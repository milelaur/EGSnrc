%L
%E
%I4
!INDENT F2;
%C80
%Q1
"*************************************************************************
"
" EGSnrc machine dependent macro file for
" linux
"
" Created by :
" EGSnrc-configure-linux version 1.0 on su helmik. 9 2020
"
" You may add your own machine dependent macros to this file,
" but be carefull to not overwrite it if you re-run
" EGSnrc-configure-linux
"
"*************************************************************************

REPLACE {$MACHINE} WITH
  {,'linux',};
REPLACE {$HEN_HOUSE} WITH
  {'/home/miia/EGSnrc/HEN_HOUSE/'};
REPLACE {$CANONICAL_SYSTEM} WITH
  {'linux64'};
REPLACE {$CONFIGURATION_NAME} WITH
  {'linux'};
REPLACE {$EGS_CONFIG} WITH
  {'/home/miia/EGSnrc/HEN_HOUSE/specs/linux.conf'};

" System dependent stuff "
"========================================"
" Unfortunately, there appears to be no reliable way of copying files "
" under Fortran => we use a system call for this"
REPLACE {$copy_file} WITH {'cp  '};

" Although one can move files using Fortran's intrinsic rename, "
" we don't know whether the user has not created additional files in "
" the temporary working directory => it is easiest to use a system call "
" to move all files from the temporary working directory to the user code "
" directory. "
REPLACE {$move_file} WITH {'mv -f '};

" There appears to be no way of removing a directory from Fortran "
" => we use a system call for this. "
REPLACE {$remove_directory} WITH {'rm -rf '};

" The directory separator "
REPLACE {$file_sep} WITH {'/'};

REPLACE {$LONG_INT} WITH { integer*8 };
REPLACE {$SHORT_INT} WITH { integer*2 };
"$MAX_INT SET TO 2^63-1 in egsnrc.macros"
"The machine byte order"
REPLACE {$BYTE_ORDER} WITH {'1234'};
;
" Record Length for unformatted I/O "
REPLACE {$RECL-FACTOR} WITH {4};
;
REPLACE {$FLUSH_UNIT(#);} WITH {call flush({P1});}
;
" If you want your user code to return an exit status, use the
" following macro to terminate execution
REPLACE {$CALL_EXIT(#);} WITH {call exit({P1});}
;
" mortran3 gets confused by the # char => we need to pass it as an "
" argument to the macro. "
REPLACE {$HAVE_C_COMPILER(#);} WITH {{EMIT;{P1}define HAVE_C_COMPILER};}
;
REPLACE {$HAVE_LOAD_DSO(#);} WITH {{EMIT;{P1}define HAVE_LOAD_DSO};}
;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc macros to read and write phase space files                          "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1999                                       "
"                                                                             "
"  Contributors:    Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Macros required to read from and write to phase space files. These macros  "
"  replace the old calls to the subroutine rw_ph_sp.mortran and any           "
"  manipulations of phase space files that were hard-coded. Currently, these  "
"  macros are used by BEAM, DOSXYZ, BEAMDP, and readphsp. The beam            "
"  configuration script looks for this file in the following directories, in  "
"  this order                                                                 "
"                                                                             "
"  $HOME/egs4/BEAM_accelerator                                                "
"  $HOME/egs4/beam                                                            "
"  $OMEGA_HOME/beam                                                           "
"                                                                             "
"  All other configuration or compile scripts only use the version of this    "
"  file in $OMEGA_HOME/beam. These macros can be used with any code provided  "
"  that this file is concatenated before any codes that use the macros.       "
"  Detailed description of what each macro does is provided at the top of     "
"  the macro.                                                                 "
"                                                                             "
"#############################################################################"


;
REPLACE {;COMIN/RWPHSP/;} WITH {
"RWPHSP must be included in the common block of main in any code that uses"
"any of these phase space macros and also in the common block of"
"any subroutine that uses any phase space macros.  Note that the macro"
"$MAX_SC_PLANES(=the max. number of scoring planes) must have been defined"
"somewhere in the code before the first use of COMIN/RWPHSP.  In the case of"
"DOSXYZ, BEAMDP and readphsp, $MAX_SC_PLANES is a dummy value, set to 1,"
"at the beginning of main.  Note that, since, IHSTRY_PHSP is a $LONG_INT"
"variable, you must have the macro REPLACE {$LONG_INT} WITH {INTEGER*8} at"
"the top of any code that uses these macros.  If your compiler has trouble"
"with INTEGER*8, use INTEGER*4 in the $LONG_INT macro."

;COMMON/RWPHSP/
   STRING_TEMP_ZLAST_OUT,
                 "holds output phsp data for up to 1000 particles, with ZLAST"
   STRING_TEMP_OUT, "holds output phsp data for up to 1000 particles, no ZLAST"
   IHSTRY_PHSP, "history number (from primary non-phase space source) of"
                "particle being scored"
   iaea_dummy_long, "used to store INTEGER*8 values temporarily"
   NHSTRY_DOS, "passed to NHSTRY in beam when this actually comes from"
               "dosxyznrc source 20"
   ESHORT,    "single precision E read from/written to phsp"
   WEIGHTTMP, "modified version of WT to be written to phsp"
   WT_PHSP_SHORT, "single precision wt read from phsp"
   X_PHSP_SHORT, "single precision x read from phsp"
   Y_PHSP_SHORT, "single precision y read from phsp"
   Z_PHSP_SHORT, "single precision Z--for iaea format only"
   U_PHSP_SHORT, "single precision u read from phsp"
   V_PHSP_SHORT, "single precision v read from phsp"
   W_PHSP_SHORT, "single precision w--for iaea format only"
   ZLAST_PHSP_SHORT, "single precision zlast read from phsp"
   MUIDX_PHSP_SHORT, "MU_INDEX--iaea phsp files only"
   EKMAX_PHSP_SHORT, "max ke of particles in phsp file"
   EKMINE_PHSP_SHORT, "min ke of electrons in phsp file"
   NINC_PHSP_SHORT, "no. of particles from original primary source"
   dosxyz2beam_index, "stores MU index passed to beam from dosxyz"
   iaea_extra_floats, "array of extra floats in IAEA phsp file"
   NUM_PHSP_TOT, "tot no of particles in phsp file"
   PHOT_PHSP_TOT,"no. of photons in phsp file"
   iaea_result,  "<0 if an error finding an available array index for IAEA"
                 "phsp file"
   iaea_n_stat,  ">=1 if a new primary history is scoring, 0 otherwise"
   iaea_q_typ,    "array to convert from charge to IAEA type"
   iaea_typ_q,   "array to convert from IAEA type to charge"
   iaea_q_index, "array index"
   I_PHSP,    "loop counter"
   IERR_PHSP, "=0 if open/read okay ~=0 if not okay"
   LATCHTMP,  "modified version of LATCH to be written to phsp"
   WRITE_PHSP_COUNTER, "counter up to 1000 used for group write"
   WRITE_PHSP_SOFAR, "how many particles written so far to file"
   PHSP_RESTART, "set to 1 if this is a restart"
   PHSP_RECL, "the record length"
   PHSP_RECL_OLD, "saves record length"
   iaea_extra_ints, "array in which LATCH will be stored for iaea format"
   iaea_extra_int_types,iaea_extra_float_types, "returns the types of"
                    "extra int and float variables in an IAEA phsp file"
   iaea_i_zlast,"index of iaea_extra_floats in which Zlast is stored for IAEA"
           "phsp files read IN"
   iaea_i_latch,"index of iaea_extra_int in which LATCH is stored for IAEA"
           "phsp files read IN"
   iaea_i_muidx,"index of iaea_extra_floats in which MU_INDEX is stored for"
           "IAEA phsp files read IN"
   iaea_n_extra_ints, "no. of extra ints stored in IAEA phsp file read IN"
   iaea_n_extra_floats, "no. of extra floats stored in IAEA phsp file read IN"
   i_iaea_open_for_write, "set to 1 if the macro IAEA_OPEN_FOR_WRITE"
                          "was used"
   iaea_i_zlast_out,"index of iaea_extra_floats in which Zlast is stored for"
               " IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
   iaea_i_latch_out,"index of iaea_extra_int in which LATCH is stored for IAEA"
           "phsp written OUT by BEAMnrc or DOSXYZnrc"
   iaea_i_muidx_out,"index of iaea_extra_floats in which MU_INDEX is stored"
           " for IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
   dosxyz2beam_izscore, "set to 1 if Z scored for each particle (IAEA only)"
   MODE_RW;   "mode of phsp file (0 with ZLAST, 2 without), writing only"

CHARACTER*32000 STRING_TEMP_ZLAST_OUT($MAX_SC_PLANES);
CHARACTER*28000 STRING_TEMP_OUT($MAX_SC_PLANES);
$LONG_INT IHSTRY_PHSP($MAX_SC_PLANES),iaea_dummy_long,NHSTRY_DOS;
REAL*4 ESHORT,WEIGHTTMP,WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
       Z_PHSP_SHORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,ZLAST_PHSP_SHORT,
       MUIDX_PHSP_SHORT,
       EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT,dosxyz2beam_index,
       iaea_extra_floats(10);
INTEGER NUM_PHSP_TOT,PHOT_PHSP_TOT,
        iaea_result,iaea_n_stat,iaea_q_typ(3),iaea_typ_q(3),iaea_q_index,I_PHSP,
        IERR_PHSP,LATCHTMP,
        WRITE_PHSP_COUNTER($MAX_SC_PLANES),WRITE_PHSP_SOFAR($MAX_SC_PLANES),
        PHSP_RESTART,PHSP_RECL,PHSP_RECL_OLD,iaea_extra_ints(10),
        iaea_extra_int_types(10),iaea_extra_float_types(10),iaea_i_zlast,
        iaea_i_latch,iaea_i_muidx,iaea_n_extra_ints,iaea_n_extra_floats,
        i_iaea_open_for_write,iaea_i_zlast_out,iaea_i_latch_out,
        iaea_i_muidx_out,dosxyz2beam_izscore;
CHARACTER*5 MODE_RW;

"variables below are not part of the common block but are used locally"
"by the $WRITE_PHSP, $WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros"

INTEGER LATCH_TEMP_OUT,NUM_PHSP_TOFLUSH,TEMP_PHSP_COUNTER,REM_PHSP;
REAL*4 REAL_TEMP_OUT(7);
CHARACTER*32 REC_TEMP_OUT;

}
;

REPLACE {$INITIALIZE_PHSP_VARIABLES;} WITH{;
"Must be placed after the variable declarations in any subroutine"
"where $WRITE_PHSP and/or $WRITE_PHSP_RECORD is used.  Note, though, that"
"it does not necessarily have to be put at the top of main, unless one or"
"both of these macros are used in main."
"It equivalences the character string REC_TEMP_OUT with the phase space data"
"for 1 particle. REC_TEMP_OUT is then used to fill the character array"
"STRING_TEMP_(ZLAST_)OUT, which holds the phase space data in blocks of 1000"
"particles before writing."

EQUIVALENCE(REC_TEMP_OUT(1:4),LATCH_TEMP_OUT);
EQUIVALENCE(REC_TEMP_OUT(5:8),REAL_TEMP_OUT(1));
EQUIVALENCE(REC_TEMP_OUT(9:12),REAL_TEMP_OUT(2));
EQUIVALENCE(REC_TEMP_OUT(13:16),REAL_TEMP_OUT(3));
EQUIVALENCE(REC_TEMP_OUT(17:20),REAL_TEMP_OUT(4));
EQUIVALENCE(REC_TEMP_OUT(21:24),REAL_TEMP_OUT(5));
EQUIVALENCE(REC_TEMP_OUT(25:28),REAL_TEMP_OUT(6));
EQUIVALENCE(REC_TEMP_OUT(29:32),REAL_TEMP_OUT(7));
}
;

REPLACE {$INIT_PHSP_COUNTERS;} WITH {;
"This macro initializes counters and flags that are used by the"
"$WRITE_PHSP/$WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros.  It is only"
"used once and should be placed after the variable declarations in main."

DO I_PHSP=1,$MAX_SC_PLANES[
  WRITE_PHSP_COUNTER(I_PHSP)=0;
  WRITE_PHSP_SOFAR(I_PHSP)=0;
  IHSTRY_PHSP(I_PHSP)=0;
]
PHSP_RESTART=0;
PHSP_RECL_OLD=0;

iaea_q_typ(1)=2;iaea_q_typ(2)=1;iaea_q_typ(3)=3;
iaea_typ_q(1)=0;iaea_typ_q(2)=-1;iaea_typ_q(3)=1;

iaea_n_extra_ints=0;iaea_n_extra_floats=0;

iaea_i_zlast=-99;iaea_i_latch=-99;iaea_i_muidx=-99;

i_iaea_open_for_write=0;

iaea_i_zlast_out=-99;iaea_i_latch_out=-99;iaea_i_muidx_out=-99;

}
;


REPLACE {$GET_E_NPASS_IQ(#,#,#,#);} WITH {;
"Macro gets NPASS, IQ from the LATCH value read in and then restores LATCH"
"by clearing the bits that store this information.  It also puts the"
"single precision energy, ESHORT, read in into double precision form."
"This macro is called by $READ_PHSP."

"Input parameters:"
"{P1}=NPASS"
"{P2}=IQ"
"{P3}=LATCH"
"{P4}=E"

{P4}=ESHORT;

IF($BTEST({P3},31)) [ {P1} = 1; {P3} = $IBCLR({P3},31); ]
ELSE [ {P1} = 0; ]

IF($BTEST({P3},30)) [
    {P2} = -1;
    {P3} = $IBCLR({P3},30); {P3} = $IBCLR({P3},29);
]
ELSE [
       IF($BTEST({P3},29)) [
          {P2} = 1; {P3} = $IBCLR({P3},29);
       ]
       ELSE [ {P2} = 0; ]
]
}
;

REPLACE {$GET_W_WT(#,#,#,#,#,#);} WITH {;
"This macro calculates W, based on U and V and the sign of WT as read in from"
"the phase space file.  Once the sign of WT is determined, WT is set equal"
"to its absolute value, since there cannot be a negative particle weight."
"This macro is called by $READ_PHSP."

"Input parameters:"
"{P1}=W"
"{P2}=WT"
"{P3}=X"
"{P4}=Y"
"{P5}=U"
"{P6}=V"

{P1} = min( 1., {P5}**2 + {P6}**2);
{P1} = sqrt(1. - {P1});
{P1} = SIGN({P1},{P2});  "This transfers sign of WT to W"

{P2}=ABS({P2}); "WT is always positive"

}
;

REPLACE {$PARSE_PHSP_RECORD(#,#,#,#);} WITH {;
"macro used by READ_PHSP_RECORD to put single precision x, y, u, v"
"read from phase space file into (potentially) double precision"
"x, y, u, v passed to READ_PHSP_RECORD macro"

"Input parameters:"
"{P1}=X"
"{P2}=Y"
"{P3}=U"
"{P4}=V"

{P1}=X_PHSP_SHORT;
{P2}=Y_PHSP_SHORT;
{P3}=U_PHSP_SHORT;
{P4}=V_PHSP_SHORT;
}
;

REPLACE {$READ_PHSP_RECORD(#,#,#:#,#,#,#,#,#);} WITH {;
"Note that a colon is required  ^  between the third and fourth"
"input parameters."
"This macro actually reads the phase space data for a single particle."
"It is called by $READ_PHSP, but can also be used as a stand-alone macro."
"If the energy, E, is < 0.0, then this is the first particle scored"
"from a new primary (ie non-phsp source) history, and NHSTRY is incremented"
"and E is set to ABS(E)."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number"
"{P3}=record number"
"{P4}=NHSTRY"
"{P5}=ZLAST"
"{P6}=LATCH"
"{P7}=E"
"{P8}=WT"
"{P9}=X,Y,U,V"

IF({P1}~=0)["must read in ZLAST"
  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT,ZLAST_PHSP_SHORT;
]
ELSE["no ZLAST"
  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT;
]

IF({P3}=76695869)[
   write(*,*)' x,y,u,v,wt,eshort,latch',
 X_PHSP_SHORT,Y_PHSP_SHORT,U_PHSP_SHORT,V_PHSP_SHORT,
WT_PHSP_SHORT,ESHORT,{P6};
]

"first particle from new primary history"
IF(ESHORT<0.0)[
  {P4}={P4}+1;
  ESHORT=ABS(ESHORT);
]

{P7}=ESHORT;
{P8}=WT_PHSP_SHORT;
$PARSE_PHSP_RECORD({P9});

IF({P1}~=0) {P5}=ZLAST_PHSP_SHORT;

}
;

REPLACE {$READ_PHSP_RECORD_ENEGATIVE(#,#,#:#,#,#,#,#);} WITH {;
"Note that a colon is required            ^  between the third and fourth"
"input parameters."
"This macro is the similar to $READ_PHSP_RECORD above, but it preserves"
"the -E marker in the phase space file and does not advance NHSTRY"
"It is only used in readphsp before byte swapping"

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number"
"{P3}=record number"
"{P4}=ZLAST"
"{P5}=LATCH"
"{P6}=E"
"{P7}=WT"
"{P8}=X,Y,U,V"

IF({P1}~=0)["must read in ZLAST"
  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7},{P4};
]
ELSE["no ZLAST"
  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7};
]

}
;

REPLACE {$READ_PHSP(#:#,#,#,#,#,#,#,#);} WITH {;
"Note colon          ^  required between the first and second"
"input parameters (third and fourth input variables)"

"This macro reads the phase space data for a single particle.  It finds"
"the value of IQ and NPASS from the LATCH variable read in and then"
"restores the LATCH variable.  It calculates W from U, V and the sign"
"of WT and then restores WT to its absolute value.  And it puts the"
"single-precision energy, ESHORT, read in into double-precision format."
"If ESHORT is < 0, it sets E=ABS(ESHORT) and increments NHSTRY, taking"
"this as the first particle scored from a new primary history."

"Input parameters:"
"{P1}=IZLAST,unit number for phase space file,record number reading from"
"{P2}=NHSTRY"
"{P3}=NPASS"
"{P4}=IQ"
"{P5}=W"
"{P6}=ZLAST"
"{P7}=LATCH"
"{P8}=E"
"{P9}=WT,X,Y,U,V"

$READ_PHSP_RECORD({P1}:{P2},{P6},{P7},{P8},{P9});

IF(IERR_PHSP=0)[
  $GET_E_NPASS_IQ({P3},{P4},{P7},{P8});
  $GET_W_WT({P5},{P9});
]

}
;

REPLACE {$GET_LATCHTMP_ESHORT_WEIGHTTMP(#,#,#,#,#,#);} WITH {;
"This macro converts LATCH into LATCHTMP, which stores NPASS and IQ"
"for a particle and is the form of LATCH written to the phase space file."
"It puts double precision energy, E, into single precision format, ESHORT,"
"for writing to the phase space file.  This macro is called from $READ_PHSP"

"Input parameters:"
"{P1}=NPASS"
"{P2}=IQ"
"{P3}=W"
"{P4}=LATCH"
"{P5}=E"
"{P6}=WT"

LATCHTMP={P4};

IF({P1} = 0) [ LATCHTMP = $IBCLR(LATCHTMP,31); ]
ELSE [ LATCHTMP = $IBSET(LATCHTMP,31); ]

IF({P2} = -1) [ LATCHTMP = $IBSET(LATCHTMP,30);]
ELSEIF({P2} = 0) [
     LATCHTMP = $IBCLR(LATCHTMP,30);
     LATCHTMP = $IBCLR(LATCHTMP,29);
]
ELSE [
     LATCHTMP = $IBCLR(LATCHTMP,30);
     LATCHTMP = $IBSET(LATCHTMP,29);
]

ESHORT={P5};

WEIGHTTMP=SIGN({P6},{P3});"transfer sign of W to WEIGHTTMP"

}
;

REPLACE {$SET_NEGATIVE_E(#,#,#,#);} WITH {;
"Macro to set E to -E if this is the first particle scored from a new"
"primary (non-phsp source) history.  This macro is called from"
"$WRITE_PHSP_RECORD."

"Input parameters"
"{P1}=phase space scoring plane no."
"{P2}=IHSTRY"
"{P3}=E"
"{P4}=WT,X,Y,U,V"

IF({P2}~=IHSTRY_PHSP({P1}))[
  {P3}=-{P3};
  IHSTRY_PHSP({P1})={P2};
]

}
;

REPLACE {$PARSE_TEMP_FOR_WRITE(#,#,#,#,#,#,#,#,#);} WITH {;
"Macro to store the output phase space data for one particle in the"
"variables LATCH_TEMP_OUT and REAL_TEMP_OUT.  These variables are"
"equivalenced to the string variable REC_TEMP_OUT, which stores the"
"phase space for one particle in string form and which, in turn, is"
"used to transfer the data to the string variable STRING_TEMP(_ZLAST)_OUT"
"which stores output phase space data for up to 1000 particles at a time."
"This macro is called from $WRITE_PHSP_RECORD."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=ZLAST"
"{P3}=LATCH"
"{P4}=E"
"{P5}=WT"
"{P6}=X"
"{P7}=Y"
"{P8}=U"
"{P9}=V"

LATCH_TEMP_OUT={P3};
REAL_TEMP_OUT(1)={P4};
REAL_TEMP_OUT(2)={P6};
REAL_TEMP_OUT(3)={P7};
REAL_TEMP_OUT(4)={P8};
REAL_TEMP_OUT(5)={P9};
REAL_TEMP_OUT(6)={P5};
IF({P1}~=0) REAL_TEMP_OUT(7)={P2};

}
;

REPLACE {$WRITE_PHSP_RECORD(#,#,#,#,#:#,#,#,#);} WITH {;
"Note that a colon is required       ^  between the fifth and sixth"
"input parameters"

"This macro is used to output phase space data 1000 particles at a time."
"For every particle, the phase space data to be output is stored in"
"the string variable STRING_TEMP(_ZLAST)_OUT.  If it is the 1000th particle"
"STRING_TEMP(_ZLAST)_OUT is written to the phase space file.  The phase"
"space header info is considered to occupy the space of 1 particle in the"
"first block of 1000 particles, however, it will be overwritten with nulls."
"This is fine since the header info should be recalculated and rewritten at"
"the top of the file after all data has been written out anyway."
"Also note that restarting with this writing scheme requires that any"
"blocks of N (N<1000) particles at the end of a phase space file from"
"the previous run must immediately be read into the first N spaces of"
"STRING_TEMP(_ZLAST)_OUT before continuing on with outputting the data"
"for new particles.  Finally, after all phase space data has been output,"
"there will probably be info for M (M<1000) particles still in"
"STRING_TEMP(_ZLAST)_OUT that has not been written to the phase space file"
"because the write counter did not reach 1000.  These are output using"
"the $PHSP_BUFFER_FLUSH macro described below."

"Group writing reduces network traffic and saves a lot of time when the"
"one of the main CPU-intensive activities is the writing of phase space data."
"Group reading has also been considered, but preliminary studies have shown"
"that it does not reduce CPU time significantly."

"Using the macro $SET_NEGATIVE_E, $WRITE_PHSP_RECORD also takes care of setting"
"E to -E if this is the first particle scored from a new primary"
"(non-phsp source) history."

"This macro is called by $WRITE_PHSP, but can also be used as a stand-"
"alone macro.  However, use of $WRITE_PHSP_RECORD, will always require"
"use of $PHSP_BUFFER_FLUSH (see below)."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number for phase space file"
"{P3}=name of phase space file"
"{P4}=record number writing to"
"{P5}=scoring plane number"
"{P6}=IHSTRY"
"{P7}=ZLAST"
"{P8}=LATCH"
"{P9}=E,WT,X,Y,U,V"

IF({P4}>2 & WRITE_PHSP_COUNTER({P5})=0 & WRITE_PHSP_SOFAR({P5})=0)[
   "we have a restart or its the start of a new batch"
   IF(({P4}-1)-1000*(({P4}-1)/1000)~=0)[
   "make what was the buffer flush part of the first record of the restart"
    CLOSE({P2});
    IF({P1}~=0)["have ZLAST"
      PHSP_RECL=$RECL-FACTOR*8;
      OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
           FORM='UNFORMATTED',STATUS='UNKNOWN');
      DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
         READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
               STRING_TEMP_ZLAST_OUT({P5})(32*(I_PHSP-1)+1:32*I_PHSP);
      ]
      CLOSE({P2});
      PHSP_RECL=$RECL-FACTOR*8000;
      OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
           FORM='UNFORMATTED',STATUS='UNKNOWN');
    ]
    ELSE["no ZLAST"
      PHSP_RECL=$RECL-FACTOR*7;
      OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
           FORM='UNFORMATTED',STATUS='UNKNOWN');
      DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
         READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
               STRING_TEMP_OUT({P5})(28*(I_PHSP-1)+1:28*I_PHSP);
      ]
      CLOSE({P2});
      PHSP_RECL=$RECL-FACTOR*7000;
      OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
           FORM='UNFORMATTED',STATUS='UNKNOWN');
    ]
   ]
   WRITE_PHSP_SOFAR({P5})=1000*INT(dble({P4}-1)/1000);
   IF(WRITE_PHSP_SOFAR({P5})>0)[
       PHSP_RESTART=1;
       WRITE_PHSP_COUNTER({P5})=({P4}-1)-1000*(({P4}-1)/1000);
   ]
   ELSE[
       WRITE_PHSP_COUNTER({P5})=({P4}-2)-1000*(({P4}-2)/1000);
   ]
]

$SET_NEGATIVE_E({P5},{P6},{P9});

$PARSE_TEMP_FOR_WRITE({P1},{P7},{P8},{P9});

IF({P4}<=1000 & PHSP_RESTART=0)["do not use first 7/8 elements"
   IF({P1}~=0)["have ZLAST"
     STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+33:
       32*WRITE_PHSP_COUNTER({P5})+64)=REC_TEMP_OUT(1:32);
   ]
   ELSE["no ZLAST"
     STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+29:
       28*WRITE_PHSP_COUNTER({P5})+56)=REC_TEMP_OUT(1:28);
   ]
]
ELSE[
   IF({P1}~=0)[
     STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+1:
       32*WRITE_PHSP_COUNTER({P5})+32)=REC_TEMP_OUT(1:32);
   ]
   ELSE["no ZLAST"
     STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+1:
       28*WRITE_PHSP_COUNTER({P5})+28)=REC_TEMP_OUT(1:28);
   ]
]

WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;

IF({P4}=1000|WRITE_PHSP_COUNTER({P5})=1000)[
   IF({P1}~=0 & PHSP_RECL=$RECL-FACTOR*8)[
     CLOSE({P2});
     PHSP_RECL_OLD=PHSP_RECL;
     PHSP_RECL=$RECL-FACTOR*8000;
     OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
          FORM='UNFORMATTED',STATUS='UNKNOWN');
   ]
   ELSEIF({P1}=0 & PHSP_RECL=$RECL-FACTOR*7)[
     PHSP_RECL_OLD=PHSP_RECL;
     CLOSE({P2});
     PHSP_RECL=$RECL-FACTOR*7000;
     OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
          FORM='UNFORMATTED',STATUS='UNKNOWN');
   ]
   IF({P1}~=0)[
     WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_ZLAST_OUT({P5});
   ]
   ELSE["no ZLAST"
     WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_OUT({P5});
   ]
   IF(PHSP_RECL_OLD~=0)[
     "have to do this in case the output file=input file"
     PHSP_RECL=PHSP_RECL_OLD;
     CLOSE({P2});
     OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
          FORM='UNFORMATTED',STATUS='UNKNOWN');
   ]
   WRITE_PHSP_COUNTER({P5})=0;
   WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+1000;
]

}
;

REPLACE {$PHSP_BUFFER_FLUSH(#,#,#,#,#);} WITH {;
"This macro outputs the data for the M (M<1000) remaining particles still"
"stored in STRING_TEMP(_ZLAST)_OUT after all calls to $WRITE_PHSP_RECORD."
"The macro does not flush all of the data at once, but in blocks that"
"divide exactly into the number of particles already in the phase space"
"file.  For each block that is flushed, the phase space file is re-opened"
"with a record length (RECL) equal to the size of the block.  Since RECL"
"divides exactly into the number of particles already in the file, the"
"block to be flushed can be appended onto the data that already exists in"
"the file with no overwrites and/or blank space."
"The other alternative was to flush STRING_TEMP(_ZLAST)_OUT one particle at"
"a time, which is more time-consuming."
"$PHSP_BUFFER_FLUSH must exist in a code that uses $WRITE_PHSP or"
"$WRITE_PHSP_RECORD.  It should be placed on its own outside the loop in which"
"phase space data is output.  In the case of BEAM, it is placed at the end"
"of each batch, so that, if the simulation crashes, phase space information"
"from the last batch is not lost."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number for phase space file"
"{P3}=file name"
"{P4}=particle number +1"
"{P5}=scoring plane number"
TEMP_PHSP_COUNTER=0;
NUM_PHSP_TOFLUSH=WRITE_PHSP_COUNTER({P5});
IF(NUM_PHSP_TOFLUSH>0)[
  IF(WRITE_PHSP_SOFAR({P5})=0)[
      WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;
      NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH+1; "account for header"
  ]
  LOOP[
    TEMP_PHSP_COUNTER=NUM_PHSP_TOFLUSH+1;
    LOOP[
      TEMP_PHSP_COUNTER=TEMP_PHSP_COUNTER-1;
      REM_PHSP=MOD(WRITE_PHSP_SOFAR({P5}),TEMP_PHSP_COUNTER);
    ]UNTIL(REM_PHSP=0);
    CLOSE({P2});
    IF({P1}~=0)["write ZLAST"
      PHSP_RECL=$RECL-FACTOR*8*TEMP_PHSP_COUNTER;
      OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
           ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
      WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
             STRING_TEMP_ZLAST_OUT({P5})
    (32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
     32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
    ]
    ELSE["no ZLAST"
      PHSP_RECL=$RECL-FACTOR*7*TEMP_PHSP_COUNTER;
      OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
           ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
      WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
             STRING_TEMP_OUT({P5})
    (28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
     28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
    ]
    WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+TEMP_PHSP_COUNTER;
    NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH-TEMP_PHSP_COUNTER;
 ] UNTIL(NUM_PHSP_TOFLUSH=0);
 WRITE_PHSP_COUNTER({P5})=0;
 WRITE_PHSP_SOFAR({P5})=0;
]
;
}
;

REPLACE {$WRITE_PHSP(#:#,#,#,#,#,#,#:#);} WITH {;
"Note that colons     ^             ^  are required between the first and"
"second input parameters (5th and 6th input variables) and the"
"8th and 9th input parameters (13th and 14th input variables)"

"This outputs phase space data in blocks of 1000 particles at a time."
"In preparation for output, LATCH is modified to hold NPASS and IQ,"
"energy (E) is placed into a single precision variable, ESHORT, and"
"weight (WT) is given the sign of W.  If this is the first particle"
"scored from a new primary (non-phase space source) history, then"
"ESHORT is set to -ESHORT and IHSTRY_PHSP is set to IHSTRY."

"Input parameters:"
"{P1}=IZLAST,unit number for phase space file,name of phase space file,"
"     record number writing to, scoring plane number"
"{P2}=IHSTRY"
"{P3}=NPASS"
"{P4}=IQ"
"{P5}=W"
"{P6}=ZLAST"
"{P7}=LATCH"
"{P8}=E,WT"
"{P9}=X,Y,U,V"

$GET_LATCHTMP_ESHORT_WEIGHTTMP({P3},{P4},{P5},{P7},{P8});

$WRITE_PHSP_RECORD({P1}:{P2},{P6},LATCHTMP,ESHORT,WEIGHTTMP,{P9});

}
;

REPLACE {$READ_PHSP_HEADER(#,#,#,#,#,#,#);} WITH {;
"This macro reads the info from the header of a phase space file."
"It is called from $OPEN_PHSP_FILE_FOR_WRITE, but can also be used"
"as a stand-alone macro."

"Input parameters:"
"{P1}=unit number"
"{P2}=MODE0 or MODE2"
"{P3}=total number of particles"
"{P4}=no. of photons"
"{P5}=max k.e. of particles"
"{P6}=min. k.e. of electrons"
"{P7}=no. of particles incident from original source"

READ({P1},REC=1,IOSTAT=IERR_PHSP){P2},NUM_PHSP_TOT,PHOT_PHSP_TOT,
EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
{P3}=NUM_PHSP_TOT;
{P4}=PHOT_PHSP_TOT;
{P5}=EKMAX_PHSP_SHORT;
{P6}=EKMINE_PHSP_SHORT;
{P7}=NINC_PHSP_SHORT;

IF(IERR_PHSP~=0)[
   OUTPUT;(//' ***ERROR READING HEADER OF PHASE SPACE FILE*** '//);
   STOP;
]
}
;

REPLACE {$OPEN_PHSP_FOR_READ(#,#,#,#,#);} WITH {;
"Macro to open a phase space file in preparation for reading it."
"The macro opens the file in one of 3 modes, as a file that is known"
"to have ZLAST (IZLAST>0), as a file that is known not to have ZLAST"
"(IZLAST=0), or with no prior knowledge of whether the file has"
"ZLAST or not (IZLAST<0)."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number"
"{P3}=file name"
"{P4}=MODE0 or MODE2"
"{P5}=total number of particles, no. of photons, max k.e. of particles,"
"      min. k.e. of electrons, no. of particles incident from original source"

IF({P1}>0)["with ZLAST"
   PHSP_RECL=$RECL-FACTOR*8;
   OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
        RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
   IF(IERR_PHSP~=0)[
        "error above on file opening when assumed it was MODE2"
         OUTPUT;(/' ***error opening file as MODE2 ****'
        /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE2 FILE) ***'/
        /' *** WE NOW TRY TO OPEN IT AS A MODE3 FILE ***'//);
         OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
              FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
        "if on error, cannot find file/directory, then stop"
        IF(IERR_PHSP~=0)[
          ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
          STOP;
        ]
        $READ_PHSP_HEADER({P2},{P4},{P5});
        IF({P4} ~= 'MODE3')[
          OUTPUT;(//' That file does not start with MODE3,',
          ' as all old compressed files (with ZLAST) must'/
          '  Check it out and try again!'///);
          IERR_PHSP=1;
          STOP;
        ]
        ELSE[
          OUTPUT;(//' This is a MODE3 file! '/
          ' Please convert it into a MODE2 file using [readphsp] ',
          ' and try again!'///);
           IERR_PHSP=1;
           STOP;
        ]
   ]
   $READ_PHSP_HEADER({P2},{P4},{P5});
   IF({P4} ~= 'MODE2')[
       OUTPUT;(//' That file does not start with MODE2,',
          ' as standard compressed files with ZLAST must'/
          '  Check it out and try again!'///);
        IERR_PHSP=1;
        STOP;
   ]
]
ELSEIF({P1}=0)["without ZLAST"
   PHSP_RECL=$RECL-FACTOR*7;
   OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
        RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
    "$RECL-FACTOR = 4 for SUN SPARC and =1 for SILICON GRAPHICS "
    "this factor is machine-dependent and stored in machine.mortran"
    "check file is MODE0 -ie standard compressed"
   IF(IERR_PHSP~=0)[
    "come here if error opening file assumed MODE0"
      OUTPUT;(/' ***ERROR opening file as MODE0****'
      /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE0 FILE) ***'/
      /' *** WE NOW TRY TO OPEN IT AS A MODE1 FILE ***'//);
      OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
       FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
      "if on error, cannot find file/directory, then stop"
      IF(IERR_PHSP~=0)[
        ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
          STOP;
      ]
      $READ_PHSP_HEADER({P2},{P4},{P5});
      IF({P4} ~= 'MODE1')[
        OUTPUT;(//' That file does not start with MODE1,',
        ' as all old compressed files must'/
        '  Check it out and try again!'///);
        IERR_PHSP=1;
        STOP;
      ]
      ELSE[
        OUTPUT;(//' This is a MODE1 file! '/
       ' Please convert it into a MODE0 file using [readphsp] ',
       'and try again!'///);
         IERR_PHSP=1;
         STOP;
      ]
   ]
   $READ_PHSP_HEADER({P2},{P4},{P5});
   IF({P4} ~= 'MODE0')[
          OUTPUT;
            (/' Does not start with MODE0 as files without ZLAST must'/
          '  Try again!'//);
          IERR_PHSP=1;
          STOP;
   ]
]
ELSEIF({P1}<0)["open with no assumptions about whether ZLAST is there or not"
   OUTPUT;(/' First, try to open it as a MODE0 file');
   PHSP_RECL=$RECL-FACTOR*7;
   OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
        RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
   IF(IERR_PHSP~=0)[
     OUTPUT;(/' Now try to open it as a MODE2 file');
     {P1}=1;
     PHSP_RECL=$RECL-FACTOR*8;
     OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
        RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
     IF(IERR_PHSP~=0)[
        ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
     ]
     ELSE[
        $READ_PHSP_HEADER({P2},{P4},{P5});
        IF({P4}~='MODE2')[
            OUTPUT;(//' That file does not start with MODE2,',
          ' as standard compressed files with ZLAST must'/
          '  Check it out and try again!'///);
          CLOSE({P2});
          STOP;
        ]
     ]
   ]
   ELSE[
     $READ_PHSP_HEADER({P2},{P4},{P5});
     {P1}=0;
     IF({P4}~='MODE0')[
       OUTPUT;(/' The file does not start with MODE0 as it supposed to');
       CLOSE({P2});
       OUTPUT;(/' Now try to open it as a MODE2 file');
       {P1}=1;
       PHSP_RECL=$RECL-FACTOR*8;
       OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
           RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
       IF(IERR_PHSP~=0)[
         ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE OPENED. ***');
       ]
       ELSE[
          $READ_PHSP_HEADER({P2},{P4},{P5});
          IF({P4}~='MODE2')[
              OUTPUT;(//' That file does not start with MODE2,',
            ' as standard compressed files with ZLAST must'/
            '  Check it out and try again!'///);
            CLOSE({P2});
            STOP;
          ]
       ]
     ]
   ]
]
}
;

REPLACE {$PARSE_PHSP_HEADER_FOR_WRITE(#,#,#,#,#);} WITH {;
"Puts max ke of particles, min ke of electrons, and no. of particles"
"incident from original source--all of which may be double precision"
"into real*4 variables"
"{P1}=tot. no. of particles"
"{P2}=no. of photons"
"{P3}=max ke of particles"
"{P4}=min ke of electrons"
"{P5}=no. of particles incident from primary source"
IF({P1}>2147483647)[
  write(*,*)' Warning while writing phase space file:';
  write(*,*)' No. of particles > 2^31-1.';
  write(*,*)' Total no. of particles (and photons) written';
  write(*,*)' to header may be nonsense.';
]
NUM_PHSP_TOT={P1};
PHOT_PHSP_TOT={P2};
EKMAX_PHSP_SHORT={P3};
EKMINE_PHSP_SHORT={P4};
NINC_PHSP_SHORT={P5};
}

REPLACE {$WRITE_PHSP_HEADER(#,#,#,#,#);} WITH {;
"Macro to write the header information into a phase space file."
"Files must be closed and re-opened with record length (RECL) for"
"a single particle in order to prevent over-writing any particle data."
"Once the header info is written, the file is closed again and re-opened"
"with the RECL for 1000 particles."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number"
"{P3}=file name"
"{P4}=MODE0 or MODE2"
"{P5}=total number of particles, no. of photons, max k.e. of particles,"
"      min. k.e. of electrons, no. of particles incident from original source"

CLOSE({P2});
IF({P1}~=0)["have ZLAST"
  PHSP_RECL=$RECL-FACTOR*8;
]
ELSE["no ZLAST"
  PHSP_RECL=$RECL-FACTOR*7;
]
OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
       FORM='UNFORMATTED',STATUS='UNKNOWN');
$PARSE_PHSP_HEADER_FOR_WRITE({P5});
WRITE({P2},REC=1){P4},NUM_PHSP_TOT,PHOT_PHSP_TOT,EKMAX_PHSP_SHORT,
EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
CLOSE({P2});
IF({P1}~=0)["have ZLAST"
  PHSP_RECL=$RECL-FACTOR*8000;
]
ELSE["no ZLAST"
  PHSP_RECL=$RECL-FACTOR*7000;
]
OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
       FORM='UNFORMATTED',STATUS='UNKNOWN');
}
;


REPLACE {$OPEN_PHSP_FOR_WRITE(#,#,#,#);} WITH {;
"This macro opens a phase space file for writing.  The file is opened with"
"a record length that will hold phase space data for 1000 particles in 1"
"record.  This is to to enable writing phase space data for 1000 particles"
"at a time (see the $WRITE_PHSP_RECORD macro above).  The macro also uses"
"$WRITE_PHSP_HEADER to output a dummy header to the file."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number"
"{P3}=file name"
"{P4}=MODE_RW"
IF({P1}~=0)["with ZLAST"
   {P4}='MODE2';
   PHSP_RECL=$RECL-FACTOR*8000;
]
ELSE["no ZLAST"
   {P4}='MODE0';
   PHSP_RECL=$RECL-FACTOR*7000;
]
OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
        FORM='UNFORMATTED',STATUS='UNKNOWN');
$WRITE_PHSP_HEADER({P1},{P2},{P3},{P4},0,0,0,0,0);
}
;

REPLACE {$CLOSE_PHSP(#);} WITH {;
"Macro to close a phase space file."

"Input parameter:"
"{P1}=the unit number of the phase space file"

CLOSE(UNIT={P1});
}
;
/*****************************************************************************
 *
 *  Empty replacement macros for reading/writing IAEA format phase space
 *  files in case the IAEA C++ utility codes for handling phase space data
 *  are unavailable.  Otherwise, these empty macros are superseded by those
 *  in $HEN_HOUSE/utils/iaea_phsp_macros.mortran by including
 *  $HEN_HOUSE/utils/iaea_phsp_macros.mortran AFTER
 *  $HEN_HOUSE/utils/phsp_macros.mortran when building the code that is
 *  to be Mortran compiled.
 *
 ****************************************************************************/

REPLACE {$IAEA_OPEN_PHSP_FOR_WRITE(#,#,#,#,#,#,#);} WITH {;

OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
           ' space handling macros.'//);
}
;

REPLACE {$IAEA_OPEN_PHSP_FOR_READ(#,#);} WITH {;

OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
           ' space handling macros.'//);
}
;
REPLACE {$IAEA_WRITE_PHSP_RECORD(#,#,#,#,#,#,#,#);} WITH {;}

REPLACE {$IAEA_READ_PHSP_HEADER(#,#,#,#,#,#,#,#,#);} WITH {;}

REPLACE {$IAEA_SET_PHSP_RECORD(#,#);} WITH {;}

REPLACE {$IAEA_READ_PHSP_RECORD(#,#,#,#,#,#,#);} WITH {;}

REPLACE {$IAEA_DESTROY_PHSP_FILE(#);} WITH {;}

REPLACE {$IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(#,#);} WITH {;}

REPLACE {$IAEA_UPDATE_PHSP_HEADER(#);} WITH {;}

REPLACE {$IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(#);} WITH {;}


/*****************************************************************************
 *
 *  Macros that combine phsp read/write macros and code around them
 *  into simpler macros for use in BEAM.
 *  The idea is that one could replace such macros with something else.
 *
 ****************************************************************************/

REPLACE {$BEAM_OPEN_PHSP_FOR_WRITE;} WITH {;
    IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
    ELSE                  [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
                          "AUNIT is a character variable"
    "construct phase space file name."
    "part of this--the part that determines the directory and"
    "file prefix--is done in beam"
    IF(IO_OPT=4)[
       phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
       Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
       $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            IZLAST,0,Z_SCORE_SHORT,I_MU_PHSP,0);
    ]
    ELSE[
       phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
       $OPEN_PHSP_FOR_WRITE(IZLAST,IOUTFLU(I),$cstring(phsp_fn),MODE_RW);
    ]
};

REPLACE {$BEAM_OPEN_PHSP_FOR_READ;} WITH {;
    OUTPUT;
    (/' Restarting after previous run, will read old data & phase-space',
      ' files');
    DO I=1,NSC_PLANES [
        OUTPUT IOUTFLU(I);(//' Checking ph-sp file on logical unit ',I4);
        :OPEN_MODE0:;
        IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
        ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
        IF(IO_OPT=4)[
          phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
          Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
          $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            IZLAST,1,Z_SCORE_SHORT,I_MU_PHSP,0);
        ]
        ELSE[
          phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;

          $OPEN_PHSP_FOR_READ(IZLAST,IOUTFLU(I),$cstring(phsp_fn),
           MODE_RW,NPPHSPSP,NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);

           NPPHSP(I)=NPPHSPSP;
        ]
     ]
};

REPLACE {$BEAM_WRITE_PHSP;} WITH {;
    IF(IOUTFLU(ISCORE)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(ISCORE)-43;]
    ELSE                       [WRITE(AUNIT,'(I1)') IOUTFLU(ISCORE)-43;]

    "output directory and file prefix are defined in beam.mortran"

    IF(IO_OPT=4)[
      $IAEA_WRITE_PHSP_RECORD(IOUTFLU(ISCORE),NPASS(NP,ISCORE),
                ISCORE,NHSTRY,LATCH(NP),IQ(NP),E(NP),WT(NP),
                X(NP),Y(NP),Z(NP),U(NP),V(NP),W(NP),ZLAST(NP),
                BEAM_MU_INDEX);
    ]

    ELSE[

    IF( i_parallel > 0 ) ["add an _w"
         phsp_fn=$cstring(phsp_fn)// '_w';
         call egs_itostring(phsp_fn,i_parallel,.false.);
    ]
    phsp_fn=$cstring(phsp_fn)// '.egsphsp'//AUNIT;
    $WRITE_PHSP(IZLAST,IOUTFLU(ISCORE),$cstring(phsp_fn),NPPHSP(ISCORE)+1,
                ISCORE:NHSTRY,NPASS(NP,ISCORE),IQ(NP),W(NP),ZLAST(NP),
                LATCH(NP),E(NP),WT(NP):X(NP),Y(NP),U(NP),V(NP));
    ]
    IF(IZLAST = 2)[
         WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY;
         JHSTRY=JHSTRY+1;
         WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) NP,IQ(NP),0,
         XLAST(NP),YLAST(NP),ZLAST(NP),0;
         :GRAPHICS_FORMAT2:FORMAT(3I4,4G15.8,I12);
    ]
   "Check only needed when actually writting to a phsp file"
   IF(NPPHSP(ISCORE)=phsp_upper_limit)[
        $egs_fatal('(//a,i19,4(a/))',
            ' *** WHILE WRITING PHASE SPACE FILE:',
            NPPHSP(ISCORE), ' particles in file.',
            ' Due to the fact that the counter for the number',
            ' of particles in the file cannot be larger than this,',
            ' no more particles will be written to the phsp file.'
        );
    ]
};

REPLACE {$BEAM_PHSP_BUFFER_FLUSH;} WITH {;
     IF(IO_OPT=4)["update no. of primary histories in header"
       DO I1=1,NSC_PLANES[
          NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
          $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(IOUTFLU(I1),NINCPHSP);
          $IAEA_UPDATE_PHSP_HEADER(IOUTFLU(I1));
       ]
     ]
     ELSE["standard BEAMnrc format"
     IF(MODE_RW='MODE0' | MODE_RW='MODE2')[
        NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
        DO I1=1,NSC_PLANES[
           NPPHSPSP=NPPHSP(I1);
           IF(IOUTFLU(I1)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I1)-43;]
           ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I1)-43;]

           "output directory and file prefix defined in beam.mortran"

           phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
           $PHSP_BUFFER_FLUSH(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),NPPHSPSP,I1);
           IF(NPPHSPSP=NPHOTPHSP(I1))[
                  "no electrons"
              $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
                              MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
                              EKMAXPHSP(I1), 0.0, NINCPHSP);
           ]
           ELSE[
              $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
                              MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
                              EKMAXPHSP(I1), EKMINPHSPE(I1), NINCPHSP);
           ]
        ]
        "we store the total particle number in the 1st record of the ph-sp file"
     ]
     ]"end of standard BEAMnrc format"
};

REPLACE {$BEAM_READ_PHSP_FOR_RESTART;} WITH {;
    DO I=1,NSC_PLANES[
       OUTPUT I,NPPHSP(I);
       (//' PH-SP FILE',I4,': '/
          '               TOTAL NO. OF PARTICLES =',I12);
       IF(IO_OPT=0 | IO_OPT=3)["check to see that the user has not"
                               "added phase space files before restarting"
           IF(IO_OPT=4)[
              $IAEA_READ_PHSP_HEADER(IOUTFLU(I),NPPHSP(I),NPHOTPHSP(I),
               EKMAXPHSP(I),NINCPHSP,Z_SCORE,IZLAST1,I_MU_PHSP,IZSCORE);
               EKMINPHSPE(I)=99999.; "info unavailable"
              IF(IZLAST=0 & IZLAST1=1)[
               OUTPUT;
    (//' Error: Phase space file was scored with ZLAST in previous run '/
       ' but you have restarted this run with IZLAST=0.  Restart with'/
       ' IZLAST=1.'//);
               STOP;
              ]
              ELSEIF(IZLAST=1 & IZLAST1=0)[
              OUTPUT;
    (//' Error: Phase space file was scored  without ZLAST in previous run '/
       ' but you have restarted this run with IZLAST=1.  Restart with'/
       ' IZLAST=0.'//);
               STOP;
              ]
           ]
           ELSE[
              $READ_PHSP_HEADER(IOUTFLU(I),MODE_RW,NPPHSPSP,
                        NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);
              NPPHSP(I)=NPPHSPSP;
           ]
           IF(NINCPHSP>
            NINCSRC*(NCASEO+(NRCYCL+1)*(NPASS_ph_spO+NFAT_ph_spO))/NNPHSP)[
                                        "files have been added"
             OUTPUT I;(//' ***ERROR:'/
' Phase space file',I4,' has been added to (using beamdp?) before restarting.'/
' The code currently does not support this.  Please add phase space'/
' files only after all runs, including restarts, are complete.'//);
             "STOP;"
           ]
       ]
       IF(NPPHSP(I) > 0)[
           CALL DATETIME(1);
           OUTPUT TIMEN;(/' READ PH-SP FILE AT ',$TIMEN_FORMAT);
           "Read last particles to check whether it is right"
           IF(IO_OPT=4)[
              "just check that file size=checksum"
              $IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(IOUTFLU(I));
           ]
           ELSE[
              $READ_PHSP_RECORD(IZLAST,IOUTFLU(I),NPPHSP(I)+1:
              NHSTRYM,ZLAST(1),LATCHM,EINM,WTM,XINM,YINM,UINM,VINM);
           "binary read"
           OUTPUT NPPHSP(I),LATCHM,EINM,XINM,YINM,UINM,VINM,WTM;(//
           ' (LATCHM,EINM,XINM,YINM,UINM,VINM,WTM) FOR PARTICLE No.',
           I12,' IN THIS FILE:'/' ',I12,6F12.5);
           "CALL TIME(TIMEN);"
           "OUTPUT TIMEN;"
           "(/' FINISHED READING PH-SP FILE AT ',$TIMEN_FORMAT);"
           ]
           OUTPUT; (/' FINISHED READING PH-SP FILE AT ',$);
           call egs_time(6); OUTPUT; (' ');
       ]
    ]"end of loop over planes"
};

REPLACE {$BEAM_CLOSE_PHSP;} WITH {;
IF(n_parallel=0 | ~is_finished) [
"do not close phsp files that have already been closed"
"after individual parallel jobs have ended"
IF (IO_OPT =  0)|((IO_OPT =  3)&(IHSTRY <= 100000))|(IO_OPT=4) [
      "phase-space output"
  DO I=1,NSC_PLANES [
     IF(IO_OPT=4)[
        $IAEA_DESTROY_PHSP_FILE(IOUTFLU(I));
     ]
     ELSE[
        CLOSE(IOUTFLU(I));
     ]
  ]
]
]
};

REPLACE {$DOSXYZ_OPEN_PHSP_FOR_WRITE;} WITH {;
    "Added by T. popescu and J.Lobo to write phsps in dosxyz."
    "only done for IAEAphsps."
    "Some mods by BW."
    IF(IRESTART=0) [
     $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            0,0,z_score_tmp,i_muidx_out,1);
    ]
    ELSEIF(IRESTART=1) [
     $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            0,1,z_score_tmp,i_muidx_out,1);
    ]
};

REPLACE {$DOSXYZ_WRITE_PHSP;} WITH {;
    "Added by T. popescu and J.Lobo to write phsps in dosxyz."
    "only done for IAEAphsps"
    $IAEA_WRITE_PHSP_RECORD(i_unit_out,0,
                1,nhist,latch(np),iq(np),e(np),
                wt(np), x(np),y(np),z(np),u(np),v(np),w(np),zlast_tmp,
                frMU_indx); "added MU index (JL 2013)"
                "zlast not used in dosxyz so this is a dummy variable"

};

REPLACE {$DOSXYZ_SET_OUT_PHSP_HEADER;} WITH {;
    "Added by T. popescu and J.Lobo to write phsps in dosxyz."
    "only done for IAEAphsps"
    IF(isource = 0 |  isource = 1 | isource = 3 | isource = 7)[
        ainflu=dble(IHSTRY+ncaseold-nsmiss-nmissm);
    ]
    ELSEIF(isource = 2 | isource = 8 )[
        ainflu=dble(IHSTRY+ncaseold+nsmiss+
         (NRCYCL+1)*(nsrjct+nsoutside+ndbsrjct))/float(nshist)*NINCSRC;
    ]
    ELSEIF(isource=4)[
        ainflu=dble(IHSTRY+ncaseold-nsmiss);
    ]
    ELSEIF(isource=6)[
        ainflu=dble(IHSTRY+ncaseold);
    ]
    ELSEIF(isource=9|isource=10|isource=21)[
        ainflu=dble(nhist);
    ]
    ELSEIF(isource=20)[
        ainflu = dble((NRCYCL+1)*(nnread))/dble(nshist)*NINCSRC;
    ]
    $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(i_unit_out,ainflu);
    $IAEA_UPDATE_PHSP_HEADER(i_unit_out);

};

" The following are null macros that will be overwritten by the library "
" version of BEAM "
REPLACE {$DECLARE-PARTICLE-CONTAINER;} WITH {;};

"End of phsp_macros.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc macros for IAEA phase space data format                             "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Blake Walters, 2007                                       "
"                                                                             "
"  Contributors:    Iwan Kawrakow                                             "
"                   Ernesto Mainegra-Hing                                     "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Macros for reading and writing phase space data in the official IAEA       "
"  format.  See the online documentation at https://www-nds.iaea.org/phsp/    "
"  for more about this format. These macros make use of the C++ IAEA phase    "
"  space handling routines in directory $HEN_HOUSE/iaea_phsp/, which are      "
"  provided for public use by the IAEA.                                       "
"                                                                             "
"  In order to use the routines, Fortran compilation must include the flags:  "
"                                                                             "
"  $HEN_HOUSE/iaea_phsp/iaea_header.cpp                                       "
"  $HEN_HOUSE/iaea_phsp/iaea_phsp.cpp                                         "
"  $HEN_HOUSE/iaea_phsp/iaea_record.cpp                                       "
"  $HEN_HOUSE/iaea_phsp/utilities.cpp                                         "
"  -lm -lstdc++                                                               "
"                                                                             "
"  In BEAMnrc, this is done by going into $HEN_HOUSE/specs/beamnrc.spec and   "
"  setting `BEAM_OBJECTS =` the above flags.                                  "
"                                                                             "
"  These macros also make use of variables in COMIN/RWPHSP defined in         "
"                                                                             "
"  $HEN_HOUSE/utils/phsp_macros.mortran                                       "
"                                                                             "
"  hence they must be included in the mortjob.mortran file AFTER              "
"                                                                             "
"  $HEN_HOUSE/utils/phsp_macros.mortran                                       "
"                                                                             "
"  These macros are defined as null in phsp_macros.mortran in case the IAEA   "
"  C++ routines are unavailable and cannot be included in the code.           "
"                                                                             "
"#############################################################################"


REPLACE {$IAEA_OPEN_PHSP_FOR_WRITE(#,#,#,#,#,#,#);} WITH {;
"Input parameters:"
"{P1}=unit number"
"{P2}=file name"
"{P3}=IZLAST"
"{P4}=IRESTART=0 for first run, 1 for restart"
"{P5}=Z position of the scoring plane"
"{P6}=IMUPHSP"
"{P7}=IZSCORE, set to 1 to score Z for each particle"
"note that if IRESTART=1, then nothing is done with {P3} and {P5}"

call iaea_new_source({P1},{P2},{P4}+2,iaea_result);
IF(iaea_result<0)[
    WRITE(i_log,*)' Error opening IAEA phase space file for write.';
    $CALL_EXIT(1);
]
i_iaea_open_for_write=1;
IF({P4}=0)[
  IF({P7}~=1) call iaea_set_constant_variable({P1},2,{P5});
  IF({P3}~=0)[
     IF({P6}~=0)[
        call iaea_set_extra_numbers({P1},2,1);
        "use generic user type for MU_INDEX"
        call iaea_set_type_extrafloat_variable({P1},1,0);
        iaea_i_muidx_out=2;
     ]
     ELSE [
        call iaea_set_extra_numbers({P1},1,1);
     ]
     call iaea_set_type_extrafloat_variable({P1},0,3);
     iaea_i_zlast_out=1;
  ]
  ELSEIF({P6}~=0)[
     call iaea_set_extra_numbers({P1},1,1);
     call iaea_set_type_extrafloat_variable({P1},0,0);
     iaea_i_muidx_out=1;
  ]
  ELSE[
     call iaea_set_extra_numbers({P1},0,1); "always store LATCH"
  ]
  call iaea_set_type_extralong_variable({P1},0,2);
  iaea_i_latch_out=1;
]
}
;

REPLACE {$IAEA_OPEN_PHSP_FOR_READ(#,#);} WITH {;
"Input parameters:"
"{P1}=unit number"
"{P2}=file name"

call iaea_new_source({P1},{P2},1,iaea_result);
IF(iaea_result<0)[
       WRITE(i_log,*)' Error opening IAEA phase space source.';
]

}
;

REPLACE {$IAEA_PARSE_FOR_WRITE(#,#,#,#,#,#,#,#,#);} WITH {;
"input parameters"
"{P1}=WT"
"{P2}=X"
"{P3}=Y"
"{P4}=Z"
"{P5}=U"
"{P6}=V"
"{P7}=W"
"{P8}=ZLAST"
"{P9}=BEAM_MU_INDEX"

WT_PHSP_SHORT={P1};
X_PHSP_SHORT={P2};
Y_PHSP_SHORT={P3};
Z_PHSP_SHORT={P4};
U_PHSP_SHORT={P5};
V_PHSP_SHORT={P6};
W_PHSP_SHORT={P7};
ZLAST_PHSP_SHORT={P8};
MUIDX_PHSP_SHORT={P9};
}


REPLACE {$IAEA_WRITE_PHSP_RECORD(#,#,#,#,#,#,#,#);} WITH {;
"input parameters"
"{P1}=unit number"
"{P2}=NPASS"
"{P3}=scoring plane no."
"{P4}=NHSTRY (primary history no.)"
"{P5}=LATCH"
"{P6}=IQ"
"{P7}=E"
"{P8}=WT,X,Y,Z,U,V,W,ZLAST,BEAM_MU_INDEX"

IF({P2}=0)["do not output if NPASS=1"
    ESHORT={P7}; "put energy into single precision"
    "calculate increment in primary history no. between this particle"
    "and last particle scored"
    iaea_n_stat={P4}-IHSTRY_PHSP({P3});
    IHSTRY_PHSP({P3})={P4}; "reset ihstry"
    "JWU: IAEA phsp uses kinetic energy!"
    IF( ({P6}=1) | ({P6}=-1) )[
          ESHORT = ESHORT - 0.5109989461;
    ]
    $IAEA_PARSE_FOR_WRITE({P8});
    IF(i_iaea_open_for_write=1)[
      iaea_extra_ints(iaea_i_latch_out)={P5};"store LATCH"
  IF(iaea_i_zlast_out>0) iaea_extra_floats(iaea_i_zlast_out)=ZLAST_PHSP_SHORT;
  IF(iaea_i_muidx_out>0) iaea_extra_floats(iaea_i_muidx_out)=MUIDX_PHSP_SHORT;
    ]
    ELSE[
      "use same array indices as input IAEA phsp file"
      "we only get here if the IAEA_OPEN_PHSP_FOR_WRITE macro"
      "has not been used"
      iaea_extra_ints(iaea_i_latch)={P5};"store LATCH"
      IF(iaea_i_zlast>0) iaea_extra_floats(iaea_i_zlast)=ZLAST_PHSP_SHORT;
      IF(iaea_i_muidx>0) iaea_extra_floats(iaea_i_muidx)=MUIDX_PHSP_SHORT;
    ]
    call iaea_write_particle({P1},iaea_n_stat,iaea_q_typ({P6}+2),ESHORT,
        WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT,Z_PHSP_SHORT,U_PHSP_SHORT,
        V_PHSP_SHORT,W_PHSP_SHORT,iaea_extra_floats,iaea_extra_ints);
]
}
;

REPLACE {$IAEA_READ_PHSP_HEADER(#,#,#,#,#,#,#,#,#);} WITH {;
"input parameters"
"{P1}=unit number"
"{P2}=total no. of particles"
"{P3}=total no. of photons"
"{P4}=max, K.E. of all particles"
"{P5}=no of incident primary histories"
"{P6}=Z of scoring plane"
"{P7}=IZLAST"
"{P8}=IMUPHSP"
"{P9}=IZSCORE"

call iaea_get_max_particles({P1},-1,iaea_dummy_long);
{P2}=iaea_dummy_long;
call iaea_get_max_particles({P1},1,iaea_dummy_long);
{P3}=iaea_dummy_long;
call iaea_get_total_original_particles({P1},iaea_dummy_long);
{P5}=iaea_dummy_long;
call iaea_get_maximum_energy({P1},EKMAX_PHSP_SHORT);
{P4}=EKMAX_PHSP_SHORT;
call iaea_get_constant_variable({P1},2,Z_PHSP_SHORT,iaea_result);
IF(iaea_result=-3)[
 write(i_log,*)
    ' Z positions of each particle will be read from phase space data.';
  {P6}=999.;
  {P9}=1; "tell host code that Z is scored"
]
ELSEIF(iaea_result<0)[
  write(i_log,*)' Error reading Z position where IAEA phsp was scored.';
  {P9}=0;
]
ELSE[
  {P6}=Z_PHSP_SHORT;
  {P9}=0;
]
call iaea_get_extra_numbers({P1},iaea_n_extra_floats,iaea_n_extra_ints);
IF(iaea_n_extra_floats = -1 | iaea_n_extra_ints = -1)[
  write(i_log,*)' Error reading number of extra variables stored in IAEA phsp';
]
call iaea_get_type_extra_variables({P1},iaea_result,iaea_extra_int_types,
   iaea_extra_float_types);
IF(iaea_result=-1)[
  write(i_log,*)' Error getting types of extra variables stored in IAEA phsp';
]
DO I_PHSP=1,iaea_n_extra_ints [
  IF(iaea_extra_int_types(I_PHSP)=2)[
    iaea_i_latch=I_PHSP;
    EXIT;
  ]
]
IF(iaea_i_latch=-99)[
    write(i_log,*)' Warning: IAEA format phsp file does not store LATCH';
]
DO I_PHSP=1,iaea_n_extra_floats [
  IF(iaea_extra_float_types(I_PHSP)=3)[
    iaea_i_zlast=I_PHSP;
    EXIT;
  ]
]
IF(iaea_i_zlast=-99)[
    {P7}=0; "no zlast"
]
ELSE[
    {P7}=1;
]
"test to see if this file contains MU_INDEX"
"we assume this is the first float after zlast, if zlast is scored,"
"and has generic user type = 0"
iaea_i_muidx=MAX(1,iaea_i_zlast+1);
IF(iaea_i_muidx>iaea_n_extra_floats | iaea_extra_float_types(iaea_i_muidx)~=0) [
  iaea_i_muidx=-99;"reset this to no scoring"
  {P8}=0;
]
ELSE[
  {P8}=1;
]
;
}
;

REPLACE {$IAEA_SET_PHSP_RECORD(#,#);} WITH {;
"input parameters"
"{P1}=unit no."
"{P2}=record no. (particle no.) to go to"

iaea_dummy_long={P2};
call iaea_set_record({P1},iaea_dummy_long,iaea_result);
IF(iaea_result<0)[
    WRITE(i_log,*)' Error going to record ',{P2},' in IAEA phsp file.';
    $CALL_EXIT(1);
]
}
;

REPLACE {$IAEA_PARSE_FOR_READ(#,#,#,#,#,#,#,#,#);} WITH {;
"input parameters"
"{P1}=WT"
"{P2}=X"
"{P3}=Y"
"{P4}=Z"
"{P5}=U"
"{P6}=V"
"{P7}=W"
"{P8}=ZLAST"
"{P9}=MU_INDEX"

{P1}=WT_PHSP_SHORT;
{P2}=X_PHSP_SHORT;
{P3}=Y_PHSP_SHORT;
{P4}=Z_PHSP_SHORT;
{P5}=U_PHSP_SHORT;
{P6}=V_PHSP_SHORT;
{P7}=W_PHSP_SHORT;
{P8}=ZLAST_PHSP_SHORT;
{P9}=MUIDX_PHSP_SHORT;
}

REPLACE {$IAEA_READ_PHSP_RECORD(#,#,#,#,#,#,#);} WITH {;
"input parameters"
"{P1}=unit number"
"{P2}=NPASS"
"{P3}=NHSTRY (no. of primary histories represented by particle read)"
"{P4}=LATCH"
"{P5}=IQ"
"{P6}=E"
"{P7}=WT,X,Y,Z,U,V,W,ZLAST,MU_INDEX"

{P2}=0; "no multiple passers stored in IAEA format"

call iaea_get_particle({P1},iaea_n_stat,iaea_q_index,ESHORT,WT_PHSP_SHORT,
        X_PHSP_SHORT,Y_PHSP_SHORT,Z_PHSP_SHORT,U_PHSP_SHORT,
        V_PHSP_SHORT,W_PHSP_SHORT,iaea_extra_floats,iaea_extra_ints);
IF(iaea_n_stat=-1)[
  WRITE(i_log,*)' Error getting particle data from IAEA phsp file.';
  $CALL_EXIT(1);
]
ELSEIF(iaea_n_stat=-2)[
  WRITE(i_log,*)' WARNING: Reached end of IAEA phsp file.  File restarted.';
]
ELSEIF(iaea_n_stat>=0)[
  {P3}={P3}+iaea_n_stat;
  IF(iaea_i_latch=-99)[
    {P4}=0; "latch not stored here"
  ]
  ELSE [
    {P4}=iaea_extra_ints(iaea_i_latch);
  ]
  {P5}=iaea_typ_q(iaea_q_index);
  "JWU: IAEA phsp uses kinetic energy!"
  IF( ({P5}=1) | ({P5}=-1) )[
      ESHORT = ESHORT + 0.5109989461;
  ]
  {P6}=ESHORT;
  IF(iaea_i_zlast=-99)[
    ZLAST_PHSP_SHORT=0; "no zlast stored"
  ]
  ELSE [
    ZLAST_PHSP_SHORT= iaea_extra_floats(iaea_i_zlast);
  ]
  IF(iaea_i_muidx=-99)[
    MUIDX_PHSP_SHORT=0; "no mu_index stored"
  ]
  ELSE [
    MUIDX_PHSP_SHORT= iaea_extra_floats(iaea_i_muidx);
  ]
  $IAEA_PARSE_FOR_READ({P7});
]
}
;
REPLACE {$IAEA_DESTROY_PHSP_FILE(#);} WITH {;
"input parameters"
"{P1}=unit number"

call iaea_destroy_source({P1},iaea_result);

IF(iaea_result<0)[
  WRITE(i_log,*)' Error closing IAEA phase space ID ',{P1};
]
}
;
REPLACE {$IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(#,#);} WITH {;
"input parameters"
"{P1}=unit number"
"{P2}=no. of incident primary histories"

iaea_dummy_long={P2};
call iaea_set_total_original_particles({P1},iaea_dummy_long);
}
;

REPLACE {$IAEA_UPDATE_PHSP_HEADER(#);} WITH {;
"input parameters"
"{P1}=unit number"

call iaea_update_header({P1},iaea_result);

IF(iaea_result<0)[
  WRITE(i_log,*)' Error writing IAEA phase space header for ID ',{P1};
  $CALL_EXIT(1);
]
}
;

REPLACE {$IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(#);} WITH {;
"input parameters"
"{P1}=unit number"

call iaea_check_file_size_byte_order({P1},iaea_result);

IF(iaea_result=-3)[
  WRITE(i_log,*)' ERROR: Size of phase space file does not match';
  WRITE(i_log,*)' the value of checksum in the header.  Something may be';
  WRITE(i_log,*)' wrong.  Check your file.';
  $CALL_EXIT(1);
]
ELSEIF(iaea_result=-4)[
  WRITE(i_log,*)' ERROR: Byte order in the phase space file does not';
  WRITE(i_log,*)' match the machine you are running on.';
  $CALL_EXIT(1);
]
ELSEIF(iaea_result=-5)[
  WRITE(i_log,*)' ERROR: Size of file does not match the value of checksum';
  WRITE(i_log,*)' in the header AND there is a byte order mismatch between';
  WRITE(i_log,*)' the file and the machine you are running on.';
  $CALL_EXIT(1);
]
ELSEIF(iaea_result=-1)[
  WRITE(i_log,*)' ERROR: Cannot open phase space header.';
  $CALL_EXIT(1);
]
ELSEIF(iaea_result=-2)[
  WRITE(i_log,*)' ERROR: Something is wrong with the phase space file.';
  $CALL_EXIT(1);
]
}
;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc beamdp utility                                                      "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Charlie Ma, 1993                                          "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Blake Walters                                             "
"                   Joanne Treurniet                                          "
"                   Iwan Kawrakow                                             "
"                   Zdenko Sego                                               "
"                   Ernesto Mainegra-Hing                                     "
"                   Frederic Tessier                                          "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The beamdp utility is a data processing program to construct an input data "
"  file for Monte Carlo simulation based on the full phase-space data for a   "
"  beam from a radiotherapy machine simulated using BEAMnrc. It can also      "
"  generate planar fluence, mean energy, spectral and angular distributions   "
"  in the format suitable for the Grace plotting program.                     "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Zdenko Sego and Dave Rogers, 2006: add double precision scoring arrays to  "
"  ensure subsource intensities add up to one even when there are large       "
"  differences in weights. Change circular and square ring fluence types.     "
"  Eliminate a big chunk of redundant data in help output.                    "
"                                                                             "
"#############################################################################"


!INDENT F 2;
"*******************************************************************************
"
"               BEAM CHARACTERIZATION: BEAM DATA PROCESSOR
"               ******************************************
"
"                           Original programmer:  C-M Ma  (NRC)
"                             June 2, 1993
"
"*******************************************************************************
"
%L
%Q1
%C80
%I4
%E
%B132
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
"*******************************************************************************

"We need the $REAL, $INTEGER and $LOGICAL macros "
REPLACE {$REAL} WITH {real*8}
REPLACE {$INTEGER} WITH {integer*4}
REPLACE {$LOGICAL} WITH {logical}

;REPLACE {$NS} WITH {22}  "maximum number of sub-sources for the source model
                          "note: this number should be consistent with
                          "that used in the simulation code (=$MXSMFS in BEAM)

;REPLACE {$NB} WITH {200} "maximum number of bins for a distribution
                          "note: this number should be consistent with
                          "that used in the simulation code

;REPLACE {$ND} WITH {2000}  "maximum number of bins for a distribution

REPLACE {$NBINANGLE} WITH {200}; "number of bins for the angular distribution"

REPLACE {$MAXANGLE} WITH {0.1745};
"ANGLE IN RAD, = 10 DEGREES. Very few particles will be scattered at angles"
"greater than 10 degrees after going through 100 cm air"

REPLACE {$LATCH_NUMBER_OF_BITS} WITH {5}
"number of bits used in LATCH to record region # where a particle is created"

REPLACE {$MAX_SC_PLANES} WITH {1};
"a dummy replacement needed for new write macros"

"Macro to set bit {P2} in {P1}  to 1
REPLACE {$IBSET(#,#);} WITH {IBSET({P1},{P2});}

"Macro to set test bit {P2} in {P1}
REPLACE {$BTEST(#,#)} WITH {BTEST({P1}, {P2}) }

"Macro to set bit {P2} in {P1}  to 0   "
REPLACE {$IBCLR(#,#);} WITH {IBCLR({P1},{P2});}

REPLACE {$LONG_INT} WITH {INTEGER*8}
"use INTEGER*4 if your compiler has trouble with this"

REPLACE {COMIN/CHARACTERS;} WITH {
COMMON/CHARACTERS/
MODE_RW1,MODE_RW2,C1,C2,AC,PSDNAM,
SPCNAM,OLDNAM, SSMFPS,
DSMFPS,GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE,SCRIPT,
LETTER1,LETTER2;
CHARACTER*5
MODE_RW1,MODE_RW2;"for use to check phase space file mode"
CHARACTER*1  C1;  "|temp. variables"
CHARACTER*2  C2;  "|temp. variables"
CHARACTER*2  AC(3); "for output of 3D points from IAEA phsp data"
CHARACTER*100
  PSDNAM;         "file name of full phase-space data to be processed"
CHARACTER*80
  SPCNAM,         "file name of source data file to be created"
  OLDNAM,         "old source data file used as a reference"
  SSMFPS,         "detailed descriptions of the source (machine, energy, "
                  "field size, etc."
  DSMFPS;         "detailed descriptions of the source (machine, energy, "
                  "field size, etc."
CHARACTER*60 GRAPHTITLE;               "|strings for xvgr plotting"
CHARACTER*60 XTITLE,YTITLE,SERIESTITLE;
CHARACTER*102 SCRIPT(4);
CHARACTER*2 LETTER1(5),LETTER2(0:101);

}
;

REPLACE {COMIN/REALS;} WITH {
COMMON/REALS/
  XMIN2,XMAX2, XPLOT,HXMIN, YPLOT,YPLOTT,
  ERRYPLOT,X2Y2,ZTOTAL,RSSD02,RSSD12,SSDVPS,
  SFACTOR,RFACTOR,RFACTOR1,RFACTOR2,
  X,Y,Z,RRFACTOR,SSFACTOR,RSSD0,RSSD1,
  WEIGHT,EI,
  PARAEMAX2,PARAEMAX1,PARAEMAX,
  PARAEMNE1,PARAEMNE2,PARAEMNE,
  PARANINC1,PARANINC2,PARANINC,
  EREAD,ZLAST, MUIDX,XIN,YIN,ZIN,UIN,VIN,WIN, SMFX2,SMFY2,SMFMXR,
  HFIELD,  RSCATT, DELTAZ,RSSDST,SSSDST,ERADII,E_ph_sp_e,
  E_ph_sp_g, E_ph_sp_p, E_MIN_ph_sp, E_MAX_ph_sp,
  RFIELD,RFIELDe,XFLDMN,XFLDMX,
  YFLDMN, YFLDMX, SMFMNZ, SMFMXZ, SMFMNX,
  SMFMXX, SMFMNY, SMFMXY, SMFMNR,RTREAT,RTREATe,XTREATMN,XTREATMX,
  YTREATMN,YTREATMX, SMFMNE,SMFMXE,
  ABNTOTAL,ABNTOTALH,FLUAREA,NINC,
  RMIN_MIN,RMIN_MAX,RMAX_MIN,RMAX_MAX,DOMEGA,
  SUM_TMP,SUM_TMP2,Z_SCORE,mumin,mumax;

$REAL
  XMIN2,XMAX2,    "|temp. variables"
  XPLOT($NB),HXMIN,  "|VARIABLES FOR XVGR PLOTTING"
  YPLOT($NB),YPLOTT,
  ERRYPLOT($NB),
  X2Y2,           "=XIN*XIN+YIN*YIN"
  ZTOTAL($NS),    "calculated SSD for a particular particle from a point source"
  RSSD02,RSSD12,  "squares of RSSD0 and RSSD1"
  SSDVPS($NS+3),  "SSD of a virtual point source for a particular source"
  SFACTOR,RFACTOR,RFACTOR1,RFACTOR2,X,Y,Z,RRFACTOR,SSFACTOR,"temp. variables"
  RSSD0,RSSD1,    "radius of a ring used for SSD analysis for a point source"
  WEIGHT,EI,
  PARAEMAX2,PARAEMAX1,PARAEMAX,
  PARAEMNE1,PARAEMNE2,PARAEMNE,
  PARANINC1,PARANINC2,PARANINC,
  EREAD,ZLAST,MUIDX,
  XIN,YIN,ZIN,UIN,
  VIN,WIN,        "|variables for phase-space data reading"
  SMFX2($NS),
  SMFY2($NS),     "|outer dimensions of applicators and collimators"
  SMFMXR($NS),    "outer radius for rings and cones"
  HFIELD($NS),    "variable for SSD calculation"
  RSCATT,         "mean scattering radius"
  DELTAZ,         "distance from scoring plane to image plane for SSD analysis"
  RSSDST($NS,$ND),"distribution used to find SSD for a virtual point source"
  SSSDST($NS,$ND),"distribution used to find SSD for a virtual point source"
  ERADII($NB),    "energy spectrum radii"
  E_ph_sp_e,      "energy of e- from phase space file"
  E_ph_sp_g,      "energy of gamma read from phase space file"
  E_ph_sp_p,      "energy of e+ read from phase space file"
  E_MIN_ph_sp,    "min energy of particles read from phase space file"
  E_MAX_ph_sp,    "max energy of particles read from phase space file"
  RFIELD,         "radius for field planar fluence distribution"
  RFIELDe,        "radius for energy distribution"
      "Note: RFIELDe must be equal to RFIELD"
  XFLDMN,         "minimum x coordinate for field planar fluence distribution"
  XFLDMX,         "maximum x coordinate for field planar fluence distribution"
  YFLDMN,         "minimum y coordinate for field planar fluence distribution"
  YFLDMX,         "maximum y coordinate for field planar fluence distribution"
  SMFMNZ($NS),    "distance from the sub-source to the scoring plane"
                  "for a tubular applicator: source bottom to the phantom"
  SMFMXZ($NS),    "distance from the top of the source to the scoring plane"
  SMFMNX($NS),    "minimum x coordinate for a sub-source"
  SMFMXX($NS),    "maximum x coordinate for a sub-source"
  SMFMNY($NS),    "minimum y coordinate for a sub-source"
  SMFMXY($NS),    "maximum y coordinate for a sub-source"
  SMFMNR($NS),    "radius of a sub-source"
  RTREAT,         "defined field radius for treatment or measurement"
  RTREATe,        "treatment field radius for energy spectra"
      "Note: RTREATe could generally be different then RTREAT"
  XTREATMN,       "min X for treatment or measurement field"
  XTREATMX,       "max X for treatment or measurement field"
  YTREATMN,       "min Y for treatment or measurement field"
  YTREATMX,       "max Y for treatment or measurement field"
  SMFMNE,SMFMXE,  "minimum and maximum energy of the spectrum for a sub-source"
  ABNTOTAL,ABNTOTALH, "TMP VARIABLES FOR ANGLE CALCULATION"
  FLUAREA,        "area of rectangular or annular region in which fluence"
                  "is evaluated"
  NINC,           "number of incident particles"
  RMIN_MIN,
  RMIN_MAX,       "used to index radial bin that user wants to plot"
  RMAX_MIN,       "in a multiple source model with multiple radial bins"
  RMAX_MAX,
  DOMEGA,         "bin width in solid angle"
  SUM_TMP($NB),   "keeps track of sums in a bin over one primary history"
  SUM_TMP2($NB),  "keeps track of sums in a bin over one primary history"
  Z_SCORE,        "Z where phsp file was scored (IAEA only)"
  mumin,mumax;    "MU range for output of (X,Y,Z) (IAEA only)"
}
;

REPLACE {COMIN/DOUBLES;} WITH {
COMMON/DOUBLES/
  KWEI,SMFRTN,
  FSMFBN1,FSMABN1,FSMABN2,FSMFXX,FSMFYY,FSMFR1,FSMFR2,FSMFR11,FSMFR12,
  FSMFRR,FSMFXY,BINSIZE,RBin,RBin_X,RBin_Y;

REAL*8
  KWEI,
  SMFRTN($NS), "relative source intensity for a sub-source"
  FSMFBN1($NS,$NB,$NB),"No of particles/bin a bin for an energy distribution "
  FSMABN1($NBINANGLE),"No of particles/bin for an angular distribution "
  FSMABN2($NBINANGLE),"= FSMABN1 SQUARED  "
  FSMFXX($NS,$NB),"No of particles/bin for a spatial distribution along x-axis"
  FSMFYY($NS,$NB),"No of particles/bin for a spatial distribution along y-axis"
  FSMFR1($NS,$NB),"No of particles/bin for a spatial distribution "
  FSMFR2($NS,$NB),"No of particles/bin for a spatial distribution "
  FSMFR11($NS,$NB),"parameters for spatial distribution"
  FSMFR12($NS,$NB),"parameters for spatial distribution"
  FSMFRR($NS,$NB),"No of particles/bin for a spatial distribution"
  FSMFXY($NS,$NB,$NB),"No of particles/bin for a rectangular field"
  BINSIZE($NB),"We deal with different bin sizes. Keep sizes here"
  RBin,RBin_X,RBin_Y;
}
;

REPLACE {COMIN/INTEGERS;} WITH {
COMMON/INTEGERS/
  PARANOT,PARANOT1,PARANOT2,PARANOP,PARANOP1,
  PARANOP2,IPARANOT,IPARANOT1,IPARANOT2,
  LPARANINC,LPARANINC1,LPARANINC2,NHSTRY,NHSTRY_LAST,
  I,II,III,IIII,IIIII,ITYPE, J,JJ,NUMBERP,NUMBERST,NBIT1,NBIT2,
  NFIELDi,NFIELDo,NFIELDe,
  NWRONG,LATCHJ,CHOICE,CHOICE1, K1,K2,K3,K4,IA,
  IX,IY,IR,K,IQ,LATCHI,IE,
  NPASSI,LATCH,SMFPXY,NFIELD,NSMFPS,I_IN_EX,
  ISMFPS,IQSMFP,MSTART,MSMFXY,NSMFEE,NPASS_ph_sp,
  N_ph_sp_e, N_ph_sp_g, N_ph_sp_p, FLUTYPE,ANGTYPE,IZLAST1,
  IZLAST2,IMUIDX1,IMUIDX2,IZSCORE1,IZSCORE2,JUSTONE,
  MAXSCATTER,NUMSCATTER,ESTYPE,i_iaea_in,i_iaea_out,i_log,
  i_unit_in,i_unit_out;

$LONG_INT PARANOT,PARANOT1,PARANOT2,
  PARANOP,PARANOP1, "these need to be made long because IAEA format handles"
  PARANOP2,IPARANOT,IPARANOT1,IPARANOT2, "> 2^31-1 particles"
  LPARANINC,LPARANINC1,LPARANINC2, "long int storage for no. of original "
                                   "histories for use in IAEA headers, where"
                                   "this is an integer*8 variable"
  NHSTRY,NHSTRY_LAST($NB);

INTEGER
  I,II,III,IIII,IIIII,ITYPE,
  J,JJ,NUMBERP,NUMBERST,NBIT1,NBIT2,  "temp. constants"
  NWRONG,LATCHJ(29),"flag for wrong field size, tmp for latch"
  CHOICE,CHOICE1,   "choice of operations"
  K1,K2,K3,K4,IA,
  IX,IY,IR,K($NS),
  IQ,LATCHI,IE,
  NPASSI,         "|integers for phase-space data reading"
  LATCH($NS),     "LATCH number for each sub-source when the beam is "
                  "simulated using BEAM"
  SMFPXY($NS),    "orientation of the collimator: 0-along x-axis,"
                  "1-along y-axis"
  NFIELD,         "total number of bins for field planar fluence distribution"
      "NFIELD=NFIELDi+NFIELDo for circular and square field types"
  NFIELDi,        "number of bins for field planar fluence distribution"
      "inside the treatment field"
  NFIELDo,        "number of bins for field planar fluence distribution"
      "outside the treatment field"
  NFIELDe,        "number of energy spectra bins"
  NSMFPS,         "number of sub-sources for the source model (Max.= $MXNSMF)"
  I_IN_EX,        "flag for inclusive or exclusive LATCH check"
  ISMFPS($NS),    "source type: 1-applicator, 2-collimator, 3-ring,"
                  "cone and point source"
  IQSMFP($NS),    "charge of particles from a subsource"
                  "-1 for electrons, 0 for photons and 1 for positrons"
  MSTART,         "=0 fresh start"
                  "=1 re-start within an option"
  MSMFXY,         "field type: 0-circular, 1-square, 2-rectangular"
  NSMFEE,         "number of bins for energy distribution for a sub-source"
  NPASS_ph_sp,    "number of particles rejected read from ph-sp for NPAS1"
  N_ph_sp_e,      "No of e- read from phase space file"
  N_ph_sp_g,      "No of gamma read from phase space file"
  N_ph_sp_p,      "No of e+ read from phase space file"
  FLUTYPE,        "choice of estimate of real fluence or planar fluence"
  ANGTYPE,   "choice to plot particles/unit solid angle or part./angular bin"
  IZLAST1,        "=0 for no ZLAST, 1 with ZLAST, added for new phsp macros"
  IZLAST2,        "same but for 2nd file when adding files"
  IMUIDX1,        "=0 if fractional MU index not stored in IAEA phsp, 1"
                  " otherwise.  For file no. 1"
  IMUIDX2,        "same as above for file no. 2"
  IZSCORE1,       "=1 if particle Z scored, 0 otherwise"
  IZSCORE2,       "same as above for file no. 2"
  JUSTONE($NB),   "keeps track of actual number of particles in bin"
  MAXSCATTER,     "max. number of particles to output to scatter plot"
  NUMSCATTER,     "keeps track of number of particles written to scatter plot"
  ESTYPE          , "energy spectrum type"
  i_iaea_in,      "set to 1 to analyze IAEA-format phase space file"
  i_iaea_out,     "set to 1 if file 2, the file being appended to when two"
                  " phsp files are added, is IAEA-format"
  i_log,          "standard output, need to declare it because we are using"
                  "phase space macros"
  i_unit_in,i_unit_out; "input and output units; must use variables for"
                      "IAEA routines rather than just specifying the unit no."
                        "directly"
}
;
REPLACE {COMIN/LOGICALS;} WITH {
COMMON/LOGICALS/OLDFILE,EGSPERT;

LOGICAL OLDFILE,  "flag for reading parameters from an old source data file"
                  " T => read an old file"
                  " F => user type in all the parameters himself  "
  EGSPERT;        "flag for EGS_PERT prompts"
                  " T => user is an EGS_PERT"
                  " F => user is not an EGS_PERT"

}

REPLACE {ASSIGN-LETTERS;} WITH {
LETTER1(1)='-1';LETTER1(2)=' 0';LETTER1(3)=' 1';
LETTER1(4)='2';LETTER1(5)=' 3';
LETTER2(0)=' 0';
LETTER2(1)=' 1';LETTER2(2)=' 2';LETTER2(3)=' 3';LETTER2(4)=' 4';
LETTER2(5)=' 5';LETTER2(6)=' 6';LETTER2(7)=' 7';LETTER2(8)=' 8';
LETTER2(9)=' 9';LETTER2(10)='10';
LETTER2(11)='11';LETTER2(12)='12';LETTER2(13)='13';LETTER2(14)='14';
LETTER2(15)='15';LETTER2(16)='16';LETTER2(17)='17';LETTER2(18)='18';
LETTER2(19)='19';LETTER2(20)='20';
LETTER2(21)='21';LETTER2(22)='22';LETTER2(23)='23';LETTER2(24)='24';
LETTER2(25)='25';LETTER2(26)='26';LETTER2(27)='27';LETTER2(28)='28';
LETTER2(29)='29';LETTER2(30)='30';
LETTER2(31)='31';LETTER2(32)='32';LETTER2(33)='33';LETTER2(34)='34';
LETTER2(35)='35';LETTER2(36)='36';LETTER2(37)='37';LETTER2(38)='38';
LETTER2(39)='39';LETTER2(40)='40';
LETTER2(41)='41';LETTER2(42)='42';LETTER2(43)='43';LETTER2(44)='44';
LETTER2(45)='45';LETTER2(46)='46';LETTER2(47)='47';LETTER2(48)='48';
LETTER2(49)='49';LETTER2(50)='50';
LETTER2(51)='51';LETTER2(52)='52';LETTER2(53)='53';LETTER2(54)='54';
LETTER2(55)='55';LETTER2(56)='56';LETTER2(57)='57';LETTER2(58)='58';
LETTER2(59)='59';LETTER2(60)='60';
LETTER2(61)='61';LETTER2(62)='62';LETTER2(63)='63';LETTER2(64)='64';
LETTER2(65)='65';LETTER2(66)='66';LETTER2(67)='67';LETTER2(68)='68';
LETTER2(69)='69';LETTER2(70)='70';
LETTER2(71)='71';LETTER2(72)='72';LETTER2(73)='73';LETTER2(74)='74';
LETTER2(75)='75';LETTER2(76)='76';LETTER2(77)='77';LETTER2(78)='78';
LETTER2(79)='79';LETTER2(80)='80';
LETTER2(81)='81';LETTER2(82)='82';LETTER2(83)='83';LETTER2(84)='84';
LETTER2(85)='85';LETTER2(86)='86';LETTER2(87)='87';LETTER2(88)='88';
LETTER2(89)='89';LETTER2(90)='90';
LETTER2(91)='91';LETTER2(92)='92';LETTER2(93)='93';LETTER2(94)='94';
LETTER2(95)='95';LETTER2(96)='96';LETTER2(97)='97';LETTER2(98)='98';
LETTER2(99)='99';LETTER2(100)=' 0';LETTER2(101)='  ';}

;

REPLACE {$SCORE(#:#:#:#)} WITH {;

"Scoring macro:"
"{P1}=bin index"
"{P2}=scoring array storing quantity summed over primary histories"
"{P3}=scoring array storing quantity**2 summed over primary histories"
"{P4}=quantity to be scored (eg WEIGHT)"

"If the primary history number, NHSTRY, is the same as the history"
"that last scored in this array, NHSTRY_LAST{P1}, then {P4} is added"
"to a temporary array, SUM_TMP{P1}.  Otherwise, we add"
"SUM_TMP{P1} to {P2}, SUM_TMP{P1}*SUM_TMP{P1} to {P3},"
"set SUM_TMP{P1}={P4}, and set NHSTRY_LAST{P1}=NHSTRY."
"This scoring method allows us to calculate uncorrelated value"
"of {P3} which is then used to calculate the uncertainty"
"in {P2}."

IF(NHSTRY_LAST({P1})=NHSTRY)["same primary history"
      SUM_TMP({P1})=SUM_TMP({P1})+{P4};
]
ELSE[
      {P2}={P2}+SUM_TMP({P1});
      {P3}={P3}+SUM_TMP({P1})*SUM_TMP({P1});
      SUM_TMP({P1})={P4};
      NHSTRY_LAST({P1})=NHSTRY;
]
}

REPLACE {$SCORE_COV(#:#:#:#:#:#:#:#)} WITH {;

"Scoring macro for ratio of 2 correlated quantities ({P7}/{P8}):"
"{P1}=bin index"
"{P2}=scoring array storing quantity1 summed over primary histories"
"{P3}=scoring array storing quantity1**2 summed over primary histories"
"{P4}=scoring array storing quantity2 summed over primary histories"
"{P5}=scoring array storing quantity2**2 summed over primary histories"
"{P6}=scoring array storing quantity1*quantity2 summed over prim. histories"
"{P7}=quantity1 (eg WEIGHT*EI)"
"{P8}=quantity2 (eg WEIGHT)"

"If the primary history number, NHSTRY, is the same as the history"
"that last scored in this bin, NHSTRY_LAST{P1}, then"
"SUM_TMP{P1}=SUM_TMP{P1}+{P7} and SUM_TMP2{P1}+{P8}."
"Otherwise, we add SUM_TMP{P1} to {P2} and SUM_TMP{P1}*SUM_TMP{P1} to {P3};"
"add SUM_TMP2{P1} to {P4} and SUM_TMP2{P1}*SUM_TMP2{P1} to {P5};"
"add SUM_TMP{P1}*SUM_TMP2{P1} to {P6};"
"set SUM_TMP{P1}={P7}; set SUM_TMP2{P1}={P8}; and set NHSTRY_LAST{P1}=NHSTRY."

IF(NHSTRY_LAST({P1})=NHSTRY)["same primary history"
      SUM_TMP({P1})=SUM_TMP({P1})+{P7};
      SUM_TMP2({P1})=SUM_TMP2({P1})+{P8};
]
ELSE[
      {P2}={P2}+SUM_TMP({P1});
      {P3}={P3}+SUM_TMP({P1})*SUM_TMP({P1});
      {P4}={P4}+SUM_TMP2({P1});
      {P5}={P5}+SUM_TMP2({P1})*SUM_TMP2({P1});
      {P6}={P6}+SUM_TMP({P1})*SUM_TMP2({P1});
      SUM_TMP({P1})={P7};
      SUM_TMP2({P1})={P8};
      NHSTRY_LAST({P1})=NHSTRY;
]
}

REPLACE {$ANALYZE(#:#:#)} WITH {;

"uncertainty analysis macro:"
"{P1}=bin index"
"{P2}=scoring array storing quantity summed over primary histories"
"{P3}=scoring array storing quantity**2 summed over primary histories"

"Adds the remaining quantity in SUM_TMP({P1}) to {P2} and"
"SUM_TMP({P1})*SUM_TMP({P1}) to {P3} and then performs"
"statistical analysis for uncertainty.  Absolute uncertainty ends up in"
"{P3} and may still have to be normalized in main program.  Note"
"that the quantity {P2} is normalized by NINC in this macro."

{P2}={P2}+SUM_TMP({P1});
{P3}={P3}+SUM_TMP({P1})*SUM_TMP({P1});

{P2}={P2}/NINC;
{P3}={P3}/NINC;
{P3}=({P3}-{P2}*{P2})/(NINC-1);
IF({P3}>0.){P3}=SQRT({P3});
{P3}=MIN({P3},0.9999D00*{P2});

}

REPLACE {$ANALYZE_COV(#:#:#:#:#:#)} WITH {;

"uncertainty analysis macro for ratio of correlated quantities"
"(quantity1/quantity2):"
"{P1}=bin index"
"{P2}=scoring array storing quantity1 summed over primary histories"
"{P3}=scoring array storing quantity1**2 summed over primary histories"
"{P4}=scoring array storing quantity2 summed over primary histories"
"{P5}=scoring array storing quantity2**2 summed over primary histories"
"{P6}=scoring array storing quantity1*quantity2 summed over prim. histories"

"Adds the remaining quantity in SUM_TMP({P1}) to {P2} and"
"SUM_TMP({P1})*SUM_TMP({P1}) to {P3}.  Adds remaining quantity in"
"SUM_TMP2({P1}) to {P4} and SUM_TMP2({P1})*SUM_TMP2({P1}) to {P5}.  And"
"adds remaining SUM_TMP({P1})*SUM_TMP2({P1}) to {P6}.  The macro then performs"
"statistical analysis for uncertainty.  Fractional uncertainty ends up in"
"{P3}.  Note that the"
"quantities {P2} and {P4} are normalized by NINC in this macro."
"Also note that the covariance term is not used for bins that"
"have fewer than 10 particles in them (this is consistent with BEAM)."

{P2}={P2}+SUM_TMP({P1});
{P3}={P3}+SUM_TMP({P1})*SUM_TMP({P1});
{P4}={P4}+SUM_TMP2({P1});
{P5}={P5}+SUM_TMP2({P1})*SUM_TMP2({P1});
{P6}={P6}+SUM_TMP({P1})*SUM_TMP2({P1});

"get relative uncertainty on {P2}"
{P2}={P2}/NINC;
{P3}={P3}/NINC;
{P3}=({P3}-{P2}*{P2})/(NINC-1);
IF({P3}>0.){P3}=SQRT({P3});
{P3}=MIN(0.9999D00,{P3}/{P2});

"get relative uncertainty on {P4}"
{P4}={P4}/NINC;
{P5}={P5}/NINC;
{P5}=({P5}-{P4}*{P4})/(NINC-1);
IF({P5}>0.){P5}=SQRT({P5});
{P5}=MIN(0.9999D00,{P5}/{P4});

IF(JUSTONE({P1})<10)["fewer than 10 particles in bin"
   {P6}=0.;
]
ELSE[
   {P6}={P6}/NINC-{P2}*{P4};
   {P6}={P6}/({P2}*{P4}*(NINC-1));
]

{P3}={P3}**2+{P5}**2-2*{P6};
IF({P3}>0.){P3}=SQRT({P3});
{P3}=MIN(0.9999D00,{P3});

}



"**VARIABLES**"
"---Force declarations of all variables---"
IMPLICIT NONE;

COMIN/CHARACTERS;
COMIN/DOUBLES;
COMIN/REALS;
COMIN/INTEGERS;
COMIN/LOGICALS;
COMIN/RWPHSP/;

INTEGER lnblnk1;

ASSIGN-LETTERS;

$INIT_PHSP_COUNTERS;

"-----------------------------------------------------------------------------

"**Checks to see if user is EGS_PERT, and sets logical variable to choose
"**appropriate prompts.

EGSPERT = .false.; "Turn on wordy prompts for first-time users"
"EGSPERT=system('exit $?EGS_PERT'); "

"-------------------------------------------------------------------------------

"**Print out a header page for non-experts

OUTPUT;(
    //
    ' Running BEAMDP, Version v 1.9'/
    ' -----------------------------------------------------------'/
    ' Type ? at any prompt for help                              ');

IF ~EGSPERT[
    CALL HELP_MESSAGE(0);
    OUTPUT ;(
        ' Do you wish more detailed information about the file created '/
        ' by the program?   (y/n[Default])=> ',$);
    INPUT C1; (A1);
    ]

IF (~EGSPERT)[
    IF ((C1='y')|(C1='Y')|( C1='?'))[
       CALL HELP_MESSAGE(1); ]
    ELSE[
        EGSPERT = .true.; "Turn off wordy prompts for first-time users"
    ]
]

:CHOICE1:  ;
OUTPUT;(/' Input a number for the operation required: ');
OUTPUT;(' ********************************************'/);
OUTPUT;(' (0) - Process data for beam characterization models');
OUTPUT;(' (1) - Derive fluence vs position from ph-sp data');
OUTPUT;(' (2) - Derive energy fluence vs position from ph-sp data');
OUTPUT;(' (3) - Derive spectral distribution from ph-sp data');
OUTPUT;(' (4) - Derive energy fluence distribution from ph-sp data');
OUTPUT;(' (5) - Derive mean energy distribution from ph-sp data');
OUTPUT;(' (6) - Derive angular distribution from ph-sp data');
OUTPUT;(' (7) - Derive ZLAST distribution from ph-sp data');
OUTPUT;(' (8) - Derive distribution of particle weights from ph-sp data');
OUTPUT;(' (9) - Derive X-Y scatter plot of particles from ph-sp data');
OUTPUT;(' (10) - Combine two ph-sp files into one');
OUTPUT;(' (11) - List parameters for a number of ph-sp particles ');
OUTPUT;(' (12) - Output (x,y,z) coordinates to file (IAEA only)');
OUTPUT;(' (13) - Quit');
OUTPUT;(' ',$);

INPUT C2,ITYPE;(A2,I8);IF(ITYPE=0)[ITYPE=1;]ELSE[ITYPE=0;]
IF (C2='? ') [ C1='?'; CALL HELP_MESSAGE(1); GOTO :CHOICE1:;]
READ(C2,'(I8)')CHOICE1 ;
OUTPUT CHOICE1;('Selected option', I4);

IF(CHOICE1 = 13) GOTO :STOP-FOR-GOOD1:;
IF(CHOICE1>13)|(CHOICE1<0)[
    OUTPUT;(//' SORRY, NO SUCH OPTIONS!'/);
    CALL HELP_MESSAGE(1);
    GOTO :CHOICE1:;
]
IF(CHOICE1 = 0) [
   CALL BEAMDP1;
   GOTO :STOP-FOR-GOOD1:;
]

MSTART=0;"mark a fresh start"
:START-INPUTS-FOR-AN-OPTION:;

" Derive fluence vs position from ph-sp data "
" Derive energy fluence vs position from ph-sp data "
" Derive mean energy distribution from ph-sp data "
" ----------------------------------------------- "
IF(CHOICE1=1)|(CHOICE1=2)|(CHOICE1=5)[
    IF ~EGSPERT[ CALL HELP_MESSAGE(2); ]
   :IA12:
   OUTPUT;(/' FIELD TYPE (0-circular ring, 1-square ring, 2-rectangular): '
   /' ',$);
   READ(5,'(I15)',ERR=:IA11:) MSMFXY ;
   GOTO :IA13:;
   :IA11:
     CALL HELP_MESSAGE(2);
     GOTO :IA12:;
   :IA13:;
   IF ((MSMFXY<0)|(MSMFXY>2)) [
      OUTPUT;(/' SORRY, NO SUCH FIELD TYPE!!!'//);
      GO TO :IA11:;
      ]

   IF (MSMFXY = 0)[" circular field"
     IF ~EGSPERT[ CALL HELP_MESSAGE(3); ]
      :MA2:  ;
      ;OUTPUT;
      (/' Nbin,IQ(-1,0,1,2,3),RFIELD'/' ',$);

      READ(5,'(2I12,F15.0)',ERR=:MA1:)
      NFIELD,IQSMFP(1),RFIELD;
      GOTO :MA3:;
      :MA1:
        CALL HELP_MESSAGE(3);
        GOTO :MA2:;
      :MA3:
      IF (IQSMFP(1)< -1)|(IQSMFP(1)>3)|(NFIELD<0)|(NFIELD > $NB)|(RFIELD<0.)[
         OUTPUT;(//' SORRY, RFIELD SHOULD BE > 0.0'/
                   '        NFIELD SHOULD BE BETWEEN 1 AND $NB');
         OUTPUT; ( ' AND    IQ SHOULD BE -1, 0, 1, 2 OR 3!'//);
         GO TO :MA1:;
      ]
      IF (NFIELD=0)[ NFIELD=40; OUTPUT;(//' Nbin DEFAULTS TO 40'/); ]
      IF (RFIELD=0.)[ RFIELD=15.; OUTPUT;(//' RFIELD DEFAULTS TO 15.0'/); ]
      IF (IQSMFP(1)=0)[ OUTPUT;(/' IQ = 0 (ONLY SCORE FOR PHOTONS)'); ]
   ]

   ELSEIF (MSMFXY = 1)[" square field"
     IF ~EGSPERT[ CALL HELP_MESSAGE(4); ]
      :MA13:
      ;OUTPUT;
      (/' Nbin,IQ(-1,0,1,2,3),HALF-WIDTH'/' ',$);

      READ(5,'(2I12,F15.0)',ERR=:MA12:) NFIELD,IQSMFP(1),RFIELD;
      GOTO :MA14:;
      :MA12:
        CALL HELP_MESSAGE(4);
        GOTO :MA13:;
      :MA14:
      IF (IQSMFP(1)<-1)|(IQSMFP(1)>3)|(NFIELD<0)|(NFIELD>$NB)|(RFIELD<0.)[
         OUTPUT;(//' SORRY, RFIELD SHOULD BE > 0.0'/
                   '        NFIELD SHOULD BE BETWEEN 1 AND $NB');
         OUTPUT;
         (         ' AND    IQ SHOULD BE -1, 0, 1, 2 OR 3!'//);
         GO TO :MA12:;
         ]
      IF (NFIELD=0.)[NFIELD=40;OUTPUT;(/' Nbin defaults to 40'/);]
      IF (RFIELD=0.)[
         RFIELD=15.;
         OUTPUT;(/' HALF-WIDTH DEFAULTS TO 15.0'/);
         ]
      IF (IQSMFP(1)=0)[
         OUTPUT;(/' IQ = 0 (ONLY SCORE FOR PHOTONS)');
         ]
      ]

   ELSEIF (MSMFXY = 2)[" rectangular field"
     IF ~EGSPERT[ CALL HELP_MESSAGE(5); ]
     :MA124:
     ;OUTPUT;
     (/' Nbin,Orient(0:along x,1: y),IQ(-1,0,1,2,3),Xmin,Xmax,Ymin,Ymax'/
      ' ',$);
     READ(5,:FORMAT-CHOICE1:,ERR=:MA123:)
     NFIELD,ISMFPS(1),IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
     :FORMAT-CHOICE1: FORMAT(3I12,4F15.0);
     OUTPUT NFIELD,ISMFPS(1),IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
          (I5, I3,I4,4F10.4);
     GOTO :MA125:;
     :MA123:
       CALL HELP_MESSAGE(5);
       GOTO :MA124:;
     :MA125:
     IF (SMFMNX(1)=0.)&(SMFMNY(1)=0.)&(SMFMXX(1)=0.)&
        (SMFMXY(1)=0.)[
        OUTPUT;(/' Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15');
        SMFMNX(1)=-15.;SMFMXX(1)=15.;SMFMNY(1)=-15.;SMFMXY(1)=15.;
        ]
     IF (SMFMNX(1)>SMFMXX(1))|(SMFMNY(1)>SMFMXY(1))|(IQSMFP(1)<-1)|
        (IQSMFP(1)>3)|(NFIELD<1)|(NFIELD>$NB)|(ISMFPS(1)<0)|(ISMFPS(1)>1)[
        OUTPUT;(//' SORRY, INPUTS SHOULD BE Xmin < Xmax,'/
                  '        NFIELD SHOULD BE BETWEEN 1 AND $NB'/
                  '                         Ymin < Ymax,'/
                  '        Orientation    = 0  or   1');
        OUTPUT;
        (         ' AND    IQ SHOULD BE -1, 0, 1, 2 OR 3!'//);
        GO TO :MA123:;
        ]
     ]"end of field type inputs"
  ]

" Derive spectral distribution from ph-sp data "
" Derive energy fluence distribution from ph-sp data "
" -------------------------------------------------- "
ELSEIF(CHOICE1 = 3 | CHOICE1 = 4)[
   IF ~EGSPERT[ CALL HELP_MESSAGE(6); ]
    :JA124:
    ;OUTPUT;(/' IQ(-1,0,1,2,3),Xmin,Xmax,Ymin,Ymax(or Rmin,Rmax)'/' ',$);
    READ(5,'(I12,4F15.0)',ERR=:JA123:)
    IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
    OUTPUT IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1); (I4,4F10.4);
    GOTO :JA125:;
    :JA123:
      CALL HELP_MESSAGE(6);
      GOTO :JA124:;
    :JA125:
    IF (SMFMNX(1)>SMFMXX(1))|(SMFMNY(1)>SMFMXY(1))|(IQSMFP(1)<-1)|
       (IQSMFP(1)>3)[
        OUTPUT;(//' SORRY, INPUTS SHOULD BE Xmin < Xmax,' /
                  '                         Ymin < Ymax,');
        OUTPUT;
        (         ' AND    IQ SHOULD BE -1, 0, 1, OR 2!'//);
        GO TO :JA123:;
        ]
    IF (SMFMNX(1)=0.)&(SMFMNY(1)=0.)&(SMFMXX(1)=0.)&(SMFMXY(1)=0.)[
       OUTPUT;
       (/' Rectangular region: Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15');
       SMFMNX(1)=-15.;SMFMXX(1)=15.;SMFMNY(1)=-15.;SMFMXY(1)=15.;
       FLUAREA=(SMFMXX(1)-SMFMNX(1))*(SMFMXY(1)-SMFMNY(1));
       MSMFXY=1;
       ]
    ELSEIF (SMFMNY(1)=0.)&(SMFMXY(1)=0.)["suppose for an annular"
       IF(SMFMNX(1)<0.)[SMFMNX(1)=0.;OUTPUT;(/' Rmin defaults to 0.');]
       IF(SMFMXX(1)<=0.)[SMFMXX(1)=15.;OUTPUT;(/' Rmax defaults to 15.');]
       OUTPUT SMFMNX(1),SMFMXX(1);
       (/' Annular region: Rmin,Rmax=',2F10.3);
       FLUAREA=3.1415927*(SMFMXX(1)**2-SMFMNX(1)**2);
       MSMFXY=0;
       ]
    ELSE[
       OUTPUT SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
       (/' Rectangular region: Xmin,Xmax,Ymin,Ymax =',4F10.3);
       FLUAREA=(SMFMXX(1)-SMFMNX(1))*(SMFMXY(1)-SMFMNY(1));
       MSMFXY=1;
       ]
   IF ~EGSPERT[ CALL HELP_MESSAGE(7); ]
   :H2:
   OUTPUT;
   (/' Nbin, Emin, Emax (in MeV, kinetic only) for the distribution ='/' ',$);
   READ(5,'(I15,2F15.0)',ERR=:H1:) NSMFEE,SMFMNE,SMFMXE;
   OUTPUT NSMFEE,SMFMNE,SMFMXE; (I6,2F12.4);
   GOTO :H3:;
   :H1:
    CALL HELP_MESSAGE(7);
    GOTO :H2:;
   :H3:
   IF ((SMFMNE<0.0)|(SMFMNE>SMFMXE)|(SMFMXE<0.0)|(NSMFEE>$NB)|(NSMFEE<1))[
      OUTPUT $NB;(/' SORRY, ENERGIES SHOULD BE Emax > Emin > 0.0 '/
      '    AND BIN NUMBER MUST BE BETWEEN 1 AND ',I4,'!!!'//);
      GO TO :H1:;
      ]
    ]

" Derive angular distribution from ph-sp data "
" ------------------------------------------- "
ELSEIF(CHOICE1 = 6)[
   IF ~EGSPERT[ CALL HELP_MESSAGE(8); ]
    :JA13:
    ;OUTPUT;(/' IQ(-1,0,1,2,3),Xmin,Xmax,Ymin,Ymax(or Rmin,Rmax)'/' ',$);
    READ(5,'(I12,4F15.0)',ERR=:JA12:)
    IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
    OUTPUT IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);(I4,4F10.4);
    GOTO :JA14:;
    :JA12:
      CALL HELP_MESSAGE(8);
      GOTO :JA13:;
    :JA14:
    IF (SMFMNX(1)>SMFMXX(1))|(SMFMNY(1)>SMFMXY(1))|(IQSMFP(1)<-1)|
       (IQSMFP(1)>3)[
        OUTPUT;(//' SORRY, INPUTS SHOULD BE Xmin < Xmax,' /
                  '                         Ymin < Ymax,');
        OUTPUT;
        (         ' AND    IQ SHOULD BE -1, 0, 1, OR 2!'//);
        GO TO :JA12:;
        ]
    IF (SMFMNX(1)=0.)&(SMFMNY(1)=0.)&(SMFMXX(1)=0.)&(SMFMXY(1)=0.)[
       OUTPUT;
       (/' Rectangular region: Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15');
       SMFMNX(1)=-15.;SMFMXX(1)=15.;SMFMNY(1)=-15.;SMFMXY(1)=15.;
       MSMFXY=1;
       ]
    IF (SMFMNY(1)=0.)&(SMFMXY(1)=0.)["suppose for an annular"
       IF(SMFMNX(1)<0.)[SMFMNX(1)=0.;OUTPUT;(/' Rmin defaultS to 0.');]
       IF(SMFMXX(1)<=0.)[SMFMXX(1)=15.;OUTPUT;(/' RmAX defaultS to 15.');]
       OUTPUT SMFMNX(1),SMFMXX(1);
       (/' Annular region: Rmin,Rmax=',2F8.3);
       MSMFXY=0;
       ]
    ELSE[
       OUTPUT SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
       (/' Rectangular region: Xmin,Xmax,Ymin,Ymax =',4F8.3);
       MSMFXY=1;
       ]
   IF ~EGSPERT[ CALL HELP_MESSAGE(9); ]
   :H13:
   OUTPUT;
   (/' Nbin, Amin, Amax (in degree) for the distribution ='/' ',$);
   READ(5,'(I15,2F15.0)',ERR=:H12:)
   NSMFEE,SMFMNE,SMFMXE;
   GOTO :H14:;
   :H12:
     CALL HELP_MESSAGE(9);
     GOTO :H13:;
   :H14:
   IF ((SMFMNE<0.0)|(SMFMNE>SMFMXE)|(SMFMXE>180.)|(NSMFEE>$NBINANGLE)|
      (NSMFEE<0))[
      OUTPUT;(/' SORRY, ANGLE SHOULD BE 180 > Amax > Amin > 0.0 '/
      '    AND BIN NUMBER MUST BE BETWEEN 1 AND ',I4,'!!!'//);
      GO TO :H12:;
      ]
   IF ((SMFMNE=0.0)&(SMFMXE=0.))|(NSMFEE=0)[
      NSMFEE=$NBINANGLE;SMFMNE=0.;SMFMXE=90.;
      OUTPUT$NBINANGLE;(/' Nbin, Amin, Amax default to ',I2,', 0., 90. ');
      ]
   IF ~EGSPERT[ CALL HELP_MESSAGE(52); ]
   :H16:
   OUTPUT;
 (/' Emin, Emax (in MeV, kinetic only) FOR THE ANGULAR DISTRIBUTION ='/' ',$);
   READ(5,'(2F15.0)',ERR=:H15:)
   SMFMNZ(1),SMFMXZ(1);
   GOTO :H17:;
   :H15:
     CALL HELP_MESSAGE(52);
     GOTO :H16:;
   :H17:
   IF ((SMFMNZ(1)<0.0)|(SMFMNZ(1)>SMFMXZ(1))|(SMFMXZ(1)<0.0))[
      OUTPUT ;(/' SORRY, ENERGIES SHOULD BE Emax > Emin > 0.0 '//);
      GO TO :H15:;
      ]
   IF(SMFMNZ(1)=0.0 & SMFMXZ(1)=0.0)[
      SMFMNZ(1)=0.0;SMFMXZ(1)=999.0;
      OUTPUT;(/' Emin, Emax default to 0 MeV, 999 MeV. ');
      ]
    ]

" Derive ZLAST distribution from ph-sp data "
" ----------------------------------------- "
ELSEIF(CHOICE1 = 7)[
   IF ~EGSPERT[ CALL HELP_MESSAGE(10); ]
    :JB13:
    ;OUTPUT;(/' IQ(-1,0,1,2,3),Xmin,Xmax,Ymin,Ymax(or Rmin,Rmax)'/' ',$);
    READ(5,'(I12,4F15.0)',ERR=:JB12:)
    IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
    GOTO :JB14:;
    :JB12:
      CALL HELP_MESSAGE(10);
      GOTO :JB13:;
    :JB14:
    IF (SMFMNX(1)>SMFMXX(1))|(SMFMNY(1)>SMFMXY(1))|(IQSMFP(1)<-1)|
       (IQSMFP(1)>3)[
        OUTPUT;(//' SORRY, INPUTS SHOULD BE Xmin < Xmax,' /
                  '                         Ymin < Ymax,');
        OUTPUT;
        (         ' AND    IQ SHOULD BE -1, 0, 1, OR 2!'//);
        GO TO :JB12:;
        ]
    IF (SMFMNX(1)=0.)&(SMFMNY(1)=0.)&(SMFMXX(1)=0.)&(SMFMXY(1)=0.)[
       OUTPUT;
       (/' Rectangular region: Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15');
       SMFMNX(1)=-15.;SMFMXX(1)=15.;SMFMNY(1)=-15.;SMFMXY(1)=15.;
       MSMFXY=1;
       ]
    IF (SMFMNY(1)=0.)&(SMFMXY(1)=0.)["suppose for an annular"
       IF(SMFMNX(1)<0.)[SMFMNX(1)=0.;OUTPUT;(/' Rmin defaultS to 0.');]
       IF(SMFMXX(1)<=0.)[SMFMXX(1)=15.;OUTPUT;(/' RmAX defaultS to 15.');]
       OUTPUT SMFMNX(1),SMFMXX(1);
       (/' Annular region: Rmin,Rmax=',2F8.3);
       MSMFXY=0;
       ]
    ELSE[
       OUTPUT SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
       (/' Rectangular region: Xmin,Xmax,Ymin,Ymax =',4F8.3);
       MSMFXY=1;
       ]
   IF ~EGSPERT[ CALL HELP_MESSAGE(11); ]
   :HB13:
   OUTPUT;
   (/' Nbin, Zmin, Zmax (in cm) for the distribution ='/' ',$);
   READ(5,'(I15,2F15.0)',ERR=:HB12:)
   NSMFEE,SMFMNE,SMFMXE;
   GOTO :HB14:;
   :HB12:
     CALL HELP_MESSAGE(11);
     GOTO :HB13:;
   :HB14:
   IF ((SMFMNE>SMFMXE)|(NSMFEE>$NBINANGLE)|
      (NSMFEE<0))[
      OUTPUT;(/' SORRY, ZLAST SHOULD BE BETWEEN Zmin AND Zmax '/
      '    AND BIN NUMBER MUST BE BETWEEN 1 AND ',I4,'!!!'//);
      GO TO :HB12:;
      ]
   IF ((SMFMNE=0.0)&(SMFMXE=0.))|(NSMFEE=0)[
      NSMFEE=$NBINANGLE;SMFMNE=0.;SMFMXE=100.;
      OUTPUT$NBINANGLE;(/' Nbin, Zmin, Zmax default to ',I2,', 0., 100. ');
      ]
    ]

" Derive distribution of particle weights from ph-sp data "
" ------------------------------------------------------- "
ELSEIF(CHOICE1 = 8)[
   IF ~EGSPERT[ CALL HELP_MESSAGE(12); ]
    :JA127:
    ;OUTPUT;(/' IQ(-1,0,1,2,3),Xmin,Xmax,Ymin,Ymax(or Rmin,Rmax)'/' ',$);
    READ(5,'(I12,4F15.0)',ERR=:JA126:)
    IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
    GOTO :JA128:;
    :JA126:
      CALL HELP_MESSAGE(12);
      GOTO :JA127:;
    :JA128:
    IF (SMFMNX(1)>SMFMXX(1))|(SMFMNY(1)>SMFMXY(1))|(IQSMFP(1)<-1)|
       (IQSMFP(1)>3)[
        OUTPUT;(//' SORRY, INPUTS SHOULD BE Xmin < Xmax,'/
                  '                         Ymin < Ymax,');
        OUTPUT;
        (         ' AND    IQ SHOULD BE -1, 0, 1, OR 2!'//);
        GO TO :JA126:;
        ]
    IF (SMFMNX(1)=0.)&(SMFMNY(1)=0.)&(SMFMXX(1)=0.)&(SMFMXY(1)=0.)[
       OUTPUT;
       (/' Rectangular region: Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15');
       SMFMNX(1)=-15.;SMFMXX(1)=15.;SMFMNY(1)=-15.;SMFMXY(1)=15.;
       MSMFXY=1;
       ]
    ELSEIF (SMFMNY(1)=0.)&(SMFMXY(1)=0.)["suppose for an annular"
       IF(SMFMNX(1)<0.)[SMFMNX(1)=0.;OUTPUT;(/' Rmin defaults to 0.');]
       IF(SMFMXX(1)<=0.)[SMFMXX(1)=15.;OUTPUT;(/' Rmax defaults to 15.');]
       OUTPUT SMFMNX(1),SMFMXX(1);
       (/' Annular region: Rmin,Rmax=',2F10.3);
       MSMFXY=0;
       ]
    ELSE[
       OUTPUT SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
       (/' Rectangular region: Xmin,Xmax,Ymin,Ymax =',4F10.3);
       MSMFXY=1;
       ]
   IF ~EGSPERT[ CALL HELP_MESSAGE(13); ]
   :H5:
   OUTPUT;
   (/' Nbin, MIN WEIGHT, MAX WEIGHT FOR THE DISTRIBUTION ='/' ',$);
   READ(5,'(I15,2F15.0)',ERR=:H4:)
   NSMFEE,SMFMNE,SMFMXE;
   GOTO :H6:;
   :H4:
     CALL HELP_MESSAGE(13);
     GOTO :H5:;
   :H6:
   IF ((SMFMNE<=0)|(SMFMNE>SMFMXE)|(NSMFEE>$NB)|(NSMFEE<1))[
     OUTPUT $NB;(/' SORRY, MIN WEIGHT MUST BE > 0 '/
                  ' WITH MAX WEIGHT > MIN WEIGHT '/
                  ' AND BIN NUMBER MUST BE BETWEEN 1 AND ',I4,'!!!'//);
      GO TO :H4:;
      ]
    ]

" Derive X-Y scatter plot of particles from ph-sp data "
" ---------------------------------------------------- "
ELSEIF(CHOICE1 = 9)[
   IF ~EGSPERT[ CALL HELP_MESSAGE(14); ]
    :JA130:
    ;OUTPUT;(/' IQ(-1,0,1,2,3),Xmin,Xmax,Ymin,Ymax(or Rmin,Rmax)'/' ',$);
    READ(5,'(I12,4F15.0)',ERR=:JA129:)
    IQSMFP(1),SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
    GOTO :JA131:;
    :JA129:
      CALL HELP_MESSAGE(14);
      GOTO :JA130:;
    :JA131:
    IF (SMFMNX(1)>SMFMXX(1))|(SMFMNY(1)>SMFMXY(1))|(IQSMFP(1)<-1)|
       (IQSMFP(1)>3)[
        OUTPUT;(//' SORRY, INPUTS SHOULD BE Xmin < Xmax,' /
                  '                         Ymin < Ymax,');
        OUTPUT;
        (         ' AND    IQ SHOULD BE -1, 0, 1, OR 2!'//);
        GO TO :JA129:;
        ]
    IF (SMFMNX(1)=0.)&(SMFMNY(1)=0.)&(SMFMXX(1)=0.)&(SMFMXY(1)=0.)[
       OUTPUT;
       (/' Rectangular region: Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15');
       SMFMNX(1)=-15.;SMFMXX(1)=15.;SMFMNY(1)=-15.;SMFMXY(1)=15.;
       MSMFXY=1;
       ]
    ELSEIF (SMFMNY(1)=0.)&(SMFMXY(1)=0.)["suppose for an annular"
       IF(SMFMNX(1)<0.)[SMFMNX(1)=0.;OUTPUT;(/' Rmin defaults to 0.');]
       IF(SMFMXX(1)<=0.)[SMFMXX(1)=15.;OUTPUT;(/' Rmax defaults to 15.');]
       OUTPUT SMFMNX(1),SMFMXX(1);
       (/' Annular region: Rmin,Rmax=',2F10.3);
       MSMFXY=0;
       ]
    ELSE[
       OUTPUT SMFMNX(1),SMFMXX(1),SMFMNY(1),SMFMXY(1);
       (/' Rectangular region: Xmin,Xmax,Ymin,Ymax =',4F10.3);
       MSMFXY=1;
       ]
   IF ~EGSPERT[ CALL HELP_MESSAGE(15); ]
   :H21:
   OUTPUT;
   (/' Emin, Emax (in MeV, kinetic only) FOR THE SCATTER PLOT ='/' ',$);
   READ(5,'(2F15.0)',ERR=:H20:)
   SMFMNE,SMFMXE;
   GOTO :H22:;
   :H20:
     CALL HELP_MESSAGE(15);
     GOTO :H21:;
   :H22:
   IF ((SMFMNE<0.0)|(SMFMNE>SMFMXE)|(SMFMXE<0.0))[
      OUTPUT $NB;(/' SORRY, ENERGIES SHOULD BE Emax > Emin > 0.0 '//);
      GO TO :H20:;
      ]
    ]

" CHOICE1 = 1-8 case "
" ------------------ "
IF(CHOICE1>0)&(CHOICE1<10)[

    IF ~EGSPERT[ "inputs for LATCH"
      CALL HELP_MESSAGE(16);
      CALL HELP_MESSAGE(17);
      CALL HELP_MESSAGE(18); ]
    :LA21:;
    OUTPUT;
(/' Input three integer variables on one line: I_IN_EX, Nbit1,Nbit2'/
' I_IN_EX (0-incl/excl bits, 1-excl bits, 2-incl regions, 3-excl regions),'/
' Nbit1   (# bits or regions to incl (if I_IN_EX=0 or 2) or excl ',
                                    '(I_IN_EX=1 or 3),'/
' Nbit2   (# bits to excl (I_IN_EX=0 only)--all on one line :'/
    ' ',$);
    READ(5,'(3I8)',ERR=:LA20:)I_IN_EX,NBIT1,NBIT2;
    OUTPUT I_IN_EX,NBIT1,NBIT2; (3I6);
    GOTO :LA22:;
    :LA20:
      CALL HELP_MESSAGE(16);
      CALL HELP_MESSAGE(17);
      GOTO :LA21:;
    :LA22:
    IF(I_IN_EX < 0 | I_IN_EX > 3)[
        OUTPUT;(//' I_IN_EX OUT OF RANGE.  TRY AGAIN.');
        CALL HELP_MESSAGE(16);
 GO TO :LA21:;
    ]

    IF(I_IN_EX~=0 & NBIT2 ~= 0)[
        OUTPUT;(//' ***WARNING: Nbit2 is not 0 and you are using'/
                  ' I_IN_EX=1, 2 or 3.  Nbit2 set to 0 here.'//);
        NBIT2=0;
    ]

    IF (NBIT1<0)[
        OUTPUT;(//' SORRY, YOU SHOULD INPUT Nbit1 >= 0');
        CALL HELP_MESSAGE(17);
 GO TO :LA21:;
        ]
    IF(NBIT2<0)[
        OUTPUT;(//' SORRY, YOU SHOULD INPUT Nbit2 >= 0');
        CALL HELP_MESSAGE(17);
 GO TO :LA21:;
        ]

    IF (I_IN_EX < 2 & (NBIT1+NBIT2<0|NBIT1+NBIT2>29))[
        OUTPUT;(//' SORRY, YOU SHOULD INPUT 0 <= total # of bits <= 29');
        CALL HELP_MESSAGE(16);
 CALL HELP_MESSAGE(17);
 GO TO :LA21:;
        ]
    ELSEIF(NBIT1<0|NBIT1>24)[
        OUTPUT;(//' SORRY, YOU SHOULD INPUT 0 <= total # of regions <= 24');
        CALL HELP_MESSAGE(16);
 CALL HELP_MESSAGE(17);
 GO TO :LA21:;
        ]

    IF(NBIT1 ~= 0)[
       :LA23:;
       IF(I_IN_EX=0|I_IN_EX=2)[
         OUTPUT; (/' BIT(I)/IREGION_TO_BIT(I) (I=1,Nbit1) to include:'/' ',$);
       ]
       IF(I_IN_EX=1|I_IN_EX=3)[
         OUTPUT; (/' BIT(I)/IREGION_TO_BIT(I) (I=1,Nbit1) to exclude:'/' ',$);
       ]
       READ(5,'(29I8)',ERR=:LA24:)(LATCH(I),I=1,NBIT1);
       GOTO :LA25:;
       :LA24:
         CALL HELP_MESSAGE(18);
         GOTO :LA23:;
       :LA25:
       DO I=1,NBIT1[
           IF (I_IN_EX < 2 & (LATCH(I)<0|LATCH(I)>28))[
              OUTPUT;(//' SORRY, YOU SHOULD INPUT 0 <= BIT(I) <= 28');
              CALL HELP_MESSAGE(18);GOTO :LA23:;
           ]
           ELSEIF(I_IN_EX >= 2 & (LATCH(I)<0|LATCH(I)>23))[
           OUTPUT;(//' SORRY, YOU SHOULD INPUT 0 <= IREGION_TO_BIT(I) <= 23');
              CALL HELP_MESSAGE(18);GOTO :LA23:;
           ]
       ]
    ]
    IF(NBIT2 ~= 0)[
       :LA26:
       OUTPUT;
      (/' BIT(I)/IREGION_TO_BIT(I) (I=Nbit1+1,Nbit1+Nbit2) to exclude:'/' ',$);
       READ(5,'(29I8)',ERR=:LA27:)(LATCH(NBIT1+I),I=1,NBIT2);
       GOTO :LA28:;
       :LA27:
         CALL HELP_MESSAGE(18);
         GOTO :LA26:;
       :LA28:
       DO I=1,NBIT2[
           IF (LATCH(NBIT1+I)<0 | LATCH(NBIT1+I)>28)[
              OUTPUT;(//' SORRY, YOU SHOULD INPUT 0 <= BIT(I) <= 28');
               CALL HELP_MESSAGE(18);GOTO :LA26:;
           ]
       ]
    ]
]

" List parameters for a number of ph-sp particles "
" ----------------------------------------------- "
IF(CHOICE1=11)[

    IF ~EGSPERT[ CALL HELP_MESSAGE(19); ]
    :LB2:
    OUTPUT;
    (/' From particle no. (default=1), to particle no. (default=100),'
      ' IQ(-1,0,1,2,3) =?'/' ',$);
    READ(5,'(3I12)',ERR=:LB1:)NUMBERST,NUMBERP,IQSMFP(1);
    GOTO :LB3:;
    :LB1:
      CALL HELP_MESSAGE(19);
      GOTO :LB2:;
    :LB3:
    IF (NUMBERST<1)[
        NUMBERST=1;
        OUTPUT;(/' First particle no. defaults to 1!');
        ]
    IF (NUMBERP<1)[
        NUMBERP=100;
        OUTPUT;(/' Last particle no. defaults to 100!');
        ]
    IF(IQSMFP(1)<-1)|(IQSMFP(1)>3)[
        IQSMFP(1)=2;"defaults to all the particles"
        OUTPUT;(/' IQ defaults to 2 (all the particles)!');
        ]
    ELSEIF(IQSMFP(1)=0)[ OUTPUT;(/' IQ = 0 (only for photons)'); ]
]

" Output 3D points to a file for plotting"
IF(CHOICE1=12)[

    IF ~EGSPERT[ CALL HELP_MESSAGE(84); ]
    :LB4:
    OUTPUT;(/' min. MU, max. MU, no. of particles to plot '/
             ' (defaults are 0, 1, and all particles in the range): ',$);
    READ(5,*) mumin,mumax,NUMBERP;
    IF(mumin<0)mumin=0.0;
    IF(mumax<mumin|mumax=0)mumax=1.0;
    OUTPUT mumin,mumax;
        (/' Will output (X,Y,Z) over MU range ',F8.3,' to ',F8.3);
/* below was when I wanted to give user option to plot any 3 coordinates
Think it is better just to give the user the option of specifying
a MU range and no. of particles
    OUTPUT;
    (/' X, Y, Z, MU (any 3), no. of particles to plot (default is all)'/
      ' : ',$);
    READ(5,'(3A,I5)',ERR=:LB5:)AC(1),AC(2),AC(3),NUMBERP;
    GOTO :LB6:;
    :LB5:
      CALL HELP_MESSAGE(84);
      GOTO :LB4:;
    :LB6:
    "strip trailing commas"
    DO I=1,3[
      DO J=1,lnblnk1(AC(I))[
         IF(AC(I)(J:J)=',')AC(I)=AC(I)(1:J-1);
      ]
    ]
    DO I=1,3[
      IF(AC(I)(1:lnblnk1(AC(I)))~='X' & AC(I)(1:lnblnk1(AC(I)))~='Y' &
         AC(I)(1:lnblnk1(AC(I)))~='Z' & AC(I)(1:lnblnk1(AC(I)))~='MU')[
      OUTPUT; (' Error: Unrecognized data type input.  Try again.');
      GOTO :LB4:;
      ]
    ]
    OUTPUT AC(1),AC(2),AC(3);
     (' Will output (',A2,',',A2,',',A2,')'/);
*/
    IF(NUMBERP<=0)[
      OUTPUT;(' Will output all particles in the range.'/);
    ]
    ELSE[
      OUTPUT NUMBERP; (' Will output ',I5,' particles. '/);
    ]
]

" Open phase space file and read it "
" --------------------------------- "
IF(MSTART=0 & ((CHOICE1>0 & CHOICE1<10)|CHOICE1=11|CHOICE1=12))[
   CALL READNAME;
   CALL OPENFILE;
]

" List parameters for a number of ph-sp particles "
" ----------------------------------------------- "
IF(MSTART=0 & CHOICE1=11)[
   IF(MODE_RW='MODE0')[
      WRITE(6,:LIST-FORMAT0:);
      :LIST-FORMAT0: FORMAT(/' ENERGY  IQ     X',
      5X, '  Y',4X,'  U',4X,'  V',4X,'  W',4X,'WEIGHT',6X,
      ' LATCH (set=1, not set=0)'/);
   ]
   ELSEIF(MODE_RW='MODE2')[
      WRITE(6,:LIST-FORMAT01:);
      :LIST-FORMAT01: FORMAT(/' ENERGY  IQ     X',
      5X, '  Y',4X,'  U',4X,'  V',4X,'  W',4X,' ZLAST   WEIGHT',6X,
      ' LATCH (set=1, not set=0)'/);
   ]
   CALL READ_DATA;"to read the ph-sp file"
]

IF(MSTART=0 & CHOICE1=12)[
  /* Checks below no longer used
   DO I=1,3[
     IF(AC(I)(1:lnblnk1(AC(I)))='Z' & IZSCORE1=0)[
       OUTPUT;(' Error: You have requested Z as one of the coordinates'/
               ' to plot, but the data does not include Z for each particle.'/
               ' Try again.'/);
       STOP;
     ]
     IF(AC(I)(1:lnblnk1(AC(I)))='Z' & IZSCORE1=0)[
       OUTPUT;(' Error: You have requested MU as one of the coordinates'/
               ' to plot, but the data does not include this.'/
               ' Try again.'/);
       STOP;
     ]
   ]
 */
   IF(IMUIDX1=0)[
      OUTPUT;(' This file does not include MU for each particle.'/
              ' Will not filter based on MU range.'/);
   ]
   OUTPUT;(/' Name of file to save data for graph plotting:'/' ',$);
   INPUT SPCNAM;(A80);
   OPEN(UNIT=3,STATUS='UNKNOWN',FILE=SPCNAM);
   CALL READ_DATA;"to read the ph-sp file"
   CLOSE(3);
]

" CHOICE1 = 1-8 case "
" ------------------ "
IF(CHOICE1>0 & CHOICE1<10)[
  IF(MSTART=0)[
    OUTPUT;(/' Name of file to save data for graph plotting:'/' ',$);
    INPUT SPCNAM;(A80);
    OUTPUT SPCNAM;(' File name input is:', A80);

    OPEN(UNIT=3,STATUS='UNKNOWN',FILE=SPCNAM);
    IF(CHOICE1<9)[
      IF ~EGSPERT[ CALL HELP_MESSAGE(20); ]

      :ITYPE:

      OUTPUT;(/' INPUT GRAPH TYPE (0: normal, 1: histogram) ');
      OUTPUT;(/' ',$);

      INPUT C1;(A1);
      IF (C1='?') [   CALL HELP_MESSAGE(20); GOTO :ITYPE:; ]
      READ(C1,'(I8)')ITYPE ;
      IF(ITYPE~=1)[ITYPE=0;]

      IF(CHOICE1>=1 & CHOICE1<=4)[
         IF ~EGSPERT[
      CALL HELP_MESSAGE(21);
      IF(CHOICE1 = 2 | CHOICE1 = 4)[
               OUTPUT;(/' The fluence being estimated is the energy fluence'/);
           ]
         ]
         :FLUTYPE:
         OUTPUT;
         (/' Plot planar fluence (1) or estimate of real fluence (0--default)');
         OUTPUT;(/' ',$);
         INPUT C1;(A1);
         IF (C1='?') [ CALL HELP_MESSAGE(21); GOTO :FLUTYPE:; ]
         READ(C1,'(I8)')FLUTYPE;
         IF(FLUTYPE~=1)[FLUTYPE=0;]
      ]
      ELSEIF(CHOICE1=6)["give user choice to plot particles/unit solid angle"
         IF ~EGSPERT[ CALL HELP_MESSAGE(53); ]
         :ANGTYPE:
         OUTPUT;
    (/' Plot particles/solid angle (1) or particles/angular bin (0--default)');
         OUTPUT;(/' ',$);
         INPUT C1;(A1);
         IF (C1='?')[ CALL HELP_MESSAGE(53); GOTO :ANGTYPE:; ]
         READ(C1,'(I8)')ANGTYPE;
         IF(ANGTYPE~=1)[ANGTYPE=0;]
      ]
    ]
  ]"end of if MSTART=0"

  " Ask the user how many particles they want to plot "
  IF(CHOICE1=9)[
      IF ~EGSPERT[ CALL HELP_MESSAGE(51); ]
      :SCATTINPUT:
      OUTPUT;
      (/' Input the maximum number of particles to include in scatter plot'/
        ' (default=total number of particles in phase space file).');
      OUTPUT;(/' ',$);
      READ(5,'(I12)',ERR=:SCATTERR:)MAXSCATTER;
      GOTO :SCATTOK:;
      :SCATTERR:
        CALL HELP_MESSAGE(51);
        GOTO :SCATTINPUT:;
      :SCATTOK:
      IF (MAXSCATTER<=0 | MAXSCATTER>PARANOT)[
        MAXSCATTER=PARANOT;
        OUTPUT MAXSCATTER;(/' Number defaults to',I12/);
      ]
  ]

    :BEGIN-READING-PH-SP-DATA:;

    SERIESTITLE(1:4)='IQ =';
    SERIESTITLE(5:6)=LETTER1(IQSMFP(1)+2);
    IF(NBIT1=0 & NBIT2 = 0)[ SERIESTITLE(7:60)=' NO LATCH CHECK'; ]
    ELSE[
       IF(I_IN_EX=0)["inclusive and exclusive bits"
          IF(NBIT1 > 0)[
             SERIESTITLE(7:19)=' INCL BIT #: ';
             DO I=1,NBIT1[
               SERIESTITLE(17+3*I:60)=LETTER2(LATCH(I));
             ]
          ]
          ELSE [SERIESTITLE(7:19)='             ';]
          "we should really fix this to not leave the space but I am lazy"
          IF(NBIT2>0)[
             SERIESTITLE(17+3*NBIT1+2:17+3*NBIT1+14)=' EXCL BIT #: ';
             DO I=1,NBIT2[
               SERIESTITLE(17+3*(NBIT1+I-1)+15:60)=
                       LETTER2(LATCH(NBIT1+I));
             ]
          ]
       ]
       ELSEIF(I_IN_EX=1)[
          SERIESTITLE(7:19)=' EXCL BIT #: ';
          DO I=1,NBIT1[
            SERIESTITLE(17+3*I:60)=LETTER2(LATCH(I));
          ]
       ]
       IF(I_IN_EX=2)[
          SERIESTITLE(7:26)=' INCL REGION BIT #: ';
          DO I=1,NBIT1[
            SERIESTITLE(24+3*I:60)=LETTER2(LATCH(I));
          ]
       ]
       ELSEIF(I_IN_EX=3)[
          SERIESTITLE(7:26)=' EXCL REGION BIT #: ';
          DO I=1,NBIT1[
            SERIESTITLE(24+3*I:60)=LETTER2(LATCH(I));
          ]
       ]
    ]

    " Special case here because this option does not use xvgrplot"
    IF(CHOICE1 = 9)[
      WRITE(6,*)'Begin writing graph data into file...';
             IF(MSTART=0)[
                 WRITE(3,:101:)PSDNAM(1:lnblnk1(PSDNAM));
      :101: FORMAT('@g0 type xy '/
                   ,'@    title "X-Y scatter plot"'/
                   ,'@    subtitle "',A,'"'/
                   ,'@    legend on'/
                   ,'@    legend x1 0.6'/
                   ,'@    legend y1 0.75'/
                   ,'@    view xmin 0.250000'/
                   ,'@    xaxis  label "X (cm)"'/
                   ,'@    yaxis  label "Y (cm)"');
             ]
             "find exact length of series title"
             IIII=61;
             LOOP [
                IIII = IIII - 1;
             ] UNTIL (SERIESTITLE(IIII:IIII) ~= ' ');
             WRITE(3,:102:)MSTART,MSTART,MSTART,MSTART+1,
                           MSTART,SERIESTITLE(1:IIII);
      :102: FORMAT('@    s',I1,' symbol 1'/
                  ,'@    s',I1,' linestyle 0'/
                  ,'@    s',I1,' symbol color ',I2/
                  ,'@    legend string ',I2,' "',A,'"');
    ]

    CALL READ_DATA;"moved so that seriestitle defined first"

    IF(CHOICE1<9)[WRITE(6,*)'Begin writing graph data into file...';]

    YPLOTT=FLOAT(IPARANOT-1);"this is the total number of particles read"
    IF(CHOICE1=1)[
       GRAPHTITLE='fluence vs position';
       IF(FLUTYPE=1)[ YTITLE='planar fluence/incident particle /cm\\S-2\\N'; ]
       ELSE[ YTITLE='fluence/incident particle /cm\\S-2\\N'; ]
       IF(MSMFXY=0)["circular field"
          XTITLE='R /cm ';
          DO II=1,NFIELD[

               $ANALYZE(II:FSMFRR(1,II):FSMFRR(2,II));

               XPLOT(II)=SQRT(FLOAT(II)/FLOAT(NFIELD))*RFIELD;
               YPLOT(II)=FSMFRR(1,II)/(3.1415927*RFIELD**2/NFIELD);
               ERRYPLOT(II)=FSMFRR(2,II)/(3.1415927*RFIELD**2/NFIELD);
          ]
          HXMIN=0.;
          IF(ITYPE=0)["make sure we plot center points"
            DO II=NFIELD,1,-1[
              IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
              ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
            ]
          ]
          CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
          SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
          ]
       ELSEIF(MSMFXY=1)["a square field with equal area square rings"
          XTITLE='X /cm ';
          DO II=1,NFIELD[

             $ANALYZE(II:FSMFRR(1,II):FSMFRR(2,II));

             XPLOT(II)=RFIELD*SQRT(FLOAT(II)/FLOAT(NFIELD));
             YPLOT(II)=FSMFRR(1,II)/(4*RFIELD**2/NFIELD);
             ERRYPLOT(II)=FSMFRR(2,II)/(4*RFIELD**2/NFIELD);
          ]
          HXMIN=0.;
          IF(ITYPE=0)["make sure we plot center points"
            DO II=NFIELD,1,-1[
              IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
              ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
            ]
          ]
          CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
          SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
          ]
       ELSEIF(MSMFXY=2)["rectangular field"
          IF(ISMFPS(1)=0)["planar fluence along x-axis"
             XTITLE='X /cm';
             DO II=1,NFIELD[

                $ANALYZE(II:FSMFXX(1,II):FSMFXX(2,II));

                XPLOT(II)=((SMFMXX(1)-SMFMNX(1))*FLOAT(II)/FLOAT(NFIELD))
                 +SMFMNX(1);

                YPLOT(II)=FSMFXX(1,II)/((SMFMXX(1)-SMFMNX(1))*
                                     (SMFMXY(1)-SMFMNY(1))/NFIELD);

                ERRYPLOT(II)=FSMFXX(2,II)/((SMFMXX(1)-SMFMNX(1))*
                                (SMFMXY(1)-SMFMNY(1))/NFIELD);
             ]
             HXMIN=SMFMNX(1);
             IF(ITYPE=0)["make sure we plot center points"
               DO II=NFIELD,1,-1[
                 IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
                 ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               ]
             ]
             CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
              SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
             ]
          ELSE["along y-axis"
             XTITLE='Y /cm';
             DO II=1,NFIELD[

                $ANALYZE(II:FSMFYY(1,II):FSMFYY(2,II));

                XPLOT(II)=((SMFMXY(1)-SMFMNY(1))*FLOAT(II)/FLOAT(NFIELD))
                +SMFMNY(1);

                YPLOT(II)=FSMFYY(1,II)/((SMFMXX(1)-SMFMNX(1))*
                                     (SMFMXY(1)-SMFMNY(1))/NFIELD);

                ERRYPLOT(II)=FSMFYY(2,II)/((SMFMXX(1)-SMFMNX(1))*
                               (SMFMXY(1)-SMFMNY(1))/NFIELD);
             ]
             HXMIN=SMFMNY(1);
             IF(ITYPE=0)["make sure we plot center points"
               DO II=NFIELD,1,-1[
                 IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
                 ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               ]
             ]
             CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
             SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
             ]
          ]
       ]

    IF(CHOICE1=2)[
       GRAPHTITLE='energy fluence vs position';
       IF(FLUTYPE=1)[
          YTITLE='planar energy fluence/incident particle /MeV cm\\S-2\\N)';
       ]
       ELSE[
          YTITLE='energy fluence/incident particle /MeV cm\\S-2\\N)';
       ]
       IF(MSMFXY=0)["circular field"
          XTITLE='R /cm';
          DO II=1,NFIELD[
             $ANALYZE(II:FSMFRR(1,II):FSMFRR(2,II));
             XPLOT(II)=SQRT(FLOAT(II)/FLOAT(NFIELD))*RFIELD;
             YPLOT(II)=FSMFRR(1,II)/(3.1415927*RFIELD**2/NFIELD);
             ERRYPLOT(II)=FSMFRR(2,II)/(3.1415927*RFIELD**2/NFIELD);
          ]
          HXMIN=0.;
          IF(ITYPE=0)["make sure we plot center points"
            DO II=NFIELD,1,-1[
                 IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
                 ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
            ]
          ]
          CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
          SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
          ]
       ELSEIF(MSMFXY=1)["a square field with square rings, equal area"
          XTITLE='X /cm';
          DO II=1,NFIELD[
             $ANALYZE(II:FSMFRR(1,II):FSMFRR(2,II));
             XPLOT(II)=RFIELD*SQRT(FLOAT(II)/FLOAT(NFIELD));
             YPLOT(II)=FSMFRR(1,II)/(4*RFIELD**2/NFIELD);
             ERRYPLOT(II)=FSMFRR(2,II)/(4*RFIELD**2/NFIELD);
          ]
          HXMIN=0.;
          IF(ITYPE=0)["make sure we plot center points"
            DO II=NFIELD,1,-1[
                 IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
                 ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
            ]
          ]
          CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
          SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
          ]
       ELSEIF(MSMFXY=2)["rectangular field"
          IF(ISMFPS(1)=0)["planar fluence along x-axis"
             XTITLE='X /cm';
             DO II=1,NFIELD[
                $ANALYZE(II:FSMFXX(1,II):FSMFXX(2,II));
                XPLOT(II)=((SMFMXX(1)-SMFMNX(1))*FLOAT(II)/FLOAT(NFIELD))
                 +SMFMNX(1);
                YPLOT(II)=FSMFXX(1,II)/((SMFMXX(1)-SMFMNX(1))*
                                     (SMFMXY(1)-SMFMNY(1))/NFIELD);
                ERRYPLOT(II)=FSMFXX(2,II)/((SMFMXX(1)-SMFMNX(1))*
                                     (SMFMXY(1)-SMFMNY(1))/NFIELD);
             ]
             HXMIN=SMFMNX(1);
             IF(ITYPE=0)["make sure we plot center points"
               DO II=NFIELD,1,-1[
                 IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
                 ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               ]
             ]
             CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
              SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
             ]
          ELSE["along y-axis"
             XTITLE='Y /cm';
             DO II=1,NFIELD[
                $ANALYZE(II:FSMFYY(1,II):FSMFYY(2,II));
                XPLOT(II)=((SMFMXY(1)-SMFMNY(1))*FLOAT(II)/FLOAT(NFIELD))
                +SMFMNY(1);
                YPLOT(II)=FSMFYY(1,II)/((SMFMXX(1)-SMFMNX(1))*
                                     (SMFMXY(1)-SMFMNY(1))/NFIELD);
                ERRYPLOT(II)=FSMFYY(2,II)/((SMFMXX(1)-SMFMNX(1))*
                                     (SMFMXY(1)-SMFMNY(1))/NFIELD);
             ]
             HXMIN=SMFMNY(1);
             IF(ITYPE=0)["make sure we plot center points"
               DO II=NFIELD,1,-1[
                 IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
                 ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               ]
             ]
             CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
             SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
             ]
          ]
       ]

    ELSEIF(CHOICE1=3)[
       GRAPHTITLE='spectral distribution';
       IF(FLUTYPE=1)[
          YTITLE='planar fluence/MeV/incident particle /cm\\S-2\\N MeV\\S-1\\N';
       ]
       ELSE[
          YTITLE='fluence/MeV/incident particle /cm\\S-2\\N MeV\\S-1\\N';
       ]
       XTITLE='energy /MeV';
       DO II=1,NSMFEE[
          $ANALYZE(II:FSMFBN1(1,1,II):FSMFBN1(2,1,II));
          XPLOT(II)=(SMFMXE-SMFMNE)*FLOAT(II)/FLOAT(NSMFEE)+SMFMNE;
          YPLOT(II)=FSMFBN1(1,1,II)/(FLUAREA*
                    (SMFMXE-SMFMNE)/FLOAT(NSMFEE));
          ERRYPLOT(II)=FSMFBN1(2,1,II)/(FLUAREA*
                    (SMFMXE-SMFMNE)/FLOAT(NSMFEE));
       ]
       HXMIN=SMFMNE;
       IF(ITYPE=0)["make sure we plot center points"
            DO II=NSMFEE,1,-1[
                 IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
                 ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
            ]
       ]
       CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NSMFEE,MSTART,
       SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
       ]

    ELSEIF(CHOICE1=4)[
       GRAPHTITLE='energy fluence distribution';
       IF(FLUTYPE=1)[
          YTITLE='planar energy fluence/MeV/incident particle  /cm\\S-2\\N';
       ]
       ELSE[
          YTITLE='energy fluence/MeV/incident particle  /cm\\S-2\\N';
       ]
       XTITLE='energy /MeV';
       DO II=1,NSMFEE[
          $ANALYZE(II:FSMFBN1(1,1,II):FSMFBN1(2,1,II));
          XPLOT(II)=(SMFMXE-SMFMNE)*FLOAT(II)/FLOAT(NSMFEE)+SMFMNE;
          YPLOT(II)=FSMFBN1(1,1,II)/(FLUAREA*
                    (SMFMXE-SMFMNE)/FLOAT(NSMFEE));
          ERRYPLOT(II)=FSMFBN1(2,1,II)/(FLUAREA*
                    (SMFMXE-SMFMNE)/FLOAT(NSMFEE));
       ]
       HXMIN=SMFMNE;
       IF(ITYPE=0)["make sure we plot center points"
            DO II=NSMFEE,1,-1[
                 IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
                 ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
            ]
       ]
       CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NSMFEE,MSTART,
       SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
       ]

    ELSEIF(CHOICE1=5)[
       GRAPHTITLE='mean energy distribution';
       YTITLE='mean energy /MeV';
       IF(MSMFXY=0)["circular field"
          XTITLE='R /cm';
          DO II=1,NFIELD[
             $ANALYZE_COV(II:FSMFBN1(1,1,II):FSMFBN1(2,1,II):FSMFBN1(1,2,II):
                        FSMFBN1(2,2,II):FSMFBN1(3,1,II));
             XPLOT(II)=SQRT(FLOAT(II)/FLOAT(NFIELD))*RFIELD;
             IF(FSMFBN1(1,1,II)=0.)[YPLOT(II)=0;]
             ELSE[YPLOT(II)=FSMFBN1(1,1,II)/FSMFBN1(1,2,II);]
             IF(FSMFBN1(1,1,II)=0.)|(FSMFBN1(1,2,II)=0.)[ERRYPLOT(II)=0;]
             ELSE[ERRYPLOT(II)=FSMFBN1(2,1,II)*YPLOT(II);]
          ]
          HXMIN=0.;
          IF(ITYPE=0)["make sure we plot center points"
            DO II=NFIELD,1,-1[
                 IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
                 ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
            ]
          ]
          CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
          SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
          ]
       ELSEIF(MSMFXY=1)["a square field with square rings, equal area"
          XTITLE='X /cm';
          DO II=1,NFIELD[
             $ANALYZE_COV(II:FSMFBN1(1,1,II):FSMFBN1(2,1,II):FSMFBN1(1,2,II):
                        FSMFBN1(2,2,II):FSMFBN1(3,1,II));
             XPLOT(II)=RFIELD*SQRT(FLOAT(II)/FLOAT(NFIELD));
             IF(FSMFBN1(1,1,II)=0.)[YPLOT(II)=0;]
             ELSE[YPLOT(II)=FSMFBN1(1,1,II)/FSMFBN1(1,2,II);]
             IF(FSMFBN1(1,1,II)=0.)|(FSMFBN1(1,2,II)=0.)[ERRYPLOT(II)=0;]
             ELSE[ERRYPLOT(II)=FSMFBN1(2,1,II)*YPLOT(II);]
          ]
          HXMIN=0.;
          IF(ITYPE=0)["make sure we plot center points"
            DO II=NFIELD,1,-1[
                 IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
                 ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
            ]
          ]
          CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
           SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
          ]
       ELSEIF(MSMFXY=2)["rectangular field"
          IF(ISMFPS(1)=0)["planar fluence along x-axis"
             XTITLE='X /cm';
             DO II=1,NFIELD[
                $ANALYZE_COV(II:FSMFBN1(1,1,II):FSMFBN1(2,1,II):FSMFBN1(1,2,II):
                        FSMFBN1(2,2,II):FSMFBN1(3,1,II));
                XPLOT(II)=((SMFMXX(1)-SMFMNX(1))*FLOAT(II)/FLOAT(NFIELD))
                 +SMFMNX(1);
                IF(FSMFBN1(1,1,II)=0.)[YPLOT(II)=0.;]
                ELSE[YPLOT(II)=FSMFBN1(1,1,II)/FSMFBN1(1,2,II);]
                IF(FSMFBN1(1,1,II)=0.)|(FSMFBN1(1,2,II)=0.)[ERRYPLOT(II)=0;]
                ELSE[ERRYPLOT(II)=FSMFBN1(2,1,II)*YPLOT(II);]
             ]
             HXMIN=SMFMNX(1);
             IF(ITYPE=0)["make sure we plot center points"
               DO II=NFIELD,1,-1[
                 IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
                 ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               ]
             ]
             CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
             SERIESTITLE,XTITLE,
             YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
             ]
          ELSE["along y-axis"
             XTITLE='Y /cm';
             DO II=1,NFIELD[
                $ANALYZE_COV(II:FSMFBN1(1,1,II):FSMFBN1(2,1,II):FSMFBN1(1,2,II):
                        FSMFBN1(2,2,II):FSMFBN1(3,1,II));
                XPLOT(II)=((SMFMXY(1)-SMFMNY(1))*FLOAT(II)/FLOAT(NFIELD))
                +SMFMNY(1);
                IF(FSMFBN1(1,1,II)=0.)[YPLOT(II)=0.;]
                ELSE[YPLOT(II)=FSMFBN1(1,1,II)/FSMFBN1(1,2,II);]
                IF(FSMFBN1(1,1,II)=0.)|(FSMFBN1(1,2,II)=0.)[ERRYPLOT(II)=0;]
                ELSE[ERRYPLOT(II)=FSMFBN1(2,1,II)*YPLOT(II);]
             ]
             HXMIN=SMFMNY(1);
             IF(ITYPE=0)["make sure we plot center points"
               DO II=NFIELD,1,-1[
                 IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
                 ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
               ]
             ]
             CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
             SERIESTITLE,XTITLE,
             YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
             ]
          ]
       ]
    " Angular distribution "
    " -------------------- "
    ELSEIF(CHOICE1=6)[
       GRAPHTITLE='angular distribution';
       IF(ANGTYPE=1)[
         YTITLE='particles/unit solid angle/incident particle';
       ]
       ELSE[
         YTITLE='particles/angular bin/incident particle';
       ]
       XTITLE='angle /degree';
       DO II=1,NSMFEE[
          $ANALYZE(II:FSMABN1(II):FSMABN2(II));
          XPLOT(II)=(SMFMXE-SMFMNE)*FLOAT(II)/FLOAT(NSMFEE)+SMFMNE;
          IF(ANGTYPE=1)["get particles/unit solid angle"
             "below is 2*pi*sin(theta)*dtheta, where theta is the"
             "angle in the middle of the bin (radians) and dtheta is"
             "the bin width (radians)"
             IF(II=1)[
               DOMEGA=2*3.1415927*SIN((XPLOT(II)+SMFMNE)/2/57.29578)*
                    (XPLOT(II)-SMFMNE)/57.29578;
             ]
             ELSE[
               DOMEGA=2*3.1415927*SIN((XPLOT(II)+XPLOT(II-1))/2/57.29578)*
                    (XPLOT(II)-XPLOT(II-1))/57.29578;
             ]
          ]
          ELSE[DOMEGA=1.;]
          YPLOT(II)=FSMABN1(II)/DOMEGA;
          ERRYPLOT(II)=FSMABN2(II)/DOMEGA;
       ]
       HXMIN=SMFMNE;
       IF(ITYPE=0)["make sure we plot center points"
            DO II=NSMFEE,1,-1[
                 IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
                 ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
            ]
       ]
       CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NSMFEE,MSTART,
       SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);

       ]
    ELSEIF(CHOICE1=7)[
       GRAPHTITLE='distribution of ZLAST';
       YTITLE='particles/bin(equal)/incident particle';
       XTITLE='Z /cm ';
       DO II=1,NSMFEE[
          $ANALYZE(II:FSMABN1(II):FSMABN2(II));
          XPLOT(II)=(SMFMXE-SMFMNE)*FLOAT(II)/FLOAT(NSMFEE)+SMFMNE;
          YPLOT(II)=FSMABN1(II);
          ERRYPLOT(II)=FSMABN2(II);
       ]
       HXMIN=SMFMNE;
       IF(ITYPE=0)["make sure we plot center points"
            DO II=NSMFEE,1,-1[
                 IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
                 ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
            ]
       ]
       CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NSMFEE,MSTART,
       SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);

       ]
    ELSEIF(CHOICE1=8)[
       GRAPHTITLE='weight distribution';
       YTITLE='particles/bin(equal width)/incident particle';
       XTITLE='weight';
       DO II=1,NSMFEE[
         $ANALYZE(II:FSMFBN1(1,1,II):FSMFBN1(2,1,II));
         XPLOT(II)=EXP((LOG(SMFMXE)-LOG(SMFMNE))*FLOAT(II)/FLOAT(NSMFEE)+
                     LOG(SMFMNE));
         YPLOT(II)=FSMFBN1(1,1,II);
         ERRYPLOT(II)=FSMFBN1(2,1,II);
       ]
       HXMIN=SMFMNE;
       IF(ITYPE=0)["make sure we plot center points"
            DO II=NSMFEE,1,-1[
                 IF(II=1)[ XPLOT(II)=(HXMIN+XPLOT(II))/2.; ]
                 ELSE[ XPLOT(II)=(XPLOT(II-1)+XPLOT(II))/2.; ]
            ]
       ]
       CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NSMFEE,MSTART,
       SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,2);
       ]
    ELSEIF(CHOICE1=9)[WRITE(3,'(''&'')');]
           "just write the ampersand at the end of the data"

    "FINISHED OPTIONS 1 - 9"
    IF(CHOICE1=1)[
       OUTPUT ;
       (/' Create another set of fluence vs position data using the same'/
         ' ph-sp file?');
       ]
    IF(CHOICE1=2)[
       OUTPUT ;
       (/' Create another set of energy fluence vs position data using the'/
         ' same ph-sp file?');
       ]
    ELSEIF(CHOICE1=3)[
       OUTPUT ;
       (/' Create another set of spectral data using the same ph-sp file?');
       ]
    IF(CHOICE1=4)[
       OUTPUT ;
     (/' Create another set of energy fluence data using the same ph-sp file?');
       ]
    ELSEIF(CHOICE1=5)[
       OUTPUT ;
       (/' Create another set of mean energy data using the same ph-sp file?');
       ]
    ELSEIF(CHOICE1=6)[
       OUTPUT ;
       (/' Create another set of angular data using the same ph-sp file?');
       ]
    ELSEIF(CHOICE1=7)[
       OUTPUT ;
       (/' Create another set of zlast data using the same ph-sp file?');
       ]
    ELSEIF(CHOICE1=8)[
       OUTPUT ;
       (/' Create another set of weight data using the same ph-sp file?');
       ]
    ELSEIF(CHOICE1=9)[
       OUTPUT ;
       (/' Create another set of x-y scatter data using the same ph-sp file?');
       ]
    OUTPUT ;
    (' (1: yes, 0: no - quit)'/' ',$);
    INPUT II; (I8);
    OUTPUT II; (I8);
    IF(II = 1)[
       MSTART=MSTART+1;
       OUTPUT;(' Using same ph-sp file');
       GOTO :START-INPUTS-FOR-AN-OPTION:;
       ]
    ELSE[
       OUTPUT ;
       (/' Plot the data just created using xmgrace before quiting?');
       OUTPUT ;
       (' (1: yes, 0: no - quit)'/' ',$);
       INPUT II; (I8);
       IF(II = 1)[
          OUTPUT;('Plot the data');
          CALL XVGR_SCRIPT;
          ]
       GOTO :STOP-FOR-GOOD1:;
       ]
    ] " end of choice1=1-8 case "

" Combine two ph-sp files into one "
" -------------------------------- "
IF(CHOICE1 = 10)
   CALL ADD_FILES;

:STOP-FOR-GOOD1:;

OUTPUT;(/' BYE!'///
         ' If running gui, this window will close before next run!'/);

STOP;
END;

%L
!LABELS 5000;
%Q1
%C80
%I4
%E
%B132
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
"*******************************************************************************
SUBROUTINE XVGR_SCRIPT;
"
" THIS IS A SUBROUTINE USED BY BEAMDP TO GENERATE A SCRIPT AND RUN xmgrace.
"
" PROGRAMMER C-M MA
"
"*******************************************************************************

"**VARIABLES**"

"---Force declarations of all variables---"
IMPLICIT NONE;

COMIN/CHARACTERS;

"CREATING A SCRIPT FILE FOR xmgrace"
OPEN(4,FILE='xmgrace_script',FORM='FORMATTED',STATUS='UNKNOWN');
SCRIPT(3)(1:22)='xmgrace -autoscale xy ';
SCRIPT(3)(23:100)= SPCNAM;
SCRIPT(1)='#!/bin/sh';
SCRIPT(2)='#xmgrace_script';
SCRIPT(4)='exit';
WRITE (4,*)SCRIPT(1)(1:60);
WRITE (4,*)SCRIPT(2)(1:60);
WRITE (4,*)SCRIPT(3)(1:);
WRITE (4,*)SCRIPT(4)(1:60);
CLOSE(4);
CALL SYSTEM('chmod +x xmgrace_script');
"converts script file to executable mode"
CALL SYSTEM('xmgrace_script &')
;
"CALL SYSTEM('xmgr_script > /dev/null &');
"executes xmgr_script file"
"redirected output to null device, and runs xvgr in background"
RETURN;
END;

%L
!LABELS 5000;
%Q1
%C80
%I4
%E
%B132
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
"*******************************************************************************
SUBROUTINE READ_DATA;
"
" THIS IS A SUBROUTINE USED BY BEAMDP TO READ DATA FROM PHASE-SPACE FILES.
"
" PROGRAMMER C-M MA
"
"*******************************************************************************

"**VARIABLES**"

"---Force declarations of all variables---"
IMPLICIT NONE;


COMIN/CHARACTERS;
COMIN/DOUBLES;
COMIN/REALS;
COMIN/INTEGERS;
COMIN/LOGICALS;
COMIN/RWPHSP/;

integer lnblnk1;

    i_log=6;

    "initialize counters"
    DO III=1,$NB[
       XPLOT(III)=0.0;
       YPLOT(III)=0.0;
       ERRYPLOT(III)=0.0;
       JUSTONE(III)=0;
       NHSTRY_LAST(III)=0.;
       SUM_TMP(III)=0.;
       SUM_TMP2(III)=0.;
    ]
    DO III=1,$NBINANGLE[
       FSMABN1(III)=0.0;"ANGULAR DISTRIBUTION"
       FSMABN2(III)=0.0;"FSMABN1 SQUARED"
    ]
    DO III=1,$NS[
       DO IIII=1,$NB[
          FSMFRR(III,IIII)=0.0;
          FSMFXX(III,IIII)=0.0;
          FSMFYY(III,IIII)=0.0;
          DO IIIII=1,$NB[FSMFXY(III,IIII,IIIII)=0.0;]
       ]
       DO IIII=1,$NB[
          DO IIIII=1,$NB[
             FSMFBN1(III,IIIII,IIII)=0.0;
             ]
       ]
    ]

    "calculate constants for later use"
    IF((SMFMXE-SMFMNE) ~= 0.)[
       SFACTOR=FLOAT(NSMFEE)/(SMFMXE-SMFMNE);"energy"
       SSFACTOR=FLOAT(NSMFEE)/(SMFMXE-SMFMNE);
       "angle, ZLAST, note we use the same variables here for convenience"
    ]
    ELSE[SFACTOR=FLOAT(NSMFEE);SSFACTOR=FLOAT(NSMFEE);]
    IF(RFIELD ~= 0.)[RFACTOR=FLOAT(NFIELD)/(RFIELD**2);"ring field"]
    ELSE[RFACTOR=FLOAT(NFIELD);]
    IF((SMFMXY(1)-SMFMNY(1)) ~= 0.)[
       Y=FLOAT(NFIELD)/(SMFMXY(1)-SMFMNY(1));"rectangular field"
    ]
    IF((SMFMXX(1)-SMFMNX(1)) ~= 0.)[
       X=FLOAT(NFIELD)/(SMFMXX(1)-SMFMNX(1));
    ]
    ELSE[X=FLOAT(NFIELD);]
    XMIN2=SMFMNX(1)*SMFMNX(1);
    XMAX2=SMFMXX(1)*SMFMXX(1);

    "Read ph-sp particles"
    :LOOP-THROUGH-PH-SP-FILE:;
    IPARANOT=1; "START WITH THE FIRST PARTICLE IN FILE"
    NUMSCATTER=0;
    IIII=0;
    NHSTRY=0;"no. of primary histories"
    LOOP["read phase-space data from the data file"

       ;:start-of-file-read0:;

      IPARANOT=IPARANOT+1;"NOTE THE SECOND RECORD STORES THE FIRST PARTICLE"
      IF(IPARANOT = PARANOT+2)["end of file encountered"
        GOTO :end-of-file-read0:;
      ]

      IF(i_iaea_in=1)[
         $IAEA_READ_PHSP_RECORD(i_unit_in,NPASSI,NHSTRY,LATCHI,IQ,EI,
              WEIGHT,XIN,YIN,ZIN,UIN,VIN,WIN,ZLAST,MUIDX);
      ]
      ELSE[

      IZLAST1=0;
      IF(MODE_RW='MODE2')IZLAST1=1;

      $READ_PHSP(IZLAST1,2,IPARANOT:NHSTRY,NPASSI,IQ,WIN,ZLAST,LATCHI,
                 EI,WEIGHT,XIN,YIN,UIN,VIN);
      ]

      IF (NPASSI ~= 0) [
         NPASS_ph_sp = NPASS_ph_sp + 1;
       "  GOTO :start-of-file-read0:;  changed by cma"
         "Discard particles if they or their ancestors have crossed"
         "scoring plane"
         ]

      IF(IQ ~= 0)[ "We need kinetic energy only"
         EI=EI-0.5109989461;
         ]

      "processing the ph-sp data"
      "*************************"

      IF(IQSMFP(1) ~= 2)["check charge first"
          IF(IQSMFP(1) =3)[IF(IQ =0)[GOTO :start-of-file-read0:;]]
          ELSEIF(IQSMFP(1) ~= IQ)[GOTO :start-of-file-read0:;]
          ]"discard the particle if the charge is not right"
      IF(CHOICE1=11)[
          DO I=1,29[
             IF($BTEST(LATCHI,I-1))[LATCHJ(30-I)=1;"Bit I is set"]
             ELSE[LATCHJ(30-I)=0;"bit I is not set"]
             ]
          IIII=IIII+1;
          IF(IIII>=NUMBERST)[
          IF(MODE_RW='MODE0')[
             WRITE(6,:LIST-FORMAT1:)
             EI,IQ,XIN,YIN,UIN,VIN,WIN,WEIGHT,(LATCHJ(I),I=1,29);
             :LIST-FORMAT1:FORMAT(F7.3,I4,2F8.3,3F7.3,1PE10.3,
             2X,$LATCH_NUMBER_OF_BITSI1,1X,24I1);
             ]
          ELSEIF(MODE_RW='MODE2')[
             WRITE(6,:LIST-FORMAT11:)
             EI,IQ,XIN,YIN,UIN,VIN,WIN,ZLAST,WEIGHT,(LATCHJ(I),I=1,29);
             :LIST-FORMAT11:FORMAT(F7.3,I4,2F8.3,3F7.3,F8.3,1PE10.3,
             2X,$LATCH_NUMBER_OF_BITSI1,1X,24I1);
             ]
          ]
          IF(NUMBERP = IIII)RETURN;
          IF(IIII=1)[
             IF(MODE_RW='MODE0')[
                WRITE(6,:LIST-FORMAT02:);
                ]
             ELSEIF(MODE_RW='MODE2')[
                WRITE(6,:LIST-FORMAT03:);
                ]
             ]
          ]
       ELSEIF(CHOICE1=12)[
        /*
          DO I=1,3[
            IF(AC(I)(1:lnblnk1(AC(I)))='X') WRITE(3,'(F8.3,$)') XIN;
            IF(AC(I)(1:lnblnk1(AC(I)))='Y') WRITE(3,'(F8.3,$)') YIN;
            IF(AC(I)(1:lnblnk1(AC(I)))='Z') WRITE(3,'(F8.3,$)') ZIN;
            IF(AC(I)(1:lnblnk1(AC(I)))='MU') WRITE(3,'(F8.3,$)') MUIDX;
            IF(I<3) WRITE(3,'(A1,$)')',';
          ]
          WRITE(3,*);
         */
          IF(IMUIDX1=0 | (MUIDX>=mumin & MUIDX<=mumax))[
                 IIII=IIII+1;
                 WRITE(3,'(F8.3,'','',F8.3,'','',F8.3)')XIN,YIN,ZIN;
          ]
          IF(NUMBERP = IIII)RETURN;
       ]

      :LIST-FORMAT02: FORMAT(/' ENERGY  IQ     X',
      5X, '  Y',4X,'  U',4X,'  V',4X,'  W',4X,'WEIGHT',6X,
      ' LATCH (set=1, not set=0)'/);
      :LIST-FORMAT03: FORMAT(/' ENERGY  IQ     X',
      5X, '  Y',4X,'  U',4X,'  V',4X,'  W',4X,' ZLAST   WEIGHT',6X,
      ' LATCH (set=1, not set=0)'/);

"below is the bit filtering"
         IF(I_IN_EX = 0)[
            DO I=1,NBIT1[
               III=LATCH(I);"check whether bit I has been set"
               IF($BTEST(LATCHI,III))EXIT;
               "now check the bits to be excluded"
               IF(I=NBIT1)GOTO :start-of-file-read0:;
                    "discard the particle"
            ]
            DO I=1,NBIT2[
               III=LATCH(I+NBIT1);"check whether bit I has been set"
               IF($BTEST(LATCHI,III))GOTO :start-of-file-read0:;
               "discard the particle"
            ]
            GOTO :PARTICLE-WITH-CORRECT_LATCH:;
         ]
         ELSEIF(I_IN_EX = 1)[
            DO I=1,NBIT1[
               III=LATCH(I);"check whether bit I has been set"
               IF($BTEST(LATCHI,III))GOTO :start-of-file-read0:;
               "as long as a specified bit is set we discard the particle"
            ]
         ]
         ELSEIF(I_IN_EX = 2)[
            DO I=1,NBIT1[
               III=LATCH(I);"check whether bit I has been set"
               IF(IBITS(LATCHI,24,5)=III)GOTO :PARTICLE-WITH-CORRECT_LATCH:;
               "now check the bits to be excluded"
            ]
            GOTO :start-of-file-read0:;
         ]
         ELSEIF(I_IN_EX = 3)[
            DO I=1,NBIT1[
               III=LATCH(I);"check whether particle originated in region I"
               IF(IBITS(LATCHI,24,5)=III)GOTO :start-of-file-read0:;
               "as long as particle originated in specified region, chuck it"
            ]
         ]

      :PARTICLE-WITH-CORRECT_LATCH:;

      X2Y2=XIN*XIN+YIN*YIN;

      " Fluence "
      IF(CHOICE1 = 1)[
          IF(FLUTYPE~=1)["use estimate of real fluence"
                   WEIGHT=WEIGHT/MAX(0.08716,ABS(WIN));
          ]
          IF(MSMFXY=0)["circular field"
             IR=INT(X2Y2*RFACTOR)+1;
             IF(IR > NFIELD)[
                "discard this particle, outside the given field"
                GOTO :start-of-file-read0:;
                ]
             $SCORE(IR:FSMFRR(1,IR):FSMFRR(2,IR):WEIGHT);
          ]
          ELSEIF(MSMFXY=1)["a square field with square rings"
             IX=INT(XIN*XIN*RFACTOR)+1;
             IY=INT(YIN*YIN*RFACTOR)+1;
             IF((IX > NFIELD) |  (IY > NFIELD))[
                "discard this particle, outside the given field"
                GOTO :start-of-file-read0:;
                ]
             IF(IX <= IY)["find index"
                $SCORE(IY:FSMFRR(1,IY):FSMFRR(2,IY):WEIGHT);
             ]
             ELSE[
                $SCORE(IX:FSMFRR(1,IX):FSMFRR(2,IX):WEIGHT);
             ]
          ]
          ELSEIF(MSMFXY=2)["rectangular field"
             IF(ISMFPS(1)=0)["score planar fluence along x-axis"
                 IX=INT((XIN-SMFMNX(1))*X)+1;
                 IF(IX>NFIELD)|(IX<1)|((XIN-SMFMNX(1))<0. |
                    YIN>=SMFMXY(1) | YIN<=SMFMNY(1))[
                     "discard this particle"
                     GOTO :start-of-file-read0:;
                     ]
                 $SCORE(IX:FSMFXX(1,IX):FSMFXX(2,IX):WEIGHT);
             ]
             ELSE["along y-axis"
                 IY=INT((YIN-SMFMNY(1))*Y)+1;
                 IF(IY>NFIELD)|(IY<1)|((YIN-SMFMNY(1))<0. |
                    XIN>=SMFMXX(1) | XIN<=SMFMNX(1))[
                     "discard this particle"
                     GOTO :start-of-file-read0:;
                     ]
                 $SCORE(IY:FSMFYY(1,IY):FSMFYY(2,IY):WEIGHT);
             ]
          ]
      ]

      " Energy fluence vs position "
      IF(CHOICE1 = 2)[
          IF(FLUTYPE~=1)["use estimate of real fluence"
                   WEIGHT=WEIGHT/MAX(0.08716,ABS(WIN));
          ]
          IF(MSMFXY=0)["circular field"
             IR=INT(X2Y2*RFACTOR)+1;
             IF(IR > NFIELD)[
                "discard this particle, outside the given field"
                GOTO :start-of-file-read0:;
                ]
             $SCORE(IR:FSMFRR(1,IR):FSMFRR(2,IR):WEIGHT*EI);
             ]
          ELSEIF(MSMFXY=1)["a square field with square rings"
             IX=INT(XIN*XIN*RFACTOR)+1;
             IY=INT(YIN*YIN*RFACTOR)+1;
             IF((IX > NFIELD) |  (IY > NFIELD))[
                "discard this particle, outside the given field"
                GOTO :start-of-file-read0:;
                ]
             IF(IX <= IY)["find index"
                $SCORE(IY:FSMFRR(1,IY):FSMFRR(2,IY):WEIGHT*EI);
                ]
             ELSE[
                $SCORE(IX:FSMFRR(1,IX):FSMFRR(2,IX):WEIGHT*EI);
                ]
             ]
          ELSEIF(MSMFXY=2)["rectangular field"
             IF(ISMFPS(1)=0)["score planar fluence along x-axis"
                 IX=INT((XIN-SMFMNX(1))*X)+1;
                 IF(IX>NFIELD)|(IX<1)|((XIN-SMFMNX(1))<0. |
                    YIN>=SMFMXY(1) | YIN<=SMFMNY(1))[
                     "discard this particle"
                     GOTO :start-of-file-read0:;
                     ]
                 $SCORE(IX:FSMFXX(1,IX):FSMFXX(2,IX):WEIGHT*EI);
                 ]
             ELSE["along y-axis"
                 IY=INT((YIN-SMFMNY(1))*Y)+1;
                 IF(IY>NFIELD)|(IY<1)|((YIN-SMFMNY(1))<0. |
                    XIN>=SMFMXX(1) | XIN<=SMFMNX(1))[
                     "discard this particle"
                     GOTO :start-of-file-read0:;
                     ]
                 $SCORE(IY:FSMFYY(1,IY):FSMFYY(2,IY):WEIGHT*EI);
                 ]
             ]
          ]

      " Spectrum "
      ELSEIF(CHOICE1 = 3)[
          IF(FLUTYPE~=1)["use estimate of real fluence"
                   WEIGHT=WEIGHT/MAX(0.08716,ABS(WIN));
          ]
          IF(MSMFXY=0)["ANNULAR"
             IF(X2Y2>=XMIN2)&(X2Y2<XMAX2)[
                IF(EI<SMFMNE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                IE=INT((EI-SMFMNE)*SFACTOR)+1;
                IF(IE > NSMFEE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                $SCORE(IE:FSMFBN1(1,1,IE):FSMFBN1(2,1,IE):WEIGHT);
                ]
             ]
          ELSEIF(MSMFXY=1)["RECTANGULAR"
             IF(YIN>SMFMNY(1))&(YIN<SMFMXY(1))&(XIN>SMFMNX(1))
             &(XIN<SMFMXX(1))["inside the given field"
                IF(EI<SMFMNE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                IE=INT((EI-SMFMNE)*SFACTOR)+1;
                IF(IE > NSMFEE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                $SCORE(IE:FSMFBN1(1,1,IE):FSMFBN1(2,1,IE):WEIGHT);
                ]
             ]
          ]

      " Energy fluence distribution "
      ELSEIF(CHOICE1 = 4)[
          IF(FLUTYPE~=1)["use estimate of real fluence"
                   WEIGHT=WEIGHT/MAX(0.08716,ABS(WIN));
          ]
          IF(MSMFXY=0)["ANNULAR"
             IF(X2Y2>=XMIN2)&(X2Y2<XMAX2)[
                IF(EI<SMFMNE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                IE=INT((EI-SMFMNE)*SFACTOR)+1;
                IF(IE > NSMFEE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                $SCORE(IE:FSMFBN1(1,1,IE):FSMFBN1(2,1,IE):WEIGHT*EI);
                ]
             ]
          ELSEIF(MSMFXY=1)["RECTANGULAR"
             IF(YIN>SMFMNY(1))&(YIN<SMFMXY(1))&(XIN>SMFMNX(1))
             &(XIN<SMFMXX(1))["inside the given field"
                IF(EI<SMFMNE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                IE=INT((EI-SMFMNE)*SFACTOR)+1;
                IF(IE > NSMFEE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                $SCORE(IE:FSMFBN1(1,1,IE):FSMFBN1(2,1,IE):WEIGHT*EI);
                ]
             ]
          ]

      " Mean energy "
      ELSEIF(CHOICE1 = 5)[
         WEIGHT=WEIGHT/MAX(0.08716,ABS(WIN));
         IF(MSMFXY=0)["circular field"
             IR=INT(X2Y2*RFACTOR)+1;
             IF(IR > NFIELD)[
                "discard this particle, outside the given field"
                GOTO :start-of-file-read0:;
                ]
             JUSTONE(IR)=JUSTONE(IR)+1;
             $SCORE_COV(IR:FSMFBN1(1,1,IR):FSMFBN1(2,1,IR):FSMFBN1(1,2,IR):
                        FSMFBN1(2,2,IR):FSMFBN1(3,1,IR):WEIGHT*EI:WEIGHT);
             ]
          ELSEIF(MSMFXY=1)["a square field with square rings"
             IX=INT(XIN*XIN*RFACTOR)+1;
             IY=INT(YIN*YIN*RFACTOR)+1;
             IF((IX > NFIELD) |  (IY > NFIELD))[
                "discard this particle, outside the given field"
                GOTO :start-of-file-read0:;
                ]
             IF(IX <= IY)["find index"
                JUSTONE(IY)=JUSTONE(IY)+1;
                $SCORE_COV(IY:FSMFBN1(1,1,IY):FSMFBN1(2,1,IY):FSMFBN1(1,2,IY):
                        FSMFBN1(2,2,IY):FSMFBN1(3,1,IY):WEIGHT*EI:WEIGHT);
                ]
             ELSE[
                JUSTONE(IX)=JUSTONE(IX)+1;
                $SCORE_COV(IX:FSMFBN1(1,1,IX):FSMFBN1(2,1,IX):FSMFBN1(1,2,IX):
                        FSMFBN1(2,2,IX):FSMFBN1(3,1,IX):WEIGHT*EI:WEIGHT);
                ]
             ]
          ELSEIF(MSMFXY=2)["rectangular field"
             IF(ISMFPS(1)=0)["score planar fluence along x-axis"
                 IX=INT((XIN-SMFMNX(1))*X)+1;
                 IF(IX>NFIELD)|(IX<1)|((XIN-SMFMNX(1))<0. |
                    YIN>=SMFMXY(1) | YIN<=SMFMNY(1))[
                     "discard this particle"
                     GOTO :start-of-file-read0:;
                     ]
                 JUSTONE(IX)=JUSTONE(IX)+1;
                 $SCORE_COV(IX:FSMFBN1(1,1,IX):FSMFBN1(2,1,IX):FSMFBN1(1,2,IX):
                        FSMFBN1(2,2,IX):FSMFBN1(3,1,IX):WEIGHT*EI:WEIGHT);
                 ]
             ELSE["along y-axis"
                 IY=INT((YIN-SMFMNY(1))*Y)+1;
                 IF(IY>NFIELD)|(IY<1)|((YIN-SMFMNY(1))<0. |
                    XIN>=SMFMXX(1) | XIN<=SMFMNX(1))[
                     "discard this particle"
                     GOTO :start-of-file-read0:;
                     ]
                 JUSTONE(IY)=JUSTONE(IY)+1;
                 $SCORE_COV(IY:FSMFBN1(1,1,IY):FSMFBN1(2,1,IY):FSMFBN1(1,2,IY):
                        FSMFBN1(2,2,IY):FSMFBN1(3,1,IY):WEIGHT*EI:WEIGHT);
                 ]
             ]
          ]

      " Angular distribution "
      ELSEIF(CHOICE1 = 6)[
          "reject the particle based on energy here, because EI stands"
          "in for angle later"
          IF(EI<SMFMNZ(1))[
              GOTO :start-of-file-read0:;"discard the particle"
          ]
          IF(EI>SMFMXZ(1))[
              GOTO :start-of-file-read0:;"discard the particle"
          ]
          IF(MSMFXY=0)["ANNULAR"
             IF(X2Y2>=XMIN2)&(X2Y2<XMAX2)[
                EI=ACOS(WIN)*57.29578; "=180./3.14159"
                IF(EI<SMFMNE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                IA=INT((EI-SMFMNE)*SSFACTOR)+1;
                IF(IA>NSMFEE)|(IA<1)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                $SCORE(IA:FSMABN1(IA):FSMABN2(IA):WEIGHT);
                ]
             ]
          ELSEIF(MSMFXY=1)["RECTANGULAR"
             IF(YIN>SMFMNY(1))&(YIN<SMFMXY(1))&(XIN>SMFMNX(1))
                &(XIN<SMFMXX(1))["inside the given field"
                EI=ACOS(WIN)*57.29578; "=180./3.14159"
                IF(EI<SMFMNE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                IA=INT((EI-SMFMNE)*SSFACTOR)+1;
                IF(IA > NSMFEE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                $SCORE(IA:FSMABN1(IA):FSMABN2(IA):WEIGHT);
                ]
             ]
          ]

      " ZLAST distribution "
      ELSEIF(CHOICE1 = 7)[
          IF(MSMFXY=0)["ANNULAR"
             IF(X2Y2>=XMIN2)&(X2Y2<XMAX2)[
                IF(ZLAST<SMFMNE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                IA=INT((ZLAST-SMFMNE)*SSFACTOR)+1;
                IF(IA > NSMFEE)|(IA < 1)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                $SCORE(IA:FSMABN1(IA):FSMABN2(IA):WEIGHT);
                ]
             ]
          ELSEIF(MSMFXY=1)["RECTANGULAR"
             IF(YIN>SMFMNY(1))&(YIN<SMFMXY(1))&(XIN>SMFMNX(1))
                &(XIN<SMFMXX(1))["inside the given field"
                IF(ZLAST<SMFMNE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                IA=INT((ZLAST-SMFMNE)*SSFACTOR)+1;
                IF(IA > NSMFEE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                $SCORE(IA:FSMABN1(IA):FSMABN2(IA):WEIGHT);
                ]
             ]
          ]

      " Weight distribution "
      ELSEIF(CHOICE1 = 8)[
          IF(SMFMXE~=SMFMNE)[
              SFACTOR=FLOAT(NSMFEE)/(LOG(SMFMXE)-LOG(SMFMNE));
          ]
          IF(MSMFXY=0)["ANNULAR"
             IF(X2Y2>=XMIN2)&(X2Y2<XMAX2)[
                IF(WEIGHT<SMFMNE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                IE=INT((LOG(WEIGHT)-LOG(SMFMNE))*SFACTOR)+1;
                IF(IE > NSMFEE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                $SCORE(IE:FSMFBN1(1,1,IE):FSMFBN1(2,1,IE):1);
                ]
             ]
          ELSEIF(MSMFXY=1)["RECTANGULAR"
             IF(YIN>SMFMNY(1))&(YIN<SMFMXY(1))&(XIN>SMFMNX(1))
             &(XIN<SMFMXX(1))["inside the given field"
                IF(WEIGHT<SMFMNE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                IE=INT((LOG(WEIGHT)-LOG(SMFMNE))*SFACTOR)+1;
                IF(IE > NSMFEE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                $SCORE(IE:FSMFBN1(1,1,IE):FSMFBN1(2,1,IE):1);
                ]
             ]
          ]

     " X-Y scatter plot "
      ELSEIF(CHOICE1 = 9)[
          IF(MSMFXY=0)["ANNULAR"
             IF(X2Y2>=XMIN2)&(X2Y2<XMAX2)[
                IF(EI<SMFMNE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                IF(EI > SMFMXE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                WRITE(3,'(1PE15.4,1PE15.4)')XIN,YIN;
                NUMSCATTER=NUMSCATTER+1;
                ]
             ]
          ELSEIF(MSMFXY=1)["RECTANGULAR"
             IF(YIN>SMFMNY(1))&(YIN<SMFMXY(1))&(XIN>SMFMNX(1))
             &(XIN<SMFMXX(1))["inside the given field"
                IF(EI<SMFMNE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                IF(EI > SMFMXE)[
                   GOTO :start-of-file-read0:;"discard the particle"
                   ]
                WRITE(3,'(1PE15.4,1PE15.4)')XIN,YIN;
                NUMSCATTER=NUMSCATTER+1;
                ]
             ]
             IF(NUMSCATTER=MAXSCATTER) GOTO :end-of-file-read0:;
          ]
      ]"end of reading ph-sp data loop"

    :end-of-file-read0:;
RETURN;
END;

%L
!LABELS 3000;
%Q1
%C80
%I4
%E
%B132
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
"*******************************************************************************
SUBROUTINE ADD_FILES;
"
" THIS IS A SUBROUTINE USED BY BEAMDP TO COMBINE TWO PHASE-SPACE FILES
" INTO ONE.
"
" PROGRAMMER C-M MA
"
"*******************************************************************************

"**VARIABLES**"

"---Force declarations of all variables---"
IMPLICIT NONE;

COMIN/CHARACTERS;
COMIN/DOUBLES;
COMIN/REALS;
COMIN/INTEGERS;
COMIN/LOGICALS;
COMIN/RWPHSP/;

$INTEGER len, lnblnk1, itmp;

$INITIALIZE_PHSP_VARIABLES;

i_log=6;

:TRY-AGAIN-1:;
IF ~EGSPERT[ CALL HELP_MESSAGE(22); ]
:RR2:
OUTPUT ; (/' Name of the old ph-sp file 1: '/);
    INPUT OLDNAM ; (A80);
    IF(OLDNAM=' ')|(OLDNAM='?')[GOTO :RR1:;]
    GOTO :RR3:;
    :RR1:
      CALL HELP_MESSAGE(22);
      GOTO :RR2:;
    :RR3:
    i_iaea_in=0; "assume not in IAEA format"
    len=lnblnk1(OLDNAM);
    IF(OLDNAM(len-8:len)='.IAEAphsp')[
         i_iaea_in=1;
         OLDNAM=OLDNAM(:len-9);
         OUTPUT;(/' Data is in IAEA format.'/);
    ]

    ;/PARANOT1,PARANOP1/=0;/PARAEMAX1,PARAEMNE1,PARANINC1/=0.;
    MODE_RW1=' ';IZLAST1=0; IMUIDX1=0; IZSCORE1=0;

    IF(i_iaea_in=1)[
       i_unit_in=2;
       $IAEA_OPEN_PHSP_FOR_READ(i_unit_in,OLDNAM);
       $IAEA_READ_PHSP_HEADER(i_unit_in,PARANOT1,PARANOP1,PARAEMAX1,LPARANINC1,
                  Z_SCORE,IZLAST1,IMUIDX1,IZSCORE1);
       OUTPUT PARANOT1,PARANOP1,PARAEMAX1,LPARANINC1;
(/'            Total number of particles in file:',I13/
  '                      Total number of photons:',I13/
  '             The rest are electrons/positrons.'/
  ' '/
  '      Maximum kinetic energy of the particles:',F13.3,' MeV'/
  ' # of incident particles from original source:',I13);
       IF(IZSCORE1=0)[
         OUTPUT Z_SCORE;
('                     Z where phsp file scored:',F13.3,' cm');
       ]
       IF(IZLAST1~=0)[
          OUTPUT;
( ' ZLAST scored in this file.');
       ]
       IF(IMUIDX1~=0)[
          OUTPUT;
( ' Fractional MU index scored in this file.');
       ]
    ]

    ELSE[


    itmp=-1;
    $OPEN_PHSP_FOR_READ(itmp,2,OLDNAM,MODE_RW1,PARANOT1,
                       PARANOP1,PARAEMAX1,PARAEMNE1,PARANINC1);
    IF(IERR_PHSP~=0) GOTO :RRR1:;

    OUTPUT PARANOT1,PARANOP1,PARAEMAX1,PARAEMNE1;
      (/'            Total number of particles in file:',I13/
        '                      Total number of photons:',I13/
        '             The rest are electrons/positrons.'/
        ' '/
        '      Maximum kinetic energy of the particles:',F13.3,' MeV'/
        '      Minimum kinetic energy of the electrons:',F13.3,' MeV');
    PARANOT=PARANOT1; "store total for later"
    IF(PARANINC1 < 2.)["an old file which stored min. phot. energy"
       OUTPUT PARANINC1;
       ('        Minimum kinetic energy of the photons:',F13.3,' MeV');
    ]
    ELSE[
       OUTPUT PARANINC1;
       (' # of incident particles from original source:',F13.1);
    ]
    ]

    :TRY-AGAIN-2:;

    OUTPUT ; (/' Name of the old ph-sp file 2: '/' ',$);
    INPUT SPCNAM ; (A80);

    IF(SPCNAM = ' ')[GOTO :TRY-AGAIN-2:;]

    i_iaea_out=0; "assume not in IAEA format"
    len=lnblnk1(SPCNAM);
    IF(SPCNAM(len-8:len)='.IAEAphsp')[
         i_iaea_out=1;
         SPCNAM=SPCNAM(:len-9);
         OUTPUT;(/' Data is in IAEA format.'/);
    ]

    IF(i_iaea_in~=i_iaea_out)[
       OUTPUT;(//' *****ERROR*****'/
                 ' Both phase space files must have the same format'/
                 ' (IAEA or standard BEAMnrc).  Try again.'//);
       STOP;
    ]


    /PARANOT2,PARANOP2,LPARANINC2/=0;/PARAEMAX2,PARAEMNE2,PARANINC2/=0.;
    MODE_RW2=' ';IZLAST2=0;IMUIDX2=0; IZSCORE2=0;

    IF(i_iaea_out=1)[
       i_unit_out=3;
       $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,SPCNAM,IZLAST2,1,Z_SCORE,IMUIDX2,
                                 IZSCORE2);
       $IAEA_READ_PHSP_HEADER(i_unit_out,PARANOT2,PARANOP2,PARAEMAX2,LPARANINC2,
                              Z_SCORE,IZLAST2,IMUIDX2,IZSCORE2);
       OUTPUT PARANOT2,PARANOP2,PARAEMAX2,LPARANINC2;
(/'            Total number of particles in file:',I13/
  '                      Total number of photons:',I13/
  '             The rest are electrons/positrons.'/
  ' '/
  '      Maximum kinetic energy of the particles:',F13.3,' MeV'/
  ' # of incident particles from original source:',I13);
       IF(IZSCORE2=1)[
         OUTPUT Z_SCORE;
('                     Z where phsp file scored:',F13.3,' cm');
       ]
       IF(IZLAST2~=0)[
         OUTPUT;(' ZLAST scored in phase space data.');
       ]
       IF(IMUIDX2~=0)[
         OUTPUT;(' Fractional MU index scored in phase space data.');
       ]
    ]

    ELSE[

    itmp=-1;
    $OPEN_PHSP_FOR_READ(itmp,3,SPCNAM,MODE_RW2,
                        PARANOT2,PARANOP2,PARAEMAX2,PARAEMNE2,PARANINC2);
    IF(IERR_PHSP~=0) GOTO :RRR2:;

    OUTPUT PARANOT2,PARANOP2,PARAEMAX2,PARAEMNE2;
      (/'            Total number of particles in file:',I13/
        '                       Total number of photons:',I13/
        '             The rest are electrons/positrons.'/
        ' '/
        '      Maximum kinetic energy of the particles:',F13.3,' MeV'/
        '      Minimum kinetic energy of the electrons:',F13.3,' MeV');

    IF(PARANINC2 < 2.)["an old file which stored min. phot. energy"
       OUTPUT PARANINC2;
       ('        Minimum kinetic energy of the photons:',F13.3,' MeV');
    ]
    ELSE[
       OUTPUT PARANINC2;
       (' # of incident particles from original source:',F13.1);
    ]
    ]
    IF(i_iaea_in~=i_iaea_out)[
       OUTPUT;(//' *****ERROR*****'/
                 ' Both phase space files must have the same format'/
                 ' (IAEA or standard BEAMnrc).  Try again.'//);
       IF(i_iaea_in=1)[
          $IAEA_DESTROY_PHSP_FILE(i_unit_in);
       ]
       ELSE[ CLOSE(2);]
       IF(i_iaea_out=1)[
          $IAEA_DESTROY_PHSP_FILE(i_unit_out);
       ]
       ELSE[ CLOSE(3);]
       RETURN;
    ]
    ELSEIF((i_iaea_in=0 & MODE_RW2 ~= MODE_RW1) |
           (i_iaea_in=1 & IZLAST1 ~= IZLAST2))["FILES OF DIFFERENT MODES"
        OUTPUT;
        (/' SORRY, CANNOT COMBINE FILES OF DIFFERENT MODES!!! '/);
        OUTPUT;
        (/' PLEASE CONVERT FILES INTO EITHER MODE0 OR 2, THEN TRY AGAIN.'/);
        IF(i_iaea_in=1)[
           $IAEA_DESTROY_PHSP_FILE(i_unit_in);
           $IAEA_DESTROY_PHSP_FILE(i_unit_out);
        ]
        ELSE[
         CLOSE(2);
         CLOSE(3);
        ]
        RETURN;
    ]
    ELSEIF(i_iaea_in=1 & IZSCORE1 ~= IZSCORE2)[
       OUTPUT;
        (/' Error: One IAEA phase space file scores particle Z, while the'/
          ' other does not.  Cannot combine.'/);
        $IAEA_DESTROY_PHSP_FILE(i_unit_in);
        $IAEA_DESTROY_PHSP_FILE(i_unit_out);
        RETURN;
    ]
    ELSEIF(i_iaea_in=1 & IMUIDX1 ~= IMUIDX2)[
       OUTPUT;
        (/' Warning: One IAEA phase space file scores fractional MU index,'/
          ' while the other does not.  Combined file will lose this '/
          ' information.'/);
    ]

    OUTPUT;(/' The contents of file 1 will be appended to file 2.'/);

    OUTPUT;(/' BEGIN READING/WRITING PH-SP DATA .....'/);

    IPARANOT2=PARANOT2+1;

    IF(i_iaea_in=0 & MODE_RW1='MODE2') IZLAST1=1;

    "check that summed files will not go over 2.147483648 GByte limit"
    /* we do not need these warnings anymore
    IF(i_iaea_in=1)[
    IF(IZLAST1=1 & PARANOT1+PARANOT2>58027027)[
       OUTPUT; (//' ***WARNING***'/
                   ' Combined file will go over 2.147 GByte limit.'//);
    ]
    ELSEIF(PARANOT1+PARANOT2>65060606)[
       "note that this check only works if ZLAST not stored in the file"
       OUTPUT; (//' ***WARNING***'/
                  ' Combined file will go over 2.147 GByte limit.'//);
    ]
    ]
    ELSE[
    IF(IZLAST1=1 & PARANOT1+PARANOT2>67108863)[
       OUTPUT; (//' ***WARNING***'/
                  ' Combined file will go over 2.147 GByte limit.'//);
    ]
    ELSEIF(PARANOT1+PARANOT2>76695843)[
       OUTPUT; (//' ***WARNING***'/
                           ' Combined file will go over 2.147 GByte limit.'//);
    ]
    ]
    */

    NHSTRY=0;"no. of primary histories--ensures -E markers are preserved"

    IF(i_iaea_in=1)[
        DO IPARANOT1=1,PARANOT1["read phase-space data from the data file 1"
           $IAEA_READ_PHSP_RECORD(i_unit_in,NPASSI,NHSTRY,LATCHI,IQ,EREAD,
              WEIGHT,XIN,YIN,ZIN,UIN,VIN,WIN,ZLAST,MUIDX);
           $IAEA_WRITE_PHSP_RECORD(i_unit_out,NPASSI,1,NHSTRY,LATCHI,IQ,EREAD,
              WEIGHT,XIN,YIN,ZIN,UIN,VIN,WIN,ZLAST,MUIDX);
        ]
        $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(i_unit_out,LPARANINC1+LPARANINC2);
        $IAEA_DESTROY_PHSP_FILE(i_unit_in);
        $IAEA_DESTROY_PHSP_FILE(i_unit_out);
    ]
    ELSE["standard BEAMnrc format"

    PARANOP1=0; "only count photons as read in case we are not adding a full"
                "file"
    DO IPARANOT1=2,PARANOT1+1["read phase-space data from the data file 1"
      "NOTE THE SECOND RECORD STORES THE FIRST PARTICLE"
      $READ_PHSP_RECORD(IZLAST1,2,IPARANOT1:NHSTRY,ZLAST,LATCHI,EREAD,
                         WEIGHT,XIN,YIN,UIN,VIN);
      IPARANOT2=IPARANOT2+1;
      PARANOP1=PARANOP1+1-IBITS(LATCHI,29,1)-IBITS(LATCHI,30,1);
            "bit 29 is set if electron, bit 30 if positron"
      $WRITE_PHSP_RECORD(IZLAST1,3,SPCNAM,IPARANOT2,1:NHSTRY,ZLAST,LATCHI,EREAD,
                          WEIGHT,XIN,YIN,UIN,VIN);
          "write to file2"
    ]
    :end-of-file1-read:;
    $PHSP_BUFFER_FLUSH(IZLAST1,3,SPCNAM,IPARANOT2,1);
    "Re-write the first line of file 2"
     PARANOT2 = PARANOT2 + PARANOT1;
     PARANOP2 = PARANOP2 + PARANOP1;
     IF(PARANOT1>0 & PARAEMAX2 < PARAEMAX1)[PARAEMAX2=PARAEMAX1;]
     IF(PARANOT1>0 & PARAEMNE2 > PARAEMNE1)[PARAEMNE2=PARAEMNE1;]
     "COMPUTE NINC"
     NINC = (PARANOT1/PARANOT)*PARANINC1 + PARANINC2;
     IF((PARANINC1 < 2.)|(PARANINC2 < 2.))[
         OUTPUT;(/' FILE 1 AND/OR 2 IS AN OLDER FILE WHICH STORED',/
          ' MIN. PHOTON ENERGY INSTEAD OF # OF INCIDENT PARTICLES',/
          ' NUMBER OF INCIDENT PARTICLES SET TO 1 IN COMBINED FILE');
         NINC = 1;
     ]
    $WRITE_PHSP_HEADER(IZLAST1,3,SPCNAM,MODE_RW2,PARANOT2,PARANOP2,
                       PARAEMAX2,PARAEMNE2,NINC);
    CLOSE(UNIT=2);
    CLOSE(UNIT=3);
    ]"end of standard BEAMnrc format"
    OUTPUT;(/' Finished reading/writing ph-sp data .....'/);

RETURN;
:RRR2:;
OUTPUT;(//' CANNOT FIND/OPEN THE PH-SP FILE!!!'///);
"ask the user whether a different ph-sp file to be used"
CALL HELP_MESSAGE(22);
GOTO :TRY-AGAIN-2:;
:RRR1: OUTPUT;(//' CANNOT FIND/OPEN THE PH-SP FILE!!!'///);
"ask the user whether a different ph-sp file to be used"
GOTO :RR1:;"OPEN FILE AGAIN"

END;

%L
!LABELS 20000;
%Q1
%C80
%I4
%E
%B132
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
"*******************************************************************************
SUBROUTINE BEAMDP1;
"
" THIS IS A SUBROUTINE USED BY BEAMDP TO PROCESS BEAM DATA AND TO GENERATE
" AN INPUT FILE FOR MULTIPLE SOURCE MODEL BEAM RE-CONSTRUCTION.
"
" PROGRAMMER C-M MA
"
"*******************************************************************************

"**VARIABLES**"

"---Force declarations of all variables---"
IMPLICIT NONE;

REAL TENERGY,TPARTICLE,TEEE;
REAL*8 TPPP;

LOGICAL RMINUNDEFINED;

COMIN/CHARACTERS;
COMIN/DOUBLES;
COMIN/REALS;
COMIN/INTEGERS;
COMIN/LOGICALS;
ASSIGN-LETTERS;

:START-CHOICE1-0:;

IF(CHOICE1 = 0)[

OUTPUT;(/' INPUT A NUMBER TO CHOOSE AN OPTION: '/);
OUTPUT;(' (0) - Input new sub-source specifiers & analyze ph-sp data');
OUTPUT;(' (1) - Change sub-source specifiers in an existing source model');
OUTPUT;(' (2) - Analyze ph-sp data using sub-source specifiers from an'/
        '       existing source model');
OUTPUT;(' (3) - Plot characteristics of source model');
OUTPUT;(' (4) - QUIT');
OUTPUT;(' ',$);
    INPUT CHOICE;(I8);

    IF(CHOICE = 4)RETURN;
    IF(CHOICE>4)|(CHOICE<0)[
        OUTPUT;(//' SORRY, NO SUCH OPTIONS!'/);
        RETURN;
        ]
    ]

IF ~EGSPERT[ CALL HELP_MESSAGE(59); ]

" ---------------------------------------------------------------------------- "

" Initialise variables for later use "
RSSD1=0.0;
K1=0;
K2=0;
K3=0;
K4=0;
KWEI=0.;
DELTAZ=25.;
SSMFPS=' ';

OLDFILE= .true.; "all options except 0 use an existing source parameter file"

" Input new sub-source specifiers & analyze ph-sp data "
" ---------------------------------------------------- "
IF(CHOICE=0)[
  OLDFILE=.false.; "default to entering sub-source specifiers from scratch"
  IF (~EGSPERT)[ CALL HELP_MESSAGE(60); ]
  :USE_REF_FILE:;
  OUTPUT ;
    (/
  ' Would you like to use sub-source specifiers from an existing source model'/
  ' as a reference? (y/n[Default])=> ',$);
  INPUT C1; (a1);
  IF (C1='?') [CALL HELP_MESSAGE(30); GOTO :USE_REF_FILE:;]
  IF (C1='y' | C1='Y') OLDFILE=.true.;
]

" Read existing sub-source specifiers "
" ----------------------------------- "
IF(OLDFILE)[
   IF ~EGSPERT[
     IF(CHOICE=0)[ CALL HELP_MESSAGE(55); ]
     ELSEIF(CHOICE=1)[ CALL HELP_MESSAGE(56); ]
     ELSEIF(CHOICE=2)[ CALL HELP_MESSAGE(57); ]
     ELSEIF(CHOICE=3)[ CALL HELP_MESSAGE(58); ]
   ]
   :READ_FILE_NAME:
   IF(CHOICE=0)[
       OUTPUT;
    (/' Source model containing sub-source specifiers to use as reference=> '/
    ' ',$);
   ]
   ELSEIF(CHOICE=1)[
       OUTPUT;
  (/' Source model containing sub-source specifiers to be modified=> '/
    ' ',$);
   ]
   ELSEIF(CHOICE=2)[
       OUTPUT;
  (/' Source model containing sub-source specifiers for analyzing phsp data=>'/
  ' ',$);
   ]
   ELSEIF(CHOICE=3)[
       OUTPUT;(/' Source model to plot=>'/' ',$);
   ]

   " Input multiple-source file name "
   INPUT OLDNAM ; (A80);
   IF (OLDNAM='?') [
       CALL HELP_MESSAGE(49);
       GOTO :READ_FILE_NAME:;
       ]
   CLOSE(UNIT=3,STATUS='KEEP');

   OPEN(UNIT=3,STATUS='OLD',FILE=OLDNAM,ERR=:AAA01:);

   " Read existing multiple-source data "
   " ---------------------------------- "
    READ(3,'(A80)',ERR=:AAA01:)SSMFPS; "detailed descriptions of the source"
    READ(3,*,ERR=:AAA01:)NSMFPS; "number of sub-sources for the source model"
    DO I=1,NSMFPS["output from each sub-sources"
        READ(3,*,ERR=:AAA01:)ISMFPS(I),IQSMFP(I),LATCH(I);
        IF(CHOICE=2 & LATCH(I)>$NS)["print a warning of LATCH out of range"
            OUTPUT I,ISMFPS(I),IQSMFP(I),LATCH(I),$NS;
       (//' ***WARNING IN SUB-SOURCE ',I3,' (type=',I3,',charge=',I3,'):'/
          ' LATCH bit associated with source = ',I3/
          ' LATCH bit should be <=',I3/
          ' Bit will be selected anyway.'//);
        ]
        IF (ISMFPS(I) = 1) ["model for aperture applicators"
            READ(3,*,ERR=:AAA01:)SMFMNZ(I),SMFMNX(I),SMFMXX(I),
            SMFMNY(I),SMFMXY(I),SMFX2(I),SMFY2(I);
            ]
        ELSEIF (ISMFPS(I) = 11) ["model for tubular applicators"
            READ(3,*,ERR=:AAA01:)SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),
            SMFMNY(I),SMFMXY(I),SMFX2(I),SMFY2(I);
            ]
        ELSEIF (ISMFPS(I) = 2) ["model for collimators"
            READ(3,*,ERR=:AAA01:)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),
            SMFMXY(I),SMFX2(I),SMFY2(I),SMFPXY(I);
            ]
        ELSEIF(ISMFPS(I) = 3)["model for ring, cone, and point source"
            READ(3,*,ERR=:AAA01:)SMFMNZ(I),SMFMNR(I),SMFMXR(I),RSSD0;
            ]
        ELSEIF(ISMFPS(I) = 4) ["model for rectangular plane source"
            READ(3,*,ERR=:AAA01:)SMFMNZ(I),SMFMNX(I),SMFMXX(I),
            SMFMNY(I),SMFMXY(I);
            ]
        ELSE["model for circular plane source"
            READ(3,*,ERR=:AAA01:)SMFMNZ(I),SMFMNR(I);
            ]
        ]"end of read for each sub-source"

    " In case user writes his own input data, try 1 source first "
    DO I=1,1[
 " Energy spectrum "
        READ(3,*,ERR=:AAA01:)NSMFEE,SMFMNE,SMFMXE;
 " Energy spectrum type "
 READ(3,*,ERR=:AAA01:)ESTYPE;
 IF(ESTYPE = 0) [
    " energy spectrum type for Inside/outside the treatment field"
    READ(3,*,ERR=:AAA01:)RTREATe,RFIELDe;
    NFIELDe=2;
    ERADII(1) = RTREATe;
    ERADII(2) = RFIELDe;
    ]
 ELSE [
    " energy spectrum with different radii "
    READ(3,*,ERR=:AAA01:)NFIELDe,RFIELDe;
    READ(3,*,ERR=:AAA01:)(ERADII(II),II=1,NFIELDe);
 ]

 " Field type "
        READ(3,*,ERR=:AAA01:)MSMFXY;
        IF(MSMFXY = 0)["circular field distribution"
            READ(3,*,ERR=:AAA01:)NFIELDi,RTREAT,NFIELDo,RFIELD;
            ]
        ELSEIF(MSMFXY = 1)["square field with symmetrical rings"
            READ(3,*,ERR=:AAA01:)NFIELDi,RTREAT,NFIELDo,RFIELD;
            ]
        ELSEIF(MSMFXY = 2)["rectangular field"
            READ(3,*,ERR=:AAA01:)NFIELD,XFLDMN,XFLDMX,YFLDMN,YFLDMX;
            READ(3,*,ERR=:AAA01:)XTREATMN,XTREATMX,YTREATMN,YTREATMX;
            ]
        READ(3,'(A100)',ERR=:AAA01:)PSDNAM;
      ]

     GOTO :AA01:;
     :AAA01:
       CALL HELP_MESSAGE(49);
       GOTO :READ_FILE_NAME:;
     :AA01:
] " end of reading existing sub-source specifiers "


" Change sub-source specifiers in an existing source model "
" Plot characteristics of source model "
" ------------------------------------ "
IF(CHOICE=1)|(CHOICE=3)[
    " Read parameters from the input file for each sub-source "
    DO I=1,NSMFPS[
         READ(3,*,ERR=:A001:)II;
         IF(I ~= II)[GOTO :A000001:;"data not right"]
         READ(3,*,ERR=:A001:)ISMFPS(I),IQSMFP(I),LATCH(I);
         IF (ISMFPS(I) = 1) ["model for aperture applicators"
             READ(3,*,ERR=:A001:)SMFMNZ(I),SMFMNX(I),SMFMXX(I),
             SMFMNY(I),SMFMXY(I),SMFX2(I),SMFY2(I);
             ]
         ELSEIF (ISMFPS(I) = 11) ["model for tubular applicators"
             READ(3,*,ERR=:A001:)SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),
             SMFMNY(I),SMFMXY(I),SMFX2(I),SMFY2(I);
             ]
         ELSEIF (ISMFPS(I) = 2) ["model for collimators"
             READ(3,*,ERR=:A001:)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),
             SMFMXY(I),SMFX2(I),SMFY2(I),SMFPXY(I);
             ]
         ELSEIF(ISMFPS(I) = 3)["model for ring, cone, and point source"
             READ(3,*,ERR=:A001:)SMFMNZ(I),SMFMNR(I),SMFMXR(I),RSSD0;
             ]
         ELSEIF(ISMFPS(I) = 4) ["model for rectangular plane source"
             READ(3,*,ERR=:A001:)SMFMNZ(I),SMFMNX(I),SMFMXX(I),
             SMFMNY(I),SMFMXY(I);
             ]
         ELSE["model for circular plane source"
             READ(3,*,ERR=:A001:)SMFMNZ(I),SMFMNR(I);
             ]

  " Relative source intensity "
         READ(3,*,ERR=:A001:)SMFRTN(I);
  " Number of bins, maximum and minimum energy "
         READ(3,*,ERR=:A001:)NSMFEE,SMFMNE,SMFMXE;

  DO III=1,NFIELDe[
     READ(3,*,ERR=:A001:) (FSMFBN1(I,III,II),II=1,NSMFEE);
     ]

         " Fielf type"
         READ(3,*,ERR=:A001:)MSMFXY;

         IF(MSMFXY = 0)["circular field distribution"
              READ(3,*,ERR=:A001:)NFIELDi,RTREAT,NFIELDo,RFIELD;
       NFIELD = NFIELDi + NFIELDo;
             "probability for each bin"
       READ(3,*,ERR=:A001:)(FSMFRR(I,II),II=1,NFIELD);
             ]
         ELSEIF(MSMFXY = 1)["square field with symmetrical square rings"
             READ(3,*,ERR=:A001:)NFIELDi,RTREAT,NFIELDo,RFIELD;
      NFIELD = NFIELDi + NFIELDo;
             READ(3,*,ERR=:A001:)(FSMFRR(I,II),II=1,NFIELD);
             READ(3,*)(FSMFR11(I,II),II=1,NFIELD);"parameters used in sampling"
             READ(3,*)(FSMFR12(I,II),II=1,NFIELD);"parameters used in sampling"
             "probability for each bin"
             ]
         ELSEIF(MSMFXY = 2)["rectangular field"
             READ(3,*,ERR=:A001:)NFIELD,XFLDMN,XFLDMX;
             READ(3,*,ERR=:A001:)NFIELD,YFLDMN,YFLDMX;
             READ(3,*,ERR=:A001:)((FSMFXY(I,II,III),II=1,NFIELD),
                 III=1,NFIELD);
             "probability for each bin"
             ]
         ]"end of read for each sub-source"

    READ(3,*,ERR=:A001:) (FSMABN1(II),II=1,$NBINANGLE);
    ABNTOTAL=0.;
    DO II=1,$NBINANGLE[ABNTOTAL=ABNTOTAL+FSMABN1(II);]
    ABNTOTALH=0.;
    DO II=1,$NBINANGLE[
       ABNTOTALH=ABNTOTALH+FSMABN1(II);
       IF((ABNTOTAL ~= 0.) & (ABNTOTALH/ABNTOTAL >= 0.5))[
          RSCATT=100.*TAN(FLOAT(II)*0.1745/FLOAT($NBINANGLE));
          "calculating mean scattering radius"
          IF((RSCATT <= 0.) & (RSCATT > 50.))[RSCATT=5.;]
          GOTO :FOUND-RSCATT:;
       ]
       ]
     :FOUND-RSCATT:;

     GOTO :A0001:;
     :A000001:OUTPUT;
     (//' SUB-SOURCES ARE NOT IN THE RIGHT ORDER, WHY?'//);GOTO :A0001:;
     :A001: OUTPUT;
     (//' ENERGY OR PLANAR FLUENCE MAY NOT BE CORRECT!'//);
     :A0001:
     CLOSE(UNIT=3,STATUS='KEEP');
     OUTPUT;
     (//' WARNING: data contained in the file may not be right if it was'/
        '          created before the execution of the programme BEAMDP'/
        '          was completed!!!'/);
     IF(CHOICE=3)GOTO :DATA-FOR-GRAPH-PLOTTING:;
] " END OF CHOICE=1 OR 3 "

IF ~EGSPERT[ CALL HELP_MESSAGE(54); ]
:A:
OUTPUT;(/' File name for the new/modified source model:'/' ',$);
INPUT SPCNAM ; (A80);
IF (SPCNAM='?') [
    CALL HELP_MESSAGE(31);
    GO TO :A:;
]

IF (SPCNAM=' ') [
    IF (OLDNAM=' ') [
        OLDNAM='beamdp.tmp';
        OUTPUT;(/' FILE NAME DEFAULT TO [beamdp.tmp]'/);
        ]
    SPCNAM=OLDNAM;
]

IF ~EGSPERT[ CALL HELP_MESSAGE(32); ]
:B:
OUTPUT ; (/' Detailed information about the source: ');
IF(SSMFPS ~= ' ')[
    OUTPUT SSMFPS;(/' THE OLD INFORMATION WAS:'/' ', A80/
    ' (Return to keep the information, otherwise type in the new one):'/);
    ]
INPUT DSMFPS ; (A80);
IF(DSMFPS='?') [CALL HELP_MESSAGE(32); GO TO :B:;]
IF(DSMFPS ~= ' ')[SSMFPS=DSMFPS;]
ELSEIF(SSMFPS = ' ')[
    OUTPUT;(/' INFORMATION ABOUT THE SIMULATED BEAM (to be filled later)'/);
    SSMFPS='to-be-filled-later';
    ]

IF(CHOICE = 2)[
    RSSD1=RSSD0;"radius of a ring for SSD analysis"
    GOTO :OPEN-PHSP-FILE:;
]

IF ~EGSPERT[ CALL HELP_MESSAGE(33); ]
:C:
OUTPUT ; (/' Number of sub-sources=> ',$);
IF OLDFILE[
    OUTPUT NSMFPS; "number of sub-sources for the source model"
    (/' The old value was',I4,'. You cannot change this value.'/);
    ]
ELSE[
    INPUT C2;(A2);
    IF (C2='? ') [ CALL HELP_MESSAGE(33);   GO TO :C:; ]
    READ(C2,'(I8)')NSMFPS ; "number of sub-sources for the source model"
    IF (NSMFPS < 1)|(NSMFPS > $NS) [CALL HELP_MESSAGE(33);   GO TO :C:; ]
    ]

DO I=1,NSMFPS["input parameters for each sub-source"

    IF ~EGSPERT[ CALL HELP_MESSAGE(34); ]
    :D1:
    OUTPUT I;
    (/' INPUT PARAMETERS FOR SUB-SOURCE',I4,':'//
     ' SOURCE TYPE(1&11-appl,2-coll,3-ring,4-rect.plane,5-circ.plane),'/
     ' CHARGE OF PARTICLES (0-photons,-1-electrons,1-positrons),'/
     ' LATCH NUMBER FOR THE SUB-SOURCE DURING BEAM SIMULATION'/' ',$);
    IF OLDFILE[
       OUTPUT ISMFPS(I),IQSMFP(I),LATCH(I);
       (/' The old values were',3I4,'.'/' Do you want to change them?'/' ',$);
       INPUT C1;(A1);
       IF (C1='?') [   GO TO :D:; ]
       IF (C1='y')|(C1='Y') [
         OUTPUT I;
         (//' INPUT PARAMETERS FOR SUB-SOURCE:',I4///
         ' SOURCE TYPE (1&11-appl,2-coll,3-ring,4-rect.plane,5-circ.plane),'/
         ' CHARGE OF PARTICLES (0-photons,-1-electrons,1-positrons), AND'/
         ' LATCH NUMBER FOR THE SUB-SOURCE DURING BEAM SIMULATION'/);
         ]
       ELSE[GOTO :DD:;]
       ]
    READ(5,'(3I15)',ERR=:D:) ISMFPS(I),IQSMFP(I),LATCH(I);
    GOTO :DD:;
    :D:
      CALL HELP_MESSAGE(34);
      GOTO :D1:;
    :DD:;
    IF ((ISMFPS(I)<1)|(ISMFPS(I)>11)|(IQSMFP(I)<-1)
        |(IQSMFP(I)>1)) [
        OUTPUT;(/' SORRY, OUT OF RANGE!!!'//);
        GO TO :D:;
        ]
    IF(LATCH(I) > $NS)[
        OUTPUT $NS;
        (///' SORRY, LATCH BIT MUST BE <=',I3,'!!!'//)
        GOTO :D:;
        ]

    IF(ISMFPS(I)=1)["sub-source is applicator"
        IF ~EGSPERT[ CALL HELP_MESSAGE(35); ]
        :E:
        OUTPUT;
        (/' Zmin, X-, X+, Y-, Y+, |x|max, |y|max (in cm) OF THE SOURCE:'/
          ' ',$);
        IF OLDFILE[
           OUTPUT SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
           SMFX2(I),SMFY2(I);
           (/' The old values were',7F10.3,'.'/
    ' Do you want to change them?'/' ',$);
           INPUT C1;(A1);
           IF (C1='?') [GO TO :EEE:; ]
           IF (C1='y')|(C1='Y') [
           OUTPUT;
             (/' Zmin, X-, X+, Y-, Y+, |x|max, |y|max (in cm) OF THE SOURCE:'
             /' ',$);
             ]
           ELSE[GOTO :EE:;]
           ]
        READ(5,'(7F15.0)',ERR=:EEE:)
        SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),SMFX2(I),SMFY2(I);
        GOTO :EE:;
        :EEE:
          CALL HELP_MESSAGE(35);
          GO TO :E:;
        :EE:;
        IF (SMFMNZ(I)<0.)|(SMFMNX(I)>= SMFMXX(I))|
        (SMFMNY(I)>= SMFMXY(I))[
            OUTPUT;(//' SORRY, Zmin MUST BE >= 0.0 cm');
            OUTPUT;(  '        X+ MUST BE > X-');
            OUTPUT;(  '        Y+ MUST BE > Y-'//);
            GO TO :E:;
            ]
        HFIELD(I)=(SMFMXX(I)-SMFMNX(I)+SMFMXY(I)-SMFMNY(I))*1.1/4.;
        "a factor of 1.1 is used here to account for the variation of"
        "distance and weighting from different part of the source"

        ]"end of sub-source = 1"

    ELSEIF(ISMFPS(I)=11)["sub-source is tubular applicator"
        IF ~EGSPERT[ CALL HELP_MESSAGE(36); ]
    :E11:
    OUTPUT;(/' Zmin,Zmax,X-,X+,Y-,Y+,|x|max,|y|max (in cm) OF THE SOURCE:'/);
    IF OLDFILE[
        OUTPUT SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
        SMFX2(I),SMFY2(I);
        (/' The old values were',8F10.3,'.'/
 ' Do you want to change them?'/' ',$);
        INPUT C1;(A1);
        IF (C1='?') [   GO TO :EEE11:; ]
        IF (C1='y')|(C1='Y') [
    OUTPUT;(/' Zmin,Zmax,X-,X+,Y-,Y+,|x|max,|y|max (in cm) OF THE SOURCE:'/);
          ]
        ELSE[GOTO :EE11:;]
        ]
        READ(5,'(7F15.0)',ERR=:EEE11:)
        SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
        SMFX2(I),SMFY2(I);
        GOTO :EE11:;
        :EEE11:
          CALL HELP_MESSAGE(36);
          GOTO :E11:;
        :EE11:;
        IF (SMFMNZ(I)<0.)|(SMFMNZ(I)>SMFMXZ(I))|(SMFMNX(I)>= SMFMXX(I))|
        (SMFMNY(I)>= SMFMXY(I))[
            OUTPUT;(//' SORRY, Zmax MUST BE >= Zmin >=0.0 cm');
            OUTPUT;(  '        X+ MUST BE > X-');
            OUTPUT;(  '        Y+ MUST BE > Y-'//);
            GO TO :E11:;
            ]
        HFIELD(I)=(SMFMXX(I)-SMFMNX(I)+SMFMXY(I)-SMFMNY(I))*1.1/4.;
        "a factor of 1.1 is used here to account for the variation of"
        "distance and weighting from different part of the source"

        ]"end of sub-source = 11"

    ELSEIF(ISMFPS(I)=2)["sub-source is collimator"
        IF ~EGSPERT[ CALL HELP_MESSAGE(37); ]
        :F:
        OUTPUT;
        (/' Zmin,X-,X+,Y-,Y+,|x|max,|y|max(in cm),Orientation OF THE SOURCE'/
         ' (0-collimator bars along x-axis,1-along y-axis):'/' ',$);
        IF OLDFILE[
            OUTPUT SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
            SMFX2(I),SMFY2(I),SMFPXY(I);
            (/' The old values were',7F10.3,I4,'.'/
              ' Do you want to change them?'/' ',$);
            INPUT C1;(A1);
            IF (C1='?') [   GO TO :FFF:; ]
            IF (C1='y')|(C1='Y') [
            OUTPUT;
        (/' Zmin,X-,X+,Y-,Y+,|x|max,|y|max(in cm),Orientation OF THE SOURCE'/
        '  (0-collimator bars along x-axis,1-along y-axis):'/' ',$);
              ]
            ELSE[GOTO :FF:;]
            ]
        READ(5,'(7F15.0,I4)',ERR=:FFF:)
        SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
        SMFX2(I),SMFY2(I),SMFPXY(I);
        GOTO :FF:;
        :FFF:
           CALL HELP_MESSAGE(37);
           GOTO :F:;
        :FF:;
        IF ((SMFMNZ(I)<0.)|(SMFMNX(I)>= SMFMXX(I))|
        (SMFMNY(I)>= SMFMXY(I))|(SMFPXY(I)<0.0)|(SMFPXY(I)>1.))[
            OUTPUT;(//' SORRY, SSD  MUST BE >= 0.0');
            OUTPUT;(  '        X+ MUST BE > X-');
            OUTPUT;(  '        Y+ MUST BE > Y-');
            OUTPUT;(  '        Orientation must be = 0 or 1'//);
            GO TO :F:;
            ]
        HFIELD(I)=(SMFMXX(I)-SMFMNX(I)+SMFMXY(I)-SMFMNY(I))/4.;
        ]"end of sub-source = 2"


    ELSEIF(ISMFPS(I) = 3)["sub-source is ring, cone or point source"
        IF ~EGSPERT[ CALL HELP_MESSAGE(38); ]
        :G:
        OUTPUT;
        (/' SSD, Rmin and Rmax OF THE SOURCE(=0 for point source):'
         /' ',$);
        IF OLDFILE[
            OUTPUT SMFMNZ(I),SMFMNR(I),SMFMXR(I);
            (/' The old values were',3F10.3,'.'/
              ' Do you want to change them?'/' ',$);
            INPUT C1;(A1);
            IF (C1='?') [   GO TO :GGG:; ]
            IF (C1='y')|(C1='Y') [
            OUTPUT;
            (/' SSD, Rmin and Rmax OF THE SOURCE(=0 for point source):'
              /' ',$);
              ]
            ELSE[GOTO :GG:;]
            ]
        READ(5,'(3F15.0)',ERR=:GGG:)SMFMNZ(I),SMFMNR(I),SMFMXR(I);
        GOTO :GG:;
        :GGG:
          CALL HELP_MESSAGE(38);
          GOTO :G:;
        :GG:;
        IF (SMFMNZ(I)<0.)|(SMFMNR(I)<0.0)|(SMFMNR(I) > SMFMXR(I))[
            OUTPUT;(//' SORRY, SSD  MUST BE >= 0.0');
            OUTPUT;(  '        Radius MUST BE >= 0.0'//);
            OUTPUT;(  '        Rmax MUST BE >= Rmin'//);
            GO TO :G:;
            ]
        IF(SMFMNR(I) < 1.0)&(SMFMNZ(I) > 50.)&(RSSD0 ~= 1000.)[
           "a point source or a ring with a small radius but large SSD"
           "RSSD0 = 1000.0 means that ring radius has not been set"
           IF ~EGSPERT[ CALL HELP_MESSAGE(39); ]
        :G1:
           OUTPUT;
        (/' Radius(cm) of a ring region on the surface for SSD analysis:'/
        ' ',$);
        IF OLDFILE[
            OUTPUT RSSD0;
            (/' The old value was',F10.3,'.'/
     ' Do you want to change it?'/' ',$);
            INPUT C1;(A1);
            IF (C1='?') [   GO TO :GGG1:; ]
            IF (C1='y')|(C1='Y') [
            OUTPUT;
            (/' Radius(cm) of a ring region on the surface for SSD analysis:'
             /' ',$);
              ]
            ELSE[GOTO :GG1:;]
            ]
           READ(5,'(F15.0)',ERR=:GGG1:)RSSD0;
           GOTO :GG1:;
           :GGG1:
             CALL HELP_MESSAGE(39);
             GOTO :G1:;
           :GG1:
           IF (RSSD0<0.)[
              OUTPUT;(//' SORRY, Radius  MUST BE >= 0.0'/);
              GO TO :GGG1:;
              ]
           IF(RSSD0 = RSSD1)[
              OUTPUT;(///' SORRY, YOU CAN ONLY HAVE ONE POINT SOURCE!!!'//
              ' THINK ABOUT IT AND TRY AGAIN.'//);
              STOP;
              ]
           RSSD1=RSSD0;"first time using point source, we take this value"
           RSSD0=1000.;"flag: ring radius has been set"
           ]"end of point-source case"
        HFIELD(I)=SMFMNR(I);
        ]"end of sub-source = 3"

    ELSEIF(ISMFPS(I) = 4)["sub-source is a rectangular plane source"
        IF ~EGSPERT[ CALL HELP_MESSAGE(40); ]
        :G4:
        OUTPUT;
        (/' SSD, X-, X+, Y- and Y+ (in cm) OF THE SOURCE:',$);
        IF OLDFILE[
            OUTPUT SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I);
            (/' The old values were',5F10.3,'.'/
              ' Do you want to change them?'/' ',$);
            INPUT C1;(A1);
            IF (C1='?') [   GO TO :GGG4:; ]
            IF (C1='y')|(C1='Y') [
              OUTPUT;
              (/' SSD, X-, X+, Y- and Y+ (in cm) OF THE SOURCE:',$);
              ]
            ELSE[GOTO :GG4:;]
            ]
        READ(5,'(5F15.0)',ERR=:GGG4:)SMFMNZ(I),SMFMNX(I),SMFMXX(I),
                  SMFMNY(I),SMFMXY(I);
        GOTO :GG4:;
        :GGG4:
           CALL HELP_MESSAGE(40);
           GOTO :G4:;
        :GG4:;
        IF (SMFMNZ(I)<0.)|(SMFMXX(I)<SMFMNX(I))|(SMFMNY(I) > SMFMXY(I))[
            OUTPUT;(//' SORRY, SSD  MUST BE >= 0.0');
            OUTPUT;(  '        X+ MUST BE > X-'//);
            OUTPUT;(  '        Y+ MUST BE > Y-'//);
            GO TO :GGG4:;
            ]
        ]

    ELSEIF(ISMFPS(I) = 5)["sub-source is a plane source"
        IF ~EGSPERT[ CALL HELP_MESSAGE(41); ]
        :G5:
        OUTPUT;
        (/' SSD and Radius (in cm) OF THE SOURCE:'/ ' ',$);
        IF OLDFILE[
            OUTPUT SMFMNZ(I),SMFMNR(I);
            (/' The old values were',2F10.3,'.'/
              ' Do you want to change them?'/' ',$);
            INPUT C1;(A1);
            IF (C1='?') [   GO TO :GGG5:; ]
            IF (C1='y')|(C1='Y') [
               OUTPUT;
        (/' SSD and Radius (in cm) OF THE SOURCE:'/ ' ',$);
               ]
            ELSE[GOTO :GG5:;]
            ]
        READ(5,'(2F15.0)',ERR=:GGG5:)SMFMNZ(I),SMFMNR(I);
        GOTO :GG5:;
        :GGG5:
           CALL HELP_MESSAGE(41);
           GOTO :G5:;
        :GG5:;
        IF (SMFMNZ(I)<0.)|(SMFMNR(I)<0.0)[
            OUTPUT;(//' SORRY, SSD  MUST BE >= 0.0');
            OUTPUT;(  '        Radius MUST BE >= 0.0'//);
            GO TO :GGG5:;
            ]
        ]

    ]"end of I loop"


" Energy spectrum "
" --------------- "
IF ~EGSPERT[ CALL HELP_MESSAGE(42); ]
:H:
OUTPUT; (/' Nbin, Emin, Emax (in MeV, kinetic only) for the spectrum:'/
         ' ',$);
IF OLDFILE[
   OUTPUT NSMFEE,SMFMNE,SMFMXE;
   (/' The old values were',I4,2F10.3,'.'/
   ' Do you want to change them?'/' ',$);
   INPUT C1;(A1);
   IF (C1='?') [   GO TO :HHH:; ]
   IF (C1='y')|(C1='Y') [
      OUTPUT;
      (/' Nbin, Emin, Emax (in MeV, kinetic only) for the spectrum:'/' ',$);
      ]
   ELSE[GOTO :HH:;]
   ]
READ(5,'(I15,2F15.0)',ERR=:HHH:) NSMFEE,SMFMNE,SMFMXE;
OUTPUT NSMFEE,SMFMNE,SMFMXE; (I6,2F12.4);
GOTO :HH:;
:HHH:
  CALL HELP_MESSAGE(42);
  GOTO :H:;
:HH:;
IF ((SMFMNE<0.0)|(SMFMNE>SMFMXE)|(SMFMXE<0.0)|(NSMFEE>$NB)|(NSMFEE<1)) [
   OUTPUT $NB;(/' Sorry, energies should be Emax > Emin > 0.0 '/
   '    and bin number must be between 1 and ',I4,'!!!'/);
   GO TO :HHH:;
   ]

" Energy spectrum type "
" -------------------- "
IF ~EGSPERT[ CALL HELP_MESSAGE(80); ]
:EST1:
OUTPUT; (/' ENERGY SPECTRUM TYPE ',
 '(0-inside/outside treatment field, 1-different radii):'/' ',$);
IF OLDFILE[
   OUTPUT ESTYPE;
   (/' The old value was',I4,'.'/' Do you want to change it?'/' ',$);
   INPUT C1;(A1);
   IF (C1='?') [   GO TO :EST3:; ]
   IF (C1='y')|(C1='Y') [
      OUTPUT;
      (/' ENERGY SPECTRUM TYPE (0-inside/outside, 1-different radii):'/' ',$);
      ]
   ELSE[GOTO :EST2:;]
   ]
READ(5,'(I15)',ERR=:EST3:) ESTYPE;
GOTO :EST2:;
:EST3:
   CALL HELP_MESSAGE(80);
   GOTO :EST1:;
:EST2:;
IF ((ESTYPE<0)|(ESTYPE>1)) [
   OUTPUT;(/' SORRY, NO SUCH ENERGY SPECTRUM TYPE!!!'//);
   GO TO :EST3:;
   ]

" energy spectrum type for Inside/outside the treatment field"
" ----------------------------------------------------------- "
IF (ESTYPE = 0)[
    IF ~EGSPERT[ CALL HELP_MESSAGE(81);]
    :ES01:
    OUTPUT;(/' R_treatment,R_scoring:'/' ',$);
    IF OLDFILE[
       OUTPUT RTREATe,RFIELDe;
       (/' The old values were',F10.3,F10.3,'.'/
       'Do you want to change them?'/' ',$);
       INPUT C1;(A1);
       IF (C1='?') [ GO TO :ES03:; ]
       IF (C1='y')|(C1='Y') [
          OUTPUT;(/' R_treatment,R_scoring:'/' ',$);
       ]
       ELSE[GOTO :ES02:;]
    ]
    READ(5,'(F15.0,F15.0)',ERR=:ES03:) RTREATe,RFIELDe;
    GOTO :ES02:;
    :ES03:
       CALL HELP_MESSAGE(81);
       GOTO :ES01:;
    :ES02:;
    IF (RTREATe<0.0001)|(RFIELDe<RTREATe)[
 OUTPUT;(//' SORRY, RADIUS  MUST BE >= 0.0001' /
                  ' AND DEFINED FIELD MUST BE INSIDE SCORING FIELD');
        GO TO :ES03:;
        ]
    " Success, set NFIELDe = 2 for this energy type "
    NFIELDe = 2;
    ERADII(1) = RTREATe;
    ERADII(2) = RFIELDe;
]
" energy spectrum with different radii "
" ------------------------------------ "
ELSEIF(ESTYPE = 1)[
    IF ~EGSPERT[ CALL HELP_MESSAGE(82); ]
    :ES11:
    OUTPUT;(/' NbinEn,R_scoring:'/' ',$);
    IF OLDFILE[
       OUTPUT NFIELDe,RFIELDe;
       (/' The old values were',I4,F10.3,'.'/
       'Do you want to change them?'/' ',$);
       INPUT C1;(A1);
       IF (C1='?') [   GO TO :ES13:; ]
       IF (C1='y')|(C1='Y') [
         OUTPUT;(/' NbinEn,R_scoring:'/' ',$);
         ]
       ELSE[GOTO :ES12:;]
       ]
    READ(5,'(I12,F15.0)',ERR=:ES13:) NFIELDe,RFIELDe;
    GOTO :ES12:;
    :ES13:
       CALL HELP_MESSAGE(82);
       GOTO :ES11:;
    :ES12:;
    IF (RFIELDe<0.0001)|(NFIELDe<1)|(NFIELDe>$NB)[
        OUTPUT;(//' SORRY, SCORING FIELD RADIUS MUST BE >= 0.0001,');
        OUTPUT $NB;
        (         ' AND NUMBER OF BINS MUST BE BETWEEN 1 AND ',I5,'!'//);
        GO TO :ES13:;
        ]
    " Success, NFIELDe is the number of different radii "
    " Now, read different radii "
    IF ~EGSPERT[ CALL HELP_MESSAGE(83); ]
    :ESR1:
    WRITE(6,*) ('R[',I,'],',I=1,NFIELDe);
    IF OLDFILE[
       WRITE(6,*)(ERADII(I),I=1,NFIELDe); "different radii for energy spectra"

       OUTPUT (ERADII(I),I=1,NFIELDe);
       (/' The old values were',A,'.'/'Do you want to change it?'/' ',$);
       INPUT C1;(A1);
       IF (C1='?') [   GO TO :ESR3:; ]
       IF (C1='y')|(C1='Y') [
         WRITE(6,*) ('R[',I,'],',I=1,NFIELDe);
         ]
       ELSE[GOTO :ESR2:;]
       ]
    READ(5,*,ERR=:ESR3:)(ERADII(I),I=1,NFIELDe);
    GOTO :ESR2:;
    :ESR3:
       CALL HELP_MESSAGE(83);
       GOTO :ESR1:;
    :ESR2:;
    DO I=1,NFIELDe[
       IF (ERADII(I)<0.0001)|(ERADII(I)>RFIELDe)[
   OUTPUT;(//' SORRY, RADIUS  MUST BE >= 0.0001' /
      ' AND MUST BE INSIDE SCORING FIELD');
          GO TO :ESR3:;
   ]
       ]
    IF (ERADII(NFIELDe) ~= RFIELDe)[
       OUTPUT;(//' SORRY, LAST RADIUS MUST BE EQUAL TO R_scoring,');
       GO TO :ESR3:;
       ]
    ]"end of energy spectrum with different radii"

" Field type "
" ---------- "
IF ~EGSPERT[ CALL HELP_MESSAGE(43); ]
:I:
OUTPUT; (/' FIELD TYPE (0-circular ring,1-square ring,2-rectangular):'/' ',$);
IF OLDFILE[
   OUTPUT MSMFXY ;
   (/' The old value was',I4,'.'/' Do you want to change it?'/' ',$)
   INPUT C1;(A1);
   IF (C1='?') [   GO TO :III:; ]
   IF (C1='y')|(C1='Y') [
      OUTPUT;
        (/' INPUT FIELD TYPE (0-circular, 1-square, 2-rectangular):'/' ',$);
      ]
   ELSE[GOTO :II:;]
   ]
READ(5,'(I15)',ERR=:III:) MSMFXY ;
GOTO :II:;
:III:
   CALL HELP_MESSAGE(43);
   GOTO :I:;
:II:;
IF ((MSMFXY<0)|(MSMFXY>2)) [
   OUTPUT;(/' SORRY, NO SUCH FIELD TYPE!!!'//);
   GO TO :III:;
   ]

IF (MSMFXY = 0)["circular field with symmetrical rings"
    IF ~EGSPERT[ CALL HELP_MESSAGE(44);]
    :J:
    OUTPUT;
    (/' NbinFlIn, R_treatment, NbinFlOut, R_scoring:'/' ',$);
    IF OLDFILE[
       OUTPUT NFIELDi,RTREAT,NFIELDo,RFIELD;
       (/' The old values were',I4,F10.3,I4,F10.3,'.'/
        'Do you want to change them?'/' ',$);
       INPUT C1;(A1);
       IF (C1='?') [ GO TO :JJJ:; ]
       IF (C1='y')|(C1='Y') [
          OUTPUT;
          (/' NbinFlIn, R_treatment, NbinFlOut, R_scoring:'/' ',$);
       ]
       ELSE[GOTO :JJ:;]
    ]
    READ(5,'(I12,F15.0,I12,F15.0)',ERR=:JJJ:) NFIELDi,RTREAT,NFIELDo,RFIELD;
    GOTO :JJ:;
    :JJJ:
       CALL HELP_MESSAGE(44);
       GOTO :J:;
    :JJ:;

    " Successful input - calculate NFIELD "
    NFIELD = NFIELDi + NFIELDo;

    IF (RTREAT<0.0001)|(RFIELD<RTREAT)[
 OUTPUT;(//' SORRY, RADIUS  MUST BE >= 0.0001' /
                  ' AND DEFINED FIELD MUST BE INSIDE SCORING FIELD');
        GO TO :JJJ:;
        ]
    IF (NFIELDi<1)|(NFIELDi>$NB)|(NFIELDo<1)|(NFIELDo>$NB)[
        OUTPUT $NB;
        (//' SORRY, NUMBER OF BINS MUST BE BETWEEN 0 AND ',I5,'!'//);
        GO TO :JJJ:;
        ]
    IF ((NFIELD<1)|(NFIELD)>$NB)[
        OUTPUT $NB;
 (//' SORRY, TOTAL NUMBER OF BINS MUST BE BETWEEN 1 AND ',I5,'!'//);
        GO TO :JJJ:;
        ]
    ]"end of circular field with symmetrical rings"

ELSEIF(MSMFXY = 1)["square field with symmetrical square rings"
    IF ~EGSPERT[ CALL HELP_MESSAGE(47); ]
    :J123:
    OUTPUT;
    (/' NbinFlIn,1/2 TREAT FIELD WIDTH,NbinFlOut,1/2 SCORING FIELD WIDTH:'/
    ' ',$);
    IF OLDFILE[
       OUTPUT NFIELDi,RTREAT,NFIELDo,RFIELD;
       (/' The old values were',I4,F10.3,I4,F10.3,'.'/
        'Do you want to change them?'/' ',$);
       INPUT C1;(A1);
       IF (C1='?') [   GO TO :JJJ123:; ]
       IF (C1='y')|(C1='Y') [
         OUTPUT;
         (/' NbinFlIn,1/2 TREAT FIELD WIDTH,NbinFlOut,1/2 SCORING FIELD WIDTH:'/
          ' ',$);
         ]
       ELSE[GOTO :JJ123:;]
       ]
    READ(5,'(I12,F15.0,I12,F15.0)',ERR=:JJJ123:) NFIELDi,RTREAT,NFIELDo,RFIELD;
    GOTO :JJ123:;
    :JJJ123:
       CALL HELP_MESSAGE(47);
       GOTO :J123:;
    :JJ123:;

   " Successful input - calculate NFIELD "
    NFIELD = NFIELDi + NFIELDo;

    IF (RTREAT<0.0001)|(RFIELD<RTREAT)[
        OUTPUT;(//' SORRY, 1/2 WIDTH  MUST BE >= 0.0001,' /
                  ' AND DEFINED FIELD MUST BE INSIDE SCORING FIELD,');
        GO TO :JJJ123:;
        ]
    IF (NFIELDi<1)|(NFIELDi>$NB)|(NFIELDo<1)|(NFIELDo>$NB)[
        OUTPUT $NB;(//' SORRY, NUMBER OF BINS MUST BE BETWEEN 0 AND ',I5,'!'//);
        GO TO :JJJ123:;
        ]
    IF (NFIELD<1)|(NFIELD>$NB)[
        OUTPUT;
 (//' SORRY, TOTAL NUMBER OF BINS MUST BE BETWEEN 1 AND ',I5,'!'//);
        GO TO :JJJ123:;
        ]
    ]"end of square field with symmetrical square rings"

ELSEIF(MSMFXY = 2)["rectangular field"

    IF ~EGSPERT[ CALL HELP_MESSAGE(45); ]
    :K:
    OUTPUT;
    (/' INPUT NFbin,XFmin,XFmax,YFmin,YFmax FOR THE SCORING FIELD:'/' ',$);
    IF OLDFILE[
       OUTPUT NFIELD,XFLDMN,XFLDMX,YFLDMN,YFLDMX;
       (/' The old values were',I4,4F10.3,'.'/
         ' Do you want to change them? '/' ',$);
       INPUT C1;(A1);
       IF (C1='?') [   GO TO :KKKK:; ]
       IF (C1='y')|(C1='Y') [
       OUTPUT;
       (/' INPUT NFbin, XFmin, XFmax, YFmin, YFmax:'/' ',$);
          ]
       ELSE[GOTO :KK:;]
       ]
    READ(5,'(I12,4F15.0)',ERR=:KKKK:)NFIELD,XFLDMN,XFLDMX,YFLDMN,YFLDMX;
    GOTO :KK:;
    :KKKK:
       CALL HELP_MESSAGE(45);
       GOTO :K:;
    :KK:;
    IF (XFLDMN>=XFLDMX)|(YFLDMN>=YFLDMX)|
    (NFIELD<1)|(NFIELD>$NB)[
        OUTPUT;(//' SORRY, XFmax MUST BE > XFmin');
        OUTPUT;(  '        YFmax MUST BE > YFmin'//);
    OUTPUT $NB;(  '        NFbin MUST BE BETWEEN 1 AND ',I5,'!!'//);
        GO TO :KKKK:;
        ]

    IF ~EGSPERT[ CALL HELP_MESSAGE(46); ]
    :KD:
    OUTPUT;
    (/' INPUT Xmin,Xmax,Ymin,Ymax FOR TREATMENT FIELD: ',$);
    IF OLDFILE[
       OUTPUT XTREATMN,XTREATMX,YTREATMN,YTREATMX;
       (/' The old values were',4F10.3,'.'/
       ' Do you want to change them?'/' ',$);
       INPUT C1;(A1);
       IF (C1='?') [   GO TO :KKKD:; ]
       IF (C1='y')|(C1='Y') [
       OUTPUT;
    (/' INPUT Xmin,Xmax,Ymin,Ymax FOR TREATMENT FIELD: ',$);
          ]
       ELSE[GOTO :KKD:;]
       ]
    READ(5,'(4F15.0)',ERR=:KKKD:)XTREATMN,XTREATMX,YTREATMN,YTREATMX;
    GOTO :KKD:;
    :KKKD:
       CALL HELP_MESSAGE(46);
       GOTO :KD:;
    :KKD:;
    IF (XTREATMX<XTREATMN)|(YTREATMX<YTREATMN)[
        OUTPUT;(//' SORRY, XTFmin > XTFmax OR YTFmin > YTFmax NOT ALLOWED!');
        GO TO :KKKD:;
        ]
    ]"end of rectangular field"

:OPEN-PHSP-FILE:;

"first do some preparation work"

"PUT LATCH NUMBERS IN ORDER FOR LATER USE"
"*******************************************"
"we relate LATCH numbers to the SSD for each sub-source so that"
"K(1) corresponds to the smallest SSD, and then K(2), then K(3),..."

OUTPUT;
(/' The order of the sub-sources in terms of their distances to the'/
 ' scoring plane and their LATCH numbers:                       '//
 '   order     sub-source #       SSD           LATCH #       CHARGE'/);
DO I=1,NSMFPS[
    K(I)=1;Z=SMFMNZ(1);"always start from K(I) = 1"
    IF(I > 1)[
        "check whether K(I) has been put into right order."
        :CHECK:;
        DO II=1,I-1[
            IF(K(I) = K(II))[
                K(I)=K(I)+1;Z=SMFMNZ(K(I));
                GOTO :CHECK:;
                ]
            ]
        ]
    :CHECK-IS-OVER:;
    "we now have the next Z that should be checked against the rest"
    IF(I ~= NSMFPS)[
        DO III=1,NSMFPS[
            IF(SMFMNZ(III) < Z)[
                "Z is probably NOT the next nearest"
                DO II=1,I["check whether SMFMNZ(III) is one of the values"
                      "that are already in the right order.          "
                    IF(III = K(II))[GOTO :ALREADY-USED:;]
                    ]
                "yes, this is the next nearest Z to be put in order"
                K(I)=III;Z=SMFMNZ(III);
                :ALREADY-USED:;
                ]
            ]
        ]
    OUTPUT I,K(I),SMFMNZ(K(I)),LATCH(K(I)),IQSMFP(K(I));
    (I6, I14, F16.3,2I14);
    "go back to put the next Z in the right order"
    ]

:RR2:;

CALL READNAME;

"in case we cannot go any further and be stopped here we output the "
"parameters already typed in by the user. We may have many 0 in the file"
"but it does not matter"
"OUTPUT PARAMETERS ALREADY TYPED IN BY THE USER
"**********************************************
OPEN(UNIT=1,STATUS='UNKNOWN',FILE=SPCNAM);
"OPEN(UNIT=1,STATUS='UNKNOWN',FILE=SPCNAM,FORM='UNFORMATTED');"

WRITE(1,'(A80)')SSMFPS; "detailed descriptions of the source"
WRITE(1,*)NSMFPS; "number of sub-sources for the source model"

" Write output for each sub-source "
DO I=1,NSMFPS[
    WRITE(1,*)ISMFPS(I),IQSMFP(I),LATCH(I);
    IF (ISMFPS(I) = 1) ["model for aperture applicators"
        WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
        SMFX2(I),SMFY2(I);
        ]
    ELSEIF (ISMFPS(I) = 11) ["model for tubular applicators"
        WRITE(1,*)SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
        SMFX2(I),SMFY2(I);
        ]
    ELSEIF (ISMFPS(I) = 2) ["model for collimators"
        WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
        SMFX2(I),SMFY2(I),SMFPXY(I);
        ]
    ELSEIF(ISMFPS(I) = 3) ["model for ring, cone, and point source"
        WRITE(1,*)SMFMNZ(I),SMFMNR(I),SMFMXR(I),RSSD1;
        ]
    ELSEIF(ISMFPS(I) = 4) ["model for rectangular plane source"
        WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I);
        ]
    ELSEIF(ISMFPS(I) = 5) ["model for circular plane source"
        WRITE(1,*)SMFMNZ(I),SMFMNR(I);
        ]
    ]"end of output for each sub-source"

" Write the number of energy distributio bins, minimum and maximum energy "
WRITE(1,*)NSMFEE,SMFMNE,SMFMXE;
" Write the energy spectrum type "
WRITE(1,*)ESTYPE;
IF(ESTYPE = 0)["Energy spectrum inside/outside the treatment field"
    WRITE(1,*)RTREATe,RFIELDe;
    ]
ELSEIF(ESTYPE = 1)["Energy spectrum with different radii"
    WRITE(1,*)NFIELDe,RFIELDe;
    WRITE(1,*)(ERADII(I),I=1,NFIELDe);
    ]

" Write the field type number "
WRITE(1,*)MSMFXY;
I=1;"we use the same field for all the sub-sources"
IF(MSMFXY = 0)["circular field distribution"
    WRITE(1,*)NFIELDi,RTREAT,NFIELDo,RFIELD;
    ]
ELSEIF(MSMFXY = 1)["square field distribution with symmetrical rings"
    WRITE(1,*)NFIELDi,RTREAT,NFIELDo,RFIELD;
    ]
ELSEIF(MSMFXY = 2)["rectangular field"
    WRITE(1,*)NFIELD,XFLDMN,XFLDMX,YFLDMN,YFLDMX;
    WRITE(1,*)XTREATMN,XTREATMX,YTREATMN,YTREATMX;
    ]

" Write the phase-space file name "
WRITE(1,'(A100)')PSDNAM;

" Write output for each sub-source "
DO I=1,NSMFPS[
    WRITE(1,*)I;
    WRITE(1,*)ISMFPS(I),IQSMFP(I),LATCH(I);
    IF (ISMFPS(I) = 1) ["model for aperture applicators"
        WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
        SMFX2(I),SMFY2(I);
        ]
    ELSEIF (ISMFPS(I) = 11) ["model for tubular applicators"
        WRITE(1,*)SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
        SMFX2(I),SMFY2(I);
        ]
    ELSEIF (ISMFPS(I) = 2) ["model for collimators"
        WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
        SMFX2(I),SMFY2(I),SMFPXY(I);
        ]
    ELSEIF(ISMFPS(I) = 3) ["model for ring, cone, and point source"
        WRITE(1,*)SMFMNZ(I),SMFMNR(I),SMFMXR(I),RSSD1;
        ]
    ELSEIF(ISMFPS(I) = 4) ["model for rectangular plane source"
        WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I);
        ]
    ELSEIF(ISMFPS(I) = 5) ["model for circular plane source"
        WRITE(1,*)SMFMNZ(I),SMFMNR(I);
        ]

    " Write relative sub-source intensity and virtual SSD "
    WRITE(1,*)SMFRTN(I),SSDVPS(I);

    " Write the number of energy distributio bins, minimum and maximum energy "
    WRITE(1,*)NSMFEE,SMFMNE,SMFMXE;
    " Energy spectra within field "
    " for inside/outside the treatment field there are NFIELDe=2 spectra "
    " for different radii there are NFIELDe spectra "
    DO III=1,NFIELDe["
         WRITE(1,*) (FSMFBN1(I,III,II),II=1,NSMFEE);
         ]

    " Write the field fluence type "
    WRITE(1,*)MSMFXY;

    IF(MSMFXY = 0)["circular field distribution"
  WRITE(1,*) NFIELDi,RTREAT,NFIELDo,RFIELD;
  " Write probability for each bin "
  WRITE(1,*)(FSMFRR(I,II),II=1,NFIELD);
  ]
    IF(MSMFXY = 1)["square field distribution with symmetrical rings"
        WRITE(1,*)NFIELDi,RTREAT,NFIELDo,RFIELD;
 " Write probability for each bin "
        WRITE(1,*)(FSMFRR(I,II),II=1,NFIELD);
 " Write parameters used in sampling "
        WRITE(1,*)(FSMFR11(I,II),II=1,NFIELD);
        WRITE(1,*)(FSMFR12(I,II),II=1,NFIELD);
        ]
    ELSEIF(MSMFXY = 2)["rectangular field"
        WRITE(1,*)NFIELD,XFLDMN,XFLDMX;
        WRITE(1,*)NFIELD,YFLDMN,YFLDMX;
        WRITE(1,*)((FSMFXY(I,II,III),II=1,NFIELD),III=1,NFIELD);
        "probability for each bin"
        ]
    ]"end of output for each sub-source"

" Write angular distribution "
WRITE(1,*) (FSMABN1(II),II=1,$NBINANGLE);
CLOSE(UNIT=1,STATUS='KEEP');

IF(CHOICE = 1)[GOTO :STOP-FOR-GOOD:;]

:OPEN-PH-SP-FILE:;
CALL OPENFILE;

CALL READ_PHSP;

CLOSE (2); "Close the ph-sp file"

OUTPUT;(/' BEGIN SUMMARISING THE PH-SP DATA.....');

" Summarize phase space data just read"
" ************************************"

IF(N_ph_sp_e ~= 0)[E_ph_sp_e = E_ph_sp_e/N_ph_sp_e; "average"]
IF(N_ph_sp_g ~= 0)[E_ph_sp_g = E_ph_sp_g/N_ph_sp_g; "average"]
IF(N_ph_sp_p ~= 0)[E_ph_sp_p = E_ph_sp_p/N_ph_sp_p; "average"]
WRITE(6,'(/T10,''INFORMATION ABOUT THE FULL PHASE SPACE DATA ''//
           '' Read total''
     ,I10,'' particles and ignored'',I6,'' multiple passers'')')
     N_ph_sp_e+N_ph_sp_g+N_ph_sp_p,NPASS_ph_sp;
WRITE(6,'(/'' There were'',I10,'' electrons with average energy'',
     T55, F9.4,'' MeV'')') N_ph_sp_e,E_ph_sp_e;
WRITE(6,'(/'' There were'',I10,'' photons with average energy'',
     T55, F9.4,'' MeV'')') N_ph_sp_g,E_ph_sp_g;
WRITE(6,'(/'' There were'',I10,'' positrons with average energy'',
     T55, F9.4,'' MeV'')') N_ph_sp_p,E_ph_sp_p;
WRITE(6,'(/'' Minimum / maximum particle energies were'',
 F9.3,'' /'',F9.3,'' MeV'')') E_MIN_ph_sp,E_MAX_ph_sp;

OUTPUT K4,(K1+K2+K3),K1,K2,K3,NWRONG;
(/'           ',I10,' PARTICLES SCORED FOR ENERGY/FLUENCE DISTRIBUTIONS'
 /'           ',I10,' PARTICLES IGNORED BECAUSE LATCH # ARE NOT SET'
 /'           ',I10,' OF THEM ARE ELECTRONS'
 /'           ',I10,' OF THEM ARE PHOTONS, AND'
 /'           ',I10,' OF THEM ARE POSITRONS'
 /'  ALSO     ',I10,' PARTICLES NOT SCORED DUE TO OUT OF THE FIELD');

DO I=1,NSMFPS[

    IF(ISMFPS(I) = 3)&(SMFMNR(I) = 0.0)["check for point source only"
        III=0;
        DO IIII=1,$ND[
          IF(RSSDST(I,IIII) ~= 0.0)&(III = 0)[III=1;]
        ]
        IF(III = 0)[
            OUTPUT I;
        (/' No particles from source ',I4,' falling into the ring.'/
        ' Was the radius of the ring outside of the field?'/
        '   '/
        ' The SSD for the point source has been taken to be 100 cm.'/
        ' However, you can try again with a different ring radius.');
            IF(IQSMFP(I) = -1)[SSDVPS($NS+1)=100.;]
            ELSEIF(IQSMFP(I) = 0)[SSDVPS($NS+2)=100.;]
            ELSEIF(IQSMFP(I) = 1)[SSDVPS($NS+3)=100.;]
            GOTO :NO-PARTICLES-DETECTED:;
            ]
        DO II=1,3["smooth the distribution 4 times"
            DO IIII=3,1998["using weighted smoothing"
                SSSDST(I,IIII)=RSSDST(I,IIII)*0.3+
                           RSSDST(I,IIII-1)*0.25+RSSDST(I,IIII+1)*0.25+
                           RSSDST(I,IIII-2)*0.1+RSSDST(I,IIII+2)*0.1;
                ]
            DO IIII=3,1998[
               RSSDST(I,IIII)=SSSDST(I,IIII);
               ]
            J=1;
            DO IIII=2,2000[
                IF(II = 1)[
                    "weight the distribution by the radius (=IIII/10)"
                    RSSDST(I,IIII)=10.*RSSDST(I,IIII)/FLOAT(IIII);
                    ]
                IF(RSSDST(I,IIII) >= RSSDST(I,J))[
                    J=IIII;"find the maximum of the image radius (times 10)"
                    ]
                ]
            ]
        DO IIII=J-10,J+10["further smooth the distribution around the maximum"
            DO III=1,10["subdivide each region into 10 regions"
               RSSDST(I,IIII*10+III)=RSSDST(I,IIII+1);
               ]
            ]
         J=(J-8)*10;
         DO JJ=1,3["further smooth 4 times"
             IF(JJ ~= 1) J=J-80;
             DO IIII=J,J+160[
                SSSDST(I,IIII)=RSSDST(I,IIII)*0.05+
                           RSSDST(I,IIII-1)*0.04+RSSDST(I,IIII+1)*0.04+
                           RSSDST(I,IIII-2)*0.035+RSSDST(I,IIII+2)*0.035+
                           RSSDST(I,IIII-3)*0.03+RSSDST(I,IIII+3)*0.03+
                           RSSDST(I,IIII-4)*0.025+RSSDST(I,IIII+4)*0.025+
                           RSSDST(I,IIII-5)*0.025+RSSDST(I,IIII+5)*0.025+
                           RSSDST(I,IIII-6)*0.025+RSSDST(I,IIII+6)*0.025+
                           RSSDST(I,IIII-7)*0.025+RSSDST(I,IIII+7)*0.025+
                           RSSDST(I,IIII-8)*0.025+RSSDST(I,IIII+8)*0.025+
                           RSSDST(I,IIII-9)*0.025+RSSDST(I,IIII+9)*0.025+
                           RSSDST(I,IIII-10)*0.02+RSSDST(I,IIII+10)*0.02+
                           RSSDST(I,IIII-11)*0.02+RSSDST(I,IIII+11)*0.02+
                           RSSDST(I,IIII-12)*0.02+RSSDST(I,IIII+12)*0.02+
                           RSSDST(I,IIII-13)*0.02+RSSDST(I,IIII+13)*0.02+
                           RSSDST(I,IIII-14)*0.02+RSSDST(I,IIII+14)*0.02+
                           RSSDST(I,IIII-15)*0.02+RSSDST(I,IIII+15)*0.02+
                           RSSDST(I,IIII-16)*0.02+RSSDST(I,IIII+16)*0.02+
                           RSSDST(I,IIII-17)*0.02+RSSDST(I,IIII+17)*0.02+
                           RSSDST(I,IIII-18)*0.02+RSSDST(I,IIII+18)*0.02+
                           RSSDST(I,IIII-19)*0.02+RSSDST(I,IIII+19)*0.02+
                           RSSDST(I,IIII-20)*0.02+RSSDST(I,IIII+20)*0.02;
                ]
            DO IIII=J,J+160[
                RSSDST(I,IIII)=SSSDST(I,IIII);
                IF(RSSDST(I,IIII) >= RSSDST(I,J))J=IIII;
                ]
            ]

        ZTOTAL(I)=DELTAZ*(RSSD1+RSSD0)/2./(FLOAT(J)/100.-(RSSD1+RSSD0)/2.);

        IF(ZTOTAL(I) > 1.0E+30)[
            OUTPUT;
        (///' The particles are incident along Z-axis. Is it a parallel'/
        ' beam or the radius of the ring close to zero?'/
        '   '/
        ' The SSD for the point source has been taken to be 1.0E+30 cm.'/
        ' However, you can try again with a different ring radius.'//);
            IF(IQSMFP(I) = -1)[SSDVPS($NS+1)=1.0E+30;]
            ELSEIF(IQSMFP(I) = 0)[SSDVPS($NS+2)=1.0E+30;]
            ELSEIF(IQSMFP(I) = 1)[SSDVPS($NS+3)=1.0E+30;]
            ]
        ELSE[
            OUTPUT I,ZTOTAL(I);
        (/' The virtual SSD for source',I4,' is',F7.1,' cm '/
        ' according to the full ph-sp data.'/);
            IF(IQSMFP(I) = -1)[SSDVPS($NS+1)=ZTOTAL(I);]
            ELSEIF(IQSMFP(I) = 0)[SSDVPS($NS+2)=ZTOTAL(I);]
            ELSEIF(IQSMFP(I) = 1)[SSDVPS($NS+3)=ZTOTAL(I);]
            ]
        ;:NO-PARTICLES-DETECTED:;
        ]
    ]"end of calculating SSD for each of the point sources"

IF(MSMFXY = 1)[   "square field distribution with symmetrical rings"
   DO I=1,NSMFPS[ "ESTIMATE INVERSE-SQUARE RATIO FOR THE PARTICLES IN A BIN"
      FSMFR11(I,1)=1.;FSMFR12(I,1)=0.;

      DO II=2,NFIELD[
         " We have different bin sizes, RBin depends on it "
  IF(II<=NFIELDi) [
     RBin=RTREAT**2*(FLOAT(II)/FLOAT(NFIELDi));
     ]
  ELSE [
     RBin=(RFIELD**2-RTREAT**2)*(FLOAT(II-NFIELDi)/FLOAT(NFIELDo))+
   RTREAT**2;
     ]

         IF(FSMFR1(I,II)<FSMFR2(I,II))&(FSMFR2(I,II)>0.)[
             IF(FSMFR1(I,II)+FSMFR2(I,II) <= 10.)[
                FSMFR11(I,II)=1.;FSMFR12(I,II)=0.;
                ]
             ELSE[
                FSMFR11(I,II)=(7.*FSMFR1(I,II)-FSMFR2(I,II))/
                           (11.*FSMFR2(I,II)-5.*FSMFR1(I,II));
                FSMFR12(I,II)=12.*(FSMFR1(I,II)-FSMFR2(I,II))/
                           (11.*FSMFR2(I,II)-5.*FSMFR1(I,II))/RBin;
                ]
             ]
         ELSEIF(FSMFR2(I,II)<=FSMFR1(I,II))&(FSMFR1(I,II)>0.)[
             IF(FSMFR1(I,II)+FSMFR2(I,II) <= 10.)[
                FSMFR11(I,II)=1.;FSMFR12(I,II)=0.;
                ]
             ELSE[
                FSMFR11(I,II)=1.;
                FSMFR12(I,II)=12.*(FSMFR1(I,II)-FSMFR2(I,II))/
                           (7.*FSMFR1(I,II)-FSMFR2(I,II))/RBin
                ]
             ]
         ]
      ]
   ]


"Throw in some defaults in case the user does not have point sources"

IF(SSDVPS($NS+1)=0.)[
   OUTPUT;(//' ***WARNING:'/
        ' You have not defined a virtual point source for e-'/
        ' However, the SSD of this source may be used in some calculations.'/
        ' A value of 100cm will be assumed.'//);
   SSDVPS($NS+1)=100.
]
IF(SSDVPS($NS+2)=0.)[
   OUTPUT;(//' ***WARNING:'/
         ' You have not defined a virtual point source for photons'/
         ' However, the SSD of this source may be used in some calculations.'/
         ' A value of 100cm will be assumed.'//);
   SSDVPS($NS+2)=100.
]

DO I=1,NSMFPS[
   IF(IQSMFP(I) =  -1)[SSDVPS(I)=SSDVPS($NS+1);]
   ELSEIF(IQSMFP(I) =  0)[SSDVPS(I)=SSDVPS($NS+2);]
   ELSEIF(IQSMFP(I) =  1)[
      IF(SSDVPS($NS+3) =  0.)[SSDVPS(I)=SSDVPS($NS+1);]
      ELSE[SSDVPS(I)=SSDVPS($NS+3);]
      ]
   ]

OUTPUT;(/' BEGIN OUTPUTING DATA.....');

"OUTPUT ANALYSED DATA"
"********************"

"Open source parameter output file"
OPEN(UNIT=1,STATUS='UNKNOWN',FILE=SPCNAM);

WRITE(1,'(A80)')SSMFPS; "detailed descriptions of the source"
WRITE(1,*)NSMFPS; "number of sub-sources for the source model"

" Write output for each sub-source "
DO I=1,NSMFPS[
    WRITE(1,*)ISMFPS(I),IQSMFP(I),LATCH(I);
    IF (ISMFPS(I) = 1) ["model for aperture applicators"
        WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
        SMFX2(I),SMFY2(I);
        ]
    ELSEIF (ISMFPS(I) = 11) ["model for tubular applicators"
        WRITE(1,*)SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
        SMFX2(I),SMFY2(I);
        ]
    ELSEIF (ISMFPS(I) = 2) ["model for collimators"
        WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
        SMFX2(I),SMFY2(I),SMFPXY(I);
        ]
    ELSEIF (ISMFPS(I) = 3) ["model for ring, cone, and point source"
        IF(SMFMNZ(I) ~= SSDVPS(I))&(SMFMNR(I) = 0.0)[
            "re-set SSD for the source"
            OUTPUT I,SMFMNZ(I),SSDVPS(I);
            (/' SSD FOR SUB-SOURCE',I4,' HAS BEEN RE-SET FROM',F7.1,
            ' cm TO',F7.1,' cm'/' ACCORDING TO THE PHASE-SPACE DATA.');
            SMFMNZ(I)=SSDVPS(I);
            ]
        WRITE(1,*)SMFMNZ(I),SMFMNR(I),SMFMXR(I),RSSD1;
        ]
    ELSEIF (ISMFPS(I) = 4) ["model for rectangular plane source"
        WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I);
        ]
    ELSE ["model for circular plane source"
        WRITE(1,*)SMFMNZ(I),SMFMNR(I);
        ]
    ]"end of output for each sub-source"

" Write the number of energy distributio bins, minimum and maximum energy "
WRITE(1,*)NSMFEE,SMFMNE,SMFMXE;

" Write the energy spectrum type "
WRITE(1,*)ESTYPE;
IF(ESTYPE = 0)["Energy spectrum inside/outside the treatment field"
    WRITE(1,*)RTREATe,RFIELDe;
    ]
ELSEIF(ESTYPE = 1)["Energy spectrum with different radii"
    WRITE(1,*)NFIELDe,RFIELDe;
    WRITE(1,*)(ERADII(I),I=1,NFIELDe);
    ]

" Write the field type number "
WRITE(1,*)MSMFXY;
I=1;"we use the same field for all the sub-sources"
IF(MSMFXY = 0)["circular field distribution with symmetrical rings"
    WRITE(1,*)NFIELDi,RTREAT,NFIELDo,RFIELD;
    ]
ELSEIF(MSMFXY = 1)["square field distribution with symmetrical square rings"
    WRITE(1,*)NFIELDi,RTREAT,NFIELDo,RFIELD;
    ]
ELSEIF(MSMFXY = 2)["rectangular field"
    WRITE(1,*)NFIELD,XFLDMN,XFLDMX,YFLDMN,YFLDMX;
    WRITE(1,*)XTREATMN,XTREATMX,YTREATMN,YTREATMX;
    ]

" Write the phase-space file name "
WRITE(1,'(A100)')PSDNAM;

" Write output for each sub-source "
DO I=1,NSMFPS[
    WRITE(1,*)I;
    WRITE(1,*)ISMFPS(I),IQSMFP(I),LATCH(I);
    IF (ISMFPS(I) = 1) ["model for aperture applicators"
        WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
        SMFX2(I),SMFY2(I);
        ]
    ELSEIF (ISMFPS(I) = 11) ["model for tubular applicators"
        WRITE(1,*)SMFMNZ(I),SMFMXZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
        SMFX2(I),SMFY2(I);
        ]
    ELSEIF (ISMFPS(I) = 2) ["model for collimators"
        WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I),
        SMFX2(I),SMFY2(I),SMFPXY(I);
        ]
    ELSEIF (ISMFPS(I) = 3) ["model for ring, cone, and point source"
        IF(SMFMNZ(I) ~= SSDVPS(I))&(SMFMNR(I) = 0.0)[
            "re-set SSD for the source"
            OUTPUT I,SMFMNZ(I),SSDVPS(I);
            (//' SSD FOR SUB-SOURCE',I4,' HAS BEEN RE-SET FROM',F7.1,
            ' cm TO',F7.1,' cm ACCORDING TO THE PH-SP DATA.'//);
            SMFMNZ(I)=SSDVPS(I);
            ]
        WRITE(1,*)SMFMNZ(I),SMFMNR(I),SMFMXR(I),RSSD1;
        ]
    ELSEIF (ISMFPS(I) = 4) ["model for rectangular plane source"
        WRITE(1,*)SMFMNZ(I),SMFMNX(I),SMFMXX(I),SMFMNY(I),SMFMXY(I);
        ]
    ELSE ["model for circular plane source"
        WRITE(1,*)SMFMNZ(I),SMFMNR(I);
        ]

    " Calculate relative sub-source intensity "
    SMFRTN(I)=SMFRTN(I)/KWEI;"this is the relative source intensity"

    " Write relative sub-source intensity and virtual SSD "
    WRITE(1,*)SMFRTN(I),SSDVPS(I);

    " Write the number of energy distributio bins, minimum and maximum energy "
    WRITE(1,*)NSMFEE,SMFMNE,SMFMXE;
    " Energy spectra within field "
    " for inside/outside the treatment field there are NFIELDe=2 spectra "
    " for different radii there are NFIELDe spectra "
    DO III=1,NFIELDe["
         WRITE(1,*) (FSMFBN1(I,III,II),II=1,NSMFEE);
         ]

    " Write the field fluence type "
    WRITE(1,*)MSMFXY;

    IF(MSMFXY = 0)["circular field distribution"
        WRITE(1,*)NFIELDi,RTREAT,NFIELDo,RFIELD;
  " Write probability for each bin "
        WRITE(1,*)(FSMFRR(I,II),II=1,NFIELD);
        ]
    ELSEIF(MSMFXY = 1)["square field distribution with symmetrical rings"
        WRITE(1,*)NFIELDi,RTREAT,NFIELDo,RFIELD;
 " Write probability for each bin "
        WRITE(1,*)(FSMFRR(I,II),II=1,NFIELD);
 " Write parameters used in sampling "
        WRITE(1,*)(FSMFR11(I,II),II=1,NFIELD);
        WRITE(1,*)(FSMFR12(I,II),II=1,NFIELD);
        ]
    ELSEIF(MSMFXY = 2)["rectangular field"
        WRITE(1,*)NFIELD,XFLDMN,XFLDMX;
        WRITE(1,*)NFIELD,YFLDMN,YFLDMX;
        WRITE(1,*)((FSMFXY(I,II,III),II=1,NFIELD),III=1,NFIELD);
        "probability for each bin"
        ]
    ]"end of output for each sub-source"
    III=1;
    DO II=2,$NBINANGLE["find maximum value FOR ANGULAR DISTRIBUTION"
       IF(FSMABN1(II) > FSMABN1(III))[III=II;]
       ]
    DO II=1,$NBINANGLE["now, normalize it"
       IF(FSMABN1(III)>0)["prevents NaN for photon only beams"
         IF(II ~= III)FSMABN1(II)=FSMABN1(II)/FSMABN1(III);
       ]
       IF(II = $NBINANGLE)FSMABN1(III)=1.;
       ]
    WRITE(1,*)(FSMABN1(II),II=1,$NBINANGLE);
CLOSE(UNIT=1,STATUS='KEEP');

:DATA-FOR-GRAPH-PLOTTING:;

" Plot characteristics of source model "
" ------------------------------------ "
IF(CHOICE > 2)[

    DO I=1,NFIELD[
      IF (I <= NFIELDi)[
  BINSIZE(I)=RTREAT**2/(FLOAT(NFIELDi));
  ]
      ELSE[
  BINSIZE(I)=(RFIELD**2-RTREAT**2)/(FLOAT(NFIELDo));
  ]
    ]

    DO I=1,NSMFPS[
        III=1;IIIII=1;
        DO II=1,NFIELD["find maximum planar fluence value"

           IF(MSMFXY = 0)|(MSMFXY = 1)[
        " Bins are not of the equal areas "
               " so, find # of particles/unit area "
               IF(FSMFRR(I,II)/BINSIZE(II) > FSMFRR(I,III)/BINSIZE(III))[
    III=II;
    ]
               ]
           ELSEIF(MSMFXY = 2)[
               DO IIII=1,NFIELD[
                  IF(FSMFXY(I,II,IIII) > FSMFXY(I,III,IIIII))[
                     III=II;IIIII=IIII;
                     ]
                  ]
               ]
           ]

 " Normalize to the maximum value "
        DO II=1,NFIELD[
           IF(MSMFXY = 0)|(MSMFXY = 1)[
               IF(FSMFRR(I,III) ~= 0.)[
                  IF(II ~= III)FSMFRR(I,II)=FSMFRR(I,II)/FSMFRR(I,III);
                  IF(II = NFIELD)FSMFRR(I,III)=1.;
                  ]
               ]
           ELSEIF(MSMFXY = 2)[
               DO IIII=1,NFIELD[
                  IF(FSMFXY(I,III,IIIII) ~= 0.)[
                     IF((II ~= III) | (IIII ~= IIIII))[
                         FSMFXY(I,II,IIII)=FSMFXY(I,II,IIII)/
                         FSMFXY(I,III,IIIII);
                         IF((II = NFIELD) & (IIII = NFIELD))
                         FSMFXY(I,III,IIIII)=1.;
                      "   WRITE(6,*)III,IIIII,FSMFXY(I,II,IIII);"
                         ]
                     ]
                  ]
               ]
           ]

 " Loop over bins and find maximum energy value "
        DO IIII=1,NFIELDe[
           III=1; " At the beginning set this one as the highest "
           DO II=2,NSMFEE[ " start from the second one "
              IF(FSMFBN1(I,IIII,II) > FSMFBN1(I,IIII,III))[
          III=II; " new highest value "
   ]
              ]
           DO II=1,NSMFEE[
              IF(II ~= III)
   FSMFBN1(I,IIII,II)=FSMFBN1(I,IIII,II)/FSMFBN1(I,IIII,III);
              IF(II = NSMFEE)
   FSMFBN1(I,IIII,III)=1.;
              ]
           ]
        ] " end of loop "

    OUTPUT;(//'Name of file to save data for graph plotting:'/' ',$);
    INPUT SPCNAM;(A80);
    OUTPUT SPCNAM;(' File name input is:', A80);
    OPEN(UNIT=3,STATUS='UNKNOWN',FILE=SPCNAM);

    MSTART=-1;
    :PLOTTING-DATA:;

    TEEE=0.;TPPP=0.;

    " For each sub-source "
    DO I=1,NSMFPS[
        TENERGY=0.0;
        TPARTICLE=0;
        :MODEL_GRAPH_TYPE:

 OUTPUT I,IQSMFP(I);
 (/' PLOT ENERGY/PLANAR FLUENCE FOR SOURCE',I3,' (CHARGE=',I3,')?'/);
 OUTPUT;(' (0) - No');
 IF(ESTYPE = 0) [
    OUTPUT;(' (1) - E inside treatment field');
    OUTPUT;(' (2) - E outside treatment field');
    ]
 ELSE [
    OUTPUT;(' (3) - E annulus');
    ]
 OUTPUT;(' (4) - Fluence');

        INPUT CHOICE;(I8);

        IF((CHOICE=1 & ESTYPE=1) | (CHOICE=2 & ESTYPE=1))[
           OUTPUT;(//' Not a valid energy option with this field type.'/
                     ' Try again.'//);
           GOTO :MODEL_GRAPH_TYPE:;
           ]
        ELSEIF(CHOICE=3 & ESTYPE=0)[
           OUTPUT;(//' You must have different energy spectra to'/
                     ' plot energy in an arbitrary radial bin.'/
                     ' Try again.'//);
           GOTO :MODEL_GRAPH_TYPE:;
           ]
        ELSEIF(CHOICE ~= 0)[
           MSTART=MSTART+1;"graph number + 1"
           ]

        IF(CHOICE = 1)|(CHOICE = 2)|(CHOICE = 3)[
     IF(CHOICE = 1)[
        II=1;
        ]
     ELSEIF(CHOICE = 2)[
        II=2;
        ]
     ELSEIF(CHOICE = 3)[
        LOOP[
    OUTPUT NFIELDe;(' There are ',I3,' different annuluses');
                  OUTPUT;(' Input the number of the annulus: ',$);
                  INPUT II; (I3);
        ] UNTIL (II>0)&(II<=NFIELDe);
     ]

            GRAPHTITLE='spectral distribution';
            YTITLE='relative particles/bin';
            XTITLE='energy /MeV';
            DO III=1,NSMFEE[
                XPLOT(III)=SMFMXE*FLOAT(III)/FLOAT(NSMFEE);
                YPLOT(III)=0;
                IF(FSMFBN1(I,II,III)>0) YPLOT(III)=FSMFBN1(I,II,III);
                ERRYPLOT(III)=0.;
                TENERGY=TENERGY+YPLOT(III)*XPLOT(III);
                TPARTICLE=TPARTICLE+YPLOT(III);
            ]
            IF(TPARTICLE>0)[
               OUTPUT TENERGY/TPARTICLE;
               (/' MEAN E FOR THIS SOURCE INSIDE TREATMENT FIELD=',F10.3,'MeV');
               TEEE=TEEE+TENERGY/TPARTICLE*SMFRTN(I);
               TPPP=TPPP+SMFRTN(I);
            ]
            ELSE[
              OUTPUT;(/' NO PARTICLES FROM THIS SOURCE INSIDE TREATMENT FIELD');
            ]
            IF(TPPP>0)[
              OUTPUT TEEE/TPPP;
              (/' MEAN E FOR ALL THE PARTICLES (SO FAR)=',F10.3,'MeV');
            ]
            HXMIN=SMFMNE;ITYPE=1;
            SERIESTITLE(1:7)='SOURCE';
            SERIESTITLE(8:9)=LETTER2(I);
            SERIESTITLE(10:15)=' IQ =';
            SERIESTITLE(16:17)=LETTER1(IQSMFP(I)+2);
     " Diffrenet aoutput for this three cases "
     IF(CHOICE = 1)[
               SERIESTITLE(18:60)=' IN TREATMENT FIELD';
        ]
     ELSEIF(CHOICE = 2)[
        SERIESTITLE(18:60)=' OUTSIDE TREATMENT FIELD';
        ]
     ELSEIF(CHOICE = 3)[
        IF(II=1)[
    SERIESTITLE(18:60)=' IN R = 0.00 - '
    //LETTER2(INT(ERADII(II)))//'.'
    //LETTER2(INT(100*(ERADII(II)-INT(ERADII(II)))));
        ]
        ELSE [
    SERIESTITLE(18:60)=' IN R = '
    //LETTER2(INT(ERADII(II-1)))//'.'
    //LETTER2(INT(100*(ERADII(II-1)-INT(ERADII(II-1)))))//' - '
    //LETTER2(INT(ERADII(II)))//'.'
    //LETTER2(INT(100*(ERADII(II)-INT(ERADII(II)))));
    ]
        ]
            CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NSMFEE,MSTART,
            SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
 ]

        ELSEIF(CHOICE = 4)[
            GRAPHTITLE='planar fluence distribution';
            YTITLE='relative particles/bin';
            ITYPE=1;
            SERIESTITLE(1:20)='PLANAR-F FOR SOURCE';
            SERIESTITLE(21:23)=LETTER2(I);
            SERIESTITLE(24:28)=' IQ =';
            SERIESTITLE(29:60)=LETTER1(IQSMFP(I)+2);
            IF(MSMFXY = 0)[
        XTITLE='radius /cm';
        ]
            ELSEIF(MSMFXY = 1)[
        XTITLE='half-side /cm';
        ]
            ELSEIF(MSMFXY = 2)[
               OUTPUT NFIELD;
               (' ORIENTATION (0: ALONG X, 1: Y), BIN NUMBER (1 - ',I3,'):'
               /' ',$);
               INPUT II,III;(2I8);
               IF(II = 0)[
                  XTITLE='X /cm ';HXMIN=XFLDMN;
                  SERIESTITLE(32:40)=' Y-BIN #:';
                  SERIESTITLE(41:60)=LETTER2(III);
               ]
               ELSEIF(II = 1)[
                  XTITLE='Y /cm ';HXMIN=YFLDMN;
                  SERIESTITLE(32:40)=' X-BIN #:';
                  SERIESTITLE(41:60)=LETTER2(III);
               ]
            ]
            IF(MSMFXY = 0)|(MSMFXY = 1)[
               DO II=1,NFIELDi[
                  XPLOT(II)=RTREAT*SQRT((FLOAT(II))/(FLOAT(NFIELDi)));
                  YPLOT(II)=FSMFRR(I,II);
                  ERRYPLOT(II)=0.;HXMIN=0;"minimum R/half-side = 0"
               ]
               DO II=NFIELDi+1,NFIELD[
    XPLOT(II)=SQRT(((RFIELD**2-RTREAT**2)*
     ((FLOAT(II-NFIELDi))/(FLOAT(NFIELDo))))+RTREAT**2);
    " Not equal areas, divide the area of RTREAT region "
    " with the area of RFIELD region "
     YPLOT(II)=FSMFRR(I,II)*(((RTREAT**2/FLOAT(nFIELDi)))/
   ((RFIELD**2-RTREAT**2)/FLOAT(NFIELDo)));
                  ERRYPLOT(II)=0.;HXMIN=0;"minimum R/half-side = 0"
               ]
            ]
            ELSEIF(MSMFXY = 2)["rectangular field"
               IF(II = 0)["along x"
                  DO II=1,NFIELD[
                     XPLOT(II)=(XFLDMN+(XFLDMX-XFLDMN)*FLOAT(II)/
                               FLOAT(NFIELD));
                     YPLOT(II)=FSMFXY(I,II,III);
                     ERRYPLOT(II)=0.;
                     WRITE(6,*)XFLDMN,XFLDMX,XPLOT(II),YPLOT(II);
                  ]
               ]
               ELSEIF(II = 1)["along y"
                  DO II=1,NFIELD[
                     XPLOT(II)=(YFLDMN+(YFLDMX-YFLDMN)*FLOAT(II)/
                               FLOAT(NFIELD));
                     YPLOT(II)=FSMFXY(I,III,II);
                     ERRYPLOT(II)=0.;
                     WRITE(6,*)YFLDMN,YFLDMX,XPLOT(II),YPLOT(II);
                  ]
               ]
            ]
            CALL XVGRPLOT(XPLOT,YPLOT,ERRYPLOT,NFIELD,MSTART,
            SERIESTITLE,XTITLE,YTITLE,GRAPHTITLE,PSDNAM,3,ITYPE,HXMIN,0);
        ]"end of choice=3"
    ]"END OF LOOP FOR EACH SOURCE"

    OUTPUT;(/' PLOT ANOTHER ENERGY/PLANAR FLUENCE INTO THE SAME FILE?'/
             ' (Note: energy and fluence should be in separate file!)'/);
    OUTPUT;( ' INPUT (1) TO CONTINUE OR (0) TO QUIT:'/' ',$);
    INPUT CHOICE;(I8);
    IF(CHOICE = 1) [
        GOTO :PLOTTING-DATA:;
    ]
    CLOSE(UNIT=3,STATUS='KEEP');
    CALL XVGR_SCRIPT;
]
:STOP-FOR-GOOD:;

OUTPUT;(/' WOULD YOU LIKE TO RUN THIS PROGRAMME AGAIN?');
OUTPUT;(/' INPUT (1) TO CONTINUE OR (0) TO QUIT:'/' ',$);
INPUT CHOICE;(I8);
IF(CHOICE = 1) [
    EGSPERT = .true.; "Turn off wordy prompts for first-time users"
    GOTO :START-CHOICE1-0:;
    ]

RETURN;
END; "End of SUBROUTINE BEAMDP1"

%L
!LABELS 7000;
%Q1
%C80
%I4
%E
%B132
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
"*******************************************************************************
SUBROUTINE READ_PHSP;
"
" THIS IS A SUBROUTINE USED BY BEAMDP TO READ DATA FROM A PHASE-SPACE FILE.
"
" PROGRAMMER C-M MA
"
"*******************************************************************************

"**VARIABLES**"

"---Force declarations of all variables---"
IMPLICIT NONE;

COMIN/CHARACTERS;
COMIN/DOUBLES;
COMIN/REALS;
COMIN/INTEGERS;
COMIN/LOGICALS;
COMIN/RWPHSP/;

i_log=6;

"initialize counters"
E_MIN_ph_sp = 1000.0;
E_MAX_ph_sp = 0.0;
RSSD0=RSSD1-RSSD1/40.;"the inner radius of the ring for SSD analysis"
RSSD02=RSSD0*RSSD0;RSSD12=RSSD1*RSSD1;"we need the squares for later use"
DO III=1,$ND[
    DO IIII=1,$NS[
        RSSDST(IIII,III)=0.0;
        ]
    ]
DO III=1,$NBINANGLE[
    FSMABN1(III)=0.0;"ANGULAR DISTRIBUTION:
    ]
DO III=1,NSMFPS[
    SMFRTN(III)=0.0;
    DO IIII=1,NFIELD[
        FSMFRR(III,IIII)=0.0;
        FSMFXX(III,IIII)=0.0;
        FSMFYY(III,IIII)=0.0;
        DO IIIII=1,NFIELD[FSMFXY(III,IIII,IIIII)=0.0;]
        ]
    DO IIII=1,NSMFEE[
        DO IIIII=1,NFIELD[
            FSMFBN1(III,IIIII,IIII)=0.0;
            ]
        ]
    ]
/N_ph_sp_e,N_ph_sp_g,N_ph_sp_p,NPASS_ph_sp/=0;
/E_ph_sp_e,E_ph_sp_g,E_ph_sp_p,E_MAX_ph_sp/=0.0;
E_MIN_ph_sp = 1000.0;

"calculate constants for later use"
SFACTOR=FLOAT(NSMFEE)/SMFMXE;
SSFACTOR=FLOAT($NBINANGLE)/$MAXANGLE;
IF(RFIELD = 0.0)&(MSMFXY ~= 2)
[RFIELD=0.0001;OUTPUT;(/' RADIUS RE-SET TO 0.0001 CM');]

IF(RFIELD = 0.)[RFACTOR=FLOAT(NFIELD);]
ELSE[RFACTOR=FLOAT(NFIELD)/(RFIELD**2);]

RFACTOR1 = FLOAT(NFIELDi)/(RTREAT**2);
RFACTOR2 = FLOAT(NFIELDo)/(RFIELD**2-RTREAT**2);

IF((YFLDMX-YFLDMN) = 0.)[Y=FLOAT(NFIELD);]
ELSE[Y=FLOAT(NFIELD)/(YFLDMX-YFLDMN);]
IF((XFLDMX-XFLDMN) = 0.)[X=FLOAT(NFIELD);]
ELSE[X=FLOAT(NFIELD)/(XFLDMX-XFLDMN);]

:READING-PH-SP-FILE:;

OUTPUT;(/' BEGIN READING PH-SP DATA .....');

IPARANOT=1; "START WITH THE FIRST PARTICLE IN FILE"
NHSTRY=0;"no. of primary histories"

LOOP["read phase-space data from the data file"

    ;:start-of-file-read:;

    IPARANOT=IPARANOT+1;"NOTE THE SECOND RECORD STORES THE FIRST PARTICLE"
    IF(IPARANOT = PARANOT+2)["end of file encountered"
        GOTO :end-of-file-read:;
        ]

    IF(i_iaea_in=1)[
        $IAEA_READ_PHSP_RECORD(i_unit_in,NPASSI,NHSTRY,LATCHI,IQ,EI,
              WEIGHT,XIN,YIN,ZIN,UIN,VIN,WIN,ZLAST,MUIDX);
    ]
    ELSE[

    IZLAST1=0;
    IF(MODE_RW='MODE2') IZLAST1=1;
    $READ_PHSP(IZLAST1,2,IPARANOT:NHSTRY,NPASSI,IQ,WIN,ZLAST,LATCHI,
              EI,WEIGHT,XIN,YIN,UIN,VIN);
    ]

    IF (NPASSI ~= 0) [
        NPASS_ph_sp = NPASS_ph_sp + 1;
        GOTO :start-of-file-read:;
        "Discard particles if they or their ancestors have crossed"
        "scoring plane"
        ]

    IF(IQ = -1)[ "We need kinetic energy only"
        EI=EI-0.5109989461;
        N_ph_sp_e = N_ph_sp_e + 1; E_ph_sp_e = E_ph_sp_e+EI;
        ]
    ELSEIF(IQ = 0)[
        N_ph_sp_g = N_ph_sp_g + 1; E_ph_sp_g = E_ph_sp_g+EI;
        ]
    ELSEIF(IQ = +1)[
        EI=EI-0.5109989461;
        N_ph_sp_p = N_ph_sp_p + 1; E_ph_sp_p = E_ph_sp_p+EI;
        ]
    ELSE[
        OUTPUT IQ;(/' Charge of the particle = ',I4,' ???'//
                   ' Never seen this kind of particle!!!'//
                   ' Something must have gone WRONG!!!'/);
        STOP;
        ]
    E_MIN_ph_sp = MIN(E_MIN_ph_sp,EI);
    E_MAX_ph_sp = MAX(E_MAX_ph_sp,EI);

    IF (SMFMNE > E_MIN_ph_sp)[
        OUTPUT IPARANOT-1,IQ,EI,SMFMNE;
              (/' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'/
              ' '/
              '     For particle number', I13, '  of charge',I3/
              '     The (min.) energy read from the PH-SP file= ',F12.5//
              '     is smaller than your input lower limit of', F10.3 /
              '              stopping now                    '/
              ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'/);
        STOP;
        ]
    IF (SMFMXE < E_MAX_ph_sp)[
        OUTPUT IPARANOT-1,IQ,EI,SMFMXE;
              (/' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'/
              ' '/
              '     For particle number', I13, '  of charge',I3/
              '     The (max.) energy read from the PH-SP file= ',F12.5//
              '     is larger than your input upper limit of', F10.3 /
              '              stopping now                    '/
              ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'/);
        STOP;
        ]
    ELSEIF(EI < 0.0)[
        OUTPUT;(/' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'///
              ' '/
              '     THE ENERGY READ FROM THE PH-SP DATA FILE '//
              '       IS SMALLER THAN ZERO, ANYTHING WRONG?  '///
              '              stopping now                    '/
              ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'/);
        STOP;
        ]

   " Processing the ph-sp data "
   " ************************* "

   I=0;II=0;
   LOOP[
   " find out the sub-source where  the particle came from this method is "
   " approximate but good enough for the simplified model.We suppose that "
   " the particle is from the  sub-source ( i.e. a component module, CM), "
   " which is the  nearest to the  scoring plane compared with other CMs, "
   " and  where  the  particle has  been to. We  therefore  ignore  those "
   " particles which have been to a nearer  CM but scattered back to a CM "
   " further away from the  scoring plane and then  scattered back to the "
   " scoring  plane. Their  effects are  supposed  to  be  negligible for "
   " high-energy electron beams.       "

      I=I+1;
      IF(I > NSMFPS)
  GOTO :no-source-found:;
      III=LATCH(K(I));

      IF(III<=0 & IBITS(LATCHI,1,$NS)=0 & IQSMFP(K(I)) = IQ)[
         "this is for photons that do not interact anywhere"
  II=K(I);
  GOTO :found-sub-source:;
  ]
      ELSEIF($BTEST(LATCHI,III))&(IQSMFP(K(I)) = IQ)[
  II=K(I); "the particle is from sub-source II"
  GOTO :found-sub-source:;
  ]
      "Otherwise, go back to check whether the particle is from the next "
      "nearest source."
      ]

;:no-source-found:;

    IF(II = 0)[
        "no sub-source has been found"
        IF(IQ = -1)[K1=K1+1;]
        ELSEIF(IQ = 0)[K2=K2+1;]
        ELSE[K3=K3+1;]
        ]
    GOTO :start-of-file-read:;

;:found-sub-source:;

    X2Y2=XIN*XIN+YIN*YIN;
    IF(ISMFPS(II) = 3)&(SMFMNR(II) = 0.0)[
        IF(X2Y2<RSSD12)&(X2Y2>RSSD02)&(WIN ~= 0.0)[
            "fill in array for the image distribution"
            IF(WIN ~= 0.)[RRFACTOR=DELTAZ/WIN;]ELSE[RRFACTOR=DELTAZ;]
            IIII=INT(10.*SQRT((XIN+RRFACTOR*UIN)*(XIN+RRFACTOR*UIN)+
            (YIN+RRFACTOR*VIN)*(YIN+RRFACTOR*VIN)))+1;
            IF(IIII < 2000)[
                RSSDST(II,IIII)=RSSDST(II,IIII)+WEIGHT;
                ]
            ]
       "fill in array for angular distribution"
       IF(IQ ~= 0)["ONLY FOR CHARGED PARTICLES"
           IF(X2Y2 <= 0.25)["within r = 0.5 cm"
               IA=INT(ACOS(WIN)*SSFACTOR)+1;
               IF((IA <= $NBINANGLE) & (EI >= SMFMXE/2.))[
                   FSMABN1(IA)=FSMABN1(IA)+WEIGHT;
                   ]
               ]
           ]
        ]

    " Circular field "
    " -------------- "
    IF(MSMFXY = 0)[
 " Is particle in the treatment field? "
 IF(X2Y2<=(RTREAT*RTREAT))[
    " Inside the treatment field (RTREAT) we "
    " can have NFIELDi equal area size bins "
    IR=INT(X2Y2*RFACTOR1)+1;
    ]
 " Is particle in the scoring field? "
 ELSEIF(X2Y2<=(RFIELD*RFIELD))[
    " Inside the scoring field (RFIELD) we "
    " can have NFIELDo equal area size bins "
    " This index goes on top of NFILEDi "
    IR=INT((X2Y2-RTREAT**2)*RFACTOR2)+NFIELDi+1;
    ]
 ELSE [
    " This can happen if scoring field in this program "
    " is smaller than scoring field in the phase-space "
    IR = NFIELD + 1;
    ]

 " Check indexes "
        IF(IR > NFIELD) [
            NWRONG=NWRONG+1;
            GOTO :start-of-file-read:;
     ]
 " Fill in field distribution "
        FSMFRR(II,IR)=FSMFRR(II,IR)+WEIGHT;
        ]

    " Square field with square rings "
    " ------------------------------ "
    ELSEIF(MSMFXY = 1)[
 " Is X coordinate inside the treatment field? "
 IF(ABS(XIN) <= RTREAT) [
    " Inside the treatment field (RTREAT) we "
    " can have NFIELDi equal area size bins "
    IX=INT(XIN*XIN*RFACTOR1)+1;
    RBin_X=0.5*SQRT(RTREAT**2*(FLOAT(IX)/FLOAT(NFIELDi)));
    ]
 " Is X coordinate inside the scoring field? "
 ELSEIF(ABS(XIN) <= RFIELD) [
    " Inside the scoring field (RFIELD) we "
    " can have NFIELDo equal area size bins "
    IX=INT((XIN*XIN-RTREAT**2)*RFACTOR2)+NFIELDi+1;
    RBin_X=0.5*SQRT((RFIELD**2-RTREAT**2)*(FLOAT(IX-NFIELDi)/
  FLOAT(NFIELDo))+RTREAT**2);
    ]
 ELSE [
    " This can happen if scoring field in this program "
    " is smaller than scoring field in the phase-space "
    IX = NFIELD + 1;
    ]

 " Is Y coordinate inside the treatment field? "
 IF(ABS(YIN) <= RTREAT) [
    " Inside the treatment field (RTREAT) we "
    " can have NFIELDi equal area size bins "
    IY=INT(YIN*YIN*RFACTOR1)+1;
    RBin_Y=0.5*RTREAT*SQRT(FLOAT(IY)/FLOAT(NFIELDi))
    ]
 " Is Y coordinate inside the scoring field? "
 ELSEIF(ABS(YIN) <= RFIELD) [
    " Inside the scoring field (RFIELD) we "
    " can have NFIELDo equal area size bins "
    IY=INT((YIN*YIN-RTREAT**2)*RFACTOR2)+NFIELDi+1;
    RBin_Y=0.5*SQRT((RFIELD**2-RTREAT**2)*(FLOAT(IY-NFIELDi)/
  FLOAT(NFIELDo))+RTREAT**2);
    ]
 ELSE [
    " This can happen if scoring field in this program "
    " is smaller than scoring field in the phase-space "
    IY = NFIELD + 1;
    ]

 " Check indexes "
 IF((IX > NFIELD) | (IY > NFIELD))[
    NWRONG=NWRONG+1;
    GOTO :start-of-file-read:;
    ]

 IF(IX <= IY)[ "find index"
    FSMFRR(II,IY)=FSMFRR(II,IY)+WEIGHT;
    IF(ABS(XIN) <= RBin_Y)[
       FSMFR1(II,IY)=FSMFR1(II,IY)+WEIGHT;
       "this array will be used to fit a function later"
       "to simulate the variation of planar fluence in a bin"
       ]
    ELSE[
       FSMFR2(II,IY)=FSMFR2(II,IY)+WEIGHT;
       ]
    IF(IX = IY)
       FSMFR2(II,IY)=FSMFR2(II,IY)+WEIGHT;
      "The particles in the corners should be counted twice"
      ]
 ELSE[
    FSMFRR(II,IX)=FSMFRR(II,IX)+WEIGHT;
    IF(ABS(YIN) <= RBin_X)[
       FSMFR1(II,IX)=FSMFR1(II,IX)+WEIGHT;
       ]
    ELSE[
       FSMFR2(II,IX)=FSMFR2(II,IX)+WEIGHT;
       ]
 ]
    ]
    " Rectangular field "
    " ----------------- "
    ELSEIF(MSMFXY = 2)[
        IF((XIN-XFLDMN) >= 0.0)[IX=INT((XIN-XFLDMN)*X)+1;]
        ELSE[IX=0;"to avoid round-off error for minus values close to 0"]
        IF((YIN-YFLDMN) >= 0.0)[IY=INT((YIN-YFLDMN)*Y)+1;]
        ELSE[IY=0;]
        IF((IX > NFIELD) |  (IY > NFIELD))[
            NWRONG=NWRONG+1;
            GOTO :start-of-file-read:;
            ]
        ELSEIF((IX < 1) |  (IY < 1))[
            NWRONG=NWRONG+1;
            GOTO :start-of-file-read:;
            ]
        FSMFXY(II,IX,IY)=FSMFXY(II,IX,IY)+WEIGHT;
        ]

    " Weighted number of particles for this source "
    SMFRTN(II)=SMFRTN(II)+WEIGHT;

    " Fill in each bin of the energy and field planar fluence distribution "
    " -------------------------------------------------------------------- "
    IE=INT(EI*SFACTOR)+1;

    " If the index is bigger than the number of bins ... "
    IF(IE > NSMFEE)
 IE=NSMFEE;

    " Circular field distribution "
    IF(MSMFXY = 0)[
 " In the following loop both type of energy spectrums were covered "
 " Inside/outside because NFIELDe=2 "
 " but also energy spectrum type with different radii "
 DO III=1,NFIELDe [
    IF( SQRT(XIN*XIN+YIN*YIN) <= ERADII(III) ) [
        FSMFBN1(II,III,IE) = FSMFBN1(II,III,IE)+WEIGHT;
       " Done, exit the loop "
       EXIT;
       ]
    ]
        ]
    " Square field distribution with symmetrical rings "
    ELSEIF(MSMFXY = 1)[
 " In the following loop both type of energy spectrums were covered "
 " Inside/outside because NFIELDe=2 "
 " but also energy spectrum type with different radii "
 DO III=1,NFIELDe [
    IF((ABS(XIN) <= ERADII(III)) & (ABS(YIN) <= ERADII(III))) [
       FSMFBN1(II,III,IE) = FSMFBN1(II,III,IE)+WEIGHT;
       " Done, exit the loop "
       EXIT;
       ]
    ]
 ]
    " Rectangular field "
    ELSEIF(MSMFXY = 2)[
        IF((XIN <= XTREATMX) & (YIN <= YTREATMX) &
            (XIN > XTREATMN) & (YIN > YTREATMN))[
            FSMFBN1(II,1,IE)=FSMFBN1(II,1,IE)+WEIGHT;
            "energy distribution, within treatment field"
            ]
        ELSE[
            FSMFBN1(II,2,IE)=FSMFBN1(II,2,IE)+WEIGHT;
            "energy distribution, outside treatment field"
            ]
        ]

    K4=K4+1;"total number of particles analyzed for e/f distributions"
    KWEI=KWEI+WEIGHT;"weighted total number of particles analyzed"

    ]"end of read phase-space data loop"

;:end-of-file-read:;

RETURN;
END;

%L
!LABELS 10000;
%Q1
%C80
%I4
%E
%B132
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
"*******************************************************************************
SUBROUTINE READNAME;
"
" THIS IS A SUBROUTINE USED BY BEAMDP TO READ A PHASE-SPACE FILE NAME.
"
" PROGRAMMER C-M MA
"
"*******************************************************************************

"**VARIABLES**"

"---Force declarations of all variables---"
IMPLICIT NONE;

COMIN/CHARACTERS;
COMIN/DOUBLES;
COMIN/REALS;
COMIN/INTEGERS;
COMIN/LOGICALS;

INTEGER lnblnk1,len;

IF ~EGSPERT[ CALL HELP_MESSAGE(61); ]
:R:
OUTPUT;
(/' Name of file containing phase space data (with ext., < A100):'/' ',$);
IF OLDFILE[
    OUTPUT PSDNAM;
    (/' The old file was      ',A100/
         ' Do you want to change it? ',$);
    INPUT C1;(A1);
    IF (C1='?')GO TO :RRR:;
    IF (C1='y')|(C1='Y')[ OUTPUT;
       (/' Name of file containing phase space data (with ext., < A100):'
        /' ',$);
       ]
    ELSE[GOTO :RR:;]
    ]
READ(5,'(A100)',ERR=:RRR:)PSDNAM;
OUTPUT PSDNAM;(' File name input is:', A100);
i_iaea_in=0; "assume not in IAEA format"
len=lnblnk1(PSDNAM);
IF(PSDNAM(len-8:len)='.IAEAphsp')[
         i_iaea_in=1;
         PSDNAM=PSDNAM(:len-9)//char(0);
         OUTPUT;(/' Data is in IAEA format.'/);
]
GOTO :RR:;
:RRR:
  CALL HELP_MESSAGE(50);
  GOTO :R:;
:RR:;

RETURN;
END;

%L
!LABELS 1000;
%Q1
%C80
%I4
%E
%B132
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
"*******************************************************************************
SUBROUTINE OPENFILE;
"
" THIS IS A SUBROUTINE USED BY BEAMDP TO OPEN A PHASE-SPACE FILE.
"
" PROGRAMMER C-M MA
"
"*******************************************************************************

"**VARIABLES**"

"---Force declarations of all variables---"
IMPLICIT NONE;
COMIN/CHARACTERS;
COMIN/DOUBLES;
COMIN/REALS;
COMIN/INTEGERS;
COMIN/LOGICALS;
COMIN/RWPHSP/;
integer itmp;

i_log=6;

:OPEN-FILE:;

IF(i_iaea_in=1)[
   i_unit_in=2;
   $IAEA_OPEN_PHSP_FOR_READ(i_unit_in,PSDNAM);
   $IAEA_READ_PHSP_HEADER(i_unit_in,PARANOT,PARANOP,PARAEMAX,LPARANINC,
                          Z_SCORE,IZLAST1,IMUIDX1,IZSCORE1);
   OUTPUT PARANOT,PARANOP,PARAEMAX,LPARANINC;
(/'            Total number of particles in file:',I13/
  '                      Total number of photons:',I13/
  '             The rest are electrons/positrons.'/
  ' '/
  '      Maximum kinetic energy of the particles:',F13.3,' MeV'/
  ' # of incident particles from original source:',I13);
  IF(IZLAST1=1)[MODE_RW='MODE2';]
  ELSE[MODE_RW='MODE0';]
  IF(IZSCORE1=0)[
    OUTPUT Z_SCORE;
('                       Z at which phsp scored:',F13.3,' cm');
  ]
  IF(IMUIDX1~=0)[
    OUTPUT;(' Fractional MU index also scored in phase space data. '/);
  ]
  NINC=LPARANINC;
]
ELSE[

itmp=-1;
$OPEN_PHSP_FOR_READ(itmp,2,PSDNAM,MODE_RW,PARANOT,
                    PARANOP,PARAEMAX,PARAEMNE,PARANINC);
IF(IERR_PHSP~=0) GOTO :RRRR1:;

OUTPUT PARANOT,PARANOP,PARAEMAX,PARAEMNE;
(/'            Total number of particles in file:',I13/
  '                       Total number of photons:',I13/
  '             The rest are electrons/positrons.'/
  ' '/
  '      Maximum kinetic energy of the particles:',F13.3,' MeV'/
  '      Minimum kinetic energy of the electrons:',F13.3,' MeV');
IF(PARANINC < 2.)["an old file which stored min. phot. energy"
       OUTPUT PARANINC;
 ('        Minimum kinetic energy of the photons:',F13.3,' MeV');
  NINC=1;
]
ELSE[
       OUTPUT PARANINC;
 (' # of incident particles from original source:',F13.1);
  NINC=PARANINC;
]
]
RETURN;
:RRRR1: OUTPUT;(//' CANNOT FIND/OPEN THE PH-SP FILE!!!'///);
"ask the user whether a different ph-sp file to be used"
IF EGSPERT[ CALL HELP_MESSAGE(61); ]
CALL READNAME;
GOTO :OPEN-FILE:;"OPEN FILE AGAIN"

END;

%L
!LABELS 7000;
%Q1
%C80
%I4
%E
%B132
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
"*******************************************************************************
SUBROUTINE HELP_MESSAGE(NMESSAGE);
"
" THIS IS A SUBROUTINE USED BY BEAMDP TO PRINT OUT HELP MESSAGES
"
" PROGRAMMER B. Walters
"
"*******************************************************************************

"**VARIABLES**"
INTEGER NMESSAGE; "determines the message to be printed"

IF(NMESSAGE=0)[
  OUTPUT;(/
  ' BEAMDP (BEAM Data Processor) creates a source parameter file'/
  ' for beam characterization models with information obtained'/
  ' from the user and derived from a full phase-space data file'/
  ' created by BEAM'/
  ' '/
  ' This programme can be used to derive planar fluence, spectrum,'/
  ' mean energy and angle distribution, etc., from a phase-space'/
  ' file created by BEAM.'/
  ' '/
  ' If you are not familiar with this programme, you can get an'/
  ' explanation before any input request. Otherwise, the prompts'/
  ' will be terse.'//
  ' However, you can get help by typing a ? to any prompt.'/);
]
ELSEIF(NMESSAGE=1)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' You have the following operation options:'/
  ' -------------------------------------------------------------'/
  '                                                              '/
  ' (0) - data processing for beam characterization models'/
  '       (input 0 for more detailed information)'/
  ' (1) - deriving fluence vs position from ph_sp data'/
  '       (number of particles vs position for required charge, region'/
  '        and LATCH)'/
  ' (2) - deriving energy fluence vs position from ph_sp data'/
  '       (kinetic energy vs position for required charge, region and'/
  '        LATCH)'/
  ' (3) - deriving energy spectrum from ph_sp data'/
  '       (particle spectrum for required charge, region and LATCH)'/
  ' (4) - deriving energy fluence distribution from ph_sp data '/
  '       (energy fluence distribution for required charge, region and'/
  '        LATCH)'/
  ' (5) - deriving mean energy information from ph_sp data'/
  '       (mean energy for required charge, region and LATCH)'/
  ' (6) - deriving angular distribution from ph_sp data');
  OUTPUT;(
  '       (angular distribution for required charge, region and LATCH)'/
  ' (7) - deriving zlast distribution from ph_sp data'/
  '       (angular distribution for required charge, region and LATCH)'/
  ' (8) - deriving information about particle weights from ph_sp data '/
  '       (distribution of weights for specified charge,region and LATCH)'/
  ' (9) - deriving X-Y positions of particles'/
  '       (X-Y scatter plot of particles for specified charge,region and'/
  '        LATCH)'/
  ' (10) - combining two ph-sp files into one'/
  '       (write the contents of file1 into file2)'/
  ' (11) - list parameters for a number of ph-sp particles'/
  '       (list IQ,X,Y,U,V,W,E,WEIGHT,LATCH on the screen)'/
  ' (12) - quit this programme'/
  ' -------------------------------------------------------------');
]
ELSEIF(NMESSAGE=2)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' CHOOSE FROM THE FOLLOWING: '/
  ' -------------------------------------------------------------'/
  ' '/
  '    0 for a circular field with circular ring bins'/
  '    1 for a square field with square ring bins'/
  '    2 for a rectangular field with rectangular voxels'/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=3)[
  OUTPUT $NB;(/
  ' -------------------------------------------------------------'/
  ' PARAMETERS REQUIRED FOR FLUENCE/ENERGY FLUENCE VS POSITION:'/
  ' ------------------------------------------------------------- '/
  ' '/
  ' The following parameters are needed for fluence vs position:'/
  ' '/
  '  1) number of radial bins into which field is divided (<',I4,')'/
  '  2) charge of the particles (0:phot,1:posi,-1:elec,2:all,3:e+e-)'/
  '  3) outer radius of the circular field'/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=4)[
  OUTPUT $NB;(/
  ' -------------------------------------------------------------'/
  ' PARAMETERS REQUIRED FOR FLUENCE/ENERGY FLUENCE VS POSITION:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are needed for fluence vs position: '/
  ' '/
  '  1) number of square bins into which field is divided (<',I4,')'/
  '  2) charge of the particles (0:photon,1:e+,-1:e-,2:all,3:e+e-)'/
  '  3) half-side of the square field'/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=5)[
  OUTPUT $NB;(/
  ' -------------------------------------------------------------'/
  ' PARAMETERS REQUIRED FOR FLUENCE/ENERGY FLUENCE VS POSITION:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' Input the following parameters:'/
  ' '/
  '  1) number of bins into which field is divided (<',I4,')'/
  '  2) orientation (0-along x-axis; 1-along y-axis)'/
  '  3) charge (0:photon,1:e+,-1:e-,2:all,3:e+e-)'/
  '  4) Xmin for a rectangular field'/
  '  5) Xmax for a rectangular field'/
  '  6) Ymin for a rectangular field'/
  '  7) Ymax for a rectangular field'/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=6)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' PARAMETERS FOR THE SPECTRAL OR ENERGY FLUENCE DISTRIBUTION:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are needed for the energy spectrum '/
  ' or energy fluence distribution: '/
  ' '/
  '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
  '  2) Xmin for a rectangular region anywhere on the scoring plane'/
  '  3) Xmax for the rectangular region'/
  '  4) Ymin for the rectangular region'/
  '  5) Ymax for the rectangular region'/
  '     (Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15)'/
  ' Or'/
  '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
  '  2) Rmin for an annular region centred at the z-axis'/
  '  3) Rmax for the annular region'/
  '     (Rmin,Rmax default to 0,15)'/
  ' '/
  '     Note: if you hit return here you get a rectangular field'/
  '       (i.e.,  Xmin,Xmax,Ymin,Ymax =-15,15,-15,15)'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=7)[
  OUTPUT $NB;(/
  ' ----------------------------------------------------------------'/
  ' NUMBER OF BINS AND MIN. ENERGY, MAX. ENERGY FOR THE DISTRIBUTION:'/
  ' ---------------------------------------------------------------- '/
  ' '/
  ' The maximum number of bins allowed is ',I4/
  ' and the energy range given below should be consistent with the'/
  ' phase-space data. For example, Emin should be =< (ECUT-0.511)'/
  ' used in the simulation with BEAM, and Emax should be greater '/
  ' than the maximum kinetic energy of the particles in the ph-sp data.'/
  ' '/
  ' ----------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=8)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' PARAMETERS FOR THE REQUIRED ANGULAR DISTRIBUTION:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are needed:'/
  ' '/
  '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
  '  2) Xmin for a rectangular region anywhere on the scoring plane'/
  '  3) Xmax for the rectangular region'/
  '  4) Ymin for the rectangular region'/
  '  5) Ymax for the rectangular region'/
  '     (Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15)'/
  ' Or '/
  '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
  '  2) Rmin for an annular region centred at the z-axis'/
  '  3) Rmax for the annular region'/
  '     (Rmin,Rmax default to 0,15)'/
  ' '/
  '     Note: if you hit return here you get a rectangular field'/
  '       (i.e.,  Xmin,Xmax,Ymin,Ymax =-15,15,-15,15)'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=9)[
  OUTPUT $NBINANGLE;(/
  ' -------------------------------------------------------------'/
  ' NUMBER OF BINS, MIN. ANGLE, MAX. ANGLE: '/
  ' -------------------------------------------------------------'/
  ' '/
  ' The maximum number of bins allowed is ',I4/
  ' and the angle should be between 0 - 90 degrees'/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=10)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' PARAMETERS FOR THE REQUIRED ZLAST DISTRIBUTION:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are needed:'/
  ' '/
  '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
  '  2) Xmin for a rectangular region anywhere on the scoring plane'/
  '  3) Xmax for the rectangular region'/
  '  4) Ymin for the rectangular region'/
  '  5) Ymax for the rectangular region'/
  '     (Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15)'/
  ' Or'/
  '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
  '  2) Rmin for an annular region centred at the z-axis'/
  '  3) Rmax for the annular region'/
  '     (Rmin,Rmax default to 0,15)'/
  ' '/
  '     Note: if you hit return here you get a rectangular field'/
  '       (i.e.,  Xmin,Xmax,Ymin,Ymax =-15,15,-15,15)'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=11)[
  OUTPUT $NBINANGLE;(/
  ' -------------------------------------------------------------'/
  ' NUMBER OF BINS, Zmin, Zmax:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The maximum number of bins allowed is ',I4/
  ' and the range of ZLAST '/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=12)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' PARAMETERS FOR THE REQUIRED WEIGHT DISTRIBUTION:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are needed for the weight distribution:'/
  ' '/
  '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
  '  2) Xmin for a rectangular region anywhere on the scoring plane'/
  '  3) Xmax for the rectangular region'/
  '  4) Ymin for the rectangular region'/
  '  5) Ymax for the rectangular region'/
  '     (Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15)'/
  ' Or'/
  '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
  '  2) Rmin for an annular region centred at the z-axis'/
  '  3) Rmax for the annular region'/
  '     (Rmin,Rmax default to 0,15)'/
  ' '/
  '     Note: if you hit return here you get a rectangular field'/
  '       (i.e.,  Xmin,Xmax,Ymin,Ymax =-15,15,-15,15)'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=13)[
  OUTPUT $NB;(/
  ' -----------------------------------------------------------------'/
  ' NUMBER OF BINS AND MIN. WEIGHT, MAX. WEIGHT FOR THE DISTRIBUTION:'/
  ' -----------------------------------------------------------------'/
  ' '/
  ' The maximum number of bins allowed is ',I4/
  ' and the weight range given below should be consistent with the'/
  ' phase-space data and also consistent with fact that the weights'/
  ' are plotted on a logarithmic scale. For example, the min. weight'/
  ' should be slightly greater than 0 and the max. weight should be'/
  ' slightly greater than 1.'/
  ' '/
  ' -----------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=14)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' PARAMETERS FOR THE X-Y SCATTER PLOT:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are needed for the X-Y scatter plot'/
  ' '/
  '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
  '  2) Xmin for a rectangular region anywhere on the scoring plane'/
  '  3) Xmax for the rectangular region'/
  '  4) Ymin for the rectangular region'/
  '  5) Ymax for the rectangular region'/
  '     (Xmin,Xmax,Ymin,Ymax default to -15,15,-15,15)'/
  ' Or'/
  '  1) charge of the particles (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
  '  2) Rmin for an annular region centred at the z-axis'/
  '  3) Rmax for the annular region'/
  '     (Rmin,Rmax default to 0,15)'/
  ' '/
  '     Note: if you hit return here you get a rectangular field'/
  '       (i.e.,  Xmin,Xmax,Ymin,Ymax =-15,15,-15,15)'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=15)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' MIN. ENERGY, MAX. ENERGY FOR THE PARTICLES IN THE SCATTER PLOT:'/
  ' ------------------------------------------------     '/
  '                                                             '/
  ' The energy range given below should be consistent with the'/
  ' phase-space data. For example, Emin should be =< (ECUT-0.511)'/
  ' used in the simulation with BEAM, and Emax should be greater '/
  ' than the maximum kinetic energy of the particles in the ph-sp data.'/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=16)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' LATCH bit filters:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' Input the following 3 varibles in the same line:'/
  ' '/
  '  1) I_IN_EX: flag for LATCH checking'/
  '    = 0 INclusive/EXclusive for bits: if any of the 1st set of'/
  '        Nbit1 bits are set and none of the 2nd set of Nbit2 bits'/
  '        are set, the particle is scored'/
  '    = 1 EXclusive for bits: if any of the set of Nbit1 bits'/
  '        are set, the particle is not scored'/
  '    = 2 INclusive for regions: score secondary particles that'/
  '        originated in the regions with IREGION_TO_BIT'/
  '        equal to any of the set of Nbit1 bits'/
  '    = 3 EXclusive for regions: do not score secondary particles'/
  '        that originated in regions with IREGION_TO_BIT equal'/
  '        to any of the set of Nbit1 bits'/);
]
ELSEIF(NMESSAGE=17)[
  OUTPUT;(
  '  2) Nbit1: the number of bits or regions of origin to'/
  '            include (I_IN_EX=0,2) or exclude (I_IN_EX=1,3)'/
  '  3) Nbit2: the number of bits to exclude.  Only has meaning'/
  '            for I_IN_EX=0, otherwise, it is automatically'/
  '            set to 0.'/
  ' '/
  '    Restrictions: for I_IN_EX=0:    0<=Nbit1+Nbit2<=29'/
  '                  for I_IN_EX=1:    0<=Nbit1<=29'/
  '                  for I_IN_EX=2,3:  0<=Nbit1<=24'//);
]
ELSEIF(NMESSAGE=18)[
  OUTPUT;(
  ' Input the following in the next line:'/
  '  BIT(I) or IREGION_TO_BIT(I) (I = 1, Nbit1):'/
  '                                         bits/IREGION_TO_BITs to'/
  '                                         include (I_IN_EX=0,2) or'/
  '                                         exclude (I_IN_EX=1,3)'/
  ' '/
  ' Input the next line only if I_IN_EX=0 and Nbit2>0:'/
  '  BIT(I) or IREGION_TO_BIT(I) (I = Nbit1+1, Nbit1+Nbit2):'/
  '                                         bits to exclude when'/
  '                                         I_IN_EX=0'/
  ' '/
  '     (BIT(I) should be between 0 and 28 and IREGION_TO_BIT(I)'/
  '      should) be between 0 and 23)'/
  ' '/
  '  (Note: if no LATCH checking is required input 0,0,0 below)'/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=19)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' LIST PARAMETERS FOR A NUMBER OF PARTICLES:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' Input the following:'/
  ' '/
  '  1) Number: number of particles to be listed (default to 100)'/
  ' '/
  '  2) IQ    : charge (0:phot,1:posit,-1:elect,2:all,3:e-e+)'/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=20)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' YOU CAN CHOOSE THE FOLLOWING GRAPH TYPES:                    '/
  ' -------------------------------------------------------------'/
  ' '/
  ' (0) - NORMAL POINT GRAPH'/
  ' (1) - HISTOGRAM'/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=21)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' Plot of  real fluence or planar fluence:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' (0) - estimated real fluence: E(particle weight/cos(Z-angle))'/
  '                               ------------------------------- '/
  '                                         total area'/
  '  '/
  ' (1) - planar fluence: E(particle weight)'/
  '                       -------------------'/
  '                           total area'/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=22)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' FILE CONTAINING FULL PHASE-SPACE DATA:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The full phase-space data created by the NRCC EGSnrc usercode'/
  ' BEAMnrc is stored in a compressed form. This programme uncompresses'/
  ' the data first and then analyses the data.'/
  ' '/
  ' The name of the file containing full phase-space data should be'/
  ' supplied here (with extension). '/
  ' '/
  ' A reminder - default BEAM ph-sp file name: [filename].egsphsp1'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=30)[
   OUTPUT;(/
  ' ------------------------------------------------------------------------'/
  ' USING SUB-SOURCE SPECIFIERS FROM AN EXISTING SOURCE MODEL FOR REFERENCE:'/
  ' ------------------------------------------------------------------------'/
  ' '/
  ' In order to help input the sub-source specifiers required to create a'/
  ' new source model, the sub-source specifiers from an existing source'/
  ' model can be used as a reference. However, if you do this, then the'/
  ' old and new source models will consist of the same number of sub-sources.'/
  '   '/
  ' In fact, it is sometimes easier to modify the sub-source specifiers'/
  ' directly by editing the source model than doing it interactively'/
  ' by running this program, and you are not confined by the'/
  ' condition mentioned above.'/
  ' -----------------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=31)[
  OUTPUT;(/
  ' ---------------------------------------------------------------'/
  ' FILE NAME INPUT:'/
  ' ---------------------------------------------------------------'/
  ' '/
  ' The name of the file containing the new source model.'/
  ' This could have been created by inputting sub-source specifiers'/
  ' from scratch and analyzing phase space data, modifying the'/
  ' sub-source specifiers of an existing source model, or analyzing'/
  ' phase space data using sub-source specifiers from an existing'/
  ' source model.'/
  ' ---------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=32)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' DETAILED INFORMATION ABOUT THE BEAM:'/
  ' -------------------------------------------------------------'/
  '                                                              '/
  ' The information about the machine, beam energy, field size, '/
  ' etc. will serve as a reminder for later use.'//
  ' Now input this information in one line (< 70 characters).'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=33)[
  OUTPUT $NS;(/
  ' -------------------------------------------------------------'/
  ' NUMBER OF SUB-SOURCES FOR THE SOURCE MODEL:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The maximum number of sub-sources is ',I4,'.'/
  ' This number is determined by the bit-setting number in BEAM.'/
  ' In general, one type of particles from a CM should be considered'/
  ' to be from a sub-source. However, scattering foils, mirror and'/
  ' monitoring chamber can be worked out as a virtual point source.'/
  ' If the relative source intensity of a sub-source is < 0.1% this'/
  ' sub-source will automatically be ignored in later use.'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=34)[
  OUTPUT I;(/
  ' -------------------------------------------------------------'/
  ' SOURCE TYPE FOR SUB-SOURCE',I4,', CHARGE, LATCH #:'/
  ' -------------------------------------------------------------'/
  '                                                             '/
  ' The source model consists of a number of sub-sources; each has'/
  ' its own energy spectrum and field distribution at the phantom'/
  ' surface. '/
  ' '/
  ' The component modules in a linear accelerator are classified'/
  ' into the following types:'/
  ' '/
  '       Source type 1  for aperture applicators'/
  '                   11 for tubular applicators'/
  '                   2  for collimators'/
  '                   3  for rings, cones, and point sources'/
  '                   4  for rectangular plane sources'/
  '                   5  for circular plane sources'/);
  OUTPUT $NS,$NS,$NS;(/
  ' The charge of the particles from the source:'/
  ' '/
  '           charge  0  for photons'/
  '                  -1  for electrons and'/
  '                   1  for positrons.'/
  ' '/
  ' The LATCH bit number must be <=',I3/
  ' If you input a LATCH bit in the range 1 - ',I3,' you are'/
  ' selecting particles that have been/interacted in region'/
  ' associated with the LATCH bit you have input.  If you input'/
  ' LATCH <= 0, then you are selecting particles that have none'/
  ' of bits 1 - ',I3,' set.  This latter option is generally only'/
  ' meaningful for virtual point sources.'/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=35)[
  OUTPUT;(/
  ' --------------------------------------------------------------'/
  ' SOURCE PARAMETERS FOR THIS SUB-SOURCE:'/
  ' --------------------------------------------------------------'/
  ' '/
  ' The following parameters are required for this sub-source:'//
  ' 1) distance (in cm) from the sub-source to the scoring plane'/
  ' 2) minimum x coordinate (cm) for the opening of the applicator'/
  ' 3) maximum x coordinate (cm) for the opening of the applicator'/
  ' 4) minimum y coordinate (cm) for the opening of the applicator'/
  ' 5) maximum y coordinate (cm) for the opening of the applicator'/
  ' 6) maximum |x| coordinate (cm) for the applicator'/
  ' 7) maximum |y| coordinate (cm) for the applicator'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=36)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' SOURCE PARAMETERS FOR THIS SUB-SOURCE:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are required for this sub-source: '//
  ' 1) distance (in cm) from source bottom to scoring plane'/
  ' 2) distance (in cm) from source top to scoring plane'/
  ' 3) minimum x coordinate (cm) for the opening of the applicator'/
  ' 4) maximum x coordinate (cm) for the opening of the applicator'/
  ' 5) minimum y coordinate (cm) for the opening of the applicator'/
  ' 6) maximum y coordinate (cm) for the opening of the applicator'/
  ' 7) maximum |x| coordinate (cm) for the applicator'/
  ' 8) maximum |y| coordinate (cm) for the applicator'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=37)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' SOURCE PARAMETERS FOR THIS SUB-SOURCE:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are required for this sub-source:'/
  ' '/
  ' 1. distance (in cm) from the sub-source to the scoring plane'/
  ' 2. minimum x coordinate (cm) for the opening of the collimator'/
  ' 3. maximum x coordinate (cm) for the opening of the collimator'/
  ' 4. minimum y coordinate (cm) for the opening of the collimator'/
  ' 5. maximum x coordinate (cm) for the opening of the collimator'/
  ' 6. maximum |x| coordinate (cm) for the collimator'/
  ' 7. maximum |y| coordinate (cm) for the collimator'/
  ' 8. orientation of the collimator:'/
  '    (0-collimator bars along x-axis, 1-along y-axis)'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=38)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' SOURCE PARAMETERS FOR THIS SUB-SOURCE:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are required for this sub-source:'/
  ' '/
  '   1) distance from the sub-source to the scoring plane'/
  '   2) Rmin: radius of the opening of the ring or cone'/
  '   3) Rmax: outer radius of the ring or cone'/
  ' '/
  ' Note:'/
  ' '/
  '   If it is a point source the radius must be 0.0 cm, and'/
  '   the SSD will be re-evaluated based on the ph-sp data.'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=39)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' RADIUS OF A RING OPENING TO ANALYSE THE VIRTUAL SSD:'/
  ' -------------------------------------------------------------'/
  '                                                             '/
  ' In order to derive the SSD for a (virtual) point source, the'/
  ' particles falling into this ring (R1) will be transported'/
  ' in vacuum. The radius of the projected image of this ring (R2)'/
  ' at a diatance, d, from the scoring plane will be calculated.'/
  ' The virtual SSD is then calculated by'/
  ' '/
  '                   SSD = d R1/(R2 - R1)'/
  ' '/
  ' see "Beam Characterization: a multiple-source model"'/
  '     by C-M Ma and D.W.O. Rogers, NRC Report PIRS-0509(C)'/
  ' '/
  ' The radius (in cm) of the ring region on the scoring plane'/
  ' should be supplied here (R > 0.0 cm and within the field).'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=40)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' SOURCE PARAMETERS FOR THIS SUB-SOURCE:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are required for this sub-source:'/
  ' '/
  ' 1) distance from the sub-source to the scoring plane'/
  ' 2) minimum x coordinate (cm) for the plane source'/
  ' 3) maximum x coordinate (cm) for the plane source'/
  ' 4) minimum y coordinate (cm) for the plane source'/
  ' 5) maximum y coordinate (cm) for the plane source'/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=41)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' SOURCE PARAMETERS FOR THIS SUB-SOURCE:                       '/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are required for this sub-source:'/
  ' '/
  '   1) distance from the sub-source to the scoring plane'/
  '   2) radius of the plane source '/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=42)[
  OUTPUT $NB;(/
  ' -------------------------------------------------------------'/
  ' NUMBER OF BINS AND MIN. ENERGY, MAX. ENERGY FOR THE SPECTRUM:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The maximum number of bins allowed is ',I4/
  ' and the energy range given below should be consistent with the'/
  ' phase-space data. For example, Emin should be =< (ECUT-0.511)'/
  ' used in the simulation with BEAM, and Emax should be greater '/
  ' than the maximum kinetic energy of the particles in the ph-sp data.'/
  ' '/
  ' Note: the min., max. energy and bin number will be the same '/
  ' for all the sub-sources.'/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=43)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' SCORING/TREATMENT FIELD TYPE:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' There are four different field types:'/
  ' '/
  '    field type = 0 for circular field with circular ring bins'/
  '               = 1 for square field with square ring bins'/
  '               = 2 for rectangular field with rectangular bins'/
  ' '/
  ' Note: field type will be the same for all the sub-sources.'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=44)[
  OUTPUT $NB,$NB,$NB;(/
  ' -------------------------------------------------------------'/
  ' PARAMETERS FOR THE CIRCULAR FIELD PLANAR FLUENCE DISTRIBUTION:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are required for this source to'/
  ' describe the circular field planar fluence distribution:'/
  ' '/
  '  1) number of bins for the planar fluence distribution'/
  '     inside the treatment field (<',I4,')'/
  '  2) radius of the treatment field'/
  '     Note: use slightly bigger value'/
  '  3) number of bins for the planar fluence distribution'/
  '     outside the treatment field (<',I4,')'/
  '  4) radius of the scoring field (=1 + a margin)'/
  ' '/
  ' Note: These will be the same for all the sub-sources.'/
  '       Total number of bins must be smaller than (<',I4,').'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=45)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' PARAMETERS FOR A RECTANGULAR SCORING FIELD:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are required for the planar fluence'/
  ' distribution in the scoring field (usually > treatment field):'/
  ' '/
  '  1) number of bins for the planar fluence (same for x & y)'/
  '  2) minimum x coordinate for the scoring field'/
  '  3) maximum x coordinate for the scoring field'/
  '  4) minimum y coordinate for the scoring field'/
  '  5) maximum y coordinate for the scoring field'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=46)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' PARAMETERS DESCRIBING A RECTANGULAR TREATMENT FIELD:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are required to define the field'/
  ' for treatment or measurement. Energy spectrum will be scored'/
  ' separately for particles falling inside and outside this '/
  ' treatment field:   '/
  ' '/
  '  1) minimum x coordinate for the scoring field'/
  '  2) maximum x coordinate for the scoring field'/
  '  3) minimum y coordinate for the scoring field'/
  '  4) maximum y coordinate for the scoring field'/
  ' '/
  ' NOTE: The treatment field should be inside the scoring field.'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=47)[
  OUTPUT $NB,$NB,$NB;(/
  ' -------------------------------------------------------------'/
  ' PARAMETERS FOR THE SQUARE FIELD PLANAR FLUENCE DISTRIBUTION:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are required for this source to'/
  ' describe the square field planar fluence distribution:'/
  ' '/
  '  1) number of bins for the planar fluence distribution'/
  '     inside the treatment field (<',I4,')'/
  '  2) half-width of the treatment field'/
  '     Note: use slightly bigger value'/
  '  3) number of bins for the planar fluence distribution'/
  '     outside the treatment field (<',I4,')'/
  '  4) half-width of the scoring field = treat. field + a margin'/
  ' '/
  ' Note: These will be the same for all the sub-sources.'/
  '       Total number of bins must be smaller than (<',I4,').'/
  ' -------------------------------------------------------------'/);
]
"ELSEIF(NMESSAGE=48)["
"  OUTPUT $NB;(/"
"  ' -------------------------------------------------------------'/"
"  ' PARAMETERS FOR THE FIELD PLANAR FLUENCE DISTRIBUTION:'/"
"  ' -------------------------------------------------------------'/"
"  ' '/"
"  ' The following parameters are required for this source to'/"
"  ' describe the field planar fluence distribution:'/"
"  ' '/"
"  ' 1) number of radial bins for the planar fluence (<',I4,')'/"
"  ' 2) max. radius of the scoring field '/"
"  ' '/"
"  ' Note: these will be the same for all the sub-sources.'/"
"  ' -------------------------------------------------------------'/);"
"]"
ELSEIF(NMESSAGE=49)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' WARNING ON SOURCE MODEL FILE NAME INPUT:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' Are you sure that there is a file in the specified directory'/
  ' or it contains the right data? Check it out and then decide'/
  ' whether to try again or switch to another file!!!'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=50)[
  OUTPUT;(/
  ' ---------------------------------------------------------------'/
  ' FILE CONTAINING FULL PHASE-SPACE DATA:'/
  ' ---------------------------------------------------------------'/
  ' '/
  ' The full phase-space data created by the NRCC EGSnrc usercode'/
  ' BEAMnrc is stored in a compressed form. This programme uncompresses'/
  ' the data first and then analyses the data.'/
  ' '/
  ' The name of the file containing full phase-space data should be'/
  ' supplied here (with extension). '/
  ' '/
  ' A reminder - default BEAM ph-sp file name: [filename].egsphsp1'/
  ' ---------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=51)[
  OUTPUT;(/
  ' ----------------------------------------------------------------'/
  ' Input the maximum number of particles to output to the scatter'/
  ' plot.  The number actually output may be less than this because'/
  ' it is also limited by the charge and/or LATCH bits selected above.'/
  ' If input is <=0 or > no. of particles in phase space file'/
  ' then this defaults to the total no. of particles in the file.'/
  ' ----------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=52)[
  OUTPUT;(/
  ' -------------------------------------------------------------------'/
  ' MIN. ENERGY, MAX. ENERGY FOR PARTICLES IN THE ANGULAR DISTRIBUTION:'/
  ' -------------------------------------------------------------------'/
  ' '/
  ' If you are interested in the angular distribution of all    '/
  ' particles, then the energy range given below should be consistent'/
  ' with the phase-space data. For example, Emin should be =< (ECUT-0.511)'/
  ' used in the simulation with BEAM, and Emax should be greater '/
  ' than the maximum kinetic energy of the particles in the ph-sp data.'/
  ' '/
  ' -------------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=53)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' Type of angular distribution:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' (0) - plot particles/angular bin'/
  ' '/
  ' (1) - plot particles/solid angle'/
  ' '/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=54)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' FILE NAME INPUT:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' File name of the new/modified source model.'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=55)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' FILE NAME INPUT:'/
  ' -------------------------------------------------------------'/
  '                                                              '/
  ' The name of the existing source model file to be used as a'/
  ' reference for sub-source specifier inputs.'/
  ' '/
  ' The file name should be supplied here (with extension < A80)'/
  ' and make sure that it exists and in the right directory!'/
  ' '/
  ' The most important thing is to make sure that the file'/
  ' contains the right data. Check its contents if you are asked'/
  ' to supply with the file name again.'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=56)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' FILE NAME INPUT:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The name of the existing source model containing sub-source  '/
  ' specifiers to be modified.'/
  ' '/
  ' The file name should be supplied here (with extension < A80)'/
  ' and make sure that it exists and in the right directory!'/
  ' '/
  ' The most important thing is to make sure that the file '/
  ' contains the right data. Check its contents if you are asked'/
  ' to supply with the file name again.'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=57)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' FILE NAME INPUT:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The name of the existing source model file containing'/
  ' sub-source specifiers to be used for analyzing the phase space'/
  ' data.'/
  ' '/
  ' The file name should be supplied here (with extension < A80)'/
  ' and make sure that it exists and in the right directory!'/
  ' '/
  ' The most important thing is to make sure that the file'/
  ' contains the right data. Check its contents if you are asked'/
  ' to supply with the file name again.'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=58)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' FILE NAME INPUT:'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The name of the source model file whose characteristics are '/
  ' to be plotted.'/
  ' '/
  ' The file name should be supplied here (with extension < A80)'/
  ' and make sure that it exists and in the right directory!'/
  ' '/
  ' The most important thing is to make sure that the file '/
  ' contains the right data. Check its contents if you are asked'/
  ' to supply with the file name again.'/
  ' -------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=59)[
  OUTPUT;(/
  ' ----------------------------------------------------------------'/
  ' DATA FILE FOR A SOURCE MODEL BASED ON FULL PHASE_SPACE DATA'/
  ' ****************************************************************'/
  ' '/
  ' The program creates a source model file for a Monte'/
  ' Carlo code. The source model is based on the full phase-space'/
  ' data created by NRCC EGSnrc usercode BEAMnrc for a particular beam'/
  ' from a clinical linear accelerator.');
   OUTPUT;(/
  ' The source model consists of a number of sub-sources; each has'/
  ' its own energy spectrum and field distribution at the phantom'/
  ' surface. The component modules in a linear accelerator are'/
  ' considered as following types of sub-sources:'//
  '            source type 1 & 11 for applicators'/
  '                        2 for collimators'/
  '                        3 for rings, cones, and point sources'/
  '                        4 for rectangular plane sources'/
  '                        5 for circular plane sources'/
  ' ');
  OUTPUT;(
  ' For more information about the simplified source models, see'//
  ' report "Beam Characterization: A Multiple-Source Model"'/
  ' by C-M Ma and D W O Rogers, IRS, NRC, Ottawa, Canada K1A 0R6'/);
]
ELSEIF(NMESSAGE=60)[
  OUTPUT;(/
  ' ------------------------------------------------------------------------'/
  ' USING SUB-SOURCE SPECIFIERS FROM AN EXISTING SOURCE MODEL FOR REFERENCE:'/
  ' ------------------------------------------------------------------------'/
  ' '/
  ' In order to help input the sub-source specifiers required to create a'/
  ' new source model, the sub-source specifiers from an existing source'/
  ' model can be used as a reference. However, if you do this, then the'/
  ' old and new source models will consist of the same number of sub-sources.'/
  ' '/
  ' In fact, it is sometimes easier to modify the sub-source specifiers'/
  ' directly by editing the source model than doing it interactively'/
  ' by running this program, and you are not confined by the'/
  ' condition mentioned above.'/
  ' ------------------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=61)[
  OUTPUT;(/
  ' ------------------------------------------------------------------'/
  ' FILE CONTAINING FULL PHASE-SPACE DATA:'/
  ' ------------------------------------------------------------------'/
  ' '/
  ' The full phase-space data created by the NRCC EGSnrc usercode'/
  ' BEAMnrc is stored in a compressed form. This programme uncompresses'/
  ' the data first and then analyses the data.'/
  ' '/
  ' The name of the file containing full phase-space data should be'/
  ' supplied here (with extension).'/
  ' '/
  ' A reminder - default BEAM ph-sp file name: [filename].egsphsp1'/
  ' ------------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=80)[
  OUTPUT;(/
  ' ----------------------------------------------------------------'/
  ' ENERGY SPECTRUM TYPE:'/
  ' ----------------------------------------------------------------'/
  ' '/
  ' There are two different energy spectrum types:'/
  ' '/
  ' 1) Inside and outside the treatment field'/
  ' 2) Different radii (independent of treatment-scoring fields)'/
  ' '/
  ' ----------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=81)[
  OUTPUT;(/
  ' ----------------------------------------------------------------'/
  ' ENERGY SPECTRUM TYPE FOR INSIDE/OUTSIDE FIELD:'/
  ' ----------------------------------------------------------------'/
  ' The following parameters are required for this energy spectrum'/
  ' type:'/
  ' '/
  '  1) radius of the treatment field'/
  '  2) radius of the scoring field'/
  ' '/
  ' ----------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=82)[
  OUTPUT $NB;(/
  ' ----------------------------------------------------------------'/
  ' ENERGY SPECTRUM TYPE WITH DIFFERENT RADII:'/
  ' ----------------------------------------------------------------'/
  ' The following parameters are required for this energy spectrum'/
  ' type:'/
  ' '/
  '  1) number of energy bins with different radii (<',I4,')'/
  '  2) radius of the scoring field'/
  ' '/
  ' ----------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=83)[
  OUTPUT;(/
  ' ----------------------------------------------------------------'/
  ' ENERGY SPECTRUM RADII:'/
  ' ----------------------------------------------------------------'/
  ' The following parameters are required for this energy spectrum'/
  ' radii:'/
  ' '/
  '  NbinEn number of different radii'/
  ' '/
  ' Note: the last radius must be equal to radius of the scoring field'/
  ' ----------------------------------------------------------------'/);
]
ELSEIF(NMESSAGE=84)[
  OUTPUT;(/
  ' -------------------------------------------------------------'/
  ' Parameters for writing particle (X,Y,Z) to a file (IAEA phsp only):'/
  ' -------------------------------------------------------------'/
  ' '/
  ' The following parameters are input:'/
  ' '/
  '  1) Min. fractional MU index (default 0)'/
  '  2) Max. fractional MU index (default 1)'/
  '  3) No. of particles to plot (default all in range)'/
  ' '/
  ' If MU index is not scored, then it will not be used as a filter.'/
  ' -------------------------------------------------------------'/);
]
ELSE[
  OUTPUT;(/
  ' ----------------------------------------------------------------'/
  ' ERROR: THIS MESSAGE TYPE DOES NOT EXIST'/
  ' ----------------------------------------------------------------'/);
]


RETURN;
END;

"End of beamdp.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc xvgr plotting subroutines                                           "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Andrew Booth, 1995                                        "
"                                                                             "
"  Contributors:    Charlie Ma                                                "
"                   Aaron Merovitz                                            "
"                   Dave Rogers                                               "
"                   Blake Walters                                             "
"                   Iwan Kawrakow                                             "
"                   Ernesto Mainegra-Hing                                     "
"                   Frederic Tessier                                          "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


!INDENT F2;
%I4
%Q1
"************************************************************************"

SUBROUTINE XVGRPLOT (X, Y, ERRY, NPTS, CURVENUM, SERIESTITLE,
                        XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                        UNITNUM, TYPE, HISTXMIN, AXISTYPE);

"************************************************************************"
"                                                                        "
"  This subroutine is used to create an xvgr plot file that will plot    "
"  Y as a function of X and include all of the pertinent information for "
"  the graph.  Each time the subroutine is called it writes one series   "
"  worth of data points to the unit specified.  For graphs that use      "
"  several series, multiple subroutine calls are required.               "
"                                                                        "
"  Written  by:  Andrew Booth, August 1995                               "
"  Modified by:  C-M Ma, Sept. 1995                                      "
"  Modified by:  Andrew Booth, July 1996                                 "
"                - introduced AXISTYPE argument to handle lin and log    "
"                  axis combinations.                                    "
"   Jan 98 A Merovitz/DR added xview xmin value so y axis label displayed"
"   Feb 98 A Merovitz/DR if non-negative, makes zeros fudge*smalest      "
"   Jun 99 BW/DWOR in Y>0 and ERRY crosses/touches 0, adjusted>0.0       "
"   Jul 99 DWOR made grace/xmgr compatible and added timestamp           "
"                                                                        "
"  The arguments of the subroutine are described in detail below:        "
"                                                                        "
"     1) X - array of x values to be plotted.  Top of bin if histogram.  "
"     2) Y - corresponding array of y values to be plotted.              "
"     3) ERRY - array containing uncertainties in Y for the plot.        "
"            If the first entry of this array is 0, it is                "
"            assumed that the graph is of type XY.  If it is             "
"            not 0, the graph is of type XY-DY.                          "
"     4) NPTS - the number (integer) of points to be plotted. This       "
"            should be the number of data points that exist in the       "
"            X, Y, and ERRY arrays.                                      "
"     5) CURVENUM - the number (integer) of the curve that is to be      "
"            plotted. The first curve number should be 0.  If this       "
"            number is not 0, then it is assumed that the plot file      "
"            already exists and the subroutine call is to add an         "
"            additional series to the existing graph.                    "
"     6) SERIESTITLE - string (max of 60 characters) giving the          "
"            series title (legend) for the data in the X and Y arrays.   "
"     7) XTITLE - string (max of 60 characters) giving the x axis        "
"            title.                                                      "
"     8) YTITLE - string (max of 60 characters) giving the y axis        "
"            title.                                                      "
"     9) GRAPHTITLE - string (max of 60 characters) giving the           "
"            graph title.                                                "
"    10) SUBTITLE - string (max of 60 characters) giving the subtitle    "
"            for the graph.                                              "
"    11) UNITNUM - number (integer) specifying where the data is to      "
"            be written.                                                 "
"            this unit must be opened by the calling routine             "
"    12) TYPE - 0 if data is to be written as normal point plot.         "
"               1 if data is to be written as a histogram plot.          "
"    13) HISTXMIN - used for histogram plots only.  This is a real       "
"                   number with the value of lower xbin for the plot.    "
"    14) AXISTYPE - 0 if linear-linear plot                              "
"                   1 if log-linear plot (y = log; x = lin)              "
"                   2 if linear-log plot (y = lin; x = log)              "
"                   3 if log-log plot                                    "
"                                                                        "
"                                                                        "
"************************************************************************"
  REPLACE{$SMALLFACTOR} WITH {1.E-5}
  REPLACE{$LARGEFACTOR} WITH {1.E5}

  IMPLICIT NONE;

  $INTEGER MAX, IDEBUG;
  PARAMETER (MAX = 400);  "---MAX used in defining the maximum number of---"
                          "---points that can be plotted in one series. ---"
  $INTEGER NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE;
  $REAL X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,HISTXMIN,ERRYOLD,SMALLESTX,
    SMALLESTY,FUDGE;
  $INTEGER TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENGTH;
  $INTEGER LOGX, LOGY, LOGDY,ZEROYCOUNT;

  "CHARACTER*80 SUBTITLE;"
  "CHARACTER*60 GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;"
  " IK changed the above to avoid complains from the compiler about"
  " inconsistent argument lists"
  CHARACTER*(*) SUBTITLE;
  CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;
  CHARACTER*10 INDEX;
  CHARACTER*3  INDEXNUM;

  $LOGICAL TESTFILE, ALLPOS;
  $REAL    one;
  parameter (one = 1);

  FUDGE = 1.e-10;              "If a number in the gaph is zero, it is replaced"
                             "by the (smallest number in the gaph)*(FUDGE)"
  IDEBUG = 0;  "set to 1 to get debug stmts active"
  IF (IDEBUG = 1) [
        write(6,'(//'' Entering xvgrplot ''/)');
        write(6,'('' Curve'',I3,'' to go to unit'',I3)')CURVENUM,UNITNUM;
        write(6,'(''SERIESTITLE: '',a60)') SERIESTITLE;
        write(6,'(''XTITLE:      '',a60)') XTITLE;
        write(6,'(''YTITLE       '',a60)') YTITLE;
        write(6,'(''GRAPHTILE:   '',a60)') graphtitle;
        write(6,'(''SUBTITLE:    '',a80)') subtitle;
  ]
  IF ( NPTS .gt. MAX) [ "Asked for too many points"
        OUTPUT NPTS, MAX;(//' **************************'/
        ' Number of points asked for =', I5,
        ' is greater than max allowed of', I4/
        ' Setting NPTS to MAX, you could adjust MAX in xvgrplot.mortran'/
        ' **************************'//);
        NPTS1 = MAX;
  ] ELSE [NPTS1 = NPTS;]

  "---Check to make sure that speicified unit is open for---"
  "---writing to.---"
  INQUIRE(UNIT = UNITNUM, OPENED = TESTFILE);

  IF (~TESTFILE) [ "---File has not been opened - print message.---"
    WRITE(6,:125:) UNITNUM;
    :125: FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------'
                 ,/'   Unit specified (',I2,') is not open.'
                 ,/'   Unit must be opened before using subroutine.'
                 ,/'   Data not written to file.'
                 ,/'  ----------------------------------------------'//);
    RETURN;
  ] "---End of error message for unopened file---"

  "---Set defaults if arguments are left blank.---"
  IF (GRAPHTITLE = ' ') [
    GRAPHTITLE = 'Untitled Graph - No title specified in subroutine';
  ]
  IF (XTITLE = ' ') [ XTITLE = 'X-axis not titled in subroutine';  ]

  IF (YTITLE = ' ') [ YTITLE = 'Y-axis not titled in subroutine'; ]

  IF (SERIESTITLE = ' ') [
    SERIESTITLE = 'series # ';
    INDEX = '0123456789';
    INDEXNUM = INDEX(CURVENUM+1:CURVENUM+1);
    SERIESTITLE(9:9) = INDEXNUM;
  ]

  "---Find lengths of stings for formatting purposes---"
  "---Initialize variable lengths---"

  TITLELENGTH = 61;    SUBLENGTH = 61;       XAXISLENGTH = 61;
  YAXISLENGTH = 61;    SERIESLENGTH = 61;

  "---Find title string length---"
  LOOP [
    TITLELENGTH = TITLELENGTH - 1;
  ] UNTIL (GRAPHTITLE(TITLELENGTH:TITLELENGTH) ~= ' ');

  "---Find subtitle string length---"
  LOOP [
    SUBLENGTH = SUBLENGTH - 1;
  ] UNTIL (SUBTITLE(SUBLENGTH:SUBLENGTH) ~= ' ');

  "---Find x-axis string length---"
  LOOP [
    XAXISLENGTH = XAXISLENGTH - 1;
  ] UNTIL (XTITLE(XAXISLENGTH:XAXISLENGTH) ~= ' ');

  "---Find y-axis string length---"
  LOOP [
    YAXISLENGTH = YAXISLENGTH - 1;
  ] UNTIL (YTITLE(YAXISLENGTH:YAXISLENGTH) ~= ' ');

  "---Find series title length---"
  LOOP [
    SERIESLENGTH = SERIESLENGTH - 1;
  ] UNTIL (SERIESTITLE(SERIESLENGTH:SERIESLENGTH) ~= ' ');
  IF( IDEBUG = 1) [
    OUTPUT SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELENGTH;
    (' SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELENGTH'/
     5I10)
  ]

  "---Small bit of error checking here done for the purpose of warning the---"
  "---user if there is a problem when using a 'log' type graph.           ---"
  "---Possible problems are:                                              ---"
  "---    1.)  value on log scale < or = 0.                               ---"
  "---    2.)  value of error bar for xydy plot extends into the region   ---"
  "---                    where y < or = 0.                               ---"
  "---                                                                    ---"
  "---To keep track of these problems the flags LOGX, LOGY, and LOGDY will---"
  "---be set if there is the respective error.                            ---"
  "---(ie.  if LOGX set (=1) then there exist an X value that is <= 0 AND ---"
  "--- the xaxis is set to be a log scale.)                               ---"
  "--------------------------------------------------------------------------"

  "---Initialize LOGX, LOGY, and LOGDY to be not set (0)---"
  LOGX = 0;          LOGY = 0;          LOGDY = 0;

  "---Initialize ZEROYCOUNT to 0---"
  ZEROYCOUNT=0;

  "In all cases where no negatives are concerned, fix points that are"
  "equal to 0.0"
  "Aaron Merovitz, Jan 1998"
  ALLPOS=.TRUE.;
  IF ( X(1)=0.0 ) [SMALLESTX = 0.1;] ELSE [SMALLESTX=X(1);]
  IF ( Y(1)=0.0 ) [SMALLESTY = 0.1;] ELSE [SMALLESTY=Y(1);]
  DO COUNT = 1, NPTS1 [
       IF ((X(COUNT) < SMALLESTX) & (X(COUNT)~=0.)) [SMALLESTX=X(COUNT);]
       IF ((Y(COUNT) < SMALLESTY) & (Y(COUNT)~=0.)) [SMALLESTY=Y(COUNT);]
       IF ((X(COUNT) < 0.)|(Y(COUNT) < 0.)) [ALLPOS=.FALSE.;]
  ]
  IF (ALLPOS) [
     DO COUNT = 1, NPTS1 [
          IF (X(COUNT)=0.) [X(COUNT)=SMALLESTX*FUDGE;]
          IF (Y(COUNT)=0.) [Y(COUNT)=SMALLESTY*FUDGE;]
     ]
  ]
  "---Loop through data points (if any log scales set) to see if there are---"
  "---any  <= 0 problems that might not have been fixed---"

  IF (AXISTYPE > 0) [  "---At least one axis is of log type---"
    DO COUNT = 1, NPTS1 [
      IF (X(COUNT) <= 0.) [ LOGX = 1; ]
      IF (Y(COUNT) <= 0.) [ LOGY = 1; ]
      IF ((Y(COUNT)-ERRY(COUNT)) <= 0.) [ LOGDY = 1; ]
    ]
  ]
  ELSE[ "--fix error bars that just hit Y axis in case user wants"
        "to switch to linlog plot while in xmgr--"
    DO COUNT = 1, NPTS1 [
       IF(Y(COUNT)-ERRY(COUNT) < Y(COUNT)-0.9999*Y(COUNT) & Y(COUNT)>0.)[
           ZEROYCOUNT=ZEROYCOUNT+1;
           IF(ZEROYCOUNT=1)[
             WRITE(6,:105:);
 :105: FORMAT (/' ------------WARNING from Subroutine XVGRPLOT-----------'
              ,/'  Some errors give 0 value and so are adjusted so       '
              ,/'  that you can switch to a log Y scale while in xmgr.   '
              ,/' -------------------------------------------------------'/);
           ]
           ERRYOLD=ERRY(COUNT);
           ERRY(COUNT) = 0.9999*Y(COUNT);
           "WRITE(6,:106:) COUNT,ERRYOLD,ERRY(COUNT);"
 ":106: FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, ' to'"
               "       /'        ',1PE11.4,'.');"
       ]
    ]
  ]

  "---Use this info later when writing to file---"

  "---Now begin writing information to unit---"
  IF (CURVENUM = 0) [ "---Case where plot file must start from scratch---"
    "---Insert xvgr graph header in file.---"

    "---Start with type of graph.  (lin-lin, log-lin, lin-log, or log-log)---"
    IF (AXISTYPE = 0) [ "---Graph is of type lin-lin---"
      WRITE(UNITNUM,:90:) 'xy';
    ] ELSEIF (AXISTYPE = 1) [ "---Graph is of type log-lin---"
      WRITE(UNITNUM,:90:) 'logy';
      WRITE(UNITNUM,:1080:);
    ] ELSEIF (AXISTYPE = 2) [ "---Graph is of type lin-log---"
      WRITE(UNITNUM,:90:) 'logx';
      WRITE(UNITNUM,:1080:);
    ] ELSEIF (AXISTYPE = 3) [ "---Graph is of type log-log---"
      WRITE(UNITNUM,:90:) 'logxy';
      WRITE(UNITNUM,:1080:);
      WRITE(UNITNUM,:1090:);
    ] ELSE [ "--anything else specified is in error--"
      WRITE(6,:91:) AXISTYPE;
      :91: FORMAT (//'  ------------Error in Subroutine XVGRPLOT-----------'
                 ,/'   AXISTYPE specified (',I2,') is not a valid option.'
                 ,/'  ----------------------------------------------'//);
      RETURN;
    ]

    :90: FORMAT ('@g0 type ',A,' ');
    :1080: FORMAT ('@    xaxis  ticklabel format exponential');
    :1090: FORMAT ('@    yaxis  ticklabel format exponential');

    "---Titles and things---"
    WRITE(UNITNUM,:100:) GRAPHTITLE(1:TITLELENGTH)
                        ,SUBTITLE(1:SUBLENGTH)
                        ,XTITLE(1:XAXISLENGTH)
                        ,YTITLE(1:YAXISLENGTH);
    :100: FORMAT ('@    title "',A,'"'/
                 ,'@    subtitle "',A,'"'/
                 ,'@    legend on'/
                 ,'@    legend box linestyle 0'/
                 ,'@    legend x1 0.6'/
                 ,'@    legend y1 0.75'/
                 ,'@    view xmin 0.250000'/
                 ,'@    xaxis  label "',A,'"'/
                 ,'@    timestamp on'/
                 ,'@    yaxis  label "',A,'"');
  ]  "---End CURVENUM = 0---"

"--XVGR has the characteristic that if the same input command is issued more---"
"--than once, the last one to be read is the one that is executed.  For this---"
"--situation, this is perfect.  Say the first series written to a file is of---"
"--a log scale, and the second is also of log scale, but has a data point   ---"
"--on the log scale that is < or = 0, then we can write the '@g0 type xy'   ---"
"--to the file AFTER the previous '@g0 type logxy' and the xy type will     ---"
"--prevail.  This will prevent errors when executing XVGR.  Of course the   ---"
"--alteration will also be written to the display.                          ---"


  IF (AXISTYPE = 1 & LOGY = 1) [  "--LOGY error--"
    WRITE(UNITNUM,:90:) 'xy';
    WRITE(6,:95:);
    :95: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
                ,/'  Log scale requested for Y axis when one or more   '
                ,/'  Y data points are 0 or negative.                  '
               ,//'  Y axis scale changed to linear.                   '
                ,/' ---------------------------------------------------'/);
  ]

  IF (AXISTYPE = 2 & LOGX = 1) [  "--LOGX error--"
    WRITE(UNITNUM,:90:) 'xy';
    WRITE(6,:96:);
    :96: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
                ,/'  Log scale requested for X axis when one or more   '
                ,/'  X data points are 0 or negative.                  '
               ,//'  X axis scale changed to linear.                   '
                ,/' ---------------------------------------------------'/);
  ]

  IF (AXISTYPE = 3 & (LOGX = 1 | LOGY = 1)) [  "--LOGX or LOGY error--"
    IF (LOGX = 1 & LOGY = 1) [
      WRITE(UNITNUM,:90:) 'xy';
      WRITE(6,:97:);
      :97: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
                  ,/'  Log scale requested for X axis and Y axis when    '
                  ,/'  one or more X and Y data points are 0 or negative.'
                 ,//'  X and Y axes scales changed to linear.            '
                  ,/' ---------------------------------------------------'/);
    ]
    ELSEIF (LOGX = 1) [ WRITE(UNITNUM,:90:) 'logy'; WRITE(6,:96:); ]
    ELSE              [ WRITE(UNITNUM,:90:) 'logx'; WRITE(6,:95:); ]
  ]

  "---now make a fix for those error bars that 'dip' beneath the x-axis on---"
  "---log plots.                                                          ---"

  IF (LOGDY = 1 & LOGY ~= 1 & (AXISTYPE = 3 | AXISTYPE = 1)) [
    "--if LOGDY problem and log scale not been already reset to linear--"
    "--do fudge to correct the problem--"

    WRITE(6,:101:);
    :101: FORMAT (/' ------------WARNING from Subroutine XVGRPLOT-----------'
              ,/'  Log scale requested for Y axis, and Y value less      '
              ,/'  error gives 0 or negative value.                      '
             ,//'  Error adjusted to aviod negavite values on log scale. '
              ,/' -------------------------------------------------------'/);

    DO COUNT = 1,NPTS1[
      IF(Y(COUNT)-ERRY(COUNT) < Y(COUNT)-0.9999*Y(COUNT)) [
        ERRYOLD = ERRY(COUNT);
        ERRY(COUNT) = 0.9999*Y(COUNT);
        WRITE(6,:103:) COUNT,ERRYOLD,ERRY(COUNT);
        :103: FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, ' to'
                      /'        ',1PE11.4,'.');
      ]
    ]

    WRITE(6,:104:);
    :104: FORMAT (/' -------------------------------------------------------'/);

  ]

  "---Include data about series for legend purposes.---"
  "first line needed to make it work with grace"
  IF (CURVENUM < 10 ) [
    WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM;
  ]
  ELSE [
    WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM;
  ]
  WRITE(UNITNUM,:150:)  CURVENUM,SERIESTITLE(1:SERIESLENGTH);
  :150: FORMAT ('@    legend string ',I2,' "',A,'"');


  "---Do normal plot.  ie. NOT histogram plot.---"
  IF (TYPE = 0) [ "---Normal point plot.---"

    "---Check all ERRYs.  If even one is nonzero, then series is type xydy---"
    DO COUNT = 1, NPTS1 [
      IF (ERRY(COUNT) ~= 0) [ "---Data set is not of type XY---"
        GOTO :X-Y-DY1:;
      ]
    ]

    "---Data set is of type XY---"
    WRITE(UNITNUM,:200:);
    :200: FORMAT ('@TYPE xy');
    IF (CURVENUM < 10) [
       WRITE(UNITNUM,:151:) CURVENUM;
       IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
       ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
    ]
    ELSE [
       WRITE(UNITNUM,:152:) CURVENUM;
       WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
    ]
    :151: FORMAT ('@    s',I1,' errorbar length 0.000000');
    :152: FORMAT ('@    s',I2,' errorbar length 0.000000');
    :197: FORMAT ('@    s',I1,' symbol color ',I2);
    :198: FORMAT ('@    s',I1,' symbol color ',I1);
    :199: FORMAT ('@    s',I2,' symbol color ',I2);

    "---Then write the data to the file.---"
    DO COUNT = 1, NPTS1 [ WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT); ]
    :250: FORMAT (1PE15.4,1PE15.4);
    GOTO  :END-X-Y-DY1:;

    "---Data set is of type XY-DY---"
    :X-Y-DY1:;
    WRITE(UNITNUM,:300:);
    :300: FORMAT ('@TYPE xydy');
    IF (CURVENUM < 10) [
    WRITE(UNITNUM,:151:) CURVENUM;
       IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
       ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
    ]
    ELSE [
       WRITE(UNITNUM,:152:) CURVENUM;
       WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
    ]

    "---Then write the data to the file.---"
    DO COUNT = 1, NPTS1 [WRITE(UNITNUM,:350:) X(COUNT),Y(COUNT),ERRY(COUNT);]
    :350: FORMAT (1PE15.4,1PE15.4,1PE15.4);
    :END-X-Y-DY1:;

  ]  "--end of point plot block--"
  ELSE [ "---Histogram plot---"

    "---Must find minimum y value in the y array to    ---"
    "---use as scale factor for establishing y-min on  ---"
    "---histogram plot.  We don't use 0 here as with 0 ---"
    "---plot can not be made into log plot in xvgr.    ---"

    YMIN = ABS($LARGEFACTOR * Y(1));

    DO COUNT = 1, NPTS1 [
       IF (ABS(Y(COUNT)) < YMIN) [ YMIN = ABS(Y(COUNT)); ]
    ]  "---End loop to find smalled Y---"

   "---Now smallest value of Y has been found.  Want to make sure that the---"
   "---first point used is even smaller than this and that it is of the same---"
   "---sign as the first Y data point in the plot.---"

    "---Now set YMIN to even smaller value for plot and set sign.---"
    YMIN = SIGN(one,Y(1)) * $SMALLFACTOR * YMIN ;

    "---Set this value in y-array as element after the---"
    "---element in index npts.---"
    Y(NPTS1+1) = YMIN;

    IF ((AXISTYPE = 2 | AXISTYPE = 3) & HISTXMIN = 0) [
      IF (X(1) = (X(2)-X(1))) [ HISTXMIN = X(1)-0.5*(X(2)-X(1)); ]
      ELSE                    [ HISTXMIN = X(1)-(X(2)-X(1)); ]

      WRITE(6,:306:) HISTXMIN;
      :306: FORMAT (/' ---------WARNING from Subroutine XVGRPLOT--------'
              ,/'  Minimum bin for X specified as 0 with log scale  '
              ,/'  on X axis.  Minimum X bin set to ',1PE10.3,'.'
              ,/' -------------------------------------------------'/);
    ]

    DO COUNT = 1, NPTS1 [
      IF (ERRY(COUNT) ~= 0.) [ "---Data set is not of type XY---"
        GOTO :X-Y-DY:;
      ]
    ]

"---Data set is of type XY---"
    IF (CURVENUM < 10) [
    WRITE(UNITNUM,:151:) CURVENUM;
       IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
       ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
    ]
    ELSE [
       WRITE(UNITNUM,:152:) CURVENUM;
       WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
    ]
    WRITE(UNITNUM,:200:);

    "---Plot the first histogram points.---"
    WRITE(UNITNUM,:250:) HISTXMIN,YMIN;
    WRITE(UNITNUM,:250:) HISTXMIN,Y(1);

    "--Then write the data to the file.---"
    DO COUNT = 1, NPTS1 [
      WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT);
      WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT+1);
    ]
    GOTO :END-X-Y-DY:;

"---Data set is of type XY-DY---"
    :X-Y-DY:;
    "---Put error of 0 on last *made-up* point in error array.---"
    ERRY(NPTS1+1) = 0.0;

    IF (CURVENUM < 10) [
    WRITE(UNITNUM,:151:) CURVENUM;
       IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
       ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
    ]
    ELSE [
       WRITE(UNITNUM,:152:) CURVENUM;
       WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
    ]
    WRITE(UNITNUM,:300:);

    "---Plot the first histogram points.---"
    IF (HISTXMIN = 0.0) [ "Aaron Meroivtz, Feb. 1998"
       HISTXMIN = SMALLESTX*FUDGE;
    ]
    WRITE(UNITNUM,:350:) HISTXMIN, YMIN, 0.;
    WRITE(UNITNUM,:350:) HISTXMIN, Y(1), 0.;
    WRITE(UNITNUM,:350:) (X(1)+HISTXMIN)/2., Y(1), ERRY(1);

    "---Then write the data to the file.---"
    DO COUNT = 1, NPTS1 [
      WRITE (UNITNUM,:350:) X(COUNT),Y(COUNT),0.;
      WRITE (UNITNUM,:350:) X(COUNT),Y(COUNT+1),0.;
      IF(COUNT < NPTS1)[
       WRITE (UNITNUM,:350:) (X(COUNT)+X(COUNT+1))/2.,Y(COUNT+1),ERRY(COUNT+1);
      ]
    ]
    :END-X-Y-DY:;
  ] "---End HIST=0 loop---"

  "---Insert end of series indicator to file.---"
  WRITE(UNITNUM,'(''&'')');

  RETURN;
  END; "---End of subroutine.---"
;

%C80
"#############################################################################"
"                                                                             "
"  EGSnrc function to get index of last non-blank character in a string       "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2004                                       "
"                                                                             "
"  Contributors:                                                              "
"                                                                             "
"#############################################################################"


$INTEGER function lnblnk1(string);

"Function to return index of last non-blank character in a string"
"We use this instead of lnblnk because there are compilers"
"that do not have lnblnk"

"******************************************************************************
character*(*) string;
DO i=len(string),1,-1 [
    j = ichar(string(i:i));
    IF( j = 0 ) [ lnblnk1 = i-1; return; ] "i.e. the same as strlen for "
                                           "0-terminated C-strings"
    IF( j ~= 9 & j ~= 10 & j ~= 11 & j ~= 12 & j ~= 13 & j ~= 32 ) [
        lnblnk1 = i; return;
    ]
]
lnblnk1 = 0; return; end;

%%
