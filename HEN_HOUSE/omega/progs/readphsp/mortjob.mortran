%L
%E
%I4
!INDENT F2;
%C80
%Q1
"#############################################################################"
"                                                                             "
" EGSnrc machine dependent macro file for linux                               "
"                                                                             "
" Created by configure version 2.0 on ma 10.5.2021 22.46.21 +0300             "
"                                                                             "
" You may add your own machine dependent macros to this file,                 "
" but be carefull to not overwrite it if you re-run configure.                "
"                                                                             "
"#############################################################################"

REPLACE {$MACHINE} WITH
  {,'linux',};
REPLACE {$HEN_HOUSE} WITH
  {'/home/rsmina/EGSnrc/HEN_HOUSE/'};
REPLACE {$CANONICAL_SYSTEM} WITH
  {'x86_64-unknown-linux-gnu'};
REPLACE {$CONFIGURATION_NAME} WITH
  {'linux'};
REPLACE {$EGS_CONFIG} WITH
  {'/home/rsmina/EGSnrc/HEN_HOUSE/specs/linux.conf'};

" System dependent stuff "
"========================================"
" Unfortunately, there appears to be no reliable way of copying files "
" under Fortran => we use a system call for this"
REPLACE {$copy_file} WITH {'cp '};

" Although one can move files using Fortran's intrinsic rename, "
" we don't know whether the user has not created additional files in "
" the temporary working directory => it is easiest to use a system call "
" to move all files from the temporary working directory to the user-code "
" directory. "
REPLACE {$move_file} WITH {'mv -f '};

" There appears to be no way of removing a directory from Fortran "
" => we use a system call for this. "
REPLACE {$remove_directory} WITH {'rm -rf '};

" The directory separator "
REPLACE {$file_sep} WITH {'/'};

REPLACE {$LONG_INT} WITH { integer*8 };
REPLACE {$SHORT_INT} WITH { integer*2 };
"$MAX_INT SET TO 2^63-1 in egsnrc.macros"
"The machine byte order"
REPLACE {$BYTE_ORDER} WITH {'1234'};
;
REPLACE {$RECL-FACTOR} WITH {4};
;
REPLACE {$FLUSH_UNIT(#);} WITH {call flush({P1});}
;
" If you want your user-code to return an exit status, use the "
" following macro to terminate execution"
REPLACE {$CALL_EXIT(#);} WITH {call exit({P1});}
;
" mortran3 gets confused by the # char => we need to pass it as an "
" argument to the macro. "
REPLACE {$HAVE_C_COMPILER(#);} WITH {{EMIT;{P1}define HAVE_C_COMPILER};}
;
REPLACE {$HAVE_LOAD_DSO(#);} WITH {{EMIT;{P1}define HAVE_LOAD_DSO};}
;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc macros to read and write phase space files                          "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1999                                       "
"                                                                             "
"  Contributors:    Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Macros required to read from and write to phase space files. These macros  "
"  replace the old calls to the subroutine rw_ph_sp.mortran and any           "
"  manipulations of phase space files that were hard-coded. Currently, these  "
"  macros are used by BEAM, DOSXYZ, BEAMDP, and readphsp. The beam            "
"  configuration script looks for this file in the following directories, in  "
"  this order                                                                 "
"                                                                             "
"  $HOME/egs4/BEAM_accelerator                                                "
"  $HOME/egs4/beam                                                            "
"  $OMEGA_HOME/beam                                                           "
"                                                                             "
"  All other configuration or compile scripts only use the version of this    "
"  file in $OMEGA_HOME/beam. These macros can be used with any code provided  "
"  that this file is concatenated before any codes that use the macros.       "
"  Detailed description of what each macro does is provided at the top of     "
"  the macro.                                                                 "
"                                                                             "
"#############################################################################"


;
REPLACE {;COMIN/RWPHSP/;} WITH {
"RWPHSP must be included in the common block of main in any code that uses"
"any of these phase space macros and also in the common block of"
"any subroutine that uses any phase space macros.  Note that the macro"
"$MAX_SC_PLANES(=the max. number of scoring planes) must have been defined"
"somewhere in the code before the first use of COMIN/RWPHSP.  In the case of"
"DOSXYZ, BEAMDP and readphsp, $MAX_SC_PLANES is a dummy value, set to 1,"
"at the beginning of main.  Note that, since, IHSTRY_PHSP is a $LONG_INT"
"variable, you must have the macro REPLACE {$LONG_INT} WITH {INTEGER*8} at"
"the top of any code that uses these macros.  If your compiler has trouble"
"with INTEGER*8, use INTEGER*4 in the $LONG_INT macro."

;COMMON/RWPHSP/
   STRING_TEMP_ZLAST_OUT,
                 "holds output phsp data for up to 1000 particles, with ZLAST"
   STRING_TEMP_OUT, "holds output phsp data for up to 1000 particles, no ZLAST"
   IHSTRY_PHSP, "history number (from primary non-phase space source) of"
                "particle being scored"
   iaea_dummy_long, "used to store INTEGER*8 values temporarily"
   NHSTRY_DOS, "passed to NHSTRY in beam when this actually comes from"
               "dosxyznrc source 20"
   ESHORT,    "single precision E read from/written to phsp"
   WEIGHTTMP, "modified version of WT to be written to phsp"
   WT_PHSP_SHORT, "single precision wt read from phsp"
   X_PHSP_SHORT, "single precision x read from phsp"
   Y_PHSP_SHORT, "single precision y read from phsp"
   Z_PHSP_SHORT, "single precision Z--for iaea format only"
   U_PHSP_SHORT, "single precision u read from phsp"
   V_PHSP_SHORT, "single precision v read from phsp"
   W_PHSP_SHORT, "single precision w--for iaea format only"
   ZLAST_PHSP_SHORT, "single precision zlast read from phsp"
   MUIDX_PHSP_SHORT, "MU_INDEX--iaea phsp files only"
   EKMAX_PHSP_SHORT, "max ke of particles in phsp file"
   EKMINE_PHSP_SHORT, "min ke of electrons in phsp file"
   NINC_PHSP_SHORT, "no. of particles from original primary source"
   dosxyz2beam_index, "stores MU index passed to beam from dosxyz"
   iaea_extra_floats, "array of extra floats in IAEA phsp file"
   NUM_PHSP_TOT, "tot no of particles in phsp file"
   PHOT_PHSP_TOT,"no. of photons in phsp file"
   iaea_result,  "<0 if an error finding an available array index for IAEA"
                 "phsp file"
   iaea_n_stat,  ">=1 if a new primary history is scoring, 0 otherwise"
   iaea_q_typ,    "array to convert from charge to IAEA type"
   iaea_typ_q,   "array to convert from IAEA type to charge"
   iaea_q_index, "array index"
   I_PHSP,    "loop counter"
   IERR_PHSP, "=0 if open/read okay ~=0 if not okay"
   LATCHTMP,  "modified version of LATCH to be written to phsp"
   WRITE_PHSP_COUNTER, "counter up to 1000 used for group write"
   WRITE_PHSP_SOFAR, "how many particles written so far to file"
   PHSP_RESTART, "set to 1 if this is a restart"
   PHSP_RECL, "the record length"
   PHSP_RECL_OLD, "saves record length"
   iaea_extra_ints, "array in which LATCH will be stored for iaea format"
   iaea_extra_int_types,iaea_extra_float_types, "returns the types of"
                    "extra int and float variables in an IAEA phsp file"
   iaea_i_zlast,"index of iaea_extra_floats in which Zlast is stored for IAEA"
           "phsp files read IN"
   iaea_i_latch,"index of iaea_extra_int in which LATCH is stored for IAEA"
           "phsp files read IN"
   iaea_i_muidx,"index of iaea_extra_floats in which MU_INDEX is stored for"
           "IAEA phsp files read IN"
   iaea_n_extra_ints, "no. of extra ints stored in IAEA phsp file read IN"
   iaea_n_extra_floats, "no. of extra floats stored in IAEA phsp file read IN"
   i_iaea_open_for_write, "set to 1 if the macro IAEA_OPEN_FOR_WRITE"
                          "was used"
   iaea_i_zlast_out,"index of iaea_extra_floats in which Zlast is stored for"
               " IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
   iaea_i_latch_out,"index of iaea_extra_int in which LATCH is stored for IAEA"
           "phsp written OUT by BEAMnrc or DOSXYZnrc"
   iaea_i_muidx_out,"index of iaea_extra_floats in which MU_INDEX is stored"
           " for IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
   dosxyz2beam_izscore, "set to 1 if Z scored for each particle (IAEA only)"
   MODE_RW;   "mode of phsp file (0 with ZLAST, 2 without), writing only"

CHARACTER*32000 STRING_TEMP_ZLAST_OUT($MAX_SC_PLANES);
CHARACTER*28000 STRING_TEMP_OUT($MAX_SC_PLANES);
$LONG_INT IHSTRY_PHSP($MAX_SC_PLANES),iaea_dummy_long,NHSTRY_DOS;
REAL*4 ESHORT,WEIGHTTMP,WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
       Z_PHSP_SHORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,ZLAST_PHSP_SHORT,
       MUIDX_PHSP_SHORT,
       EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT,dosxyz2beam_index,
       iaea_extra_floats(10);
INTEGER NUM_PHSP_TOT,PHOT_PHSP_TOT,
        iaea_result,iaea_n_stat,iaea_q_typ(3),iaea_typ_q(3),iaea_q_index,I_PHSP,
        IERR_PHSP,LATCHTMP,
        WRITE_PHSP_COUNTER($MAX_SC_PLANES),WRITE_PHSP_SOFAR($MAX_SC_PLANES),
        PHSP_RESTART,PHSP_RECL,PHSP_RECL_OLD,iaea_extra_ints(10),
        iaea_extra_int_types(10),iaea_extra_float_types(10),iaea_i_zlast,
        iaea_i_latch,iaea_i_muidx,iaea_n_extra_ints,iaea_n_extra_floats,
        i_iaea_open_for_write,iaea_i_zlast_out,iaea_i_latch_out,
        iaea_i_muidx_out,dosxyz2beam_izscore;
CHARACTER*5 MODE_RW;

"variables below are not part of the common block but are used locally"
"by the $WRITE_PHSP, $WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros"

INTEGER LATCH_TEMP_OUT,NUM_PHSP_TOFLUSH,TEMP_PHSP_COUNTER,REM_PHSP;
REAL*4 REAL_TEMP_OUT(7);
CHARACTER*32 REC_TEMP_OUT;

}
;

REPLACE {$INITIALIZE_PHSP_VARIABLES;} WITH{;
"Must be placed after the variable declarations in any subroutine"
"where $WRITE_PHSP and/or $WRITE_PHSP_RECORD is used.  Note, though, that"
"it does not necessarily have to be put at the top of main, unless one or"
"both of these macros are used in main."
"It equivalences the character string REC_TEMP_OUT with the phase space data"
"for 1 particle. REC_TEMP_OUT is then used to fill the character array"
"STRING_TEMP_(ZLAST_)OUT, which holds the phase space data in blocks of 1000"
"particles before writing."

EQUIVALENCE(REC_TEMP_OUT(1:4),LATCH_TEMP_OUT);
EQUIVALENCE(REC_TEMP_OUT(5:8),REAL_TEMP_OUT(1));
EQUIVALENCE(REC_TEMP_OUT(9:12),REAL_TEMP_OUT(2));
EQUIVALENCE(REC_TEMP_OUT(13:16),REAL_TEMP_OUT(3));
EQUIVALENCE(REC_TEMP_OUT(17:20),REAL_TEMP_OUT(4));
EQUIVALENCE(REC_TEMP_OUT(21:24),REAL_TEMP_OUT(5));
EQUIVALENCE(REC_TEMP_OUT(25:28),REAL_TEMP_OUT(6));
EQUIVALENCE(REC_TEMP_OUT(29:32),REAL_TEMP_OUT(7));
}
;

REPLACE {$INIT_PHSP_COUNTERS;} WITH {;
"This macro initializes counters and flags that are used by the"
"$WRITE_PHSP/$WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros.  It is only"
"used once and should be placed after the variable declarations in main."

DO I_PHSP=1,$MAX_SC_PLANES[
  WRITE_PHSP_COUNTER(I_PHSP)=0;
  WRITE_PHSP_SOFAR(I_PHSP)=0;
  IHSTRY_PHSP(I_PHSP)=0;
]
PHSP_RESTART=0;
PHSP_RECL_OLD=0;

iaea_q_typ(1)=2;iaea_q_typ(2)=1;iaea_q_typ(3)=3;
iaea_typ_q(1)=0;iaea_typ_q(2)=-1;iaea_typ_q(3)=1;

iaea_n_extra_ints=0;iaea_n_extra_floats=0;

iaea_i_zlast=-99;iaea_i_latch=-99;iaea_i_muidx=-99;

i_iaea_open_for_write=0;

iaea_i_zlast_out=-99;iaea_i_latch_out=-99;iaea_i_muidx_out=-99;

}
;


REPLACE {$GET_E_NPASS_IQ(#,#,#,#);} WITH {;
"Macro gets NPASS, IQ from the LATCH value read in and then restores LATCH"
"by clearing the bits that store this information.  It also puts the"
"single precision energy, ESHORT, read in into double precision form."
"This macro is called by $READ_PHSP."

"Input parameters:"
"{P1}=NPASS"
"{P2}=IQ"
"{P3}=LATCH"
"{P4}=E"

{P4}=ESHORT;

IF($BTEST({P3},31)) [ {P1} = 1; {P3} = $IBCLR({P3},31); ]
ELSE [ {P1} = 0; ]

IF($BTEST({P3},30)) [
    {P2} = -1;
    {P3} = $IBCLR({P3},30); {P3} = $IBCLR({P3},29);
]
ELSE [
       IF($BTEST({P3},29)) [
          {P2} = 1; {P3} = $IBCLR({P3},29);
       ]
       ELSE [ {P2} = 0; ]
]
}
;

REPLACE {$GET_W_WT(#,#,#,#,#,#);} WITH {;
"This macro calculates W, based on U and V and the sign of WT as read in from"
"the phase space file.  Once the sign of WT is determined, WT is set equal"
"to its absolute value, since there cannot be a negative particle weight."
"This macro is called by $READ_PHSP."

"Input parameters:"
"{P1}=W"
"{P2}=WT"
"{P3}=X"
"{P4}=Y"
"{P5}=U"
"{P6}=V"

{P1} = min( 1., {P5}**2 + {P6}**2);
{P1} = sqrt(1. - {P1});
{P1} = SIGN({P1},{P2});  "This transfers sign of WT to W"

{P2}=ABS({P2}); "WT is always positive"

}
;

REPLACE {$PARSE_PHSP_RECORD(#,#,#,#);} WITH {;
"macro used by READ_PHSP_RECORD to put single precision x, y, u, v"
"read from phase space file into (potentially) double precision"
"x, y, u, v passed to READ_PHSP_RECORD macro"

"Input parameters:"
"{P1}=X"
"{P2}=Y"
"{P3}=U"
"{P4}=V"

{P1}=X_PHSP_SHORT;
{P2}=Y_PHSP_SHORT;
{P3}=U_PHSP_SHORT;
{P4}=V_PHSP_SHORT;
}
;

REPLACE {$READ_PHSP_RECORD(#,#,#:#,#,#,#,#,#);} WITH {;
"Note that a colon is required  ^  between the third and fourth"
"input parameters."
"This macro actually reads the phase space data for a single particle."
"It is called by $READ_PHSP, but can also be used as a stand-alone macro."
"If the energy, E, is < 0.0, then this is the first particle scored"
"from a new primary (ie non-phsp source) history, and NHSTRY is incremented"
"and E is set to ABS(E)."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number"
"{P3}=record number"
"{P4}=NHSTRY"
"{P5}=ZLAST"
"{P6}=LATCH"
"{P7}=E"
"{P8}=WT"
"{P9}=X,Y,U,V"

IF({P1}~=0)["must read in ZLAST"
  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT,ZLAST_PHSP_SHORT;
]
ELSE["no ZLAST"
  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT;
]

IF({P3}=76695869)[
   write(*,*)' x,y,u,v,wt,eshort,latch',
 X_PHSP_SHORT,Y_PHSP_SHORT,U_PHSP_SHORT,V_PHSP_SHORT,
WT_PHSP_SHORT,ESHORT,{P6};
]

"first particle from new primary history"
IF(ESHORT<0.0)[
  {P4}={P4}+1;
  ESHORT=ABS(ESHORT);
]

{P7}=ESHORT;
{P8}=WT_PHSP_SHORT;
$PARSE_PHSP_RECORD({P9});

IF({P1}~=0) {P5}=ZLAST_PHSP_SHORT;

}
;

REPLACE {$READ_PHSP_RECORD_ENEGATIVE(#,#,#:#,#,#,#,#);} WITH {;
"Note that a colon is required            ^  between the third and fourth"
"input parameters."
"This macro is the similar to $READ_PHSP_RECORD above, but it preserves"
"the -E marker in the phase space file and does not advance NHSTRY"
"It is only used in readphsp before byte swapping"

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number"
"{P3}=record number"
"{P4}=ZLAST"
"{P5}=LATCH"
"{P6}=E"
"{P7}=WT"
"{P8}=X,Y,U,V"

IF({P1}~=0)["must read in ZLAST"
  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7},{P4};
]
ELSE["no ZLAST"
  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7};
]

}
;

REPLACE {$READ_PHSP(#:#,#,#,#,#,#,#,#);} WITH {;
"Note colon          ^  required between the first and second"
"input parameters (third and fourth input variables)"

"This macro reads the phase space data for a single particle.  It finds"
"the value of IQ and NPASS from the LATCH variable read in and then"
"restores the LATCH variable.  It calculates W from U, V and the sign"
"of WT and then restores WT to its absolute value.  And it puts the"
"single-precision energy, ESHORT, read in into double-precision format."
"If ESHORT is < 0, it sets E=ABS(ESHORT) and increments NHSTRY, taking"
"this as the first particle scored from a new primary history."

"Input parameters:"
"{P1}=IZLAST,unit number for phase space file,record number reading from"
"{P2}=NHSTRY"
"{P3}=NPASS"
"{P4}=IQ"
"{P5}=W"
"{P6}=ZLAST"
"{P7}=LATCH"
"{P8}=E"
"{P9}=WT,X,Y,U,V"

$READ_PHSP_RECORD({P1}:{P2},{P6},{P7},{P8},{P9});

IF(IERR_PHSP=0)[
  $GET_E_NPASS_IQ({P3},{P4},{P7},{P8});
  $GET_W_WT({P5},{P9});
]

}
;

REPLACE {$GET_LATCHTMP_ESHORT_WEIGHTTMP(#,#,#,#,#,#);} WITH {;
"This macro converts LATCH into LATCHTMP, which stores NPASS and IQ"
"for a particle and is the form of LATCH written to the phase space file."
"It puts double precision energy, E, into single precision format, ESHORT,"
"for writing to the phase space file.  This macro is called from $READ_PHSP"

"Input parameters:"
"{P1}=NPASS"
"{P2}=IQ"
"{P3}=W"
"{P4}=LATCH"
"{P5}=E"
"{P6}=WT"

LATCHTMP={P4};

IF({P1} = 0) [ LATCHTMP = $IBCLR(LATCHTMP,31); ]
ELSE [ LATCHTMP = $IBSET(LATCHTMP,31); ]

IF({P2} = -1) [ LATCHTMP = $IBSET(LATCHTMP,30);]
ELSEIF({P2} = 0) [
     LATCHTMP = $IBCLR(LATCHTMP,30);
     LATCHTMP = $IBCLR(LATCHTMP,29);
]
ELSE [
     LATCHTMP = $IBCLR(LATCHTMP,30);
     LATCHTMP = $IBSET(LATCHTMP,29);
]

ESHORT={P5};

WEIGHTTMP=SIGN({P6},{P3});"transfer sign of W to WEIGHTTMP"

}
;

REPLACE {$SET_NEGATIVE_E(#,#,#,#);} WITH {;
"Macro to set E to -E if this is the first particle scored from a new"
"primary (non-phsp source) history.  This macro is called from"
"$WRITE_PHSP_RECORD."

"Input parameters"
"{P1}=phase space scoring plane no."
"{P2}=IHSTRY"
"{P3}=E"
"{P4}=WT,X,Y,U,V"

IF({P2}~=IHSTRY_PHSP({P1}))[
  {P3}=-{P3};
  IHSTRY_PHSP({P1})={P2};
]

}
;

REPLACE {$PARSE_TEMP_FOR_WRITE(#,#,#,#,#,#,#,#,#);} WITH {;
"Macro to store the output phase space data for one particle in the"
"variables LATCH_TEMP_OUT and REAL_TEMP_OUT.  These variables are"
"equivalenced to the string variable REC_TEMP_OUT, which stores the"
"phase space for one particle in string form and which, in turn, is"
"used to transfer the data to the string variable STRING_TEMP(_ZLAST)_OUT"
"which stores output phase space data for up to 1000 particles at a time."
"This macro is called from $WRITE_PHSP_RECORD."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=ZLAST"
"{P3}=LATCH"
"{P4}=E"
"{P5}=WT"
"{P6}=X"
"{P7}=Y"
"{P8}=U"
"{P9}=V"

LATCH_TEMP_OUT={P3};
REAL_TEMP_OUT(1)={P4};
REAL_TEMP_OUT(2)={P6};
REAL_TEMP_OUT(3)={P7};
REAL_TEMP_OUT(4)={P8};
REAL_TEMP_OUT(5)={P9};
REAL_TEMP_OUT(6)={P5};
IF({P1}~=0) REAL_TEMP_OUT(7)={P2};

}
;

REPLACE {$WRITE_PHSP_RECORD(#,#,#,#,#:#,#,#,#);} WITH {;
"Note that a colon is required       ^  between the fifth and sixth"
"input parameters"

"This macro is used to output phase space data 1000 particles at a time."
"For every particle, the phase space data to be output is stored in"
"the string variable STRING_TEMP(_ZLAST)_OUT.  If it is the 1000th particle"
"STRING_TEMP(_ZLAST)_OUT is written to the phase space file.  The phase"
"space header info is considered to occupy the space of 1 particle in the"
"first block of 1000 particles, however, it will be overwritten with nulls."
"This is fine since the header info should be recalculated and rewritten at"
"the top of the file after all data has been written out anyway."
"Also note that restarting with this writing scheme requires that any"
"blocks of N (N<1000) particles at the end of a phase space file from"
"the previous run must immediately be read into the first N spaces of"
"STRING_TEMP(_ZLAST)_OUT before continuing on with outputting the data"
"for new particles.  Finally, after all phase space data has been output,"
"there will probably be info for M (M<1000) particles still in"
"STRING_TEMP(_ZLAST)_OUT that has not been written to the phase space file"
"because the write counter did not reach 1000.  These are output using"
"the $PHSP_BUFFER_FLUSH macro described below."

"Group writing reduces network traffic and saves a lot of time when the"
"one of the main CPU-intensive activities is the writing of phase space data."
"Group reading has also been considered, but preliminary studies have shown"
"that it does not reduce CPU time significantly."

"Using the macro $SET_NEGATIVE_E, $WRITE_PHSP_RECORD also takes care of setting"
"E to -E if this is the first particle scored from a new primary"
"(non-phsp source) history."

"This macro is called by $WRITE_PHSP, but can also be used as a stand-"
"alone macro.  However, use of $WRITE_PHSP_RECORD, will always require"
"use of $PHSP_BUFFER_FLUSH (see below)."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number for phase space file"
"{P3}=name of phase space file"
"{P4}=record number writing to"
"{P5}=scoring plane number"
"{P6}=IHSTRY"
"{P7}=ZLAST"
"{P8}=LATCH"
"{P9}=E,WT,X,Y,U,V"

IF({P4}>2 & WRITE_PHSP_COUNTER({P5})=0 & WRITE_PHSP_SOFAR({P5})=0)[
   "we have a restart or its the start of a new batch"
   IF(({P4}-1)-1000*(({P4}-1)/1000)~=0)[
   "make what was the buffer flush part of the first record of the restart"
    CLOSE({P2});
    IF({P1}~=0)["have ZLAST"
      PHSP_RECL=$RECL-FACTOR*8;
      OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
           FORM='UNFORMATTED',STATUS='UNKNOWN');
      DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
         READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
               STRING_TEMP_ZLAST_OUT({P5})(32*(I_PHSP-1)+1:32*I_PHSP);
      ]
      CLOSE({P2});
      PHSP_RECL=$RECL-FACTOR*8000;
      OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
           FORM='UNFORMATTED',STATUS='UNKNOWN');
    ]
    ELSE["no ZLAST"
      PHSP_RECL=$RECL-FACTOR*7;
      OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
           FORM='UNFORMATTED',STATUS='UNKNOWN');
      DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
         READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
               STRING_TEMP_OUT({P5})(28*(I_PHSP-1)+1:28*I_PHSP);
      ]
      CLOSE({P2});
      PHSP_RECL=$RECL-FACTOR*7000;
      OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
           FORM='UNFORMATTED',STATUS='UNKNOWN');
    ]
   ]
   WRITE_PHSP_SOFAR({P5})=1000*INT(dble({P4}-1)/1000);
   IF(WRITE_PHSP_SOFAR({P5})>0)[
       PHSP_RESTART=1;
       WRITE_PHSP_COUNTER({P5})=({P4}-1)-1000*(({P4}-1)/1000);
   ]
   ELSE[
       WRITE_PHSP_COUNTER({P5})=({P4}-2)-1000*(({P4}-2)/1000);
   ]
]

$SET_NEGATIVE_E({P5},{P6},{P9});

$PARSE_TEMP_FOR_WRITE({P1},{P7},{P8},{P9});

IF({P4}<=1000 & PHSP_RESTART=0)["do not use first 7/8 elements"
   IF({P1}~=0)["have ZLAST"
     STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+33:
       32*WRITE_PHSP_COUNTER({P5})+64)=REC_TEMP_OUT(1:32);
   ]
   ELSE["no ZLAST"
     STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+29:
       28*WRITE_PHSP_COUNTER({P5})+56)=REC_TEMP_OUT(1:28);
   ]
]
ELSE[
   IF({P1}~=0)[
     STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+1:
       32*WRITE_PHSP_COUNTER({P5})+32)=REC_TEMP_OUT(1:32);
   ]
   ELSE["no ZLAST"
     STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+1:
       28*WRITE_PHSP_COUNTER({P5})+28)=REC_TEMP_OUT(1:28);
   ]
]

WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;

IF({P4}=1000|WRITE_PHSP_COUNTER({P5})=1000)[
   IF({P1}~=0 & PHSP_RECL=$RECL-FACTOR*8)[
     CLOSE({P2});
     PHSP_RECL_OLD=PHSP_RECL;
     PHSP_RECL=$RECL-FACTOR*8000;
     OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
          FORM='UNFORMATTED',STATUS='UNKNOWN');
   ]
   ELSEIF({P1}=0 & PHSP_RECL=$RECL-FACTOR*7)[
     PHSP_RECL_OLD=PHSP_RECL;
     CLOSE({P2});
     PHSP_RECL=$RECL-FACTOR*7000;
     OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
          FORM='UNFORMATTED',STATUS='UNKNOWN');
   ]
   IF({P1}~=0)[
     WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_ZLAST_OUT({P5});
   ]
   ELSE["no ZLAST"
     WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_OUT({P5});
   ]
   IF(PHSP_RECL_OLD~=0)[
     "have to do this in case the output file=input file"
     PHSP_RECL=PHSP_RECL_OLD;
     CLOSE({P2});
     OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
          FORM='UNFORMATTED',STATUS='UNKNOWN');
   ]
   WRITE_PHSP_COUNTER({P5})=0;
   WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+1000;
]

}
;

REPLACE {$PHSP_BUFFER_FLUSH(#,#,#,#,#);} WITH {;
"This macro outputs the data for the M (M<1000) remaining particles still"
"stored in STRING_TEMP(_ZLAST)_OUT after all calls to $WRITE_PHSP_RECORD."
"The macro does not flush all of the data at once, but in blocks that"
"divide exactly into the number of particles already in the phase space"
"file.  For each block that is flushed, the phase space file is re-opened"
"with a record length (RECL) equal to the size of the block.  Since RECL"
"divides exactly into the number of particles already in the file, the"
"block to be flushed can be appended onto the data that already exists in"
"the file with no overwrites and/or blank space."
"The other alternative was to flush STRING_TEMP(_ZLAST)_OUT one particle at"
"a time, which is more time-consuming."
"$PHSP_BUFFER_FLUSH must exist in a code that uses $WRITE_PHSP or"
"$WRITE_PHSP_RECORD.  It should be placed on its own outside the loop in which"
"phase space data is output.  In the case of BEAM, it is placed at the end"
"of each batch, so that, if the simulation crashes, phase space information"
"from the last batch is not lost."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number for phase space file"
"{P3}=file name"
"{P4}=particle number +1"
"{P5}=scoring plane number"
TEMP_PHSP_COUNTER=0;
NUM_PHSP_TOFLUSH=WRITE_PHSP_COUNTER({P5});
IF(NUM_PHSP_TOFLUSH>0)[
  IF(WRITE_PHSP_SOFAR({P5})=0)[
      WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;
      NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH+1; "account for header"
  ]
  LOOP[
    TEMP_PHSP_COUNTER=NUM_PHSP_TOFLUSH+1;
    LOOP[
      TEMP_PHSP_COUNTER=TEMP_PHSP_COUNTER-1;
      REM_PHSP=MOD(WRITE_PHSP_SOFAR({P5}),TEMP_PHSP_COUNTER);
    ]UNTIL(REM_PHSP=0);
    CLOSE({P2});
    IF({P1}~=0)["write ZLAST"
      PHSP_RECL=$RECL-FACTOR*8*TEMP_PHSP_COUNTER;
      OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
           ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
      WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
             STRING_TEMP_ZLAST_OUT({P5})
    (32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
     32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
    ]
    ELSE["no ZLAST"
      PHSP_RECL=$RECL-FACTOR*7*TEMP_PHSP_COUNTER;
      OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
           ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
      WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
             STRING_TEMP_OUT({P5})
    (28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
     28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
    ]
    WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+TEMP_PHSP_COUNTER;
    NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH-TEMP_PHSP_COUNTER;
 ] UNTIL(NUM_PHSP_TOFLUSH=0);
 WRITE_PHSP_COUNTER({P5})=0;
 WRITE_PHSP_SOFAR({P5})=0;
]
;
}
;

REPLACE {$WRITE_PHSP(#:#,#,#,#,#,#,#:#);} WITH {;
"Note that colons     ^             ^  are required between the first and"
"second input parameters (5th and 6th input variables) and the"
"8th and 9th input parameters (13th and 14th input variables)"

"This outputs phase space data in blocks of 1000 particles at a time."
"In preparation for output, LATCH is modified to hold NPASS and IQ,"
"energy (E) is placed into a single precision variable, ESHORT, and"
"weight (WT) is given the sign of W.  If this is the first particle"
"scored from a new primary (non-phase space source) history, then"
"ESHORT is set to -ESHORT and IHSTRY_PHSP is set to IHSTRY."

"Input parameters:"
"{P1}=IZLAST,unit number for phase space file,name of phase space file,"
"     record number writing to, scoring plane number"
"{P2}=IHSTRY"
"{P3}=NPASS"
"{P4}=IQ"
"{P5}=W"
"{P6}=ZLAST"
"{P7}=LATCH"
"{P8}=E,WT"
"{P9}=X,Y,U,V"

$GET_LATCHTMP_ESHORT_WEIGHTTMP({P3},{P4},{P5},{P7},{P8});

$WRITE_PHSP_RECORD({P1}:{P2},{P6},LATCHTMP,ESHORT,WEIGHTTMP,{P9});

}
;

REPLACE {$READ_PHSP_HEADER(#,#,#,#,#,#,#);} WITH {;
"This macro reads the info from the header of a phase space file."
"It is called from $OPEN_PHSP_FILE_FOR_WRITE, but can also be used"
"as a stand-alone macro."

"Input parameters:"
"{P1}=unit number"
"{P2}=MODE0 or MODE2"
"{P3}=total number of particles"
"{P4}=no. of photons"
"{P5}=max k.e. of particles"
"{P6}=min. k.e. of electrons"
"{P7}=no. of particles incident from original source"

READ({P1},REC=1,IOSTAT=IERR_PHSP){P2},NUM_PHSP_TOT,PHOT_PHSP_TOT,
EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
{P3}=NUM_PHSP_TOT;
{P4}=PHOT_PHSP_TOT;
{P5}=EKMAX_PHSP_SHORT;
{P6}=EKMINE_PHSP_SHORT;
{P7}=NINC_PHSP_SHORT;

IF(IERR_PHSP~=0)[
   OUTPUT;(//' ***ERROR READING HEADER OF PHASE SPACE FILE*** '//);
   STOP;
]
}
;

REPLACE {$OPEN_PHSP_FOR_READ(#,#,#,#,#);} WITH {;
"Macro to open a phase space file in preparation for reading it."
"The macro opens the file in one of 3 modes, as a file that is known"
"to have ZLAST (IZLAST>0), as a file that is known not to have ZLAST"
"(IZLAST=0), or with no prior knowledge of whether the file has"
"ZLAST or not (IZLAST<0)."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number"
"{P3}=file name"
"{P4}=MODE0 or MODE2"
"{P5}=total number of particles, no. of photons, max k.e. of particles,"
"      min. k.e. of electrons, no. of particles incident from original source"

IF({P1}>0)["with ZLAST"
   PHSP_RECL=$RECL-FACTOR*8;
   OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
        RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
   IF(IERR_PHSP~=0)[
        "error above on file opening when assumed it was MODE2"
         OUTPUT;(/' ***error opening file as MODE2 ****'
        /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE2 FILE) ***'/
        /' *** WE NOW TRY TO OPEN IT AS A MODE3 FILE ***'//);
         OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
              FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
        "if on error, cannot find file/directory, then stop"
        IF(IERR_PHSP~=0)[
          ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
          STOP;
        ]
        $READ_PHSP_HEADER({P2},{P4},{P5});
        IF({P4} ~= 'MODE3')[
          OUTPUT;(//' That file does not start with MODE3,',
          ' as all old compressed files (with ZLAST) must'/
          '  Check it out and try again!'///);
          IERR_PHSP=1;
          STOP;
        ]
        ELSE[
          OUTPUT;(//' This is a MODE3 file! '/
          ' Please convert it into a MODE2 file using [readphsp] ',
          ' and try again!'///);
           IERR_PHSP=1;
           STOP;
        ]
   ]
   $READ_PHSP_HEADER({P2},{P4},{P5});
   IF({P4} ~= 'MODE2')[
       OUTPUT;(//' That file does not start with MODE2,',
          ' as standard compressed files with ZLAST must'/
          '  Check it out and try again!'///);
        IERR_PHSP=1;
        STOP;
   ]
]
ELSEIF({P1}=0)["without ZLAST"
   PHSP_RECL=$RECL-FACTOR*7;
   OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
        RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
    "$RECL-FACTOR = 4 for SUN SPARC and =1 for SILICON GRAPHICS "
    "this factor is machine-dependent and stored in machine.mortran"
    "check file is MODE0 -ie standard compressed"
   IF(IERR_PHSP~=0)[
    "come here if error opening file assumed MODE0"
      OUTPUT;(/' ***ERROR opening file as MODE0****'
      /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE0 FILE) ***'/
      /' *** WE NOW TRY TO OPEN IT AS A MODE1 FILE ***'//);
      OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
       FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
      "if on error, cannot find file/directory, then stop"
      IF(IERR_PHSP~=0)[
        ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
          STOP;
      ]
      $READ_PHSP_HEADER({P2},{P4},{P5});
      IF({P4} ~= 'MODE1')[
        OUTPUT;(//' That file does not start with MODE1,',
        ' as all old compressed files must'/
        '  Check it out and try again!'///);
        IERR_PHSP=1;
        STOP;
      ]
      ELSE[
        OUTPUT;(//' This is a MODE1 file! '/
       ' Please convert it into a MODE0 file using [readphsp] ',
       'and try again!'///);
         IERR_PHSP=1;
         STOP;
      ]
   ]
   $READ_PHSP_HEADER({P2},{P4},{P5});
   IF({P4} ~= 'MODE0')[
          OUTPUT;
            (/' Does not start with MODE0 as files without ZLAST must'/
          '  Try again!'//);
          IERR_PHSP=1;
          STOP;
   ]
]
ELSEIF({P1}<0)["open with no assumptions about whether ZLAST is there or not"
   OUTPUT;(/' First, try to open it as a MODE0 file');
   PHSP_RECL=$RECL-FACTOR*7;
   OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
        RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
   IF(IERR_PHSP~=0)[
     OUTPUT;(/' Now try to open it as a MODE2 file');
     {P1}=1;
     PHSP_RECL=$RECL-FACTOR*8;
     OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
        RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
     IF(IERR_PHSP~=0)[
        ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
     ]
     ELSE[
        $READ_PHSP_HEADER({P2},{P4},{P5});
        IF({P4}~='MODE2')[
            OUTPUT;(//' That file does not start with MODE2,',
          ' as standard compressed files with ZLAST must'/
          '  Check it out and try again!'///);
          CLOSE({P2});
          STOP;
        ]
     ]
   ]
   ELSE[
     $READ_PHSP_HEADER({P2},{P4},{P5});
     {P1}=0;
     IF({P4}~='MODE0')[
       OUTPUT;(/' The file does not start with MODE0 as it supposed to');
       CLOSE({P2});
       OUTPUT;(/' Now try to open it as a MODE2 file');
       {P1}=1;
       PHSP_RECL=$RECL-FACTOR*8;
       OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
           RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
       IF(IERR_PHSP~=0)[
         ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE OPENED. ***');
       ]
       ELSE[
          $READ_PHSP_HEADER({P2},{P4},{P5});
          IF({P4}~='MODE2')[
              OUTPUT;(//' That file does not start with MODE2,',
            ' as standard compressed files with ZLAST must'/
            '  Check it out and try again!'///);
            CLOSE({P2});
            STOP;
          ]
       ]
     ]
   ]
]
}
;

REPLACE {$PARSE_PHSP_HEADER_FOR_WRITE(#,#,#,#,#);} WITH {;
"Puts max ke of particles, min ke of electrons, and no. of particles"
"incident from original source--all of which may be double precision"
"into real*4 variables"
"{P1}=tot. no. of particles"
"{P2}=no. of photons"
"{P3}=max ke of particles"
"{P4}=min ke of electrons"
"{P5}=no. of particles incident from primary source"
IF({P1}>2147483647)[
  write(*,*)' Warning while writing phase space file:';
  write(*,*)' No. of particles > 2^31-1.';
  write(*,*)' Total no. of particles (and photons) written';
  write(*,*)' to header may be nonsense.';
]
NUM_PHSP_TOT={P1};
PHOT_PHSP_TOT={P2};
EKMAX_PHSP_SHORT={P3};
EKMINE_PHSP_SHORT={P4};
NINC_PHSP_SHORT={P5};
}

REPLACE {$WRITE_PHSP_HEADER(#,#,#,#,#);} WITH {;
"Macro to write the header information into a phase space file."
"Files must be closed and re-opened with record length (RECL) for"
"a single particle in order to prevent over-writing any particle data."
"Once the header info is written, the file is closed again and re-opened"
"with the RECL for 1000 particles."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number"
"{P3}=file name"
"{P4}=MODE0 or MODE2"
"{P5}=total number of particles, no. of photons, max k.e. of particles,"
"      min. k.e. of electrons, no. of particles incident from original source"

CLOSE({P2});
IF({P1}~=0)["have ZLAST"
  PHSP_RECL=$RECL-FACTOR*8;
]
ELSE["no ZLAST"
  PHSP_RECL=$RECL-FACTOR*7;
]
OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
       FORM='UNFORMATTED',STATUS='UNKNOWN');
$PARSE_PHSP_HEADER_FOR_WRITE({P5});
WRITE({P2},REC=1){P4},NUM_PHSP_TOT,PHOT_PHSP_TOT,EKMAX_PHSP_SHORT,
EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
CLOSE({P2});
IF({P1}~=0)["have ZLAST"
  PHSP_RECL=$RECL-FACTOR*8000;
]
ELSE["no ZLAST"
  PHSP_RECL=$RECL-FACTOR*7000;
]
OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
       FORM='UNFORMATTED',STATUS='UNKNOWN');
}
;


REPLACE {$OPEN_PHSP_FOR_WRITE(#,#,#,#);} WITH {;
"This macro opens a phase space file for writing.  The file is opened with"
"a record length that will hold phase space data for 1000 particles in 1"
"record.  This is to to enable writing phase space data for 1000 particles"
"at a time (see the $WRITE_PHSP_RECORD macro above).  The macro also uses"
"$WRITE_PHSP_HEADER to output a dummy header to the file."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number"
"{P3}=file name"
"{P4}=MODE_RW"
IF({P1}~=0)["with ZLAST"
   {P4}='MODE2';
   PHSP_RECL=$RECL-FACTOR*8000;
]
ELSE["no ZLAST"
   {P4}='MODE0';
   PHSP_RECL=$RECL-FACTOR*7000;
]
OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
        FORM='UNFORMATTED',STATUS='UNKNOWN');
$WRITE_PHSP_HEADER({P1},{P2},{P3},{P4},0,0,0,0,0);
}
;

REPLACE {$CLOSE_PHSP(#);} WITH {;
"Macro to close a phase space file."

"Input parameter:"
"{P1}=the unit number of the phase space file"

CLOSE(UNIT={P1});
}
;
/*****************************************************************************
 *
 *  Empty replacement macros for reading/writing IAEA format phase space
 *  files in case the IAEA C++ utility codes for handling phase space data
 *  are unavailable.  Otherwise, these empty macros are superseded by those
 *  in $HEN_HOUSE/utils/iaea_phsp_macros.mortran by including
 *  $HEN_HOUSE/utils/iaea_phsp_macros.mortran AFTER
 *  $HEN_HOUSE/utils/phsp_macros.mortran when building the code that is
 *  to be Mortran compiled.
 *
 ****************************************************************************/

REPLACE {$IAEA_OPEN_PHSP_FOR_WRITE(#,#,#,#,#,#,#);} WITH {;

OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
           ' space handling macros.'//);
}
;

REPLACE {$IAEA_OPEN_PHSP_FOR_READ(#,#);} WITH {;

OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
           ' space handling macros.'//);
}
;
REPLACE {$IAEA_WRITE_PHSP_RECORD(#,#,#,#,#,#,#,#);} WITH {;}

REPLACE {$IAEA_READ_PHSP_HEADER(#,#,#,#,#,#,#,#,#);} WITH {;}

REPLACE {$IAEA_SET_PHSP_RECORD(#,#);} WITH {;}

REPLACE {$IAEA_READ_PHSP_RECORD(#,#,#,#,#,#,#);} WITH {;}

REPLACE {$IAEA_DESTROY_PHSP_FILE(#);} WITH {;}

REPLACE {$IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(#,#);} WITH {;}

REPLACE {$IAEA_UPDATE_PHSP_HEADER(#);} WITH {;}

REPLACE {$IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(#);} WITH {;}


/*****************************************************************************
 *
 *  Macros that combine phsp read/write macros and code around them
 *  into simpler macros for use in BEAM.
 *  The idea is that one could replace such macros with something else.
 *
 ****************************************************************************/

REPLACE {$BEAM_OPEN_PHSP_FOR_WRITE;} WITH {;
    IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
    ELSE                  [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
                          "AUNIT is a character variable"
    "construct phase space file name."
    "part of this--the part that determines the directory and"
    "file prefix--is done in beam"
    IF(IO_OPT=4)[
       phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
       Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
       $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            IZLAST,0,Z_SCORE_SHORT,I_MU_PHSP,0);
    ]
    ELSE[
       phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
       $OPEN_PHSP_FOR_WRITE(IZLAST,IOUTFLU(I),$cstring(phsp_fn),MODE_RW);
    ]
};

REPLACE {$BEAM_OPEN_PHSP_FOR_READ;} WITH {;
    OUTPUT;
    (/' Restarting after previous run, will read old data & phase-space',
      ' files');
    DO I=1,NSC_PLANES [
        OUTPUT IOUTFLU(I);(//' Checking ph-sp file on logical unit ',I4);
        :OPEN_MODE0:;
        IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
        ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
        IF(IO_OPT=4)[
          phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
          Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
          $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            IZLAST,1,Z_SCORE_SHORT,I_MU_PHSP,0);
        ]
        ELSE[
          phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;

          $OPEN_PHSP_FOR_READ(IZLAST,IOUTFLU(I),$cstring(phsp_fn),
           MODE_RW,NPPHSPSP,NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);

           NPPHSP(I)=NPPHSPSP;
        ]
     ]
};

REPLACE {$BEAM_WRITE_PHSP;} WITH {;
    IF(IOUTFLU(ISCORE)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(ISCORE)-43;]
    ELSE                       [WRITE(AUNIT,'(I1)') IOUTFLU(ISCORE)-43;]

    "output directory and file prefix are defined in beam.mortran"

    IF(IO_OPT=4)[
      $IAEA_WRITE_PHSP_RECORD(IOUTFLU(ISCORE),NPASS(NP,ISCORE),
                ISCORE,NHSTRY,LATCH(NP),IQ(NP),E(NP),WT(NP),
                X(NP),Y(NP),Z(NP),U(NP),V(NP),W(NP),ZLAST(NP),
                BEAM_MU_INDEX);
    ]

    ELSE[

    IF( i_parallel > 0 ) ["add an _w"
         phsp_fn=$cstring(phsp_fn)// '_w';
         call egs_itostring(phsp_fn,i_parallel,.false.);
    ]
    phsp_fn=$cstring(phsp_fn)// '.egsphsp'//AUNIT;
    $WRITE_PHSP(IZLAST,IOUTFLU(ISCORE),$cstring(phsp_fn),NPPHSP(ISCORE)+1,
                ISCORE:NHSTRY,NPASS(NP,ISCORE),IQ(NP),W(NP),ZLAST(NP),
                LATCH(NP),E(NP),WT(NP):X(NP),Y(NP),U(NP),V(NP));
    ]
    IF(IZLAST = 2)[
         WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY;
         JHSTRY=JHSTRY+1;
         WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) NP,IQ(NP),0,
         XLAST(NP),YLAST(NP),ZLAST(NP),0;
         :GRAPHICS_FORMAT2:FORMAT(3I4,4G15.8,I12);
    ]
   "Check only needed when actually writting to a phsp file"
   IF(NPPHSP(ISCORE)=phsp_upper_limit)[
        $egs_fatal('(//a,i19,4(a/))',
            ' *** WHILE WRITING PHASE SPACE FILE:',
            NPPHSP(ISCORE), ' particles in file.',
            ' Due to the fact that the counter for the number',
            ' of particles in the file cannot be larger than this,',
            ' no more particles will be written to the phsp file.'
        );
    ]
};

REPLACE {$BEAM_PHSP_BUFFER_FLUSH;} WITH {;
     IF(IO_OPT=4)["update no. of primary histories in header"
       DO I1=1,NSC_PLANES[
          NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
          $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(IOUTFLU(I1),NINCPHSP);
          $IAEA_UPDATE_PHSP_HEADER(IOUTFLU(I1));
       ]
     ]
     ELSE["standard BEAMnrc format"
     IF(MODE_RW='MODE0' | MODE_RW='MODE2')[
        NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
        DO I1=1,NSC_PLANES[
           NPPHSPSP=NPPHSP(I1);
           IF(IOUTFLU(I1)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I1)-43;]
           ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I1)-43;]

           "output directory and file prefix defined in beam.mortran"

           phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
           $PHSP_BUFFER_FLUSH(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),NPPHSPSP,I1);
           IF(NPPHSPSP=NPHOTPHSP(I1))[
                  "no electrons"
              $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
                              MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
                              EKMAXPHSP(I1), 0.0, NINCPHSP);
           ]
           ELSE[
              $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
                              MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
                              EKMAXPHSP(I1), EKMINPHSPE(I1), NINCPHSP);
           ]
        ]
        "we store the total particle number in the 1st record of the ph-sp file"
     ]
     ]"end of standard BEAMnrc format"
};

REPLACE {$BEAM_READ_PHSP_FOR_RESTART;} WITH {;
    DO I=1,NSC_PLANES[
       OUTPUT I,NPPHSP(I);
       (//' PH-SP FILE',I4,': '/
          '               TOTAL NO. OF PARTICLES =',I12);
       IF(IO_OPT=0 | IO_OPT=3)["check to see that the user has not"
                               "added phase space files before restarting"
           IF(IO_OPT=4)[
              $IAEA_READ_PHSP_HEADER(IOUTFLU(I),NPPHSP(I),NPHOTPHSP(I),
               EKMAXPHSP(I),NINCPHSP,Z_SCORE,IZLAST1,I_MU_PHSP,IZSCORE);
               EKMINPHSPE(I)=99999.; "info unavailable"
              IF(IZLAST=0 & IZLAST1=1)[
               OUTPUT;
    (//' Error: Phase space file was scored with ZLAST in previous run '/
       ' but you have restarted this run with IZLAST=0.  Restart with'/
       ' IZLAST=1.'//);
               STOP;
              ]
              ELSEIF(IZLAST=1 & IZLAST1=0)[
              OUTPUT;
    (//' Error: Phase space file was scored  without ZLAST in previous run '/
       ' but you have restarted this run with IZLAST=1.  Restart with'/
       ' IZLAST=0.'//);
               STOP;
              ]
           ]
           ELSE[
              $READ_PHSP_HEADER(IOUTFLU(I),MODE_RW,NPPHSPSP,
                        NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);
              NPPHSP(I)=NPPHSPSP;
           ]
           IF(NINCPHSP>
            NINCSRC*(NCASEO+(NRCYCL+1)*(NPASS_ph_spO+NFAT_ph_spO))/NNPHSP)[
                                        "files have been added"
             OUTPUT I;(//' ***ERROR:'/
' Phase space file',I4,' has been added to (using beamdp?) before restarting.'/
' The code currently does not support this.  Please add phase space'/
' files only after all runs, including restarts, are complete.'//);
             "STOP;"
           ]
       ]
       IF(NPPHSP(I) > 0)[
           CALL DATETIME(1);
           OUTPUT TIMEN;(/' READ PH-SP FILE AT ',$TIMEN_FORMAT);
           "Read last particles to check whether it is right"
           IF(IO_OPT=4)[
              "just check that file size=checksum"
              $IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(IOUTFLU(I));
           ]
           ELSE[
              $READ_PHSP_RECORD(IZLAST,IOUTFLU(I),NPPHSP(I)+1:
              NHSTRYM,ZLAST(1),LATCHM,EINM,WTM,XINM,YINM,UINM,VINM);
           "binary read"
           OUTPUT NPPHSP(I),LATCHM,EINM,XINM,YINM,UINM,VINM,WTM;(//
           ' (LATCHM,EINM,XINM,YINM,UINM,VINM,WTM) FOR PARTICLE No.',
           I12,' IN THIS FILE:'/' ',I12,6F12.5);
           "CALL TIME(TIMEN);"
           "OUTPUT TIMEN;"
           "(/' FINISHED READING PH-SP FILE AT ',$TIMEN_FORMAT);"
           ]
           OUTPUT; (/' FINISHED READING PH-SP FILE AT ',$);
           call egs_time(6); OUTPUT; (' ');
       ]
    ]"end of loop over planes"
};

REPLACE {$BEAM_CLOSE_PHSP;} WITH {;
IF(n_parallel=0 | ~is_finished) [
"do not close phsp files that have already been closed"
"after individual parallel jobs have ended"
IF (IO_OPT =  0)|((IO_OPT =  3)&(IHSTRY <= 100000))|(IO_OPT=4) [
      "phase-space output"
  DO I=1,NSC_PLANES [
     IF(IO_OPT=4)[
        $IAEA_DESTROY_PHSP_FILE(IOUTFLU(I));
     ]
     ELSE[
        CLOSE(IOUTFLU(I));
     ]
  ]
]
]
};

REPLACE {$DOSXYZ_OPEN_PHSP_FOR_WRITE;} WITH {;
    "Added by T. popescu and J.Lobo to write phsps in dosxyz."
    "only done for IAEAphsps."
    "Some mods by BW."
    IF(IRESTART=0) [
     $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            0,0,z_score_tmp,i_muidx_out,1);
    ]
    ELSEIF(IRESTART=1) [
     $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            0,1,z_score_tmp,i_muidx_out,1);
    ]
};

REPLACE {$DOSXYZ_WRITE_PHSP;} WITH {;
    "Added by T. popescu and J.Lobo to write phsps in dosxyz."
    "only done for IAEAphsps"
    $IAEA_WRITE_PHSP_RECORD(i_unit_out,0,
                1,nhist,latch(np),iq(np),e(np),
                wt(np), x(np),y(np),z(np),u(np),v(np),w(np),zlast_tmp,
                frMU_indx); "added MU index (JL 2013)"
                "zlast not used in dosxyz so this is a dummy variable"

};

REPLACE {$DOSXYZ_SET_OUT_PHSP_HEADER;} WITH {;
    "Added by T. popescu and J.Lobo to write phsps in dosxyz."
    "only done for IAEAphsps"
    IF(isource = 0 |  isource = 1 | isource = 3 | isource = 7)[
        ainflu=dble(IHSTRY+ncaseold-nsmiss-nmissm);
    ]
    ELSEIF(isource = 2 | isource = 8 )[
        ainflu=dble(IHSTRY+ncaseold+nsmiss+
         (NRCYCL+1)*(nsrjct+nsoutside+ndbsrjct))/float(nshist)*NINCSRC;
    ]
    ELSEIF(isource=4)[
        ainflu=dble(IHSTRY+ncaseold-nsmiss);
    ]
    ELSEIF(isource=6)[
        ainflu=dble(IHSTRY+ncaseold);
    ]
    ELSEIF(isource=9|isource=10|isource=21)[
        ainflu=dble(nhist);
    ]
    ELSEIF(isource=20)[
        ainflu = dble((NRCYCL+1)*(nnread))/dble(nshist)*NINCSRC;
    ]
    $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(i_unit_out,ainflu);
    $IAEA_UPDATE_PHSP_HEADER(i_unit_out);

};

" The following are null macros that will be overwritten by the library "
" version of BEAM "
REPLACE {$DECLARE-PARTICLE-CONTAINER;} WITH {;};

"End of phsp_macros.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc readphsp utility source code                                        "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Bruce Faddegon, 1991                                      "
"                   Jiansu Wei, 1991
"                                                                             "
"  Contributors:    Charlie Ma                                                "
"                   Dave Rogers                                               "
"                   Daryoush Sheikh-Bagheri                                   "
"                   Blake Walters                                             "
"                   Iwan Kawrakow                                             "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


%L
%Q1
%C80
!INDENT F4;
!INDENT M4;
"*******************************************************************************
"
"                             ************
"                             *          *
"                             * READPHSP *
"                             *          *
"                             ************
"
"*******************************************************************************
"
"                                PURPOSE
"                                *******
"
" Provides for conversion of phase-space files between various formats, both
" of historical interest and in current use.
"
"*******************************************************************************
"
"                              USAGE
"                              *****
"
"   The script readphsp is a driver for this code:
"      readphsp $1 $2 $3 $4
"
"  $1    input file is $1.egsphsp$2 or $1.egs4phsp$2
"  $2    if it is 1, 2 or 3  which phase space file,  default = 1
"        if none of the above, it is the output filename
"  $3(or $2)    output file with extension,  default is $1.paw
"  $4(or $3)    output directory, default is current
"
"  Standalone:  readphsp.exe inputfile ioutputfile lrecl
"  lrecl = 4 for Sun and = 1 for SGI, only used for direct access modes
"
"
"
"*******************************************************************************
"
"                              DESCRIPTION
"                              ***********
"
" The full phase-space file contains a record of the position, direction,
" energy, and type of particle (electron, positron, or photon), etc. These files
" are usually generated by a Monte Carlo simulation. They currently can be
" produced by the EGSnrc user-code BEAMnrc.  This program provides for
" conversion between the following formats:
"
"     MODE NUMBER   PROGRAM(S)      FORMAT
"     -----------   --------------  -----------------------------------
"       0           BEAM            FORTRAN BINARY (ACCESS=DIRECT)
"       1           BEAM(old)       FORTRAN BINARY (ACCESS=SEQUENTIAL)
"       2           BEAM            FORTRAN BINARY (ACCESS=DIRECT) + ZLAST
"       3           BEAM(old)       FORTRAN BINARY (ACCESS=SEQUENTIAL) + ZLAST
"       4           PAW             FORTRAN BINARY
"
" Modes 1 and 3 are for historical conversions only and will eventually
" be discarded (want to bet?)
"
" The phase-space parameters for each format are as follows:
"
"     BEAM: IQ, LATCH, ENERGY, X, Y, U, V, W, WT, NPASS (& ZLAST for MODE2&3)
"     PAW:  iq, latch1,latch2.e.x.y.u.v.w.wt           (or zlast for MODE2&3)
"
"
"*******************************************************************************
"
"                                LINKING
"                                *******
"
"  The script compile_readphsp handles compilation and linking of readphsp.
"
" For the PAW format (from CERN), the following libraries are required:
" pawlib and packlib.
"
" On SUN SPARC machine:
" f77 -o readphsp.SunOS.exe readphsp.f\
"            -L/usr/people/irs1/omega/progs/readphsp_SunOS -lpawlib -lpacklib
"
" On a SILICON GRAPHICS machine:
" f77 -o readphsp.IRIX.exe readphsp.f\
"            -L/usr/people/irs1/omega/progs/readphsp_IRIX -lpawlib -lpacklib
"
"  In the above, the -Ldir specifies what directories to find pawlib and
"  packlib.
"*******************************************************************************
"
"                                AUTHORS
"                                *******
" B. A. Faddegon and J. Wei, Nov. 91
" B. A. Faddegon, Nov. 11/91
"    - corrected write error in BB option
"                - removed references to 0 index
"                - always prints numbers of all particles types
"    - added more recent FORTRAN binary file
" B. A. Faddegon, June 26/92
"    - added PAW write using J. Sun's program PAWDAT as a template (read
"      unavailable)
"    - cleaned up code and in-line documentation
" B. A. Faddegon, Aug 15/92
"    - minor changes to improve interactive I/O
" ALL THE OTHER CHANGES MADE BY JWEI.
" D. Sheikh-Bagheri, Aug 11/94
"    - I/O changes + one can write a desired # of records into the paw file
" C.-M. Ma, Oct. 6, 1994
"    - substantial changes to read from MODE 0-3 files and write to MODE0-4.
"    - removed old beam format and C format which are no longer used
"    - re-structured the whole programme
" C.-M. Ma, Apr. 12, 1995
"    - changes to score quantities to be stored on the first record
" BPG Sep. 1995, Added Btree access.
" LA  Sep. 1995, Added binned MODE0 output.
" D. Sheikh-Bagheri, Nov. 1995,
"                   - Restructured the PAW option to produce column-wise
"                     ntuple (CWN) to handle integers (like LATCH) correctly.
"                     RWN commented out everywhere
" DWOR removed BTREE Sept 1997, improved dialogue
"*******************************************************************************
"                             MACHINE DEPENDENCIES
"
"   The following macros may require changes for machines that do not handle
"   BTEST, IBCL, IBSET.
"
" *****************************"
" macros related to bit setting"
" *****************************"
""
"Macro to set bit {P2} in {P1}  to 1"
REPLACE {$IBSET(#,#);} WITH {
        IBSET({P1},{P2});}

        "Macro to set test bit {P2} in {P1}"
        "Note this may require a LOGICAL declaration wherever used"
REPLACE {$BTEST(#,#)} WITH {
        BTEST({P1}, {P2}) }

        "Macro to set bit {P2} in {P1}  to 0"
REPLACE {$IBCLR(#,#);} WITH {
        IBCLR({P1},{P2});}

        "Macro to swap bytes in {P1}"
        "Assumes 4-byte reals"
        "Byte 4 ---> byte 1"
        "byte 3 ---> byte 2"
        "byte 2 ---> byte 3"
        "byte 1 ---> byte 4"
        "macro only works with reals"
REPLACE {$SWAPBYTESREAL(#);} WITH {
      SWAPA={P1};
      SWAPII=0;
      SWAPDUMMY1=SWAPI;
      SWAPDUMMY2=SWAPII;
      CALL MVBITS(SWAPDUMMY1, 24, 8, SWAPDUMMY2, 0);
      CALL MVBITS(SWAPDUMMY1, 16, 8, SWAPDUMMY2, 8);
      CALL MVBITS(SWAPDUMMY1, 8, 8, SWAPDUMMY2, 16);
      CALL MVBITS(SWAPDUMMY1, 0,8,SWAPDUMMY2, 24);
      SWAPI=SWAPDUMMY2;
      {P1}=SWAPA;
}

        "Macro to swap bytes in {P1}"
        "Assumes 4-byte integers"
        "Byte 4 ---> byte 1"
        "byte 3 ---> byte 2"
        "byte 2 ---> byte 3"
        "byte 1 ---> byte 4"
        "macro only works with integers"
REPLACE {$SWAPBYTESINT(#);} WITH {
      SWAPI={P1};
      SWAPII=0;
      SWAPDUMMY1=SWAPI;
      SWAPDUMMY2=SWAPII;
      CALL MVBITS(SWAPDUMMY1, 24, 8, SWAPDUMMY2, 0);
      CALL MVBITS(SWAPDUMMY1, 16, 8, SWAPDUMMY2, 8);
      CALL MVBITS(SWAPDUMMY1, 8, 8, SWAPDUMMY2, 16);
      CALL MVBITS(SWAPDUMMY1, 0,8,SWAPDUMMY2, 24);
      SWAPI=SWAPDUMMY2;
      {P1}=SWAPI;
}

;

REPLACE {$MAX_SC_PLANES} WITH {1};

REPLACE {$INTEGER} WITH {integer*4}
REPLACE {$REAL} WITH {real*4}
REPLACE {$LOGICAL} WITH {logical}
;

"*******************************************************************************
"
"                             MAIN PROGRAM
"                             ************
"
" Type declarations
" *****************
"
"
"IMPLICIT NONE;

" general variables
" =================

INTEGER I, IIN, IOUT, IQ, LATCH, CHARGE,
       " NPASS, "
        INMODE, OUTMODE,
        IWRITEMAX,NPHOTON,
        in_particle_so_far,  "total number of input records read -including 1st
        out_part_so_far,    "total number of particle histories output so far"
        out_phot_so_far,    "number of photons output so far"
        in_particle_tot,     "total number of records in input file"
"        IOS,
        IWRITESTART,
        LRECORD,
        NHSTRY;            "keeps track of no. of primary (non-phsp) histories"
                           "necessary as placeholder in phsp macro calls"

CHARACTER*70 NAMEIN, NAMEOUT;
CHARACTER*5  MODE;
CHARACTER*1  RECORDL;
"DOUBLE PRECISION ENERGY;"
REAL*4 AV_E(3), U, V, W, X, Y," Z," WT, EMAXK,EMINE,NINC,
   tot_wt_read(3),     "total weight of particles in output file"
   tot_num_read(3),    "total number of records of each charge in output"
   ZLAST;

" LA
" bin variables
" ==============
INTEGER NESBIN, NXBIN, NYBIN, NUBIN, NVBIN, BIN_NUM;
REAL*4 ESMIN, XMIN, YMIN, UMIN, VMIN,
       ESMAX, XMAX, YMAX, UMAX, VMAX,
       ESBIN, XBIN, YBIN, UBIN, VBIN;

" variables exclusive to PAW-format
" =================================

"  By default HBOOKN will allocate a maximum quota of 8000 buffers of LRECL.
"        You can change the maximum quota with the following trick
"           Set iquest(10)=maximum number of records
"           iquest declared in common/quest/iquest(100)
"           and specify the option 'Q' for Quota in HBOOKN (See below)
REPLACE {$NCOLUM} WITH {10};         "number of variables in each record
REPLACE {$MAX_BUFF} WITH {3000000};  "maxnumber of buffers of LRECL"
"CHARACTER*8 CHTAGS($NCOLUM);"
COMMON/PAWC/H($MAX_BUFF);
COMMON/QUEST/IQUEST(100);
REAL XTUPLE($NCOLUM),H;
INTEGER NTUPLE,IQUEST,ISTAT,ICYCLE,NPRIME,LRECL;
"RWN version data are recognized by the following names in PAW"
"RWN        DATA CHTAGS/'e','x','y','u','v','l','i','t','r','w'/;

" variables for byte swapping
" ===========================
"
INTEGER*4 SWAPI,SWAPII;
INTEGER SWAPDUMMY1,SWAPDUMMY2,SWAPYES;
REAL*4 SWAPA;
CHARACTER*1 SWAPGOAHEAD,SWAPAWAY;

EQUIVALENCE(SWAPA,SWAPI);


" COMMON BLOCK DEFINITION (CWN)
" *****************************
COMMON /phasesp/ e,x,y,zlast,wt,iq,latch1,latch2,w,u,v;

COMIN/RWPHSP/; "variables for phsp macros"

$INITIALIZE_PHSP_VARIABLES;

DATA tot_wt_read /3*0.0/, tot_num_read / 3*0.0/, AV_E /3*0.0/;

$INIT_PHSP_COUNTERS;

NPHOTON=0;EMAXK=0.0;NINC=0.0;EMINE=0.0;
SWAPYES=0;
SWAPAWAY='n';

" Interactive input
" *****************
"

" get arguments from command line
" ===============================
CALL GETARG(1, NAMEIN); CALL GETARG(2, NAMEOUT); CALL GETARG(3, RECORDL);
"By having LRECORD an input, the code is identical for Sun and SGI"
"The record length factor =4 on Sun Sparc and =1 on SG machines"

READ(RECORDL,'(I1)')LRECORD;

"RECORD LENGTH IS REQUIRED FOR 'ACCESS=DIRECT' FILES AND IT'S RELATED TO"
"THE NUMBER OF VARIABLES CONTAINED IN A RECORD. CURRENTLY, FOR MODE0-1 "
"FILES A RECORD CONTAINS 7 VARIABLES WHILE FOR MODE2-3 FILES A RECORD "
"CONTAINS 8 VARIABLES. ON SUN SPARC MACHINES, RECORD LENGTH = 4 X # OF"
"VARIABLES IN A RECORD WHILE ON SILICON GRAPHICS RECORD LENGTH = # OF"
"VARIABLES CONTAINED IN A RECORD.             --CMa"


" get arguments from console
" ==========================

" Open file to read
" *****************
"
LOOP [
      OUTPUT NAMEIN;
      (' WELCOME TO USE NRCC PROGRAM "READ PH_ase SPace"!'/
      /' MODE OF INPUT PHASE-SPACE FILE called: ',A70
      /'         ACCESS=DIRECT, THE DEFAULT      ---> 0'
      /'         ACCESS=SEQUENTIAL               ---> 1'
      /'         ACCESS=DIRECT, WITH ZLAST       ---> 2'
      /'         ACCESS=SEQUENTIAL, WITH ZLAST   ---> 3'
      /'  Option:  ',$);
      INPUT INMODE; (I1);
]UNTIL (INMODE >= 0 & INMODE <=3);

IIN=1;"LOGICAL UNIT FOR INPUT"
"IOS=0;start with no error on input"

IF (INMODE = 1)[ "OLD BEAM COMPRESSED FILES"
   OPEN (IIN,FILE=NAMEIN,STATUS='OLD',FORM='UNFORMATTED');
   READ(IIN) MODE;
   IF(MODE ~= 'MODE1')[
       OUTPUT;(//' *** SORRY, THIS IS NOT A MODE1 FILE,',
       ' INPUT A MODE1 FILE AND TRY AGAIN!'/);STOP;
   ]
]
ELSEIF (INMODE = 3)[ "OLD BEAM COMPRESSED FILES WITH ZLAST"
   OPEN (IIN,FILE=NAMEIN,STATUS='OLD',FORM='UNFORMATTED');
   READ(IIN) MODE;
   IF(MODE ~= 'MODE3')[
       OUTPUT;(//' *** SORRY, THIS IS NOT A MODE3 FILE,',
       ' INPUT A MODE3 FILE AND TRY AGAIN!'/);STOP;
   ]
]
ELSE[ "DEFAULT BEAM COMPRESSED FILES"
   $OPEN_PHSP_FOR_READ(INMODE,IIN,NAMEIN,MODE,in_particle_tot,
                       NPHOTON,EMAXK,EMINE,NINC);
   OUTPUT in_particle_tot,NPHOTON,EMAXK,EMINE,NINC;
(//' *** THIS FILE CONTAINS          ',I13,' PARTICLES'/
   '                                 ',I13,' OF THEM ARE PHOTONS'/
   '     MAXIMUM KINETIC ENERGY      ',F13.3,' MeV'/
   '     MINIMUM ENERGY FOR ELECTRONS',F13.3,' MeV'/
   '    ORIGINAL # INCIDENT PARTICLES',F13.1,/);
   IF(in_particle_tot<0|NPHOTON>in_particle_tot|
          NPHOTON<0|EMAXK<0|EMINE>EMAXK|EMINE<0|
          NINC<0)["phase space file may be from another machine--swap bytes"
       OUTPUT;
       (/1x,78('=')/,' IF THE ABOVE INFO IS NONSENSE, CONSIDER BYTE SWAPPING',
                 ' THIS FILE.'/1x,78('=')/);
   ]
]

" Open file to write
" ******************
"
LOOP[
      OUTPUT NAMEOUT;
      (' MODE OF OUTPUT FILE called: ',A70
      /'      ACCESS=DIRECT (DEFAULT)        ---> 0'
      /'      ACCESS=SEQUENTIAL              ---> 1'
      /'      ACCESS=DIRECT, WITH ZLAST      ---> 2'
      /'      ACCESS=SEQUENTIAL, WITH ZLAST  ---> 3'
      /'      PAW FILE                       ---> 4'
      /'      SWAP BYTES--SAME MODE AS INPUT ---> 5'
      /' Option: ',$);
      INPUT OUTMODE; (I1);
]UNTIL (OUTMODE >= 0 & OUTMODE <= 5);

IOUT=2;"LOGICAL UNIT FOR OUTPUT"

IF (OUTMODE = 1)[ "OLD BEAM COMPRESSED FILES"
   OPEN (IOUT,FILE=NAMEOUT,STATUS='NEW',FORM='UNFORMATTED');
   WRITE(IOUT)'MODE1';
   IF(INMODE=2|INMODE=3)[
       OUTPUT;(//' *** ZLAST read in but not written out'/);
   ]
]
ELSEIF (OUTMODE = 0|OUTMODE = 2)[ "DEFAULT BEAM COMPRESSED FILES"
   $OPEN_PHSP_FOR_WRITE(OUTMODE,IOUT,NAMEOUT,MODE);
   IF((INMODE=2|INMODE=3) & OUTMODE=0)[
       OUTPUT;(//' *** ZLAST read in but not written out'/);
   ]
   ELSEIF((INMODE=0|INMODE=1) & OUTMODE=2)[
       OUTPUT;(//' *** OUTPUT of ZLAST requested but not read in. Set 0');
   ]
]
ELSEIF (OUTMODE = 3)[ "OLD BEAM COMPRESSED FILES WITH ZLAST"
   OPEN (IOUT,FILE=NAMEOUT,STATUS='NEW',FORM='UNFORMATTED');
   WRITE(IOUT)'MODE3';
   IF(INMODE=0|INMODE=1)[
       OUTPUT;(//' *** OUTPUT of ZLAST requested but not read in. Set 0');
   ]
]
ELSEIF (OUTMODE = 4)[ "PAW FORMAT"
   CALL HLIMIT($MAX_BUFF);
   NTUPLE=10;

    NTUPLE_CWN=10;
    LRECL=2048; "Use 2048 instead of 1024, to process files up to 200 MB"
    OUTPUT LRECL;(//' USING RECORD LENGTH IN WORDS = ',I8//
                    ' IN PAW USE: HI/FILE 2 PAWFILE 2048 ');

   IF((LRECL.LT.1024).OR.(LRECL.GT.16384))[
      LRECL=1024;
      OUTPUT;(/' RECORD LENGTH DEFAULTED TO 1024!'//);
      ]
   NPRIME=32000;
" RWN   IQUEST(NTUPLE)=$MAX_BUFF;
" RWN   CALL HROPEN(IOUT,'APTUPLE',NAMEOUT,'NQ',LRECL,ISTAT);
" RWN   CALL HBOOKN(NTUPLE,'beam',$NCOLUM,'APTUPLE',NPRIME,CHTAGS);

"CWN:
    CALL HBSET('BSIZE',16384,IERR);
    CALL HROPEN(IOUT,'phasesp',NAMEOUT,'N',LRECL,ISTAT);
    CALL HBNT(NTUPLE_CWN,'BEAM',' ');
    CALL HBNAME(NTUPLE_CWN,'phasesp',e,'e,x,y,zlast,wt,iq:i*4:4,
    latch1:u*4:16,latch2:u*4:16,w,u,v');
]
ELSEIF (OUTMODE = 5)[ "swap bytes--only good with MODE0 and MODE2 files"
    IF(INMODE ~= 0 & INMODE ~=2)[
      OUTPUT;(/' BYTE SWAPPING CAN ONLY BE DONE ON MODE0 AND MODE2 FILES.'/);
      STOP;
    ]
    ELSEIF(NAMEOUT = NAMEIN)["allow the same name" IOUT=IIN; ]
    ELSE[
      $OPEN_PHSP_FOR_WRITE(INMODE,IOUT,NAMEOUT,MODE);
    ]
    $SWAPBYTESINT(in_particle_tot);
    $SWAPBYTESINT(NPHOTON);
    $SWAPBYTESREAL(EMAXK);
    $SWAPBYTESREAL(EMINE);
    $SWAPBYTESREAL(NINC);
    OUTPUT in_particle_tot,NPHOTON,EMAXK,EMINE,NINC;
(//' INFO IN 1ST RECORD OF INPUT FILE AFTER BYTE SWAPPING:'/
   ' *** THIS FILE CONTAINS',I13,' PARTICLES'/
   '                                 ',I13,' OF THEM ARE PHOTONS'/
   '     MAXIMUM KINETIC ENERGY      ',F13.3,' MeV'/
   '     MINIMUM ENERGY FOR ELECTRONS',F13.3,' MeV'/
   '    ORIGINAL # INCIDENT PARTICLES',F13.1,/);
    OUTPUT;(/' You can swap bytes to make a file for the machine you are on'/
             ' because the file was created elsewhere'/
             ' or you can be converting a file to use on another machine'/
             ' Are you swapping bytes to be compatible with a machine'/
             ' other than the one you are running on now? [y/n] :',$);
    INPUT SWAPAWAY;(A1);
    IF (SWAPAWAY='y')[
       $SWAPBYTESINT(in_particle_tot);
       $SWAPBYTESINT(NPHOTON);
       $SWAPBYTESREAL(NINC);
    ]
    ELSE[SWAPAWAY='n';]
]


" Read and write phase-space files
" ********************************
"
OUTPUT; (/' HOW MANY PARTICLE RECORDS TO WRITE (default to 100000000): ',$);
INPUT IWRITEMAX; (I10);
OUTPUT; (/' PARTICLE NUMBER TO START AT (default to 1): ',$);
INPUT IWRITESTART; (I10);
IF(IWRITEMAX <= 0) [
   IF(INMODE=5) [IWRITEMAX = 1000000;] ELSE [IWRITEMAX = 100000000 ;]
]
IF(IWRITESTART <=0 ) IWRITESTART=1;
"BPG"
IF(INMODE=5)IBWRITEMAX=IWRITEMAX+1;
OUTPUT (IWRITEMAX); (/' WILL OUTPUT UP TO ', I10,'  PARTICLE RECORDS');
OUTPUT IWRITESTART; (/' STARTING FROM PARTICLE ',I10);
OUTPUT;(/' PARTICLE TYPE FOR OUTPUT: (-1=e-,0=photon,+1=e+,2=all,3=e-&e+) ',$);
INPUT CHARGE; (I2);
in_particle_so_far=1;
out_part_so_far = 1;   "number of particle records written so far"
                   "recall there is 1 more (non-particle) record at top"
out_phot_so_far=0;
NHSTRY=0; "no. of primary histories represented in phsp file"

LOOP[ "read and write one particle at a time
    IF(INMODE = 1)[ " OLD BEAM-FORMAT, ACCESS=SEQUENTIAL"
        READ (IIN,ERR=:END_OF_FILE:,END=:END_OF_FILE:)
            LATCH,ESHORT,X,Y,U,V,WT;
    ]
    ELSEIF(INMODE = 3)[ " BEAM-FORMAT, ACCESS=SEQUENTIAL WITH ZLAST"
              READ (IIN,ERR=:END_OF_FILE:,END=:END_OF_FILE:)
            LATCH,ESHORT,X,Y,U,V,WT,ZLAST;
    ]
    ELSE[ " DEFAULT BEAM-FORMAT, ACCESS=DIRECT"
        IF(OUTMODE=5)["preserve -E markers + do not advance NHSTRY"
          $READ_PHSP_RECORD_ENEGATIVE(INMODE,IIN,in_particle_so_far+IWRITESTART:
                          ZLAST,LATCH,ESHORT,WT,X,Y,U,V);
        ]
        ELSE["advance NHSTRY, do not preserve -E markers"
          $READ_PHSP_RECORD(INMODE,IIN,in_particle_so_far+IWRITESTART:
                          NHSTRY,ZLAST,LATCH,ESHORT,WT,X,Y,U,V);
        ]
        IF(IERR_PHSP~=0) GOTO :END_OF_FILE:;
        IF(OUTMODE = 5)[
            $SWAPBYTESINT(LATCH);
            $SWAPBYTESREAL(ESHORT);
            IF(ESHORT<0.0)[
               "now advance primary history number and get rid of -E marker"
               NHSTRY=NHSTRY+1;
               ESHORT=ABS(ESHORT);
            ]
            $SWAPBYTESREAL(X);
            $SWAPBYTESREAL(Y);
            $SWAPBYTESREAL(U);
            $SWAPBYTESREAL(V);
            $SWAPBYTESREAL(WT);
            IF(INMODE = 2)[
              $SWAPBYTESREAL(ZLAST);
            ]
        ]
    ]

"if swapping away to another machine, restore the values of
"some variables so that the calculations below make sense

    IF(SWAPAWAY='y')[
       $SWAPBYTESINT(LATCH);
       $SWAPBYTESREAL(WT);
       $SWAPBYTESREAL(ESHORT);
    ]

    "FIND OUT THE CHARGE OF THE PARTICLE"
    IF(INMODE ~= 5)[
       IF($BTEST(LATCH, 30) ) [ IQ=-1; ]   " restore the iq "
       ELSEIF($BTEST(LATCH, 29) ) [ IQ=1; ]
       ELSE[ IQ=0; ]
    ]
    "store some info for averages re inputs"
    "recall that sign of WT is arbitrary here - so use abs"
    tot_wt_read(IQ+2) = tot_wt_read(IQ+2)+ABS(WT);
    tot_num_read(IQ+2) = tot_num_read(IQ+2)+1.0;
    AV_E(IQ+2) = AV_E(IQ+2)+ESHORT*ABS(WT);

"swap stuff back into nonsense mode if swapping away"

    IF(SWAPAWAY='y')[
       $SWAPBYTESINT(LATCH);
       $SWAPBYTESREAL(WT);
       $SWAPBYTESREAL(ESHORT);
    ]

    IF(IQ = CHARGE | CHARGE = 2 | (CHARGE = 3 &ABS(IQ)=1) ) [
        "ONLY STORE THE SELECTED CHARGE"
        IF(OUTMODE = 0 | OUTMODE=2)[ " DEFAULT BEAM-FORMAT, ACCESS=DIRECT"
            $WRITE_PHSP_RECORD(OUTMODE,IOUT,NAMEOUT,out_part_so_far+1,1:
                               NHSTRY,ZLAST,LATCH,ESHORT,WT,X,Y,U,V);
        ]

        ELSEIF(OUTMODE = 1)[ " BEAM-FORMAT, ACCESS=SEQUENTIAL"
            WRITE (IOUT) LATCH,ESHORT,X,Y,U,V,WT;
        ]
        ELSEIF(OUTMODE = 3)[ " BEAM-FORMAT, ACCESS=SEQUENTIAL WITH ZLAST"
            WRITE (IOUT) LATCH,ESHORT,X,Y,U,V,WT,ZLAST;
        ]
        ELSEIF(OUTMODE = 5)[
            $WRITE_PHSP_RECORD(INMODE,IOUT,NAMEOUT,out_part_so_far+1,1:
                               NHSTRY,ZLAST,LATCH,ESHORT,WT,X,Y,U,V);
        ]

        ELSE[" PAW FORMAT"
            "For this output only,  we need to recover the original"
            "phase space values, not the compressed values"
            IF( abs(IQ) = 1) [ ESHORT=ESHORT-0.5109989461; ]
            "until Feb 1995, this was if(iq = -1) => e+ had total energy"
  "RWN          XTUPLE(1) = ESHORT; XTUPLE(2) = X; XTUPLE(3) = Y; XTUPLE(4) = U;
  "RWN          XTUPLE(5) = V;
               LATCH = $IBCLR(LATCH,29);"clear bits used for charge"
               LATCH = $IBCLR(LATCH,30);
               LATCH = $IBCLR( LATCH, 31 ) ;"clear bit used for unused NPASS"
  "RWN          XTUPLE(6) = LATCH;
  "RWN          XTUPLE(7) = IQ;
               "Restore w using technique to ensure precsion near w=1
               W = MIN( 1., U**2 + V**2);
               W = SQRT(1 - W);
               W = SIGN(W,WT);  "This transfers sign of WT to W"
               WT = ABS(WT);   "WT is always positive, sign was just that of W"
  "RWN          XTUPLE(8) = WT;
  "RWN          IF(INMODE=0|INMODE=1|INMODE=5)[ XTUPLE(9) = SQRT(X*X+Y*Y); ]
  "RWN          ELSE[ XTUPLE(9) = ZLAST; ]
  "RWN         XTUPLE(10)= W;

  "RWN          CALL HFN(NTUPLE,XTUPLE);

  "CWN:
             E = ESHORT;
             LATCH1 = iand(LATCH,65535);
             LATCH2 = LATCH/65536;
             CALL HFNT(NTUPLE_CWN)

        ]
        IF(IQ=0) out_phot_so_far=out_phot_so_far+1;
        IF(out_part_so_far >= IWRITEMAX) [GOTO :END_IO: ;]
        out_part_so_far = out_part_so_far + 1;

    ]"END OF SELECTED CHARGE OUTPUT"

    IF(in_particle_so_far = 1)[ OUTPUT; (/' HAVE STARTED PROCESSING. '); ]
    ELSEIF(mod(in_particle_so_far,100000) = 0)[
        OUTPUT in_particle_so_far,out_part_so_far-1;
        (/' HAVE READ ',I10,' PARTICLES AND WRITTEN', I10,' PARTICLES. ');
    ]
    IF(INMODE=0|INMODE=2)["this is a condition for access=direct files"
        IF(in_particle_so_far >= in_particle_tot)[
            out_part_so_far = out_part_so_far - 1;"since was already updated"
            GOTO :END_IO:;"at end of file"
        ]
    ]
    in_particle_so_far=in_particle_so_far+1; "set up for next read"

] "END OF LOOP over particles in"


:END_OF_FILE:
"get here if read end of file"
OUTPUT;(/'  Read to end of input file'//);
in_particle_so_far = in_particle_so_far - 1;
  "sincve had been updated prior to read"
out_part_so_far = out_part_so_far -1;

:END_IO:;
IF(OUTMODE=5)[
  $PHSP_BUFFER_FLUSH(INMODE,IOUT,NAMEOUT,out_part_so_far+1,1);
]
ELSE[
  $PHSP_BUFFER_FLUSH(OUTMODE,IOUT,NAMEOUT,out_part_so_far+1,1);
]

"Record the total number of particles in the first record"
"********************************************************"

OUTPUT in_particle_so_far,out_part_so_far;
(/' HAVE FINISHED READING',I10,' AND WRITING ',I
 "turn internal counters into their nonsensical"
 "values for another machine"10,' PARTICLES.'/);

NPHOTON=out_phot_so_far; "TOTAL NUMBER OF PHOTONS                       "
                         "WE USE THE SAME VALUES FOR EMAXK ,EMINE"
                         "NINC has to be normalized in case we did not"
                         "read all the particles"

NINC=NINC*in_particle_so_far/in_particle_tot;
IF(SWAPAWAY='y')[
   $SWAPBYTESINT(out_part_so_far);
   $SWAPBYTESINT(NPHOTON);
   $SWAPBYTESREAL(NINC);
]

IF(OUTMODE=0)[
   $WRITE_PHSP_HEADER(OUTMODE,IOUT,NAMEOUT,'MODE0',out_part_so_far,NPHOTON,
                      EMAXK,EMINE,NINC);
   ]
ELSEIF(OUTMODE=2)[
   $WRITE_PHSP_HEADER(OUTMODE,IOUT,NAMEOUT,'MODE2',out_part_so_far,NPHOTON,
                      EMAXK,EMINE,NINC);
   ]
ELSEIF(OUTMODE = 5)[
   IF(INMODE=0)[
  $WRITE_PHSP_HEADER(INMODE,IOUT,NAMEOUT,'MODE0',out_part_so_far,NPHOTON,
                     EMAXK,EMINE,NINC);
   ]
   ELSEIF(INMODE=2)[
  $WRITE_PHSP_HEADER(INMODE,IOUT,NAMEOUT,'MODE2',out_part_so_far,NPHOTON,
                     EMAXK,EMINE,NINC);
   ]
]


"Information output"
"******************"

DO I=1, 3[
   IF(tot_wt_read(I)=0.0)[ AV_E(I)=0.0; ]
   ELSE[ AV_E(I)=AV_E(I)/tot_wt_read(I); ]
]

OUTPUT (tot_num_read(I),tot_wt_read(I), AV_E(I),I=1,3),NHSTRY;(//
'              *** INFORMATION ABOUT THE PARTICLES READ IN ***'//
'         ELECTRONS                 PHOTONS                  POSITRONS'/
'number   weight  ave en     number weight  ave en        number weight  ave en'
/
'                  (MeV)                    (MeV)                      (MeV)'/
3(0PF9.0,F9.0,0PF8.3)//
I10,' primary histories represented in particles read in.'//
' HAPPY COMPUTING, BYE!'//);

" Close I/O units
" ***************

CLOSE(IIN);

IF (OUTMODE = 4) [ "PAW format"
  "RWN    CALL HROUT(0,ICYCLE,' ');
  "RWN    CALL HREND('APTUPLE');
     CALL HROUT(NTUPLE_CWN,ICYCLE,' ');
     CALL HREND('phasesp');
]
ELSE[ "all other formats" CLOSE(IOUT); ]

" End of code
" ***********

STOP;

:File-exists:
OUTPUT NAMEOUT;
(' Tried to open following file as new and it was there:'/1x,A70/
 '  Either remove it or re-run with different output file name'/
 '  Output file name(with extension) is 3rd parameter (for byte swapping'/
 '  name can be same as input file name (but overwrites the file!)'//)
STOP;
END;
;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc function to get index of last non-blank character in a string       "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2004                                       "
"                                                                             "
"  Contributors:                                                              "
"                                                                             "
"#############################################################################"


$INTEGER function lnblnk1(string);

"Function to return index of last non-blank character in a string"
"We use this instead of lnblnk because there are compilers"
"that do not have lnblnk"

"******************************************************************************
character*(*) string;
DO i=len(string),1,-1 [
    j = ichar(string(i:i));
    IF( j = 0 ) [ lnblnk1 = i-1; return; ] "i.e. the same as strlen for "
                                           "0-terminated C-strings"
    IF( j ~= 9 & j ~= 10 & j ~= 11 & j ~= 12 & j ~= 13 & j ~= 32 ) [
        lnblnk1 = i; return;
    ]
]
lnblnk1 = 0; return; end;

%%
