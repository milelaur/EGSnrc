      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      COMMON/DATA2/I,J,K,L,M,I0,J0,K0,IMAX,JMAX,KMAX, ICOUNT,INTX,INTY,I
     *NTZ,ISTR,JSTR,LA_AXIS,LTOT, MAX_CURVE,NCURVE,NDIST1,NDIST2,NUM_ARR
     *,NPOINTS,IOPTION,NTYPE_SYMBOL, NTYPE_CURVE,AXISDOSE,DDBIN_CHI,DDBI
     *N_DIFF,DOSE,ERRDOSE,ERRY, FREQ_CHI,FREQ_DIFF,PROFILEDOSE,PROFILERR
     *,TOTALNORM, XCOORD,YCOORD,ZCOORD, XBOUND,YBOUND,ZBOUND,X,Y,VOXEL_M
     *EAS, CURVE_LABELS,CURVE_SPECS,FILEIN,THE_STRING,TITLE,XAXIS,YAXIS,
     * OUTFILE
      INTEGER I,J,K,L,M
      INTEGER I0, J0, K0
      INTEGER IMAX(15),JMAX(15),KMAX(15)
      INTEGER ICOUNT
      INTEGER INTX,INTY,INTZ
      INTEGER ISTR,JSTR
      INTEGER LA_AXIS
      INTEGER LTOT
      INTEGER MAX_CURVE, NCURVE
      INTEGER NDIST1,NDIST2
      INTEGER NUM_ARR(10)
      INTEGER NPOINTS,IOPTION(4)
      INTEGER NTYPE_SYMBOL,NTYPE_CURVE
      REAL AXISDOSE(15,128)
      REAL DDBIN_CHI
      REAL DDBIN_DIFF
      REAL DOSE(15,128,128,128)
      REAL ERRDOSE(15,128,128,128)
      REAL ERRY(400)
      REAL FREQ_CHI(400)
      REAL FREQ_DIFF(400)
      REAL PROFILEDOSE(128+1),PROFILERR(128+1)
      REAL TOTALNORM(15)
      REAL XCOORD, YCOORD, ZCOORD
      REAL XBOUND(15,128+1),YBOUND(15,128+1), ZBOUND(15,128+1)
      REAL X(400),Y(400)
      REAL VOXEL_MEAS
      CHARACTER*60 CURVE_LABELS
      CHARACTER*2 CURVE_SPECS
      CHARACTER*70 FILEIN(15)
      CHARACTER*(10) THE_STRING
      CHARACTER*60 TITLE,XAXIS,YAXIS,OUTFILE,SUBTITLE
      DATA NDIST1_FLAG/15*0/
      DATA TOTALNORM/15*1.0/
      MAX_CURVE = 0
      WRITE(6,1010)
1010  FORMAT(/'*****************************************')
      WRITE(6,1020)
1020  FORMAT('        STATDOSE.MORTRAN')
      WRITE(6,1030)128,128,128
1030  FORMAT('        Max array dimensions:',3I4)
      WRITE(6,1040)15
1040  FORMAT('        Max # data sets:',I3)
      WRITE(6,1050)
1050  FORMAT('*****************************************')
      CALL MAINMENU
      STOP
      END
      SUBROUTINE MAINMENU
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      INTEGER ISELECT
      SAVE
1060  NFLAG = 0
      ISELECT = 0
      WRITE(6,1070)
1070  FORMAT(/' MAIN MENU')
      WRITE(6,1080)
1080  FORMAT(' --------')
      WRITE(6,1090)
1090  FORMAT(' 0 - Exit')
      WRITE(6,1100)
1100  FORMAT(' 1 - Read dose distributions')
      WRITE(6,1110)
1110  FORMAT(' 2 - Statistical analysis')
      WRITE(6,1120)
1120  FORMAT(' 3 - Normalization')
      WRITE(6,1130)
1130  FORMAT(' 4 - Rebinning')
      WRITE(6,1140)
1140  FORMAT(' 5 - Plot')
      WRITE(6,1150)
1150  FORMAT(' 6 - Save'/)
      WRITE(6,1160)
1160  FORMAT(1X,'Selection: ',$)
      READ(5,1170)ISELECT
1170  FORMAT(I5)
      IF ((ISELECT .LT. 0 .OR. ISELECT .GT. 6)) THEN
        GOTO 1060
      ELSE IF((ISELECT .EQ. 0)) THEN
        WRITE(6,1180)
1180    FORMAT(/1X,'Are you sure? (y/n) [y]: ',$)
        READ(5,1190)REPLY
1190    FORMAT(A)
        IF (((REPLY .EQ. 'y') .OR. (REPLY .EQ. CHAR(32)))) THEN
          RETURN
        ELSE
          GOTO 1060
        END IF
      ELSE IF((ISELECT .EQ. 1)) THEN
        CALL READDOSE
      ELSE IF((ISELECT .EQ. 2)) THEN
        DO 1201 N=1,15
          IF (NDIST1_FLAG(N) .EQ. 1) THEN
            NFLAG = NFLAG+1
          END IF
1201    CONTINUE
1202    CONTINUE
        IF ((NFLAG .GT. 1)) THEN
          CALL STATSMENU
        ELSE
          WRITE(6,1210)
1210      FORMAT('Please read in more data before ', 'attempting to do s
     *tats comparisons')
        END IF
      ELSE IF((ISELECT .EQ. 3)) THEN
        DO 1221 N=1,15
          IF (NDIST1_FLAG(N) .EQ. 1) THEN
            NFLAG = 1
          END IF
1221    CONTINUE
1222    CONTINUE
        IF (NFLAG .EQ. 1) THEN
          CALL NORMMENU
        ELSE
          WRITE(6,1230)
1230      FORMAT(1X,'Please read in data before attempting normalization
     *')
        END IF
      ELSE IF((ISELECT .EQ. 4)) THEN
        DO 1241 N=1,15
          IF (NDIST1_FLAG(N) .EQ. 1) THEN
            NFLAG = 1
          END IF
1241    CONTINUE
1242    CONTINUE
        IF (NFLAG.EQ.1) THEN
          CALL REBINNING
        ELSE
          WRITE(6,1250)
1250      FORMAT(1X,'Please read in data before rebinning')
        END IF
      ELSE IF((ISELECT .EQ. 5)) THEN
        DO 1261 N=1,15
          IF (NDIST1_FLAG(N) .EQ. 1) THEN
            NFLAG = 1
          END IF
1261    CONTINUE
1262    CONTINUE
        IF (NFLAG .EQ. 1) THEN
          CALL PLOTMENU
        ELSE
          WRITE(6,1270)
1270      FORMAT(1X,'Please read in data before plotting')
        END IF
      ELSE IF((ISELECT .EQ. 6)) THEN
        DO 1281 N=1,15
          IF (NDIST1_FLAG(N) .EQ. 1) THEN
            NFLAG = 1
          END IF
1281    CONTINUE
1282    CONTINUE
        IF (NFLAG .EQ. 1) THEN
          CALL SAVE
        ELSE
          WRITE(6,1290)
1290      FORMAT(1X,'Please read in data before saving')
        END IF
      END IF
      GOTO 1060
      END
      SUBROUTINE READDOSE
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      COMMON/DATA2/I,J,K,L,M,I0,J0,K0,IMAX,JMAX,KMAX, ICOUNT,INTX,INTY,I
     *NTZ,ISTR,JSTR,LA_AXIS,LTOT, MAX_CURVE,NCURVE,NDIST1,NDIST2,NUM_ARR
     *,NPOINTS,IOPTION,NTYPE_SYMBOL, NTYPE_CURVE,AXISDOSE,DDBIN_CHI,DDBI
     *N_DIFF,DOSE,ERRDOSE,ERRY, FREQ_CHI,FREQ_DIFF,PROFILEDOSE,PROFILERR
     *,TOTALNORM, XCOORD,YCOORD,ZCOORD, XBOUND,YBOUND,ZBOUND,X,Y,VOXEL_M
     *EAS, CURVE_LABELS,CURVE_SPECS,FILEIN,THE_STRING,TITLE,XAXIS,YAXIS,
     * OUTFILE
      INTEGER I,J,K,L,M
      INTEGER I0, J0, K0
      INTEGER IMAX(15),JMAX(15),KMAX(15)
      INTEGER ICOUNT
      INTEGER INTX,INTY,INTZ
      INTEGER ISTR,JSTR
      INTEGER LA_AXIS
      INTEGER LTOT
      INTEGER MAX_CURVE, NCURVE
      INTEGER NDIST1,NDIST2
      INTEGER NUM_ARR(10)
      INTEGER NPOINTS,IOPTION(4)
      INTEGER NTYPE_SYMBOL,NTYPE_CURVE
      REAL AXISDOSE(15,128)
      REAL DDBIN_CHI
      REAL DDBIN_DIFF
      REAL DOSE(15,128,128,128)
      REAL ERRDOSE(15,128,128,128)
      REAL ERRY(400)
      REAL FREQ_CHI(400)
      REAL FREQ_DIFF(400)
      REAL PROFILEDOSE(128+1),PROFILERR(128+1)
      REAL TOTALNORM(15)
      REAL XCOORD, YCOORD, ZCOORD
      REAL XBOUND(15,128+1),YBOUND(15,128+1), ZBOUND(15,128+1)
      REAL X(400),Y(400)
      REAL VOXEL_MEAS
      CHARACTER*60 CURVE_LABELS
      CHARACTER*2 CURVE_SPECS
      CHARACTER*70 FILEIN(15)
      CHARACTER*(10) THE_STRING
      CHARACTER*60 TITLE,XAXIS,YAXIS,OUTFILE,SUBTITLE
      INTEGER NUM,istat,egs_system
      CHARACTER*70 FILENAME(40)
      SAVE
      NUMCHAR = 0
      ICOUNT = 0
1300  istat=egs_system('ls *.3ddose > files')
      IF ((istat.NE.0)) THEN
        WRITE(6,1310)
1310    FORMAT(/' Will assume you are running on a Windows system.'/)
        istat=egs_system('dir /B *.3ddose > files')
      END IF
      IF ((istat.NE.0)) THEN
        WRITE(6,1320)
1320    FORMAT(//' Do not recognize the system you are running on.'/ ' .
     *3ddose files cannot be listed.'//)
        STOP
      END IF
      WRITE(6,1330)
1330  FORMAT(/1X,'READ DOSE DISTRIBUTIONS')
      WRITE(6,1340)
1340  FORMAT(1X,'-----------------------')
      OPEN(UNIT = 8,FILE='files',STATUS = 'UNKNOWN')
1350  CONTINUE
      READ(8,'(A)',END=28) FILENAME(ICOUNT+1)
      FILENAME(ICOUNT+1)=FILENAME(ICOUNT+1)(:index(FILENAME(ICOUNT+1),'.
     *3ddose')-1)
      ICOUNT = ICOUNT+1
      IF ((ICOUNT .EQ. 40)) THEN
        WRITE(6,1360)ICOUNT
1360    FORMAT(//' Have read in ',I4,' .3ddose files, which is the max.n
     *o. possible.'/ ' To read in more, you must increase $MAXFILE andre
     *compile statdose'//)
        GOTO 28
      END IF
      GO TO 1350
28    IF ((ICOUNT .EQ. 0)) THEN
        WRITE(6,1370)
1370    FORMAT(//' no files with extension .3ddose in this directory!'//
     *)
        RETURN
      END IF
      CLOSE(UNIT=8)
      DO 1381 I=1,ICOUNT
        WRITE(6,1390)I,FILENAME(I)
1390    FORMAT(1X,I2,1X,A70)
1381  CONTINUE
1382  CONTINUE
1400  WRITE(6,1410)ICOUNT
1410  FORMAT(/1X,'Input file number to Read in: (1-', I2,' or 0-Main Men
     *u): ',$)
      READ(5,1420)NUM
1420  FORMAT(I2)
      IF ((NUM .EQ. 0)) THEN
        RETURN
      ELSE IF((NUM.GT.ICOUNT)) THEN
        WRITE(6,1430)
1430    FORMAT(1X,'SORRY, THAT IS OUT OF RANGE.')
        GOTO 1400
      END IF
      WRITE(6,1440)15
1440  FORMAT(1X,'File number for temporary storage: (1-', I1,' or 0-Main
     * Menu): ',$)
      READ(5,1450)NDIST1
1450  FORMAT(I2)
      IF ((NDIST1.EQ.0)) THEN
        RETURN
      ELSE IF((NDIST1 .GT. 15)) THEN
        WRITE(6,1460)15
1460    FORMAT(1X,'Max is:',I3,' try again')
        GOTO 1400
      END IF
      NDIST1_FLAG(NDIST1)=1
      CALL LETTERCOUNT(FILENAME(NUM),NUMCHAR)
      FILEIN(NDIST1)= '
     *                     '
      FILEIN(NDIST1)(1:NUMCHAR)=FILENAME(NUM)(1:NUMCHAR)
      OPEN(UNIT=4,FILE=FILEIN(NDIST1)(1:NUMCHAR)//'.3ddose',STATUS='OLD'
     *)
      READ(4,*) IMAX(NDIST1),JMAX(NDIST1),KMAX(NDIST1)
      WRITE(6,1470)IMAX(NDIST1),JMAX(NDIST1),KMAX(NDIST1)
1470  FORMAT(/1X,'Number of voxels in X,Y,Z directions: ',3I10)
      IF ((IMAX(NDIST1) .GT. 128 .OR. JMAX(NDIST1) .GT. 128 .OR. KMAX(ND
     *IST1) .GT. 128)) THEN
        WRITE(6,1480)128,128,128
1480    FORMAT(///' One of dimensions is greater than allowed', ' limits
     * of ', 3I4// ' Adjust in statdose.mortran and recompile')
        STOP
      END IF
      READ(4,*) (XBOUND(NDIST1,I),I=1,IMAX(NDIST1)+1)
      READ(4,*) (YBOUND(NDIST1,I),I=1,JMAX(NDIST1)+1)
      READ(4,*) (ZBOUND(NDIST1,I),I=1,KMAX(NDIST1)+1)
      WRITE(6,1490)XBOUND(NDIST1,1),XBOUND(NDIST1,IMAX(NDIST1)+1)
1490  FORMAT(1X,'Voxel-boundary values in X-direction: ' ,F10.2,2X,'-',F
     *7.2)
      WRITE(6,1500)YBOUND(NDIST1,1),YBOUND(NDIST1,JMAX(NDIST1)+1)
1500  FORMAT(1X,'Voxel-boundary values in Y-direction: ' ,F10.2,2X,'-',F
     *7.2)
      WRITE(6,1510)ZBOUND(NDIST1,1),ZBOUND(NDIST1,KMAX(NDIST1)+1)
1510  FORMAT(1X,'Voxel-boundary values in Z-direction: ' ,F10.2,2X,'-',F
     *7.2)
      WRITE(6,1520)
1520  FORMAT(1X,'Reading dose distribution...')
      READ(4,*) (((DOSE(NDIST1,I,J,K),I=1,IMAX(NDIST1)),J=1,JMAX(NDIST1)
     *),K=1,KMAX(NDIST1))
      WRITE(6,1530)
1530  FORMAT(1X,'Reading in the uncertainties on DOSE Distribution...')
      READ(4,*) (((ERRDOSE(NDIST1,I,J,K),I=1,IMAX(NDIST1)),J=1,JMAX(NDIS
     *T1)),K=1,KMAX(NDIST1))
      DO 1541 I=1,IMAX(NDIST1)
        DO 1551 J=1,JMAX(NDIST1)
          DO 1561 K=1,KMAX(NDIST1)
            ERRDOSE(NDIST1,I,J,K)=DOSE(NDIST1,I,J,K)*ERRDOSE(NDIST1,I,J,
     *      K)
1561      CONTINUE
1562      CONTINUE
1551    CONTINUE
1552    CONTINUE
1541  CONTINUE
1542  CONTINUE
      CLOSE(UNIT=4)
      WRITE(6,1570)
1570  FORMAT(/1X,'Have read dose distributions')
      WRITE(6,1580)
1580  FORMAT(1X,'-----------------------')
      DO 1591 I=1,ICOUNT
        WRITE(6,1600)I,FILENAME(I)
1600    FORMAT(1X,I2,1X,A70)
1591  CONTINUE
1592  CONTINUE
      GOTO 1400
      END
      SUBROUTINE STATSMENU
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      INTEGER ISELECT1, ISELECT2
      SAVE
1610  NFLAG = 0
      ISELECT1 = 0
      WRITE(6,1620)
1620  FORMAT(/' STATS MENU')
      WRITE(6,1630)
1630  FORMAT(' ---------')
      WRITE(6,1640)
1640  FORMAT(' 0 - Return to main menu')
      WRITE(6,1650)
1650  FORMAT(' 1 - Plot frequency vs. D1-D2')
      WRITE(6,1660)
1660  FORMAT(' 2 - Plot frequency vs. (D1-D2)/[(D1+D2)/2] * 100%')
      WRITE(6,1670)
1670  FORMAT(' 3 - Plot frequency vs. (D1-D2)/max central axis dose * 10
     *0%')
      WRITE(6,1680)
1680  FORMAT(' 4 - Plot frequency vs. (D1-D2)/sqrt(err1**2+err2**2)')
      WRITE(6,1690)
1690  FORMAT(/1X,'Selection: ',$)
      READ(5,1700)ISELECT1
1700  FORMAT(I5)
      IF ((ISELECT1.LT.0.OR.ISELECT1.GT.4)) THEN
        GOTO 1610
      ELSE IF((ISELECT1 .EQ. 0)) THEN
        RETURN
      END IF
1710  ISELECT2 = 0
      WRITE(6,1720)
1720  FORMAT(/' STATS OPTIONS')
      WRITE(6,1730)
1730  FORMAT(' -------')
      WRITE(6,1740)
1740  FORMAT(' 0 - Return to STATS MENU')
      WRITE(6,1750)
1750  FORMAT(' 1 - Limit frequency distribution to maximum dose differen
     *ce'/ '      or max % dose difference')
      WRITE(6,1760)
1760  FORMAT(' 2 - Limit frequency distribution to (maximum dose)/10')
      WRITE(6,1770)
1770  FORMAT(' 3 - Custom bin width')
      WRITE(6,1780)
1780  FORMAT(/1X,'Selection: ',$)
      READ(5,1790)ISELECT2
1790  FORMAT(I5)
      IF ((ISELECT2.LT.0.OR.ISELECT2.GT.3)) THEN
        GOTO 1710
      ELSE IF((ISELECT2 .EQ. 0)) THEN
        GOTO 1610
      ELSE IF((ISELECT2 .EQ. 2 .AND. ISELECT1 .GT. 1)) THEN
        WRITE(6,1800)
1800    FORMAT(' Binning with respect to max dose does not make sense '/
     *' when plotting frequency vs. % dose differences.'/ ' Choose anoth
     *er binning option:'/)
        GOTO 1710
      ELSE
        CALL STATS(ISELECT1,ISELECT2)
      END IF
      GOTO 1610
      END
      SUBROUTINE STATS(LA_TYPE,LA_DELTA)
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      COMMON/DATA2/I,J,K,L,M,I0,J0,K0,IMAX,JMAX,KMAX, ICOUNT,INTX,INTY,I
     *NTZ,ISTR,JSTR,LA_AXIS,LTOT, MAX_CURVE,NCURVE,NDIST1,NDIST2,NUM_ARR
     *,NPOINTS,IOPTION,NTYPE_SYMBOL, NTYPE_CURVE,AXISDOSE,DDBIN_CHI,DDBI
     *N_DIFF,DOSE,ERRDOSE,ERRY, FREQ_CHI,FREQ_DIFF,PROFILEDOSE,PROFILERR
     *,TOTALNORM, XCOORD,YCOORD,ZCOORD, XBOUND,YBOUND,ZBOUND,X,Y,VOXEL_M
     *EAS, CURVE_LABELS,CURVE_SPECS,FILEIN,THE_STRING,TITLE,XAXIS,YAXIS,
     * OUTFILE
      INTEGER I,J,K,L,M
      INTEGER I0, J0, K0
      INTEGER IMAX(15),JMAX(15),KMAX(15)
      INTEGER ICOUNT
      INTEGER INTX,INTY,INTZ
      INTEGER ISTR,JSTR
      INTEGER LA_AXIS
      INTEGER LTOT
      INTEGER MAX_CURVE, NCURVE
      INTEGER NDIST1,NDIST2
      INTEGER NUM_ARR(10)
      INTEGER NPOINTS,IOPTION(4)
      INTEGER NTYPE_SYMBOL,NTYPE_CURVE
      REAL AXISDOSE(15,128)
      REAL DDBIN_CHI
      REAL DDBIN_DIFF
      REAL DOSE(15,128,128,128)
      REAL ERRDOSE(15,128,128,128)
      REAL ERRY(400)
      REAL FREQ_CHI(400)
      REAL FREQ_DIFF(400)
      REAL PROFILEDOSE(128+1),PROFILERR(128+1)
      REAL TOTALNORM(15)
      REAL XCOORD, YCOORD, ZCOORD
      REAL XBOUND(15,128+1),YBOUND(15,128+1), ZBOUND(15,128+1)
      REAL X(400),Y(400)
      REAL VOXEL_MEAS
      CHARACTER*60 CURVE_LABELS
      CHARACTER*2 CURVE_SPECS
      CHARACTER*70 FILEIN(15)
      CHARACTER*(10) THE_STRING
      CHARACTER*60 TITLE,XAXIS,YAXIS,OUTFILE,SUBTITLE
      INTEGER LA_TYPE,LA_DELTA
      INTEGER ILO,IHI,JLO,JHI,LL,KDMAX
      REAL CHI,DIFF,DIFFMAX,DIFFSQ,DOSEMAX,DOSE_STORE,DOSES,ERRDIFFSQ,RM
     *S,temp
      SAVE
1810  CHI = 0.0
      DIFFMAX = 0.0
      DIFFSQ = 0.0
      DOSEMAX = 0.0
      DOSES = 0.0
      KDMAX = 0
      LL = 0
      LTOT = 0
      RMS = 0.0
      DO 1821 I=1,400
        FREQ_DIFF(I) = 0.0
        FREQ_CHI(I) = 0.0
1821  CONTINUE
1822  CONTINUE
      WRITE(6,1830)
1830  FORMAT(/1X,'STATISTICAL ANALYSIS')
      WRITE(6,1840)
1840  FORMAT(1X,'--------------------')
1850  WRITE(6,1860)
1860  FORMAT(1X,'Files currently loaded:'/)
      DO 1871 N=1,15
        IF (NDIST1_FLAG(N) .EQ. 1) THEN
          WRITE(6,1880)N,FILEIN(N)
1880      FORMAT(I2,' - ',A)
        END IF
1871  CONTINUE
1872  CONTINUE
      WRITE(6,1890)
1890  FORMAT(/1X,'File #1 for analysis: (0-MainMenu): ',$)
      READ(5,1900)NDIST1
1900  FORMAT(I2)
      IF (NDIST1 .EQ. 0) THEN
        RETURN
      ELSE IF((NDIST1 .GT. 15)) THEN
        WRITE(6,1910)
1910    FORMAT(1X,'Sorry, that is out of range.'/)
        GOTO 1850
      END IF
      WRITE(6,1920)
1920  FORMAT(1X,'File #2 for analysis: (0-MainMenu): ',$)
      READ(5,1930)NDIST2
1930  FORMAT(I2)
      IF (NDIST2 .EQ. 0) THEN
        RETURN
      ELSE IF(NDIST2.GT.15) THEN
        WRITE(6,1940)
1940    FORMAT(1X,'Sorry, that is out of range.'/)
        GOTO 1850
      END IF
      IF (IMAX(NDIST1).NE.IMAX(NDIST2)) THEN
        WRITE(6,1950)
1950    FORMAT(1X, 'BINNING STRUCTURES INCOMPATIBLE, PLEASE SELECT AGAIN
     *.')
        GOTO 1850
      END IF
      DO 1961 I=1,IMAX(NDIST1)
        IF (XBOUND(NDIST1,I).NE.XBOUND(NDIST2,I)) THEN
          WRITE(6,1970)
1970      FORMAT(' BINNING STRUCTURES INCOMPATIBLE, PLEASE SELECT AGAIN.
     *')
          GOTO 1850
        END IF
1961  CONTINUE
1962  CONTINUE
      IF (JMAX(NDIST1).NE.JMAX(NDIST2)) THEN
        WRITE(6,1980)
1980    FORMAT(1X, 'BINNING STRUCTURES INCOMPATIBLE, PLEASE SELECT AGAIN
     *.')
        GOTO 1850
      END IF
      DO 1991 J=1,JMAX(NDIST1)
        IF (YBOUND(NDIST1,J).NE.YBOUND(NDIST2,J)) THEN
          WRITE(6,2000)
2000      FORMAT(' BINNING STRUCTURES INCOMPATIBLE, PLEASE SELECT AGAIN.
     *')
          GOTO 1850
        END IF
1991  CONTINUE
1992  CONTINUE
      IF (KMAX(NDIST1).NE.KMAX(NDIST2)) THEN
        WRITE(6,2010)
2010    FORMAT(1X, 'BINNING STRUCTURES INCOMPATIBLE, PLEASE SELECT AGAIN
     *.')
        GOTO 1850
      END IF
      DO 2021 K=1,KMAX(NDIST1)
        IF (ZBOUND(NDIST1,K).NE.ZBOUND(NDIST2,K)) THEN
          WRITE(6,2030)
2030      FORMAT(' BINNING STRUCTURES INCOMPATIBLE, PLEASE SELECT AGAIN.
     *')
          GOTO 1850
        END IF
2021  CONTINUE
2022  CONTINUE
      WRITE(6,2040)
2040  FORMAT(1X,'Binning structure are the same, i.e. OK. ', 'Proceeding
     * with stats routine...')
2050  WRITE(6,2060)400
2060  FORMAT(/1X,'Maximum bins  =  ',I3)
      WRITE(6,2070)
2070  FORMAT(1X,'Input number of bins in frequency distribution [default
     * 101]: ',$)
      READ(5,2080)LTOT
2080  FORMAT(I3)
      IF (LTOT .EQ. 0) THEN
        LTOT = 101
      ELSE IF(LTOT.GT.400) THEN
        WRITE(6,2090)
2090    FORMAT(1X,'Too many bins. Please re-enter.')
        GOTO 2050
      ELSE IF(MOD(LTOT,2) .EQ. 0) THEN
        WRITE(6,2100)
2100    FORMAT(' Must have an odd # bins. Please re-enter.')
        GOTO 2050
      END IF
      DDBIN_CHI = 10./LTOT
      IF ((MOD(IMAX(NDIST1),2)) .EQ. 0) THEN
        ILO = IMAX(NDIST1)/2
        IHI = IMAX(NDIST1)/2+1
      ELSE
        ILO = IMAX(NDIST1)/2+1
        IHI = IMAX(NDIST1)/2+1
      END IF
      IF ((MOD(JMAX(NDIST1),2)) .EQ. 0) THEN
        JLO = JMAX(NDIST1)/2
        JHI = JMAX(NDIST1)/2+1
      ELSE
        JLO = JMAX(NDIST1)/2+1
        JHI = JMAX(NDIST1)/2+1
      END IF
      DO 2111 K=1,KMAX(NDIST1)
        DOSE_STORE = 0
        DO 2121 I=ILO,IHI
          DO 2131 J=JLO,JHI
            DOSE_STORE = DOSE(NDIST1,I,J,K)+DOSE_STORE
2131      CONTINUE
2132      CONTINUE
2121    CONTINUE
2122    CONTINUE
        DOSE_STORE = DOSE_STORE/((IHI-ILO+1)*(JHI-JLO+1))
        AXISDOSE(NDIST1,K) = DOSE_STORE
2111  CONTINUE
2112  CONTINUE
      IF ((MOD(IMAX(NDIST2),2)) .EQ. 0) THEN
        ILO = IMAX(NDIST2)/2
        IHI = IMAX(NDIST2)/2+1
      ELSE
        ILO = IMAX(NDIST2)/2+1
        IHI = IMAX(NDIST2)/2+1
      END IF
      IF ((MOD(JMAX(NDIST2),2)) .EQ. 0) THEN
        JLO = JMAX(NDIST2)/2
        JHI = JMAX(NDIST2)/2+1
      ELSE
        JLO = JMAX(NDIST2)/2+1
        JHI = JMAX(NDIST2)/2+1
      END IF
      DO 2141 K=1,KMAX(NDIST2)
        DOSE_STORE = 0
        DO 2151 I=ILO,IHI
          DO 2161 J=JLO,JHI
            DOSE_STORE = DOSE(NDIST2,I,J,K)+DOSE_STORE
2161      CONTINUE
2162      CONTINUE
2151    CONTINUE
2152    CONTINUE
        DOSE_STORE = DOSE_STORE/((IHI-ILO+1)*(JHI-JLO+1))
        AXISDOSE(NDIST2,K) = DOSE_STORE
2141  CONTINUE
2142  CONTINUE
      I0 = 0
      J0 = 0
      K0 = 0
      DO 2171 K=1,KMAX(NDIST1)
        DO 2181 I=1,IMAX(NDIST1)
          DO 2191 J=1,JMAX(NDIST1)
            DIFF = DOSE(NDIST1,I,J,K)-DOSE(NDIST2,I,J,K)
            DIFFSQ = DIFF*DIFF
            IF ((DOSE(NDIST1,I,J,K).NE.0. .AND. DOSE(NDIST2,I,J,K).NE.0.
     *      )) THEN
              DOSES = DOSES+1
              RMS = DIFFSQ + RMS
              CHI = CHI + DIFFSQ/ (ERRDOSE(NDIST1,I,J,K)**2+ERRDOSE(NDIS
     *        T2,I,J,K)**2)
              IF ((LA_TYPE .EQ. 1 .OR. LA_TYPE .EQ. 3)) THEN
                IF (ABS(DIFF).GT.DIFFMAX) THEN
                  DIFFMAX = ABS(DIFF)
                  I0 = I
                  J0 = J
                  K0 = K
                END IF
              END IF
              IF ((LA_TYPE .EQ. 2)) THEN
                IF ((ABS(DIFF*2/(DOSE(NDIST1,I,J,K)+DOSE(NDIST2,I,J,K)))
     *           .GT.DIFFMAX)) THEN
                  DIFFMAX = ABS(DIFF*2/ (DOSE(NDIST1,I,J,K)+DOSE(NDIST2,
     *            I,J,K)))
                  I0 = I
                  J0 = J
                  K0 = K
                END IF
              END IF
              IF ((LA_TYPE .EQ. 4)) THEN
                temp= ABS(DIFF)/ SQRT(ERRDOSE(NDIST1,I,J,K)**2+ERRDOSE(N
     *          DIST2,I,J,K)**2)
                IF (( temp .GT. DIFFMAX)) THEN
                  DIFFMAX = temp
                  I0 = I
                  J0 = J
                  K0 = K
                END IF
              END IF
            END IF
2191      CONTINUE
2192      CONTINUE
2181    CONTINUE
2182    CONTINUE
        IF (((AXISDOSE(NDIST1,K)+AXISDOSE(NDIST2,K))/2).GT.DOSEMAX) THEN
          DOSEMAX = (AXISDOSE(NDIST1,K)+AXISDOSE(NDIST2,K))/2
          KDMAX = K
        END IF
2171  CONTINUE
2172  CONTINUE
      IF (LA_DELTA .EQ. 1) THEN
        IF ((LA_TYPE .EQ. 1 .OR. LA_TYPE .EQ. 4)) THEN
          DDBIN_DIFF = 2*DIFFMAX/LTOT
        ELSE IF((LA_TYPE .EQ. 2)) THEN
          DDBIN_DIFF = 2*DIFFMAX*100./LTOT
        ELSE IF((LA_TYPE .EQ. 3)) THEN
          DDBIN_DIFF = 2*DIFFMAX*100./DOSEMAX/LTOT
        END IF
      ELSE IF(LA_DELTA .EQ. 2) THEN
        DDBIN_DIFF = DOSEMAX/INT(LTOT/2-1)*10.
      ELSE IF(LA_DELTA .EQ. 3) THEN
        WRITE(6,2200)
2200    FORMAT(1X,'Bin width in dose or % dose difference units: ',$)
        READ(5,2210)DDBIN_DIFF
2210    FORMAT(F10.0)
      END IF
      DO 2221 I=1,IMAX(NDIST1)
        DO 2231 J=1,JMAX(NDIST1)
          DO 2241 K=1,KMAX(NDIST1)
            IF ((DOSE(NDIST1,I,J,K).NE.0..AND.DOSE(NDIST2,I,J,K).NE.0.))
     *       THEN
              DIFF = DOSE(NDIST1,I,J,K)-DOSE(NDIST2,I,J,K)
              DIFFSQ = DIFF**2
              ERRDIFFSQ = ERRDOSE(NDIST1,I,J,K)*ERRDOSE(NDIST1,I,J,K)+ E
     *        RRDOSE(NDIST2,I,J,K)*ERRDOSE(NDIST2,I,J,K)
              IF ((LA_TYPE .EQ. 2)) THEN
                DIFF = DIFF*2*100./(DOSE(NDIST1,I,J,K)+DOSE(NDIST2,I,J,K
     *          ))
              ELSE IF((LA_TYPE .EQ. 3)) THEN
                DIFF = DIFF*100./DOSEMAX
              ELSE IF((LA_TYPE .EQ. 4)) THEN
                DIFF = DIFF/SQRT(ERRDIFFSQ)
              END IF
              LL = NINT(DIFF/DDBIN_DIFF)+NINT(LTOT/2.)
              IF ((LL.GT.LTOT)) THEN
                LL = LTOT
              ELSE IF((LL.LT.1)) THEN
                LL = 1
              END IF
              FREQ_DIFF(LL) = FREQ_DIFF(LL)+1
              LL = INT(DIFFSQ/ERRDIFFSQ/DDBIN_CHI)+1
              IF ((LL.GT.LTOT)) THEN
                LL = LTOT
              ELSE IF((LL.LT.1)) THEN
                LL = 1
              END IF
              FREQ_CHI(LL) = FREQ_CHI(LL)+1
            END IF
2241      CONTINUE
2242      CONTINUE
2231    CONTINUE
2232    CONTINUE
2221  CONTINUE
2222  CONTINUE
      IF (DOSES.NE.0) THEN
        RMS = RMS/DOSES
        RMS = SQRT(RMS)
        CHI = CHI/DOSES
        DO 2251 LL=1,LTOT
          FREQ_DIFF(LL) = FREQ_DIFF(LL)/DOSES
          FREQ_CHI(LL) = FREQ_CHI(LL)/DOSES
2251    CONTINUE
2252    CONTINUE
      END IF
      WRITE(6,2260)CHI
2260  FORMAT(/1X,'Chi-squared per degree of freedom: ',G10.3)
      WRITE(6,2270)RMS
2270  FORMAT(1X,'RMS:                               ',G10.3)
      WRITE(6,2280)DOSES/(IMAX(NDIST1)*JMAX(NDIST1)*KMAX(NDIST1)),IFIX(D
     *OSES), (IMAX(NDIST1)*JMAX(NDIST1)*KMAX(NDIST1))
2280  FORMAT(/1X,'Ratio of voxels containing dose to total voxels:',G10.
     *3/ 1x,'Number of voxels containing dose:             ',I12/ 1x,'To
     *tal number of voxels:                       ',I12)
      IF ((LA_TYPE .EQ. 1)) THEN
        WRITE(6,2290)DIFFMAX
2290    FORMAT(/1X,'Maximum dose diff =  ',G10.2,' Gy * cm**2')
      ELSE IF((LA_TYPE .EQ. 2)) THEN
        WRITE(6,2300)DIFFMAX * 100.
2300    FORMAT(/1X,'Maximum (D1-D2)/[(D1+D2)/2]  =  ',G10.2,' %')
      ELSE IF((LA_TYPE .EQ. 3)) THEN
        WRITE(6,2310)DIFFMAX/DOSEMAX * 100.
2310    FORMAT(/1X,'Maximum (D1-D2)/max central axis dose  =  ',G10.2,'%
     *')
      ELSE IF((LA_TYPE .EQ. 4)) THEN
        WRITE(6,2320)DIFFMAX
2320    FORMAT(/1X,'Maximum (D1-D2)/sqrt(err1**2+err2**2)  =  ',G10.2)
      END IF
      IF ((I0 .EQ. 0) .AND. (J0 .EQ. 0) .AND. (K0 .EQ. 0)) THEN
        WRITE(6,2330)
2330    FORMAT(1X,'No differences in any values.')
      ELSE
        WRITE(6,2340)I0,J0,K0
2340    FORMAT(1X,'Occurs at voxel: ',3I9)
        WRITE(6,2350)XBOUND(NDIST1,I0),XBOUND(NDIST1,I0+1),YBOUND(NDIST1
     *  ,J0), YBOUND(NDIST1,J0+1),ZBOUND(NDIST1,K0),ZBOUND(NDIST1,K0+1)
2350    FORMAT(1X,'Coordinates:',3(2X,F5.1,',',F5.1))
        WRITE(6,2360)DOSE(NDIST1,I0,J0,K0),ERRDOSE(NDIST1,I0,J0,K0), DOS
     *  E(NDIST2,I0,J0,K0),ERRDOSE(NDIST2,I0,J0,K0)
2360    FORMAT(1x,'Doses:',2(G10.3,'+-',G10.3))
      END IF
      WRITE(6,2370)DOSEMAX
2370  FORMAT(/1X,'Maximum dose along central axis is:',G10.2)
      XCOORD = 0.0
      YCOORD = 0.0
      DO 2381 I0=2,IMAX(NDIST1)
        VOXEL_MEAS = XBOUND(NDIST1,I0)
        IF ((VOXEL_MEAS.GT.XCOORD)) THEN
          GO TO2382
        END IF
2381  CONTINUE
2382  CONTINUE
      I0 = I0-1
      DO 2391 J0=2,JMAX(NDIST1)
        VOXEL_MEAS = YBOUND(NDIST1,J0)
        IF ((VOXEL_MEAS.GT.YCOORD)) THEN
          GO TO2392
        END IF
2391  CONTINUE
2392  CONTINUE
      J0 = J0-1
      WRITE(6,2400)I0,J0,KDMAX
2400  FORMAT(1X,'Occurs at voxel: ',3I9)
      WRITE(6,2410)XBOUND(NDIST1,I0),XBOUND(NDIST1,I0+1), YBOUND(NDIST1,
     *J0),YBOUND(NDIST1,J0+1),ZBOUND(NDIST1,KDMAX), ZBOUND(NDIST1,KDMAX+
     *1)
2410  FORMAT(1X,'Coordinates:',3(2X,F5.1,',',F5.1))
      WRITE(6,2420)DOSE(NDIST1,I0,J0,KDMAX),ERRDOSE(NDIST1,I0,J0,KDMAX),
     * DOSE(NDIST2,I0,J0,KDMAX),ERRDOSE(NDIST2,I0,J0,KDMAX)
2420  FORMAT(1x,'Doses:',2(G10.3,'+-',G10.3))
      CALL PLOTFREQ(LA_TYPE)
      RETURN
      END
      SUBROUTINE PLOTFREQ(X_TYPE)
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      COMMON/DATA2/I,J,K,L,M,I0,J0,K0,IMAX,JMAX,KMAX, ICOUNT,INTX,INTY,I
     *NTZ,ISTR,JSTR,LA_AXIS,LTOT, MAX_CURVE,NCURVE,NDIST1,NDIST2,NUM_ARR
     *,NPOINTS,IOPTION,NTYPE_SYMBOL, NTYPE_CURVE,AXISDOSE,DDBIN_CHI,DDBI
     *N_DIFF,DOSE,ERRDOSE,ERRY, FREQ_CHI,FREQ_DIFF,PROFILEDOSE,PROFILERR
     *,TOTALNORM, XCOORD,YCOORD,ZCOORD, XBOUND,YBOUND,ZBOUND,X,Y,VOXEL_M
     *EAS, CURVE_LABELS,CURVE_SPECS,FILEIN,THE_STRING,TITLE,XAXIS,YAXIS,
     * OUTFILE
      INTEGER I,J,K,L,M
      INTEGER I0, J0, K0
      INTEGER IMAX(15),JMAX(15),KMAX(15)
      INTEGER ICOUNT
      INTEGER INTX,INTY,INTZ
      INTEGER ISTR,JSTR
      INTEGER LA_AXIS
      INTEGER LTOT
      INTEGER MAX_CURVE, NCURVE
      INTEGER NDIST1,NDIST2
      INTEGER NUM_ARR(10)
      INTEGER NPOINTS,IOPTION(4)
      INTEGER NTYPE_SYMBOL,NTYPE_CURVE
      REAL AXISDOSE(15,128)
      REAL DDBIN_CHI
      REAL DDBIN_DIFF
      REAL DOSE(15,128,128,128)
      REAL ERRDOSE(15,128,128,128)
      REAL ERRY(400)
      REAL FREQ_CHI(400)
      REAL FREQ_DIFF(400)
      REAL PROFILEDOSE(128+1),PROFILERR(128+1)
      REAL TOTALNORM(15)
      REAL XCOORD, YCOORD, ZCOORD
      REAL XBOUND(15,128+1),YBOUND(15,128+1), ZBOUND(15,128+1)
      REAL X(400),Y(400)
      REAL VOXEL_MEAS
      CHARACTER*60 CURVE_LABELS
      CHARACTER*2 CURVE_SPECS
      CHARACTER*70 FILEIN(15)
      CHARACTER*(10) THE_STRING
      CHARACTER*60 TITLE,XAXIS,YAXIS,OUTFILE,SUBTITLE
      INTEGER NUM1,NUM2,X_TYPE
      REAL XMIN
      SAVE
      CALL LETTERCOUNT(FILEIN(NDIST1),NUM1)
      CALL LETTERCOUNT(FILEIN(NDIST2),NUM2)
      TITLE = 'frequency distribution of '//FILEIN(NDIST1)(1:MIN(10,NUM1
     *))// ' / '//FILEIN(NDIST2)(1:MIN(10,NUM2))
      IF ((X_TYPE .EQ. 1)) THEN
        XAXIS=' D1 - D2  /Gy * cm**2)'
      ELSE IF((X_TYPE .EQ. 2)) THEN
        XAXIS=' (D1-D2)/[(D1+D2)/2] * 100%'
      ELSE IF((X_TYPE .EQ. 3)) THEN
        XAXIS=' (D1-D2)/DsmaxN * 100%'
      ELSE IF((X_TYPE .EQ. 4)) THEN
        XAXIS=' (D1-D2)/sqrt(err1**2+err2**2)'
      END IF
      YAXIS=' normalized frequency distribution'
      DO 2431 L=1,4
        IOPTION(L) = 0
2431  CONTINUE
2432  CONTINUE
      WRITE(6,2440)
2440  FORMAT(/1X,'Output Filename (default=freqdist1): ',$)
      READ(5,2450)OUTFILE
2450  FORMAT(A)
      IF (OUTFILE .EQ. ' ') THEN
        OUTFILE = 'freqdist1'
      END IF
      outfile=outfile(1:lnblnk1(outfile))//'.agr'
      OPEN(UNIT=7,STATUS='UNKNOWN',FILE=outfile)
      IF ((X_TYPE .EQ. 1)) THEN
        CURVE_LABELS='dose difference'
      END IF
      IF ((X_TYPE .EQ. 2.OR.X_TYPE .EQ. 3)) THEN
        CURVE_LABELS='% dose difference'
      ELSE IF((X_TYPE .EQ. 4)) THEN
        CURVE_LABELS='dose difference/sqrt(err1**2+err**2)'
      END IF
      NTYPE_SYMBOL = 1
      NTYPE_CURVE = 1
      CURVE_SPECS = CHAR(NTYPE_SYMBOL+48)//CHAR(NTYPE_CURVE+48)
      NPOINTS = LTOT
      NCURVE = 1
      DO 2461 L=1,LTOT
        X(L) = DDBIN_DIFF*(L-(LTOT/2)-1)
        Y(L) = FREQ_DIFF(L)
        ERRY(L) = 0.0
2461  CONTINUE
2462  CONTINUE
      SUBTITLE=' '
      XMIN=0.
      CALL XVGRPLOT(X,Y,ERRY,NPOINTS,NCURVE-1,CURVE_LABELS, XAXIS,YAXIS,
     *TITLE,SUBTITLE,7,IOPTION(1),XMIN,IOPTION(2))
      WRITE(6,2470)
2470  FORMAT(/1X,'Calling xmgrace...please be patient! ')
      CLOSE(7)
      CALL XVGR_SCRIPT
      WRITE(6,2480)
2480  FORMAT(/1X,'Output Filename (default = freqdist2): ',$)
      READ(5,2490)OUTFILE
2490  FORMAT(A)
      IF (OUTFILE .EQ. ' ') THEN
        OUTFILE = 'freqdist2'
      END IF
      outfile=outfile(1:lnblnk1(outfile))//'.agr'
      OPEN(UNIT=7,STATUS='UNKNOWN',FILE=outfile)
      XAXIS=' chi-squared'
      CURVE_LABELS='square of difference over error'
      NTYPE_SYMBOL = 1
      NTYPE_CURVE = 1
      CURVE_SPECS = CHAR(NTYPE_SYMBOL+48)//CHAR(NTYPE_CURVE+48)
      NPOINTS = LTOT
      NCURVE = 1
      DO 2501 L=1,LTOT
        X(L) = DDBIN_CHI*(L-0.5)
        Y(L) = FREQ_CHI(L)
        ERRY(L) = 0.0
2501  CONTINUE
2502  CONTINUE
      SUBTITLE=' '
      XMIN=0.
      CALL XVGRPLOT(X,Y,ERRY,NPOINTS,NCURVE-1,CURVE_LABELS, XAXIS,YAXIS,
     *TITLE,SUBTITLE,7,IOPTION(1),XMIN,IOPTION(2))
      WRITE(6,2510)
2510  FORMAT(/1X,'Calling xmgrace...please be patient! ')
      CLOSE(7)
      CALL XVGR_SCRIPT
      RETURN
      END
      SUBROUTINE NORMMENU
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      INTEGER ISELECT
      SAVE
      EXTERNAL SCALE
2520  NFLAG = 0
      ISELECT = 0
      WRITE(6,2530)
2530  FORMAT(/1X,'NORM MENU')
      WRITE(6,2540)
2540  FORMAT(1X,'--------')
      WRITE(6,2550)
2550  FORMAT(1X,'0 - Main menu')
      WRITE(6,2560)
2560  FORMAT(1X,'1 - Apply scaling factor')
      WRITE(6,2570)
2570  FORMAT(1X,'2 - Normalize to average dose')
      WRITE(6,2580)
2580  FORMAT(1X,'3 - Normalize to maximum dose along central axis')
      WRITE(6,2590)
2590  FORMAT(1X,'4 - Normalize to dose in specific voxel')
      WRITE(6,2600)
2600  FORMAT(1X,'5 - Denormalize')
      WRITE(6,2610)
2610  FORMAT(/1X,'Selection: ',$)
      READ(5,2620)ISELECT
2620  FORMAT(I5)
      IF ((ISELECT.LT.0.OR.ISELECT.GT.5)) THEN
        GOTO 2520
      ELSE IF((ISELECT .EQ. 0)) THEN
        RETURN
      ELSE IF((ISELECT .EQ. 1)) THEN
        CALL SCALE
      ELSE IF((ISELECT .EQ. 2)) THEN
        CALL AVERAGEDOSE
      ELSE IF((ISELECT .EQ. 3)) THEN
        CALL CENTRALMAX
      ELSE IF((ISELECT .EQ. 4)) THEN
        CALL SPECVOXEL
      ELSE IF((ISELECT .EQ. 5)) THEN
        CALL DENORMALIZE
      END IF
      GOTO 2520
      END
      SUBROUTINE SCALE
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      COMMON/DATA2/I,J,K,L,M,I0,J0,K0,IMAX,JMAX,KMAX, ICOUNT,INTX,INTY,I
     *NTZ,ISTR,JSTR,LA_AXIS,LTOT, MAX_CURVE,NCURVE,NDIST1,NDIST2,NUM_ARR
     *,NPOINTS,IOPTION,NTYPE_SYMBOL, NTYPE_CURVE,AXISDOSE,DDBIN_CHI,DDBI
     *N_DIFF,DOSE,ERRDOSE,ERRY, FREQ_CHI,FREQ_DIFF,PROFILEDOSE,PROFILERR
     *,TOTALNORM, XCOORD,YCOORD,ZCOORD, XBOUND,YBOUND,ZBOUND,X,Y,VOXEL_M
     *EAS, CURVE_LABELS,CURVE_SPECS,FILEIN,THE_STRING,TITLE,XAXIS,YAXIS,
     * OUTFILE
      INTEGER I,J,K,L,M
      INTEGER I0, J0, K0
      INTEGER IMAX(15),JMAX(15),KMAX(15)
      INTEGER ICOUNT
      INTEGER INTX,INTY,INTZ
      INTEGER ISTR,JSTR
      INTEGER LA_AXIS
      INTEGER LTOT
      INTEGER MAX_CURVE, NCURVE
      INTEGER NDIST1,NDIST2
      INTEGER NUM_ARR(10)
      INTEGER NPOINTS,IOPTION(4)
      INTEGER NTYPE_SYMBOL,NTYPE_CURVE
      REAL AXISDOSE(15,128)
      REAL DDBIN_CHI
      REAL DDBIN_DIFF
      REAL DOSE(15,128,128,128)
      REAL ERRDOSE(15,128,128,128)
      REAL ERRY(400)
      REAL FREQ_CHI(400)
      REAL FREQ_DIFF(400)
      REAL PROFILEDOSE(128+1),PROFILERR(128+1)
      REAL TOTALNORM(15)
      REAL XCOORD, YCOORD, ZCOORD
      REAL XBOUND(15,128+1),YBOUND(15,128+1), ZBOUND(15,128+1)
      REAL X(400),Y(400)
      REAL VOXEL_MEAS
      CHARACTER*60 CURVE_LABELS
      CHARACTER*2 CURVE_SPECS
      CHARACTER*70 FILEIN(15)
      CHARACTER*(10) THE_STRING
      CHARACTER*60 TITLE,XAXIS,YAXIS,OUTFILE,SUBTITLE
      REAL SCALEFACT
      SAVE
2630  SCALEFACT = 0
      WRITE(6,2640)
2640  FORMAT(/1X,'Rescaling')
      WRITE(6,2650)
2650  FORMAT(1X,'---------')
2660  WRITE(6,2670)
2670  FORMAT(1X,'Files currently loaded:'/)
      DO 2681 N=1,15
        IF (NDIST1_FLAG(N) .EQ. 1) THEN
          WRITE(6,2690)N,FILEIN(N)
2690      FORMAT(I2,' - ',A)
        END IF
2681  CONTINUE
2682  CONTINUE
      WRITE(6,2700)
2700  FORMAT(/1X,'Number of file to Rescale (0-MainMenu): ',$)
      READ(5,2710)NDIST1
2710  FORMAT(I2)
      IF (NDIST1 .EQ. 0) THEN
        RETURN
      ELSE IF(NDIST1.GT.15) THEN
        WRITE(6,2720)
2720    FORMAT(1X,'SORRY, THAT IS OUT OF RANGE.'/)
        GOTO 2660
      END IF
2730  WRITE(6,2740)
2740  FORMAT(1X,'Scaling factor (0-Normmenu): ',$)
      READ(5,2750)SCALEFACT
2750  FORMAT(F10.0)
      IF (SCALEFACT.LT.0) THEN
        WRITE(6,2760)
2760    FORMAT(1X,'SORRY, THAT IS OUT OF RANGE.'/)
        GOTO 2730
      ELSE IF(SCALEFACT .EQ. 0) THEN
        RETURN
      END IF
      WRITE(6,2770)
2770  FORMAT(1X,'RESCALING ARRAY...')
      TOTALNORM(NDIST1) = SCALEFACT*TOTALNORM(NDIST1)
      DO 2781 I=1,IMAX(NDIST1)
        DO 2791 J=1,JMAX(NDIST1)
          DO 2801 K=1,KMAX(NDIST1)
            DOSE(NDIST1,I,J,K) = DOSE(NDIST1,I,J,K)*SCALEFACT
            ERRDOSE(NDIST1,I,J,K) = ERRDOSE(NDIST1,I,J,K)*SCALEFACT
2801      CONTINUE
2802      CONTINUE
2791    CONTINUE
2792    CONTINUE
2781  CONTINUE
2782  CONTINUE
      GOTO 2630
      END
      SUBROUTINE AVERAGEDOSE
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      COMMON/DATA2/I,J,K,L,M,I0,J0,K0,IMAX,JMAX,KMAX, ICOUNT,INTX,INTY,I
     *NTZ,ISTR,JSTR,LA_AXIS,LTOT, MAX_CURVE,NCURVE,NDIST1,NDIST2,NUM_ARR
     *,NPOINTS,IOPTION,NTYPE_SYMBOL, NTYPE_CURVE,AXISDOSE,DDBIN_CHI,DDBI
     *N_DIFF,DOSE,ERRDOSE,ERRY, FREQ_CHI,FREQ_DIFF,PROFILEDOSE,PROFILERR
     *,TOTALNORM, XCOORD,YCOORD,ZCOORD, XBOUND,YBOUND,ZBOUND,X,Y,VOXEL_M
     *EAS, CURVE_LABELS,CURVE_SPECS,FILEIN,THE_STRING,TITLE,XAXIS,YAXIS,
     * OUTFILE
      INTEGER I,J,K,L,M
      INTEGER I0, J0, K0
      INTEGER IMAX(15),JMAX(15),KMAX(15)
      INTEGER ICOUNT
      INTEGER INTX,INTY,INTZ
      INTEGER ISTR,JSTR
      INTEGER LA_AXIS
      INTEGER LTOT
      INTEGER MAX_CURVE, NCURVE
      INTEGER NDIST1,NDIST2
      INTEGER NUM_ARR(10)
      INTEGER NPOINTS,IOPTION(4)
      INTEGER NTYPE_SYMBOL,NTYPE_CURVE
      REAL AXISDOSE(15,128)
      REAL DDBIN_CHI
      REAL DDBIN_DIFF
      REAL DOSE(15,128,128,128)
      REAL ERRDOSE(15,128,128,128)
      REAL ERRY(400)
      REAL FREQ_CHI(400)
      REAL FREQ_DIFF(400)
      REAL PROFILEDOSE(128+1),PROFILERR(128+1)
      REAL TOTALNORM(15)
      REAL XCOORD, YCOORD, ZCOORD
      REAL XBOUND(15,128+1),YBOUND(15,128+1), ZBOUND(15,128+1)
      REAL X(400),Y(400)
      REAL VOXEL_MEAS
      CHARACTER*60 CURVE_LABELS
      CHARACTER*2 CURVE_SPECS
      CHARACTER*70 FILEIN(15)
      CHARACTER*(10) THE_STRING
      CHARACTER*60 TITLE,XAXIS,YAXIS,OUTFILE,SUBTITLE
      REAL AVGDOSE
      SAVE
2810  AVGDOSE = 0
      WRITE(6,2820)
2820  FORMAT(/1X,'Normalize to average dose')
      WRITE(6,2830)
2830  FORMAT(1X,'-------------------------')
2840  WRITE(6,2850)
2850  FORMAT(1X,'Files currently loaded:'/)
      DO 2861 N=1,15
        IF (NDIST1_FLAG(N) .EQ. 1) THEN
          WRITE(6,2870)N,FILEIN(N)
2870      FORMAT(I2,' - ',A)
        END IF
2861  CONTINUE
2862  CONTINUE
      WRITE(6,2880)
2880  FORMAT(/1X,'Number of file to Normalize (0-MainMenu): ',$)
      READ(5,2890)NDIST1
2890  FORMAT(I2)
      IF (NDIST1 .EQ. 0) THEN
        RETURN
      ELSE IF(NDIST1.GT.15) THEN
        WRITE(6,2900)
2900    FORMAT(1X,'SORRY, THAT IS OUT OF RANGE.'/)
        GOTO 2840
      END IF
      WRITE(6,2910)
2910  FORMAT(1X,'NORMALIZING TO AVERAGE DOSE...')
      DO 2921 I=1,IMAX(NDIST1)
        DO 2931 J=1,JMAX(NDIST1)
          DO 2941 K=1,KMAX(NDIST1)
            AVGDOSE = DOSE(NDIST1,I,J,K)+AVGDOSE
2941      CONTINUE
2942      CONTINUE
2931    CONTINUE
2932    CONTINUE
2921  CONTINUE
2922  CONTINUE
      AVGDOSE = AVGDOSE/(IMAX(NDIST1)*JMAX(NDIST1)*KMAX(NDIST1))
      WRITE(6,2950)AVGDOSE
2950  FORMAT(1X,'AVERAGE DOSE: ',G10.4)
      TOTALNORM(NDIST1) = TOTALNORM(NDIST1)/AVGDOSE
      DO 2961 I=1,IMAX(NDIST1)
        DO 2971 J=1,JMAX(NDIST1)
          DO 2981 K=1,KMAX(NDIST1)
            DOSE(NDIST1,I,J,K) = DOSE(NDIST1,I,J,K)/AVGDOSE
            ERRDOSE(NDIST1,I,J,K) = ERRDOSE(NDIST1,I,J,K)/AVGDOSE
2981      CONTINUE
2982      CONTINUE
2971    CONTINUE
2972    CONTINUE
2961  CONTINUE
2962  CONTINUE
      GOTO 2810
      END
      SUBROUTINE CENTRALMAX
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      COMMON/DATA2/I,J,K,L,M,I0,J0,K0,IMAX,JMAX,KMAX, ICOUNT,INTX,INTY,I
     *NTZ,ISTR,JSTR,LA_AXIS,LTOT, MAX_CURVE,NCURVE,NDIST1,NDIST2,NUM_ARR
     *,NPOINTS,IOPTION,NTYPE_SYMBOL, NTYPE_CURVE,AXISDOSE,DDBIN_CHI,DDBI
     *N_DIFF,DOSE,ERRDOSE,ERRY, FREQ_CHI,FREQ_DIFF,PROFILEDOSE,PROFILERR
     *,TOTALNORM, XCOORD,YCOORD,ZCOORD, XBOUND,YBOUND,ZBOUND,X,Y,VOXEL_M
     *EAS, CURVE_LABELS,CURVE_SPECS,FILEIN,THE_STRING,TITLE,XAXIS,YAXIS,
     * OUTFILE
      INTEGER I,J,K,L,M
      INTEGER I0, J0, K0
      INTEGER IMAX(15),JMAX(15),KMAX(15)
      INTEGER ICOUNT
      INTEGER INTX,INTY,INTZ
      INTEGER ISTR,JSTR
      INTEGER LA_AXIS
      INTEGER LTOT
      INTEGER MAX_CURVE, NCURVE
      INTEGER NDIST1,NDIST2
      INTEGER NUM_ARR(10)
      INTEGER NPOINTS,IOPTION(4)
      INTEGER NTYPE_SYMBOL,NTYPE_CURVE
      REAL AXISDOSE(15,128)
      REAL DDBIN_CHI
      REAL DDBIN_DIFF
      REAL DOSE(15,128,128,128)
      REAL ERRDOSE(15,128,128,128)
      REAL ERRY(400)
      REAL FREQ_CHI(400)
      REAL FREQ_DIFF(400)
      REAL PROFILEDOSE(128+1),PROFILERR(128+1)
      REAL TOTALNORM(15)
      REAL XCOORD, YCOORD, ZCOORD
      REAL XBOUND(15,128+1),YBOUND(15,128+1), ZBOUND(15,128+1)
      REAL X(400),Y(400)
      REAL VOXEL_MEAS
      CHARACTER*60 CURVE_LABELS
      CHARACTER*2 CURVE_SPECS
      CHARACTER*70 FILEIN(15)
      CHARACTER*(10) THE_STRING
      CHARACTER*60 TITLE,XAXIS,YAXIS,OUTFILE,SUBTITLE
      INTEGER ILO,IHI,JLO,JHI
      REAL FACT_NORM
      REAL DOSE_STORE
      SAVE
2990  FACT_NORM = 0
      WRITE(6,3000)
3000  FORMAT(/1X,'Normalize along central maximum')
      WRITE(6,3010)
3010  FORMAT(1X,'-------------------------------')
3020  WRITE(6,3030)
3030  FORMAT(1X,'Files currently loaded:'/)
      DO 3041 N=1,15
        IF (NDIST1_FLAG(N) .EQ. 1) THEN
          WRITE(6,3050)N,FILEIN(N)
3050      FORMAT(I2,' - ',A)
        END IF
3041  CONTINUE
3042  CONTINUE
      WRITE(6,3060)
3060  FORMAT(/1X,'Number of file to Normalize (0-MainMenu): ',$)
      READ(5,3070)NDIST1
3070  FORMAT(I2)
      IF (NDIST1 .EQ. 0) THEN
        RETURN
      ELSE IF(NDIST1.GT.15) THEN
        WRITE(6,3080)
3080    FORMAT(1X,'SORRY, THAT IS OUT OF RANGE.'/)
        GOTO 3020
      END IF
      IF ((MOD(IMAX(NDIST1),2)) .EQ. 0) THEN
        ILO = IMAX(NDIST1)/2
        IHI = IMAX(NDIST1)/2+1
      ELSE
        ILO = IMAX(NDIST1)/2+1
        IHI = IMAX(NDIST1)/2+1
      END IF
      IF ((MOD(JMAX(NDIST1),2)) .EQ. 0) THEN
        JLO = JMAX(NDIST1)/2
        JHI = JMAX(NDIST1)/2+1
      ELSE
        JLO = JMAX(NDIST1)/2+1
        JHI = JMAX(NDIST1)/2+1
      END IF
      DO 3091 K=1,KMAX(NDIST1)
        DOSE_STORE = 0
        DO 3101 I=ILO,IHI
          DO 3111 J=JLO,JHI
            DOSE_STORE = DOSE(NDIST1,I,J,K)+DOSE_STORE
3111      CONTINUE
3112      CONTINUE
3101    CONTINUE
3102    CONTINUE
        DOSE_STORE = DOSE_STORE/((IHI-ILO+1)*(JHI-JLO+1))
        AXISDOSE(NDIST1,K) = DOSE_STORE
3091  CONTINUE
3092  CONTINUE
      DO 3121 K=1,KMAX(NDIST1)
        FACT_NORM = MAX(FACT_NORM,AXISDOSE(NDIST1,K))
3121  CONTINUE
3122  CONTINUE
      TOTALNORM(NDIST1) = TOTALNORM(NDIST1)/FACT_NORM
      WRITE(6,3130)
3130  FORMAT(1X,'Normalizing to maximum dose along central axis...')
      WRITE(6,3140)(IHI-ILO+1)
3140  FORMAT(1X,'Number of voxels averaged in X direction: ',I1)
      WRITE(6,3150)(JHI-JLO+1)
3150  FORMAT(1X,'Number of voxels averaged in Y direction: ',I1)
      WRITE(6,3160)FACT_NORM
3160  FORMAT(1X,'Maximum dose along the axis: ',G10.2)
      DO 3171 I=1,IMAX(NDIST1)
        DO 3181 J=1,JMAX(NDIST1)
          DO 3191 K=1,KMAX(NDIST1)
            DOSE(NDIST1,I,J,K) = DOSE(NDIST1,I,J,K)/FACT_NORM
            ERRDOSE(NDIST1,I,J,K) = ERRDOSE(NDIST1,I,J,K)/FACT_NORM
3191      CONTINUE
3192      CONTINUE
3181    CONTINUE
3182    CONTINUE
3171  CONTINUE
3172  CONTINUE
      GOTO 2990
      END
      SUBROUTINE SPECVOXEL
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      COMMON/DATA2/I,J,K,L,M,I0,J0,K0,IMAX,JMAX,KMAX, ICOUNT,INTX,INTY,I
     *NTZ,ISTR,JSTR,LA_AXIS,LTOT, MAX_CURVE,NCURVE,NDIST1,NDIST2,NUM_ARR
     *,NPOINTS,IOPTION,NTYPE_SYMBOL, NTYPE_CURVE,AXISDOSE,DDBIN_CHI,DDBI
     *N_DIFF,DOSE,ERRDOSE,ERRY, FREQ_CHI,FREQ_DIFF,PROFILEDOSE,PROFILERR
     *,TOTALNORM, XCOORD,YCOORD,ZCOORD, XBOUND,YBOUND,ZBOUND,X,Y,VOXEL_M
     *EAS, CURVE_LABELS,CURVE_SPECS,FILEIN,THE_STRING,TITLE,XAXIS,YAXIS,
     * OUTFILE
      INTEGER I,J,K,L,M
      INTEGER I0, J0, K0
      INTEGER IMAX(15),JMAX(15),KMAX(15)
      INTEGER ICOUNT
      INTEGER INTX,INTY,INTZ
      INTEGER ISTR,JSTR
      INTEGER LA_AXIS
      INTEGER LTOT
      INTEGER MAX_CURVE, NCURVE
      INTEGER NDIST1,NDIST2
      INTEGER NUM_ARR(10)
      INTEGER NPOINTS,IOPTION(4)
      INTEGER NTYPE_SYMBOL,NTYPE_CURVE
      REAL AXISDOSE(15,128)
      REAL DDBIN_CHI
      REAL DDBIN_DIFF
      REAL DOSE(15,128,128,128)
      REAL ERRDOSE(15,128,128,128)
      REAL ERRY(400)
      REAL FREQ_CHI(400)
      REAL FREQ_DIFF(400)
      REAL PROFILEDOSE(128+1),PROFILERR(128+1)
      REAL TOTALNORM(15)
      REAL XCOORD, YCOORD, ZCOORD
      REAL XBOUND(15,128+1),YBOUND(15,128+1), ZBOUND(15,128+1)
      REAL X(400),Y(400)
      REAL VOXEL_MEAS
      CHARACTER*60 CURVE_LABELS
      CHARACTER*2 CURVE_SPECS
      CHARACTER*70 FILEIN(15)
      CHARACTER*(10) THE_STRING
      CHARACTER*60 TITLE,XAXIS,YAXIS,OUTFILE,SUBTITLE
      INTEGER ILO,IHI,JLO,JHI,KLO,KHI
      REAL FACT_NORM
      SAVE
3200  FACT_NORM = 0
      WRITE(6,3210)
3210  FORMAT(/1X,'Normalize to specific voxel')
      WRITE(6,3220)
3220  FORMAT(1X,'---------------------------')
3230  WRITE(6,3240)
3240  FORMAT(1X,'Files currently loaded:'/)
      DO 3251 N=1,15
        IF ((NDIST1_FLAG(N) .EQ. 1)) THEN
          WRITE(6,3260)N,FILEIN(N)
3260      FORMAT(I2,' - ',A)
        END IF
3251  CONTINUE
3252  CONTINUE
      WRITE(6,3270)
3270  FORMAT(/1X,'Number of file to Normalize (0-MainMenu): ',$)
      READ(5,3280)NDIST1
3280  FORMAT(I2)
      IF (NDIST1 .EQ. 0) THEN
        RETURN
      ELSE IF(NDIST1.GT.15) THEN
        WRITE(6,3290)
3290    FORMAT(1X,'SORRY, THAT IS OUT OF RANGE.'/)
        GOTO 3230
      END IF
      WRITE(6,3300)
3300  FORMAT(1X,'Voxel coordinates x,y,z (cm): ',$)
      read(5,*) XCOORD,YCOORD,ZCOORD
      IF ((.false.)) THEN
        WRITE(6,3310)XCOORD,YCOORD,ZCOORD
3310    FORMAT(' XCOORD,YCOORD,ZCOORD:',3F10.3)
      END IF
      DO 3321 I0=2,IMAX(NDIST1)
        VOXEL_MEAS = XBOUND(NDIST1,I0)
        IF ((VOXEL_MEAS.GT.XCOORD)) THEN
          GO TO3322
        END IF
3321  CONTINUE
3322  CONTINUE
      I0 = I0-1
      DO 3331 J0=2,JMAX(NDIST1)
        VOXEL_MEAS = YBOUND(NDIST1,J0)
        IF ((VOXEL_MEAS.GT.YCOORD)) THEN
          GO TO3332
        END IF
3331  CONTINUE
3332  CONTINUE
      J0 = J0-1
      DO 3341 K0=2,KMAX(NDIST1)
        VOXEL_MEAS = ZBOUND(NDIST1,K0)
        IF ((VOXEL_MEAS.GT.ZCOORD)) THEN
          GO TO3342
        END IF
3341  CONTINUE
3342  CONTINUE
      K0 = K0-1
      IF ((.false.)) THEN
        WRITE(6,3350)I0, J0, K0
3350    FORMAT('Post FIND_BINB: I0, J0, K0=',3I4)
      END IF
      ILO = I0
      IHI = I0
      IF ((XBOUND(NDIST1,I0+1)-XCOORD).LT..01) THEN
        IHI=I0+1
      END IF
      IF ((XCOORD-XBOUND(NDIST1,I0)).LT. 0.01) THEN
        ILO=I0-1
      END IF
      IF ((ILO .EQ. 0)) THEN
        ILO=1
      END IF
      JLO = J0
      JHI = J0
      IF ((YBOUND(NDIST1,J0+1)-YCOORD).LT..01) THEN
        JHI=J0+1
      END IF
      IF ((YCOORD-YBOUND(NDIST1,J0)).LT. 0.01) THEN
        JLO=J0-1
      END IF
      IF ((JLO .EQ. 0)) THEN
        JLO=1
      END IF
      KLO = K0
      KHI = K0
      IF ((ZBOUND(NDIST1,K0+1)-ZCOORD).LT..01) THEN
        KHI=K0+1
      END IF
      IF ((ZCOORD-ZBOUND(NDIST1,K0)).LT. 0.01) THEN
        KLO=K0-1
      END IF
      IF ((KLO .EQ. 0)) THEN
        KLO=1
      END IF
      IF ((.false.)) THEN
        WRITE(6,3360)ILO, JLO, KLO
3360    FORMAT('Post FIND_LIMS: ILO, JLO, KLO=',3I4)
      END IF
      DO 3371 I=ILO,IHI
        DO 3381 J=JLO,JHI
          DO 3391 K=KLO,KHI
            FACT_NORM = DOSE(NDIST1,I,J,K)+FACT_NORM
3391      CONTINUE
3392      CONTINUE
3381    CONTINUE
3382    CONTINUE
3371  CONTINUE
3372  CONTINUE
      IF ((.false.)) THEN
        WRITE(6,3400)ILO,IHI,JLO,JHI,KLO,KHI,FACT_NORM
3400    FORMAT(' ILO,IHI,JLO,JHI,KLO,KHI,FACT_NORM:',6I4,3x,G10.4)
      END IF
      FACT_NORM = FACT_NORM/((IHI-ILO+1)*(JHI-JLO+1)*(KHI-KLO+1))
      TOTALNORM(NDIST1) = TOTALNORM(NDIST1)/FACT_NORM
      WRITE(6,3410)I0,J0,K0
3410  FORMAT(1X,'Normalizing to dose in voxel ',3I3)
      WRITE(6,3420)(IHI-ILO+1)
3420  FORMAT(1X,'Number of voxels averaged in X direction: ',I1)
      WRITE(6,3430)(JHI-JLO+1)
3430  FORMAT(1X,'Number of voxels averaged in Y direction: ',I1)
      WRITE(6,3440)(KHI-KLO+1)
3440  FORMAT(1X,'Number of voxels averaged in Z direction: ',I1)
      WRITE(6,3450)FACT_NORM
3450  FORMAT(1X,'Dose in the voxel: ',G10.2)
      DO 3461 I=1,IMAX(NDIST1)
        DO 3471 J=1,JMAX(NDIST1)
          DO 3481 K=1,KMAX(NDIST1)
            DOSE(NDIST1,I,J,K) = DOSE(NDIST1,I,J,K)/FACT_NORM
            ERRDOSE(NDIST1,I,J,K) = ERRDOSE(NDIST1,I,J,K)/FACT_NORM
3481      CONTINUE
3482      CONTINUE
3471    CONTINUE
3472    CONTINUE
3461  CONTINUE
3462  CONTINUE
      GOTO 3200
      END
      SUBROUTINE DENORMALIZE
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      COMMON/DATA2/I,J,K,L,M,I0,J0,K0,IMAX,JMAX,KMAX, ICOUNT,INTX,INTY,I
     *NTZ,ISTR,JSTR,LA_AXIS,LTOT, MAX_CURVE,NCURVE,NDIST1,NDIST2,NUM_ARR
     *,NPOINTS,IOPTION,NTYPE_SYMBOL, NTYPE_CURVE,AXISDOSE,DDBIN_CHI,DDBI
     *N_DIFF,DOSE,ERRDOSE,ERRY, FREQ_CHI,FREQ_DIFF,PROFILEDOSE,PROFILERR
     *,TOTALNORM, XCOORD,YCOORD,ZCOORD, XBOUND,YBOUND,ZBOUND,X,Y,VOXEL_M
     *EAS, CURVE_LABELS,CURVE_SPECS,FILEIN,THE_STRING,TITLE,XAXIS,YAXIS,
     * OUTFILE
      INTEGER I,J,K,L,M
      INTEGER I0, J0, K0
      INTEGER IMAX(15),JMAX(15),KMAX(15)
      INTEGER ICOUNT
      INTEGER INTX,INTY,INTZ
      INTEGER ISTR,JSTR
      INTEGER LA_AXIS
      INTEGER LTOT
      INTEGER MAX_CURVE, NCURVE
      INTEGER NDIST1,NDIST2
      INTEGER NUM_ARR(10)
      INTEGER NPOINTS,IOPTION(4)
      INTEGER NTYPE_SYMBOL,NTYPE_CURVE
      REAL AXISDOSE(15,128)
      REAL DDBIN_CHI
      REAL DDBIN_DIFF
      REAL DOSE(15,128,128,128)
      REAL ERRDOSE(15,128,128,128)
      REAL ERRY(400)
      REAL FREQ_CHI(400)
      REAL FREQ_DIFF(400)
      REAL PROFILEDOSE(128+1),PROFILERR(128+1)
      REAL TOTALNORM(15)
      REAL XCOORD, YCOORD, ZCOORD
      REAL XBOUND(15,128+1),YBOUND(15,128+1), ZBOUND(15,128+1)
      REAL X(400),Y(400)
      REAL VOXEL_MEAS
      CHARACTER*60 CURVE_LABELS
      CHARACTER*2 CURVE_SPECS
      CHARACTER*70 FILEIN(15)
      CHARACTER*(10) THE_STRING
      CHARACTER*60 TITLE,XAXIS,YAXIS,OUTFILE,SUBTITLE
      SAVE
3490  WRITE(6,3500)
3500  FORMAT(/1X,'DENORMALIZE')
      WRITE(6,3510)
3510  FORMAT(1X,'-----------')
3520  WRITE(6,3530)
3530  FORMAT(1X,'Files currently loaded:'/)
      DO 3541 N=1,15
        IF (NDIST1_FLAG(N) .EQ. 1) THEN
          WRITE(6,3550)N,FILEIN(N)
3550      FORMAT(I2,' - ',A)
        END IF
3541  CONTINUE
3542  CONTINUE
      WRITE(6,3560)
3560  FORMAT(/1X,'Number of file to DeNormalize (0-MainMenu): ',$)
      READ(5,3570)NDIST1
3570  FORMAT(I2)
      IF (NDIST1 .EQ. 0) THEN
        RETURN
      ELSE IF(NDIST1.GT.15) THEN
        WRITE(6,3580)
3580    FORMAT(1X,'SORRY, THAT IS OUT OF RANGE.'/)
        GOTO 3520
      END IF
      WRITE(6,3590)
3590  FORMAT(1X,'DENORMALIZING DISTRIBUTION...')
      DO 3601 I=1,IMAX(NDIST1)
        DO 3611 J=1,JMAX(NDIST1)
          DO 3621 K=1,KMAX(NDIST1)
            DOSE(NDIST1,I,J,K) = DOSE(NDIST1,I,J,K)/TOTALNORM(NDIST1)
            ERRDOSE(NDIST1,I,J,K) = ERRDOSE(NDIST1,I,J,K)/TOTALNORM(NDIS
     *      T1)
3621      CONTINUE
3622      CONTINUE
3611    CONTINUE
3612    CONTINUE
3601  CONTINUE
3602  CONTINUE
      GOTO 3490
      END
      SUBROUTINE REBINNING
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      COMMON/DATA2/I,J,K,L,M,I0,J0,K0,IMAX,JMAX,KMAX, ICOUNT,INTX,INTY,I
     *NTZ,ISTR,JSTR,LA_AXIS,LTOT, MAX_CURVE,NCURVE,NDIST1,NDIST2,NUM_ARR
     *,NPOINTS,IOPTION,NTYPE_SYMBOL, NTYPE_CURVE,AXISDOSE,DDBIN_CHI,DDBI
     *N_DIFF,DOSE,ERRDOSE,ERRY, FREQ_CHI,FREQ_DIFF,PROFILEDOSE,PROFILERR
     *,TOTALNORM, XCOORD,YCOORD,ZCOORD, XBOUND,YBOUND,ZBOUND,X,Y,VOXEL_M
     *EAS, CURVE_LABELS,CURVE_SPECS,FILEIN,THE_STRING,TITLE,XAXIS,YAXIS,
     * OUTFILE
      INTEGER I,J,K,L,M
      INTEGER I0, J0, K0
      INTEGER IMAX(15),JMAX(15),KMAX(15)
      INTEGER ICOUNT
      INTEGER INTX,INTY,INTZ
      INTEGER ISTR,JSTR
      INTEGER LA_AXIS
      INTEGER LTOT
      INTEGER MAX_CURVE, NCURVE
      INTEGER NDIST1,NDIST2
      INTEGER NUM_ARR(10)
      INTEGER NPOINTS,IOPTION(4)
      INTEGER NTYPE_SYMBOL,NTYPE_CURVE
      REAL AXISDOSE(15,128)
      REAL DDBIN_CHI
      REAL DDBIN_DIFF
      REAL DOSE(15,128,128,128)
      REAL ERRDOSE(15,128,128,128)
      REAL ERRY(400)
      REAL FREQ_CHI(400)
      REAL FREQ_DIFF(400)
      REAL PROFILEDOSE(128+1),PROFILERR(128+1)
      REAL TOTALNORM(15)
      REAL XCOORD, YCOORD, ZCOORD
      REAL XBOUND(15,128+1),YBOUND(15,128+1), ZBOUND(15,128+1)
      REAL X(400),Y(400)
      REAL VOXEL_MEAS
      CHARACTER*60 CURVE_LABELS
      CHARACTER*2 CURVE_SPECS
      CHARACTER*70 FILEIN(15)
      CHARACTER*(10) THE_STRING
      CHARACTER*60 TITLE,XAXIS,YAXIS,OUTFILE,SUBTITLE
      INTEGER JEND, LASTBIN_FACT,MAX_BIN,NBIN_FACT,NDIST1_BIN
      SAVE
3630  WRITE(6,3640)
3640  FORMAT(/1X,'REBINNING')
      WRITE(6,3650)
3650  FORMAT(1X,'----------')
3660  WRITE(6,3670)
3670  FORMAT(1X,'Files currently loaded:'/)
      DO 3681 N=1,15
        IF (NDIST1_FLAG(N) .EQ. 1) THEN
          WRITE(6,3690)N,FILEIN(N)
3690      FORMAT(I2,' - ',A)
        END IF
3681  CONTINUE
3682  CONTINUE
      WRITE(6,3700)
3700  FORMAT(/1X,'Number of file to Rebin (0-MainMenu): ',$)
      READ(5,3710)NDIST1
3710  FORMAT(I2)
      IF (NDIST1 .EQ. 0) THEN
        RETURN
      ELSE IF(NDIST1.GT.15) THEN
        WRITE(6,3720)
3720    FORMAT(1X,'SORRY, THAT IS OUT OF RANGE.'/)
        GOTO 3660
      END IF
3730  WRITE(6,3740)
3740  FORMAT(1X,'Number of Rebinned File (1-5,0-MainMenu): ',$)
      READ(5,3750)NDIST1_BIN
3750  FORMAT(I2)
      IF (NDIST1_BIN .EQ. 0) THEN
        RETURN
      ELSE IF(NDIST1_BIN.GT.15) THEN
        WRITE(6,3760)
3760    FORMAT(1X,'SORRY, THAT IS OUT OF RANGE.'/)
        GOTO 3660
      ELSE IF(NDIST1_BIN .EQ. NDIST1) THEN
        WRITE(6,3770)
3770    FORMAT(1X,'YOU CANNOT OVERWRITE THE FILE YOU ARE REBINNING.')
        GOTO 3730
      END IF
      CALL LETTERCOUNT(FILEIN(NDIST1),NUMCHAR)
      WRITE(6,3780)FILEIN(NDIST1)(1:NUMCHAR)
3780  FORMAT(1X,'Name of rebinned file (default=',A,'.rb): ',$)
      READ(5,3790)FILEIN(NDIST1_BIN)
3790  FORMAT(A)
      IF (FILEIN(NDIST1_BIN) .EQ. ' ') THEN
        FILEIN(NDIST1_BIN)=FILEIN(NDIST1)(1:NUMCHAR) //'.rb'
      END IF
3800  WRITE(6,3810)
3810  FORMAT(1X,'Axis for rebinning (1-X,2-Y,3-Z): ',$)
      READ(5,3820)LA_AXIS
3820  FORMAT(I5)
      IF ((LA_AXIS.LT.1.OR.LA_AXIS.GT.3)) THEN
        GOTO 3800
      END IF
3830  WRITE(6,3840)
3840  FORMAT(1X,'Rebinning factor: ',$)
      READ(5,3850)NBIN_FACT
3850  FORMAT(I5)
      IF (NBIN_FACT .EQ. 0) THEN
        WRITE(6,3860)
3860    FORMAT('REBINNING FACTOR MUST BE AN INTEGER GREATER THAN 0')
        GOTO 3830
      END IF
      WRITE(6,3870)
3870  FORMAT(1X,'REBINNING......'/)
      DO 3881 I=1,IMAX(NDIST1)
        DO 3891 J=1,JMAX(NDIST1)
          DO 3901 K=1,KMAX(NDIST1)
            DOSE(NDIST1_BIN,I,J,K) = 0.
            ERRDOSE(NDIST1_BIN,I,J,K) = 0.
3901      CONTINUE
3902      CONTINUE
3891    CONTINUE
3892    CONTINUE
3881  CONTINUE
3882  CONTINUE
      JEND = NBIN_FACT
      IF (LA_AXIS .EQ. 1) THEN
        MAX_BIN = (IMAX(NDIST1)+NBIN_FACT-1)/NBIN_FACT
        LASTBIN_FACT = MOD(IMAX(NDIST1),NBIN_FACT)
        IF (LASTBIN_FACT.EQ.0) THEN
          LASTBIN_FACT = NBIN_FACT
        END IF
        DO 3911 I=1,MAX_BIN
          XBOUND(NDIST1_BIN,I) = XBOUND(NDIST1,(I-1)*NBIN_FACT+1)
3911    CONTINUE
3912    CONTINUE
        XBOUND(NDIST1_BIN,MAX_BIN+1) = XBOUND(NDIST1,IMAX(NDIST1)+1)
        IMAX(NDIST1_BIN) = MAX_BIN
        DO 3921 I=1,(JMAX(NDIST1)+1)
          YBOUND(NDIST1_BIN,I) = YBOUND(NDIST1,I)
3921    CONTINUE
3922    CONTINUE
        JMAX(NDIST1_BIN) = JMAX(NDIST1)
        DO 3931 I=1,(KMAX(NDIST1)+1)
          ZBOUND(NDIST1_BIN,I) = ZBOUND(NDIST1,I)
3931    CONTINUE
3932    CONTINUE
        KMAX(NDIST1_BIN) = KMAX(NDIST1)
        DO 3941 I=1,MAX_BIN
          IF (I.EQ.MAX_BIN) THEN
            JEND=LASTBIN_FACT
          END IF
          DO 3951 J=1,JMAX(NDIST1_BIN)
            DO 3961 K=1,KMAX(NDIST1_BIN)
              DO 3971 L=1,JEND
                I0=(I-1)*NBIN_FACT+L
                J0=J
                K0=K
                DOSE(NDIST1_BIN,I,J,K)=DOSE(NDIST1_BIN,I,J,K)+ DOSE(NDIS
     *          T1,I0,J0,K0)
                ERRDOSE(NDIST1_BIN,I,J,K)=ERRDOSE(NDIST1_BIN,I,J,K)+ ERR
     *          DOSE(NDIST1,I0,J0,K0)**2
3971          CONTINUE
3972          CONTINUE
              DOSE(NDIST1_BIN,I,J,K)=DOSE(NDIST1_BIN,I,J,K)/JEND
              ERRDOSE(NDIST1_BIN,I,J,K)= SQRT(ERRDOSE(NDIST1_BIN,I,J,K))
     *        /JEND
3961        CONTINUE
3962        CONTINUE
3951      CONTINUE
3952      CONTINUE
3941    CONTINUE
3942    CONTINUE
      ELSE IF(LA_AXIS .EQ. 2) THEN
        MAX_BIN = (JMAX(NDIST1)+NBIN_FACT-1)/NBIN_FACT
        LASTBIN_FACT = MOD(JMAX(NDIST1),NBIN_FACT)
        IF (LASTBIN_FACT.EQ.0) THEN
          LASTBIN_FACT = NBIN_FACT
        END IF
        DO 3981 I=1,MAX_BIN
          YBOUND(NDIST1_BIN,I) = YBOUND(NDIST1,(I-1)*NBIN_FACT+1)
3981    CONTINUE
3982    CONTINUE
        YBOUND(NDIST1_BIN,MAX_BIN+1) = YBOUND(NDIST1,JMAX(NDIST1)+1)
        JMAX(NDIST1_BIN) = MAX_BIN
        DO 3991 I=1,(IMAX(NDIST1)+1)
          XBOUND(NDIST1_BIN,I) = XBOUND(NDIST1,I)
3991    CONTINUE
3992    CONTINUE
        IMAX(NDIST1_BIN) = IMAX(NDIST1)
        DO 4001 I=1,(KMAX(NDIST1)+1)
          ZBOUND(NDIST1_BIN,I) = ZBOUND(NDIST1,I)
4001    CONTINUE
4002    CONTINUE
        KMAX(NDIST1_BIN) = KMAX(NDIST1)
        DO 4011 J=1,MAX_BIN
          IF (J.EQ.MAX_BIN) THEN
            JEND=LASTBIN_FACT
          END IF
          DO 4021 I=1,IMAX(NDIST1_BIN)
            DO 4031 K=1,KMAX(NDIST1_BIN)
              DO 4041 L=1,JEND
                J0=(J-1)*NBIN_FACT+L
                I0=I
                K0=K
                DOSE(NDIST1_BIN,I,J,K)=DOSE(NDIST1_BIN,I,J,K)+ DOSE(NDIS
     *          T1,I0,J0,K0)
                ERRDOSE(NDIST1_BIN,I,J,K)=ERRDOSE(NDIST1_BIN,I,J,K)+ ERR
     *          DOSE(NDIST1,I0,J0,K0)**2
4041          CONTINUE
4042          CONTINUE
              DOSE(NDIST1_BIN,I,J,K)=DOSE(NDIST1_BIN,I,J,K)/JEND
              ERRDOSE(NDIST1_BIN,I,J,K)= SQRT(ERRDOSE(NDIST1_BIN,I,J,K))
     *        /JEND
4031        CONTINUE
4032        CONTINUE
4021      CONTINUE
4022      CONTINUE
4011    CONTINUE
4012    CONTINUE
      ELSE IF(LA_AXIS .EQ. 3) THEN
        MAX_BIN = (KMAX(NDIST1)+NBIN_FACT-1)/NBIN_FACT
        LASTBIN_FACT = MOD(KMAX(NDIST1),NBIN_FACT)
        IF (LASTBIN_FACT.EQ.0) THEN
          LASTBIN_FACT = NBIN_FACT
        END IF
        DO 4051 I=1,MAX_BIN
          ZBOUND(NDIST1_BIN,I) = ZBOUND(NDIST1,(I-1)*NBIN_FACT+1)
4051    CONTINUE
4052    CONTINUE
        ZBOUND(NDIST1_BIN,MAX_BIN+1) = ZBOUND(NDIST1,KMAX(NDIST1)+1)
        KMAX(NDIST1_BIN) = MAX_BIN
        DO 4061 I=1,(IMAX(NDIST1)+1)
          XBOUND(NDIST1_BIN,I) = XBOUND(NDIST1,I)
4061    CONTINUE
4062    CONTINUE
        IMAX(NDIST1_BIN) = IMAX(NDIST1)
        DO 4071 I=1,(JMAX(NDIST1)+1)
          YBOUND(NDIST1_BIN,I) = YBOUND(NDIST1,I)
4071    CONTINUE
4072    CONTINUE
        JMAX(NDIST1_BIN) = JMAX(NDIST1)
        DO 4081 K=1,MAX_BIN
          IF (K.EQ.MAX_BIN) THEN
            JEND=LASTBIN_FACT
          END IF
          DO 4091 I=1,IMAX(NDIST1_BIN)
            DO 4101 J=1,JMAX(NDIST1_BIN)
              DO 4111 L=1,JEND
                K0=(K-1)*NBIN_FACT+L
                I0=I
                J0=J
                DOSE(NDIST1_BIN,I,J,K)=DOSE(NDIST1_BIN,I,J,K)+ DOSE(NDIS
     *          T1,I0,J0,K0)
                ERRDOSE(NDIST1_BIN,I,J,K)=ERRDOSE(NDIST1_BIN,I,J,K)+ ERR
     *          DOSE(NDIST1,I0,J0,K0)**2
4111          CONTINUE
4112          CONTINUE
              DOSE(NDIST1_BIN,I,J,K)=DOSE(NDIST1_BIN,I,J,K)/JEND
              ERRDOSE(NDIST1_BIN,I,J,K)= SQRT(ERRDOSE(NDIST1_BIN,I,J,K))
     *        /JEND
4101        CONTINUE
4102        CONTINUE
4091      CONTINUE
4092      CONTINUE
4081    CONTINUE
4082    CONTINUE
      END IF
      WRITE(6,4120)IMAX(NDIST1_BIN),JMAX(NDIST1_BIN),KMAX(NDIST1_BIN)
4120  FORMAT(1X,'NUMBER OF VOXELS IN X,Y,Z DIRECTIONS: ',3I10)
      WRITE(6,4130)XBOUND(NDIST1_BIN,1),XBOUND(NDIST1_BIN,IMAX(NDIST1_BI
     *N)+1)
4130  FORMAT(1X,'Voxel-boundary values in X-direction: ' ,F10.2,2X,'-',F
     *7.2)
      WRITE(6,4140)YBOUND(NDIST1_BIN,1),YBOUND(NDIST1_BIN,JMAX(NDIST1_BI
     *N)+1)
4140  FORMAT(1X,'Voxel-boundary values in Y-direction: ' ,F10.2,2X,'-',F
     *7.2)
      WRITE(6,4150)ZBOUND(NDIST1_BIN,1),ZBOUND(NDIST1_BIN,KMAX(NDIST1_BI
     *N)+1)
4150  FORMAT(1X,'Voxel-boundary values in Z-direction: ' ,F10.2,2X,'-',F
     *7.2)
      NDIST1_FLAG(NDIST1_BIN) = 1
      GOTO 3630
      END
      SUBROUTINE PLOTMENU
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      INTEGER ISELECT
      SAVE
4160  NFLAG = 0
      ISELECT = 0
      WRITE(6,4170)
4170  FORMAT(/1X,'PLOT MENU')
      WRITE(6,4180)
4180  FORMAT(1X,'--------')
      WRITE(6,4190)
4190  FORMAT(1X,'0 - Main menu')
      WRITE(6,4200)
4200  FORMAT(1X,'1 - Plot profiles')
      WRITE(6,4210)
4210  FORMAT(1X,'2 - Comparison plot')
      WRITE(6,4220)
4220  FORMAT(/1X,'Selection: ',$)
      READ(5,4230)ISELECT
4230  FORMAT(I5)
      IF ((ISELECT.LT.0.OR.ISELECT.GT.2)) THEN
        GOTO 4160
      ELSE IF((ISELECT .EQ. 0)) THEN
        RETURN
      ELSE IF((ISELECT .EQ. 1)) THEN
        CALL PLOTDOSE
      ELSE IF((ISELECT .EQ. 2)) THEN
        DO 4241 N=1,15
          IF (NDIST1_FLAG(N) .EQ. 1) THEN
            NFLAG=NFLAG+1
          END IF
4241    CONTINUE
4242    CONTINUE
        IF ((.false.)) THEN
          WRITE(6,4250)NFLAG,(NDIST1_FLAG(N),N=1,15)
4250      FORMAT(' NFLAG=',I3,'  NDIST1_FLAG='/ (10I4))
        END IF
        IF (NFLAG.GT.1) THEN
          CALL COMPAREPLOT
        ELSE
          WRITE(6,4260)
4260      FORMAT('Please read in more data before attempting to comparep
     *lots')
        END IF
      END IF
      GOTO 4160
      END
      SUBROUTINE PLOTDOSE
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      COMMON/DATA2/I,J,K,L,M,I0,J0,K0,IMAX,JMAX,KMAX, ICOUNT,INTX,INTY,I
     *NTZ,ISTR,JSTR,LA_AXIS,LTOT, MAX_CURVE,NCURVE,NDIST1,NDIST2,NUM_ARR
     *,NPOINTS,IOPTION,NTYPE_SYMBOL, NTYPE_CURVE,AXISDOSE,DDBIN_CHI,DDBI
     *N_DIFF,DOSE,ERRDOSE,ERRY, FREQ_CHI,FREQ_DIFF,PROFILEDOSE,PROFILERR
     *,TOTALNORM, XCOORD,YCOORD,ZCOORD, XBOUND,YBOUND,ZBOUND,X,Y,VOXEL_M
     *EAS, CURVE_LABELS,CURVE_SPECS,FILEIN,THE_STRING,TITLE,XAXIS,YAXIS,
     * OUTFILE
      INTEGER I,J,K,L,M
      INTEGER I0, J0, K0
      INTEGER IMAX(15),JMAX(15),KMAX(15)
      INTEGER ICOUNT
      INTEGER INTX,INTY,INTZ
      INTEGER ISTR,JSTR
      INTEGER LA_AXIS
      INTEGER LTOT
      INTEGER MAX_CURVE, NCURVE
      INTEGER NDIST1,NDIST2
      INTEGER NUM_ARR(10)
      INTEGER NPOINTS,IOPTION(4)
      INTEGER NTYPE_SYMBOL,NTYPE_CURVE
      REAL AXISDOSE(15,128)
      REAL DDBIN_CHI
      REAL DDBIN_DIFF
      REAL DOSE(15,128,128,128)
      REAL ERRDOSE(15,128,128,128)
      REAL ERRY(400)
      REAL FREQ_CHI(400)
      REAL FREQ_DIFF(400)
      REAL PROFILEDOSE(128+1),PROFILERR(128+1)
      REAL TOTALNORM(15)
      REAL XCOORD, YCOORD, ZCOORD
      REAL XBOUND(15,128+1),YBOUND(15,128+1), ZBOUND(15,128+1)
      REAL X(400),Y(400)
      REAL VOXEL_MEAS
      CHARACTER*60 CURVE_LABELS
      CHARACTER*2 CURVE_SPECS
      CHARACTER*70 FILEIN(15)
      CHARACTER*(10) THE_STRING
      CHARACTER*60 TITLE,XAXIS,YAXIS,OUTFILE,SUBTITLE
      REAL XMIN
      SAVE
4270  WRITE(6,4280)
4280  FORMAT(/1X,'Data for dose plot')
      WRITE(6,4290)
4290  FORMAT(1X,'------------------')
      WRITE(6,4300)
4300  FORMAT(/1X,'Files currently loaded')
      WRITE(6,4310)
4310  FORMAT(1X,'----------------------')
      DO 4321 N=1,15
        IF (NDIST1_FLAG(N) .EQ. 1) THEN
          WRITE(6,4330)N,FILEIN(N)
4330      FORMAT(I2,' - ',A)
        END IF
4321  CONTINUE
4322  CONTINUE
      WRITE(6,4340)
4340  FORMAT(/1X,'Number of file to Plot (0-PlotMenu): ',$)
      READ(5,4350)NDIST1
4350  FORMAT(I1)
      IF (NDIST1 .EQ. 0) THEN
        RETURN
      ELSE IF(NDIST1.GT.15) THEN
        WRITE(6,4360)
4360    FORMAT(1X,'Sorry, that is out of range.')
        WRITE(6,4370)
4370    FORMAT(' ')
        GOTO 4270
      END IF
      MAX_CURVE = 0
4380  IF ((.false.)) THEN
        WRITE(6,4390)
4390    FORMAT(' Starting :ENTER_AXIS1:')
      END IF
      WRITE(6,4400)
4400  FORMAT(/1X,'Axis for Profile (0-PlotMenu,1-X,2-Y,3-Z): ',$)
      READ(5,4410)LA_AXIS
4410  FORMAT(I5)
      IF ((LA_AXIS .EQ. 0)) THEN
        RETURN
      END IF
      IF ((LA_AXIS.LT.1.OR.LA_AXIS.GT.3)) THEN
        GOTO 4380
      ELSE
        IF (LA_AXIS .EQ. 1) THEN
          XAXIS = 'X axis/cm'
          YAXIS = 'dose /Gy'
          DO 4421 L=1,4
            IOPTION(L) = 0
4421      CONTINUE
4422      CONTINUE
        ELSE IF(LA_AXIS .EQ. 2) THEN
          XAXIS = 'Y axis/cm'
          YAXIS = 'dose /Gy'
          DO 4431 L=1,4
            IOPTION(L) = 0
4431      CONTINUE
4432      CONTINUE
        ELSE IF(LA_AXIS .EQ. 3) THEN
          XAXIS = 'Z axis/cm'
          YAXIS = 'dose /Gy'
          DO 4441 L=1,4
            IOPTION(L) = 0
4441      CONTINUE
4442      CONTINUE
        END IF
      END IF
      IF ((.false.)) THEN
        WRITE(6,4450)LA_AXIS
4450    FORMAT(' Selected LA_AXIS=',I3)
      END IF
      CALL LETTERCOUNT(FILEIN(NDIST1),NUMCHAR)
      WRITE(6,4460)FILEIN(NDIST1)(1:NUMCHAR)
4460  FORMAT(1X,'Graph Title (default=Profile for ', A,'): ',$)
      READ(5,4470)TITLE
4470  FORMAT(A)
      IF (TITLE .EQ. ' ') THEN
        TITLE = 'Profile for '//FILEIN(NDIST1)(1:NUMCHAR)
      END IF
      WRITE(6,4480)FILEIN(NDIST1)(1:NUMCHAR)
4480  FORMAT(1X,'Output Filename (default=',A, '): ',$)
      READ(5,4490)OUTFILE
4490  FORMAT(A)
      IF (OUTFILE .EQ. ' ') THEN
        OUTFILE = FILEIN(NDIST1)(1:NUMCHAR)
      END IF
      WRITE(6,4500)
4500  FORMAT(1X,'Number of curves to Plot: ',$)
      READ(5,4510)MAX_CURVE
4510  FORMAT(I5)
      IF (MAX_CURVE .EQ. 0) THEN
        RETURN
      END IF
      IF ((MAX_CURVE .GT. 1)) THEN
        WRITE(6,4520)
4520    FORMAT(1X,'Generate Automatic Offset? (y/n) [n]: ',$)
        READ(5,4530)REPLY
4530    FORMAT(A)
      ELSE
        REPLY='n'
      END IF
      WRITE(6,4540)
4540  FORMAT(' ')
      NCURVE = 0
      outfile = outfile(1:lnblnk1(outfile))//'.agr'
      OPEN(UNIT=7,STATUS='UNKNOWN',FILE=outfile)
4550  IF ((.false.)) THEN
        WRITE(6,4560)
4560    FORMAT(' Starting :DEFINE_CURVE1: loop')
      END IF
      NCURVE = NCURVE + 1
      IF (LA_AXIS .EQ. 1) THEN
        WRITE(6,4570)
4570    FORMAT(1X,'Coordinates of Axis (y,z): ',$)
        READ(5,*) YCOORD,ZCOORD
        IF ((.false.)) THEN
          WRITE(6,4580)YCOORD,ZCOORD
4580      FORMAT(1x,'Will plot at YCOORD,ZCOORD=',2F10.4)
        END IF
      END IF
      IF (LA_AXIS .EQ. 2) THEN
        WRITE(6,4590)
4590    FORMAT(1X,'Coordinates of Axis (x,z): ',$)
        READ(5,*) XCOORD,ZCOORD
        IF ((.false.)) THEN
          WRITE(6,4600)XCOORD,ZCOORD
4600      FORMAT(1x,'Will plot at XCOORD,ZCOORD=',2F10.4)
        END IF
      END IF
      IF (LA_AXIS .EQ. 3) THEN
        WRITE(6,4610)
4610    FORMAT(1X,'Coordinates of Axis (x,y): ')
        READ(5,*) XCOORD,YCOORD
        IF ((.false.)) THEN
          WRITE(6,4620)XCOORD,YCOORD
4620      FORMAT(1x,'Will plot at XCOORD,YCOORD=',2F10.4)
        END IF
      END IF
      WRITE(6,4630)NDIST1,FILEIN(NDIST1)(1:NUMCHAR)
4630  FORMAT(/1X,'3D-dose distribution ',I2,': ',A)
      I0=0
      J0=0
      K0=0
      IF (LA_AXIS .EQ. 1) THEN
        DO 4641 J0=2,JMAX(NDIST1)
          VOXEL_MEAS = YBOUND(NDIST1,J0)
          IF ((VOXEL_MEAS.GT.YCOORD)) THEN
            GO TO4642
          END IF
4641    CONTINUE
4642    CONTINUE
        J0 = J0-1
        DO 4651 K0=2,KMAX(NDIST1)
          VOXEL_MEAS = ZBOUND(NDIST1,K0)
          IF ((VOXEL_MEAS.GT.ZCOORD)) THEN
            GO TO4652
          END IF
4651    CONTINUE
4652    CONTINUE
        K0 = K0-1
      ELSE IF(LA_AXIS .EQ. 2) THEN
        DO 4661 I0=2,IMAX(NDIST1)
          VOXEL_MEAS = XBOUND(NDIST1,I0)
          IF ((VOXEL_MEAS.GT.XCOORD)) THEN
            GO TO4662
          END IF
4661    CONTINUE
4662    CONTINUE
        I0 = I0-1
        DO 4671 K0=2,KMAX(NDIST1)
          VOXEL_MEAS = ZBOUND(NDIST1,K0)
          IF ((VOXEL_MEAS.GT.ZCOORD)) THEN
            GO TO4672
          END IF
4671    CONTINUE
4672    CONTINUE
        K0 = K0-1
      ELSE IF(LA_AXIS .EQ. 3) THEN
        DO 4681 I0=2,IMAX(NDIST1)
          VOXEL_MEAS = XBOUND(NDIST1,I0)
          IF ((VOXEL_MEAS.GT.XCOORD)) THEN
            GO TO4682
          END IF
4681    CONTINUE
4682    CONTINUE
        I0 = I0-1
        DO 4691 J0=2,JMAX(NDIST1)
          VOXEL_MEAS = YBOUND(NDIST1,J0)
          IF ((VOXEL_MEAS.GT.YCOORD)) THEN
            GO TO4692
          END IF
4691    CONTINUE
4692    CONTINUE
        J0 = J0-1
      END IF
      IF (LA_AXIS .EQ. 1) THEN
        DO 4701 I0=1,IMAX(NDIST1)
          PROFILEDOSE(I0) = DOSE(NDIST1,I0,J0,K0)
          PROFILERR(I0) = ERRDOSE(NDIST1,I0,J0,K0)
4701    CONTINUE
4702    CONTINUE
        IF ((.false.)) THEN
          WRITE(6,4710)
4710      FORMAT(/' Following is PRINT_BOUNDS output')
          WRITE(6,4720)J0,K0
4720      FORMAT(1X,'Profile along X-axis at voxel :',2I3)
          WRITE(6,4730)IMAX(NDIST1),JMAX(NDIST1),KMAX(NDIST1)
4730      FORMAT(/1X,'Number of voxels in x,y,z directions: ',3I10)
          WRITE(6,4740)XBOUND(NDIST1,1),XBOUND(NDIST1,IMAX(NDIST1)+1)
4740      FORMAT(1X,'Voxel-boundary values in x-direction: ',F10.2,2X,'-
     *',F7.2)
          WRITE(6,4750)YBOUND(NDIST1,1),YBOUND(NDIST1,JMAX(NDIST1)+1)
4750      FORMAT(1X,'Voxel-boundary values in y-direction: ',F10.2,2X,'-
     *',F7.2)
          WRITE(6,4760)ZBOUND(NDIST1,1),ZBOUND(NDIST1,KMAX(NDIST1)+1)
4760      FORMAT(1X,'Voxel-boundary values in z-direction: ',F10.2,2X,'-
     *',F7.2)
          WRITE(6,4770)
4770      FORMAT(' ')
          DO 4781 I0=1,IMAX(NDIST1)
            WRITE(6,4790)((XBOUND(NDIST1,I0)+XBOUND(NDIST1,I0+1))/2), PR
     *      OFILEDOSE(I0),PROFILERR(I0)
4790        FORMAT(1X,'X','BOUND=',E15.5,1X,'DOSE=',E12.5,1X,'ERRDOSE=',
     *E12.5)
4781      CONTINUE
4782      CONTINUE
          WRITE(6,4800)
4800      FORMAT(' ')
        END IF
        NPOINTS = IMAX(NDIST1)
        IF ((REPLY.EQ.'y')) THEN
          DO 4811 I0=1,IMAX(NDIST1)
            X(I0)=((XBOUND(NDIST1,I0)+ XBOUND(NDIST1,I0+1))/2)+(.1*(NCUR
     *      VE-1)* (XBOUND(NDIST1,I0+1)-XBOUND(NDIST1,I0)))
            Y(I0)=PROFILEDOSE(I0)
            ERRY(I0)=PROFILERR(I0)
4811      CONTINUE
4812      CONTINUE
        ELSE
          DO 4821 I0=1,IMAX(NDIST1)
            X(I0)=((XBOUND(NDIST1,I0)+ XBOUND(NDIST1,I0+1))/2)
            Y(I0)=PROFILEDOSE(I0)
            ERRY(I0)=PROFILERR(I0)
4821      CONTINUE
4822      CONTINUE
        END IF
        IF (LA_AXIS.EQ.1) THEN
          ISTR=0
          JSTR=0
          ICOUNT = 0
          INTY=INT((ABS(YBOUND(NDIST1,J0)+YBOUND(NDIST1,J0+1))/2) *10+0.
     *    5)
          IF (INTY.NE.0) THEN
4831        CONTINUE
              ISTR=ISTR+1
              NUM_ARR(ISTR) = INTY-(INTY/10)*10
              INTY = INTY/10
              IF((INTY.EQ.0))GO TO4832
            GO TO 4831
4832        CONTINUE
            THE_STRING=' ('
            ICOUNT = 2
            IF ((YBOUND(NDIST1,J0)+YBOUND(NDIST1,J0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT = ICOUNT+1
            END IF
            DO 4841 N=ISTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(N)+48)
              ICOUNT = ICOUNT+1
4841        CONTINUE
4842        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT=ICOUNT+2
          ELSE
            THE_STRING=' (0.0'
            ICOUNT = 5
          END IF
          INTZ=INT((ABS(ZBOUND(NDIST1,K0)+ZBOUND(NDIST1,K0+1))/2) *10+0.
     *    5)
          IF (INTZ.NE.0) THEN
4851        CONTINUE
              JSTR=JSTR+1
              NUM_ARR(JSTR) = INTZ-(INTZ/10)*10
              INTZ = INTZ/10
              IF((INTZ.EQ.0))GO TO4852
            GO TO 4851
4852        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//','
            ICOUNT = ICOUNT+1
            IF ((ZBOUND(NDIST1,K0)+ZBOUND(NDIST1,K0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT=ICOUNT+1
            END IF
            DO 4861 M=JSTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(M)+48)
              ICOUNT = ICOUNT+1
4861        CONTINUE
4862        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT= ICOUNT+2
            THE_STRING=THE_STRING(1:ICOUNT)//')'
            ICOUNT = ICOUNT+1
          ELSE
            THE_STRING=THE_STRING(1:ICOUNT)//',0.0)'
            ICOUNT=ICOUNT+5
          END IF
        ELSE IF(LA_AXIS.EQ.2) THEN
          ISTR=0
          JSTR=0
          ICOUNT = 0
          INTX=INT((ABS(XBOUND(NDIST1,I0)+XBOUND(NDIST1,I0+1))/2) *10+0.
     *    5)
          IF (INTX.NE.0) THEN
4871        CONTINUE
              ISTR=ISTR+1
              NUM_ARR(ISTR) = INTX-(INTX/10)*10
              INTX = INTX/10
              IF((INTX.EQ.0))GO TO4872
            GO TO 4871
4872        CONTINUE
            THE_STRING=' ('
            ICOUNT = 2
            IF ((XBOUND(NDIST1,I0)+XBOUND(NDIST1,I0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT = ICOUNT+1
            END IF
            DO 4881 N=ISTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(N)+48)
              ICOUNT = ICOUNT+1
4881        CONTINUE
4882        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT=ICOUNT+2
          ELSE
            THE_STRING=' (0.0'
            ICOUNT = 5
          END IF
          INTZ=INT((ABS(ZBOUND(NDIST1,K0)+ZBOUND(NDIST1,K0+1))/2) *10+0.
     *    5)
          IF (INTZ.NE.0) THEN
4891        CONTINUE
              JSTR=JSTR+1
              NUM_ARR(JSTR) = INTZ-(INTZ/10)*10
              INTZ = INTZ/10
              IF((INTZ.EQ.0))GO TO4892
            GO TO 4891
4892        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//','
            ICOUNT = ICOUNT+1
            IF ((ZBOUND(NDIST1,K0)+ZBOUND(NDIST1,K0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT=ICOUNT+1
            END IF
            DO 4901 M=JSTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(M)+48)
              ICOUNT = ICOUNT+1
4901        CONTINUE
4902        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT= ICOUNT+2
            THE_STRING=THE_STRING(1:ICOUNT)//')'
            ICOUNT = ICOUNT+1
          ELSE
            THE_STRING=THE_STRING(1:ICOUNT)//',0.0)'
            ICOUNT=ICOUNT+5
          END IF
        ELSE IF(LA_AXIS.EQ.3) THEN
          ISTR=0
          JSTR=0
          ICOUNT = 0
          INTX=INT((ABS(XBOUND(NDIST1,I0)+XBOUND(NDIST1,I0+1))/2) *10+0.
     *    5)
          IF (INTX.NE.0) THEN
4911        CONTINUE
              ISTR=ISTR+1
              NUM_ARR(ISTR) = INTX-(INTX/10)*10
              INTX = INTX/10
              IF((INTX.EQ.0))GO TO4912
            GO TO 4911
4912        CONTINUE
            THE_STRING=' ('
            ICOUNT = 2
            IF ((XBOUND(NDIST1,I0)+XBOUND(NDIST1,I0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT = ICOUNT+1
            END IF
            DO 4921 N=ISTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(N)+48)
              ICOUNT = ICOUNT+1
4921        CONTINUE
4922        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT=ICOUNT+2
          ELSE
            THE_STRING=' (0.0'
            ICOUNT = 5
          END IF
          INTY=INT((ABS(YBOUND(NDIST1,J0)+YBOUND(NDIST1,J0+1))/2) *10+0.
     *    5)
          IF (INTY.NE.0) THEN
4931        CONTINUE
              JSTR=JSTR+1
              NUM_ARR(JSTR) = INTY-(INTY/10)*10
              INTY = INTY/10
              IF((INTY.EQ.0))GO TO4932
            GO TO 4931
4932        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//','
            ICOUNT = ICOUNT+1
            IF ((YBOUND(NDIST1,J0)+YBOUND(NDIST1,J0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT=ICOUNT+1
            END IF
            DO 4941 M=JSTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(M)+48)
              ICOUNT = ICOUNT+1
4941        CONTINUE
4942        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT= ICOUNT+2
            THE_STRING=THE_STRING(1:ICOUNT)//')'
            ICOUNT = ICOUNT+1
          ELSE
            THE_STRING=THE_STRING(1:ICOUNT)//',0.0)'
            ICOUNT=ICOUNT+5
          END IF
        END IF
        CURVE_LABELS=THE_STRING
        NTYPE_SYMBOL = MOD(NCURVE,9)+1
        NTYPE_CURVE = MOD(NCURVE,5)+1
        CURVE_SPECS = CHAR(NTYPE_SYMBOL+48)//CHAR(NTYPE_CURVE+48)
      ELSE IF(LA_AXIS .EQ. 2) THEN
        DO 4951 J0=1,JMAX(NDIST1)
          PROFILEDOSE(J0) = DOSE(NDIST1,I0,J0,K0)
          PROFILERR(J0) = ERRDOSE(NDIST1,I0,J0,K0)
4951    CONTINUE
4952    CONTINUE
        IF ((.false.)) THEN
          WRITE(6,4960)
4960      FORMAT(/' Following is PRINT_BOUNDS output')
          WRITE(6,4970)I0,K0
4970      FORMAT(1X,'Profile along Y-axis at voxel :',2I3)
          WRITE(6,4980)IMAX(NDIST1),JMAX(NDIST1),KMAX(NDIST1)
4980      FORMAT(/1X,'Number of voxels in x,y,z directions: ',3I10)
          WRITE(6,4990)XBOUND(NDIST1,1),XBOUND(NDIST1,IMAX(NDIST1)+1)
4990      FORMAT(1X,'Voxel-boundary values in x-direction: ',F10.2,2X,'-
     *',F7.2)
          WRITE(6,5000)YBOUND(NDIST1,1),YBOUND(NDIST1,JMAX(NDIST1)+1)
5000      FORMAT(1X,'Voxel-boundary values in y-direction: ',F10.2,2X,'-
     *',F7.2)
          WRITE(6,5010)ZBOUND(NDIST1,1),ZBOUND(NDIST1,KMAX(NDIST1)+1)
5010      FORMAT(1X,'Voxel-boundary values in z-direction: ',F10.2,2X,'-
     *',F7.2)
          WRITE(6,5020)
5020      FORMAT(' ')
          DO 5031 J0=1,JMAX(NDIST1)
            WRITE(6,5040)((YBOUND(NDIST1,J0)+YBOUND(NDIST1,J0+1))/2), PR
     *      OFILEDOSE(J0),PROFILERR(J0)
5040        FORMAT(1X,'Y','BOUND=',E15.5,1X,'DOSE=',E12.5,1X,'ERRDOSE=',
     *E12.5)
5031      CONTINUE
5032      CONTINUE
          WRITE(6,5050)
5050      FORMAT(' ')
        END IF
        NPOINTS = JMAX(NDIST1)
        IF ((REPLY.EQ.'y')) THEN
          DO 5061 J0=1,JMAX(NDIST1)
            X(J0)=((YBOUND(NDIST1,J0)+ YBOUND(NDIST1,J0+1))/2)+(.1*(NCUR
     *      VE-1)* (YBOUND(NDIST1,J0+1)-YBOUND(NDIST1,J0)))
            Y(J0)=PROFILEDOSE(J0)
            ERRY(J0)=PROFILERR(J0)
5061      CONTINUE
5062      CONTINUE
        ELSE
          DO 5071 J0=1,JMAX(NDIST1)
            X(J0)=((YBOUND(NDIST1,J0)+ YBOUND(NDIST1,J0+1))/2)
            Y(J0)=PROFILEDOSE(J0)
            ERRY(J0)=PROFILERR(J0)
5071      CONTINUE
5072      CONTINUE
        END IF
        IF (LA_AXIS.EQ.1) THEN
          ISTR=0
          JSTR=0
          ICOUNT = 0
          INTY=INT((ABS(YBOUND(NDIST1,J0)+YBOUND(NDIST1,J0+1))/2) *10+0.
     *    5)
          IF (INTY.NE.0) THEN
5081        CONTINUE
              ISTR=ISTR+1
              NUM_ARR(ISTR) = INTY-(INTY/10)*10
              INTY = INTY/10
              IF((INTY.EQ.0))GO TO5082
            GO TO 5081
5082        CONTINUE
            THE_STRING=' ('
            ICOUNT = 2
            IF ((YBOUND(NDIST1,J0)+YBOUND(NDIST1,J0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT = ICOUNT+1
            END IF
            DO 5091 N=ISTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(N)+48)
              ICOUNT = ICOUNT+1
5091        CONTINUE
5092        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT=ICOUNT+2
          ELSE
            THE_STRING=' (0.0'
            ICOUNT = 5
          END IF
          INTZ=INT((ABS(ZBOUND(NDIST1,K0)+ZBOUND(NDIST1,K0+1))/2) *10+0.
     *    5)
          IF (INTZ.NE.0) THEN
5101        CONTINUE
              JSTR=JSTR+1
              NUM_ARR(JSTR) = INTZ-(INTZ/10)*10
              INTZ = INTZ/10
              IF((INTZ.EQ.0))GO TO5102
            GO TO 5101
5102        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//','
            ICOUNT = ICOUNT+1
            IF ((ZBOUND(NDIST1,K0)+ZBOUND(NDIST1,K0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT=ICOUNT+1
            END IF
            DO 5111 M=JSTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(M)+48)
              ICOUNT = ICOUNT+1
5111        CONTINUE
5112        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT= ICOUNT+2
            THE_STRING=THE_STRING(1:ICOUNT)//')'
            ICOUNT = ICOUNT+1
          ELSE
            THE_STRING=THE_STRING(1:ICOUNT)//',0.0)'
            ICOUNT=ICOUNT+5
          END IF
        ELSE IF(LA_AXIS.EQ.2) THEN
          ISTR=0
          JSTR=0
          ICOUNT = 0
          INTX=INT((ABS(XBOUND(NDIST1,I0)+XBOUND(NDIST1,I0+1))/2) *10+0.
     *    5)
          IF (INTX.NE.0) THEN
5121        CONTINUE
              ISTR=ISTR+1
              NUM_ARR(ISTR) = INTX-(INTX/10)*10
              INTX = INTX/10
              IF((INTX.EQ.0))GO TO5122
            GO TO 5121
5122        CONTINUE
            THE_STRING=' ('
            ICOUNT = 2
            IF ((XBOUND(NDIST1,I0)+XBOUND(NDIST1,I0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT = ICOUNT+1
            END IF
            DO 5131 N=ISTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(N)+48)
              ICOUNT = ICOUNT+1
5131        CONTINUE
5132        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT=ICOUNT+2
          ELSE
            THE_STRING=' (0.0'
            ICOUNT = 5
          END IF
          INTZ=INT((ABS(ZBOUND(NDIST1,K0)+ZBOUND(NDIST1,K0+1))/2) *10+0.
     *    5)
          IF (INTZ.NE.0) THEN
5141        CONTINUE
              JSTR=JSTR+1
              NUM_ARR(JSTR) = INTZ-(INTZ/10)*10
              INTZ = INTZ/10
              IF((INTZ.EQ.0))GO TO5142
            GO TO 5141
5142        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//','
            ICOUNT = ICOUNT+1
            IF ((ZBOUND(NDIST1,K0)+ZBOUND(NDIST1,K0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT=ICOUNT+1
            END IF
            DO 5151 M=JSTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(M)+48)
              ICOUNT = ICOUNT+1
5151        CONTINUE
5152        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT= ICOUNT+2
            THE_STRING=THE_STRING(1:ICOUNT)//')'
            ICOUNT = ICOUNT+1
          ELSE
            THE_STRING=THE_STRING(1:ICOUNT)//',0.0)'
            ICOUNT=ICOUNT+5
          END IF
        ELSE IF(LA_AXIS.EQ.3) THEN
          ISTR=0
          JSTR=0
          ICOUNT = 0
          INTX=INT((ABS(XBOUND(NDIST1,I0)+XBOUND(NDIST1,I0+1))/2) *10+0.
     *    5)
          IF (INTX.NE.0) THEN
5161        CONTINUE
              ISTR=ISTR+1
              NUM_ARR(ISTR) = INTX-(INTX/10)*10
              INTX = INTX/10
              IF((INTX.EQ.0))GO TO5162
            GO TO 5161
5162        CONTINUE
            THE_STRING=' ('
            ICOUNT = 2
            IF ((XBOUND(NDIST1,I0)+XBOUND(NDIST1,I0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT = ICOUNT+1
            END IF
            DO 5171 N=ISTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(N)+48)
              ICOUNT = ICOUNT+1
5171        CONTINUE
5172        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT=ICOUNT+2
          ELSE
            THE_STRING=' (0.0'
            ICOUNT = 5
          END IF
          INTY=INT((ABS(YBOUND(NDIST1,J0)+YBOUND(NDIST1,J0+1))/2) *10+0.
     *    5)
          IF (INTY.NE.0) THEN
5181        CONTINUE
              JSTR=JSTR+1
              NUM_ARR(JSTR) = INTY-(INTY/10)*10
              INTY = INTY/10
              IF((INTY.EQ.0))GO TO5182
            GO TO 5181
5182        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//','
            ICOUNT = ICOUNT+1
            IF ((YBOUND(NDIST1,J0)+YBOUND(NDIST1,J0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT=ICOUNT+1
            END IF
            DO 5191 M=JSTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(M)+48)
              ICOUNT = ICOUNT+1
5191        CONTINUE
5192        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT= ICOUNT+2
            THE_STRING=THE_STRING(1:ICOUNT)//')'
            ICOUNT = ICOUNT+1
          ELSE
            THE_STRING=THE_STRING(1:ICOUNT)//',0.0)'
            ICOUNT=ICOUNT+5
          END IF
        END IF
        CURVE_LABELS=THE_STRING
        NTYPE_SYMBOL = MOD(NCURVE,9)+1
        NTYPE_CURVE = MOD(NCURVE,5)+1
        CURVE_SPECS = CHAR(NTYPE_SYMBOL+48)//CHAR(NTYPE_CURVE+48)
      ELSE IF(LA_AXIS .EQ. 3) THEN
        DO 5201 K0=1,KMAX(NDIST1)
          PROFILEDOSE(K0) = DOSE(NDIST1,I0,J0,K0)
          PROFILERR(K0) = ERRDOSE(NDIST1,I0,J0,K0)
5201    CONTINUE
5202    CONTINUE
        IF ((.false.)) THEN
          WRITE(6,5210)
5210      FORMAT(/' Following is PRINT_BOUNDS output')
          WRITE(6,5220)I0,J0
5220      FORMAT(1X,'Profile along Z-axis at voxel :',2I3)
          WRITE(6,5230)IMAX(NDIST1),JMAX(NDIST1),KMAX(NDIST1)
5230      FORMAT(/1X,'Number of voxels in x,y,z directions: ',3I10)
          WRITE(6,5240)XBOUND(NDIST1,1),XBOUND(NDIST1,IMAX(NDIST1)+1)
5240      FORMAT(1X,'Voxel-boundary values in x-direction: ',F10.2,2X,'-
     *',F7.2)
          WRITE(6,5250)YBOUND(NDIST1,1),YBOUND(NDIST1,JMAX(NDIST1)+1)
5250      FORMAT(1X,'Voxel-boundary values in y-direction: ',F10.2,2X,'-
     *',F7.2)
          WRITE(6,5260)ZBOUND(NDIST1,1),ZBOUND(NDIST1,KMAX(NDIST1)+1)
5260      FORMAT(1X,'Voxel-boundary values in z-direction: ',F10.2,2X,'-
     *',F7.2)
          WRITE(6,5270)
5270      FORMAT(' ')
          DO 5281 K0=1,KMAX(NDIST1)
            WRITE(6,5290)((ZBOUND(NDIST1,K0)+ZBOUND(NDIST1,K0+1))/2), PR
     *      OFILEDOSE(K0),PROFILERR(K0)
5290        FORMAT(1X,'Z','BOUND=',E15.5,1X,'DOSE=',E12.5,1X,'ERRDOSE=',
     *E12.5)
5281      CONTINUE
5282      CONTINUE
          WRITE(6,5300)
5300      FORMAT(' ')
        END IF
        NPOINTS = KMAX(NDIST1)
        IF ((REPLY.EQ.'y')) THEN
          DO 5311 K0=1,KMAX(NDIST1)
            X(K0)=((ZBOUND(NDIST1,K0)+ ZBOUND(NDIST1,K0+1))/2)+(.1*(NCUR
     *      VE-1)* (ZBOUND(NDIST1,K0+1)-ZBOUND(NDIST1,K0)))
            Y(K0)=PROFILEDOSE(K0)
            ERRY(K0)=PROFILERR(K0)
5311      CONTINUE
5312      CONTINUE
        ELSE
          DO 5321 K0=1,KMAX(NDIST1)
            X(K0)=((ZBOUND(NDIST1,K0)+ ZBOUND(NDIST1,K0+1))/2)
            Y(K0)=PROFILEDOSE(K0)
            ERRY(K0)=PROFILERR(K0)
5321      CONTINUE
5322      CONTINUE
        END IF
        IF (LA_AXIS.EQ.1) THEN
          ISTR=0
          JSTR=0
          ICOUNT = 0
          INTY=INT((ABS(YBOUND(NDIST1,J0)+YBOUND(NDIST1,J0+1))/2) *10+0.
     *    5)
          IF (INTY.NE.0) THEN
5331        CONTINUE
              ISTR=ISTR+1
              NUM_ARR(ISTR) = INTY-(INTY/10)*10
              INTY = INTY/10
              IF((INTY.EQ.0))GO TO5332
            GO TO 5331
5332        CONTINUE
            THE_STRING=' ('
            ICOUNT = 2
            IF ((YBOUND(NDIST1,J0)+YBOUND(NDIST1,J0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT = ICOUNT+1
            END IF
            DO 5341 N=ISTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(N)+48)
              ICOUNT = ICOUNT+1
5341        CONTINUE
5342        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT=ICOUNT+2
          ELSE
            THE_STRING=' (0.0'
            ICOUNT = 5
          END IF
          INTZ=INT((ABS(ZBOUND(NDIST1,K0)+ZBOUND(NDIST1,K0+1))/2) *10+0.
     *    5)
          IF (INTZ.NE.0) THEN
5351        CONTINUE
              JSTR=JSTR+1
              NUM_ARR(JSTR) = INTZ-(INTZ/10)*10
              INTZ = INTZ/10
              IF((INTZ.EQ.0))GO TO5352
            GO TO 5351
5352        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//','
            ICOUNT = ICOUNT+1
            IF ((ZBOUND(NDIST1,K0)+ZBOUND(NDIST1,K0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT=ICOUNT+1
            END IF
            DO 5361 M=JSTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(M)+48)
              ICOUNT = ICOUNT+1
5361        CONTINUE
5362        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT= ICOUNT+2
            THE_STRING=THE_STRING(1:ICOUNT)//')'
            ICOUNT = ICOUNT+1
          ELSE
            THE_STRING=THE_STRING(1:ICOUNT)//',0.0)'
            ICOUNT=ICOUNT+5
          END IF
        ELSE IF(LA_AXIS.EQ.2) THEN
          ISTR=0
          JSTR=0
          ICOUNT = 0
          INTX=INT((ABS(XBOUND(NDIST1,I0)+XBOUND(NDIST1,I0+1))/2) *10+0.
     *    5)
          IF (INTX.NE.0) THEN
5371        CONTINUE
              ISTR=ISTR+1
              NUM_ARR(ISTR) = INTX-(INTX/10)*10
              INTX = INTX/10
              IF((INTX.EQ.0))GO TO5372
            GO TO 5371
5372        CONTINUE
            THE_STRING=' ('
            ICOUNT = 2
            IF ((XBOUND(NDIST1,I0)+XBOUND(NDIST1,I0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT = ICOUNT+1
            END IF
            DO 5381 N=ISTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(N)+48)
              ICOUNT = ICOUNT+1
5381        CONTINUE
5382        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT=ICOUNT+2
          ELSE
            THE_STRING=' (0.0'
            ICOUNT = 5
          END IF
          INTZ=INT((ABS(ZBOUND(NDIST1,K0)+ZBOUND(NDIST1,K0+1))/2) *10+0.
     *    5)
          IF (INTZ.NE.0) THEN
5391        CONTINUE
              JSTR=JSTR+1
              NUM_ARR(JSTR) = INTZ-(INTZ/10)*10
              INTZ = INTZ/10
              IF((INTZ.EQ.0))GO TO5392
            GO TO 5391
5392        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//','
            ICOUNT = ICOUNT+1
            IF ((ZBOUND(NDIST1,K0)+ZBOUND(NDIST1,K0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT=ICOUNT+1
            END IF
            DO 5401 M=JSTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(M)+48)
              ICOUNT = ICOUNT+1
5401        CONTINUE
5402        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT= ICOUNT+2
            THE_STRING=THE_STRING(1:ICOUNT)//')'
            ICOUNT = ICOUNT+1
          ELSE
            THE_STRING=THE_STRING(1:ICOUNT)//',0.0)'
            ICOUNT=ICOUNT+5
          END IF
        ELSE IF(LA_AXIS.EQ.3) THEN
          ISTR=0
          JSTR=0
          ICOUNT = 0
          INTX=INT((ABS(XBOUND(NDIST1,I0)+XBOUND(NDIST1,I0+1))/2) *10+0.
     *    5)
          IF (INTX.NE.0) THEN
5411        CONTINUE
              ISTR=ISTR+1
              NUM_ARR(ISTR) = INTX-(INTX/10)*10
              INTX = INTX/10
              IF((INTX.EQ.0))GO TO5412
            GO TO 5411
5412        CONTINUE
            THE_STRING=' ('
            ICOUNT = 2
            IF ((XBOUND(NDIST1,I0)+XBOUND(NDIST1,I0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT = ICOUNT+1
            END IF
            DO 5421 N=ISTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(N)+48)
              ICOUNT = ICOUNT+1
5421        CONTINUE
5422        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT=ICOUNT+2
          ELSE
            THE_STRING=' (0.0'
            ICOUNT = 5
          END IF
          INTY=INT((ABS(YBOUND(NDIST1,J0)+YBOUND(NDIST1,J0+1))/2) *10+0.
     *    5)
          IF (INTY.NE.0) THEN
5431        CONTINUE
              JSTR=JSTR+1
              NUM_ARR(JSTR) = INTY-(INTY/10)*10
              INTY = INTY/10
              IF((INTY.EQ.0))GO TO5432
            GO TO 5431
5432        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//','
            ICOUNT = ICOUNT+1
            IF ((YBOUND(NDIST1,J0)+YBOUND(NDIST1,J0+1))/2.LT.0) THEN
              THE_STRING=THE_STRING(1:ICOUNT)//'-'
              ICOUNT=ICOUNT+1
            END IF
            DO 5441 M=JSTR,2,-1
              THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(M)+48)
              ICOUNT = ICOUNT+1
5441        CONTINUE
5442        CONTINUE
            THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
            ICOUNT= ICOUNT+2
            THE_STRING=THE_STRING(1:ICOUNT)//')'
            ICOUNT = ICOUNT+1
          ELSE
            THE_STRING=THE_STRING(1:ICOUNT)//',0.0)'
            ICOUNT=ICOUNT+5
          END IF
        END IF
        CURVE_LABELS=THE_STRING
        NTYPE_SYMBOL = MOD(NCURVE,9)+1
        NTYPE_CURVE = MOD(NCURVE,5)+1
        CURVE_SPECS = CHAR(NTYPE_SYMBOL+48)//CHAR(NTYPE_CURVE+48)
      ELSE
        WRITE(6,5450)
5450    FORMAT(1X,'ERROR, illegal data for axis')
      END IF
      SUBTITLE=' '
      XMIN=0.
      CALL XVGRPLOT(X,Y,ERRY,NPOINTS,NCURVE-1,CURVE_LABELS, XAXIS,YAXIS,
     *TITLE,SUBTITLE,7,IOPTION(1),XMIN,IOPTION(2))
      IF ((.false.)) THEN
        WRITE(6,5460)NCURVE,MAX_CURVE
5460    FORMAT('Have prepared data for curve',I3,' of',I3)
      END IF
      IF((NCURVE .LT. MAX_CURVE))GOTO 4550
5470  WRITE(6,5480)
5480  FORMAT(/1X,'Calling xmgrace...Please be patient! ')
      CLOSE(7)
      CALL XVGR_SCRIPT
      GOTO 4380
      END
      SUBROUTINE COMPAREPLOT
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      COMMON/DATA2/I,J,K,L,M,I0,J0,K0,IMAX,JMAX,KMAX, ICOUNT,INTX,INTY,I
     *NTZ,ISTR,JSTR,LA_AXIS,LTOT, MAX_CURVE,NCURVE,NDIST1,NDIST2,NUM_ARR
     *,NPOINTS,IOPTION,NTYPE_SYMBOL, NTYPE_CURVE,AXISDOSE,DDBIN_CHI,DDBI
     *N_DIFF,DOSE,ERRDOSE,ERRY, FREQ_CHI,FREQ_DIFF,PROFILEDOSE,PROFILERR
     *,TOTALNORM, XCOORD,YCOORD,ZCOORD, XBOUND,YBOUND,ZBOUND,X,Y,VOXEL_M
     *EAS, CURVE_LABELS,CURVE_SPECS,FILEIN,THE_STRING,TITLE,XAXIS,YAXIS,
     * OUTFILE
      INTEGER I,J,K,L,M
      INTEGER I0, J0, K0
      INTEGER IMAX(15),JMAX(15),KMAX(15)
      INTEGER ICOUNT
      INTEGER INTX,INTY,INTZ
      INTEGER ISTR,JSTR
      INTEGER LA_AXIS
      INTEGER LTOT
      INTEGER MAX_CURVE, NCURVE
      INTEGER NDIST1,NDIST2
      INTEGER NUM_ARR(10)
      INTEGER NPOINTS,IOPTION(4)
      INTEGER NTYPE_SYMBOL,NTYPE_CURVE
      REAL AXISDOSE(15,128)
      REAL DDBIN_CHI
      REAL DDBIN_DIFF
      REAL DOSE(15,128,128,128)
      REAL ERRDOSE(15,128,128,128)
      REAL ERRY(400)
      REAL FREQ_CHI(400)
      REAL FREQ_DIFF(400)
      REAL PROFILEDOSE(128+1),PROFILERR(128+1)
      REAL TOTALNORM(15)
      REAL XCOORD, YCOORD, ZCOORD
      REAL XBOUND(15,128+1),YBOUND(15,128+1), ZBOUND(15,128+1)
      REAL X(400),Y(400)
      REAL VOXEL_MEAS
      CHARACTER*60 CURVE_LABELS
      CHARACTER*2 CURVE_SPECS
      CHARACTER*70 FILEIN(15)
      CHARACTER*(10) THE_STRING
      CHARACTER*60 TITLE,XAXIS,YAXIS,OUTFILE,SUBTITLE
      REAL XMIN
      SAVE
      MAX_CURVE = 0
      DO 5491 I=1,10
        CURVE_LABELS='                    '
5491  CONTINUE
5492  CONTINUE
5500  WRITE(6,5510)
5510  FORMAT(/1X,'COMPARE-PLOT')
      WRITE(6,5520)
5520  FORMAT(1X,'------------')
      WRITE(6,5530)
5530  FORMAT(1X,'Axis for Compare-plot (0-PlotMenu,1-X,2-Y,3-Z): ',$)
      READ(5,5540)LA_AXIS
5540  FORMAT(I5)
      IF ((LA_AXIS.LT.1.OR.LA_AXIS.GT.3)) THEN
        RETURN
      ELSE
        IF (LA_AXIS .EQ. 1) THEN
          XAXIS = 'X axis/cm'
          YAXIS = 'dose /Gy'
          DO 5551 L=1,4
            IOPTION(L) = 0
5551      CONTINUE
5552      CONTINUE
        ELSE IF(LA_AXIS .EQ. 2) THEN
          XAXIS = 'Y axis/cm'
          YAXIS = 'dose /Gy'
          DO 5561 L=1,4
            IOPTION(L) = 0
5561      CONTINUE
5562      CONTINUE
        ELSE IF(LA_AXIS .EQ. 3) THEN
          XAXIS = 'Z axis/cm'
          YAXIS = 'dose /Gy'
          DO 5571 L=1,4
            IOPTION(L) = 0
5571      CONTINUE
5572      CONTINUE
        END IF
      END IF
      IF (LA_AXIS .EQ. 1) THEN
        WRITE(6,5580)
5580    FORMAT(1X,'Coordinates of Axis (y,z): ',$)
        READ(5,*) YCOORD,ZCOORD
      END IF
      IF (LA_AXIS .EQ. 2) THEN
        WRITE(6,5590)
5590    FORMAT(1X,'Coordinates of Axis (x,z): ',$)
        READ(5,*) XCOORD,ZCOORD
      END IF
      IF (LA_AXIS .EQ. 3) THEN
        WRITE(6,5600)
5600    FORMAT(1X,'Coordinates of Axis (x,y): ',$)
        READ(5,*) XCOORD,YCOORD
      END IF
      IF (LA_AXIS .EQ. 1) THEN
        ISTR=0
        JSTR=0
        ICOUNT = 0
        INTY=INT(ABS(YCOORD)*10+0.5)
        IF (INTY.NE.0) THEN
5611      CONTINUE
            ISTR=ISTR+1
            NUM_ARR(ISTR) = INTY-(INTY/10)*10
            INTY = INTY/10
            IF((INTY.EQ.0))GO TO5612
          GO TO 5611
5612      CONTINUE
          THE_STRING=' ('
          ICOUNT = 2
          IF (YCOORD.LT.0) THEN
            THE_STRING=THE_STRING(1:ICOUNT)//'-'
            ICOUNT = ICOUNT+1
          END IF
          DO 5621 N=ISTR,2,-1
            THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(N)+48)
            ICOUNT = ICOUNT+1
5621      CONTINUE
5622      CONTINUE
          THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
          ICOUNT=ICOUNT+2
        ELSE
          THE_STRING=' (0.0'
          ICOUNT = 5
        END IF
        INTZ=INT(ABS(ZCOORD)*10+0.5)
        IF (INTZ.NE.0) THEN
5631      CONTINUE
            JSTR=JSTR+1
            NUM_ARR(JSTR) = INTZ-(INTZ/10)*10
            INTZ = INTZ/10
            IF((INTZ.EQ.0))GO TO5632
          GO TO 5631
5632      CONTINUE
          THE_STRING=THE_STRING(1:ICOUNT)//','
          ICOUNT = ICOUNT+1
          IF (ZCOORD.LT.0) THEN
            THE_STRING=THE_STRING(1:ICOUNT)//'-'
            ICOUNT=ICOUNT+1
          END IF
          DO 5641 M=JSTR,2,-1
            THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(M)+48)
            ICOUNT = ICOUNT+1
5641      CONTINUE
5642      CONTINUE
          THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
          ICOUNT= ICOUNT+2
          THE_STRING=THE_STRING(1:ICOUNT)//')'
          ICOUNT = ICOUNT+1
        ELSE
          THE_STRING=THE_STRING(1:ICOUNT)//',0.0)'
          ICOUNT=ICOUNT+5
        END IF
      ELSE IF(LA_AXIS .EQ. 2) THEN
        ISTR=0
        JSTR=0
        ICOUNT = 0
        INTX=INT(ABS(XCOORD)*10+0.5)
        IF (INTX.NE.0) THEN
5651      CONTINUE
            ISTR=ISTR+1
            NUM_ARR(ISTR) = INTX-(INTX/10)*10
            INTX = INTX/10
            IF((INTX.EQ.0))GO TO5652
          GO TO 5651
5652      CONTINUE
          THE_STRING=' ('
          ICOUNT = 2
          IF (XCOORD.LT.0) THEN
            THE_STRING=THE_STRING(1:ICOUNT)//'-'
            ICOUNT = ICOUNT+1
          END IF
          DO 5661 N=ISTR,2,-1
            THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(N)+48)
            ICOUNT = ICOUNT+1
5661      CONTINUE
5662      CONTINUE
          THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
          ICOUNT=ICOUNT+2
        ELSE
          THE_STRING=' (0.0'
          ICOUNT = 5
        END IF
        INTZ=INT(ABS(ZCOORD)*10+0.5)
        IF (INTZ.NE.0) THEN
5671      CONTINUE
            JSTR=JSTR+1
            NUM_ARR(JSTR) = INTZ-(INTZ/10)*10
            INTZ = INTZ/10
            IF((INTZ.EQ.0))GO TO5672
          GO TO 5671
5672      CONTINUE
          THE_STRING=THE_STRING(1:ICOUNT)//','
          ICOUNT = ICOUNT+1
          IF (ZCOORD.LT.0) THEN
            THE_STRING=THE_STRING(1:ICOUNT)//'-'
            ICOUNT=ICOUNT+1
          END IF
          DO 5681 M=JSTR,2,-1
            THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(M)+48)
            ICOUNT = ICOUNT+1
5681      CONTINUE
5682      CONTINUE
          THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
          ICOUNT= ICOUNT+2
          THE_STRING=THE_STRING(1:ICOUNT)//')'
          ICOUNT = ICOUNT+1
        ELSE
          THE_STRING=THE_STRING(1:ICOUNT)//',0.0)'
          ICOUNT=ICOUNT+5
        END IF
      ELSE IF(LA_AXIS .EQ. 3) THEN
        ISTR=0
        JSTR=0
        ICOUNT = 0
        INTX=INT(ABS(XCOORD)*10+0.5)
        IF (INTX.NE.0) THEN
5691      CONTINUE
            ISTR=ISTR+1
            NUM_ARR(ISTR) = INTX-(INTX/10)*10
            INTX = INTX/10
            IF((INTX.EQ.0))GO TO5692
          GO TO 5691
5692      CONTINUE
          THE_STRING=' ('
          ICOUNT = 2
          IF (XCOORD.LT.0) THEN
            THE_STRING=THE_STRING(1:ICOUNT)//'-'
            ICOUNT = ICOUNT+1
          END IF
          DO 5701 N=ISTR,2,-1
            THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(N)+48)
            ICOUNT = ICOUNT+1
5701      CONTINUE
5702      CONTINUE
          THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
          ICOUNT=ICOUNT+2
        ELSE
          THE_STRING=' (0.0'
          ICOUNT = 5
        END IF
        INTY=INT(ABS(YCOORD)*10+0.5)
        IF (INTY.NE.0) THEN
5711      CONTINUE
            JSTR=JSTR+1
            NUM_ARR(JSTR) = INTY-(INTY/10)*10
            INTY = INTY/10
            IF((INTY.EQ.0))GO TO5712
          GO TO 5711
5712      CONTINUE
          THE_STRING=THE_STRING(1:ICOUNT)//','
          ICOUNT = ICOUNT+1
          IF (YCOORD.LT.0) THEN
            THE_STRING=THE_STRING(1:ICOUNT)//'-'
            ICOUNT=ICOUNT+1
          END IF
          DO 5721 M=JSTR,2,-1
            THE_STRING=THE_STRING(1:ICOUNT)//CHAR(NUM_ARR(M)+48)
            ICOUNT = ICOUNT+1
5721      CONTINUE
5722      CONTINUE
          THE_STRING=THE_STRING(1:ICOUNT)//'.'//CHAR(NUM_ARR(1)+48)
          ICOUNT= ICOUNT+2
          THE_STRING=THE_STRING(1:ICOUNT)//')'
          ICOUNT = ICOUNT+1
        ELSE
          THE_STRING=THE_STRING(1:ICOUNT)//',0.0)'
          ICOUNT=ICOUNT+5
        END IF
      END IF
      WRITE(6,5730)THE_STRING(1:ICOUNT)
5730  FORMAT(1X,'Graph Title (default=Compareplot at ',A,'): ',$)
      READ(5,5740)TITLE
5740  FORMAT(A)
      IF (TITLE .EQ. ' ') THEN
        TITLE = 'Compareplot at '//THE_STRING(1:ICOUNT)
      END IF
      WRITE(6,5750)
5750  FORMAT(1X,'Output Filename (default=Compareplot.agr): ',$)
      READ(5,5760)OUTFILE
5760  FORMAT(A)
      IF (OUTFILE .EQ. ' ') THEN
        OUTFILE = 'Compareplot'
      END IF
      WRITE(6,5770)
5770  FORMAT(/1X,'Generate Automatic Offset? (y/n) [n]: ',$)
      READ(5,5780)REPLY
5780  FORMAT(A)
      NCURVE = 0
      outfile=outfile(1:lnblnk1(outfile))//'.agr'
      OPEN(UNIT=7,STATUS='UNKNOWN',FILE=outfile)
5790  CONTINUE
5800  WRITE(6,5810)
5810  FORMAT(/1X,'Files currently loaded:'/)
      DO 5821 N=1,15
        IF (NDIST1_FLAG(N) .EQ. 1) THEN
          WRITE(6,5830)N,FILEIN(N)
5830      FORMAT(I2,' - ',A)
        END IF
5821  CONTINUE
5822  CONTINUE
      WRITE(6,5840)
5840  FORMAT(/1X,'Input curve # to be plotted in this graph (0=>View Gra
     *ph): ',$)
      READ(5,5850)NDIST1
5850  FORMAT(I2)
      IF (NDIST1 .EQ. 0) THEN
        IF (NCURVE .EQ. 0) THEN
          RETURN
        ELSE
          GOTO 5860
        END IF
      ELSE IF(NDIST1.GT.15) THEN
        WRITE(6,5870)
5870    FORMAT(1X,'Sorry, that is out of range.'/)
        GOTO 5800
      END IF
      NCURVE = NCURVE + 1
      I0=0
      J0=0
      K0=0
      IF (LA_AXIS .EQ. 1) THEN
        DO 5881 J0=2,JMAX(NDIST1)
          VOXEL_MEAS = YBOUND(NDIST1,J0)
          IF ((VOXEL_MEAS.GT.YCOORD)) THEN
            GO TO5882
          END IF
5881    CONTINUE
5882    CONTINUE
        J0 = J0-1
        DO 5891 K0=2,KMAX(NDIST1)
          VOXEL_MEAS = ZBOUND(NDIST1,K0)
          IF ((VOXEL_MEAS.GT.ZCOORD)) THEN
            GO TO5892
          END IF
5891    CONTINUE
5892    CONTINUE
        K0 = K0-1
      ELSE IF(LA_AXIS .EQ. 2) THEN
        DO 5901 I0=2,IMAX(NDIST1)
          VOXEL_MEAS = XBOUND(NDIST1,I0)
          IF ((VOXEL_MEAS.GT.XCOORD)) THEN
            GO TO5902
          END IF
5901    CONTINUE
5902    CONTINUE
        I0 = I0-1
        DO 5911 K0=2,KMAX(NDIST1)
          VOXEL_MEAS = ZBOUND(NDIST1,K0)
          IF ((VOXEL_MEAS.GT.ZCOORD)) THEN
            GO TO5912
          END IF
5911    CONTINUE
5912    CONTINUE
        K0 = K0-1
      ELSE IF(LA_AXIS .EQ. 3) THEN
        DO 5921 I0=2,IMAX(NDIST1)
          VOXEL_MEAS = XBOUND(NDIST1,I0)
          IF ((VOXEL_MEAS.GT.XCOORD)) THEN
            GO TO5922
          END IF
5921    CONTINUE
5922    CONTINUE
        I0 = I0-1
        DO 5931 J0=2,JMAX(NDIST1)
          VOXEL_MEAS = YBOUND(NDIST1,J0)
          IF ((VOXEL_MEAS.GT.YCOORD)) THEN
            GO TO5932
          END IF
5931    CONTINUE
5932    CONTINUE
        J0 = J0-1
      END IF
      WRITE(6,5940)NDIST1,FILEIN(NDIST1)(1:NUMCHAR)
5940  FORMAT(/1X,'3D-dose distribution ',I2,': ',A)
      IF (LA_AXIS .EQ. 1) THEN
        DO 5951 I0=1,IMAX(NDIST1)
          PROFILEDOSE(I0) = DOSE(NDIST1,I0,J0,K0)
          PROFILERR(I0) = ERRDOSE(NDIST1,I0,J0,K0)
5951    CONTINUE
5952    CONTINUE
        NPOINTS = IMAX(NDIST1)
        IF ((REPLY.EQ.'y')) THEN
          DO 5961 I0=1,IMAX(NDIST1)
            X(I0)=((XBOUND(NDIST1,I0)+ XBOUND(NDIST1,I0+1))/2)+(.05*(NCU
     *      RVE-1)* (XBOUND(NDIST1,I0+1)-XBOUND(NDIST1,I0)))
            Y(I0)=PROFILEDOSE(I0)
            ERRY(I0)=PROFILERR(I0)
5961      CONTINUE
5962      CONTINUE
        ELSE
          DO 5971 I0=1,IMAX(NDIST1)
            X(I0)=((XBOUND(NDIST1,I0)+ XBOUND(NDIST1,I0+1))/2)
            Y(I0)=PROFILEDOSE(I0)
            ERRY(I0)=PROFILERR(I0)
5971      CONTINUE
5972      CONTINUE
        END IF
        CALL LETTERCOUNT(FILEIN(NDIST1),J)
        CURVE_LABELS='                    '
        CURVE_LABELS=FILEIN(NDIST1)(1:J)
        NTYPE_SYMBOL = MOD(NCURVE,9)+1
        NTYPE_CURVE = MOD(NCURVE,5)+1
        CURVE_SPECS = CHAR(NTYPE_SYMBOL+48)//CHAR(NTYPE_CURVE+48)
      ELSE IF(LA_AXIS .EQ. 2) THEN
        DO 5981 J0=1,JMAX(NDIST1)
          PROFILEDOSE(J0) = DOSE(NDIST1,I0,J0,K0)
          PROFILERR(J0) = ERRDOSE(NDIST1,I0,J0,K0)
5981    CONTINUE
5982    CONTINUE
        NPOINTS = JMAX(NDIST1)
        IF ((REPLY.EQ.'y')) THEN
          DO 5991 J0=1,JMAX(NDIST1)
            X(J0)=((YBOUND(NDIST1,J0)+ YBOUND(NDIST1,J0+1))/2)+(.05*(NCU
     *      RVE-1)* (YBOUND(NDIST1,J0+1)-YBOUND(NDIST1,J0)))
            Y(J0)=PROFILEDOSE(J0)
            ERRY(J0)=PROFILERR(J0)
5991      CONTINUE
5992      CONTINUE
        ELSE
          DO 6001 J0=1,JMAX(NDIST1)
            X(J0)=((YBOUND(NDIST1,J0)+ YBOUND(NDIST1,J0+1))/2)
            Y(J0)=PROFILEDOSE(J0)
            ERRY(J0)=PROFILERR(J0)
6001      CONTINUE
6002      CONTINUE
        END IF
        CALL LETTERCOUNT(FILEIN(NDIST1),J)
        CURVE_LABELS='                    '
        CURVE_LABELS=FILEIN(NDIST1)(1:J)
        NTYPE_SYMBOL = MOD(NCURVE,9)+1
        NTYPE_CURVE = MOD(NCURVE,5)+1
        CURVE_SPECS = CHAR(NTYPE_SYMBOL+48)//CHAR(NTYPE_CURVE+48)
      ELSE IF(LA_AXIS .EQ. 3) THEN
        DO 6011 K0=1,KMAX(NDIST1)
          PROFILEDOSE(K0) = DOSE(NDIST1,I0,J0,K0)
          PROFILERR(K0) = ERRDOSE(NDIST1,I0,J0,K0)
6011    CONTINUE
6012    CONTINUE
        NPOINTS = KMAX(NDIST1)
        IF ((REPLY.EQ.'y')) THEN
          DO 6021 K0=1,KMAX(NDIST1)
            X(K0)=((ZBOUND(NDIST1,K0)+ ZBOUND(NDIST1,K0+1))/2)+(.05*(NCU
     *      RVE-1)* (ZBOUND(NDIST1,K0+1)-ZBOUND(NDIST1,K0)))
            Y(K0)=PROFILEDOSE(K0)
            ERRY(K0)=PROFILERR(K0)
6021      CONTINUE
6022      CONTINUE
        ELSE
          DO 6031 K0=1,KMAX(NDIST1)
            X(K0)=((ZBOUND(NDIST1,K0)+ ZBOUND(NDIST1,K0+1))/2)
            Y(K0)=PROFILEDOSE(K0)
            ERRY(K0)=PROFILERR(K0)
6031      CONTINUE
6032      CONTINUE
        END IF
        CALL LETTERCOUNT(FILEIN(NDIST1),J)
        CURVE_LABELS='                    '
        CURVE_LABELS=FILEIN(NDIST1)(1:J)
        NTYPE_SYMBOL = MOD(NCURVE,9)+1
        NTYPE_CURVE = MOD(NCURVE,5)+1
        CURVE_SPECS = CHAR(NTYPE_SYMBOL+48)//CHAR(NTYPE_CURVE+48)
      ELSE
        WRITE(6,6040)
6040    FORMAT(1X,'ERROR, ILLEGAL DATA FOR AXIS')
      END IF
      SUBTITLE=' '
      XMIN=0.
      CALL XVGRPLOT(X,Y,ERRY,NPOINTS,NCURVE-1,CURVE_LABELS, XAXIS,YAXIS,
     *TITLE,SUBTITLE,7,IOPTION(1),XMIN,IOPTION(2))
      IF ((NCURVE.EQ.10)) THEN
        GOTO 5860
      ELSE
        GOTO 5790
      END IF
5860  WRITE(6,6050)
6050  FORMAT(/1X,'CALLING XMGR...PLEASE BE PATIENT! ')
      CLOSE(7)
      CALL XVGR_SCRIPT
      GOTO 5500
      END
      SUBROUTINE SAVE
      COMMON/DATA1/N,NDIST1_FLAG,NFLAG,NUMCHAR,REPLY
      INTEGER N,NDIST1_FLAG(15),NFLAG,NUMCHAR
      CHARACTER*1 REPLY
      COMMON/DATA2/I,J,K,L,M,I0,J0,K0,IMAX,JMAX,KMAX, ICOUNT,INTX,INTY,I
     *NTZ,ISTR,JSTR,LA_AXIS,LTOT, MAX_CURVE,NCURVE,NDIST1,NDIST2,NUM_ARR
     *,NPOINTS,IOPTION,NTYPE_SYMBOL, NTYPE_CURVE,AXISDOSE,DDBIN_CHI,DDBI
     *N_DIFF,DOSE,ERRDOSE,ERRY, FREQ_CHI,FREQ_DIFF,PROFILEDOSE,PROFILERR
     *,TOTALNORM, XCOORD,YCOORD,ZCOORD, XBOUND,YBOUND,ZBOUND,X,Y,VOXEL_M
     *EAS, CURVE_LABELS,CURVE_SPECS,FILEIN,THE_STRING,TITLE,XAXIS,YAXIS,
     * OUTFILE
      INTEGER I,J,K,L,M
      INTEGER I0, J0, K0
      INTEGER IMAX(15),JMAX(15),KMAX(15)
      INTEGER ICOUNT
      INTEGER INTX,INTY,INTZ
      INTEGER ISTR,JSTR
      INTEGER LA_AXIS
      INTEGER LTOT
      INTEGER MAX_CURVE, NCURVE
      INTEGER NDIST1,NDIST2
      INTEGER NUM_ARR(10)
      INTEGER NPOINTS,IOPTION(4)
      INTEGER NTYPE_SYMBOL,NTYPE_CURVE
      REAL AXISDOSE(15,128)
      REAL DDBIN_CHI
      REAL DDBIN_DIFF
      REAL DOSE(15,128,128,128)
      REAL ERRDOSE(15,128,128,128)
      REAL ERRY(400)
      REAL FREQ_CHI(400)
      REAL FREQ_DIFF(400)
      REAL PROFILEDOSE(128+1),PROFILERR(128+1)
      REAL TOTALNORM(15)
      REAL XCOORD, YCOORD, ZCOORD
      REAL XBOUND(15,128+1),YBOUND(15,128+1), ZBOUND(15,128+1)
      REAL X(400),Y(400)
      REAL VOXEL_MEAS
      CHARACTER*60 CURVE_LABELS
      CHARACTER*2 CURVE_SPECS
      CHARACTER*70 FILEIN(15)
      CHARACTER*(10) THE_STRING
      CHARACTER*60 TITLE,XAXIS,YAXIS,OUTFILE,SUBTITLE
      CHARACTER*70 TEMPNAME
      LOGICAL THERE
      SAVE
6060  WRITE(6,6070)
6070  FORMAT(/1X,'SAVE FILES')
      WRITE(6,6080)
6080  FORMAT(1X,'----------')
2660  WRITE(6,6090)
6090  FORMAT(1X,'Files currently loaded:'/)
      DO 6101 N=1,15
        IF (NDIST1_FLAG(N) .EQ. 1) THEN
          WRITE(6,6110)N,FILEIN(N)
6110      FORMAT(I2,' - ',A)
        END IF
6101  CONTINUE
6102  CONTINUE
      WRITE(6,6120)
6120  FORMAT(/1X,'Number of file to Save (0-MainMenu): ',$)
      READ(5,6130)NDIST1
6130  FORMAT(I2)
      IF (NDIST1.EQ.0) THEN
        RETURN
      ELSE IF(NDIST1.GT.15) THEN
        WRITE(6,6140)
6140    FORMAT(1X,'SORRY, THAT IS OUT OF RANGE.'/)
        GOTO 2660
      END IF
      TEMPNAME = FILEIN(NDIST1)
      CALL LETTERCOUNT(FILEIN(NDIST1),NUMCHAR)
      WRITE(6,6150)FILEIN(NDIST1)(1:NUMCHAR)
6150  FORMAT(1X,'Name of saved file (default=',A,'): ',$)
      READ(5,6160)FILEIN(NDIST1)
6160  FORMAT(A)
      IF (FILEIN(NDIST1) .EQ. ' ') THEN
        FILEIN(NDIST1) = TEMPNAME
      END IF
      CALL LETTERCOUNT(FILEIN(NDIST1),NUMCHAR)
      INQUIRE (FILE = FILEIN(NDIST1)(1:NUMCHAR)//'.3ddose',EXIST=THERE)
      IF (THERE) THEN
        OPEN(UNIT=4,FILE=FILEIN(NDIST1)(1:NUMCHAR)// '.3ddose',STATUS='O
     *LD')
      ELSE
        OPEN(UNIT=4,FILE=FILEIN(NDIST1)(1:NUMCHAR)// '.3ddose',STATUS='N
     *EW')
      END IF
      WRITE(4,*) IMAX(NDIST1),JMAX(NDIST1),KMAX(NDIST1)
      DO 6171 I=1,(IMAX(NDIST1)+1)
        WRITE(4,*) XBOUND(NDIST1,I)
6171  CONTINUE
6172  CONTINUE
      DO 6181 I=1,(JMAX(NDIST1)+1)
        WRITE(4,*) YBOUND(NDIST1,I)
6181  CONTINUE
6182  CONTINUE
      DO 6191 I=1,(KMAX(NDIST1)+1)
        WRITE(4,*) ZBOUND(NDIST1,I)
6191  CONTINUE
6192  CONTINUE
      WRITE(6,6200)
6200  FORMAT(1X,'WRITING DOSE DISTRIBUTION...')
      WRITE(4,*) (((DOSE(NDIST1,I,J,K),I=1,IMAX(NDIST1)),J=1,JMAX(NDIST1
     *)),K=1,KMAX(NDIST1))
      WRITE(6,6210)
6210  FORMAT(1X,'WRITING ERROR IN DOSE DISTRIBUTION...')
      DO 6221 I=1,IMAX(NDIST1)
        DO 6231 J=1,JMAX(NDIST1)
          DO 6241 K=1,KMAX(NDIST1)
            ERRDOSE(NDIST1,I,J,K) = ERRDOSE(NDIST1,I,J,K)/DOSE(NDIST1,I,
     *      J,K)
6241      CONTINUE
6242      CONTINUE
6231    CONTINUE
6232    CONTINUE
6221  CONTINUE
6222  CONTINUE
      WRITE(4,*) (((ERRDOSE(NDIST1,I,J,K),I=1,IMAX(NDIST1)),J=1,JMAX(NDI
     *ST1)),K=1,KMAX(NDIST1))
      DO 6251 I=1,IMAX(NDIST1)
        DO 6261 J=1,JMAX(NDIST1)
          DO 6271 K=1,KMAX(NDIST1)
            ERRDOSE(NDIST1,I,J,K) = DOSE(NDIST1,I,J,K)*ERRDOSE(NDIST1,I,
     *      J,K)
6271      CONTINUE
6272      CONTINUE
6261    CONTINUE
6262    CONTINUE
6251  CONTINUE
6252  CONTINUE
      CLOSE(UNIT=4)
      GOTO 6060
      END
      SUBROUTINE LETTERCOUNT(STRING,J)
      CHARACTER*70 STRING
      INTEGER I, J
      LOGICAL FLAG
      SAVE
      J = 0
      DO 6281 I=1,69
        FLAG = STRING(I:I+1).NE.' '
        IF (FLAG) THEN
          J = J+1
        END IF
6281  CONTINUE
6282  CONTINUE
      FLAG = STRING(70:70).NE.' '
      IF (FLAG) THEN
        J = J+1
      END IF
      RETURN
      END
      SUBROUTINE XVGR_SCRIPT
      IMPLICIT NONE
      COMMON/DATA2/I,J,K,L,M,I0,J0,K0,IMAX,JMAX,KMAX, ICOUNT,INTX,INTY,I
     *NTZ,ISTR,JSTR,LA_AXIS,LTOT, MAX_CURVE,NCURVE,NDIST1,NDIST2,NUM_ARR
     *,NPOINTS,IOPTION,NTYPE_SYMBOL, NTYPE_CURVE,AXISDOSE,DDBIN_CHI,DDBI
     *N_DIFF,DOSE,ERRDOSE,ERRY, FREQ_CHI,FREQ_DIFF,PROFILEDOSE,PROFILERR
     *,TOTALNORM, XCOORD,YCOORD,ZCOORD, XBOUND,YBOUND,ZBOUND,X,Y,VOXEL_M
     *EAS, CURVE_LABELS,CURVE_SPECS,FILEIN,THE_STRING,TITLE,XAXIS,YAXIS,
     * OUTFILE
      INTEGER I,J,K,L,M
      INTEGER I0, J0, K0
      INTEGER IMAX(15),JMAX(15),KMAX(15)
      INTEGER ICOUNT
      INTEGER INTX,INTY,INTZ
      INTEGER ISTR,JSTR
      INTEGER LA_AXIS
      INTEGER LTOT
      INTEGER MAX_CURVE, NCURVE
      INTEGER NDIST1,NDIST2
      INTEGER NUM_ARR(10)
      INTEGER NPOINTS,IOPTION(4)
      INTEGER NTYPE_SYMBOL,NTYPE_CURVE
      REAL AXISDOSE(15,128)
      REAL DDBIN_CHI
      REAL DDBIN_DIFF
      REAL DOSE(15,128,128,128)
      REAL ERRDOSE(15,128,128,128)
      REAL ERRY(400)
      REAL FREQ_CHI(400)
      REAL FREQ_DIFF(400)
      REAL PROFILEDOSE(128+1),PROFILERR(128+1)
      REAL TOTALNORM(15)
      REAL XCOORD, YCOORD, ZCOORD
      REAL XBOUND(15,128+1),YBOUND(15,128+1), ZBOUND(15,128+1)
      REAL X(400),Y(400)
      REAL VOXEL_MEAS
      CHARACTER*60 CURVE_LABELS
      CHARACTER*2 CURVE_SPECS
      CHARACTER*70 FILEIN(15)
      CHARACTER*(10) THE_STRING
      CHARACTER*60 TITLE,XAXIS,YAXIS,OUTFILE,SUBTITLE
      CHARACTER*100 SCRIPT(4)
      INTEGER istat, egs_system
      OPEN(4,FILE='xmgr_script',FORM='FORMATTED',STATUS='UNKNOWN')
      SCRIPT(3)(1:8)='xmgrace '
      SCRIPT(3)(9:100) = outfile
      SCRIPT(1)='#!/bin/sh'
      SCRIPT(2)='#xmgr_script'
      SCRIPT(4)='exit'
      WRITE (4,*)SCRIPT(1)(1:60)
      WRITE (4,*)SCRIPT(2)(1:60)
      WRITE (4,*)SCRIPT(3)(1:)
      WRITE (4,*)SCRIPT(4)(1:60)
      CLOSE(4)
      istat=egs_system('sh xmgr_script &')
      IF ((istat.NE.0)) THEN
        WRITE(6,6290)
6290    FORMAT(//' xmgr/xmgrace is not available on this machine.'/ ' Wi
     *ll not be called.'//)
      END IF
      RETURN
      END
C***************************************************************************
C
C   This file was automatically generated by:
C   EGSnrc-configure-linux version 1.0
C   It contains various subroutines and functions for date, time,
C   CPU time, host name, etc.
C
C   Attention: all changes will be lost the next time you run
C   EGSnrc-configure-linux.
C
C***************************************************************************

C##############################################################################
C
C  EGSnrc egs_system subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C egs_system(command)  runs a system command and returns the status
C                      command must be null-terminated
C*****************************************************************************
      integer function egs_system(command)
      character*(*) command
      integer system, istat
      istat = system(command)
      egs_system = istat
      return
      end

C##############################################################################
C
C  EGSnrc egs_isdir subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C  egs_isdir(file_name)  Returns .true., if the string file_name points to
C                        an existing directory. This version uses the lstat
C                        intrinsic and then tests for bit 14 being set in
C                        the mode element. This works on all Unix systems
C                        that I have access to (Linux, Aix, HP-UX, OSF1,
C                        Solaris, IRIX)
C
C*****************************************************************************

      logical function egs_isdir(file_name)
      implicit none
      character*(*) file_name
      integer*4 lnblnk1, res, array(13), l, lstat
      logical btest
      egs_isdir = .false.
      l = lnblnk1(file_name)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = char(0)
         ! On some systems lstat only works if the string is 0-terminated
      res = lstat(file_name,array)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = ' '
      if( res.eq.0 ) then
            ! Amost all compilers that have the lstat intrinsic return the
            ! file mode in the 3rd array element. But the PGI compiler has
            ! its own opinion on the subject and returns it in the 5th element
            ! That's why the relevant element is written as 3
            ! here, 3 gets replaced by the appropriate element
            ! by the configure script.
          if( btest(array(3),14) ) egs_isdir = .true.
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C***************************************************************************
C
C   egs_fdate(out):  print a 24 char date and time string in the form
C                         'Tue Mar 18 08:16:42 2003'
C                    to the unit specified by out without end of line
C                    i.e. the sequence
C                    write(6,'(a,$)') 'Today is '
C                    call egs_fdate(6)
C                    write(6,'(a)') '. Have a nice date'
C                    should result in something like
C                    Today is Tue Mar 18 08:16:42 2003. Have a nice date
C                    printed to unit 6.
C
C***************************************************************************

      subroutine egs_fdate(ounit)
      integer ounit
      character*24 string
      call fdate(string)
      write(ounit,'(a,$)') string
      end

C***************************************************************************
C
C   egs_get_fdate(string) assignes a 24 char date and time string to string
C                         string must be at least 24 chars long, otherwise
C                         this subroutine has no effect.
C
C***************************************************************************

      subroutine egs_get_fdate(string)
      character*(*) string
      if( len(string).ge.24 ) call fdate(string)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date_and_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


      subroutine egs_date_and_time(vnow)
      integer vnow(8)
      character dat*8,tim*10,zon*5
      call date_and_time(dat,tim,zon,vnow)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*************************************************************************
C
C egs_date(ounit): print a 11 char string in the form
C                     '18-Mar-2003'
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_date(ounit)
      integer ounit
      character string*24, dat*11
      call fdate(string)
      dat(1:2) = string(9:10)
      dat(3:3) = '-'
      dat(4:6) = string(5:7)
      dat(7:7) = '-'
      dat(8:11) = string(21:24)
      write(ounit,'(a,$)') dat
      return
      end

C##############################################################################
C
C  EGSnrc egs_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C $Id: egs_time_v1.f,v 1.1 2003/07/11 19:17:08 iwan Exp $
C*************************************************************************
C
C egs_time(ounit): print a 8 char string in the form hh:mm:ss
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_time(ounit)
      integer ounit
      character string*24
      call fdate(string)
      write(ounit,'(a,$)') string(12:19)
      return
      end

C##############################################################################
C
C  EGSnrc seconds timing subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_secnds(t0): returns seconds passed since midnight minus t0
C
C*****************************************************************************

      real function egs_secnds(t0)
      real t0,t1
      character dat*8,tim*10,zon*5
      integer values(8)
      call date_and_time(dat,tim,zon,values)
      t1 = 3600.*values(5) + 60.*values(6) + values(7) + 0.001*values(8)
      egs_secnds = t1 - t0
      return
      end

C*****************************************************************************
C
C real function egs_tot_time()
C
C   On first call returns seconds passed since 1/1/1970
C   On subsequent calls returns
C     - seconds since last call, if flag = 0
C     - seconds since first call, else
C
C*****************************************************************************

      real function egs_tot_time(flag)
      integer flag
      character dat*8,tim*10,zon*5
      integer vnow(8), vlast(8),i
      real t,egs_time_diff,t0
      data vlast/1970,1,1,5*0/,t0/-1/
      save vlast,t0
      call date_and_time(dat,tim,zon,vnow)
      t = egs_time_diff(vlast,vnow)
      do i=1,8
        vlast(i)=vnow(i)
      end do
      if( t0.lt.0 ) then
        t0 = 0
        egs_tot_time = t
      else
        t0 = t0 + t
        if(flag.eq.0) then
          egs_tot_time = t
        else
          egs_tot_time = t0
        end if
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date and time subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C****************************************************************************
C
C Returns the time difference between vstart and vend
C vstart and vend are integer arrays of dimension 8 with elements
C corresponding to the specification of the data_and_time routine, i.e.
C   array(1) = year
C   array(2) = month of the year   (1...12)
C   array(3) = day of the month    (1...31)
C   array(4) = difference in minutes from UTC
C   array(5) = hour of the day     (1...23)
C   array(6) = minute of the hour  (1...59)
C   array(7) = seconds of the minute (1...59)
C   array(8) = miliseconds of the second (1...999)
C
C Note: this implementation ignores the time difference from UTC field
C
C*****************************************************************************
      real function egs_time_diff(vstart,vend)
      integer    vstart(8),vend(8)
      real       egs_time_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_time_diff = -egs_time_diff_o(vend,vstart)
      else
        egs_time_diff = egs_time_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C day difference between the dates specified by the integer arrays vstart and
C vend. The arrays are v(1)=year, v(2)=month, v(3)=day
C
C******************************************************************************
      integer function egs_day_diff(vstart,vend)
      integer vstart(3),vend(3),egs_day_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_day_diff = -egs_day_diff_o(vend,vstart)
      else
        egs_day_diff = egs_day_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C Returns a 3-letter abreviation of the day of the week in the string day,
C given a day specified by the integer array values
C   values(1)=year, values(2)=month, values(3)=day
C
C******************************************************************************
      subroutine egs_weekday(values,day)
      character*(*) day
      integer       values(3)
      integer       days,vtmp(3),egs_day_diff,aux
      character*3   wdays(7)
      data wdays/'Mon','Tue','Wed','Thu','Fri','Sat','Sun'/
      vtmp(1) = 1970
      vtmp(2) = 1
      vtmp(3) = 1
      days = egs_day_diff(vtmp,values)
      aux = mod(days,7)
      days = 4 + aux
      if( days.gt.7 ) days = days - 7
      day(:len(day)) = ' '
      aux = min(len(day),3)
      day(:aux) = wdays(days)(:aux)
      return
      end

C*****************************************************************************
C
C Same as egs_day_diff above, but assumes that vend specifies a later date
C than vstart.
C
C*****************************************************************************
      integer function egs_day_diff_o(vstart,vend)
      integer vstart(3),vend(3)
      integer    days
      logical    next_month
      integer    tm,m,ty,y
      integer    mdays(12)
      data       mdays/31,28,31,30,31,30,31,31,30,31,30,31/
      days = 0
      ty = vstart(1)
      y  = vend(1)
      tm = vstart(2)
      m  = vend(2)
      next_month = .true.
      do while(next_month)
        if( tm.eq.m.and.ty.eq.y ) then
          next_month = .false.
        else
          days = days + mdays(tm)
          if( tm.eq.2.and.mod(ty,4).eq.0 ) days = days + 1
          tm = tm + 1
          if( tm.gt.12 ) then
            ty = ty + 1
            tm = 1
          end if
        end if
      end do
      days = days + vend(3) - vstart(3)
      egs_day_diff_o = days
      return
      end

C******************************************************************************
C
C Same as egs_time_diff above, but assumes that vend specifies a later date
C than vstart.
C
C******************************************************************************
      real function egs_time_diff_o(vstart,vend)
      integer    vstart(8),vend(8)
      integer    days,hours,minutes,secs,msecs
      integer    egs_day_diff_o
      days = egs_day_diff_o(vstart,vend)
      hours = vend(5) - vstart(5)
      minutes = vend(6) - vstart(6)
      secs = vend(7) - vstart(7)
      msecs = vend(8) - vstart(8)
      egs_time_diff_o = 3600.*(24.*days+hours)+60.*minutes+secs+
     &                  0.001*msecs
      return
      end

C******************************************************************************
C
C Returns in month a 3-letter abreviation of the month specified by mo, if
C mo is between 1 and 12, or an empty string otherwise.
C
C******************************************************************************
      subroutine egs_month(mo,month)
      integer mo
      character*(*) month
      integer iaux
      character*3   months(12)
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      iaux = min(len(month),3)
      month(:len(month)) = ' '
      if( mo.ge.1.and.mo.le.12 ) month(:iaux) = months(mo)(:iaux)
      return
      end

C******************************************************************************
C
C Converts a 3-letter abreviation of a month to its corresponding integer
C value, if the string month is a valid month, or -1 otherwise.
C
C******************************************************************************
      integer function egs_conver_month(month)
      character*3 month
      character*3 months(12)
      integer i
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      do i=1,12
        if( month.eq.months(i) ) then
          egs_conver_month = i
          return
        end if
      end do
      egs_conver_month = -1
      return
      end


C##############################################################################
C
C  EGSnrc egs_etime subroutine
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_etime(): returns CPU time consumed since the start of
C                            the program
C
C*****************************************************************************

      real function egs_etime()
      real tarray(2),etime
      egs_etime = etime(tarray)
      return
      end

C##############################################################################
C
C  EGSnrc canonical system name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the canonical system name as determined by the config.guess script
C or the Windows installation program to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_canonical_system(ounit)
      integer ounit
      write(6,'(a,$)') 'linux64'
      return
      end

C******************************************************************************
C
C Assign the canonical system name as determined by the config.guess script
C or the Windows installation program to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_canonical_system(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('linux64')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'linux64'
      else
        res(:l2) = 'linux64'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc configuration name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the configuration name as specified suring the configuration
C process to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_configuration_name(ounit)
      integer ounit
      write(6,'(a,$)') 'linux'
      return
      end

C******************************************************************************
C
C Assign the configuration name as specified suring the configuration
C process to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_configuration_name(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('linux')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'linux'
      else
        res(:l2) = 'linux'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc hostname subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C Print the host name to the unit specified by ounit without inserting
C a new line character.
C
C*****************************************************************************

      subroutine egs_print_hostnm(ounit)
      integer ounit
      character*256 string
      integer res,hostnm,lnblnk1
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      write(ounit,'(a,$)') string(:lnblnk1(string))
      return
      end

C*****************************************************************************
C
C Assign the host name to the string pointed to be hname.
C
C*****************************************************************************

      subroutine egs_get_hostnm(hname)
      character*(*) hname
      character*256 string
      integer res,hostnm,lnblnk1,l1,l2,l
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      l1 = lnblnk1(string)
      l2 = len(hname)
      hname(:l2) = ' '
      l = min(l1,l2)
      hname(:l) = string(:l)
      return
      end

      SUBROUTINE XVGRPLOT (X, Y, ERRY, NPTS, CURVENUM, SERIESTITLE, XTIT
     *LE, YTITLE, GRAPHTITLE, SUBTITLE, UNITNUM, TYPE, HISTXMIN, AXISTYP
     *E)
      IMPLICIT NONE
      integer*4 MAX, IDEBUG
      PARAMETER (MAX = 400)
      integer*4 NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE
      real*4 X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,HISTXMIN,ERRYOLD,SMALLESTX,
     * SMALLESTY,FUDGE
      integer*4 TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENG
     *TH
      integer*4 LOGX, LOGY, LOGDY,ZEROYCOUNT
      CHARACTER*(*) SUBTITLE
      CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE
      CHARACTER*10 INDEX
      CHARACTER*3 INDEXNUM
      logical TESTFILE, ALLPOS
      real*4 one
      parameter (one = 1)
      FUDGE = 1.e-10
      IDEBUG = 0
      IF ((IDEBUG .EQ. 1)) THEN
        write(6,'(//'' Entering xvgrplot ''/)')
        write(6,'('' Curve'',I3,'' to go to unit'',I3)')CURVENUM,UNITNUM
        write(6,'(''SERIESTITLE: '',a60)') SERIESTITLE
        write(6,'(''XTITLE:      '',a60)') XTITLE
        write(6,'(''YTITLE       '',a60)') YTITLE
        write(6,'(''GRAPHTILE:   '',a60)') graphtitle
        write(6,'(''SUBTITLE:    '',a80)') subtitle
      END IF
      IF (( NPTS .gt. MAX)) THEN
        WRITE(6,6300)NPTS, MAX
6300    FORMAT(//' **************************'/ ' Number of points asked
     * for =', I5, ' is greater than max allowed of', I4/ ' Setting NPTS
     * to MAX, you could adjust MAX in xvgrplot.mortran'/ ' ************
     ***************'//)
        NPTS1 = MAX
      ELSE
        NPTS1 = NPTS
      END IF
      INQUIRE(UNIT = UNITNUM,OPENED=TESTFILE)
      IF ((.NOT.TESTFILE)) THEN
        WRITE(6,6310) UNITNUM
6310    FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------' ,/'
     *   Unit specified (',I2,') is not open.' ,/'   Unit must be opened
     * before using subroutine.' ,/'   Data not written to file.' ,/'  -
     *---------------------------------------------'//)
        RETURN
      END IF
      IF ((GRAPHTITLE .EQ. ' ')) THEN
        GRAPHTITLE = 'Untitled Graph - No title specified in subroutine'
      END IF
      IF ((XTITLE .EQ. ' ')) THEN
        XTITLE = 'X-axis not titled in subroutine'
      END IF
      IF ((YTITLE .EQ. ' ')) THEN
        YTITLE = 'Y-axis not titled in subroutine'
      END IF
      IF ((SERIESTITLE .EQ. ' ')) THEN
        SERIESTITLE = 'series # '
        INDEX = '0123456789'
        INDEXNUM = INDEX(CURVENUM+1:CURVENUM+1)
        SERIESTITLE(9:9) = INDEXNUM
      END IF
      TITLELENGTH = 61
      SUBLENGTH = 61
      XAXISLENGTH = 61
      YAXISLENGTH = 61
      SERIESLENGTH = 61
6321  CONTINUE
        TITLELENGTH = TITLELENGTH - 1
        IF(((GRAPHTITLE(TITLELENGTH:TITLELENGTH) .NE. ' ')))GO TO6322
      GO TO 6321
6322  CONTINUE
6331  CONTINUE
        SUBLENGTH = SUBLENGTH - 1
        IF(((SUBTITLE(SUBLENGTH:SUBLENGTH) .NE. ' ')))GO TO6332
      GO TO 6331
6332  CONTINUE
6341  CONTINUE
        XAXISLENGTH = XAXISLENGTH - 1
        IF(((XTITLE(XAXISLENGTH:XAXISLENGTH) .NE. ' ')))GO TO6342
      GO TO 6341
6342  CONTINUE
6351  CONTINUE
        YAXISLENGTH = YAXISLENGTH - 1
        IF(((YTITLE(YAXISLENGTH:YAXISLENGTH) .NE. ' ')))GO TO6352
      GO TO 6351
6352  CONTINUE
6361  CONTINUE
        SERIESLENGTH = SERIESLENGTH - 1
        IF(((SERIESTITLE(SERIESLENGTH:SERIESLENGTH) .NE. ' ')))GO TO6362
      GO TO 6361
6362  CONTINUE
      IF (( IDEBUG .EQ. 1)) THEN
        WRITE(6,6370)SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITL
     *  ELENGTH
6370    FORMAT(' SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELEN
     *GTH'/ 5I10)
      END IF
      LOGX = 0
      LOGY = 0
      LOGDY = 0
      ZEROYCOUNT=0
      ALLPOS=.TRUE.
      IF (( X(1).EQ.0.0 )) THEN
        SMALLESTX = 0.1
      ELSE
        SMALLESTX=X(1)
      END IF
      IF (( Y(1).EQ.0.0 )) THEN
        SMALLESTY = 0.1
      ELSE
        SMALLESTY=Y(1)
      END IF
      DO 6381 COUNT=1,NPTS1
        IF (((X(COUNT) .LT. SMALLESTX) .AND. (X(COUNT).NE.0.))) THEN
          SMALLESTX=X(COUNT)
        END IF
        IF (((Y(COUNT) .LT. SMALLESTY) .AND. (Y(COUNT).NE.0.))) THEN
          SMALLESTY=Y(COUNT)
        END IF
        IF (((X(COUNT) .LT. 0.).OR.(Y(COUNT) .LT. 0.))) THEN
          ALLPOS=.FALSE.
        END IF
6381  CONTINUE
6382  CONTINUE
      IF ((ALLPOS)) THEN
        DO 6391 COUNT=1,NPTS1
          IF ((X(COUNT).EQ.0.)) THEN
            X(COUNT)=SMALLESTX*FUDGE
          END IF
          IF ((Y(COUNT).EQ.0.)) THEN
            Y(COUNT)=SMALLESTY*FUDGE
          END IF
6391    CONTINUE
6392    CONTINUE
      END IF
      IF ((AXISTYPE .GT. 0)) THEN
        DO 6401 COUNT=1,NPTS1
          IF ((X(COUNT) .LE. 0.)) THEN
            LOGX = 1
          END IF
          IF ((Y(COUNT) .LE. 0.)) THEN
            LOGY = 1
          END IF
          IF (((Y(COUNT)-ERRY(COUNT)) .LE. 0.)) THEN
            LOGDY = 1
          END IF
6401    CONTINUE
6402    CONTINUE
      ELSE
        DO 6411 COUNT=1,NPTS1
          IF ((Y(COUNT)-ERRY(COUNT) .LT. Y(COUNT)-0.9999*Y(COUNT) .AND.
     *    Y(COUNT).GT.0.)) THEN
            ZEROYCOUNT=ZEROYCOUNT+1
            IF ((ZEROYCOUNT.EQ.1)) THEN
              WRITE(6,6420)
6420          FORMAT (/' ------------WARNING from Subroutine XVGRPLOT---
     *--------' ,/'  Some errors give 0 value and so are adjusted so   '
     * ,/'  that you can switch to a log Y scale while in xmgr.   ',/' -
     *------------------------------------------------------'/)
            END IF
            ERRYOLD=ERRY(COUNT)
            ERRY(COUNT) = 0.9999*Y(COUNT)
          END IF
6411    CONTINUE
6412    CONTINUE
      END IF
      IF ((CURVENUM .EQ. 0)) THEN
        IF ((AXISTYPE .EQ. 0)) THEN
          WRITE(UNITNUM,6430) 'xy'
        ELSE IF((AXISTYPE .EQ. 1)) THEN
          WRITE(UNITNUM,6430) 'logy'
          WRITE(UNITNUM,6440)
        ELSE IF((AXISTYPE .EQ. 2)) THEN
          WRITE(UNITNUM,6430) 'logx'
          WRITE(UNITNUM,6440)
        ELSE IF((AXISTYPE .EQ. 3)) THEN
          WRITE(UNITNUM,6430) 'logxy'
          WRITE(UNITNUM,6440)
          WRITE(UNITNUM,6450)
        ELSE
          WRITE(6,6460) AXISTYPE
6460      FORMAT (//'  ------------Error in Subroutine XVGRPLOT---------
     *--' ,/'   AXISTYPE specified (',I2,') is not a valid option.' ,/' 
     *----------------------------------------------'//)
          RETURN
        END IF
6430    FORMAT ('@g0 type ',A,' ')
6440    FORMAT ('@    xaxis  ticklabel format exponential')
6450    FORMAT ('@    yaxis  ticklabel format exponential')
        WRITE(UNITNUM,6470) GRAPHTITLE(1:TITLELENGTH) ,SUBTITLE(1:SUBLEN
     *  GTH) ,XTITLE(1:XAXISLENGTH) ,YTITLE(1:YAXISLENGTH)
6470    FORMAT ('@    title "',A,'"'/ ,'@    subtitle "',A,'"'/ ,'@    l
     *egend on'/ ,'@    legend box linestyle 0'/ ,'@    legend x1 0.6'/,
     *'@    legend y1 0.75'/ ,'@    view xmin 0.250000'/ ,'@    xaxis  l
     *abel "',A,'"'/ ,'@    timestamp on'/ ,'@    yaxis  label "',A,'"')
      END IF
      IF ((AXISTYPE .EQ. 1 .AND. LOGY .EQ. 1)) THEN
        WRITE(UNITNUM,6430) 'xy'
        WRITE(6,6480)
6480    FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------',
     */'  Log scale requested for Y axis when one or more   ' ,/'  Ydata
     * points are 0 or negative.                  ' ,//'  Y axis scale c
     *hanged to linear.                   ' ,/' ------------------------
     *---------------------------'/)
      END IF
      IF ((AXISTYPE .EQ. 2 .AND. LOGX .EQ. 1)) THEN
        WRITE(UNITNUM,6430) 'xy'
        WRITE(6,6490)
6490    FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------',
     */'  Log scale requested for X axis when one or more   ' ,/'  Xdata
     * points are 0 or negative.                  ' ,//'  X axis scale c
     *hanged to linear.                   ' ,/' ------------------------
     *---------------------------'/)
      END IF
      IF ((AXISTYPE .EQ. 3 .AND. (LOGX .EQ. 1 .OR. LOGY .EQ. 1))) THEN
        IF ((LOGX .EQ. 1 .AND. LOGY .EQ. 1)) THEN
          WRITE(UNITNUM,6430) 'xy'
          WRITE(6,6500)
6500      FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------
     *' ,/'  Log scale requested for X axis and Y axis when    ' ,/'  on
     *e or more X and Y data points are 0 or negative.' ,//'  X and Y ax
     *es scales changed to linear.            ' ,/' --------------------
     *-------------------------------'/)
        ELSE IF((LOGX .EQ. 1)) THEN
          WRITE(UNITNUM,6430) 'logy'
          WRITE(6,6490)
        ELSE
          WRITE(UNITNUM,6430) 'logx'
          WRITE(6,6480)
        END IF
      END IF
      IF ((LOGDY .EQ. 1 .AND. LOGY .NE. 1 .AND. (AXISTYPE .EQ. 3 .OR. AX
     *ISTYPE .EQ. 1))) THEN
        WRITE(6,6510)
6510    FORMAT (/' ------------WARNING from Subroutine XVGRPLOT---------
     *--' ,/'  Log scale requested for Y axis, and Y value less      ' ,
     */'  error gives 0 or negative value.                      ' ,//'  
     *Error adjusted to aviod negavite values on log scale. ' ,/' ------
     *-------------------------------------------------'/)
        DO 6521 COUNT=1,NPTS1
          IF ((Y(COUNT)-ERRY(COUNT) .LT. Y(COUNT)-0.9999*Y(COUNT))) THEN
            ERRYOLD = ERRY(COUNT)
            ERRY(COUNT) = 0.9999*Y(COUNT)
            WRITE(6,6530) COUNT,ERRYOLD,ERRY(COUNT)
6530        FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, '
     * to' /'        ',1PE11.4,'.')
          END IF
6521    CONTINUE
6522    CONTINUE
        WRITE(6,6540)
6540    FORMAT (/' -----------------------------------------------------
     *--'/)
      END IF
      IF ((CURVENUM .LT. 10 )) THEN
        WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM
      ELSE
        WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM
      END IF
      WRITE(UNITNUM,6550) CURVENUM,SERIESTITLE(1:SERIESLENGTH)
6550  FORMAT ('@    legend string ',I2,' "',A,'"')
      IF ((TYPE .EQ. 0)) THEN
        DO 6561 COUNT=1,NPTS1
          IF ((ERRY(COUNT) .NE. 0)) THEN
            GOTO 6570
          END IF
6561    CONTINUE
6562    CONTINUE
        WRITE(UNITNUM,6580)
6580    FORMAT ('@TYPE xy')
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,6590) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,6600) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,6610) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,6620) CURVENUM
          WRITE(UNITNUM,6630) CURVENUM, CURVENUM+1
        END IF
6590    FORMAT ('@    s',I1,' errorbar length 0.000000')
6620    FORMAT ('@    s',I2,' errorbar length 0.000000')
6600    FORMAT ('@    s',I1,' symbol color ',I2)
6610    FORMAT ('@    s',I1,' symbol color ',I1)
6630    FORMAT ('@    s',I2,' symbol color ',I2)
        DO 6641 COUNT=1,NPTS1
          WRITE(UNITNUM,6650) X(COUNT),Y(COUNT)
6641    CONTINUE
6642    CONTINUE
6650    FORMAT (1PE15.4,1PE15.4)
        GOTO 6660
6570    CONTINUE
        WRITE(UNITNUM,6670)
6670    FORMAT ('@TYPE xydy')
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,6590) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,6600) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,6610) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,6620) CURVENUM
          WRITE(UNITNUM,6630) CURVENUM, CURVENUM+1
        END IF
        DO 6681 COUNT=1,NPTS1
          WRITE(UNITNUM,6690) X(COUNT),Y(COUNT),ERRY(COUNT)
6681    CONTINUE
6682    CONTINUE
6690    FORMAT (1PE15.4,1PE15.4,1PE15.4)
6660    CONTINUE
      ELSE
        YMIN = ABS(1.E5 * Y(1))
        DO 6701 COUNT=1,NPTS1
          IF ((ABS(Y(COUNT)) .LT. YMIN)) THEN
            YMIN = ABS(Y(COUNT))
          END IF
6701    CONTINUE
6702    CONTINUE
        YMIN = SIGN(one,Y(1)) * 1.E-5 * YMIN
        Y(NPTS1+1) = YMIN
        IF (((AXISTYPE .EQ. 2 .OR. AXISTYPE .EQ. 3) .AND. HISTXMIN .EQ.
     *  0)) THEN
          IF ((X(1) .EQ. (X(2)-X(1)))) THEN
            HISTXMIN = X(1)-0.5*(X(2)-X(1))
          ELSE
            HISTXMIN = X(1)-(X(2)-X(1))
          END IF
          WRITE(6,6710) HISTXMIN
6710      FORMAT (/' ---------WARNING from Subroutine XVGRPLOT--------',
     */'  Minimum bin for X specified as 0 with log scale  ' ,/'  on X a
     *xis.  Minimum X bin set to ',1PE10.3,'.' ,/' ---------------------
     *----------------------------'/)
        END IF
        DO 6721 COUNT=1,NPTS1
          IF ((ERRY(COUNT) .NE. 0.)) THEN
            GOTO 6730
          END IF
6721    CONTINUE
6722    CONTINUE
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,6590) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,6600) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,6610) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,6620) CURVENUM
          WRITE(UNITNUM,6630) CURVENUM, CURVENUM+1
        END IF
        WRITE(UNITNUM,6580)
        WRITE(UNITNUM,6650) HISTXMIN,YMIN
        WRITE(UNITNUM,6650) HISTXMIN,Y(1)
        DO 6741 COUNT=1,NPTS1
          WRITE(UNITNUM,6650) X(COUNT),Y(COUNT)
          WRITE(UNITNUM,6650) X(COUNT),Y(COUNT+1)
6741    CONTINUE
6742    CONTINUE
        GOTO 6750
6730    CONTINUE
        ERRY(NPTS1+1) = 0.0
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,6590) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,6600) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,6610) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,6620) CURVENUM
          WRITE(UNITNUM,6630) CURVENUM, CURVENUM+1
        END IF
        WRITE(UNITNUM,6670)
        IF ((HISTXMIN .EQ. 0.0)) THEN
          HISTXMIN = SMALLESTX*FUDGE
        END IF
        WRITE(UNITNUM,6690) HISTXMIN, YMIN, 0.
        WRITE(UNITNUM,6690) HISTXMIN, Y(1), 0.
        WRITE(UNITNUM,6690) (X(1)+HISTXMIN)/2., Y(1), ERRY(1)
        DO 6761 COUNT=1,NPTS1
          WRITE (UNITNUM,6690) X(COUNT),Y(COUNT),0.
          WRITE (UNITNUM,6690) X(COUNT),Y(COUNT+1),0.
          IF ((COUNT .LT. NPTS1)) THEN
            WRITE (UNITNUM,6690) (X(COUNT)+X(COUNT+1))/2.,Y(COUNT+1),ERR
     *      Y(COUNT+1)
          END IF
6761    CONTINUE
6762    CONTINUE
6750    CONTINUE
      END IF
      WRITE(UNITNUM,'(''&'')')
      RETURN
      END
      integer*4 function lnblnk1(string)
      character*(*) string
      DO 6771 i=len(string),1,-1
        j = ichar(string(i:i))
        IF (( j .EQ. 0 )) THEN
          lnblnk1 = i-1
          return
        END IF
        IF (( j .NE. 9 .AND. j .NE. 10 .AND. j .NE. 11 .AND. j .NE. 12 .
     *  AND. j .NE. 13 .AND. j .NE. 32 )) THEN
          lnblnk1 = i
          return
        END IF
6771  CONTINUE
6772  CONTINUE
      lnblnk1 = 0
      return
      end
