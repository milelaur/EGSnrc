#!/bin/bash
###############################################################################
#
#  EGSnrc script to run a pbsdsh task
#  Copyright (C) 2015 National Research Council Canada
#
#  This file is part of EGSnrc.
#
#  EGSnrc is free software: you can redistribute it and/or modify it under
#  the terms of the GNU Affero General Public License as published by the
#  Free Software Foundation, either version 3 of the License, or (at your
#  option) any later version.
#
#  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
#  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
#  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
#  more details.
#
#  You should have received a copy of the GNU Affero General Public License
#  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################
#
#  Author:          Frederic Tessier, 2008
#
#  Contributors:
#
###############################################################################
#
#  This script is called from 'run_user_code_batch' when using the PBS
#  distributed shell (pbsdsh). In this mode PBS simply reserves the requested
#  number of nodes and uses this script to launch each individual 'task'.
#
################################################################################


# command to run
command=$1
basename=$2
dshsleep=$3


# go to working directory
cd $PBS_O_WORKDIR


# set job index in terms of the dsh task number
job=`expr $PBS_TASKNUM - 1`


# job string
jobstr=$(printf "job %04d" $job)


# log function to write messages to the log file
function log {
    echo $(date) "["$(date +%H:%M:%S.%N)"]: $jobstr: $1"
}


# quit function if simulation is done
function quit_if_done {
    done=$(grep -o END $basename.egsjob)
    if [ "$done" = "END" ]; then
        log "QUIT (simulation already finished)"
        exit
    fi
}


# manage jobs to avoid bottleneck and race conditions
if [ $job -eq 1 ]; then

    # log host and pid of job 1 in .egsjob file
    log "host=$(hostname) pid=$$ BEGIN" > $basename.egsjob

else

    # log the host and pid of this job
    log "host=$(hostname) pid=$$"

    # all jobs wait a fixed delay (relative to first job)
    delay=1
    log "sleep $delay seconds (initial delay)"
    sleep $delay

    # wait until there is an .egsjob file (maximum 120 seconds)
    total=0
    delay=10
    limit=120
    while [ ! -e $basename.egsjob ]; do
        log "sleep $delay seconds (no $basename.egsjob file after $total seconds)"
        sleep $delay
        total=$((total+$delay))
        if [ $total -gt $limit ]; then
            log "QUIT (no $basename.egsjob file after $limit seconds)"
            exit
        fi
    done

    # sleep until there is a lock file, maximum 300 seconds
    total=0
    delay=10
    limit=300
    while [ ! -e $basename.lock ]; do

        # quit if simulation is already done
        quit_if_done

        # otherwise wait for lock file
        log "sleep $delay seconds ($basename.lock not found after $total seconds)"
        sleep $delay
        total=$((total+$delay))
        if [ $total -gt $limit ]; then
            log "QUIT ($basename.lock not found after $limit seconds)"
            exit
        fi
    done

    # offset all jobs by a fixed delay (relative to previous job)
    delay=100000
    log "sleep $((job*$delay)) microseconds (job offset)"
    for j in $(seq 1 $job); do
        usleep $delay
        quit_if_done
    done

    # extra user-specified delay between each job
    delay=$dshsleep
    if [ $delay -gt 0 ]; then
        log "sleep $((job*$dshsleep)) seconds (user-specififed offset)"
        for j in $(seq 1 $job); do
            usleep $delay
            quit_if_done
        done
    fi

    # report on lock file content
    if [ -e $basename.lock ]; then
        content=$(cat $basename.lock)
        log "found $basename.lock: $content"
    else
        log "QUIT ($basename.lock does not exist anymore)"
        exit
    fi

fi


# launch the job if simulation is not done
quit_if_done
log "RUN $command -j $job"
$command -j $job


# report that this job is done
log "DONE."


# report that the simulation (job 1) is done
if [ $job -eq 1 ]; then
    log "FINISH simulation"
    log "host=$(hostname) pid=$$ END" >> $basename.egsjob
fi
