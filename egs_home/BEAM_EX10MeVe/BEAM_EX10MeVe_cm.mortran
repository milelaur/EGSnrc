%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: stacked planes                            "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Geoff Zhang                                               "
"                   Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code originally evolved from the SLAB component module written by     "
"  Dave Rogers and Bruce Faddegon, starting in 1991, and subsequently edited  "
"  by George Ding.                                                            "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             ***********             ""toc:
"                             *         *             ""toc:
"                             *  SLABS  *             ""toc:
"                             *         *             ""toc:
"                             ***********             ""toc:
"
"   History of modifications given by sccs
"
"*******************************************************************************
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.  Multiple planes of arbitrary thickness and
"   material.
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator:  a set of 2 or more
"   slabs infinite in x & y.
"
"   This component module can be added to the simulation by including these
"   routines in the MORTRAN file BEAM_CM.MORTRAN and including the MORTRAN
"   replacement macros associated with this component module in the file
"   BEAM_COMMON.MORTRAN.  The order of the component modules in either of
"   these files is unimportant.  To explicitly include this component module in
"   the simulation it must be included in the $CM_LIST replacement statement.
"   The component modules in this list are stacked sequentially for the
"   simulation, one on top of the other, and must not overlap.
;
%E   " SLABS_cm.mortran - start of geometry description
"I>
"I> Geometry of XITWIN (SLABS):             ""toc:
"I> ******************
"I>
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I> -------->    IR=    | IR=1   |  IR=2    | ...... |  IR=N_SLABS    |
"I>    beam   N_SLABS+1 |        |          |        |                |
"I> direction  (airgap) |        |          |        |                |
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I>
"I>   IR is the region number within the CM.  There are N_SLABS(+1) local
"I>   regions. The first region is the slab furthest upstream.  If there
"I>   is an airgap at the front (top) then it is the last region,
"I>   otherwise the last region is the slab furthest downstream.
"I>
"I>
"I>            -----------------------------------------------
"I>            |          Region        | Description        |
"I>            |------------------------|--------------------|
"I>            |  absolute    | local   |                    |
"I>            |--------------|---------|                    |
"I>            |IRSTART_SLABS | IR_SLABS| slab infinite x, y |
"I>            |  +IR_SLABS-1 |         |                    |
"I>            -----------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_XITWIN
"                      ISUMRY_XITWIN
"                      HOWFAR_XITWIN
"                      WHERE_AM_I_XITWIN
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS ON USE/BUGS             ""toc:
"                             ************************
"
"         As structured, one cannot assign IREGION_TO_BIT or DOSE_ZONE values
"         to the air gap region if it exists.
"
"        in EGS_WINDOWS file, a disk instead of square is output
"
"*******************************************************************************
"
;
"*******************************************************************************
"**************************  DESCRIPTION OF VARIABLES  *************************
"*******************************************************************************
"
"
"                                OTHER VARIABLES
"                                ***************
"
"  Refer to the section on type declarations for each subroutine. The following
"  section describes the variables input from unit 5.  These variables define
"  the parameters of each simulation.
"
"*******************************************************************************
"
"                               INPUT FROM UNIT 5              ""toc:
"                               *****************             ""toc:
"
"I>
"I>  CARDS CM_XITWIN  (SLABS)
"I>  **************
"I>
"I>  -1  dummy line (filled with ****)  read in main
"I>
"I>   0  RMAX_CM(ICM_XITWIN)       outer boundary for CM - 1/2 side of
"I>                                square(read in main)
"I>
"I>   1  TITLE_XITWIN (60A1):  Title of CM.
"I>
"I>   2  N_XITWIN (I5):  Number of planar slabs in CM = # regions in CM,
"I>                      excludes any air gap needed.
"I>
"I>   3  ZMIN_XITWIN (F15.0):  Distance from front of first slab to reference
"I>                            plane  (Z=0).
"I>
"I>   4  Parameters of each slab from front to back (increasing Z).  One pair of
"I>      cards (4a and 4b) for each of the slabs.
"I>
"I>      4a   ZTHICK_XITWIN, ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT, ESAVEIN
"I>                           (3F15.0,2I5,F15.0):
"I>
"I>              ZTHICK_XITWIN:   slab thickness.
"I>              ECUT, PCUT:      Cutoff energies-defaults are ECUTIN,PCUTIN
"I>              DOSE_ZONE:       Dose zone to score dose - 0 if not scored
"I>              IREGION_TO_BIT:  map this region to this bit number in LATCH
"I>              ESAVEIN:         Value of ESAVE for this region if range
"I>                               rejection on. Default is ESAVE_GLOBAL.
"I>
"I>      4b   MED_IN (24A1):  Medium of the planar slab, used to set MED_INDEX.
"I>
"I>   Example
"I>   *******
"I>
"I>  The following set of cards defines a 1 cm thick slab of air sandwiched
"I>  between two 0.1 cm thick slabs of tungsten.  The front slab is at
"I>  Z=7.32 cm. Electrons will be followed in the slabs down to kinetic energies
"I>  of 10 keV (total energies of 0.521 MeV) and photons will be followed down
"I>  to energies of 1 keV.  The dose deposited in the air will be scored and
"I>  added to the dose from the other regions in dose zone 1, and the
"I>  dose deposited in both tungsten slabs will be scored and added to the dose
"I>  from the other regions in dose zone 2.  Particles interacting in
"I>  the first slab will be associated with BIT 1 in LATCH.  In all slabs,
"I>  ESAVEIN=0, thus ESAVE in each slab will default to ESAVE_GLOBAL.
"I>
"I>  10.0,                         RMAX_CM
"I>  Multiple slabs: 0.1cm W-1cm air-0.1cm W, ECUT=0.521, PCUT=0.001
"I>  3,                            N_SLABS
"I>  7.32,                         ZMIN_SLABS
"I>  0.1, 0.521, 0.001, 2,1,0.0,   ZTHICK_SLABS etc
"I>  W521ICRU
"I>  1., 0.521, 0.001, 1,0,0.0
"I>  AIR521ICRU
"I>  0.1, 0.521, 0.001, 2,0,0.0
"I>  W521ICRU
"
"
%E   "Start of subroutine INPUT_XITWIN"
"*******************************************************************************
"
"                           Subroutine INPUT_SLABS
"                           **********************
"
"  A CM input subroutine for a series of 1 or more slabs infinite in x & y.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_XITWIN;


;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_XITWIN,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;
"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_SLABS
"T>*********************************
"T>
$REAL ZMIN_XITWIN,                   "T>minimum Z for this CM
      ESAVEIN;                       "T>ESAVE value read in for each region

INTEGER I,J,                         "T>DO loop indeces
        IRA,                         "T>Absolute region number
        MED_FLAG,                    "T>flag for media-sort macro $MED_INPUT
        MED_INDEX,                   "T>medium index,set(post)sort $MED_INPUT
        NDO;                         "T>loop index
"
"  initialize parameters
"  =====================
"
ICM_XITWIN = ICM;                   "CM index for this component module
                                    "Note ICM_XITWIN not needed here since
                                    "ICM is set, but it is not set when
                                    "other routines called.
IRSTART_XITWIN = IR_start_CM(ICM_XITWIN); "Index of first region in this CM,
                                    "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_XITWIN) = 0;          "Geometry-checking flag, 0 if no errors
"
"establish CM boundary as a square (was cylinder prior to April 13,1994)
RMAX_CM_FLAG(ICM_XITWIN) = 2;       "put a square boundary about CM
"
OUTPUT;(/' XITWIN (SLABS)');
OUTPUT RMAX_CM(ICM); (' This component is a set of planar slabs'/
  '      Outer boundary is a square with |x| & |y| <',F10.2,' cm');
IF(ICM_XITWIN = 1)[
   OUTPUT Z_min_CM(ICM_XITWIN);
   (' This is first component -- starts at ',F11.4,' cm from reference plane');]
ELSE
   [OUTPUT Z_min_CM(ICM_XITWIN);(' Previous CM ends at:',F12.5,' cm');]
OUTPUT;(' TITLE: ',$);
;MINPUT (XITWIN) TITLE_XITWIN;(60A1);
               "MINPUT is a replacement macro with EOF and
               "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_XITWIN;(' ',60A1);
"
"   get information for each slab
"   =============================
"
"
"Get maximum number of slabs (and regions) permitted
OUTPUT $MAX_N_XITWIN; (' NUMBER OF SLABS (MINIMUM 1, MAXIMUM',I3,'): ',$);
;MINPUT (XITWIN) N_XITWIN; (I5);
OUTPUT N_XITWIN; (I5);
IF(N_XITWIN < 1)[
         N_XITWIN=1;
         OUTPUT ICM_XITWIN;
          (//'***ERROR IN CM ',I4,' (SLABS):'/
             '# of slabs < 1'/
             '# of slabs set to 1 for now.'//);
         IERR_GEOM(ICM_XITWIN)=IERR_GEOM(ICM_XITWIN)+1;
]
ELSEIF (N_XITWIN > $MAX_N_XITWIN)[
               N_XITWIN=$MAX_N_XITWIN;
               OUTPUT ICM_XITWIN, N_XITWIN;
               (//'***ERROR IN CM ',I4,' (SLABS):'/
                  '# of slabs > max. allowed'/
                  '# of slabs reduced to ',I4,' for now'//);
               IERR_GEOM(ICM_XITWIN)=IERR_GEOM(ICM_XITWIN)+1;
]

" get distance from reference plane, z=0"
"
OUTPUT;
 (' DISTANCE FROM FRONT OF SLABS (excluding air gap) TO REF PLANE (z=0): ',$);
;MINPUT (XITWIN) ZMIN_XITWIN;(F15.0);
OUTPUT ZMIN_XITWIN;(F10.5);
IF(ZMIN_XITWIN < Z_min_CM(ICM_XITWIN))["have overlapped two CMs"
   IF(ICM_XITWIN = 1)["first CM is special case"
     "Z_min_CM(1) is very front of accelerator, including air, input in main"
     OUTPUT ICM_XITWIN, ZMIN_XITWIN,Z_min_CM(ICM_XITWIN);
      (//' ***WARNING IN CM ',I4,' (XITWIN):'/
       ' Z_min_CM(1) (=front of the accelerator) is past front of first slab'/
       ' Z_min_CM(1) reset to value just input =',F8.5,' cm'/
       ' from ',F8.5,' cm'//);
     WRITE(IOUTLIST,:label1:) ICM_XITWIN, ZMIN_XITWIN,
                              Z_min_CM(ICM_XITWIN);
          :label1: FORMAT(//' ***WARNING IN CM ',I4,' (XITWIN):'/
  ' Z_min_CM(1) (=front of the accelerator) is past front of first slab'/
  ' Z_min_CM(1) reset to value just input =',F8.5,' cm'/
  ' from ',F8.5,' cm'//);
     Z_min_CM(ICM_XITWIN) = ZMIN_XITWIN;
   ]
   ELSE[
     OUTPUT ICM_XITWIN;
       (//'***ERROR IN CM ',I4,' (XITWIN):'/
          'Overlaps with previous CM.'//);
     IERR_GEOM(ICM_XITWIN)=IERR_GEOM(ICM_XITWIN)+1;
   ]
]

"loop over slabs
"
IRA = IRSTART_XITWIN-1; "absolute region number
DO IR_XITWIN=1,N_XITWIN [
   "loop through local region number to get slab information"
   IRA = IRA+1;
   "get thickness, cutoff energies, and dose scoring zone"
   "
   OUTPUT IR_XITWIN;(//' Inputs for slab # ',I5);
   OUTPUT; (' SLAB THICKNESS(cm), ECUT, PCUT,',
         ' DOSE ZONE(0=>DONT SCORE), IREGION_TO_BIT,ESAVE'/' :',$);
   ;MINPUT (XITWIN)
      ZTHICK_XITWIN(IR_XITWIN),ECUT(IRA),PCUT(IRA),
      DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),ESAVEIN;
      (3F15.0,2I5,F15.0);
   IF (ECUT(IRA) < ECUTIN) ECUT(IRA)=ECUTIN;
   IF (PCUT(IRA) < PCUTIN) PCUT(IRA)=PCUTIN;
   IF (ESAVEIN > 0.511) [ESAVE(IRA) = ESAVEIN;]
   ELSE [ESAVE(IRA)=ESAVE_GLOBAL;]
   "Particles with total energies < ESAVE are considered for range rejection"
   "if range rejection is on.  Default is ESAVE_GLOBAL but values are set"
   "back to zero in main if range rejection is off"
   ;OUTPUT
      ZTHICK_XITWIN(IR_XITWIN),ECUT(IRA),PCUT(IRA),
      DOSE_ZONE(IRA),IREGION_TO_BIT(IRA), ESAVE(IRA);
      (3F11.5,I9,I20,F11.5);
   IF(ZTHICK_XITWIN(IR_XITWIN)<0.0)[
      OUTPUT ICM_XITWIN, IR_XITWIN;
       (//'***ERROR IN CM ',I4,' (SLABS):'/
          'ZTHICK(',I4,') < 0.0'//);
      IERR_GEOM(ICM_XITWIN)=IERR_GEOM(ICM_XITWIN)+1;
   ]
   "get material for this slab and determine material number for this region"

   OUTPUT;(' SLAB ',$);
   ;$MED_INPUT(XITWIN); " inputs character array MED_IN from unit 5, loops
      "through array MEDIA(24,I) to check if medium was previously input.
      "If so, sets MED_INDEX to index of previous medium.  If not,
      "increments NMED and sets MED_INDEX to NMED.
   MED(IRA) = MED_INDEX; " medium of the planar slab
] "end of loop over IR_XITWIN"
"
"  parameter definition
"  ====================
"
"fill arrays of distance from reference plane (z=0) to front and back of slabs
ZFRONT_XITWIN(1) = ZMIN_XITWIN;
IF (N_XITWIN > 1) [
   DO IR_XITWIN=1,N_XITWIN-1 ["loop through local region number"
      ZBACK_XITWIN(IR_XITWIN) = ZFRONT_XITWIN(IR_XITWIN) +
                            ZTHICK_XITWIN(IR_XITWIN);
      ZFRONT_XITWIN(IR_XITWIN+1) = ZBACK_XITWIN(IR_XITWIN);
   ] "end of loop over IR_XITWIN"
]
ZBACK_XITWIN(N_XITWIN) = ZFRONT_XITWIN(N_XITWIN) +
                             ZTHICK_XITWIN(N_XITWIN);
"
"establish start of next CM
Z_min_CM(ICM_XITWIN+1) = ZBACK_XITWIN(N_XITWIN);
"
"  set up air gap to previous CM, if present
"  =========================================
"
"  The air gap has the highest region number in the CM, even though it is at
"  the top of the component module.  This is to allow the assignment of region
"  numbers on input of the parameters of each local region (mainly to assign the
"  medium number of the region).  The air gap is then assigned after all of the
"  CM parameters have been input.
"
Z_gap_THICK(ICM_XITWIN) = ZMIN_XITWIN-Z_min_CM(ICM_XITWIN);

IF (Z_gap_THICK(ICM_XITWIN) < $MIN_GAP) ["$MIN_GAP is defined in  main"
   Z_gap_THICK(ICM_XITWIN) = 0.;
   ZFRONT_XITWIN(1)=Z_min_CM(ICM_XITWIN);
   N_GAP_XITWIN = 0; "no air gap for this CM
]
ELSE [
   N_GAP_XITWIN = 1; "this CM has an air gap
   IRA = IRSTART_XITWIN+N_XITWIN; "absolute region number of air gap
   MED(IRA) = AIR_INDEX; "medium is air, vacuum or whatever assigned
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
   ECUT(IRA) = ECUTIN;
   PCUT(IRA) = PCUTIN;
   ZFRONT_XITWIN(N_XITWIN+1) = Z_min_CM(ICM_XITWIN);
   "only for output listing
]
"  set up region numbers
"  =====================
"
"  This CM has N_XITWIN+N_GAP_XITWIN regions, plates infinite in x & y, with
"  an air gap at the front, if present. Slabs are numbered in sequence starting
"  from the furthest upstream slab to the last downstream slab, followed by the
"  air gap, if present.
"
IREND_XITWIN = IRSTART_XITWIN+N_XITWIN+N_GAP_XITWIN-1;
               "Index of last region
NREG = NREG+N_XITWIN+N_GAP_XITWIN;  "Total of regions in full geometry up
                                    "to and including this CM
                                    "NREG is in comin GEOM
IF (NREG <= $MXREG) ["have not exceeded maximum region number
      "Index of first region in next CM:"
      IR_start_CM(ICM_XITWIN+1) = IREND_XITWIN+1;
]
ELSE [
      OUTPUT ICM_XITWIN,NREG,$MXREG;
      (//'***ERROR IN CM ',I4,' (SLABS):'/
         I4,' regions requested, only', I4,' available'/
         '    Change $MXREG in beam_user_macros.mortran'//);
      IERR_GEOM(ICM_XITWIN)=IERR_GEOM(ICM_XITWIN)+1;
]
"
"  establish dose-scoring zones and range rejection parameters for each region
"  ===========================================================================
"
"Note air gap cannot be a dose scoring region as presently set up.
IRA = IRSTART_XITWIN-1; "absolute region number
DO IR_XITWIN=1,N_XITWIN ["loop over local region number
   IRA = IRA+1;

   "dose-scoring zones
   "
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT); " current maxmum number
] "end of loop over IR_XITWIN

"set up minimum thicknesses which in this case are just the last 5"
"slabs"
"If we ever need more than 5 slabs, we should extend this or do
"something fancy like group similar materials"

NDO = MIN(5,N_XITWIN); "consider at most 5 slabs of material"
                       "air gap handled below"
                       "limit of 5 not essential here, but needed in helpful"
                       "in other cases"
"OUTPUT NDO;(' For automated range rejection consider',I3,' slabs of material');
DO IR_XITWIN = N_XITWIN, N_XITWIN-NDO+1, -1 [
   IRA = IR_XITWIN + IRSTART_XITWIN-1;   "absolute region"
   Z_min_thick(ICM,N_XITWIN+1 - IR_XITWIN) = ZTHICK_XITWIN(IR_XITWIN);
   "MED_min_thick is in COMIN CMs"
   MED_min_thick(ICM,N_XITWIN+1 - IR_XITWIN) = MED(IRA);
   "OUTPUT IR_XITWIN,IRA,ICM, N_XITWIN+1-IR_XITWIN,
      "Z_min_thick(ICM,N_XITWIN+1-IR_XITWIN),
      "ICM,N_XITWIN+1 - IR_XITWIN,
      "MED_min_thick(ICM,N_XITWIN+1 - IR_XITWIN);
      "(' IR_XITWIN,IRA=',I2,',',I3,' Z_min_thick(',2I2,')=',F10.3,
      "'  MED_min_thick(',2I3,')=',I2   );
]
IF(NDO < 5)[  "some not used - include air gap if there is one"
    IF(N_GAP_XITWIN = 1)["There is an air gap"
       Z_min_thick(ICM,NDO+1) = Z_gap_thick(ICM_XITWIN);
       MED_min_thick(ICM,NDO+1) = 1; "AIR is 1"
       OUTPUT ICM,NDO+1,Z_min_thick(ICM,NDO+1),ICM,NDO+1,
                 MED_min_thick(ICM,NDO+1);
       (' Front air gap',T20,' Z_min_thick(',I2,',',I2,')=',F10.3,
                 '  MED_min_thick(',I2,',',I2,')=',I5   );
       NDO = NDO +1;
    ]"end of loop if there is an air gap"
    IF(NDO < 5 )["check in case incremented by air gap"
       DO I = NDO+1,5["zero remaining, unused values"
         Z_min_thick(ICM,I) = 0.0;
         MED_min_thick(ICM,I) = 0;
       ]"end of do loop on I"
    ]"end second NDO < 5 case"
]"end NDO < 5 case"
"
"   return from INPUT_SLABS
"   =======================
RETURN;

"   error messages
"   ==============
"
:EOF_XITWIN:
;OUTPUT ICM;
(//' *** ERROR in XITWIN *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_XITWIN:
;OUTPUT ICM;(//' *** ERROR  in XITWIN *** format error on input for CM',I3);
STOP; END;
"End of INPUT_XITWIN"

%E   "start of subroutine ISUMRY_XITWIN"
"*******************************************************************************
"
"                          Subroutine ISUMRY_SLABS
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_XITWIN;


;IMPLICIT NONE;
;COMIN/BOUNDS,CMs,CM_XITWIN,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_SLABS
"T>**********************************
"T>
INTEGER
   ICOLOUR,   "T>colour of CM for EGS_Windows
   IDD,       "T>index of dose scoring zone
   IRA,       "T>absolute region number
   J;         "T>DO loop index
"
"   Mass of dose zone
"   =================
"Need to calculate mass of dose zone here,after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_XITWIN.
"
IRA = IRSTART_XITWIN-1; "absolute region number
DO IR_XITWIN=1,N_XITWIN+N_GAP_XITWIN ["loop over local region number
   IRA = IRA+1;
   IF(DOSE_ZONE(IRA).NE.0) ["this is a dose zone"
      IDD=DOSE_ZONE(IRA);
      "add mass of square region to any previous mass in dose region"
      AMASS(IDD)=AMASS(IDD) + RHOR(IRA)* (ZBACK_XITWIN(IR_XITWIN)
                 - ZFRONT_XITWIN(IR_XITWIN))*4*(RMAX_CM2(ICM_XITWIN));
      "note RHOR is the density which defaults to that from PEGS4 in HATCH
      "but could be set to any value prior to call to hatch
   ]
] "end of loop over IR_XITWIN"

"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"
"Output to list file changed to make it more clear--B Walters 18/08/94"

WRITE(IOUTLIST,110) ICM_XITWIN,TITLE_XITWIN;
WRITE(IOUTLIST,120) Z_min_CM(ICM_XITWIN),RMAX_CM(ICM_XITWIN);
WRITE(IOUTLIST,122);
IF(N_GAP_XITWIN~=0)[
   WRITE(IOUTLIST,124) 'airgap',Z_min_CM(ICM_XITWIN),
                       ZFRONT_XITWIN(1)-Z_min_CM(ICM_XITWIN);
]
DO IR_XITWIN=1,N_XITWIN[
   WRITE(IOUTLIST,123) IR_XITWIN,ZFRONT_XITWIN(IR_XITWIN),
                       ZTHICK_XITWIN(IR_XITWIN);
]
WRITE(IOUTLIST,130);
IRA = IRSTART_XITWIN-1;

DO IR_XITWIN=1,N_XITWIN + N_GAP_XITWIN [
   IRA = IRA+1;
   IF(IR_XITWIN<=N_XITWIN)[
      IF (MED(IRA)=0) ["Medium is vacuum"
         WRITE(IOUTLIST,140)
         IR_XITWIN,IR_XITWIN,'slab',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,140)
         IR_XITWIN,IR_XITWIN,'slab',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]
   ELSE[
      IF (MED(IRA)=0) ["Medium is vacuum"
         WRITE(IOUTLIST,142)
         IR_XITWIN,'NA','airgap',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,142)
         IR_XITWIN,'NA','airgap',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
    WRITE(IOUTLIST,141)'at top';
    ]
]"end loop on IR_XITWIN"


110 FORMAT(///1x,79('-')/
 '  Component module',I3,' is one or more planar slabs  ',
 '(SLABS)'
           /1x,79('-')
           //T5,'Title: ',68A1);
120 FORMAT(/T2,'XITWIN geometry parameters:',
           /T2,'-----------------------------',
           /T2,'Distance of front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Half-width of outer boundary of CM = ',F15.5,' cm');
122 FORMAT(/T2,
'slab #    Z front    thickness',
/T2,
'           face               ',
/T2,
'           (cm)        (cm)   ');
123 FORMAT(T2,I4,F12.3,F11.3);
124 FORMAT(T2,A6,F10.3,F11.3);
130 FORMAT(/T2,'XITWIN region parameters:',
           /T2,'---------------------------',
           /T2,'local  slab #  location  electron  photon',
           '  range-rejection  dose  bit  medium'
           /T2,'region                    cutoff   cutoff',
           '   level     max   zone  set'
           /T2,'                           (MeV)    (MeV)',
           '   (MeV)    (MeV)');

140 FORMAT(T2,I3,I7,5X,A7,F10.3,F9.3,F8.3,F9.3,I5,I5,2X,9A1);
141 FORMAT(T17,A7);
142 FORMAT(T2,I3,5X,A2,5X,A7,F10.3,F9.3,F8.3,F9.3,I5,I5,2X,9A1);



"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"
IF (IWATCH = 4 | IZLAST = 2) ["Graphics file requested"
   ICOLOUR = MOD(ICM_XITWIN,4)+1; "select ICOLOUR = 1, 2, or 3, colour of CM"
   DO IR_XITWIN=1,N_XITWIN ["Loop over local region number"
      WRITE(IOUTGEOM,200) ICOLOUR,'DISK',0.,0.,
                       ZFRONT_XITWIN(IR_XITWIN),RMAX_CM(ICM_XITWIN);
      "NOTE *** it was a disk but it is a square now!"
   ]
   WRITE(IOUTGEOM,200) ICOLOUR,'DISK',0.,0.,
                       ZBACK_XITWIN(N_XITWIN),RMAX_CM(ICM_XITWIN);
   200 FORMAT(' ',I1,A4,10(F7.2,','));
] "End of graphics output"
"
;RETURN;END;
"SLABS_cm.mortran end of ISUMRY_XITWIN"

%E   "start of subroutine HOWFAR_XITWIN"
"*******************************************************************************
"************************** Component Module SLABS *****************************
"*******************************************************************************
"
"                          Subroutine HOWFAR_SLABS
"                          ***********************
"
" HOWFAR routine for stacked planar media.
"
" Determine if current region number is within component module SLABS, and if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are N_SLABS local regions + an air gap (if present):
"
"     local               absolute                  description
"   ---------  ----------------------------------  -------------
"   IR_SLABS   IR_start_CM(ICM_SLABS)+IR_SLABS-1   slab IR_SLABS
"   N_SLABS+1  IR_start_CM(ICM_SLABS)+N_SLABS      air gap
"
"       Geometrical co-ordinates, as set in INPUT_SLABS are:
"       ZFRONT_SLABS(IR_SLABS)     front of slab IR_SLABS (upstream surface)
"       ZBACK_SLABS(IR_SLABS)      back of slab IR_SLABS (downstream surface)
"
"*******************************************************************************

;SUBROUTINE HOWFAR_XITWIN;


;IMPLICIT NONE;
;COMIN/ CMs,CM_XITWIN,EPCONT,STACK,EGS-IO/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_SLABS
"T>**********************************
"T>
INTEGER
   IRL;         "T>local region number (absolute), required by HOWNEAR macro
$REAL
   DIST,        "T>distance to region boundary along current particle trajectory
   DMIN_XITWIN, "T>minimum distance to boundaries checked thus far
   ZNEAR;       "T>distance to nearest boundary

IRL = IR(NP);   "local region number (absolute)

" Set DNEAR
" *********
" This replacement macros sets DMIN_XITWIN as well as defining IR_XITWIN
;
XITWIN_CM_HOWNEAR(DMIN_XITWIN);
DNEAR(NP) = DMIN_XITWIN;
;
" Boundary-crossing check
" ***********************
" Determine if current region number is within component module SLABS,
"  and if so evaluate DIST, distance to region boundary along current
" trajectory.  USTEP must not exceed DIST.
"
IF (IR_XITWIN>0 & IR_XITWIN<N_XITWIN+1) [
   "particle in this CM (not in air gap)"
   IF (W(NP)>0.0) ["particle going forward"
      "calculate distance to back boundary"
      ZNEAR = ZBACK_XITWIN(IR_XITWIN)-Z(NP);
      DIST = ZNEAR/W(NP);
      IF (DIST < 0.) [DIST=0.;]
      "Above check was put in to handle the case where the distance"
      "to interaction is ~ the distance to the"
      "back of the SLABS CM.  In this case, particles initiated"
      "by the interaction may actually have Z values that put them"
      "in the next CM, but because the WHERE_AM_I for the next"
      "CM has not been called yet, HOWFAR for SLABS is used, and a"
      "negative USTEP results.  Note that this unusual case has"
      "only been observed to occur between SLABS and CONS3R CMs"
      "when incident particles are photons, SLABS is the target, and"
      "CONS3R is the primary collimator immediately below the target"
      "18/12/95"
      IF(DIST=0. & IR_XITWIN=N_XITWIN)[DIST=1.E-16;]
      "Above gives DIST a very small positive value in case of leaving CM"
      "When collecting phase space immediately below a thin (0.01 cm) layer of"
      "Mylar in a beam, there was a high probability of the calculated"
      "value of USTEP (ie unmodified by HOWFAR) actually putting the particle"
      "right on the back of the mylar layer.  When it came to the next step,"
      "the calculated value of DIST was 0, which meant USTEP was set to 0,"
      "and, as a result, AUSGAB was not called on leaving the CM."
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         IF (IR_XITWIN<N_XITWIN) ["particle will remain in CM"
            IRNEW = IR(NP)+1; "new region number"
         ]
         ELSE ["particle will enter downstream CM"
            CALL WHERE_AM_I(ICM_XITWIN,1); "get IRNEW, ICMNEW"
         ]
      ]
   ]" end of forward going block"
   ELSEIF (W(NP)<0.0) ["particle going backwards"
      "calculate distance to front boundary"
      ZNEAR = Z(NP)-ZFRONT_XITWIN(IR_XITWIN);
      DIST = -ZNEAR/W(NP); "Direction cosine is negative"
      IF (DIST < 0.) [DIST=0.;] "see reason above"
      IF (DIST=0. & N_GAP_XITWIN=0 & IR_XITWIN=1)[ DIST=1.E-16;]
      IF(DIST <= USTEP) [
         USTEP = DIST;
         IF (IR_XITWIN>1) ["particle will remain in CM"
            IRNEW = IR(NP)-1; "new region number"
         ]
         ELSEIF (IR_XITWIN=1 & N_GAP_XITWIN=1) ["particle entering air gap"
            IRNEW = IREND_XITWIN; "new region number"
         ]
         ELSE ["particle will enter upstream CM"
            CALL WHERE_AM_I(ICM_XITWIN,-1); "get IRNEW, ICMNEW"
         ]
      ]
   ]" end of backward going block"
   "if W(NP)=0.0, never hit boundary, need not reset USTEP"
]"end of CM regions"

"   in air gap at top of CM
"   =======================
"
ELSEIF (IR_XITWIN=N_XITWIN+1 & N_GAP_XITWIN=1) ["particle in air gap"
   IF (W(NP)>0.0) ["particle going forward"
      "calculate distance to back boundary"
      ZNEAR = ZFRONT_XITWIN(1)-Z(NP);
      DIST = ZNEAR/W(NP);
      IF (DIST < 0.) [DIST=0.;] "See reason above"
      IF(DIST <= USTEP ) ["particle will enter first slab, this CM
         USTEP = DIST;
         IRNEW = IRSTART_XITWIN; "new region number"
      ]
   ]" end of forward going block"
   ELSEIF (W(NP)<0.0 ) ["particle going backwards"
      "calculate distance to front boundary"
      ZNEAR = Z(NP)-Z_min_CM(ICM_XITWIN);
      DIST = -ZNEAR/W(NP); "Direction cosine is negative"
      IF (DIST <= 0.) [DIST=1.E-16;] "See reason above"
                                     "Always set to small +ve value since"
                                     "we are definitely leaving through top"
      IF(DIST <= USTEP) ["particle will enter upstream CM"
         USTEP = DIST;
         CALL WHERE_AM_I(ICM_XITWIN,-1); "get IRNEW, ICMNEW"
      ]
   ]" end of backward going block"
   "if W(NP)=0.0, never hit boundary, need not reset USTEP"
]"end of air-gap region"

"   outside of CM, something is wrong
"   =================================
"
ELSE ["something is wrong"
   OUTPUT IR(NP)-IRSTART_XITWIN+1, IR(NP), ICM_XITWIN,
      IR_start_CM(ICM_XITWIN); (//' ************'//' HOWFAR_XITWIN error'/
      '    Region, local, absolute =',2I5/
      '    CM number=',I5,' start region =',I5/' *********'//);
   STOP;
] "end of IF statement"
RETURN; END; "End of subroutine HOWFAR_SLABS"

%E   "start of subroutine WHERE_AM_I_XITWIN"
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_SLABS
"                          ***************************
"
" WHERE_AM_I routine for stacked planar slabs.
"
" WHERE_AM_I_XITWIN determines the new region number when a particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_XITWIN subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_XITWIN from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************

;SUBROUTINE WHERE_AM_I_XITWIN(IDIR);


;IMPLICIT NONE;
;COMIN/CM_XITWIN,EPCONT,STACK/; "/STACK/would be needed for more complicated
                       "geometries.
"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_SLABS
"T>**************************************
"T>
INTEGER IDIR,I;  "T>direction of particle, +1=forward, -1=backward

IF (IDIR=1) ["particle entering this CM through front face (upstream)
   IF (N_GAP_XITWIN=0) ["no air gap this CM"
      IRNEW = IRSTART_XITWIN;
   ]
   ELSE ["this CM has an air gap at the front
      IRNEW = IREND_XITWIN;
   ]
]
ELSEIF(IDIR=2) ["particle starting within CM"
   IF(N_GAP_XITWIN=1 & Z(NP)< ZFRONT_XITWIN(1))[
      IRNEW = IREND_XITWIN;
   ]
   ELSE[
     IRNEW=IRSTART_XITWIN+N_XITWIN-1;
     DO I=1,N_XITWIN[
      IF(Z(NP)<ZFRONT_XITWIN(I)+ZTHICK_XITWIN(I))[
          IRNEW=IRSTART_XITWIN+I-1;
          EXIT;
      ]
     ]
   ]
]
ELSE ["particle entering this CM through back face (downstream)
   IRNEW = IRSTART_XITWIN+N_XITWIN-1;
]
RETURN;
END; "End of subroutine WHERE_AM_I_SLABS"

%E  "start of subroutine HOWNEAR_XITWIN"
"*****************************************************************************
"
"                        Subroutine HOWNEAR_XITWIN
"                        *************************
"
" Returns min. distance to nearest region boundary.  Used to be a macro, but
" now the the macro calls this subroutine.
"
"*****************************************************************************

;SUBROUTINE HOWNEAR_XITWIN(DIST);

$IMPLICIT-NONE;

COMIN/CM_XITWIN,STACK,CMs/;

$REAL DIST; "T> min. distance to nearest region boundary

IR_XITWIN = IR(NP)-IRSTART_XITWIN+1;
IF(IR_XITWIN=N_XITWIN+1 & N_GAP_XITWIN=1)["particle is in air gap"
   DIST=MIN(Z(NP)-Z_min_CM(ICM_XITWIN),ZFRONT_XITWIN(1)-Z(NP));
]
ELSE["particle is in one of the layers"
   DIST=MIN(Z(NP)-ZFRONT_XITWIN(IR_XITWIN),
       ZBACK_XITWIN(IR_XITWIN)-Z(NP));
]
RETURN;
END; "End of subroutine HOWNEAR_XITWIN"
"******************************************************************************
"End of SLABS_cm.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: 3-region stacked truncated cones          "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Charlie Ma                                                "
"                   Dave Rogers                                               "
"                   Joanne Treurniet                                          "
"                   Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             **************                 ""toc:
"                             *            *                 ""toc:
"                             *   CONS3R   *                 ""toc:
"                             *            *                 ""toc:
"                             **************                 ""toc:
"
"   History of modifications given by SCCS
"
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.  It is can be used for any case for r symmetry
"   if there are only two region in r direction, e.g, slab, ring, stack rings,
"   cone(primary collimator), cone stack. limit: the first version only can
"   allow the convex shapes in z direction, not the concave shapes, if required,
"   can be changed.
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator: primary collimator
"
%E   "COLLIMAT_cm   start of geometry description (CONS3R)
"I>
"I> Geometry of COLLIMAT: (CONS3R)
"I> *********************************
"I>                                        |
"I>                            |           |  beam direction
"I>                            .           |
"I>                            |          \|/
"I>                            .           .
"I>                  ----------------------------------------------
"I>                            |    Air gap IR= 3 if it exists
"I>                  ----------------------------/------------------
"I>                            .                / point 1
"I>                            |       point 2 /
"I>                            .               \ IR = 2
"I>                            |        IR = 1  \  point 3
"I>                            .                /
"I>                                            /
"I>              central axis  |               \ point i-1
"I>                            .                \
"I>                            |                 \ point i
"I>                            .                 /
"I>                            |                / point i+1
"I>                            .                \
"I>                            |                 \
"I>                            .                  \ .....
"I>                            |                  |
"I>                            .                  |
"I>                            |                  |
"I>                            .                  | point n
"I>                  ----------------------------------------------
"I>
"I>
"I>
"I>
"I>   IR is the region number within the CM.  There are three local regions
"I>   shown above.
"I>
"I>
"I>            ------------------------------------------------------
"I>            |             Region            | Description         |
"I>            |-------------------------------|---------------------|
"I>            |  absolute       | local       |                     |
"I>            |-----------------|-------------|                     |
"I>            |                 |             |                     |
"I>            |IRSTART_CONS3R   | IR_CONS3R   |  as shown in above  |
"I>            |  +IR_CONS3R-1   |             |    (1 to 2)         |
"I>            |                 |             |                     |
"I>            |                 |             |                     |
"I>            -------------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_COLLIMAT
"                      ISUMRY_COLLIMAT
"                      HOWFAR_COLLIMAT
"                      WHERE_AM_I_COLLIMAT
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"
"                             RESTRICTIONS ON USE/BUGS           ""toc:
"                             ************************
"
"
"*******************************************************************************
"*******************************************************************************
"**************************  DESCRIPTION OF VARIABLES  *************************
"*******************************************************************************
"
"                             COMMON BLOCK VARIABLES
"                             **********************
"
"  Refer to the replacement macros in BEAM.MORTRAN and BEAM_COMMON.MORTRAN
"  which define the common block variables.
"
"*******************************************************************************
"
"                                OTHER VARIABLES
"                                ***************
"
"  Refer to the section on type declarations for each subroutine. The following
"  section describes the variables input from unit 5.  These variables define
"  the parameters of each simulation.
"
"*******************************************************************************
"
"                    Description of user input for CONS3R        ""toc:
"                    ************************************        ""toc:
"
"I>
"I>  CARDS CM_COLLIMAT (CONS3R)
"I>  **************
"I>
"I>   -1 Dummy line to indicate start of CM
"I>
"I>   0  RMAX_CM(ICM_COLLIMAT) (F10.0):  Outer radial boundary of CM (cm).
"I>
"I>   1  TITLE_COLLIMAT (60A1):  Title of CM.
"I>
"I>   2  ZMIN_COLLIMAT (F15.0):  Dist from front of cones to
"I>                             reference plane (Z=0).
"I>
"I>   3  ZTHICK_COLLIMAT (F15.0): The thickness of cones (excludes front air).
"I>
"I>   4  NUM_NODE_COLLIMAT (I5):  The # of points to be used <$NPOINT_CONS3R.
"I>
"I>   Repeat 5 for I=1,NUM_NODE_COLLIMAT
"I>
"I>   5  ZCORNER_COLLIMAT(I), RCORNER_COLLIMAT(I) (2F15.0):
"I>        Positions (Z, R) for node I.  First & last must match
"I>        ZMIN_COLLIMAT and ZMIN_COLLIMAT+ZTHICK_COLLIMAT.  Note also the
"I>        restriction Z(I+1) >= Z(I).
"I>
"I>   Repeat 6, 7 for inner (ie inside cons3r), then outer region
"I>
"I>   6  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT, IREJCTIN  (2F15.0,3I5):
"I>
"I>         ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   If non-zero, dose in this zone is scored in this
"I>                      dose zone
"I>         IREGION_TO_BIT:   region to LATCH bit correspondence for particles
"I>                      interacting in this region
"I>         IREJCTIN:    If IREJCT_GLOBAL is on, then by setting IREJCT=-1
"I>                      here, range rejection is turned off in this region
"I>                      If left blank or zero, the global value is used.
"I>
"I>   7  MED_IN (24A1):  Medium of region
"I>                      used to set MED_INDEX.
"I>
"I>
"I>   Example
"I>   *******
"I>
"I>  The following input example describes a 1cm thick flat-top cone, having
"I>  a radius at the top of 0.8cm and a radius at the bottom of 1.2cm
"I>  sitting on a 0.3cm thick cylinder of radius 1.5cm which, in turn,
"I>  is sitting atop a flat-top cone of thickness 1.0cm with top radius
"I>  0.5cm and bottom radius=0.8cm.  The two cones and cylinder are
"I>  made of H2O--note that all of these structures MUST be of the same
"I>  medium--and they are surrounded by AIR.  Dose in the surrounding
"I>  AIR is stored in dose zone 1, and dose in the cones/cylinder
"I>  structure is stored in zone 2.
"I>
"I>  5.0
"I>  example cons3r
"I>  0.0
"I>  2.3
"I>  6
"I>  0.0, 0.8
"I>  1.0, 1.2
"I>  1.0, 1.5
"I>  1.3, 1.5
"I>  1.3, 0.5
"I>  2.3, 0.8
"I>  0.521, 0.01, 2, 0, 0
"I>  H2O
"I>  0.521, 0.01, 1, 0 ,0
"I>  AIR
"I>
"
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules
"
"*******************************************************************************

%E   "CONS3R_cm - start of subroutine HOWFAR_COLLIMAT
"*******************************************************************************
"*********************** Component Module CONS3R *****************************
"*******************************************************************************
"
"                          Subroutine HOWFAR_COLLIMAT
"                          ************************
"
" HOWFAR routine for stacked truncated cones
"
" Determine if current region number is within component module CONS3R, if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are N_COLLIMAT local regions + an air gap (if present):
"
"     local               absolute                       description
"   ----------    ------------------------------   ----------------------
" IR_CONS3R    IR_start_CM(ICM_CONS3R)+IR_CONS3R-1 excluding front air gap
"   ----------    ------------------------------   -----------------------
"   Geometrical co-ordinates, as set in INPUT_CONS3R are:
"
"   ZFRONT_COLLIMAT     front of CM (upstream surface, air region)
"   ZMIN_COLLIMAT       front of CM
"   ZBACK_COLLIMAT      back of CM
"   RMIN_COLLIMAT       smallest radius of the module
"
"******************************************************************************

;SUBROUTINE HOWFAR_COLLIMAT;


"The following macros are used for boundary crossing. The particle is
"shifted by 1.0E-5 at the end of a step to overcome possible numerical errors
"V>$GEO_SHIFT_1_(#)
"V>=============
"V>{p1} the value to compare with ustep
"V> if {p1}+1.0e-5 < ustep shift it, otherwise no shift
;
REPLACE {$GEO_SHIFT_1_(#)} WITH {
; IF({P1}+1.0E-5< USTEP) [{P1}={P1}+1.0E-5;]  }

"V>$GEO_SHIFT_2_(#,#)
"V>=============
"V>{p1} the value to compare with {P2}
"V> if {p1}+1.0e-5 < {P2} shift it, otherwise no shift
;
REPLACE {$GEO_SHIFT_2_(#,#)} WITH {
; IF({P1}+1.0E-5< {P2}) [{P1}={P1}+1.0E-5;]  }

;IMPLICIT NONE;
;COMIN/ CMs,CM_COLLIMAT,EPCONT,STACK,EGS-IO/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_CONS3R
"T>**********************************
"T>
INTEGER
   IRL,        "T>local region number (absolute), required by HOWNEAR macro
   I, J, K,    "T>loop control
   IU_D,       "T>to indicate the relations bet ustep and dist
   DIRTMP;     "T>temp variable for use as direction indicator in macros

$REAL
   DIST,         "T>farthest distance to z boundary along current trajectory
   DIST_TMP,     "T>distance to z boundary along current particle trajectory
   RF_COLLIMAT,   "T>temporary variable
   RF2_COLLIMAT,  "T>temporary variable
   R0SQ,         "T>temporary init position of the particle in x-y plane
   R0DELR,       "T>temporary variable for vec r dot vec delta r
   DELRSQ,       "T>temporary variables for the sq of delta r
   RV_COLLIMAT,   "T>temporary variable  for the r
   RV2_COLLIMAT,  "T>temporary variable  for the r
   CRITERIOR_IR,
   R0SQ_2,CRITERIOR_IR_2,  "T>used for boundary crossing
   A, B, B2, C, TEMP1, CUT_COE1, CUT_COE2, CUT_COE,STEP_UNIT, STEP_UNITOLD,
                 "T>temporary variables used for quadratic eq.
   XPLN,YPLN,ZPLN;   "T>temp variable for storing x,y,z after planned step

$REAL one;
parameter (one = 1);

" Determine local region number
" *****************************
IRL = IR(NP); "local region number (absolute)
IR_COLLIMAT = IRL - IRSTART_COLLIMAT + 1;   "local region number( relative )

" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module CONS3R,if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
;
R0SQ=X(NP)**2+Y(NP)**2;
STEP_UNIT=0.0;
STEP_UNITOLD=0.0;  " this one will be used to control the cut_coe in the loop

" the following block double check:
"=================================
"      1. the particle is out of the CM oe regions in z direction
"      2.                        the regions in r directions
"     if so reset the ir #, and print out the warning message.
"comment: this block is not time consumming, can be kept in the final version
"=======
"
"  now do the air gap check if existed.
"=====================================

IF(N_GAP_COLLIMAT = 1 & IR_COLLIMAT = 3 ) "  check the air gap first
[
   IF(W(NP)>0.0)
   ["particle going forward"
      DIST = (ZMIN_COLLIMAT - Z(NP))/W(NP); "distance to front of CM
      IF(DIST < 0.0)
      [ " particle going forward"
          USTEP = 0.;
          IF( R0SQ<RCORNER2_COLLIMAT(1) )
          [  IRNEW =IRSTART_COLLIMAT; RETURN;]
          ELSE[IRNEW =IRSTART_COLLIMAT+1; RETURN;]
      ] " double check if a particle is out of the AIR GAP

   ]
   ELSEIF(W(NP)<0.0)
   [ " particle going backward"
      DIST = (ZFRONT_COLLIMAT - Z(NP))/W(NP); "distance to front of CM
      IF(DIST <= 0.0)
      [
          USTEP=1.e-16; "ensures call to ausgab for crossing CM boundary"
          CALL WHERE_AM_I(ICM_COLLIMAT,-1);
          RETURN;
      ] " double check if a particle is out of the CM
   ]
]
ELSEIF(IR_COLLIMAT=1 | IR_COLLIMAT=2)  " in the local region 1 or 2
[
   IF(W(NP) > 0.0)
   [  "particle going forward"
      DIST = (ZMAX_COLLIMAT - Z(NP))/W(NP); "distance to back of CM
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <=0.0)
      [
          USTEP=1.e-16;
          CALL WHERE_AM_I(ICM_COLLIMAT,1);
          RETURN;
      ] " double check if a particle is out of the CM
   ]
   ELSEIF(W(NP) < 0.0)
   [  "particle going backward"
      DIST = (ZMIN_COLLIMAT - Z(NP))/W(NP); "distance to back of CM "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.)
      [
          IF(N_GAP_COLLIMAT = 1)
          [ USTEP=0.; IRNEW =IREND_COLLIMAT; RETURN; ]
          ELSE[ USTEP=1.e-16; CALL WHERE_AM_I(ICM_COLLIMAT,-1); RETURN; ]
      ] " double check if a particle is out of the main body to air gap
   ]
]

" end of z direction check
"=========================


" now do the check in r direction
"================================
"Note: in some unusual cases, if the particle z(np)=zcorner_CONS3R(i),
"      the folloing block may print out the error message, but it is not an
"      error!!

IF(IR_COLLIMAT=1 |IR_COLLIMAT=2 )[
      IF(W(NP)>=0.0)[
          DO I=1, NUM_NODE_COLLIMAT[IF(Z(NP)<ZCORNER_COLLIMAT(I))[EXIT;] ]
          J=I-1;
"         it will never happen j=i-1=num_node_CONS3R
      ]
      ELSE[
          DO I=NUM_NODE_COLLIMAT,1,-1[IF(Z(NP)>ZCORNER_COLLIMAT(I))[EXIT;]]
          J=I;
"         it will never happen j=i=0
      ]
      IF(SURPARA_COLLIMAT(J,4)<1.0E29)[
        "SURPARA_COLLIMAT(i,1)*R+SURPARA_COLLIMAT(i,2)*Z+SURPARA_COLLIMAT(i,3)=0
        IF(COUNT1_COLLIMAT>0)[
           CRITERIOR_IR=CRITOLD_COLLIMAT;
        ]
        ELSE[
           CRITERIOR_IR=SQRT(R0SQ)-(RCORNER_COLLIMAT(J)
             +SURPARA_COLLIMAT(J,4)*(Z(NP)-ZCORNER_COLLIMAT(J)));
        ]

" the following block is used to control the unusual case, if the particle
" cannot find the right region, it will be discarded and print the warning
" message!!!!!!
"=============================

        IF(CRITERIOR_IR>0.0 & IR_COLLIMAT =1 )[
           "The particle is in the wrong region"
           "following stmt used to be USTEP=1e-5 but this causes"
           "problems for low energy electrons where this is > range"
           "so now we just set USTEP=1e-5 if requested USTEP is"
           "longer, otherwise we leave it at the electr determined USTEP"
           "Bug reported by Joanne Moseley and Jeff Chen of London"
           "regional Cancer center, Dec 1995"
           IF(USTEP >= 1.0E-5 | USTEP = 0) USTEP=1.0E-5;
           XPLN=X(NP)+U(NP)*USTEP;
           YPLN=Y(NP)+V(NP)*USTEP;
           ZPLN=Z(NP)+W(NP)*USTEP; "found necessary for roundoff errors"
           R0SQ_2=XPLN**2 + YPLN**2;
           IF(W(NP)>=0.0)[
             DO I=1, NUM_NODE_COLLIMAT[
                IF(ZPLN<ZCORNER_COLLIMAT(I))[EXIT;]
             ]
             K=I-1;
           ]
           ELSE[
             DO I=NUM_NODE_COLLIMAT,1,-1[
                IF(ZPLN>ZCORNER_COLLIMAT(I))[EXIT;]
             ]
             K=I;
           ]
           CRITERIOR_IR_2=SQRT(R0SQ_2)-(RCORNER_COLLIMAT(K)+
                         SURPARA_COLLIMAT(K,4)*(ZPLN-ZCORNER_COLLIMAT(K)));
           IF(CRITERIOR_IR_2>0.0)[
              IRNEW=IRSTART_COLLIMAT+1;
           ]
           ELSE[
              IRNEW=IRSTART_COLLIMAT;
           ]
           COUNT1_COLLIMAT=COUNT1_COLLIMAT+1;
           IF(COUNT1_COLLIMAT>100)[
              OUTPUT X(NP),Y(NP),X(NP)**2+Y(NP)**2,Z(NP),U(NP),
                 V(NP),W(NP),E(NP),IQ(NP);
                 (/' WARNING FROM CONS3R (COLLIMAT):',
                   ' TAKEN USTEP = 1.0E-5 FOR 100 TIMES, '/
                   ' BUT THE PARTICLE STILL ENDS UP IN THE WRONG REGION'/
                   ' (ie INSIDE CONE WHEN IT SHOULD BE OUTSIDE OR VICE VERSA)'/
                   ' THE PARTICLE HAS BEEN DISCARDED.'/
                   ' OUTPUT: x,y,r**2,z,u,v,w,E,IQ '/
                    8F11.6,I3);
                 IDISC=1;
                 COUNT1_COLLIMAT=0;
                 USTEP=0.0;
           ]
           RETURN;
        ]
        ELSEIF(CRITERIOR_IR<0.0 & IR_COLLIMAT=2 )[
           IF(USTEP >= 1.0E-5 | USTEP = 0) USTEP=1.0E-5;
           XPLN=X(NP)+U(NP)*USTEP;
           YPLN=Y(NP)+V(NP)*USTEP;
           ZPLN=Z(NP)+W(NP)*USTEP; "found necessary for roundoff errors"
           R0SQ_2=XPLN**2 + YPLN**2;
           IF(W(NP)>=0.0)[
             DO I=1, NUM_NODE_COLLIMAT[
                IF(ZPLN<ZCORNER_COLLIMAT(I))[EXIT;]
             ]
             K=I-1;
           ]
           ELSE[
             DO I=NUM_NODE_COLLIMAT,1,-1[
                IF(ZPLN>ZCORNER_COLLIMAT(I))[EXIT;]
             ]
             K=I;
           ]
           CRITERIOR_IR_2=SQRT(R0SQ_2)-(RCORNER_COLLIMAT(K)+
                          SURPARA_COLLIMAT(K,4)*(ZPLN-ZCORNER_COLLIMAT(K)));
           IF(CRITERIOR_IR_2<0.0)[
              IRNEW=IRSTART_COLLIMAT;
           ]
           ELSE[
              IRNEW=IRSTART_COLLIMAT+1;
           ]
           COUNT1_COLLIMAT=COUNT1_COLLIMAT+1;
           IF(COUNT1_COLLIMAT>100)[
              OUTPUT X(NP),Y(NP),X(NP)**2+Y(NP)**2,Z(NP),U(NP),
                 V(NP),W(NP),E(NP),IQ(NP);
                 (/' WARNING FROM CONS3R (COLLIMAT):',
                   ' TAKEN USTEP = 1.0E-5 FOR 100 TIMES, '/
                   ' BUT THE PARTICLE STILL ENDS UP IN THE WRONG REGION'/
                   ' (ie INSIDE CONE WHEN IT SHOULD BE OUTSIDE OR VICE VERSA)'/
                   ' THE PARTICLE HAS BEEN DISCARDED.'/
                   ' OUTPUT: x,y,r**2,z,u,v,w,E,IQ '/
                    8F11.6,I3);
                 IDISC=1;
                 COUNT1_COLLIMAT=0;
                 USTEP=0.0;
           ]
           RETURN;
        ]
        ELSE["no problem, reset the error counter"
           COUNT1_COLLIMAT=0;
        ]
      ]
]


" end of the double check in r direction
"========================================

IF(IR_COLLIMAT = 1)
[   "local region 1

   RF2_COLLIMAT=(X(NP)+STEP_UNIT*U(NP))**2+(Y(NP)+STEP_UNIT*V(NP))**2;
   IF(W(NP) > 0.0)
   [
      " do the fast step if possible
      IF(RF2_COLLIMAT<RMIN2_COLLIMAT)
      [
            IF(IU_D=0)[ RETURN; ]  " ustep admitted"
            ELSE
            [
                $GEO_SHIFT_1_(STEP_UNIT);
                USTEP=STEP_UNIT;
                CALL WHERE_AM_I(ICM_COLLIMAT,1); RETURN;
            ]
      ]
      ELSE   " answer the question: hits side wall or not and where ?
      [
           DO J=I-1, NUM_NODE_COLLIMAT-1
           [ ; COLLIMAT_MACRO_1_IN(1,ZCORNER_COLLIMAT(J+1),1); ]
           IF(IU_D=1)
           [
                $GEO_SHIFT_1_(DIST);
                USTEP=DIST;
                CALL WHERE_AM_I(ICM_COLLIMAT,1);
                RETURN;
           ]
           ELSE[ RETURN; ] " ustep admitted and no region # changed "
       ]
   ]      " end of the w(np) > 0 case   "

   IF(W(NP) < 0.0)
   [  "particle going backward"
      IF(RF2_COLLIMAT<RMIN2_COLLIMAT)
      [
            IF(IU_D=0)[ RETURN; ]  " ustep admitted"
            ELSE
            [
               $GEO_SHIFT_1_(STEP_UNIT);
               USTEP=STEP_UNIT;
               IF(N_GAP_COLLIMAT = 1)
               [ IRNEW =IREND_COLLIMAT; RETURN; ]
               ELSE[ CALL WHERE_AM_I(ICM_COLLIMAT,-1); RETURN; ]
            ]
      ]
      ELSE   " answer the question: hits side wall or not and where ?
      [
           DO J=I, 1, -1
           [  ;COLLIMAT_MACRO_1_IN(1,ZCORNER_COLLIMAT(J),-1); ]
           IF(IU_D=1)
           [
               $GEO_SHIFT_1_(DIST);
               USTEP=DIST;
               IF(N_GAP_COLLIMAT = 1)
               [ IRNEW =IREND_COLLIMAT; RETURN; ]
               ELSE[ CALL WHERE_AM_I(ICM_COLLIMAT,-1); RETURN; ]
           ]
           ELSE[ RETURN; ] " ustep admitted and no region # changed "
      ]
   ]      " end of the w(np) < 0 case   "

   ELSE   " w(np) = 0 case "
   [
        J=I-1;  " no change in z direction, do not need loop
        RV_COLLIMAT=RCORNER_COLLIMAT(J)
               +SURPARA_COLLIMAT(J,4)*(Z(NP)-ZCORNER_COLLIMAT(J));
        RV2_COLLIMAT=RV_COLLIMAT**2;
        RF2_COLLIMAT=(X(NP)+USTEP*U(NP))**2+(Y(NP)+USTEP*V(NP))**2;
        IF(RF2_COLLIMAT<RV2_COLLIMAT) [ RETURN; ]
                        " ustep admitted , no region # changed "
        ELSE     " solve the equ to get the max ustep  "
        [
           R0DELR=X(NP)*U(NP)+Y(NP)*V(NP);
           DELRSQ=U(NP)*U(NP)+V(NP)*V(NP);
           CUT_COE=(SQRT(R0DELR*R0DELR+DELRSQ*(RV2_COLLIMAT-R0SQ))-R0DELR)/
                   DELRSQ;
           IF(CUT_COE>0.0 & CUT_COE<= USTEP)
           [
               $GEO_SHIFT_1_(CUT_COE);
               USTEP=CUT_COE;
               IRNEW=IRSTART_COLLIMAT+1;RETURN;
           ]
           ELSE[IRNEW=IRSTART_COLLIMAT+1; RETURN;]  " ustep admitted "
        ]
   ]   " end of the w(np) =0 case  "
]

ELSEIF(IR_COLLIMAT = 2)
[ "particle in region 2
   IF(W(NP) > 0.0)
   [  "particle going forward"
       " answer the question: hits side wall or not and where ?
      DO J=I-1, NUM_NODE_COLLIMAT-1
      [  ;COLLIMAT_MACRO_1_OUT(0,ZCORNER_COLLIMAT(J+1),1);  ]
      IF(IU_D=1)
      [
          $GEO_SHIFT_1_(DIST);
          USTEP=DIST;
          CALL WHERE_AM_I(ICM_COLLIMAT,1);
          RETURN;
      ]
      ELSE[ RETURN; ] " ustep admitted and no region # changed "
   ]      " end of the w(np) > 0 case   "

   IF(W(NP) < 0.0) [  "particle going backward"
      DO J=I, 1, -1
      [  ;COLLIMAT_MACRO_1_OUT(0,ZCORNER_COLLIMAT(J),-1);  ]
      IF(IU_D=1)
      [
         $GEO_SHIFT_1_(DIST);
         USTEP=DIST;
         IF(N_GAP_COLLIMAT = 1)
         [ IRNEW =IREND_COLLIMAT; RETURN; ]
         ELSE[ CALL WHERE_AM_I(ICM_COLLIMAT,-1); RETURN; ]
      ]
      ELSE[ RETURN; ] " ustep admitted and no region # changed "
   ]      " end of the w(np) < 0 case   "

   ELSE   " w(np) = 0 case "
   [
        J=I-1;
        RV_COLLIMAT=RCORNER_COLLIMAT(J)
               +SURPARA_COLLIMAT(J,4)*(Z(NP)-ZCORNER_COLLIMAT(J));
        RV2_COLLIMAT=RV_COLLIMAT**2;
        " solve the equ to get the max ustep  "
        R0DELR=X(NP)*U(NP)+Y(NP)*V(NP);
        DELRSQ=U(NP)*U(NP)+V(NP)*V(NP);
        IF (R0DELR*R0DELR+DELRSQ*(RV2_COLLIMAT-R0SQ) < 0.) [RETURN;]
        CUT_COE=(-SQRT(R0DELR*R0DELR+DELRSQ*(RV2_COLLIMAT-R0SQ))-R0DELR)/
                   DELRSQ;
        IF(CUT_COE>0.0 & CUT_COE<= USTEP)
        [
          $GEO_SHIFT_1_(CUT_COE);
          USTEP=CUT_COE;
          IRNEW = IRSTART_COLLIMAT; RETURN;
        ]
          ELSE[ RETURN;]   " USTEP ADMITTED
    ]   " end of the w(np) =0 case  "
]


ELSEIF(IR_COLLIMAT = 3)
["particle in region 3
   IF(W(NP) > 0.0)
   ["particle going backward"
      IF(DIST <= USTEP )
      ["particle to be moved to region boundary
         $GEO_SHIFT_1_(DIST);
         USTEP = DIST;
         IF( ( (X(NP)+DIST*U(NP))**2+(Y(NP)+DIST*V(NP))**2)
             <=RCORNER2_COLLIMAT(1) )
         [  IRNEW =IRSTART_COLLIMAT; RETURN;]
         ELSE[IRNEW =IRSTART_COLLIMAT+1; RETURN;]

      ] "end of particle going forward
      ELSE[ RETURN;]
   ]
   ELSEIF(W(NP) < 0.0)
   ["particle going backward"
      IF(DIST <= USTEP )
      ["particle to be moved to region boundary
         $GEO_SHIFT_1_(DIST);
         USTEP = DIST;
         CALL WHERE_AM_I(ICM_COLLIMAT,-1);
         RETURN;
      ]
      ELSE[RETURN;]
   ] " end of going backward"
] " end of region 3

ELSE
["something is wrong"
   OUTPUT IR(NP)-IRSTART_COLLIMAT+1, IR(NP), ICM_COLLIMAT,
          IR_start_CM(ICM_COLLIMAT);
      (//' ************'//' HOWFAR_COLLIMAT error'/
         '    Region, local, absolute =',2I5/
         '    CM number=',I5,' start region =',I5/
         ' *********'//);
   STOP;
] "end of IF statement"
RETURN;
END; "End of subroutine HOWFAR_COLLIMAT"
%E   "CONS3R_cm - start of subroutine WHERE_AM_I_COLLIMAT"
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_CONS3R
"                          ***************************
"
" WHERE_AM_I_COLLIMAT determines the new region number when a particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_COLLIMAT subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_COLLIMAT from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************

;SUBROUTINE WHERE_AM_I_COLLIMAT(IDIR);


;IMPLICIT NONE;
;COMIN/CM_COLLIMAT,EPCONT,STACK/;
"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_CONS3R
"T>**************************************
"T>
INTEGER IDIR;  "T>direction of particle, +1=forward, -1=backward
$REAL XBDY_COLLIMAT,YBDY_COLLIMAT,RBDY2_COLLIMAT;

XBDY_COLLIMAT = X(NP) + U(NP)*USTEP;      YBDY_COLLIMAT = Y(NP) + V(NP)*USTEP;
RBDY2_COLLIMAT = XBDY_COLLIMAT**2 + YBDY_COLLIMAT**2;
IF((IRSTART_COLLIMAT = 2) & (IDIR =1))    " this is first CM and from front
[  RBDY2_COLLIMAT = X(NP)*X(NP) + Y(NP)*Y(NP); ]
IF (IDIR=1)
["particle entering this CM through front face (upstream)
   IF(N_GAP_COLLIMAT = 0)
   ["no air gap this CM"
      IF(RBDY2_COLLIMAT < RCORNER2_COLLIMAT(1)) [ IRNEW = IRSTART_COLLIMAT;]
      ELSE[ IRNEW = IRSTART_COLLIMAT + 1; ]
   ]
   ELSE ["this CM has air gap at front" IRNEW = IREND_COLLIMAT; ]
]
ELSE
["particle entering this CM through back face (downstream)
   IF(RBDY2_COLLIMAT < RCORNER2_COLLIMAT(NUM_NODE_COLLIMAT))
   [ IRNEW = IRSTART_COLLIMAT; ]
   ELSE[  IRNEW = IRSTART_COLLIMAT + 1; ]
]
RETURN;
END; "End of subroutine WHERE_AM_I_COLLIMAT"
%E   "CONS3R_cm - start of subroutine INPUT_COLLIMAT"
"*******************************************************************************
"
"                           Subroutine INPUT_CONS3R
"                           **********************
"
"  A CM input subroutine for a series of truncated cones.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_COLLIMAT;


;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_COLLIMAT,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;
"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_CONS3R
"T>*********************************
"T>
$REAL ZTHICK_COLLIMAT;      "T>thickness of  the CM

INTEGER I,J,               "T>DO loop indeces
        IRA,               "T>Absolute region number
        MED_FLAG,          "T>flag used by media-sort macro $MED_INPUT
        MED_INDEX,         "T>medium index, set after medium sort by $MED_INPUT
        IREJCTIN;          "T>possible override of global IREJCT_GLOBAL value
"
"  initialize parameters
"  =====================
"
N_COLLIMAT = 2;           "No. of regions in CM (if 3,including front air gap)
ICM_COLLIMAT = ICM;       "CM index for this component module
IRSTART_COLLIMAT = IR_start_CM(ICM_COLLIMAT); "Index of first region in this CM,
                                      "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_COLLIMAT) = 0; "Geometry-checking flag, 0 if no error detected
COUNT1_COLLIMAT=0; "start of error counter at 0"

"
"  get the title line
"  ==================
"
OUTPUT;(/' COLLIMAT (CONS3R)');
OUTPUT;(/' This component is a set of stacked cones with 3 regions ')
OUTPUT RMAX_CM(ICM);('    Outer boundary is a cylinder of radius',F12.3,' cm');
IF(ICM = 1)["first CM"
   OUTPUT Z_min_CM(1);
   (' This is first component -- starts at',F10.4,' cm from z=0 ref plane');
]
ELSE["there is another CM upstream"
   OUTPUT Z_min_CM(ICM);(' This CM starts at back of previous CM at',
          F12.5,' cm');
]
OUTPUT;(' TITLE: ',$);
;MINPUT (COLLIMAT) TITLE_COLLIMAT;(60A1);
               ";MINPUT is a replacement macro with EOF and
               "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_COLLIMAT;(' ',60A1); "OUTPUT is a replacement macro which writes to
                             "unit 5.  Used here for echo of user input
OUTPUT Z_min_CM(ICM_COLLIMAT);
       (' Air gap/front of this  CM starts at:',F10.4, ' cm');
"
" get distance from reference plane, z=0"
"   =============================
OUTPUT;
   (' Distance from front of cones(not air gap) to z = 0.0 plane: ',$);
;MINPUT (COLLIMAT) ZMIN_COLLIMAT;(F15.0);
OUTPUT ZMIN_COLLIMAT;(F15.5);
IF(Z_min_CM(ICM_COLLIMAT)>ZMIN_COLLIMAT)[
   IF(ICM_COLLIMAT=1)[
      OUTPUT ICM_COLLIMAT, Z_min_CM(ICM_COLLIMAT),ZMIN_COLLIMAT;
       (//' ***WARNING IN CM ',I4,' (CONS3R):'/
          ' Z_min_CM(1) > distance to front of cones'/
          ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
      WRITE(IOUTLIST,100)ICM_COLLIMAT, Z_min_CM(ICM_COLLIMAT),ZMIN_COLLIMAT;
100 FORMAT(//' ***WARNING IN CM ',I4,' (CONS3R):'/
          ' Z_min_CM(1) > distance to front of cones'/
          ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
      Z_min_CM(ICM_COLLIMAT)=ZMIN_COLLIMAT;
    ]
    ELSE[
      OUTPUT ICM_COLLIMAT;
       (//'***ERROR IN CM ',I4,' (CONS3R):'/
          'Overlaps with previous CM'//);
      IERR_GEOM(ICM_COLLIMAT)=IERR_GEOM(ICM_COLLIMAT)+1;
    ]
]
"
"   get  CONS3R geometry information
"   =================================
"
OUTPUT; (' CONS3R total thickness (in cm, excluding front air): ',$);
;MINPUT (COLLIMAT) ZTHICK_COLLIMAT; (F15.0);
OUTPUT ZTHICK_COLLIMAT; (F15.5);
IF(ZTHICK_COLLIMAT<0.0)[
    OUTPUT ICM_COLLIMAT;(//'***ERROR IN CM ',I4,' (CONS3R):'/
                          'ZTHICK < 0.0'//);
    IERR_GEOM(ICM_COLLIMAT)=IERR_GEOM(ICM_COLLIMAT)+1;
]
OUTPUT $NPOINT_COLLIMAT +1;
  (' INPUT THE # OF NODES (VERTICES) DEFINING THE CONES ' /
   ' (1 < # NODES < ',I4,'):',$);
   ;MINPUT (COLLIMAT) NUM_NODE_COLLIMAT; (I5);
   OUTPUT NUM_NODE_COLLIMAT; (I5);
IF(NUM_NODE_COLLIMAT > $NPOINT_COLLIMAT) [
     OUTPUT ICM_COLLIMAT, $NPOINT_COLLIMAT;
           (//'***ERROR IN CM ',I4,' (CONS3R):'/
              '# of nodes input > max. # of nodes allowed',/
              '# of nodes reduced to ',I4,' for now'//);
     NUM_NODE_COLLIMAT=$NPOINT_COLLIMAT;
     IERR_GEOM(ICM_COLLIMAT)=IERR_GEOM(ICM_COLLIMAT)+1;
]
ELSEIF(NUM_NODE_COLLIMAT < 2)[
     OUTPUT ICM_COLLIMAT; (//'***ERROR IN CM ',I4,' (CONS3R):'/
                            '# nodes input < 2',/
                            '# of nodes set to 2 for now'//);
     NUM_NODE_COLLIMAT=2;
     IERR_GEOM(ICM_COLLIMAT)=IERR_GEOM(ICM_COLLIMAT)+1;
]
;OUTPUT NUM_NODE_COLLIMAT;
(' INPUT THE  COORDINATES PAIRS (Z, R) FOR ', I5, ' NODES, ONE PAIR/LINE'/
 ' RECALL THAT Z(i+1) >= Z(i)');
DO I=1,NUM_NODE_COLLIMAT
[
    OUTPUT I;(' INPUT COORDINATES OF NODE',I3, ' AS Z, R: ', $);
    ;MINPUT (COLLIMAT) ZCORNER_COLLIMAT(I), RCORNER_COLLIMAT(I); (2F15.0);
     OUTPUT ZCORNER_COLLIMAT(I), RCORNER_COLLIMAT(I); (2F15.5);
     IF(  ZCORNER_COLLIMAT(1)~=ZMIN_COLLIMAT)[
        "this is done each time but who cares"
        OUTPUT ICM_COLLIMAT, ZMIN_COLLIMAT,ZCORNER_COLLIMAT(1);
     (//' ***WARNING IN CM ',I4,' (CONS3R):'/
     ' Z(1) must =',F15.5,' cm so value changed '/
     ' from',F15.5,' cm'//);
     WRITE(IOUTLIST,101)ICM_COLLIMAT,ZMIN_COLLIMAT,ZCORNER_COLLIMAT(1);
   101 FORMAT(//' ***WARNING IN CM ',I4,' (CONS3R):'/
     ' Z(1) must =',F15.5,' cm so value changed '/
     ' from',F15.5,' cm'//);
      ZCORNER_COLLIMAT(1)=ZMIN_COLLIMAT;
     ]
     IF(I>1)[
       IF(ZCORNER_COLLIMAT(I-1)>ZCORNER_COLLIMAT(I))[
          OUTPUT ICM_COLLIMAT, I, I-1; (//'***ERROR IN CM ',I4,' (CONS3R):'/
                                 'Z(',I4,') < Z(',I4,')'//);
          IERR_GEOM(ICM_COLLIMAT)=IERR_GEOM(ICM_COLLIMAT)+1;
       ]
     ]
     IF (RCORNER_COLLIMAT(I) > RMAX_CM(ICM_COLLIMAT))[
        OUTPUT ICM_COLLIMAT, I; (//'***WARNING IN CM ',I4,' (CONS3R):'/
                               'R(',I4,') > RMAX_CM'//);
        WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (CONS3R):''/
                              ''R('',I4,'') > RMAX_CM''//)')
                         ICM_COLLIMAT, I;
     ]
]
IF(ZCORNER_COLLIMAT(NUM_NODE_COLLIMAT)~=ZMIN_COLLIMAT+ZTHICK_COLLIMAT)[
   IF(ABS(ZCORNER_COLLIMAT(NUM_NODE_COLLIMAT) - (ZMIN_COLLIMAT+ZTHICK_COLLIMAT))
          > 0.001) ["Print message if significant only"
       OUTPUT ICM_COLLIMAT, ZMIN_COLLIMAT+ZTHICK_COLLIMAT,
          ZCORNER_COLLIMAT(NUM_NODE_COLLIMAT);
       (//' ***WARNING IN CM ',I4,' (CONS3R):'/
        ' Last Z must =',F15.5,' cm, so value changed'/
        ' from',F15.5,' cm'//);
       WRITE(IOUTLIST,102)ICM_COLLIMAT, ZMIN_COLLIMAT+ZTHICK_COLLIMAT,
                      ZCORNER_COLLIMAT(NUM_NODE_COLLIMAT);
       102 FORMAT(//' ***WARNING IN CM ',I4,' (CONS3R):'/
            ' Last Z must =',F15.5,' cm, so value changed'/
            ' from',F15.5,' cm'//);
   ]
   ZCORNER_COLLIMAT(NUM_NODE_COLLIMAT) =  ZMIN_COLLIMAT+ZTHICK_COLLIMAT;
]
IF(   ZCORNER_COLLIMAT(1)=ZCORNER_COLLIMAT(2)
    | ZCORNER_COLLIMAT(NUM_NODE_COLLIMAT)=ZCORNER_COLLIMAT(NUM_NODE_COLLIMAT-1))
[  OUTPUT; (/ 1X,79('*')/' NOTE: the input is not economical because of',
      ' 0 thickness regions, please, rearrange it for next run'
      / 1X,79('*'));
]
DO I=1,NUM_NODE_COLLIMAT [ "no negative radius allowed"
   RCORNER_COLLIMAT(I)=ABS(RCORNER_COLLIMAT(I));
]

" get the smallest radius "
RMIN_COLLIMAT=RCORNER_COLLIMAT(1);
DO I=2,NUM_NODE_COLLIMAT [
   RMIN_COLLIMAT=MIN(RCORNER_COLLIMAT(I),RMIN_COLLIMAT);
]
RMIN2_COLLIMAT=RMIN_COLLIMAT**2;

"
"   get ECUT, PCUT, dose scoring zone, LATCH correspondences,
"       IREJCT overrides, material in each region
"   ===============================================================
IRA = IRSTART_COLLIMAT-1;
OUTPUT;(/' For this CM, the inner region is 1, the outer 2');
DO IR_COLLIMAT = 1,N_COLLIMAT["loop through regions to get information"
   IRA = IRA+1;
   ;OUTPUT IR_COLLIMAT,IREJCT_GLOBAL;(' For region',I3,/' ECUT, PCUT(MeV),',
         ' DOSE ZONE (0=> NO DOSE), IREGION_TO_BIT, IREJCT(0=>',I2,
         ' -1=>0)' /' : ',$);
   ;MINPUT (COLLIMAT) ECUT(IRA), PCUT(IRA), DOSE_ZONE(IRA),
           IREGION_TO_BIT(IRA),IREJCTIN; (2F15.0,3I5);
   IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
   IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
   IF(IREJCTIN < 0) [IREJCT(IRA) = 0; "ie can only force it from 1 to 0"]
     OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
            IREGION_TO_BIT(IRA),IREJCTIN; (2F15.5,3I10);
     OUTPUT IR_COLLIMAT;(' material of region ',I3,' ',$);
     ;$MED_INPUT(COLLIMAT); "input character array MED_IN from unit 5,loops
     "through array MEDIA(24,I) to check if medium was previously input.
     "If so, sets MED_INDEX to index of previous medium.  If not,
     "increments NMED and sets MED_INDEX to NMED.
     MED(IRA) = MED_INDEX; " medium of the planar slab
] "end of loop over IR_COLLIMAT"

"
"  parameter definition
"  ====================
"
" define the geometry here:
ZMAX_COLLIMAT = ZMIN_COLLIMAT + ZTHICK_COLLIMAT;

" To calc. the parameters for cone surfaces "
DO I=1, NUM_NODE_COLLIMAT-1
[
    IF(ZCORNER_COLLIMAT(I)=ZCORNER_COLLIMAT(I+1))  " parallel to the xy plane
    [
         SURPARA_COLLIMAT(I,4)=1.0E30;
         SURPARA_COLLIMAT(I,1)=0.0;
         SURPARA_COLLIMAT(I,2)=-1.0;
         SURPARA_COLLIMAT(I,3)=ZCORNER_COLLIMAT(I);
    ]
    ELSE
    [
         SURPARA_COLLIMAT(I,4)=(RCORNER_COLLIMAT(I+1)-RCORNER_COLLIMAT(I))
            /(ZCORNER_COLLIMAT(I+1)-ZCORNER_COLLIMAT(I));
         SURPARA_COLLIMAT(I,1)= 1.0/SQRT(1.0+SURPARA_COLLIMAT(I,4)**2);
         SURPARA_COLLIMAT(I,2)=
              -SURPARA_COLLIMAT(I,4)/ SQRT(1.0+SURPARA_COLLIMAT(I,4)**2);
         SURPARA_COLLIMAT(I,3)=
              (SURPARA_COLLIMAT(I,4)*ZCORNER_COLLIMAT(I)-RCORNER_COLLIMAT(I))
                         /SQRT(1.0+SURPARA_COLLIMAT(I,4)**2);
    ]
]

DO I=1,NUM_NODE_COLLIMAT [
   RCORNER2_COLLIMAT(I)=RCORNER_COLLIMAT(I)**2;
]

ZFRONT_COLLIMAT = Z_min_CM(ICM_COLLIMAT);
"
"establish start of next CM
Z_min_CM(ICM_COLLIMAT+1) = ZMAX_COLLIMAT;
"
"  set up the air gap, if present
"  =========================================
"
"  The air gap has the highest region number in the CM, even though it is at
"  the top of the component module.  This is to allow the assignment of region
"  numbers on input of the parameters of each local region (mainly to assign the
"  medium number of the region).  The air gap is then assigned after all of the
"  CM parameters have been input.
"
"note that if this is the first CM (ICM_COLLIMAT=1) then the gap thickness
"Z_gap_THICK(ICM_COLLIMAT) = 0, which is used as a flag that there is no air gap

Z_gap_THICK(ICM_COLLIMAT) = ZMIN_COLLIMAT - Z_min_CM(ICM_COLLIMAT);
IF (Z_gap_THICK(ICM_COLLIMAT) < = 0.0)
[
   Z_gap_THICK(ICM_COLLIMAT) = 0.;
   N_GAP_COLLIMAT = 0; "no air gap for this CM
]
ELSE
[
   N_GAP_COLLIMAT = 1; "this CM has an air gap
   IRA = IRSTART_COLLIMAT+N_COLLIMAT; "absolute region number of air gap
   MED(IRA) = AIR_INDEX; "medium is nominal air
   ESAVE(IRA)=ESAVE_GLOBAL;
   ECUT(IRA)=ECUTIN;
   PCUT(IRA)=PCUTIN;
   ECUTRR(IRA)=ECUT(IRA);
]
"
"  set up region numbers
"  =====================
"
"  This CM has N_CONS3R+N_GAP_COLLIMAT regions
"
;
IREND_COLLIMAT = (IRSTART_COLLIMAT -1) +N_COLLIMAT+N_GAP_COLLIMAT;
             "Index of last region
NREG = NREG+N_COLLIMAT+N_GAP_COLLIMAT;  "Total number of regions in geometry up
                                "to and including this CM
IF (NREG <= $MXREG) [IR_start_CM(ICM_COLLIMAT+1) = IREND_COLLIMAT+1; ]
                       "have not exceeded maximum region number
                       "Index of first region in next CM:"
ELSE [
      OUTPUT ICM_COLLIMAT,NREG,$MXREG;
      (//'***ERROR IN CM ',I4,' (CONS3R):'/
         I4,' regions requested, only ',I4,' available');
      IERR_GEOM(ICM_COLLIMAT)=IERR_GEOM(ICM_COLLIMAT)+1;
]
"
"  establish CM boundary
"  =====================
RMAX_CM_FLAG(ICM_COLLIMAT) = 1; "put a circular boundary about CM
"
"  establish dose-scoring zones and bit setting for each region
"  ===========================================================================
"
IRA = IRSTART_COLLIMAT-1; "absolute region number"
DO IR_COLLIMAT=1,N_COLLIMAT
["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT); " current maxmum
   "charged particle range rejection parameters
   "
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region
   E_min_out(ICM_COLLIMAT)=ECUT(IRA); "Minimum energy on exit from CM

] "end of loop over IR_COLLIMAT

"   return from INPUT_CONS3R
"   =======================
"
RETURN;

"   error messages
"   ==============
"
:EOF_COLLIMAT:
;OUTPUT ICM;
  (//' *** ERROR *** unexpected end of file reading input for CONS3R--CM',I3);
STOP;

:ERROR_COLLIMAT:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CONS3R--CM',I3);
STOP;

END;  "End of subroutine INPUT_COLLIMAT"
%E   "CONS3R_cm - start of subroutine ISUMRY_COLLIMAT"
"*******************************************************************************
"
"                          Subroutine ISUMRY_CONS3R
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_COLLIMAT;


;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_COLLIMAT,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_CONS3R
"T>**********************************
"T>
INTEGER
   ICOLOUR,    "T>colour of CM for EGS_Windows
   IRA,        "T>absolute region number
   I,J;        "T>DO loop index
$REAL  VOL_COLLIMAT(3), PIL;   "T> region volume
"   Mass of dose zone
"   =================
"
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_COLLIMAT.
"
PIL=3.14159;

"  init. the vol.
/VOL_COLLIMAT(1),VOL_COLLIMAT(2),VOL_COLLIMAT(3)/=0.0; "FOR AIR GAP, IF EXISTs"

" calc. the vol for each region.
IF(N_GAP_COLLIMAT=1) ["there is an air gap"
    VOL_COLLIMAT(3)=PIL*(ZMIN_COLLIMAT-Z_min_CM(ICM_COLLIMAT))
              *RMAX_CM(ICM_COLLIMAT)**2;
]
DO I=1, NUM_NODE_COLLIMAT-1 [
    IF(ZCORNER_COLLIMAT(I)~=ZCORNER_COLLIMAT(I+1) )
    [    VOL_COLLIMAT(1)=VOL_COLLIMAT(1)+
                 PIL/3.0*(ZCORNER_COLLIMAT(I+1)-ZCORNER_COLLIMAT(I))*
                 ( RCORNER_COLLIMAT(I+1)**2 + RCORNER_COLLIMAT(I)**2
                 +RCORNER_COLLIMAT(I+1)*RCORNER_COLLIMAT(I) );
    ]
]
VOL_COLLIMAT(2)=PIL*(ZMAX_COLLIMAT-ZMIN_COLLIMAT)*
                RMAX_CM(ICM_COLLIMAT)**2-VOL_COLLIMAT(1);

IRA = IRSTART_COLLIMAT-1; "absolute region number
DO IR_COLLIMAT=1,N_COLLIMAT+N_GAP_COLLIMAT
["loop over local region number
   IRA = IRA+1;
   IF(DOSE_ZONE(IRA) ~= 0)
   ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+VOL_COLLIMAT(IR_COLLIMAT)*RHOR(IRA);
   ]
] "end of loop over IR_COLLIMAT"

"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"

WRITE(IOUTLIST,110) ICM_COLLIMAT,TITLE_COLLIMAT;
WRITE(IOUTLIST,120) Z_min_CM(ICM_COLLIMAT),RMAX_CM(ICM_COLLIMAT);
IF(N_GAP_COLLIMAT~=0)[
         WRITE(IOUTLIST,124) Z_min_CM(ICM_COLLIMAT),
                             ZCORNER_COLLIMAT(1)-Z_min_CM(ICM_COLLIMAT);
]
IRA = IRSTART_COLLIMAT-1;
WRITE(IOUTLIST,122);
DO I = 1,NUM_NODE_COLLIMAT[
   WRITE(IOUTLIST,123) I, ZCORNER_COLLIMAT(I), RCORNER_COLLIMAT(I);
]
WRITE(IOUTLIST,130);
DO IR_COLLIMAT=1,N_COLLIMAT[
   IRA = IRA+1;
   IF(IR_COLLIMAT=1)[
     IF (MED(IRA)=0)
     ["Medium is vacuum"
      WRITE(IOUTLIST,140) IR_COLLIMAT,'inside',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
            'V','a','c','u','u','m';
     ]
     ELSE
     ["Medium is not vacuum"
      WRITE(IOUTLIST,140) IR_COLLIMAT,'inside',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
   ELSEIF(IR_COLLIMAT=2)[
     IF (MED(IRA)=0)
     ["Medium is vacuum"
      WRITE(IOUTLIST,140) IR_COLLIMAT,'outside',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         'V','a','c','u','u','m';
     ]
     ELSE
     ["Medium is not vacuum"
      WRITE(IOUTLIST,140) IR_COLLIMAT,'outside',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
]

IF(N_GAP_COLLIMAT ~=0)[
   IRA=IRSTART_COLLIMAT+N_COLLIMAT;
      WRITE(IOUTLIST,140) IR_COLLIMAT,'airgap',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      WRITE(IOUTLIST,141)'at top';
]

110 FORMAT(///1X,79('-')/'  Component module',I3,' - stacked truncated',
           ' cones (3 regions CONS3R)'
           /1X,79('-')
           //T5,'Title: ',68A1);
120 FORMAT(/T2,'COLLIMAT geometry parameters:',
           /T2,'--------------------------',
           /T2,'Distance from front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Radius of outer boundary of CM = ',F15.5,' cm');
122 FORMAT(/T2,'node      Z(cm)     r(cm)');
123 FORMAT(T2,I3,F11.3,F10.3);
124 FORMAT(T2,'There is an airgap which starts at Z=',F8.5,' cm and is ',
           F8.5,' cm thick.');
130 FORMAT(/T2,'COLLIMAT region parameters:',
           /T2,'-------------------------',
           /T2,'local  location  electron  photon',
           '  range-rejection   dose  bit  medium'
           /T2,'region            cutoff   cutoff',
           '   level     max    zone  set'
           /T2,'                   (MeV)    (MeV)',
           '   (MeV)    (MeV)');

140 FORMAT(T2,I3,4X,A7,F10.3,F9.3,F8.3,F9.3,I6,I5,3X,9A1);
141 FORMAT(T9,A7);


"   Output representation of this component module to file for EGS_Windows
"   ======================================================================

IF(IWATCH = 4 | IZLAST = 2)
[  "Create a graphics file "
        ICOLOUR=4;
        IF(NUM_NODE_COLLIMAT > 10)
        [ "10 IS THE CURRENT MAX NO OF GROT PTS"
          "THIS IS OK IF THERE ARE LESS THAN 20 PTS; 15 ARE ALLOWED NOW"
          WRITE(IOUTGEOM,201)ICOLOUR,'GROT',0.0,0.0,0.0,0.0,
               (ZCORNER_COLLIMAT(I),
                RCORNER_COLLIMAT(I),I=1,10),0.0,0.0;
          WRITE(IOUTGEOM,201)ICOLOUR,'GROT',0.0,0.0,0.0,0.0,
               (ZCORNER_COLLIMAT(I),
                RCORNER_COLLIMAT(I),I=10,NUM_NODE_COLLIMAT),0.0,0.0;
        ] ELSE [
          WRITE(IOUTGEOM,201)ICOLOUR,'GROT',0.0,0.0,0.0,0.0,
               (ZCORNER_COLLIMAT(I),
               RCORNER_COLLIMAT(I),I=1,NUM_NODE_COLLIMAT),0.0,0.0;
        ]
]"End of graphics output"
201   FORMAT(' ',I1,A4,4(F7.2,','),$NPOINT_COLLIMAT(F7.2,','),
             $NPOINT_COLLIMAT(F7.2,','));

"   end of ISUMRY_CONS3R
"   ===================
"
;RETURN;
END; "end of subroutine ISUMRY_COLLIMAT"
%E   "CONS3R_cm - start of subroutine HOWNEAR_COLLIMAT"
"******************************************************************************
"
"                          Subroutine HOWNEAR_COLLIMAT
"                          ***********************
"
" Returns min. distance to nearest region boundary
" Used to be a macro, but now the macro calls this subroutine.
"
"*******************************************************************************
;SUBROUTINE HOWNEAR_COLLIMAT(DIST);

$IMPLICIT-NONE;

COMIN/CM_COLLIMAT,STACK,CMs/;

$REAL DIST, "T> min. distance to nearest region boundary
      R_COLLIMAT; "T> stores radial position of particle

$INTEGER I_COLLIMAT; "T> looping index"

IR_COLLIMAT = IR(NP) - IRSTART_COLLIMAT + 1;
R_COLLIMAT=SQRT(X(NP)**2+Y(NP)**2);
IF(IR_COLLIMAT = 1) [
    DIST=MIN(   Z(NP)-ZMIN_COLLIMAT,
                ZMAX_COLLIMAT-Z(NP),
                RMAX_CM(ICM_COLLIMAT) -R_COLLIMAT );
    DO I_COLLIMAT=1, NUM_NODE_COLLIMAT-1
     [
       DIST=MIN(DIST, ABS(SURPARA_COLLIMAT(I_COLLIMAT,1)*R_COLLIMAT
            +SURPARA_COLLIMAT(I_COLLIMAT,2)*Z(NP)
            +SURPARA_COLLIMAT(I_COLLIMAT,3)) );
     ]
]
ELSEIF(IR_COLLIMAT = 2) [
         DIST=MIN( Z(NP)-ZMIN_COLLIMAT,ZMAX_COLLIMAT-Z(NP),
            RMAX_CM(ICM_COLLIMAT) -R_COLLIMAT  );
         DO I_COLLIMAT=1, NUM_NODE_COLLIMAT-1
         [
            DIST=MIN(DIST, ABS(SURPARA_COLLIMAT(I_COLLIMAT,1)*R_COLLIMAT
               +SURPARA_COLLIMAT(I_COLLIMAT,2)*Z(NP)
                +SURPARA_COLLIMAT(I_COLLIMAT,3)) );
         ]
]
ELSE [
        DIST=0.0;
]
RETURN;
END; "End of subroutine HOWNEAR_COLLIMAT"
"*******************************************************************************
"End of CONS3R_cm.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: stack of conical geometries               "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Geoff Zhang                                               "
"                   Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code originally evolved from the CONS component module written by     "
"  George Ding, starting in 1992, and subsequently edited by Charlie Ma.      "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             ************               ""toc:
"                             *          *               ""toc:
"                             * CONESTAK *               ""toc:
"                             *          *               ""toc:
"                             ************               ""toc:
"
"   See sccs for history of modifications
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.  primary collimator (cone geormetry of
"   arbitrary thickness, angle and material in and out).
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator: primary collimator
"
"I>
"I> Geometry of CONESTAK:                              ""toc:
"I> ******************
"I>                                       |
"I>                                       |  beam direction
"I>                                       |
"I>                                      \|/
"I>
"I>                  ----------------------------------------------
"I>                               Air gap IR = N+1 if exist
"I>                  ----------------------------------------------
"I>                  |               /        \                  |
"I>          IR = 3  |    IR = 2    / IR = 1   \  IR = 2         | IR = 3
"I>                  |             /            \                |
"I>                  |            /              \               |
"I>      outer wall  |-------------------------------------------|
"I>                  |          /                  \             |
"I>                  |         /   IR = 3*(I-1)+1   \IR=3(I-1)+2 |IR=3(I-1)+3
"I>                  |        /                      \           |
"I>                  |-------------------------------------------|
"I>                                    .......
"I>
"I>
"I>
"I>   IR is the region number within the CM.  There are three local regions
"I>   shown above.
"I>
"I>
"I>            ------------------------------------------------------
"I>            |          Region              | Description         |
"I>            |------------------------------|---------------------|
"I>            |  absolute      | local       |                     |
"I>            |----------------|-------------|                     |
"I>            |                |             |                     |
"I>            |IRSTART_CONESTAK| IR_CONESTAK |  as shown in above  |
"I>            | +IR_CONESTAK-1 |             |    (1 to 2)         |
"I>            |                |             |                     |
"I>            |                |             |                     |
"I>            ------------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_SCATFOIL
"                      ISUMRY_SCATFOIL
"                      HOWFAR_SCATFOIL
"                      WHERE_AM_I_SCATFOIL
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS/KNOWN BUGS        ""toc:
"                             ***********************
"
"
"*******************************************************************************
;
"
"                               INPUT FROM UNIT 5             ""toc:
"                               *****************             ""toc:
"
"I>
"I>  CARDS CM_SCATFOIL (CONESTAK)
"I>  ********************************
"I>
"I>   -1  dummy line to indicate start of CM
"I>
"I>   0  RMAX_CM(ICM_SCATFOIL) (F10.0): Outer radial boundary (cm).
"I>
"I>   1  TITLE_SCATFOIL (60A1):  Title of CM.
"I>
"I>   2  ZMIN_SCATFOIL, RBN_SCATFOIL (2F15.0):
"I>
"I>         ZMIN_SCATFOIL:  Distance from front of first cone to
"I>                          reference plane (Z=0),
"I>         RBN_SCATFOIL:   Inner radius of outer wall
"I>                          (Set to 0 if you do not want an outer wall)
"I>
"I>   3  ISCM_MAX_SCATFOIL (I5): Number of conical layers
"I>
"I>   Repeat 4 once for I=1,ISCM_MAX_SCATFOIL
"I>
"I>   4  ZTHICK_SCATFOIL(I), RMIN_SCATFOIL(I), RMAX_SCATFOIL(I) (3F15.0):
"I>
"I>        ZTHICK_SCATFOIL(I):  Thickness of conical layer.
"I>        RMIN_SCATFOIL(I):    Front radius of conical layer.
"I>        RMAX_SCATFOIL(I):    Back radius of conical layer.
"I>                           Note restrictions:
"I>                           RMAX_SCATFOIL(I)>=RMIN_SCATFOIL(I)
"I>                           RMIN_SCATFOIL(I+1)>=RMAX_SCATFOIL(I)
"I>
"I>   5 and 6 are only required if there is an outer wall (ie RBN_SCATFOIL~=0)
"I>
"I>   5  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT in local region 3 (outer wall):
"I>                                                  (2F15.0,2I5)
"I>
"I>         ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   Dose scoring flag, non-zero to score dose
"I>                      deposited in it
"I>         IREGION_TO_BIT:   Bit setting number for the region
"I>
"I>   6  MED_IN (24A1):  Medium of local region 3
"I>                      used to set MED_INDEX.
"I>
"I>   Repeat 7-10 for each conical layer
"I>
"I>   7  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT in local region 1 (inside cone):
"I>                                                  (2F15.0,2I5)
"I>
"I>         ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   Dose scoring flag, 0 to score dose deposited in it
"I>         IREGION_TO_BIT:   Bit setting number for the region
"I>
"I>   8  MED_IN (24A1):  Medium of local region 1 (inside cone),
"I>                      used to set MED_INDEX
"I>
"I>   9  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT in local region 2 (outside cone):
"I>                                                    (2F15.0,2I5)
"I>
"I>         ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   Dose scoring flag, 0 to score dose deposited in it
"I>         IREGION_TO_BIT:   Bit setting number for the region
"I>
"I>   10  MED_IN (24A1):  Medium of local region 2 (outside of cone),
"I>                       used to set MED_INDEX
"I>   Example
"I>   *******
"I>
"I>  The following input example describes two conical layers.  The first
"I>  layer is a flat-top cone 1.0cm thick, with a radius at the top of 0.8cm
"I>  and a radius at the base of 1.2cm.  The second layer is a cylinder, also
"I>  1.0cm thick, of radius 1.2cm.  The top cone is made of Cu and the bottom
"I>  cylinder is made of Pb.  The entire structure is encircled by a Pb wall
"I>  with inner radius 4cm and outer radius 5cm.
"I>  In both layers, the medium between the cone and the outer wall is H2O.
"I>
"I>  Dose in the Cu cone will be scored in dose zone 1.  Dose in the PB cylinder
"I>  will appear in dose zone 2.  The dose to the encircling PB wall will be in
"I>  zone 3.  And the dose to the water in both layers will be scored in zone 4.
"I>  ECUT and PCUT in all cases is 0.521MeV and 0.01MeV respectively.
"I>
"I>  5.0                   RMAX_CM
"I>  cone and cylinder surrounded by PB wall
"I>  0.0, 4.0
"I>  2
"I>  1.0, 0.8, 1.2
"I>  1.0, 1.2, 1.2
"I>  0.521, 0.01, 3, 0
"I>  PB
"I>  0.521, 0.01, 1, 0
"I>  CU
"I>  0.521, 0.01, 4, 0
"I>  H2O
"I>  0.521, 0.01, 2, 0
"I>  PB
"I>  0.521, 0.01, 4, 0
"I>  H2O
"I>
"
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules
"
"*******************************************************************************

%E   "start of subroutine HOWFAR_SCATFOIL"
"*******************************************************************************
"************************** Component Module CONESTAK **************************
"*******************************************************************************
"
"                          Subroutine HOWFAR_CONESTAK
"                          ***********************
"
" HOWFAR routine for stacked planar media.
"
" Determine if current region number is within component module CONESTAK, and
" if so evaluate DIST, distance to region boundary along current trajectory.
"  USTEP must not exceed DIST.
"
"   There are N_CONESTAK local regions + an air gap (if present):
"
"     local               absolute                       description
"  -----------  --------------------------------------  ----------------------
"  IR_CONESTAK  IR_start_CM(ICM_CONESTAK)+IR_CONESTAK-1 excluding front air gap
" ------------  --------------------------------------  -----------------------
"   Geometrical co-ordinates, as set in INPUT_CONESTAK are:
"
"   ZFRONT_CONESTAK     front of CM (upstream surface, air region)
"   ZMIN_CONESTAK       front of cone
"   ZBACK_CONESTAK      back of cone
"   RMAX_CONESTAK       radius of bottom conical layer (largest)
"
"******************************************************************************
;SUBROUTINE HOWFAR_SCATFOIL;


;IMPLICIT NONE;
;COMIN/ CMs,CM_SCATFOIL,EPCONT,STACK,SCORE,EGS-IO/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_CONESTAK
"T>**********************************
"T>
INTEGER
   IRNEW_SCATFOIL, "T>tentative new region number within CM (absolute)
   IB_SCATFOIL,    "T>index to deal with round off errors (=1,2 in region 1,2)
   IHIT;            "T>Index for hit(=1) or not (=0)

$REAL
   DIST,           "T>distance to region boundary along current trajectory
   XF_SCATFOIL,   "T>temporary variable
   YF_SCATFOIL,   "T>temporary variable
   ZF_SCATFOIL,   "T>temporary variable
   TCON_SCATFOIL, "T>temporary variable
   SQXY_SCATFOIL;
$REAL
   AUP_SCATFOIL, CUP_SCATFOIL,  TQ_SCATFOIL,
   A_SCATFOIL,   B_SCATFOIL,    B2_SCATFOIL,
   C_SCATFOIL,   COUT_SCATFOIL, RAD_SCATFOIL,
   BUP_SCATFOIL, DUP_SCATFOIL,  T1_SCATFOIL,
   T2_SCATFOIL,  I1,  I2;
$REAL one;
parameter (one = 1);

;
" Determine local region number
"
" This replacement macros sets DMIN_SCATFOIL as well as defining IR_SCATFOIL
;SCATFOIL_CM_HOWNEAR(DNEAR(NP));

" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module CONESTAK,
" and if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
;
IF(IR_SCATFOIL = 3*ISCM_MAX_SCATFOIL + 1) [ "particle in front air gap
   IF(W(NP) > 0.0) ["particle going forward"
      DIST = (ZMIN_SCATFOIL(1) - Z(NP))/W(NP); "distance to front of SCM
      IRNEW_SCATFOIL = IRSTART_SCATFOIL;
      ;;SCATFOIL_GET_SQXY(DIST,SQXY_SCATFOIL);
      IF(SQXY_SCATFOIL > RBN2_SCATFOIL)[
         IRNEW_SCATFOIL = IRSTART_SCATFOIL + 2;
      ]
      ELSEIF(SQXY_SCATFOIL > RMIN2_SCATFOIL(1))[
         IRNEW_SCATFOIL = IRSTART_SCATFOIL + 1;
      ]
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         IRNEW = IRNEW_SCATFOIL; "new region number"
      ]
   ] "end of particle going forward
   ELSEIF(W(NP) < 0.0) ["particle going backward"
      DIST = (ZFRONT_SCATFOIL - Z(NP))/W(NP); "distance to front of CM
      IF(DIST<=0.)[DIST=1.E-16;]"see SLABS_cm.mortran for explanation"
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         CALL WHERE_AM_I(ICM_SCATFOIL,-1);
      ]
   ] " end of going backward"
] " end of region of air gap
ELSEIF(IR_SCATFOIL = 3*(ISCM_SCATFOIL-1)+1)[   "local region 1
   IB_SCATFOIL=1;
   ;;SCATFOIL_CHECK_RIN(ISCM_SCATFOIL,IB_SCATFOIL);
   IF(W(NP) > 0.0) [  "particle going forward"
      DIST = (ZMAX_SCATFOIL(ISCM_SCATFOIL) - Z(NP))/W(NP);
                  "distance to back of this SCM
      IF(DIST < 0)[DIST=0.;]
      IF(DIST=0. & ISCM_SCATFOIL=ISCM_MAX_SCATFOIL)[DIST=1.E-16;]
            "see SLABS_cm.mortran for explanation"
      IRNEW_SCATFOIL = 1;
      ;;SCATFOIL_GET_SQXY(DIST,SQXY_SCATFOIL);  "get r**2 on ZMAX_SCATFOIL
      IF(SQXY_SCATFOIL <= RMAX2T_SCATFOIL(ISCM_SCATFOIL,IB_SCATFOIL))[
         IF(ISCM_SCATFOIL ~= ISCM_MAX_SCATFOIL)[
            IF(SQXY_SCATFOIL < RMIN2_SCATFOIL(ISCM_SCATFOIL+1))[
               IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*ISCM_SCATFOIL;
            ]
            ELSE[
               IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*ISCM_SCATFOIL + 1;
            ]
         ]
      ]
      ELSE[
         ;;SCATFOIL_IN_HIT(TCON_SCATFOIL,ISCM_SCATFOIL,IB_SCATFOIL);
          DIST = TCON_SCATFOIL;
          IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*(ISCM_SCATFOIL-1) + 1;
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IF (IRNEW_SCATFOIL = 1) ["leaving CM through back"
            CALL WHERE_AM_I(ICM_SCATFOIL,1);
         ]
         ELSE ["still in this CM
            IRNEW = IRNEW_SCATFOIL; "new region number"
         ]
      ]
   ] "end of particle going forward
   ELSEIF(W(NP) < 0.0) [  "particle going backward"
      DIST = (ZMIN_SCATFOIL(ISCM_SCATFOIL) - Z(NP))/W(NP);
      "distance to back of SCM
      IF(DIST < 0)[DIST=0.;]
      IF(DIST=0. & ISCM_SCATFOIL=1 & N_GAP_SCATFOIL=0)[DIST=1.E-16;]
      ;;SCATFOIL_GET_SQXY(DIST,SQXY_SCATFOIL);  "get r**2 on ZMIN
      IF(SQXY_SCATFOIL > RMIN2T_SCATFOIL(ISCM_SCATFOIL,IB_SCATFOIL) )[
         ;;SCATFOIL_IN_HIT(TCON_SCATFOIL,ISCM_SCATFOIL,IB_SCATFOIL);
         DIST = TCON_SCATFOIL;
         IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*(ISCM_SCATFOIL-1) + 1;
      ]
      ELSE[
         IF(ISCM_SCATFOIL = 1)[
            IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*ISCM_MAX_SCATFOIL;
                         "air gap region
            IF(N_GAP_SCATFOIL = 0)[IRNEW_SCATFOIL = 1;]
         ]
         ELSE[ " ISCM_SCATFOIL > 1
            ;;SCATFOIL_GET_SQXY(DIST,SQXY_SCATFOIL);
            IF(SQXY_SCATFOIL < RMAX2_SCATFOIL(ISCM_SCATFOIL-1))[
               IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*(ISCM_SCATFOIL-2);
            ]
            ELSE[
               IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*(ISCM_SCATFOIL-2) + 1;
            ]
         ]
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IF(IRNEW_SCATFOIL = 1) ["leaving CM through front"
            CALL WHERE_AM_I(ICM_SCATFOIL,-1);
         ]
         ELSE ["still in CM, entering another region"
            IRNEW = IRNEW_SCATFOIL; "new region number"
         ]
      ]
   ] " end of going backward"
   ELSE[  "particle W=0
      ;;SCATFOIL_IN_HIT(TCON_SCATFOIL,ISCM_SCATFOIL,IB_SCATFOIL);
      DIST = TCON_SCATFOIL;
      IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*(ISCM_SCATFOIL-1) + 1;
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IRNEW = IRNEW_SCATFOIL; "new region number"
      ]
   ] " end of W=0
] " end of region 1
ELSEIF(IR_SCATFOIL = 3*(ISCM_SCATFOIL-1)+2)[ "particle in region 2
   IB_SCATFOIL=2;   " =2 in region 2
   ;;SCATFOIL_CHECK_ROUT(ISCM_SCATFOIL,IB_SCATFOIL);
   IF(W(NP) > 0.0) [  "particle going forward"
      DIST = (ZMAX_SCATFOIL(ISCM_SCATFOIL) - Z(NP))/W(NP);
                             "distance to back of SCM
      IF(DIST < 0)[DIST=0.;]
      IF(DIST=0. & ISCM_SCATFOIL=ISCM_MAX_SCATFOIL)[DIST=1.E-16;]
      ;;SCATFOIL_OUT(IHIT,TCON_SCATFOIL,ISCM_SCATFOIL,IB_SCATFOIL);
      IF(IHIT = 1)[
         ZF_SCATFOIL = Z(NP) + TCON_SCATFOIL * W(NP);
         IF(ZF_SCATFOIL < ZMAX_SCATFOIL(ISCM_SCATFOIL) &
            ZF_SCATFOIL > ZMIN_SCATFOIL(ISCM_SCATFOIL))[
            DIST = TCON_SCATFOIL;
            IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*(ISCM_SCATFOIL-1);
         ]
         ELSE[
            ;;SCATFOIL_GET_SQXY(DIST,SQXY_SCATFOIL);
            "get r**2 on ZMAX_SCATFOIL
            IF(ISCM_SCATFOIL < ISCM_MAX_SCATFOIL)[
               IF(SQXY_SCATFOIL < RMIN2_SCATFOIL(ISCM_SCATFOIL+1))[
                  IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*ISCM_SCATFOIL;
               ]
               ELSEIF(SQXY_SCATFOIL < RBN2T_SCATFOIL(IB_SCATFOIL))[
                  IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*ISCM_SCATFOIL + 1;
               ]
               ELSE[
                  IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*ISCM_SCATFOIL + 1;
                  ;;SCATFOIL_IN_HIT_CYL(TCON_SCATFOIL,IB_SCATFOIL);
                  DIST = TCON_SCATFOIL;
                  IRNEW_SCATFOIL = IRSTART_SCATFOIL +
                                   3*(ISCM_SCATFOIL-1) + 2;
               ]
            ]
            ELSE[ "ISCM_SCATFOIL = ISCM_MAX_SCATFOIL)
               IRNEW_SCATFOIL = 1;
               IF(SQXY_SCATFOIL > RBN2T_SCATFOIL(IB_SCATFOIL))[
                  ;;SCATFOIL_IN_HIT_CYL(TCON_SCATFOIL,IB_SCATFOIL);
                  DIST = TCON_SCATFOIL;
                  IRNEW_SCATFOIL = IRSTART_SCATFOIL +
                                     3*(ISCM_SCATFOIL-1) + 2;
               ]
            ]
         ]
      ]
      ELSE[ "IHIT = 0
         ;;SCATFOIL_GET_SQXY(DIST,SQXY_SCATFOIL);  "get r**2 on ZMAX_SCATFOIL
         IF(ISCM_SCATFOIL < ISCM_MAX_SCATFOIL)[
            IF(SQXY_SCATFOIL < RMIN2_SCATFOIL(ISCM_SCATFOIL+1))[
               IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*ISCM_SCATFOIL;
            ]
            ELSEIF(SQXY_SCATFOIL < RBN2T_SCATFOIL(IB_SCATFOIL))[
               IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*ISCM_SCATFOIL + 1;
            ]
            ELSE[
               IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*ISCM_SCATFOIL + 1;
               ;;SCATFOIL_IN_HIT_CYL(TCON_SCATFOIL,IB_SCATFOIL);
               DIST = TCON_SCATFOIL;
               IRNEW_SCATFOIL = IRSTART_SCATFOIL +
                                   3*(ISCM_SCATFOIL-1) + 2;
            ]
         ]
         ELSE[ "ISCM_SCATFOIL = ISCM_MAX_SCATFOIL)
            IRNEW_SCATFOIL = 1;
            IF(SQXY_SCATFOIL > RBN2T_SCATFOIL(IB_SCATFOIL))[
               ;;SCATFOIL_IN_HIT_CYL(TCON_SCATFOIL,IB_SCATFOIL);
                DIST = TCON_SCATFOIL;
                IRNEW_SCATFOIL = IRSTART_SCATFOIL +
                                    3*(ISCM_SCATFOIL-1) + 2;
            ]
         ]
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IF( IRNEW_SCATFOIL = 1 )["leaving CM through back"
            CALL WHERE_AM_I(ICM_SCATFOIL,1);
         ]
         ELSE ["still in CM, entering region 2 or 3"
            IRNEW = IRNEW_SCATFOIL; "new region number"
         ]
      ]
   ] " end of particle going forward"
   ELSEIF(W(NP) < 0.0) [  "particle going backward"
      DIST = (ZMIN_SCATFOIL(ISCM_SCATFOIL) - Z(NP))/W(NP);
                                  "distance to back of SCM
      IF(DIST < 0)[DIST=0.;]
      IF(ISCM_SCATFOIL = 1)[
         ;;SCATFOIL_OUT(IHIT,TCON_SCATFOIL,ISCM_SCATFOIL,IB_SCATFOIL);
         IF (IHIT = 0 & DIST=0.)[
            IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*ISCM_MAX_SCATFOIL;
         ]
         ELSEIF(IHIT = 1)[
            ZF_SCATFOIL = Z(NP) + TCON_SCATFOIL * W(NP);
            IF(ZF_SCATFOIL > ZMIN_SCATFOIL(ISCM_SCATFOIL) &
               ZF_SCATFOIL < ZMAX_SCATFOIL(ISCM_SCATFOIL))[
               DIST = TCON_SCATFOIL;
               IRNEW_SCATFOIL = IRSTART_SCATFOIL;
            ]
            ELSE[
               IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*ISCM_MAX_SCATFOIL;
            ]
         ]
         ELSE[ " IHIT = 0
            IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*ISCM_MAX_SCATFOIL;
            "assume we will just exit through top or enter airgap at top"
            ;;SCATFOIL_GET_SQXY(DIST,SQXY_SCATFOIL);
                       "get r**2 on ZMIN_SCATFOIL
            IF(SQXY_SCATFOIL > RBN2T_SCATFOIL(IB_SCATFOIL))[
               ;;SCATFOIL_IN_HIT_CYL(TCON_SCATFOIL,IB_SCATFOIL);
               IF(TCON_SCATFOIL*W(NP)+Z(NP) > ZMIN_SCATFOIL(ISCM_SCATFOIL) &
                  TCON_SCATFOIL*W(NP)+Z(NP) < ZMAX_SCATFOIL(ISCM_SCATFOIL))[
                  DIST = TCON_SCATFOIL;
                  IRNEW_SCATFOIL = IRSTART_SCATFOIL +
                        3*(ISCM_SCATFOIL-1) + 2;
               ]
            ]
         ]
         IF(IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*ISCM_MAX_SCATFOIL &
            N_GAP_SCATFOIL=0 & DIST=0.)[DIST=1.0E-16;]
                          "make sure it goes into prev. CM"
      ]
      ELSE[ " ISCM > 1
         ;;SCATFOIL_OUT(IHIT,TCON_SCATFOIL,ISCM_SCATFOIL,IB_SCATFOIL);
         IF(IHIT = 1)[
            ZF_SCATFOIL = Z(NP) + TCON_SCATFOIL * W(NP);
            IF(ZF_SCATFOIL > ZMIN_SCATFOIL(ISCM_SCATFOIL) &
               ZF_SCATFOIL < ZMAX_SCATFOIL(ISCM_SCATFOIL))[
               DIST = TCON_SCATFOIL;
               IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*(ISCM_SCATFOIL -1);
            ]
            ELSE[
               ;;SCATFOIL_GET_SQXY(DIST,SQXY_SCATFOIL);
               IF(SQXY_SCATFOIL < RBN2T_SCATFOIL(IB_SCATFOIL))[
                  IRNEW_SCATFOIL = IRSTART_SCATFOIL +
                                    3*(ISCM_SCATFOIL-2) + 1;
               ]
               ELSEIF(SQXY_SCATFOIL > RBN2T_SCATFOIL(IB_SCATFOIL))[
                  IRNEW_SCATFOIL = IRSTART_SCATFOIL +
                                    3*(ISCM_SCATFOIL-2) + 1;
                  ;;SCATFOIL_IN_HIT_CYL(TCON_SCATFOIL,IB_SCATFOIL);
                   DIST = TCON_SCATFOIL;
                   IRNEW_SCATFOIL = IRSTART_SCATFOIL +
                                    3*(ISCM_SCATFOIL-1) + 2;
               ]
            ]
         ]
         ELSE[ " IHIT = 0
            ;;SCATFOIL_GET_SQXY(DIST,SQXY_SCATFOIL);
                  "get r**2 on ZMIN_SCATFOIL
            IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*(ISCM_SCATFOIL-2) + 1;
            IF(SQXY_SCATFOIL > RBN2T_SCATFOIL(IB_SCATFOIL))[
               ;;SCATFOIL_IN_HIT_CYL(TCON_SCATFOIL,IB_SCATFOIL);
               DIST = TCON_SCATFOIL;
               IRNEW_SCATFOIL = IRSTART_SCATFOIL +
                                    3*(ISCM_SCATFOIL-1) + 2;
            ]
         ]
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IF(N_GAP_SCATFOIL = 0 )[ "leaving CM through front"
            IF(IRNEW_SCATFOIL => IRSTART_SCATFOIL + 3*ISCM_MAX_SCATFOIL) [
               CALL WHERE_AM_I(ICM_SCATFOIL,-1);
            ]
            ELSE ["still in CM, entering another region"
               IRNEW = IRNEW_SCATFOIL; "new region number"
            ]
         ]
         ELSE [ "still in CM, entering another region
            IRNEW = IRNEW_SCATFOIL; "new region number"
         ]
      ]
   ] " end of particle going bachward"
   ELSE [  "particle W=0
      ;;SCATFOIL_OUT(IHIT,TCON_SCATFOIL,ISCM_SCATFOIL,IB_SCATFOIL);
      IF(IHIT = 1)[
         DIST = TCON_SCATFOIL;
         IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*(ISCM_SCATFOIL-1);
      ]
      ELSE[
         ;;SCATFOIL_IN_HIT_CYL(TCON_SCATFOIL,IB_SCATFOIL);
         DIST = TCON_SCATFOIL;
         IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*(ISCM_SCATFOIL-1) + 2;
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IRNEW = IRNEW_SCATFOIL; "new region number"
      ]
   ] " end of particle W=0"
] " end of region 2
ELSEIF(IR_SCATFOIL = 3*(ISCM_SCATFOIL-1)+3) ["particle in region 3
IB_SCATFOIL = 1;
   IF(W(NP) > 0.0)[
      DIST = (ZMAX_SCATFOIL(ISCM_SCATFOIL) - Z(NP))/W(NP);
                        "distance to back of SCM
      IF(DIST < 0)[DIST=0.;]
      IF(DIST=0. & ISCM_SCATFOIL=ISCM_MAX_SCATFOIL)[DIST=1.E-16;]
      IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*ISCM_SCATFOIL + 2;
      IF(ISCM_SCATFOIL = ISCM_MAX_SCATFOIL)[IRNEW_SCATFOIL = 1;]
      IF(U(NP)*X(NP)+V(NP)*Y(NP) < 0)[
         ;;SCATFOIL_OUT_CYL(IHIT,TCON_SCATFOIL,IB_SCATFOIL);
         IF(IHIT = 1)[
            ZF_SCATFOIL = Z(NP) + TCON_SCATFOIL * W(NP);
            IF(ZF_SCATFOIL < ZMAX_SCATFOIL(ISCM_SCATFOIL)&
               ZF_SCATFOIL > ZMIN_SCATFOIL(ISCM_SCATFOIL))[
               IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*(ISCM_SCATFOIL-1) + 1;
               DIST = TCON_SCATFOIL;
            ]
         ]
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IF(IRNEW_SCATFOIL = 1 )[ "leaving CM through front"
            CALL WHERE_AM_I(ICM_SCATFOIL,1);
         ]
         ELSE [ "still in CM, entering another region
            IRNEW = IRNEW_SCATFOIL; "new region number"
         ]
      ]
   ] " end of particle going forward"
   ELSEIF(W(NP) < 0.0)[

      DIST = (ZMIN_SCATFOIL(ISCM_SCATFOIL) - Z(NP))/W(NP);
                   "distance to front of SCM
      IF(DIST < 0)[DIST=0.;]
      IF(DIST=0. & N_GAP_SCATFOIL = 0 & ISCM_SCATFOIL = 1)[DIST=1.E-16;]
      IF(ISCM_SCATFOIL = 1)[
         IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*ISCM_MAX_SCATFOIL;
         IF(N_GAP_SCATFOIL = 0)[IRNEW_SCATFOIL = 1;]
         IF(U(NP)*X(NP)+V(NP)*Y(NP) < 0)[
            ;;SCATFOIL_OUT_CYL(IHIT,TCON_SCATFOIL,IB_SCATFOIL);
            IF(IHIT = 1 &
               (Z(NP) + TCON_SCATFOIL * W(NP)) >= ZMIN_SCATFOIL(1) &
               (Z(NP) + TCON_SCATFOIL * W(NP)) <= ZMAX_SCATFOIL(1))[
               DIST = TCON_SCATFOIL;
               IRNEW_SCATFOIL = IRSTART_SCATFOIL + 1;
            ]
         ]
      ]
      ELSE[   "ISCM > 1
         IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*(ISCM_SCATFOIL-2) + 2;
         IF(U(NP)*X(NP)+V(NP)*Y(NP) < 0)[
            ;;SCATFOIL_OUT_CYL(IHIT,TCON_SCATFOIL,IB_SCATFOIL);
            IF(IHIT = 1 &
               (Z(NP) + TCON_SCATFOIL * W(NP)) >=
                 ZMIN_SCATFOIL(ISCM_SCATFOIL) &
               (Z(NP) + TCON_SCATFOIL * W(NP)) <=
                 ZMAX_SCATFOIL(ISCM_SCATFOIL))[
               DIST = TCON_SCATFOIL;
               IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*(ISCM_SCATFOIL-1) + 1;
            ]
         ]
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IF(IRNEW_SCATFOIL = 1)[ "leaving CM through front"
            CALL WHERE_AM_I(ICM_SCATFOIL,-1);
         ]
         ELSE [ "still in CM, entering another region
            IRNEW = IRNEW_SCATFOIL; "new region number"
         ]
      ]
   ] " end of particle going backward"
   ELSE[   " W(NP) = 0.0
      DIST=1E10;
      ;;SCATFOIL_OUT_CYL(IHIT,TCON_SCATFOIL,IB_SCATFOIL);
      IF(IHIT = 1)[
         DIST = TCON_SCATFOIL;
         IRNEW_SCATFOIL = IRSTART_SCATFOIL + 3*(ISCM_SCATFOIL-1) + 1;
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;  "still in CM, entering another region
         IRNEW = IRNEW_SCATFOIL; "new region number"
      ]
   ] " end of particle w=0
]

"   outside of CM, something is wrong
"   =================================
"
ELSE ["something is wrong"
   OUTPUT IR(NP)-IRSTART_SCATFOIL+1,IR(NP),ICM_SCATFOIL,
          IR_start_CM(ICM_SCATFOIL);
      (//' ************'//' HOWFAR_SCATFOIL error'/
         '    Region, local, absolute =',2I5/
         '    CM number=',I5,' start region =',I5/
         ' *********'//);
   STOP;
] "end of IF statement"
;
RETURN;
END; "End of subroutine HOWFAR_SCATFOIL"
%E "start of subroutine WHERE_AM_I_SCATFOIL"
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_SCATFOIL
"                          ***************************
"
" WHERE_AM_I routine for a stacked right cylinder slabs.
"
" WHERE_AM_I_SCATFOIL determines the new region number when a
" particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_SCATFOIL subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_SCATFOIL from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************

;SUBROUTINE WHERE_AM_I_SCATFOIL(IDIR);


REPLACE {$CHECK_FRONT_SCATFOIL;} WITH {;}
REPLACE {$CHECK_BACK_SCATFOIL;} WITH {;}
;IMPLICIT NONE;
;COMIN/CM_SCATFOIL,EPCONT,STACK/;
"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_SCATFOIL
"T>**************************************
"T>
INTEGER IDIR,  "T>direction of particle, +1=forward, -1=backward
           I;  "T>looping index
$REAL XBDY_SCATFOIL,YBDY_SCATFOIL,RBDY2_SCATFOIL;
XBDY_SCATFOIL = X(NP) + U(NP)*USTEP;
YBDY_SCATFOIL = Y(NP) + V(NP)*USTEP;
RBDY2_SCATFOIL = XBDY_SCATFOIL*XBDY_SCATFOIL + YBDY_SCATFOIL*YBDY_SCATFOIL;
IF(IRSTART_SCATFOIL = 2)[ " this is first CM and from front
   IF(IDIR =1)[RBDY2_SCATFOIL = X(NP)**2 + Y(NP)**2;]
]
IF (IDIR=1) ["particle entering this CM through front face (upstream)
   IF(N_GAP_SCATFOIL = 0) ["no air gap this CM"
      IRNEW = IRSTART_SCATFOIL;
      IF(RBDY2_SCATFOIL > RBN2_SCATFOIL)[
         IRNEW = IRSTART_SCATFOIL + 2;
      ]
      ELSEIF(RBDY2_SCATFOIL > RMIN2_SCATFOIL(1))[
         IRNEW = IRSTART_SCATFOIL + 1;
      ]
   ]
   ELSE ["this CM has an air gap at the front
      $CHECK_FRONT_SCATFOIL;
      IRNEW = IREND_SCATFOIL;
   ]
]
ELSEIF (IDIR=-1) ["particle entering this CM through back face (downstream)
   $CHECK_BACK_SCATFOIL;
   IRNEW = IRSTART_SCATFOIL + 3*(ISCM_MAX_SCATFOIL-1);
   IF(RBDY2_SCATFOIL > RBN2_SCATFOIL)[
      IRNEW = IRSTART_SCATFOIL + 3*(ISCM_MAX_SCATFOIL-1) + 2;
   ]
   ELSEIF(RBDY2_SCATFOIL > RMAX2_SCATFOIL(ISCM_MAX_SCATFOIL))[
      IRNEW = IRSTART_SCATFOIL + 3*(ISCM_MAX_SCATFOIL-1) + 1;
   ]
]
ELSEIF (IDIR=2) ["particle originating within the CM (source 3)
   IF(Z(NP)<ZMIN_SCATFOIL(1))["in front air gap
      IRNEW = IREND_SCATFOIL;
   ]
   ELSE[
      DO I=1,ISCM_MAX_SCATFOIL[
         IF(Z(NP)<=ZMAX_SCATFOIL(I) & Z(NP)>=ZMIN_SCATFOIL(I))[
            IRNEW = IRSTART_SCATFOIL + 3*(I-1);
            IF(SQRT(X(NP)**2+Y(NP)**2) > RBN_SCATFOIL)[
               IRNEW = IRSTART_SCATFOIL + 3*(I-1) + 2;
            ]
            ELSEIF(SQRT(X(NP)**2+Y(NP)**2) >
               Z(NP)*ALO_SCATFOIL(I)+BLO_SCATFOIL(I))[
                  IRNEW = IRSTART_SCATFOIL + 3*(I-1) + 1;
            ]
            EXIT;
         ]
      ]
   ]
]
RETURN;
END; "End of subroutine WHERE_AM_I_SCATFOIL"
%E   "start of subroutine INPUT_SCATFOIL"
"*******************************************************************************
"
"                           Subroutine INPUT_SCATFOIL
"                           **********************
"
"  A CM input subroutine for a series of 2 or more semi-infinite slabs.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_SCATFOIL;


;IMPLICIT NONE;
;COMIN/BOUNDS,CMs,CM_SCATFOIL,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;
"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_SCATFOIL
"T>*********************************
"T>
$REAL ZTHICK_SCATFOIL(20),  "T>thickness of cone in this SCM
      BDYTOL,                "T>may set differ from  $BDY_TOL
      AIRGAPMIN_SCATFOIL;   "T>minimum air gap in front and back of CM

INTEGER I,J,            "T>DO loop indeces
        IRA,            "T>Absolute region number
        MED_FLAG,       "T>flag used by media-sort macro $MED_INPUT
        IRA_WALL,       "T> region no tmp
        MED_INDEX_WALL, "T>  medium of wall local
        MED_INDEX;      "T>medium index, set after medium sort by $MED_INPUT
"
"  initialize parameters
"  =====================
"
ICM_SCATFOIL = ICM;      "CM index for this component module
IRSTART_SCATFOIL = IR_start_CM(ICM_SCATFOIL);
                    "Index of first region in this CM,
                    "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_SCATFOIL) = 0; "Geometry-checking flag, 0 if no error detected
AIRGAPMIN_SCATFOIL = 0.1; "set a minimum 0.1 cm air gap at front of CM

"
"  get the title line
"  ==================
"
OUTPUT;(/' Next component is a stacked set of truncated cones ');
OUTPUT;(/' SCATFOIL (CONESTAK)');
IF(ICM_SCATFOIL = 1)[
   OUTPUT Z_min_CM(1);
   (' This is the first component and starts at Z=',F11.4,' cm');
]
ELSE
   [OUTPUT Z_min_CM(ICM_SCATFOIL);
    (' Previous CM ends at:',F12.5,' cm'/);
]
OUTPUT; (' TITLE: ',$);
MINPUT (SCATFOIL) TITLE_SCATFOIL;(60A1);
";MINPUT is a replacement macro with EOF and
          "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_SCATFOIL;(' ',60A1);
"
" get distance from reference plane, z=0"
"   =============================
NOWALL_SCATFOIL = 0;
OUTPUT;
(' Distance front 1st cone to ref plane(z=0), inner radius outer wall(0=>none)'/
 ' : ',$);
MINPUT (SCATFOIL) ZMIN_SCATFOIL(1),RBN_SCATFOIL;(2F15.0);
OUTPUT ZMIN_SCATFOIL(1),RBN_SCATFOIL;(2F25.5);
IF(Z_min_CM(ICM_SCATFOIL)>ZMIN_SCATFOIL(1))[
   IF(ICM_SCATFOIL=1)[
     OUTPUT ICM_SCATFOIL, ZMIN_SCATFOIL(1),Z_min_CM(1);
       (//' ***WARNING IN CM ',I4,' (CONESTAK):'/
        ' Z_min_CM(1) < ZMIN(1)'/
        ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
     WRITE(IOUTLIST,100)ICM_SCATFOIL, ZMIN_SCATFOIL(1),
           Z_min_CM(1);
     100 FORMAT(//' ***WARNING IN CM ',I4,' (CONESTAK):'/
        ' Z_min_CM(1) < ZMIN(1)'/
        ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
     Z_min_CM(1)=ZMIN_SCATFOIL(1);
   ]
   ELSE[
     OUTPUT ICM_SCATFOIL;
       (//'***ERROR IN CM ',I4,' (CONESTAK):'/
          'Overlaps with previous CM'//);
      IERR_GEOM(ICM_SCATFOIL)=IERR_GEOM(ICM_SCATFOIL)+1;
   ]
]
IF(RBN_SCATFOIL = 0) [
   NOWALL_SCATFOIL = 1;
   OUTPUT ZMIN_SCATFOIL(1),RBN_SCATFOIL;(2F25.5,',  No outer wall!!');
]
ELSEIF(RBN_SCATFOIL > RMAX_CM(ICM_SCATFOIL))[
   OUTPUT ICM_SCATFOIL;
     (//'***ERROR IN CM ',I4,' (CONESTAK):'/
       'inner radius of outer wall > RMAX_CM'//);
   IERR_GEOM(ICM_SCATFOIL)=IERR_GEOM(ICM_SCATFOIL)+1;
]
IF(RBN_SCATFOIL = 0) [RBN_SCATFOIL = RMAX_CM(ICM_SCATFOIL); ]
ISCM_MAX_SCATFOIL = $MAX_N_SCATFOIL;
"Maximum number of slab cone permitted
OUTPUT ISCM_MAX_SCATFOIL;
(' NUMBER OF layers (MINIMUM 1, MAXIMUM',I3,'): ',$);
MINPUT (SCATFOIL) ISCM_MAX_SCATFOIL; (I5);
OUTPUT ISCM_MAX_SCATFOIL; (I5);
IF(ISCM_MAX_SCATFOIL > $MAX_N_SCATFOIL)[
   OUTPUT ICM_SCATFOIL, $MAX_N_SCATFOIL;
     (//'***ERROR IN CM ',I4,' (CONESTAK):'/
        '# of layers > max. allowed.'/
        '# of layers reduced to ',I4,' for now.'//);
   IERR_GEOM(ICM_SCATFOIL)=IERR_GEOM(ICM_SCATFOIL)+1;
   ISCM_MAX_SCATFOIL=$MAX_N_SCATFOIL;
]
ELSEIF(ISCM_MAX_SCATFOIL<1)[
   ISCM_MAX_SCATFOIL=1;
   OUTPUT ICM_SCATFOIL;
    (//'***ERROR IN CM ',I4,' (CONESTAK):'/
       '# of layers < 1'/
       '# of layers reset to 1 for now'//);
   IERR_GEOM(ICM_SCATFOIL)=IERR_GEOM(ICM_SCATFOIL)+1;
]
N_SCATFOIL = 3*ISCM_MAX_SCATFOIL;
"Number of regions in this CM (excluding front air gap)
"
"   get  each cone slab geometry information
"   =================================
"
"loop over bars
DO I = 1,ISCM_MAX_SCATFOIL ["loop to get each slab location"
   OUTPUT I;(/' Cone layer No:',I3,
   /' Thickness of conical layer,  top(r1) and  bottom(r2) radii (r1<=r2)'/
   ' : ',$);
   ;MINPUT (SCATFOIL) ZTHICK_SCATFOIL(I),
    RMIN_SCATFOIL(I),RMAX_SCATFOIL(I); (3F15.0);
   OUTPUT ZTHICK_SCATFOIL(I),RMIN_SCATFOIL(I),RMAX_SCATFOIL(I);(3F15.5);
   IF(ZTHICK_SCATFOIL(I) < 0.0)[
      OUTPUT ICM_SCATFOIL, I;
        (//'***ERROR IN CM ',I4,' (CONESTAK):'/
           'ZTHICK(',I4,') < 0.0'//);
      IERR_GEOM(ICM_SCATFOIL)=IERR_GEOM(ICM_SCATFOIL)+1;
   ]
   IF(RMIN_SCATFOIL(I) > RMAX_SCATFOIL(I))[
      OUTPUT ICM_SCATFOIL, I, I;
        (//'***ERROR IN CM ',I4,' (CONESTAK):'/
           'RMIN(',I4,') > RMAX(',I4,')'//);
      IERR_GEOM(ICM_SCATFOIL)=IERR_GEOM(ICM_SCATFOIL)+1;
   ]
   IF(RMIN_SCATFOIL(I)=RMAX_SCATFOIL(I) & RMIN_SCATFOIL(I)<$BDY_TOL)[
      "this will cause problems with region check during run"
      RMIN_SCATFOIL(I)=$BDY_TOL;
      RMAX_SCATFOIL(I)=$BDY_TOL;
      OUTPUT ICM_SCATFOIL, I,$BDY_TOL;
        (//' ***WARNING IN CM ',I4,' (CONESTAK):'/
           ' RMIN=RMAX<$BDY_TOL (BOUNDARY TOLERANCE) IN LAYER ',I4/
           ' THIS CAN CAUSE ENDLESS LOOPS'/
           ' RMIN AND RMAX HAVE BEEN RESET TO ',F8.5//);
      WRITE(IOUTLIST,:WARNLAB1:) ICM_SCATFOIL, I,$BDY_TOL;
:WARNLAB1: FORMAT(//' ***WARNING IN CM ',I4,' (CONESTAK):'/
           ' RMIN=RMAX<$BDY_TOL (BOUNDARY TOLERANCE) IN LAYER ',I4/
           ' THIS CAN CAUSE ENDLESS LOOPS'/
           ' RMIN AND RMAX HAVE BEEN RESET TO ',F8.5//);
   ]
   IF(NOWALL_SCATFOIL=1 & RMIN_SCATFOIL(I)>RMAX_CM(ICM_SCATFOIL))[
      OUTPUT ICM_SCATFOIL, I;
        (//'***WARNING IN CM ',I4,' (CONESTAK):'/
           'RMIN(',I4,') > RMAX_CM'//);
      WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (CONESTAK):''/
           ''RMIN('',I4,'') > RMAX_CM''//)')
            ICM_SCATFOIL, I;
   ]
   IF(NOWALL_SCATFOIL=1 & RMAX_SCATFOIL(I)>RMAX_CM(ICM_SCATFOIL))[
      OUTPUT ICM_SCATFOIL, I;
        (//'***WARNING IN CM ',I4,' (CONESTAK):'/
           'RMAX(',I4,') > RMAX_CM'//);
      WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (CONESTAK):''/
           ''RMAX('',I4,'') > RMAX_CM''//)')
            ICM_SCATFOIL, I;
   ]
   IF(I > 1 & RMAX_SCATFOIL(I-1) > RMIN_SCATFOIL(I))[
      OUTPUT ICM_SCATFOIL, I, I-1;
       (//'***ERROR IN CM ',I4,' (CONESTAK):'/
          'RMIN(',I4,') < RMAX(',I4,')'//);
      IERR_GEOM(ICM_SCATFOIL)=IERR_GEOM(ICM_SCATFOIL)+1;
   ]
]
IF(NOWALL_SCATFOIL = 0 &
    RBN_SCATFOIL < RMAX_SCATFOIL(ISCM_MAX_SCATFOIL))[
    OUTPUT ICM_SCATFOIL;
      (//'***ERROR IN CM ',I4,' (CONESTAK):'/
         'Inner radius of outer wall < max. cone radius.'//);
    IERR_GEOM(ICM_SCATFOIL)=IERR_GEOM(ICM_SCATFOIL)+1;
]

"   get ECUT, PCUT, dose scoring zone, and material in each region
"   ===============================================================
IRA = IRSTART_SCATFOIL-1;
DO IR_SCATFOIL = 1,N_SCATFOIL["loop through regions to get information"
   IRA = IRA+1;
   IF(NOWALL_SCATFOIL = 0 & IR_SCATFOIL = 1)[
      OUTPUT ;(/' For outer wall:'/
' ECUT, PCUT (MeV), DOSE ZONE (0=DO NOT SCORE DOSE), IREGION_TO_BIT'/' : ',$);
     ;MINPUT (SCATFOIL)
      ECUT(IRA+2),PCUT(IRA+2),DOSE_ZONE(IRA+2),IREGION_TO_BIT(IRA+2);
      (2F15.0,2I5);
      IRA_WALL = IRA+2;
      IF(ECUT(IRA+2) < ECUTIN)[ECUT(IRA+2)=ECUTIN;]
      IF(PCUT(IRA+2) < PCUTIN)[PCUT(IRA+2)=PCUTIN;]
      ;OUTPUT ECUT(IRA+2),PCUT(IRA+2),DOSE_ZONE(IRA+2),
             IREGION_TO_BIT(IRA+2);(F10.5,F10.3,I12,I20);
      OUTPUT ;(' Material of outer wall ',$);
     ;$MED_INPUT(SCATFOIL);
            "inputs character array MED_IN from unit 5, loops
     "through array MEDIA(24,I) to check if medium was previously input.
     "If so, sets MED_INDEX to index of previous medium.  If not,
     "increments NMED and sets MED_INDEX to NMED.
      MED(IRA+2) = MED_INDEX; " medium of the planar slab
      MED_INDEX_WALL = MED_INDEX;
   ]
   IF(NOWALL_SCATFOIL = 1 & IR_SCATFOIL = 1)[
         IRA_WALL = IRA+2;
         ECUT(IRA+2) = ECUTIN;
         PCUT(IRA+2) = PCUTIN;
         DOSE_ZONE(IRA+2)= 0;
         IREGION_TO_BIT(IRA+2) = 0;
         MED(IRA+2) = 0;
   ]

   IF(MOD(IR_SCATFOIL,3) = 1)[
      OUTPUT IR_SCATFOIL/3+1;(/' For layer',I3);
      OUTPUT IR_SCATFOIL;(' Local region ',I3,' (inside of cone)'/
 ' ECUT, PCUT (MeV), DOSE ZONE (0=DO NOT SCORE DOSE), IREGION_TO_BIT'/' : ',$);
   ]
   IF(MOD(IR_SCATFOIL,3) = 2)[
      OUTPUT IR_SCATFOIL;(' Local region ',I3,' (outside of cone)'/
 ' ECUT, PCUT (MeV), DOSE ZONE (0=DO NOT SCORE DOSE), IREGION_TO_BIT'/' : ',$);
   ]
   IF(MOD(IR_SCATFOIL,3) ~= 0)[
     ;MINPUT (SCATFOIL)
      ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
      (2F15.0,2I5);
      IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
      IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
      ;OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
             IREGION_TO_BIT(IRA);(F10.5,F10.3,I12,I20);
      OUTPUT IR_SCATFOIL;(' Material of region ',I3,' ',$);
     ;$MED_INPUT(SCATFOIL); " inputs character array MED_IN from unit 5, loops
     "through array MEDIA(24,I) to check if medium was previously input.
     "If so, sets MED_INDEX to index of previous medium.  If not,
     "increments NMED and sets MED_INDEX to NMED.
      MED(IRA) = MED_INDEX; " medium of the planar slab
   ]
   IF(MOD(IR_SCATFOIL,3) = 0)[
      ECUT(IRA) = ECUT(IRA_WALL);
      PCUT(IRA) = PCUT(IRA_WALL);
      DOSE_ZONE(IRA)= DOSE_ZONE(IRA_WALL);
      IREGION_TO_BIT(IRA) = IREGION_TO_BIT(IRA_WALL) ;
      MED(IRA) = MED_INDEX_WALL;
      IF(NOWALL_SCATFOIL = 1)[MED(IRA) = 0; ]
   ]
] "end of loop over IR_SCATFOIL"

"
"  set up air gap to previous CM, if present
"  =========================================
"
"  The air gap has the highest region number in the CM, even though it is at
"  the top of the component module.  This is to allow the assignment of region
"  numbers on input of the parameters of each local region (mainly to assign the
"  medium number of the region).  The air gap is then assigned after all of the
"  CM parameters have been input.
"
"note that if this is the first CM (ICM_SCATFOIL=1) then the gap thickness
"Z_gap_THICK(ICM_SCATFOIL) = 0, which is used as a flag that there is no
"air gap

"front of air gap
Z_gap_THICK(ICM_SCATFOIL) = ZMIN_SCATFOIL(1) - Z_min_CM(ICM_SCATFOIL);
IF (Z_gap_THICK(ICM_SCATFOIL) < $MIN_GAP) [
   Z_gap_THICK(ICM_SCATFOIL) = 0.;
   ZMIN_SCATFOIL(1)=Z_min_CM(ICM_SCATFOIL);
   N_GAP_SCATFOIL = 0; "no air gap for this CM
]
ELSE [
   N_GAP_SCATFOIL = 1; "this CM has an air gap
   IRA = IRSTART_SCATFOIL+N_SCATFOIL; "absolute region number of air gap
   MED(IRA) = AIR_INDEX; "medium is air
   ECUT(IRA) = ECUTIN;
   PCUT(IRA)=PCUTIN;
   ESAVE(IRA)=ESAVE_GLOBAL;
   ECUTRR(IRA)=ECUT(IRA);
]
"
"  parameter definition
"  ====================
"
"fill arrays of distance from reference plane (z=0) to front and back of slabs
"
" define the cone geometry here:

BDYTOL= $BDY_TOL;
ZMAX_SCATFOIL(1) = ZMIN_SCATFOIL(1) + ZTHICK_SCATFOIL(1);
DO I = 2, ISCM_MAX_SCATFOIL[
   ZMIN_SCATFOIL(I) = ZMIN_SCATFOIL(I-1) +
   ZTHICK_SCATFOIL(I-1);
   ZMAX_SCATFOIL(I) = ZMIN_SCATFOIL(I) + ZTHICK_SCATFOIL(I);
]
DO I = 1, ISCM_MAX_SCATFOIL[
   ALO_SCATFOIL(I) = (RMAX_SCATFOIL(I)-
   RMIN_SCATFOIL(I))/(ZMAX_SCATFOIL(I) - ZMIN_SCATFOIL(I));
   BLO_SCATFOIL(I) = RMIN_SCATFOIL(I) -
   ZMIN_SCATFOIL(I)*ALO_SCATFOIL(I);
   RMINT_SCATFOIL(I,1)  = RMIN_SCATFOIL(I) + BDYTOL;
   RMINT_SCATFOIL(I,2)  = RMIN_SCATFOIL(I) - BDYTOL;
   RMAXT_SCATFOIL(I,1)  = RMAX_SCATFOIL(I) + BDYTOL;
   RMAXT_SCATFOIL(I,2)  = RMAX_SCATFOIL(I) - BDYTOL;
   RMIN2_SCATFOIL(I)    = RMIN_SCATFOIL(I)**2;
   RMAX2_SCATFOIL(I)    = RMAX_SCATFOIL(I)**2;
   RMIN2T_SCATFOIL(I,1) = RMINT_SCATFOIL(I,1)**2;
   RMIN2T_SCATFOIL(I,2) = RMINT_SCATFOIL(I,2)**2;
   RMAX2T_SCATFOIL(I,1) = RMAXT_SCATFOIL(I,1)**2;
   RMAX2T_SCATFOIL(I,2) = RMAXT_SCATFOIL(I,2)**2;
   BLOT_SCATFOIL(I,1) = BLO_SCATFOIL(I) + BDYTOL;
   BLOT_SCATFOIL(I,2) = BLO_SCATFOIL(I) - BDYTOL;
   COSA_SCATFOIL(I)  = (ZMAX_SCATFOIL(I) - ZMIN_SCATFOIL(I))/
            SQRT( (ZMAX_SCATFOIL(I) - ZMIN_SCATFOIL(I))**2
                 +(RMAX_SCATFOIL(I) - RMIN_SCATFOIL(I))**2 );
]
RBN2_SCATFOIL     = RBN_SCATFOIL**2;
RBNT_SCATFOIL(1)  = RBN_SCATFOIL - BDYTOL;
RBNT_SCATFOIL(2)  = RBN_SCATFOIL + BDYTOL;
RBN2T_SCATFOIL(1) = RBNT_SCATFOIL(1)**2;
RBN2T_SCATFOIL(2) = RBNT_SCATFOIL(2)**2;

"set the variable zfront, which is only used once
ZFRONT_SCATFOIL = Z_min_CM(ICM_SCATFOIL);

"establish start of next CM
"
Z_min_CM(ICM_SCATFOIL+1) = ZMAX_SCATFOIL(ISCM_MAX_SCATFOIL);
"
"  set up region numbers
"  =====================
"
"  This CM has N_SCATFOIL+N_GAP_SCATFOIL regions, a series of cone slabs
"
;
IREND_SCATFOIL = IRSTART_SCATFOIL + N_SCATFOIL+ N_GAP_SCATFOIL - 1;
 "Index of last region
NREG = NREG+N_SCATFOIL+N_GAP_SCATFOIL;
                          "Total number of regions in full geometry up
                                "to and including this CM
IF (NREG <= $MXREG) ["have not exceeded maximum region number
      "Index of first region in next CM:"
      IR_start_CM(ICM_SCATFOIL+1) = IREND_SCATFOIL+1;
]
ELSE [
      OUTPUT ICM_SCATFOIL,NREG,$MXREG;
      (//'***ERROR IN CM ',I4,' (CONESTAK):'/
         I4,' regions requested, only ',I4,' available'//);
      IERR_GEOM(ICM_SCATFOIL)=IERR_GEOM(ICM_SCATFOIL)+1;
]
"
"  establish CM boundary
"  =====================
RMAX_CM_FLAG(ICM_SCATFOIL) = 1; "put a cylindrical boundary about CM
"
"  establish dose scoring zones and latch bit setting
"  ==================================================
"
IRA = IRSTART_SCATFOIL-1; "absolute region number"
DO IR_SCATFOIL=1,N_SCATFOIL["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones
   IF(NDOSE_ZONE > $MAX_DOSE_ZONE)[
      OUTPUT NDOSE_ZONE;
       (' Too many dose zone !', 'NDOSE_ZONE =',I5,
        ' > $MAX_DOSE_ZONE');
      STOP;
   ]
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT); " current maxmum
   "charged particle range rejection parameters
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region
   E_min_out(ICM_SCATFOIL)=ECUT(IRA); "Minimum energy on exit from CM
] "end of loop over IR_SCATFOIL

"   return from INPUT_SCATFOIL
"   =======================
"
RETURN;

"   error messages
"   ==============
"
:EOF_SCATFOIL:
;OUTPUT ICM;(//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_SCATFOIL:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;
END;  "End of subroutine INPUT_SCATFOIL"
%E   "start of subroutine ISUMRY_SCATFOIL"
"*******************************************************************************
"
"                          Subroutine ISUMRY_SCATFOIL
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_SCATFOIL;


;IMPLICIT NONE;
;COMIN/BOUNDS,CMs,CM_SCATFOIL,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_SCATFOIL
"T>**********************************
"T>
INTEGER
   ICOLOUR,       "T>colour of CM for EGS_Windows
   IRA,           "T>absolute region number
   I,J;           "T>DO loop index

$REAL VOL_SCATFOIL(3*$MAX_N_SCATFOIL+1),PIL;  "T> region volume
"   Mass of dose zone
"   =================
"
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_SCATFOIL.
"
PIL=4.0*ATAN(1.0);

" calc. the vol for each region.

DO I = 1,ISCM_MAX_SCATFOIL[
   VOL_SCATFOIL(3*(I-1)+1) = PIL/3.0*(ZMAX_SCATFOIL(I)-ZMIN_SCATFOIL(I))*
                    ( RMIN_SCATFOIL(I)**2 + RMAX_SCATFOIL(I)**2
                      +RMIN_SCATFOIL(I)*RMAX_SCATFOIL(I) );
   VOL_SCATFOIL(3*(I-1)+2) =
          PIL*(ZMAX_SCATFOIL(I)-ZMIN_SCATFOIL(I))*RBN_SCATFOIL**2-
           VOL_SCATFOIL(3*(I-1)+1);
   VOL_SCATFOIL(3*(I-1)+3) =
          PIL*(ZMAX_SCATFOIL(I)-
            ZMIN_SCATFOIL(I))*(RMAX_CM(ICM_SCATFOIL)**2-
              RBN_SCATFOIL**2);
]

IRA = IRSTART_SCATFOIL-1; "absolute region number
DO IR_SCATFOIL=1,N_SCATFOIL+N_GAP_SCATFOIL ["loop over local region number
   IRA = IRA+1;
   IF(DOSE_ZONE(IRA).NE.0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+VOL_SCATFOIL(IR_SCATFOIL)*RHOR(IRA);
      IF(AMASS(ID)<0.0 & ABS(AMASS(ID))<0.000001)[AMASS(ID)=0.0;]
   ]
] "end of loop over IR_SCATFOIL"

"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"

WRITE(IOUTLIST,110) ICM_SCATFOIL,TITLE_SCATFOIL;
WRITE(IOUTLIST,120) Z_min_CM(ICM_SCATFOIL),RMAX_CM(ICM_SCATFOIL);
IF(NOWALL_SCATFOIL=1)[
   WRITE(IOUTLIST,122);
]
ELSE[ WRITE(IOUTLIST,121)RBN_SCATFOIL; ]
WRITE(IOUTLIST,123);
IF(N_GAP_SCATFOIL~=0)[
   WRITE(IOUTLIST,124)'airgap',Z_min_CM(ICM_SCATFOIL),
                      ZMIN_SCATFOIL(1)-Z_min_CM(ICM_SCATFOIL),
                      RMAX_CM(ICM_SCATFOIL),RMAX_CM(ICM_SCATFOIL);
]
DO I=1,ISCM_MAX_SCATFOIL[
   WRITE(IOUTLIST,130)I,ZMIN_SCATFOIL(I),ZMAX_SCATFOIL(I)-
               ZMIN_SCATFOIL(I),
               RMIN_SCATFOIL(I),RMAX_SCATFOIL(I);
]
WRITE(IOUTLIST,140);
IRA = IRSTART_SCATFOIL - 1;
DO IR_SCATFOIL=1,N_SCATFOIL-1,3[
   ISCM_SCATFOIL = (IR_SCATFOIL - 1)/3 + 1;
   IRA = IRSTART_SCATFOIL + IR_SCATFOIL - 1;
   IF(MED(IRA)~=0)[
      WRITE(IOUTLIST,150) IR_SCATFOIL,ISCM_SCATFOIL,'inside',
         ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),(MEDIA(J,MED(IRA)),J=1,9);
   ]
   ELSEIF(MED(IRA)=0)[
      WRITE(IOUTLIST,150) IR_SCATFOIL,ISCM_SCATFOIL,'inside',
         ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
   ]
   IF(MED(IRA+1)~=0)[
      WRITE(IOUTLIST,150) IR_SCATFOIL+1,ISCM_SCATFOIL,'outside',
         ECUT(IRA+1),PCUT(IRA+1),ECUTRR(IRA+1),ESAVE(IRA+1),
         DOSE_ZONE(IRA+1),IREGION_TO_BIT(IRA+1),(MEDIA(J,MED(IRA+1)),J=1,9);
   ]
   ELSEIF(MED(IRA+1)=0)[
      WRITE(IOUTLIST,150) IR_SCATFOIL+1,ISCM_SCATFOIL,'outside',
         ECUT(IRA+1),PCUT(IRA+1),ECUTRR(IRA+1),ESAVE(IRA+1),
         DOSE_ZONE(IRA+1),IREGION_TO_BIT(IRA+1),'V','a','c','u','u','m';
   ]
   IF(NOWALL_SCATFOIL~=1)[
      IF(MED(IRA+2)~=0)[
         WRITE(IOUTLIST,150) IR_SCATFOIL+2,ISCM_SCATFOIL,'wall',
         ECUT(IRA+2),PCUT(IRA+2),ECUTRR(IRA+2),ESAVE(IRA+2),
         DOSE_ZONE(IRA+2),IREGION_TO_BIT(IRA+2),(MEDIA(J,MED(IRA+2)),J=1,9);
      ]
      ELSEIF(MED(IRA+2)=0)[
         WRITE(IOUTLIST,150) IR_SCATFOIL+2,ISCM_SCATFOIL,'wall',
         ECUT(IRA+2),PCUT(IRA+2),ECUTRR(IRA+2),ESAVE(IRA+2),
         DOSE_ZONE(IRA+2),IREGION_TO_BIT(IRA+2),'V','a','c','u','u','m';
      ]
   ]
   ELSE[        "nowall"
      WRITE(IOUTLIST,153) IR_SCATFOIL+2,ISCM_SCATFOIL,'nowall',
         'NA','NA','NA','NA','NA','NA','V','a','c','u','u','m';
   ]
]
IF(N_GAP_SCATFOIL ~= 0 )[
   IRA = IRSTART_SCATFOIL+N_SCATFOIL;
   WRITE(IOUTLIST,151) N_SCATFOIL+N_GAP_SCATFOIL,'NA','airgap',
       ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
       DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),(MEDIA(J,MED(IRA)),J=1,9);
   WRITE(IOUTLIST,152)'at top';
]

110 FORMAT(///1x,79('-')/ '  Component module',I3,
           ' is stacked set of truncated cones (CONESTAK)'
           /1x,79('-')
           //T2,'Title: ',68A1);
120 FORMAT(/T2,'SCATFOIL geometry parameters:',
           /T2,'-----------------------------',
           /T2,'Distance of front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Radius of outer boundary of CM = ',F15.5,' cm');
121 FORMAT(T2,'Inner radius of outer wall = ',F8.5,' cm');
122 FORMAT(T2,'There is no outer wall.');
123 FORMAT(/T2,'layer    Z front   thickness   top radius   bottom radius',
           /T2,'  #       face',
           /T2,'          (cm)       (cm)         (cm)         (cm)');
140 FORMAT(/T2,'SCATFOIL region parameters:',
           /T2,'---------------------------',
           /T2,'local  layer  location  electron  photon',
           '  range-rejection   dose  bit  medium'
           /T2,'region                   cutoff   cutoff',
           '   level     max    zone  set'
           /T2,'                          (MeV)    (MeV)',
           '   (MeV)    (MeV)');
150 FORMAT(T2,I3,I7,4X,A7,F10.3,F9.3,F8.3,F9.3,I6,I5,2X,9A1);
151 FORMAT(T2,I3,4X,A3,4X,A7,F10.3,F9.3,F8.3,F9.3,I6,I5,2X,9A1);
152 FORMAT(T16,A7);
153 FORMAT(T2,I3,I7,4X,A7,A10,A9,A8,A9,A6,A5,2X,9A1);
130 FORMAT(T2,I3,F12.3,F12.3,F12.3,F13.3);
124 FORMAT(T2,A6,F9.3,F12.3,F12.3,F13.3);

"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"
IF(IWATCH = 4 | IZLAST = 2) [  "Creat a graphics file "
   ICOLOUR=4;
"   WRITE(IOUTGEOM,201) ICOLOUR,'DISK',0.0,0.0,ZMIN_SCATFOIL,RMIN_SCATFOIL;
   "cone geometry"
   DO I = 1, ISCM_MAX_SCATFOIL[
      WRITE(IOUTGEOM,201)ICOLOUR,'CYLZ',ZMIN_SCATFOIL(I),
          RMIN_SCATFOIL(I),ZMAX_SCATFOIL(I),RMAX_SCATFOIL(I),0.0,0.0;
          201   FORMAT(' ',I1,A4,10(F7.2,','));
   ]
]"End of graphics output"
RETURN;
END;  "end of subroutine ISUMRY_SCATFOIL"
%E   "start of subroutine HOWNEAR_SCATFOIL"
"******************************************************************************
"
"                          Subroutine HOWNEAR_SCATFOIL
"                          ***********************
"
" Calculates min. distance to nearest region boundary.
" Used to be contained in a macro.
"
"*******************************************************************************
;SUBROUTINE HOWNEAR_SCATFOIL(DIST);


$IMPLICIT-NONE;

COMIN/CM_SCATFOIL,STACK/;

$REAL DIST; "T> the min. distance to nearest region boundary

IR_SCATFOIL = IR(NP) - IRSTART_SCATFOIL + 1;
ISCM_SCATFOIL = (IR_SCATFOIL-1)/3 + 1;
IF(IR_SCATFOIL = 3*(ISCM_SCATFOIL-1) + 1)[
  DIST = (ALO_SCATFOIL(ISCM_SCATFOIL)*Z(NP) +
           BLO_SCATFOIL(ISCM_SCATFOIL)
          - SQRT(X(NP)**2 + Y(NP)**2))*COSA_SCATFOIL(ISCM_SCATFOIL);
  DIST = MIN(DIST,Z(NP)-ZMIN_SCATFOIL(ISCM_SCATFOIL),
         ZMAX_SCATFOIL(ISCM_SCATFOIL)-Z(NP));
]
ELSEIF(IR_SCATFOIL = 3*(ISCM_SCATFOIL-1)+2)[
  IF(NOWALL_SCATFOIL=1)[
      DIST = (SQRT(X(NP)*X(NP) + Y(NP)*Y(NP))
           - ALO_SCATFOIL(ISCM_SCATFOIL)*Z(NP)
           - BLO_SCATFOIL(ISCM_SCATFOIL))*COSA_SCATFOIL(ISCM_SCATFOIL);
  ]
  ELSE[
      DIST = MIN((SQRT(X(NP)*X(NP) + Y(NP)*Y(NP))
                  - ALO_SCATFOIL(ISCM_SCATFOIL)*Z(NP)
                  - BLO_SCATFOIL(ISCM_SCATFOIL))
                  *COSA_SCATFOIL(ISCM_SCATFOIL),
                 RBN_SCATFOIL-SQRT(X(NP)*X(NP) + Y(NP)*Y(NP)));
  ]
  DIST = MIN(DIST,Z(NP)-ZMIN_SCATFOIL(ISCM_SCATFOIL),
         ZMAX_SCATFOIL(ISCM_SCATFOIL)-Z(NP));
]
ELSEIF(IR_SCATFOIL = 3*(ISCM_SCATFOIL-1)+3)[
  DIST = MIN(SQRT(X(NP)*X(NP) + Y(NP)*Y(NP)) - RBN_SCATFOIL,
             Z(NP)-ZMIN_SCATFOIL(ISCM_SCATFOIL),
             ZMAX_SCATFOIL(ISCM_SCATFOIL)-Z(NP));
]
ELSE[
   DIST=0.0;
]
RETURN;
END; "End of subroutine HOWNEAR_SCATFOIL"
"*******************************************************************************
"End of CONESTAK_cm.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: parallel plate monitor chamber            "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Charlie Ma                                                "
"                   Dave Rogers                                               "
"                   Iwan Kawrakow                                             "
"                   Ernesto Mainegra-Hing                                     "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code originally evolved from the IONCHAM component module written by  "
"  Jiansu Wei, starting in 1992.                                              "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


%Q1
%C80
!INDENT F4;
!INDENT M4;
;
"
"*******************************************************************************
"*******************************************************************************
"
"                             *************       ""toc:
"                             *           *       ""toc:
"                             *  CHAMBER  *       ""toc:
"                             *           *       ""toc:
"                             *************       ""toc:
"
"
"   History of modifications given by sccs.
"
"*******************************************************************************
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"
"   Component module for BEAM.  Parallel plate monitor chamber in the      "
"   container with top and bottom layers of arbitrary thickness and        "
"   material.                                                              "
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator:  a cylindrical
"   planar geometry for monitoring chamber.
"
"I>
"I> Geometry of IONCHAM (CHAMBER):             ""toc:
"I> *****************************
"I>                        top part,    # of layers: n_top_$chamber
"I>                --------|-----------------------------|--------
"I>                -------------|-----------------|---------------
"I>                -----------------------------------------------
"I>                 |     |    |--------------------|    |     |
"I>                 |     |    |--------------------|    |     |
"I>                 |     |    |--------------------|    |     |
"I>                 |     |wall|--------------------|    |     |
"I>                 |     |    |         .          |    |  # of layers:
"I>     container   |     |    |         .          |    |   n_chm_$chamber
"I>       wall      |     |    |         .          |    |     |
"I>                 | gap |    |         .          |    |     |
"I>                 |     |    |chamber central part|    |     |
"I>                 |     |    |--------------------|    |     |
"I>                 |     |    |--------------------|    |     |
"I>                 |     |    |--------------------|    |     |
"I>                 |     |    |____________________|    |     |
"I>                --------|----------------------------|-----------
"I>                ----------|------------------------|-------------
"I>                ------|--------------------------------|---------
"I>                        bottom part, # of layers: n_bot_$chamber
"I>
"I>
"I>   IR is the region number within the CM.  There are three parts
"I>   shown above. There are N_IONCHAM (>1) local regions.
"I>
"I>
"I>            ----------------------------------------------------
"I>            | top part:  n_top_$chamber layers.                |
"I>            |            # region: n_top_$chamber x 2          |
"I>            ----------------------------------------------------
"I>            | cham part: n_chm_$chamber layers.                |
"I>            |            # region: n_chm_$chamber + 3          |
"I>            ----------------------------------------------------
"I>            | bottom part: n_bot_$chamber layers               |
"I>            |            # region: n_bot_$chamber x 2          |
"I>            |--------------------------------------------------|
"I>            | total # regions: N_$chamberber = n_chm_$chamber+3|
"I>            |                  +2n_top_$chamber                |
"I>            |                  +2n_bot_$chamber                |
"I>            ----------------------------------------------------
;
"I>            -------------------------------------------------
"I>            | abs region # setting:                         |
"I>            |     first: main cham part begins              |
"I>            |            with irstart_$chamber,             |
"I>            |            ends with irstart_$chamber+        |
"I>            |            n_chm_$chamber-1                   |
"I>            |            +3(side wall+gap+ container wall)  |
"I>            |     second: top layers begins                 |
"I>            |            with the end of cham part+1        |
"I>            |            ends with the end of cham part     |
"I>            |            + 2n_top_$chamber-1                |
"I>            |     third: bottom layers with                 |
"I>            |            the end of top part +1             |
"I>            |            ends with the end of top part      |
"I>            |            + 2n_bot_$chamber-1                |
"I>            |     air gap: irend_$chamber=irstart_$chamber+ |
"I>            |            n_cham_$chamber +3                 |
"I>            |            +2n_top_$chamber                   |
"I>            |            +2n_bot_$chamber                   |
"I>            -------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_IONCHAM
"                      ISUMRY_IONCHAM
"                      HOWFAR_IONCHAM
"                      WHERE_AM_I_IONCHAM
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS ON USE/BUGS       ""toc:
"                             ************************
"
"*******************************************************************************
"**************************  DESCRIPTION OF VARIABLES  *************************
"*******************************************************************************
"
"                             COMMON BLOCK VARIABLES
"                             **********************
"
"  Refer to the replacement macros in BEAM.MORTRAN and BEAM_COMMON.MORTRAN
"  which define the common block variables.
"
"*******************************************************************************
"
"                                OTHER VARIABLES
"                                ***************
"
"  Refer to the section on type declarations for each subroutine. The following
"  section describes the variables input from unit 5.  These variables define
"  the parameters of each simulation.
"
;
"*******************************************************************************
"
"                               INPUT FROM UNIT 5             ""toc:
"                               *****************             ""toc:
"
"I>
"I>  CARDS CM_IONCHAM
"I>  ****************
"I>
"I>  -1  Dummy line to indicate start of CM.
"I>
"I>   0  RMAX_CM(ICM_IONCHAM):( F10.0):   Maximum radius of component module
"I>
"I>   1  TITLE_IONCHAM (60A1):  Title of CM.
"I>
"I>   2  ZMIN_IONCHAM (F15.0): Distance from front surface of 1st cylinder to
"I>                             reference plane (Z=0). Excludes any air gap.
"I>
"I>   3  N_TOP_IONCHAM, N_CHM_IONCHAM, N_BOT_IONCHAM (3I5)
"I>
"I>        N_TOP_IONCHAM:   Number of layers in top part (>= 0).
"I>        N_CHM_IONCHAM:   Number of layers in chamber itself (> 0 to input
"I>                          chamber layers individually or if ALL layers have
"I>                          the same thickness and medium; < 0 to
"I>                          input -N_CHM_IONCHAM groups of layers where
"I>                          layers in each group have the same thickness and
"I>                          ALL layers have the same MED).
"I>        N_BOT_IONCHAM:   Number of layers in bottom part (>= 0).
;
"I>   ==========================================================================
"I>   4  Inputs for the top part (If N_TOP_IONCHAM >0):
"I>   ==========================================================================
"I>
"I>    If all layers in this part are identical, then in line (a) include
"I>    NFLAG=N_TOP_IONCHAM, otherwise repeat (a) to (e) for each of the
"I>    layers.
"I>
"I>     a) ZTHICK, RCYS_IONCHAM , NFLAG (2F15.0,I5)
"I>           ZTHICK (F15.0):        Thickness of each layer in top part
"I>           RCYS_IONCHAM (F15.0): Radius of inner cylinders in each layer
"I>           N_TOP_IONCHAM (I5):   Number of layers in top part
"I>
"I>     b) ECUT,PCUT,DOSE_ZONE,IREGION_TO_BIT for inner cylinders
"I>                                           (2F15.0,2I5,1-line):
"I>         ECUT, PCUT: Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:  Dose scoring region for this region, 0=>no dose scored.
"I>         IREGION_TO_BIT :  Bit # in LATCH designated to this region
"I>
"I>     c) MED_IN (24A1):  Medium of inner cylinder (used for MED_INDEX)
"I>
"I>     d) ECUT,PCUT,DOSE_ZONE,IREGION_TO_BIT for outer annuli
"I>                                           (2F15.0,2I5,1-line):
"I>
"I>     e) MED_IN (24A1):  Medium for outer annuli (used for MED_INDEX)
"I>
;
"I>   =========================================================================
"I>   5  Inputs for the chamber/phantom part:
"I>   =========================================================================
"I>
"I>    The chamber/phantom part has a central part of potentially many layers
"I>    which may have different media and dimensions.  Outside this there
"I>    are 3 cylindrical shells, called the chamber wall, gap, and container
"I>    wall.  Each is a single material running the entire Z-span of the
"I>    central part.
"I>
"I>   5.1) RCYS_IONCHAM(1,1), RCYS_IONCHAM(1,2), RCYS_IONCHAM(1,3) (3F15.0)
"I>          RCYS_IONCHAM (1,1): Inner r of chamber wall=outer r central region
"I>          RCYS_IONCHAM (1,2): Outer r of chamber wall=inner r of gap
"I>          RCYS_IONCHAM (1,3): Inner r of container wall=outer r of gap
"I>
"I>
"I>   5.2) If N_CHM_IONCHAM>0: If all layers in this part are identical, then
"I>           in line (a) include NFLAG=N_CHM_IONCHAM and input (b) once for
"I>           all layers, otherwise repeat (a) to (c) for each of the layers.
"I>        If N_CHM_IONCHAM<0: Repeat (a) once for each of the
"I>           -N_CHM_IONCHAM groups of layers of equal thickness. In this case,
"I>           NFLAG is the number of layers in the group.   Then input (b) once
"I>           for all layers.
"I>
"I>     a) ZTHICK, NFLAG  (F15.0,I5)
"I>           ZTHICK:    Thickness of each layer in chamber part
"I>                      (N_CHM_IONCHAM>0) or of each layer in this particular
"I>                      group of layers (N_CHM_IONCHAM<0)
"I>           NFLAG:     Number of layers in chamber IF all same
"I>                      (N_CHM_IONCHAM>0) or number of layers in the group
"I>                      (N_CHM_IONCHAM<0)
"I>
"I>     b) ECUT,PCUT,DOSE_ZONE,IREGION_TO_BIT for chamber layers
"I>                                                (2F15.0,2I5,one line):
"I>           ECUT, PCUT: Cutoff energies for electrons and photons.
"I>           DOSE_ZONE:  if all layers are of equal thickness or there are
"I>                       groups of layers of equal thickness (ie
"I>                       NFLAG=N_CHM_IONCHAM or N_CHM_IONCHAM<0) then, if
"I>                       DOSE_ZONE>0 the dose is scored in regions
"I>                       DOSE_ZONE, DOSE_ZONE+1,.., DOSE_ZONE+N_CHM_IONCHAM-1
"I>                       ie, a sequence of dose scoring zones are set up
"I>                       automatically for all layers.
"I>                       For single region at a time
"I>                       Dose scoring region for this region,0=>no dose scored.
"I>           IREGION_TO_BIT :  Bit # in LATCH designated to this region
"I>
"I>     c) MED_IN (24A1):  Medium of chamber layers (used to set MED_INDEX)
"I>
"I>
"I>     5.3) Inputs for the chamber wall:
"I>     ---------------------------------
"I>
"I>     a) ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT, (2F15.0,2I5):
"I>           ECUT, PCUT: Cutoff energies for electrons and photons.
"I>           DOSE_ZONE:  Dose scoring region for this region,0=>no dose scored.
"I>           IREGION_TO_BIT:  Bit # in LATCH designated to this region
"I>
"I>     b) MED_IN (24A1):  Medium of chamber wall (used to set MED_INDEX)
"I>
"I>     5.4) Inputs for the gap between chamber wall and container wall:
"I>     ----------------------------------------------------------------
"I>
"I>     a) ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT, (2F15.0,2I5):
"I>
"I>     b) MED_IN (24A1):  Medium of gap (used to set MED_INDEX)
"I>
"I>
"I>     5.5) Inputs for the container wall:
"I>     -------------------------------------------
"I>
"I>     a) ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT, (2F15.0,2I5):
"I>
"I>     b) MED_IN (24A1):  Medium of container wall (used to set MED_INDEX)
;
"I>   =====================================================================
"I>   6  Inputs for the bottom part (If N_BOT_IONCHAM >0):
"I>   =====================================================================
"I>
"I>    5.6) If all layers in this part are identical, then in line (a) include
"I>         NFLAG=N_BOT_IONCHAM, otherwise repeat (a) to (e) for each of the
"I>         layers.
"I>
"I>     a) ZTHICK, RCYS_IONCHAM , NFLAG (2F15.0,I5)
"I>          ZTHICK:           Thickness of each layer in bottom part
"I>          RCYS_IONCHAM:    Radius of inner cylinders in bottom part
"I           NFLAG:            Number of layers in bottom part IF all same
"I>
"I>     b) ECUT,PCUT,DOSE_ZONE,IREGION_TO_BIT for inner cylinders
"I>                                             (2F15.0,2I5,1-line):
"I>          ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>          DOSE_ZONE:   Dose scoring flag, 0=>do not score dose.
"I>          IREGION_TO_BIT :  Bit # in LATCH designated to this region
"I>
"I>     c) MED_IN (24A1):  Medium of inner cylinders (used for MED_INDEX)
"I>
"I>     d) ECUT,PCUT,DOSE_ZONE,IREGION_TO_BIT for outer annuli
"I>                                            (2F15.0,2I5,1-line):
"I>     e) MED_IN (24A1):  Medium of outer annuli (used for MED_INDEX)
"I>
"I>   ====================================================================
"I>   7  Inputs for range rejection options:
"I>   ====================================================================
"I>
"I>       MRNGE (I5)         0 or 1
"I>
"I>          MRNGE     : = 1 to estimate thickness of the CHAMBER for
"I>                        ECUTRR calculations in automated range rejection
"I>                        (IREJCT_GLOBAL=1) (crude approx for 5 layers)
"I>                      = 0 no ECUTRR calculation--range rejection will
"I>                        still be done on a region-by-region basis
"I>
"I>            Note that MRNGE only has an effect if automated range
"I>            rejection is on (IREJCT_GLOBAL=1).
"I>
"I>   Example
"I>   *******
"I>
"I>  The following set of cards defines a chamber with 2 top layers, 3 chamber
"I>  layers, and 2 bottom layers.
"I>  The chamber wall is AL & the chamber container is CU. The detecting
"I>  material is air.
"I>  The air cavities are assigned as dose region 1 and the rest as region 2.
"I>
"I>  10.5; radius of CM
"I>  Chamber with 2 top layers, 3 chamber layers, 2 bottom layers
"I>  10.0; distance from front surface of the CM to the reference plane (z=0)
"I>  2,3,2;                   2 top layers, 3 chamber layers, 2 bottom layers
"I>  0.1,5.0,0;          first layer in the top part, 0.1cm thick, IR=5cm
"I>  0.521,0.010,2,2;  dose region # = 2
"I>  CU             ;  medium
"I>  0.521,0.010,2,2;
"I>  CU
"I>  0.2,5.0,0;          second layer is 0.2 cm thick, radius = 5.0 cm
"I>  0.521,0.010,2,2;  for inner cylinder (dose region # = 2)
"I>  AL
"I>  0.521,0.010,2,2;  for outer annulus
"I>  AL
"I>  5.0,5.2,10.0;     IR & OR of chamber wall, IR of container
"I>  0.2;              thickness of the first layer (air) in chamber part
"I>  0.521,0.010,1,2;  dose region # = 1
"I>  AIR
"I>  0.1;              thickness of the second layer (AL) in chamber part
"I>  0.521,0.010,2,2;  dose region # = 2
"I>  AL
"I>  0.2;              thickness of the third layer (air) in chamber part
"I>  0.521,0.010,1,2;  dose region # = 1
"I>  AIR
"I>  0.521,0.010,2,2;  chamber wall (dose region # = 2)
"I>  AL
"I>  0.521,0.010,2,2;  air gap betweem chamber wall and container wall
"I>  AIR
"I>  0.521,0.010,2,2;  chamber container
"I>  CU
"I>  0.1,5.0,2;        2 layers in bot. part have = thickness, IR
"I>  0.521,0.010,2,2;  for inner cylinders
"I>  AL
"I>  0.521,0.010,2,2;  for outer annuli
"I>  AL
"I>  0;                do not calculate ECUTRR
"I>
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules
"
"*******************************************************************************

%E     "start of subroutine HOWFAR_IONCHAM"
"******************************************************************************
"************************** Component Module CHAMBER***************************
"******************************************************************************
"
"                          Subroutine HOWFAR_IONCHAM
"                          ***********************
"
" HOWFAR routine for stacked planar media.
"
" Determine if current region number is within CHAMBER, and if so evaluate
" DIST, the distance to the region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are N_IONCHAM local regions + an air gap (if present):
"
"     local               absolute                       description
"----------  -------------------------------------   -----------------------
"IR_IONCHAM  IR_start_CM(ICM_IONCHAM)+IR_IONCHAM-1 excluding front air gap
"----------  -------------------------------------   -----------------------
"   Geometrical co-ordinates, as set in INPUT_IONCHAM are:
"
"   ZFRONT_IONCHAM     front of CM (upstream surface, air region)
"   ZMIN_IONCHAM       front of first cylinder
"   ZMAX_IONCHAM       back of last cylinder
"   RMAX_IONCHAM       radius of last cylinder (largest)
"
"******************************************************************************

;SUBROUTINE HOWFAR_IONCHAM;


"V>$GEO_SHIFT_1_(#)
"V>=============
"V>{p1} the value to compare with ustep
"V> if {p1}+1.0e-5 < ustep shift it, otherwise no shift
;
REPLACE {$GEO_SHIFT_1_(#)} WITH
{; IF({P1}+1.0E-5< USTEP) [{P1}={P1}+1.0E-5;]  }


"V>$GEO_SHIFT_2_(#,#)
"V>=============
"V>{p1} the value to compare with {P2}
"V> if {p1}+1.0e-5 < {P2} shift it, otherwise no shift
;
REPLACE {$GEO_SHIFT_2_(#,#)} WITH
{; IF({P1}+1.0E-5< {P2}) [{P1}={P1}+1.0E-5;]  }

;IMPLICIT NONE;

;COMIN/
   CMs,CM_IONCHAM,EPCONT,STACK,EGS-IO/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_IONCHAM
"T>**********************************
"T>

INTEGER
   IRL,            "T>local region number (absolute), required by HOWNEAR macro
   I, IIR, JDEBUG,
   LAYER,
   IU_D;           "T>to indicate the relations between ustep and dist

$REAL
   DIST,          "T>furthest dist to z boundary along current trajectory
   RF2_IONCHAM,  "T>temporary variable
   DMIN_IONCHAM, "T>minimum distance to boundaries checked thus far
   R0SQ,          "T>temporary init position of the particle in x-y plane
   CRITERIOR_IR,ZNP,
   STEP_UNIT, CUT_COE, CUTCOE_IONCHAM, SHIFT_COUNT_IONCHAM;
;

" Determine local region number
" *****************************
ZNP=Z(NP);
IRL = IR(NP); "local region number (absolute)
JDEBUG=JDEBUG+1;
IR_IONCHAM = IRL - IRSTART_IONCHAM + 1;   "local region number( relative )

" Set DNEAR
" *********
" This replacement macros sets DMIN_IONCHAM as well as defining IR_IONCHAM
;
IONCHAM_CM_HOWNEAR(DMIN_IONCHAM);
DNEAR(NP) = DMIN_IONCHAM;
;

" CALC. THE LAYER # "
IF( IR_IONCHAM<=N_CHM_IONCHAM ) [ LAYER=IR_IONCHAM; ]
ELSEIF(IR_IONCHAM<=N_CHM_IONCHAM+3 ) [ LAYER=1; ]
ELSE[
   LAYER=N_CHM_IONCHAM+
         (IR_IONCHAM-N_CHM_IONCHAM-3+1)/2;
]
" this will be used only for the top and bottom parts "


" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module,if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
;
R0SQ=X(NP)**2+Y(NP)**2;
CUT_COE=0.0;

" the following block double check:
"=================================
"      1. the particle is out of the CM oe regions in z direction
"      2.                        the regions in r directions
"     if so reset the ir #, and print out the warning message.
"comment: this block is not time consumming, can be kept in the final version
"=======
"
"  now do the air gap if existed.
"=====================================

IF(N_GAP_IONCHAM=1 & IRL=IREND_IONCHAM )["check the air gap first"
   IF(W(NP)>0.0)["particle going forward"
      DIST = (ZMIN_IONCHAM - Z(NP))/W(NP); "distance to front of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0)[ " particle was out of the air gap"
          USTEP=0.0;
          IF(N_TOP_IONCHAM=0)[" no top layer above the chamber"
              IF(R0SQ<RCYS2_IONCHAM(1,1))[IRNEW =IRSTART_IONCHAM;]
              ELSEIF(R0SQ<RCYS2_IONCHAM(1,2))
                 [IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM;]
              ELSEIF( R0SQ<RCYS2_IONCHAM(1,3) )
                 [IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM+1;]
              ELSE[ IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM+2;]
           ]
           ELSE[        " has top layer above the chamber"
               IF( R0SQ<RCYS2_IONCHAM(N_CHM_IONCHAM+1,1) )
                  [ IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM+3;]
               ELSE[IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM+4;]
           ]
           RETURN;
       ] "end of the double check if a particle is out of the AIR GAP"

      "  do the howfar job for the air gap  "
      "====================================="
       ELSE[
           IF( IU_D=0 )[RETURN; ] " no cut, ustep admmited"
           ELSE[ " iu_d=1, cut the ustep to dist "
               ;$GEO_SHIFT_1_(STEP_UNIT);
               USTEP=STEP_UNIT;
               RF2_IONCHAM= (X(NP)+USTEP*U(NP))**2
                        +(Y(NP)+USTEP*V(NP))**2;
               IF(N_TOP_IONCHAM=0)[  " no top layer above the chamber"
                  IF( RF2_IONCHAM<RCYS2_IONCHAM(1,1) )
                    [IRNEW =IRSTART_IONCHAM;]
                  ELSEIF( RF2_IONCHAM<RCYS2_IONCHAM(1,2) )
                    [IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM;]
                  ELSEIF( RF2_IONCHAM<RCYS2_IONCHAM(1,3) )
                    [IRNEW =IRSTART_IONCHAM+1+N_CHM_IONCHAM;]
                  ELSE[ IRNEW =IRSTART_IONCHAM+2+N_CHM_IONCHAM;]
               ]
               ELSE[ " has top layer above the chamber"
                  IF( RF2_IONCHAM<RCYS2_IONCHAM(N_CHM_IONCHAM+1,1) )
                    [ IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM+3;]
                  ELSE[IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM+4;]
               ]
               RETURN;
           ]  " end of the cut case"
       ]"  end of the howfar for this case"
   ]   " end of the w>0 case

   ELSEIF(W(NP)<0.0)[ " particle going backward"
      DIST = (ZFRONT_IONCHAM - Z(NP))/W(NP); "distance to front of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0)[
          USTEP=1.E-16; "make sure ausgab is called when leaving CM"
          CALL WHERE_AM_I(ICM_IONCHAM,-1);
          RETURN;
      ] " end of the double check if a particle is out of the CM"
      ELSE[ " do the howfar job"
          IF( IU_D=0 ) [ RETURN; ]   " no cut, ustep admmited"
          ELSE[  " iu_d=1, cut the ustep to dist "
              ;$GEO_SHIFT_1_(STEP_UNIT);
              USTEP=STEP_UNIT;
              CALL WHERE_AM_I(ICM_IONCHAM,-1);
              RETURN;
          ]  " end of the howfar job for this case "

      ]    " end of the howfar job for this case"
   ]  " end of the w<0 case "
   ELSE[ RETURN;]  " for the w=0.0 case "
]    " end of the air gap case "

" now do the central part of the ion chamber "
"==========================================="

ELSEIF(IR_IONCHAM<=N_CHM_IONCHAM)  [" inside the inner chamber layers"
   IF(W(NP) > 0.0) [  "particle going forward"
      DIST = (Z_IONCHAM(IR_IONCHAM+1) - Z(NP))/W(NP);
      "distance to back of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <=0.0)[
          USTEP=0.0;
          IF(IR_IONCHAM=N_CHM_IONCHAM & N_BOT_IONCHAM=0 )[
             " last layer of the cham"
             USTEP=1.E-16;
             CALL WHERE_AM_I(ICM_IONCHAM,1);
          ]" and last layer of CM  "
          ELSEIF( IR_IONCHAM=N_CHM_IONCHAM )[
             " last layer of chamb, not for CM   "
             " particle will go into the first layer of the bottom part  "
             IF(R0SQ< RCYS2_IONCHAM(N_CHM_IONCHAM+N_TOP_IONCHAM+1,1))[
                 " the first layer of the bottom part"
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3+2*N_TOP_IONCHAM;
             ]
             ELSE[
                IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3+2*N_TOP_IONCHAM+1;
             ]
          ]
          ELSE[  IRNEW = IR(NP)+1;]
          RETURN;
      ]
      " end of the double check if a particle is out of the CM in z direct "

      " now check the r direction "
      "==========================="

      CRITERIOR_IR=R0SQ-RCYS2_IONCHAM(1,1);
      " all the inner layers have the same radius"
      IF(CRITERIOR_IR>0.0)[" out of the r1 "
          USTEP=MIN( USTEP, SHIFT_COUNT_IONCHAM(IR_IONCHAM) );
          IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM;" go into the side wall "
          RETURN;
      ]   " end of the   r direction error block "

      "  now do the howfar job  "
      "========================="
      RF2_IONCHAM=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF(RF2_IONCHAM > RCYS2_IONCHAM(1,1))
        [CUT_COE=CUTCOE_IONCHAM( R0SQ, RCYS2_IONCHAM(1,1) ); ]
      IF((CUT_COE>0.0&CUT_COE<STEP_UNIT)|(CUT_COE=STEP_UNIT&IU_D=0))[
          " hits the side wall of the chamber "
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM;
          RETURN;
      ]
      ELSEIF(IU_D=1)[ " hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          IF(IR_IONCHAM=N_CHM_IONCHAM & N_BOT_IONCHAM=0 )[
              " last layer of the cham"
              CALL WHERE_AM_I(ICM_IONCHAM,1); ]" and last layer of CM  "
          ELSEIF( IR_IONCHAM=N_CHM_IONCHAM )[
              "last layer of chamb, not for CM"
              " particle will go into the first layer of the bottom part  "
              RF2_IONCHAM= (X(NP)+USTEP*U(NP))**2
                        +(Y(NP)+USTEP*V(NP))**2;
              IF(RF2_IONCHAM<RCYS2_IONCHAM(N_CHM_IONCHAM+
                         N_TOP_IONCHAM+1,1))
              [IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3+2*N_TOP_IONCHAM;]
              ELSE[IRNEW=IRSTART_IONCHAM+
                   N_CHM_IONCHAM+3+2*N_TOP_IONCHAM+1;]
          ]
          ELSE[IRNEW = IR(NP)+1;]
          RETURN;
       ]    " end of the case with  ustep cutoff in z direction "
       ELSE [ RETURN; " no cut off at all "  ]
   ] " end of the w>0 case "

   ELSEIF(W(NP)< 0.0)["particle going backward"
      DIST = (Z_IONCHAM(IR_IONCHAM) - Z(NP))/W(NP);
      "distance to back layer, the 0th index is ok "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0)[" particle was out of this layer in z direction"
          USTEP=0.0;
          IF(IR_IONCHAM=1 & N_TOP_IONCHAM=0 )[ " top of CM, no top part "
              IF(N_GAP_IONCHAM = 1)[ IRNEW =IREND_IONCHAM;]
              " has air gap"
              ELSE [ USTEP=1.E-16; CALL WHERE_AM_I(ICM_IONCHAM,-1); ]
                                              " no air gap "
          ]
          ELSEIF(IR_IONCHAM=1)[
             " top of the chamb, not the top of the CM"
             " particle will go into the top part from below"
             IF(R0SQ<RCYS2_IONCHAM(N_CHM_IONCHAM+N_TOP_IONCHAM,1))[
                 " the last layer of the top part "
                 IRNEW=IRSTART_IONCHAM+
                      N_CHM_IONCHAM+3+2*(N_TOP_IONCHAM-1);
             ]
             ELSE[IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3+
                   2*(N_TOP_IONCHAM-1)+1;
             ]
          ]
          ELSE[  IRNEW = IR(NP)-1;]" layer # decreases by one in the chamb"
          RETURN;
      ]
      " end of the double check if a particle is out of the main cham in z"

      " now check the r direction "
      "==========================="
      CRITERIOR_IR=R0SQ-RCYS2_IONCHAM(1,1);
      IF(CRITERIOR_IR>0.0)[" out of the region in r direction  "
          USTEP=MIN( USTEP, SHIFT_COUNT_IONCHAM(IR_IONCHAM) );
          IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM;" go into the side wall "
          RETURN;
      ]   " end of the   r direction error block "

      "  now do the howfar job  "
      "========================="
      RF2_IONCHAM=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF( RF2_IONCHAM > RCYS2_IONCHAM(1,1) )
        [CUT_COE=CUTCOE_IONCHAM( R0SQ, RCYS2_IONCHAM(1,1) ); ]
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) )[
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM;
          RETURN;
      ]
      ELSEIF(IU_D=1)[" hits the TOP of this layer"
        ;$GEO_SHIFT_1_(STEP_UNIT);
         USTEP=STEP_UNIT;
         IF(IR_IONCHAM=1 & N_TOP_IONCHAM=0 & N_GAP_IONCHAM=0 )
           [ CALL WHERE_AM_I(ICM_IONCHAM,-1); ]  " and first layer of CM  "
         ELSEIF(IR_IONCHAM=1 & N_TOP_IONCHAM=0)
           [ IRNEW=IREND_IONCHAM;]
         ELSEIF( IR_IONCHAM=1 )[ " first layer of chamb, not for CM "
            RF2_IONCHAM= (X(NP)+USTEP*U(NP))*(X(NP)+USTEP*U(NP))
                +(Y(NP)+USTEP*V(NP))*(Y(NP)+USTEP*V(NP));
            IF(RF2_IONCHAM<RCYS2_IONCHAM(N_CHM_IONCHAM+N_TOP_IONCHAM,1))
            [IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3+2*(N_TOP_IONCHAM-1);]
            ELSE[IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3+
                2*(N_TOP_IONCHAM-1)+1;
            ]
         ]
         ELSE[IRNEW = IR(NP)-1;]
         RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
   ]   " end of the w<0.0 case"

   ELSE[ " W=0 CASE "
       CUT_COE=CUTCOE_IONCHAM( R0SQ, RCYS2_IONCHAM(1,1) );
       IF( CUT_COE>0.0 & CUT_COE<=USTEP ) [
           ;$GEO_SHIFT_1_(CUT_COE);
           USTEP=CUT_COE;
           IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM;
       ]
       RETURN;
   ]   " end of the w=0 case "
]     " end of the central chamber layer part "
      "=============================="

ELSEIF(IR_IONCHAM<=N_CHM_IONCHAM+3) [
   " in the side wall or side gap or container wall"
   IIR=IR_IONCHAM-N_CHM_IONCHAM;
   " iir = 1, wall; 2, side gap; 3 container wall "
   IF(W(NP) > 0.0)["particle going forward"
      DIST = (Z_IONCHAM(N_CHM_IONCHAM+1) - Z(NP))/W(NP);
        "distance to back of cham"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <=0.0)[      " out of this layer in z direction "
          USTEP=0.0;
          IF( N_BOT_IONCHAM=0 )[   " no bottom part "
              USTEP=1.E-16;
              CALL WHERE_AM_I(ICM_IONCHAM,1);
          ]
          ELSE[                    " has bottom part "
              IF(R0SQ< RCYS2_IONCHAM(N_CHM_IONCHAM+N_TOP_IONCHAM+1,1))[
                  " the first layer of the bottom "
                  IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3+2*N_TOP_IONCHAM;
              ]
              ELSE[ IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3+
                          2*N_TOP_IONCHAM+1;
              ]
          ]
          RETURN;
      ]
      " end of the double check if a particle is out of the wall in z direct

      " now check the r direction "
      "==========================="
      CRITERIOR_IR=R0SQ-RCYS2_IONCHAM(1,IIR);
      IF(CRITERIOR_IR<0.0)[" out of the region in r dir towards to center"
          USTEP=MIN(USTEP, SHIFT_COUNT_IONCHAM(IR_IONCHAM));
          IF(IIR=1)[
              " figure out the layer # the particle will go into."
              DO I=1, N_CHM_IONCHAM[
                 IF( Z(NP)<Z_IONCHAM(I+1) ) [ EXIT; ]
              ]
              I=MIN(I, N_CHM_IONCHAM);  " to avoid i > n_chm_$chamber "
              IRNEW=IRSTART_IONCHAM+I-1;
          ]
          ELSE[ IRNEW = IRL-1; ]
          RETURN;
      ]      " end of the  out to in check "
      IF( IIR~=3)[" when iir =3, no need to check the outer "
          CRITERIOR_IR=R0SQ-RCYS2_IONCHAM(1,IIR+1);
          IF(CRITERIOR_IR>0.0)[  " out side the outer radius "
              USTEP=MIN( USTEP, SHIFT_COUNT_IONCHAM(IR_IONCHAM) );
              IRNEW=IRL+1;
              RETURN;
          ]       " end of the warnning message block.
      ]        " end of the outer radius check
      " end of the r direction error block "

      " do the howfar job for this case "
      "================================="
      " first do the inner r "
      CUT_COE=CUTCOE_IONCHAM(R0SQ, RCYS2_IONCHAM(1,IIR));
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) )[  " hits the inner wall"
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)[ " figure out the layer # the particle will go into."
             DO I=1, N_CHM_IONCHAM[
                IF( Z(NP)+USTEP*W(NP)<Z_IONCHAM(I+1) ) [ EXIT; ]
             ]
             I=MIN(I, N_CHM_IONCHAM);  " to avoid i > n_chm_$chamber "
             IRNEW = IRSTART_IONCHAM+I-1;
          ]
          ELSE[ IRNEW=IRL-1;]
          RETURN;
      ]
      IF(CUT_COE<=0.0 & IIR~=3)[   " IT IS NECESSARY TO DO OUTER CSAE"
          CUT_COE=CUTCOE_IONCHAM(R0SQ, RCYS2_IONCHAM(1,IIR+1));
          IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
             |( CUT_COE=STEP_UNIT & IU_D=0 ) ) [  " hits the outer wall"
             ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
             USTEP=CUT_COE;
             IRNEW=IR(NP)+1;
             RETURN;
          ]
      ]     " not hits the side wall at all"

     " now check to see whether hitting the bottom  "

      IF(IU_D=1)[         " hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          " last layer of the CM, no bottom part"
          IF(N_BOT_IONCHAM=0 )[ CALL WHERE_AM_I(ICM_IONCHAM,1); ]
          ELSE[" particle will go into the first layer of the bottom part"
              RF2_IONCHAM= (X(NP)+USTEP*U(NP))**2
                        +(Y(NP)+USTEP*V(NP))**2;
              " the first layer of the bottom part "
              IF( RF2_IONCHAM< RCYS2_IONCHAM(N_CHM_IONCHAM+
                           N_TOP_IONCHAM+1,1) )
              [ IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3+2*N_TOP_IONCHAM; ]
              ELSE[ IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3+
                  2*N_TOP_IONCHAM+1;
              ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "

   ]   " end of the w> 0.0 case "

   " now do the w<0.0 case "
   "======================="
   ELSEIF(W(NP) < 0.0)["particle going backward"
      DIST = (Z_IONCHAM("0"1) - Z(NP))/W(NP); "distance to back layer "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0)[ " out of the region in z direction "
          USTEP=0.0;
          IF(N_TOP_IONCHAM=0 )[
              IF(N_GAP_IONCHAM = 1)[ IRNEW =IREND_IONCHAM;]
              ELSE [ USTEP=1.E-16; CALL WHERE_AM_I(ICM_IONCHAM,-1); ]
          ]
          ELSE[         " the last layer of the top part"
             IF(R0SQ<RCYS2_IONCHAM(N_CHM_IONCHAM+N_TOP_IONCHAM,1) )
             [IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3+2*(N_TOP_IONCHAM-1);]
             ELSE[ IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3+
                      2*(N_TOP_IONCHAM-1)+1;]
          ]
          RETURN;
      ] "end of the double check if a particle is out of the region"
            " in z direction"

      " now check the r direction to see if the region # is right or not"
      "================================================================"
      CRITERIOR_IR=R0SQ-RCYS2_IONCHAM(1,IIR);
      IF(CRITERIOR_IR<0.0)[" out of the region in r dir TOWARDS center  "
          USTEP=MIN( USTEP, SHIFT_COUNT_IONCHAM(IR_IONCHAM) );
          IF(IIR=1)[ "figure out the layer # the particle will go into."
             DO I=1, N_CHM_IONCHAM[IF(Z(NP)<Z_IONCHAM(I+1))[EXIT;]]
             I=MIN(I, N_CHM_IONCHAM);  " to avoid i > n_chm_$chamber "
             IRNEW=IRSTART_IONCHAM +I-1;
          ]
          ELSE[ IRNEW=IRL-1;  ]
          RETURN;
      ]  " end of the check for the inner radius case "
      IF( IIR~=3) [ " when iir =3, no need to check the outer "
          CRITERIOR_IR=R0SQ-RCYS2_IONCHAM(1,IIR+1);
          IF(CRITERIOR_IR>0.0)[  " out side the outer radius "
              USTEP=MIN(USTEP,SHIFT_COUNT_IONCHAM(IR_IONCHAM));
              IRNEW=IRL+1;
              RETURN;
          ]       " end of the warning message block.
      ]        " end of the outer radius check
      " end of the   r direction error block "

      " do the howfar job for this case "
      "=====================================
      CUT_COE=CUTCOE_IONCHAM(R0SQ, RCYS2_IONCHAM(1,IIR));
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) )[  " hits the inner wall"
         ; $GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)[ "figure out the layer # the particle will go into."
             DO I=1, N_CHM_IONCHAM[
                 IF( Z(NP)+USTEP*W(NP)<Z_IONCHAM(I+1) ) [ EXIT; ]
             ]
             I=MIN(I, N_CHM_IONCHAM);  " to avoid i > n_chm_$chamber "
             IRNEW=IRSTART_IONCHAM+I-1;
          ]
          ELSE[ IRNEW=IRL-1; ]
          RETURN;
      ]
      IF(CUT_COE<=0.0 & IIR~=3)[   " IT IS NECESSARY TO DO OUTER CSAE"
          CUT_COE=CUTCOE_IONCHAM( R0SQ, RCYS2_IONCHAM(1,IIR+1));
          IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
             |( CUT_COE=STEP_UNIT & IU_D=0 ) )[   " hits the outer wall"
             ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
             USTEP=CUT_COE;
             IRNEW=IRL+1;
             RETURN;
          ]
      ]     " not hits the side wall at all"

      " now check to see whether hitting the bottom  "
      "=============================================="
      IF(IU_D=1)[         " hits the TOP of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          IF(N_TOP_IONCHAM=0 )[ " the first layer of the CM, no top part "
             IF(N_GAP_IONCHAM=0)[ CALL WHERE_AM_I(ICM_IONCHAM,-1); ]
              " no air gap "
             ELSE[ IRNEW=IREND_IONCHAM; ]
          ]
          ELSE[ " particle will go into the last layer of the top part  "
            RF2_IONCHAM= (X(NP)+USTEP*U(NP))**2
                        +(Y(NP)+USTEP*V(NP))**2;
            IF(RF2_IONCHAM<RCYS2_IONCHAM(N_CHM_IONCHAM+N_TOP_IONCHAM,1))
              [IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3+
                      2*(N_TOP_IONCHAM-1); ]
            ELSE[IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3+
                      2*(N_TOP_IONCHAM-1)+1; ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
   ]        " end of the w<0.0 case "

   ELSE[ "  w=0 case "
      CUT_COE=CUTCOE_IONCHAM( R0SQ, RCYS2_IONCHAM(1,IIR));"inner wall first"
      IF(  CUT_COE>0.0 & CUT_COE <= USTEP )[  " hits the inner wall"
          ;$GEO_SHIFT_1_(CUT_COE);
          USTEP=CUT_COE;
          IF(IIR=1)[
             DO I=1, N_CHM_IONCHAM
             " figure out the layer # the particle will go into."
               [ IF( Z(NP)+USTEP*W(NP)<Z_IONCHAM(I+1) ) [ EXIT; ] ]
             I=MIN(I, N_CHM_IONCHAM);  " to avoid i > n_chm_$chamber "
             IRNEW=IRSTART_IONCHAM+I-1;
          ]
          ELSE[ IRNEW=IRL-1; ]
      ]
      IF(CUT_COE<=0.0 & IIR~=3)[ " IT IS NECESSARY TO DO OUTER CSAE"
          CUT_COE=CUTCOE_IONCHAM( R0SQ, RCYS2_IONCHAM(1,IIR+1));
          IF(  CUT_COE>0.0 & CUT_COE <= USTEP )[   " hits the outer wall"
             ;$GEO_SHIFT_1_(CUT_COE);
             USTEP=CUT_COE;
             IRNEW=IRL+1;
          ]
      ]
      RETURN;     " not hits the side wall at all"
   ]   " end of the w=0 case "
]      " end of the side of the ionchamber part"

" now do the top part of this CM "
"================================"
ELSEIF(IR_IONCHAM<=N_CHM_IONCHAM+3+2*N_TOP_IONCHAM )[ " top layers "
   IIR=IR_IONCHAM-(N_CHM_IONCHAM+3);
   IIR=MOD(IIR, 2);" iir=1, inside region, =0, outside region "
   IF(W(NP) > 0.0)   ["particle going forward"
      DIST = (Z_IONCHAM(LAYER+1) - Z(NP))/W(NP); "distance to back of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <=0.0)[
          USTEP=0.0;
          IF(LAYER=N_CHM_IONCHAM+N_TOP_IONCHAM )["the end of the top layer"
              IF( R0SQ<RCYS2_IONCHAM(1,1) ) [  IRNEW =IRSTART_IONCHAM;]
              ELSEIF( R0SQ<RCYS2_IONCHAM(1,2) )
                [IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM;]
              ELSEIF( R0SQ<RCYS2_IONCHAM(1,3) )
                [IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM+1;]
              ELSE[ IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM+2;]
          ]
          ELSE[
              IF( R0SQ< RCYS2_IONCHAM(LAYER+1,1) )[
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                       +2*(LAYER-N_CHM_IONCHAM);
              ]
              ELSE[
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                      +2*(LAYER-N_CHM_IONCHAM)+1;
              ]
          ]
          RETURN;
      ]
      " end of the double check if a particle is out of the CM in z direction

      " now check the r direction "
      "============================"
      CRITERIOR_IR=R0SQ-RCYS2_IONCHAM(LAYER, 1);
      IF(CRITERIOR_IR>0.0 & IIR=1)[  " out OF the  r "
         USTEP=MIN( USTEP, SHIFT_COUNT_IONCHAM(IR_IONCHAM) );
         IRNEW=IRL+1;
         RETURN;
      ]
      ELSEIF(CRITERIOR_IR<0.0 & IIR=0)[  " inside the outer radius "
         USTEP=MIN( USTEP, SHIFT_COUNT_IONCHAM(IR_IONCHAM) );
         IRNEW=IRL-1;
         RETURN;
      ]      " end of the warnning message block."


      " do the howfar job for this case "
      "=====================================
      RF2_IONCHAM=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF( ( RF2_IONCHAM > RCYS2_IONCHAM(LAYER,1) & IIR=1 ) | IIR=0 )
        [CUT_COE=CUTCOE_IONCHAM( R0SQ, RCYS2_IONCHAM(LAYER,1)); ]
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) )[" hits the inner wall"
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)[IRNEW=IRL+1; " from in to out "]
          ELSE[ IRNEW=IRL-1; ]
          RETURN;
      ]

      " now check to see whether hitting the bottom  "
      ELSEIF(IU_D=1) [" hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          RF2_IONCHAM= (X(NP)+USTEP*U(NP))**2
                   +(Y(NP)+USTEP*V(NP))**2;
          IF(LAYER=N_CHM_IONCHAM+N_TOP_IONCHAM)[ " last layer of the top"
              " particle will go into the first layer of the chamber  "
              IF( RF2_IONCHAM< RCYS2_IONCHAM(1,1) )
                [ IRNEW=IRSTART_IONCHAM;]
              ELSEIF ( RF2_IONCHAM< RCYS2_IONCHAM(1,2) )
                [ IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM;]
              ELSEIF ( RF2_IONCHAM< RCYS2_IONCHAM(1,3) )
                [ IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+1;]
              ELSE[ IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+2; ]
          ]     " end of the last layer of the top case "
          ELSE[
              IF( RF2_IONCHAM< RCYS2_IONCHAM(LAYER+1,1) )[
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                       +2*(LAYER-N_CHM_IONCHAM);
              ]
              ELSE [
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                      +2*(LAYER-N_CHM_IONCHAM)+1;
              ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
   ]                   " end of the w> 0 case "

   " now do the w<0 case "
   "====================="

   ELSEIF(W(NP) < 0.0)[     "particle going backward"
      "  the top layer in the top part "
      IF(LAYER=N_CHM_IONCHAM+1)[ DIST=( ZMIN_IONCHAM-Z(NP) )/W(NP); ]
      ELSE [ DIST = (Z_IONCHAM(LAYER) - Z(NP))/W(NP); ]
      "distance to back layer "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0) [
          USTEP=0.0;
          IF(LAYER=N_CHM_IONCHAM +1) [  " the first layer of the CM "
              IF(N_GAP_IONCHAM = 1)[ IRNEW =IREND_IONCHAM;]
              " has air gap "
              ELSE [ USTEP=1.E-16; CALL WHERE_AM_I(ICM_IONCHAM,-1); ]
                                            " no air gap "
          ]
          ELSE [
             IF(R0SQ<RCYS2_IONCHAM(LAYER-1,1) )[
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                       +2*(LAYER-2-N_CHM_IONCHAM);
             ]
             ELSE[
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                       +2*(LAYER-2-N_CHM_IONCHAM)+1;
             ]
          ]
          RETURN;
      ]
      "  end of the double check if a particle is out of the top layer in z"

      " now check the r direction "
      "============================"
      CRITERIOR_IR=R0SQ-RCYS2_IONCHAM(LAYER, 1);
      IF(CRITERIOR_IR>0.0 & IIR=1) [ "supposed to be in outside region"
         USTEP=MIN( USTEP, SHIFT_COUNT_IONCHAM(IR_IONCHAM) );
         IRNEW=IRL+1;
         RETURN;
      ]
      ELSEIF(CRITERIOR_IR<0.0 & IIR=0)["supposed to be in inside region"
         USTEP=MIN( USTEP, SHIFT_COUNT_IONCHAM(IR_IONCHAM) );
         IRNEW=IRL-1;
         RETURN;
      ]      " end of the warnning message block."

      " do the howfar job for this case "
      "=====================================
      RF2_IONCHAM=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF( ( RF2_IONCHAM > RCYS2_IONCHAM(LAYER,1) & IIR=1 ) | IIR=0 )
        [CUT_COE=CUTCOE_IONCHAM(R0SQ, RCYS2_IONCHAM(LAYER,1)); ]
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) ) [" hits the side  wall"
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)  [  IRNEW=IRL+1; " from in to out "]
          ELSE[ IRNEW=IRL-1; ]
          RETURN;
      ]

      " now check to see whether hitting the top  "
      "==========================================="
      ELSEIF(IU_D=1) [" hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          RF2_IONCHAM= (X(NP)+USTEP*U(NP))**2
                   +(Y(NP)+USTEP*V(NP))**2;
          IF(LAYER=N_CHM_IONCHAM+1) [ " the first layer of the top"
              " particle will go into the air gap or out of the CM  "
              IF( N_GAP_IONCHAM=1 ) [ IRNEW=IREND_IONCHAM;]
              ELSE[ CALL WHERE_AM_I(ICM_IONCHAM, -1); ]
          ]     " end of the last layer of the top case "
          ELSE[         " still inside the top part "
              IF( RF2_IONCHAM< RCYS2_IONCHAM(LAYER-1,1) )[
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                       +2*(LAYER-N_CHM_IONCHAM-2);
              ]
              ELSE[
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                      +2*(LAYER-N_CHM_IONCHAM-2)+1;
              ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
  ]   " end of the w< 0.0 case "

  " now do  the w=0.0 case "
  "========================"
   ELSE [
      CUT_COE=CUTCOE_IONCHAM(R0SQ, RCYS2_IONCHAM(LAYER,1));
      IF(  CUT_COE>0.0 & CUT_COE <= USTEP )  [ " hits the  wall"
          ;$GEO_SHIFT_1_(CUT_COE);
          USTEP=CUT_COE;
          IF(IIR=1)[ IRNEW=IRL+1;]
          ELSE[ IRNEW=IRL-1; ]
      ]
      RETURN;
   ]    " end of the w=0.0 case "
]      " end of the top part "

" now do the bottom part "
"========================"
ELSEIF(IR_IONCHAM<=N_CHM_IONCHAM+3+2*N_TOP_IONCHAM+2*N_BOT_IONCHAM )[
   IIR=IR_IONCHAM-(N_CHM_IONCHAM+3);
   IIR=MOD(IIR, 2);      " iir=1, inside , iir=2, out side region "
   IF(W(NP) > 0.0)[        "particle going forward"
      DIST = (Z_IONCHAM(LAYER+1) - Z(NP))/W(NP); "distance to back of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <=0.0) [
          USTEP=0.0;
          IF(LAYER=N_CHM_IONCHAM+N_TOP_IONCHAM+N_BOT_IONCHAM)
             [  USTEP=1.E-16; CALL WHERE_AM_I(ICM_IONCHAM, 1); ]
          " the end layer of the  bottom part and the CM"
          ELSE[
              IF( R0SQ< RCYS2_IONCHAM(LAYER+1,1) )[
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                        +2*(LAYER-N_CHM_IONCHAM);
              ]
              ELSE[
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                        +2*(LAYER-N_CHM_IONCHAM)+1;
              ]
          ]
          RETURN;
      ]
      " end of the double check if a particle is out of region in z direction"

      " now check the r direction "
      "============================="
      CRITERIOR_IR=R0SQ-RCYS2_IONCHAM(LAYER, 1);
      IF(CRITERIOR_IR>0.0 & IIR=1)["supposed to be in the outer region"
         USTEP=MIN( USTEP, SHIFT_COUNT_IONCHAM(IR_IONCHAM) );
         IRNEW=IRL+1;
         RETURN;
      ]
      ELSEIF(CRITERIOR_IR<0.0 & IIR=0)["supposed to be in inside region"
         USTEP=MIN( USTEP, SHIFT_COUNT_IONCHAM(IR_IONCHAM) );
         IRNEW=IRL-1;
         RETURN;
      ]      " end of the warnning message block."

      " do the howfar job for this case "
      "=====================================
      RF2_IONCHAM=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF( ( RF2_IONCHAM > RCYS2_IONCHAM(LAYER,1) & IIR=1 ) | IIR=0 )
        [ CUT_COE=CUTCOE_IONCHAM( R0SQ, RCYS2_IONCHAM(LAYER,1)); ]
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) )[" hits the side wall"
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)[  IRNEW=IRL+1; " from in to out "]
          ELSE[ IRNEW=IRL-1; ]
          RETURN;
      ]    " end of the hitting the side wall case "

      " now check to see whether hitting the bottom  "
      "=============================================="
      ELSEIF(IU_D=1) [        " hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          RF2_IONCHAM= (X(NP)+USTEP*U(NP))**2
                   +(Y(NP)+USTEP*V(NP))**2;
          IF(LAYER=N_CHM_IONCHAM+N_TOP_IONCHAM+N_BOT_IONCHAM )
             [  CALL WHERE_AM_I(ICM_IONCHAM, 1) ; ]
          "last layer of the CM"
          ELSE [
              IF( RF2_IONCHAM< RCYS2_IONCHAM(LAYER+1,1) ) [
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                       +2*(LAYER-N_CHM_IONCHAM);
              ]
              ELSE[
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                      +2*(LAYER-N_CHM_IONCHAM)+1;
              ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
   ]   " end of the w>0.0 case "
       "========================"

   ELSEIF(W(NP) < 0.0)[       "particle going backward"
      IF(LAYER=N_CHM_IONCHAM+N_TOP_IONCHAM+1)
        [ DIST=( Z_IONCHAM(N_CHM_IONCHAM+1)-Z(NP) )/W(NP); ]
      "  the top layer in the bottom part "
      ELSE [ DIST = (Z_IONCHAM(LAYER-1+1) - Z(NP))/W(NP); ]
            "distance to back layer "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0)[
          USTEP=0.0;
          IF( LAYER=N_CHM_IONCHAM+N_TOP_IONCHAM+1 ) [
              " the first layer of the bottom "
              IF( R0SQ<RCYS2_IONCHAM(1,1) )
                [  IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM-1;]
              " the last layer of the cham"
              ELSEIF( R0SQ<RCYS2_IONCHAM(1,2) )
                [IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM;]
              " the side wall region"
              ELSEIF( R0SQ<RCYS2_IONCHAM(1,3) )
                [IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM+1;]
              " the side gap region "
              ELSE[ IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM+2;]
              " outtest container region "
          ]
          ELSE[
             IF(R0SQ<RCYS2_IONCHAM(LAYER-1,1) )[
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                       +2*(LAYER-2-N_CHM_IONCHAM);
             ]
             ELSE [
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                       +2*(LAYER-2-N_CHM_IONCHAM)+1;
             ]
          ]
          RETURN;
      ] "end of the double check if a particle is out of the region in z"

      " now check the r direction "
      "============================"
      CRITERIOR_IR=R0SQ-RCYS2_IONCHAM(LAYER, 1);
      IF(CRITERIOR_IR>0.0 & IIR=1)  [" supposed to be outside  "
         USTEP=MIN( USTEP, SHIFT_COUNT_IONCHAM(IR_IONCHAM) );
         IRNEW=IRL+1;
         RETURN;
      ]
      ELSEIF(CRITERIOR_IR<0.0 & IIR=0) [ " supposed to be inside "
         USTEP=MIN( USTEP, SHIFT_COUNT_IONCHAM(IR_IONCHAM) );
         IRNEW=IRL-1;
         RETURN;
      ]      " end of the warnning message block."

      " do the howfar job for this case "
      "=====================================
      RF2_IONCHAM=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF( ( RF2_IONCHAM > RCYS2_IONCHAM(LAYER,1) & IIR=1 ) | IIR=0 )
        [CUT_COE=CUTCOE_IONCHAM( R0SQ, RCYS2_IONCHAM(LAYER,1)); ]
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) ) [ " hits the inner wall"
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)[  IRNEW=IRL+1; " from in to out "]
          ELSE[ IRNEW=IRL-1; ]
          RETURN;
      ]

      " now check to see whether hitting the top  "
      ELSEIF(IU_D=1) [ " hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          RF2_IONCHAM= (X(NP)+USTEP*U(NP))**2
                   +(Y(NP)+USTEP*V(NP))**2;
          IF(LAYER=N_CHM_IONCHAM+N_TOP_IONCHAM+1)[
              " the first layer of the bottom"
              " particle will go into the chamber   "
              IF( RF2_IONCHAM<RCYS2_IONCHAM(1,1) )
                [IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM-1;]
              "the last layer of the cham"
              ELSEIF( RF2_IONCHAM<RCYS2_IONCHAM(1,2) )
                [IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM;]
               " the side wall region"
              ELSEIF( RF2_IONCHAM<RCYS2_IONCHAM(1,3) )
                [IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM+1;]
              " the side gap region "
              ELSE[ IRNEW =IRSTART_IONCHAM+N_CHM_IONCHAM+2;]
              "outtest container region "
          ]     " end of the last layer of the bottom case "
          ELSE[  " still inside the bottom part "
              IF( RF2_IONCHAM< RCYS2_IONCHAM(LAYER-1,1))[
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                       +2*(LAYER-N_CHM_IONCHAM-2);
              ]
              ELSE[
                 IRNEW=IRSTART_IONCHAM+N_CHM_IONCHAM+3
                      +2*(LAYER-N_CHM_IONCHAM-2)+1;
              ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
   ]   " end of the w< 0.0 case "

   ELSE[ " now do  the w=0.0 case "
         "========================"
      CUT_COE=CUTCOE_IONCHAM( R0SQ, RCYS2_IONCHAM(LAYER,1));
      IF(  CUT_COE>0.0 & CUT_COE <= USTEP )  [" hits the  wall"
         ; $GEO_SHIFT_1_(CUT_COE);
          USTEP=CUT_COE;
          IF(IIR=1)
            [ IRNEW=IRL+1;]
          ELSE[ IRNEW=IRL-1; ]
      ]
      RETURN;
   ]    " end of the w=0.0 case "

]   " end of the bottom part "
       "======================="



"   outside of CM, something is wrong
"   =================================
"
ELSE ["something is wrong"
   OUTPUT IR(NP)-IRSTART_IONCHAM+1,IR(NP),ICM_IONCHAM,
          IR_start_CM(ICM_IONCHAM);
      (//' ************'//' HOWFAR-CHAMBER error'/
         '    Region, local, absolute =',2I5/
         '    CM number=',I5,' start region =',I5/
         ' *********'//);
   STOP;
] "end of IF statement"
;
"   end of HOWFAR_IONCHAM
"   ===================
"
END; "End of subroutine HOWFAR_IONCHAM"

%E "Start of miscellaneous functions and subroutines"

;$REAL FUNCTION SHIFT_COUNT_IONCHAM(IDUMP);
"This function is used in finding the correct region. If a particle is
"in a wrong region we change the region # and shift the particle by 1.0E-5.
"If we still cannot find the correct region after 20 shifts we terminate the
"particle. If 10000 particles have been discarded we quit! However, one
"can carry on running this simulation using the BEAM re-start feature if he
"considers the effect of discarding these particles would be negligible
"for a large number of histories run.

;IMPLICIT NONE;

;COMIN/STACK, EPCONT,CM_IONCHAM,SCORE,EGS-IO/;

$LONG_INT IHSTRYOLD;
INTEGER IDUMP, COUNT1, COUNT;
$REAL XYZNEW,XYZOLD,xyzoldsave;
save xyzold,count1,count;
DATA count1,count/0,0/;
XYZNEW=X(NP)+Y(NP)+Z(NP);
IF( XYZNEW.NE.XYZOLD.OR.IHSTRY.NE.IHSTRYOLD)[ COUNT1=0;]
     " This fudge is used just to get around a numerical accuracy "
     " problem.  It is OK unless you receive the error message in "
     " the next if statement a lot of times.  "
     " IHSTRY check added to protect against incrementing COUNT1"
     " when phase space source is incident right on boundary of"
     " chamber and particles are recycled"
ELSE[
    COUNT1=COUNT1+1;
    IF( COUNT1=20 ) [
        OUTPUT IDUMP,X(NP),Y(NP),X(NP)**2+Y(NP)**2,Z(NP),U(NP),
        V(NP),W(NP),E(NP),IQ(NP);
        (/' WARNING FROM CHAMBER REGION ', I5,': TAKEN USTEP = 1.0E-5 ',
         ' FOR 20 TIMES, STILL CANNOT FIND ITS REGION'/
         ' THE PARTICLE HAS BEEN DISCARDED.'/
         ' OUTPUT: x,y,r**2,z,u,v,w,E,IQ '/
        8F11.6,I3);
        IDISC=1;COUNT1=0;
        SHIFT_COUNT_IONCHAM=0.0;
        COUNT=COUNT+1;
        IF( COUNT >10000 )[
          OUTPUT;(//' ChAMBER: 10000 PARTICLES HAVE BEEN DISCARDED DUE TO'/
                     ' WRONG REGION #/BOUNDARY CROSSING ERROR. STOP!!!'//);
          STOP;
        ]
    ]
]
XYZOLD=XYZNEW;
IHSTRYOLD=IHSTRY;

SHIFT_COUNT_IONCHAM=1.0E-5;

RETURN;
END;

"******************************************************************

SUBROUTINE WARN_MES_IONCHAM(IDUMP, DUMP1, DUMP2);
IMPLICIT NONE;
COMIN/EGS-IO/;
INTEGER IDUMP, COUNT;
$REAL DUMP1, DUMP2;

    OUTPUT IDUMP, DUMP1, DUMP2; (/' WARNING MESSAGE: ' , I5, 2F15.8);
    COUNT=COUNT+1;
RETURN;
END;

"******************************************************************
;

$REAL FUNCTION CUTCOE_IONCHAM( DUMP1, DUMP2 );
IMPLICIT NONE;

$REAL  DUMP1, DUMP2;
;COMIN/STACK, CM_IONCHAM/;

$REAL A, B, B2, C, TEMP, CUT_COE1, CUT_COE2,one;
parameter (one=1);

A=U(NP)**2+V(NP)**2;
B=X(NP)*U(NP)+Y(NP)*V(NP);
B2=B**2;
C=DUMP1-DUMP2;
IF(A=0.0)[
     IF(B~=0.0)[CUTCOE_IONCHAM=-0.5*C/B;]
     ELSE[ CUTCOE_IONCHAM=-1.0E5; ]
]
ELSE[
    TEMP=B2-A*C;
    IF(TEMP>=0.0)[
       TEMP=-(B+SIGN(one,B)*SQRT(TEMP) );
       CUT_COE1=TEMP/A;
       CUT_COE2=C/TEMP;
       IF( CUT_COE1>0.0 & CUT_COE2>0.0)
       [CUTCOE_IONCHAM=MIN(CUT_COE1,CUT_COE2); ]
       ELSE[ CUTCOE_IONCHAM=MAX(CUT_COE1,CUT_COE2); ]
    ]
    ELSE [ CUTCOE_IONCHAM=-1.0E5; ]
]

RETURN;
END; "End of miscellaneous subroutines and functions"

%E    "Start of subroutine WHERE_AM_I_IONCHAM"
"******************************************************************************

"******************************************************************************
"
"                          Subroutine WHERE_AM_I_IONCHAM
"                          ***************************
"
" WHERE_AM_I routine for a stacked right cylinder slabs.
"
" WHERE_AM_I_IONCHAM determines the new region # when a particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_IONCHAM subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_IONCHAM from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"******************************************************************************

;SUBROUTINE WHERE_AM_I_IONCHAM(IDIR);


;IMPLICIT NONE;

;COMIN/CMs,CM_IONCHAM,EPCONT,STACK/;

"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_IONCHAM
"T>**************************************
"T>

INTEGER IDIR;  "T>direction of particle, +1=forward, -1=backward
$REAL XBDY_IONCHAM,YBDY_IONCHAM,RBDY2_IONCHAM;
XBDY_IONCHAM = X(NP) + U(NP)*USTEP;
YBDY_IONCHAM = Y(NP) + V(NP)*USTEP;
RBDY2_IONCHAM = XBDY_IONCHAM*XBDY_IONCHAM + YBDY_IONCHAM*YBDY_IONCHAM;
IF((IRSTART_IONCHAM = 2) & (IDIR =1))    " this is first CM and from front
  [ RBDY2_IONCHAM = X(NP)*X(NP) + Y(NP)*Y(NP); ]

IF (IDIR=1) ["particle entering this CM through front face (upstream)
   IF(N_GAP_IONCHAM = 0) [        "no air gap this CM"
      IF(N_TOP_IONCHAM=0)    [" no top layers above the ionchamber.
         IF(RBDY2_IONCHAM < RCYS2_IONCHAM(1,1))
           [ IRNEW = IRSTART_IONCHAM;   ]     " center
         ELSEIF(RBDY2_IONCHAM < RCYS2_IONCHAM(1, 2))
           [   IRNEW = IRSTART_IONCHAM + N_CHM_IONCHAM;]  " side wall
         ELSEIF(RBDY2_IONCHAM < RCYS2_IONCHAM(1, 3))
           [IRNEW = IRSTART_IONCHAM + N_CHM_IONCHAM+1; ]     " side gap
         ELSE[ IRNEW = IRSTART_IONCHAM +N_CHM_IONCHAM+2 ; ] " container wall
      ]
      ELSE["   has top layer."
         IF(RBDY2_IONCHAM < RCYS2_IONCHAM(N_CHM_IONCHAM+1,1))
           [ IRNEW = IRSTART_IONCHAM + N_CHM_IONCHAM +3; ]
         ELSE[ IRNEW = IRSTART_IONCHAM + N_CHM_IONCHAM +3 +1; ]
      ]
   ]
   ELSE [  IRNEW = IREND_IONCHAM; ]"this CM has an air gap at the front"
]  " end of idir=1 case
ELSE ["particle entering this CM through back face (downstream)
   IF( N_BOT_IONCHAM=0 )[ " no bottom layers below the chamber
      IF(RBDY2_IONCHAM < RCYS2_IONCHAM(1,1))
        [ IRNEW = IRSTART_IONCHAM-1+N_CHM_IONCHAM;   ]     " center
      ELSEIF(RBDY2_IONCHAM < RCYS2_IONCHAM(1, 2))
        [ IRNEW = IRSTART_IONCHAM+N_CHM_IONCHAM ;]  " side wall
      ELSEIF(RBDY2_IONCHAM < RCYS2_IONCHAM(1, 3))
        [IRNEW = IRSTART_IONCHAM +N_CHM_IONCHAM+ 1; ]     " side gap
      ELSE[ IRNEW = IRSTART_IONCHAM+N_CHM_IONCHAM + 2; ] " container wall
   ]
   ELSE["   has bottom layer.
      IF(RBDY2_IONCHAM
       < RCYS2_IONCHAM(N_CHM_IONCHAM+N_TOP_IONCHAM+N_BOT_IONCHAM,1))
        [ IRNEW = IREND_IONCHAM-N_GAP_IONCHAM-1; ]
      ELSE[ IRNEW =IREND_IONCHAM-N_GAP_IONCHAM; ]
   ]
]

RETURN;

END; "End of subroutine WHERE_AM_I_IONCHAM"

%E   "Start of subroutine INPUT_IONCHAM"
"*******************************************************************************
"
"                           Subroutine INPUT_IONCHAM
"                           **********************
"
"  A CM input subroutine for a cylindrical planar geometry.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_IONCHAM;


;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_IONCHAM,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;
"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_IONCHAM
"T>*********************************
"T>

$REAL   ZTHICK_IONCHAM, "T>total thickness of CM
        ZTHICK,          "T>temp. variable used to store layer thicknesses
        THICK1, THICK2, THICK3, "T>temp. storage of total thicknesses
        Zminthick,       "T>used to calc. min thickness for range rejection
        RCYSTEMP($MAX_N_IONCHAM), "T>used for inputting top part
        ZTEMP($MAX_N_IONCHAM),    "T>used for inputting top part
        ECUTTEMP($MXREG),          "T>used for inputting top part
        PCUTTEMP($MXREG);          "T>used for inputting top part

INTEGER I,IM,J,JM, II, III,        "T>DO loop indeces
        MRNGE,          "T> local variable = 1 to enable ECUTRR calculation
                        "T> otherwise ECUTRR is not calculated
        IRA,            "T>Absolute region number
        MED_FLAG,       "T>flag used by media-sort macro $MED_INPUT
        MED_INDEX,      "T>medium index, set after medium sort by $MED_INPUT
        N_CHAM,         "T>used to keep track of number of layers in chamber
        DOSE_ZONETEMP($MXREG),  "T>used for inputting top part
        IREGION_TO_BITTEMP($MXREG), "T>used for inputting top part
        MEDTEMP($MXREG),          "T>used for inputting top part
        IRM;                      "T>used for inputting top part
"
"  initialize parameters
"  =====================
"
ICM_IONCHAM = ICM;     "CM index for this component module
IRSTART_IONCHAM = IR_start_CM(ICM_IONCHAM);
              "Index of first region in this CM,
              "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_IONCHAM) = 0; "Geometry-checking flag, 0 if no error detected

DO I=1,NDOSE_ZONE[ZPLOTCHM(I)=-1000.;"set default values"]

"
"  get the title line
"  ==================
"
OUTPUT;(/' IONCHAM  (CHAMBER)');
OUTPUT RMAX_CM(ICM);
     (/' This component is an ion chamber or for scoring dose components'/
       '       Outer boundary is a cylinder of radius',F10.4,' cm'
       //' TITLE: ',$);
;MINPUT (IONCHAM) TITLE_IONCHAM;(60A1);
OUTPUT TITLE_IONCHAM;(' ',60A1);

IF (ICM_IONCHAM = 1)[OUTPUT Z_min_CM(1);
   (' This is first component module -- starts at',F12.4,
                                          ' cm from ref plane(z=0)');
]
ELSE [OUTPUT Z_min_CM(ICM_IONCHAM);
   (' This CM, including air gap, starts at end of previous CM at', F10.5,
    ' cm');
]
"
" get distance from reference plane, z=0"
"   =============================
OUTPUT;
(/' Distance from front of IONCHAM(not air gap) to ref plane(z=0):',$);
;MINPUT (IONCHAM) ZMIN_IONCHAM;(F15.0);
OUTPUT ZMIN_IONCHAM;(F11.5);

IF(ZMIN_IONCHAM < Z_min_CM(ICM_IONCHAM))[
   IF(ICM_IONCHAM=1)[
      OUTPUT ICM_IONCHAM, ZMIN_IONCHAM,Z_min_CM(ICM_IONCHAM);
       (//' ***WARNING IN CM ',I4,' (CHAMBER):'/
          ' Z_min_CM(1) > distance to top of chamber'/
          ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm '//);
          WRITE(IOUTLIST,100)
        ICM_IONCHAM, ZMIN_IONCHAM,Z_min_CM(ICM_IONCHAM);
     100 FORMAT(//' ***WARNING IN CM ',I4,' (CHAMBER):'/
          ' Z_min_CM(1) > distance to top of chamber'/
          ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm '//);
       Z_min_CM(ICM_IONCHAM)=ZMIN_IONCHAM;
   ]
   ELSE[
     OUTPUT ICM_IONCHAM;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'Overlaps with previous CM'//);
       IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
   ]
]
OUTPUT; (/' This module consists of 3 partS:',
         /'   1 --- top part, ',
         /'   2 --- main part: the chamber/phantom central part, ',
         /'   3 --- bottom part.');
OUTPUT $MAX_N_IONCHAM-1;
(/' Input the number of layers for each part: '/
' N-TOP (>=0), N-CHAM (>0 to input chamber layers individually or <0 to'/
' input -N-CHAM groups of layers), N-BOT (>=0) (N-TOP + total number of'/
' chamber layers + N-BOT <= ',I4,') on one line'/
' : ',$);
;MINPUT (IONCHAM) N_TOP_IONCHAM, N_CHM_IONCHAM, N_BOT_IONCHAM;(3I5);
OUTPUT N_TOP_IONCHAM, N_CHM_IONCHAM,  N_BOT_IONCHAM;(3I9);
IF(N_CHM_IONCHAM=0)[
   OUTPUT ICM_IONCHAM;
     (//'***ERROR IN CM ',I4,' (CHAMBER)'/
        'N-CHAM = 0'/
        'N-CHAM reset to 1 for now.'//);
   N_CHM_IONCHAM=1;
   IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
]
IF(N_TOP_IONCHAM < 0)[
   OUTPUT ICM_IONCHAM; (//'***ERROR IN CM ',I4,' (CHAMBER)'/
        'N-TOP < 0'/ 'N-TOP reset to 0 for now.'//);
   N_TOP_IONCHAM=0;
   IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
]
IF(N_BOT_IONCHAM < 0)[
   OUTPUT ICM_IONCHAM;
     (//'***ERROR IN CM ',I4,' (CHAMBER)'/
        'N-BOT < 0'/ 'N-BOT reset to 0 for now.'//);
   N_BOT_IONCHAM=0;
   IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
]
IF(N_CHM_IONCHAM>0 &
   N_CHM_IONCHAM+N_TOP_IONCHAM+N_BOT_IONCHAM > $MAX_N_IONCHAM-1)[
   N_BOT_IONCHAM=0;
   N_TOP_IONCHAM=0;
   N_CHM_IONCHAM=$MAX_N_IONCHAM-1;
   OUTPUT ICM_IONCHAM, $MAX_N_IONCHAM-1;
    (//'***ERROR IN CM ',I4,' (CHAMBER):'/
       'N-CHAM + N-TOP + N-BOT > max. # of layers allowed.'/
       'N-TOP set to 0, N-BOT set to 0, N-CHAM set to ',I4,' for now.'//);
   IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
]

IF(N_CHM_IONCHAM>0)[
   N_IONCHAM = N_CHM_IONCHAM+3+ 2*N_TOP_IONCHAM+2*N_BOT_IONCHAM;
]
"Number of regions in this CM (<50, excluding front air gap)"
"
"                  INPUT for TOP REGION
"                  ====================
"
IF(N_TOP_IONCHAM~=0)[
  OUTPUT N_TOP_IONCHAM;
  (/' Input thickness (ZTHICK) & inner radius (RCYL) for each of',
   ' the',I3,' layers'/' for the top part.'
  /' Note that the inner radius, RCYL divides each layer into 2',
  ' regions,'/
  ' an inner disc-shaped region and an outer annular region.',
  /' The outer boundary of the annular region is RMAX_CM.');
  OUTPUT;(/
  ' For layers of equal thickness, inner radius and medium, '/
  ' Input ZTHICK,RCYL & N-TOP, in one line)'/
  ' Otherwise, input ZTHICK & RCYL for each layer starting from 1ST',
  ' layer'/ ' : ',$);
  IM=1;"starting # for the top part"
  ;MINPUT (IONCHAM) ZTHICK, RCYSTEMP(IM),JM;(2F15.0,I5);
  OUTPUT ZTHICK, RCYSTEMP(IM),JM;(2F15.5,I5);
  IF(ZTHICK<0.0)[
     OUTPUT ICM_IONCHAM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Thickness of layer 1 in top part < 0.0.'//);
     IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
  ]
  IF(RCYSTEMP(IM)<0.0)[
     OUTPUT ICM_IONCHAM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'RCYS of layer 1, top part < 0.0'//);
     IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
  ]
  ELSEIF(RCYSTEMP(IM) > RMAX_CM(ICM_IONCHAM))[
     OUTPUT ICM_IONCHAM;
      (//'***WARNING IN CM ',I4,' (CHAMBER):'/
         'RCYS of layer 1, top part > RMAX_CM'//);
     WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,
       '' (CHAMBER):''/ ''RCYS of layer 1, top part > RMAX_CM''//)')
        ICM_IONCHAM;
  ]
  ZTEMP(IM)=ZMIN_IONCHAM+ZTHICK;

  IF(JM = N_TOP_IONCHAM)["for equal thickness, radius and medium"
     IRM=1;
     OUTPUT N_TOP_IONCHAM;
     (/' All the',I5,' layers have the same thickness, inner radius'/);
     "1st (inner) region in the top part"
     OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose)',
        ',IREGION_TO_BIT for inner regions'/' :',$);
     ;MINPUT (IONCHAM) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM);
     (2F15.0,2I5);
     IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
     IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
     ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IM),
        IREGION_TO_BITTEMP(IM); (2F10.4, I5,I15);
     OUTPUT;(/' For inner regions:',$);
     ;$MED_INPUT(IONCHAM); " inputs character array MED_IN from unit 5,
                            " loops
     "through array MEDIA(24,I) to check if medium was previously input.
     "If so, sets MED_INDEX to index of previous medium.  If not,
     "increments NMED and sets MED_INDEX to NMED.
     MEDTEMP(IRM) = MED_INDEX; " medium of the slab
     IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_IONCHAM, $MAX_DOSE_ZONE;
       (/'***ERROR IN CM ',I4,' (CHAMBER):'/
       'DOSE_ZONE # of inner cylinders in top part > $MAX_DOSE_ZONE.'/
       'DOSE_ZONE set to ',I4,' for now.'/
       'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
     ]
     IRM = IRM+1;"for outer region of this layer"
     ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',
     ' for outer regions'/' :',$);
     ;MINPUT (IONCHAM) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM); (2F15.0,2I5);
     IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
     IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
     ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM);(2F10.4, I5,I15);
     OUTPUT;(/' For outer regions:',$);
     ;$MED_INPUT(IONCHAM);
     MEDTEMP(IRM) = MED_INDEX;
     IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_IONCHAM, $MAX_DOSE_ZONE;
       (/'***ERROR IN CM ',I4,' (CHAMBER):'/
       'DOSE_ZONE # of annuli in top part > $MAX_DOSE_ZONE.'/
       'DOSE_ZONE set to ',I4,' for now.'/
       'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
     ]
     DO IM=2,N_TOP_IONCHAM[
        ZTEMP(IM)=ZTEMP(IM-1)+ZTHICK;
        RCYSTEMP(IM)=RCYSTEMP(1);
        IRM = IRM+1;"for inner region of this layer"
        ECUTTEMP(IRM)=ECUTTEMP(1);
        PCUTTEMP(IRM)=PCUTTEMP(1);
        DOSE_ZONETEMP(IRM)=DOSE_ZONETEMP(1);
        IREGION_TO_BITTEMP(IRM)=IREGION_TO_BIT(1);
        MEDTEMP(IRM) = MED(1);
        IRM = IRM+1;"for outer region of this layer"
        ECUTTEMP(IRM)=ECUTTEMP(2);
        PCUTTEMP(IRM)=PCUTTEMP(2);
        DOSE_ZONETEMP(IRM)=DOSE_ZONETEMP(2);
        IREGION_TO_BITTEMP(IRM)=IREGION_TO_BIT(2);
        MEDTEMP(IRM) = MED(2);
     ]
  ]"end of equal thickness, radius and media inputs"

  ELSE["for different thicknesses, radii or media"
     IF(N_TOP_IONCHAM>1)[
        OUTPUT N_TOP_IONCHAM;
        (/' The',I5,' layers have different inner radii, thickness,',
         /' and/or media');
     ]
     OUTPUT 1;(/' For layer',I4,' in top part:');
     OUTPUT ZTHICK,RCYSTEMP(IM);
     (/' ZTHICK & RCYL =',2F15.5);
     IRM=1;
     OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose)',
     ',IREGION_TO_BIT for inner region'/' :',$);
     ;MINPUT (IONCHAM) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM); (2F15.0,2I5);
     IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
     IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
     ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM); (2F10.4, I5,I15);
     OUTPUT;(/' For inner region:',$);
     ;$MED_INPUT(IONCHAM);
     "inputs character array MED_IN from unit 5, loops
     "through array MEDIA(24,I) to check if medium was previously input.
     "If so, sets MED_INDEX to index of previous medium.  If not,
     "increments NMED and sets MED_INDEX to NMED.
     MEDTEMP(IRM) = MED_INDEX; " medium of the planar slab
     IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_IONCHAM, $MAX_DOSE_ZONE;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
 'DOSE_ZONE # of inner cylinder in 1st layer, top part > $MAX_DOSE_ZONE.'/
 'DOSE_ZONE # set to ',I4,' for now.'/
    'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
     ]
     IRM = IRM+1;"for outer region of this layer"
     ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',
     ' for outer region'/' :',$);
     ;MINPUT (IONCHAM) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM); (2F15.0,2I5);
     IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
     IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
     ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM); (2F10.4, I5,I15);
     OUTPUT;(' For outer region:',$);
     ;$MED_INPUT(IONCHAM);
     MEDTEMP(IRM) = MED_INDEX;
     IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_IONCHAM, $MAX_DOSE_ZONE;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
  'DOSE_ZONE # of outer annulus in 1st layer, top part > $MAX_DOSE_ZONE.'/
     'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
     ]
     DO IM=2, N_TOP_IONCHAM[
        OUTPUT IM;
        (/' FOR LAYER',I4,' IN TOP PART:');
        OUTPUT;
        (/' ZTHICK & RCYL:',$);
        ;MINPUT (IONCHAM) ZTHICK, RCYSTEMP(IM);(2F15.0);
        OUTPUT ZTHICK, RCYSTEMP(IM);(2F15.5);
        IF( RCYSTEMP(IM)<0.0 )[
          OUTPUT ICM_IONCHAM, IM-N_CHM_IONCHAM;
           (//'***ERROR IN CM ',I4,' (CHAMBER):'/
              'Radius of inner cylinder in layer ',I4,' of top part < 0.0'//);
          IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
        ]
        ELSEIF(RCYSTEMP(IM) > RMAX_CM(ICM_IONCHAM))[
          OUTPUT ICM_IONCHAM, IM-N_CHM_IONCHAM;
           (//'***WARNING IN CM ',I4,' (CHAMBER):'/
          'Radius of inner cylinder in layer ',I4,' of top part > RMAX_CM'//);
         WRITE(IOUTLIST,'(//''***WARNING IN CM '',
         I4,'' (CHAMBER):''/
         ''Radius of inner cylinder in layer '',
         I4,'' of top part > RMAX_CM''//)')
         ICM_IONCHAM, IM-N_CHM_IONCHAM;
        ]
        IF(ZTHICK<0.0)[
           OUTPUT ICM_IONCHAM, IM-N_CHM_IONCHAM;
          (//'***ERROR IN CM ',I4,' (CHAMBER):'/
             'Thickness of layer ',I4,' in top part < 0.0'//);
           IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
        ]
        ZTEMP(IM)=ZTEMP(IM-1)+ZTHICK;
        OUTPUT ZTHICK, RCYSTEMP(IM);(2F15.5);
        IRM = IRM+1;"inner region of this layer"
        OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose)',
                ',IREGION_TO_BIT for inner region'/' :',$);
        ;MINPUT (IONCHAM) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
                           IREGION_TO_BITTEMP(IRM); (2F15.0,2I5);
        IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
        IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
        ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IRM),
                              IREGION_TO_BITTEMP(IRM); (2F10.4, I5,I15);
        OUTPUT;(/' For inner region:',$);
        ;$MED_INPUT(IONCHAM);
        MEDTEMP(IRM) = MED_INDEX; " medium of the planar slab
        IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
           ;OUTPUT ICM_IONCHAM, IM,$MAX_DOSE_ZONE;
             (//'***ERROR IN CM ',I4,' (CHAMBER):'/
             'DOSE_ZONE # of inner cylinder in layer ',I4,
             ' of top part > $MAX_DOSE_ZONE.'/
             'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beamnrc_user_macros.mortran'//);
            DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
            IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
        ]
        IRM = IRM+1;"for outer region of this layer"
        ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',
                 ' for outer region'/' :',$);
        ;MINPUT (IONCHAM) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
                          IREGION_TO_BITTEMP(IRM); (2F15.0,2I5);
        IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
        IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
        ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IRM),
                IREGION_TO_BITTEMP(IRM); (2F10.4, I5,I15);
        OUTPUT;(' For outer region:',$);
        ;$MED_INPUT(IONCHAM);
        MEDTEMP(IRM) = MED_INDEX;
        IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
           ;OUTPUT ICM_IONCHAM, IM,$MAX_DOSE_ZONE;
             (//'***ERROR IN CM ',I4,' (CHAMBER):'/
             'DOSE_ZONE # of outer annulus in layer ',I4,
             ' of top part > $MAX_DOSE_ZONE.'/
             'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
            DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
            IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
        ]
     ]"end of the do loop"
  ]"end of non-equal thickness, etc"
  THICK2=ZTEMP(N_TOP_IONCHAM)-ZMIN_IONCHAM;
  "the overall thickness for the top part"
]
ELSE[THICK2=0.0;]

"
"                    INPUTS FOR THE Central CHAMBER PART
"                    ===================================
"
OUTPUT; (/'          INPUTS FOR THE Central CHAMBER PART');

OUTPUT; (/' INPUT THE INNER RADIUS OF THE CHAMBER WALL (R_INNER),'
  /' THE OUTER RADIUS OF THE CHAMBER WALL (R_WALL), AND THE OUTER RADIUS,'
  /' OF THE GAP BETWEEN THE CHAMBER WALL AND CONTAINER WALL (R_OUTER),'
  /' ALL ON ONE LINE.'/' : ',$);
;MINPUT (IONCHAM) RCYS_IONCHAM(1, 1), RCYS_IONCHAM(1, 2),
    RCYS_IONCHAM(1, 3);(3F15.0);
OUTPUT RCYS_IONCHAM(1, 1), RCYS_IONCHAM(1, 2),
   RCYS_IONCHAM(1, 3); (3F13.5);
OUTPUT;
(/' Note that R_OUTER also defines the inner radius of the container.'
/' The outer radius of the container is defined by RMAX_CM.');
IF(RCYS_IONCHAM(1,1)<0.0)[
   OUTPUT ICM_IONCHAM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Inner radius of chamber wall < 0.0'//);
   IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
]
ELSEIF(RCYS_IONCHAM(1,1)>RMAX_CM(ICM_IONCHAM))[
   OUTPUT ICM_IONCHAM;
     (//'***WARNING IN CM ',I4,' (CHAMBER):'/
       'Inner radius of chamber wall > RMAX_CM'//);
   WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (CHAMBER):''/
         ''Inner radius of chamber wall > RMAX_CM''//)')
         ICM_IONCHAM;
]
IF(RCYS_IONCHAM(1,2)<0.0)[
   OUTPUT ICM_IONCHAM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Outer radius of chamber wall < 0.0'//);
   IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
]
ELSEIF(RCYS_IONCHAM(1,2)>RMAX_CM(ICM_IONCHAM))[
   OUTPUT ICM_IONCHAM;
     (//'***WARNING IN CM ',I4,' (CHAMBER):'/
       'Outer radius of chamber wall > RMAX_CM'//);
   WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (CHAMBER):''/
         ''Outer radius of chamber wall > RMAX_CM''//)')
         ICM_IONCHAM;
]
IF(RCYS_IONCHAM(1,3)<0.0)[
   OUTPUT ICM_IONCHAM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Inner radius of container wall < 0.0'//);
   IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
]
ELSEIF(RCYS_IONCHAM(1,3)>RMAX_CM(ICM_IONCHAM))[
   OUTPUT ICM_IONCHAM;
     (//'***WARNING IN CM ',I4,' (CHAMBER):'/
       'Inner radius of container wall > RMAX_CM'//);
   WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (CHAMBER):''/
         ''Inner radius of container wall > RMAX_CM''//)')
         ICM_IONCHAM;
]
IF(RCYS_IONCHAM(1,2)<RCYS_IONCHAM(1,1))[
   OUTPUT ICM_IONCHAM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Outer radius of chamber wall < inner radius of chamber wall'//);
   IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
]
IF(RCYS_IONCHAM(1,3)<RCYS_IONCHAM(1,1))[
   OUTPUT ICM_IONCHAM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Inner radius of container wall < inner radius of chamber wall'//);
   IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
]
IF(RCYS_IONCHAM(1,3)<RCYS_IONCHAM(1,2))[
   OUTPUT ICM_IONCHAM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Inner radius of container wall < outer radius of chamber wall'//);
   IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
]

RCYS2_IONCHAM(1,1)=RCYS_IONCHAM(1,1)**2;
RCYS2_IONCHAM(1,2)=RCYS_IONCHAM(1,2)**2;
RCYS2_IONCHAM(1,3)=RCYS_IONCHAM(1,3)**2;

Z_IONCHAM(1)=ZMIN_IONCHAM+THICK2;  " THE TOP Z COORD OF THE CHAMBER "

IF(N_CHM_IONCHAM<0)["inputting for a group of layers"
  OUTPUT -N_CHM_IONCHAM;
  (/' THIS CHAMBER HAS ',I4,' GROUPS OF LAYERS WITH EQUAL THICKNESS (ZTHICK).'/
    ' FOR EACH GROUP, INPUT ZTHICK,I (on one line), WHERE I IS THE NUMBER OF'/
    ' LAYERS IN THE GROUP'/' : ',$);
  N_CHAM=0;
  DO II=1,-N_CHM_IONCHAM[
    OUTPUT II; (/' FOR LAYER GROUP ',I4,' :');
    ;MINPUT (IONCHAM) ZTHICK,I;(F15.0,I5);
    OUTPUT ZTHICK,I;(F15.5,I5);
    IF(ZTHICK<0.0)[
      OUTPUT ICM_IONCHAM;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'Layers in chamber part have thickness < 0.0'//);
      IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
    ]
    IF(I<=0)[
      OUTPUT ICM_IONCHAM;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'Cannot have a group with <= 0 layers'//);
      IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
    ]
    N_CHAM=N_CHAM+I;
    IF(N_CHAM+N_TOP_IONCHAM+N_BOT_IONCHAM > $MAX_N_IONCHAM-1)[
       OUTPUT ICM_IONCHAM;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
       'N-CHAM + N-TOP + N-BOT > max. # of layers allowed.'/);
       IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
    ]
    OUTPUT N_CHAM-I+1,N_CHAM,ZTHICK;
     (/' LAYERS ',I4,' - ',I4,' HAVE EQUAL THICKNESS OF',F15.5,' cm.'/);
    Z_IONCHAM(N_CHAM-I+2)=Z_IONCHAM(N_CHAM-I+1)+ZTHICK;
    DO IM=N_CHAM-I+2,N_CHAM[
      Z_IONCHAM(IM+1)=Z_IONCHAM(IM)+ZTHICK;
    ]
  ]"end of do loop to input thicknesses"
  IM=1;
  IRA = IRSTART_IONCHAM;"for the chamber part, one region per layer"
  N_CHM_IONCHAM=N_CHAM;
  N_IONCHAM = N_CHM_IONCHAM+3+ 2*N_TOP_IONCHAM+2*N_BOT_IONCHAM;
  OUTPUT N_CHM_IONCHAM;
   ;(' If a dose zone is input, it is the first of',I4,' in sequence');
   OUTPUT;(' ECUT,PCUT,INITIAL DOSE ZONE(0=>do not score dose),',
    ' IREGION_TO_BIT'/
    ' FOR ALL LAYERS: ',$);
   ;MINPUT (IONCHAM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
   (2F15.0,2I5);
   IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
   IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
   ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA);(2F10.4,I5,I15);
   OUTPUT;(' For all layers :',$);
   ;$MED_INPUT(IONCHAM);
   MED(IRA) = MED_INDEX; " medium of the planar slab
   IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
      ;OUTPUT ICM_IONCHAM,$MAX_DOSE_ZONE;
        (//'***ERROR IN CM ',I4,' (CHAMBER):'/
     'DOSE_ZONE # of layer 1 of chamber part > $MAX_DOSE_ZONE.'/
     'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
      DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
      IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
   ]
   ELSEIF(DOSE_ZONE(IRA).NE.0)[
      IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
      ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
      ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
   ]
   DO IM=2, N_CHM_IONCHAM[
      IRA = IRA+1;
      ECUT(IRA)=ECUT(IRSTART_IONCHAM);
      PCUT(IRA)=PCUT(IRSTART_IONCHAM);
      DOSE_ZONE(IRA)=DOSE_ZONE(IRSTART_IONCHAM) + (IM-1);
      IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
         ;OUTPUT ICM_IONCHAM,IM,$MAX_DOSE_ZONE;
           (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'DOSE_ZONE # of layer ',I4,' of chamber part > $MAX_DOSE_ZONE.'/
          'DOSE_ZONE # set to ',I4,' for now.'/
   'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
                DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
          IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
      ]
      ELSEIF(DOSE_ZONE(IRA).NE.0)[
         IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
         ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
         ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
      ]
      IREGION_TO_BIT(IRA)=IREGION_TO_BIT(IRSTART_IONCHAM);
      MED(IRA) = MED(IRSTART_IONCHAM);
   ]
]
ELSE[
  OUTPUT; (/' INPUT THICKNESS FOR EACH LAYER WITHIN THE CHAMBER'/
  ' FOR LAYERS OF EQUAL THICKNESS (ZTHICK) AND MEDIUM, '/
  ' INPUT ZTHICK,N-CHAM (in one line)'
  /' OTHERWISE, INPUT ZTHICK FOR EACH LAYER STARTING FROM 1ST LAYER'/' : ',$);
  ;MINPUT (IONCHAM) ZTHICK,I;(F15.0,I5);
  OUTPUT ZTHICK,I;(F15.5,I5);
  IF(I = N_CHM_IONCHAM)[
    IF(ZTHICK<0.0)[
       OUTPUT ICM_IONCHAM;
        (//'***ERROR IN CM ',I4,' (CHAMBER):'/
           'Layers in chamber part have thickness < 0.0'//);
       IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
    ]
    OUTPUT I,ZTHICK;
     (/' ALL THE ',I5,' LAYERS HAVE EQUAL THICKNESS OF',F15.5,' cm.'/);
    IRA = IRSTART_IONCHAM;"for the chamber part, one region per layer"
    IM=1;
    OUTPUT I;
     ;(' If a dose zone is input, it is the first of',I4,' in sequence');
    OUTPUT;(' ECUT,PCUT,INITIAL DOSE ZONE(0=>do not score dose),',
     ' IREGION_TO_BIT'/
     ' FOR THE LAYERS: ',$);
    ;MINPUT (IONCHAM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
    (2F15.0,2I5);
    IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
    IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
    ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
       IREGION_TO_BIT(IRA);(2F10.4,I5,I15);
    OUTPUT;(' For all layers :',$);
    ;$MED_INPUT(IONCHAM);
    MED(IRA) = MED_INDEX; " medium of the planar slab
    IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_IONCHAM,$MAX_DOSE_ZONE;
         (//'***ERROR IN CM ',I4,' (CHAMBER):'/
      'DOSE_ZONE # of layer 1 of chamber part > $MAX_DOSE_ZONE.'/
      'DOSE_ZONE # set to ',I4,' for now.'/
      'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
    ]
    ELSEIF(DOSE_ZONE(IRA).NE.0)[
       IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
       ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
       ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
    ]
    Z_IONCHAM(2)=Z_IONCHAM(1)+ZTHICK;
    DO IM=2, N_CHM_IONCHAM[
       Z_IONCHAM(IM+1)=Z_IONCHAM(IM)+ZTHICK;
       IRA = IRA+1;
       ECUT(IRA)=ECUT(IRSTART_IONCHAM);
       PCUT(IRA)=PCUT(IRSTART_IONCHAM);
       DOSE_ZONE(IRA)=DOSE_ZONE(IRSTART_IONCHAM) + (IM-1);
       IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
          ;OUTPUT ICM_IONCHAM,IM,$MAX_DOSE_ZONE;
            (//'***ERROR IN CM ',I4,' (CHAMBER):'/
           'DOSE_ZONE # of layer ',I4,' of chamber part > $MAX_DOSE_ZONE.'/
           'DOSE_ZONE # set to ',I4,' for now.'/
    'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
           DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
           IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
       ]
       ELSEIF(DOSE_ZONE(IRA).NE.0)[
          IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
          ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
          ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
       ]
       IREGION_TO_BIT(IRA)=IREGION_TO_BIT(IRSTART_IONCHAM);
       MED(IRA) = MED(IRSTART_IONCHAM);
    ]
  ]
  ELSE[
    IF(N_CHM_IONCHAM>1)[
       OUTPUT N_CHM_IONCHAM;
       (/' THE',I4,' LAYERS HAVE DIFFERENT ZTHICK AND/OR MEDIA.');
    ]
    OUTPUT 1;
    (/' FOR LAYER',I4,' IN THE CHAMBER:');
    OUTPUT ZTHICK; (/' ZTHICK =',F15.5 );
    IF(ZTHICK<0.0)[
       OUTPUT ICM_IONCHAM;
         (//'***ERROR IN CM ',I4,' (CHAMBER):'/
            'Thickness of layer 1 in chamber part < 0.0'//);
       IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
    ]
    IRA = IRSTART_IONCHAM;"for the chamber part, one region per layer"
    IM=1;
    OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT'/' :',$);
    ;MINPUT (IONCHAM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
    (2F15.0,2I5);
    IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
    IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
    ;OUTPUT ECUT(IRA),PCUT(IRA),
          DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);(2F10.4,I5,I15);
    OUTPUT;(' For this layer :');
    ;$MED_INPUT(IONCHAM);
    MED(IRA) = MED_INDEX;
    IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_IONCHAM,$MAX_DOSE_ZONE;
         (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'DOSE_ZONE # of layer 1 of chamber part > $MAX_DOSE_ZONE.'/
          'DOSE_ZONE # set to ',I4,' for now.'/
    'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
        DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
        IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
    ]
    ELSEIF(DOSE_ZONE(IRA).NE.0)[
       IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
       ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
       ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
    ]
    Z_IONCHAM(2)=Z_IONCHAM(1)+ZTHICK;
    DO IM=2, N_CHM_IONCHAM[
       OUTPUT IM;
       (/' FOR LAYER',I4,' IN THE CHAMBER:');
       OUTPUT; (/' ZTHICK: ',$ );
       ;MINPUT (IONCHAM) ZTHICK;(F15.0);
       OUTPUT ZTHICK;(F15.5);
       IF(ZTHICK<0.0)[
          OUTPUT ICM_IONCHAM, IM;
           (//'***ERROR IN CM ',I4,' (CHAMBER):'/
            'Thickness of layer ',I4,' in chamber part < 0.0'//);
          IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
       ]
       Z_IONCHAM(IM+1)=Z_IONCHAM(IM)+ZTHICK;
       IRA = IRA+1;
       OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT'/
               ':',$);
       ;MINPUT (IONCHAM)
        ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
       (2F15.0,2I5);
       IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
       IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
       ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA), IREGION_TO_BIT(IRA);
          (2F10.4,I5,I15);
       OUTPUT;(' For this layer :',$);
       ;$MED_INPUT(IONCHAM);
       MED(IRA) = MED_INDEX; " medium of the planar slab
       IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
         ;OUTPUT ICM_IONCHAM,IM,$MAX_DOSE_ZONE;
         (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'DOSE_ZONE # of layer ',I4,' of chamber part > $MAX_DOSE_ZONE.'/
          'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
          DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
          IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
       ]
       ELSEIF(DOSE_ZONE(IRA).NE.0)[
          IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
          ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
          ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
       ]
    ]"end of do loop"
  ] "end of else"
]"end of else"

DO I=1, N_CHM_IONCHAM[
     RCYS_IONCHAM(I,1)=RCYS_IONCHAM(1,1);
     RCYS_IONCHAM(I,2)=RCYS_IONCHAM(1,2);
     RCYS_IONCHAM(I,3)=RCYS_IONCHAM(1,3);
     RCYS2_IONCHAM(I,1)=RCYS2_IONCHAM(1,1);
     RCYS2_IONCHAM(I,2)=RCYS2_IONCHAM(1,2);
     RCYS2_IONCHAM(I,3)=RCYS2_IONCHAM(1,3);
]



THICK1=Z_IONCHAM(N_CHM_IONCHAM+1)-Z_IONCHAM(1);
"the overall thickness for the monitor chamber part"

DO IR_IONCHAM = 1+N_CHM_IONCHAM, N_CHM_IONCHAM +3[
   "Parameters for chamber wall, gap and container wall regions"
   IRA = IRA+1;
   IF(IR_IONCHAM.EQ.1+N_CHM_IONCHAM)[
      OUTPUT;(/' FOR THE CHAMBER WALL:');
   ]
   ELSEIF(IR_IONCHAM.EQ.2+N_CHM_IONCHAM)[
      OUTPUT;(/' FOR THE GAP BETWEEN THE CHAMBER WALL AND THE'/
               'CONTAINER WALL:');
   ]
   ELSE[
      OUTPUT;(/' FOR THE CONTAINER WALL:');
   ]
   OUTPUT;(/' ECUT,PCUT, DOSE ZONE(0=>do not score dose),IREGION_TO_BIT'/
            ' : ',$);
   ;MINPUT (IONCHAM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
   IREGION_TO_BIT(IRA); (2F15.0,2I5);
   IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
   IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
   OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
     IREGION_TO_BIT(IRA); (2F10.4,I5,I15);
   OUTPUT;(' For this region: ',$);
   ;$MED_INPUT(IONCHAM);
   MED(IRA) = MED_INDEX;
   IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
     ;OUTPUT ICM_IONCHAM,$MAX_DOSE_ZONE;
        (//'***ERROR IN CM ',I4,' (CHAMBER):'/
 'DOSE_ZONE # chamber wall, gap, and/or container wall > $MAX_DOSE_ZONE.'/
      'DOSE_ZONE # set to ',I4,' for now.'/
  'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
     DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
     IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
   ]
   ELSEIF(DOSE_ZONE(IRA).NE.0)[
      IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
      ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
      ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
   ]
]"end of chamber wall, gap and container wall inputs"

IRM=0;
DO I=1,N_TOP_IONCHAM[ "put here because we need to know N_CHM_IONCHAM"
  IM=N_CHM_IONCHAM+I;"starting # for the top part"
  RCYS_IONCHAM(IM, 1)=RCYSTEMP(I);
  RCYS2_IONCHAM(IM,1)=RCYS_IONCHAM(IM,1)**2;
  Z_IONCHAM(IM+1)=ZTEMP(I);
  IRA = IRA+1;
  IRM=IRM+1;
  IR_IONCHAM = IR_IONCHAM+1;
  ECUT(IRA)=ECUTTEMP(IRM);
  PCUT(IRA)=PCUTTEMP(IRM);
  DOSE_ZONE(IRA)=DOSE_ZONETEMP(IRM);
  IREGION_TO_BIT(IRA)=IREGION_TO_BITTEMP(IRM);
  MED(IRA)=MEDTEMP(IRM);
  IF(DOSE_ZONE(IRA).NE.0)[
        IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
        ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
        ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
  ]
  IRA = IRA+1;"for outer region of this layer"
  IR_IONCHAM =IR_IONCHAM +1;
  IRM=IRM+1;
  ECUT(IRA)=ECUTTEMP(IRM);
  PCUT(IRA)=PCUTTEMP(IRM);
  DOSE_ZONE(IRA)=DOSE_ZONETEMP(IRM);
  IREGION_TO_BIT(IRA)=IREGION_TO_BITTEMP(IRM);
  MED(IRA)=MEDTEMP(IRM);
  IF(DOSE_ZONE(IRA).NE.0)[
        IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
        ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
        ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
  ]
]

THICK3=0.;

IF(N_BOT_IONCHAM~=0)[
   OUTPUT N_BOT_IONCHAM;
   (/' INPUTS FOR THE BOTTOM PART (ALTOGETHER ',I4,' LAYERS):');
   OUTPUT;(/' SIMILAR TO THE TOP PART, EACH LAYER OF THE BOTTOM PART'/
   ' IS DIVIDED INTO AN INNER DISC-SHAPED REGION AND AN OUTER ANNULAR'/
   ' REGION BY THE INNER RADIUS, RCYL.'/
   ' FOR LAYERS OF EQUAL THICKNESS, INNER RADIUS & MEDIA,'/
   ' INPUT ZTHICK,RCYL & N-BOT (2F15.0,I5, in one line)'/
   ' OTHERWISE, INPUT ZTHICK & RCYL FOR EACH LAYER STARTING FROM 1ST',
   ' LAYER'/
   ' (2F15.0)',$);
   IM=N_CHM_IONCHAM+N_TOP_IONCHAM+1;"starting # for the bottom part"
   ;MINPUT (IONCHAM) ZTHICK, RCYS_IONCHAM(IM, 1),JM;(2F15.0,I5);
   OUTPUT ZTHICK, RCYS_IONCHAM(IM, 1),JM;(2F15.5,I5);
   IF(ZTHICK<0.0)[
     OUTPUT ICM_IONCHAM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Thickness of layer 1 in bottom part < 0.0.'//);
     IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
   ]
   IF(RCYS_IONCHAM(IM, 1)<0.0)[
     OUTPUT ICM_IONCHAM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'RCYS of layer 1, bottom part < 0.0'//);
     IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
   ]
   ELSEIF(RCYS_IONCHAM(IM,1) > RMAX_CM(ICM_IONCHAM))[
     OUTPUT ICM_IONCHAM;
      (//'***WARNING IN CM ',I4,' (CHAMBER):'/
         'RCYS of layer 1, bottom part > RMAX_CM'//);
     WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,
       '' (CHAMBER):''/
       ''RCYS of layer 1, bottom part > RMAX_CM''//)')
        ICM_IONCHAM;
   ]
   RCYS2_IONCHAM(IM,1)=RCYS_IONCHAM(IM,1)**2;
   Z_IONCHAM(IM+1)=Z_IONCHAM(N_CHM_IONCHAM+1)+ZTHICK;

  IF(JM.EQ.N_BOT_IONCHAM)["for equal thickness and radius"
     IRA = IRSTART_IONCHAM+N_CHM_IONCHAM+3+2*N_TOP_IONCHAM;
     IR_IONCHAM = N_CHM_IONCHAM+3+2*N_TOP_IONCHAM+1;
     OUTPUT N_BOT_IONCHAM;
     (/' ALL THE',I5,' LAYERS HAVE THE SAME THICKNESS & RADIUS'/);
     OUTPUT ZTHICK, RCYS_IONCHAM(IM,1);
     (/' FOR ALL LAYERS, ZTHICK, RCYL = ',2F15.5);
     OUTPUT;(/
      ' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',/
      ' for inner regions'/
       ' : ',$);
     ;MINPUT (IONCHAM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (2F15.0,2I5);
      IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
      IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
      OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
      OUTPUT;(' For inner region :',$);
      ;$MED_INPUT(IONCHAM);
      MED(IRA) = MED_INDEX;
      IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
        ;OUTPUT ICM_IONCHAM, $MAX_DOSE_ZONE;
        (/'***ERROR IN CM ',I4,' (CHAMBER):'/
        'DOSE_ZONE # of inner cylinders in bottom part > $MAX_DOSE_ZONE.'/
        'DOSE_ZONE set to ',I4,' for now.'/
        'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
        DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
        IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
      ]
      ELSEIF(DOSE_ZONE(IRA).NE.0)[
         IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
         ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
         ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
      ]
      IRA=IRA+1;
      IR_IONCHAM=IR_IONCHAM+1;
      ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',
      ' for outer regions'/' :',$);
      ;MINPUT (IONCHAM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (2F15.0,2I5);
      IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
      IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
      ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
      OUTPUT;(' For outer region :',$);
      ;$MED_INPUT(IONCHAM);
      MED(IRA) = MED_INDEX;
      IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
        ;OUTPUT ICM_IONCHAM, $MAX_DOSE_ZONE;
       (/'***ERROR IN CM ',I4,' (CHAMBER):'/
       'DOSE_ZONE # of annuli in bottom part > $MAX_DOSE_ZONE.'/
       'DOSE_ZONE set to ',I4,' for now.'/
       'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
        DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
        IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
      ]
      ELSEIF(DOSE_ZONE(IRA).NE.0)[
         IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
         ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
         ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
      ]
      DO IM=N_CHM_IONCHAM+N_TOP_IONCHAM+2,
          N_CHM_IONCHAM+N_TOP_IONCHAM+N_BOT_IONCHAM[
        Z_IONCHAM(IM+1)=Z_IONCHAM(IM)+ZTHICK;
        RCYS2_IONCHAM(IM,1)=
        RCYS2_IONCHAM(N_CHM_IONCHAM+N_TOP_IONCHAM+1,1);
        IRA = IRA+1;"for inner region"
        ECUT(IRA)=ECUT(IRSTART_IONCHAM+N_CHM_IONCHAM+3+2*N_TOP_IONCHAM);
        PCUT(IRA)=PCUT(IRSTART_IONCHAM+N_CHM_IONCHAM+3+2*N_TOP_IONCHAM);
        DOSE_ZONE(IRA)=
             DOSE_ZONE(IRSTART_IONCHAM+N_CHM_IONCHAM+3+2*N_TOP_IONCHAM);
        IF(DOSE_ZONE(IRA).NE.0)[
           IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
           ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
           ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
        ]
        MED(IRA)=MED(IRSTART_IONCHAM+N_CHM_IONCHAM+3+2*N_TOP_IONCHAM);
        IRA = IRA+1;"for outer region"
        ECUT(IRA)=ECUT(IRSTART_IONCHAM+N_CHM_IONCHAM+4+2*N_TOP_IONCHAM);
        PCUT(IRA)=PCUT(IRSTART_IONCHAM+N_CHM_IONCHAM+4+2*N_TOP_IONCHAM);
        DOSE_ZONE(IRA)=
           DOSE_ZONE(IRSTART_IONCHAM+N_CHM_IONCHAM+4+2*N_TOP_IONCHAM);
        IF(DOSE_ZONE(IRA).NE.0)[
           IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
           ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
           ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
        ]
        MED(IRA)=MED(IRSTART_IONCHAM+N_CHM_IONCHAM+4+2*N_TOP_IONCHAM);
      ]
      THICK3=ZTHICK*FLOAT(N_BOT_IONCHAM);
  ]"end of equal thickness and radius input"
  ELSE["for different thicknesses, radii or media"
     IRA = IRSTART_IONCHAM+N_CHM_IONCHAM+3+2*N_TOP_IONCHAM;
     IR_IONCHAM = N_CHM_IONCHAM+3+2*N_TOP_IONCHAM+1;
     IF(N_BOT_IONCHAM>1)[ OUTPUT N_BOT_IONCHAM;
         (/' THE',I4, ' LAYERS IN THE BOTTOM PART HAVE DIFFERENT'/
            ' INNER RADII, THICKNESS, AND/OR MEDIA.');
     ]
     OUTPUT 1;(/' FOR LAYER',I4,' IN BOTTOM PART:');
     OUTPUT ZTHICK,RCYS_IONCHAM(IM, 1);
     (/' ZTHICK, RCYL =',2F15.5);
     THICK3=ZTHICK;
     OUTPUT;(/' ECUT,PCUT,DOSE ZONE(0=>do not score dose),'/
            ' IREGION_TO_BIT for inner region'/
            ' : ',$);
     ;MINPUT (IONCHAM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (2F15.0,2I5);
     IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
     IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
     ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
     OUTPUT;(' For inner region :',$);
     ;$MED_INPUT(IONCHAM);
     MED(IRA) = MED_INDEX;
     IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_IONCHAM, $MAX_DOSE_ZONE;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
  'DOSE_ZONE # of inner cylinder in 1st layer, bottom part > $MAX_DOSE_ZONE.'/
    'DOSE_ZONE # set to ',I4,' for now.'/
    'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
     ]
     ELSEIF(DOSE_ZONE(IRA).NE.0)[
         IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
         ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
         ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
     ]
     IRA = IRA+1;"for outer region of this layer"
     IR_IONCHAM =IR_IONCHAM +1;
     ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',
     ' for outer region'/' :',$);
     ;MINPUT (IONCHAM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (2F15.0,2I5);
     IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
     IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
     ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
       IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
     OUTPUT;(' For outer region :',$);
     ;$MED_INPUT(IONCHAM);
     MED(IRA) = MED_INDEX;
     IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_IONCHAM, $MAX_DOSE_ZONE;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
  'DOSE_ZONE # of outer annulus in 1st layer, bottom part > $MAX_DOSE_ZONE.'/
        'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
     ]
     ELSEIF(DOSE_ZONE(IRA).NE.0)[
         IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
         ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
         ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
     ]
     DO IM=N_CHM_IONCHAM+N_TOP_IONCHAM+2,
            N_CHM_IONCHAM+N_TOP_IONCHAM+ N_BOT_IONCHAM[
        OUTPUT IM-N_CHM_IONCHAM-N_TOP_IONCHAM;
        (/' FOR LAYER',I4,' OF THE BOTTOM PART:');
        OUTPUT;
        (/' INPUT ZTHICK & RADIUS:',$);
        ;MINPUT (IONCHAM) ZTHICK, RCYS_IONCHAM(IM, 1);(2F15.0);
        OUTPUT ZTHICK, RCYS_IONCHAM(IM, 1);(2F12.5);
        IF(ZTHICK<0.0)[
           OUTPUT ICM_IONCHAM, IM-N_CHM_IONCHAM-N_TOP_IONCHAM;
          (//'***ERROR IN CM ',I4,' (CHAMBER):'/
             'Thickness of layer ',I4,' in bottom part < 0.0'//);
           IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
        ]
        Z_IONCHAM(IM+1)=Z_IONCHAM(IM)+ZTHICK;THICK3=THICK3+ZTHICK;
        IF( RCYS_IONCHAM(IM,1)<0.0 )[
          OUTPUT ICM_IONCHAM, IM-N_CHM_IONCHAM-N_TOP_IONCHAM;
           (//'***ERROR IN CM ',I4,' (CHAMBER):'/
            'Radius of inner cylinder in layer ',I4,' of bottom part < 0.0'//);
          IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
        ]
        ELSEIF(RCYS_IONCHAM(IM,1) > RMAX_CM(ICM_IONCHAM))[
          OUTPUT ICM_IONCHAM, IM-N_CHM_IONCHAM-N_TOP_IONCHAM;
          (//'***WARNING IN CM ',I4,' (CHAMBER):'/
         'Radius of inner cylinder in layer ',I4,' of bottom part > RMAX_CM'//);
          WRITE(IOUTLIST,'(//''***WARNING IN CM '',
          I4,'' (CHAMBER):''/
          ''Radius of inner cylinder in layer '',
          I4,'' of bottom part > RMAX_CM''//)')
          ICM_IONCHAM, IM-N_CHM_IONCHAM-N_TOP_IONCHAM;
        ]
        RCYS2_IONCHAM(IM,1)=RCYS_IONCHAM(IM,1)**2;
        "note: each layer has 2 regions in this part"
        IRA = IRA+1;"for inner region of this layer"
        IR_IONCHAM =IR_IONCHAM +1;
        ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),',
        'IREGION_TO_BIT for inner region'/' :',$);
        ;MINPUT (IONCHAM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
           IREGION_TO_BIT(IRA); (2F15.0,2I5);
        IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
        IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
        ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
          IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
        OUTPUT;(' For inner region :',$);
        ;$MED_INPUT(IONCHAM);
        MED(IRA) = MED_INDEX;
        IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_IONCHAM, IM-N_CHM_IONCHAM-N_TOP_IONCHAM,$MAX_DOSE_ZONE;
         (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'DOSE_ZONE # of inner cylinder in layer ',I4,
          ' of bottom part > $MAX_DOSE_ZONE.'/
          'DOSE_ZONE # set to ',I4,' for now.'/
  'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
            DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
            IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
        ]
        ELSEIF(DOSE_ZONE(IRA).NE.0)[
           IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
           ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
           ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
        ]
        IRA = IRA+1;"for outer region of this layer"
        IR_IONCHAM =IR_IONCHAM +1;
        ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),',
        'IREGION_TO_BIT for outer region'/' :',$);
        ;MINPUT (IONCHAM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
           IREGION_TO_BIT(IRA); (2F15.0,2I5);
        IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
        IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
        ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
            IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
        OUTPUT;(' For outer region :',$);
        ;$MED_INPUT(IONCHAM);
        MED(IRA) = MED_INDEX;
        IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_IONCHAM, IM-N_CHM_IONCHAM-N_TOP_IONCHAM,$MAX_DOSE_ZONE;
          (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'DOSE_ZONE # of outer annulus in layer ',I4,
          ' of bottom part > $MAX_DOSE_ZONE.'/
          'DOSE_ZONE # set to ',I4,' for now.'/
   'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
           DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
           IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
        ]
        ELSEIF(DOSE_ZONE(IRA).NE.0)[
           IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
           ZPLOTCHM(DOSE_ZONE(IRA))=Z_IONCHAM(IM);
           ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_IONCHAM(IM+1);
        ]
     ]"end of do loop"
  ]"end of non-equal thickness, etc."
]"end of bottom part"


ZTHICK_IONCHAM=THICK1+THICK2+THICK3;"total thickness of the component module"
ZMAX_IONCHAM=ZMIN_IONCHAM+ZTHICK_IONCHAM;
"
"  parameter definition
"  ====================
"
"establish the front surface of this CM, if it is the first module,
"Z_min_CM(1) will be given by the user in BEAM general inputs.

ZFRONT_IONCHAM = Z_min_CM(ICM_IONCHAM);
"
"establish start of next CM
"
Z_min_CM(ICM_IONCHAM+1) = ZMAX_IONCHAM;

"
"
"  set up the air gap, if present
"  =========================================
"
"  The air gap has the highest region number in the CM, even though it is at
"  the top of the component module.  This is to allow the assignment of region
"  numbers on input of the parameters of each local region (mainly to assign the
"  medium number of the region).  The air gap is then assigned after all of the
"  CM parameters have been input.
"
"note that if this is the first CM (ICM_$chamber=1) then the gap thickness
"Z_gap_THICK(ICM_$chamber) = ZMIN_IONCHAM - Z_min_CM(1),
"which is used as a flag whether there is an air gap.

Z_gap_THICK(ICM_IONCHAM) = ZMIN_IONCHAM - Z_min_CM(ICM_IONCHAM);

IF (Z_gap_THICK(ICM_IONCHAM) = 0.0)[
   Z_gap_THICK(ICM_IONCHAM) = 0.;
   N_GAP_IONCHAM = 0; "no air gap is needed for this CM
]
ELSE[
   N_GAP_IONCHAM = 1; "this CM has an air gap"
   OUTPUT Z_min_CM(ICM_IONCHAM),ZMIN_IONCHAM;
   (/' THERE WILL BE AN AIR GAP SET UP BETWEEN Z=',F8.4,' AND Z=',F8.4/);
   IRA = IRSTART_IONCHAM+N_IONCHAM; "absolute region number of air gap
   MED(IRA) = AIR_INDEX; "medium is air
   ECUT(IRA)=ECUTIN;
   PCUT(IRA)=PCUTIN;
   ESAVE(IRA)=ESAVE_GLOBAL;
   ECUTRR(IRA)=ECUT(IRA);
]

"
"  set up region numbers
"  =====================
"
"  This CM has N_IONCHAM+N_GAP_$chamber regions
"
;
IREND_IONCHAM = (IRSTART_IONCHAM -1) +N_IONCHAM+N_GAP_IONCHAM;
       "Index of last region"
NREG = NREG+N_IONCHAM+N_GAP_IONCHAM;
       "Total number of regions in full geometry up"
       "to and including this CM"
IF (NREG <= $MXREG)[
   IR_start_CM(ICM_IONCHAM+1) = IREND_IONCHAM+1;
   "It has not exceeded maximum region number. "
   "Index of first region in next CM:"
]
ELSE[
   OUTPUT ICM_IONCHAM,NREG,$MXREG;
   (//'***ERROR IN CM ',I4,' (CHAMBER):'/
      I4,' regions requested, only ',I4,' available'//);
   IERR_GEOM(ICM_IONCHAM)=IERR_GEOM(ICM_IONCHAM)+1;
]

"  Establish CM boundary
"  =====================
RMAX_CM_FLAG(ICM_IONCHAM) = 1; "put a boundary about CM"
"
"  Establish dose-scoring zones and bit setting for each region
"  ============================================================
"
IRA = IRSTART_IONCHAM-1; "absolute region number"
DO IR_IONCHAM=1,N_IONCHAM["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones"
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE);"Number of dose zones"
   IF(NDOSE_ZONE>$MAX_DOSE_ZONE)[
      OUTPUT;(///' IN CHAMBER, NDOSE_ZONE OUT OF RANGE!!!'///);
      STOP;
   ]
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT); " current maxmum"
   "charged particle range rejection parameters"
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are"
                            "considered for range rejection"
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region"
   E_min_out(ICM_IONCHAM)=ECUT(IRA); "Minimum energy on exit from CM"
] "end of loop over IR_IONCHAM"

"Set up minimum thicknesses for range rejection purposes. In this case "
"we check the last 5 slabs. If we ever need more than 5 slabs, we should"
"extend this or do something fancy like group similar materials."
"Only do this for the central ion chamber part "

I=1; J=1;        " J is index for Z_min_thick , I for layer index "
LOOP[
   Z_min_thick(ICM,J)=0.0;     " init. "
   IRA = I + IRSTART_IONCHAM-1;   "absolute region"
   IF( MED(IRA)~=1) [" AIR WILL BE COUNTED AFTERWARDS "
       MED_min_thick(ICM, J)=MED(IRA);
       Z_min_thick(ICM,J) = Z_IONCHAM(I+1)-Z_IONCHAM(I);
       " first assignment "
   ]
   DO IR_IONCHAM=I+1, N_CHM_IONCHAM [
      "loop through all the layers, if same med added together"
       IRA = IR_IONCHAM + IRSTART_IONCHAM-1;   "absolute region"
       IF( MED(IRA)=MED_min_thick(ICM, J) )[
           Z_min_thick(ICM,J) =Z_min_thick(ICM,J)+
           (Z_IONCHAM(IR_IONCHAM+1)-Z_IONCHAM(IR_IONCHAM-1+1));
       ]
   ]     " end of the do loop "
   " now figure out where the next index I(layer) begins with "
   DO IR_IONCHAM=I+1, N_CHM_IONCHAM[
       IRA = IR_IONCHAM + IRSTART_IONCHAM-1;   "absolute region"
       III=0;
       DO II=J, 1, -1[
         IF(MED(IRA)~=MED_min_thick(ICM, II) & MED(IRA)~=1)[ III=III+1; ]
       ]
       IF( III=J )  " the next med is different from all the before "
         [ I=IR_IONCHAM; J=J+1; EXIT; ]   " keep the i as the next index "
                                         " J increases by one  "
   ]
]WHILE( I<=N_CHM_IONCHAM & J<=5 & IR_IONCHAM<=N_CHM_IONCHAM );

IF(J < 5  )[  "some not used"
    DO I=1, N_TOP_IONCHAM+N_BOT_IONCHAM[
       IRA = N_CHM_IONCHAM+3+2*(I-1)+1+IRSTART_IONCHAM-1;
       "absolute region"
       IF( RCYS_IONCHAM(N_CHM_IONCHAM+I, 1) >= RMAX_CM(ICM_IONCHAM)
          & MED(IRA)~=1 )[
           IF(J<5)[ J=J+1; ]
           ELSE[ EXIT; ]
           MED_min_thick(ICM, J)=MED(IRA);
           IF(I=1 & N_TOP_IONCHAM~=0 )[
              Z_min_thick(ICM,J) = (  Z_IONCHAM(I+N_CHM_IONCHAM+1)
                                       -ZMIN_IONCHAM);
           ]
           ELSEIF(I=N_TOP_IONCHAM+1)[
              Z_min_thick(ICM,J) = (  Z_IONCHAM(I+N_CHM_IONCHAM+1)
                                       -Z_IONCHAM(N_CHM_IONCHAM+1) );
           ]
           ELSE[
              Z_min_thick(ICM,J) = ( Z_IONCHAM(I+N_CHM_IONCHAM+1)
                                      -Z_IONCHAM(I-1+N_CHM_IONCHAM+1) );
           ]
       ]
    ]     " end of the do loop "
]

IF(J < 5)[  "some not used"
    Zminthick=0.0;
    DO I=1, J [  Zminthick=Zminthick+Z_min_thick(ICM, I); ]
    J=J+1;
    Z_min_thick(ICM, J)=ZTHICK_IONCHAM+Z_gap_thick(ICM_IONCHAM)-Zminthick;
    MED_min_thick(ICM,J) = AIR_INDEX; "AIR_INDEX is 0 or 1"
    DO I = J+1,5[
        Z_min_thick(ICM,I) = 0.0;
        MED_min_thick(ICM,I) = 0;
    ]"end of do loop on I"
]"end J < 5 case"

OUTPUT; (/' MRNGE: ENTER 1 to estimate thickness of IONCHAM for ECUTRR'/
          ' calculations in automated range rejection; otherwise, do'/
          ' not calculate ECUTRR',$);
;MINPUT (IONCHAM) MRNGE; (I5);
OUTPUT MRNGE;(I5);
OUTPUT; (' ');
IF(MRNGE~=1)[
    DO I=1, 5[Z_min_thick(ICM,I)=0.0; MED_min_thick(ICM,I)=0; ]
]
ELSE[
   OUTPUT; (/'          Z_min_thick ,     MED_min_thick  ');
   DO I=1, 5[
       IF( Z_min_thick(ICM,I)~=0.0 )[
          OUTPUT Z_min_thick(ICM,I), MED_min_thick(ICM,I);
          (10X, F8.4, 10X, I5);
       ]
   ]
]

"  return from INPUT_IONCHAM
"  =======================
"
RETURN;

"  error messages
"  ==============
"
:EOF_IONCHAM:
;OUTPUT ICM;
(//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_IONCHAM:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;

"  end of INPUT_IONCHAM
"  ==================
"
END;  "End of INPUT_IONCHAM"

%E    "Start of subroutine ISUMRY_IONCHAM"
"*******************************************************************************
"
"                          Subroutine ISUMRY_IONCHAM
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_IONCHAM;


;IMPLICIT NONE;

;COMIN/
   BOUNDS,CMs,CM_IONCHAM,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER,EGS-IO/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_IONCHAM
"T>**********************************
"T>

INTEGER
   ICOLOUR, "T>colour of CM for EGS_Windows
   IRA,     "T>absolute region number
   LAYER,
   I,J;     "T>DO loop index

$REAL  PIL,VOL_IONCHAM($MAX_N_IONCHAM);  "T>cylinder volume
"   Mass of dose zone
"   =================
"
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_$chamber.
PIL=4.0*ATAN(1.0);

I=0;
LOOP[
   I = I+1;
   IF( I<=N_CHM_IONCHAM ) [ LAYER=I; ]
   ELSEIF(I<=N_CHM_IONCHAM+3 ) [ LAYER=1; ]
   ELSE
     [LAYER=N_CHM_IONCHAM+(I-N_CHM_IONCHAM-3+1)/2;]
     " this will be used only for the top and bottom parts "
   IF(I<=N_CHM_IONCHAM)
   [
      VOL_IONCHAM(I)=PIL*RCYS2_IONCHAM(1,1)*(Z_IONCHAM(I+1)-
          Z_IONCHAM(I));
   ]
   ELSEIF( I=N_CHM_IONCHAM+1 )
   [
       VOL_IONCHAM(I)=PIL*(RCYS2_IONCHAM(1,2)-RCYS2_IONCHAM(1,1))
                   *(Z_IONCHAM(N_CHM_IONCHAM+1)-Z_IONCHAM(1));
   ]
   ELSEIF( I=N_CHM_IONCHAM+2 )
   [
       VOL_IONCHAM(I)=PIL*(RCYS2_IONCHAM(1,3)-RCYS2_IONCHAM(1,2))
                   *(Z_IONCHAM(N_CHM_IONCHAM+1)-Z_IONCHAM(1));
   ]
   ELSEIF( I=N_CHM_IONCHAM+3 )
   [
       VOL_IONCHAM(I)=PIL*( RMAX_CM(ICM_IONCHAM)*RMAX_CM(ICM_IONCHAM)
                   -RCYS2_IONCHAM(1,3))
                   *(Z_IONCHAM(N_CHM_IONCHAM+1)-Z_IONCHAM(1));
   ]
   ELSE
   [
       IF( (LAYER.EQ.N_CHM_IONCHAM+1) .AND. (N_TOP_IONCHAM.NE.0))
       [VOL_IONCHAM(I)=PIL*RCYS2_IONCHAM(LAYER,1)*(Z_IONCHAM(LAYER+1)
             -ZMIN_IONCHAM);]
       ELSEIF( LAYER=N_CHM_IONCHAM+N_TOP_IONCHAM+1 )
       [
           VOL_IONCHAM(I)=PIL*RCYS2_IONCHAM(LAYER,1)
                        *(Z_IONCHAM(LAYER+1)-Z_IONCHAM(N_CHM_IONCHAM+1));
       ]
       ELSE
       [VOL_IONCHAM(I)=PIL*RCYS2_IONCHAM(LAYER,1)*(Z_IONCHAM(LAYER+1)
                         -Z_IONCHAM(LAYER-1+1));
       ]
       I=I+1;
       IF( (LAYER.EQ.N_CHM_IONCHAM+1) .AND. (N_TOP_IONCHAM.NE.0))
       [
            VOL_IONCHAM(I)=PIL*( RMAX_CM(ICM_IONCHAM)*RMAX_CM(ICM_IONCHAM)
                              -RCYS2_IONCHAM(LAYER,1) )
                           *(Z_IONCHAM(LAYER+1)-ZMIN_IONCHAM);
       ]
       ELSEIF( LAYER=N_CHM_IONCHAM+N_TOP_IONCHAM+1 )
       [
            VOL_IONCHAM(I)=PIL*( RMAX_CM(ICM_IONCHAM)*RMAX_CM(ICM_IONCHAM)
                              -RCYS2_IONCHAM(LAYER,1) )
                       *(Z_IONCHAM(LAYER+1)-Z_IONCHAM(N_CHM_IONCHAM+1));
       ]
       ELSE
       [
            VOL_IONCHAM(I)=PIL*( RMAX_CM(ICM_IONCHAM)*RMAX_CM(ICM_IONCHAM)
                              -RCYS2_IONCHAM(LAYER,1) )
                       *(Z_IONCHAM(LAYER+1)-Z_IONCHAM(LAYER-1+1));
       ]
   ]
]UNTIL (I>=N_IONCHAM);

DO I = 1,N_IONCHAM
[ IF( VOL_IONCHAM(I) <=0.0 ) [
OUTPUT I;(/' LOCAL REGION',I4,' IN CHAMBER HAS ZERO VOLUME!'/);
"VOL_IONCHAM(I)=1.0;" ] ]

IRA = IRSTART_IONCHAM-1; "absolute region number
DO IR_IONCHAM=1,N_IONCHAM+N_GAP_IONCHAM ["loop over local region number
   IRA = IRA+1;
   IF(DOSE_ZONE(IRA).NE.0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+VOL_IONCHAM(IR_IONCHAM)*RHOR(IRA);
   ]
] "end of loop over IR_IONCHAM"

"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"
WRITE(IOUTLIST,110) ICM_IONCHAM,TITLE_IONCHAM;
WRITE(IOUTLIST,111) Z_min_CM(ICM_IONCHAM),RMAX_CM(ICM_IONCHAM);

"AIR GAP, IF PRESENT "
IF(N_GAP_IONCHAM~=0)[
   IRA=IRSTART_IONCHAM+N_IONCHAM;
   WRITE(IOUTLIST,1501);
   WRITE(IOUTLIST,1504)N_IONCHAM+1,
                       'NA',Z_min_CM(ICM_IONCHAM),ZMIN_IONCHAM-
                       Z_min_CM(ICM_IONCHAM),RMAX_CM(ICM_IONCHAM),
                       ECUT(IRA),PCUT(IRA),
                       ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
                       (MEDIA(J,MED(IRA)),J=1,9);
   WRITE(IOUTLIST,1505);
]
" ION CHAMBER TOP PART "
IRA = IRSTART_IONCHAM-1+3+N_CHM_IONCHAM;
IF( N_TOP_IONCHAM~=0) [ WRITE(IOUTLIST,1204); ]
DO IR_IONCHAM=N_CHM_IONCHAM+1,N_CHM_IONCHAM+N_TOP_IONCHAM [
   IRA = IRA+1;
   I=(IR_IONCHAM-N_CHM_IONCHAM-1)*2+N_CHM_IONCHAM+3+1;
   IF( IR_IONCHAM=N_CHM_IONCHAM+1 ) [
      IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1304) I,IR_IONCHAM-N_CHM_IONCHAM,
         ZMIN_IONCHAM,Z_IONCHAM(IR_IONCHAM+1)-ZMIN_IONCHAM,
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1304)I,IR_IONCHAM-N_CHM_IONCHAM,
         ZMIN_IONCHAM,Z_IONCHAM(IR_IONCHAM+1)-ZMIN_IONCHAM,
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]
   ELSE[
      IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1304)I,IR_IONCHAM-N_CHM_IONCHAM,
         Z_IONCHAM(IR_IONCHAM),Z_IONCHAM(IR_IONCHAM+1)-
         Z_IONCHAM(IR_IONCHAM),
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1304) I,IR_IONCHAM-N_CHM_IONCHAM,
         Z_IONCHAM(IR_IONCHAM),Z_IONCHAM(IR_IONCHAM+1)-
         Z_IONCHAM(IR_IONCHAM),
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]

   IRA = IRA+1;
   I=I+1;
   IF( IR_IONCHAM=N_CHM_IONCHAM+1 ) [
     IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1305) I,IR_IONCHAM-N_CHM_IONCHAM,
         ZMIN_IONCHAM,Z_IONCHAM(IR_IONCHAM+1)-
         ZMIN_IONCHAM,
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
     ]
     ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1305) I,IR_IONCHAM-N_CHM_IONCHAM,
         ZMIN_IONCHAM,Z_IONCHAM(IR_IONCHAM+1)-
         ZMIN_IONCHAM,
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
   ELSE[
     IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1305) I,IR_IONCHAM-N_CHM_IONCHAM,
         Z_IONCHAM(IR_IONCHAM),Z_IONCHAM(IR_IONCHAM+1)-
         Z_IONCHAM(IR_IONCHAM),
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
     ]
     ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1305) I,IR_IONCHAM-N_CHM_IONCHAM,
         Z_IONCHAM(IR_IONCHAM),Z_IONCHAM(IR_IONCHAM+1)-
         Z_IONCHAM(IR_IONCHAM),
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
]

WRITE(IOUTLIST,120);
IRA = IRSTART_IONCHAM-1;"for chamber part"
DO IR_IONCHAM=1,N_CHM_IONCHAM [
   IRA = IRA+1;
   IF (MED(IRA)=0) ["Medium is vacuum"
      /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
      WRITE(IOUTLIST,130) IR_IONCHAM,IR_IONCHAM,'layer',
      Z_IONCHAM(IR_IONCHAM),
      Z_IONCHAM(IR_IONCHAM+1)-Z_IONCHAM(IR_IONCHAM),
      RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
      ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
   ]
   ELSE
   ["Medium is not vacuum"
      WRITE(IOUTLIST,130) IR_IONCHAM,IR_IONCHAM,'layer',
      Z_IONCHAM(IR_IONCHAM),
      Z_IONCHAM(IR_IONCHAM+1)-Z_IONCHAM(IR_IONCHAM),
      RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
      ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
      (MEDIA(J,MED(IRA)),J=1,9);
   ]
]

" ion chamber side wall part "
IRA=IRA+1;
WRITE(IOUTLIST,1201);
IF (MED(IRA)=0) ["Medium is vacuum"
    /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
    WRITE(IOUTLIST,1301) IR_IONCHAM,'NA','entire',
         Z_IONCHAM(0+1),
         Z_IONCHAM(N_CHM_IONCHAM+1)-Z_IONCHAM(0+1),
         RCYS_IONCHAM(1,1), RCYS_IONCHAM(1,2),ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
]
ELSE ["Medium is not vacuum"
     WRITE(IOUTLIST,1301) IR_IONCHAM,'NA','entire',
         Z_IONCHAM(0+1),
         Z_IONCHAM(N_CHM_IONCHAM+1)-Z_IONCHAM(0+1),
         RCYS_IONCHAM(1,1), RCYS_IONCHAM(1,2),ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,8);
]
WRITE(IOUTLIST,1310)'wall';
" ion chamber side air gap part "
IRA=IRA+1;
WRITE(IOUTLIST,1202);
IF (MED(IRA)=0) ["Medium is vacuum"
    /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
    WRITE(IOUTLIST,1302) IR_IONCHAM+1,'NA','entire',
         Z_IONCHAM(0+1),
         Z_IONCHAM(N_CHM_IONCHAM+1)-Z_IONCHAM(0+1),
         RCYS_IONCHAM(1,2), RCYS_IONCHAM(1,3), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
]
ELSE ["Medium is not vacuum"
     WRITE(IOUTLIST,1302) IR_IONCHAM+1,'NA','entire',
         Z_IONCHAM(0+1),
         Z_IONCHAM(N_CHM_IONCHAM+1)-Z_IONCHAM(0+1),
         RCYS_IONCHAM(1,2), RCYS_IONCHAM(1,3), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,8);
]
WRITE(IOUTLIST,1311)'gap';
" ion chamber's container wall part "
IRA=IRA+1;
WRITE(IOUTLIST,1203);
IF (MED(IRA)=0) ["Medium is vacuum"
    /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
    WRITE(IOUTLIST,1303) IR_IONCHAM+2,'NA','entire',
     Z_IONCHAM(0+1),
     Z_IONCHAM(N_CHM_IONCHAM+1)-Z_IONCHAM(0+1),
         RCYS_IONCHAM(1,3), RMAX_CM(ICM_IONCHAM),
         ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
]
ELSE ["Medium is not vacuum"
     WRITE(IOUTLIST,1303) IR_IONCHAM+2,'NA','entire',
     Z_IONCHAM(0+1),
     Z_IONCHAM(N_CHM_IONCHAM+1)-Z_IONCHAM(0+1),
         RCYS_IONCHAM(1,3), RMAX_CM(ICM_IONCHAM),
         ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,8);
]
WRITE(IOUTLIST,1312)'wall';

" ION CHAMBER BOTTOM PART "
IRA = IRSTART_IONCHAM-1+3+N_CHM_IONCHAM+2*N_TOP_IONCHAM;
IF( N_BOT_IONCHAM~=0 ) [ WRITE(IOUTLIST,1206); ]
DO IR_IONCHAM=N_CHM_IONCHAM+N_TOP_IONCHAM+1,
                 N_CHM_IONCHAM+N_TOP_IONCHAM+N_BOT_IONCHAM[
   IRA = IRA+1;
   I=(IR_IONCHAM-N_CHM_IONCHAM-1)*2+N_CHM_IONCHAM+3+1;
   IF( IR_IONCHAM=N_CHM_IONCHAM+N_TOP_IONCHAM+1 )[
     IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1306)
         I,IR_IONCHAM-N_CHM_IONCHAM-N_TOP_IONCHAM,
         Z_IONCHAM(N_CHM_IONCHAM+1),Z_IONCHAM(IR_IONCHAM+1)-
         Z_IONCHAM(N_CHM_IONCHAM+1),
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
     ]
     ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1306)
         I,IR_IONCHAM-N_CHM_IONCHAM-N_TOP_IONCHAM,
         Z_IONCHAM(N_CHM_IONCHAM+1),Z_IONCHAM(IR_IONCHAM+1)-
         Z_IONCHAM(N_CHM_IONCHAM+1),
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
   ELSE[
      IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1306)
         I,IR_IONCHAM-N_CHM_IONCHAM-N_TOP_IONCHAM,
         Z_IONCHAM(IR_IONCHAM),Z_IONCHAM(IR_IONCHAM+1)-
         Z_IONCHAM(IR_IONCHAM),
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1306)
         I,IR_IONCHAM-N_CHM_IONCHAM-N_TOP_IONCHAM,
         Z_IONCHAM(IR_IONCHAM),Z_IONCHAM(IR_IONCHAM+1)-
         Z_IONCHAM(IR_IONCHAM),
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]

   IRA = IRA+1;
   I=I+1;
   IF( IR_IONCHAM=N_CHM_IONCHAM+N_TOP_IONCHAM+1 ) [
      IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1307)
         I,IR_IONCHAM-N_CHM_IONCHAM-N_TOP_IONCHAM,
         Z_IONCHAM(N_CHM_IONCHAM+1),Z_IONCHAM(IR_IONCHAM+1)-
         Z_IONCHAM(N_CHM_IONCHAM+1),
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1307)
         I,IR_IONCHAM-N_CHM_IONCHAM-N_TOP_IONCHAM,
         Z_IONCHAM(N_CHM_IONCHAM+1),Z_IONCHAM(IR_IONCHAM+1)-
         Z_IONCHAM(N_CHM_IONCHAM+1),
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]
   ELSE[
     IF (MED(IRA)=0)["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1307)
         I,IR_IONCHAM-N_CHM_IONCHAM-N_TOP_IONCHAM,
         Z_IONCHAM(IR_IONCHAM),Z_IONCHAM(IR_IONCHAM+1)-
         Z_IONCHAM(IR_IONCHAM),
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
     ]
     ELSE["Medium is not vacuum"
         WRITE(IOUTLIST,1307)
         I,IR_IONCHAM-N_CHM_IONCHAM-N_TOP_IONCHAM,
         Z_IONCHAM(IR_IONCHAM),Z_IONCHAM(IR_IONCHAM+1)-
         Z_IONCHAM(IR_IONCHAM),
         RCYS_IONCHAM(IR_IONCHAM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
]

DO I=1,N_IONCHAM[IF(VOL_IONCHAM(I)<=0.0 )[WRITE(IOUTLIST,141)I;]]

110 FORMAT(///1x,79('-')/
            '  Component module',I3,' is an ion chamber or phantom ',
            '(CHAMBER)'/ 1x,79('-')//T5,'Title: ',68A1);
111 FORMAT(/T2,'IONCHAM region & geometry parameters:',
           /T2,'-------------------------------------',
           /T2,'Distance of front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Radius of outer boundary of CM = ',F15.5,' cm');

120 FORMAT(/T5,'IONCHAM CENTRAL PART parameters:',
           /T5,'--------------------------------',
           /T1,' local layer loc.   Z    Zthick  rad.  electr photon',
           ' range-reject  dose  medium',
           /T1,' reg              front                cutoff cutoff',
           ' level   max   zone'
           /T1,'                   (cm)    (cm)  (cm)   (MeV)  (MeV)',
           ' (MeV)  (MeV)');
130 FORMAT(T1,I3,I5,A7,F8.3,F8.4,F7.3,4F7.3,I3,2X,9A1);
131 FORMAT(T9,A8);
1201 FORMAT(/T5,'IONCHAM WALL parameters:',
           /T5,'--------------------------',
        /T1,' local layer loc.  Z    Zthick     rad.     electr photon',
        ' range-reject dose med',
        /T1,' reg             front         inner  outer cutoff cutoff',
        ' level  max   zone'
        /T1,'                 (cm)    (cm)      (cm)      (MeV)  (MeV)',
        ' (MeV) (MeV)');
1301 FORMAT(T1,I3,A4,A7,F8.3,F7.3,2F7.3,2F6.3,F7.3,F6.3,I3,1X,8A1);
1310 FORMAT(T8,A7);
1202 FORMAT(/T5,'IONCHAM side air gap parameters:',
           /T5,'---------------------------------',
        /T1,' local layer loc.  Z    Zthick     rad.     electr photon',
        ' range-reject dose med',
        /T1,' reg             front         inner  outer cutoff cutoff',
        ' level  max   zone'
        /T1,'                 (cm)    (cm)      (cm)      (MeV)  (MeV)',
        ' (MeV) (MeV)');
1302 FORMAT(T1,I3,A4,A7,F8.3,F7.3,2F7.3,2F6.3,F7.3,F6.3,I3,1X,8A1);
1311 FORMAT(T8,A7);
1203 FORMAT(/T5,'IONCHAM container wall parameters:',
           /T5,'-----------------------------------',
        /T1,' local layer loc.  Z    Zthick     rad.     electr photon',
        ' range-reject dose med',
        /T1,' reg             front         inner  outer cutoff cutoff',
        ' level  max   zone'
        /T1,'                 (cm)    (cm)      (cm)      (MeV)  (MeV)',
        ' (MeV) (MeV)');
1303 FORMAT(T1,I3,A4,A7,F8.3,F7.3,2F7.3,2F6.3,F7.3,F6.3,I3,1X,8A1);
1312 FORMAT(T8,A7);
1204 FORMAT(/T5,'IONCHAM TOP PART parameters:',
           /T5,'-----------------------------',
           /T1,' local layer loc.   Z    Zthick  inner electr photon',
           ' range-reject  dose  medium',
           /T1,' reg              front           rad. cutoff cutoff',
           ' level   max   zone'
           /T1,'                   (cm)   (cm)    (cm)  (MeV)  (MeV)',
           ' (MeV)  (MeV)');
1304 FORMAT(T1,I3,I5,'  inner',F8.3,F8.4,5F7.3,I3,2X,9A1);
1305 FORMAT(T1,I3,I5,'  outer',F8.3,F8.4,5F7.3,I3,2X,9A1);
1206 FORMAT(/T5,'IONCHAM BOTTOM PART parameters:',
           /T5,'--------------------------------',
           /T1,' local layer loc.   Z    Zthick  inner electr photon',
           ' range-reject  dose  medium',
           /T1,' reg              front           rad. cutoff cutoff',
           ' level   max   zone'
           /T1,'                   (cm)   (cm)    (cm)  (MeV)  (MeV)',
           ' (MeV)  (MeV)');
1306 FORMAT(T1,I3,I5,'  inner',F8.3,F8.4,5F7.3,I3,2X,9A1);
1307 FORMAT(T1,I3,I5,'  outer',F8.3,F8.4,5F7.3,I3,2X,9A1);
1501 FORMAT(/T5,'Air gap parameters:',
           /T5,'-------------------',
           /T1,' local layer loc.   Z    Zthick   rad. electr photon',
           ' range-reject  dose  medium',
           /T1,' reg              front                cutoff cutoff',
           ' level   max   zone'
           /T1,'                   (cm)   (cm)    (cm)  (MeV)  (MeV)',
           ' (MeV)  (MeV)');
1504 FORMAT(T1,I3,A5,'  airgap',F8.3,F7.3,5F7.3,I3,2X,9A1);
1505 FORMAT(T8,'   at top');


141 FORMAT(/' LOCAL REGION',I4,' IN CHAMBER HAS ZERO VOLUME!');



"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"

IF(IWATCH = 4 | IZLAST = 2)
[  "Creat a graphics file "
   ;$SELECT-COLOUR;
    DO I=1, N_CHM_IONCHAM+N_TOP_IONCHAM+N_BOT_IONCHAM
    [
       WRITE(IOUTGEOM,201)ICOLOUR,'CYLZ',Z_IONCHAM(I-1+1),
                      RCYS_IONCHAM(I,1),
                Z_IONCHAM(I+1),RCYS_IONCHAM(I,1),0.0,0.0;
    ]
]"End of graphics output"

201   FORMAT(' ',I1,A4,10(F7.2,','));


"   end of ISUMRY_IONCHAM
"   ===================
"
RETURN;
END; "End of subroutine ISUMRY_IONCHAM"
%E "Start of subroutine HOWNEAR_IONCHAM
"*******************************************************************************
"
SUBROUTINE HOWNEAR_IONCHAM(DIST);
"
" Returns min. distance to nearest region boundary
" Used to be a function, but changed to a subroutine for convenience
"  and consistency.
"*******************************************************************************
$IMPLICIT-NONE;

;COMIN/CM_IONCHAM,STACK/;

INTEGER LAYER;
$REAL RF_IONCHAM, RF2_IONCHAM, DIST;

IR_IONCHAM=IR(NP)-IRSTART_IONCHAM+1;"local region # "

" CALC. THE LAYER # "
IF( IR_IONCHAM<=N_CHM_IONCHAM ) [ LAYER=IR_IONCHAM; ]
ELSEIF(IR_IONCHAM<=N_CHM_IONCHAM+3 ) [ LAYER=1; ]
ELSEIF(IR_IONCHAM<=N_IONCHAM)[
    LAYER=N_CHM_IONCHAM+(IR_IONCHAM-N_CHM_IONCHAM-3+1)/2;
    "last term gives the layer number, i.e., "
    "for region 1 in top part, the layer number(integer)=(1+1)/2=1"
    "for region 2 in top part, the layer number(integer)=(2+1)/2=1"
    "for region 3 in top part, the layer number(integer)=(3+1)/2=2"
    "......                                        changed by CMa."
    " this will be used only for the top and bottom parts         "
]

RF2_IONCHAM=X(NP)**2+Y(NP)**2;
RF_IONCHAM=SQRT(RF2_IONCHAM);
IF( IR_IONCHAM<=N_CHM_IONCHAM ) [" inside the main ion chamber part "
    DIST=MIN(  Z(NP)-Z_IONCHAM(LAYER),   " upstream "
    Z_IONCHAM(LAYER+1)-Z(NP),     " downstream"
    RCYS_IONCHAM(LAYER,1)-RF_IONCHAM  );
    RETURN;
]
ELSEIF( IR_IONCHAM<=N_CHM_IONCHAM +3 )  [
    " in the side wall or side gap or container wall "
    DIST=MIN(  Z(NP)-Z_IONCHAM(1),      " upstream "
    Z_IONCHAM(N_CHM_IONCHAM+1)-Z(NP),  " downstream "
    ABS( RF_IONCHAM -RCYS_IONCHAM(1, 1) ),
    ABS( RF_IONCHAM -RCYS_IONCHAM(1, 2) ),
    ABS( RF_IONCHAM -RCYS_IONCHAM(1, 3) ) );
    RETURN;
]
ELSEIF( IR_IONCHAM<=N_IONCHAM )[   " except air gap. "
    DIST=MIN(  Z(NP)-ZMIN_IONCHAM,
    " check the front face of the 1st layer in the top"
    ABS( Z(NP)-Z_IONCHAM(1) ),
    " check the back face of the last layer in the top"
    ABS( Z(NP)-Z_IONCHAM(N_CHM_IONCHAM+1) ),
    " check the front face for the 1st layer in the bottom"
    ZMAX_IONCHAM-Z(NP),        " back face for the last in the bottom "
    ABS(Z(NP)-Z_IONCHAM(LAYER)),  " except the above case "
    "this is for the front face of the layer"
    ABS(Z_IONCHAM(LAYER+1)-Z(NP)),
    "this is for the back face of the layer"
    "note we use ABS because the front face in the top layer"
    "and the back face of the bottom layer may not be Z_IONCHAM(LAYER)"
    "and Z_IONCHAM(LAYER+1)     --CMa"
    ABS( RCYS_IONCHAM(LAYER,1)-RF_IONCHAM ) );
    RETURN;
]
ELSEIF( IR(NP)=IREND_IONCHAM & N_GAP_IONCHAM=1)[
    DIST=MIN(Z(NP)-ZFRONT_IONCHAM, ZMIN_IONCHAM-Z(NP));
    RETURN;
]
RETURN;
END; "End of subroutine HOWNEAR_IONCHAM"
"End of CHAMBER_cm.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: stack of conical geometries               "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Geoff Zhang                                               "
"                   Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code originally evolved from the CONS component module written by     "
"  George Ding, starting in 1992, and subsequently edited by Charlie Ma.      "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             ************               ""toc:
"                             *          *               ""toc:
"                             * CONESTAK *               ""toc:
"                             *          *               ""toc:
"                             ************               ""toc:
"
"   See sccs for history of modifications
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.  primary collimator (cone geormetry of
"   arbitrary thickness, angle and material in and out).
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator: primary collimator
"
"I>
"I> Geometry of CONESTAK:                              ""toc:
"I> ******************
"I>                                       |
"I>                                       |  beam direction
"I>                                       |
"I>                                      \|/
"I>
"I>                  ----------------------------------------------
"I>                               Air gap IR = N+1 if exist
"I>                  ----------------------------------------------
"I>                  |               /        \                  |
"I>          IR = 3  |    IR = 2    / IR = 1   \  IR = 2         | IR = 3
"I>                  |             /            \                |
"I>                  |            /              \               |
"I>      outer wall  |-------------------------------------------|
"I>                  |          /                  \             |
"I>                  |         /   IR = 3*(I-1)+1   \IR=3(I-1)+2 |IR=3(I-1)+3
"I>                  |        /                      \           |
"I>                  |-------------------------------------------|
"I>                                    .......
"I>
"I>
"I>
"I>   IR is the region number within the CM.  There are three local regions
"I>   shown above.
"I>
"I>
"I>            ------------------------------------------------------
"I>            |          Region              | Description         |
"I>            |------------------------------|---------------------|
"I>            |  absolute      | local       |                     |
"I>            |----------------|-------------|                     |
"I>            |                |             |                     |
"I>            |IRSTART_CONESTAK| IR_CONESTAK |  as shown in above  |
"I>            | +IR_CONESTAK-1 |             |    (1 to 2)         |
"I>            |                |             |                     |
"I>            |                |             |                     |
"I>            ------------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_RING
"                      ISUMRY_RING
"                      HOWFAR_RING
"                      WHERE_AM_I_RING
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS/KNOWN BUGS        ""toc:
"                             ***********************
"
"
"*******************************************************************************
;
"
"                               INPUT FROM UNIT 5             ""toc:
"                               *****************             ""toc:
"
"I>
"I>  CARDS CM_RING (CONESTAK)
"I>  ********************************
"I>
"I>   -1  dummy line to indicate start of CM
"I>
"I>   0  RMAX_CM(ICM_RING) (F10.0): Outer radial boundary (cm).
"I>
"I>   1  TITLE_RING (60A1):  Title of CM.
"I>
"I>   2  ZMIN_RING, RBN_RING (2F15.0):
"I>
"I>         ZMIN_RING:  Distance from front of first cone to
"I>                          reference plane (Z=0),
"I>         RBN_RING:   Inner radius of outer wall
"I>                          (Set to 0 if you do not want an outer wall)
"I>
"I>   3  ISCM_MAX_RING (I5): Number of conical layers
"I>
"I>   Repeat 4 once for I=1,ISCM_MAX_RING
"I>
"I>   4  ZTHICK_RING(I), RMIN_RING(I), RMAX_RING(I) (3F15.0):
"I>
"I>        ZTHICK_RING(I):  Thickness of conical layer.
"I>        RMIN_RING(I):    Front radius of conical layer.
"I>        RMAX_RING(I):    Back radius of conical layer.
"I>                           Note restrictions:
"I>                           RMAX_RING(I)>=RMIN_RING(I)
"I>                           RMIN_RING(I+1)>=RMAX_RING(I)
"I>
"I>   5 and 6 are only required if there is an outer wall (ie RBN_RING~=0)
"I>
"I>   5  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT in local region 3 (outer wall):
"I>                                                  (2F15.0,2I5)
"I>
"I>         ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   Dose scoring flag, non-zero to score dose
"I>                      deposited in it
"I>         IREGION_TO_BIT:   Bit setting number for the region
"I>
"I>   6  MED_IN (24A1):  Medium of local region 3
"I>                      used to set MED_INDEX.
"I>
"I>   Repeat 7-10 for each conical layer
"I>
"I>   7  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT in local region 1 (inside cone):
"I>                                                  (2F15.0,2I5)
"I>
"I>         ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   Dose scoring flag, 0 to score dose deposited in it
"I>         IREGION_TO_BIT:   Bit setting number for the region
"I>
"I>   8  MED_IN (24A1):  Medium of local region 1 (inside cone),
"I>                      used to set MED_INDEX
"I>
"I>   9  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT in local region 2 (outside cone):
"I>                                                    (2F15.0,2I5)
"I>
"I>         ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   Dose scoring flag, 0 to score dose deposited in it
"I>         IREGION_TO_BIT:   Bit setting number for the region
"I>
"I>   10  MED_IN (24A1):  Medium of local region 2 (outside of cone),
"I>                       used to set MED_INDEX
"I>   Example
"I>   *******
"I>
"I>  The following input example describes two conical layers.  The first
"I>  layer is a flat-top cone 1.0cm thick, with a radius at the top of 0.8cm
"I>  and a radius at the base of 1.2cm.  The second layer is a cylinder, also
"I>  1.0cm thick, of radius 1.2cm.  The top cone is made of Cu and the bottom
"I>  cylinder is made of Pb.  The entire structure is encircled by a Pb wall
"I>  with inner radius 4cm and outer radius 5cm.
"I>  In both layers, the medium between the cone and the outer wall is H2O.
"I>
"I>  Dose in the Cu cone will be scored in dose zone 1.  Dose in the PB cylinder
"I>  will appear in dose zone 2.  The dose to the encircling PB wall will be in
"I>  zone 3.  And the dose to the water in both layers will be scored in zone 4.
"I>  ECUT and PCUT in all cases is 0.521MeV and 0.01MeV respectively.
"I>
"I>  5.0                   RMAX_CM
"I>  cone and cylinder surrounded by PB wall
"I>  0.0, 4.0
"I>  2
"I>  1.0, 0.8, 1.2
"I>  1.0, 1.2, 1.2
"I>  0.521, 0.01, 3, 0
"I>  PB
"I>  0.521, 0.01, 1, 0
"I>  CU
"I>  0.521, 0.01, 4, 0
"I>  H2O
"I>  0.521, 0.01, 2, 0
"I>  PB
"I>  0.521, 0.01, 4, 0
"I>  H2O
"I>
"
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules
"
"*******************************************************************************

%E   "start of subroutine HOWFAR_RING"
"*******************************************************************************
"************************** Component Module CONESTAK **************************
"*******************************************************************************
"
"                          Subroutine HOWFAR_CONESTAK
"                          ***********************
"
" HOWFAR routine for stacked planar media.
"
" Determine if current region number is within component module CONESTAK, and
" if so evaluate DIST, distance to region boundary along current trajectory.
"  USTEP must not exceed DIST.
"
"   There are N_CONESTAK local regions + an air gap (if present):
"
"     local               absolute                       description
"  -----------  --------------------------------------  ----------------------
"  IR_CONESTAK  IR_start_CM(ICM_CONESTAK)+IR_CONESTAK-1 excluding front air gap
" ------------  --------------------------------------  -----------------------
"   Geometrical co-ordinates, as set in INPUT_CONESTAK are:
"
"   ZFRONT_CONESTAK     front of CM (upstream surface, air region)
"   ZMIN_CONESTAK       front of cone
"   ZBACK_CONESTAK      back of cone
"   RMAX_CONESTAK       radius of bottom conical layer (largest)
"
"******************************************************************************
;SUBROUTINE HOWFAR_RING;


;IMPLICIT NONE;
;COMIN/ CMs,CM_RING,EPCONT,STACK,SCORE,EGS-IO/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_CONESTAK
"T>**********************************
"T>
INTEGER
   IRNEW_RING, "T>tentative new region number within CM (absolute)
   IB_RING,    "T>index to deal with round off errors (=1,2 in region 1,2)
   IHIT;            "T>Index for hit(=1) or not (=0)

$REAL
   DIST,           "T>distance to region boundary along current trajectory
   XF_RING,   "T>temporary variable
   YF_RING,   "T>temporary variable
   ZF_RING,   "T>temporary variable
   TCON_RING, "T>temporary variable
   SQXY_RING;
$REAL
   AUP_RING, CUP_RING,  TQ_RING,
   A_RING,   B_RING,    B2_RING,
   C_RING,   COUT_RING, RAD_RING,
   BUP_RING, DUP_RING,  T1_RING,
   T2_RING,  I1,  I2;
$REAL one;
parameter (one = 1);

;
" Determine local region number
"
" This replacement macros sets DMIN_RING as well as defining IR_RING
;RING_CM_HOWNEAR(DNEAR(NP));

" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module CONESTAK,
" and if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
;
IF(IR_RING = 3*ISCM_MAX_RING + 1) [ "particle in front air gap
   IF(W(NP) > 0.0) ["particle going forward"
      DIST = (ZMIN_RING(1) - Z(NP))/W(NP); "distance to front of SCM
      IRNEW_RING = IRSTART_RING;
      ;;RING_GET_SQXY(DIST,SQXY_RING);
      IF(SQXY_RING > RBN2_RING)[
         IRNEW_RING = IRSTART_RING + 2;
      ]
      ELSEIF(SQXY_RING > RMIN2_RING(1))[
         IRNEW_RING = IRSTART_RING + 1;
      ]
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         IRNEW = IRNEW_RING; "new region number"
      ]
   ] "end of particle going forward
   ELSEIF(W(NP) < 0.0) ["particle going backward"
      DIST = (ZFRONT_RING - Z(NP))/W(NP); "distance to front of CM
      IF(DIST<=0.)[DIST=1.E-16;]"see SLABS_cm.mortran for explanation"
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         CALL WHERE_AM_I(ICM_RING,-1);
      ]
   ] " end of going backward"
] " end of region of air gap
ELSEIF(IR_RING = 3*(ISCM_RING-1)+1)[   "local region 1
   IB_RING=1;
   ;;RING_CHECK_RIN(ISCM_RING,IB_RING);
   IF(W(NP) > 0.0) [  "particle going forward"
      DIST = (ZMAX_RING(ISCM_RING) - Z(NP))/W(NP);
                  "distance to back of this SCM
      IF(DIST < 0)[DIST=0.;]
      IF(DIST=0. & ISCM_RING=ISCM_MAX_RING)[DIST=1.E-16;]
            "see SLABS_cm.mortran for explanation"
      IRNEW_RING = 1;
      ;;RING_GET_SQXY(DIST,SQXY_RING);  "get r**2 on ZMAX_RING
      IF(SQXY_RING <= RMAX2T_RING(ISCM_RING,IB_RING))[
         IF(ISCM_RING ~= ISCM_MAX_RING)[
            IF(SQXY_RING < RMIN2_RING(ISCM_RING+1))[
               IRNEW_RING = IRSTART_RING + 3*ISCM_RING;
            ]
            ELSE[
               IRNEW_RING = IRSTART_RING + 3*ISCM_RING + 1;
            ]
         ]
      ]
      ELSE[
         ;;RING_IN_HIT(TCON_RING,ISCM_RING,IB_RING);
          DIST = TCON_RING;
          IRNEW_RING = IRSTART_RING + 3*(ISCM_RING-1) + 1;
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IF (IRNEW_RING = 1) ["leaving CM through back"
            CALL WHERE_AM_I(ICM_RING,1);
         ]
         ELSE ["still in this CM
            IRNEW = IRNEW_RING; "new region number"
         ]
      ]
   ] "end of particle going forward
   ELSEIF(W(NP) < 0.0) [  "particle going backward"
      DIST = (ZMIN_RING(ISCM_RING) - Z(NP))/W(NP);
      "distance to back of SCM
      IF(DIST < 0)[DIST=0.;]
      IF(DIST=0. & ISCM_RING=1 & N_GAP_RING=0)[DIST=1.E-16;]
      ;;RING_GET_SQXY(DIST,SQXY_RING);  "get r**2 on ZMIN
      IF(SQXY_RING > RMIN2T_RING(ISCM_RING,IB_RING) )[
         ;;RING_IN_HIT(TCON_RING,ISCM_RING,IB_RING);
         DIST = TCON_RING;
         IRNEW_RING = IRSTART_RING + 3*(ISCM_RING-1) + 1;
      ]
      ELSE[
         IF(ISCM_RING = 1)[
            IRNEW_RING = IRSTART_RING + 3*ISCM_MAX_RING;
                         "air gap region
            IF(N_GAP_RING = 0)[IRNEW_RING = 1;]
         ]
         ELSE[ " ISCM_RING > 1
            ;;RING_GET_SQXY(DIST,SQXY_RING);
            IF(SQXY_RING < RMAX2_RING(ISCM_RING-1))[
               IRNEW_RING = IRSTART_RING + 3*(ISCM_RING-2);
            ]
            ELSE[
               IRNEW_RING = IRSTART_RING + 3*(ISCM_RING-2) + 1;
            ]
         ]
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IF(IRNEW_RING = 1) ["leaving CM through front"
            CALL WHERE_AM_I(ICM_RING,-1);
         ]
         ELSE ["still in CM, entering another region"
            IRNEW = IRNEW_RING; "new region number"
         ]
      ]
   ] " end of going backward"
   ELSE[  "particle W=0
      ;;RING_IN_HIT(TCON_RING,ISCM_RING,IB_RING);
      DIST = TCON_RING;
      IRNEW_RING = IRSTART_RING + 3*(ISCM_RING-1) + 1;
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IRNEW = IRNEW_RING; "new region number"
      ]
   ] " end of W=0
] " end of region 1
ELSEIF(IR_RING = 3*(ISCM_RING-1)+2)[ "particle in region 2
   IB_RING=2;   " =2 in region 2
   ;;RING_CHECK_ROUT(ISCM_RING,IB_RING);
   IF(W(NP) > 0.0) [  "particle going forward"
      DIST = (ZMAX_RING(ISCM_RING) - Z(NP))/W(NP);
                             "distance to back of SCM
      IF(DIST < 0)[DIST=0.;]
      IF(DIST=0. & ISCM_RING=ISCM_MAX_RING)[DIST=1.E-16;]
      ;;RING_OUT(IHIT,TCON_RING,ISCM_RING,IB_RING);
      IF(IHIT = 1)[
         ZF_RING = Z(NP) + TCON_RING * W(NP);
         IF(ZF_RING < ZMAX_RING(ISCM_RING) &
            ZF_RING > ZMIN_RING(ISCM_RING))[
            DIST = TCON_RING;
            IRNEW_RING = IRSTART_RING + 3*(ISCM_RING-1);
         ]
         ELSE[
            ;;RING_GET_SQXY(DIST,SQXY_RING);
            "get r**2 on ZMAX_RING
            IF(ISCM_RING < ISCM_MAX_RING)[
               IF(SQXY_RING < RMIN2_RING(ISCM_RING+1))[
                  IRNEW_RING = IRSTART_RING + 3*ISCM_RING;
               ]
               ELSEIF(SQXY_RING < RBN2T_RING(IB_RING))[
                  IRNEW_RING = IRSTART_RING + 3*ISCM_RING + 1;
               ]
               ELSE[
                  IRNEW_RING = IRSTART_RING + 3*ISCM_RING + 1;
                  ;;RING_IN_HIT_CYL(TCON_RING,IB_RING);
                  DIST = TCON_RING;
                  IRNEW_RING = IRSTART_RING +
                                   3*(ISCM_RING-1) + 2;
               ]
            ]
            ELSE[ "ISCM_RING = ISCM_MAX_RING)
               IRNEW_RING = 1;
               IF(SQXY_RING > RBN2T_RING(IB_RING))[
                  ;;RING_IN_HIT_CYL(TCON_RING,IB_RING);
                  DIST = TCON_RING;
                  IRNEW_RING = IRSTART_RING +
                                     3*(ISCM_RING-1) + 2;
               ]
            ]
         ]
      ]
      ELSE[ "IHIT = 0
         ;;RING_GET_SQXY(DIST,SQXY_RING);  "get r**2 on ZMAX_RING
         IF(ISCM_RING < ISCM_MAX_RING)[
            IF(SQXY_RING < RMIN2_RING(ISCM_RING+1))[
               IRNEW_RING = IRSTART_RING + 3*ISCM_RING;
            ]
            ELSEIF(SQXY_RING < RBN2T_RING(IB_RING))[
               IRNEW_RING = IRSTART_RING + 3*ISCM_RING + 1;
            ]
            ELSE[
               IRNEW_RING = IRSTART_RING + 3*ISCM_RING + 1;
               ;;RING_IN_HIT_CYL(TCON_RING,IB_RING);
               DIST = TCON_RING;
               IRNEW_RING = IRSTART_RING +
                                   3*(ISCM_RING-1) + 2;
            ]
         ]
         ELSE[ "ISCM_RING = ISCM_MAX_RING)
            IRNEW_RING = 1;
            IF(SQXY_RING > RBN2T_RING(IB_RING))[
               ;;RING_IN_HIT_CYL(TCON_RING,IB_RING);
                DIST = TCON_RING;
                IRNEW_RING = IRSTART_RING +
                                    3*(ISCM_RING-1) + 2;
            ]
         ]
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IF( IRNEW_RING = 1 )["leaving CM through back"
            CALL WHERE_AM_I(ICM_RING,1);
         ]
         ELSE ["still in CM, entering region 2 or 3"
            IRNEW = IRNEW_RING; "new region number"
         ]
      ]
   ] " end of particle going forward"
   ELSEIF(W(NP) < 0.0) [  "particle going backward"
      DIST = (ZMIN_RING(ISCM_RING) - Z(NP))/W(NP);
                                  "distance to back of SCM
      IF(DIST < 0)[DIST=0.;]
      IF(ISCM_RING = 1)[
         ;;RING_OUT(IHIT,TCON_RING,ISCM_RING,IB_RING);
         IF (IHIT = 0 & DIST=0.)[
            IRNEW_RING = IRSTART_RING + 3*ISCM_MAX_RING;
         ]
         ELSEIF(IHIT = 1)[
            ZF_RING = Z(NP) + TCON_RING * W(NP);
            IF(ZF_RING > ZMIN_RING(ISCM_RING) &
               ZF_RING < ZMAX_RING(ISCM_RING))[
               DIST = TCON_RING;
               IRNEW_RING = IRSTART_RING;
            ]
            ELSE[
               IRNEW_RING = IRSTART_RING + 3*ISCM_MAX_RING;
            ]
         ]
         ELSE[ " IHIT = 0
            IRNEW_RING = IRSTART_RING + 3*ISCM_MAX_RING;
            "assume we will just exit through top or enter airgap at top"
            ;;RING_GET_SQXY(DIST,SQXY_RING);
                       "get r**2 on ZMIN_RING
            IF(SQXY_RING > RBN2T_RING(IB_RING))[
               ;;RING_IN_HIT_CYL(TCON_RING,IB_RING);
               IF(TCON_RING*W(NP)+Z(NP) > ZMIN_RING(ISCM_RING) &
                  TCON_RING*W(NP)+Z(NP) < ZMAX_RING(ISCM_RING))[
                  DIST = TCON_RING;
                  IRNEW_RING = IRSTART_RING +
                        3*(ISCM_RING-1) + 2;
               ]
            ]
         ]
         IF(IRNEW_RING = IRSTART_RING + 3*ISCM_MAX_RING &
            N_GAP_RING=0 & DIST=0.)[DIST=1.0E-16;]
                          "make sure it goes into prev. CM"
      ]
      ELSE[ " ISCM > 1
         ;;RING_OUT(IHIT,TCON_RING,ISCM_RING,IB_RING);
         IF(IHIT = 1)[
            ZF_RING = Z(NP) + TCON_RING * W(NP);
            IF(ZF_RING > ZMIN_RING(ISCM_RING) &
               ZF_RING < ZMAX_RING(ISCM_RING))[
               DIST = TCON_RING;
               IRNEW_RING = IRSTART_RING + 3*(ISCM_RING -1);
            ]
            ELSE[
               ;;RING_GET_SQXY(DIST,SQXY_RING);
               IF(SQXY_RING < RBN2T_RING(IB_RING))[
                  IRNEW_RING = IRSTART_RING +
                                    3*(ISCM_RING-2) + 1;
               ]
               ELSEIF(SQXY_RING > RBN2T_RING(IB_RING))[
                  IRNEW_RING = IRSTART_RING +
                                    3*(ISCM_RING-2) + 1;
                  ;;RING_IN_HIT_CYL(TCON_RING,IB_RING);
                   DIST = TCON_RING;
                   IRNEW_RING = IRSTART_RING +
                                    3*(ISCM_RING-1) + 2;
               ]
            ]
         ]
         ELSE[ " IHIT = 0
            ;;RING_GET_SQXY(DIST,SQXY_RING);
                  "get r**2 on ZMIN_RING
            IRNEW_RING = IRSTART_RING + 3*(ISCM_RING-2) + 1;
            IF(SQXY_RING > RBN2T_RING(IB_RING))[
               ;;RING_IN_HIT_CYL(TCON_RING,IB_RING);
               DIST = TCON_RING;
               IRNEW_RING = IRSTART_RING +
                                    3*(ISCM_RING-1) + 2;
            ]
         ]
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IF(N_GAP_RING = 0 )[ "leaving CM through front"
            IF(IRNEW_RING => IRSTART_RING + 3*ISCM_MAX_RING) [
               CALL WHERE_AM_I(ICM_RING,-1);
            ]
            ELSE ["still in CM, entering another region"
               IRNEW = IRNEW_RING; "new region number"
            ]
         ]
         ELSE [ "still in CM, entering another region
            IRNEW = IRNEW_RING; "new region number"
         ]
      ]
   ] " end of particle going bachward"
   ELSE [  "particle W=0
      ;;RING_OUT(IHIT,TCON_RING,ISCM_RING,IB_RING);
      IF(IHIT = 1)[
         DIST = TCON_RING;
         IRNEW_RING = IRSTART_RING + 3*(ISCM_RING-1);
      ]
      ELSE[
         ;;RING_IN_HIT_CYL(TCON_RING,IB_RING);
         DIST = TCON_RING;
         IRNEW_RING = IRSTART_RING + 3*(ISCM_RING-1) + 2;
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IRNEW = IRNEW_RING; "new region number"
      ]
   ] " end of particle W=0"
] " end of region 2
ELSEIF(IR_RING = 3*(ISCM_RING-1)+3) ["particle in region 3
IB_RING = 1;
   IF(W(NP) > 0.0)[
      DIST = (ZMAX_RING(ISCM_RING) - Z(NP))/W(NP);
                        "distance to back of SCM
      IF(DIST < 0)[DIST=0.;]
      IF(DIST=0. & ISCM_RING=ISCM_MAX_RING)[DIST=1.E-16;]
      IRNEW_RING = IRSTART_RING + 3*ISCM_RING + 2;
      IF(ISCM_RING = ISCM_MAX_RING)[IRNEW_RING = 1;]
      IF(U(NP)*X(NP)+V(NP)*Y(NP) < 0)[
         ;;RING_OUT_CYL(IHIT,TCON_RING,IB_RING);
         IF(IHIT = 1)[
            ZF_RING = Z(NP) + TCON_RING * W(NP);
            IF(ZF_RING < ZMAX_RING(ISCM_RING)&
               ZF_RING > ZMIN_RING(ISCM_RING))[
               IRNEW_RING = IRSTART_RING + 3*(ISCM_RING-1) + 1;
               DIST = TCON_RING;
            ]
         ]
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IF(IRNEW_RING = 1 )[ "leaving CM through front"
            CALL WHERE_AM_I(ICM_RING,1);
         ]
         ELSE [ "still in CM, entering another region
            IRNEW = IRNEW_RING; "new region number"
         ]
      ]
   ] " end of particle going forward"
   ELSEIF(W(NP) < 0.0)[

      DIST = (ZMIN_RING(ISCM_RING) - Z(NP))/W(NP);
                   "distance to front of SCM
      IF(DIST < 0)[DIST=0.;]
      IF(DIST=0. & N_GAP_RING = 0 & ISCM_RING = 1)[DIST=1.E-16;]
      IF(ISCM_RING = 1)[
         IRNEW_RING = IRSTART_RING + 3*ISCM_MAX_RING;
         IF(N_GAP_RING = 0)[IRNEW_RING = 1;]
         IF(U(NP)*X(NP)+V(NP)*Y(NP) < 0)[
            ;;RING_OUT_CYL(IHIT,TCON_RING,IB_RING);
            IF(IHIT = 1 &
               (Z(NP) + TCON_RING * W(NP)) >= ZMIN_RING(1) &
               (Z(NP) + TCON_RING * W(NP)) <= ZMAX_RING(1))[
               DIST = TCON_RING;
               IRNEW_RING = IRSTART_RING + 1;
            ]
         ]
      ]
      ELSE[   "ISCM > 1
         IRNEW_RING = IRSTART_RING + 3*(ISCM_RING-2) + 2;
         IF(U(NP)*X(NP)+V(NP)*Y(NP) < 0)[
            ;;RING_OUT_CYL(IHIT,TCON_RING,IB_RING);
            IF(IHIT = 1 &
               (Z(NP) + TCON_RING * W(NP)) >=
                 ZMIN_RING(ISCM_RING) &
               (Z(NP) + TCON_RING * W(NP)) <=
                 ZMAX_RING(ISCM_RING))[
               DIST = TCON_RING;
               IRNEW_RING = IRSTART_RING + 3*(ISCM_RING-1) + 1;
            ]
         ]
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IF(IRNEW_RING = 1)[ "leaving CM through front"
            CALL WHERE_AM_I(ICM_RING,-1);
         ]
         ELSE [ "still in CM, entering another region
            IRNEW = IRNEW_RING; "new region number"
         ]
      ]
   ] " end of particle going backward"
   ELSE[   " W(NP) = 0.0
      DIST=1E10;
      ;;RING_OUT_CYL(IHIT,TCON_RING,IB_RING);
      IF(IHIT = 1)[
         DIST = TCON_RING;
         IRNEW_RING = IRSTART_RING + 3*(ISCM_RING-1) + 1;
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;  "still in CM, entering another region
         IRNEW = IRNEW_RING; "new region number"
      ]
   ] " end of particle w=0
]

"   outside of CM, something is wrong
"   =================================
"
ELSE ["something is wrong"
   OUTPUT IR(NP)-IRSTART_RING+1,IR(NP),ICM_RING,
          IR_start_CM(ICM_RING);
      (//' ************'//' HOWFAR_RING error'/
         '    Region, local, absolute =',2I5/
         '    CM number=',I5,' start region =',I5/
         ' *********'//);
   STOP;
] "end of IF statement"
;
RETURN;
END; "End of subroutine HOWFAR_RING"
%E "start of subroutine WHERE_AM_I_RING"
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_RING
"                          ***************************
"
" WHERE_AM_I routine for a stacked right cylinder slabs.
"
" WHERE_AM_I_RING determines the new region number when a
" particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_RING subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_RING from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************

;SUBROUTINE WHERE_AM_I_RING(IDIR);


REPLACE {$CHECK_FRONT_RING;} WITH {;}
REPLACE {$CHECK_BACK_RING;} WITH {;}
;IMPLICIT NONE;
;COMIN/CM_RING,EPCONT,STACK/;
"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_RING
"T>**************************************
"T>
INTEGER IDIR,  "T>direction of particle, +1=forward, -1=backward
           I;  "T>looping index
$REAL XBDY_RING,YBDY_RING,RBDY2_RING;
XBDY_RING = X(NP) + U(NP)*USTEP;
YBDY_RING = Y(NP) + V(NP)*USTEP;
RBDY2_RING = XBDY_RING*XBDY_RING + YBDY_RING*YBDY_RING;
IF(IRSTART_RING = 2)[ " this is first CM and from front
   IF(IDIR =1)[RBDY2_RING = X(NP)**2 + Y(NP)**2;]
]
IF (IDIR=1) ["particle entering this CM through front face (upstream)
   IF(N_GAP_RING = 0) ["no air gap this CM"
      IRNEW = IRSTART_RING;
      IF(RBDY2_RING > RBN2_RING)[
         IRNEW = IRSTART_RING + 2;
      ]
      ELSEIF(RBDY2_RING > RMIN2_RING(1))[
         IRNEW = IRSTART_RING + 1;
      ]
   ]
   ELSE ["this CM has an air gap at the front
      $CHECK_FRONT_RING;
      IRNEW = IREND_RING;
   ]
]
ELSEIF (IDIR=-1) ["particle entering this CM through back face (downstream)
   $CHECK_BACK_RING;
   IRNEW = IRSTART_RING + 3*(ISCM_MAX_RING-1);
   IF(RBDY2_RING > RBN2_RING)[
      IRNEW = IRSTART_RING + 3*(ISCM_MAX_RING-1) + 2;
   ]
   ELSEIF(RBDY2_RING > RMAX2_RING(ISCM_MAX_RING))[
      IRNEW = IRSTART_RING + 3*(ISCM_MAX_RING-1) + 1;
   ]
]
ELSEIF (IDIR=2) ["particle originating within the CM (source 3)
   IF(Z(NP)<ZMIN_RING(1))["in front air gap
      IRNEW = IREND_RING;
   ]
   ELSE[
      DO I=1,ISCM_MAX_RING[
         IF(Z(NP)<=ZMAX_RING(I) & Z(NP)>=ZMIN_RING(I))[
            IRNEW = IRSTART_RING + 3*(I-1);
            IF(SQRT(X(NP)**2+Y(NP)**2) > RBN_RING)[
               IRNEW = IRSTART_RING + 3*(I-1) + 2;
            ]
            ELSEIF(SQRT(X(NP)**2+Y(NP)**2) >
               Z(NP)*ALO_RING(I)+BLO_RING(I))[
                  IRNEW = IRSTART_RING + 3*(I-1) + 1;
            ]
            EXIT;
         ]
      ]
   ]
]
RETURN;
END; "End of subroutine WHERE_AM_I_RING"
%E   "start of subroutine INPUT_RING"
"*******************************************************************************
"
"                           Subroutine INPUT_RING
"                           **********************
"
"  A CM input subroutine for a series of 2 or more semi-infinite slabs.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_RING;


;IMPLICIT NONE;
;COMIN/BOUNDS,CMs,CM_RING,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;
"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_RING
"T>*********************************
"T>
$REAL ZTHICK_RING(20),  "T>thickness of cone in this SCM
      BDYTOL,                "T>may set differ from  $BDY_TOL
      AIRGAPMIN_RING;   "T>minimum air gap in front and back of CM

INTEGER I,J,            "T>DO loop indeces
        IRA,            "T>Absolute region number
        MED_FLAG,       "T>flag used by media-sort macro $MED_INPUT
        IRA_WALL,       "T> region no tmp
        MED_INDEX_WALL, "T>  medium of wall local
        MED_INDEX;      "T>medium index, set after medium sort by $MED_INPUT
"
"  initialize parameters
"  =====================
"
ICM_RING = ICM;      "CM index for this component module
IRSTART_RING = IR_start_CM(ICM_RING);
                    "Index of first region in this CM,
                    "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_RING) = 0; "Geometry-checking flag, 0 if no error detected
AIRGAPMIN_RING = 0.1; "set a minimum 0.1 cm air gap at front of CM

"
"  get the title line
"  ==================
"
OUTPUT;(/' Next component is a stacked set of truncated cones ');
OUTPUT;(/' RING (CONESTAK)');
IF(ICM_RING = 1)[
   OUTPUT Z_min_CM(1);
   (' This is the first component and starts at Z=',F11.4,' cm');
]
ELSE
   [OUTPUT Z_min_CM(ICM_RING);
    (' Previous CM ends at:',F12.5,' cm'/);
]
OUTPUT; (' TITLE: ',$);
MINPUT (RING) TITLE_RING;(60A1);
";MINPUT is a replacement macro with EOF and
          "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_RING;(' ',60A1);
"
" get distance from reference plane, z=0"
"   =============================
NOWALL_RING = 0;
OUTPUT;
(' Distance front 1st cone to ref plane(z=0), inner radius outer wall(0=>none)'/
 ' : ',$);
MINPUT (RING) ZMIN_RING(1),RBN_RING;(2F15.0);
OUTPUT ZMIN_RING(1),RBN_RING;(2F25.5);
IF(Z_min_CM(ICM_RING)>ZMIN_RING(1))[
   IF(ICM_RING=1)[
     OUTPUT ICM_RING, ZMIN_RING(1),Z_min_CM(1);
       (//' ***WARNING IN CM ',I4,' (CONESTAK):'/
        ' Z_min_CM(1) < ZMIN(1)'/
        ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
     WRITE(IOUTLIST,100)ICM_RING, ZMIN_RING(1),
           Z_min_CM(1);
     100 FORMAT(//' ***WARNING IN CM ',I4,' (CONESTAK):'/
        ' Z_min_CM(1) < ZMIN(1)'/
        ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
     Z_min_CM(1)=ZMIN_RING(1);
   ]
   ELSE[
     OUTPUT ICM_RING;
       (//'***ERROR IN CM ',I4,' (CONESTAK):'/
          'Overlaps with previous CM'//);
      IERR_GEOM(ICM_RING)=IERR_GEOM(ICM_RING)+1;
   ]
]
IF(RBN_RING = 0) [
   NOWALL_RING = 1;
   OUTPUT ZMIN_RING(1),RBN_RING;(2F25.5,',  No outer wall!!');
]
ELSEIF(RBN_RING > RMAX_CM(ICM_RING))[
   OUTPUT ICM_RING;
     (//'***ERROR IN CM ',I4,' (CONESTAK):'/
       'inner radius of outer wall > RMAX_CM'//);
   IERR_GEOM(ICM_RING)=IERR_GEOM(ICM_RING)+1;
]
IF(RBN_RING = 0) [RBN_RING = RMAX_CM(ICM_RING); ]
ISCM_MAX_RING = $MAX_N_RING;
"Maximum number of slab cone permitted
OUTPUT ISCM_MAX_RING;
(' NUMBER OF layers (MINIMUM 1, MAXIMUM',I3,'): ',$);
MINPUT (RING) ISCM_MAX_RING; (I5);
OUTPUT ISCM_MAX_RING; (I5);
IF(ISCM_MAX_RING > $MAX_N_RING)[
   OUTPUT ICM_RING, $MAX_N_RING;
     (//'***ERROR IN CM ',I4,' (CONESTAK):'/
        '# of layers > max. allowed.'/
        '# of layers reduced to ',I4,' for now.'//);
   IERR_GEOM(ICM_RING)=IERR_GEOM(ICM_RING)+1;
   ISCM_MAX_RING=$MAX_N_RING;
]
ELSEIF(ISCM_MAX_RING<1)[
   ISCM_MAX_RING=1;
   OUTPUT ICM_RING;
    (//'***ERROR IN CM ',I4,' (CONESTAK):'/
       '# of layers < 1'/
       '# of layers reset to 1 for now'//);
   IERR_GEOM(ICM_RING)=IERR_GEOM(ICM_RING)+1;
]
N_RING = 3*ISCM_MAX_RING;
"Number of regions in this CM (excluding front air gap)
"
"   get  each cone slab geometry information
"   =================================
"
"loop over bars
DO I = 1,ISCM_MAX_RING ["loop to get each slab location"
   OUTPUT I;(/' Cone layer No:',I3,
   /' Thickness of conical layer,  top(r1) and  bottom(r2) radii (r1<=r2)'/
   ' : ',$);
   ;MINPUT (RING) ZTHICK_RING(I),
    RMIN_RING(I),RMAX_RING(I); (3F15.0);
   OUTPUT ZTHICK_RING(I),RMIN_RING(I),RMAX_RING(I);(3F15.5);
   IF(ZTHICK_RING(I) < 0.0)[
      OUTPUT ICM_RING, I;
        (//'***ERROR IN CM ',I4,' (CONESTAK):'/
           'ZTHICK(',I4,') < 0.0'//);
      IERR_GEOM(ICM_RING)=IERR_GEOM(ICM_RING)+1;
   ]
   IF(RMIN_RING(I) > RMAX_RING(I))[
      OUTPUT ICM_RING, I, I;
        (//'***ERROR IN CM ',I4,' (CONESTAK):'/
           'RMIN(',I4,') > RMAX(',I4,')'//);
      IERR_GEOM(ICM_RING)=IERR_GEOM(ICM_RING)+1;
   ]
   IF(RMIN_RING(I)=RMAX_RING(I) & RMIN_RING(I)<$BDY_TOL)[
      "this will cause problems with region check during run"
      RMIN_RING(I)=$BDY_TOL;
      RMAX_RING(I)=$BDY_TOL;
      OUTPUT ICM_RING, I,$BDY_TOL;
        (//' ***WARNING IN CM ',I4,' (CONESTAK):'/
           ' RMIN=RMAX<$BDY_TOL (BOUNDARY TOLERANCE) IN LAYER ',I4/
           ' THIS CAN CAUSE ENDLESS LOOPS'/
           ' RMIN AND RMAX HAVE BEEN RESET TO ',F8.5//);
      WRITE(IOUTLIST,:WARNLAB1:) ICM_RING, I,$BDY_TOL;
:WARNLAB1: FORMAT(//' ***WARNING IN CM ',I4,' (CONESTAK):'/
           ' RMIN=RMAX<$BDY_TOL (BOUNDARY TOLERANCE) IN LAYER ',I4/
           ' THIS CAN CAUSE ENDLESS LOOPS'/
           ' RMIN AND RMAX HAVE BEEN RESET TO ',F8.5//);
   ]
   IF(NOWALL_RING=1 & RMIN_RING(I)>RMAX_CM(ICM_RING))[
      OUTPUT ICM_RING, I;
        (//'***WARNING IN CM ',I4,' (CONESTAK):'/
           'RMIN(',I4,') > RMAX_CM'//);
      WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (CONESTAK):''/
           ''RMIN('',I4,'') > RMAX_CM''//)')
            ICM_RING, I;
   ]
   IF(NOWALL_RING=1 & RMAX_RING(I)>RMAX_CM(ICM_RING))[
      OUTPUT ICM_RING, I;
        (//'***WARNING IN CM ',I4,' (CONESTAK):'/
           'RMAX(',I4,') > RMAX_CM'//);
      WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (CONESTAK):''/
           ''RMAX('',I4,'') > RMAX_CM''//)')
            ICM_RING, I;
   ]
   IF(I > 1 & RMAX_RING(I-1) > RMIN_RING(I))[
      OUTPUT ICM_RING, I, I-1;
       (//'***ERROR IN CM ',I4,' (CONESTAK):'/
          'RMIN(',I4,') < RMAX(',I4,')'//);
      IERR_GEOM(ICM_RING)=IERR_GEOM(ICM_RING)+1;
   ]
]
IF(NOWALL_RING = 0 &
    RBN_RING < RMAX_RING(ISCM_MAX_RING))[
    OUTPUT ICM_RING;
      (//'***ERROR IN CM ',I4,' (CONESTAK):'/
         'Inner radius of outer wall < max. cone radius.'//);
    IERR_GEOM(ICM_RING)=IERR_GEOM(ICM_RING)+1;
]

"   get ECUT, PCUT, dose scoring zone, and material in each region
"   ===============================================================
IRA = IRSTART_RING-1;
DO IR_RING = 1,N_RING["loop through regions to get information"
   IRA = IRA+1;
   IF(NOWALL_RING = 0 & IR_RING = 1)[
      OUTPUT ;(/' For outer wall:'/
' ECUT, PCUT (MeV), DOSE ZONE (0=DO NOT SCORE DOSE), IREGION_TO_BIT'/' : ',$);
     ;MINPUT (RING)
      ECUT(IRA+2),PCUT(IRA+2),DOSE_ZONE(IRA+2),IREGION_TO_BIT(IRA+2);
      (2F15.0,2I5);
      IRA_WALL = IRA+2;
      IF(ECUT(IRA+2) < ECUTIN)[ECUT(IRA+2)=ECUTIN;]
      IF(PCUT(IRA+2) < PCUTIN)[PCUT(IRA+2)=PCUTIN;]
      ;OUTPUT ECUT(IRA+2),PCUT(IRA+2),DOSE_ZONE(IRA+2),
             IREGION_TO_BIT(IRA+2);(F10.5,F10.3,I12,I20);
      OUTPUT ;(' Material of outer wall ',$);
     ;$MED_INPUT(RING);
            "inputs character array MED_IN from unit 5, loops
     "through array MEDIA(24,I) to check if medium was previously input.
     "If so, sets MED_INDEX to index of previous medium.  If not,
     "increments NMED and sets MED_INDEX to NMED.
      MED(IRA+2) = MED_INDEX; " medium of the planar slab
      MED_INDEX_WALL = MED_INDEX;
   ]
   IF(NOWALL_RING = 1 & IR_RING = 1)[
         IRA_WALL = IRA+2;
         ECUT(IRA+2) = ECUTIN;
         PCUT(IRA+2) = PCUTIN;
         DOSE_ZONE(IRA+2)= 0;
         IREGION_TO_BIT(IRA+2) = 0;
         MED(IRA+2) = 0;
   ]

   IF(MOD(IR_RING,3) = 1)[
      OUTPUT IR_RING/3+1;(/' For layer',I3);
      OUTPUT IR_RING;(' Local region ',I3,' (inside of cone)'/
 ' ECUT, PCUT (MeV), DOSE ZONE (0=DO NOT SCORE DOSE), IREGION_TO_BIT'/' : ',$);
   ]
   IF(MOD(IR_RING,3) = 2)[
      OUTPUT IR_RING;(' Local region ',I3,' (outside of cone)'/
 ' ECUT, PCUT (MeV), DOSE ZONE (0=DO NOT SCORE DOSE), IREGION_TO_BIT'/' : ',$);
   ]
   IF(MOD(IR_RING,3) ~= 0)[
     ;MINPUT (RING)
      ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
      (2F15.0,2I5);
      IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
      IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
      ;OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
             IREGION_TO_BIT(IRA);(F10.5,F10.3,I12,I20);
      OUTPUT IR_RING;(' Material of region ',I3,' ',$);
     ;$MED_INPUT(RING); " inputs character array MED_IN from unit 5, loops
     "through array MEDIA(24,I) to check if medium was previously input.
     "If so, sets MED_INDEX to index of previous medium.  If not,
     "increments NMED and sets MED_INDEX to NMED.
      MED(IRA) = MED_INDEX; " medium of the planar slab
   ]
   IF(MOD(IR_RING,3) = 0)[
      ECUT(IRA) = ECUT(IRA_WALL);
      PCUT(IRA) = PCUT(IRA_WALL);
      DOSE_ZONE(IRA)= DOSE_ZONE(IRA_WALL);
      IREGION_TO_BIT(IRA) = IREGION_TO_BIT(IRA_WALL) ;
      MED(IRA) = MED_INDEX_WALL;
      IF(NOWALL_RING = 1)[MED(IRA) = 0; ]
   ]
] "end of loop over IR_RING"

"
"  set up air gap to previous CM, if present
"  =========================================
"
"  The air gap has the highest region number in the CM, even though it is at
"  the top of the component module.  This is to allow the assignment of region
"  numbers on input of the parameters of each local region (mainly to assign the
"  medium number of the region).  The air gap is then assigned after all of the
"  CM parameters have been input.
"
"note that if this is the first CM (ICM_RING=1) then the gap thickness
"Z_gap_THICK(ICM_RING) = 0, which is used as a flag that there is no
"air gap

"front of air gap
Z_gap_THICK(ICM_RING) = ZMIN_RING(1) - Z_min_CM(ICM_RING);
IF (Z_gap_THICK(ICM_RING) < $MIN_GAP) [
   Z_gap_THICK(ICM_RING) = 0.;
   ZMIN_RING(1)=Z_min_CM(ICM_RING);
   N_GAP_RING = 0; "no air gap for this CM
]
ELSE [
   N_GAP_RING = 1; "this CM has an air gap
   IRA = IRSTART_RING+N_RING; "absolute region number of air gap
   MED(IRA) = AIR_INDEX; "medium is air
   ECUT(IRA) = ECUTIN;
   PCUT(IRA)=PCUTIN;
   ESAVE(IRA)=ESAVE_GLOBAL;
   ECUTRR(IRA)=ECUT(IRA);
]
"
"  parameter definition
"  ====================
"
"fill arrays of distance from reference plane (z=0) to front and back of slabs
"
" define the cone geometry here:

BDYTOL= $BDY_TOL;
ZMAX_RING(1) = ZMIN_RING(1) + ZTHICK_RING(1);
DO I = 2, ISCM_MAX_RING[
   ZMIN_RING(I) = ZMIN_RING(I-1) +
   ZTHICK_RING(I-1);
   ZMAX_RING(I) = ZMIN_RING(I) + ZTHICK_RING(I);
]
DO I = 1, ISCM_MAX_RING[
   ALO_RING(I) = (RMAX_RING(I)-
   RMIN_RING(I))/(ZMAX_RING(I) - ZMIN_RING(I));
   BLO_RING(I) = RMIN_RING(I) -
   ZMIN_RING(I)*ALO_RING(I);
   RMINT_RING(I,1)  = RMIN_RING(I) + BDYTOL;
   RMINT_RING(I,2)  = RMIN_RING(I) - BDYTOL;
   RMAXT_RING(I,1)  = RMAX_RING(I) + BDYTOL;
   RMAXT_RING(I,2)  = RMAX_RING(I) - BDYTOL;
   RMIN2_RING(I)    = RMIN_RING(I)**2;
   RMAX2_RING(I)    = RMAX_RING(I)**2;
   RMIN2T_RING(I,1) = RMINT_RING(I,1)**2;
   RMIN2T_RING(I,2) = RMINT_RING(I,2)**2;
   RMAX2T_RING(I,1) = RMAXT_RING(I,1)**2;
   RMAX2T_RING(I,2) = RMAXT_RING(I,2)**2;
   BLOT_RING(I,1) = BLO_RING(I) + BDYTOL;
   BLOT_RING(I,2) = BLO_RING(I) - BDYTOL;
   COSA_RING(I)  = (ZMAX_RING(I) - ZMIN_RING(I))/
            SQRT( (ZMAX_RING(I) - ZMIN_RING(I))**2
                 +(RMAX_RING(I) - RMIN_RING(I))**2 );
]
RBN2_RING     = RBN_RING**2;
RBNT_RING(1)  = RBN_RING - BDYTOL;
RBNT_RING(2)  = RBN_RING + BDYTOL;
RBN2T_RING(1) = RBNT_RING(1)**2;
RBN2T_RING(2) = RBNT_RING(2)**2;

"set the variable zfront, which is only used once
ZFRONT_RING = Z_min_CM(ICM_RING);

"establish start of next CM
"
Z_min_CM(ICM_RING+1) = ZMAX_RING(ISCM_MAX_RING);
"
"  set up region numbers
"  =====================
"
"  This CM has N_RING+N_GAP_RING regions, a series of cone slabs
"
;
IREND_RING = IRSTART_RING + N_RING+ N_GAP_RING - 1;
 "Index of last region
NREG = NREG+N_RING+N_GAP_RING;
                          "Total number of regions in full geometry up
                                "to and including this CM
IF (NREG <= $MXREG) ["have not exceeded maximum region number
      "Index of first region in next CM:"
      IR_start_CM(ICM_RING+1) = IREND_RING+1;
]
ELSE [
      OUTPUT ICM_RING,NREG,$MXREG;
      (//'***ERROR IN CM ',I4,' (CONESTAK):'/
         I4,' regions requested, only ',I4,' available'//);
      IERR_GEOM(ICM_RING)=IERR_GEOM(ICM_RING)+1;
]
"
"  establish CM boundary
"  =====================
RMAX_CM_FLAG(ICM_RING) = 1; "put a cylindrical boundary about CM
"
"  establish dose scoring zones and latch bit setting
"  ==================================================
"
IRA = IRSTART_RING-1; "absolute region number"
DO IR_RING=1,N_RING["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones
   IF(NDOSE_ZONE > $MAX_DOSE_ZONE)[
      OUTPUT NDOSE_ZONE;
       (' Too many dose zone !', 'NDOSE_ZONE =',I5,
        ' > $MAX_DOSE_ZONE');
      STOP;
   ]
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT); " current maxmum
   "charged particle range rejection parameters
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region
   E_min_out(ICM_RING)=ECUT(IRA); "Minimum energy on exit from CM
] "end of loop over IR_RING

"   return from INPUT_RING
"   =======================
"
RETURN;

"   error messages
"   ==============
"
:EOF_RING:
;OUTPUT ICM;(//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_RING:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;
END;  "End of subroutine INPUT_RING"
%E   "start of subroutine ISUMRY_RING"
"*******************************************************************************
"
"                          Subroutine ISUMRY_RING
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_RING;


;IMPLICIT NONE;
;COMIN/BOUNDS,CMs,CM_RING,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_RING
"T>**********************************
"T>
INTEGER
   ICOLOUR,       "T>colour of CM for EGS_Windows
   IRA,           "T>absolute region number
   I,J;           "T>DO loop index

$REAL VOL_RING(3*$MAX_N_RING+1),PIL;  "T> region volume
"   Mass of dose zone
"   =================
"
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_RING.
"
PIL=4.0*ATAN(1.0);

" calc. the vol for each region.

DO I = 1,ISCM_MAX_RING[
   VOL_RING(3*(I-1)+1) = PIL/3.0*(ZMAX_RING(I)-ZMIN_RING(I))*
                    ( RMIN_RING(I)**2 + RMAX_RING(I)**2
                      +RMIN_RING(I)*RMAX_RING(I) );
   VOL_RING(3*(I-1)+2) =
          PIL*(ZMAX_RING(I)-ZMIN_RING(I))*RBN_RING**2-
           VOL_RING(3*(I-1)+1);
   VOL_RING(3*(I-1)+3) =
          PIL*(ZMAX_RING(I)-
            ZMIN_RING(I))*(RMAX_CM(ICM_RING)**2-
              RBN_RING**2);
]

IRA = IRSTART_RING-1; "absolute region number
DO IR_RING=1,N_RING+N_GAP_RING ["loop over local region number
   IRA = IRA+1;
   IF(DOSE_ZONE(IRA).NE.0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+VOL_RING(IR_RING)*RHOR(IRA);
      IF(AMASS(ID)<0.0 & ABS(AMASS(ID))<0.000001)[AMASS(ID)=0.0;]
   ]
] "end of loop over IR_RING"

"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"

WRITE(IOUTLIST,110) ICM_RING,TITLE_RING;
WRITE(IOUTLIST,120) Z_min_CM(ICM_RING),RMAX_CM(ICM_RING);
IF(NOWALL_RING=1)[
   WRITE(IOUTLIST,122);
]
ELSE[ WRITE(IOUTLIST,121)RBN_RING; ]
WRITE(IOUTLIST,123);
IF(N_GAP_RING~=0)[
   WRITE(IOUTLIST,124)'airgap',Z_min_CM(ICM_RING),
                      ZMIN_RING(1)-Z_min_CM(ICM_RING),
                      RMAX_CM(ICM_RING),RMAX_CM(ICM_RING);
]
DO I=1,ISCM_MAX_RING[
   WRITE(IOUTLIST,130)I,ZMIN_RING(I),ZMAX_RING(I)-
               ZMIN_RING(I),
               RMIN_RING(I),RMAX_RING(I);
]
WRITE(IOUTLIST,140);
IRA = IRSTART_RING - 1;
DO IR_RING=1,N_RING-1,3[
   ISCM_RING = (IR_RING - 1)/3 + 1;
   IRA = IRSTART_RING + IR_RING - 1;
   IF(MED(IRA)~=0)[
      WRITE(IOUTLIST,150) IR_RING,ISCM_RING,'inside',
         ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),(MEDIA(J,MED(IRA)),J=1,9);
   ]
   ELSEIF(MED(IRA)=0)[
      WRITE(IOUTLIST,150) IR_RING,ISCM_RING,'inside',
         ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
   ]
   IF(MED(IRA+1)~=0)[
      WRITE(IOUTLIST,150) IR_RING+1,ISCM_RING,'outside',
         ECUT(IRA+1),PCUT(IRA+1),ECUTRR(IRA+1),ESAVE(IRA+1),
         DOSE_ZONE(IRA+1),IREGION_TO_BIT(IRA+1),(MEDIA(J,MED(IRA+1)),J=1,9);
   ]
   ELSEIF(MED(IRA+1)=0)[
      WRITE(IOUTLIST,150) IR_RING+1,ISCM_RING,'outside',
         ECUT(IRA+1),PCUT(IRA+1),ECUTRR(IRA+1),ESAVE(IRA+1),
         DOSE_ZONE(IRA+1),IREGION_TO_BIT(IRA+1),'V','a','c','u','u','m';
   ]
   IF(NOWALL_RING~=1)[
      IF(MED(IRA+2)~=0)[
         WRITE(IOUTLIST,150) IR_RING+2,ISCM_RING,'wall',
         ECUT(IRA+2),PCUT(IRA+2),ECUTRR(IRA+2),ESAVE(IRA+2),
         DOSE_ZONE(IRA+2),IREGION_TO_BIT(IRA+2),(MEDIA(J,MED(IRA+2)),J=1,9);
      ]
      ELSEIF(MED(IRA+2)=0)[
         WRITE(IOUTLIST,150) IR_RING+2,ISCM_RING,'wall',
         ECUT(IRA+2),PCUT(IRA+2),ECUTRR(IRA+2),ESAVE(IRA+2),
         DOSE_ZONE(IRA+2),IREGION_TO_BIT(IRA+2),'V','a','c','u','u','m';
      ]
   ]
   ELSE[        "nowall"
      WRITE(IOUTLIST,153) IR_RING+2,ISCM_RING,'nowall',
         'NA','NA','NA','NA','NA','NA','V','a','c','u','u','m';
   ]
]
IF(N_GAP_RING ~= 0 )[
   IRA = IRSTART_RING+N_RING;
   WRITE(IOUTLIST,151) N_RING+N_GAP_RING,'NA','airgap',
       ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
       DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),(MEDIA(J,MED(IRA)),J=1,9);
   WRITE(IOUTLIST,152)'at top';
]

110 FORMAT(///1x,79('-')/ '  Component module',I3,
           ' is stacked set of truncated cones (CONESTAK)'
           /1x,79('-')
           //T2,'Title: ',68A1);
120 FORMAT(/T2,'RING geometry parameters:',
           /T2,'-----------------------------',
           /T2,'Distance of front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Radius of outer boundary of CM = ',F15.5,' cm');
121 FORMAT(T2,'Inner radius of outer wall = ',F8.5,' cm');
122 FORMAT(T2,'There is no outer wall.');
123 FORMAT(/T2,'layer    Z front   thickness   top radius   bottom radius',
           /T2,'  #       face',
           /T2,'          (cm)       (cm)         (cm)         (cm)');
140 FORMAT(/T2,'RING region parameters:',
           /T2,'---------------------------',
           /T2,'local  layer  location  electron  photon',
           '  range-rejection   dose  bit  medium'
           /T2,'region                   cutoff   cutoff',
           '   level     max    zone  set'
           /T2,'                          (MeV)    (MeV)',
           '   (MeV)    (MeV)');
150 FORMAT(T2,I3,I7,4X,A7,F10.3,F9.3,F8.3,F9.3,I6,I5,2X,9A1);
151 FORMAT(T2,I3,4X,A3,4X,A7,F10.3,F9.3,F8.3,F9.3,I6,I5,2X,9A1);
152 FORMAT(T16,A7);
153 FORMAT(T2,I3,I7,4X,A7,A10,A9,A8,A9,A6,A5,2X,9A1);
130 FORMAT(T2,I3,F12.3,F12.3,F12.3,F13.3);
124 FORMAT(T2,A6,F9.3,F12.3,F12.3,F13.3);

"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"
IF(IWATCH = 4 | IZLAST = 2) [  "Creat a graphics file "
   ICOLOUR=4;
"   WRITE(IOUTGEOM,201) ICOLOUR,'DISK',0.0,0.0,ZMIN_RING,RMIN_RING;
   "cone geometry"
   DO I = 1, ISCM_MAX_RING[
      WRITE(IOUTGEOM,201)ICOLOUR,'CYLZ',ZMIN_RING(I),
          RMIN_RING(I),ZMAX_RING(I),RMAX_RING(I),0.0,0.0;
          201   FORMAT(' ',I1,A4,10(F7.2,','));
   ]
]"End of graphics output"
RETURN;
END;  "end of subroutine ISUMRY_RING"
%E   "start of subroutine HOWNEAR_RING"
"******************************************************************************
"
"                          Subroutine HOWNEAR_RING
"                          ***********************
"
" Calculates min. distance to nearest region boundary.
" Used to be contained in a macro.
"
"*******************************************************************************
;SUBROUTINE HOWNEAR_RING(DIST);


$IMPLICIT-NONE;

COMIN/CM_RING,STACK/;

$REAL DIST; "T> the min. distance to nearest region boundary

IR_RING = IR(NP) - IRSTART_RING + 1;
ISCM_RING = (IR_RING-1)/3 + 1;
IF(IR_RING = 3*(ISCM_RING-1) + 1)[
  DIST = (ALO_RING(ISCM_RING)*Z(NP) +
           BLO_RING(ISCM_RING)
          - SQRT(X(NP)**2 + Y(NP)**2))*COSA_RING(ISCM_RING);
  DIST = MIN(DIST,Z(NP)-ZMIN_RING(ISCM_RING),
         ZMAX_RING(ISCM_RING)-Z(NP));
]
ELSEIF(IR_RING = 3*(ISCM_RING-1)+2)[
  IF(NOWALL_RING=1)[
      DIST = (SQRT(X(NP)*X(NP) + Y(NP)*Y(NP))
           - ALO_RING(ISCM_RING)*Z(NP)
           - BLO_RING(ISCM_RING))*COSA_RING(ISCM_RING);
  ]
  ELSE[
      DIST = MIN((SQRT(X(NP)*X(NP) + Y(NP)*Y(NP))
                  - ALO_RING(ISCM_RING)*Z(NP)
                  - BLO_RING(ISCM_RING))
                  *COSA_RING(ISCM_RING),
                 RBN_RING-SQRT(X(NP)*X(NP) + Y(NP)*Y(NP)));
  ]
  DIST = MIN(DIST,Z(NP)-ZMIN_RING(ISCM_RING),
         ZMAX_RING(ISCM_RING)-Z(NP));
]
ELSEIF(IR_RING = 3*(ISCM_RING-1)+3)[
  DIST = MIN(SQRT(X(NP)*X(NP) + Y(NP)*Y(NP)) - RBN_RING,
             Z(NP)-ZMIN_RING(ISCM_RING),
             ZMAX_RING(ISCM_RING)-Z(NP));
]
ELSE[
   DIST=0.0;
]
RETURN;
END; "End of subroutine HOWNEAR_RING"
"*******************************************************************************
"End of CONESTAK_cm.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: mirror plane                              "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Iwan Kawrakow                                             "
"                   Ernesto Mainegra-Hing                                     "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code originally evolved from the MIRR component module written by     "
"  George Ding, starting in 1992, and subsequently edited by Charlie Ma.      "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             ***********              ""toc:
"                             *         *              ""toc:
"                             * MIRROR  *              ""toc:
"                             *         *              ""toc:
"                             ***********              ""toc:
"
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.  A mirror plane of arbitrary layer,thickness and
"   material in air.
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator:  a mirror.
"
%E   "MIRROR_cm.mortran  -- start of geometry picture"
"I>
"I> Geometry of MIRROR:
"I> ******************
"I>
"I>                          |         | \ \ \   IR = N+1   |
"I>                          |         |\ \ \ \             |
"I>                          |         | \ \ \ \            |
"I>                          |         |  \ \ \ \           |
"I>                          |         |   \ \ \ \          |
"I>      ----------->        | IR= N+3 |    \ \ \ \         |
"I>                          |         |   IR=1,2,N\        |
"I>      beam direction      |         |      \ \ \ \       |
"I>                          |         |       \ \ \ \      |
"I>                          |         |        \ \ \ \     |
"I>                          |         |         \ \ \ \    |
"I>                          |         |          \ \ \ \   |
"I>                          |         |           \ \ \ \  |
"I>                          |         |            \ \ \ \ |
"I>                          |         |  IR = N+2   \ \ \ \|
"I>
"I>
"I>   IR is the region number within the CM.  There are three local regions
"I>   shown above.
"I>
"I>
"I>            -------------------------------------------------
"I>            |          Region         | Description         |
"I>            |-------------------------|---------------------|
"I>            |  absolute    | local    |                     |
"I>            |--------------|----------|                     |
"I>            |              |          |                     |
"I>            |IRSTART_MIRROR| IR_MIRROR|  as shown in above  |
"I>            |  +IR_MIRROR-1|          |    (1 to N+3)       |
"I>            |              |          |                     |
"I>            |              |          |                     |
"I>            -------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_MIRROR
"                      ISUMRY_MIRROR
"                      HOWFAR_MIRROR
"                      WHERE_AM_I_MIRROR
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS ON USE/KNOW BUGS
"                             *****************************
"
"
"*******************************************************************************
%E   "MIRROR_cm.mortran  -- start of description of user input file"
"
"                               INPUT FROM UNIT 5       ""toc:
"                               *****************
"
"I>
"I>  CARDS CM_MIRROR
"I>  **************
"I>
"I>  -1  Dummy line to indicate start of CM.
"I>
"I>   0  RMAX_CM(ICM_MIRROR) (F10.0): Half-width of CM boundary (cm).
"I>
"I>   1  TITLE_MIRROR (60A1): Title of CM.
"I>
"I>   2  ZMIN_MIRROR,ZTHICK_MIRROR (2F15.0):
"I>
"I>           ZMIN_MIRROR:   Distance from front of CM(excluding air gap) to
"I>                           ref plane(Z=0).
"I>           ZTHICK_MIRROR: Z-direction span.
"I>
"I>   3  XFMIN_MIRROR, XBMIN_MIRROR (2F15.0):
"I>
"I>           XFMIN_MIRROR:  X value at which front face of mirror
"I>                           intersects ZMIN_MIRROR.
"I>           XBMIN_MIRROR:  X value at which front face of mirror
"I>                           intersects ZMIN_MIRROR + ZTHICK_MIRROR.
"I>      Note restriction:
"I>    5 degrees<ATAN(ZTHICK_MIRROR/(XFMIN_MIRROR-XBMIN_MIRROR)<90 degrees
"I>
"I>   4  N_MIRROR, (I10):    Number of layers
"I>
"I>   Repeat 5 for I=1,N_MIRROR
"I>
"I>   5  DTHICK_MIRROR(I) (F15.0): Thickness of layer I in mirror,
"I>                                 in cm.  Layer 1 is the front face
"I>                                 of the mirror.
"I>
"I>   Repeat 6 and 7 for I=1,N_MIRROR.
"I>
"I>   6  ECUT, PCUT,DOSE_ZONE, IREGION_TO_BIT (2F15.0, 2I5): for each layer
"I>
"I>          ECUT, PCUT:  Cutoff energies for electrons and photons in
"I>                       layer I.
"I>          DOSE_ZONE:   Dose scoring flag in layer I.
"I>     IREGION_TO_BIT:   bit to associate local region of layer I with
"I>
"I>   7  MED_IN (24A1):  Medium of layer I, used to set MED_INDEX.
"I>
"I>   8  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT in region behind mirror
"I>                                                       (2F15.0,2I5):
"I>
"I>         ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   Dose scoring flag, 0 to score dose deposited in it
"I>    IREGION_TO_BIT:   bit to associate local region with
"I>
"I>   9  MED_IN (24A1):  Medium of local region behind the mirror,
"I>                      used to set MED_INDEX.
"I>
"I>   10  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT in region in front of
"I>                                             mirror(2F15.0,2I5):
"I>
"I>         ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   Dose scoring flag, 0 to score dose deposited in it
"I>    IREGION_TO_BIT:   bit to associate local region with
"I>
"I>   11  MED_IN (24A1): Medium of region in front of mirror,
"I>                      used to set MED_INDEX.
"I>
"I>
"I>   Example
"I>   *******
"I>
"I>   The following describes a mirror composed of 1 AL slab.
"I>   The front face of the mirror intersects the front of the
"I>   CM (excluding any airgap) at X=3cm and the back of the CM at X=-3cm.
"I>   The mirror starts at 19.7cm and is 2cm in the z-direction.
"I>   The thickness of the AL slab is 0.00508cm.
"I>   Note that thickness is measured perpendicular to the
"I>   face of the mirror.  AIR is both in front of and behind
"I>   the AL mirror.  No dose is scored in this example.
"I>
"I>   10.00   RMAX_CM
"I>   MIRROR : z=19.5074 downstream, original, dif overlap
"I>   19.70, 2.0
"I>   3.0, -3.0
"I>   1
"I>   0.00508
"I>   0.0, 0.0, 0, 0
"I>   AL
"I>   0.0, 0.0, 0, 0
"I>   AIR
"I>   0.0, 0.0, 0, 0
"I>   AIR
"I>
"I>
"
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules
"
"*******************************************************************************
%E   "start of subroutine HOWFAR_MIRROR"
"*******************************************************************************
"
"                          Subroutine HOWFAR_MIRROR
"                          ***********************
"
" HOWFAR routine for stacked planar media.
"
" Determine if current region number is within component module MIRR, and if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are N_MIRROR local regions :
"
"     local               absolute                       description
"   ------------    ------------------------------     ----------------------
"   IR_MIRROR      IR_start_CM(ICM_MIRROR)+IR_MIRROR-1      as shown above
"   ------------    ------------------------------     -----------------------
"   Geometrical co-ordinates, as set in INPUT_MIRROR are:
"
"   ZFRONT_MIRROR     front of CM (upstream surface, air region)
"   ZMIN_MIRROR       front of mirror
"   ZBACK_MIRROR       back of mirror
"   RMAX_MIRROR       dimmension limit (in x and y)
"
"******************************************************************************
REPLACE {$PRINT_1_N1;} WITH {;
IF( X(NP)-A_MIRROR*Z(NP)+BMAXT_MIRROR(IR_MIRROR) > $BDY_TOL)[
   OUTPUT IR_MIRROR,Z(NP),X(NP),A_MIRROR*Z(NP)+BMAXT_MIRROR(IR_MIRROR);
       (' print1-n1:ir,z, x, a+bmax ',I3,3F16.8);
]
J = J + 1;
IF(J>1000)[STOP;]
}
REPLACE {$PRINT_1_N2;} WITH {;
OUTPUT IR_MIRROR,Z(NP),X(NP),A_MIRROR*Z(NP)+BMINT_MIRROR(IR_MIRROR);
       (' print1-n2:ir,z, x, a+bmin ',I3,3F16.8);
J = J + 1;
IF(J>1000)[STOP;]
}
REPLACE {$PRINT_N+1;} WITH {;
OUTPUT IR_MIRROR,Z(NP),X(NP),A_MIRROR*Z(NP)+BMAX_MIRROR(N_MIRROR);
       (' printn+1:ir,z, x, a+bmax ',I3,3F16.8);
J = J + 1;
IF(J>1000)[STOP;]
}
REPLACE {$PRINT_N+2;} WITH {;
OUTPUT IR_MIRROR,Z(NP),X(NP),A_MIRROR*Z(NP)+BMIN_MIRROR(1);
       (' printn+1:ir,z, x, a+bmax ',I3,3F16.8);
J = J + 1;
IF(J>1000)[STOP;]
}
;SUBROUTINE HOWFAR_MIRROR;


;IMPLICIT NONE;
;COMIN/CMs,CM_MIRROR,EPCONT,STACK,EGS-IO/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_MIRROR
"T>**********************************
"T>
INTEGER
   IRL,           "T>local region number (absolute), required by HOWNEAR macro
   IRNEW_MIRROR, "T>tentative new region number within CM (absolute)
   I,             "T> loop index
   NERROR_M;      "T> number of errors in howfar (particle neglected)

$REAL
   DIST,          "T>distance to region boundary along current trajectory
   XPLN_MIRROR;  "T> Temporary variable
;
" Determine local region number
" *****************************

IRL = IR(NP); "local region number (absolute)

" Set DNEAR
" *********
" This replacement macros sets DMIN_MIRROR as well as defining IR_MIRROR
"
;MIRROR_CM_HOWNEAR(DNEAR(NP));

" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module MIRR, and if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
;
IF(IR_MIRROR > 0 & IR_MIRROR <= N_MIRROR )[   "local region 1 to N
   IF(X(NP) > A_MIRROR*Z(NP)+BMAXT_MIRROR(IR_MIRROR))[
      IRNEW = IRSTART_MIRROR + IR_MIRROR;
      "$PRINT_1_N1;"
      USTEP = 0;
      RETURN;
   ]
   ELSEIF(X(NP) < A_MIRROR*Z(NP)+BMINT_MIRROR(IR_MIRROR))[
      IRNEW = IRSTART_MIRROR + IR_MIRROR - 2;
      IF(IR_MIRROR = 1)[IRNEW = IRSTART_MIRROR + N_MIRROR + 1;]
      "$PRINT_1_N2;"
      USTEP = 0;
      RETURN;
   ]
   IF(W(NP) > 0.0)[
      DIST = (ZBACK_MIRROR - Z(NP))/W(NP);
      IF(DIST<=0.)[DIST=1.E-16;] "ensures call to ausgab if leaving CM"
      IRNEW_MIRROR = 1;
      XPLN_MIRROR = X(NP) + U(NP)*DIST;
      IF(XPLN_MIRROR > XBMAXT_MIRROR(IR_MIRROR))[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR;
         DIST = (A_MIRROR*Z(NP)+BMAXT_MIRROR(IR_MIRROR)
                 -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
      ELSEIF(XPLN_MIRROR < XBMINT_MIRROR(IR_MIRROR))[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR - 2;
         IF(IR_MIRROR = 1)[
            IRNEW_MIRROR = IRSTART_MIRROR + N_MIRROR + 1;
         ]
         DIST = (A_MIRROR*Z(NP)+BMINT_MIRROR(IR_MIRROR)
                -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
   ]
   ELSEIF(W(NP) < 0.0)[
      DIST = (ZMIN_MIRROR - Z(NP))/W(NP);
      IF(DIST<=0. & N_GAP_MIRROR=0)[DIST=1.E-16;]
      XPLN_MIRROR = X(NP) + U(NP)*DIST;
      IRNEW_MIRROR = IREND_MIRROR;
      IF(N_GAP_MIRROR = 0)[IRNEW_MIRROR = 1;]
      IF(XPLN_MIRROR > XFMAXT_MIRROR(IR_MIRROR))[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR;
         DIST = (A_MIRROR*Z(NP)+BMAXT_MIRROR(IR_MIRROR)
                -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
      ELSEIF(XPLN_MIRROR < XFMINT_MIRROR(IR_MIRROR))[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR - 2;
         IF(IR_MIRROR = 1)[
            IRNEW_MIRROR = IRSTART_MIRROR + N_MIRROR + 1;
         ]
         DIST = (A_MIRROR*Z(NP)+BMINT_MIRROR(IR_MIRROR)
                -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
   ]
   ELSE[
      IF(U(NP) > 0.0)[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR;
         DIST = (A_MIRROR*Z(NP)+BMAXT_MIRROR(IR_MIRROR)-X(NP))/U(NP);
      ]
      ELSEIF(U(NP) < 0.0)[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR - 2;
         IF(IR_MIRROR = 1)[
            IRNEW_MIRROR = IRSTART_MIRROR + N_MIRROR + 1;
         ]
         DIST = (A_MIRROR*Z(NP)+BMINT_MIRROR(IR_MIRROR)-X(NP))/U(NP);
      ]
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF(IRNEW_MIRROR=1) ["leaving CM through back"
         IF(W(NP) > 0.0)[CALL WHERE_AM_I(ICM_MIRROR,1);]
         ELSEIF(W(NP) < 0.0)[CALL WHERE_AM_I(ICM_MIRROR,-1);]
      ]
      ELSE ["still in CM, entering between bars
         IRNEW = IRNEW_MIRROR; "new region number"
      ]
   ]
]"end of IR = 1-N

ELSEIF(IR_MIRROR = N_MIRROR + 1)[ "local region N_MIRROR + 1
   IF(X(NP) < A_MIRROR*Z(NP)+BMAX_MIRROR(N_MIRROR))[
      IRNEW = IRSTART_MIRROR + N_MIRROR - 1;
      USTEP = 0;
      RETURN;
   ]
   IF(W(NP) > 0.0)[
      DIST = (ZBACK_MIRROR - Z(NP))/W(NP);
      IF(DIST<=0.)[DIST=1.E-16;]
      IRNEW_MIRROR = 1;
      XPLN_MIRROR = X(NP) + U(NP)*DIST;
      IF(XPLN_MIRROR < XBMAX_MIRROR(N_MIRROR))[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR - 2;
         DIST = (A_MIRROR*Z(NP)+BMAX_MIRROR(N_MIRROR)
                   -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
   ]
   ELSEIF(W(NP) < 0.0)[
      DIST = (ZMIN_MIRROR - Z(NP))/W(NP);
      IF(DIST<=0. & N_GAP_MIRROR = 0)[DIST=1.E-16;]
      IRNEW_MIRROR = IREND_MIRROR;
      IF(N_GAP_MIRROR = 0)[IRNEW_MIRROR = 1;]
      XPLN_MIRROR = X(NP) + U(NP)*DIST;
      IF(XPLN_MIRROR < XFMAX_MIRROR(N_MIRROR))[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR - 2;
         DIST = (A_MIRROR*Z(NP)+BMAX_MIRROR(N_MIRROR)
                  -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
   ]
   ELSE[
      IF(U(NP) < 0.0)[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR - 2;
         DIST = (A_MIRROR*Z(NP)+BMAX_MIRROR(N_MIRROR)-X(NP))/U(NP);
      ]
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF(IRNEW_MIRROR=1) ["leaving CM"
         IF(W(NP) > 0.0)[CALL WHERE_AM_I(ICM_MIRROR,1);]
         ELSEIF(W(NP) < 0.0)[CALL WHERE_AM_I(ICM_MIRROR,-1);]
      ]
      ELSE ["still in CM, entering between bars
         IRNEW = IRNEW_MIRROR; "new region number"
      ]
   ]
]
ELSEIF(IR_MIRROR = N_MIRROR + 2)[ "local region N_MIRROR + 2
   IF(X(NP) > A_MIRROR*Z(NP)+BMIN_MIRROR(1))[
      IRNEW = IRSTART_MIRROR;
      USTEP = 0;
      RETURN;
   ]
   IF(W(NP) > 0.0)[
      DIST = (ZBACK_MIRROR - Z(NP))/W(NP);
      IF(DIST<=0.)[DIST=1.E-16;]
      IRNEW_MIRROR = 1;
      XPLN_MIRROR = X(NP) + U(NP)*DIST;
      IF(XPLN_MIRROR > XBMIN_MIRROR(1))[
         IRNEW_MIRROR = IRSTART_MIRROR;
         DIST = (A_MIRROR*Z(NP)+BMIN_MIRROR(1)
                   -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
   ]
   ELSEIF(W(NP) < 0.0)[
      DIST = (ZMIN_MIRROR - Z(NP))/W(NP);
      IF(DIST<=0. & N_GAP_MIRROR = 0)[DIST=1.E-16;]
      IRNEW_MIRROR = IREND_MIRROR;
      XPLN_MIRROR = X(NP) + U(NP)*DIST;
      IF(N_GAP_MIRROR = 0)[IRNEW_MIRROR = 1;]
      IF(XPLN_MIRROR > XFMIN_MIRROR(1))[
         IRNEW_MIRROR = IRSTART_MIRROR;
         DIST = (A_MIRROR*Z(NP)+BMIN_MIRROR(1)
                  -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
   ]
   ELSE[
      IF(U(NP) > 0.0)[
         IRNEW_MIRROR = IRSTART_MIRROR;
         DIST = (A_MIRROR*Z(NP)+BMIN_MIRROR(1)-X(NP))/U(NP);
      ]
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF(IRNEW_MIRROR=1) ["leaving CM "
         IF(W(NP) > 0.0)[CALL WHERE_AM_I(ICM_MIRROR,1);]
         ELSEIF(W(NP) < 0.0)[CALL WHERE_AM_I(ICM_MIRROR,-1);]
      ]
      ELSE ["still in CM, entering between bars
         IRNEW = IRNEW_MIRROR; "new region number"
      ]
   ]
]
ELSEIF(IR_MIRROR = N_MIRROR + 3)[ "local region N_MIRROR + 3
   IF(W(NP) > 0.0)[
      DIST = (ZMIN_MIRROR - Z(NP))/W(NP);
      IF(DIST < 0.0)[DIST = 0.0;]
      XPLN_MIRROR = X(NP) + U(NP)*DIST;
      IF(XPLN_MIRROR < XFMIN_MIRROR(1))[
         IRNEW_MIRROR = IRSTART_MIRROR + N_MIRROR + 1;
      ]
      ELSEIF(XPLN_MIRROR < XFMAX_MIRROR(N_MIRROR))[
         DO I = 1, N_MIRROR[
            IF(XPLN_MIRROR < XFMAX_MIRROR(I))[
               IRNEW_MIRROR = IRSTART_MIRROR + I - 1;
               EXIT;
            ]
         ]
      ]
      ELSE[
         IRNEW_MIRROR = IRSTART_MIRROR + N_MIRROR;
      ]
   ]
   ELSEIF(W(NP) < 0.0)[
      DIST = (ZFRONT_MIRROR - Z(NP))/W(NP);
      IF(DIST <= 0.0)[DIST = 1.E-16;]
      IRNEW_MIRROR = 1;
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF(IRNEW_MIRROR = 1) ["leaving CM through back"
         CALL WHERE_AM_I(ICM_MIRROR,-1);
      ]
      ELSE ["still in CM
         IRNEW = IRNEW_MIRROR; "new region number"
      ]
   ]
] " end of region N_MIRROR + 3

"   outside of CM, something is wrong
"   =================================
"
ELSE ["something is wrong"
   OUTPUT IR(NP)-IRSTART_MIRROR+1,IR(NP),
          ICM_MIRROR,IR_start_CM(ICM_MIRROR);
      (//' ************'//' HOWFAR_MIRROR error: region # confused,'/
         '    Region, local, absolute =',2I5/
         '    CM number=',I5,' start region =',I5/
         '    This particle is being terminated on spot.',
         ' ************'//);
   NERROR_M=NERROR_M+1;
   IDISC=1;
   USTEP = 0.; IRNEW = IRL;
   IF(NERROR_M.EQ.10)[
      OUTPUT;(//' TOO MANY PARTICLES ARE NEGLECTED IN THIS CM!!'//);
      STOP;
   ]
] "end of IF statement"
;
RETURN;
END; "End of subroutine HOWFAR_MIRROR"

%E   "start of subroutine INPUT_MIRROR"
"*******************************************************************************
"
"                           Subroutine INPUT_MIRROR
"                           **********************
"
"  A CM input subroutine for a series of 2 or more semi-infinite slabs.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_MIRROR;


;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_MIRROR,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;
"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_MIRROR
"T>*********************************
"T>
$REAL
      BDYTOL;            "T>boundary tolerence
INTEGER I,J,NDO,         "T>DO loop indeces
        IRA,             "T>Absolute region number
        MED_FLAG,        "T>flag used by media-sort macro $MED_INPUT
        MED_INDEX;       "T>medium index, set after medium sort by $MED_INPUT
"
"  initialize parameters
"  =====================
"
ICM_MIRROR = ICM;      "CM index for this component module
IRSTART_MIRROR = IR_start_CM(ICM_MIRROR); "Index of first region in this CM,
                                      "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_MIRROR) = 0; "Geometry-checking flag, 0 if no error detected
"
"  get the title line
"  ==================
OUTPUT;(/' MIRROR (MIRROR)');
OUTPUT RMAX_CM(ICM);(/' Next component is a flat inclined mirror'/
  '      Outer boundary is a square with |x| & |y| <',F10.2,' cm');
IF(ICM_MIRROR = 1)[OUTPUT Z_min_CM(1);
   (' This component starts at',F10.4,' cm from the ref plane(Z=0)');]
ELSE
   [OUTPUT Z_min_CM(ICM_MIRROR);(' Previous CM ends at:',F12.5,' cm');]

OUTPUT;(' TITLE: ',$);
MINPUT (MIRROR) TITLE_MIRROR;(60A1); "MINPUT is a macro with EOF and
                                "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_MIRROR;(' ',60A1);
"
" get distance from reference plane, z=0"
"   =============================
OUTPUT; (' Z position at which mirror (excluding air gap) starts '/
  'and thickness of mirror in Z direction (on one line)'/' : ',$);
MINPUT (MIRROR) ZMIN_MIRROR,ZTHICK_MIRROR;(2F15.0);
OUTPUT ZMIN_MIRROR,ZTHICK_MIRROR;(2F15.5);
IF(Z_min_CM(ICM_MIRROR)>ZMIN_MIRROR)[
   IF(ICM_MIRROR=1)[
     OUTPUT ICM_MIRROR, ZMIN_MIRROR,Z_min_CM(ICM_MIRROR);
      (//' ***WARNING IN CM ',I4,' (MIRROR):'/
         ' Z_min_CM(1) > Z at which mirror starts'/
         ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
     WRITE(IOUTLIST,100)ICM_MIRROR, ZMIN_MIRROR,Z_min_CM(ICM_MIRROR);
     100 FORMAT(//' ***WARNING IN CM ',I4,' (MIRROR):'/
         ' Z_min_CM(1) > Z at which mirror starts'/
         ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
      Z_min_CM(ICM_MIRROR)=ZMIN_MIRROR;
   ]
   ELSE[
     OUTPUT ICM_MIRROR;
      (//'***ERROR IN CM ',I4,' (MIRROR):'/
         'Overlaps with previous CM'//);
     IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
   ]
]
IF(ZTHICK_MIRROR<0.0)[
  OUTPUT ICM_MIRROR;
   (//'***ERROR IN CM ',I4,' (MIRROR):'/
      'ZTHICK < 0.0'//);
   IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
]

OUTPUT;
   (' XFMIN (X position that front face crosses front of CM) and'/,
    ' XBMIN (X position that front face crosses back of CM): ',$);
MINPUT (MIRROR) XFMIN_MIRROR(1),XBMIN_MIRROR(1);(2F15.0);
OUTPUT XFMIN_MIRROR(1),XBMIN_MIRROR(1);(2F11.5);
IF(XFMIN_MIRROR(1) < XBMIN_MIRROR(1))[
   OUTPUT ICM_MIRROR;
     (//'***ERROR IN CM ',I4,' (MIRROR):'/
        'XFMIN < XBMIN'//);
   IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
]
ELSEIF(ZTHICK_MIRROR>0.0 &
       ZTHICK_MIRROR/(XFMIN_MIRROR(1) - XBMIN_MIRROR(1)).LT.0.0875)[
   "for angles < 5 degrees, one should not use this component module"
   OUTPUT ICM_MIRROR;
   (//'***ERROR IN CM ',I4,' (MIRROR):'/
      'Mirror angle too small which will result in simulation error'/
      ' Module SLABS can be used for such small angle simulations.'//);
   IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
]
IF(ABS(XFMIN_MIRROR(1))>RMAX_CM(ICM_MIRROR))[
   OUTPUT ICM_MIRROR;
    (//'***WARNING IN CM ',I4,' (MIRROR):'/
       'XFMIN(1) is outside RMAX_CM'//);
   WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (MIRROR):''/
       ''XFMIN(1) is outside RMAX_CM''//)')
       ICM_MIRROR;
]
IF(ABS(XBMIN_MIRROR(1))>RMAX_CM(ICM_MIRROR))[
   OUTPUT ICM_MIRROR;
    (//'***WARNING IN CM ',I4,' (MIRROR):'/
       'XBMIN(1) is outside RMAX_CM'//);
   WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (MIRROR):''/
       ''XBMIN(1) is outside RMAX_CM''//)')
       ICM_MIRROR;
]
"
"   get geometry information for mirror
"   =================================================
"
N_MIRROR = $MAX_N_MIRROR;
OUTPUT N_MIRROR;(' Number of layers of the mirror, minimum 1, maximum',I4);
MINPUT (MIRROR) N_MIRROR; (I10);
OUTPUT N_MIRROR;(' Number of layers in this mirror is',I4);
IF(N_MIRROR>$MAX_N_MIRROR)[
   N_MIRROR=$MAX_N_MIRROR;
   OUTPUT ICM_MIRROR, N_MIRROR;
    (//'***ERROR IN CM ',I4,' (MIRROR):'/
       '# of layers > max. allowed'/
       '# of layers reduced to ',F8.5,' for now'//);
   IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
]
ELSEIF(N_MIRROR<1)[
   N_MIRROR=1;
   OUTPUT ICM_MIRROR;
    (//'***ERROR IN CM ',I4,' (MIRROR):'/
       '# of layers < 1'/
       '# of layers reset to 1 for now'//);
   IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
]
DO I =1, N_MIRROR [
   OUTPUT I;(' Thickness of layer',I3,'(in cm): ',$);
   ;MINPUT (MIRROR) DTHICK_MIRROR(I);(F15.0);
   OUTPUT DTHICK_MIRROR(I);(F15.5);
   IF(DTHICK_MIRROR(I)<0.0)[
      OUTPUT ICM_MIRROR, I;
       (//'***ERROR IN CM ',I4,' (MIRROR):'/
          'DTHICK(',I4,') < 0.0'//);
      IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
   ]
]

XFMAX_MIRROR(1) = XFMIN_MIRROR(1) +
      SQRT(ZTHICK_MIRROR**2+(XFMIN_MIRROR(1)-
      XBMIN_MIRROR(1))**2)/ZTHICK_MIRROR*DTHICK_MIRROR(1);
XBMAX_MIRROR(1) = XBMIN_MIRROR(1) +
      SQRT(ZTHICK_MIRROR**2+(XFMIN_MIRROR(1)-
      XBMIN_MIRROR(1))**2)/ZTHICK_MIRROR*DTHICK_MIRROR(1);
IF(N_MIRROR > 1)[
   DO I =2, N_MIRROR[
      XFMIN_MIRROR(I) = XFMIN_MIRROR(I-1) +
         SQRT(ZTHICK_MIRROR**2+(XFMIN_MIRROR(1)-
         XBMIN_MIRROR(1))**2)/ZTHICK_MIRROR*DTHICK_MIRROR(I-1);
      XFMAX_MIRROR(I-1) = XFMIN_MIRROR(I);
      XBMIN_MIRROR(I) = XBMIN_MIRROR(I-1) +
         SQRT(ZTHICK_MIRROR**2+(XFMIN_MIRROR(1)-
         XBMIN_MIRROR(1))**2)/ZTHICK_MIRROR*DTHICK_MIRROR(I-1);
      XBMAX_MIRROR(I-1) = XBMIN_MIRROR(I);
      XFMAX_MIRROR(I) = XFMAX_MIRROR(I-1) +
         SQRT(ZTHICK_MIRROR**2+(XFMIN_MIRROR(1)-
         XBMIN_MIRROR(1))**2)/ZTHICK_MIRROR*DTHICK_MIRROR(I);
      XBMAX_MIRROR(I) = XBMAX_MIRROR(I-1) +
         SQRT(ZTHICK_MIRROR**2+(XFMIN_MIRROR(1)-
         XBMIN_MIRROR(1))**2)/ZTHICK_MIRROR*DTHICK_MIRROR(I);
   ]
]
"
"   get ECUT, PCUT, dose scoring zone, and material in each region
"   ===============================================================
IRA = IRSTART_MIRROR-1;
DO IR_MIRROR = 1,N_MIRROR+2["loop through regions to get information"
   IRA = IRA+1;
   IF(IR_MIRROR <= N_MIRROR) [
         OUTPUT IR_MIRROR;(/' For layer',I3,' of mirror:');
   ]
   ELSEIF(IR_MIRROR = N_MIRROR+1)[OUTPUT;(/' For region behind mirror:');]
   ELSEIF(IR_MIRROR = N_MIRROR+2)[OUTPUT;
                 (/' For region in front of mirror:');]
   ;OUTPUT;(' ECUT, PCUT(MeV), DOSE ZONE(0=DO NOT SCORE DOSE), IREGION_TO_BIT'/
   ' :',$);
   ;MINPUT (MIRROR) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (2F15.0,2I5);
   OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (F8.3,F9.3,I15,I19);
   IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
   IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
   IF(IR_MIRROR=N_MIRROR+1)[
      OUTPUT; (' Material of region behind mirror ',$);]
   ELSEIF(IR_MIRROR=N_MIRROR+2)[
      OUTPUT; (' Material of region in front of mirror ',$);]
   ELSE[
      OUTPUT IR_MIRROR;(' Material of layer ',I3,' ',$);]
   ;$MED_INPUT(MIRROR); " inputs character array MED_IN from unit 5, loops
  "through array MEDIA(24,I) to check if medium was previously input.
  "If so, sets MED_INDEX to index of previous medium.  If not,
  "increments NMED and sets MED_INDEX to NMED.
   MED(IRA) = MED_INDEX; " medium of the planar slab
] "end of loop over IR_MIRROR"

"  set up air gap to previous CM, if present
"  =========================================
"
"  The air gap has the highest region number in the CM, even though it is at
"  the top of the component module.  This is to allow the assignment of region
"  numbers on input of the parameters of each local region (mainly to assign the
"  medium number of the region).  The air gap is then assigned after all of the
"  CM parameters have been input.
"
Z_gap_THICK(ICM_MIRROR) = ZMIN_MIRROR - Z_min_CM(ICM_MIRROR);
IF (Z_gap_THICK(ICM_MIRROR) < $MIN_GAP) [
   Z_gap_THICK(ICM_MIRROR) = 0.;
   ZMIN_MIRROR=Z_min_CM(ICM_MIRROR);
   N_GAP_MIRROR = 0; "no air gap for this CM
]
ELSE[ N_GAP_MIRROR = 1; "this CM has an air gap "]

IF(N_GAP_MIRROR =1)[
    IRA = IRSTART_MIRROR + N_MIRROR + 2;
    ECUT(IRA) = ECUT(IRA-1);
    PCUT(IRA) = PCUT(IRA-1);
    MED(IRA)  = AIR_INDEX; " medium of the air gap
    ESAVE(IRA)=ESAVE_GLOBAL;
]
"
"  parameter definition
"  ====================
"
"fill arrays of distance from reference plane (z=0) to front and back of slabs
"
BDYTOL = $BDY_TOL;
A_MIRROR =  (XBMIN_MIRROR(1) - XFMIN_MIRROR(1))/ZTHICK_MIRROR;
DO I = 1, N_MIRROR[
   BMIN_MIRROR(I) = XFMIN_MIRROR(I) - A_MIRROR*ZMIN_MIRROR;
   BMAX_MIRROR(I) = XFMAX_MIRROR(I) - A_MIRROR*ZMIN_MIRROR;
   BMINT_MIRROR(I) = BMIN_MIRROR(I) - BDYTOL;
   BMAXT_MIRROR(I) = BMAX_MIRROR(I) + BDYTOL;
   XFMINT_MIRROR(I) = XFMIN_MIRROR(I) - BDYTOL;
   XFMAXT_MIRROR(I) = XFMAX_MIRROR(I) + BDYTOL;
   XBMINT_MIRROR(I) = XBMIN_MIRROR(I) - BDYTOL;
   XBMAXT_MIRROR(I) = XBMAX_MIRROR(I) + BDYTOL;
]
"
"establish start of next CM
ZBACK_MIRROR = ZMIN_MIRROR + ZTHICK_MIRROR;
Z_min_CM(ICM_MIRROR+1) = ZBACK_MIRROR;
ZFRONT_MIRROR = Z_min_CM(ICM_MIRROR);
"
"
"  set up region numbers
"  =====================
"  This CM has N_MIRROR + 2 + N_GAP_MIRROR regions
"
IREND_MIRROR = IRSTART_MIRROR + N_MIRROR + N_GAP_MIRROR + 1;
               "Index of last region
NREG = NREG + N_MIRROR + N_GAP_MIRROR + 2;  "Total number of regions up
                                              "to and including this CM
IF (NREG <= $MXREG) ["have not exceeded maximum region number
      "Index of first region in next CM:"
      IR_start_CM(ICM_MIRROR+1) = IREND_MIRROR + 1;
]
ELSE [
      OUTPUT ICM_MIRROR,NREG,$MXREG;
      (//'***ERROR IN CM ',I4,' (MIRROR):'/
        I4,' regions requested, only',I4,' available');
         N_MIRROR=$MAX_N_MIRROR;
     IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
]
"
"  establish CM boundary
"  =====================
"
RMAX_CM_FLAG(ICM_MIRROR) = 2; "put a square boundary about CM
"
"  establish dose-scoring zones and range rejection parameters for each region
"  ===========================================================================
"
IRA = IRSTART_MIRROR-1; "absolute region number"
DO IR_MIRROR=1,N_MIRROR+2["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones
   IF(NDOSE_ZONE > $MAX_DOSE_ZONE)[
      OUTPUT NDOSE_ZONE;
       (' Too many dose zone !', 'NDOSE_ZONE =',I5,
        ' > $MAX_DOSE_ZONE');
      STOP;
   ]
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT);
   "charged particle range rejection parameters
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
] "end of loop over IR_MIRROR

"Initialize for automated range rejection"

"set up minimum thicknesses which in this case are just the last 5"
"slabs"
"If we ever need more than 5 slabs, we should extend this or do
"something fancy like group similar materials"

NDO = MIN(5,N_MIRROR); "consider at most 5 slabs of material"
                        "air gap handled below"
IF (IREJCT_GLOBAL = 1)[" i.e. will use automated range rejection"
   ;OUTPUT;(//' ************************************************************'/
        ' NOTE: MIRRORs RANGE REJECTION ALGORITHM ASSUMES THE MIRROR'/
        ' INTERSECTS THE ENTIRE BEAM!!!   CHECK IT'/
        ' ***********************************************************'//);
   WRITE(IOUTLIST,'(''*********************************************''/
      '' NOTE: MIRRORs RANGE REJECTION ALGORITHM ASSUMES THE MIRROR''/
      '' INTERSECTS THE ENTIRE BEAM!!!   CHECK IT''/
      '' ***********************************************************''//)');
   DO IR_MIRROR = 1, NDO [
      IRA = IR_MIRROR + IRSTART_MIRROR-1;   "absolute region"
      Z_min_thick(ICM,IR_MIRROR) = DTHICK_MIRROR(IR_MIRROR);
      MED_min_thick(ICM, IR_MIRROR) = MED(IRA);
      "OUTPUT IR_MIRROR,IRA,ICM, IR_MIRROR, Z_min_thick(ICM,IR_MIRROR),
         "ICM,IR_MIRROR, MED_min_thick(ICM, IR_MIRROR);
         "(' IR_MIRROR,IRA=',I2,',',I3,T25,'Z_min_thick(',2I2,')=',F10.3,
         "'  MED_min_thick(',2I3,')=',I2);
   ]"have set parameters for actual mirror materials"
   IF(NDO < 5)[  "still some of 5 locations available"
       "Use an approximation and treat entire rest of CM as if filled"
       "with air and with no reduction because of material in mirror"
       "This may be a bad approximation if used for anything other than a"
       "MIRROR ********************"
       Z_min_thick(ICM,NDO+1) = ZTHICK_MIRROR + Z_gap_thick(ICM_MIRROR);
       MED_min_thick(ICM,NDO+1) = AIR_INDEX; "AIR_INDEX is 0 or 1"
       OUTPUT ICM,NDO+1,Z_min_thick(ICM,NDO+1),ICM,NDO+1,
                    MED_min_thick(ICM,NDO+1);
       (' For air in CM ',T25,' Z_min_thick(',2I2,')=',F10.3,
                    '  MED_min_thick(',2I3,')=',I2);
   ]
]"end of loop on IREJCT_GLOBAL=1"
RETURN;

"   error messages
"   ==============
"
:EOF_MIRROR:
;OUTPUT ICM;(//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_MIRROR:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;
END;  "End of INPUT_MIRROR"
%E   "start of subroutine ISUMRY_MIRROR"
"*******************************************************************************
"
"                          Subroutine ISUMRY_MIRROR
"                          ************************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_MIRROR;


;IMPLICIT NONE;

;COMIN/ BOUNDS,CMs,CM_MIRROR,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_MIRROR
"T>**********************************
"T>
INTEGER
   ICOLOUR,    "T>colour of CM for EGS_Windows
   IRA,        "T>absolute region number
   I,J;        "T>DO loop index

$REAL VOL_MIRROR($MAX_N_MIRROR),   "T>volume
      YWIDTH,
      VOLTOT_MIRROR;
"
"   Mass of dose zone
"   =================
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_MIRROR.
VOLTOT_MIRROR=0.;
IRA=IRSTART_MIRROR-1;
DO I = 1, N_MIRROR + 2 [
   IRA = IRA+1; "absolute region number
   IF(I<=N_MIRROR)["one of the mirror slabs
     VOL_MIRROR(I)=SQRT(ZTHICK_MIRROR**2+(XFMIN_MIRROR(I)-
                    XBMIN_MIRROR(I))**2)*DTHICK_MIRROR(I)*
                    2*RMAX_CM(ICM_MIRROR);
     IF(XBMIN_MIRROR(I)<-RMAX_CM(ICM_MIRROR) &
       XBMAX_MIRROR(I)>=-RMAX_CM(ICM_MIRROR))[
         VOL_MIRROR(I)=VOL_MIRROR(I)-(ABS(XBMIN_MIRROR(I))-
                        RMAX_CM(ICM_MIRROR))**2*(ZTHICK_MIRROR/
                        (XFMIN_MIRROR(I)-XBMIN_MIRROR(I)))*
                        RMAX_CM(ICM_MIRROR);
     ]
     ELSEIF(XBMIN_MIRROR(I)<-RMAX_CM(ICM_MIRROR) &
       XBMAX_MIRROR(I)<-RMAX_CM(ICM_MIRROR))[
          VOL_MIRROR(I)=VOL_MIRROR(I)-(XBMAX_MIRROR(I)-
                         XBMIN_MIRROR(I))*(ABS(XBMAX_MIRROR(I))-
                         RMAX_CM(ICM_MIRROR))*ZTHICK_MIRROR/
                         (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*2*
                         RMAX_CM(ICM_MIRROR)-(XBMAX_MIRROR(I)-
                         XBMIN_MIRROR(I))**2*ZTHICK_MIRROR/
                         (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*
                         RMAX_CM(ICM_MIRROR);
     ]
     IF(XFMAX_MIRROR(I)>RMAX_CM(ICM_MIRROR) &
     XFMIN_MIRROR(I)<=RMAX_CM(ICM_MIRROR))[
         IF(XBMAX_MIRROR(I)>RMAX_CM(ICM_MIRROR))[
             VOL_MIRROR(I)=VOL_MIRROR(I)-(XFMAX_MIRROR(I)-
                        XBMAX_MIRROR(I))*ZTHICK_MIRROR*
                        RMAX_CM(ICM_MIRROR)-(XBMAX_MIRROR(I)-
                        RMAX_CM(ICM_MIRROR))*ZTHICK_MIRROR*
                        2*RMAX_CM(ICM_MIRROR);
         ]
         ELSE[
         VOL_MIRROR(I)=VOL_MIRROR(I)-(ABS(XFMAX_MIRROR(I))-
                        RMAX_CM(ICM_MIRROR))**2*ZTHICK_MIRROR/
                        (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*
                        RMAX_CM(ICM_MIRROR);
         ]
     ]
     ELSEIF(XFMAX_MIRROR(I)>RMAX_CM(ICM_MIRROR) &
     XFMIN_MIRROR(I)>RMAX_CM(ICM_MIRROR))[
        IF(XBMAX_MIRROR(I)>RMAX_CM(ICM_MIRROR))[
          VOL_MIRROR(I)=VOL_MIRROR(I)-(XFMAX_MIRROR(I)-
                         XFMIN_MIRROR(I))*(XFMIN_MIRROR(I)-
                         RMAX_CM(ICM_MIRROR))*ZTHICK_MIRROR/
                         (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*2*
                         RMAX_CM(ICM_MIRROR)-(XFMAX_MIRROR(I)-
                         XFMIN_MIRROR(I))**2*ZTHICK_MIRROR/
                         (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*
                         RMAX_CM(ICM_MIRROR)+(XBMAX_MIRROR(I)-
                         RMAX_CM(ICM_MIRROR))**2*ZTHICK_MIRROR/
                         (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*
                         RMAX_CM(ICM_MIRROR);
        ]
        ELSE[
          VOL_MIRROR(I)=VOL_MIRROR(I)-(XFMAX_MIRROR(I)-
                         XFMIN_MIRROR(I))*(ABS(XFMIN_MIRROR(I))-
                         RMAX_CM(ICM_MIRROR))*ZTHICK_MIRROR/
                         (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*2*
                         RMAX_CM(ICM_MIRROR)-(XFMAX_MIRROR(I)-
                        XFMIN_MIRROR(I))**2*ZTHICK_MIRROR/
                         (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*
                         RMAX_CM(ICM_MIRROR);
        ]
     ]
     VOLTOT_MIRROR=VOLTOT_MIRROR+VOL_MIRROR(I);
   ]
   ELSEIF(I=N_MIRROR+1)["region underneath mirror"
     IF(XBMAX_MIRROR(N_MIRROR)>RMAX_CM(ICM_MIRROR))[
       VOL_MIRROR(I)=0.0;
     ]
     ELSE[
       VOL_MIRROR(I)=ZTHICK_MIRROR*(XFMAX_MIRROR(N_MIRROR)
                    -XBMAX_MIRROR(N_MIRROR))*
                    RMAX_CM(ICM_MIRROR);
       IF(XFMAX_MIRROR(N_MIRROR)>RMAX_CM(ICM_MIRROR))[
          VOL_MIRROR(I)=VOL_MIRROR(I)-(RMAX_CM(ICM_MIRROR)-
                       XBMAX_MIRROR(N_MIRROR))*ZTHICK_MIRROR/
                       (XFMAX_MIRROR(N_MIRROR)-
                        XBMAX_MIRROR(N_MIRROR))*
                        (XFMAX_MIRROR(N_MIRROR)-
                        RMAX_CM(ICM_MIRROR))*2*RMAX_CM(ICM_MIRROR)-
                        (XFMAX_MIRROR(N_MIRROR)-
                         RMAX_CM(ICM_MIRROR))**2*ZTHICK_MIRROR/
                         (XFMAX_MIRROR(N_MIRROR)-
                        XBMAX_MIRROR(N_MIRROR))*
                        RMAX_CM(ICM_MIRROR);
       ]
       ELSE[
          VOL_MIRROR(I)=VOL_MIRROR(I)+ZTHICK_MIRROR*
                       (RMAX_CM(ICM_MIRROR)-
                        XFMAX_MIRROR(N_MIRROR))*2*
                        RMAX_CM(ICM_MIRROR);
       ]
       IF(XBMAX_MIRROR(N_MIRROR)<-RMAX_CM(ICM_MIRROR))[
          VOL_MIRROR(I)=VOL_MIRROR(I)-
                       (ABS(XBMAX_MIRROR(N_MIRROR))-
                       RMAX_CM(ICM_MIRROR))**2*ZTHICK_MIRROR/
                       (XFMAX_MIRROR(N_MIRROR)-
                        XBMAX_MIRROR(N_MIRROR))*
                        RMAX_CM(ICM_MIRROR);
       ]
    ]
    VOLTOT_MIRROR=VOLTOT_MIRROR+VOL_MIRROR(I)
   ]
   ELSEIF(I=N_MIRROR+2)["region above mirror"
     VOL_MIRROR(I)=ZTHICK_MIRROR*4*RMAX_CM(ICM_MIRROR)**2-
                    VOLTOT_MIRROR;
   ]
   IF(DOSE_ZONE(IRA).NE.0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+VOL_MIRROR(I)*RHOR(IRA);
   ]
]"end of do loop over regions"


"   Calculate four corner of the mirror for graph
"   =============================================
"

"   Summarize geometrical information for this component module in listing file
"   ===========================================================================

WRITE(IOUTLIST,110) ICM_MIRROR,TITLE_MIRROR;
WRITE(IOUTLIST,120) Z_min_CM(ICM_MIRROR),RMAX_CM(ICM_MIRROR),
                    ZMIN_MIRROR,ZTHICK_MIRROR;
WRITE(IOUTLIST,122);
IF(N_GAP_MIRROR~=0)[
   WRITE(IOUTLIST,126) 'airgap',ZMIN_MIRROR-Z_min_CM(ICM_MIRROR),
                       'NA','NA','NA','NA';
   WRITE(IOUTLIST,126) 'at top';
]
DO I=1,N_MIRROR[
   IF(I=1)[
   WRITE(IOUTLIST,124) I,'(front)',DTHICK_MIRROR(I),
                       XFMIN_MIRROR(I),XBMIN_MIRROR(I),
                       XFMAX_MIRROR(I),XBMAX_MIRROR(I);
   ]
   ELSE[
   WRITE(IOUTLIST,123) I,DTHICK_MIRROR(I),
                       XFMIN_MIRROR(I),XBMIN_MIRROR(I),
                       XFMAX_MIRROR(I),XBMAX_MIRROR(I);
   ]
]
WRITE(IOUTLIST,125) ATAN((XFMIN_MIRROR(1)-XBMIN_MIRROR(1))/
                         ZTHICK_MIRROR)*180./3.1415926;
WRITE(IOUTLIST,130);

IRA = IRSTART_MIRROR-1;
DO IR_MIRROR=1,N_MIRROR+2+N_GAP_MIRROR[
   IRA = IRA+1;
   IF(IR_MIRROR<=N_MIRROR)[
      IF(MED(IRA)=0)[
         WRITE(IOUTLIST,140) IR_MIRROR,IR_MIRROR,'layer',
               ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
               DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
               'V','a','c','u','u','m';
      ]
      ELSE[
         WRITE(IOUTLIST,140) IR_MIRROR,IR_MIRROR,'layer',
               ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
               DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
               (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]
   ELSEIF(IR_MIRROR<=N_MIRROR+2)[
       IF(MED(IRA)=0)[
         WRITE(IOUTLIST,141) IR_MIRROR,'NA','region',
               ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
               DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
               'V','a','c','u','u','m';
       ]
       ELSE[
         WRITE(IOUTLIST,141) IR_MIRROR,'NA','region',
               ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
               DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
               (MEDIA(J,MED(IRA)),J=1,9);
       ]
       IF(IR_MIRROR=N_MIRROR+1)[
            WRITE(IOUTLIST,142)'behind';
       ]
       ELSEIF(IR_MIRROR=N_MIRROR+2)[
            WRITE(IOUTLIST,142)'in front';
       ]
   ]
   ELSEIF(IR_MIRROR=N_MIRROR+2+N_GAP_MIRROR)[
       IF(MED(IRA)=0)[
         WRITE(IOUTLIST,141) IR_MIRROR,'NA','airgap',
               ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
               DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
              'V','a','c','u','u','m';
       ]
       ELSE[
         WRITE(IOUTLIST,141) IR_MIRROR,'NA','airgap',
               ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
               DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
              (MEDIA(J,MED(IRA)),J=1,9);
       ]
       WRITE(IOUTLIST,142)'at top';
   ]

]

110 FORMAT(///1X,79('-')/'  Component module',I3,' is a flat inclined',
           ' mirror MIRROR '
           /1X,79('-')
           //T2,'Title: ',68A1);
120 FORMAT(/T2,'MIRROR geometry parameters:',
           /T2,'-----------------------------',
           /T2,'Z of front face of CM = ',F15.5,' cm',
           /T2,'Half-width of outer boundary of CM = ',F15.5,' cm',
           /T2,'Z at which mirror starts = ',F15.5,
               ' cm',
           /T2,'Z span of mirror = ',F15.5,' cm');
122 FORMAT(/T2,
'layer #      thickness         XFMIN     XBMIN     XFMAX     XBMAX',
/T2,
'               (cm)                            (cm)');
123 FORMAT(T2,I2,F17.3,F17.3,3F10.3);
124 FORMAT(T2,I2,A7,F10.3,F17.3,3F10.3);
126 FORMAT(T2,A7,F12.3,A17,3A10);
125 FORMAT(/T2,'Angle of mirror face wrt z-axis = ',F15.5,' degrees');
130 FORMAT(/T2,'MIRROR region parameters:',
           /T2,'---------------------------',
           /T2,'local layer  location   electron   photon',
           '  range-rejection   dose  bit  medium'
           /T2,'region                   cutoff    cutoff',
           '   level     max    zone  set',
           /T2,'                         (MeV)      (MeV)',
           '   (MeV)    (MeV)');
140 FORMAT(T2,I3,I7,2X,A8,F11.3,F9.3,F9.3,F9.3,I5,I5,2X,9A1);
141 FORMAT(T2,I3,A7,2X,A8,F11.3,F9.3,F9.3,F9.3,I5,I5,2X,9A1);
142 FORMAT(T14,A8);



"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"
ICOLOUR = 1;
YWIDTH = MIN(RMAX_CM(ICM_MIRROR),3.);
IF(IWATCH = 4 | IZLAST = 2) [   "Creat a graphics file "
  ;$SELECT-COLOUR;
   DO I =1, N_MIRROR[
      WRITE(IOUTGEOM,201) ICOLOUR,'QUAD',
          XFMIN_MIRROR(I), YWIDTH,ZMIN_MIRROR,
          XBMIN_MIRROR(I), YWIDTH,ZBACK_MIRROR,
          XBMIN_MIRROR(I),-YWIDTH,ZBACK_MIRROR,
          XFMIN_MIRROR(I),-YWIDTH,ZMIN_MIRROR;
   ]
      WRITE(IOUTGEOM,201) ICOLOUR,'QUAD',
          XFMAX_MIRROR(N_MIRROR), YWIDTH,ZMIN_MIRROR,
          XBMAX_MIRROR(N_MIRROR), YWIDTH,ZBACK_MIRROR,
          XBMAX_MIRROR(N_MIRROR),-YWIDTH,ZBACK_MIRROR,
          XFMAX_MIRROR(N_MIRROR),-YWIDTH,ZMIN_MIRROR;

201   FORMAT(' ',I1,A4,12(F7.2,','));
]"End of graphics output"

"   end of ISUMRY_MIRROR
"   ===================
"
RETURN;
END; "end of subroutine ISUMRY_MIRROR"
%E   "start of subroutine WHERE_AM_I_MIRROR"
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_$MIRR
"                          ***************************
"
" WHERE_AM_I routine for a MIRROR"
"
" WHERE_AM_I_MIRROR determines the new region number when a particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_MIRROR subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_MIRROR from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************

;SUBROUTINE WHERE_AM_I_MIRROR(IDIR);


;IMPLICIT NONE;
;COMIN/CM_MIRROR,EPCONT,STACK/;
"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_MIRROR
"T>**************************************
"T>
INTEGER I,     "T>loop index
        IDIR;  "T>direction of particle, +1=forward, -1=backward
$REAL XF_MIRROR;
XF_MIRROR = X(NP) + USTEP*U(NP);
IF(IDIR=1) ["particle entering this CM through front face (upstream)
   IF(N_GAP_MIRROR ~= 0)[
      IRNEW = IREND_MIRROR;
   ]
   ELSE[
      IF(IRSTART_MIRROR = 2) [XF_MIRROR = X(NP);]
      IF(XF_MIRROR < XFMIN_MIRROR(1))[
         IRNEW = IRSTART_MIRROR + N_MIRROR + 1;
      ]
      ELSEIF(XF_MIRROR < XFMAX_MIRROR(N_MIRROR))[
         DO I = 1, N_MIRROR[
            IF(XF_MIRROR < XFMAX_MIRROR(I))[
               IRNEW = IRSTART_MIRROR + I - 1;
               RETURN;
            ]
         ]
      ]
      ELSE[
         IRNEW = IRSTART_MIRROR + N_MIRROR;
      ]
   ]
]
ELSE["particle entering this CM through back face (downstream)
   IF(XF_MIRROR > XBMAX_MIRROR(N_MIRROR))[
      IRNEW = IRSTART_MIRROR + N_MIRROR;
   ]
   ELSEIF(XF_MIRROR > XBMIN_MIRROR(1))[
      DO I = 1, N_MIRROR[
         IF(XF_MIRROR <= XBMAX_MIRROR(I))[
            IRNEW = IRSTART_MIRROR + I - 1;
            RETURN;
         ]
      ]
   ]
   ELSE[
      IRNEW = IRSTART_MIRROR + N_MIRROR + 1;
   ]
]
RETURN;
END; "End of subroutine WHERE_AM_I_MIRROR"

%E   "start of subroutine HOWNEAR_MIRROR"
"******************************************************************************
"
"                          Subroutine HOWNEAR_MIRROR
"                          ************************
"
" Calculates min. distance to nearest region boundary.
" Used to be a macro, but now the macro calls this subroutine.
"
"*******************************************************************************
;SUBROUTINE HOWNEAR_MIRROR(DIST);


$IMPLICIT-NONE;

COMIN/CM_MIRROR,STACK/;

$REAL DIST; "T> the min. distance to the nearest region boundary

IR_MIRROR = IR(NP) - IRSTART_MIRROR + 1;"local region number (relative)"
IF(IR_MIRROR > 0 & IR_MIRROR <= N_MIRROR )[   "local region 1 to N"
        DIST=MIN( Z(NP)-ZMIN_MIRROR,  "distance to the top surface"
        ZBACK_MIRROR-Z(NP),      "distance to the bottom"
        (X(NP)-XBMIN_MIRROR(IR_MIRROR))*(ZTHICK_MIRROR/
           SQRT((XBMIN_MIRROR(1)
           -XFMIN_MIRROR(1))**2+ZTHICK_MIRROR**2))
           -(ZBACK_MIRROR-Z(NP))*((XFMIN_MIRROR(1)-
           XBMIN_MIRROR(1))/SQRT((XBMIN_MIRROR(1)
           -XFMIN_MIRROR(1))**2+ZTHICK_MIRROR**2)), "distance to the side"
        (ZBACK_MIRROR-Z(NP))*((XFMIN_MIRROR(1)-
           XBMIN_MIRROR(1))/SQRT((XBMIN_MIRROR(1)
           -XFMIN_MIRROR(1))**2+ZTHICK_MIRROR**2))
           - (X(NP)-XBMAX_MIRROR(IR_MIRROR))*(ZTHICK_MIRROR/
           SQRT((XBMIN_MIRROR(1)-XFMIN_MIRROR(1))**2+ZTHICK_MIRROR**2))
        "distance to the side"
        );
]
ELSEIF(IR_MIRROR=N_MIRROR+1)["the air region below the mirror"
        DIST=MIN( Z(NP)-ZMIN_MIRROR,  "distance to the top surface"
        ZBACK_MIRROR-Z(NP),      "distance to the bottom"
        (X(NP)-XBMAX_MIRROR(N_MIRROR))*(ZTHICK_MIRROR
         /SQRT((XBMIN_MIRROR(1)-XFMIN_MIRROR(1))**2+ZTHICK_MIRROR**2))
           -(ZBACK_MIRROR-Z(NP))*((XFMIN_MIRROR(1)-XBMIN_MIRROR(1))/
           SQRT((XBMIN_MIRROR(1)-XFMIN_MIRROR(1))**2+ZTHICK_MIRROR**2))
        "distance to the side"
        );
]
ELSEIF(IR_MIRROR=N_MIRROR+2)["the air region above the mirror"
        DIST=MIN( Z(NP)-ZMIN_MIRROR,  "distance to the top surface"
        ZBACK_MIRROR-Z(NP),      "distance to the bottom"
        (ZBACK_MIRROR-Z(NP))*((XFMIN_MIRROR(1)-
           XBMIN_MIRROR(1))/SQRT((XBMIN_MIRROR(1)
           -XFMIN_MIRROR(1))**2+ZTHICK_MIRROR**2))
           -(X(NP)-XBMIN_MIRROR(1))*(ZTHICK_MIRROR/SQRT((XFMIN_MIRROR(1)
           -XBMIN_MIRROR(1))**2+ZTHICK_MIRROR**2))
        "distance to the side"
        );
]
ELSEIF((N_GAP_MIRROR.EQ.1)&(IR_MIRROR=N_MIRROR+3))["in the air gap"
   DIST=MIN( Z(NP)-ZFRONT_MIRROR,  "distance to the front surface of the CM"
   ZMIN_MIRROR-Z(NP)      "distance to the lower boundary of the region"
   );
]
RETURN;
END; "End of subroutine HOWNEAR_MIRROR"
"*******************************************************************************
"End of MIRROR_cm.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: set of paired bars                        "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          George Ding, 1992                                         "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                   Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             **************      ""toc:
"                             *            *      ""toc:
"                             *    JAWS    *      ""toc:
"                             *            *      ""toc:
"                             **************      ""toc:
"
"   Programmer:  George Ding.
"
"   Development  Version, begun September 5, 1992. Completed in October,1992
"
"   For complete history see sccs record.
"*******************************************************************************
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.
"   Set of paired bars.(collimator jaws or applicator)
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator:  a set of 1 or more
"   paired bars. The bas are of arbitrary thickness and material,and X or Y.
"   orintation.
"
"   This component module can be added to the simulation by including these
"   routines in the MORTRAN file BEAM_CM.MORTRAN and including the MORTRAN
"   replacement macros associated with this component module in the file
"   BEAM_COMMON.MORTRAN.  The order of the component modules in either of
"   these files is unimportant.  To explicitly include this component module in
"   the simulation it must be included in the $CM_LIST replacement statement.
"   The component modules in this list are stacked sequentially for the
"   simulation, one on top of the other, and must not overlap.
%E   "JAWS_cm.mortran - start of geometry description
"I>
"I> Geometry of JAWS:                             ""toc:
"I> ******************
"I>                                  ||
"I>                                \ || /   beam
"I>                                 \||/
"I>                                  \/
"I>
"I>             ---------------------------------------------------
"I>
"I>             -------------     IR=1      ----------------
"I>                         /              |
"I>  ISCM=1       IR=3     /               |   IR=2
"I>            ------------  - - - - - - -  -----------------
"I>
"I>           ---------------    IR=4     ---------------------
"I>                         /            \
"I>  ISCM=2       IR=6     /              \  IR=5
"I>       ----------------- - - - - - - -  -----------------------
"I>
"I>
"I>   IR is the region number within the CM.  There are N_JAWS local
"I>   regions. The first region is between bars or jaws.  An air gap is
"I>   always present at the front.
"I>
"I>
"I>            --------------------------------------------------------
"I>            |          Region               | Description          |
"I>            |-------------------------------|----------------------|
"I>            |  absolute       | local       |                      |
"I>            |-----------------|-------------|                      |
"I>            | IRSTART_JAWS    |  IR_JAWS    |   see graph          |
"I>            |   +IR_JAWS-1    |             |                      |
"I>            --------------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_MAINJAWS
"                      ISUMRY_MAINJAWS
"                      HOWFAR_MAINJAWS
"                      WHERE_AM_I_MAINJAWS
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS ON USE/BUGS
"                             ************************
"
" 1. Very small jaw angles lead to approximations because of boundary
"    tolerance.  Particles may step right through the tips of jaws,
"    without recognizing that they have entered and exited a distinct
"    region, where jaw thickness is ~$BDY_TOL cm.
"
"*******************************************************************************
"*******************************************************************************
"**************************  DESCRIPTION OF VARIABLES  *************************
"*******************************************************************************
"
"                             COMMON BLOCK VARIABLES
"                             **********************
"
"  Refer to the replacement macros in BEAM.MORTRAN and BEAM_COMMON.MORTRAN
"  which define the common block variables.
"
"*******************************************************************************
"
"                                OTHER VARIABLES
"                                ***************
"
"  Refer to the section on type declarations for each subroutine. The following
"  section describes the variables input from unit 5.  These variables define
"  the parameters of each simulation.
"
"*******************************************************************************
"
"                   Description of Users Input from Unit 5   ""toc:
"                   **************************************
"
"I>
"I>  CARDS CM_MAINJAWS(JAWS)
"I>  **************
"I>
"I>  -1  dummy line read in main used to separate input for CMs
"I>
"I>   0  RMAX_CM(ICM_JAWS) (F10.0):
"I>                         Perpendicular distance from Z-axis to boundary
"I>                         surrounding component module.  This component
"I>                         module has a square boundary.
"I>
"I>   1  TITLE_MAINJAWS (60A1):  Title of CM.
"I>
"I>   2  ISCM_MAX_MAINJAWS (I5):  Number of paired bars or jaws in CM.
"I>
"I>   Repeat 3 and 4 for I=1,ISCM_MAX_MAINJAWS
"I>
"I>   3  XY_CHOICE (A1):  indicate orientation of the paired bars/jaws
"I>                        X means bars/jaws perpendicular to x axis
"I>                       i.e. separation and movement is along x-axis
"I>
"I>   4  ZMIN_MAINJAWS(I), ZMAX_MAINJAWS(I), XFP_MAINJAWS(I), XBP_MAINJAWS(I),
"I>      XFN_MAINJAWS(I), XBN_MAINJAWS(I) (6F15.0)
"I>
"I>        ZMIN_MAINJAWS(I): Distance front of bars/jaws to reference plane.
"I>        ZMAX_MAINJAWS(I): Distance back of bars/jaws to reference plane.
"I>        XFP_MAINJAWS(I):  positive bar/jaw x or y coodinate at front.
"I>        XBP_MAINJAWS(I):  positive bar/jaw x or y coodinate at back.
"I>        XFN_MAINJAWS(I):  negative bar/jaw x or y coodinate at front.
"I>        XBN_MAINJAWS(I):  negative bar/jaw x or y coodinate at back.
"I>
"I>   5   ECUT, PCUT, DOSE_ZONE, IREGION_to_BIT (2F15.0,2I5): for interior
"I>                                                     (assumed to be AIR)
"I>
"I>          ECUT, PCUT:     Cutoff energies for electrons and photons.
"I>          DOSE_ZONE:      Dose scoring zone of air surrounding bars.
"I>          IREGION_TO_BIT: This region associated with this bit in LATCH
"I>
"I>   Repeat 6 and 7 for I=1,ISCM_MAX_MAINJAWS
"I>
"I>   6   ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT (2F15.0,2I5)
"I>
"I>          ECUT, PCUT:     Cutoff energies for electrons and photons in
"I>                          jaw I.
"I>          DOSE_ZONE:      Dose scoring zone for jaw I.
"I>          IREGION_TO_BIT: Both bars of jaw I associated with this bit.
"I>
"I>   7   MED_IN (24A1):  Medium of jaw I, used to set MED_INDEX.
"I>
"I>   Example
"I>   *******
"I>
"I>  The following set of cards defines a pair of 5 cm-thick Al jaws.
"I>  The first set of bars open along the X axis.  The inside faces of
"I>  this jaw are vertical at |X|=3cm.  The second set of bars open along
"I>  the Y axis.  The inside
"I>  faces of this jaw are angled out slightly, beginning at |Y|=3cm at the top
"I>  of the jaw and ending at |Y|=3.05cm at the bottom of the jaw.
"I>  The first jaw starts at Z=30.0 cm.  Note the 0.01 cm airgap between
"I>  the two jaws.
"I>
"I>  Electrons will be followed in the CM down to kinetic energies of
"I>  10 keV (total energies of 0.521 MeV) and photons will be followed down
"I>  to energies of 1 keV.  The dose deposited in the air will be scored and
"I>  added to the dose deposited in the bars in dose zone 1.
"I>
"I>  15.0    RMAX_CM
"I>  JAWS: 2 Al jaws, 5cm thick
"I>  2
"I>  X
"I>  30.0, 35.0, 3.0, 3.0, -3.0, -3.0
"I>  Y
"I>  35.01, 40.01, 3.0, 3.05, -3.0, -3.05
"I>  0.0, 0.0, 1, 0
"I>  0.0, 0.0, 1, 0
"I>  AL
"I>  0.0, 0.0, 1, 0
"I>  AL
"I>
"
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules not allowed
"
"   2)  Overlapping bars not allowed
"
"   3)  Air gap at front of CM required
"
"   4)  Inner boundary of all bars must be within CM boundary, RMAX_CM
"
"*******************************************************************************

%E   "Start of subroutine HOWFAR_MAINJAWS"
"*******************************************************************************
"************************** Component Module JAWS ******************************
"*******************************************************************************
"
"                          Subroutine HOWFAR_JAWS
"                          ***********************
"
" HOWFAR routine for set of paired bars.
"
" Determine if current region number is within component module JAWS, and if
" so evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are 4xISCM local regions see above graph:
"
"      local                    absolute                   description
"   ------------  ------------------------------------   ---------------
"       IRL       IR_start_CM(ICM_JAWS)+IRL-1               IRL
"
"   Geometrical co-ordinates, as set in INPUT_JAWS are:
"
"   ZFRONT_JAWS     front of CM (upstream surface, air region)
"   ZBACK_JAWS      back of CM (downstream surface, air region)
"   ZMIN_JAWS(IRL)  front of bars ISCM,
"   ZMAX_JAWS(IRL)  back of bars ISCM
"
"*******************************************************************************
;SUBROUTINE HOWFAR_MAINJAWS;


;IMPLICIT NONE;
;COMIN/CMs,CM_MAINJAWS,EPCONT,STACK,EGS-IO/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_JAWS
"T>**********************************
"T>
INTEGER
   IRL,        "T>local region number (absolute), required by HOWNEAR macro
   IB_MAINJAWS,    "T>index to deal with round off errors
   I_tpo,I_tne, "T>error indices
   IRNEW_MAINJAWS; "T>tentative new region number within CM (absolute)

$REAL
   DIST,       "T>distance to region boundary along current particle trajectory
   DIST1,      "T>holds value of DIST while further checks are done
   XPLN_MAINJAWS,  "T>X or Y at a plane surface along particle trajectory
   ZPLN_MAINJAWS;  "T>Z along particle trajectory

DATA I_tpo,I_tne/0,0/;

IRL = IR(NP); "local region number (absolute)
"
" This replacement macros sets DNEAR as well as defining IR_MAINJAWS,
 ;MAINJAWS_CM_HOWNEAR(DNEAR(NP));

" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module JAWS, and if
" so evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
";MAINJAWS_SET_XY_UV(ISCM_MAINJAWS);"" needed if no dnear caln in howfar"
IF(IR_MAINJAWS = 3*ISCM_MAINJAWS-2) ["particle not in positive or negative bar
   IB_MAINJAWS=1;
   IF(W(NP) > 0.0 )[
      IF(Z(NP) < ZMIN_MAINJAWS(ISCM_MAINJAWS) + $BDY_TOL) [
         DIST = (ZMIN_MAINJAWS(ISCM_MAINJAWS) - Z(NP) + $BDY_TOL)/W(NP);
         XPLN_MAINJAWS = XY_MAINJAWS + UV_MAINJAWS * DIST;
         ZPLN_MAINJAWS = Z(NP)+DIST*W(NP);
         IF(XPLN_MAINJAWS > APO_MAINJAWS(ISCM_MAINJAWS)*ZPLN_MAINJAWS +
            BPOT_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS))[
            "must check against plane of jaws at actual Z posn of particle"
            IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1) + 1;
         ]
         ELSEIF(XPLN_MAINJAWS < ANE_MAINJAWS(ISCM_MAINJAWS)*ZPLN_MAINJAWS +
                BNET_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS))[
            IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1) + 2;
         ]
         ELSE[
            DIST = (ZMAX_MAINJAWS(ISCM_MAINJAWS)-Z(NP) + $BDY_TOL)/W(NP);
            IF(DIST < 0) [DIST = 0.0;]
            IF(DIST=0. & ISCM_MAINJAWS=ISCM_MAX_MAINJAWS)[DIST=1.E-16;]
            XPLN_MAINJAWS = XY_MAINJAWS + UV_MAINJAWS * DIST;
            ZPLN_MAINJAWS = Z(NP)+DIST*W(NP);
            IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*ISCM_MAINJAWS;
            IF(ISCM_MAINJAWS = ISCM_MAX_MAINJAWS)[IRNEW_MAINJAWS =1;]
            DIST1=DIST;
            IF(XPLN_MAINJAWS > APO_MAINJAWS(ISCM_MAINJAWS)*ZPLN_MAINJAWS +
               BPOT_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS))[
               ;MAINJAWS_TPOSITIVE;
               IF(DIST<DIST1)[
                 IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1) + 1;
               ]
               ELSE[
                 DIST=DIST1;
               ]
            ]
            ELSEIF(XPLN_MAINJAWS < ANE_MAINJAWS(ISCM_MAINJAWS)*ZPLN_MAINJAWS +
                BNET_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS))[
               ;MAINJAWS_TNEGATIVE;
               IF(DIST<DIST1)[
                 IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1) + 2;
               ]
               ELSE[
                 DIST=DIST1;
               ]
            ]
         ]
      ]
      ELSE[ "Z(NP)> ZMIN_MAINJAWS(ISCM_MAINJAWS)
         IF( XY_MAINJAWS > APO_MAINJAWS(ISCM_MAINJAWS)*Z(NP) +
             BPOT_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS) &
             Z(NP) > ZMIN_MAINJAWS(ISCM_MAINJAWS) + $BDY_TOL  &
             Z(NP) < ZMAX_MAINJAWS(ISCM_MAINJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1) + 1;
            USTEP = 0.0;
            RETURN;
         ]
         IF( XY_MAINJAWS < ANE_MAINJAWS(ISCM_MAINJAWS)*Z(NP) +
             BNET_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS) &
             Z(NP) > ZMIN_MAINJAWS(ISCM_MAINJAWS) + $BDY_TOL &
             Z(NP) < ZMAX_MAINJAWS(ISCM_MAINJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1) + 2;
            USTEP = 0.0;
            RETURN;
         ]
         DIST = (ZMAX_MAINJAWS(ISCM_MAINJAWS) - Z(NP) + $BDY_TOL)/W(NP);
         IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*ISCM_MAINJAWS;
         IF(ISCM_MAINJAWS = ISCM_MAX_MAINJAWS)[IRNEW_MAINJAWS =1;]
         XPLN_MAINJAWS = XY_MAINJAWS + UV_MAINJAWS * DIST;
         ZPLN_MAINJAWS = Z(NP)+DIST*W(NP);
         DIST1=DIST;
         IF(XPLN_MAINJAWS > APO_MAINJAWS(ISCM_MAINJAWS)*ZPLN_MAINJAWS +
               BPOT_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS))[
            ;MAINJAWS_TPOSITIVE;
            IF(DIST<DIST1)[
              IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1) + 1;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
         ELSEIF(XPLN_MAINJAWS < ANE_MAINJAWS(ISCM_MAINJAWS)*ZPLN_MAINJAWS +
                BNET_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS))[
            ;MAINJAWS_TNEGATIVE;
            IF(DIST<DIST1)[
              IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1) + 2;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
      ]
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         IF (IRNEW_MAINJAWS=1) ["leaving CM through back"
            CALL WHERE_AM_I(ICM_MAINJAWS,1);
         ]
         ELSE ["still in CM, entering between bars
            IRNEW = IRNEW_MAINJAWS; "new region number"
         ]
      ]
   ]"end of w > 0.0
   ELSEIF (W(NP) < 0.0)[
      IF(Z(NP) < ZMIN_MAINJAWS(ISCM_MAINJAWS) + $BDY_TOL) [
         IF(ISCM_MAINJAWS = 1)[
            DIST = (ZFRONT_MAINJAWS - Z(NP))/W(NP);
            IF(DIST <= 0)[ DIST = 1.E-16;]
            IRNEW_MAINJAWS = 1;
         ]
         ELSE[ "  ISCM_MAINJAWS > 1
            ;MAINJAWS_SET_XY_UV(ISCM_MAINJAWS-1);
            DIST = (ZMAX_MAINJAWS(ISCM_MAINJAWS-1) - Z(NP) - $BDY_TOL)/W(NP);
            XPLN_MAINJAWS = XY_MAINJAWS + UV_MAINJAWS * DIST;
            ZPLN_MAINJAWS = Z(NP) + DIST*W(NP);
            IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-2);
            IF(XPLN_MAINJAWS > APO_MAINJAWS(ISCM_MAINJAWS-1)*ZPLN_MAINJAWS +
               BPOT_MAINJAWS(ISCM_MAINJAWS-1,IB_MAINJAWS))[
               IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-2) + 1;
            ]
            ELSEIF(XPLN_MAINJAWS < ANE_MAINJAWS(ISCM_MAINJAWS-1)*ZPLN_MAINJAWS +
                BNET_MAINJAWS(ISCM_MAINJAWS-1,IB_MAINJAWS))[
               IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-2) + 2;
            ]
         ]
      ]
      ELSE[ "Z(NP)> ZMIN_MAINJAWS(ISCM_MAINJAWS)
         IF( XY_MAINJAWS > APO_MAINJAWS(ISCM_MAINJAWS)*Z(NP) +
             BPOT_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS) &
             Z(NP) > ZMIN_MAINJAWS(ISCM_MAINJAWS) + $BDY_TOL  &
             Z(NP) < ZMAX_MAINJAWS(ISCM_MAINJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1) + 1;
            USTEP = 0.0;
            RETURN;
         ]
         IF( XY_MAINJAWS < ANE_MAINJAWS(ISCM_MAINJAWS)*Z(NP) +
             BNET_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS) &
             Z(NP) > ZMIN_MAINJAWS(ISCM_MAINJAWS) + $BDY_TOL &
             Z(NP) < ZMAX_MAINJAWS(ISCM_MAINJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1) + 2;
            USTEP = 0.0;
            RETURN;
         ]
         DIST = (ZMIN_MAINJAWS(ISCM_MAINJAWS)-Z(NP) - $BDY_TOL)/W(NP);
         IF(DIST < 0)[ DIST = 0.0;]
         XPLN_MAINJAWS = XY_MAINJAWS + UV_MAINJAWS * DIST;
         ZPLN_MAINJAWS = Z(NP) + DIST*W(NP);
         DIST1=DIST;
         IF(XPLN_MAINJAWS > APO_MAINJAWS(ISCM_MAINJAWS)*ZPLN_MAINJAWS +
               BPOT_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS))[
            ;MAINJAWS_TPOSITIVE;
            IF(DIST<DIST1)[
              IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1) + 1;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
         ELSEIF(XPLN_MAINJAWS < ANE_MAINJAWS(ISCM_MAINJAWS)*ZPLN_MAINJAWS +
                BNET_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS))[
            ;MAINJAWS_TNEGATIVE;
            IF(DIST<DIST1)[
              IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1) + 2;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
         ELSE[
            IF(ISCM_MAINJAWS = 1)[
               DIST = (ZFRONT_MAINJAWS - Z(NP))/W(NP);
               IF(DIST <= 0)[ DIST = 1.E-16;]
               IRNEW_MAINJAWS = 1;
            ]
            ELSE[ "  ISCM_MAINJAWS > 1
               ;MAINJAWS_SET_XY_UV(ISCM_MAINJAWS-1);
               DIST = (ZMAX_MAINJAWS(ISCM_MAINJAWS-1) - Z(NP) - $BDY_TOL)/W(NP);
               IF(DIST < 0)[ DIST = 0.0;]
               XPLN_MAINJAWS = XY_MAINJAWS + UV_MAINJAWS * DIST;
               ZPLN_MAINJAWS = Z(NP) + DIST*W(NP);
               IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-2);
               IF(XPLN_MAINJAWS > APO_MAINJAWS(ISCM_MAINJAWS-1)*ZPLN_MAINJAWS +
                  BPOT_MAINJAWS(ISCM_MAINJAWS-1,IB_MAINJAWS))[
                  IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-2) + 1;
               ]
               ELSEIF(XPLN_MAINJAWS <
                      ANE_MAINJAWS(ISCM_MAINJAWS-1)*ZPLN_MAINJAWS +
                      BNET_MAINJAWS(ISCM_MAINJAWS-1,IB_MAINJAWS))[
                  IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-2) + 2;
               ]
            ]
         ]
      ]
      IF(DIST <= USTEP ) [
         USTEP = DIST;
         IF(IRNEW_MAINJAWS = 1)["particle moving out from front CM
            CALL WHERE_AM_I(ICM_MAINJAWS,-1);
         ]
         ELSE[  "still in CM
            USTEP = DIST;
            IRNEW = IRNEW_MAINJAWS; "new region number"
         ]
      ]
   ] "end of w < 0.0
   ELSE[ "(W(NP) = 0.0
      DIST=1.0E20;
      IF(Z(NP) > ZMIN_MAINJAWS(ISCM_MAINJAWS) ) [
         IF(UV_MAINJAWS > 0.0)[
            IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1) + 1;
            ;MAINJAWS_TPOSITIVE;
         ]
         ELSE[
            IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1) + 2;
            ;MAINJAWS_TNEGATIVE;
         ]
      ]
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         IRNEW = IRNEW_MAINJAWS; "new region number"
      ]
   ]"end of w = 0.0
] "end of region 1
ELSEIF(IR_MAINJAWS = 3*ISCM_MAINJAWS-1) [ "particle in positive bars
   IB_MAINJAWS=2;
   IF( XY_MAINJAWS < APO_MAINJAWS(ISCM_MAINJAWS)*Z(NP) +
       BPOT_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS) &
      Z(NP) > ZMIN_MAINJAWS(ISCM_MAINJAWS) - $BDY_TOL  &
      Z(NP) < ZMAX_MAINJAWS(ISCM_MAINJAWS) + $BDY_TOL )[
      IRNEW = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1);
      USTEP = 0.0;
      RETURN;
   ]
   IF (W(NP) > 0.0) [
      DIST = (ZMAX_MAINJAWS(ISCM_MAINJAWS)-Z(NP)+$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IF(DIST=0. & ISCM_MAINJAWS = ISCM_MAX_MAINJAWS)[DIST=1.E-16;]
      IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*ISCM_MAINJAWS;
      IF(ISCM_MAINJAWS = ISCM_MAX_MAINJAWS)[IRNEW_MAINJAWS =1;]
      XPLN_MAINJAWS = XY_MAINJAWS + UV_MAINJAWS * DIST;
      ZPLN_MAINJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_MAINJAWS < APO_MAINJAWS(ISCM_MAINJAWS)*ZPLN_MAINJAWS +
       BPOT_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS))[
         IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1);
         ;MAINJAWS_TPOSITIVE;
      ]
   ]"end of w > 0.0
   ELSEIF (W(NP) < 0.0)[
      DIST = (ZMIN_MAINJAWS(ISCM_MAINJAWS)-Z(NP)-$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1);
      XPLN_MAINJAWS = XY_MAINJAWS + UV_MAINJAWS * DIST;
      ZPLN_MAINJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_MAINJAWS < APO_MAINJAWS(ISCM_MAINJAWS)*ZPLN_MAINJAWS +
       BPOT_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS))[
         ;MAINJAWS_TPOSITIVE;
      ]
   ] "end of w < 0.0
   ELSE[ "(W(NP) = 0.0
      DIST=1.0E20;
      IF(UV_MAINJAWS < 0.0)[
         IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1);
         ;MAINJAWS_TPOSITIVE;
      ]
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF (IRNEW_MAINJAWS=1) ["leaving CM through back"
         CALL WHERE_AM_I(ICM_MAINJAWS,1);
      ]
      ELSE ["still in CM, entering between bars
         IRNEW = IRNEW_MAINJAWS; "new region number"
      ]
   ]
]  "end of region 2
ELSEIF(IR_MAINJAWS = 3*ISCM_MAINJAWS) [ "particle in negative bars
   IB_MAINJAWS=2;
   IF( XY_MAINJAWS > ANE_MAINJAWS(ISCM_MAINJAWS)*Z(NP) +
       BNET_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS) &
      Z(NP) > ZMIN_MAINJAWS(ISCM_MAINJAWS) - $BDY_TOL &
      Z(NP) < ZMAX_MAINJAWS(ISCM_MAINJAWS) + $BDY_TOL )[
      IRNEW = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1);
      USTEP = 0.0;
      RETURN;
   ]
   IF (W(NP) > 0.0) [
      DIST = (ZMAX_MAINJAWS(ISCM_MAINJAWS)-Z(NP)+$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IF(DIST=0. & ISCM_MAINJAWS = ISCM_MAX_MAINJAWS)[DIST=1.E-16;]
      IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*ISCM_MAINJAWS;
      IF(ISCM_MAINJAWS = ISCM_MAX_MAINJAWS)[IRNEW_MAINJAWS =1;]
      XPLN_MAINJAWS = XY_MAINJAWS + UV_MAINJAWS * DIST;
      ZPLN_MAINJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_MAINJAWS > ANE_MAINJAWS(ISCM_MAINJAWS)*ZPLN_MAINJAWS +
       BNET_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS))[
         IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1);
         ;MAINJAWS_TNEGATIVE;
      ]
   ] "end of w > 0.0
   ELSEIF(W(NP) < 0.0)[
      DIST = (ZMIN_MAINJAWS(ISCM_MAINJAWS)-Z(NP)-$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1);
      XPLN_MAINJAWS = XY_MAINJAWS + UV_MAINJAWS * DIST;
      ZPLN_MAINJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_MAINJAWS > ANE_MAINJAWS(ISCM_MAINJAWS)*ZPLN_MAINJAWS +
       BNET_MAINJAWS(ISCM_MAINJAWS,IB_MAINJAWS))[
         ;MAINJAWS_TNEGATIVE;
      ]
   ]"end of w < 0.0
   ELSE[ "(W(NP) = 0.0
      DIST=1.0E20;
      IF(UV_MAINJAWS > 0.0)[
         IRNEW_MAINJAWS = IRSTART_MAINJAWS + 3*(ISCM_MAINJAWS-1);
         ;MAINJAWS_TNEGATIVE;
      ]
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF (IRNEW_MAINJAWS=1) ["leaving CM through back"
         CALL WHERE_AM_I(ICM_MAINJAWS,1);
      ]
      ELSE ["still in CM, entering between bars
         IRNEW = IRNEW_MAINJAWS; "new region number"
      ]
   ]
] "end of region 3
"end of CM regions"

"   outside of CM, something is wrong
"   =================================
"
ELSE ["something is wrong"
   OUTPUT IR(NP)-IRSTART_MAINJAWS+1, IR(NP), ICM_MAINJAWS,
          IR_start_CM(ICM_MAINJAWS);
      (//' ************'//' HOWFAR_JAWS error'/
         '    Region, local, absolute =',2I5/
         '    CM number=',I5,' start region =',I5/
         ' *********'//);
   STOP;
] "end of IF statement"
RETURN;
END; "End of subroutine HOWFAR_MAINJAWS"
%E   "Start of subroutine WHERE_AM_I_MAINJAWS"
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_JAWS
"                          ***************************
"
" WHERE_AM_I routine for set of JAWS.
"
" WHERE_AM_I_MAINJAWS determines the new region number when a particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_MAINJAWS subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_MAINJAWS from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************
;SUBROUTINE WHERE_AM_I_MAINJAWS(IDIR);


;IMPLICIT NONE;
;COMIN/CM_MAINJAWS,EPCONT,STACK/;

"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_JAWS
"T>**************************************
"T>
INTEGER IDIR;       "T>direction of particle, +1=forward, -1=backward
$REAL XBDY_MAINJAWS;
XBDY_MAINJAWS = X(NP) + U(NP)*USTEP;
IF(IXY_CHOICE_MAINJAWS(ISCM_MAX_MAINJAWS) = 1)[
   XBDY_MAINJAWS = Y(NP) + V(NP)*USTEP;
]
IF (IDIR=1) ["particle entering this CM through front face (upstream)
   "$CHECK_FRONT_MAINJAWS;"
   IRNEW = IRSTART_MAINJAWS;
]
ELSE ["particle entering this CM through back face (downstream)
   IRNEW = IRSTART_MAINJAWS + 3*ISCM_MAX_MAINJAWS - 3;
   "$CHECK_BACK_MAINJAWS;"
   IF(XBDY_MAINJAWS > XBP_MAINJAWS(ISCM_MAX_MAINJAWS))[
      IRNEW = IRSTART_MAINJAWS + 3*ISCM_MAX_MAINJAWS-2;
   ]
   ELSEIF(XBDY_MAINJAWS < XBN_MAINJAWS(ISCM_MAX_MAINJAWS))[
      IRNEW = IRSTART_MAINJAWS + 3*ISCM_MAX_MAINJAWS - 1;
   ]
]
RETURN;
END; "End of subroutine WHERE_AM_I_MAINJAWS"
%E   "Start of subroutine INPUT_MAINJAWS"
"*******************************************************************************
"
"                           Subroutine INPUT_JAWS
"                           **********************
"
"  A CM input subroutine for a series of 1 or more paired bars.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_MAINJAWS;


;IMPLICIT NONE;
;COMIN/BOUNDS,CMs,CM_MAINJAWS,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;

"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_JAWS
"T>*********************************
"T>
INTEGER I,J,         "T>DO loop indeces
        IRA,         "T>Absolute region number
        MED_FLAG,    "T>flag used by media-sort macro $MED_INPUT
        MED_INDEX;   "T>medium index, set after medium sort by $MED_INPUT

$REAL AIRGAPMIN_MAINJAWS,  "T>minimum air gap in front and back of CM
      BDYTOL;          "T>stores $BDY_TOL
CHARACTER*1 XY_CHOICE(1);
"
"  initialize parameters
"  =====================
"
ICM_MAINJAWS = ICM;      "CM index for this component module
IRSTART_MAINJAWS = IR_start_CM(ICM_MAINJAWS); "Index of first region in this CM,
                                      "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_MAINJAWS) = 0; "Geometry-checking flag, 0 if no error detected
AIRGAPMIN_MAINJAWS = 0.01; "Minimum 0.01 cm air gap at front and back of CM

OUTPUT RMAX_CM(ICM); (' This component is sets of paired bars or jaws'/
  '      Outer boundary is a square with |x| & |y| <',F10.2,' cm');
OUTPUT;(' TITLE: ',$);
;MINPUT (MAINJAWS) TITLE_MAINJAWS;(60A1);
                          ";MINPUT is a replacement macro with EOF and
                          "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_MAINJAWS;(' ',60A1);
IF(ICM_MAINJAWS = 1)[
   OUTPUT;(' This is the first component and starts at the reference plane');]
ELSE
   [OUTPUT Z_min_CM(ICM_MAINJAWS);(' Previous CM ends at:',F12.5,' cm');]

"
"   get geometry information
"   =============================
"
"get the number of paired bars/jaws"
ISCM_MAX_MAINJAWS = $MAX_N_MAINJAWS; "Max number of paired bars/jaws permitted
OUTPUT ISCM_MAX_MAINJAWS;
       (' NUMBER OF paired bars/jaws (minimum 1, maximum',I3,'): ',$);
;MINPUT (MAINJAWS) ISCM_MAX_MAINJAWS; (I5);
OUTPUT ISCM_MAX_MAINJAWS; (I5);
IF(ISCM_MAX_MAINJAWS > $MAX_N_MAINJAWS)[
   OUTPUT ICM_MAINJAWS, $MAX_N_MAINJAWS;
   (//'***ERROR IN CM ',I4,' (JAWS):'/
      '# of paired bars > max. allowed.'/
      '# of pared bars reduced to ',I4,' for now.'//);
   ISCM_MAX_MAINJAWS=$MAX_N_MAINJAWS;
   IERR_GEOM(ICM_MAINJAWS)=IERR_GEOM(ICM_MAINJAWS)+1;
]
ELSEIF(ISCM_MAX_MAINJAWS<1)[
   ISCM_MAX_MAINJAWS=1;
   OUTPUT ICM_MAINJAWS;
   (//'***ERROR IN CM ',I4,' (JAWS):'/
      '# of paired bars < 1'/
      '# of pared bars reset to 1 for now.'//);
   IERR_GEOM(ICM_MAINJAWS)=IERR_GEOM(ICM_MAINJAWS)+1;
]
N_MAINJAWS = 3*ISCM_MAX_MAINJAWS;

"loop over bars
DO I = 1,ISCM_MAX_MAINJAWS ["loop to get each bar location"
   OUTPUT I;(/' Paired bar/jaw set no:',I3,/
    ' Are bars/jaws perpendicular to x or y axis'/
    ' i.e. is separation measured on x or y axis'/
    ' (Input "y" or "Y" for Y jaws, any other character for X jaws): ',$);
   ;MINPUT (MAINJAWS) XY_CHOICE;(1A1);
   OUTPUT XY_CHOICE;(' ',1A1);
   IXY_CHOICE_MAINJAWS(I) = 0;
   IF(XY_CHOICE(1) ='Y' | XY_CHOICE(1) ='y')[ IXY_CHOICE_MAINJAWS(I) = 1;]
   IF(IXY_CHOICE_MAINJAWS(I) = 0)["this is x bars/jaws"
         OUTPUT;(' Input ZMIN, ZMAX & jaw coordinates: XFP, XBP,',
         ' XFN, XBN(cm) all on one line');
   ]
   ELSE ["this is y bars/jaws"
         OUTPUT;(' Input ZMIN, ZMAX & jaw coordinates: YFP, YBP,',
         ' YFN, YBN(cm) all on one line');
   ]
   IF(I=1)[
         OUTPUT AIRGAPMIN_MAINJAWS;
          (' (leave at least min. airgap = ',F8.5,' before 1st jaws)',
          /' : ',$);
   ]
   ELSE[
         OUTPUT AIRGAPMIN_MAINJAWS;
          (' (leave at least min. airgap = ',F8.5,' between jaws)',
           /' : ',$);
   ]
   ;MINPUT (MAINJAWS) ZMIN_MAINJAWS(I), ZMAX_MAINJAWS(I), XFP_MAINJAWS(I),
      XBP_MAINJAWS(I), XFN_MAINJAWS(I), XBN_MAINJAWS(I);(6F15.0);
   ;OUTPUT ZMIN_MAINJAWS(I),ZMAX_MAINJAWS(I), XFP_MAINJAWS(I),
      XBP_MAINJAWS(I), XFN_MAINJAWS(I),XBN_MAINJAWS(I); (6F11.5);
   IF(I=1)[
       IF(ICM_MAINJAWS=1 &
         Z_min_CM(ICM_MAINJAWS)>ZMIN_MAINJAWS(1)-AIRGAPMIN_MAINJAWS)[
         OUTPUT ICM_MAINJAWS, AIRGAPMIN_MAINJAWS,
         ZMIN_MAINJAWS(1)-AIRGAPMIN_MAINJAWS,Z_min_CM(1);
           (//' ***WARNING IN CM ',I4,' (JAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between top',
              ' of CM and 1st jaws.'/
              ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
           WRITE(IOUTLIST,100)ICM_MAINJAWS, AIRGAPMIN_MAINJAWS,
              ZMIN_MAINJAWS(1)-AIRGAPMIN_MAINJAWS,Z_min_CM(1);
          100 FORMAT(//' ***WARNING IN CM ',I4,' (JAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between top',
              ' of CM and 1st jaws.'/
              ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
          Z_min_CM(1)=ZMIN_MAINJAWS(1)-AIRGAPMIN_MAINJAWS;
       ]
       ELSEIF(Z_min_CM(ICM_MAINJAWS)>ZMIN_MAINJAWS(1))[
         OUTPUT ICM_MAINJAWS;
           (//'***ERROR IN CM ',I4,' (JAWS):'/
              'Overlaps with previous CM'//);
           IERR_GEOM(ICM_MAINJAWS)=IERR_GEOM(ICM_MAINJAWS)+1;
       ]
       ELSEIF(Z_min_CM(ICM_MAINJAWS)>ZMIN_MAINJAWS(1)-AIRGAPMIN_MAINJAWS)[
         OUTPUT ICM_MAINJAWS, AIRGAPMIN_MAINJAWS,
         Z_min_CM(ICM_MAINJAWS)+AIRGAPMIN_MAINJAWS,
                ZMIN_MAINJAWS(1);
           (//' ***WARNING IN CM ',I4,' (JAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         WRITE(IOUTLIST,101)ICM_MAINJAWS, AIRGAPMIN_MAINJAWS,
                Z_min_CM(ICM_MAINJAWS)+AIRGAPMIN_MAINJAWS,ZMIN_MAINJAWS(1);
         101 FORMAT(//' ***WARNING IN CM ',I4,' (JAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         ZMIN_MAINJAWS(1)=Z_min_CM(ICM_MAINJAWS)+AIRGAPMIN_MAINJAWS;
       ]
   ]
   ELSE[
     IF (ZMAX_MAINJAWS(I-1)>ZMIN_MAINJAWS(I))[
        OUTPUT ICM_MAINJAWS, I-1, I;
         (//'***ERROR IN CM ',I4,' (JAWS):'/
            'Paired bars ',I4,' overlap with paired bars ',I4//);
        IERR_GEOM(ICM_MAINJAWS)=IERR_GEOM(ICM_MAINJAWS)+1;
     ]
     ELSEIF (ZMAX_MAINJAWS(I-1)>ZMIN_MAINJAWS(I)-AIRGAPMIN_MAINJAWS)[
        OUTPUT ICM_MAINJAWS, AIRGAPMIN_MAINJAWS, I-1, I, I,
                ZMAX_MAINJAWS(I-1)+AIRGAPMIN_MAINJAWS,ZMIN_MAINJAWS(I);
          (//' ***WARNING IN CM ',I4,' (JAWS):'/
             ' Less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        WRITE(IOUTLIST,102)ICM_MAINJAWS, AIRGAPMIN_MAINJAWS, I-1, I, I,
                ZMAX_MAINJAWS(I-1)+AIRGAPMIN_MAINJAWS,ZMIN_MAINJAWS(I);
        102 FORMAT(//' ***WARNING IN CM ',I4,' (JAWS):'/
             ' Less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        ZMIN_MAINJAWS(I)=ZMAX_MAINJAWS(I-1)+AIRGAPMIN_MAINJAWS;
     ]
   ]
   IF(ZMIN_MAINJAWS(I) >= ZMAX_MAINJAWS(I))[
      OUTPUT ICM_MAINJAWS, I, I;
        (//'***ERROR IN CM ',I4,' (JAWS):'/
           'ZMIN(',I4,') >= ZMAX(',I4,')'//);
      IERR_GEOM(ICM_MAINJAWS)=IERR_GEOM(ICM_MAINJAWS)+1;
   ]
   IF(ABS(XFP_MAINJAWS(I))>RMAX_CM(ICM_MAINJAWS))[
      OUTPUT ICM_MAINJAWS, I;
        (//'***ERROR IN CM ',I4,' (JAWS):'/
           'XFP(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_MAINJAWS)=IERR_GEOM(ICM_MAINJAWS)+1;
   ]
   IF(ABS(XBP_MAINJAWS(I))>RMAX_CM(ICM_MAINJAWS))[
      OUTPUT ICM_MAINJAWS, I;
        (//'***ERROR IN CM ',I4,' (JAWS):'/
           'XBP(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_MAINJAWS)=IERR_GEOM(ICM_MAINJAWS)+1;
   ]
   IF(ABS(XFN_MAINJAWS(I))>RMAX_CM(ICM_MAINJAWS))[
      OUTPUT ICM_MAINJAWS, I;
        (//'***ERROR IN CM ',I4,' (JAWS):'/
           'XFN(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_MAINJAWS)=IERR_GEOM(ICM_MAINJAWS)+1;
   ]
   IF(ABS(XBN_MAINJAWS(I))>RMAX_CM(ICM_MAINJAWS))[
      OUTPUT ICM_MAINJAWS, I;
        (//'***ERROR IN CM ',I4,' (JAWS):'/
           'XBN(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_MAINJAWS)=IERR_GEOM(ICM_MAINJAWS)+1;
   ]
   IF(XFP_MAINJAWS(I) < XFN_MAINJAWS(I))[
      OUTPUT ICM_MAINJAWS, I, I;
        (//'***ERROR IN CM ',I4,' (JAWS):'/
           'XFP(',I4,') < XFN(',I4,')'//);
      IERR_GEOM(ICM_MAINJAWS)=IERR_GEOM(ICM_MAINJAWS)+1;
   ]
   ELSEIF(XFP_MAINJAWS(I) - XFN_MAINJAWS(I) < $BDY_TOL*3 )[
      XFP_MAINJAWS(I) = XFP_MAINJAWS(I) + $BDY_TOL*2;
      XFN_MAINJAWS(I) = XFN_MAINJAWS(I) - $BDY_TOL*2;
   ]
   IF(XBP_MAINJAWS(I) < XBN_MAINJAWS(I))[
      OUTPUT ICM_MAINJAWS, I, I;
        (//'***ERROR IN CM ',I4,' (JAWS):'/
           'XBP(',I4,') < XBN(',I4,')'//);
      IERR_GEOM(ICM_MAINJAWS)=IERR_GEOM(ICM_MAINJAWS)+1;
   ]
   ELSEIF(XBP_MAINJAWS(I) - XBN_MAINJAWS(I) < $BDY_TOL*3 )[
      XBP_MAINJAWS(I) = XBP_MAINJAWS(I) + $BDY_TOL*2;
      XBN_MAINJAWS(I) = XBN_MAINJAWS(I) - $BDY_TOL*2;
   ]
] "end of loop over paired bars/jaws"

"set absolute region number to first region in CM for next set of inputs"
IRA = IRSTART_MAINJAWS; "absolute region number
OUTPUT ; (/'  Now input data re ECUT and PCUT for each region'/
         /' For central region which is assumed to be air'
         /' ECUT,       PCUT,   DOSE ZONE OF AIR,   REGION TO BIT '/' : ',$);
MINPUT (MAINJAWS) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
        (2F15.0,2I5);
OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA); (2F11.5,2I5);
IF (ECUT(IRA) <  ECUTIN) ECUT(IRA)=ECUTIN;
IF (PCUT(IRA) <  PCUTIN) PCUT(IRA)=PCUTIN;
"get material for each bar and determine material number for these regions
MED(IRA) = AIR_INDEX; " medium of air
"
"now get info on each set of jaws"
DO IR_MAINJAWS = 2, N_MAINJAWS-1, 3[
   IRA = IRSTART_MAINJAWS  + IR_MAINJAWS - 1;"this is absolute region number"
   "central region air, so pick up same parameters as assigned above"
   "this is redundant on first time thru loop"
   ECUT(IRA-1) = ECUT(IRSTART_MAINJAWS);
   PCUT(IRA-1) = PCUT(IRSTART_MAINJAWS);
   DOSE_ZONE(IRA-1) = DOSE_ZONE(IRSTART_MAINJAWS);
   MED(IRA-1) = AIR_INDEX; " medium of air
   OUTPUT IR_MAINJAWS/3 + 1 ; (/' Paired bars/jaws no:',I3,
         /' ECUT,        PCUT,       DOSE ZONE,    IREGION_TO_BIT '/' :',$);
  ;MINPUT (MAINJAWS) ECUT(IRA), PCUT(IRA), DOSE_ZONE(IRA),
          IREGION_TO_BIT(IRA); (2F15.0,2I5);
  ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
          IREGION_TO_BIT(IRA); (2F11.5,2I5);
   IREGION_TO_BIT(IRA -1) = IREGION_TO_BIT(IRSTART_MAINJAWS);
   IF (ECUT(IRA) <  ECUTIN) ECUT(IRA)=ECUTIN;
   IF (PCUT(IRA) <  PCUTIN) PCUT(IRA)=PCUTIN;
   "get material for each bar and determine material number for these regions
   OUTPUT;(' Medium in this region',$);
   $MED_INPUT(MAINJAWS); " inputs character array MED_IN from unit 5, loops
      "through array MEDIA(24,I) to check if medium was previously input.
      "If so, sets MED_INDEX to index of previous medium.  If not,
      "increments NMED and sets MED_INDEX to NMED.
      "error transfers to :ERROR_MAINJAWS:
   MED(IRA) = MED_INDEX; " medium of the planar slab
   "both parts of jaw are same material so transfer parameters"
   ECUT(IRA+1) = ECUT(IRA);
   PCUT(IRA+1) = PCUT(IRA);
   DOSE_ZONE(IRA+1) = DOSE_ZONE(IRA);
   IREGION_TO_BIT(IRA +1) = IREGION_TO_BIT(IRA);
   MED(IRA+1) = MED(IRA); "
] "end of loop over IR_MAINJAWS"
;
"  set up region numbers
"  =====================
"
"  CM has 4xISCM_MAX_MAINJAWS regions, series of paired bars/jaws surrounded
"  by an air region.  paired bars are numbered in sequence starting from the
"  furthest upstream.
"
IREND_MAINJAWS = IRSTART_MAINJAWS + N_MAINJAWS-1;  "Index of last region
NREG = NREG+N_MAINJAWS;           "Total number of regions in full geometry up
                                "to and including this CM
IF (NREG <= $MXREG) ["have not exceeded maximum region number
      "Index of first region in next CM:"
      IR_start_CM(ICM_MAINJAWS+1) = IREND_MAINJAWS+1;
]
ELSE [
      OUTPUT ICM_MAINJAWS,NREG,$MXREG;
      (//'***ERROR IN CM ',I4,' (JAWS):'/
         I4,' regions requested, only ',I4,' available'//);
      IERR_GEOM(ICM_MAINJAWS)=IERR_GEOM(ICM_MAINJAWS)+1;
]
"
"  parameter definition
"  ====================
"
"geometrical coordinates
"
"
DO I = 1, ISCM_MAX_MAINJAWS[
   APO_MAINJAWS(I) = (XBP_MAINJAWS(I)-XFP_MAINJAWS(I))/
                           (ZMAX_MAINJAWS(I) - ZMIN_MAINJAWS(I));
   ANE_MAINJAWS(I) = (XBN_MAINJAWS(I)-XFN_MAINJAWS(I))/
                           (ZMAX_MAINJAWS(I) - ZMIN_MAINJAWS(I));
   BPO_MAINJAWS(I) =  XFP_MAINJAWS(I) - ZMIN_MAINJAWS(I)*APO_MAINJAWS(I);
   BNE_MAINJAWS(I) =  XFN_MAINJAWS(I) - ZMIN_MAINJAWS(I)*ANE_MAINJAWS(I);
   COSP_MAINJAWS(I)= (ZMAX_MAINJAWS(I) - ZMIN_MAINJAWS(I))/
                 SQRT( (ZMAX_MAINJAWS(I) - ZMIN_MAINJAWS(I))**2
                      +( XBP_MAINJAWS(I) - XFP_MAINJAWS(I) )**2 );
   COSN_MAINJAWS(I)= (ZMAX_MAINJAWS(I) - ZMIN_MAINJAWS(I))/
                 SQRT( (ZMAX_MAINJAWS(I) - ZMIN_MAINJAWS(I))**2
                       + (XBN_MAINJAWS(I) - XFN_MAINJAWS(I))**2 );
]

BDYTOL = $BDY_TOL;
DO I = 1,ISCM_MAX_MAINJAWS ["loop through bars"
   XFPT_MAINJAWS(I,1)  = XFP_MAINJAWS(I) + BDYTOL;
   XFPT_MAINJAWS(I,2)  = XFP_MAINJAWS(I) - BDYTOL;
   XBPT_MAINJAWS(I,1)  = XBP_MAINJAWS(I) + BDYTOL;
   XBPT_MAINJAWS(I,2)  = XBP_MAINJAWS(I) - BDYTOL;
   XFNT_MAINJAWS(I,1)  = XFN_MAINJAWS(I) - BDYTOL;
   XFNT_MAINJAWS(I,2)  = XFN_MAINJAWS(I) + BDYTOL;
   XBNT_MAINJAWS(I,1)  = XBN_MAINJAWS(I) - BDYTOL;
   XBNT_MAINJAWS(I,2)  = XBN_MAINJAWS(I) + BDYTOL;
   BPOT_MAINJAWS(I,1) =  BPO_MAINJAWS(I) + BDYTOL;
   BPOT_MAINJAWS(I,2) =  BPO_MAINJAWS(I) - BDYTOL;
   BNET_MAINJAWS(I,1) =  BNE_MAINJAWS(I) - BDYTOL;
   BNET_MAINJAWS(I,2) =  BNE_MAINJAWS(I) + BDYTOL;
] "end of loop over I"
"

"establish start of next CM
Z_min_CM(ICM_MAINJAWS+1) = ZMAX_MAINJAWS(ISCM_MAX_MAINJAWS);
"
"
ZFRONT_MAINJAWS = Z_min_CM(ICM_MAINJAWS);
ZBACK_MAINJAWS = Z_min_CM(ICM_MAINJAWS+1);
"
"  establish CM boundary is a square
"  =================================
"
RMAX_CM_FLAG(ICM_MAINJAWS) = 2; "=> put a square boundary about CM

"
"  establish dose-scoring zones and range rejection parameters for each region
"  ===========================================================================
"
IRA = IRSTART_MAINJAWS-1; "absolute region number
DO IR_MAINJAWS=1,N_MAINJAWS ["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones and latch
   "
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones"
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT);

   "charged particle range rejection parameters
   "
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region
] "end of loop over IR_MAINJAWS
E_min_out(ICM_MAINJAWS)=ECUT(IRA); "Minimum energy on exit from CM


"   return from INPUT_JAWS
"   =======================
"
RETURN;

"   error messages
"   ==============
"
:EOF_MAINJAWS:
;OUTPUT ICM;(//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_MAINJAWS:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;
END;  "End of INPUT_MAINJAWS"
%E   "Start of subroutine ISUMRY_MAINJAWS"
"*******************************************************************************
"
"                          Subroutine ISUMRY_JAWS
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_MAINJAWS;


;IMPLICIT NONE;

;COMIN/
   BOUNDS,CMs,CM_MAINJAWS,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_JAWS
"T>**********************************
"T>

INTEGER
   ICOLOUR,   "T>colour of CM for EGS_Windows
   IRA,       "T>absolute region number
   I,J;       "T>DO loop index

$REAL
   XYMAX,     "T>X or Y boundary
   VOLAIR_MAINJAWS,  "T>air volume
   VOL_MAINJAWS($MAX_N_MAINJAWS); "T>volume of air between bar
CHARACTER*1 XY_CHOICE(1);

"   Mass of dose zone
"   =================
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_MAINJAWS.
"
IRA = IRSTART_MAINJAWS-2; "absolute region number
VOLAIR_MAINJAWS=(ZBACK_MAINJAWS-ZFRONT_MAINJAWS)*
            4.*RMAX_CM2(ICM_MAINJAWS);"air volume"
DO I = 1,ISCM_MAX_MAINJAWS [
  IRA=IRA+3;
   VOL_MAINJAWS(I)=(ZMAX_MAINJAWS(I)-ZMIN_MAINJAWS(I))*
               (4.*RMAX_CM2(ICM_MAINJAWS)-
               RMAX_CM(ICM_MAINJAWS)*
               ABS(XFP_MAINJAWS(I)+
               XBP_MAINJAWS(I)-XFN_MAINJAWS(I)-
               XBN_MAINJAWS(I)));
   VOLAIR_MAINJAWS=VOLAIR_MAINJAWS-VOL_MAINJAWS(I);
   IF(DOSE_ZONE(IRA)~=0) [ "this is a dose zone"
      ID=DOSE_ZONE(IRA);
     AMASS(ID)=AMASS(ID)+RHOR(IRA)*VOL_MAINJAWS(I);
   ]
] "end of loop over IR_MAINJAWS"
IRA = IRSTART_MAINJAWS; "absolute region number
IF(DOSE_ZONE(IRA)~=0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+RHOR(IRA)*VOLAIR_MAINJAWS;
]


"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"
WRITE(IOUTLIST,110) ICM_MAINJAWS,TITLE_MAINJAWS;
WRITE(IOUTLIST,120) Z_min_CM(ICM_MAINJAWS),RMAX_CM(ICM_MAINJAWS);
WRITE(IOUTLIST,122);
DO I=1, ISCM_MAX_MAINJAWS[
   IF(I=1)[
        WRITE(IOUTLIST,124)'airgap',Z_min_CM(ICM_MAINJAWS),ZMIN_MAINJAWS(1)-
                           Z_min_CM(ICM_MAINJAWS),'NA','NA','NA','NA',
                           'NA';
   ]
   ELSE[
        WRITE(IOUTLIST,124)'airgap',ZMAX_MAINJAWS(I-1),ZMIN_MAINJAWS(I)-
                           ZMAX_MAINJAWS(I-1),'NA','NA','NA','NA',
                           'NA';
   ]
   IF(IXY_CHOICE_MAINJAWS(I) = 0)[XY_CHOICE(1) ='x';]
   ELSE[XY_CHOICE(1) ='y';]
   WRITE(IOUTLIST,123)I,ZMIN_MAINJAWS(I),ZMAX_MAINJAWS(I)-
                      ZMIN_MAINJAWS(I),XY_CHOICE(1),
                      XFP_MAINJAWS(I),XBP_MAINJAWS(I),
                      XFN_MAINJAWS(I),XBN_MAINJAWS(I);
]
WRITE(IOUTLIST,130);
IRA = IRSTART_MAINJAWS-1;
DO I = 1, ISCM_MAX_MAINJAWS [
   IRA = IRSTART_MAINJAWS + 3*(I-1);
   IF(MED(IRA)~=0)[
      WRITE(IOUTLIST,140) 3*(I-1)+1,I,'airgap',
        ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),(MEDIA(J,MED(IRA)),J=1,9);
        WRITE(IOUTLIST,141)'above &';
        WRITE(IOUTLIST,141)'centre';
   ]
   ELSE[
      WRITE(IOUTLIST,140) 3*(I-1)+1,I,'airgap',
        ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
        WRITE(IOUTLIST,141)'above &';
        WRITE(IOUTLIST,141)'centre';
   ]
   IF(MED(IRA+1)~=0)[
      WRITE(IOUTLIST,140) 3*(I-1)+2,I,'+ve jaw',
        ECUT(IRA+1),PCUT(IRA+1), ECUTRR(IRA+1),ESAVE(IRA+1),
        DOSE_ZONE(IRA+1),
         IREGION_TO_BIT(IRA+1),(MEDIA(J,MED(IRA+1)),J=1,9);
   ]
   ELSE[
      WRITE(IOUTLIST,140) 3*(I-1)+2,I,'+ve jaw',
        ECUT(IRA+1),PCUT(IRA+1), ECUTRR(IRA+1),ESAVE(IRA+1),
        DOSE_ZONE(IRA+1),
         IREGION_TO_BIT(IRA+1),'V','a','c','u','u','m';
   ]
   IF(MED(IRA+2)~=0)[
      WRITE(IOUTLIST,140) 3*(I-1)+3,I,'-ve jaw',
        ECUT(IRA+2),PCUT(IRA+2), ECUTRR(IRA+2),ESAVE(IRA+2),
        DOSE_ZONE(IRA+2),
         IREGION_TO_BIT(IRA+2),(MEDIA(J,MED(IRA+2)),J=1,9);
   ]
   ELSE[
      WRITE(IOUTLIST,140) 3*(I-1)+3,I,'-ve jaw',
        ECUT(IRA+2),PCUT(IRA+2), ECUTRR(IRA+2),ESAVE(IRA+2),
        DOSE_ZONE(IRA+2),
         IREGION_TO_BIT(IRA+2),'V','a','c','u','u','m';
   ]
   WRITE(IOUTLIST,141)' ';
]
110 FORMAT(///1X,79('-')/
'  Component module',I3,' is JAWS'
           /1X,79('-')
           //T5,'Title: ',68A1);
120 FORMAT(/T2,'MAINJAWS geometry parameters:',
           /T2,'-----------------------------',
           /T2,'Distance of front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Half-width of outer boundary of CM = ',F15.5,' cm');
122 FORMAT(/T2,
'jaw #    Z front    thickness    x or y               coordinates',
/T2,
'          face                   jaws        FP       BP       FN',
'      BN',
/T2,
'          (cm)        (cm)                                (cm)');
123 FORMAT(T2,I3,F12.3,F11.3,9X,A1,F12.3,F9.3,F9.3,F9.3);
124 FORMAT(T2,A6,F9.3,F11.3,8X,A2,A11,A9,A9,A8);
130 FORMAT(/T2,'MAINJAWS region parameters:',
           /T2,'---------------------------',
           /T2,'local jaw #   location  electron  photon',
           '  range-rejection   dose  bit  medium'
           /T2,'region                   cutoff   cutoff',
           '   level     max    zone  set'
           /T2,'                          (MeV)    (MeV)',
           '   (MeV)    (MeV)');
140 FORMAT(T2,I3,I7,4X,A7,F10.3,F9.3,F8.3,F9.3,I6,I5,2X,9A1);
141 FORMAT(15X,A7);


"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"
IF (IWATCH = 4 | IZLAST = 2) ["Graphics file requested"
   ;$SELECT-COLOUR; "Macro for selecting ICOLOUR = 1, 2, or 3, colour of CM"
   DO I =1,ISCM_MAX_MAINJAWS["Loop over local region number"
      XYMAX = RMAX_CM(ICM_MAINJAWS);
         IF(IXY_CHOICE_MAINJAWS(I) = 0)[
            WRITE(IOUTGEOM,200)
               ICOLOUR,'COLX',XYMAX,XFP_MAINJAWS(I),XBP_MAINJAWS(I),XYMAX,XYMAX,
               ZMIN_MAINJAWS(I),ZMAX_MAINJAWS(I);
            WRITE(IOUTGEOM,200)
              ICOLOUR,'COLX',XFN_MAINJAWS(I),-XYMAX,-XYMAX,XBN_MAINJAWS(I),
              XYMAX, ZMIN_MAINJAWS(I),ZMAX_MAINJAWS(I);
         ]
         ELSEIF(IXY_CHOICE_MAINJAWS(I) = 1)[
            J = ICOLOUR-1;
            IF(J < 1)[J = 4;]
            WRITE(IOUTGEOM,200)
               J,'COLY',XYMAX,XFP_MAINJAWS(I),XBP_MAINJAWS(I),XYMAX,XYMAX,
               ZMIN_MAINJAWS(I),ZMAX_MAINJAWS(I);
            WRITE(IOUTGEOM,200)
               J,'COLY',XFN_MAINJAWS(I),-XYMAX,-XYMAX,XBN_MAINJAWS(I),XYMAX,
               ZMIN_MAINJAWS(I),ZMAX_MAINJAWS(I);
         ]
   ]
] "End of graphics output"

200 FORMAT(' ',I1,A4,10(F7.2,','));

"   end of ISUMRY_JAWS
"   ===================
"
RETURN;
END;  "End of subroutine ISUMRY_MAINJAWS"

%E   "Start of subroutine HOWNEAR_MAINJAWS"
"******************************************************************************
"
"                          Subroutine HOWNEAR_JAWS
"                          ***********************
"
" Returns min. distance to nearest region boundary
" Replaces the old HOWNEAR macro.
"
"*******************************************************************************
;SUBROUTINE HOWNEAR_MAINJAWS(DIST);


$IMPLICIT-NONE;

COMIN/CM_MAINJAWS,STACK/;

$REAL DIST; "T> min. distance to nearest boundary

IR_MAINJAWS = IR(NP)-IRSTART_MAINJAWS+1;
ISCM_MAINJAWS = (IR_MAINJAWS-1)/3 + 1;
XY_MAINJAWS = X(NP);
UV_MAINJAWS = U(NP);
IF(IXY_CHOICE_MAINJAWS(ISCM_MAINJAWS) = 1)[
   XY_MAINJAWS = Y(NP);
   UV_MAINJAWS = V(NP);
]
IF(IR_MAINJAWS = 3*ISCM_MAINJAWS-1) [ "particle in positive bars"
   DIST = COSP_MAINJAWS(ISCM_MAINJAWS)
          *(XY_MAINJAWS-APO_MAINJAWS(ISCM_MAINJAWS)*Z(NP)
           -BPOT_MAINJAWS(ISCM_MAINJAWS,2));
   DIST = MIN(DIST,
              ZMAX_MAINJAWS(ISCM_MAINJAWS)-Z(NP),
              Z(NP) - ZMIN_MAINJAWS(ISCM_MAINJAWS));
]
ELSEIF(IR_MAINJAWS = 3*ISCM_MAINJAWS) [ "particle in negative bars"
   DIST = COSN_MAINJAWS(ISCM_MAINJAWS)
          *(ANE_MAINJAWS(ISCM_MAINJAWS)*Z(NP)
          +BNET_MAINJAWS(ISCM_MAINJAWS,2)-XY_MAINJAWS) ;
   DIST = MIN(DIST,
              ZMAX_MAINJAWS(ISCM_MAINJAWS) - Z(NP),
              Z(NP) - ZMIN_MAINJAWS(ISCM_MAINJAWS) );
]
ELSE[ "particle in air"
   DIST = 0.0;
]
RETURN;
END; "End of subroutine HOWNEAR_MAINJAWS"
"*******************************************************************************
"End of JAWS_cm.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: set of rectangular applicators            "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Geoff Zhang                                               "
"                   Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             ****************          ""toc:
"                             *              *          ""toc:
"                             *   APPLICAT   *          ""toc:
"                             *              *          ""toc:
"                             ****************          ""toc:
"
"   History of modifications given by sccs
"
"*******************************************************************************
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.  Set of rectangular applicators.
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.mortran to simulate
"   one component module of a clinical linear accelerator:  a set of 1 or more
"   applicators.  Each applicator is defined by two concentric, symmetric
"   rectangles or squares, the inner region being air.  The scrapers are
"   of arbitrary thickness, width and position relative to the reference
"   plane (Z=0). The applicators may have different materials.
"
"   This is an extention of APPSQ_cm.mortran starting from SID 1.53 last
"   edited on 14 Aug 1998.
"
%E   "APPLICAT_cm.mortran - start of geometry description
"I>
"I> Geometry of APPLICAT (APPLICAT):               ""toc:
"I> *********************
"I>
"I>                     |                  ___         _____   |
"I>                     |    ____         |   |       |     |  |
"I>                     |   |    |        |IR=|       |IR=  |  |
"I>                     |   |IR=1|        |  2|       |N_SC |  |
"I>                     |   |____|        |___|       |_____|  |
"I>                     |                                      |
"I>       --------->    |                                      |
"I>          beam       |            IR=N_SC+1                 |
"I>       direction     |    ____          ___         _____   |
"I>                     |   |    |        |IR=|       |IR=  |  |
"I>                     |   |IR=1|        |  2|       |N_SC |  |
"I>                     |   |____|        |   |       |     |  |
"I>                     |                 |___|       |_____|  |
"I>                     |                                      |
"I>
"I>   IR is the region number within the CM.  There are N_APPLICAT+1 local
"I>   regions. The first region is the furthest upstream.  An air gap is
"I>   always present at the front and back of the CM.
"I>
"I>
"I>            --------------------------------------------------------
"I>            |          Region               | Description          |
"I>            |-------------------------------|----------------------|
"I>            |  absolute       | local       |                      |
"I>            |-----------------|-------------|                      |
"I>            |IRSTART_APPLICAT | IR_APPLICAT |  applicator          |
"I>            |  +IR_APPLICAT-1 |             |                      |
"I>            |IRSTART_APPLICAT | N_APPLICAT+1| intervening air space|
"I>            |  +N_APPLICAT    |             |                      |
"I>            --------------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_APPLICAT
"                      ISUMRY_APPLICAT
"                      HOWFAR_APPLICAT
"                      WHERE_AM_I_APPLICAT
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS ON USE/BUGS         ""toc:
"                             *******************
"
"
;
"*******************************************************************************
"**************************  DESCRIPTION OF VARIABLES  *************************
"*******************************************************************************
"
"                             COMMON BLOCK VARIABLES
"                             **********************
"
"  Refer to the replacement macros in BEAM.mortran and APPLICAT_macros.mortran
"  which define the common block variables.
"
"*******************************************************************************
"
"                                OTHER VARIABLES
"                                ***************
"
"  Refer to the section on type declarations for each subroutine. The following
"  section describes the variables input from unit 5.  These variables define
"  the parameters of each simulation.
"
"*******************************************************************************
"
"                               INPUT FROM UNIT 5              ""toc:
"                               *****************              ""toc:
"
"I>
"I>  CARDS CM_APPLICAT
"I>  *****************
"I>
"I>  -1  Dummy line to indicate start of CM.
"I>
"I>   0  RMAX_CM(ICM_APPLICAT) (F10.0): Half-width of outer boundary of CM (cm)
"I>
"I>   1  TITLE_APPLICAT (60A1):  Title of CM.
"I>
"I>   2  ZBACK_APPLICAT (F15.0): Z of back face of the CM
"I>                           (air will be added if necessary below the
"I>                           last applicator)
"I>
"I>       Note that there is always an air gap (thickness =
"I>       AIRGAPMIN) in the front and the back of this CM.
"I>       Therefore ZBACK_APPLICAT should be >= Z of the back face of the
"I>       last scraper + AIRGAPMIN.
"I>
"I>   3  N_APPLICAT, ISHAPE (2I5):
"I>        N_APPLICAT:  Number of scrapers in the CM.
"I>        ISHAPE:       Index of applicators' shape, default to square, 1 for
"I>                      rectangle.
"I>
"I>   Repeat 4 for I=1,N_APPLICAT.
"I>
"I>   4  ZMIN_APPLICAT(I), ZTHICK_APPLICAT(I), XMIN_APPLICAT(I),
"I>      YMIN_APPLICAT(I),
"I>      WIDTHX_APPLICAT(I), WIDTHY_APPLICAT(I),
"I>      DOSE_ZONE,IREGION_TO_BIT (6F15.0,2I4):
"I>
"I>        ZMIN_APPLICAT(I):   Z of front face of scraper I.
"I>                             Note that ZMIN_APPLICAT(1)-
"I>                             Z_min_CM must be >= AIRGAPMIN.
"I>        ZTHICK_APPLICAT(I): Thickness of scraper I.  Note that
"I>                             ZMIN_APPLICAT(I+1)-(ZMIN_APPLICAT(I)+
"I>                             ZTHICK_APPLICAT(I))
"I>                             must be >= AIRGAPMIN.
"I>        XMIN_APPLICAT(I):   (ISHAPE=1)  Half-width of inner opening in
"I>                                         x in scraper I.
"I>                             (ISHAPE~=1) Half-width of inner opening in x
"I>                                         and y in scraper I.
"I>        YMIN_APPLICAT(I):   (ISHAPE=1)  Half-width of inner opening in y in
"I>                                         scraper I.
"I>                             (ISHAPE~=1) Not required.
"I>        WIDTHX_APPLICAT(I): (ISHAPE=1)  Width of bar in x (ie material
"I>                                         surrounding inner opening) of
"I>                                         scraper I.
"I>                             (ISHAPE~=1) Width of bar in x and y for
"I>                                         scraper I.
"I>        WIDTHY_APPLICAT(I): (ISHAPE=1)  Width of bar in y (ie material
"I>                                         surrounding inner opening) of
"I>                                         scraper I.
"I>                             (ISHAPE~=1) Not required.
"I>        DOSE_ZONE:           Dose scoring zone for the scraper bar.
"I>        IREGION_TO_BIT:      Bit setting number for the scraper bar.
"I>
"I>        Note restrictions to allow air gaps between scrapers and
"I>        before the first scraper:
"I>         ZMIN_APPLICAT(1)-Z_min_CM >= AIRGAPMIN
"I>         ZMIN_APPLICAT(I+1)-(ZMIN_APPLICAT(I)+ZTHICK_APPLICAT(I)) >=
"I>         AIRGAPMIN
"I>
"I>   6   ECUT, PCUT, DOSE_ZONE_AIR,IREGION_TO_BIT_AIR (2F15.0,2I5):
"I>
"I>          ECUT, PCUT:     Cutoff energies for electrons and photons for
"I>                          both the bars and the surrounding (air) region
"I>          DOSE_ZONE_AIR:  Dose scoring zone for the surrounding region
"I>     IREGION_TO_BIT_AIR:  Bit set number for the surrounding (air) region
"I>
"I>   Repeat 7 for I=1,N_APPLICAT.
"I>
"I>   7   MED_IN (24A1):  Medium of the bar of scraper I, used to
"I>                       set MED_INDEX.
"I>
"I>   Example
"I>   *******
"I>
"I>  The following set of cards defines an applicator consisting of 2
"I>  0.2cm-thick Al scrapers.  The scrapers are separated by 8cm of air.
"I>  Scrapers can be thought of as made of 4 bars arranged in a rectangle
"I>  orthogonal to the Z axis.  For both scrapers in this example, the half-
"I>  width of the openings created by the bars is 2cm in x, 4cm in y, and the
"I>  width of the bars themselves is 1cm in x, 1.5cm in y.  The front scraper
"I>  starts at Z=60.5 cm.
"I>
"I>  Electrons will be followed in the CM down to kinetic energies of
"I>  10 keV (total energies of 0.521 MeV) and photons will be followed down
"I>  to energies of 1 keV.  The dose deposited in the air will be scored and
"I>  added to the dose from the other regions in dose scoring zone 1, and the
"I>  dose deposited in both scrapers will be scored and added to the dose
"I>  from the other regions in dose scoring zone 2.  There is a minimum 0.1 cm
"I>  air gap at the front and back of the scrapers CM so that the applicator
"I>  bars are completely surrounded by air.
"I>
"I>  10.0,    RMAX_CM
"I>  Applicators: 0.2cm Al at 60.5cm and 68.7cm, ECUT=0.521, PCUT=0.01
"I>  100.0,   extended air to Z=100 cm
"I>  2, 1,    two rectangular applicators
"I>  60.5, 0.2, 2.0, 4.0, 1.0, 1.5, 2,3
"I>  68.7, 0.2, 2.0, 4.0, 1.0, 1.5, 2,2
"I>  0.521, 0.01, 1, 0
"I>  AL521ICRU
"I>  AL521ICRU
"
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules not allowed
"
"   2)  Overlapping scrapers not allowed
"
"   3)  Air gap at front and back of CM required
"
"   4)  Inner boundary of all scrapers must be within CM boundary, RMAX_CM
"
"*******************************************************************************

%E "start of subroutine HOWFAR_APPLICAT"
"*******************************************************************************
"************************** Component Module APPLICAT **************************
"*******************************************************************************
"
"                          Subroutine HOWFAR_APPLICAT
"                          **************************
"
" HOWFAR routine for set of scrapers.
"
" Determine if current region number is within component module APPLICAT, and if
" so evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are N_APPLICAT+1 local regions + an air gap (if present):
"
"      local                    absolute                   description
"   ------------  ------------------------------------   ---------------
"       IRL       IR_start_CM(ICM_APPLICAT)+IRL-1        scraper IRL
"   N_APPLICAT+1  IR_start_CM(ICM_APPLICAT)+N_APPLICAT   intervening air
"
"   Geometrical co-ordinates, as set in INPUT_APPLICAT are:
"
"   ZFRONT_APPLICAT     front of CM (upstream surface, air region)
"   ZBACK_APPLICAT      back of CM (downstream surface, air region)
"   ZMIN_APPLICAT(IRL)  front of scraper IRL, or front of surrounding air
"                      region for IRL=N_APPLICAT+1
"   ZMAX_APPLICAT(IRL)  back of scraper IRL or air region
"   XMIN_APPLICAT(IRL)  minimum X of scraper IRL
"   YMIN_APPLICAT(IRL)  minimum Y of scraper IRL
"   XMAX_APPLICAT(IRL)  maximum X of scraper IRL
"   YMAX_APPLICAT(IRL)  maximum Y of scraper IRL
"
"*******************************************************************************
;
;SUBROUTINE HOWFAR_APPLICAT;


;IMPLICIT NONE;

;COMIN/CMs,CM_APPLICAT,EPCONT,STACK,EGS-IO/;

"T>
"T>*************************************
"T>TYPE DECLARATIONS FOR HOWFAR_APPLICAT
"T>*************************************
"T>

INTEGER
   I,II,            "T>loop variable
   IRL,             "T>local region number (absolute), required by HOWNEAR macro
   IRNEW_APPLICAT, "T>tentative new region number within CM (absolute)
   IB_APPLICAT,    "T>index to deal with round off errors
   IHIT;            "T>Index for hit(=1) or not (=0)

$REAL
   DIST,            "T>distance to region boundary along current particle
"                      trajectory
   DFR,             "T>distance to front scraper plane on particle trajectory
   XFR,             "T>X at scraper front surface along particle trajectory
   YFR,             "T>Y at scraper front surface along particle trajectory
   DBA,             "T>distance to back scraper plane on particle trajectory
   XBA,             "T>X at scraper back surface along particle trajectory
   YBA,             "T>Y at scraper back surface along particle trajectory
   DTEM,            "T>temperary dist;
   ZFRBA,           "T>front or back of a scraper plane z coordinate
   TVAR;            "T>temperary variable to reduce repeated calculation

IRL = IR(NP); "local region number (absolute)

" Set DNEAR
" *********
" This replacement macros sets DNEAR and defines IR_APPLICAT

;APPLICAT_CM_HOWNEAR(DNEAR(NP));

" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module APPLICAT, and if
" so evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
IF (IR_APPLICAT>0 & IR_APPLICAT<N_APPLICAT+1) [
   "particle in a scraper, all treated the same"
   "establish nearest boundary in Z-direction"
   IB_APPLICAT=1; "inside srapers is 1"
   IF (W(NP)~=0.0) [
      ZFRBA=ZMAXT_APPLICAT(IR_APPLICAT,IB_APPLICAT);
      IF(W(NP)<0.0)[ZFRBA=ZMINT_APPLICAT(IR_APPLICAT,IB_APPLICAT);]
      DBA = (ZFRBA-Z(NP))/W(NP);
      XBA = ABS(X(NP)+U(NP)*DBA); "X at Back
      YBA = ABS(Y(NP)+V(NP)*DBA); "Y at Back
      APPLICAT_MAY_HIT_INSIDE(IHIT,DTEM,
      XMINT_APPLICAT(IR_APPLICAT,IB_APPLICAT),
      YMINT_APPLICAT(IR_APPLICAT,IB_APPLICAT),X(NP),Y(NP),DBA);
      IF(IHIT=1)[ DIST=DTEM;]
      ELSEIF((
            XBA>XMINT_APPLICAT(IR_APPLICAT,IB_APPLICAT)|
            YBA>YMINT_APPLICAT(IR_APPLICAT,IB_APPLICAT))&
            XBA<XMAXT_APPLICAT(IR_APPLICAT,IB_APPLICAT) &
            YBA<YMAXT_APPLICAT(IR_APPLICAT,IB_APPLICAT))[
            DIST=DBA;
      ]
      ELSE[
            APPLICAT_HIT_OUTSIDE(DTEM,
            XMAXT_APPLICAT(IR_APPLICAT,IB_APPLICAT),
            YMAXT_APPLICAT(IR_APPLICAT,IB_APPLICAT),X(NP),Y(NP));
            DIST=DTEM;
      ]
      DIST=MIN(DIST,DBA);
   ]
   ELSE[                        " (W(NP)=0.0"
      APPLICAT_MAY_HIT_INSIDE(IHIT,DTEM,
      XMINT_APPLICAT(IR_APPLICAT,IB_APPLICAT),
      YMINT_APPLICAT(IR_APPLICAT,IB_APPLICAT),X(NP),Y(NP),1E10);
      IF(IHIT=1)[
         DIST=DTEM;
      ]
      ELSE[
         APPLICAT_HIT_OUTSIDE(DTEM,
         XMAXT_APPLICAT(IR_APPLICAT,IB_APPLICAT),
         YMAXT_APPLICAT(IR_APPLICAT,IB_APPLICAT),X(NP),Y(NP));
         DIST=DTEM;
      ]
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary, still in CM
      USTEP = DIST;
      IRNEW = IRSTART_APPLICAT+N_APPLICAT; "new region number
   ]
]" end of scraper block"
ELSEIF (IR_APPLICAT=N_APPLICAT+1) [ "particle in air region "
   IB_APPLICAT=2;    "in air the index is 2"
   IF (W(NP)>0.0)[   "particle moving forward"
      "check scrapers for possible intersection with particle trajectory
      DIST = (ZBACK_APPLICAT-Z(NP))/W(NP); "distance to back of CM
      IF(DIST<=0)[DIST=1.E-16;]
      IRNEW_APPLICAT = 1; "new region number for large USTEP
      DO I=1,N_APPLICAT ["loop through scrapers
         IF(Z(NP)>ZMINT_APPLICAT(I,IB_APPLICAT)&
            Z(NP)<ZMAXT_APPLICAT(I,IB_APPLICAT))["check Z between wall first "
            DBA=(ZMAXT_APPLICAT(I,IB_APPLICAT)-Z(NP))/W(NP);
            XBA=X(NP)+DBA*U(NP);
            YBA=Y(NP)+DBA*V(NP);
            IF(ABS(X(NP)) < XMINT_APPLICAT(I,IB_APPLICAT)&
               ABS(Y(NP)) < YMINT_APPLICAT(I,IB_APPLICAT))[ "inside Amin
               IF(ABS(XBA)>XMINT_APPLICAT(I,IB_APPLICAT)|
                  ABS(YBA)>YMINT_APPLICAT(I,IB_APPLICAT))[ "hit wall
                  APPLICAT_HIT_OUTSIDE(DTEM,
                  XMINT_APPLICAT(I,IB_APPLICAT),
                  YMINT_APPLICAT(I,IB_APPLICAT),X(NP),Y(NP));
                  DIST=DTEM;IRNEW_APPLICAT = IRSTART_APPLICAT+I-1;
                  EXIT;
               ]
               ELSEIF(I < N_APPLICAT)[
                  DO II=I+1,N_APPLICAT[ " continue down the way check"
                     DFR=(ZMINT_APPLICAT(II,IB_APPLICAT)-Z(NP))/W(NP);
                     XFR = X(NP)+U(NP)*DFR;   "X at front
                     YFR = Y(NP)+V(NP)*DFR;   "X at front
                     IF(
                       (ABS(XFR)>=XMINT_APPLICAT(II,IB_APPLICAT) |
                        ABS(YFR)>=YMINT_APPLICAT(II,IB_APPLICAT))&
                        ABS(XFR)<=XMAXT_APPLICAT(II,IB_APPLICAT) &
                        ABS(YFR)<=YMAXT_APPLICAT(II,IB_APPLICAT))[
                        DIST=DFR;
                        "I=N_APPLICAT;"
                        IRNEW_APPLICAT = IRSTART_APPLICAT+II-1;
                        GOTO :OUTLOOP1:;
                     ]
                     ELSEIF(ABS(XFR) < XMINT_APPLICAT(II,IB_APPLICAT)&
                        ABS(YFR) < YMINT_APPLICAT(II,IB_APPLICAT))[
                        DBA=(ZMAXT_APPLICAT(II,IB_APPLICAT)-Z(NP))/W(NP);
                        XBA = X(NP)+U(NP)*DBA; "X at Back
                        YBA = Y(NP)+V(NP)*DBA; "X at Back
                        IF(ABS(XBA)>XMINT_APPLICAT(II,IB_APPLICAT)|
                           ABS(YBA)>YMINT_APPLICAT(II,IB_APPLICAT))[
                           APPLICAT_HIT_OUTSIDE(DTEM,
                           XMINT_APPLICAT(II,IB_APPLICAT),
                           YMINT_APPLICAT(II,IB_APPLICAT),XFR,YFR);
                           DIST=DTEM+DFR;
                           IRNEW_APPLICAT = IRSTART_APPLICAT+II-1;
                           GOTO :OUTLOOP1:;
                        ]
                     ]
                  ]
               ]
            ]"end inside
            ELSEIF(ABS(X(NP)) > XMAXT_APPLICAT(I,IB_APPLICAT)|
               ABS(Y(NP)) > YMAXT_APPLICAT(I,IB_APPLICAT))[  "outside Amax
               APPLICAT_MAY_HIT_INSIDE(IHIT,DTEM,
                  XMAXT_APPLICAT(I,IB_APPLICAT),
                  YMAXT_APPLICAT(I,IB_APPLICAT),X(NP),Y(NP),DBA);
               IF(IHIT =1)[
                  DIST=DTEM;
                  IRNEW_APPLICAT = IRSTART_APPLICAT+I-1;
                  EXIT;
               ]
               ELSEIF(I < N_APPLICAT)[
                  DO II=I+1,N_APPLICAT[ " continue down the way check"
                     DFR=(ZMINT_APPLICAT(II,IB_APPLICAT)-Z(NP))/W(NP);
                     XFR = X(NP)+U(NP)*DFR;   "X at front
                     YFR = Y(NP)+V(NP)*DFR;   "X at front
                     IF((
                        ABS(XFR)>=XMINT_APPLICAT(II,IB_APPLICAT)|
                        ABS(YFR)>=YMINT_APPLICAT(II,IB_APPLICAT))&
                        ABS(XFR)<=XMAXT_APPLICAT(II,IB_APPLICAT) &
                        ABS(YFR)<=YMAXT_APPLICAT(II,IB_APPLICAT))[
                        DIST=DFR;
                        "I=N_APPLICAT;"
                        IRNEW_APPLICAT = IRSTART_APPLICAT+II-1;
                        GOTO :OUTLOOP1:;
                     ]
                     ELSEIF(ABS(XFR)<XMINT_APPLICAT(II,IB_APPLICAT)&
                        ABS(YFR)<YMINT_APPLICAT(II,IB_APPLICAT))[
                        DBA=(ZMAXT_APPLICAT(II,IB_APPLICAT)-Z(NP))/W(NP);
                        XBA = X(NP)+U(NP)*DBA; "X at Back
                        YBA = Y(NP)+V(NP)*DBA; "X at Back
                        IF(ABS(XBA)>XMINT_APPLICAT(II,IB_APPLICAT)|
                           ABS(YBA)>YMINT_APPLICAT(II,IB_APPLICAT))[
                           APPLICAT_HIT_OUTSIDE(DTEM,
                           XMINT_APPLICAT(II,IB_APPLICAT),
                           YMINT_APPLICAT(II,IB_APPLICAT),XFR,YFR);
                           DIST = DTEM+DFR;
                           IRNEW_APPLICAT = IRSTART_APPLICAT+II-1;
                           GOTO :OUTLOOP1:;
                        ]
                     ]
                     ELSEIF(
                        ABS(XFR) > XMAXT_APPLICAT(II,IB_APPLICAT)|
                        ABS(YFR) > YMAXT_APPLICAT(II,IB_APPLICAT))[
                        DBA=(ZMAXT_APPLICAT(II,IB_APPLICAT)-Z(NP))/W(NP);
                        XBA = X(NP)+U(NP)*DBA; "X at Back
                        YBA = Y(NP)+V(NP)*DBA; "X at Back
                        APPLICAT_MAY_HIT_INSIDE(IHIT,DTEM,
                           XMAXT_APPLICAT(II,IB_APPLICAT),
                           YMAXT_APPLICAT(II,IB_APPLICAT),XFR,YFR,DBA-DFR);
                        IF(IHIT =1)[
                           DIST = DTEM+DFR;
                           IRNEW_APPLICAT = IRSTART_APPLICAT+II-1;
                           GOTO :OUTLOOP1:;
                        ]
                     ]
                  ] " end of down the way check"
               ]
            ]"end outside Amax
         ]
         ELSEIF(Z(NP)<ZMINT_APPLICAT(I,IB_APPLICAT))[
            "check Z not between scrapers,"
            DFR=(ZMINT_APPLICAT(I,IB_APPLICAT)-Z(NP))/W(NP);
            XFR = X(NP)+U(NP)*DFR;   "X at front
            YFR = Y(NP)+V(NP)*DFR;   "X at front
            IF((
               ABS(XFR) >= XMINT_APPLICAT(I,IB_APPLICAT)|
               ABS(YFR) >= YMINT_APPLICAT(I,IB_APPLICAT))&
               ABS(XFR) <= XMAXT_APPLICAT(I,IB_APPLICAT) &
               ABS(YFR) <= YMAXT_APPLICAT(I,IB_APPLICAT))[
               DIST = DFR;
               IRNEW_APPLICAT = IRSTART_APPLICAT+I-1;
               EXIT;
            ]
            ELSEIF(
               ABS(XFR)<XMINT_APPLICAT(I,IB_APPLICAT)&
               ABS(YFR)<YMINT_APPLICAT(I,IB_APPLICAT))[
               DBA=(ZMAXT_APPLICAT(I,IB_APPLICAT)-Z(NP))/W(NP);
               XBA = X(NP)+U(NP)*DBA; "X at Back
               YBA = Y(NP)+V(NP)*DBA; "X at Back
               IF(ABS(XBA)>XMINT_APPLICAT(I,IB_APPLICAT)|
                  ABS(YBA)>YMINT_APPLICAT(I,IB_APPLICAT))[
                  APPLICAT_HIT_OUTSIDE(DTEM,
                  XMINT_APPLICAT(I,IB_APPLICAT),
                  YMINT_APPLICAT(I,IB_APPLICAT),XFR,YFR);
                  DIST = DTEM+DFR;
                  IRNEW_APPLICAT = IRSTART_APPLICAT+I-1;
                  EXIT;
               ]
            ]
         ]
      ]
      :OUTLOOP1:;
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         IF (IRNEW_APPLICAT=1) ["leaving CM through back"
            CALL WHERE_AM_I(ICM_APPLICAT,1);
         ]
         ELSE ["still in CM, entering scraper"
            IRNEW = IRNEW_APPLICAT; "new region number"
         ]
      ]
   ]

   ELSEIF (W(NP)<0.0) [" particle move backward"
      DIST = (ZFRONT_APPLICAT-Z(NP))/W(NP); "distance to front of CM
      IF(DIST<=0)[DIST=1.E-16;]
      IRNEW_APPLICAT = 1; "new region number for large USTEP
      DO I=N_APPLICAT,1,-1 ["loop through scrapers
         IF(Z(NP) > ZMINT_APPLICAT(I,IB_APPLICAT)&
            Z(NP) < ZMAXT_APPLICAT(I,IB_APPLICAT))[
            "check Z between a scraper first"
            IF(ABS(X(NP)) < XMINT_APPLICAT(I,IB_APPLICAT) &
               ABS(Y(NP)) < YMINT_APPLICAT(I,IB_APPLICAT))[  "inside Amin
               DFR = (ZMINT_APPLICAT(I,IB_APPLICAT)-Z(NP))/W(NP);
               XFR = X(NP)+DFR*U(NP);
               YFR = Y(NP)+DFR*V(NP);
               IF(ABS(XFR) > XMINT_APPLICAT(I,IB_APPLICAT) |
                  ABS(YFR) > YMINT_APPLICAT(I,IB_APPLICAT))[
                  APPLICAT_HIT_OUTSIDE(DTEM,
                  XMINT_APPLICAT(I,IB_APPLICAT),
                  YMINT_APPLICAT(I,IB_APPLICAT),X(NP),Y(NP));
                  DIST=DTEM;
                  IRNEW_APPLICAT = IRSTART_APPLICAT+I-1;
                  EXIT;
               ]
               ELSEIF(I > 1)[
                  DO II=I-1,1,-1[ " continue down the way check"
                     DBA = (ZMAXT_APPLICAT(II,IB_APPLICAT)-Z(NP))/W(NP);
                     XBA = X(NP)+U(NP)*DBA;   "X at back
                     YBA = Y(NP)+V(NP)*DBA;   "X at back
                     IF((
                        ABS(XBA) >= XMINT_APPLICAT(II,IB_APPLICAT)|
                        ABS(YBA) >= YMINT_APPLICAT(II,IB_APPLICAT))&
                        ABS(XBA) <= XMAXT_APPLICAT(II,IB_APPLICAT) &
                        ABS(YBA) <= YMAXT_APPLICAT(II,IB_APPLICAT))[
                        DIST = DBA;
                        IRNEW_APPLICAT = IRSTART_APPLICAT+II-1;
                        GOTO :OUTLOOP2:;
                     ]
                     ELSEIF(
                        ABS(XBA) < XMINT_APPLICAT(II,IB_APPLICAT)&
                        ABS(YBA) < YMINT_APPLICAT(II,IB_APPLICAT))[
                        DFR = (ZMINT_APPLICAT(II,IB_APPLICAT)-Z(NP))/W(NP);
                        XFR = X(NP)+U(NP)*DFR; "X at front
                        YFR = Y(NP)+V(NP)*DFR; "X at front
                        IF(ABS(XFR) > XMINT_APPLICAT(II,IB_APPLICAT)|
                           ABS(YFR) > YMINT_APPLICAT(II,IB_APPLICAT))[
                           APPLICAT_HIT_OUTSIDE(DTEM,
                           XMINT_APPLICAT(II,IB_APPLICAT),
                           YMINT_APPLICAT(II,IB_APPLICAT),XBA,YBA);
                           DIST = DTEM+DBA;
                           IRNEW_APPLICAT = IRSTART_APPLICAT+II-1;
                           GOTO :OUTLOOP2:;
                        ]
                     ]
                  ] " end of continue down the way check"
               ]
            ] "end of Z between scraper and inside Amin

            ELSEIF(
               ABS(X(NP)) > XMAXT_APPLICAT(I,IB_APPLICAT)|
               ABS(Y(NP)) > YMAXT_APPLICAT(I,IB_APPLICAT))
               [" Z between a scraper but out side Amax
               DFR = (ZMINT_APPLICAT(I,IB_APPLICAT)-Z(NP))/W(NP);
               XFR = X(NP)+DFR*U(NP);
               YFR = Y(NP)+DFR*V(NP);
               APPLICAT_MAY_HIT_INSIDE(IHIT,DTEM,
                  XMAXT_APPLICAT(I,IB_APPLICAT),
                  YMAXT_APPLICAT(I,IB_APPLICAT),X(NP),Y(NP),DFR);
               IF(IHIT = 1)[
                  DIST=DTEM;
                  IRNEW_APPLICAT = IRSTART_APPLICAT+I-1;
                  EXIT;
               ]
               ELSEIF(I > 1)[
                  DO II=I-1,1,-1[ " continue down the way check"
                     DBA = (ZMAXT_APPLICAT(II,IB_APPLICAT)-Z(NP))/W(NP);
                     XBA = X(NP)+U(NP)*DBA;   "X at back
                     YBA = Y(NP)+V(NP)*DBA;   "X at back
                     IF((
                        ABS(XBA) >= XMINT_APPLICAT(II,IB_APPLICAT)|
                        ABS(YBA) >= YMINT_APPLICAT(II,IB_APPLICAT))&
                        ABS(XBA) <= XMAXT_APPLICAT(II,IB_APPLICAT) &
                        ABS(YBA) <= YMAXT_APPLICAT(II,IB_APPLICAT))[
                        DIST = DBA;
                        IRNEW_APPLICAT = IRSTART_APPLICAT+II-1;
                        GOTO :OUTLOOP2:;
                     ]
                     ELSEIF(
                        ABS(XBA) < XMINT_APPLICAT(II,IB_APPLICAT)&
                        ABS(YBA) < YMINT_APPLICAT(II,IB_APPLICAT))[
                        DFR=(ZMINT_APPLICAT(II,IB_APPLICAT)-Z(NP))/W(NP);
                        XFR = X(NP)+U(NP)*DFR; "X at front
                        YFR = Y(NP)+V(NP)*DFR; "X at front
                        IF(ABS(XFR) > XMINT_APPLICAT(II,IB_APPLICAT)|
                           ABS(YFR) > YMINT_APPLICAT(II,IB_APPLICAT))[
                           APPLICAT_HIT_OUTSIDE(DTEM,
                           XMINT_APPLICAT(II,IB_APPLICAT),
                           YMINT_APPLICAT(II,IB_APPLICAT),XBA,YBA);
                           DIST = DTEM+DBA;
                           IRNEW_APPLICAT = IRSTART_APPLICAT+II-1;
                           GOTO :OUTLOOP2:;
                        ]
                     ]
                     ELSEIF(
                        ABS(XBA) > XMAXT_APPLICAT(II,IB_APPLICAT)|
                        ABS(YBA) > YMAXT_APPLICAT(II,IB_APPLICAT))[
                        DFR=(ZMINT_APPLICAT(II,IB_APPLICAT)-Z(NP))/W(NP);
                        XFR = X(NP) + U(NP)*DFR; "X at front
                        YFR = Y(NP) + V(NP)*DFR; "X at front
                        APPLICAT_MAY_HIT_INSIDE(IHIT,DTEM,
                           XMAXT_APPLICAT(II,IB_APPLICAT),
                           YMAXT_APPLICAT(II,IB_APPLICAT),XBA,YBA,DFR-DBA);
                        IF(IHIT =1)[
                           DIST = DTEM+DBA;
                           IRNEW_APPLICAT = IRSTART_APPLICAT+II-1;
                           GOTO :OUTLOOP2:;
                        ]
                     ]
                  ] " end of continue down the way check"
               ]
            ]  "end of Z between scraper end of out side Amax"
         ] "end of Z between a scraper"
         ELSEIF(Z(NP) > ZMAXT_APPLICAT(I,IB_APPLICAT))[
            " Z not between a scraper"
            DBA = (ZMAXT_APPLICAT(I,IB_APPLICAT)-Z(NP))/W(NP);
            XBA = X(NP)+U(NP)*DBA;   "X at front
            YBA = Y(NP)+V(NP)*DBA;   "X at front
            IF((
               ABS(XBA) >= XMINT_APPLICAT(I,IB_APPLICAT)|
               ABS(YBA) >= YMINT_APPLICAT(I,IB_APPLICAT))&
               ABS(XBA) <= XMAXT_APPLICAT(I,IB_APPLICAT) &
               ABS(YBA) <= YMAXT_APPLICAT(I,IB_APPLICAT))[
               DIST=DBA;
               IRNEW_APPLICAT = IRSTART_APPLICAT+I-1;
               EXIT;
            ]
            ELSEIF(
               ABS(XBA) < XMINT_APPLICAT(I,IB_APPLICAT) &
               ABS(YBA) < YMINT_APPLICAT(I,IB_APPLICAT))[
               DFR=(ZMINT_APPLICAT(I,IB_APPLICAT)-Z(NP))/W(NP);
               XFR = X(NP)+U(NP)*DFR; "X at Back
               YFR = Y(NP)+V(NP)*DFR; "X at Back
               IF(ABS(XFR) > XMINT_APPLICAT(I,IB_APPLICAT)|
                  ABS(YFR) > YMINT_APPLICAT(I,IB_APPLICAT))[
                  APPLICAT_HIT_OUTSIDE(DTEM,
                  XMINT_APPLICAT(I,IB_APPLICAT),
                  YMINT_APPLICAT(I,IB_APPLICAT),XBA,YBA);
                  DIST = DTEM + DBA;
                  IRNEW_APPLICAT = IRSTART_APPLICAT+I-1;
                  EXIT;
               ]
            ]
            ELSEIF(
               ABS(XBA) > XMAXT_APPLICAT(I,IB_APPLICAT)|
               ABS(YBA) > YMAXT_APPLICAT(I,IB_APPLICAT))[
               DFR = (ZMINT_APPLICAT(I,IB_APPLICAT)-Z(NP))/W(NP);
               XFR = X(NP)+U(NP)*DFR; "X at Back
               YFR = Y(NP)+V(NP)*DFR; "X at Back
               APPLICAT_MAY_HIT_INSIDE(IHIT,DTEM,
                  XMAXT_APPLICAT(I,IB_APPLICAT),
                  YMAXT_APPLICAT(I,IB_APPLICAT),XBA,YBA,DFR-DBA);
               IF(IHIT =1)[
                  DIST = DTEM+DBA;
                  IRNEW_APPLICAT = IRSTART_APPLICAT+I-1;
                  EXIT;
               ]
            ]
         ]
      ]" end of not between a scraper"
:OUTLOOP2:
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         IF(IRNEW_APPLICAT=1) ["leaving CM through front"
            CALL WHERE_AM_I(ICM_APPLICAT,-1);
         ]
         ELSE ["still in CM, entering scraper"
            IRNEW = IRNEW_APPLICAT; "new region number"
         ]
      ]
   ] " end of move backward"
   ELSEIF (W(NP)=0.0) [ " w=0"
      DIST = 1.E30; "set large distance in case of particle missing scrapers
      DO I=1,N_APPLICAT ["loop through scrapers
         IF(Z(NP) >= ZMINT_APPLICAT(I,IB_APPLICAT)&
            Z(NP) <= ZMAXT_APPLICAT(I,IB_APPLICAT)) ["if between a scraper
            APPLICAT_HIT_OUTSIDE(DTEM,
            XMINT_APPLICAT(I,IB_APPLICAT),
            YMINT_APPLICAT(I,IB_APPLICAT),X(NP),Y(NP));
            DIST = DTEM;
            IRNEW_APPLICAT = IRSTART_APPLICAT+I-1;
            IF(DIST <= USTEP ) ["particle to be moved to region boundary
               USTEP = DIST;
               IRNEW = IRNEW_APPLICAT; "new region number"
            ]
            EXIT;
         ]
      ]

   ] "end of w=0"

] "end of air region
"end of CM regions"

"   outside of CM, something is wrong
"   =================================
"
ELSE ["something is wrong"
   OUTPUT IR(NP)-IRSTART_APPLICAT+1,IR(NP),ICM_APPLICAT,
      IR_start_CM(ICM_APPLICAT);
      (//' ************'//' HOWFAR_APPLICAT error'/
         '    Region, local, absolute =',2I5/
         '    CM number=',I5,' start region =',I5/
         ' *********'//);
   STOP;
] "end of IF statement"

"   end of HOWFAR_APPLICAT
"   ======================
"
RETURN;
END; "End of subroutine HOWFAR_APPLICAT"
%E "start of subroutine WHERE_AM_I_APPLICAT"
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_APPLICAT
"                          ******************************
"
" WHERE_AM_I routine for set of scrapers.
"
" WHERE_AM_I_APPLICAT determines the new region number when a particle crosses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_APPLICAT subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_APPLICAT from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************

;SUBROUTINE WHERE_AM_I_APPLICAT(IDIR);


;IMPLICIT NONE;
;COMIN/CM_APPLICAT,EPCONT/; "/STACK/would be needed for more complicated"
                        "geometries."
"T>
"T>*****************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_APPLICAT
"T>*****************************************
"T>
;
INTEGER IDIR;       "T>direction of particle, +1=forward, -1=backward
IRNEW = IREND_APPLICAT; "particle always enters air region around scrapers"
RETURN;
END; "End of subroutine WHERE_AM_I_APPLICAT"
%E  "start of subroutine INPUT_APPLICAT"
"*******************************************************************************
"
"                           Subroutine INPUT_APPLICAT
"                           *************************
"
"  A CM input subroutine for a series of 1 or more scrapers.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_APPLICAT;


;IMPLICIT NONE;
;COMIN/BOUNDS,CMs,CM_APPLICAT,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;
"T>
"T>************************************
"T>TYPE DECLARATIONS FOR INPUT_APPLICAT
"T>************************************
"T>
INTEGER
        DOSE_ZONE_AIR, "T>dose scoring zone of air region surrounding scrapers
        I,J,K,         "T>DO loop indeces
        IRA,           "T>Absolute region number
        IR_TO_BIT_AIR, "T>Bit setting number for air region
        MED_FLAG,      "T>flag used by media-sort macro $MED_INPUT
        MED_INDEX,     "T>medium index, set after medium sort by $MED_INPUT
        ISHAPE;        "T>shape index, square (default) or rectangular (1)
$REAL ZTHICK_APPLICAT($MAX_N_APPLICAT), "T>thickness of each scraper in CM
      WIDTHX_APPLICAT($MAX_N_APPLICAT), "T>x width of each scraper in this CM
      WIDTHY_APPLICAT($MAX_N_APPLICAT); "T>y width of each scraper in this CM
"
"  initialize parameters
"  =====================
"
ICM_APPLICAT = ICM;      "CM index for this component module
IRSTART_APPLICAT = IR_start_CM(ICM_APPLICAT);"Index of first region in CM,
                                      "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_APPLICAT) = 0; "Geometry-checking flag, 0 if no error detected
AIRGAPMIN_APPLICAT = $GAP_F_B_AIR_MIN; "Minimum air gap at front and back of CM

"
"  get the title line
"  ==================
"
OUTPUT;(/' Next component is a set of square or rectangular scrapers '//
       'APPLICAT   (APPLICAT:'//' TITLE: ',$);
;MINPUT (APPLICAT) TITLE_APPLICAT;(60A1);
                  ";MINPUT is a replacement macro with EOF and
                                "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_APPLICAT;(' ',60A1);

"  get the Z coordinate of CM starting and ending if default is not used
"  ==================================================================
OUTPUT AIRGAPMIN_APPLICAT;
   (/' Input ZBACK_APPLICAT, the Z coordinate of the back face of this CM',
    /' [Note: Leave at least min. airgap (=',F8.5,' cm) between'/
     ' the back of the last scraper and ZBACK]:',$);

;MINPUT (APPLICAT) ZBACK_APPLICAT;(F15.0);
OUTPUT ZBACK_APPLICAT; (F15.5);

"
"   get information for each layer of applicator
"   ============================================
"
"get number of slabs"
"
N_APPLICAT = $MAX_N_APPLICAT; "Maximum number of applicators permitted"
OUTPUT N_APPLICAT;
   (/' Number of scrapers in the CM (minimum 1, maximum',I2,'): '
    /' and the index for scrapers shape: 0 (default) for square, '
    /'                                    1 for rectangualr ',$);
;MINPUT (APPLICAT) N_APPLICAT,ISHAPE; (2I5);
OUTPUT N_APPLICAT,ISHAPE; (2I5);
IF(N_APPLICAT > $MAX_N_APPLICAT)[
   N_APPLICAT=$MAX_N_APPLICAT;
   OUTPUT ICM_APPLICAT, N_APPLICAT;
     (//' ***ERROR IN CM ',I4,' (APPLICAT):'/
        '# of scrapers > max. allowed'/
        '# of scrapers reduced to ',I4,' for now'//);
   IERR_GEOM(ICM_APPLICAT)=IERR_GEOM(ICM_APPLICAT)+1;
]
ELSEIF(N_APPLICAT<1)[
   N_APPLICAT=1;
   OUTPUT ICM_APPLICAT;
     (//' ***ERROR IN CM ',I4,' (APPLICAT):'/
        '# of scrapers < 1'/
        '# of scrapers reset to 1 for now'//);
   IERR_GEOM(ICM_APPLICAT)=IERR_GEOM(ICM_APPLICAT)+1;
]
IF(ISHAPE<=0)[
   ISHAPE=0;
   OUTPUT; (/' scrapers to be square, use square scraper input format.',$);
]
ELSEIF(ISHAPE>1)[
   ISHAPE=1;
   OUTPUT; (/' ***WARNING: scrapers set to be rectangular***'/
              ' use rectangualr scraper input format.',$);
]
ELSE [      "rectangular scrapers"
   OUTPUT; (/' rectangular scraper. Use rectangular scraper input format.'
            ,$);
]

"loop over scrapers
"
IRA = IRSTART_APPLICAT - 1; "absolute region number
DO IR_APPLICAT=1,N_APPLICAT [
   "loop through local region number to get slab information"
   IRA = IRA+1;
   "get Z of front face, thickness, and width of scraper IR_APPLICAT
   "
   IF(ISHAPE=0)[   "square scraper input"
      OUTPUT IR_APPLICAT, AIRGAPMIN_APPLICAT;
         (/' Scraper',I3,':'/
' Z OF FRONT FACE, THICKNESS (in Z), HALF-WIDTH OF OPENING,'/
' BAR WIDTH(cm), DOSE ZONE, IREGION_TO_BIT (all on one line)'/
' [Leave at least the min. airgap (= ',F8.5,' cm) between scrapers]',/
          ' : ',$);
      ;MINPUT (APPLICAT)
         ZMIN_APPLICAT(IR_APPLICAT),ZTHICK_APPLICAT(IR_APPLICAT),
         XMIN_APPLICAT(IR_APPLICAT),
         WIDTHX_APPLICAT(IR_APPLICAT),
         DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
         (4F15.0,2I4);
      ;OUTPUT
         ZMIN_APPLICAT(IR_APPLICAT),ZTHICK_APPLICAT(IR_APPLICAT),
         XMIN_APPLICAT(IR_APPLICAT),
         WIDTHX_APPLICAT(IR_APPLICAT),
         DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
         (4F8.2,2I12);
      YMIN_APPLICAT(IR_APPLICAT)=XMIN_APPLICAT(IR_APPLICAT);
      WIDTHY_APPLICAT(IR_APPLICAT)=WIDTHX_APPLICAT(IR_APPLICAT);
   ]
   ELSE[   "rectangular scraper input"
      OUTPUT IR_APPLICAT, AIRGAPMIN_APPLICAT;
         (/' Scraper',I3,':'/
      ' Z OF FRONT FACE, THICKNESS (in Z), HALF-WIDTH OF OPENING in X,'/
      ' HALF-WIDTH OF OPENING in Y, BAR WIDTH(cm) in X, BAR WIDTH(cm) in Y,'/
      ' DOSE ZONE, IREGION_TO_BIT (all on one line)'/
      ' [Leave at least the min. airgap (= ',F8.5,' cm) between scrapers]',/
          ' : ',$);
      ;MINPUT (APPLICAT)
         ZMIN_APPLICAT(IR_APPLICAT),ZTHICK_APPLICAT(IR_APPLICAT),
         XMIN_APPLICAT(IR_APPLICAT),YMIN_APPLICAT(IR_APPLICAT),
         WIDTHX_APPLICAT(IR_APPLICAT),WIDTHY_APPLICAT(IR_APPLICAT),
         DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
         (6F15.0,2I4);
      ;OUTPUT
         ZMIN_APPLICAT(IR_APPLICAT),ZTHICK_APPLICAT(IR_APPLICAT),
         XMIN_APPLICAT(IR_APPLICAT),YMIN_APPLICAT(IR_APPLICAT),
         WIDTHX_APPLICAT(IR_APPLICAT),WIDTHY_APPLICAT(IR_APPLICAT),
         DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
         (6F8.2,2I12);
   ]
   IF(IR_APPLICAT=1)[
     IF(ICM_APPLICAT=1 & Z_min_CM(ICM_APPLICAT) > ZMIN_APPLICAT(1)-
         AIRGAPMIN_APPLICAT)[
        OUTPUT ICM_APPLICAT, AIRGAPMIN_APPLICAT,
        ZMIN_APPLICAT(1)-AIRGAPMIN_APPLICAT,Z_min_CM(1);
         (//' ***WARNING IN CM ',I4,' (APPLICAT):'/
            ' Less than min. airgap (',F8.5,' cm) between top',
            ' of CM and 1st scraper.'/
            ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
        WRITE(IOUTLIST,100)ICM_APPLICAT, AIRGAPMIN_APPLICAT,
             ZMIN_APPLICAT(1)-AIRGAPMIN_APPLICAT,Z_min_CM(1);
       100 FORMAT(//' ***WARNING IN CM ',I4,' (APPLICAT):'/
            ' Less than min. airgap (',F8.5,' cm) between top',
            ' of CM and 1st scraper.'/
            ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
        Z_min_CM(1)= ZMIN_APPLICAT(1)-AIRGAPMIN_APPLICAT;
     ]
     ELSEIF(Z_min_CM(ICM_APPLICAT) > ZMIN_APPLICAT(1))[
         OUTPUT ICM_APPLICAT;
           (//' ***ERROR IN CM ',I4,' (APPLICAT):'/
              ' Overlaps with previous CM.'//);
         IERR_GEOM(ICM_APPLICAT)=IERR_GEOM(ICM_APPLICAT)+1;
     ]
     ELSEIF(Z_min_CM(ICM_APPLICAT) > ZMIN_APPLICAT(1) - AIRGAPMIN_APPLICAT)[
         OUTPUT ICM_APPLICAT, AIRGAPMIN_APPLICAT,
         Z_min_CM(ICM_APPLICAT)+AIRGAPMIN_APPLICAT,ZMIN_APPLICAT(1);
          (//' ***WARNING IN CM ',I4,' (APPLICAT):'/
             ' Less than min. airgap (',F8.5,' cm) between top',
             ' of CM and 1st scraper.'/
             ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         WRITE(IOUTLIST,101)ICM_APPLICAT, AIRGAPMIN_APPLICAT,
              Z_min_CM(ICM_APPLICAT)+AIRGAPMIN_APPLICAT,ZMIN_APPLICAT(1);
         101 FORMAT(//' ***WARNING IN CM ',I4,' (APPLICAT):'/
             ' Less than min. airgap (',F8.5,' cm) between top',
             ' of CM and 1st scraper.'/
             ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         ZMIN_APPLICAT(1)=Z_min_CM(ICM_APPLICAT)+AIRGAPMIN_APPLICAT;
     ]
   ]
   ELSE[
     IF(ZMIN_APPLICAT(IR_APPLICAT-1)+ZTHICK_APPLICAT(IR_APPLICAT-1) >
        ZMIN_APPLICAT(IR_APPLICAT))[
         OUTPUT ICM_APPLICAT, IR_APPLICAT-1, IR_APPLICAT;
           (//' ***ERROR IN CM ',I4,' (APPLICAT):'/
              ' Scraper ',I4,' overlaps with scraper ',I4//);
         IERR_GEOM(ICM_APPLICAT)=IERR_GEOM(ICM_APPLICAT)+1;
     ]
     ELSEIF (ZMIN_APPLICAT(IR_APPLICAT-1)+ZTHICK_APPLICAT(IR_APPLICAT-1)>
        ZMIN_APPLICAT(IR_APPLICAT)-AIRGAPMIN_APPLICAT)[
          OUTPUT ICM_APPLICAT, AIRGAPMIN_APPLICAT, IR_APPLICAT-1,
          IR_APPLICAT, IR_APPLICAT,
          ZMIN_APPLICAT(IR_APPLICAT-1)+ZTHICK_APPLICAT(IR_APPLICAT-1)+
          AIRGAPMIN_APPLICAT,ZMIN_APPLICAT(IR_APPLICAT);
          (//' ***WARNING IN CM ',I4,' (APPLICAT):'/
              ' Less than min. airgap (',F8.5,' cm) between scraper ',
              I4,' and scraper ',I4/
              ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
          WRITE(IOUTLIST,103)ICM_APPLICAT, AIRGAPMIN_APPLICAT,IR_APPLICAT-1,
       IR_APPLICAT, IR_APPLICAT,ZMIN_APPLICAT(IR_APPLICAT-1)+
       ZTHICK_APPLICAT(IR_APPLICAT-1)+AIRGAPMIN_APPLICAT,
       ZMIN_APPLICAT(IR_APPLICAT);
           103 FORMAT(//' ***WARNING IN CM ',I4,' (APPLICAT):'/
               ' Less than min. airgap (',F8.5,' cm) between scraper ',
               I4,' and scraper ',I4/
               ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
           ZMIN_APPLICAT(IR_APPLICAT)=ZMIN_APPLICAT(IR_APPLICAT-1)+
                       ZTHICK_APPLICAT(IR_APPLICAT-1)+AIRGAPMIN_APPLICAT;
     ]
   ]
   IF(ZTHICK_APPLICAT(IR_APPLICAT)<0.0)[
      OUTPUT ICM_APPLICAT, IR_APPLICAT;
        (//' ***ERROR IN CM ',I4,' (APPLICAT):'/
           ' ZTHICK(',I4,') < 0.0'//);
      IERR_GEOM(ICM_APPLICAT)=IERR_GEOM(ICM_APPLICAT)+1;
   ]
   IF(IR_APPLICAT=N_APPLICAT &
     ZMIN_APPLICAT(IR_APPLICAT)+ZTHICK_APPLICAT(IR_APPLICAT) >
     ZBACK_APPLICAT-AIRGAPMIN_APPLICAT)[
       OUTPUT ICM_APPLICAT, AIRGAPMIN_APPLICAT, ZMIN_APPLICAT(IR_APPLICAT)+
                       ZTHICK_APPLICAT(IR_APPLICAT)+
                       AIRGAPMIN_APPLICAT,ZBACK_APPLICAT;
        (//' ***WARNING IN CM ',I4,' (APPLICAT):'/
           ' Less than min. airgap (',F8.5,' cm) between last'/
           ' scraper and ZBACK'/
           ' ZBACK reset to ',F8.5,' cm from ',F8.5,' cm'//);
       WRITE(IOUTLIST,104)ICM_APPLICAT, AIRGAPMIN_APPLICAT,
         ZMIN_APPLICAT(IR_APPLICAT)+ZTHICK_APPLICAT(IR_APPLICAT)+
         AIRGAPMIN_APPLICAT,ZBACK_APPLICAT;
      104 FORMAT(//' ***WARNING IN CM ',I4,' (APPLICAT):'/
           ' Less than min. airgap (',F8.5,' cm) between last'/
           ' scraper and ZBACK'/
           ' ZBACK reset to ',F8.5,' cm from ',F8.5,' cm'//);
       ZBACK_APPLICAT=ZMIN_APPLICAT(IR_APPLICAT)+
                       ZTHICK_APPLICAT(IR_APPLICAT)+
                       AIRGAPMIN_APPLICAT;
   ]
   IF(XMIN_APPLICAT(IR_APPLICAT)<0.0)[
      OUTPUT ICM_APPLICAT, IR_APPLICAT;
       (//' ***ERROR IN CM ',I4,' (APPLICAT):'/
          ' Half-width of opening in x in scraper ',I4,' < 0.0'//);
      IERR_GEOM(ICM_APPLICAT)=IERR_GEOM(ICM_APPLICAT)+1;
   ]
   IF(YMIN_APPLICAT(IR_APPLICAT)<0.0)[
      OUTPUT ICM_APPLICAT, IR_APPLICAT;
       (//' ***ERROR IN CM ',I4,' (APPLICAT):'/
          ' Half-width of opening in y in scraper ',I4,' < 0.0'//);
      IERR_GEOM(ICM_APPLICAT)=IERR_GEOM(ICM_APPLICAT)+1;
   ]
   ELSEIF(XMIN_APPLICAT(IR_APPLICAT)>RMAX_CM(ICM_APPLICAT))[
        OUTPUT ICM_APPLICAT, IR_APPLICAT;
       (//' ***ERROR IN CM ',I4,' (APPLICAT):'/
          ' Half-width of opening in x inscraper ',I4,' > RMAX_CM'//);
      IERR_GEOM(ICM_APPLICAT)=IERR_GEOM(ICM_APPLICAT)+1;
   ]
   ELSEIF(YMIN_APPLICAT(IR_APPLICAT)>RMAX_CM(ICM_APPLICAT))[
        OUTPUT ICM_APPLICAT, IR_APPLICAT;
       (//' ***ERROR IN CM ',I4,' (APPLICAT):'/
          ' Half-width of opening in y inscraper ',I4,' > RMAX_CM'//);
      IERR_GEOM(ICM_APPLICAT)=IERR_GEOM(ICM_APPLICAT)+1;
   ]
   ELSEIF(WIDTHX_APPLICAT(IR_APPLICAT)>=0.0 &
        XMIN_APPLICAT(IR_APPLICAT)+WIDTHX_APPLICAT(IR_APPLICAT)>
        RMAX_CM(ICM_APPLICAT))[
       OUTPUT ICM_APPLICAT, IR_APPLICAT, IR_APPLICAT,
         RMAX_CM(ICM_APPLICAT)-XMIN_APPLICAT(IR_APPLICAT),
          WIDTHX_APPLICAT(IR_APPLICAT);
        (//' ***WARNING IN CM ',I4,' (APPLICAT):'/
         ' Scraper in x ',I4,' extends beyond RMAX_CM'/
         ' Bar width in x of scraper ',I4,' reduced to ',F8.5,' cm'/
         ' from ',F8.5,' cm'//);
  WRITE(IOUTLIST,105)ICM_APPLICAT, IR_APPLICAT, IR_APPLICAT,
          RMAX_CM(ICM_APPLICAT)-XMIN_APPLICAT(IR_APPLICAT),
          WIDTHX_APPLICAT(IR_APPLICAT);
   105 FORMAT(//' ***WARNING IN CM ',I4,' (APPLICAT):'/
         ' Scraper in x ',I4,' extends beyond RMAX_CM'/
         ' Bar width in x of scraper ',I4,' reduced to ',F8.5,' cm'/
         ' from ',F8.5,' cm'//);
       WIDTHX_APPLICAT(IR_APPLICAT)=RMAX_CM(ICM_APPLICAT)
                               -XMIN_APPLICAT(IR_APPLICAT);
   ]
   ELSEIF(WIDTHY_APPLICAT(IR_APPLICAT)>=0.0 &
        YMIN_APPLICAT(IR_APPLICAT)+WIDTHY_APPLICAT(IR_APPLICAT)>
        RMAX_CM(ICM_APPLICAT))[
       OUTPUT ICM_APPLICAT, IR_APPLICAT, IR_APPLICAT,
         RMAX_CM(ICM_APPLICAT)-YMIN_APPLICAT(IR_APPLICAT),
         WIDTHY_APPLICAT(IR_APPLICAT);
        (//' ***WARNING IN CM ',I4,' (APPLICAT):'/
         ' Scraper in y ',I4,' extends beyond RMAX_CM'/
         ' Bar width in y of scraper ',I4,' reduced to ',F8.5,' cm'/
         ' from ',F8.5,' cm'//);
      WRITE(IOUTLIST,106)ICM_APPLICAT, IR_APPLICAT, IR_APPLICAT,
          RMAX_CM(ICM_APPLICAT)-YMIN_APPLICAT(IR_APPLICAT),
          WIDTHY_APPLICAT(IR_APPLICAT);
    106 FORMAT(//' ***WARNING IN CM ',I4,' (APPLICAT):'/
         ' Scraper in y ',I4,' extends beyond RMAX_CM'/
         ' Bar width in y of scraper ',I4,' reduced to ',F8.5,' cm'/
         ' from ',F8.5,' cm'//);
        WIDTHY_APPLICAT(IR_APPLICAT)=RMAX_CM(ICM_APPLICAT)
                               -YMIN_APPLICAT(IR_APPLICAT);
   ]
   IF(WIDTHX_APPLICAT(IR_APPLICAT)<0.0)[
      OUTPUT ICM_APPLICAT, IR_APPLICAT;
       (//' ***ERROR IN CM ',I4,' (APPLICAT):'/
          ' Bar width in x of scraper ',I4,' < 0.0'//);
   ]
   IF(WIDTHY_APPLICAT(IR_APPLICAT)<0.0)[
      OUTPUT ICM_APPLICAT, IR_APPLICAT;
       (//' ***ERROR IN CM ',I4,' (APPLICAT):'/
          ' Bar width in y of scraper ',I4,' < 0.0'//);
   ]
] "end of loop over IR_APPLICAT"

"set absolute region number to first region in CM for next set of inputs"
"
IRA = IRSTART_APPLICAT;

"get energy cutoffs and dose scoring zones"
"
OUTPUT ; (/' ECUT, PCUT of scrapers & air',/
          ' & DOSE ZONE, IREGION_TO_BIT of air (all in one line): '/,$);
;MINPUT (APPLICAT) ECUT(IRA),PCUT(IRA),
               DOSE_ZONE_AIR,IR_TO_BIT_AIR; (2F15.0,2I5);
OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE_AIR,IR_TO_BIT_AIR;
      (2F15.5,2I5);
IF (ECUT(IRA).LT.ECUTIN) ECUT(IRA)=ECUTIN;
IF (PCUT(IRA).LT.PCUTIN) PCUT(IRA)=PCUTIN;

"get material for scrapers and determine material number for these regions
"
IRA = IRSTART_APPLICAT - 1;
DO K = 1,N_APPLICAT[
   OUTPUT K;(/' SCRAPER ',I4,$);
   IRA = IRA + 1;
   ;$MED_INPUT(APPLICAT); " inputs character array MED_IN from unit 5, loops
   "through array MEDIA(24,I) to check if medium was previously input.
   "If so, sets MED_INDEX to index of previous medium.  If not,
   "increments NMED and sets MED_INDEX to NMED.
   MED(IRA) = MED_INDEX; " medium of each scraper
]
"
"  set up region numbers
"  =====================
"
"  This CM has N_APPLICAT+1 regions, a series of applicators completely
"  surrounded by an air region. Scrapers are numbered in sequence
"  starting from the furthest upstream.
"
IREND_APPLICAT = IRSTART_APPLICAT+N_APPLICAT;  "Index of last region
NREG = NREG+N_APPLICAT+1;    "Total number of regions in full geometry up
                              "to and including this CM
IF (NREG <= $MXREG) ["have not exceeded maximum region number
      "Index of first region in next CM:"
      IR_start_CM(ICM_APPLICAT+1) = IREND_APPLICAT+1;
]
ELSE [
      OUTPUT ICM_APPLICAT, NREG,$MXREG;
      (//' ***ERROR IN CM ',I4,' (APPLICAT):'/
         I4,' regions requested, only',I4,' available');
     IERR_GEOM(ICM_APPLICAT)=IERR_GEOM(ICM_APPLICAT)+1;
]
"
"  parameter definition
"  ====================
"
"geometrical coordinates, material, and energy cutoffs of applicators
"
"
IRA = IRSTART_APPLICAT-1; "absolute region number"
DO IR_APPLICAT=1,N_APPLICAT ["loop through applicators"
   IRA = IRA+1;
   ZMAX_APPLICAT(IR_APPLICAT) = ZMIN_APPLICAT(IR_APPLICAT)+
       ZTHICK_APPLICAT(IR_APPLICAT);
   ZMAXT_APPLICAT(IR_APPLICAT,1) = ZMAX_APPLICAT(IR_APPLICAT)+$BDY_TOL;
   ZMAXT_APPLICAT(IR_APPLICAT,2) = ZMAX_APPLICAT(IR_APPLICAT)-$BDY_TOL;
   ZMINT_APPLICAT(IR_APPLICAT,1) = ZMIN_APPLICAT(IR_APPLICAT)-$BDY_TOL;
   ZMINT_APPLICAT(IR_APPLICAT,2) = ZMIN_APPLICAT(IR_APPLICAT)+$BDY_TOL;
   XMAX_APPLICAT(IR_APPLICAT) = XMIN_APPLICAT(IR_APPLICAT)+
        WIDTHX_APPLICAT(IR_APPLICAT);
   YMAX_APPLICAT(IR_APPLICAT) = YMIN_APPLICAT(IR_APPLICAT)+
        WIDTHY_APPLICAT(IR_APPLICAT);
   XMAXT_APPLICAT(IR_APPLICAT,1) =XMAX_APPLICAT(IR_APPLICAT)+$BDY_TOL;
   XMAXT_APPLICAT(IR_APPLICAT,2) =XMAX_APPLICAT(IR_APPLICAT)-$BDY_TOL;
   XMINT_APPLICAT(IR_APPLICAT,1) =XMIN_APPLICAT(IR_APPLICAT)-$BDY_TOL;
   XMINT_APPLICAT(IR_APPLICAT,2) =XMIN_APPLICAT(IR_APPLICAT)+$BDY_TOL;
   YMAXT_APPLICAT(IR_APPLICAT,1) =YMAX_APPLICAT(IR_APPLICAT)+$BDY_TOL;
   YMAXT_APPLICAT(IR_APPLICAT,2) =YMAX_APPLICAT(IR_APPLICAT)-$BDY_TOL;
   YMINT_APPLICAT(IR_APPLICAT,1) =YMIN_APPLICAT(IR_APPLICAT)-$BDY_TOL;
   YMINT_APPLICAT(IR_APPLICAT,2) =YMIN_APPLICAT(IR_APPLICAT)+$BDY_TOL;
   "MED(IRA) = MED(IRSTART_APPLICAT);"
   ECUT(IRA) = ECUT(IRSTART_APPLICAT);
   PCUT(IRA) = PCUT(IRSTART_APPLICAT);
] "end of loop over IR_APPLICAT"
"
"establish start of next CM
"
Z_min_CM(ICM_APPLICAT+1) = ZBACK_APPLICAT;
"
"geometrical coordinates, material, and energy cutoffs of air region surrounding
"applicators
"
ZFRONT_APPLICAT = Z_min_CM(ICM_APPLICAT);
IRA = IREND_APPLICAT; "absolute region number"
MED(IRA) = AIR_INDEX; "air region"
ECUT(IRA) = ECUT(IRSTART_APPLICAT); "same energy cutoffs as applicators"
PCUT(IRA) = PCUT(IRSTART_APPLICAT);
ESAVE(IRA)=ESAVE_GLOBAL;
"
"  establish CM boundary
"  =====================
"
"Used to establish scraper boundaries here, but they are now defined
"right at input
RMAX_CM_FLAG(ICM_APPLICAT) = 2; "put a square boundary about CM
"
"  establish dose-scoring zones and range rejection parameters for each region
"  ===========================================================================
"
IRA = IRSTART_APPLICAT-1; "absolute region number
DO IR_APPLICAT=1,N_APPLICAT ["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),DOSE_ZONE_AIR,NDOSE_ZONE);"# dose zones"
   "charged particle range rejection parameters
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region
] "end of loop over IR_APPLICAT
IRA = IRA+1; "absolute region number of air surrounding applicators
DOSE_ZONE(IRA) = DOSE_ZONE_AIR;
E_min_out(ICM_APPLICAT)=ECUT(IRA); "Minimum energy on exit from CM
IRA = IRSTART_APPLICAT-1; "absolute region number
DO I =1,N_APPLICAT[
   IRA = IRA + 1;
   MAX_BIT = MAX(MAX_BIT,IREGION_TO_BIT(IRA));
]
IREGION_TO_BIT(IREND_APPLICAT) = IR_TO_BIT_AIR;
MAX_BIT = MAX(MAX_BIT,IR_TO_BIT_AIR);
"
"   return from INPUT_APPLICAT
"   ==========================
"
RETURN;
"   error messages
"   ==============
"
:EOF_APPLICAT:
;OUTPUT ICM;(//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;
:ERROR_APPLICAT:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;
END;  "End of INPUT_APPLICAT"
%E "start of subroutine ISUMRY_APPLICAT"
"*******************************************************************************
"
"                          Subroutine ISUMRY_APPLICAT
"                          **************************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_APPLICAT;


;IMPLICIT NONE;
;COMIN/BOUNDS,CMs,CM_APPLICAT,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;
"T>
"T>*************************************
"T>TYPE DECLARATIONS FOR ISUMRY_APPLICAT
"T>*************************************
"T>
INTEGER
   ICOLOUR,                        "T>colour of CM for EGS_Windows
   IRA,                            "T>absolute region number
   J;                              "T>DO loop index

$REAL
   XMAXA,                          "T>outer applicator boundary in x
   XMINA,                          "T>inner applicator boundary in x
   YMAXA,                          "T>outer applicator boundary in y
   YMINA,                          "T>inner applicator boundary in y
   VOLAIR_APPLICAT,               "T>air volume
   VOLSCRAPER_APPLICAT;           "T>volume of individual applicators

"   Mass of dose zone
"   =================
"
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_APPLICAT.
IRA = IRSTART_APPLICAT-1; "absolute region number
VOLAIR_APPLICAT = (ZBACK_APPLICAT-ZFRONT_APPLICAT)*4*RMAX_CM2(ICM_APPLICAT);
"air volume"
DO IR_APPLICAT=1,N_APPLICAT ["loop over local region numbers of applicators
   IRA = IRA+1;
   IF (RMAX_CM(ICM_APPLICAT)>XMAX_APPLICAT(IR_APPLICAT))&
      (RMAX_CM(ICM_APPLICAT)>YMAX_APPLICAT(IR_APPLICAT)) [
      "applicator boundary is (XMAXA x YMAXA)"
      VOLSCRAPER_APPLICAT = (ZMAX_APPLICAT(IR_APPLICAT)-
         ZMIN_APPLICAT(IR_APPLICAT))*
         (4*XMAX_APPLICAT(IR_APPLICAT)*YMAX_APPLICAT(IR_APPLICAT)-
         4*XMIN_APPLICAT(IR_APPLICAT)*YMIN_APPLICAT(IR_APPLICAT));
   ]
   ELSEIF (RMAX_CM(ICM_APPLICAT)<=XMAX_APPLICAT(IR_APPLICAT))&
      (RMAX_CM(ICM_APPLICAT)<=YMAX_APPLICAT(IR_APPLICAT)) [
      "applicator boundary is RMAX_CM"
      VOLSCRAPER_APPLICAT = (ZMAX_APPLICAT(IR_APPLICAT)-
         ZMIN_APPLICAT(IR_APPLICAT))*
         (4*RMAX_CM2(ICM_APPLICAT)-
         4*XMIN_APPLICAT(IR_APPLICAT)*YMIN_APPLICAT(IR_APPLICAT));
   ]
   ELSEIF (RMAX_CM(ICM_APPLICAT)>XMAX_APPLICAT(IR_APPLICAT))&
      (RMAX_CM(ICM_APPLICAT)<YMAX_APPLICAT(IR_APPLICAT)) [
      "applicator boundary in y is RMAX_CM"
      VOLSCRAPER_APPLICAT = (ZMAX_APPLICAT(IR_APPLICAT)-
         ZMIN_APPLICAT(IR_APPLICAT))*
         (4*XMAX_APPLICAT(IR_APPLICAT)*RMAX_CM(IR_APPLICAT)-
         4*XMIN_APPLICAT(IR_APPLICAT)*YMIN_APPLICAT(IR_APPLICAT));
   ]
   ELSE ["applicator boundary in x is RMAX"
      VOLSCRAPER_APPLICAT = (ZMAX_APPLICAT(IR_APPLICAT)-
         ZMIN_APPLICAT(IR_APPLICAT))*
         (4*RMAX_CM(IR_APPLICAT)*YMAX_APPLICAT(IR_APPLICAT)-
         4*XMIN_APPLICAT(IR_APPLICAT)*YMIN_APPLICAT(IR_APPLICAT));
   ]
   VOLAIR_APPLICAT = VOLAIR_APPLICAT-VOLSCRAPER_APPLICAT; "air volume"
   IF(DOSE_ZONE(IRA)~=0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+RHOR(IRA)*VOLSCRAPER_APPLICAT;
   ]
] "end of loop over IR_APPLICAT"
IRA = IRA+1; "absolute region number of air surrounding applicators"
IF(DOSE_ZONE(IRA)~=0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+RHOR(IRA)*VOLAIR_APPLICAT;
]
"
"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"
WRITE(IOUTLIST,110) ICM_APPLICAT,TITLE_APPLICAT;
WRITE(IOUTLIST,120) Z_min_CM(ICM_APPLICAT),RMAX_CM(ICM_APPLICAT),
                    Z_min_CM(ICM_APPLICAT+1);
WRITE(IOUTLIST,122);
DO IR_APPLICAT=1,N_APPLICAT [
   IF(IR_APPLICAT=1)[
      WRITE(IOUTLIST,126)'airgap',Z_min_CM(ICM_APPLICAT),
                         ZMIN_APPLICAT(1)-Z_min_CM(ICM_APPLICAT),
                         'NA','NA','NA','NA';
   ]
   ELSE[
      WRITE(IOUTLIST,126)'airgap',ZMAX_APPLICAT(IR_APPLICAT-1),
                         ZMIN_APPLICAT(IR_APPLICAT)-
                         ZMAX_APPLICAT(IR_APPLICAT-1),
                         'NA','NA','NA','NA';
   ]
   WRITE(IOUTLIST,123)
      IR_APPLICAT,ZMIN_APPLICAT(IR_APPLICAT),
      ZMAX_APPLICAT(IR_APPLICAT)-ZMIN_APPLICAT(IR_APPLICAT),
      XMIN_APPLICAT(IR_APPLICAT),
      YMIN_APPLICAT(IR_APPLICAT),
      XMAX_APPLICAT(IR_APPLICAT)-XMIN_APPLICAT(IR_APPLICAT),
      YMAX_APPLICAT(IR_APPLICAT)-YMIN_APPLICAT(IR_APPLICAT);
   IF(IR_APPLICAT=N_APPLICAT)[
      WRITE(IOUTLIST,126)'airgap',ZMAX_APPLICAT(N_APPLICAT),
                         Z_min_CM(ICM_APPLICAT+1)-
                         ZMAX_APPLICAT(N_APPLICAT),'NA','NA','NA','NA';
   ]
]
123 FORMAT(T5,I6,6F11.4);
WRITE(IOUTLIST,124);
IF(Z_min_CM(ICM_APPLICAT + 1) >
   ZMAX_APPLICAT(N_APPLICAT)+AIRGAPMIN_APPLICAT)[
   WRITE(IOUTLIST,125);
]
WRITE(IOUTLIST,130);
IRA = IRSTART_APPLICAT-1;"absolute region number"
DO IR_APPLICAT=1,N_APPLICAT+1 [
   IRA = IRA+1;
   IF (IR_APPLICAT<=N_APPLICAT)[
      IF (MED(IRA)=0) ["Medium is vacuum"
         WRITE(IOUTLIST,140) IR_APPLICAT,IR_APPLICAT,'scraper',
         ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,140) IR_APPLICAT,IR_APPLICAT,'scraper',
         ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
         DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]
   ELSEIF(IR_APPLICAT=N_APPLICAT+1)[
      IF (MED(IRA)=0) ["Medium is vacuum"
         WRITE(IOUTLIST,141) IR_APPLICAT,'NA','surrounding',
         ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,141) IR_APPLICAT,'NA','surrounding',
         ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
         DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
      WRITE(IOUTLIST,142)'air';
   ]
]
110 FORMAT(///1x,79('-')/'  Component module',I3,
          ' is a set of square scrapers (APPLICAT) '/
          1x,79('-') //T5,'Title: ',68A1);
120 FORMAT(/T2,'APPLICAT geometry parameters:',
           /T2,'--------------------------',
           /T2,'Z of front face of CM = ',F15.5,' cm',
           /T2,'Half-width of outer boundary of CM = ',F15.5,' cm',
           /T2,'Z of back face of CM = ',F15.5,' cm');
122 FORMAT(
/T5,'scraper   Z of     bar/gap  x half-width  y half-width  x bar   y bar',
/T5,'number  front face  thick     opening       opening     width   width',
/T5,'         (cm)       (cm)       (cm)         (cm)        (cm)     (cm) ');
126 FORMAT(T5,A6,2F11.4,4A11);
124 FORMAT(/T2,
'Note gap between the last scraper and the back of the CM.');
125 FORMAT(/T2,
'This gap was not set to the default value of airgapmin but'/T2,
'was set to a user-defined value > airgapmin.');
130 FORMAT(/T2,'APPLICAT region parameters:',
           /T2,'------------------------',
           /T2,'local scraper  location  electron   photon',
           '  range-rejection   dose  bit  medium'
           /T2,'region   #                cutoff    cutoff',
           '   level     max    zone  set'
/T2,'                          (MeV)    (MeV)    (MeV)    (MeV)');
140 FORMAT(T2,I3,I6,3X,A11,F8.3,F9.3,F9.3,F9.3,I5,I5,2X,9A1);
141 FORMAT(T2,I3,3X,A3,3X,A11,F8.3,F9.3,F9.3,F9.3,I5,I5,2X,9A1);
142 FORMAT(T14,A11);
"
"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"
IF (IWATCH = 4 | IZLAST = 2) ["Graphics file requested"
   ;$SELECT-COLOUR; "Macro for selecting ICOLOUR = 1, 2, or 3, colour of CM"
   DO IR_APPLICAT=1,N_APPLICAT ["Loop over local region number"
      XMINA = XMIN_APPLICAT(IR_APPLICAT);
      YMINA = YMIN_APPLICAT(IR_APPLICAT);
      XMAXA = MIN(XMAX_APPLICAT(IR_APPLICAT),
                  MAX(XMINA,RMAX_CM(ICM_APPLICAT)));
      YMAXA = MIN(YMAX_APPLICAT(IR_APPLICAT),
                  MAX(YMINA,RMAX_CM(ICM_APPLICAT)));
      WRITE(IOUTGEOM,200)
         ICOLOUR,'COLX',XMAXA,XMINA,XMINA,XMAXA,YMAXA,
         ZMIN_APPLICAT(IR_APPLICAT),ZMAX_APPLICAT(IR_APPLICAT);
      WRITE(IOUTGEOM,200)
         ICOLOUR,'COLX',-XMAXA,-XMINA,-XMINA,-XMAXA,YMAXA,
         ZMIN_APPLICAT(IR_APPLICAT),ZMAX_APPLICAT(IR_APPLICAT);
      WRITE(IOUTGEOM,200)
         ICOLOUR,'COLY',YMAXA,YMINA,YMINA,YMAXA,XMINA,
         ZMIN_APPLICAT(IR_APPLICAT),ZMAX_APPLICAT(IR_APPLICAT);
      WRITE(IOUTGEOM,200)
         ICOLOUR,'COLY',-YMAXA,-YMINA,-YMINA,-YMAXA,XMINA,
         ZMIN_APPLICAT(IR_APPLICAT),ZMAX_APPLICAT(IR_APPLICAT);
   ]
] "End of graphics output"
200 FORMAT(' ',I1,A4,10(F7.2,','));
;RETURN;END;
"APPLICAT_cm.mortran end of ISUMRY_APPLICAT"

%E "start of subroutine HOWNEAR_APPLICAT"
"*******************************************************************************
"
"                          Subroutine HOWNEAR_APPLICAT
"                          **************************
"
" Returns min. distance to nearest region boundary.  Used to be a macro but
" now the macro is replaced by a call to this subroutine.
"
"*******************************************************************************
;SUBROUTINE HOWNEAR_APPLICAT(DIST);

$IMPLICIT-NONE;
COMIN/CMs,CM_APPLICAT,STACK/;

$REAL DIST; "T> distance to nearest region boundary"

IR_APPLICAT = IR(NP)-IRSTART_APPLICAT+1;
IF (IR_APPLICAT=N_APPLICAT+1) ["in air region sorrounding scrapers"
   DIST = 0.0; "simple solution for now"
]
ELSE ["in scraper IR_APPLICAT"
   DIST = MIN(ZMAX_APPLICAT(IR_APPLICAT)-Z(NP),
                 Z(NP)-ZMIN_APPLICAT(IR_APPLICAT),
                 XMAX_APPLICAT(IR_APPLICAT)-ABS(X(NP)),
                 YMAX_APPLICAT(IR_APPLICAT)-ABS(Y(NP)));
   IF ABS(X(NP))>XMINT_APPLICAT(IR_APPLICAT,1) [
        DIST = MIN(DIST,ABS(X(NP))-XMIN_APPLICAT(IR_APPLICAT));
   ]
   IF ABS(Y(NP))>YMINT_APPLICAT(IR_APPLICAT,1) [
        DIST = MIN(DIST,ABS(Y(NP))-YMIN_APPLICAT(IR_APPLICAT));
   ]
]
RETURN;
END; "End of subroutine HOWNEAR_APPLICAT"
"*****************************************************************************
"End of APPLICAT_cm.mortran"
%N "Turn off MORTRAN listing
