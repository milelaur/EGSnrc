%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: stacked planes                            "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Geoff Zhang                                               "
"                   Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code originally evolved from the SLAB component module written by     "
"  Dave Rogers and Bruce Faddegon, starting in 1991, and subsequently edited  "
"  by George Ding.                                                            "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             ***********             ""toc:
"                             *         *             ""toc:
"                             *  SLABS  *             ""toc:
"                             *         *             ""toc:
"                             ***********             ""toc:
"
"   History of modifications given by sccs
"
"*******************************************************************************
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.  Multiple planes of arbitrary thickness and
"   material.
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator:  a set of 2 or more
"   slabs infinite in x & y.
"
"   This component module can be added to the simulation by including these
"   routines in the MORTRAN file BEAM_CM.MORTRAN and including the MORTRAN
"   replacement macros associated with this component module in the file
"   BEAM_COMMON.MORTRAN.  The order of the component modules in either of
"   these files is unimportant.  To explicitly include this component module in
"   the simulation it must be included in the $CM_LIST replacement statement.
"   The component modules in this list are stacked sequentially for the
"   simulation, one on top of the other, and must not overlap.
;
%E   " SLABS_cm.mortran - start of geometry description
"I>
"I> Geometry of TARGET (SLABS):             ""toc:
"I> ******************
"I>
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I> -------->    IR=    | IR=1   |  IR=2    | ...... |  IR=N_SLABS    |
"I>    beam   N_SLABS+1 |        |          |        |                |
"I> direction  (airgap) |        |          |        |                |
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I>
"I>   IR is the region number within the CM.  There are N_SLABS(+1) local
"I>   regions. The first region is the slab furthest upstream.  If there
"I>   is an airgap at the front (top) then it is the last region,
"I>   otherwise the last region is the slab furthest downstream.
"I>
"I>
"I>            -----------------------------------------------
"I>            |          Region        | Description        |
"I>            |------------------------|--------------------|
"I>            |  absolute    | local   |                    |
"I>            |--------------|---------|                    |
"I>            |IRSTART_SLABS | IR_SLABS| slab infinite x, y |
"I>            |  +IR_SLABS-1 |         |                    |
"I>            -----------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_TARGET
"                      ISUMRY_TARGET
"                      HOWFAR_TARGET
"                      WHERE_AM_I_TARGET
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS ON USE/BUGS             ""toc:
"                             ************************
"
"         As structured, one cannot assign IREGION_TO_BIT or DOSE_ZONE values
"         to the air gap region if it exists.
"
"        in EGS_WINDOWS file, a disk instead of square is output
"
"*******************************************************************************
"
;
"*******************************************************************************
"**************************  DESCRIPTION OF VARIABLES  *************************
"*******************************************************************************
"
"
"                                OTHER VARIABLES
"                                ***************
"
"  Refer to the section on type declarations for each subroutine. The following
"  section describes the variables input from unit 5.  These variables define
"  the parameters of each simulation.
"
"*******************************************************************************
"
"                               INPUT FROM UNIT 5              ""toc:
"                               *****************             ""toc:
"
"I>
"I>  CARDS CM_TARGET  (SLABS)
"I>  **************
"I>
"I>  -1  dummy line (filled with ****)  read in main
"I>
"I>   0  RMAX_CM(ICM_TARGET)       outer boundary for CM - 1/2 side of
"I>                                square(read in main)
"I>
"I>   1  TITLE_TARGET (60A1):  Title of CM.
"I>
"I>   2  N_TARGET (I5):  Number of planar slabs in CM = # regions in CM,
"I>                      excludes any air gap needed.
"I>
"I>   3  ZMIN_TARGET (F15.0):  Distance from front of first slab to reference
"I>                            plane  (Z=0).
"I>
"I>   4  Parameters of each slab from front to back (increasing Z).  One pair of
"I>      cards (4a and 4b) for each of the slabs.
"I>
"I>      4a   ZTHICK_TARGET, ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT, ESAVEIN
"I>                           (3F15.0,2I5,F15.0):
"I>
"I>              ZTHICK_TARGET:   slab thickness.
"I>              ECUT, PCUT:      Cutoff energies-defaults are ECUTIN,PCUTIN
"I>              DOSE_ZONE:       Dose zone to score dose - 0 if not scored
"I>              IREGION_TO_BIT:  map this region to this bit number in LATCH
"I>              ESAVEIN:         Value of ESAVE for this region if range
"I>                               rejection on. Default is ESAVE_GLOBAL.
"I>
"I>      4b   MED_IN (24A1):  Medium of the planar slab, used to set MED_INDEX.
"I>
"I>   Example
"I>   *******
"I>
"I>  The following set of cards defines a 1 cm thick slab of air sandwiched
"I>  between two 0.1 cm thick slabs of tungsten.  The front slab is at
"I>  Z=7.32 cm. Electrons will be followed in the slabs down to kinetic energies
"I>  of 10 keV (total energies of 0.521 MeV) and photons will be followed down
"I>  to energies of 1 keV.  The dose deposited in the air will be scored and
"I>  added to the dose from the other regions in dose zone 1, and the
"I>  dose deposited in both tungsten slabs will be scored and added to the dose
"I>  from the other regions in dose zone 2.  Particles interacting in
"I>  the first slab will be associated with BIT 1 in LATCH.  In all slabs,
"I>  ESAVEIN=0, thus ESAVE in each slab will default to ESAVE_GLOBAL.
"I>
"I>  10.0,                         RMAX_CM
"I>  Multiple slabs: 0.1cm W-1cm air-0.1cm W, ECUT=0.521, PCUT=0.001
"I>  3,                            N_SLABS
"I>  7.32,                         ZMIN_SLABS
"I>  0.1, 0.521, 0.001, 2,1,0.0,   ZTHICK_SLABS etc
"I>  W521ICRU
"I>  1., 0.521, 0.001, 1,0,0.0
"I>  AIR521ICRU
"I>  0.1, 0.521, 0.001, 2,0,0.0
"I>  W521ICRU
"
"
%E   "Start of subroutine INPUT_TARGET"
"*******************************************************************************
"
"                           Subroutine INPUT_SLABS
"                           **********************
"
"  A CM input subroutine for a series of 1 or more slabs infinite in x & y.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_TARGET;


;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_TARGET,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;
"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_SLABS
"T>*********************************
"T>
$REAL ZMIN_TARGET,                   "T>minimum Z for this CM
      ESAVEIN;                       "T>ESAVE value read in for each region

INTEGER I,J,                         "T>DO loop indeces
        IRA,                         "T>Absolute region number
        MED_FLAG,                    "T>flag for media-sort macro $MED_INPUT
        MED_INDEX,                   "T>medium index,set(post)sort $MED_INPUT
        NDO;                         "T>loop index
"
"  initialize parameters
"  =====================
"
ICM_TARGET = ICM;                   "CM index for this component module
                                    "Note ICM_TARGET not needed here since
                                    "ICM is set, but it is not set when
                                    "other routines called.
IRSTART_TARGET = IR_start_CM(ICM_TARGET); "Index of first region in this CM,
                                    "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_TARGET) = 0;          "Geometry-checking flag, 0 if no errors
"
"establish CM boundary as a square (was cylinder prior to April 13,1994)
RMAX_CM_FLAG(ICM_TARGET) = 2;       "put a square boundary about CM
"
OUTPUT;(/' TARGET (SLABS)');
OUTPUT RMAX_CM(ICM); (' This component is a set of planar slabs'/
  '      Outer boundary is a square with |x| & |y| <',F10.2,' cm');
IF(ICM_TARGET = 1)[
   OUTPUT Z_min_CM(ICM_TARGET);
   (' This is first component -- starts at ',F11.4,' cm from reference plane');]
ELSE
   [OUTPUT Z_min_CM(ICM_TARGET);(' Previous CM ends at:',F12.5,' cm');]
OUTPUT;(' TITLE: ',$);
;MINPUT (TARGET) TITLE_TARGET;(60A1);
               "MINPUT is a replacement macro with EOF and
               "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_TARGET;(' ',60A1);
"
"   get information for each slab
"   =============================
"
"
"Get maximum number of slabs (and regions) permitted
OUTPUT $MAX_N_TARGET; (' NUMBER OF SLABS (MINIMUM 1, MAXIMUM',I3,'): ',$);
;MINPUT (TARGET) N_TARGET; (I5);
OUTPUT N_TARGET; (I5);
IF(N_TARGET < 1)[
         N_TARGET=1;
         OUTPUT ICM_TARGET;
          (//'***ERROR IN CM ',I4,' (SLABS):'/
             '# of slabs < 1'/
             '# of slabs set to 1 for now.'//);
         IERR_GEOM(ICM_TARGET)=IERR_GEOM(ICM_TARGET)+1;
]
ELSEIF (N_TARGET > $MAX_N_TARGET)[
               N_TARGET=$MAX_N_TARGET;
               OUTPUT ICM_TARGET, N_TARGET;
               (//'***ERROR IN CM ',I4,' (SLABS):'/
                  '# of slabs > max. allowed'/
                  '# of slabs reduced to ',I4,' for now'//);
               IERR_GEOM(ICM_TARGET)=IERR_GEOM(ICM_TARGET)+1;
]

" get distance from reference plane, z=0"
"
OUTPUT;
 (' DISTANCE FROM FRONT OF SLABS (excluding air gap) TO REF PLANE (z=0): ',$);
;MINPUT (TARGET) ZMIN_TARGET;(F15.0);
OUTPUT ZMIN_TARGET;(F10.5);
IF(ZMIN_TARGET < Z_min_CM(ICM_TARGET))["have overlapped two CMs"
   IF(ICM_TARGET = 1)["first CM is special case"
     "Z_min_CM(1) is very front of accelerator, including air, input in main"
     OUTPUT ICM_TARGET, ZMIN_TARGET,Z_min_CM(ICM_TARGET);
      (//' ***WARNING IN CM ',I4,' (TARGET):'/
       ' Z_min_CM(1) (=front of the accelerator) is past front of first slab'/
       ' Z_min_CM(1) reset to value just input =',F8.5,' cm'/
       ' from ',F8.5,' cm'//);
     WRITE(IOUTLIST,:label1:) ICM_TARGET, ZMIN_TARGET,
                              Z_min_CM(ICM_TARGET);
          :label1: FORMAT(//' ***WARNING IN CM ',I4,' (TARGET):'/
  ' Z_min_CM(1) (=front of the accelerator) is past front of first slab'/
  ' Z_min_CM(1) reset to value just input =',F8.5,' cm'/
  ' from ',F8.5,' cm'//);
     Z_min_CM(ICM_TARGET) = ZMIN_TARGET;
   ]
   ELSE[
     OUTPUT ICM_TARGET;
       (//'***ERROR IN CM ',I4,' (TARGET):'/
          'Overlaps with previous CM.'//);
     IERR_GEOM(ICM_TARGET)=IERR_GEOM(ICM_TARGET)+1;
   ]
]

"loop over slabs
"
IRA = IRSTART_TARGET-1; "absolute region number
DO IR_TARGET=1,N_TARGET [
   "loop through local region number to get slab information"
   IRA = IRA+1;
   "get thickness, cutoff energies, and dose scoring zone"
   "
   OUTPUT IR_TARGET;(//' Inputs for slab # ',I5);
   OUTPUT; (' SLAB THICKNESS(cm), ECUT, PCUT,',
         ' DOSE ZONE(0=>DONT SCORE), IREGION_TO_BIT,ESAVE'/' :',$);
   ;MINPUT (TARGET)
      ZTHICK_TARGET(IR_TARGET),ECUT(IRA),PCUT(IRA),
      DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),ESAVEIN;
      (3F15.0,2I5,F15.0);
   IF (ECUT(IRA) < ECUTIN) ECUT(IRA)=ECUTIN;
   IF (PCUT(IRA) < PCUTIN) PCUT(IRA)=PCUTIN;
   IF (ESAVEIN > 0.511) [ESAVE(IRA) = ESAVEIN;]
   ELSE [ESAVE(IRA)=ESAVE_GLOBAL;]
   "Particles with total energies < ESAVE are considered for range rejection"
   "if range rejection is on.  Default is ESAVE_GLOBAL but values are set"
   "back to zero in main if range rejection is off"
   ;OUTPUT
      ZTHICK_TARGET(IR_TARGET),ECUT(IRA),PCUT(IRA),
      DOSE_ZONE(IRA),IREGION_TO_BIT(IRA), ESAVE(IRA);
      (3F11.5,I9,I20,F11.5);
   IF(ZTHICK_TARGET(IR_TARGET)<0.0)[
      OUTPUT ICM_TARGET, IR_TARGET;
       (//'***ERROR IN CM ',I4,' (SLABS):'/
          'ZTHICK(',I4,') < 0.0'//);
      IERR_GEOM(ICM_TARGET)=IERR_GEOM(ICM_TARGET)+1;
   ]
   "get material for this slab and determine material number for this region"

   OUTPUT;(' SLAB ',$);
   ;$MED_INPUT(TARGET); " inputs character array MED_IN from unit 5, loops
      "through array MEDIA(24,I) to check if medium was previously input.
      "If so, sets MED_INDEX to index of previous medium.  If not,
      "increments NMED and sets MED_INDEX to NMED.
   MED(IRA) = MED_INDEX; " medium of the planar slab
] "end of loop over IR_TARGET"
"
"  parameter definition
"  ====================
"
"fill arrays of distance from reference plane (z=0) to front and back of slabs
ZFRONT_TARGET(1) = ZMIN_TARGET;
IF (N_TARGET > 1) [
   DO IR_TARGET=1,N_TARGET-1 ["loop through local region number"
      ZBACK_TARGET(IR_TARGET) = ZFRONT_TARGET(IR_TARGET) +
                            ZTHICK_TARGET(IR_TARGET);
      ZFRONT_TARGET(IR_TARGET+1) = ZBACK_TARGET(IR_TARGET);
   ] "end of loop over IR_TARGET"
]
ZBACK_TARGET(N_TARGET) = ZFRONT_TARGET(N_TARGET) +
                             ZTHICK_TARGET(N_TARGET);
"
"establish start of next CM
Z_min_CM(ICM_TARGET+1) = ZBACK_TARGET(N_TARGET);
"
"  set up air gap to previous CM, if present
"  =========================================
"
"  The air gap has the highest region number in the CM, even though it is at
"  the top of the component module.  This is to allow the assignment of region
"  numbers on input of the parameters of each local region (mainly to assign the
"  medium number of the region).  The air gap is then assigned after all of the
"  CM parameters have been input.
"
Z_gap_THICK(ICM_TARGET) = ZMIN_TARGET-Z_min_CM(ICM_TARGET);

IF (Z_gap_THICK(ICM_TARGET) < $MIN_GAP) ["$MIN_GAP is defined in  main"
   Z_gap_THICK(ICM_TARGET) = 0.;
   ZFRONT_TARGET(1)=Z_min_CM(ICM_TARGET);
   N_GAP_TARGET = 0; "no air gap for this CM
]
ELSE [
   N_GAP_TARGET = 1; "this CM has an air gap
   IRA = IRSTART_TARGET+N_TARGET; "absolute region number of air gap
   MED(IRA) = AIR_INDEX; "medium is air, vacuum or whatever assigned
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
   ECUT(IRA) = ECUTIN;
   PCUT(IRA) = PCUTIN;
   ZFRONT_TARGET(N_TARGET+1) = Z_min_CM(ICM_TARGET);
   "only for output listing
]
"  set up region numbers
"  =====================
"
"  This CM has N_TARGET+N_GAP_TARGET regions, plates infinite in x & y, with
"  an air gap at the front, if present. Slabs are numbered in sequence starting
"  from the furthest upstream slab to the last downstream slab, followed by the
"  air gap, if present.
"
IREND_TARGET = IRSTART_TARGET+N_TARGET+N_GAP_TARGET-1;
               "Index of last region
NREG = NREG+N_TARGET+N_GAP_TARGET;  "Total of regions in full geometry up
                                    "to and including this CM
                                    "NREG is in comin GEOM
IF (NREG <= $MXREG) ["have not exceeded maximum region number
      "Index of first region in next CM:"
      IR_start_CM(ICM_TARGET+1) = IREND_TARGET+1;
]
ELSE [
      OUTPUT ICM_TARGET,NREG,$MXREG;
      (//'***ERROR IN CM ',I4,' (SLABS):'/
         I4,' regions requested, only', I4,' available'/
         '    Change $MXREG in beam_user_macros.mortran'//);
      IERR_GEOM(ICM_TARGET)=IERR_GEOM(ICM_TARGET)+1;
]
"
"  establish dose-scoring zones and range rejection parameters for each region
"  ===========================================================================
"
"Note air gap cannot be a dose scoring region as presently set up.
IRA = IRSTART_TARGET-1; "absolute region number
DO IR_TARGET=1,N_TARGET ["loop over local region number
   IRA = IRA+1;

   "dose-scoring zones
   "
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT); " current maxmum number
] "end of loop over IR_TARGET

"set up minimum thicknesses which in this case are just the last 5"
"slabs"
"If we ever need more than 5 slabs, we should extend this or do
"something fancy like group similar materials"

NDO = MIN(5,N_TARGET); "consider at most 5 slabs of material"
                       "air gap handled below"
                       "limit of 5 not essential here, but needed in helpful"
                       "in other cases"
"OUTPUT NDO;(' For automated range rejection consider',I3,' slabs of material');
DO IR_TARGET = N_TARGET, N_TARGET-NDO+1, -1 [
   IRA = IR_TARGET + IRSTART_TARGET-1;   "absolute region"
   Z_min_thick(ICM,N_TARGET+1 - IR_TARGET) = ZTHICK_TARGET(IR_TARGET);
   "MED_min_thick is in COMIN CMs"
   MED_min_thick(ICM,N_TARGET+1 - IR_TARGET) = MED(IRA);
   "OUTPUT IR_TARGET,IRA,ICM, N_TARGET+1-IR_TARGET,
      "Z_min_thick(ICM,N_TARGET+1-IR_TARGET),
      "ICM,N_TARGET+1 - IR_TARGET,
      "MED_min_thick(ICM,N_TARGET+1 - IR_TARGET);
      "(' IR_TARGET,IRA=',I2,',',I3,' Z_min_thick(',2I2,')=',F10.3,
      "'  MED_min_thick(',2I3,')=',I2   );
]
IF(NDO < 5)[  "some not used - include air gap if there is one"
    IF(N_GAP_TARGET = 1)["There is an air gap"
       Z_min_thick(ICM,NDO+1) = Z_gap_thick(ICM_TARGET);
       MED_min_thick(ICM,NDO+1) = 1; "AIR is 1"
       OUTPUT ICM,NDO+1,Z_min_thick(ICM,NDO+1),ICM,NDO+1,
                 MED_min_thick(ICM,NDO+1);
       (' Front air gap',T20,' Z_min_thick(',I2,',',I2,')=',F10.3,
                 '  MED_min_thick(',I2,',',I2,')=',I5   );
       NDO = NDO +1;
    ]"end of loop if there is an air gap"
    IF(NDO < 5 )["check in case incremented by air gap"
       DO I = NDO+1,5["zero remaining, unused values"
         Z_min_thick(ICM,I) = 0.0;
         MED_min_thick(ICM,I) = 0;
       ]"end of do loop on I"
    ]"end second NDO < 5 case"
]"end NDO < 5 case"
"
"   return from INPUT_SLABS
"   =======================
RETURN;

"   error messages
"   ==============
"
:EOF_TARGET:
;OUTPUT ICM;
(//' *** ERROR in TARGET *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_TARGET:
;OUTPUT ICM;(//' *** ERROR  in TARGET *** format error on input for CM',I3);
STOP; END;
"End of INPUT_TARGET"

%E   "start of subroutine ISUMRY_TARGET"
"*******************************************************************************
"
"                          Subroutine ISUMRY_SLABS
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_TARGET;


;IMPLICIT NONE;
;COMIN/BOUNDS,CMs,CM_TARGET,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_SLABS
"T>**********************************
"T>
INTEGER
   ICOLOUR,   "T>colour of CM for EGS_Windows
   IDD,       "T>index of dose scoring zone
   IRA,       "T>absolute region number
   J;         "T>DO loop index
"
"   Mass of dose zone
"   =================
"Need to calculate mass of dose zone here,after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_TARGET.
"
IRA = IRSTART_TARGET-1; "absolute region number
DO IR_TARGET=1,N_TARGET+N_GAP_TARGET ["loop over local region number
   IRA = IRA+1;
   IF(DOSE_ZONE(IRA).NE.0) ["this is a dose zone"
      IDD=DOSE_ZONE(IRA);
      "add mass of square region to any previous mass in dose region"
      AMASS(IDD)=AMASS(IDD) + RHOR(IRA)* (ZBACK_TARGET(IR_TARGET)
                 - ZFRONT_TARGET(IR_TARGET))*4*(RMAX_CM2(ICM_TARGET));
      "note RHOR is the density which defaults to that from PEGS4 in HATCH
      "but could be set to any value prior to call to hatch
   ]
] "end of loop over IR_TARGET"

"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"
"Output to list file changed to make it more clear--B Walters 18/08/94"

WRITE(IOUTLIST,110) ICM_TARGET,TITLE_TARGET;
WRITE(IOUTLIST,120) Z_min_CM(ICM_TARGET),RMAX_CM(ICM_TARGET);
WRITE(IOUTLIST,122);
IF(N_GAP_TARGET~=0)[
   WRITE(IOUTLIST,124) 'airgap',Z_min_CM(ICM_TARGET),
                       ZFRONT_TARGET(1)-Z_min_CM(ICM_TARGET);
]
DO IR_TARGET=1,N_TARGET[
   WRITE(IOUTLIST,123) IR_TARGET,ZFRONT_TARGET(IR_TARGET),
                       ZTHICK_TARGET(IR_TARGET);
]
WRITE(IOUTLIST,130);
IRA = IRSTART_TARGET-1;

DO IR_TARGET=1,N_TARGET + N_GAP_TARGET [
   IRA = IRA+1;
   IF(IR_TARGET<=N_TARGET)[
      IF (MED(IRA)=0) ["Medium is vacuum"
         WRITE(IOUTLIST,140)
         IR_TARGET,IR_TARGET,'slab',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,140)
         IR_TARGET,IR_TARGET,'slab',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]
   ELSE[
      IF (MED(IRA)=0) ["Medium is vacuum"
         WRITE(IOUTLIST,142)
         IR_TARGET,'NA','airgap',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,142)
         IR_TARGET,'NA','airgap',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
    WRITE(IOUTLIST,141)'at top';
    ]
]"end loop on IR_TARGET"


110 FORMAT(///1x,79('-')/
 '  Component module',I3,' is one or more planar slabs  ',
 '(SLABS)'
           /1x,79('-')
           //T5,'Title: ',68A1);
120 FORMAT(/T2,'TARGET geometry parameters:',
           /T2,'-----------------------------',
           /T2,'Distance of front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Half-width of outer boundary of CM = ',F15.5,' cm');
122 FORMAT(/T2,
'slab #    Z front    thickness',
/T2,
'           face               ',
/T2,
'           (cm)        (cm)   ');
123 FORMAT(T2,I4,F12.3,F11.3);
124 FORMAT(T2,A6,F10.3,F11.3);
130 FORMAT(/T2,'TARGET region parameters:',
           /T2,'---------------------------',
           /T2,'local  slab #  location  electron  photon',
           '  range-rejection  dose  bit  medium'
           /T2,'region                    cutoff   cutoff',
           '   level     max   zone  set'
           /T2,'                           (MeV)    (MeV)',
           '   (MeV)    (MeV)');

140 FORMAT(T2,I3,I7,5X,A7,F10.3,F9.3,F8.3,F9.3,I5,I5,2X,9A1);
141 FORMAT(T17,A7);
142 FORMAT(T2,I3,5X,A2,5X,A7,F10.3,F9.3,F8.3,F9.3,I5,I5,2X,9A1);



"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"
IF (IWATCH = 4 | IZLAST = 2) ["Graphics file requested"
   ICOLOUR = MOD(ICM_TARGET,4)+1; "select ICOLOUR = 1, 2, or 3, colour of CM"
   DO IR_TARGET=1,N_TARGET ["Loop over local region number"
      WRITE(IOUTGEOM,200) ICOLOUR,'DISK',0.,0.,
                       ZFRONT_TARGET(IR_TARGET),RMAX_CM(ICM_TARGET);
      "NOTE *** it was a disk but it is a square now!"
   ]
   WRITE(IOUTGEOM,200) ICOLOUR,'DISK',0.,0.,
                       ZBACK_TARGET(N_TARGET),RMAX_CM(ICM_TARGET);
   200 FORMAT(' ',I1,A4,10(F7.2,','));
] "End of graphics output"
"
;RETURN;END;
"SLABS_cm.mortran end of ISUMRY_TARGET"

%E   "start of subroutine HOWFAR_TARGET"
"*******************************************************************************
"************************** Component Module SLABS *****************************
"*******************************************************************************
"
"                          Subroutine HOWFAR_SLABS
"                          ***********************
"
" HOWFAR routine for stacked planar media.
"
" Determine if current region number is within component module SLABS, and if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are N_SLABS local regions + an air gap (if present):
"
"     local               absolute                  description
"   ---------  ----------------------------------  -------------
"   IR_SLABS   IR_start_CM(ICM_SLABS)+IR_SLABS-1   slab IR_SLABS
"   N_SLABS+1  IR_start_CM(ICM_SLABS)+N_SLABS      air gap
"
"       Geometrical co-ordinates, as set in INPUT_SLABS are:
"       ZFRONT_SLABS(IR_SLABS)     front of slab IR_SLABS (upstream surface)
"       ZBACK_SLABS(IR_SLABS)      back of slab IR_SLABS (downstream surface)
"
"*******************************************************************************

;SUBROUTINE HOWFAR_TARGET;


;IMPLICIT NONE;
;COMIN/ CMs,CM_TARGET,EPCONT,STACK,EGS-IO/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_SLABS
"T>**********************************
"T>
INTEGER
   IRL;         "T>local region number (absolute), required by HOWNEAR macro
$REAL
   DIST,        "T>distance to region boundary along current particle trajectory
   DMIN_TARGET, "T>minimum distance to boundaries checked thus far
   ZNEAR;       "T>distance to nearest boundary

IRL = IR(NP);   "local region number (absolute)

" Set DNEAR
" *********
" This replacement macros sets DMIN_TARGET as well as defining IR_TARGET
;
TARGET_CM_HOWNEAR(DMIN_TARGET);
DNEAR(NP) = DMIN_TARGET;
;
" Boundary-crossing check
" ***********************
" Determine if current region number is within component module SLABS,
"  and if so evaluate DIST, distance to region boundary along current
" trajectory.  USTEP must not exceed DIST.
"
IF (IR_TARGET>0 & IR_TARGET<N_TARGET+1) [
   "particle in this CM (not in air gap)"
   IF (W(NP)>0.0) ["particle going forward"
      "calculate distance to back boundary"
      ZNEAR = ZBACK_TARGET(IR_TARGET)-Z(NP);
      DIST = ZNEAR/W(NP);
      IF (DIST < 0.) [DIST=0.;]
      "Above check was put in to handle the case where the distance"
      "to interaction is ~ the distance to the"
      "back of the SLABS CM.  In this case, particles initiated"
      "by the interaction may actually have Z values that put them"
      "in the next CM, but because the WHERE_AM_I for the next"
      "CM has not been called yet, HOWFAR for SLABS is used, and a"
      "negative USTEP results.  Note that this unusual case has"
      "only been observed to occur between SLABS and CONS3R CMs"
      "when incident particles are photons, SLABS is the target, and"
      "CONS3R is the primary collimator immediately below the target"
      "18/12/95"
      IF(DIST=0. & IR_TARGET=N_TARGET)[DIST=1.E-16;]
      "Above gives DIST a very small positive value in case of leaving CM"
      "When collecting phase space immediately below a thin (0.01 cm) layer of"
      "Mylar in a beam, there was a high probability of the calculated"
      "value of USTEP (ie unmodified by HOWFAR) actually putting the particle"
      "right on the back of the mylar layer.  When it came to the next step,"
      "the calculated value of DIST was 0, which meant USTEP was set to 0,"
      "and, as a result, AUSGAB was not called on leaving the CM."
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         IF (IR_TARGET<N_TARGET) ["particle will remain in CM"
            IRNEW = IR(NP)+1; "new region number"
         ]
         ELSE ["particle will enter downstream CM"
            CALL WHERE_AM_I(ICM_TARGET,1); "get IRNEW, ICMNEW"
         ]
      ]
   ]" end of forward going block"
   ELSEIF (W(NP)<0.0) ["particle going backwards"
      "calculate distance to front boundary"
      ZNEAR = Z(NP)-ZFRONT_TARGET(IR_TARGET);
      DIST = -ZNEAR/W(NP); "Direction cosine is negative"
      IF (DIST < 0.) [DIST=0.;] "see reason above"
      IF (DIST=0. & N_GAP_TARGET=0 & IR_TARGET=1)[ DIST=1.E-16;]
      IF(DIST <= USTEP) [
         USTEP = DIST;
         IF (IR_TARGET>1) ["particle will remain in CM"
            IRNEW = IR(NP)-1; "new region number"
         ]
         ELSEIF (IR_TARGET=1 & N_GAP_TARGET=1) ["particle entering air gap"
            IRNEW = IREND_TARGET; "new region number"
         ]
         ELSE ["particle will enter upstream CM"
            CALL WHERE_AM_I(ICM_TARGET,-1); "get IRNEW, ICMNEW"
         ]
      ]
   ]" end of backward going block"
   "if W(NP)=0.0, never hit boundary, need not reset USTEP"
]"end of CM regions"

"   in air gap at top of CM
"   =======================
"
ELSEIF (IR_TARGET=N_TARGET+1 & N_GAP_TARGET=1) ["particle in air gap"
   IF (W(NP)>0.0) ["particle going forward"
      "calculate distance to back boundary"
      ZNEAR = ZFRONT_TARGET(1)-Z(NP);
      DIST = ZNEAR/W(NP);
      IF (DIST < 0.) [DIST=0.;] "See reason above"
      IF(DIST <= USTEP ) ["particle will enter first slab, this CM
         USTEP = DIST;
         IRNEW = IRSTART_TARGET; "new region number"
      ]
   ]" end of forward going block"
   ELSEIF (W(NP)<0.0 ) ["particle going backwards"
      "calculate distance to front boundary"
      ZNEAR = Z(NP)-Z_min_CM(ICM_TARGET);
      DIST = -ZNEAR/W(NP); "Direction cosine is negative"
      IF (DIST <= 0.) [DIST=1.E-16;] "See reason above"
                                     "Always set to small +ve value since"
                                     "we are definitely leaving through top"
      IF(DIST <= USTEP) ["particle will enter upstream CM"
         USTEP = DIST;
         CALL WHERE_AM_I(ICM_TARGET,-1); "get IRNEW, ICMNEW"
      ]
   ]" end of backward going block"
   "if W(NP)=0.0, never hit boundary, need not reset USTEP"
]"end of air-gap region"

"   outside of CM, something is wrong
"   =================================
"
ELSE ["something is wrong"
   OUTPUT IR(NP)-IRSTART_TARGET+1, IR(NP), ICM_TARGET,
      IR_start_CM(ICM_TARGET); (//' ************'//' HOWFAR_TARGET error'/
      '    Region, local, absolute =',2I5/
      '    CM number=',I5,' start region =',I5/' *********'//);
   STOP;
] "end of IF statement"
RETURN; END; "End of subroutine HOWFAR_SLABS"

%E   "start of subroutine WHERE_AM_I_TARGET"
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_SLABS
"                          ***************************
"
" WHERE_AM_I routine for stacked planar slabs.
"
" WHERE_AM_I_TARGET determines the new region number when a particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_TARGET subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_TARGET from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************

;SUBROUTINE WHERE_AM_I_TARGET(IDIR);


;IMPLICIT NONE;
;COMIN/CM_TARGET,EPCONT,STACK/; "/STACK/would be needed for more complicated
                       "geometries.
"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_SLABS
"T>**************************************
"T>
INTEGER IDIR,I;  "T>direction of particle, +1=forward, -1=backward

IF (IDIR=1) ["particle entering this CM through front face (upstream)
   IF (N_GAP_TARGET=0) ["no air gap this CM"
      IRNEW = IRSTART_TARGET;
   ]
   ELSE ["this CM has an air gap at the front
      IRNEW = IREND_TARGET;
   ]
]
ELSEIF(IDIR=2) ["particle starting within CM"
   IF(N_GAP_TARGET=1 & Z(NP)< ZFRONT_TARGET(1))[
      IRNEW = IREND_TARGET;
   ]
   ELSE[
     IRNEW=IRSTART_TARGET+N_TARGET-1;
     DO I=1,N_TARGET[
      IF(Z(NP)<ZFRONT_TARGET(I)+ZTHICK_TARGET(I))[
          IRNEW=IRSTART_TARGET+I-1;
          EXIT;
      ]
     ]
   ]
]
ELSE ["particle entering this CM through back face (downstream)
   IRNEW = IRSTART_TARGET+N_TARGET-1;
]
RETURN;
END; "End of subroutine WHERE_AM_I_SLABS"

%E  "start of subroutine HOWNEAR_TARGET"
"*****************************************************************************
"
"                        Subroutine HOWNEAR_TARGET
"                        *************************
"
" Returns min. distance to nearest region boundary.  Used to be a macro, but
" now the the macro calls this subroutine.
"
"*****************************************************************************

;SUBROUTINE HOWNEAR_TARGET(DIST);

$IMPLICIT-NONE;

COMIN/CM_TARGET,STACK,CMs/;

$REAL DIST; "T> min. distance to nearest region boundary

IR_TARGET = IR(NP)-IRSTART_TARGET+1;
IF(IR_TARGET=N_TARGET+1 & N_GAP_TARGET=1)["particle is in air gap"
   DIST=MIN(Z(NP)-Z_min_CM(ICM_TARGET),ZFRONT_TARGET(1)-Z(NP));
]
ELSE["particle is in one of the layers"
   DIST=MIN(Z(NP)-ZFRONT_TARGET(IR_TARGET),
       ZBACK_TARGET(IR_TARGET)-Z(NP));
]
RETURN;
END; "End of subroutine HOWNEAR_TARGET"
"******************************************************************************
"End of SLABS_cm.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: 3-region stacked truncated cones          "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Charlie Ma                                                "
"                   Dave Rogers                                               "
"                   Joanne Treurniet                                          "
"                   Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             **************                 ""toc:
"                             *            *                 ""toc:
"                             *   CONS3R   *                 ""toc:
"                             *            *                 ""toc:
"                             **************                 ""toc:
"
"   History of modifications given by SCCS
"
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.  It is can be used for any case for r symmetry
"   if there are only two region in r direction, e.g, slab, ring, stack rings,
"   cone(primary collimator), cone stack. limit: the first version only can
"   allow the convex shapes in z direction, not the concave shapes, if required,
"   can be changed.
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator: primary collimator
"
%E   "PRIMCOLL_cm   start of geometry description (CONS3R)
"I>
"I> Geometry of PRIMCOLL: (CONS3R)
"I> *********************************
"I>                                        |
"I>                            |           |  beam direction
"I>                            .           |
"I>                            |          \|/
"I>                            .           .
"I>                  ----------------------------------------------
"I>                            |    Air gap IR= 3 if it exists
"I>                  ----------------------------/------------------
"I>                            .                / point 1
"I>                            |       point 2 /
"I>                            .               \ IR = 2
"I>                            |        IR = 1  \  point 3
"I>                            .                /
"I>                                            /
"I>              central axis  |               \ point i-1
"I>                            .                \
"I>                            |                 \ point i
"I>                            .                 /
"I>                            |                / point i+1
"I>                            .                \
"I>                            |                 \
"I>                            .                  \ .....
"I>                            |                  |
"I>                            .                  |
"I>                            |                  |
"I>                            .                  | point n
"I>                  ----------------------------------------------
"I>
"I>
"I>
"I>
"I>   IR is the region number within the CM.  There are three local regions
"I>   shown above.
"I>
"I>
"I>            ------------------------------------------------------
"I>            |             Region            | Description         |
"I>            |-------------------------------|---------------------|
"I>            |  absolute       | local       |                     |
"I>            |-----------------|-------------|                     |
"I>            |                 |             |                     |
"I>            |IRSTART_CONS3R   | IR_CONS3R   |  as shown in above  |
"I>            |  +IR_CONS3R-1   |             |    (1 to 2)         |
"I>            |                 |             |                     |
"I>            |                 |             |                     |
"I>            -------------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_PRIMCOLL
"                      ISUMRY_PRIMCOLL
"                      HOWFAR_PRIMCOLL
"                      WHERE_AM_I_PRIMCOLL
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"
"                             RESTRICTIONS ON USE/BUGS           ""toc:
"                             ************************
"
"
"*******************************************************************************
"*******************************************************************************
"**************************  DESCRIPTION OF VARIABLES  *************************
"*******************************************************************************
"
"                             COMMON BLOCK VARIABLES
"                             **********************
"
"  Refer to the replacement macros in BEAM.MORTRAN and BEAM_COMMON.MORTRAN
"  which define the common block variables.
"
"*******************************************************************************
"
"                                OTHER VARIABLES
"                                ***************
"
"  Refer to the section on type declarations for each subroutine. The following
"  section describes the variables input from unit 5.  These variables define
"  the parameters of each simulation.
"
"*******************************************************************************
"
"                    Description of user input for CONS3R        ""toc:
"                    ************************************        ""toc:
"
"I>
"I>  CARDS CM_PRIMCOLL (CONS3R)
"I>  **************
"I>
"I>   -1 Dummy line to indicate start of CM
"I>
"I>   0  RMAX_CM(ICM_PRIMCOLL) (F10.0):  Outer radial boundary of CM (cm).
"I>
"I>   1  TITLE_PRIMCOLL (60A1):  Title of CM.
"I>
"I>   2  ZMIN_PRIMCOLL (F15.0):  Dist from front of cones to
"I>                             reference plane (Z=0).
"I>
"I>   3  ZTHICK_PRIMCOLL (F15.0): The thickness of cones (excludes front air).
"I>
"I>   4  NUM_NODE_PRIMCOLL (I5):  The # of points to be used <$NPOINT_CONS3R.
"I>
"I>   Repeat 5 for I=1,NUM_NODE_PRIMCOLL
"I>
"I>   5  ZCORNER_PRIMCOLL(I), RCORNER_PRIMCOLL(I) (2F15.0):
"I>        Positions (Z, R) for node I.  First & last must match
"I>        ZMIN_PRIMCOLL and ZMIN_PRIMCOLL+ZTHICK_PRIMCOLL.  Note also the
"I>        restriction Z(I+1) >= Z(I).
"I>
"I>   Repeat 6, 7 for inner (ie inside cons3r), then outer region
"I>
"I>   6  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT, IREJCTIN  (2F15.0,3I5):
"I>
"I>         ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   If non-zero, dose in this zone is scored in this
"I>                      dose zone
"I>         IREGION_TO_BIT:   region to LATCH bit correspondence for particles
"I>                      interacting in this region
"I>         IREJCTIN:    If IREJCT_GLOBAL is on, then by setting IREJCT=-1
"I>                      here, range rejection is turned off in this region
"I>                      If left blank or zero, the global value is used.
"I>
"I>   7  MED_IN (24A1):  Medium of region
"I>                      used to set MED_INDEX.
"I>
"I>
"I>   Example
"I>   *******
"I>
"I>  The following input example describes a 1cm thick flat-top cone, having
"I>  a radius at the top of 0.8cm and a radius at the bottom of 1.2cm
"I>  sitting on a 0.3cm thick cylinder of radius 1.5cm which, in turn,
"I>  is sitting atop a flat-top cone of thickness 1.0cm with top radius
"I>  0.5cm and bottom radius=0.8cm.  The two cones and cylinder are
"I>  made of H2O--note that all of these structures MUST be of the same
"I>  medium--and they are surrounded by AIR.  Dose in the surrounding
"I>  AIR is stored in dose zone 1, and dose in the cones/cylinder
"I>  structure is stored in zone 2.
"I>
"I>  5.0
"I>  example cons3r
"I>  0.0
"I>  2.3
"I>  6
"I>  0.0, 0.8
"I>  1.0, 1.2
"I>  1.0, 1.5
"I>  1.3, 1.5
"I>  1.3, 0.5
"I>  2.3, 0.8
"I>  0.521, 0.01, 2, 0, 0
"I>  H2O
"I>  0.521, 0.01, 1, 0 ,0
"I>  AIR
"I>
"
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules
"
"*******************************************************************************

%E   "CONS3R_cm - start of subroutine HOWFAR_PRIMCOLL
"*******************************************************************************
"*********************** Component Module CONS3R *****************************
"*******************************************************************************
"
"                          Subroutine HOWFAR_PRIMCOLL
"                          ************************
"
" HOWFAR routine for stacked truncated cones
"
" Determine if current region number is within component module CONS3R, if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are N_PRIMCOLL local regions + an air gap (if present):
"
"     local               absolute                       description
"   ----------    ------------------------------   ----------------------
" IR_CONS3R    IR_start_CM(ICM_CONS3R)+IR_CONS3R-1 excluding front air gap
"   ----------    ------------------------------   -----------------------
"   Geometrical co-ordinates, as set in INPUT_CONS3R are:
"
"   ZFRONT_PRIMCOLL     front of CM (upstream surface, air region)
"   ZMIN_PRIMCOLL       front of CM
"   ZBACK_PRIMCOLL      back of CM
"   RMIN_PRIMCOLL       smallest radius of the module
"
"******************************************************************************

;SUBROUTINE HOWFAR_PRIMCOLL;


"The following macros are used for boundary crossing. The particle is
"shifted by 1.0E-5 at the end of a step to overcome possible numerical errors
"V>$GEO_SHIFT_1_(#)
"V>=============
"V>{p1} the value to compare with ustep
"V> if {p1}+1.0e-5 < ustep shift it, otherwise no shift
;
REPLACE {$GEO_SHIFT_1_(#)} WITH {
; IF({P1}+1.0E-5< USTEP) [{P1}={P1}+1.0E-5;]  }

"V>$GEO_SHIFT_2_(#,#)
"V>=============
"V>{p1} the value to compare with {P2}
"V> if {p1}+1.0e-5 < {P2} shift it, otherwise no shift
;
REPLACE {$GEO_SHIFT_2_(#,#)} WITH {
; IF({P1}+1.0E-5< {P2}) [{P1}={P1}+1.0E-5;]  }

;IMPLICIT NONE;
;COMIN/ CMs,CM_PRIMCOLL,EPCONT,STACK,EGS-IO/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_CONS3R
"T>**********************************
"T>
INTEGER
   IRL,        "T>local region number (absolute), required by HOWNEAR macro
   I, J, K,    "T>loop control
   IU_D,       "T>to indicate the relations bet ustep and dist
   DIRTMP;     "T>temp variable for use as direction indicator in macros

$REAL
   DIST,         "T>farthest distance to z boundary along current trajectory
   DIST_TMP,     "T>distance to z boundary along current particle trajectory
   RF_PRIMCOLL,   "T>temporary variable
   RF2_PRIMCOLL,  "T>temporary variable
   R0SQ,         "T>temporary init position of the particle in x-y plane
   R0DELR,       "T>temporary variable for vec r dot vec delta r
   DELRSQ,       "T>temporary variables for the sq of delta r
   RV_PRIMCOLL,   "T>temporary variable  for the r
   RV2_PRIMCOLL,  "T>temporary variable  for the r
   CRITERIOR_IR,
   R0SQ_2,CRITERIOR_IR_2,  "T>used for boundary crossing
   A, B, B2, C, TEMP1, CUT_COE1, CUT_COE2, CUT_COE,STEP_UNIT, STEP_UNITOLD,
                 "T>temporary variables used for quadratic eq.
   XPLN,YPLN,ZPLN;   "T>temp variable for storing x,y,z after planned step

$REAL one;
parameter (one = 1);

" Determine local region number
" *****************************
IRL = IR(NP); "local region number (absolute)
IR_PRIMCOLL = IRL - IRSTART_PRIMCOLL + 1;   "local region number( relative )

" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module CONS3R,if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
;
R0SQ=X(NP)**2+Y(NP)**2;
STEP_UNIT=0.0;
STEP_UNITOLD=0.0;  " this one will be used to control the cut_coe in the loop

" the following block double check:
"=================================
"      1. the particle is out of the CM oe regions in z direction
"      2.                        the regions in r directions
"     if so reset the ir #, and print out the warning message.
"comment: this block is not time consumming, can be kept in the final version
"=======
"
"  now do the air gap check if existed.
"=====================================

IF(N_GAP_PRIMCOLL = 1 & IR_PRIMCOLL = 3 ) "  check the air gap first
[
   IF(W(NP)>0.0)
   ["particle going forward"
      DIST = (ZMIN_PRIMCOLL - Z(NP))/W(NP); "distance to front of CM
      IF(DIST < 0.0)
      [ " particle going forward"
          USTEP = 0.;
          IF( R0SQ<RCORNER2_PRIMCOLL(1) )
          [  IRNEW =IRSTART_PRIMCOLL; RETURN;]
          ELSE[IRNEW =IRSTART_PRIMCOLL+1; RETURN;]
      ] " double check if a particle is out of the AIR GAP

   ]
   ELSEIF(W(NP)<0.0)
   [ " particle going backward"
      DIST = (ZFRONT_PRIMCOLL - Z(NP))/W(NP); "distance to front of CM
      IF(DIST <= 0.0)
      [
          USTEP=1.e-16; "ensures call to ausgab for crossing CM boundary"
          CALL WHERE_AM_I(ICM_PRIMCOLL,-1);
          RETURN;
      ] " double check if a particle is out of the CM
   ]
]
ELSEIF(IR_PRIMCOLL=1 | IR_PRIMCOLL=2)  " in the local region 1 or 2
[
   IF(W(NP) > 0.0)
   [  "particle going forward"
      DIST = (ZMAX_PRIMCOLL - Z(NP))/W(NP); "distance to back of CM
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <=0.0)
      [
          USTEP=1.e-16;
          CALL WHERE_AM_I(ICM_PRIMCOLL,1);
          RETURN;
      ] " double check if a particle is out of the CM
   ]
   ELSEIF(W(NP) < 0.0)
   [  "particle going backward"
      DIST = (ZMIN_PRIMCOLL - Z(NP))/W(NP); "distance to back of CM "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.)
      [
          IF(N_GAP_PRIMCOLL = 1)
          [ USTEP=0.; IRNEW =IREND_PRIMCOLL; RETURN; ]
          ELSE[ USTEP=1.e-16; CALL WHERE_AM_I(ICM_PRIMCOLL,-1); RETURN; ]
      ] " double check if a particle is out of the main body to air gap
   ]
]

" end of z direction check
"=========================


" now do the check in r direction
"================================
"Note: in some unusual cases, if the particle z(np)=zcorner_CONS3R(i),
"      the folloing block may print out the error message, but it is not an
"      error!!

IF(IR_PRIMCOLL=1 |IR_PRIMCOLL=2 )[
      IF(W(NP)>=0.0)[
          DO I=1, NUM_NODE_PRIMCOLL[IF(Z(NP)<ZCORNER_PRIMCOLL(I))[EXIT;] ]
          J=I-1;
"         it will never happen j=i-1=num_node_CONS3R
      ]
      ELSE[
          DO I=NUM_NODE_PRIMCOLL,1,-1[IF(Z(NP)>ZCORNER_PRIMCOLL(I))[EXIT;]]
          J=I;
"         it will never happen j=i=0
      ]
      IF(SURPARA_PRIMCOLL(J,4)<1.0E29)[
        "SURPARA_PRIMCOLL(i,1)*R+SURPARA_PRIMCOLL(i,2)*Z+SURPARA_PRIMCOLL(i,3)=0
        IF(COUNT1_PRIMCOLL>0)[
           CRITERIOR_IR=CRITOLD_PRIMCOLL;
        ]
        ELSE[
           CRITERIOR_IR=SQRT(R0SQ)-(RCORNER_PRIMCOLL(J)
             +SURPARA_PRIMCOLL(J,4)*(Z(NP)-ZCORNER_PRIMCOLL(J)));
        ]

" the following block is used to control the unusual case, if the particle
" cannot find the right region, it will be discarded and print the warning
" message!!!!!!
"=============================

        IF(CRITERIOR_IR>0.0 & IR_PRIMCOLL =1 )[
           "The particle is in the wrong region"
           "following stmt used to be USTEP=1e-5 but this causes"
           "problems for low energy electrons where this is > range"
           "so now we just set USTEP=1e-5 if requested USTEP is"
           "longer, otherwise we leave it at the electr determined USTEP"
           "Bug reported by Joanne Moseley and Jeff Chen of London"
           "regional Cancer center, Dec 1995"
           IF(USTEP >= 1.0E-5 | USTEP = 0) USTEP=1.0E-5;
           XPLN=X(NP)+U(NP)*USTEP;
           YPLN=Y(NP)+V(NP)*USTEP;
           ZPLN=Z(NP)+W(NP)*USTEP; "found necessary for roundoff errors"
           R0SQ_2=XPLN**2 + YPLN**2;
           IF(W(NP)>=0.0)[
             DO I=1, NUM_NODE_PRIMCOLL[
                IF(ZPLN<ZCORNER_PRIMCOLL(I))[EXIT;]
             ]
             K=I-1;
           ]
           ELSE[
             DO I=NUM_NODE_PRIMCOLL,1,-1[
                IF(ZPLN>ZCORNER_PRIMCOLL(I))[EXIT;]
             ]
             K=I;
           ]
           CRITERIOR_IR_2=SQRT(R0SQ_2)-(RCORNER_PRIMCOLL(K)+
                         SURPARA_PRIMCOLL(K,4)*(ZPLN-ZCORNER_PRIMCOLL(K)));
           IF(CRITERIOR_IR_2>0.0)[
              IRNEW=IRSTART_PRIMCOLL+1;
           ]
           ELSE[
              IRNEW=IRSTART_PRIMCOLL;
           ]
           COUNT1_PRIMCOLL=COUNT1_PRIMCOLL+1;
           IF(COUNT1_PRIMCOLL>100)[
              OUTPUT X(NP),Y(NP),X(NP)**2+Y(NP)**2,Z(NP),U(NP),
                 V(NP),W(NP),E(NP),IQ(NP);
                 (/' WARNING FROM CONS3R (PRIMCOLL):',
                   ' TAKEN USTEP = 1.0E-5 FOR 100 TIMES, '/
                   ' BUT THE PARTICLE STILL ENDS UP IN THE WRONG REGION'/
                   ' (ie INSIDE CONE WHEN IT SHOULD BE OUTSIDE OR VICE VERSA)'/
                   ' THE PARTICLE HAS BEEN DISCARDED.'/
                   ' OUTPUT: x,y,r**2,z,u,v,w,E,IQ '/
                    8F11.6,I3);
                 IDISC=1;
                 COUNT1_PRIMCOLL=0;
                 USTEP=0.0;
           ]
           RETURN;
        ]
        ELSEIF(CRITERIOR_IR<0.0 & IR_PRIMCOLL=2 )[
           IF(USTEP >= 1.0E-5 | USTEP = 0) USTEP=1.0E-5;
           XPLN=X(NP)+U(NP)*USTEP;
           YPLN=Y(NP)+V(NP)*USTEP;
           ZPLN=Z(NP)+W(NP)*USTEP; "found necessary for roundoff errors"
           R0SQ_2=XPLN**2 + YPLN**2;
           IF(W(NP)>=0.0)[
             DO I=1, NUM_NODE_PRIMCOLL[
                IF(ZPLN<ZCORNER_PRIMCOLL(I))[EXIT;]
             ]
             K=I-1;
           ]
           ELSE[
             DO I=NUM_NODE_PRIMCOLL,1,-1[
                IF(ZPLN>ZCORNER_PRIMCOLL(I))[EXIT;]
             ]
             K=I;
           ]
           CRITERIOR_IR_2=SQRT(R0SQ_2)-(RCORNER_PRIMCOLL(K)+
                          SURPARA_PRIMCOLL(K,4)*(ZPLN-ZCORNER_PRIMCOLL(K)));
           IF(CRITERIOR_IR_2<0.0)[
              IRNEW=IRSTART_PRIMCOLL;
           ]
           ELSE[
              IRNEW=IRSTART_PRIMCOLL+1;
           ]
           COUNT1_PRIMCOLL=COUNT1_PRIMCOLL+1;
           IF(COUNT1_PRIMCOLL>100)[
              OUTPUT X(NP),Y(NP),X(NP)**2+Y(NP)**2,Z(NP),U(NP),
                 V(NP),W(NP),E(NP),IQ(NP);
                 (/' WARNING FROM CONS3R (PRIMCOLL):',
                   ' TAKEN USTEP = 1.0E-5 FOR 100 TIMES, '/
                   ' BUT THE PARTICLE STILL ENDS UP IN THE WRONG REGION'/
                   ' (ie INSIDE CONE WHEN IT SHOULD BE OUTSIDE OR VICE VERSA)'/
                   ' THE PARTICLE HAS BEEN DISCARDED.'/
                   ' OUTPUT: x,y,r**2,z,u,v,w,E,IQ '/
                    8F11.6,I3);
                 IDISC=1;
                 COUNT1_PRIMCOLL=0;
                 USTEP=0.0;
           ]
           RETURN;
        ]
        ELSE["no problem, reset the error counter"
           COUNT1_PRIMCOLL=0;
        ]
      ]
]


" end of the double check in r direction
"========================================

IF(IR_PRIMCOLL = 1)
[   "local region 1

   RF2_PRIMCOLL=(X(NP)+STEP_UNIT*U(NP))**2+(Y(NP)+STEP_UNIT*V(NP))**2;
   IF(W(NP) > 0.0)
   [
      " do the fast step if possible
      IF(RF2_PRIMCOLL<RMIN2_PRIMCOLL)
      [
            IF(IU_D=0)[ RETURN; ]  " ustep admitted"
            ELSE
            [
                $GEO_SHIFT_1_(STEP_UNIT);
                USTEP=STEP_UNIT;
                CALL WHERE_AM_I(ICM_PRIMCOLL,1); RETURN;
            ]
      ]
      ELSE   " answer the question: hits side wall or not and where ?
      [
           DO J=I-1, NUM_NODE_PRIMCOLL-1
           [ ; PRIMCOLL_MACRO_1_IN(1,ZCORNER_PRIMCOLL(J+1),1); ]
           IF(IU_D=1)
           [
                $GEO_SHIFT_1_(DIST);
                USTEP=DIST;
                CALL WHERE_AM_I(ICM_PRIMCOLL,1);
                RETURN;
           ]
           ELSE[ RETURN; ] " ustep admitted and no region # changed "
       ]
   ]      " end of the w(np) > 0 case   "

   IF(W(NP) < 0.0)
   [  "particle going backward"
      IF(RF2_PRIMCOLL<RMIN2_PRIMCOLL)
      [
            IF(IU_D=0)[ RETURN; ]  " ustep admitted"
            ELSE
            [
               $GEO_SHIFT_1_(STEP_UNIT);
               USTEP=STEP_UNIT;
               IF(N_GAP_PRIMCOLL = 1)
               [ IRNEW =IREND_PRIMCOLL; RETURN; ]
               ELSE[ CALL WHERE_AM_I(ICM_PRIMCOLL,-1); RETURN; ]
            ]
      ]
      ELSE   " answer the question: hits side wall or not and where ?
      [
           DO J=I, 1, -1
           [  ;PRIMCOLL_MACRO_1_IN(1,ZCORNER_PRIMCOLL(J),-1); ]
           IF(IU_D=1)
           [
               $GEO_SHIFT_1_(DIST);
               USTEP=DIST;
               IF(N_GAP_PRIMCOLL = 1)
               [ IRNEW =IREND_PRIMCOLL; RETURN; ]
               ELSE[ CALL WHERE_AM_I(ICM_PRIMCOLL,-1); RETURN; ]
           ]
           ELSE[ RETURN; ] " ustep admitted and no region # changed "
      ]
   ]      " end of the w(np) < 0 case   "

   ELSE   " w(np) = 0 case "
   [
        J=I-1;  " no change in z direction, do not need loop
        RV_PRIMCOLL=RCORNER_PRIMCOLL(J)
               +SURPARA_PRIMCOLL(J,4)*(Z(NP)-ZCORNER_PRIMCOLL(J));
        RV2_PRIMCOLL=RV_PRIMCOLL**2;
        RF2_PRIMCOLL=(X(NP)+USTEP*U(NP))**2+(Y(NP)+USTEP*V(NP))**2;
        IF(RF2_PRIMCOLL<RV2_PRIMCOLL) [ RETURN; ]
                        " ustep admitted , no region # changed "
        ELSE     " solve the equ to get the max ustep  "
        [
           R0DELR=X(NP)*U(NP)+Y(NP)*V(NP);
           DELRSQ=U(NP)*U(NP)+V(NP)*V(NP);
           CUT_COE=(SQRT(R0DELR*R0DELR+DELRSQ*(RV2_PRIMCOLL-R0SQ))-R0DELR)/
                   DELRSQ;
           IF(CUT_COE>0.0 & CUT_COE<= USTEP)
           [
               $GEO_SHIFT_1_(CUT_COE);
               USTEP=CUT_COE;
               IRNEW=IRSTART_PRIMCOLL+1;RETURN;
           ]
           ELSE[IRNEW=IRSTART_PRIMCOLL+1; RETURN;]  " ustep admitted "
        ]
   ]   " end of the w(np) =0 case  "
]

ELSEIF(IR_PRIMCOLL = 2)
[ "particle in region 2
   IF(W(NP) > 0.0)
   [  "particle going forward"
       " answer the question: hits side wall or not and where ?
      DO J=I-1, NUM_NODE_PRIMCOLL-1
      [  ;PRIMCOLL_MACRO_1_OUT(0,ZCORNER_PRIMCOLL(J+1),1);  ]
      IF(IU_D=1)
      [
          $GEO_SHIFT_1_(DIST);
          USTEP=DIST;
          CALL WHERE_AM_I(ICM_PRIMCOLL,1);
          RETURN;
      ]
      ELSE[ RETURN; ] " ustep admitted and no region # changed "
   ]      " end of the w(np) > 0 case   "

   IF(W(NP) < 0.0) [  "particle going backward"
      DO J=I, 1, -1
      [  ;PRIMCOLL_MACRO_1_OUT(0,ZCORNER_PRIMCOLL(J),-1);  ]
      IF(IU_D=1)
      [
         $GEO_SHIFT_1_(DIST);
         USTEP=DIST;
         IF(N_GAP_PRIMCOLL = 1)
         [ IRNEW =IREND_PRIMCOLL; RETURN; ]
         ELSE[ CALL WHERE_AM_I(ICM_PRIMCOLL,-1); RETURN; ]
      ]
      ELSE[ RETURN; ] " ustep admitted and no region # changed "
   ]      " end of the w(np) < 0 case   "

   ELSE   " w(np) = 0 case "
   [
        J=I-1;
        RV_PRIMCOLL=RCORNER_PRIMCOLL(J)
               +SURPARA_PRIMCOLL(J,4)*(Z(NP)-ZCORNER_PRIMCOLL(J));
        RV2_PRIMCOLL=RV_PRIMCOLL**2;
        " solve the equ to get the max ustep  "
        R0DELR=X(NP)*U(NP)+Y(NP)*V(NP);
        DELRSQ=U(NP)*U(NP)+V(NP)*V(NP);
        IF (R0DELR*R0DELR+DELRSQ*(RV2_PRIMCOLL-R0SQ) < 0.) [RETURN;]
        CUT_COE=(-SQRT(R0DELR*R0DELR+DELRSQ*(RV2_PRIMCOLL-R0SQ))-R0DELR)/
                   DELRSQ;
        IF(CUT_COE>0.0 & CUT_COE<= USTEP)
        [
          $GEO_SHIFT_1_(CUT_COE);
          USTEP=CUT_COE;
          IRNEW = IRSTART_PRIMCOLL; RETURN;
        ]
          ELSE[ RETURN;]   " USTEP ADMITTED
    ]   " end of the w(np) =0 case  "
]


ELSEIF(IR_PRIMCOLL = 3)
["particle in region 3
   IF(W(NP) > 0.0)
   ["particle going backward"
      IF(DIST <= USTEP )
      ["particle to be moved to region boundary
         $GEO_SHIFT_1_(DIST);
         USTEP = DIST;
         IF( ( (X(NP)+DIST*U(NP))**2+(Y(NP)+DIST*V(NP))**2)
             <=RCORNER2_PRIMCOLL(1) )
         [  IRNEW =IRSTART_PRIMCOLL; RETURN;]
         ELSE[IRNEW =IRSTART_PRIMCOLL+1; RETURN;]

      ] "end of particle going forward
      ELSE[ RETURN;]
   ]
   ELSEIF(W(NP) < 0.0)
   ["particle going backward"
      IF(DIST <= USTEP )
      ["particle to be moved to region boundary
         $GEO_SHIFT_1_(DIST);
         USTEP = DIST;
         CALL WHERE_AM_I(ICM_PRIMCOLL,-1);
         RETURN;
      ]
      ELSE[RETURN;]
   ] " end of going backward"
] " end of region 3

ELSE
["something is wrong"
   OUTPUT IR(NP)-IRSTART_PRIMCOLL+1, IR(NP), ICM_PRIMCOLL,
          IR_start_CM(ICM_PRIMCOLL);
      (//' ************'//' HOWFAR_PRIMCOLL error'/
         '    Region, local, absolute =',2I5/
         '    CM number=',I5,' start region =',I5/
         ' *********'//);
   STOP;
] "end of IF statement"
RETURN;
END; "End of subroutine HOWFAR_PRIMCOLL"
%E   "CONS3R_cm - start of subroutine WHERE_AM_I_PRIMCOLL"
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_CONS3R
"                          ***************************
"
" WHERE_AM_I_PRIMCOLL determines the new region number when a particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_PRIMCOLL subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_PRIMCOLL from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************

;SUBROUTINE WHERE_AM_I_PRIMCOLL(IDIR);


;IMPLICIT NONE;
;COMIN/CM_PRIMCOLL,EPCONT,STACK/;
"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_CONS3R
"T>**************************************
"T>
INTEGER IDIR;  "T>direction of particle, +1=forward, -1=backward
$REAL XBDY_PRIMCOLL,YBDY_PRIMCOLL,RBDY2_PRIMCOLL;

XBDY_PRIMCOLL = X(NP) + U(NP)*USTEP;      YBDY_PRIMCOLL = Y(NP) + V(NP)*USTEP;
RBDY2_PRIMCOLL = XBDY_PRIMCOLL**2 + YBDY_PRIMCOLL**2;
IF((IRSTART_PRIMCOLL = 2) & (IDIR =1))    " this is first CM and from front
[  RBDY2_PRIMCOLL = X(NP)*X(NP) + Y(NP)*Y(NP); ]
IF (IDIR=1)
["particle entering this CM through front face (upstream)
   IF(N_GAP_PRIMCOLL = 0)
   ["no air gap this CM"
      IF(RBDY2_PRIMCOLL < RCORNER2_PRIMCOLL(1)) [ IRNEW = IRSTART_PRIMCOLL;]
      ELSE[ IRNEW = IRSTART_PRIMCOLL + 1; ]
   ]
   ELSE ["this CM has air gap at front" IRNEW = IREND_PRIMCOLL; ]
]
ELSE
["particle entering this CM through back face (downstream)
   IF(RBDY2_PRIMCOLL < RCORNER2_PRIMCOLL(NUM_NODE_PRIMCOLL))
   [ IRNEW = IRSTART_PRIMCOLL; ]
   ELSE[  IRNEW = IRSTART_PRIMCOLL + 1; ]
]
RETURN;
END; "End of subroutine WHERE_AM_I_PRIMCOLL"
%E   "CONS3R_cm - start of subroutine INPUT_PRIMCOLL"
"*******************************************************************************
"
"                           Subroutine INPUT_CONS3R
"                           **********************
"
"  A CM input subroutine for a series of truncated cones.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_PRIMCOLL;


;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_PRIMCOLL,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;
"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_CONS3R
"T>*********************************
"T>
$REAL ZTHICK_PRIMCOLL;      "T>thickness of  the CM

INTEGER I,J,               "T>DO loop indeces
        IRA,               "T>Absolute region number
        MED_FLAG,          "T>flag used by media-sort macro $MED_INPUT
        MED_INDEX,         "T>medium index, set after medium sort by $MED_INPUT
        IREJCTIN;          "T>possible override of global IREJCT_GLOBAL value
"
"  initialize parameters
"  =====================
"
N_PRIMCOLL = 2;           "No. of regions in CM (if 3,including front air gap)
ICM_PRIMCOLL = ICM;       "CM index for this component module
IRSTART_PRIMCOLL = IR_start_CM(ICM_PRIMCOLL); "Index of first region in this CM,
                                      "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_PRIMCOLL) = 0; "Geometry-checking flag, 0 if no error detected
COUNT1_PRIMCOLL=0; "start of error counter at 0"

"
"  get the title line
"  ==================
"
OUTPUT;(/' PRIMCOLL (CONS3R)');
OUTPUT;(/' This component is a set of stacked cones with 3 regions ')
OUTPUT RMAX_CM(ICM);('    Outer boundary is a cylinder of radius',F12.3,' cm');
IF(ICM = 1)["first CM"
   OUTPUT Z_min_CM(1);
   (' This is first component -- starts at',F10.4,' cm from z=0 ref plane');
]
ELSE["there is another CM upstream"
   OUTPUT Z_min_CM(ICM);(' This CM starts at back of previous CM at',
          F12.5,' cm');
]
OUTPUT;(' TITLE: ',$);
;MINPUT (PRIMCOLL) TITLE_PRIMCOLL;(60A1);
               ";MINPUT is a replacement macro with EOF and
               "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_PRIMCOLL;(' ',60A1); "OUTPUT is a replacement macro which writes to
                             "unit 5.  Used here for echo of user input
OUTPUT Z_min_CM(ICM_PRIMCOLL);
       (' Air gap/front of this  CM starts at:',F10.4, ' cm');
"
" get distance from reference plane, z=0"
"   =============================
OUTPUT;
   (' Distance from front of cones(not air gap) to z = 0.0 plane: ',$);
;MINPUT (PRIMCOLL) ZMIN_PRIMCOLL;(F15.0);
OUTPUT ZMIN_PRIMCOLL;(F15.5);
IF(Z_min_CM(ICM_PRIMCOLL)>ZMIN_PRIMCOLL)[
   IF(ICM_PRIMCOLL=1)[
      OUTPUT ICM_PRIMCOLL, Z_min_CM(ICM_PRIMCOLL),ZMIN_PRIMCOLL;
       (//' ***WARNING IN CM ',I4,' (CONS3R):'/
          ' Z_min_CM(1) > distance to front of cones'/
          ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
      WRITE(IOUTLIST,100)ICM_PRIMCOLL, Z_min_CM(ICM_PRIMCOLL),ZMIN_PRIMCOLL;
100 FORMAT(//' ***WARNING IN CM ',I4,' (CONS3R):'/
          ' Z_min_CM(1) > distance to front of cones'/
          ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
      Z_min_CM(ICM_PRIMCOLL)=ZMIN_PRIMCOLL;
    ]
    ELSE[
      OUTPUT ICM_PRIMCOLL;
       (//'***ERROR IN CM ',I4,' (CONS3R):'/
          'Overlaps with previous CM'//);
      IERR_GEOM(ICM_PRIMCOLL)=IERR_GEOM(ICM_PRIMCOLL)+1;
    ]
]
"
"   get  CONS3R geometry information
"   =================================
"
OUTPUT; (' CONS3R total thickness (in cm, excluding front air): ',$);
;MINPUT (PRIMCOLL) ZTHICK_PRIMCOLL; (F15.0);
OUTPUT ZTHICK_PRIMCOLL; (F15.5);
IF(ZTHICK_PRIMCOLL<0.0)[
    OUTPUT ICM_PRIMCOLL;(//'***ERROR IN CM ',I4,' (CONS3R):'/
                          'ZTHICK < 0.0'//);
    IERR_GEOM(ICM_PRIMCOLL)=IERR_GEOM(ICM_PRIMCOLL)+1;
]
OUTPUT $NPOINT_PRIMCOLL +1;
  (' INPUT THE # OF NODES (VERTICES) DEFINING THE CONES ' /
   ' (1 < # NODES < ',I4,'):',$);
   ;MINPUT (PRIMCOLL) NUM_NODE_PRIMCOLL; (I5);
   OUTPUT NUM_NODE_PRIMCOLL; (I5);
IF(NUM_NODE_PRIMCOLL > $NPOINT_PRIMCOLL) [
     OUTPUT ICM_PRIMCOLL, $NPOINT_PRIMCOLL;
           (//'***ERROR IN CM ',I4,' (CONS3R):'/
              '# of nodes input > max. # of nodes allowed',/
              '# of nodes reduced to ',I4,' for now'//);
     NUM_NODE_PRIMCOLL=$NPOINT_PRIMCOLL;
     IERR_GEOM(ICM_PRIMCOLL)=IERR_GEOM(ICM_PRIMCOLL)+1;
]
ELSEIF(NUM_NODE_PRIMCOLL < 2)[
     OUTPUT ICM_PRIMCOLL; (//'***ERROR IN CM ',I4,' (CONS3R):'/
                            '# nodes input < 2',/
                            '# of nodes set to 2 for now'//);
     NUM_NODE_PRIMCOLL=2;
     IERR_GEOM(ICM_PRIMCOLL)=IERR_GEOM(ICM_PRIMCOLL)+1;
]
;OUTPUT NUM_NODE_PRIMCOLL;
(' INPUT THE  COORDINATES PAIRS (Z, R) FOR ', I5, ' NODES, ONE PAIR/LINE'/
 ' RECALL THAT Z(i+1) >= Z(i)');
DO I=1,NUM_NODE_PRIMCOLL
[
    OUTPUT I;(' INPUT COORDINATES OF NODE',I3, ' AS Z, R: ', $);
    ;MINPUT (PRIMCOLL) ZCORNER_PRIMCOLL(I), RCORNER_PRIMCOLL(I); (2F15.0);
     OUTPUT ZCORNER_PRIMCOLL(I), RCORNER_PRIMCOLL(I); (2F15.5);
     IF(  ZCORNER_PRIMCOLL(1)~=ZMIN_PRIMCOLL)[
        "this is done each time but who cares"
        OUTPUT ICM_PRIMCOLL, ZMIN_PRIMCOLL,ZCORNER_PRIMCOLL(1);
     (//' ***WARNING IN CM ',I4,' (CONS3R):'/
     ' Z(1) must =',F15.5,' cm so value changed '/
     ' from',F15.5,' cm'//);
     WRITE(IOUTLIST,101)ICM_PRIMCOLL,ZMIN_PRIMCOLL,ZCORNER_PRIMCOLL(1);
   101 FORMAT(//' ***WARNING IN CM ',I4,' (CONS3R):'/
     ' Z(1) must =',F15.5,' cm so value changed '/
     ' from',F15.5,' cm'//);
      ZCORNER_PRIMCOLL(1)=ZMIN_PRIMCOLL;
     ]
     IF(I>1)[
       IF(ZCORNER_PRIMCOLL(I-1)>ZCORNER_PRIMCOLL(I))[
          OUTPUT ICM_PRIMCOLL, I, I-1; (//'***ERROR IN CM ',I4,' (CONS3R):'/
                                 'Z(',I4,') < Z(',I4,')'//);
          IERR_GEOM(ICM_PRIMCOLL)=IERR_GEOM(ICM_PRIMCOLL)+1;
       ]
     ]
     IF (RCORNER_PRIMCOLL(I) > RMAX_CM(ICM_PRIMCOLL))[
        OUTPUT ICM_PRIMCOLL, I; (//'***WARNING IN CM ',I4,' (CONS3R):'/
                               'R(',I4,') > RMAX_CM'//);
        WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (CONS3R):''/
                              ''R('',I4,'') > RMAX_CM''//)')
                         ICM_PRIMCOLL, I;
     ]
]
IF(ZCORNER_PRIMCOLL(NUM_NODE_PRIMCOLL)~=ZMIN_PRIMCOLL+ZTHICK_PRIMCOLL)[
   IF(ABS(ZCORNER_PRIMCOLL(NUM_NODE_PRIMCOLL) - (ZMIN_PRIMCOLL+ZTHICK_PRIMCOLL))
          > 0.001) ["Print message if significant only"
       OUTPUT ICM_PRIMCOLL, ZMIN_PRIMCOLL+ZTHICK_PRIMCOLL,
          ZCORNER_PRIMCOLL(NUM_NODE_PRIMCOLL);
       (//' ***WARNING IN CM ',I4,' (CONS3R):'/
        ' Last Z must =',F15.5,' cm, so value changed'/
        ' from',F15.5,' cm'//);
       WRITE(IOUTLIST,102)ICM_PRIMCOLL, ZMIN_PRIMCOLL+ZTHICK_PRIMCOLL,
                      ZCORNER_PRIMCOLL(NUM_NODE_PRIMCOLL);
       102 FORMAT(//' ***WARNING IN CM ',I4,' (CONS3R):'/
            ' Last Z must =',F15.5,' cm, so value changed'/
            ' from',F15.5,' cm'//);
   ]
   ZCORNER_PRIMCOLL(NUM_NODE_PRIMCOLL) =  ZMIN_PRIMCOLL+ZTHICK_PRIMCOLL;
]
IF(   ZCORNER_PRIMCOLL(1)=ZCORNER_PRIMCOLL(2)
    | ZCORNER_PRIMCOLL(NUM_NODE_PRIMCOLL)=ZCORNER_PRIMCOLL(NUM_NODE_PRIMCOLL-1))
[  OUTPUT; (/ 1X,79('*')/' NOTE: the input is not economical because of',
      ' 0 thickness regions, please, rearrange it for next run'
      / 1X,79('*'));
]
DO I=1,NUM_NODE_PRIMCOLL [ "no negative radius allowed"
   RCORNER_PRIMCOLL(I)=ABS(RCORNER_PRIMCOLL(I));
]

" get the smallest radius "
RMIN_PRIMCOLL=RCORNER_PRIMCOLL(1);
DO I=2,NUM_NODE_PRIMCOLL [
   RMIN_PRIMCOLL=MIN(RCORNER_PRIMCOLL(I),RMIN_PRIMCOLL);
]
RMIN2_PRIMCOLL=RMIN_PRIMCOLL**2;

"
"   get ECUT, PCUT, dose scoring zone, LATCH correspondences,
"       IREJCT overrides, material in each region
"   ===============================================================
IRA = IRSTART_PRIMCOLL-1;
OUTPUT;(/' For this CM, the inner region is 1, the outer 2');
DO IR_PRIMCOLL = 1,N_PRIMCOLL["loop through regions to get information"
   IRA = IRA+1;
   ;OUTPUT IR_PRIMCOLL,IREJCT_GLOBAL;(' For region',I3,/' ECUT, PCUT(MeV),',
         ' DOSE ZONE (0=> NO DOSE), IREGION_TO_BIT, IREJCT(0=>',I2,
         ' -1=>0)' /' : ',$);
   ;MINPUT (PRIMCOLL) ECUT(IRA), PCUT(IRA), DOSE_ZONE(IRA),
           IREGION_TO_BIT(IRA),IREJCTIN; (2F15.0,3I5);
   IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
   IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
   IF(IREJCTIN < 0) [IREJCT(IRA) = 0; "ie can only force it from 1 to 0"]
     OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
            IREGION_TO_BIT(IRA),IREJCTIN; (2F15.5,3I10);
     OUTPUT IR_PRIMCOLL;(' material of region ',I3,' ',$);
     ;$MED_INPUT(PRIMCOLL); "input character array MED_IN from unit 5,loops
     "through array MEDIA(24,I) to check if medium was previously input.
     "If so, sets MED_INDEX to index of previous medium.  If not,
     "increments NMED and sets MED_INDEX to NMED.
     MED(IRA) = MED_INDEX; " medium of the planar slab
] "end of loop over IR_PRIMCOLL"

"
"  parameter definition
"  ====================
"
" define the geometry here:
ZMAX_PRIMCOLL = ZMIN_PRIMCOLL + ZTHICK_PRIMCOLL;

" To calc. the parameters for cone surfaces "
DO I=1, NUM_NODE_PRIMCOLL-1
[
    IF(ZCORNER_PRIMCOLL(I)=ZCORNER_PRIMCOLL(I+1))  " parallel to the xy plane
    [
         SURPARA_PRIMCOLL(I,4)=1.0E30;
         SURPARA_PRIMCOLL(I,1)=0.0;
         SURPARA_PRIMCOLL(I,2)=-1.0;
         SURPARA_PRIMCOLL(I,3)=ZCORNER_PRIMCOLL(I);
    ]
    ELSE
    [
         SURPARA_PRIMCOLL(I,4)=(RCORNER_PRIMCOLL(I+1)-RCORNER_PRIMCOLL(I))
            /(ZCORNER_PRIMCOLL(I+1)-ZCORNER_PRIMCOLL(I));
         SURPARA_PRIMCOLL(I,1)= 1.0/SQRT(1.0+SURPARA_PRIMCOLL(I,4)**2);
         SURPARA_PRIMCOLL(I,2)=
              -SURPARA_PRIMCOLL(I,4)/ SQRT(1.0+SURPARA_PRIMCOLL(I,4)**2);
         SURPARA_PRIMCOLL(I,3)=
              (SURPARA_PRIMCOLL(I,4)*ZCORNER_PRIMCOLL(I)-RCORNER_PRIMCOLL(I))
                         /SQRT(1.0+SURPARA_PRIMCOLL(I,4)**2);
    ]
]

DO I=1,NUM_NODE_PRIMCOLL [
   RCORNER2_PRIMCOLL(I)=RCORNER_PRIMCOLL(I)**2;
]

ZFRONT_PRIMCOLL = Z_min_CM(ICM_PRIMCOLL);
"
"establish start of next CM
Z_min_CM(ICM_PRIMCOLL+1) = ZMAX_PRIMCOLL;
"
"  set up the air gap, if present
"  =========================================
"
"  The air gap has the highest region number in the CM, even though it is at
"  the top of the component module.  This is to allow the assignment of region
"  numbers on input of the parameters of each local region (mainly to assign the
"  medium number of the region).  The air gap is then assigned after all of the
"  CM parameters have been input.
"
"note that if this is the first CM (ICM_PRIMCOLL=1) then the gap thickness
"Z_gap_THICK(ICM_PRIMCOLL) = 0, which is used as a flag that there is no air gap

Z_gap_THICK(ICM_PRIMCOLL) = ZMIN_PRIMCOLL - Z_min_CM(ICM_PRIMCOLL);
IF (Z_gap_THICK(ICM_PRIMCOLL) < = 0.0)
[
   Z_gap_THICK(ICM_PRIMCOLL) = 0.;
   N_GAP_PRIMCOLL = 0; "no air gap for this CM
]
ELSE
[
   N_GAP_PRIMCOLL = 1; "this CM has an air gap
   IRA = IRSTART_PRIMCOLL+N_PRIMCOLL; "absolute region number of air gap
   MED(IRA) = AIR_INDEX; "medium is nominal air
   ESAVE(IRA)=ESAVE_GLOBAL;
   ECUT(IRA)=ECUTIN;
   PCUT(IRA)=PCUTIN;
   ECUTRR(IRA)=ECUT(IRA);
]
"
"  set up region numbers
"  =====================
"
"  This CM has N_CONS3R+N_GAP_PRIMCOLL regions
"
;
IREND_PRIMCOLL = (IRSTART_PRIMCOLL -1) +N_PRIMCOLL+N_GAP_PRIMCOLL;
             "Index of last region
NREG = NREG+N_PRIMCOLL+N_GAP_PRIMCOLL;  "Total number of regions in geometry up
                                "to and including this CM
IF (NREG <= $MXREG) [IR_start_CM(ICM_PRIMCOLL+1) = IREND_PRIMCOLL+1; ]
                       "have not exceeded maximum region number
                       "Index of first region in next CM:"
ELSE [
      OUTPUT ICM_PRIMCOLL,NREG,$MXREG;
      (//'***ERROR IN CM ',I4,' (CONS3R):'/
         I4,' regions requested, only ',I4,' available');
      IERR_GEOM(ICM_PRIMCOLL)=IERR_GEOM(ICM_PRIMCOLL)+1;
]
"
"  establish CM boundary
"  =====================
RMAX_CM_FLAG(ICM_PRIMCOLL) = 1; "put a circular boundary about CM
"
"  establish dose-scoring zones and bit setting for each region
"  ===========================================================================
"
IRA = IRSTART_PRIMCOLL-1; "absolute region number"
DO IR_PRIMCOLL=1,N_PRIMCOLL
["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT); " current maxmum
   "charged particle range rejection parameters
   "
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region
   E_min_out(ICM_PRIMCOLL)=ECUT(IRA); "Minimum energy on exit from CM

] "end of loop over IR_PRIMCOLL

"   return from INPUT_CONS3R
"   =======================
"
RETURN;

"   error messages
"   ==============
"
:EOF_PRIMCOLL:
;OUTPUT ICM;
  (//' *** ERROR *** unexpected end of file reading input for CONS3R--CM',I3);
STOP;

:ERROR_PRIMCOLL:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CONS3R--CM',I3);
STOP;

END;  "End of subroutine INPUT_PRIMCOLL"
%E   "CONS3R_cm - start of subroutine ISUMRY_PRIMCOLL"
"*******************************************************************************
"
"                          Subroutine ISUMRY_CONS3R
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_PRIMCOLL;


;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_PRIMCOLL,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_CONS3R
"T>**********************************
"T>
INTEGER
   ICOLOUR,    "T>colour of CM for EGS_Windows
   IRA,        "T>absolute region number
   I,J;        "T>DO loop index
$REAL  VOL_PRIMCOLL(3), PIL;   "T> region volume
"   Mass of dose zone
"   =================
"
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_PRIMCOLL.
"
PIL=3.14159;

"  init. the vol.
/VOL_PRIMCOLL(1),VOL_PRIMCOLL(2),VOL_PRIMCOLL(3)/=0.0; "FOR AIR GAP, IF EXISTs"

" calc. the vol for each region.
IF(N_GAP_PRIMCOLL=1) ["there is an air gap"
    VOL_PRIMCOLL(3)=PIL*(ZMIN_PRIMCOLL-Z_min_CM(ICM_PRIMCOLL))
              *RMAX_CM(ICM_PRIMCOLL)**2;
]
DO I=1, NUM_NODE_PRIMCOLL-1 [
    IF(ZCORNER_PRIMCOLL(I)~=ZCORNER_PRIMCOLL(I+1) )
    [    VOL_PRIMCOLL(1)=VOL_PRIMCOLL(1)+
                 PIL/3.0*(ZCORNER_PRIMCOLL(I+1)-ZCORNER_PRIMCOLL(I))*
                 ( RCORNER_PRIMCOLL(I+1)**2 + RCORNER_PRIMCOLL(I)**2
                 +RCORNER_PRIMCOLL(I+1)*RCORNER_PRIMCOLL(I) );
    ]
]
VOL_PRIMCOLL(2)=PIL*(ZMAX_PRIMCOLL-ZMIN_PRIMCOLL)*
                RMAX_CM(ICM_PRIMCOLL)**2-VOL_PRIMCOLL(1);

IRA = IRSTART_PRIMCOLL-1; "absolute region number
DO IR_PRIMCOLL=1,N_PRIMCOLL+N_GAP_PRIMCOLL
["loop over local region number
   IRA = IRA+1;
   IF(DOSE_ZONE(IRA) ~= 0)
   ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+VOL_PRIMCOLL(IR_PRIMCOLL)*RHOR(IRA);
   ]
] "end of loop over IR_PRIMCOLL"

"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"

WRITE(IOUTLIST,110) ICM_PRIMCOLL,TITLE_PRIMCOLL;
WRITE(IOUTLIST,120) Z_min_CM(ICM_PRIMCOLL),RMAX_CM(ICM_PRIMCOLL);
IF(N_GAP_PRIMCOLL~=0)[
         WRITE(IOUTLIST,124) Z_min_CM(ICM_PRIMCOLL),
                             ZCORNER_PRIMCOLL(1)-Z_min_CM(ICM_PRIMCOLL);
]
IRA = IRSTART_PRIMCOLL-1;
WRITE(IOUTLIST,122);
DO I = 1,NUM_NODE_PRIMCOLL[
   WRITE(IOUTLIST,123) I, ZCORNER_PRIMCOLL(I), RCORNER_PRIMCOLL(I);
]
WRITE(IOUTLIST,130);
DO IR_PRIMCOLL=1,N_PRIMCOLL[
   IRA = IRA+1;
   IF(IR_PRIMCOLL=1)[
     IF (MED(IRA)=0)
     ["Medium is vacuum"
      WRITE(IOUTLIST,140) IR_PRIMCOLL,'inside',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
            'V','a','c','u','u','m';
     ]
     ELSE
     ["Medium is not vacuum"
      WRITE(IOUTLIST,140) IR_PRIMCOLL,'inside',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
   ELSEIF(IR_PRIMCOLL=2)[
     IF (MED(IRA)=0)
     ["Medium is vacuum"
      WRITE(IOUTLIST,140) IR_PRIMCOLL,'outside',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         'V','a','c','u','u','m';
     ]
     ELSE
     ["Medium is not vacuum"
      WRITE(IOUTLIST,140) IR_PRIMCOLL,'outside',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
]

IF(N_GAP_PRIMCOLL ~=0)[
   IRA=IRSTART_PRIMCOLL+N_PRIMCOLL;
      WRITE(IOUTLIST,140) IR_PRIMCOLL,'airgap',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      WRITE(IOUTLIST,141)'at top';
]

110 FORMAT(///1X,79('-')/'  Component module',I3,' - stacked truncated',
           ' cones (3 regions CONS3R)'
           /1X,79('-')
           //T5,'Title: ',68A1);
120 FORMAT(/T2,'PRIMCOLL geometry parameters:',
           /T2,'--------------------------',
           /T2,'Distance from front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Radius of outer boundary of CM = ',F15.5,' cm');
122 FORMAT(/T2,'node      Z(cm)     r(cm)');
123 FORMAT(T2,I3,F11.3,F10.3);
124 FORMAT(T2,'There is an airgap which starts at Z=',F8.5,' cm and is ',
           F8.5,' cm thick.');
130 FORMAT(/T2,'PRIMCOLL region parameters:',
           /T2,'-------------------------',
           /T2,'local  location  electron  photon',
           '  range-rejection   dose  bit  medium'
           /T2,'region            cutoff   cutoff',
           '   level     max    zone  set'
           /T2,'                   (MeV)    (MeV)',
           '   (MeV)    (MeV)');

140 FORMAT(T2,I3,4X,A7,F10.3,F9.3,F8.3,F9.3,I6,I5,3X,9A1);
141 FORMAT(T9,A7);


"   Output representation of this component module to file for EGS_Windows
"   ======================================================================

IF(IWATCH = 4 | IZLAST = 2)
[  "Create a graphics file "
        ICOLOUR=4;
        IF(NUM_NODE_PRIMCOLL > 10)
        [ "10 IS THE CURRENT MAX NO OF GROT PTS"
          "THIS IS OK IF THERE ARE LESS THAN 20 PTS; 15 ARE ALLOWED NOW"
          WRITE(IOUTGEOM,201)ICOLOUR,'GROT',0.0,0.0,0.0,0.0,
               (ZCORNER_PRIMCOLL(I),
                RCORNER_PRIMCOLL(I),I=1,10),0.0,0.0;
          WRITE(IOUTGEOM,201)ICOLOUR,'GROT',0.0,0.0,0.0,0.0,
               (ZCORNER_PRIMCOLL(I),
                RCORNER_PRIMCOLL(I),I=10,NUM_NODE_PRIMCOLL),0.0,0.0;
        ] ELSE [
          WRITE(IOUTGEOM,201)ICOLOUR,'GROT',0.0,0.0,0.0,0.0,
               (ZCORNER_PRIMCOLL(I),
               RCORNER_PRIMCOLL(I),I=1,NUM_NODE_PRIMCOLL),0.0,0.0;
        ]
]"End of graphics output"
201   FORMAT(' ',I1,A4,4(F7.2,','),$NPOINT_PRIMCOLL(F7.2,','),
             $NPOINT_PRIMCOLL(F7.2,','));

"   end of ISUMRY_CONS3R
"   ===================
"
;RETURN;
END; "end of subroutine ISUMRY_PRIMCOLL"
%E   "CONS3R_cm - start of subroutine HOWNEAR_PRIMCOLL"
"******************************************************************************
"
"                          Subroutine HOWNEAR_PRIMCOLL
"                          ***********************
"
" Returns min. distance to nearest region boundary
" Used to be a macro, but now the macro calls this subroutine.
"
"*******************************************************************************
;SUBROUTINE HOWNEAR_PRIMCOLL(DIST);

$IMPLICIT-NONE;

COMIN/CM_PRIMCOLL,STACK,CMs/;

$REAL DIST, "T> min. distance to nearest region boundary
      R_PRIMCOLL; "T> stores radial position of particle

$INTEGER I_PRIMCOLL; "T> looping index"

IR_PRIMCOLL = IR(NP) - IRSTART_PRIMCOLL + 1;
R_PRIMCOLL=SQRT(X(NP)**2+Y(NP)**2);
IF(IR_PRIMCOLL = 1) [
    DIST=MIN(   Z(NP)-ZMIN_PRIMCOLL,
                ZMAX_PRIMCOLL-Z(NP),
                RMAX_CM(ICM_PRIMCOLL) -R_PRIMCOLL );
    DO I_PRIMCOLL=1, NUM_NODE_PRIMCOLL-1
     [
       DIST=MIN(DIST, ABS(SURPARA_PRIMCOLL(I_PRIMCOLL,1)*R_PRIMCOLL
            +SURPARA_PRIMCOLL(I_PRIMCOLL,2)*Z(NP)
            +SURPARA_PRIMCOLL(I_PRIMCOLL,3)) );
     ]
]
ELSEIF(IR_PRIMCOLL = 2) [
         DIST=MIN( Z(NP)-ZMIN_PRIMCOLL,ZMAX_PRIMCOLL-Z(NP),
            RMAX_CM(ICM_PRIMCOLL) -R_PRIMCOLL  );
         DO I_PRIMCOLL=1, NUM_NODE_PRIMCOLL-1
         [
            DIST=MIN(DIST, ABS(SURPARA_PRIMCOLL(I_PRIMCOLL,1)*R_PRIMCOLL
               +SURPARA_PRIMCOLL(I_PRIMCOLL,2)*Z(NP)
                +SURPARA_PRIMCOLL(I_PRIMCOLL,3)) );
         ]
]
ELSE [
        DIST=0.0;
]
RETURN;
END; "End of subroutine HOWNEAR_PRIMCOLL"
"*******************************************************************************
"End of CONS3R_cm.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: photon flattening filter                  "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code originally evolved from the FFILTER component module written by  "
"  George Ding, starting in 1992.                                             "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             ************            ""toc:
"                             *          *            ""toc:
"                             * FLATFILT *            ""toc:
"                             *          *            ""toc:
"                             ************            ""toc:
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.  Photon flattering filter (filter geormetry for
"   arbitrary shape and material).
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator: primary collimator
"
"I>
"I> Geometry of FLATFILT:
"I> ********************
"I>                     |
"I>                     |  beam direction (central axis)
"I>                     |
"I>                    \|/
"I>
"I>       --------------------------------------------------------------------
"I>           Air gap IR = Sum(J=1,ISCM_NO)[ISSCM_NO(J) +1] +1 if exists
"I>       --------------------------------------------------------------------
"I>                 /       \         |               |
"I>       ...      / IR = 1  \ IR = 2 |   IR = ...    | IR=ISSCM_NO(1)+1
"I>               /           \       |               |
"I>              /             \      |               |
"I>       ---------------------------------------------------------------------
"I>               \  ....     /      \
"I>       ...      \         /   .... \    IR=Sum(J=1,ISCM_NO)[ISSCM_NO(J) +1]
"I>                 \       /          \
"I>      ----------------------------------------------------------------------

"I>
"I>
"I>  IR is the region number within the CM.
"I>
"I>
"I>            ------------------------------------------------------
"I>            |          Region              |    Description      |
"I>            |------------------------------|---------------------|
"I>            |  absolute      | local       |                     |
"I>            |----------------|-------------|                     |
"I>            |                |             |                     |
"I>            |IRSTART_FLATFILT| IR_FLATFILT |  as shown in above  |
"I>            |  +IR_FLATFILT-1|             |                     |
"I>            |                |             |                     |
"I>            |                |             |                     |
"I>            ------------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_$flatfilt
"                      ISUMRY_$flatfilt
"                      HOWFAR_$flatfilt
"                      WHERE_AM_I_$flatfilt
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS ON USE/KNOWN BUGS
"                             ******************************
;
"*******************************************************************************
"**************************  DESCRIPTION OF VARIABLES  *************************
"*******************************************************************************
"
"                               INPUT FROM UNIT 5          ""toc:
"                               *****************
"
"I>
"I>  CARDS CM_FLATTENF
"I>  ******************
"I>
"I>  -1  Dummy line to indicate start of CM.
"I>
"I>   0  RMAX_CM(ICM_FLATTENF) (F10.0): Radius of outer boundary of CM (cm).
"I>
"I>   1  TITLE_FLATTENF (60A1):  Title of CM.
"I>
"I>   2  ZMIN_FLATTENF (F10.0):  Distance from front of CM (front of
"I>       the first layer) to reference plane (Z=0),
"I>       not including air gap.
"I>
"I>   3  ISCM_NO_FLATTENF (I5): Number of layers.
"I>
"I>   Repeat 4-6 for I=1,ISCM_NO_FLATTENF
"I>
"I>   4  ISSCM_NO_FLATTENF(I), ZTHICK_FLATTENF(I)  (I5,F15.0):
"I>
"I>             ISSCM_NO_FLATTENF(I): # cones in layer I(ex outer region).
"I>             ZTHICK_FLATTENF(I):   Thickness of layer I.
"I>
"I>   Repeat 5 for J=1,ISSCM_NO_FLATTENF(I) all on one line in order
"I>   of increasing cone radius.
"I>
"I>   5  RTOP_FLATTENF(I,J) (F15.0):
"I>             Top radius of cone J in layer I.
"I>             Note restriction: RTOP_FLATTENF(I,J+1)>RTOP_FLATTENF(I,J)
"I>
"I>   Repeat 6 for J=1,ISSCM_NO_FLATTENF(I) all on one line in order
"I>   of increasing cone radius.
"I>
"I>   6  RBOT_FLATTENF(I,J) (F15.0):
"I>             Bottom radius of cone J in layer I.
"I>             Note restriction: RBOT_FLATTENF(I,J+1)>RBOT_FLATTENF(I,J)
"I>
"I>   Repeat 7 and 8 for J=1,ISSCM_NO_FLATTENF(I)+1 for every layer I.
"I>   When J=ISSCM_NO_FLATTENF(I)+1, you are specifying ECUT, PCUT,
"I>   MED_IN, etc. for the region between the outermost cone and RMAX_CM
"I>   in layer I.
"I>
"I>   7  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT  (2F15.0,2I5):
"I>
"I>          ECUT, PCUT:  Cutoff energies for electrons and photons
"I>                       in cone J.
"I>          DOSE_ZONE:   Dose scoring flag for cone J.
"I>       IREGION_TO_BIT: Bit setting for region defined by cone J.
"I>
"I>   8  MED_IN (24A1):  Medium of cone J
"I>                      used to set MED_INDEX.
"I>
"I>   Example
"I>   *******
"I>
"I>  The following example describes a FLATFILT with 2 layers.  The
"I>  RMAX of this FLATFILT is 2cm.  There is no air gap between the
"I>  first layer and the top of the CM.
"I>
"I>  The first layer is 0.3 cm thick and comprises a convex cone made
"I>  of H2O within a concave cone made of PB.  The convex H2O cone has
"I>  a top radius of 0.0cm and a bottom radius of 1.0cm.  The concave PB
"I>  cone has a top radius of 1.5cm and a bottom radius of 1.1cm.
"I>  The region between the outer, concave cone and RMAX_CM is AIR.
"I>  The second layer is also 0.3 cm thick and comprises a single
"I>  cylinder of H2O having radius 1cm (ie top radius=bottom
"I>  radius=1cm).  The region between the outer boundary of this
"I>  cylinder and RMAX_CM (an annular region) is AIR.
"I>
"I>  The dose to the AIR regions is scored in dose zone 1.  The dose
"I>  to H2O regions (the convex cone in the first layer and the cylinder
"I>  in the second layer) is scored in zone 2.  And the dose to PB
"I>  (the concave cone in the first layer) is scored in zone 3.
"I>  ECUT and PCUT for all regions are 0.521 MeV and 0.01 MeV
"I>  respectively.
"I>
"I>  2.00000,               RMAX_CM
"I>  flatfilt
"I>  0.0,                   ZMIN of first layer
"I>  2,                     no. of layers
"I>  2,  0.30,              no. of cones in first layer and thickness
"I>  0.0,1.5,               top radii of cones
"I>  1.0,1.1,               bottom radii of cones
"I>  1, 0.3                 no. of cones in second layer and thickness
"I>  1.0                    top radius of cone
"I>  1.0                    bottom radius of cone
"I>  0.521, 0.01, 2, 0,     ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT
"I>  H2O                    MEDIUM -- for layer 1, cone 1
"I>  0.521, 0.01, 3, 0
"I>  PB                            -- for layer 1, cone 2
"I>  0.521, 0.01, 1, 0
"I>  AIR                           -- for region between cone 2 and RMAX
"I>  0.521, 0.01, 2, 0
"I>  H2O                           -- for layer 2, cone 1
"I>  0.521, 0.01, 1, 0
"I>  AIR                           -- for region between cone 1 and RMAX
"
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules
"

%E "Start of HOWFAR_FLATTENF"
"*******************************************************************************
"
"                          Subroutine HOWFAR_FLATFILT
"                          ***********************
"
" HOWFAR routine for stacked planar media.
"
" Determine if current region number is within component module FLAT, and if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are N_FLATFILT local regions + an air gap (if present):
"
"     local               absolute                       description
"  ----------  -------------------------------------   -----------------------
"  IR_FLATFILT  IR_start_CM(ICM_FLATFILT)+IR_FLATFILT-1  excluding front air gap
"  ----------  -------------------------------------   -----------------------
"   Geometrical co-ordinates, as set in INPUT_FLATFILT are:
"
"   ZFRONT_FLATFILT     front of CM (upstream surface, air region)
"   ZMIN_FLATFILT       front of filter
"   ZBACK_FLATFILT      back of filter
"   RBOT_FLATFILT       radius of last cylinder (largest)
"
"******************************************************************************
;SUBROUTINE HOWFAR_FLATTENF;


;IMPLICIT NONE;
;COMIN/CMs,CM_FLATTENF,EPCONT,STACK,USER,EGS-IO/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_FLATFILT
"T>**********************************
"T>
INTEGER
   IRL,         "T> absolute region number
   IRNEW_FLATTENF,"T>tentative new region number within CM (absolute)
   I,II,        "T> tmp loop index
   I_inside,I_outside; "T> error indices for particles in the wrong cone

$REAL
   DIST,           "T>dist to region boundary along current particle trajectory
   DIST_CIN,       "T>dist to cone boundary along current particle trajectory
   DIST_COU,       "T>dist to cone boundary along current particle trajectory
   XF_FLATTENF,   "T>temperary variable
   YF_FLATTENF,   "T>temperary variable
   SQXY_FLATTENF,
   DIST_PLANE;       "T>stores DIST to a plane when W>0
$REAL             "local tem variables
   ALO_FLATTENF,
   BLO_FLATTENF,
   AUP_FLATTENF,
   CUP_FLATTENF,
   TQ_FLATTENF,
   BUP_FLATTENF,
   DUP_FLATTENF,
   T1_FLATTENF,
   T2_FLATTENF;
;
$REAL one;
parameter (one = 1);

DATA I_inside,I_outside/0,0/;
SAVE I_inside;
SAVE I_outside;
" Determine local region number
" *****************************
IRL=IR(NP);

;FLATTENF_CHECK_OUTSIDE;

" Set DNEAR
" *********
" This replacement macros sets DMIN_FLATTENF as well as defining IR_FLATTENF

;FLATTENF_CM_HOWNEAR(DNEAR(NP));

" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module, and if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
;
IF(IR_FLATTENF <= N_FLATTENF) [   "inside filter"
   IF(W(NP) > 0)[ " when w > 0.0"
      DIST = (ZMAX_FLATTENF(ISCM_FLATTENF)
              - Z(NP))/W(NP);
      DIST_PLANE=DIST;
      IF(DIST < 0.)[DIST=0.;]
      IF(DIST=0. & ISCM_FLATTENF=ISCM_NO_FLATTENF)[DIST=1.E-16;]
      FLATTENF_GET_SQXY(DIST,SQXY_FLATTENF);
      IF(ISCM_FLATTENF < ISCM_NO_FLATTENF)[
         DO II = 1, ISSCM_NO_FLATTENF(ISCM_FLATTENF+1) [
            IF(SQXY_FLATTENF <=
               RTOP_FLATTENF(ISCM_FLATTENF+1,II)**2)[
               IRNEW_FLATTENF = IRSTART_FLATTENF
                       + IR_FLATTENF - IISSC_FLATTENF
                       + ISSCM_NO_FLATTENF(ISCM_FLATTENF) + II;
               EXIT;
            ]
            ELSEIF(SQXY_FLATTENF >
               RTOP_FLATTENF(ISCM_FLATTENF+1,
               ISSCM_NO_FLATTENF(ISCM_FLATTENF+1))**2)[
               IRNEW_FLATTENF  =
                        IRSTART_FLATTENF + IR_FLATTENF
                       - IISSC_FLATTENF + 1
                       + ISSCM_NO_FLATTENF(ISCM_FLATTENF)
                       + ISSCM_NO_FLATTENF(ISCM_FLATTENF+1);
            ]
         ]
      ]
      ELSEIF(ISCM_FLATTENF = ISCM_NO_FLATTENF)[
         IRNEW_FLATTENF = 1;
      ]
      IF(IISSC_FLATTENF > 1)[
         FLATTENF_GET_DICO_OU(ISCM_FLATTENF,IISSC_FLATTENF);
      ]
      IF(IISSC_FLATTENF <= ISSCM_NO_FLATTENF(ISCM_FLATTENF))[
         FLATTENF_GET_DICO_IN(ISCM_FLATTENF,IISSC_FLATTENF);
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IF(IRNEW_FLATTENF = 1 )[ "leaving CM through back"
            CALL WHERE_AM_I(ICM_FLATTENF,1);
         ]
         ELSE [ "still in CM, entering another region
            IRNEW = IRNEW_FLATTENF; "new region number"
         ]
         IF(DIST=DIST_PLANE & IBRSPL=2 & ICM_DBS=ICM_FLATTENF &
            ISCM_FLATTENF+1=ZPLANE_DBS & IQ(NP)~=0 & IPHAT(NP)=NBRSPL)[
             "electron is about to hit splitting plane and is fat"
             IAUSFL(6)=1; "to call ausgab after step"
             ESPLIT_DBS=1; "to do electron splitting"
         ]
      ]
   ]
   ELSEIF(W(NP) < 0)[  "when w < 0.0
      DIST = (ZMIN_FLATTENF(ISCM_FLATTENF)
              - Z(NP))/W(NP);
      IF(DIST < 0.)[DIST=0.;]
      IF(DIST=0. & ISCM_FLATTENF=1 & N_GAP_FLATTENF=0)[DIST=1.E-16;]
     ;FLATTENF_CHECH_DIST1;

      FLATTENF_GET_SQXY(DIST,SQXY_FLATTENF);
      IF(ISCM_FLATTENF > 1)[
         DO II = 1, ISSCM_NO_FLATTENF(ISCM_FLATTENF-1) [
            IF(SQXY_FLATTENF <=
               RBOT_FLATTENF(ISCM_FLATTENF-1,II)**2)[
               IRNEW_FLATTENF  = IRSTART_FLATTENF
                       + IR_FLATTENF - 2- IISSC_FLATTENF
                       - ISSCM_NO_FLATTENF(ISCM_FLATTENF-1) + II;
               EXIT;
            ]
            ELSEIF(SQXY_FLATTENF >
               RBOT_FLATTENF(ISCM_FLATTENF-1,
               ISSCM_NO_FLATTENF(ISCM_FLATTENF-1))**2)[
               IRNEW_FLATTENF = IRSTART_FLATTENF
                       + IR_FLATTENF - 1 - IISSC_FLATTENF;
            ]
         ]
      ]
      ELSEIF(ISCM_FLATTENF = 1 & N_GAP_FLATTENF ~= 0)[
         IRNEW_FLATTENF = IREND_FLATTENF;
      ]
      ELSEIF(ISCM_FLATTENF = 1 & N_GAP_FLATTENF = 0)[
         IRNEW_FLATTENF = 1;
      ]
      IF(IISSC_FLATTENF > 1)[
         FLATTENF_GET_DICO_OU_WLTZ(ISCM_FLATTENF,IISSC_FLATTENF);
        ;FLATTENF_CHECH_DIST2;
      ]
      IF(IISSC_FLATTENF <= ISSCM_NO_FLATTENF(ISCM_FLATTENF))[
         FLATTENF_GET_DICO_IN(ISCM_FLATTENF,IISSC_FLATTENF);
        ;FLATTENF_CHECH_DIST3;
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IF(IRNEW_FLATTENF = 1 )[ "leaving CM through front"
            CALL WHERE_AM_I(ICM_FLATTENF,-1);
         ]
         ELSE [ "still in CM, entering another region
            IRNEW = IRNEW_FLATTENF; "new region number"
         ]
      ]
   ]
   ELSE[  "when w = 0.0"
      DIST = 1E10;
      IF(IISSC_FLATTENF > 1 &
         U(NP)*X(NP) + V(NP)*Y(NP) < 0.0)[
         FLATTENF_GET_DICO_OU(ISCM_FLATTENF,IISSC_FLATTENF);
         IRNEW_FLATTENF = IR(NP) - 1;
      ]
      ELSEIF(IISSC_FLATTENF <= ISSCM_NO_FLATTENF(ISCM_FLATTENF) &
         U(NP)*X(NP) + V(NP)*Y(NP) > 0.0) [
         FLATTENF_GET_DICO_IN(ISCM_FLATTENF,IISSC_FLATTENF);
         IRNEW_FLATTENF = IR(NP) + 1;
      ]
      IF(DIST <= USTEP) ["particle to be moved to region boundary
         USTEP = DIST;
         IRNEW = IRNEW_FLATTENF; "new region number"
      ]
   ]
]


ELSEIF(IR_FLATTENF = N_FLATTENF + 1) [   "in front air gap
   IF(W(NP) > 0.0) ["particle going forward"
      DIST = (ZMIN_FLATTENF(1)
                - Z(NP))/W(NP); "distance to front of SCM
      IF(DIST < 0.)[DIST=0.;]
      DO I = 1, ISSCM_NO_FLATTENF(1)[
         IF((X(NP)+DIST*U(NP))**2 + (Y(NP)+DIST*V(NP))**2 <=
            RTOP_FLATTENF(1,I)**2)[
            IRNEW_FLATTENF = IRSTART_FLATTENF + I -1;
            EXIT;
         ]
         ELSEIF( (X(NP)+DIST*U(NP))**2 + (Y(NP)+DIST*V(NP))**2 >
            RTOP_FLATTENF(1,ISSCM_NO_FLATTENF(1))**2 )[
            IRNEW_FLATTENF = IRSTART_FLATTENF +
                              ISSCM_NO_FLATTENF(1);
         ]
      ]
   ] "end of particle going forward
   ELSEIF(W(NP) < 0.0) ["particle going backward"
      DIST = (ZFRONT_FLATTENF
              - Z(NP))/W(NP); "distance to front of CM
      IF(DIST <= 0.)[DIST=1.e-16;]
      IRNEW_FLATTENF = 1;
   ]" end of going backward"
   ELSE[DIST = 1E10;]

   IF(DIST <= USTEP) ["particle to be moved to region boundary
      USTEP = DIST;
      IF(IRNEW_FLATTENF = 1 )[ "leaving CM through front"
         CALL WHERE_AM_I(ICM_FLATTENF,-1);
      ]
      ELSE [ "still in CM, entering another region
         IRNEW = IRNEW_FLATTENF; "new region number"
      ]
      IF(W(NP)>0.0 & IBRSPL=2 & ICM_DBS=ICM_FLATTENF &
            ZPLANE_DBS=1 & IQ(NP)~=0 & IPHAT(NP)=NBRSPL)[
             "electron is about to hit splitting plane and is fat"
             IAUSFL(6)=1; "to call ausgab after step"
             ESPLIT_DBS=1; "to do electron splitting"
      ]
   ]
] " end of region of air gap
ELSE[
   IDISC = 1;
   IRNEW = 1;
   OUTPUT IR_FLATTENF, Z(NP), SQRT(X(NP)**2+Y(NP)**2);
          (' some thing is wrong IR_FLATTENF, Z ',I5,4F10.4);
]
"   outside of CM, something is wrong
"   =================================
;
;FLATTENF_NEGTIVE_USTEP;
RETURN;
END; "End of subroutine HOWFAR_FLATTENF"

%E "Start of WHERE_AM_I_FLATTENF"
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_FLATFILT
"                          ***************************
"
" WHERE_AM_I routine for a stacked right cylinder slabs.
"
" WHERE_AM_I_$flatfilt determines the new region # when a particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_$flatfilt subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_$flatfilt from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************


REPLACE {$CHECK_FRONT_FLATTENF;} WITH {;
   IF(ABS(Z(NP)+USTEP*W(NP) - ZFRONT_FLATTENF) > $BDY_TOL)[
       OUTPUT Z(NP), Z(NP)+USTEP*W(NP),ZFRONT_FLATTENF,W(NP),USTEP;
          ( ' in front of CM - cons z, z+d*w, zf,w ustep = ', /5F16.8);
   ]
}
REPLACE {$CHECK_BACK_FLATTENF;} WITH {;
   IF(ABS(Z(NP)+USTEP*W(NP) - ZMAX_FLATTENF(ISCM_NO_FLATTENF)) > $BDY_TOL)[
       OUTPUT Z(NP), Z(NP)+USTEP*W(NP),ZMAX_FLATTENF(ISCM_NO_FLATTENF),
           W(NP),USTEP;
          ( ' in back of CM - cons z, z+d*w =, zmax, w ,ustep ', /5F16.8);
   ]

}
;SUBROUTINE WHERE_AM_I_FLATTENF(IDIR);


;IMPLICIT NONE;

;COMIN/CM_FLATTENF,EPCONT,STACK,USER/;
"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_FLATFILT
"T>**** **********************************
"T>
INTEGER IDIR;      "T>direction of particle, +1=forward, -1=backward
INTEGER I,II,         "T>loop indices
        TEMPIR;       "T>keeps track of local region numbers in a loop
$REAL XBDY_FLATTENF,YBDY_FLATTENF,RBDY2_FLATTENF;

XBDY_FLATTENF = X(NP) + U(NP)*USTEP;
YBDY_FLATTENF = Y(NP) + V(NP)*USTEP;
RBDY2_FLATTENF = XBDY_FLATTENF*XBDY_FLATTENF
                + YBDY_FLATTENF*YBDY_FLATTENF;
IF(IRSTART_FLATTENF = 2 & IDIR = 1)[ " this is first CM and from front
   RBDY2_FLATTENF = X(NP)**2 + Y(NP)**2;
]
IF (IDIR=1) ["particle entering this CM through front face
   IF(N_GAP_FLATTENF = 0) ["no air gap this CM"
      IRNEW = IRSTART_FLATTENF;
      DO I = ISSCM_NO_FLATTENF(1),1,-1[
            IF(RBDY2_FLATTENF > RTOP_FLATTENF(1,I)**2)[
               IRNEW = IRSTART_FLATTENF + I;
               EXIT;
            ]
      ]
      IF(IBRSPL=2 & ICM_DBS=ICM_FLATTENF &
            ZPLANE_DBS=1 & IQ(NP)~=0 & IPHAT(NP)=NBRSPL)[
             "electron is about to hit splitting plane and is fat"
             IAUSFL(6)=1; "to call ausgab after step"
             ESPLIT_DBS=1; "to do electron splitting"
     ]
   ]
   ELSE ["this CM has an air gap at the front
      IRNEW = IREND_FLATTENF;
   ]
]
ELSEIF(IDIR=-1) ["particle entering this CM through back face (downstream)
  IRNEW= IRSTART_FLATTENF+ N_FLATTENF -1
         - ISSCM_NO_FLATTENF(ISCM_NO_FLATTENF);
  DO I = ISSCM_NO_FLATTENF(ISCM_NO_FLATTENF),1,-1[
        IF(RBDY2_FLATTENF > RBOT_FLATTENF(ISCM_NO_FLATTENF,I)**2)[
             IRNEW = IRSTART_FLATTENF+ N_FLATTENF -1
                     - ISSCM_NO_FLATTENF(ISCM_NO_FLATTENF) + I;
             EXIT;
        ]
  ]
]
ELSEIF(IDIR=2)["particle originating within the CM (source 3)
  IF(Z(NP)<ZMIN_FLATTENF(1))["in front air gap
     IRNEW = IREND_FLATTENF;
  ]
  ELSE["somewhere within the flatfilt
     TEMPIR=0;
     DO I=1,ISCM_NO_FLATTENF[
        IF(Z(NP) >= ZMIN_FLATTENF(I) & Z(NP) <= ZMAX_FLATTENF(I))[
           DO II=1,ISSCM_NO_FLATTENF(I)+1[
              IF(II<ISSCM_NO_FLATTENF(I)+1)[
                IF(SQRT(X(NP)**2+Y(NP)**2) <=
                   Z(NP)*(RBOT_FLATTENF(I,II)-RTOP_FLATTENF(I,II))/
                       (ZMAX_FLATTENF(I)-ZMIN_FLATTENF(I)) +
                   RTOP_FLATTENF(I,II) - ZMIN_FLATTENF(I)*
                       (RBOT_FLATTENF(I,II)-RTOP_FLATTENF(I,II))/
                       (ZMAX_FLATTENF(I)-ZMIN_FLATTENF(I)))[
                     IRNEW=IRSTART_FLATTENF + TEMPIR +
                           II -1;
                     EXIT;
                ]
              ]
              ELSE[
                IRNEW=IRSTART_FLATTENF + TEMPIR +
                      II -1;
                EXIT;
              ]
           ]
        ]
        ELSE[
           TEMPIR=TEMPIR+ISSCM_NO_FLATTENF(I)+1;
        ]
     ]
  ]
]
RETURN;
END; "End of subroutine WHERE_AM_I_FLATTENF"

%E "Start of INPUT_FLATTENF"
"*******************************************************************************
"
"                           Subroutine INPUT_FLATFILT
"                           **********************
"
"  A CM input subroutine for a series of 2 or more semi-infinite slabs.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_FLATTENF;


;IMPLICIT NONE;

;COMIN/ BOUNDS,CMs,CM_FLATTENF,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;
"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_FLATFILT
"T>*********************************
"T>

$REAL ZTHICK_FLATTENF($MAX_N_SC_FLATTENF),  "T>thickness of the filter
      BDYTOL,               "T>may set differ from $BDY_TOL
      AIRGAPMIN_FLATTENF;  "T>minimum air gap in front and back of CM

INTEGER I,II,III,J,         "T>DO loop indeces
        IRA,                "T>Absolute region number
        MED_FLAG,           "T>flag used by media-sort macro $MED_INPUT
        MED_INDEX;          "T>medium index, set after med sort by $MED_INPUT

"  initialize parameters
"  =====================
"
ICM_FLATTENF = ICM;      "CM index for this component module
IRSTART_FLATTENF = IR_start_CM(ICM_FLATTENF);
            "Index of first region in this CM,
                "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_FLATTENF) = 0; "Geometry-checking flag, 0 if no error detected
AIRGAPMIN_FLATTENF = 0.1; "set a minimum 0.1 cm air gap at front of CM

"
"  get the title line
"  ==================
"
OUTPUT;(/' Next component is a set of conical  slabs'/
' TITLE: ',$);
;MINPUT (FLATTENF) TITLE_FLATTENF;(60A1);
                       ";MINPUT is a replacement macro with EOF and
                       "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_FLATTENF;(' ',60A1);
                        "OUTPUT is a replacement macro which writes to
                        "unit 5.  Used here for echo of user input
"
" get distance from reference plane, z=0"
"   =============================
OUTPUT; (' Z at which FLATFILT (excluding air gap) starts (cm) ',$);
;MINPUT (FLATTENF) ZMIN_FLATTENF(1);(F10.0);
OUTPUT ZMIN_FLATTENF(1);(F15.5);
IF(Z_min_CM(ICM_FLATTENF)>ZMIN_FLATTENF(1))[
   IF(ICM_FLATTENF=1)[
      OUTPUT ICM_FLATTENF, ZMIN_FLATTENF(1),
       Z_min_CM(ICM_FLATTENF);
       (//' ***WARNING IN CM ',I4,' (FLATFILT):'/
          ' Z_min_CM(1) > Z of first layer'/
          ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
      WRITE(IOUTLIST,100)ICM_FLATTENF, ZMIN_FLATTENF(1),
       Z_min_CM(ICM_FLATTENF);
      100 FORMAT(//' ***WARNING IN CM ',I4,' (FLATFILT):'/
          ' Z_min_CM(1) > Z of first layer'/
          ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
      Z_min_CM(ICM_FLATTENF)=ZMIN_FLATTENF(1);
   ]
   ELSE[
      OUTPUT ICM_FLATTENF;
        (//'***ERROR IN CM ',I4,' (FLATFILT):'/
           'Overlaps with previous CM'//);
      IERR_GEOM(ICM_FLATTENF)=IERR_GEOM(ICM_FLATTENF)+1;
   ]
]

ISCM_NO_FLATTENF = $MAX_N_FLATTENF;
            "Maximum number of slab cone permitted
OUTPUT ISCM_NO_FLATTENF;
   (' Number of layers (MINIMUM 1, MAXIMUM',I2,'): ',$);
;MINPUT (FLATTENF) ISCM_NO_FLATTENF; (I5);
OUTPUT ISCM_NO_FLATTENF; (I5);
IF(ISCM_NO_FLATTENF > $MAX_N_FLATTENF)[
   OUTPUT ICM_FLATTENF, $MAX_N_FLATTENF;
      (//'***ERROR IN CM ',I4,' (FLATFILT):'/
         '# of layers > max. layers allowed.'/
         '# of layers reduced to ',I4,' for now.'//);
   ISCM_NO_FLATTENF=$MAX_N_FLATTENF;
   IERR_GEOM(ICM_FLATTENF)=IERR_GEOM(ICM_FLATTENF)+1;
]
ELSEIF(ISCM_NO_FLATTENF<1)[
   ISCM_NO_FLATTENF=1;
   OUTPUT ICM_FLATTENF;
      (//'***ERROR IN CM ',I4,' (FLATFILT):'/
         '# of layers < 1'/
         '# of layers reset to 1 for now.'//);
   IERR_GEOM(ICM_FLATTENF)=IERR_GEOM(ICM_FLATTENF)+1;
]

"   get  each layer's geometry information
"   =================================
DO I = 1, ISCM_NO_FLATTENF[
   ISSCM_NO_FLATTENF(I) = $MAX_N_SC_FLATTENF;
   OUTPUT I;(//' For layer ',I5,' :');
   OUTPUT I,ISSCM_NO_FLATTENF(I);
    (/' Number of coaxial cones in layer',I5,' (Min 1, Max',I2,')',/,
     ' and thickness of this layer: ',$);
   ;MINPUT (FLATTENF) ISSCM_NO_FLATTENF(I),ZTHICK_FLATTENF(I); (I5,F15.0);
   IF(ZTHICK_FLATTENF(I) = 0.0)[ZTHICK_FLATTENF(I) = 2*$BDY_TOL;]
   OUTPUT ISSCM_NO_FLATTENF(I),ZTHICK_FLATTENF(I); (I5,F15.5);
   IF(ISSCM_NO_FLATTENF(I) > $MAX_N_SC_FLATTENF)[
      OUTPUT ICM_FLATTENF,I, $MAX_N_SC_FLATTENF;
         (//'***ERROR IN CM ',I4,' (FLATFILT):'/
            '# of cones in layer ',I4,' > max. allowed.'/
            '# of cones reduced to ',I4,' for now.'//);
      ISSCM_NO_FLATTENF(I)=$MAX_N_SC_FLATTENF;
      IERR_GEOM(ICM_FLATTENF)=IERR_GEOM(ICM_FLATTENF)+1;
   ]
   ELSEIF(ISSCM_NO_FLATTENF(I)<1)[
      ISSCM_NO_FLATTENF(I)=1;
      OUTPUT ICM_FLATTENF,I;
         (//'***ERROR IN CM ',I4,' (FLATFILT):'/
            '# of cones in layer ',I4,' < 1'/
            '# of cones set to 1 for now.'//);
      IERR_GEOM(ICM_FLATTENF)=IERR_GEOM(ICM_FLATTENF)+1;
   ]
   IF(ZTHICK_FLATTENF(I) < 0.0)[
      OUTPUT ICM_FLATTENF,I;
          (//'***ERROR IN CM ',I4,' (FLATFILT):'/
             'ZTHICK(',I4,') < 0.0'//);
      IERR_GEOM(ICM_FLATTENF)=IERR_GEOM(ICM_FLATTENF)+1;
   ]
    OUTPUT I;(/' input top radii of cones in layer',I5,
         /' (on one line in order of increasing radius)'/': ',$);
   ;MINPUT (FLATTENF) (RTOP_FLATTENF(I,J), J=1,ISSCM_NO_FLATTENF(I));
        ($MAX_N_SC_FLATTENF F15.0);
    OUTPUT (RTOP_FLATTENF(I,J), J=1,ISSCM_NO_FLATTENF(I));
          ($MAX_N_SC_FLATTENF F15.5);
    IF(RTOP_FLATTENF(I,1) = 0.0)[RTOP_FLATTENF(I,1) = 3*$BDY_TOL;]
    ELSEIF(RTOP_FLATTENF(I,1) < 0.0)[
       OUTPUT ICM_FLATTENF,I;
          (//'***ERROR IN CM ',I4,' (FLATFILT):'/
             'RTOP(',I4,',1) < 0.0'//);
       IERR_GEOM(ICM_FLATTENF)=IERR_GEOM(ICM_FLATTENF)+1;
    ]
    ELSEIF(RTOP_FLATTENF(I,1) > RMAX_CM(ICM_FLATTENF))[
        OUTPUT ICM_FLATTENF, I;
          (//'***WARNING IN CM ',I4,' (FLATFILT):'/
             'RTOP(',I4,',1) > RMAX_CM'//);
        WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (FLATFILT):''/
             ''RTOP('',I4,'',1) > RMAX_CM''//)')
             ICM_FLATTENF, I;
    ]
    DO II = 2, ISSCM_NO_FLATTENF(I)[
       IF(RTOP_FLATTENF(I,II)<0.0)[
          OUTPUT ICM_FLATTENF,I,II;
           (//'***ERROR IN CM ',I4,' (FLATFILT):'/
              'RTOP(',I4,',',I4,') < 0.0'//);
          IERR_GEOM(ICM_FLATTENF)=IERR_GEOM(ICM_FLATTENF)+1;
       ]
       ELSEIF(RTOP_FLATTENF(I,II) < RTOP_FLATTENF(I,II-1))[
          OUTPUT ICM_FLATTENF, I, II, I, II-1;
            (//'***ERROR IN CM ',I4,' (FLATFILT):'/
               'RTOP(',I4,',',I4,') < RTOP(',I4,',',I4,')'//);
          IERR_GEOM(ICM_FLATTENF)=IERR_GEOM(ICM_FLATTENF)+1;
       ]
       IF( RTOP_FLATTENF(I,II) > RMAX_CM(ICM_FLATTENF))[
          OUTPUT ICM_FLATTENF, I, II;
            (//'***WARNING IN CM ',I4,' (FLATFILT):'/
               'RTOP(',I4,',',I4,') > RMAX_CM'//);
      WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (FLATFILT):''/
               ''RTOP('',I4,'','',I4,'') > RMAX_CM''//)')
                ICM_FLATTENF, I, II;
       ]
    ]
    IF(RTOP_FLATTENF(I,ISSCM_NO_FLATTENF(I))<=RMAX_CM(ICM_FLATTENF))[
         RTOP_FLATTENF(I,ISSCM_NO_FLATTENF(I)+1)=
           RMAX_CM(ICM_FLATTENF);
    ]
    OUTPUT I;(/' input bottom radii of cones in layer',I5,/
  ' (on one line in order of increasing radius--Note that'/
  ' cones in one layer cannot cross)'/' :',$);
   ;MINPUT (FLATTENF) (RBOT_FLATTENF(I,J), J=1,ISSCM_NO_FLATTENF(I));
        ($MAX_N_SC_FLATTENF F15.0);
    OUTPUT (RBOT_FLATTENF(I,J), J=1,ISSCM_NO_FLATTENF(I));
          ($MAX_N_SC_FLATTENF F15.5);
    IF(RBOT_FLATTENF(I,1) = 0.0)[RBOT_FLATTENF(I,1) = 3*$BDY_TOL;]
    ELSEIF(RBOT_FLATTENF(I,1) < 0.0)[
       OUTPUT ICM_FLATTENF,I;
          (//'***ERROR IN CM ',I4,' (FLATFILT):'/
             'RBOT(',I4,',1) < 0.0'//);
       IERR_GEOM(ICM_FLATTENF)=IERR_GEOM(ICM_FLATTENF)+1;
    ]
    ELSEIF(RBOT_FLATTENF(I,1) > RMAX_CM(ICM_FLATTENF))[
        OUTPUT ICM_FLATTENF, I;
          (//'***WARNING IN CM ',I4,' (FLATFILT):'/
             'RBOT(',I4,',1) > RMAX_CM'//);
        WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (FLATFILT):''/
             ''RBOT('',I4,'',1) > RMAX_CM''//)')
             ICM_FLATTENF, I;
    ]
    DO II = 2, ISSCM_NO_FLATTENF(I)[
       IF(RBOT_FLATTENF(I,II) < 0.0)[
          OUTPUT ICM_FLATTENF, I, II;
           (//'***ERROR IN CM ',I4,' (FLATFILT):'/
              'RBOT(',I4,',',I4,') < 0.0'//);
          IERR_GEOM(ICM_FLATTENF)=IERR_GEOM(ICM_FLATTENF)+1;
       ]
       ELSEIF(  RBOT_FLATTENF(I,II) < RBOT_FLATTENF(I,II-1))[
          OUTPUT ICM_FLATTENF, I, II, I, II-1;
            (//'***ERROR IN CM ',I4,' (FLATFILT):'/
               'RBOT(',I4,',',I4,') < RBOT(',I4,',',I4,')'//);
          IERR_GEOM(ICM_FLATTENF)=IERR_GEOM(ICM_FLATTENF)+1;
       ]
       IF( RBOT_FLATTENF(I,II) > RMAX_CM(ICM_FLATTENF))[
          OUTPUT ICM_FLATTENF, I, II;
            (//'***WARNING IN CM ',I4,' (FLATFILT):'/
               'RBOT(',I4,',',I4,') > RMAX_CM'//);
      WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (FLATFILT):''/
               ''RBOT('',I4,'','',I4,'') > RMAX_CM''//)')
               ICM_FLATTENF, I, II;
       ]
    ]
    IF(RBOT_FLATTENF(I,ISSCM_NO_FLATTENF(I))<=RMAX_CM(ICM_FLATTENF))[
         RBOT_FLATTENF(I,ISSCM_NO_FLATTENF(I)+1)=
           RMAX_CM(ICM_FLATTENF);
    ]
]


N_FLATTENF = 0;
DO I = 1, ISCM_NO_FLATTENF[
   N_FLATTENF = N_FLATTENF + ISSCM_NO_FLATTENF(I) + 1;
] "Number of regions in this CM (excluding air gap)
"

"   get ECUT, PCUT, dose scoring zone, and material in each region
"   ===============================================================
OUTPUT;(///' Inputs for ECUT, PCUT, dose zones, media ...');
IRA = IRSTART_FLATTENF-1;
IR_FLATTENF=0;
DO II = 1, ISCM_NO_FLATTENF[
   OUTPUT II;(//' For layer',I5,' :');
   DO III = 1, ISSCM_NO_FLATTENF(II)+1[
      IR_FLATTENF=IR_FLATTENF+1;
      IRA = IRA+1;
      IF(III<=ISSCM_NO_FLATTENF(II))[
         OUTPUT III;(/' For cone',I5,' :');
         IF(ISSCM_NO_FLATTENF(II)>1 & III=1)[
           OUTPUT;(' (innermost cone)');
         ]
         ELSEIF(ISSCM_NO_FLATTENF(II)>1 & III=ISSCM_NO_FLATTENF(II))[
           OUTPUT;(' (outermost cone)');
         ]
      ]
      ELSEIF(III=ISSCM_NO_FLATTENF(II)+1)[
         OUTPUT;(/' For region between outermost cone and RMAX_CM :');
      ]
      ;OUTPUT;(' ECUT, PCUT (MeV),',
             ' DOSE ZONE (0=DO NOT SCORE DOSE), IREGION_TO_BIT: '/,$);
      ;MINPUT (FLATTENF)
      ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
      (2F15.0,2I5);
      IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
      IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
   ;OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
      (2F15.5,2I5);
      OUTPUT;(' material ',$);
   ;$MED_INPUT(FLATTENF); " inputs character array MED_IN from unit 5, loops
  "through array MEDIA(24,I) to check if medium was previously input.
  "If so, sets MED_INDEX to index of previous medium.  If not,
  "increments NMED and sets MED_INDEX to NMED.
   MED(IRA) = MED_INDEX; " medium of the planar slab
   ]
]"end of loop over regions"

"
"  parameter definition
"  ====================
"
"fill arrays of distance from reference plane (z=0) to front and back of slabs
"
" define the filter geometry here:

BDYTOL= $BDY_TOL;
ZMAX_FLATTENF(1) = ZMIN_FLATTENF(1) + ZTHICK_FLATTENF(1);
DO I = 2, ISCM_NO_FLATTENF[
   ZMIN_FLATTENF(I) = ZMIN_FLATTENF(I-1) + ZTHICK_FLATTENF(I-1);
   ZMAX_FLATTENF(I) = ZMIN_FLATTENF(I) + ZTHICK_FLATTENF(I);
]

IF(ICM_FLATTENF=ICM_DBS)[
    IF(ZPLANE_DBS > ISCM_NO_FLATTENF+1)[
      OUTPUT ZPLANE_DBS,ISCM_NO_FLATTENF+1;
  (/' ****DBS WARNING in FLATTENF****'/
  ' Plane chosen for electron splitting in DBS was ',I4,/
  ' This is > than the no. of planes in this FLATFILT geometry.'/
  ' Splitting plane will be reset to the bottom plane no.'/
  ' in this FLATFILT ( ',I4,').'/);
      WRITE(IOUTLIST,101) ZPLANE_DBS,ISCM_NO_FLATTENF+1;
  101 FORMAT(/' ****DBS WARNING in FLATTENF****'/
  ' Plane chosen for electron splitting in DBS was ',I4,/
  ' This is > than the no. of planes in this FLATFILT geometry.'/
  ' Splitting plane will be reset to the bottom plane no.'/
  ' in this FLATFILT ( ',I4,').'/);
      ZPLANE_DBS=ISCM_NO_FLATTENF+1;
    ]
    OUTPUT NBRSPL,ZPLANE_DBS;
  (/' DBS in FLATTENF:'/
    '   Electron splitting no.        = ',I12,/
    '   Electron splitting plane no.  = ',I12);
  IF(ZPLANE_DBS=1)[
    ZPOSN_DBS=ZMIN_FLATTENF(1);
  ]
  ELSE[
    ZPOSN_DBS=ZMAX_FLATTENF(ZPLANE_DBS-1);
  ]
  OUTPUT ZPOSN_DBS;
   ('   Z position of splitting plane = ',F10.5,' cm'/);
  IF(IRAD_DBS=1)[
    OUTPUT;(' Split electrons will be distributed with radial symmetry about'/
            ' the beam axis in this plane.'/);
  ]
  OUTPUT ZRR_DBS;
  (/'   Reminder: Z position of russian roulette plane = ',F10.5,' cm'/);
]

"establish top of first CM
"
ZFRONT_FLATTENF = Z_min_CM(ICM_FLATTENF);

"
"establish start of next CM
"
Z_min_CM(ICM_FLATTENF+1) = ZMAX_FLATTENF(ISCM_NO_FLATTENF);

"
"  set up air gap to previous CM, if present
"  =========================================
"
"  The air gap has the highest region number in the CM, even though it is at
"  the top of the component module.  This is to allow the assignment of region
"  numbers on input of the parameters of each local region (mainly to assign the
"  medium number of the region).  The air gap is then assigned after all of the
"  CM parameters have been input.
"
"note that if this is the first CM (ICM_$flatfilt=1) then the gap thickness
"Z_gap_THICK(ICM_$flatfilt) = 0, which is used as a flag for no air gap

Z_gap_THICK(ICM_FLATTENF) = ZMIN_FLATTENF(1) - Z_min_CM(ICM_FLATTENF);
IF(Z_gap_THICK(ICM_FLATTENF) < $MIN_GAP)[
   Z_gap_THICK(ICM_FLATTENF) = 0.;
   N_GAP_FLATTENF = 0; "no air gap for this CM
   ZMIN_FLATTENF(1) = Z_min_CM(ICM_FLATTENF);
]
ELSE[
   N_GAP_FLATTENF = 1; "this CM has an air gap
   IRA = IRSTART_FLATTENF + N_FLATTENF; "absolute region number of air gap
   MED(IRA) = AIR_INDEX; "medium is air
   ECUT(IRA) = ECUTIN;
   PCUT(IRA)=PCUTIN;
   ESAVE(IRA)=ESAVE_GLOBAL;
   ECUTRR(IRA)=ECUT(IRA);
]

"
"  set up region numbers
"  =====================
"
"  This CM has N_FLATFILT+N_GAP_$flatfilt regions
"
;
IREND_FLATTENF = IRSTART_FLATTENF + N_FLATTENF+ N_GAP_FLATTENF - 1;
                            "Index of last region
NREG = NREG + N_FLATTENF + N_GAP_FLATTENF;
                      "Total number of regions in full geometry up
                                "to and including this CM
IF (NREG <= $MXREG) ["have not exceeded maximum region number
      "Index of first region in next CM:"
      IR_start_CM(ICM_FLATTENF+1) = IREND_FLATTENF+1;
]
ELSE [
      OUTPUT ICM_FLATTENF,NREG,$MXREG;
      (//'***ERROR IN CM ',I4,' (FLATFILT):'/
         I4,' regions requested, only ',I4,' available'//);
      IERR_GEOM(ICM_FLATTENF)=IERR_GEOM(ICM_FLATTENF)+1;
]

"
"  establish CM boundary
"  =====================
"
RMAX_CM_FLAG(ICM_FLATTENF) = 1; "put a cylindrical boundary about CM

"
"  establish dose scoring zones and latch bit setting
"  ==================================================
"
IRA = IRSTART_FLATTENF-1; "absolute region number"
DO IR_FLATTENF=1, N_FLATTENF ["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT); " current maxmum
   "charged particle range rejection parameters
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region
   E_min_out(ICM_FLATTENF)=ECUT(IRA); "Minimum energy on exit from CM
] "end of loop over IR_FLATTENF

"   return from INPUT_FLATFILT
"   =======================
"
RETURN;

"   error messages
"   ==============
"
:EOF_FLATTENF:
;OUTPUT ICM;(//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_FLATTENF:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;
END;  "End of INPUT_FLATTENF"

%E "Start of ISUMRY_FLATTENF"
"*******************************************************************************
"
"                          Subroutine ISUMRY_FLATFILT
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_FLATTENF;


;IMPLICIT NONE;

;COMIN/ BOUNDS,CMs,CM_FLATTENF,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_FLATFILT
"T>**********************************
"T>
INTEGER
   ICOLOUR,       "T>colour of CM for EGS_Windows
   IRA,           "T>absolute region number
   I,J,K,L,II;    "T>DO loop index

$REAL VOL_FLATTENF($MAX_N_SC_FLATTENF,$MAX_N_SC_FLATTENF),
      VOLUME_FLATTENF($MAX_N_SC_FLATTENF*$MAX_N_SC_FLATTENF),
                                                           "T> region volume
      R1, R2, H;
"   Mass of dose zone
"   =================
"
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_$flatfilt.
"
II = 0;
DO I = 1,ISCM_NO_FLATTENF[
   K = 0;
   DO J = 1,ISSCM_NO_FLATTENF(I) + 1[
      K = K + 1;
      IF(J<=ISSCM_NO_FLATTENF(I))[
         R1 = RTOP_FLATTENF(I,J);
         R2 = RBOT_FLATTENF(I,J);
      ]
      ELSE[
         R1 = RMAX_CM(ICM_FLATTENF);
         R2 = RMAX_CM(ICM_FLATTENF);
      ]
      H = ZMAX_FLATTENF(I) - ZMIN_FLATTENF(I);
      VOL_FLATTENF(I,J) = 3.1415926/3.0*H*(R1**2 + R2**2 + R1*R2);
      II= II + 1;
      IF(K > 1)[
         DO L = 1, K - 1[
            VOL_FLATTENF(I,J) =
            VOL_FLATTENF(I,J) - VOL_FLATTENF(I,L);
         ]
      ]
      VOLUME_FLATTENF(II) = VOL_FLATTENF(I,J);
   ]
]

IRA = IRSTART_FLATTENF - 1; "absolute region number
DO IR_FLATTENF = 1,N_FLATTENF ["loop over local region number
   IRA = IRA+1;
   IF(DOSE_ZONE(IRA) ~= 0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID) = AMASS(ID)+VOLUME_FLATTENF(IR_FLATTENF)*RHOR(IRA);
   ]
] "end of loop over IR_FLATTENF"

"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"

WRITE(IOUTLIST,110) ICM_FLATTENF,TITLE_FLATTENF;
WRITE(IOUTLIST,120) Z_min_CM(ICM_FLATTENF),RMAX_CM(ICM_FLATTENF);

WRITE(IOUTLIST,122);
DO I = 1, ISCM_NO_FLATTENF[
   DO II = 1 , ISSCM_NO_FLATTENF(I)[
      IF(II=1)[
        WRITE(IOUTLIST,123)I,ZMIN_FLATTENF(I),ZMAX_FLATTENF(I)-
                           ZMIN_FLATTENF(I),
                           II,RTOP_FLATTENF(I,II),
                           RBOT_FLATTENF(I,II);
      ]
      ELSE[
        WRITE(IOUTLIST,124)II,RTOP_FLATTENF(I,II),
                           RBOT_FLATTENF(I,II);
      ]
   ]
]
WRITE(IOUTLIST,130);
IRA = IRSTART_FLATTENF - 1;
DO I = 1, ISCM_NO_FLATTENF[
   DO II = 1 , ISSCM_NO_FLATTENF(I) + 1[
      IRA = IRA + 1;
      IR_FLATTENF = IRA - IRSTART_FLATTENF + 1;
      IF(II<=ISSCM_NO_FLATTENF(I))[
          IF(MED(IRA)=0) ["Medium is vacuum"
              WRITE(IOUTLIST,140) IR_FLATTENF,I,II,'cone',
                     ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),
                     DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
                     'V','a','c','u','u','m';
          ]
          ELSE ["Medium is not vacuum"
              WRITE(IOUTLIST,140) IR_FLATTENF,I,II,'cone',
                             ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
                             DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
                             (MEDIA(J,MED(IRA)),J=1,9);
          ]
      ]
      ELSEIF(II=ISSCM_NO_FLATTENF(I) + 1)[
          IF(MED(IRA)=0) ["Medium is vacuum"
              WRITE(IOUTLIST,141) IR_FLATTENF,I,'NA','between',
                     ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),
                     DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
                     'V','a','c','u','u','m';
          ]
          ELSE ["Medium is not vacuum"
              WRITE(IOUTLIST,141) IR_FLATTENF,I,'NA','between',
                             ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
                             DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
                             (MEDIA(J,MED(IRA)),J=1,9);
          ]
          WRITE(IOUTLIST,142)'outer';
          WRITE(IOUTLIST,142)'cone and';
          WRITE(IOUTLIST,142)'RMAX_CM';
      ]
    ]
    WRITE(IOUTLIST,142)' ';
]
IF(N_GAP_FLATTENF ~= 0 )[
   IRA = IRSTART_FLATTENF + N_FLATTENF;
   WRITE(IOUTLIST,143) N_FLATTENF+N_GAP_FLATTENF,'NA','NA','airgap',
       ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
       DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),(MEDIA(J,MED(IRA)),J=1,9);
   WRITE(IOUTLIST,142)'at top';
]


110 FORMAT(///' Component module',I3,' is FLATFILT'
           /'  --------------------------------------'
           //T5,'Title: ',68A1);
120 FORMAT(/T2,'FLATTENF geometry parameters:',
           /T2,'-----------------------------',
           /T2,'Distance of front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Radius of outer boundary of CM = ',F15.5,' cm');
122 FORMAT
(/T2,'layer  Z front  thickness  cone  top radius  bottom radius',
 /T2,'  #     face                #',
 /T2,'        (cm)       (cm)            (cm)          (cm)');
123 FORMAT(T2,I3,F9.3,F11.3,I6,F11.3,F14.3);
124 FORMAT(T25,I6,F11.3,F14.3);
130 FORMAT(/T2,'FLATTENF region parameters:',
           /T2,'---------------------------',
           /T2,'local  layer  cone  loc.  electron  photon',
           '  range  rejection  dose  bit  medium'
           /T2,'region                     cutoff   cutoff',
           '  level   maximum   zone  set'
           /T2,'                           (MeV)     (MeV)',
           '  (MeV)    (MeV)');
140 FORMAT(T2,I3,I7,I6,A9,F8.3,F9.3,F7.3,F10.3,I5,I4,2x,9A1);
141 FORMAT(T2,I3,I7,A6,A9,F8.3,F9.3,F7.3,F10.3,I5,I4,2x,9A1);
142 FORMAT(T18,A9);
143 FORMAT(T2,I3,A7,A6,A9,F8.3,F9.3,F7.3,F10.3,I5,I4,2x,9A1);



"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"
IF(IWATCH = 4 | IZLAST = 2) [  "Creat a graphics file "
   ICOLOUR=4;
"   WRITE(IOUTGEOM,201) ICOLOUR,'DISK',0.0,0.0,ZMIN_FLATTENF,RTOP_FLATTENF;
   "filter geometry"
   DO I = 1, ISCM_NO_FLATTENF[
      DO J = 1, ISSCM_NO_FLATTENF(I)[
         WRITE(IOUTGEOM,201)ICOLOUR,'CYLZ',ZMIN_FLATTENF(I),
                      RTOP_FLATTENF(I,J),ZMAX_FLATTENF(I),
                      RBOT_FLATTENF(I,J),0.0,0.0;
      ]
   ]
]"End of graphics output"
201   FORMAT(' ',I1,A4,10(F7.2,','));
;RETURN;
END; "End of subroutine ISUMRY_FLATTENF"

%E "Start of HOWNEAR_FLATTENF"
"******************************************************************************
"
"                          Subroutine HOWNEAR_FLATTENF
"                          ***********************
"
" Returns min. distance to nearest region boundary.
" Used to be a macro.
"
"*******************************************************************************
;SUBROUTINE HOWNEAR_FLATTENF(DIST);


$IMPLICIT-NONE;

COMIN/CM_FLATTENF,STACK/;

$REAL DIST, "T> min. distance to nearest region boundary
      DNER_Z,DNER_IN,DNER_OU,  "T> temp. distance variables
      tmp1,tmp2,tmp3,tmp4,tmp5, "T> temp. distance variables
      ALO_FLATTENF,  "T> part of equation of line describing cone bdy
      BLO_FLATTENF;  "T> part of equation of line describing cone bdy

$INTEGER I1,I,II; "T> looping indices

IR_FLATTENF = IR(NP) - IRSTART_FLATTENF + 1;
I1 = 0;
DO I = 1, ISCM_NO_FLATTENF [
    DO II= 1, ISSCM_NO_FLATTENF(I)+1 [
       I1=I1+1;
       IF(I1=IR_FLATTENF)[
         ISCM_FLATTENF=I;
         IISSC_FLATTENF=II;
         EXIT;
       ]
    ]
    IF(I1=IR_FLATTENF)[
       EXIT;
    ]
]
IF(IR_FLATTENF<=N_FLATTENF)[
   DNER_OU = 1E20;
   DNER_IN = 1E20;
   DNER_Z = MIN(ZMAX_FLATTENF(ISCM_FLATTENF) - Z(NP),
                Z(NP) - ZMIN_FLATTENF(ISCM_FLATTENF) );
   IF(IISSC_FLATTENF <= ISSCM_NO_FLATTENF(ISCM_FLATTENF))[
     tmp1 = ZMAX_FLATTENF(ISCM_FLATTENF)
       - ZMIN_FLATTENF(ISCM_FLATTENF);
     tmp2 = ABS(RTOP_FLATTENF(ISCM_FLATTENF,IISSC_FLATTENF)
        - RBOT_FLATTENF(ISCM_FLATTENF,IISSC_FLATTENF));
     tmp3 = tmp1/SQRT(tmp1**2+tmp2**2);
     tmp4 = SQRT(X(NP)**2 + Y(NP)**2);
     ALO_FLATTENF = (RBOT_FLATTENF(ISCM_FLATTENF,IISSC_FLATTENF)
                  - RTOP_FLATTENF(ISCM_FLATTENF,IISSC_FLATTENF))/
                    (ZMAX_FLATTENF(ISCM_FLATTENF)
                  - ZMIN_FLATTENF(ISCM_FLATTENF));
     BLO_FLATTENF = RTOP_FLATTENF(ISCM_FLATTENF,IISSC_FLATTENF)
                 - ZMIN_FLATTENF(ISCM_FLATTENF)*ALO_FLATTENF;
     tmp5 = ALO_FLATTENF * Z(NP) + BLO_FLATTENF;
     DNER_OU =  (tmp5 - tmp4) * tmp3;
   ]
   IF(IISSC_FLATTENF > 1 )[
      tmp1 = ZMAX_FLATTENF(ISCM_FLATTENF)
            - ZMIN_FLATTENF(ISCM_FLATTENF);
      tmp2 = ABS(RTOP_FLATTENF(ISCM_FLATTENF,IISSC_FLATTENF-1)
            - RBOT_FLATTENF(ISCM_FLATTENF,IISSC_FLATTENF-1));
      tmp3 = tmp1/SQRT(tmp1**2+tmp2**2);
      tmp4 = SQRT(X(NP)**2 + Y(NP)**2);
      ALO_FLATTENF = (RBOT_FLATTENF(ISCM_FLATTENF,IISSC_FLATTENF-1)
               - RTOP_FLATTENF(ISCM_FLATTENF,IISSC_FLATTENF-1))/
                (ZMAX_FLATTENF(ISCM_FLATTENF)
               - ZMIN_FLATTENF(ISCM_FLATTENF));
      BLO_FLATTENF = RTOP_FLATTENF(ISCM_FLATTENF,IISSC_FLATTENF-1)
               - ZMIN_FLATTENF(ISCM_FLATTENF)*ALO_FLATTENF;
      tmp5 = ALO_FLATTENF * Z(NP) + BLO_FLATTENF;
      DNER_IN =  (tmp4 - tmp5) * tmp3;
   ]
   DIST = MIN(DNER_IN,DNER_OU,DNER_Z);
]
ELSEIF(IR_FLATTENF=N_FLATTENF+1)[
  DIST=MIN(Z(NP)-ZFRONT_FLATTENF,ZMIN_FLATTENF(1)-Z(NP));
]
RETURN;
END;"End of subroutine HOWNEAR_FLATTENF

"*******************************************************************************
"End of FLATFILT_cm.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: parallel plate monitor chamber            "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Charlie Ma                                                "
"                   Dave Rogers                                               "
"                   Iwan Kawrakow                                             "
"                   Ernesto Mainegra-Hing                                     "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code originally evolved from the IONCHAM component module written by  "
"  Jiansu Wei, starting in 1992.                                              "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


%Q1
%C80
!INDENT F4;
!INDENT M4;
;
"
"*******************************************************************************
"*******************************************************************************
"
"                             *************       ""toc:
"                             *           *       ""toc:
"                             *  CHAMBER  *       ""toc:
"                             *           *       ""toc:
"                             *************       ""toc:
"
"
"   History of modifications given by sccs.
"
"*******************************************************************************
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"
"   Component module for BEAM.  Parallel plate monitor chamber in the      "
"   container with top and bottom layers of arbitrary thickness and        "
"   material.                                                              "
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator:  a cylindrical
"   planar geometry for monitoring chamber.
"
"I>
"I> Geometry of CHAMBER (CHAMBER):             ""toc:
"I> *****************************
"I>                        top part,    # of layers: n_top_$chamber
"I>                --------|-----------------------------|--------
"I>                -------------|-----------------|---------------
"I>                -----------------------------------------------
"I>                 |     |    |--------------------|    |     |
"I>                 |     |    |--------------------|    |     |
"I>                 |     |    |--------------------|    |     |
"I>                 |     |wall|--------------------|    |     |
"I>                 |     |    |         .          |    |  # of layers:
"I>     container   |     |    |         .          |    |   n_chm_$chamber
"I>       wall      |     |    |         .          |    |     |
"I>                 | gap |    |         .          |    |     |
"I>                 |     |    |chamber central part|    |     |
"I>                 |     |    |--------------------|    |     |
"I>                 |     |    |--------------------|    |     |
"I>                 |     |    |--------------------|    |     |
"I>                 |     |    |____________________|    |     |
"I>                --------|----------------------------|-----------
"I>                ----------|------------------------|-------------
"I>                ------|--------------------------------|---------
"I>                        bottom part, # of layers: n_bot_$chamber
"I>
"I>
"I>   IR is the region number within the CM.  There are three parts
"I>   shown above. There are N_CHAMBER (>1) local regions.
"I>
"I>
"I>            ----------------------------------------------------
"I>            | top part:  n_top_$chamber layers.                |
"I>            |            # region: n_top_$chamber x 2          |
"I>            ----------------------------------------------------
"I>            | cham part: n_chm_$chamber layers.                |
"I>            |            # region: n_chm_$chamber + 3          |
"I>            ----------------------------------------------------
"I>            | bottom part: n_bot_$chamber layers               |
"I>            |            # region: n_bot_$chamber x 2          |
"I>            |--------------------------------------------------|
"I>            | total # regions: N_$chamberber = n_chm_$chamber+3|
"I>            |                  +2n_top_$chamber                |
"I>            |                  +2n_bot_$chamber                |
"I>            ----------------------------------------------------
;
"I>            -------------------------------------------------
"I>            | abs region # setting:                         |
"I>            |     first: main cham part begins              |
"I>            |            with irstart_$chamber,             |
"I>            |            ends with irstart_$chamber+        |
"I>            |            n_chm_$chamber-1                   |
"I>            |            +3(side wall+gap+ container wall)  |
"I>            |     second: top layers begins                 |
"I>            |            with the end of cham part+1        |
"I>            |            ends with the end of cham part     |
"I>            |            + 2n_top_$chamber-1                |
"I>            |     third: bottom layers with                 |
"I>            |            the end of top part +1             |
"I>            |            ends with the end of top part      |
"I>            |            + 2n_bot_$chamber-1                |
"I>            |     air gap: irend_$chamber=irstart_$chamber+ |
"I>            |            n_cham_$chamber +3                 |
"I>            |            +2n_top_$chamber                   |
"I>            |            +2n_bot_$chamber                   |
"I>            -------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_CHAMBER
"                      ISUMRY_CHAMBER
"                      HOWFAR_CHAMBER
"                      WHERE_AM_I_CHAMBER
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS ON USE/BUGS       ""toc:
"                             ************************
"
"*******************************************************************************
"**************************  DESCRIPTION OF VARIABLES  *************************
"*******************************************************************************
"
"                             COMMON BLOCK VARIABLES
"                             **********************
"
"  Refer to the replacement macros in BEAM.MORTRAN and BEAM_COMMON.MORTRAN
"  which define the common block variables.
"
"*******************************************************************************
"
"                                OTHER VARIABLES
"                                ***************
"
"  Refer to the section on type declarations for each subroutine. The following
"  section describes the variables input from unit 5.  These variables define
"  the parameters of each simulation.
"
;
"*******************************************************************************
"
"                               INPUT FROM UNIT 5             ""toc:
"                               *****************             ""toc:
"
"I>
"I>  CARDS CM_CHAMBER
"I>  ****************
"I>
"I>  -1  Dummy line to indicate start of CM.
"I>
"I>   0  RMAX_CM(ICM_CHAMBER):( F10.0):   Maximum radius of component module
"I>
"I>   1  TITLE_CHAMBER (60A1):  Title of CM.
"I>
"I>   2  ZMIN_CHAMBER (F15.0): Distance from front surface of 1st cylinder to
"I>                             reference plane (Z=0). Excludes any air gap.
"I>
"I>   3  N_TOP_CHAMBER, N_CHM_CHAMBER, N_BOT_CHAMBER (3I5)
"I>
"I>        N_TOP_CHAMBER:   Number of layers in top part (>= 0).
"I>        N_CHM_CHAMBER:   Number of layers in chamber itself (> 0 to input
"I>                          chamber layers individually or if ALL layers have
"I>                          the same thickness and medium; < 0 to
"I>                          input -N_CHM_CHAMBER groups of layers where
"I>                          layers in each group have the same thickness and
"I>                          ALL layers have the same MED).
"I>        N_BOT_CHAMBER:   Number of layers in bottom part (>= 0).
;
"I>   ==========================================================================
"I>   4  Inputs for the top part (If N_TOP_CHAMBER >0):
"I>   ==========================================================================
"I>
"I>    If all layers in this part are identical, then in line (a) include
"I>    NFLAG=N_TOP_CHAMBER, otherwise repeat (a) to (e) for each of the
"I>    layers.
"I>
"I>     a) ZTHICK, RCYS_CHAMBER , NFLAG (2F15.0,I5)
"I>           ZTHICK (F15.0):        Thickness of each layer in top part
"I>           RCYS_CHAMBER (F15.0): Radius of inner cylinders in each layer
"I>           N_TOP_CHAMBER (I5):   Number of layers in top part
"I>
"I>     b) ECUT,PCUT,DOSE_ZONE,IREGION_TO_BIT for inner cylinders
"I>                                           (2F15.0,2I5,1-line):
"I>         ECUT, PCUT: Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:  Dose scoring region for this region, 0=>no dose scored.
"I>         IREGION_TO_BIT :  Bit # in LATCH designated to this region
"I>
"I>     c) MED_IN (24A1):  Medium of inner cylinder (used for MED_INDEX)
"I>
"I>     d) ECUT,PCUT,DOSE_ZONE,IREGION_TO_BIT for outer annuli
"I>                                           (2F15.0,2I5,1-line):
"I>
"I>     e) MED_IN (24A1):  Medium for outer annuli (used for MED_INDEX)
"I>
;
"I>   =========================================================================
"I>   5  Inputs for the chamber/phantom part:
"I>   =========================================================================
"I>
"I>    The chamber/phantom part has a central part of potentially many layers
"I>    which may have different media and dimensions.  Outside this there
"I>    are 3 cylindrical shells, called the chamber wall, gap, and container
"I>    wall.  Each is a single material running the entire Z-span of the
"I>    central part.
"I>
"I>   5.1) RCYS_CHAMBER(1,1), RCYS_CHAMBER(1,2), RCYS_CHAMBER(1,3) (3F15.0)
"I>          RCYS_CHAMBER (1,1): Inner r of chamber wall=outer r central region
"I>          RCYS_CHAMBER (1,2): Outer r of chamber wall=inner r of gap
"I>          RCYS_CHAMBER (1,3): Inner r of container wall=outer r of gap
"I>
"I>
"I>   5.2) If N_CHM_CHAMBER>0: If all layers in this part are identical, then
"I>           in line (a) include NFLAG=N_CHM_CHAMBER and input (b) once for
"I>           all layers, otherwise repeat (a) to (c) for each of the layers.
"I>        If N_CHM_CHAMBER<0: Repeat (a) once for each of the
"I>           -N_CHM_CHAMBER groups of layers of equal thickness. In this case,
"I>           NFLAG is the number of layers in the group.   Then input (b) once
"I>           for all layers.
"I>
"I>     a) ZTHICK, NFLAG  (F15.0,I5)
"I>           ZTHICK:    Thickness of each layer in chamber part
"I>                      (N_CHM_CHAMBER>0) or of each layer in this particular
"I>                      group of layers (N_CHM_CHAMBER<0)
"I>           NFLAG:     Number of layers in chamber IF all same
"I>                      (N_CHM_CHAMBER>0) or number of layers in the group
"I>                      (N_CHM_CHAMBER<0)
"I>
"I>     b) ECUT,PCUT,DOSE_ZONE,IREGION_TO_BIT for chamber layers
"I>                                                (2F15.0,2I5,one line):
"I>           ECUT, PCUT: Cutoff energies for electrons and photons.
"I>           DOSE_ZONE:  if all layers are of equal thickness or there are
"I>                       groups of layers of equal thickness (ie
"I>                       NFLAG=N_CHM_CHAMBER or N_CHM_CHAMBER<0) then, if
"I>                       DOSE_ZONE>0 the dose is scored in regions
"I>                       DOSE_ZONE, DOSE_ZONE+1,.., DOSE_ZONE+N_CHM_CHAMBER-1
"I>                       ie, a sequence of dose scoring zones are set up
"I>                       automatically for all layers.
"I>                       For single region at a time
"I>                       Dose scoring region for this region,0=>no dose scored.
"I>           IREGION_TO_BIT :  Bit # in LATCH designated to this region
"I>
"I>     c) MED_IN (24A1):  Medium of chamber layers (used to set MED_INDEX)
"I>
"I>
"I>     5.3) Inputs for the chamber wall:
"I>     ---------------------------------
"I>
"I>     a) ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT, (2F15.0,2I5):
"I>           ECUT, PCUT: Cutoff energies for electrons and photons.
"I>           DOSE_ZONE:  Dose scoring region for this region,0=>no dose scored.
"I>           IREGION_TO_BIT:  Bit # in LATCH designated to this region
"I>
"I>     b) MED_IN (24A1):  Medium of chamber wall (used to set MED_INDEX)
"I>
"I>     5.4) Inputs for the gap between chamber wall and container wall:
"I>     ----------------------------------------------------------------
"I>
"I>     a) ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT, (2F15.0,2I5):
"I>
"I>     b) MED_IN (24A1):  Medium of gap (used to set MED_INDEX)
"I>
"I>
"I>     5.5) Inputs for the container wall:
"I>     -------------------------------------------
"I>
"I>     a) ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT, (2F15.0,2I5):
"I>
"I>     b) MED_IN (24A1):  Medium of container wall (used to set MED_INDEX)
;
"I>   =====================================================================
"I>   6  Inputs for the bottom part (If N_BOT_CHAMBER >0):
"I>   =====================================================================
"I>
"I>    5.6) If all layers in this part are identical, then in line (a) include
"I>         NFLAG=N_BOT_CHAMBER, otherwise repeat (a) to (e) for each of the
"I>         layers.
"I>
"I>     a) ZTHICK, RCYS_CHAMBER , NFLAG (2F15.0,I5)
"I>          ZTHICK:           Thickness of each layer in bottom part
"I>          RCYS_CHAMBER:    Radius of inner cylinders in bottom part
"I           NFLAG:            Number of layers in bottom part IF all same
"I>
"I>     b) ECUT,PCUT,DOSE_ZONE,IREGION_TO_BIT for inner cylinders
"I>                                             (2F15.0,2I5,1-line):
"I>          ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>          DOSE_ZONE:   Dose scoring flag, 0=>do not score dose.
"I>          IREGION_TO_BIT :  Bit # in LATCH designated to this region
"I>
"I>     c) MED_IN (24A1):  Medium of inner cylinders (used for MED_INDEX)
"I>
"I>     d) ECUT,PCUT,DOSE_ZONE,IREGION_TO_BIT for outer annuli
"I>                                            (2F15.0,2I5,1-line):
"I>     e) MED_IN (24A1):  Medium of outer annuli (used for MED_INDEX)
"I>
"I>   ====================================================================
"I>   7  Inputs for range rejection options:
"I>   ====================================================================
"I>
"I>       MRNGE (I5)         0 or 1
"I>
"I>          MRNGE     : = 1 to estimate thickness of the CHAMBER for
"I>                        ECUTRR calculations in automated range rejection
"I>                        (IREJCT_GLOBAL=1) (crude approx for 5 layers)
"I>                      = 0 no ECUTRR calculation--range rejection will
"I>                        still be done on a region-by-region basis
"I>
"I>            Note that MRNGE only has an effect if automated range
"I>            rejection is on (IREJCT_GLOBAL=1).
"I>
"I>   Example
"I>   *******
"I>
"I>  The following set of cards defines a chamber with 2 top layers, 3 chamber
"I>  layers, and 2 bottom layers.
"I>  The chamber wall is AL & the chamber container is CU. The detecting
"I>  material is air.
"I>  The air cavities are assigned as dose region 1 and the rest as region 2.
"I>
"I>  10.5; radius of CM
"I>  Chamber with 2 top layers, 3 chamber layers, 2 bottom layers
"I>  10.0; distance from front surface of the CM to the reference plane (z=0)
"I>  2,3,2;                   2 top layers, 3 chamber layers, 2 bottom layers
"I>  0.1,5.0,0;          first layer in the top part, 0.1cm thick, IR=5cm
"I>  0.521,0.010,2,2;  dose region # = 2
"I>  CU             ;  medium
"I>  0.521,0.010,2,2;
"I>  CU
"I>  0.2,5.0,0;          second layer is 0.2 cm thick, radius = 5.0 cm
"I>  0.521,0.010,2,2;  for inner cylinder (dose region # = 2)
"I>  AL
"I>  0.521,0.010,2,2;  for outer annulus
"I>  AL
"I>  5.0,5.2,10.0;     IR & OR of chamber wall, IR of container
"I>  0.2;              thickness of the first layer (air) in chamber part
"I>  0.521,0.010,1,2;  dose region # = 1
"I>  AIR
"I>  0.1;              thickness of the second layer (AL) in chamber part
"I>  0.521,0.010,2,2;  dose region # = 2
"I>  AL
"I>  0.2;              thickness of the third layer (air) in chamber part
"I>  0.521,0.010,1,2;  dose region # = 1
"I>  AIR
"I>  0.521,0.010,2,2;  chamber wall (dose region # = 2)
"I>  AL
"I>  0.521,0.010,2,2;  air gap betweem chamber wall and container wall
"I>  AIR
"I>  0.521,0.010,2,2;  chamber container
"I>  CU
"I>  0.1,5.0,2;        2 layers in bot. part have = thickness, IR
"I>  0.521,0.010,2,2;  for inner cylinders
"I>  AL
"I>  0.521,0.010,2,2;  for outer annuli
"I>  AL
"I>  0;                do not calculate ECUTRR
"I>
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules
"
"*******************************************************************************

%E     "start of subroutine HOWFAR_CHAMBER"
"******************************************************************************
"************************** Component Module CHAMBER***************************
"******************************************************************************
"
"                          Subroutine HOWFAR_CHAMBER
"                          ***********************
"
" HOWFAR routine for stacked planar media.
"
" Determine if current region number is within CHAMBER, and if so evaluate
" DIST, the distance to the region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are N_CHAMBER local regions + an air gap (if present):
"
"     local               absolute                       description
"----------  -------------------------------------   -----------------------
"IR_CHAMBER  IR_start_CM(ICM_CHAMBER)+IR_CHAMBER-1 excluding front air gap
"----------  -------------------------------------   -----------------------
"   Geometrical co-ordinates, as set in INPUT_CHAMBER are:
"
"   ZFRONT_CHAMBER     front of CM (upstream surface, air region)
"   ZMIN_CHAMBER       front of first cylinder
"   ZMAX_CHAMBER       back of last cylinder
"   RMAX_CHAMBER       radius of last cylinder (largest)
"
"******************************************************************************

;SUBROUTINE HOWFAR_CHAMBER;


"V>$GEO_SHIFT_1_(#)
"V>=============
"V>{p1} the value to compare with ustep
"V> if {p1}+1.0e-5 < ustep shift it, otherwise no shift
;
REPLACE {$GEO_SHIFT_1_(#)} WITH
{; IF({P1}+1.0E-5< USTEP) [{P1}={P1}+1.0E-5;]  }


"V>$GEO_SHIFT_2_(#,#)
"V>=============
"V>{p1} the value to compare with {P2}
"V> if {p1}+1.0e-5 < {P2} shift it, otherwise no shift
;
REPLACE {$GEO_SHIFT_2_(#,#)} WITH
{; IF({P1}+1.0E-5< {P2}) [{P1}={P1}+1.0E-5;]  }

;IMPLICIT NONE;

;COMIN/
   CMs,CM_CHAMBER,EPCONT,STACK,EGS-IO/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_CHAMBER
"T>**********************************
"T>

INTEGER
   IRL,            "T>local region number (absolute), required by HOWNEAR macro
   I, IIR, JDEBUG,
   LAYER,
   IU_D;           "T>to indicate the relations between ustep and dist

$REAL
   DIST,          "T>furthest dist to z boundary along current trajectory
   RF2_CHAMBER,  "T>temporary variable
   DMIN_CHAMBER, "T>minimum distance to boundaries checked thus far
   R0SQ,          "T>temporary init position of the particle in x-y plane
   CRITERIOR_IR,ZNP,
   STEP_UNIT, CUT_COE, CUTCOE_CHAMBER, SHIFT_COUNT_CHAMBER;
;

" Determine local region number
" *****************************
ZNP=Z(NP);
IRL = IR(NP); "local region number (absolute)
JDEBUG=JDEBUG+1;
IR_CHAMBER = IRL - IRSTART_CHAMBER + 1;   "local region number( relative )

" Set DNEAR
" *********
" This replacement macros sets DMIN_CHAMBER as well as defining IR_CHAMBER
;
CHAMBER_CM_HOWNEAR(DMIN_CHAMBER);
DNEAR(NP) = DMIN_CHAMBER;
;

" CALC. THE LAYER # "
IF( IR_CHAMBER<=N_CHM_CHAMBER ) [ LAYER=IR_CHAMBER; ]
ELSEIF(IR_CHAMBER<=N_CHM_CHAMBER+3 ) [ LAYER=1; ]
ELSE[
   LAYER=N_CHM_CHAMBER+
         (IR_CHAMBER-N_CHM_CHAMBER-3+1)/2;
]
" this will be used only for the top and bottom parts "


" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module,if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
;
R0SQ=X(NP)**2+Y(NP)**2;
CUT_COE=0.0;

" the following block double check:
"=================================
"      1. the particle is out of the CM oe regions in z direction
"      2.                        the regions in r directions
"     if so reset the ir #, and print out the warning message.
"comment: this block is not time consumming, can be kept in the final version
"=======
"
"  now do the air gap if existed.
"=====================================

IF(N_GAP_CHAMBER=1 & IRL=IREND_CHAMBER )["check the air gap first"
   IF(W(NP)>0.0)["particle going forward"
      DIST = (ZMIN_CHAMBER - Z(NP))/W(NP); "distance to front of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0)[ " particle was out of the air gap"
          USTEP=0.0;
          IF(N_TOP_CHAMBER=0)[" no top layer above the chamber"
              IF(R0SQ<RCYS2_CHAMBER(1,1))[IRNEW =IRSTART_CHAMBER;]
              ELSEIF(R0SQ<RCYS2_CHAMBER(1,2))
                 [IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER;]
              ELSEIF( R0SQ<RCYS2_CHAMBER(1,3) )
                 [IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER+1;]
              ELSE[ IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER+2;]
           ]
           ELSE[        " has top layer above the chamber"
               IF( R0SQ<RCYS2_CHAMBER(N_CHM_CHAMBER+1,1) )
                  [ IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER+3;]
               ELSE[IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER+4;]
           ]
           RETURN;
       ] "end of the double check if a particle is out of the AIR GAP"

      "  do the howfar job for the air gap  "
      "====================================="
       ELSE[
           IF( IU_D=0 )[RETURN; ] " no cut, ustep admmited"
           ELSE[ " iu_d=1, cut the ustep to dist "
               ;$GEO_SHIFT_1_(STEP_UNIT);
               USTEP=STEP_UNIT;
               RF2_CHAMBER= (X(NP)+USTEP*U(NP))**2
                        +(Y(NP)+USTEP*V(NP))**2;
               IF(N_TOP_CHAMBER=0)[  " no top layer above the chamber"
                  IF( RF2_CHAMBER<RCYS2_CHAMBER(1,1) )
                    [IRNEW =IRSTART_CHAMBER;]
                  ELSEIF( RF2_CHAMBER<RCYS2_CHAMBER(1,2) )
                    [IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER;]
                  ELSEIF( RF2_CHAMBER<RCYS2_CHAMBER(1,3) )
                    [IRNEW =IRSTART_CHAMBER+1+N_CHM_CHAMBER;]
                  ELSE[ IRNEW =IRSTART_CHAMBER+2+N_CHM_CHAMBER;]
               ]
               ELSE[ " has top layer above the chamber"
                  IF( RF2_CHAMBER<RCYS2_CHAMBER(N_CHM_CHAMBER+1,1) )
                    [ IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER+3;]
                  ELSE[IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER+4;]
               ]
               RETURN;
           ]  " end of the cut case"
       ]"  end of the howfar for this case"
   ]   " end of the w>0 case

   ELSEIF(W(NP)<0.0)[ " particle going backward"
      DIST = (ZFRONT_CHAMBER - Z(NP))/W(NP); "distance to front of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0)[
          USTEP=1.E-16; "make sure ausgab is called when leaving CM"
          CALL WHERE_AM_I(ICM_CHAMBER,-1);
          RETURN;
      ] " end of the double check if a particle is out of the CM"
      ELSE[ " do the howfar job"
          IF( IU_D=0 ) [ RETURN; ]   " no cut, ustep admmited"
          ELSE[  " iu_d=1, cut the ustep to dist "
              ;$GEO_SHIFT_1_(STEP_UNIT);
              USTEP=STEP_UNIT;
              CALL WHERE_AM_I(ICM_CHAMBER,-1);
              RETURN;
          ]  " end of the howfar job for this case "

      ]    " end of the howfar job for this case"
   ]  " end of the w<0 case "
   ELSE[ RETURN;]  " for the w=0.0 case "
]    " end of the air gap case "

" now do the central part of the ion chamber "
"==========================================="

ELSEIF(IR_CHAMBER<=N_CHM_CHAMBER)  [" inside the inner chamber layers"
   IF(W(NP) > 0.0) [  "particle going forward"
      DIST = (Z_CHAMBER(IR_CHAMBER+1) - Z(NP))/W(NP);
      "distance to back of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <=0.0)[
          USTEP=0.0;
          IF(IR_CHAMBER=N_CHM_CHAMBER & N_BOT_CHAMBER=0 )[
             " last layer of the cham"
             USTEP=1.E-16;
             CALL WHERE_AM_I(ICM_CHAMBER,1);
          ]" and last layer of CM  "
          ELSEIF( IR_CHAMBER=N_CHM_CHAMBER )[
             " last layer of chamb, not for CM   "
             " particle will go into the first layer of the bottom part  "
             IF(R0SQ< RCYS2_CHAMBER(N_CHM_CHAMBER+N_TOP_CHAMBER+1,1))[
                 " the first layer of the bottom part"
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3+2*N_TOP_CHAMBER;
             ]
             ELSE[
                IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3+2*N_TOP_CHAMBER+1;
             ]
          ]
          ELSE[  IRNEW = IR(NP)+1;]
          RETURN;
      ]
      " end of the double check if a particle is out of the CM in z direct "

      " now check the r direction "
      "==========================="

      CRITERIOR_IR=R0SQ-RCYS2_CHAMBER(1,1);
      " all the inner layers have the same radius"
      IF(CRITERIOR_IR>0.0)[" out of the r1 "
          USTEP=MIN( USTEP, SHIFT_COUNT_CHAMBER(IR_CHAMBER) );
          IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER;" go into the side wall "
          RETURN;
      ]   " end of the   r direction error block "

      "  now do the howfar job  "
      "========================="
      RF2_CHAMBER=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF(RF2_CHAMBER > RCYS2_CHAMBER(1,1))
        [CUT_COE=CUTCOE_CHAMBER( R0SQ, RCYS2_CHAMBER(1,1) ); ]
      IF((CUT_COE>0.0&CUT_COE<STEP_UNIT)|(CUT_COE=STEP_UNIT&IU_D=0))[
          " hits the side wall of the chamber "
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER;
          RETURN;
      ]
      ELSEIF(IU_D=1)[ " hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          IF(IR_CHAMBER=N_CHM_CHAMBER & N_BOT_CHAMBER=0 )[
              " last layer of the cham"
              CALL WHERE_AM_I(ICM_CHAMBER,1); ]" and last layer of CM  "
          ELSEIF( IR_CHAMBER=N_CHM_CHAMBER )[
              "last layer of chamb, not for CM"
              " particle will go into the first layer of the bottom part  "
              RF2_CHAMBER= (X(NP)+USTEP*U(NP))**2
                        +(Y(NP)+USTEP*V(NP))**2;
              IF(RF2_CHAMBER<RCYS2_CHAMBER(N_CHM_CHAMBER+
                         N_TOP_CHAMBER+1,1))
              [IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3+2*N_TOP_CHAMBER;]
              ELSE[IRNEW=IRSTART_CHAMBER+
                   N_CHM_CHAMBER+3+2*N_TOP_CHAMBER+1;]
          ]
          ELSE[IRNEW = IR(NP)+1;]
          RETURN;
       ]    " end of the case with  ustep cutoff in z direction "
       ELSE [ RETURN; " no cut off at all "  ]
   ] " end of the w>0 case "

   ELSEIF(W(NP)< 0.0)["particle going backward"
      DIST = (Z_CHAMBER(IR_CHAMBER) - Z(NP))/W(NP);
      "distance to back layer, the 0th index is ok "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0)[" particle was out of this layer in z direction"
          USTEP=0.0;
          IF(IR_CHAMBER=1 & N_TOP_CHAMBER=0 )[ " top of CM, no top part "
              IF(N_GAP_CHAMBER = 1)[ IRNEW =IREND_CHAMBER;]
              " has air gap"
              ELSE [ USTEP=1.E-16; CALL WHERE_AM_I(ICM_CHAMBER,-1); ]
                                              " no air gap "
          ]
          ELSEIF(IR_CHAMBER=1)[
             " top of the chamb, not the top of the CM"
             " particle will go into the top part from below"
             IF(R0SQ<RCYS2_CHAMBER(N_CHM_CHAMBER+N_TOP_CHAMBER,1))[
                 " the last layer of the top part "
                 IRNEW=IRSTART_CHAMBER+
                      N_CHM_CHAMBER+3+2*(N_TOP_CHAMBER-1);
             ]
             ELSE[IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3+
                   2*(N_TOP_CHAMBER-1)+1;
             ]
          ]
          ELSE[  IRNEW = IR(NP)-1;]" layer # decreases by one in the chamb"
          RETURN;
      ]
      " end of the double check if a particle is out of the main cham in z"

      " now check the r direction "
      "==========================="
      CRITERIOR_IR=R0SQ-RCYS2_CHAMBER(1,1);
      IF(CRITERIOR_IR>0.0)[" out of the region in r direction  "
          USTEP=MIN( USTEP, SHIFT_COUNT_CHAMBER(IR_CHAMBER) );
          IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER;" go into the side wall "
          RETURN;
      ]   " end of the   r direction error block "

      "  now do the howfar job  "
      "========================="
      RF2_CHAMBER=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF( RF2_CHAMBER > RCYS2_CHAMBER(1,1) )
        [CUT_COE=CUTCOE_CHAMBER( R0SQ, RCYS2_CHAMBER(1,1) ); ]
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) )[
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER;
          RETURN;
      ]
      ELSEIF(IU_D=1)[" hits the TOP of this layer"
        ;$GEO_SHIFT_1_(STEP_UNIT);
         USTEP=STEP_UNIT;
         IF(IR_CHAMBER=1 & N_TOP_CHAMBER=0 & N_GAP_CHAMBER=0 )
           [ CALL WHERE_AM_I(ICM_CHAMBER,-1); ]  " and first layer of CM  "
         ELSEIF(IR_CHAMBER=1 & N_TOP_CHAMBER=0)
           [ IRNEW=IREND_CHAMBER;]
         ELSEIF( IR_CHAMBER=1 )[ " first layer of chamb, not for CM "
            RF2_CHAMBER= (X(NP)+USTEP*U(NP))*(X(NP)+USTEP*U(NP))
                +(Y(NP)+USTEP*V(NP))*(Y(NP)+USTEP*V(NP));
            IF(RF2_CHAMBER<RCYS2_CHAMBER(N_CHM_CHAMBER+N_TOP_CHAMBER,1))
            [IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3+2*(N_TOP_CHAMBER-1);]
            ELSE[IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3+
                2*(N_TOP_CHAMBER-1)+1;
            ]
         ]
         ELSE[IRNEW = IR(NP)-1;]
         RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
   ]   " end of the w<0.0 case"

   ELSE[ " W=0 CASE "
       CUT_COE=CUTCOE_CHAMBER( R0SQ, RCYS2_CHAMBER(1,1) );
       IF( CUT_COE>0.0 & CUT_COE<=USTEP ) [
           ;$GEO_SHIFT_1_(CUT_COE);
           USTEP=CUT_COE;
           IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER;
       ]
       RETURN;
   ]   " end of the w=0 case "
]     " end of the central chamber layer part "
      "=============================="

ELSEIF(IR_CHAMBER<=N_CHM_CHAMBER+3) [
   " in the side wall or side gap or container wall"
   IIR=IR_CHAMBER-N_CHM_CHAMBER;
   " iir = 1, wall; 2, side gap; 3 container wall "
   IF(W(NP) > 0.0)["particle going forward"
      DIST = (Z_CHAMBER(N_CHM_CHAMBER+1) - Z(NP))/W(NP);
        "distance to back of cham"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <=0.0)[      " out of this layer in z direction "
          USTEP=0.0;
          IF( N_BOT_CHAMBER=0 )[   " no bottom part "
              USTEP=1.E-16;
              CALL WHERE_AM_I(ICM_CHAMBER,1);
          ]
          ELSE[                    " has bottom part "
              IF(R0SQ< RCYS2_CHAMBER(N_CHM_CHAMBER+N_TOP_CHAMBER+1,1))[
                  " the first layer of the bottom "
                  IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3+2*N_TOP_CHAMBER;
              ]
              ELSE[ IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3+
                          2*N_TOP_CHAMBER+1;
              ]
          ]
          RETURN;
      ]
      " end of the double check if a particle is out of the wall in z direct

      " now check the r direction "
      "==========================="
      CRITERIOR_IR=R0SQ-RCYS2_CHAMBER(1,IIR);
      IF(CRITERIOR_IR<0.0)[" out of the region in r dir towards to center"
          USTEP=MIN(USTEP, SHIFT_COUNT_CHAMBER(IR_CHAMBER));
          IF(IIR=1)[
              " figure out the layer # the particle will go into."
              DO I=1, N_CHM_CHAMBER[
                 IF( Z(NP)<Z_CHAMBER(I+1) ) [ EXIT; ]
              ]
              I=MIN(I, N_CHM_CHAMBER);  " to avoid i > n_chm_$chamber "
              IRNEW=IRSTART_CHAMBER+I-1;
          ]
          ELSE[ IRNEW = IRL-1; ]
          RETURN;
      ]      " end of the  out to in check "
      IF( IIR~=3)[" when iir =3, no need to check the outer "
          CRITERIOR_IR=R0SQ-RCYS2_CHAMBER(1,IIR+1);
          IF(CRITERIOR_IR>0.0)[  " out side the outer radius "
              USTEP=MIN( USTEP, SHIFT_COUNT_CHAMBER(IR_CHAMBER) );
              IRNEW=IRL+1;
              RETURN;
          ]       " end of the warnning message block.
      ]        " end of the outer radius check
      " end of the r direction error block "

      " do the howfar job for this case "
      "================================="
      " first do the inner r "
      CUT_COE=CUTCOE_CHAMBER(R0SQ, RCYS2_CHAMBER(1,IIR));
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) )[  " hits the inner wall"
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)[ " figure out the layer # the particle will go into."
             DO I=1, N_CHM_CHAMBER[
                IF( Z(NP)+USTEP*W(NP)<Z_CHAMBER(I+1) ) [ EXIT; ]
             ]
             I=MIN(I, N_CHM_CHAMBER);  " to avoid i > n_chm_$chamber "
             IRNEW = IRSTART_CHAMBER+I-1;
          ]
          ELSE[ IRNEW=IRL-1;]
          RETURN;
      ]
      IF(CUT_COE<=0.0 & IIR~=3)[   " IT IS NECESSARY TO DO OUTER CSAE"
          CUT_COE=CUTCOE_CHAMBER(R0SQ, RCYS2_CHAMBER(1,IIR+1));
          IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
             |( CUT_COE=STEP_UNIT & IU_D=0 ) ) [  " hits the outer wall"
             ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
             USTEP=CUT_COE;
             IRNEW=IR(NP)+1;
             RETURN;
          ]
      ]     " not hits the side wall at all"

     " now check to see whether hitting the bottom  "

      IF(IU_D=1)[         " hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          " last layer of the CM, no bottom part"
          IF(N_BOT_CHAMBER=0 )[ CALL WHERE_AM_I(ICM_CHAMBER,1); ]
          ELSE[" particle will go into the first layer of the bottom part"
              RF2_CHAMBER= (X(NP)+USTEP*U(NP))**2
                        +(Y(NP)+USTEP*V(NP))**2;
              " the first layer of the bottom part "
              IF( RF2_CHAMBER< RCYS2_CHAMBER(N_CHM_CHAMBER+
                           N_TOP_CHAMBER+1,1) )
              [ IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3+2*N_TOP_CHAMBER; ]
              ELSE[ IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3+
                  2*N_TOP_CHAMBER+1;
              ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "

   ]   " end of the w> 0.0 case "

   " now do the w<0.0 case "
   "======================="
   ELSEIF(W(NP) < 0.0)["particle going backward"
      DIST = (Z_CHAMBER("0"1) - Z(NP))/W(NP); "distance to back layer "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0)[ " out of the region in z direction "
          USTEP=0.0;
          IF(N_TOP_CHAMBER=0 )[
              IF(N_GAP_CHAMBER = 1)[ IRNEW =IREND_CHAMBER;]
              ELSE [ USTEP=1.E-16; CALL WHERE_AM_I(ICM_CHAMBER,-1); ]
          ]
          ELSE[         " the last layer of the top part"
             IF(R0SQ<RCYS2_CHAMBER(N_CHM_CHAMBER+N_TOP_CHAMBER,1) )
             [IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3+2*(N_TOP_CHAMBER-1);]
             ELSE[ IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3+
                      2*(N_TOP_CHAMBER-1)+1;]
          ]
          RETURN;
      ] "end of the double check if a particle is out of the region"
            " in z direction"

      " now check the r direction to see if the region # is right or not"
      "================================================================"
      CRITERIOR_IR=R0SQ-RCYS2_CHAMBER(1,IIR);
      IF(CRITERIOR_IR<0.0)[" out of the region in r dir TOWARDS center  "
          USTEP=MIN( USTEP, SHIFT_COUNT_CHAMBER(IR_CHAMBER) );
          IF(IIR=1)[ "figure out the layer # the particle will go into."
             DO I=1, N_CHM_CHAMBER[IF(Z(NP)<Z_CHAMBER(I+1))[EXIT;]]
             I=MIN(I, N_CHM_CHAMBER);  " to avoid i > n_chm_$chamber "
             IRNEW=IRSTART_CHAMBER +I-1;
          ]
          ELSE[ IRNEW=IRL-1;  ]
          RETURN;
      ]  " end of the check for the inner radius case "
      IF( IIR~=3) [ " when iir =3, no need to check the outer "
          CRITERIOR_IR=R0SQ-RCYS2_CHAMBER(1,IIR+1);
          IF(CRITERIOR_IR>0.0)[  " out side the outer radius "
              USTEP=MIN(USTEP,SHIFT_COUNT_CHAMBER(IR_CHAMBER));
              IRNEW=IRL+1;
              RETURN;
          ]       " end of the warning message block.
      ]        " end of the outer radius check
      " end of the   r direction error block "

      " do the howfar job for this case "
      "=====================================
      CUT_COE=CUTCOE_CHAMBER(R0SQ, RCYS2_CHAMBER(1,IIR));
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) )[  " hits the inner wall"
         ; $GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)[ "figure out the layer # the particle will go into."
             DO I=1, N_CHM_CHAMBER[
                 IF( Z(NP)+USTEP*W(NP)<Z_CHAMBER(I+1) ) [ EXIT; ]
             ]
             I=MIN(I, N_CHM_CHAMBER);  " to avoid i > n_chm_$chamber "
             IRNEW=IRSTART_CHAMBER+I-1;
          ]
          ELSE[ IRNEW=IRL-1; ]
          RETURN;
      ]
      IF(CUT_COE<=0.0 & IIR~=3)[   " IT IS NECESSARY TO DO OUTER CSAE"
          CUT_COE=CUTCOE_CHAMBER( R0SQ, RCYS2_CHAMBER(1,IIR+1));
          IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
             |( CUT_COE=STEP_UNIT & IU_D=0 ) )[   " hits the outer wall"
             ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
             USTEP=CUT_COE;
             IRNEW=IRL+1;
             RETURN;
          ]
      ]     " not hits the side wall at all"

      " now check to see whether hitting the bottom  "
      "=============================================="
      IF(IU_D=1)[         " hits the TOP of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          IF(N_TOP_CHAMBER=0 )[ " the first layer of the CM, no top part "
             IF(N_GAP_CHAMBER=0)[ CALL WHERE_AM_I(ICM_CHAMBER,-1); ]
              " no air gap "
             ELSE[ IRNEW=IREND_CHAMBER; ]
          ]
          ELSE[ " particle will go into the last layer of the top part  "
            RF2_CHAMBER= (X(NP)+USTEP*U(NP))**2
                        +(Y(NP)+USTEP*V(NP))**2;
            IF(RF2_CHAMBER<RCYS2_CHAMBER(N_CHM_CHAMBER+N_TOP_CHAMBER,1))
              [IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3+
                      2*(N_TOP_CHAMBER-1); ]
            ELSE[IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3+
                      2*(N_TOP_CHAMBER-1)+1; ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
   ]        " end of the w<0.0 case "

   ELSE[ "  w=0 case "
      CUT_COE=CUTCOE_CHAMBER( R0SQ, RCYS2_CHAMBER(1,IIR));"inner wall first"
      IF(  CUT_COE>0.0 & CUT_COE <= USTEP )[  " hits the inner wall"
          ;$GEO_SHIFT_1_(CUT_COE);
          USTEP=CUT_COE;
          IF(IIR=1)[
             DO I=1, N_CHM_CHAMBER
             " figure out the layer # the particle will go into."
               [ IF( Z(NP)+USTEP*W(NP)<Z_CHAMBER(I+1) ) [ EXIT; ] ]
             I=MIN(I, N_CHM_CHAMBER);  " to avoid i > n_chm_$chamber "
             IRNEW=IRSTART_CHAMBER+I-1;
          ]
          ELSE[ IRNEW=IRL-1; ]
      ]
      IF(CUT_COE<=0.0 & IIR~=3)[ " IT IS NECESSARY TO DO OUTER CSAE"
          CUT_COE=CUTCOE_CHAMBER( R0SQ, RCYS2_CHAMBER(1,IIR+1));
          IF(  CUT_COE>0.0 & CUT_COE <= USTEP )[   " hits the outer wall"
             ;$GEO_SHIFT_1_(CUT_COE);
             USTEP=CUT_COE;
             IRNEW=IRL+1;
          ]
      ]
      RETURN;     " not hits the side wall at all"
   ]   " end of the w=0 case "
]      " end of the side of the ionchamber part"

" now do the top part of this CM "
"================================"
ELSEIF(IR_CHAMBER<=N_CHM_CHAMBER+3+2*N_TOP_CHAMBER )[ " top layers "
   IIR=IR_CHAMBER-(N_CHM_CHAMBER+3);
   IIR=MOD(IIR, 2);" iir=1, inside region, =0, outside region "
   IF(W(NP) > 0.0)   ["particle going forward"
      DIST = (Z_CHAMBER(LAYER+1) - Z(NP))/W(NP); "distance to back of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <=0.0)[
          USTEP=0.0;
          IF(LAYER=N_CHM_CHAMBER+N_TOP_CHAMBER )["the end of the top layer"
              IF( R0SQ<RCYS2_CHAMBER(1,1) ) [  IRNEW =IRSTART_CHAMBER;]
              ELSEIF( R0SQ<RCYS2_CHAMBER(1,2) )
                [IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER;]
              ELSEIF( R0SQ<RCYS2_CHAMBER(1,3) )
                [IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER+1;]
              ELSE[ IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER+2;]
          ]
          ELSE[
              IF( R0SQ< RCYS2_CHAMBER(LAYER+1,1) )[
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                       +2*(LAYER-N_CHM_CHAMBER);
              ]
              ELSE[
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                      +2*(LAYER-N_CHM_CHAMBER)+1;
              ]
          ]
          RETURN;
      ]
      " end of the double check if a particle is out of the CM in z direction

      " now check the r direction "
      "============================"
      CRITERIOR_IR=R0SQ-RCYS2_CHAMBER(LAYER, 1);
      IF(CRITERIOR_IR>0.0 & IIR=1)[  " out OF the  r "
         USTEP=MIN( USTEP, SHIFT_COUNT_CHAMBER(IR_CHAMBER) );
         IRNEW=IRL+1;
         RETURN;
      ]
      ELSEIF(CRITERIOR_IR<0.0 & IIR=0)[  " inside the outer radius "
         USTEP=MIN( USTEP, SHIFT_COUNT_CHAMBER(IR_CHAMBER) );
         IRNEW=IRL-1;
         RETURN;
      ]      " end of the warnning message block."


      " do the howfar job for this case "
      "=====================================
      RF2_CHAMBER=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF( ( RF2_CHAMBER > RCYS2_CHAMBER(LAYER,1) & IIR=1 ) | IIR=0 )
        [CUT_COE=CUTCOE_CHAMBER( R0SQ, RCYS2_CHAMBER(LAYER,1)); ]
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) )[" hits the inner wall"
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)[IRNEW=IRL+1; " from in to out "]
          ELSE[ IRNEW=IRL-1; ]
          RETURN;
      ]

      " now check to see whether hitting the bottom  "
      ELSEIF(IU_D=1) [" hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          RF2_CHAMBER= (X(NP)+USTEP*U(NP))**2
                   +(Y(NP)+USTEP*V(NP))**2;
          IF(LAYER=N_CHM_CHAMBER+N_TOP_CHAMBER)[ " last layer of the top"
              " particle will go into the first layer of the chamber  "
              IF( RF2_CHAMBER< RCYS2_CHAMBER(1,1) )
                [ IRNEW=IRSTART_CHAMBER;]
              ELSEIF ( RF2_CHAMBER< RCYS2_CHAMBER(1,2) )
                [ IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER;]
              ELSEIF ( RF2_CHAMBER< RCYS2_CHAMBER(1,3) )
                [ IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+1;]
              ELSE[ IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+2; ]
          ]     " end of the last layer of the top case "
          ELSE[
              IF( RF2_CHAMBER< RCYS2_CHAMBER(LAYER+1,1) )[
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                       +2*(LAYER-N_CHM_CHAMBER);
              ]
              ELSE [
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                      +2*(LAYER-N_CHM_CHAMBER)+1;
              ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
   ]                   " end of the w> 0 case "

   " now do the w<0 case "
   "====================="

   ELSEIF(W(NP) < 0.0)[     "particle going backward"
      "  the top layer in the top part "
      IF(LAYER=N_CHM_CHAMBER+1)[ DIST=( ZMIN_CHAMBER-Z(NP) )/W(NP); ]
      ELSE [ DIST = (Z_CHAMBER(LAYER) - Z(NP))/W(NP); ]
      "distance to back layer "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0) [
          USTEP=0.0;
          IF(LAYER=N_CHM_CHAMBER +1) [  " the first layer of the CM "
              IF(N_GAP_CHAMBER = 1)[ IRNEW =IREND_CHAMBER;]
              " has air gap "
              ELSE [ USTEP=1.E-16; CALL WHERE_AM_I(ICM_CHAMBER,-1); ]
                                            " no air gap "
          ]
          ELSE [
             IF(R0SQ<RCYS2_CHAMBER(LAYER-1,1) )[
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                       +2*(LAYER-2-N_CHM_CHAMBER);
             ]
             ELSE[
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                       +2*(LAYER-2-N_CHM_CHAMBER)+1;
             ]
          ]
          RETURN;
      ]
      "  end of the double check if a particle is out of the top layer in z"

      " now check the r direction "
      "============================"
      CRITERIOR_IR=R0SQ-RCYS2_CHAMBER(LAYER, 1);
      IF(CRITERIOR_IR>0.0 & IIR=1) [ "supposed to be in outside region"
         USTEP=MIN( USTEP, SHIFT_COUNT_CHAMBER(IR_CHAMBER) );
         IRNEW=IRL+1;
         RETURN;
      ]
      ELSEIF(CRITERIOR_IR<0.0 & IIR=0)["supposed to be in inside region"
         USTEP=MIN( USTEP, SHIFT_COUNT_CHAMBER(IR_CHAMBER) );
         IRNEW=IRL-1;
         RETURN;
      ]      " end of the warnning message block."

      " do the howfar job for this case "
      "=====================================
      RF2_CHAMBER=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF( ( RF2_CHAMBER > RCYS2_CHAMBER(LAYER,1) & IIR=1 ) | IIR=0 )
        [CUT_COE=CUTCOE_CHAMBER(R0SQ, RCYS2_CHAMBER(LAYER,1)); ]
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) ) [" hits the side  wall"
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)  [  IRNEW=IRL+1; " from in to out "]
          ELSE[ IRNEW=IRL-1; ]
          RETURN;
      ]

      " now check to see whether hitting the top  "
      "==========================================="
      ELSEIF(IU_D=1) [" hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          RF2_CHAMBER= (X(NP)+USTEP*U(NP))**2
                   +(Y(NP)+USTEP*V(NP))**2;
          IF(LAYER=N_CHM_CHAMBER+1) [ " the first layer of the top"
              " particle will go into the air gap or out of the CM  "
              IF( N_GAP_CHAMBER=1 ) [ IRNEW=IREND_CHAMBER;]
              ELSE[ CALL WHERE_AM_I(ICM_CHAMBER, -1); ]
          ]     " end of the last layer of the top case "
          ELSE[         " still inside the top part "
              IF( RF2_CHAMBER< RCYS2_CHAMBER(LAYER-1,1) )[
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                       +2*(LAYER-N_CHM_CHAMBER-2);
              ]
              ELSE[
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                      +2*(LAYER-N_CHM_CHAMBER-2)+1;
              ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
  ]   " end of the w< 0.0 case "

  " now do  the w=0.0 case "
  "========================"
   ELSE [
      CUT_COE=CUTCOE_CHAMBER(R0SQ, RCYS2_CHAMBER(LAYER,1));
      IF(  CUT_COE>0.0 & CUT_COE <= USTEP )  [ " hits the  wall"
          ;$GEO_SHIFT_1_(CUT_COE);
          USTEP=CUT_COE;
          IF(IIR=1)[ IRNEW=IRL+1;]
          ELSE[ IRNEW=IRL-1; ]
      ]
      RETURN;
   ]    " end of the w=0.0 case "
]      " end of the top part "

" now do the bottom part "
"========================"
ELSEIF(IR_CHAMBER<=N_CHM_CHAMBER+3+2*N_TOP_CHAMBER+2*N_BOT_CHAMBER )[
   IIR=IR_CHAMBER-(N_CHM_CHAMBER+3);
   IIR=MOD(IIR, 2);      " iir=1, inside , iir=2, out side region "
   IF(W(NP) > 0.0)[        "particle going forward"
      DIST = (Z_CHAMBER(LAYER+1) - Z(NP))/W(NP); "distance to back of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <=0.0) [
          USTEP=0.0;
          IF(LAYER=N_CHM_CHAMBER+N_TOP_CHAMBER+N_BOT_CHAMBER)
             [  USTEP=1.E-16; CALL WHERE_AM_I(ICM_CHAMBER, 1); ]
          " the end layer of the  bottom part and the CM"
          ELSE[
              IF( R0SQ< RCYS2_CHAMBER(LAYER+1,1) )[
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                        +2*(LAYER-N_CHM_CHAMBER);
              ]
              ELSE[
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                        +2*(LAYER-N_CHM_CHAMBER)+1;
              ]
          ]
          RETURN;
      ]
      " end of the double check if a particle is out of region in z direction"

      " now check the r direction "
      "============================="
      CRITERIOR_IR=R0SQ-RCYS2_CHAMBER(LAYER, 1);
      IF(CRITERIOR_IR>0.0 & IIR=1)["supposed to be in the outer region"
         USTEP=MIN( USTEP, SHIFT_COUNT_CHAMBER(IR_CHAMBER) );
         IRNEW=IRL+1;
         RETURN;
      ]
      ELSEIF(CRITERIOR_IR<0.0 & IIR=0)["supposed to be in inside region"
         USTEP=MIN( USTEP, SHIFT_COUNT_CHAMBER(IR_CHAMBER) );
         IRNEW=IRL-1;
         RETURN;
      ]      " end of the warnning message block."

      " do the howfar job for this case "
      "=====================================
      RF2_CHAMBER=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF( ( RF2_CHAMBER > RCYS2_CHAMBER(LAYER,1) & IIR=1 ) | IIR=0 )
        [ CUT_COE=CUTCOE_CHAMBER( R0SQ, RCYS2_CHAMBER(LAYER,1)); ]
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) )[" hits the side wall"
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)[  IRNEW=IRL+1; " from in to out "]
          ELSE[ IRNEW=IRL-1; ]
          RETURN;
      ]    " end of the hitting the side wall case "

      " now check to see whether hitting the bottom  "
      "=============================================="
      ELSEIF(IU_D=1) [        " hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          RF2_CHAMBER= (X(NP)+USTEP*U(NP))**2
                   +(Y(NP)+USTEP*V(NP))**2;
          IF(LAYER=N_CHM_CHAMBER+N_TOP_CHAMBER+N_BOT_CHAMBER )
             [  CALL WHERE_AM_I(ICM_CHAMBER, 1) ; ]
          "last layer of the CM"
          ELSE [
              IF( RF2_CHAMBER< RCYS2_CHAMBER(LAYER+1,1) ) [
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                       +2*(LAYER-N_CHM_CHAMBER);
              ]
              ELSE[
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                      +2*(LAYER-N_CHM_CHAMBER)+1;
              ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
   ]   " end of the w>0.0 case "
       "========================"

   ELSEIF(W(NP) < 0.0)[       "particle going backward"
      IF(LAYER=N_CHM_CHAMBER+N_TOP_CHAMBER+1)
        [ DIST=( Z_CHAMBER(N_CHM_CHAMBER+1)-Z(NP) )/W(NP); ]
      "  the top layer in the bottom part "
      ELSE [ DIST = (Z_CHAMBER(LAYER-1+1) - Z(NP))/W(NP); ]
            "distance to back layer "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0)[
          USTEP=0.0;
          IF( LAYER=N_CHM_CHAMBER+N_TOP_CHAMBER+1 ) [
              " the first layer of the bottom "
              IF( R0SQ<RCYS2_CHAMBER(1,1) )
                [  IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER-1;]
              " the last layer of the cham"
              ELSEIF( R0SQ<RCYS2_CHAMBER(1,2) )
                [IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER;]
              " the side wall region"
              ELSEIF( R0SQ<RCYS2_CHAMBER(1,3) )
                [IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER+1;]
              " the side gap region "
              ELSE[ IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER+2;]
              " outtest container region "
          ]
          ELSE[
             IF(R0SQ<RCYS2_CHAMBER(LAYER-1,1) )[
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                       +2*(LAYER-2-N_CHM_CHAMBER);
             ]
             ELSE [
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                       +2*(LAYER-2-N_CHM_CHAMBER)+1;
             ]
          ]
          RETURN;
      ] "end of the double check if a particle is out of the region in z"

      " now check the r direction "
      "============================"
      CRITERIOR_IR=R0SQ-RCYS2_CHAMBER(LAYER, 1);
      IF(CRITERIOR_IR>0.0 & IIR=1)  [" supposed to be outside  "
         USTEP=MIN( USTEP, SHIFT_COUNT_CHAMBER(IR_CHAMBER) );
         IRNEW=IRL+1;
         RETURN;
      ]
      ELSEIF(CRITERIOR_IR<0.0 & IIR=0) [ " supposed to be inside "
         USTEP=MIN( USTEP, SHIFT_COUNT_CHAMBER(IR_CHAMBER) );
         IRNEW=IRL-1;
         RETURN;
      ]      " end of the warnning message block."

      " do the howfar job for this case "
      "=====================================
      RF2_CHAMBER=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF( ( RF2_CHAMBER > RCYS2_CHAMBER(LAYER,1) & IIR=1 ) | IIR=0 )
        [CUT_COE=CUTCOE_CHAMBER( R0SQ, RCYS2_CHAMBER(LAYER,1)); ]
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) ) [ " hits the inner wall"
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)[  IRNEW=IRL+1; " from in to out "]
          ELSE[ IRNEW=IRL-1; ]
          RETURN;
      ]

      " now check to see whether hitting the top  "
      ELSEIF(IU_D=1) [ " hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          RF2_CHAMBER= (X(NP)+USTEP*U(NP))**2
                   +(Y(NP)+USTEP*V(NP))**2;
          IF(LAYER=N_CHM_CHAMBER+N_TOP_CHAMBER+1)[
              " the first layer of the bottom"
              " particle will go into the chamber   "
              IF( RF2_CHAMBER<RCYS2_CHAMBER(1,1) )
                [IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER-1;]
              "the last layer of the cham"
              ELSEIF( RF2_CHAMBER<RCYS2_CHAMBER(1,2) )
                [IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER;]
               " the side wall region"
              ELSEIF( RF2_CHAMBER<RCYS2_CHAMBER(1,3) )
                [IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER+1;]
              " the side gap region "
              ELSE[ IRNEW =IRSTART_CHAMBER+N_CHM_CHAMBER+2;]
              "outtest container region "
          ]     " end of the last layer of the bottom case "
          ELSE[  " still inside the bottom part "
              IF( RF2_CHAMBER< RCYS2_CHAMBER(LAYER-1,1))[
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                       +2*(LAYER-N_CHM_CHAMBER-2);
              ]
              ELSE[
                 IRNEW=IRSTART_CHAMBER+N_CHM_CHAMBER+3
                      +2*(LAYER-N_CHM_CHAMBER-2)+1;
              ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
   ]   " end of the w< 0.0 case "

   ELSE[ " now do  the w=0.0 case "
         "========================"
      CUT_COE=CUTCOE_CHAMBER( R0SQ, RCYS2_CHAMBER(LAYER,1));
      IF(  CUT_COE>0.0 & CUT_COE <= USTEP )  [" hits the  wall"
         ; $GEO_SHIFT_1_(CUT_COE);
          USTEP=CUT_COE;
          IF(IIR=1)
            [ IRNEW=IRL+1;]
          ELSE[ IRNEW=IRL-1; ]
      ]
      RETURN;
   ]    " end of the w=0.0 case "

]   " end of the bottom part "
       "======================="



"   outside of CM, something is wrong
"   =================================
"
ELSE ["something is wrong"
   OUTPUT IR(NP)-IRSTART_CHAMBER+1,IR(NP),ICM_CHAMBER,
          IR_start_CM(ICM_CHAMBER);
      (//' ************'//' HOWFAR-CHAMBER error'/
         '    Region, local, absolute =',2I5/
         '    CM number=',I5,' start region =',I5/
         ' *********'//);
   STOP;
] "end of IF statement"
;
"   end of HOWFAR_CHAMBER
"   ===================
"
END; "End of subroutine HOWFAR_CHAMBER"

%E "Start of miscellaneous functions and subroutines"

;$REAL FUNCTION SHIFT_COUNT_CHAMBER(IDUMP);
"This function is used in finding the correct region. If a particle is
"in a wrong region we change the region # and shift the particle by 1.0E-5.
"If we still cannot find the correct region after 20 shifts we terminate the
"particle. If 10000 particles have been discarded we quit! However, one
"can carry on running this simulation using the BEAM re-start feature if he
"considers the effect of discarding these particles would be negligible
"for a large number of histories run.

;IMPLICIT NONE;

;COMIN/STACK, EPCONT,CM_CHAMBER,SCORE,EGS-IO/;

$LONG_INT IHSTRYOLD;
INTEGER IDUMP, COUNT1, COUNT;
$REAL XYZNEW,XYZOLD,xyzoldsave;
save xyzold,count1,count;
DATA count1,count/0,0/;
XYZNEW=X(NP)+Y(NP)+Z(NP);
IF( XYZNEW.NE.XYZOLD.OR.IHSTRY.NE.IHSTRYOLD)[ COUNT1=0;]
     " This fudge is used just to get around a numerical accuracy "
     " problem.  It is OK unless you receive the error message in "
     " the next if statement a lot of times.  "
     " IHSTRY check added to protect against incrementing COUNT1"
     " when phase space source is incident right on boundary of"
     " chamber and particles are recycled"
ELSE[
    COUNT1=COUNT1+1;
    IF( COUNT1=20 ) [
        OUTPUT IDUMP,X(NP),Y(NP),X(NP)**2+Y(NP)**2,Z(NP),U(NP),
        V(NP),W(NP),E(NP),IQ(NP);
        (/' WARNING FROM CHAMBER REGION ', I5,': TAKEN USTEP = 1.0E-5 ',
         ' FOR 20 TIMES, STILL CANNOT FIND ITS REGION'/
         ' THE PARTICLE HAS BEEN DISCARDED.'/
         ' OUTPUT: x,y,r**2,z,u,v,w,E,IQ '/
        8F11.6,I3);
        IDISC=1;COUNT1=0;
        SHIFT_COUNT_CHAMBER=0.0;
        COUNT=COUNT+1;
        IF( COUNT >10000 )[
          OUTPUT;(//' ChAMBER: 10000 PARTICLES HAVE BEEN DISCARDED DUE TO'/
                     ' WRONG REGION #/BOUNDARY CROSSING ERROR. STOP!!!'//);
          STOP;
        ]
    ]
]
XYZOLD=XYZNEW;
IHSTRYOLD=IHSTRY;

SHIFT_COUNT_CHAMBER=1.0E-5;

RETURN;
END;

"******************************************************************

SUBROUTINE WARN_MES_CHAMBER(IDUMP, DUMP1, DUMP2);
IMPLICIT NONE;
COMIN/EGS-IO/;
INTEGER IDUMP, COUNT;
$REAL DUMP1, DUMP2;

    OUTPUT IDUMP, DUMP1, DUMP2; (/' WARNING MESSAGE: ' , I5, 2F15.8);
    COUNT=COUNT+1;
RETURN;
END;

"******************************************************************
;

$REAL FUNCTION CUTCOE_CHAMBER( DUMP1, DUMP2 );
IMPLICIT NONE;

$REAL  DUMP1, DUMP2;
;COMIN/STACK, CM_CHAMBER/;

$REAL A, B, B2, C, TEMP, CUT_COE1, CUT_COE2,one;
parameter (one=1);

A=U(NP)**2+V(NP)**2;
B=X(NP)*U(NP)+Y(NP)*V(NP);
B2=B**2;
C=DUMP1-DUMP2;
IF(A=0.0)[
     IF(B~=0.0)[CUTCOE_CHAMBER=-0.5*C/B;]
     ELSE[ CUTCOE_CHAMBER=-1.0E5; ]
]
ELSE[
    TEMP=B2-A*C;
    IF(TEMP>=0.0)[
       TEMP=-(B+SIGN(one,B)*SQRT(TEMP) );
       CUT_COE1=TEMP/A;
       CUT_COE2=C/TEMP;
       IF( CUT_COE1>0.0 & CUT_COE2>0.0)
       [CUTCOE_CHAMBER=MIN(CUT_COE1,CUT_COE2); ]
       ELSE[ CUTCOE_CHAMBER=MAX(CUT_COE1,CUT_COE2); ]
    ]
    ELSE [ CUTCOE_CHAMBER=-1.0E5; ]
]

RETURN;
END; "End of miscellaneous subroutines and functions"

%E    "Start of subroutine WHERE_AM_I_CHAMBER"
"******************************************************************************

"******************************************************************************
"
"                          Subroutine WHERE_AM_I_CHAMBER
"                          ***************************
"
" WHERE_AM_I routine for a stacked right cylinder slabs.
"
" WHERE_AM_I_CHAMBER determines the new region # when a particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_CHAMBER subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_CHAMBER from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"******************************************************************************

;SUBROUTINE WHERE_AM_I_CHAMBER(IDIR);


;IMPLICIT NONE;

;COMIN/CMs,CM_CHAMBER,EPCONT,STACK/;

"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_CHAMBER
"T>**************************************
"T>

INTEGER IDIR;  "T>direction of particle, +1=forward, -1=backward
$REAL XBDY_CHAMBER,YBDY_CHAMBER,RBDY2_CHAMBER;
XBDY_CHAMBER = X(NP) + U(NP)*USTEP;
YBDY_CHAMBER = Y(NP) + V(NP)*USTEP;
RBDY2_CHAMBER = XBDY_CHAMBER*XBDY_CHAMBER + YBDY_CHAMBER*YBDY_CHAMBER;
IF((IRSTART_CHAMBER = 2) & (IDIR =1))    " this is first CM and from front
  [ RBDY2_CHAMBER = X(NP)*X(NP) + Y(NP)*Y(NP); ]

IF (IDIR=1) ["particle entering this CM through front face (upstream)
   IF(N_GAP_CHAMBER = 0) [        "no air gap this CM"
      IF(N_TOP_CHAMBER=0)    [" no top layers above the ionchamber.
         IF(RBDY2_CHAMBER < RCYS2_CHAMBER(1,1))
           [ IRNEW = IRSTART_CHAMBER;   ]     " center
         ELSEIF(RBDY2_CHAMBER < RCYS2_CHAMBER(1, 2))
           [   IRNEW = IRSTART_CHAMBER + N_CHM_CHAMBER;]  " side wall
         ELSEIF(RBDY2_CHAMBER < RCYS2_CHAMBER(1, 3))
           [IRNEW = IRSTART_CHAMBER + N_CHM_CHAMBER+1; ]     " side gap
         ELSE[ IRNEW = IRSTART_CHAMBER +N_CHM_CHAMBER+2 ; ] " container wall
      ]
      ELSE["   has top layer."
         IF(RBDY2_CHAMBER < RCYS2_CHAMBER(N_CHM_CHAMBER+1,1))
           [ IRNEW = IRSTART_CHAMBER + N_CHM_CHAMBER +3; ]
         ELSE[ IRNEW = IRSTART_CHAMBER + N_CHM_CHAMBER +3 +1; ]
      ]
   ]
   ELSE [  IRNEW = IREND_CHAMBER; ]"this CM has an air gap at the front"
]  " end of idir=1 case
ELSE ["particle entering this CM through back face (downstream)
   IF( N_BOT_CHAMBER=0 )[ " no bottom layers below the chamber
      IF(RBDY2_CHAMBER < RCYS2_CHAMBER(1,1))
        [ IRNEW = IRSTART_CHAMBER-1+N_CHM_CHAMBER;   ]     " center
      ELSEIF(RBDY2_CHAMBER < RCYS2_CHAMBER(1, 2))
        [ IRNEW = IRSTART_CHAMBER+N_CHM_CHAMBER ;]  " side wall
      ELSEIF(RBDY2_CHAMBER < RCYS2_CHAMBER(1, 3))
        [IRNEW = IRSTART_CHAMBER +N_CHM_CHAMBER+ 1; ]     " side gap
      ELSE[ IRNEW = IRSTART_CHAMBER+N_CHM_CHAMBER + 2; ] " container wall
   ]
   ELSE["   has bottom layer.
      IF(RBDY2_CHAMBER
       < RCYS2_CHAMBER(N_CHM_CHAMBER+N_TOP_CHAMBER+N_BOT_CHAMBER,1))
        [ IRNEW = IREND_CHAMBER-N_GAP_CHAMBER-1; ]
      ELSE[ IRNEW =IREND_CHAMBER-N_GAP_CHAMBER; ]
   ]
]

RETURN;

END; "End of subroutine WHERE_AM_I_CHAMBER"

%E   "Start of subroutine INPUT_CHAMBER"
"*******************************************************************************
"
"                           Subroutine INPUT_CHAMBER
"                           **********************
"
"  A CM input subroutine for a cylindrical planar geometry.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_CHAMBER;


;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_CHAMBER,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;
"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_CHAMBER
"T>*********************************
"T>

$REAL   ZTHICK_CHAMBER, "T>total thickness of CM
        ZTHICK,          "T>temp. variable used to store layer thicknesses
        THICK1, THICK2, THICK3, "T>temp. storage of total thicknesses
        Zminthick,       "T>used to calc. min thickness for range rejection
        RCYSTEMP($MAX_N_CHAMBER), "T>used for inputting top part
        ZTEMP($MAX_N_CHAMBER),    "T>used for inputting top part
        ECUTTEMP($MXREG),          "T>used for inputting top part
        PCUTTEMP($MXREG);          "T>used for inputting top part

INTEGER I,IM,J,JM, II, III,        "T>DO loop indeces
        MRNGE,          "T> local variable = 1 to enable ECUTRR calculation
                        "T> otherwise ECUTRR is not calculated
        IRA,            "T>Absolute region number
        MED_FLAG,       "T>flag used by media-sort macro $MED_INPUT
        MED_INDEX,      "T>medium index, set after medium sort by $MED_INPUT
        N_CHAM,         "T>used to keep track of number of layers in chamber
        DOSE_ZONETEMP($MXREG),  "T>used for inputting top part
        IREGION_TO_BITTEMP($MXREG), "T>used for inputting top part
        MEDTEMP($MXREG),          "T>used for inputting top part
        IRM;                      "T>used for inputting top part
"
"  initialize parameters
"  =====================
"
ICM_CHAMBER = ICM;     "CM index for this component module
IRSTART_CHAMBER = IR_start_CM(ICM_CHAMBER);
              "Index of first region in this CM,
              "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_CHAMBER) = 0; "Geometry-checking flag, 0 if no error detected

DO I=1,NDOSE_ZONE[ZPLOTCHM(I)=-1000.;"set default values"]

"
"  get the title line
"  ==================
"
OUTPUT;(/' CHAMBER  (CHAMBER)');
OUTPUT RMAX_CM(ICM);
     (/' This component is an ion chamber or for scoring dose components'/
       '       Outer boundary is a cylinder of radius',F10.4,' cm'
       //' TITLE: ',$);
;MINPUT (CHAMBER) TITLE_CHAMBER;(60A1);
OUTPUT TITLE_CHAMBER;(' ',60A1);

IF (ICM_CHAMBER = 1)[OUTPUT Z_min_CM(1);
   (' This is first component module -- starts at',F12.4,
                                          ' cm from ref plane(z=0)');
]
ELSE [OUTPUT Z_min_CM(ICM_CHAMBER);
   (' This CM, including air gap, starts at end of previous CM at', F10.5,
    ' cm');
]
"
" get distance from reference plane, z=0"
"   =============================
OUTPUT;
(/' Distance from front of CHAMBER(not air gap) to ref plane(z=0):',$);
;MINPUT (CHAMBER) ZMIN_CHAMBER;(F15.0);
OUTPUT ZMIN_CHAMBER;(F11.5);

IF(ZMIN_CHAMBER < Z_min_CM(ICM_CHAMBER))[
   IF(ICM_CHAMBER=1)[
      OUTPUT ICM_CHAMBER, ZMIN_CHAMBER,Z_min_CM(ICM_CHAMBER);
       (//' ***WARNING IN CM ',I4,' (CHAMBER):'/
          ' Z_min_CM(1) > distance to top of chamber'/
          ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm '//);
          WRITE(IOUTLIST,100)
        ICM_CHAMBER, ZMIN_CHAMBER,Z_min_CM(ICM_CHAMBER);
     100 FORMAT(//' ***WARNING IN CM ',I4,' (CHAMBER):'/
          ' Z_min_CM(1) > distance to top of chamber'/
          ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm '//);
       Z_min_CM(ICM_CHAMBER)=ZMIN_CHAMBER;
   ]
   ELSE[
     OUTPUT ICM_CHAMBER;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'Overlaps with previous CM'//);
       IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
   ]
]
OUTPUT; (/' This module consists of 3 partS:',
         /'   1 --- top part, ',
         /'   2 --- main part: the chamber/phantom central part, ',
         /'   3 --- bottom part.');
OUTPUT $MAX_N_CHAMBER-1;
(/' Input the number of layers for each part: '/
' N-TOP (>=0), N-CHAM (>0 to input chamber layers individually or <0 to'/
' input -N-CHAM groups of layers), N-BOT (>=0) (N-TOP + total number of'/
' chamber layers + N-BOT <= ',I4,') on one line'/
' : ',$);
;MINPUT (CHAMBER) N_TOP_CHAMBER, N_CHM_CHAMBER, N_BOT_CHAMBER;(3I5);
OUTPUT N_TOP_CHAMBER, N_CHM_CHAMBER,  N_BOT_CHAMBER;(3I9);
IF(N_CHM_CHAMBER=0)[
   OUTPUT ICM_CHAMBER;
     (//'***ERROR IN CM ',I4,' (CHAMBER)'/
        'N-CHAM = 0'/
        'N-CHAM reset to 1 for now.'//);
   N_CHM_CHAMBER=1;
   IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
]
IF(N_TOP_CHAMBER < 0)[
   OUTPUT ICM_CHAMBER; (//'***ERROR IN CM ',I4,' (CHAMBER)'/
        'N-TOP < 0'/ 'N-TOP reset to 0 for now.'//);
   N_TOP_CHAMBER=0;
   IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
]
IF(N_BOT_CHAMBER < 0)[
   OUTPUT ICM_CHAMBER;
     (//'***ERROR IN CM ',I4,' (CHAMBER)'/
        'N-BOT < 0'/ 'N-BOT reset to 0 for now.'//);
   N_BOT_CHAMBER=0;
   IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
]
IF(N_CHM_CHAMBER>0 &
   N_CHM_CHAMBER+N_TOP_CHAMBER+N_BOT_CHAMBER > $MAX_N_CHAMBER-1)[
   N_BOT_CHAMBER=0;
   N_TOP_CHAMBER=0;
   N_CHM_CHAMBER=$MAX_N_CHAMBER-1;
   OUTPUT ICM_CHAMBER, $MAX_N_CHAMBER-1;
    (//'***ERROR IN CM ',I4,' (CHAMBER):'/
       'N-CHAM + N-TOP + N-BOT > max. # of layers allowed.'/
       'N-TOP set to 0, N-BOT set to 0, N-CHAM set to ',I4,' for now.'//);
   IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
]

IF(N_CHM_CHAMBER>0)[
   N_CHAMBER = N_CHM_CHAMBER+3+ 2*N_TOP_CHAMBER+2*N_BOT_CHAMBER;
]
"Number of regions in this CM (<50, excluding front air gap)"
"
"                  INPUT for TOP REGION
"                  ====================
"
IF(N_TOP_CHAMBER~=0)[
  OUTPUT N_TOP_CHAMBER;
  (/' Input thickness (ZTHICK) & inner radius (RCYL) for each of',
   ' the',I3,' layers'/' for the top part.'
  /' Note that the inner radius, RCYL divides each layer into 2',
  ' regions,'/
  ' an inner disc-shaped region and an outer annular region.',
  /' The outer boundary of the annular region is RMAX_CM.');
  OUTPUT;(/
  ' For layers of equal thickness, inner radius and medium, '/
  ' Input ZTHICK,RCYL & N-TOP, in one line)'/
  ' Otherwise, input ZTHICK & RCYL for each layer starting from 1ST',
  ' layer'/ ' : ',$);
  IM=1;"starting # for the top part"
  ;MINPUT (CHAMBER) ZTHICK, RCYSTEMP(IM),JM;(2F15.0,I5);
  OUTPUT ZTHICK, RCYSTEMP(IM),JM;(2F15.5,I5);
  IF(ZTHICK<0.0)[
     OUTPUT ICM_CHAMBER;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Thickness of layer 1 in top part < 0.0.'//);
     IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
  ]
  IF(RCYSTEMP(IM)<0.0)[
     OUTPUT ICM_CHAMBER;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'RCYS of layer 1, top part < 0.0'//);
     IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
  ]
  ELSEIF(RCYSTEMP(IM) > RMAX_CM(ICM_CHAMBER))[
     OUTPUT ICM_CHAMBER;
      (//'***WARNING IN CM ',I4,' (CHAMBER):'/
         'RCYS of layer 1, top part > RMAX_CM'//);
     WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,
       '' (CHAMBER):''/ ''RCYS of layer 1, top part > RMAX_CM''//)')
        ICM_CHAMBER;
  ]
  ZTEMP(IM)=ZMIN_CHAMBER+ZTHICK;

  IF(JM = N_TOP_CHAMBER)["for equal thickness, radius and medium"
     IRM=1;
     OUTPUT N_TOP_CHAMBER;
     (/' All the',I5,' layers have the same thickness, inner radius'/);
     "1st (inner) region in the top part"
     OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose)',
        ',IREGION_TO_BIT for inner regions'/' :',$);
     ;MINPUT (CHAMBER) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM);
     (2F15.0,2I5);
     IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
     IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
     ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IM),
        IREGION_TO_BITTEMP(IM); (2F10.4, I5,I15);
     OUTPUT;(/' For inner regions:',$);
     ;$MED_INPUT(CHAMBER); " inputs character array MED_IN from unit 5,
                            " loops
     "through array MEDIA(24,I) to check if medium was previously input.
     "If so, sets MED_INDEX to index of previous medium.  If not,
     "increments NMED and sets MED_INDEX to NMED.
     MEDTEMP(IRM) = MED_INDEX; " medium of the slab
     IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_CHAMBER, $MAX_DOSE_ZONE;
       (/'***ERROR IN CM ',I4,' (CHAMBER):'/
       'DOSE_ZONE # of inner cylinders in top part > $MAX_DOSE_ZONE.'/
       'DOSE_ZONE set to ',I4,' for now.'/
       'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
     ]
     IRM = IRM+1;"for outer region of this layer"
     ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',
     ' for outer regions'/' :',$);
     ;MINPUT (CHAMBER) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM); (2F15.0,2I5);
     IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
     IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
     ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM);(2F10.4, I5,I15);
     OUTPUT;(/' For outer regions:',$);
     ;$MED_INPUT(CHAMBER);
     MEDTEMP(IRM) = MED_INDEX;
     IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_CHAMBER, $MAX_DOSE_ZONE;
       (/'***ERROR IN CM ',I4,' (CHAMBER):'/
       'DOSE_ZONE # of annuli in top part > $MAX_DOSE_ZONE.'/
       'DOSE_ZONE set to ',I4,' for now.'/
       'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
     ]
     DO IM=2,N_TOP_CHAMBER[
        ZTEMP(IM)=ZTEMP(IM-1)+ZTHICK;
        RCYSTEMP(IM)=RCYSTEMP(1);
        IRM = IRM+1;"for inner region of this layer"
        ECUTTEMP(IRM)=ECUTTEMP(1);
        PCUTTEMP(IRM)=PCUTTEMP(1);
        DOSE_ZONETEMP(IRM)=DOSE_ZONETEMP(1);
        IREGION_TO_BITTEMP(IRM)=IREGION_TO_BIT(1);
        MEDTEMP(IRM) = MED(1);
        IRM = IRM+1;"for outer region of this layer"
        ECUTTEMP(IRM)=ECUTTEMP(2);
        PCUTTEMP(IRM)=PCUTTEMP(2);
        DOSE_ZONETEMP(IRM)=DOSE_ZONETEMP(2);
        IREGION_TO_BITTEMP(IRM)=IREGION_TO_BIT(2);
        MEDTEMP(IRM) = MED(2);
     ]
  ]"end of equal thickness, radius and media inputs"

  ELSE["for different thicknesses, radii or media"
     IF(N_TOP_CHAMBER>1)[
        OUTPUT N_TOP_CHAMBER;
        (/' The',I5,' layers have different inner radii, thickness,',
         /' and/or media');
     ]
     OUTPUT 1;(/' For layer',I4,' in top part:');
     OUTPUT ZTHICK,RCYSTEMP(IM);
     (/' ZTHICK & RCYL =',2F15.5);
     IRM=1;
     OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose)',
     ',IREGION_TO_BIT for inner region'/' :',$);
     ;MINPUT (CHAMBER) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM); (2F15.0,2I5);
     IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
     IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
     ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM); (2F10.4, I5,I15);
     OUTPUT;(/' For inner region:',$);
     ;$MED_INPUT(CHAMBER);
     "inputs character array MED_IN from unit 5, loops
     "through array MEDIA(24,I) to check if medium was previously input.
     "If so, sets MED_INDEX to index of previous medium.  If not,
     "increments NMED and sets MED_INDEX to NMED.
     MEDTEMP(IRM) = MED_INDEX; " medium of the planar slab
     IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_CHAMBER, $MAX_DOSE_ZONE;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
 'DOSE_ZONE # of inner cylinder in 1st layer, top part > $MAX_DOSE_ZONE.'/
 'DOSE_ZONE # set to ',I4,' for now.'/
    'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
     ]
     IRM = IRM+1;"for outer region of this layer"
     ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',
     ' for outer region'/' :',$);
     ;MINPUT (CHAMBER) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM); (2F15.0,2I5);
     IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
     IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
     ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM); (2F10.4, I5,I15);
     OUTPUT;(' For outer region:',$);
     ;$MED_INPUT(CHAMBER);
     MEDTEMP(IRM) = MED_INDEX;
     IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_CHAMBER, $MAX_DOSE_ZONE;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
  'DOSE_ZONE # of outer annulus in 1st layer, top part > $MAX_DOSE_ZONE.'/
     'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
     ]
     DO IM=2, N_TOP_CHAMBER[
        OUTPUT IM;
        (/' FOR LAYER',I4,' IN TOP PART:');
        OUTPUT;
        (/' ZTHICK & RCYL:',$);
        ;MINPUT (CHAMBER) ZTHICK, RCYSTEMP(IM);(2F15.0);
        OUTPUT ZTHICK, RCYSTEMP(IM);(2F15.5);
        IF( RCYSTEMP(IM)<0.0 )[
          OUTPUT ICM_CHAMBER, IM-N_CHM_CHAMBER;
           (//'***ERROR IN CM ',I4,' (CHAMBER):'/
              'Radius of inner cylinder in layer ',I4,' of top part < 0.0'//);
          IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
        ]
        ELSEIF(RCYSTEMP(IM) > RMAX_CM(ICM_CHAMBER))[
          OUTPUT ICM_CHAMBER, IM-N_CHM_CHAMBER;
           (//'***WARNING IN CM ',I4,' (CHAMBER):'/
          'Radius of inner cylinder in layer ',I4,' of top part > RMAX_CM'//);
         WRITE(IOUTLIST,'(//''***WARNING IN CM '',
         I4,'' (CHAMBER):''/
         ''Radius of inner cylinder in layer '',
         I4,'' of top part > RMAX_CM''//)')
         ICM_CHAMBER, IM-N_CHM_CHAMBER;
        ]
        IF(ZTHICK<0.0)[
           OUTPUT ICM_CHAMBER, IM-N_CHM_CHAMBER;
          (//'***ERROR IN CM ',I4,' (CHAMBER):'/
             'Thickness of layer ',I4,' in top part < 0.0'//);
           IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
        ]
        ZTEMP(IM)=ZTEMP(IM-1)+ZTHICK;
        OUTPUT ZTHICK, RCYSTEMP(IM);(2F15.5);
        IRM = IRM+1;"inner region of this layer"
        OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose)',
                ',IREGION_TO_BIT for inner region'/' :',$);
        ;MINPUT (CHAMBER) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
                           IREGION_TO_BITTEMP(IRM); (2F15.0,2I5);
        IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
        IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
        ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IRM),
                              IREGION_TO_BITTEMP(IRM); (2F10.4, I5,I15);
        OUTPUT;(/' For inner region:',$);
        ;$MED_INPUT(CHAMBER);
        MEDTEMP(IRM) = MED_INDEX; " medium of the planar slab
        IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
           ;OUTPUT ICM_CHAMBER, IM,$MAX_DOSE_ZONE;
             (//'***ERROR IN CM ',I4,' (CHAMBER):'/
             'DOSE_ZONE # of inner cylinder in layer ',I4,
             ' of top part > $MAX_DOSE_ZONE.'/
             'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beamnrc_user_macros.mortran'//);
            DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
            IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
        ]
        IRM = IRM+1;"for outer region of this layer"
        ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',
                 ' for outer region'/' :',$);
        ;MINPUT (CHAMBER) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
                          IREGION_TO_BITTEMP(IRM); (2F15.0,2I5);
        IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
        IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
        ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IRM),
                IREGION_TO_BITTEMP(IRM); (2F10.4, I5,I15);
        OUTPUT;(' For outer region:',$);
        ;$MED_INPUT(CHAMBER);
        MEDTEMP(IRM) = MED_INDEX;
        IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
           ;OUTPUT ICM_CHAMBER, IM,$MAX_DOSE_ZONE;
             (//'***ERROR IN CM ',I4,' (CHAMBER):'/
             'DOSE_ZONE # of outer annulus in layer ',I4,
             ' of top part > $MAX_DOSE_ZONE.'/
             'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
            DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
            IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
        ]
     ]"end of the do loop"
  ]"end of non-equal thickness, etc"
  THICK2=ZTEMP(N_TOP_CHAMBER)-ZMIN_CHAMBER;
  "the overall thickness for the top part"
]
ELSE[THICK2=0.0;]

"
"                    INPUTS FOR THE Central CHAMBER PART
"                    ===================================
"
OUTPUT; (/'          INPUTS FOR THE Central CHAMBER PART');

OUTPUT; (/' INPUT THE INNER RADIUS OF THE CHAMBER WALL (R_INNER),'
  /' THE OUTER RADIUS OF THE CHAMBER WALL (R_WALL), AND THE OUTER RADIUS,'
  /' OF THE GAP BETWEEN THE CHAMBER WALL AND CONTAINER WALL (R_OUTER),'
  /' ALL ON ONE LINE.'/' : ',$);
;MINPUT (CHAMBER) RCYS_CHAMBER(1, 1), RCYS_CHAMBER(1, 2),
    RCYS_CHAMBER(1, 3);(3F15.0);
OUTPUT RCYS_CHAMBER(1, 1), RCYS_CHAMBER(1, 2),
   RCYS_CHAMBER(1, 3); (3F13.5);
OUTPUT;
(/' Note that R_OUTER also defines the inner radius of the container.'
/' The outer radius of the container is defined by RMAX_CM.');
IF(RCYS_CHAMBER(1,1)<0.0)[
   OUTPUT ICM_CHAMBER;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Inner radius of chamber wall < 0.0'//);
   IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
]
ELSEIF(RCYS_CHAMBER(1,1)>RMAX_CM(ICM_CHAMBER))[
   OUTPUT ICM_CHAMBER;
     (//'***WARNING IN CM ',I4,' (CHAMBER):'/
       'Inner radius of chamber wall > RMAX_CM'//);
   WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (CHAMBER):''/
         ''Inner radius of chamber wall > RMAX_CM''//)')
         ICM_CHAMBER;
]
IF(RCYS_CHAMBER(1,2)<0.0)[
   OUTPUT ICM_CHAMBER;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Outer radius of chamber wall < 0.0'//);
   IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
]
ELSEIF(RCYS_CHAMBER(1,2)>RMAX_CM(ICM_CHAMBER))[
   OUTPUT ICM_CHAMBER;
     (//'***WARNING IN CM ',I4,' (CHAMBER):'/
       'Outer radius of chamber wall > RMAX_CM'//);
   WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (CHAMBER):''/
         ''Outer radius of chamber wall > RMAX_CM''//)')
         ICM_CHAMBER;
]
IF(RCYS_CHAMBER(1,3)<0.0)[
   OUTPUT ICM_CHAMBER;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Inner radius of container wall < 0.0'//);
   IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
]
ELSEIF(RCYS_CHAMBER(1,3)>RMAX_CM(ICM_CHAMBER))[
   OUTPUT ICM_CHAMBER;
     (//'***WARNING IN CM ',I4,' (CHAMBER):'/
       'Inner radius of container wall > RMAX_CM'//);
   WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (CHAMBER):''/
         ''Inner radius of container wall > RMAX_CM''//)')
         ICM_CHAMBER;
]
IF(RCYS_CHAMBER(1,2)<RCYS_CHAMBER(1,1))[
   OUTPUT ICM_CHAMBER;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Outer radius of chamber wall < inner radius of chamber wall'//);
   IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
]
IF(RCYS_CHAMBER(1,3)<RCYS_CHAMBER(1,1))[
   OUTPUT ICM_CHAMBER;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Inner radius of container wall < inner radius of chamber wall'//);
   IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
]
IF(RCYS_CHAMBER(1,3)<RCYS_CHAMBER(1,2))[
   OUTPUT ICM_CHAMBER;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Inner radius of container wall < outer radius of chamber wall'//);
   IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
]

RCYS2_CHAMBER(1,1)=RCYS_CHAMBER(1,1)**2;
RCYS2_CHAMBER(1,2)=RCYS_CHAMBER(1,2)**2;
RCYS2_CHAMBER(1,3)=RCYS_CHAMBER(1,3)**2;

Z_CHAMBER(1)=ZMIN_CHAMBER+THICK2;  " THE TOP Z COORD OF THE CHAMBER "

IF(N_CHM_CHAMBER<0)["inputting for a group of layers"
  OUTPUT -N_CHM_CHAMBER;
  (/' THIS CHAMBER HAS ',I4,' GROUPS OF LAYERS WITH EQUAL THICKNESS (ZTHICK).'/
    ' FOR EACH GROUP, INPUT ZTHICK,I (on one line), WHERE I IS THE NUMBER OF'/
    ' LAYERS IN THE GROUP'/' : ',$);
  N_CHAM=0;
  DO II=1,-N_CHM_CHAMBER[
    OUTPUT II; (/' FOR LAYER GROUP ',I4,' :');
    ;MINPUT (CHAMBER) ZTHICK,I;(F15.0,I5);
    OUTPUT ZTHICK,I;(F15.5,I5);
    IF(ZTHICK<0.0)[
      OUTPUT ICM_CHAMBER;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'Layers in chamber part have thickness < 0.0'//);
      IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
    ]
    IF(I<=0)[
      OUTPUT ICM_CHAMBER;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'Cannot have a group with <= 0 layers'//);
      IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
    ]
    N_CHAM=N_CHAM+I;
    IF(N_CHAM+N_TOP_CHAMBER+N_BOT_CHAMBER > $MAX_N_CHAMBER-1)[
       OUTPUT ICM_CHAMBER;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
       'N-CHAM + N-TOP + N-BOT > max. # of layers allowed.'/);
       IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
    ]
    OUTPUT N_CHAM-I+1,N_CHAM,ZTHICK;
     (/' LAYERS ',I4,' - ',I4,' HAVE EQUAL THICKNESS OF',F15.5,' cm.'/);
    Z_CHAMBER(N_CHAM-I+2)=Z_CHAMBER(N_CHAM-I+1)+ZTHICK;
    DO IM=N_CHAM-I+2,N_CHAM[
      Z_CHAMBER(IM+1)=Z_CHAMBER(IM)+ZTHICK;
    ]
  ]"end of do loop to input thicknesses"
  IM=1;
  IRA = IRSTART_CHAMBER;"for the chamber part, one region per layer"
  N_CHM_CHAMBER=N_CHAM;
  N_CHAMBER = N_CHM_CHAMBER+3+ 2*N_TOP_CHAMBER+2*N_BOT_CHAMBER;
  OUTPUT N_CHM_CHAMBER;
   ;(' If a dose zone is input, it is the first of',I4,' in sequence');
   OUTPUT;(' ECUT,PCUT,INITIAL DOSE ZONE(0=>do not score dose),',
    ' IREGION_TO_BIT'/
    ' FOR ALL LAYERS: ',$);
   ;MINPUT (CHAMBER) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
   (2F15.0,2I5);
   IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
   IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
   ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA);(2F10.4,I5,I15);
   OUTPUT;(' For all layers :',$);
   ;$MED_INPUT(CHAMBER);
   MED(IRA) = MED_INDEX; " medium of the planar slab
   IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
      ;OUTPUT ICM_CHAMBER,$MAX_DOSE_ZONE;
        (//'***ERROR IN CM ',I4,' (CHAMBER):'/
     'DOSE_ZONE # of layer 1 of chamber part > $MAX_DOSE_ZONE.'/
     'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
      DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
      IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
   ]
   ELSEIF(DOSE_ZONE(IRA).NE.0)[
      IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
      ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
      ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
   ]
   DO IM=2, N_CHM_CHAMBER[
      IRA = IRA+1;
      ECUT(IRA)=ECUT(IRSTART_CHAMBER);
      PCUT(IRA)=PCUT(IRSTART_CHAMBER);
      DOSE_ZONE(IRA)=DOSE_ZONE(IRSTART_CHAMBER) + (IM-1);
      IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
         ;OUTPUT ICM_CHAMBER,IM,$MAX_DOSE_ZONE;
           (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'DOSE_ZONE # of layer ',I4,' of chamber part > $MAX_DOSE_ZONE.'/
          'DOSE_ZONE # set to ',I4,' for now.'/
   'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
                DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
          IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
      ]
      ELSEIF(DOSE_ZONE(IRA).NE.0)[
         IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
         ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
         ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
      ]
      IREGION_TO_BIT(IRA)=IREGION_TO_BIT(IRSTART_CHAMBER);
      MED(IRA) = MED(IRSTART_CHAMBER);
   ]
]
ELSE[
  OUTPUT; (/' INPUT THICKNESS FOR EACH LAYER WITHIN THE CHAMBER'/
  ' FOR LAYERS OF EQUAL THICKNESS (ZTHICK) AND MEDIUM, '/
  ' INPUT ZTHICK,N-CHAM (in one line)'
  /' OTHERWISE, INPUT ZTHICK FOR EACH LAYER STARTING FROM 1ST LAYER'/' : ',$);
  ;MINPUT (CHAMBER) ZTHICK,I;(F15.0,I5);
  OUTPUT ZTHICK,I;(F15.5,I5);
  IF(I = N_CHM_CHAMBER)[
    IF(ZTHICK<0.0)[
       OUTPUT ICM_CHAMBER;
        (//'***ERROR IN CM ',I4,' (CHAMBER):'/
           'Layers in chamber part have thickness < 0.0'//);
       IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
    ]
    OUTPUT I,ZTHICK;
     (/' ALL THE ',I5,' LAYERS HAVE EQUAL THICKNESS OF',F15.5,' cm.'/);
    IRA = IRSTART_CHAMBER;"for the chamber part, one region per layer"
    IM=1;
    OUTPUT I;
     ;(' If a dose zone is input, it is the first of',I4,' in sequence');
    OUTPUT;(' ECUT,PCUT,INITIAL DOSE ZONE(0=>do not score dose),',
     ' IREGION_TO_BIT'/
     ' FOR THE LAYERS: ',$);
    ;MINPUT (CHAMBER) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
    (2F15.0,2I5);
    IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
    IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
    ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
       IREGION_TO_BIT(IRA);(2F10.4,I5,I15);
    OUTPUT;(' For all layers :',$);
    ;$MED_INPUT(CHAMBER);
    MED(IRA) = MED_INDEX; " medium of the planar slab
    IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_CHAMBER,$MAX_DOSE_ZONE;
         (//'***ERROR IN CM ',I4,' (CHAMBER):'/
      'DOSE_ZONE # of layer 1 of chamber part > $MAX_DOSE_ZONE.'/
      'DOSE_ZONE # set to ',I4,' for now.'/
      'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
    ]
    ELSEIF(DOSE_ZONE(IRA).NE.0)[
       IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
       ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
       ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
    ]
    Z_CHAMBER(2)=Z_CHAMBER(1)+ZTHICK;
    DO IM=2, N_CHM_CHAMBER[
       Z_CHAMBER(IM+1)=Z_CHAMBER(IM)+ZTHICK;
       IRA = IRA+1;
       ECUT(IRA)=ECUT(IRSTART_CHAMBER);
       PCUT(IRA)=PCUT(IRSTART_CHAMBER);
       DOSE_ZONE(IRA)=DOSE_ZONE(IRSTART_CHAMBER) + (IM-1);
       IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
          ;OUTPUT ICM_CHAMBER,IM,$MAX_DOSE_ZONE;
            (//'***ERROR IN CM ',I4,' (CHAMBER):'/
           'DOSE_ZONE # of layer ',I4,' of chamber part > $MAX_DOSE_ZONE.'/
           'DOSE_ZONE # set to ',I4,' for now.'/
    'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
           DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
           IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
       ]
       ELSEIF(DOSE_ZONE(IRA).NE.0)[
          IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
          ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
          ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
       ]
       IREGION_TO_BIT(IRA)=IREGION_TO_BIT(IRSTART_CHAMBER);
       MED(IRA) = MED(IRSTART_CHAMBER);
    ]
  ]
  ELSE[
    IF(N_CHM_CHAMBER>1)[
       OUTPUT N_CHM_CHAMBER;
       (/' THE',I4,' LAYERS HAVE DIFFERENT ZTHICK AND/OR MEDIA.');
    ]
    OUTPUT 1;
    (/' FOR LAYER',I4,' IN THE CHAMBER:');
    OUTPUT ZTHICK; (/' ZTHICK =',F15.5 );
    IF(ZTHICK<0.0)[
       OUTPUT ICM_CHAMBER;
         (//'***ERROR IN CM ',I4,' (CHAMBER):'/
            'Thickness of layer 1 in chamber part < 0.0'//);
       IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
    ]
    IRA = IRSTART_CHAMBER;"for the chamber part, one region per layer"
    IM=1;
    OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT'/' :',$);
    ;MINPUT (CHAMBER) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
    (2F15.0,2I5);
    IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
    IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
    ;OUTPUT ECUT(IRA),PCUT(IRA),
          DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);(2F10.4,I5,I15);
    OUTPUT;(' For this layer :');
    ;$MED_INPUT(CHAMBER);
    MED(IRA) = MED_INDEX;
    IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_CHAMBER,$MAX_DOSE_ZONE;
         (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'DOSE_ZONE # of layer 1 of chamber part > $MAX_DOSE_ZONE.'/
          'DOSE_ZONE # set to ',I4,' for now.'/
    'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
        DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
        IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
    ]
    ELSEIF(DOSE_ZONE(IRA).NE.0)[
       IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
       ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
       ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
    ]
    Z_CHAMBER(2)=Z_CHAMBER(1)+ZTHICK;
    DO IM=2, N_CHM_CHAMBER[
       OUTPUT IM;
       (/' FOR LAYER',I4,' IN THE CHAMBER:');
       OUTPUT; (/' ZTHICK: ',$ );
       ;MINPUT (CHAMBER) ZTHICK;(F15.0);
       OUTPUT ZTHICK;(F15.5);
       IF(ZTHICK<0.0)[
          OUTPUT ICM_CHAMBER, IM;
           (//'***ERROR IN CM ',I4,' (CHAMBER):'/
            'Thickness of layer ',I4,' in chamber part < 0.0'//);
          IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
       ]
       Z_CHAMBER(IM+1)=Z_CHAMBER(IM)+ZTHICK;
       IRA = IRA+1;
       OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT'/
               ':',$);
       ;MINPUT (CHAMBER)
        ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
       (2F15.0,2I5);
       IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
       IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
       ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA), IREGION_TO_BIT(IRA);
          (2F10.4,I5,I15);
       OUTPUT;(' For this layer :',$);
       ;$MED_INPUT(CHAMBER);
       MED(IRA) = MED_INDEX; " medium of the planar slab
       IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
         ;OUTPUT ICM_CHAMBER,IM,$MAX_DOSE_ZONE;
         (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'DOSE_ZONE # of layer ',I4,' of chamber part > $MAX_DOSE_ZONE.'/
          'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
          DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
          IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
       ]
       ELSEIF(DOSE_ZONE(IRA).NE.0)[
          IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
          ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
          ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
       ]
    ]"end of do loop"
  ] "end of else"
]"end of else"

DO I=1, N_CHM_CHAMBER[
     RCYS_CHAMBER(I,1)=RCYS_CHAMBER(1,1);
     RCYS_CHAMBER(I,2)=RCYS_CHAMBER(1,2);
     RCYS_CHAMBER(I,3)=RCYS_CHAMBER(1,3);
     RCYS2_CHAMBER(I,1)=RCYS2_CHAMBER(1,1);
     RCYS2_CHAMBER(I,2)=RCYS2_CHAMBER(1,2);
     RCYS2_CHAMBER(I,3)=RCYS2_CHAMBER(1,3);
]



THICK1=Z_CHAMBER(N_CHM_CHAMBER+1)-Z_CHAMBER(1);
"the overall thickness for the monitor chamber part"

DO IR_CHAMBER = 1+N_CHM_CHAMBER, N_CHM_CHAMBER +3[
   "Parameters for chamber wall, gap and container wall regions"
   IRA = IRA+1;
   IF(IR_CHAMBER.EQ.1+N_CHM_CHAMBER)[
      OUTPUT;(/' FOR THE CHAMBER WALL:');
   ]
   ELSEIF(IR_CHAMBER.EQ.2+N_CHM_CHAMBER)[
      OUTPUT;(/' FOR THE GAP BETWEEN THE CHAMBER WALL AND THE'/
               'CONTAINER WALL:');
   ]
   ELSE[
      OUTPUT;(/' FOR THE CONTAINER WALL:');
   ]
   OUTPUT;(/' ECUT,PCUT, DOSE ZONE(0=>do not score dose),IREGION_TO_BIT'/
            ' : ',$);
   ;MINPUT (CHAMBER) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
   IREGION_TO_BIT(IRA); (2F15.0,2I5);
   IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
   IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
   OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
     IREGION_TO_BIT(IRA); (2F10.4,I5,I15);
   OUTPUT;(' For this region: ',$);
   ;$MED_INPUT(CHAMBER);
   MED(IRA) = MED_INDEX;
   IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
     ;OUTPUT ICM_CHAMBER,$MAX_DOSE_ZONE;
        (//'***ERROR IN CM ',I4,' (CHAMBER):'/
 'DOSE_ZONE # chamber wall, gap, and/or container wall > $MAX_DOSE_ZONE.'/
      'DOSE_ZONE # set to ',I4,' for now.'/
  'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
     DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
     IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
   ]
   ELSEIF(DOSE_ZONE(IRA).NE.0)[
      IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
      ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
      ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
   ]
]"end of chamber wall, gap and container wall inputs"

IRM=0;
DO I=1,N_TOP_CHAMBER[ "put here because we need to know N_CHM_CHAMBER"
  IM=N_CHM_CHAMBER+I;"starting # for the top part"
  RCYS_CHAMBER(IM, 1)=RCYSTEMP(I);
  RCYS2_CHAMBER(IM,1)=RCYS_CHAMBER(IM,1)**2;
  Z_CHAMBER(IM+1)=ZTEMP(I);
  IRA = IRA+1;
  IRM=IRM+1;
  IR_CHAMBER = IR_CHAMBER+1;
  ECUT(IRA)=ECUTTEMP(IRM);
  PCUT(IRA)=PCUTTEMP(IRM);
  DOSE_ZONE(IRA)=DOSE_ZONETEMP(IRM);
  IREGION_TO_BIT(IRA)=IREGION_TO_BITTEMP(IRM);
  MED(IRA)=MEDTEMP(IRM);
  IF(DOSE_ZONE(IRA).NE.0)[
        IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
        ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
        ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
  ]
  IRA = IRA+1;"for outer region of this layer"
  IR_CHAMBER =IR_CHAMBER +1;
  IRM=IRM+1;
  ECUT(IRA)=ECUTTEMP(IRM);
  PCUT(IRA)=PCUTTEMP(IRM);
  DOSE_ZONE(IRA)=DOSE_ZONETEMP(IRM);
  IREGION_TO_BIT(IRA)=IREGION_TO_BITTEMP(IRM);
  MED(IRA)=MEDTEMP(IRM);
  IF(DOSE_ZONE(IRA).NE.0)[
        IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
        ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
        ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
  ]
]

THICK3=0.;

IF(N_BOT_CHAMBER~=0)[
   OUTPUT N_BOT_CHAMBER;
   (/' INPUTS FOR THE BOTTOM PART (ALTOGETHER ',I4,' LAYERS):');
   OUTPUT;(/' SIMILAR TO THE TOP PART, EACH LAYER OF THE BOTTOM PART'/
   ' IS DIVIDED INTO AN INNER DISC-SHAPED REGION AND AN OUTER ANNULAR'/
   ' REGION BY THE INNER RADIUS, RCYL.'/
   ' FOR LAYERS OF EQUAL THICKNESS, INNER RADIUS & MEDIA,'/
   ' INPUT ZTHICK,RCYL & N-BOT (2F15.0,I5, in one line)'/
   ' OTHERWISE, INPUT ZTHICK & RCYL FOR EACH LAYER STARTING FROM 1ST',
   ' LAYER'/
   ' (2F15.0)',$);
   IM=N_CHM_CHAMBER+N_TOP_CHAMBER+1;"starting # for the bottom part"
   ;MINPUT (CHAMBER) ZTHICK, RCYS_CHAMBER(IM, 1),JM;(2F15.0,I5);
   OUTPUT ZTHICK, RCYS_CHAMBER(IM, 1),JM;(2F15.5,I5);
   IF(ZTHICK<0.0)[
     OUTPUT ICM_CHAMBER;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Thickness of layer 1 in bottom part < 0.0.'//);
     IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
   ]
   IF(RCYS_CHAMBER(IM, 1)<0.0)[
     OUTPUT ICM_CHAMBER;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'RCYS of layer 1, bottom part < 0.0'//);
     IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
   ]
   ELSEIF(RCYS_CHAMBER(IM,1) > RMAX_CM(ICM_CHAMBER))[
     OUTPUT ICM_CHAMBER;
      (//'***WARNING IN CM ',I4,' (CHAMBER):'/
         'RCYS of layer 1, bottom part > RMAX_CM'//);
     WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,
       '' (CHAMBER):''/
       ''RCYS of layer 1, bottom part > RMAX_CM''//)')
        ICM_CHAMBER;
   ]
   RCYS2_CHAMBER(IM,1)=RCYS_CHAMBER(IM,1)**2;
   Z_CHAMBER(IM+1)=Z_CHAMBER(N_CHM_CHAMBER+1)+ZTHICK;

  IF(JM.EQ.N_BOT_CHAMBER)["for equal thickness and radius"
     IRA = IRSTART_CHAMBER+N_CHM_CHAMBER+3+2*N_TOP_CHAMBER;
     IR_CHAMBER = N_CHM_CHAMBER+3+2*N_TOP_CHAMBER+1;
     OUTPUT N_BOT_CHAMBER;
     (/' ALL THE',I5,' LAYERS HAVE THE SAME THICKNESS & RADIUS'/);
     OUTPUT ZTHICK, RCYS_CHAMBER(IM,1);
     (/' FOR ALL LAYERS, ZTHICK, RCYL = ',2F15.5);
     OUTPUT;(/
      ' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',/
      ' for inner regions'/
       ' : ',$);
     ;MINPUT (CHAMBER) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (2F15.0,2I5);
      IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
      IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
      OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
      OUTPUT;(' For inner region :',$);
      ;$MED_INPUT(CHAMBER);
      MED(IRA) = MED_INDEX;
      IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
        ;OUTPUT ICM_CHAMBER, $MAX_DOSE_ZONE;
        (/'***ERROR IN CM ',I4,' (CHAMBER):'/
        'DOSE_ZONE # of inner cylinders in bottom part > $MAX_DOSE_ZONE.'/
        'DOSE_ZONE set to ',I4,' for now.'/
        'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
        DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
        IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
      ]
      ELSEIF(DOSE_ZONE(IRA).NE.0)[
         IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
         ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
         ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
      ]
      IRA=IRA+1;
      IR_CHAMBER=IR_CHAMBER+1;
      ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',
      ' for outer regions'/' :',$);
      ;MINPUT (CHAMBER) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (2F15.0,2I5);
      IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
      IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
      ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
      OUTPUT;(' For outer region :',$);
      ;$MED_INPUT(CHAMBER);
      MED(IRA) = MED_INDEX;
      IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
        ;OUTPUT ICM_CHAMBER, $MAX_DOSE_ZONE;
       (/'***ERROR IN CM ',I4,' (CHAMBER):'/
       'DOSE_ZONE # of annuli in bottom part > $MAX_DOSE_ZONE.'/
       'DOSE_ZONE set to ',I4,' for now.'/
       'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
        DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
        IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
      ]
      ELSEIF(DOSE_ZONE(IRA).NE.0)[
         IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
         ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
         ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
      ]
      DO IM=N_CHM_CHAMBER+N_TOP_CHAMBER+2,
          N_CHM_CHAMBER+N_TOP_CHAMBER+N_BOT_CHAMBER[
        Z_CHAMBER(IM+1)=Z_CHAMBER(IM)+ZTHICK;
        RCYS2_CHAMBER(IM,1)=
        RCYS2_CHAMBER(N_CHM_CHAMBER+N_TOP_CHAMBER+1,1);
        IRA = IRA+1;"for inner region"
        ECUT(IRA)=ECUT(IRSTART_CHAMBER+N_CHM_CHAMBER+3+2*N_TOP_CHAMBER);
        PCUT(IRA)=PCUT(IRSTART_CHAMBER+N_CHM_CHAMBER+3+2*N_TOP_CHAMBER);
        DOSE_ZONE(IRA)=
             DOSE_ZONE(IRSTART_CHAMBER+N_CHM_CHAMBER+3+2*N_TOP_CHAMBER);
        IF(DOSE_ZONE(IRA).NE.0)[
           IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
           ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
           ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
        ]
        MED(IRA)=MED(IRSTART_CHAMBER+N_CHM_CHAMBER+3+2*N_TOP_CHAMBER);
        IRA = IRA+1;"for outer region"
        ECUT(IRA)=ECUT(IRSTART_CHAMBER+N_CHM_CHAMBER+4+2*N_TOP_CHAMBER);
        PCUT(IRA)=PCUT(IRSTART_CHAMBER+N_CHM_CHAMBER+4+2*N_TOP_CHAMBER);
        DOSE_ZONE(IRA)=
           DOSE_ZONE(IRSTART_CHAMBER+N_CHM_CHAMBER+4+2*N_TOP_CHAMBER);
        IF(DOSE_ZONE(IRA).NE.0)[
           IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
           ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
           ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
        ]
        MED(IRA)=MED(IRSTART_CHAMBER+N_CHM_CHAMBER+4+2*N_TOP_CHAMBER);
      ]
      THICK3=ZTHICK*FLOAT(N_BOT_CHAMBER);
  ]"end of equal thickness and radius input"
  ELSE["for different thicknesses, radii or media"
     IRA = IRSTART_CHAMBER+N_CHM_CHAMBER+3+2*N_TOP_CHAMBER;
     IR_CHAMBER = N_CHM_CHAMBER+3+2*N_TOP_CHAMBER+1;
     IF(N_BOT_CHAMBER>1)[ OUTPUT N_BOT_CHAMBER;
         (/' THE',I4, ' LAYERS IN THE BOTTOM PART HAVE DIFFERENT'/
            ' INNER RADII, THICKNESS, AND/OR MEDIA.');
     ]
     OUTPUT 1;(/' FOR LAYER',I4,' IN BOTTOM PART:');
     OUTPUT ZTHICK,RCYS_CHAMBER(IM, 1);
     (/' ZTHICK, RCYL =',2F15.5);
     THICK3=ZTHICK;
     OUTPUT;(/' ECUT,PCUT,DOSE ZONE(0=>do not score dose),'/
            ' IREGION_TO_BIT for inner region'/
            ' : ',$);
     ;MINPUT (CHAMBER) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (2F15.0,2I5);
     IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
     IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
     ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
     OUTPUT;(' For inner region :',$);
     ;$MED_INPUT(CHAMBER);
     MED(IRA) = MED_INDEX;
     IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_CHAMBER, $MAX_DOSE_ZONE;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
  'DOSE_ZONE # of inner cylinder in 1st layer, bottom part > $MAX_DOSE_ZONE.'/
    'DOSE_ZONE # set to ',I4,' for now.'/
    'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
     ]
     ELSEIF(DOSE_ZONE(IRA).NE.0)[
         IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
         ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
         ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
     ]
     IRA = IRA+1;"for outer region of this layer"
     IR_CHAMBER =IR_CHAMBER +1;
     ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',
     ' for outer region'/' :',$);
     ;MINPUT (CHAMBER) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (2F15.0,2I5);
     IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
     IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
     ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
       IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
     OUTPUT;(' For outer region :',$);
     ;$MED_INPUT(CHAMBER);
     MED(IRA) = MED_INDEX;
     IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_CHAMBER, $MAX_DOSE_ZONE;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
  'DOSE_ZONE # of outer annulus in 1st layer, bottom part > $MAX_DOSE_ZONE.'/
        'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
     ]
     ELSEIF(DOSE_ZONE(IRA).NE.0)[
         IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
         ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
         ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
     ]
     DO IM=N_CHM_CHAMBER+N_TOP_CHAMBER+2,
            N_CHM_CHAMBER+N_TOP_CHAMBER+ N_BOT_CHAMBER[
        OUTPUT IM-N_CHM_CHAMBER-N_TOP_CHAMBER;
        (/' FOR LAYER',I4,' OF THE BOTTOM PART:');
        OUTPUT;
        (/' INPUT ZTHICK & RADIUS:',$);
        ;MINPUT (CHAMBER) ZTHICK, RCYS_CHAMBER(IM, 1);(2F15.0);
        OUTPUT ZTHICK, RCYS_CHAMBER(IM, 1);(2F12.5);
        IF(ZTHICK<0.0)[
           OUTPUT ICM_CHAMBER, IM-N_CHM_CHAMBER-N_TOP_CHAMBER;
          (//'***ERROR IN CM ',I4,' (CHAMBER):'/
             'Thickness of layer ',I4,' in bottom part < 0.0'//);
           IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
        ]
        Z_CHAMBER(IM+1)=Z_CHAMBER(IM)+ZTHICK;THICK3=THICK3+ZTHICK;
        IF( RCYS_CHAMBER(IM,1)<0.0 )[
          OUTPUT ICM_CHAMBER, IM-N_CHM_CHAMBER-N_TOP_CHAMBER;
           (//'***ERROR IN CM ',I4,' (CHAMBER):'/
            'Radius of inner cylinder in layer ',I4,' of bottom part < 0.0'//);
          IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
        ]
        ELSEIF(RCYS_CHAMBER(IM,1) > RMAX_CM(ICM_CHAMBER))[
          OUTPUT ICM_CHAMBER, IM-N_CHM_CHAMBER-N_TOP_CHAMBER;
          (//'***WARNING IN CM ',I4,' (CHAMBER):'/
         'Radius of inner cylinder in layer ',I4,' of bottom part > RMAX_CM'//);
          WRITE(IOUTLIST,'(//''***WARNING IN CM '',
          I4,'' (CHAMBER):''/
          ''Radius of inner cylinder in layer '',
          I4,'' of bottom part > RMAX_CM''//)')
          ICM_CHAMBER, IM-N_CHM_CHAMBER-N_TOP_CHAMBER;
        ]
        RCYS2_CHAMBER(IM,1)=RCYS_CHAMBER(IM,1)**2;
        "note: each layer has 2 regions in this part"
        IRA = IRA+1;"for inner region of this layer"
        IR_CHAMBER =IR_CHAMBER +1;
        ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),',
        'IREGION_TO_BIT for inner region'/' :',$);
        ;MINPUT (CHAMBER) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
           IREGION_TO_BIT(IRA); (2F15.0,2I5);
        IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
        IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
        ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
          IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
        OUTPUT;(' For inner region :',$);
        ;$MED_INPUT(CHAMBER);
        MED(IRA) = MED_INDEX;
        IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_CHAMBER, IM-N_CHM_CHAMBER-N_TOP_CHAMBER,$MAX_DOSE_ZONE;
         (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'DOSE_ZONE # of inner cylinder in layer ',I4,
          ' of bottom part > $MAX_DOSE_ZONE.'/
          'DOSE_ZONE # set to ',I4,' for now.'/
  'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
            DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
            IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
        ]
        ELSEIF(DOSE_ZONE(IRA).NE.0)[
           IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
           ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
           ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
        ]
        IRA = IRA+1;"for outer region of this layer"
        IR_CHAMBER =IR_CHAMBER +1;
        ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),',
        'IREGION_TO_BIT for outer region'/' :',$);
        ;MINPUT (CHAMBER) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
           IREGION_TO_BIT(IRA); (2F15.0,2I5);
        IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
        IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
        ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
            IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
        OUTPUT;(' For outer region :',$);
        ;$MED_INPUT(CHAMBER);
        MED(IRA) = MED_INDEX;
        IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_CHAMBER, IM-N_CHM_CHAMBER-N_TOP_CHAMBER,$MAX_DOSE_ZONE;
          (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'DOSE_ZONE # of outer annulus in layer ',I4,
          ' of bottom part > $MAX_DOSE_ZONE.'/
          'DOSE_ZONE # set to ',I4,' for now.'/
   'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
           DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
           IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
        ]
        ELSEIF(DOSE_ZONE(IRA).NE.0)[
           IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
           ZPLOTCHM(DOSE_ZONE(IRA))=Z_CHAMBER(IM);
           ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_CHAMBER(IM+1);
        ]
     ]"end of do loop"
  ]"end of non-equal thickness, etc."
]"end of bottom part"


ZTHICK_CHAMBER=THICK1+THICK2+THICK3;"total thickness of the component module"
ZMAX_CHAMBER=ZMIN_CHAMBER+ZTHICK_CHAMBER;
"
"  parameter definition
"  ====================
"
"establish the front surface of this CM, if it is the first module,
"Z_min_CM(1) will be given by the user in BEAM general inputs.

ZFRONT_CHAMBER = Z_min_CM(ICM_CHAMBER);
"
"establish start of next CM
"
Z_min_CM(ICM_CHAMBER+1) = ZMAX_CHAMBER;

"
"
"  set up the air gap, if present
"  =========================================
"
"  The air gap has the highest region number in the CM, even though it is at
"  the top of the component module.  This is to allow the assignment of region
"  numbers on input of the parameters of each local region (mainly to assign the
"  medium number of the region).  The air gap is then assigned after all of the
"  CM parameters have been input.
"
"note that if this is the first CM (ICM_$chamber=1) then the gap thickness
"Z_gap_THICK(ICM_$chamber) = ZMIN_CHAMBER - Z_min_CM(1),
"which is used as a flag whether there is an air gap.

Z_gap_THICK(ICM_CHAMBER) = ZMIN_CHAMBER - Z_min_CM(ICM_CHAMBER);

IF (Z_gap_THICK(ICM_CHAMBER) = 0.0)[
   Z_gap_THICK(ICM_CHAMBER) = 0.;
   N_GAP_CHAMBER = 0; "no air gap is needed for this CM
]
ELSE[
   N_GAP_CHAMBER = 1; "this CM has an air gap"
   OUTPUT Z_min_CM(ICM_CHAMBER),ZMIN_CHAMBER;
   (/' THERE WILL BE AN AIR GAP SET UP BETWEEN Z=',F8.4,' AND Z=',F8.4/);
   IRA = IRSTART_CHAMBER+N_CHAMBER; "absolute region number of air gap
   MED(IRA) = AIR_INDEX; "medium is air
   ECUT(IRA)=ECUTIN;
   PCUT(IRA)=PCUTIN;
   ESAVE(IRA)=ESAVE_GLOBAL;
   ECUTRR(IRA)=ECUT(IRA);
]

"
"  set up region numbers
"  =====================
"
"  This CM has N_CHAMBER+N_GAP_$chamber regions
"
;
IREND_CHAMBER = (IRSTART_CHAMBER -1) +N_CHAMBER+N_GAP_CHAMBER;
       "Index of last region"
NREG = NREG+N_CHAMBER+N_GAP_CHAMBER;
       "Total number of regions in full geometry up"
       "to and including this CM"
IF (NREG <= $MXREG)[
   IR_start_CM(ICM_CHAMBER+1) = IREND_CHAMBER+1;
   "It has not exceeded maximum region number. "
   "Index of first region in next CM:"
]
ELSE[
   OUTPUT ICM_CHAMBER,NREG,$MXREG;
   (//'***ERROR IN CM ',I4,' (CHAMBER):'/
      I4,' regions requested, only ',I4,' available'//);
   IERR_GEOM(ICM_CHAMBER)=IERR_GEOM(ICM_CHAMBER)+1;
]

"  Establish CM boundary
"  =====================
RMAX_CM_FLAG(ICM_CHAMBER) = 1; "put a boundary about CM"
"
"  Establish dose-scoring zones and bit setting for each region
"  ============================================================
"
IRA = IRSTART_CHAMBER-1; "absolute region number"
DO IR_CHAMBER=1,N_CHAMBER["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones"
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE);"Number of dose zones"
   IF(NDOSE_ZONE>$MAX_DOSE_ZONE)[
      OUTPUT;(///' IN CHAMBER, NDOSE_ZONE OUT OF RANGE!!!'///);
      STOP;
   ]
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT); " current maxmum"
   "charged particle range rejection parameters"
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are"
                            "considered for range rejection"
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region"
   E_min_out(ICM_CHAMBER)=ECUT(IRA); "Minimum energy on exit from CM"
] "end of loop over IR_CHAMBER"

"Set up minimum thicknesses for range rejection purposes. In this case "
"we check the last 5 slabs. If we ever need more than 5 slabs, we should"
"extend this or do something fancy like group similar materials."
"Only do this for the central ion chamber part "

I=1; J=1;        " J is index for Z_min_thick , I for layer index "
LOOP[
   Z_min_thick(ICM,J)=0.0;     " init. "
   IRA = I + IRSTART_CHAMBER-1;   "absolute region"
   IF( MED(IRA)~=1) [" AIR WILL BE COUNTED AFTERWARDS "
       MED_min_thick(ICM, J)=MED(IRA);
       Z_min_thick(ICM,J) = Z_CHAMBER(I+1)-Z_CHAMBER(I);
       " first assignment "
   ]
   DO IR_CHAMBER=I+1, N_CHM_CHAMBER [
      "loop through all the layers, if same med added together"
       IRA = IR_CHAMBER + IRSTART_CHAMBER-1;   "absolute region"
       IF( MED(IRA)=MED_min_thick(ICM, J) )[
           Z_min_thick(ICM,J) =Z_min_thick(ICM,J)+
           (Z_CHAMBER(IR_CHAMBER+1)-Z_CHAMBER(IR_CHAMBER-1+1));
       ]
   ]     " end of the do loop "
   " now figure out where the next index I(layer) begins with "
   DO IR_CHAMBER=I+1, N_CHM_CHAMBER[
       IRA = IR_CHAMBER + IRSTART_CHAMBER-1;   "absolute region"
       III=0;
       DO II=J, 1, -1[
         IF(MED(IRA)~=MED_min_thick(ICM, II) & MED(IRA)~=1)[ III=III+1; ]
       ]
       IF( III=J )  " the next med is different from all the before "
         [ I=IR_CHAMBER; J=J+1; EXIT; ]   " keep the i as the next index "
                                         " J increases by one  "
   ]
]WHILE( I<=N_CHM_CHAMBER & J<=5 & IR_CHAMBER<=N_CHM_CHAMBER );

IF(J < 5  )[  "some not used"
    DO I=1, N_TOP_CHAMBER+N_BOT_CHAMBER[
       IRA = N_CHM_CHAMBER+3+2*(I-1)+1+IRSTART_CHAMBER-1;
       "absolute region"
       IF( RCYS_CHAMBER(N_CHM_CHAMBER+I, 1) >= RMAX_CM(ICM_CHAMBER)
          & MED(IRA)~=1 )[
           IF(J<5)[ J=J+1; ]
           ELSE[ EXIT; ]
           MED_min_thick(ICM, J)=MED(IRA);
           IF(I=1 & N_TOP_CHAMBER~=0 )[
              Z_min_thick(ICM,J) = (  Z_CHAMBER(I+N_CHM_CHAMBER+1)
                                       -ZMIN_CHAMBER);
           ]
           ELSEIF(I=N_TOP_CHAMBER+1)[
              Z_min_thick(ICM,J) = (  Z_CHAMBER(I+N_CHM_CHAMBER+1)
                                       -Z_CHAMBER(N_CHM_CHAMBER+1) );
           ]
           ELSE[
              Z_min_thick(ICM,J) = ( Z_CHAMBER(I+N_CHM_CHAMBER+1)
                                      -Z_CHAMBER(I-1+N_CHM_CHAMBER+1) );
           ]
       ]
    ]     " end of the do loop "
]

IF(J < 5)[  "some not used"
    Zminthick=0.0;
    DO I=1, J [  Zminthick=Zminthick+Z_min_thick(ICM, I); ]
    J=J+1;
    Z_min_thick(ICM, J)=ZTHICK_CHAMBER+Z_gap_thick(ICM_CHAMBER)-Zminthick;
    MED_min_thick(ICM,J) = AIR_INDEX; "AIR_INDEX is 0 or 1"
    DO I = J+1,5[
        Z_min_thick(ICM,I) = 0.0;
        MED_min_thick(ICM,I) = 0;
    ]"end of do loop on I"
]"end J < 5 case"

OUTPUT; (/' MRNGE: ENTER 1 to estimate thickness of CHAMBER for ECUTRR'/
          ' calculations in automated range rejection; otherwise, do'/
          ' not calculate ECUTRR',$);
;MINPUT (CHAMBER) MRNGE; (I5);
OUTPUT MRNGE;(I5);
OUTPUT; (' ');
IF(MRNGE~=1)[
    DO I=1, 5[Z_min_thick(ICM,I)=0.0; MED_min_thick(ICM,I)=0; ]
]
ELSE[
   OUTPUT; (/'          Z_min_thick ,     MED_min_thick  ');
   DO I=1, 5[
       IF( Z_min_thick(ICM,I)~=0.0 )[
          OUTPUT Z_min_thick(ICM,I), MED_min_thick(ICM,I);
          (10X, F8.4, 10X, I5);
       ]
   ]
]

"  return from INPUT_CHAMBER
"  =======================
"
RETURN;

"  error messages
"  ==============
"
:EOF_CHAMBER:
;OUTPUT ICM;
(//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_CHAMBER:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;

"  end of INPUT_CHAMBER
"  ==================
"
END;  "End of INPUT_CHAMBER"

%E    "Start of subroutine ISUMRY_CHAMBER"
"*******************************************************************************
"
"                          Subroutine ISUMRY_CHAMBER
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_CHAMBER;


;IMPLICIT NONE;

;COMIN/
   BOUNDS,CMs,CM_CHAMBER,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER,EGS-IO/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_CHAMBER
"T>**********************************
"T>

INTEGER
   ICOLOUR, "T>colour of CM for EGS_Windows
   IRA,     "T>absolute region number
   LAYER,
   I,J;     "T>DO loop index

$REAL  PIL,VOL_CHAMBER($MAX_N_CHAMBER);  "T>cylinder volume
"   Mass of dose zone
"   =================
"
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_$chamber.
PIL=4.0*ATAN(1.0);

I=0;
LOOP[
   I = I+1;
   IF( I<=N_CHM_CHAMBER ) [ LAYER=I; ]
   ELSEIF(I<=N_CHM_CHAMBER+3 ) [ LAYER=1; ]
   ELSE
     [LAYER=N_CHM_CHAMBER+(I-N_CHM_CHAMBER-3+1)/2;]
     " this will be used only for the top and bottom parts "
   IF(I<=N_CHM_CHAMBER)
   [
      VOL_CHAMBER(I)=PIL*RCYS2_CHAMBER(1,1)*(Z_CHAMBER(I+1)-
          Z_CHAMBER(I));
   ]
   ELSEIF( I=N_CHM_CHAMBER+1 )
   [
       VOL_CHAMBER(I)=PIL*(RCYS2_CHAMBER(1,2)-RCYS2_CHAMBER(1,1))
                   *(Z_CHAMBER(N_CHM_CHAMBER+1)-Z_CHAMBER(1));
   ]
   ELSEIF( I=N_CHM_CHAMBER+2 )
   [
       VOL_CHAMBER(I)=PIL*(RCYS2_CHAMBER(1,3)-RCYS2_CHAMBER(1,2))
                   *(Z_CHAMBER(N_CHM_CHAMBER+1)-Z_CHAMBER(1));
   ]
   ELSEIF( I=N_CHM_CHAMBER+3 )
   [
       VOL_CHAMBER(I)=PIL*( RMAX_CM(ICM_CHAMBER)*RMAX_CM(ICM_CHAMBER)
                   -RCYS2_CHAMBER(1,3))
                   *(Z_CHAMBER(N_CHM_CHAMBER+1)-Z_CHAMBER(1));
   ]
   ELSE
   [
       IF( (LAYER.EQ.N_CHM_CHAMBER+1) .AND. (N_TOP_CHAMBER.NE.0))
       [VOL_CHAMBER(I)=PIL*RCYS2_CHAMBER(LAYER,1)*(Z_CHAMBER(LAYER+1)
             -ZMIN_CHAMBER);]
       ELSEIF( LAYER=N_CHM_CHAMBER+N_TOP_CHAMBER+1 )
       [
           VOL_CHAMBER(I)=PIL*RCYS2_CHAMBER(LAYER,1)
                        *(Z_CHAMBER(LAYER+1)-Z_CHAMBER(N_CHM_CHAMBER+1));
       ]
       ELSE
       [VOL_CHAMBER(I)=PIL*RCYS2_CHAMBER(LAYER,1)*(Z_CHAMBER(LAYER+1)
                         -Z_CHAMBER(LAYER-1+1));
       ]
       I=I+1;
       IF( (LAYER.EQ.N_CHM_CHAMBER+1) .AND. (N_TOP_CHAMBER.NE.0))
       [
            VOL_CHAMBER(I)=PIL*( RMAX_CM(ICM_CHAMBER)*RMAX_CM(ICM_CHAMBER)
                              -RCYS2_CHAMBER(LAYER,1) )
                           *(Z_CHAMBER(LAYER+1)-ZMIN_CHAMBER);
       ]
       ELSEIF( LAYER=N_CHM_CHAMBER+N_TOP_CHAMBER+1 )
       [
            VOL_CHAMBER(I)=PIL*( RMAX_CM(ICM_CHAMBER)*RMAX_CM(ICM_CHAMBER)
                              -RCYS2_CHAMBER(LAYER,1) )
                       *(Z_CHAMBER(LAYER+1)-Z_CHAMBER(N_CHM_CHAMBER+1));
       ]
       ELSE
       [
            VOL_CHAMBER(I)=PIL*( RMAX_CM(ICM_CHAMBER)*RMAX_CM(ICM_CHAMBER)
                              -RCYS2_CHAMBER(LAYER,1) )
                       *(Z_CHAMBER(LAYER+1)-Z_CHAMBER(LAYER-1+1));
       ]
   ]
]UNTIL (I>=N_CHAMBER);

DO I = 1,N_CHAMBER
[ IF( VOL_CHAMBER(I) <=0.0 ) [
OUTPUT I;(/' LOCAL REGION',I4,' IN CHAMBER HAS ZERO VOLUME!'/);
"VOL_CHAMBER(I)=1.0;" ] ]

IRA = IRSTART_CHAMBER-1; "absolute region number
DO IR_CHAMBER=1,N_CHAMBER+N_GAP_CHAMBER ["loop over local region number
   IRA = IRA+1;
   IF(DOSE_ZONE(IRA).NE.0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+VOL_CHAMBER(IR_CHAMBER)*RHOR(IRA);
   ]
] "end of loop over IR_CHAMBER"

"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"
WRITE(IOUTLIST,110) ICM_CHAMBER,TITLE_CHAMBER;
WRITE(IOUTLIST,111) Z_min_CM(ICM_CHAMBER),RMAX_CM(ICM_CHAMBER);

"AIR GAP, IF PRESENT "
IF(N_GAP_CHAMBER~=0)[
   IRA=IRSTART_CHAMBER+N_CHAMBER;
   WRITE(IOUTLIST,1501);
   WRITE(IOUTLIST,1504)N_CHAMBER+1,
                       'NA',Z_min_CM(ICM_CHAMBER),ZMIN_CHAMBER-
                       Z_min_CM(ICM_CHAMBER),RMAX_CM(ICM_CHAMBER),
                       ECUT(IRA),PCUT(IRA),
                       ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
                       (MEDIA(J,MED(IRA)),J=1,9);
   WRITE(IOUTLIST,1505);
]
" ION CHAMBER TOP PART "
IRA = IRSTART_CHAMBER-1+3+N_CHM_CHAMBER;
IF( N_TOP_CHAMBER~=0) [ WRITE(IOUTLIST,1204); ]
DO IR_CHAMBER=N_CHM_CHAMBER+1,N_CHM_CHAMBER+N_TOP_CHAMBER [
   IRA = IRA+1;
   I=(IR_CHAMBER-N_CHM_CHAMBER-1)*2+N_CHM_CHAMBER+3+1;
   IF( IR_CHAMBER=N_CHM_CHAMBER+1 ) [
      IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1304) I,IR_CHAMBER-N_CHM_CHAMBER,
         ZMIN_CHAMBER,Z_CHAMBER(IR_CHAMBER+1)-ZMIN_CHAMBER,
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1304)I,IR_CHAMBER-N_CHM_CHAMBER,
         ZMIN_CHAMBER,Z_CHAMBER(IR_CHAMBER+1)-ZMIN_CHAMBER,
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]
   ELSE[
      IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1304)I,IR_CHAMBER-N_CHM_CHAMBER,
         Z_CHAMBER(IR_CHAMBER),Z_CHAMBER(IR_CHAMBER+1)-
         Z_CHAMBER(IR_CHAMBER),
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1304) I,IR_CHAMBER-N_CHM_CHAMBER,
         Z_CHAMBER(IR_CHAMBER),Z_CHAMBER(IR_CHAMBER+1)-
         Z_CHAMBER(IR_CHAMBER),
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]

   IRA = IRA+1;
   I=I+1;
   IF( IR_CHAMBER=N_CHM_CHAMBER+1 ) [
     IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1305) I,IR_CHAMBER-N_CHM_CHAMBER,
         ZMIN_CHAMBER,Z_CHAMBER(IR_CHAMBER+1)-
         ZMIN_CHAMBER,
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
     ]
     ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1305) I,IR_CHAMBER-N_CHM_CHAMBER,
         ZMIN_CHAMBER,Z_CHAMBER(IR_CHAMBER+1)-
         ZMIN_CHAMBER,
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
   ELSE[
     IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1305) I,IR_CHAMBER-N_CHM_CHAMBER,
         Z_CHAMBER(IR_CHAMBER),Z_CHAMBER(IR_CHAMBER+1)-
         Z_CHAMBER(IR_CHAMBER),
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
     ]
     ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1305) I,IR_CHAMBER-N_CHM_CHAMBER,
         Z_CHAMBER(IR_CHAMBER),Z_CHAMBER(IR_CHAMBER+1)-
         Z_CHAMBER(IR_CHAMBER),
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
]

WRITE(IOUTLIST,120);
IRA = IRSTART_CHAMBER-1;"for chamber part"
DO IR_CHAMBER=1,N_CHM_CHAMBER [
   IRA = IRA+1;
   IF (MED(IRA)=0) ["Medium is vacuum"
      /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
      WRITE(IOUTLIST,130) IR_CHAMBER,IR_CHAMBER,'layer',
      Z_CHAMBER(IR_CHAMBER),
      Z_CHAMBER(IR_CHAMBER+1)-Z_CHAMBER(IR_CHAMBER),
      RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
      ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
   ]
   ELSE
   ["Medium is not vacuum"
      WRITE(IOUTLIST,130) IR_CHAMBER,IR_CHAMBER,'layer',
      Z_CHAMBER(IR_CHAMBER),
      Z_CHAMBER(IR_CHAMBER+1)-Z_CHAMBER(IR_CHAMBER),
      RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
      ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
      (MEDIA(J,MED(IRA)),J=1,9);
   ]
]

" ion chamber side wall part "
IRA=IRA+1;
WRITE(IOUTLIST,1201);
IF (MED(IRA)=0) ["Medium is vacuum"
    /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
    WRITE(IOUTLIST,1301) IR_CHAMBER,'NA','entire',
         Z_CHAMBER(0+1),
         Z_CHAMBER(N_CHM_CHAMBER+1)-Z_CHAMBER(0+1),
         RCYS_CHAMBER(1,1), RCYS_CHAMBER(1,2),ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
]
ELSE ["Medium is not vacuum"
     WRITE(IOUTLIST,1301) IR_CHAMBER,'NA','entire',
         Z_CHAMBER(0+1),
         Z_CHAMBER(N_CHM_CHAMBER+1)-Z_CHAMBER(0+1),
         RCYS_CHAMBER(1,1), RCYS_CHAMBER(1,2),ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,8);
]
WRITE(IOUTLIST,1310)'wall';
" ion chamber side air gap part "
IRA=IRA+1;
WRITE(IOUTLIST,1202);
IF (MED(IRA)=0) ["Medium is vacuum"
    /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
    WRITE(IOUTLIST,1302) IR_CHAMBER+1,'NA','entire',
         Z_CHAMBER(0+1),
         Z_CHAMBER(N_CHM_CHAMBER+1)-Z_CHAMBER(0+1),
         RCYS_CHAMBER(1,2), RCYS_CHAMBER(1,3), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
]
ELSE ["Medium is not vacuum"
     WRITE(IOUTLIST,1302) IR_CHAMBER+1,'NA','entire',
         Z_CHAMBER(0+1),
         Z_CHAMBER(N_CHM_CHAMBER+1)-Z_CHAMBER(0+1),
         RCYS_CHAMBER(1,2), RCYS_CHAMBER(1,3), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,8);
]
WRITE(IOUTLIST,1311)'gap';
" ion chamber's container wall part "
IRA=IRA+1;
WRITE(IOUTLIST,1203);
IF (MED(IRA)=0) ["Medium is vacuum"
    /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
    WRITE(IOUTLIST,1303) IR_CHAMBER+2,'NA','entire',
     Z_CHAMBER(0+1),
     Z_CHAMBER(N_CHM_CHAMBER+1)-Z_CHAMBER(0+1),
         RCYS_CHAMBER(1,3), RMAX_CM(ICM_CHAMBER),
         ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
]
ELSE ["Medium is not vacuum"
     WRITE(IOUTLIST,1303) IR_CHAMBER+2,'NA','entire',
     Z_CHAMBER(0+1),
     Z_CHAMBER(N_CHM_CHAMBER+1)-Z_CHAMBER(0+1),
         RCYS_CHAMBER(1,3), RMAX_CM(ICM_CHAMBER),
         ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,8);
]
WRITE(IOUTLIST,1312)'wall';

" ION CHAMBER BOTTOM PART "
IRA = IRSTART_CHAMBER-1+3+N_CHM_CHAMBER+2*N_TOP_CHAMBER;
IF( N_BOT_CHAMBER~=0 ) [ WRITE(IOUTLIST,1206); ]
DO IR_CHAMBER=N_CHM_CHAMBER+N_TOP_CHAMBER+1,
                 N_CHM_CHAMBER+N_TOP_CHAMBER+N_BOT_CHAMBER[
   IRA = IRA+1;
   I=(IR_CHAMBER-N_CHM_CHAMBER-1)*2+N_CHM_CHAMBER+3+1;
   IF( IR_CHAMBER=N_CHM_CHAMBER+N_TOP_CHAMBER+1 )[
     IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1306)
         I,IR_CHAMBER-N_CHM_CHAMBER-N_TOP_CHAMBER,
         Z_CHAMBER(N_CHM_CHAMBER+1),Z_CHAMBER(IR_CHAMBER+1)-
         Z_CHAMBER(N_CHM_CHAMBER+1),
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
     ]
     ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1306)
         I,IR_CHAMBER-N_CHM_CHAMBER-N_TOP_CHAMBER,
         Z_CHAMBER(N_CHM_CHAMBER+1),Z_CHAMBER(IR_CHAMBER+1)-
         Z_CHAMBER(N_CHM_CHAMBER+1),
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
   ELSE[
      IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1306)
         I,IR_CHAMBER-N_CHM_CHAMBER-N_TOP_CHAMBER,
         Z_CHAMBER(IR_CHAMBER),Z_CHAMBER(IR_CHAMBER+1)-
         Z_CHAMBER(IR_CHAMBER),
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1306)
         I,IR_CHAMBER-N_CHM_CHAMBER-N_TOP_CHAMBER,
         Z_CHAMBER(IR_CHAMBER),Z_CHAMBER(IR_CHAMBER+1)-
         Z_CHAMBER(IR_CHAMBER),
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]

   IRA = IRA+1;
   I=I+1;
   IF( IR_CHAMBER=N_CHM_CHAMBER+N_TOP_CHAMBER+1 ) [
      IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1307)
         I,IR_CHAMBER-N_CHM_CHAMBER-N_TOP_CHAMBER,
         Z_CHAMBER(N_CHM_CHAMBER+1),Z_CHAMBER(IR_CHAMBER+1)-
         Z_CHAMBER(N_CHM_CHAMBER+1),
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1307)
         I,IR_CHAMBER-N_CHM_CHAMBER-N_TOP_CHAMBER,
         Z_CHAMBER(N_CHM_CHAMBER+1),Z_CHAMBER(IR_CHAMBER+1)-
         Z_CHAMBER(N_CHM_CHAMBER+1),
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]
   ELSE[
     IF (MED(IRA)=0)["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1307)
         I,IR_CHAMBER-N_CHM_CHAMBER-N_TOP_CHAMBER,
         Z_CHAMBER(IR_CHAMBER),Z_CHAMBER(IR_CHAMBER+1)-
         Z_CHAMBER(IR_CHAMBER),
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
     ]
     ELSE["Medium is not vacuum"
         WRITE(IOUTLIST,1307)
         I,IR_CHAMBER-N_CHM_CHAMBER-N_TOP_CHAMBER,
         Z_CHAMBER(IR_CHAMBER),Z_CHAMBER(IR_CHAMBER+1)-
         Z_CHAMBER(IR_CHAMBER),
         RCYS_CHAMBER(IR_CHAMBER,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
]

DO I=1,N_CHAMBER[IF(VOL_CHAMBER(I)<=0.0 )[WRITE(IOUTLIST,141)I;]]

110 FORMAT(///1x,79('-')/
            '  Component module',I3,' is an ion chamber or phantom ',
            '(CHAMBER)'/ 1x,79('-')//T5,'Title: ',68A1);
111 FORMAT(/T2,'CHAMBER region & geometry parameters:',
           /T2,'-------------------------------------',
           /T2,'Distance of front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Radius of outer boundary of CM = ',F15.5,' cm');

120 FORMAT(/T5,'CHAMBER CENTRAL PART parameters:',
           /T5,'--------------------------------',
           /T1,' local layer loc.   Z    Zthick  rad.  electr photon',
           ' range-reject  dose  medium',
           /T1,' reg              front                cutoff cutoff',
           ' level   max   zone'
           /T1,'                   (cm)    (cm)  (cm)   (MeV)  (MeV)',
           ' (MeV)  (MeV)');
130 FORMAT(T1,I3,I5,A7,F8.3,F8.4,F7.3,4F7.3,I3,2X,9A1);
131 FORMAT(T9,A8);
1201 FORMAT(/T5,'CHAMBER WALL parameters:',
           /T5,'--------------------------',
        /T1,' local layer loc.  Z    Zthick     rad.     electr photon',
        ' range-reject dose med',
        /T1,' reg             front         inner  outer cutoff cutoff',
        ' level  max   zone'
        /T1,'                 (cm)    (cm)      (cm)      (MeV)  (MeV)',
        ' (MeV) (MeV)');
1301 FORMAT(T1,I3,A4,A7,F8.3,F7.3,2F7.3,2F6.3,F7.3,F6.3,I3,1X,8A1);
1310 FORMAT(T8,A7);
1202 FORMAT(/T5,'CHAMBER side air gap parameters:',
           /T5,'---------------------------------',
        /T1,' local layer loc.  Z    Zthick     rad.     electr photon',
        ' range-reject dose med',
        /T1,' reg             front         inner  outer cutoff cutoff',
        ' level  max   zone'
        /T1,'                 (cm)    (cm)      (cm)      (MeV)  (MeV)',
        ' (MeV) (MeV)');
1302 FORMAT(T1,I3,A4,A7,F8.3,F7.3,2F7.3,2F6.3,F7.3,F6.3,I3,1X,8A1);
1311 FORMAT(T8,A7);
1203 FORMAT(/T5,'CHAMBER container wall parameters:',
           /T5,'-----------------------------------',
        /T1,' local layer loc.  Z    Zthick     rad.     electr photon',
        ' range-reject dose med',
        /T1,' reg             front         inner  outer cutoff cutoff',
        ' level  max   zone'
        /T1,'                 (cm)    (cm)      (cm)      (MeV)  (MeV)',
        ' (MeV) (MeV)');
1303 FORMAT(T1,I3,A4,A7,F8.3,F7.3,2F7.3,2F6.3,F7.3,F6.3,I3,1X,8A1);
1312 FORMAT(T8,A7);
1204 FORMAT(/T5,'CHAMBER TOP PART parameters:',
           /T5,'-----------------------------',
           /T1,' local layer loc.   Z    Zthick  inner electr photon',
           ' range-reject  dose  medium',
           /T1,' reg              front           rad. cutoff cutoff',
           ' level   max   zone'
           /T1,'                   (cm)   (cm)    (cm)  (MeV)  (MeV)',
           ' (MeV)  (MeV)');
1304 FORMAT(T1,I3,I5,'  inner',F8.3,F8.4,5F7.3,I3,2X,9A1);
1305 FORMAT(T1,I3,I5,'  outer',F8.3,F8.4,5F7.3,I3,2X,9A1);
1206 FORMAT(/T5,'CHAMBER BOTTOM PART parameters:',
           /T5,'--------------------------------',
           /T1,' local layer loc.   Z    Zthick  inner electr photon',
           ' range-reject  dose  medium',
           /T1,' reg              front           rad. cutoff cutoff',
           ' level   max   zone'
           /T1,'                   (cm)   (cm)    (cm)  (MeV)  (MeV)',
           ' (MeV)  (MeV)');
1306 FORMAT(T1,I3,I5,'  inner',F8.3,F8.4,5F7.3,I3,2X,9A1);
1307 FORMAT(T1,I3,I5,'  outer',F8.3,F8.4,5F7.3,I3,2X,9A1);
1501 FORMAT(/T5,'Air gap parameters:',
           /T5,'-------------------',
           /T1,' local layer loc.   Z    Zthick   rad. electr photon',
           ' range-reject  dose  medium',
           /T1,' reg              front                cutoff cutoff',
           ' level   max   zone'
           /T1,'                   (cm)   (cm)    (cm)  (MeV)  (MeV)',
           ' (MeV)  (MeV)');
1504 FORMAT(T1,I3,A5,'  airgap',F8.3,F7.3,5F7.3,I3,2X,9A1);
1505 FORMAT(T8,'   at top');


141 FORMAT(/' LOCAL REGION',I4,' IN CHAMBER HAS ZERO VOLUME!');



"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"

IF(IWATCH = 4 | IZLAST = 2)
[  "Creat a graphics file "
   ;$SELECT-COLOUR;
    DO I=1, N_CHM_CHAMBER+N_TOP_CHAMBER+N_BOT_CHAMBER
    [
       WRITE(IOUTGEOM,201)ICOLOUR,'CYLZ',Z_CHAMBER(I-1+1),
                      RCYS_CHAMBER(I,1),
                Z_CHAMBER(I+1),RCYS_CHAMBER(I,1),0.0,0.0;
    ]
]"End of graphics output"

201   FORMAT(' ',I1,A4,10(F7.2,','));


"   end of ISUMRY_CHAMBER
"   ===================
"
RETURN;
END; "End of subroutine ISUMRY_CHAMBER"
%E "Start of subroutine HOWNEAR_CHAMBER
"*******************************************************************************
"
SUBROUTINE HOWNEAR_CHAMBER(DIST);
"
" Returns min. distance to nearest region boundary
" Used to be a function, but changed to a subroutine for convenience
"  and consistency.
"*******************************************************************************
$IMPLICIT-NONE;

;COMIN/CM_CHAMBER,STACK/;

INTEGER LAYER;
$REAL RF_CHAMBER, RF2_CHAMBER, DIST;

IR_CHAMBER=IR(NP)-IRSTART_CHAMBER+1;"local region # "

" CALC. THE LAYER # "
IF( IR_CHAMBER<=N_CHM_CHAMBER ) [ LAYER=IR_CHAMBER; ]
ELSEIF(IR_CHAMBER<=N_CHM_CHAMBER+3 ) [ LAYER=1; ]
ELSEIF(IR_CHAMBER<=N_CHAMBER)[
    LAYER=N_CHM_CHAMBER+(IR_CHAMBER-N_CHM_CHAMBER-3+1)/2;
    "last term gives the layer number, i.e., "
    "for region 1 in top part, the layer number(integer)=(1+1)/2=1"
    "for region 2 in top part, the layer number(integer)=(2+1)/2=1"
    "for region 3 in top part, the layer number(integer)=(3+1)/2=2"
    "......                                        changed by CMa."
    " this will be used only for the top and bottom parts         "
]

RF2_CHAMBER=X(NP)**2+Y(NP)**2;
RF_CHAMBER=SQRT(RF2_CHAMBER);
IF( IR_CHAMBER<=N_CHM_CHAMBER ) [" inside the main ion chamber part "
    DIST=MIN(  Z(NP)-Z_CHAMBER(LAYER),   " upstream "
    Z_CHAMBER(LAYER+1)-Z(NP),     " downstream"
    RCYS_CHAMBER(LAYER,1)-RF_CHAMBER  );
    RETURN;
]
ELSEIF( IR_CHAMBER<=N_CHM_CHAMBER +3 )  [
    " in the side wall or side gap or container wall "
    DIST=MIN(  Z(NP)-Z_CHAMBER(1),      " upstream "
    Z_CHAMBER(N_CHM_CHAMBER+1)-Z(NP),  " downstream "
    ABS( RF_CHAMBER -RCYS_CHAMBER(1, 1) ),
    ABS( RF_CHAMBER -RCYS_CHAMBER(1, 2) ),
    ABS( RF_CHAMBER -RCYS_CHAMBER(1, 3) ) );
    RETURN;
]
ELSEIF( IR_CHAMBER<=N_CHAMBER )[   " except air gap. "
    DIST=MIN(  Z(NP)-ZMIN_CHAMBER,
    " check the front face of the 1st layer in the top"
    ABS( Z(NP)-Z_CHAMBER(1) ),
    " check the back face of the last layer in the top"
    ABS( Z(NP)-Z_CHAMBER(N_CHM_CHAMBER+1) ),
    " check the front face for the 1st layer in the bottom"
    ZMAX_CHAMBER-Z(NP),        " back face for the last in the bottom "
    ABS(Z(NP)-Z_CHAMBER(LAYER)),  " except the above case "
    "this is for the front face of the layer"
    ABS(Z_CHAMBER(LAYER+1)-Z(NP)),
    "this is for the back face of the layer"
    "note we use ABS because the front face in the top layer"
    "and the back face of the bottom layer may not be Z_CHAMBER(LAYER)"
    "and Z_CHAMBER(LAYER+1)     --CMa"
    ABS( RCYS_CHAMBER(LAYER,1)-RF_CHAMBER ) );
    RETURN;
]
ELSEIF( IR(NP)=IREND_CHAMBER & N_GAP_CHAMBER=1)[
    DIST=MIN(Z(NP)-ZFRONT_CHAMBER, ZMIN_CHAMBER-Z(NP));
    RETURN;
]
RETURN;
END; "End of subroutine HOWNEAR_CHAMBER"
"End of CHAMBER_cm.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: mirror plane                              "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Iwan Kawrakow                                             "
"                   Ernesto Mainegra-Hing                                     "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code originally evolved from the MIRR component module written by     "
"  George Ding, starting in 1992, and subsequently edited by Charlie Ma.      "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             ***********              ""toc:
"                             *         *              ""toc:
"                             * MIRROR  *              ""toc:
"                             *         *              ""toc:
"                             ***********              ""toc:
"
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.  A mirror plane of arbitrary layer,thickness and
"   material in air.
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator:  a mirror.
"
%E   "MIRROR_cm.mortran  -- start of geometry picture"
"I>
"I> Geometry of MIRROR:
"I> ******************
"I>
"I>                          |         | \ \ \   IR = N+1   |
"I>                          |         |\ \ \ \             |
"I>                          |         | \ \ \ \            |
"I>                          |         |  \ \ \ \           |
"I>                          |         |   \ \ \ \          |
"I>      ----------->        | IR= N+3 |    \ \ \ \         |
"I>                          |         |   IR=1,2,N\        |
"I>      beam direction      |         |      \ \ \ \       |
"I>                          |         |       \ \ \ \      |
"I>                          |         |        \ \ \ \     |
"I>                          |         |         \ \ \ \    |
"I>                          |         |          \ \ \ \   |
"I>                          |         |           \ \ \ \  |
"I>                          |         |            \ \ \ \ |
"I>                          |         |  IR = N+2   \ \ \ \|
"I>
"I>
"I>   IR is the region number within the CM.  There are three local regions
"I>   shown above.
"I>
"I>
"I>            -------------------------------------------------
"I>            |          Region         | Description         |
"I>            |-------------------------|---------------------|
"I>            |  absolute    | local    |                     |
"I>            |--------------|----------|                     |
"I>            |              |          |                     |
"I>            |IRSTART_MIRROR| IR_MIRROR|  as shown in above  |
"I>            |  +IR_MIRROR-1|          |    (1 to N+3)       |
"I>            |              |          |                     |
"I>            |              |          |                     |
"I>            -------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_MIRROR
"                      ISUMRY_MIRROR
"                      HOWFAR_MIRROR
"                      WHERE_AM_I_MIRROR
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS ON USE/KNOW BUGS
"                             *****************************
"
"
"*******************************************************************************
%E   "MIRROR_cm.mortran  -- start of description of user input file"
"
"                               INPUT FROM UNIT 5       ""toc:
"                               *****************
"
"I>
"I>  CARDS CM_MIRROR
"I>  **************
"I>
"I>  -1  Dummy line to indicate start of CM.
"I>
"I>   0  RMAX_CM(ICM_MIRROR) (F10.0): Half-width of CM boundary (cm).
"I>
"I>   1  TITLE_MIRROR (60A1): Title of CM.
"I>
"I>   2  ZMIN_MIRROR,ZTHICK_MIRROR (2F15.0):
"I>
"I>           ZMIN_MIRROR:   Distance from front of CM(excluding air gap) to
"I>                           ref plane(Z=0).
"I>           ZTHICK_MIRROR: Z-direction span.
"I>
"I>   3  XFMIN_MIRROR, XBMIN_MIRROR (2F15.0):
"I>
"I>           XFMIN_MIRROR:  X value at which front face of mirror
"I>                           intersects ZMIN_MIRROR.
"I>           XBMIN_MIRROR:  X value at which front face of mirror
"I>                           intersects ZMIN_MIRROR + ZTHICK_MIRROR.
"I>      Note restriction:
"I>    5 degrees<ATAN(ZTHICK_MIRROR/(XFMIN_MIRROR-XBMIN_MIRROR)<90 degrees
"I>
"I>   4  N_MIRROR, (I10):    Number of layers
"I>
"I>   Repeat 5 for I=1,N_MIRROR
"I>
"I>   5  DTHICK_MIRROR(I) (F15.0): Thickness of layer I in mirror,
"I>                                 in cm.  Layer 1 is the front face
"I>                                 of the mirror.
"I>
"I>   Repeat 6 and 7 for I=1,N_MIRROR.
"I>
"I>   6  ECUT, PCUT,DOSE_ZONE, IREGION_TO_BIT (2F15.0, 2I5): for each layer
"I>
"I>          ECUT, PCUT:  Cutoff energies for electrons and photons in
"I>                       layer I.
"I>          DOSE_ZONE:   Dose scoring flag in layer I.
"I>     IREGION_TO_BIT:   bit to associate local region of layer I with
"I>
"I>   7  MED_IN (24A1):  Medium of layer I, used to set MED_INDEX.
"I>
"I>   8  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT in region behind mirror
"I>                                                       (2F15.0,2I5):
"I>
"I>         ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   Dose scoring flag, 0 to score dose deposited in it
"I>    IREGION_TO_BIT:   bit to associate local region with
"I>
"I>   9  MED_IN (24A1):  Medium of local region behind the mirror,
"I>                      used to set MED_INDEX.
"I>
"I>   10  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT in region in front of
"I>                                             mirror(2F15.0,2I5):
"I>
"I>         ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   Dose scoring flag, 0 to score dose deposited in it
"I>    IREGION_TO_BIT:   bit to associate local region with
"I>
"I>   11  MED_IN (24A1): Medium of region in front of mirror,
"I>                      used to set MED_INDEX.
"I>
"I>
"I>   Example
"I>   *******
"I>
"I>   The following describes a mirror composed of 1 AL slab.
"I>   The front face of the mirror intersects the front of the
"I>   CM (excluding any airgap) at X=3cm and the back of the CM at X=-3cm.
"I>   The mirror starts at 19.7cm and is 2cm in the z-direction.
"I>   The thickness of the AL slab is 0.00508cm.
"I>   Note that thickness is measured perpendicular to the
"I>   face of the mirror.  AIR is both in front of and behind
"I>   the AL mirror.  No dose is scored in this example.
"I>
"I>   10.00   RMAX_CM
"I>   MIRROR : z=19.5074 downstream, original, dif overlap
"I>   19.70, 2.0
"I>   3.0, -3.0
"I>   1
"I>   0.00508
"I>   0.0, 0.0, 0, 0
"I>   AL
"I>   0.0, 0.0, 0, 0
"I>   AIR
"I>   0.0, 0.0, 0, 0
"I>   AIR
"I>
"I>
"
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules
"
"*******************************************************************************
%E   "start of subroutine HOWFAR_MIRROR"
"*******************************************************************************
"
"                          Subroutine HOWFAR_MIRROR
"                          ***********************
"
" HOWFAR routine for stacked planar media.
"
" Determine if current region number is within component module MIRR, and if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are N_MIRROR local regions :
"
"     local               absolute                       description
"   ------------    ------------------------------     ----------------------
"   IR_MIRROR      IR_start_CM(ICM_MIRROR)+IR_MIRROR-1      as shown above
"   ------------    ------------------------------     -----------------------
"   Geometrical co-ordinates, as set in INPUT_MIRROR are:
"
"   ZFRONT_MIRROR     front of CM (upstream surface, air region)
"   ZMIN_MIRROR       front of mirror
"   ZBACK_MIRROR       back of mirror
"   RMAX_MIRROR       dimmension limit (in x and y)
"
"******************************************************************************
REPLACE {$PRINT_1_N1;} WITH {;
IF( X(NP)-A_MIRROR*Z(NP)+BMAXT_MIRROR(IR_MIRROR) > $BDY_TOL)[
   OUTPUT IR_MIRROR,Z(NP),X(NP),A_MIRROR*Z(NP)+BMAXT_MIRROR(IR_MIRROR);
       (' print1-n1:ir,z, x, a+bmax ',I3,3F16.8);
]
J = J + 1;
IF(J>1000)[STOP;]
}
REPLACE {$PRINT_1_N2;} WITH {;
OUTPUT IR_MIRROR,Z(NP),X(NP),A_MIRROR*Z(NP)+BMINT_MIRROR(IR_MIRROR);
       (' print1-n2:ir,z, x, a+bmin ',I3,3F16.8);
J = J + 1;
IF(J>1000)[STOP;]
}
REPLACE {$PRINT_N+1;} WITH {;
OUTPUT IR_MIRROR,Z(NP),X(NP),A_MIRROR*Z(NP)+BMAX_MIRROR(N_MIRROR);
       (' printn+1:ir,z, x, a+bmax ',I3,3F16.8);
J = J + 1;
IF(J>1000)[STOP;]
}
REPLACE {$PRINT_N+2;} WITH {;
OUTPUT IR_MIRROR,Z(NP),X(NP),A_MIRROR*Z(NP)+BMIN_MIRROR(1);
       (' printn+1:ir,z, x, a+bmax ',I3,3F16.8);
J = J + 1;
IF(J>1000)[STOP;]
}
;SUBROUTINE HOWFAR_MIRROR;


;IMPLICIT NONE;
;COMIN/CMs,CM_MIRROR,EPCONT,STACK,EGS-IO/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_MIRROR
"T>**********************************
"T>
INTEGER
   IRL,           "T>local region number (absolute), required by HOWNEAR macro
   IRNEW_MIRROR, "T>tentative new region number within CM (absolute)
   I,             "T> loop index
   NERROR_M;      "T> number of errors in howfar (particle neglected)

$REAL
   DIST,          "T>distance to region boundary along current trajectory
   XPLN_MIRROR;  "T> Temporary variable
;
" Determine local region number
" *****************************

IRL = IR(NP); "local region number (absolute)

" Set DNEAR
" *********
" This replacement macros sets DMIN_MIRROR as well as defining IR_MIRROR
"
;MIRROR_CM_HOWNEAR(DNEAR(NP));

" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module MIRR, and if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
;
IF(IR_MIRROR > 0 & IR_MIRROR <= N_MIRROR )[   "local region 1 to N
   IF(X(NP) > A_MIRROR*Z(NP)+BMAXT_MIRROR(IR_MIRROR))[
      IRNEW = IRSTART_MIRROR + IR_MIRROR;
      "$PRINT_1_N1;"
      USTEP = 0;
      RETURN;
   ]
   ELSEIF(X(NP) < A_MIRROR*Z(NP)+BMINT_MIRROR(IR_MIRROR))[
      IRNEW = IRSTART_MIRROR + IR_MIRROR - 2;
      IF(IR_MIRROR = 1)[IRNEW = IRSTART_MIRROR + N_MIRROR + 1;]
      "$PRINT_1_N2;"
      USTEP = 0;
      RETURN;
   ]
   IF(W(NP) > 0.0)[
      DIST = (ZBACK_MIRROR - Z(NP))/W(NP);
      IF(DIST<=0.)[DIST=1.E-16;] "ensures call to ausgab if leaving CM"
      IRNEW_MIRROR = 1;
      XPLN_MIRROR = X(NP) + U(NP)*DIST;
      IF(XPLN_MIRROR > XBMAXT_MIRROR(IR_MIRROR))[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR;
         DIST = (A_MIRROR*Z(NP)+BMAXT_MIRROR(IR_MIRROR)
                 -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
      ELSEIF(XPLN_MIRROR < XBMINT_MIRROR(IR_MIRROR))[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR - 2;
         IF(IR_MIRROR = 1)[
            IRNEW_MIRROR = IRSTART_MIRROR + N_MIRROR + 1;
         ]
         DIST = (A_MIRROR*Z(NP)+BMINT_MIRROR(IR_MIRROR)
                -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
   ]
   ELSEIF(W(NP) < 0.0)[
      DIST = (ZMIN_MIRROR - Z(NP))/W(NP);
      IF(DIST<=0. & N_GAP_MIRROR=0)[DIST=1.E-16;]
      XPLN_MIRROR = X(NP) + U(NP)*DIST;
      IRNEW_MIRROR = IREND_MIRROR;
      IF(N_GAP_MIRROR = 0)[IRNEW_MIRROR = 1;]
      IF(XPLN_MIRROR > XFMAXT_MIRROR(IR_MIRROR))[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR;
         DIST = (A_MIRROR*Z(NP)+BMAXT_MIRROR(IR_MIRROR)
                -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
      ELSEIF(XPLN_MIRROR < XFMINT_MIRROR(IR_MIRROR))[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR - 2;
         IF(IR_MIRROR = 1)[
            IRNEW_MIRROR = IRSTART_MIRROR + N_MIRROR + 1;
         ]
         DIST = (A_MIRROR*Z(NP)+BMINT_MIRROR(IR_MIRROR)
                -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
   ]
   ELSE[
      IF(U(NP) > 0.0)[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR;
         DIST = (A_MIRROR*Z(NP)+BMAXT_MIRROR(IR_MIRROR)-X(NP))/U(NP);
      ]
      ELSEIF(U(NP) < 0.0)[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR - 2;
         IF(IR_MIRROR = 1)[
            IRNEW_MIRROR = IRSTART_MIRROR + N_MIRROR + 1;
         ]
         DIST = (A_MIRROR*Z(NP)+BMINT_MIRROR(IR_MIRROR)-X(NP))/U(NP);
      ]
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF(IRNEW_MIRROR=1) ["leaving CM through back"
         IF(W(NP) > 0.0)[CALL WHERE_AM_I(ICM_MIRROR,1);]
         ELSEIF(W(NP) < 0.0)[CALL WHERE_AM_I(ICM_MIRROR,-1);]
      ]
      ELSE ["still in CM, entering between bars
         IRNEW = IRNEW_MIRROR; "new region number"
      ]
   ]
]"end of IR = 1-N

ELSEIF(IR_MIRROR = N_MIRROR + 1)[ "local region N_MIRROR + 1
   IF(X(NP) < A_MIRROR*Z(NP)+BMAX_MIRROR(N_MIRROR))[
      IRNEW = IRSTART_MIRROR + N_MIRROR - 1;
      USTEP = 0;
      RETURN;
   ]
   IF(W(NP) > 0.0)[
      DIST = (ZBACK_MIRROR - Z(NP))/W(NP);
      IF(DIST<=0.)[DIST=1.E-16;]
      IRNEW_MIRROR = 1;
      XPLN_MIRROR = X(NP) + U(NP)*DIST;
      IF(XPLN_MIRROR < XBMAX_MIRROR(N_MIRROR))[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR - 2;
         DIST = (A_MIRROR*Z(NP)+BMAX_MIRROR(N_MIRROR)
                   -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
   ]
   ELSEIF(W(NP) < 0.0)[
      DIST = (ZMIN_MIRROR - Z(NP))/W(NP);
      IF(DIST<=0. & N_GAP_MIRROR = 0)[DIST=1.E-16;]
      IRNEW_MIRROR = IREND_MIRROR;
      IF(N_GAP_MIRROR = 0)[IRNEW_MIRROR = 1;]
      XPLN_MIRROR = X(NP) + U(NP)*DIST;
      IF(XPLN_MIRROR < XFMAX_MIRROR(N_MIRROR))[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR - 2;
         DIST = (A_MIRROR*Z(NP)+BMAX_MIRROR(N_MIRROR)
                  -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
   ]
   ELSE[
      IF(U(NP) < 0.0)[
         IRNEW_MIRROR = IRSTART_MIRROR + IR_MIRROR - 2;
         DIST = (A_MIRROR*Z(NP)+BMAX_MIRROR(N_MIRROR)-X(NP))/U(NP);
      ]
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF(IRNEW_MIRROR=1) ["leaving CM"
         IF(W(NP) > 0.0)[CALL WHERE_AM_I(ICM_MIRROR,1);]
         ELSEIF(W(NP) < 0.0)[CALL WHERE_AM_I(ICM_MIRROR,-1);]
      ]
      ELSE ["still in CM, entering between bars
         IRNEW = IRNEW_MIRROR; "new region number"
      ]
   ]
]
ELSEIF(IR_MIRROR = N_MIRROR + 2)[ "local region N_MIRROR + 2
   IF(X(NP) > A_MIRROR*Z(NP)+BMIN_MIRROR(1))[
      IRNEW = IRSTART_MIRROR;
      USTEP = 0;
      RETURN;
   ]
   IF(W(NP) > 0.0)[
      DIST = (ZBACK_MIRROR - Z(NP))/W(NP);
      IF(DIST<=0.)[DIST=1.E-16;]
      IRNEW_MIRROR = 1;
      XPLN_MIRROR = X(NP) + U(NP)*DIST;
      IF(XPLN_MIRROR > XBMIN_MIRROR(1))[
         IRNEW_MIRROR = IRSTART_MIRROR;
         DIST = (A_MIRROR*Z(NP)+BMIN_MIRROR(1)
                   -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
   ]
   ELSEIF(W(NP) < 0.0)[
      DIST = (ZMIN_MIRROR - Z(NP))/W(NP);
      IF(DIST<=0. & N_GAP_MIRROR = 0)[DIST=1.E-16;]
      IRNEW_MIRROR = IREND_MIRROR;
      XPLN_MIRROR = X(NP) + U(NP)*DIST;
      IF(N_GAP_MIRROR = 0)[IRNEW_MIRROR = 1;]
      IF(XPLN_MIRROR > XFMIN_MIRROR(1))[
         IRNEW_MIRROR = IRSTART_MIRROR;
         DIST = (A_MIRROR*Z(NP)+BMIN_MIRROR(1)
                  -X(NP))/(U(NP)-W(NP)*A_MIRROR);
      ]
   ]
   ELSE[
      IF(U(NP) > 0.0)[
         IRNEW_MIRROR = IRSTART_MIRROR;
         DIST = (A_MIRROR*Z(NP)+BMIN_MIRROR(1)-X(NP))/U(NP);
      ]
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF(IRNEW_MIRROR=1) ["leaving CM "
         IF(W(NP) > 0.0)[CALL WHERE_AM_I(ICM_MIRROR,1);]
         ELSEIF(W(NP) < 0.0)[CALL WHERE_AM_I(ICM_MIRROR,-1);]
      ]
      ELSE ["still in CM, entering between bars
         IRNEW = IRNEW_MIRROR; "new region number"
      ]
   ]
]
ELSEIF(IR_MIRROR = N_MIRROR + 3)[ "local region N_MIRROR + 3
   IF(W(NP) > 0.0)[
      DIST = (ZMIN_MIRROR - Z(NP))/W(NP);
      IF(DIST < 0.0)[DIST = 0.0;]
      XPLN_MIRROR = X(NP) + U(NP)*DIST;
      IF(XPLN_MIRROR < XFMIN_MIRROR(1))[
         IRNEW_MIRROR = IRSTART_MIRROR + N_MIRROR + 1;
      ]
      ELSEIF(XPLN_MIRROR < XFMAX_MIRROR(N_MIRROR))[
         DO I = 1, N_MIRROR[
            IF(XPLN_MIRROR < XFMAX_MIRROR(I))[
               IRNEW_MIRROR = IRSTART_MIRROR + I - 1;
               EXIT;
            ]
         ]
      ]
      ELSE[
         IRNEW_MIRROR = IRSTART_MIRROR + N_MIRROR;
      ]
   ]
   ELSEIF(W(NP) < 0.0)[
      DIST = (ZFRONT_MIRROR - Z(NP))/W(NP);
      IF(DIST <= 0.0)[DIST = 1.E-16;]
      IRNEW_MIRROR = 1;
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF(IRNEW_MIRROR = 1) ["leaving CM through back"
         CALL WHERE_AM_I(ICM_MIRROR,-1);
      ]
      ELSE ["still in CM
         IRNEW = IRNEW_MIRROR; "new region number"
      ]
   ]
] " end of region N_MIRROR + 3

"   outside of CM, something is wrong
"   =================================
"
ELSE ["something is wrong"
   OUTPUT IR(NP)-IRSTART_MIRROR+1,IR(NP),
          ICM_MIRROR,IR_start_CM(ICM_MIRROR);
      (//' ************'//' HOWFAR_MIRROR error: region # confused,'/
         '    Region, local, absolute =',2I5/
         '    CM number=',I5,' start region =',I5/
         '    This particle is being terminated on spot.',
         ' ************'//);
   NERROR_M=NERROR_M+1;
   IDISC=1;
   USTEP = 0.; IRNEW = IRL;
   IF(NERROR_M.EQ.10)[
      OUTPUT;(//' TOO MANY PARTICLES ARE NEGLECTED IN THIS CM!!'//);
      STOP;
   ]
] "end of IF statement"
;
RETURN;
END; "End of subroutine HOWFAR_MIRROR"

%E   "start of subroutine INPUT_MIRROR"
"*******************************************************************************
"
"                           Subroutine INPUT_MIRROR
"                           **********************
"
"  A CM input subroutine for a series of 2 or more semi-infinite slabs.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_MIRROR;


;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_MIRROR,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;
"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_MIRROR
"T>*********************************
"T>
$REAL
      BDYTOL;            "T>boundary tolerence
INTEGER I,J,NDO,         "T>DO loop indeces
        IRA,             "T>Absolute region number
        MED_FLAG,        "T>flag used by media-sort macro $MED_INPUT
        MED_INDEX;       "T>medium index, set after medium sort by $MED_INPUT
"
"  initialize parameters
"  =====================
"
ICM_MIRROR = ICM;      "CM index for this component module
IRSTART_MIRROR = IR_start_CM(ICM_MIRROR); "Index of first region in this CM,
                                      "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_MIRROR) = 0; "Geometry-checking flag, 0 if no error detected
"
"  get the title line
"  ==================
OUTPUT;(/' MIRROR (MIRROR)');
OUTPUT RMAX_CM(ICM);(/' Next component is a flat inclined mirror'/
  '      Outer boundary is a square with |x| & |y| <',F10.2,' cm');
IF(ICM_MIRROR = 1)[OUTPUT Z_min_CM(1);
   (' This component starts at',F10.4,' cm from the ref plane(Z=0)');]
ELSE
   [OUTPUT Z_min_CM(ICM_MIRROR);(' Previous CM ends at:',F12.5,' cm');]

OUTPUT;(' TITLE: ',$);
MINPUT (MIRROR) TITLE_MIRROR;(60A1); "MINPUT is a macro with EOF and
                                "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_MIRROR;(' ',60A1);
"
" get distance from reference plane, z=0"
"   =============================
OUTPUT; (' Z position at which mirror (excluding air gap) starts '/
  'and thickness of mirror in Z direction (on one line)'/' : ',$);
MINPUT (MIRROR) ZMIN_MIRROR,ZTHICK_MIRROR;(2F15.0);
OUTPUT ZMIN_MIRROR,ZTHICK_MIRROR;(2F15.5);
IF(Z_min_CM(ICM_MIRROR)>ZMIN_MIRROR)[
   IF(ICM_MIRROR=1)[
     OUTPUT ICM_MIRROR, ZMIN_MIRROR,Z_min_CM(ICM_MIRROR);
      (//' ***WARNING IN CM ',I4,' (MIRROR):'/
         ' Z_min_CM(1) > Z at which mirror starts'/
         ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
     WRITE(IOUTLIST,100)ICM_MIRROR, ZMIN_MIRROR,Z_min_CM(ICM_MIRROR);
     100 FORMAT(//' ***WARNING IN CM ',I4,' (MIRROR):'/
         ' Z_min_CM(1) > Z at which mirror starts'/
         ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
      Z_min_CM(ICM_MIRROR)=ZMIN_MIRROR;
   ]
   ELSE[
     OUTPUT ICM_MIRROR;
      (//'***ERROR IN CM ',I4,' (MIRROR):'/
         'Overlaps with previous CM'//);
     IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
   ]
]
IF(ZTHICK_MIRROR<0.0)[
  OUTPUT ICM_MIRROR;
   (//'***ERROR IN CM ',I4,' (MIRROR):'/
      'ZTHICK < 0.0'//);
   IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
]

OUTPUT;
   (' XFMIN (X position that front face crosses front of CM) and'/,
    ' XBMIN (X position that front face crosses back of CM): ',$);
MINPUT (MIRROR) XFMIN_MIRROR(1),XBMIN_MIRROR(1);(2F15.0);
OUTPUT XFMIN_MIRROR(1),XBMIN_MIRROR(1);(2F11.5);
IF(XFMIN_MIRROR(1) < XBMIN_MIRROR(1))[
   OUTPUT ICM_MIRROR;
     (//'***ERROR IN CM ',I4,' (MIRROR):'/
        'XFMIN < XBMIN'//);
   IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
]
ELSEIF(ZTHICK_MIRROR>0.0 &
       ZTHICK_MIRROR/(XFMIN_MIRROR(1) - XBMIN_MIRROR(1)).LT.0.0875)[
   "for angles < 5 degrees, one should not use this component module"
   OUTPUT ICM_MIRROR;
   (//'***ERROR IN CM ',I4,' (MIRROR):'/
      'Mirror angle too small which will result in simulation error'/
      ' Module SLABS can be used for such small angle simulations.'//);
   IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
]
IF(ABS(XFMIN_MIRROR(1))>RMAX_CM(ICM_MIRROR))[
   OUTPUT ICM_MIRROR;
    (//'***WARNING IN CM ',I4,' (MIRROR):'/
       'XFMIN(1) is outside RMAX_CM'//);
   WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (MIRROR):''/
       ''XFMIN(1) is outside RMAX_CM''//)')
       ICM_MIRROR;
]
IF(ABS(XBMIN_MIRROR(1))>RMAX_CM(ICM_MIRROR))[
   OUTPUT ICM_MIRROR;
    (//'***WARNING IN CM ',I4,' (MIRROR):'/
       'XBMIN(1) is outside RMAX_CM'//);
   WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (MIRROR):''/
       ''XBMIN(1) is outside RMAX_CM''//)')
       ICM_MIRROR;
]
"
"   get geometry information for mirror
"   =================================================
"
N_MIRROR = $MAX_N_MIRROR;
OUTPUT N_MIRROR;(' Number of layers of the mirror, minimum 1, maximum',I4);
MINPUT (MIRROR) N_MIRROR; (I10);
OUTPUT N_MIRROR;(' Number of layers in this mirror is',I4);
IF(N_MIRROR>$MAX_N_MIRROR)[
   N_MIRROR=$MAX_N_MIRROR;
   OUTPUT ICM_MIRROR, N_MIRROR;
    (//'***ERROR IN CM ',I4,' (MIRROR):'/
       '# of layers > max. allowed'/
       '# of layers reduced to ',F8.5,' for now'//);
   IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
]
ELSEIF(N_MIRROR<1)[
   N_MIRROR=1;
   OUTPUT ICM_MIRROR;
    (//'***ERROR IN CM ',I4,' (MIRROR):'/
       '# of layers < 1'/
       '# of layers reset to 1 for now'//);
   IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
]
DO I =1, N_MIRROR [
   OUTPUT I;(' Thickness of layer',I3,'(in cm): ',$);
   ;MINPUT (MIRROR) DTHICK_MIRROR(I);(F15.0);
   OUTPUT DTHICK_MIRROR(I);(F15.5);
   IF(DTHICK_MIRROR(I)<0.0)[
      OUTPUT ICM_MIRROR, I;
       (//'***ERROR IN CM ',I4,' (MIRROR):'/
          'DTHICK(',I4,') < 0.0'//);
      IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
   ]
]

XFMAX_MIRROR(1) = XFMIN_MIRROR(1) +
      SQRT(ZTHICK_MIRROR**2+(XFMIN_MIRROR(1)-
      XBMIN_MIRROR(1))**2)/ZTHICK_MIRROR*DTHICK_MIRROR(1);
XBMAX_MIRROR(1) = XBMIN_MIRROR(1) +
      SQRT(ZTHICK_MIRROR**2+(XFMIN_MIRROR(1)-
      XBMIN_MIRROR(1))**2)/ZTHICK_MIRROR*DTHICK_MIRROR(1);
IF(N_MIRROR > 1)[
   DO I =2, N_MIRROR[
      XFMIN_MIRROR(I) = XFMIN_MIRROR(I-1) +
         SQRT(ZTHICK_MIRROR**2+(XFMIN_MIRROR(1)-
         XBMIN_MIRROR(1))**2)/ZTHICK_MIRROR*DTHICK_MIRROR(I-1);
      XFMAX_MIRROR(I-1) = XFMIN_MIRROR(I);
      XBMIN_MIRROR(I) = XBMIN_MIRROR(I-1) +
         SQRT(ZTHICK_MIRROR**2+(XFMIN_MIRROR(1)-
         XBMIN_MIRROR(1))**2)/ZTHICK_MIRROR*DTHICK_MIRROR(I-1);
      XBMAX_MIRROR(I-1) = XBMIN_MIRROR(I);
      XFMAX_MIRROR(I) = XFMAX_MIRROR(I-1) +
         SQRT(ZTHICK_MIRROR**2+(XFMIN_MIRROR(1)-
         XBMIN_MIRROR(1))**2)/ZTHICK_MIRROR*DTHICK_MIRROR(I);
      XBMAX_MIRROR(I) = XBMAX_MIRROR(I-1) +
         SQRT(ZTHICK_MIRROR**2+(XFMIN_MIRROR(1)-
         XBMIN_MIRROR(1))**2)/ZTHICK_MIRROR*DTHICK_MIRROR(I);
   ]
]
"
"   get ECUT, PCUT, dose scoring zone, and material in each region
"   ===============================================================
IRA = IRSTART_MIRROR-1;
DO IR_MIRROR = 1,N_MIRROR+2["loop through regions to get information"
   IRA = IRA+1;
   IF(IR_MIRROR <= N_MIRROR) [
         OUTPUT IR_MIRROR;(/' For layer',I3,' of mirror:');
   ]
   ELSEIF(IR_MIRROR = N_MIRROR+1)[OUTPUT;(/' For region behind mirror:');]
   ELSEIF(IR_MIRROR = N_MIRROR+2)[OUTPUT;
                 (/' For region in front of mirror:');]
   ;OUTPUT;(' ECUT, PCUT(MeV), DOSE ZONE(0=DO NOT SCORE DOSE), IREGION_TO_BIT'/
   ' :',$);
   ;MINPUT (MIRROR) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (2F15.0,2I5);
   OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (F8.3,F9.3,I15,I19);
   IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
   IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
   IF(IR_MIRROR=N_MIRROR+1)[
      OUTPUT; (' Material of region behind mirror ',$);]
   ELSEIF(IR_MIRROR=N_MIRROR+2)[
      OUTPUT; (' Material of region in front of mirror ',$);]
   ELSE[
      OUTPUT IR_MIRROR;(' Material of layer ',I3,' ',$);]
   ;$MED_INPUT(MIRROR); " inputs character array MED_IN from unit 5, loops
  "through array MEDIA(24,I) to check if medium was previously input.
  "If so, sets MED_INDEX to index of previous medium.  If not,
  "increments NMED and sets MED_INDEX to NMED.
   MED(IRA) = MED_INDEX; " medium of the planar slab
] "end of loop over IR_MIRROR"

"  set up air gap to previous CM, if present
"  =========================================
"
"  The air gap has the highest region number in the CM, even though it is at
"  the top of the component module.  This is to allow the assignment of region
"  numbers on input of the parameters of each local region (mainly to assign the
"  medium number of the region).  The air gap is then assigned after all of the
"  CM parameters have been input.
"
Z_gap_THICK(ICM_MIRROR) = ZMIN_MIRROR - Z_min_CM(ICM_MIRROR);
IF (Z_gap_THICK(ICM_MIRROR) < $MIN_GAP) [
   Z_gap_THICK(ICM_MIRROR) = 0.;
   ZMIN_MIRROR=Z_min_CM(ICM_MIRROR);
   N_GAP_MIRROR = 0; "no air gap for this CM
]
ELSE[ N_GAP_MIRROR = 1; "this CM has an air gap "]

IF(N_GAP_MIRROR =1)[
    IRA = IRSTART_MIRROR + N_MIRROR + 2;
    ECUT(IRA) = ECUT(IRA-1);
    PCUT(IRA) = PCUT(IRA-1);
    MED(IRA)  = AIR_INDEX; " medium of the air gap
    ESAVE(IRA)=ESAVE_GLOBAL;
]
"
"  parameter definition
"  ====================
"
"fill arrays of distance from reference plane (z=0) to front and back of slabs
"
BDYTOL = $BDY_TOL;
A_MIRROR =  (XBMIN_MIRROR(1) - XFMIN_MIRROR(1))/ZTHICK_MIRROR;
DO I = 1, N_MIRROR[
   BMIN_MIRROR(I) = XFMIN_MIRROR(I) - A_MIRROR*ZMIN_MIRROR;
   BMAX_MIRROR(I) = XFMAX_MIRROR(I) - A_MIRROR*ZMIN_MIRROR;
   BMINT_MIRROR(I) = BMIN_MIRROR(I) - BDYTOL;
   BMAXT_MIRROR(I) = BMAX_MIRROR(I) + BDYTOL;
   XFMINT_MIRROR(I) = XFMIN_MIRROR(I) - BDYTOL;
   XFMAXT_MIRROR(I) = XFMAX_MIRROR(I) + BDYTOL;
   XBMINT_MIRROR(I) = XBMIN_MIRROR(I) - BDYTOL;
   XBMAXT_MIRROR(I) = XBMAX_MIRROR(I) + BDYTOL;
]
"
"establish start of next CM
ZBACK_MIRROR = ZMIN_MIRROR + ZTHICK_MIRROR;
Z_min_CM(ICM_MIRROR+1) = ZBACK_MIRROR;
ZFRONT_MIRROR = Z_min_CM(ICM_MIRROR);
"
"
"  set up region numbers
"  =====================
"  This CM has N_MIRROR + 2 + N_GAP_MIRROR regions
"
IREND_MIRROR = IRSTART_MIRROR + N_MIRROR + N_GAP_MIRROR + 1;
               "Index of last region
NREG = NREG + N_MIRROR + N_GAP_MIRROR + 2;  "Total number of regions up
                                              "to and including this CM
IF (NREG <= $MXREG) ["have not exceeded maximum region number
      "Index of first region in next CM:"
      IR_start_CM(ICM_MIRROR+1) = IREND_MIRROR + 1;
]
ELSE [
      OUTPUT ICM_MIRROR,NREG,$MXREG;
      (//'***ERROR IN CM ',I4,' (MIRROR):'/
        I4,' regions requested, only',I4,' available');
         N_MIRROR=$MAX_N_MIRROR;
     IERR_GEOM(ICM_MIRROR)=IERR_GEOM(ICM_MIRROR)+1;
]
"
"  establish CM boundary
"  =====================
"
RMAX_CM_FLAG(ICM_MIRROR) = 2; "put a square boundary about CM
"
"  establish dose-scoring zones and range rejection parameters for each region
"  ===========================================================================
"
IRA = IRSTART_MIRROR-1; "absolute region number"
DO IR_MIRROR=1,N_MIRROR+2["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones
   IF(NDOSE_ZONE > $MAX_DOSE_ZONE)[
      OUTPUT NDOSE_ZONE;
       (' Too many dose zone !', 'NDOSE_ZONE =',I5,
        ' > $MAX_DOSE_ZONE');
      STOP;
   ]
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT);
   "charged particle range rejection parameters
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
] "end of loop over IR_MIRROR

"Initialize for automated range rejection"

"set up minimum thicknesses which in this case are just the last 5"
"slabs"
"If we ever need more than 5 slabs, we should extend this or do
"something fancy like group similar materials"

NDO = MIN(5,N_MIRROR); "consider at most 5 slabs of material"
                        "air gap handled below"
IF (IREJCT_GLOBAL = 1)[" i.e. will use automated range rejection"
   ;OUTPUT;(//' ************************************************************'/
        ' NOTE: MIRRORs RANGE REJECTION ALGORITHM ASSUMES THE MIRROR'/
        ' INTERSECTS THE ENTIRE BEAM!!!   CHECK IT'/
        ' ***********************************************************'//);
   WRITE(IOUTLIST,'(''*********************************************''/
      '' NOTE: MIRRORs RANGE REJECTION ALGORITHM ASSUMES THE MIRROR''/
      '' INTERSECTS THE ENTIRE BEAM!!!   CHECK IT''/
      '' ***********************************************************''//)');
   DO IR_MIRROR = 1, NDO [
      IRA = IR_MIRROR + IRSTART_MIRROR-1;   "absolute region"
      Z_min_thick(ICM,IR_MIRROR) = DTHICK_MIRROR(IR_MIRROR);
      MED_min_thick(ICM, IR_MIRROR) = MED(IRA);
      "OUTPUT IR_MIRROR,IRA,ICM, IR_MIRROR, Z_min_thick(ICM,IR_MIRROR),
         "ICM,IR_MIRROR, MED_min_thick(ICM, IR_MIRROR);
         "(' IR_MIRROR,IRA=',I2,',',I3,T25,'Z_min_thick(',2I2,')=',F10.3,
         "'  MED_min_thick(',2I3,')=',I2);
   ]"have set parameters for actual mirror materials"
   IF(NDO < 5)[  "still some of 5 locations available"
       "Use an approximation and treat entire rest of CM as if filled"
       "with air and with no reduction because of material in mirror"
       "This may be a bad approximation if used for anything other than a"
       "MIRROR ********************"
       Z_min_thick(ICM,NDO+1) = ZTHICK_MIRROR + Z_gap_thick(ICM_MIRROR);
       MED_min_thick(ICM,NDO+1) = AIR_INDEX; "AIR_INDEX is 0 or 1"
       OUTPUT ICM,NDO+1,Z_min_thick(ICM,NDO+1),ICM,NDO+1,
                    MED_min_thick(ICM,NDO+1);
       (' For air in CM ',T25,' Z_min_thick(',2I2,')=',F10.3,
                    '  MED_min_thick(',2I3,')=',I2);
   ]
]"end of loop on IREJCT_GLOBAL=1"
RETURN;

"   error messages
"   ==============
"
:EOF_MIRROR:
;OUTPUT ICM;(//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_MIRROR:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;
END;  "End of INPUT_MIRROR"
%E   "start of subroutine ISUMRY_MIRROR"
"*******************************************************************************
"
"                          Subroutine ISUMRY_MIRROR
"                          ************************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_MIRROR;


;IMPLICIT NONE;

;COMIN/ BOUNDS,CMs,CM_MIRROR,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_MIRROR
"T>**********************************
"T>
INTEGER
   ICOLOUR,    "T>colour of CM for EGS_Windows
   IRA,        "T>absolute region number
   I,J;        "T>DO loop index

$REAL VOL_MIRROR($MAX_N_MIRROR),   "T>volume
      YWIDTH,
      VOLTOT_MIRROR;
"
"   Mass of dose zone
"   =================
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_MIRROR.
VOLTOT_MIRROR=0.;
IRA=IRSTART_MIRROR-1;
DO I = 1, N_MIRROR + 2 [
   IRA = IRA+1; "absolute region number
   IF(I<=N_MIRROR)["one of the mirror slabs
     VOL_MIRROR(I)=SQRT(ZTHICK_MIRROR**2+(XFMIN_MIRROR(I)-
                    XBMIN_MIRROR(I))**2)*DTHICK_MIRROR(I)*
                    2*RMAX_CM(ICM_MIRROR);
     IF(XBMIN_MIRROR(I)<-RMAX_CM(ICM_MIRROR) &
       XBMAX_MIRROR(I)>=-RMAX_CM(ICM_MIRROR))[
         VOL_MIRROR(I)=VOL_MIRROR(I)-(ABS(XBMIN_MIRROR(I))-
                        RMAX_CM(ICM_MIRROR))**2*(ZTHICK_MIRROR/
                        (XFMIN_MIRROR(I)-XBMIN_MIRROR(I)))*
                        RMAX_CM(ICM_MIRROR);
     ]
     ELSEIF(XBMIN_MIRROR(I)<-RMAX_CM(ICM_MIRROR) &
       XBMAX_MIRROR(I)<-RMAX_CM(ICM_MIRROR))[
          VOL_MIRROR(I)=VOL_MIRROR(I)-(XBMAX_MIRROR(I)-
                         XBMIN_MIRROR(I))*(ABS(XBMAX_MIRROR(I))-
                         RMAX_CM(ICM_MIRROR))*ZTHICK_MIRROR/
                         (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*2*
                         RMAX_CM(ICM_MIRROR)-(XBMAX_MIRROR(I)-
                         XBMIN_MIRROR(I))**2*ZTHICK_MIRROR/
                         (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*
                         RMAX_CM(ICM_MIRROR);
     ]
     IF(XFMAX_MIRROR(I)>RMAX_CM(ICM_MIRROR) &
     XFMIN_MIRROR(I)<=RMAX_CM(ICM_MIRROR))[
         IF(XBMAX_MIRROR(I)>RMAX_CM(ICM_MIRROR))[
             VOL_MIRROR(I)=VOL_MIRROR(I)-(XFMAX_MIRROR(I)-
                        XBMAX_MIRROR(I))*ZTHICK_MIRROR*
                        RMAX_CM(ICM_MIRROR)-(XBMAX_MIRROR(I)-
                        RMAX_CM(ICM_MIRROR))*ZTHICK_MIRROR*
                        2*RMAX_CM(ICM_MIRROR);
         ]
         ELSE[
         VOL_MIRROR(I)=VOL_MIRROR(I)-(ABS(XFMAX_MIRROR(I))-
                        RMAX_CM(ICM_MIRROR))**2*ZTHICK_MIRROR/
                        (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*
                        RMAX_CM(ICM_MIRROR);
         ]
     ]
     ELSEIF(XFMAX_MIRROR(I)>RMAX_CM(ICM_MIRROR) &
     XFMIN_MIRROR(I)>RMAX_CM(ICM_MIRROR))[
        IF(XBMAX_MIRROR(I)>RMAX_CM(ICM_MIRROR))[
          VOL_MIRROR(I)=VOL_MIRROR(I)-(XFMAX_MIRROR(I)-
                         XFMIN_MIRROR(I))*(XFMIN_MIRROR(I)-
                         RMAX_CM(ICM_MIRROR))*ZTHICK_MIRROR/
                         (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*2*
                         RMAX_CM(ICM_MIRROR)-(XFMAX_MIRROR(I)-
                         XFMIN_MIRROR(I))**2*ZTHICK_MIRROR/
                         (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*
                         RMAX_CM(ICM_MIRROR)+(XBMAX_MIRROR(I)-
                         RMAX_CM(ICM_MIRROR))**2*ZTHICK_MIRROR/
                         (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*
                         RMAX_CM(ICM_MIRROR);
        ]
        ELSE[
          VOL_MIRROR(I)=VOL_MIRROR(I)-(XFMAX_MIRROR(I)-
                         XFMIN_MIRROR(I))*(ABS(XFMIN_MIRROR(I))-
                         RMAX_CM(ICM_MIRROR))*ZTHICK_MIRROR/
                         (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*2*
                         RMAX_CM(ICM_MIRROR)-(XFMAX_MIRROR(I)-
                        XFMIN_MIRROR(I))**2*ZTHICK_MIRROR/
                         (XFMIN_MIRROR(I)-XBMIN_MIRROR(I))*
                         RMAX_CM(ICM_MIRROR);
        ]
     ]
     VOLTOT_MIRROR=VOLTOT_MIRROR+VOL_MIRROR(I);
   ]
   ELSEIF(I=N_MIRROR+1)["region underneath mirror"
     IF(XBMAX_MIRROR(N_MIRROR)>RMAX_CM(ICM_MIRROR))[
       VOL_MIRROR(I)=0.0;
     ]
     ELSE[
       VOL_MIRROR(I)=ZTHICK_MIRROR*(XFMAX_MIRROR(N_MIRROR)
                    -XBMAX_MIRROR(N_MIRROR))*
                    RMAX_CM(ICM_MIRROR);
       IF(XFMAX_MIRROR(N_MIRROR)>RMAX_CM(ICM_MIRROR))[
          VOL_MIRROR(I)=VOL_MIRROR(I)-(RMAX_CM(ICM_MIRROR)-
                       XBMAX_MIRROR(N_MIRROR))*ZTHICK_MIRROR/
                       (XFMAX_MIRROR(N_MIRROR)-
                        XBMAX_MIRROR(N_MIRROR))*
                        (XFMAX_MIRROR(N_MIRROR)-
                        RMAX_CM(ICM_MIRROR))*2*RMAX_CM(ICM_MIRROR)-
                        (XFMAX_MIRROR(N_MIRROR)-
                         RMAX_CM(ICM_MIRROR))**2*ZTHICK_MIRROR/
                         (XFMAX_MIRROR(N_MIRROR)-
                        XBMAX_MIRROR(N_MIRROR))*
                        RMAX_CM(ICM_MIRROR);
       ]
       ELSE[
          VOL_MIRROR(I)=VOL_MIRROR(I)+ZTHICK_MIRROR*
                       (RMAX_CM(ICM_MIRROR)-
                        XFMAX_MIRROR(N_MIRROR))*2*
                        RMAX_CM(ICM_MIRROR);
       ]
       IF(XBMAX_MIRROR(N_MIRROR)<-RMAX_CM(ICM_MIRROR))[
          VOL_MIRROR(I)=VOL_MIRROR(I)-
                       (ABS(XBMAX_MIRROR(N_MIRROR))-
                       RMAX_CM(ICM_MIRROR))**2*ZTHICK_MIRROR/
                       (XFMAX_MIRROR(N_MIRROR)-
                        XBMAX_MIRROR(N_MIRROR))*
                        RMAX_CM(ICM_MIRROR);
       ]
    ]
    VOLTOT_MIRROR=VOLTOT_MIRROR+VOL_MIRROR(I)
   ]
   ELSEIF(I=N_MIRROR+2)["region above mirror"
     VOL_MIRROR(I)=ZTHICK_MIRROR*4*RMAX_CM(ICM_MIRROR)**2-
                    VOLTOT_MIRROR;
   ]
   IF(DOSE_ZONE(IRA).NE.0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+VOL_MIRROR(I)*RHOR(IRA);
   ]
]"end of do loop over regions"


"   Calculate four corner of the mirror for graph
"   =============================================
"

"   Summarize geometrical information for this component module in listing file
"   ===========================================================================

WRITE(IOUTLIST,110) ICM_MIRROR,TITLE_MIRROR;
WRITE(IOUTLIST,120) Z_min_CM(ICM_MIRROR),RMAX_CM(ICM_MIRROR),
                    ZMIN_MIRROR,ZTHICK_MIRROR;
WRITE(IOUTLIST,122);
IF(N_GAP_MIRROR~=0)[
   WRITE(IOUTLIST,126) 'airgap',ZMIN_MIRROR-Z_min_CM(ICM_MIRROR),
                       'NA','NA','NA','NA';
   WRITE(IOUTLIST,126) 'at top';
]
DO I=1,N_MIRROR[
   IF(I=1)[
   WRITE(IOUTLIST,124) I,'(front)',DTHICK_MIRROR(I),
                       XFMIN_MIRROR(I),XBMIN_MIRROR(I),
                       XFMAX_MIRROR(I),XBMAX_MIRROR(I);
   ]
   ELSE[
   WRITE(IOUTLIST,123) I,DTHICK_MIRROR(I),
                       XFMIN_MIRROR(I),XBMIN_MIRROR(I),
                       XFMAX_MIRROR(I),XBMAX_MIRROR(I);
   ]
]
WRITE(IOUTLIST,125) ATAN((XFMIN_MIRROR(1)-XBMIN_MIRROR(1))/
                         ZTHICK_MIRROR)*180./3.1415926;
WRITE(IOUTLIST,130);

IRA = IRSTART_MIRROR-1;
DO IR_MIRROR=1,N_MIRROR+2+N_GAP_MIRROR[
   IRA = IRA+1;
   IF(IR_MIRROR<=N_MIRROR)[
      IF(MED(IRA)=0)[
         WRITE(IOUTLIST,140) IR_MIRROR,IR_MIRROR,'layer',
               ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
               DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
               'V','a','c','u','u','m';
      ]
      ELSE[
         WRITE(IOUTLIST,140) IR_MIRROR,IR_MIRROR,'layer',
               ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
               DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
               (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]
   ELSEIF(IR_MIRROR<=N_MIRROR+2)[
       IF(MED(IRA)=0)[
         WRITE(IOUTLIST,141) IR_MIRROR,'NA','region',
               ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
               DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
               'V','a','c','u','u','m';
       ]
       ELSE[
         WRITE(IOUTLIST,141) IR_MIRROR,'NA','region',
               ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
               DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
               (MEDIA(J,MED(IRA)),J=1,9);
       ]
       IF(IR_MIRROR=N_MIRROR+1)[
            WRITE(IOUTLIST,142)'behind';
       ]
       ELSEIF(IR_MIRROR=N_MIRROR+2)[
            WRITE(IOUTLIST,142)'in front';
       ]
   ]
   ELSEIF(IR_MIRROR=N_MIRROR+2+N_GAP_MIRROR)[
       IF(MED(IRA)=0)[
         WRITE(IOUTLIST,141) IR_MIRROR,'NA','airgap',
               ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
               DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
              'V','a','c','u','u','m';
       ]
       ELSE[
         WRITE(IOUTLIST,141) IR_MIRROR,'NA','airgap',
               ECUT(IRA),PCUT(IRA),ECUTRR(IRA),ESAVE(IRA),
               DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
              (MEDIA(J,MED(IRA)),J=1,9);
       ]
       WRITE(IOUTLIST,142)'at top';
   ]

]

110 FORMAT(///1X,79('-')/'  Component module',I3,' is a flat inclined',
           ' mirror MIRROR '
           /1X,79('-')
           //T2,'Title: ',68A1);
120 FORMAT(/T2,'MIRROR geometry parameters:',
           /T2,'-----------------------------',
           /T2,'Z of front face of CM = ',F15.5,' cm',
           /T2,'Half-width of outer boundary of CM = ',F15.5,' cm',
           /T2,'Z at which mirror starts = ',F15.5,
               ' cm',
           /T2,'Z span of mirror = ',F15.5,' cm');
122 FORMAT(/T2,
'layer #      thickness         XFMIN     XBMIN     XFMAX     XBMAX',
/T2,
'               (cm)                            (cm)');
123 FORMAT(T2,I2,F17.3,F17.3,3F10.3);
124 FORMAT(T2,I2,A7,F10.3,F17.3,3F10.3);
126 FORMAT(T2,A7,F12.3,A17,3A10);
125 FORMAT(/T2,'Angle of mirror face wrt z-axis = ',F15.5,' degrees');
130 FORMAT(/T2,'MIRROR region parameters:',
           /T2,'---------------------------',
           /T2,'local layer  location   electron   photon',
           '  range-rejection   dose  bit  medium'
           /T2,'region                   cutoff    cutoff',
           '   level     max    zone  set',
           /T2,'                         (MeV)      (MeV)',
           '   (MeV)    (MeV)');
140 FORMAT(T2,I3,I7,2X,A8,F11.3,F9.3,F9.3,F9.3,I5,I5,2X,9A1);
141 FORMAT(T2,I3,A7,2X,A8,F11.3,F9.3,F9.3,F9.3,I5,I5,2X,9A1);
142 FORMAT(T14,A8);



"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"
ICOLOUR = 1;
YWIDTH = MIN(RMAX_CM(ICM_MIRROR),3.);
IF(IWATCH = 4 | IZLAST = 2) [   "Creat a graphics file "
  ;$SELECT-COLOUR;
   DO I =1, N_MIRROR[
      WRITE(IOUTGEOM,201) ICOLOUR,'QUAD',
          XFMIN_MIRROR(I), YWIDTH,ZMIN_MIRROR,
          XBMIN_MIRROR(I), YWIDTH,ZBACK_MIRROR,
          XBMIN_MIRROR(I),-YWIDTH,ZBACK_MIRROR,
          XFMIN_MIRROR(I),-YWIDTH,ZMIN_MIRROR;
   ]
      WRITE(IOUTGEOM,201) ICOLOUR,'QUAD',
          XFMAX_MIRROR(N_MIRROR), YWIDTH,ZMIN_MIRROR,
          XBMAX_MIRROR(N_MIRROR), YWIDTH,ZBACK_MIRROR,
          XBMAX_MIRROR(N_MIRROR),-YWIDTH,ZBACK_MIRROR,
          XFMAX_MIRROR(N_MIRROR),-YWIDTH,ZMIN_MIRROR;

201   FORMAT(' ',I1,A4,12(F7.2,','));
]"End of graphics output"

"   end of ISUMRY_MIRROR
"   ===================
"
RETURN;
END; "end of subroutine ISUMRY_MIRROR"
%E   "start of subroutine WHERE_AM_I_MIRROR"
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_$MIRR
"                          ***************************
"
" WHERE_AM_I routine for a MIRROR"
"
" WHERE_AM_I_MIRROR determines the new region number when a particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_MIRROR subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_MIRROR from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************

;SUBROUTINE WHERE_AM_I_MIRROR(IDIR);


;IMPLICIT NONE;
;COMIN/CM_MIRROR,EPCONT,STACK/;
"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_MIRROR
"T>**************************************
"T>
INTEGER I,     "T>loop index
        IDIR;  "T>direction of particle, +1=forward, -1=backward
$REAL XF_MIRROR;
XF_MIRROR = X(NP) + USTEP*U(NP);
IF(IDIR=1) ["particle entering this CM through front face (upstream)
   IF(N_GAP_MIRROR ~= 0)[
      IRNEW = IREND_MIRROR;
   ]
   ELSE[
      IF(IRSTART_MIRROR = 2) [XF_MIRROR = X(NP);]
      IF(XF_MIRROR < XFMIN_MIRROR(1))[
         IRNEW = IRSTART_MIRROR + N_MIRROR + 1;
      ]
      ELSEIF(XF_MIRROR < XFMAX_MIRROR(N_MIRROR))[
         DO I = 1, N_MIRROR[
            IF(XF_MIRROR < XFMAX_MIRROR(I))[
               IRNEW = IRSTART_MIRROR + I - 1;
               RETURN;
            ]
         ]
      ]
      ELSE[
         IRNEW = IRSTART_MIRROR + N_MIRROR;
      ]
   ]
]
ELSE["particle entering this CM through back face (downstream)
   IF(XF_MIRROR > XBMAX_MIRROR(N_MIRROR))[
      IRNEW = IRSTART_MIRROR + N_MIRROR;
   ]
   ELSEIF(XF_MIRROR > XBMIN_MIRROR(1))[
      DO I = 1, N_MIRROR[
         IF(XF_MIRROR <= XBMAX_MIRROR(I))[
            IRNEW = IRSTART_MIRROR + I - 1;
            RETURN;
         ]
      ]
   ]
   ELSE[
      IRNEW = IRSTART_MIRROR + N_MIRROR + 1;
   ]
]
RETURN;
END; "End of subroutine WHERE_AM_I_MIRROR"

%E   "start of subroutine HOWNEAR_MIRROR"
"******************************************************************************
"
"                          Subroutine HOWNEAR_MIRROR
"                          ************************
"
" Calculates min. distance to nearest region boundary.
" Used to be a macro, but now the macro calls this subroutine.
"
"*******************************************************************************
;SUBROUTINE HOWNEAR_MIRROR(DIST);


$IMPLICIT-NONE;

COMIN/CM_MIRROR,STACK/;

$REAL DIST; "T> the min. distance to the nearest region boundary

IR_MIRROR = IR(NP) - IRSTART_MIRROR + 1;"local region number (relative)"
IF(IR_MIRROR > 0 & IR_MIRROR <= N_MIRROR )[   "local region 1 to N"
        DIST=MIN( Z(NP)-ZMIN_MIRROR,  "distance to the top surface"
        ZBACK_MIRROR-Z(NP),      "distance to the bottom"
        (X(NP)-XBMIN_MIRROR(IR_MIRROR))*(ZTHICK_MIRROR/
           SQRT((XBMIN_MIRROR(1)
           -XFMIN_MIRROR(1))**2+ZTHICK_MIRROR**2))
           -(ZBACK_MIRROR-Z(NP))*((XFMIN_MIRROR(1)-
           XBMIN_MIRROR(1))/SQRT((XBMIN_MIRROR(1)
           -XFMIN_MIRROR(1))**2+ZTHICK_MIRROR**2)), "distance to the side"
        (ZBACK_MIRROR-Z(NP))*((XFMIN_MIRROR(1)-
           XBMIN_MIRROR(1))/SQRT((XBMIN_MIRROR(1)
           -XFMIN_MIRROR(1))**2+ZTHICK_MIRROR**2))
           - (X(NP)-XBMAX_MIRROR(IR_MIRROR))*(ZTHICK_MIRROR/
           SQRT((XBMIN_MIRROR(1)-XFMIN_MIRROR(1))**2+ZTHICK_MIRROR**2))
        "distance to the side"
        );
]
ELSEIF(IR_MIRROR=N_MIRROR+1)["the air region below the mirror"
        DIST=MIN( Z(NP)-ZMIN_MIRROR,  "distance to the top surface"
        ZBACK_MIRROR-Z(NP),      "distance to the bottom"
        (X(NP)-XBMAX_MIRROR(N_MIRROR))*(ZTHICK_MIRROR
         /SQRT((XBMIN_MIRROR(1)-XFMIN_MIRROR(1))**2+ZTHICK_MIRROR**2))
           -(ZBACK_MIRROR-Z(NP))*((XFMIN_MIRROR(1)-XBMIN_MIRROR(1))/
           SQRT((XBMIN_MIRROR(1)-XFMIN_MIRROR(1))**2+ZTHICK_MIRROR**2))
        "distance to the side"
        );
]
ELSEIF(IR_MIRROR=N_MIRROR+2)["the air region above the mirror"
        DIST=MIN( Z(NP)-ZMIN_MIRROR,  "distance to the top surface"
        ZBACK_MIRROR-Z(NP),      "distance to the bottom"
        (ZBACK_MIRROR-Z(NP))*((XFMIN_MIRROR(1)-
           XBMIN_MIRROR(1))/SQRT((XBMIN_MIRROR(1)
           -XFMIN_MIRROR(1))**2+ZTHICK_MIRROR**2))
           -(X(NP)-XBMIN_MIRROR(1))*(ZTHICK_MIRROR/SQRT((XFMIN_MIRROR(1)
           -XBMIN_MIRROR(1))**2+ZTHICK_MIRROR**2))
        "distance to the side"
        );
]
ELSEIF((N_GAP_MIRROR.EQ.1)&(IR_MIRROR=N_MIRROR+3))["in the air gap"
   DIST=MIN( Z(NP)-ZFRONT_MIRROR,  "distance to the front surface of the CM"
   ZMIN_MIRROR-Z(NP)      "distance to the lower boundary of the region"
   );
]
RETURN;
END; "End of subroutine HOWNEAR_MIRROR"
"*******************************************************************************
"End of MIRROR_cm.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: set of paired bars                        "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          George Ding, 1992                                         "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                   Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             **************      ""toc:
"                             *            *      ""toc:
"                             *    JAWS    *      ""toc:
"                             *            *      ""toc:
"                             **************      ""toc:
"
"   Programmer:  George Ding.
"
"   Development  Version, begun September 5, 1992. Completed in October,1992
"
"   For complete history see sccs record.
"*******************************************************************************
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.
"   Set of paired bars.(collimator jaws or applicator)
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator:  a set of 1 or more
"   paired bars. The bas are of arbitrary thickness and material,and X or Y.
"   orintation.
"
"   This component module can be added to the simulation by including these
"   routines in the MORTRAN file BEAM_CM.MORTRAN and including the MORTRAN
"   replacement macros associated with this component module in the file
"   BEAM_COMMON.MORTRAN.  The order of the component modules in either of
"   these files is unimportant.  To explicitly include this component module in
"   the simulation it must be included in the $CM_LIST replacement statement.
"   The component modules in this list are stacked sequentially for the
"   simulation, one on top of the other, and must not overlap.
%E   "JAWS_cm.mortran - start of geometry description
"I>
"I> Geometry of JAWS:                             ""toc:
"I> ******************
"I>                                  ||
"I>                                \ || /   beam
"I>                                 \||/
"I>                                  \/
"I>
"I>             ---------------------------------------------------
"I>
"I>             -------------     IR=1      ----------------
"I>                         /              |
"I>  ISCM=1       IR=3     /               |   IR=2
"I>            ------------  - - - - - - -  -----------------
"I>
"I>           ---------------    IR=4     ---------------------
"I>                         /            \
"I>  ISCM=2       IR=6     /              \  IR=5
"I>       ----------------- - - - - - - -  -----------------------
"I>
"I>
"I>   IR is the region number within the CM.  There are N_JAWS local
"I>   regions. The first region is between bars or jaws.  An air gap is
"I>   always present at the front.
"I>
"I>
"I>            --------------------------------------------------------
"I>            |          Region               | Description          |
"I>            |-------------------------------|----------------------|
"I>            |  absolute       | local       |                      |
"I>            |-----------------|-------------|                      |
"I>            | IRSTART_JAWS    |  IR_JAWS    |   see graph          |
"I>            |   +IR_JAWS-1    |             |                      |
"I>            --------------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_SECJAWS
"                      ISUMRY_SECJAWS
"                      HOWFAR_SECJAWS
"                      WHERE_AM_I_SECJAWS
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS ON USE/BUGS
"                             ************************
"
" 1. Very small jaw angles lead to approximations because of boundary
"    tolerance.  Particles may step right through the tips of jaws,
"    without recognizing that they have entered and exited a distinct
"    region, where jaw thickness is ~$BDY_TOL cm.
"
"*******************************************************************************
"*******************************************************************************
"**************************  DESCRIPTION OF VARIABLES  *************************
"*******************************************************************************
"
"                             COMMON BLOCK VARIABLES
"                             **********************
"
"  Refer to the replacement macros in BEAM.MORTRAN and BEAM_COMMON.MORTRAN
"  which define the common block variables.
"
"*******************************************************************************
"
"                                OTHER VARIABLES
"                                ***************
"
"  Refer to the section on type declarations for each subroutine. The following
"  section describes the variables input from unit 5.  These variables define
"  the parameters of each simulation.
"
"*******************************************************************************
"
"                   Description of Users Input from Unit 5   ""toc:
"                   **************************************
"
"I>
"I>  CARDS CM_SECJAWS(JAWS)
"I>  **************
"I>
"I>  -1  dummy line read in main used to separate input for CMs
"I>
"I>   0  RMAX_CM(ICM_JAWS) (F10.0):
"I>                         Perpendicular distance from Z-axis to boundary
"I>                         surrounding component module.  This component
"I>                         module has a square boundary.
"I>
"I>   1  TITLE_SECJAWS (60A1):  Title of CM.
"I>
"I>   2  ISCM_MAX_SECJAWS (I5):  Number of paired bars or jaws in CM.
"I>
"I>   Repeat 3 and 4 for I=1,ISCM_MAX_SECJAWS
"I>
"I>   3  XY_CHOICE (A1):  indicate orientation of the paired bars/jaws
"I>                        X means bars/jaws perpendicular to x axis
"I>                       i.e. separation and movement is along x-axis
"I>
"I>   4  ZMIN_SECJAWS(I), ZMAX_SECJAWS(I), XFP_SECJAWS(I), XBP_SECJAWS(I),
"I>      XFN_SECJAWS(I), XBN_SECJAWS(I) (6F15.0)
"I>
"I>        ZMIN_SECJAWS(I): Distance front of bars/jaws to reference plane.
"I>        ZMAX_SECJAWS(I): Distance back of bars/jaws to reference plane.
"I>        XFP_SECJAWS(I):  positive bar/jaw x or y coodinate at front.
"I>        XBP_SECJAWS(I):  positive bar/jaw x or y coodinate at back.
"I>        XFN_SECJAWS(I):  negative bar/jaw x or y coodinate at front.
"I>        XBN_SECJAWS(I):  negative bar/jaw x or y coodinate at back.
"I>
"I>   5   ECUT, PCUT, DOSE_ZONE, IREGION_to_BIT (2F15.0,2I5): for interior
"I>                                                     (assumed to be AIR)
"I>
"I>          ECUT, PCUT:     Cutoff energies for electrons and photons.
"I>          DOSE_ZONE:      Dose scoring zone of air surrounding bars.
"I>          IREGION_TO_BIT: This region associated with this bit in LATCH
"I>
"I>   Repeat 6 and 7 for I=1,ISCM_MAX_SECJAWS
"I>
"I>   6   ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT (2F15.0,2I5)
"I>
"I>          ECUT, PCUT:     Cutoff energies for electrons and photons in
"I>                          jaw I.
"I>          DOSE_ZONE:      Dose scoring zone for jaw I.
"I>          IREGION_TO_BIT: Both bars of jaw I associated with this bit.
"I>
"I>   7   MED_IN (24A1):  Medium of jaw I, used to set MED_INDEX.
"I>
"I>   Example
"I>   *******
"I>
"I>  The following set of cards defines a pair of 5 cm-thick Al jaws.
"I>  The first set of bars open along the X axis.  The inside faces of
"I>  this jaw are vertical at |X|=3cm.  The second set of bars open along
"I>  the Y axis.  The inside
"I>  faces of this jaw are angled out slightly, beginning at |Y|=3cm at the top
"I>  of the jaw and ending at |Y|=3.05cm at the bottom of the jaw.
"I>  The first jaw starts at Z=30.0 cm.  Note the 0.01 cm airgap between
"I>  the two jaws.
"I>
"I>  Electrons will be followed in the CM down to kinetic energies of
"I>  10 keV (total energies of 0.521 MeV) and photons will be followed down
"I>  to energies of 1 keV.  The dose deposited in the air will be scored and
"I>  added to the dose deposited in the bars in dose zone 1.
"I>
"I>  15.0    RMAX_CM
"I>  JAWS: 2 Al jaws, 5cm thick
"I>  2
"I>  X
"I>  30.0, 35.0, 3.0, 3.0, -3.0, -3.0
"I>  Y
"I>  35.01, 40.01, 3.0, 3.05, -3.0, -3.05
"I>  0.0, 0.0, 1, 0
"I>  0.0, 0.0, 1, 0
"I>  AL
"I>  0.0, 0.0, 1, 0
"I>  AL
"I>
"
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules not allowed
"
"   2)  Overlapping bars not allowed
"
"   3)  Air gap at front of CM required
"
"   4)  Inner boundary of all bars must be within CM boundary, RMAX_CM
"
"*******************************************************************************

%E   "Start of subroutine HOWFAR_SECJAWS"
"*******************************************************************************
"************************** Component Module JAWS ******************************
"*******************************************************************************
"
"                          Subroutine HOWFAR_JAWS
"                          ***********************
"
" HOWFAR routine for set of paired bars.
"
" Determine if current region number is within component module JAWS, and if
" so evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are 4xISCM local regions see above graph:
"
"      local                    absolute                   description
"   ------------  ------------------------------------   ---------------
"       IRL       IR_start_CM(ICM_JAWS)+IRL-1               IRL
"
"   Geometrical co-ordinates, as set in INPUT_JAWS are:
"
"   ZFRONT_JAWS     front of CM (upstream surface, air region)
"   ZBACK_JAWS      back of CM (downstream surface, air region)
"   ZMIN_JAWS(IRL)  front of bars ISCM,
"   ZMAX_JAWS(IRL)  back of bars ISCM
"
"*******************************************************************************
;SUBROUTINE HOWFAR_SECJAWS;


;IMPLICIT NONE;
;COMIN/CMs,CM_SECJAWS,EPCONT,STACK,EGS-IO/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_JAWS
"T>**********************************
"T>
INTEGER
   IRL,        "T>local region number (absolute), required by HOWNEAR macro
   IB_SECJAWS,    "T>index to deal with round off errors
   I_tpo,I_tne, "T>error indices
   IRNEW_SECJAWS; "T>tentative new region number within CM (absolute)

$REAL
   DIST,       "T>distance to region boundary along current particle trajectory
   DIST1,      "T>holds value of DIST while further checks are done
   XPLN_SECJAWS,  "T>X or Y at a plane surface along particle trajectory
   ZPLN_SECJAWS;  "T>Z along particle trajectory

DATA I_tpo,I_tne/0,0/;

IRL = IR(NP); "local region number (absolute)
"
" This replacement macros sets DNEAR as well as defining IR_SECJAWS,
 ;SECJAWS_CM_HOWNEAR(DNEAR(NP));

" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module JAWS, and if
" so evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
";SECJAWS_SET_XY_UV(ISCM_SECJAWS);"" needed if no dnear caln in howfar"
IF(IR_SECJAWS = 3*ISCM_SECJAWS-2) ["particle not in positive or negative bar
   IB_SECJAWS=1;
   IF(W(NP) > 0.0 )[
      IF(Z(NP) < ZMIN_SECJAWS(ISCM_SECJAWS) + $BDY_TOL) [
         DIST = (ZMIN_SECJAWS(ISCM_SECJAWS) - Z(NP) + $BDY_TOL)/W(NP);
         XPLN_SECJAWS = XY_SECJAWS + UV_SECJAWS * DIST;
         ZPLN_SECJAWS = Z(NP)+DIST*W(NP);
         IF(XPLN_SECJAWS > APO_SECJAWS(ISCM_SECJAWS)*ZPLN_SECJAWS +
            BPOT_SECJAWS(ISCM_SECJAWS,IB_SECJAWS))[
            "must check against plane of jaws at actual Z posn of particle"
            IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1) + 1;
         ]
         ELSEIF(XPLN_SECJAWS < ANE_SECJAWS(ISCM_SECJAWS)*ZPLN_SECJAWS +
                BNET_SECJAWS(ISCM_SECJAWS,IB_SECJAWS))[
            IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1) + 2;
         ]
         ELSE[
            DIST = (ZMAX_SECJAWS(ISCM_SECJAWS)-Z(NP) + $BDY_TOL)/W(NP);
            IF(DIST < 0) [DIST = 0.0;]
            IF(DIST=0. & ISCM_SECJAWS=ISCM_MAX_SECJAWS)[DIST=1.E-16;]
            XPLN_SECJAWS = XY_SECJAWS + UV_SECJAWS * DIST;
            ZPLN_SECJAWS = Z(NP)+DIST*W(NP);
            IRNEW_SECJAWS = IRSTART_SECJAWS + 3*ISCM_SECJAWS;
            IF(ISCM_SECJAWS = ISCM_MAX_SECJAWS)[IRNEW_SECJAWS =1;]
            DIST1=DIST;
            IF(XPLN_SECJAWS > APO_SECJAWS(ISCM_SECJAWS)*ZPLN_SECJAWS +
               BPOT_SECJAWS(ISCM_SECJAWS,IB_SECJAWS))[
               ;SECJAWS_TPOSITIVE;
               IF(DIST<DIST1)[
                 IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1) + 1;
               ]
               ELSE[
                 DIST=DIST1;
               ]
            ]
            ELSEIF(XPLN_SECJAWS < ANE_SECJAWS(ISCM_SECJAWS)*ZPLN_SECJAWS +
                BNET_SECJAWS(ISCM_SECJAWS,IB_SECJAWS))[
               ;SECJAWS_TNEGATIVE;
               IF(DIST<DIST1)[
                 IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1) + 2;
               ]
               ELSE[
                 DIST=DIST1;
               ]
            ]
         ]
      ]
      ELSE[ "Z(NP)> ZMIN_SECJAWS(ISCM_SECJAWS)
         IF( XY_SECJAWS > APO_SECJAWS(ISCM_SECJAWS)*Z(NP) +
             BPOT_SECJAWS(ISCM_SECJAWS,IB_SECJAWS) &
             Z(NP) > ZMIN_SECJAWS(ISCM_SECJAWS) + $BDY_TOL  &
             Z(NP) < ZMAX_SECJAWS(ISCM_SECJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1) + 1;
            USTEP = 0.0;
            RETURN;
         ]
         IF( XY_SECJAWS < ANE_SECJAWS(ISCM_SECJAWS)*Z(NP) +
             BNET_SECJAWS(ISCM_SECJAWS,IB_SECJAWS) &
             Z(NP) > ZMIN_SECJAWS(ISCM_SECJAWS) + $BDY_TOL &
             Z(NP) < ZMAX_SECJAWS(ISCM_SECJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1) + 2;
            USTEP = 0.0;
            RETURN;
         ]
         DIST = (ZMAX_SECJAWS(ISCM_SECJAWS) - Z(NP) + $BDY_TOL)/W(NP);
         IRNEW_SECJAWS = IRSTART_SECJAWS + 3*ISCM_SECJAWS;
         IF(ISCM_SECJAWS = ISCM_MAX_SECJAWS)[IRNEW_SECJAWS =1;]
         XPLN_SECJAWS = XY_SECJAWS + UV_SECJAWS * DIST;
         ZPLN_SECJAWS = Z(NP)+DIST*W(NP);
         DIST1=DIST;
         IF(XPLN_SECJAWS > APO_SECJAWS(ISCM_SECJAWS)*ZPLN_SECJAWS +
               BPOT_SECJAWS(ISCM_SECJAWS,IB_SECJAWS))[
            ;SECJAWS_TPOSITIVE;
            IF(DIST<DIST1)[
              IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1) + 1;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
         ELSEIF(XPLN_SECJAWS < ANE_SECJAWS(ISCM_SECJAWS)*ZPLN_SECJAWS +
                BNET_SECJAWS(ISCM_SECJAWS,IB_SECJAWS))[
            ;SECJAWS_TNEGATIVE;
            IF(DIST<DIST1)[
              IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1) + 2;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
      ]
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         IF (IRNEW_SECJAWS=1) ["leaving CM through back"
            CALL WHERE_AM_I(ICM_SECJAWS,1);
         ]
         ELSE ["still in CM, entering between bars
            IRNEW = IRNEW_SECJAWS; "new region number"
         ]
      ]
   ]"end of w > 0.0
   ELSEIF (W(NP) < 0.0)[
      IF(Z(NP) < ZMIN_SECJAWS(ISCM_SECJAWS) + $BDY_TOL) [
         IF(ISCM_SECJAWS = 1)[
            DIST = (ZFRONT_SECJAWS - Z(NP))/W(NP);
            IF(DIST <= 0)[ DIST = 1.E-16;]
            IRNEW_SECJAWS = 1;
         ]
         ELSE[ "  ISCM_SECJAWS > 1
            ;SECJAWS_SET_XY_UV(ISCM_SECJAWS-1);
            DIST = (ZMAX_SECJAWS(ISCM_SECJAWS-1) - Z(NP) - $BDY_TOL)/W(NP);
            XPLN_SECJAWS = XY_SECJAWS + UV_SECJAWS * DIST;
            ZPLN_SECJAWS = Z(NP) + DIST*W(NP);
            IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-2);
            IF(XPLN_SECJAWS > APO_SECJAWS(ISCM_SECJAWS-1)*ZPLN_SECJAWS +
               BPOT_SECJAWS(ISCM_SECJAWS-1,IB_SECJAWS))[
               IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-2) + 1;
            ]
            ELSEIF(XPLN_SECJAWS < ANE_SECJAWS(ISCM_SECJAWS-1)*ZPLN_SECJAWS +
                BNET_SECJAWS(ISCM_SECJAWS-1,IB_SECJAWS))[
               IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-2) + 2;
            ]
         ]
      ]
      ELSE[ "Z(NP)> ZMIN_SECJAWS(ISCM_SECJAWS)
         IF( XY_SECJAWS > APO_SECJAWS(ISCM_SECJAWS)*Z(NP) +
             BPOT_SECJAWS(ISCM_SECJAWS,IB_SECJAWS) &
             Z(NP) > ZMIN_SECJAWS(ISCM_SECJAWS) + $BDY_TOL  &
             Z(NP) < ZMAX_SECJAWS(ISCM_SECJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1) + 1;
            USTEP = 0.0;
            RETURN;
         ]
         IF( XY_SECJAWS < ANE_SECJAWS(ISCM_SECJAWS)*Z(NP) +
             BNET_SECJAWS(ISCM_SECJAWS,IB_SECJAWS) &
             Z(NP) > ZMIN_SECJAWS(ISCM_SECJAWS) + $BDY_TOL &
             Z(NP) < ZMAX_SECJAWS(ISCM_SECJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1) + 2;
            USTEP = 0.0;
            RETURN;
         ]
         DIST = (ZMIN_SECJAWS(ISCM_SECJAWS)-Z(NP) - $BDY_TOL)/W(NP);
         IF(DIST < 0)[ DIST = 0.0;]
         XPLN_SECJAWS = XY_SECJAWS + UV_SECJAWS * DIST;
         ZPLN_SECJAWS = Z(NP) + DIST*W(NP);
         DIST1=DIST;
         IF(XPLN_SECJAWS > APO_SECJAWS(ISCM_SECJAWS)*ZPLN_SECJAWS +
               BPOT_SECJAWS(ISCM_SECJAWS,IB_SECJAWS))[
            ;SECJAWS_TPOSITIVE;
            IF(DIST<DIST1)[
              IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1) + 1;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
         ELSEIF(XPLN_SECJAWS < ANE_SECJAWS(ISCM_SECJAWS)*ZPLN_SECJAWS +
                BNET_SECJAWS(ISCM_SECJAWS,IB_SECJAWS))[
            ;SECJAWS_TNEGATIVE;
            IF(DIST<DIST1)[
              IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1) + 2;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
         ELSE[
            IF(ISCM_SECJAWS = 1)[
               DIST = (ZFRONT_SECJAWS - Z(NP))/W(NP);
               IF(DIST <= 0)[ DIST = 1.E-16;]
               IRNEW_SECJAWS = 1;
            ]
            ELSE[ "  ISCM_SECJAWS > 1
               ;SECJAWS_SET_XY_UV(ISCM_SECJAWS-1);
               DIST = (ZMAX_SECJAWS(ISCM_SECJAWS-1) - Z(NP) - $BDY_TOL)/W(NP);
               IF(DIST < 0)[ DIST = 0.0;]
               XPLN_SECJAWS = XY_SECJAWS + UV_SECJAWS * DIST;
               ZPLN_SECJAWS = Z(NP) + DIST*W(NP);
               IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-2);
               IF(XPLN_SECJAWS > APO_SECJAWS(ISCM_SECJAWS-1)*ZPLN_SECJAWS +
                  BPOT_SECJAWS(ISCM_SECJAWS-1,IB_SECJAWS))[
                  IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-2) + 1;
               ]
               ELSEIF(XPLN_SECJAWS <
                      ANE_SECJAWS(ISCM_SECJAWS-1)*ZPLN_SECJAWS +
                      BNET_SECJAWS(ISCM_SECJAWS-1,IB_SECJAWS))[
                  IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-2) + 2;
               ]
            ]
         ]
      ]
      IF(DIST <= USTEP ) [
         USTEP = DIST;
         IF(IRNEW_SECJAWS = 1)["particle moving out from front CM
            CALL WHERE_AM_I(ICM_SECJAWS,-1);
         ]
         ELSE[  "still in CM
            USTEP = DIST;
            IRNEW = IRNEW_SECJAWS; "new region number"
         ]
      ]
   ] "end of w < 0.0
   ELSE[ "(W(NP) = 0.0
      DIST=1.0E20;
      IF(Z(NP) > ZMIN_SECJAWS(ISCM_SECJAWS) ) [
         IF(UV_SECJAWS > 0.0)[
            IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1) + 1;
            ;SECJAWS_TPOSITIVE;
         ]
         ELSE[
            IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1) + 2;
            ;SECJAWS_TNEGATIVE;
         ]
      ]
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         IRNEW = IRNEW_SECJAWS; "new region number"
      ]
   ]"end of w = 0.0
] "end of region 1
ELSEIF(IR_SECJAWS = 3*ISCM_SECJAWS-1) [ "particle in positive bars
   IB_SECJAWS=2;
   IF( XY_SECJAWS < APO_SECJAWS(ISCM_SECJAWS)*Z(NP) +
       BPOT_SECJAWS(ISCM_SECJAWS,IB_SECJAWS) &
      Z(NP) > ZMIN_SECJAWS(ISCM_SECJAWS) - $BDY_TOL  &
      Z(NP) < ZMAX_SECJAWS(ISCM_SECJAWS) + $BDY_TOL )[
      IRNEW = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1);
      USTEP = 0.0;
      RETURN;
   ]
   IF (W(NP) > 0.0) [
      DIST = (ZMAX_SECJAWS(ISCM_SECJAWS)-Z(NP)+$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IF(DIST=0. & ISCM_SECJAWS = ISCM_MAX_SECJAWS)[DIST=1.E-16;]
      IRNEW_SECJAWS = IRSTART_SECJAWS + 3*ISCM_SECJAWS;
      IF(ISCM_SECJAWS = ISCM_MAX_SECJAWS)[IRNEW_SECJAWS =1;]
      XPLN_SECJAWS = XY_SECJAWS + UV_SECJAWS * DIST;
      ZPLN_SECJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_SECJAWS < APO_SECJAWS(ISCM_SECJAWS)*ZPLN_SECJAWS +
       BPOT_SECJAWS(ISCM_SECJAWS,IB_SECJAWS))[
         IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1);
         ;SECJAWS_TPOSITIVE;
      ]
   ]"end of w > 0.0
   ELSEIF (W(NP) < 0.0)[
      DIST = (ZMIN_SECJAWS(ISCM_SECJAWS)-Z(NP)-$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1);
      XPLN_SECJAWS = XY_SECJAWS + UV_SECJAWS * DIST;
      ZPLN_SECJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_SECJAWS < APO_SECJAWS(ISCM_SECJAWS)*ZPLN_SECJAWS +
       BPOT_SECJAWS(ISCM_SECJAWS,IB_SECJAWS))[
         ;SECJAWS_TPOSITIVE;
      ]
   ] "end of w < 0.0
   ELSE[ "(W(NP) = 0.0
      DIST=1.0E20;
      IF(UV_SECJAWS < 0.0)[
         IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1);
         ;SECJAWS_TPOSITIVE;
      ]
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF (IRNEW_SECJAWS=1) ["leaving CM through back"
         CALL WHERE_AM_I(ICM_SECJAWS,1);
      ]
      ELSE ["still in CM, entering between bars
         IRNEW = IRNEW_SECJAWS; "new region number"
      ]
   ]
]  "end of region 2
ELSEIF(IR_SECJAWS = 3*ISCM_SECJAWS) [ "particle in negative bars
   IB_SECJAWS=2;
   IF( XY_SECJAWS > ANE_SECJAWS(ISCM_SECJAWS)*Z(NP) +
       BNET_SECJAWS(ISCM_SECJAWS,IB_SECJAWS) &
      Z(NP) > ZMIN_SECJAWS(ISCM_SECJAWS) - $BDY_TOL &
      Z(NP) < ZMAX_SECJAWS(ISCM_SECJAWS) + $BDY_TOL )[
      IRNEW = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1);
      USTEP = 0.0;
      RETURN;
   ]
   IF (W(NP) > 0.0) [
      DIST = (ZMAX_SECJAWS(ISCM_SECJAWS)-Z(NP)+$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IF(DIST=0. & ISCM_SECJAWS = ISCM_MAX_SECJAWS)[DIST=1.E-16;]
      IRNEW_SECJAWS = IRSTART_SECJAWS + 3*ISCM_SECJAWS;
      IF(ISCM_SECJAWS = ISCM_MAX_SECJAWS)[IRNEW_SECJAWS =1;]
      XPLN_SECJAWS = XY_SECJAWS + UV_SECJAWS * DIST;
      ZPLN_SECJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_SECJAWS > ANE_SECJAWS(ISCM_SECJAWS)*ZPLN_SECJAWS +
       BNET_SECJAWS(ISCM_SECJAWS,IB_SECJAWS))[
         IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1);
         ;SECJAWS_TNEGATIVE;
      ]
   ] "end of w > 0.0
   ELSEIF(W(NP) < 0.0)[
      DIST = (ZMIN_SECJAWS(ISCM_SECJAWS)-Z(NP)-$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1);
      XPLN_SECJAWS = XY_SECJAWS + UV_SECJAWS * DIST;
      ZPLN_SECJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_SECJAWS > ANE_SECJAWS(ISCM_SECJAWS)*ZPLN_SECJAWS +
       BNET_SECJAWS(ISCM_SECJAWS,IB_SECJAWS))[
         ;SECJAWS_TNEGATIVE;
      ]
   ]"end of w < 0.0
   ELSE[ "(W(NP) = 0.0
      DIST=1.0E20;
      IF(UV_SECJAWS > 0.0)[
         IRNEW_SECJAWS = IRSTART_SECJAWS + 3*(ISCM_SECJAWS-1);
         ;SECJAWS_TNEGATIVE;
      ]
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF (IRNEW_SECJAWS=1) ["leaving CM through back"
         CALL WHERE_AM_I(ICM_SECJAWS,1);
      ]
      ELSE ["still in CM, entering between bars
         IRNEW = IRNEW_SECJAWS; "new region number"
      ]
   ]
] "end of region 3
"end of CM regions"

"   outside of CM, something is wrong
"   =================================
"
ELSE ["something is wrong"
   OUTPUT IR(NP)-IRSTART_SECJAWS+1, IR(NP), ICM_SECJAWS,
          IR_start_CM(ICM_SECJAWS);
      (//' ************'//' HOWFAR_JAWS error'/
         '    Region, local, absolute =',2I5/
         '    CM number=',I5,' start region =',I5/
         ' *********'//);
   STOP;
] "end of IF statement"
RETURN;
END; "End of subroutine HOWFAR_SECJAWS"
%E   "Start of subroutine WHERE_AM_I_SECJAWS"
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_JAWS
"                          ***************************
"
" WHERE_AM_I routine for set of JAWS.
"
" WHERE_AM_I_SECJAWS determines the new region number when a particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_SECJAWS subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_SECJAWS from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************
;SUBROUTINE WHERE_AM_I_SECJAWS(IDIR);


;IMPLICIT NONE;
;COMIN/CM_SECJAWS,EPCONT,STACK/;

"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_JAWS
"T>**************************************
"T>
INTEGER IDIR;       "T>direction of particle, +1=forward, -1=backward
$REAL XBDY_SECJAWS;
XBDY_SECJAWS = X(NP) + U(NP)*USTEP;
IF(IXY_CHOICE_SECJAWS(ISCM_MAX_SECJAWS) = 1)[
   XBDY_SECJAWS = Y(NP) + V(NP)*USTEP;
]
IF (IDIR=1) ["particle entering this CM through front face (upstream)
   "$CHECK_FRONT_SECJAWS;"
   IRNEW = IRSTART_SECJAWS;
]
ELSE ["particle entering this CM through back face (downstream)
   IRNEW = IRSTART_SECJAWS + 3*ISCM_MAX_SECJAWS - 3;
   "$CHECK_BACK_SECJAWS;"
   IF(XBDY_SECJAWS > XBP_SECJAWS(ISCM_MAX_SECJAWS))[
      IRNEW = IRSTART_SECJAWS + 3*ISCM_MAX_SECJAWS-2;
   ]
   ELSEIF(XBDY_SECJAWS < XBN_SECJAWS(ISCM_MAX_SECJAWS))[
      IRNEW = IRSTART_SECJAWS + 3*ISCM_MAX_SECJAWS - 1;
   ]
]
RETURN;
END; "End of subroutine WHERE_AM_I_SECJAWS"
%E   "Start of subroutine INPUT_SECJAWS"
"*******************************************************************************
"
"                           Subroutine INPUT_JAWS
"                           **********************
"
"  A CM input subroutine for a series of 1 or more paired bars.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_SECJAWS;


;IMPLICIT NONE;
;COMIN/BOUNDS,CMs,CM_SECJAWS,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;

"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_JAWS
"T>*********************************
"T>
INTEGER I,J,         "T>DO loop indeces
        IRA,         "T>Absolute region number
        MED_FLAG,    "T>flag used by media-sort macro $MED_INPUT
        MED_INDEX;   "T>medium index, set after medium sort by $MED_INPUT

$REAL AIRGAPMIN_SECJAWS,  "T>minimum air gap in front and back of CM
      BDYTOL;          "T>stores $BDY_TOL
CHARACTER*1 XY_CHOICE(1);
"
"  initialize parameters
"  =====================
"
ICM_SECJAWS = ICM;      "CM index for this component module
IRSTART_SECJAWS = IR_start_CM(ICM_SECJAWS); "Index of first region in this CM,
                                      "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_SECJAWS) = 0; "Geometry-checking flag, 0 if no error detected
AIRGAPMIN_SECJAWS = 0.01; "Minimum 0.01 cm air gap at front and back of CM

OUTPUT RMAX_CM(ICM); (' This component is sets of paired bars or jaws'/
  '      Outer boundary is a square with |x| & |y| <',F10.2,' cm');
OUTPUT;(' TITLE: ',$);
;MINPUT (SECJAWS) TITLE_SECJAWS;(60A1);
                          ";MINPUT is a replacement macro with EOF and
                          "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_SECJAWS;(' ',60A1);
IF(ICM_SECJAWS = 1)[
   OUTPUT;(' This is the first component and starts at the reference plane');]
ELSE
   [OUTPUT Z_min_CM(ICM_SECJAWS);(' Previous CM ends at:',F12.5,' cm');]

"
"   get geometry information
"   =============================
"
"get the number of paired bars/jaws"
ISCM_MAX_SECJAWS = $MAX_N_SECJAWS; "Max number of paired bars/jaws permitted
OUTPUT ISCM_MAX_SECJAWS;
       (' NUMBER OF paired bars/jaws (minimum 1, maximum',I3,'): ',$);
;MINPUT (SECJAWS) ISCM_MAX_SECJAWS; (I5);
OUTPUT ISCM_MAX_SECJAWS; (I5);
IF(ISCM_MAX_SECJAWS > $MAX_N_SECJAWS)[
   OUTPUT ICM_SECJAWS, $MAX_N_SECJAWS;
   (//'***ERROR IN CM ',I4,' (JAWS):'/
      '# of paired bars > max. allowed.'/
      '# of pared bars reduced to ',I4,' for now.'//);
   ISCM_MAX_SECJAWS=$MAX_N_SECJAWS;
   IERR_GEOM(ICM_SECJAWS)=IERR_GEOM(ICM_SECJAWS)+1;
]
ELSEIF(ISCM_MAX_SECJAWS<1)[
   ISCM_MAX_SECJAWS=1;
   OUTPUT ICM_SECJAWS;
   (//'***ERROR IN CM ',I4,' (JAWS):'/
      '# of paired bars < 1'/
      '# of pared bars reset to 1 for now.'//);
   IERR_GEOM(ICM_SECJAWS)=IERR_GEOM(ICM_SECJAWS)+1;
]
N_SECJAWS = 3*ISCM_MAX_SECJAWS;

"loop over bars
DO I = 1,ISCM_MAX_SECJAWS ["loop to get each bar location"
   OUTPUT I;(/' Paired bar/jaw set no:',I3,/
    ' Are bars/jaws perpendicular to x or y axis'/
    ' i.e. is separation measured on x or y axis'/
    ' (Input "y" or "Y" for Y jaws, any other character for X jaws): ',$);
   ;MINPUT (SECJAWS) XY_CHOICE;(1A1);
   OUTPUT XY_CHOICE;(' ',1A1);
   IXY_CHOICE_SECJAWS(I) = 0;
   IF(XY_CHOICE(1) ='Y' | XY_CHOICE(1) ='y')[ IXY_CHOICE_SECJAWS(I) = 1;]
   IF(IXY_CHOICE_SECJAWS(I) = 0)["this is x bars/jaws"
         OUTPUT;(' Input ZMIN, ZMAX & jaw coordinates: XFP, XBP,',
         ' XFN, XBN(cm) all on one line');
   ]
   ELSE ["this is y bars/jaws"
         OUTPUT;(' Input ZMIN, ZMAX & jaw coordinates: YFP, YBP,',
         ' YFN, YBN(cm) all on one line');
   ]
   IF(I=1)[
         OUTPUT AIRGAPMIN_SECJAWS;
          (' (leave at least min. airgap = ',F8.5,' before 1st jaws)',
          /' : ',$);
   ]
   ELSE[
         OUTPUT AIRGAPMIN_SECJAWS;
          (' (leave at least min. airgap = ',F8.5,' between jaws)',
           /' : ',$);
   ]
   ;MINPUT (SECJAWS) ZMIN_SECJAWS(I), ZMAX_SECJAWS(I), XFP_SECJAWS(I),
      XBP_SECJAWS(I), XFN_SECJAWS(I), XBN_SECJAWS(I);(6F15.0);
   ;OUTPUT ZMIN_SECJAWS(I),ZMAX_SECJAWS(I), XFP_SECJAWS(I),
      XBP_SECJAWS(I), XFN_SECJAWS(I),XBN_SECJAWS(I); (6F11.5);
   IF(I=1)[
       IF(ICM_SECJAWS=1 &
         Z_min_CM(ICM_SECJAWS)>ZMIN_SECJAWS(1)-AIRGAPMIN_SECJAWS)[
         OUTPUT ICM_SECJAWS, AIRGAPMIN_SECJAWS,
         ZMIN_SECJAWS(1)-AIRGAPMIN_SECJAWS,Z_min_CM(1);
           (//' ***WARNING IN CM ',I4,' (JAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between top',
              ' of CM and 1st jaws.'/
              ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
           WRITE(IOUTLIST,100)ICM_SECJAWS, AIRGAPMIN_SECJAWS,
              ZMIN_SECJAWS(1)-AIRGAPMIN_SECJAWS,Z_min_CM(1);
          100 FORMAT(//' ***WARNING IN CM ',I4,' (JAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between top',
              ' of CM and 1st jaws.'/
              ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
          Z_min_CM(1)=ZMIN_SECJAWS(1)-AIRGAPMIN_SECJAWS;
       ]
       ELSEIF(Z_min_CM(ICM_SECJAWS)>ZMIN_SECJAWS(1))[
         OUTPUT ICM_SECJAWS;
           (//'***ERROR IN CM ',I4,' (JAWS):'/
              'Overlaps with previous CM'//);
           IERR_GEOM(ICM_SECJAWS)=IERR_GEOM(ICM_SECJAWS)+1;
       ]
       ELSEIF(Z_min_CM(ICM_SECJAWS)>ZMIN_SECJAWS(1)-AIRGAPMIN_SECJAWS)[
         OUTPUT ICM_SECJAWS, AIRGAPMIN_SECJAWS,
         Z_min_CM(ICM_SECJAWS)+AIRGAPMIN_SECJAWS,
                ZMIN_SECJAWS(1);
           (//' ***WARNING IN CM ',I4,' (JAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         WRITE(IOUTLIST,101)ICM_SECJAWS, AIRGAPMIN_SECJAWS,
                Z_min_CM(ICM_SECJAWS)+AIRGAPMIN_SECJAWS,ZMIN_SECJAWS(1);
         101 FORMAT(//' ***WARNING IN CM ',I4,' (JAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         ZMIN_SECJAWS(1)=Z_min_CM(ICM_SECJAWS)+AIRGAPMIN_SECJAWS;
       ]
   ]
   ELSE[
     IF (ZMAX_SECJAWS(I-1)>ZMIN_SECJAWS(I))[
        OUTPUT ICM_SECJAWS, I-1, I;
         (//'***ERROR IN CM ',I4,' (JAWS):'/
            'Paired bars ',I4,' overlap with paired bars ',I4//);
        IERR_GEOM(ICM_SECJAWS)=IERR_GEOM(ICM_SECJAWS)+1;
     ]
     ELSEIF (ZMAX_SECJAWS(I-1)>ZMIN_SECJAWS(I)-AIRGAPMIN_SECJAWS)[
        OUTPUT ICM_SECJAWS, AIRGAPMIN_SECJAWS, I-1, I, I,
                ZMAX_SECJAWS(I-1)+AIRGAPMIN_SECJAWS,ZMIN_SECJAWS(I);
          (//' ***WARNING IN CM ',I4,' (JAWS):'/
             ' Less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        WRITE(IOUTLIST,102)ICM_SECJAWS, AIRGAPMIN_SECJAWS, I-1, I, I,
                ZMAX_SECJAWS(I-1)+AIRGAPMIN_SECJAWS,ZMIN_SECJAWS(I);
        102 FORMAT(//' ***WARNING IN CM ',I4,' (JAWS):'/
             ' Less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        ZMIN_SECJAWS(I)=ZMAX_SECJAWS(I-1)+AIRGAPMIN_SECJAWS;
     ]
   ]
   IF(ZMIN_SECJAWS(I) >= ZMAX_SECJAWS(I))[
      OUTPUT ICM_SECJAWS, I, I;
        (//'***ERROR IN CM ',I4,' (JAWS):'/
           'ZMIN(',I4,') >= ZMAX(',I4,')'//);
      IERR_GEOM(ICM_SECJAWS)=IERR_GEOM(ICM_SECJAWS)+1;
   ]
   IF(ABS(XFP_SECJAWS(I))>RMAX_CM(ICM_SECJAWS))[
      OUTPUT ICM_SECJAWS, I;
        (//'***ERROR IN CM ',I4,' (JAWS):'/
           'XFP(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_SECJAWS)=IERR_GEOM(ICM_SECJAWS)+1;
   ]
   IF(ABS(XBP_SECJAWS(I))>RMAX_CM(ICM_SECJAWS))[
      OUTPUT ICM_SECJAWS, I;
        (//'***ERROR IN CM ',I4,' (JAWS):'/
           'XBP(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_SECJAWS)=IERR_GEOM(ICM_SECJAWS)+1;
   ]
   IF(ABS(XFN_SECJAWS(I))>RMAX_CM(ICM_SECJAWS))[
      OUTPUT ICM_SECJAWS, I;
        (//'***ERROR IN CM ',I4,' (JAWS):'/
           'XFN(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_SECJAWS)=IERR_GEOM(ICM_SECJAWS)+1;
   ]
   IF(ABS(XBN_SECJAWS(I))>RMAX_CM(ICM_SECJAWS))[
      OUTPUT ICM_SECJAWS, I;
        (//'***ERROR IN CM ',I4,' (JAWS):'/
           'XBN(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_SECJAWS)=IERR_GEOM(ICM_SECJAWS)+1;
   ]
   IF(XFP_SECJAWS(I) < XFN_SECJAWS(I))[
      OUTPUT ICM_SECJAWS, I, I;
        (//'***ERROR IN CM ',I4,' (JAWS):'/
           'XFP(',I4,') < XFN(',I4,')'//);
      IERR_GEOM(ICM_SECJAWS)=IERR_GEOM(ICM_SECJAWS)+1;
   ]
   ELSEIF(XFP_SECJAWS(I) - XFN_SECJAWS(I) < $BDY_TOL*3 )[
      XFP_SECJAWS(I) = XFP_SECJAWS(I) + $BDY_TOL*2;
      XFN_SECJAWS(I) = XFN_SECJAWS(I) - $BDY_TOL*2;
   ]
   IF(XBP_SECJAWS(I) < XBN_SECJAWS(I))[
      OUTPUT ICM_SECJAWS, I, I;
        (//'***ERROR IN CM ',I4,' (JAWS):'/
           'XBP(',I4,') < XBN(',I4,')'//);
      IERR_GEOM(ICM_SECJAWS)=IERR_GEOM(ICM_SECJAWS)+1;
   ]
   ELSEIF(XBP_SECJAWS(I) - XBN_SECJAWS(I) < $BDY_TOL*3 )[
      XBP_SECJAWS(I) = XBP_SECJAWS(I) + $BDY_TOL*2;
      XBN_SECJAWS(I) = XBN_SECJAWS(I) - $BDY_TOL*2;
   ]
] "end of loop over paired bars/jaws"

"set absolute region number to first region in CM for next set of inputs"
IRA = IRSTART_SECJAWS; "absolute region number
OUTPUT ; (/'  Now input data re ECUT and PCUT for each region'/
         /' For central region which is assumed to be air'
         /' ECUT,       PCUT,   DOSE ZONE OF AIR,   REGION TO BIT '/' : ',$);
MINPUT (SECJAWS) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
        (2F15.0,2I5);
OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA); (2F11.5,2I5);
IF (ECUT(IRA) <  ECUTIN) ECUT(IRA)=ECUTIN;
IF (PCUT(IRA) <  PCUTIN) PCUT(IRA)=PCUTIN;
"get material for each bar and determine material number for these regions
MED(IRA) = AIR_INDEX; " medium of air
"
"now get info on each set of jaws"
DO IR_SECJAWS = 2, N_SECJAWS-1, 3[
   IRA = IRSTART_SECJAWS  + IR_SECJAWS - 1;"this is absolute region number"
   "central region air, so pick up same parameters as assigned above"
   "this is redundant on first time thru loop"
   ECUT(IRA-1) = ECUT(IRSTART_SECJAWS);
   PCUT(IRA-1) = PCUT(IRSTART_SECJAWS);
   DOSE_ZONE(IRA-1) = DOSE_ZONE(IRSTART_SECJAWS);
   MED(IRA-1) = AIR_INDEX; " medium of air
   OUTPUT IR_SECJAWS/3 + 1 ; (/' Paired bars/jaws no:',I3,
         /' ECUT,        PCUT,       DOSE ZONE,    IREGION_TO_BIT '/' :',$);
  ;MINPUT (SECJAWS) ECUT(IRA), PCUT(IRA), DOSE_ZONE(IRA),
          IREGION_TO_BIT(IRA); (2F15.0,2I5);
  ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
          IREGION_TO_BIT(IRA); (2F11.5,2I5);
   IREGION_TO_BIT(IRA -1) = IREGION_TO_BIT(IRSTART_SECJAWS);
   IF (ECUT(IRA) <  ECUTIN) ECUT(IRA)=ECUTIN;
   IF (PCUT(IRA) <  PCUTIN) PCUT(IRA)=PCUTIN;
   "get material for each bar and determine material number for these regions
   OUTPUT;(' Medium in this region',$);
   $MED_INPUT(SECJAWS); " inputs character array MED_IN from unit 5, loops
      "through array MEDIA(24,I) to check if medium was previously input.
      "If so, sets MED_INDEX to index of previous medium.  If not,
      "increments NMED and sets MED_INDEX to NMED.
      "error transfers to :ERROR_SECJAWS:
   MED(IRA) = MED_INDEX; " medium of the planar slab
   "both parts of jaw are same material so transfer parameters"
   ECUT(IRA+1) = ECUT(IRA);
   PCUT(IRA+1) = PCUT(IRA);
   DOSE_ZONE(IRA+1) = DOSE_ZONE(IRA);
   IREGION_TO_BIT(IRA +1) = IREGION_TO_BIT(IRA);
   MED(IRA+1) = MED(IRA); "
] "end of loop over IR_SECJAWS"
;
"  set up region numbers
"  =====================
"
"  CM has 4xISCM_MAX_SECJAWS regions, series of paired bars/jaws surrounded
"  by an air region.  paired bars are numbered in sequence starting from the
"  furthest upstream.
"
IREND_SECJAWS = IRSTART_SECJAWS + N_SECJAWS-1;  "Index of last region
NREG = NREG+N_SECJAWS;           "Total number of regions in full geometry up
                                "to and including this CM
IF (NREG <= $MXREG) ["have not exceeded maximum region number
      "Index of first region in next CM:"
      IR_start_CM(ICM_SECJAWS+1) = IREND_SECJAWS+1;
]
ELSE [
      OUTPUT ICM_SECJAWS,NREG,$MXREG;
      (//'***ERROR IN CM ',I4,' (JAWS):'/
         I4,' regions requested, only ',I4,' available'//);
      IERR_GEOM(ICM_SECJAWS)=IERR_GEOM(ICM_SECJAWS)+1;
]
"
"  parameter definition
"  ====================
"
"geometrical coordinates
"
"
DO I = 1, ISCM_MAX_SECJAWS[
   APO_SECJAWS(I) = (XBP_SECJAWS(I)-XFP_SECJAWS(I))/
                           (ZMAX_SECJAWS(I) - ZMIN_SECJAWS(I));
   ANE_SECJAWS(I) = (XBN_SECJAWS(I)-XFN_SECJAWS(I))/
                           (ZMAX_SECJAWS(I) - ZMIN_SECJAWS(I));
   BPO_SECJAWS(I) =  XFP_SECJAWS(I) - ZMIN_SECJAWS(I)*APO_SECJAWS(I);
   BNE_SECJAWS(I) =  XFN_SECJAWS(I) - ZMIN_SECJAWS(I)*ANE_SECJAWS(I);
   COSP_SECJAWS(I)= (ZMAX_SECJAWS(I) - ZMIN_SECJAWS(I))/
                 SQRT( (ZMAX_SECJAWS(I) - ZMIN_SECJAWS(I))**2
                      +( XBP_SECJAWS(I) - XFP_SECJAWS(I) )**2 );
   COSN_SECJAWS(I)= (ZMAX_SECJAWS(I) - ZMIN_SECJAWS(I))/
                 SQRT( (ZMAX_SECJAWS(I) - ZMIN_SECJAWS(I))**2
                       + (XBN_SECJAWS(I) - XFN_SECJAWS(I))**2 );
]

BDYTOL = $BDY_TOL;
DO I = 1,ISCM_MAX_SECJAWS ["loop through bars"
   XFPT_SECJAWS(I,1)  = XFP_SECJAWS(I) + BDYTOL;
   XFPT_SECJAWS(I,2)  = XFP_SECJAWS(I) - BDYTOL;
   XBPT_SECJAWS(I,1)  = XBP_SECJAWS(I) + BDYTOL;
   XBPT_SECJAWS(I,2)  = XBP_SECJAWS(I) - BDYTOL;
   XFNT_SECJAWS(I,1)  = XFN_SECJAWS(I) - BDYTOL;
   XFNT_SECJAWS(I,2)  = XFN_SECJAWS(I) + BDYTOL;
   XBNT_SECJAWS(I,1)  = XBN_SECJAWS(I) - BDYTOL;
   XBNT_SECJAWS(I,2)  = XBN_SECJAWS(I) + BDYTOL;
   BPOT_SECJAWS(I,1) =  BPO_SECJAWS(I) + BDYTOL;
   BPOT_SECJAWS(I,2) =  BPO_SECJAWS(I) - BDYTOL;
   BNET_SECJAWS(I,1) =  BNE_SECJAWS(I) - BDYTOL;
   BNET_SECJAWS(I,2) =  BNE_SECJAWS(I) + BDYTOL;
] "end of loop over I"
"

"establish start of next CM
Z_min_CM(ICM_SECJAWS+1) = ZMAX_SECJAWS(ISCM_MAX_SECJAWS);
"
"
ZFRONT_SECJAWS = Z_min_CM(ICM_SECJAWS);
ZBACK_SECJAWS = Z_min_CM(ICM_SECJAWS+1);
"
"  establish CM boundary is a square
"  =================================
"
RMAX_CM_FLAG(ICM_SECJAWS) = 2; "=> put a square boundary about CM

"
"  establish dose-scoring zones and range rejection parameters for each region
"  ===========================================================================
"
IRA = IRSTART_SECJAWS-1; "absolute region number
DO IR_SECJAWS=1,N_SECJAWS ["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones and latch
   "
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones"
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT);

   "charged particle range rejection parameters
   "
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region
] "end of loop over IR_SECJAWS
E_min_out(ICM_SECJAWS)=ECUT(IRA); "Minimum energy on exit from CM


"   return from INPUT_JAWS
"   =======================
"
RETURN;

"   error messages
"   ==============
"
:EOF_SECJAWS:
;OUTPUT ICM;(//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_SECJAWS:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;
END;  "End of INPUT_SECJAWS"
%E   "Start of subroutine ISUMRY_SECJAWS"
"*******************************************************************************
"
"                          Subroutine ISUMRY_JAWS
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_SECJAWS;


;IMPLICIT NONE;

;COMIN/
   BOUNDS,CMs,CM_SECJAWS,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_JAWS
"T>**********************************
"T>

INTEGER
   ICOLOUR,   "T>colour of CM for EGS_Windows
   IRA,       "T>absolute region number
   I,J;       "T>DO loop index

$REAL
   XYMAX,     "T>X or Y boundary
   VOLAIR_SECJAWS,  "T>air volume
   VOL_SECJAWS($MAX_N_SECJAWS); "T>volume of air between bar
CHARACTER*1 XY_CHOICE(1);

"   Mass of dose zone
"   =================
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_SECJAWS.
"
IRA = IRSTART_SECJAWS-2; "absolute region number
VOLAIR_SECJAWS=(ZBACK_SECJAWS-ZFRONT_SECJAWS)*
            4.*RMAX_CM2(ICM_SECJAWS);"air volume"
DO I = 1,ISCM_MAX_SECJAWS [
  IRA=IRA+3;
   VOL_SECJAWS(I)=(ZMAX_SECJAWS(I)-ZMIN_SECJAWS(I))*
               (4.*RMAX_CM2(ICM_SECJAWS)-
               RMAX_CM(ICM_SECJAWS)*
               ABS(XFP_SECJAWS(I)+
               XBP_SECJAWS(I)-XFN_SECJAWS(I)-
               XBN_SECJAWS(I)));
   VOLAIR_SECJAWS=VOLAIR_SECJAWS-VOL_SECJAWS(I);
   IF(DOSE_ZONE(IRA)~=0) [ "this is a dose zone"
      ID=DOSE_ZONE(IRA);
     AMASS(ID)=AMASS(ID)+RHOR(IRA)*VOL_SECJAWS(I);
   ]
] "end of loop over IR_SECJAWS"
IRA = IRSTART_SECJAWS; "absolute region number
IF(DOSE_ZONE(IRA)~=0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+RHOR(IRA)*VOLAIR_SECJAWS;
]


"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"
WRITE(IOUTLIST,110) ICM_SECJAWS,TITLE_SECJAWS;
WRITE(IOUTLIST,120) Z_min_CM(ICM_SECJAWS),RMAX_CM(ICM_SECJAWS);
WRITE(IOUTLIST,122);
DO I=1, ISCM_MAX_SECJAWS[
   IF(I=1)[
        WRITE(IOUTLIST,124)'airgap',Z_min_CM(ICM_SECJAWS),ZMIN_SECJAWS(1)-
                           Z_min_CM(ICM_SECJAWS),'NA','NA','NA','NA',
                           'NA';
   ]
   ELSE[
        WRITE(IOUTLIST,124)'airgap',ZMAX_SECJAWS(I-1),ZMIN_SECJAWS(I)-
                           ZMAX_SECJAWS(I-1),'NA','NA','NA','NA',
                           'NA';
   ]
   IF(IXY_CHOICE_SECJAWS(I) = 0)[XY_CHOICE(1) ='x';]
   ELSE[XY_CHOICE(1) ='y';]
   WRITE(IOUTLIST,123)I,ZMIN_SECJAWS(I),ZMAX_SECJAWS(I)-
                      ZMIN_SECJAWS(I),XY_CHOICE(1),
                      XFP_SECJAWS(I),XBP_SECJAWS(I),
                      XFN_SECJAWS(I),XBN_SECJAWS(I);
]
WRITE(IOUTLIST,130);
IRA = IRSTART_SECJAWS-1;
DO I = 1, ISCM_MAX_SECJAWS [
   IRA = IRSTART_SECJAWS + 3*(I-1);
   IF(MED(IRA)~=0)[
      WRITE(IOUTLIST,140) 3*(I-1)+1,I,'airgap',
        ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),(MEDIA(J,MED(IRA)),J=1,9);
        WRITE(IOUTLIST,141)'above &';
        WRITE(IOUTLIST,141)'centre';
   ]
   ELSE[
      WRITE(IOUTLIST,140) 3*(I-1)+1,I,'airgap',
        ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
        WRITE(IOUTLIST,141)'above &';
        WRITE(IOUTLIST,141)'centre';
   ]
   IF(MED(IRA+1)~=0)[
      WRITE(IOUTLIST,140) 3*(I-1)+2,I,'+ve jaw',
        ECUT(IRA+1),PCUT(IRA+1), ECUTRR(IRA+1),ESAVE(IRA+1),
        DOSE_ZONE(IRA+1),
         IREGION_TO_BIT(IRA+1),(MEDIA(J,MED(IRA+1)),J=1,9);
   ]
   ELSE[
      WRITE(IOUTLIST,140) 3*(I-1)+2,I,'+ve jaw',
        ECUT(IRA+1),PCUT(IRA+1), ECUTRR(IRA+1),ESAVE(IRA+1),
        DOSE_ZONE(IRA+1),
         IREGION_TO_BIT(IRA+1),'V','a','c','u','u','m';
   ]
   IF(MED(IRA+2)~=0)[
      WRITE(IOUTLIST,140) 3*(I-1)+3,I,'-ve jaw',
        ECUT(IRA+2),PCUT(IRA+2), ECUTRR(IRA+2),ESAVE(IRA+2),
        DOSE_ZONE(IRA+2),
         IREGION_TO_BIT(IRA+2),(MEDIA(J,MED(IRA+2)),J=1,9);
   ]
   ELSE[
      WRITE(IOUTLIST,140) 3*(I-1)+3,I,'-ve jaw',
        ECUT(IRA+2),PCUT(IRA+2), ECUTRR(IRA+2),ESAVE(IRA+2),
        DOSE_ZONE(IRA+2),
         IREGION_TO_BIT(IRA+2),'V','a','c','u','u','m';
   ]
   WRITE(IOUTLIST,141)' ';
]
110 FORMAT(///1X,79('-')/
'  Component module',I3,' is JAWS'
           /1X,79('-')
           //T5,'Title: ',68A1);
120 FORMAT(/T2,'SECJAWS geometry parameters:',
           /T2,'-----------------------------',
           /T2,'Distance of front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Half-width of outer boundary of CM = ',F15.5,' cm');
122 FORMAT(/T2,
'jaw #    Z front    thickness    x or y               coordinates',
/T2,
'          face                   jaws        FP       BP       FN',
'      BN',
/T2,
'          (cm)        (cm)                                (cm)');
123 FORMAT(T2,I3,F12.3,F11.3,9X,A1,F12.3,F9.3,F9.3,F9.3);
124 FORMAT(T2,A6,F9.3,F11.3,8X,A2,A11,A9,A9,A8);
130 FORMAT(/T2,'SECJAWS region parameters:',
           /T2,'---------------------------',
           /T2,'local jaw #   location  electron  photon',
           '  range-rejection   dose  bit  medium'
           /T2,'region                   cutoff   cutoff',
           '   level     max    zone  set'
           /T2,'                          (MeV)    (MeV)',
           '   (MeV)    (MeV)');
140 FORMAT(T2,I3,I7,4X,A7,F10.3,F9.3,F8.3,F9.3,I6,I5,2X,9A1);
141 FORMAT(15X,A7);


"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"
IF (IWATCH = 4 | IZLAST = 2) ["Graphics file requested"
   ;$SELECT-COLOUR; "Macro for selecting ICOLOUR = 1, 2, or 3, colour of CM"
   DO I =1,ISCM_MAX_SECJAWS["Loop over local region number"
      XYMAX = RMAX_CM(ICM_SECJAWS);
         IF(IXY_CHOICE_SECJAWS(I) = 0)[
            WRITE(IOUTGEOM,200)
               ICOLOUR,'COLX',XYMAX,XFP_SECJAWS(I),XBP_SECJAWS(I),XYMAX,XYMAX,
               ZMIN_SECJAWS(I),ZMAX_SECJAWS(I);
            WRITE(IOUTGEOM,200)
              ICOLOUR,'COLX',XFN_SECJAWS(I),-XYMAX,-XYMAX,XBN_SECJAWS(I),
              XYMAX, ZMIN_SECJAWS(I),ZMAX_SECJAWS(I);
         ]
         ELSEIF(IXY_CHOICE_SECJAWS(I) = 1)[
            J = ICOLOUR-1;
            IF(J < 1)[J = 4;]
            WRITE(IOUTGEOM,200)
               J,'COLY',XYMAX,XFP_SECJAWS(I),XBP_SECJAWS(I),XYMAX,XYMAX,
               ZMIN_SECJAWS(I),ZMAX_SECJAWS(I);
            WRITE(IOUTGEOM,200)
               J,'COLY',XFN_SECJAWS(I),-XYMAX,-XYMAX,XBN_SECJAWS(I),XYMAX,
               ZMIN_SECJAWS(I),ZMAX_SECJAWS(I);
         ]
   ]
] "End of graphics output"

200 FORMAT(' ',I1,A4,10(F7.2,','));

"   end of ISUMRY_JAWS
"   ===================
"
RETURN;
END;  "End of subroutine ISUMRY_SECJAWS"

%E   "Start of subroutine HOWNEAR_SECJAWS"
"******************************************************************************
"
"                          Subroutine HOWNEAR_JAWS
"                          ***********************
"
" Returns min. distance to nearest region boundary
" Replaces the old HOWNEAR macro.
"
"*******************************************************************************
;SUBROUTINE HOWNEAR_SECJAWS(DIST);


$IMPLICIT-NONE;

COMIN/CM_SECJAWS,STACK/;

$REAL DIST; "T> min. distance to nearest boundary

IR_SECJAWS = IR(NP)-IRSTART_SECJAWS+1;
ISCM_SECJAWS = (IR_SECJAWS-1)/3 + 1;
XY_SECJAWS = X(NP);
UV_SECJAWS = U(NP);
IF(IXY_CHOICE_SECJAWS(ISCM_SECJAWS) = 1)[
   XY_SECJAWS = Y(NP);
   UV_SECJAWS = V(NP);
]
IF(IR_SECJAWS = 3*ISCM_SECJAWS-1) [ "particle in positive bars"
   DIST = COSP_SECJAWS(ISCM_SECJAWS)
          *(XY_SECJAWS-APO_SECJAWS(ISCM_SECJAWS)*Z(NP)
           -BPOT_SECJAWS(ISCM_SECJAWS,2));
   DIST = MIN(DIST,
              ZMAX_SECJAWS(ISCM_SECJAWS)-Z(NP),
              Z(NP) - ZMIN_SECJAWS(ISCM_SECJAWS));
]
ELSEIF(IR_SECJAWS = 3*ISCM_SECJAWS) [ "particle in negative bars"
   DIST = COSN_SECJAWS(ISCM_SECJAWS)
          *(ANE_SECJAWS(ISCM_SECJAWS)*Z(NP)
          +BNET_SECJAWS(ISCM_SECJAWS,2)-XY_SECJAWS) ;
   DIST = MIN(DIST,
              ZMAX_SECJAWS(ISCM_SECJAWS) - Z(NP),
              Z(NP) - ZMIN_SECJAWS(ISCM_SECJAWS) );
]
ELSE[ "particle in air"
   DIST = 0.0;
]
RETURN;
END; "End of subroutine HOWNEAR_SECJAWS"
"*******************************************************************************
"End of JAWS_cm.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: stacked planes                            "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Geoff Zhang                                               "
"                   Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code originally evolved from the SLAB component module written by     "
"  Dave Rogers and Bruce Faddegon, starting in 1991, and subsequently edited  "
"  by George Ding.                                                            "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             ***********             ""toc:
"                             *         *             ""toc:
"                             *  SLABS  *             ""toc:
"                             *         *             ""toc:
"                             ***********             ""toc:
"
"   History of modifications given by sccs
"
"*******************************************************************************
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.  Multiple planes of arbitrary thickness and
"   material.
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator:  a set of 2 or more
"   slabs infinite in x & y.
"
"   This component module can be added to the simulation by including these
"   routines in the MORTRAN file BEAM_CM.MORTRAN and including the MORTRAN
"   replacement macros associated with this component module in the file
"   BEAM_COMMON.MORTRAN.  The order of the component modules in either of
"   these files is unimportant.  To explicitly include this component module in
"   the simulation it must be included in the $CM_LIST replacement statement.
"   The component modules in this list are stacked sequentially for the
"   simulation, one on top of the other, and must not overlap.
;
%E   " SLABS_cm.mortran - start of geometry description
"I>
"I> Geometry of AIRSLAB (SLABS):             ""toc:
"I> ******************
"I>
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I> -------->    IR=    | IR=1   |  IR=2    | ...... |  IR=N_SLABS    |
"I>    beam   N_SLABS+1 |        |          |        |                |
"I> direction  (airgap) |        |          |        |                |
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I>                     |        |          |        |                |
"I>
"I>   IR is the region number within the CM.  There are N_SLABS(+1) local
"I>   regions. The first region is the slab furthest upstream.  If there
"I>   is an airgap at the front (top) then it is the last region,
"I>   otherwise the last region is the slab furthest downstream.
"I>
"I>
"I>            -----------------------------------------------
"I>            |          Region        | Description        |
"I>            |------------------------|--------------------|
"I>            |  absolute    | local   |                    |
"I>            |--------------|---------|                    |
"I>            |IRSTART_SLABS | IR_SLABS| slab infinite x, y |
"I>            |  +IR_SLABS-1 |         |                    |
"I>            -----------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_AIRSLAB
"                      ISUMRY_AIRSLAB
"                      HOWFAR_AIRSLAB
"                      WHERE_AM_I_AIRSLAB
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS ON USE/BUGS             ""toc:
"                             ************************
"
"         As structured, one cannot assign IREGION_TO_BIT or DOSE_ZONE values
"         to the air gap region if it exists.
"
"        in EGS_WINDOWS file, a disk instead of square is output
"
"*******************************************************************************
"
;
"*******************************************************************************
"**************************  DESCRIPTION OF VARIABLES  *************************
"*******************************************************************************
"
"
"                                OTHER VARIABLES
"                                ***************
"
"  Refer to the section on type declarations for each subroutine. The following
"  section describes the variables input from unit 5.  These variables define
"  the parameters of each simulation.
"
"*******************************************************************************
"
"                               INPUT FROM UNIT 5              ""toc:
"                               *****************             ""toc:
"
"I>
"I>  CARDS CM_AIRSLAB  (SLABS)
"I>  **************
"I>
"I>  -1  dummy line (filled with ****)  read in main
"I>
"I>   0  RMAX_CM(ICM_AIRSLAB)       outer boundary for CM - 1/2 side of
"I>                                square(read in main)
"I>
"I>   1  TITLE_AIRSLAB (60A1):  Title of CM.
"I>
"I>   2  N_AIRSLAB (I5):  Number of planar slabs in CM = # regions in CM,
"I>                      excludes any air gap needed.
"I>
"I>   3  ZMIN_AIRSLAB (F15.0):  Distance from front of first slab to reference
"I>                            plane  (Z=0).
"I>
"I>   4  Parameters of each slab from front to back (increasing Z).  One pair of
"I>      cards (4a and 4b) for each of the slabs.
"I>
"I>      4a   ZTHICK_AIRSLAB, ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT, ESAVEIN
"I>                           (3F15.0,2I5,F15.0):
"I>
"I>              ZTHICK_AIRSLAB:   slab thickness.
"I>              ECUT, PCUT:      Cutoff energies-defaults are ECUTIN,PCUTIN
"I>              DOSE_ZONE:       Dose zone to score dose - 0 if not scored
"I>              IREGION_TO_BIT:  map this region to this bit number in LATCH
"I>              ESAVEIN:         Value of ESAVE for this region if range
"I>                               rejection on. Default is ESAVE_GLOBAL.
"I>
"I>      4b   MED_IN (24A1):  Medium of the planar slab, used to set MED_INDEX.
"I>
"I>   Example
"I>   *******
"I>
"I>  The following set of cards defines a 1 cm thick slab of air sandwiched
"I>  between two 0.1 cm thick slabs of tungsten.  The front slab is at
"I>  Z=7.32 cm. Electrons will be followed in the slabs down to kinetic energies
"I>  of 10 keV (total energies of 0.521 MeV) and photons will be followed down
"I>  to energies of 1 keV.  The dose deposited in the air will be scored and
"I>  added to the dose from the other regions in dose zone 1, and the
"I>  dose deposited in both tungsten slabs will be scored and added to the dose
"I>  from the other regions in dose zone 2.  Particles interacting in
"I>  the first slab will be associated with BIT 1 in LATCH.  In all slabs,
"I>  ESAVEIN=0, thus ESAVE in each slab will default to ESAVE_GLOBAL.
"I>
"I>  10.0,                         RMAX_CM
"I>  Multiple slabs: 0.1cm W-1cm air-0.1cm W, ECUT=0.521, PCUT=0.001
"I>  3,                            N_SLABS
"I>  7.32,                         ZMIN_SLABS
"I>  0.1, 0.521, 0.001, 2,1,0.0,   ZTHICK_SLABS etc
"I>  W521ICRU
"I>  1., 0.521, 0.001, 1,0,0.0
"I>  AIR521ICRU
"I>  0.1, 0.521, 0.001, 2,0,0.0
"I>  W521ICRU
"
"
%E   "Start of subroutine INPUT_AIRSLAB"
"*******************************************************************************
"
"                           Subroutine INPUT_SLABS
"                           **********************
"
"  A CM input subroutine for a series of 1 or more slabs infinite in x & y.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_AIRSLAB;


;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_AIRSLAB,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;
"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_SLABS
"T>*********************************
"T>
$REAL ZMIN_AIRSLAB,                   "T>minimum Z for this CM
      ESAVEIN;                       "T>ESAVE value read in for each region

INTEGER I,J,                         "T>DO loop indeces
        IRA,                         "T>Absolute region number
        MED_FLAG,                    "T>flag for media-sort macro $MED_INPUT
        MED_INDEX,                   "T>medium index,set(post)sort $MED_INPUT
        NDO;                         "T>loop index
"
"  initialize parameters
"  =====================
"
ICM_AIRSLAB = ICM;                   "CM index for this component module
                                    "Note ICM_AIRSLAB not needed here since
                                    "ICM is set, but it is not set when
                                    "other routines called.
IRSTART_AIRSLAB = IR_start_CM(ICM_AIRSLAB); "Index of first region in this CM,
                                    "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_AIRSLAB) = 0;          "Geometry-checking flag, 0 if no errors
"
"establish CM boundary as a square (was cylinder prior to April 13,1994)
RMAX_CM_FLAG(ICM_AIRSLAB) = 2;       "put a square boundary about CM
"
OUTPUT;(/' AIRSLAB (SLABS)');
OUTPUT RMAX_CM(ICM); (' This component is a set of planar slabs'/
  '      Outer boundary is a square with |x| & |y| <',F10.2,' cm');
IF(ICM_AIRSLAB = 1)[
   OUTPUT Z_min_CM(ICM_AIRSLAB);
   (' This is first component -- starts at ',F11.4,' cm from reference plane');]
ELSE
   [OUTPUT Z_min_CM(ICM_AIRSLAB);(' Previous CM ends at:',F12.5,' cm');]
OUTPUT;(' TITLE: ',$);
;MINPUT (AIRSLAB) TITLE_AIRSLAB;(60A1);
               "MINPUT is a replacement macro with EOF and
               "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_AIRSLAB;(' ',60A1);
"
"   get information for each slab
"   =============================
"
"
"Get maximum number of slabs (and regions) permitted
OUTPUT $MAX_N_AIRSLAB; (' NUMBER OF SLABS (MINIMUM 1, MAXIMUM',I3,'): ',$);
;MINPUT (AIRSLAB) N_AIRSLAB; (I5);
OUTPUT N_AIRSLAB; (I5);
IF(N_AIRSLAB < 1)[
         N_AIRSLAB=1;
         OUTPUT ICM_AIRSLAB;
          (//'***ERROR IN CM ',I4,' (SLABS):'/
             '# of slabs < 1'/
             '# of slabs set to 1 for now.'//);
         IERR_GEOM(ICM_AIRSLAB)=IERR_GEOM(ICM_AIRSLAB)+1;
]
ELSEIF (N_AIRSLAB > $MAX_N_AIRSLAB)[
               N_AIRSLAB=$MAX_N_AIRSLAB;
               OUTPUT ICM_AIRSLAB, N_AIRSLAB;
               (//'***ERROR IN CM ',I4,' (SLABS):'/
                  '# of slabs > max. allowed'/
                  '# of slabs reduced to ',I4,' for now'//);
               IERR_GEOM(ICM_AIRSLAB)=IERR_GEOM(ICM_AIRSLAB)+1;
]

" get distance from reference plane, z=0"
"
OUTPUT;
 (' DISTANCE FROM FRONT OF SLABS (excluding air gap) TO REF PLANE (z=0): ',$);
;MINPUT (AIRSLAB) ZMIN_AIRSLAB;(F15.0);
OUTPUT ZMIN_AIRSLAB;(F10.5);
IF(ZMIN_AIRSLAB < Z_min_CM(ICM_AIRSLAB))["have overlapped two CMs"
   IF(ICM_AIRSLAB = 1)["first CM is special case"
     "Z_min_CM(1) is very front of accelerator, including air, input in main"
     OUTPUT ICM_AIRSLAB, ZMIN_AIRSLAB,Z_min_CM(ICM_AIRSLAB);
      (//' ***WARNING IN CM ',I4,' (AIRSLAB):'/
       ' Z_min_CM(1) (=front of the accelerator) is past front of first slab'/
       ' Z_min_CM(1) reset to value just input =',F8.5,' cm'/
       ' from ',F8.5,' cm'//);
     WRITE(IOUTLIST,:label1:) ICM_AIRSLAB, ZMIN_AIRSLAB,
                              Z_min_CM(ICM_AIRSLAB);
          :label1: FORMAT(//' ***WARNING IN CM ',I4,' (AIRSLAB):'/
  ' Z_min_CM(1) (=front of the accelerator) is past front of first slab'/
  ' Z_min_CM(1) reset to value just input =',F8.5,' cm'/
  ' from ',F8.5,' cm'//);
     Z_min_CM(ICM_AIRSLAB) = ZMIN_AIRSLAB;
   ]
   ELSE[
     OUTPUT ICM_AIRSLAB;
       (//'***ERROR IN CM ',I4,' (AIRSLAB):'/
          'Overlaps with previous CM.'//);
     IERR_GEOM(ICM_AIRSLAB)=IERR_GEOM(ICM_AIRSLAB)+1;
   ]
]

"loop over slabs
"
IRA = IRSTART_AIRSLAB-1; "absolute region number
DO IR_AIRSLAB=1,N_AIRSLAB [
   "loop through local region number to get slab information"
   IRA = IRA+1;
   "get thickness, cutoff energies, and dose scoring zone"
   "
   OUTPUT IR_AIRSLAB;(//' Inputs for slab # ',I5);
   OUTPUT; (' SLAB THICKNESS(cm), ECUT, PCUT,',
         ' DOSE ZONE(0=>DONT SCORE), IREGION_TO_BIT,ESAVE'/' :',$);
   ;MINPUT (AIRSLAB)
      ZTHICK_AIRSLAB(IR_AIRSLAB),ECUT(IRA),PCUT(IRA),
      DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),ESAVEIN;
      (3F15.0,2I5,F15.0);
   IF (ECUT(IRA) < ECUTIN) ECUT(IRA)=ECUTIN;
   IF (PCUT(IRA) < PCUTIN) PCUT(IRA)=PCUTIN;
   IF (ESAVEIN > 0.511) [ESAVE(IRA) = ESAVEIN;]
   ELSE [ESAVE(IRA)=ESAVE_GLOBAL;]
   "Particles with total energies < ESAVE are considered for range rejection"
   "if range rejection is on.  Default is ESAVE_GLOBAL but values are set"
   "back to zero in main if range rejection is off"
   ;OUTPUT
      ZTHICK_AIRSLAB(IR_AIRSLAB),ECUT(IRA),PCUT(IRA),
      DOSE_ZONE(IRA),IREGION_TO_BIT(IRA), ESAVE(IRA);
      (3F11.5,I9,I20,F11.5);
   IF(ZTHICK_AIRSLAB(IR_AIRSLAB)<0.0)[
      OUTPUT ICM_AIRSLAB, IR_AIRSLAB;
       (//'***ERROR IN CM ',I4,' (SLABS):'/
          'ZTHICK(',I4,') < 0.0'//);
      IERR_GEOM(ICM_AIRSLAB)=IERR_GEOM(ICM_AIRSLAB)+1;
   ]
   "get material for this slab and determine material number for this region"

   OUTPUT;(' SLAB ',$);
   ;$MED_INPUT(AIRSLAB); " inputs character array MED_IN from unit 5, loops
      "through array MEDIA(24,I) to check if medium was previously input.
      "If so, sets MED_INDEX to index of previous medium.  If not,
      "increments NMED and sets MED_INDEX to NMED.
   MED(IRA) = MED_INDEX; " medium of the planar slab
] "end of loop over IR_AIRSLAB"
"
"  parameter definition
"  ====================
"
"fill arrays of distance from reference plane (z=0) to front and back of slabs
ZFRONT_AIRSLAB(1) = ZMIN_AIRSLAB;
IF (N_AIRSLAB > 1) [
   DO IR_AIRSLAB=1,N_AIRSLAB-1 ["loop through local region number"
      ZBACK_AIRSLAB(IR_AIRSLAB) = ZFRONT_AIRSLAB(IR_AIRSLAB) +
                            ZTHICK_AIRSLAB(IR_AIRSLAB);
      ZFRONT_AIRSLAB(IR_AIRSLAB+1) = ZBACK_AIRSLAB(IR_AIRSLAB);
   ] "end of loop over IR_AIRSLAB"
]
ZBACK_AIRSLAB(N_AIRSLAB) = ZFRONT_AIRSLAB(N_AIRSLAB) +
                             ZTHICK_AIRSLAB(N_AIRSLAB);
"
"establish start of next CM
Z_min_CM(ICM_AIRSLAB+1) = ZBACK_AIRSLAB(N_AIRSLAB);
"
"  set up air gap to previous CM, if present
"  =========================================
"
"  The air gap has the highest region number in the CM, even though it is at
"  the top of the component module.  This is to allow the assignment of region
"  numbers on input of the parameters of each local region (mainly to assign the
"  medium number of the region).  The air gap is then assigned after all of the
"  CM parameters have been input.
"
Z_gap_THICK(ICM_AIRSLAB) = ZMIN_AIRSLAB-Z_min_CM(ICM_AIRSLAB);

IF (Z_gap_THICK(ICM_AIRSLAB) < $MIN_GAP) ["$MIN_GAP is defined in  main"
   Z_gap_THICK(ICM_AIRSLAB) = 0.;
   ZFRONT_AIRSLAB(1)=Z_min_CM(ICM_AIRSLAB);
   N_GAP_AIRSLAB = 0; "no air gap for this CM
]
ELSE [
   N_GAP_AIRSLAB = 1; "this CM has an air gap
   IRA = IRSTART_AIRSLAB+N_AIRSLAB; "absolute region number of air gap
   MED(IRA) = AIR_INDEX; "medium is air, vacuum or whatever assigned
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
   ECUT(IRA) = ECUTIN;
   PCUT(IRA) = PCUTIN;
   ZFRONT_AIRSLAB(N_AIRSLAB+1) = Z_min_CM(ICM_AIRSLAB);
   "only for output listing
]
"  set up region numbers
"  =====================
"
"  This CM has N_AIRSLAB+N_GAP_AIRSLAB regions, plates infinite in x & y, with
"  an air gap at the front, if present. Slabs are numbered in sequence starting
"  from the furthest upstream slab to the last downstream slab, followed by the
"  air gap, if present.
"
IREND_AIRSLAB = IRSTART_AIRSLAB+N_AIRSLAB+N_GAP_AIRSLAB-1;
               "Index of last region
NREG = NREG+N_AIRSLAB+N_GAP_AIRSLAB;  "Total of regions in full geometry up
                                    "to and including this CM
                                    "NREG is in comin GEOM
IF (NREG <= $MXREG) ["have not exceeded maximum region number
      "Index of first region in next CM:"
      IR_start_CM(ICM_AIRSLAB+1) = IREND_AIRSLAB+1;
]
ELSE [
      OUTPUT ICM_AIRSLAB,NREG,$MXREG;
      (//'***ERROR IN CM ',I4,' (SLABS):'/
         I4,' regions requested, only', I4,' available'/
         '    Change $MXREG in beam_user_macros.mortran'//);
      IERR_GEOM(ICM_AIRSLAB)=IERR_GEOM(ICM_AIRSLAB)+1;
]
"
"  establish dose-scoring zones and range rejection parameters for each region
"  ===========================================================================
"
"Note air gap cannot be a dose scoring region as presently set up.
IRA = IRSTART_AIRSLAB-1; "absolute region number
DO IR_AIRSLAB=1,N_AIRSLAB ["loop over local region number
   IRA = IRA+1;

   "dose-scoring zones
   "
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT); " current maxmum number
] "end of loop over IR_AIRSLAB

"set up minimum thicknesses which in this case are just the last 5"
"slabs"
"If we ever need more than 5 slabs, we should extend this or do
"something fancy like group similar materials"

NDO = MIN(5,N_AIRSLAB); "consider at most 5 slabs of material"
                       "air gap handled below"
                       "limit of 5 not essential here, but needed in helpful"
                       "in other cases"
"OUTPUT NDO;(' For automated range rejection consider',I3,' slabs of material');
DO IR_AIRSLAB = N_AIRSLAB, N_AIRSLAB-NDO+1, -1 [
   IRA = IR_AIRSLAB + IRSTART_AIRSLAB-1;   "absolute region"
   Z_min_thick(ICM,N_AIRSLAB+1 - IR_AIRSLAB) = ZTHICK_AIRSLAB(IR_AIRSLAB);
   "MED_min_thick is in COMIN CMs"
   MED_min_thick(ICM,N_AIRSLAB+1 - IR_AIRSLAB) = MED(IRA);
   "OUTPUT IR_AIRSLAB,IRA,ICM, N_AIRSLAB+1-IR_AIRSLAB,
      "Z_min_thick(ICM,N_AIRSLAB+1-IR_AIRSLAB),
      "ICM,N_AIRSLAB+1 - IR_AIRSLAB,
      "MED_min_thick(ICM,N_AIRSLAB+1 - IR_AIRSLAB);
      "(' IR_AIRSLAB,IRA=',I2,',',I3,' Z_min_thick(',2I2,')=',F10.3,
      "'  MED_min_thick(',2I3,')=',I2   );
]
IF(NDO < 5)[  "some not used - include air gap if there is one"
    IF(N_GAP_AIRSLAB = 1)["There is an air gap"
       Z_min_thick(ICM,NDO+1) = Z_gap_thick(ICM_AIRSLAB);
       MED_min_thick(ICM,NDO+1) = 1; "AIR is 1"
       OUTPUT ICM,NDO+1,Z_min_thick(ICM,NDO+1),ICM,NDO+1,
                 MED_min_thick(ICM,NDO+1);
       (' Front air gap',T20,' Z_min_thick(',I2,',',I2,')=',F10.3,
                 '  MED_min_thick(',I2,',',I2,')=',I5   );
       NDO = NDO +1;
    ]"end of loop if there is an air gap"
    IF(NDO < 5 )["check in case incremented by air gap"
       DO I = NDO+1,5["zero remaining, unused values"
         Z_min_thick(ICM,I) = 0.0;
         MED_min_thick(ICM,I) = 0;
       ]"end of do loop on I"
    ]"end second NDO < 5 case"
]"end NDO < 5 case"
"
"   return from INPUT_SLABS
"   =======================
RETURN;

"   error messages
"   ==============
"
:EOF_AIRSLAB:
;OUTPUT ICM;
(//' *** ERROR in AIRSLAB *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_AIRSLAB:
;OUTPUT ICM;(//' *** ERROR  in AIRSLAB *** format error on input for CM',I3);
STOP; END;
"End of INPUT_AIRSLAB"

%E   "start of subroutine ISUMRY_AIRSLAB"
"*******************************************************************************
"
"                          Subroutine ISUMRY_SLABS
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_AIRSLAB;


;IMPLICIT NONE;
;COMIN/BOUNDS,CMs,CM_AIRSLAB,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_SLABS
"T>**********************************
"T>
INTEGER
   ICOLOUR,   "T>colour of CM for EGS_Windows
   IDD,       "T>index of dose scoring zone
   IRA,       "T>absolute region number
   J;         "T>DO loop index
"
"   Mass of dose zone
"   =================
"Need to calculate mass of dose zone here,after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_AIRSLAB.
"
IRA = IRSTART_AIRSLAB-1; "absolute region number
DO IR_AIRSLAB=1,N_AIRSLAB+N_GAP_AIRSLAB ["loop over local region number
   IRA = IRA+1;
   IF(DOSE_ZONE(IRA).NE.0) ["this is a dose zone"
      IDD=DOSE_ZONE(IRA);
      "add mass of square region to any previous mass in dose region"
      AMASS(IDD)=AMASS(IDD) + RHOR(IRA)* (ZBACK_AIRSLAB(IR_AIRSLAB)
                 - ZFRONT_AIRSLAB(IR_AIRSLAB))*4*(RMAX_CM2(ICM_AIRSLAB));
      "note RHOR is the density which defaults to that from PEGS4 in HATCH
      "but could be set to any value prior to call to hatch
   ]
] "end of loop over IR_AIRSLAB"

"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"
"Output to list file changed to make it more clear--B Walters 18/08/94"

WRITE(IOUTLIST,110) ICM_AIRSLAB,TITLE_AIRSLAB;
WRITE(IOUTLIST,120) Z_min_CM(ICM_AIRSLAB),RMAX_CM(ICM_AIRSLAB);
WRITE(IOUTLIST,122);
IF(N_GAP_AIRSLAB~=0)[
   WRITE(IOUTLIST,124) 'airgap',Z_min_CM(ICM_AIRSLAB),
                       ZFRONT_AIRSLAB(1)-Z_min_CM(ICM_AIRSLAB);
]
DO IR_AIRSLAB=1,N_AIRSLAB[
   WRITE(IOUTLIST,123) IR_AIRSLAB,ZFRONT_AIRSLAB(IR_AIRSLAB),
                       ZTHICK_AIRSLAB(IR_AIRSLAB);
]
WRITE(IOUTLIST,130);
IRA = IRSTART_AIRSLAB-1;

DO IR_AIRSLAB=1,N_AIRSLAB + N_GAP_AIRSLAB [
   IRA = IRA+1;
   IF(IR_AIRSLAB<=N_AIRSLAB)[
      IF (MED(IRA)=0) ["Medium is vacuum"
         WRITE(IOUTLIST,140)
         IR_AIRSLAB,IR_AIRSLAB,'slab',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,140)
         IR_AIRSLAB,IR_AIRSLAB,'slab',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]
   ELSE[
      IF (MED(IRA)=0) ["Medium is vacuum"
         WRITE(IOUTLIST,142)
         IR_AIRSLAB,'NA','airgap',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,142)
         IR_AIRSLAB,'NA','airgap',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
    WRITE(IOUTLIST,141)'at top';
    ]
]"end loop on IR_AIRSLAB"


110 FORMAT(///1x,79('-')/
 '  Component module',I3,' is one or more planar slabs  ',
 '(SLABS)'
           /1x,79('-')
           //T5,'Title: ',68A1);
120 FORMAT(/T2,'AIRSLAB geometry parameters:',
           /T2,'-----------------------------',
           /T2,'Distance of front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Half-width of outer boundary of CM = ',F15.5,' cm');
122 FORMAT(/T2,
'slab #    Z front    thickness',
/T2,
'           face               ',
/T2,
'           (cm)        (cm)   ');
123 FORMAT(T2,I4,F12.3,F11.3);
124 FORMAT(T2,A6,F10.3,F11.3);
130 FORMAT(/T2,'AIRSLAB region parameters:',
           /T2,'---------------------------',
           /T2,'local  slab #  location  electron  photon',
           '  range-rejection  dose  bit  medium'
           /T2,'region                    cutoff   cutoff',
           '   level     max   zone  set'
           /T2,'                           (MeV)    (MeV)',
           '   (MeV)    (MeV)');

140 FORMAT(T2,I3,I7,5X,A7,F10.3,F9.3,F8.3,F9.3,I5,I5,2X,9A1);
141 FORMAT(T17,A7);
142 FORMAT(T2,I3,5X,A2,5X,A7,F10.3,F9.3,F8.3,F9.3,I5,I5,2X,9A1);



"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"
IF (IWATCH = 4 | IZLAST = 2) ["Graphics file requested"
   ICOLOUR = MOD(ICM_AIRSLAB,4)+1; "select ICOLOUR = 1, 2, or 3, colour of CM"
   DO IR_AIRSLAB=1,N_AIRSLAB ["Loop over local region number"
      WRITE(IOUTGEOM,200) ICOLOUR,'DISK',0.,0.,
                       ZFRONT_AIRSLAB(IR_AIRSLAB),RMAX_CM(ICM_AIRSLAB);
      "NOTE *** it was a disk but it is a square now!"
   ]
   WRITE(IOUTGEOM,200) ICOLOUR,'DISK',0.,0.,
                       ZBACK_AIRSLAB(N_AIRSLAB),RMAX_CM(ICM_AIRSLAB);
   200 FORMAT(' ',I1,A4,10(F7.2,','));
] "End of graphics output"
"
;RETURN;END;
"SLABS_cm.mortran end of ISUMRY_AIRSLAB"

%E   "start of subroutine HOWFAR_AIRSLAB"
"*******************************************************************************
"************************** Component Module SLABS *****************************
"*******************************************************************************
"
"                          Subroutine HOWFAR_SLABS
"                          ***********************
"
" HOWFAR routine for stacked planar media.
"
" Determine if current region number is within component module SLABS, and if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are N_SLABS local regions + an air gap (if present):
"
"     local               absolute                  description
"   ---------  ----------------------------------  -------------
"   IR_SLABS   IR_start_CM(ICM_SLABS)+IR_SLABS-1   slab IR_SLABS
"   N_SLABS+1  IR_start_CM(ICM_SLABS)+N_SLABS      air gap
"
"       Geometrical co-ordinates, as set in INPUT_SLABS are:
"       ZFRONT_SLABS(IR_SLABS)     front of slab IR_SLABS (upstream surface)
"       ZBACK_SLABS(IR_SLABS)      back of slab IR_SLABS (downstream surface)
"
"*******************************************************************************

;SUBROUTINE HOWFAR_AIRSLAB;


;IMPLICIT NONE;
;COMIN/ CMs,CM_AIRSLAB,EPCONT,STACK,EGS-IO/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_SLABS
"T>**********************************
"T>
INTEGER
   IRL;         "T>local region number (absolute), required by HOWNEAR macro
$REAL
   DIST,        "T>distance to region boundary along current particle trajectory
   DMIN_AIRSLAB, "T>minimum distance to boundaries checked thus far
   ZNEAR;       "T>distance to nearest boundary

IRL = IR(NP);   "local region number (absolute)

" Set DNEAR
" *********
" This replacement macros sets DMIN_AIRSLAB as well as defining IR_AIRSLAB
;
AIRSLAB_CM_HOWNEAR(DMIN_AIRSLAB);
DNEAR(NP) = DMIN_AIRSLAB;
;
" Boundary-crossing check
" ***********************
" Determine if current region number is within component module SLABS,
"  and if so evaluate DIST, distance to region boundary along current
" trajectory.  USTEP must not exceed DIST.
"
IF (IR_AIRSLAB>0 & IR_AIRSLAB<N_AIRSLAB+1) [
   "particle in this CM (not in air gap)"
   IF (W(NP)>0.0) ["particle going forward"
      "calculate distance to back boundary"
      ZNEAR = ZBACK_AIRSLAB(IR_AIRSLAB)-Z(NP);
      DIST = ZNEAR/W(NP);
      IF (DIST < 0.) [DIST=0.;]
      "Above check was put in to handle the case where the distance"
      "to interaction is ~ the distance to the"
      "back of the SLABS CM.  In this case, particles initiated"
      "by the interaction may actually have Z values that put them"
      "in the next CM, but because the WHERE_AM_I for the next"
      "CM has not been called yet, HOWFAR for SLABS is used, and a"
      "negative USTEP results.  Note that this unusual case has"
      "only been observed to occur between SLABS and CONS3R CMs"
      "when incident particles are photons, SLABS is the target, and"
      "CONS3R is the primary collimator immediately below the target"
      "18/12/95"
      IF(DIST=0. & IR_AIRSLAB=N_AIRSLAB)[DIST=1.E-16;]
      "Above gives DIST a very small positive value in case of leaving CM"
      "When collecting phase space immediately below a thin (0.01 cm) layer of"
      "Mylar in a beam, there was a high probability of the calculated"
      "value of USTEP (ie unmodified by HOWFAR) actually putting the particle"
      "right on the back of the mylar layer.  When it came to the next step,"
      "the calculated value of DIST was 0, which meant USTEP was set to 0,"
      "and, as a result, AUSGAB was not called on leaving the CM."
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         IF (IR_AIRSLAB<N_AIRSLAB) ["particle will remain in CM"
            IRNEW = IR(NP)+1; "new region number"
         ]
         ELSE ["particle will enter downstream CM"
            CALL WHERE_AM_I(ICM_AIRSLAB,1); "get IRNEW, ICMNEW"
         ]
      ]
   ]" end of forward going block"
   ELSEIF (W(NP)<0.0) ["particle going backwards"
      "calculate distance to front boundary"
      ZNEAR = Z(NP)-ZFRONT_AIRSLAB(IR_AIRSLAB);
      DIST = -ZNEAR/W(NP); "Direction cosine is negative"
      IF (DIST < 0.) [DIST=0.;] "see reason above"
      IF (DIST=0. & N_GAP_AIRSLAB=0 & IR_AIRSLAB=1)[ DIST=1.E-16;]
      IF(DIST <= USTEP) [
         USTEP = DIST;
         IF (IR_AIRSLAB>1) ["particle will remain in CM"
            IRNEW = IR(NP)-1; "new region number"
         ]
         ELSEIF (IR_AIRSLAB=1 & N_GAP_AIRSLAB=1) ["particle entering air gap"
            IRNEW = IREND_AIRSLAB; "new region number"
         ]
         ELSE ["particle will enter upstream CM"
            CALL WHERE_AM_I(ICM_AIRSLAB,-1); "get IRNEW, ICMNEW"
         ]
      ]
   ]" end of backward going block"
   "if W(NP)=0.0, never hit boundary, need not reset USTEP"
]"end of CM regions"

"   in air gap at top of CM
"   =======================
"
ELSEIF (IR_AIRSLAB=N_AIRSLAB+1 & N_GAP_AIRSLAB=1) ["particle in air gap"
   IF (W(NP)>0.0) ["particle going forward"
      "calculate distance to back boundary"
      ZNEAR = ZFRONT_AIRSLAB(1)-Z(NP);
      DIST = ZNEAR/W(NP);
      IF (DIST < 0.) [DIST=0.;] "See reason above"
      IF(DIST <= USTEP ) ["particle will enter first slab, this CM
         USTEP = DIST;
         IRNEW = IRSTART_AIRSLAB; "new region number"
      ]
   ]" end of forward going block"
   ELSEIF (W(NP)<0.0 ) ["particle going backwards"
      "calculate distance to front boundary"
      ZNEAR = Z(NP)-Z_min_CM(ICM_AIRSLAB);
      DIST = -ZNEAR/W(NP); "Direction cosine is negative"
      IF (DIST <= 0.) [DIST=1.E-16;] "See reason above"
                                     "Always set to small +ve value since"
                                     "we are definitely leaving through top"
      IF(DIST <= USTEP) ["particle will enter upstream CM"
         USTEP = DIST;
         CALL WHERE_AM_I(ICM_AIRSLAB,-1); "get IRNEW, ICMNEW"
      ]
   ]" end of backward going block"
   "if W(NP)=0.0, never hit boundary, need not reset USTEP"
]"end of air-gap region"

"   outside of CM, something is wrong
"   =================================
"
ELSE ["something is wrong"
   OUTPUT IR(NP)-IRSTART_AIRSLAB+1, IR(NP), ICM_AIRSLAB,
      IR_start_CM(ICM_AIRSLAB); (//' ************'//' HOWFAR_AIRSLAB error'/
      '    Region, local, absolute =',2I5/
      '    CM number=',I5,' start region =',I5/' *********'//);
   STOP;
] "end of IF statement"
RETURN; END; "End of subroutine HOWFAR_SLABS"

%E   "start of subroutine WHERE_AM_I_AIRSLAB"
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_SLABS
"                          ***************************
"
" WHERE_AM_I routine for stacked planar slabs.
"
" WHERE_AM_I_AIRSLAB determines the new region number when a particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_AIRSLAB subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_AIRSLAB from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************

;SUBROUTINE WHERE_AM_I_AIRSLAB(IDIR);


;IMPLICIT NONE;
;COMIN/CM_AIRSLAB,EPCONT,STACK/; "/STACK/would be needed for more complicated
                       "geometries.
"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_SLABS
"T>**************************************
"T>
INTEGER IDIR,I;  "T>direction of particle, +1=forward, -1=backward

IF (IDIR=1) ["particle entering this CM through front face (upstream)
   IF (N_GAP_AIRSLAB=0) ["no air gap this CM"
      IRNEW = IRSTART_AIRSLAB;
   ]
   ELSE ["this CM has an air gap at the front
      IRNEW = IREND_AIRSLAB;
   ]
]
ELSEIF(IDIR=2) ["particle starting within CM"
   IF(N_GAP_AIRSLAB=1 & Z(NP)< ZFRONT_AIRSLAB(1))[
      IRNEW = IREND_AIRSLAB;
   ]
   ELSE[
     IRNEW=IRSTART_AIRSLAB+N_AIRSLAB-1;
     DO I=1,N_AIRSLAB[
      IF(Z(NP)<ZFRONT_AIRSLAB(I)+ZTHICK_AIRSLAB(I))[
          IRNEW=IRSTART_AIRSLAB+I-1;
          EXIT;
      ]
     ]
   ]
]
ELSE ["particle entering this CM through back face (downstream)
   IRNEW = IRSTART_AIRSLAB+N_AIRSLAB-1;
]
RETURN;
END; "End of subroutine WHERE_AM_I_SLABS"

%E  "start of subroutine HOWNEAR_AIRSLAB"
"*****************************************************************************
"
"                        Subroutine HOWNEAR_AIRSLAB
"                        *************************
"
" Returns min. distance to nearest region boundary.  Used to be a macro, but
" now the the macro calls this subroutine.
"
"*****************************************************************************

;SUBROUTINE HOWNEAR_AIRSLAB(DIST);

$IMPLICIT-NONE;

COMIN/CM_AIRSLAB,STACK,CMs/;

$REAL DIST; "T> min. distance to nearest region boundary

IR_AIRSLAB = IR(NP)-IRSTART_AIRSLAB+1;
IF(IR_AIRSLAB=N_AIRSLAB+1 & N_GAP_AIRSLAB=1)["particle is in air gap"
   DIST=MIN(Z(NP)-Z_min_CM(ICM_AIRSLAB),ZFRONT_AIRSLAB(1)-Z(NP));
]
ELSE["particle is in one of the layers"
   DIST=MIN(Z(NP)-ZFRONT_AIRSLAB(IR_AIRSLAB),
       ZBACK_AIRSLAB(IR_AIRSLAB)-Z(NP));
]
RETURN;
END; "End of subroutine HOWNEAR_AIRSLAB"
"******************************************************************************
"End of SLABS_cm.mortran"
%N "Turn off MORTRAN listing
