%L
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc macros                                                              "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2000                                       "
"                   Dave Rogers, 2000                                         "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                   Ernesto Mainegra-Hing                                     "
"                   Frederic Tessier                                          "
"                   Reid Townson                                              "
"                   Victor Malkov                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"


"Compiler directives"
"==================="
%Q1         "Automatically close comments at end of line
            "but this DOES NOT apply withing macro definitions!!
%C80        "Allow 80 columns of source/line (default is 72)
%L          "Turn on listing


"=================================================================="
" Macros to implement implicit data types                          "
"=================================================================="

REPLACE {$LOGICAL} WITH {;logical}
REPLACE {$REAL}    WITH {;real*8}
REPLACE {$INTEGER} WITH {;integer*4}
REPLACE {$LONG_INT} WITH {;integer*8} "change this to integer*4 for compilers"
                                      "that do not support integer*8"
REPLACE {$SHORT_INT} WITH {;integer*2} "change this to integer*4 for compilers"
                                      "that do not support integer*2"
"the above is not used in EGSnrc but is used in the NRC user codes,
"especially related to number of histories"
"Note that the HP compiler does not support *8 integers so the above"
" should be changed for HP"

REPLACE {$IMPLICIT-NONE;} WITH {;}
REPLACE {$IMPLICIT-NONE;} WITH {implicit none;}

"=================================================================="
"SELECT THE FORTRAN STANDARD TO BE USED (1966 OR 1977)             "
REPLACE {$FORTVER} WITH {1977}
"=================================================================="

"******************************************************************"
REPLACE {$TYPE} WITH {
  {SETR F=$FORTVER}
   [IF] {COPY F}=1977 [CHARACTER*4] [ELSE] [INTEGER*4]
  }
"******************************************************************"

"******************************************************************"
SPECIFY ALPHA    AS (0...$);
SPECIFY SYMBOL   AS (0...?);
SPECIFY NAME     AS LETTER(0,5)[ALPHA];
SPECIFY <COMMA>  AS [','|''];
SPECIFY <NAME>   AS [NAME|''];
SPECIFY LABEL    AS ':'NAME':';
SPECIFY <LABEL>  AS [LABEL|''];
SPECIFY <*>      AS ['*'|''];
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {NEWLABEL} WITH {@LG}
REPLACE {%'{ARB}'={<*>}'{ARB}'}
   WITH {[IF] '{P2}'='*' [APPEND'{P3}'TO'{P1}']
            [ELSE] [ REPLACE {{P1}}WITH{{P3}}]}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

    "RULES TO GENERALIZE MORTRAN'S INPUT AND OUTPUT"
REPLACE {;$UINPUT(#)#;}
   WITH {;{SETR A=NEWLABEL}
            READ({P1},{COPY A}){P2};{COPY A}FORMAT}

REPLACE {;$UOUTPUT(#)#;}
   WITH {;{SETR A=NEWLABEL}
            WRITE({P1},{COPY A}){P2};{COPY A}FORMAT}

REPLACE {;$ECHO#({NAME}{<COMMA>}#)#;}
 WITH {;{SETR X=NEWLABEL}
 WRITE(IUECHO,{COPY X});{COPY X}FORMAT(' ECHO {P1}:{P5}');
 [IF] {EXIST 3} [{P1}({P2},{P4}){P5};
 WRITE(IUECHO,{P4}){P5};]
 [ELSE] [{SETR Y=NEWLABEL}{P1}({P2},{COPY Y}){P4};
 WRITE(IUECHO,{COPY Y}){P5};{COPY Y}FORMAT]
 }
;  "---------- BUFFER FLUSH SEMICOLON ----------"
REPLACE {;IUECHO=#;} WITH { REPLACE {IUECHO} WITH {{P1}};}
"INITALIZE" ;IUECHO=6;

"MACRO TO SPLIT STRING INTO A LIST SEPARATED BY COMMAS"
REPLACE {$S'{SYMBOL}#'}
  WITH {'{P1}'[IF]{EXIST 2}[,$S'{P2}']}

"SOME DEBUGGING MACROS"
REPLACE {$LIST#/#/#;} WITH
   {;OUTPUT {P3};('LIST/{P2}/{P3}:'/(1X,{P1}));}
APPEND{;COMMON/QDEBUG/QDEBUG;LOGICAL QDEBUG;} TO {;COMIN/DEBUG/;}

REPLACE {$TRACE#;} WITH
  {REPLACE {;{P1}={WAIT {ARB}};}  WITH
  {{EMIT;{P1}}={WAIT {P1}};
  IF QDEBUG [OUTPUT{P1};
  (' {P1} ASSIGNED {WAIT {P1}} ',G25.18);] }; }
REPLACE {$S1TRACE#;} WITH
  {{SETR A=NEWLABEL}
    REPLACE {;{P1}({WAIT {ARB}})={WAIT {ARB}};}
       WITH {{EMIT ;{P1}({WAIT {P1}})}={WAIT {P2}};
           IF QDEBUG [I{COPY A}={WAIT {P1}};
                OUTPUT I{COPY A},{P1}(I{COPY A});
                    (' {P1}(',I6,') ASSIGNED {WAIT {P2}} ' ,
                       G25.18);] } ;}

REPLACE {$TRACE#,#;} WITH {$TRACE{P1};$TRACE{P2};}
REPLACE {$S1TRACE#,#;} WITH {$S1TRACE{P1};$S1TRACE{P2};}

SPECIFY DELIM AS ['('|';'];
REPLACE {$CALLTRACE;} WITH
  {REPLACE {;CALL{NAME}{DELIM}} WITH
  {;IF (QDEBUG)[OUTPUT;
    (' SUBROUTINE {WAIT {P1}} CALLED.');]
         {WAIT {EMIT CALL} {P1}{P2}} };}

REPLACE {$DUMP#,#;} WITH
    {;{SETR A=NEWLABEL}
         V{COPY A}={P1};OUTPUT V{COPY A};(' {P1}=',1PG15.7);
         [IF] {EXIST 2} [$DUMP{P2};] ;}
   "NOTICE: THE LIST OF VARIABLES MUST BE FOLLOWED BY A COMMA"
   "FOR EXAMPLE $DUMP S,T(U,V),W,; OR $DUMP A,;"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MORTRAN MACRO DEFINITIONS FOR EGS."

"FIRST SOME PARAMETERS"
REPLACE {PARAMETER #=#;} WITH
   { REPLACE {{P1}} WITH {{P2}}}

PARAMETER $MXMED=10;      "MAX. NO. OF DIFFERENT MEDIA (EXCL. VAC.)"
PARAMETER $MXREG=2000;    "MAXIMUM NO. OF REGIONS ALLOCATED"
PARAMETER $MXSTACK=40;    "STACK SIZE"
PARAMETER $MXVRT1=1000;   "NO. OF REPRESENTATIVE ANGLES IN VERT1"
PARAMETER $FMXVRT1=1000.; "FLOATING $MXVRT1"
PARAMETER $MXPWR2I=50;    "SIZE OF TABLE OF INVERSE POWERS OF TWO"
PARAMETER $MXJREFF=200;   "SIZE OF MULTIPLE SCATTERING JREFF MAP"
PARAMETER $MSSTEPS=16;    "NO. OF MULTIPLE SCATTERING STEP SIZES"
PARAMETER $MXVRT2=100;    "DISTRBTN OF NONOVERLAPPING PARTS OF VERT"

;
"FOLLOWING DEFINE MAX. NO. OF INTERVALS FOR FIT TO FUNCTIONS"
PARAMETER $MXSGE=400;     "GAMMA SMALL ENERGY INTERVALS"
PARAMETER $MXGE=2000;     "GAMMA MAPPED ENERGY INTERVALS"
PARAMETER $MXSEKE=300;    "ELECTRON SMALL ENERGY INTERVALS"
PARAMETER $MXEKE=500;     "ELECTRON MAPPED ENERGY INTERVALS"
PARAMETER $MXEL=50;       "MAXIMUM # OF ELEMENTS IN A MEDIUM"
PARAMETER $MXLEKE=100;    "ELECTRON ENERGY INTERVALS BELOW EKELIM"
PARAMETER $MXCMFP=100;    "CUMULATIVE ELECTRON MEAN-FREE-PATH"
PARAMETER $MXRANGE=100;   "ELECTRON RANGE"
PARAMETER $MXBLC=20;      "MOLIERE'S LOWER CASE B"
PARAMETER $MXRNTH=20;     "RANDOM NUMBER FOR SUBMEDIAN ANGLES"
PARAMETER $MXRNTHI=20;    "RANDOM NUMBER FOR SUPERMEDIAN ANGLES"
PARAMETER $MXRAYFF=100;   "RAYLEIGH ATOMIC FORM FACTOR"
PARAMETER $RAYCDFSIZE=100;"CDF from RAYLEIGH FORM FACTOR SQUARED"
PARAMETER $MXSINC=1002;   "ANGLE INTERVALS IN (0,5*PI/2) FOR SINE"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"THE FOLLOWING ARE PARAMETERS FOR AUSGAB CALLS:"
PARAMETER $MXAUS=35;       "CHANGE IF MORE AUSGAB CALLS ARE ADDED"
PARAMETER $MXAUSM5=30;     "SET THIS TO $MXAUS VALUE LESS 5"

"FIRST FIVE AUSGAB CALLS BELOW TURNED ON IN BLOCK DATA (DEFAULT)"
PARAMETER $TRANAUSB=0;    "BEFORE TRANSPORT"
PARAMETER $EGSCUTAUS=1;   "ENERGY BELOW ECUT OR PCUT"
PARAMETER $PEGSCUTAUS=2;  "ENERGY BELOW AE OR AP"
PARAMETER $USERDAUS=3;    "USER REQUESTED DISCARD"
PARAMETER $PHOTXAUS=4;    "FLUORESCENT PHOTON DISCARD"

"THE REMAINING 23 ARE TURNED OFF IN BLOCK DATA (DEFAULT)"
PARAMETER $TRANAUSA=5;    "AFTER TRANSPORT"
PARAMETER $BREMAUSB=6;    "BEFORE BREMS CALL"
PARAMETER $BREMAUSA=7;    "AFTER BREMS CALL"
PARAMETER $MOLLAUSB=8;    "BEFORE MOLLER CALL"
PARAMETER $MOLLAUSA=9;    "AFTER MOLLER CALL"
PARAMETER $BHABAUSB=10;   "BEFORE BHABHA CALL"
PARAMETER $BHABAUSA=11;   "AFTER BHABHA CALL"
PARAMETER $ANNIHFAUSB=12; "BEFORE ANNIH CALL"
PARAMETER $ANNIHFAUSA=13; "AFTER ANNIH CALL"
PARAMETER $ANNIHRAUSB=28; "BEFORE POSITRON ANNIH AT REST"
PARAMETER $ANNIHRAUSA=14; "POSITRON ANNIHILATED AT REST"
PARAMETER $PAIRAUSB=15;   "BEFORE PAIR CALL"
PARAMETER $PAIRAUSA=16;   "AFTER PAIR CALL"
PARAMETER $COMPAUSB=17;   "BEFORE COMPT CALL"
PARAMETER $COMPAUSA=18;   "AFTER COMPT CALL"
PARAMETER $PHOTOAUSB=19;  "BEFORE PHOTO CALL"
PARAMETER $PHOTOAUSA=20;  "AFTER PHOTO CALL"
PARAMETER $UPHIAUSB=21;   "ENTERED UPHI"
PARAMETER $UPHIAUSA=22;   "LEFT UPHI"
PARAMETER $RAYLAUSB=23;   "BEFORE RAYLEIGH EVENT"
PARAMETER $RAYLAUSA=24;   "AFTER RAYLEIGH EVENT"
PARAMETER $FLUORTRA=25;   "A fluorescent transition just occurred"
PARAMETER $COSKROTRA=26;  "A Coster-Kronig transition just occurred"
PARAMETER $AUGERTRA=27;   "An Auger transition just occurred"
"Ali:photonuc, 2 lines"
" note that 28 is already used for positron annih at rest - see above"
PARAMETER $PHOTONUCAUSB=29; "BEFORE PHOTONUCLEAR EVENT"
PARAMETER $PHOTONUCAUSA=30; "AFTER PHOTONUCLEAR EVENT"
PARAMETER $EIIB=31;   "Before EII"
PARAMETER $EIIA=32;   "After EII"
PARAMETER $SPHOTONA=33;   "After sub-threshold photon energy deposition"
PARAMETER $SELECTRONA=34;   "After sub-threshold electron energy deposition"

;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {$AUSCALL(#);} WITH
   {IARG={P1} ;  IF (IAUSFL(IARG+1).NE.0) [CALL AUSGAB(IARG);]} ;
;  "---------- BUFFER FLUSH SEMICOLON ----------"
"TEMPORARY OVER-RIDES FOR SOME OF THE ABOVE"
PARAMETER $MXSGE=1;
PARAMETER $MXSEKE=1;
PARAMETER $MXLEKE=1;
PARAMETER $MXCMFP=1;
PARAMETER $MXRANGE=1;
PARAMETER $MXBLC=1;
PARAMETER $MXRNTH=1;
PARAMETER $MXRNTHI=1;
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"THE FOLLOWING DEFINE PRECISION USED IN ENERGY COMPUTATIONS"
"THE LATTER OF THE TWO WILL BE IN EFFECT"
REPLACE {$ENERGYPRECISION} WITH {;REAL }"SINGLE PRECISION"
REPLACE {$ENERGYPRECISION} WITH {;DOUBLE PRECISION }
REPLACE {$MAX_INT} WITH {2147483647} "2^31-1"
"^--- limits number of particles and hence phase space file size"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MACROS TO MAKE CHANGES IN THE DEGREE OF FIT EASIER"
"ALSO USEFUL FOR ABBREVIATING LISTS OF SUBSCRIPTED VARIABLES"
"$LGN STANDS FOR 'LIST GENERATOR'"
"$RSC MEANS THAT THE EXPANDED LIST SHOULD RESCANNED FOR FURTHER"
"OPERATIONS.  MACROS EXPECTING TO DO RESCANS SHOULD BE"
"DEFINED AFTER THE FOLLOWING MACRO"
REPLACE {$RSC(#)} WITH {{P1}}
"IF NOT MATCHED BY ANYTHING ELSE, REMOVE $RSC()"
REPLACE {$RSC(#),#$LSCALEBY#;} WITH
   {{P1}={P1}*{P3};{P2}$LSCALEBY{P3};}
REPLACE {$RSC(#)$LSCALEBY#;} WITH {{P1}={P1}*{P2};}
REPLACE {$LGN(#/#/)} WITH {$RSC({P1}{P2})}
REPLACE {$LGN(#(#)/#/)} WITH {$RSC({P1}{P3}({P2}))}
REPLACE {$LGN(#(#))} WITH {$RSC({P1}({P2}))}
REPLACE {$LGN(#/#,#/)} WITH
    {$LGN({P1}/{P2}/),$LGN({P1}/{P3}/)}
REPLACE {$LGN(#,#/#/)} WITH
    {$LGN({P1}/{P3}/),$LGN({P2}/{P3}/)}
REPLACE {$LGN(#(#)/#,#/)} WITH
    {$LGN({P1}({P2})/{P3}/),$LGN({P1}({P2})/{P4}/)}
REPLACE {$LGN(#,#(#)#)} WITH
    {$LGN({P1}({P3}){P4}),$LGN({P2}({P3}){P4})}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MACROS FOR SCALING REQUIRED BY CHANGE IN DISTANCE UNIT"
REPLACE {$SCALE# BY #;} WITH {{P1}={P1}*{P2};}
REPLACE {$SCALE#,# BY #;} WITH
    {{P1}={P1}*{P3};$SCALE{P2} BY {P3};}
REPLACE {$SCALE$LGN(#) BY #;} WITH
    {$LGN({P1})$LSCALE BY {P2};}
REPLACE {$SCALE$LGN(#),# BY #;} WITH
            {$LGN({P1})$LSCALE BY {P3};$SCALE{P2} BY {P3};}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"------------------------------------------------------------------
" Macros related to bit setting
"------------------------------------------------------------------
""
"Macro to set bit {P2} in {P1}  to 1
REPLACE {$IBSET(#,#);} WITH {ibset({P1},{P2});}

"Macro to set test bit {P2} in {P1}
"Note this may require a LOGICAL declaration wherever used
REPLACE {$BTEST(#,#)} WITH {btest({P1}, {P2})}

"Macro to set bit {P2} in {P1}  to 0
REPLACE {$IBCLR(#,#);} WITH {ibclr({P1},{P2});}
"Above used by RW_PH_SP routine - (read_write_phase_space for BEAM)


"COMMON BLOCK INSERTION MACROS"
REPLACE {;COMIN/#,#/;} WITH {;COMIN/{P1}/;COMIN/{P2}/;}

"NOW FOR SOME SPECIFIC COMMON BLOCKS"

"------------------------------------------------------------------"
"*** BOUNDS--CUTOFF ENERGIES & VACUUM TRANSPORT DISTANCE           "
"------------------------------------------------------------------"
REPLACE {;COMIN/BOUNDS/;} WITH
{
    ;COMMON/BOUNDS/ECUT($MXREG),PCUT($MXREG),VACDST;
     $REAL         ECUT,   "Minimum electron transport energy"
                   PCUT,   "Minimum photon transport energy"
                   VACDST; "Infinity (1E8)"
}

"------------------------------------------------------------------"
"*** BREMPR--BREMSSTRAHLUNG AND PAIR PRODUCTION DATA               "
"------------------------------------------------------------------"

;
REPLACE {$MXBREN} WITH {57}
REPLACE {$MXBRXX} WITH {54}
REPLACE {$MXBREL} WITH {100}
REPLACE {$MXGAUSS} WITH {64}
REPLACE {$MXBRES} WITH {100}
REPLACE {$MXBRXS} WITH {50}
REPLACE {$NIST-ENERGY-SCALE} WITH {1.0}

REPLACE {$NIST-DATA-UNIT} WITH {i_nist_data}
;

REPLACE {$COMIN-INIT-NIST-BREMS;} WITH {;
    ;COMIN/MEDIA,BREMPR,ELECIN,THRESH,USEFUL,NIST-BREMS,Spin-Data,EGS-IO/;
};

REPLACE {;COMIN/BREMPR/;} WITH
{
  ;COMMON/BREMPR/
             $LGN(DL(8,$MXMED)/1,2,3,4,5,6/),
             $LGN(ALPHI,BPAR,DELPOS(2,$MXMED)),
             $LGN(WA,PZ,ZELEM,RHOZ($MXMED,$MXEL)),
             PWR2I($MXPWR2I),
             $LGN(DELCM,ZBRANG,LZBRANG,NNE($MXMED)),
             IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet,
             ASYM($MXMED,$MXEL,2);
   $TYPE     ASYM;
   $REAL     $LGN(DL/1,2,3,4,5,6/), "Parameter for the fit of the screening"
                                    "rejection function, eq. (2.7.14 and 15)"
             ALPHI,  "Prob. for the (1-BR)/BR part in BREMS, eq. (2.7.64)"
             BPAR,   "Prob. for the 12*(BR-1/2)**2 part in PAIR, eq. (2.7.105)"
             DELPOS, "maximum delta, eq. (2.7.31)"
             WA,     "atomic weight"
             PZ,     "atomic fraction of an element in a compound"
             ZELEM,  "Z for a given component"
             RHOZ,   "density of an element in a compound"
             PWR2I,  "powers of 1/2 (used for sampling (1-BR)/BR"
             DELCM,  "136*m*exp(Zg), eq. (2.7.51)"
             ZBRANG, "composite factor for angular distributions"
             LZBRANG;"-Log(ZBRANG)"
   $INTEGER  NNE,    "number of elements/compound"
             IBRDST, "flag to switch on bremsstrahlung angular distributions"
             IPRDST, "flag to switch on pair angular distributions"
             ibr_nist,  "use the NIST bremsstrahlung cross sections"
             itriplet,  "if set to 1, explicitely simulate triplet events"
             pair_nrc;  "=0 => use Bethe-Heitler pair cross sections"
                        "=1 => use the NRC pair cross sections"
};

REPLACE {;COMIN/NIST-BREMS/;} WITH {;

  common/nist_brems/ nb_fdata(0:$MXBRXS,$MXBRES,$MXMED),
                     nb_xdata(0:$MXBRXS,$MXBRES,$MXMED),
                     nb_wdata($MXBRXS,$MXBRES,$MXMED),
                     nb_idata($MXBRXS,$MXBRES,$MXMED),
                     nb_emin($MXMED),nb_emax($MXMED),
                     nb_lemin($MXMED),nb_lemax($MXMED),
                     nb_dle($MXMED),nb_dlei($MXMED),
                     log_ap($MXMED);
  $REAL    nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lemax,
           nb_dle,nb_dlei,log_ap;
  $INTEGER nb_idata;
};

REPLACE {$NRC-PAIR-NXX} WITH {65};
REPLACE {$NRC-PAIR-NEE} WITH {84};
REPLACE {$NRC-PAIR-NX-1} WITH {64};
REPLACE {$NRC-PAIR-NE-1} WITH {83};

REPLACE {;COMIN/NRC-PAIR-DATA/;} WITH {;
    common/nrc_pair/ nrcp_fdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
                     nrcp_wdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
                     nrcp_idata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
                     nrcp_xdata($NRC-PAIR-NXX),
                     nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
    $REAL            nrcp_fdata,nrcp_wdata,nrcp_xdata,
                     nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
    $INTEGER         nrcp_idata;
};

"------------------------------------------------------------------------"
"*** TRIPLET DATA                                                        "
"------------------------------------------------------------------------"
REPLACE {$MAX_TRIPLET} WITH {250}
REPLACE {;COMIN/TRIPLET-DATA/;} WITH {;
        common/triplet_data/ a_triplet($MAX_TRIPLET,$MXMED),
                             b_triplet($MAX_TRIPLET,$MXMED),
                             dl_triplet, dli_triplet, bli_triplet, log_4rm;
        $REAL                a_triplet,b_triplet,dl_triplet, dli_triplet,
                             bli_triplet, log_4rm;
};

"------------------------------------------------------------------------"
"*** COMPTON-DATA -- Incoherent scattering data                          "
"------------------------------------------------------------------------"
REPLACE {$MXTOTSH}   WITH {1538} "Total number of shells for Z=1..100    "
REPLACE {$MXMDSH}    WITH {200}   "Max. number of shells per medium       "
REPLACE {$INCOHUNIT} WITH {i_incoh}   "Unit number for compton data           "

REPLACE {;COMIN/COMPTON-DATA/;} WITH
{
  ;common/compton_data/ iz_array($MXTOTSH), "Atomic number for each shell"
                        be_array($MXTOTSH), "Shell binding energies      "
                        Jo_array($MXTOTSH), "Compton profile parameter   "
                        erfJo_array($MXTOTSH),"needed for the calculation"
                                            "of the incoherent scattering"
                                            "function                    "
                        ne_array($MXTOTSH), "Occupation number           "
                        shn_array($MXTOTSH),"shell type                  "
                                            "(=1     for K,              "
                                            " =2,3,4 for L1,L2,L3        "
                                            " =5     for M               "
                                            " =6     for N               "
                                            " =7     for all others      "
                        shell_array($MXMDSH,$MXMED),
                        eno_array($MXMDSH,$MXMED),
                        eno_atbin_array($MXMDSH,$MXMED),
                        n_shell($MXMED),
                        radc_flag,          "flag for radiative corrections"
                        ibcmp($MXREG);      "flag to turn on binding effects"
   $INTEGER             iz_array,ne_array,shn_array,eno_atbin_array,
                        shell_array,n_shell,radc_flag;
   $REAL                be_array,Jo_array,erfJo_array,eno_array;
   $SHORT_INT           ibcmp;
}


"------------------------------------------------------------------ "
"*** EDGE -- Containes binding energies for K,L1,L2,L3,             "
"             'average' M and 'average' N shells; photo-absorption  "
"             interaction probabilities with these shells;          "
"             + fluorescence, Auger, Coster-Kronig transition       "
"             probabilities                                         "
"             IEDGFL is a flag for turning on/off atomic relaxations"
"             IPHTER is a flag for turning on/off photo-lectron     "
"                    angular distribution                           "
"             both are left-overs from the previous coding          "
"             Have put now also data to calculate elemental PE      "
"             cross sections needed to sample the element the photon"
"             is interacting with.
"------------------------------------------------------------------ "
REPLACE {$MXELEMENT} WITH {100}  " Number of elements               "
REPLACE {$MXSHXSEC}  WITH {30}   " Number of shells available       "
REPLACE {$MXSHELL}   WITH {6}    " Number of shells treated         "
REPLACE {$MXINTER}   WITH {5}    " $MXSHELL-1                       "
REPLACE {$MXTRANS}   WITH {39}   " Number of possible transitions   "
REPLACE {$MXEDGE}    WITH {16}   " max. number of edges above 1 keV "
REPLACE {$PHOTOUNIT} WITH {i_photo_relax} " unit number for photo_relax.data "
REPLACE {$PHOCSUNIT} WITH {i_photo_cs}   " unit number for photo_cs.data    "

REPLACE {;COMIN/EDGE/;} WITH
{;
   COMMON/EDGE/binding_energies($MXSHXSEC,$MXELEMENT),
               interaction_prob($MXSHELL,$MXELEMENT),
               relaxation_prob($MXTRANS,$MXELEMENT),
               edge_energies($MXEDGE,$MXELEMENT),
               edge_number($MXELEMENT),
               edge_a($MXEDGE,$MXELEMENT),
               edge_b($MXEDGE,$MXELEMENT),
               edge_c($MXEDGE,$MXELEMENT),
               edge_d($MXEDGE,$MXELEMENT),
               IEDGFL($MXREG),IPHTER($MXREG);
   $REAL       binding_energies, " K,L1,L2,L3,M,N binding energies  "
               interaction_prob, " prob. for interaction with one of"
                                 " the above shells (provided photon"
                                 " energy is above be)              "
               relaxation_prob,  " relaxation probabilities         "
               edge_energies,    " photo-absorption edge energies   "
               edge_a,edge_b,edge_c,edge_d;
                                 " photo cross section fit parameters "
   $SHORT_INT  IEDGFL,  "flag for switching on fluorscent emission"
               IPHTER;  "flag for switching on photo-electron angular distr."
   $INTEGER    edge_number; " number of `edges' for each element"
}

"------------------------------------------------------------------"
"*** ELECIN--ELECTRON TRANSPORT INPUT                              "
"        MODIFIED 1989/12/19 TO INCLUDE IUNRST,EPSTFL AND IAPRIM   "
"        NRC DWOR                                                  "
"------------------------------------------------------------------"
REPLACE {;COMIN/ELECIN/;} WITH
{;
   COMMON/ELECIN/
   esig_e($MXMED),psig_e($MXMED),
   esige_max, psige_max,
   range_ep(0:1,$MXEKE,$MXMED),
   E_array($MXEKE,$MXMED),
   $LGN(etae_ms,etap_ms,q1ce_ms,q1cp_ms,q2ce_ms,q2cp_ms,
        blcce($MXEKE,$MXMED)/0,1/),
   $LGN(EKE($MXMED)/0,1/),
   $LGN(XR0,TEFF0,BLCC,XCC($MXMED)),
   $LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,TMXS($MXEKE,$MXMED)/0,1/),
   expeke1($MXMED),
   IUNRST($MXMED),EPSTFL($MXMED),IAPRIM($MXMED),
   sig_ismonotone(0:1,$MXMED);
   $REAL    esig_e,        "maximum electron cross section per energy loss"
                           "for each medium"
            psig_e,        "maximum positron cross section per energy loss"
                           "for each medium"
            esige_max,     "maximum electron cross section per energy loss"
            psige_max,     "maximum electron cross section per energy loss"
            range_ep,      "electron (0) or positron (1) range"
            E_array,       "table energies"
            etae_ms0,etae_ms1,
                           "for interpolation of screening parameter (e-)"
            etap_ms0,etap_ms1,
                           "for interpolation of screening parameter (e+)"
            q1ce_ms0,q1ce_ms1,
                          "for interpolation of q1 correction due to spin (e-)"
            q1cp_ms0,q1cp_ms1,
                          "for interpolation of q1 correction due to spin (e+)"
            q2ce_ms0,q2ce_ms1,
                          "for interpolation of q2 correction due to spin (e-)"
            q2cp_ms0,q2cp_ms1,
                          "for interpolation of q2 correction due to spin (e+)"
            blcce0,blcce1,"for interpolation of scattering power correction   "
                          "necessary to account for scattering already taken  "
                          "into account in discrete Moller/Bhabha             "
            expeke1,       "Exp(1/eke1)-1"
            $LGN(EKE/0,1/),"table for kinetic energy indexing"
            XR0,           "unused, but read in HATCH"
            TEFF0,         "unused, but read in HATCH"
            BLCC,          "b lower case sub c"
            XCC,           "chi sub-c-c"
            ESIG0,ESIG1,   "used for electron cross section interpolation"
            PSIG0,PSIG1,   "used for positron cross section interpolation"
            EDEDX0,EDEDX1, "used for electron dE/dx interpolation"
            PDEDX0,PDEDX1, "used for positron dE/dx interpolation"
            EBR10,EBR11,   "used for e- branching into brems interpolation"
            PBR10,PBR11,   "used for e+ branching into brems interpolation"
            PBR20,PBR21,   "used for e+ branching into Bhabha interpolation"
            TMXS0,TMXS1;   "used for maximum step-size interpolation"
   $INTEGER IUNRST,        "flag for type of stopping power (see PEGS4)"
            EPSTFL,        "flag for ICRU37 collision stopping powers"
            IAPRIM;        "flag for ICRU37 radiative stopping powers"
   $LOGICAL sig_ismonotone;"true, if cross section is an increasing function"
                           "of energy, false otherwise"
}

"***************************************************************************"
"                                                                           "
" ------------ common block for EII data -----------------                  "
"
" Added by Iwan Kawrakow, March 20 2004.
"                                                                           "
"****************************************************************************

REPLACE {$MAX_EII_SHELLS} WITH {40};  "Maximum number of shells participating"
                                      "in EII in a simulation                "
REPLACE {$N_EII_BINS} WITH {250};     "Number of bins for EII x-section      "
                                      "interpolations                        "
REPLACE {$MAX_EII_BINS} WITH {{COMPUTE $N_EII_BINS*$MAX_EII_SHELLS}};
"We store the EII x-section interpolation coefficients in 1D arrays  "
"The above is the dimension of these arrays required to hold the data"
REPLACE {;COMIN/EII-DATA/;} WITH {;
    common/eii_data/
        eii_xsection_a($MAX_EII_BINS), "EII x-section interpolation coeff."
        eii_xsection_b($MAX_EII_BINS), "EII x-section interpolation coeff."
        eii_cons($MXMED),
        eii_a($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
        eii_b($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
        eii_L_factor,                  "L-shell EII xsection scaling factor"
        eii_z($MAX_EII_SHELLS),        "Z of each shell                   "
        eii_sh($MAX_EII_SHELLS),       "shell type (1=K, 2=LI, eyc.)      "
        eii_nshells($MXELEMENT),       "No. of EII shells for each element"
        eii_nsh($MXMED),               "No. of EII shells for each medium "
        eii_first($MXMED,$MXEL),       "First EII shell in the list of shells"
        eii_no($MXMED,$MXEL),          "N. of EII shells                  "
        eii_flag;                      "EII flag                          "
                                       "         = 0 => no EII            "
                                       "         = 1 => simple EII        "
                                       "         > 1 => future use        "
    $REAL     eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_factor;
    $INTEGER  eii_z,eii_sh,eii_nshells;
    $INTEGER  eii_first,eii_no;
    $INTEGER  eii_elements,eii_flag,eii_nsh;
};

REPLACE {$COMIN-EII-SAMPLE;} WITH {
    ;COMIN/EPCONT,EII-DATA,EGS-VARIANCE-REDUCTION,RANDOM,STACK,THRESH,
           UPHIOT,USEFUL,EGS-IO,RELAX-DATA/;
};
REPLACE {$COMIN-EII-INIT;} WITH {
    ;COMIN/BREMPR,EDGE,EGS-IO,EII-DATA,ELECIN,MEDIA,THRESH,USEFUL/;
};

REPLACE {;COMIN/EMF-INPUTS/;} WITH {;
    common/emf_inputs/ExIN,EyIN,EzIN, "E field"
                     EMLMTIN,         "Ekin, u, E fractional maximum change"
                     BxIN, ByIN, BzIN,       "B field: initial region"
                     Bx, By, Bz,             "B field: current region"
                     Bx_new, By_new, Bz_new, "B field: in new region"
                     emfield_on;             "true if EM fields not null"

   $REAL    ExIN,EyIN,EzIN,
            EMLMTIN,
            BxIN,ByIN,BzIN,
            Bx,By,Bz,
            Bx_new,By_new,Bz_new;
   $LOGICAL emfield_on;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"
" The following common block is made available to the user so that  "
" he/she knows which shell was being relaxed when the call to ausgab"
" occured                                                           "
" Added by Iwan Kawrakow, March 22 2004.                            "

REPLACE {;COMIN/RELAX-USER/;} WITH {;
   common/user_relax/ u_relax,ish_relax,iZ_relax;
   $REAL              u_relax;
   $INTEGER           ish_relax, iZ_relax;
};


;  "---------- BUFFER FLUSH SEMICOLON ----------"
"***************************************************************************"
"                                                                           "
" ------------ common blocks for EADL relaxation data -----------------     "
"
" Added by Ernesto Mainegra, June 1st 2011.                                 "
"                                                                           "
"***************************************************************************"
"shell in one long list, avoiding repetition (i.e. if an element is present"
"in different materials, its shell structure and information will be stored"
"only once in the list). The array shell_eadl(Z,i) tells us the position of"
"the i'th shell of element Z in the long shell list.                       "
"***************************************************************************"

REPLACE {$MXESHLL} WITH {30}  "max. number of shells for an element"
REPLACE {$MAXSHELL} WITH {3000}"max. number of shells"
REPLACE {$MAXRELAX} WITH {10000}"max. number of relaxations channels"
REPLACE {$MAXVAC} WITH {100}   "max. number of vacancies"
REPLACE {$MAXTRANS} WITH {300}  "max. number of transitions per element"
"============================================================"
" Set input key 'Atomic relaxations' to 'simple' to recover original
" implementation which allows photoelectric interactions with <M> and
" <N> shells. See below for details on the shells considered by different
" interactions depending on the value of eadl_relax:
"
"      Interaction        .false.             .true.
"      -----------------------------------------
"      Compton                all available shells
"      EII                K,L1..L3            K,L1..L3
"      Photoeffect        K,L1..L3,<M>,<N>    K,L1..L3
"      Shellwise
"      Photoeffect             N/A      All shells > $RELAX-CUTOFF
"      Relaxation
"        initial vacancy  K,L1..L3,<M>        K,L1..L3
"        (for new photoeffect)                K, L1..L3, M1..M5, N1..N4
"        final vacancy    L1..L3,<M>,<N>      L1..L3,M1..M5,N1..N7...
"
"============================================================"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {;COMIN/SHELL-DATA/;} WITH {;

  common/shell_data/
    shell_be($MAXSHELL),      "binding energies"
    shell_type($MAXSHELL),    "shell type according to EADL notation"
    shell_num($MAXSHELL),     "the shell position in the element"
    shell_Z($MAXSHELL),       "Z of the element the shell belongs to"
    shell_eadl($MXELEMENT,$MXESHLL), "global index for a shell of element Z"
    shell_ntot;               "total number of shells in the list"
  $REAL    shell_be;
  $INTEGER shell_type,shell_Z,shell_ntot,shell_num,shell_eadl;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {;COMIN/RELAX-DATA/;} WITH {;

  common/relax_data/
    relax_first($MAXSHELL),    "first transition"
    relax_ntran($MAXSHELL),    "number of transitions"
    relax_state($MAXRELAX),    "final state of the transition"
    relax_prob($MAXRELAX),     "probability"
    relax_atbin($MAXRELAX),    "used for alias sampling"
    relax_ntot;                "total number of transitions in the list"
  $REAL     relax_prob;
  $INTEGER  relax_first, relax_ntran, relax_state, relax_atbin, relax_ntot;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {;COMIN/RELAX-FOR-USER/;} WITH {;
    common/relax_for_user/
     rfu_E0, "binding energy of vacancy that initiated cascade"
     rfu_E,  "binding energy of current vacancy"
     rfu_Z,  "Atomic number of the element the relaxing shell belongs to"
     rfu_j0, "shell numb. of vacancy that initiated cascade in the list"
     rfu_n0, "same but number is shell number in the element"
     rfu_t0, "same but number is shell type according to EADL notation"
     rfu_j,  "shell number of current vacancy"
     rfu_n,  "same but number is shell number in the element"
     rfu_t;  "same but number is shell type according to EADL notation"
    $INTEGER rfu_Z,rfu_j0,rfu_n0,rfu_t0,rfu_j,rfu_n,rfu_t;
    $REAL    rfu_E0,rfu_E;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {$COMIN-RELAX-INIT;} WITH {
;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
RELAX-DATA,SHELL-DATA/;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {$COMIN-RELAX-EADL;} WITH {
;COMIN/RELAX-DATA,RELAX-FOR-USER,SHELL-DATA,
STACK,THRESH,EPCONT,USEFUL,UPHIOT,RANDOM,BOUNDS,EGS-IO,MISC,MEDIA,
X-OPTIONS/;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"***************************************************************************"
"                                                                           "
" -------------- shell-wise photoelectric cross section data ------------   "
"
" Cross sections taken from Sabbatucci and Salvat,                          "
" Theory and calculation of the atomic photoeffect                          "
" Radiat. Phys. and Chem., Volume 121, April 2016, Pages 122-140            "
"                                                                           "
"***************************************************************************"
" Shell-wise photoelectric cross sections from 50 eV up to 1 GeV for elements
" from Z=1 up to Z=99. All K, L, M, and N shells are included. One can define
" a threshold energy separating inner from outer shells. By default this
" energy is set to 1 keV, but for accurate calculation of quantities that  "
" require knowledge of which particle deposited the energy, one might need to
" use the a lower threshold.
"***************************************************************************"
"============================================================"
REPLACE {$RELAX-CUTOFF} WITH {0.001"threshold energy for outer shells"}
REPLACE {$MXPESHELL} WITH {16} "K,L1..L3,M1..M5,N1..N7 + outer shell"
REPLACE {$MXNE} WITH {500}     "number of energy points per shell "
"============================================================"
REPLACE {;COMIN/PE-SHELL-DATA/;} WITH {;

  common/pe_shell_data/
    pe_xsection($MXNE,$MXELEMENT,0:$MXPESHELL),  "shellwise cross sections"
    pe_elem_prob($MXNE,$MXELEMENT,$MXMED), "prob. of interaction with an"
                                           "element of a medium"
    pe_energy($MXNE,$MXELEMENT),    "energy grid"
    pe_zsorted($MXELEMENT,$MXMED),"sorted array of Z for each medium"
    pe_be($MXELEMENT,$MXPESHELL),      "binding energies"
    pe_nshell($MXELEMENT),       "number of shells for each element"
    pe_zpos($MXELEMENT),       "position of each Z element"
    pe_nge($MXELEMENT),       "number of energy points for each element"
    pe_ne;                    "number of elements in the simulation"
  $REAL    pe_be, pe_energy, pe_xsection, pe_elem_prob;
  $INTEGER pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {$COMIN-SHELLWISE-PE-INIT;} WITH {
;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
    PE-SHELL-DATA/;
};


;  "---------- BUFFER FLUSH SEMICOLON ----------"
" Some macros for C-style syntax in mortran "
" Unfortunately, /= doesn't work because of /v1,v2,...,vn/=value;"

REPLACE {;#+=#;} WITH { ;{P1} = {P1} + {P2}; }
REPLACE {[#+=#;} WITH { {P1} = {P1} + {P2}; }

REPLACE {;#-=#;} WITH { ;{P1} = {P1} - {P2}; }
REPLACE {[#-=#;} WITH { {P1} = {P1} - {P2}; }

REPLACE {;#*=#;} WITH { ;{P1} = {P1}*{P2}; }
REPLACE {[#*=#;} WITH { {P1} = {P1}*{P2}; }

;  "---------- BUFFER FLUSH SEMICOLON ----------"
"***************************************************************************"

REPLACE {;COMIN/ET-Control/;} WITH  "ET stands for Electron Transport"
{
  ;common/ET_control/
              smaxir($MXREG),estepe,ximax,
              "ximin_for_bca,"
              skindepth_for_bca,transport_algorithm,
              bca_algorithm,exact_bca,spin_effects;
    $REAL     smaxir,             "geom. step-size constrain for each region"
              estepe,             "global energy loss constrain"
              ximax,              "max. first GS moment per step"
                                  "(roughly half the average MS angle squared"
              "ximin_for_bca,"
                                  "min. first GS moment per step for boundary"
                                  "crossing in VMC mode"
              skindepth_for_bca;  "distance from a boundary (in elastic MFP)"
                                  "to switch to one of the BCAs "
    $INTEGER  transport_algorithm,"=$PRESTA-II or $PRESTA--I"
              bca_algorithm;      "will be used if other inexact BCAs"
                                  "implemented in the future"
    $LOGICAL  exact_bca,          "if .true. => BCA in single scattering mode"
              spin_effects;       "if .true. electron/positron spin effects"
                                  "are taken into account in the single and"
                                  "multiple elasting scattering routines"
}
;

" ======================== multiple scattering commons ================= "

" Screened Rutherford MS data "

REPLACE {$MAXL_MS}    WITH {63}
REPLACE {$MAXQ_MS}    WITH {7}
REPLACE {$MAXU_MS}    WITH {31}
REPLACE {$0-MAXL_MS}  WITH {0:63}
REPLACE {$0-MAXQ_MS}  WITH {0:7}
REPLACE {$0-MAXU_MS}  WITH {0:31}
REPLACE {$LAMBMIN_MS} WITH {1.}
REPLACE {$LAMBMAX_MS} WITH {1e5}
REPLACE {$QMIN_MS}    WITH {1e-3}
REPLACE {$QMAX_MS}    WITH {0.5}

REPLACE {COMIN/MS-Data/;} WITH {
  common/ms_data/
              ums_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
              fms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
              wms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
              ims_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
              llammin,llammax,dllamb,dllambi,dqms,dqmsi;
  real*4      ums_array,fms_array,wms_array,
              llammin,llammax,dllamb,dllambi,dqms,dqmsi;
  $SHORT_INT  ims_array;
}
;

" spin effect data used in an additional rejection loop "

REPLACE {$MAXE_SPIN}   WITH {15}
REPLACE {$MAXE_SPI1}   WITH {{COMPUTE 2*$MAXE_SPIN+1}}
REPLACE {$MAXQ_SPIN}   WITH {15}
REPLACE {$MAXU_SPIN}   WITH {31}
REPLACE {$0-MAXE_SPI1} WITH {0:$MAXE_SPI1}
REPLACE {$0-MAXQ_SPIN} WITH {0:$MAXQ_SPIN}
REPLACE {$0-MAXU_SPIN} WITH {0:$MAXU_SPIN}

REPLACE {COMIN/Spin-Data/;} WITH {
  common/spin_data/
              spin_rej($MXMED,0:1,$0-MAXE_SPI1,$0-MAXQ_SPIN,$0-MAXU_SPIN),
              espin_min,espin_max,espml,b2spin_min,b2spin_max,
              dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i,
              fool_intel_optimizer;
  real*4      spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max,
              dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i;
  $LOGICAL    fool_intel_optimizer;
}
;

REPLACE {COMIN/CH-Steps/;} WITH
{
  common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step;
  real*8           count_pII_steps,count_all_steps;
  $LOGICAL         is_ch_step;
}
;
"------------------------------------------------------------------"
"*** EPCONT--ELECTRON-PHOTON CONTROL VARIABLES                     "
"------------------------------------------------------------------"
REPLACE {;COMIN/EPCONT/;} WITH
{;
  COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP,
                RHOF,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE,
                x_final,y_final,z_final,
                u_final,v_final,w_final,
                IDISC,IROLD,IRNEW,IAUSFL($MXAUS);
    $ENERGY PRECISION EDEP,   "energy deposition in MeV"
                      EDEP_LOCAL; "local energy deposition in MeV"
    $REAL             TSTEP,  "distance to a discrete interaction"
                      TUSTEP, "intended step length, befor check with geometry"
                      USTEP,  "transport distance calculated from TUSTEP"
                      VSTEP,  "transport distance after truncation by HOWFAR"
                      TVSTEP, "curved path-length calculated from TVSTEP"
                      RHOF,   "mass density ratio"
                      EOLD,   "energy before deduction of energy loss"
                      ENEW,   "energy after  deduction of energy loss"
                      EKE,    "kinetic energy"
                      ELKE,   "Log(EKE)"
                      GLE,    "Log(energy) in PHOTON"
                      E_RANGE,"range of electron before an iarg=0 ausgab call"
                      x_final,y_final,z_final, "position at end of step"
                      u_final,v_final,w_final; "direction at end of step"
                                               "only set (and relevant) "
                                               "for electrons"
    $INTEGER          IDISC,  "flag indicating user discard"
                      IROLD,  "region before transport"
                      IRNEW,  "region after transport"
                      IAUSFL; "flags for AUSGAB calls"
}

"------------------------------------------------------------------"
"*** MEDIA--NAMES OF MEDIA CURRENTLY BEING USED                    "
"------------------------------------------------------------------"
REPLACE {;COMIN/MEDIA/;} WITH
{;
   COMMON/MEDIA/
"Ali:photonuc, 4 lines (order matters because of padding issues)"
       $LGN(RLC,RLDU,RHO,MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,
            IRAYLM,IPHOTONUCM($MXMED)),
            MEDIA(24,$MXMED), photon_xsections, comp_xsections,
            photonuc_xsections,eii_xfile,IPHOTONUC,NMED;
   $TYPE    MEDIA;"media names"
   $REAL    RLC,  "radiation length in centimeters for a given medium"
            RLDU, "radiation length after user scaling over-ride"
            RHO,  "mass density of a given medium"
            apx, upx;"new photon xsection data thresholds"
   $INTEGER MSGE, "??? "
            MGE,  "number of photon mapped energy intervals for a given medium"
            MSEKE,"??? "
            MEKE, "number of e mapped energy intervals for a given medium"
            MLEKE,"??? "
            MCMFP,"??? "
            MRANGE,"??? "
            IRAYLM,"Rayleigh switch for a given medium"
"Ali:photonuc, 2 lines"
            IPHOTONUCM,"photonuclear switch for a given medium"
            IPHOTONUC,"set to 1 if any IPHOTONUCM is set to 1"
            NMED;  "number of media"
   character*16 eii_xfile;
            "Defaults to eii_ik.data if On or Off options selected"
            "which is the EII implemented by Iwan for EGSnrc"
            "else, following options available: "
            "  eii_'casnati'.data    "
            "  eii_'kolbenstvedt'.data "
            "  eii_'gryzinski'.data"
            "these must be in $HEN_HOUSE/data"
   character*16 photon_xsections;
            "If photon_xsections is not empty, photon cross sections will be"
            "re-initialized using data files  "
            "  'photon_xsection'_photo.data   "
            "  'photon_xsection'_pair.data    "
            "  'photon_xsection'_triplet.data "
            "  'photon_xsection'_rayleigh.data"
            "that must be placed in $HEN_HOUSE/data"
   character*16 comp_xsections;
            "If comp_xsections is not empty or not set to 'default' and"
            "bound Compton scattering is On, then total Compton cross sections"
            "will be taken from 'comp_xsections'_compton.data"
            "instead of being computed from the theoretical expressions"
"Ali:photonuc, 5 lines"
   character*16 photonuc_xsections;
            "If photonuc_xsections is not empty or not set to 'default',"
            "the photonuclear cross sections will be taken from"
            "'photonuc_xsections'_photonuc.data instead of using the data"
            "in the default file iaea_photonuc.data."
}

"------------------------------------------------------------------"
"*** MISC--MISCELLANEOUS COMMON                                    "
"------------------------------------------------------------------"
REPLACE {;COMIN/MISC/;} WITH
{;
  COMMON/MISC/
"Ali:photonuc, 1 line"
           DUNIT,KMPI,KMPO,$LGN(RHOR,MED,IRAYLR,IPHOTONUCR($MXREG));
  $REAL    DUNIT,   "unit scaling factor"
           RHOR;    "density of a given region"
  $INTEGER KMPI,    "fortran unit number of the pegs4 datafile"
           KMPO;    "fortran unit number of pegs4 echo file"
  $SHORT_INT MED,   "medium number for a given region"
             IRAYLR,"Rayleigh switch for a given region"
"Ali:photonuc, 1 line"
             IPHOTONUCR;"photonuclear switch for a given region"
}
;

"------------------------------------------------------------------"
"*** PHOTIN--PHOTON TRANSPORT DATA                                 "
"------------------------------------------------------------------"
REPLACE {;COMIN/PHOTIN/;} WITH
{;
    COMMON/PHOTIN/
       EBINDA($MXMED),
       $LGN(GE($MXMED)/0,1/),
       $LGN(GMFP,GBR1,GBR2($MXGE,$MXMED)/0,1/),
       $LGN(RCO($MXMED)/0,1/),
       $LGN(RSCT($MXRAYFF,$MXMED)/0,1/),
       $LGN(COHE($MXGE,$MXMED)/0,1/),
"Ali:photonuc, 1 line"
       $LGN(PHOTONUC($MXGE,$MXMED)/0,1/),
       DPMFP,
       MPGEM($MXSGE,$MXMED),
       NGR($MXMED);
    $REAL
       EBINDA,      "energy of the K-edge for a given medium"
       GE0,GE1,     "used for indexing in logarithmic interpolations"
       GMFP0,GMFP1, "used for gamma MFP interpolation"
       GBR10,GBR11, "used for branching into pair interpolation"
       GBR20,GBR21, "used for branching into Compton interpolation"
       RCO0,RCO1,   "used for indexing in momentum trans. sampling in Rayleigh"
       RSCT0,RSCT1, "used for interpolation of momentum trans. func. in R"
       COHE0,COHE1, "used for Rayleigh modification interpolation"
"Ali:photonuc, 1 line"
       PHOTONUC0,PHOTONUC1, "used for photonuclear modification interpolation"
       DPMFP;       "number of MFP's to go to the next interaction"
    $INTEGER
       MPGEM,       "??? "
       NGR;         "array size for Rayleigh scattering data"
}
;

"------------------------------------------------------------------"
"*** RANDOM - DECLARATIONS FOR RANDOM NUMBER GENERATOR             "
"------------------------------------------------------------------"

" Note that the definition of the COMIN/RANDOM/ was taken out of   "
" the egsnrc.macros file. The current philosophy is that the user  "
" has to provide a random number generator in a separate file.     "
" Two commonly used RNGs are provided in separate files:           "
"  RANLUX: ranlux.macros and ranlux.mortran                        "
"  RANMAR: ranmar.macros and ranmar.mortran                        "


"------------------------------------------------------------------"
"*** STACK--INFORMATION KEPT ABOUT CURRENT PARTICLES               "
"------------------------------------------------------------------"
REPLACE {;COMIN/STACK/;} WITH
{;
   COMMON/STACK/
       $LGN(E,X,Y,Z,U,V,W,DNEAR,WT,IQ,IR,LATCH($MXSTACK)),
       LATCHI,NP,NPold;
   $ENERGY PRECISION
       E;     "total particle energy"
   $REAL
       X,Y,Z, "particle co-ordinates"
       U,V,W, "particle direction cosines"
       DNEAR, "perpendicular distance to nearest boundary"
       WT;    "particle weight"
   $INTEGER
       IQ,    "charge, -1 for electrons, 0 for photons, 1 for positrons"
       IR,    "current region"
       LATCH, "extra phase space variable"
       LATCHI,"needed because shower does not pass latch-BLOCK DATA sets 0"
       NP,    "stack pointer"
       NPold; "stack pointer before an interaction"
}

"------------------------------------------------------------------"
"*** THRESH--THRESHOLD (AND OTHER) ENERGIES                        "
"------------------------------------------------------------------"
REPLACE {;COMIN/THRESH/;} WITH
{;
   COMMON/THRESH/RMT2,RMSQ,
                 $LGN(AP,AE,UP,UE,TE,THMOLL($MXMED));
   $REAL         RMT2,  "2*electron mass in MeV"
                 RMSQ,  "electron mass squared in MeV**2"
                 AP,    "photon creation threshold energy"
                 AE,    "electron creation threshold energy (total)"
                 UP,    "upper photon energy in PEGS4 data set"
                 UE,    "upper electron energy in PEGS4 data set"
                 TE,    "electron creation threshold energy (kinetic)"
                 THMOLL;"Moller threshold = AE + TE"
}

"------------------------------------------------------------------"
"*** UPHIIN--SINE TABLES FOR UPHI                                  "
"------------------------------------------------------------------"
REPLACE {;COMIN/UPHIIN/;} WITH
{;
   COMMON/UPHIIN/SINC0,SINC1,$LGN(SIN($MXSINC)/0,1/);
   $REAL         SINC0,SINC1,SIN0,SIN1;
}

"------------------------------------------------------------------"
"*** UPHIOT--UPHI'S INPUT/OUTPUT WITH ITS USERS                    "
"------------------------------------------------------------------"
REPLACE {;COMIN/UPHIOT/;} WITH
{;
   COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI,
                 COSPHI,PI,TWOPI,PI5D2;
   $REAL         THETA,  "polar scattering angle"
                 SINTHE, "sin(THETA)"
                 COSTHE, "cos(THETA)"
                 SINPHI, "sine of the azimuthal scattering angle"
                 COSPHI, "cosine of the azimuthal scattering angle"
                 PI,TWOPI,PI5D2;
}

"------------------------------------------------------------------"
"*** USEFUL--HEAVILY USED VARIABLES                                "
"------------------------------------------------------------------"
REPLACE {;COMIN/USEFUL/;} WITH
{;
   COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD;
   $ENERGY PRECISION PZERO,   "precise zero"
                     PRM,     "precise electron mass in MeV"
                     PRMT2;   "2*PRM"
   $REAL             RM;      "electron mass in MeV"
   $INTEGER          MEDIUM,  "medium index of current region"
                     MEDOLD;  "medium index of previous region"
   " The rest mass value is as recommended by CODATA 2014"
   " http://physics.nist.gov/cgi-bin/cuu/Value?mec2mev"
   DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D0/;
}

"------------------------------------------------------------------"
"*** USER--A COMMON FOR THE 'USER' TO 'USE'                        "
"------------------------------------------------------------------"
REPLACE {;COMIN/USER/;} WITH {
         ;}  "DEFAULT IS NULL"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {;COMIN/X-OPTIONS/;} WITH {
    ;
  common/x_options/eadl_relax,       "Use EADL relaxation"
                   mcdf_pe_xsections;"Use Sabbatucci and Salvat PE xsections"
  $LOGICAL  eadl_relax, mcdf_pe_xsections;
};

"------------------------------------------------------------------"
"*** MACROS TO DEFINE THE COMMONS USED IN EACH SUBPROGRAM.         "
"------------------------------------------------------------------"
REPLACE {$COMIN-ANNIH;} WITH {
     ;COMIN/DEBUG,STACK, UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
REPLACE {$COMIN-ANNIH-ATREST;} WITH {
    ;COMIN/DEBUG,STACK,RANDOM,USEFUL,EGS-VARIANCE-REDUCTION,EGS-IO/;}
REPLACE {$COMIN-BHABHA;} WITH {
    ;COMIN/DEBUG,STACK, THRESH,UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,
           EGS-IO/;}
REPLACE {$COMIN-BREMS;} WITH {
    ;COMIN/DEBUG,BREMPR,EPCONT,NIST-BREMS,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
           EGS-VARIANCE-REDUCTION,EGS-IO/;}
REPLACE {$COMIN-COMPT;} WITH {
   ;COMIN/COMPTON-DATA,DEBUG,EPCONT,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
          EGS-VARIANCE-REDUCTION,EGS-IO,RELAX-DATA/;}
REPLACE {$COMIN-ELECTR;} WITH {
;COMIN/DEBUG,BOUNDS,ELECIN,EPCONT,MEDIA,MISC,STACK,THRESH,
UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,CH-Steps,EGS-IO,
          EGS-VARIANCE-REDUCTION,EMF-INPUTS/;}
REPLACE {$COMIN-HATCH;} WITH {
;COMIN/DEBUG,BOUNDS,BREMPR,ELECIN,MEDIA,MISC,PHOTIN,STACK,THRESH,
UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,EGS-IO,X-OPTIONS,
          EGS-VARIANCE-REDUCTION/;}
REPLACE {$COMIN-MOLLER;} WITH {
   ;COMIN/DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM,EGS-IO,
          EGS-VARIANCE-REDUCTION/;}
REPLACE {$COMIN-PAIR;} WITH {
   ;COMIN/DEBUG,BREMPR,NRC-PAIR-DATA,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
          EPCONT,TRIPLET-DATA,EGS-VARIANCE-REDUCTION,EGS-IO/;}
REPLACE {$COMIN-PHOTO;} WITH {
   ;COMIN/BOUNDS,BREMPR,DEBUG,EDGE,EPCONT,MEDIA,PHOTIN,RANDOM,
          STACK,UPHIOT,USEFUL,EGS-IO,X-OPTIONS,
          EGS-VARIANCE-REDUCTION,RELAX-DATA/;}
REPLACE {$COMIN-PHOTON;} WITH {
;COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,UPHIOT,
USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
REPLACE {$COMIN-SHOWER;} WITH {
  ;COMIN/DEBUG,STACK,UPHIOT,RANDOM,EGS-IO/;}
REPLACE {$COMIN-UPHI;} WITH {
  ;COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM,EGS-IO/;}
REPLACE {$COMIN-BLOCK;} WITH {
  ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,
  EPCONT,CH-Steps,ET-Control,MEDIA,MISC,PHOTIN,RANDOM,STACK,
  THRESH, UPHIIN,UPHIOT,USEFUL,EGS-VARIANCE-REDUCTION/;}
REPLACE {$COMIN-RELAX;} WITH {
  ;COMIN/EPCONT,STACK,BOUNDS,USEFUL,RANDOM,EDGE,EGS-IO,RELAX-DATA,X-OPTIONS/;}
REPLACE {$COMIN-SET-DEFAULTS;} WITH {
  ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,EPCONT,CH-Steps,ET-Control,
       MEDIA,MISC,PHOTIN,RANDOM,STACK,THRESH, UPHIIN,UPHIOT,USEFUL,
       EGS-VARIANCE-REDUCTION,EGS-IO,Spin-Data,EII-DATA,rayleigh_inputs,
       EMF-INPUTS,X-OPTIONS/;};
REPLACE {$COMIN-INIT-COMPT;} WITH {
  ;COMIN/COMPTON-DATA,BREMPR,EDGE,MEDIA,MISC,USEFUL,EGS-IO,X-OPTIONS/;};
REPLACE {$COMIN-MSCATI;} WITH {
  ;COMIN/BOUNDS,ELECIN,MEDIA,MISC,RANDOM,ET-Control,USEFUL,EGS-IO/;};
REPLACE {$COMIN-INIT-TRIPLET;} WITH {
  ;COMIN/BREMPR,EGS-IO,MEDIA,TRIPLET-DATA,USEFUL/;};
REPLACE {$COMIN-GET-TRANSPORTP;} WITH {
  ;COMIN/GetInput,BOUNDS,ET-Control,EDGE,COMPTON-DATA,MEDIA,MISC,
         BREMPR,EII-DATA,EGS-IO,rayleigh_inputs,EMF-INPUTS,X-OPTIONS/;};
"Ali:photonuc, 1 block"
REPLACE {$COMIN-PHOTONUC;} WITH {;COMIN/STACK,EPCONT,USEFUL/;};

;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {ILOG2(#)} WITH {
    IFIX(1.44269*LOG({P1}))} "1.44269=1/LN(2)"

REPLACE {$SETINTERVAL#,#;} WITH {
    [IF] '{P2}'=SNAME  [L{P1}={P2}1*{P1}+{P2}0;]
    [ELSE]  [L{P1}={P2}1(MEDIUM)*{P1}+{P2}0(MEDIUM);]}
"TWO ARGUMENT SET INTERVAL CALL (ABOVE) CURRENTLY MEANS"
"INTERVAL INDEX IS LINEAR FUNCTION OF THE LINEAR VARIABLE,"
"WITH NO MAPPING.  {P1} IS THE LINEAR VARIABLE AND {P2} IS"
"THE NAME OF THE INTERVAL(WHICH IS USED TO CONSTRUCT THE"
"COEFFICIENTS USED IN COMPUTING THE INTERVAL INDEX)."
"BUT, IF {P2} IS SINC OR BLC OR RTHR OR RTHRI, IT DOES"
"NOT DEPEND ON MEDIUM"

REPLACE {$EVALUATE#USING#(#);} WITH {
  [IF] '{P2}'=SNAME1
  [{P1}={P2}1(L{P3})*{P3}+{P2}0(L{P3});] [ELSE]
  [{P1}={P2}1(L{P3},MEDIUM)*{P3}+{P2}0(L{P3},MEDIUM);]}
"{P1} IS VARIABLE TO BE ASSIGNED VALUE."
"{P2} IS THE FUNCTION BEING APPROXIMATED."
"{P3} IS THE ARGUMENT OF THE FUNCTION. IN THE CURRENT"
"PWLF METHOD, THE ARGUMENT DETERMINES AN INTERVAL USING THE"
"$SET INTERVAL MACROS.   WITH IN THIS INTERVAL THE"
"FUNCTION IS APPROXIMATED AS A LINEAR FUNCTION OF"
"THE ARGUMENT. BUT"
"IF {P2}=SIN IT DOES NOT DEPEND ON MEDIUM"

REPLACE {$EVALUATE#USING#(#,#);} WITH {
  {P1}={P2}0(L{P3},L{P4})+{P2}1(L{P3},L{P4})*{P3}+
  {P2}2(L{P3},L{P4})*
  {P4};}"2-D APPROXIMATION INDEPENDENT OF MEDIUM"
SPECIFY SNAME AS ['sinc'|'blc'|'rthr'|'rthri'|'SINC'|'BLC'|'RTHR'|'RTHRI'];
SPECIFY SNAME1 AS ['sin'|'SIN'];

"The following circumvent the above table look up method for sin"
"functions.  Modern machines do sines very quickly so the large saving"
"in time from the above no longer exists for sines (was 40% on some"
"machines for the overall computing time! (for example it makes a
"20% effect on an SGI R4400)"
"To recover the use of tables, just comment out the following two"
"macros"

REPLACE {$EVALUATE#USING SIN(#);} WITH {{P1}=sin({P2});}
REPLACE {$SET INTERVAL#,SINC;} WITH {;}


"MACRO TO ALLOW USER TO ADD TO PROPERTIES THAT ARE"
"PASSED TO NEW PARTICLES"
REPLACE {$TRANSFERPROPERTIESTO#FROM#;} WITH {
    X{P1}=X{P2};Y{P1}=Y{P2};Z{P1}=Z{P2};IR{P1}=IR{P2};
    WT{P1}=WT{P2};DNEAR{P1}=DNEAR{P2};LATCH{P1}=LATCH{P2};}
   "IN THE USAGE OF THE ABOVE MACRO, '(IP)' WILL REFER TO THE"
   "PARTICLE WHOSE STACK INDEX IS 'IP'. 'NP' IS THE TOP OF THE STACK."
   "JUST PLAIN 'I' WILL REFER TO THE INITIAL VALUES SUPPLIED"
   "AS ARGUMENTS TO SHOWER, OR SUPPLIED IN COMMON BLOCKS OR"
   "DATA STATEMENTS IN SHOWER."

"Macro to check that the stack size is not exceeded"
REPLACE {$CHECK-STACK(#,#);} WITH {;
  IF( {P1} > $MXSTACK ) [
;  "---------- BUFFER FLUSH SEMICOLON ----------"
      $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
          ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
          ' Increase $MXSTACK and try again ');
  ]
};

/*
   Redefined to be able to use huge stack in C++ application after
   implementing new relaxation.
 */
REPLACE {$CHECK-STACK(#,#);} WITH {;
  IF( {P1} > $MXSTACK ) [
      $egs_fatal('(//,3a,/,2(a,i9))',' In subroutine ',{P2},
          ' stack size exceeded! ',' $MAXSTACK = ',$MXSTACK,' np = ',{P1});
  ]
};

"MACRO FOR RE-EVALUATING DEDX IN SUBROUTINE ELECTR"
REPLACE {$DEDX-RE-EVALUATION;} WITH {
;}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"THE FOLLOWING MACROS ARE USED IN SUBROUTINE ELECTR IN ORDER TO MAKE"
"PATH LENGTH CORRECTIONS AND RESTRICTIONS:"
REPLACE {$SET-USTEP;} WITH
{
  ekems = eke - 0.5*tustep*dedx; "Use mid-point energy to calculate"
                                  "energy dependent quantities"
  $CALCULATE-XI(tustep);
  IF ( xi < 0.1 )
    [
      ustep = tustep*(1 - xi*(0.5 - xi*0.166667));
    ]
    ELSE
    [
      ustep = tustep*(1 - Exp(-xi))/xi;
    ]
}
;

REPLACE {$CALCULATE-XI(#);} WITH
{
  p2 = ekems*(ekems+rmt2); beta2 = p2/(p2 + rmsq);
  chia2 = xccl/(4*blccl*p2);
                                "Note that our chia2 is Moliere chia2/4"
                                "Note also that xcc is now old egs xcc**2"
  xi = 0.5*xccl/p2/beta2*{P1};
  IF( spin_effects ) [
      elkems = Log(ekems);
      $SET INTERVAL elkems,eke;
      IF(lelec < 0) [
          $EVALUATE etap USING etae_ms(elkems);
          $EVALUATE xi_corr USING q1ce_ms(elkems);
      ]
      ELSE          [
          $EVALUATE etap USING etap_ms(elkems);
          $EVALUATE xi_corr USING q1cp_ms(elkems);
      ]
      chia2 = chia2*etap; xi = xi*xi_corr;
      $EVALUATE ms_corr USING blcce(elkems);
      blccl = blccl*ms_corr;
  ]
  ELSE [ xi_corr = 1; etap = 1; ]
  xi = xi*(Log(1+1./chia2)-1/(1+chia2));
}

REPLACE {$SET-TVSTEP;} WITH
"        ===========                 "
{
    ;IF ( vstep < ustep0 )
    [
      ekems = eke - 0.5*tustep*vstep/ustep0*dedx;
         "This estimates the energy loss to the boundary."
         "tustep was the intended curved path-length,"
         "ustep0 is the average transport distance in the initial direction"
         "       resulting from tustep"
         "vstep = ustep is the reduced average transport distance in the "
         "              initial direction due to boundary crossing"
      $CALCULATE-XI(vstep);
      IF ( xi < 0.1 )
      [
        tvstep = vstep*(1 + xi*(0.5 + xi*0.333333));
      ]
      ELSE
      [

        IF ( xi < 0.999999 )
        [
           tvstep = -vstep*Log(1 - xi)/xi;
        ]
        ELSE
        [
           "This is an error condition because the average transition "
           "in the initial direction of motion is always smaller than 1/Q1"
           $egs_info(*,' Stoped in SET-TVSTEP because xi > 1! ');
           $egs_info(*,' Medium: ',medium);
           $egs_info(*,' Initial energy: ',eke);
           $egs_info(*,' Average step energy: ',ekems);
           $egs_info(*,' tustep: ',tustep);
           $egs_info(*,' ustep0: ',ustep0);
           $egs_info(*,' vstep:  ',vstep);
           $egs_info(*,' ==> xi = ',xi);
           $egs_fatal(*,'This is a fatal error condition');
        ]
      ]
    ]
    ELSE
    [
      tvstep = tustep;
    ]
}
;

REPLACE {$ENEPS} WITH {0.0001}
            "DIFFERENCE BETWEEN ECUT AND END POINT ENERGY FOR"
            "RANGE CALCULATION"

REPLACE {$EPSEMFP} WITH {1.E-5}  "SMALLEST ELECTRON MFP VALUE"
REPLACE {$EPSGMFP} WITH {1.E-5}  "SMALLEST GAMMA MFP VALUE"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"THE FOLLOWING ARE UTILITY AND OTHER MACROS FOR THE USER"

"ETALY1---COMMON BLOCK FOR ENERGY CONSERVATION PURPOSES"
REPLACE {;COMIN/ETALY1/;} WITH {
    ;COMMON/ETALY1/ESUM(4,$MXREG,5);
    $ENERGY PRECISION ESUM;}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"NTALY1---COMMON BLOCK FOR KEEPING COUNT OF ETALY1-EVENTS"
REPLACE {;COMIN/NTALY1/;} WITH {
   ;COMMON/NTALY1/NSUM(4,$MXREG,5);
   $INTEGER NSUM;
}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MACRO TO ALLOW USER TO INITIALIZE IN SUBROUTINE HATCH"
REPLACE {$HATCH-USER-INPUT-INIT;} WITH {;
" $RNG-INITIALIZATION; "
" Have taken this out, (IK, Jan 2000). If the user does not initilize the"
" rng before the first call to shower, the rng will initialize itself    "
" using the default seed and the default luxury level (which is defined  "
" via $DEFAULT-LL).                                                      "

DO J=1,$MXREG [
  IF(SMAXIR(J)<=0.0) [SMAXIR(J)=1E10;]
]
;}

REPLACE {$KERMA-INSERT;} WITH {;}
            "USED IN KERMA CALCULATIONS---DEFAULT IS NULL"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MACRO FOR CONTROLLING NEGATIVE USTEP"
REPLACE {$USER-CONTROLS-NEGATIVE-USTEP;} WITH {
"         ============================"
   ;IF(USTEP<-1.E-4)[ IERUST=IERUST+1;OUTPUT IERUST,USTEP,IR(NP),IRNEW,
   IROLD,X(NP),Y(NP),Z(NP),SQRT(X(NP)**2+Y(NP)**2);
   (I6,' NEGATIVE USTEP=',E14.6,' IR,IRNEW,IROLD=',3I4,' X,Y,Z,R=',
   4E14.6);
   IF(IERUST>10)[OUTPUT;(///'0STOP, TOO MANY USTEP ERRORS'///); STOP;]]
   USTEP=0.0;}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {$CHECK-NEGATIVE-USTEP;} WITH {;
    IF(ustep <= 0) [
        "Negative ustep---probable truncation problem at a"
        "boundary, which means we are not in the region we think"
        "we are in.  The default macro assumes that user has set"
        "irnew to the region we are really most likely to be"
        "in.  A message is written out whenever ustep is less than -1.e-4"
        IF(ustep < -1e-4) [
            ierust = ierust + 1;
            OUTPUT ierust,ustep,dedx,e(np)-prm,
                   ir(np),irnew,irold,x(np),y(np),z(np);
            (i4,' Negative ustep = ',e12.5,' dedx=',F8.4,' ke=',F8.4,
             ' ir,irnew,irold =',3i4,' x,y,z =',4e10.3);
            IF(ierust > 1000) [
                OUTPUT;(////' Called exit---too many ustep errors'///);
                $CALL_EXIT(1);
            ]
        ]
        ustep = 0;
    ]
};

"MACRO FOR INTRODUCING FLUCTUATIONS IN THE ENERGY LOSS BY"
"CHARGED PARTICLES (E.G., 'LANDAU FLUCTUATIONS')---DEFAULT IS NULL"
REPLACE {$DE-FLUCTUATION;} WITH {;}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"Macro for production of annihilation quanta whenever"
"the energy is greater than AE but less than or equal to ECUT."
"photons are always produced in EGSnrc."

REPLACE {$POSITRON-ECUT-DISCARD;} WITH {EDEP=PEIE-PRM;}
"NOTE: TO GET THE EGS3 VERSION SIMPLY USE EDEP=PEIE+PRM"
"      AS THE REPLACEMENT PART OF THE MACRO."
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MACROS FOR PARTICLE SELECTION (E.G., LEADING PARTICLE,"
"SPLITTING, ETC.).  DEFAULT IS ULTIMATELY 'NULL'"
"     -----IN SUBROUTINE ELECTR-----                 "
REPLACE {$PARTICLE-SELECTION-ELECTR;} WITH {;}
REPLACE {$PARTICLE-SELECTION-ANNIH;} WITH {
         $PARTICLE-SELECTION-ELECTR;}
REPLACE {$PARTICLE-SELECTION-ANNIHREST;} WITH {
        $PARTICLE-SELECTION-ELECTR;}
REPLACE {$PARTICLE-SELECTION-BHABHA;} WITH {
        $PARTICLE-SELECTION-ELECTR;}
REPLACE {$PARTICLE-SELECTION-BREMS;} WITH {
        $PARTICLE-SELECTION-ELECTR;}
REPLACE {$PARTICLE-SELECTION-MOLLER;}
   WITH {$PARTICLE-SELECTION-ELECTR;}
"     -----IN SUBROUTINE PHOTON-----                 "
REPLACE {$PARTICLE-SELECTION-PHOTON;} WITH {;}
REPLACE {$PARTICLE-SELECTION-COMPT;} WITH {
        $PARTICLE-SELECTION-PHOTON;}
REPLACE {$PARTICLE-SELECTION-PAIR;} WITH {
        $PARTICLE-SELECTION-PHOTON;}
REPLACE {$PARTICLE-SELECTION-PHOTO;} WITH {
        $PARTICLE-SELECTION-PHOTON;}

"MACRO FOR SELECTION OF THE ELECTRON MEAN-FREE-PATH"
REPLACE {$SELECT-ELECTRON-MFP;} WITH {
        $RANDOMSET RNNE1; IF(RNNE1.EQ.0.0) [RNNE1=1.E-30;]
         DEMFP=MAX(-LOG(RNNE1),$EPSEMFP);}

"MACRO FOR SELECTION OF THE PHOTON MEAN-FREE-PATH"
REPLACE {$SELECT-PHOTON-MFP;} WITH {
       $RANDOMSET RNNO35; IF(RNNO35.EQ.0.0) [RNNO35=1.E-30;]
         DPMFP=-LOG(RNNO35);}

"MACRO to do range rejection on a region by region basis"
"      if the user requests it.  The variables e_max_rr and i_do_rr"
"      are in COMIN ET-CONTROL.  This macro is called immediately"
"      after $USER-RANGE-DISCARD in ELECTR and everytime called"
"      the electrons current range has been computed and stored in"
"      range and the distance to the nearest boundary has just been"
"      computed and is in tperp.  e_max_rr and i_do_rr are initialized"
"      to zero in BLOCK DATA so range rejection is not done unless"
"      Since option must be turned on by the user, it is considered a"
"      USER-ELECTRON-DISCARD."
"      Note this technique implies an approximation because the particle"
"      is not allowed to create a brem particle which might escape"
"      the region.  This is why  e_max_rr is used, to allow high"
"      energy electrons to be tracked in case they give off brem."

REPLACE {$RANGE-DISCARD;} WITH {
  ;IF( i_do_rr(irl) = 1 & e(np) < e_max_rr(irl) ) [
      IF(tperp >= range) ["particle cannot escape local region"
          idisc = 50 + 49*iq(np); "1 for electrons, 99 for positrons"
          go to :USER-ELECTRON-DISCARD: ;
      ]
  ]
};


"MACRO TO ALLOW USER TO DISCARD IF AT OR NEAR END OF RANGE"
REPLACE {$USER-RANGE-DISCARD;} WITH {;}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"RAYLEIGH (COHERENT) SCATTERING MACROS"

"custom form factor file names"
/*********************************************************
   For simplicity, molecular form factors are assumed to
   ALWAYS be given as FF/SQRT(MW). Current available mol.
   FF are given this way.

   One could devise a more complex scheme, where the user
   enters by input in which form the FF are given and then,
   depending on whether the medium is defined as compound or
   mixture, egsnrc must or not multiplicate the Rayleigh
   xsection with the molecular weight.

   In the current scheme, this is done automatically
   without needing input from the user.
**********************************************************/
REPLACE {COMIN/rayleigh_inputs/;} WITH
"        ================"
{
;COMMON/rayleigh_inputs/iray_ff_media($MXMED),iray_ff_file($MXMED);
;character*24 iray_ff_media;
;character*128 iray_ff_file;
}

REPLACE {COMIN/rayleigh_sampling/;} WITH
"        ================"
{;COMMON/rayleigh_sampling/xgrid($MXRAYFF,$MXMED),
                            fcum($MXRAYFF,$MXMED),
                           b_array($MXRAYFF,$MXMED),
                           c_array($MXRAYFF,$MXMED),
                           i_array($RAYCDFSIZE,$MXMED),
                           $LGN(pmax($MXGE,$MXMED)/0,1/);
$REAL xgrid, fcum, b_array, c_array,pmax0, pmax1;
$INTEGER i_array;
}

REPLACE {$RAYLEIGH-CORRECTION;} WITH {
     ;IF(IRAYLR(IRL).EQ.1) [$EVALUATE COHFAC USING COHE(GLE);
    GMFP=GMFP*COHFAC];}

REPLACE {$OLD_RAYLEIGH-SCATTERING;} WITH {
      ;IF(IRAYLR(IRL).EQ.1) [
   $RANDOMSET RNNO37;
   IF (RNNO37.LE.(1.0-COHFAC)) [
   $AUSCALL($RAYLAUSB);
   NPold = NP;
   :SAMPLING-LOOP: LOOP [$RANDOMSET XXX;
   $SET INTERVAL XXX,RCO; $EVALUATE X2 USING RSCT(XXX);
   Q2=X2*RMSQ/(20.60744*20.60744);
   COSTHE=1.-Q2/(2.*E(NP)*E(NP));
   IF (ABS(COSTHE).GT.1.0) GO TO :SAMPLING-LOOP:;
   CSQTHE=COSTHE*COSTHE;
   REJF=(1.0+CSQTHE)/2.0;
   $RANDOMSET RNNORJ;
   ] UNTIL (RNNORJ <= REJF);
   SINTHE=SQRT(1.0-CSQTHE); CALL UPHI(2,1);
   $AUSCALL($RAYLAUSA);
   GOTO :PNEWENERGY:;]]
  }
REPLACE {$RAYLEIGH-SCATTERING;} WITH {
   ;IF(IRAYLR(IRL).EQ.1) [
   $RANDOMSET RNNO37;
   IF (RNNO37.LE.(1.0-COHFAC)) [
   $AUSCALL($RAYLAUSB);
   NPold = NP;
   call egs_rayleigh_sampling(MEDIUM,E(NP),GLE,LGLE,COSTHE,SINTHE);
   CALL UPHI(2,1);
   $AUSCALL($RAYLAUSA);
   GOTO :PNEWENERGY:;]]
}

"Ali:photonuc, 2 blocks"
REPLACE {$PHOTONUC-CORRECTION;} WITH {
     ;IF(IPHOTONUCR(IRL).EQ.1) [$EVALUATE PHOTONUCFAC USING PHOTONUC(GLE);
    GMFP=GMFP*PHOTONUCFAC];}

REPLACE {$PHOTONUCLEAR;} WITH {
   ;IF(IPHOTONUCR(IRL).EQ.1) [
      $RANDOMSET RNNO39;
      IF (RNNO39.LE.(1.0-PHOTONUCFAC)) [
        $AUSCALL($PHOTONUCAUSB);
        call PHOTONUC;
        $AUSCALL($PHOTONUCAUSA);
        GOTO :PNEWENERGY:;
      ]
    ]
}

"DENSITY RATIO SCALING MACRO (TO OVER-RIDE DENSITY IN A PARTICULAR"
"REGION)  NOTE: THIS MACRO REPLACES SUBROUTINE RHOSET OF EGS3"

REPLACE {$SET-RHOF;} WITH {RHOF=RHOR(IRL)/RHO(MEDIUM);}  "DEFAULT"

"TEMPLATES FOR PERFORMING CHARGED PARTICLE TRANSPORT IN EM FIELD"
REPLACE {$SET-TUSTEP-EM-FIELD;} WITH {;}
REPLACE {$SET-USTEP-EM-FIELD;} WITH {;}
REPLACE {$VACUUM-ADD-WORK-EM-FIELD;} WITH {;}
REPLACE {$SET-ANGLES-EM-FIELD;} WITH {;}
REPLACE {$SET-TVSTEP-EM-FIELD;} WITH {;}
REPLACE {$ADD-WORK-EM-FIELD;} WITH {;}
REPLACE {$EMFIELD_INITIATE_SET_TUSTEP;} WITH {;}
REPLACE {;COMIN/EM/;} WITH {;}
REPLACE {$EMFIELD_PII;} WITH {;}
REPLACE{$EMFIELD_PI;}WITH{;}
REPLACE{$EM_FIELD_SS;}WITH{;}
REPLACE{$ADD_WORK_EM_FIELD;}WITH{;}
REPLACE{$EMFieldInVacuum;}WITH{;}
REPLACE{$EM_MACROS_ACTIVE}WITH{.false.}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"------------------------------------------------------------------"
"        EGS4/EGSnrc GEOMETRY MACROS: AN EXTENSION TO EGS MACROS   "
"------------------------------------------------------------------"

"   NOTE1: CYLNDR IS A NEW MACRO BY G.R.STEVENSON OF CERN"
"          (SEE HS-RP/TM/80-78, 25 NOV. 1980)"

"   NOTE2: CONE IS A NEW MACRO BY H.HIRAYAMA OF KEK. "
"          MACRO REPLACEMENT OF CERN VERSION SUBROUTINE CONE"
"          (SEE HS-RP/TM/81-30, 5 MAY 1981)"

"   NOTE3: SPHERE IS A NEW MACRO BY G.R.STEVENSON OF CERN"
"          (SEE HS-RP/TM/81-30, 5 MAY 1981)"

"   NOTE4: $PLAN2X AND $PLAN2P ARE TWO NEW MACROS BY W.R.NELSON."
"          $PLAN2P WAS FORMERLY CALLED $PLANE2 AND IS STILL THE"
"          SAME (CALLS TO $PLANE2 WILL AUTOMATICALLY DEFAULT TO"
"          TO $PLAN2P).  $PLAN2X, HOWEVER, WILL CORRECTLY HANDLE"
"          THE CASE OF TWO, NON-PARALLEL PLANES."

"------------------------------------------------------------------"
"        MACRO-ROUTINES FOR PLANE GEOMETRY  (SLAC VERSION)         "
"------------------------------------------------------------------"
;
PARAMETER $MXPLNS=100;     "MAX. NO. OF PLANES"

"PLADTA---COMMON BLOCK FOR $PLANE1 AND $PLANE2 MACROS"
REPLACE {;COMIN/PLADTA/;} WITH {
      ;COMMON/PLADTA/PCOORD(3,$MXPLNS),PNORM(3,$MXPLNS);
      $REAL PCOORD, PNORM;
}

"$PLANE1---MACRO REPLACEMENT FOR SUBROUTINE PLANE1"
REPLACE {$PLANE1(#,#,#,#);} WITH {
 UDOTA=PNORM(1,{P1})*U(NP)+PNORM(2,{P1})*
 V(NP)+PNORM(3,{P1})*W(NP); UDOTAP={P2}*UDOTA;
 IF(UDOTA.EQ.0.0)[{P3}=2;]ELSEIF(UDOTAP.LT.0.0)
 [{P3}=0;] ELSE [{P3}=1;{P4}=(PNORM(1,{P1})*
 (PCOORD(1,{P1})-X(NP))+ PNORM(2,{P1})*
 (PCOORD(2,{P1})-Y(NP))+PNORM(3,{P1})*
 (PCOORD(3,{P1})-Z(NP)))/UDOTA;]}
"NOTE:   EVERYWHERE $PLANE1 IS USED ONE MUST"
"        INCLUDE COMIN/PLADTA,STACK/"

"------------------------------------------------------------------"

"$PLANE2---MACRO REPLACEMENT FOR SUBROUTINE PLANE2"
"          NOTE: $PLANE2 HAS BEEN SUPERCEDED BY $PLAN2P (BELOW),"
"                WHICH IS AUTOMATICALLY TAKEN CARE OF BY THE"
"                FOLLOWING MACRO STATEMENT."
REPLACE {$PLANE2} WITH {$PLAN2P}

"------------------------------------------------------------------"

"$PLAN2P---MACRO REPLACEMENT FOR SUBROUTINE PLAN2P (OR $PLANE2)"
"          (I.E., TWO PARALLEL PLANES)"
REPLACE {$PLAN2P(#,#,#,#,#,#);} WITH {
  $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1)
 [ $CHGTR(TVAL,{P2});] ELSEIF(IHIT.EQ.0)
 [$PLANE1({P4},{P6},IHIT,TVAL);$CHGTR(TVAL,{P5});]}
"NOTE:   EVERYWHERE $PLAN2P ($PLANE2) IS USED ONE MUST"
"        INCLUDE COMIN/EPCONT,PLADTA,STACK/"

"------------------------------------------------------------------"

"$PLAN2X---MACRO REPLACEMENT FOR SUBROUTINE PLAN2X"
"          (I.E., TWO, NON-PARALLEL (CROSSING) PLANES)"
REPLACE {$PLAN2X(#,#,#,#,#,#);} WITH {
    $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1) [
   $CHGTR(TVAL,{P2});]   $PLANE1({P4},{P6},IHIT,TVAL);
   IF(IHIT.EQ.1) [$CHGTR(TVAL,{P5});]}
"NOTE:   EVERYWHERE $PLAN2X IS USED ONE MUST"
"        INCLUDE COMIN/EPCONT,PLADTA,STACK/"

"------------------------------------------------------------------"
"      MACRO-ROUTINE FOR CYLINRICAL GEOMETRY  (CERN VERSION)       "
"------------------------------------------------------------------"

PARAMETER $MXCYLS=75;      "MAX. NO. OF CYLINDERS"
PARAMETER $DELCYL=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"

"CYLDTA---COMMON BLOCK FOR $CYLNDR MACRO"
REPLACE {;COMIN/CYLDTA/;} WITH {
   ;COMMON/CYLDTA/CYRAD2($MXCYLS);
   $REAL CYRAD2;
}

"$CYLNDR---MACRO REPLACEMENT FOR SUB CYLNDR GRS VERSION 14 11 80"
REPLACE {$CYLNDR(#,#,#,#);} WITH {
   {P3}=1;{P4}=0.0;ACYL=SQRT(U(NP)*U(NP)+V(NP)*V(NP));
   IF(ACYL.EQ.0.0)[{P3}=0;]  ELSE [
   BCYL=(X(NP)*U(NP)+Y(NP)*V(NP))/ACYL;CCYL=X(NP)*X(NP)+Y(NP)*Y(NP)
   -CYRAD2({P1});  ARGCY=BCYL*BCYL-CCYL;
   IF(ARGCY.LT.0.0) [{P3}=0;]   ELSE [
   IF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.0.AND.BCYL.GE.0.0)[{P3}=0;]
   ELSEIF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.1.AND.BCYL.LT.0.0)[
   {P4}=-2.0*BCYL/ACYL;]
   ELSE [ IF({P2}.EQ.1.AND.CCYL.GE.0.0)[{P3}=1;{P4}=$DELCYL;]
   ELSEIF({P2}.EQ.0.AND.CCYL.LE.0.0)[{P3}=1;{P4}=$DELCYL;]
   ELSE  [  ROOTCY=SQRT(ARGCY); IF(CCYL.LT.0.0)
   [{P4}=(-BCYL+ROOTCY)/ACYL;]
   ELSEIF(BCYL.LT.0.0) [{P4}=(-BCYL-ROOTCY)/ACYL;]
   ELSE [{P3}=0;]]]]]}
"NOTE:   EVERYWHERE $CYLNDR IS USED ONE MUST"
"         INCLUDE COMIN/CYLDTA,STACK/"

"$CYL2--MACRO EQUIVALENT FOR CYLNDR OF $PLANE2  GRS 17.11.80"
REPLACE {$CYL2(#,#,#,#);} WITH {
 $CYLNDR({P1},0,IHIT,TCYL);IF(IHIT.EQ.1)[
 $CHGTR(TCYL,{P2});]ELSE[$CYLNDR({P3},1,IHIT,TCYL);
 IF(IHIT.EQ.1)[ $CHGTR(TCYL,{P4});]]}
"NOTE:   EVERYWHERE $CYL2 IS USED ONE MUST
"         INCLUDE COMIN/CYLDTA,STACK/"

;  "---------- BUFFER FLUSH SEMICOLON ----------"

"------------------------------------------------------------------"
"     MACRO-ROUTINE FOR CERN CONICAL GEOMETRY  (SLAC VERSION)      "
"------------------------------------------------------------------"

PARAMETER $MXCONES=75;     "MAXIMUM NUMBER OF CONES"
PARAMETER $DELCON=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"

"CONDTA---COMMON BLOCK FOR $CONE MACRO"
REPLACE {;COMIN/CONDTA/;} WITH {
   ;COMMON/CONDTA/COTAL2($MXCONES),SMALLL($MXCONES);
   $REAL COTAL2, SMALLL;
}

"$CONE---MACRO REPLACEMENT FOR CERN VERSION SUBROUTINE CONE"
REPLACE {$CONE(#,#,#,#);} WITH {
   {P3}=0;ITWOPR=0;CPCON=COTAL2({P1});SGNCON=SIGN(1.0,CPCON);
   CPCON=ABS(CPCON);ZNP=SGNCON*(Z(NP)-SMALLL({P1}));
   WNP=SGNCON*W(NP);CPCON1=1.0+CPCON;
   CPCON2=SQRT(CPCON1);DCON1=X(NP)*X(NP)+Y(NP)*Y(NP);
   DCON2=SQRT(DCON1); IF((ZNP.GE.0.0).OR.(WNP.GE.0.0)) [
   ACON=(U(NP)*U(NP)+V(NP)*V(NP))*CPCON-WNP*WNP;
   BCON1=(X(NP)*U(NP)+Y(NP)*V(NP))*CPCON;BCON=BCON1-ZNP*WNP;
   CCON=DCON1*CPCON-ZNP*ZNP;
   IF(ACON.EQ.0.0)[IF(BCON.NE.0.0)
   [IF(ABS(CCON).LT.$DELCON.AND.ZNP.GE.0.0)[
   IF(({P2}.EQ.1.AND.BCON.GE.0.0).OR.({P2}.EQ.0.AND.BCON.LE.0.0))[
   TCON1=-CCON/(2*BCON);IF(TCON1.GE.0.0)[IF((ZNP+TCON1*WNP).GE.0.0)
   [{P4}=TCON1;{P3}=1;]]]]]
   ELSE[TCON1=CPCON2*ZNP*SIGN(1.0,-WNP);
   IF(TCON1.GE.0.0)[{P4}=TCON1;{P3}=1;]]]
   ELSEIF((ABS(CCON).LT.$DELCON).AND.(ZNP.GE.0.0))
   [BPRIM=BCON1-WNP*DCON2;
   IF({P2}.EQ.1.AND.BPRIM.LT.0.0)[TCON1=-2*BCON/ACON;
   IF(TCON1.GE.0.0) [{P4}=TCON1;{P3}=1;]]]
   ELSEIF({P2}.EQ.1.AND.CCON.GT.0.0) [{P4}=$DELCON;{P3}=1;]
   ELSEIF({P2}.EQ.0.AND.CCON.LT.0.0.AND.ZNP.GE.0.0)
   [{P4}=$DELCON;{P3}=1;] ELSE[CCON1=BCON*BCON-ACON*CCON;
   IF(CCON1.GE.0.0)[ROOT=SQRT(CCON1);
   IF(BCON.GT.0.0)[TCON11=-(BCON+ROOT)/ACON;]
   ELSE[TCON11=-CCON/(BCON-ROOT);]
   IF(BCON.LT.0.0)[TCON22=-(BCON-ROOT)/ACON;]
   ELSE[TCON22=-CCON/(BCON+ROOT);]
   IF((TCON11.GE.0.0).OR.(TCON22.GE.0.0))[
   IF(TCON11.LT.0.0)[TCON1=TCON22;]
   ELSE[IF(TCON22.LT.0.0)[TCON1=TCON11;] ELSE[ITWOPR=1;
   TCON1=min(TCON11,TCON22);TCON2=max(TCON11,TCON22);]]
   IF((ZNP+TCON1*WNP).GE.0.0)[{P4}=TCON1;{P3}=1;]
   ELSEIF((ITWOPR.EQ.1).AND.((ZNP+TCON2*WNP).GE.0.0))
   [{P4}=TCON2;{P3}=1;]]]]]}
"NOTE:   EVERYWHERE $CONE IS USED ONE MUST
"         INCLUDE COMIN/CONDTA,STACK/"

"$CON2--MACRO EQUIVALENT FOR CONE OF $PLANE2            "
REPLACE {$CON2(#,#,#,#);} WITH {
   $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
   $CHGTR(TCON,{P2});]ELSE[$CONE({P3},1,IHIT,TCON);IF(IHIT.EQ.1)[
   $CHGTR(TCON,{P4});]]}

"$CON21--MACRO EQUIVALENT FOR CONE OF $PLANE2 (IN THE CASE  "
"OF OUTSIDE TWO CONE SURFACE)                               "
REPLACE {$CON21(#,#,#,#);} WITH {
   $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
   $CHGTR(TCON,{P2});]ELSE[$CONE({P3},0,IHIT,TCON);IF(IHIT.EQ.1)[
   $CHGTR(TCON,{P4});]]}

;  "---------- BUFFER FLUSH SEMICOLON ----------"

"------------------------------------------------------------------"
"        MACRO-ROUTINE FOR SPHERICAL GEOMETRY  (CERN VERSION)      "
"------------------------------------------------------------------"

PARAMETER $MXSPHE=75;      "MAX. NO. OF SPHERES"
PARAMETER $DELSPH=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"

"SPHDTA------COMMON BLOCK FOR $SPHERE MACRO"
REPLACE {;COMIN/SPHDTA/;} WITH {
   ;COMMON/SPHDTA/SPRAD2($MXSPHE);
   $REAL SPRAD2;
}

"$SPHERE---MACRO REPLACEMENT FOR SUB SPHERE GRS VERSION 08 12 80"
REPLACE {$SPHERE(#,#,#,#);} WITH {
   {P3}=1;{P4}=0.0;ASPH=1.0;
   BSPH=(X(NP)*U(NP)+Y(NP)*V(NP)+Z(NP)*W(NP))/ASPH;CSPH=X(NP)*X(NP)
   +Y(NP)*Y(NP)+Z(NP)*Z(NP)  -SPRAD2({P1});  ARGSP=BSPH*BSPH-CSPH;
   IF(ARGSP.LT.0.0) [{P3}=0;]   ELSE [
   IF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.0.AND.BSPH.GE.0.0)[{P3}=0;]
   ELSEIF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.1.AND.BSPH.LT.0.0)[
   {P4}=-2.0*BSPH/ASPH;]
   ELSE [ IF({P2}.EQ.1.AND.CSPH.GE.0.0)[{P3}=1;{P4}=$DELSPH;]
   ELSEIF({P2}.EQ.0.AND.CSPH.LE.0.0)[{P3}=1;{P4}=$DELSPH;]
   ELSE [ROOTSP=SQRT(ARGSP); IF(CSPH.LT.0.0)
   [{P4}=(-BSPH+ROOTSP)/ASPH;] ELSEIF(BSPH.LT.0.0)
   [{P4}=(-BSPH-ROOTSP)/ASPH;] ELSE [{P3}=0;]]]]}
"NOTE:   EVERYWHERE $SPHERE IS USED ONE MUST
"         INCLUDE COMIN/SPHDTA,STACK/"

"$SPH2--MACRO EQUIVALENT FOR SPHERE OF $PLANE2  GRS 08.12.80"
REPLACE {$SPH2(#,#,#,#);} WITH {
 $SPHERE({P1},0,IHIT,TSPH);IF(IHIT.EQ.1)[
 $CHGTR(TSPH,{P2});]ELSE[$SPHERE({P3},1,IHIT,TSPH);
 IF(IHIT.EQ.1)[ $CHGTR(TSPH,{P4});]]}
"NOTE:   EVERYWHERE $SPH2 IS USED ONE MUST
"         INCLUDE COMIN/SPHDTA,STACK/"

;  "---------- BUFFER FLUSH SEMICOLON ----------"

"------------------------------------------------------------------"
"        MACRO-ROUTINE FOR CHANGING REGIONS  (SLAC VERSION)        "
"------------------------------------------------------------------"

"$CHGTR---MACRO REPLACEMENT FOR SUBROUTINE CHGTR"
REPLACE {$CHGTR(#,#);} WITH {
    ;IF({P1}.LE.USTEP) [USTEP={P1}; IRNEW={P2};]}
"NOTE:   EVERYWHERE $CHGTR IS USED ONE MUST
"         INCLUDE COMIN/EPCONT/"

"------------------------------------------------------------------"
"     MACRO-ROUTINE TO OBTAIN FINAL COORDINATES (SLAC VERSION)     "
"------------------------------------------------------------------"

"$FINVAL---MACRO REPLACEMENT FOR SUBROUTINE FINVAL"
REPLACE {$FINVAL(#,#,#,#);} WITH {
   {P2}=X(NP)+{P1}*U(NP); {P3}=Y(NP)+{P1}*V(NP);
   {P4}=Z(NP)+{P1}*W(NP);}
"NOTE:   EVERYWHERE $FINVAL IS USED ONE MUST
"         INCLUDE COMIN/STACK/"

"------------------------------------------------------------------"
"                 END OF GEMOETRY MACRO EXTENSION                  "
"------------------------------------------------------------------"

"******************************************************************"
"                                                                  "
"                    NRC EXTENSIONS                                "
"                                                                  "
"******************************************************************"

; "BUFFER FLUSH"
"--------------------------------------------------------------"
"                                                              "
"           PHOTOELECTRON ANGLE SELECTION                      "
"           =============================                      "
"                                                              "
"--------------------------------------------------------------"
"This macro can be used to select the photoelectron direction  "

REPLACE {$SELECT-PHOTOELECTRON-DIRECTION;} WITH {
"        ================================"
;IF(IPHTER(IR(NP)).EQ.1)[
  EELEC=E(NP);
  IF(EELEC.GT.ECUT(IR(NP)))[
    BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC;
    GAMMA=EELEC/RM;
    ALPHA=0.5*GAMMA-0.5+1./GAMMA;
    RATIO=BETA/ALPHA;
    LOOP[
      $RANDOMSET RNPHT;RNPHT=2.*RNPHT-1.;
      IF(RATIO.LE.0.2)[
        FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT);
        IF( gamma < 100 ) [
            COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA);
        ]
        ELSE [
            IF( fkappa > 0 ) [
                costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gamma-1)**3);
            ]
            ELSE [ COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA); ]
        ]
        "XI=1./(1.-BETA*COSTHE); <-- this numerically problematic "
        "                            at high energies, IK"
        xi = (1+beta*fkappa)*gamma*gamma;
      ]
      ELSE[
        XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO))-1.));
        COSTHE=(1.-1./XI)/BETA;
      ]
      SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE));
      $RANDOMSET RNPHT2;
      ]WHILE(RNPHT2.GT.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA);
    SINTHE=SQRT(SINTH2);
    CALL UPHI(2,1);]]
}

; "BUFFER FLUSH"

"--------------------------------------------------------------"
"                                                              "
"           TSTEP RECURSION IN ELECTR                          "
"           =========================                          "
"                                                              "
"--------------------------------------------------------------"
"This macro can be used to control TSTEP recursion in ELECTR   "

REPLACE {$USER_CONTROLS_TSTEP_RECURSION;} WITH {;}

; "BUFFER FLUSH"

%C80
"------------------------------------------------------------------"
"  BREMSSTRAHLUNG ANGLE SELECTION MACROS                           "
"------------------------------------------------------------------"


"These macros are explained in NRCC REPORT #PIRS0203"
"by Bielajew, Mohan and Chui                        "

"Macro to initialize data for bremsstrahlung production               "
"The quantity ZBRANG is ( (1/111)*Zeff**(1/3) )**2                    "
"where Zeff is defined in equation (7) OF PIRS0203                    "
"This macro goes in SUBROUTINE HATCH                                  "
"                                                                     "
REPLACE {$INITIALIZE-BREMS-ANGLE;} WITH {
; IF(IBRDST.EQ.1)[
        DO IM=1,NMED[
            ZBRANG(IM)=0.0;PZNORM=0.0;
            DO IE=1,NNE(IM)[
                ZBRANG(IM)=
                  ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
                PZNORM=PZNORM+PZ(IM,IE);
                ]
                ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
                LZBRANG(IM)=-log(ZBRANG(IM));
            ]
        ]
}
;

;

" Following is associated with the selection of bremsstrahlung photon"
" angle.  This has been implemented directly into the BREMS subroutine"
" and changed slightly. Nonetheless, this macro is still used."

"This is the function G(X) of PIRS0203               "
"The result is returned in {P1} as a function of {P2}"
"i.e. {P1}=G({P2}) where {P2}=X                      "
"                                                    "
REPLACE {$SET-BREM-REJECTION-FUNCTION(#,#);} WITH {
; Y2TST1=(1.+{P2})**2;
{P1}= (4.+LOG(RJARG3+ZTARG/Y2TST1))*(4.*ESEDEI*{P2}/Y2TST1-RJARG1)+RJARG2;
}
;

"------------------------------------------------------------------"
"  PAIR ANGLE SELECTION MACROS                                     "
"------------------------------------------------------------------"

"These macros are explained in NRCC REPORT # PIRS0287 by Bielajew     "

;
"Macro to initialize data for PAIR PRODUCTION                         "
"THE QUANTITY ZBRANG IS ( (1/111)*Zeff**(1/3) )**2                    "
"WHERE Zeff IS DEFINED IN EQUATION (7) OF PIRS0287                    "
"THIS MACRO GOES IN SUBROUTINE HATCH                                  "
"THIS MACRO IS IDENTICAL TO THE $INITIALIZE-BREMS-ANGLE DEFINED ABOVE "
"                                                                     "
REPLACE {$INITIALIZE-PAIR-ANGLE;} WITH {
;    IF(IPRDST.GT.0)[
        DO IM=1,NMED[
            ZBRANG(IM)=0.0;PZNORM=0.0;
            DO IE=1,NNE(IM)[
                ZBRANG(IM)=
                  ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
                PZNORM=PZNORM+PZ(IM,IE);
                ]
                ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
            ]
        ]
}
;
"THRESHOLD BELOW WHICH ONLY LOWEST ORDER ANGULAR DISTRIBUTION OF THE  "
"PAIR ANGLE IS EMPLOYED. SCALE IS ENERGY (MeV).                       "
"USERS MAY OVERRIDE THIS WITH A HIGHER VALUE BUT A LOWER VALUE WILL   "
"CAUSE NON-PHYSICAL SAMPLING                                          "
"                                                                     "
REPLACE {$BHPAIR} WITH {4.14}
;
"THIS MACRO ENABLES VERY SMALL ANGLE SAMPLING TO BE     "
"ACCUMULATED. THE LIMIT OF 1.0E-10 BREAKS DOWN AROUND   "
"50 GEV OR SO (THETA=RM/E, FOR BOTH PAIR AND BREM).     "
"THIS MACRO REPLACES CODE IN UPHI AND IN THE PRESTA     "
"MACROS FOR THE LATERAL CORRELATION PART $PRESTA-LCDV.  "
;
REPLACE {(SINPS2.LT.1.0E-10)} WITH {(SINPS2.LT.1.0E-20)}
;
"THE FOLLOWING REPLACES THE EGS4 DEFAULT $SET-PAIR-ANGLE MACRO    "
"IT'S USE REQUIRES AN ASSOCIATE MACRO $SET-PAIR-REJECTION-FUNCTION"
"DEFINED BELOW                                                    "
"                                                                 "
"USAGE: IPRDST=0 => EGS4 DEFAULT ANGLE SELECTION                  "
"       IPRDST=1 => LOWEST ORDER ANGULAR DISTRIBUTION             "
"                                                                 "
"              d(Probability)            sin(theta)               "
"              -------------- = -------------------------------   "
"                 d(theta)      2*P*[E_total - P*cos(theta)]**2   "
"                                                                 "
"       IPRDST=2 => MOTZ, OLSEN AND KOCH (1969) EQ. 3D-2003       "
"                   IF IPRDST IS NON-ZERO AND E_PHOTON < $BHPAIR  "
"                   THE IPRDST=1 DISTRIBUTION IS USED             "
"                                                                 "
REPLACE {$SET-PAIR-ANGLE;} WITH {;
    IF( iprdst > 0 ) [
        IF( iprdst = 4 ) [
            $RANDOMSET rtest;
            "gbeta = (1-rmt2/eig)**8;"
            gbeta = PESE1/(PESE1+10);
            IF( rtest < gbeta ) [ iprdst_use = 1; ]
            ELSE [ iprdst_use = 4; ]
        ]
        ELSEIF ( iprdst = 2 & eig < $BHPAIR ) [ iprdst_use = 1; ]
        ELSE [ iprdst_use = iprdst; ]
        DO ichrg = 1,2 [
            IF(ICHRG.EQ.1)[ESE=PESE1;]ELSE[
                ESE=ESE2;
                IF( iprdst = 4 ) [
                    gbeta = ESE/(ESE+10);
                    $RANDOMSET rtest;
                    IF( rtest < gbeta ) [ iprdst_use = 1; ]
                    ELSE [ iprdst_use = 4; ]
                ]
            ]
            IF( iprdst_use = 1 ) [
                PSE=SQRT(MAX(0.0,(ESE-RM)*(ESE+RM)));
                $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
                SINTHE=RM*SQRT((1.0-COSTHE)*(1.0+COSTHE))/(PSE*COSTHE+ESE);
                COSTHE=(ESE*COSTHE+PSE)/(PSE*COSTHE+ESE);
            ]
            ELSE IF( iprdst_use = 2 ) [
                "ZBRANG=( (1/111)*Zeff**(1/3) )**2"
                ZTARG=ZBRANG(MEDIUM);
                "TTEIG=TOTAL INITIAL PHOTON ENERGY IN ELECTRON REST MASS UNITS"
                TTEIG=EIG/RM;
                "TTESE=TOTAL FINAL ELECTRON ENERGY IN ELECTRON REST MASS UNITS"
                TTESE=ESE/RM;
                "TTPSE=TOTAL FINAL ELECTRON MOMENTUM IN rm UNITS"
                TTPSE=SQRT((TTESE-1.0)*(TTESE+1.0));
                "THIS IS THE RATIO (r IN PIRS0287)"
                ESEDEI=TTESE/(TTEIG-TTESE);
                ESEDER=1.0/ESEDEI;
                "DETERMINE THE NORMALIZATION "
                XIMIN=1.0/(1.0+(3.141593*TTESE)**2);
                $SET-PAIR-REJECTION-FUNCTION(REJMIN,XIMIN);
                YA=(2.0/TTEIG)**2;
                XITRY=MAX(0.01,MAX(XIMIN,MIN(0.5,SQRT(YA/ZTARG))));
                GALPHA=1.0+0.25*LOG(YA+ZTARG*XITRY**2);
                GBETA=0.5*ZTARG*XITRY/(YA+ZTARG*XITRY**2);
                GALPHA=GALPHA-GBETA*(XITRY-0.5);
                XIMID=GALPHA/(3.0*GBETA);
                IF(GALPHA.GE.0.0)[
                    XIMID=0.5-XIMID+SQRT(XIMID**2+0.25);
                ]
                ELSE[
                    XIMID=0.5-XIMID-SQRT(XIMID**2+0.25);
                ]
                XIMID=MAX(0.01,MAX(XIMIN,MIN(0.5,XIMID)));
                $SET-PAIR-REJECTION-FUNCTION(REJMID,XIMID);
                "ESTIMATE MAXIMUM OF THE REJECTION FUNCTION"
                "FOR LATER USE BY THE REJECTION TECHNIQUE  "
                REJTOP=1.02*MAX(REJMIN,REJMID);
                LOOP[
                    $RANDOMSET XITST;
                    $SET-PAIR-REJECTION-FUNCTION(REJTST,XITST);
                    $RANDOMSET RTEST;
                    "CONVERT THE SUCCESSFUL CANDIDATE XITST TO AN ANGLE"
                    THETA=SQRT(1.0/XITST-1.0)/TTESE;
                    "LOOP UNTIL REJECTION TECHNIQUE ACCEPTS XITST"
                    REJTST_on_REJTOP   = REJTST/REJTOP;
                ]UNTIL((RTEST <= REJTST_on_REJTOP) & (THETA < PI) );
                SINTHE=SIN(THETA);COSTHE=COS(THETA);
            ]
            ELSE IF( iprdst_use = 3 ) [
                $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
                sinthe=(1-costhe)*(1+costhe);
                IF( sinthe > 0 ) [ sinthe = sqrt(sinthe); ] ELSE [ sinthe = 0; ]
            ]
            ELSE [
                "PSE=SQRT(MAX(1e-10,(ESE-RM)*(ESE+RM)));"
                "$RANDOMSET costhe;"
                "costhe=(ese-(ese+pse)*exp(-2*costhe*log((ese+pse)/rm)))/pse;"
                $RANDOMSET costhe;
                costhe=1-2*sqrt(costhe);
                sinthe=(1-costhe)*(1+costhe);
                IF( sinthe > 0 ) [ sinthe=sqrt(sinthe); ] ELSE [ sinthe=0; ]
            ]
            IF( ichrg = 1 ) [CALL UPHI(2,1);]
            ELSE [ sinthe=-sinthe; NP=NP+1; CALL UPHI(3,2); ]
        ]
        iq(np) = iq2; iq(np-1) = iq1; return;
    ]
    ELSE[
        THETA=0; "THETA=RM/EIG; "
    ]
}
;
"THIS IS THE FUNCTION d[G(XI)]/(d XI) OF PIRS0287    "
"THE RESULT IS RETURNED IN {P1} AS A FUNCTION OF {P2}"
"I.E. {P1}=G({P2}) WHERE {P2}=XI                     "
"                                                    "
REPLACE {$SET-PAIR-REJECTION-FUNCTION(#,#);} WITH {
; {P1} = 2.0+3.0*(ESEDEI+ESEDER) -
        4.00*(ESEDEI+ESEDER+1.0-4.0*({P2}-0.5)**2)*(
            1.0+0.25*LOG(
                ((1.0+ESEDER)*(1.0+ESEDEI)/(2.*TTEIG))**2+ZTARG*{P2}**2
                )
            )
        ;
}
;

REPLACE {$SELECT-LOW-ENERGY-PAIR-PRODICTION;} WITH
{
  $RANDOMSET RNNO30; $RANDOMSET rnno34;
  PESE2 = PRM + 0.5*RNNO30*(PEIG-2*PRM); PESE1 = PEIG - PESE2;
  IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]
}
" IK introduced this macro because uniform energy distribution"
" is probably a better approximation than a zero energy 'electron'"
" for low energy pair production"

;

"THIS MACRO EXCHANGES TWO POSITIONS ON THE STACK"
"NB: LATCH IS A NON-STANDARD STACK VARIABLE     "
"    REMOVE IT IF IT CAUSES PROBLEMS            "
"                                               "
REPLACE {$EXCHANGE-STACK(#,#);} WITH {
;
FDUMMY = U({P2});     U({P2})     = U({P1});     U({P1})     = FDUMMY;
FDUMMY = V({P2});     V({P2})     = V({P1});     V({P1})     = FDUMMY;
FDUMMY = W({P2});     W({P2})     = W({P1});     W({P1})     = FDUMMY;
FDUMMY = E({P2});     E({P2})     = E({P1});     E({P1})     = FDUMMY;
FDUMMY = WT({P2});    WT({P2})    = WT({P1});    WT({P1})    = FDUMMY;
IDUMMY = IQ({P2});    IQ({P2})    = IQ({P1});    IQ({P1})    = IDUMMY;
"LATCH IS NOW STANDARD"
IDUMMY = LATCH({P2}); LATCH({P2}) = LATCH({P1}); LATCH({P1}) = IDUMMY;
}
;

REPLACE {;OUTPUT61#;#;} WITH {
"       ==============="
;{SETR A=@LG}
WRITE(6,{COPY A}){P1};WRITE(1,{COPY A}){P1};{COPY A}FORMAT{P2};}
;

" The following macro provides a second order evaluation of the   "
" stopping power. The parameter is half of the initial estimate of"
" the energy loss fraction. IK Oct 97                             "
REPLACE {$RE-EVALUATE-DEDX(#);} WITH
{
;
  elktmp = elke + Log(1 - {P1});
  $SET INTERVAL elktmp,eke;
  lelktmp = max(1,lelktmp);
  IF(lelec < 0)[$EVALUATE dedxmid USING ededx(elktmp);]
  ELSE         [$EVALUATE dedxmid USING pdedx(elktmp);]
  dedx = rhof*dedxmid*(1+0.17408298*({P1}/(1-{P1})/(eke+PRM))**2);
                   "0.17408298 is 2/3*m**2"
  {P1} = 2*{P1};
}

; "BUFFER FLUSH"


%E    "egsnrc.macros"
"******************************************************************"
"                                                                  "
"       transport algorithm related stuff                          "
"                                                                  "
"******************************************************************"

"Macros to denote the various transport algorithms"
"These numbers just have to be distinct"
"Note that the distributed version of EGSnrc does not include the VMC option"
REPLACE {$PRESTA-II} WITH {0}
REPLACE {$PRESTA--I} WITH {1}
REPLACE {$VMC}       WITH {2}

REPLACE {$CALL-USER-ELECTRON} WITH {;}

;
REPLACE {$MSCAT-DATAFILE} WITH {i_mscat}
  "Fortran unit number used to read in new MS"
;
REPLACE {$RANDOMIZE-TUSTEP} WITH {.false.}
  "Switches tustep randomization off"
;
REPLACE {$SKIN-DEPTH-FOR-BCA} WITH {3}
;
REPLACE {$PRESTA-DEBUG} WITH {.false.}
;
REPLACE {$EXACT-BCA-XIMAX} WITH {0.5}
;
REPLACE {$INEXACT-BCA-XIMAX} WITH {0.5} "this is not realy neccessary, "
                                        "it remained from Alex's coding"
;
REPLACE {$MAX-ELOSS} WITH {0.25}
;
REPLACE {$SUBSTEP-ELOSS-EVALUATION} WITH {.false.}
;
REPLACE {$MAX-SMAX} WITH {1e10}
;
REPLACE {$GLOBAL-ECUT} WITH {0.}
;
REPLACE {$GLOBAL-PCUT} WITH {0.}
;
REPLACE {$IBRDST-DEFAULT} WITH {1}
;
REPLACE {$IBR-NIST-DEFAULT} WITH {0}
;
REPLACE {$PAIR-NRC-DEFAULT} WITH {0}
;
REPLACE {$TRIPLET-DEFAULT} WITH {0}
;
REPLACE {$IPRDST-DEFAULT} WITH {1}
;
REPLACE {$IBCMP-DEFAULT} WITH {3} "set to norej"
;
REPLACE {$IEDGFL-DEFAULT} WITH {1}
;
REPLACE {$IPHTER-DEFAULT} WITH {1}
;
REPLACE {$TRANSPORT-ALGORITHM-DEFAULT} WITH {$PRESTA-II}
;
REPLACE {$BCA-ALGORITHM-DEFAULT} WITH {0}
;
REPLACE {$EXACT-BCA-DEFAULT} WITH {.true.}
;
REPLACE {$SPIN-EFFECTS-DEFAULT} WITH {.true.}
;
REPLACE {$IRAYLR-DEFAULT} WITH {1}
;
REPLACE {$AP-DEFAULT} WITH {-1}
;
REPLACE {$UP-DEFAULT} WITH {-1}
;
REPLACE {$XSEC-DEFAULT} WITH {0}
;
REPLACE {$XDATA-DEFAULT} WITH {'xcom'}
;
REPLACE {$COMP-XDATA-DEFAULT} WITH {'default'}
;
"EADL relaxation is now the default"
REPLACE {$EADL-RELAX-DEFAULT} WITH {.true.}
;
"Sabbatucci and Salvat PE xsections not the default yet"
REPLACE {$MCDF-PE-DEFAULT} WITH {.false.}
;
"Ali:photonuc, 2 lines"
REPLACE {$IPHOTONUCR-DEFAULT} WITH {0}
;
REPLACE {$PHOTONUC-XDATA-DEFAULT} WITH {'default'}
;
"EMH:emf, 7 lines"
REPLACE {$ExDEF} WITH {0}
;
REPLACE {$EyDEF} WITH {0}
;
REPLACE {$EzDEF} WITH {0}
;
REPLACE {$BxDEF} WITH {0}
;
REPLACE {$ByDEF} WITH {0}
;
REPLACE {$BzDEF} WITH {0}
;
REPLACE {$EMLMTDEF} WITH {0.02}
;

            "This macro sets the minimum step size for a condensed"
            "history (CH) step. When the exact BCA is used, the minimum"
            "CH step is determined by efficiency considerations only"
            "At about 3 elastic MFP's single scattering becomes more"
            "efficient than CH and so the algorithm switches off CH"
            "If one of the various inexact BCA's is invoked, this macro"
            "provides a simple way to include more sophisticated"
            "decisions about the maximum acceptable approximated CH step"

"The parameters passed to the macro in ELECTR are  eke and elke "

REPLACE {$SET-SKINDEPTH(#,#);} WITH
"        =================                  "
{
   $CALCULATE-ELASTIC-SCATTERING-MFP(ssmfp,{P1},{P2});
   skindepth = skindepth_for_bca*ssmfp;
}
;

"This macro calculates the elastic scattering MFP"
"If spin_effects is .false., the screened Rutherford cross section"
"is used, else the the elastic MFP is based on PWA cross sections"

REPLACE {$CALCULATE-ELASTIC-SCATTERING-MFP(#,#,#);} WITH
"        =======================================           "
{
    blccl = rhof*blcc(medium);
    xccl  = rhof*xcc(medium);
    p2 = {P2}*({P2}+rmt2); beta2 = p2/(p2 + rmsq);
    IF ( spin_effects ) [
      IF(lelec < 0) [ $EVALUATE etap USING etae_ms({P3}); ]
      ELSE          [ $EVALUATE etap USING etap_ms({P3}); ]
      $EVALUATE ms_corr USING blcce({P3});
      blccl = blccl/etap/(1+0.25*etap*xccl/blccl/p2)*ms_corr;
    ]
    {P1}=beta2/blccl;
}
;

REPLACE {$SINGLE-SCATTERING(#);} WITH
"        ======================                     "
{
    $SET-SCREENING-ANGLE({P1});
    call sscat(chia2,costhe,sinthe);
}
;

"The following macro will allow the use of better single scattering"
"cross sections (PWA) and/or to take into account double counting  "
"of the contribution of atomic electrons to the scattering power   "

REPLACE {$SET-SCREENING-ANGLE(#);} WITH
"        ========================                   "
{
    chia2   = xcc(medium)/(4*{P1}*({P1} + rmt2)*blcc(medium));
}
;

REPLACE {$HARD-SCATTERING;} WITH {;}
;

REPLACE {$TURN_OFF_SCATTERING} WITH {;}
;
"If the above is redefined in a user code or uncommented here                 "
"REPLACE {$TURN_OFF_SCATTERING} WITH {;cost = 1.000; sint = 0.000; return;}   "
"this will turn off all single and multiple scattering                        "
"DR April 2012   see corresponding 2 additions to egsnrc,mortran in           "
"                subroutines sscat and mscat

%E "egsnrc.macros"

REPLACE {$CALL-HOWFAR-IN-ELECTR;} WITH {;
  IF(callhowfar | wt(np) <= 0) [ call howfar; ]
};

REPLACE {$CALL-HOWFAR-IN-PHOTON;} WITH {;
  IF( ustep > dnear(np) | wt(np) <= 0 ) [ call howfar; ]
};

REPLACE {$CALL-HOWNEAR(#);} WITH
{
    OUTPUT 35; "35 in decimal is ascii code for the pound sign"
    (
        ' '/
        ' '/
        ' ***************************************************************'/
        ' ***************************************************************'/
        ' '/
        ' PRESTA-II is aborting execution because you have not defined   '/
        ' the HOWNEAR macro for your geometry.                           '/
        ' '/
        ' You MUST either do so or employ a limited form of PRESTA-II    '/
        ' which does not attempt the refined boundary crossing or lateral'/
        ' correlation features of the algorithm.                         '/
        ' '/
        ' If you include the following macro in your usercode:           '/
        ' '/
        ' REPLACE {$CALL-HOWNEAR(',a,');} WITH {;}                       '/
        ' '/
        ' you can choose between single scattering mode (very slow) and  '/
        ' standard EGS4 mode (no PRESTA enhancments) by the appropriate  '/
        ' choice of the parameters in your input file (see the PRESTA-II '/
        ' manual)                                                        '/
        ' '/
        ' ***************************************************************'/
        ' ***************************************************************'/
        ' '/
        ' '/
    );
    stop;
}

"For compability with user codes with PRESTA-I implemented"
REPLACE {$PRESTA-INPUT-SUMMARY;} WITH {;}
REPLACE {$PRESTA-INPUTS;}        WITH {;}

"If you want to read P-II inputs using the get_input() routine by "
"A. Merovitz and D.W.O.R. you need to either place the following  "
"three macros at the top of your user code, or after the default"
"definitions given below"

;

REPLACE {$USE-GET-INPUTS} WITH {.true.} "To not use get_input replace this "
                                        "with .false.                      "

"The following are the ones used by default"


REPLACE {$USE-GET-INPUTS} WITH {.false.}


;
%E    "egsnrc.macros"

"Macro for azimuthal angle selection
"using a sampling within a box method
"Choose a point randomly within a box such that
"-1 <= x <= 1 and 0 <= y < = 1
"Reject the set if it lies without the inscribed unit semicircle centered
"at (x,y) = (0,0)
"once out of the loop, use the trigonimetric relations (TeX notation)
"\cos 2\phi = (x^2 - y^2)/(x^2 + y^2)
"\sin 2\phi = 2xy/(x^2 + y^2)
REPLACE {$SELECT-AZIMUTHAL-ANGLE(#,#);} WITH
{
;
LOOP
[
    $RANDOMSET xphi;
    xphi  = 2*xphi - 1;
    xphi2 = xphi*xphi;
    $RANDOMSET yphi;
    yphi2  = yphi*yphi;
    rhophi2 = xphi2 + yphi2;
]WHILE(rhophi2 > 1);
rhophi2 = 1/rhophi2;
{P1}  = (xphi2 - yphi2)*rhophi2;
{P2}  = 2*xphi*yphi*rhophi2;
}
;

REPLACE {$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;} WITH {;
  $REAL xphi,xphi2,yphi,yphi2,rhophi2;
};

%E     "egsnrc.macros"
"************************************************************************"
"                                                                        "
"                 Definitions of local variables                         "
"                                                                        "
"************************************************************************"

REPLACE {$DEFINE-LOCAL-VARIABLES-ANNIH;} WITH
{;
"Local variables in order of appearance"
$ENERGY PRECISION
      PAVIP,    "precise total energy in the laboratory frame"
      PESG1,    "precise energy of 1st annihilation photon"
      PESG2;    "precise energy of 2nd annihilation photon"
$REAL AVIP,     "total energy in the laboratory frame"
      A,        "total energy in units of the electron's rest energy"
      G,T,P,    "energy, kinetic energy and momentum in units of RM"
      POT,      "P/T"
      EP0,      "minimum fractional energy"
      WSAMP,    "to avoid un-necessary calc. of Log((1-ep0)/ep0)"
      RNNO01,   "random numbers"
      RNNO02,
      EP,       "fractional energy of the more energetic photon"
      REJF,     "rejection function"
      ESG1,     "energy of the more energetic photon"
      ESG2,     "energy of the less energetic photon"
      aa,bb,cc,sinpsi,sindel,cosdel,us,vs,cphi,sphi;
                "for inline rotations"
$INTEGER
      ibr;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-BHABHA;} WITH
{;
"Local variables in order of appearance"
$ENERGY PRECISION
      PEIP,     "precise total energy of incident positron"
      PEKIN,    "precise kinetic energy of incident positron"
      PEKSE2,   "precise kinetic energy of second 'electron'"
      PESE1,    "precise total energy of first 'electron'"
      PESE2,    "precise total energy of second 'electron'"
      H1,       "used in direction cosine calculations"
      DCOSTH;   "polar scattering angle for more energetic 'electron'"
$REAL EIP,      "total energy of incident positron"
      EKIN,     "kinetic energy of incident positron"
      T0,       "kinetic energy of incident positron in units of RM"
      E0,       "total energy of incident positron in units of RM"
      E02,      "E0**2"
      YY,       "1/(T0+2)"
      Y2,YP,YP2,"various functions of YY"
      BETA2,    "incident positron velocity in units of c"
      EP0,      "minimum fractional energy of a secondary 'electron'"
      EP0C,     "1-EP0"
      B1,B2,B3,B4,  "used in rejection function calculation"
      RNNO03,RNNO04,"random numbers"
      BR,       "kinetic energy fraction of the 2nd 'electron'"
      REJF2,    "rejection function"
      ESE1,     "total energy of 1st 'electron'"
      ESE2;     "total energy of 2nd 'electron'"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-BREMS;} WITH
{;
"Local variables in order of appearance"
$ENERGY PRECISION
  PEIE,   "precise incident electron energy"
  PESG,   "presice energy of emitted photon"
  PESE;   "precise total energy of scattered electron"
$REAL
  EIE,    "total incident electron energy"
  EKIN,   "kinetic incident energy"
  brmin,  " ap(medium)/ekin"
  waux,   "for faster sampling of 1/br"
  aux,    "ese/eie"
  r1,     "a random number"
  ajj,    "for energy bin determination if alias sampling is employed"
  alias_sample1,
  RNNO06, "random number"
  RNNO07, "random number"
  BR,     "energy fraction of secondary photon"
  ESG,    "energy of secondary photon"
  ESE,    "total energy of secondary electron"
  DELTA,  "scaled momentum transfer"
  phi1,   "screening function"
  phi2,   "screening function"
  REJF;   "screening rejection function"

"Brems angle selection variables"
$REAL
  a,b,c,  "direction cosines of incident `electron'"
  sinpsi, sindel, cosdel, us, vs,
          "all used for rotations"
  ztarg,  "(Zeff**1/3/111)**2, used for 2BS angle sampling"
  tteie,  "total energy in units of rest energy"
  beta,   "electron velocity in units of speed of light"
  y2max,  "maximum possible scaled angle"
  y2maxi, "inverse of the above"
  ttese,  "new electron energy in units of rm"
  rjarg1,rjarg2,rjarg3,rejmin,rejmid,rejmax,rejtop,rejtst,
          "all of them used for angle rejection function calcs"
  esedei, "new total energy over old total energy"
  y2tst,  "scaled angle, costhe = 1 - 2*y2tst/y2max"
  y2tst1,
  rtest,  "random number for rejection"
  xphi,yphi,xphi2,yphi2,rhophi2,cphi,sphi;
          "all of the above is for azimuthal angle sampling"

$INTEGER
  L,L1,ibr,jj,j;

}
;

REPLACE {$DEFINE-VARIABLES-FOR-SET-BREMS-ANGLE;} WITH
{;
"Local variables for photon angle selection"
$REAL ZTARG,  "( (1/111)*Zeff**(1/3) )**2"
      TTEIE,  "total incident electron energy in units of RM"
      TTESE,  "total scattered electron energy in units of RM"
      ESEDEI, "TTESE/TTEIE"
      beta,   "electron speed in units of c"
      Y2MAX,  "maximum value of the scaled angle"
      RJARG1,RJARG2,RJARG3,
              "arguments for which the rejection function is calculated"
      REJMIN,REJMID,REJMAX,
              "corresponding values of the rejection function"
      REJTOP, "max(REJMIN,REJMID,REJMAX)"
      Y2TST,  "random number and candidate for a scaled angle"
      REJTST, "rejection function at Y2TST"
      Y2TST1, "aux. variable for rejection function calculation"
      REJTST_on_REJTOP  ,  "ratio for rejection test"
      RTEST;  "random number for rejection"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT;} WITH
{;
"Local COMPT variables in order of appearance"
$ENERGY PRECISION
      PEIG,   "precise energy of incident photon"
      PESG,   "precise energy of scattered photon"
      PESE;   "precise total energy of compton electron"
$REAL ko,     "energy of incident photon in units of RM"
      broi,   "1+2*ko"
      broi2,  "broi*broi"
      bro,    "1/broi"
      bro1,   "1-bro"
      alph1,  "probability for the 1/BR part"
      alph2,  "probability for the BR part"
      alpha,  "alpha1/(alph1+alph2)"
      rnno15,rnno16,rnno17,rnno18,rnno19,
              "random numbers"
      br,     "scattered photon energy fraction"
      temp,   "aux. variable for polar angle calculation"
      rejf3,  "rejection function"
      rejmax, "max. of rejf3 in thge case of uniform sampling"
      Uj,     "binding energy of the selected shell"
      Jo,     "the Compton profile parameter"
      br2,    "br*br"
      fpz,fpz1,"used for limited pz-range rejection"
      qc,     "momentum transfer corresponding to the Compton line energy"
      qc2,    "qc squared"
      af,     "for calculating F"
      Fmax,   "maximum of F"
      frej,   "used for F-rejection"
      eta_incoh, eta, "random numbers"
      aux,aux1,aux2,aux3,aux4, "aux. variables"
      pzmax,  "max. possible z-component of the initial electron momentum"
      pz,     "initial electron momentum projection"
      pz2,    "pz*pz"
      rnno_RR;"for playing Russian Roulette"
$INTEGER
      irl,    "local region number"
      i,      "loop variable for shell sampling (and then shell sampled)"
      j,      "pointer to the shell in the shell data list"
      iarg,   "argument for ausgab call"
      ip;     "a loop variable"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT-old;} WITH
{;
"Local COMPT variables in order of appearance"
$ENERGY PRECISION
      PEIG,   "precise energy of incident photon"
      PESG,   "precise energy of scattered photon"
      PESE;   "precise total energy of compton electron"
$REAL ko,     "energy of incident photon in units of RM"
      broi,   "1+2*ko"
      broi2,  "broi*broi"
      bro,    "1/broi"
      bro1,   "1-bro"
      alph1,  "probability for the 1/BR part"
      alph2,  "probability for the BR part"
      alpha,  "alpha1/(alph1+alph2)"
      rnno15,rnno16,rnno17,rnno18,rnno19,
              "random numbers"
      br,     "scattered photon energy fraction"
      temp,   "aux. variable for polar angle calculation"
      rejf3,  "rejection function"
      rejmax, "max. of rejf3 in thge case of uniform sampling"
      Uj,     "binding energy of the selected shell"
      br2,    "br*br"
      aux,aux1,aux2,"aux. variables"
      pzmax2, "max. possible momentum transfer squared"
      pz,     "momentum transfer prejection"
      pz2,    "pz*pz"
      rnno_RR;"for playing Russian Roulette"
$INTEGER
      irl,    "local region number"
      i,      "loop variable for shell sampling (and then shell sampled)"
      j,      "pointer to the shell in the shell data list"
      iarg,   "argument for ausgab call"
      ip;     "a loop variable"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-ELECTR;} WITH
{;
" Local ELECTR variables"
$ENERGY PRECISION "($ENERGY PRECISION means double precision)"
    demfp,        "differential electron mean free path"
    peie,         "precise energy of incident electron"
    total_tstep,  "total path-length to next discrete interaction"
    total_de      "total energy loss to next discrete interaction"
;
$REAL
    ekems,      "kinetic energy used to sample MS angle (normally midpoint)"
    elkems,     "Log(ekems)"
    chia2,      "Multiple scattering screening angle"
    etap,       "correction to Moliere screening angle from PWA cross sections"
    lambda,     "number of mean free paths (elastic scattering cross section)"
    blccl,      "blcc(medium)*rhof"
    xccl,       "xcc(medium)*rhof"
    xi,         "used for PLC calculations (first GS moment times path-length)"
    xi_corr,    "correction to xi due to spin effects"
    ms_corr,
    p2,         "electron momentum times c, squared"
    beta2,      "electron speed in units of c, squared"
    de,         "energy loss to dedx"
    save_de,    "de saved before $DE-FLUCTUATION"
    dedx,       "stopping power after density scaling"
    dedx0,      "stopping power before density scaling"
    dedxmid,    "stopping power at mid-step before density scaling"
    ekei,       "used in $CALCULATE-TSTEP-FROM-DEMFP;"
    elkei,      "Log(ekei), used in $CALCULATE-TSTEP-FROM-DEMFP;"
    aux,        "aux. variable"
    ebr1,       "e- branching ratio into brem"
    eie,        "energy of incident electron"
    ekef,       "kinetic energy after a step"
    elkef,      "Log(ekef)"
    ekeold,     "kinetic energy before a step"
    eketmp,     "used to evaluate average kinetic energy of a step"
    elktmp,     "log(eketmp)"
    fedep,      "fractional energy loss used in stopping power calculation"
    tuss,       "sampled path-length to a single scattering event"
    pbr1,       "e+ branching ratio into brem"
    pbr2,       "e+ branching ratio into brem or Bhabha"
    range,      "electron range"
    rfict,      "rejection function for fictitious cross section"
    rnne1,      "random number"
    rnno24,     "random number"
    rnno25,     "random number"
    rnnotu,     "random number"
    rnnoss,     "random number"
    sig,        "cross section after density scaling but before a step"
    sig0,       "cross section before density scaling but before a step"
    sigf,       "cross section before density scaling but after a step"
    skindepth,  "skin depth employed for PRESTA-II boundary crossing"
    ssmfp,      "distance of one single elastic scattering mean free path"
    tmxs,       "electron step-size restriction"
    tperp,      "perpendicular distance to the closest boundary"
    ustep0,     "temporary storage for ustep"
    uscat,      "x-axis direction cosine for scattering"
    vscat,      "y-axis direction cosine for scattering"
    wscat,      "z-axis direction cosine for scattering"
    xtrans,     "final x-axis position after transport"
    ytrans,     "final y-axis position after transport"
    ztrans,     "final z-axis position after transport"
    cphi,sphi;  "for azimuthal angle selection for annih at rest"

$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;

$INTEGER
    iarg,      "calling code for ausgab"
    idr,       "calling code for ausgab"
    ierust,    "error counter for negative ustep errors"
    irl,       "region number"
    lelec,     "charge of electron"
    qel,       " = 0 for electrons, = 1 for positrons "
    lelke,     "index into the energy grid of tabulated functions"
    lelkems,   "index into the energy grid of tabulated functions"
    lelkef,    "index into the energy grid of tabulated functions"
    lelktmp,   "index into the energy grid of tabulated functions"
    ibr;       "a loop variable"

$LOGICAL
    "BCA = boundary crossing algorithm"
    callhowfar, "= .true.  => BCA requires a call to howfar"
                "= .false. => BCA does not require a call to howfar"
    domultiple, "= .true.  => inexact BCA requires multiple scattering"
    dosingle,   "= .true.  => exact BCA requires single scattering"
                "= .false. => exact BCA requires no single scattering"
    callmsdist, "= .true.  => normal condensed-history transport"
                "= .false. => one of the BCA's will be invoked"
    findindex,  "used for mscat"
    spin_index, "used for mscat with spin effects"
    compute_tstep
;
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-HATCH;} WITH
{;
"Local HATCH variables in alphabetical order"

$TYPE MBUF(72),MDLABL(8);

$REAL
    ACD   , "used to test goodness of sine-table look-up"
    ADEV  , "absolute deviation in sine-table look-up"
    ASD   , "used to test goodness of sine-table look-up"
    COST  , "cos(theta) from instrinsic library function"
    CTHET , "use to calculate cos(theta) according to look-up tables"
    DEL   , "leat squares delta for sine-table look-up"
    DFACT , "converts rl to dunits"
    DFACTI, "converts rl**-1 to dunits**-1"
    DUNITO, "units scaling varable"
    DUNITR, "saved value of dunit"
    FNSSS , "real form of integer nsinss"
    P     , "counter used in the pwr2i(i) = 1/2**(i - 1) construction"
    PZNORM, "used in $INITIALIZE-BREMS-ANGLE"
    RDEV  , "relative deviation in sine-table look-up"
    S2C2  , "sinthe**2 + costhe**2, used to test look-up table"
    S2C2MN, "min(s2c2)"
    S2C2MX, "max(s2c2)"
    SINT  , "sin(theta) from instrinsic library function"
    SX    , "sum of angles for least squared analysis of look-up table errors"
    SXX   , "sum**2 of angles for least square analysis of look-up table errors"
    SXY   , "sum of angle*sin(angle) for least squared analysis of look-up"
            "table errors"
    SY    , "sum of sin(angle) for least squared analysis of look-up table "
            "errors"
    WID   , "width of sine-table mesh sub-interval (sine-table algorithm)"
    XS    , "angle value in a sub-sub-interval (sine-table algorithm)"
    XS0   , "lower limit of a sub-sub-interval (sine-table algorithm)"
    XS1   , "upwer limit of a sub-sub-interval (sine-table algorithm)"
    XSI   , "beginning angle of a sun-interval (sine-table algorithm)"
    WSS   , "width of a sub-sub-interval (sine-table algorithm)"
    YS    , "sin(angle) for least squared analysis of look-up table errors"
    ZEROS(3); "zeros of sine, 0,pi,twopi"

$INTEGER
    I     , "generic do-loop variable"
    I1ST  , "flag = 0 on first pass"
    IB    , "do-loop variable used for reading the medium type"
    ID    , "integer value of -dunit, when dunit is negative"
    IE    , "do-loop variable for reading over elements in a compound/mixture"
    IL    , "do-loop variable used for reading the medium type"
    IM    , "do-loop variable looping over nmed, number of media"
    IRAYL , "Rayleigh switch read in from PEGS"
    IRN   , "do-loop variable over random set of sine-table look-ups"
    ISTEST, "flag that switches on test of sine function fit"
    ISUB  , "do-loop variable over sub-intervals of the sine look-up table"
    ISS   , "do-loop variable over sub-sub-intervals of the sine look-up table"
    IZ    , "used to locate an exact zero of a sun-interval mesh point in the"
            "sine-table look-up"
    IZZ   , "do-loop variable over the exact zeros of the sine-table look-up"
    J     , "do-loop variable looping over nmed, number of media"
    JR    , "do-loop variable looping over number of regions"
    LCTHET, "$SET INTERVAL index for cos(theta) from look-up table"
    LMDL  , "character width of medium header ' MEDIUM='"
    LMDN  , "character width of medium description"
    LTHETA, "$SET INTERVAL index for sin(theta) from look-up table"
    MD    , "temporary storage for the medium number"
    MXSINC, "number of intervals approximating the sine function"
    NCMFP , "array size input from PEGS. Currently 0, but probably intended"
            "to be cumulative electron mean free path. Presently unused."
    NEKE  , "array size input from PEGS."
            "Number of electron mapped energy intervals."
    NGE   , "array size input from PEGS."
            "Number of photon mapped energy intervals."
    NGRIM , "Rayleigh cross section array size."
    NISUB , "mxsinc - 2. Size of array with endpoints removed."
    NLEKE , "array size input from PEGS. Currently 0, but probably intended"
            "to be number of electron energy intervals below threshold."
            "Presently unused."
    NM    , "number of media found in the "
    NRANGE, "array size input from PEGS. Currently 0, but probably intended"
            "to be number of intervals in an array giving the electron range."
            "Presently unused."
    NRNA  , "number of random angles testing sine function fit"
    NSEKE , "array size input from PEGS. Currently 0, but probably intended"
            "to be number of electron small energy intervals. Presently unused."
    NSGE  , "array size input from PEGS. Currently 0, but probably intended"
            "to be number of gamma small energy intervals. Presently unused."
    NSINSS, "number of sub-intervals for each sine function interval"
    LOK($MXMED); "flag indicating that medium has been found in the PEGS "
                 "datafile"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-MOLLER;} WITH
{;
"Local MOLLER variables in order of their appearance"

$ENERGY PRECISION
     PEIE,   "precise total energy of incident electron"
     PEKSE2, "precise kinetic energy of 2nd secondary electron"
     PESE1,  "precise total energy of 1st secondary electron"
     PESE2,  "precise total energy of 2nd secondary electron"
     PEKIN,  "precise kinetic energy of incident electron"
     H1,     "used for polar scattering angle calculation"
     DCOSTH; "polar scattering angle squared"
$REAL EIE,    "total energy of incident electron"
     EKIN,   "kinetic energy of incident electron"
     T0,     "kinetic energy of incident electron in units of RM"
     E0,     "total energy of incident electron in units of RM"
     EXTRAE, "energy above the Moller threshold"
     E02,    "E0**2"
     EP0,    "minimum alowed kinetic energy fraction"
     G2,G3,  "used for rejection function calculation"
     GMAX,   "maximum value of the rejection function"
     BR,     "kinetic energy fraction to lowew energy electron"
     R,      "(1-BR)/BR"
     REJF4,  "rejection function"
     RNNO27, "random number for BR sampling"
     RNNO28, "random number for rejection"
     ESE1,   "energy of 1st secondary electron"
     ESE2;   "energy of 2nd secondary electron"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-PAIR;} WITH
{;
"Local PAIR variables in order of their appearance"
$ENERGY PRECISION
      PEIG,      "precise energy of incident photon"
      PESE1,     "precise energy of 1st 'electron'"
      PESE2;     "precise energy of 2nd 'electron'"

$REAL EIG,       "energy of incident photon"
      ESE2,      "total energy of lower energy 'electron'"
      RNNO30,RNNO31,rnno32,rnno33,rnno34,
                 "random numbers"
      DELTA,     "scaled momentum transfer"
      REJF,      "screening rejection function"
      rejmax,    "the maximum of rejf"
      aux1,aux2, "auxilary variables"
      Amax,      "Maximum of the screening function used with (br-1/2)**2"
      Bmax,      "Maximum of the screening function used with the uniform part"
      del0,      "delcm*eig"
      br,        "fraction of the available energy (eig-rmt2) going to the"
                 "lower energy `electron'"
      Eminus,Eplus,Eavail,rnno_RR;

$INTEGER
      L,L1;  "flags for high/low energy distributions"
}
;

REPLACE {$DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;} WITH
{;
$REAL ESE,   "total energy of one of the 'electrons'"
      PSE,   "momentum corresponding to ESE"
      ZTARG, "( (1/111)*Zeff**(1/3) )**2"
      TTEIG, "incident photon energy in units of RM"
      TTESE, "energy of one of the 'electrons' in units of RM"
      TTPSE, "momentum of one of the 'electrons' in units of RM"
      ESEDEI,"TTESE/(TTEIG-TTESE) = ratio of secondary electron energies"
      ESEDER,"1/ESEDEI"
      XIMIN, "1st argument where rejection function might have a maximum"
      XIMID, "2nd argument where rejection function might have a maximum"
      REJMIN,"rejection function at XIMIN"
      REJMID,"rejection function at XIMID"
      REJTOP,"max(REJMIN,REJMID)"
      YA,XITRY,GALPHA,GBETA,
             "aux. variables for XIMID calculation"
      XITST, "random number for pair angle sampling"
      REJTST_on_REJTOP  ,  "ratio for rejection test"
      REJTST,"rejection function at XITST"
      RTEST; "random number for rejection"
$INTEGER
      ICHRG; "loop variable"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTO;} WITH
{;
"Local PHOTO variables in order of their appearance"

$ENERGY PRECISION
      PEIG;         "precise energy of incident photon"
$REAL BR,           "random number"
      sigma,        "elemental cross section"
      aux,aux1,     "aux. variables"
      probs($MXEL), "probability for an interaction with a given element"
      sigtot,       "total cross section"
      e_vac,        "shell binding energy"
      rnno_RR;      "for playing Russian Roulette"
$INTEGER
      IARG,         "AUSGAB calling switch"
      iZ,           "Atomic number of the element the photon is "
                    "interactiong with"
      irl,          "local region number"
      ints($MXEL),  "energy interval number for a given element"
      j,ip,         "loop variables"
      n_warning,    "a warning counter"
      k;            "shell number"

$LOGICAL
      do_relax;
save  n_warning;
}
;

REPLACE {$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;} WITH
{;
"Photo-electron angle selection variables"
$REAL EELEC, "total energy of photo-electron"
      BETA,  "velocity of electron in units of c"
      GAMMA, "total energy of photo-electron in units of RM"
      ALPHA, "kinematic factor"
      RATIO, "=BETA/ALPHA"
      RNPHT, "random number"
      FKAPPA,"aux. variable for COSTHE calculation"
      XI,    "used in rejection function calculation"
      SINTH2,"SINTHE**2"
      RNPHT2;"random number for rejection"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-EDGSET;} WITH
{;
"Local EDGSET variables in order of their appearance"
$REAL EALF(100),EBET(100),OMEG(100),PHOTOK(100),PKA(100);
      "see the data statements in EDGSETfor definition of these arrays"
$INTEGER JJ,IZ,IMED,I;
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTON;} WITH
{;
"Local PHOTON variables in order of their appearance"
$ENERGY PRECISION
    PEIG;   "precise photon energy"
;
$REAL
    EIG,    "photon energy"
    RNNO35, "random number for default MFP selection"
    GMFPR0, "photon MFP before density scaling and coherent correction"
    GMFP,   "photon MFP after density scaling"
    COHFAC, "Rayleigh scattering correction"
    RNNO37, "random number for Rayleigh scattering selection"
    XXX,    "random number for momentum transfer sampling in Rayleigh"
    X2,     "scaled momentum transfer in Rayleigh scattering event"
    Q2,     "momentum transfer squared in Rayleigh scattering event"
    CSQTHE, "COSTHE**2"
    REJF,   "Rayleigh scattering rejection function"
    RNNORJ, "random number for rejection in Rayleigh scattering"
    RNNO36, "random number for interaction branching"
    GBR1,   "probability for pair production"
    GBR2,   "probability for pair + compton"
    T,      "used for particle exchange on the stack"
"Ali:photonuc, 2 lines"
    PHOTONUCFAC, "photonuclear correction"
    RNNO39; "random number for photonuclear selection (RNNO38 is taken)"
;
$INTEGER
    IARG,   "parameter for AUSGAB"
    IDR,    "parameter for AUSGAB"
    IRL,    "region number"
    LGLE,   "index for GMFP interpolation"
    LXXX;   "index for Rayleigh scattering cummulative distribution int."
}
;

"Ali:photonuc, 1 block"
REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTONUC;} WITH {;}
;

" Handling track-ends "
" By default, just call AUSGAB and drop energy on the spot"

REPLACE {$ELECTRON-TRACK-END;} WITH {; $AUSCALL(idr); }
REPLACE {$PHOTON-TRACK-END;}   WITH {; $AUSCALL(IDR); }
;

" Macros for the fictitious method  "
"==================================="

" The following version uses sub-threshold energy loss "
" as a measure of path-length => cross section is actual "
" cross section divided by restricted stopping power "
" The global maximum of this quantity called esig_e (electrons) or "
" psig_e (positrons) and is determined in HATCH "

REPLACE {$EVALUATE-SIG0;} WITH
"        ==============="
{;
   IF( sig_ismonotone(qel,medium) ) [
       $EVALUATE-SIGF; sig0 = sigf;
   ]
   ELSE [
       IF( lelec < 0 ) [sig0 = esig_e(medium);]
       ELSE            [sig0 = psig_e(medium);]
   ]
}

REPLACE {$EVALUATE-SIGF;} WITH
"        ==============="
{;
  IF(lelec < 0)
  [
      $EVALUATE sigf USING esig(elke);
      $EVALUATE dedx0 USING ededx(elke);
      sigf = sigf/dedx0;
  ]
  ELSE
  [
      $EVALUATE sigf USING psig(elke);
      $EVALUATE dedx0 USING pdedx(elke);
      sigf = sigf/dedx0;
  ]
}
;

REPLACE {$EVALUATE-EBREM-FRACTION;} WITH {
    $EVALUATE ebr1 USING ebr1(elke);
};
REPLACE {$EVALUATE-PBREM-FRACTION;} WITH {
    $EVALUATE pbr1 USING pbr1(elke);
};
REPLACE {$EVALUATE-BHABHA-FRACTION;} WITH {
    $EVALUATE pbr2 USING pbr2(elke);
};


" Because the cross section is interactions per energy loss, no "
" rhof-scaling is required "
REPLACE {$SCALE-SIG0;} WITH
"        ============"
{
   sig = sig0;
}
;

" Once the sub-threshold processes energy loss to the next discrete "
" interaction is determined, the corresponding path-length has to be"
" calculated. This is done by the macro below. This macro           "
" assumes the energy at the begining to be eke, the logarithm of it "
" elke, lelke - the corresponding interpolation index and makes     "
" use of $COMPUTE-DRANGE(#,#,#,#,#,#)                               "

REPLACE {$CALCULATE-TSTEP-FROM-DEMFP;} WITH
"        ============================"
{;
  IF( compute_tstep ) [
    total_de = demfp/sig; fedep = total_de;
    ekef  = eke - fedep;
    IF( ekef <= E_array(1,medium) ) [ tstep = vacdst; ]
    ELSE
    [
      elkef = Log(ekef);
      $SET INTERVAL elkef,eke;
      IF( lelkef = lelke )
      [       " initial and final energy are in the same interpolation bin "
          $COMPUTE-DRANGE(eke,ekef,lelke,elke,elkef,tstep);
      ]
      ELSE
      [   " initial and final energy are in different interpolation bins, "
          " calc range from ekef to E(lelkef+1) and from E(lelke) to eke  "
          " and add the pre-calculated range from E(lelkef+1) to E(lelke) "
          ekei = E_array(lelke,medium);
          elkei = (lelke - eke0(medium))/eke1(medium);
          $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,tuss);
          ekei = E_array(lelkef+1,medium);
          elkei = (lelkef + 1 - eke0(medium))/eke1(medium);
          $COMPUTE-DRANGE(ekei,ekef,lelkef,elkei,elkef,tstep);
          tstep=tstep+tuss+
                  range_ep(qel,lelke,medium)-range_ep(qel,lelkef+1,medium);
      ]
    ]
    total_tstep = tstep;
    compute_tstep = .false.;
  ]
  tstep = total_tstep/rhof;  " non-default density scaling "
}
;

" The following macro computes the path-length traveled while going from  "
" energy {P1} to energy {P2}, both energies being in the same             "
" interpolation bin, given by {P3}. {P4} and {P5} are the logarithms of   "
" {P1} and {P2}. The expression is based on logarithmic interpolation as  "
" used in EGSnrc (i.e. dedx = a + b*Log(E) ) and a power series expansion "
" of the ExpIntegralEi function that is the result of the integration.    "
" The result is returned in {P6}.                                         "

REPLACE {$COMPUTE-DRANGE(#,#,#,#,#,#);} WITH
"        ============================="
{
  fedep = 1 - {P2}/{P1};
  elktmp = 0.5*({P4}+{P5}+0.25*fedep*fedep*(1+fedep*(1+0.875*fedep)));
           " the above evaluates the logarithm of the midpoint energy"
  lelktmp = {P3};
  IF(lelec < 0) [
      $EVALUATE dedxmid USING ededx(elktmp);
      dedxmid = 1/dedxmid;
      aux = ededx1(lelktmp,medium)*dedxmid;
      "aux = ededx1(lelktmp,medium)/dedxmid;"
  ]
  ELSE [
      $EVALUATE dedxmid USING pdedx(elktmp);
      dedxmid = 1/dedxmid;
      aux = pdedx1(lelktmp,medium)*dedxmid;
      "aux = pdedx1(lelktmp,medium)/dedxmid;"
  ]
  aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6;
  "{P6} = fedep*{P1}/dedxmid*(1+aux);"
  {P6} = fedep*{P1}*dedxmid*(1+aux);
}
;

" The following macro computes the range to the minimum table energy "
" It uses $COMPUTE-DRANGE                                            "
" Note that range_ep array is precomputed in subroutine mscati and   "
" gives the range from the energy interval end points to AE for each "
" medium.

REPLACE {$COMPUTE-RANGE;} WITH
"        ==============="
{
;
  ekei = E_array(lelke,medium);
  elkei = (lelke - eke0(medium))/eke1(medium);
  $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,range);
  range = (range + range_ep(qel,lelke,medium))/rhof;
}
;

/******* trying to save evaluation of range.
REPLACE {$COMPUTE-RANGE;} WITH {;
"        ==============="
  IF( do_range ) [
      ekei = E_array(lelke,medium);
      elkei = (lelke - eke0(medium))/eke1(medium);
      $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,range);
      the_range = range + range_ep(qel,lelke,medium);
      do_range = .false.;
  ]
  range = the_range/rhof;
};
******************/

" The following macro updates demfp. As energy loss is used as the  "
" 'path-length' variable (see above), it just substracts the energy "
" loss for the step.                                                "
REPLACE {$UPDATE-DEMFP;} WITH
"        =============="
{
  demfp = demfp - save_de*sig;
  total_de = total_de - save_de;
  total_tstep = total_tstep - tvstep*rhof;
  IF( total_tstep < 1e-9 ) [ demfp = 0; ]
}
;

" The following macro computes the energy loss due to sub-threshold "
" processes for a path-length {P1}. The energy at the beginning of  "
" the step is {P2}, {P3}=Log({P2}), {P4} is the interpolation index "
" The formulae are based on the logarithmic interpolation for dedx  "
" used in EGSnrc. The result is returned in {P5}. Assumes that      "
" initial and final energy are in the same interpolation bin.       "

REPLACE {$COMPUTE-ELOSS(#,#,#,#,#);} WITH
"        =========================="
{;
  IF( lelec < 0 ) [
      $EVALUATE dedxmid USING ededx({P3});
      aux = ededx1({P4},medium)/dedxmid;
  ]
  ELSE [
      $EVALUATE dedxmid USING pdedx({P3});
      aux = pdedx1({P4},medium)/dedxmid;
  ]
  /*
  {P5} = dedxmid*{P1};  " Energy loss using stopping power at the beginning "
  */
  {P5} = dedxmid*{P1}*rhof; "IK: rhof scaling bug, June 9 2006"
                            "rhof scaling must be done here and NOT in "
                            "$COMPUTE-ELOSS-G below!"
  fedep = {P5}/{P2};
  {P5} = {P5}*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1-
             0.25*fedep*(2-aux*(4-aux)))));
}
;

" The following is a generalized version of $COMPUTE-ELOSS.        "

REPLACE {$COMPUTE-ELOSS-G(#,#,#,#,#);} WITH
"        ============================"
{
  tuss = range - range_ep(qel,{P4},medium)/rhof;
    " here tuss is the range between the initial energy and the next lower "
    " energy on the interpolation grid "
  IF( tuss >= {P1} ) [  " Final energy is in the same interpolation bin "
      $COMPUTE-ELOSS({P1},{P2},{P3},{P4},{P5});
      /* {P5} = {P5}*rhof; "IK, rhof bug"  */
      "IK: rhof scaling bug, June 9 2006. rhof scaling is done in "
      "    $COMPUTE-ELOSS above!                                  "
  ]
  ELSE [ " Must find first the table index where the step ends using "
         " pre-calculated ranges                                     "
      lelktmp = {P4};
      tuss = (range - {P1})*rhof;
         " now tuss is the range of the final energy electron "
         " scaled to the default mass density from PEGS4      "
      IF( tuss <= 0 ) [ {P5} = {P2} - TE(medium)*0.99; ]
        " i.e., if the step we intend to take is longer than the particle "
        " range, the particle energy goes down to the threshold "
        "({P2} is the initial particle energy)  "
        "originally the entire energy was lost, but msdist_xxx is not prepared"
        "to deal with such large eloss fractions => changed July 2005."
      ELSE [
          WHILE ( tuss < range_ep(qel,lelktmp,medium) ) [
              lelktmp = lelktmp - 1; ]
          elktmp = (lelktmp+1-eke0(medium))/eke1(medium);
          eketmp = E_array(lelktmp+1,medium);
          "tuss = range_ep(qel,lelktmp+1,medium) - tuss;"
          "IK: rhof scaling bug, June 9 2006: because of the change in "
          "    $COMPUTE-ELOSS above, we must scale tuss by rhof        "
          tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof;
          $COMPUTE-ELOSS(tuss,eketmp,elktmp,lelktmp,{P5});
          {P5} = {P5} + {P2} - eketmp;
      ]
  ]
}
;
%E  "egsnrc.macros"
"============================================================================"
"
"   The following is related to use of the NRC auxilliary get_inputs
"   routine which is part of the standard NRC user-codes.
"
"   It is not an essential part of EGSnrc but is most easily defined here.
"
"============================================================================"
"
" Input stuff for the get_inputs() routine.                                  "
" As the expirience has shown that get_inputs() is frequently used in several"
" subroutines, I changed the parameter passed to get_inputs() to a common    "
" block. Otherwise, the parameters have to be defined in each subroutine using"
" get_inputs() and, with static variables, this lead to a memory use         "
" explosion (e.g. 8 MB for CAVRZ vs. 0.8 MB without get_inputs()!)           "
" IK, Dec. 1998                                                              "

REPLACE {$NMAX} WITH {100};
REPLACE {$NVALUE} WITH {100};
REPLACE {$STRING80} WITH {80};
REPLACE {$STRING32} WITH {64};
REPLACE {$STRING40} WITH {40};
REPLACE {$STRING256} WITH {256};
REPLACE {$MXALINP} WITH {5};

REPLACE {COMIN/GetInput/;} WITH
"        ================"
{
  ;COMMON/GetInput/
        ALLOWED_INPUTS($NMAX,0:$MXALINP), "Associates a name with each second "
                                   "array index(0:4) for a value sought"
        VALUES_SOUGHT($NMAX),      "Name of each input                 "
        CHAR_VALUE($NMAX,$NVALUE), "For returning character inputs     "
        VALUE($NMAX,$NVALUE),      "For returning int. or real inputs  "
        DEFAULT($NMAX),            "Default value, only for type 0 & 1 "
        VALUE_MIN($NMAX),          "Min and max value defining         "
        VALUE_MAX($NMAX),          "the acceptable input range         "
        NVALUE($NMAX),             "Number of values per value sought  "
        TYPE($NMAX),               "Type of the value sought           "
                                   "0 for integer                      "
                                   "1 for real                         "
                                   "2 for character                    "
                                   "3 for character with allowed_inputs"
        ERROR_FLAGS($NMAX),        "An error flag for each of the      "
                                   "attempted inputs                   "
        i_errors,                  "Unit no. for .errors output file   "
        NMIN, NMAX,                "Minimum and maximum index number of"
                                   "the values sought                  "
        ERROR_FLAG,                "0 for no errors, 1 for errors      "
        DELIMETER;                 "Name of the delimeter              "
   character ALLOWED_INPUTS*$STRING32,VALUES_SOUGHT*$STRING32,
             CHAR_VALUE*$STRING256,DELIMETER*$STRING32;
   $REAL     VALUE,DEFAULT,VALUE_MIN,VALUE_MAX;
   $INTEGER  NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors;
}
;

REPLACE {$GET_INPUT(#);} WITH { NMIN = {P1}; NMAX = {P1}; CALL GET_INPUT; }
;

REPLACE {$GET_INPUTS(#,#);} WITH { NMIN = {P1}; NMAX = {P2}; CALL GET_INPUT; }
;

"The following macro is used in the egs_init1 subroutine (in the file
"egs_utilities.mortran.  Here it is replaced by null so that we insist that
"the .egsinp file be opened with unit=5 (standard input) and the .egslog
"file (if required) be opened with unit=6 (standard output).  This is
"replaced by a search for available units in beamnrc_lib.mortran to avoid
"unit collisions with BEAM shared library sources

REPLACE {$AVAILABLE_UNIT(#,#)} WITH {;}

" The following two macros are defined so that if the nrcaux.mortran file
" is included in the configuration file these are defined at least.
" If the NRC statistics routine  SIGMA is to be used these must have realistic
" definitions in the user-code.

REPLACE {$MXDATA} WITH {1};
REPLACE {$STAT} WITH {2};

%E  "egsnrc.macros"
"============================================================================"
"   The following is related to use of the NRC auxilliary
"   routine xvgrplot which is called from some of the standard
"   NRC user-codes.
"
"   It is not an essential part of EGSnrc but is most easily defined here.
"============================================================================"
REPLACE{$PLTDIM} WITH {300};"Unique array dimension for XVGRPLOT and PLOTSN"
                        "Suppresses warnings from Intel compiler on Windows"
                   "when arrays have different dimensions in diff. routines"

%E   "egsnrc.macros"
"***************************************************************************"
"                                                                           "
"         EGSnrc internal Variance Reduction Macros                         "
"                                                                           "
"***************************************************************************"

REPLACE {;COMIN/EGS-VARIANCE-REDUCTION/;} WITH {;

  common/egs_vr/
    e_max_rr($MXREG), "max energy at which to do range rejection (RR)"
    prob_RR,          "probability for survival in R. Roulette"
    nbr_split,        "do brems splitting if > 1"
    i_play_RR,        "0=>don't play Russian Roulette,1=>play Russian Roulette"
    i_survived_RR,    "0=> all particles survive RR, n=> n partilces were"
                      "eliminated by RR in this interaction"
    n_RR_warning,     "a counter for user errors"
    i_do_rr($MXREG);  "0=>no RR, region by region, 1=>there is RR"
  $REAL          e_max_rr,prob_RR;
  $INTEGER       nbr_split,i_play_RR,i_survived_RR,n_RR_warning;
  $SHORT_INT     i_do_rr;
};

REPLACE {$MAX-RR-WARNING} WITH {50}

"This macro implements Russian Roulette (most useful  with brems splitting)"
"It is more efficient than having the user do it via AUSGAB since it avoids"
"considerable handling of the particles by ELECTR"
"The user must set i_play_RR (defaults to 0) and prob_RR"
"Both are in COMIN EGS-VARIANCE-REDUCTION"
""
"Note that this macro is called as $PLAY RUSSIAN ROULETTE WITH ELECTRONS..."
"Note also that subroutine pair has its own, internal version"

REPLACE {$PLAYRUSSIANROULETTEWITHELECTRONSFROM#;} WITH {;

  i_survived_RR = 0;   "flag all survive"
  ;IF( i_play_RR = 1 ) [
      IF( prob_RR <= 0 ) [
          IF( n_RR_warning < $MAX-RR-WARNING ) [
            n_RR_warning = n_RR_warning + 1;
            OUTPUT prob_RR;
  ('**** Warning, attempt to play Roussian Roulette with prob_RR<=0! ',g14.6);
          ]
      ]
      ELSE [
          ip = {P1};
          LOOP [     "handle all particles from p1 to np"
              IF( iq(ip) ~= 0 ) [   "i.e. charged particles"
                  $RANDOMSET rnno_RR;
                  IF( rnno_RR < prob_RR ) [ "particle survives"
                      wt(ip) = wt(ip)/prob_RR;
                      ip = ip + 1; "increase local pointer"
                  ]
                  ELSE [                    "particle killed"
                      ;i_survived_RR = i_survived_RR + 1;
                      ;IF(ip < np) [
                          "=>replace it with last particle on stack"
                          e(ip) = e(np); iq(ip) = iq(np); wt(ip) = wt(np);
                          u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
                      ]
                      np = np-1; "reduce stack by one=> particle gone"
                  ] "end of kill particle block"
              ] ELSE [ "this is a photon, leave it. Change pointer" ip = ip+1; ]
          ] UNTIL (ip > np);
          "loops until either np is decreased to ip, or ip increased to np"
          IF( np = 0 ) [ " we need at least one particle on the stack "
                         " so that the transport routines can exit properly"
              np = 1; e(np) = 0; iq(np) = 0; wt(np) = 0;
          ]
      ] "end of russian roulette block"
  ] "end of flag set block"
};

"*********************************************************************"
"  Stuff related to radiative corrections for Compton scattering      "
"                                                                     "
"  For now we exclude such corrections by default. They can be        "
"  included by adding the file rad_compton.mortran to the list of     "
"  files used to build EGSnrc just before egsnrc.mortran              "
"  The reason is that there is a fairly large amount of data needed   "
"  and this would be wasteful if the effect turns out to be small     "
"*********************************************************************"

REPLACE {$RADC_CHECK;} WITH {;}
REPLACE {$RADC_REJECTION;} WITH {;}
REPLACE {$RADC_WARNING;} WITH {;
    IF( radc_flag = 1 ) [
        $egs_warning(*,'You are trying to use radiative Compton corrections');
        $egs_info(*,'without having included rad_compton1.mortran');
        $egs_info('(a//)','Turning radiative Compton corrections OFF ...');
        radc_flag = 0;
    ]
};
REPLACE {$RADC_HATCH;} WITH {$RADC_WARNING;}
REPLACE {$COMIN-RADC-INIT;} WITH {
        ;COMIN/RAD_COMPTON,EGS-IO,COMPTON-DATA,MEDIA,PHOTIN,USEFUL/;
};
REPLACE {$COMIN-RADC-SAMPLE;} WITH {
        ;COMIN/RAD_COMPTON,RANDOM,STACK,USEFUL,EGS-IO/;
};


"*********************************************************************"
"  I/O, parallel processing, string manipulations, etc.
"*********************************************************************"

"how many chunks do we want to split the parallel run into
REPLACE {$N_CHUNKS} WITH {10};

" String manipulations, error messages, etc. "
REPLACE {$cstring(#)} WITH {{P1}(:lnblnk1({P1}))};
REPLACE {$set_string(#,#);} WITH {;
  DO i=1,len({P1}) [ {P1}(i:i) = {P2}; ] ;
};

REPLACE {$egs_debug(#,#);} WITH { write(i_log,{P1}) {P2}; };
REPLACE {$egs_fatal(#,#,#);} WITH {
  $warning('(/a)','***************** Error: ');
  $warning({P1},{P2});
  $warning('(/a)','***************** Quiting now.');
  $CALL_EXIT({P3});
};
REPLACE {$egs_fatal(#,#);} WITH {
  $warning('(/a)','***************** Error: ');
  $warning({P1},{P2});
  $warning('(/a)','***************** Quiting now.');
  $CALL_EXIT(1);
};
REPLACE {$egs_warning(#,#);} WITH {
  $warning('(/a)','***************** Warning: ');
  $warning({P1},{P2});
};
REPLACE {$warning(#,#);} WITH { write(i_log,{P1}) {P2}; };
REPLACE {$egs_info(#,#);} WITH { write(i_log,{P1}) {P2}; };
REPLACE {$declare_write_buffer;} WITH {;};


" Common block containing various directories, file names, etc. "
REPLACE {$mx_units} WITH {20};
REPLACE {$max_extension_length} WITH {10};
REPLACE {;COMIN/EGS-IO/;} WITH {;
  common /egs_io/ file_extensions($mx_units),
                  file_units($mx_units),
                  user_code,  "The name of the user code"
                  input_file, "The input file name with path but no extension"
                  output_file,"Same as above but for output"
                  pegs_file,  "The pegs file name with path and extension"
                  hen_house,  "The HEN_HOUSE directory"
                  egs_home,   "The EGS_HOME directory"
                  work_dir,   "The working directory within the user code dir."
                  host_name,  "The name of the host"
                  n_parallel, "if >0, number of parallel jobs"
                  i_parallel, "if >0, parallel job number"
                  first_parallel,"first parallel job (default is 1)"
                  n_max_parallel,"if parallel run, max. number of running jobs"
                  n_chunk,    "Histories per calculation chunk"
                  n_files,
                  i_input,    "unit no. for .egsinp if required"
                  i_log,      "unit no. for .egslog if required"
                  i_incoh,    "unit no. for Compton data"
                  i_nist_data, "unit no. for NIST data"
                  i_mscat,     "unit no. for multiple scattering data"
                  i_photo_cs,  "unit no. for photon cross-section data"
                  i_photo_relax, "unit no. for photon relaxation data"
                  xsec_out,     "switches on/off xsection file output"
                  is_batch,   "True for batch mode"
                  is_pegsless; "true if you are running without pegs file"
  character input_file*256, output_file*256, pegs_file*256,
            file_extensions*$max_extension_length,
            hen_house*128, egs_home*128, work_dir*128, user_code*64,
            host_name*64;
  $INTEGER  n_parallel, i_parallel, first_parallel,n_max_parallel,
            n_chunk, file_units, n_files,i_input,i_log,i_incoh,
            i_nist_data,i_mscat,i_photo_cs,i_photo_relax, xsec_out;
  $LOGICAL  is_batch,is_pegsless;
};

"The following macro sets the EGS_HOME directory               "
"The defualt implementation is to use the environment variable "
"EGS_HOME. But at the NRC EGS_HOME is set using the macro      "
"$EGS_HOME defined in machine.macros.                          "
REPLACE {$set_egs_home;} WITH {;
  $set_string(egs_home,' ');
  call getenv('EGS_HOME',egs_home);
};


" Initialization of various variables on a region-by-region basis "
" This is made a macro so that it can be replaced with a different "
" version for the C/C++ interface                                 "
REPLACE {$set-region-by-region-defaults;} WITH {;
DO i=1,$MXREG [
    ecut(i) = $GLOBAL-ECUT; pcut(i) = $GLOBAL-PCUT; "cut-off energies"
    ibcmp(i) = $IBCMP-DEFAULT;    "Compton "
    iedgfl(i) = $IEDGFL-DEFAULT;  "Relaxations"
    iphter(i) = $IPHTER-DEFAULT;  "photo-electron angular distribution"
    smaxir(i) = $MAX-SMAX;        "maximum step size"
    i_do_rr(i) = 0;               "range rejection flag"
    e_max_rr(i) = 0;              "`save' energy for range rejection"
    med(i) = 1;                   "default medium"
    rhor(i) = 0;                  "default mass density"
    iraylr(i) = $IRAYLR-DEFAULT;  "Rayleigh flag"
"Ali:photonuc, 1 line"
    iphotonucr(i) = $IPHOTONUCR-DEFAULT;  "photonuclear flag per region"]
};

" Make sure ecut and pcut are at least ae/ap and set default densities "
" This is made a macro so that it can be replaced with a different "
" version for the C/C++ interface                                 "
REPLACE {$adjust_rhor_ecut_pcut;} WITH {;
DO JR=1,$MXREG [
    MD=MED(JR);
    IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
        ECUT(JR)=max(ECUT(JR),AE(MD));
        PCUT(JR)=max(PCUT(JR),AP(MD));
        "   USE STANDARD DENSITY FOR REGIONS NOT SPECIALLY SET UP"
        IF (RHOR(JR).EQ.0.0)[RHOR(JR)=RHO(MD);]
    ]
]
};

REPLACE {$adjust_pcut;} WITH {;
DO JR=1,$MXREG [
    MD=MED(JR);
    IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
        PCUT(JR)=max(PCUT(JR),AP(MD));
    ]
]
};

REPLACE {$start_new_particle;} WITH { medium = med(irl); };

REPLACE {$electron_region_change;} WITH {
    ir(np) = irnew; irl = irnew; medium = med(irl);
};
REPLACE {$photon_region_change;} WITH { $electron_region_change; }

REPLACE {$declare_max_medium;} WITH {;};

REPLACE {$need_bound_compton_data(#);} WITH {
  {P1} = .false.;
  DO j=1,$MXREG [
      medium = med(j);
      IF( medium > 0 & medium <= nmed) [
          IF( ibcmp(j) > 0 ) [ {P1} = .true.; EXIT; ]
      ]
  ]
};

REPLACE {$need_relaxation_data(#);} WITH {
  {P1} = .false.;
  DO j=1,$MXREG [
      IF( iedgfl(j) > 0 & iedgfl(j) <= $MXELEMENT ) [ {P1} = .true.; EXIT; ]
  ]
};

REPLACE {$need_rayleigh_data;} WITH {;
DO J=1,NMED [
:LOOP-OVER-REGIONS:  DO I=1,$MXREG [
IF(IRAYLR(I).EQ.1.AND.MED(I).EQ.J) [
"REGION I = MEDIUM J AND WE WANT RAYLEIGH SCATTERING, SO"
"SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
IRAYLM(J)=1; EXIT :LOOP-OVER-REGIONS:;]
"END OF REGION-LOOP"]
"END OF MEDIA-LOOP"]
};

"Ali:photonuc, 1 block"
REPLACE {$need_photonuc_data;} WITH {;
IPHOTONUC=0;
DO J=1,NMED [
:LOOP-OVER-REGIONS-PHOTONUC: DO I=1,$MXREG [
IF(IPHOTONUCR(I).EQ.1.AND.MED(I).EQ.J) [
"REGION I = MEDIUM J AND WE WANT PHOTONUCLEAR, SO"
"SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
IPHOTONUCM(J)=1; IPHOTONUC=1; EXIT :LOOP-OVER-REGIONS-PHOTONUC:;]
"END OF REGION-LOOP"]
"END OF MEDIA-LOOP"]
};

REPLACE {$set_ecutmn;} WITH {
  ecutmn = 1e30;
  DO i=1,$MXREG [
      IF( med(i) > 0 & med(i) <= nmed ) [
                ecutmn = Min(ecutmn,ecut(i));
      ]
  ]
};

" default numer of media. "
REPLACE {$default_nmed} WITH {1}

REPLACE {$GET-PEGSLESS-XSECTIONS;} WITH {;
$egs_fatal('(a/a)',' Code cannot be run in pegsless mode.',
' Compile with required files and try again.');
;
}

REPLACE {$INIT-PEGS4-VARIABLES;} WITH {;}

REPLACE {$DECLARE-PEGS4-COMMON-BLOCKS;} WITH {;}

" The following macro is defined to fool the Intel Fortran compiler "
" version 8.0, which miscompiles init_spin when certain optimizations"
" are turned on and the code is run on an Athlon CPU. "
REPLACE {$FOOL-INTEL-OPTIMIZER(#) #;} WITH {;
    IF( fool_intel_optimizer ) [ write({P1},*) {P2}; ]
}
;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc timing macros                                                       "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2003                                       "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                                                                             "
"#############################################################################"


REPLACE {$DECLARE_TIMING_VARIABLES;} WITH {;
  real  CPUT0,CPUT1,CPUT2,TDUM;
  real egs_tot_time, egs_etime;}
;
REPLACE {$INITIALIZE_ELAPSED_CPU_TIME;} WITH {;}
;
REPLACE {$SET_ELAPSED_CPUTIME(#);} WITH { {P1}=egs_etime(); }
;
REPLACE {$INITIALIZE_ELAPSED_TOTAL_TIME;} WITH
  { tdum = egs_tot_time(1); }
;
REPLACE {$SET_ELAPSED_TOTAL_TIME(#);} WITH
  { {P1} = egs_tot_time(0); }
;
REPLACE {$CONVERSION_TO_SECONDS} WITH {1.0}
;
REPLACE {$TIME_RESOLUTION} WITH {0.01}
;
%E
%I4
!INDENT F2;
%C80
%Q1
"*************************************************************************
"
" EGSnrc machine dependent macro file for
" linux
"
" Created by :
" EGSnrc-configure-linux version 1.0 on su helmik. 9 2020
"
" You may add your own machine dependent macros to this file,
" but be carefull to not overwrite it if you re-run
" EGSnrc-configure-linux
"
"*************************************************************************

REPLACE {$MACHINE} WITH
  {,'linux',};
REPLACE {$HEN_HOUSE} WITH
  {'/home/miia/EGSnrc/HEN_HOUSE/'};
REPLACE {$CANONICAL_SYSTEM} WITH
  {'linux64'};
REPLACE {$CONFIGURATION_NAME} WITH
  {'linux'};
REPLACE {$EGS_CONFIG} WITH
  {'/home/miia/EGSnrc/HEN_HOUSE/specs/linux.conf'};

" System dependent stuff "
"========================================"
" Unfortunately, there appears to be no reliable way of copying files "
" under Fortran => we use a system call for this"
REPLACE {$copy_file} WITH {'cp  '};

" Although one can move files using Fortran's intrinsic rename, "
" we don't know whether the user has not created additional files in "
" the temporary working directory => it is easiest to use a system call "
" to move all files from the temporary working directory to the user code "
" directory. "
REPLACE {$move_file} WITH {'mv -f '};

" There appears to be no way of removing a directory from Fortran "
" => we use a system call for this. "
REPLACE {$remove_directory} WITH {'rm -rf '};

" The directory separator "
REPLACE {$file_sep} WITH {'/'};

REPLACE {$LONG_INT} WITH { integer*8 };
REPLACE {$SHORT_INT} WITH { integer*2 };
"$MAX_INT SET TO 2^63-1 in egsnrc.macros"
"The machine byte order"
REPLACE {$BYTE_ORDER} WITH {'1234'};
;
" Record Length for unformatted I/O "
REPLACE {$RECL-FACTOR} WITH {4};
;
REPLACE {$FLUSH_UNIT(#);} WITH {call flush({P1});}
;
" If you want your user code to return an exit status, use the
" following macro to terminate execution
REPLACE {$CALL_EXIT(#);} WITH {call exit({P1});}
;
" mortran3 gets confused by the # char => we need to pass it as an "
" argument to the macro. "
REPLACE {$HAVE_C_COMPILER(#);} WITH {{EMIT;{P1}define HAVE_C_COMPILER};}
;
REPLACE {$HAVE_LOAD_DSO(#);} WITH {{EMIT;{P1}define HAVE_LOAD_DSO};}
;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc macros for ranmar random number generator                           "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2000                                       "
"                   Dave Rogers, 2000                                         "
"                                                                             "
"  Contributors:                                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Implementation for EGSnrc of the RANMAR random number generator (RNG),     "
"  proposed by Marsaglia and Zaman.                                           "
"                                                                             "
"  Note that this implementation uses integers to store the state of the RNG  "
"  and to generate the next number in the sequence. Only at the end are the   "
"  random numbers are converted to reals by a multiplication with 2**(-24)    "
"  (there are only 24 significant bits). I found the integer implementation   "
"  to be about 30% faster then using reals on Pentium III machines, and       "
"  nearly 70% faster on older SGI workstations.                               "
"                                                                             "
"  To use this set of macros, you need to initialize the RNG by a call to     "
"  init_ranmar (in ranmar.mortran) or read-in a valid RNG state using the     "
"  macro $RETRIEVE RNG STATE FROM UNIT #;                                     "
"                                                                             "
"#############################################################################"


REPLACE {$NRANMAR} WITH {128}
REPLACE {;COMIN/RANDOM/;} WITH
{;
   common/randomm/ rng_array($NRANMAR), urndm(97), crndm, cdrndm, cmrndm,
                   i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed;
   integer*4       urndm, crndm, cdrndm, cmrndm, i4opt,
                   ixx, jxx, fool_optimizer,rng_seed,rng_array;
   real*4          twom24;
}
"in the above, rng_seed is typed and part of common because it is"
" initialized in BLOCK DATA for the ranlux rng.                  "
" It is not actually used by ranmar."

" The following is the $RANDOMSET macro for EGSnrc."
" Found that using integers it is faster by about 30% on a PIII CPU"
" (which is the NRC computer environment                           "

" Found that when the RNG is not inlined, code runs faster "
" Presumambly because the executable shrinks by a significant amount "
" Iwan Kawrakow, May 2003 "

REPLACE {$RANDOMSET#;} WITH {;
  IF( rng_seed > $NRANMAR ) call ranmar_get;
  {P1} = rng_array(rng_seed)*twom24; rng_seed = rng_seed + 1;
};

"REPLACE {$RANDOMSET#;} WITH
"{
"    i4opt = urndm(ixx) - urndm(jxx);
"    IF(i4opt < 0) i4opt = i4opt + 16777216;
"    urndm(ixx) = i4opt;
"    ixx = ixx - 1; jxx = jxx - 1;
"    IF(ixx = 0)        [ ixx = 97; ]
"    ELSE IF( jxx = 0 ) [ jxx = 97; ]
"    crndm = crndm - cdrndm;
"    IF(crndm < 0) crndm = crndm + cmrndm;
"    i4opt = i4opt - crndm;
"    IF(i4opt < 0) i4opt = i4opt + 16777216;
"    {P1} = twom24*i4opt;
"}
;

REPLACE {$RNG-INITIALIZATION;} WITH { ;call init_ranmar; }

REPLACE {$RNG-DEFAULT-INITIALIZATION;} WITH {;
    ixx=0; jxx=0; call init_ranmar;
};

REPLACE {$INITIALIZE RNG USING # AND #; } WITH {;
  ixx = {P1}; jxx = {P2};
  call init_ranmar;
};

"**************************************************************************"
" The macros below are not essential for the operation of the RNG,         "
" they are defined for convinience in our NRC user codes                   "
"**************************************************************************"

REPLACE {$STORE RNG STATE ON UNIT #;} WITH
{
    rewind({P1});
    write({P1},*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
                  rng_array;
}

REPLACE {$PUT RNG STATE ON UNIT #;} WITH
{
    write({P1},*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
                  rng_array;
}

REPLACE {$RETRIEVE RNG STATE FROM UNIT #;} WITH {;
    read({P1},*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
                 rng_array;
    twom24 = 1./16777216.;  "just in case it is not initialized in rmarin"
};

REPLACE {$SHOW-RNG-STATE(#);} WITH {;
   write({P1},'(a,2i4,$)') ' ixx jxx = ',ixx,jxx;
};

REPLACE {$PRINT-RNG-STATE(#,#);} WITH {;
   write({P1},{P2}) ixx,jxx;
};

REPLACE {$RNG-INPUTS(#,#,#,#);} WITH {;
   ival = ival + 1;
   VALUES_SOUGHT(IVAL)={P1};
   nvalue(ival) = 2;
   type(ival)   = 0;
   value_min(ival) = 1;
   value_max(ival) = 30081;
   default(ival)   = 9373;
   delimeter = {P2};
   nmin = ival; nmax = ival;
   call get_input;
   IF( error_flags(ival) = 0 ) [
       {P3} = value(ival,1);
       {P4} = value(ival,2);
   ]
   ELSE [ {P3} = 0; {P4} = 0; ]
};

REPLACE {$RNG-STRING-1} WITH {' 1st initial random number seed: '}
REPLACE {$RNG-STRING-2} WITH {' 2nd initial random number seed: '}

"            end of ranmar.macros         "
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc transport parameter macros                                          "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Iwan Kawrakow, 2003                                       "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                   Ernesto Mainegra-Hing                                     "
"                                                                             "
"#############################################################################"
"                                                                             "
"  These macros are used in conjunction with the get_inputs.mortran routines  "
"  to read in EGSnrc transport physics parameters. Specifically with          "
"  subroutine get_transport_parameter.                                        "
"                                                                             "
"  The following are definitions of code words (values sought) for the        "
"  various transport parameters that can be set. I hope they are              "
"  self-explanatory. If you don't like them:                                  "
"                                                                             "
"  - include this file via the configuration file BEFORE your user code.      "
"                                                                             "
"  - Replace the macros in your user code with code words that you prefer.    "
"                                                                             "
"#############################################################################"


REPLACE {$GLOBAL_ELECTRON_CUTOFF} WITH {'Global ECUT'}
REPLACE {$GLOBAL_PHOTON_CUTOFF}   WITH {'Global PCUT'}
REPLACE {$GLOBAL_SMAX}            WITH {'Global SMAX'}
REPLACE {$INCOHERENT_SCATTERING}  WITH {'Bound Compton scattering'}
REPLACE {$RADC_COMPTON}           WITH {'Radiative Compton corrections'}
REPLACE {$COHERENT_SCATTERING}    WITH {'Rayleigh scattering'}
REPLACE {$ATOMIC_RELAXATIONS}     WITH {'Atomic relaxations'}
REPLACE {$PE_ANGULAR_SAMPLING}    WITH {'Photoelectron angular sampling'}
REPLACE {$BREMS_ANGULAR_SAMPLING} WITH {'Brems angular sampling'}
REPLACE {$BREMS_CROSS_SECTIONS}   WITH {'Brems cross sections'}
REPLACE {$PAIR_ANGULAR_SAMPLING}  WITH {'Pair angular sampling'}
REPLACE {$PAIR_CROSS_SECTIONS}    WITH {'Pair cross sections'}
REPLACE {$TRIPLET_PRODUCTION}     WITH {'Triplet production'}
REPLACE {$ELECTRON_IMPACT_IONI}   WITH {'Electron Impact Ionization'}
REPLACE {$SPIN_EFFECTS}           WITH {'Spin effects'}
REPLACE {$MAXIMUM_ESTEPE}         WITH {'ESTEPE'}
REPLACE {$MAXIMUM_XIMAX}          WITH {'XImax'}
REPLACE {$SKIN_FOR_BCA}           WITH {'Skin depth for BCA'}
REPLACE {$BOUNDARY_ALGORITHM}     WITH {'Boundary crossing algorithm'}
REPLACE {$ELECTRON_STEP_ALG}      WITH {'Electron-step algorithm'}
REPLACE {$ON_IN_REGIONS}          WITH {'On in Regions'}
REPLACE {$OFF_IN_REGIONS}         WITH {'Off in Regions'}
REPLACE {$IN_REGIONS}             WITH {'Regions'}
REPLACE {$THE_DELIMETER}          WITH {'MC TRANSPORT PARAMETER'}
REPLACE {$PHOTON_XSECTIONS}       WITH {'Photon cross sections'}
REPLACE {$COMPTON_XSECTIONS}      WITH {'Compton cross sections'}
REPLACE {$PHOTON_XSECTIONS_OUT}   WITH {'Photon cross-sections output'}
REPLACE {$SCALE_L_EII_XSECTIONS}  WITH {'scale L EII cross-sections'}
"Ali:photonuc, 2 lines"
"Cannot use $PHOTONUC; it clashes with other variables"
REPLACE {$PHOTO_NUCLEAR}          WITH {'Photonuclear attenuation'}
REPLACE {$PHOTONUC_XSECTIONS}     WITH {'Photonuclear cross sections'}
REPLACE {$B_FIELD} WITH {'Magnetic Field'}
REPLACE {$E_FIELD} WITH {'Electric Field'}
REPLACE {$EM_LMT} WITH {'EM ESTEPE'}
;

REPLACE {$TURN-ON/OFF-IN-REGIONS(#,#,#,#);} WITH
{;
aux_inregions = .false.;
IF( error_flags({P1}) = 0 ) [
    write(i_log,*) {P2};
    itmp = value({P1},1);
    IF( itmp = 2 | itmp = 3 ) [
        ival                = ival + 1;
        values_sought(ival) = {P2};
        nvalue(ival)        = 0;
        type(ival)          = 0;
        value_min(ival)     = 1;
        value_max(ival)     = $MXREG;
        default(ival)       = 1;
        ival                = ival + 1;
        values_sought(ival) = {P3};
        nvalue(ival)        = 0;
        type(ival)          = 0;
        value_min(ival)     = 1;
        value_max(ival)     = $MXREG;
        default(ival)       = 1;
        Nmin = ival-1; Nmax = ival;
        CALL GET_INPUT;
        IF( error_flags(ival-1) = 0 & error_flags(ival) = 0 ) [
            IF( nvalue(ival) = nvalue(ival-1) ) [
                iitmp = itmp-2;
                DO j=1,$MXREG [ {P4}(j) = iitmp; ]
                 "i.e. set everywhere to 0 (if turn on) or 1 (if turn off)"
                iitmp = 1 - iitmp;
                 "and then re-set in the specified regions"
                DO k=1,nvalue(ival) [
                    istart = value(ival-1,k);
                    iend = value(ival,k);
"Ali:photonuc, 2 lines to crudely print start/stop regions"
                    write(i_log,*) {P2},istart;
                    write(i_log,*) {P3},iend;
                    IF( istart <= iend ) [
                        DO j=istart,iend [ {P4}(j) = iitmp; ]
                        aux_inregions = .true.;
                    ]
                ]
            ]
            ELSE [ value({P1},1) = {P4}(1); ]
        ]
        ELSE [ value({P1},1) = {P4}(1); ]
    ]
    ELSE [
        IF( itmp > 3 ) itmp = itmp-2;
        write(i_log,*) ' Setting all to ',itmp;
        DO j=1,$MXREG [ {P4}(j) = itmp; ]
    ]
]
ELSE ["Use default value"
  "Check if default is other than ON or Off"
  "and shift as no input by regions requested"
  IF({P4}(1) = 2 | {P4}(1) = 3)[
    value({P1},1) = {P4}(1)+2;
  ]
  ELSE[
    value({P1},1) = {P4}(1);
  ]
]

};

REPLACE{$SET # IN REGIONS(#,#,#,#,#,#,#);} WITH
{;

aux_inregions = .false.;
ival                = ival + 1;
{P2}                = ival;
values_sought(ival) = {P6};
nvalue(ival)        = 0;
type(ival)          = 1;
value_min(ival)     = {P3};
value_max(ival)     = {P4};
default(ival)       = {P5};

ival                = ival + 1;
values_sought(ival) = {P7};
nvalue(ival)        = 0;
type(ival)          = 0;
value_min(ival)     = 1;
value_max(ival)     = $MXREG;
default(ival)       = 1;

ival                = ival + 1;
values_sought(ival) = {P8};
nvalue(ival)        = 0;
type(ival)          = 0;
value_min(ival)     = 1;
value_max(ival)     = $MXREG;
default(ival)       = 1;

Nmin = {P2}; Nmax = {P2}+2; error_flag = 0;
CALL GET_INPUT;

IF( error_flag = 0 ) [
    IF( nvalue({P2}) = nvalue(ival) & nvalue(ival-1) = nvalue(ival) ) [
        DO k=1,nvalue(ival) [
            istart = value(ival-1,k);
            iend = value(ival,k);
            IF( istart <= iend ) [
                DO j=istart,iend [ {P1}(j) = value({P2},k); ]
                aux_inregions = .true.;
            ]
        ]
    ]
]
};
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc pegs4 macros                                                        "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Blake Walters, 2013                                       "
"                                                                             "
"  Contributors:    Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The content of this file was adapted from the original pegs4 source code   "
"  to enable on-the-fly pegs data generation in EGSnrc. Please see the pegs4  "
"  sources for more information on the authorship of the original code.       "
"                                                                             "
"#############################################################################"


"Compiler directives"
"==================="
%Q1         "Automatically close comments at end of line
            "but this DOES NOT apply withing macro definitions!!
%C80        "Allow 80 columns of source/line (default is 72)
%L          "Turn on listing

"MACROS TO SPLIT LONG STRING INTO A1 STRINGS"
REPLACE {$S'{SYMBOL}#'} WITH
   {'#1'[IF]{EXIST 2}[,$S'{P2}']};

"pegs4 uses single precision.  real*8 causes problems"
REPLACE {$REAL4} WITH {real*4};

PARAMETER $MXSTC=73;"NUMBER OF MEDIA WITH STERNHEIMER COEFFICIENTS"
PARAMETER $RERR=1.E-5;      "RERR-VALUE NEEDED BY DCADRE"
PARAMETER $AERR=1.E-16;     "AERR-VALUE NEEDED BY DCADRE"
PARAMETER $FUDGEMS=1.0;  "FULL MS OFF ATOMIC ELECTRONS"

REPLACE {;COMIN/LBREMZ/;} WITH {
  ;COMMON/LBREMZ/CONST,DELC,EBREMZ,DELTAM,XLNZ;
   $REAL4 CONST,DELC,EBREMZ,DELTAM,XLNZ;
}

REPLACE {;COMIN/PMCONS/;} WITH
   {;COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN;
     $REAL4 PIP,C,RME,HBAR,ECGS,EMKS,AN;
   };

REPLACE {;COMIN/DERCON/;} WITH
   {;COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680;
     $REAL4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680;
   };

REPLACE {;COMIN/THRESHP/;} WITH
   {;COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP;
     $REAL4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP;
     $INTEGER IUNRSTP;
   };

REPLACE {;COMIN/BREMPRP/;} WITH
   {;COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6),
    DELCMP,ALPHIP(2),BPARP(2),DELPOSP(2);
    $REAL4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP;
   };

REPLACE {;COMIN/EPSTAR/;} WITH
   {;
     COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20),
     EPSTTL,NEPST,IEPST,EPSTFLP,
     NELEPS,ZEPST(20),IAPRFL,IAPRIMP;
     $INTEGER    ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP;
     CHARACTER   EPSTTL*80;
     $REAL4       EPSTEN,EPSTD,WEPST;
   };

    "THIS COMMON IS USED FOR OPTION WHICH READS IN DENSITY EFFECT "
    "CORRECTION IN SPINIT AND CALCULATES USING IT IN SPIONB       "
    "THE FLAG EPSTFL IS READ UNDER NAMELIST INPUT, AND DEFAULTS   "
    "   TO ZERO IN THE BLOCK DATA. SET TO UNITY TO USE THE OPTION "
    "PEGS USES THE I-VALUE IN THE DENSITY INPUT FILE              "
    "VARIOUS CHECKS ARE DONE TO ENSURE THE DENSITY CORRECTION     "
    "   CORRESPONDS TO THE MATERIAL DEFINITION IN PEGS            "
    "THE ENERGY TABLE READ IN IS ASSUMED TO BE KINETIC ENERGY IN  "
    "   MEV BUT IS CONVERTED TO TOTAL ENERGY BY THE CODE.         "
    "THE ENERGY OPTION MUST BE USED IN PEGS PRIOR TO THE MIXT,COMP"
    "   OR ELEM OPTIONS TO ALLOW ALL THE CHECKS TO WORK PROPERLY. "
    "NELEPS IS THE NUMBER OF ELEMENTS IN THE MATERIAL             "
    "ZEPST(I) (INTEGER), WEPST(I) ARE THE Z VALUE AND FRACTION    "
    "   BY WEIGHT OF THE I-TH ELEMENT IN THE DATA FILE.           "
    "IAPRIM is a flag to tell which correction to the bremsstrahlung        "
    "       cross section to use:      0 =>  old Koch and Motz    "
    " =1(defaulat) read in new data file; =2, use no corrections. "
    "IAPRFL is a flag to say if APRIM file has been initialized   "

REPLACE {;COMIN/MOLVAR/;} WITH
   {;COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,
    RLCP,EDEN,RHOP,XCCP,BLCCP,TEFF0P,XR0P;
     $REAL4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP,
       XCCP,BLCCP,TEFF0P,XR0P;
   };

REPLACE {;COMIN/MIMSD/;} WITH
   {;COMMON/MIMSD/BMIN;
     $REAL4 BMIN;
   };

REPLACE {;COMIN/RADLEN/;} WITH
   {;COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183;
     $REAL4 ALRAD,ALRADP,A1440,A183;
   };

"------------------------------------------------------------------"
"*** LSPION--COMMON FOR COMMUNICATION BETWEEN SPINIT AND SPIONB    "
"------------------------------------------------------------------"
REPLACE {;COMIN/LSPION/;} WITH
   {;COMMON/LSPION/CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV;
     $REAL4 CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV;
   };

REPLACE {;COMIN/SPCOMM/;} WITH
   {;COMMON/SPCOMM/MEDTBL(24,$MXSTC),
           NUMSTMED,STDATA(6,$MXSTC);
       $TYPE MEDTBL;
       $INTEGER NUMSTMED;
       $REAL4    STDATA;
   }

REPLACE {;COMIN/PWLFIN/;} WITH
   {;COMMON/PWLFIN/EPE,ZTHRE(8),ZEPE(8),NIPE,NALE;
     $REAL4 EPE,ZTHRE,ZEPE;
     $INTEGER NIPE,NALE;
   };

REPLACE {;COMIN/RSLTS/;} WITH
   {;COMMON/RSLTS/NEL,AXE,BXE,AFE($MXEKE,8),BFE($MXEKE,8);
     $REAL4 AXE,BXE,AFE,BFE;
     $INTEGER NEL;
   };

REPLACE {;COMIN/ELEMTB/;} WITH
   {;COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100);
     $INTEGER NET;
     $REAL4 ITBL,WATBL,RHOTBL;
     $TYPE ASYMT;
   }

REPLACE {;COMIN/MIXDAT/;} WITH
   {;COMMON/MIXDAT/NEP,LMED,PZP($MXEL),ZELEMP($MXEL),WAP($MXEL),RHOZP($MXEL),
     GASPP,EZ,TPZ,IDSTRN(24);
     $INTEGER NEP,LMED;
     $REAL4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ;
     $TYPE IDSTRN;
   }

REPLACE {;COMIN/DBRPR/;} WITH
   {;COMMON/DBRPR/ALFP1(2),ALFP2(2),AL2;
     $REAL4 ALFP1,ALFP2,al2;
   };

"This block contains some media parameters required for"
"cross-section calculations but not covered in any of the"
"egsnrc common blocks.  It also contains $REAL4 versions"
"of some egsnrc media parameters to allow direct comparison"
"with cross-sections calculated by pegs4.mortran"
REPLACE {;COMIN/MEDINP/;} WITH
   {;COMMON/MEDINP/inpdensity_file($MXMED),inpasym($MXMED,$MXEL),
     inpstrn(24,$MXMED),pz4($MXMED,$MXEL),
     rhoz4($MXMED,$MXEL),wa4($MXMED,$MXEL),inpgasp($MXMED);
     character*256 inpdensity_file;
     $TYPE inpasym,inpstrn;
     $REAL4 pz4,rhoz4,wa4,inpgasp;
   };

REPLACE {$DECLARE-PEGS4-COMMON-BLOCKS;} WITH {
;COMIN/LBREMZ,PMCONS,DERCON,EPSTAR,MOLVAR,LSPION,PWLFIN,
RSLTS,SPCOMM,MIXDAT,RADLEN,MIMSD,THRESHP,BREMPRP,ELEMTB,MEDINP/;
$REAL4 XSIFP,WADUM,PZDUM,RHOZDUM,RLCDUM,ALKE,ALKEI;
$INTEGER I01;
EXTERNAL ALKE,ALKEI,EFUNS;
$TYPE MEDTB1(24,20),MEDTB2(24,20),MEDTB3(24,20),MEDTB4(24,13);
EQUIVALENCE (MEDTBL(1,1),MEDTB1(1,1));
EQUIVALENCE (MEDTBL(1,21),MEDTB2(1,1));
EQUIVALENCE (MEDTBL(1,41),MEDTB3(1,1));
EQUIVALENCE (MEDTBL(1,61),MEDTB4(1,1));
$REAL4 STDAT1(6,20),STDAT2(6,20),STDAT3(6,20),STDAT4(6,13);
EQUIVALENCE (STDATA(1,1),STDAT1(1,1));
EQUIVALENCE (STDATA(1,21),STDAT2(1,1));
EQUIVALENCE (STDATA(1,41),STDAT3(1,1));
EQUIVALENCE (STDATA(1,61),STDAT4(1,1));
}

REPLACE {$GET-PEGSLESS-XSECTIONS;} WITH
{;

call get_media_inputs(-1);

DO IM=1,NMED[

  "store values in variables used to calculate cross-sections"
  AEP=AE(IM);
  UEP=UE(IM);
  APP=AP(IM);
  UPP=UP(IM);
  NEP=NNE(IM);
  IUNRSTP=IUNRST(IM);
  IAPRIMP=IAPRIM(IM);
  EPSTFLP=EPSTFL(IM);
  GASPP=INPGASP(IM); "recall gasp not an egsnrc variable"
  RHOP=RHO(IM);
  DO J=1,NEP[
    ZELEMP(J)=ZELEM(IM,J);
    "use the $REAL4 variables from MEDINP for these ones, for now"
    "since these have been calculated using $REAL4 math"
    PZP(J)=PZ4(IM,J);
    RHOZP(J)=RHOZ4(IM,J);
    WAP(J)=WA4(IM,J);
 ]
 DO IB=1,LMDN[
   IDSTRN(IB)=INPSTRN(IB,IM);
 ]
 TEP=AEP-RMP; THMOLLP=AEP+TEP ; "equation in pegs4.mortran"

 IF (UEP.LE.AEP)[
    write(i_log,'(a,24a1)')'  Error: Material not defined: ',
                              (media(j,IM),j=1,24);
    $egs_fatal(*,'Material used in the geometry was not defined in the'
                ,' material data.');
 ]

 CALL MIX; "calculates MS parameters"

 CALL SPINIT(inpdensity_file(IM)); "density corrections, may open density file"

 CALL DIFFER;
"do not know why we call above subroutine since"
"bremsstrahlung cross-sections get reset in fix_brems"

 "now call the piecewise linear fit subroutine to generate the remainder of"
 "the electron cross-sections"
 CALL PWLF1(NEL,NALE,AEP,UEP,THMOLLP,EPE,ZTHRE,ZEPE,NIPE,ALKE,
ALKEI,AXE,BXE,$MXEKE,8,AFE,BFE,EFUNS);

 "cross-sections are now calculated"
 "store generated data in egsnrc variables"

 "recompute the following two, note the different form of the equation for"
 "THMOLL compared to pegs4.mortran"
 TE(IM)=AE(IM)-RM; THMOLL(IM)=TE(IM)*2. + RM ;

 "cross-section parameters"
 RLC(IM)=RLCP;"RLCP gets calculated in MIX"

 XCC(IM)=XCCP;
 BLCC(IM)=BLCCP;
 XR0(IM)=XR0P;
 TEFF0(IM)=TEFF0P;

 "all of the below gets reset in fix_brems"
 DELCM(IM)=DELCMP;
 DO I=1,2[
  ALPHI(I,IM)=ALPHIP(I);
  BPAR(I,IM)=BPARP(I);
  DELPOS(I,IM)=DELPOSP(I);
 ]
 DO I=1,6[
  DL1(I,IM)=DLP1(I);
  DL2(I,IM)=DLP2(I);
  DL3(I,IM)=DLP3(I);
  DL4(I,IM)=DLP4(I);
  DL5(I,IM)=DLP5(I);
  DL6(I,IM)=DLP6(I);
 ]


 "the following egsnrc quantities are all zeroed in the pegs4 generated data"
 "so they shall be zeroed here"
 MSGE(IM)=0;MSEKE(IM)=0;MLEKE(IM)=0;MCMFP(IM)=0;MRANGE(IM)=0;

 "now, the non-zero quantities"
 MGE(IM)=$MXGE; "we do not use PWLF1 for photon quantities"
               "this setting is also done in init_user_photon"
 MEKE(IM)=NEL; "no. of electron energies as determed from PWLF1"

 "now, set secondary egsnrc variables"

 NSGE=MSGE(IM);NGE=MGE(IM);NSEKE=MSEKE(IM);NEKE=MEKE(IM);
 NLEKE=MLEKE(IM);NCMFP=MCMFP(IM);NRANGE=MRANGE(IM);

 "store results of pwlf in egsnrc variables"
 EKE0(IM)=BXE;
 EKE1(IM)=AXE;

 "BFE and AFE were acquired with the call to"
 "PWLF1 above but we need to fill in the arrays"
 DO I=1,NEKE[
    ESIG0(I,IM)=BFE(I,1);
    ESIG1(I,IM)=AFE(I,1);
    PSIG0(I,IM)=BFE(I,2);
    PSIG1(I,IM)=AFE(I,2);
    EDEDX0(I,IM)=BFE(I,3);
    EDEDX1(I,IM)=AFE(I,3);
    PDEDX0(I,IM)=BFE(I,4);
    PDEDX1(I,IM)=AFE(I,4);
    EBR10(I,IM)=BFE(I,5);
    EBR11(I,IM)=AFE(I,5);
    PBR10(I,IM)=BFE(I,6);
    PBR11(I,IM)=AFE(I,6);
    PBR20(I,IM)=BFE(I,7);
    PBR21(I,IM)=AFE(I,7);
    TMXS0(I,IM)=BFE(I,8);
    TMXS1(I,IM)=AFE(I,8);
 ]

"below is for debugging to ensure that"
"pegsless and pegs versions would give identical"
"results if pegsless cross sections were to be"
"read from a file a la pegs"

/*
write(56,'(1X,1P,5E14.5)')RLCP,AEP,APP,UEP,UPP;
write(56,'(1X,14I5)')
$LGN(MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE(IM));
write(56,'(1X,1P,5E14.5)')($LGN(DLP(I)/1,2,3,4,5,6/),I=1,6);
write(56,'(1X,1P,5E14.5)')DELCMP,(ALPHIP(I),BPARP(I),
   DELPOSP(I),I=1,2);
write(56,'(1X,1P,5E14.5)')XR0P,TEFF0P,BLCCP,XCCP;
write(56,'(1X,1P,5E14.5)')BXE,AXE;
write(56,'(1X,1P,5E14.5)')((BFE(I,J),AFE(I,J),J=1,8),I=1,NEKE);
rewind(56);
READ(56,:FLT:) $LGN(RLC,AE,AP,UE,UP(IM));
READ(56,:INT:)
$LGN(MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE(IM));
READ(56,:FLT:)($LGN(DL(I,IM)/1,2,3,4,5,6/),I=1,6);
READ(56,:FLT:)DELCM(IM),($LGN(ALPHI,BPAR,
   DELPOS(I,IM)),I=1,2);
READ(56,:FLT:)$LGN(XR0,TEFF0,BLCC,XCC(IM));
READ(56,:FLT:)$LGN(EKE(IM)/0,1/);
READ(56,:FLT:)
($LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,
   TMXS(I,IM)/0,1/),I=1,NEKE);
rewind(56);
*/

]

"put rescaling here in case we want to plot stopping powers via"
"show_media_parameters below"
"   WE NOW HAVE DATA FOR ALL MEDIA REQUESTED.  NOW DO DISTANCE UNIT"
"   CHANGE.  DATA FROM PEGS IS IN UNITS OF RADIATION LENGTHS."
"   EGS IS RUN IN UNITS OF 'DUNIT' CENTIMETERS, IF DUNIT.GT.0 "
"   OR IN UNITS OF RLC(-DUNIT) CENTIMETERS IF DUNIT.LT.0."
"   THAT IS, A NEGATIVE DUNIT MEANS UNIT IS TO BE THE RADIATION"
"   LENGTH OF THE MEDIUM WHOSE INDEX IS -DUNIT"
DUNITR=DUNIT; "SAVE REQUESTED"
IF(DUNIT.LT.0.0)[ID=MAX0(1,MIN0($MXMED,int(-DUNIT)));
   DUNIT=RLC(ID);]
IF(DUNIT.NE.1.0) [
$egs_info('(a,1PE14.5,E14.5,a)',' DUNIT REQUESTED&USED ARE: ',
         DUNITR,DUNIT,'(CM.)' );
]
DO IM=1,NMED [
DFACT=RLC(IM)/DUNIT; "CONVERTS RL TO DUNITS"
DFACTI=1.0/DFACT;    "CONVERT RL**-1 TO DUNITS**-1"

FOR I=1 TO MEKE(IM) [
$SCALE $LGN(ESIG,PSIG,EDEDX,PDEDX(I,IM)/0,1/) BY DFACTI;
$SCALE $LGN(TMXS(I,IM)/0,1/) BY DFACT;]
$SCALE TEFF0(IM) BY DFACT;
$SCALE BLCC(IM) BY DFACTI;
$SCALE XCC(IM) BY SQRT(DFACTI);
RLDU(IM)=RLC(IM)/DUNIT;
FOR I=1 TO MGE(IM) [$SCALE $LGN(GMFP(I,IM)/0,1/) BY DFACT; ]
] "END IM DO"

"   SCALE VACDST.  UNDO PREVIOUS SCALE, THEN DO NEW."
VACDST=VACDST*DUNITO/DUNIT;
DUNITO=DUNIT; "SAVE OLD DUNIT"

call show_media_parameters(i_log);

;
}

REPLACE {$INIT-PEGS4-VARIABLES;} WITH {
;
"***PHYSICAL AND MATHEMATICAL CONSTANTS                                "
"     C        SPEED OF LIGHT(CM/SEC)                                  "
"     RME      ELECTRON REST MASS(GRAMS)                               "
"     HBAR     PLANCK'S CONSTANT/(2*PI)  (ERG SEC)                     "
"     ECGS     ELECTRON CHARGE (ESU)                                   "
"     EMKS     ELECTRON CHARGE (COULOMB)                               "
"     AN       AVOGADRO'S NUMBER                                       "
PIP=3.1415926536;
C=2.997925E+10;
HBAR=1.05450E-27;
ECGS=4.80298E-10;
EMKS=1.60210E-19;
AN=6.02252E+23;
"***DERIVED CONSTANTS                                                  "
"     RADDEG   ONE RADIAN IN DEGREES                                   "
"     FSC      FINE STRUCTURE CONSTANT                                 "
"     ERGMEV   ONE MILLION ELECTRON VOLTS EXPRESSED IN ERGS            "
"     R0       CLASSICAL ELECTRON RADIUS                               "
"     RM       ELECTRON REST ENERGY IN MEV                             "
RADDEG=180./PIP;
FSC = ECGS**2/(HBAR*C);
"     1.E+7 IS THE NUMBER OF ERGS PER JOULE                            "
ERGMEV = (1.E+6)*(EMKS*1.E+7);
RME = PRM/C**2*ERGMEV;
"We are using RMP instead of PRM because single precision is required"
RMP = PRM;
R0 = (ECGS**2)/(RME*C**2);
RMPSQ = RMP*RMP;
A22P9 = RADDEG*SQRT(4.*PIP*AN)*ECGS**2/ERGMEV;
A6680 = 4.0*PIP*AN*(HBAR/(RME*C))**2*(0.885**2/(1.167*1.13));

"DATA FOR COMMON BLOCK LSPION"
DATA AFACT/0.0/,SK/0.0/,X0/0.0/,X1/0.0/,CBAR/0.0/,IEV/0.0/;

"DATA for COMMON BLOCK SPCOMM"
DATA LMED/24/,NUMSTMED/$MXSTC/;

"DATA for COMMON BLOCK PWLFIN"
DATA EPE/.01/,ZTHRE,ZEPE/16*0.0/,NIPE/20/,NALE/$MXEKE/;

"DATA for COMMON BLOCK MIMSD"
DATA BMIN/4.5/;

"DATA for COMMON BLOCK RADLEN"
DATA ALRAD/5.31,4.79,4.74,4.71/,ALRADP/6.144,5.621,5.805,5.924/,
A1440/1194.0/,A183/184.15/;

DATA MEDTB1/
$S'H2-GAS',18*' ',$S'H2-LIQUID',15*' ',$S'HE-GAS',18*' ',$S'LI',22*' ',
$S'BE',22*' ',$S'C-2.265 G/CM**3',9*' ',$S'C-1.70 G/CM**3',10*' ',
$S'N2-GAS',18*' ',$S'O2-GAS',18*' ',$S'NE-GAS',18*' ',$S'NA',22*' ',
$S'MG',22*' ',$S'AL',22*' ',$S'SI',22*' ',$S'AR-GAS',18*' ',
$S'K',23*' ',$S'CA',22*' ',$S'TI',22*' ',$S'V',23*' ',$S'MN',22*' '
/;

DATA MEDTB2/
$S'FE',22*' ',$S'CO',22*' ',$S'NI',22*' ',$S'CU',22*' ',$S'ZN',22*' ',
$S'GE',22*' ',$S'SE',22*' ',$S'KR-GAS',18*' ',$S'RB',22*' ',
$S'MO',22*' ',$S'AG',22*' ',$S'CD',22*' ',$S'IN',22*' ',$S'SN',22*' ',
$S'XE-GAS',18*' ',$S'CS',22*' ',$S'GD',22*' ',$S'TA',22*' ',
$S'W',23*' ',$S'PT',22*' '
/;

DATA MEDTB3/
$S'AU',22*' ',$S'HG',22*' ',$S'PB',22*' ',$S'RN-GAS',18*' ',
$S'U',23*' ',
$S'AIR-GAS',17*' ',$S'CO2-GAS',17*' ',$S'POLYETHYLENE',12*' ',
$S'POLYPROPYLENE',11*' ',$S'XYLENE',18*' ',$S'TOLUENE',17*' ',
$S'NYLON',19*' ',$S'VINYLTOLUENE',12*' ',$S'A150-PLASTIC',12*' ',
$S'STILBENE',16*' ',$S'POLYSTYRENE',13*' ',$S'ANTHRACENE',14*' ',
$S'LEXAN',19*' ',$S'LUCITE',18*' ',$S'H2O',21*' '
/;

DATA MEDTB4/
$S'MYLAR',19*' ',
$S'KAPTON',18*' ',$S'LIF',21*' ',$S'POLYVINYL-CL',12*' ',
$S'PYREX-GLASS',13*' ',$S'SIO2',20*' ',$S'CAF2',20*' ',
$S'PHOTOEMULSION',11*' ',$S'AGCL',20*' ',$S'NAI',21*' ',
$S'LII',21*' ',$S'AGBR',20*' ',$S'CSI',21*' '
/;

DATA STDAT1/
0.03535,6.790,1.864,3.5,19.2,9.584,
0.09179,5.831,0.476,2.0,21.8,3.263,
0.0114,7.625,2.202,4.0,41.8,11.139,
0.3492,3.233,0.0966,2.0,40.0,3.122,
0.3518,3.034,-0.0089,2.0,63.7,2.785,
0.5848,2.360,-0.0089,2.0,78.0,2.868,
0.7154,2.191,-0.0089,2.0,78.0,3.155,
0.2120,3.041,1.738,4.0,82.0,10.540,
0.2666,2.825,1.754,4.0,95.0,10.700,
0.1202,3.357,2.073,4.5,137.0,11.904,
0.2204,3.103,0.4515,2.8,149.0,5.053,
0.1714,3.223,0.2386,2.8,156.0,4.530,
0.3346,2.795,0.0966,2.5,166.0,4.239,
0.3755,2.720,0.0966,2.5,173.0,4.435,
0.1902,2.982,1.764,4.5,188.0,11.948,
0.3041,2.674,0.2386,3.0,190.0,5.642,
0.2177,2.874,0.1751,3.0,191.0,5.040,
0.1782,2.946,0.0485,3.0,233.0,4.445,
0.1737,2.935,-0.0089,3.0,245.0,4.266,
0.1996,2.812,-0.0089,3.0,272.0,4.270
/;

DATA STDAT2/
0.2101,2.771,-0.0089,3.0,286.0,4.291,
0.2229,2.713,-0.0089,3.0,297.0,4.260,
0.2504,2.619,-0.0089,3.0,311.0,4.312,
0.2557,2.613,-0.0089,3.0,322.0,4.419,
0.3163,2.468,0.0485,3.0,330.0,4.691,
0.2809,2.647,0.2386,3.0,350.0,5.141,
0.2979,2.635,0.2386,3.0,348.0,5.321,
0.1519,3.030,1.716,4.8,352.0,12.512,
0.1450,3.078,0.4515,3.5,363.0,6.478,
0.2228,2.824,0.1751,3.0,424.0,4.879,
0.3091,2.563,-0.0089,3.0,470.0,5.063,
0.1853,2.819,0.0485,3.3,469.0,5.273,
0.2004,2.790,0.1751,3.3,487.0,5.517,
0.1898,2.839,0.2386,3.3,488.0,5.534,
0.1329,3.020,1.563,5.0,482.0,12.728,
0.2214,2.784,0.4515,3.5,488.0,6.914,
0.2068,2.686,0.0485,3.5,591.0,5.874,
0.1663,2.805,0.1751,3.5,718.0,5.526,
0.1499,2.870,0.1751,3.5,727.0,5.406,
0.1465,2.903,0.0966,3.5,790.0,5.473
/;

DATA STDAT3/
0.1533,2.881,0.0966,3.5,790.0,5.575,
0.1824,2.798,0.2386,3.5,800.0,5.961,
0.1861,2.814,0.2386,3.5,823.0,6.202,
0.1130,3.023,1.537,5.3,794.0,13.284,
0.1362,3.034,0.2386,3.5,890.0,5.869,
0.2466,2.879,1.742,4.0,85.7,10.595,
0.1999,3.022,1.648,4.0,88.7,10.239,
0.4875,2.544,0.1379,2.0,57.4,3.002,
0.2493,2.975,0.1537,2.3,59.2,3.126,
0.2755,2.911,0.1695,2.3,61.8,3.270,
0.2830,2.890,0.1722,2.3,62.5,3.303,
0.5345,2.439,0.1336,2.0,63.9,3.063,
0.3495,2.749,0.1467,2.2,64.7,3.201,
0.5462,2.435,0.1329,2.0,65.1,3.110,
0.2989,2.851,0.1731,2.3,67.7,3.367,
0.3670,2.724,0.1647,2.2,68.7,3.300,
0.5858,2.364,0.1146,2.0,69.5,3.151,
0.3865,2.664,0.1608,2.2,73.1,3.321,
0.3996,2.606,0.1824,2.2,74.0,3.330,
0.2065,3.007,0.2400,2.5,75.0,3.502
/;

DATA STDAT4/
0.3124,2.782,0.1561,2.3,78.7,3.326,
0.4061,2.614,0.1492,2.2,79.3,3.342,
0.1308,3.476,0.0171,2.5,94.0,3.167,
0.1873,2.962,0.1558,2.8,108.2,4.053,
0.2988,2.805,0.1479,2.5,134.0,3.971,
0.1440,3.220,0.1385,2.8,139.2,4.003,
0.3750,2.592,0.0676,2.5,166.0,4.065,
0.3416,2.496,0.1009,3.0,331.0,5.332,
0.1243,3.002,-0.0138,3.5,398.4,5.344,
0.1560,2.926,0.1203,3.5,452.0,6.057,
0.1785,2.845,0.0892,3.5,485.1,6.267,
0.1351,2.976,0.0358,3.5,487.2,5.616,
0.1796,2.840,0.0395,3.5,553.1,6.281
/;

DATA NET/100/;

DATA ITBL/19.2,41.8,40.,63.7,76.0,78.0,82.0,95.0,115.,137.,
 149.,156.,166.,173.,173.,180.,174.,188.,190.,191.,216.,233.,245.,
 257.,272.,286.,297.,311.,322.,330.,334.,350.,347.,348.,357.,352.,
 363.,366.,379.,393.,417.,424.,428.,441.,449.,470.,470.,469.,488.,
 488.,487.,485.,491.,482.,488.,491.,501.,523.,535.,546.,560.,574.,
 580.,591.,614.,628.,650.,658.,674.,684.,694.,705.,718.,727.,736.,
 746.,757.,790.,790.,800.,810.,823.,823.,830.,825.,794.,827.,826.,
 841.,847.,878.,890.,902.,921.,934.,939.,952.,966.,980.,994./;

DATA WATBL/1.00797,4.0026,6.939,9.0122,10.811,12.01115,14.0067,
 15.9994,18.9984,20.183,22.9898,24.312,26.9815,28.088,30.9738,
 32.064,35.453,39.948,39.102,40.08,44.956,47.90,50.942,51.998,
 54.9380,55.847,58.9332,58.71,63.54,65.37,69.72,72.59,74.9216,
 78.96,79.808,83.80,85.47,87.62,88.905,91.22,92.906,95.94,99.0,
 101.07,102.905,106.4,107.87,112.4,114.82,118.69,121.75,127.60,
 126.9044,131.30,132.905,137.34,138.91,
 140.12,140.907,144.24,147.,150.35,151.98,157.25,158.924,162.50,
 164.930,167.26,168.934,173.04,174.97,178.49,180.948,183.85,
 186.2,190.2,192.2,195.08,196.987,200.59,204.37,207.19,208.980,
 210.,210.,222.,223.,226.,227.,232.036,231.,238.03,237.,242.,
 243.,247.,247.,248.,254.,253./;

 DATA RHOTBL/0.0808,0.19,0.534,1.85,2.5,2.26,1.14,1.568,1.5,1.0,
 0.9712,1.74,2.702,2.4,1.82,2.07,2.2,1.65,0.86,1.55,3.02,4.54,
 5.87,7.14,7.3,7.86,8.71,8.90,8.9333,7.140,5.91,5.36,5.73,4.80,
 4.2,3.4,1.53,2.6,4.47,6.4,8.57,9.01,11.50,12.20,12.50,12.,10.5,
 8.65,7.30,7.31,6.684,6.24,4.93,2.7,1.873,3.5,6.15,6.90,6.769,
 7.007, 1.  ,7.54,5.17,7.87,8.25,8.56,8.80,9.06,9.32,6.96,9.85,
 11.40,16.60,19.30,20.53,22.48,22.42,21.45,19.30,14.19,11.85,
 11.34,9.78,9.30, 1.  ,4., 1.  ,5.,  1. ,11.0,15.37,18.90,
 20.5,19.737,11.7,7.,1.   , 1.  , 1.  ,  1. /;

DATA ASYMT/'H','HE','LI','BE','B','C','N','O','F','NE',
 'NA','MG','AL','SI','P','S','CL','AR','K','CA','SC','TI',
 'V','CR','MN','FE','CO','NI','CU','ZN','GA','GE','AS','SE','BR',
 'KR','RB','SR','Y','ZR','NB','MO','TC','RU','RH','PD','AG','CD',
 'IN','SN','SB','TE','I','XE','CS','BA','LA','CE','PR','ND',
 'PM','SM','EU','GD','TB','DY','HO','ER','TM','YB','LU','HF','TA',
 'W','RE','OS','IR','PT','AU','HG','TL','PB','BI','PO','AT','RN',
 'FR','RA','AC','TH','PA','U','NP','PU','AM','CM','BK','CF','ES',
 'FM'/;

"for COMMON BLOCK EPSTAR"
DATA EPSTFLP/0/,IEPST/1/,IAPRIMP/1/,IAPRFL/0/;

}

;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc user macros                                                 "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Daryoush Sheikh-Bagheri                                   "
"                   Dave Rogers                                               "
"                   Iwan Kawrakow                                             "
"                   Frederic Tessier                                          "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"
"                                                                             "
"  A set of MORTRAN replacement macros for BEAMnrc that are available for     "
"  modification.                                                              "
"                                                                             "
"#############################################################################"


%Q1
%C80
!INDENT F4;
!INDENT M4;
;
REPLACE {$USER_MACROS_VERSION}
WITH {' '}
" **********************
" Array size definition:
" **********************
REPLACE {$MAX_CMs} WITH {25}       "maximum number of CMs allowed"
REPLACE {$MAX_CMsP1} WITH {{COMPUTE $MAX_CMs+1}}  "MAX_CMs+1"
REPLACE {$NCASEMIN} WITH {100}     "min no. of cases in 1 run
REPLACE {$NBATCH} WITH {10}        "no. of batches run is divided up into
REPLACE {$COVMIN} WITH {10}        "min. no. of particles crossing a scoring"
                                   "zone for which covariance will be"
                                   "included in uncertainty estimate (for"
                                   "average energy/angle only)"
REPLACE {$MXMED} WITH {12}         "max # of media
REPLACE {$MXREG} WITH {3000}        "maximum number of regions (absolute)
REPLACE {$MXSTACK} WITH {10000}    "maximum stack (much less if no brem split)
REPLACE {$MAXBRSPLIT} WITH {2000}  "maximum number of bremsstrahlung splits
                                   "note that $MXSTACK must be adjusted too
REPLACE {$MAX_DOSE_ZONE} WITH {1500} "maximum number of dose-scoring zones
REPLACE {$MAXIT} WITH {12}         "maximum number of dose components to score
REPLACE {$MAX_SC_PLANES} WITH {3}  "maximum number of fluence scoring planes
REPLACE {$MAX_SC_ZONES} WITH {5}   "no. of radial scoring zones on each fluence
"                                   scoring plane, minimum 2
REPLACE {$MAX_SC_PARAMETERS} WITH {8} "number of parameters scored
 "Index 1 through 4 in scoring array - 1st crossing of scoring plane
 "Index 4 through 8 - particle or ancestors crossed scoring plane at least once
 "Index 1 & 5-number, 2 & 6-fluence, 3 & 7-energy, 4 & 8-angle wrt z-axis"
REPLACE {$MAXPTS_SRC9} WITH {10}   "no of discrete points for source 9"
REPLACE {$MXRDIST} WITH {1000}"no of POINTS IN RADIAL DISTRIBUTION FIT--src 15"

"$MXSTACK=2000 and $MAXBRSPLIT=250 are settings which allow selective
"bremsstrahlung spltting

;
" *****************************
" Parameter replacement macros:
" *****************************
REPLACE {$BDY_TOL} WITH {1.E-5}    "boundary tolerance for HOWFAR_$CMNAME
                                   "to account for round-off error
REPLACE {$MIN_GAP} WITH {0.01}     "minimum air gap allowed between CM's
REPLACE {$ONE-EPS} WITH {0.9999}   "used to keep the source inside target
;
;
"                               LATCH MACROS ""toc:
"                               ***********
"
REPLACE {$LATCH_NUMBER_OF_BITS} WITH {5}
"$LATCH_NUMBER_OF_BITS is the number of bits used to record the region number,
"when a secondary is created, using LATCH. If $LATCH_NUMBER_OF_BITS is set to
"5, for example, bits 1 - 23 will be used for region bit set, bit 0 is used
"to record whether the particle is a descendant of a brem photon while bits
"24 - 28 (5 bits) will be used to record the region number. Bits 29 -31 are
"reserved for rw-ph-sp. However, during a run bit 30 will be used for
"contamination calculations.
"
" ***************************************
" macros related to bit setting for LATCH
" ***************************************
"
"   note BTEST etc are standard F77 extensions because of US military
"   contract requirements

"Macro to set bit {P2} in {P1}  to 1
REPLACE {$IBSET(#,#);} WITH {IBSET({P1},{P2});}

"Macro to set test bit {P2} in {P1}
"      Note this may require a LOGICAL declaration wherever used"
REPLACE {$BTEST(#,#)} WITH {BTEST({P1}, {P2}) }

"Macro to set bit {P2} in {P1}  to 0   "
REPLACE {$IBCLR(#,#);} WITH {IBCLR({P1},{P2});}
"note that above macros are defined in nrcc4mac.mortran, but may not
"     be in earlier versions and so are included here.
;
"******************************
"V>BEAM CHARACTERIZATION MODELS
"******************************
"V>The following are the defaults for beam characterization models;

REPLACE {;COMIN/BMODEL/;} WITH {;}
;
REPLACE {$BEAMMODEL_SOURCE_INPUT} WITH {
    OUTPUT;(///' SORRY, BEAM CHARACTERIZATION MODELS NOT IMPLEMENTED'//
               ' PLEASE START AGAIN WITH OTHER SOURCES'///);
    STOP; }
;
REPLACE {$LOCAL-VARIABLES-SOURCE31} WITH {;}
REPLACE {$BEAMMODEL_SOURCE_OUTPUT} WITH {;}
REPLACE {$BEAMMODEL_INITIAL_ENERGY} WITH {;}
REPLACE {$BEAMMODEL_SOURCE_SAMPLING} WITH {
  OUTPUT; (///' BEAM CHARACTERIZATION MODELS NOT IMPLEMENTED'///);}
REPLACE {$BEAMMODEL_INPUT_OPTION} WITH {
 ;IF(IO_OPT > 1 & IO_OPT<4)[
    OUTPUT;(///' BEAM CHARACTERIZATION MODELS NOT IMPLEMENTED'//
               ' PLEASE USE OPTION 0 OR 1 FOR IO_OPT INSTEAD'///);
    STOP;];
}
REPLACE {$BEAMMODEL_READ_FILE} WITH {;}
REPLACE {$BEAMMODEL_OSUMRY} WITH {;}
REPLACE {$BEAMMODEL_DATA_ANALYSIS} WITH {;}
REPLACE {$BEAMMODEL_DATA_OUTPUT} WITH {;}
REPLACE {$BEAMMODEL_SRCOUT} WITH {;}
REPLACE {$BEAMMODEL_PASSING_VARIABLES} WITH {;}
;

"If this is a beam shared library source that uses a phase space"
"source and it is running in parallel, then the following macro"
"gets replaced by code that specifies the portion of the phase"
"space source to use"
REPLACE {$SET_INPHSP_BEAM_SOURCE_PARALLEL;} WITH {;}

;

"****************************************
"   Phase-space output macros
"****************************************
"
"   note:Use one of these macros if you
"        want your phase space file
"        stored in different location
"        (change requires recompilation)
"
" The following is the default which is the standard way of
" doing it, the phase space file is stored on local user code
" directory
REPLACE {$DIRECTORY-FOR-PHSP} WITH {$cstring(egs_home)//$cstring(user_code)};
"
" The following is to enable storing file at some other location.
" for example, at location '/data/data005/somedir'
"REPLACE {$DIRECTORY-FOR-PHSP} WITH {'/data/data005/somedir'};"

"******************************************************************************
;
"                        CUSTOM USER MACROS FOR BEAM
"                        ***************************
"
"  User replacement macros can be changed here or else in a separate file
"  (to be concatenated with the code by modifying the sources.make file
"   in your accelerator directory) to perform user-specified functions.
;
"user macro executed in AUSGAB.  Executed before anything else in AUSGAB."
REPLACE {$USER-AUSGAB;} WITH {;}

"macro for inputting/initializing custom variables"
REPLACE {$USER-INIT;} WITH {;}

"tasks to be performed at the end of the run (eg data analysis, output)"
REPLACE {$USER-FINISH;} WITH {;}

"extra data to be written to .egsdat file for restarts, recombination"
"after parallel.  {P1} is the unit number of the file."
REPLACE {$USER-WRITE-DAT(#);} WITH {;}

"extra data to be from .egsdat file for restarts, recombination"
"after parallel.  {P1} is the unit number of the file."
REPLACE {$USER-READ-DAT(#);} WITH {;}

"allow definition of custom user variables to add to USER common blocks"
REPLACE {;COMIN/USER-CUSTOM-VARIABLES/;} WITH {;}

"macro in subroutine combine_results which will allow user to recombine"
"their own data after a parallel run"
REPLACE {$USER-COMBINE-RESULTS;} WITH {;}
REPLACE {$USER-ADD-DATA(#);} WITH {;}
REPLACE {$USER-RESET-DATA;} WITH {;}

"macro at the top of subroutine kill_the_photons to allow user to modify"
"how this is done."
REPLACE {$USER-KILL-PHOTONS;} WITH {;}

"macro for user to do things just before a call to shower"
REPLACE {$USER-BEFORE-SHOWER;} WITH {;}

"macro for user to do things just after a call to shower"
REPLACE {$USER-AFTER-SHOWER;} WITH {;}

" end of beamnrc_user_macros.mortran"
;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc macros to read and write phase space files                          "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1999                                       "
"                                                                             "
"  Contributors:    Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Macros required to read from and write to phase space files. These macros  "
"  replace the old calls to the subroutine rw_ph_sp.mortran and any           "
"  manipulations of phase space files that were hard-coded. Currently, these  "
"  macros are used by BEAM, DOSXYZ, BEAMDP, and readphsp. The beam            "
"  configuration script looks for this file in the following directories, in  "
"  this order                                                                 "
"                                                                             "
"  $HOME/egs4/BEAM_accelerator                                                "
"  $HOME/egs4/beam                                                            "
"  $OMEGA_HOME/beam                                                           "
"                                                                             "
"  All other configuration or compile scripts only use the version of this    "
"  file in $OMEGA_HOME/beam. These macros can be used with any code provided  "
"  that this file is concatenated before any codes that use the macros.       "
"  Detailed description of what each macro does is provided at the top of     "
"  the macro.                                                                 "
"                                                                             "
"#############################################################################"


;
REPLACE {;COMIN/RWPHSP/;} WITH {
"RWPHSP must be included in the common block of main in any code that uses"
"any of these phase space macros and also in the common block of"
"any subroutine that uses any phase space macros.  Note that the macro"
"$MAX_SC_PLANES(=the max. number of scoring planes) must have been defined"
"somewhere in the code before the first use of COMIN/RWPHSP.  In the case of"
"DOSXYZ, BEAMDP and readphsp, $MAX_SC_PLANES is a dummy value, set to 1,"
"at the beginning of main.  Note that, since, IHSTRY_PHSP is a $LONG_INT"
"variable, you must have the macro REPLACE {$LONG_INT} WITH {INTEGER*8} at"
"the top of any code that uses these macros.  If your compiler has trouble"
"with INTEGER*8, use INTEGER*4 in the $LONG_INT macro."

;COMMON/RWPHSP/
   STRING_TEMP_ZLAST_OUT,
                 "holds output phsp data for up to 1000 particles, with ZLAST"
   STRING_TEMP_OUT, "holds output phsp data for up to 1000 particles, no ZLAST"
   IHSTRY_PHSP, "history number (from primary non-phase space source) of"
                "particle being scored"
   iaea_dummy_long, "used to store INTEGER*8 values temporarily"
   NHSTRY_DOS, "passed to NHSTRY in beam when this actually comes from"
               "dosxyznrc source 20"
   ESHORT,    "single precision E read from/written to phsp"
   WEIGHTTMP, "modified version of WT to be written to phsp"
   WT_PHSP_SHORT, "single precision wt read from phsp"
   X_PHSP_SHORT, "single precision x read from phsp"
   Y_PHSP_SHORT, "single precision y read from phsp"
   Z_PHSP_SHORT, "single precision Z--for iaea format only"
   U_PHSP_SHORT, "single precision u read from phsp"
   V_PHSP_SHORT, "single precision v read from phsp"
   W_PHSP_SHORT, "single precision w--for iaea format only"
   ZLAST_PHSP_SHORT, "single precision zlast read from phsp"
   MUIDX_PHSP_SHORT, "MU_INDEX--iaea phsp files only"
   EKMAX_PHSP_SHORT, "max ke of particles in phsp file"
   EKMINE_PHSP_SHORT, "min ke of electrons in phsp file"
   NINC_PHSP_SHORT, "no. of particles from original primary source"
   dosxyz2beam_index, "stores MU index passed to beam from dosxyz"
   iaea_extra_floats, "array of extra floats in IAEA phsp file"
   NUM_PHSP_TOT, "tot no of particles in phsp file"
   PHOT_PHSP_TOT,"no. of photons in phsp file"
   iaea_result,  "<0 if an error finding an available array index for IAEA"
                 "phsp file"
   iaea_n_stat,  ">=1 if a new primary history is scoring, 0 otherwise"
   iaea_q_typ,    "array to convert from charge to IAEA type"
   iaea_typ_q,   "array to convert from IAEA type to charge"
   iaea_q_index, "array index"
   I_PHSP,    "loop counter"
   IERR_PHSP, "=0 if open/read okay ~=0 if not okay"
   LATCHTMP,  "modified version of LATCH to be written to phsp"
   WRITE_PHSP_COUNTER, "counter up to 1000 used for group write"
   WRITE_PHSP_SOFAR, "how many particles written so far to file"
   PHSP_RESTART, "set to 1 if this is a restart"
   PHSP_RECL, "the record length"
   PHSP_RECL_OLD, "saves record length"
   iaea_extra_ints, "array in which LATCH will be stored for iaea format"
   iaea_extra_int_types,iaea_extra_float_types, "returns the types of"
                    "extra int and float variables in an IAEA phsp file"
   iaea_i_zlast,"index of iaea_extra_floats in which Zlast is stored for IAEA"
           "phsp files read IN"
   iaea_i_latch,"index of iaea_extra_int in which LATCH is stored for IAEA"
           "phsp files read IN"
   iaea_i_muidx,"index of iaea_extra_floats in which MU_INDEX is stored for"
           "IAEA phsp files read IN"
   iaea_n_extra_ints, "no. of extra ints stored in IAEA phsp file read IN"
   iaea_n_extra_floats, "no. of extra floats stored in IAEA phsp file read IN"
   i_iaea_open_for_write, "set to 1 if the macro IAEA_OPEN_FOR_WRITE"
                          "was used"
   iaea_i_zlast_out,"index of iaea_extra_floats in which Zlast is stored for"
               " IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
   iaea_i_latch_out,"index of iaea_extra_int in which LATCH is stored for IAEA"
           "phsp written OUT by BEAMnrc or DOSXYZnrc"
   iaea_i_muidx_out,"index of iaea_extra_floats in which MU_INDEX is stored"
           " for IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
   dosxyz2beam_izscore, "set to 1 if Z scored for each particle (IAEA only)"
   MODE_RW;   "mode of phsp file (0 with ZLAST, 2 without), writing only"

CHARACTER*32000 STRING_TEMP_ZLAST_OUT($MAX_SC_PLANES);
CHARACTER*28000 STRING_TEMP_OUT($MAX_SC_PLANES);
$LONG_INT IHSTRY_PHSP($MAX_SC_PLANES),iaea_dummy_long,NHSTRY_DOS;
REAL*4 ESHORT,WEIGHTTMP,WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
       Z_PHSP_SHORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,ZLAST_PHSP_SHORT,
       MUIDX_PHSP_SHORT,
       EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT,dosxyz2beam_index,
       iaea_extra_floats(10);
INTEGER NUM_PHSP_TOT,PHOT_PHSP_TOT,
        iaea_result,iaea_n_stat,iaea_q_typ(3),iaea_typ_q(3),iaea_q_index,I_PHSP,
        IERR_PHSP,LATCHTMP,
        WRITE_PHSP_COUNTER($MAX_SC_PLANES),WRITE_PHSP_SOFAR($MAX_SC_PLANES),
        PHSP_RESTART,PHSP_RECL,PHSP_RECL_OLD,iaea_extra_ints(10),
        iaea_extra_int_types(10),iaea_extra_float_types(10),iaea_i_zlast,
        iaea_i_latch,iaea_i_muidx,iaea_n_extra_ints,iaea_n_extra_floats,
        i_iaea_open_for_write,iaea_i_zlast_out,iaea_i_latch_out,
        iaea_i_muidx_out,dosxyz2beam_izscore;
CHARACTER*5 MODE_RW;

"variables below are not part of the common block but are used locally"
"by the $WRITE_PHSP, $WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros"

INTEGER LATCH_TEMP_OUT,NUM_PHSP_TOFLUSH,TEMP_PHSP_COUNTER,REM_PHSP;
REAL*4 REAL_TEMP_OUT(7);
CHARACTER*32 REC_TEMP_OUT;

}
;

REPLACE {$INITIALIZE_PHSP_VARIABLES;} WITH{;
"Must be placed after the variable declarations in any subroutine"
"where $WRITE_PHSP and/or $WRITE_PHSP_RECORD is used.  Note, though, that"
"it does not necessarily have to be put at the top of main, unless one or"
"both of these macros are used in main."
"It equivalences the character string REC_TEMP_OUT with the phase space data"
"for 1 particle. REC_TEMP_OUT is then used to fill the character array"
"STRING_TEMP_(ZLAST_)OUT, which holds the phase space data in blocks of 1000"
"particles before writing."

EQUIVALENCE(REC_TEMP_OUT(1:4),LATCH_TEMP_OUT);
EQUIVALENCE(REC_TEMP_OUT(5:8),REAL_TEMP_OUT(1));
EQUIVALENCE(REC_TEMP_OUT(9:12),REAL_TEMP_OUT(2));
EQUIVALENCE(REC_TEMP_OUT(13:16),REAL_TEMP_OUT(3));
EQUIVALENCE(REC_TEMP_OUT(17:20),REAL_TEMP_OUT(4));
EQUIVALENCE(REC_TEMP_OUT(21:24),REAL_TEMP_OUT(5));
EQUIVALENCE(REC_TEMP_OUT(25:28),REAL_TEMP_OUT(6));
EQUIVALENCE(REC_TEMP_OUT(29:32),REAL_TEMP_OUT(7));
}
;

REPLACE {$INIT_PHSP_COUNTERS;} WITH {;
"This macro initializes counters and flags that are used by the"
"$WRITE_PHSP/$WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros.  It is only"
"used once and should be placed after the variable declarations in main."

DO I_PHSP=1,$MAX_SC_PLANES[
  WRITE_PHSP_COUNTER(I_PHSP)=0;
  WRITE_PHSP_SOFAR(I_PHSP)=0;
  IHSTRY_PHSP(I_PHSP)=0;
]
PHSP_RESTART=0;
PHSP_RECL_OLD=0;

iaea_q_typ(1)=2;iaea_q_typ(2)=1;iaea_q_typ(3)=3;
iaea_typ_q(1)=0;iaea_typ_q(2)=-1;iaea_typ_q(3)=1;

iaea_n_extra_ints=0;iaea_n_extra_floats=0;

iaea_i_zlast=-99;iaea_i_latch=-99;iaea_i_muidx=-99;

i_iaea_open_for_write=0;

iaea_i_zlast_out=-99;iaea_i_latch_out=-99;iaea_i_muidx_out=-99;

}
;


REPLACE {$GET_E_NPASS_IQ(#,#,#,#);} WITH {;
"Macro gets NPASS, IQ from the LATCH value read in and then restores LATCH"
"by clearing the bits that store this information.  It also puts the"
"single precision energy, ESHORT, read in into double precision form."
"This macro is called by $READ_PHSP."

"Input parameters:"
"{P1}=NPASS"
"{P2}=IQ"
"{P3}=LATCH"
"{P4}=E"

{P4}=ESHORT;

IF($BTEST({P3},31)) [ {P1} = 1; {P3} = $IBCLR({P3},31); ]
ELSE [ {P1} = 0; ]

IF($BTEST({P3},30)) [
    {P2} = -1;
    {P3} = $IBCLR({P3},30); {P3} = $IBCLR({P3},29);
]
ELSE [
       IF($BTEST({P3},29)) [
          {P2} = 1; {P3} = $IBCLR({P3},29);
       ]
       ELSE [ {P2} = 0; ]
]
}
;

REPLACE {$GET_W_WT(#,#,#,#,#,#);} WITH {;
"This macro calculates W, based on U and V and the sign of WT as read in from"
"the phase space file.  Once the sign of WT is determined, WT is set equal"
"to its absolute value, since there cannot be a negative particle weight."
"This macro is called by $READ_PHSP."

"Input parameters:"
"{P1}=W"
"{P2}=WT"
"{P3}=X"
"{P4}=Y"
"{P5}=U"
"{P6}=V"

{P1} = min( 1., {P5}**2 + {P6}**2);
{P1} = sqrt(1. - {P1});
{P1} = SIGN({P1},{P2});  "This transfers sign of WT to W"

{P2}=ABS({P2}); "WT is always positive"

}
;

REPLACE {$PARSE_PHSP_RECORD(#,#,#,#);} WITH {;
"macro used by READ_PHSP_RECORD to put single precision x, y, u, v"
"read from phase space file into (potentially) double precision"
"x, y, u, v passed to READ_PHSP_RECORD macro"

"Input parameters:"
"{P1}=X"
"{P2}=Y"
"{P3}=U"
"{P4}=V"

{P1}=X_PHSP_SHORT;
{P2}=Y_PHSP_SHORT;
{P3}=U_PHSP_SHORT;
{P4}=V_PHSP_SHORT;
}
;

REPLACE {$READ_PHSP_RECORD(#,#,#:#,#,#,#,#,#);} WITH {;
"Note that a colon is required  ^  between the third and fourth"
"input parameters."
"This macro actually reads the phase space data for a single particle."
"It is called by $READ_PHSP, but can also be used as a stand-alone macro."
"If the energy, E, is < 0.0, then this is the first particle scored"
"from a new primary (ie non-phsp source) history, and NHSTRY is incremented"
"and E is set to ABS(E)."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number"
"{P3}=record number"
"{P4}=NHSTRY"
"{P5}=ZLAST"
"{P6}=LATCH"
"{P7}=E"
"{P8}=WT"
"{P9}=X,Y,U,V"

IF({P1}~=0)["must read in ZLAST"
  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT,ZLAST_PHSP_SHORT;
]
ELSE["no ZLAST"
  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT;
]

IF({P3}=76695869)[
   write(*,*)' x,y,u,v,wt,eshort,latch',
 X_PHSP_SHORT,Y_PHSP_SHORT,U_PHSP_SHORT,V_PHSP_SHORT,
WT_PHSP_SHORT,ESHORT,{P6};
]

"first particle from new primary history"
IF(ESHORT<0.0)[
  {P4}={P4}+1;
  ESHORT=ABS(ESHORT);
]

{P7}=ESHORT;
{P8}=WT_PHSP_SHORT;
$PARSE_PHSP_RECORD({P9});

IF({P1}~=0) {P5}=ZLAST_PHSP_SHORT;

}
;

REPLACE {$READ_PHSP_RECORD_ENEGATIVE(#,#,#:#,#,#,#,#);} WITH {;
"Note that a colon is required            ^  between the third and fourth"
"input parameters."
"This macro is the similar to $READ_PHSP_RECORD above, but it preserves"
"the -E marker in the phase space file and does not advance NHSTRY"
"It is only used in readphsp before byte swapping"

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number"
"{P3}=record number"
"{P4}=ZLAST"
"{P5}=LATCH"
"{P6}=E"
"{P7}=WT"
"{P8}=X,Y,U,V"

IF({P1}~=0)["must read in ZLAST"
  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7},{P4};
]
ELSE["no ZLAST"
  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7};
]

}
;

REPLACE {$READ_PHSP(#:#,#,#,#,#,#,#,#);} WITH {;
"Note colon          ^  required between the first and second"
"input parameters (third and fourth input variables)"

"This macro reads the phase space data for a single particle.  It finds"
"the value of IQ and NPASS from the LATCH variable read in and then"
"restores the LATCH variable.  It calculates W from U, V and the sign"
"of WT and then restores WT to its absolute value.  And it puts the"
"single-precision energy, ESHORT, read in into double-precision format."
"If ESHORT is < 0, it sets E=ABS(ESHORT) and increments NHSTRY, taking"
"this as the first particle scored from a new primary history."

"Input parameters:"
"{P1}=IZLAST,unit number for phase space file,record number reading from"
"{P2}=NHSTRY"
"{P3}=NPASS"
"{P4}=IQ"
"{P5}=W"
"{P6}=ZLAST"
"{P7}=LATCH"
"{P8}=E"
"{P9}=WT,X,Y,U,V"

$READ_PHSP_RECORD({P1}:{P2},{P6},{P7},{P8},{P9});

IF(IERR_PHSP=0)[
  $GET_E_NPASS_IQ({P3},{P4},{P7},{P8});
  $GET_W_WT({P5},{P9});
]

}
;

REPLACE {$GET_LATCHTMP_ESHORT_WEIGHTTMP(#,#,#,#,#,#);} WITH {;
"This macro converts LATCH into LATCHTMP, which stores NPASS and IQ"
"for a particle and is the form of LATCH written to the phase space file."
"It puts double precision energy, E, into single precision format, ESHORT,"
"for writing to the phase space file.  This macro is called from $READ_PHSP"

"Input parameters:"
"{P1}=NPASS"
"{P2}=IQ"
"{P3}=W"
"{P4}=LATCH"
"{P5}=E"
"{P6}=WT"

LATCHTMP={P4};

IF({P1} = 0) [ LATCHTMP = $IBCLR(LATCHTMP,31); ]
ELSE [ LATCHTMP = $IBSET(LATCHTMP,31); ]

IF({P2} = -1) [ LATCHTMP = $IBSET(LATCHTMP,30);]
ELSEIF({P2} = 0) [
     LATCHTMP = $IBCLR(LATCHTMP,30);
     LATCHTMP = $IBCLR(LATCHTMP,29);
]
ELSE [
     LATCHTMP = $IBCLR(LATCHTMP,30);
     LATCHTMP = $IBSET(LATCHTMP,29);
]

ESHORT={P5};

WEIGHTTMP=SIGN({P6},{P3});"transfer sign of W to WEIGHTTMP"

}
;

REPLACE {$SET_NEGATIVE_E(#,#,#,#);} WITH {;
"Macro to set E to -E if this is the first particle scored from a new"
"primary (non-phsp source) history.  This macro is called from"
"$WRITE_PHSP_RECORD."

"Input parameters"
"{P1}=phase space scoring plane no."
"{P2}=IHSTRY"
"{P3}=E"
"{P4}=WT,X,Y,U,V"

IF({P2}~=IHSTRY_PHSP({P1}))[
  {P3}=-{P3};
  IHSTRY_PHSP({P1})={P2};
]

}
;

REPLACE {$PARSE_TEMP_FOR_WRITE(#,#,#,#,#,#,#,#,#);} WITH {;
"Macro to store the output phase space data for one particle in the"
"variables LATCH_TEMP_OUT and REAL_TEMP_OUT.  These variables are"
"equivalenced to the string variable REC_TEMP_OUT, which stores the"
"phase space for one particle in string form and which, in turn, is"
"used to transfer the data to the string variable STRING_TEMP(_ZLAST)_OUT"
"which stores output phase space data for up to 1000 particles at a time."
"This macro is called from $WRITE_PHSP_RECORD."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=ZLAST"
"{P3}=LATCH"
"{P4}=E"
"{P5}=WT"
"{P6}=X"
"{P7}=Y"
"{P8}=U"
"{P9}=V"

LATCH_TEMP_OUT={P3};
REAL_TEMP_OUT(1)={P4};
REAL_TEMP_OUT(2)={P6};
REAL_TEMP_OUT(3)={P7};
REAL_TEMP_OUT(4)={P8};
REAL_TEMP_OUT(5)={P9};
REAL_TEMP_OUT(6)={P5};
IF({P1}~=0) REAL_TEMP_OUT(7)={P2};

}
;

REPLACE {$WRITE_PHSP_RECORD(#,#,#,#,#:#,#,#,#);} WITH {;
"Note that a colon is required       ^  between the fifth and sixth"
"input parameters"

"This macro is used to output phase space data 1000 particles at a time."
"For every particle, the phase space data to be output is stored in"
"the string variable STRING_TEMP(_ZLAST)_OUT.  If it is the 1000th particle"
"STRING_TEMP(_ZLAST)_OUT is written to the phase space file.  The phase"
"space header info is considered to occupy the space of 1 particle in the"
"first block of 1000 particles, however, it will be overwritten with nulls."
"This is fine since the header info should be recalculated and rewritten at"
"the top of the file after all data has been written out anyway."
"Also note that restarting with this writing scheme requires that any"
"blocks of N (N<1000) particles at the end of a phase space file from"
"the previous run must immediately be read into the first N spaces of"
"STRING_TEMP(_ZLAST)_OUT before continuing on with outputting the data"
"for new particles.  Finally, after all phase space data has been output,"
"there will probably be info for M (M<1000) particles still in"
"STRING_TEMP(_ZLAST)_OUT that has not been written to the phase space file"
"because the write counter did not reach 1000.  These are output using"
"the $PHSP_BUFFER_FLUSH macro described below."

"Group writing reduces network traffic and saves a lot of time when the"
"one of the main CPU-intensive activities is the writing of phase space data."
"Group reading has also been considered, but preliminary studies have shown"
"that it does not reduce CPU time significantly."

"Using the macro $SET_NEGATIVE_E, $WRITE_PHSP_RECORD also takes care of setting"
"E to -E if this is the first particle scored from a new primary"
"(non-phsp source) history."

"This macro is called by $WRITE_PHSP, but can also be used as a stand-"
"alone macro.  However, use of $WRITE_PHSP_RECORD, will always require"
"use of $PHSP_BUFFER_FLUSH (see below)."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number for phase space file"
"{P3}=name of phase space file"
"{P4}=record number writing to"
"{P5}=scoring plane number"
"{P6}=IHSTRY"
"{P7}=ZLAST"
"{P8}=LATCH"
"{P9}=E,WT,X,Y,U,V"

IF({P4}>2 & WRITE_PHSP_COUNTER({P5})=0 & WRITE_PHSP_SOFAR({P5})=0)[
   "we have a restart or its the start of a new batch"
   IF(({P4}-1)-1000*(({P4}-1)/1000)~=0)[
   "make what was the buffer flush part of the first record of the restart"
    CLOSE({P2});
    IF({P1}~=0)["have ZLAST"
      PHSP_RECL=$RECL-FACTOR*8;
      OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
           FORM='UNFORMATTED',STATUS='UNKNOWN');
      DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
         READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
               STRING_TEMP_ZLAST_OUT({P5})(32*(I_PHSP-1)+1:32*I_PHSP);
      ]
      CLOSE({P2});
      PHSP_RECL=$RECL-FACTOR*8000;
      OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
           FORM='UNFORMATTED',STATUS='UNKNOWN');
    ]
    ELSE["no ZLAST"
      PHSP_RECL=$RECL-FACTOR*7;
      OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
           FORM='UNFORMATTED',STATUS='UNKNOWN');
      DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
         READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
               STRING_TEMP_OUT({P5})(28*(I_PHSP-1)+1:28*I_PHSP);
      ]
      CLOSE({P2});
      PHSP_RECL=$RECL-FACTOR*7000;
      OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
           FORM='UNFORMATTED',STATUS='UNKNOWN');
    ]
   ]
   WRITE_PHSP_SOFAR({P5})=1000*INT(dble({P4}-1)/1000);
   IF(WRITE_PHSP_SOFAR({P5})>0)[
       PHSP_RESTART=1;
       WRITE_PHSP_COUNTER({P5})=({P4}-1)-1000*(({P4}-1)/1000);
   ]
   ELSE[
       WRITE_PHSP_COUNTER({P5})=({P4}-2)-1000*(({P4}-2)/1000);
   ]
]

$SET_NEGATIVE_E({P5},{P6},{P9});

$PARSE_TEMP_FOR_WRITE({P1},{P7},{P8},{P9});

IF({P4}<=1000 & PHSP_RESTART=0)["do not use first 7/8 elements"
   IF({P1}~=0)["have ZLAST"
     STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+33:
       32*WRITE_PHSP_COUNTER({P5})+64)=REC_TEMP_OUT(1:32);
   ]
   ELSE["no ZLAST"
     STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+29:
       28*WRITE_PHSP_COUNTER({P5})+56)=REC_TEMP_OUT(1:28);
   ]
]
ELSE[
   IF({P1}~=0)[
     STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+1:
       32*WRITE_PHSP_COUNTER({P5})+32)=REC_TEMP_OUT(1:32);
   ]
   ELSE["no ZLAST"
     STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+1:
       28*WRITE_PHSP_COUNTER({P5})+28)=REC_TEMP_OUT(1:28);
   ]
]

WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;

IF({P4}=1000|WRITE_PHSP_COUNTER({P5})=1000)[
   IF({P1}~=0 & PHSP_RECL=$RECL-FACTOR*8)[
     CLOSE({P2});
     PHSP_RECL_OLD=PHSP_RECL;
     PHSP_RECL=$RECL-FACTOR*8000;
     OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
          FORM='UNFORMATTED',STATUS='UNKNOWN');
   ]
   ELSEIF({P1}=0 & PHSP_RECL=$RECL-FACTOR*7)[
     PHSP_RECL_OLD=PHSP_RECL;
     CLOSE({P2});
     PHSP_RECL=$RECL-FACTOR*7000;
     OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
          FORM='UNFORMATTED',STATUS='UNKNOWN');
   ]
   IF({P1}~=0)[
     WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_ZLAST_OUT({P5});
   ]
   ELSE["no ZLAST"
     WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_OUT({P5});
   ]
   IF(PHSP_RECL_OLD~=0)[
     "have to do this in case the output file=input file"
     PHSP_RECL=PHSP_RECL_OLD;
     CLOSE({P2});
     OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
          FORM='UNFORMATTED',STATUS='UNKNOWN');
   ]
   WRITE_PHSP_COUNTER({P5})=0;
   WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+1000;
]

}
;

REPLACE {$PHSP_BUFFER_FLUSH(#,#,#,#,#);} WITH {;
"This macro outputs the data for the M (M<1000) remaining particles still"
"stored in STRING_TEMP(_ZLAST)_OUT after all calls to $WRITE_PHSP_RECORD."
"The macro does not flush all of the data at once, but in blocks that"
"divide exactly into the number of particles already in the phase space"
"file.  For each block that is flushed, the phase space file is re-opened"
"with a record length (RECL) equal to the size of the block.  Since RECL"
"divides exactly into the number of particles already in the file, the"
"block to be flushed can be appended onto the data that already exists in"
"the file with no overwrites and/or blank space."
"The other alternative was to flush STRING_TEMP(_ZLAST)_OUT one particle at"
"a time, which is more time-consuming."
"$PHSP_BUFFER_FLUSH must exist in a code that uses $WRITE_PHSP or"
"$WRITE_PHSP_RECORD.  It should be placed on its own outside the loop in which"
"phase space data is output.  In the case of BEAM, it is placed at the end"
"of each batch, so that, if the simulation crashes, phase space information"
"from the last batch is not lost."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number for phase space file"
"{P3}=file name"
"{P4}=particle number +1"
"{P5}=scoring plane number"
TEMP_PHSP_COUNTER=0;
NUM_PHSP_TOFLUSH=WRITE_PHSP_COUNTER({P5});
IF(NUM_PHSP_TOFLUSH>0)[
  IF(WRITE_PHSP_SOFAR({P5})=0)[
      WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;
      NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH+1; "account for header"
  ]
  LOOP[
    TEMP_PHSP_COUNTER=NUM_PHSP_TOFLUSH+1;
    LOOP[
      TEMP_PHSP_COUNTER=TEMP_PHSP_COUNTER-1;
      REM_PHSP=MOD(WRITE_PHSP_SOFAR({P5}),TEMP_PHSP_COUNTER);
    ]UNTIL(REM_PHSP=0);
    CLOSE({P2});
    IF({P1}~=0)["write ZLAST"
      PHSP_RECL=$RECL-FACTOR*8*TEMP_PHSP_COUNTER;
      OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
           ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
      WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
             STRING_TEMP_ZLAST_OUT({P5})
    (32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
     32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
    ]
    ELSE["no ZLAST"
      PHSP_RECL=$RECL-FACTOR*7*TEMP_PHSP_COUNTER;
      OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
           ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
      WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
             STRING_TEMP_OUT({P5})
    (28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
     28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
    ]
    WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+TEMP_PHSP_COUNTER;
    NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH-TEMP_PHSP_COUNTER;
 ] UNTIL(NUM_PHSP_TOFLUSH=0);
 WRITE_PHSP_COUNTER({P5})=0;
 WRITE_PHSP_SOFAR({P5})=0;
]
;
}
;

REPLACE {$WRITE_PHSP(#:#,#,#,#,#,#,#:#);} WITH {;
"Note that colons     ^             ^  are required between the first and"
"second input parameters (5th and 6th input variables) and the"
"8th and 9th input parameters (13th and 14th input variables)"

"This outputs phase space data in blocks of 1000 particles at a time."
"In preparation for output, LATCH is modified to hold NPASS and IQ,"
"energy (E) is placed into a single precision variable, ESHORT, and"
"weight (WT) is given the sign of W.  If this is the first particle"
"scored from a new primary (non-phase space source) history, then"
"ESHORT is set to -ESHORT and IHSTRY_PHSP is set to IHSTRY."

"Input parameters:"
"{P1}=IZLAST,unit number for phase space file,name of phase space file,"
"     record number writing to, scoring plane number"
"{P2}=IHSTRY"
"{P3}=NPASS"
"{P4}=IQ"
"{P5}=W"
"{P6}=ZLAST"
"{P7}=LATCH"
"{P8}=E,WT"
"{P9}=X,Y,U,V"

$GET_LATCHTMP_ESHORT_WEIGHTTMP({P3},{P4},{P5},{P7},{P8});

$WRITE_PHSP_RECORD({P1}:{P2},{P6},LATCHTMP,ESHORT,WEIGHTTMP,{P9});

}
;

REPLACE {$READ_PHSP_HEADER(#,#,#,#,#,#,#);} WITH {;
"This macro reads the info from the header of a phase space file."
"It is called from $OPEN_PHSP_FILE_FOR_WRITE, but can also be used"
"as a stand-alone macro."

"Input parameters:"
"{P1}=unit number"
"{P2}=MODE0 or MODE2"
"{P3}=total number of particles"
"{P4}=no. of photons"
"{P5}=max k.e. of particles"
"{P6}=min. k.e. of electrons"
"{P7}=no. of particles incident from original source"

READ({P1},REC=1,IOSTAT=IERR_PHSP){P2},NUM_PHSP_TOT,PHOT_PHSP_TOT,
EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
{P3}=NUM_PHSP_TOT;
{P4}=PHOT_PHSP_TOT;
{P5}=EKMAX_PHSP_SHORT;
{P6}=EKMINE_PHSP_SHORT;
{P7}=NINC_PHSP_SHORT;

IF(IERR_PHSP~=0)[
   OUTPUT;(//' ***ERROR READING HEADER OF PHASE SPACE FILE*** '//);
   STOP;
]
}
;

REPLACE {$OPEN_PHSP_FOR_READ(#,#,#,#,#);} WITH {;
"Macro to open a phase space file in preparation for reading it."
"The macro opens the file in one of 3 modes, as a file that is known"
"to have ZLAST (IZLAST>0), as a file that is known not to have ZLAST"
"(IZLAST=0), or with no prior knowledge of whether the file has"
"ZLAST or not (IZLAST<0)."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number"
"{P3}=file name"
"{P4}=MODE0 or MODE2"
"{P5}=total number of particles, no. of photons, max k.e. of particles,"
"      min. k.e. of electrons, no. of particles incident from original source"

IF({P1}>0)["with ZLAST"
   PHSP_RECL=$RECL-FACTOR*8;
   OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
        RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
   IF(IERR_PHSP~=0)[
        "error above on file opening when assumed it was MODE2"
         OUTPUT;(/' ***error opening file as MODE2 ****'
        /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE2 FILE) ***'/
        /' *** WE NOW TRY TO OPEN IT AS A MODE3 FILE ***'//);
         OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
              FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
        "if on error, cannot find file/directory, then stop"
        IF(IERR_PHSP~=0)[
          ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
          STOP;
        ]
        $READ_PHSP_HEADER({P2},{P4},{P5});
        IF({P4} ~= 'MODE3')[
          OUTPUT;(//' That file does not start with MODE3,',
          ' as all old compressed files (with ZLAST) must'/
          '  Check it out and try again!'///);
          IERR_PHSP=1;
          STOP;
        ]
        ELSE[
          OUTPUT;(//' This is a MODE3 file! '/
          ' Please convert it into a MODE2 file using [readphsp] ',
          ' and try again!'///);
           IERR_PHSP=1;
           STOP;
        ]
   ]
   $READ_PHSP_HEADER({P2},{P4},{P5});
   IF({P4} ~= 'MODE2')[
       OUTPUT;(//' That file does not start with MODE2,',
          ' as standard compressed files with ZLAST must'/
          '  Check it out and try again!'///);
        IERR_PHSP=1;
        STOP;
   ]
]
ELSEIF({P1}=0)["without ZLAST"
   PHSP_RECL=$RECL-FACTOR*7;
   OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
        RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
    "$RECL-FACTOR = 4 for SUN SPARC and =1 for SILICON GRAPHICS "
    "this factor is machine-dependent and stored in machine.mortran"
    "check file is MODE0 -ie standard compressed"
   IF(IERR_PHSP~=0)[
    "come here if error opening file assumed MODE0"
      OUTPUT;(/' ***ERROR opening file as MODE0****'
      /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE0 FILE) ***'/
      /' *** WE NOW TRY TO OPEN IT AS A MODE1 FILE ***'//);
      OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
       FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
      "if on error, cannot find file/directory, then stop"
      IF(IERR_PHSP~=0)[
        ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
          STOP;
      ]
      $READ_PHSP_HEADER({P2},{P4},{P5});
      IF({P4} ~= 'MODE1')[
        OUTPUT;(//' That file does not start with MODE1,',
        ' as all old compressed files must'/
        '  Check it out and try again!'///);
        IERR_PHSP=1;
        STOP;
      ]
      ELSE[
        OUTPUT;(//' This is a MODE1 file! '/
       ' Please convert it into a MODE0 file using [readphsp] ',
       'and try again!'///);
         IERR_PHSP=1;
         STOP;
      ]
   ]
   $READ_PHSP_HEADER({P2},{P4},{P5});
   IF({P4} ~= 'MODE0')[
          OUTPUT;
            (/' Does not start with MODE0 as files without ZLAST must'/
          '  Try again!'//);
          IERR_PHSP=1;
          STOP;
   ]
]
ELSEIF({P1}<0)["open with no assumptions about whether ZLAST is there or not"
   OUTPUT;(/' First, try to open it as a MODE0 file');
   PHSP_RECL=$RECL-FACTOR*7;
   OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
        RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
   IF(IERR_PHSP~=0)[
     OUTPUT;(/' Now try to open it as a MODE2 file');
     {P1}=1;
     PHSP_RECL=$RECL-FACTOR*8;
     OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
        RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
     IF(IERR_PHSP~=0)[
        ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
     ]
     ELSE[
        $READ_PHSP_HEADER({P2},{P4},{P5});
        IF({P4}~='MODE2')[
            OUTPUT;(//' That file does not start with MODE2,',
          ' as standard compressed files with ZLAST must'/
          '  Check it out and try again!'///);
          CLOSE({P2});
          STOP;
        ]
     ]
   ]
   ELSE[
     $READ_PHSP_HEADER({P2},{P4},{P5});
     {P1}=0;
     IF({P4}~='MODE0')[
       OUTPUT;(/' The file does not start with MODE0 as it supposed to');
       CLOSE({P2});
       OUTPUT;(/' Now try to open it as a MODE2 file');
       {P1}=1;
       PHSP_RECL=$RECL-FACTOR*8;
       OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
           RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
       IF(IERR_PHSP~=0)[
         ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE OPENED. ***');
       ]
       ELSE[
          $READ_PHSP_HEADER({P2},{P4},{P5});
          IF({P4}~='MODE2')[
              OUTPUT;(//' That file does not start with MODE2,',
            ' as standard compressed files with ZLAST must'/
            '  Check it out and try again!'///);
            CLOSE({P2});
            STOP;
          ]
       ]
     ]
   ]
]
}
;

REPLACE {$PARSE_PHSP_HEADER_FOR_WRITE(#,#,#,#,#);} WITH {;
"Puts max ke of particles, min ke of electrons, and no. of particles"
"incident from original source--all of which may be double precision"
"into real*4 variables"
"{P1}=tot. no. of particles"
"{P2}=no. of photons"
"{P3}=max ke of particles"
"{P4}=min ke of electrons"
"{P5}=no. of particles incident from primary source"
IF({P1}>2147483647)[
  write(*,*)' Warning while writing phase space file:';
  write(*,*)' No. of particles > 2^31-1.';
  write(*,*)' Total no. of particles (and photons) written';
  write(*,*)' to header may be nonsense.';
]
NUM_PHSP_TOT={P1};
PHOT_PHSP_TOT={P2};
EKMAX_PHSP_SHORT={P3};
EKMINE_PHSP_SHORT={P4};
NINC_PHSP_SHORT={P5};
}

REPLACE {$WRITE_PHSP_HEADER(#,#,#,#,#);} WITH {;
"Macro to write the header information into a phase space file."
"Files must be closed and re-opened with record length (RECL) for"
"a single particle in order to prevent over-writing any particle data."
"Once the header info is written, the file is closed again and re-opened"
"with the RECL for 1000 particles."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number"
"{P3}=file name"
"{P4}=MODE0 or MODE2"
"{P5}=total number of particles, no. of photons, max k.e. of particles,"
"      min. k.e. of electrons, no. of particles incident from original source"

CLOSE({P2});
IF({P1}~=0)["have ZLAST"
  PHSP_RECL=$RECL-FACTOR*8;
]
ELSE["no ZLAST"
  PHSP_RECL=$RECL-FACTOR*7;
]
OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
       FORM='UNFORMATTED',STATUS='UNKNOWN');
$PARSE_PHSP_HEADER_FOR_WRITE({P5});
WRITE({P2},REC=1){P4},NUM_PHSP_TOT,PHOT_PHSP_TOT,EKMAX_PHSP_SHORT,
EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
CLOSE({P2});
IF({P1}~=0)["have ZLAST"
  PHSP_RECL=$RECL-FACTOR*8000;
]
ELSE["no ZLAST"
  PHSP_RECL=$RECL-FACTOR*7000;
]
OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
       FORM='UNFORMATTED',STATUS='UNKNOWN');
}
;


REPLACE {$OPEN_PHSP_FOR_WRITE(#,#,#,#);} WITH {;
"This macro opens a phase space file for writing.  The file is opened with"
"a record length that will hold phase space data for 1000 particles in 1"
"record.  This is to to enable writing phase space data for 1000 particles"
"at a time (see the $WRITE_PHSP_RECORD macro above).  The macro also uses"
"$WRITE_PHSP_HEADER to output a dummy header to the file."

"Input parameters:"
"{P1}=IZLAST"
"{P2}=unit number"
"{P3}=file name"
"{P4}=MODE_RW"
IF({P1}~=0)["with ZLAST"
   {P4}='MODE2';
   PHSP_RECL=$RECL-FACTOR*8000;
]
ELSE["no ZLAST"
   {P4}='MODE0';
   PHSP_RECL=$RECL-FACTOR*7000;
]
OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
        FORM='UNFORMATTED',STATUS='UNKNOWN');
$WRITE_PHSP_HEADER({P1},{P2},{P3},{P4},0,0,0,0,0);
}
;

REPLACE {$CLOSE_PHSP(#);} WITH {;
"Macro to close a phase space file."

"Input parameter:"
"{P1}=the unit number of the phase space file"

CLOSE(UNIT={P1});
}
;
/*****************************************************************************
 *
 *  Empty replacement macros for reading/writing IAEA format phase space
 *  files in case the IAEA C++ utility codes for handling phase space data
 *  are unavailable.  Otherwise, these empty macros are superseded by those
 *  in $HEN_HOUSE/utils/iaea_phsp_macros.mortran by including
 *  $HEN_HOUSE/utils/iaea_phsp_macros.mortran AFTER
 *  $HEN_HOUSE/utils/phsp_macros.mortran when building the code that is
 *  to be Mortran compiled.
 *
 ****************************************************************************/

REPLACE {$IAEA_OPEN_PHSP_FOR_WRITE(#,#,#,#,#,#,#);} WITH {;

OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
           ' space handling macros.'//);
}
;

REPLACE {$IAEA_OPEN_PHSP_FOR_READ(#,#);} WITH {;

OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
           ' space handling macros.'//);
}
;
REPLACE {$IAEA_WRITE_PHSP_RECORD(#,#,#,#,#,#,#,#);} WITH {;}

REPLACE {$IAEA_READ_PHSP_HEADER(#,#,#,#,#,#,#,#,#);} WITH {;}

REPLACE {$IAEA_SET_PHSP_RECORD(#,#);} WITH {;}

REPLACE {$IAEA_READ_PHSP_RECORD(#,#,#,#,#,#,#);} WITH {;}

REPLACE {$IAEA_DESTROY_PHSP_FILE(#);} WITH {;}

REPLACE {$IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(#,#);} WITH {;}

REPLACE {$IAEA_UPDATE_PHSP_HEADER(#);} WITH {;}

REPLACE {$IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(#);} WITH {;}


/*****************************************************************************
 *
 *  Macros that combine phsp read/write macros and code around them
 *  into simpler macros for use in BEAM.
 *  The idea is that one could replace such macros with something else.
 *
 ****************************************************************************/

REPLACE {$BEAM_OPEN_PHSP_FOR_WRITE;} WITH {;
    IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
    ELSE                  [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
                          "AUNIT is a character variable"
    "construct phase space file name."
    "part of this--the part that determines the directory and"
    "file prefix--is done in beam"
    IF(IO_OPT=4)[
       phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
       Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
       $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            IZLAST,0,Z_SCORE_SHORT,I_MU_PHSP,0);
    ]
    ELSE[
       phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
       $OPEN_PHSP_FOR_WRITE(IZLAST,IOUTFLU(I),$cstring(phsp_fn),MODE_RW);
    ]
};

REPLACE {$BEAM_OPEN_PHSP_FOR_READ;} WITH {;
    OUTPUT;
    (/' Restarting after previous run, will read old data & phase-space',
      ' files');
    DO I=1,NSC_PLANES [
        OUTPUT IOUTFLU(I);(//' Checking ph-sp file on logical unit ',I4);
        :OPEN_MODE0:;
        IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
        ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
        IF(IO_OPT=4)[
          phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
          Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
          $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            IZLAST,1,Z_SCORE_SHORT,I_MU_PHSP,0);
        ]
        ELSE[
          phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;

          $OPEN_PHSP_FOR_READ(IZLAST,IOUTFLU(I),$cstring(phsp_fn),
           MODE_RW,NPPHSPSP,NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);

           NPPHSP(I)=NPPHSPSP;
        ]
     ]
};

REPLACE {$BEAM_WRITE_PHSP;} WITH {;
    IF(IOUTFLU(ISCORE)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(ISCORE)-43;]
    ELSE                       [WRITE(AUNIT,'(I1)') IOUTFLU(ISCORE)-43;]

    "output directory and file prefix are defined in beam.mortran"

    IF(IO_OPT=4)[
      $IAEA_WRITE_PHSP_RECORD(IOUTFLU(ISCORE),NPASS(NP,ISCORE),
                ISCORE,NHSTRY,LATCH(NP),IQ(NP),E(NP),WT(NP),
                X(NP),Y(NP),Z(NP),U(NP),V(NP),W(NP),ZLAST(NP),
                BEAM_MU_INDEX);
    ]

    ELSE[

    IF( i_parallel > 0 ) ["add an _w"
         phsp_fn=$cstring(phsp_fn)// '_w';
         call egs_itostring(phsp_fn,i_parallel,.false.);
    ]
    phsp_fn=$cstring(phsp_fn)// '.egsphsp'//AUNIT;
    $WRITE_PHSP(IZLAST,IOUTFLU(ISCORE),$cstring(phsp_fn),NPPHSP(ISCORE)+1,
                ISCORE:NHSTRY,NPASS(NP,ISCORE),IQ(NP),W(NP),ZLAST(NP),
                LATCH(NP),E(NP),WT(NP):X(NP),Y(NP),U(NP),V(NP));
    ]
    IF(IZLAST = 2)[
         WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY;
         JHSTRY=JHSTRY+1;
         WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) NP,IQ(NP),0,
         XLAST(NP),YLAST(NP),ZLAST(NP),0;
         :GRAPHICS_FORMAT2:FORMAT(3I4,4G15.8,I12);
    ]
   "Check only needed when actually writting to a phsp file"
   IF(NPPHSP(ISCORE)=phsp_upper_limit)[
        $egs_fatal('(//a,i19,4(a/))',
            ' *** WHILE WRITING PHASE SPACE FILE:',
            NPPHSP(ISCORE), ' particles in file.',
            ' Due to the fact that the counter for the number',
            ' of particles in the file cannot be larger than this,',
            ' no more particles will be written to the phsp file.'
        );
    ]
};

REPLACE {$BEAM_PHSP_BUFFER_FLUSH;} WITH {;
     IF(IO_OPT=4)["update no. of primary histories in header"
       DO I1=1,NSC_PLANES[
          NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
          $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(IOUTFLU(I1),NINCPHSP);
          $IAEA_UPDATE_PHSP_HEADER(IOUTFLU(I1));
       ]
     ]
     ELSE["standard BEAMnrc format"
     IF(MODE_RW='MODE0' | MODE_RW='MODE2')[
        NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
        DO I1=1,NSC_PLANES[
           NPPHSPSP=NPPHSP(I1);
           IF(IOUTFLU(I1)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I1)-43;]
           ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I1)-43;]

           "output directory and file prefix defined in beam.mortran"

           phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
           $PHSP_BUFFER_FLUSH(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),NPPHSPSP,I1);
           IF(NPPHSPSP=NPHOTPHSP(I1))[
                  "no electrons"
              $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
                              MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
                              EKMAXPHSP(I1), 0.0, NINCPHSP);
           ]
           ELSE[
              $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
                              MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
                              EKMAXPHSP(I1), EKMINPHSPE(I1), NINCPHSP);
           ]
        ]
        "we store the total particle number in the 1st record of the ph-sp file"
     ]
     ]"end of standard BEAMnrc format"
};

REPLACE {$BEAM_READ_PHSP_FOR_RESTART;} WITH {;
    DO I=1,NSC_PLANES[
       OUTPUT I,NPPHSP(I);
       (//' PH-SP FILE',I4,': '/
          '               TOTAL NO. OF PARTICLES =',I12);
       IF(IO_OPT=0 | IO_OPT=3)["check to see that the user has not"
                               "added phase space files before restarting"
           IF(IO_OPT=4)[
              $IAEA_READ_PHSP_HEADER(IOUTFLU(I),NPPHSP(I),NPHOTPHSP(I),
               EKMAXPHSP(I),NINCPHSP,Z_SCORE,IZLAST1,I_MU_PHSP,IZSCORE);
               EKMINPHSPE(I)=99999.; "info unavailable"
              IF(IZLAST=0 & IZLAST1=1)[
               OUTPUT;
    (//' Error: Phase space file was scored with ZLAST in previous run '/
       ' but you have restarted this run with IZLAST=0.  Restart with'/
       ' IZLAST=1.'//);
               STOP;
              ]
              ELSEIF(IZLAST=1 & IZLAST1=0)[
              OUTPUT;
    (//' Error: Phase space file was scored  without ZLAST in previous run '/
       ' but you have restarted this run with IZLAST=1.  Restart with'/
       ' IZLAST=0.'//);
               STOP;
              ]
           ]
           ELSE[
              $READ_PHSP_HEADER(IOUTFLU(I),MODE_RW,NPPHSPSP,
                        NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);
              NPPHSP(I)=NPPHSPSP;
           ]
           IF(NINCPHSP>
            NINCSRC*(NCASEO+(NRCYCL+1)*(NPASS_ph_spO+NFAT_ph_spO))/NNPHSP)[
                                        "files have been added"
             OUTPUT I;(//' ***ERROR:'/
' Phase space file',I4,' has been added to (using beamdp?) before restarting.'/
' The code currently does not support this.  Please add phase space'/
' files only after all runs, including restarts, are complete.'//);
             "STOP;"
           ]
       ]
       IF(NPPHSP(I) > 0)[
           CALL DATETIME(1);
           OUTPUT TIMEN;(/' READ PH-SP FILE AT ',$TIMEN_FORMAT);
           "Read last particles to check whether it is right"
           IF(IO_OPT=4)[
              "just check that file size=checksum"
              $IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(IOUTFLU(I));
           ]
           ELSE[
              $READ_PHSP_RECORD(IZLAST,IOUTFLU(I),NPPHSP(I)+1:
              NHSTRYM,ZLAST(1),LATCHM,EINM,WTM,XINM,YINM,UINM,VINM);
           "binary read"
           OUTPUT NPPHSP(I),LATCHM,EINM,XINM,YINM,UINM,VINM,WTM;(//
           ' (LATCHM,EINM,XINM,YINM,UINM,VINM,WTM) FOR PARTICLE No.',
           I12,' IN THIS FILE:'/' ',I12,6F12.5);
           "CALL TIME(TIMEN);"
           "OUTPUT TIMEN;"
           "(/' FINISHED READING PH-SP FILE AT ',$TIMEN_FORMAT);"
           ]
           OUTPUT; (/' FINISHED READING PH-SP FILE AT ',$);
           call egs_time(6); OUTPUT; (' ');
       ]
    ]"end of loop over planes"
};

REPLACE {$BEAM_CLOSE_PHSP;} WITH {;
IF(n_parallel=0 | ~is_finished) [
"do not close phsp files that have already been closed"
"after individual parallel jobs have ended"
IF (IO_OPT =  0)|((IO_OPT =  3)&(IHSTRY <= 100000))|(IO_OPT=4) [
      "phase-space output"
  DO I=1,NSC_PLANES [
     IF(IO_OPT=4)[
        $IAEA_DESTROY_PHSP_FILE(IOUTFLU(I));
     ]
     ELSE[
        CLOSE(IOUTFLU(I));
     ]
  ]
]
]
};

REPLACE {$DOSXYZ_OPEN_PHSP_FOR_WRITE;} WITH {;
    "Added by T. popescu and J.Lobo to write phsps in dosxyz."
    "only done for IAEAphsps."
    "Some mods by BW."
    IF(IRESTART=0) [
     $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            0,0,z_score_tmp,i_muidx_out,1);
    ]
    ELSEIF(IRESTART=1) [
     $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            0,1,z_score_tmp,i_muidx_out,1);
    ]
};

REPLACE {$DOSXYZ_WRITE_PHSP;} WITH {;
    "Added by T. popescu and J.Lobo to write phsps in dosxyz."
    "only done for IAEAphsps"
    $IAEA_WRITE_PHSP_RECORD(i_unit_out,0,
                1,nhist,latch(np),iq(np),e(np),
                wt(np), x(np),y(np),z(np),u(np),v(np),w(np),zlast_tmp,
                frMU_indx); "added MU index (JL 2013)"
                "zlast not used in dosxyz so this is a dummy variable"

};

REPLACE {$DOSXYZ_SET_OUT_PHSP_HEADER;} WITH {;
    "Added by T. popescu and J.Lobo to write phsps in dosxyz."
    "only done for IAEAphsps"
    IF(isource = 0 |  isource = 1 | isource = 3 | isource = 7)[
        ainflu=dble(IHSTRY+ncaseold-nsmiss-nmissm);
    ]
    ELSEIF(isource = 2 | isource = 8 )[
        ainflu=dble(IHSTRY+ncaseold+nsmiss+
         (NRCYCL+1)*(nsrjct+nsoutside+ndbsrjct))/float(nshist)*NINCSRC;
    ]
    ELSEIF(isource=4)[
        ainflu=dble(IHSTRY+ncaseold-nsmiss);
    ]
    ELSEIF(isource=6)[
        ainflu=dble(IHSTRY+ncaseold);
    ]
    ELSEIF(isource=9|isource=10|isource=21)[
        ainflu=dble(nhist);
    ]
    ELSEIF(isource=20)[
        ainflu = dble((NRCYCL+1)*(nnread))/dble(nshist)*NINCSRC;
    ]
    $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(i_unit_out,ainflu);
    $IAEA_UPDATE_PHSP_HEADER(i_unit_out);

};

" The following are null macros that will be overwritten by the library "
" version of BEAM "
REPLACE {$DECLARE-PARTICLE-CONTAINER;} WITH {;};

"End of phsp_macros.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc macros for IAEA phase space data format                             "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Blake Walters, 2007                                       "
"                                                                             "
"  Contributors:    Iwan Kawrakow                                             "
"                   Ernesto Mainegra-Hing                                     "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Macros for reading and writing phase space data in the official IAEA       "
"  format.  See the online documentation at https://www-nds.iaea.org/phsp/    "
"  for more about this format. These macros make use of the C++ IAEA phase    "
"  space handling routines in directory $HEN_HOUSE/iaea_phsp/, which are      "
"  provided for public use by the IAEA.                                       "
"                                                                             "
"  In order to use the routines, Fortran compilation must include the flags:  "
"                                                                             "
"  $HEN_HOUSE/iaea_phsp/iaea_header.cpp                                       "
"  $HEN_HOUSE/iaea_phsp/iaea_phsp.cpp                                         "
"  $HEN_HOUSE/iaea_phsp/iaea_record.cpp                                       "
"  $HEN_HOUSE/iaea_phsp/utilities.cpp                                         "
"  -lm -lstdc++                                                               "
"                                                                             "
"  In BEAMnrc, this is done by going into $HEN_HOUSE/specs/beamnrc.spec and   "
"  setting `BEAM_OBJECTS =` the above flags.                                  "
"                                                                             "
"  These macros also make use of variables in COMIN/RWPHSP defined in         "
"                                                                             "
"  $HEN_HOUSE/utils/phsp_macros.mortran                                       "
"                                                                             "
"  hence they must be included in the mortjob.mortran file AFTER              "
"                                                                             "
"  $HEN_HOUSE/utils/phsp_macros.mortran                                       "
"                                                                             "
"  These macros are defined as null in phsp_macros.mortran in case the IAEA   "
"  C++ routines are unavailable and cannot be included in the code.           "
"                                                                             "
"#############################################################################"


REPLACE {$IAEA_OPEN_PHSP_FOR_WRITE(#,#,#,#,#,#,#);} WITH {;
"Input parameters:"
"{P1}=unit number"
"{P2}=file name"
"{P3}=IZLAST"
"{P4}=IRESTART=0 for first run, 1 for restart"
"{P5}=Z position of the scoring plane"
"{P6}=IMUPHSP"
"{P7}=IZSCORE, set to 1 to score Z for each particle"
"note that if IRESTART=1, then nothing is done with {P3} and {P5}"

call iaea_new_source({P1},{P2},{P4}+2,iaea_result);
IF(iaea_result<0)[
    WRITE(i_log,*)' Error opening IAEA phase space file for write.';
    $CALL_EXIT(1);
]
i_iaea_open_for_write=1;
IF({P4}=0)[
  IF({P7}~=1) call iaea_set_constant_variable({P1},2,{P5});
  IF({P3}~=0)[
     IF({P6}~=0)[
        call iaea_set_extra_numbers({P1},2,1);
        "use generic user type for MU_INDEX"
        call iaea_set_type_extrafloat_variable({P1},1,0);
        iaea_i_muidx_out=2;
     ]
     ELSE [
        call iaea_set_extra_numbers({P1},1,1);
     ]
     call iaea_set_type_extrafloat_variable({P1},0,3);
     iaea_i_zlast_out=1;
  ]
  ELSEIF({P6}~=0)[
     call iaea_set_extra_numbers({P1},1,1);
     call iaea_set_type_extrafloat_variable({P1},0,0);
     iaea_i_muidx_out=1;
  ]
  ELSE[
     call iaea_set_extra_numbers({P1},0,1); "always store LATCH"
  ]
  call iaea_set_type_extralong_variable({P1},0,2);
  iaea_i_latch_out=1;
]
}
;

REPLACE {$IAEA_OPEN_PHSP_FOR_READ(#,#);} WITH {;
"Input parameters:"
"{P1}=unit number"
"{P2}=file name"

call iaea_new_source({P1},{P2},1,iaea_result);
IF(iaea_result<0)[
       WRITE(i_log,*)' Error opening IAEA phase space source.';
]

}
;

REPLACE {$IAEA_PARSE_FOR_WRITE(#,#,#,#,#,#,#,#,#);} WITH {;
"input parameters"
"{P1}=WT"
"{P2}=X"
"{P3}=Y"
"{P4}=Z"
"{P5}=U"
"{P6}=V"
"{P7}=W"
"{P8}=ZLAST"
"{P9}=BEAM_MU_INDEX"

WT_PHSP_SHORT={P1};
X_PHSP_SHORT={P2};
Y_PHSP_SHORT={P3};
Z_PHSP_SHORT={P4};
U_PHSP_SHORT={P5};
V_PHSP_SHORT={P6};
W_PHSP_SHORT={P7};
ZLAST_PHSP_SHORT={P8};
MUIDX_PHSP_SHORT={P9};
}


REPLACE {$IAEA_WRITE_PHSP_RECORD(#,#,#,#,#,#,#,#);} WITH {;
"input parameters"
"{P1}=unit number"
"{P2}=NPASS"
"{P3}=scoring plane no."
"{P4}=NHSTRY (primary history no.)"
"{P5}=LATCH"
"{P6}=IQ"
"{P7}=E"
"{P8}=WT,X,Y,Z,U,V,W,ZLAST,BEAM_MU_INDEX"

IF({P2}=0)["do not output if NPASS=1"
    ESHORT={P7}; "put energy into single precision"
    "calculate increment in primary history no. between this particle"
    "and last particle scored"
    iaea_n_stat={P4}-IHSTRY_PHSP({P3});
    IHSTRY_PHSP({P3})={P4}; "reset ihstry"
    "JWU: IAEA phsp uses kinetic energy!"
    IF( ({P6}=1) | ({P6}=-1) )[
          ESHORT = ESHORT - 0.5109989461;
    ]
    $IAEA_PARSE_FOR_WRITE({P8});
    IF(i_iaea_open_for_write=1)[
      iaea_extra_ints(iaea_i_latch_out)={P5};"store LATCH"
  IF(iaea_i_zlast_out>0) iaea_extra_floats(iaea_i_zlast_out)=ZLAST_PHSP_SHORT;
  IF(iaea_i_muidx_out>0) iaea_extra_floats(iaea_i_muidx_out)=MUIDX_PHSP_SHORT;
    ]
    ELSE[
      "use same array indices as input IAEA phsp file"
      "we only get here if the IAEA_OPEN_PHSP_FOR_WRITE macro"
      "has not been used"
      iaea_extra_ints(iaea_i_latch)={P5};"store LATCH"
      IF(iaea_i_zlast>0) iaea_extra_floats(iaea_i_zlast)=ZLAST_PHSP_SHORT;
      IF(iaea_i_muidx>0) iaea_extra_floats(iaea_i_muidx)=MUIDX_PHSP_SHORT;
    ]
    call iaea_write_particle({P1},iaea_n_stat,iaea_q_typ({P6}+2),ESHORT,
        WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT,Z_PHSP_SHORT,U_PHSP_SHORT,
        V_PHSP_SHORT,W_PHSP_SHORT,iaea_extra_floats,iaea_extra_ints);
]
}
;

REPLACE {$IAEA_READ_PHSP_HEADER(#,#,#,#,#,#,#,#,#);} WITH {;
"input parameters"
"{P1}=unit number"
"{P2}=total no. of particles"
"{P3}=total no. of photons"
"{P4}=max, K.E. of all particles"
"{P5}=no of incident primary histories"
"{P6}=Z of scoring plane"
"{P7}=IZLAST"
"{P8}=IMUPHSP"
"{P9}=IZSCORE"

call iaea_get_max_particles({P1},-1,iaea_dummy_long);
{P2}=iaea_dummy_long;
call iaea_get_max_particles({P1},1,iaea_dummy_long);
{P3}=iaea_dummy_long;
call iaea_get_total_original_particles({P1},iaea_dummy_long);
{P5}=iaea_dummy_long;
call iaea_get_maximum_energy({P1},EKMAX_PHSP_SHORT);
{P4}=EKMAX_PHSP_SHORT;
call iaea_get_constant_variable({P1},2,Z_PHSP_SHORT,iaea_result);
IF(iaea_result=-3)[
 write(i_log,*)
    ' Z positions of each particle will be read from phase space data.';
  {P6}=999.;
  {P9}=1; "tell host code that Z is scored"
]
ELSEIF(iaea_result<0)[
  write(i_log,*)' Error reading Z position where IAEA phsp was scored.';
  {P9}=0;
]
ELSE[
  {P6}=Z_PHSP_SHORT;
  {P9}=0;
]
call iaea_get_extra_numbers({P1},iaea_n_extra_floats,iaea_n_extra_ints);
IF(iaea_n_extra_floats = -1 | iaea_n_extra_ints = -1)[
  write(i_log,*)' Error reading number of extra variables stored in IAEA phsp';
]
call iaea_get_type_extra_variables({P1},iaea_result,iaea_extra_int_types,
   iaea_extra_float_types);
IF(iaea_result=-1)[
  write(i_log,*)' Error getting types of extra variables stored in IAEA phsp';
]
DO I_PHSP=1,iaea_n_extra_ints [
  IF(iaea_extra_int_types(I_PHSP)=2)[
    iaea_i_latch=I_PHSP;
    EXIT;
  ]
]
IF(iaea_i_latch=-99)[
    write(i_log,*)' Warning: IAEA format phsp file does not store LATCH';
]
DO I_PHSP=1,iaea_n_extra_floats [
  IF(iaea_extra_float_types(I_PHSP)=3)[
    iaea_i_zlast=I_PHSP;
    EXIT;
  ]
]
IF(iaea_i_zlast=-99)[
    {P7}=0; "no zlast"
]
ELSE[
    {P7}=1;
]
"test to see if this file contains MU_INDEX"
"we assume this is the first float after zlast, if zlast is scored,"
"and has generic user type = 0"
iaea_i_muidx=MAX(1,iaea_i_zlast+1);
IF(iaea_i_muidx>iaea_n_extra_floats | iaea_extra_float_types(iaea_i_muidx)~=0) [
  iaea_i_muidx=-99;"reset this to no scoring"
  {P8}=0;
]
ELSE[
  {P8}=1;
]
;
}
;

REPLACE {$IAEA_SET_PHSP_RECORD(#,#);} WITH {;
"input parameters"
"{P1}=unit no."
"{P2}=record no. (particle no.) to go to"

iaea_dummy_long={P2};
call iaea_set_record({P1},iaea_dummy_long,iaea_result);
IF(iaea_result<0)[
    WRITE(i_log,*)' Error going to record ',{P2},' in IAEA phsp file.';
    $CALL_EXIT(1);
]
}
;

REPLACE {$IAEA_PARSE_FOR_READ(#,#,#,#,#,#,#,#,#);} WITH {;
"input parameters"
"{P1}=WT"
"{P2}=X"
"{P3}=Y"
"{P4}=Z"
"{P5}=U"
"{P6}=V"
"{P7}=W"
"{P8}=ZLAST"
"{P9}=MU_INDEX"

{P1}=WT_PHSP_SHORT;
{P2}=X_PHSP_SHORT;
{P3}=Y_PHSP_SHORT;
{P4}=Z_PHSP_SHORT;
{P5}=U_PHSP_SHORT;
{P6}=V_PHSP_SHORT;
{P7}=W_PHSP_SHORT;
{P8}=ZLAST_PHSP_SHORT;
{P9}=MUIDX_PHSP_SHORT;
}

REPLACE {$IAEA_READ_PHSP_RECORD(#,#,#,#,#,#,#);} WITH {;
"input parameters"
"{P1}=unit number"
"{P2}=NPASS"
"{P3}=NHSTRY (no. of primary histories represented by particle read)"
"{P4}=LATCH"
"{P5}=IQ"
"{P6}=E"
"{P7}=WT,X,Y,Z,U,V,W,ZLAST,MU_INDEX"

{P2}=0; "no multiple passers stored in IAEA format"

call iaea_get_particle({P1},iaea_n_stat,iaea_q_index,ESHORT,WT_PHSP_SHORT,
        X_PHSP_SHORT,Y_PHSP_SHORT,Z_PHSP_SHORT,U_PHSP_SHORT,
        V_PHSP_SHORT,W_PHSP_SHORT,iaea_extra_floats,iaea_extra_ints);
IF(iaea_n_stat=-1)[
  WRITE(i_log,*)' Error getting particle data from IAEA phsp file.';
  $CALL_EXIT(1);
]
ELSEIF(iaea_n_stat=-2)[
  WRITE(i_log,*)' WARNING: Reached end of IAEA phsp file.  File restarted.';
]
ELSEIF(iaea_n_stat>=0)[
  {P3}={P3}+iaea_n_stat;
  IF(iaea_i_latch=-99)[
    {P4}=0; "latch not stored here"
  ]
  ELSE [
    {P4}=iaea_extra_ints(iaea_i_latch);
  ]
  {P5}=iaea_typ_q(iaea_q_index);
  "JWU: IAEA phsp uses kinetic energy!"
  IF( ({P5}=1) | ({P5}=-1) )[
      ESHORT = ESHORT + 0.5109989461;
  ]
  {P6}=ESHORT;
  IF(iaea_i_zlast=-99)[
    ZLAST_PHSP_SHORT=0; "no zlast stored"
  ]
  ELSE [
    ZLAST_PHSP_SHORT= iaea_extra_floats(iaea_i_zlast);
  ]
  IF(iaea_i_muidx=-99)[
    MUIDX_PHSP_SHORT=0; "no mu_index stored"
  ]
  ELSE [
    MUIDX_PHSP_SHORT= iaea_extra_floats(iaea_i_muidx);
  ]
  $IAEA_PARSE_FOR_READ({P7});
]
}
;
REPLACE {$IAEA_DESTROY_PHSP_FILE(#);} WITH {;
"input parameters"
"{P1}=unit number"

call iaea_destroy_source({P1},iaea_result);

IF(iaea_result<0)[
  WRITE(i_log,*)' Error closing IAEA phase space ID ',{P1};
]
}
;
REPLACE {$IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(#,#);} WITH {;
"input parameters"
"{P1}=unit number"
"{P2}=no. of incident primary histories"

iaea_dummy_long={P2};
call iaea_set_total_original_particles({P1},iaea_dummy_long);
}
;

REPLACE {$IAEA_UPDATE_PHSP_HEADER(#);} WITH {;
"input parameters"
"{P1}=unit number"

call iaea_update_header({P1},iaea_result);

IF(iaea_result<0)[
  WRITE(i_log,*)' Error writing IAEA phase space header for ID ',{P1};
  $CALL_EXIT(1);
]
}
;

REPLACE {$IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(#);} WITH {;
"input parameters"
"{P1}=unit number"

call iaea_check_file_size_byte_order({P1},iaea_result);

IF(iaea_result=-3)[
  WRITE(i_log,*)' ERROR: Size of phase space file does not match';
  WRITE(i_log,*)' the value of checksum in the header.  Something may be';
  WRITE(i_log,*)' wrong.  Check your file.';
  $CALL_EXIT(1);
]
ELSEIF(iaea_result=-4)[
  WRITE(i_log,*)' ERROR: Byte order in the phase space file does not';
  WRITE(i_log,*)' match the machine you are running on.';
  $CALL_EXIT(1);
]
ELSEIF(iaea_result=-5)[
  WRITE(i_log,*)' ERROR: Size of file does not match the value of checksum';
  WRITE(i_log,*)' in the header AND there is a byte order mismatch between';
  WRITE(i_log,*)' the file and the machine you are running on.';
  $CALL_EXIT(1);
]
ELSEIF(iaea_result=-1)[
  WRITE(i_log,*)' ERROR: Cannot open phase space header.';
  $CALL_EXIT(1);
]
ELSEIF(iaea_result=-2)[
  WRITE(i_log,*)' ERROR: Something is wrong with the phase space file.';
  $CALL_EXIT(1);
]
}
;
%E
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc macros for component modules                                "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          George Ding, 1992                                         "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Blake Walters                                             "
"                   Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Mortran macros for the component modules of BEAM. A header for definitions "
"  of $CM_LIST and $CM_TYPE which are added right after this by the scrips to "
"  the .mortjob.mortran file.                                                 "
"                                                                             "
"#############################################################################"


%L
%Q1
%C80
!INDENT F4;
!INDENT M4;
;
" **************************
" List of component modules:
" **************************
"
"  The list of identifiers of components to be included in the accelerator model
"  is defined in the $CM_LIST replacement macro.  This must be modified prior
"  to the MORTRAN compile step in order to generate an executable program with a
"  different sequence and set of component modules.  The component modules must
"  be listed in order of increasing Z.
"
"  The type of each component module is indicated in the $CM_TYPE macro.
"
"  This is the end of beam_cm_macros.hdr but the beam script will insert
"  a couple of macros here with the required lists.
"
" The following is an example for a 2 CM case using CM SLABS and CHAMBER,
"  identifiers FOILS and ION_CH
"
"  REPLACE{$CM_LIST} WITH {CMLIST(
"         ION_CH,
"         FOILS
"     )}
"  REPLACE{$CM_TYPE} WITH {CMTYPE(
"         CHAMBER,
"         SLABS
"     )}
"=======end of example, following this is the real thing============"
"
REPLACE{$CM_LIST} WITH {CMLIST(
      PHANTOM
   )}
REPLACE{$CM_TYPE} WITH {CMTYPE(
      CHAMBER
   )}
REPLACE{$SYNC_CM_LIST} WITH {SYNCCMLIST(
      END_SYNC_CMS
   )}
REPLACE{$DYN_CM_LIST} WITH {DYNCMLIST(
      END_DYN_CMS
   )}
REPLACE{$CM_TYPE} WITH {CMTYPE(
      CHAMBER
   )}
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module macros: parallel plate monitor chamber     "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


%Q1
%C80
!INDENT F4;
!INDENT M4;
;
"-------------------------------------------------------------------------------
"     CHAMBER miscellaneous replacement macros
"-------------------------------------------------------------------------------
"
;
REPLACE {$MAX_N_PHANTOM} WITH {200}
"        ==========="
;
"-------------------------------------------------------------------------------
"     CHAMBER component module common
"-------------------------------------------------------------------------------
"
"V>COMMON/CM_PHANTOM/
"V>================
"V>ICM_PHANTOM        = index of CM, set as ICM in INPUT_$tag and never re-set
"V>IRSTART_PHANTOM    = first region number for this CM
"V>IREND_PHANTOM      = last region number for this CM
"V>N_PHANTOM          = number of regions in CM
"V>TITLE_PHANTOM      = title of CM
"V>ZFRONT_PHANTOM     = Front of CM (air)
"V>ZBACK_PHANTOM      = Front of CM (air)
"V>ZMIN_PHANTOM       = Upstream Z boundary of first cylinder slab
"V>ZMAX_PHANTOM       = Downstream Z boundary of this CM
"V>Z_PHANTOM(I)
"V>RCYS_PHANTOM(I,3)     = radius of a cylindeRS
"V>RCYS2_PHANTOM(I,3)    = squre of radius of a cylinder
"V>IR_PHANTOM         = local region number
;
REPLACE {COMIN/CM_PHANTOM/;} WITH {
   COMMON/CM_PHANTOM/
      Z_PHANTOM,
      ZFRONT_PHANTOM,
      ZBACK_PHANTOM,
      ZMIN_PHANTOM,
      ZMAX_PHANTOM,
      RCYS_PHANTOM,
      RCYS2_PHANTOM,
      TITLE_PHANTOM,
      ICM_PHANTOM,IRSTART_PHANTOM,IREND_PHANTOM,
      N_PHANTOM,N_GAP_PHANTOM,
      N_CHM_PHANTOM, N_TOP_PHANTOM,
      N_BOT_PHANTOM,
      IR_PHANTOM;
   INTEGER
      ICM_PHANTOM,IRSTART_PHANTOM,IREND_PHANTOM,
      N_PHANTOM ,N_GAP_PHANTOM,
      N_CHM_PHANTOM, N_TOP_PHANTOM,
      N_BOT_PHANTOM, IR_PHANTOM;
   $REAL
      ZFRONT_PHANTOM,
      ZBACK_PHANTOM,
      ZMIN_PHANTOM,
      ZMAX_PHANTOM,
      RCYS_PHANTOM($MAX_N_PHANTOM,3),
      RCYS2_PHANTOM($MAX_N_PHANTOM,3);
   REAL*8 Z_PHANTOM(1:$MAX_N_PHANTOM+1);  "P Selvam change"
   CHARACTER*1 TITLE_PHANTOM(60);
} "end of replacement defining common for this CM"
;
;
"-------------------------------------------------------------------------------
"     CHAMBER HOWNEAR replacement macro
"-------------------------------------------------------------------------------
"V>PHANTOM_CM_HOWNEAR(#)
"V>===================
"V>
;
REPLACE {PHANTOM_CM_HOWNEAR(#);} WITH  { CALL HOWNEAR_PHANTOM({P1}); }
;
"End of CHAMBER_macros.mortran"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc short main program                                          "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Iwan Kawrakow, 2004                                       "
"                                                                             "
"  Contributors:                                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The original long main program in BEAM was refactored so that one can more "
"  easily create a shared library from BEAM that can be loaded as a source    "
"  from another user code. This file must be concatenated just before         "
"  the beamnrc.mortran file.                                                  "
"                                                                             "
"#############################################################################"


program beam_main;

implicit none;

$INTEGER ircode;

call egs_init;
call beam_init(ircode);
  " beam_init returns trhe following error codes: "
  " ircode < 0 => fatal error (e.g. wrong input format, etc.)"
  " ircode > 0 => skip shower loop (becuase e.g. the user just wants "
  "                                 to combine results or do stat. anal."
  " ircode = 0 => normal execution "

  write(6,*) '*********** Returned from beam_init: ircode = ',ircode;
IF( ircode < 0 ) [ $CALL_EXIT(1); ]
IF( ircode = 0 ) call beam_shower_loop;
IF( ircode = 2 ) [ call beam_finish(1); ]
ELSE             [ call beam_finish(0); ]
$CALL_EXIT(0);
end;

%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc core source code                                            "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Dave Rogers, 1995                                         "
"                                                                             "
"  Contributors:    Rock Mackie                                               "
"                   Alex Bielajew                                             "
"                   Bruce Faddegon                                            "
"                   George Ding                                               "
"                   Charlie Ma                                                "
"                   Jiansu Wei                                                "
"                   Blake Walters                                             "
"                   Geoff Zhang                                               "
"                   Daryoush Sheikh-Bagheri                                   "
"                   Jiangshen Sun                                             "
"                   Iwan Kawrakow                                             "
"                   Ernesto Mainegra-Hing                                     "
"                   Frederic Tessier                                          "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


%Q1
%C80
!INDENT F4;
!INDENT M4;
;
REPLACE {$BEAM_VERSION}
WITH {,' ',}
;
"*****************************************************************************
"*****************************************************************************
"
"                             *************                            ""toc:
"                             *           *                            ""toc:
"                             * BEAMnrc   *                            ""toc:
"                             *           *                            ""toc:
"                             *************                            ""toc:
"                                                                      ""toc:
"*******************************************************************************
"*******************************************************************************
;
;
"                          GENERAL DESCRIPTION                         ""toc:
"                          *******************
"
"   The code is used to determine the full phase-space spectra of electrons,
"   photons, and positrons that are produced by  a radiotherapy unit.
"   The output spectrum file can be used as a source input file to either
"   BEAMnrc or various other routines, in particular, DOSXYZnrc. The latter code
"   is used to determine 3-D dose distributions in arbitrary voxel geometries.
"
"   This code system is designed to work under the standard NRC Unix
"   system for running EGSnrc but needs extended buffers in MORTRAN3.

"   The names of the additional MORTRAN files required to complete this code
"   are listed in beamnrc.configuraion.
"
"   This code is maintained un SCCS control and a complete history of
"   changes is available via that utility.
"
"   The code is kept on $OMEGA_HOME/beam.
"
"*******************************************************************************
;
"                            ROUTINES CALLED                           ""toc:
"                            ***************
"
"   User-written routines common to all component modules:
"       HOWFAR, INPUTS, ISUMRY, OSUMRY, ISOURCE, MXRNGE, SRCHST, SRCOTO,
"       SRCOUT, WHERE_AM_I.
"   These routines are all contained in this file along with AUSGAB, which is
"   called from various EGSnrc routines.
"
"   User-written routines needed for each component module:
"       INPUT_$CMNAME, ISUMRY_$CMNAME, HOWFAR_$CMNAME, WHERE_AM_I_$CMNAME.
"   $CMNAME is a 1-8-character alphanumeric tag which uniquely defines a
"   component module. These routines are contained in $CMNAME_cm.mortran.
"   Associated macros are in $CMNAME_macros.mortran.
"
"   EGSnrc routines:
"       HATCH, SHOWER, SIGMA, WATCH.
"
"*******************************************************************************
"
"                                IO Units                              ""toc:
"                               ********
"
"        Unit number  file
"
"       1    listing file for user
"       2    state of random no. generator at start of history(ISTORE non-zero)
"       3    ploting file
"       4    stored scoring arrays written end each batch for restart
"       5    user input from keyboard or input file
"       6    echo of user input / log file
"       7    echo of input file - for restart or creating a file interactively
"       8    EGSnrc echos the cross section data read in to this unit
"      17    EGS_windows geometry file
"      12    HATCH reads the cross section data prepared by PEGS4 from this unit
"      13    EGS_windows file  for graphical display particle histories
"      15    File for output of EGSnrc input warnings/errors
"      42    input phase space file
"      44    output phase space data
"      45    output phase space data
"      46    output phase space data
"      99    input energy spectrum  (file named & opened internally)
"
"      Unit numbers are associated with file names at run time via
"      $OMEGA_HOME/beamnrc/beamnrc.environment
"
"*******************************************************************************
;
"                                COMMONS USED                          ""toc:
"                                ************
"
"   The MAIN routine requires the following common blocks.  A * indicates that
"   MORTRAN replacement macros are used in BEAMnrc or $CMNAME_macros to define
"   the common.
"
"   Common blocks written specifically for BEAMnrc:
"      CMs*, CM_$CMNAME*, ENERGYSRC, GEOM, IO_INFO, SCORE, SOURCE,
"      USER*.
"   One common block /CM_$CMAME/ is associated with each component module. These
"   common blocks are intended to be used together.  Variable names in
"   /CM_$CMNAME/ all end with _$CMNAME.
"   MORTRAN replacement macros for the component module common blocks
"   reside in $CMNAME_macros.mortran.
"   The common block USER is comprised of the following common blocks:
"     USER-PHOTON-FORCING* -- photon forcing variables
"     USER-RANGE-REJECTION* -- range rejection variables
"     USER-SPLITTING* -- variables for arbitrary splitting (some global
"                        variables for bremsstrahlung splitting and rus. rou.)
"     USER-STACK* -- additional variables that must be added to the stack
"
"   Common blocks also used by other OMEGA-BEAM user codes:
"      BMODEL*, RWPHSP.
"         BMODEL -- variables for beam characterization models.  Stored
"                   in beammodel_macros.mortran, but replaced by ;
"                   (from beamnrc_user_macros.mortran) if beammodel_macros.
"                   mortran is not available.
"         RWPHSP -- variables for handling phase space data.  Stored in
"                   phsp_macros.mortran.
"
"   EGSnrc common blocks:
"      BOUNDS, BREMPR, EDGE, ELECIN, EPCONT, MEDIA, MISC, PHOTIN, STACK,
"      THRESH, UPHIOT, USEFUL, RANDOM.
"
"*******************************************************************************
;
"                                 KNOWN BUGS/RESTRICTIONS
"                                 **********
"
"  RESTRICTIONS discussed in manuals etc
"
"*******************************************************************************
"*******************************************************************************
;
"                            DESCRIPTION OF VARIABLES                  ""toc:
"                            ************************
"
"
"  Each variable in the common blocks is defined on a line containing the
"  character sequence 'V>'.
"
"  Each local variable is defined on a line that contains the character
"  sequence 'T>'.
"
;
"*******************************************************************************
"I>
"I>                     FORMAT OF PARAMETER-DEFINITION(input) FILE     ""toc:
"I>                     ******************************************     ""toc:
"
"  This section describes the variables input from the parameter-definition
"  file, FORTRAN unit 5, file extension of '.egs4inp'.  These variables
"  define the parameters specific to each simulation.  Each line in this
"  section and the related sections in the component module subroutines
"  is preceeded with the character sequence 'I>'.
"
"I>                       GENERAL INPUT/OUTPUT PARAMETERS
"I>                       *******************************
"I>
"I>  First record    TITLE   80A1
"I>  ************
"I>
"I>  Next Record  MEDIUM for nominal air (as in pegs4dat file)
"I>  ***********
"I>               In many CMs, the region about the central-axis or at the
"I>               front or back of the CM, is assumed to be this medium.
"I>               It is thought of and referred to as air, but can be anything.
"I>               Default is VACUUM. MEDIUM must exactly match name in pegs4dat
"I>-----------------------------------------------------------------------------
;
"%A00
"I>  Next Record
"I>  ***********
"I>     IWATCH,ISTORE,IRESTART,IO_OPT,IDAT,LATCH_OPTION,IZLAST
"I>
"I>             IWATCH = 0 for normal output (the default)
"I>                    = 1 output for every discrete interaction
"I>                    = 2 output for every electron/photon step as well
"I>                    = 4 outputs file for graphics
"I>                    = -N set to 2 on history N, set to 0 on all other
"I>                         histories (for debugging purposes)
"I>             ISTORE = 0 store rn seeds for the 1st history of a batch
"I>                    = 1 store initial rn status (unit 2) for each history
"I>                        being simulated
"I>                    =-1 start first history with rn status from file (unit 2)
"I>                        This is a debugging tool. If run quits, rerun with
"I>                        ISTORE=1, then again ISTORE=-1 and IWATCH = 1/2
"I>                        and/or the debugger on.
"I>           IRESTART = 0 first run for this data set (the default)
"I>                    = 1 restart of a previous run
"I>                    = 2 just create the input file and exit
"I>                    = 3 read in the raw data from a previous run and do
"I>                       the statistical analysis on dose etc.
"I>                    = 4 read in the .egsdat files from parallel jobs
"I>                        having the same base name as the input file but
"I>                        with the extension _w#, where #
"I>                        can be any positive integer.  These .egsdat files
"I>                        will be summed and then the result analyzed similar
"I>                        to IRESTART=3.
"I>             IO_OPT = 0 phase-space output at each scoring plane(the default)
"I>                    = 1 no phase-space output when particles cross scoring
"I>                        plane
"I>                    = 2 no phase-space output but do data analysis for
"I>                        simplified source models
"I>                    = 3 phase-space output up to 100 k particle histories
"I>                        then do analysis only for simplified source models
"I>                    = 4 output phase space in IAEA format
"I>             IDAT   = 0 store data arrays for re-use (takes time but safer)
"I>                    = 1 don't store them
"I>      LATCH_OPTION  = 0 defaults to 2
"I>                    = 1 LATCH for secondaries not inherited from primaries
"I>                        Bits 1-23 set for all regions particle is in
"I>                    = 2 LATCH bits set for all regions particle is in
"I>                        and inherited by secondaries
"I>                        also record bit regions where secondaries created
"I>                        and whether they were created by brem photons
"I>                    = 3 = option 2 but the region numbers are recorded
"I>                        for photons where they interact rather than where
"I>                        they pass through
"I>            IZLAST  = 0 do not score ZLAST etc. (the default)
"I>                    = 1 score the z-position of the last site of interaction
"I>                        for photons and creation of electrons by a photon.
"I>                    = 2 score the xyz-position of the last site of
"I>                        interaction in the file $.egs4gph to be used by
"I>                        EGS_WINDOWS. IWATCH=4 must not be used at same time.
"I>                        Note that for phase space inputs, ZLAST is passed
"I>                        through, but XLAST and YLAST are not.
"I>----------------------------------------------------------------------------
;
"%A01
"I>  Next Record            MONTE CARLO CONTROL INPUT
"I>  ***********            *************************
"I>
"I>     NCASE,IXXIN,JXXIN,TIMMAX,IBRSPL,NBRSPL,IRRLTT,ICM_SPLIT
"I>             NCASE  = # of histories to run for this simulation
"I>                      (min:$NCASEMIN = 100 for IWATCH=0)
"I>             IXXIN  = 1st random number initial seed (blank or 0 OK)
"I>                      Note that, if using the ranlux random no. generator,
"I>                      this input is the luxury level and should have a
"I>                      value >=0 and <=4.  Otherwise, a default luxury
"I>                      level of 1 will be used.
"I>             JXXIN  = 2nd random number initial seed (blank or 0 OK)
"I>             TIMMAX = max cpu time allowed for this run in hours
"I>                      (default=0.99)
"I>             IBRSPL = 0 no brem splitting
"I>                    = 1 with uniform brem splitting
"I>                    = 2 with directional bremsstrahlung splitting (DBS)
"I>             NBRSPL = brem splitting number AND
"I>                      annihilation splitting number (if IRRLTT=2)
"I>             IRRLTT = 0 no Russian Roulette (the default).  Also, no
"I>                        annihilation or higher-order splitting.
"I>                    = 1 no longer used.  This defaults to IRRLTT=2
"I>                    = 2 perform Russian Roulette--eliminates all but one
"I>                        of secondary charged particles created by split
"I>                        photons.
"I>                        If the surviving particle undergoes another (higher-
"I>                        order) bremsstrahlung event or an annihilation,
"I>                        resulting photons are split again by NBRSPL for
"I>                        IBRSPL=1. (ie uniform splitting)
"I>
"I>             Note: The input IRRLTT is automatically set to 0 if IBRSPL=2
"I>                   This is because Directional Bremsstrahlung Splitting
"I>                   does not use the built-in Russian Roulette of EGSnrc
"I>
"I>          ICM_SPLIT = 0 no splitting of photons and electrons as they cross
"I>                        a plane at the start of a user-specified CM
"I>                    > 0 Split photons and electrons a user-specified number
"I>                        of times as soon as they cross the arbitrary
"I>                        splitting plane at the top of this CM #.
"I>
;
"I>  Next record (if IBRSPL=2)
"I>  ***********
"I>
"I>     FS,SSD,ICM_DBS,ZPLANE_DBS,IRAD_DBS,ZRR_DBS  (6F12.0)
"I>                 FS = radius of field (cm) into which bremsstrahlung photons
"I>                      must be directed if they are to be split.
"I>                SSD = distance from bremsstrahlung target where FS
"I>                      is defined.
"I>        ICM_DBS and   These are only required to define the splitting
"I>                      plane if IBRSPL=2.  As soon as
"I>         ZPLANE_DBS   a fat electron reaches ZPLANE_DBS within CM number
"I>                      ICM_DBS, it gets split NBRSPL times.  This is designed
"I>                      to improve electron statistics in the current
"I>                      implementation of directional bremsstrahlung
"I>                      splitting (DBS).  If ICM_DBS=0, then no electron
"I>                      splitting is done (recommended if only good photon
"I>                      statistics are required).  Note that ZPLANE_DBS is
"I>                      the index of the plane within ICM_DBS, not the Z
"I>                      position of the plane.  Usually, ICM_DBS will
"I>                      be the CM number of the flattening filter in the
"I>                      accelerator.  If this is modelled using FLATFILT
"I>                      or CONESTAK, then ZPLANE_DBS will denote the layer
"I>                      no. (starting from the top).  If the flattening
"I>                      filter is modelled using CONS3R, then only two
"I>                      planes are available: ZPLANE_DBS=1 is the plane
"I>                      at the top of the structure and ZPLANE_DBS=2 is the
"I>                      plane at the bottom of the structure.  Currently,
"I>                      only FLATFILT, CONESTAK and CONS3R support these
"I>                      inputs.  Usually ZPLANE_DBS is the plane defining the
"I>                      bottom of the flattening filter.
"I>           IRAD_DBS   Set to 1 if you want the NBRSPL split electrons
"I>                      to be distributed in a radially-symmetric manner
"I>                      about the beam axis.  Note that the beam must be
"I>                      radially symmetric above the splitting plane for this
"I>                      to make sense.  Set to 0 (the default) otherwise.
"I>           ZRR_DBS    Z position of the russian roulette plane (cm).  Only
"I>                      required if IBRSPL=2.  This defines the Z
"I>                      position of a plane within the geometry below which
"I>                      non-fat photons about to undergo a compton, pair
"I>                      or photoelectric event will NOT be subject to
"I>                      russian roulette and compton, pair or photoelectric
"I>                      events from fat photons will be split NBRSPL times.
"I>                      This is designed to increase the number of electrons
"I>                      (albeit with a lower weight) below this plane and
"I>                      is only used if electron splitting is on (ie
"I>                      ICM_DBS above is > 0).  Note that radiative events
"I>                      (bremsstrahlung, annihilation) of non-fat electrons
"I>                      below this plane are not split. Usually, the Russian
"I>                      Roulette plane is above the electron splitting plane,
"I>                      and so it is within the flattening filter
"I>                      but somewhere above the bottom.  Note that ZRR_DBS is
"I>                      in cm whereas the electron splitting plane must be
"I>                      on a horizontal boundary in a CM.
"I>
"I>  Next record (if ICM_SPLIT>0)
"I>  ***********
"I>
"I>     NSPLIT_PHOT,NSPLIT_ELEC (2I3)
"I>            NSPLIT_PHOT = The photon splitting number.
"I>            NSPLIT_ELEC = The electron splitting number.
"I>     This input is unrelatted to bremm splittin and is designed to improve
"I>     efficiency in phantom depth-dose calculations.
"I>------------------------------------------------------------------------
;
"%A02
"I>
"I>                SOURCE GEOMETRICAL CONFIGURATION INPUT
"I>                **************************************
"I>
"I>  Next Record  specifies charge and type of source of incident particles
"I>               The meaning of parameters depends on source type
"I>
"I>  ISOURC = 0   PARALLEL BEAM INCIDENT FROM THE FRONT (+VE Z-AXIS)
"I>  **********
"I>
"I>     IQIN,ISOURC,RBEAM,UINC,VINC,WINC
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  0
"I>             RBEAM   radius of parallel beam in cm (defaults to max radius
"I>                     if RBEAM < 0 or > max radius
"I>                     max radius =RMAX_CM(1) for circular CM boundary
"I>                                =RMAX_CM(1)*SQRT(2) for square CM )
"I>             UINC    incident x-axis direction cosine
"I>             VINC    incident y-axis direction cosine
"I>             WINC    incident z-axis direction cosine
"I>                     Note: (UINC,VINC,WINC) get automatically normalized
"I>                           defaults to (0.0,0.0,1.0)
"I>------------------------------------------------------------------------
;
"%A03
"I>  ISOURC = 1   POINT SOURCE ON Z-AXIS INCIDENT FROM THE FRONT
"I>  **********                circular or square
"I>
"I>     IQIN,ISOURC,DISTZ,RBEAM,GAMMA,XINL,XINU,YINL,YINU
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  1
"I>             DISTZ   distance of the point source above front of first
"I>                     CM at Z=Z_min_CM(1). Defaults to  100 cm
"I>             RBEAM   radius of the beam on front of first CM
"I>                     defaults to max radius of first CM if GAMMA is also 0.
"I>                     or:
"I>                     If negative, denotes that that field on front of
"I>                     first CM is rectangular
"I>             GAMMA   1/2 angle about z-axis(degrees) of source,
"I>                     ONLY if RBEAM=0.0
"I>             XINL,XINU,YINL,YINU  Lower and upper X boundaries and
"I>                     Y boundaries of rectangular field on first CM in
"I>                     cm.  ONLY if RBEAM<0.
"I>------------------------------------------------------------------------
;
"%A04
"I>  ISOURC = 3  UNIFORM ISOTROPICALLY RADIATING SOURCE WITHIN CMs
"I>  **********        Circular: Vertical ring centred on Z-axis
"I>                       or     horizontal cylinder centred parallel to X-axis
"I>
"I>     IQIN,ISOURC,RMINBM,RBEAM,ZSMIN,ZSMAX,i_dsb,splitcm_dsb,dsb_delta
"I>             IQIN    charge of particles from source (defaults to 0)
"I>             ISOURC  =  3
"I>             RMINBM  inner radius of vertical ring (RBEAM >= 0) (cm)
"I>                     or:
"I>                     Z position of centre of horizontal cylinder
"I>                     (RBEAM < 0) (cm)
"I>             RBEAM   outer radius of vertical ring (RBEAM >= 0) (cm)
"I>                     or:
"I>                     -radius of horizontal cylinder (RBEAM < 0) (cm)
"I>             ZSMIN   Z of top of vertical ring (RBEAM >= 0) (cm)
"I>                     or:
"I>                     min. X of horizontal cylinder (RBEAM < 0) (cm)
"I>             ZSMAX   Z of bottom of vertical ring (RBEAM >= 0) (cm)
"I>                     or:
"I>                     max. X of horizontal cylinder (RBEAM < 0) (cm)
"I>             i_dsb   Set to 1 to use directional source biasing.  Note that
"I>                     directional bremsstrahlung splitting (IBRSPL=2) must
"I>                     also be used.  Splitting number (NBRSPL), splitting
"I>                     field radius (FS), source to surface distance
"I>                     (SSD) and electron splitting parameters (if e-
"I>                     contamination is desired) are read from the DBS
"I>                     inputs.
"I>       splitcm_dsb   The CM no. at which primary photons are split and
"I>                     radially redistributed about the Z-axis.  Photons
"I>                     are split/redistributed immediately upon entering
"I>                     CM no. splitcm_dsb.  Note that this should be the
"I>                     the no. of the first CM in the treatment head without
"I>                     radial symmetry.  The number of times a photon is
"I>                     split depends upon the radial bin into which it
"I>                     is directed.  Bin radii are determined by the input
"I>                     dsb_delta below.  Set splitcm_dsb=0 for no splitting/
"I>                     redistribution.
"I>         dsb_delta   The min. linear distance, in cm, between split/
"I>                     redistributed photons, projected to the SSD of the
"I>                     splitting field. dsb_delta is used to divide the
"I>                     splitting field into radial bins, where photons
"I>                     directed into bin i are split i times.
"I>
"I>         NOTE: The sign of RBEAM determines if the source will be a
"I>                      vertical ring a horizontal cylinder.
"I>               The Z-span of the source must be in the range
"I>                      Z_min_CM(1)-Z_min_CM(MAX_CMs+1).
"I>               Currently, this source is limited to being placed within
"I>                      CONESTAK, FLATFILT or SIDETUBE
"I>------------------------------------------------------------------------
;
"%A04a
"I>  ISOURC = 3a  A cylindrical, isotropically radiating Co60 source within CMs
"I>  **********  using directional source biasing (DSB).
"I>
"I>     IQIN,ISOURC,RMINBM,RBEAM,ZSMIN,ZSMAX,i_dsb,DSB_DELTA
"I>           (same is source 3)
"I>------------------------------------------------------------------------
;
"%A05
"I>  ISOURC = 5   NRC SWEPT BEAM SOURCE
"I>  **********
"I>
"I>     IQIN,ISOURC,GAMMA,RBEAM
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  5
"I>             GAMMA   1/2 angle of cone in degrees
"I>             RBEAM   radius of beam spot at Z = 0.0 (cm)
"I>
"I>     Note apex of cone is at x=y=0,z=Z_min_CM(1)
"I>---------------------------------------------------------------------
;
"%A06
"I>  ISOURC = 6   RECTANGULAR BEAM INCIDENT FROM THE FRONT
"I>  **********
"I>
"I>     IQIN,ISOURC,XBEAM0,YBEAM0,XBEAM,YBEAM
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  = 6
"I>             XBEAM0  X position of centre of beam (cm)
"I>             YBEAM0  Y position of centre of beam (cm)
"I>             XBEAM   half-width in X direction (cm)
"I>             YBEAM   half-width in Y direction (cm)
"I>---------------------------------------------------------------------
;
"%A07
"I>  ISOURC = 7   SCANNING BEAM SOURCE (sawtooth like Therac20)
"I>  **********
"I>
"I>     IQIN,ISOURC,FD_AT100, IRATIO_YXF, RBEAM
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  7
"I>             FD_AT100   length & width of scanning field at  SSD=100cm
"I>             IRATIO_YXF =  the number of Y scans per X scan
"I>                          (rounds 2*IRATIO_YXF up to nearest odd
"I>                          number--default IRATIO_YXF = 6.5)
"I>             RBEAM   radius of the beam at Z=0, defaults to 0.01cm
"I>----------------------------------------------------------------------
;
"%A08
"I>  ISOURC = 8   SCANNING BEAM FOR MM50 (uniform circular beam from
"I>  *********                            a point on axis at Z=0)
"I>
"I>     IQIN,ISOURC,DISTZ,RBEAM
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  8
"I>             DISTZ   SSD (default to 100 cm)
"I>             RBEAM   radius of scanned beam at SSD.  If set <=0 or
"I>                     too large, then RBEAM gets reset to
"I>                     RMAX_CM(1)*DISTZ/Z_min_CM(1) (circular CM 1) or
"I>                     SQRT(2)*RMAX_CM(1)*DISTZ/Z_min_CM(1) (square CM 1)
"I>                     so that particles strike the front of
"I>                     CM 1 within a circle of radius RMAX_CM(1)
"I>                     or SQRT(2)*RMAX_CM(1).
"I>             RBEAM0  Radius of beam spot at Z=0cm.  Defaults to 0
"I>                     if RBEAM0<0 and gets reset to
"I>                     RMAX_CM(1)*DISTZ/Z_min_CM(1)-RBEAM (circular CM 1)
"I>                     or SQRT(2)*RMAX_CM(1)*DISTZ/Z_min_CM(1)-RBEAM
"I>                     (square CM 1) if RBEAM+RBEAM0 >
"I>                     RMAX_CM(1)*DISTZ/Z_min_CM(1) or >
"I>                     SQRT(2)*RMAX_CM(1)*DISTZ/Z_min_CM(1).
"I>    For this source the particles start at Z_min_CM(1) and hence
"I>    Z_min_CM(1) must be >= 0.0
"I>----------------------------------------------------------------------
;
"%A09
"I>  ISOURC = 9   SCANNING BEAM FOR MM50 (discrete field coverage from
"I>  *********                            a point source at Z=0)
"I>
"I>     IQIN,ISOURC,DISTZ,NPTS_SRC9
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  9
"I>             DISTZ   SSD (default to 100 cm)
"I>         NPTS_SRC9   the number of discrete points at the SSD
"I>                     defaults to $MAXPTS_SRC9 if NPTS_SRC9 > $MAXPTS_SRC9
"I>                     or 1 if NPTS_SRC9 <= 0.
"I>
"I>  Next record (if ISOURC=9)
"I>  *************************
"I>
"I>     Repeat for I=1,NPTS_SRC9
"I>
"I>     X_SRC9(I),Y_SRC9(I),PROB_SRC9(I) (3F15.0)
"I>              X_SRC9(I)     X coordinate of point I at the SSD (cm)
"I>              Y_SRC9(I)     Y coordinate of point I at the SSD (cm)
"I>              PROB_SRC9(I)  probability of a particle being at point I
"I>
"I>     Note that PROB_SRC9(I) need not be normalized; they are
"I>     automatically normalized in the source routine.
"I>    For this source the particles start at Z_min_CM(1) and hence
"I>    Z_min_CM(1) must be >= 0.0
"I>----------------------------------------------------------------------
;
"%A10
"I>  ISOURC = 10   PARALLEL CIRCULAR BEAM INCIDENT FROM THE SIDE
"I>  ***********
"I>                (NOTE: beam facing X-AXIS, I.E., UINC should be < 0.0   )
"I>                (this source should only be used together with CM XTUBE )
"I>                (for simulating the target of an X-ray tube.            )
"I>                (XTUBE should always be the first CM in the geometry.   )
"I>
"I>     IQIN,ISOURC,RBEAM,UINC,VINC,WINC
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  10
"I>             RBEAM   radius of parallel beam in cm (defaults to max radius)
"I>             UINC    incident X-axis direction cosine (UINC < 0.0)
"I>             VINC    incident Y-axis direction cosine
"I>             WINC    incident Z-axis direction cosine
"I>                     Note: (UINC,VINC,WINC) get automatically normalized
"I>                           defaults to (-1.0,0.0,0.0)
"I>---------------------------------------------------------------------
;
"%A11
"I>  ISOURC = 13   PARALLEL RECTANGULAR BEAM INCIDENT FROM THE SIDE
"I>  ***********
"I>                (Note beam facing X-axis, i.e., UINC should be < 0.0    )
"I>                (this source should only be used together with CM XTUBE )
"I>                (for simulating the target of an X-ray tube.            )
"I>                (XTUBE should always be the first CM in the geometry.   )
"I>
"I>     IQIN,ISOURC,YBEAM,ZBEAM,UINC,VINC
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  13
"I>             YBEAM   half-width of parallel beam in cm (defaults to 0.2 cm)
"I>             ZBEAM   half-height of parallel beam in cm (defaults to 0.2 cm)
"I>             UINC    incident X-axis direction cosine (UINC < 0.0)
"I>             VINC    incident Y-axis direction cosine
"I>                     (incident Z-axis direction cosine WINC default to 0.0)
"I>                     Note: (UINC,VINC) get automatically normalized
"I>                           defaults to (-1.0,0.0,0.0)
"I>------------------------------------------------------------------------
;
"%A20
"I>  ISOURC = 15   NRC SWEPT BEAM WITH BEAM DIVERGENCE AND RADIAL INTENSITY
"I>  ***********                                                DISTRIBUTION
"I>
"I>     IQIN,ISOURC,GAMMA,ZFOCUS,RTHETAIN,THETAIN
"I>             IQIN       charge of the incident beam (defaults to 0)
"I>             ISOURC     =  15
"I>             GAMMA      half angle of the cone swept by the beam (degrees)
"I>             ZFOCUS     Z position of the apex of the cone (cm)
"I>             RETHETAIN  radius at which THETAIN, the divergence angle of the
"I>                        beam, is specified (cm).  RTHETAIN must be > 0.
"I>             THETAIN    divergence angle of the beam (degrees).  If GAMMA
"I>                        is not 0, then THETAIN can be set to 0; otherwise
"I>                        it must be > 0.
"I>
"I>      Note that particles are always incident at Z_min_CM(1), regardless of
"I>      the value of ZFOCUS
"I>
"I>  Next record (If ISOURC=15)
"I>  ***********
"I>      SPCNAM       FILENAME (with EXT) containing description of the radial
"I>                   intensity distribution of the incident particles
"I>                                               (maximum 256 characters)
"I>             _______________________________________________________
"I>             FILE FORMAT for SPCNAM:
"I>               NRDIST
"I>               (RDISTF(I),RPDF(I),I=1,NRDIST)
"I>                     NRDIST     # radial bins
"I>                     RDISTF(I)  upper radius of bin I (cm)
"I>                     RPDF(I)    probability of particle being in bin I.
"I>------------------------------------------------------------------------
;
"%A21
"%A22
"I>  ISOURC = 19   PARALLEL ELLIPTICAL BEAM FROM FRONT GAUSSIAN IN X AND Y
"I>  ***********
"I>
"I>     IQIN,ISOURC,RBEAM,UINC,VINC,WINC,sigma_src19,RBEAMY
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  = 19
"I>             RBEAM   sigma of the 2-D gaussian distribution (RBEAM > 0)
"I>                     in the X-direction in cm
"I>                       or
"I>                     -FWHM of 2-D gaussian distribution (RBEAM < 0) in
"I>                     the X-direction in cm
"I>                     Note: sigma of gaussian distribution is limited to
"I>                           <RMAX_CM(1) for circular CM 1 and
"I>                           <SQRT(2)*RMAX_CM(1) for square CM 1
"I>             UINC    incident x-axis direction cosine
"I>             VINC    incident y-axis direction cosine
"I>             WINC    incident z-axis direction cosine
"I>                     Note: (UINC,VINC,WINC) get automatically normalized
"I>                           defaults to (0.0,0.0,1.0)
"I>      sigma_src19    mean angular spread of particles about Z axis
"I>                     in degrees (none if set <=0).  Overrides incident
"I>                     direction cosines if set > 0, so that beam is assumed
"I>                     to be centred on Z axis.
"I>           RBEAMY    same as RBEAM but for Y-direction.  If set to 0,
"I>                     then RBEAMY=RBEAM for a circular beam.
"I>------------------------------------------------------------------------
;
"%A12
"I>  ISOURC = 21   FULL PHASE-SPACE SOURCE
"I>  ***********
"I>
"I>     IQIN,ISOURC,INIT_ICM,NRCYCL,IPARALLEL,PARNUM,ISRC_DBS,RSRC_DBS,
"I>                                                  SSDSRC_DBS,ZSRC_DBS
"I>             IQIN       dummy NOT USED. Set = 9 for this source by BEAMnrc
"I>             ISOURC     = 21
"I>             INIT_ICM   particles start at front surface of this CM
"I>                        (INIT_ICM is actually read as a real)
"I>             NRCYCL     Number of times to recycle each particle in a phase
"I>                        space source.  Each particle in the phase space
"I>                        file is used a total of NRCYCL+1 times before
"I>                        going on to the next particle.
"I>                        If NRCYCL is set <=0 then NRCYCL is automatically
"I>                        calculated to use the entire phase space file with no
"I>                        restarts.  The calculated NRCYCL does not take into
"I>                        account particles that are rejected because they
"I>                        miss the geometry.
"I>                        If NRCYCL is set > 0, then the user-input value is
"I>                        used.
"I>                        If NCASE > no. of particles in the phase space file,
"I>                        then use of NRCYCL is essential for accurate
"I>                        statistics.  If you are unsure of how many times to
"I>                        recycle, use the automatically-calculated value of
"I>                        NRCYCL.  If this still results in many restarts
"I>                        (because of multiple passers being rejected and/or
"I>                        photons rejected because they fall outside the DBS
"I>                        splitting radius--see below)
"I>                        then re-run the simulation with NRCYCL set manually
"I>                        to:
"I>                        NCASE/(NNPHSP-NNPHSP*(NPASS_ph_sp+NFAT_ph_sp)/
"I>                                    (NTOT_ph_sp+NPASS_ph_sp+NFAT_ph_sp) ) -1
"I>                        where NNPHSP is the no. of particles in the file,
"I>                        NTOT_ph_sp is total no. of particles used (not
"I>                        including recycling), NPASS_ph_sp is total no.
"I>                        of multiple passers ignored (not including
"I>                        recycling), and NFAT_ph_sp is the no. of photons
"I>                        rejected (not including recycling because they fall
"I>                        outside the DBS splitting radius at the SSD (only
"I>                        if ISRC_DBS=1--see below)). These numbers are
"I>                        available in the .egslst file.  Always round your
"I>                        calculated value of NRCYCL up.
"I>            IPARALLEL   set >1 if you are distributing the job among
"I>                        IPARALLEL machines.  IPARALLEL is used with PARNUM
"I>                        (see below) to partition a phase space source into
"I>                        IPARALLEL equal parts.
"I>            PARNUM      For each of the IPARALLEL parallel jobs, PARNUM
"I>                        should have a different integer value in the range
"I>                        1<=PARNUM<=IPARALLEL.  The partition of the phase
"I>                        space source that is used for a particular job is
"I>                        then given by:
"I>                           (PARNUM-1)*(NNPHSP/IPARALLEL)<INPHSP<=
"I>                                                (PARNUM)*(NNPHSP/IPARALLEL)
"I>                        where NNPHSP is the total number of particles in the
"I>                        phsp source and INPHSP is the particle no. chosen.
"I>            ISRC_DBS    Set to 1 if you used directional bremsstrahlung
"I>                        splitting (DBS) in the BEAM simulation used to
"I>                        generate this phase space source and you wish to
"I>                        reject photons not aimed into the splitting
"I>                        field(which are fat).  These fat photons compromise
"I>                        statistics.  Set to 0 otherwise.
"I>            RSRC_DBS    DBS splitting radius in BEAM simulation used to
"I>                        generate this source (cm).  Only used if ISRC_DBS=1.
"I>            SSDSRC_DBS  SSD at which RSRC_DBS was defined in the BEAM sim.
"I>                        used to generate this source (cm). Only used if
"I>                        ISRC_DBS=1.
"I>            ZSRC_DBS    Z where the phase space source was collected in
"I>                        the BEAM simulation used to generate this source(cm).
"I>                        Only used if ISRC_DBS=1.
"I>
"I>      Photons are projected from ZSRC_DBS to SSDSRC_DBS and if they will fall
"I>      outside of RSRC_DBS (based on their trajectory) then they will
"I>      be rejected.  This prevents fat photons from compromising statistics.
"I>
"I>  Next record (If ISOURC=21)
"I>  ***********
"I>     SPCNAM        FILENAME (with EXT) contains phase space information
"I>                   (maximum of 256 characters)
"I>------------------------------------------------------------------------
;
"%A32
"I>  ISOURC = 23   BEAM SIMULATION SOURCE
"I>  ***********
"I>
"I>     IQIN,ISOURC,INIT_ICM,ISRC_DBS,ALPHA24,BETA24,DIST24
"I>             IQIN       dummy NOT USED. Set = 9 for this source by BEAMnrc
"I>             ISOURC     = 23
"I>             INIT_ICM   particles start at front surface of this CM
"I>                        (INIT_ICM is actually read as a real)
"I>             ISRC_DBS   Set to 1 if you are using directional bremsstrahlung
"I>                        splitting (DBS) in the BEAM simulation source
"I>                        and you wish to reject fat photons (not aimed into
"I>                        the splitting field).  These fat photons compromise
"I>                        statistics.  Set to 0 otherwise.
"I>              ALPHA24   Angle of rotation of source plane about X-axis
"I>                        in degrees.  Positive angle is clockwise rotation.
"I>                        (-90 < ALPHA24 < 90)
"I>               BETA24   Angle of rotation of source plane about Y-axis
"I>                        in degrees.  Positive angle is counter-clockwise
"I>                        rotation. (-90 < ALPHA24 < 90)
"I>               DIST24   Distance of point of rotation above INIT_ICM.
"I>
"I>     Note restriction that if ALPHA24~=0 and/or BETA24 ~=0, then INIT_ICM
"I>     must be > 1.  This is because the rotation will result in some
"I>     particles incident within INIT_ICM-1.  Also, both INIT_ICM and
"I>     INIT_ICM-1 must be SLABS, SIDETUBE or FLATFILT, since these are the
"I>     only CMs currently capable of determining initial regions for particles
"I>     incident within them.
"I>
"I>  Next record (If ISOURC=23)
"I>  ***********
"I>
"I>     the_beam_code, the_pegs_file, the_input_file (3A80)
"I>
"I>       the_beam_code    The name of the BEAM code you are running as a
"I>                        source (ie BEAM_sourceaccelname).  This must have
"I>                        been compiled as a shared library
"I>                        (libBEAM_accelname.so or BEAM_accelname.dll) and
"I>                        exist in EGS_HOME/bin/config.
"I>       the_pegs_file    The pegs data set used by the BEAM simulation source
"I>                        (no .pegs4dat extension).  This must be in
"I>                        HEN_HOUSE/pegs4/data or EGS_HOME/pegs4/data.
"I>       the_input_file   The input file used to run the BEAM simulation
"I>                        source (no .egsinp extension).  This must exist in
"I>                        your EGS_HOME/BEAM_sourceaccelname directory.  It
"I>                        must be a working input file and must be set up to
"I>                        write a phase space file at a single scoring plane.
"I>                        This plane becomes where particles are sampled from
"I>                        for the second-stage BEAMnrc simulation (no phase
"I>                        space file is scored, however).
"I>------------------------------------------------------------------------
;
"%A33
"I>  ISOURC = 24   FULL PHASE-SPACE SOURCE INCIDENT FROM USER-DEFINED ANGLE
"I>  ***********
"I>
"I>  Inputs identical to ISOURC = 21 with the following additional line of
"I>  inputs after SPCNAM:
"I>
"I>     ALPHA24,BETA24,DIST24
"I>
"I>              ALPHA24   Angle of rotation of source plane about X-axis
"I>                        in degrees.  Positive angle is clockwise rotation.
"I>                        (-90 < ALPHA24 < 90)
"I>               BETA24   Angle of rotation of source plane about Y-axis
"I>                        in degrees.  Positive angle is counter-clockwise
"I>                        rotation. (-90 < ALPHA24 < 90)
"I>               DIST24   Distance of point of rotation above INIT_ICM.
"I>
"I>     Note restriction that if ALPHA24~=0 and/or BETA24 ~=0, then INIT_ICM
"I>     must be > 1.  This is because the rotation will result in some
"I>     particles incident within INIT_ICM-1.  Also, both INIT_ICM and
"I>     INIT_ICM-1 must be SLABS, SIDETUBE or FLATFILT, since these are the
"I>     only CMs currently capable of determining initial regions for particles
"I>     incident within them.
"I>
"I>     The initial idea and much of the coding for Source 24 is courtesy of
"I>     Patrick Downes at University of Cardiff, Wales.
"I>------------------------------------------------------------------------
;
"%A13
"I>  ISOURC =  31     BEAM CHARACTERIZATION MODEL,
"I>  ************
"I>     IQIN,ISOURC,CMSOU
"I>             IQIN    charge of incident beam (not used)
"I>             ISOURC  = 31
"I>             CMSOU   particles start at the front surface of this CM
"I>
"I>  Next record (If ISOURC=31)
"I>  ***********
"I>     SPCNAM        FILENAME (with EXT) contains information on beam model
"I>                   (maximum of 256 characters)
"I>  --------------------------------------------------------------------------
;
"%A14
"I>
"I>  Next Record (IF ISOURC <21)     SOURCE ENERGY INPUT
"I>  ***********                     *******************
"I>
"I>     MONOEN (I8)
"I>                      = 0 if monoenergetic beam (the default)
"I>                      = 1 if energy spectrum to be used
"I>                          Note: BEAMnrc sets MONOEN=2 for phase space inputs
"I>
"I>   Next Record (IF MONOEN = 0)
"I>   ***********
"I>     EIN (F15.0)
"I>                  kinetic energy of the incident beam in MeV
"I>                  (defaults to 1.25), only for MONOEN=0
"I>
"I>   Next Record (IF MONOEN = 1)
"I>   ***********
"I>     FILNAM(256A1)  FILENAME(WITH EXT) contains spectrum information
"I>                   which must be in  NRC's ensrcV format.
"I>             _______________________________________________________
"I>             FILE FORMAT:
"I>             SPEC_TITLE   (A80)
"I>               NENSRC,ENMIN,IMODE (I10,F15.0,I5)
"I>               (ENSRCD(IB),SRCPDF(IB),IB=1,NENSRC) (2F20.0)
"I>                     NENSRC  # Energy bins in spectrum histogram
"I>                     ENMIN   Lower energy of first bin
"I>                     IMODE   =0 assuming counts/bin, =1 counts/MeV
"I>                     ENSRCD(I),SRCPDF(I)  I=1,NENSRC
"I>                             Top of energy bin and probability of
"I>                             initial particle being in this bin.
"I>                             Probability does not need to be normalized
"I>             _______________________________________________________
"I>
"I>   Next Record (IF MONOEN = 1)
"I>   ***********
"I>     IOUTSP (I5):
"I>             = 0 no spectrum data in output summary
"I>             = 1 include spectrum data in output summary
"I>
"I>---------------------------------------------------------------------------
;
"%A15
"I>                     TRANSPORT CONTROL INPUT
"I>                     ***********************
"I>   Next Record
"I>   ***********
"I>     ESTEPIN,SMAX,ECUTIN,PCUTIN,IDORAY,IREJCT_GLOBAL,ESAVE_GLOBAL,IFLUOR
"I>
"I>             ESTEPIN Dummy variable (used to be ESTEPE -- max. fractional
"I>                     energy loss/electron step)
"I>             SMAX    Dummy variable (used to be SMAX -- max. step length)
"I>             ECUTIN  electron cut off in MeV - total energy
"I>                     If this is > ECUT as input in the EGSnrc input section
"I>                     (see below), then ECUT is set to ECUTIN.  Default
"I>                     value for ECUT is AE.
"I>             PCUTIN  photon cut off in MeV.  If this is > PCUT as input
"I>                     in the EGSnrc input section (see below), then PCUT
"I>                     is set to PCUTIN.  Default value for PCUT is AP.
"I>             IDORAY  Dummy variable (used to turn Rayleigh scattering on/off)
"I>      IREJCT_GLOBAL = 0 no electron range rejection
"I>                    = 1 do electron range rejection--if residual
"I>                        range to ECUTRR(IRL) is < DNEAR and
"I>                        electron energy is < ESAVE_GLOBAL, terminate
"I>                        history.  ECUTRR(IRL) may vary from component
"I>                        module to component module and is calculated based
"I>                        on the particle making it to the bottom of the
"I>                        accelerator with energy > ECUT
"I>                    = 2 as in =1, but use a non-calculated ECUTRR = ECUT(IRL)
"I>                        this should be used if interested in more
"I>                        than phase-space data at base of simulation
"I>                 =-1,-2 Same as above, but now Russian Roulette is played
"I>                        with ALL electrons that can not escape the region
"I>                        and are not fat. Only applicable with DBS.
"I>       ESAVE_GLOBAL  energy below which an electron will be discarded
"I>                     If E<ESAVE_GLOBAL & the electron cannot escape from the
"I>                     current region with E>ECUTRR(IRL). This ignores brem
"I>                     losses.
"I>             IFLUOR  Dummy variable (used to turn X-ray fluorescence on/off)
"I>
"I>        The dummy inputs are retained for compatibility with EGS4/BEAM input
"I>        files.
"I>----------------------------------------------------------------------------
;
"%A16
"I>  Next Record        Photon Forcing Controls
"I>  ***********        ***********************
"I>      IFORCE,NFMIN,NFMAX,NFCMIN,NFCMAX
"I>             IFORCE = 0 normal photon transport (the default)
"I>                    = 1 force photon interaction in the geometry
"I>             NFMIN  number of photon interaction/history at which to start
"I>                    photon-interaction-forcing (defaults to 1)--this
"I>                    option has been deleted and NFMIN is now always treated
"I>                    as 1.
"I>             NFMAX  number of photon interaction/history after which to
"I>                    stop forcing photon to interact (defaults to 1)
"I>             NFCMIN number of CM to start photon interaction forcing
"I>                    ( default to 1 )
"I>             NFCMAX number of last CM in which photons forced to interact
"I>                    ( default to max_cms )
"I>                    If a particle passes thru NFCMIN to NFCMAX, it is
"I>                    forced to interact there for the first NFMAX
"I>                    interactions. The WEIGHT
"I>                    of this photon is reduced and the remaining WEIGHT is
"I>                    carried by another photon which will be transported
"I>----------------------------------------------------------------------------
;
"%A17
"I>  Next record             SCORING PLANE INPUT
"I>  ***********             *******************
"I>
"I>    NSC_PLANES, (IPLANE_to_CM(I), I=1,NSC_PLANES)
"I>
"I>       NSC_PLANES     number of scoring planes >=0
"I>       IPLANE_to_CM   CM numbers corresponding to the scoring planes
"I>                      fluence is scored at the back of a component module
"I>                      phase space data written from same planes
"I>
"I>       (Note only IPLANE_to_CM(1) is used for beam model analysis);
"I>
"I>  Next record            SCORING ZONE TYPE/DIMENSIONS
"I>  ***********            ****************************
"I>
"I>  Repeat the next pair of lines for ISCORE=1,...,NSC_PLANES
"I>
"I>     NSC_ZONES(ISCORE), MZONE_TYPE(ISCORE)
"I>          NSC_ZONES     number of scoring zones within each scoring plane
"I>                        (= 0: maximum number available with equal zone area)
"I>          MZONE_TYPE    0 annular zones (default)
"I>                        1 square (ring) zones
"I>                        2 grid
"I>
"I>  Next record (for NSC_ZONES(ISCORE)>0 and MZONE_TYPE = 0 or 1)
"I>  ***********
"I>     (RSCORE_ZONE(ISCORE,I), I=1,NSC_ZONES)  (up to 10/line)
"I>          RSCORE_ZONE   outer radius of each scoring zone in order of
"I>                           increasing radius (MZONE_TYPE = 0)
"I>                        half width from origin of each scoring zone
"I>                           in order of increasing width (MZONE_TYPE = 1)
"I>
"I>  Next record (for NSC_ZONES(ISCORE)>0 and MZONE_TYPE = 2)
"I>  ***********
"I>     XMIN_ZONE, XMAX_ZONE, YMIN_ZONE, YMAX_ZONE, NX_ZONE, NY_ZONE
"I>            XMIN_ZONE     lower x bound of grid area (cm)
"I>            XMAX_ZONE     upper x bound of grid area (cm)
"I>            YMIN_ZONE     lower y bound of grid area (cm)
"I>            YMAX_ZONE     upper y bound of grid area (cm)
"I>            NX_ZONE       number of grid zones in x direction
"I>            NY_ZONE       number of grid zones in y direction
"I>----------------------------------------------------------------------------
;
"%A18
"I>  Next record           DOSE COMPONENTS CALCULATION INPUT
"I>  ***********           *********************************
"I>     ITDOSE_ON
"I>         ITDOSE_ON  = 0 (DEFAULT) only total dose is calculated
"I>                    = 1 total dose and dose components may be calculated
"I>
"I>     There are 2 classes of components. First is selected as dose from
"I>     particles or descendents of particular charge as they cross a
"I>     specified boundary.  Second is based on bit selections in the
"I>     variable LATCH, either inclusive or exclusive sets - i.e. depends
"I>     on where particle has been or interacted.
"I>
"I>  Next record (if ITDOSE_ON=1)
"I>  ***********
"I>     ICM_CONTAM, IQ_CONTAM (2I5)
"I>          All particles of type IQ_CONTAM (0=photons, 1=charged
"I>          particles) are identified as contaminants when they enter
"I>          the front of CM number ICM_CONTAM and their dose is scored as
"I>          contaminant dose in all dose zones.
"I>          If ICM_CONTAM = 0, no contaminant dose is scored.
"I>          LATCH_OPTION = 1 is not allowed with ICM_CONTAM non-zero
"I>
"I>  Next record (if ITDOSE_ON=1)
"I>  ***********
"I>     LNEXC (I5)
"I>           LNEXC: # of dose components scored which exclude dose from
"I>                  particles with certain LATCH bits set - i.e. which have
"I>                  not been in certain regions.
"I>                  LNEXC = 0 is allowed. LNEXC <= $MAXIT - 3
"I>
"I>  Next records (if LNEXC > 0)
"I>  ************
"I>     (L_N_EXC(I,J), J=1, 31 ) (31I5) (repeat LNEXC times, line by line)
"I>           L_N_EXC(I,J): Bit #s in LATCH for dose component I
"I>                 (will exclude dose from component I if these bits set)
"I>
"I>  Next record (if ITDOSE_ON=1)
"I>  ***********
"I>     LNINC (I5)
"I>           LNINC: # of dose components scored for particles
"I>                  from specified regions (with designated bit settings
"I>                  in LATCH).  LNINC <= $MAXIT - LNEXC - 3
"I>
"I>  Next records (if LNINC > 0)
"I>  ************
"I>     (L_N_INC(I,J), J=1, 31 ) (31I5) (repeat LNINC times, line by line)
"I>           L_N_INC(I,J): Bit #s in LATCH for dose component I.
"I>                         These are in two groups/line, separated by a zero.
"I>                         Of the first group of bits, at least one must
"I>                         be set to be in this dose component.
"I>                         The second group need not be present, but if
"I>                         it is, none of these bits can be set to be in
"I>                         this dose component.
"I>
"I>---------------------------------------------------------------------------
;
"%A19
"I>  Next record           INPUT FRONT SURFACE (Z) FOR CM 1
"I>  ***********           ********************************
"I>
"I>     Z_min_CM(1)  Z-coordinate of front surface for component module 1
"I>                  This includes any air gap and defines front of model.
"I>                  A common value will be 0.0 except for sources 8 & 9.
"I>                  For most sources except for ISOURC=3, 21 & 31, this is
"I>                  also the source plane on which the particles are incident
"I>          Note that the front of all CMs is given w.r.t. z = 0.0, not
"I>          w.r.t. Z_min_CM(1).
"I>
"I>  Next record         Blank or dummy line indicating start of
"I>  ***********         input for component modules
"I>
"I>
"I>  Next records (many)       COMPONENT MODULE INPUT
"I>  *************             **********************
"I>
"I>  Component module parameters are input in order of their appearance in the
"I>  code, that is, in the order they occur in $CM_LIST.  See the 'INPUT FROM
"I>  UNIT 5' section in each CM subroutine for the list of input parameters.
"I>
"I>   There are two lines before the input of parameters for each CM:
"I>   one is *********************************************** ,
"I>   the other is RMAX_CM, the outer boundary(radius or 1/2 of square) of CM
"I>
"I>  ---------------------------------------------------------------------------
;
"%A23
"I>                          EGSnrc INPUTS
"I>                          *************
"I>    (modified from the description in $HEN_HOUSE/src/get_inputs.mortran)
"I>
"I>  The input for parameters associated with EGSnrc follows a format
"I>  used by all the standard EGSnrc user codes.  The rest of the BEAMnrc
"I>  input has not been changed because the GUI's make the details of the
"I>  format irrelevant.
"I>
"I>  All input associated with selection of EGSnrc transport parameters
"I>  is not crucial for the execution as there are default values set.
"I>  Therefore, if some of the input options in this section are
"I>  missing/misspelled, this will be ignored and default parameters assumed.
"I>  As the transport parameter input routine uses get_inputs, a lot
"I>  of error/warning messages may be produced on UNIT 15, though.
"I>  If you don't have the intention of changing default settings,
"I>  simply ignore the error messages.
"I>
"I>  The delimiters are
"I>               :start mc transport parameter:
"I>               :stop mc transport parameter:
"I>
"I>  Currently, the following options are available (case does not matter and
"I>             the internal variables are shown in [ ] brackets):
"I>
"%A24
"I>       Global ECUT=     Global (in all regions) electron transport cut
"I>                        off energy (in MeV). If this input is missing,
"I>                        or is < ECUTIN from the main BEAMnrc inputs
"I>                        (See above) then ECUTIN is used for Global ECUT.
"I>                        Global ECUT defaults to AE(medium).
"I>                        [ ECUT ]
"I>       Global PCUT=     Global (in all regions) photon transport cut
"I>                        off energy (in MeV). If this input is missing,
"I>                        or is < PCUTIN from the main BEAMnrc inputs
"I>                        (See above) then PCUTIN is used for Global PCUT.
"I>                        Global PCUT defaults to AP(medium).
"I>                        [ PCUT ]
"I>       Global SMAX=     Global (in all regions) maximum step-size
"I>                        restriction for electron transport (in cm).
"I>                        No SMAX restriction is necessary if the electron
"I>                        step algorithm is PRESTA-II and the EXACT boundary
"I>                        crossing algorithm (the default) is used.  In this
"I>                        case, SMAX will default to 1e10.  However, if either
"I>                         Electron-step algorithm= PRESTA-I
"I>                         or
"I>                         Boundary crossing algorithm= PRESTA-I,
"I>                        then a step-size restriction is necessary, and
"I>                        SMAX will default to 5 cm.
"I>                        [ SMAXIR ]
"%A25
"I>       ESTEPE=          Maximum fractional energy loss per step.
"I>                        Note that this is a global option only, no
"I>                        region-by-region setting is possible. If missing,
"I>                        the default is 0.25 (25%).
"I>                        [ ESTEPE ]
"I>       XImax=           Maximum first elastic scattering moment per step.
"I>                        Default is 0.5, NEVER use value greater than 1 as
"I>                        this is beyond the range of MS data available.
"I>                        [ XIMAX ]
"I>       Boundary crossing algorithm=
"I>                        There are two selections possible: EXACT and
"I>                        PRESTA-I.  PRESTA-I means that boundaries will
"I>                        be crossed a la PRESTA.  That is, with lateral
"I>                        correlations turned off at a distance given by
"I>                        `Skin depth for BCA' (see below) from the boundary
"I>                        and MS forced at the boundary.  EXACT means
"I>                        the algorithm will cross boundaries in a single
"I>                        scattering (SS) mode, the distance from a boundary
"I>                        at which the transition to SS mode is made is
"I>                        determined by `Skin depth for BCA' (see below).
"I>                        Default is EXACT since PRESTA-I may result in
"I>                        significant dose overestimates when CHAMBER is
"I>                        used as a phantom, and EXACT will not significantly
"I>                        increase CPU time in most accelerators.
"I>                        [ bca_algorithm, exact_bca ]
"I>       Skin depth for BCA=
"I>                        Determines the distance from a boundary (in elastic
"I>                        MFP) at which the algorithm will go into single
"I>                        scattering mode (if EXACT boundary crossing) or
"I>                        switch off lateral correlations (if PRESTA-I boundary
"I>                        crossing). Default value is 3 for EXACT or
"I>                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
"I>                        for a definition of BLCMIN). Note that if you choose
"I>                        EXACT boundary crossing and set Skin depth for BCA
"I>                        to a very large number (e.g. 1e10), the entire
"I>                        calculation will be in SS mode. If you choose
"I>                        PRESTA-I boundary crossing and make Skin depth for
"I>                        BCA large, you will get default EGS4 behaviours
"I>                        (no PRESTA)
"I>                        [ skindepth_for_bca ]
"%A26
"I>       Electron-step algorithm=
"I>                        PRESTA-II (the default), the name is
"I>                        used for historical reasons
"I>                        or PRESTA-I
"I>                        Determines the algorithm used to take into account
"I>                        lateral and longitudinal correlations in a
"I>                        condensed history step.
"I>                        [ transport_algorithm ]
"I>       Spin effects=    Off, On, (default is On)
"I>                        Turns off/on spin effects for electron elastic
"I>                        scattering. Spin On is ABSOLUTELY necessary for
"I>                        good back-scattering calculations. Will make a
"I>                        difference even in `well conditioned' situations
"I>                        (e.g. depth dose curves for RTP energy range
"I>                        electrons).
"I>                        [ spin_effects ]
"I>       Brems angular sampling= Simple, KM, (default is KM)
"I>                        If Simple, use only the leading term of the Koch-Motz
"I>                        distribution to determine the emission angle of
"I>                        bremsstrahlung photons. If KM, complete
"I>                        modified Koch-Motz 2BS is used (modifications
"I>                        concern proper handling of kinematics at low
"I>                        energies, makes 2BS almost the same as 2BN at low
"I>                        energies).
"I>                        [ IBRDST ]
"I>       Brems cross sections= BH, NIST, NRC, default is BH
"I>                        If BH is selected, the Bethe-Heitler bremsstrahlung
"I>                        cross sections (Coulomb corrected above 50 MeV)
"I>                        will be used. If NIST is selected, the NIST brems
"I>                        cross section data base (which is the basis for
"I>                        the ICRU radiative stopping powers) will be employed.
"I>                        Differences are negligible for E > ,say, 10 MeV,
"I>                        but significant in the keV energy range.  If NRC is
"I>                        selected, NIST data including corrections for
"I>                        electron-electron brems will be used (typically only
"I>                        significant for low values of the atomic number Z
"I>                        and for k/T < 0.005).
"I>       Triplet production= On or Off (default).  Turns on/off simulation
"I>                        of triplet production.  If On, then Borsellino's
"I>                        first Born approximation is used to sample triplet
"I>                        events based on the triplet cross-section data.
"I>                        [ itriplet ]
"I>       Bound Compton scattering=  On, Off, Simple or norej (default)
"I>                        If Off, Compton scattering will be treated with
"I>                        Klein-Nishina, with On Compton scattering is
"I>                        treated in the Impulse approximation.
"I>                        With Simple, the impulse approximation incoherent
"I>                        scattering function will be used (i.e., no Doppler
"I>                        broadening). With norej the actual total bound
"I>                        Compton cross section is used and there are no
"I>                        rejections at run time.
"I>                        Make sure to use for low energy applications,
"I>                        not necessary above, say, 1 MeV.
"I>                        [ IBCMP ]
"I>       Compton cross sections= Bound Compton cross-section data.  User-
"I>                        supplied bound Compton cross-sections in the file
"I>                        $HEN_HOUSE/data/comp_xsections_compton.data, where
"I>                        comp_xsections is the name supplied for this input.
"I>                        This is only used if Bound Compton scattering= Simple
"I>                        and is not available on a region-by-region basis
"I>                        (see below).  The default file (ie in the absence
"I>                        of any user-supplied data) is compton_sigma.data.
"I>                        [ comp_xsections ]
"I>       Radiative Compton corrections= On or Off (default). If on, then
"I>                        include radiative corrections for Compton scattering.
"I>                        Equations are based on original Brown & Feynman
"I>                        equations (Phys. Rev. 85, p 231--1952).  Requires
"I>                        a change to the user codes Makefile to include
"I>                        $(EGS_SOURCEDIR)rad_compton1.mortran in the
"I>                        SOURCES (just before
"I>                        $(EGS_SOURCEDIR)get_inputs.mortran).
"I>                        [ radc_flag ]
"%A27
"I>       Pair angular sampling= Off, Simple or KM (Default is Simple)
"I>                        If off, pairs are set in motion at an angle m/E
"I>                        relative to the photon direction (m is electron rest
"I>                        energy, E the photon energy). Simple turns on
"I>                        the leading term of the angular distribution
"I>                        (this is sufficient for most applications),
"I>                        KM (comes from Koch and Motz) turns on using 2BS
"I>                        from the article by Koch and Motz.
"I>                        Always use Simple or KM.
"I>                        [ IPRDST ]
"I>       Pair cross sections= BH (default) or NRC.  If set to BH, then use
"I>                        Bethe-Heitler pair production cross-sections.  If set
"I>                        to NRC, then use NRC pair production cross-sections
"I>                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
"I>                        of interest at low energies, where the NRC cross-
"I>                        sections take into account the asymmetry in the
"I>                        positron-electron energy distribution.
"I>                        [ pair_nrc ]
"I>       Photoelectron angular sampling= Off or On (Default is On)
"I>                        If Off, photo-electrons get the direction of the
"I>                        `mother' photon, with On, Sauter's furmula is
"I>                        used (which is, strictly speaking, valid only for
"I>                        K-shell photo-absorption).
"I>                        If the user has a better approach, replace the macro
"I>                            $SELECT-PHOTOELECTRON-DIRECTION;
"I>                        The only application that
"I>                        Only situation encountered where this made a
"I>                        small difference was a big ion chamber (cavity size
"I>                        comparable with electron range) with high-Z walls
"I>                        in a low energy photon beam.
"I>                        [ IPHTER ]
"I>       Rayleigh scattering= Off, On, custom
"I>                        If On, turn on coherent (Rayleigh) scattering.
"I>                        Default is On. Should be turned on for low energy
"I>                        applications.
"I>                        If custom, user must provide media names and form
"I>                        factor files for each desired medium. For the rest
"I>                        of the media, default atomic FF are used.
"I>                        [ IRAYLR ]
"I>       ff media names = A list of media names (must match media found in
"I>                        PEGS4 data file) for which the user is going to
"I>                        provide custom Rayleigh form factor data.
"I>                        [ iray_ff_media($MXMED) ]
"I>       ff file names = A list of names of files containing the Rayleigh
"I>                       form factor data for the media specified by
"I>                       the ff media names = input above.  Full directory
"I>                       paths must be given for all files, and for each medium
"I>                       specified, iray_ff_media(i), there must be a
"I>                       corresponding file name, iray_ff_file(i).  For
"I>                       example files, see the directory
"I>                       $HEN_HOUSE/data/molecular_form_factors.
"I>                       [ iray_ff_file($MXMED) ]
"I>       Atomic relaxations= Off, On, eadl, simple
"I>                        Default is eadl.  On defaults to eadl.
"I>                        When simulating atomic relaxations:
"I>                        - In photo-electric absorption events, the element
"I>                          (if material is mixture) and the shell the photon
"I>                          is interacting with are sampled from the
"I>                          appropriate cross sections
"I>                        - Shell vacancies created in photoelectric,
"I>                          compton and electron impact ionization events
"I>                          are relaxed via emission of fluorescent X-Rays,
"I>                          Auger and Koster-Cronig electrons.
"I>                         The eadl option features a more accurate treatment
"I>                         of relaxation events and uses binding energies
"I>                         consistent with those in of the photon cross
"I>                         sections used in the simulation.  If using
"I>                         mcdf-xcom or mcdf-epdl photon cross sections, you
"I>                         cannot use the simple option and this will
"I>                         automatically get reset to eadl.
"I>                         Make sure to use eadl or simple for low energy
"I>                         applications.
"I>                         [ IEDGFL ]
"%A28
"I>       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
"I>                        gryzinski, penelope.  If set to On or ik, then use
"I>                        Kawrakow's theory to derive EII cross-sections.
"I>                        If set to casnati, then
"I>                        use the cross-sections of Casnati (contained in the
"I>                        file ($HEN_HOUSE/data/eii_casnati.data).  Similar for
"I>                        kolbenstvedt, gryzinski and penelope. This is only of
"I>                        interest in kV X-ray calculations.
"I>                        Case-sensitive except for Off, On or ik options.
"I>                        [ eii_flag ]
"I>       Photon cross sections= Photon cross-section data.  Current options are
"I>                        si (Storm-Israel), epdl (Evaluated Photon Data
"I>                        Library), xcom (the default), pegs4, mcdf-xcom and
"I>                        mcdf-epdl:
"I>                        Allows the use of photon cross-sections other than
"I>                        from the PEGS4 file (unless the pegs4 option is
"I>                        specified).  Options mcdf-xcom and mcdf-epdl use
"I>                        Sabbatucci and Salvat's renormalized photoelectric
"I>                        cross sections with either xcom or epdl for all other
"I>                        cross sections.  These are more accurate but can
"I>                        increase CPU time by up to 6 %.
"I>                        Note that the user can supply their own cross-section
"I>                        data as well. The requirement is that the files
"I>                        photon_xsections_photo.data,
"I>                        photon_xsections_pair.data,
"I>                        photon_xsections_triplet.data, and
"I>                        photon_xsections_rayleigh.data exist in the
"I>                        $HEN_HOUSE/data directory, where photon_xsections
"I>                        is the name specified.
"I>                        Hence this entry is case-sensitive.
"I>                        [ photon_xsections ]
"I>       Photon cross-sections output= Off (default) or On.  If On, then
"I>                        a file $EGS_HOME/user_code/inputfile.xsections is
"I>                        output containing photon cross-section data used.
"I>                        [ xsec_out ]
"I>       Photonuclear attenuation= Off (default) or On
"I>                        If On, models the photonuclear effect. Current
"I>                        implementation is crude. Available on a
"I>                        region-by-region basis (see below)
"I>                        [ IPHOTONUCR ]
"I>       Photonuclear cross sections= Total photonuclear cross sections. User-
"I>                        supplied total photonuclear cross-sections in
"I>                        $HEN_HOUSE/data/photonuc_xsections_photonuc.data,
"I>                        where photonuc_xsections is the name supplied for
"I>                        this input (case sensitive). In the absence of
"I>                        any user-supplied data, or if photonuc_xsections
"I>                        is set to 'default', the default file is
"I>                        iaea_photonuc.data.
"I>                        [ photonuc_xsections ]
"I>
"I>       Atomic relaxations, Rayleigh scattering, Photoelectron angular
"I>       sampling, Bound Compton scattering and Photonuclear attenuation
"I>       can also be turned On/Off on a region-by-region basis.
"I>       To do so, put e.g.
"I>
"I>       Atomic relaxations= On in Regions   or
"I>       Atomic relaxations= Off in regions
"I>                         in your input file. Then use the relevant one of:
"I>       Relaxations start region=
"I>       Relaxations stop region=
"I>                or
"I>       Bound Compton start region=
"I>       Bound Compton stop region=
"I>                or
"I>       Rayleigh start region=
"I>       Rayleigh stop region=
"I>                or
"I>       PE sampling start region=
"I>       PE sampling stop region=
"I>                or
"I>       Photonuclear start region=
"I>       Photonuclear stop region=
"I>
"I>             each followed by a list of one or more
"I>             start and stop regions separated by commas.
"I>        Example:
"I>        Atomic relaxations= On in Regions
"I>        Relaxations start region=  1, 40
"I>        Relaxations stop region=  10, 99
"I>                         will first turn off relaxations everywhere and
"I>                         then turn on in regions 1-10 and 40-99.
"I>                         Note that input is checked against min. and max.
"I>                         region number and ignored if
"I>                         start region < 1 or stop_region > $MXREG or
"I>                         start region > stop region.
"I>
"%A29
"I> ---------------------------------------------------------------------------
"I>
"I>                          Rejection Plane Inputs
"I>                          **********************
"I>
"I>  Used to define a rejection plane for use in conjunction with directional
"I>  bremsstrahlung splitting (DBS, IBRSPL=2, see above).
"I>  Inputs can exist without IBRSPL=2, but they will not be used.
"I>
"I>  Inputs must appear between the delimiters:
"I>  :Start DBS rejection plane:
"I>  :Stop DBS rejection plane:
"I>
"I>  Inputs are:
"I>
"I>     Use a rejection plane= Off, On (default is Off)
"I>                           Set to On if you want to define a rejection
"I>                           plane.
"I>                           [USE_REJPLN]
"I>     Z(cm) from zero reference plane= Z position of reference plane.
"I>                           [Z_REJPLN]
"I>
"I>     Fat photons and electrons will be discarded if they are about
"I>     to interact at Z>=Z_REJPLN.  Used to prevent correlated particles
"I>     from being created close to a scoring plane, compromising
"I>     statistics.
"%A30
"I>  ---------------------------------------------------------------------------
"I>
"I>          Bremsstrahlung Cross Section Enhancement (BCSE) Inputs
"I>          ******************************************************
"I>
"I>  Inputs for the BCSE variance reduction technique.
"I>
"I>  Inputs must appear between delimiters:
"I>  :Start BCSE:
"I>  :Stop BCSE:
"I>
"I>  Inputs are:
"I>
"I>      Use BCSE= Off, On (default is Off)
"I>              Set to On to use BCSE.
"I>              [USE_BCSE]
"I>      Media to enhance= A list of media in
"I>              which to enhance the bremsstrahlung cross-section.  If
"I>              none of the media is found in the accelerator, then no
"I>              BCSE is done.
"I>              [is_bcse_medium]
"I>      Enhancement constant= Floating point factor by which bremsstrahlung
"I>              cross-sections are enhanced. Typical values are in the range
"I>              20 (megavoltage accelerators) -- 500 (x-ray tubes in
"I>              mammography energy range).
"I>              [BCSE_FACTOR_C]
"I>      Enhancement power= Floating point number that us used for an energy
"I>              dependent BCSE. If this input is <=0, then a constant
"I>              BCSE factor is used that is given by BCSE_FACTOR_C. But if
"I>              this input is >0, then the BCSE factor is computed on-th-fly
"I>              using 1 + BCSE_FACTOR_C*(E(np)-rm)**BCSE_POWER_N.
"I>              Typical values for BCSE_POWER_N are 2...4. Note that
"I>              BCSE_FACTOR_C must be adjusted accordingly so that the above
"I>              equations gives a factor of 20 (megavoltage accelerators) --
"I>              500 (low energy x-ray tubes) for the maximum energy of the
"I>              incident electron spectrum.
"I>              If in doubt, just set to <=0 because the gain from an
"I>              energy dependent BCSE is modest (~20%).
"I>
"I>  Note that if BCSE is used in conjunction with uniform bremsstrahlung
"I>  splitting (UBS) then
"I>  Russian Roulette is automatically turned on (IRRLTT=2--see above).
"I>
"I>  BCSE is most efficient when used in conjunction with DBS or UBS
"I>
"%A31
"I>  ---------------------------------------------------------------------------
"I>
"I>                          CUSTOMIZED USER INPUTS
"I>                          **********************
"I>
"I>  This section contains inputs that are unique to the user.  In general
"I>  the user must modify beamnrc.mortran to read these inputs from the
"I>  .egsinp file.  Also, the GUI will not give access to these inputs.
"I>  If no custom inputs are required, then this section can be omitted
"I>  entirely.
"I>
"I>  Custom user inputs must appear in the .egsinp file between the delimiters:
"I>       :Start user inputs:
"I>       :Stop user inputs:
"I>
"I>  This section can appear either just before or just after the EGSnrc
"I>  inputs (see above).
"I>
"I>  Currently, the only custom user input hard-coded in beamnrc.mortran
"I>  is:
"I>
"I>   PHSP OUTPUT DIRECTORY= /full directory path to where phase space files
"I>                           are to be output, or blank
"I>             This allows the user to specify a directory other than
"I>             $EGS_HOME/BEAM_accelname in which to write phase space data.
"I>             Useful if phase space files are large and, due to disk space
"I>             limitations, must be written to a /temp area.  If left blank
"I>             or omitted entirely, then phase space files are output to the
"I>             default $EGS_HOME/BEAM_accelname directory.
"I>             [ PHSP_OUTDIR ]
"I>
"I>*****************************************************************************
;
"                        MORTRAN REPLACEMENT MACROS                    ""toc:
"                        **************************
"
"   The replacement macros which define the component module common blocks
"   are situated in $CMNAME_macros.mortran, one set for each component module.
"   beamnrc_user_macros.mortran contains macros available for modification
"   by the user.  All of these files are placed before beamnrc.mortran (this
"   file) before compilation is carried out.
"
"*******************************************************************************
;
"                               EGSnrc MACROS                            ""toc:
"                               ***********
;
"
" The following macro is used in the EGSnrc code system and replaces
" the definition of this macro found in egsnrc.macros
"
" ***************
" Negative USTEP:
" ***************
" Following macro used in ELECTR.  Negative values of USTEP set to 0.  Prints
" USTEP if <-1E-4.  Stops printing after 1000 negative USTEP values encountered
" to prevent filling the log file.  For BEAMnrc, set IAUSFL(6) to 0 since
" negative USTEP values are often encountered on boundaries and this may have
" been preceeded by a call to WHERE_AM_I where IAUSFL(6) is set to 1.  Since a
" negative USTEP will prevent an immediate call to AUSGAB, if this change were
" not made, IAUSFL(6) would remain set to 1 on exit from ELECTR
" and AUSGAB would be called the next time through ELECTR with IAUSFL(6)=1,
" giving an error in AUSGAB since in this case, ICMNEW=ICM.
"
REPLACE {$USER-CONTROLS-NEGATIVE-USTEP;} WITH {
"         ============================"
  ;IF (USTEP<-1.E-4) [
"reset USTEP to 0 for fast step to set region number and medium only"
     IERUST=IERUST+1;
     IF (IERUST<1000) [
        ICM = IR_to_CM(IR(NP));
        OUTPUT IERUST,USTEP,IR(NP),IRNEW,IROLD,
           IRL-IR_start_CM(ICM)+1,ICM,
           X(NP),Y(NP),Z(NP),SQRT(X(NP)**2+Y(NP)**2),E(NP),IQ(NP),
           U(NP),V(NP),W(NP);
           (4X,I4,' *** WARNING *** NEGATIVE USTEP=',E10.3,/10X,
            'IR,IRNEW,IROLD=',3I5,', Local IR=',I3,', ICM=',I3,
            /10X,'X,Y,Z,R=',4(1PE13.5)/10X,'E(NP),IQ(NP)=',1PE13.5,I5,
            /10X,'U,V,W = ',3(1PE13.5));
     ]
     ELSE IF (IERUST=1000) [
        OUTPUT;(///' *** ERROR ***  More than 1000 USTEP errors'///);
        WRITE(IOUTLIST,
                '(///'' *** ERROR ***  More than 1000 USTEP errors''///)');
        OUTPUT IHSTRY;(///' Number of histories sofar completed = ',I10///);
        WRITE(IOUTLIST,
                '(///'' Number of histories sofar completed ='',I10///)');
        $CALL_EXIT(1);
     ]
  ]
  USTEP=0.0;
  }
;

"the following calculates BLCMIN on the fly if using PRESTA-I as the"
"BCA--can save a lot of time, overrides macro of the same name in egsnrc.macros"
"This has been commented out because it produced real differences in"
"electron dosxyz calculations.  New default is to use PRESTA-I BCA with"
"fixed BLCMIN"
"REPLACE {$SET-SKINDEPTH(#,#);} WITH {"
"   ;IF( exact_bca ) ["
"        $CALCULATE-ELASTIC-SCATTERING-MFP(ssmfp,{P1},{P2});"
"        skindepth = skindepth_for_bca*ssmfp;"
"    ]"
"    ELSE ["
"        p2 = {P1}*({P1}+rmt2); beta2 = p2/(p2 + rmsq);"
"        xccl = xcc(medium); blccl = blcc(medium); chia2 = xccl/(4*blccl*p2);"
"        skindepth ="
"          skindepth_for_bca*2*p2*beta2/xccl/(log(1+1./chia2)*(1+chia2)-1);"
"        IF( skindepth > 5 ) skindepth = 5;"
"    ]"
"};"

"uncomment the following to change the defaults for certain EGSnrc input"
"parameters in egsnrc.macros.  The settings below can speed up MV simulations"
"at little/no cost to accuracy"

"Brems angular sampling= Simple"
"REPLACE {$IBRDST-DEFAULT} WITH {0}
;

"Bound Compton scattering= Off"
"REPLACE {$IBCMP-DEFAULT} WITH {0}
;

"Atomic relaxations= Off"
"REPLACE {$IEDGFL-DEFAULT} WITH {0}
;

"Photoelectron angular sampling= Off"
"REPLACE {$IPHTER-DEFAULT} WITH {0}
;

"Rayleigh scattering = Off"
"REPLACE {$IRAYLR-DEFAULT} WITH {0}
;

"required to prevent needless calls to interaction subroutines"
"if a zero weight particle is placed on the stack--in DBS"
REPLACE {$AUSCALL(#);} WITH
   {IARG={P1} ;
    IF (IAUSFL(IARG+1).NE.0) CALL AUSGAB(IARG);
   IF(WT(NP)=0) RETURN;} ;

"
"*******************************************************************************
;
"                               BEAMnrc MACROS                          ""toc:
"                               ***********
"*******************************************************************************
"
%E    "beamnrc.mortran - start of range rejection macro                   "
" **************************************************
" Range rejection macro:
" **********************
" BEAMnrc bypasses the EGSnrc built-in range rejection (implemented in
" the $RANGE-DISCARD macro in EGSnrc) because EGSnrc range rejection
" uses particle range to AE, while we want to use particle range to
" ECUTRR(IRL), where ECUTRR(IRL)=ECUT(IRL) (IREJCT_GLOBAL=2) or
" ECUTRR(IRL)=energy required to leave region IRL and still have energy
" > ECUTIN at the bottom of the accelerator (IREJCT_GLOBAL=1).  In the
" macro below, DNEAR(NP) is the perpendicular distance from the particle to the
" nearest region boundary, range is the particle range to AE (calculated in
" EGSnrc) and RANGE_ECUTRR(IRL) is the range from ECUTRR(IRL) to AE
" (calculated at the beginning of the simulation).  Thus,
" range-RANGE_ECUTRR(IRL) is the particle range to ECUTRR(IRL), and if
" DNEAR is >= this, we can discard the particle.
"
" No range rejection is done in vacuum, if IREJCT=0, or if the particle energy
" exceeds ESAVE.
"
REPLACE {$USER-RANGE-DISCARD;} WITH {
"        ===================="
;
IF( i_rr_global = 1 & ibrspl = 2 & iphat(np)<nbrspl & dnear(np) > range ) [
    $RANDOMSET rnno24;
    IF( rnno24*nbrspl > iphat(np) ) [ np=np-1; return; ]
    wt(np) = wt(np)*nbrspl/iphat(np); iphat(np)=nbrspl;
]
IF( IREJCT_GLOBAL > 0 & MEDIUM ~= 0 & E(NP) < ESAVE(IRL) & IREJCT(IRL)=1 &
    DNEAR(NP) >= range-RANGE_ECUTRR(IRL))[

    "Perform charged-particle range-rejection using ecutrr"
    "range-RANGE_ECUTRR is the range to ECUTRR"

     IF(LELEC =  -1)[ IDISC=1;"electron" ] ELSE [IDISC=99;"positron"]
     IAUSFL(6)=0;
     "We re-set the flag to 0 because"
    "if the flag is 1 for this particle and we discard it "
    "before it is scored, the next particle on stack may be scored"
    "instead if USTEP<DNEAR and the flag is not re-set to 0 in HOWFAR "
     GOTO :USER-ELECTRON-DISCARD:;

]"end of perform range-rejection block"
}

;
" HOWNEAR replacement macros for PRESTA.  User must provide replacement macro
" for CM_HOWNEAR_$CMNAME which returns TPERP, the distance to closest boundary.
" Used in $SET-TUSTEP.
REPLACE {$CALL-HOWNEAR(#);} WITH {
"       ================"
        ;ICM = IR_to_CM(IRL);
        ;$GOTO_CM_LIST(HOWNEAR) ICM;
        ;$CM_LIST$CM_HOWNEAR({P1});
        :HOWNEAR_DONE: CONTINUE;
}

;REPLACE {CMLIST(#)$CM_HOWNEAR(#);} WITH {
:HOWNEAR_{P1}:  {P1}_CM_HOWNEAR({P2});
}
;REPLACE {CMLIST(#,#)$CM_HOWNEAR(#);} WITH {
        ;CMLIST({P2})$CM_HOWNEAR({P3});
        GOTO :HOWNEAR_DONE:;
:HOWNEAR_{P1}:  {P1}_CM_HOWNEAR({P3});
}

" expand $SYNCCMS_SET_COMP to coding to set opening dimensions of all"
" SYNC type CMs in the accelerator"
" if there are no more SYNC CMs we encounter END_SYNC_CMS in the list"
" and, because there is only one parameter, it becomes a null (;) replacement"

REPLACE {$SYNCCMS_SET_COMP;} WITH {$SYNC_CM_LIST$SET_COMP;}

;REPLACE {SYNCCMLIST(#)$SET_COMP;} WITH {;}

;REPLACE {SYNCCMLIST(#,#)$SET_COMP;} WITH {
   {P1}_SET_COMP;
   SYNCCMLIST({P2})$SET_COMP;
}

"now expand $SYNCCMS_APPEND_USER to coding that will append the common"
"block for each SYNC type CM to USER"
"At the end of the list, we encounter a single parameter,END_SYNC_CMS, and the"
"replacement is null"

REPLACE {$SYNCCMS_APPEND_USER;} WITH {$SYNC_CM_LIST$APPEND_USER;}

;REPLACE {SYNCCMLIST(#)$APPEND_USER;} WITH {;}

;REPLACE {SYNCCMLIST(#,#)$APPEND_USER;} WITH {
    APPEND {;COMIN/USER-{P1}/;} TO {;COMIN/USER/;}
    SYNCCMLIST({P2})$APPEND_USER;
}

"same as above but for DYN type CMs"

REPLACE {$DYNCMS_SET_COMP;} WITH {$DYN_CM_LIST$SET_COMP;}

;REPLACE {DYNCMLIST(#)$SET_COMP;} WITH {;}

;REPLACE {DYNCMLIST(#,#)$SET_COMP;} WITH {
   {P1}_SET_COMP;
   DYNCMLIST({P2})$SET_COMP;
}

REPLACE {$DYNCMS_APPEND_USER;} WITH {$DYN_CM_LIST$APPEND_USER;}

;REPLACE {DYNCMLIST(#)$APPEND_USER;} WITH {;}

;REPLACE {DYNCMLIST(#,#)$APPEND_USER;} WITH {
    APPEND {;COMIN/USER-{P1}/;} TO {;COMIN/USER/;}
    DYNCMLIST({P2})$APPEND_USER;
}


" *********************************
" Revised LATCH and NPASS features:
" *********************************
"
" At NRCC the variable LATCH is added to the stack and then passed on
" to a particles descendants - so we can use it to track a particles
" history   - e.g. add 1 to LATCH each time there is a Compton event, then
"             the current value tells how often the photon has scattered
"             so far - etc.
" In the version used for BEAMnrc, NPASS is 2-dimensional array specifying
" the number of times that particle NP or its ancestors have crossed
" scoring plane ISCORE.  The variable NPASS, like LATCH, is passed on to
" a particles descendants.  NPASSI is required for the initial call to
" SHOWER.  Note: We need NPASSI in common since it is not a call parameter to
" SHOWER.
" above comments about LATCH is not implemented. The implemented LATCH
" number is obtained through the bit set. ( for more detail information
" about the LATCH in BEAMnrc see 'BEAMnrc technical notes.)

REPLACE {$TRANSFER PROPERTIES TO (#) FROM (#);} WITH {
   X({P1})=X({P2});Y({P1})=Y({P2});Z({P1})=Z({P2});IR({P1})=IR({P2});
   WT({P1})=WT({P2});DNEAR({P1})=DNEAR({P2});
   LATCH({P1})=LATCH({P2});
   ZLAST({P1})=ZLAST({P2});
   NFTIME({P1})=NFTIME({P2});
   DO ISCORE=1,$MAX_SC_PLANES[ NPASS({P1},ISCORE)=NPASS({P2},ISCORE); ]
   NSPLIT({P1})=NSPLIT({P2});
   IPHAT({P1})=IPHAT({P2});
}

REPLACE {$TRANSFER PROPERTIES TO # FROM I;} WITH {
"        ================================="
   X{P1}=XI;Y{P1}=YI;Z{P1}=ZI;IR{P1}=IRI;
   WT{P1}=WTI; DNEAR{P1}=DNEARI;LATCH({P1})=LATCHI;
   DO ISCORE=1,$MAX_SC_PLANES [NPASS({P1},ISCORE)=NPASSI;]
   NSPLIT({P1})=NSPLITI; IPHAT({P1})=IPHATI;
}
"Note ZLAST is not transfered at start"
;
%E    "beamnrc.mortran - start of bremsstrahlung splitting macro          "
" **********************************************************"

"IBRSPL = 0 => NO ADDITIONAL BREMSSTRAHLUNG PHOTONS (DEFAULT)       "
"       = 1 => PERFORM UNIFORM BREMSSTRAHLUNG SPLITTING             "
"       = 2 => PERFORM DIRECTIONAL BREMSSTRAHLUNG SPLITTING         "
"THIS MACRO IS INVOKED AFTER THE FIRST CALL THE SUBROUTINE BREMS    "
"                                                                   "
; "BUFFER FLUSH"

" ***************** replacing the default $AUSCALL macro ************** "
"    With the definition below, which differs from the default          "
"    replacement in egsnrc.macros only by the last line, one can        "
"    cancel or modify interactions in AUSGAB. For instance, if one      "
"    wants to use an alternative implementation of Rayleigh scattering, "
"    one sets iausfl(20)=1, does own Rayleigh in ausgab when iarg=19    "
"    call occurs, puts an extra particle with weight 0 on the stack and "
"    returns. For the DBS stuff, the most elegant way of doing things   "
"    (at least for my taste) is to call ausgab just before a given      "
"    interaction occures, perform the interaction within ausgab the     "
"    desired number of times (0, 1, or nbrspl), and then skip the       "
"    call to the interaction routine by having a weight zero particle   "
"    on top of the stack.                                               "

REPLACE {$AUSCALL(#);} WITH {
    iarg = {P1};
    IF( iausfl(iarg+1) ~= 0 ) [
        call ausgab(iarg);
        IF( wt(np) <= 0 ) [ np = np-1; return; ]
    ]
};

/******************************************************************************

   The following macro implements photon cross section
   enhancement (CSE). CSE may be usefull for improving the statistics
   of electron contamination in photon beams and should be applied in
   the last air slab before the phantom.

   IK, Jan 29 2005.

 *****************************************************************************/

REPLACE {$RAYLEIGH-CORRECTION;} WITH {;

    IF(IRAYLR(IRL) = 1) [
        $EVALUATE COHFAC USING COHE(GLE); GMFP=GMFP*COHFAC;
    ]
    IF( use_cs_enhance ) [
        iarg = IR_to_CM(IR(NP));
        IF( cs_enhance(iarg) > 1 ) [ gmfp = gmfp/cs_enhance(iarg); ]
    ]

};


;

REPLACE{$FORCING-REMINDER} WITH {;
OUTPUT IRNEW,IRNEW,PCUT(IRNEW),E(NP),IRODUM,IR(NP);(/
            /' *** NO photon interaction forcing in region',I4/
             '     for particles of energies < PCUT(',I4,') =',
            F8.3,'MeV'/
             '     which differs from the pcut values elsewhere.'//
             '     This photon (E=',F8.3,'MeV) is forced to interact in'/
             '     regions',I4,' TO',I4,'.'//);
WRITE(IOUTLIST,
'(//'' *** NO photon interaction forcing in region'',I4/
''     for particles of energies < PCUT('',I4,'') ='',F8.3,''MeV''/
''     which differs from the pcut values elsewhere.''//
''     This photon (E='',F8.3,''MeV) is forced to interact in''/
''     regions'',I4,'' TO '',I4//)') IRNEW,IRNEW,PCUT(IRNEW),
             E(NP),IRODUM,IR(NP);
}

%E    "beamnrc.mortran - start photon forcing interaction scheme          "
"New photon interaction forcing scheme"

REPLACE {$SELECT-PHOTON-MFP;} WITH {
; CALL SELECT_PHOTON_MFP(DPMFP);
}

REPLACE {$SELECT-PHOTON-MFP-FOR-FORCING(#);} WITH
"         =================="
{;"We enter this macro if a photon is entering a new CM AND it should"
"be forced.  It is called either from SELECT_PHOTON_MFP or directly"
"from AUSGAB when a photon gets to the boundary of the forcing regions."
"Conditions to determine whether or not it should be forced"
"are:"
"1. the CM is NFCMIN and W(NP)>0 or the CM is NFCMAX and W(NP)<0"
"   In other words, the CM is one that we want to do forcing in"
"2. 1 <= NFTIME(NP) <= NFMAX--in other words, the number of times"
"   the photon will have interacted in the relevant CMs"
"   falls in the range of interaction numbers that we"
"   want to force."
"See the macro $SELECT-PHOTON-MFP for a detailed description of"
"most of the variables relevant to photon forcing"

"An additional variable used in this macro is MFORCF:"
"   MFORCF is a flag set to 0 at the beginning of the simulation.  However,"
"   if one region in which forcing is in effect has a PCUT higher than the"
"   rest of the forcing regions AND the energy of the photon before"
"   forcing is < PCUT in this region, a message is printed to the"
"   effect that photons with energy < this higher PCUT will only be"
"   forced up to the region with the higher PCUT.  Then MFORCF is set to 1"
"   to prevent repeated printouts of this warning."

"On exit from this macro, we have created two photons, one which is forced"
"to interact and occupies stack position NP-1 and a fictitious photon which"
"steps right through the forcing regions without interacting, in stack"
"position NP.  This macro does not actually transport either photon and"
"leaves both of them at the X,Y,Z position that the original, single photon"
"occupied before forcing.  However, the macro does calculate a"
"{P1} for the fictitious (non-interacting) photon based on the total"
"distance through the forcing regions with no interactions and then"
"a randomly selected distance past that (in which interactions may occur)."
"After dealing with the fictitious photon, the forced"
"photon is transported.  The forced photon is identified by having "
"NP_INC(NP)=1 (set in this macro) and is dealt with in the"
"$SELECT-PHOTON-MFP macro, where"
"a value of {P1} is calculated based on the distance to the first"
"interaction."

"force this photon to interact in the specified CMs"

NP_INC(NP)=1;    "flag, we are doing photon interaction forcing now"

NP=NP+1;
"set up 2 photons: top of stack will be non-interacting, fictitious photon"
"NP-1 will be photon that is forced"

;$TRANSFER PROPERTIES TO (NP) FROM (NP-1);
U(NP)=U(NP-1);V(NP)=V(NP-1);W(NP)=W(NP-1);E(NP)=E(NP-1);IQ(NP)=IQ(NP-1);
DUMU=USTEP;IRODUM=IROLD;IRNDUM=IRNEW;ICMNEWDUM=ICMNEW;ICMOLDDUM=ICM;
MEDDUM=MEDIUM;IDUM=IDISC;PATHL=0.0;MEDTMP=0;
IF(IWATCH = 1 | IWATCH =2)[
   OUTPUT NP;(' Ficticious photon put on stack with NP =',I4);
]

"In the following loop, we calculate PATHL: the total number of photon"
"mean free paths required to pass right through the CMs where forcing"
"is on without interacting."
LOOP[
    USTEP=VACDST;IROLD=IR(NP);MEDIUM=MED(IROLD);
    IF(MEDIUM=0)["vacuum"
        DELTAP=0.;
    ]
    ELSE[
        IF(MEDTMP ~= MEDIUM)[
          MEDTMP=MEDIUM;
          $SET INTERVAL GLE,GE;
          $EVALUATE DELTAP USING GMFP(GLE);
        ]
        IF(IRAYLR(IROLD) =  1)[ $EVALUATE COHFAC USING COHE(GLE); ]
        ELSE[ COHFAC=1.0;]
    ]

    CALL HOWFAR;

    IF(DELTAP~=0) PATHL=PATHL+USTEP/(DELTAP*COHFAC);
    "only add to PATHL if this was not vacuum"

    IF( (IR_to_CM(IRNEW)<NFCMIN) | (IR_to_CM(IRNEW)>NFCMAX)
            | (IRNEW=1) ) EXIT;
    IF(E(NP)<PCUT(IRNEW))[
        IF(MFORCF=0)[ MFORCF=1;$FORCING-REMINDER;]
        EXIT;"get out from here because during transport the particle"
              "will be terminated in the next region. Thus we stop"
              "calculating effective thickness from here  "
    ]
    IR(NP)=IRNEW;
    X(NP)=X(NP)+USTEP*U(NP);
    Y(NP)=Y(NP)+USTEP*V(NP);
    Z(NP)=Z(NP)+USTEP*W(NP);
]

;$TRANSFER PROPERTIES TO (NP) FROM (NP-1);
"recover the position, etc. of the fictitious photon"
U(NP)=U(NP-1);V(NP)=V(NP-1);W(NP)=W(NP-1);E(NP)=E(NP-1);
USTEP=DUMU;IROLD=IRODUM;IRNEW=IRNDUM;ICMNEW=ICMNEWDUM;ICM=ICMOLDDUM;
MEDIUM=MEDDUM;IDISC=IDUM;

"we now calculate the weighting factor for the photon that will be"
"forced to interact in the required CMs (see eq 17 in RB90 review)"
IF(PATHL <= 1.0E-3)[GWAIT(NP-1)=PATHL*(1.-0.5*PATHL);]"for numerical accuracy"
ELSE[GWAIT(NP-1)=1.-EXP(-PATHL);]
GWTOLD=WT(NP-1);"save GWTOLD for below"
WT(NP-1)=GWTOLD*GWAIT(NP-1);"weight of forced photon"
"in fact, if PATHL = 0 there should be no photon interactions and  "
"therefore we should only have one photon rather than two. It is OK"
"now because WT(NP-1)=0 if this happens. See earlier comments.     "

"we now calculate the weighting factor for the photon which will   "
"carry the remaining weight and not interact again in relevant CMs "
GWAIT(NP)=1.-GWAIT(NP-1);
WT(NP)=GWTOLD*GWAIT(NP);
EPSLON=RNNO35*GWAIT(NP);
"This photon can only interact outside the"
"specified CMs for photon interaction forcing   "
"Now calculate {P1}, the number of mean free paths that the fictitious"
"photon goes before interaction.  It cannot interact in the first PATHL."
"The coding corresponds to {P1}=PATHL(in forcing region)-LOG(RNN035)"
"(ie it allows transport through the forcing CMs without interaction"
"and then interacts naturally past them)."
IF( (1.-GWAIT(NP)+EPSLON) <= 1.0E-3)[
    {P1}=(1.-GWAIT(NP)+EPSLON)*(1.+0.5*(1.-GWAIT(NP)+EPSLON));
]
ELSE[
    IF(GWAIT(NP)=EPSLON)[{P1}=1.0E30;]
    ELSE[{P1}=-LOG(GWAIT(NP)-EPSLON);]
]
"Note that this macro is somewhat inefficient since we will eventually"
"duplicate the transport done above in the loop.  We could someday recode."
}

REPLACE {$SCORE(#,#:#)} WITH {;

"Scoring macro:"
"{P1}{P2}=scoring array (eg SCDOSE(ID,ITDOSE))"
"{P3}=quantity to be scored (eg FTMP)"

"If the (primary) history number, NHSTRY_LAST, is the same as the history"
"that last scored in this array, {P1}_LAST{P2}, then {P3} is added"
"to a temporary array, {P1}_TMP{P2}.  Otherwise, we add"
"{P1}_TMP{P2} to {P1}{P2}, {P1}_TMP{P2}*{P1}_TMP{P2} to {P1}2{P2},"
"set {P1}_TMP{P2}={P3}, and set {P1}_LAST{P2}=NHSTRY."
"This scoring method allows us to calculate  uncorrelated value"
"of {P1}2{P2} which is then used to calculate the uncertainty"
"in {P1}{P2}.  This macro is only used for scoring energy deposited"
"(for dose calculations) and no. of steps."

IF(NHSTRY_LAST={P1}_LAST{P2})[
  {P1}_TMP{P2}={P1}_TMP{P2} + {P3};
]
ELSE[
  {P1}{P2}={P1}{P2}+{P1}_TMP{P2};
  {P1}2{P2}={P1}2{P2} + {P1}_TMP{P2}*{P1}_TMP{P2};
  {P1}_TMP{P2}={P3};
  {P1}_LAST{P2}=NHSTRY_LAST;
]
;
}

REPLACE {$ANALYZE(#,#:#)} WITH {;

"Macro to analyze uncertainty:"
"{P1}{P2}=scoring array (eg SCDOSE,(ID,ITDOSE))"
"{P3}=quantity to normalize by (eg incident no. of particles)"

"We add any portion of {P1}_TMP{P2} that remains unscored at"
"the end of the run to {P1}{P2} and {P1}2{P2} if we have not created a"
".egsdat file and then calculate the uncertainty on {P1}{P2}/{P3}.  The "
"uncertainty is stored in {P1}2{P2} and is expressed as a percentage of"
"{P1}{P2}/{P3} (max 99.9%).  Note that you must define the REAL*8 variable"
"SCORE_TEMP in any subroutine where this macro is used.  This macro"
"is only used in the analysis of dose and no. of steps."

IF(IDAT=1)[
  {P1}{P2}= {P1}{P2}+{P1}_TMP{P2};
  {P1}2{P2}= {P1}2{P2} +{P1}_TMP{P2}*{P1}_TMP{P2};
]

SCORE_TEMP={P1}{P2}/{P3};
{P1}2{P2}={P1}2{P2}/{P3};
{P1}2{P2}=({P1}2{P2}-SCORE_TEMP*SCORE_TEMP)/({P3}-1);
IF({P1}2{P2}>=0.) {P1}2{P2}= SQRT({P1}2{P2});
IF(SCORE_TEMP~=0.)[
    {P1}2{P2}= MIN({P1}2{P2}/SCORE_TEMP*100.D0,99.9D00);
]
ELSE[
    {P1}2{P2}=99.9D00;
]
;
}

"*******************************************************************************
;
"                        GENERAL-USE MACROS FOR BEAMnrc PROPER         ""toc:
"                        *************************************
;
" *********
" Data I/O:
" *********
"
" General input statement that exits correctly when end-of-file is reached

REPLACE {;MINPUT (#) #;} WITH {
;@LG@LS1READ(i_input,@LC10,END=:EOF_{P1}:,ERR=:ERROR_{P1}:){P2};@LC10FORMAT@LU1}

" ************
" Data typing:
" ************
"
" Data type definition for global change of precision
"
"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"
" How often do I need to change this ???????????????????????????????????????
" It is defined in machine.macros (or in beamnrc_user_macros.mortran, if   "
" the user wants to overwrite), not here!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"REPLACE {$REAL} WITH {REAL*4 }

"REPLACE {$INTEGER} WITH {INTEGER*4}

"REPLACE {$LONG_INT} WITH {INTEGER*8}

" $LONG_INT=INTEGER*8 is used to define a few variables, such as
" IHSTRY and NCASE in order to allow > 2.15x10^9 histories to be run
" This is particularly useful for parallel runs, where it is relatively
" easy to have a high total number of histories.
" However, this is non-standard Fortran on many systems.  We have compiled
" successfully on PC Linux, SGI, DEC Alpha and Sun Sparc systems.
" On rs6000 systems, the compiler may give warnings saying length specified
" is not valid for the specified type and revert to INTEGER*4, but compilation
" will be successful.  On HP9000 systems, the compilation may fail with error
" messages saying incompatible type-length combination.
" If compilation fails, replace $LONG_INT with INTEGER*4 in the macro above.
 "       ====="

"REPLACE {$SHORT_INT} WITH {INTEGER*2}

"This is used for variables which store the last primary history no. that
"scored a quantity of interest.  If your compiler has trouble with this
"change it to INTEGER*4.

" ****************
" Colour graphics:
" ****************
" Macro for selecting ICOLOUR = 1, 2, or 3, colour of CM viewed with EGS_Windows
"
REPLACE {;$SELECT-COLOUR;} WITH {;ICOLOUR = MOD(ICM,4)+1;}
"       ================"
"
"*******************************************************************************
;
"                   GENERAL-USE MACROS FOR COMPONENT MODULES           ""toc:
"                   ****************************************
;
" **************************************************************
" Expansion macros for list-oriented GOTO for component modules:
" **************************************************************
"
REPLACE {;$GOTO_CM_LIST(#)} WITH {;GOTO ({REDUCE GOTO_CM_LIST/{P1}/$CM_LIST })}
"       ================="

REPLACE {GOTO_CM_LIST/#/CMLIST(#)}
WITH { :{P1}_{P2}: }
;
REPLACE {GOTO_CM_LIST/#/CMLIST(#,#)} WITH {
    :{P1}_{P2}:,GOTO_CM_LIST/{P1}/CMLIST({P3}) }

"  The following is used to expand ;CALL_INPUT; into a series of calls to
"  the input routines for each CM contained in $CM_LIST defined above
"
REPLACE {$INFORMAT} WITH {OLD};
;
REPLACE {;CALL INPUT_OLD_CMLIST(#);} WITH {
          ;CALL INPUT_{P1};
          OUTPUT;('  Input blank line to signify end of component module');
          read(i_input,*);
          }
REPLACE {;CALL INPUT_OLD_CMLIST(#,#);} WITH {
"       ================"
          ;CALL INPUT_{P1};
          ICM=ICM+1;
          ;IF (ICM > $MAX_CMs) GOTO :ERR_ICM_GT_MAX_CMs:;
          OUTPUT; (/1x,79('=')/
                '  Input blank line to signify start of component module');
          read(i_input,*); "skip an input line"
          OUTPUT ICM; (1x,79('=')/' Outer boundary of CM',I3,': ',$);
          ;MINPUT (MAIN) RMAX_CM(ICM);(F10.0);
          IF(RMAX_CM(ICM) = 0.0)RMAX_CM(ICM) = 100.;
          OUTPUT RMAX_CM(ICM);(F10.5);
          RMAX_CM2(ICM) = RMAX_CM(ICM)**2;
          ;CALL INPUT_OLD_CMLIST({P2});
          }
;
REPLACE {;CALL INPUT_NEW_CMLIST(#);} WITH {
          ;CALL INPUT_NEW_{P1};
          OUTPUT;('  Input blank line to signify end of component module');
          ;read(i_input,*);
          }
REPLACE {;CALL INPUT_NEW_CMLIST(#,#);} WITH {
"       ================"
          ;CALL INPUT_NEW_{P1};
          ICM=ICM+1;
          ;IF (ICM > $MAX_CMs) GOTO :ERR_ICM_GT_MAX_CMs:;
          " Input boundary of component module.  HOWFAR terminates particle "
          " histories that reach RMAX_CM(ICM)"
          OUTPUT; (/1x,79('=')/
                '  Input blank line to signify start of component module');
          ;read(i_input,*);
          OUTPUT ICM; (1x,79('=')/' Outer boundary of CM',I3,': ',$);
          ;MINPUT (MAIN) RMAX_CM(ICM);(F10.0);
          IF(RMAX_CM(ICM) = 0.0)RMAX_CM(ICM) = 100.;
          OUTPUT RMAX_CM(ICM);(F10.5);
          RMAX_CM2(ICM) = RMAX_CM(ICM)**2;
          ;CALL INPUT_NEW_CMLIST({P2});
          }
;
REPLACE {;CALL_INPUT;} WITH {
          ;IF (ICM > $MAX_CMs) GOTO :ERR_ICM_GT_MAX_CMs:;
          " Input radius of component module.  HOWFAR terminates particle "
          " histories that reach RMAX_CM(ICM)"
          OUTPUT;(/1x,79('=')/
           '  Input blank line to signify start of component module');
          ;read(i_input,*);
          :CMLAB1: FORMAT(' **************start of CM ',A8,2X,A8,
          '  *************');
          OUTPUT ICM; (/1x,79('=')/' Outer boundary of CM',I3,': ',$);
          ;MINPUT (MAIN) RMAX_CM(ICM);(F10.0);
          IF(RMAX_CM(ICM) = 0.0)RMAX_CM(ICM) = 100.;
          OUTPUT RMAX_CM(ICM);(F10.5);
          :CMLAB2:FORMAT(F10.5,',',T50,'Outer boundary') ;
          RMAX_CM2(ICM) = RMAX_CM(ICM)**2;
          {REDUCE ;CALL INPUT_$INFORMAT_$CM_LIST;}
                        "Set of calls to INPUT_$CMNAME"
          GOTO :SKIP_ERR_ICM_GT_MAX_CMs:;
          :ERR_ICM_GT_MAX_CMs: OUTPUT $MAX_CMs;
              (//' ******Number of component modules requested',
              ' is greater than the',I3,' available *******');
              $CALL_EXIT(1);
          :SKIP_ERR_ICM_GT_MAX_CMs: CONTINUE;}

;
" Macro to determine region number in adjacent CM when crossing CM boundary:
" {P1} is the current component module IICM (before crossing the boundary),
" {P2} is the direction, +1 for forward and -1 for backward.  Used in
" conjunction with $GOTO_CM_LIST.
"
REPLACE {;$WHERE_AM_I;} WITH {
"       ============="
   {REDUCE ;CALL WHAMI_$CM_LIST;}
   :WHAMI_DONE: CONTINUE;
   }
;REPLACE {;CALL WHAMI_CMLIST(#);} WITH {
; :WHAMI_{P1}:  ;CALL WHERE_AM_I_{P1}(IDIR);
   GOTO :WHAMI_DONE:;
   }
;
REPLACE {;CALL WHAMI_CMLIST(#,#);} WITH {
   ;CALL WHAMI_CMLIST({P2});
   :WHAMI_{P1}:  ;CALL WHERE_AM_I_{P1}(IDIR); GOTO :WHAMI_DONE:;
   }
;
" MACRO's to expand the call into a series of labelled
" calls to the individual CM's ISUMRY. The last CM ends up being the statement
" immediately after the original statement.
"
REPLACE {;$CALL_ISUMRY;} WITH { {REDUCE ;CALL ISUMRY__$CM_LIST;} }
"       =============="
;
REPLACE {;CALL ISUMRY__CMLIST(#);} WITH {CALL ISUMRY_{P1};}
;
REPLACE {;CALL ISUMRY__CMLIST(#,#);} WITH {
   ;CALL ISUMRY_{P1};
   ;CALL ISUMRY__CMLIST({P2});
   }
;
" ******************
" Media input macro:
" ******************
;
" Media input and sort to avoid repetition in /MEDIA/.  Checks whether last
" medium in character array MEDIA is repeated.  If not, NMED, the number of
" different media in the simulation, is incremented by 1 and MED_INDEX is set
" to NMED.  If so, MED_INDEX is set to the index of the matching medium in
" MEDIA.  NMED and MEDIA are in /MEDIA/, and MED_IN, the character array for the
" current medium, is in /CMs/.  Medium 0 is vacuum, medium 1 is ``AIR'',
" additional media start at medium 2.  Vacuum is chosen in input parameter
" file with VACUUM.  There is no default.
"
REPLACE {;$MED_INPUT(#);} WITH {
    ;OUTPUT ; (' MEDIUM (left justify): ',$);
    READ(i_input,'(24A1)',END=:EOF_{P1}:,ERR=:ERROR_{P1}:) (MED_IN(J),J=1,24);
    OUTPUT (MED_IN(J),J=1,24); (' ',24A1);
    IF(MED_IN(1) = 'V' & MED_IN(2)='A' & MED_IN(3)='C' &
       MED_IN(4) = 'U' & MED_IN(5)='U' & MED_IN(6)='M') [
       MED_INDEX=0; "Medium is vacuum"
    ]
    ELSE ["Medium is not vacuum"
       IF(NMED ~= 0)["if nominal air is vacuum, nmed might be zero"
          DO I = 1,NMED[
             MED_FLAG = 0;
             DO J = 1,24[
                IF(MEDIA(J,I) ~= MED_IN(J))[MED_FLAG = 1;EXIT;]
             ]
             IF(MED_FLAG =  0)[MED_INDEX = I;EXIT;]
             IF(I =  NMED)[
                NMED = NMED+1;
                MED_INDEX = NMED;
                DO J = 1,24[MEDIA(J,NMED) = MED_IN(J);]
                EXIT;
             ]
          ] "end of loop over I"
       ]"end NMED ~=0 block"
       ELSE ["NMED = 0 CASE"
          NMED = 1;
          MED_INDEX = NMED;
          DO J = 1,24[MEDIA(J,NMED) = MED_IN(J);]
       ]
    ]
}
;
"*******************************************************************************
;
"                             COMMON BLOCK MACROS                      ""toc:
"                             *******************
;
"V>******************************************
"V>Common block macros for component modules:
"V>******************************************
"V>
"V>COMMON/CMs/  Geometrical and range rejection information of interest to
"V>===========  all component modules:
"V>
"V>E_min_out(ICM) = minimum energy of electron leaving a CM ICM which can reach
"V>     the nearest downstream scoring region with energy greater than ECUT in
"V>     the scoring region. For use in range rejection.  Set in MAIN because
"V>     needs info from all CMs past the current one.
"V>MAX_CMs = number of CMs.
"V>MED_IN = 24-character name of last medium input in INPUT_$CMNAME.
"V>ICM = CM index, incremented before call to INPUT_$CMNAME, set in SRCHST and
"V>     HOWFAR during particle transport.
"V>ICMNEW = Next CM, set in WHERE_AM_I, different than ICM (only?) if particle
"V>     transported to CM boundary.
"V>ICM_to_SCORE(ICM) = scoring plane associated with ICM, 0 => none.  Set in
"V>     main based on IPLANE_to_CM(I) which is read in.
"V>IERR_GEOM(ICM) = geometry-checking flag for each CM, 0 if no errors detected,
"V>     1-99 specifies number of errors detected within CM, >100 specifies that
"V>     CM above overlaps
"V>IR_start_CM(ICM) = region number of first region in CM, set by previous CM,
"V>     read in subroutine INPUT_$CMNAME.
"V>IR_to_CM(IR) = pointer used in HOWFAR which says which CM a region IR is in.
"V>     Set in step 4 in MAIN.
"V>RMAX_CM(ICM) = outer boundary of treatment head, particles discarded if they
"V>     move outside of this boundary.  Read in step 2 in MAIN.
"V>RMAX_CM2(ICM) = square of outer boundary.
"V>RMAX_CM_FLAG(ICM) = flag for boundary of CM:  set in INPUT_$CMNAME.
"V>     0--bounds of CM are all set in  HOWFAR_$CMNAME,
"V>     1--CM is bounded by cylinder of radius RMAX_CM(ICM),
"V>     2--CM is bounded by square box at RMAX_CM(ICM) and  -RMAX_CM(ICM).
"V>Z_min_CM(ICM) = min Z value for each CM, set by previous CM in INPUT_$CMNAME
"V>     (back of previous CM) following the convention that the downstream
"V>     surface of source or accelerator exit window is at Z = 0.0.  Last value
"V>     (with ICM=MAX_CMs+1) is maximum Z of model.
"V>Z_gap_THICK(ICM) = thickness of air gap at front of CM to fill in space
"V>     between Z_min_CM and front of CM, set in INPUT_$CMNAME.
"V>Z_min_thick(ICM,j) minimum thickness in cm of up to j = 5 regions in
"V>     ICM for an electron going through ICM. It is used for range
"V>     rejection. It is set in each CMs input routine. j=1 is closest
"V>     to the bottom plane. Often only one = total thickness (air).
"V>MED_min_thick(ICM,j)  medium values corresponding to min thicknesses.
"V>ITDOSE_ON    if dose components to be scored, this flag is 1, otherwise 0
"V>ICM_CONTAM   If ITDOSE_ON is 1, and ICM_CONTAM is >= 1
"V>             then dose is broken into 2 components based on the charge
"V>             entering front of ICM ICM_CONTAM.
"V>IQ_CONTAM    type of the particles considered to be the contaminant
"V>             on entering ICM = ICM_CONTAM (identified via bit 30 in LATCH).
"V>XTUBE_EXISTS flag is 0 unless first CM in accelerator is XTUBE, in
"V>             which case it is 1.  It is set in XTUBE_INPUTS.
"V>ANGLE        = angle between X-ray target surface and z-axis
"V>CMTYPE(ICM)  8 character ordered array with names of CM types (SLABS etc)
"V>CMLIST(ICM)  8 character ordered array with identifiers for CMs
"V>AIR_INDEX    index for the ``air'' region =1 unless 0 for vacuum
"V>IDIRG        stores value of IDIR for use in AUSGAB to determine if a
"V>             particle is turned back before exiting a CM

REPLACE {;COMIN/CMs/;} WITH {
;COMMON/CMs/
   Z_min_CM,Z_gap_THICK,E_min_out,RMAX_CM,RMAX_CM2,Z_min_thick,ANGLE,
   BEAM_MU_INDEX,BEAM_MU_INDEX_OLD,
   ICM,ICMNEW,ICM_to_SCORE,IERR_GEOM,
   IR_start_CM,MAX_CMs,IR_to_CM,RMAX_CM_FLAG,
   MED_min_thick,
   ITDOSE_ON,ICM_CONTAM, IQ_CONTAM,XTUBE_EXISTS,AIR_INDEX,IDIRG,
   MED_IN, CMTYPE, CMLIST;
$REAL Z_min_CM($MAX_CMsP1),$LGN(Z_gap_THICK,
   E_min_out,RMAX_CM,RMAX_CM2($MAX_CMs)),Z_min_thick($MAX_CMs,5),ANGLE,
   BEAM_MU_INDEX,BEAM_MU_INDEX_OLD;
INTEGER ICM,ICMNEW,ICM_to_SCORE($MAX_CMs),IERR_GEOM($MAX_CMs),
   IR_start_CM($MAX_CMsP1),MAX_CMs,IR_to_CM($MXREG),RMAX_CM_FLAG($MAX_CMs),
   MED_min_thick($MAX_CMs,5),
   ITDOSE_ON,ICM_CONTAM, IQ_CONTAM,XTUBE_EXISTS,AIR_INDEX,IDIRG;
CHARACTER*4 MED_IN(24);
CHARACTER*8 CMTYPE($MAX_CMs), CMLIST($MAX_CMs);
}   "end of definition of /CMs/

"
" set of macros to generate lists of CM NAMEs and IDENTIFIERS
" ************************************
REPLACE {$CHAR_DATA} WITH {
   {SETR C=0} {SETR D=0}
   {REDUCE $CHAR_$CM_LIST; $CHAR_$CM_TYPE;}
}
;REPLACE {$CHAR_CMLIST(#)} WITH {
   {INCR C}
   CMLIST({COPY C}) = '{P1}';
}
REPLACE {$CHAR_CMLIST(#,#)} WITH {
   {INCR C}
   CMLIST({COPY C}) = '{P1}';
   $CHAR_CMLIST({P2});
}
;
REPLACE {$CHAR_CMTYPE(#)} WITH {
   {INCR D}
   CMTYPE({COPY D}) = '{P1}';
}
REPLACE {$CHAR_CMTYPE(#,#)} WITH {
   {INCR D}
   CMTYPE({COPY D}) = '{P1}';
   $CHAR_CMTYPE({P2});
}
;
"  COMIN/CM_LIST/  To include all component module commons
"  ==============
"
REPLACE {COMIN/CM_LIST/;} WITH { {REDUCE ;COMIN_CM_LIST/$CM_LIST/;} }

;REPLACE {;COMIN_CM_LIST/CMLIST(#)/;} WITH { ;COMIN/CM_{P1}/;}
;REPLACE {;COMIN_CM_LIST/CMLIST(#,#)/;} WITH {
   ;COMIN/CM_{P1}/;
   ;COMIN_CM_LIST/CMLIST({P2})/;
}

" **************************
" Other common block macros:
" **************************
"
"------------------------------------------------------------------"
"V>COMMON/GEOM/  Geometrical information:
"V>============
"V>
"V>NREG = number of regions.
"V>
REPLACE {;COMIN/GEOM/;} WITH {
;COMMON/GEOM/ NREG;
INTEGER NREG; }
;
"V>COMMON/IO_INFO/  Input and output information and unit numbers:
"V>===============
"V>
"V>Variables passed in common:
"V>TITLE = 80 character max, input by user for descriptive purposes
"V>
"V>Unit numbers passed in common:
"V>IOUTLIST = listing
"V>IOUTPLOT = plot file
"V>IORSTRT  = restart file, mainly containing scoring arrays (input)
"V>IOUTGPH  = EGS_Windows file for graphical display of particle history
"V>           note this is hardwired as 13 in the WATCH subroutine
"V>IOUTGEOM = EGS_Windows geometry file
"V>IOUTRN   = storage of initial random number for each history
"V>IINSRC   = unit number for input of phase-space source (input)
"V>IOUTFLU(I) particle phase-space output for scoring plane I
"V>DNTIME   = variable needed in date routine on suns
"V>DATEN,TIMEN = machine variables for time and date
"V>IXXIN,JXXIN = input random number seeds
"V>DATCOUNT = no. of .egsdat files added for recombining parallel job
"V>

REPLACE {;COMIN/IO_INFO/;} WITH {
;COMMON/IO_INFO/TITLE,IORSTRT,IINSRC,IOUTLIST,IOUTPLOT,
   IOUTGPH,IOUTGEOM,IOUTRN,IOUTFLU,IXXIN,JXXIN,DATCOUNT,
   DNTIME,TIMEN,DATEN;
CHARACTER*80 TITLE;
CHARACTER TIMEN*8,DATEN*11,DNTIME*24;
INTEGER IOUTLIST,IOUTPLOT,IORSTRT,IOUTGPH,IOUTGEOM,IOUTRN,
   IINSRC,IOUTFLU($MAX_SC_PLANES),IXXIN,JXXIN,DATCOUNT;
}   "end of definition of /IO_INFO/

;
"V>COMMON/SCORE/  Common used for scoring in AUSGAB:
"V>==============
"V>
"V>MXNP =   Maximum level to which the stack of daughter particles from an
"V>         incident particle rises (stack may include incident particle).
"V>ISTORE = 0 store the initial RNs for the 1st history of a batch(the default)
"V>       = 1 store the initial random numbers before the current history starts
"V>       =-1 start the 1st history with the RN seeds previously stored.
"V>IWATCH = 0 for normal output (the default)
"V>       = 1 output on every discrete interaction
"V>       = 2 output on every electron/photon step as well
"V>       = 4 prints out file for graphics.
"V>       = -N set to 2 for history N, set to 0 for all other histories
"V>IHSTRY = counter for total number of histories successfully simulated.
"V>NHSTRY = counter for number of primary (non-phsp source) histories
"V>         that score particles in a phsp source
"V>NHSTRY_LAST = INTEGER*2 version of NHSTRY -- resets at 32700 -- allows
"V>              us to get away with INTEGER*2 versions of SCFLU_LAST,
"V>              SCDOSE_LAST and SCSTP_LAST arrays
"V>INPHSP = counter for the particle number being read from the ph-sp file
"V>NPPHSP(3)= counters for total number of particles in phase space files
"V>NPFLU(3)= counters for total number of particles crossing scoring planes
"V>IO_OPT = 0 normal output
"V>       = 1 no phase-space output when particles cross scoring planes.
"V>       = 2 no ph-sp output,  do data analysis for source models
"V>       = 3 ph-sp output for up to 100 K particle histories and then only
"V>           do data analysis for source models
"V>       = 4 same as 0 but phase space files output in IAEA format
"V>IOUTSP = 0 no energy input spectrum data in output summary
"V>       = 1 include energy input spectrum data in output summary.
"V>TMCPUO = CPU time used in previous sessions.
"V>TIMMAX = maximum allowed CPU hours for a given calculation.
"V>EIN = kinetic energy of the external beam.
"V>IDAT = 0 store data arrays for re-use
"V>     = 1 don't store them.
"V>NCASE = number of histories remaining to be done.
"V>NCASEO = number of histories done in previous sessions.
"V>NHSTRYO = number of histories from primary (non-phsp) sources simulated
"V>          in previous runs (ISOURC=21 only)
"V>NCASET = number of histories already done.
"V>JCASE  = no. of histories in each batch
"V>IRESTART = 0 => initial run
"V>         = 1 => restarted run
"V>         = 2 => creation of input file only
"V>         = 3 => data analysis only
"V>is_finished = .true. on finishing the last job in a parallel run
"V>IQIN = charge of the external beam.
"V>SCSTP = scores total number of charged particle steps
"V>SCSTP2 = holds sum of squares of number of charged particle steps.
"V>         After analysis, holds fractional uncertainty in SCSTP
"V>SCSTP_TMP = scores total number of charged particle steps in 1 primary
"V>            history
"V>SCSTP_LAST = last primary history to contribute to SCSTP_TMP
"V>PIISTP = no. of PRESTA-II steps read from .egsdat files
"V>DOSE_STAT = 0 if primary history or can get no. of primary histories from
"V>            phsp source = 1 otherwise
"V>
"V>Dose scoring variables:
"V>AMASS(ID) = mass of scoring zone ID.
"V>SCDSTP/SCDSTP2/SCDSTP_TMP/SCDSTP_LAST = SCSTP, SCSTP2, SCSTP_TMP, SCSTP_LAST
"V>                                        for dose region
"V>ID = index of dose scoring zone.
"V>DOSE_ZONE(IR) = dose zone, 0 if IR not a dose scoring region.
"V>NDOSE_ZONE = number of dose scoring zones.
"V>SCDOSE(ID,IT) = array for scoring energy deposited in dose zone ID for
"V>                dose component IT.  Eventually holds normalized dose
"V>SCDOSE2(ID,IT) = array for storing sum of squares of energy deposited in
"V>                 zone ID for dose component IT.  After analysis, holds
"V>                 fractional uncertainty in dose.
"V>SCDOSE_TMP(ID,IT) = array stores energy deposited in zone ID for dose
"V>                    component IT over one primary history.
"V>SCDOSE_LAST(ID,IT) = last primary history to contribute energy to
"V>                     SCDOSE_TMP(ID,IT)
"V>
"V>Fluence scoring variables:
"V>ISCORE = index of scoring plane.
"V>ISZ = index of radial scoring zone on scoring plane.
"V>IPLANE_to_CM(ISCORE) = CM immediately upstream of scoring plane.
"V>NSC_PLANES = number of planes for fluence scoring and phase space data.
"V>NSC_ZONES(ISCORE)  = number of zones in scoring planes for fluence scoring.
"V>MZONE_TYPE(ISCORE) = type of scoring zones for fluence scoring:
"V>                     0-annular, 1-square.
"V>RSCORE_ZONE(ISCORE,ISZ) outer dimension(radius or half-side)for scoring zones
"V>RSCORE_ZONE2(ISCORE,ISZ) = square of outer radius of scoring zone .
"V>SCFLU(IQ+2,ISCORE,ISZ,IP) = array for scoring particle number, energy, and
"V>     angle wrt z-axis.  The scoring parameter index IP is defined as follows:
"V>         1 to 4 - 1st crossing of scoring plane:
"V>           1-number, 2-fluence, 3-energy, 4-angle wrt z-axis
"V>         5 to 8 - particle or ancestors crossed scoring plane at least once:
"V>           5-number, 6-fluence, 7-energy, 8-angle wrt z-axis.
"V>                            After uncertainty, analysis, this array actually
"V>                            holds normalized particle number, fluence,
"V>                            energy and angle wrt z-axis.
"V>SCFLU2(IQ+2,ISCORE,ISZ,IP) = array for holding the sum of the squares of
"V>                             the quantities scored in SCFLU.  After
"V>                             uncertainty analysis, it holds the fractional
"V>                             uncertainty for the quantities scored in
"V>                             SCFLU.  Array indices have same meaning as in
"V>                             SCFLU.
"V>SCFLU_TMP(IQ+2,ISCORE,ISZ,IP) = array that holds scored particle number,
"V>                                energy and angle wrt z-axis for 1 primary
"V>                                history.  Array indices same as for SCFLU
"V>SCFLU_LAST(IQ+2,ISCORE,ISZ,JP) = array that stores last primary history to
"V>                                score particle of charge IQ, crossing
"V>                                plane ISCORE in scoring zone ISZ.  JP=1 if
"V>                                this is a first time crossing; JP=2 for
"V>                                multiple crossers.
"V>SCFLU_COV(IQ+2,ISCORE,ISZ,KP) = for particles of charge IQ, crossing zone
"V>                                ISZ of scoring plane ISCORE, this array
"V>                                stores energy*no. (weighted) summed over
"V>                                all primary histories for first time
"V>                                crossers (KP=1) and multiple crossers
"V>                                (KP=2) and also stores angle*no. (weighted)
"V>                                summed over all primary histories for
"V>                                first time (KP=3) and multiple (KP=4)
"V>                                crossers.  It is eventually used to
"V>                                calculate the covariance between energy
"V>                                and no. and angle and no. so that the
"V>                                uncertainties on energy/no. and angle/no.
"V>                                can be estimated properly
"V>SCFLU_NUM(IQ+2,ISCORE,ISZ,JP) = array that stores the no. of particles
"V>                                of charge IQ, crossing zone ISZ of scoring
"V>                                plane ISCORE.  Does not take into account
"V>                                particle weight.  JP has same meaning as
"V>                                in SCFLU_LAST.
"V>SCFLU_NOCOV(IQ+2,ISCORE,ISZ,JP)= 1 if SCFLU_NUM(IQ+2,ISCORE,ISZ,JP) <
"V>                                 $COVNUM, 0 otherwise.  $COVNUM is the
"V>                                 minimum no. of particles
"V>                                 required to include covariance in the
"V>                                 uncertainty estimate of average energy
"V>                                 and average angle.  It is defined in
"V>                                 beamnrc_user_macros.mortran.
"V>MAX_BIT  = maximum number of bit set
"V>IREGION_TO_BIT = region which set to bit number
"V>EKMAXPHSP(ISCORE) = the max kinetic energy of particles in a phsp file
"V>EKMINPHSPE(ISCORE) = min kinetic energy of e-'s in a phsp file
"V>NINCPHSP = # of incident particles (non-phsp source) used (replaces
"V>            the variable EKMINPHSPG(ISCORE))
"V>NPHOTPHSP(ISCORE) = the total number of photons in a phsp file
"V>ZPHSP(ISCORE) = the value of Z of the phsp file (currently not used)
"V>FLUENCERR(ISCORE)=0 if fluence in scoring zone 6 is okay
"V>IPLOTFLAG=1 if CHAMBER is used for dose scoring
"V>ZPLOTCHM($MAX_DOSE_ZONE+1) z-position of each dose zone in CHAMBER
"V>MAXWEIGHT = max. weight of particles crossing all scoring planes
"V>MINWEIGHT = min. weight of particles crossing all scoring planes
"V>ECUTIN = stores global ECUT--variable kept here because it is used in CMs
"V>PCUTIN = stores global PCUT--variable kept because it is used in CMs
"V>NUM_BREM = total number of bremsstrahlung interactions in this run
"V>data_unit = unit number of .egsdat file (4)
"V>PHSP_OUTDIR = directory to output phase space file to (an option)

REPLACE {;COMIN/SCORE/;} WITH {
;COMMON/SCORE/
   "Ali:GRID"
   NX_ZONE,NY_ZONE,XMIN_ZONE,XMAX_ZONE,YMIN_ZONE,YMAX_ZONE,
   SCDOSE,SCDOSE2, SCFLU, SCFLU2,
   SCFLU_COV, SCSTP,SCDSTP,SCSTP2,SCDSTP2, PIISTP,PHSP_OUTDIR,
   AMASS,TMCPUO,TIMMAX,EIN, RSCORE_ZONE, RSCORE_ZONE2,
   EKMAXPHSP, EKMINPHSPE, NINCPHSP, ZPHSP, ZPLOTCHM,MAXWEIGHT,
   MINWEIGHT,ECUTIN,PCUTIN, SCDOSE_TMP, SCFLU_TMP,
   SCSTP_TMP,SCDSTP_TMP, IHSTRY,NHSTRY,NCASE,NCASEO,NHSTRYO,NCASET,JCASE,
   NPPHSP, NPHOTPHSP, INPHSP,NPFLU, SCFLU_NUM,
   is_finished, data_unit,MXNP,ISTORE,IWATCH,IO_OPT,IOUTSP,ID,
   NSC_PLANES,NSC_ZONES, IPLANE_to_CM,IZLAST,I_MU_PHSP,IZSCORE,JHSTRY,
   ISCORE,ISZ,IDAT, IRESTART, IQIN,MZONE_TYPE,NDOSE_ZONE,DOSE_ZONE,
   MAX_BIT,IREGION_TO_BIT, LNEXC, LNINC, L_N_EXC,L_N_INC,
   FLUENCERR,IPLOTFLAG,DOSE_STAT,NUM_BREM,
   SCFLU_NOCOV,NHSTRY_LAST,SCSTP_LAST,SCDSTP_LAST, SCDOSE_LAST, SCFLU_LAST;
REAL*8 SCDOSE($MAX_DOSE_ZONE,$MAXIT),SCDOSE2($MAX_DOSE_ZONE,$MAXIT),
   SCFLU(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,$MAX_SC_PARAMETERS),
   SCFLU2(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,$MAX_SC_PARAMETERS),
   SCFLU_COV(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,4),
   SCSTP,SCDSTP,SCSTP2,SCDSTP2, PIISTP;
CHARACTER*80 PHSP_OUTDIR;
$REAL AMASS($MAX_DOSE_ZONE),TMCPUO,TIMMAX,EIN,
   RSCORE_ZONE($MAX_SC_PLANES,$MAX_SC_ZONES),
   RSCORE_ZONE2($MAX_SC_PLANES,$MAX_SC_ZONES),
   EKMAXPHSP($MAX_SC_PLANES), EKMINPHSPE($MAX_SC_PLANES),
   NINCPHSP, ZPHSP($MAX_SC_PLANES),
   ZPLOTCHM($MAX_DOSE_ZONE+1),MAXWEIGHT,MINWEIGHT,ECUTIN,PCUTIN,
   SCDOSE_TMP($MAX_DOSE_ZONE,$MAXIT),
   SCFLU_TMP(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,$MAX_SC_PARAMETERS),
   SCSTP_TMP,SCDSTP_TMP,
   "Ali:GRID"
   XMIN_ZONE($MAX_SC_PLANES),XMAX_ZONE($MAX_SC_PLANES),
   YMIN_ZONE($MAX_SC_PLANES),YMAX_ZONE($MAX_SC_PLANES);

$LONG_INT IHSTRY,NHSTRY,NCASE,NCASEO,NHSTRYO,NCASET,JCASE,
   NPPHSP($MAX_SC_PLANES),NPHOTPHSP($MAX_SC_PLANES),INPHSP,
   NPFLU($MAX_SC_PLANES),
   SCFLU_NUM(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,2);
$LOGICAL is_finished;
INTEGER data_unit,MXNP,ISTORE,IWATCH,IO_OPT,IOUTSP,ID,
   NSC_PLANES,NSC_ZONES($MAX_SC_PLANES),
   IPLANE_to_CM($MAX_SC_PLANES),IZLAST,I_MU_PHSP,IZSCORE,JHSTRY,
   ISCORE,ISZ,IDAT, IRESTART,
   IQIN,MZONE_TYPE($MAX_SC_PLANES),NDOSE_ZONE,DOSE_ZONE($MXREG),
   MAX_BIT,IREGION_TO_BIT($MXREG),
   LNEXC, LNINC, L_N_EXC($MAXIT, 32),L_N_INC($MAXIT,32),
   FLUENCERR($MAX_SC_PLANES),IPLOTFLAG,DOSE_STAT,NUM_BREM,
   SCFLU_NOCOV(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,2),

   "Ali:GRID"
   NX_ZONE($MAX_SC_PLANES),NY_ZONE($MAX_SC_PLANES);

$SHORT_INT NHSTRY_LAST,SCSTP_LAST,SCDSTP_LAST,
           SCDOSE_LAST($MAX_DOSE_ZONE,$MAXIT),
           SCFLU_LAST(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,2);
}   "end of definition of /SCORE/

;
"V>
"V>COMMON/SOURCE/  Particle source information:
"V>==============
"V>
"V>Variables passed in common:
"V>GAMMA = 1/2 angle in degrees of swept beam or point source(ISOURC=5or1)
"V>ONEMCOSGAM = 1 - COSGAMMA   used in sampling for ISOURC=1
"V>COSGAMMA = cos of gamma(ISOURC=5, and ISOURC=1)
"V>RBEAM = radius (side of square if<0) of beam at the front of 1st CM.
"V>RBEAM0 = beam spot radius at Z=0 for source 8
"V>WBEAM = -RBEAM/2  for RBEAM < 0, i.e. square point source beams
"V>UINC = incident x-axis direction cosine (ISOURC=0).
"V>VINC = incident y-axis direction cosine (ISOURC=0).
"V>WINC = incident z-axis direction cosine (ISOURC=0).
"V>XBEAM = half-width of the beam in X direction
"V>ZBEAM = half-height of the beam
"V>YBEAM = half-width of the beam in y direction
"V>XBEAM0 = x coordinate of the beam centre
"V>YBEAM0 = y coordinate of the beam centre
"V>XINL = lower X bound of beam on CM 1 (ISOURC=1)
"V>XINU = upper X bound of beam on CM 1 (ISOURC=1)
"V>YINL = lower Y bound of beam on CM 1 (ISOURC=1)
"V>YINU = upper Y bound of beam on CM 1 (ISOURC=1)
"V>XINDEL = XINU-XINL for ISOURC=1 as a rectangular beam
"V>YINDEL = YINU-YINL for ISOURC=1 as a rectangular beam
"V>DISTRH = distance of the source from the middle of the target.
"V>DSTRH2 = DISTRH**2.
"V>DISTZ = distance of the point source from the front of the target.
"V>DISTZ2 = DISTZ**2.
"V>DISTB = distance of the point source from the back of the target.
"V>DISTB2 = DISTB**2.
"V>RCYL1 = radius of the target.
"V>RCYL2 = RCYL1**2.
"V>FD_AT100 = SCANNING FIELD SIZE USED IN ISOURC=7
"V>IRATIO_YXF/2 = THE RATIO OF THE SCANNING BET Y/X DIRECTION
"V>XSCAN_UNIT = SCANNING STEP IN HALF SCANNING CYCLE
"V>PROBFC = probability that incident beam strikes the flat face (ISOURC=12).
"V>PROBBK = probability that incident beam strikes the flat face (ISOURC=12).
"V>PROBSD = probability that incident beam strikes the curved side (ISOURC=12).
"V>ASIDE = rectangular area of the target seen by the beam.
"V>ZCOFST = Z-axis offset of the center of the target.
"V>ZSOFST = Z-axis offset of the source.
"V>NRDIST = # radial bin distribution histogram (ISOURC=20).
"V>NSRCRG = source region for isotropically radiating source (ISOURC=3).
"V>RMINBM = minimum beam radius for ISOURC=14, and ISOURC=3.
"V>RMINSQ = RMINBM**2.
"V>EINSRC = highest possible particle energy from phase-space (ISOURC=21).
"V>NSHIST = number of particles in source file (ISOURC=21).
"V>NSLEFT = number of particles remaining in source file (ISOURC=21).
"V>SPCNAM = 256-character file name of source data file (ISOURC=21 AND 31).
"V>Z_SOURCE = distance from source to reference plane.
"V>INIT_ICM = init ICM # for isourc=21 case, input from temp2 on source line
"V>N_ph_sp_e(g,p) = # of elec, gamma, positrons started from phase space file
"V>E_ph_sp_e(g,p) = energy of elec, gamma, pos started from phase space file
"V>E_MAX_ph_sp =max energy of any particle started from phase space file
"V>NPASS_ph_sp = number of particles rejected from phase space for NPASS=1
"V>NPASS_ph_spO = no. of particles rejected from phase space source in past
"V>               run
"V>SINGAMM = sine of gamma(ISOURC=5)
"V>XYBEAM = X or Y size of the beam at the front of the target.
"V>NNPHSP =number of particles in source 21
"V>NPHOTSRC = number of photons in source 21
"V>EKMAXSRC = max kinetic energy of particles in source 21
"V>EKMAX = max. kinetic energy of particles in source
"V>EKMINSRCE = min kinetic energy of e-'s in source 21
"V>NINCSRC = # of incident particles (from non-phsp source) used to generate
"V>          the source (replaces EKMINSRCG)
"V>ZSRC = Z at which phsp file for source 21 file was written (not used yet)
"V>OLDSRC = 1 if the phsp file was generated by an older version of BEAM
"           and does not contain EKMAXSRC in record 1 and/or does not
"           contain NINCSRC in record 1
"V>FILNAM = 256-character file name for energy spectrum file
"V>NPTS_SRC9 = number of discrete points for source 9
"V>X_SRC9,Y_SRC9 = X,Y at SSD of discrete points for source 9
"V>PROB_SRC9 = probability for each discrete point of source 9
"V>ZSMIN = min Z for source 3
"V>ZSMAX = max Z for source 3
"V>MIN_CM_SRC3 = min CM spanned by source 3
"V>MAX_CM_SRC3 = max CM spanned by source 3
"V>CHOSEN_SRC18 = 0 at start or if we've taken both gaussian distributed
"                 radii from the routine for source 18
"               = 1 if we've only taken the first gaussian distributed
"                 radius from source 18 routine
"V>RIN1_SRC18 = first gaussian-distributed radius calculated by source 18
"V>RIN2_SRC18 = second gaussian-distributed radius calculated by source 18
"V>RINMAX = max radius of source as defined by RMAX_CM(1)
"V>ISOURC = flag for source type.
"V>OUTCNT Keeps track of # of times phsp file for source 21 is
"V>        exhausted
"V>IFPB = flags if ISOURC = 0,2 OR 4.
"V>MONOEN = 0 if use monoenergetic beam,
"V>       = 1 if use source dist'n,
"V>       = 2 if use phase-space of each particle from source.
"V>SPEC_TITLE = 80 char title at top of energy spectrum
"V>NRCYCL = no. of times to recycle each particle from a phsp source before
"V>         moving on to the next one (ISOURC=21)
"V>CYCLNUM  keeps track of how many times a particle has been used
"V>IPARALLEL = no. of parallel jobs into which a simulation is split(ISOURC=21)
"V>PARNUM = set to a different integer value in the range 1<=PARNUM<=IPARALLEL
"V>         for the IPARALLEL parallel jobs (ISOURC=21)
"V>WEIGHTOLD holds WEIGHT for recycled particles (ISOURC=21)
"V>UINOLD    holds UIN for recycled particles (ISOURC=21)
"V>VINOLD    holds VIN for recycled particles (ISOURC=21)
"V>WINOLD    holds WIN for recycled particles (ISOURC=21)
"V>XINOLD    holds XIN for recycled particles (ISOURC=21)
"V>YINOLD    holds YIN for recycled particles (ISOURC=21)
"V>ZINOLD    holds ZIN for recycled particles (ISOURC=24)
"V>INIT_ICMOLD holds ICM for recycled particles (ISOURC=24)
"V>ISRC_DBS  set to 1 if DBS used to generate the source and you wish to
"V>          reject fat photons that will fall outside the DBS splitting
"V>          radius (ISOURC=21)
"V>i_iaea_in = 1 if the phase space source is in IAEA format.  This
"V>          is done automatically based on detecting .IAEAphsp at the end
"V>          of the file name as input
"V>RSRC_DBS  DBS splitting radius used to generate source (ISOURC=21)
"V>SSDSRC_DBS SSD where RSRC_DBS was defined when source was generated
"V>           (ISOURC=21)
"V>ZSRC_DBS  Z where source was generated (ISOURC=21)
"V>NFAT_ph_sp  no. of photons rejected because their trajectory would take
"V>          them beyond the RSRC_DBS at SSDSRC_DBS (ie fat photons) (ISOURC=21)
"V>NFAT_ph_spO no. of fat photons rejected in previous run
"V>sigma_src19 mean angular spread of incident particles in degrees
"              (ISOURC=19)
"V>i_dsb set to 1 for directional source biasing
"V>splitcm_dsb CM no. where particles are split/rotated upon entering
"V>dsb_delta distance between rotated particles in source biasing
"V>dsb_rbin  array of radii corresponding to different splitting no.s
"V>ALPHA24,BETA24  angles of rotation about X- and Y-axes (source 23, 24)
"V>SALPHA24,CALPHA24 sin and cos of ALPHA24 (angle of rotation about X-axis)
"V>                  for source 24 and 23
"V>SBETA24,CBETA24 sin and cos of BETA24 (angle of rotation about Y-axis)
"V>                  for source 24 and 23
"V>DIST24    distance of point of rotation from INIT_ICM (source 24 and 23)

;
REPLACE {$INVDIM} WITH {1000}
;
REPLACE {$NENSRC} WITH {240}
;
REPLACE {;COMIN/ENERGYSRC/;} WITH {
;COMMON/ENERGYSRC/NENSRC,IMODE,ENSRCD,SRCPDF,SRCCDF,ENMIN,CDFINV,
     DELTAK,IB, FILNAM;
$REAL ENSRCD($NENSRC),SRCPDF($NENSRC),SRCCDF($NENSRC),ENMIN,
     CDFINV($INVDIM,2),DELTAK;
INTEGER IMODE,NENSRC,IB;
CHARACTER*256 FILNAM;}
;
" IK: reordered common block to start with largest members first "
"     (that's what one should always do) "

REPLACE {$DSB_MAX_BIN} WITH {1000};
REPLACE {;COMIN/SOURCE/;} WITH {
;COMMON/SOURCE/
   COSGAMMA,GAMMA,ONEMCOSGAM,THETAIN,RTHETAIN,
   THETAI,COSTHETA,SINTHETA,
   DUMMY15,DUMMY11,DUMMY22,UINP,VINP,WINP,SIGN1,SIGN2,RIN1_SRC18,
   RIN2_SRC18,RINMAX,SALPHA24,CALPHA24,SBETA24,
   CBETA24, NNPHSP,NPHOTSRC,WBEAM,
   RBEAM,RBEAM0,RBEAM2,UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,
   DISTZ,DISTZ2,
   DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,ASIDE,ZCOFST,ZSOFST,
   RMINBM,RMINSQ,EINSRC,Z_SOURCE,E_ph_sp_e,E_ph_sp_g,E_ph_sp_p,E_MAX_ph_sp,
   SINGAMMA,FD_AT100,XSCAN_UNIT,XYBEAM,XBEAM0,YBEAM0,
   XINL,XINU,YINL,YINU,XINDEL,YINDEL,
   EKMAXSRC, EKMAX, EKMINSRCE, NINCSRC, ZSRC, X_SRC9,
   Y_SRC9, PROB_SRC9, ZSMIN, ZSMAX,
   RNNO1, RNNO2,AK, RCDFIN,RDISTF,RPDF,RCDF,
   FNORM20, IBNSOK, GRIDSZ, RIN, ZFOCUS,
   COSRNG,SINRNG,WEIGHTOLD,UINOLD,VINOLD,WINOLD,XINOLD,YINOLD,ZINOLD,
   RSRC_DBS,SSDSRC_DBS,ZSRC_DBS,sigma_src19,DIST24,ALPHA24,BETA24,RBEAMY,
   xo_src19, yo_src19,
   NRDIST,NSRCRG,NSHIST,NSLEFT,N_ph_sp_e,N_ph_sp_g,N_ph_sp_p,
   NPASS_ph_sp, NPASS_ph_spO, NFAT_ph_sp, NFAT_ph_spO,
   INIT_ICM, IRATIO_YXF, OLDSRC,NPTS_SRC9,
   MIN_CM_SRC3, MAX_CM_SRC3, MODEIN, ICOUNT, IERROR,
   RLAST, IB20, K20,IRDIST,CHOSEN_SRC18,ISOURC,OUTCNT,IFPB,MONOEN,
   NRCYCL,CYCLNUM,IPARALLEL,PARNUM,ISRC_DBS,i_iaea_in,INSIDE_FLAG,
   INIT_ICMOLD,I_MUPHSP_IN,SPCNAM,
   the_beam_code,the_input_file,the_pegs_file,SPEC_TITLE,phsp_open;
REAL*8 COSGAMMA,GAMMA,ONEMCOSGAM,THETAIN,RTHETAIN,
       THETAI,COSTHETA,SINTHETA,
       DUMMY15,DUMMY11,DUMMY22,UINP,VINP,WINP,SIGN1,SIGN2,RIN1_SRC18,
       RIN2_SRC18,RINMAX,SALPHA24,CALPHA24,SBETA24,
       CBETA24;
$LONG_INT NNPHSP, NPHOTSRC;
$REAL WBEAM,
   RBEAM,RBEAM0,RBEAM2,UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,
   DISTZ,DISTZ2,
   DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,ASIDE,ZCOFST,ZSOFST,
   RMINBM,RMINSQ,EINSRC,Z_SOURCE,E_ph_sp_e,E_ph_sp_g,E_ph_sp_p,E_MAX_ph_sp,
   SINGAMMA,FD_AT100,XSCAN_UNIT,XYBEAM,XBEAM0,YBEAM0,
   XINL,XINU,YINL,YINU,XINDEL,YINDEL,
   EKMAXSRC, EKMAX, EKMINSRCE, NINCSRC, ZSRC, X_SRC9($MAXPTS_SRC9),
   Y_SRC9($MAXPTS_SRC9), PROB_SRC9($MAXPTS_SRC9), ZSMIN, ZSMAX,
   RNNO1, RNNO2,AK, RCDFIN($MXRDIST,2),RDISTF($MXRDIST),
   RPDF($MXRDIST),RCDF($MXRDIST),
   FNORM20, IBNSOK, GRIDSZ, RIN, ZFOCUS,
   COSRNG,SINRNG,WEIGHTOLD,UINOLD,VINOLD,WINOLD,XINOLD,YINOLD,ZINOLD,
   RSRC_DBS,SSDSRC_DBS,ZSRC_DBS,sigma_src19,DIST24,ALPHA24,BETA24,RBEAMY,
   xo_src19, yo_src19;
INTEGER NRDIST,NSRCRG,NSHIST,NSLEFT,N_ph_sp_e,N_ph_sp_g,N_ph_sp_p,
      NPASS_ph_sp, NPASS_ph_spO, NFAT_ph_sp, NFAT_ph_spO,
      INIT_ICM, IRATIO_YXF, OLDSRC,NPTS_SRC9,
      MIN_CM_SRC3, MAX_CM_SRC3, MODEIN, ICOUNT, IERROR,
      RLAST, IB20, K20,IRDIST,CHOSEN_SRC18,ISOURC,OUTCNT,IFPB,MONOEN,
      NRCYCL,CYCLNUM,IPARALLEL,PARNUM,ISRC_DBS,i_iaea_in,INSIDE_FLAG,
      INIT_ICMOLD,I_MUPHSP_IN;
CHARACTER*256 SPCNAM;
CHARACTER*80 the_beam_code,the_input_file,the_pegs_file,SPEC_TITLE;
$LOGICAL phsp_open;

}


" COMIN/USER/
" ===========
"
REPLACE {;COMIN/USER/;} WITH {
;COMIN/USER-PHOTON-FORCING,USER-RANGE-REJECTION,USER-SPLITTING,
       USER-STACK,
       USER-DIRECTIONAL-BREM-SPLITTING,USER-CS-ENHANCEMENT,
       USER-CUSTOM-VARIABLES,USER-DIRECTIONAL-SOURCE-BIASING,
       USER-BCSE/;
}

"V>COMMON/USER-CS-ENHANCEMENT/   Common for cross section enhancement,
"V>                              included in COMIN/USER/
"V>                              Added by IK July 13 2005
"V>
"V> cs_enhance(icm) = photon cross section enhancement factor in CM icm.
"V>                   Default is 1 (i.e. no cross section enhancement).
"V> use_cs_enhance  = true, if any of cs_enhance(i) > 1, false otherwise.
REPLACE {;COMIN/USER-CS-ENHANCEMENT/;} WITH {;
    common/cs_enhancement/ cs_enhance($MAX_CMs), cse_return($MXAUS),
                           use_cs_enhance;
    $REAL                  cs_enhance;
    $LOGICAL               cse_return, use_cs_enhance;
};

"Ali:BCSE"
"IK: modified BCSE"
REPLACE {;COMIN/USER-BCSE/;} WITH {;
    COMMON/BCSE/ BCSE_FACTOR_C,BCSE_POWER_N,BCSE_FACTOR,ENPOLD_ORGNL,
                 is_bcse_medium($MXMED),
                 MED_BCSE,NBRSPL_ORGNL,nmed_enhance,USE_BCSE;
    $LOGICAL     USE_BCSE,is_bcse_medium;
    $INTEGER     MED_BCSE,NBRSPL_ORGNL,nmed_enhance;
    $REAL        BCSE_FACTOR_C,BCSE_POWER_N,BCSE_FACTOR,ENPOLD_ORGNL;
};

;
"V>COMMON/USER-RANGE-REJECTION/  Common used for range rejection, included in
"V>============================  COMIN/USER/
"V>
"V>ESAVE_GLOBAL = global upper energy for range rejection, may differ for
"V>     specific regions.
"V>ECUTRR(IR) = minimum energy of particle on exit from region IR.
"V>     Set in main using E_min_out.
"V>RANGE_ECUTRR(IR) = range in cm at ECUTRR to AE - calculated in main
"V>IREJCT(IR) = 0 => no electron range rejection
"V>           = 1 => use restricted stopping power for range calculation,
"V>                  discard if particle range is less than DNEAR.
"V>           > 1 These options were never really used and removed
"V>IREJCT_GLOBAL = global setting for IREJCT, only has effect when 0, 1 or 2
"V>              = 0 => sets IREJCT to 0 for all regions.
"V>              = 1 => initializes IREJCT(IRL)=1 for all regions and sets up
"V>                     ECUTRR arrays automatically
"V>                     Note CMs can turn it off in individual regions
"V>              = 2 => as for = 1 but do not set up ECUTRR array
"V>ESAVE(IR) = upper energy for range rejection in region IR, in COMIN
"V>            USER-STEP-CONTROLS, set by CM.
;
REPLACE {;COMIN/USER-RANGE-REJECTION/;} WITH {
;COMMON/USERRR/ESAVE_GLOBAL,ECUTRR,
RANGE_ECUTRR,ESAVE,
IREJCT,IREJCT_GLOBAL,i_rr_global;
$REAL ESAVE_GLOBAL,ECUTRR($MXREG),RANGE_ECUTRR($MXREG),
      ESAVE($MXREG);
INTEGER IREJCT($MXREG),IREJCT_GLOBAL,i_rr_global;
}

;
"V>COMMON/USERPF/  User photon forcing, included in COMIN/USER/
"V>==============
"V>
"V>GWTOLD = old weight
"V>GWAIT($MXSTACK) = weight adjustment in photon forcing scheme.
"V>IFORCE = only force photons to interact if this is non-zero.
"V>NFMIN = for force photon interactions macro.
"V>NFMAX = for force photon interactions macro.
"V>NFCMIN = for force photon interactions macro.
"V>NFCMAX = for force photon interactions macro.
"V>NFTIME($MXSTACK) = for force photon interactions macro.
"V>NP_INC($MXSTACK) = flag for photon interaction forcing. When doing
"V>         photon forcing a new photon is created (which carries the
"V>         remaining weight) and transported first. The photon (which
"V>         is forced to interact in the specified CMs) is transported
"V>         later and we set NP_INC(NP) = 1 for this photon.
"V>MFORCF = a flag for printing out a warning message that forcing will
"V>         not be done in regions where PCUT > energy of the photon
"V>DUMU = holds value of ustep during transfer of properties
"V>PATHL stores total number of mean free paths through forcing regions
"V>DELTAP = MFP in medium
"V>EPSLON = random # times weight of forced particle
"V>ARG = 1./(1.-EPSLON)
"V>IRODUM = holds IROLD during transfer of particle properties
"V>IRNDUM holds IRNEW during transfer of properties
"V>ICMNEWDUM holds ICMNEW during transfer
"V>ICMOLDDUM holds ICMOLD during transfer
"V>MEDDUM holds MEDIUM during transfer
"V>IDUM holds IDISC during transfer
"V>MEDTMP holds value of MEDIUM

REPLACE {;COMIN/USER-PHOTON-FORCING/;} WITH {
"         ============================="
;COMMON/USERPF/GWTOLD,GWAIT,IFORCE,NFMIN,NFMAX,NFCMIN,NFCMAX,NFTIME,
         NP_INC,MFORCF,DUMU,PATHL,DELTAP,EPSLON,ARG,
         IRODUM,IRNDUM,ICMNEWDUM,ICMOLDDUM,MEDDUM,IDUM,MEDTMP;
$REAL GWTOLD,GWAIT($MXSTACK),DUMU,PATHL,DELTAP,EPSLON,ARG;
INTEGER IFORCE,NFMIN,NFMAX,NFCMIN,NFCMAX,NFTIME($MXSTACK),
         NP_INC($MXSTACK),MFORCF,IRODUM,IRNDUM,ICMNEWDUM,
         ICMOLDDUM,MEDDUM,IDUM,MEDTMP;
}

"V>COMMON/USERSPL/  arbitrary splitting and some global variables for
"                   bremsstrahlung splitting and russian roulette--included
"                   in COMIN/USER/
"V>
"V>IBRSPL = 0 => NO ADDITIONAL BREMSSTRAHLUNG PHOTONS (DEFAULT)
"V>       = 1 => PERFORM BREMSSTRAHLUNG SPLITTING
"V>       = 2 => PERFORM DIRECTIONAL BREMSSTRAHLUNG SPLITTING
"V>NBRSPL = NUMBER OF BREMSSTRAHLUNG PHOTONS CREATED/INTERACTION
"V>IRRLTT = 0 (default) no Russian Roulette
"V>       = 1 gets set to 2
"V>       = 2 is the default RusRou
"V>ICM_SPLIT = CM # at top of which to set an arbitrary splitting planea
"V>            set to 0 for no arbitrary splitting
"V>NSPLIT_PHOT = splitting no. for arbitrary splitting of photons
"V>NSPLIT_ELEC = splitting no. for arbitrary splitting of electrons
"V>NSPLITI = required to set NSPLIT(NP) at initial call to SHOWER.
"V>NSPLIT(NP) = set to 1 if particle NP or its ancestors have been split at
"V>             the arbitrary splitting plane.
"V>SSD = SSD of field (cm)
"V>FS = radius of circular field (directional bremsstrahlung splitting) (cm)

REPLACE {;COMIN/USER-SPLITTING/;} WITH {
;COMMON/USERSPL/SSD,FS,
               IBRSPL,NBRSPL,IRRLTT,ICM_SPLIT,NSPLIT_PHOT,NSPLIT_ELEC,
               NSPLITI,NSPLIT;
INTEGER IBRSPL,NBRSPL,IRRLTT,ICM_SPLIT,NSPLIT_PHOT,NSPLIT_ELEC,
        NSPLITI,NSPLIT($MXSTACK);
$REAL SSD,FS;
}

"V>COMMON/USER-DIRECTIONAL-BREM-SPLITTING/ global variables used for
"                                          directional bremsstrahlung
"                                          splitting--included in COMIN/USER/
"V>
"V>U_DBS,V_DBS,W_DBS = saved direction cosines so that we can split
"V>                    compton, pair and photoelectric events
"V>X_DBS,Y_DBS,Z_DBS = saved position so that we can split pair and
"V>                    photoelectric events
"V>WT_DBS = saved weight for splitting pair and pe events
"V>DNEAR_DBS = saved DNEAR for splitting pair and pe events
"V>ZLAST_DBS = saved ZLAST for splitting pair and pe eventsa
"V>DIST_DBS = distance along particle trajectory to SSD of field defined
"V>           for DBS
"V>R2_DBS = R^2 where particle strikes SSD
"V>RNNO_DBS = stores random numbers during DBS
"V>COSTHE_DBS,SINTHE_DBS,CPHI_DBS,SPHI_DBS = variables used to calculate
"V>                                          random angles for split X-Rays
"V>                                          after pair and pe events
"V>E_DBS = saved energy for splitting compton, pair and pe events
"V>IR_DBS = saved region number for splitting pair and pe events
"V>LATCH_DBS = saved LATCH value for splitting pair and pe events
"V>NFTIME_DBS = saved NFTIME for splitting pair and pe events
"V>NPASS_DBS(ISCORE) = saved value of NPASS(ISCORE) for splitting pair
"V>                    and pe events
"V>NSPLIT_DBS = saved value of NSPLIT for splitting pair and pe events
"V>NP_DBS = used to store stack locations during DBS
"V>IDBS,JDBS = looping indices used during DBS
"V>IPHAT($MXSTACK) = additional stack variable for DBS.  Set to 1 if this
"V>                  is a fat particle (ie one that was aimed out of the field
"V>                  but survived Russian Roulette and has, thus, had its
"V>                  weight increased).
"V>IPHAT_DBS = temporary storage for IPHAT(NP) during bremsstrahlung
"V>            splitting so that IPHAT=1 is not passed on to split
"V>            descendants
"V>PLAYRR_DBS = 0 if photon is directed into the field defined by FS, SSD
"V>           = 1 if not -- ie Russian Roulette is to be played
"V>ICM_DBS    = CM no. in which ZPLANE_DBS, the plane at which to split
"V>             electrons NBRSPL times to improve e- statistics, is defined.
"V>             Usually the flattening filter.  Set to 0 to not split e- at all
"V>ZPLANE_DBS = Plane no. in ICM_DBS at which e- are to be split NBRSPL time.
"V>             Note, this is the plane no., not the Z position of a plane.
"V>IRAD_DBS   = 1 to distribute the NBRSPL split electrons in a radially
"V>             symmetric manner about the beam axis.
"V>ZRR_DBS    = Z position of russian roulette plane below which non-fat
"V>             photons about to undergo interactions will not be subject to
"V>             russian roulette and interactions due to fat photons will be
"V>             split
"V>ZPOSN_DBS  = Z position of ZPLANE_DBS, for output only
"V>ESPLIT_DBS = 1 if electron splitting in DBS to be done, subject to
"V>             W>0 after electron reaches splitting plane.  Set in
"V>             HOWFAR or WHERE_AM_I of ICM_DBS.  0 otherwise.

" For efficiency, it is better to have common block members aligned at "
" 8 byte boundaries => always start with the 8 byte (double precision) "
" variables "
REPLACE {;COMIN/USER-DIRECTIONAL-BREM-SPLITTING/;} WITH {
;COMMON/USERDBS/
    E_DBS,time_brem,time_comp,time_start,time_end,
    U_DBS,V_DBS,W_DBS,X_DBS,Y_DBS,Z_DBS,WT_DBS,DNEAR_DBS,
ZLAST_DBS,DIST_DBS,R2_DBS,RNNO_DBS,COSTHE_DBS,SINTHE_DBS,CPHI_DBS,SPHI_DBS,
ZRR_DBS,ZPOSN_DBS,
IR_DBS,LATCH_DBS,NFTIME_DBS,NPASS_DBS($MAX_SC_PLANES),
NSPLIT_DBS,
NP_DBS,IDBS,JDBS,IPHAT($MXSTACK),IPHAT_DBS,PLAYRR_DBS,
ICM_DBS,ZPLANE_DBS,IRAD_DBS,ESPLIT_DBS,
count_nbrem,count_ncomp,count_npair,count_nphoto,count_nannih,
count_kill_brem,count_kill_comp,count_kill_photo,count_kill_annih,
count_kill_tmp,count_esplit,

"Ali:REJPLN"
USE_REJPLN,Z_REJPLN,FLAG_REJPLN;
$LOGICAL USE_REJPLN;
$REAL Z_REJPLN;
$INTEGER  FLAG_REJPLN;

$REAL U_DBS,V_DBS,W_DBS,X_DBS,Y_DBS,Z_DBS,WT_DBS,DNEAR_DBS,
ZLAST_DBS,DIST_DBS,R2_DBS,RNNO_DBS,COSTHE_DBS,SINTHE_DBS,CPHI_DBS,SPHI_DBS,
ZRR_DBS,ZPOSN_DBS;
$ENERGY PRECISION E_DBS;
$INTEGER IR_DBS,LATCH_DBS,NFTIME_DBS,NPASS_DBS,NSPLIT_DBS,
NP_DBS,IDBS,JDBS,IPHAT,IPHAT_DBS,PLAYRR_DBS,
ICM_DBS,ZPLANE_DBS,IRAD_DBS,ESPLIT_DBS,
count_nbrem,count_ncomp,count_npair,count_nphoto,count_nannih,
count_kill_brem,count_kill_comp,count_kill_photo,count_kill_annih,
count_kill_tmp,count_esplit;
real*8 time_brem,time_comp,time_start,time_end;
}

"below is for debugging DBS only"
APPEND {; real*4 time_array(2),etime; } TO {
 $DEFINE-LOCAL-VARIABLES-ELECTR;}
APPEND {; real*4 time_array(2),etime; } TO {
 $DEFINE-LOCAL-VARIABLES-PHOTON;}

REPLACE {;COMIN/USER-DIRECTIONAL-SOURCE-BIASING/;} WITH {
;COMMON/USERDSB/rsq_dsb,rnno_dsb,
   i_dsb, do_dsb,splitcm_dsb,k_dsb,
   dsb_delta,dsb_rbin($DSB_MAX_BIN+1),dsb_prob($DSB_MAX_BIN),
   dsb_ibin($DSB_MAX_BIN),dsb_aeff,dsb_nbin;
$REAL rsq_dsb,rnno_dsb,
      dsb_delta,dsb_rbin,dsb_prob,dsb_aeff;
$INTEGER i_dsb,do_dsb,splitcm_dsb,k_dsb,
         dsb_ibin,dsb_nbin;
}

"V>COMMON/USERST/  User variables that used to be in COMIN/STACK--now
"V>==============  included in COMIN/USER
"V>
"V>ZLAST(NP) = Z of last site of interaction for photons or Z of site of
"V             creation of an electron
"V>LATCH_OPTION =1: secondaries don't inherit primaries' latch values
"V>              2: pass on the primaries' latch values to the secondaries &
"V>                 also record where the secondaries are created
"V>              3: = 2 but record where a photon interacts rather than where
"V>                 it passes through
"V>LNOB29: a constant for shifting the region number in order to record it
"V>using LATCH
"V>NPASSI = required for the initial call to SHOWER.
"V>IPHATI = required for initial call to SHOWER
"V>XLAST(NP),YLAST(NP) = X,Y of last site of interaction for photons or of
"V>                      site of creation of an electron
"V>NPASS(NP,ISCORE) = number of times that particle NP or its ancestors have
"V>     crossed scoring plane ISCORE.
"V>FDUMMY,IDUMMY = temp variables used during stack exchange
"V>LATCHIN,LATCHOUT = LATCH value for primaries and secondaries after
"V>                   interactions.  DBS only.
"V>LATCHOLD,ZLASTOLD = values of LATCH and ZLAST for primary before interaction
"V>                    used with DBS in case compton rejected

REPLACE {;COMIN/USER-STACK/;} WITH {
;COMMON/USERST/ZLAST,XLAST,YLAST,FDUMMY,ZLASTOLD,LATCH_OPTION,LNOB29,NPASSI,
             IPHATI,NPASS,IDUMMY,LATCHIN,LATCHOUT,LATCHOLD;
$REAL ZLAST($MXSTACK),XLAST($MXSTACK),YLAST($MXSTACK),FDUMMY,ZLASTOLD;
INTEGER LATCH_OPTION,LNOB29,NPASSI,IPHATI,
       NPASS($MXSTACK,$MAX_SC_PLANES),IDUMMY,LATCHIN,LATCHOUT,LATCHOLD;
}

"now append the USER variables of any SYNC CM to USER"
$SYNCCMS_APPEND_USER;
"same for DYN type CMs"
$DYNCMS_APPEND_USER;

APPEND {;COMIN/CMs,CM_LIST,SCORE/;} TO {$COMIN-ELECTR;}

APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-ANNIH;}

APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-ANNIH-ATREST;}

APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-BREMS;}

APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-SHOWER;}

APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-RELAX;}

APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-RELAX-EADL;}

APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-UPHI;}

"Added by IK for radiative Compton corrections. Sep 6 2005"
APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-RADC-SAMPLE;}

"Added by IK for cross section enhancement. July 13 2005 "
APPEND {;COMIN/CMs/;} TO {$COMIN-PHOTON;}

"Added by IK for the new EII stuff. April 1 2004"
APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-EII-SAMPLE;}

APPEND {;
$REAL xphi, xphi2, yphi, yphi2, rhophi2; } TO
{$DEFINE-LOCAL-VARIABLES-PHOTON;} "necessary for $SELECT-AZIMUTHAL-ANGLE macro"
                                 "used by directional bremsstrahlung splitting"
;

/********************************************************************
  timing variables: need to be in a common so that timing info
  can be passed between beam_init, beam_shower and beam_finish
 *******************************************************************/
REPLACE {;COMIN/TIMING-INFO/;} WITH {;
    common/timing_info/ etimetot, timcpu, tzero, timeb, ibatch;
    $REAL               etimetot, timcpu, tzero, timeb;
    $INTEGER            ibatch;
};


$HAVE_C_COMPILER(#);

#ifdef HAVE_C_COMPILER;
"append variables that allow us to keep track of min, max particle"
"in a phase space source chunk"
APPEND {;COMMON/SCORE_FORPARALLEL/INPHSP_MAX, INPHSP_MIN;
$LONG_INT INPHSP_MAX, INPHSP_MIN; } TO
{;COMIN/SCORE/;}

#endif;

/********************* begin IK: modified BCSE *******************************/
REPLACE {$EVALUATE-SIG0;} WITH {;
    IF( use_bcse & is_bcse_medium(medium) & (ibrspl < 2 | iphat(np) > 1) ) [
        IF(lelec < 0) [
            $EVALUATE sigf USING esig(elke); $EVALUATE dedx0 USING ededx(elke);
            $EVALUATE ebr1 USING ebr1(elke); sig0 = esig_e(medium);
        ]
        ELSE [
            $EVALUATE sigf USING psig(elke); $EVALUATE dedx0 USING pdedx(elke);
            $EVALUATE ebr1 USING pbr1(elke); sig0 = psig_e(medium);
        ]
        sigf = sigf/dedx0;
        IF( bcse_power_n > 0 ) [
            bcse_factor = 1 + bcse_factor_c*(E(np)-prm)**bcse_power_n;
        ] ELSE [ bcse_factor = bcse_factor_c; ]
        IF( ibrspl = 2 & bcse_factor > iphat(np) ) bcse_factor = iphat(np);
        sigf = sigf*(1 + ebr1*(bcse_factor-1));
        IF( sigf > sig0 ) sig0 = sigf;
    ]
    ELSE [
        IF( sig_ismonotone(qel,medium) ) [
            IF(lelec < 0) [
                $EVALUATE sigf USING esig(elke);
                $EVALUATE dedx0 USING ededx(elke);
            ]
            ELSE [
                $EVALUATE sigf USING psig(elke);
                $EVALUATE dedx0 USING pdedx(elke);
            ]
            sig0 = sigf/dedx0;
        ]
        ELSE [
            IF( lelec < 0 ) [sig0 = esig_e(medium);]
            ELSE            [sig0 = psig_e(medium);]
        ]
    ]
};

REPLACE {$EVALUATE-SIGF;} WITH {;
    IF(lelec < 0) [
        $EVALUATE sigf USING esig(elke); $EVALUATE dedx0 USING ededx(elke);
    ] ELSE [
        $EVALUATE sigf USING psig(elke); $EVALUATE dedx0 USING pdedx(elke);
    ]
    sigf = sigf/dedx0;
    IF( use_bcse & is_bcse_medium(medium) & (ibrspl < 2 | iphat(np) > 1) ) [
        IF(lelec < 0) [ $EVALUATE ebr1 USING ebr1(elke); ]
        ELSE          [ $EVALUATE ebr1 USING pbr1(elke); ]
        IF( bcse_power_n > 0 ) [
            bcse_factor = 1 + bcse_factor_c*(E(np)-prm)**bcse_power_n;
        ] ELSE [ bcse_factor = bcse_factor_c; ]
        IF( ibrspl = 2 & bcse_factor > iphat(np) ) bcse_factor = iphat(np);
        sig = sigf*(1 + ebr1*(bcse_factor-1));
        IF( sig <= sig0 ) [ sigf = sig; ]
        ELSE [
            " somehow the final cross section is larger than the initial  "
            " => adjust (lower) the enhancement factor so that they become"
            "    the same                                                 "
            bcse_factor = 1 + (sig0/sigf-1)/ebr1;
            IF( bcse_factor < 1 ) [
                $egs_fatal(*,'In $EVALUATE-SIGF: bcse_factor = ',bcse_factor);
            ]
            sigf = sig0;
        ]
    ]
    ELSE [ bcse_factor = 1; ]
};

REPLACE {$EVALUATE-EBREM-FRACTION;} WITH {;
    IF( use_bcse & is_bcse_medium(medium) & (ibrspl < 2 | iphat(np) > 1) ) [
        ebr1 = ebr1*bcse_factor/(1 + ebr1*(bcse_factor-1));
    ]
    ELSE [
        $EVALUATE ebr1 USING ebr1(elke);
    ]
};

REPLACE {$EVALUATE-PBREM-FRACTION;} WITH {;
    IF( use_bcse & is_bcse_medium(medium) & (ibrspl < 2 | iphat(np) > 1) ) [
        pbr1 = ebr1*bcse_factor/(1 + ebr1*(bcse_factor-1));
    ] ELSE [
        $EVALUATE pbr1 USING pbr1(elke);
    ]
};

REPLACE {$EVALUATE-BHABHA-FRACTION;} WITH {
    $EVALUATE pbr2 USING pbr2(elke);
    IF( use_bcse & is_bcse_medium(medium) & (ibrspl < 2 | iphat(np) > 1) ) [
        pbr2 = (ebr1*(bcse_factor-1) + pbr2)/(1 + ebr1*(bcse_factor-1));
    ]
};

/*********************** end IK: modified BCSE *******************************/





"*******************************************************************************
"*******************************************************************************
"
"                             BEAMnrc PROPER (MAIN)                    ""toc:
"                             ********************                     ""toc:
"
"*******************************************************************************
"
"                 TYPE DECLARATIONS AND COMMON BLOCKS FOR MAIN
"                 ********************************************
"

subroutine beam_init(ircode);

$IMPLICIT-NONE;

$INTEGER ircode,IERR;

;COMIN/BOUNDS, BREMPR, CMs, EDGE, ELECIN, ENERGYSRC, EPCONT, GEOM,
  IO_INFO,MEDIA, MISC, PHOTIN, SCORE, SOURCE, STACK, THRESH, UPHIOT,
  USEFUL, USER, RANDOM, BMODEL, RWPHSP, EGS-VARIANCE-REDUCTION, CH-Steps,
  EGS-IO,TIMING-INFO,GetInput/;
"V>**************************
"T>TYPE DECLARATIONS FOR MAIN
"T>**************************
"T>
INTEGER
   I,IS,I1,I2,I3,I4,IT,J,k, "T>DO loop indices
   LATCHM,NHSTRYM,NPASSM,IQINM,"T> temp. variables
   IERR_INPUTS,  "T>non-zero if error detected on input from parameter-defn file
   IRL,          "T>local region number
   ITMAX,        "T>Number of dose components
   LELKE,        "T>used when computing E_min_out and RANGE_ECUTRR
   lelktmp,      "T>used when computing RANGE_ECUTRR
   lelec,        "T>used when computing RANGE_ECUTRR
   NPPHSPSP,     "T>INTEGER*4 version of NPPHSP for writing/reading to/from
                 "T>header of phsp file
   egs_open_datfile, "T> EGSnrc subroutine
   egs_open_file, "T> EGSnrc subroutine for assigning Fortran units
   lnblnk1,      "T> built-in lnblnk function
   IZLAST1;


$REAL
   DEDXE,          "T> used calculating E_min_out
   EKEM,           "T> used calculating E_min_out
   EKEI,           "T> used in calculating RANGE_ECUTRR
   ELKEI,          "T> used in calculating RANGE_ECUTRR
   fedep,          "T> used in calculating RANGE_ECUTRR
   elktmp,         "T> used in calculating RANGE_ECUTRR
   dedxmid,        "T> used in calculating RANGE_ECUTRR
   aux,            "T> used in calculating RANGE_ECUTRR
   EI,             "T>
   RSCORE_MAX2,     "T>Square of maximum radius of scoring zone = RMAX_CM
   EINM,XINM,YINM,UINM,VINM,WTM,ZINM,WINM, "T> temp. variables
   WEIGHT,Z_SCORE;          "T>

REAL*4 Z_SCORE_SHORT; "T> used to pass Z position of scoring plane to
                      "   IAEA phsp header

$LONG_INT long_tmp; "for MOD functions"


CHARACTER*8 AUNIT;    "T> for use assigning file=fort.   units"
CHARACTER*256 phsp_fn,phsp_fn_base; "T> temp. storage for phase space file name

external combine_results;

/*
   Well, I just wanted to make it compiler with EGSnrcMP =>
   quick hack to define DATEN_FORMAT and TIMEN_FORMAT         IK
 */
REPLACE {$DATEN_FORMAT} WITH {A};
REPLACE {$TIMEN_FORMAT} WITH {A};


"*******************************************************************************
"
"                       START OF EXECUTABLE CODE                       ""toc:
"                       ************************
"
;

IBATCH=0;
ETIMETOT=0;
ircode = 0;

$INIT_PHSP_COUNTERS;

$CHAR_DATA;   "expands to a list of CMLIST and CMTYPE assignments"
              "ie CMLIST(i) and CMTYPE(i) contain identifier and name"
              "of CM(i). They are in COMIN CMs"
              "This uses $CM_LIST and $CM_TYPE definitions from build step"

CALL DATETIME(1);
OUTPUT TIMEN, DATEN;(//' BEAMnrc  '$BEAM_VERSION $USER_MACROS_VERSION/
        ' ON '$MACHINE' WITH EGSnrc.',T60,$TIMEN_FORMAT,1X,$DATEN_FORMAT/);
OUTPUT $MAX_CMs, $MXMED, $MXREG, $MXSTACK, $MAXBRSPLIT, $MAX_DOSE_ZONE,
       $MAX_SC_PLANES, $MAX_SC_ZONES, $MAXIT, $MIN_GAP;
(/' The following internal parameters are set:'/
' Max number of CMs:',I3,           T40,'Max number of media',I4/
' Max number of regions:',I4,       T40,'Max stack:',I10/
' Max bremsstrahlung split:',I10,    T40,'Max number dose zones:',I4/
' Max number of scoring planes:',I3,T40,'Max number of scoring zones:',I4/
' Max number dose components:',I3,  T40,'Minimum air gap:',F12.4,' cm'/
'   All of above can be adjusted in beamnrc_user_macros.mortran'/);


"*******************************************************************************
"*******************************************************************************
"
"        PRE-HATCH-CALL INITIALIZATION, INCLUDING ALL INTERACTIVE INPUT
"        **************************************************************
"
"*******************************************************************************
"
"                          I/O INITIALIZATION of UNITS                 ""toc:
"                          ***************************

IOUTLIST   = 1;   "unit number for listing
IOUTRN     = 2;   "starting random number status for each history
IOUTPLOT   = 3;   "plot file
IORSTRT    = 4;   ".egsdat file
IOUTGPH    = 13;  "EGS_Windows file for graphical display of particle history
IOUTGEOM   = 17;  "EGS_Windows geometry file
IINSRC     = 42;  "unit number for input of phase-space source (input)
OUTCNT     =0;    "# of times isourc=21 phsp file exhausted

"note files for phase space data(units 44,45,46..)  are explicitly opened"
DO I=1,$MAX_SC_PLANES [ IOUTFLU(I) = I+43;"phase-space for scoring plane I"]


"explicitly open .egslst file"
IOUTLIST=egs_open_file(IOUTLIST,0,1,'.egslst');
"open .egstmpa file

"*******************************************************************************
"
"               INPUT FROM PARAMETER-DEFINITION FILE (UNIT 5)          ""toc:
"               *********************************************
CALL INPUTS;        "reads in general info re simulation

OUTPUT; (/' Finished general beamnrc input, now input re component modules');

" Geometry input for the component modules
" ****************************************

IF(IREJCT_GLOBAL > 0) [ DO IRL=1,$MXREG [ IREJCT(IRL) = 1; ]]
"    above done here so individual CMs can turn it off"
NREG = 1;                 "Number of regions
MED(1) = 0;               "Start with vacuum at front
IR_start_CM(1) = 2;       "First region in first CM is region 2
NDOSE_ZONE = 0;           "Number of dose scoring zones (each zone
                          "has 1 or more regions)
IERR_INPUTS = 0;          "Error-checking flag for INPUTS
DO ICM=1,$MAX_CMs ["set flag for checking outer boundary of CM in HOWFAR
   RMAX_CM_FLAG(ICM) = -1; "if flag=-1 after CM input, it was not properly set
]
ICM = 1;                  "CM index is incremented each time a new CM is read

;CALL_INPUT; "Expands to a series of calls to all INPUT_$CMNAME subroutines,
             "the set of component modules {$CMNAME} is specified by $CM_LIST.
             "ICM is incremented before the call to each INPUT_$CMNAME routine

;OUTPUT;(/' Back in main of beamnrc.mortran after inputs from CMs'/);


MAX_CMs = ICM;

" Get cross section enhancement factors, if any.
" Added by IK July 13 2005.
" Moved after hatch call "
"call get_cse_factors;"

"It is possible to set up the inputs with all regions vacuum, but EGSnrc"
"chokes on this in HATCH, so bail out here"
IF(NMED = 0)[
   OUTPUT;(//'  EXITING because entire geometry input as VACCUUM'/
          '          EGSnrc does not like this: set it up so there is at'/
          '          least one region with a material in it'///);
   $CALL_EXIT(1);
]

"if ISOURC=21, check that INIT_CM <= MAX_CMs"
"NB this check used to be in ISOURCE, where MAX_CMs is not yet set"
IF(ISOURC = 21 | ISOURC=23 |ISOURC=24) [
   IF(INIT_ICM > MAX_CMs)|(INIT_ICM < 1)[
       INIT_ICM=1;
       OUTPUT;(//'***ERROR IN INPUT FOR ISOURC=21 or 23 or 24'/
                'INIT_ICM>MAX_CMs or INIT_ICM<1'/
                'INIT_ICM reset to 1'//);
       WRITE(IOUTLIST,'(//''***ERROR IN INPUT FOR ISOURC=21 or 23 or 24''/
                ''INIT_ICM>MAX_CMs or INIT_ICM<1''/
                ''INIT_ICM reset to 1''//)');
   ]
]

"check that ICM_CONTAM <= MAX_CMs"
IF(ITDOSE_ON=1 & ICM_CONTAM > MAX_CMs)[
   ICM_CONTAM=MAX_CMs;
   OUTPUT ICM_CONTAM;
   (//'***WARNING:'/ 'ICM_CONTAM > # of CMs'/ 'ICM_CONTAM reset to ',I4//);
]

"check that ICM_SPLIT is <= MAX_CMs"
IF(ICM_SPLIT > MAX_CMs)[
   OUTPUT ICM_SPLIT, MAX_CMs; (//' ***WARNING***'/ ' ICM_SPLIT > # of CMs'/
                                 ' ICM_SPLIT reduced to ',I4,' from ',I4//);
]

"check that number of dose scoring zones is within limits"
"This should also be done in CMs"
IF (NDOSE_ZONE > $MAX_DOSE_ZONE)["limit exceeded"
    OUTPUT NDOSE_ZONE,$MAX_DOSE_ZONE;(///'***Number of dose zone=',
    I4,' is greater than max allowed =',I5/' Increase $MAX_DOSE_ZONE',
    ' in beamnrc_user_macros.mortran'///);
    $CALL_EXIT(1);
]

DO IRL=2,NREG [
   IF(DOSE_ZONE(IRL)<0)[
        OUTPUT IRL;(//' ****WARNING:'/
                      ' Dose zone in region ',I10,' is < 0'/
                      ' Reset to 0 (no dose scoring).'//);
        DOSE_ZONE(IRL)=0;
   ]
]

"check that radii/half widths of scoring zones do not put them"
"beyond the boundaries of their associated CM"
DO ISCORE=1,NSC_PLANES [
  IF(MZONE_TYPE(ISCORE) = 0)["annular zones"
    DO I=1, NSC_ZONES(ISCORE)[
      IF(RSCORE_ZONE(ISCORE,I)>RMAX_CM(IPLANE_to_CM(ISCORE)))[
        OUTPUT ISCORE, IPLANE_to_CM(ISCORE), I, RSCORE_ZONE(ISCORE,I),
        RMAX_CM(IPLANE_to_CM(ISCORE));
        (//'***ERROR IN INPUT FOR SCORING PLANE ',I4,' ON CM ',I4/
        'Outer radius of zone ',I4,' =',F10.3,' cm, which is > RMAX_CM/SMAX_CM'/
        'Radius reduced to ',F10.3,' cm'//);
        WRITE(IOUTLIST,
'(//''***ERROR IN INPUT FOR SCORING PLANE '',I4,'' ON CM '',I4/
''Outer radius of zone '',I4,'' ='',F10.3,'' cm, which is > RMAX_CM/SMAX_CM''/
''Radius reduced to '',F10.3,'' cm''//)') ISCORE, IPLANE_to_CM(ISCORE),
                      I, RSCORE_ZONE(ISCORE,I),RMAX_CM(IPLANE_to_CM(ISCORE));
                 RSCORE_ZONE(ISCORE,I)=RMAX_CM(IPLANE_to_CM(ISCORE));
                 RSCORE_ZONE2(ISCORE,I)=RSCORE_ZONE(ISCORE,I)**2;
      ]
    ]
  ]
  ELSEIF(MZONE_TYPE(ISCORE) = 1)["square zones"
    DO I=1, NSC_ZONES(ISCORE)[
      IF(RMAX_CM_FLAG(IPLANE_to_CM(ISCORE))=1 &
         SQRT(2.)*RSCORE_ZONE(ISCORE,I)>RMAX_CM(IPLANE_to_CM(ISCORE)))[
             OUTPUT ISCORE, IPLANE_to_CM(ISCORE),
                       I, RSCORE_ZONE(ISCORE,I),
                       RMAX_CM(IPLANE_to_CM(ISCORE))/SQRT(2.);
      (//'***ERROR IN INPUT FOR SCORING PLANE ',I4,' ON CM ',I4/
'Outer half-width of zone ',I4,' =',F10.3,' cm, which goes beyond RMAX_CM'/
                     'Half-width reduced to ',F10.3,' cm'//);
             WRITE(IOUTLIST,
'(//''***ERROR IN INPUT FOR SCORING PLANE '',I4,'' ON CM '',I4/
''Outer half-width of zone '',I4,'' ='',F10.3,
'' cm, which goes beyond RMAX_CM''/
''Half-width reduced to '',F10.3,'' cm''//)') ISCORE, IPLANE_to_CM(ISCORE),
                                             I, RSCORE_ZONE(ISCORE,I),
                                    RMAX_CM(IPLANE_to_CM(ISCORE))/SQRT(2.);
              RSCORE_ZONE(ISCORE,I)=RMAX_CM(IPLANE_to_CM(ISCORE))
                                       /SQRT(2.);
              RSCORE_ZONE2(ISCORE,I)=RSCORE_ZONE(ISCORE,I)**2;
      ]
      ELSEIF(RMAX_CM_FLAG(IPLANE_to_CM(ISCORE))=2 &
             RSCORE_ZONE(ISCORE,I)>RMAX_CM(IPLANE_to_CM(ISCORE)))[
                OUTPUT ISCORE, IPLANE_to_CM(ISCORE),
                       I, RSCORE_ZONE(ISCORE,I),
                       RMAX_CM(IPLANE_to_CM(ISCORE));
      (//'***ERROR IN INPUT FOR SCORING PLANE ',I4,' ON CM ',I4/
 'Outer half-width of zone ',I4,' =',F10.3,' cm, which is > SMAX_CM'/
 'Half-width reduced to ',F10.3,' cm'//);
                WRITE(IOUTLIST,
'(//''***ERROR IN INPUT FOR SCORING PLANE '',I4,'' ON CM '',I4/
''Outer half-width of zone '',I4,'' ='',F10.3,'' cm, which is > SMAX_CM''/
''Half-width reduced to '',F10.3,'' cm''//)') ISCORE, IPLANE_to_CM(ISCORE),
                          I, RSCORE_ZONE(ISCORE,I),
                          RMAX_CM(IPLANE_to_CM(ISCORE));
                RSCORE_ZONE(ISCORE,I)=RMAX_CM(IPLANE_to_CM(ISCORE));
                RSCORE_ZONE2(ISCORE,I)=RSCORE_ZONE(ISCORE,I)**2;
      ]
    ]
  ]
]

IF(IBRSPL=2 & ICM_DBS>0)["check that CM no. for e- splitting is not"
                         "> MAX_CMs or is not of a type supported"
    IF(ICM_DBS>MAX_CMs)[
       ICM_DBS=0;
       OUTPUT MAX_CMs;
   (/' ****DBS WARNING*****'/
     ' CM no. for electron splitting > max. CM no. in accelerator (',I4,')'/
     ' No electron splitting will be done.'/);
    ]
    ELSEIF(CMTYPE(ICM_DBS)~='FLATFILT' & CMTYPE(ICM_DBS)~='PYRAMIDS')[
       ICM_DBS=0;
       OUTPUT CMTYPE(ICM_DBS);
       (/' ****DBS WARNING****'/
         ' You have selected to split electrons in a ',A8,' CM.'/
         ' Electron splitting is only supported in FLATFILT.'/
         ' No splitting will be done.'/);
    ]
]


" Open output data files for scoring planes
" *****************************************
"
IF(IO_OPT = 0  | IO_OPT >= 3) ["requested phase space files be output"

  "$DIRECTORY-FOR-PHSP is defined in beamnrc_user_macros.mortran"
  "default is $cstring(egs_home)//$cstring(user_code)"
  "The default is always on the accelerator directory, not in"
  "  the subdirectory used for other files while running"
  "However, the path does not need to be the same as accelerator"
  " directory, it could be anywhere the user wants. To change it,"
  "redefine $DIRECTORY-FOR-PHSP in beamnrc_user_macros.mortran code"

  IF(PHSP_OUTDIR~=' ')[
      "assume the user wants definition of output directory in the"
      "input file to overwrite that in beamnrc_user_macros.mortran"
      phsp_fn_base=$cstring(PHSP_OUTDIR) // $file_sep //
                   $cstring(output_file);
  ]
  ELSE[
      phsp_fn_base=$DIRECTORY-FOR-PHSP // $file_sep //
                   $cstring(output_file);
  ]
  IF( i_parallel > 0 ) ["add an _w"
      phsp_fn_base=$cstring(phsp_fn_base)// '_w';
      call egs_itostring(phsp_fn_base,i_parallel,.false.);
  ]

  I_MU_PHSP=0; "default to not store fractional MU index"
  "loop through CMs and determine if there are any synchronized ones"
  DO I=1,MAX_CMs[
    IF(CMTYPE(I)='SYNCJAWS' | CMTYPE(I)='SYNCVMLC' |
       CMTYPE(I)='SYNCMLCE' | CMTYPE(I)='SYNCHDMLC')[
      "store fractional MU index in IAEA phsp files"
      I_MU_PHSP=1;
      EXIT;
    ]
  ]

  IF(IRESTART = 0)["start a new run"
     DO I=1,NSC_PLANES [
         $BEAM_OPEN_PHSP_FOR_WRITE;
     ]
  ] "end of IRESTART = 0 block"

  ELSEIF(IRESTART =  1)["restart from a previous run"
      $BEAM_OPEN_PHSP_FOR_READ;
  ] "end of IRESTART = 1 block"
]  "end of block opening phase space files if there"

"initialize counters for phase space output for 1st scorig plane only"
/N_ph_sp_e,N_ph_sp_g,N_ph_sp_p,NPASS_ph_sp,NFAT_ph_sp/=0;
/E_ph_sp_e,E_ph_sp_g,E_ph_sp_p,E_MAX_ph_sp/=0.0;
"
"   get default CM  for scoring planes and zones, if not read in inputs
"
"IPLANE_to_CM(J) is CM at back of which J-th scoring plane is"
IF(IPLANE_to_CM(1) <= 0)["default to last CM in case was not input"
   IPLANE_to_CM(1) = MAX_CMs;
]
DO ISCORE=1,NSC_PLANES ["check CM exists for each scoring plane"
   IF (IPLANE_to_CM(ISCORE)>MAX_CMs) [
      IERR_INPUTS = 1; "Flag to stop after input parameters written to listing
      OUTPUT ISCORE,IPLANE_to_CM(ISCORE); (' *** ERROR *** ',
          ' Scoring plane',I3,' at back of CM',I3,', CM does not exist');
   ]"end if"
]"end of do loop"

" Set default scoring zones for fluence
" *************************************
"
DO ISCORE=1,NSC_PLANES ["loop through scoring planes"
   IF(NSC_ZONES(ISCORE) =  0)["default requested, set radii or half-widths of "
                   "equal-area radial-scoring zones"
      NSC_ZONES(ISCORE) = $MAX_SC_ZONES;
      "Note, particle coming back can be outside these scoring regions"
      "since the next CM may have been bigger"
      OUTPUT;(' Default equal area fluence scoring zones now being set');
      RSCORE_MAX2 = RMAX_CM2(IPLANE_to_CM(ISCORE));
      DO ISZ=1,NSC_ZONES(ISCORE) [
        RSCORE_ZONE2(ISCORE,ISZ) = ISZ*RSCORE_MAX2/NSC_ZONES(ISCORE);
        RSCORE_ZONE(ISCORE,ISZ) = SQRT(RSCORE_ZONE2(ISCORE,ISZ));
      ]
      IF(MZONE_TYPE(ISCORE) = 0)[
          OUTPUT ISCORE,(RSCORE_ZONE(ISCORE,ISZ),ISZ=1,NSC_ZONES(ISCORE));
          (' For scoring plane',I2,', zone radii  are:',(5F8.4));
      ]
      ELSE[
          OUTPUT ISCORE,(RSCORE_ZONE(ISCORE,ISZ),ISZ=1,NSC_ZONES(ISCORE));
          (' For scoring plane',I2,', zone half-widths  are:',(5F8.4));
      ]
   ]
]

" Geometry checking
" *****************
"
" IERR_GEOM is geometry-checking flag and is set in INPUT_$CMNAME as follows:
"    0 if no errors detected,
" 1-99 number of errors detected within CM
"  >99 if CM above overlaps,

DO ICM=1,MAX_CMs [ "Loop over CM's to check if errors in geometry were detected"
   IF (IERR_GEOM(ICM) ~= 0) [
      IF (IERR_GEOM(ICM)>99) [
         IERR_INPUTS = 1; "Flag to stop after input parameters written to
                          "listing
         OUTPUT ICM-1,ICM;
            (' *** ERROR *** Component modules',I3,' and',I3,' overlap');
      ]
      IF (IERR_GEOM(ICM)-(IERR_GEOM(ICM)/100)*100>0) [
         IERR_INPUTS = 1; "Flag to stop after input parameters written to
                          "listing
         OUTPUT IERR_GEOM(ICM)-(IERR_GEOM(ICM)/100)*100,ICM;
            ('***ERROR:'/
            I2,' errors detected in the geometry of component module',I3);
      ]
   ]
]"end loop on ICM"


DO ICM=1,MAX_CMs ["check flag specifying outer boundary of CM in HOWFAR
   "These were all initialized to -1 above, but the CMs should have set them
   IF (RMAX_CM_FLAG(ICM)=-1) ["flag not properly set
      IERR_INPUTS = 1; "Flag to stop after input parameters written to listing
      OUTPUT ICM; (' *** ERROR *** ',
          ' RMAX_CM_FLAG not properly set for CM ',I4 );
   ]
]

"*******************************************************************************
"
"                        INITIALIZE SCORING ARRAYS                     ""toc:
"                        *************************
"
" Prepare for fluence and dose scoring.  Fluence scoring includes full
" phase-space, number, energy, and z-axis direction cosines.

ITMAX=3+LNEXC+LNINC; "Number of dose components"
                     "here lnexc and lninc added to score the different "
                     "dose components contributed by the various latch  "
                     "setting, JWEI, 12/29, 1992 "

"for steps:
SCSTP=0; SCSTP2=0; SCDSTP=0; SCDSTP2=0; PIISTP=0;
SCSTP_LAST=0; SCDSTP_LAST=0;

"for dose:
DO IT=1,ITMAX[
    DO ID=1,NDOSE_ZONE[
          SCDOSE_LAST(ID,IT)=0;
          SCDOSE(ID,IT)=0.0;
          SCDOSE2(ID,IT)=0.0;
          SCDOSE_TMP(ID,IT)=0.0;
    ]
]
"for fluence:
[I1=1,3;
     [I2=1,$MAX_SC_PLANES;
         [I3=1,$MAX_SC_ZONES+1;
                   SCFLU_LAST(I1,I2,I3,1)=0;
                   SCFLU_LAST(I1,I2,I3,2)=0;
                   SCFLU_NUM(I1,I2,I3,1)=0;
                   SCFLU_NUM(I1,I2,I3,2)=0;
                   SCFLU_NOCOV(I1,I2,I3,1)=0;
                   SCFLU_NOCOV(I1,I2,I3,2)=0;
                   DO I4=1,4[
                     SCFLU_COV(I1,I2,I3,I4)=0.;
                   ]
                   [I4=1,$MAX_SC_PARAMETERS;
                      SCFLU(I1,I2,I3,I4)=0.;
                      SCFLU2(I1,I2,I3,I4)=0.;
                      SCFLU_TMP(I1,I2,I3,I4)=0.;
                   ]
]]] "End of loop over I1"

"
" Set scoring flag to 1 if fluence is to be scored at back of CM
DO I=1,MAX_CMs ["Zero scoring flag" ICM_to_SCORE(I)=0; ]
DO I=1,NSC_PLANES [
   NPFLU(I)=0; "initialize no. of particles crossing each plane to 0"
   ICM_to_SCORE(IPLANE_to_CM(I))=I;  "ICM_to_SCORE is inverse of IPLANE_to_CM"
                                     "ICM associated with scoring plane I"
                                     "in COMIN CMs            "
]

NCASEO=0;NCASET=0;TMCPUO=0;NHSTRYO=0;NPASS_ph_spO=0;NFAT_ph_spO=0;

IF(ISOURC~=21 & ISOURC~=24)[
    NNPHSP=1.;
    NINCSRC=1.;
    NRCYCL=0;
]

IF(IRESTART =  0)[ "Fresh start, set everything to zero"

   DO I=1,NSC_PLANES [
       NPPHSP(I)=0;"Initialize the counters + variables for the ph-sp I/O"
       EKMAXPHSP(I)=0.;
       EKMINPHSPE(I)=99999.; "start with a huge number"
       NPHOTPHSP(I)=0;
   ]
   NINCPHSP=0;
] "END IF IRESTART=0"

ELSEIF(IRESTART = 1)["Restart, read old data from unit 4"
    "Open unit 4 as an old file"
    OUTPUT; (/' *** About to read dose/fluence data from previous run ***');
    data_unit=egs_open_datfile(IORSTRT,0,1,'.egsdat');
    READ(data_unit,*) SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIISTP;
    READ(data_unit,*)
           ((SCDOSE(ID,IT),SCDOSE2(ID,IT),IT=1,ITMAX),ID=1,NDOSE_ZONE);
    READ(data_unit,*) ((((SCFLU(I1,I2,I3,I4),SCFLU2(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,$MAX_SC_PARAMETERS);
    READ(data_unit,*) ((((SCFLU_COV(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,4);
    READ(data_unit,*) ((((SCFLU_NUM(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,2);
    $RETRIEVE RNG STATE FROM UNIT data_unit;
    READ(data_unit,*)NCASEO,NHSTRYO,TMCPUO,(NPPHSP(I),I=1,NSC_PLANES),
                   NPASS_ph_spO,NFAT_ph_spO;
    "read in any extra variables"
    $USER-READ-DAT(data_unit);

    CLOSE(data_unit);

    OUTPUT;(/' ***Successfully read previous dose and fluence data file ***'/);

    $BEAM_READ_PHSP_FOR_RESTART;

] "end of IRESTART=1 block"

ELSEIF(IRESTART = 3)[
    "Analysis only, read old data from unit 4"
    "Open unit 4 as an old file"
    OUTPUT; (/' *** About to read dose/fluence data from previous run ***');
    data_unit=egs_open_datfile(IORSTRT,0,1,'.egsdat');
    READ(data_unit,*) SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIISTP;
    READ(data_unit,*)
           ((SCDOSE(ID,IT),SCDOSE2(ID,IT),IT=1,ITMAX),ID=1,NDOSE_ZONE);
    READ(data_unit,*) ((((SCFLU(I1,I2,I3,I4),SCFLU2(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,$MAX_SC_PARAMETERS);
    READ(data_unit,*) ((((SCFLU_COV(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,4);
    READ(data_unit,*) ((((SCFLU_NUM(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,2);
    $RETRIEVE RNG STATE FROM UNIT data_unit;
    $PUT RNG STATE ON UNIT 6;
    READ(data_unit,*)NCASEO,NHSTRYO,TMCPUO,(NPPHSP(IS),IS=1,NSC_PLANES),
                   NPASS_ph_spO,NFAT_ph_spO;
    $USER-READ-DAT(data_unit);
    CLOSE(data_unit);
    NCASE=0;"no new cases, just analyze old data"

] "end of IRESTART = 3 loop"

ELSEIF(IRESTART = 4)[
    call egs_combine_runs(combine_results,'.egsdat');
    NCASE=0;"no new cases, just analyze old data"
] "end of IRESTART = 4 loop"

IF(IRESTART=1|IRESTART=3)[
"set NPFLU(I)=the total no. of particles that have already crossed"
"scoring plane I"
    DO I=1,NSC_PLANES[
       DO I4=1,2[
          DO I3=1,NSC_ZONES(I)+1[
             DO I1=1,3[
                NPFLU(I)=NPFLU(I)+SCFLU_NUM(I1,I,I3,I4);
             ]
          ]
       ]
    ]
]

NCASET=NCASE+NCASEO;

"*******************************************************************************
"*******************************************************************************
"
"                                 HATCH CALL                           ""toc:
"                                 **********
"
DUNIT=1; "Set length units to cm"
OUTPUT NMED, (I,(MEDIA(J,I),J=1,24), I=1,NMED);
     (/' There are', I3,' different media:'/
     (10x,' Medium(',I3,') is: ',24A1));

CALL DATETIME(1);  OUTPUT TIMEN;(/' CALL TO HATCH AT  ',$TIMEN_FORMAT);

CALL HATCH; "Input the pegs generated data"

" Get cross section enhancement factors, if any.
" Added by IK July 13 2005.
call get_cse_factors;

"Ali:REJPLN"
CALL GET_REJPLN;

"Ali:BCSE"
CALL GET_BCSE_PARAMETERS;

"initialize any extra user variables"
$USER-INIT;

CALL DATETIME(1);OUTPUT TIMEN;(/' HATCH COMPLETED AT ',$TIMEN_FORMAT);

call show_transport_parameter(6);

"see if the user wants to scale elastic scattering cross sections"
call set_elastic_parameter;

"Revisit ECUTIN/PCUTIN"
"If all global ECUT/PCUT values were left blank, then"
"ECUTIN/PCUTIN at this point = 0.  Set ECUTIN/PCUTIN to AE/AP of default"
"medium unless this is a vacuum, in which case set them equal to the highest"
"AE/AP of all media.  Will only have implications for IREJCT_GLOBAL=1"
IF(ECUTIN=0.0)[
  IF(AIR_INDEX=1) [
    ECUTIN=AE(1);
  ]
  ELSE [
    DO I=1,NMED[ ECUTIN=MAX(ECUTIN,AE(I));]
  ]
]
IF(PCUTIN=0.0)[
  IF(AIR_INDEX=1) [
    PCUTIN=AP(1);
  ]
  ELSE [
    DO I=1,NMED[ PCUTIN=MAX(PCUTIN,AP(I));]
  ]
]
"Note: default region densities (RHOR=0) set to those of PEGS files in HATCH
;
"*******************************************************************************
"*******************************************************************************
"
"             INITIALIZATION FOR PHOTON FORCING                        ""toc:
"             *********************************
"
"  MFORCF is a flag set to 0 in the begging of the simulation. If photon
"  interaction forcing scheme is used in the simulation and a photon is
"  terminated when entering a region where PCUT is lower than in other
"  regions. A message will be printed and the flag will be set to 1 in order
"  to inform the user that forcing will not be done in this region for photons
"  of energies below PCUT but it may still be done elsewhere
"
MFORCF=0;
"*******************************************************************************
"*******************************************************************************
"
"                     INITIALIZATION FOR HOWFAR                        ""toc:
"                     *************************
"
"  Load array IR_to_CM (passed in COMIN CMs)
"  The purpose of these arrays is to speed up the calls to HOWFAR.
"
IRL = 0; ICM = 0;
LOOP [IRL = IRL + 1;
     IF(IRL = IR_start_CM(ICM+1))["start a new CM in this region"
          ICM = ICM + 1;
     ] "end of if block"
     IR_to_CM(IRL) = ICM;  "note for first region this points to CM=0.
]UNTIL (IRL = NREG);


"           Range rejection initialization                             ""toc:
"           ******************************
IF (IREJCT_GLOBAL = 0) ["no range rejection to be done"
   "override any values set in CMs input or value 1 set at start"
   DO IRL=1,$MXREG [
          IREJCT(IRL) = 0;
          ECUTRR(IRL)=0.;
   ]
"Setting ECUTRR to zero here overrides any default settings of ECUTRR"
"in the individual CMs.  Some CMs set ECUTRR to ECUT; others do not"
"set ECUTRR at all."
]
ELSE[ "doing range rejection
  IF(IREJCT_GLOBAL=1)["automatically increase ECUTRR away from bottom"
      "Calculate and use E_min_out values"
      "for each CM to set ECUTRR for each region"
      "start with ECUT just before scoring plane, assumed to be last CM"
      IF(ICM_to_SCORE(MAX_CMs) ~= 1)[
         OUTPUT;(///' ****************************************************'/
         ' IREJECT_GLOBAL=1 ASSUMES only scoring plane is at back of last CM'
         /' and it isnt!'/
          '**************************************************************'/);
         WRITE(IOUTLIST,'(//'' *********************************************''
         /'' IREJECT_GLOBAL=1 ASSUMES 1 scoring plane is at back of last CM''
         /'' and it isnt!''/
        ''**********************************************************''//)');
      ]
      E_min_out(MAX_CMs) = ECUTIN; "This assumes the global ECUT controls"
        "what we want from the scoring plane - If the user has a higher"
        "value close to the scoring plane, then ECUTIN should be raised"

      "OUTPUT;(//' in BEAMnrc main: Temporary output re calculation of ECUTRR');
      DO ICM = MAX_CMs,2,-1 ["loop over CMs starting from last"
         "calc minimum energy at exit of previous CM which will leave"
         "electrons above required min energy at exit"
         EKE = E_min_out(ICM);  "starting min energy"
         IF (Z_min_thick(ICM,1) = 0.0)["This CM did not set the value"
           "default to whole CM being AIR (i.e MEDIUM 1)"
           Z_min_thick(ICM,1) = Z_min_CM(ICM+1) - Z_min_CM(ICM);
          "Z_min_CM is front of each CM, and for MAX_CMs+1=back of last CM"
           MED_min_thick(ICM,1)=1;
           /******************************************************************
            Check whether user set surrounding to vacuum and nominal air
            was set to medium one which is not necessarily air-like material.
            This could cause the minimum energy needed to reach the bottom of
            the accelerator to become larger than the upper energy limit of
            the available data.
                                                               EMH April 2011
           ******************************************************************/
           IF (AIR_INDEX = 0 &          "surrounding medium is vacuum and"
             RHO(MED_min_thick(ICM,1)) > 0.12048)["air med 100X heavier"
              "Find index of lightest medium available"
              aux=1.0E+10;MED_min_thick(ICM,1)=1;
              DO j=1,nmed [
                 IF (rho(j)<aux)[aux=rho(j);MED_min_thick(ICM,1)=j;]
              ]
              j = MED_min_thick(ICM,1);
              $egs_warning('(a,i3/,3(a/),a,i3,a,e10.5,a,24a1)',
              'Range rejection initialization CM # ',ICM,
              '========================================',
              'Surrounding medium set to VACUUM but AIR-like medium 1',
              'is 100 times more dense than AIR. Resetting MED_min_thick',
              'to least dense medium #',j,' with RHO = ',
              rho(j),' g/cm3 named ',(media(k,j),k=1,24));
           ]
           /*****************************************************************/
         ]
         DO I=1,5[ "loop over minimum thicknesses set in INPUT"
           MEDIUM = MED_min_thick(ICM,I);
           IF(MEDIUM ~= 0)[
             IF (EKE <= UE(MEDIUM)) [ "prevent array index overrun"
                ELKE = LOG(EKE); $SET INTERVAL ELKE, EKE;
                $EVALUATE DEDXE USING EDEDX(ELKE);
                EKEM = EKE + 0.5*DEDXE*Z_min_thick(ICM,I);
                "EKEM is roughly mid-point of energy-assumes const DEDXE"
                "iterate once to get better average stopping power"
                IF (EKEM <= UE(MEDIUM)) [ "prevent array index overrun"
                    ELKE = LOG(EKEM); $SET INTERVAL ELKE, EKE;
                    $EVALUATE DEDXE USING EDEDX(ELKE);
                ]
                EKE = EKE + DEDXE*Z_min_thick(ICM,I);
                "EKE is min energy starting this slab which can exit above"
                "required minimum - assuming DEDX varies linearly"
             ]
             "constrain EKE to UE at most, and warn user"
             IF (EKE > UE(MEDIUM)) [
              $egs_warning('(a,i3/,a/,a/,a,f7.2,a,f7.2,a/,2a/,'//
                           '2a,f7.2,a/,/a/,a,f7.2,a,24a1/)',
              'Setting up range rejection (rr) with varying ECUTRR in CM # ',
               ICM,
               '============================================================',
               'Minimum E needed from previous CM to reach the bottom of ',
              'this CM is ',EKE,
              ' MeV. This is larger than UE (',UE(medium),' MeV).',
              'Hence all charged  particles will be range-rejected before ',
              'entering this CM.',
              'Switching off rr in this CM by setting the minimum energy to',
              ' ECUTIN = ', ECUTIN,' MeV.',
              'Are you using a high density surrounding medium?',
              'Nominal "AIR" (MEDIUM 1) with RHO = ',rho(medium),'g/cm3 is ',
              (media(J,medium),J=1,24));

                EKE = E_min_out(ICM);
             ]
           ]"end MEDIUM non-zero block"
         ]"end loop on I for various slabs"
         E_min_out(ICM-1) = EKE;
      ]"end loop on ICM"
      "now set ECUTRR values for each region = E_min_out for that CM"
      DO IRL = 2,NREG[ECUTRR(IRL) = max(ECUT(IRL),E_min_out(IR_to_CM(IRL)));]
              "IR_to_CM from comin CMs tells which CM each region is"
              "in.  It is set just above in main"
  ]
  ELSEIF(IREJCT_GLOBAL=2)["do not calculate ECUTRR"
      DO IRL = 2,NREG[ECUTRR(IRL) =ECUT(IRL);]
  ]

  "For both IREJCT_GLOBAL=1,2 calculate RANGE_ECUTRR, range of electron"
  "with lowest energy to be transported in this region - in COMIN USER"
  lelec=-1; "need to set this for EGSnrc macros used to compute range"
  DO IRL = 2,NREG[
    IF(IREJCT(IRL)>0)[
      MEDIUM = MED(IRL);"MED in COMIN MISC, MEDIUM in COMIN USEFUL"
      "only want range above AE"
      IF(MEDIUM=0 | ECUTRR(IRL) = AE(MEDIUM))[RANGE_ECUTRR(IRL)=0.0;]
      ELSE[
         EKE = ECUTRR(IRL)- RM;
         ELKE = LOG(EKE);
         $SET INTERVAL ELKE, EKE;
         EKEI = E_array(LELKE,MEDIUM);
         ELKEI = (LELKE - eke0(MEDIUM))/eke1(MEDIUM);
         $COMPUTE-DRANGE(EKE,EKEI,LELKE,ELKE,ELKEI,RANGE_ECUTRR(IRL));
         RANGE_ECUTRR(IRL)=(RANGE_ECUTRR(IRL)+range_ep(0,LELKE,MEDIUM))*
                         (RHO(MEDIUM)/RHOR(IRL));
                       "RHOR = RHO(MEDIUM) unless overrides used"
                       "add the mult to avoid doing on each step"
      ]
       "Range of electron with energy ECUTRR of this region"
    ]"end IREJCT>0 block"
  ]"end loop on IRL"
]"end of if IREJCT_GLOBAL>0"
;
"*******************************************************************************
"
"                     INITIALIZATION FOR AUSGAB                        ""toc:
"                     *************************
"
;
" Set up AUSGAB calls for normal execution (not necessary, as fed through BLOCK
" DATA, but do it anyway).
DO J=1,5[ IAUSFL(J)=1; ]
DO J=6,$MXAUS[ IAUSFL(J)=0; ]
"NB IAUSFL(6) is set =1 to flag when leaving a CM and then set=0 in AUSGAB"
"This means it must not be used in any other manner."

IAUSFL(7)=1; "call before bremsstrahlung so we can count bremsstrahlung events"

"if uniform bremsstrahlung splitting is on and IRRLTT=0 then,"
"if the particle is the result of a bremsstrahlung or annihilation event, we"
"want to set nbr_split=1 before a bremsstrahlung or annihilation event to avoid"
"higher-order splitting."
"Conversely, if the particle is a primary, then we want to make sure"
"nbr_split=NBRSPL before the bremsstrahlung or annihilation event (provided
"that the particle falls inside the defined field in the case of DBS)."
"Finally, if using DBS, we want to potentially split annihilation events"
IF((IBRSPL=1 & IRRLTT=0) | IBRSPL=2)[
    IAUSFL(13)=1; "before annih in flight"
    IAUSFL(29)=1; "before annih at rest"
]

"When bremsstrahlung splitting is done, we play russian roulette with
"secondaries from split bremsstrahlung photons so we don't get swamped
"following the electrons (usually after just the photons).  For uniform
"bremsstrahlung splitting, russian roulette is taken care of in egsnrc.mortran
"but for directional bremsstrahlung splitting, we need to set prob_RR
"according to the variable splitting number before egsnrc.mortran can
"take care of it.  Thus, we need to set up extra calls to AUSGAB
IF( IBRSPL=2)[
    IAUSFL(16) = 1; " before call to PAIR         "
    IAUSFL(18) = 1; " before COMPTON      "
    IAUSFL(20) = 1; " before PHOTO      "
    IAUSFL(24) = 1; " before RAYLEIGH: wasn't there => things will go wrong "
                    " if someone decides to turn Rayleigh on "
]
IF( IBRSPL=2 ) [
    IAUSFL(26) = 1; " after creating fluorescent photons "
]

IF(LATCH_OPTION  ~= 0)[
        "call ausgab if a SECONDARY is created in order to record the "
        "region number where the particle is generated                "
        "we're going to call ausgab a lot"
        /IAUSFL(8),IAUSFL(10),IAUSFL(12),IAUSFL(14),IAUSFL(15),IAUSFL(17),
        IAUSFL(19),IAUSFL(21)/=1;
        IF(LATCH_OPTION  >= 2)[
           IAUSFL(25)  = 1; " after a coherent interaction has occurred "
           LNOB29 = 2**(29-$LATCH_NUMBER_OF_BITS);
        ]
        "LNOB29 is a constant used to shift the region number so that this    "
        "number can be recorded by LATCH using bits (29-$LATCH_NUMBER_OF_BITS)"
        "- 28. BITS 1 - (28-$LATCH_NUMBER_OF_BITS) are used for region bit set"
        "One can recover the region number by dividing LATCH by LNOB29 later  "
        "on while working with PAW. For example, one can get the information  "
        "on all the particles created in region N using (INT(L/LNOB29) = N).  "
        "For the primaries, we should have N = 0.                             "
]

IF(IZLAST ~= 0)[ "scoring of last interaction site is requested."
   /IAUSFL(8),IAUSFL(14),IAUSFL(15),IAUSFL(17)/ =1;
   /IAUSFL(19),IAUSFL(25),IAUSFL(21)/ = 1;
   "With these flags set, AUSGAB is called as follows:"
   "8  => after brem created"
   "14 => after annihiliation in flight"
   "15 => after annihiliation at rest"
   "17 => after pair production"
   "19 => after compton scatter"
   "21 => after photoelectric event"
   "25 => after Rayleigh event"
]

" Set up AUSGAB calls for cross section enhancement "
" Added by IK July 13 2005.                         "
DO j=1,$MXAUS [ cse_return(j) = .false.; ]
IF( use_cs_enhance ) [
    " cross section enhancement requested.
    " we need calls to ausgab before and after compton/pair/photo/rayleigh
    " If the flags for these calls are not set, we set cse_return to true
    " so that we can return from AUSGAB immediately.
    IF( iausfl(16) = 0 ) cse_return(16) = .true.;
    IF( iausfl(17) = 0 ) cse_return(17) = .true.;
    IF( iausfl(18) = 0 ) cse_return(18) = .true.;
    IF( iausfl(19) = 0 ) cse_return(19) = .true.;
    IF( iausfl(20) = 0 ) cse_return(20) = .true.;
    IF( iausfl(21) = 0 ) cse_return(21) = .true.;
    IF( iausfl(24) = 0 ) cse_return(24) = .true.;
    IF( iausfl(25) = 0 ) cse_return(25) = .true.;
    IAUSFL(16) = 1; IAUSFL(17) = 1; " before/after PAIR     "
    IAUSFL(18) = 1; IAUSFL(19) = 1; " before/after COMPTON  "
    IAUSFL(20) = 1; IAUSFL(21) = 1; " before/after PHOTO    "
    IAUSFL(24) = 1; IAUSFL(25) = 1; " before/after RAYLEIGH "
]

"Ali:BCSE"

IF(IBRSPL=1)[IAUSFL(26)=1; "to split eii relaxation photons in UBS"]
                           "regardless of the use of BCSE         "
IF(USE_BCSE)[/IAUSFL(7),IAUSFL(8),IAUSFL(26)/=1;]

"*******************************************************************************
"
"                     INITIALIZATION FOR SHOWER                        ""toc:
"                     *************************
"
;
MXNP=0; "Reset the maximum stack indicator passed in SCORE

IHSTRY = NCASEO; "Reset the number of histories counter
NPASS_ph_sp=NPASS_ph_spO; "set number of particles rejected because of being"
                          "multiple passers"
NFAT_ph_sp=NFAT_ph_spO; "set no. of photons rejected because their trajectory"
                        "would take them beyond DBS radius at SSD"
NHSTRY = NHSTRYO;
IF((ISOURC=21 | ISOURC=24) & ~phsp_open)[
   IF(IPARALLEL>1 & PARNUM>0)["this is one of IPARALLEL parallel runs"
      IF(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp)<NNPHSP/IPARALLEL)[
          INPHSP=INT((PARNUM-1)*NNPHSP/IPARALLEL)+IHSTRY+
                 (NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp);
      ]
      ELSE[
          long_tmp=NNPHSP;
          INPHSP=INT((PARNUM-1)*NNPHSP/IPARALLEL)+
                   MOD(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp),
                       long_tmp/IPARALLEL);
      ]
   ]
   ELSE["not a parallel run"
      IF(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp).LT.NNPHSP)[
           INPHSP = IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp);
      ]
      ELSE[
          long_tmp=NNPHSP;
           INPHSP=MOD(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp),long_tmp);
      ]
   ]
   IF(i_iaea_in=1)["need to set position in IAEA phsp source"
      $IAEA_SET_PHSP_RECORD(IINSRC,INPHSP+1);"start at INPHSP+1 because"
                                             "INPHSP is incremented upon"
                                             "entering srchst"
   ]
]
"set the counter for the particle number being read from ph-sp file"

"special case if this is a beam library source using a phase space file"
$SET_INPHSP_BEAM_SOURCE_PARALLEL;

JHSTRY = 0; "Reset counter for EGS_WINDOWS for ZLAST"

IF(ISOURC < 21 | ISOURC=22) ["non-phase space input"
   IF(MONOEN =  0) ["Monoenergetic beam"
       IF(IQIN =  0)[EI=EIN;]ELSE[EI=EIN+RM;]
       EKMAX=EIN; "Maximum kinetic energy"
   ]
   ELSEIF(MONOEN =  1) ["spectrum input"
       EKMAX = ENSRCD(NENSRC);
   ]
]
ELSEIF(ISOURC >= 21 & ISOURC~=22) [
    "Read from ph-sp file or use beam characterization model"
    EKMAX=EKMAXSRC; "Maximum kinetic energy from the ph-sp particle"
    EIN=EKMAXSRC;"EIN will be used later in ISUMRY "
]

" Check that the data file had data over the energy range required"
DO I=1,NMED[
    IF((EKMAX >  UP(I)) |  (EKMAX >  UE(I)-RM))[
        OUTPUT I,EKMAX,UP(I),UE(I);
        (//1X,50('*')//
        ' FOR MEDIUM',I3,' INCIDENT ENERGY=',F10.1,' MeV'/
        ' IS GREATER THAN COVERED BY DATA FILE WHERE UP,UE=',2F10.1,' MeV'/
        '     EXECUTION WILL TERMINATE AFTER COMPLETION OF INPUT FILE'//
        1X,50('*')//);
        IRESTART=2; "Signal an early exit"
    ]
] "End of loop over media"

" Calculate one-time-only constants for source"
CALL SRCOTO(WEIGHT);

$BEAMMODEL_READ_FILE;
"beam characterization model inputs"

"open the .egsgeom file if asked for (.egsgph is opened in WATCH)"
IF(IWATCH=4 | IZLAST=2)[
   IOUTGEOM=egs_open_file(IOUTGEOM,0,1,'.egsgeom');
]
IF(IZLAST=2)[
    IOUTGPH=egs_open_file(IOUTGPH,0,1,'.egsgph');
]

"open the .egsdat file if asked for"
IF(IDAT=0) data_unit = egs_open_file(IORSTRT,0,1,'.egsdat');

"Print the summary of INPUTS"
CALL ISUMRY;

"now set ECUT(1)=PCUT(1)=0.0 to avoid warning messages from AUSGAB"
ECUT(1)=0.;
PCUT(1)=0.;
IF (IERR_INPUTS ~= 0) [ "stop if errors detected in INPUTS
   OUTPUT; (//'***ERROR in CM geometries -- simulation not run'//);
   WRITE (IOUTLIST,121);
   $CALL_EXIT(1);
]
121  FORMAT('***ERROR in CM geometries -- simulation not run'/
     T20, 'See log file or terminal output');

" Write the header for the listing file
CALL DATETIME(1);
WRITE(IOUTLIST,100) TITLE,TIMEN,DATEN;
100  FORMAT(//1A79/
     /' NRCC CALN: BEAMnrc(EGSnrc) '$BEAM_VERSION $USER_MACROS_VERSION,
     /' ON '$MACHINE' ',T60,$TIMEN_FORMAT,1X,$DATEN_FORMAT);
WRITE(IOUTLIST,200);
200  FORMAT(' ',79('*')/
            ' ',T20,'EXECUTION INFORMATION AND WARNING MESSAGES'/
            ' ',79('*') );

"Print header for execution messages"
WRITE(i_log,200);

" Print execution mode
IF(IRESTART =  0)[WRITE(i_log,201);WRITE(IOUTLIST,201);]
ELSEIF(IRESTART =  1)[
    IF(ISOURC=21 | ISOURC=24)[
       WRITE(i_log,205) NCASE,NCASEO,NHSTRYO,NPASS_ph_spO,NFAT_ph_spO,
                    (NPPHSP(IS),IS=1,NSC_PLANES);
       WRITE(IOUTLIST,205)NCASE,NCASEO,NHSTRYO,NPASS_ph_spO,NFAT_ph_spO,
                    (NPPHSP(IS),IS=1,NSC_PLANES);
    ]
    ELSEIF(ISOURC=23)[
       WRITE(i_log,206) NCASE,NCASEO,NHSTRYO,NFAT_ph_spO,
                    (NPPHSP(IS),IS=1,NSC_PLANES);
       WRITE(IOUTLIST,206)NCASE,NCASEO,NHSTRYO,NFAT_ph_spO,
                    (NPPHSP(IS),IS=1,NSC_PLANES);
    ]
    ELSE[
       WRITE(i_log,202) NCASE,NCASEO,(NPPHSP(IS),IS=1,NSC_PLANES);
       WRITE(IOUTLIST,202)NCASE,NCASEO,(NPPHSP(IS),IS=1,NSC_PLANES);
    ]
]
ELSEIF(IRESTART =  2)[
    WRITE(i_log,203); WRITE(IOUTLIST,203);
    ircode = 2; return;
]
ELSEIF(IRESTART =  3)[
    WRITE(i_log,204); WRITE(IOUTLIST,204);
    ircode = 1; return;
]
201  FORMAT(/'********* NEW INPUT FILE *********'/);
202  FORMAT(/' ********* RESTARTED INPUT FILE ********* '/
           ' ',10X,I12,' NEW + ',I12,' OLD HISTORIES'/
           ' ',10X,'USING RN SEEDS FROM PREVIOUS RUN'/
           ' ',10X,'# OF PARTICLES IN THE PH-SP FILE FROM PREVIOUS RUN ='/
           ' ',20X,4(1X,I12)/);
203  FORMAT(/' ********* INPUT FILE CREATION ONLY *********'/);
204  FORMAT(/' ********* DATA ANALYSIS ONLY *********'/);
205  FORMAT(/' ********* RESTARTED INPUT FILE ********* '/
      ' ',10X,I12,' NEW + ',I12,' OLD HISTORIES (',I12,' PRIMARY HISTORIES)'/
      ' ',10X,'# OF MULTIPLE PASSERS REJECTED FROM PREVIOUS RUN = ',I12/
      ' ',10X,'# OF PHOTONS REJECTED BECAUSE THEY FALL OUTSIDE '/
      ' ',10X,'                            DBS SPLITTING RADIUS = ',I12/
      ' ',10X,'USING RN SEEDS FROM PREVIOUS RUN'/
      ' ',10X,'# OF PARTICLES IN THE PH-SP FILE FROM PREVIOUS RUN ='/
      ' ',20X,4(1X,I12)/);
206  FORMAT(/' ********* RESTARTED INPUT FILE ********* '/
      ' ',10X,I12,' NEW + ',I12,' OLD HISTORIES (',I12,' PRIMARY HISTORIES)'/
      ' ',10X,'# OF FAT PHOTONS REJECTED=',I12/
      ' ',10X,'USING RN SEEDS FROM PREVIOUS RUN'/
      ' ',10X,'# OF PARTICLES IN THE PH-SP FILE FROM PREVIOUS RUN ='/
      ' ',20X,4(1X,I12)/);

" Initialize IWATCH routine"
IF(IWATCH ~= 0) CALL WATCH(-99,IWATCH);

CHOSEN_SRC18=0; "initialize in case we are using source 18"

DO I1=1,$MXSTACK[NP_INC(I1)=0;] "INITIALIZE PHOTON INTERACTION FORCING FLAG"

"initialize min. and max. particle weights"
MINWEIGHT=9999.;
MAXWEIGHT=0.;

CYCLNUM=0; "initialize no. of times a particle has been recycled"

NUM_BREM=0; "keeps track of bremsstrahlung interactions for this run only"

NHSTRY_LAST=0;

"the following was added by Tony Popescu and Julio Lobo to allow"
"communication between several moving beam modules"
"initialiaze communicating variables"
BEAM_MU_INDEX=-1.0;
BEAM_MU_INDEX_OLD=-1.0;
dosxyz2beam_index=1.0; "used for dosxyz phsp source- kept as +ve otherwise"

IF(ISTORE =  -1)[
    OUTPUT IOUTRN;(/' Will READ RANDOM NUMBER PARAMETERS FROM UNIT : ',I2);
    IOUTRN=egs_open_datfile(IOUTRN,0,1,'.egsrns');
    $RETRIEVE RNG STATE FROM UNIT IOUTRN;
    "Read initial random # parameters for the first history from a file"
]

" initialize interaction counters for dbs "
/count_nbrem,count_ncomp,count_npair,count_nphoto,count_nannih,
count_kill_brem,count_kill_comp,count_kill_photo,count_kill_annih/=0;
/time_brem,time_comp/=0;
count_esplit=0;
return;

:EOF_MAIN:;
OUTPUT;(//' *** unexpected end of file reading input for MAIN ***');
ircode = -1; return;

:ERROR_MAIN:;
OUTPUT;(//' *** format error on input for MAIN ***');
ircode = -2; return;

:EOF_RS1:;
OUTPUT;(/' *** Error on opening file: No directory/file can be found. ***');
ircode = -3;

return; end;

/**************************************************************************
 *
 *                 beam_shower
 *
 **************************************************************************/
subroutine beam_shower(icase);
/**************************************************************************/
implicit none;
$LONG_INT icase;

;COMIN/SCORE,SOURCE,EPCONT,RANDOM,CMs,USER,IO_INFO,TIMING-INFO,USEFUL,EGS-IO,
RWPHSP/;

$LONG_INT
   NHSTRY_OLD;   "T>used to store previous version of NHSTRY before call
                 "  to SRCHST"

$INTEGER RESETWATCH,IRIN,I1,I2,I3,IT,LATCHI,ITMAX;
$REAL    EI,XIN,YIN,ZIN,UIN,VIN,WIN,WEIGHT;
integer  egs_open_file;

RESETWATCH = 0;
ITMAX=3+LNEXC+LNINC;

IHSTRY=IHSTRY+1; "Increment history counter"
NHSTRY_OLD=NHSTRY; "store old value of NHSTRY"
IF(IWATCH < 0 & ABS(IWATCH) = IHSTRY)[
      IWATCH=2;
      RESETWATCH=1;
]

NFTIME(1)=0; "Reset the photon interaction forcing counter"
IDISC=0; "reset flag for starting a new particle           "
     "Photon forcing didn't work properly without this in  "
     "past but not now as we changed the condition for exit"
     "from IDISC=1 to IRNEW=1. Anyway, it does more good   "
     "than harm to reset it in the beginning of a history. "
     "It prevints further problems when we make use of     "
     "IDISC in the future.                                 "

IF(ISTORE = 1)["store state of RNG for later use"
    IOUTRN=egs_open_file(IOUTRN,0,1,'.egsrns');
    $PUT RNG STATE ON UNIT IOUTRN;
    CLOSE(IOUTRN);
]

IF(IBRSPL=2)[
  IPHATI=NBRSPL;
]
ELSE[
  IPHATI=1; "default value of iphat for source particles"
          "may be changed in SRCHST if ISOURC=3 and DSB is on"
]

IF(dosxyz2beam_index<0)[" for particles given by dosxyznrc"
                      "set the index to be positive again"
        BEAM_MU_INDEX=dosxyz2beam_index+1.1;
        "make sure the old index is different so the CMs freeze since"
        "dosxyznrc sets them"
        BEAM_MU_INDEX_OLD=BEAM_MU_INDEX-1.1;

]

"Tony Popescu and Julio Lobo: Note: with multiple"
"synchronized modules, only one sets the BEAM_MU_INDEX"
"the rest use the same one"
$SYNCCMS_SET_COMP; "coding for synchronized settings of all SYNC"
                   "type CMs in the accelerator"
$DYNCMS_SET_COMP; "same for DYN CMs"

"the following was added by Tony Popescu and Julio Lobo to allow"
"communication between several moving beam modules"
"set old mu index after all dynamic modules have been set"
BEAM_MU_INDEX_OLD = BEAM_MU_INDEX;

"Calculate the source dependant values which change for each
"history these include :
"particle energy if full phase-space input
"entry point into target,
"initial component module,
"initial direction cosines,
"statistical weight,
CALL SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT);
"for ISOURC=21 EIN and IQIN are passed via comin score"
ICMNEW = ICM; "set equal to suppress full phase-space output until
              "particle crosses a scoring plane
IF( ISOURC ~= 21 & ISOURC ~=23 & ISOURC~=24 & dosxyz2beam_index >= 0) [
    IF( MONOEN = 1 ) CALL EN_SAMPLE(EIN);
    IF(IQIN =  0)[EI=EIN;]ELSE[EI=EIN+PRM;]
] ELSE [ EI = EIN; ]

"set initial energy for beam models";
$BEAMMODEL_INITIAL_ENERGY;  "default is ;"

"Set initial values of non-standard particle properties in /STACK/"
IF( ISOURC~=21 & ISOURC~=24)[   " added by jwei "
    NPASSI=0;
    "Keeps track of number of times particle or its ancestors
    "have passed through scoring planes
]

NSPLITI=0;

ESPLIT_DBS=0; "default is to not split e- in DBS"

IF (IZLAST ~= 0) [
    ZLAST(1) = ZIN; XLAST(1) = XIN; YLAST(1)= YIN;
    IF (ISOURC ~= 21 & ISOURC~=24) ["not a phase space input"
       ZLAST(1) = ZIN; XLAST(1) = XIN; YLAST(1)= YIN;
    ]
    ELSE [
      "Note that for ISOURC = 21 XLAST,YLAST are not in the input"
      XLAST(1) = -100.0; YLAST(1)= -100.0;
      "Set above values to try to make sure not misused"
   ]
]

IF((IWATCH > 0)  &  (IWATCH ~= 4))[
   OUTPUT 1,(EI-abs(IQIN)*PRM),IQIN,IRIN,XIN,YIN,ZIN,UIN,
            VIN,WIN,LATCHI,WEIGHT;
   (' INITIAL SHOWER VALUES',T37,':',
   I2,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
]

IF(dosxyz2beam_index>=0)[
"Never increment when nhistry controlled by source 20 "
"in dosxyznrc."
IF( isourc = 3 & i_dsb = 1 ) [
    " history counter incremented in SRCHST "
]
ELSE [

IF((ISOURC~=21 & ISOURC~=23 & ISOURC~=24) | (DOSE_STAT=1 & NRCYCL=0) |
   (DOSE_STAT=1 & NRCYCL>0 & CYCLNUM=1) |
   ((ISOURC=21 | ISOURC=24) & DOSE_STAT=0 & IPARALLEL>1 & PARNUM>0 &
       ICASE=1 & IBATCH=1 & NHSTRY=NHSTRY_OLD)) NHSTRY=NHSTRY+1;
"increment no. of primary histories if this is not a phsp source,"
"if phsp source does not demarcate primary histories AND there is"
"no recycling or this is the first particle in the cycle, or if"
"phsp source does indicate primary histories but NHSTRY was not"
"incremented on the first history because this is one of a number"
"of parallel runs and, due to the way the phsp source was"
"partitioned, the first particle did not indicate a new primary"
"history."

]
]
ELSE [
 NHSTRY=NHSTRY_DOS;
]


IF(NHSTRY~=NHSTRY_OLD)["not necessarily true if this is a phsp"
                       "source"
   NHSTRY_LAST=NHSTRY_LAST+1;
   IF(NHSTRY_LAST=32700)["zero all SCARRAY_LAST counters and"
                         "reset NHSTRY_LAST to 1"
     SCSTP_LAST=0; SCDSTP_LAST=0;

     DO IT=1,ITMAX[
        DO ID=1,NDOSE_ZONE[
           SCDOSE_LAST(ID,IT)=0;
        ]
     ]
     [I1=1,3;
        [I2=1,$MAX_SC_PLANES;
           [I3=1,$MAX_SC_ZONES+1;
              SCFLU_LAST(I1,I2,I3,1)=0;
              SCFLU_LAST(I1,I2,I3,2)=0;
           ]
        ]
     ]
     NHSTRY_LAST=1;
   ]
]

"All initial shower variables are set, call the shower routine"

$USER-BEFORE-SHOWER;
CALL SHOWER(IQIN,EI,XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT);
$USER-AFTER-SHOWER;

"Signal the end of a history if WATCH mode is set"
IF(IWATCH >  0) CALL WATCH(-1,IWATCH);
IF(RESETWATCH=1)[IWATCH = 0;]

return; end;

/****************************************************************************
 *
 *                          beam_shower_loop
 *
 ***************************************************************************/
subroutine beam_shower_loop;
/***************************************************************************/
implicit none;

;COMIN/SCORE,SOURCE,STACK,EGS-IO,IO_INFO,USER,EPCONT,RANDOM,USEFUL,CMs,
       CH-Steps,RWPHSP,TIMING-INFO/;

INTEGER
   I,I1,I2,I3,I4,IT, "T>DO loop indices
   TOT_BATCH,    "T>Total number of batches processed
   IRIN,         "T>
   ITMAX,        "T>Number of dose components
   RESETWATCH,   "T>used to reset IWATCH to 0 when IWATCH<0
   NPPHSPSP,     "T>INTEGER*4 version of NPPHSP for writing/reading to/from
                 "T>header of phsp file
   lnblnk1;      "T> built-in lnblnk function

$LONG_INT
   ICASE,
   NHSTRY_OLD;   "T>used to store previous version of NHSTRY before call
                 "  to SRCHST"
$DECLARE_TIMING_VARIABLES;   "timing_variables CPUT0/1/2 TZERO ETIME UTIME_"

$REAL BATCHT;

integer egs_open_file;

$INTEGER IERR;

CHARACTER AUNIT*8, phsp_fn*256,phsp_fn_base*256;

#ifdef HAVE_C_COMPILER;
$REAL   part_dose, part2_dose, current_result, current_uncertainty;
$LONG_INT n_run,n_tot,n_last,n_left,other_num_1,other_num_2,p_per_phsp_chunk;
$INTEGER  n_run_chunk;
$LOGICAL first_time;
#endif;

INTEGER NETADJ;  "T>keeps track of how many times elapsed time adjusted"

NETADJ=0;  "initialize number of times elapsed time adjusted"
ITMAX=3+LNEXC+LNINC;
RESETWATCH=0;
TOT_BATCH = 0;

" Set clock at the beginning of simulations"
$SET_ELAPSED_CPUTIME(tzero);
$INITIALIZE_ELAPSED_TOTAL_TIME;
"note above macros defined in timing.macros"

"New parallel processing implementation. Only used if there is a
"    working C compiler.
#ifdef HAVE_C_COMPILER;
;
n_tot = ncaseo; first_time = .true.;
/part_dose,part2_dose/=0;
"Not sure what is a good quantity to put into the job control file"
"In fact, this quantity may change depending on the run"
"just use 0 for now"

write(i_log,*) '*********** jcase = ',jcase;

:start_parallel_loop:;
IF( n_parallel > 0 ) [  "Job is part of a parallel run "

    call egs_pjob_control(ncase,n_run,n_left,n_tot,part_dose,part2_dose,
                          current_result, current_uncertainty);
    IF( n_run = 0 ) [
        write(i_log,'(//a,a//)') '****** No histories left in job control file',
                      '       => end simulation';
        return;
    ]
    jcase = n_run/$NBATCH;
    IF( jcase < 1 ) [ jcase = 1; n_run = jcase*$NBATCH; ]
    IF( first_time ) [
        IF(ISOURC=21 | ISOURC=24)
                   p_per_phsp_chunk=NNPHSP/(n_parallel*$N_CHUNKS);
        first_time = .false.; n_last = n_run;
        write(i_log,'(//a,i12,a//)') '****** Running ',n_run,' histories';
    ]
    ELSE [
        write(i_log,'(//a,i12,a)') '***** Finished ',n_last,' histories';
        write(i_log,'(/a/,20x,1pe11.4,a,0pf5.2,a/,a,i12,a//)')
  '      current result including previous runs and other parallel jobs: ',
         current_result, ' +/- ',current_uncertainty,' %',
  '      will run another ',n_run,' histories';
    ]
    IF(ISOURC=21 | ISOURC=24)[
"    figure out where to start in the phase space file"
        n_run_chunk=(ncase-n_left)*n_parallel*$N_CHUNKS/ncase;
        other_num_1=n_run_chunk*ncase;
        other_num_2=(ncase-n_left)*n_parallel*$N_CHUNKS;
        IF(other_num_1<other_num_2)[
          n_run_chunk=n_run_chunk+1;
        ]
        INPHSP_MIN=(n_run_chunk-1)*p_per_phsp_chunk+1;
        IF(n_left=0)["this is the last run just use up the rest of the"
                     "phsp source"
           INPHSP_MAX=NNPHSP;
        ]
        ELSE["calculate the max value of INPHSP"
           INPHSP_MAX=INPHSP_MIN+p_per_phsp_chunk-1;
        ]
        INPHSP=INPHSP_MIN-1; "src routine adds 1 to INPHSP"
        "need to set position in IAEA source, if applicable"
        IF(i_iaea_in=1)[$IAEA_SET_PHSP_RECORD(IINSRC,INPHSP_MIN);]
        CYCLNUM=0; "reset NRCYCL counter"
        write(i_log,'(/a/,a,i12,a,i12/,a//)')
  '      This simulation uses a phase space source.',
  '      This run will use from particle',INPHSP_MIN,' to particle ',
         INPHSP_MAX,
  '      in the source file.';
    ]
]
#endif;


"*******************************************************************************
"*******************************************************************************
"
"                                 SHOWER CALL                          ""toc:
"                                 ***********
"
"*******************************************************************************
"
" Loop through the number of histories. Calculate constants that may change for
" each history and do the simulation.
"
"Break up into batches.  Execution stops if there is not enough time to do
"another batch.  Note: these are not statistical batches, they are only for
"output purposes.

IF(IRESTART=3)[
   OUTPUT;(/' Analyzing data from a previous run'//);
]
ELSEIF(IRESTART=4)[
   OUTPUT;(/' Combining and analyzing data from parallel runs'//);
]
ELSE[

  DO IBATCH=1,$NBATCH[

    TOT_BATCH = TOT_BATCH + 1; "Num done including the current one"
    IF(IBATCH =  1)[
        CALL DATETIME(1);
        OUTPUT TIMEN;
        (/' BATCH #',2X,'TIME-ELAPSED',2X,'TOTAL CPUTIME',2X,'RATIO',2X,
        'TIME OF DAY',2X,'RNG pointers'//
        ' ',4X,'1',10X,'0.0',12X,'0.0',6X,'0.00',4X,$TIMEN_FORMAT,'  ',$);
        $SHOW-RNG-STATE(i_log);OUTPUT;(' ');
    ]
    ELSE[
        $SET_ELAPSED_TOTAL_TIME(TIMEB);
        $SET_ELAPSED_CPUTIME(CPUT2);
        TIMCPU=CPUT2-tzero;
        ETIMETOT=ETIMETOT+TIMEB;
        CALL DATETIME(1);
        OUTPUT IBATCH,ETIMETOT,TIMCPU,ETIMETOT/TIMCPU,TIMEN;
        (4X,I2,5X,F8.1,7X,F8.1,2X,F8.2,4X,$TIMEN_FORMAT,'  ',$);
        $SHOW-RNG-STATE(i_log);OUTPUT;(' ');
        "Check there is time left for another batch"
        BATCHT=TIMCPU/FLOAT(TOT_BATCH - 1);"Time per batch so far"
        IF(TIMCPU+1.1*BATCHT >  TIMMAX*3600.)[
            "Not enough time for another batch"
            "Print message and exit simulation loop"
            WRITE(IOUTLIST,210) TIMMAX,TOT_BATCH-1,IHSTRY-NCASEO,IHSTRY;
            WRITE(i_log,210) TIMMAX,TOT_BATCH-1,IHSTRY-NCASEO,IHSTRY;
            return;
        ]

        ;$BEAMMODEL_DATA_OUTPUT;
        "analysis data for beam characterization models"
    ]

    210  FORMAT(//' ========= '/'   NOT ENOUGH TIME TO FINISH WITHIN',
       ' LIMIT OF',F8.2,' HOURS',I3,' BATCHES USED'/
       ' ',I12,' HISTORIES RUN, ',I12,' HISTORIES ANALYZED'//);

    DO ICASE=1,JCASE["within a batch now"

        call beam_shower(icase);

    ] "End of the ICASE loop"

    "Succesful completion of a batch. Delete the raw data from the last batch"
    "and record the new batch only if requested"
    call beam_write_dat;
    IF(IO_OPT = 0  | IO_OPT >= 3) [
        IF(PHSP_OUTDIR~=' ')[
             "assume the user wants definition of output directory in the"
             "input file to overwrite that in beamnrc_user_macros.mortran"
           phsp_fn_base=$cstring(PHSP_OUTDIR) // $file_sep //
                         $cstring(output_file);
        ]
        ELSE[
           phsp_fn_base=$DIRECTORY-FOR-PHSP // $file_sep //
                         $cstring(output_file);
        ]
        IF( i_parallel > 0 ) ["add an _w"
           phsp_fn_base=$cstring(phsp_fn_base)// '_w';
           call egs_itostring(phsp_fn_base,i_parallel,.false.);
        ]
        $BEAM_PHSP_BUFFER_FLUSH;
    ]
  ] "End of loop on IBATCH  - ie end of simulations "
]"end of normal run"

#ifdef HAVE_C_COMPILER;
;
IF( n_parallel > 0 ) [ goto :start_parallel_loop:; ]

#endif;

return; end;

subroutine beam_write_dat;

"subroutine writes the .egsdat file if requested."
"Put in a separate subroutine so that we can output the file when"
"a BEAM simulation is used as a source."
implicit none;
;COMIN/SCORE,SOURCE,RANDOM,CH-Steps,TIMING-INFO,USER,EGS-IO/;

INTEGER IT,ITMAX,I1,I2,I3,I4;

$DECLARE_TIMING_VARIABLES;

ITMAX=3+LNEXC+LNINC;

    IF(IDAT =  0)[
        "add unscored portions of all *_TMP arrays before writing"
        "the .egsdat file"
        SCSTP=SCSTP+SCSTP_TMP;
        SCSTP2=SCSTP2+SCSTP_TMP*SCSTP_TMP;
        SCSTP_TMP=0;
        SCDSTP=SCDSTP+SCDSTP_TMP;
        SCDSTP2=SCDSTP2+SCDSTP_TMP*SCDSTP_TMP;
        SCDSTP_TMP=0;
        DO ID=1,NDOSE_ZONE[
          DO IT=1,ITMAX[
             SCDOSE(ID,IT)=SCDOSE(ID,IT)+SCDOSE_TMP(ID,IT);
             SCDOSE2(ID,IT)=SCDOSE2(ID,IT)+SCDOSE_TMP(ID,IT)*SCDOSE_TMP(ID,IT);
             SCDOSE_TMP(ID,IT)=0;
          ]
        ]
        DO I1=1,3[
          DO I2=1,NSC_PLANES[
            DO I3=1,NSC_ZONES(I2)+1[
              "mean energy, first time crossers"
              SCFLU_COV(I1,I2,I3,1)=SCFLU_COV(I1,I2,I3,1)+
                                       SCFLU_TMP(I1,I2,I3,3)*
                                       SCFLU_TMP(I1,I2,I3,2);
              "mean angle, first time crossers"
              SCFLU_COV(I1,I2,I3,2)=SCFLU_COV(I1,I2,I3,2)+
                                       SCFLU_TMP(I1,I2,I3,4)*
                                       SCFLU_TMP(I1,I2,I3,1);
              "mean energy, multiple crossers"
              SCFLU_COV(I1,I2,I3,3)=SCFLU_COV(I1,I2,I3,3)+
                                       SCFLU_TMP(I1,I2,I3,7)*
                                       SCFLU_TMP(I1,I2,I3,6);
              "mean angle, multiple crossers"
              SCFLU_COV(I1,I2,I3,4)=SCFLU_COV(I1,I2,I3,4)+
                                       SCFLU_TMP(I1,I2,I3,8)*
                                       SCFLU_TMP(I1,I2,I3,5);
              DO I4=1,$MAX_SC_PARAMETERS[
                SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)+
                                    SCFLU_TMP(I1,I2,I3,I4);
                SCFLU2(I1,I2,I3,I4)=SCFLU2(I1,I2,I3,I4)+
                              SCFLU_TMP(I1,I2,I3,I4)*SCFLU_TMP(I1,I2,I3,I4);
                SCFLU_TMP(I1,I2,I3,I4)=0;
              ]
            ]
          ]
        ]
        rewind(data_unit); "i.e. overwrite data from previous batch"
        WRITE(data_unit,*) SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIISTP+count_pII_steps;
        WRITE(data_unit,*)
             ((SCDOSE(ID,IT),SCDOSE2(ID,IT),IT=1,ITMAX),ID=1,NDOSE_ZONE);
        WRITE(data_unit,*)
             ((((SCFLU(I1,I2,I3,I4),SCFLU2(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,$MAX_SC_PARAMETERS);
        WRITE(data_unit,*)
             ((((SCFLU_COV(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,4);
        WRITE(data_unit,*)
             ((((SCFLU_NUM(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,2);
        $SET_ELAPSED_CPUTIME(CPUT2);
        TIMCPU=CPUT2-tzero;
        $PUT RNG STATE ON UNIT data_unit;
        WRITE(data_unit,*) IHSTRY,NHSTRY,TIMCPU,(NPPHSP(I1),I1=1,NSC_PLANES),
                         NPASS_ph_sp,NFAT_ph_sp;
        $USER-WRITE-DAT(data_unit);
        OUTPUT IHSTRY,NPPHSP(1);
           ('     # of histories run:',I10,
            '      # of particles in ph-sp file:',I10/);
        $FLUSH_UNIT(data_unit);
     ]"End of conditional data storage"

return; end;

subroutine beam_finish(ientry);
implicit none;

$INTEGER ientry,egs_open_file;

;COMIN/SCORE,SOURCE,STACK,IO_INFO,RANDOM,USER,CMs,EGS-IO,UPHIOT,TIMING-INFO,
       RWPHSP/;

$REAL
   SCORE_NORM_NUM, "T>Normalization factor for scoring numbers of particles
   SCORE_NORM_FLUENCE, "T>Normalization factor for fluence scoring
   FMASS            "T>Mass of dose zone unless vacuum in which case FMASS=1
;

REAL*8 SCORE_TEMP; "T> temp variable used during uncertainty analysis

$REAL TEMP1,WEIGHT,RATIO;

$INTEGER I,I1,I2,I3,I4,IT,ITMAX,IERR,NUMIND,COVIND;

$DECLARE_TIMING_VARIABLES;

external combine_results;

#ifdef HAVE_C_COMPILER;
integer n_job;

#endif;

is_finished = .false.;

"*******************************************************************************
"
"                             END OF SIMULATION                        ""toc:
"                             *****************

ITMAX=3+LNEXC+LNINC;

IF( ientry ~= 0 & ientry ~= 1) [ goto :END-OF-RUN:; ]

IF(ISOURC=21 | ISOURC=24)[
  IF(OUTCNT>0)["print warning" WRITE(IOUTLIST,249) OUTCNT; ]
  249 FORMAT(///' **WARNING** USED ALL PARTICLES FROM SOURCE FILE ',I5,
  ' TIMES.');
]

:TIME-PLUS-ANAL:

IF(IRESTART~=4 & ~is_finished)[
  WRITE(IOUTLIST,250);
  $SHOW-RNG-STATE(IOUTLIST);
  WRITE(i_log,250);
  $SHOW-RNG-STATE(i_log);
]
$SET_ELAPSED_TOTAL_TIME(TIMEB);
$SET_ELAPSED_CPUTIME(CPUT2);
TIMCPU=CPUT2-tzero;
ETIMETOT=ETIMETOT+TIMEB;
RATIO=ETIMETOT/TIMCPU;
IF(IRESTART ~= 3 & IRESTART ~=4 & ~is_finished)[
    WRITE(IOUTLIST,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
    WRITE(i_log,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
    IF(ientry=1) [
      WRITE(IOUTLIST,280)TIMCPU/dble(IHSTRY),
      3600.*dble(IHSTRY)/TIMCPU;
      WRITE(i_log,280)TIMCPU/dble(IHSTRY),
      3600.*dble(IHSTRY)/TIMCPU;
    ]
    ELSE[
      WRITE(IOUTLIST,280)TIMCPU/dble((IBATCH-1)*JCASE),
      3600.*dble((IBATCH-1)*JCASE)/TIMCPU;
      WRITE(i_log,280)TIMCPU/dble((IBATCH-1)*JCASE),
      3600.*dble((IBATCH-1)*JCASE)/TIMCPU;
    ]
]
IF(IRESTART = 1)[
    WRITE(IOUTLIST,270) TIMCPU+TMCPUO,(TIMCPU+TMCPUO)/3600.;
    WRITE(i_log,270) TIMCPU+TMCPUO,(TIMCPU+TMCPUO)/3600.;
    WRITE(IOUTLIST,280)(TIMCPU+TMCPUO)/dble(IHSTRY),
                       3600.*dble(IHSTRY)/(TIMCPU+TMCPUO);
    WRITE(i_log,280)(TIMCPU+TMCPUO)/dble(IHSTRY),
                 3600.*dble(IHSTRY)/(TIMCPU+TMCPUO);
]
ELSEIF(IRESTART = 3)[
    WRITE(IOUTLIST,275) TMCPUO,TMCPUO/3600.;
    WRITE(i_log,275) TMCPUO,TMCPUO/3600.;
    WRITE(IOUTLIST,280)TMCPUO/dble(IHSTRY),
                       3600.*dble(IHSTRY)/TMCPUO;
    WRITE(i_log,280)TMCPUO/dble(IHSTRY),
                 3600.*dble(IHSTRY)/TMCPUO;
]
ELSEIF(IRESTART = 4 | is_finished)[
    WRITE(IOUTLIST,285) DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/FLOAT(DATCOUNT);
    WRITE(i_log,285) DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/FLOAT(DATCOUNT);
    WRITE(IOUTLIST,290)TMCPUO/dble(IHSTRY),
                       3600.*dble(IHSTRY)/TMCPUO;
    WRITE(i_log,290)TMCPUO/dble(IHSTRY),
                 3600.*dble(IHSTRY)/TMCPUO;
]

250  FORMAT(/' *** FINAL RANDOM NUMBER POINTERS: ',$);
260  FORMAT(//' FOR THIS RUN:'/
             ' ------------ '/
             ' ELAPSED& CPU TIMEs, RATIO =',2F10.1,'s (=',F7.2,'HR)',F7.2);
270  FORMAT(/' FOR THIS+PREVIOUS RUN:'/
             ' --------------------- '/
             ' TOTAL CPUTIME =',F10.1,'s (=',F8.2,' HR)');
275  FORMAT(/' FOR OLD RUN:'/
             ' ----------- '/
             ' TOTAL CPUTIME =',F10.1,'s (=',F8.2,' HR)');
280  FORMAT( ' CPUTIME per history =',F10.5,' sec. Number of histories per',
             ' hour =',F12.0/'   On '$MACHINE' ');
285  FORMAT(/' FOR PARALLEL RUNS:'/
             ' ----------------- '/
    ' On ',I5,' machines '/
    ' TOTAL CPUTIME =',F10.1,'s (=',F8.2,' HR), CPUTIME/machine =',F10.1);
290  FORMAT( ' CPUTIME per history =',F10.5,' sec. '/
             ' Number of histories per hour on one machine =',F12.0/
             '   On '$MACHINE' ');

"*******************************************************************************
"*******************************************************************************
"
"                        ANALYSIS AND OUTPUT OF RESULTS                ""toc:
"                        ******************************
"
"*******************************************************************************
"
"                      STATISTICAL AND OTHER DATA HANDLING             ""toc:
"                      ***********************************

:STATS-ANAL:;

IF(OUTCNT>0)[
   OUTPUT;(//' ***WARNING***'/
       ' The phsp source was restarted at least once.  This may lead'/
       ' to an underestimate of uncertainty, especially if restarted'/
       ' many times.  If restarted many times, try re-running with'/
       ' NRCYCL recalculated as described at top of beamnrc.mortran'//);
]
IF((ISOURC=3 & i_dsb=1)|ISOURC=23)[
   SCORE_NORM_NUM=NHSTRY;
]
ELSE[
   SCORE_NORM_NUM = NINCSRC*dble(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/
                 FLOAT(NNPHSP);
]
"this is the total number of primary (non-phsp source) histories"
"it is a useful number in the following analysis"

"   dose analysis (also analyze no. of charged particle steps)
"   =============
"

$ANALYZE(SCSTP, :SCORE_NORM_NUM);
$ANALYZE(SCDSTP, :SCORE_NORM_NUM);
DO I1=1,ITMAX[
   DO I2=1,NDOSE_ZONE[
     $ANALYZE(SCDOSE,(I2,I1):SCORE_NORM_NUM);
   ]
]

" Convert dose from MeV to Grays per incident particle"
" Recall 1 MeV = 1.602E-6 erg, 1 rad = 100 erg/g, 1 Gy = 1 J/kg = 100 rad  "
" = 10000 erg/g. The unit of mass here is gram. Thus we have 1 MeV/g =     "
" 1.602E-10 Gy. The unit of dose/per incident particle is also Gy.         "

DO IT=1,ITMAX[
    DO ID=1,NDOSE_ZONE[
            IF(SCDOSE(ID,IT) ~= 0.0)[
                FMASS=AMASS(ID);
                IF(FMASS =  0.0)FMASS=1.0; "Avoids /0 for vacuum"
                SCDOSE(ID,IT)=SCDOSE(ID,IT)*1.602E-10/
                              (FMASS*SCORE_NORM_NUM);
            ]
    ]
]

"   fluence analysis
"   ================
"
DO I1=1,3[
  DO I2=1,NSC_PLANES[
     FLUENCERR(I2)=0;
     IF(MZONE_TYPE(I2) = 0)["circular scoring"TEMP1=PI;]
     ELSEIF(MZONE_TYPE(I2) = 1)["square scoring"TEMP1=4.0;] "Ali:GRID"
     ELSEIF(MZONE_TYPE(I2) = 2)["grid scoring"TEMP1=1.0;]
     ELSE[OUTPUT;(///' SCORING NORMALIZATION NOT WELL DEFINED********');
           TEMP1 = 1.0;
     ]
     DO I3=1,NSC_ZONES(I2)+1[
       IF(MZONE_TYPE(I2)<2)["i.e.not grid" "Ali:GRID"
         IF (I3=1) [
            SCORE_NORM_FLUENCE = TEMP1*RSCORE_ZONE2(I2,I3)*SCORE_NORM_NUM;
         ]
         ELSEIF(I3=NSC_ZONES(I2)+1)[
            IF((IPLANE_to_CM(I2)=MAX_CMs) |
              (RMAX_CM_FLAG(IPLANE_to_CM(I2))=RMAX_CM_FLAG(IPLANE_to_CM(I2)+1)
              & RMAX_CM(IPLANE_to_CM(I2))>=RMAX_CM(IPLANE_to_CM(I2)+1)) |
              (RMAX_CM_FLAG(IPLANE_to_CM(I2))=1 &
              RMAX_CM(IPLANE_to_CM(I2))>=SQRT(2.)*RMAX_CM(IPLANE_to_CM(I2)+1))|
              (RMAX_CM_FLAG(IPLANE_to_CM(I2))=2 &
              RMAX_CM(IPLANE_to_CM(I2))>=RMAX_CM(IPLANE_to_CM(I2)+1)))[
                IF(RMAX_CM_FLAG(IPLANE_to_CM(I2))=1)[
                   SCORE_NORM_FLUENCE=(PI*RMAX_CM(IPLANE_to_CM(I2))**2
                                 -TEMP1*RSCORE_ZONE2(I2,NSC_ZONES(I2)))*
                                 SCORE_NORM_NUM;
                ]
                ELSEIF(RMAX_CM_FLAG(IPLANE_to_CM(I2))=2)[
                   SCORE_NORM_FLUENCE=(4*RMAX_CM(IPLANE_to_CM(I2))**2
                                 -TEMP1*RSCORE_ZONE2(I2,NSC_ZONES(I2)))*
                                 SCORE_NORM_NUM;
                ]
            ]
            "now normalizes with area and # of particles in outer zone"
            ELSE["just normalize wrt # of incident particles"
               SCORE_NORM_FLUENCE=SCORE_NORM_NUM;
               FLUENCERR(I2)=1;
            ]
         ]
         ELSE [
            SCORE_NORM_FLUENCE = TEMP1*(RSCORE_ZONE2(I2,I3) -
                                 RSCORE_ZONE2(I2,I3-1))*SCORE_NORM_NUM
         ]
       ]
       ELSE["grid"   "Ali:GRID"
         IF(I3=NSC_ZONES(I2)+1)["the outermost zone"
             SCORE_NORM_FLUENCE=(4*RMAX_CM(IPLANE_to_CM(I2))**2
                  -(RSCORE_ZONE(I2,NX_ZONE(I2)+1)-RSCORE_ZONE(I2,1))*
                   (RSCORE_ZONE2(I2,NY_ZONE(I2)+1)-RSCORE_ZONE2(I2,1)))*
                   SCORE_NORM_NUM;
         ]
         ELSE["the same for all zones"
             SCORE_NORM_FLUENCE=(RSCORE_ZONE(I2,2)-RSCORE_ZONE(I2,1))*
                                (RSCORE_ZONE2(I2,2)-RSCORE_ZONE2(I2,1))*
                                SCORE_NORM_NUM;
         ]
       ] "end of grid"

         IF(SCORE_NORM_FLUENCE~=0.)[
             DO I4=1,8[
                "first add unscored portions of SCFLU_TMP if we have not"
                "already added them prior to writing the .egsdat file"
                IF(IDAT=1)[
                  SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)+
                                   SCFLU_TMP(I1,I2,I3,I4);
                  SCFLU2(I1,I2,I3,I4)=SCFLU2(I1,I2,I3,I4)+
                                    SCFLU_TMP(I1,I2,I3,I4)**2;
                  "add to the covariance arrays"
                  IF(I4=1)["mean energy, first time crossers"
                    SCFLU_COV(I1,I2,I3,I4)=SCFLU_COV(I1,I2,I3,I4)+
                                           SCFLU_TMP(I1,I2,I3,I4+2)*
                                           SCFLU_TMP(I1,I2,I3,2);
                  ]
                  ELSEIF(I4=2)["mean angle, first time crossers"
                    SCFLU_COV(I1,I2,I3,I4)=SCFLU_COV(I1,I2,I3,I4)+
                                           SCFLU_TMP(I1,I2,I3,I4+2)*
                                           SCFLU_TMP(I1,I2,I3,1);
                  ]
                  ELSEIF(I4=3)["mean energy, multiple crossers"
                    SCFLU_COV(I1,I2,I3,I4)=SCFLU_COV(I1,I2,I3,I4)+
                                           SCFLU_TMP(I1,I2,I3,I4+4)*
                                           SCFLU_TMP(I1,I2,I3,6);
                  ]
                  ELSEIF(I4=4)["mean angle, multiple crossers"
                    SCFLU_COV(I1,I2,I3,I4)=SCFLU_COV(I1,I2,I3,I4)+
                                           SCFLU_TMP(I1,I2,I3,I4+4)*
                                           SCFLU_TMP(I1,I2,I3,5);
                  ]
                ]

                "now, do the analysis, total no. of incident primary"
                "histories (SCORE_NORM_NUM) as normalization no."
                SCORE_TEMP=SCFLU(I1,I2,I3,I4)/SCORE_NORM_NUM;
                SCFLU2(I1,I2,I3,I4)=SCFLU2(I1,I2,I3,I4)/SCORE_NORM_NUM;
                SCFLU2(I1,I2,I3,I4)=(SCFLU2(I1,I2,I3,I4)-SCORE_TEMP**2)/
                                     (SCORE_NORM_NUM-1);
                IF(SCFLU2(I1,I2,I3,I4)>0) SCFLU2(I1,I2,I3,I4)=
                                          SQRT(SCFLU2(I1,I2,I3,I4));
                IF((I4<5 & SCFLU_NUM(I1,I2,I3,1)<=1) |
                   (I4>4 & I4<9 & SCFLU_NUM(I1,I2,I3,2)<=1))[
                   "we have 0 or 1 particle contributing"
                   SCFLU2(I1,I2,I3,I4)=99.9;
                ]
                ELSEIF(SCORE_TEMP~=0)[
                     SCFLU2(I1,I2,I3,I4)=
                          MIN(SCFLU2(I1,I2,I3,I4)/SCORE_TEMP*100.D00,99.9D00);
                ]

                "and normalize quantities for output"
                IF(I4=1|I4=5)["no."
                    SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)/SCORE_NORM_NUM;
                ]
                ELSEIF(I4=2|I4=6)["fluence"
                    SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)/SCORE_NORM_FLUENCE;
                ]
                ELSEIF(I4=3|I4=7)["mean energy"
                    IF(I4=3)["set indices"
                       NUMIND=1;
                       COVIND=1;
                    ]
                    ELSE[
                       NUMIND=2;
                       COVIND=3;
                    ]
                    "first, normalize by no. of primary histories"
                    SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)/SCORE_NORM_NUM;
                    "now, get fluence normalized by no. of primary histories"
                    SCORE_TEMP=SCFLU(I1,I2,I3,I4-1)*SCORE_NORM_FLUENCE/
                               SCORE_NORM_NUM;
                    IF(SCFLU_NUM(I1,I2,I3,NUMIND)<=1)[
                        "only 0-1 particle contributing"
                        SCFLU2(I1,I2,I3,I4)=99.9;
                        SCFLU_NOCOV(I1,I2,I3,NUMIND)=1;
                    ]
                    ELSE[
                      IF(SCFLU_NUM(I1,I2,I3,NUMIND)<$COVMIN)[
                        "covers case where there are too few particles to"
                        "consider covariance"
                        SCFLU_COV(I1,I2,I3,COVIND)=0.;
                        SCFLU_NOCOV(I1,I2,I3,NUMIND)=1;
                      ]
                      ELSE[
                        "calculate cov(Energy fluence,fluence)"
                        SCFLU_COV(I1,I2,I3,COVIND)=SCFLU_COV(I1,I2,I3,COVIND)/
                                             SCORE_NORM_NUM -
                                        SCFLU(I1,I2,I3,I4)*SCORE_TEMP;
                        "calcuate cov(E flu.,flu.)/((E flu.)(flu.)(N-1))"
                        SCFLU_COV(I1,I2,I3,COVIND)=SCFLU_COV(I1,I2,I3,COVIND)/
                                                 (SCFLU(I1,I2,I3,I4)*
                                             SCORE_TEMP*(SCORE_NORM_NUM-1));
                      ]
                      SCFLU2(I1,I2,I3,I4)=(SCFLU2(I1,I2,I3,I4)/100.D00)**2+
                                        (SCFLU2(I1,I2,I3,I4-1)/100.D00)**2-
                                         2*SCFLU_COV(I1,I2,I3,COVIND);
                      IF(SCFLU2(I1,I2,I3,I4)>0.)[
                          SCFLU2(I1,I2,I3,I4)=SQRT(SCFLU2(I1,I2,I3,I4));
                      ]
                      SCFLU2(I1,I2,I3,I4)=MIN(SCFLU2(I1,I2,I3,I4)*100.D00,
                                            99.9D00);
                    ]
                    "now divide E flu. by flu."
                    IF(SCFLU(I1,I2,I3,I4-1)>0) SCFLU(I1,I2,I3,I4)=
                                     SCFLU(I1,I2,I3,I4)/SCORE_TEMP;
                ]
                ELSEIF(I4=4|I4=8)[ "mean angle"
                    IF(I4=4)["set indices"
                       NUMIND=1;
                       COVIND=2;
                    ]
                    ELSE[
                       NUMIND=2;
                       COVIND=4;
                    ]
                    "first, normalize in the same way as no.,flu."
                    SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)/SCORE_NORM_NUM;
                    IF(SCFLU_NUM(I1,I2,I3,NUMIND)<=1)[
                        "only 0-1 particle contributing"
                        SCFLU2(I1,I2,I3,I4)=99.9;
                        SCFLU_NOCOV(I1,I2,I3,NUMIND)=1;
                    ]
                    ELSE[
                      IF(SCFLU_NUM(I1,I2,I3,NUMIND)<$COVMIN)[
                        "covers case where there are too few particles to"
                        "consider covariance"
                        SCFLU_COV(I1,I2,I3,COVIND)=0.;
                        SCFLU_NOCOV(I1,I2,I3,NUMIND)=1;
                      ]
                      ELSEIF(SCFLU(I1,I2,I3,I4)=0.)[
                        "covers case where all particles have angle 0"
                        SCFLU_COV(I1,I2,I3,COVIND)=0.;
                      ]
                      "calculate cov(angle,no.)"
                      SCFLU_COV(I1,I2,I3,COVIND)=SCFLU_COV(I1,I2,I3,COVIND)/
                                             SCORE_NORM_NUM -
                                        SCFLU(I1,I2,I3,I4)*SCFLU(I1,I2,I3,I4-3);
                      "calcuate cov(angle,no.)/((angle)(no.)(N-1))"
                      SCFLU_COV(I1,I2,I3,COVIND)=SCFLU_COV(I1,I2,I3,COVIND)/
                                                 (SCFLU(I1,I2,I3,I4)*
                                                  SCFLU(I1,I2,I3,I4-3)*
                                                  (SCORE_NORM_NUM-1));
                      "now, estimate the uncertainty"
                      SCFLU2(I1,I2,I3,I4)=(SCFLU2(I1,I2,I3,I4)/100.D00)**2+
                                        (SCFLU2(I1,I2,I3,I4-3)/100.D00)**2-
                                         2*SCFLU_COV(I1,I2,I3,COVIND);
                      IF(SCFLU2(I1,I2,I3,I4)>0.)[
                          SCFLU2(I1,I2,I3,I4)=SQRT(SCFLU2(I1,I2,I3,I4));
                      ]
                      SCFLU2(I1,I2,I3,I4)=MIN(SCFLU2(I1,I2,I3,I4)*100.D00,
                                            99.9D00);
                    ]
                    "divide angle by no. and convert to degrees"
                    IF(SCFLU(I1,I2,I3,I4-3)>0) SCFLU(I1,I2,I3,I4)=
                                        SCFLU(I1,I2,I3,I4)/SCFLU(I1,I2,I3,I4-3);
                    SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)*57.29578;
                ]
             ]
         ]
         ELSEIF(I1=1 & I3<=NSC_ZONES(I2)) [
            WRITE (IOUTLIST,
          '(//''***WARNING IN SCORING PLANE '',I4,/
              ''Zone '',I4,'' has zero area''//)') I2, I3;
            OUTPUT I2, I3; (//'***WARNING IN SCORING PLANE ',I4,/
                   'Zone ',I4,' has zero area'//);
         ]
    ]
  ]
]

"
"*******************************************************************************
"
"                            OUTPUT SUMMARY                            ""toc:
"                            **************
"

"extra data analysis, output, etc"
"put here so user can skip OSUMRY if required"
$USER-FINISH;

IF(ientry=1) NINCPHSP=SCORE_NORM_NUM;
"so correct no. of incident particles is output to phsp summary when this is a"
"beam source"

CALL OSUMRY; "Print the output summary"

;$BEAMMODEL_OSUMRY;"beam characterization model output"

"below used for evaluating DBS, commented out for now"
"write(6,*); write(6,*);
"write(6,*) '========================================================';
"write(6,*) 'Interaction counters:';
"write(6,*) ' number of brems events: ',count_nbrem;
"write(6,*) ' number of killed brem photons: ',count_kill_brem;
"write(6,*) ' number of annihilation events: ',count_nannih;
"write(6,*) ' number of killed annihilation photons: ',count_kill_annih;
"write(6,*) ' number of compton events: ',count_ncomp;
"write(6,*) ' number of killed compton-scattered photons: ',count_kill_comp;
"write(6,*) ' number of pair events: ',count_npair;
"write(6,*) ' number of photo events: ',count_nphoto;
"write(6,*) ' number of killed fluorescent photons: ',count_kill_photo;
"write(6,*) ' number of electron splitting events: ',count_esplit;
"write(6,*);
"write(6,*) ' time spent doing brem: ',time_brem,' seconds';
"write(6,*) ' time spent doing compton: ',time_comp,' seconds';
"write(6,*) '========================================================';
"write(6,*); write(6,*);

:END-OF-RUN:;

"close any files that were opened"
IF(IDAT=0) close(data_unit);
IF(IWATCH=4 | IZLAST=2 )[
    close(IOUTGPH);
    close(IOUTGEOM);
]
IF(ISTORE = -1)[ CLOSE(IOUTRN); ]

$BEAM_CLOSE_PHSP;

CALL DATETIME(1);
OUTPUT DATEN,TIMEN;(/' END OF RUN',10X,$DATEN_FORMAT,1X,$TIMEN_FORMAT//);
WRITE(IOUTLIST,400) DATEN,TIMEN;
400  FORMAT(///' END OF RUN',10X,$DATEN_FORMAT,1X,$TIMEN_FORMAT//);

call egs_finish;     " Finish the simulation "

#ifdef HAVE_C_COMPILER;
;
IF( n_parallel > 0 & ~is_finished ) [
    call egs_pjob_finish(n_job);
    IOUTLIST=egs_open_file(IOUTLIST,0,1,'.egslst');
    IF( n_job = 0 ) [
        is_finished = .true.;
        DO ID=1,NDOSE_ZONE[
           AMASS(ID)=0.; "zero these since they get summed again in ISUMRY"
        ]
        CALL ISUMRY;
        call egs_combine_runs(combine_results,'.egsdat');
        NCASET=NCASEO;  IHSTRY=NCASET; NCASE=0;
        CALL SRCOTO(WEIGHT);
        goto :TIME-PLUS-ANAL:;
    ]
]
#endif;

return; end;

"REPLACE {$CHECK-WEIGHTS(#);} WITH {;
"  DO j=npold,np [
"      ;
"      IF( iphat(j) = 1 ) [
"          IF( abs(wt(j)-1) > 0.01 ) [
"              write(25,*) {P1},iphat(j),wt(j);
"              n_weight_warning = n_weight_warning + 1;
"          ]
"      ]
"      ELSE [
"          IF( abs(wt(j)*nbrspl-1) > 0.01 ) [
"              write(25,*) {P1},iphat(j),wt(j);
"              n_weight_warning = n_weight_warning + 1;
"          ]
"      ]
"  ]
"  IF( n_weight_warning > 1000 ) [
"      write(6,*) ' *** too many weight warnings! '; $CALL_EXIT(1);
"  ]
"};

REPLACE {$CHECK-WEIGHTS(#);} WITH {;}

%E     "beamnrc.mortran - start subroutine ausgab                         "
"*******************************************************************************
"
                          SUBROUTINE AUSGAB(IARG);
"                         *****************
"*******************************************************************************
"
"
"     An AUSGAB routine to be used with the radiotherapy accelerator
"     simulation code BEAMnrc.
"
"     This routine:
"        scores fluence and dose
"        writes the phase-space file
"        does latch setting
"        calls watch
"
"     LATCH Setting         There are 3 options:
"
"     LATCH_OPTION = 1:     bits are set in LATCH whenever particle is
"                           in the specified region, but LATCH is NOT inherited
"                           by secondary if created in region being watched.
"
"     LATCH_OPTION = 2:     bit 0 set if brem or annihilation occurs
"                           bits 1 to (28-$LATCH_NUMBER_OF_BITS) set as in
"                           option 1 -i.e. wherever it has beeni but inherited.
"                           rest of bits up to 28 tell which bit_region
"                           created in.
"
"     LATCH_OPTION = 3:     as option 2 but bits only set for regions
"                           where it has interacted.  Note electrons
"                           interact everywhere they are, so 2 vs 3 only
"                           differ regarding photons
"
"     Bit 30 is set if particle is contaminant defined as cross selected plane.
"
"     Fluence scoring:  Outputs the full phase-space of each particle which
"     crosses the scoring planes to units 44,45 and 46. The full phase-space is:
"
"                  (IQ,LATCH,E,X,Y,Z,U,V,W,WT,NPASS).
"
"     When OPEN a file with 'direct access, unformated, fixed record length'
"     The record length for the 7 variables stored in a compressed file is
"     28 bytes.
"     The 7 variables are (LATCH,E,X,Y,U,V,WT)
"     When OPEN a file with 'unformated'
"     The record length for the 7 variables stored in a compressed file is
"     36 bytes.
"
"     Dose scoring:  The user must specify the accelerator geometry as well
"     as the regions which comprise the zones in which the dose is to be scored
"     the geometrical checks for crossing 'geometrical' or 'dose' regions
"     are handled by the subroutine  HOWFAR.  (Adapted from DOSRZ).
;
"     FOR IT = 1      the total dose is scored
"            = 2      the dose less stopped/discarded particles is scored
"            = 3      the dose components are scored with CM CHAMBER
"
"*******************************************************************************
"
$IMPLICIT-NONE;
;COMIN/CMs,EDGE,EPCONT,GEOM,IO_INFO,SCORE,STACK,USEFUL,USER,RANDOM,BREMPR,
MEDIA,MISC,PHOTIN,BOUNDS,RWPHSP,EGS-VARIANCE-REDUCTION,SOURCE,ELECIN,
COMPTON-DATA,EGS-IO/;

$DECLARE-PARTICLE-CONTAINER;

"T>****************************
"T>TYPE DECLARATIONS FOR AUSGAB
"T>****************************
"T>
;INTEGER
   IARG,    "T>argument from EGS (see SLAC-265, section A2.6, p260)
   IPAR,    "T>index for fluence scoring parameter
   IQL,
   LGLE,IBITH30,IBITL30,"T>local variable
   IT,      "T> loop control for score dose
   ISTATUS, "T>used to control the bit filter
   I, II,   "T> loop control indices
   IERR,    "T> needed for BEAMDP1 subroutine
   split_dsb, "T> used for splitting/rotating in dsb
   IRL,     "T>local region number
   lnblnk1, "T>built-in lnblnk function
   IX,IY;   "T>indices for grid scoring"  "Ali:GRID"

$REAL
   FTMP,   "T>total dose with delta transport
   RDIST2, "T>square of distance from z-axis
   WEIGHT, "T>particle weight
   WGHTMA, "T>local variables
   WL,     "T>local direction cosine
   RNNO35,COHFAC,"T> local variables
   ANG_DBS,"T> used in e- splitting in DBS for radially-symmetric redistn"
   ang_dsb,"T> used for particle splitting/rotating for dsb"
   ener,   "T> energy variable used by DBS
   sinthe,costhe,cphi,sphi,rhophi2,yphi2,yphi,xphi2,xphi;
                "above is for annihilation at rest with IBRSPL=2"
$REAL twopi,cos_dsb,sin_dsb,RNDM_BCSE,one;
LOGICAL BTEST;
CHARACTER*8 AUNIT;
CHARACTER*256 phsp_fn; "T> temp. storage for phase space file name
$INTEGER iicm,ip;

$REAL phsp_upper_limit; "T> set to max. no. of particles in phsp file
      "^--- changed to $REAL so one can set it to very large values"
      "     without having to use the -dbl compiler directive to make"
      "     integer*8 the default integer constant -- EMH"
$REAL abrspl,wt_i;
$INTEGER iphat_i;

"this group is only for debugging DBS"
REAL*4 time_array(2),etime;
$INTEGER n_weight_warning;
parameter (one = 1);
data n_weight_warning/0/;
data phsp_upper_limit/$MAX_INT/twopi/6.28318530717958647702561791881237241/;
                      "^--- this controls the max. no. of particles"
                      "     that can be written to a phsp file.  Currently"
                      "     it is set to 2^31-1 (file size up to 64 GBytes)"
                      "     due to the fact that the variable used to write"
                      "     the no. of particles to the header is integer*4."
                      "     If we change this variable to real*4 (4-byte"
                      "     restriction is due to phsp file record length),"
                      "     then this number could be increased but there"
                      "     would be a loss of precision in the no. of"
                      "     particles output to the header."
save n_weight_warning,phsp_upper_limit,twopi;

$INITIALIZE_PHSP_VARIABLES;

"have to do it in 2 steps or else the -1 is lost"
"phsp_upper_limit=2.**32;
"phsp_upper_limit=phsp_upper_limit-1;
"^ Is 2**32-1 or 2**31-1 required ?
"  I thought this is to prevent overflow of 32 bit integers =>
"  must be 2**31-1 (this are signed integers).
"  => changed to the data statement above.  --IK"

"*******************************************************************************
"
"                             STACK OVERFLOW CHECK
"                             ********************

MXNP=MAX(MXNP,NP);"Keep track of how deep stack is -passed in comin score"
IF(NP >  $MXSTACK)[ "Stack as deep as allowed"
    OUTPUT NP,$MXSTACK;
    (' IN AUSGAB, NP=',I3,' >= MAXIMUM STACK ALLOWED=',I3,/1X,79('*')/);
    $CALL_EXIT(1);
]

" Ali:BCSE"
/* MUST be BEFORE the WATCH call so IWATCH output becomes meaningful */

/*
IF(USE_BCSE & IBRSPL < 2)[
   IF(IARG=6)[
      IF(MED(IR(NP))=MED_BCSE)[
         NBRSPL = NBRSPL_ORGNL;
         NBR_SPLIT = NBRSPL;
         ENPOLD_ORGNL = E(NP);
      ]
      ELSE[
         NBRSPL=INT(NBRSPL_ORGNL*BCSE_FACTOR);
         NBR_SPLIT = NBRSPL;
      ]
   ]
   IF(IARG=7 & MED(IR(NP))=MED_BCSE)[
         NBRSPL = INT(NBRSPL_ORGNL*BCSE_FACTOR);
         NBR_SPLIT = NBRSPL;
         $RANDOMSET RNDM_BCSE;
         IF(RNDM_BCSE > 1./BCSE_FACTOR)[E(NPOLD)=ENPOLD_ORGNL;]
         DO I=NPold+1,NP[ WT(I)=WT(I)/BCSE_FACTOR; ]
   ]
]
*/

"IK: modified BCSE"
"Contrary to Ali's approach, we consider NBRSPL to be the maximum amount "
"of splitting. When BCSE is in effect and brems is about to occur, NBRSPL"
"is decreased by bcse_factor and then reset back to its original value   "
"after the brems event => noting to be done in all other cases.          "
IF( use_bcse & ibrspl < 2 ) [
    IF( iarg = 6 & is_bcse_medium(med(ir(np))) ) [
        "Brems about to occur in an enhanced medium "
        abrspl = NBRSPL_ORGNL; abrspl = abrspl/bcse_factor;
        IF( abrspl < 1 ) [
            "$egs_fatal(*,'Brems enhancement factor ',abrspl,"
            "   ' is greater than nbrspl!');"
            $egs_fatal(*,'Brems enhancement factor ',bcse_factor,
               ' is greater than nbrspl ',NBRSPL_ORGNL);
        ]
        nbrspl = abrspl; $RANDOMSET rndm_bcse;
        IF( rndm_bcse < abrspl - nbrspl ) nbrspl = nbrspl + 1;
        nbr_split = nbrspl;
        wt(np) = (wt(np)*nbrspl)/nbrspl_orgnl; enpold_orgnl = e(np);
    ]
    IF( iarg = 7 & is_bcse_medium(med(ir(np))) ) [
        "Brems in an enhanced medium just occured "
        wt(npold) = (wt(npold)*nbrspl_orgnl)/nbrspl;
        nbrspl = nbrspl_orgnl; nbr_split = nbrspl;
        $RANDOMSET rndm_bcse;
        IF( rndm_bcse*bcse_factor > 1 ) e(npold) = enpold_orgnl;
    ]
]


" The following splits eii photons both for UBS & BCSE whether the two       "
" are used individually or in conjunction with each other. Not automatically "
" done in EGS, has to be done by the user.                                   "

IF((IBRSPL=1 | (USE_BCSE & IBRSPL<2)) & IARG=25 & WT(NP)=1.0)[
   NPOLD=NP;
   CALL UNIFORM_PHOTONS_4PI(NBRSPL,E(NP));
]

"Ali: end BCSE alone and BCSE with UBS"

IF(IWATCH >  0) CALL WATCH(IARG,IWATCH); "Signal WATCH routine if active"

"user functions in AUSGAB"
$USER-AUSGAB;

" Check if particle is leaving the transport geometry
" ***************************************************
IRL = IR(NP);  "Local region number"
IF(IRL =  1)[
   IF(IARG ~= 3 & IARG ~=5)[
       "if properly coded we should only get IRL=1 when being discarded"
       "IARG 3 means user has asked for a discard not at a scoring plane"
       "IARG 5 means we are at scoring plane"
       OUTPUT IARG;(//' ********IN AUSGAB:   IRL = 1 with IARG=',I5,/
       'This should not happen'//);
       $CALL_EXIT(1);
   ]
   IF(IARG = 3) [RETURN;] "Outside the geometry, HOWFAR will discard"
   "If IARG = 5, it will return after writinbg phase space"
]

"Ali:REJPLN"
IF(IBRSPL=2 & USE_REJPLN) ["DBS WITH A REJECTION PLANE"
   IF(FLAG_REJPLN=0)["FIRST TIME"
      WRITE(IOUTLIST,901) Z_REJPLN;
901 FORMAT(/'** A rejection plane is being used with DBS **'/
            'Z(cm) from zero reference plane =',F12.2/
      'The following is a list of discarded fat particle data (if any):'/
      'IARG , IQ(NP) , IR(NP) , WT(NP) , Z(NP) , TVSTEP'//);
      FLAG_REJPLN=1;

   ]
   IF (WT(NP)=1 & Z(NP)>=Z_REJPLN & IARG > 5)[
      WRITE(IOUTLIST,902) IARG,IQ(NP),IR(NP),WT(NP),Z(NP),TVSTEP;
902   FORMAT(I3,2X,I3,2X,I3,2X,E10.3,2X,E10.3,2X,E10.3);
      WT(NP)=0;
      FLAG_REJPLN = FLAG_REJPLN+1;
      IF(FLAG_REJPLN>1000)[
         WRITE(IOUTLIST,903);
903      FORMAT('Rejection plane eliminated more than 1000 fat photons. STOP');
         STOP;
      ]
      RETURN;
   ]
]

"*******************************************************************************
"                        cross section enhancement
"*******************************************************************************
IF( use_cs_enhance ) [
    iicm = IR_to_CM(irl);
    IF( cs_enhance(iicm) > 1 ) [
        IF( iarg = 15 | iarg = 17 | iarg = 19 | iarg = 23 ) [
                       "Pair/Compton/Photo/Rayleigh about to occur"
            np = np+1; $CHECK-STACK(np,'ausgab(cs_enhance)');
            $TRANSFER PROPERTIES TO (np) FROM (np-1);
            W(NP)=W(NP-1); U(np)=U(np-1); V(np)=V(np-1);
            E(NP)=E(NP-1);IQ(NP)=IQ(NP-1); wt(np) = wt(np)/cs_enhance(iicm);
            return;
        ]
        ELSE IF( iarg = 16 | iarg = 18 | iarg = 20 | iarg = 24 ) [
                       "Pair/Compton/Photo/Rayleigh just occured."
            $RANDOMSET rnno35;
            IF( rnno35*cs_enhance(iicm) > 1 ) [
                "keep the original photon and trow away scattered photons "
                DO ip=npold,np [
                    IF( iq(ip) = 0 ) [ wt(ip) = 0; ]
                ]
            ]
            ELSE [
                "keep the scattered photons and throw away the original photon"
                wt(npold-1) = 0;
                DO ip=npold,np [
                    IF( iq(ip) = 0 ) [ wt(ip) = wt(ip)*cs_enhance(iicm); ]
                ]
            ]
            return;
        ]
    ]
    IF( cse_return(iarg+1) ) return;
]

"*******************************************************************************
"
"                            FLUENCE SCORING                           ""toc:
"                            ***************
"
" Check if particle crossing scoring plane
" ****************************************
" IAUSFL(6)=1 set in WHERE-AM-I when found we are leaving a CM "
" also set to 1 in HOWFAR or WHERE_AM_I routine of ICM_DBS when splitting"
" electrons with directional bremsstrahlung splitting.  In this latter case,"
" the electron has just reached the user-specified splitting plane within the"
" CM."
IF (IARG =  5) ["Particle step just taken"

   IF(ESPLIT_DBS=1)["fat electron has reached splitting plane"
    IF(W(NP)>0)["electron going forward, split it"
     count_esplit=count_esplit+1;
     IF(IWATCH=1|IWATCH=2)[
       OUTPUT NP,E(NP)-PRM,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),
              U(NP),V(NP),W(NP),LATCH(NP),WT(NP);
             (' Electron',T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
       OUTPUT NBRSPL;(' about to be split ',I10, ' times (DBS).');
       IF(IRAD_DBS=1)[
         OUTPUT;
    (' Split electrons will be symmetrically distributed about beam axis.');
       ]
     ]
     WT(NP)=WT(NP)/FLOAT(NBRSPL); "reduce weight of first electron"
     IPHAT(NP)=1;            "signify that it is now non-fat"
     IF(IRAD_DBS=1)["calculate angular increment for radially-symmetric dist"
        ANG_DBS=2.*3.1415926/FLOAT(NBRSPL);
     ]
     IF(IWATCH=1|IWATCH=2)[
        OUTPUT NP,E(NP)-PRM,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),
              U(NP),V(NP),W(NP),LATCH(NP),WT(NP);
             (T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
     ]
     DO I=1,NBRSPL-1[
        NP=NP+1;
        $TRANSFER PROPERTIES TO (NP) FROM (NP-1);
        W(NP)=W(NP-1);E(NP)=E(NP-1);IQ(NP)=IQ(NP-1);
        IF(IRAD_DBS=1)[
        "have to do rotational transformation of X,Y,U,V"
             X(NP)=X(NP-1)*COS(ANG_DBS)+Y(NP-1)*SIN(ANG_DBS);
             Y(NP)=-X(NP-1)*SIN(ANG_DBS)+Y(NP-1)*COS(ANG_DBS);
             U(NP)=U(NP-1)*COS(ANG_DBS)+V(NP-1)*SIN(ANG_DBS);
             V(NP)=-U(NP-1)*SIN(ANG_DBS)+V(NP-1)*COS(ANG_DBS);
        ]
        ELSE[
             U(NP)=U(NP-1);V(NP)=V(NP-1);
        ]
        IF(IWATCH=1|IWATCH=2)[
           OUTPUT NP,E(NP)-PRM,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),
              U(NP),V(NP),W(NP),LATCH(NP),WT(NP);
             (T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
        ]
     ]
    ]
    ESPLIT_DBS=0; "turn off flag for e- splitting"
   ]"end of electron splitting for DBS"

   IF(ICM=ICMNEW)["IAUSFL(6) was set to 1 by SPLIT_E_DBS, not in"
                  "WHERE_AM_I for leaving CM"
     IAUSFL(6)=0;
     RETURN;
   ]

   IF((IDIRG=-1 & W(NP)>0) | (IDIRG=1 & W(NP)<0))[ "particle has scattered"
     "back on reaching the CM boundary--do not score it"
     IAUSFL(6)=0;
     RETURN;
   ]
   IF(IWATCH =  1 |  IWATCH =  2) [
     IF(ICMNEW ~= 0)[
       OUTPUT ICM,ICMNEW;(' PASSING FROM CM',I3,' TO CM',I3);
     ]
     ELSE [
       OUTPUT ICM;(' PASSING FROM CM',I3,' TO OUTSIDE REGION');
     ]
   ]

   "below check is really redundant with DBS stuff above"
   IF (ICM =  ICMNEW) [ "Should never happen, check anyway"
      OUTPUT ICM,IAUSFL(6),IHSTRY; (' *** WARNING *** ICM=ICMNEW=',I2,
      ' when IAUSFL(6)=',I2, ' for history',I10);
      WRITE (IOUTLIST,
         '('' *** WARNING *** ICM=ICMNEW='',I2,'' when IAUSFL(6)='',I2,
           '' for history'',I10)') ICM,IAUSFL(6),IHSTRY;
      GOTO :FLU_SCORE_END:;
   ]

   "   Find which scoring plane we are to use - ICM_to_SCORE is in COMINN  CMS"
   "                                          value is 0 if not a scoring plane"
   IF (W(NP) >  0.) [ISCORE = ICM_to_SCORE(ICM);]  "Index of scoring plane"
   ELSEIF (ICM =  1)  [ISCORE = 0; "going back out of first CM"]
   ELSE [ISCORE = ICM_to_SCORE(ICM-1);"going back - score with previous CM"]

   " No scoring if particle is NOT crossing scoring plane or if scoring plane
   " index exceeds limit.
   IF (ISCORE = 0) GOTO :FLU_SCORE_END:;

   " Particle statistics (number, energy, and angle wrt z-axis)
   " *******************
   IQL = IQ(NP)+2; "Local variable"
   WL = W(NP); "Local direction cosine, may be >1.  If so, set to 1"
   IF (ABS(WL) >  1.) WL=SIGN(one,WL);
   RDIST2 = Y(NP)**2+X(NP)**2;

   NPFLU(ISCORE)=NPFLU(ISCORE)+1;"new variable to keep track of #"
                                 "of particles crossing scoring plane; used"
                                 "to be NPPHSP, but NPPHSP is only incremented"
                                 "if writing phsp files"

   IF(MZONE_TYPE(ISCORE) = 0)["Find index of radial scoring zones"
       DO ISZ=1,NSC_ZONES(ISCORE) [
          IF (RDIST2 <= RSCORE_ZONE2(ISCORE,ISZ)) [GOTO :FOUND-ZONE-INDEX:;]
       ]
   ]
   ELSEIF(MZONE_TYPE(ISCORE) = 1)["Find index of square scoring zones"
       DO ISZ=1,NSC_ZONES(ISCORE) [
          IF( ABS(X(NP)) <= RSCORE_ZONE(ISCORE,ISZ) & ABS(Y(NP)) <=
                RSCORE_ZONE(ISCORE,ISZ)) [GOTO :FOUND-ZONE-INDEX:;]
       ]
   ]
   ELSEIF(MZONE_TYPE(ISCORE) = 2)["find index of zone in grid"  "Ali:GRID"
       DO IX=1,NX_ZONE(ISCORE)[
          IF(RSCORE_ZONE(ISCORE,IX)<=X(NP) & RSCORE_ZONE(ISCORE,IX+1) > X(NP))
                                      EXIT;
       ]
       DO IY=1,NY_ZONE(ISCORE)[
          IF(RSCORE_ZONE2(ISCORE,IY)<=Y(NP) & RSCORE_ZONE2(ISCORE,IY+1) > Y(NP))
                                      EXIT;
       ]
       IF(IX=NX_ZONE(ISCORE)+1 | IY=NY_ZONE(ISCORE)+1)[
          ISZ=NSC_ZONES(ISCORE)+1;
       ]
       ELSE[
          ISZ=IX+(IY-1)*NX_ZONE(ISCORE);
       ]
   ]
   "on exit, if no exit used, ISZ = NSC_ZONES+1, but this is only"
   "possible if particle coming backwards from a CM with a larger value"
   "of RMAX_CM -  hence set up so last value always available"

   ;:FOUND-ZONE-INDEX:;

   "Fill scoring array..."
   IF (ISZ<=NSC_ZONES(ISCORE)+1) ["Particle crosses through scoring zone"
      IF (NPASS(NP,ISCORE)=0) ["1st crossing of scoring plane" IPAR = 0;]
      ELSE ["multiple crossings of scoring plane" IPAR = 4;]
      WEIGHT = WT(NP);
      IF (WEIGHT < 0.0)[OUTPUT WEIGHT,E(NP);
         (' ***error in AUSGAB - weight=',F12.4,' is NEGATIVE for E=',
            F12.4);
      ]

      "scoring for fluence,etc.  Do not use $SCORE macro because this"
      "coding is more compact.  Also, we only have two SCFLU_LAST/zone,"
      "rather than one/quantity scored, which is what $SCORE assumes."
      IF(IPAR=0 & NHSTRY_LAST=SCFLU_LAST(IQL,ISCORE,ISZ,1) |
         IPAR=4 & NHSTRY_LAST=SCFLU_LAST(IQL,ISCORE,ISZ,2))[
         "same as the last primary history that scored with this IQ,ISCORE,"
         "and ISZ"

         "Number:"
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+1)=SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+1)+
                                          WEIGHT; "Number"

         "Fluence:"
         "In case particle at steep angle, avoid huge weight using max"
         "angle of 85 degrees"
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+2)=SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+2)+
                                          WEIGHT/MAX(0.08716,ABS(WL));

         "Energy fluence:"
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+3)=SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+3)+
                                          WEIGHT*(E(NP)-PRM*ABS(IQ(NP)))/
                                          MAX(0.08716,ABS(WL));
         "Angle:"
         "change to degrees on output"
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+4)=SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+4)+
                                          WEIGHT*ACOS(WL);
      ]
      ELSE[ "not the same as the last primary history that scored with"
            "this IQ, ISCORE and ISZ--update the scoring arrays and"
            "quantities^2"

         "Energy: also score Energy flu.*flu. now for covariance"
         "analysis later"
         SCFLU(IQL,ISCORE,ISZ,IPAR+3)=SCFLU(IQL,ISCORE,ISZ,IPAR+3) +
                                      SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+3);
         SCFLU2(IQL,ISCORE,ISZ,IPAR+3)=SCFLU2(IQL,ISCORE,ISZ,IPAR+3)+
                                       SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+3)**2;
         SCFLU_COV(IQL,ISCORE,ISZ,IPAR/2+1)=SCFLU_COV(IQL,ISCORE,ISZ,IPAR/2+1)+
                                          SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+3)*
                                          SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+2);
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+3)=WEIGHT*(E(NP)-PRM*ABS(IQ(NP)))/
                                          MAX(0.08716,ABS(WL));

         "Angle: also score angle*no. (weighted) now for covariance"
         "analysis later"
         SCFLU(IQL,ISCORE,ISZ,IPAR+4)=SCFLU(IQL,ISCORE,ISZ,IPAR+4) +
                                      SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+4);
         SCFLU2(IQL,ISCORE,ISZ,IPAR+4)=SCFLU2(IQL,ISCORE,ISZ,IPAR+4)+
                                       SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+4)**2;
         SCFLU_COV(IQL,ISCORE,ISZ,IPAR/2+2)=SCFLU_COV(IQL,ISCORE,ISZ,IPAR/2+2)+
                                          SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+4)*
                                          SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+1);
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+4)=WEIGHT*ACOS(WL);

         "Number: do it here because we used SCFLU_TMP from this for mean"
         "angle above"
         SCFLU(IQL,ISCORE,ISZ,IPAR+1)=SCFLU(IQL,ISCORE,ISZ,IPAR+1) +
                                      SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+1);
         SCFLU2(IQL,ISCORE,ISZ,IPAR+1)=SCFLU2(IQL,ISCORE,ISZ,IPAR+1) +
                                      SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+1)**2;
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+1)=WEIGHT;

         "Fluence: do it here because we use SCFLU_TMP from this for mean"
         "energy above"
         SCFLU(IQL,ISCORE,ISZ,IPAR+2)=SCFLU(IQL,ISCORE,ISZ,IPAR+2) +
                                      SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+2);
         SCFLU2(IQL,ISCORE,ISZ,IPAR+2)=SCFLU2(IQL,ISCORE,ISZ,IPAR+2) +
                                      SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+2)**2;
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+2)=WEIGHT/MAX(0.08716,ABS(WL));

         "update SCFLU_LAST"
         IF(IPAR=0)[
           SCFLU_LAST(IQL,ISCORE,ISZ,1)=NHSTRY_LAST;
         ]
         ELSE[
           SCFLU_LAST(IQL,ISCORE,ISZ,2)=NHSTRY_LAST;
         ]
      ]

      "update SCFLU_NUM, no. of particles crossing each scoring zone"
      IF(IPAR=0)[
         SCFLU_NUM(IQL,ISCORE,ISZ,1)=SCFLU_NUM(IQL,ISCORE,ISZ,1)+1;
      ]
      ELSE[
         SCFLU_NUM(IQL,ISCORE,ISZ,2)=SCFLU_NUM(IQL,ISCORE,ISZ,2)+1;
      ]

      "determine if this is > max weight or < min weight"
      IF(WEIGHT<MINWEIGHT)[
             MINWEIGHT=WEIGHT;
      ]
      ELSEIF(WEIGHT>MAXWEIGHT)[
             MAXWEIGHT=WEIGHT;
      ]


   ]

   " Full phase-space scoring
   " ************************

   IF (IO_OPT =  0)|((IO_OPT =  3)&(IHSTRY <= 100000))|(IO_OPT=4)[
                                 "phase-space output"
     NPPHSP(ISCORE)=NPPHSP(ISCORE)+1;"increment # of particles in file"
     IF((E(NP)-PRM*ABS(IQ(NP)))>EKMAXPHSP(ISCORE))[
            EKMAXPHSP(ISCORE)=E(NP)-PRM*ABS(IQ(NP));
     ]
     IF(IQ(NP)=-1)[
        IF((E(NP)-PRM)<EKMINPHSPE(ISCORE))[
              EKMINPHSPE(ISCORE)=E(NP)-PRM;
        ]
     ]
     ELSEIF(IQ(NP)=0)[
        NPHOTPHSP(ISCORE)=NPHOTPHSP(ISCORE)+1;
     ]
     IF(PHSP_OUTDIR~=' ')[
      "assume the user wants definition of output directory in the"
      "input file to overwrite that in beamnrc_user_macros.mortran"
       phsp_fn=$cstring(PHSP_OUTDIR) // $file_sep // $cstring(output_file);
     ]
     ELSE[
       phsp_fn=$DIRECTORY-FOR-PHSP // $file_sep // $cstring(output_file);
     ]
     $BEAM_WRITE_PHSP;"this is different when using BEAM as a source"
   ] "end of write phase space option"


    ;$BEAMMODEL_DATA_ANALYSIS;
    "data analysis for beam models - default is null, i.e. ;"

   "Increment NPASS, the number of times this particle or its ancestors have"
   "crossed scoring plane ISCORE"
   NPASS(NP,ISCORE) = NPASS(NP,ISCORE)+1;

   :FLU_SCORE_END:

   " Do the particle splitting if called for by ICM_SPLIT"
   IF(ICM_SPLIT>0)["particle splitting is to be done"
    IF(ICMNEW=ICM_SPLIT & W(NP)>0. & NSPLIT(NP)=0)[
"only split on entering CM from top and if it has not been split before"
     NSPLIT(NP)=NSPLIT(NP)+1;"descendants will not be split again"
     IF(IQ(NP)=0 & NSPLIT_PHOT>1)[
        WT(NP)=WT(NP)/FLOAT(NSPLIT_PHOT);
        IF(IWATCH=1 | IWATCH=2)[
          OUTPUT NSPLIT_PHOT;
 (' SPLITTING PHOTON INTO ',I4,' PHOTONS EACH WITH THE FOLLOWING PROPERTIES:');
          OUTPUT NP,NP+NSPLIT_PHOT-1,E(NP),IQ(NP),IR(NP),X(NP),Y(NP),
                 Z(NP),U(NP),V(NP),W(NP),LATCH(NP),WT(NP);
          (' RESULTING PHOTONS',T29,':',I5,' -',I5,F9.3,2I4,3F8.3,3F7.3,
                                I10,1PE10.3);
        ]
        DO I=1,NSPLIT_PHOT-1[
          NP=NP+1;
          $TRANSFER PROPERTIES TO (NP) FROM (NP-1);
          U(NP)=U(NP-1);V(NP)=V(NP-1);W(NP)=W(NP-1);
          E(NP)=E(NP-1);IQ(NP)=IQ(NP-1);
        ]
     ]
     "ELSEIF(IQ(NP)=-1 & NSPLIT_ELEC>1)["
        "Why splitting only electrons???  --IK, July 2005"
     ELSEIF(IABS(IQ(NP))=1 & NSPLIT_ELEC>1)[
        WT(NP)=WT(NP)/FLOAT(NSPLIT_ELEC);
        IF(IWATCH=1 | IWATCH=2)[
          OUTPUT NSPLIT_ELEC;
(' SPLITTING ELECTRON INTO ',I4,' ELECTRONS EACH WITH THE',
 ' FOLLOWING PROPERTIES:');
          OUTPUT NP,NP+NSPLIT_ELEC-1,E(NP)-PRM,IQ(NP),IR(NP),
                 X(NP),Y(NP),Z(NP),U(NP),V(NP),W(NP),LATCH(NP),WT(NP);
          (' RESULTING ELECTRONS',T29,':',I5,' -',I5,F9.3,2I4,3F8.3,3F7.3,
                                        I10,1PE10.3);
        ]
        DO I=1,NSPLIT_ELEC-1[
          NP=NP+1;
          $TRANSFER PROPERTIES TO (NP) FROM (NP-1);
          U(NP)=U(NP-1);V(NP)=V(NP-1);W(NP)=W(NP-1);
          E(NP)=E(NP-1);IQ(NP)=IQ(NP-1);
        ]
     ]
    ]
   ]

   "directional source biasing done here"
   IF(i_dsb=1 & dsb_delta>0 & icmnew=splitcm_dsb & w(np)>0. & iphat(np)>1 &
     iphat(np)<nbrspl)[
     "split and rotate particle about this plane for dsb"
     WT(NP)=WT(NP)/FLOAT(iphat(np)); "reduce weight of first electron"
     ANG_dsb=twopi/FLOAT(iphat(np));
     cos_dsb = cos(ang_dsb); sin_dsb = sin(ang_dsb);
     split_dsb=iphat(np); "store this because we reset it to 1"
     iphat(np)=1;
     DO I=1,split_dsb-1[
        NP=NP+1;
        $TRANSFER PROPERTIES TO (NP) FROM (NP-1);
        W(NP)=W(NP-1);E(NP)=E(NP-1);IQ(NP)=IQ(NP-1);
        "have to do rotational transformation of X,Y,U,V"
        X(NP)=X(NP-1)*cos_dsb+Y(NP-1)*sin_dsb;
        Y(NP)=-X(NP-1)*sin_dsb+Y(NP-1)*cos_dsb;
        U(NP)=U(NP-1)*cos_dsb+V(NP-1)*sin_dsb;
        V(NP)=-U(NP-1)*sin_dsb+V(NP-1)*cos_dsb;
     ]
   ]

   IF( IQ(NP)=0 & IFORCE=1 )["photon interaction forcing is used"

      IF(((ICMNEW=NFCMIN & W(NP)>0) | (ICMNEW=NFCMAX & W(NP)<0))
        & NP_INC(NP)=0 )[
      "particle is entering CM where it could be forced to interact"

         IF( NFTIME(NP)+1<=NFMAX)[
         "We now test against NFTIME(NP)+1, the projection of what NFTIME(NP)"
         "would be if there was in interaction.  Used to also contain a test"
         "for NFTIME+1>=NFMIN, but the NFMIN option was cut since it is"
         "difficult to implement and the usefulness of being able to"
         "set NFMIN~=1 is questionable.  Thus, NFMIN is now always treated"
         "as 1."

            NFTIME(NP)=NFTIME(NP)+1;
                             "increment the the number of interactions in the"
                             "forcing CMs"
            $RANDOMSET RNNO35;IF(RNNO35 = 0.0)RNNO35=1.E-30;
            ;$SELECT-PHOTON-MFP-FOR-FORCING(DPMFP);
            "re-calculate the MFP of this photon"
            "a new photon will be created which carries the remaining weight"
         ]
      ]
   ]
   IAUSFL(6) = 0; "Reset to prevent call to AUSGAB for fluence scoring until"
                  "scoring plane is crossed"
   RETURN; "only for IARG=5 case"
] "End of fluence scoring branch ie IARG=5 block"

"******************************************************************************
"
"         SETTINGS FOR BREMSSTRAHLUNG SPLITTING
"         *************************************
"
"
IF(IBRSPL=1 & IRRLTT=0)["uniform bremsstrahlung splitting without Russ. Roul."
  IF(IARG=6 | IARG=12 | IARG=28)[
"sets nbr_split=1 before bremsstrahlung and annihilation events if this is a"
"secondary charged particle and nbr_split=NBRSPL if this is a primary"
"charged particle--prevents splitting of higher-order bremsstrahlung and"
"annihilation photons"
    IF($BTEST(LATCH(NP),0))[
                 "this is a secondary particle, do not split"
        nbr_split=1;
    ]
    ELSE["Note primary annihilation photons will also be split by NBRSPL"
          "In the case of an incoming e+ beam"
        nbr_split=NBRSPL;
    ]
  ]
]

ELSEIF(IBRSPL=2) ["directional bremsstrahlung splitting"

   IF( iarg > 5 & z(np) > ssd ) [ nbr_split = 1; GOTO :ZLAST_AND_LATCH:; ]


   IF(i_dsb=1 & z(np)<Z_min_CM(splitcm_dsb) & dsb_nbin>1)[do_dsb=1;]
   ELSE[do_dsb=0;]

   IF(iarg = 6 | iarg = 12 | iarg = 28 ) [

       "bremsstrahlung or annihilation about to occur"

       "check below commented out because we can now have non-fat e-"
       "with the e- splitting scheme"
       "IF( iphat(np) ~= 1 ) ["
       "    write(6,*) ' A non-fat charged particle ???'; "
       "    write(6,*) ' position: ',x(np),y(np),z(np);"
       "    write(6,*) ' direction: ',u(np),v(np),w(np);"
       "    write(6,*) ' energy and weight: ',e(np),wt(np);"
       "    $CALL_EXIT(1);"
       "]"

       IF(LATCH_OPTION=2 | LATCH_OPTION=3)[
         "LATCHIN applies to primaries"
         LATCHIN=LATCH(np);
         "prepare LATCHOUT to apply to secondaries"
         IF($BTEST(LATCHIN,30))[IBITH30=1073741824;
                LATCHOUT=LATCHIN-IBITH30;]
         ELSE[IBITH30=0;]
         LATCHOUT = $IBSET(LATCHIN,0);
         "bit 0 is used to mark the photon"
         IF(LATCHIN >= LNOB29)["check whether the parent is a secondary."
             LATCHOUT=LATCHOUT+
                   (IREGION_TO_BIT(IRL)- INT(LATCHOUT/LNOB29))*LNOB29;
         ]
         ELSE["The parent is a primary."
             LATCHOUT =  LATCHOUT+IREGION_TO_BIT(IRL)*LNOB29;
         ]
         LATCHOUT=LATCHOUT+IBITH30;
         LATCH(np)=LATCHOUT; "allows transfering of latch value to secondaries"
                             "during interaction.  Just have to remember to"
                             "reset LATCH of electron after brems"
       ]
       IF(IZLAST=1)ZLAST(np)=Z(np); "will get transferred during interaction"

       nbr_split = NBRSPL;
       IF( iarg = 6 )  [

           IF( iphat(np) > 1 ) [
               "IK: modified BCSE"
               IF( use_bcse & is_bcse_medium(med(ir(np))) ) [
                   " reduce nbrspl by the current BCSE factor          "
                   " which was computed in ELECTR (in $CALCULATE-SIGF) "
                   " depending on the particle energy                  "
                   abrspl = nbrspl_orgnl; abrspl = abrspl/bcse_factor;
                   IF( abrspl < 1 ) [
                       $egs_fatal(*,'Brems enhancement factor ',abrspl,
                         ' is greater than NBRSPL!');
                   ]
                   $RANDOMSET rndm_bcse; nbrspl = abrspl;
                   IF( rndm_bcse < abrspl - nbrspl ) nbrspl = nbrspl + 1;
                   nbr_split = nbrspl;
                   " Remember old energy and weight "
                   enpold_orgnl = e(np); wt_i = wt(np);
                   " Adjust electron weight so that resulting brems photons "
                   " have the proper weight                                 "
                   wt(np) = (wt_i*nbrspl)/nbrspl_orgnl;
               ]
               ELSE [
                   nbrspl = iphat(np); nbr_split = nbrspl;
               ]
               " Remember old fatness and set electron fatness to 1 "
               iphat_i = iphat(np); iphat(np) = 1;
               count_nbrem = count_nbrem + nbrspl;
               IF( ibrdst = 0 ) [ call do_smart_brems; ]
               ELSE [
                   call brems;
                   call kill_the_photons(npold+1,0);
                   count_kill_brem = count_kill_brem + count_kill_tmp;
               ]
               " Set electron fatness to its old value "
               iphat(npold) = iphat_i;
               IF( use_bcse & is_bcse_medium(med(ir(np))) ) [
                   " Reset electron weight to its initial value "
                   wt(npold) = wt_i;
                   " Now decide if we should accept this interaction "
                   $RANDOMSET rndm_bcse;
                   IF( rndm_bcse*bcse_factor > 1 ) [
                       " No. Set electron energy to its initial value and "
                       " kill all fat photons                             "
                       e(npold) = enpold_orgnl;
                       wt_i = 0;
                   ]
                   DO ip=npold+1,np [
                       IF( iphat(ip) > 1 ) [
                           wt(ip) = wt_i; iphat(ip) = iphat_i;
                       ]
                   ]
                   " And finally reset nbrspl back to its maximum value "
                   nbrspl = nbrspl_orgnl; nbr_split = nbrspl;
               ]
           ]
           ELSE [
               " Thin electron -> do single brems but kill photons not going "
               " towards the field "
               count_nbrem = count_nbrem + 1;
               nbr_split=1;
               call brems;
               call kill_the_photons(npold+1,0);
               count_kill_brem = count_kill_brem + count_kill_tmp;
           ]
           $CHECK-WEIGHTS('After brems ');
           "reset LATCH of electron"
           IF(LATCH_OPTION=2 | LATCH_OPTION=3)LATCH(npold)=LATCHIN;
       ]

       ELSE IF( iarg = 12 ) [
           IF( iphat(np) > 1 ) [
               nbr_split = iphat(np); iphat(np) = 1;
               count_nannih = count_nannih + 2*nbr_split;
           ]
           ELSE [
               count_nannih = count_nannih + 2; nbr_split=1;
           ]
           call annih;
           call kill_the_photons(npold,0);
           count_kill_annih = count_kill_annih + count_kill_tmp;
           $CHECK-WEIGHTS('After annih ');
       ]

       ELSE [
           IF(iphat(np) > 1) [
               count_nannih = count_nannih + 2*iphat(np);
               npold = np;
               call uniform_photons(2*iphat(np),rm);
           ]
           ELSE[ "non-fat, do not use uniform_photons for this"
               count_nannih = count_nannih + 2;
               npold = np;
               "Pick random direction for first gamma
               $RANDOMSET costhe; costhe = 2*costhe-1;
               sinthe = sqrt(max(0.0,(1-costhe)*(1+costhe)));
               $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               e(np) = prm; iq(np) = 0;
               $TRANSFER PROPERTIES TO (np) FROM (npold);
               u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = costhe;
               np = np+1;
               $CHECK-STACK(np,'ANNIH_AT_REST');
               e(np) = prm; iq(np) = 0;
               $TRANSFER PROPERTIES TO (np) FROM (npold);
               u(np) = -u(np-1); v(np) = -v(np-1); w(np) = -w(np-1);
               call kill_the_photons(npold,0);
               count_kill_annih = count_kill_annih + count_kill_tmp;
           ]
           $CHECK-WEIGHTS('After annih at rest ');
       ]
       IF(IZLAST=2)[
         DO I=NPold,NP[
           XLAST(I)=X(I);
           YLAST(I)=Y(I);
           ZLAST(I)=Z(I);
         ]
       ]
       " now put a zero weight particle on top of the stack thus forcing "
       " a return to shower. "
       np=np+1;
       $CHECK-STACK(np,'ausgab(after brems or annih)');
       wt(np) = 0; return;
   ]

   IF( iarg = 15 | iarg = 17 | iarg = 19 | iarg = 23 ) [

       "Pair/Compton/Photo/Rayleigh about to occur

       /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
       /*               wt(np) = 0; return;                     */
       /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

       IF( iphat(np) < NBRSPL & (ICM_DBS=0 | Z(NP)<=ZRR_DBS) &
           (rhor(ir(np))>=1.2e-2 | do_dsb=1)) [
                                  " non-fat photon which is not in gas"
                                  " and is above RR plane (if electron"
                                  " splitting is on)"
         "IF( iarg ~= 17 | ibcmp(irl) = 0 ) [ "
         IF( (iarg ~= 17 | ibcmp(irl) = 0) & iarg ~= 23 ) [
             "russian roulette it"
             $RANDOMSET rnno35;
             IF( rnno35*nbrspl > iphat(np) ) [ wt(np) = 0; return; ]
             wt(np) = wt(np)*float(nbrspl)/float(iphat(np));
             iphat(np)=nbrspl;
         ]
         "We don't kill the photon before bound compton"
         "because the interaction may get rejected => we get a fat "
         "photon going towards the field."
       ]

       "at this point, the photon is fat, or it is non-fat and about to"
       "interact in gas or is below the RR plane (if e- splitting on)"

      " IF(WT(NP)<1)[
      "   write(*,*)' iphat,wt,iarg ',IPHAT(NP),WT(NP),iarg;
      " ]

       IF(LATCH_OPTION=2 | LATCH_OPTION=3)[
         LATCHOLD=LATCH(np);"retain in case compton rejected"
         "prepare LATCHIN to apply to primaries"
         LATCHIN=LATCH(np);
         IF(LATCH_OPTION=3)
                LATCHIN=$IBSET(LATCHIN,IREGION_TO_BIT(IRL));
         "prepare LATCHOUT to apply to secondaries"
         IF($BTEST(LATCHIN,30))[IBITH30=1073741824;
                LATCHOUT=LATCHIN-IBITH30;]
         ELSE[IBITH30=0;]
         IF(LATCHIN >= LNOB29)["check whether the parent is a secondary."
             LATCHOUT=LATCHOUT+
                   (IREGION_TO_BIT(IRL)- INT(LATCHOUT/LNOB29))*LNOB29;
         ]
         ELSE["The parent is a primary."
             LATCHOUT =  LATCHOUT+IREGION_TO_BIT(IRL)*LNOB29;
         ]
         LATCHOUT=LATCHOUT+IBITH30;
       ]
       IF(IZLAST=1)ZLASTOLD=ZLAST(np);"retain in case compt rejected"

       IF( iarg = 15 | iarg = 19 ) ["pair or photo about to occur"
         IF(LATCH_OPTION=2 | LATCH_OPTION=3)LATCH(np)=LATCHOUT;
             "photon disappears so we can just pass on LATCHOUT"
         IF(IZLAST=1)ZLAST(np)=Z(np); "will get transferred during interaction"
         IF(iphat(np)=nbrspl & ICM_DBS>0 & Z(NP)>ZRR_DBS)[
                                    "split interaction"
           IF(iarg=15)[ count_npair= count_npair+nbrspl; call do_pair;]
           ELSE[ count_nphoto= count_nphoto+nbrspl; call do_photo;]
           IF(IZLAST=2)[
             DO I=NPold,NP[
               ZLAST(I)=Z(I);
               XLAST(I)=X(I);
               YLAST(I)=Y(I);
             ]
           ]
         ]
         ELSE["no splitting, let electr take care of interaction"
           nbr_split = 1; return;
         ]
       ]
       ELSE IF( iarg = 17 ) ["compton about to occur, always split it"
         time_start = etime(time_array);
         IF(iphat(np)=nbrspl)["fat, should be split"
           count_ncomp = count_ncomp + nbrspl;
           IF( ibcmp(ir(np)) = 1 | (ICM_DBS>0 & Z(NP)>ZRR_DBS)) [
              "cannot do smart_compton below RR plane because it produces"
              "a fat electron"
               call do_compton;
               count_kill_comp = count_kill_comp + count_kill_tmp;
           ] ELSE
"at little/no cost to accuracy"[
               IF(LATCH_OPTION=3)LATCH(np)=LATCHIN;"pass on LATCHIN"
               IF(IZLAST=1)zlast(np)=z(np);
               call do_smart_compton;
               "single e- in npold"
               IF(LATCH_OPTION=2 | LATCH_OPTION=3) LATCH(npold)= LATCHOUT;
               IF(IZLAST=2)[
                 DO I=NPold,NP[
                   ZLAST(I)=Z(I);
                   XLAST(I)=X(I);
                   YLAST(I)=Y(I);
                 ]
               ]
           ]
         ]
         ELSE["non-fat, play Russian Roulette with photon"
           count_ncomp = count_ncomp + 1;
           IF(LATCH_OPTION=2 | LATCH_OPTION=3)LATCH(np)= LATCHOUT;
           "easier to pass on latch of secondaries by transferring"
           IF(IZLAST=1)zlast(np)=z(np);
           call compt;
           IF(LATCH_OPTION=2 | LATCH_OPTION=3)[
             IF(np>npold)[LATCH(npold)=LATCHIN;]
             ELSE[LATCH(npold)=LATCHOLD;]"interaction rejected"
           ]
           IF(IZLAST=1 & np=npold)zlast(npold)=zlastold;"interaction rejected"
           call kill_the_photons(npold,0);
           count_kill_comp = count_kill_comp + count_kill_tmp;
           IF(IZLAST=2)[
              DO I=NPold,NP[
                ZLAST(I)=Z(I);
                XLAST(I)=X(I);
                YLAST(I)=Y(I);
              ]
           ]
         ]
         time_end = etime(time_array);
         time_comp = time_comp + time_end - time_start;
         $CHECK-WEIGHTS('After compton ');
       ]
       ELSE [
           IF(LATCH_OPTION=3) LATCH(np)=LATCHIN;
           IF(IZLAST=1)zlast(np)=z(np);
           IF(iphat(np)=1)["thin photon, just one interaction"
              call do_rayleigh(1);
           ]
           ELSE[
              call do_rayleigh(nbrspl);
           ]
           $CHECK-WEIGHTS('After rayleigh');
           IF(IZLAST=2)[
             DO I=npold,np[
               zlast(I)=z(I);
               xlast(I)=x(I);
               ylast(I)=y(I);
             ]
           ]
       ]
       IF( iarg = 16 ) [ $CHECK-WEIGHTS('After pair '); ]
       IF( iarg = 20 ) [ $CHECK-WEIGHTS('After photo '); ]

       " now put a zero weight particle on top of the stack thus forcing "
       " a return to shower. "
       np=np+1;
       $CHECK-STACK(np,'ausgab(after compton or rayleigh)');
       wt(np) = 0; return;

   ]

   IF( iarg = 25 ) [ "a fluorescent photon has just been put on the stack "
                     "split it"
       IF( iphat(np) = nbrspl ) [
           ener = e(np);
           npold=np;
           call uniform_photons(nbrspl,ener);
           $CHECK-WEIGHTS('After fluorescence ');
       ]
       ELSE["kill the thin photon if it is not aimed into the field"
           call kill_the_photons(np,0);
       ]
       return;
   ]

]
IF(IARG=6) NUM_BREM=NUM_BREM+nbr_split;

"macro below sets prob_RR, the probability that a charged particle will"
"survive Russian Roulette, when seletive bremsstrahlung is on"
:ZLAST_AND_LATCH:;
"******************************************************************************
"
"         LAST INTERACTION SITE SCORING (FOR PHOTONS AND ELECTRONS) ""toc:
"         *********************************************************
"
"The last interaction site is scored as follows: For photons, whenever there
"is an interaction ZLAST is replaced with the Z, for electrons ZLAST is
"identified as the Z of it's creation by photon and this value is passed on to
"any other electron with which the original electron discreetly interacts.

IF(IZLAST = 1)[
  IF(IARG = 7)[ "brems just occurred -- not sure if this dealt with splitting"
                "before"
    DO I=NPold,NP[
      ZLAST(I)=Z(I); "set Z of creation of photon and interaction of e-"
    ]
  ]
  ELSEIF(IARG = 18)["compton just occurred"
    IF(NP > NPold | i_survived_rr > 0)["need this in case interaction rejected"
        DO I=NPold,NP[
          ZLAST(I)=Z(I); "set Z of creation of e- and interaction of phot."
        ]
    ]
  ]
  ELSEIF(IARG = 24)[ "IARG = 24: a coherent interaction has just occurred"
    ZLAST(NP) = Z(NP); " In this case there is one and only one photon"
  ]
  ELSEIF(IARG = 13 | IARG = 14)[
     "IARG = 13: returned to ELECTR after a call to ANNIH
     "IARG = 14: a positron has annihilated at rest
     DO I=NPold,NP[
         ZLAST(I)=Z(I); "set Z of creation of photons"
     ]
  ]
  ELSEIF(IARG = 20)[
  "IARG = 20: returned to PHOTON after a call to PHOTO was made (if NP ~= 0)"
      IF(NP>NPold | i_survived_rr > 0 | IQ(NPold)=-1)[
        DO I=NPold,NP[
            ZLAST(I)=Z(I); "set Z of creation of electrons and interaction of"
                           "photon"
        ]
      ]
  ]
  ELSEIF(IARG = 16)[ "IARG = 16: after a call to PAIR was made"
      DO I=NPold,NP[
           ZLAST(I)=Z(I); "mark Z of creation of e- and e+"
      ]
  ]
]" END IF FOR IZLAST=1"

ELSEIF(IZLAST = 2)["store x and y for display too"
  IF(IARG = 7)[ "brems just occurred -- not sure if this dealt with splitting"
                "before"
    DO I=NPold,NP[
      XLAST(I)=X(I);
      YLAST(I)=Y(I);
      ZLAST(I)=Z(I);
    ]
  ]
  ELSEIF(IARG = 18)["compton just occurred"
    IF(NP > NPold | i_survived_rr > 0)[
        DO I=NPold,NP[
          XLAST(I)=X(I);
          YLAST(I)=Y(I);
          ZLAST(I)=Z(I);
        ]
    ]
  ]
  ELSEIF(IARG = 24)[ "IARG = 24: a coherent interaction has just occurred"
    ZLAST(NP) = Z(NP); " In this case there is one and only one photon"
    YLAST(NP) = Y(NP); XLAST(NP) = X(NP);
  ]
  ELSEIF(IARG = 13 | IARG = 14)[
     "IARG = 13: returned to ELECTR after a call to ANNIH
     "IARG = 14: a positron has annihilated at rest
     DO I=NPold,NP[
         XLAST(I)=X(I);
         YLAST(I)=Y(I);
         ZLAST(I)=Z(I);
     ]
  ]
  ELSEIF(IARG = 20)[
  "IARG = 20: returned to PHOTON after a call to PHOTO was made (if NP ~= 0)"
      IF(NP>NPold | i_survived_rr > 0 | IQ(NPold)=-1)[
        DO I=NPold,NP[
            XLAST(I)=X(I);
            YLAST(I)=Y(I);
            ZLAST(I)=Z(I);
        ]
      ]
  ]
  ELSEIF(IARG = 16)[ "IARG = 16: after a call to PAIR was made"
      DO I=NPold,NP[
           XLAST(I)=X(I);
           YLAST(I)=Y(I);
           ZLAST(I)=Z(I);
      ]
  ]
]" END IF FOR IZLAST = 2"

"*******************************************************************************

"*******************************************************************************
"
"                               LATCH SETTING                          ""toc:
"                               *************
" for detailed implementation see beamnrc documentation:
" BEAMnrc code Technical Notes.

"On each step, if asked, an appropriate bit in latch is"
"set to indicate particle has been in this region"

IF(LATCH_OPTION  < 3 | (LATCH_OPTION  = 3 & IQ(NP) ~= 0) )[
   IF((IARG = 0) & (IREGION_TO_BIT(IRL) ~= 0) ) [
      LATCH(NP) = $IBSET(LATCH(NP),IREGION_TO_BIT(IRL));
   ]
]
"$IBSET is defined in beamnrc_user_macros.mortran"

"If LATCH is not to be inherited, the following arranges this in a restricted"
" sense - if a secondary is created in one of the regions we are watching"
"         then the new latch does not carry the info about the previous value"
IF(LATCH_OPTION  = 1 & IREGION_TO_BIT(IRL) ~= 0)[
   IF(IARG = 7)[      " Brem just taken"
      DO I=NPold+1,NP[ "photons at the top of the stack"
       LATCH(I) = $IBSET(0,IREGION_TO_BIT(IRL));
      ]
   ]
   ELSEIF(IARG = 9)[  " Moller just occurred, secondary is on top of stack"
      LATCH(NP) = $IBSET(0,IREGION_TO_BIT(IRL));
   ]
   ELSEIF(IARG = 11)[ " Bhabha just occurred - positron doesn't inherit"
      IF(IQ(NP) = 1)[ LATCH(NP-1) = $IBSET(0,IREGION_TO_BIT(IRL)); ]
      ELSE[  LATCH(NP) = $IBSET(0,IREGION_TO_BIT(IRL)); ]
   ]
   ELSEIF(IARG = 13 | IARG = 14 )[  " Annih just occurred"
      DO I=NPold,NP[
        LATCH(I) = $IBSET(0,IREGION_TO_BIT(IRL));
      ]
   ]
   ELSEIF(IARG = 16)[ " Pair production just occurred reset both"
      DO I=NPold,NP[
        LATCH(I) = $IBSET(0,IREGION_TO_BIT(IRL));
      ]
   ]
   ELSEIF(IARG = 18)[ " Comp just occurred reset all electrons"
      DO I=NPold+1,NP[ "original photon is NPold"
           LATCH(I) = $IBSET(0,IREGION_TO_BIT(IRL));
      ]
   ]
   ELSEIF(IARG = 20)[ " Photo just occurred--treat all photons as created"
      IF(NP>NPold | i_survived_rr > 0 | IQ(NPold)=-1)[
        DO I=NPold,NP[
           LATCH(I) = $IBSET(0,IREGION_TO_BIT(IRL));
        ]
      ]
   ]
]"end of LATCH_OPTION = 1 block"

"*******************************************************************************
"
"                               LATCH SETTING for LATCH_OPTION 2       ""toc:
"                               *************
"The following is for LATCH_OPTION =2. In this case, both the primaries' LATCH
"values are passed on to the secondaries and the particle origins are recorded.
"we use bits 1 to (28-$LATCH_NUMBER_OF_BITS) for region bit set, bit 0
"is used to record whether a brem is involved in this particle history, and
"bits (29-$LATCH_NUMBER_OF_BITS) - 28 to record the region # where the particle
"is created. This works for 2**($LATCH_NUMBER_OF_BITS) geometrical regions.
"Bits 29-31 are reserved for rw-ph-sp. The number of bits used for particle
"origin can be increased by changing the value of $LATCH_NUMBER_OF_BITS
"in the beginning of this file. For example, if 7 bits are used
"we can have altogether 128 geometrical regions in the simulation geometry.
"Note that for a secondary we record its origin according to where it is created
"no matter its parent is a primary or a secondary.
"Recall bits 1-23 are set above for LATCH(NP) on IARG=0 steps
"Also, recall that in this piece of code LATCH(NP-1)=LATCH(NP) if they
"      are both just created by same parent
"
"Prior to SID 2.31 there was a bug which caused LATCH(0) to be accessed
"for IWATCH on or for Coherent scatter on.  Bug Pointed out by Jeff Chen and
"Joanne Moseley of London Regional Cancer Center.
"

ELSEIF(LATCH_OPTION  = 2 & IARG > 6)[
  " LNOB29 = 2**(29-$LATCH_NUMBER_OF_BITS). We use this constant to shift"
  " IREGION_TO_BIT(IRL) by (29-$LATCH_NUMBER_OF_BITS) bits in order to   "
  "record it using bits from (28-$LATCH_NUMBER_OF_BITS) to 28.           "

"Define some macros for saving bit 30 for contaminant dose calculations"
"       Note 1073741824=2**30
REPLACE {$SAVE_LATCH_BIT30NP;} WITH {
  ;IF($BTEST(LATCH(NP),30))[IBITH30=1073741824; LATCH(NP)=LATCH(NP)-IBITH30;]
  ELSE[IBITH30=0;]
}
REPLACE {$SAVE_LATCH_BIT30NP-1;} WITH {
  ;IF($BTEST(LATCH(NP-1),30))[
     IBITL30=1073741824; LATCH(NP-1)=LATCH(NP-1)-IBITL30;
  ]
  ELSE[IBITL30=0;]
}
REPLACE {$SAVE_LATCH_BIT30I;} WITH {
  ;IF($BTEST(LATCH(I),30))[IBITH30=1073741824; LATCH(I)=LATCH(I)-IBITH30;]
  ELSE[IBITH30=0;]
}
REPLACE {$RESTORE_LATCH_BIT30NP;} WITH {LATCH(NP)=LATCH(NP)+IBITH30;}
REPLACE {$RESTORE_LATCH_BIT30NP-1;} WITH {LATCH(NP-1)=LATCH(NP-1)+IBITL30;}
REPLACE {$RESTORE_LATCH_BIT30I;} WITH {LATCH(I)=LATCH(I)+IBITH30;}


  "Moller is the most probable interaction, check it first"
  ;IF(IARG = 9)[ " Moller just occurred, secondary is on top of stack"
    $SAVE_LATCH_BIT30NP;
    IF(LATCH(NP) >= LNOB29)["check whether the parent is a secondary. At "
      "this stage the resultant particle has the same LATCH as the parent."
      LATCH(NP) = LATCH(NP)+(IREGION_TO_BIT(IRL)-
                  INT(LATCH(NP)/LNOB29))*LNOB29;
    ]
    ELSE["the parent is a primary"
      LATCH(NP) = LATCH(NP)+IREGION_TO_BIT(IRL)*LNOB29;
    ]
  $RESTORE_LATCH_BIT30NP;
  ]

  ELSEIF(IARG = 18)[ " Comp just occurred, record the electron"
    DO I=NPold+1,NP[
      $SAVE_LATCH_BIT30I;
      IF(LATCH(I) >= LNOB29)["check whether the parent photon is a secondary. "
         LATCH(I) = LATCH(I)+(IREGION_TO_BIT(IRL)-
                       INT(LATCH(I)/LNOB29))*LNOB29;
      ]
      ELSE["photon is a primary"
         LATCH(I) = LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30I;
    ]
  ]"end of Compton block"

  ELSEIF(IARG = 7)[ " Brem just occurred, record the photon origin"
    DO I=NPold,NP["photons start at NPold+1"
     IF(IQ(I)=0)[
      $SAVE_LATCH_BIT30I;
      LATCH(I) = $IBSET(LATCH(I),0);
      "bit 0 is used to mark the brem photon"
      IF(LATCH(I) >= LNOB29)["check whether the parent e- is a secondary. "
        LATCH(I) =LATCH(I)+(IREGION_TO_BIT(IRL)-
        INT(LATCH(I)/LNOB29))*LNOB29;
      ]
      ELSE["the parent is a primary"
        LATCH(I) = LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30I;
     ]
    ]
  ]"end of bremsstrahlung block"

  ELSEIF(IARG = 16)[ " Pair production just occurred, record both"
    "at this stage both particle have the same LATCH.               "
    DO I=NPold,NP[
      $SAVE_LATCH_BIT30I; IBITL30 = IBITH30;
      IF(LATCH(I) >= LNOB29)["check whether the parent photon is a secondary. "
        LATCH(I)=LATCH(I)+(IREGION_TO_BIT(IRL)- INT(LATCH(I)/LNOB29))*LNOB29;
      ]
      ELSE["The parent is a primary."
        LATCH(I) =  LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30I;
    ]
  ]"end of pair block"

  ELSEIF(IARG = 11)[ " Bhabha just occurred - record the electron"
    IF(IQ(NP) = 1)[ "positron on top"
      $SAVE_LATCH_BIT30NP-1;
      IF(LATCH(NP-1) >= LNOB29)["check whether the parent is a secondary. "
        LATCH(NP-1) = LATCH(NP-1)+(IREGION_TO_BIT(IRL)-
        INT(LATCH(NP-1)/LNOB29))*LNOB29;
      ]
      ELSE["the parent is a primary"
        LATCH(NP-1) = LATCH(NP-1)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
    $RESTORE_LATCH_BIT30NP-1;
    ]"end positron on top"
    ELSE[ "electron on top, record the region number using LATCH"
      $SAVE_LATCH_BIT30NP;
      IF(LATCH(NP) >= LNOB29)["check whether the parent is a secondary. "
        LATCH(NP) = LATCH(NP)+(IREGION_TO_BIT(IRL)-
                    INT(LATCH(NP)/LNOB29))*LNOB29;
      ]
      ELSE["the parent is a primary"
        LATCH(NP) = LATCH(NP)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
    $RESTORE_LATCH_BIT30NP;
    ]"end electron on top"
  ]

  ELSEIF(IARG = 13 | IARG = 14 )[  " Annih just occurred -record both."
    DO I=NPold,NP[
      $SAVE_LATCH_BIT30I;
      LATCH(I) = $IBSET(LATCH(I),0);
      "bit 0 is used to mark the photon"
      IF(LATCH(I) >= LNOB29)["check whether the parent is a secondary. "
        "At this stage both particle have the same LATCH.               "
        LATCH(I)=LATCH(I)+(IREGION_TO_BIT(IRL)- INT(LATCH(I)/LNOB29))*LNOB29;
      ]
      ELSE["The parent is a primary."
        LATCH(I) =  LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30I;
    ]
  ] "End of Annih"

  ELSEIF(IARG = 20)[ " Photo just occurred"
    IF(NP>NPold | i_survived_rr > 0 | IQ(NPold)=-1)[
      DO I=NPold,NP[
        $SAVE_LATCH_BIT30I;
        IF(LATCH(I) >= LNOB29)["check whether the parent is a secondary. "
           LATCH(I) = LATCH(I)+(IREGION_TO_BIT(IRL)-
                      INT(LATCH(I)/LNOB29))*LNOB29;
        ]
        ELSE["the parent is a primary"
           LATCH(I) = LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
        ]
        $RESTORE_LATCH_BIT30I;
      ]
    ]
  ] "End of photo"

]         "End of LATCH option = 2,   "
"
"*******************************************************************************
"
"                               LATCH SETTING  LATCH_OPTION=3          ""toc:
"                               *************
"The following is for LATCH_OPTION =3. In this case, both the primaries' LATCH
"values are passed on to the secondaries and the particle origins are recorded.
"we use bits 1 to (28-$LATCH_NUMBER_OF_BITS) for region bit set, bit 0
"is used to record whether a photon is involved in this particle history, and
"bits (29-$LATCH_NUMBER_OF_BITS) - 28 to record the region # where the particle
"is created. This works for 2**($LATCH_NUMBER_OF_BITS) geometrical regions.
"Bits 29-31 are reserved for rw-phsp. The number of bits used for particle
"origin can be increased by changing the value of $LATCH_NUMBER_OF_BITS
"in the beginning of this file. For example, if 7 bits are used
"we can have altogether 128 geometrical regions in the simulation geometry.
"Note that for a secondary we record its origin according to where it is created
"no matter its parent is a primary or a secondary.
"
"The difference between LATCH_OPTION =3 and LATCH_OPTION =2 is that
"for LATCH_OPTION =3 the region number, where a photon has interacted, is
"recorded rather than where it has passed through. This option is considered
"to be more appropriate for BEAMnrc than option 2. However, there are some
"problems with this option. As primaries' LATCH values are passed on to the
"secondaries, one can find region numbers in a photon history which do not
"correspond to photon interactions but to electron paths of their parents.
"
"For LATCH_OPTION =3 we set bits in LATCH here if there is an interaction.
"    whereas for LATCH_OPTION =2 it is done near the start of AUSGAB.
"
"
"Jan 26, 1996 - a fairly significant bug was fixed. It had two parts.
"  1) For a compton photon, if IREGIO_TO_BIT(IRL) was not set, then
"     BIT 0 in LATCH was set => it was a bremsstrahlung photon.
"       HOWEVER, since we default any non-set regions to region 23,
"                this was a non-problem.
"  2) For pair events,coherent events, photo-electric events, the bits
"     were not set when the secondaries were created. If they were
"     created below ECUT or PCUT, they were discarded without the region
"     bit set - this could muck up the dose scoring by component.
"     MORE importantly, for e+, which then annihilate, there were 511
"     photons created which had no bits set, although the region of origin
"     was properly set.
"     For Compton, electron had its bit set prior to this change.
"
"     To be explicit, both electrons and photons carry the current bit
"     set, immediately after creation - either because the parent had
"     it set (for charged particle parents) or because we set it here.

"
"Feb 6, 1996 - also noted that for fluorescent x-ray, had been saving"
"     BIT30NP instead of BIT30NP-1 so contaminant dose scoring would"
"     have been missing this component if initial photon was a secondary"
"
ELSEIF(LATCH_OPTION  = 3 & IARG > 6)[

  " LNOB29 = 2**(29-$LATCH_NUMBER_OF_BITS). We use this constant to shift"
  " IREGION_TO_BIT(IRL) by (29-$LATCH_NUMBER_OF_BITS) bits in order to   "
  "record it using bits from (28-$LATCH_NUMBER_OF_BITS) to 28.           "

  "Moller is the most probable interaction, check it first"
  IF(IARG = 9)[ " Moller just occurred, secondary is on top of stack"
    $SAVE_LATCH_BIT30NP;
    IF(LATCH(NP) >= LNOB29)["check whether the parent is a secondary. At "
      "this stage the resultant particle has the same LATCH as the parent."
      LATCH(NP) = LATCH(NP)+(IREGION_TO_BIT(IRL)-INT(LATCH(NP)/LNOB29))*LNOB29;
    ]
    ELSE["the parent is a primary"
      LATCH(NP) = LATCH(NP)+IREGION_TO_BIT(IRL)*LNOB29;
    ]
    $RESTORE_LATCH_BIT30NP;
  ]

  ELSEIF(IARG = 18)[ " Comp just occurred, record the electron"
    DO I=NPold+1,NP["secondary e- and relaxation products"
        LATCH(I)= $IBSET(LATCH(I),IREGION_TO_BIT(IRL)); "set where created"
                                                        "also for fluor. phot"
        $SAVE_LATCH_BIT30I;
        IF(LATCH(I) >= LNOB29)["check whether the parent is a secondary. "
            LATCH(I) = LATCH(I)+(IREGION_TO_BIT(IRL)-
                       INT(LATCH(I)/LNOB29))*LNOB29;
        ]
        ELSE["the parent is a primary"
           LATCH(I) = LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
        ]
        $RESTORE_LATCH_BIT30I;
    ]"taken care of secondaries"
    IF(NP>NPold | i_survived_rr > 0)[ "interaction took place set region"
                                      "where primary interacted"
        LATCH(NPold)=$IBSET(LATCH(NPold),IREGION_TO_BIT(IRL));
    ]
  ]

  ELSEIF(IARG = 7)[ " Brem just occurred, record the photon origin"
    DO I=NPold,NP[ "photons start at NPold+1"
     IF(IQ(I)=0)[
      LATCH(I) = $IBSET(LATCH(I),0);
      "bit 0 is used to mark the brem photon"
      $SAVE_LATCH_BIT30I;
      IF(LATCH(I) >= LNOB29)["check whether the parent is a secondary. "
        LATCH(I) =LATCH(I)+(IREGION_TO_BIT(IRL)-
                   INT(LATCH(I)/LNOB29))*LNOB29;
      ]
      ELSE["the parent is a primary"
        LATCH(I) = LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30I;
     ]
    ]
  ]

  ELSEIF(IARG = 16)[ " Pair production just occurred, record both"
    DO I=NPold,NP[
      $SAVE_LATCH_BIT30I;
      LATCH(I)=$IBSET(LATCH(I),IREGION_TO_BIT(IRL)); "set where created"
      IF(LATCH(I) >= LNOB29)["check whether the parent is a secondary. "
      "at this stage both particle have the same LATCH.               "
         LATCH(I)=LATCH(I)+(IREGION_TO_BIT(IRL)-INT(LATCH(I)/LNOB29))*LNOB29;
      ]
      ELSE["The parent is a primary."
         LATCH(I) =  LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30I;
    ]
  ]

  ELSEIF(IARG = 11)[ " Bhabha just occurred - record the electron"
    IF(IQ(NP) = 1)[ "positron on top"
      $SAVE_LATCH_BIT30NP-1;
      IF(LATCH(NP-1) >= LNOB29)["check whether the parent is a secondary. "
        LATCH(NP-1) = LATCH(NP-1)+(IREGION_TO_BIT(IRL)-
                      INT(LATCH(NP-1)/LNOB29))*LNOB29;
      ]
      ELSE["the parent is a primary"
        LATCH(NP-1) = LATCH(NP-1)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30NP-1;
    ]
    ELSE[ "electron on top, record the region number using LATCH"
      $SAVE_LATCH_BIT30NP;
      IF(LATCH(NP) >= LNOB29)["check whether the parent is a secondary. "
        LATCH(NP) = LATCH(NP)+(IREGION_TO_BIT(IRL)-
                    INT(LATCH(NP)/LNOB29))*LNOB29;
      ]
      ELSE["the parent is a primary"
        LATCH(NP) = LATCH(NP)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30NP;
    ]
  ]
  ELSEIF(IARG = 24)[ " Coherent scattering just occurred, record the photon"
    IF(IQ(NP) = 0)[ "the particle is a photon"
       LATCH(NP)=$IBSET(LATCH(NP),IREGION_TO_BIT(IRL));
    ]
    ELSE[ "the particle is not a photon. This must be wrong."
        OUTPUT;(/// ' ***IN AUSGAB****'/
        ' Something is wrong, IQ(NP) should be = 0 for photons!!!'///);
        $CALL_EXIT(1);
    ]
  ] "end of coherent interaction"

  ELSEIF(IARG = 20)[ " Photo just occurred"
    IF(NP>NPold | i_survived_rr > 0 | IQ(NPold)=-1)[
      DO I=NPold,NP[
        $SAVE_LATCH_BIT30I;
        IF(LATCH(I) >= LNOB29)["check whether the parent is a secondary. "
          LATCH(I) = LATCH(I)+(IREGION_TO_BIT(IRL)-
                    INT(LATCH(I)/LNOB29))*LNOB29;
        ]
        ELSE["the parent is a primary"
          LATCH(I) = LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
        ]
        LATCH(I)=$IBSET(LATCH(I),IREGION_TO_BIT(IRL));"set bit to creation"
                                                      "of e- and any phot."
        $RESTORE_LATCH_BIT30I;
      ]
    ]
  ] "End of photo"

  ELSEIF(IARG = 13 | IARG = 14 )[  " Annih just occurred -record both."
    DO I=NPold,NP[
      $SAVE_LATCH_BIT30I;
      LATCH(I) = $IBSET(LATCH(I),0);
      "bit 0 is used to mark the photon"
      IF(LATCH(I) >= LNOB29)["check whether the parent is a secondary. "
      "At this stage both particle have the same LATCH.               "
        LATCH(I)=LATCH(I)+(IREGION_TO_BIT(IRL)-INT(LATCH(I)/LNOB29))*LNOB29;
      ]
      ELSE["The parent is a primary."
        LATCH(I) =  LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30I;
    ]
  ] "End of Annih"
]         "End of LATCH option = 3,   "


"*******************************************************************************

"*******************************************************************************
"
"                                DOSE SCORING                          ""toc:
"                                ************
"
" Obtain frequently used local variables
" **************************************
ID=DOSE_ZONE(IRL);    "Dose scoring zone for this region"

IF(IARG =  0)["About to transport a particle"
    IF(IQ(NP) ~= 0)[
        $SCORE(SCSTP, :1); "count total steps taken"
        IF(ID  ~=  0)[$SCORE(SCDSTP, :1);"Count total steps in dose regions"]
    ]
] "END TEST FOR IARG = 0"

" Do some basic checks to see if scoring is needed
" ************************************************
IF((IARG >= 5) |  (EDEP =  0.0))RETURN;

" Score total energy deposited
" ****************************

FTMP=WT(NP)*EDEP;

IF(ID  ~=  0)[ "In a dose scoring region"

    "Score total energy deposited"
    $SCORE(SCDOSE,(ID,1):FTMP);

    IF(IBRSPL=2 & IPHAT(NP)=1)["score non-fat total dose for DBS"
       $SCORE(SCDOSE,(ID,2):FTMP); "unused dose component otherwise"
    ]

    "Here if itdose_on=1, score dose components filtered by latch bits"
    "L_N_EXC(): score the energy deposited  less the latch  bit       "
    " setting  specified by L_N_EXC().                              "
    "L_N_INC(): score the energy deposited only by particles with bit "
    "setting  specified by L_N_INC().                               "

     IF(ITDOSE_ON=1 )["contaminant dose and latch filters considered)
        " here it=3 reserved for the photon or electron contamination"
        " in where am i routine, set the bit 30 to specify the particle"
       IF( $BTEST(LATCH(NP),30) ) [
           " IT=3 reserved for contaminant dose"
           $SCORE(SCDOSE,(ID,3):FTMP);
       ]
       IF( LNEXC+LNINC > 0 ) ["i.e. there is some bit filtering to do"
           DO IT=4, 3+LNEXC[ "  any bit set specified by L_N_EXC(IT, I)
                             "  will be excluded, i.e., not scored
               ISTATUS=1;
               DO I=1, 31 [
                   IF( L_N_EXC(IT, I)=0 )[ EXIT; ]
                   ELSEIF($BTEST(LATCH(NP),L_N_EXC(IT, I)))[ISTATUS=0;]
               ]
               IF(I=1)[ ISTATUS=0;]
               IF( ISTATUS=1 )[
                   $SCORE(SCDOSE,(ID,IT):FTMP);
               ]
           ]
           DO IT=4+LNEXC, 3+LNEXC+LNINC [
               " (any one of the bits specified by L_N_INC(IT, I)
               " is set )  &   ( all of the bits specified by
               " L_N_INC(IT, II)  are not set ), then score.
               " L_N_INC(IT, I) and L_N_INC(IT, II) are separated
               " by a 0
               ISTATUS=0;
               DO I=1, 31 [
                   IF( L_N_INC(IT, I)=0 )[ EXIT; ]
                   ELSEIF($BTEST(LATCH(NP),L_N_INC(IT, I)))[ ISTATUS=1;]
               ]
               IF(I=1)[ ISTATUS=0;]
               DO II=I+1, 31 [
                   IF( L_N_INC(IT, II)=0 )[ EXIT; ]
                   ELSEIF($BTEST(LATCH(NP),L_N_INC(IT, II)))[ ISTATUS=0;]
               ]
               IF( ISTATUS=1 )[ $SCORE(SCDOSE,(ID,IT):FTMP); ]
           ]
       ]"end of bit filtering routine"
    ]"end of ITDOSE_ON set"
    IF((IWATCH >  1)  &  (IWATCH ~= 4))[
        OUTPUT FTMP,IRL,IARG;
        (' ***TOTAL DOSE WITH DELTA TRANSPORT = ',E14.7,' MeV. IRL= ',I3,
        ' IARG= ',I3);
    ]
]

IF(IAUSFL(6)=1)[
   IF(IARG=1 | IARG=2 | IARG=3)["We reset the flag"
       IAUSFL(6)=0;
       "if this flag is not re-set, the next particle on stack may"
       "be scored even it's not crossing a scoring plane BECAUSE if "
       "USTEP<DNEAR IAUSFL(6) won't be re-set in HOWFAR for the particle "
       ESPLIT_DBS=0; "also reset this in case the reason IAUSFL(6) is set"
                     "to one is because we were going to do e- splitting"
                     "Cancels e- splitting in case transport cut off"
                     "due to E<AE or E<ECUT or range rejection"
   ]
   ELSEIF(ICM = ICMNEW & ESPLIT_DBS=0)[
       "this is not necessary anymore. Bugs related to this removed"
       IAUSFL(6) = 0;
       OUTPUT;
       (/' IN AUSGAB, IAUSFL(6) is re-set to 0. This should not happen!'/
        ' Track down why we are getting this!'/);
       OUTPUT X(NP),Y(NP),Z(NP),W(NP),IR(NP),ICM,IHSTRY;
       (' X(NP),Y(NP),Z(NP),W(NP),IR(NP),ICM,IHSTRY= ',4F12.4,3I8);
   ]
]

RETURN;
END;  "End of subroutine AUSGAB"
%E     "beamnrc.mortran - start subroutine ENSRC                          "
"************************************************************************
"
"    These routines handle sampling from an energy spectrum as
"     per standard NRC routine ensrc.mortran
"
"************************************************************************
SUBROUTINE EN_SAMPLE(ENIN);

$IMPLICIT-NONE;
;COMIN/ENERGYSRC,RANDOM,SOURCE,EGS-IO/;

INTEGER K;
$REAL ENIN; "energy as sampled from energy distribution"

"THIS  DOES THE ACTUAL SAMPLING OF THE INCIDENT ENERGY"
"THIS WILL  RETURN A HISTOGRAM OF VALUES"
:RETRY:;
$RANDOMSET RNNO1;      $RANDOMSET RNNO2;
DO K=1,NENSRC[
   RNNO1=RNNO1-SRCCDF(K);
   IF(RNNO1<=0) EXIT;
]
ENIN = CDFINV(K,1) + RNNO2*CDFINV(K,2);
IF(ENIN < ENMIN)[
   IF(ENIN < 0.9999*ENMIN)[
       OUTPUT;(//' ***WARNING IN ENERGY SAMPLING ROUTINE:'/
                 ' Sampled energy < ENMIN'//);
   ]
   GOTO :RETRY:;
]
IF(ENIN > ENSRCD(NENSRC))[
   IF(ENIN > 1.0001*ENSRCD(NENSRC))[
       OUTPUT;(//' ***WARNING IN ENERGY SAMPLING ROUTINE:'/
                 ' Sampled energy > max. energy'//);
   ]
   GOTO :RETRY:;
]
RETURN;
END;

SUBROUTINE EN_INITIALIZE;

$IMPLICIT-NONE;
;COMIN/ENERGYSRC,SCORE,SOURCE,EGS-IO/;

INTEGER KMAX, "stores index of bin with max. probability"
        I,K; "indices"
$REAL    FMAX, "stores max. normalized probability"
        TEMP, "used in re-ordering bins"
        FNORM; "used to calculate normalization"

"This initialization routine is based on a sampling routine by Iwan"
"Kawrakow.  The previous initialization routine allowed sampling of"
"energies beyond the maximum energy and also sometimes failed to sample"
"from bins with small probabilities"
"SRCCDF($INVDIM) used to store the cumulative probability distribution"
"but now simply stores the normalized PDF re-ordered so that bins with"
"the highest probability come first"

IF(ENMIN >= ENSRCD(1))[
    OUTPUT;(//' ***ERROR IN ENERGY SPECTRUM:'/
              ' Lower energy of 1st bin >= upper energy of 1st bin.'//);
    $CALL_EXIT(1);
]

"now normalize the distribution and for each energy bin determine the"
"lower energy of the bin and the width of the bin"
FNORM=0;
DO IB=1,NENSRC[ FNORM = FNORM + SRCPDF(IB);]
DO IB=1,NENSRC[
    SRCCDF(IB)=SRCPDF(IB)/FNORM;
    IF(IB>1)[
      CDFINV(IB,1)=ENSRCD(IB-1);
    ]
    ELSE[
      CDFINV(IB,1)=ENMIN;
    ]
    CDFINV(IB,2)=ENSRCD(IB)-CDFINV(IB,1);
]

"re-order the bins to put bins with max. probability first"

DO I=1,NENSRC-1[
   FMAX=SRCCDF(I);KMAX=I;
   DO K=I+1,NENSRC[
     IF(SRCCDF(K) > FMAX)[
        FMAX=SRCCDF(K); KMAX=K;
     ]
   ]
   K=KMAX;
   TEMP=SRCCDF(K); SRCCDF(K)=SRCCDF(I); SRCCDF(I)=TEMP;
   TEMP=CDFINV(K,1); CDFINV(K,1)=CDFINV(I,1); CDFINV(I,1)=TEMP;
   TEMP=CDFINV(K,2); CDFINV(K,2)=CDFINV(I,2); CDFINV(I,2)=TEMP;
]"END LOOP OVER I"

"OUTPUT IF IWATCH IS ACTIVE"
IF(IWATCH ~= 0)[
  OUTPUT SPEC_TITLE;(1x,80A1);
  OUTPUT;(/' ENSRCD,   SRCPDF:'//);
  OUTPUT (ENSRCD(IB),SRCPDF(IB),IB=1,NENSRC);(2E17.7);
  OUTPUT;(//);
]
RETURN;
END;   "end of subroutine ensrc
%E     "beamnrc.mortran - start subroutine howfar                         "
"*******************************************************************************
"
                          SUBROUTINE HOWFAR;
"                         *****************
"*******************************************************************************
"
"     HOWFAR routine for BEAMnrc.
"
"     ASSUMES arrays IR_to_CM_forward and IR_to_CM_back  and NREG have
"     been initialized.
"
"     ROUTINES CALLED:
"
"     This routine just determines which CM to call and
"     otherwise just passes everything through to the HOWFAR_CM routines
"
"
"*******************************************************************************
"
"                             LOCAL REPLACEMENT MACROS
"                             ************************
;
" MACRO's to expands the call into a series of labelled
" calls to the individual CM's HOWFARS. The last CM ends up being the statement
" immediately after the original statement> Note the order is critical.

REPLACE {;$CALL_HOWFAR;} WITH {
       {REDUCE ;CALL HOWFAR__$CM_LIST;} :CM_CALL_DONE: CONTINUE;
}
;REPLACE {;CALL HOWFAR__CMLIST(#);} WITH {;:HOWFAR_{P1}:  ;CALL HOWFAR_{P1};}
;REPLACE {;CALL HOWFAR__CMLIST(#,#);} WITH {
       ;CALL HOWFAR__CMLIST({P2});
       GOTO :CM_CALL_DONE:;
:HOWFAR_{P1}:  ;CALL HOWFAR_{P1};
}
"*******************************************************************************
"
"                       TYPE DECLARATIONS AND COMMON BLOCKS
"                       ***********************************
$IMPLICIT-NONE;
;COMIN/CMs,GEOM,SCORE,STACK,EPCONT,USER,EGS-IO/;
"T>****************************
"T>TYPE DECLARATIONS FOR HOWFAR
"T>****************************
"T>
$REAL
   A,    "T>direction sine wrt z-axis
   B,    "T>X*U+Y*V;B2=B*B
   B2,   "T>square of B
   C,    "T>square of radial position
   COUT, "T>square of radial position less square of cylinder radius (<=0)
   TCYL, "T>distance to outer cylinder along particle trajectory
   XF,   "T> X coordinate after ustep
   YF;   "T> Y coordinate after ustep

" Discard if in region 1 (vacuum region which surrounds geometry)
" **********************
IF(IR(NP) > 1 & IR(NP) <= NREG) [ ICM = IR_to_CM(IR(NP)); ]
ELSE ["region is out of geometry" IDISC = 1; RETURN; ]

" Call HOWFAR for current component module
" ****************************************
ICMNEW = ICM; "ICMNEW is changed in WHERE_AM_I when particle reaches boundary of
              "component module as established in HOWFAR_$CMNAME.
IAUSFL(6) = 0; "No call to AUSGAB for fluence scoring after particle transport.
               "This flag is set to 1 in WHERE_AM_I to request a call to AUSGAB
               "after particle transport for the purpose of scoring fluence on
               "the scoring plane between component modules.  The flag is reset
               "here to avoid the situation where no call is made to AUSGAB
               "after the particle transport, such as with a negative USTEP in
               "subroutine ELECTR, resulting in an AUSGAB call after the next
               "particle step when the particle is not crossing a scoring plane.
ESPLIT_DBS=0;  "set to 0 to avoid splitting e- (DBS) when splitting plane is at"
               "the bottom of a CM, and e- reaches the splitting plane by"
               "travelling backwards (W<0) to it but then changes direction"
               "(W>0) as soon as it hits the splitting plane.  In this case,"
               "the e- never really entered the splitting CM, so we do not want"
               " to split"

;$GOTO_CM_LIST(HOWFAR) ICM;
;$CALL_HOWFAR;    "expands to call specific HOWFAR_CM routines for each CM

" Check for particle crossing outer boundary, radius or 1/2 square RMAX_CM(ICM)
" *****************************************************************************
"
" set IRNEW and ICMNEW if particle will pass out of the side of  geometry
" while still in this CM.
"
" calculate x and y position at end of step.
XF = ABS(X(NP) + USTEP * U(NP));
YF = ABS(Y(NP) + USTEP * V(NP));

IF(RMAX_CM_FLAG(ICM) = 1) [" cylindrical boundary about CM"
   C = X(NP)**2 + Y(NP)**2; "radial position at START of step"
   IF( C > RMAX_CM2(ICM) ) [ " particle already out
      IRNEW = 1; "set region into 1"
      ICMNEW = 0; "set CM into 0"
      IAUSFL(6) = 0; "No call to AUSGAB for fluence scoring flag.  This
           "flag may have been set to 1 in WHERE_AM_I, but boundary
           "of cylinder, which particle is now known to cross, is
           "not a scoring plane.
      USTEP =  0.0;
      ESPLIT_DBS = 0;
   ]
   ELSEIF( (XF**2 + YF**2) > RMAX_CM2(ICM) ) [" particle will pass the boundary
      A = U(NP)*U(NP)+V(NP)*V(NP);
      "In principle, we must be inside CM still since USTEP reduced in
      "HOWFAR_CM, but we are cautious in case of roundoff.
      "If particle is going out, we reduce USTEP etc so energy deposition
      "etc will be correct out to the boundary.
      IF(A > 0.0 & (RMAX_CM(ICM)-SQRT(C))/SQRT(A) < USTEP) [
         "boundary may be crossed
         COUT = C - RMAX_CM2(ICM);
         IF(COUT > 0.0)[ "COUT should be negative or zero
            IF(IWATCH > 0)[OUTPUT COUT;(' COUT=',E11.3);]
            COUT=0.0;
         ]
         B = X(NP)*U(NP)+Y(NP)*V(NP);
         B2 = B**2;
         IF(B > 0.0)[
            IF(COUT/B2 > -1.0E-3)[TCYL=-0.5*COUT/B;]
            ELSE[TCYL=-COUT/(SQRT(B2-A*COUT)+B);]
         ]
         ELSEIF(B < 0.0)[
            IF(COUT/B2 > -1.0E-3)[TCYL = -2.*B/A*(1.-0.25*A*COUT/B2);]
            ELSE[TCYL = (SQRT(B2-A*COUT)-B)/A;]
         ]
         ELSE[ TCYL=SQRT(-COUT/A); ]
         IF (USTEP > TCYL) [ "check if particle reaches boundary
            USTEP = TCYL; "adjust USTEP
            IRNEW = 1; "particle passing out of geometry into region 1"
            ICMNEW = 0; "particle passing out of geometry into CM 0"
            IAUSFL(6) = 0; "No call to AUSGAB for fluence scoring flag.
            ESPLIT_DBS=0;
         ]
      ]
   ]"end of particle will pass the boundary block"
]"end of check for cylindrical outer boundary

ELSEIF (RMAX_CM_FLAG(ICM) = 2) ["request check of square boundary about CM
   IF(ABS(X(NP)) > RMAX_CM(ICM) | ABS(Y(NP)) > RMAX_CM(ICM) )[
      " particle already outside the boundary at start of step"
      IRNEW = 1; "set region = 1"
      ICMNEW = 0; "set CM = 0"
      IAUSFL(6) = 0; "No call to AUSGAB for fluence scoring flag.  This
                     "flag may have been set to 1 in WHERE_AM_I, but boundary
                     "of cylinder, which particle is now known to cross, is
                     "not a scoring plane.
      USTEP =  0.0; "
      ESPLIT_DBS=0;
   ]
   ELSEIF((XF > RMAX_CM(ICM)) | (YF > RMAX_CM(ICM)) )[
      " particle will pass the boundary"
      A=1.E20;B=1.E20;
      IF (U(NP) > 0)    ["X-boundary  pos" A = (RMAX_CM(ICM)-X(NP))/U(NP);]
      ELSEIF(U(NP) < 0) ["X-boundary  neg" A = (-RMAX_CM(ICM)-X(NP))/U(NP);]

      IF (V(NP) > 0)     ["Y-boundary pos" B = (RMAX_CM(ICM)-Y(NP))/V(NP);]
      ELSEIF (V(NP) < 0) ["Y-boundary neg" B = (-RMAX_CM(ICM)-Y(NP))/V(NP);]
      C = MIN(A,B);
      IF(C < USTEP) [ "boundary to be crossed
         USTEP = C; "adjust USTEP
         IRNEW = 1; "particle passing out of geometry into region 1"
         ICMNEW = 0; "particle passing out of geometry into CM 0"
         IAUSFL(6) = 0; "No call to AUSGAB for fluence scoring flag.  This
         ESPLIT_DBS=0;
      ]
   ]"end of particle will pass the boundary block"
]"end of check for square boundary"
RETURN;
END; "End of subroutine HOWFAR
%E     "beamnrc.mortran - start subroutine inputs                         "
"*******************************************************************************
"
                          SUBROUTINE INPUTS;
"                         *****************
"*******************************************************************************
"
"                    TYPE DECLARATIONS AND COMMON BLOCKS
"                    ***********************************
"
$IMPLICIT-NONE;
;COMIN/BREMPR,EDGE,CMs,ELECIN,GEOM,IO_INFO,MEDIA,MISC,SCORE,
      SOURCE,USEFUL,RANDOM,USER, STACK,EPCONT,ENERGYSRC,BOUNDS,
      EGS-VARIANCE-REDUCTION,ET-Control,EGS-IO,GetInput,RWPHSP/;

"T>****************************
"T>TYPE DECLARATIONS FOR INPUTS
"T>****************************
"T>
INTEGER
   I,J,JJ, "T>DO loop indices
   INEXT, "T>dummy variable
   NUM_PHSPOUT; "T> used for getting name of phsp file output directory
DOUBLE PRECISION FCASE; "T>dummy variable.

$REAL ESTEPIN,SMAX; "Dummy variables for things now taken"
                                  "care of by egsnrc"
INTEGER IDORAY,IFLUOR; "Dummy variables for things now taken"
                                  "care of by egsnrc"
;
"*****************************************************************************
"
"                       INPUT/OUTPUT CONTROL INPUT          ""toc:
"                       **************************
"First Record
"************
OUTPUT;(/' TITLE:',$);
;MINPUT (INPUTS) TITLE;(1A80);
OUTPUT TITLE;(' ',1A80/);
OUTPUT;(' ');

"EGSnrc transport parameters
"***************************

OUTPUT;(' Reading in EGSnrc transport parameters:'/
        ' -------------------------------------- ');

"set skindepth to 0 here.  If skindepth input is omitted from"
"the input file or is input improperly, then it will remain 0, only"
"to get reset to BLCMIN if BCA=PRESTA-I or 3 if BCA=EXACT in the"
"subroutine mscati.  If, on the other hand, skindepth is input properly,"
"but the value is out of the range of allowed values [-1,1e15], then"
"it will be set to its default value of 3.  This will not be reset in"
"mscati"
skindepth_for_bca=0;

call get_transport_parameter(-1);

OUTPUT;(//' Finished reading EGSnrc transport parameters.'/);

IF((~exact_bca | transport_algorithm=$PRESTA--I) & SMAXIR(1)=1e10)[
"if we get to here with the default value of SMAX (1e10), then"
"assume that this is because the SMAX input does not exist, the user"
"did not input it properly or the value was out of range and we want to"
"set it to the PRESTA-I default of 5"
    DO I=1,$MXREG[ SMAXIR(I)=5.;]
]

"now, see if the user has input a directory in which to write"
"phase space files"
PHSP_OUTDIR=' ';
NUM_PHSPOUT=1;
VALUES_SOUGHT(NUM_PHSPOUT)='PHSP OUTPUT DIRECTORY';
TYPE(NUM_PHSPOUT)=2; "character input"
NVALUE(NUM_PHSPOUT)=1;"only looking for 1 input"

DELIMETER='USER INPUTS';
$GET_INPUT(NUM_PHSPOUT);

IF(error_flags(NUM_PHSPOUT)=0)[
  "read PHSP_OUTDIR from the input text string"
  READ (CHAR_VALUE(NUM_PHSPOUT,1),FMT='(A)') PHSP_OUTDIR;
]

REWIND(i_input); "go back to beginning of input file"
;MINPUT (INPUTS) TITLE;(1A80); "read the title again to get to the 2nd line"

"input of name of material for nominal AIR as used by pegs4dat"
" *************************************"
NMED = 1;                  "Number of media so far
AIR_INDEX = 1;             "first medium is the air, unless set to 0 for vacuum
;OUTPUT;
   (/' MEDIUM of nominal AIR (exactly as in pegs4dat) (left justify): ',$);
READ(i_input,'(24A1)') (MED_IN(J),J=1,24);
;OUTPUT (MED_IN(J),J=1,24); (' ',24A1/);
IF(MED_IN(1) =  'V' & "Check if medium is vacuum"
    MED_IN(2)='A' & MED_IN(3)='C' & MED_IN(4)='U' & MED_IN(5)='U' &
    MED_IN(6)='M') [
    OUTPUT;(/' AIR  is called VACUUM '/);
    AIR_INDEX = 0;
    NMED = 0;
]
ELSEIF (MED_IN(1) =  ' ' & MED_IN(2)=' ' & MED_IN(3)=' ' & MED_IN(4)=' ')[
    "Nothing input, assume vacuum"
    MED_IN(1)='V'; MED_IN(2)='A';MED_IN(3)='C';MED_IN(4)='U';MED_IN(5)='U';
    MED_IN(6)='M';
    OUTPUT;(' Defaults to vacuum');
    AIR_INDEX = 0;
    NMED = 0;
]
DO J=1,24[MEDIA(J,1)=MED_IN(J);]              "medium 1 is nominal AIR
;

"next record
"***********

OUTPUT;(/' IWATCH(-N-4), ISTOR(0,+-1), IRESTART(0-3), IO_OPT(0-4), ',/
         ' IDAT(0-1), LATCH_OPTION (1-3), IZLAST(0-2): ',$);
;MINPUT (INPUTS) IWATCH,ISTORE,IRESTART,IO_OPT,IDAT,LATCH_OPTION ,IZLAST;
               (7I12);
OUTPUT IWATCH,ISTORE,IRESTART,IO_OPT,IDAT,LATCH_OPTION ,IZLAST;
       (2I12,3I10,2I12);
IF(IWATCH >  4)IWATCH=0;
IF((ISTORE < -1)   |  (ISTORE >  1))  ISTORE=0;
IF((IRESTART  < 0) |  (IRESTART >  4))IRESTART=0;
IF((IO_OPT  < 0)   |  (IO_OPT >  4))  IO_OPT=0;
IF((IDAT    < 0)   |  (IDAT   >  1))  IDAT  =0;
IF((IZLAST < 0)    |  (IZLAST > 2))   IZLAST = 0;
IF(LATCH_OPTION <=0| LATCH_OPTION>3)  LATCH_OPTION = 2;
$BEAMMODEL_INPUT_OPTION;
OUTPUT IWATCH,ISTORE,IRESTART,IO_OPT,IDAT,LATCH_OPTION ,IZLAST;
    (/' Do not track(0) or track(>0) every interaction or track Nth'/
      ' history only(-N):',T60,I12/
    ' Store random # for a batch(0),a history(1) or read random #(-1):',T70,I2/
    ' First run(0),restarted(1),make(2),analyze(3):',T70,I2/
    ' Output to PH-SP(0),not(1),BEAM-MODEL(2),PH-SP&MODEL(3),'/
    '      output to PH-SP in IAEA format(4):',T70,I2/
    ' Store data(0) or not(1):',T70,I2/
    ' LATCH OPTION,do not inherit(1),inherit+record origin(2,3):',T70,I2/
    ' Do not score ZLAST(0), score ZLAST(1), output file for graphics(2):',
    T70,I2);
"IF((IRESTART =  2) |  (IDAT =  1))[INEXT=0;]ELSE[INEXT=1;]"
IF(IRESTART =  1)[INEXT=1;]ELSE[INEXT=0;]"Only leave restart=1 if already is"
OUTPUT;(' ');

"                       MONTE CARLO CONTROL INPUT            ""toc:
"                       *************************

"Next Record
"***********

OUTPUT;(' #HISTORIES, RN SEED #1, RN SEED #2, TIMMAX, ',
        ' IBRSPL(0,1,2),'/T10,'NBRSPL, IRRLTT(0,1,2), ICM_SPLIT'/' : ',$);
READ(i_input,'(F15.0,2I13,F12.0,4I10)',END=:EOF_INPUTS:,ERR=:ERR_INPUTS2:)
     FCASE, IXXIN,JXXIN,TIMMAX,IBRSPL,NBRSPL,IRRLTT,ICM_SPLIT;
OUTPUT  FCASE,IXXIN,JXXIN,TIMMAX,IBRSPL,NBRSPL,IRRLTT,ICM_SPLIT;
(/T1,F15.0,2I13,F12.4,4I10);

IF(IWATCH = 4 & FCASE >1000 ) [ "This is probably unintentional"
     OUTPUT;(//' *****************************************************'/
               ' *****************************************************'/
               ' IWATCH = 4 and FCASE > 1000. => a huge file'/
               ' The assumption is that this is a mistake/oversight'/
               '        Stopping the run'/
               ' *****************************************************'/
               ' *****************************************************'/);
     $CALL_EXIT(1);
]

"Make sure the IXXIN and JXXIN values will not be overridden by defaults"
" and warn user if they will in case they expect to start independent runs"
IF((IXXIN <= 0) | (IXXIN > 31328)) [
   OUTPUT; (' First RN seed outside allowed range and default value set');
   IXXIN = 1802;
]
IF((JXXIN < = 0) | (JXXIN > 30081)) [
   OUTPUT; (' Second RN seed outside allowed range and default value set');
   JXXIN = 9373; "sets Marsaglia default"
]

NCASE=FCASE;
IF(IWATCH =  0  &  NCASE  < $NCASEMIN)[NCASE=$NCASEMIN;]
IF(NCASE/$NBATCH=0)["must have a minimum of $NBATCH cases"
   NCASE=$NBATCH;
]
JCASE=NCASE/$NBATCH; NCASE=$NBATCH*JCASE;
FCASE=NCASE;

IF( i_parallel > 0 ) JXXIN = JXXIN - 1 + i_parallel;

$INITIALIZE RNG USING IXXIN AND JXXIN;

IF(TIMMAX =  0.0)TIMMAX=0.99;
IF(IRRLTT<0 | IRRLTT > 2)IRRLTT=0; "default "
IF(IBRSPL =  0 & IRRLTT>=1)[
    "Russian roulette can only be used with brem splitting"
    IRRLTT=0;NBRSPL=1;
    OUTPUT;(//' Russian roulette can only be used with brem splitting'/
              ' IRRLTT reset to 0.'//);
]
"Huh? Was: ELSEIF(IBRSPL=2 & IBRSPL>0)["
ELSEIF(IBRSPL=2 & IRRLTT>0)[
    "built-in Russ. Rou. not used with DBS"
    IRRLTT=0;
    OUTPUT;(//' Built-in Russian roulette not used with DBS'/
              ' IRRLTT reset to 0.'//);
]
ELSEIF(IBRSPL=29)[ "SBS no longer supported"
    OUTPUT;
  (//' Selective bremsstrahlung splitting no longer supported.'/
     ' Will carry on with no bremsstrahlung splitting.'//);
    IRRLTT=0;NBRSPL=1;
]
IF(IRRLTT=1)[ "no longer support this option"
    OUTPUT;(//' IRRLTT=1 is no longer supported.  Defaults to IRRLTT=2.'//);
    IRRLTT=2;
]
IF(IBRSPL =  1 | IBRSPL=2)[
    "DEFAULT BREM SPLITTING TO $MAXBRSPLIT"
    IF(NBRSPL <= 0)[
      "default bremsstrahlung splitting to NBRSPL=20, which should"
      "provide reasonable optimization up to 20 MeV"
      NBRSPL=20;
      OUTPUT NBRSPL;(//' ***WARNING***'/
                       ' NBRSPL<=0.  Reset to ',I4//);
      WRITE(IOUTLIST,100)NBRSPL;
    100 FORMAT(//' ***WARNING***'/
                 ' NBRSPL<=0.  Reset to ',I4//);
    ]
    ELSEIF(NBRSPL >  $MAXBRSPLIT)[
      "default to $MAXBRSPLIT"
      OUTPUT $MAXBRSPLIT,NBRSPL;
      (//' ***WARNING***'/
         ' NBRSPL > $MAXBRSPLIT '/
         ' NBRSPL reduced to ',I10,' from ',I10//);
      WRITE(IOUTLIST,101)$MAXBRSPLIT,NBRSPL;
   101 FORMAT(//' ***WARNING***'/
         ' NBRSPL > $MAXBRSPLIT '/
         ' NBRSPL reduced to max = ',I10,' from ',I10//);
      NBRSPL=$MAXBRSPLIT;
    ]
    IF($MXSTACK<4*NBRSPL)[
      OUTPUT $MXSTACK,4*NBRSPL;
      (//' ***WARNING***'/
         ' $MXSTACK is only ',I10,'.  This may not be large enough to'/
         ' handle the bremsstrahlung splitting.  We recommend increasing'/
         ' $MXSTACK to at least 4*NBRSPL = ',I10,' in '/
         ' beamnrc_user_macros.mortran.'//);
      WRITE(IOUTLIST,102)$MXSTACK,4*NBRSPL;
      102 FORMAT(//' ***WARNING***'/
         ' $MXSTACK is only ',I10,'.  This may not be large enough to'/
         ' handle the bremsstrahlung splitting.  We recommend increasing'/
         ' $MXSTACK to at least 4*NBRSPL = ',I10,' in '/
         ' beamnrc_user_macros.mortran.'//);
    ]
    IF(LATCH_OPTION.LT.2)[
        LATCH_OPTION=2;"DEFAULT IS 2"
        OUTPUT;
    (//' LATCH_OPTION cannot be set to 0 or 1 if brem-splitting required.'/
           ' LATCH_OPTION has been re-set to 2'//);
    ]
]

IF(IBRSPL=1 | IBRSPL=2) nbr_split=NBRSPL; "so egsnrc can take over ubs"
                                          "note that this gets reset in"
                                          "AUSGAB"
IF(IRRLTT=2)[ "so egsnrc can take over russ. roulette"
    i_play_RR=1;
    IF(IBRSPL=1 | IBRSPL=2) prob_RR=1./FLOAT(NBRSPL);
]

IF(ICM_SPLIT<0)[
    ICM_SPLIT=0; "default"
]
ELSEIF(ICM_SPLIT=1)[
    OUTPUT;(//' ***WARNING***'/
     ' You have set the arbitrary splitting plane to the top of CM 1.'/
     ' Splitting only works for CM > 1.  Code will not fail but you'/
     ' will not get splitting.'//);
    WRITE(IOUTLIST,103);
  103 FORMAT(//' ***WARNING***'/
     ' You have set the arbitrary splitting plane to the top of CM 1.'/
     ' Splitting only works for CM > 1.  Code will not fail but you'/
     ' will not get splitting.'//);
]

OUTPUT NCASE,IXXIN,JXXIN,TIMMAX,IBRSPL,NBRSPL,IRRLTT;
    (/' # of histories:',T60,I12/
    ' 1st initial random number seed(>0,<31329):',T60,I12/
    ' 2nd initial random number seed(>0,<30081):',T60,I12/
    ' maximum cpu time allowed:',T60,F10.2,' hrs'/
    ' bremsstrahlung angular sampling is always switched on'/
    ' bremsstrahlung splitting off(0),uniform(1),'/
    ' directional(2):',T60,I12 /
    ' each brem split into:',T60,I12/
    ' Russian roulette off(0),on(1),on+annihilation split(2):',T60,I12/);
IF(ICM_SPLIT>0)[
   OUTPUT ICM_SPLIT;
    (' Arbitrary splitting plane at top of CM # ',T60,I12);
]
OUTPUT;(' ');


"Next Record only if IBRSPL > 1
"***********

IF(IBRSPL=2)[
   OUTPUT;
   (' Inputs for DBS:'/
    ' ---------------'/
' Field radius at SSD (cm), SSD (cm), CM no. for electron splitting'/
' (0 for no splitting), Plane no. within CM for electron splitting,'/
' IRAD_DBS (set to 1 for radially-symmetric splitting), Z position'/
' of russian roulette plane (cm).'/
    ' : ',$);
    ;MINPUT (INPUTS) FS,SSD,ICM_DBS,ZPLANE_DBS,IRAD_DBS,ZRR_DBS;
         (2F12.0,3I12,F12.0);
    OUTPUT  FS,SSD,ICM_DBS,ZPLANE_DBS,IRAD_DBS,ZRR_DBS;
    (/T1,2F12.3,3I12,F12.3);

    IF(ICM_DBS<=0 | ZPLANE_DBS<=0)[
       ICM_DBS=0;
       OUTPUT;(/' Electrons will not be split.'/);
    ]
    ELSE[
       OUTPUT NBRSPL,ICM_DBS,ZPLANE_DBS,ZRR_DBS;
       (/' Electrons will be split ',I10,' times:'/
         '        CM no. for splitting = ',I4,/
         '        Splitting plane no.  = ',I8,/
         ' Z of russian roulette plain = ',F8.5,' cm'/);
       IF(IRAD_DBS=1)[
          OUTPUT;(/' Split electrons will be redistributed with radial'/
                   ' symmetry about the beam axis.'/);
       ]
       ELSE[
          IRAD_DBS=0;
       ]
    ]

    OUTPUT;(' ');
]

"Next Record only if ICM_SPLIT > 0
"***********

IF(ICM_SPLIT>0)[
  OUTPUT;(' NSPLIT_PHOT,NSPLIT_ELEC :',$);
  ;MINPUT (INPUTS) NSPLIT_PHOT,NSPLIT_ELEC;(2I6);
  OUTPUT  NSPLIT_PHOT,NSPLIT_ELEC;
  (/T1,2I6);
  IF(NSPLIT_PHOT<=1 & NSPLIT_ELEC<=1)[
    OUTPUT;(//' ***WARNING in arbitrary splitting:'/
              ' Both NSPLIT_PHOT and NSPLIT_ELEC are <=1'/
          ' Implying no splitting is to be done for either particle type.'/
          ' ICM_SPLIT will be set to 0, shutting off arbitrary splitting.'//);
    ICM_SPLIT=0;
  ]
  IF($MXSTACK<4*NSPLIT_PHOT)[
    OUTPUT $MXSTACK,4*NSPLIT_PHOT;
      (//' ***WARNING***'/
         ' $MXSTACK is only ',I6,'.  This may not be large enough to'/
         ' handle the photon splitting at an arbitrary plane.  We recommend'/
         ' increasing $MXSTACK to at least 4*NSPLIT_PHOT = ',I6,' in '/
         ' beamnrc_user_macros.mortran.'//);
      WRITE(IOUTLIST,104)$MXSTACK,4*NSPLIT_PHOT;
      104 FORMAT(//' ***WARNING***'/
         ' $MXSTACK is only ',I6,'.  This may not be large enough to'/
         ' handle the photon splitting at an arbitrary plane.  We recommend'/
         ' increasing $MXSTACK to at least 4*NSPLIT_PHOT = ',I6,' in '/
         ' beamnrc_user_macros.mortran.'//);
  ]
  IF($MXSTACK<4*NSPLIT_ELEC)[
    OUTPUT $MXSTACK,4*NSPLIT_ELEC;
      (//' ***WARNING***'/
         ' $MXSTACK is only ',I6,'.  This may not be large enough to'/
         ' handle the electron splitting at an arbitrary plane.  We recommend'/
         ' increasing $MXSTACK to at least 4*NSPLIT_ELEC = ',I6,' in '/
         ' beamnrc_user_macros.mortran.'//);
      WRITE(IOUTLIST,105)$MXSTACK,4*NSPLIT_ELEC;
      105 FORMAT(//' ***WARNING***'/
         ' $MXSTACK is only ',I6,'.  This may not be large enough to'/
         ' handle the photon splitting at an arbitrary plane.  We recommend'/
         ' increasing $MXSTACK to at least 4*NSPLIT_ELEC = ',I6,' in '/
         ' beamnrc_user_macros.mortran.'//);
  ]
]

"                       SOURCE CONFIGURATION INPUT       ""toc:
"                       **************************

DOSE_STAT=0; "assume that we can get nhstry from a phsp source"
             "if not, this is set to 1 in ISOURCE"

CALL ISOURCE; "Get source data including source energies"

"Next Record
"***********
OUTPUT;
    (/'(ESTEPIN,SMAX--DUMMY INPUTS),ECUTIN,PCUTIN,(IDORAY--DUMMY INPUT)'/
    'IREJCT_GLOBAL(-2...2),ESAVE_GLOBAL,(IFLUOR--DUMMY INPUT)'/'   : ',$);
;MINPUT (INPUTS)
    ESTEPIN,SMAX,ECUTIN,PCUTIN,IDORAY,IREJCT_GLOBAL,ESAVE_GLOBAL,IFLUOR;
    (4F15.0,2I12,F15.0,I5);
OUTPUT ESTEPIN,SMAX,ECUTIN,PCUTIN,IDORAY,IREJCT_GLOBAL,ESAVE_GLOBAL,IFLUOR;
    (F7.3, 1PE12.4, 0PF10.4,F10.4,2I5,F10.4, I5)

IF(ECUTIN>ECUT(2))[ "reset ecut in all regions to ecutin"
   OUTPUT ECUT(2);
    (/' ****WARNING****'/
      ' ECUTIN > ECUT input in EGSnrc parameters ( ',F10.4,' MeV).'/
      ' ECUT defaults to ECUTIN.'/);
   DO I=2,$MXREG[ ECUT(I)=ECUTIN;]
]
ELSE[
   ECUTIN=ECUT(2);
]
IF(PCUTIN>PCUT(2))[ "reset ecut in all regions to ecutin"
   OUTPUT PCUT(2);
    (/' ****WARNING****'/
      ' PCUTIN > PCUT input in EGSnrc parameters ( ',F10.4,' MeV).'/
      ' PCUT defaults to PCUTIN.'/);
   DO I=2,$MXREG[ PCUT(I)=PCUTIN;]
]
ELSE[
   PCUTIN=PCUT(2);
]

"moved to below call to ISUMRY to avoid ECUT=AE in show transport params"
"now set ECUT(1)=PCUT(1)=0.0 to avoid warning messages from AUSGAB"
"ECUT(1)=0.;
"PCUT(1)=0.;

IF(MONOEN=1)[
"check that minimum energy of first non-zero bin is above ECUT,PCUT"
   IF(SRCPDF(1)>0.0)[
        IF(IQIN=-1&ENMIN<ECUTIN)[
          OUTPUT;(//' *******WARNING:'/
                      ' min. energy of spectrum < ECUTIN'/
' May lead to artifically high dose in region(s) on which source',
'  is incident'//);
          WRITE(IOUTLIST,'(//'' *******WARNING:''/
                      '' min. energy of spectrum < ECUTIN''/
                      '' May lead to artifically high dose in region(s)'',
                      '' on which source is incident''//)');
        ]
        ELSEIF(IQIN=0&ENMIN<PCUTIN)[
          OUTPUT;(//' *******WARNING:'/
                      ' min. energy of spectrum < PCUTIN'/
' May lead to artifically high dose in region(s) on which source',
' is incident'//);
          WRITE(IOUTLIST,'(//'' *******WARNING:''/
                      '' min. energy of spectrum < PCUTIN''/
                      '' May lead to artifically high dose in region(s)'',
                      '' on which source is incident''//)');
        ]
    ]
    ELSE["find out the min energy of the first non-zero bin"
        DO IB=2,NENSRC[
          IF(SRCPDF(IB)>0.)[
            IF(IQIN=-1&ENSRCD(IB-1)<ECUTIN)[
               OUTPUT;(//' *******WARNING:'/
                      ' min. energy of spectrum < ECUTIN'/
' May lead to artifically high dose in region(s) on which source',
' is incident'//);
               WRITE(IOUTLIST,'(//'' *******WARNING:''/
                      '' min. energy of spectrum < ECUTIN''/
                      '' May lead to artifically high dose in region(s)'',
                      '' on which source is incident''//)');
            ]
            ELSEIF(IQIN=0&ENSRCD(IB-1)<PCUTIN)[
               OUTPUT;(//' *******WARNING:'/
                      ' min. energy of spectrum < PCUTIN'/
' May lead to artifically high dose in region(s) on which source',
' is incident'//);
               WRITE(IOUTLIST,'(//'' *******WARNING:''/
                      '' min. energy of spectrum < PCUTIN''/
                      '' May lead to artifically high dose in region(s)'',
                      '' on which source is incident''//)');
            ]
            EXIT;
          ]
        ]
   ]
]

OUTPUT ESAVE_GLOBAL;
    (' Global esave cutoff value for range rejection:',T60,F10.4,' MeV');

IF( IREJCT_GLOBAL < 0 & IREJCT_GLOBAL > -3 ) [
"special range rejection options for DBS, -1, -2"
    i_rr_global = 1; IREJCT_GLOBAL = -IREJCT_GLOBAL;
] ELSE [ i_rr_global = 0; ]
IF(IREJCT_GLOBAL <=  0 | IREJCT_GLOBAL > 2)[ OUTPUT;(' NO RANGE REJECTION');
   IF(ESAVE_GLOBAL > ECUTIN)[
      OUTPUT;(T10,' Why is ESAVE_GLOBAL set when there is no range rejection?',
      /T15,'It is set to zero'/);
      ESAVE_GLOBAL = 0.0;
   ]
   IREJCT_GLOBAL=0;
]
ELSEIF(IREJCT_GLOBAL > 0)[
    OUTPUT;(' RANGE REJECTION below ESAVE with RANGE and DNEAR');
    IF (ESAVE_GLOBAL <= ECUTIN) [
         OUTPUT ;(///' ******  NB ESAVE_GLOBAL <= ECUT  so NO Range Rejection',
                ' ***' /'              Unless ESAVE set individually'//);
    ]
    ELSEIF (ESAVE_GLOBAL ~= 0.0 & IREJCT_GLOBAL = 1)[
         OUTPUT ;(///'       ***** NOTE ****',/
           ' Automated range rejection (IREJCT_GLOBAL=1) is being used.',/
           ' This implies doses will be inaccurate because of changes',/
           ' in ECUTRR going from one CM to the next.'///);
    ]
]
ELSE["this option not implemented "
    OUTPUT IREJCT_GLOBAL;(' RANGE REJECTION  option:',I4,'  NOT IMPLEMENTED'/
           '  No range rejection done ******'//);
    IREJCT_GLOBAL = 0;
]

"Next record
"***********

OUTPUT;(/' Photon forcing: next five numbers on one line'/
    ' Force photon interactions in the target?(0)=>no,(1)=>yes, '/
    ' min/max photon interaction #/history to do forcing for,'/
    ' min/max CM # in which to do forcing  '/' : ',$);
;MINPUT (INPUTS) IFORCE,NFMIN,NFMAX, NFCMIN, NFCMAX;(5I12);
OUTPUT IFORCE,NFMIN,NFMAX, NFCMIN, NFCMAX;(5I4);
IF((IFORCE  < 0) |  (IFORCE >  1)) IFORCE=0;
IF(IFORCE =  0)[
    OUTPUT;(/' No photon interaction forcing in effect'/);
]
ELSE[
    IF(NFMIN <= 0)NFMIN=1;
    IF(NFMAX <= 0)NFMAX=1;
    "NOTE, WE COULD ARRANGE THE SCORING SO THAT SECOND FORCING COULD BE"
    "USED, BUT IT IS NOT A TRIVIAL EXTENTION."
    OUTPUT NFMIN,NFMAX;
    (/' Forced photon interactions in effect for interactions #',
     I3,' to',I3/);
    OUTPUT NFCMIN,NFCMAX;
    (/' Forced photons to interact in modules',I3,' to',I3,/);
]
;
"                       SCORING PLANES             ""toc:
"                       **************
"INPUT records FOR SCORING PLANES

OUTPUT;(/' Information about scoring planes'/);

IF(IO_OPT=1 | IO_OPT=2) [
   OUTPUT IO_OPT;(' No phase space files since IO_OPT=',I3);
]
ELSE[ OUTPUT; (' There will be phase space files generated at each plane');
   IF(IO_OPT=4) OUTPUT;
      (' Phase space will be in IAEA format');
]

OUTPUT;(' Number of scoring planes(NSC_PLANES) & list of CMs (score at',
       ' back of each)'/' : ',$);
;MINPUT (INPUTS) NSC_PLANES,(IPLANE_to_CM(I),I=1,NSC_PLANES);(10I5);
OUTPUT NSC_PLANES,(IPLANE_to_CM(I),I=1,NSC_PLANES);(10I5);
IF (NSC_PLANES > $MAX_SC_PLANES)[ OUTPUT NSC_PLANES, $MAX_SC_PLANES;
  (///' *******asked for too many scoring planes**********'/
      '        reduced from',I4,' to', I3/
     /' ***********************');
  NSC_PLANES = $MAX_SC_PLANES;
]

IF(IO_OPT ~= 1)&(NSC_PLANES = 0) [
   OUTPUT;
   (//' AT LEAST ONE SCORING PLANE HAS TO BE GIVEN FOR PH-SP OUTPUT!!'/
             ' PLEASE RESTART AND USE NSC_PLANES > 0.'///);
   $CALL_EXIT(1);
]

IF (NSC_PLANES < 0 | NSC_PLANES > $MAX_SC_PLANES) NSC_PLANES=$MAX_SC_PLANES;

IF(NSC_PLANES = 0) [
   OUTPUT;(//' Number of scoring or output planes is zero.'/
             ' No fluence scoring will be done.'//);
]
"Note that the existence of the requested CMs is checked in the gemoetry
"checking routine in main after we know how many there are.

ELSE[OUTPUT NSC_PLANES,(IPLANE_to_CM(I),I=1,NSC_PLANES);
   (' Number of planes for fluence scoring or phase space output:', I5/
    ' Fluence will be scored at the back of component module(s): ',10(I5,','));
   IF(IPLANE_to_CM(1) = 0)[
      OUTPUT;(' Scoring plane will default to back of last CM');
   ]
]

IF(NSC_PLANES>0 & IO_OPT ~= 1 & PHSP_OUTDIR~=' ')[
   "user specified directory in which to write phase space files"
   OUTPUT PHSP_OUTDIR;
   (//' Phase space files at scoring planes will be output to directory'/
      ' : ',A);
]

"                        SCORING ZONES            ""toc:
"                        *************

"INPUT records FOR SCORING ZONES

IF(NSC_PLANES  > 0) ["only ask if there are scoring planes"
   DO ISCORE=1,NSC_PLANES ["loop through scoring planes "
      OUTPUT ISCORE;(/' Inputs for scoring plane ',I5);
      "Ali:GRID"
      OUTPUT $MAX_SC_ZONES; (/' Number of scoring zones(',I5,
             ') & zone type (0-annular;1-square;2-grid): ',$);
      ;MINPUT (INPUTS) NSC_ZONES(ISCORE),MZONE_TYPE(ISCORE);(2I5);
      IF (NSC_ZONES(ISCORE) > $MAX_SC_ZONES)[
         OUTPUT ISCORE, NSC_ZONES(ISCORE), $MAX_SC_ZONES;
         (///' *******asked for too many scoring zones for scoring plane',I2,
             ' **********'/
             '        reduced from',I4,' to', I3/
            /' ***********************'///);
         NSC_ZONES(ISCORE) = $MAX_SC_ZONES;
      ]
      OUTPUT NSC_ZONES(ISCORE),MZONE_TYPE(ISCORE);  (2I5);

      "Ali:GRID"
      IF(MZONE_TYPE(ISCORE) <0 | MZONE_TYPE(ISCORE)>2)
         MZONE_TYPE(ISCORE)=0; "default to annular zones"

      IF(MZONE_TYPE(ISCORE) = 0)[ "annular zones - default case is set later"
         IF (NSC_ZONES(ISCORE)>0)[
            OUTPUT;
            (' Radii of scoring zones, in increasing order(10/line): ',$);
            ;MINPUT (INPUTS) (RSCORE_ZONE(ISCORE,I),I=1,NSC_ZONES(ISCORE));
                (10F15.0);
            OUTPUT (RSCORE_ZONE(ISCORE,I),I=1,NSC_ZONES(ISCORE));
                (10F10.5);
            DO ISZ=1,NSC_ZONES(ISCORE) [
              "Square radius of scoring zones for each plane"
               RSCORE_ZONE2(ISCORE,ISZ) = RSCORE_ZONE(ISCORE,ISZ)**2;
            ]
         ] "end NSC_ZONES>0 block"
         ELSE [OUTPUT;
         (' Five equal area annular zones to be used for scoring');]
         "Note that if NSC_ZONES=0, there are 5 regions of equal area set up to
         "maximum boundary of CM. This is done in the geometry checking routines
         "since the CM outer boundary is needed first but not yet available
         OUTPUT;(' ');
      ]"end of annular zones"
      ELSEIF(MZONE_TYPE(ISCORE) = 1) ["square zones"
         IF (NSC_ZONES(ISCORE)>0)[
            OUTPUT;
            (' Half-width of scoring zones, in increasing order(10/line)'/
            ' : ',$);
            ;MINPUT (INPUTS) (RSCORE_ZONE(ISCORE,I),I=1,NSC_ZONES(ISCORE));
                  (10F15.0);
            OUTPUT (RSCORE_ZONE(ISCORE,I),I=1,NSC_ZONES(ISCORE)); (10F10.5);
            DO ISZ=1,NSC_ZONES(ISCORE) ["Square half-width for scoring zones"
               RSCORE_ZONE2(ISCORE,ISZ) = RSCORE_ZONE(ISCORE,ISZ)**2;
            ]
         ] "end NSC_ZONES>0 block"
         ELSE [OUTPUT;
         (' Five equal area square rings to be used for scoring');]
         "Note that if NSC_ZONES=0, there are 5 regions of equal area set up to
         "maximum boundary of CM.
      OUTPUT;(' ');
      ]
      ELSEIF(MZONE_TYPE(ISCORE) = 2) ["grid"   "Ali:GRID"
         ;MINPUT (INPUTS) XMIN_ZONE(ISCORE),XMAX_ZONE(ISCORE),
                          YMIN_ZONE(ISCORE),YMAX_ZONE(ISCORE),
                          NX_ZONE(ISCORE),NY_ZONE(ISCORE);
                          (4F12.5,2I5);
         OUTPUT; (' XMIN, XMAX, YMIN and YMAX in cm');
         OUTPUT XMIN_ZONE(ISCORE),XMAX_ZONE(ISCORE),
                YMIN_ZONE(ISCORE),YMAX_ZONE(ISCORE); (4F10.3);
         OUTPUT NX_ZONE(ISCORE),NY_ZONE(ISCORE);
                (' NX =',I3,'    NY =',I3);
         IF(NX_ZONE(ISCORE)*NY_ZONE(ISCORE)>$MAX_SC_ZONES)[
            OUTPUT ISCORE, NX_ZONE(ISCORE)*NY_ZONE(ISCORE), $MAX_SC_ZONES;
         (///' *******asked for too many scoring zones for scoring plane',I2,
             ' **********'/
             '   You asked for ',I4,' but max. number is ',I4/
            /' ***********************'///);
            STOP;
         ]
         ELSE[
            NSC_ZONES(ISCORE)=NX_ZONE(ISCORE)*NY_ZONE(ISCORE);
            OUTPUT NSC_ZONES(ISCORE);
            (' Total no. of scoring zones = ',I5);
            "now, get the grid boundaries,  RSCORE_ZONE stores X boundaries"
            "RSCORE_ZONE2 stores Y boundaries"
            DO ISZ=1,NX_ZONE(ISCORE)+1[
               RSCORE_ZONE(ISCORE,ISZ)=XMIN_ZONE(ISCORE)+
               (XMAX_ZONE(ISCORE)-XMIN_ZONE(ISCORE))/NX_ZONE(ISCORE)*(ISZ-1);
            ]
            OUTPUT (RSCORE_ZONE(ISCORE,ISZ),ISZ=1,NX_ZONE(ISCORE)+1);
               (' X-grid boundaries:'/(6F10.3));
            DO ISZ=1,NY_ZONE(ISCORE)+1[
               RSCORE_ZONE2(ISCORE,ISZ)=YMIN_ZONE(ISCORE)+
               (YMAX_ZONE(ISCORE)-YMIN_ZONE(ISCORE))/NY_ZONE(ISCORE)*(ISZ-1);
            ]
            OUTPUT (RSCORE_ZONE2(ISCORE,ISZ),ISZ=1,NY_ZONE(ISCORE)+1);
               (' Y-grid boundaries:'/(6F10.3));OUTPUT;(/);
         ]
      ]
   ]"end of do loop through scoring scoring planes"
]"end of NSC_PLANES > 0 block"

"         inputs for dose components calculations       ""toc:

OUTPUT;
 (' Total dose only(0) or total dose & dose components(1):', $);
;MINPUT (INPUTS) ITDOSE_ON; (I5);
IF(ITDOSE_ON ~= 1)ITDOSE_ON=0;"default to 0"
OUTPUT ITDOSE_ON; (I5);

IF(ITDOSE_ON = 1)[
    OUTPUT;
(/' CM # at which contaminant particles are identified on entry at front,'/
  ' and type of contaminant particle (0=photons,1=charged particles)'/
  ' :',$);
   ;MINPUT (INPUTS) ICM_CONTAM, IQ_CONTAM; (2I5);
   OUTPUT ICM_CONTAM, IQ_CONTAM; (2I5);
   "do some checks"
   IF (IQ_CONTAM ~= 0)&(ABS(IQ_CONTAM) ~= 1)[
      OUTPUT;(///' Wrong input for IQ_CONTAM!!!'/
      ' Try again with IQ_CONTAM = 1(charged particles) or 0(photons)'//);
      $CALL_EXIT(1);
   ]
   IF(LATCH_OPTION = 1 & ICM_CONTAM ~= 0) ["this combination won't work"
      OUTPUT;(//' ****************WARNING: **************'/
      'Contaminant dose is meaningless with LATCH_OPTION = 1'/
      'ICM_CONTAM has been set to 0'//);
      WRITE(IOUTLIST,'(//''***WARNING:''/
      ''Contaminant dose is meaningless with LATCH_OPTION = 1''/
      ''ICM_CONTAM has been set to 0''//)');
      ICM_CONTAM=0;
   ]

   IF((ISOURC=21 | ISOURC=23 | ISOURC=24) & ICM_CONTAM<INIT_ICM)[
      OUTPUT;(//'***WARNING:'/
    'ICM_CONTAM < CM # on which phase space/BEAMnrc sim. source is incident.'/
       'Cannot score contaminant dose in this case.'/
       'ICM_CONTAM reset to 0 (no contaminant dose determined) for now.'//);
      WRITE(IOUTLIST,'(//''***WARNING:''/
  ''ICM_CONTAM <= CM # on which phase space/BEAMnrc sim. source is incident.''/
       ''Cannot score contaminant dose in this case.''/
     ''ICM_CONTAM reset to 0 (no contaminant dose determined) for now.''//)');
      ICM_CONTAM=0;
   ]
   ELSEIF(ICM_CONTAM>=1)[
      IF(IQ_CONTAM=0)[
        OUTPUT; (//' Dose from contaminant photons will be calculated');
      ]
      ELSEIF(ABS(IQ_CONTAM)=1)[
        OUTPUT;
        (//' Dose from contaminant electrons & positrons will be calculated');
      ]
      OUTPUT ICM_CONTAM; (' in CM # ',I4,//);
   ]
   ELSE[
      OUTPUT; (//'No contaminant dose will be calculated'//);
      ICM_CONTAM=0;
   ]
   OUTPUT; (/' # of dose components which exclude particles',
                                           ' from specified regions: ',$);
   ;MINPUT (INPUTS) LNEXC; (I5);
   OUTPUT LNEXC; (I5);
   IF(LNEXC<=0)[ LNEXC=0;]
   IF( LNEXC+3>$MAXIT) [
      OUTPUT $MAXIT-3,$MAXIT;
        (/' ******Input error: too many components asked for'/
      ' MAX. LNEXC =', I3,' since $MAXIT=',I3);
      $CALL_EXIT(1);
   ]   " out of max sub index "
   DO I=4, 3+LNEXC[  "this counts on the fortran not executing if LNEXC=0"
       OUTPUT I-3;(/' INPUT THE BIT #S IN LATCH FOR DOSE COMPONENT' , I4,
                  /' WILL NOT SCORE THE DOSE WHEN THESE BITS ARE SET: ');
       ;MINPUT (INPUTS) (L_N_EXC(I, J), J=1, 31 ); (31I5);
       DO J=1,31[
         IF(L_N_EXC(I,J) ~= 0)[
           OUTPUT  L_N_EXC(I, J); (I5,$);
         ]
       ]
       OUTPUT;(' ');
   ]
   OUTPUT;
   (/' # of dose components including particles from specified regions: ',$);
   ;MINPUT (INPUTS) LNINC; (I5);
   OUTPUT LNINC; (I5);
   IF(LNINC<=0)[ LNINC=0;]
   IF( LNINC+LNEXC+3>$MAXIT) [
      OUTPUT $MAXIT-3-LNINC,$MAXIT;
      (/' ******Input error: too many components asked for',
      ' MAX. LNINC =', I3,' since $MAXIT=',I3);
      $CALL_EXIT(1);
   ]   " out of max sub index "
   DO I=4+LNEXC, 3+LNEXC+LNINC [
      OUTPUT I-3;
      (/' INPUT THE BIT #S IN LATCH FOR DOSE COMPONENT', I4,
      /' INPUT BIT #S TO INCLUDE, 0, BIT #S TO EXCLUDE (IF ANY): ');
      ;MINPUT (INPUTS) (L_N_INC(I, J), J=1, 31) ; (31I5);
      DO J=1,31[
         IF(L_N_INC(I,J)=0)[
           EXIT;
         ]
         ELSE[
           IF(J=1) OUTPUT;
                  (' WILL SCORE THE DOSE IF ANY OF THESE BITS ARE SET: ');
           OUTPUT  L_N_INC(I, J); (I5,$);
         ]
      ]
      DO JJ=J+1,31[
         IF(L_N_INC(I,JJ)=0)[
           EXIT;
         ]
         ELSE[
           IF(JJ=J+1) OUTPUT;
                  (/' AND NONE OF THESE BITS ARE SET: ');
           OUTPUT  L_N_INC(I, JJ); (I5,$);
         ]
      ]
      OUTPUT;(' ');
   ]
]"end of ITDOSE_ON block"


" input the front boundary of the ist component module"
OUTPUT;
(/' Z dist from ref plane(Z=0) to CM front (include any air gap): ', $);
;MINPUT (INPUTS) Z_min_CM(1); (F15.0);
OUTPUT Z_min_CM(1); (F11.5);

"INITIALIZATION OF BIT SETTING just in case
DO I = 1, $MXREG[IREGION_TO_BIT(I) = 0;]
;
RETURN;

"BAD INPUT FILE, STOP AND PRINT MESSAGE
:EOF_INPUTS:
;OUTPUT;(//' *** unexpected end of file reading input for INPUTS ***');
$CALL_EXIT(1); "END OF INPUT FILE RETURN"

:ERROR_INPUTS:
;OUTPUT;(//' *** format error on input for INPUTS ***');
$CALL_EXIT(1); "END OF INPUT FILE RETURN"

:ERR_INPUTS2:
;OUTPUT;(//' *** format error on input for INPUTS ***'/
           ' Note that we have added a new input variable, ICM_SPLIT '/
           ' for particle splitting at an arbitrary plane.  This error '/
           ' may be due to the fact that you are using an older input'/
           ' file without ICM_SPLIT and with explanatory text on this'/
           ' input line.');
$CALL_EXIT(1);

END; "END OF SUBROUTINE INPUTS

%E     "beamnrc.mortran - start subroutane isumry                         "
"*******************************************************************************
"
                            SUBROUTINE ISUMRY;
"                           *****************
"
"     ISUMRY routine for BEAMnrc.
"
"     ASSUMES arrays IR_to_CM_forward and IR_to_CM_back have
"     been initialized.
"
"     ROUTINES CALLED:  none
"
"*******************************************************************************
"
$IMPLICIT-NONE;
;COMIN/BOUNDS,BREMPR,CMs,EDGE,ELECIN,EPCONT,GEOM,IO_INFO,MEDIA,MISC,
      SCORE,SOURCE,STACK,THRESH,USEFUL,USER,RANDOM,ENERGYSRC,EGS-IO/;
"T>****************************
"T>TYPE DECLARATIONS FOR ISUMRY
"T>****************************
"T>
;INTEGER
   I,I1,I2,I3,J,JJ,kk, "T>DO loop indices
   I3MAX, "T>limit of number of media for listing
   IOUT,  "T>output unit number
   IRL,   "T>region number"
   LELKE, "T>used to calc. max. range
   lelktmp,"T>used to calc. max. range
   lelec;  "T>used to calc. max. range

;$REAL
   AEMIN,   "T>minimum AE, lower total electron energy of PEGS data
   EIE,     "T>total energy of electron, includes rest mass
   ETAB(5), "T>tables of energies for summary of RNGEE
   RNGEE($MXMED), "T>maximum range that EGS will transport electron
   TSTTPM,  "T>PRESTA calculated minimum step sizes for maximum energy
   IEKMAX,   "T>keeps track of maximum kinetic energy of the source
   EKEI,     "T>used in calculation of max. range
   ELKEI,    "T>used in calculation of max. range
   fedep,    "T> used in calculating max. range
   elktmp,   "T> used in calculating max. range
   dedxmid,  "T> used in calculating max. range
   aux;      "T> used in calculating max. range


DATA ETAB/1.,1.5,2.,4.,6./;


"                                 OUTPUT
"                                 ******
"
" Write the header
" ****************
CALL DATETIME(1);
WRITE(IOUTLIST,100) TITLE,TIMEN,DATEN;
100  FORMAT(// ,1A79/
      /' NRCC CALN: BEAMnrc(EGSnrc) '$BEAM_VERSION $USER_MACROS_VERSION,
      /' ON '$MACHINE' ',T60,$TIMEN_FORMAT,1X,$DATEN_FORMAT);
WRITE(IOUTLIST,200);
" Monte Carlo, transport, and scatter controls
" ********************************************
WRITE(IOUTLIST,211) NCASE,NCASET;
IF((NCASE+IHSTRY)  < 100)WRITE(IOUTLIST,203);
"in fact, this should never happen because minimum NCASE = 100 - CMa"
IF(IQIN < 9) & (ISOURC < 21 | ISOURC=22)[
     IF(IQIN < 9)[WRITE(IOUTLIST,204) IQIN;]
     IF(MONOEN =  0)[WRITE(IOUTLIST,201) EIN;]
     IF(MONOEN = 1)["spectrum input"
         WRITE(IOUTLIST,205) FILNAM, ENMIN, ENSRCD(NENSRC),NENSRC;
         IF(IMODE=1)[
            WRITE(IOUTLIST,'(T20,''  SPECTRUM FILE CONTAINS COUNTS/MeV'')');
         ]
         ELSEIF(IMODE=0)[
            WRITE(IOUTLIST,'(T20,''  SPECTRUM FILE CONTAINS COUNTS/BIN'')');
         ]
         IF(IOUTSP = 1)["list spectrum"
            WRITE(IOUTLIST,110) NENSRC;
            110   FORMAT(T20,'ENERGY DIST''N, # OF INCIDENT ENERGY BINS:',T60,
            I3/T20,'BIN    KINETIC ENERGY     PROBABILITY  ');
            DO IB=1,NENSRC[
               WRITE(IOUTLIST,120)IB,ENSRCD(IB),SRCPDF(IB);
               120   FORMAT(' ',T20,I3,T28,F7.3,T45,1PE10.3);
            ]
         ]
     ]
]
ELSEIF(ISOURC >= 21 & ISOURC~=22)[
     IF((ISOURC = 21 | ISOURC=24) & ~phsp_open)[
                      WRITE(IOUTLIST,207) NNPHSP, NPHOTSRC, EKMAXSRC,
                      EKMINSRCE, NINCSRC, INIT_ICM, NRCYCL;
        IF(OLDSRC = 1)[ WRITE(IOUTLIST,208); ]
        IF(IPARALLEL>1 & PARNUM>0)[
             WRITE(IOUTLIST,209)IPARALLEL,INT((PARNUM-1)*NNPHSP/IPARALLEL)+1,
                INT(PARNUM*NNPHSP/IPARALLEL);
        ]
     ]

     "space for ISOURC=31 when it arrives
]

"Ali:BCSE"
IF((IBRSPL = 1 | IBRSPL = 2) & USE_BCSE)[NBRSPL = NBRSPL_ORGNL;]
IF(IBRSPL =  0)[WRITE(IOUTLIST,2279);]
ELSEIF(IBRSPL = 1)[WRITE(IOUTLIST,2281)NBRSPL;]
ELSEIF(IBRSPL = 2)[
    WRITE(IOUTLIST,2289)FS,SSD,NBRSPL;
    IF(ICM_DBS>0)[
      WRITE(IOUTLIST,2290)ZPLANE_DBS,ICM_DBS,ZPOSN_DBS,ZRR_DBS;
      IF(IRAD_DBS=1)[
         WRITE(IOUTLIST,2291);
      ]
      ELSE[
         WRITE(IOUTLIST,2292);
      ]
    ]
]

IF(USE_BCSE) [
   WRITE(IOUTLIST,:new2:) nmed_enhance;
   :new2: FORMAT(/T20,'Brem. cross section enhancement WILL be used'/
   T20,' The following ',I2,' media will be enhanced:');
   DO i=1,$MXMED [
       IF( is_bcse_medium(i) ) [
          WRITE(IOUTLIST,'(T20,24a1)') (media(kk,i),kk=1,24);
       ]
   ]
   IF( BCSE_POWER_N > 0 ) [
    WRITE(IOUTLIST,:new3:) BCSE_FACTOR_C,BCSE_POWER_N;
    :new3: FORMAT(T20,' Enhancement factor will be 1 + C*E**N WITH C = ',
               1PE14.6,' N = ',0PF9.2);
   ]
   ELSE [
       WRITE(IOUTLIST,:new4:) BCSE_FACTOR_C;
       :new4: FORMAT(T20,' Constant enhancement factor  =',F12.2);
   ]
]"end of using BCSE block"
ELSE [ WRITE(IOUTLIST,:new1:);
  :new1: FORMAT(T20,'Brem. cross section enhancement WILL NOT be used');
]

IF(IBRSPL=1)[
  IF(IRRLTT >=  1)[WRITE(IOUTLIST,2282);] ELSE [WRITE(IOUTLIST,2283);]
]
IF(IRRLTT = 2)[
  IF(IBRSPL = 1)[WRITE(IOUTLIST,2286)NBRSPL;]
]
IF(ICM_SPLIT>0)[
   WRITE(IOUTLIST,2287)ICM_SPLIT,NSPLIT_PHOT,NSPLIT_ELEC;
]
IF(IFORCE ~= 0)[
   IF( NFCMIN<1 | NFCMIN>NFCMAX )[ NFCMIN = 1; ]
   IF( NFCMAX<NFCMIN | NFCMAX>MAX_CMS ) [ NFCMAX = MAX_CMS; ]
   WRITE(IOUTLIST,230)NFMIN,NFMAX,NFCMIN,NFCMAX;
]
ELSE[WRITE(IOUTLIST,231);]
IF(NSC_PLANES = 0)[WRITE(IOUTLIST,233);]
ELSEIF(NSC_PLANES>0)[
   WRITE(IOUTLIST,234);
   DO I = 1,NSC_PLANES[
     WRITE(IOUTLIST,235) I,IPLANE_to_CM(I);
   ]
   IF(IO_OPT = 1|IO_OPT = 2)[WRITE(IOUTLIST,236);]
   ELSE[
     WRITE(IOUTLIST,237);
     IF(IO_OPT=4) WRITE(IOUTLIST,238);
   ]
]

200  FORMAT(' ',78('*')/ ' **',T78,'**'/
' **',T38,'BEAMnrc',T78,'**'/ ' **',T78,'**'/
' **',T10,'Code developed at National Research Council of Canada as part of',
                   T78,'**'/
' **',T15,'OMEGA collaboration with the University of Wisconsin.',T78,'**'/
' **',T78,'**'/
' **',' This is version V1 of BEAMnrc '
   ,T78,'**'/ ' **',T78,'**'/ ' ',78('*')//);
211  FORMAT(' Max # of histories: to run',I12,T50,'To analyze',T65,I12);
204  FORMAT(' ',T20,'Incident charge',T63,I2);
201  FORMAT(' ',T20,'Incident kinetic energy',T56,F9.3,' MeV');
202  FORMAT(' ',T20,'Maximum incident kinetic energy',T57,F9.3,' MeV');
203  FORMAT (' ',T4,'*** WARNING *** too few histories - statistical analysis',
              ' incorrect');
205  FORMAT(' ',T20,'Read incident kinetic energy spectrum from file:'/A,/
            ' ',T20,'  Minimum kinetic energy in spectrum',T56,F9.3,' MeV',/
            ' ',T20,'  Maximum kinetic energy in spectrum',T56,F9.3,' MeV',/
            ' ',T20,'               # of bins in spectrum',T56,I9);
207  FORMAT(' ',T20,'Reading in a phase space source with:',/,
            ' ',T20,'             total # of particles',T56,I9,/
            ' ',T20,'                     # of photons',T56,I9,/
            ' ',T20,'  Maximum particle kinetic energy',T56,F9.3,' MeV',/
            ' ',T20,'  Minimum electron kinetic energy',T56,F9.3,' MeV',/
            ' ',T20,'  # of particles incident from   ',/
            ' ',T20,'                  original source',T56,F13.1,/
            ' ',T20,'   Source entering at top of CM #',T63,I2/
            ' ',T20,'  # of times to recycle particles',T56,I9);
208  FORMAT(/' ',T20,'***WARNING****NUMBER OF PHOTONS AND MINIMUM'/
            ' ',T20,'     PHOTON AND ELECTRON ENERGIES SHOWN ABOVE'/
            ' ',T20,'     HAVE BEEN SET TO ZERO EITHER BECAUSE THE'/
            ' ',T20,'     THE SOURCE FILE WAS GENERATED BY AN OLDER'/
            ' ',T20,'     VERSION OF BEAMnrc OR BECAUSE IT HAS AN ERROR.'/
            ' ',T20,'     CHECK THE FILE!!'/);
209  FORMAT(/,' ',T20,'This is one of ',I4,' parallel runs'/
            ' ',T20,'Simulation will use from particle',T56,I12,/
            ' ',T20,'                      to particle',T56,I12);
230  FORMAT(' ',T20,'Min/max photon step forced',T60,I6,'/',I6,
       /T20,'Min/max CM modules to force interaction',T60,I6,'/',I6);
231  FORMAT(' ',T20,'Photon force interaction switch',T60,'OFF');
233  FORMAT(' ',T20,'There are no scoring planes');
234  FORMAT(' ',T20,'SCORING PLANES:     #',T52,'CM #',/
            ' ',T20,'---------------------',T52,'----');
235  FORMAT(' ',T37,I4,T53,I2);
236  FORMAT(T20,'No phase space files will be output');
237  FORMAT(T20,'Phase space files will be output at EVERY scoring plane');
238  FORMAT(T20,'Phase space files will be in IAEA format');
2279   FORMAT(/T20,'Bremsstrahlung splitting',T60,'OFF');
2281   FORMAT(/T20,'Bremsstrahlung splitting',T60,'UNIFORM'/T20,
      'Initially, each bremsstrahlung photon split into ',I10,' photons');
2282   FORMAT(T20,'Russian Roulette is',T60,'ON');
2283   FORMAT(T20,'Russian Roulette is',T60,'OFF');
2284   FORMAT(T20,'Annihilation splitting no.',T60,F5.1);
2286   FORMAT(T20,'Annihilation splitting no.',T60,I4);
2289   FORMAT(/T20,'Bremsstrahlung splitting',T60,'DIRECTIONAL'/
               T20,' splitting field radius',T60,F8.3,' cm'/
               T20,' splitting field SSD',T60,F8.3,' cm'/
               T20,' splitting no. in field',T60,I10);
2290   FORMAT(T20,' e+/e- will be split at plane',I4,' in CM',I4,':'/
              T20,'  Z of splitting plane',T60,F8.3,' cm'/
              T20,'  Z of Russian Roulette plane',T60,F8.3,' cm');
2291   FORMAT(T20,'  Radial redistribution of split e+/e-',T60,'ON');
2292   FORMAT(T20,'  Radial redistribution of split e+/e-',T60,'OFF');
2287   FORMAT(T20,'Arbitrary split plane at top of CM',T60,I5/
              T20,'           Photon splitting number',T60,I5/
              T20,'         Electron splitting number',T60,I5);


" Range rejection summary
" ***********************
IF(IREJCT_GLOBAL = 0)[
   WRITE(IOUTLIST,'(T20,''RANGE REJECTION SWITCH'',T60,''OFF'')');
]
ELSEIF(IREJCT_GLOBAL > 0)[
   "check that ESAVE is set above ECUT somewhere, otherwise there is"
   "no range rejection"
   lelec=-1;
   JJ = 0;"flag "
   DO I = 1,NREG[
      IF(ESAVE(I) > ECUT(I))[JJ = JJ + 1;]"adds up regions for range rejection"
   ]
   IF(JJ = 0)[
      WRITE(IOUTLIST,'(T10,''ESAVE NEVER ABOVE ECUT=> NO RANGE REJECTION'')');
   ]
   "List the maximum ranges for 7 media
   WRITE(IOUTLIST,'(T20,''Range rejection switch'',T60,''ON '' )');
   IF(JJ>0)[
     WRITE(IOUTLIST,:label:) JJ;
     :label: FORMAT(T20,'Range rejection in',I4,' regions');
   ]
   IF(IREJCT_GLOBAL = 1) [
      WRITE(IOUTLIST,
      '(T20,''Automatic ECUTRR used starting from'',T60,F10.3,'' MeV'')')
      ECUTIN;
   ]
   IF(IREJCT_GLOBAL = 2) [WRITE(IOUTLIST,'(T30,''Fixed ECUT used'')');]
   WRITE(IOUTLIST,
   '('' Range rejection based on medium of region particle is traversing'')');
   I3MAX = MIN0(NMED,7); "Limited to 7 media for listing
   WRITE(IOUTLIST,246) I3MAX,((MEDIA(J,I),J = 1,8),I = 1,I3MAX);
   246  FORMAT(' Maximum electron ranges for restricted stopping powers:'/
           '   kinetic',T20,'   Range for media 1 through',I2/
           '   energy',T30,'      (cm)'/'   (MeV)    ',6(8A1,2X),8A1);
   AEMIN = 1.E30;       IEKMAX = 20.;
   DO I3 = 1,I3MAX[
      IF(AEMIN >  AE(I3)) [AEMIN = AE(I3);]]
   IF((MONOEN = 0) & (ISOURC<21 | ISOURC=22)) [IEKMAX = EIN;]
   ELSEIF(ISOURC>=21 & EKMAXSRC>0. & ISOURC~=22) [IEKMAX = EKMAXSRC;]
   ELSEIF((MONOEN=1) & (ISOURC<21 | ISOURC=22)) [IEKMAX = ENSRCD(NENSRC);]
   DO I1 = 1,8[
      DO I2 = 1,5[
         EKE = ETAB(I2)*10.**(I1-4);
         EIE = EKE+RM;
         IF(EIE >= AEMIN  &  EIE <= IEKMAX) [
            ELKE = LOG(EKE);
            DO MEDIUM = 1,I3MAX[
               RNGEE(MEDIUM) = 0.;
               IF(EIE >= AE(MEDIUM)  &  EIE <= UE(MEDIUM)) [
                 $SET INTERVAL ELKE, EKE;
                 EKEI = E_array(LELKE,MEDIUM);
                 ELKEI = (LELKE - eke0(MEDIUM))/eke1(MEDIUM);
                 $COMPUTE-DRANGE(EKE,EKEI,LELKE,ELKE,ELKEI,RNGEE(MEDIUM));
                 RNGEE(MEDIUM)=(RNGEE(MEDIUM)+range_ep(0,LELKE,MEDIUM));
               ]
               IF(EIE >  UE(MEDIUM)) [RNGEE(MEDIUM) = 999.999;]
            ]"END OF MEDIUM LOOP"
            WRITE(IOUTLIST,247) EKE,(RNGEE(I3),I3 = 1,I3MAX);
            247  FORMAT(' ',F7.3,2X,10(F10.3));]
      ]"END OF I2 LOOP"
   ]"END OF I1 LOOP"
   EKE = IEKMAX;
   EIE = EKE+RM;
   ELKE = LOG(EKE);
         DO MEDIUM = 1,I3MAX[
            RNGEE(MEDIUM) = 0.;
            IF(EIE >= AE(MEDIUM)  &  EIE <= UE(MEDIUM)) [
              $SET INTERVAL ELKE, EKE;
              EKEI = E_array(LELKE,MEDIUM);
              ELKEI = (LELKE - eke0(MEDIUM))/eke1(MEDIUM);
              $COMPUTE-DRANGE(EKE,EKEI,LELKE,ELKE,ELKEI,RNGEE(MEDIUM));
              RNGEE(MEDIUM)=(RNGEE(MEDIUM)+range_ep(0,LELKE,MEDIUM));
            ]
            IF(EIE >  UE(MEDIUM)) [RNGEE(MEDIUM) = 999.999;]
         ]"END OF MEDIUM LOOP"
         WRITE(IOUTLIST,247) EKE,(RNGEE(I3),I3 = 1,I3MAX);
]"End of IREJCT_GLOBAL>0 branch"
IF((ESAVE_GLOBAL >  0.0)) WRITE(IOUTLIST,267)ESAVE_GLOBAL;
267  FORMAT(' ',T20,'Discard all electrons below energy:',T60,F7.3,
                   ' MeV'/
                T25,'if too far from closest boundary');

" Various variables output
" ************************

WRITE(IOUTLIST,260) TIMMAX,IXXIN,JXXIN;
260  FORMAT(' ',T20,'Maximum cputime allowed',T59,F10.2,' (hrs)'/
            ' ',T20,'Initial random number seeds',T50,I12,I14);

" Latch options
" ******************

IF(LATCH_OPTION  = 1)[
  WRITE(IOUTLIST,'(T13,''LATCH_OPTION = 1: Latch values for secondaries not''/
                   T13,''                  inherited from primaries.'')');
]
ELSEIF(LATCH_OPTION  = 2)[
  WRITE(IOUTLIST,'(T13,''LATCH_OPTION = 2: Latch values inherited, origin of''/
                   T13,''                  secondary particles recorded.'')');
]
ELSEIF(LATCH_OPTION  = 3)[
  WRITE(IOUTLIST,'(T13,''LATCH_OPTION = 3: Latch values inherited, origin of''/
                   T13,''                  secondary particles recorded.  For''/
                   T13,''                  photons, region no. are recorded''/
                   T13,''                  where they interact, not where ''/
                   T13,''                  they just pass through.'')');
]
"LATCH_OPTION  is part of COMIN STACK"

"summary of transport parameters"
call show_transport_parameter(IOUTLIST);

" Material summary
" ****************
WRITE(IOUTLIST,300) NMED;
DO I=1,NMED[
    WRITE(IOUTLIST,310) I,(MEDIA(J,I),J=1,18),RHO(I),AE(I),AP(I),UE(I),UP(I);
]
300  FORMAT('  ',T20,'Material summary   ',I1,' Materials used'/
             ' ',79('*')/
             '  # Material',11x,'density(g/cm**3)',3X,'AE(MeV)',3X,'AP(MeV)',
                 5X,'UE(MeV)',2X,'UP(MeV)'/
             ' -- -----------------  ----------------',3X,'-------',
             3X,'-------',5X,'-------',2X,'-------');
310  FORMAT(' ',I2,1X,18A1,3X,1PE10.3,1x,2(3X,0PF9.3,1X,F9.3));


" Source summary
" **************
CALL SRCOUT;

" Geometry summary
" ****************
"Note: Region and Range rejection summaries now in one table"

WRITE(IOUTLIST,548);
548 FORMAT(/' REGION and RANGE REJECTION SUMMARY:',/
              ' **********************************'/);
WRITE(IOUTLIST,549) NREG;
549 FORMAT(' Total number of regions, including region 1',
                 ' which surrounds the geometry:', I4);
WRITE(IOUTLIST,550) ;
"Region 1 is vacuum"
WRITE(IOUTLIST,560) 1,1,0,'exterior',0,0,0,'V','a','c','u','u','m';

DO IRL=2,NREG ["DEFAULT IREGION_TO_BIT(IRL) TO 23"
   IF(IREGION_TO_BIT(IRL)<1|IREGION_TO_BIT(IRL)>23)[IREGION_TO_BIT(IRL)=23;]
]

DO IRL=2,NREG [
     IF(IREJCT_GLOBAL > 0)["range rejection"
        IF(IREJCT(IRL)=0)[
          IF(MED(IRL)=0)["vacuum"
             WRITE(IOUTLIST,560)
             IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
             CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
             MED(IRL),'V','a','c','u','u','m',' ',' ',' ',ECUTRR(IRL),
             RANGE_ECUTRR(IRL),ESAVE(IRL),'NO RR';
          ]
          ELSE[
             WRITE(IOUTLIST,560)
             IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
             CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
             MED(IRL),(MEDIA(J,MED(IRL)),J=1,9),ECUTRR(IRL),
             RANGE_ECUTRR(IRL),ESAVE(IRL),'NO RR';
          ]
        ]
        ELSEIF(IREJCT(IRL)=1)[
          IF(MED(IRL)=0)["vacuum"
             WRITE(IOUTLIST,560)
             IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
             CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
             MED(IRL),'V','a','c','u','u','m',' ',' ',' ',ECUTRR(IRL),
             RANGE_ECUTRR(IRL),ESAVE(IRL),'DNEAR';
          ]
          ELSE[
             WRITE(IOUTLIST,560)
             IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
             CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
             MED(IRL),(MEDIA(J,MED(IRL)),J=1,9),ECUTRR(IRL),
             RANGE_ECUTRR(IRL),ESAVE(IRL),'DNEAR';
          ]
        ]
     ]  "end IREJCT_GLOBAL > 0 block"
     ELSE["no range rejection"
        ESAVE(IRL)=0.0;
        IF(IRL=2)[
          IF(MED(IRL)=0)["vacuum"
             WRITE(IOUTLIST,565)
             IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
             CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
             MED(IRL),'V','a','c','u','u','m',' ',' ',' ',
             'Global range rejection off';
          ]
          ELSE[
            WRITE(IOUTLIST,565)
            IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
            CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
            MED(IRL),(MEDIA(J,MED(IRL)),J=1,9),
            'Global range rejection off';
          ]
        ]
        ELSE[
          IF(MED(IRL)=0)["vacuum"
             WRITE(IOUTLIST,565)
             IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
             CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
             MED(IRL),'V','a','c','u','u','m';
          ]
          ELSE[
            WRITE(IOUTLIST,565)
            IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
            CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
            MED(IRL),(MEDIA(J,MED(IRL)),J=1,9);
          ]
        ]
     ]
]


550  FORMAT(/T3,'Region',T13,'CM',T25,'Dose', T32,'IR_',
         T39,'Medium',T49,'ECUTRR',T57,'res_rnge',T67,'ESAVE',
         T75,'type',
        /T2,'abs',T6,'local',T13,'# IDENTIF ',T25,'ZONE',
         T32,'TO_',
         T37,'(No.&Name)',T50,'(MeV)',T59,'(cm)',T67,'(MeV)',
         /T24,'(0=no)',T32,'BIT');
560  FORMAT(1x,i3,i4,i5,1x,A8,I4,I7,I5,1X,9A1,F7.3,F8.3,F8.3,A7);
565  FORMAT(1x,i3,i4,i5,1x,A8,I4,I7,I5,1X,9A1,A32);

IF(NSC_PLANES=0)[OUTPUT;(/' No scoring planes included in output');]
ELSE [OUTPUT NSC_PLANES;(/' There are',I3,' scoring planes -see below');]

WRITE(IOUTLIST,'(/'' Component Module summary:''/
                 '' *************************'')');

IF (MAX_CMs = 1)[WRITE(IOUTLIST,'(/''  There is 1 Component Module:''/)') ;]
ELSE [
   WRITE(IOUTLIST,'(/''  There are'',I3,'' Component Modules.''/)') MAX_CMs;
]
WRITE(IOUTLIST,540);
DO ICM = 1,MAX_CMs[
    WRITE(IOUTLIST,545) ICM,CMTYPE(ICM),CMLIST(ICM),IR_start_CM(ICM),
       RMAX_CM_FLAG(ICM),RMAX_CM(ICM),Z_min_CM(ICM),Z_gap_THICK(ICM),
       ICM_to_SCORE(ICM);
] "end of loop over CMs"

540 FORMAT(
'     COMPONENT MODULE  FIRST     BOUNDARY    DISTANCE FROM    AIR    SCORING'/
'                      REGION  (1=cyl,2=sq)  REFERENCE PLANE   GAP     PLANE'/
'  #  TYPE  IDENTIFIER         FLAG    (cm)          (cm)      (cm)   (0=none)'
/);
545  FORMAT(I3,1X,A,1X,A,I5,I6,F10.3,4X,F10.3,F10.3,I6);


;$CALL_ISUMRY;    "this expands to call all the specific ISUMRY_CM routines

WRITE(IOUTLIST,'(//)');

RETURN;

END;     "Last line of subroutine ISUMRY"
%E     "beamnrc.mortran - start subroutine osumry                         "
"*******************************************************************************
"
                             SUBROUTINE OSUMRY;
"                            *****************
"
"     Routine  to ouput results for BEAMnrc.
"
"     ROUTINES CALLED: none
"
"*******************************************************************************
$IMPLICIT-NONE;
;COMIN/BOUNDS,BREMPR,CMs,EDGE,ELECIN,GEOM,IO_INFO,MEDIA,MISC,
    SCORE,SOURCE,THRESH,USEFUL,USER,RANDOM,CH-Steps,EGS-IO/;
"T>****************************
"T>TYPE DECLARATIONS FOR OSUMRY
"T>****************************
"T>
;INTEGER
   I,J,   "T>indices for general use
   IPAR,  "T>parameter index in fluence scoring arrays FLUENCE[UN][IS], SCFLU
   IQL,   "T>charge of particle
   IT,    "T>parameter index in dose scoring arrays DOSE[UN][IS], SCDOSE
   IT1,   "T>looping index used to keep dose output < 80 columns wide
   MAXIT1,"T>the max. value of IT1
   IT2,   "T>another looping index; index for dose curves
   MAXIT2,"T>the max. value of IT2
   TYPE,  "T>graph type = 1 for histogram and = 0 for normal point
   NNZ,   "T>keeps track of non-zero fluence zones
   HADZERO, "T>keeps track of zero bits in inclusive bit filters
   NOCOV; "T>set to 1 if one of the average energy or angle uncertainty
          "  estimates does not include covariance
;REAL
   TOTNUM, "T>keeps track of total # of particles in each scoring zone
   NUMTOT, "T> total # of particles in all scoring planes
   TOTERR, "T>keeps track of error on total # of particles
   TOTflu_uncer; "T>tracks total uncertainty on fluence when grid scoring

  $REAL XPLOT($MAX_DOSE_ZONE),YPLOT($MAX_DOSE_ZONE),ERRY($MAX_DOSE_ZONE);
  CHARACTER*100 SUBTITLE;
  CHARACTER*60 GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;
  CHARACTER*3  COMPNUM; "dose component no. in character format"
  integer      egs_open_file;
"*******************************************************************************
"
"                      INITIALIZATION AND OUTPUT
"                      *************************
"
"PRINT OUT FINAL BREM SPLITTING NUMBER"
IF(IBRSPL =  1)[WRITE(IOUTLIST,90)NBRSPL;]

"Print # charged particle steps/# times MS switched off/ratio"
WRITE(IOUTLIST,200) SCSTP,SCSTP2,
SCSTP/(NINCSRC*dble(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/FLOAT(NNPHSP)),
SCSTP2,(count_pII_steps+PIISTP)/SCSTP,SCSTP2;
90   FORMAT(/' FINAL BREMSSTRAHLUNG EVENTS CREATE ',I10,' PHOTONS'/);
100  FORMAT(' ',80A1/' ',75X,$DATEN_FORMAT,1X,$TIMEN_FORMAT//
           T28,'SUMMARY OF FLUENCE AND DOSE RESULTS'/
           ' ',T28,'***********************************');
200  FORMAT(/' ',T20,'TOTAL # CHARGED PARTICLE STEPS',T57,
           1PE10.3,' +/-',0PF4.1,'%'/
           ' ',T10,'# CHARGED PARTICLE STEPS/INITIAL HISTORY',T57,
           1PE10.3,' +/-',0PF4.1,'%'/
           ' ','# PRESTA-II STEPS/TOTAL # CHARGED PARTICLE STEPS',T60,
           F7.3,' +/-',0PF4.1,'%');
IF(IRESTART~=4 & ~is_finished)[ "do not keep track of this when combining"
                                "parallel runs"
WRITE(IOUTLIST,
          '(/''        NO. OF BREMSSTRAHLUNG EVENTS IN THIS RUN:'',T60,I12)')
             NUM_BREM;
" MXNP in COMIN SCORE is depth of stack"
WRITE(IOUTLIST,'(/T20,'' Maximum depth of stack='',I8)') MXNP;
]
"
" Summarize incident phase space data"
" ***********************************"

IF(ISOURC = 21 | ISOURC=23 | ISOURC=24)["full phase space data input"
   IF(N_ph_sp_e ~= 0)[E_ph_sp_e = E_ph_sp_e/N_ph_sp_e; "average"]
   IF(N_ph_sp_g ~= 0)[E_ph_sp_g = E_ph_sp_g/N_ph_sp_g; "average"]
   IF(N_ph_sp_p ~= 0)[E_ph_sp_p = E_ph_sp_p/N_ph_sp_p; "average"]
   IF(ISOURC = 21 | ISOURC=24)[
   WRITE(IOUTLIST,'(/T5,''PHASE SPACE SOURCE: Summary of particles '',
''used (not including recycling)''/
'' Used total of'',I10,'' particles, ignored'',I6,
'' multiple passers''/
'' and rejected'',I6,'' photons falling outside the DBS radius at SSD'')')
     N_ph_sp_e+N_ph_sp_g+N_ph_sp_p,NPASS_ph_sp,NFAT_ph_sp;
   ]
   ELSEIF(ISOURC=23)[
   WRITE(IOUTLIST,'(/T5,''BEAM SIMULATION SOURCE: Summary of particles used''/
'' Used total of'',I10,'' particles, and rejected'',I6,'' fat photons'')')
     N_ph_sp_e+N_ph_sp_g+N_ph_sp_p,NFAT_ph_sp;
   ]
   WRITE(IOUTLIST,
    '(/'' Equivalent to'',I10,'' primary histories'')') NHSTRY;
   WRITE(IOUTLIST,'(/'' There were'',I10,'' electrons with average energy'',
     T55, F9.4,'' MeV'')') N_ph_sp_e,E_ph_sp_e;
   WRITE(IOUTLIST,'(/'' There were'',I10,'' photons with average energy'',
     T55, F9.4,'' MeV'')') N_ph_sp_g,E_ph_sp_g;
   WRITE(IOUTLIST,'(/'' There were'',I10,'' positrons with average energy'',
     T55, F9.4,'' MeV'')') N_ph_sp_p,E_ph_sp_p;
   WRITE(IOUTLIST,'(/'' Maximum particle energy was'',F12.3,'' MeV'')')
     E_MAX_ph_sp;
]


" Scoring-plane results (fluence + phase space)
" ********************************************
"
IF (NSC_PLANES >  0) [
   IF (IO_OPT = 0 | IO_OPT >= 3) [
      WRITE(IOUTLIST,
      '(/T20,'' PHASE SPACE FILE OUTPUT''/T20,
             '' ***********************''/)');
      WRITE(IOUTLIST, '('' FILE  SCORE    TOTAL     TOTAL'',
                    ''    MAX. KE OF       MIN. KE OF     # INCIDENT''/
                        ''  #    PLANE  PARTICLES* PHOTONS*'',
                    ''   PARTICLES        ELECTRONS   PARTICLES FROM''/
                        ''                                '',
                    ''      (MeV)            (MeV)    ORIGINAL SOURCE''/)');
      DO ICM=1,MAX_CMs [
         ISCORE=ICM_to_SCORE(ICM);
         IF (ISCORE ~= 0) [
            IF(IRESTART=3|IRESTART=4|is_finished)[
               WRITE(IOUTLIST,'(I4,I7,I11,I9,''**'',F11.4,''**'',F15.4,''**'',
                                F14.3,''**''/)')
               ISCORE,ISCORE,NPPHSP(ISCORE),
               NPHOTPHSP(ISCORE),EKMAXPHSP(ISCORE),EKMINPHSPE(ISCORE),
               NINCPHSP;
            ]
            ELSE[
               WRITE(IOUTLIST,'(I4,I7,I11,I9,F13.4,F17.4,F16.3/)')
               ISCORE,ISCORE,NPPHSP(ISCORE),
               NPHOTPHSP(ISCORE),EKMAXPHSP(ISCORE),EKMINPHSPE(ISCORE),
               NINCPHSP;
            ]
         ]
      ]
   ]
    "End of phase space summary"

   IF(DOSE_STAT=1)[
      WRITE(IOUTLIST,'(//'' ***WARNING***''/
'' Could not read no. of primary (non-phsp) histories from ph-sp source.''/
'' Dose and fluence analyzed assuming each particle read from the ph-sp''/
'' file is an independent history.  May result in an underestimate''/
'' of uncertainties.''//)');
   ]
   IF(OUTCNT>0)[
      WRITE(IOUTLIST,'(//'' ***WARNING***''/
'' The phsp source was restarted at least once.  This may lead''/
'' to an underestimate of uncertainty, especially if restarted''/
'' many times.  If restarted many times, try re-running with''/
'' NRCYCL recalculated as described at top of beamnrc.mortran''//)');
   ]

   WRITE(IOUTLIST,'(//T20,'' FLUENCE RESULTS''/T20, '' ***************''/)');
   IF(OLDSRC=1|OLDSRC=2) [
               WRITE(IOUTLIST,
     '('' ***WARNING: FLUENCE IS NORMALIZED per PARTICLE INCIDENT FROM''/
       ''             PHASE SPACE SOURCE, NOT ORIGINAL SOURCE''//)');
   ]
   DO ICM=1,MAX_CMs ["Radii or half-widths of scoring zones"
      ISCORE=ICM_to_SCORE(ICM);
      IF (ISCORE ~= 0) [
         IF (MZONE_TYPE(ISCORE) = 0)["annular zones"
                  WRITE(IOUTLIST, '(''  CM SCORE POSITION   TOTAL'',
                  T48,  ''ZONE RADII'',/,
           ''     PLANE  (cm)    PARTICLES*'',T47,''   (cm)'')');
           WRITE(IOUTLIST,'(I4,I5,F8.2,I12,5F10.4,/(29X,5F10.4))')
           ICM,ISCORE,Z_min_CM(IPLANE_to_CM(ISCORE)+1),NPFLU(ISCORE),
           (RSCORE_ZONE(ISCORE,ISZ),ISZ=1,NSC_ZONES(ISCORE));
         ]
         ELSEIF(MZONE_TYPE(ISCORE) = 1)["square zones"
                  WRITE(IOUTLIST, '(''  CM SCORE POSITION   TOTAL'',
                  T48,  ''ZONE HALF-WIDTHS'',/,
           ''     PLANE  (cm)    PARTICLES*'',T47,''      (cm)'')');
           WRITE(IOUTLIST,'(I4,I5,F8.2,I12,5F10.4,/(29X,5F10.4))')
           ICM,ISCORE,Z_min_CM(IPLANE_to_CM(ISCORE)+1),NPFLU(ISCORE),
           (RSCORE_ZONE(ISCORE,ISZ),ISZ=1,NSC_ZONES(ISCORE));
         ]
         ELSEIF(MZONE_TYPE(ISCORE) = 2)[ "Ali:GRID"
            WRITE(IOUTLIST,'(//'' For grid scoring in plane'',I2)') ISCORE;
            WRITE(IOUTLIST,'(/'' XMIN, XMAX, YMIN and YMAX in cm'')');
            WRITE(IOUTLIST,'(4F10.3)') XMIN_ZONE(ISCORE),XMAX_ZONE(ISCORE),
                  YMIN_ZONE(ISCORE),YMAX_ZONE(ISCORE);
            WRITE(IOUTLIST,'('' NX ='',I3,''    NY ='',I3)')
                  NX_ZONE(ISCORE),NY_ZONE(ISCORE);
            WRITE(IOUTLIST,'('' Total no. of scoring zones ='',I5)')
                  NSC_ZONES(ISCORE);
            WRITE(IOUTLIST,'('' X-grid boundaries:'')');
            WRITE(IOUTLIST, '(6F10.3)') "6 here to list them 6 in one line"
                 (RSCORE_ZONE(ISCORE,ISZ),ISZ=1,NX_ZONE(ISCORE)+1);
            WRITE(IOUTLIST,'('' Y-grid boundaries:'')');
            WRITE(IOUTLIST, '(6F10.3)') "6 here to list them 6 in one line"
                 (RSCORE_ZONE2(ISCORE,ISZ),ISZ=1,NY_ZONE(ISCORE)+1);
         ]
      ]
   ]
   WRITE(IOUTLIST, '(/'' *Includes all particles of all weights'')');
   IF(IRESTART=3 | IRESTART=4 | is_finished)[
     WRITE(IOUTLIST,
   '(/'' **Information not available from runs in which previous data''/
      ''   is simply analyzed (IRESTART=3) or combined from parallel''/
      ''   runs (automatically or with IRESTART=4).  The missing phase''/
      ''   space file info is available in the header of the (combined)''/
      ''   phase space file.'')');
   ]
   WRITE(IOUTLIST, '(/''  Lines with zero results are not printed'')');
   NUMTOT=0.;
   DO IPAR=1,8,4 [
         IF (IPAR=1) [
            WRITE(IOUTLIST,
             '(/'' SPECTRAL-AVERAGED QUANTITIES FOR FIRST TIME CROSSINGS OF'',
             '' THE SCORING PLANE''/
             T20,''NORMALIZED per INCIDENT PARTICLE'')');
         ]
         ELSE [
            WRITE(IOUTLIST,
             '(/'' SPECTRAL-AVERAGED QUANTITIES FOR MULTIPLE CROSSINGS OF'',
             '' THE SCORING PLANE''/
             T20,''NORMALIZED per INCIDENT PARTICLE'')');
         ]
      WRITE(IOUTLIST,401);
401   FORMAT(
      ' ZONE        NUMBER            FLUENCE    ',
      '      ENERGY       ANGLE WRT Z-AXIS'/
      '                            (/cm**2)    ',
      '      (MeV)           (degrees)'/
      ' ---- ------------------ ------------------',
      ' ---------------- ----------------');
      NOCOV=0;
      DO ICM=1,MAX_CMs [
         IF (ICM_to_SCORE(ICM) ~= 0) [
            ISCORE=ICM_to_SCORE(ICM);
            WRITE(IOUTLIST,
               '(T25,'' SCORING PLANE'',I2,'', CM'',I3,'':'')') ISCORE,ICM;
            DO IQL=-1,1 [
               IF (IQL=-1) [
                  WRITE(IOUTLIST,'('' ELECTRONS'')') ;
               ]
               ELSEIF (IQL=0) [
                  WRITE(IOUTLIST,'('' PHOTONS'')') ;
               ]
               ELSE [
                  WRITE(IOUTLIST,'('' POSITRONS'')') ;
               ]
               TOTNUM=0.;
               TOTERR=0.;
               TOTflu_uncer=0.;
               NNZ=0;  "counts non-zero fluences"
               DO ISZ=1,NSC_ZONES(ISCORE)+1 ["loop over all scoring zones"
                  IF (SCFLU(IQL+2,ISCORE,ISZ,IPAR) ~= 0.0)["non-zero fluence"
                     IF(SCFLU_NOCOV(IQL+2,ISCORE,ISZ,IPAR/5+1)=1)[
                       WRITE(IOUTLIST,404) ISZ,(SCFLU(IQL+2,ISCORE,ISZ,I),
                       SCFLU2(IQL+2,ISCORE,ISZ,I),
                       I=IPAR,IPAR+$MAX_SC_PARAMETERS/2-1);
                       NOCOV=1;
                     ]
                     ELSE[
                       WRITE(IOUTLIST,402) ISZ,(SCFLU(IQL+2,ISCORE,ISZ,I),
                       SCFLU2(IQL+2,ISCORE,ISZ,I),
                       I=IPAR,IPAR+$MAX_SC_PARAMETERS/2-1);
                     ]
                     NNZ=NNZ+1;
                     NUMTOT=NUMTOT+SCFLU(IQL+2,ISCORE,ISZ,IPAR);
                     IF(ISZ ~= NSC_ZONES(ISCORE)+1 & MZONE_TYPE(ISCORE) = 2)[
                      "not in outer region and scoring a grid"
                      TOTflu_uncer=TOTflu_uncer+SCFLU2(IQL+2,ISCORE,ISZ,IPAR+1);
                      "IPAR +1 is the fluence and its uncertainty"
                     ]
                  ]"end of if that suppresses zero fluence regions"
                  ELSEIF(ISZ=NSC_ZONES(ISCORE)+1)[
                     FLUENCERR(ISCORE)=0;
                  ]"don't print anything about errors in zone 6"
                  IF (NSC_ZONES(ISCORE)>1)[
                     TOTNUM=TOTNUM+SCFLU(IQL+2,ISCORE,ISZ,IPAR);
                     TOTERR=TOTERR+(SCFLU2(IQL+2,ISCORE,ISZ,IPAR)/100.D00
                            *SCFLU(IQL+2,ISCORE,ISZ,IPAR))**2;
                     IF(ISZ=NSC_ZONES(ISCORE)+1 & TOTNUM>0. & NNZ>1)[
                        WRITE(IOUTLIST,403)'Tot',TOTNUM,SQRT(TOTERR)/
                                           TOTNUM*100.;
                        IF ( MZONE_TYPE(ISCORE) = 2) ["a grid scoring area"
                           WRITE(IOUTLIST,405) TOTflu_uncer/(NNZ-1);
                        ]
                     ]
                  ]
                 402 FORMAT(' ',I4,1PE11.3,'+-',0PF5.2,'%',1PE11.3,'+-',
                     0PF5.2,'%',0PF10.3,'+-',0PF4.1,'%',0PF10.3,'+-',
                     0PF4.1,'%');
                 403 FORMAT('   --------------------',/,
                            ' ',A4,1PE11.3,'+-',0PF4.1,'%');
                 404 FORMAT(' ',I4,1PE11.3,'+-',0PF5.2,'%',1PE11.3,'+-',
                     0PF5.2,'%',0PF10.3,'+-',0PF4.1,'%*',0PF10.3,'+-',
                     0PF4.1,'%*');
                 405 FORMAT(' ',19x,'Average fluence uncertainty in grid  ',
                            0PF5.2,'%');
               ]"end of loop in ISZ"
            ]"end of loop on different charges"
            IF(FLUENCERR(ISCORE)=1)[
               WRITE(IOUTLIST,
'(/''***WARNING: RMAX_CM('',I4,'') goes beyond RMAX_CM('',I4,'').  Thus,''/
   ''fluence in outer scoring zone may have contributions from particles''/
   ''exiting from the top of CM '',I4,''.  Since it is difficult to ''/
   ''determine the area of outer zone under these conditions, fluence in''/
   ''outer zone has been normalized by # of incident particles only.''/)')
                  IPLANE_to_CM(ISCORE)+1, IPLANE_to_CM(ISCORE),
                  IPLANE_to_CM(ISCORE)+1;
            ]
         ]
      ]
      IF(NOCOV=1)[
         WRITE(IOUTLIST,
'(/'' *Covariance not included in uncertainty because no. of particles''/
   ''  crossing scoring zone < '',I5)') $COVMIN;
      ]
   ]
    "End of fluence summary"
   "output min and max overall particle weights"
  IF(IRESTART < 2 & ~is_finished)[
   IF(NUMTOT=0.) MINWEIGHT=0.; "reset from 999 if no particles scored"
   IF(MINWEIGHT > 0.0000030 )[
      WRITE(IOUTLIST,
            '(//'' MIN PARTICLE WEIGHT FOR ALL SCORING ZONES = '',F12.7/
                '' MAX PARTICLE WEIGHT FOR ALL SCORING ZONES = '',F12.7,/)')
                MINWEIGHT,MAXWEIGHT;
      OUTPUT MINWEIGHT,MAXWEIGHT;
            (//' MIN PARTICLE WEIGHT FOR ALL SCORING ZONES = ',F12.7/
               ' MAX PARTICLE WEIGHT FOR ALL SCORING ZONES = ',F12.7/);
   ]
   ELSE[
      WRITE(IOUTLIST,
            '(//'' MIN PARTICLE WEIGHT FOR ALL SCORING ZONES = '',1PE12.5/
                '' MAX PARTICLE WEIGHT FOR ALL SCORING ZONES = '',0PF12.7,/)')
                MINWEIGHT,MAXWEIGHT;
      OUTPUT MINWEIGHT,MAXWEIGHT;
            (//' MIN PARTICLE WEIGHT FOR ALL SCORING ZONES = ',1PE12.5/
               ' MAX PARTICLE WEIGHT FOR ALL SCORING ZONES = ',0PF12.7/);
   ]
  ]
]

" Dose zone results
" *****************
IF (NDOSE_ZONE ~= 0) [
   WRITE(IOUTLIST,'(/T30,'' DOSE RESULTS''/
                 T30,'' ************''/)');
   IF(OLDSRC=1|OLDSRC=2) [
               WRITE(IOUTLIST,
       '('' ***WARNING: DOSES ARE NORMALIZED per PARTICLE INCIDENT FROM''/
         ''             PHASE SPACE SOURCE, NOT ORIGINAL SOURCE''//)');
   ]
   IF(IREJCT_GLOBAL = 1 & ESAVE_GLOBAL ~= 0. & ESAVE_GLOBAL > ECUTIN) [
     WRITE(IOUTLIST,'(T10,'' ***NOTE***''/
            T10,''Automated range rejection is being used.''/
            T10,''This implies doses will be inaccurate because''/
            T10,''of changes in ECUTRR going from on CM to the next.''/)');
   ]
   "print # charged particle steps in dose region"
   WRITE(IOUTLIST,210) SCDSTP,SCDSTP2,
         SCDSTP/(NINCSRC*dble(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/
         FLOAT(NNPHSP)),SCDSTP2;

   "Print a summary of the dose zone results"
   WRITE(IOUTLIST,300);
   WRITE(IOUTLIST,302)
      (ID,AMASS(ID),SCDOSE(ID,1),SCDOSE2(ID,1),(AMASS(ID)/1000.)*SCDOSE(ID,1),
      SCDOSE2(ID,1),ID=1,NDOSE_ZONE);
   IF(IBRSPL=2)["print total non-fat dose for DBS"
     WRITE(IOUTLIST, *);
     WRITE(IOUTLIST,305);
     WRITE(IOUTLIST,302)
      (ID,AMASS(ID),SCDOSE(ID,2),SCDOSE2(ID,2),(AMASS(ID)/1000.)*SCDOSE(ID,2),
      SCDOSE2(ID,2),ID=1,NDOSE_ZONE);
   ]
   IF( ITDOSE_ON=1) [

      IF( ICM_CONTAM >= 1) [
         WRITE(IOUTLIST, *);
         WRITE(IOUTLIST,304)ICM_CONTAM;
         WRITE(IOUTLIST,302)(ID,AMASS(ID),SCDOSE(ID,3),SCDOSE2(ID,3),
             (AMASS(ID)/1000.)*SCDOSE(ID,3),SCDOSE2(ID,3),ID=1,NDOSE_ZONE);
      ]
      WRITE(IOUTLIST, *);
      IF(LNEXC+LNINC>0)[
        WRITE(IOUTLIST,
            '(/T22,'' DOSE RESULTS WITH BIT FILTERS''/
            T30,'' ************''/)');
        WRITE(IOUTLIST,
            '(T5,''BIT FILTER SUMMARY''/
              T5,''******************''/)');
        WRITE(IOUTLIST,
        '(T2,''COMPONENT  FILTER                      BIT''/,
        T2,''   #        TYPE                        #s''/)');
        IF(LNEXC > 0)[
          DO I=4,3+LNEXC[
            WRITE(IOUTLIST,:FILTFORM1:)I-3,'EXCLUDE';
            DO J=1,31[
              IF(L_N_EXC(I,J) ~= 0)[
                 WRITE(IOUTLIST,:FILTFORM2:)L_N_EXC(I,J);
              ]
              ELSE[
                 EXIT;
              ]
            ]
          WRITE(IOUTLIST,'('' '')');
          ]
        ]
        IF(LNINC > 0)[
          DO I=4+LNEXC,3+LNEXC+LNINC[
            WRITE(IOUTLIST,:FILTFORM1:)I-3,'INCLUDE';
            HADZERO=0;
            DO J=1,31[
              IF(L_N_INC(I,J) ~= 0)[
                 WRITE(IOUTLIST,:FILTFORM2:)L_N_INC(I,J);
              ]
              ELSEIF(HADZERO=0 & L_N_INC(I,J)=0 & L_N_INC(I,J+1)~=0)[
                 HADZERO=1;
                 WRITE(IOUTLIST,:FILTFORM3:)'-';
              ]
              ELSE[
                 EXIT;
              ]
            ]
          WRITE(IOUTLIST,'('' '')');
          ]
        ]
        IF(MOD((LNEXC+LNINC),3)~=0|LNEXC+LNINC=0)[
          MAXIT1=AINT((LNEXC+LNINC)/3.)+1;
        ]
        ELSE[
          MAXIT1=AINT((LNEXC+LNINC)/3.);
        ]
        IT=3;
        DO IT1=1,MAXIT1[
          WRITE(IOUTLIST, '(/'' DOSE '', $)' );
          WRITE(IOUTLIST, '(2X, ''   DOSE   '', $ )');
          IF(IT1=MAXIT1)[
            MAXIT2=LNEXC+LNINC-(IT1-1)*3;
          ]
          ELSE[
            MAXIT2=3;
          ]
          DO IT2=1,MAXIT2[
            WRITE(IOUTLIST, '(7X, ''    DOSE     '', $ )');
          ]
          WRITE(IOUTLIST, *);
          WRITE(IOUTLIST, '('' ZONE '', $)' );
           WRITE(IOUTLIST, '(2X,''   TOTAL   '' , $ )');
          DO IT2=1,MAXIT2[
               WRITE(IOUTLIST, '(7X, ''COMPONENT:'',I2,''  '', $ )')
                    IT2+(IT1-1)*3;
          ]
          WRITE(IOUTLIST, *);
          DO ID=1,NDOSE_ZONE [
            WRITE(IOUTLIST, '(/I4,$ )' ) ID;
            WRITE(IOUTLIST, '(1X,1PE10.3, "+/-",0PF4.1,"%", $ )')
            SCDOSE(ID,1), SCDOSE2(ID,1);
            DO IT2=1,MAXIT2[
               WRITE(IOUTLIST, '(1X,1PE10.3, "+/-",0PF4.1,"%", $ )')
               SCDOSE(ID,IT+IT2), SCDOSE2(ID,IT+IT2)
            ]
          ]   " end of the do id loop "
          WRITE(IOUTLIST,*);
          WRITE(IOUTLIST,*);
          IT=IT+MAXIT2;
        ] "end of the do it1 loop
      ]"end of if LNEXC+LNINC>0
   ]"end of if itdose_on"

   "Plot of dose zone results to file [-.egsplot]"
   IOUTPLOT = egs_open_file(IOUTPLOT,0,0,'.egsplot');
   IF( IOUTPLOT > 0 ) [
       TYPE=1;"histogram as default, but it can be changed to normal
              "point plot by setting to 0"

       IF(IPLOTFLAG.EQ.0)[
          DO ID=1,NDOSE_ZONE[XPLOT(ID)=FLOAT(ID);]
          XTITLE='DOSE ZONE NUMBER';
       ]
       ELSE[
          XTITLE='Z (cm)';
          IF(TYPE.EQ.0)[
             DO ID=1,NDOSE_ZONE[XPLOT(ID)=(ZPLOTCHM(ID)+ZPLOTCHM(ID+1))/2.;]
          ]
          ELSE[
             DO ID=1,NDOSE_ZONE[XPLOT(ID)=ZPLOTCHM(ID+1);]
          ]
       ]
       DO ID=1,NDOSE_ZONE[
          YPLOT(ID)=SCDOSE(ID,1);
          ERRY(ID)=SCDOSE2(ID,1)*SCDOSE(ID,1)/100.;
       ]
       YTITLE='ABSORBED DOSE PER INCIDENT PARTICLE (Gy)';
       GRAPHTITLE='Dose Simulation Using BEAMnrc';
       SERIESTITLE='total';
       IT2=0;
       "plot histogram"
       CALL XVGRPLOT(XPLOT, YPLOT, ERRY, NDOSE_ZONE, IT2,SERIESTITLE,
         XTITLE, YTITLE, GRAPHTITLE, TITLE,IOUTPLOT, TYPE, ZPLOTCHM(1),0);

       IF(IBRSPL=2)["plot total-fat dose"
         DO ID=1,NDOSE_ZONE[
          YPLOT(ID)=SCDOSE(ID,2);
          ERRY(ID)=SCDOSE2(ID,2)*SCDOSE(ID,2)/100.;
         ]
         SERIESTITLE='total-fat';
         IT2=IT2+1;
         CALL XVGRPLOT(XPLOT, YPLOT, ERRY, NDOSE_ZONE, IT2,SERIESTITLE,
         XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,IOUTPLOT, TYPE, ZPLOTCHM(1),0);
       ]

       IF(ITDOSE_ON=1)[
         IF(ICM_CONTAM>=1)[
            DO ID=1,NDOSE_ZONE[
              YPLOT(ID)=SCDOSE(ID,3);
              ERRY(ID)=SCDOSE2(ID,3)*SCDOSE(ID,3)/100.;
            ]
            SERIESTITLE='contaminant';
            IT2=IT2+1;
            CALL XVGRPLOT(XPLOT, YPLOT, ERRY, NDOSE_ZONE, IT2, SERIESTITLE,
              XTITLE, YTITLE, GRAPHTITLE, TITLE,IOUTPLOT, TYPE, ZPLOTCHM(1),0);
         ]
         DO IT=4,3+LNEXC+LNINC [
            DO ID=1,NDOSE_ZONE[
              YPLOT(ID)=SCDOSE(ID,IT);
              ERRY(ID)=SCDOSE2(ID,IT)*SCDOSE(ID,IT)/100.;
            ]
            IT2=IT2+1;
            IF(IT-3<10)[
               COMPNUM=CHAR((IT-3)+48);
            ]
            ELSEIF(IT-3<100)[
               COMPNUM=CHAR((IT-3)/10+48)//CHAR(MOD((IT-3),10)+48);
            ]
            ELSEIF(IT-3<1000)[
               COMPNUM=CHAR((IT-3)/100+48)//CHAR(MOD((IT-3),100)/10+48)//
                       CHAR(MOD(MOD((IT-3),100),10)+48);
            ]
            ELSE[ "do not label components past 999"
               COMPNUM=' ';
            ]
            SERIESTITLE='component '//COMPNUM;
            CALL XVGRPLOT(XPLOT, YPLOT, ERRY, NDOSE_ZONE, IT2, SERIESTITLE,
               XTITLE, YTITLE, GRAPHTITLE, TITLE,IOUTPLOT, TYPE, ZPLOTCHM(1),0);
         ]
       ]
       CLOSE(IOUTPLOT);
   ]
   ELSE [
       write(i_log,*);
       write(i_log,*)
     ' ************ failed to open .egsplot file for writing ********** ';
       write(i_log,*);
   ]
]
210  FORMAT(' ',T12,'TOTAL # CHARGED PARTICLE STEPS in DOSE REG.',T57,
             1PE10.3,' +/-',0PF4.1,'%'/
             ' ','# CHARGED PARTICLE STEPS in DOSE REG./INITIAL HISTORY',T57,
             1PE10.3,' +/-',0PF4.1,'%'/);
300 FORMAT(' ',T15,'TOTAL DOSE PER INCIDENT PARTICLE'/
             /T5,'DOSE     MASS           DOSE          ENERGY DEPOSITED '
             /T5,'ZONE      (g)           (Gy)                 (J)',
             /T5,'---- -----------  ------------------  ------------------');
302  FORMAT(' ',I6,3X,1PE10.3,2X,1PE10.3,'+/-',0PF4.1,'%',
            2X,1PE10.3,'+/-',0PF4.1,'%');
"303 FORMAT(' ',T10,'T-S  DOSE PER INCIDENT PARTICLE FOR ION CHAMBER'/
            " /T5,'DOSE     MASS           DOSE          ENERGY DEPOSITED '
            " /T5,'ZONE      (g)           (Gy)                 (J)',
            " /T5,'---- -----------  ------------------  ------------------');
304 FORMAT(' ',T10,'CONTAMINANT DOSE/INCIDENT PARTICLE FOR CM',I3/
             /T5,'DOSE     MASS           DOSE          ENERGY DEPOSITED '
             /T5,'ZONE      (g)           (Gy)                 (J)',
             /T5,'---- -----------  ------------------  ------------------');
305 FORMAT(' ',
'TOTAL DOSE EXCLUDING FAT PARTICLES PER INCIDENT PARTICLE (DBS ONLY)'/
             /T5,'DOSE     MASS           DOSE          ENERGY DEPOSITED '
             /T5,'ZONE      (g)           (Gy)                 (J)',
             /T5,'---- -----------  ------------------  ------------------');
:FILTFORM1: FORMAT(T2,I4,A14,T25,$);
:FILTFORM2: FORMAT(I5,$);
:FILTFORM3: FORMAT(A5,$);

RETURN;

END; "End of subroutine OSUMRY"
%L    TURN LISTING BACK ON IN CASE OFF IN MACRO FILE
%E     "beamnrc.mortran - start subroutine isource                        "
"*******************************************************************************
"
                            SUBROUTINE ISOURCE;
"                           ******************
"*******************************************************************************
"
"   Source input routine for BEAMnrc, particle position, direction, and energy.
"
"     This subroutine handles the inputs assoiciated with various source
"     options. For ISOURC<21, info re source energies are read here too.
"     Associated routines are:
"         SRCOUT   describes source for listing file
"         SRCOTO   does one time only source initialization
"         SRCHST   initializes variable for each history
"
"     Other options can be added - must get ISOURC and MONOEN (COMIN
"      USER-VARIANCE-REDIUCTION and IQIN from COMIN SCORE
"
"*******************************************************************************
"
"
$IMPLICIT-NONE;
;COMIN/CMs,GEOM,IO_INFO,MEDIA,MISC,SCORE,SOURCE,UPHIOT,USER,RANDOM,
       ENERGYSRC,RWPHSP,EGS-IO/;

"T>*****************************
"T>TYPE DECLARATIONS FOR ISOURCE
"T>*****************************
"T>
INTEGER I, "T>a loop index"
"        SWAPYES, T>set to 1 if you have to swap bytes in the phsp source"
"        IOS, T>an io status indicator"
        TEMPINT, "T>a dummy integer"
        LATCHM,NHSTRYM,IQINM,NPASSM, "T> temp. variables for source 21"
        egs_get_unit,i_spect,i_spcnam,len,ilen,lnblnk1,IZLAST1;
$REAL
   FNORM, "T>normalization for direction cosines
   TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,TEMP6,TEMP7,TEMP8, "T>for general use
   EINM,XINM,YINM,UINM,VINM,WTM,ZINM,WINM,Z_SCORE;
                                "T> temp. variables for source 21"

CHARACTER*256 TEXT;

COMIN/BMODEL/;

$LONG_INT tmp_long;

"*******************************************************************************
"
"                      INITIALIZATION AND INPUT
"                      ************************
"
INIT_ICM=0; "initialization "
MONOEN = 0; "Monoenergetic source"

OUTPUT;(' CHARGE OF THE INCIDENT BEAM(-1,0,1),'/' SOURCE CONFIGURATION');
OUTPUT;('      (0) Parallel beam incident from the front:(0),radius(cm),'/
        '                    incident direction cosines (U,V,W)'/);
OUTPUT;('  or  (1) Point source on axis incident from the front,'/
        '           DISTZ,distance of source to VERY front of first CM.'/
        '           RBEAM,beam radius (cm) or flag indicating rectangular(<0),'/
        '           GAMMA,1/2 angle(degrees) of source if RBEAM=0.0,'/
        '           XINL,XINU,YINL,YINU, dimensions of rectangular beam if'/
        '           RBEAM<0.'/);
OUTPUT;('  or  (3) Uniform isotropically radiating source incident within CMs:'/
        '          inner radius of vertical ring (if next input >=0) or Z'/
        '          of centre of horizontal cylinder (if next input < 0) in cm,'/
        '          outer radius of vertical ring (if >=0) or -radius of '/
        '          horizontal cylinder (if <0) in cm, Z of top of vertical'/
        '          ring or min. X of horizontal cylinder in cm, Z of bottom'/
        '          of vertical ring or max. X of horizontal cylinder in cm,'/
        '          i_dsb (set to 1 to use directional source biasing),'/
        '          splitcm_dsb (CM no. at which, upon entering, photons '/
        '          are split and radially redistributed--set to 0 for no'/
        '          splitting/redistribution), dsb_delta (min. linear distance'/
        '          between split/redistributed photons projected to SSD'/
        '          in cm)'/);
OUTPUT;('  or  (5) NRC swept beam, cone 1/2 angle (in degrees)'/
        '                    radius of beam spot (in cm)'/);
OUTPUT;('  or  (6) Parallel rectangular beam incident along Z-axis:(6),'/
        '                    centred at (Xo,Yo), half-widths: Xh, Yh (cm)'/
        '                    (0, 6, Xo, Yo, Xh, Yh)'/);
OUTPUT;('  or  (7) Scanning beam, scanning field size to 100 cm '/
        '                    ratio of the frequencies in Y/X directions'/
        '                    spot size at the initial point. '/);
OUTPUT;('  or  (8) Scanning point source for MM50--uniform field coverage:'/
        '                    (8), SSD (defaults to 100 cm), radius of'/
        '                    field at SSD (defaults to RMAX_CM(1)), radius'/
        '                    of beam spot at Z=0 (defaults to 0).'/
        '                    Note that this option assumes the point'/
        '                    source is at Z=0'/);
OUTPUT;('  or  (9) Scanning point source for MM50--discrete field coverage:'/
        '                    (9), SSD (defaults to 100 cm), # of '/
        '                    discrete points at SSD.'/
        '                    Note that this option assumes the point'/
        '                    source is at Z=0'/);
OUTPUT;('  or (10) Parallel circular beam incident on an x-ray target:'/
        '                    (10), radius(cm), direction cosines (U,V)'/
        '                    default to (-1,0), (W is set to 0)'/);
OUTPUT;('  or (13) Parallel rectangular beam incident on an x-ray target:'/
  '                    (13), half-width(cm), half-height (cm)'/
  '                    direction cosines (U,V,W), default to (-1,0,0)'/);
OUTPUT;
('  or (15) NRC swept beam with radial divergence and intensity distribution:'/
'                    (15),cone 1/2 angle (in degrees), Z of apex of cone (cm),'/
'                    radius at which beam divergence angle is defined (cm),'/
'                    beam divergence angle (degrees)'/);
OUTPUT;('  or (19) Parallel elliptical beam with gaussian in X and Y:'/
        '                (19),sigma of gaussian distribution in X (if > 0) or'/
        '                -FWHM of gaussian distribution in X (if < 0) in cm,'/
        '                incident direction cosines (U,V,W),'/
        '                mean angular spread (degrees, none if <=0,'/
        '                if set >0 then overrides U,V,W inputs),'/
        '                sigma (if > 0) or -FWHM (if < 0) of gaussian'/
        '                distribution in Y in cm (if = 0 then defaults to'/
        '                value in X-direction)'/);
OUTPUT;('  or (21) Full phase-space of each particle read from unit 42'/
        '                    component module # '/
        '                      (particles incident on the front of this CM),'/
        '                    no. of times to recycle each particle'/
        '                      (calculated automatically if set to 0),'/
        '                    no. of parallel jobs (if using pprocess script),'/
        '                    job no. (if using pprocess),'/
        '                    ISRC_DBS (1 if source generated using DBS),'/
        '                    RSRC_DBS,SSDSRC_DBS (splitting radius, SSD used'/
        '                       to generate this source--only if ISRC_DBS=1),'/
        '                    ZSRC_DBS (Z where the source was generated--'/
        '                       only if ISRC_DBS=1)'/
        '                    (0, 21, INIT_ICM, 0,0,0,0,0,0,0)'/);
OUTPUT;
   ('  or (23) Full BEAM simulation source incident from user-defined angle'/
        '                    component module # '/
        '                      (particles incident on the front of this CM),'/
        '                    ISRC_DBS (1 if source using DBS),'/
        '                    angle of rotation about X axis (ALPHA24),'/
        '                    angle of rotation about Y axis (BETA24),'/
'                    distance of point of rotation above INIT_ICM (DIST24)'/
     '                    (0, 23, INIT_ICM, ISRC_DBS,ALPHA24,BETA24,DIST24)'/);
OUTPUT;('  or (24) Full phase-space incident from user-defined angle'/
        '          Input line 1:'/
        '                    component module # '/
        '                      (particles incident on the front of this CM),'/
        '                    no. of times to recycle each particle'/
        '                      (calculated automatically if set to 0),'/
        '                    no. of parallel jobs (if using pprocess script),'/
        '                    job no. (if using pprocess),'/
        '                    ISRC_DBS (1 if source generated using DBS),'/
        '                    RSRC_DBS,SSDSRC_DBS (splitting radius, SSD used'/
        '                       to generate this source--only if ISRC_DBS=1),'/
        '                    ZSRC_DBS (Z where the source was generated--'/
        '                       only if ISRC_DBS=1)'/
        '                    (0, 24, INIT_ICM, 0,0,0,0,0,0,0)'/
        '          Input line 2:'/
        '                    angle of rotation about X axis (ALPHA24),'/
        '                    angle of rotation about Y axis (BETA24),'/
'                    distance of point of rotation above INIT_ICM (DIST24)'/);
OUTPUT;('  or (31) Beam characterization model, component module #',/
        '                    (particles incident on the front of this CM)'/
        '                    (0, 31, CMSOU,0.,0.,0.)'/);
OUTPUT;(' IQIN,ISOURC, up to 8 reals: ',$);
;MINPUT (ISOURCE) IQIN,ISOURC,TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,TEMP6,TEMP7,TEMP8;
(2I12,8F15.0);
IF( ISOURC < 0 ) [
    ISOURC = -ISOURC; INIT_ICM = -1;
]
IF( ISOURC > 1000 ) [
    INSIDE_FLAG = ISOURC/1000; ISOURC = ISOURC - INSIDE_FLAG*1000;
]
ELSE [ INSIDE_FLAG = 0; ]
IF( INIT_ICM < 0 ) [
    ;MINPUT (ISOURCE) Z_SOURCE; (F15.0);
]

OUTPUT IQIN,ISOURC,TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,TEMP6,TEMP7,TEMP8;
(I4,I4,8F10.4);
IF((IQIN  < -1) |  (IQIN >  1)) IQIN=0;
IF(ISOURC < 21)OUTPUT IQIN;(T20,' SOURCE CHARGE is ',I3);
OUTPUT ISOURC; (T20,' ISOURC =',I3);
IF( INSIDE_FLAG > 0 ) [ OUTPUT INSIDE_FLAG; (T20,' IFLAG  =',I3); ]

" ISOURC = 0   Frontal parallel beam"
" **********
IF(ISOURC = 0)[
    RBEAM=TEMP1;
    FNORM=TEMP2**2+TEMP3**2+TEMP4**2;
    IF(FNORM =  0.0)[
        UINC=0.0;VINC=0.0;WINC=1.0;
    ]
    ELSE[
        FNORM=SQRT(FNORM);
        UINC=TEMP2/FNORM;VINC=TEMP3/FNORM;WINC=TEMP4/FNORM;
    ]
    OUTPUT RBEAM,UINC,VINC,WINC;
       (' PARALLEL BEAM INCIDENT FROM THE FRONT(+VE Z-AXIS)'/
        ' RADIUS OF BEAM AT THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
        ' X-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
    TEMP5=1.E30;  "Radius limited to RMAX_CM(1) in SRCOTO"
    IF ((RBEAM  < 0.0) |  (RBEAM >  TEMP5)) RBEAM=TEMP5;
    100 FORMAT(' ',2(I2,' '),4(G14.6),', IQIN,ISOURCE etc');
    200 FORMAT(' ',I1);
    300 FORMAT(' ',I3);
    400 FORMAT(' ',2(G14.7,' '));
    500 FORMAT(' ',79('*')//T30,'SOURCE PARAMETERS'//' ',79('*')/);
]

" ISOURC = 1 FRONTAL POINT SOURCE"
" **********
ELSEIF(ISOURC = 1)[
    DISTZ=TEMP1;RBEAM=TEMP2;GAMMA= TEMP3;
    IF(RBEAM<0.)["rectangular beam"
       XINL=TEMP4;XINU=TEMP5;YINL=TEMP6;YINU=TEMP7;
    ]
    IF (DISTZ <= 0.0) DISTZ=100.;
    IF (RBEAM > 0.0 & GAMMA ~=0.0)[
      OUTPUT RBEAM,GAMMA; (//' ****Beam radius (=',F10.3,') and half-angle(=',
      F10.3,') are both non-zero****'/' We ignore the half-angle'//);
      GAMMA = 0.0;
    ]
    IF (RBEAM > 0.0)[
       OUTPUT DISTZ,RBEAM;
          (' Point source on axis incident from the front'/
           ' Distance OF  source to VERY front of first CM:',T60,F10.4,' cm'/
           ' Radius of the beam at front of first CM:', T60,F10.4,' cm'/);
    ]
    ELSEIF (RBEAM < 0.0)[
       OUTPUT DISTZ,XINL,XINU,YINL,YINU;
          (' Point source on axis incident from the front'/
           ' Distance of  source to VERY front of first CM:',T60,F10.4,' cm'/
           ' Beam is rectangular on front of first CM with:'/
           '             X boundaries:',F10.4,' - ',F10.4,' cm'/
           '             Y boundaries:',F10.4,' - ',F10.4,' cm'/);
    ]
    ELSE [
       OUTPUT DISTZ,GAMMA;
          (' Point source on axis incident from the front'/
           ' Distance of  source to VERY front of first CM:',T60,F10.4,' cm'/
           ' Half-angle of circular source =',T60,F10.4,' deg'/);
    ]

    IF(RBEAM=0. & GAMMA < 0.0) [OUTPUT GAMMA;(/'  ****Asked for negative angle'
       ,'=',F12.3/'      Its absolute value is used');
       GAMMA = ABS(GAMMA);
    ]
    IF (RBEAM=0. & GAMMA >= 90.)[
      OUTPUT;(//' ***Half-angle must be less than 90 degrees to hit target'/
      '     Angle reduced to 89 degrees'//);
      GAMMA = 89.;
    ]
]

ELSEIF(ISOURC = 3)[ "ISOTROPICALLY RADIATING DISK"
    RBEAM=TEMP2;
    RBEAM2 = RBEAM**2;
    RMINBM = TEMP1;
    IF(RBEAM >= 0)[
       IF(RMINBM < 0)[
          OUTPUT;(//' ***ERROR IN SOURCE 3:'/ ' RMINBM < 0'//);
          IF(RBEAM=0)[
             OUTPUT;(//' NB: IF YOU WANT A HORIZONTAL CYLINDER OF 0 RADIUS,'/
                       '     SET RBEAM TO A VERY SMALL -VE NUMBER'//);
          ]
          $CALL_EXIT(1);
       ]
       IF(RMINBM > RBEAM)[
          OUTPUT;(//' ***ERROR IN SOURCE 3:'/ ' RMINBM > RBEAM'//);
          IF(RBEAM=0)[
             OUTPUT;(//' NB: IF YOU WANT A HORIZONTAL CYLINDER OF 0 RADIUS,'/
                       '     SET RBEAM TO A VERY SMALL -VE NUMBER'//);
          ]
          $CALL_EXIT(1);
       ]
       RMINSQ = RMINBM**2;
    ]
    ZSMIN=TEMP3;ZSMAX=TEMP4;
    IF(ZSMIN > ZSMAX)[
       OUTPUT;(//' ***ERROR IN SOURCE 3:'/ ' ZSMIN > ZSMAX'//);
       $CALL_EXIT(1);
    ]
    IF(RBEAM >= 0)[
       OUTPUT RMINBM,RBEAM,ZSMIN,ZSMAX;
       (' UNIFORM ISOTROPICALLY RADIATING RING CENTRED ON Z-AXIS:'/
        ' INNER RADIUS:',T60,F10.4,' cm' /
        ' OUTER RADIUS:',T60,F10.4,' cm' /
        ' Z OF TOP OF RING:',T60,F10.4,' cm' /
        ' Z OF BOTTOM OF RING:',T60,F10.4,' cm' /);
    ]
    ELSE[
       OUTPUT ABS(RBEAM),RMINBM,ZSMIN,ZSMAX;
       (' UNIFORM ISOTROPICALLY RADIATING CYLINDER CENTRED || TO X-AXIS:'/
        ' RADIUS:',T60,F10.4,' cm' /
        ' Z POSITION OF CENTRE OF CYLINDER:',T60,F10.4,' cm'/
        ' MIN. X OF CYLINDER:',T60,F10.4,' cm' /
        ' MAX. X OF CYLINDER:',T60,F10.4,' cm' /);
    ]
    i_dsb=temp5; dsb_aeff = 1;
    IF(i_dsb=1)[
      IF(IBRSPL=2)[
          splitcm_dsb=temp6; dsb_delta=temp7;
          OUTPUT; (' Directional source biasing (DSB) used in conjunction with'/
              ' directional bremsstrahlung splitting (DBS).'/);
          IF(splitcm_dsb <= 0 ) [
             OUTPUT; (' NOT USING ROTATIONAL SYMMETRY'/);
              write(*,*) '===> split_cm = ', splitcm_dsb;
          ]
          ELSE [
            IF( dsb_delta > 0 ) [
              call dsb_init_sampling(dsb_delta,fs,dsb_aeff,$DSB_MAX_BIN,
                             dsb_nbin,dsb_rbin,dsb_prob,dsb_ibin);
            ]
            IF( dsb_delta > 0 ) [
              OUTPUT splitcm_dsb,dsb_delta*fs,dsb_nbin,dsb_aeff;
              (' Particles will be split on entering CM no. ',I10/
              ' and rotated to positions at least ',F12.5,' cm apart.'/
              ' This requires ',i4,' sampling bins and has Aeff = ',f8.5/);
            ]
            ELSE [
              OUTPUT; (' NOT USING ROTATIONAL SYMMETRY'/);
              write(*,*) '===> dsb_delta = ', dsb_delta;
            ]
          ]
      ]
      ELSE[
       OUTPUT;
          (' Directional source biasing (DSB) selected, but directional'/
           ' bremsstrahlung splitting (DBS) is not.  DSB requires DBS.'/
           ' DSB turned off for now.'/);
          i_dsb=0;
      ]
    ]
    ELSE[
       i_dsb=0;
    ]
]

" ISOURC = 5   NRC swept beam"
" **********
ELSEIF(ISOURC = 5)[
    GAMMA=TEMP1;RBEAM=TEMP2;
    IF(GAMMA < 0.0) [OUTPUT GAMMA;(/'  ****Asked for negative angle'
       ,'=',F12.3,'deg'/'      Its absolute value is used');
       GAMMA = ABS(GAMMA);
    ]
    IF(RBEAM < 0.0) [OUTPUT RBEAM;(/'  ****Asked for negative BEAM RADIUS'
       ,'=',F12.3/'      It is set to zero');
       RBEAM = 0.0;
    ]
    "RBEAM > area of CM handled below"
    IF(GAMMA > 89.0) [OUTPUT;(/' ***REDUCED GAMMA to 89 degrees');
      GAMMA = 89.;
    ]
    "It is hard to do more checks since large angles may be valid here"
    OUTPUT GAMMA,RBEAM;
       (' NRC SWEPT BEAM '/
        ' Half angle of cone',T60,F10.4,' deg'/
        ' RADIUS OF THE BEAM SPOT AT FRONT of FIRST CM:',
        T60,F10.4,' cm'/);
]

" ISOURC = 6  Frontal parallel beam with rectangular field"
" **********
ELSEIF(ISOURC = 6)[
    XBEAM0=TEMP1;YBEAM0=TEMP2;XBEAM=TEMP3;YBEAM=TEMP4;
    UINC=0.0;VINC=0.0;WINC=1.0;"beam along z-axis"
    OUTPUT XBEAM0,YBEAM0,XBEAM,YBEAM;
       (' PARALLEL RECTANGULAR BEAM INCIDENT ALONG Z-AXIS'/
        ' CENTRED AT (Xo,Yo) = (',T60,2F10.4,')'/
        ' HALF-WIDTH IN X DIRECTION:',T60,F10.4/
        ' HALF-WIDTH IN Y DIRECTION:',T60,F10.4/
        ' (Note: beam edge limited to simulation geometry later!)'/);
    "note: Beam edge will be limited to RMAX_CM(1) in SRCOTO"
]

ELSEIF(ISOURC = 22)[
    XBEAM0=TEMP1;YBEAM0=TEMP2;XBEAM=TEMP3;YBEAM=TEMP4;
    UINC=0.0;VINC=0.0;WINC=1.0;"beam along z-axis"
    OUTPUT XBEAM0,YBEAM0,XBEAM,YBEAM;
    (' PARALLEL RECTANGULAR RING INCIDENT ALONG Z-AXIS'/
     ' CENTRED AT (Xo,Yo) = (',T60,2F10.4,')'/
     ' HALF-WIDTH IN X DIRECTION:',T60,F10.4/
     ' HALF-WIDTH IN Y DIRECTION:',T60,F10.4/
     ' (Note: beam edge limited to simulation geometry later!)'/);
      "note: Beam edge will be limited to RMAX_CM(1) in SRCOTO"
]

" ISOURC = 7   the scanning beam  "
"*********
ELSEIF(ISOURC = 7) [
      FD_AT100=TEMP1;
      IF( FD_AT100<=0.0 )
      [OUTPUT; (' SCANNING FIELD SIZE ERROR!!!'); $CALL_EXIT(1); ]
      IRATIO_YXF=TEMP2*2;
      IF(IRATIO_YXF<=0) [ IRATIO_YXF=13; ]  " default to manufacture set"
      IF( MOD(IRATIO_YXF, 2)=0 )[ IRATIO_YXF=IRATIO_YXF+1; ]
                " set to odd number, see the scanning system ref. "
      XSCAN_UNIT=FD_AT100*2.0/IRATIO_YXF; " the scanning step for half cycle
      RBEAM=TEMP3;
      IF( RBEAM<=0.0 ) [ RBEAM=0.01; ]  " default size "
      OUTPUT  FD_AT100, IRATIO_YXF, RBEAM;
              (' SCANNING BEAM WITH: ',
              /'          SCANNING FIELD SIZE AT SSD=100 : ', F15.7,
              /'          THE FREQUENCY RATIO BETWEEN Y/X: ', I5,
              /'          THE SPOT SIZE AT THE INITIAL POINT:', F15.7);
]

" ISOURC = 8   scanned point source uniform on xy plane for MM50  "
"*********

ELSEIF(ISOURC = 8)[
    DISTZ=TEMP1;RBEAM=TEMP2;RBEAM0=TEMP3;
    IF (DISTZ <= 0.0) DISTZ=100.;
    IF (RBEAM0 < 0.0) RBEAM0=0.;
    IF (RBEAM > 0.0)[
        OUTPUT DISTZ,RBEAM,RBEAM0;
        (' MM50 scanned point on axis at Z=0, uniform circular field at SSD'/
         ' SSD                      :',T60,F10.4,' cm'/
         ' radius of the beam at SSD :', T60,F10.4,' cm'/
         ' radius of beam spot at Z=0 :',T60,F10.4,' cm'/);
    ]
    IF(RBEAM <= 0.0) [OUTPUT RBEAM;(/'  ****Asked for negative BEAM RADIUS'
       ,'=',F12.3/'      It will be reset to RINMAX.');
       "RINMAX is related to RMAX_CM(1) which is not available yet"
    ]
]

" ISOURC = 9   discrete point source on xy plane for MM50  "
"*********

ELSEIF(ISOURC = 9)[
    DISTZ=TEMP1;NPTS_SRC9=TEMP2;
    IF (DISTZ <= 0.0) DISTZ=100.;
    IF(NPTS_SRC9>$MAXPTS_SRC9)[
       NPTS_SRC9=$MAXPTS_SRC9;
       OUTPUT $MAXPTS_SRC9; (//'***WARNING IN SOURCE 9'/
              ' Number of discrete points chosen > max. allowed'/
              ' Number of points reduced to',I4//);
       WRITE(IOUTLIST,
          '(//''***WARNING IN SOURCE 9''/
          '' Number of discrete points chosen > max. allowed''/
          '' Number of points reduced to'',I4//)') $MAXPTS_SRC9;
    ]
    ELSEIF(NPTS_SRC9<=0)[
       NPTS_SRC9=1;
       OUTPUT; (//'***WARNING IN SOURCE 9'/
              ' Number of discrete points chosen <= 0'/
              ' Number of points reset to 1'//);
       WRITE(IOUTLIST,
          '(//''***WARNING IN SOURCE 9''/
          '' Number of discrete points chosen <= 0''/
          '' Number of points reset to 1''//)');
    ]
    OUTPUT DISTZ,NPTS_SRC9;
     (/' MM50 SCANNED POINT SOURCE ON AXIS AT Z=0, DISCRETE COVERAGE AT SSD'/
       '                              SSD:',T60,F10.4,' cm'/
       ' NUMBER OF DISCRETE POINTS AT SSD:', T60,I10,/);
    OUTPUT NPTS_SRC9; (' INPUT (X,Y,PROBABILITY) FOR THE',I4,
                  ' DISCRETE POINTS AT THE SSD:');
    FNORM = 0.0;
    DO I=1,NPTS_SRC9[
       OUTPUT I;(' For point ',I4,' X,Y,prob : ',$);
       ;MINPUT (ISOURCE) X_SRC9(I),Y_SRC9(I),PROB_SRC9(I);(3F15.0);
       OUTPUT X_SRC9(I),Y_SRC9(I),PROB_SRC9(I); (3F10.4);
       FNORM=FNORM+PROB_SRC9(I);
    ]
    "normalize and convert to cumulative prob distn"
    DO I=1,NPTS_SRC9[
       PROB_SRC9(I)=PROB_SRC9(I)/FNORM;
       IF(I>1)[ PROB_SRC9(I)=PROB_SRC9(I)+PROB_SRC9(I-1); ]
    ]
]

" ISOURC = 10  parallel circular beam incident on an x-ray target"
" **********
ELSEIF(ISOURC = 10)[
    RBEAM=TEMP1;
    FNORM=TEMP2**2+TEMP3**2+TEMP4**2;
    IF(FNORM =  0.0)[
        UINC=-1.;VINC=0.0;WINC=0.0;
    ]
    ELSE[
        FNORM=SQRT(FNORM);
        UINC=TEMP2/FNORM;VINC=TEMP3/FNORM;WINC=TEMP4/FNORM;
    ]
    IF(UINC >= 0.0)[
        UINC=-UINC;
        OUTPUT UINC;
        (/' BEAM MUST FACE Z-AXIS, UINC HAS BEEN RE-SET TO ',F8.3/);
    ]
    IF (RBEAM  < 0.0) RBEAM=0.2;  "default to 0.2 cm"
    OUTPUT RBEAM,UINC,VINC,WINC;
       (' PARALLEL BEAM INCIDENT ON X-RAY TARGET (FACING X-AXIS)'/
        ' RADIUS OF CROSSECTION AREA OF THE BEAM :',T60,F10.4,' cm'/
        ' X-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
]

" ISOURC = 13   parallel rectangular beam incident on an x-ray target"
" **********
ELSEIF(ISOURC = 13)[
    YBEAM=TEMP1;ZBEAM=TEMP2;
    FNORM=TEMP3**2+TEMP4**2;
    IF(FNORM =  0.0)[
        UINC=-1.;VINC=0.0;WINC=0.0;
    ]
    ELSE[
        FNORM=SQRT(FNORM);
        UINC=TEMP3/FNORM;VINC=TEMP4/FNORM;WINC=0.;
    ]
    IF(UINC >= 0.0)[
        UINC=-UINC;
        OUTPUT UINC;
        (/' BEAM MUST FACE Z-AXIS, UINC HAS BEEN RE-SET TO ',F8.3/);
    ]
    IF (YBEAM  < 0.0) YBEAM=0.2;
    IF (ZBEAM  < 0.0) ZBEAM=0.2;"default to 0.2 mm"
    OUTPUT YBEAM,ZBEAM,UINC,VINC,WINC;
       (' PARALLEL BEAM INCIDENT ON X-RAY TARGET (FACING X-AXIS)'/
        ' HALF-WIDTH OF CROSSECTION AREA OF THE BEAM :',T60,F10.4,' cm'/
        ' HALF-HEIGHT OF CROSSECTION AREA OF THE BEAM :',T60,F10.4,' cm'/
        ' X-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
]

ELSEIF(ISOURC = 15)["Radial intensity distribution"
    GAMMA=TEMP1; ZFOCUS=TEMP2; THETAIN=TEMP4; RTHETAIN=TEMP3;

    IF(GAMMA < 0.0) [OUTPUT GAMMA;(/'  ****Asked for negative angle'
       ,'=',F12.3,'deg'/'      Its absolute value is used');
       GAMMA = ABS(GAMMA);
    ]

    OUTPUT GAMMA,ZFOCUS,THETAIN,RTHETAIN;
       (' NRC SWEPT BEAM with RADIAL INTENSITY DISTRIBUTION and DIVERGENCE'/
        ' Half angle of swept cone =',T60,F10.4,' degrees'/
        ' Z of apex of cone = ',T60,F10.4,' cm'/
        ' Divergence angle of beam = ',T60,F10.4,' degrees'/
        ' Radius at which divergence angle defined = ',T60,F10.4,' cm'/);

"    OUTPUT;(' LOCAL INPUT(TEMP3=0) OR EXTERNAL FILE(TEMP3=1): ',$);
"    MODEIN = 1;  needed temp3 for RTHETAIN"
    "IF(MODEIN.NE.1) MODEIN=0;  DEFAULT"
"    OUTPUT;(/' RADIAL DISTRIBUTION:');
"    IF(MODEIN.EQ.0)[
        "INPUT FROM KEYBOARD OR .INP FILE"
"        OUTPUT;(' NUMBER OF RADIAL BINS: ',$);
"        MINPUT (ISOURCE) NRDIST;(I15);
"        IF((NRDIST.LT.1).OR.(NRDIST.GT.100))[
"            OUTPUT;
"            (/' *** NUMBER RADIAL BINS OUT OF RANGE (<1 OR >100),',
"            ' RESET TO 100 ***');
"            NRDIST=100;
"            ]
"        OUTPUT NRDIST;(' INPUT',I4,' SETS OF RDISTF,RPDF IN 2F20.0 FORMAT');
"        OUTPUT;('   RDISTF INCREASING IN SIZE, RPDF NON-NEGATIVE');
"        DO IB20=1,NRDIST[
"            MINPUT (ISOURCE) RDISTF(IB20),RPDF(IB20);(2F20.0);
"            ]
"        ]
"    ELSE[
        "EXTERNAL FILE INPUT"
        OUTPUT;
(' INPUT NAME OF FILE WITH RADIAL INTENSITY DISTRIBUTION (up to 80 CHAR '/
 ' WITH .EXT): '/);
        READ(i_input,'(A256)',END=:EOF_ISOURCE:) SPCNAM;
      OUTPUT SPCNAM;(/' READ INPUT RADIAL INTENSITY DISTRIBUTION FROM: '/A256);
        call replace_env(SPCNAM);
        i_spcnam=9;
        i_spcnam=egs_get_unit(i_spcnam);
        IF(i_spcnam<0)[
           $egs_fatal(*,'failed to get a free Fortran I/O unit for file.');
        ]
        OPEN(UNIT=i_spcnam,STATUS='OLD',FILE=SPCNAM);
        READ(i_spcnam,*)NRDIST;
        IF((NRDIST.LT.1).OR.(NRDIST.GT.100))[
            OUTPUT;
            (' *** NUMBER RADIAL BINS OUT OF RANGE (<1 OR >100),',
            ' RESET TO 100 ***');
            NRDIST=100;
            ]
        READ(i_spcnam,*)(RDISTF(IB20),RPDF(IB20),IB20=1,NRDIST);
        CLOSE(UNIT=i_spcnam);
        OUTPUT NRDIST;('    HAVE READ',I5,' INPUT RADIAL BINS FROM FILE');

    "DO A CHECK ON THE RADIAL DISTRIBUTION"
    ICOUNT=0;
    "RLAST=0;  daryoush changed below"
    RLAST=-1000.;
    IERROR=0;
    :R-DIST-INPUT:LOOP[
        ICOUNT=ICOUNT+1;
        IF(ICOUNT.GT.NRDIST)[EXIT:R-DIST-INPUT:;]
         IF(RDISTF(ICOUNT).LE.RLAST)[
            " IERROR=1;   daryoush, to allow symmetric input"
            OUTPUT;
            (' *** RDISTF>=LAST ONE. MAYBE NOT ALLOWED,',
            ' CHECK THIS OUT.');
            ]
        ELSEIF(RPDF(ICOUNT).LT.0.0)[
            IERROR=1;
            OUTPUT;(' PDF < 0 NOT ALLOWED,',
            ' TERMINATING RADIAL INTENSITY DISTRIBUTION INPUT');
            ]
        IF(IERROR.EQ.1)[
            ICOUNT=ICOUNT-1;
            IF(ICOUNT.EQ.0)[
                OUTPUT;(' *** NO RADIAL INTENSITY DISTRIBUTION DEFINED,',
                ' STOPPING EXECUTION ***');
                $CALL_EXIT(1);
                ]
            OUTPUT ICOUNT;
            (' RADIAL INTENSITY DITRIBUTION INPUT APPEARS TO BE INCOMPLETE,',
            ' NRDIST RESET TO ',I12);
            NRDIST=ICOUNT;
            EXIT:R-DIST-INPUT:;
            ]
        RLAST=RDISTF(ICOUNT);
        ]

    OUTPUT RDISTF(1),RDISTF(NRDIST);
    ('    UPPER BIN RADII RANGE FROM ',F12.3,' TO',F12.3,' cm');

    OUTPUT;(/' AND NOW THE RADIAL INTENSITY DISTRIBUTION...');

    "now multiply the PDF by area and find the normalization factor"
    "note that RCDF used to store the cumulative distribution function"
    "but now it just stores RPDF*area"
    FNORM20=0;
    DO IB20=1,NRDIST[
       IF(IB20>1)[
         RCDF(IB20)=RPDF(IB20)*(RDISTF(IB20)**2-RDISTF(IB20-1)**2);
       ]
       ELSE[
         RCDF(IB20)=RPDF(1)*RDISTF(1)**2;
       ]
       FNORM20=FNORM20+RCDF(IB20);
    ]
    "now do the normalization and find the min rad**2 and the area of"
    "each radial bin"
    DO IB20=1,NRDIST[
        RCDF(IB20)=RCDF(IB20)/FNORM20;
        IF(IB20>1)[
           RCDFIN(IB20,1)=RDISTF(IB20-1)**2;
        ]
        ELSE[
           RCDFIN(IB20,1)=0.0;
        ]
        RCDFIN(IB20,2)=RDISTF(IB20)**2-RCDFIN(IB20,1);
    ]
    "now put the bins with maximum probability first"
    DO IB20=1,NRDIST-1[
       DUMMY15 = RCDF(IB20); "stores maximum value"
       AK= IB20;  "stores index of max. value"
       DO K20=IB20+1,NRDIST[
          IF(RCDF(K20) > DUMMY15)[
               DUMMY15=RCDF(K20);
               AK=K20;
          ]
       ]
       K20 = AK;
       TEMP5 = RCDF(K20); RCDF(K20) = RCDF(IB20); RCDF(IB20) = TEMP5;
       TEMP5 = RCDFIN(K20,1); RCDFIN(K20,1)=RCDFIN(IB20,1);
               RCDFIN(IB20,1)=TEMP5;
       TEMP5 = RCDFIN(K20,2); RCDFIN(K20,2)=RCDFIN(IB20,2);
               RCDFIN(IB20,2)=TEMP5;
    ]

    OUTPUT;(/'                               ');
    OUTPUT;( '    UPPER RADIUS OF BIN(cm)         PROB. '/);
    OUTPUT (RDISTF(IB20),RPDF(IB20),IB20=1,NRDIST);(E20.7,6X,E20.7);
    OUTPUT;(//);
]
" ISOURC = 18 parallel beam with gaussian radial distribution"
" **********
"inputs are the same as for source 19"
ELSEIF(ISOURC = 18)[
    FNORM=TEMP2**2+TEMP3**2+TEMP4**2;
    IF(FNORM =  0.0)[
        UINC=0.0;VINC=0.0;WINC=1.0;
    ]
    ELSE[
        FNORM=SQRT(FNORM);
        UINC=TEMP2/FNORM;VINC=TEMP3/FNORM;WINC=TEMP4/FNORM;
    ]
    IF(TEMP1>=0) ["user entered sigma of beam"
        RBEAM=TEMP1;
        OUTPUT RBEAM,UINC,VINC,WINC;
       (' PARALLEL BEAM INCIDENT FROM FRONT WITH GAUSSIAN RADIAL DISTRIBUTION'/
        ' SIGMA OF BEAM AT THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
        ' X-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
    ]
    ELSE["user entered FWHM of beam"
        RBEAM=-0.42466*TEMP1;
        OUTPUT -TEMP1,UINC,VINC,WINC;
       (' PARALLEL BEAM INCIDENT FROM FRONT WITH GAUSSIAN RADIAL DISTRIBUTION'/
        ' FWHM OF BEAM AT THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
        ' X-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
    ]
    TEMP5=1.E30;  "Radius limited to RMAX_CM(1) in SRCOTO"
    IF ((RBEAM  < 0.0) |  (RBEAM >  TEMP5)) RBEAM=TEMP5;
]
" ISOURC = 19 parallel beam with 2-D gaussian X-Y distribution plus"
" plus angular spread"
" **********
ELSEIF(ISOURC = 19)[
    FNORM=TEMP2**2+TEMP3**2+TEMP4**2;
    IF(FNORM =  0.0)[
        UINC=0.0;VINC=0.0;WINC=1.0;
    ]
    ELSE[
        FNORM=SQRT(FNORM);
        UINC=TEMP2/FNORM;VINC=TEMP3/FNORM;WINC=TEMP4/FNORM;
    ]
    IF( TEMP1 >= 0 ) [ RBEAM=TEMP1; ] ELSE [ RBEAM=-0.42466*TEMP1; ]
    IF( TEMP6 > 0 ) [ RBEAMY=TEMP6; ]
    ELSEIF (TEMP6 < 0 ) [ RBEAMY=-0.42466*TEMP6; ]
    ELSE [ RBEAMY=RBEAM; ]
    xo_src19 = temp7; yo_src19 = temp8;
    OUTPUT RBEAM,RBEAMY,xo_src19,yo_src19;
    (' PARALLEL ELLIPTICAL BEAM INCIDENT FROM FRONT WITH GAUSSIAN DISTRIBUTION'/
     ' IN X AND Y:'/
     ' X-SIGMA OF BEAM AT THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
     ' Y-SIGMA OF BEAM AT THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
     ' X-POSITION OF MIDPOINT OF ELLIPTICAL SPOT:',T60,F10.4,' cm'/
     ' Y-POSITION OF MIDPOINT OF ELLIPTICAL SPOT:',T60,F10.4,' cm');
    "IF(TEMP1>=0) [""user entered sigma of beam"
    "    RBEAM=TEMP1;"
    "    OUTPUT RBEAM;"
    "(' PARALLEL BEAM INCIDENT FROM FRONT WITH 2-D GAUSSIAN X-Y DISTRIBUTION'/"
    "    ' SIGMA OF BEAM AT THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm');"
    "]"
    "ELSE[""user entered FWHM of beam"
    "    RBEAM=-0.42466*TEMP1;"
    "    OUTPUT -TEMP1;"
    "(' PARALLEL BEAM INCIDENT FROM FRONT WITH 2-D GAUSSIAN X-Y DISTRIBUTION'/"
    "    ' FWHM OF BEAM AT THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm');"
    "]   "
    IF( temp5 > 0 ) [ sigma_src19 = (temp5*3.1415926/180)**2;
        OUTPUT TEMP5;
       (' MEAN ANGULAR SPREAD ABOUT Z AXIS:',T60,F10.4,' degrees'/);
    ]
    ELSE [ sigma_src19 = -1;
        OUTPUT UINC,VINC,WINC;
       (' X-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
    ]
]

" ISOURC = 21 or 24  Full phase space for each particle"
"************
ELSEIF(ISOURC = 21 | ISOURC=24)[
    "External file input"
    OUTPUT;
    (' FULL PHASE-SPACE TO BE READ FROM UNIT 42...'/
    ' INPUT NAME OF FILE WITH PHASE SPACE DATA(1 TO 256 CHARS,',
    'WITH .EXT)'/' : ',$);
    READ(i_input,'(A256)',END=:EOF_ISOURCE:)SPCNAM;
    OUTPUT SPCNAM;(/' READ PHASE SPACE INFORMATION FROM: '/A256);

    call replace_env(SPCNAM);

    i_iaea_in=0; "assume not in IAEA format"

    inquire(file=SPCNAM,opened=phsp_open);
  IF(phsp_open)[
      OUTPUT;(/' Phase space source already open.  Will assume that '/
                ' DOSXYZnrc Source 20 is using this BEAM code as '/
                ' an initial geometry.  Will not attempt to '/
                ' open phase space source.'/);
      MONOEN = 2; "flag for polyenergetic beam from phase-space information
      IQIN = 9;
      INIT_ICM=TEMP1;
      EKMAXSRC=TEMP2; "have to do this for a conditional statement"
                      "just before calling SRCOTO"
  ]
  ELSE[
    ilen=lnblnk1(SPCNAM);
    IF(SPCNAM(ilen-8:ilen)='.IAEAphsp')[
         i_iaea_in=1;
         SPCNAM=SPCNAM(:ilen-9);
    ]

    IF(i_iaea_in=1)[
        $IAEA_OPEN_PHSP_FOR_READ(IINSRC,SPCNAM);
        $IAEA_READ_PHSP_HEADER(IINSRC,NNPHSP,NPHOTSRC,EKMAXSRC,NINCSRC,
                               Z_SOURCE,IZLAST1,I_MUPHSP_IN,IZSCORE);
        OUTPUT NNPHSP,NPHOTSRC,EKMAXSRC,NINCSRC;
           (T10,' IAEA format Phase space source with:'/
            T5,'                    Total number of particles =',I13/
            T5,'                            Number of photons =',I13/
            T5,'              Maximum particle kinetic energy =',F13.3,' MeV'/
            T5,' # of particles incident from original source =',F13.1/);
        IF(IZSCORE=0)[
         OUTPUT Z_SOURCE;
            (T5,'                        Z where source scored =',F13.3,' cm'/);
        ]
        IF(I_MUPHSP_IN~=0)[
           OUTPUT;
        (/' Fractional MU index will be read from the phase space data.');
        ]
    ]
    ELSE[
        $OPEN_PHSP_FOR_READ(IZLAST,IINSRC,SPCNAM,MODE_RW,NNPHSP,NPHOTSRC,
          EKMAXSRC,EKMINSRCE,NINCSRC);
         "NNPHSP: the total # of particles in file"
         "NPHOTSRC: # of photons in the file"
         "EKMAXSRC: max k.e. of particles"
         "EKMINSRCE: min k.e. of e- "
         "NINCSRC: # of incident partices from"
         "         original source"

    OLDSRC=0;
    IF(EKMAXSRC = 0.0 | NPHOTSRC>NNPHSP | EKMINSRCE>EKMAXSRC)[
           OUTPUT;(//' *****WARNING*****'/
                  ' PHASE SPACE SOURCE MAY HAVE AN ERROR OR MAY HAVE BEEN'/
                  ' GENERATED BY AN OLDER VERSION OF BEAMnrc.'/
                 ' WILL USE USER-INPUT VALUE OF MAXIMUM KINETIC ENERGY.'/
                  ' NUMBER OF PHOTONS AND MINIMUM ELECTRON ENERGY'/
                  ' WILL BE SET TO 0.  THIS WILL HAVE NO EFFECT ON RESULTS.'/
                  ' # OF PARTICLES INCIDENT FROM ORIGINAL SOURCE WILL BE SET'/
                ' EQUAL TO THE TOTAL NUMBER OF PARTICLES IN THE SOURCE FILE,'/
                  ' WHICH WILL CAUSE DOSE AND FLUENCE TO BE NORMALIZED'/
                  ' WITH RESPECT TO THE # OF HISTORIES RUN FROM THE PHASE'/
                  ' SPACE FILE, NOT THE # OF PARTICLES FROM THE ORIGINAL'/
                  ' SOURCE.'/
                  ' CHECK PHSP SOURCE FOR POSSIBLE ERRORS!'//);
           EKMAXSRC=TEMP2;
           NPHOTSRC=0;
           EKMINSRCE=0.;
           NINCSRC=NNPHSP;
           OLDSRC=1;
    ]
    ELSEIF(NINCSRC < 2)["source was generated before NINC replaced EKMINSRCG"
           OUTPUT;(//' ******WARNING*****'/
                     ' PHASE SPACE SOURCE WAS GENERATED USING AN OLDER'/
                   ' VERSION OF BEAMnrc IN WHICH # OF PARTICLES INCIDENT FROM'/
                     ' ORIGINAL SOURCE WAS NOT STORED.  THIS NUMBER WILL'/
                     ' BE SET EQUAL TO THE NUMBER OF PARTICLES IN THE SOURCE'/
                     ' FILE, AND DOSE AND FLUENCE WILL BE NORMALIZED'/
                     ' WITH RESPECT TO THE # OF HISTORIES RUN FROM THIS'/
                     ' FILE...NOT THE # OF PARTICLES OF PARTICLES FROM'/
                     ' THE ORIGINAL SOURCE'//);
           NINCSRC=NNPHSP;
           OLDSRC=2;
    ]
    OUTPUT NNPHSP,NPHOTSRC,EKMAXSRC,EKMINSRCE,NINCSRC;
           (T10,' Phase space source with:',/
            T5,'                    Total number of particles =',I13,/
            T5,'                            Number of photons =',I13,/
            T5,'              Maximum particle kinetic energy =',F13.3,' MeV'/
            T5,'              Minimum electron kinetic energy =',F13.3,' MeV'/
            T5,' # of particles incident from original source =',F13.1,/);
    ]"end of BEAMnrc format phsp source"
    MONOEN = 2; "flag for polyenergetic beam from phase-space information
    IQIN = 9;
    INIT_ICM=TEMP1;
    OUTPUT INIT_ICM;
    (/' Particles will start at the front boundary of CM',I3/);
    ISRC_DBS=TEMP5;RSRC_DBS=TEMP6;SSDSRC_DBS=TEMP7;ZSRC_DBS=TEMP8;
    IF(ISRC_DBS=1)[
       OUTPUT RSRC_DBS,SSDSRC_DBS,ZSRC_DBS;
      (/ T5,' Directional Bremsstrahlung Splitting (DBS) used'/
        T5,' in BEAM simulation to generate phase space source with:'/
        T10,'    DBS splitting radius =',F10.4,' cm'/
        T10,'SSD where radius defined =',F10.4,' cm'/
        T10,'   Z where source scored =',F10.4, 'cm'/
        T5,' Photons whose trajectory takes them outside the DBS splitting'/
        T5,' radius at the SSD will be rejected.'/);
       IF(SSDSRC_DBS<ZSRC_DBS)[
         OUTPUT;(//' ***WARNING:'/
                   ' SSD where DBS splitting radius is defined < the Z'/
                   ' value of scoring plane for this source.'/
                   ' Particle rejection will be turned off.'//);
         ISRC_DBS=0;
       ]
    ]
    ELSE[
      ISRC_DBS=0;
    ]
    IPARALLEL=TEMP3;
    PARNUM=TEMP4;

#ifdef HAVE_C_COMPILER;

"control parallel jobs differently if n_parallel>0"
    IF(IPARALLEL>1 & n_parallel>0)[
       OUTPUT IPARALLEL, n_parallel;
       (/' You have set IPARALLEL in the input file to ',I4,/
         ' But you are also running a C compiled code with n_parallel=',I4,/
         ' IPARALLEL will be reset to 1, and control of the parallel run '/
         ' will be within BEAM.'/);
       IPARALLEL=1;
    ]

#endif;

    IF(IPARALLEL<=0) IPARALLEL=1;
    IF(PARNUM<0) PARNUM=0;
    IF(IPARALLEL>1)[
       IF(PARNUM>=1 & PARNUM<=IPARALLEL)[
         OUTPUT IPARALLEL,INT((PARNUM-1)*NNPHSP/IPARALLEL)+1,
                INT(PARNUM*NNPHSP/IPARALLEL);
                  (/' This is one of ',I4,' parallel jobs.'/
                    ' It will use from particle ',I12,' to particle ',I12,/
                    ' from the phase space source in the simulation.'/);
       ]
       ELSE[
         OUTPUT IPARALLEL;
     (/' IPARALLEL input indicates that this is one of ',I4,' parallel jobs.'/
       ' But PARNUM is out of range (<1 or >IPARALLEL).  Therefore, phsp '/
       ' source will not be partitioned.'/);
         PARNUM=0;
         IPARALLEL=1;
       ]
    ]
    IF(TEMP2<=0)["automatically calculate NRCYCL"
      tmp_long=NNPHSP;
      IF(NINT(dble(IPARALLEL*NCASE)/float(NNPHSP))<=1)[
         "true if NCASE is only slightly > NNPHSP or < NNPHSP"
         NRCYCL=0;
      ]
      ELSEIF(MOD(IPARALLEL*NCASE,tmp_long)=0)[
         "NCASE is an exact multiple of NNPSHP"
         NRCYCL=(IPARALLEL*NCASE)/NNPHSP-1;
      ]
      ELSE[
         NRCYCL=(IPARALLEL*NCASE)/NNPHSP;
      ]
    ]
    ELSE[
      "use user-input value of NRCYCL"
      NRCYCL=TEMP2;
    ]
    OUTPUT NRCYCL;
  (/' Particles will be recycled ',I4,' times before moving on to next one.'/);

    "now read 2nd record, if NHSTRYM gets incremented, then we have a"
    "phsp file that stores NHSTRY"
    NHSTRYM=0;
    IF(i_iaea_in=1)[
       "just check that file size=checksum and that byte orders match"
       $IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(IINSRC);
    ]
    ELSE[
       $READ_PHSP_RECORD(IZLAST,IINSRC,2:
           NHSTRYM,ZLAST(1),LATCHM,EINM,WTM,XINM,YINM,UINM,VINM);
    IF(NHSTRYM=0)[
       DOSE_STAT=1;
       OUTPUT;(//' ***WARNING***'/
       ' Cannot read no. of primary (non-phsp) histories from ph-sp source.'/
       ' Dose and fluence will be analyzed assuming each particle read from'/
       ' the ph-sp file is an independent history.  May result in an'/
       ' underestimate of uncertainties.'//);
    ]
    ]
  ]"end of else ~phsp_open"

    IF(ISOURC=24)["read input angles, distance"
       OUTPUT INIT_ICM;
              (' Angle of source plane wrt the X-axis (degrees), Angle wrt '/
               ' the Y-axis (degrees), distance from point of rotation to '/
               ' front of CM ',I4,' (cm):',$);
       ;MINPUT (ISOURCE) ALPHA24,BETA24,DIST24;(3F15.0);
       OUTPUT ALPHA24,BETA24,DIST24;(3F12.5);
       IF(ABS(ALPHA24)>=90. | ABS(BETA24)>=90.)[
          OUTPUT;(//' ****ERROR in input for source 24:'/
                   ' At least one of the source angles is >= 90.'/
                   ' Incident particles will not hit the surface of the CM.'/
                   ' Reset angle(s) and try again.'//);
          STOP;
       ]
       ELSEIF(INIT_ICM=1 & (ALPHA24~=0 | BETA24~=0))[
          OUTPUT;(//' ****ERROR in input for source 24:'/
                    ' Incident CM must be > 1 to allow for rotation of source '/
                    ' to positions above its incident plane.  Try again.'//);
           STOP;
       ]
       ELSEIF((ALPHA24~=0 | BETA24~=0) & ((CMTYPE(INIT_ICM)~='SLABS' &
        CMTYPE(INIT_ICM)~='FLATFILT' & CMTYPE(INIT_ICM)~='SIDETUBE') |
        (CMTYPE(INIT_ICM-1)~='SLABS' &
        CMTYPE(INIT_ICM-1)~='FLATFILT' & CMTYPE(INIT_ICM-1)~='SIDETUBE')))[
          OUTPUT;(//' ****ERROR in input for source 24:'/
         ' INIT_ICM and INIT_ICM-1 must be SLABS, FLATFILT or SIDETUBE.'//);
          STOP;
       ]
       SALPHA24=SIN(ALPHA24*3.1415926/180.);
       CALPHA24=COS(ALPHA24*3.1415926/180.);
       SBETA24=SIN(BETA24*3.1415926/180.);
       CBETA24=COS(BETA24*3.1415926/180.);
    ]

    "initialize counters"
    "the following variables will keep track of source 21 parameters as"
    "the source is used"
    /N_ph_sp_e,N_ph_sp_g,N_ph_sp_p,NPASS_ph_sp,NFAT_ph_sp/=0;
    /E_ph_sp_e,E_ph_sp_g,E_ph_sp_p,E_MAX_ph_sp/=0.0;
]

" ISOURC = 23   Full BEAM simulation source"
"************
ELSEIF(ISOURC = 23)[
OUTPUT;
   (' Input name of source beam code (BEAM_accelname), input file (no ext.), '/
    ' pegs data (no ext.) (A256)'/'  : ',$);
    READ(i_input,'(A)',END=:EOF_ISOURCE:) TEXT;
    OUTPUT $cstring(TEXT);(A);
    "now parse TEXT for the inputs"

    the_beam_code=TEXT(:INDEX(TEXT,',')-1);
    TEXT=TEXT(INDEX(TEXT,',')+1:);
    "strip leading blanks"
    WHILE(INDEX(the_beam_code,' ')=1) [
      IF(len(the_beam_code)>=2)[
        the_beam_code=the_beam_code(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]
    "strip trailing blanks"
    the_beam_code=the_beam_code(:lnblnk1(the_beam_code));

    the_input_file=TEXT(:INDEX(TEXT,',')-1);
    TEXT=TEXT(INDEX(TEXT,',')+1:);
    "strip leading blanks"
    WHILE(INDEX(the_input_file,' ')=1) [
      IF(len(the_input_file)>=2) [
        the_input_file=the_input_file(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]
    "strip trailing blanks"
    the_input_file=the_input_file(:lnblnk1(the_input_file));
    the_pegs_file=TEXT(:lnblnk1(TEXT));
    "strip leading blanks"
    WHILE(INDEX(the_pegs_file,' ')=1) [
      IF(len(the_pegs_file)>=2) [
        the_pegs_file=the_pegs_file(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]
    MONOEN = 2; "flag for polyenergetic beam from phase-space information
    IQIN = 9;
    INIT_ICM=TEMP1;
    ISRC_DBS=TEMP2;
    ALPHA24=TEMP3;
    BETA24=TEMP4;
    DIST24=TEMP5;

    OUTPUT $cstring(the_beam_code),$cstring(the_input_file),
             $cstring(the_pegs_file);
    (/' BEAM simulation name: ',A/
      '           input file: ',A/
      '   pegs data for BEAM: ',A/);
    OUTPUT INIT_ICM;
    (/' Particles will start at the front boundary of CM',I3/);
    IF(ISRC_DBS=1)OUTPUT;(' Fat photons from DBS will be rejected.'/);
    OUTPUT ALPHA24,BETA24,INIT_ICM,DIST24;
    (' Angle of rotation of source plane wrt the X-axis = ',F8.3,' degrees'/
     ' Angle of rotation of source plane wrt the Y-axis = ',F8.3,' degrees'/
     ' Distance of point of rotation above CM ',I4,' = ',F8.3,' cm'/);
    IF(ABS(ALPHA24)>=90. | ABS(BETA24)>=90.)[
          OUTPUT;(//' ****ERROR in input for source 23:'/
                   ' At least one of the source angles is >= 90.'/
                   ' Incident particles will not hit the surface of the CM.'/
                   ' Reset angle(s) and try again.'//);
          STOP;
    ]
    ELSEIF(INIT_ICM=1 & (ALPHA24~=0 | BETA24~=0))[
          OUTPUT;(//' ****ERROR in input for source 23:'/
                    ' Incident CM must be > 1 to allow for rotation of source '/
                    ' to positions above its incident plane.  Try again.'//);
           STOP;
    ]
    ELSEIF((ALPHA24~=0 | BETA24~=0) & ((CMTYPE(INIT_ICM)~='SLABS' &
        CMTYPE(INIT_ICM)~='FLATFILT' & CMTYPE(INIT_ICM)~='SIDETUBE') |
        (CMTYPE(INIT_ICM-1)~='SLABS' &
        CMTYPE(INIT_ICM-1)~='FLATFILT' & CMTYPE(INIT_ICM-1)~='SIDETUBE')))[
          OUTPUT;(//' ****ERROR in input for source 23:'/
          ' INIT_ICM and INIT_ICM-1 must be SLABS, FLATFILT or SIDETUBE'//);
        STOP;
    ]
    SALPHA24=SIN(ALPHA24*3.1415926/180.);
    CALPHA24=COS(ALPHA24*3.1415926/180.);
    SBETA24=SIN(BETA24*3.1415926/180.);
    CBETA24=COS(BETA24*3.1415926/180.);

    "initialize counters"
    "the following variables will keep track of source 21 parameters as"
    "the source is used"
    /N_ph_sp_e,N_ph_sp_g,N_ph_sp_p,NFAT_ph_sp/=0;
    /E_ph_sp_e,E_ph_sp_g,E_ph_sp_p,E_MAX_ph_sp/=0.0;
]

" ISOURC = 31   use beam characterization models"
"************
ELSEIF(ISOURC = 31)[ ;$BEAMMODEL_SOURCE_INPUT; ]

ELSE[
    OUTPUT ISOURC;(///' *********ISOURC=',I5,' DOES NOT EXIST IN BEAMnrc****'/
    //' START AGAIN'///);
    $CALL_EXIT(1);
]

IF (ISOURC < 21 | ISOURC=22) [

"            Source energy input                                      ""toc:
"            *******************
   OUTPUT;(/' Source energy --Monoenergetic(0) or spectrum (1): ',$);
   ;MINPUT (ISOURCE) MONOEN;(I4);
   OUTPUT MONOEN;(I8);

   IF (MONOEN = 0)  ["Monoenergetic"
      OUTPUT;(' Monoenergetic source');
      IF (IQIN = 0) [OUTPUT;(' Energy of incident beam (MeV): ',$);]
      ELSE [OUTPUT;(' Kinetic energy of incident beam (MeV): ',$);]
      ;MINPUT (ISOURCE) EIN;(F10.0);
      IF( EIN = 0.0) [EIN = 1.25;"default value"]
      OUTPUT EIN;( F15.4);
   ]

   ELSEIF(MONOEN = 1)[
      OUTPUT;(' Energy distribution source');
      OUTPUT;(' INPUT NAME OF FILE WITH SPECTRUM DATA(<=256 CHARS)'/' : ',$);
      READ(i_input,'(A256)',END=:EOF_ISOURCE:) FILNAM;
      OUTPUT FILNAM;(/'   Will now read input energy spectrum from: ',/A256);
      call replace_env(FILNAM);
      i_spect=99;
      i_spect=egs_get_unit(i_spect);
      IF(i_spect<0)[
        $egs_fatal(*,'failed to get a free Fortran I/O unit for file');
      ]
      OPEN(UNIT=i_spect,STATUS='OLD',FILE=FILNAM,ERR=:EOF_RS3:);
      READ(i_spect,'(A80)') SPEC_TITLE;
      READ(i_spect,'(I10,F15.0,I5)')NENSRC,ENMIN,IMODE;
      IF(NENSRC > $NENSRC) [
         OUTPUT NENSRC,$NENSRC;
          (//' ********** Asked for too many energy bins******'/
          ' NENSRC =',I4, ' reduced to max allowed =',I4/1x,30('*')//);
         NENSRC = $NENSRC;
      ]
      READ(i_spect,'(2F20.0)')(ENSRCD(IB),SRCPDF(IB),IB=1,NENSRC);
      CLOSE(UNIT=i_spect);
      OUTPUT NENSRC; (' Have read',I5,' energy bins from file');
      IF(IMODE=0)[ OUTPUT;('      File contained counts/bin '); ]
      ELSEIF(IMODE = 1)[ OUTPUT;('      File contained counts/MeV ');
         SRCPDF(1) = SRCPDF(1)*(ENSRCD(1)-ENMIN);
         DO IB=2,NENSRC[SRCPDF(IB) = SRCPDF(IB)*(ENSRCD(IB)-ENSRCD(IB-1));]
      ] "end mode = 1 block"
      ELSE [
         OUTPUT IMODE;(///'*****MODE not 0 or 1 in spectrum file? **'
         /80('*') //);
      ]
      EIN = ENSRCD(NENSRC);"SET TO MAX ENERGY FOR SOME CHECKS"
      OUTPUT ENMIN,EIN;
      ('    ENERGY RANGES FROM',F10.3,' MeV TO',F12.3,' MeV');
      OUTPUT;
      (' Print spectrum data in output summary, yes(1) or no(0): ',$);
      READ(i_input,'(I5)') IOUTSP;
      IF(IOUTSP ~= 1)[IOUTSP=0;]
      OUTPUT IOUTSP;(I12);
      CALL EN_INITIALIZE;
   ]

   ELSEIF(MONOEN > 2)[ OUTPUT MONOEN;(' MONOEN = ',I4, ' ??? ');
                       $CALL_EXIT(1); ]
]"end of energy spectrum input for ISOURC<21"

" Normal return
" *************
RETURN;

" Errors
" ******
:EOF_ISOURCE: "unexpected end of input file, stop and print message
;OUTPUT;(//' *** unexpected end of file reading input for ISOURCE ***');
$CALL_EXIT(1); "End of input file return"

:ERROR_ISOURCE: "error on input, stop and print message
;OUTPUT;(//' *** format error on input for ISOURCE ***');
$CALL_EXIT(1); "Error in input file return"

:EOF_RS3: "error on file opening"
;OUTPUT;(//' *** SORRY, WE CANNOT FIND THE REQUIRED FILE/DIRECTORY. ***');
$CALL_EXIT(1);
END; "End of subroutine ISOURCE"
%E     "beamnrc.mortran - start subroutine srcoto                         "
"*******************************************************************************
"
                             SUBROUTINE SRCOTO(WEIGHT);
"                            *****************
"*******************************************************************************
"
" Calculation of one time only constants that may vary with source type.
"
"*******************************************************************************
"
$IMPLICIT-NONE;
;COMIN/CMs,GEOM,IO_INFO,MEDIA,MISC,SCORE,SOURCE,UPHIOT,USER,RANDOM,EGS-IO/;

"T>****************************
"T>TYPE DECLARATIONS FOR SRCOTO
"T>****************************
"T>
INTEGER I,  "T>a looping index
    IMAX,   "T>index of CM dictating RINMAX--used with source 3"
    IMIN;   "T>index of CM dictating RINMIN--used with source 3"
$REAL
    WEIGHT, "T>weight of source particles
    RINMIN; "T>minimum radius of beam--used with source 3

"*******************************************************************************
"
"
IFPB=1;               "Default flag to not being frontal parallel beam"
IF(INIT_ICM = 0)[
   Z_SOURCE=Z_min_CM(1);
   "Default: Source incident on front of 1st component module. "
]
ELSE IF( INIT_ICM > 0 ) [
   Z_SOURCE=Z_min_CM(INIT_ICM);
   "Default: Source incident on front of CM #: INIT_ICM. "
]

WEIGHT=1.0;           " Default weight

"Determine what default or maximum angle/radius should be"
"This depends on whether first CM has circular or square outer boundary"

IF(RMAX_CM_FLAG(1) = 1)    ["circular" RINMAX = RMAX_CM(1)*$ONE-EPS;]
ELSEIF(RMAX_CM_FLAG(1) = 2)["square" RINMAX=RMAX_CM(1)*SQRT(2.)*$ONE-EPS;]
ELSE["given by some other parameter, so just make safe" RINMAX=1000.;]
IF(ISOURC = 8 | ISOURC = 9) ["in these cases, RBEAM is limited at DISTZ"
   IF(Z_SOURCE ~= 0.0)[RINMAX = RINMAX* DISTZ/ABS(Z_SOURCE);
                      "largest beam from a source in CM 1"
   ]
   ELSE               [RINMAX = 10000.;"beam size not limited by this concern"]
]

" ISOURC = 0
"***********
IF(ISOURC = 0) ["Frontal parallel beam source"
    IF (RBEAM >= RINMAX) [
       RBEAM=RINMAX; "Limit beam radius to
         "geometry radius, scaled down to insure a strike on the target"
       OUTPUT RBEAM;
         (//' BEAM GOES BEYOND BOUNDARY OF CM !'
          /' BEAM RADIUS REDUCED TO ',F8.3,' cm.');
    ]
    IFPB=0;"Set flag- passed in common SOURCE
    IF((ISOURC = 0)  &  (WINC ~= 1.)) IFPB=1; "Not for angled incidence
    RBEAM2=RBEAM**2;
]
" ISOURC = 1
"***********
ELSEIF(ISOURC = 1) ["frontal point source"
    IF (RBEAM < 0.0) ["rectangular field, calculate constants and do checks"
       IF(XINU>RMAX_CM(1))[
          OUTPUT RMAX_CM(1);
          (//' ***WARNING IN SOURCE 1:'/
             ' XINU>RMAX of CM 1. XINU reset to ',F8.5,' cm for now.'//);
          XINU=RMAX_CM(1);
       ]
       IF(XINL<-RMAX_CM(1))[
          OUTPUT -RMAX_CM(1);
          (//' ***WARNING IN SOURCE 1:'/
             ' XINL<-RMAX of CM 1. XINL reset to ',F8.5,' cm for now.'//);
          XINL=-RMAX_CM(1);
       ]
       IF(YINU>RMAX_CM(1))[
          OUTPUT RMAX_CM(1);
          (//' ***WARNING IN SOURCE 1:'/
             ' YINU>RMAX of CM 1. YINU reset to ',F8.5,' cm for now.'//);
          YINU=RMAX_CM(1);
       ]
       IF(YINL<-RMAX_CM(1))[
          OUTPUT -RMAX_CM(1);
          (//' ***WARNING IN SOURCE 1:'/
             ' YINL<-RMAX of CM 1. YINL reset to ',F8.5,' cm for now.'//);
          YINL=-RMAX_CM(1);
       ]
       IF(XINL>XINU)[
          OUTPUT;
          (//' ***ERROR IN SOURCE 1:'/
             ' XINL>XINU.  Please reset and try again.'//);
          $CALL_EXIT(1);
       ]
       IF(YINL>YINU)[
          OUTPUT;
          (//' ***ERROR IN SOURCE 1:'/
             ' YINL>YINU.  Please reset and try again.'//);
          $CALL_EXIT(1);
       ]
       XINDEL=XINU-XINL;
       YINDEL=YINU-YINL;
    ]
    ELSE["RBEAM>=0"
       IF (RBEAM = 0.0 & GAMMA = 0.0)[ RBEAM=RINMAX;"default" ]
       IF (RBEAM >= RINMAX) RBEAM=RINMAX;
       RBEAM2 = RBEAM**2;
       IF (GAMMA = 0.0) ["RBEAM input"
          COSGAMMA = DISTZ/SQRT(RBEAM2 + DISTZ**2);
          ONEMCOSGAM = 1D0 - COSGAMMA;   "used in sampling"
          "above will be inaccurate for small fields - use an expansion"
          "COSGAMMA = 1 - 0.5*x**2 + .377*x**4 with x=RBEAM/DISTZ"

          " Note that double precision is used to prevent problems near"
          "origin when sampling later, even in large fields"
       ]
       ELSE ["GAMMA input"
          COSGAMMA = COS(GAMMA/57.29658);
          IF (TAN(GAMMA/57.29658)*DISTZ > RINMAX)[
            "half-angle so big, some particles miss front face"
            "This may not be appropriate some day, so could remove it"
            COSGAMMA =DISTZ/SQRT(RINMAX**2 +DISTZ**2);
            GAMMA = 57.29578*ACOS(COSGAMMA); "degrees"
            OUTPUT GAMMA;
          ('  Half-angle reduced to',F10.5,' degrees so just hits front face');
          ]
          ONEMCOSGAM = 1D0 - COSGAMMA;   "used in sampling"
       ]"end of block with gamma input"
    ]
"OUTPUT GAMMA,RBEAM,COSGAMMA;(/' ***TEMPORARY  GAMMA,RBEAM,COSGAMMA'/3F15.8);
]

ELSEIF(ISOURC = 3)[ "ISOTROPICALLY RADIATING RING"
    IF(RBEAM >= 0)[
       IF(ZSMIN < Z_min_CM(1))[
          IF(ZSMAX < Z_min_CM(1))[
             OUTPUT;(//' ***ERROR IN SOURCE 3:'/
                        ' ZSMIN & ZSMAX < Z_min_CM(1)'//);
             $CALL_EXIT(1);
          ]
          ELSE[
             ZSMIN= Z_min_CM(1);
             OUTPUT ZSMIN;(//' ***WARNING IN SOURCE 3:'/
                        ' ZSMIN < Z_min_CM(1)'/
                        ' ZSMIN reset to',F10.4,' cm'//);
             WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
                        '' ZSMIN < Z_min_CM(1)''/
                        '' ZSMIN reset to'',F10.4,'' cm''//)')ZSMIN;
          ]
       ]
       IF(ZSMAX > Z_min_CM(MAX_CMs+1))[
          IF(ZSMIN > Z_min_CM(MAX_CMs+1))[
             OUTPUT;(//' ***ERROR IN SOURCE 3:'/
                        ' ZSMIN & ZSMAX > bottom of geometry'//);
             $CALL_EXIT(1);
          ]
          ELSE[
             ZSMAX=Z_min_CM(MAX_CMs+1);
             OUTPUT ZSMAX;(//' ***WARNING IN SOURCE 3:'/
                        ' ZSMAX > bottom of geometry'/
                        ' ZSMAX reset to',F10.4,' cm'//);
             WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
                        '' ZSMAX > bottom of geometry''/
                        '' ZSMAX reset to'',F10.4,'' cm''//)')ZSMAX;
          ]
       ]
       DO I=MAX_CMs,1,-1[
          IF(ZSMIN>=Z_min_CM(I))[
             MIN_CM_SRC3=I;
             EXIT;
          ]
       ]
       DO I=1,MAX_CMs[
          IF(ZSMAX<=Z_min_CM(I+1))[
             MAX_CM_SRC3=I;
             EXIT;
          ]
       ]
    ]
    ELSE[
       IF(RMINBM < Z_min_CM(1))[
          OUTPUT;(//' ***ERROR IN SOURCE 3:'/
                    ' Centre of source cylinder < Z_min_CM(1)'/
                    ' Source will not work with this geometry'//);
          $CALL_EXIT(1);
       ]
       ELSEIF(RMINBM > Z_min_CM(MAX_CMs+1))[
          OUTPUT;(//' ***ERROR IN SOURCE 3:'/
               ' Centre of source cylinder > bottom of simulation geometry'/
               ' Source will not work with this geometry'//);
          $CALL_EXIT(1);
       ]
       IF(RMINBM - ABS(RBEAM) < Z_min_CM(1))[
          RBEAM=-ABS(RMINBM - Z_min_CM(1));
          OUTPUT ABS(RBEAM);(//' ***WARNING IN SOURCE 3:'/
          ' Source extends above Z_min_CM(1)'/
          ' RBEAM reset to',F10.4,' cm'//);
          WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
          '' Source extends above Z_min_CM(1)''/
          '' RBEAM reset to'',F10.4,'' cm''//)')ABS(RBEAM);
       ]
       IF(RMINBM + ABS(RBEAM) > Z_min_CM(MAX_CMs+1))[
          RBEAM=-ABS(Z_min_CM(MAX_CMs+1)-RMINBM);
          OUTPUT ABS(RBEAM);(//' ***WARNING IN SOURCE 3:'/
          ' Source extends below simulation geometry'/
          ' RBEAM reset to',F10.4,' cm'//);
          WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
          '' Source extends below simulation geometry''/
          '' RBEAM reset to'',F10.4,'' cm''//)')ABS(RBEAM);
       ]
       DO I=MAX_CMs,1,-1[
          IF(RMINBM-ABS(RBEAM)>=Z_min_CM(I))[
             MIN_CM_SRC3=I;
             EXIT;
          ]
       ]
       DO I=1,MAX_CMs[
          IF(RMINBM+ABS(RBEAM)<=Z_min_CM(I+1))[
             MAX_CM_SRC3=I;
             EXIT;
          ]
       ]
    ]
    IMAX=MIN_CM_SRC3;
    IMIN=MIN_CM_SRC3;
    RINMAX=RMAX_CM(IMAX);
    RINMIN=RMAX_CM(IMAX);
    DO I=MIN_CM_SRC3,MAX_CM_SRC3[
       IF(CMTYPE(I)~='CONESTAK' & CMTYPE(I)~='SIDETUBE'
          & CMTYPE(I)~='FLATFILT')[
          OUTPUT I;(//' ***ERROR IN SOURCE 3:'/
  ' CM ',I4,' is not a CONESTAK, SIDETUBE or FLATFILT, yet it has some of the'/
  ' source in it.  Source must be contained within CONESTAKs, SIDETUBEs, or'/
  ' FLATFILTs for now.  Try again.'//);
          $CALL_EXIT(1);
       ]
       IF(RMAX_CM(I)>RMAX_CM(IMAX))[
         IMAX=I;
         RINMAX=RMAX_CM(I);
       ]
       ELSEIF(RMAX_CM(I)<RMAX_CM(IMIN))[
         IMIN=I;
         RINMIN=RMAX_CM(I);
       ]
    ]
    IF(RBEAM >= 0)[
       IF(RMAX_CM_FLAG(IMAX)=2)[RINMAX = SQRT(2.)*RINMAX;]
       IF(RMAX_CM_FLAG(IMIN)=2)[RINMIN = SQRT(2.)*RINMIN;]
       IF(RBEAM>RINMAX)[
          IF(RMINBM>RINMAX)[
             OUTPUT;(//' ***ERROR IN SOURCE 3:'/
            ' RBEAM & RMINBM > RMAX_CM of largest CM containing source'//);
             $CALL_EXIT(1);
          ]
          ELSE[
             RBEAM=RINMAX;
             OUTPUT RBEAM;(//' ***WARNING IN SOURCE 3:'/
            ' RBEAM > RMAX_CM of largest CM containing source'/
            ' RBEAM reset to ',F8.3,' cm'//);
             WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
            '' RBEAM > RMAX_CM of largest CM containing source''/
            '' RBEAM reset to '',F8.3,'' cm''//)') RBEAM;
          ]
       ]
       IF(RBEAM>RINMIN)[
          OUTPUT;(//' ***WARNING IN SOURCE 3:'/
        ' Source goes beyond RMAX_CM of smallest CM containing source'//);
          WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
        '' Source goes beyond RMAX_CM of smallest CM containing source''//)');
       ]
    ]
    ELSE[
       IF((ZSMIN < -RINMAX & ZSMAX < -RINMAX) |
           (ZSMIN > RINMAX & ZSMAX > RINMAX))[
          OUTPUT;(//' ***ERROR IN SOURCE 3:'/
' Entire source is beyond RMAX_CM of largest CM supposed to contain source'//);
          $CALL_EXIT(1);
       ]
       IF(ZSMIN < -RINMAX)[
          ZSMIN=-RINMAX;
          OUTPUT ZSMIN;(//' ***WARNING IN SOURCE 3:'/
          ' Min. X of source < RMAX_CM of largest CM containing source'/
          ' Min. X reset to ',F8.3,' cm'//);
          WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
          '' Min. X of source < RMAX_CM of largest CM containing source''/
          '' Min. X reset to '',F8.3,'' cm''//)') ZSMIN;
       ]
       IF(ZSMAX > RINMAX)[
          ZSMAX=RINMAX;
          OUTPUT ZSMAX;(//' ***WARNING IN SOURCE 3:'/
          ' Max. X of source > RMAX_CM of largest CM containing source'/
          ' Max. X reset to ',F8.3,' cm'//);
          WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
          '' Max. X of source < RMAX_CM of largest CM containing source''/
          '' Max. X reset to '',F8.3,'' cm''//)') ZSMAX;
       ]
       IF(ABS(ZSMAX) > RINMIN | ABS(ZSMIN) > RINMIN)[
          OUTPUT;(//' ***WARNING IN SOURCE 3:'/
      ' Source goes beyond RMAX_CM of smallest CM containing source'//);
          WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
      '' Source goes beyond RMAX_CM of smallest CM containing source''//)');
       ]
    ]
"   Following are used to sample Z easily
    ZSOFST=0.5*(ZSMAX - ZSMIN)+ ZSMIN;
    ZBEAM=0.5*(ZSMAX - ZSMIN);
]

" ISOURC = 5
"***********
ELSEIF(ISOURC = 5) ["NRC swept beam"
    IF (RBEAM >= RINMAX) RBEAM=RINMAX; "Limit beam radius to
         "geometry radius, scaled down to insure a strike on the target
    RBEAM2 = RBEAM**2;
    COSGAMMA = COS(GAMMA/57.29658);
    SINGAMMA = SQRT(1.0 - COSGAMMA**2);
]
" ISOURC = 6
"***********
ELSEIF(ISOURC = 6) ["Frontal parallel rectangular beam along z-axis"
    RBEAM=SQRT(XBEAM**2+YBEAM**2);
"THERE IS A BUG HERE - This assumes first CM is circular outer boundary"
"IT may be square - usually will be in fact, and these checks would be faster"
    IF (RMAX_CM_FLAG(1) = 1)["case of cylindrical CM"
       IF (SQRT(XBEAM0**2+YBEAM0**2) > RMAX_CM(1))[
          "beam centre is outside the geometry radius"
           XBEAM0=0.;YBEAM0=0.;
           OUTPUT;(//' BEAM CENTRE IS OUTSIDE THE GEOMETRY RADIUS!!!'/
              ' BEAM CENTRE DEFAULTS TO (0.,0.). '///);
       ]
    ]
    ELSEIF(RMAX_CM_FLAG(1) = 2)["square CM"
       IF (ABS(XBEAM0) > RMAX_CM(1)) |
          (ABS(YBEAM0) > RMAX_CM(1)) [
          "beam centre is outside boundaries"
          XBEAM0=0.;YBEAM0=0.;
          OUTPUT;(//' BEAM CENTRE IS OUTSIDE THE GEOMETRY RADIUS!!!'/
              ' BEAM CENTRE DEFAULTS TO (0.,0.). '///);
       ]
    ]
"following brings limits of beam back to RMAX_CM(1) if the"
"beam goes beyond this boundary"
    IF (ABS(XBEAM0+XBEAM) > RMAX_CM(1)) |
       (ABS(XBEAM0-XBEAM) > RMAX_CM(1)) [
       XBEAM=RMAX_CM(1) - ABS(XBEAM0);
       OUTPUT XBEAM;(//' BEAM GOES BEYOND BOUNDARY OF CM!!'/
          ' XBEAM REDUCED TO ',F8.3,'cm.');
    ]
    IF (ABS(YBEAM0+YBEAM) > RMAX_CM(1)) |
       (ABS(YBEAM0-YBEAM) > RMAX_CM(1)) [
       YBEAM=RMAX_CM(1) - ABS(YBEAM0);
       OUTPUT YBEAM;(//' BEAM GOES BEYOND BOUNDARY OF CM!!'/
          ' YBEAM REDUCED TO ',F8.3,'cm.');
    ]
    IFPB=0;"Set flag- FRONTAL PARALLEL BEAM"
]

ELSEIF(ISOURC=21) ["phsp source"
     IF(i_iaea_in=1 & IZSCORE=1 & CMTYPE(INIT_ICM)~='SLABS' &
           CMTYPE(INIT_ICM)~='FLATFILT' & CMTYPE(INIT_ICM)~='SIDETUBE')[
           OUTPUT;(/' Warning in source 21: Z for each particle will be read'/
                    ' from the IAEA phase space data, but INIT_ICM is not set'/
                    ' to a CM that can handle particles incident within it'/
                    ' (SLABS, FLATFILT or SIDETUBE).  Depending on the Z'/
                    ' of incident particles, this may result in the'/
                    ' simulation stopping mid-run.'/);
        ]
]

ELSEIF(ISOURC = 22) ["Frontal parallel rectangular beam along z-axis"
    RBEAM=SQRT(XBEAM**2+YBEAM**2);
    "THERE IS A BUG HERE - This assumes first CM is circular outer boundary"
"IT may be square - usually will be in fact, and these checks would be faster"
    IF (RMAX_CM_FLAG(1) = 1)["case of cylindrical CM"
          IF (SQRT(XBEAM0**2+YBEAM0**2) > RMAX_CM(1))[
              "beam centre is outside the geometry radius"
              XBEAM0=0.;YBEAM0=0.;
              OUTPUT;(//' BEAM CENTRE IS OUTSIDE THE GEOMETRY RADIUS!!!'/
              ' BEAM CENTRE DEFAULTS TO (0.,0.). '///);
              ]
     ]
     ELSEIF(RMAX_CM_FLAG(1) = 2)["square CM"
         IF (ABS(XBEAM0) > RMAX_CM(1)) |
         (ABS(YBEAM0) > RMAX_CM(1)) [
             "beam centre is outside boundaries"
              XBEAM0=0.;YBEAM0=0.;
             OUTPUT;(//' BEAM CENTRE IS OUTSIDE THE GEOMETRY RADIUS!!!'/
              ' BEAM CENTRE DEFAULTS TO (0.,0.). '///);
         ]
     ]
    "following brings limits of beam back to RMAX_CM(1) if the"
    "beam goes beyond this boundary"
     IF (ABS(XBEAM0+XBEAM) > RMAX_CM(1)) |
         (ABS(XBEAM0-XBEAM) > RMAX_CM(1)) [
          XBEAM=RMAX_CM(1) - ABS(XBEAM0);
          OUTPUT XBEAM;(//' BEAM GOES BEYOND BOUNDARY OF CM!!'/
            ' XBEAM REDUCED TO ',F8.3,'cm.');
     ]
     IF (ABS(YBEAM0+YBEAM) > RMAX_CM(1)) |
         (ABS(YBEAM0-YBEAM) > RMAX_CM(1)) [
              YBEAM=RMAX_CM(1) - ABS(YBEAM0);
              OUTPUT YBEAM;(//' BEAM GOES BEYOND BOUNDARY OF CM!!'/
              ' YBEAM REDUCED TO ',F8.3,'cm.');
     ]
]

" ISOURC = 7
"*********
ELSEIF(ISOURC = 7) [  " the scanning beam  "
    IF (RBEAM > RINMAX)[ RBEAM=RINMAX;]"Limit beam radius to
    "geometry radius, scaled down to insure a strike on the target
    RBEAM2=RBEAM**2;
]

" ISOURC = 8
"*********
ELSEIF(ISOURC = 8) [  " the scanning uniform MM50 beam  "
    IF (RBEAM > RINMAX | RBEAM<= 0)[
       IF (RBEAM > RINMAX)[
          OUTPUT RINMAX; (//' BEAM GOES BEYOND BOUNDARY.'/
                     ' BEAM RADIUS REDUCED TO ',F8.3,'cm.'//);
       ]
       RBEAM=RINMAX;"Limit beam radius to
       "geometry radius, scaled down to insure a strike on the model"
    ]
    RBEAM2=RBEAM**2;
    IF (RBEAM+RBEAM0 > RINMAX)[
          OUTPUT RBEAM0,RINMAX-RBEAM;
          (//' ****WARNING IN SOURCE 8'/
             ' RBEAM+RBEAM0 goes beyond boundary of CM 1 '/
             ' RBEAM0 reduced from ',F8.3,' cm to ',F8.3,' cm.'//);
          WRITE(IOUTLIST,100)RBEAM0,RINMAX-RBEAM;
     100 FORMAT(//' ****WARNING IN SOURCE 8'/
             ' RBEAM+RBEAM0 goes beyond boundary of CM 1 '/
             ' RBEAM0 reduced from ',F8.3,' cm to ',F8.3,' cm.'//);
         RBEAM0=RINMAX-RBEAM;
    ]
]

" ISOURC = 9
"*********
ELSEIF(ISOURC = 9) [  " the scanning beam with discrete points"
   IF (RMAX_CM_FLAG(1) = 1)["case of cylindrical CM"
      DO I=1,NPTS_SRC9[
         IF(SQRT(X_SRC9(I)**2+Y_SRC9(I)**2) > RINMAX)[
            OUTPUT I; (//'***WARNING IN SOURCE 9:'/
                'Point ',I4,' goes beyond RINMAX.'//);
            WRITE(IOUTLIST,'(//''***WARNING IN SOURCE 9:''/
                ''Point '',I4,'' goes beyond RINMAX.''//)') I;
         ]
      ]
   ]
   ELSEIF (RMAX_CM_FLAG(1) = 2)["square CM"
      DO I=1,NPTS_SRC9[
         IF(ABS(X_SRC9(I))>RINMAX | ABS(Y_SRC9(I))>RINMAX )[
            OUTPUT I; (//'***WARNING IN SOURCE 9:'/
                'Point ',I4,' goes beyond RINMAX.'//);
            WRITE(IOUTLIST,'(//''***WARNING IN SOURCE 9:''/
                ''Point '',I4,'' goes beyond RINMAX.''//)') I;
         ]
      ]
   ]
]

" ISOURC = 10
"***********
ELSEIF(ISOURC = 10) ["parallel circular beam source from side"
    IF (RBEAM >= (Z_min_CM(2)-Z_min_CM(1))/2.)[
        RBEAM=(Z_min_CM(2)-Z_min_CM(1))/2.;
        "too large default to half of the thickness of the target"
    ]
    RBEAM2=RBEAM**2;
]
" ISOURC = 13
"***********
ELSEIF(ISOURC = 13) ["parallel rectangular beam source from side"
    IF (YBEAM >= (Z_min_CM(2)-Z_min_CM(1))/2.)[
        YBEAM=(Z_min_CM(2)-Z_min_CM(1))/2.;
        "too large default to half of the thickness of the target"
    ]
    IF (ZBEAM >= (Z_min_CM(2)-Z_min_CM(1))/2.)[
        ZBEAM=(Z_min_CM(2)-Z_min_CM(1))/2.;
        "too large default to half of the thickness of the target"
    ]
]

ELSEIF(ISOURC = 15)[
    COSGAMMA=COS(GAMMA/57.29578);
    SINGAMMA = SIN(GAMMA/57.29578);
    WEIGHT=1.0; "INCIDENT WEIGHT"
]
" ISOURC = 18
"***********
ELSEIF(ISOURC = 18) ["Gaussian parallel beam source"
    IF (RBEAM >= RINMAX) [
       "Limit beam radius to
       "geometry radius, scaled down to insure a strike on the target"
       OUTPUT RBEAM,RINMAX;
         (//' ***WARNING IN SOURCE 18:'/
            ' SIGMA OF INCIDENT BEAM IS BEYOND BOUNDARY OF CM !'
           /' SIGMA REDUCED FROM ',F8.3,' cm TO ',F8.3,' cm.'//);
       WRITE(IOUTLIST,102)RBEAM,RINMAX;
    102 FORMAT(//' ***WARNING IN SOURCE 18:'/
            ' SIGMA OF INCIDENT BEAM IS BEYOND BOUNDARY OF CM !'
           /' SIGMA REDUCED FROM ',F8.3,' cm TO ',F8.3,' cm.'//);
       RBEAM=RINMAX;
    ]
    IFPB=0;"Set flag- passed in common SOURCE
    IF((ISOURC = 18)  &  (WINC ~= 1.)) IFPB=1; "Not for angled incidence
    RBEAM2=RBEAM**2;
]
" ISOURC = 19
"***********
ELSEIF(ISOURC = 19) ["Gaussian parallel beam source"
    IF (RBEAM >= RINMAX) [
       "Limit beam radius to
       "geometry radius, scaled down to insure a strike on the target"
       OUTPUT RBEAM,RINMAX;
         (//' ***WARNING IN SOURCE 19:'/
            ' SIGMA OF INCIDENT BEAM IS BEYOND BOUNDARY OF CM !'
           /' SIGMA REDUCED FROM ',F8.3,' cm TO ',F8.3,' cm.'//);
       WRITE(IOUTLIST,103)RBEAM,RINMAX;
    103 FORMAT(//' ***WARNING IN SOURCE 19:'/
            ' SIGMA OF INCIDENT BEAM IS BEYOND BOUNDARY OF CM !'
           /' SIGMA REDUCED FROM ',F8.3,' cm TO ',F8.3,' cm.'//);
       RBEAM=RINMAX;
    ]
    IFPB=0;"Set flag- passed in common SOURCE
    IF((ISOURC = 19)  &  (WINC ~= 1.)) IFPB=1; "Not for angled incidence
    RBEAM2=RBEAM**2;
]
" ISOURC=23
"***********
ELSEIF(ISOURC = 23)[ "beam simulation source"
   OUTPUT 'About to call init_beamsource';(//a);
   call init_beamsource(i_parallel,n_parallel,i_log,$CONFIGURATION_NAME,
                        hen_house,egs_home,the_beam_code,
                        the_pegs_file,the_input_file);
   call maxenergy_beamsource(EKMAXSRC);
]
RETURN;
END;    "End of subroutine SRCOTO
%E     "beamnrc.mortran - start subroutine srcout                         "
"*******************************************************************************
"
                            SUBROUTINE SRCOUT;
"                           *****************
"*******************************************************************************
"
"  Describe source.
"
"*******************************************************************************
"
"                    TYPE DECLARATIONS AND COMMON BLOCKS
"                    ***********************************
"
$IMPLICIT-NONE;

"T>****************************
"T>TYPE DECLARATIONS FOR SRCOUT
"T>****************************
"T>

INTEGER I,lnblnk1; "T>a looping index"

;COMIN/CMs,GEOM,IO_INFO,MEDIA,MISC,SCORE,SOURCE,UPHIOT,USER,RANDOM,ENERGYSRC/;

;COMIN/BMODEL/;;

"*******************************************************************************
"
"                     EXECUTABLE PART OF CODE
"                     ***********************
"
WRITE(IOUTLIST,500);
500 FORMAT(' ',79('*')/T30,'SOURCE PARAMETERS'/);
IF(ISOURC < 21 | ISOURC=22)[
   IF(IQIN = 0)[WRITE(IOUTLIST,505);]   "IQIN is in COMIN SCORE"
   ELSEIF(IQIN = -1)[WRITE(IOUTLIST,506);]
   ELSEIF(IQIN = +1)[WRITE(IOUTLIST,507);]  "IQIN = 9 for full phase space"
]
502 FORMAT(T20,'INITIAL PARTICLES are electrons and positrons');
503 FORMAT(T20,'INITIAL PARTICLES are photons and positrons');
504 FORMAT(T20,'INITIAL PARTICLES are electrons, photons and positrons');
505 FORMAT(T20,'INITIAL PARTICLES are Photons');
506 FORMAT(T20,'INITIAL PARTICLES are Electrons');
507 FORMAT(T20,'INITIAL PARTICLES are Positrons');

;$BEAMMODEL_SRCOUT;"Beam model output"

IF(ISOURC = 0)[ WRITE(IOUTLIST,510) Z_SOURCE,RBEAM,UINC,VINC,WINC;
   510 FORMAT(T20,'PARALLEL BEAM ON FRONT FACE at Z=',F9.4,' cm'/
           T20,'Beam radius=',F9.4,' cm'/
           T17,' X,Y,Z DIRECTION COSINES = (',3(F10.5),')');
]
ELSEIF(ISOURC = 1)[ WRITE(IOUTLIST,520) DISTZ, Z_SOURCE;
   520 FORMAT(T5,'Point source on beam (Z) axis',F8.2, ' cm from FIRST CM, '/
           T5,'Front surface of CM at Z=',F9.4,' cm');
   IF(RBEAM<0.)["rectangular beam"
      WRITE(IOUTLIST,523)XINL,XINU,YINL,YINU;
      523  FORMAT(T5,'Collimated to rectangle with:'/
                  T5,'   X dimensions: ',F8.3,' - ',F8.3,' cm'/
                  T5,'   Y dimensions: ',F8.3,' - ',F8.3,' cm');
   ]
   ELSE[
      IF(GAMMA ~= 0.0)[WRITE(IOUTLIST,521) GAMMA;
        521  FORMAT(T5,' Half-angle of source=',F10.5,' degrees');
      ]
      ELSE [
           WRITE(IOUTLIST,522) RBEAM;
        522  FORMAT(T5,'Beam collimated to radius =',F8.3,' cm');
      ]
   ]
]
ELSEIF(ISOURC = 3)[
   IF(RBEAM>=0)[
       WRITE(IOUTLIST,525) ZSMIN,ZSMAX,RMINBM,RBEAM,MIN_CM_SRC3,MAX_CM_SRC3;
   ]
   ELSE[
       WRITE(IOUTLIST,526) ZSMIN,ZSMAX,RMINBM,ABS(RBEAM),
                          MIN_CM_SRC3,MAX_CM_SRC3;
   ]
   525 FORMAT(T5,'UNIFORM ISOTROPICALLY RADIATING RING CENTRED ON Z-AXIS'/
           T5,'SOURCE SPANS FROM Z=',F10.4,' cm to Z=',F10.4,' cm'/
           T5,'INNER RADIUS=',F10.4,' cm'/
           T5,'OUTER RADIUS=',F10.4,' cm'/
           T5,'SOURCE IS WITHIN CM(s)',I4,' -',I4);
526 FORMAT (T5,'UNIFORM ISOTROPICALLY RADIATING CYLINDER CENTRED || TO X-AXIS'/
           T5,'SOURCE SPANS FROM X=',F10.4,' cm to X=',F10.4,' cm'/
           T5,'Z OF THE SOURCE CENTRE=',F10.4,' cm'/
           T5,'RADIUS=',F10.4,' cm'/
           T5,'SOURCE IS WITHIN CM(s)',I4,' -',I4);
]
ELSEIF(ISOURC = 5)[ WRITE(IOUTLIST,530) GAMMA,RBEAM,Z_SOURCE;
   530 FORMAT(T5,'NRC swept beam  with half angle of ',F8.2, ' degrees '/
           T5,'BEAM SPOT RADIUS =',F8.3,' cm at Z=',F9.4,' cm');
]
ELSEIF(ISOURC = 6)[ WRITE(IOUTLIST,516) Z_SOURCE,XBEAM0,YBEAM0,XBEAM,YBEAM;
   516 FORMAT(T5,'PARALLEL RECTANGULAR BEAM ON FRONT FACE at Z=',
           F9.4,' cm'/
           T5,'CENTRED AT (Xh,Yh) = (',2F9.4,')'/
           T5,' HALF-WIDTH IN X DIRECTION:',F10.4,' cm'/
           T5,' HALF-WIDTH IN Y DIRECTION:',F10.4,' cm'/);
]
ELSEIF(ISOURC = 7)[ WRITE(IOUTLIST,537) FD_AT100, IRATIO_YXF, RBEAM;
   537 FORMAT(T5, ' SCANNING BEAM WITH FIELD SIZE AT SSD=100 : ', F15.7,
           T5, /'          THE FREQUENCY 2*RATION BETWEEN Y/X: ', I5,
           T5, /'          THE SPOT SIZE AT THE INITIAL POINT:', F15.7);
]
ELSEIF(ISOURC = 8)[ WRITE(IOUTLIST,538) DISTZ, Z_SOURCE;
   538 FORMAT(T5,'MM50 point scanned uniform circular source SSD',F8.2,
   ' cm from first CM, '/
           T5,'Front surface of CM(1) at Z=',F9.4,' cm');
   IF(GAMMA ~= 0.0)[WRITE(IOUTLIST,521) GAMMA;
   ]
   ELSE [ WRITE(IOUTLIST,522) RBEAM;
   ]
   WRITE(IOUTLIST,536) RBEAM0;
   536 FORMAT(T5,'Beam spot radius at Z=0 is ',F8.5,' cm');
]
ELSEIF(ISOURC = 9)[ WRITE(IOUTLIST,539) NPTS_SRC9, DISTZ, Z_SOURCE;
   539 FORMAT(T5,'MM50 scanned point source with',I4,' discrete points at SSD'/
              T5,'SSD=',F8.2,' cm, '/
           T5,'Front surface of CM(1) at Z=',F9.4,' cm'/
           T5,'(X,Y,PROBABILITY) of each point at SSD:');
   DO I=1,NPTS_SRC9[
      IF(I>1)[ WRITE(IOUTLIST,'(T10,3F10.4)')
           X_SRC9(I),Y_SRC9(I),PROB_SRC9(I)-PROB_SRC9(I-1);
      ]
      ELSE[ WRITE(IOUTLIST,'(T10,3F10.4)') X_SRC9(I),Y_SRC9(I),PROB_SRC9(I); ]
   ]
]
ELSEIF(ISOURC = 10)[ WRITE(IOUTLIST,511) RBEAM,UINC,VINC,WINC;
   511 FORMAT(T20,'PARALLEL CIRCULAR BEAM FROM SIDE, RADIUS=',F8.3,' cm'/
           T17,' X,Y,Z DIRECTION COSINES = (',3(F10.4),')');
]
ELSEIF(ISOURC = 13)[ WRITE(IOUTLIST,512) YBEAM,ZBEAM,UINC,VINC,WINC;
   512 FORMAT(T20,'PARALLEL RECTANGULAR BEAM FROM SIDE'/
           T20,'HALF-WIDTH(Y)=',F8.3,'cm, HALF-HEIGHT(Z)=',F8.3,' cm'/
           T17,' X,Y,Z DIRECTION COSINES = (',3(F10.4),')');
]
ELSEIF(ISOURC = 15)[ WRITE(IOUTLIST,540) GAMMA,ZFOCUS,THETAIN,RTHETAIN,SPCNAM;
540 FORMAT(T5,
   'NRC SWEPT BEAM WITH DIVERGENCE AND RADIAL INTENSITY DISTRIBUTION'/
  T5,'                     HALF ANGLE OF SWEPT CONE = ',F10.4,' degrees'/
  T5,'                            Z OF APEX OF CONE = ',F10.4,' cm'/
  T5,'                        BEAM DIVERGENCE ANGLE = ',F10.4,' degrees'/
  T5,'RADIUS AT WHICH BEAM DIVERGENCE ANGLE DEFINED = ',F10.4,' cm'//
             T5,'FILE CONTAINING RADIAL INTENSITY DISTRIBUTION:'/A//
             T5,'RADIAL INTENSITY DISTRIBTION...'//
             T5,'     bin     upper radius            '/
             T5,'      #          (cm)         prob.  '/);
             DO IB20=1,NRDIST[
                 WRITE(IOUTLIST,541)IB20,RDISTF(IB20),RPDF(IB20);
                 541 FORMAT(T5,I7,F17.8,E14.5);
             ]
]
ELSEIF(ISOURC = 18)[ WRITE(IOUTLIST,513) Z_SOURCE,RBEAM,RBEAM/0.42466,
                                         UINC,VINC,WINC;
513 FORMAT(T20,'PARALLEL BEAM WITH GAUSSIAN RADIAL DISTRIBUTION'/
           T20,'ON FRONT FACE at Z=',F9.4,' cm'/
           T20,'BEAM SIGMA=',F9.4,' cm (FWHM=',F9.4,' cm)'/
           T17,' X,Y,Z DIRECTION COSINES = (',3(F10.5),')');
]
ELSEIF(ISOURC = 19)[ WRITE(IOUTLIST,514) Z_SOURCE,RBEAM,RBEAM/0.42466,
                                         UINC,VINC,WINC;
514 FORMAT(T20,'PARALLEL BEAM WITH 2-D GAUSSIAN X-Y DISTRIBUTION'/
           T20,'ON FRONT FACE at Z=',F9.4,' cm'/
           T20,'BEAM SIGMA=',F9.4,' cm (FWHM=',F9.4,' cm)'/
           T17,' X,Y,Z DIRECTION COSINES = (',3(F10.5),')');
]

ELSEIF(ISOURC = 21 | ISOURC=24)[
              WRITE(IOUTLIST,640) SPCNAM,Z_SOURCE,INIT_ICM,NNPHSP,
                                         NPHOTSRC,EKMAXSRC,
                                         EKMINSRCE,NINCSRC,NRCYCL;
   640 FORMAT(T20,'FULL PHASE SPACE INPUT FOR EACH INCIDENT PARTICLE. '/
   T5,' SOURCE DATA FILE: ',A/
   T5,'             SOURCE INCIDENT ON FRONT FACE, Z =',F13.2,' cm'/
   T5,'                SOURCE INCIDENT ON MODULE ICM =',I13, /
   T5,'             Total # of particles in the file =',I13,/
   T5,'                     # of photons in the file =',I13,/
   T5,'                  Maximum energy of particles =',F13.3,' MeV'/
   T5,'                  Minimum energy of electrons =',F13.3,' MeV'/
   T5,' # of particles incident from original source =',F13.1/
   T5,'    # of times each particle will be recycled =',I13,/);
     IF(ISOURC=24)[
          WRITE(IOUTLIST,647)ALPHA24,BETA24,DIST24;
647 FORMAT(T5,
      ' Phase space plane incident from user-specified direction (Source 24):'/
   T5,'                angle of rotation wrt the X-axis =',F8.3,' degrees'/
   T5,'                angle of rotation wrt the Y-axis =',F8.3,' degrees'/
   T5,' distance of point of rotation above incident CM =',F8.3,' cm'/);
     ]
     IF(ISRC_DBS=1)[
          WRITE(IOUTLIST,644)RSRC_DBS,SSDSRC_DBS,ZSRC_DBS;
   644 FORMAT(T5,' Directional Bremsstrahlung Splitting (DBS) used'/
        T5,' in BEAM simulation to generate phase space source with:'/
        T10,'    DBS splitting radius =',F10.4,' cm'/
        T10,'SSD where radius defined =',F10.4,' cm'/
        T10,'   Z where source scored =',F10.4, 'cm'/
        T5,' Photons whose trajectory takes them outside the DBS splitting'/
        T5,' radius at the SSD will be rejected.'/);
     ]
     IF(IPARALLEL>1 & PARNUM>0)[
          WRITE(IOUTLIST,643) IPARALLEL,INT((PARNUM-1)*NNPHSP/IPARALLEL)+1,
                INT(PARNUM*NNPHSP/IPARALLEL);
   643 FORMAT(
   T5,' This is one of ',I4, ' parallel runs and will use from'/
   T5,' particle ',I12,' to particle ',I12,' in phase space source'/);
     ]
]
ELSEIF(ISOURC = 23)[ WRITE(IOUTLIST,646) Z_SOURCE,INIT_ICM,
                     $cstring(the_beam_code),
                    $cstring(the_input_file), $cstring(the_pegs_file),
                    EKMAXSRC,ALPHA24,BETA24,DIST24;
  646 FORMAT(T20,'BEAM SIMULATION SOURCE. '/
   T5,'             SOURCE INCIDENT ON FRONT FACE, Z =',F13.2,' cm'/
   T5,'                SOURCE INCIDENT ON MODULE ICM =',I13, /
   T32,'BEAMnrc simulation:  ',A/
   T40,'input file:  ',A/
   T36,'pegs data file:  ',A/
   T23,'Maximum energy of particles =',F13.3,' MeV'/
   T5,' angle of rotation of  source plane wrt the X-axis =',F8.3,' degrees'/
T5,' angle of rotation of source plane wrt the Y-axis =',F8.3,' degrees'/
T5,'  distance of point of rotation above incident CM =',F8.3,' cm'/);
   IF(ISRC_DBS=1)[
          WRITE(IOUTLIST,645);
          645 FORMAT(T5,' Fat photons from DBS will be rejected.'/);
   ]
]
IF(MONOEN=0&ISOURC~=31)[
   WRITE(IOUTLIST,641) EIN;
   641 FORMAT(/T20,'KINETIC ENERGY OF SOURCE =',F10.3,' MeV');
]
ELSEIF(MONOEN=1)[
   WRITE(IOUTLIST,642) FILNAM, ENMIN, ENSRCD(NENSRC),
                                     NENSRC;
   IF(IMODE=0)[
      WRITE(IOUTLIST,'(T20,''FILE CONTAINS COUNTS/BIN'')');
   ]
   ELSEIF(IMODE=1)[
      WRITE(IOUTLIST,'(T20,''FILE CONTAINS COUNTS/MeV'')');
   ]
   642 FORMAT(/T20,'INCIDENT ENERGY SPECTRUM READ FROM:'/A/
               T20,'MINIMUM KINETIC ENERGY OF SPECTRUM = ',F10.3,' MeV'/
               T20,'MAXIMUM KINETIC ENERGY OF SPECTRUM = ',F10.3,' MeV'/
               T20,'        NUMBER OF BINS IN SPECTRUM = ',I10);
]

;$BEAMMODEL_SOURCE_OUTPUT; "beam characterization model output"

RETURN;
END;    "End of subroutine SRCOUT
%E     "beamnrc.mortran - start subroutine srchst                         "
"*******************************************************************************
"
                      SUBROUTINE SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT);
"                     *****************
"*******************************************************************************
"
" Determine history-dependent parameters of source.
"
"*******************************************************************************
"
"                    TYPE DECLARATIONS AND COMMON BLOCKS
"                    ***********************************
"
$IMPLICIT-NONE;
;COMIN/
CMs,EPCONT,GEOM,IO_INFO,MEDIA,MISC,SCORE,SOURCE,STACK,UPHIOT,USER,
    RANDOM,RWPHSP,USEFUL,EGS-IO/;


"T>****************************
"T>TYPE DECLARATIONS FOR SRCHST
"T>****************************
"T>
;INTEGER
   IDIR,       "T>direction of source particle, 1=+Z direction
               "T>                             -1=-Z direction
   IRIN,       "T>region number of source
   IND_SCAN,   "T>index used in scanning beam source for the cycle index.
   I;          "T>a looping index
$REAL
   DIST_RAY,   "T>distance along ray from point source to first CM
   R2,         "T>square of randomly chosen X/Y source coordinates
   WEIGHT,     "T>weight of source particle
   UIN,VIN,WIN,"T>direction cosines of source
   XIN,YIN,ZIN,"T>coordinates of source
   XINPP,YINPP,XINP,YINP, "T>entrance coordinates of particles for source 15
   "XINS,YINS," "T>coordinates of sub-source not currently used
   ZZZ,RNG,  "T>coordinates of sub-source
   DELX,DELY, "T>deltas to add to XIN, YIN for source 8
   PHI,"T>variable for ISOURC=1
   DISTSRC_DBS, "T>stores distance along trajectory to DBS SSD (isourc=21)"
   RXYZ,FW,     "T>used for sampling ISOURC=1 as a rectangular beam"
   rand_dsb,    "T>for use in DSB"
   TEMP;        "T>used for source 24

REPLACE {$DSB_MAX_PARTICLE} WITH {1000}
$REAL  x_dsb, y_dsb, z_dsb, u_dsb($DSB_MAX_PARTICLE),
       v_dsb($DSB_MAX_PARTICLE),w_dsb($DSB_MAX_PARTICLE),
       wt_dsb($DSB_MAX_PARTICLE),wthin,xj,yj,disti,tcheck;
$INTEGER phat_dsb($DSB_MAX_PARTICLE),np_dsb,nthin,phatj,j;
$LOGICAL take_it;

$ENERGY PRECISION COS_THETA,SIN_THETA;"T>variable for ISOURC=1

;$LOCAL-VARIABLES-SOURCE31;

$ENERGY PRECISION EREAD;

/* Many of the sources below don't set the weight!
   So, set it to 1 first and the sources that have a different or variable
   weight will overwrite it below.
   IK, Aug 2004.
*/

data np_dsb/0/;
save x_dsb, y_dsb, z_dsb, u_dsb, v_dsb, w_dsb, wt_dsb, phat_dsb, np_dsb;

weight = 1;

"*******************************************************************************
"
"                         EXECUTABLE PART OF CODE
"                         ***********************
"
" ISOURC = 0
" **********
" Julio Lobo, Tony Popescu: Handle particles given by dosxyznrc
IF(dosxyz2beam_index<0)[GOTO :PARTICLE_FROM_DOSXYZ:;]

IF (ISOURC = 0) ["Frontal parallel beam source"
   IF (RBEAM =  0.0) ["pencil beam" /XIN,YIN/=0.0; ]
   ELSE["Choose a point randomly in a circle"
   ; LOOP[ $RANDOMSET XIN;XIN=(2.0*XIN-1.0)*RBEAM;
           $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*RBEAM;
           R2=XIN**2+YIN**2; ] UNTIL R2 <= RBEAM2;
     ]
   IF(IFPB =  0)[WIN=1.0;UIN=0.0;VIN=0.0;]ELSE[UIN=UINC;VIN=VINC;WIN=WINC;]
   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]
" ISOURC = 1
" **********
ELSEIF(ISOURC = 1) ["Frontal point source on axis"
   IF (RBEAM >= 0.0) [ " produce a circular beam "
      "pick angles randomly"
      $RANDOMSET RNG;
      COS_THETA = 1D0 - RNG* ONEMCOSGAM; "ONEMCOSGAM is 1-cos(1/2 angle=GAMMA)"
      "double precision since single precision causes COS_THETA to be "
      "1 when GAMMA is very small. The bug showed as a big peak around "
      "x=0,y=0 and a valley just outside it - rings actually near origin."
      SIN_THETA = DSQRT(1D0 - COS_THETA**2);
      $RANDOMSET PHI; PHI = 6.283185308*PHI;
      UIN = SIN_THETA*COS(PHI);
      VIN = SIN_THETA*SIN(PHI);
      WIN = COS_THETA;
      IF(WIN ~= 0.0)[
         ZZZ = DISTZ/WIN;
         XIN = ZZZ * UIN;
         YIN = ZZZ * VIN;
      ]
      ELSE [OUTPUT;(///' ****Initial particle will not hit target***'//);
        "this should be impossible since GAMMA is reduced to force a hit"
        $CALL_EXIT(1);
      ]
   ]
   ELSE [" produce rectangular beam"
      LOOP[" taken from DOSXYZ source 3"
          $RANDOMSET RNG;
          XIN=RNG*XINDEL+XINL;
          $RANDOMSET RNG;
          YIN=RNG*YINDEL+YINL;
          $RANDOMSET RNG;
          RXYZ=SQRT(DISTZ*DISTZ+XIN*XIN+YIN*YIN);
          WIN=DISTZ/RXYZ;
          IF(XINDEL=0. & YINDEL=0.)GOTO :FOUND_A_POINT:;
          FW=WIN**3.;
          IF(RNG<FW)GOTO :FOUND_A_POINT:;
      ]
      ;:FOUND_A_POINT:;
      UIN=XIN/RXYZ;
      VIN=YIN/RXYZ;
   ]
   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]

ELSEIF(ISOURC = 3)[ "ISOTROPICALLY RADIATING DISK"
    "CHOOSE Z-COORDINATE FOR THE GENERATION OF A PARTICLE WITHIN REGION NSRCRG"
    ;:dsb_resample:;
    IF(RBEAM>=0)[
       $RANDOMSET ZIN;
       ZIN=ZSOFST+(2.0*ZIN-1.0)*ZBEAM;
       IF(RBEAM < 1.E-4)[
          XIN=0;
          YIN=0;
       ]
       ELSEIF(ABS(RBEAM-RMINBM) < 1.E-4)[
          $RANDOMSET XIN;
          XIN=TWOPI*XIN;
          YIN=RBEAM*SIN(XIN);
          XIN=RBEAM*COS(XIN);
       ]
       ELSE[
          LOOP[
              $RANDOMSET XIN;XIN=(2.0*XIN-1.0)*RBEAM;
              $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*RBEAM;
              R2=XIN**2+YIN**2;
          ] UNTIL (R2 <= RBEAM2 & R2 >= RMINSQ);
       ]
    ]
    ELSE[
       $RANDOMSET XIN;
       XIN=ZSOFST+(2.0*XIN-1.0)*ZBEAM;
       IF(ABS(RBEAM)<1.E-4)[
          YIN=0;
          ZIN=RMINBM;
       ]
       ELSE[
          LOOP[
              $RANDOMSET ZIN;ZIN=(2.0*ZIN-1.0)*ABS(RBEAM);
              $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*ABS(RBEAM);
              R2=ZIN**2+YIN**2;
          ] UNTIL (R2 <= RBEAM2);
          ZIN=RMINBM+ZIN;
       ]
    ]
    "NOW DETERMINE INITIAL DIRECTION COSINES"

    IF( i_dsb = 1 ) [

        IF( np_dsb < 1 ) [

            " No particles left from previous calls => pick new "
            " position and directions                           "
            x_dsb = xin; y_dsb = yin; z_dsb = zin;

            " Number of thin source particles going towards circle "
            wthin = fs*fs*dsb_aeff*nbrspl/(2*(ssd-zin))**2;

            /*
            write(6,*) 'Picking particles: x = ',xin,yin,zin,' wthin = ',wthin,
              nhstry;
            */

            nthin = wthin; wthin = wthin - nthin;
            $RANDOMSET rand_dsb; IF( rand_dsb < wthin ) nthin = nthin + 1;
            /* write(6,*) 'nthin = ',nthin; */

            LOOP [

                " Increment history counters "
                nhstry = nhstry + 1;

                " Pick a direction for a phat particle "
                $RANDOMSET costhe; costhe = 2*costhe-1;
                sinthe = 1 - costhe**2;
                IF( sinthe > 0 ) [ sinthe = sqrt(sinthe); ] ELSE [ sinthe = 0; ]
                $RANDOMSET phi; phi = twopi*phi;
                uin = sinthe*cos(phi); vin = sinthe*sin(phi); win = costhe;
                /* write(6,*) 'phat: direction = ',uin,vin,win; */
                take_it = .true.;
                IF( win > 0 ) [
                    tcheck = (ssd-zin)/win;
                    IF( (xin+uin*tcheck)**2+(yin+vin*tcheck)**2 < fs*fs ) [
                        take_it = .false.;
                          " goes toward field, which is already taken "
                          " taken into account with thin particles"
                    ]
                ]

                np_dsb = 0;
                IF( take_it ) [
                    /* write(6,*) 'phat accepted'; */
                    u_dsb(1) = uin; v_dsb(1) = vin; w_dsb(1) = win;
                    wt_dsb(1) = 1; phat_dsb(1) = nbrspl;
                    np_dsb = 1;
                ]

                " Now pick nthin directions for the thin particles "
                DO j = 1,nthin [
                    IF( dsb_nbin > 1 ) [
                        call dsb_get_point(fs,dsb_nbin,dsb_rbin,dsb_prob,
                                dsb_ibin,xj,yj,phatj);
                    ]
                    ELSE [
                        LOOP [
                            $RANDOMSET xj; xj = 2*xj-1;
                            $RANDOMSET yj; yj = 2*yj-1;
                        ] UNTIL ( xj*xj + yj*yj < 1 );
                        phatj = 1; xj = xj*fs; yj = yj*fs;
                    ]
                    /* write(6,*) 'thin: ',j,xj,yj,phatj; */
                    uin = xj-xin; vin = yj-yin; win = ssd-zin;
                    disti = 1/sqrt(uin**2+vin**2+win**2);
                    $RANDOMSET rand_dsb; win = win*disti;
                    IF( rand_dsb < win**3 ) [
                        /* write(6,*) 'thin accepted'; */
                        uin = uin*disti; vin = vin*disti;
                        np_dsb = np_dsb + 1;
                        IF( np_dsb > $DSB_MAX_PARTICLE ) [
                          $egs_fatal(*,'In SRCHST number of stored particle ',
                                'directions exceeds ',$DSB_MAX_PARTICLE,
                                ' Increase $DSB_MAX_PARTICLE and retry');
                        ]
                        u_dsb(np_dsb) = uin; v_dsb(np_dsb) = vin;
                        w_dsb(np_dsb) = win; phat_dsb(np_dsb) = phatj;
                        wt_dsb(np_dsb) = dble(phatj)/nbrspl;
                    ]
                ]
            ] UNTIL (np_dsb > 0);
        ]

        xin = x_dsb; yin = y_dsb; zin = z_dsb;
        uin = u_dsb(np_dsb); vin = v_dsb(np_dsb); win = w_dsb(np_dsb);
        weight = wt_dsb(np_dsb); iphati = phat_dsb(np_dsb);
        /*
        write(6,*) 'Using stored particle ',np_dsb,':';
        write(6,*) xin,yin,zin,uin,vin,win,weight,iphati;
        */
        np_dsb = np_dsb - 1;

    ]
    ELSE [
        $RANDOMSET COSTHE;   COSTHE=2.*COSTHE-1;
        SINTHE=SQRT(1.0-COSTHE**2);
        $RANDOMSET PHI;PHI=TWOPI*PHI;
        UIN=SINTHE*COS(PHI);VIN=SINTHE*SIN(PHI);WIN=COSTHE;
        WEIGHT=1.0
    ]
    DO I=1,MAX_CMs[
       IF(ZIN < Z_min_CM(I+1))[
          ICM=I;
          EXIT;
       ]
    ]
    IDIR=2;
    IAUSFL(6)=0; "in case of no initial call to HOWFAR"
]

" ISOURC = 5
" **********
ELSEIF(ISOURC = 5) ["NRC swept beam "
   "Choose a point randomly in a circle"
   ; LOOP[ $RANDOMSET XIN;XIN=(2.0*XIN-1.0)*RBEAM;
           $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*RBEAM;
           R2=XIN**2+YIN**2; ] UNTIL R2 <= RBEAM2;

   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
   WIN = COSGAMMA;
   $RANDOMSET RNG; RNG = TWOPI*RNG;"select angle 0 to 2 pie"
   UIN = COS(RNG)*SINGAMMA;
   VIN = SIN(RNG)*SINGAMMA;
]


" ISOURC = 6
" **********

ELSEIF (ISOURC = 6) ["Frontal parallel rectangular beam along z-axis"
   IF (RBEAM =  0.0) ["pencil beam" XIN=XBEAM0;YIN=YBEAM0; ]
   ELSE["Choose a point randomly in the field"
    ; $RANDOMSET XIN;XIN=(2.0*XIN-1.0)*XBEAM+XBEAM0;
      $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*YBEAM+YBEAM0;
   ]
   UIN=UINC;VIN=VINC;WIN=WINC;
   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]

ELSEIF (ISOURC = 22) ["Frontal parallel rectangular beam along z-axis"
   IF (RBEAM =  0.0) ["pencil beam" XIN=XBEAM0;YIN=YBEAM0; ]
   ELSE["Choose a point randomly in the square ring"
       ; $RANDOMSET RNG;RNG=(2*RNG-1)*2*(XBEAM+YBEAM);
       IF(RNG<=-2*XBEAM)[
           YIN=RNG+2*XBEAM+YBEAM+YBEAM0;
           XIN=-XBEAM+YBEAM0;
       ]
       ELSEIF(RNG<=0.)[
           XIN=RNG+XBEAM+XBEAM0;
           YIN=-YBEAM+YBEAM0;
       ]
       ELSEIF(RNG<=2*YBEAM)[
           YIN=RNG-YBEAM+YBEAM0;
           XIN=XBEAM+XBEAM0;
       ]
       ELSE[
           XIN=RNG-2*YBEAM-XBEAM+XBEAM0;
           YIN=YBEAM+YBEAM0;
       ]
   ]
   UIN=UINC;VIN=VINC;WIN=WINC;
   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]

" ISOURC=7
"*********
ELSEIF(ISOURC=7) [  " the scanning beam  "
                    " origin at left bottom corner "
                    " scanning field at 100 cm
     $RANDOMSET RNG; IND_SCAN=RNG*IRATIO_YXF;
     IF( IND_SCAN >=IRATIO_YXF ) [ IND_SCAN=IRATIO_YXF-1; ] " should not happen
     $RANDOMSET XIN;   "  range [0,1)
     XIN=XSCAN_UNIT*XIN;  " rescale to [0, xscan_unit)
     IF( MOD(IND_SCAN, 2) = 0 ) [  YIN=XIN*IRATIO_YXF/2.0;] " go up scanning
     ELSEIF( MOD(IND_SCAN, 2) = 1 ) [  YIN=-XIN*IRATIO_YXF/2.0+FD_AT100;]
                                               " go down scanning "
                                               " y range [0, FD_AT100)
     XIN=XIN+IND_SCAN*XSCAN_UNIT;   " shift the x coord to each cycle
     IF(XIN>FD_AT100) [ XIN=-XIN+2.0*FD_AT100; ]    " the return scanning
                    " shift the origin to (0.0, 0.0) "
     XIN=XIN-FD_AT100/2.0;
     YIN=YIN-FD_AT100/2.0;
                    "  calc. the u, v, win  "
     DIST_RAY=SQRT( XIN*XIN+YIN*YIN+(100.0)**2); "modified to eliminate"
                                            "dependence of WIN on"
                                            "Z_min_CM(1)"
     WIN=(100.0)/DIST_RAY;
     UIN=XIN/DIST_RAY;
     VIN=YIN/DIST_RAY;

                   " now consider the beam spot size, i.e., not point source

   ; LOOP[ $RANDOMSET XIN;XIN=(2.0*XIN-1.0)*RBEAM;
           $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*RBEAM;
           R2=XIN**2+YIN**2;
     ] UNTIL R2 <= RBEAM2;
   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]


" ISOURC=8
"*********
ELSEIF(ISOURC = 8) ["scaned point source uniform on xy plane"
                    "cf ISOURC = 1 which is uniform in solid angle"

 "Choose a point randomly in a circle"
 ;LOOP[$RANDOMSET XIN;XIN=(2.0*XIN-1.0)*RBEAM;
       $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*RBEAM;
       R2=XIN**2+YIN**2;] UNTIL R2 <= RBEAM2;
   ZZZ = SQRT(XIN**2 + YIN**2 + DISTZ**2);
   IF(ZZZ > 0)[
      UIN=XIN/ZZZ;
      VIN=YIN/ZZZ;
      WIN=DISTZ/ZZZ;
   ]
   ELSE [OUTPUT;(///' ****some thing is wrong in source = 8***'//);
     $CALL_EXIT(1);
   ]
   IF(RBEAM0<=0.)[
     DELX=0.;DELY=0.;
   ]
   ELSE[
     LOOP[$RANDOMSET DELX;DELX=(2.0*DELX-1.0)*RBEAM0;
          $RANDOMSET DELY;DELY=(2.0*DELY-1.0)*RBEAM0;
          R2=DELX**2+DELY**2;] UNTIL R2 <= RBEAM0**2;
   ]
   ZIN=Z_SOURCE; "Incident Z position = Z_min_CM(1)"
   XIN=XIN*Z_SOURCE/DISTZ+DELX;"at origin if Z_SOURCE = 0.0"
   YIN=YIN*Z_SOURCE/DISTZ+DELY;
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]

" ISOURC=9
"*********
ELSEIF(ISOURC = 9) ["scanned point source with discrete points on xy plane"
   $RANDOMSET XIN;  "randomly select which point to aim at"
   DO I=1,NPTS_SRC9[
     IF(XIN<PROB_SRC9(I))[
        XIN=X_SRC9(I);
        YIN=Y_SRC9(I);
        EXIT;  "exit DO loop since found and set this one"
     ]
   ]
   ZZZ = SQRT(XIN**2 + YIN**2 + DISTZ**2);
   IF(ZZZ > 0)[
      UIN=XIN/ZZZ;
      VIN=YIN/ZZZ;
      WIN=DISTZ/ZZZ;
   ]
   ELSE [OUTPUT;(///' ****some thing is wrong on the source = 9***'//);
     $CALL_EXIT(1);
   ]
   ZIN=Z_SOURCE; "Incident Z position"
   XIN=XIN*Z_SOURCE/DISTZ;
   YIN=YIN*Z_SOURCE/DISTZ;
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]

" ISOURC = 10
" ***********

ELSEIF (ISOURC = 10) ["parallel circular beam from side on x-ray target"
   IF (XTUBE_EXISTS ~= 1) [
       OUTPUT;(////'   SORRY, MY FRIEND, THIS SOURCE CAN ONLY BE USED'/
                   '   TOGETHER WITH THE COMPONENT MODULE XTUBE FOR THE'/
                   '   SIMULATION OF THE TARGET OF AN X-RAY TUBE !!!!!!');
       GOTO :ERROR_SOURCE:;
   ]
   IF (RBEAM =  0.0) ["pencil beam"YIN=0.0; XIN=0.0;ZIN=0.0;]
   ELSE["Choose a point randomly in a circle"
       LOOP[ $RANDOMSET ZIN;ZIN=(2.0*ZIN-1.0)*RBEAM;
           $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*RBEAM;
           R2=ZIN**2+YIN**2; ] UNTIL R2 <= RBEAM2;
   ]
   XIN=-ZIN*TAN(ANGLE);"start from target surface"
   ZIN=Z_min_CM(1)+(Z_min_CM(2)-Z_min_CM(1))/2.+ZIN;
   UIN=UINC;VIN=VINC;WIN=WINC;
   ICM = 1; "Entering first component module"
   IDIR = 0; "Entering from side"
]

" ISOURC = 13
" ***********

ELSEIF (ISOURC = 13)["parallel rectangular beam from side on x-ray target"
   IF (XTUBE_EXISTS ~= 1) [
       OUTPUT;(////'   SORRY, MY FRIEND, THIS SOURCE CAN ONLY BE USED'/
                   '   TOGETHER WITH THE COMPONENT MODULE XTUBE FOR THE'/
                   '   SIMULATION OF THE TARGET OF AN X-RAY TUBE !!!!!!');
       GOTO :ERROR_SOURCE:;
   ]
   IF ((YBEAM =  0.0)&(ZBEAM =  0.0))
       ["pencil beam"
       YIN=0.0; XIN=0.0;
       ZIN=Z_min_CM(1)+(Z_min_CM(2)-Z_min_CM(1))/2.;
   ]
   ELSE["Choose a point randomly in a circle"
       $RANDOMSET ZIN;ZIN=(2.0*ZIN-1.0)*ZBEAM;
       $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*YBEAM;
       XIN=-ZIN*TAN(ANGLE);"start from target surface"
       ZIN=Z_min_CM(1)+(Z_min_CM(2)-Z_min_CM(1))/2.+ZIN;
       UIN=UINC;VIN=VINC;WIN=WINC;
       ICM = 1; "Entering first component module"
       IDIR = 0; "Entering from side"
   ]
]

" ISOURC = 15
" ***********

ELSEIF (ISOURC = 15)["swept beam with radial intensity distribution"
                     "and angular variation"

    "THIS ENTRY DOES THE ACTUAL SAMPLING OF THE INCIDENT RADIAL INTENSITY"
    "DISTRIBUTION"
    "THIS WILL RETURN A HISTOGRAM OF VALUES"
    :RETRY_SOURCE15:;
    $RANDOMSET RNNO1;$RANDOMSET RNNO2;
    DO IB20=1,NRDIST[
       RNNO1=RNNO1 - RCDF(IB20);
       IF(RNNO1 <= 0) EXIT;
    ]
    RIN=SQRT(RCDFIN(IB20,1)+RNNO2*RCDFIN(IB20,2));
    IF(RIN < 0)[
      IF(RIN < -0.0001)[
        OUTPUT;(//' ****WARNING IN SOURCE 15:'/
                  ' Sampled radius < 0.0'//);
      ]
      GOTO :RETRY_SOURCE15:;
    ]
    IF(RIN > RDISTF(NRDIST))[
      IF(RIN > 1.0001*RDISTF(NRDIST))[
         OUTPUT;(//' ****WARNING IN SOURCE 15:'/
                  ' Sampled radius > max. radius'//);
      ]
      GOTO :RETRY_SOURCE15:;
    ]

    ZIN=Z_min_CM(1);
    ICM = 1; "Entering first component module"

   "IF(THETAIN ~= 0.)["
       "$RANDOMSET RNG; "
       "COSTHETA = 1D0 -  RNG * (1.0 - DCOS(THETAIN));"
       "SINTHETA = DSQRT( 1D0 -  COSTHETA**2 );"
    " see qa_isourc15_theory.tex for proof"
    " the above sampling by itself will produce uniform fluence"
    "]"
    "ELSE[ COSTHETA = 1D0;"
    " SINTHETA = 0D0;"
    "]"


    " the above proved to make profiles much worse, see nrc20s_r[5-7]_xyz_e3"
    " note that in nrc20s_r and s series convergence was assumed not divergence"

    "THETAI = DACOS(COSTHETA);"
    " THETAI  is in radians "

    " now I'll try this:  assume that the divergence increases radially: "

    THETAI = DATAN( RIN/RTHETAIN * DTAN(THETAIN/57.29578));
    COSTHETA = DCOS(THETAI);
    " for the results of this see nrc20s_u series "

    SINTHETA = DSIN(THETAI);


    WINP = COSTHETA;
    $RANDOMSET RNG; RNG = TWOPI*RNG;
    XINPP = RIN * COS(RNG);
    YINPP = RIN * SIN(RNG);
    UINP = COS(RNG) * SINTHETA;
    VINP = SIN(RNG) * SINTHETA;


    $RANDOMSET RNG; RNG = TWOPI*RNG;
    COSRNG = COS(RNG);
    SINRNG = SIN(RNG);

    " Rotate (UINP,VINP,WINP) first by GAMMA (azimuth) then by RNG (phi)"
    UIN =       UINP * COSRNG
              + VINP * SINRNG * COSGAMMA
              + WINP * SINRNG * SINGAMMA ;
    VIN = -1.0 * UINP * SINRNG
              + VINP * COSRNG * COSGAMMA
              + WINP * COSRNG * SINGAMMA;
    WIN = -1.0 * VINP * SINGAMMA
              + WINP * COSGAMMA;

" do a 2-D rotation through phi to find XINP, YINP--Note that this"
" assumes that the source radial intensity distribution is defined in a plane"
" parallel to the ZFOCUS plane (ie not tilted with gamma)"

    XINP = XINPP*COSRNG + YINPP*SINRNG;
    YINP = -1.0 * XINPP*SINRNG + YINPP*COSRNG;

    " now project back to ZIN "

    XIN = XINP - (ZFOCUS - ZIN)/WIN*UIN;
    YIN = YINP - (ZFOCUS - ZIN)/WIN*VIN;

]
" ISOURC = 18
" **********
ELSEIF (ISOURC = 18) ["Parallel beam source with Gaussian radial distn"
   IF (RBEAM =  0.0) ["pencil beam" /XIN,YIN/=0.0; ]
   ELSE["Choose a random Gaussian point in a 1-D Gaussian distribution"
     IF(CHOSEN_SRC18=0)["need to choose 2 new gaussian distributed radii"
        LOOP[ $RANDOMSET ZIN;
            ZIN=RBEAM*SQRT(-2*LOG(1-ZIN));
        ] UNTIL ZIN<=RINMAX;
        $RANDOMSET XIN;
        XIN=2.*3.1415926*XIN;
        RIN1_SRC18=ZIN*COS(XIN);
        RIN2_SRC18=ZIN*SIN(XIN);
        ZIN=RIN1_SRC18;
        CHOSEN_SRC18=1;
     ]
     ELSE[
        ZIN=RIN2_SRC18;
        CHOSEN_SRC18=0;
     ]
     "generate a random angle"
     $RANDOMSET YIN; YIN = 2.*3.1415926*YIN;
     XIN = ZIN*COS(YIN);
     YIN = ZIN*SIN(YIN);
   ]
   IF(IFPB =  0)[WIN=1.0;UIN=0.0;VIN=0.0;]ELSE[UIN=UINC;VIN=VINC;WIN=WINC;]
   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]
" ISOURC = 19
" **********
ELSEIF (ISOURC = 19) ["Parallel beam source with gaussian X-Y"
   IF (RBEAM =  0.0) ["pencil beam" /XIN,YIN/=0.0; ]
   ELSE["Choose a random Gaussian point in a 2-D Gaussian distribution"
     ;
     /*
     ;  XIN = RINMAX; "use XIN as limit on radius"
     ;  LOOP[ $RANDOMSET ZIN;
            ZIN=SQRT(-2.*RBEAM2*LOG(1.-ZIN)); "ZIN really radius"
            ] UNTIL ZIN <= XIN;
        "generate a random angle"
        $RANDOMSET YIN; YIN = 2.*3.1415926*YIN;
        XIN = ZIN*COS(YIN);
        YIN = ZIN*SIN(YIN);
      */
      LOOP [
          $RANDOMSET ZIN;
          ZIN=SQRT(-2*LOG(1.-ZIN)); "ZIN really radius"
          $RANDOMSET YIN; YIN = 2.*3.1415926*YIN;
          XIN = xo_src19 + RBEAM*ZIN*COS(YIN);
          YIN = yo_src19 + RBEAMY*ZIN*SIN(YIN);
      ] UNTIL (ABS(XIN)<RINMAX&ABS(YIN)<RINMAX&XIN*XIN+YIN*YIN<RINMAX*RINMAX);
   ]
   IF( sigma_src19 > 0 ) [
     "find uin,vin,win if there is angular spread"
       LOOP [
           $RANDOMSET win; win = 1 + sigma_src19*log(1-win);
       ] UNTIL (win > 0);
       uin = sqrt((1-win)*(1+win));
       $RANDOMSET PHI; PHI = 6.283185308*PHI;
       vin = uin*sin(phi); uin = uin*cos(phi);
   ] ELSE [
       IF(IFPB =  0)[WIN=1.0;UIN=0.0;VIN=0.0;]ELSE[UIN=UINC;VIN=VINC;WIN=WINC;]
   ]
   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]
" ISOURC = 21 or 24
" ***********
ELSEIF(ISOURC = 21 | ISOURC=24)["Full phase space for each particle"
  IF(NRCYCL>0 & CYCLNUM>0 & CYCLNUM<=NRCYCL)["recycle this particle"
     CYCLNUM=CYCLNUM+1;
     XIN=XINOLD;
     YIN=YINOLD;
     UIN=UINOLD;
     VIN=VINOLD;
     WIN=WINOLD;
     WEIGHT=WEIGHTOLD;
     ICM=INIT_ICMOLD;
     ZIN=ZINOLD;
     IF(I_MUPHSP_IN~=0)[
       "make sure any synchronized CMs do not change BEAM_MU_INDEX by setting"
       "BEAM_MU_INDEX_OLD to something different than BEAM_MU_INDEX"
       BEAM_MU_INDEX_OLD=BEAM_MU_INDEX - 1.1;
     ]
     "all other parameters are global and unchanged"
  ]
  ELSE["get a new particle from the phsp file"

     INPHSP=INPHSP+1; "increment counter for particle no."

     :SOURCE_READ:;
    "Note that for ISOURC=21, not only do we need to get the parameters"
    "for SRCHST (i.e. XIN,YIN,ZIN,UIN,VIN,WIN,IRIN and WEIGHT) but also"
    "IQIN and EIN passed in COMIN/SCORE. Note that EKIN is usually"
    "KE for other sources - but in main we treat it as total energy"
    "since that is what it is in the phase space file"

#ifdef HAVE_C_COMPILER;
     "output a warning if we are restarting the chunk of the phase"
     "space source"
     IF(n_parallel>0 & INPHSP>INPHSP_MAX)[
        "rewind phsp source and output a warning"
        INPHSP=INPHSP_MIN;
        OUTCNT=OUTCNT+1;
       OUTPUT ;
     (///' ***WARNING*** USED ALL PARTICLES FROM CHUNK IN SOURCE FILE!'/
       '               RESTARTING FROM FIRST PARTICLE IN THIS CHUNK.'//
       /1x,79('*')// );
      IF(i_iaea_in=1)[ NHSTRY=OUTCNT*NINCSRC/(n_parallel*$N_CHUNKS);
                    "above ensures that NHSTRY is accurate"
                    "note the equivalent does not work for BEAMnrc"
                    "format phsp sources"
          $IAEA_SET_PHSP_RECORD(IINSRC,INPHSP);]
     ]
#endif;

     IF(IPARALLEL>1 & PARNUM>0 & INPHSP > INT(PARNUM*NNPHSP/IPARALLEL))[
       INPHSP=INT((PARNUM-1)*NNPHSP/IPARALLEL)+1;
       OUTCNT=OUTCNT+1;
       OUTPUT ;
     (///' ***WARNING*** USED ALL PARTICLES FROM PARTITION IN SOURCE FILE!'/
       '               RESTARTING FROM FIRST PARTICLE IN THIS PARTITION.'//
       /1x,79('*')// );
       IF(i_iaea_in=1)[ NHSTRY=OUTCNT*NINCSRC/IPARALLEL;
                  $IAEA_SET_PHSP_RECORD(IINSRC,INPHSP); ]
     ]
     ELSEIF(INPHSP.GT.NNPHSP)[
       "used up all the particles stored in the ph-sp file"
       INPHSP=1;"set the pointer back to the beginning of the ph-sp file"
       OUTCNT=OUTCNT+1;
       OUTPUT ;(///' ***WARNING*** USED ALL PARTICLES FROM SOURCE FILE!'/
       '               RESTARTING FROM FIRST PARTICLE IN FILE.'//
       /1x,79('*')// );
       IF(i_iaea_in=1)[ NHSTRY=OUTCNT*NINCSRC;
                 $IAEA_SET_PHSP_RECORD(IINSRC,1); ]
     ]
   IF(i_iaea_in=1)[
       $IAEA_READ_PHSP_RECORD(IINSRC,NPASSI,NHSTRY,LATCHI,IQIN,EREAD,
        WEIGHT,XIN,YIN,ZIN,UIN,VIN,WIN,ZLAST(1),BEAM_MU_INDEX);
       IF(I_MUPHSP_IN=0)BEAM_MU_INDEX=BEAM_MU_INDEX_OLD;
       "ensure BEAM_MU_INDEX gets reset if BEAM_MU_INDEX gets set"
       "to a nonsense value."
   ]
   ELSE[
   $READ_PHSP(IZLAST,IINSRC,INPHSP+1:NHSTRY,NPASSI,IQIN,WIN,ZLAST(1),LATCHI,
               EREAD,WEIGHT,XIN,YIN,UIN,VIN);
   ]
   IF((i_iaea_in=0 & IERR_PHSP>0) | (i_iaea_in=1 & iaea_n_stat=-2))[
         "end of file encountered -restart same file"
       IF(IPARALLEL>1 & PARNUM>0)[
         INPHSP=INT((PARNUM-1)*NNPHSP/IPARALLEL)+1;
         OUTCNT=OUTCNT+1;
         OUTPUT ;
     (///' ***WARNING*** USED ALL PARTICLES FROM PARTITION IN SOURCE FILE!'/
       '               RESTARTING FROM FIRST PARTICLE IN THIS PARTITION.'//
       /1x,79('*')// );
       ]
       ELSE[
         INPHSP=1;"set the pointer back to the beginning of the ph-sp file"
         OUTCNT=OUTCNT+1;
         OUTPUT ;(///' ***WARNING*** USED ALL PARTICLES FROM SOURCE FILE!'/
         '               RESTARTING FROM FIRST PARTICLE IN FILE.'//
       /1x,79('*')// );
       ]
       GOTO :SOURCE_READ:;
    ]
    IF (NPASSI ~= 0) [
       NPASS_ph_sp = NPASS_ph_sp + 1;INPHSP=1+INPHSP;
       GOTO :SOURCE_READ:; "Discard particles if they or their"
                           "ancestors have crossed scoring plane"
    ]
    ELSEIF(ISRC_DBS=1 & IQIN=0)["possibly reject fat photon"
       DISTSRC_DBS=(SSDSRC_DBS-ZSRC_DBS)/WIN;
       IF((XIN+UIN*DISTSRC_DBS)**2+(YIN+VIN*DISTSRC_DBS)**2>RSRC_DBS**2)[
           NFAT_ph_sp=NFAT_ph_sp+1;
           INPHSP=1+INPHSP;
           GOTO :SOURCE_READ:;
       ]
    ]
    EIN = EREAD;  "double prec EREAD stuffed into s.p. variable"
    IF(IQIN = -1)[N_ph_sp_e = N_ph_sp_e + 1; E_ph_sp_e = E_ph_sp_e+EIN;]
    IF(IQIN = 0)[N_ph_sp_g = N_ph_sp_g + 1; E_ph_sp_g = E_ph_sp_g+EIN;]
    IF(IQIN = +1)[N_ph_sp_p = N_ph_sp_p + 1; E_ph_sp_p = E_ph_sp_p+EIN;]
    E_MAX_ph_sp = MAX(E_MAX_ph_sp,EIN);   "ignores rest mass issue"

    IF(ISOURC=24 & (ALPHA24~=0 | BETA24 ~=0))[
          "rotate particle about specified point"
       ZIN = Z_SOURCE-DIST24 - XIN*CALPHA24*SBETA24 - YIN*SALPHA24 +
             DIST24*CALPHA24*CBETA24;
       YIN = -XIN*SALPHA24*SBETA24 + YIN*CALPHA24 + DIST24*SALPHA24*CBETA24;
       XIN =  XIN*CBETA24 + DIST24*SBETA24;
       TEMP = WIN;
       WIN = -UIN*CALPHA24*SBETA24 - VIN*SALPHA24 + WIN*CALPHA24*CBETA24;
       VIN = -UIN*SALPHA24*SBETA24 + VIN*CALPHA24 + TEMP*SALPHA24*CBETA24;
       UIN =  UIN*CBETA24 + TEMP*SBETA24;
       DO I=1,MAX_CMs[
        IF(ZIN < Z_min_CM(I+1))[
           ICM=I;
           EXIT;
        ]
       ]
       IF(CMTYPE(ICM)~='SLABS' & CMTYPE(ICM)~='FLATFILT' &
          CMTYPE(ICM)~='SIDETUBE')[
         OUTPUT;(/' Error in source 24: Particle not incident within a'/
                  ' CM capable of handling internal sources (SLABS, FLATFILT'/
                  ' or SIDETUBE)'//);
         STOP;
       ]
       IDIR=2; "entering from within CM"
       IAUSFL(6)=0; "in case of no initial call to HOWFAR"
    ]
    ELSEIF(IZSCORE=1)["use Z read from IAEA phsp file"
      DO I=1,MAX_CMs[
        IF(ZIN < Z_min_CM(I+1))[
           ICM=I;
           EXIT;
        ]
      ]
      IF(CMTYPE(ICM)~='SLABS' & CMTYPE(ICM)~='FLATFILT' &
          CMTYPE(ICM)~='SIDETUBE')[
         OUTPUT;(/' Error in source 21: Particle not incident within a'/
                  ' CM capable of handling internal sources (SLABS, FLATFILT'/
                  ' or SIDETUBE)'//);
         STOP;
      ]
      IDIR=2; "entering from within CM"
      IAUSFL(6)=0;
    ]
    ELSE[
      ZIN=Z_SOURCE; "Incident Z position"
      ICM = INIT_ICM; "Entering first component module"
                  "changed to any module by JWEI "
      IDIR=1;
    ]

    IF(NRCYCL>0)["store parameters that are not global for recycling"
      CYCLNUM=1;
      XINOLD=XIN;
      YINOLD=YIN;
      ZINOLD=ZIN;
      INIT_ICMOLD=ICM;
      UINOLD=UIN;
      VINOLD=VIN;
      WINOLD=WIN;
      WEIGHTOLD=WEIGHT;
    ]
  ]"end of getting a new particle"
]

ELSEIF(ISOURC=23) ["full beam simulation source"
  :retry_sample_beamsource:;
  call sample_beamsource(ein,xin,yin,zin,uin,vin,win,weight,
                         iqin,latchi,nhstry,iphati);
  IF(ISRC_DBS=1 & iqin=0 & iphati>1)[
      NFAT_ph_sp=NFAT_ph_sp+1;
      GOTO :retry_sample_beamsource:;
  ]
  IF(IQIN = -1)[N_ph_sp_e = N_ph_sp_e + 1; E_ph_sp_e = E_ph_sp_e+EIN;]
  IF(IQIN = 0)[N_ph_sp_g = N_ph_sp_g + 1; E_ph_sp_g = E_ph_sp_g+EIN;]
  IF(IQIN = +1)[N_ph_sp_p = N_ph_sp_p + 1; E_ph_sp_p = E_ph_sp_p+EIN;]
  E_MAX_ph_sp = MAX(E_MAX_ph_sp,EIN);   "ignores rest mass issue"

  IF(ALPHA24 ~= 0 | BETA24 ~= 0)["rotate particle about specified point"
       ZIN = Z_SOURCE-DIST24 - XIN*CALPHA24*SBETA24 - YIN*SALPHA24 +
             DIST24*CALPHA24*CBETA24;
       YIN = -XIN*SALPHA24*SBETA24 + YIN*CALPHA24 + DIST24*SALPHA24*CBETA24;
       XIN =  XIN*CBETA24 + DIST24*SBETA24;
       TEMP = WIN;
       WIN = -UIN*CALPHA24*SBETA24 - VIN*SALPHA24 + WIN*CALPHA24*CBETA24;
       VIN = -UIN*SALPHA24*SBETA24 + VIN*CALPHA24 + TEMP*SALPHA24*CBETA24;
       UIN =  UIN*CBETA24 + TEMP*SBETA24;
       DO I=1,MAX_CMs[
        IF(ZIN < Z_min_CM(I+1))[
           ICM=I;
           EXIT;
        ]
       ]
       IF(CMTYPE(ICM)~='SLABS' & CMTYPE(ICM)~='FLATFILT' &
          CMTYPE(ICM)~='SIDETUBE')[
         OUTPUT;(/' Error in source 23: Particle not incident within a'/
                  ' CM capable of handling internal sources (SLABS, FLATFILT'/
                  ' or SIDETUBE)'//);
         STOP;
       ]
       IDIR=2;"entering from inside CM"
       IAUSFL(6)=0;
  ]
  ELSE[
       ZIN=Z_SOURCE; "Incident Z position"
       ICM = INIT_ICM; "Entering first component module"
                  "changed to any module by JWEI "
       IDIR=1; "entering from front"
  ]
]

" ISOURC = 31
" **********
ELSEIF(ISOURC = 31) ["beam characterization model"
$BEAMMODEL_SOURCE_SAMPLING;
$BEAMMODEL_PASSING_VARIABLES;
]"end of ISOURC = 31"

" Determine initial region
" ************************
" Following expands into set of calls to WHERE_AM_I_$CMNAME to determine region
" number particle is entering in component module ICM.  Require X(NP) and Y(NP)
" in WHERE_AM_I_$CMNAME.
NP = 1;
X(NP) = XIN;
Y(NP) = YIN;
Z(NP) = ZIN;  " added by jwei, NOV. 12, 1992
IQ(NP)= IQIN;
U(NP)=UIN;
V(NP)=VIN;
W(NP)=WIN;
USTEP=0.0;    " this is useful only for isourc=21, the particle enters the
"             INIT_ICM module at the beginning of the correlated simulation,
"             which will overcome a problem with where_am_i_$CMNAME, where when
"             the CM is not the first one, it always uses ustep to determine
"             the ir in the CM.     --added by JWEI.
IF(ISOURC~=21 & ISOURC~=23 & ISOURC~=24)[LATCHI=0;]
LATCH(NP)=LATCHI;

;:PARTICLE_FROM_DOSXYZ:;

IF(dosxyz2beam_index<0)["the stack values were already set in beam_lib.mortran"
   " just need to set the initial values"
    NP=1;
    EIN=E(NP);
    IQIN=IQ(NP);
    XIN=X(NP);
    YIN=Y(NP);
    IF(dosxyz2beam_izscore=1)["use Z from iaea phsp"
        ZIN=Z(NP);
        DO I=1,MAX_CMs[
          IF(ZIN < Z_min_CM(I+1))[
             ICM=I;
             EXIT;
          ]
        ]
        IF(CMTYPE(ICM)~='SLABS' & CMTYPE(ICM)~='FLATFILT' &
          CMTYPE(ICM)~='SIDETUBE')[
         OUTPUT;(/' Error in source 24: Particle not incident within a'/
                  ' CM capable of handling internal sources (SLABS, FLATFILT'/
                  ' or SIDETUBE)'//);
         STOP;
        ]
        IDIR=2;
        IAUSFL(6)=0;
    ] ELSE [
        ZIN=Z_SOURCE;
        Z(NP)=Z_SOURCE;
        IF(ISOURC=21 | ISOURC=23 | ISOURC=24)[
            ICM = INIT_ICM;
        ]
        ELSE["assume it is incident on CM 1"
            ICM=1;
        ]
        IDIR=1;
    ]
    UIN=U(NP);
    VIN=V(NP);
    WIN=W(NP);
    WEIGHT=WT(NP);
    USTEP=0.0;    " this is useful only for isourc=21, the particle enters the
"             INIT_ICM module at the beginning of the correlated simulation,
"             which will overcome a problem with where_am_i_$CMNAME, where when
"             the CM is not the first one, it always uses ustep to determine
"             the ir in the CM.     --added by JWEI.
    LATCHI=LATCH(NP);

]

IF( INSIDE_FLAG > 0 ) [ IRNEW = INSIDE_FLAG; ]
ELSE [
    IF(ISOURC=3 | ISOURC=10 | ISOURC=13 |
       (ISOURC=24 & (ALPHA24 ~= 0 | BETA24 ~= 0)) |
       (ISOURC=23 & (ALPHA24 ~= 0 | BETA24 ~= 0)) |
       (ISOURC=21 & IZSCORE=1) | dosxyz2beam_izscore=1)[
          ;$GOTO_CM_LIST(WHAMI) ICM;
          ;$WHERE_AM_I;
    ]
    ELSE [CALL WHERE_AM_I(ICM-1,1); ]
         "so we can set contaminant bit if needed"
]
IF($BTEST(LATCH(NP),30))["it enters as a contaminant particle"
                          "store this in LATCHI"
       LATCHI=$IBSET(LATCHI,30);
]
IRIN=IRNEW;
RETURN;
:ERROR_SOURCE:
;OUTPUT;
(////' *** SIMULATION STOPS DUE TO THE USE OF WRONG SOURCE/CM ***'//);
$CALL_EXIT(1);

END;   "End of subroutine SRCHST"
%E     "beamnrc.mortran - start subroutine where_am_i                     "
"*******************************************************************************
"
                          SUBROUTINE WHERE_AM_I(IICM,IDIR);
"                         *********************
"*******************************************************************************
"
"     WHERE_AM_I routine for BEAMnrc.
"
" This routine is called from HOWFAR_$CMNAME when a particle reaches the front
" (IDIR=1) or back (IDIR=-1) of a component module.  The index of the new
" component module, ICMNEW, is determined and the correct WHERE_AM_I_$CMNAME
" subroutine is called to determine the new region number, IRNEW.  IAUSFL(6) is
" also set to 1 to initiate an AUSGAB call following particle transport to check
" if the component module boundary is also a scoring plane.
"
"*******************************************************************************
"
"                    TYPE DECLARATIONS AND COMMON BLOCKS
"                    ***********************************
"
$IMPLICIT-NONE;
;COMIN/CMs,EPCONT,STACK,USER/;

"T>********************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I
"T>********************************
"T>
INTEGER
   IICM, "T>component module where current particle resides
   IDIR; "T>particle direction, +1=downstream, -1=upstream

"*******************************************************************************
"
"                 CALL WHERE_AM_I SUBROUTINE OF NEXT COMPONENT MODULE
"                 ***************************************************
"
ICMNEW = IICM+IDIR; "Index of new component module particle is about to enter"
IAUSFL(6) = 1;      "Flag to call AUSGAB after particle transport"
IDIRG=IDIR;         "set the global value of IDIR for later test in AUSGAB"

"
"   Check vacuum region 1 surrounding geometry
"   ******************************************
"
" Check if leaving front or back of geometry

IF (ICMNEW > MAX_CMs | ICMNEW <= 0 ) [ ICMNEW=0; IRNEW=1; RETURN; ]

" Check if leaving geometry through cylindrical boundary
IF (RMAX_CM_FLAG(ICMNEW)=1 &
      (X(NP)+USTEP*U(NP))**2+(Y(NP)+USTEP*V(NP))**2>RMAX_CM2(ICMNEW)) [
   ICMNEW=0; IRNEW=1; RETURN;
]

"Check if leaving geometry through square boundary
ELSEIF (RMAX_CM_FLAG(ICMNEW)=2 &
        (ABS(X(NP)+USTEP*U(NP))>RMAX_CM(ICMNEW) |
         ABS(Y(NP)+USTEP*V(NP))>RMAX_CM(ICMNEW))) [
   ICMNEW=0; IRNEW=1; RETURN;
]
"
"   Check regions within next CM
"   ****************************
" When the particle with charge IQ_CONTAM first enters the front of module
" ICM_CONTAM, the following will automatically
" set the bit 30 of LATCH to record the photon or electron contamination
" and use it in AUSGAB to score the dose separately.
"Note that the IDIR=1 condition was added Sept 2002 to make this"
"correspond only to contamination entering from the front"
"Prior to that, contamination was defined from the back as well"
"Mary Chin pointed this out"
IF(ITDOSE_ON = 1)["dose components are to be calculated  "
   IF(ICMNEW=ICM_CONTAM & ABS(IQ(NP))=ABS(IQ_CONTAM) & (IDIR = 1)) [
      LATCH(NP)=$IBSET(LATCH(NP), 30);
   ]
]

"  The following expands into a computed go to which finds regions in
"  next CM using WHERE_AM_I_$CMNAME?
"
;$GOTO_CM_LIST(WHAMI) ICMNEW;
;$WHERE_AM_I;

RETURN;

END;     "Last line of subroutine WHERE_AM_I"

%E     "beamnrc.mortran - start subroutine datetime                       "
"The following subroutine expands into the macros CALL DATE and CALL TIME"
"Originally, the macros were expanded in the body of the program"
"wherever DATEN and TIMEN had to be set, but this leads to the presence"
"of machine-dependent code throughout BEAMnrc.  With this new format,"
"machine-dependent date and time routines will only exist within this"
"subroutine, making it easier to modify BEAMnrc to run on different"
"machines"

"**********************************************************************"
              SUBROUTINE DATETIME(DUMMY);
"
"**********************************************************************"
$IMPLICIT-NONE;
;COMIN/IO_INFO/;      "contains the variables DATEN,TIMEN,DNTIME"
INTEGER DUMMY;"just a dummy variable"
"June 19, 97  back to CALL DATE    CALL TIME since"
"g77 V0.5.20 works   not sure what g77 does."
"CALL DATE(DATEN); CALL TIME(TIMEN);
"above needed possibly to match up with machine.mortran"
"but following avoids the machine.mortran macro translation"
"and for some unknown reason, works with Linux/g77 whereas"
"the translation, which should be identical, doesnt"
";CALL FDATE(DNTIME);   "
"DATEN(1:7)=DNTIME(5:12);   "
"DATEN(8:11)=DNTIME(21:24);   "
"TIMEN=DNTIME(12:19);   "

" IK: use the EGSnrc egs_fdate function instead. "
call egs_get_fdate(DNTIME);
daten(1:7)=dntime(5:11);
daten(8:11)=dntime(21:24);
timen(1:8)=dntime(12:19);


RETURN;

END; "end of the subroutine DATETIME"


%E    "beamnrc.mortran---start of subroutine SELECT_PHOTON_MFP"

SUBROUTINE SELECT_PHOTON_MFP(DDPMFP);

"This subroutine takes the place of the old $SELECT-PHOTON-MFP macro.
"We enter this subroutine for every photon step"
"variables related to photon forcing (declared in USER-PHOTON-FORCING):"
"NFCMIN=the CM number at which to begin forcing"
"NFCMAX=the CM number after which forcing is stopped"
"NFMIN=the number of interactions occurring within NFCMIN<=CM<=NFCMAX"
"      at which to begin forcing--option has been cut out and is now always"
"      treated as 1"
"NFMAX=the number of interactions occurring within NFCMIN<=CM<=NFCMAX"
"      after which to stop forcing"
"NFTIME(NP)=the number of times that a photon has interacted in"
"           NFCIMIN<=CM<=NFCMAX if photon forcing is on.  By making this"
"           a stack variable, we now force all child photons NFMAX-NFTIME(NP)"
"           times, where NFTIME(NP) is the number of photon interactions"
"           of the parent particle."
"NP_INC(NP)=1 for the photon which is forced to interact "
"          =0 if it is a new photon which may or may not require"
"             forcing"

$IMPLICIT-NONE;
;COMIN/USER,RANDOM,STACK,SCORE,EPCONT,BOUNDS,CMs,USEFUL,PHOTIN,MISC,IO_INFO,
       EGS-IO/;

$REAL RNNO35, "used to store random numbers"
     DDPMFP, "local variable used for number of MFP's to next interaction"
     COHFAC; "Rayleigh scattering correction"

$INTEGER LGLE;   "index for GMFP interpolation"

$RANDOMSET RNNO35;IF(RNNO35 = 0.0)RNNO35=1.E-30;

IF(IFORCE =  0)["no photon forcing" DDPMFP=-LOG(RNNO35); ]

ELSEIF(NP_INC(NP) =  0)["this is a new photon. Check if it should"
                        "be forced to interact.                  "
    NFTIME(NP)=NFTIME(NP)+1;
                    "increment NFTIME(NP) here.  That way, the number of"
                    "interactions is incremented once and only once"
                    "for either a forced or unforced interaction"

    IF((NFTIME(NP) >  NFMAX) | (IR_TO_CM(IR(NP))<NFCMIN)
        | (IR_TO_CM(IR(NP))>NFCMAX) | (NP=$MXSTACK))[
            "forcing not needed in these cases"
            "Above used to also contain a test if NFTIME < NFMIN, however"
            "the NFMIN option has been deleted since it is difficult to"
            "implement and its value is questionable.  Thus, NFMIN is now"
            "always treated as 1."

        IF((IR_TO_CM(IR(NP))<NFCMIN) | (IR_TO_CM(IR(NP))>NFCMAX) )[
            NFTIME(NP)=NFTIME(NP)-1;
            "Since we have already incremented NFTIME(NP) above, we have to"
            "decrement it back to its original value if"
            "the interaction is not occurring within NFCMIN<=CM<=NFCMAX"
            "don't count as it's not in the required CMs"
        ]
        ELSEIF(NP=$MXSTACK)[ "cannot force it to interact here "

            OUTPUT; (' WARNING: MAXIMUM STACK NUMBER REACHED ',
            /' PHOTON INTERACTION FORCING IGNORED THIS TIME!!' );
            NFTIME(NP)=NFTIME(NP)-1;
            "don't count as it cannot be done in this case"
        ]
        DDPMFP=-LOG(RNNO35);
    ]"end of block where forcing not needed although it is on"

    ELSE["force this photon to interact in the specified CMs"
        $SELECT-PHOTON-MFP-FOR-FORCING(DDPMFP);
    ]
] "end of NP_INC(NP) = 0 case "

ELSE[ "NP_INC(NP)=1, now transport the photon that is forced to       "
      "interact in the specified CMs.                                 "
    NP_INC(NP)=0; "re-set the flag"

    IAUSFL(6)=0;"re-set the flag in case it has been set in HOWFAR"

    EPSLON=RNNO35*GWAIT(NP);
    IF(EPSLON <= 1.0E-3)[ DDPMFP=EPSLON*(1.+0.5*EPSLON); ]
    ELSE[
         ARG=1./(1.-EPSLON);
         DDPMFP=LOG(ARG);
    ]
] "end of NP_INC(NP) = 1 case "

RETURN;
END;  "end of subroutine SELECT_PHOTON_MFP"

"==============================================================================
subroutine kill_the_photons(nstart,kill_electrons);
implicit none;
$INTEGER nstart,kill_electrons,rrprobi;
;COMIN/STACK,RANDOM,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
USER-DIRECTIONAL-SOURCE-BIASING,EGS-IO/;

$USER-KILL-PHOTONS;

IDBS=nstart; count_kill_tmp = 0;
IF( nstart > np ) [ return; ]
LOOP[;
   IF(IQ(IDBS)=0) [
       PLAYRR_DBS=0;
       IF(W(IDBS)<=0)[ PLAYRR_DBS=1; rrprobi = nbrspl;]
       ELSE["see if photon is aimed into the field"
           DIST_DBS=(SSD-Z(IDBS))/W(IDBS);"distance to SSD"
           R2_DBS=(X(IDBS)+DIST_DBS*U(IDBS))**2 +
            (Y(IDBS)+DIST_DBS*V(IDBS))**2;"R^2 at SSD"
           IF(R2_DBS >= FS**2) [ PLAYRR_DBS=1; rrprobi = nbrspl; ]
           ELSE IF( do_dsb = 1 ) [
               r2_dbs = r2_dbs/fs**2;
               DO k_dsb=1,dsb_nbin [
                   IF( r2_dbs < dsb_rbin(k_dsb+1) ) EXIT;
               ]
               rrprobi = k_dsb; PLAYRR_DBS=1;
           ]
       ]
       IF(PLAYRR_DBS=1)[
           $RANDOMSET RNNO_DBS;
           IF(RNNO_DBS*rrprobi > 1) ["kill particle"
               count_kill_tmp =count_kill_tmp + 1;
               IF(IDBS<NP)[
                 IF(IWATCH=1 | IWATCH=2)[
                   OUTPUT 1./NBRSPL,IDBS,E(IDBS),IQ(IDBS),IR(IDBS),X(IDBS),
                   Y(IDBS),Z(IDBS),U(IDBS),V(IDBS),W(IDBS),LATCH(IDBS),WT(IDBS);
                   (T10,'Eliminating photon with probability ',F8.5,' :'/
                   T36,I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
                 ]
                 E(IDBS)=E(NP);IQ(IDBS)=IQ(NP);WT(IDBS)=WT(NP);
                 U(IDBS)=U(NP); V(IDBS)=V(NP); W(IDBS)=W(NP);
                 iphat(idbs) = iphat(np);
               ]
               ELSE[
                 IF(IWATCH=1 | IWATCH=2)[
                   OUTPUT 1./NBRSPL,NP,E(NP),IQ(NP),IR(NP),X(NP),Y(NP),
                   Z(NP),U(NP),V(NP),W(NP),LATCH(NP),WT(NP);
                   (T10,'Eliminating photon with probability ',F8.5,' :'/
                   T36,I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
                 ]
               ]
               NP=NP-1;
           ]
           ELSE["keep particle and increase weight"
               WT(IDBS)=WT(IDBS)*rrprobi;
               IPHAT(IDBS)=rrprobi;"mark it as a fat photon"
               IF(IWATCH=1 | IWATCH=2)[
                 OUTPUT IDBS,E(IDBS),IQ(IDBS),IR(IDBS),X(IDBS),
                 Y(IDBS),Z(IDBS),U(IDBS),V(IDBS),W(IDBS),LATCH(IDBS),WT(IDBS);
                 (T10,'Photon survives Russian Roulette :'/
                 T36,I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
               ]
               IDBS=IDBS+1;
          ]
      ]
      ELSE["keep the photon"
          idbs=idbs+1;
      ]
  ]
  ELSE["this is a charged particle, keep it"
     IF( kill_electrons = 0 ) [ IDBS=IDBS+1; ]
     ELSE [
         $RANDOMSET RNNO_DBS;
         IF(RNNO_DBS*NBRSPL > 1) ["kill particle"
             IF(IDBS<NP)[
                 E(IDBS)=E(NP);IQ(IDBS)=IQ(NP);WT(IDBS)=WT(NP);
                 U(IDBS)=U(NP); V(IDBS)=V(NP); W(IDBS)=W(NP);
             ]
             np=np-1;
         ]
         ELSE [ "keep particle and increase weight"
             WT(IDBS)=WT(IDBS)*NBRSPL;
             IPHAT(IDBS)=NBRSPL;
             IDBS=IDBS+1;
         ]
     ]
  ]
] UNTIL (IDBS>NP);
return; end;

"====================================================================="
          subroutine uniform_photons(nsample,energy);
"====================================================================="
" Samples nsample photons with random directions.                     "
" If a photon hits a circle with radius fs at z position ssd, it is   "
" put on the stack with a weight wt(npold)/nbrspl. If it does not,    "
" it is kept on the stack with probability 1/nbrspl and given a       "
" weight of wt(npold). To reduce the number of uniformly sampled      "
" directions, the minimum and maximum polar angles for which a photon "
" may hit the circle is calculated and on average                     "
"   nsample*(ct_max-ct_min)/2                                         "
" are forced to have polar angles between ct_min and ct_max.          "
" To be used for annihilation at rest and fluorescent photons         "
" nsample will be 2*nbrspl for annihilation events and nbrspl for     "
" fluorescent photons                                                 "
" IK, September 2002.                                                 "
"====================================================================="
implicit none;
$INTEGER nsample;
$REAL    energy;
;COMIN/STACK,RANDOM,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
       USER-STACK,USER-PHOTON-FORCING,
       USER-DIRECTIONAL-SOURCE-BIASING,EGS-IO/;
$REAL    ro,d,aux,ct_min,ct_max,an_split,rnno,weight,cost,sint,xx,yy,cphi,sphi;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
$INTEGER n_split,i,ns;

" Calculate the minimum and maximum polar angles that may result "
" in a direction towards the circle with radius fs at ssd        "
ro = sqrt(x(np)*x(np)+y(np)*y(np)); d = ssd - z(np); aux = (ro + fs)/d;
ct_min = 1./sqrt(1+aux*aux);
IF( ro <= fs ) [ ct_max = 1; ]
ELSE [ aux = (fs-ro)/d; ct_max = 1./sqrt(1+aux*aux); ]

" Out of the nsample uniform photons, an_split will be having polar angles "
" between ct_min and ct_max                                               "
an_split = 0.5*(ct_max - ct_min)*nsample;
n_split = an_split; an_split = an_split - n_split;
$RANDOMSET rnno; IF( rnno < an_split ) [ n_split = n_split + 1; ]
count_kill_tmp = nsample - n_split;

" Now create the nsplit photons. Note: not all directions with polar angles "
" between ct_min and ct_max will hit the circle. We will therefore play "
" Russian Roulette with photons not going towards the circle            "
weight = wt(npold)/nbrspl;
np = np-1;
DO i=1,n_split [
    $RANDOMSET rnno; cost = ct_min + rnno*(ct_max - ct_min);
    sint = 1-cost*cost;
    IF( sint > 0 ) [ sint = sqrt(sint); ] ELSE [ sint = 0; ]
    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
    aux = d/cost*sint;
    xx = x(npold) + aux*cphi; yy = y(npold) + aux*sphi;
    ns = 0; rsq_dsb = xx*xx + yy*yy;
    IF( rsq_dsb < fs*fs ) [
        ns = 1;
        IF( do_dsb = 1 ) [
            rsq_dsb = rsq_dsb/fs**2;
            DO k_dsb = 1,dsb_nbin [
                IF( rsq_dsb < dsb_rbin(k_dsb+1) ) EXIT;
            ]
            ns = k_dsb;
        ]
    ]
    ELSE [ ns = nbrspl; ]
    IF( ns > 1 ) [
        $RANDOMSET rnno;
        IF( rnno*ns > 1 ) [ ns = 0; ]
    ]
    IF( ns > 0 ) [
        np = np+1;
        $CHECK-STACK(np,'uniform_photons');
        $TRANSFER PROPERTIES TO (np) FROM (NPold);
        e(np) = energy; iq(np) = 0; wt(np) = weight*ns;
        u(np) = sint*cphi; v(np) = sint*sphi; w(np) = cost;
        iphat(np) = ns;
    ] ELSE [ count_kill_tmp = count_kill_tmp + 1; ]
]

" There will be on average (1-(ct_max-ct_min)/2)*nsample photons with   "
" polar angles outside of the desired range. Such photons are guaranteed"
" to not hit the circle => they must be Russian Rouletted => on average "
" (1-(ct_max-ct_min)/2)*nsample/nbrspl will survive. We model this by   "
" sampling nsample/nbrspl photons using all polar angles and rejecting  "
" those with polar angles between ct_min and ct_max (taken into account "
" above).                                                               "
n_split = nsample/nbrspl;
DO i=1,n_split [
    $RANDOMSET rnno; cost = 2*rnno-1;
    IF( cost < ct_min | cost > ct_max ) [
        sint = 1-cost*cost;
        IF( sint > 0 ) [ sint = sqrt(sint); ] ELSE [ sint = 0; ]
        $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
        np = np+1;
        $CHECK-STACK(np,'uniform_photons');
        $TRANSFER PROPERTIES TO (np) FROM (NPold);
        e(np) = energy; iq(np) = 0; wt(np) = weight*nbrspl;
        u(np) = sint*cphi; v(np) = sint*sphi; w(np) = cost;
        iphat(np) = nbrspl;
    ] ELSE [ count_kill_tmp = count_kill_tmp + 1; ]
]
return; end;

REPLACE {$STORE-PARTICLE-PROPERTIES-DBS;} WITH {
  x_dbs=x(np); y_dbs=y(np); z_dbs=z(np); ir_dbs=ir(np); wt_dbs=wt(np);
  dnear_dbs=dnear(np); latch_dbs=latch(np); zlast_dbs=zlast(np);
  nftime_dbs=nftime(np); nsplit_dbs=nsplit(np);
  DO j=1,$MAX_SC_PLANES[ npass_dbs(j) = npass(np,j); ]
  u_dbs=u(np); v_dbs=v(np); w_dbs=w(np); e_dbs=e(np);
};

REPLACE {$RESTORE-PARTICLE-PROPERTIES-DBS;} WITH {
        x(np)=x_dbs; y(np)=y_dbs; z(np)=z_dbs;
        wt(np)=wt_dbs; iq(np)=0; ir(np)=ir_dbs;
        dnear(np)=dnear_dbs; latch(np)=latch_dbs; zlast(np)=zlast_dbs;
        nftime(np)=nftime_dbs; nsplit(np)=nsplit_dbs;
        DO j=1,$MAX_SC_PLANES[ npass(np,j)=npass_dbs(j); ]
        u(np)=u_dbs; v(np)=v_dbs; w(np)=w_dbs; e(np)=e_dbs;
        iphat(np)=1;
};

"==========================================================================="
         subroutine do_compton;
"==========================================================================="
" Performs nbrspl compton events. All electrons are killed with probability "
" 1/nbrspl. Scattered photons are kept on the stack if they go towards the  "
" circle wirh radius fs at ssd, otherwise they also are killed with         "
" probability 1/nbrspl.                                                     "
"                                                                           "
" IK, September 2002                                                        "
"==========================================================================="
implicit none;
;COMIN/STACK,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
       USER-STACK,USER-PHOTON-FORCING,EGS-IO/;
$INTEGER np_save,i,j,kill_electrons,nps;

np_save = np; iphat(np) = 1; wt(np) = wt(np)/nbrspl;
IF(ICM_DBS>0 & Z(NP)>ZRR_DBS)[ kill_electrons=0; ] ELSE [ kill_electrons=1; ]
$STORE-PARTICLE-PROPERTIES-DBS;
DO i=1,nbrspl [
    IF( i > 1 ) [
        np=np+1;
        $CHECK-STACK(np,'do_compton');
        $RESTORE-PARTICLE-PROPERTIES-DBS;
    ]
    nps = np;
    IF(LATCH_OPTION=2 | LATCH_OPTION=3)LATCH(np)= LATCHOUT;
    "easier to pass on latch of secondaries by transferring"
    IF(IZLAST=1)zlast(np)=z(np);
    call compt;
    IF(LATCH_OPTION=2 | LATCH_OPTION=3)[
       IF(np>npold)[LATCH(npold)=LATCHIN;]
       ELSE[LATCH(npold)=LATCHOLD;]"interaction rejected"
    ]
    IF(IZLAST=1 & np=npold)zlast(npold)=zlastold;"interaction rejected"
    call kill_the_photons(nps,kill_electrons);
    IF(IZLAST=2)[
       DO j=NPold,NP[
           ZLAST(j)=Z(j);
           XLAST(j)=X(j);
           YLAST(j)=Y(j);
       ]
    ]
]
npold = np_save;
/*
IF(ICM_DBS>0 & Z(NP)>ZRR_DBS)["do not Rus Rou. electrons"
   call kill_the_photons(np_save,0);
]
ELSE["Rus. Rou. electrons"
   call kill_the_photons(np_save,1);
]
*/
return; end;

"==========================================================================="
         subroutine do_pair;
"==========================================================================="
" Performs nbrspl pair events. This is only used if IBRSPL=2 (DBS) with     "
" electron splitting and Z(NP)>ZRR_DBS.  Resulting charged particles are all"
" kept.                                                                     "
"==========================================================================="
implicit none;
;COMIN/STACK,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
       USER-STACK,USER-PHOTON-FORCING,EGS-IO/;
$INTEGER np_save,i,j;

np_save = np; iphat(np)=1; wt(np) = wt(np)/nbrspl;
$STORE-PARTICLE-PROPERTIES-DBS;
DO i=1,nbrspl [
    IF( i > 1 ) [
        np=np+1;
        $CHECK-STACK(np,'do_pair');
        $RESTORE-PARTICLE-PROPERTIES-DBS;
    ]
    call pair;
]
npold = np_save;
return; end;

"==========================================================================="
         subroutine do_photo;
"==========================================================================="
" Performs nbrspl photoelectric events. This is only used if IBRSPL=2 (DBS) "
" with electron splitting and Z(NP)>ZRR_DBS.  Resulting electrons are all   "
" kept.                                                                     "
"==========================================================================="
implicit none;
;COMIN/STACK,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
       USER-STACK,USER-PHOTON-FORCING,EGS-IO/;
$INTEGER np_save,i,j;

np_save = np; iphat(np) = 1; wt(np) = wt(np)/nbrspl;
$STORE-PARTICLE-PROPERTIES-DBS;
DO i=1,nbrspl [
    IF( i > 1 ) [
        np=np+1;
        $CHECK-STACK(np,'do_photo');
        $RESTORE-PARTICLE-PROPERTIES-DBS;
    ]
    call photo;
]
npold = np_save;
return; end;

"==========================================================================="
         subroutine do_old_rayleigh(nsample);
"==========================================================================="
implicit none;
;COMIN/STACK,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,EGS-IO,
       USER-STACK,USER-PHOTON-FORCING,RANDOM,THRESH,UPHIOT,PHOTIN,USEFUL/;
$INTEGER np_save,i,j,lxxx,nsample,nps;
$REAL    xxx,x2,q2,csqthe,rejf,rnnorj;

np_save = np; iphat(np) = 1; wt(np) = wt(np)/nsample;
$STORE-PARTICLE-PROPERTIES-DBS;
DO i=1,nsample [
    IF( i > 1 ) [
        np=np+1;
        $CHECK-STACK(np,'do_old_rayleigh');
        $RESTORE-PARTICLE-PROPERTIES-DBS;
    ]
    ;
    :retry-loop: LOOP [
        $RANDOMSET xxx;
        $SET INTERVAL XXX,RCO; $EVALUATE X2 USING RSCT(XXX);
        Q2=X2*RMSQ/(20.60744*20.60744);
        COSTHE=1.-Q2/(2.*E(NP)*E(NP));
        IF (ABS(COSTHE).GT.1.0) GO TO :retry-loop:;
        CSQTHE=COSTHE*COSTHE;
        REJF=(1.0+CSQTHE)/2.0;
        $RANDOMSET RNNORJ;
    ] UNTIL (RNNORJ <= REJF);
    SINTHE=SQRT(1.0-CSQTHE); CALL UPHI(2,1);
    nps = np;
    call kill_the_photons(nps,0);
]
npold = np_save;
"call kill_the_photons(np_save,0);"
return; end;

"==========================================================================="
subroutine do_rayleigh(nsample);
"==========================================================================="
implicit none;
$declare_max_medium;
$INTEGER np_save,i,j,lxxx,nsample,nps,lgle;
$REAL    loge;
;COMIN/PHOTIN,USEFUL,EPCONT,STACK,RANDOM,UPHIOT,THRESH,
       USER-DIRECTIONAL-BREM-SPLITTING,USER-STACK,EGS-IO,
       USER-PHOTON-FORCING,USER-SPLITTING/;

np_save = np; iphat(np) = 1; wt(np) = wt(np)/nsample;
$STORE-PARTICLE-PROPERTIES-DBS;
"loge = log(E(NP)); LGLE=GE1(MEDIUM)*loge+GE0(MEDIUM);
loge = gle; LGLE=GE1(MEDIUM)*loge+GE0(MEDIUM);
DO i=1,nsample [
    IF( i > 1 ) [
        np=np+1;
        $CHECK-STACK(np,'do_rayleigh');
        $RESTORE-PARTICLE-PROPERTIES-DBS;
    ]
    call egs_rayleigh_sampling(medium,e(np),gle,lgle,costhe,sinthe);
    call uphi(2,1);
    nps = np; call kill_the_photons(nps,0);
]
npold = np_save;
return; end;

"==========================================================================="
       subroutine do_smart_compton;
"==========================================================================="
" If Compton scattering is modeled using Klein-Nishina, and if one keeps    "
" just one electron per Compton event, one
" can substantially improve the DBS efficiency by calculating in advance    "
" the probability for scattered photons going into the circle of interest.  "
" This subroutine implements the technique.                                 "
"                                                                           "
" I. Kawrakow, Septemner 2002                                               "
"==========================================================================="
implicit none;
;COMIN/STACK,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
       USER-STACK,USER-PHOTON-FORCING,RANDOM,THRESH,UPHIOT,PHOTIN,USEFUL,
       USER-DIRECTIONAL-SOURCE-BIASING,EGS-IO/;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
$REAL    ctmin,ctmax,ko,ko2,eps1,eps2,w1,w2,wc,broi,alpha1_t,alpha2_t,
         alpha_t,alpha1,alpha2,alpha,eps1_t,eps2_t,eps1_0,eps2_0,
         rnno,rnno1,rnno2,rnno3,rej1,rej2,rejmax,rejf,asample,
         weight,br,cost,sint,temp,cphi,sphi,us,vs,un,vn,wn,x1,y1,
         eps12_t,eps12,sindel,cosdel,sinpsi,aux,ro;
real*8   peig,pese,pesg;
$INTEGER nsample,i,ns;
$LOGICAL need_rotation;
$INTEGER ntest;
"$REAL    nc1,nc2,nc3;

"ntest = 1000000; nc1=0; nc2=0; nc3=0;

call get_ctminmax(x(np),y(np),z(np),u(np),v(np),w(np),ro,fs,ssd,ctmin,ctmax);
"write(25,*) '*******do_smart_compton: e = ',e(np),' ctmin/max = ',ctmin,ctmax,
"' weight = ',wt(np);
"write(25,*) ' pos: ',x(np),y(np),z(np),' dir: ',u(np),v(np),w(np);
npold = np;
peig = e(np); ko = peig/rm; broi = 1 + 2*ko;  ko2 = ko*ko;
alpha1_t = Log(broi);
eps1_t = 1./broi; eps2_t = 1;
w2 = alpha1_t*(Ko2-2*Ko-2)+(eps2_t-eps1_t)*(1./eps1_t/eps2_t + broi
    + Ko2*(eps1_t+eps2_t)/2);
eps12_t = eps1_t*eps1_t; alpha2_t = (eps2_t*eps2_t-eps12_t);
alpha_t = alpha1_t/(alpha1_t+alpha2_t/2);
eps1 = 1./(1+Ko*(1-ctmin)); eps2 = 1./(1+Ko*(1-ctmax));
eps1_0 = eps1; eps2_0 = eps2;
alpha1 = log(eps2/eps1);
w1 = alpha1*(Ko2-2*Ko-2)+(eps2-eps1)*(1./eps1/eps2 + broi
    + Ko2*(eps1+eps2)/2);
eps12 = eps1*eps1; alpha2 = (eps2*eps2-eps12);
alpha = alpha1/(alpha1+alpha2/2);
rej1 = 1-(1-eps1)*(broi*eps1-1)/(Ko*Ko*eps1*(1+eps1*eps1));
rej2 = 1-(1-eps2)*(broi*eps2-1)/(Ko*Ko*eps2*(1+eps2*eps2));
rejmax = MAX(rej1,rej2);

wc = w1/w2;
asample = wc*nbrspl; nsample = asample; asample = asample - nsample;
$RANDOMSET rnno; IF( rnno < asample ) [ nsample = nsample + 1; ]
nsample = nsample + 1;
"write(25,*) ' wc = ',wc,' nsample = ',nsample;

sinpsi = u(npold)*u(npold)+v(npold)*v(npold);
IF( sinpsi > 1e-20 ) [
    sinpsi = sqrt(sinpsi); sindel = v(npold)/sinpsi; cosdel = u(npold)/sinpsi;
    need_rotation = .true.;
] ELSE [ need_rotation = .false.; ]
weight = wt(npold)/nbrspl;

DO i=1,nsample [
    IF( i = nsample ) [
        eps1 = eps1_t; eps2 = 1; eps12 = eps12_t;
        alpha1 = alpha1_t; alpha2 = alpha2_t; alpha = alpha_t;
        rejmax = 1;
    ]
    LOOP [
        $RANDOMSET rnno1; $RANDOMSET rnno2; $RANDOMSET rnno3;
        IF( rnno1 < alpha ) [ br = eps1*exp(alpha1*rnno2); ]
        ELSE                [ br = sqrt(eps12 + rnno2*alpha2); ]
        Temp = (1-Br)/Ko/Br; Sint = Temp*(2-Temp);
        rejf = 1 - Br*Sint/(1+Br*Br);
    ] WHILE ( rnno3*rejmax > rejf );
    pesg = br*peig; pese = prm + peig - pesg;
    IF( Temp < 2 ) [ cost = 1 - Temp; sint = sqrt(Sint); ]
    ELSE [ cost = -1; sint = 0; ]
    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
    IF( i = nsample ) [
        IF( br > eps1_0 & br < eps2_0 ) goto :do_the_electron:;
        ns = nbrspl;
    ]
    IF( need_rotation ) [
        us = sint*cphi; vs = sint*sphi;
        un = w(npold)*cosdel*us - sindel*vs + u(npold)*cost;
        vn = w(npold)*sindel*us + cosdel*vs + v(npold)*cost;
        wn = w(npold)*cost - sinpsi*us;
    ]
    ELSE [ un = sint*cphi; vn = sint*sphi; wn = w(npold)*cost; ]
    IF( i < nsample ) [
        ns = nbrspl;
        IF( wn > 0 ) [
            aux = (ssd-z(npold))/wn;
            x1 = x(npold) + un*aux; y1 = y(npold) + vn*aux;
            rsq_dsb = x1*x1+y1*y1;
            IF( rsq_dsb < fs*fs ) [
                ns = 1;
                IF( do_dsb = 1 ) [
                    rsq_dsb = rsq_dsb/fs**2;
                    DO k_dsb=1,dsb_nbin [
                        IF( rsq_dsb < dsb_rbin(k_dsb+1) ) EXIT;
                    ]
                    ns = k_dsb;
                ]
            ]
        ]
        IF( ns > 1 ) [
            $RANDOMSET rnno;
            IF( rnno*ns > 1 ) [ ns = 0; ]
        ]
    ]
    "IF( wn > 0 ) [
    "    aux = (ssd-z(npold))/wn;
    "    x1 = x(npold) + un*aux; y1 = y(npold) + vn*aux;
    "    write(25,*) '+',i,ns,cost,sqrt(x1*x1+y1*y1);
    "] ELSE [ write(25,*) '-',i,ns,cost,wn; ]
    IF( ns > 0 ) [
        np = np+1;
        $CHECK-STACK(np,'do_smart_compton');
        $TRANSFER PROPERTIES TO (np) FROM (npold);
        u(np) = un; v(np) = vn; w(np) = wn; iq(np) = 0; wt(np) = weight*ns;
        e(np)=pesg; iphat(np) = ns;
    ]
]

:do_the_electron:
aux = 1 + Br*Br - 2*Br*cost;
IF( aux > 1e-8 ) [
    cost = (1-Br*cost)/sqrt(aux);
    sint = 1 - cost*cost;
    IF( sint > 0 ) [ sint = -sqrt(sint); ]
    ELSE [ sint = 0; ] "write(6,*) 'Precision problem in smart compton'; ]"
    us = sint*cphi; vs = sint*sphi;
    u(npold) = w(npold)*cosdel*us - sindel*vs + u(npold)*cost;
    v(npold) = w(npold)*sindel*us + cosdel*vs + v(npold)*cost;
    w(npold) = w(npold)*cost - sinpsi*us;
]
e(npold) = pese; iq(npold) = -1; iphat(npold) = nbrspl;

return; end;

"==========================================================================="
       subroutine do_smart_brems;
"==========================================================================="
" If the brems angular distribution is simple (leading term, ibrdst=0), one "
" can substantially improve the DBS efficiency by calculating in advance    "
" the probability for brems emission into the circle of interest.           "
" This subroutine implements the technique.                                 "
"                                                                           "
" I. Kawrakow, Septemner 2002                                               "
"==========================================================================="
implicit none;
;COMIN/STACK,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
       USER-STACK,USER-PHOTON-FORCING,RANDOM,THRESH,UPHIOT,PHOTIN,USEFUL,
       BREMPR,EGS-VARIANCE-REDUCTION,EPCONT,NIST-BREMS,
       USER-DIRECTIONAL-SOURCE-BIASING,EGS-IO/;

$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
$REAL    ener, tau, beta2, beta, ct_min, ct_max, wprob, asample, aux1,
         aux2, sinpsi, sindel, cosdel, rnno, cost, sint, cphi, sphi, r1,
         us, vs, un, vn, wn, weight, eie, ekin, ese, esg, brmin, waux,
         ajj,br,alias_sample1,rnno06,rnno07,delta,phi1,phi2,rejf,x1,y1,aux;
$REAL    r,ro,d,dmin,wprob1,dist,disti,rnno_o;
$INTEGER nsample,i,ibr,ns,jj,l,l1,ip,j;
$LOGICAL need_rotation,method1;
real*8   peie,pese,pesg;

npold = np;
ener = e(np) - rm; tau = ener/rm;
beta2 = tau*(tau+2)/(tau+1)**2; beta = sqrt(beta2);
call get_ctminmax(x(np),y(np),z(np),u(np),v(np),w(np),ro,fs,ssd,ct_min,ct_max);
wprob = (ct_max - ct_min)/((1-beta*ct_max)*(1-beta*ct_min)*2*
                             (tau+1)*(tau+1));

d = ssd - z(np);
IF( ro <= fs ) [ dmin = d; ] ELSE [ dmin = sqrt(d*d + (ro-fs)*(ro-fs)); ]
wprob1 = fs*fs*d/(2*dmin*dmin*dmin);
aux = (tau+1)*(1-beta*ct_max);
wprob1 = wprob1/(2*aux*aux);

IF( wprob1 < wprob ) [ method1 = .true.; wprob = wprob1; ]
ELSE                 [ method1 = .false.; ]

IF( wprob < 1 ) [
    asample = wprob*nbrspl; nsample = asample; asample = asample - nsample;
    $RANDOMSET rnno; IF( rnno < asample ) [ nsample = nsample + 1; ]
] ELSE [ ct_max = 1; ct_min = -1; nsample = nbrspl; method1 = .false.; ]

" Now we know approximately how many photons will go into the circle of "
" interest. Sample them. "
aux1 = ct_max - ct_min; aux2 = 1 - beta*ct_max; weight = wt(np)/nbrspl;
sinpsi = u(npold)*u(npold)+v(npold)*v(npold);
IF( sinpsi > 1e-20 ) [
    sinpsi = sqrt(sinpsi); sindel = v(npold)/sinpsi; cosdel = u(npold)/sinpsi;
    need_rotation = .true.;
] ELSE [ need_rotation = .false.; ]
"$RANDOMSET rnno_o;
DO i=1,nsample [
    IF( method1 ) [
        $RANDOMSET r; $RANDOMSET rnno;
        IF( rnno > r ) r = rnno;
        "r = sqrt((i-rnno_o)/nsample);
        $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
        x1 = fs*r*cphi; y1 = fs*r*sphi;
        un = x1 - x(npold); vn = y1 - y(npold); wn = d;
        dist = sqrt(un*un + vn*vn + wn*wn); disti = 1/dist;
        cost = (u(npold)*un + v(npold)*vn + w(npold)*wn)*disti;
        rejf = (1-beta*ct_max)*dmin*disti/(1-beta*cost);
        rejf = rejf*rejf*dmin*disti;
        $RANDOMSET rnno;
        IF( rnno < rejf ) [
            ns = 1; un = un*disti; vn = vn*disti; wn = wn*disti;
        ]
        ELSE [ ns = 0; ]
    ]
    ELSE [
        $RANDOMSET rnno; rnno = rnno*aux1;
        "rnno = (i-rnno_o)/nsample; rnno = rnno*aux1;
        cost = (ct_min*aux2+rnno)/(aux2+beta*rnno);
        sint = 1-cost*cost;
        IF( sint > 0 ) [ sint = sqrt(sint); ] ELSE [ sint = 0; ]
        $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
        IF( need_rotation ) [
            us = sint*cphi; vs = sint*sphi;
            un = w(npold)*cosdel*us - sindel*vs + u(npold)*cost;
            vn = w(npold)*sindel*us + cosdel*vs + v(npold)*cost;
            wn = w(npold)*cost - sinpsi*us;
        ]
        ELSE [ un = sint*cphi; vn = sint*sphi; wn = w(npold)*cost; ]
        ns = 0;
        IF( wn > 0 ) [
            aux = (ssd-z(npold))/wn;
            x1 = x(npold) + un*aux; y1 = y(npold) + vn*aux;
            rsq_dsb = x1*x1+y1*y1;
            IF( rsq_dsb <= fs*fs ) [
                ns = 1;
                IF( do_dsb = 1 ) [
                    rsq_dsb = rsq_dsb/fs**2;
                    DO k_dsb=1,dsb_nbin [
                        IF( rsq_dsb < dsb_rbin(k_dsb+1) ) EXIT;
                    ]
                    ns = k_dsb;
                ]
            ]
        ]
        IF( ns > 1 ) [
            $RANDOMSET rnno;
            IF( rnno*ns > 1 ) [ ns = 0; ]
        ]
    ]
    IF( ns > 0 ) [
        np = np+1;
        $CHECK-STACK(np,'do_smart_brems');
        $TRANSFER PROPERTIES TO (np) FROM (npold);
        u(np) = un; v(np) = vn; w(np) = wn; iq(np) = 0; wt(np) = weight*ns;
        iphat(np) = ns;
    ]
]

" Now pick one more direction and if it is not between ct_min and ct_max "
" (already taken into account above), add a fat photon                   "
aux1 = 2; aux2 = 1 - beta;
$RANDOMSET rnno; rnno = rnno*aux1;
cost = (rnno-aux2)/(aux2+beta*rnno);
sint = 1-cost*cost; IF( sint > 0 ) [ sint = sqrt(sint); ] ELSE [ sint = 0; ]
$SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
IF( need_rotation ) [
    us = sint*cphi; vs = sint*sphi;
    un = w(npold)*cosdel*us - sindel*vs + u(npold)*cost;
    vn = w(npold)*sindel*us + cosdel*vs + v(npold)*cost;
    wn = w(npold)*cost - sinpsi*us;
]
ELSE [ un = sint*cphi; vn = sint*sphi; wn = w(npold)*cost; ]
ns = nbrspl;
IF( wn > 0 ) [
    aux = (ssd-z(npold))/wn;
    x1 = x(npold) + un*aux; y1 = y(npold) + vn*aux;
    rsq_dsb = x1*x1+y1*y1;
    IF( rsq_dsb <= fs*fs ) ns = 0;
]
IF( ns > 0 ) [
    np = np+1; $CHECK-STACK(np,'do_smart_brems');
    $TRANSFER PROPERTIES TO (np) FROM (npold);
    u(np) = un; v(np) = vn; w(np) = wn;
    iq(np) = 0; wt(np) = weight*ns; iphat(np) = ns;
]

" The following samples the energies of the surviving photons "
" It is just cut/paste from subroutine BREMS.                 "
nsample = np - npold;
IF( nsample < 1 ) nsample = 1;
PEIE=E(NPold);
EIE=PEIE;
IF (EIE.LT.50.0)[ L=1; ] ELSE [ L=3; ]
L1 = L+1;
ekin = peie-prm; brmin = ap(medium)/ekin;
waux = elke - log_ap(medium);
IF( ibr_nist = 1 ) [
    ajj = 1 + (waux + log_ap(medium) - nb_lemin(medium))*nb_dlei(medium);
    jj = ajj; ajj = ajj - jj;
    IF( jj >  $MXBRES ) [ jj = $MXBRES; ajj = -1; ]
]
ip = npold;
DO ibr = 1,nsample [
    ip = ip+1;
    IF( ibr_nist = 1 ) [ "use the NIST bremsstrahlung cross section"
                         "data base"
        IF( ekin > nb_emin(medium) ) [
            $RANDOMSET r1;
            IF( r1 < ajj ) [ j = jj+1; ] ELSE [ j = jj; ]
            br = alias_sample1($MXBRXS,nb_xdata(0,j,medium),
                               nb_fdata(0,j,medium),
                               nb_wdata(1,j,medium),nb_idata(1,j,medium));
        ]
        ELSE [ $RANDOMSET br; ]
        esg = ap(medium)*exp(br*waux); pesg = esg;
        pese = peie - pesg; ese = pese;
    ]
    ELSE [

        LOOP [ "User wants to use Bethe-Heitler"

            $RANDOMSET rnno06; $RANDOMSET rnno07;
            br = brmin*exp(rnno06*waux);
            esg = ekin*br; pesg = esg;
            pese = peie - pesg; ese = pese;
            delta = esg/eie/ese*delcm(medium); aux = ese/eie;
            IF( delta < 1 ) [
                phi1 = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
                phi2 = dl1(l1,medium)+delta*(dl2(l1,medium)+
                        delta*dl3(l1,medium));
            ]
            ELSE [
                phi1 = dl4(l,medium)+dl5(l,medium)*log(delta+dl6(l,medium));
                phi2 = phi1;
            ]
            rejf = (1+aux*aux)*phi1 - 2*aux*phi2/3;

        ] UNTIL (rnno07 < rejf);
    ]
    IF( ip <= np ) [ e(ip) = pesg; ]
]
e(npold) = pese;
return; end;


subroutine get_ctminmax(xo,yo,zo,uo,vo,wo,ro,fs,ssd,ct_min,ct_max);
implicit none;
$REAL xo,yo,zo,uo,vo,wo,ro,fs,ssd,ct_min,ct_max;
$REAL d,d2,st,dmin,dmax,aux;

d = ssd - zo; d2 = d*d;
ro = sqrt(xo*xo+yo*yo);
st = 1-wo*wo; IF( st > 0 ) [ st = sqrt(st); ] ELSE [ st = 0; ]
IF( ro <= fs ) [ dmin = d; ] ELSE [ dmin = sqrt(d2+(fs-ro)*(fs-ro)); ]
dmax = sqrt(d2+(fs+ro)*(fs+ro));
aux = wo*d-xo*uo-yo*vo;
ct_max = aux+fs*st;
IF( ct_max > 0 ) [ ct_max = ct_max/dmin; ] ELSE [ ct_max = ct_max/dmax; ]
IF( ct_max > 1 ) ct_max = 1;
ct_min = aux-fs*st;
IF( ct_min > 0 ) [ ct_min = ct_min/dmax; ] ELSE [ ct_min = ct_min/dmin; ]
IF( ct_min < -1 ) ct_min = -1;
return; end;

subroutine old_get_ctminmax(x,y,z,u,v,w,fs,ssd,ct_min,ct_max);
implicit none;
$REAL x,y,z,u,v,w,fs,ssd,ct_min,ct_max;
$REAL ro,aw,d,d2,taux,x1,y1,r,tmp;

"Was :
"ro = sqrt(x*x+y*y); aw = abs(w); d = ssd - z; d2 = d*d;
"IF( aw > 1e-6 ) [
"    taux = d/aw;
ro = sqrt(x*x+y*y); d = ssd - z; d2 = d*d;
IF( abs(w) > 1e-6 ) [
    taux = d/w;
    x1 = x+taux*u; y1 = y+taux*v; r = sqrt(x1*x1+y1*y1);
    IF( r < fs ) [ ct_max = 1; ]
    ELSE [
        ct_max = (d2+(fs-ro)*(r-ro))/
                 sqrt((d2+(r-ro)*(r-ro))*(d2+(fs-ro)*(fs-ro)));
    ]
    ct_min = (d2-(r-ro)*(fs+ro))/
               sqrt((d2+(r-ro)*(r-ro))*(d2+(fs+ro)*(fs+ro)));
    IF( w < 0 ) [
        tmp = ct_min; ct_min = -ct_max; ct_max = -tmp;
    ]
]
ELSE [
    ct_min = -(fs+ro)/sqrt(d2+(fs+ro)*(fs+ro));
    ct_max = (fs-ro)/sqrt(d2+(fs-ro)*(fs-ro));
]
return; end;

"==========================================================================="
       subroutine combine_results(file_name);
"==========================================================================="
" Subroutine called at the end of all parallel runs to recombine the results"
" This used to have to be done separately by the user.                      "
"                                                                           "
"==========================================================================="
implicit none;
COMIN/IO_INFO,SCORE,SOURCE,RANDOM,CH-Steps,USER,EGS-IO/;
character*(*) file_name;
$INTEGER egs_get_unit,lnblnk1;
$INTEGER IS,I1,I2,I3,I4,TEMPNPASS_ph_sp,TEMPNFAT_ph_sp,IT,ITMAX;
$LONG_INT TEMPSCFLU_NUM(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,2),
   TEMPNCASE, TEMPNHSTRY, TEMPNPPHSP($MAX_SC_PLANES);
$REAL TEMPTMCPU;
REAL*8 TEMPSCSTP,TEMPSCSTP2,
  TEMPSCDSTP,TEMPSCDSTP2,TEMPPIISTP,
  TEMPSCDOSE($MAX_DOSE_ZONE,$MAXIT),
  TEMPSCDOSE2($MAX_DOSE_ZONE,$MAXIT),
  TEMPSCFLU(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,$MAX_SC_PARAMETERS),
  TEMPSCFLU2(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,$MAX_SC_PARAMETERS),
  TEMPSCFLU_COV(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,4);
$LOGICAL first_time;
data first_time/.true./;
save first_time;

ITMAX=3+LNEXC+LNINC;

IF(first_time)[
    first_time = .false.;
    $USER-RESET-DATA;
    DATCOUNT = 0;
    "now, zero arrays"
    DO IS=1,NSC_PLANES[
         NPPHSP(IS)=0;
         NPFLU(IS)=0;
         EKMAXPHSP(IS)=0.;
         EKMINPHSPE(IS)=0.;
         NPHOTPHSP(IS)=0;
    ]
    NINCPHSP=0;
    "for steps:
    SCSTP=0; SCSTP2=0; SCDSTP=0; SCDSTP2=0; PIISTP=0;
    SCSTP_LAST=0; SCDSTP_LAST=0; count_pII_steps=0;
    "for dose:
    DO IT=1,ITMAX[
        DO ID=1,NDOSE_ZONE[
              SCDOSE_LAST(ID,IT)=0;
              SCDOSE(ID,IT)=0.0;
              SCDOSE2(ID,IT)=0.0;
              SCDOSE_TMP(ID,IT)=0.0;
        ]
    ]
    "for fluence:
    [I1=1,3;
         [I2=1,$MAX_SC_PLANES;
             [I3=1,$MAX_SC_ZONES+1;
                   SCFLU_LAST(I1,I2,I3,1)=0;
                   SCFLU_LAST(I1,I2,I3,2)=0;
                   SCFLU_NUM(I1,I2,I3,1)=0;
                   SCFLU_NUM(I1,I2,I3,2)=0;
                   SCFLU_NOCOV(I1,I2,I3,1)=0;
                   SCFLU_NOCOV(I1,I2,I3,2)=0;
                   DO I4=1,4[
                     SCFLU_COV(I1,I2,I3,I4)=0.;
                   ]
                   [I4=1,$MAX_SC_PARAMETERS;
                      SCFLU(I1,I2,I3,I4)=0.;
                      SCFLU2(I1,I2,I3,I4)=0.;
                      SCFLU_TMP(I1,I2,I3,I4)=0.;
                   ]
    ]]] "End of loop over I1"
    NCASEO=0;TMCPUO=0;NHSTRYO=0;NPASS_ph_spO=0;NFAT_ph_spO=0;
    OUTPUT ;(/1X,'Summing the following .egsdat files');
    OUTPUT ; (1X,'------------------------------------'/);
    WRITE(IOUTLIST,'(/1X,''Summing the following .egsdat files'')');
    WRITE(IOUTLIST,'(1X,''------------------------------------''/)');
]

IORSTRT=egs_get_unit(IORSTRT);
WRITE(IOUTLIST,'(A)') $cstring(file_name);
WRITE(i_log,'(A)') $cstring(file_name);
open(IORSTRT,file=file_name,status='old',err=:EOF_RS1:);

DATCOUNT=DATCOUNT+1;

READ(IORSTRT,*,err=:EOF_RS3:,end=:EOF_RS3:) TEMPSCSTP,TEMPSCSTP2,
                                    TEMPSCDSTP,TEMPSCDSTP2,TEMPPIISTP;
READ(IORSTRT,*,err=:EOF_RS3:,end=:EOF_RS3:)
     ((TEMPSCDOSE(ID,IT),TEMPSCDOSE2(ID,IT),IT=1,ITMAX),ID=1,NDOSE_ZONE);
READ(IORSTRT,*,err=:EOF_RS3:,end=:EOF_RS3:)
      ((((TEMPSCFLU(I1,I2,I3,I4),TEMPSCFLU2(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,$MAX_SC_PARAMETERS);
READ(IORSTRT,*,err=:EOF_RS3:,end=:EOF_RS3:)
             ((((TEMPSCFLU_COV(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,4);
READ(IORSTRT,*,err=:EOF_RS3:,end=:EOF_RS3:)
             ((((TEMPSCFLU_NUM(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,2);
$RETRIEVE RNG STATE FROM UNIT IORSTRT;
READ(IORSTRT,*,err=:EOF_RS3:,end=:EOF_RS3:)TEMPNCASE,TEMPNHSTRY,TEMPTMCPU,
         (TEMPNPPHSP(IS),IS=1,NSC_PLANES),TEMPNPASS_ph_sp,TEMPNFAT_ph_sp;
$USER-ADD-DATA(IORSTRT);
write(i_log,*) '   ncase = ',TEMPNCASE,' cpu time = ',TEMPTMCPU;
write(IOUTLIST,*) '   ncase = ',TEMPNCASE,' cpu time = ',TEMPTMCPU;
      "now sum the scored data"
SCSTP=SCSTP+TEMPSCSTP; SCSTP2=SCSTP2+TEMPSCSTP2;
SCDSTP=SCDSTP+TEMPSCDSTP; SCDSTP2=SCDSTP2+TEMPSCDSTP2;
PIISTP=PIISTP+TEMPPIISTP;
DO ID=1,NDOSE_ZONE[
          DO IT=1,ITMAX[
            SCDOSE(ID,IT)=SCDOSE(ID,IT)+TEMPSCDOSE(ID,IT);
            SCDOSE2(ID,IT)=SCDOSE2(ID,IT)+TEMPSCDOSE2(ID,IT);
          ]
]
DO I1=1,3[
          DO I2=1,NSC_PLANES[
            DO I3=1,NSC_ZONES(I2)+1[
              SCFLU_NUM(I1,I2,I3,1)=SCFLU_NUM(I1,I2,I3,1)+
                                    TEMPSCFLU_NUM(I1,I2,I3,1);
              SCFLU_NUM(I1,I2,I3,2)=SCFLU_NUM(I1,I2,I3,2)+
                                    TEMPSCFLU_NUM(I1,I2,I3,2);
              NPFLU(I2)=NPFLU(I2)+TEMPSCFLU_NUM(I1,I2,I3,1)+
                        TEMPSCFLU_NUM(I1,I2,I3,2);
              DO I4=1,4[
                SCFLU_COV(I1,I2,I3,I4)=SCFLU_COV(I1,I2,I3,I4)+
                                TEMPSCFLU_COV(I1,I2,I3,I4);
              ]
              DO I4=1,$MAX_SC_PARAMETERS[
                SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)+
                                          TEMPSCFLU(I1,I2,I3,I4);
                SCFLU2(I1,I2,I3,I4)=SCFLU2(I1,I2,I3,I4)+
                                          TEMPSCFLU2(I1,I2,I3,I4);
              ]
            ]
          ]
]
NCASEO=NCASEO+TEMPNCASE;
NHSTRYO=NHSTRYO+TEMPNHSTRY;
TMCPUO=TMCPUO+TEMPTMCPU;
DO IS=1,NSC_PLANES[
         NPPHSP(IS)=NPPHSP(IS)+TEMPNPPHSP(IS);
]
NPASS_ph_spO=NPASS_ph_spO+TEMPNPASS_ph_sp;
NFAT_ph_spO=NFAT_ph_spO+TEMPNFAT_ph_sp;

$USER-COMBINE-RESULTS;

CLOSE(UNIT=IORSTRT);
return;
:EOF_RS1:;
WRITE(i_log,*) 'Error opening file ';
return;
:EOF_RS3:;
write(i_log,*) 'Error reading file ';
close(UNIT=IORSTRT); return; end;

"******************************************************************************
" Get cross section enhancement factors, if any
" Added by IK July 13 2005.
"******************************************************************************
subroutine get_cse_factors;
implicit none;
;COMIN/USER-CS-ENHANCEMENT,GetInput,MEDIA,ELECIN,EGS-IO/;
$INTEGER i,ival,n,imed;

DO i=1,$MAX_CMs [ cs_enhance(i) = 0; ]
use_cs_enhance = .false.;

ival = 1;

values_sought(ival) = 'SCALE XCC MEDIUM';
nvalue(ival) = 0; type(ival) = 0;
value_min(ival) = 0; value_max(ival) = nmed;
default(ival) = 0;

ival = ival + 1;
values_sought(ival) = 'SCALE XCC FACTOR';
nvalue(ival) = 0; type(ival) = 1;
value_min(ival) = 0; value_max(ival) = 1e10;
default(ival) = 1;

ival = ival + 1;
values_sought(ival) = 'CSE IN CMS';
nvalue(ival) = 0; type(ival) = 0;
value_min(ival) = 1; value_max(ival) = $MAX_CMs;
default(ival) = $MAX_CMs;

ival = ival + 1;
values_sought(ival) = 'CSE FACTORS';
nvalue(ival) = 0; type(ival) = 1;
value_min(ival) = 1; value_max(ival) = 1e10;
default(ival) = 1;

Nmin = ival-3; Nmax = ival;  delimeter = 'USER INPUTS';
call get_input;
error_flag = 0;

IF( error_flags(ival-3) = 0 & error_flags(ival-2) = 0 ) [
    n = min(nvalue(ival-3),nvalue(ival-2));
    DO i=1,n [
        imed = value(ival-3,i);
        IF( imed > 0 & imed <= nmed ) [
            write(i_log,*) '*** Scaling xcc of medium ',imed,' with ',
                value(ival-2,i);
            xcc(imed) = xcc(imed)*value(ival-2,i);
        ]
    ]
]

IF( error_flags(ival-1) = 0 & error_flags(ival) = 0 ) [
    n = min(nvalue(ival-1),nvalue(ival));
    IF( n > 0 ) [
        DO i=1,n [ cs_enhance(int(value(ival-1,i))) = value(ival,i); ]
        DO i=1,$MAX_CMs [
            IF( cs_enhance(i) > 1 ) [ use_cs_enhance = .true.; EXIT; ]
        ]
        IF( use_cs_enhance ) [
          OUTPUT; (//'********** Photon cross section enhancement will be used',
                    ' in the following CMs: ******');
            DO i=1,$MAX_CMs [
                IF( cs_enhance(i) > 1 ) [
                    OUTPUT i,cs_enhance(i); ('   ',i3,5x,f12.4);
                ]
            ]
            OUTPUT; (//'*************************************************',
                    '*****************************'//);
            return;
        ]
    ]
]
OUTPUT; (//'************* Photon cross section enhancement will not be used'//);

return; end;

"=====================================================================
subroutine beamlib_max_energy(E);

"  used to return max. k.e. of incident particles
"  useful for codes that are using a BEAM simulation as a source
"=====================================================================
implicit none;
$REAL E;
;COMIN/SOURCE/;
E = EKMAX;
return; end;

/***************************************************************************
 *
 *   Stuff related to directional source biasing (DSB)
 *
 ***************************************************************************/

subroutine dsb_init_sampling(dsb_delta,fs,dsb_aeff,nbin_max,dsb_nbin,dsb_rbin,
              dsb_prob,dsb_ibin);
implicit none;
COMIN/EGS-IO/;
$REAL    dsb_delta,fs,dsb_aeff,dsb_rbin(*),dsb_prob(*);
$INTEGER nbin_max,dsb_nbin,dsb_ibin(*);

$INTEGER j,jh,jl;
real*8   sum,aux,pi2,dphi;
parameter (pi2=6.283185307179586477025617918812372408865);

IF( dsb_delta >= fs ) [
    dsb_delta = 0; dsb_nbin = 1; return;
]
dsb_nbin = pi2/acos(1-(dsb_delta/fs)**2/2)-1;
IF( dsb_nbin < 1 ) [
    dsb_nbin = 1; dsb_delta = 0; return;
]
IF( dsb_nbin > nbin_max ) [
    OUTPUT dsb_delta,fs,dsb_nbin,nbin_max;
    (/'In subroutine dsb_init_sampling: '/
      '  for delta = ',f10.4,' and FS = ',f10.4,' one needs ',i4,/,
      '  sampling bins. This is more than the maximum ',i4,/,
      '  => adjusting number of sampling bins to maximum'/);
    dsb_nbin = nbin_max;
]
dsb_delta = sqrt(2*(1-cos(pi2/(dsb_nbin+1))));
dsb_rbin(1) = 0; sum = 0;
DO j=2,dsb_nbin [
    dphi = pi2/j;
    dsb_rbin(j) = (dsb_delta/sqrt(2*(1-cos(dphi))))**2;
    dsb_prob(j-1) = (dsb_rbin(j)-dsb_rbin(j-1))/(j-1);
    sum = sum + dsb_prob(j-1);
    dsb_ibin(j-1) = -1;
]
dsb_rbin(dsb_nbin+1) = 1;
dsb_prob(dsb_nbin) = (1 - dsb_rbin(dsb_nbin))/dsb_nbin;
sum = sum + dsb_prob(dsb_nbin);
dsb_aeff = sum; sum = sum/dsb_nbin;
DO j=1,dsb_nbin-1 [
    DO jh=1,dsb_nbin-1 [
        IF( dsb_ibin(jh) < 0 & dsb_prob(jh) > sum ) EXIT;
    ]
    DO jl=1,dsb_nbin-1 [
        IF( dsb_ibin(jl) < 0 & dsb_prob(jl) < sum ) EXIT;
    ]
    aux = sum - dsb_prob(jl);
    dsb_prob(jh) = dsb_prob(jh) - aux;
    dsb_prob(jl) = dsb_prob(jl)/sum;
    dsb_ibin(jl) = jh;
]
DO j=1,dsb_nbin [
    IF( dsb_ibin(j) < 0 ) [
        dsb_prob(j) = dsb_prob(j)/sum; dsb_ibin(j) = j;
    ]
]
return; end;

subroutine dsb_get_point(fs,nbin,rbin,prob,ibin,x,y,phat);
implicit none;
$REAL    fs,rbin(*),prob(*),x,y;
$INTEGER nbin,ibin(*),phat;
;COMIN/RANDOM/;
$REAL rnno1,rnno2,rnno3,rnno4,r,phi,pi2;
$INTEGER j;
parameter (pi2=6.283185307179586477025617918812372408865);

$RANDOMSET rnno1; $RANDOMSET rnno2; $RANDOMSET rnno3; $RANDOMSET rnno4;
j = 1 + rnno1*nbin;
IF( rnno2 > prob(j) ) j = ibin(j);
r = fs*sqrt(rbin(j)*rnno3 + rbin(j+1)*(1-rnno3));
phi = pi2*rnno4;
x = r*cos(phi); y = r*sin(phi); phat = j;
return; end;

"Ali:BCSE"

SUBROUTINE GET_BCSE_PARAMETERS;

IMPLICIT NONE;

;COMIN/MEDIA,ELECIN,GetInput,IO_INFO,
       USER-BCSE,USER-SPLITTING,EGS-VARIANCE-REDUCTION,EGS-IO/;

$REAL    EIL,
         SIGT_OLD,SIGT_NEW_I,SIGT_NEW_II,
         BR1_OLD,BR2_OLD,BR1_NEW_I,BR1_NEW_II,BR2_NEW_I,BR2_NEW_II,
         SIG_BREM_NEW,SIG_BHABHA,
         SIGE_I,SIGE_II,SIGP_I,SIGP_II,EDEDX,PDEDX;
$LOGICAL is_ok;

$INTEGER I,k,MEDIUM,egs_add_medium,nmed_i,lnblnk1,nlen;

DO I=1,$MXMED [ is_bcse_medium(i) = .false.; ]

NMIN = 1; NMAX = 5;
DELIMETER = 'BCSE';

I = 1;
VALUES_SOUGHT(I) = 'Use BCSE';
NVALUE(I) = 1;
TYPE(I) = 3;
ALLOWED_INPUTS(I,0) = 'Off';
ALLOWED_INPUTS(I,1) = 'On';

I = I+1;
VALUES_SOUGHT(I) = 'Media to enhance';
NVALUE(I) = 0;
TYPE(I) = 2;

I = I+1;
VALUES_SOUGHT(I) = 'Enhancement constant';
NVALUE(I) = 1;
TYPE(I) = 1;
VALUE_MIN(I) = 1e-30;
VALUE_MAX(I) = 1e+30;
DEFAULT(I) = 1;

I = I+1;
VALUES_SOUGHT(I) = 'Enhancement power';
NVALUE(I) = 1;
TYPE(I) = 1;
VALUE_MIN(I) = -10;
VALUE_MAX(I) = 10;
DEFAULT(I) = 0;

I = I+1;
VALUES_SOUGHT(I) = 'Russian Roulette';
NVALUE(I) = 1;
TYPE(I) = 3;
ALLOWED_INPUTS(I,0) = 'Off';
ALLOWED_INPUTS(I,1) = 'On';

CALL GET_INPUT;

IF(ERROR_FLAGS(1) ~= 0 | ERROR_FLAGS(2) ~= 0
 | ERROR_FLAGS(3) ~= 0 | ERROR_FLAGS(4) ~= 0 | VALUE(1,1) ~= 1)[
   OUTPUT; (//'*** Brem. cross section enhancement WILL NOT be used ***'//);
   USE_BCSE = .FALSE.; RETURN;
]

nmed_i = nmed; nmed_enhance = 0;
DO i=1,nvalue(2) [
    nlen = lnblnk1(char_value(2,i));
    IF( nlen < $STRING80 ) char_value(2,i)(nlen+1:nlen+1) = char(0);
    medium = egs_add_medium(char_value(2,i));
    IF( medium > 0 & medium <= nmed_i ) [
        IF( ~is_bcse_medium(medium) ) nmed_enhance = nmed_enhance + 1;
        is_bcse_medium(medium) = .true.;
    ]
    ELSE [
        $egs_warning(*,'BCSE inputs: no medium ',char_value(2,i),' defined');
        nmed = nmed_i;
    ]
]
IF( nmed_enhance < 1 ) [
    OUTPUT; (//'*** No valid BCSE media defined -->');
    OUTPUT; ('*** Brem. cross section enhancement WILL NOT be used ***'//);
    USE_BCSE = .FALSE.; RETURN;
]

USE_BCSE = .TRUE.;
BCSE_FACTOR_C = VALUE(3,1);
BCSE_POWER_N = VALUE(4,1);
/* Introduced IF below since NBRSPL is 0 for BCSE alone! EMH Nov 2012*/
IF (IBRSPL > 0)[NBRSPL_ORGNL = NBRSPL;]
ELSE           [NBRSPL_ORGNL = BCSE_FACTOR_C;]

/* Russian Roulette setting */
IF(VALUE(5,1) = 1)["meaning RR ON"
    IF(IBRSPL=0)[ I_PLAY_RR=1;PROB_RR=1./BCSE_FACTOR_C;]"BCSE alone"
    ELSEIF(IBRSPL=1)[ IRRLTT=2; I_PLAY_RR=1;PROB_RR=1/FLOAT(NBRSPL);]"BCSE+UBS"
    "PROB_RR=1/FLOAT(NBRSPL); Doesn't make sense for BCSE alone! EMH Nov 2012"
]
IF(IBRSPL=2) [I_PLAY_RR=0;] "RR must be off for DBS; it has its own"

OUTPUT; (//' *** Brem. cross section enhancement WILL be used ***');
OUTPUT nmed_enhance; (' *** The following ',I2,' media will be enhanced:');
DO i=1,$MXMED [
    IF( is_bcse_medium(i) ) write(i_log,'(9x,24a1)') (media(k,i),k=1,24);
]
IF( BCSE_POWER_N > 0 ) [
    OUTPUT BCSE_FACTOR_C,BCSE_POWER_N;
    ('     Enhancement factor will be 1 + C*E**N WITH C = ',E14.6,' N = ',
       F9.2);
]
ELSE [
    OUTPUT BCSE_FACTOR_C; ('     Constant enhancement factor  =',F12.2);
]
OUTPUT I_PLAY_RR, PROB_RR; ('     Play Russian Roulette  =',I2,
                            ' with probability ',E10.2);


/*****************************************************************************
 *
 *      Adjust cross sections and branching ratios
 *
 *****************************************************************************/

RETURN; END; "END OF SUBROUTINE GET_BCSE_PARAMETERS"


 "Ali:BCSE"
/*******************************************************************
 UNIFORM_PHOTONS_4PI IS A MODIFIED VERSION OF UNIFORM_PHOTONS.
 IT PRODUCES PHOTONS UNIFORMLY IN THE 4PI. IT IS USED ONLY IN BCSE
********************************************************************/
SUBROUTINE UNIFORM_PHOTONS_4PI(NSAMPLE,ENERGY);
IMPLICIT NONE;
$INTEGER NSAMPLE,I;
double precision energy;
$REAL    WEIGHT,RNNO,PHI,SINT;
;COMIN/STACK,RANDOM,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
       USER-STACK,USER-PHOTON-FORCING,EGS-IO/;

WEIGHT = WT(NPOLD)/NSAMPLE;
NP=NP-1;

DO I=1,NSAMPLE[
    NP = NP+1;
    $CHECK-STACK(NP,'UNIFORM_PHOTONS_4PI');
    $TRANSFER PROPERTIES TO (NP) FROM (NPOLD);
    E(NP) = ENERGY; IQ(NP) = 0; WT(NP) = WEIGHT;

    $RANDOMSET RNNO;
    PHI=3.1415927*(2.0*RNNO-1.0);
    $RANDOMSET RNNO;
    W(NP) = 2.0*RNNO-1.0;
    SINT = 1.0-W(NP)*W(NP);
    IF( SINT > 0 )[SINT = SQRT(SINT);] ELSE [SINT = 0;]
    U(NP)=SINT*COS(PHI);
    V(NP)=SINT*SIN(PHI);
]
RETURN; END;

"Ali:REJPLN"
SUBROUTINE GET_REJPLN;

IMPLICIT NONE;
;COMIN/USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,GetInput,EGS-IO/;

IF(IBRSPL=2)[
   NMIN = 1; NMAX = 1;
   DELIMETER = 'DBS REJECTION PLANE';

   VALUES_SOUGHT(1) = 'Use a rejection plane';
   NVALUE(1) = 1;
   TYPE(1) = 3;
   ALLOWED_INPUTS(1,0) = 'Off';
   ALLOWED_INPUTS(1,1) = 'On';

   CALL GET_INPUT;

   IF(ERROR_FLAGS(1) ~= 0 | VALUE(1,1) ~= 1)[
      OUTPUT; (//'*** No rejection plane will be used with DBS ***'/
                 '*** Correlated-particle warning ***'//);
      USE_REJPLN = .FALSE.;
   ]
   ELSE[
      VALUES_SOUGHT(1) = 'Z(cm) from zero reference plane';
      NVALUE(1) = 1;
      TYPE(1) = 1;
      VALUE_MIN(1) = 0;
      VALUE_MAX(1) = SSD;
      DEFAULT(1) = SSD;

      CALL GET_INPUT;

      USE_REJPLN = .TRUE.;
      Z_REJPLN = VALUE(1,1);
      FLAG_REJPLN=0;

      OUTPUT Z_REJPLN;
      (//'** A rejection plane will be used with DBS **'/
       'Z(cm) from zero reference plane =',F12.2//);
   ]
]
RETURN; END; "END OF SUBROUTINE GET_REJPLN"

$HAVE_LOAD_DSO(#);

#ifndef HAVE_LOAD_DSO;

subroutine init_beamsource(i_parallel,n_parallel,i_log,conf_name,
                         hen_house,egs_home,the_beam_code,
                         the_pegs_file,the_input_file);
$INTEGER i_parallel,n_parallel;
character*(*) conf_name;
character*(*) hen_house,egs_home,the_beam_code,the_pegs_file,the_input_file;
write(6,*) 'You need a working C compiler to use source 9!';
$CALL_EXIT(1);
end;

subroutine sample_beamsource(einsrc,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,weight,
                               iqin,latchi,nhist,iphatsrc);

return; end;

subroutine finish_beamsource;
return; end;

#endif;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc xvgr plotting subroutines                                           "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Andrew Booth, 1995                                        "
"                                                                             "
"  Contributors:    Charlie Ma                                                "
"                   Aaron Merovitz                                            "
"                   Dave Rogers                                               "
"                   Blake Walters                                             "
"                   Iwan Kawrakow                                             "
"                   Ernesto Mainegra-Hing                                     "
"                   Frederic Tessier                                          "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


!INDENT F2;
%I4
%Q1
"************************************************************************"

SUBROUTINE XVGRPLOT (X, Y, ERRY, NPTS, CURVENUM, SERIESTITLE,
                        XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                        UNITNUM, TYPE, HISTXMIN, AXISTYPE);

"************************************************************************"
"                                                                        "
"  This subroutine is used to create an xvgr plot file that will plot    "
"  Y as a function of X and include all of the pertinent information for "
"  the graph.  Each time the subroutine is called it writes one series   "
"  worth of data points to the unit specified.  For graphs that use      "
"  several series, multiple subroutine calls are required.               "
"                                                                        "
"  Written  by:  Andrew Booth, August 1995                               "
"  Modified by:  C-M Ma, Sept. 1995                                      "
"  Modified by:  Andrew Booth, July 1996                                 "
"                - introduced AXISTYPE argument to handle lin and log    "
"                  axis combinations.                                    "
"   Jan 98 A Merovitz/DR added xview xmin value so y axis label displayed"
"   Feb 98 A Merovitz/DR if non-negative, makes zeros fudge*smalest      "
"   Jun 99 BW/DWOR in Y>0 and ERRY crosses/touches 0, adjusted>0.0       "
"   Jul 99 DWOR made grace/xmgr compatible and added timestamp           "
"                                                                        "
"  The arguments of the subroutine are described in detail below:        "
"                                                                        "
"     1) X - array of x values to be plotted.  Top of bin if histogram.  "
"     2) Y - corresponding array of y values to be plotted.              "
"     3) ERRY - array containing uncertainties in Y for the plot.        "
"            If the first entry of this array is 0, it is                "
"            assumed that the graph is of type XY.  If it is             "
"            not 0, the graph is of type XY-DY.                          "
"     4) NPTS - the number (integer) of points to be plotted. This       "
"            should be the number of data points that exist in the       "
"            X, Y, and ERRY arrays.                                      "
"     5) CURVENUM - the number (integer) of the curve that is to be      "
"            plotted. The first curve number should be 0.  If this       "
"            number is not 0, then it is assumed that the plot file      "
"            already exists and the subroutine call is to add an         "
"            additional series to the existing graph.                    "
"     6) SERIESTITLE - string (max of 60 characters) giving the          "
"            series title (legend) for the data in the X and Y arrays.   "
"     7) XTITLE - string (max of 60 characters) giving the x axis        "
"            title.                                                      "
"     8) YTITLE - string (max of 60 characters) giving the y axis        "
"            title.                                                      "
"     9) GRAPHTITLE - string (max of 60 characters) giving the           "
"            graph title.                                                "
"    10) SUBTITLE - string (max of 60 characters) giving the subtitle    "
"            for the graph.                                              "
"    11) UNITNUM - number (integer) specifying where the data is to      "
"            be written.                                                 "
"            this unit must be opened by the calling routine             "
"    12) TYPE - 0 if data is to be written as normal point plot.         "
"               1 if data is to be written as a histogram plot.          "
"    13) HISTXMIN - used for histogram plots only.  This is a real       "
"                   number with the value of lower xbin for the plot.    "
"    14) AXISTYPE - 0 if linear-linear plot                              "
"                   1 if log-linear plot (y = log; x = lin)              "
"                   2 if linear-log plot (y = lin; x = log)              "
"                   3 if log-log plot                                    "
"                                                                        "
"                                                                        "
"************************************************************************"
  REPLACE{$SMALLFACTOR} WITH {1.E-5}
  REPLACE{$LARGEFACTOR} WITH {1.E5}

  IMPLICIT NONE;

  $INTEGER MAX, IDEBUG;
  PARAMETER (MAX = 400);  "---MAX used in defining the maximum number of---"
                          "---points that can be plotted in one series. ---"
  $INTEGER NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE;
  $REAL X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,HISTXMIN,ERRYOLD,SMALLESTX,
    SMALLESTY,FUDGE;
  $INTEGER TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENGTH;
  $INTEGER LOGX, LOGY, LOGDY,ZEROYCOUNT;

  "CHARACTER*80 SUBTITLE;"
  "CHARACTER*60 GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;"
  " IK changed the above to avoid complains from the compiler about"
  " inconsistent argument lists"
  CHARACTER*(*) SUBTITLE;
  CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;
  CHARACTER*10 INDEX;
  CHARACTER*3  INDEXNUM;

  $LOGICAL TESTFILE, ALLPOS;
  $REAL    one;
  parameter (one = 1);

  FUDGE = 1.e-10;              "If a number in the gaph is zero, it is replaced"
                             "by the (smallest number in the gaph)*(FUDGE)"
  IDEBUG = 0;  "set to 1 to get debug stmts active"
  IF (IDEBUG = 1) [
        write(6,'(//'' Entering xvgrplot ''/)');
        write(6,'('' Curve'',I3,'' to go to unit'',I3)')CURVENUM,UNITNUM;
        write(6,'(''SERIESTITLE: '',a60)') SERIESTITLE;
        write(6,'(''XTITLE:      '',a60)') XTITLE;
        write(6,'(''YTITLE       '',a60)') YTITLE;
        write(6,'(''GRAPHTILE:   '',a60)') graphtitle;
        write(6,'(''SUBTITLE:    '',a80)') subtitle;
  ]
  IF ( NPTS .gt. MAX) [ "Asked for too many points"
        OUTPUT NPTS, MAX;(//' **************************'/
        ' Number of points asked for =', I5,
        ' is greater than max allowed of', I4/
        ' Setting NPTS to MAX, you could adjust MAX in xvgrplot.mortran'/
        ' **************************'//);
        NPTS1 = MAX;
  ] ELSE [NPTS1 = NPTS;]

  "---Check to make sure that speicified unit is open for---"
  "---writing to.---"
  INQUIRE(UNIT = UNITNUM, OPENED = TESTFILE);

  IF (~TESTFILE) [ "---File has not been opened - print message.---"
    WRITE(6,:125:) UNITNUM;
    :125: FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------'
                 ,/'   Unit specified (',I2,') is not open.'
                 ,/'   Unit must be opened before using subroutine.'
                 ,/'   Data not written to file.'
                 ,/'  ----------------------------------------------'//);
    RETURN;
  ] "---End of error message for unopened file---"

  "---Set defaults if arguments are left blank.---"
  IF (GRAPHTITLE = ' ') [
    GRAPHTITLE = 'Untitled Graph - No title specified in subroutine';
  ]
  IF (XTITLE = ' ') [ XTITLE = 'X-axis not titled in subroutine';  ]

  IF (YTITLE = ' ') [ YTITLE = 'Y-axis not titled in subroutine'; ]

  IF (SERIESTITLE = ' ') [
    SERIESTITLE = 'series # ';
    INDEX = '0123456789';
    INDEXNUM = INDEX(CURVENUM+1:CURVENUM+1);
    SERIESTITLE(9:9) = INDEXNUM;
  ]

  "---Find lengths of stings for formatting purposes---"
  "---Initialize variable lengths---"

  TITLELENGTH = 61;    SUBLENGTH = 61;       XAXISLENGTH = 61;
  YAXISLENGTH = 61;    SERIESLENGTH = 61;

  "---Find title string length---"
  LOOP [
    TITLELENGTH = TITLELENGTH - 1;
  ] UNTIL (GRAPHTITLE(TITLELENGTH:TITLELENGTH) ~= ' ');

  "---Find subtitle string length---"
  LOOP [
    SUBLENGTH = SUBLENGTH - 1;
  ] UNTIL (SUBTITLE(SUBLENGTH:SUBLENGTH) ~= ' ');

  "---Find x-axis string length---"
  LOOP [
    XAXISLENGTH = XAXISLENGTH - 1;
  ] UNTIL (XTITLE(XAXISLENGTH:XAXISLENGTH) ~= ' ');

  "---Find y-axis string length---"
  LOOP [
    YAXISLENGTH = YAXISLENGTH - 1;
  ] UNTIL (YTITLE(YAXISLENGTH:YAXISLENGTH) ~= ' ');

  "---Find series title length---"
  LOOP [
    SERIESLENGTH = SERIESLENGTH - 1;
  ] UNTIL (SERIESTITLE(SERIESLENGTH:SERIESLENGTH) ~= ' ');
  IF( IDEBUG = 1) [
    OUTPUT SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELENGTH;
    (' SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELENGTH'/
     5I10)
  ]

  "---Small bit of error checking here done for the purpose of warning the---"
  "---user if there is a problem when using a 'log' type graph.           ---"
  "---Possible problems are:                                              ---"
  "---    1.)  value on log scale < or = 0.                               ---"
  "---    2.)  value of error bar for xydy plot extends into the region   ---"
  "---                    where y < or = 0.                               ---"
  "---                                                                    ---"
  "---To keep track of these problems the flags LOGX, LOGY, and LOGDY will---"
  "---be set if there is the respective error.                            ---"
  "---(ie.  if LOGX set (=1) then there exist an X value that is <= 0 AND ---"
  "--- the xaxis is set to be a log scale.)                               ---"
  "--------------------------------------------------------------------------"

  "---Initialize LOGX, LOGY, and LOGDY to be not set (0)---"
  LOGX = 0;          LOGY = 0;          LOGDY = 0;

  "---Initialize ZEROYCOUNT to 0---"
  ZEROYCOUNT=0;

  "In all cases where no negatives are concerned, fix points that are"
  "equal to 0.0"
  "Aaron Merovitz, Jan 1998"
  ALLPOS=.TRUE.;
  IF ( X(1)=0.0 ) [SMALLESTX = 0.1;] ELSE [SMALLESTX=X(1);]
  IF ( Y(1)=0.0 ) [SMALLESTY = 0.1;] ELSE [SMALLESTY=Y(1);]
  DO COUNT = 1, NPTS1 [
       IF ((X(COUNT) < SMALLESTX) & (X(COUNT)~=0.)) [SMALLESTX=X(COUNT);]
       IF ((Y(COUNT) < SMALLESTY) & (Y(COUNT)~=0.)) [SMALLESTY=Y(COUNT);]
       IF ((X(COUNT) < 0.)|(Y(COUNT) < 0.)) [ALLPOS=.FALSE.;]
  ]
  IF (ALLPOS) [
     DO COUNT = 1, NPTS1 [
          IF (X(COUNT)=0.) [X(COUNT)=SMALLESTX*FUDGE;]
          IF (Y(COUNT)=0.) [Y(COUNT)=SMALLESTY*FUDGE;]
     ]
  ]
  "---Loop through data points (if any log scales set) to see if there are---"
  "---any  <= 0 problems that might not have been fixed---"

  IF (AXISTYPE > 0) [  "---At least one axis is of log type---"
    DO COUNT = 1, NPTS1 [
      IF (X(COUNT) <= 0.) [ LOGX = 1; ]
      IF (Y(COUNT) <= 0.) [ LOGY = 1; ]
      IF ((Y(COUNT)-ERRY(COUNT)) <= 0.) [ LOGDY = 1; ]
    ]
  ]
  ELSE[ "--fix error bars that just hit Y axis in case user wants"
        "to switch to linlog plot while in xmgr--"
    DO COUNT = 1, NPTS1 [
       IF(Y(COUNT)-ERRY(COUNT) < Y(COUNT)-0.9999*Y(COUNT) & Y(COUNT)>0.)[
           ZEROYCOUNT=ZEROYCOUNT+1;
           IF(ZEROYCOUNT=1)[
             WRITE(6,:105:);
 :105: FORMAT (/' ------------WARNING from Subroutine XVGRPLOT-----------'
              ,/'  Some errors give 0 value and so are adjusted so       '
              ,/'  that you can switch to a log Y scale while in xmgr.   '
              ,/' -------------------------------------------------------'/);
           ]
           ERRYOLD=ERRY(COUNT);
           ERRY(COUNT) = 0.9999*Y(COUNT);
           "WRITE(6,:106:) COUNT,ERRYOLD,ERRY(COUNT);"
 ":106: FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, ' to'"
               "       /'        ',1PE11.4,'.');"
       ]
    ]
  ]

  "---Use this info later when writing to file---"

  "---Now begin writing information to unit---"
  IF (CURVENUM = 0) [ "---Case where plot file must start from scratch---"
    "---Insert xvgr graph header in file.---"

    "---Start with type of graph.  (lin-lin, log-lin, lin-log, or log-log)---"
    IF (AXISTYPE = 0) [ "---Graph is of type lin-lin---"
      WRITE(UNITNUM,:90:) 'xy';
    ] ELSEIF (AXISTYPE = 1) [ "---Graph is of type log-lin---"
      WRITE(UNITNUM,:90:) 'logy';
      WRITE(UNITNUM,:1080:);
    ] ELSEIF (AXISTYPE = 2) [ "---Graph is of type lin-log---"
      WRITE(UNITNUM,:90:) 'logx';
      WRITE(UNITNUM,:1080:);
    ] ELSEIF (AXISTYPE = 3) [ "---Graph is of type log-log---"
      WRITE(UNITNUM,:90:) 'logxy';
      WRITE(UNITNUM,:1080:);
      WRITE(UNITNUM,:1090:);
    ] ELSE [ "--anything else specified is in error--"
      WRITE(6,:91:) AXISTYPE;
      :91: FORMAT (//'  ------------Error in Subroutine XVGRPLOT-----------'
                 ,/'   AXISTYPE specified (',I2,') is not a valid option.'
                 ,/'  ----------------------------------------------'//);
      RETURN;
    ]

    :90: FORMAT ('@g0 type ',A,' ');
    :1080: FORMAT ('@    xaxis  ticklabel format exponential');
    :1090: FORMAT ('@    yaxis  ticklabel format exponential');

    "---Titles and things---"
    WRITE(UNITNUM,:100:) GRAPHTITLE(1:TITLELENGTH)
                        ,SUBTITLE(1:SUBLENGTH)
                        ,XTITLE(1:XAXISLENGTH)
                        ,YTITLE(1:YAXISLENGTH);
    :100: FORMAT ('@    title "',A,'"'/
                 ,'@    subtitle "',A,'"'/
                 ,'@    legend on'/
                 ,'@    legend box linestyle 0'/
                 ,'@    legend x1 0.6'/
                 ,'@    legend y1 0.75'/
                 ,'@    view xmin 0.250000'/
                 ,'@    xaxis  label "',A,'"'/
                 ,'@    timestamp on'/
                 ,'@    yaxis  label "',A,'"');
  ]  "---End CURVENUM = 0---"

"--XVGR has the characteristic that if the same input command is issued more---"
"--than once, the last one to be read is the one that is executed.  For this---"
"--situation, this is perfect.  Say the first series written to a file is of---"
"--a log scale, and the second is also of log scale, but has a data point   ---"
"--on the log scale that is < or = 0, then we can write the '@g0 type xy'   ---"
"--to the file AFTER the previous '@g0 type logxy' and the xy type will     ---"
"--prevail.  This will prevent errors when executing XVGR.  Of course the   ---"
"--alteration will also be written to the display.                          ---"


  IF (AXISTYPE = 1 & LOGY = 1) [  "--LOGY error--"
    WRITE(UNITNUM,:90:) 'xy';
    WRITE(6,:95:);
    :95: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
                ,/'  Log scale requested for Y axis when one or more   '
                ,/'  Y data points are 0 or negative.                  '
               ,//'  Y axis scale changed to linear.                   '
                ,/' ---------------------------------------------------'/);
  ]

  IF (AXISTYPE = 2 & LOGX = 1) [  "--LOGX error--"
    WRITE(UNITNUM,:90:) 'xy';
    WRITE(6,:96:);
    :96: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
                ,/'  Log scale requested for X axis when one or more   '
                ,/'  X data points are 0 or negative.                  '
               ,//'  X axis scale changed to linear.                   '
                ,/' ---------------------------------------------------'/);
  ]

  IF (AXISTYPE = 3 & (LOGX = 1 | LOGY = 1)) [  "--LOGX or LOGY error--"
    IF (LOGX = 1 & LOGY = 1) [
      WRITE(UNITNUM,:90:) 'xy';
      WRITE(6,:97:);
      :97: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
                  ,/'  Log scale requested for X axis and Y axis when    '
                  ,/'  one or more X and Y data points are 0 or negative.'
                 ,//'  X and Y axes scales changed to linear.            '
                  ,/' ---------------------------------------------------'/);
    ]
    ELSEIF (LOGX = 1) [ WRITE(UNITNUM,:90:) 'logy'; WRITE(6,:96:); ]
    ELSE              [ WRITE(UNITNUM,:90:) 'logx'; WRITE(6,:95:); ]
  ]

  "---now make a fix for those error bars that 'dip' beneath the x-axis on---"
  "---log plots.                                                          ---"

  IF (LOGDY = 1 & LOGY ~= 1 & (AXISTYPE = 3 | AXISTYPE = 1)) [
    "--if LOGDY problem and log scale not been already reset to linear--"
    "--do fudge to correct the problem--"

    WRITE(6,:101:);
    :101: FORMAT (/' ------------WARNING from Subroutine XVGRPLOT-----------'
              ,/'  Log scale requested for Y axis, and Y value less      '
              ,/'  error gives 0 or negative value.                      '
             ,//'  Error adjusted to aviod negavite values on log scale. '
              ,/' -------------------------------------------------------'/);

    DO COUNT = 1,NPTS1[
      IF(Y(COUNT)-ERRY(COUNT) < Y(COUNT)-0.9999*Y(COUNT)) [
        ERRYOLD = ERRY(COUNT);
        ERRY(COUNT) = 0.9999*Y(COUNT);
        WRITE(6,:103:) COUNT,ERRYOLD,ERRY(COUNT);
        :103: FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, ' to'
                      /'        ',1PE11.4,'.');
      ]
    ]

    WRITE(6,:104:);
    :104: FORMAT (/' -------------------------------------------------------'/);

  ]

  "---Include data about series for legend purposes.---"
  "first line needed to make it work with grace"
  IF (CURVENUM < 10 ) [
    WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM;
  ]
  ELSE [
    WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM;
  ]
  WRITE(UNITNUM,:150:)  CURVENUM,SERIESTITLE(1:SERIESLENGTH);
  :150: FORMAT ('@    legend string ',I2,' "',A,'"');


  "---Do normal plot.  ie. NOT histogram plot.---"
  IF (TYPE = 0) [ "---Normal point plot.---"

    "---Check all ERRYs.  If even one is nonzero, then series is type xydy---"
    DO COUNT = 1, NPTS1 [
      IF (ERRY(COUNT) ~= 0) [ "---Data set is not of type XY---"
        GOTO :X-Y-DY1:;
      ]
    ]

    "---Data set is of type XY---"
    WRITE(UNITNUM,:200:);
    :200: FORMAT ('@TYPE xy');
    IF (CURVENUM < 10) [
       WRITE(UNITNUM,:151:) CURVENUM;
       IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
       ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
    ]
    ELSE [
       WRITE(UNITNUM,:152:) CURVENUM;
       WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
    ]
    :151: FORMAT ('@    s',I1,' errorbar length 0.000000');
    :152: FORMAT ('@    s',I2,' errorbar length 0.000000');
    :197: FORMAT ('@    s',I1,' symbol color ',I2);
    :198: FORMAT ('@    s',I1,' symbol color ',I1);
    :199: FORMAT ('@    s',I2,' symbol color ',I2);

    "---Then write the data to the file.---"
    DO COUNT = 1, NPTS1 [ WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT); ]
    :250: FORMAT (1PE15.4,1PE15.4);
    GOTO  :END-X-Y-DY1:;

    "---Data set is of type XY-DY---"
    :X-Y-DY1:;
    WRITE(UNITNUM,:300:);
    :300: FORMAT ('@TYPE xydy');
    IF (CURVENUM < 10) [
    WRITE(UNITNUM,:151:) CURVENUM;
       IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
       ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
    ]
    ELSE [
       WRITE(UNITNUM,:152:) CURVENUM;
       WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
    ]

    "---Then write the data to the file.---"
    DO COUNT = 1, NPTS1 [WRITE(UNITNUM,:350:) X(COUNT),Y(COUNT),ERRY(COUNT);]
    :350: FORMAT (1PE15.4,1PE15.4,1PE15.4);
    :END-X-Y-DY1:;

  ]  "--end of point plot block--"
  ELSE [ "---Histogram plot---"

    "---Must find minimum y value in the y array to    ---"
    "---use as scale factor for establishing y-min on  ---"
    "---histogram plot.  We don't use 0 here as with 0 ---"
    "---plot can not be made into log plot in xvgr.    ---"

    YMIN = ABS($LARGEFACTOR * Y(1));

    DO COUNT = 1, NPTS1 [
       IF (ABS(Y(COUNT)) < YMIN) [ YMIN = ABS(Y(COUNT)); ]
    ]  "---End loop to find smalled Y---"

   "---Now smallest value of Y has been found.  Want to make sure that the---"
   "---first point used is even smaller than this and that it is of the same---"
   "---sign as the first Y data point in the plot.---"

    "---Now set YMIN to even smaller value for plot and set sign.---"
    YMIN = SIGN(one,Y(1)) * $SMALLFACTOR * YMIN ;

    "---Set this value in y-array as element after the---"
    "---element in index npts.---"
    Y(NPTS1+1) = YMIN;

    IF ((AXISTYPE = 2 | AXISTYPE = 3) & HISTXMIN = 0) [
      IF (X(1) = (X(2)-X(1))) [ HISTXMIN = X(1)-0.5*(X(2)-X(1)); ]
      ELSE                    [ HISTXMIN = X(1)-(X(2)-X(1)); ]

      WRITE(6,:306:) HISTXMIN;
      :306: FORMAT (/' ---------WARNING from Subroutine XVGRPLOT--------'
              ,/'  Minimum bin for X specified as 0 with log scale  '
              ,/'  on X axis.  Minimum X bin set to ',1PE10.3,'.'
              ,/' -------------------------------------------------'/);
    ]

    DO COUNT = 1, NPTS1 [
      IF (ERRY(COUNT) ~= 0.) [ "---Data set is not of type XY---"
        GOTO :X-Y-DY:;
      ]
    ]

"---Data set is of type XY---"
    IF (CURVENUM < 10) [
    WRITE(UNITNUM,:151:) CURVENUM;
       IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
       ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
    ]
    ELSE [
       WRITE(UNITNUM,:152:) CURVENUM;
       WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
    ]
    WRITE(UNITNUM,:200:);

    "---Plot the first histogram points.---"
    WRITE(UNITNUM,:250:) HISTXMIN,YMIN;
    WRITE(UNITNUM,:250:) HISTXMIN,Y(1);

    "--Then write the data to the file.---"
    DO COUNT = 1, NPTS1 [
      WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT);
      WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT+1);
    ]
    GOTO :END-X-Y-DY:;

"---Data set is of type XY-DY---"
    :X-Y-DY:;
    "---Put error of 0 on last *made-up* point in error array.---"
    ERRY(NPTS1+1) = 0.0;

    IF (CURVENUM < 10) [
    WRITE(UNITNUM,:151:) CURVENUM;
       IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
       ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
    ]
    ELSE [
       WRITE(UNITNUM,:152:) CURVENUM;
       WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
    ]
    WRITE(UNITNUM,:300:);

    "---Plot the first histogram points.---"
    IF (HISTXMIN = 0.0) [ "Aaron Meroivtz, Feb. 1998"
       HISTXMIN = SMALLESTX*FUDGE;
    ]
    WRITE(UNITNUM,:350:) HISTXMIN, YMIN, 0.;
    WRITE(UNITNUM,:350:) HISTXMIN, Y(1), 0.;
    WRITE(UNITNUM,:350:) (X(1)+HISTXMIN)/2., Y(1), ERRY(1);

    "---Then write the data to the file.---"
    DO COUNT = 1, NPTS1 [
      WRITE (UNITNUM,:350:) X(COUNT),Y(COUNT),0.;
      WRITE (UNITNUM,:350:) X(COUNT),Y(COUNT+1),0.;
      IF(COUNT < NPTS1)[
       WRITE (UNITNUM,:350:) (X(COUNT)+X(COUNT+1))/2.,Y(COUNT+1),ERRY(COUNT+1);
      ]
    ]
    :END-X-Y-DY:;
  ] "---End HIST=0 loop---"

  "---Insert end of series indicator to file.---"
  WRITE(UNITNUM,'(''&'')');

  RETURN;
  END; "---End of subroutine.---"
;

%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: parallel plate monitor chamber            "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 1995                                       "
"                                                                             "
"  Contributors:    Charlie Ma                                                "
"                   Dave Rogers                                               "
"                   Iwan Kawrakow                                             "
"                   Ernesto Mainegra-Hing                                     "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code originally evolved from the IONCHAM component module written by  "
"  Jiansu Wei, starting in 1992.                                              "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


%Q1
%C80
!INDENT F4;
!INDENT M4;
;
"
"*******************************************************************************
"*******************************************************************************
"
"                             *************       ""toc:
"                             *           *       ""toc:
"                             *  CHAMBER  *       ""toc:
"                             *           *       ""toc:
"                             *************       ""toc:
"
"
"   History of modifications given by sccs.
"
"*******************************************************************************
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"
"   Component module for BEAM.  Parallel plate monitor chamber in the      "
"   container with top and bottom layers of arbitrary thickness and        "
"   material.                                                              "
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator:  a cylindrical
"   planar geometry for monitoring chamber.
"
"I>
"I> Geometry of PHANTOM (CHAMBER):             ""toc:
"I> *****************************
"I>                        top part,    # of layers: n_top_$chamber
"I>                --------|-----------------------------|--------
"I>                -------------|-----------------|---------------
"I>                -----------------------------------------------
"I>                 |     |    |--------------------|    |     |
"I>                 |     |    |--------------------|    |     |
"I>                 |     |    |--------------------|    |     |
"I>                 |     |wall|--------------------|    |     |
"I>                 |     |    |         .          |    |  # of layers:
"I>     container   |     |    |         .          |    |   n_chm_$chamber
"I>       wall      |     |    |         .          |    |     |
"I>                 | gap |    |         .          |    |     |
"I>                 |     |    |chamber central part|    |     |
"I>                 |     |    |--------------------|    |     |
"I>                 |     |    |--------------------|    |     |
"I>                 |     |    |--------------------|    |     |
"I>                 |     |    |____________________|    |     |
"I>                --------|----------------------------|-----------
"I>                ----------|------------------------|-------------
"I>                ------|--------------------------------|---------
"I>                        bottom part, # of layers: n_bot_$chamber
"I>
"I>
"I>   IR is the region number within the CM.  There are three parts
"I>   shown above. There are N_PHANTOM (>1) local regions.
"I>
"I>
"I>            ----------------------------------------------------
"I>            | top part:  n_top_$chamber layers.                |
"I>            |            # region: n_top_$chamber x 2          |
"I>            ----------------------------------------------------
"I>            | cham part: n_chm_$chamber layers.                |
"I>            |            # region: n_chm_$chamber + 3          |
"I>            ----------------------------------------------------
"I>            | bottom part: n_bot_$chamber layers               |
"I>            |            # region: n_bot_$chamber x 2          |
"I>            |--------------------------------------------------|
"I>            | total # regions: N_$chamberber = n_chm_$chamber+3|
"I>            |                  +2n_top_$chamber                |
"I>            |                  +2n_bot_$chamber                |
"I>            ----------------------------------------------------
;
"I>            -------------------------------------------------
"I>            | abs region # setting:                         |
"I>            |     first: main cham part begins              |
"I>            |            with irstart_$chamber,             |
"I>            |            ends with irstart_$chamber+        |
"I>            |            n_chm_$chamber-1                   |
"I>            |            +3(side wall+gap+ container wall)  |
"I>            |     second: top layers begins                 |
"I>            |            with the end of cham part+1        |
"I>            |            ends with the end of cham part     |
"I>            |            + 2n_top_$chamber-1                |
"I>            |     third: bottom layers with                 |
"I>            |            the end of top part +1             |
"I>            |            ends with the end of top part      |
"I>            |            + 2n_bot_$chamber-1                |
"I>            |     air gap: irend_$chamber=irstart_$chamber+ |
"I>            |            n_cham_$chamber +3                 |
"I>            |            +2n_top_$chamber                   |
"I>            |            +2n_bot_$chamber                   |
"I>            -------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_PHANTOM
"                      ISUMRY_PHANTOM
"                      HOWFAR_PHANTOM
"                      WHERE_AM_I_PHANTOM
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS ON USE/BUGS       ""toc:
"                             ************************
"
"*******************************************************************************
"**************************  DESCRIPTION OF VARIABLES  *************************
"*******************************************************************************
"
"                             COMMON BLOCK VARIABLES
"                             **********************
"
"  Refer to the replacement macros in BEAM.MORTRAN and BEAM_COMMON.MORTRAN
"  which define the common block variables.
"
"*******************************************************************************
"
"                                OTHER VARIABLES
"                                ***************
"
"  Refer to the section on type declarations for each subroutine. The following
"  section describes the variables input from unit 5.  These variables define
"  the parameters of each simulation.
"
;
"*******************************************************************************
"
"                               INPUT FROM UNIT 5             ""toc:
"                               *****************             ""toc:
"
"I>
"I>  CARDS CM_PHANTOM
"I>  ****************
"I>
"I>  -1  Dummy line to indicate start of CM.
"I>
"I>   0  RMAX_CM(ICM_PHANTOM):( F10.0):   Maximum radius of component module
"I>
"I>   1  TITLE_PHANTOM (60A1):  Title of CM.
"I>
"I>   2  ZMIN_PHANTOM (F15.0): Distance from front surface of 1st cylinder to
"I>                             reference plane (Z=0). Excludes any air gap.
"I>
"I>   3  N_TOP_PHANTOM, N_CHM_PHANTOM, N_BOT_PHANTOM (3I5)
"I>
"I>        N_TOP_PHANTOM:   Number of layers in top part (>= 0).
"I>        N_CHM_PHANTOM:   Number of layers in chamber itself (> 0 to input
"I>                          chamber layers individually or if ALL layers have
"I>                          the same thickness and medium; < 0 to
"I>                          input -N_CHM_PHANTOM groups of layers where
"I>                          layers in each group have the same thickness and
"I>                          ALL layers have the same MED).
"I>        N_BOT_PHANTOM:   Number of layers in bottom part (>= 0).
;
"I>   ==========================================================================
"I>   4  Inputs for the top part (If N_TOP_PHANTOM >0):
"I>   ==========================================================================
"I>
"I>    If all layers in this part are identical, then in line (a) include
"I>    NFLAG=N_TOP_PHANTOM, otherwise repeat (a) to (e) for each of the
"I>    layers.
"I>
"I>     a) ZTHICK, RCYS_PHANTOM , NFLAG (2F15.0,I5)
"I>           ZTHICK (F15.0):        Thickness of each layer in top part
"I>           RCYS_PHANTOM (F15.0): Radius of inner cylinders in each layer
"I>           N_TOP_PHANTOM (I5):   Number of layers in top part
"I>
"I>     b) ECUT,PCUT,DOSE_ZONE,IREGION_TO_BIT for inner cylinders
"I>                                           (2F15.0,2I5,1-line):
"I>         ECUT, PCUT: Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:  Dose scoring region for this region, 0=>no dose scored.
"I>         IREGION_TO_BIT :  Bit # in LATCH designated to this region
"I>
"I>     c) MED_IN (24A1):  Medium of inner cylinder (used for MED_INDEX)
"I>
"I>     d) ECUT,PCUT,DOSE_ZONE,IREGION_TO_BIT for outer annuli
"I>                                           (2F15.0,2I5,1-line):
"I>
"I>     e) MED_IN (24A1):  Medium for outer annuli (used for MED_INDEX)
"I>
;
"I>   =========================================================================
"I>   5  Inputs for the chamber/phantom part:
"I>   =========================================================================
"I>
"I>    The chamber/phantom part has a central part of potentially many layers
"I>    which may have different media and dimensions.  Outside this there
"I>    are 3 cylindrical shells, called the chamber wall, gap, and container
"I>    wall.  Each is a single material running the entire Z-span of the
"I>    central part.
"I>
"I>   5.1) RCYS_PHANTOM(1,1), RCYS_PHANTOM(1,2), RCYS_PHANTOM(1,3) (3F15.0)
"I>          RCYS_PHANTOM (1,1): Inner r of chamber wall=outer r central region
"I>          RCYS_PHANTOM (1,2): Outer r of chamber wall=inner r of gap
"I>          RCYS_PHANTOM (1,3): Inner r of container wall=outer r of gap
"I>
"I>
"I>   5.2) If N_CHM_PHANTOM>0: If all layers in this part are identical, then
"I>           in line (a) include NFLAG=N_CHM_PHANTOM and input (b) once for
"I>           all layers, otherwise repeat (a) to (c) for each of the layers.
"I>        If N_CHM_PHANTOM<0: Repeat (a) once for each of the
"I>           -N_CHM_PHANTOM groups of layers of equal thickness. In this case,
"I>           NFLAG is the number of layers in the group.   Then input (b) once
"I>           for all layers.
"I>
"I>     a) ZTHICK, NFLAG  (F15.0,I5)
"I>           ZTHICK:    Thickness of each layer in chamber part
"I>                      (N_CHM_PHANTOM>0) or of each layer in this particular
"I>                      group of layers (N_CHM_PHANTOM<0)
"I>           NFLAG:     Number of layers in chamber IF all same
"I>                      (N_CHM_PHANTOM>0) or number of layers in the group
"I>                      (N_CHM_PHANTOM<0)
"I>
"I>     b) ECUT,PCUT,DOSE_ZONE,IREGION_TO_BIT for chamber layers
"I>                                                (2F15.0,2I5,one line):
"I>           ECUT, PCUT: Cutoff energies for electrons and photons.
"I>           DOSE_ZONE:  if all layers are of equal thickness or there are
"I>                       groups of layers of equal thickness (ie
"I>                       NFLAG=N_CHM_PHANTOM or N_CHM_PHANTOM<0) then, if
"I>                       DOSE_ZONE>0 the dose is scored in regions
"I>                       DOSE_ZONE, DOSE_ZONE+1,.., DOSE_ZONE+N_CHM_PHANTOM-1
"I>                       ie, a sequence of dose scoring zones are set up
"I>                       automatically for all layers.
"I>                       For single region at a time
"I>                       Dose scoring region for this region,0=>no dose scored.
"I>           IREGION_TO_BIT :  Bit # in LATCH designated to this region
"I>
"I>     c) MED_IN (24A1):  Medium of chamber layers (used to set MED_INDEX)
"I>
"I>
"I>     5.3) Inputs for the chamber wall:
"I>     ---------------------------------
"I>
"I>     a) ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT, (2F15.0,2I5):
"I>           ECUT, PCUT: Cutoff energies for electrons and photons.
"I>           DOSE_ZONE:  Dose scoring region for this region,0=>no dose scored.
"I>           IREGION_TO_BIT:  Bit # in LATCH designated to this region
"I>
"I>     b) MED_IN (24A1):  Medium of chamber wall (used to set MED_INDEX)
"I>
"I>     5.4) Inputs for the gap between chamber wall and container wall:
"I>     ----------------------------------------------------------------
"I>
"I>     a) ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT, (2F15.0,2I5):
"I>
"I>     b) MED_IN (24A1):  Medium of gap (used to set MED_INDEX)
"I>
"I>
"I>     5.5) Inputs for the container wall:
"I>     -------------------------------------------
"I>
"I>     a) ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT, (2F15.0,2I5):
"I>
"I>     b) MED_IN (24A1):  Medium of container wall (used to set MED_INDEX)
;
"I>   =====================================================================
"I>   6  Inputs for the bottom part (If N_BOT_PHANTOM >0):
"I>   =====================================================================
"I>
"I>    5.6) If all layers in this part are identical, then in line (a) include
"I>         NFLAG=N_BOT_PHANTOM, otherwise repeat (a) to (e) for each of the
"I>         layers.
"I>
"I>     a) ZTHICK, RCYS_PHANTOM , NFLAG (2F15.0,I5)
"I>          ZTHICK:           Thickness of each layer in bottom part
"I>          RCYS_PHANTOM:    Radius of inner cylinders in bottom part
"I           NFLAG:            Number of layers in bottom part IF all same
"I>
"I>     b) ECUT,PCUT,DOSE_ZONE,IREGION_TO_BIT for inner cylinders
"I>                                             (2F15.0,2I5,1-line):
"I>          ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>          DOSE_ZONE:   Dose scoring flag, 0=>do not score dose.
"I>          IREGION_TO_BIT :  Bit # in LATCH designated to this region
"I>
"I>     c) MED_IN (24A1):  Medium of inner cylinders (used for MED_INDEX)
"I>
"I>     d) ECUT,PCUT,DOSE_ZONE,IREGION_TO_BIT for outer annuli
"I>                                            (2F15.0,2I5,1-line):
"I>     e) MED_IN (24A1):  Medium of outer annuli (used for MED_INDEX)
"I>
"I>   ====================================================================
"I>   7  Inputs for range rejection options:
"I>   ====================================================================
"I>
"I>       MRNGE (I5)         0 or 1
"I>
"I>          MRNGE     : = 1 to estimate thickness of the CHAMBER for
"I>                        ECUTRR calculations in automated range rejection
"I>                        (IREJCT_GLOBAL=1) (crude approx for 5 layers)
"I>                      = 0 no ECUTRR calculation--range rejection will
"I>                        still be done on a region-by-region basis
"I>
"I>            Note that MRNGE only has an effect if automated range
"I>            rejection is on (IREJCT_GLOBAL=1).
"I>
"I>   Example
"I>   *******
"I>
"I>  The following set of cards defines a chamber with 2 top layers, 3 chamber
"I>  layers, and 2 bottom layers.
"I>  The chamber wall is AL & the chamber container is CU. The detecting
"I>  material is air.
"I>  The air cavities are assigned as dose region 1 and the rest as region 2.
"I>
"I>  10.5; radius of CM
"I>  Chamber with 2 top layers, 3 chamber layers, 2 bottom layers
"I>  10.0; distance from front surface of the CM to the reference plane (z=0)
"I>  2,3,2;                   2 top layers, 3 chamber layers, 2 bottom layers
"I>  0.1,5.0,0;          first layer in the top part, 0.1cm thick, IR=5cm
"I>  0.521,0.010,2,2;  dose region # = 2
"I>  CU             ;  medium
"I>  0.521,0.010,2,2;
"I>  CU
"I>  0.2,5.0,0;          second layer is 0.2 cm thick, radius = 5.0 cm
"I>  0.521,0.010,2,2;  for inner cylinder (dose region # = 2)
"I>  AL
"I>  0.521,0.010,2,2;  for outer annulus
"I>  AL
"I>  5.0,5.2,10.0;     IR & OR of chamber wall, IR of container
"I>  0.2;              thickness of the first layer (air) in chamber part
"I>  0.521,0.010,1,2;  dose region # = 1
"I>  AIR
"I>  0.1;              thickness of the second layer (AL) in chamber part
"I>  0.521,0.010,2,2;  dose region # = 2
"I>  AL
"I>  0.2;              thickness of the third layer (air) in chamber part
"I>  0.521,0.010,1,2;  dose region # = 1
"I>  AIR
"I>  0.521,0.010,2,2;  chamber wall (dose region # = 2)
"I>  AL
"I>  0.521,0.010,2,2;  air gap betweem chamber wall and container wall
"I>  AIR
"I>  0.521,0.010,2,2;  chamber container
"I>  CU
"I>  0.1,5.0,2;        2 layers in bot. part have = thickness, IR
"I>  0.521,0.010,2,2;  for inner cylinders
"I>  AL
"I>  0.521,0.010,2,2;  for outer annuli
"I>  AL
"I>  0;                do not calculate ECUTRR
"I>
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules
"
"*******************************************************************************

%E     "start of subroutine HOWFAR_PHANTOM"
"******************************************************************************
"************************** Component Module CHAMBER***************************
"******************************************************************************
"
"                          Subroutine HOWFAR_PHANTOM
"                          ***********************
"
" HOWFAR routine for stacked planar media.
"
" Determine if current region number is within CHAMBER, and if so evaluate
" DIST, the distance to the region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are N_PHANTOM local regions + an air gap (if present):
"
"     local               absolute                       description
"----------  -------------------------------------   -----------------------
"IR_PHANTOM  IR_start_CM(ICM_PHANTOM)+IR_PHANTOM-1 excluding front air gap
"----------  -------------------------------------   -----------------------
"   Geometrical co-ordinates, as set in INPUT_PHANTOM are:
"
"   ZFRONT_PHANTOM     front of CM (upstream surface, air region)
"   ZMIN_PHANTOM       front of first cylinder
"   ZMAX_PHANTOM       back of last cylinder
"   RMAX_PHANTOM       radius of last cylinder (largest)
"
"******************************************************************************

;SUBROUTINE HOWFAR_PHANTOM;


"V>$GEO_SHIFT_1_(#)
"V>=============
"V>{p1} the value to compare with ustep
"V> if {p1}+1.0e-5 < ustep shift it, otherwise no shift
;
REPLACE {$GEO_SHIFT_1_(#)} WITH
{; IF({P1}+1.0E-5< USTEP) [{P1}={P1}+1.0E-5;]  }


"V>$GEO_SHIFT_2_(#,#)
"V>=============
"V>{p1} the value to compare with {P2}
"V> if {p1}+1.0e-5 < {P2} shift it, otherwise no shift
;
REPLACE {$GEO_SHIFT_2_(#,#)} WITH
{; IF({P1}+1.0E-5< {P2}) [{P1}={P1}+1.0E-5;]  }

;IMPLICIT NONE;

;COMIN/
   CMs,CM_PHANTOM,EPCONT,STACK,EGS-IO/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_PHANTOM
"T>**********************************
"T>

INTEGER
   IRL,            "T>local region number (absolute), required by HOWNEAR macro
   I, IIR, JDEBUG,
   LAYER,
   IU_D;           "T>to indicate the relations between ustep and dist

$REAL
   DIST,          "T>furthest dist to z boundary along current trajectory
   RF2_PHANTOM,  "T>temporary variable
   DMIN_PHANTOM, "T>minimum distance to boundaries checked thus far
   R0SQ,          "T>temporary init position of the particle in x-y plane
   CRITERIOR_IR,ZNP,
   STEP_UNIT, CUT_COE, CUTCOE_PHANTOM, SHIFT_COUNT_PHANTOM;
;

" Determine local region number
" *****************************
ZNP=Z(NP);
IRL = IR(NP); "local region number (absolute)
JDEBUG=JDEBUG+1;
IR_PHANTOM = IRL - IRSTART_PHANTOM + 1;   "local region number( relative )

" Set DNEAR
" *********
" This replacement macros sets DMIN_PHANTOM as well as defining IR_PHANTOM
;
PHANTOM_CM_HOWNEAR(DMIN_PHANTOM);
DNEAR(NP) = DMIN_PHANTOM;
;

" CALC. THE LAYER # "
IF( IR_PHANTOM<=N_CHM_PHANTOM ) [ LAYER=IR_PHANTOM; ]
ELSEIF(IR_PHANTOM<=N_CHM_PHANTOM+3 ) [ LAYER=1; ]
ELSE[
   LAYER=N_CHM_PHANTOM+
         (IR_PHANTOM-N_CHM_PHANTOM-3+1)/2;
]
" this will be used only for the top and bottom parts "


" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module,if so
" evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
;
R0SQ=X(NP)**2+Y(NP)**2;
CUT_COE=0.0;

" the following block double check:
"=================================
"      1. the particle is out of the CM oe regions in z direction
"      2.                        the regions in r directions
"     if so reset the ir #, and print out the warning message.
"comment: this block is not time consumming, can be kept in the final version
"=======
"
"  now do the air gap if existed.
"=====================================

IF(N_GAP_PHANTOM=1 & IRL=IREND_PHANTOM )["check the air gap first"
   IF(W(NP)>0.0)["particle going forward"
      DIST = (ZMIN_PHANTOM - Z(NP))/W(NP); "distance to front of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0)[ " particle was out of the air gap"
          USTEP=0.0;
          IF(N_TOP_PHANTOM=0)[" no top layer above the chamber"
              IF(R0SQ<RCYS2_PHANTOM(1,1))[IRNEW =IRSTART_PHANTOM;]
              ELSEIF(R0SQ<RCYS2_PHANTOM(1,2))
                 [IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM;]
              ELSEIF( R0SQ<RCYS2_PHANTOM(1,3) )
                 [IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM+1;]
              ELSE[ IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM+2;]
           ]
           ELSE[        " has top layer above the chamber"
               IF( R0SQ<RCYS2_PHANTOM(N_CHM_PHANTOM+1,1) )
                  [ IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM+3;]
               ELSE[IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM+4;]
           ]
           RETURN;
       ] "end of the double check if a particle is out of the AIR GAP"

      "  do the howfar job for the air gap  "
      "====================================="
       ELSE[
           IF( IU_D=0 )[RETURN; ] " no cut, ustep admmited"
           ELSE[ " iu_d=1, cut the ustep to dist "
               ;$GEO_SHIFT_1_(STEP_UNIT);
               USTEP=STEP_UNIT;
               RF2_PHANTOM= (X(NP)+USTEP*U(NP))**2
                        +(Y(NP)+USTEP*V(NP))**2;
               IF(N_TOP_PHANTOM=0)[  " no top layer above the chamber"
                  IF( RF2_PHANTOM<RCYS2_PHANTOM(1,1) )
                    [IRNEW =IRSTART_PHANTOM;]
                  ELSEIF( RF2_PHANTOM<RCYS2_PHANTOM(1,2) )
                    [IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM;]
                  ELSEIF( RF2_PHANTOM<RCYS2_PHANTOM(1,3) )
                    [IRNEW =IRSTART_PHANTOM+1+N_CHM_PHANTOM;]
                  ELSE[ IRNEW =IRSTART_PHANTOM+2+N_CHM_PHANTOM;]
               ]
               ELSE[ " has top layer above the chamber"
                  IF( RF2_PHANTOM<RCYS2_PHANTOM(N_CHM_PHANTOM+1,1) )
                    [ IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM+3;]
                  ELSE[IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM+4;]
               ]
               RETURN;
           ]  " end of the cut case"
       ]"  end of the howfar for this case"
   ]   " end of the w>0 case

   ELSEIF(W(NP)<0.0)[ " particle going backward"
      DIST = (ZFRONT_PHANTOM - Z(NP))/W(NP); "distance to front of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0)[
          USTEP=1.E-16; "make sure ausgab is called when leaving CM"
          CALL WHERE_AM_I(ICM_PHANTOM,-1);
          RETURN;
      ] " end of the double check if a particle is out of the CM"
      ELSE[ " do the howfar job"
          IF( IU_D=0 ) [ RETURN; ]   " no cut, ustep admmited"
          ELSE[  " iu_d=1, cut the ustep to dist "
              ;$GEO_SHIFT_1_(STEP_UNIT);
              USTEP=STEP_UNIT;
              CALL WHERE_AM_I(ICM_PHANTOM,-1);
              RETURN;
          ]  " end of the howfar job for this case "

      ]    " end of the howfar job for this case"
   ]  " end of the w<0 case "
   ELSE[ RETURN;]  " for the w=0.0 case "
]    " end of the air gap case "

" now do the central part of the ion chamber "
"==========================================="

ELSEIF(IR_PHANTOM<=N_CHM_PHANTOM)  [" inside the inner chamber layers"
   IF(W(NP) > 0.0) [  "particle going forward"
      DIST = (Z_PHANTOM(IR_PHANTOM+1) - Z(NP))/W(NP);
      "distance to back of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <=0.0)[
          USTEP=0.0;
          IF(IR_PHANTOM=N_CHM_PHANTOM & N_BOT_PHANTOM=0 )[
             " last layer of the cham"
             USTEP=1.E-16;
             CALL WHERE_AM_I(ICM_PHANTOM,1);
          ]" and last layer of CM  "
          ELSEIF( IR_PHANTOM=N_CHM_PHANTOM )[
             " last layer of chamb, not for CM   "
             " particle will go into the first layer of the bottom part  "
             IF(R0SQ< RCYS2_PHANTOM(N_CHM_PHANTOM+N_TOP_PHANTOM+1,1))[
                 " the first layer of the bottom part"
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3+2*N_TOP_PHANTOM;
             ]
             ELSE[
                IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3+2*N_TOP_PHANTOM+1;
             ]
          ]
          ELSE[  IRNEW = IR(NP)+1;]
          RETURN;
      ]
      " end of the double check if a particle is out of the CM in z direct "

      " now check the r direction "
      "==========================="

      CRITERIOR_IR=R0SQ-RCYS2_PHANTOM(1,1);
      " all the inner layers have the same radius"
      IF(CRITERIOR_IR>0.0)[" out of the r1 "
          USTEP=MIN( USTEP, SHIFT_COUNT_PHANTOM(IR_PHANTOM) );
          IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM;" go into the side wall "
          RETURN;
      ]   " end of the   r direction error block "

      "  now do the howfar job  "
      "========================="
      RF2_PHANTOM=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF(RF2_PHANTOM > RCYS2_PHANTOM(1,1))
        [CUT_COE=CUTCOE_PHANTOM( R0SQ, RCYS2_PHANTOM(1,1) ); ]
      IF((CUT_COE>0.0&CUT_COE<STEP_UNIT)|(CUT_COE=STEP_UNIT&IU_D=0))[
          " hits the side wall of the chamber "
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM;
          RETURN;
      ]
      ELSEIF(IU_D=1)[ " hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          IF(IR_PHANTOM=N_CHM_PHANTOM & N_BOT_PHANTOM=0 )[
              " last layer of the cham"
              CALL WHERE_AM_I(ICM_PHANTOM,1); ]" and last layer of CM  "
          ELSEIF( IR_PHANTOM=N_CHM_PHANTOM )[
              "last layer of chamb, not for CM"
              " particle will go into the first layer of the bottom part  "
              RF2_PHANTOM= (X(NP)+USTEP*U(NP))**2
                        +(Y(NP)+USTEP*V(NP))**2;
              IF(RF2_PHANTOM<RCYS2_PHANTOM(N_CHM_PHANTOM+
                         N_TOP_PHANTOM+1,1))
              [IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3+2*N_TOP_PHANTOM;]
              ELSE[IRNEW=IRSTART_PHANTOM+
                   N_CHM_PHANTOM+3+2*N_TOP_PHANTOM+1;]
          ]
          ELSE[IRNEW = IR(NP)+1;]
          RETURN;
       ]    " end of the case with  ustep cutoff in z direction "
       ELSE [ RETURN; " no cut off at all "  ]
   ] " end of the w>0 case "

   ELSEIF(W(NP)< 0.0)["particle going backward"
      DIST = (Z_PHANTOM(IR_PHANTOM) - Z(NP))/W(NP);
      "distance to back layer, the 0th index is ok "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0)[" particle was out of this layer in z direction"
          USTEP=0.0;
          IF(IR_PHANTOM=1 & N_TOP_PHANTOM=0 )[ " top of CM, no top part "
              IF(N_GAP_PHANTOM = 1)[ IRNEW =IREND_PHANTOM;]
              " has air gap"
              ELSE [ USTEP=1.E-16; CALL WHERE_AM_I(ICM_PHANTOM,-1); ]
                                              " no air gap "
          ]
          ELSEIF(IR_PHANTOM=1)[
             " top of the chamb, not the top of the CM"
             " particle will go into the top part from below"
             IF(R0SQ<RCYS2_PHANTOM(N_CHM_PHANTOM+N_TOP_PHANTOM,1))[
                 " the last layer of the top part "
                 IRNEW=IRSTART_PHANTOM+
                      N_CHM_PHANTOM+3+2*(N_TOP_PHANTOM-1);
             ]
             ELSE[IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3+
                   2*(N_TOP_PHANTOM-1)+1;
             ]
          ]
          ELSE[  IRNEW = IR(NP)-1;]" layer # decreases by one in the chamb"
          RETURN;
      ]
      " end of the double check if a particle is out of the main cham in z"

      " now check the r direction "
      "==========================="
      CRITERIOR_IR=R0SQ-RCYS2_PHANTOM(1,1);
      IF(CRITERIOR_IR>0.0)[" out of the region in r direction  "
          USTEP=MIN( USTEP, SHIFT_COUNT_PHANTOM(IR_PHANTOM) );
          IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM;" go into the side wall "
          RETURN;
      ]   " end of the   r direction error block "

      "  now do the howfar job  "
      "========================="
      RF2_PHANTOM=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF( RF2_PHANTOM > RCYS2_PHANTOM(1,1) )
        [CUT_COE=CUTCOE_PHANTOM( R0SQ, RCYS2_PHANTOM(1,1) ); ]
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) )[
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM;
          RETURN;
      ]
      ELSEIF(IU_D=1)[" hits the TOP of this layer"
        ;$GEO_SHIFT_1_(STEP_UNIT);
         USTEP=STEP_UNIT;
         IF(IR_PHANTOM=1 & N_TOP_PHANTOM=0 & N_GAP_PHANTOM=0 )
           [ CALL WHERE_AM_I(ICM_PHANTOM,-1); ]  " and first layer of CM  "
         ELSEIF(IR_PHANTOM=1 & N_TOP_PHANTOM=0)
           [ IRNEW=IREND_PHANTOM;]
         ELSEIF( IR_PHANTOM=1 )[ " first layer of chamb, not for CM "
            RF2_PHANTOM= (X(NP)+USTEP*U(NP))*(X(NP)+USTEP*U(NP))
                +(Y(NP)+USTEP*V(NP))*(Y(NP)+USTEP*V(NP));
            IF(RF2_PHANTOM<RCYS2_PHANTOM(N_CHM_PHANTOM+N_TOP_PHANTOM,1))
            [IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3+2*(N_TOP_PHANTOM-1);]
            ELSE[IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3+
                2*(N_TOP_PHANTOM-1)+1;
            ]
         ]
         ELSE[IRNEW = IR(NP)-1;]
         RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
   ]   " end of the w<0.0 case"

   ELSE[ " W=0 CASE "
       CUT_COE=CUTCOE_PHANTOM( R0SQ, RCYS2_PHANTOM(1,1) );
       IF( CUT_COE>0.0 & CUT_COE<=USTEP ) [
           ;$GEO_SHIFT_1_(CUT_COE);
           USTEP=CUT_COE;
           IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM;
       ]
       RETURN;
   ]   " end of the w=0 case "
]     " end of the central chamber layer part "
      "=============================="

ELSEIF(IR_PHANTOM<=N_CHM_PHANTOM+3) [
   " in the side wall or side gap or container wall"
   IIR=IR_PHANTOM-N_CHM_PHANTOM;
   " iir = 1, wall; 2, side gap; 3 container wall "
   IF(W(NP) > 0.0)["particle going forward"
      DIST = (Z_PHANTOM(N_CHM_PHANTOM+1) - Z(NP))/W(NP);
        "distance to back of cham"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <=0.0)[      " out of this layer in z direction "
          USTEP=0.0;
          IF( N_BOT_PHANTOM=0 )[   " no bottom part "
              USTEP=1.E-16;
              CALL WHERE_AM_I(ICM_PHANTOM,1);
          ]
          ELSE[                    " has bottom part "
              IF(R0SQ< RCYS2_PHANTOM(N_CHM_PHANTOM+N_TOP_PHANTOM+1,1))[
                  " the first layer of the bottom "
                  IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3+2*N_TOP_PHANTOM;
              ]
              ELSE[ IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3+
                          2*N_TOP_PHANTOM+1;
              ]
          ]
          RETURN;
      ]
      " end of the double check if a particle is out of the wall in z direct

      " now check the r direction "
      "==========================="
      CRITERIOR_IR=R0SQ-RCYS2_PHANTOM(1,IIR);
      IF(CRITERIOR_IR<0.0)[" out of the region in r dir towards to center"
          USTEP=MIN(USTEP, SHIFT_COUNT_PHANTOM(IR_PHANTOM));
          IF(IIR=1)[
              " figure out the layer # the particle will go into."
              DO I=1, N_CHM_PHANTOM[
                 IF( Z(NP)<Z_PHANTOM(I+1) ) [ EXIT; ]
              ]
              I=MIN(I, N_CHM_PHANTOM);  " to avoid i > n_chm_$chamber "
              IRNEW=IRSTART_PHANTOM+I-1;
          ]
          ELSE[ IRNEW = IRL-1; ]
          RETURN;
      ]      " end of the  out to in check "
      IF( IIR~=3)[" when iir =3, no need to check the outer "
          CRITERIOR_IR=R0SQ-RCYS2_PHANTOM(1,IIR+1);
          IF(CRITERIOR_IR>0.0)[  " out side the outer radius "
              USTEP=MIN( USTEP, SHIFT_COUNT_PHANTOM(IR_PHANTOM) );
              IRNEW=IRL+1;
              RETURN;
          ]       " end of the warnning message block.
      ]        " end of the outer radius check
      " end of the r direction error block "

      " do the howfar job for this case "
      "================================="
      " first do the inner r "
      CUT_COE=CUTCOE_PHANTOM(R0SQ, RCYS2_PHANTOM(1,IIR));
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) )[  " hits the inner wall"
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)[ " figure out the layer # the particle will go into."
             DO I=1, N_CHM_PHANTOM[
                IF( Z(NP)+USTEP*W(NP)<Z_PHANTOM(I+1) ) [ EXIT; ]
             ]
             I=MIN(I, N_CHM_PHANTOM);  " to avoid i > n_chm_$chamber "
             IRNEW = IRSTART_PHANTOM+I-1;
          ]
          ELSE[ IRNEW=IRL-1;]
          RETURN;
      ]
      IF(CUT_COE<=0.0 & IIR~=3)[   " IT IS NECESSARY TO DO OUTER CSAE"
          CUT_COE=CUTCOE_PHANTOM(R0SQ, RCYS2_PHANTOM(1,IIR+1));
          IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
             |( CUT_COE=STEP_UNIT & IU_D=0 ) ) [  " hits the outer wall"
             ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
             USTEP=CUT_COE;
             IRNEW=IR(NP)+1;
             RETURN;
          ]
      ]     " not hits the side wall at all"

     " now check to see whether hitting the bottom  "

      IF(IU_D=1)[         " hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          " last layer of the CM, no bottom part"
          IF(N_BOT_PHANTOM=0 )[ CALL WHERE_AM_I(ICM_PHANTOM,1); ]
          ELSE[" particle will go into the first layer of the bottom part"
              RF2_PHANTOM= (X(NP)+USTEP*U(NP))**2
                        +(Y(NP)+USTEP*V(NP))**2;
              " the first layer of the bottom part "
              IF( RF2_PHANTOM< RCYS2_PHANTOM(N_CHM_PHANTOM+
                           N_TOP_PHANTOM+1,1) )
              [ IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3+2*N_TOP_PHANTOM; ]
              ELSE[ IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3+
                  2*N_TOP_PHANTOM+1;
              ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "

   ]   " end of the w> 0.0 case "

   " now do the w<0.0 case "
   "======================="
   ELSEIF(W(NP) < 0.0)["particle going backward"
      DIST = (Z_PHANTOM("0"1) - Z(NP))/W(NP); "distance to back layer "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0)[ " out of the region in z direction "
          USTEP=0.0;
          IF(N_TOP_PHANTOM=0 )[
              IF(N_GAP_PHANTOM = 1)[ IRNEW =IREND_PHANTOM;]
              ELSE [ USTEP=1.E-16; CALL WHERE_AM_I(ICM_PHANTOM,-1); ]
          ]
          ELSE[         " the last layer of the top part"
             IF(R0SQ<RCYS2_PHANTOM(N_CHM_PHANTOM+N_TOP_PHANTOM,1) )
             [IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3+2*(N_TOP_PHANTOM-1);]
             ELSE[ IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3+
                      2*(N_TOP_PHANTOM-1)+1;]
          ]
          RETURN;
      ] "end of the double check if a particle is out of the region"
            " in z direction"

      " now check the r direction to see if the region # is right or not"
      "================================================================"
      CRITERIOR_IR=R0SQ-RCYS2_PHANTOM(1,IIR);
      IF(CRITERIOR_IR<0.0)[" out of the region in r dir TOWARDS center  "
          USTEP=MIN( USTEP, SHIFT_COUNT_PHANTOM(IR_PHANTOM) );
          IF(IIR=1)[ "figure out the layer # the particle will go into."
             DO I=1, N_CHM_PHANTOM[IF(Z(NP)<Z_PHANTOM(I+1))[EXIT;]]
             I=MIN(I, N_CHM_PHANTOM);  " to avoid i > n_chm_$chamber "
             IRNEW=IRSTART_PHANTOM +I-1;
          ]
          ELSE[ IRNEW=IRL-1;  ]
          RETURN;
      ]  " end of the check for the inner radius case "
      IF( IIR~=3) [ " when iir =3, no need to check the outer "
          CRITERIOR_IR=R0SQ-RCYS2_PHANTOM(1,IIR+1);
          IF(CRITERIOR_IR>0.0)[  " out side the outer radius "
              USTEP=MIN(USTEP,SHIFT_COUNT_PHANTOM(IR_PHANTOM));
              IRNEW=IRL+1;
              RETURN;
          ]       " end of the warning message block.
      ]        " end of the outer radius check
      " end of the   r direction error block "

      " do the howfar job for this case "
      "=====================================
      CUT_COE=CUTCOE_PHANTOM(R0SQ, RCYS2_PHANTOM(1,IIR));
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) )[  " hits the inner wall"
         ; $GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)[ "figure out the layer # the particle will go into."
             DO I=1, N_CHM_PHANTOM[
                 IF( Z(NP)+USTEP*W(NP)<Z_PHANTOM(I+1) ) [ EXIT; ]
             ]
             I=MIN(I, N_CHM_PHANTOM);  " to avoid i > n_chm_$chamber "
             IRNEW=IRSTART_PHANTOM+I-1;
          ]
          ELSE[ IRNEW=IRL-1; ]
          RETURN;
      ]
      IF(CUT_COE<=0.0 & IIR~=3)[   " IT IS NECESSARY TO DO OUTER CSAE"
          CUT_COE=CUTCOE_PHANTOM( R0SQ, RCYS2_PHANTOM(1,IIR+1));
          IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
             |( CUT_COE=STEP_UNIT & IU_D=0 ) )[   " hits the outer wall"
             ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
             USTEP=CUT_COE;
             IRNEW=IRL+1;
             RETURN;
          ]
      ]     " not hits the side wall at all"

      " now check to see whether hitting the bottom  "
      "=============================================="
      IF(IU_D=1)[         " hits the TOP of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          IF(N_TOP_PHANTOM=0 )[ " the first layer of the CM, no top part "
             IF(N_GAP_PHANTOM=0)[ CALL WHERE_AM_I(ICM_PHANTOM,-1); ]
              " no air gap "
             ELSE[ IRNEW=IREND_PHANTOM; ]
          ]
          ELSE[ " particle will go into the last layer of the top part  "
            RF2_PHANTOM= (X(NP)+USTEP*U(NP))**2
                        +(Y(NP)+USTEP*V(NP))**2;
            IF(RF2_PHANTOM<RCYS2_PHANTOM(N_CHM_PHANTOM+N_TOP_PHANTOM,1))
              [IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3+
                      2*(N_TOP_PHANTOM-1); ]
            ELSE[IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3+
                      2*(N_TOP_PHANTOM-1)+1; ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
   ]        " end of the w<0.0 case "

   ELSE[ "  w=0 case "
      CUT_COE=CUTCOE_PHANTOM( R0SQ, RCYS2_PHANTOM(1,IIR));"inner wall first"
      IF(  CUT_COE>0.0 & CUT_COE <= USTEP )[  " hits the inner wall"
          ;$GEO_SHIFT_1_(CUT_COE);
          USTEP=CUT_COE;
          IF(IIR=1)[
             DO I=1, N_CHM_PHANTOM
             " figure out the layer # the particle will go into."
               [ IF( Z(NP)+USTEP*W(NP)<Z_PHANTOM(I+1) ) [ EXIT; ] ]
             I=MIN(I, N_CHM_PHANTOM);  " to avoid i > n_chm_$chamber "
             IRNEW=IRSTART_PHANTOM+I-1;
          ]
          ELSE[ IRNEW=IRL-1; ]
      ]
      IF(CUT_COE<=0.0 & IIR~=3)[ " IT IS NECESSARY TO DO OUTER CSAE"
          CUT_COE=CUTCOE_PHANTOM( R0SQ, RCYS2_PHANTOM(1,IIR+1));
          IF(  CUT_COE>0.0 & CUT_COE <= USTEP )[   " hits the outer wall"
             ;$GEO_SHIFT_1_(CUT_COE);
             USTEP=CUT_COE;
             IRNEW=IRL+1;
          ]
      ]
      RETURN;     " not hits the side wall at all"
   ]   " end of the w=0 case "
]      " end of the side of the ionchamber part"

" now do the top part of this CM "
"================================"
ELSEIF(IR_PHANTOM<=N_CHM_PHANTOM+3+2*N_TOP_PHANTOM )[ " top layers "
   IIR=IR_PHANTOM-(N_CHM_PHANTOM+3);
   IIR=MOD(IIR, 2);" iir=1, inside region, =0, outside region "
   IF(W(NP) > 0.0)   ["particle going forward"
      DIST = (Z_PHANTOM(LAYER+1) - Z(NP))/W(NP); "distance to back of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <=0.0)[
          USTEP=0.0;
          IF(LAYER=N_CHM_PHANTOM+N_TOP_PHANTOM )["the end of the top layer"
              IF( R0SQ<RCYS2_PHANTOM(1,1) ) [  IRNEW =IRSTART_PHANTOM;]
              ELSEIF( R0SQ<RCYS2_PHANTOM(1,2) )
                [IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM;]
              ELSEIF( R0SQ<RCYS2_PHANTOM(1,3) )
                [IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM+1;]
              ELSE[ IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM+2;]
          ]
          ELSE[
              IF( R0SQ< RCYS2_PHANTOM(LAYER+1,1) )[
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                       +2*(LAYER-N_CHM_PHANTOM);
              ]
              ELSE[
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                      +2*(LAYER-N_CHM_PHANTOM)+1;
              ]
          ]
          RETURN;
      ]
      " end of the double check if a particle is out of the CM in z direction

      " now check the r direction "
      "============================"
      CRITERIOR_IR=R0SQ-RCYS2_PHANTOM(LAYER, 1);
      IF(CRITERIOR_IR>0.0 & IIR=1)[  " out OF the  r "
         USTEP=MIN( USTEP, SHIFT_COUNT_PHANTOM(IR_PHANTOM) );
         IRNEW=IRL+1;
         RETURN;
      ]
      ELSEIF(CRITERIOR_IR<0.0 & IIR=0)[  " inside the outer radius "
         USTEP=MIN( USTEP, SHIFT_COUNT_PHANTOM(IR_PHANTOM) );
         IRNEW=IRL-1;
         RETURN;
      ]      " end of the warnning message block."


      " do the howfar job for this case "
      "=====================================
      RF2_PHANTOM=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF( ( RF2_PHANTOM > RCYS2_PHANTOM(LAYER,1) & IIR=1 ) | IIR=0 )
        [CUT_COE=CUTCOE_PHANTOM( R0SQ, RCYS2_PHANTOM(LAYER,1)); ]
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) )[" hits the inner wall"
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)[IRNEW=IRL+1; " from in to out "]
          ELSE[ IRNEW=IRL-1; ]
          RETURN;
      ]

      " now check to see whether hitting the bottom  "
      ELSEIF(IU_D=1) [" hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          RF2_PHANTOM= (X(NP)+USTEP*U(NP))**2
                   +(Y(NP)+USTEP*V(NP))**2;
          IF(LAYER=N_CHM_PHANTOM+N_TOP_PHANTOM)[ " last layer of the top"
              " particle will go into the first layer of the chamber  "
              IF( RF2_PHANTOM< RCYS2_PHANTOM(1,1) )
                [ IRNEW=IRSTART_PHANTOM;]
              ELSEIF ( RF2_PHANTOM< RCYS2_PHANTOM(1,2) )
                [ IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM;]
              ELSEIF ( RF2_PHANTOM< RCYS2_PHANTOM(1,3) )
                [ IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+1;]
              ELSE[ IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+2; ]
          ]     " end of the last layer of the top case "
          ELSE[
              IF( RF2_PHANTOM< RCYS2_PHANTOM(LAYER+1,1) )[
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                       +2*(LAYER-N_CHM_PHANTOM);
              ]
              ELSE [
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                      +2*(LAYER-N_CHM_PHANTOM)+1;
              ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
   ]                   " end of the w> 0 case "

   " now do the w<0 case "
   "====================="

   ELSEIF(W(NP) < 0.0)[     "particle going backward"
      "  the top layer in the top part "
      IF(LAYER=N_CHM_PHANTOM+1)[ DIST=( ZMIN_PHANTOM-Z(NP) )/W(NP); ]
      ELSE [ DIST = (Z_PHANTOM(LAYER) - Z(NP))/W(NP); ]
      "distance to back layer "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0) [
          USTEP=0.0;
          IF(LAYER=N_CHM_PHANTOM +1) [  " the first layer of the CM "
              IF(N_GAP_PHANTOM = 1)[ IRNEW =IREND_PHANTOM;]
              " has air gap "
              ELSE [ USTEP=1.E-16; CALL WHERE_AM_I(ICM_PHANTOM,-1); ]
                                            " no air gap "
          ]
          ELSE [
             IF(R0SQ<RCYS2_PHANTOM(LAYER-1,1) )[
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                       +2*(LAYER-2-N_CHM_PHANTOM);
             ]
             ELSE[
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                       +2*(LAYER-2-N_CHM_PHANTOM)+1;
             ]
          ]
          RETURN;
      ]
      "  end of the double check if a particle is out of the top layer in z"

      " now check the r direction "
      "============================"
      CRITERIOR_IR=R0SQ-RCYS2_PHANTOM(LAYER, 1);
      IF(CRITERIOR_IR>0.0 & IIR=1) [ "supposed to be in outside region"
         USTEP=MIN( USTEP, SHIFT_COUNT_PHANTOM(IR_PHANTOM) );
         IRNEW=IRL+1;
         RETURN;
      ]
      ELSEIF(CRITERIOR_IR<0.0 & IIR=0)["supposed to be in inside region"
         USTEP=MIN( USTEP, SHIFT_COUNT_PHANTOM(IR_PHANTOM) );
         IRNEW=IRL-1;
         RETURN;
      ]      " end of the warnning message block."

      " do the howfar job for this case "
      "=====================================
      RF2_PHANTOM=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF( ( RF2_PHANTOM > RCYS2_PHANTOM(LAYER,1) & IIR=1 ) | IIR=0 )
        [CUT_COE=CUTCOE_PHANTOM(R0SQ, RCYS2_PHANTOM(LAYER,1)); ]
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) ) [" hits the side  wall"
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)  [  IRNEW=IRL+1; " from in to out "]
          ELSE[ IRNEW=IRL-1; ]
          RETURN;
      ]

      " now check to see whether hitting the top  "
      "==========================================="
      ELSEIF(IU_D=1) [" hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          RF2_PHANTOM= (X(NP)+USTEP*U(NP))**2
                   +(Y(NP)+USTEP*V(NP))**2;
          IF(LAYER=N_CHM_PHANTOM+1) [ " the first layer of the top"
              " particle will go into the air gap or out of the CM  "
              IF( N_GAP_PHANTOM=1 ) [ IRNEW=IREND_PHANTOM;]
              ELSE[ CALL WHERE_AM_I(ICM_PHANTOM, -1); ]
          ]     " end of the last layer of the top case "
          ELSE[         " still inside the top part "
              IF( RF2_PHANTOM< RCYS2_PHANTOM(LAYER-1,1) )[
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                       +2*(LAYER-N_CHM_PHANTOM-2);
              ]
              ELSE[
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                      +2*(LAYER-N_CHM_PHANTOM-2)+1;
              ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
  ]   " end of the w< 0.0 case "

  " now do  the w=0.0 case "
  "========================"
   ELSE [
      CUT_COE=CUTCOE_PHANTOM(R0SQ, RCYS2_PHANTOM(LAYER,1));
      IF(  CUT_COE>0.0 & CUT_COE <= USTEP )  [ " hits the  wall"
          ;$GEO_SHIFT_1_(CUT_COE);
          USTEP=CUT_COE;
          IF(IIR=1)[ IRNEW=IRL+1;]
          ELSE[ IRNEW=IRL-1; ]
      ]
      RETURN;
   ]    " end of the w=0.0 case "
]      " end of the top part "

" now do the bottom part "
"========================"
ELSEIF(IR_PHANTOM<=N_CHM_PHANTOM+3+2*N_TOP_PHANTOM+2*N_BOT_PHANTOM )[
   IIR=IR_PHANTOM-(N_CHM_PHANTOM+3);
   IIR=MOD(IIR, 2);      " iir=1, inside , iir=2, out side region "
   IF(W(NP) > 0.0)[        "particle going forward"
      DIST = (Z_PHANTOM(LAYER+1) - Z(NP))/W(NP); "distance to back of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <=0.0) [
          USTEP=0.0;
          IF(LAYER=N_CHM_PHANTOM+N_TOP_PHANTOM+N_BOT_PHANTOM)
             [  USTEP=1.E-16; CALL WHERE_AM_I(ICM_PHANTOM, 1); ]
          " the end layer of the  bottom part and the CM"
          ELSE[
              IF( R0SQ< RCYS2_PHANTOM(LAYER+1,1) )[
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                        +2*(LAYER-N_CHM_PHANTOM);
              ]
              ELSE[
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                        +2*(LAYER-N_CHM_PHANTOM)+1;
              ]
          ]
          RETURN;
      ]
      " end of the double check if a particle is out of region in z direction"

      " now check the r direction "
      "============================="
      CRITERIOR_IR=R0SQ-RCYS2_PHANTOM(LAYER, 1);
      IF(CRITERIOR_IR>0.0 & IIR=1)["supposed to be in the outer region"
         USTEP=MIN( USTEP, SHIFT_COUNT_PHANTOM(IR_PHANTOM) );
         IRNEW=IRL+1;
         RETURN;
      ]
      ELSEIF(CRITERIOR_IR<0.0 & IIR=0)["supposed to be in inside region"
         USTEP=MIN( USTEP, SHIFT_COUNT_PHANTOM(IR_PHANTOM) );
         IRNEW=IRL-1;
         RETURN;
      ]      " end of the warnning message block."

      " do the howfar job for this case "
      "=====================================
      RF2_PHANTOM=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF( ( RF2_PHANTOM > RCYS2_PHANTOM(LAYER,1) & IIR=1 ) | IIR=0 )
        [ CUT_COE=CUTCOE_PHANTOM( R0SQ, RCYS2_PHANTOM(LAYER,1)); ]
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) )[" hits the side wall"
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)[  IRNEW=IRL+1; " from in to out "]
          ELSE[ IRNEW=IRL-1; ]
          RETURN;
      ]    " end of the hitting the side wall case "

      " now check to see whether hitting the bottom  "
      "=============================================="
      ELSEIF(IU_D=1) [        " hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          RF2_PHANTOM= (X(NP)+USTEP*U(NP))**2
                   +(Y(NP)+USTEP*V(NP))**2;
          IF(LAYER=N_CHM_PHANTOM+N_TOP_PHANTOM+N_BOT_PHANTOM )
             [  CALL WHERE_AM_I(ICM_PHANTOM, 1) ; ]
          "last layer of the CM"
          ELSE [
              IF( RF2_PHANTOM< RCYS2_PHANTOM(LAYER+1,1) ) [
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                       +2*(LAYER-N_CHM_PHANTOM);
              ]
              ELSE[
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                      +2*(LAYER-N_CHM_PHANTOM)+1;
              ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
   ]   " end of the w>0.0 case "
       "========================"

   ELSEIF(W(NP) < 0.0)[       "particle going backward"
      IF(LAYER=N_CHM_PHANTOM+N_TOP_PHANTOM+1)
        [ DIST=( Z_PHANTOM(N_CHM_PHANTOM+1)-Z(NP) )/W(NP); ]
      "  the top layer in the bottom part "
      ELSE [ DIST = (Z_PHANTOM(LAYER-1+1) - Z(NP))/W(NP); ]
            "distance to back layer "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; IU_D=0; ]
      ELSE [ STEP_UNIT=DIST; IU_D=1; ]
      IF(DIST <= 0.0)[
          USTEP=0.0;
          IF( LAYER=N_CHM_PHANTOM+N_TOP_PHANTOM+1 ) [
              " the first layer of the bottom "
              IF( R0SQ<RCYS2_PHANTOM(1,1) )
                [  IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM-1;]
              " the last layer of the cham"
              ELSEIF( R0SQ<RCYS2_PHANTOM(1,2) )
                [IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM;]
              " the side wall region"
              ELSEIF( R0SQ<RCYS2_PHANTOM(1,3) )
                [IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM+1;]
              " the side gap region "
              ELSE[ IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM+2;]
              " outtest container region "
          ]
          ELSE[
             IF(R0SQ<RCYS2_PHANTOM(LAYER-1,1) )[
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                       +2*(LAYER-2-N_CHM_PHANTOM);
             ]
             ELSE [
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                       +2*(LAYER-2-N_CHM_PHANTOM)+1;
             ]
          ]
          RETURN;
      ] "end of the double check if a particle is out of the region in z"

      " now check the r direction "
      "============================"
      CRITERIOR_IR=R0SQ-RCYS2_PHANTOM(LAYER, 1);
      IF(CRITERIOR_IR>0.0 & IIR=1)  [" supposed to be outside  "
         USTEP=MIN( USTEP, SHIFT_COUNT_PHANTOM(IR_PHANTOM) );
         IRNEW=IRL+1;
         RETURN;
      ]
      ELSEIF(CRITERIOR_IR<0.0 & IIR=0) [ " supposed to be inside "
         USTEP=MIN( USTEP, SHIFT_COUNT_PHANTOM(IR_PHANTOM) );
         IRNEW=IRL-1;
         RETURN;
      ]      " end of the warnning message block."

      " do the howfar job for this case "
      "=====================================
      RF2_PHANTOM=(X(NP)+STEP_UNIT*U(NP))**2
                        +(Y(NP)+STEP_UNIT*V(NP))**2;
      IF( ( RF2_PHANTOM > RCYS2_PHANTOM(LAYER,1) & IIR=1 ) | IIR=0 )
        [CUT_COE=CUTCOE_PHANTOM( R0SQ, RCYS2_PHANTOM(LAYER,1)); ]
      IF( ( CUT_COE>0.0 & CUT_COE < STEP_UNIT )
         |( CUT_COE=STEP_UNIT & IU_D=0 ) ) [ " hits the inner wall"
          ;$GEO_SHIFT_2_(CUT_COE, STEP_UNIT);
          USTEP=CUT_COE;
          IF(IIR=1)[  IRNEW=IRL+1; " from in to out "]
          ELSE[ IRNEW=IRL-1; ]
          RETURN;
      ]

      " now check to see whether hitting the top  "
      ELSEIF(IU_D=1) [ " hits the bottom of this layer"
          ;$GEO_SHIFT_1_(STEP_UNIT);
          USTEP=STEP_UNIT;
          RF2_PHANTOM= (X(NP)+USTEP*U(NP))**2
                   +(Y(NP)+USTEP*V(NP))**2;
          IF(LAYER=N_CHM_PHANTOM+N_TOP_PHANTOM+1)[
              " the first layer of the bottom"
              " particle will go into the chamber   "
              IF( RF2_PHANTOM<RCYS2_PHANTOM(1,1) )
                [IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM-1;]
              "the last layer of the cham"
              ELSEIF( RF2_PHANTOM<RCYS2_PHANTOM(1,2) )
                [IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM;]
               " the side wall region"
              ELSEIF( RF2_PHANTOM<RCYS2_PHANTOM(1,3) )
                [IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM+1;]
              " the side gap region "
              ELSE[ IRNEW =IRSTART_PHANTOM+N_CHM_PHANTOM+2;]
              "outtest container region "
          ]     " end of the last layer of the bottom case "
          ELSE[  " still inside the bottom part "
              IF( RF2_PHANTOM< RCYS2_PHANTOM(LAYER-1,1))[
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                       +2*(LAYER-N_CHM_PHANTOM-2);
              ]
              ELSE[
                 IRNEW=IRSTART_PHANTOM+N_CHM_PHANTOM+3
                      +2*(LAYER-N_CHM_PHANTOM-2)+1;
              ]
          ]
          RETURN;
      ]    " end of the case with  ustep cutoff in z direction "
      ELSE [ RETURN; ]       " no cut off at all "
   ]   " end of the w< 0.0 case "

   ELSE[ " now do  the w=0.0 case "
         "========================"
      CUT_COE=CUTCOE_PHANTOM( R0SQ, RCYS2_PHANTOM(LAYER,1));
      IF(  CUT_COE>0.0 & CUT_COE <= USTEP )  [" hits the  wall"
         ; $GEO_SHIFT_1_(CUT_COE);
          USTEP=CUT_COE;
          IF(IIR=1)
            [ IRNEW=IRL+1;]
          ELSE[ IRNEW=IRL-1; ]
      ]
      RETURN;
   ]    " end of the w=0.0 case "

]   " end of the bottom part "
       "======================="



"   outside of CM, something is wrong
"   =================================
"
ELSE ["something is wrong"
   OUTPUT IR(NP)-IRSTART_PHANTOM+1,IR(NP),ICM_PHANTOM,
          IR_start_CM(ICM_PHANTOM);
      (//' ************'//' HOWFAR-CHAMBER error'/
         '    Region, local, absolute =',2I5/
         '    CM number=',I5,' start region =',I5/
         ' *********'//);
   STOP;
] "end of IF statement"
;
"   end of HOWFAR_PHANTOM
"   ===================
"
END; "End of subroutine HOWFAR_PHANTOM"

%E "Start of miscellaneous functions and subroutines"

;$REAL FUNCTION SHIFT_COUNT_PHANTOM(IDUMP);
"This function is used in finding the correct region. If a particle is
"in a wrong region we change the region # and shift the particle by 1.0E-5.
"If we still cannot find the correct region after 20 shifts we terminate the
"particle. If 10000 particles have been discarded we quit! However, one
"can carry on running this simulation using the BEAM re-start feature if he
"considers the effect of discarding these particles would be negligible
"for a large number of histories run.

;IMPLICIT NONE;

;COMIN/STACK, EPCONT,CM_PHANTOM,SCORE,EGS-IO/;

$LONG_INT IHSTRYOLD;
INTEGER IDUMP, COUNT1, COUNT;
$REAL XYZNEW,XYZOLD,xyzoldsave;
save xyzold,count1,count;
DATA count1,count/0,0/;
XYZNEW=X(NP)+Y(NP)+Z(NP);
IF( XYZNEW.NE.XYZOLD.OR.IHSTRY.NE.IHSTRYOLD)[ COUNT1=0;]
     " This fudge is used just to get around a numerical accuracy "
     " problem.  It is OK unless you receive the error message in "
     " the next if statement a lot of times.  "
     " IHSTRY check added to protect against incrementing COUNT1"
     " when phase space source is incident right on boundary of"
     " chamber and particles are recycled"
ELSE[
    COUNT1=COUNT1+1;
    IF( COUNT1=20 ) [
        OUTPUT IDUMP,X(NP),Y(NP),X(NP)**2+Y(NP)**2,Z(NP),U(NP),
        V(NP),W(NP),E(NP),IQ(NP);
        (/' WARNING FROM CHAMBER REGION ', I5,': TAKEN USTEP = 1.0E-5 ',
         ' FOR 20 TIMES, STILL CANNOT FIND ITS REGION'/
         ' THE PARTICLE HAS BEEN DISCARDED.'/
         ' OUTPUT: x,y,r**2,z,u,v,w,E,IQ '/
        8F11.6,I3);
        IDISC=1;COUNT1=0;
        SHIFT_COUNT_PHANTOM=0.0;
        COUNT=COUNT+1;
        IF( COUNT >10000 )[
          OUTPUT;(//' ChAMBER: 10000 PARTICLES HAVE BEEN DISCARDED DUE TO'/
                     ' WRONG REGION #/BOUNDARY CROSSING ERROR. STOP!!!'//);
          STOP;
        ]
    ]
]
XYZOLD=XYZNEW;
IHSTRYOLD=IHSTRY;

SHIFT_COUNT_PHANTOM=1.0E-5;

RETURN;
END;

"******************************************************************

SUBROUTINE WARN_MES_PHANTOM(IDUMP, DUMP1, DUMP2);
IMPLICIT NONE;
COMIN/EGS-IO/;
INTEGER IDUMP, COUNT;
$REAL DUMP1, DUMP2;

    OUTPUT IDUMP, DUMP1, DUMP2; (/' WARNING MESSAGE: ' , I5, 2F15.8);
    COUNT=COUNT+1;
RETURN;
END;

"******************************************************************
;

$REAL FUNCTION CUTCOE_PHANTOM( DUMP1, DUMP2 );
IMPLICIT NONE;

$REAL  DUMP1, DUMP2;
;COMIN/STACK, CM_PHANTOM/;

$REAL A, B, B2, C, TEMP, CUT_COE1, CUT_COE2,one;
parameter (one=1);

A=U(NP)**2+V(NP)**2;
B=X(NP)*U(NP)+Y(NP)*V(NP);
B2=B**2;
C=DUMP1-DUMP2;
IF(A=0.0)[
     IF(B~=0.0)[CUTCOE_PHANTOM=-0.5*C/B;]
     ELSE[ CUTCOE_PHANTOM=-1.0E5; ]
]
ELSE[
    TEMP=B2-A*C;
    IF(TEMP>=0.0)[
       TEMP=-(B+SIGN(one,B)*SQRT(TEMP) );
       CUT_COE1=TEMP/A;
       CUT_COE2=C/TEMP;
       IF( CUT_COE1>0.0 & CUT_COE2>0.0)
       [CUTCOE_PHANTOM=MIN(CUT_COE1,CUT_COE2); ]
       ELSE[ CUTCOE_PHANTOM=MAX(CUT_COE1,CUT_COE2); ]
    ]
    ELSE [ CUTCOE_PHANTOM=-1.0E5; ]
]

RETURN;
END; "End of miscellaneous subroutines and functions"

%E    "Start of subroutine WHERE_AM_I_PHANTOM"
"******************************************************************************

"******************************************************************************
"
"                          Subroutine WHERE_AM_I_PHANTOM
"                          ***************************
"
" WHERE_AM_I routine for a stacked right cylinder slabs.
"
" WHERE_AM_I_PHANTOM determines the new region # when a particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_PHANTOM subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_PHANTOM from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"******************************************************************************

;SUBROUTINE WHERE_AM_I_PHANTOM(IDIR);


;IMPLICIT NONE;

;COMIN/CMs,CM_PHANTOM,EPCONT,STACK/;

"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_PHANTOM
"T>**************************************
"T>

INTEGER IDIR;  "T>direction of particle, +1=forward, -1=backward
$REAL XBDY_PHANTOM,YBDY_PHANTOM,RBDY2_PHANTOM;
XBDY_PHANTOM = X(NP) + U(NP)*USTEP;
YBDY_PHANTOM = Y(NP) + V(NP)*USTEP;
RBDY2_PHANTOM = XBDY_PHANTOM*XBDY_PHANTOM + YBDY_PHANTOM*YBDY_PHANTOM;
IF((IRSTART_PHANTOM = 2) & (IDIR =1))    " this is first CM and from front
  [ RBDY2_PHANTOM = X(NP)*X(NP) + Y(NP)*Y(NP); ]

IF (IDIR=1) ["particle entering this CM through front face (upstream)
   IF(N_GAP_PHANTOM = 0) [        "no air gap this CM"
      IF(N_TOP_PHANTOM=0)    [" no top layers above the ionchamber.
         IF(RBDY2_PHANTOM < RCYS2_PHANTOM(1,1))
           [ IRNEW = IRSTART_PHANTOM;   ]     " center
         ELSEIF(RBDY2_PHANTOM < RCYS2_PHANTOM(1, 2))
           [   IRNEW = IRSTART_PHANTOM + N_CHM_PHANTOM;]  " side wall
         ELSEIF(RBDY2_PHANTOM < RCYS2_PHANTOM(1, 3))
           [IRNEW = IRSTART_PHANTOM + N_CHM_PHANTOM+1; ]     " side gap
         ELSE[ IRNEW = IRSTART_PHANTOM +N_CHM_PHANTOM+2 ; ] " container wall
      ]
      ELSE["   has top layer."
         IF(RBDY2_PHANTOM < RCYS2_PHANTOM(N_CHM_PHANTOM+1,1))
           [ IRNEW = IRSTART_PHANTOM + N_CHM_PHANTOM +3; ]
         ELSE[ IRNEW = IRSTART_PHANTOM + N_CHM_PHANTOM +3 +1; ]
      ]
   ]
   ELSE [  IRNEW = IREND_PHANTOM; ]"this CM has an air gap at the front"
]  " end of idir=1 case
ELSE ["particle entering this CM through back face (downstream)
   IF( N_BOT_PHANTOM=0 )[ " no bottom layers below the chamber
      IF(RBDY2_PHANTOM < RCYS2_PHANTOM(1,1))
        [ IRNEW = IRSTART_PHANTOM-1+N_CHM_PHANTOM;   ]     " center
      ELSEIF(RBDY2_PHANTOM < RCYS2_PHANTOM(1, 2))
        [ IRNEW = IRSTART_PHANTOM+N_CHM_PHANTOM ;]  " side wall
      ELSEIF(RBDY2_PHANTOM < RCYS2_PHANTOM(1, 3))
        [IRNEW = IRSTART_PHANTOM +N_CHM_PHANTOM+ 1; ]     " side gap
      ELSE[ IRNEW = IRSTART_PHANTOM+N_CHM_PHANTOM + 2; ] " container wall
   ]
   ELSE["   has bottom layer.
      IF(RBDY2_PHANTOM
       < RCYS2_PHANTOM(N_CHM_PHANTOM+N_TOP_PHANTOM+N_BOT_PHANTOM,1))
        [ IRNEW = IREND_PHANTOM-N_GAP_PHANTOM-1; ]
      ELSE[ IRNEW =IREND_PHANTOM-N_GAP_PHANTOM; ]
   ]
]

RETURN;

END; "End of subroutine WHERE_AM_I_PHANTOM"

%E   "Start of subroutine INPUT_PHANTOM"
"*******************************************************************************
"
"                           Subroutine INPUT_PHANTOM
"                           **********************
"
"  A CM input subroutine for a cylindrical planar geometry.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_PHANTOM;


;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_PHANTOM,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;
"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_PHANTOM
"T>*********************************
"T>

$REAL   ZTHICK_PHANTOM, "T>total thickness of CM
        ZTHICK,          "T>temp. variable used to store layer thicknesses
        THICK1, THICK2, THICK3, "T>temp. storage of total thicknesses
        Zminthick,       "T>used to calc. min thickness for range rejection
        RCYSTEMP($MAX_N_PHANTOM), "T>used for inputting top part
        ZTEMP($MAX_N_PHANTOM),    "T>used for inputting top part
        ECUTTEMP($MXREG),          "T>used for inputting top part
        PCUTTEMP($MXREG);          "T>used for inputting top part

INTEGER I,IM,J,JM, II, III,        "T>DO loop indeces
        MRNGE,          "T> local variable = 1 to enable ECUTRR calculation
                        "T> otherwise ECUTRR is not calculated
        IRA,            "T>Absolute region number
        MED_FLAG,       "T>flag used by media-sort macro $MED_INPUT
        MED_INDEX,      "T>medium index, set after medium sort by $MED_INPUT
        N_CHAM,         "T>used to keep track of number of layers in chamber
        DOSE_ZONETEMP($MXREG),  "T>used for inputting top part
        IREGION_TO_BITTEMP($MXREG), "T>used for inputting top part
        MEDTEMP($MXREG),          "T>used for inputting top part
        IRM;                      "T>used for inputting top part
"
"  initialize parameters
"  =====================
"
ICM_PHANTOM = ICM;     "CM index for this component module
IRSTART_PHANTOM = IR_start_CM(ICM_PHANTOM);
              "Index of first region in this CM,
              "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_PHANTOM) = 0; "Geometry-checking flag, 0 if no error detected

DO I=1,NDOSE_ZONE[ZPLOTCHM(I)=-1000.;"set default values"]

"
"  get the title line
"  ==================
"
OUTPUT;(/' PHANTOM  (CHAMBER)');
OUTPUT RMAX_CM(ICM);
     (/' This component is an ion chamber or for scoring dose components'/
       '       Outer boundary is a cylinder of radius',F10.4,' cm'
       //' TITLE: ',$);
;MINPUT (PHANTOM) TITLE_PHANTOM;(60A1);
OUTPUT TITLE_PHANTOM;(' ',60A1);

IF (ICM_PHANTOM = 1)[OUTPUT Z_min_CM(1);
   (' This is first component module -- starts at',F12.4,
                                          ' cm from ref plane(z=0)');
]
ELSE [OUTPUT Z_min_CM(ICM_PHANTOM);
   (' This CM, including air gap, starts at end of previous CM at', F10.5,
    ' cm');
]
"
" get distance from reference plane, z=0"
"   =============================
OUTPUT;
(/' Distance from front of PHANTOM(not air gap) to ref plane(z=0):',$);
;MINPUT (PHANTOM) ZMIN_PHANTOM;(F15.0);
OUTPUT ZMIN_PHANTOM;(F11.5);

IF(ZMIN_PHANTOM < Z_min_CM(ICM_PHANTOM))[
   IF(ICM_PHANTOM=1)[
      OUTPUT ICM_PHANTOM, ZMIN_PHANTOM,Z_min_CM(ICM_PHANTOM);
       (//' ***WARNING IN CM ',I4,' (CHAMBER):'/
          ' Z_min_CM(1) > distance to top of chamber'/
          ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm '//);
          WRITE(IOUTLIST,100)
        ICM_PHANTOM, ZMIN_PHANTOM,Z_min_CM(ICM_PHANTOM);
     100 FORMAT(//' ***WARNING IN CM ',I4,' (CHAMBER):'/
          ' Z_min_CM(1) > distance to top of chamber'/
          ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm '//);
       Z_min_CM(ICM_PHANTOM)=ZMIN_PHANTOM;
   ]
   ELSE[
     OUTPUT ICM_PHANTOM;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'Overlaps with previous CM'//);
       IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
   ]
]
OUTPUT; (/' This module consists of 3 partS:',
         /'   1 --- top part, ',
         /'   2 --- main part: the chamber/phantom central part, ',
         /'   3 --- bottom part.');
OUTPUT $MAX_N_PHANTOM-1;
(/' Input the number of layers for each part: '/
' N-TOP (>=0), N-CHAM (>0 to input chamber layers individually or <0 to'/
' input -N-CHAM groups of layers), N-BOT (>=0) (N-TOP + total number of'/
' chamber layers + N-BOT <= ',I4,') on one line'/
' : ',$);
;MINPUT (PHANTOM) N_TOP_PHANTOM, N_CHM_PHANTOM, N_BOT_PHANTOM;(3I5);
OUTPUT N_TOP_PHANTOM, N_CHM_PHANTOM,  N_BOT_PHANTOM;(3I9);
IF(N_CHM_PHANTOM=0)[
   OUTPUT ICM_PHANTOM;
     (//'***ERROR IN CM ',I4,' (CHAMBER)'/
        'N-CHAM = 0'/
        'N-CHAM reset to 1 for now.'//);
   N_CHM_PHANTOM=1;
   IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
]
IF(N_TOP_PHANTOM < 0)[
   OUTPUT ICM_PHANTOM; (//'***ERROR IN CM ',I4,' (CHAMBER)'/
        'N-TOP < 0'/ 'N-TOP reset to 0 for now.'//);
   N_TOP_PHANTOM=0;
   IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
]
IF(N_BOT_PHANTOM < 0)[
   OUTPUT ICM_PHANTOM;
     (//'***ERROR IN CM ',I4,' (CHAMBER)'/
        'N-BOT < 0'/ 'N-BOT reset to 0 for now.'//);
   N_BOT_PHANTOM=0;
   IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
]
IF(N_CHM_PHANTOM>0 &
   N_CHM_PHANTOM+N_TOP_PHANTOM+N_BOT_PHANTOM > $MAX_N_PHANTOM-1)[
   N_BOT_PHANTOM=0;
   N_TOP_PHANTOM=0;
   N_CHM_PHANTOM=$MAX_N_PHANTOM-1;
   OUTPUT ICM_PHANTOM, $MAX_N_PHANTOM-1;
    (//'***ERROR IN CM ',I4,' (CHAMBER):'/
       'N-CHAM + N-TOP + N-BOT > max. # of layers allowed.'/
       'N-TOP set to 0, N-BOT set to 0, N-CHAM set to ',I4,' for now.'//);
   IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
]

IF(N_CHM_PHANTOM>0)[
   N_PHANTOM = N_CHM_PHANTOM+3+ 2*N_TOP_PHANTOM+2*N_BOT_PHANTOM;
]
"Number of regions in this CM (<50, excluding front air gap)"
"
"                  INPUT for TOP REGION
"                  ====================
"
IF(N_TOP_PHANTOM~=0)[
  OUTPUT N_TOP_PHANTOM;
  (/' Input thickness (ZTHICK) & inner radius (RCYL) for each of',
   ' the',I3,' layers'/' for the top part.'
  /' Note that the inner radius, RCYL divides each layer into 2',
  ' regions,'/
  ' an inner disc-shaped region and an outer annular region.',
  /' The outer boundary of the annular region is RMAX_CM.');
  OUTPUT;(/
  ' For layers of equal thickness, inner radius and medium, '/
  ' Input ZTHICK,RCYL & N-TOP, in one line)'/
  ' Otherwise, input ZTHICK & RCYL for each layer starting from 1ST',
  ' layer'/ ' : ',$);
  IM=1;"starting # for the top part"
  ;MINPUT (PHANTOM) ZTHICK, RCYSTEMP(IM),JM;(2F15.0,I5);
  OUTPUT ZTHICK, RCYSTEMP(IM),JM;(2F15.5,I5);
  IF(ZTHICK<0.0)[
     OUTPUT ICM_PHANTOM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Thickness of layer 1 in top part < 0.0.'//);
     IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
  ]
  IF(RCYSTEMP(IM)<0.0)[
     OUTPUT ICM_PHANTOM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'RCYS of layer 1, top part < 0.0'//);
     IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
  ]
  ELSEIF(RCYSTEMP(IM) > RMAX_CM(ICM_PHANTOM))[
     OUTPUT ICM_PHANTOM;
      (//'***WARNING IN CM ',I4,' (CHAMBER):'/
         'RCYS of layer 1, top part > RMAX_CM'//);
     WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,
       '' (CHAMBER):''/ ''RCYS of layer 1, top part > RMAX_CM''//)')
        ICM_PHANTOM;
  ]
  ZTEMP(IM)=ZMIN_PHANTOM+ZTHICK;

  IF(JM = N_TOP_PHANTOM)["for equal thickness, radius and medium"
     IRM=1;
     OUTPUT N_TOP_PHANTOM;
     (/' All the',I5,' layers have the same thickness, inner radius'/);
     "1st (inner) region in the top part"
     OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose)',
        ',IREGION_TO_BIT for inner regions'/' :',$);
     ;MINPUT (PHANTOM) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM);
     (2F15.0,2I5);
     IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
     IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
     ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IM),
        IREGION_TO_BITTEMP(IM); (2F10.4, I5,I15);
     OUTPUT;(/' For inner regions:',$);
     ;$MED_INPUT(PHANTOM); " inputs character array MED_IN from unit 5,
                            " loops
     "through array MEDIA(24,I) to check if medium was previously input.
     "If so, sets MED_INDEX to index of previous medium.  If not,
     "increments NMED and sets MED_INDEX to NMED.
     MEDTEMP(IRM) = MED_INDEX; " medium of the slab
     IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_PHANTOM, $MAX_DOSE_ZONE;
       (/'***ERROR IN CM ',I4,' (CHAMBER):'/
       'DOSE_ZONE # of inner cylinders in top part > $MAX_DOSE_ZONE.'/
       'DOSE_ZONE set to ',I4,' for now.'/
       'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
     ]
     IRM = IRM+1;"for outer region of this layer"
     ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',
     ' for outer regions'/' :',$);
     ;MINPUT (PHANTOM) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM); (2F15.0,2I5);
     IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
     IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
     ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM);(2F10.4, I5,I15);
     OUTPUT;(/' For outer regions:',$);
     ;$MED_INPUT(PHANTOM);
     MEDTEMP(IRM) = MED_INDEX;
     IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_PHANTOM, $MAX_DOSE_ZONE;
       (/'***ERROR IN CM ',I4,' (CHAMBER):'/
       'DOSE_ZONE # of annuli in top part > $MAX_DOSE_ZONE.'/
       'DOSE_ZONE set to ',I4,' for now.'/
       'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
     ]
     DO IM=2,N_TOP_PHANTOM[
        ZTEMP(IM)=ZTEMP(IM-1)+ZTHICK;
        RCYSTEMP(IM)=RCYSTEMP(1);
        IRM = IRM+1;"for inner region of this layer"
        ECUTTEMP(IRM)=ECUTTEMP(1);
        PCUTTEMP(IRM)=PCUTTEMP(1);
        DOSE_ZONETEMP(IRM)=DOSE_ZONETEMP(1);
        IREGION_TO_BITTEMP(IRM)=IREGION_TO_BIT(1);
        MEDTEMP(IRM) = MED(1);
        IRM = IRM+1;"for outer region of this layer"
        ECUTTEMP(IRM)=ECUTTEMP(2);
        PCUTTEMP(IRM)=PCUTTEMP(2);
        DOSE_ZONETEMP(IRM)=DOSE_ZONETEMP(2);
        IREGION_TO_BITTEMP(IRM)=IREGION_TO_BIT(2);
        MEDTEMP(IRM) = MED(2);
     ]
  ]"end of equal thickness, radius and media inputs"

  ELSE["for different thicknesses, radii or media"
     IF(N_TOP_PHANTOM>1)[
        OUTPUT N_TOP_PHANTOM;
        (/' The',I5,' layers have different inner radii, thickness,',
         /' and/or media');
     ]
     OUTPUT 1;(/' For layer',I4,' in top part:');
     OUTPUT ZTHICK,RCYSTEMP(IM);
     (/' ZTHICK & RCYL =',2F15.5);
     IRM=1;
     OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose)',
     ',IREGION_TO_BIT for inner region'/' :',$);
     ;MINPUT (PHANTOM) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM); (2F15.0,2I5);
     IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
     IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
     ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM); (2F10.4, I5,I15);
     OUTPUT;(/' For inner region:',$);
     ;$MED_INPUT(PHANTOM);
     "inputs character array MED_IN from unit 5, loops
     "through array MEDIA(24,I) to check if medium was previously input.
     "If so, sets MED_INDEX to index of previous medium.  If not,
     "increments NMED and sets MED_INDEX to NMED.
     MEDTEMP(IRM) = MED_INDEX; " medium of the planar slab
     IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_PHANTOM, $MAX_DOSE_ZONE;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
 'DOSE_ZONE # of inner cylinder in 1st layer, top part > $MAX_DOSE_ZONE.'/
 'DOSE_ZONE # set to ',I4,' for now.'/
    'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
     ]
     IRM = IRM+1;"for outer region of this layer"
     ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',
     ' for outer region'/' :',$);
     ;MINPUT (PHANTOM) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM); (2F15.0,2I5);
     IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
     IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
     ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IRM),
        IREGION_TO_BITTEMP(IRM); (2F10.4, I5,I15);
     OUTPUT;(' For outer region:',$);
     ;$MED_INPUT(PHANTOM);
     MEDTEMP(IRM) = MED_INDEX;
     IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_PHANTOM, $MAX_DOSE_ZONE;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
  'DOSE_ZONE # of outer annulus in 1st layer, top part > $MAX_DOSE_ZONE.'/
     'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
     ]
     DO IM=2, N_TOP_PHANTOM[
        OUTPUT IM;
        (/' FOR LAYER',I4,' IN TOP PART:');
        OUTPUT;
        (/' ZTHICK & RCYL:',$);
        ;MINPUT (PHANTOM) ZTHICK, RCYSTEMP(IM);(2F15.0);
        OUTPUT ZTHICK, RCYSTEMP(IM);(2F15.5);
        IF( RCYSTEMP(IM)<0.0 )[
          OUTPUT ICM_PHANTOM, IM-N_CHM_PHANTOM;
           (//'***ERROR IN CM ',I4,' (CHAMBER):'/
              'Radius of inner cylinder in layer ',I4,' of top part < 0.0'//);
          IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
        ]
        ELSEIF(RCYSTEMP(IM) > RMAX_CM(ICM_PHANTOM))[
          OUTPUT ICM_PHANTOM, IM-N_CHM_PHANTOM;
           (//'***WARNING IN CM ',I4,' (CHAMBER):'/
          'Radius of inner cylinder in layer ',I4,' of top part > RMAX_CM'//);
         WRITE(IOUTLIST,'(//''***WARNING IN CM '',
         I4,'' (CHAMBER):''/
         ''Radius of inner cylinder in layer '',
         I4,'' of top part > RMAX_CM''//)')
         ICM_PHANTOM, IM-N_CHM_PHANTOM;
        ]
        IF(ZTHICK<0.0)[
           OUTPUT ICM_PHANTOM, IM-N_CHM_PHANTOM;
          (//'***ERROR IN CM ',I4,' (CHAMBER):'/
             'Thickness of layer ',I4,' in top part < 0.0'//);
           IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
        ]
        ZTEMP(IM)=ZTEMP(IM-1)+ZTHICK;
        OUTPUT ZTHICK, RCYSTEMP(IM);(2F15.5);
        IRM = IRM+1;"inner region of this layer"
        OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose)',
                ',IREGION_TO_BIT for inner region'/' :',$);
        ;MINPUT (PHANTOM) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
                           IREGION_TO_BITTEMP(IRM); (2F15.0,2I5);
        IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
        IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
        ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IRM),
                              IREGION_TO_BITTEMP(IRM); (2F10.4, I5,I15);
        OUTPUT;(/' For inner region:',$);
        ;$MED_INPUT(PHANTOM);
        MEDTEMP(IRM) = MED_INDEX; " medium of the planar slab
        IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
           ;OUTPUT ICM_PHANTOM, IM,$MAX_DOSE_ZONE;
             (//'***ERROR IN CM ',I4,' (CHAMBER):'/
             'DOSE_ZONE # of inner cylinder in layer ',I4,
             ' of top part > $MAX_DOSE_ZONE.'/
             'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beamnrc_user_macros.mortran'//);
            DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
            IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
        ]
        IRM = IRM+1;"for outer region of this layer"
        ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',
                 ' for outer region'/' :',$);
        ;MINPUT (PHANTOM) ECUTTEMP(IRM),PCUTTEMP(IRM),DOSE_ZONETEMP(IRM),
                          IREGION_TO_BITTEMP(IRM); (2F15.0,2I5);
        IF(ECUTTEMP(IRM) < ECUTIN)[ECUTTEMP(IRM)=ECUTIN;]
        IF(PCUTTEMP(IRM) < PCUTIN)[PCUTTEMP(IRM)=PCUTIN;]
        ;OUTPUT ECUTTEMP(IRM),PCUTTEMP(IRM), DOSE_ZONETEMP(IRM),
                IREGION_TO_BITTEMP(IRM); (2F10.4, I5,I15);
        OUTPUT;(' For outer region:',$);
        ;$MED_INPUT(PHANTOM);
        MEDTEMP(IRM) = MED_INDEX;
        IF( DOSE_ZONETEMP(IRM) > $MAX_DOSE_ZONE )[
           ;OUTPUT ICM_PHANTOM, IM,$MAX_DOSE_ZONE;
             (//'***ERROR IN CM ',I4,' (CHAMBER):'/
             'DOSE_ZONE # of outer annulus in layer ',I4,
             ' of top part > $MAX_DOSE_ZONE.'/
             'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
            DOSE_ZONETEMP(IRM)=$MAX_DOSE_ZONE;
            IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
        ]
     ]"end of the do loop"
  ]"end of non-equal thickness, etc"
  THICK2=ZTEMP(N_TOP_PHANTOM)-ZMIN_PHANTOM;
  "the overall thickness for the top part"
]
ELSE[THICK2=0.0;]

"
"                    INPUTS FOR THE Central CHAMBER PART
"                    ===================================
"
OUTPUT; (/'          INPUTS FOR THE Central CHAMBER PART');

OUTPUT; (/' INPUT THE INNER RADIUS OF THE CHAMBER WALL (R_INNER),'
  /' THE OUTER RADIUS OF THE CHAMBER WALL (R_WALL), AND THE OUTER RADIUS,'
  /' OF THE GAP BETWEEN THE CHAMBER WALL AND CONTAINER WALL (R_OUTER),'
  /' ALL ON ONE LINE.'/' : ',$);
;MINPUT (PHANTOM) RCYS_PHANTOM(1, 1), RCYS_PHANTOM(1, 2),
    RCYS_PHANTOM(1, 3);(3F15.0);
OUTPUT RCYS_PHANTOM(1, 1), RCYS_PHANTOM(1, 2),
   RCYS_PHANTOM(1, 3); (3F13.5);
OUTPUT;
(/' Note that R_OUTER also defines the inner radius of the container.'
/' The outer radius of the container is defined by RMAX_CM.');
IF(RCYS_PHANTOM(1,1)<0.0)[
   OUTPUT ICM_PHANTOM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Inner radius of chamber wall < 0.0'//);
   IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
]
ELSEIF(RCYS_PHANTOM(1,1)>RMAX_CM(ICM_PHANTOM))[
   OUTPUT ICM_PHANTOM;
     (//'***WARNING IN CM ',I4,' (CHAMBER):'/
       'Inner radius of chamber wall > RMAX_CM'//);
   WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (CHAMBER):''/
         ''Inner radius of chamber wall > RMAX_CM''//)')
         ICM_PHANTOM;
]
IF(RCYS_PHANTOM(1,2)<0.0)[
   OUTPUT ICM_PHANTOM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Outer radius of chamber wall < 0.0'//);
   IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
]
ELSEIF(RCYS_PHANTOM(1,2)>RMAX_CM(ICM_PHANTOM))[
   OUTPUT ICM_PHANTOM;
     (//'***WARNING IN CM ',I4,' (CHAMBER):'/
       'Outer radius of chamber wall > RMAX_CM'//);
   WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (CHAMBER):''/
         ''Outer radius of chamber wall > RMAX_CM''//)')
         ICM_PHANTOM;
]
IF(RCYS_PHANTOM(1,3)<0.0)[
   OUTPUT ICM_PHANTOM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Inner radius of container wall < 0.0'//);
   IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
]
ELSEIF(RCYS_PHANTOM(1,3)>RMAX_CM(ICM_PHANTOM))[
   OUTPUT ICM_PHANTOM;
     (//'***WARNING IN CM ',I4,' (CHAMBER):'/
       'Inner radius of container wall > RMAX_CM'//);
   WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,'' (CHAMBER):''/
         ''Inner radius of container wall > RMAX_CM''//)')
         ICM_PHANTOM;
]
IF(RCYS_PHANTOM(1,2)<RCYS_PHANTOM(1,1))[
   OUTPUT ICM_PHANTOM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Outer radius of chamber wall < inner radius of chamber wall'//);
   IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
]
IF(RCYS_PHANTOM(1,3)<RCYS_PHANTOM(1,1))[
   OUTPUT ICM_PHANTOM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Inner radius of container wall < inner radius of chamber wall'//);
   IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
]
IF(RCYS_PHANTOM(1,3)<RCYS_PHANTOM(1,2))[
   OUTPUT ICM_PHANTOM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Inner radius of container wall < outer radius of chamber wall'//);
   IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
]

RCYS2_PHANTOM(1,1)=RCYS_PHANTOM(1,1)**2;
RCYS2_PHANTOM(1,2)=RCYS_PHANTOM(1,2)**2;
RCYS2_PHANTOM(1,3)=RCYS_PHANTOM(1,3)**2;

Z_PHANTOM(1)=ZMIN_PHANTOM+THICK2;  " THE TOP Z COORD OF THE CHAMBER "

IF(N_CHM_PHANTOM<0)["inputting for a group of layers"
  OUTPUT -N_CHM_PHANTOM;
  (/' THIS CHAMBER HAS ',I4,' GROUPS OF LAYERS WITH EQUAL THICKNESS (ZTHICK).'/
    ' FOR EACH GROUP, INPUT ZTHICK,I (on one line), WHERE I IS THE NUMBER OF'/
    ' LAYERS IN THE GROUP'/' : ',$);
  N_CHAM=0;
  DO II=1,-N_CHM_PHANTOM[
    OUTPUT II; (/' FOR LAYER GROUP ',I4,' :');
    ;MINPUT (PHANTOM) ZTHICK,I;(F15.0,I5);
    OUTPUT ZTHICK,I;(F15.5,I5);
    IF(ZTHICK<0.0)[
      OUTPUT ICM_PHANTOM;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'Layers in chamber part have thickness < 0.0'//);
      IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
    ]
    IF(I<=0)[
      OUTPUT ICM_PHANTOM;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'Cannot have a group with <= 0 layers'//);
      IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
    ]
    N_CHAM=N_CHAM+I;
    IF(N_CHAM+N_TOP_PHANTOM+N_BOT_PHANTOM > $MAX_N_PHANTOM-1)[
       OUTPUT ICM_PHANTOM;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
       'N-CHAM + N-TOP + N-BOT > max. # of layers allowed.'/);
       IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
    ]
    OUTPUT N_CHAM-I+1,N_CHAM,ZTHICK;
     (/' LAYERS ',I4,' - ',I4,' HAVE EQUAL THICKNESS OF',F15.5,' cm.'/);
    Z_PHANTOM(N_CHAM-I+2)=Z_PHANTOM(N_CHAM-I+1)+ZTHICK;
    DO IM=N_CHAM-I+2,N_CHAM[
      Z_PHANTOM(IM+1)=Z_PHANTOM(IM)+ZTHICK;
    ]
  ]"end of do loop to input thicknesses"
  IM=1;
  IRA = IRSTART_PHANTOM;"for the chamber part, one region per layer"
  N_CHM_PHANTOM=N_CHAM;
  N_PHANTOM = N_CHM_PHANTOM+3+ 2*N_TOP_PHANTOM+2*N_BOT_PHANTOM;
  OUTPUT N_CHM_PHANTOM;
   ;(' If a dose zone is input, it is the first of',I4,' in sequence');
   OUTPUT;(' ECUT,PCUT,INITIAL DOSE ZONE(0=>do not score dose),',
    ' IREGION_TO_BIT'/
    ' FOR ALL LAYERS: ',$);
   ;MINPUT (PHANTOM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
   (2F15.0,2I5);
   IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
   IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
   ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA);(2F10.4,I5,I15);
   OUTPUT;(' For all layers :',$);
   ;$MED_INPUT(PHANTOM);
   MED(IRA) = MED_INDEX; " medium of the planar slab
   IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
      ;OUTPUT ICM_PHANTOM,$MAX_DOSE_ZONE;
        (//'***ERROR IN CM ',I4,' (CHAMBER):'/
     'DOSE_ZONE # of layer 1 of chamber part > $MAX_DOSE_ZONE.'/
     'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
      DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
      IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
   ]
   ELSEIF(DOSE_ZONE(IRA).NE.0)[
      IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
      ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
      ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
   ]
   DO IM=2, N_CHM_PHANTOM[
      IRA = IRA+1;
      ECUT(IRA)=ECUT(IRSTART_PHANTOM);
      PCUT(IRA)=PCUT(IRSTART_PHANTOM);
      DOSE_ZONE(IRA)=DOSE_ZONE(IRSTART_PHANTOM) + (IM-1);
      IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
         ;OUTPUT ICM_PHANTOM,IM,$MAX_DOSE_ZONE;
           (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'DOSE_ZONE # of layer ',I4,' of chamber part > $MAX_DOSE_ZONE.'/
          'DOSE_ZONE # set to ',I4,' for now.'/
   'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
                DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
          IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
      ]
      ELSEIF(DOSE_ZONE(IRA).NE.0)[
         IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
         ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
         ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
      ]
      IREGION_TO_BIT(IRA)=IREGION_TO_BIT(IRSTART_PHANTOM);
      MED(IRA) = MED(IRSTART_PHANTOM);
   ]
]
ELSE[
  OUTPUT; (/' INPUT THICKNESS FOR EACH LAYER WITHIN THE CHAMBER'/
  ' FOR LAYERS OF EQUAL THICKNESS (ZTHICK) AND MEDIUM, '/
  ' INPUT ZTHICK,N-CHAM (in one line)'
  /' OTHERWISE, INPUT ZTHICK FOR EACH LAYER STARTING FROM 1ST LAYER'/' : ',$);
  ;MINPUT (PHANTOM) ZTHICK,I;(F15.0,I5);
  OUTPUT ZTHICK,I;(F15.5,I5);
  IF(I = N_CHM_PHANTOM)[
    IF(ZTHICK<0.0)[
       OUTPUT ICM_PHANTOM;
        (//'***ERROR IN CM ',I4,' (CHAMBER):'/
           'Layers in chamber part have thickness < 0.0'//);
       IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
    ]
    OUTPUT I,ZTHICK;
     (/' ALL THE ',I5,' LAYERS HAVE EQUAL THICKNESS OF',F15.5,' cm.'/);
    IRA = IRSTART_PHANTOM;"for the chamber part, one region per layer"
    IM=1;
    OUTPUT I;
     ;(' If a dose zone is input, it is the first of',I4,' in sequence');
    OUTPUT;(' ECUT,PCUT,INITIAL DOSE ZONE(0=>do not score dose),',
     ' IREGION_TO_BIT'/
     ' FOR THE LAYERS: ',$);
    ;MINPUT (PHANTOM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
    (2F15.0,2I5);
    IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
    IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
    ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
       IREGION_TO_BIT(IRA);(2F10.4,I5,I15);
    OUTPUT;(' For all layers :',$);
    ;$MED_INPUT(PHANTOM);
    MED(IRA) = MED_INDEX; " medium of the planar slab
    IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_PHANTOM,$MAX_DOSE_ZONE;
         (//'***ERROR IN CM ',I4,' (CHAMBER):'/
      'DOSE_ZONE # of layer 1 of chamber part > $MAX_DOSE_ZONE.'/
      'DOSE_ZONE # set to ',I4,' for now.'/
      'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
    ]
    ELSEIF(DOSE_ZONE(IRA).NE.0)[
       IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
       ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
       ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
    ]
    Z_PHANTOM(2)=Z_PHANTOM(1)+ZTHICK;
    DO IM=2, N_CHM_PHANTOM[
       Z_PHANTOM(IM+1)=Z_PHANTOM(IM)+ZTHICK;
       IRA = IRA+1;
       ECUT(IRA)=ECUT(IRSTART_PHANTOM);
       PCUT(IRA)=PCUT(IRSTART_PHANTOM);
       DOSE_ZONE(IRA)=DOSE_ZONE(IRSTART_PHANTOM) + (IM-1);
       IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
          ;OUTPUT ICM_PHANTOM,IM,$MAX_DOSE_ZONE;
            (//'***ERROR IN CM ',I4,' (CHAMBER):'/
           'DOSE_ZONE # of layer ',I4,' of chamber part > $MAX_DOSE_ZONE.'/
           'DOSE_ZONE # set to ',I4,' for now.'/
    'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
           DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
           IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
       ]
       ELSEIF(DOSE_ZONE(IRA).NE.0)[
          IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
          ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
          ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
       ]
       IREGION_TO_BIT(IRA)=IREGION_TO_BIT(IRSTART_PHANTOM);
       MED(IRA) = MED(IRSTART_PHANTOM);
    ]
  ]
  ELSE[
    IF(N_CHM_PHANTOM>1)[
       OUTPUT N_CHM_PHANTOM;
       (/' THE',I4,' LAYERS HAVE DIFFERENT ZTHICK AND/OR MEDIA.');
    ]
    OUTPUT 1;
    (/' FOR LAYER',I4,' IN THE CHAMBER:');
    OUTPUT ZTHICK; (/' ZTHICK =',F15.5 );
    IF(ZTHICK<0.0)[
       OUTPUT ICM_PHANTOM;
         (//'***ERROR IN CM ',I4,' (CHAMBER):'/
            'Thickness of layer 1 in chamber part < 0.0'//);
       IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
    ]
    IRA = IRSTART_PHANTOM;"for the chamber part, one region per layer"
    IM=1;
    OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT'/' :',$);
    ;MINPUT (PHANTOM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
    (2F15.0,2I5);
    IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
    IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
    ;OUTPUT ECUT(IRA),PCUT(IRA),
          DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);(2F10.4,I5,I15);
    OUTPUT;(' For this layer :');
    ;$MED_INPUT(PHANTOM);
    MED(IRA) = MED_INDEX;
    IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_PHANTOM,$MAX_DOSE_ZONE;
         (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'DOSE_ZONE # of layer 1 of chamber part > $MAX_DOSE_ZONE.'/
          'DOSE_ZONE # set to ',I4,' for now.'/
    'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
        DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
        IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
    ]
    ELSEIF(DOSE_ZONE(IRA).NE.0)[
       IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
       ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
       ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
    ]
    Z_PHANTOM(2)=Z_PHANTOM(1)+ZTHICK;
    DO IM=2, N_CHM_PHANTOM[
       OUTPUT IM;
       (/' FOR LAYER',I4,' IN THE CHAMBER:');
       OUTPUT; (/' ZTHICK: ',$ );
       ;MINPUT (PHANTOM) ZTHICK;(F15.0);
       OUTPUT ZTHICK;(F15.5);
       IF(ZTHICK<0.0)[
          OUTPUT ICM_PHANTOM, IM;
           (//'***ERROR IN CM ',I4,' (CHAMBER):'/
            'Thickness of layer ',I4,' in chamber part < 0.0'//);
          IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
       ]
       Z_PHANTOM(IM+1)=Z_PHANTOM(IM)+ZTHICK;
       IRA = IRA+1;
       OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT'/
               ':',$);
       ;MINPUT (PHANTOM)
        ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
       (2F15.0,2I5);
       IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
       IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
       ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA), IREGION_TO_BIT(IRA);
          (2F10.4,I5,I15);
       OUTPUT;(' For this layer :',$);
       ;$MED_INPUT(PHANTOM);
       MED(IRA) = MED_INDEX; " medium of the planar slab
       IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
         ;OUTPUT ICM_PHANTOM,IM,$MAX_DOSE_ZONE;
         (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'DOSE_ZONE # of layer ',I4,' of chamber part > $MAX_DOSE_ZONE.'/
          'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
          DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
          IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
       ]
       ELSEIF(DOSE_ZONE(IRA).NE.0)[
          IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
          ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
          ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
       ]
    ]"end of do loop"
  ] "end of else"
]"end of else"

DO I=1, N_CHM_PHANTOM[
     RCYS_PHANTOM(I,1)=RCYS_PHANTOM(1,1);
     RCYS_PHANTOM(I,2)=RCYS_PHANTOM(1,2);
     RCYS_PHANTOM(I,3)=RCYS_PHANTOM(1,3);
     RCYS2_PHANTOM(I,1)=RCYS2_PHANTOM(1,1);
     RCYS2_PHANTOM(I,2)=RCYS2_PHANTOM(1,2);
     RCYS2_PHANTOM(I,3)=RCYS2_PHANTOM(1,3);
]



THICK1=Z_PHANTOM(N_CHM_PHANTOM+1)-Z_PHANTOM(1);
"the overall thickness for the monitor chamber part"

DO IR_PHANTOM = 1+N_CHM_PHANTOM, N_CHM_PHANTOM +3[
   "Parameters for chamber wall, gap and container wall regions"
   IRA = IRA+1;
   IF(IR_PHANTOM.EQ.1+N_CHM_PHANTOM)[
      OUTPUT;(/' FOR THE CHAMBER WALL:');
   ]
   ELSEIF(IR_PHANTOM.EQ.2+N_CHM_PHANTOM)[
      OUTPUT;(/' FOR THE GAP BETWEEN THE CHAMBER WALL AND THE'/
               'CONTAINER WALL:');
   ]
   ELSE[
      OUTPUT;(/' FOR THE CONTAINER WALL:');
   ]
   OUTPUT;(/' ECUT,PCUT, DOSE ZONE(0=>do not score dose),IREGION_TO_BIT'/
            ' : ',$);
   ;MINPUT (PHANTOM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
   IREGION_TO_BIT(IRA); (2F15.0,2I5);
   IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
   IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
   OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
     IREGION_TO_BIT(IRA); (2F10.4,I5,I15);
   OUTPUT;(' For this region: ',$);
   ;$MED_INPUT(PHANTOM);
   MED(IRA) = MED_INDEX;
   IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
     ;OUTPUT ICM_PHANTOM,$MAX_DOSE_ZONE;
        (//'***ERROR IN CM ',I4,' (CHAMBER):'/
 'DOSE_ZONE # chamber wall, gap, and/or container wall > $MAX_DOSE_ZONE.'/
      'DOSE_ZONE # set to ',I4,' for now.'/
  'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
     DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
     IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
   ]
   ELSEIF(DOSE_ZONE(IRA).NE.0)[
      IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
      ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
      ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
   ]
]"end of chamber wall, gap and container wall inputs"

IRM=0;
DO I=1,N_TOP_PHANTOM[ "put here because we need to know N_CHM_PHANTOM"
  IM=N_CHM_PHANTOM+I;"starting # for the top part"
  RCYS_PHANTOM(IM, 1)=RCYSTEMP(I);
  RCYS2_PHANTOM(IM,1)=RCYS_PHANTOM(IM,1)**2;
  Z_PHANTOM(IM+1)=ZTEMP(I);
  IRA = IRA+1;
  IRM=IRM+1;
  IR_PHANTOM = IR_PHANTOM+1;
  ECUT(IRA)=ECUTTEMP(IRM);
  PCUT(IRA)=PCUTTEMP(IRM);
  DOSE_ZONE(IRA)=DOSE_ZONETEMP(IRM);
  IREGION_TO_BIT(IRA)=IREGION_TO_BITTEMP(IRM);
  MED(IRA)=MEDTEMP(IRM);
  IF(DOSE_ZONE(IRA).NE.0)[
        IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
        ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
        ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
  ]
  IRA = IRA+1;"for outer region of this layer"
  IR_PHANTOM =IR_PHANTOM +1;
  IRM=IRM+1;
  ECUT(IRA)=ECUTTEMP(IRM);
  PCUT(IRA)=PCUTTEMP(IRM);
  DOSE_ZONE(IRA)=DOSE_ZONETEMP(IRM);
  IREGION_TO_BIT(IRA)=IREGION_TO_BITTEMP(IRM);
  MED(IRA)=MEDTEMP(IRM);
  IF(DOSE_ZONE(IRA).NE.0)[
        IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
        ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
        ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
  ]
]

THICK3=0.;

IF(N_BOT_PHANTOM~=0)[
   OUTPUT N_BOT_PHANTOM;
   (/' INPUTS FOR THE BOTTOM PART (ALTOGETHER ',I4,' LAYERS):');
   OUTPUT;(/' SIMILAR TO THE TOP PART, EACH LAYER OF THE BOTTOM PART'/
   ' IS DIVIDED INTO AN INNER DISC-SHAPED REGION AND AN OUTER ANNULAR'/
   ' REGION BY THE INNER RADIUS, RCYL.'/
   ' FOR LAYERS OF EQUAL THICKNESS, INNER RADIUS & MEDIA,'/
   ' INPUT ZTHICK,RCYL & N-BOT (2F15.0,I5, in one line)'/
   ' OTHERWISE, INPUT ZTHICK & RCYL FOR EACH LAYER STARTING FROM 1ST',
   ' LAYER'/
   ' (2F15.0)',$);
   IM=N_CHM_PHANTOM+N_TOP_PHANTOM+1;"starting # for the bottom part"
   ;MINPUT (PHANTOM) ZTHICK, RCYS_PHANTOM(IM, 1),JM;(2F15.0,I5);
   OUTPUT ZTHICK, RCYS_PHANTOM(IM, 1),JM;(2F15.5,I5);
   IF(ZTHICK<0.0)[
     OUTPUT ICM_PHANTOM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'Thickness of layer 1 in bottom part < 0.0.'//);
     IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
   ]
   IF(RCYS_PHANTOM(IM, 1)<0.0)[
     OUTPUT ICM_PHANTOM;
      (//'***ERROR IN CM ',I4,' (CHAMBER):'/
         'RCYS of layer 1, bottom part < 0.0'//);
     IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
   ]
   ELSEIF(RCYS_PHANTOM(IM,1) > RMAX_CM(ICM_PHANTOM))[
     OUTPUT ICM_PHANTOM;
      (//'***WARNING IN CM ',I4,' (CHAMBER):'/
         'RCYS of layer 1, bottom part > RMAX_CM'//);
     WRITE(IOUTLIST,'(//''***WARNING IN CM '',I4,
       '' (CHAMBER):''/
       ''RCYS of layer 1, bottom part > RMAX_CM''//)')
        ICM_PHANTOM;
   ]
   RCYS2_PHANTOM(IM,1)=RCYS_PHANTOM(IM,1)**2;
   Z_PHANTOM(IM+1)=Z_PHANTOM(N_CHM_PHANTOM+1)+ZTHICK;

  IF(JM.EQ.N_BOT_PHANTOM)["for equal thickness and radius"
     IRA = IRSTART_PHANTOM+N_CHM_PHANTOM+3+2*N_TOP_PHANTOM;
     IR_PHANTOM = N_CHM_PHANTOM+3+2*N_TOP_PHANTOM+1;
     OUTPUT N_BOT_PHANTOM;
     (/' ALL THE',I5,' LAYERS HAVE THE SAME THICKNESS & RADIUS'/);
     OUTPUT ZTHICK, RCYS_PHANTOM(IM,1);
     (/' FOR ALL LAYERS, ZTHICK, RCYL = ',2F15.5);
     OUTPUT;(/
      ' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',/
      ' for inner regions'/
       ' : ',$);
     ;MINPUT (PHANTOM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (2F15.0,2I5);
      IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
      IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
      OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
      OUTPUT;(' For inner region :',$);
      ;$MED_INPUT(PHANTOM);
      MED(IRA) = MED_INDEX;
      IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
        ;OUTPUT ICM_PHANTOM, $MAX_DOSE_ZONE;
        (/'***ERROR IN CM ',I4,' (CHAMBER):'/
        'DOSE_ZONE # of inner cylinders in bottom part > $MAX_DOSE_ZONE.'/
        'DOSE_ZONE set to ',I4,' for now.'/
        'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
        DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
        IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
      ]
      ELSEIF(DOSE_ZONE(IRA).NE.0)[
         IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
         ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
         ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
      ]
      IRA=IRA+1;
      IR_PHANTOM=IR_PHANTOM+1;
      ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',
      ' for outer regions'/' :',$);
      ;MINPUT (PHANTOM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (2F15.0,2I5);
      IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
      IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
      ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
      OUTPUT;(' For outer region :',$);
      ;$MED_INPUT(PHANTOM);
      MED(IRA) = MED_INDEX;
      IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
        ;OUTPUT ICM_PHANTOM, $MAX_DOSE_ZONE;
       (/'***ERROR IN CM ',I4,' (CHAMBER):'/
       'DOSE_ZONE # of annuli in bottom part > $MAX_DOSE_ZONE.'/
       'DOSE_ZONE set to ',I4,' for now.'/
       'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
        DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
        IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
      ]
      ELSEIF(DOSE_ZONE(IRA).NE.0)[
         IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
         ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
         ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
      ]
      DO IM=N_CHM_PHANTOM+N_TOP_PHANTOM+2,
          N_CHM_PHANTOM+N_TOP_PHANTOM+N_BOT_PHANTOM[
        Z_PHANTOM(IM+1)=Z_PHANTOM(IM)+ZTHICK;
        RCYS2_PHANTOM(IM,1)=
        RCYS2_PHANTOM(N_CHM_PHANTOM+N_TOP_PHANTOM+1,1);
        IRA = IRA+1;"for inner region"
        ECUT(IRA)=ECUT(IRSTART_PHANTOM+N_CHM_PHANTOM+3+2*N_TOP_PHANTOM);
        PCUT(IRA)=PCUT(IRSTART_PHANTOM+N_CHM_PHANTOM+3+2*N_TOP_PHANTOM);
        DOSE_ZONE(IRA)=
             DOSE_ZONE(IRSTART_PHANTOM+N_CHM_PHANTOM+3+2*N_TOP_PHANTOM);
        IF(DOSE_ZONE(IRA).NE.0)[
           IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
           ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
           ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
        ]
        MED(IRA)=MED(IRSTART_PHANTOM+N_CHM_PHANTOM+3+2*N_TOP_PHANTOM);
        IRA = IRA+1;"for outer region"
        ECUT(IRA)=ECUT(IRSTART_PHANTOM+N_CHM_PHANTOM+4+2*N_TOP_PHANTOM);
        PCUT(IRA)=PCUT(IRSTART_PHANTOM+N_CHM_PHANTOM+4+2*N_TOP_PHANTOM);
        DOSE_ZONE(IRA)=
           DOSE_ZONE(IRSTART_PHANTOM+N_CHM_PHANTOM+4+2*N_TOP_PHANTOM);
        IF(DOSE_ZONE(IRA).NE.0)[
           IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
           ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
           ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
        ]
        MED(IRA)=MED(IRSTART_PHANTOM+N_CHM_PHANTOM+4+2*N_TOP_PHANTOM);
      ]
      THICK3=ZTHICK*FLOAT(N_BOT_PHANTOM);
  ]"end of equal thickness and radius input"
  ELSE["for different thicknesses, radii or media"
     IRA = IRSTART_PHANTOM+N_CHM_PHANTOM+3+2*N_TOP_PHANTOM;
     IR_PHANTOM = N_CHM_PHANTOM+3+2*N_TOP_PHANTOM+1;
     IF(N_BOT_PHANTOM>1)[ OUTPUT N_BOT_PHANTOM;
         (/' THE',I4, ' LAYERS IN THE BOTTOM PART HAVE DIFFERENT'/
            ' INNER RADII, THICKNESS, AND/OR MEDIA.');
     ]
     OUTPUT 1;(/' FOR LAYER',I4,' IN BOTTOM PART:');
     OUTPUT ZTHICK,RCYS_PHANTOM(IM, 1);
     (/' ZTHICK, RCYL =',2F15.5);
     THICK3=ZTHICK;
     OUTPUT;(/' ECUT,PCUT,DOSE ZONE(0=>do not score dose),'/
            ' IREGION_TO_BIT for inner region'/
            ' : ',$);
     ;MINPUT (PHANTOM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (2F15.0,2I5);
     IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
     IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
     ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
     OUTPUT;(' For inner region :',$);
     ;$MED_INPUT(PHANTOM);
     MED(IRA) = MED_INDEX;
     IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_PHANTOM, $MAX_DOSE_ZONE;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
  'DOSE_ZONE # of inner cylinder in 1st layer, bottom part > $MAX_DOSE_ZONE.'/
    'DOSE_ZONE # set to ',I4,' for now.'/
    'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
     ]
     ELSEIF(DOSE_ZONE(IRA).NE.0)[
         IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
         ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
         ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
     ]
     IRA = IRA+1;"for outer region of this layer"
     IR_PHANTOM =IR_PHANTOM +1;
     ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),IREGION_TO_BIT',
     ' for outer region'/' :',$);
     ;MINPUT (PHANTOM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
      IREGION_TO_BIT(IRA); (2F15.0,2I5);
     IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
     IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
     ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
       IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
     OUTPUT;(' For outer region :',$);
     ;$MED_INPUT(PHANTOM);
     MED(IRA) = MED_INDEX;
     IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_PHANTOM, $MAX_DOSE_ZONE;
       (//'***ERROR IN CM ',I4,' (CHAMBER):'/
  'DOSE_ZONE # of outer annulus in 1st layer, bottom part > $MAX_DOSE_ZONE.'/
        'DOSE_ZONE # set to ',I4,' for now.'/
     'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
       DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
       IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
     ]
     ELSEIF(DOSE_ZONE(IRA).NE.0)[
         IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
         ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
         ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
     ]
     DO IM=N_CHM_PHANTOM+N_TOP_PHANTOM+2,
            N_CHM_PHANTOM+N_TOP_PHANTOM+ N_BOT_PHANTOM[
        OUTPUT IM-N_CHM_PHANTOM-N_TOP_PHANTOM;
        (/' FOR LAYER',I4,' OF THE BOTTOM PART:');
        OUTPUT;
        (/' INPUT ZTHICK & RADIUS:',$);
        ;MINPUT (PHANTOM) ZTHICK, RCYS_PHANTOM(IM, 1);(2F15.0);
        OUTPUT ZTHICK, RCYS_PHANTOM(IM, 1);(2F12.5);
        IF(ZTHICK<0.0)[
           OUTPUT ICM_PHANTOM, IM-N_CHM_PHANTOM-N_TOP_PHANTOM;
          (//'***ERROR IN CM ',I4,' (CHAMBER):'/
             'Thickness of layer ',I4,' in bottom part < 0.0'//);
           IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
        ]
        Z_PHANTOM(IM+1)=Z_PHANTOM(IM)+ZTHICK;THICK3=THICK3+ZTHICK;
        IF( RCYS_PHANTOM(IM,1)<0.0 )[
          OUTPUT ICM_PHANTOM, IM-N_CHM_PHANTOM-N_TOP_PHANTOM;
           (//'***ERROR IN CM ',I4,' (CHAMBER):'/
            'Radius of inner cylinder in layer ',I4,' of bottom part < 0.0'//);
          IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
        ]
        ELSEIF(RCYS_PHANTOM(IM,1) > RMAX_CM(ICM_PHANTOM))[
          OUTPUT ICM_PHANTOM, IM-N_CHM_PHANTOM-N_TOP_PHANTOM;
          (//'***WARNING IN CM ',I4,' (CHAMBER):'/
         'Radius of inner cylinder in layer ',I4,' of bottom part > RMAX_CM'//);
          WRITE(IOUTLIST,'(//''***WARNING IN CM '',
          I4,'' (CHAMBER):''/
          ''Radius of inner cylinder in layer '',
          I4,'' of bottom part > RMAX_CM''//)')
          ICM_PHANTOM, IM-N_CHM_PHANTOM-N_TOP_PHANTOM;
        ]
        RCYS2_PHANTOM(IM,1)=RCYS_PHANTOM(IM,1)**2;
        "note: each layer has 2 regions in this part"
        IRA = IRA+1;"for inner region of this layer"
        IR_PHANTOM =IR_PHANTOM +1;
        ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),',
        'IREGION_TO_BIT for inner region'/' :',$);
        ;MINPUT (PHANTOM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
           IREGION_TO_BIT(IRA); (2F15.0,2I5);
        IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
        IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
        ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
          IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
        OUTPUT;(' For inner region :',$);
        ;$MED_INPUT(PHANTOM);
        MED(IRA) = MED_INDEX;
        IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_PHANTOM, IM-N_CHM_PHANTOM-N_TOP_PHANTOM,$MAX_DOSE_ZONE;
         (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'DOSE_ZONE # of inner cylinder in layer ',I4,
          ' of bottom part > $MAX_DOSE_ZONE.'/
          'DOSE_ZONE # set to ',I4,' for now.'/
  'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
            DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
            IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
        ]
        ELSEIF(DOSE_ZONE(IRA).NE.0)[
           IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
           ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
           ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
        ]
        IRA = IRA+1;"for outer region of this layer"
        IR_PHANTOM =IR_PHANTOM +1;
        ;OUTPUT;(' ECUT,PCUT,DOSE ZONE(0=>do not score dose),',
        'IREGION_TO_BIT for outer region'/' :',$);
        ;MINPUT (PHANTOM) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
           IREGION_TO_BIT(IRA); (2F15.0,2I5);
        IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
        IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
        ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
            IREGION_TO_BIT(IRA);  (2F10.4,I5,I15);
        OUTPUT;(' For outer region :',$);
        ;$MED_INPUT(PHANTOM);
        MED(IRA) = MED_INDEX;
        IF( DOSE_ZONE(IRA) > $MAX_DOSE_ZONE )[
       ;OUTPUT ICM_PHANTOM, IM-N_CHM_PHANTOM-N_TOP_PHANTOM,$MAX_DOSE_ZONE;
          (//'***ERROR IN CM ',I4,' (CHAMBER):'/
          'DOSE_ZONE # of outer annulus in layer ',I4,
          ' of bottom part > $MAX_DOSE_ZONE.'/
          'DOSE_ZONE # set to ',I4,' for now.'/
   'Probably need to change $MAX_DOSE_ZONE in beam_user_macros.mortran'//);
           DOSE_ZONE(IRA)=$MAX_DOSE_ZONE;
           IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
        ]
        ELSEIF(DOSE_ZONE(IRA).NE.0)[
           IPLOTFLAG=1;"set flag: CHAMBER is used for dose scoring"
           ZPLOTCHM(DOSE_ZONE(IRA))=Z_PHANTOM(IM);
           ZPLOTCHM(DOSE_ZONE(IRA)+1)=Z_PHANTOM(IM+1);
        ]
     ]"end of do loop"
  ]"end of non-equal thickness, etc."
]"end of bottom part"


ZTHICK_PHANTOM=THICK1+THICK2+THICK3;"total thickness of the component module"
ZMAX_PHANTOM=ZMIN_PHANTOM+ZTHICK_PHANTOM;
"
"  parameter definition
"  ====================
"
"establish the front surface of this CM, if it is the first module,
"Z_min_CM(1) will be given by the user in BEAM general inputs.

ZFRONT_PHANTOM = Z_min_CM(ICM_PHANTOM);
"
"establish start of next CM
"
Z_min_CM(ICM_PHANTOM+1) = ZMAX_PHANTOM;

"
"
"  set up the air gap, if present
"  =========================================
"
"  The air gap has the highest region number in the CM, even though it is at
"  the top of the component module.  This is to allow the assignment of region
"  numbers on input of the parameters of each local region (mainly to assign the
"  medium number of the region).  The air gap is then assigned after all of the
"  CM parameters have been input.
"
"note that if this is the first CM (ICM_$chamber=1) then the gap thickness
"Z_gap_THICK(ICM_$chamber) = ZMIN_PHANTOM - Z_min_CM(1),
"which is used as a flag whether there is an air gap.

Z_gap_THICK(ICM_PHANTOM) = ZMIN_PHANTOM - Z_min_CM(ICM_PHANTOM);

IF (Z_gap_THICK(ICM_PHANTOM) = 0.0)[
   Z_gap_THICK(ICM_PHANTOM) = 0.;
   N_GAP_PHANTOM = 0; "no air gap is needed for this CM
]
ELSE[
   N_GAP_PHANTOM = 1; "this CM has an air gap"
   OUTPUT Z_min_CM(ICM_PHANTOM),ZMIN_PHANTOM;
   (/' THERE WILL BE AN AIR GAP SET UP BETWEEN Z=',F8.4,' AND Z=',F8.4/);
   IRA = IRSTART_PHANTOM+N_PHANTOM; "absolute region number of air gap
   MED(IRA) = AIR_INDEX; "medium is air
   ECUT(IRA)=ECUTIN;
   PCUT(IRA)=PCUTIN;
   ESAVE(IRA)=ESAVE_GLOBAL;
   ECUTRR(IRA)=ECUT(IRA);
]

"
"  set up region numbers
"  =====================
"
"  This CM has N_PHANTOM+N_GAP_$chamber regions
"
;
IREND_PHANTOM = (IRSTART_PHANTOM -1) +N_PHANTOM+N_GAP_PHANTOM;
       "Index of last region"
NREG = NREG+N_PHANTOM+N_GAP_PHANTOM;
       "Total number of regions in full geometry up"
       "to and including this CM"
IF (NREG <= $MXREG)[
   IR_start_CM(ICM_PHANTOM+1) = IREND_PHANTOM+1;
   "It has not exceeded maximum region number. "
   "Index of first region in next CM:"
]
ELSE[
   OUTPUT ICM_PHANTOM,NREG,$MXREG;
   (//'***ERROR IN CM ',I4,' (CHAMBER):'/
      I4,' regions requested, only ',I4,' available'//);
   IERR_GEOM(ICM_PHANTOM)=IERR_GEOM(ICM_PHANTOM)+1;
]

"  Establish CM boundary
"  =====================
RMAX_CM_FLAG(ICM_PHANTOM) = 1; "put a boundary about CM"
"
"  Establish dose-scoring zones and bit setting for each region
"  ============================================================
"
IRA = IRSTART_PHANTOM-1; "absolute region number"
DO IR_PHANTOM=1,N_PHANTOM["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones"
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE);"Number of dose zones"
   IF(NDOSE_ZONE>$MAX_DOSE_ZONE)[
      OUTPUT;(///' IN CHAMBER, NDOSE_ZONE OUT OF RANGE!!!'///);
      STOP;
   ]
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT); " current maxmum"
   "charged particle range rejection parameters"
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are"
                            "considered for range rejection"
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region"
   E_min_out(ICM_PHANTOM)=ECUT(IRA); "Minimum energy on exit from CM"
] "end of loop over IR_PHANTOM"

"Set up minimum thicknesses for range rejection purposes. In this case "
"we check the last 5 slabs. If we ever need more than 5 slabs, we should"
"extend this or do something fancy like group similar materials."
"Only do this for the central ion chamber part "

I=1; J=1;        " J is index for Z_min_thick , I for layer index "
LOOP[
   Z_min_thick(ICM,J)=0.0;     " init. "
   IRA = I + IRSTART_PHANTOM-1;   "absolute region"
   IF( MED(IRA)~=1) [" AIR WILL BE COUNTED AFTERWARDS "
       MED_min_thick(ICM, J)=MED(IRA);
       Z_min_thick(ICM,J) = Z_PHANTOM(I+1)-Z_PHANTOM(I);
       " first assignment "
   ]
   DO IR_PHANTOM=I+1, N_CHM_PHANTOM [
      "loop through all the layers, if same med added together"
       IRA = IR_PHANTOM + IRSTART_PHANTOM-1;   "absolute region"
       IF( MED(IRA)=MED_min_thick(ICM, J) )[
           Z_min_thick(ICM,J) =Z_min_thick(ICM,J)+
           (Z_PHANTOM(IR_PHANTOM+1)-Z_PHANTOM(IR_PHANTOM-1+1));
       ]
   ]     " end of the do loop "
   " now figure out where the next index I(layer) begins with "
   DO IR_PHANTOM=I+1, N_CHM_PHANTOM[
       IRA = IR_PHANTOM + IRSTART_PHANTOM-1;   "absolute region"
       III=0;
       DO II=J, 1, -1[
         IF(MED(IRA)~=MED_min_thick(ICM, II) & MED(IRA)~=1)[ III=III+1; ]
       ]
       IF( III=J )  " the next med is different from all the before "
         [ I=IR_PHANTOM; J=J+1; EXIT; ]   " keep the i as the next index "
                                         " J increases by one  "
   ]
]WHILE( I<=N_CHM_PHANTOM & J<=5 & IR_PHANTOM<=N_CHM_PHANTOM );

IF(J < 5  )[  "some not used"
    DO I=1, N_TOP_PHANTOM+N_BOT_PHANTOM[
       IRA = N_CHM_PHANTOM+3+2*(I-1)+1+IRSTART_PHANTOM-1;
       "absolute region"
       IF( RCYS_PHANTOM(N_CHM_PHANTOM+I, 1) >= RMAX_CM(ICM_PHANTOM)
          & MED(IRA)~=1 )[
           IF(J<5)[ J=J+1; ]
           ELSE[ EXIT; ]
           MED_min_thick(ICM, J)=MED(IRA);
           IF(I=1 & N_TOP_PHANTOM~=0 )[
              Z_min_thick(ICM,J) = (  Z_PHANTOM(I+N_CHM_PHANTOM+1)
                                       -ZMIN_PHANTOM);
           ]
           ELSEIF(I=N_TOP_PHANTOM+1)[
              Z_min_thick(ICM,J) = (  Z_PHANTOM(I+N_CHM_PHANTOM+1)
                                       -Z_PHANTOM(N_CHM_PHANTOM+1) );
           ]
           ELSE[
              Z_min_thick(ICM,J) = ( Z_PHANTOM(I+N_CHM_PHANTOM+1)
                                      -Z_PHANTOM(I-1+N_CHM_PHANTOM+1) );
           ]
       ]
    ]     " end of the do loop "
]

IF(J < 5)[  "some not used"
    Zminthick=0.0;
    DO I=1, J [  Zminthick=Zminthick+Z_min_thick(ICM, I); ]
    J=J+1;
    Z_min_thick(ICM, J)=ZTHICK_PHANTOM+Z_gap_thick(ICM_PHANTOM)-Zminthick;
    MED_min_thick(ICM,J) = AIR_INDEX; "AIR_INDEX is 0 or 1"
    DO I = J+1,5[
        Z_min_thick(ICM,I) = 0.0;
        MED_min_thick(ICM,I) = 0;
    ]"end of do loop on I"
]"end J < 5 case"

OUTPUT; (/' MRNGE: ENTER 1 to estimate thickness of PHANTOM for ECUTRR'/
          ' calculations in automated range rejection; otherwise, do'/
          ' not calculate ECUTRR',$);
;MINPUT (PHANTOM) MRNGE; (I5);
OUTPUT MRNGE;(I5);
OUTPUT; (' ');
IF(MRNGE~=1)[
    DO I=1, 5[Z_min_thick(ICM,I)=0.0; MED_min_thick(ICM,I)=0; ]
]
ELSE[
   OUTPUT; (/'          Z_min_thick ,     MED_min_thick  ');
   DO I=1, 5[
       IF( Z_min_thick(ICM,I)~=0.0 )[
          OUTPUT Z_min_thick(ICM,I), MED_min_thick(ICM,I);
          (10X, F8.4, 10X, I5);
       ]
   ]
]

"  return from INPUT_PHANTOM
"  =======================
"
RETURN;

"  error messages
"  ==============
"
:EOF_PHANTOM:
;OUTPUT ICM;
(//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_PHANTOM:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;

"  end of INPUT_PHANTOM
"  ==================
"
END;  "End of INPUT_PHANTOM"

%E    "Start of subroutine ISUMRY_PHANTOM"
"*******************************************************************************
"
"                          Subroutine ISUMRY_PHANTOM
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_PHANTOM;


;IMPLICIT NONE;

;COMIN/
   BOUNDS,CMs,CM_PHANTOM,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER,EGS-IO/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_PHANTOM
"T>**********************************
"T>

INTEGER
   ICOLOUR, "T>colour of CM for EGS_Windows
   IRA,     "T>absolute region number
   LAYER,
   I,J;     "T>DO loop index

$REAL  PIL,VOL_PHANTOM($MAX_N_PHANTOM);  "T>cylinder volume
"   Mass of dose zone
"   =================
"
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_$chamber.
PIL=4.0*ATAN(1.0);

I=0;
LOOP[
   I = I+1;
   IF( I<=N_CHM_PHANTOM ) [ LAYER=I; ]
   ELSEIF(I<=N_CHM_PHANTOM+3 ) [ LAYER=1; ]
   ELSE
     [LAYER=N_CHM_PHANTOM+(I-N_CHM_PHANTOM-3+1)/2;]
     " this will be used only for the top and bottom parts "
   IF(I<=N_CHM_PHANTOM)
   [
      VOL_PHANTOM(I)=PIL*RCYS2_PHANTOM(1,1)*(Z_PHANTOM(I+1)-
          Z_PHANTOM(I));
   ]
   ELSEIF( I=N_CHM_PHANTOM+1 )
   [
       VOL_PHANTOM(I)=PIL*(RCYS2_PHANTOM(1,2)-RCYS2_PHANTOM(1,1))
                   *(Z_PHANTOM(N_CHM_PHANTOM+1)-Z_PHANTOM(1));
   ]
   ELSEIF( I=N_CHM_PHANTOM+2 )
   [
       VOL_PHANTOM(I)=PIL*(RCYS2_PHANTOM(1,3)-RCYS2_PHANTOM(1,2))
                   *(Z_PHANTOM(N_CHM_PHANTOM+1)-Z_PHANTOM(1));
   ]
   ELSEIF( I=N_CHM_PHANTOM+3 )
   [
       VOL_PHANTOM(I)=PIL*( RMAX_CM(ICM_PHANTOM)*RMAX_CM(ICM_PHANTOM)
                   -RCYS2_PHANTOM(1,3))
                   *(Z_PHANTOM(N_CHM_PHANTOM+1)-Z_PHANTOM(1));
   ]
   ELSE
   [
       IF( (LAYER.EQ.N_CHM_PHANTOM+1) .AND. (N_TOP_PHANTOM.NE.0))
       [VOL_PHANTOM(I)=PIL*RCYS2_PHANTOM(LAYER,1)*(Z_PHANTOM(LAYER+1)
             -ZMIN_PHANTOM);]
       ELSEIF( LAYER=N_CHM_PHANTOM+N_TOP_PHANTOM+1 )
       [
           VOL_PHANTOM(I)=PIL*RCYS2_PHANTOM(LAYER,1)
                        *(Z_PHANTOM(LAYER+1)-Z_PHANTOM(N_CHM_PHANTOM+1));
       ]
       ELSE
       [VOL_PHANTOM(I)=PIL*RCYS2_PHANTOM(LAYER,1)*(Z_PHANTOM(LAYER+1)
                         -Z_PHANTOM(LAYER-1+1));
       ]
       I=I+1;
       IF( (LAYER.EQ.N_CHM_PHANTOM+1) .AND. (N_TOP_PHANTOM.NE.0))
       [
            VOL_PHANTOM(I)=PIL*( RMAX_CM(ICM_PHANTOM)*RMAX_CM(ICM_PHANTOM)
                              -RCYS2_PHANTOM(LAYER,1) )
                           *(Z_PHANTOM(LAYER+1)-ZMIN_PHANTOM);
       ]
       ELSEIF( LAYER=N_CHM_PHANTOM+N_TOP_PHANTOM+1 )
       [
            VOL_PHANTOM(I)=PIL*( RMAX_CM(ICM_PHANTOM)*RMAX_CM(ICM_PHANTOM)
                              -RCYS2_PHANTOM(LAYER,1) )
                       *(Z_PHANTOM(LAYER+1)-Z_PHANTOM(N_CHM_PHANTOM+1));
       ]
       ELSE
       [
            VOL_PHANTOM(I)=PIL*( RMAX_CM(ICM_PHANTOM)*RMAX_CM(ICM_PHANTOM)
                              -RCYS2_PHANTOM(LAYER,1) )
                       *(Z_PHANTOM(LAYER+1)-Z_PHANTOM(LAYER-1+1));
       ]
   ]
]UNTIL (I>=N_PHANTOM);

DO I = 1,N_PHANTOM
[ IF( VOL_PHANTOM(I) <=0.0 ) [
OUTPUT I;(/' LOCAL REGION',I4,' IN CHAMBER HAS ZERO VOLUME!'/);
"VOL_PHANTOM(I)=1.0;" ] ]

IRA = IRSTART_PHANTOM-1; "absolute region number
DO IR_PHANTOM=1,N_PHANTOM+N_GAP_PHANTOM ["loop over local region number
   IRA = IRA+1;
   IF(DOSE_ZONE(IRA).NE.0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+VOL_PHANTOM(IR_PHANTOM)*RHOR(IRA);
   ]
] "end of loop over IR_PHANTOM"

"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"
WRITE(IOUTLIST,110) ICM_PHANTOM,TITLE_PHANTOM;
WRITE(IOUTLIST,111) Z_min_CM(ICM_PHANTOM),RMAX_CM(ICM_PHANTOM);

"AIR GAP, IF PRESENT "
IF(N_GAP_PHANTOM~=0)[
   IRA=IRSTART_PHANTOM+N_PHANTOM;
   WRITE(IOUTLIST,1501);
   WRITE(IOUTLIST,1504)N_PHANTOM+1,
                       'NA',Z_min_CM(ICM_PHANTOM),ZMIN_PHANTOM-
                       Z_min_CM(ICM_PHANTOM),RMAX_CM(ICM_PHANTOM),
                       ECUT(IRA),PCUT(IRA),
                       ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
                       (MEDIA(J,MED(IRA)),J=1,9);
   WRITE(IOUTLIST,1505);
]
" ION CHAMBER TOP PART "
IRA = IRSTART_PHANTOM-1+3+N_CHM_PHANTOM;
IF( N_TOP_PHANTOM~=0) [ WRITE(IOUTLIST,1204); ]
DO IR_PHANTOM=N_CHM_PHANTOM+1,N_CHM_PHANTOM+N_TOP_PHANTOM [
   IRA = IRA+1;
   I=(IR_PHANTOM-N_CHM_PHANTOM-1)*2+N_CHM_PHANTOM+3+1;
   IF( IR_PHANTOM=N_CHM_PHANTOM+1 ) [
      IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1304) I,IR_PHANTOM-N_CHM_PHANTOM,
         ZMIN_PHANTOM,Z_PHANTOM(IR_PHANTOM+1)-ZMIN_PHANTOM,
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1304)I,IR_PHANTOM-N_CHM_PHANTOM,
         ZMIN_PHANTOM,Z_PHANTOM(IR_PHANTOM+1)-ZMIN_PHANTOM,
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]
   ELSE[
      IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1304)I,IR_PHANTOM-N_CHM_PHANTOM,
         Z_PHANTOM(IR_PHANTOM),Z_PHANTOM(IR_PHANTOM+1)-
         Z_PHANTOM(IR_PHANTOM),
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1304) I,IR_PHANTOM-N_CHM_PHANTOM,
         Z_PHANTOM(IR_PHANTOM),Z_PHANTOM(IR_PHANTOM+1)-
         Z_PHANTOM(IR_PHANTOM),
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]

   IRA = IRA+1;
   I=I+1;
   IF( IR_PHANTOM=N_CHM_PHANTOM+1 ) [
     IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1305) I,IR_PHANTOM-N_CHM_PHANTOM,
         ZMIN_PHANTOM,Z_PHANTOM(IR_PHANTOM+1)-
         ZMIN_PHANTOM,
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
     ]
     ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1305) I,IR_PHANTOM-N_CHM_PHANTOM,
         ZMIN_PHANTOM,Z_PHANTOM(IR_PHANTOM+1)-
         ZMIN_PHANTOM,
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
   ELSE[
     IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1305) I,IR_PHANTOM-N_CHM_PHANTOM,
         Z_PHANTOM(IR_PHANTOM),Z_PHANTOM(IR_PHANTOM+1)-
         Z_PHANTOM(IR_PHANTOM),
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
     ]
     ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1305) I,IR_PHANTOM-N_CHM_PHANTOM,
         Z_PHANTOM(IR_PHANTOM),Z_PHANTOM(IR_PHANTOM+1)-
         Z_PHANTOM(IR_PHANTOM),
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
]

WRITE(IOUTLIST,120);
IRA = IRSTART_PHANTOM-1;"for chamber part"
DO IR_PHANTOM=1,N_CHM_PHANTOM [
   IRA = IRA+1;
   IF (MED(IRA)=0) ["Medium is vacuum"
      /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
      WRITE(IOUTLIST,130) IR_PHANTOM,IR_PHANTOM,'layer',
      Z_PHANTOM(IR_PHANTOM),
      Z_PHANTOM(IR_PHANTOM+1)-Z_PHANTOM(IR_PHANTOM),
      RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
      ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
   ]
   ELSE
   ["Medium is not vacuum"
      WRITE(IOUTLIST,130) IR_PHANTOM,IR_PHANTOM,'layer',
      Z_PHANTOM(IR_PHANTOM),
      Z_PHANTOM(IR_PHANTOM+1)-Z_PHANTOM(IR_PHANTOM),
      RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
      ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
      (MEDIA(J,MED(IRA)),J=1,9);
   ]
]

" ion chamber side wall part "
IRA=IRA+1;
WRITE(IOUTLIST,1201);
IF (MED(IRA)=0) ["Medium is vacuum"
    /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
    WRITE(IOUTLIST,1301) IR_PHANTOM,'NA','entire',
         Z_PHANTOM(0+1),
         Z_PHANTOM(N_CHM_PHANTOM+1)-Z_PHANTOM(0+1),
         RCYS_PHANTOM(1,1), RCYS_PHANTOM(1,2),ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
]
ELSE ["Medium is not vacuum"
     WRITE(IOUTLIST,1301) IR_PHANTOM,'NA','entire',
         Z_PHANTOM(0+1),
         Z_PHANTOM(N_CHM_PHANTOM+1)-Z_PHANTOM(0+1),
         RCYS_PHANTOM(1,1), RCYS_PHANTOM(1,2),ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,8);
]
WRITE(IOUTLIST,1310)'wall';
" ion chamber side air gap part "
IRA=IRA+1;
WRITE(IOUTLIST,1202);
IF (MED(IRA)=0) ["Medium is vacuum"
    /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
    WRITE(IOUTLIST,1302) IR_PHANTOM+1,'NA','entire',
         Z_PHANTOM(0+1),
         Z_PHANTOM(N_CHM_PHANTOM+1)-Z_PHANTOM(0+1),
         RCYS_PHANTOM(1,2), RCYS_PHANTOM(1,3), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
]
ELSE ["Medium is not vacuum"
     WRITE(IOUTLIST,1302) IR_PHANTOM+1,'NA','entire',
         Z_PHANTOM(0+1),
         Z_PHANTOM(N_CHM_PHANTOM+1)-Z_PHANTOM(0+1),
         RCYS_PHANTOM(1,2), RCYS_PHANTOM(1,3), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,8);
]
WRITE(IOUTLIST,1311)'gap';
" ion chamber's container wall part "
IRA=IRA+1;
WRITE(IOUTLIST,1203);
IF (MED(IRA)=0) ["Medium is vacuum"
    /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
    WRITE(IOUTLIST,1303) IR_PHANTOM+2,'NA','entire',
     Z_PHANTOM(0+1),
     Z_PHANTOM(N_CHM_PHANTOM+1)-Z_PHANTOM(0+1),
         RCYS_PHANTOM(1,3), RMAX_CM(ICM_PHANTOM),
         ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
]
ELSE ["Medium is not vacuum"
     WRITE(IOUTLIST,1303) IR_PHANTOM+2,'NA','entire',
     Z_PHANTOM(0+1),
     Z_PHANTOM(N_CHM_PHANTOM+1)-Z_PHANTOM(0+1),
         RCYS_PHANTOM(1,3), RMAX_CM(ICM_PHANTOM),
         ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,8);
]
WRITE(IOUTLIST,1312)'wall';

" ION CHAMBER BOTTOM PART "
IRA = IRSTART_PHANTOM-1+3+N_CHM_PHANTOM+2*N_TOP_PHANTOM;
IF( N_BOT_PHANTOM~=0 ) [ WRITE(IOUTLIST,1206); ]
DO IR_PHANTOM=N_CHM_PHANTOM+N_TOP_PHANTOM+1,
                 N_CHM_PHANTOM+N_TOP_PHANTOM+N_BOT_PHANTOM[
   IRA = IRA+1;
   I=(IR_PHANTOM-N_CHM_PHANTOM-1)*2+N_CHM_PHANTOM+3+1;
   IF( IR_PHANTOM=N_CHM_PHANTOM+N_TOP_PHANTOM+1 )[
     IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1306)
         I,IR_PHANTOM-N_CHM_PHANTOM-N_TOP_PHANTOM,
         Z_PHANTOM(N_CHM_PHANTOM+1),Z_PHANTOM(IR_PHANTOM+1)-
         Z_PHANTOM(N_CHM_PHANTOM+1),
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
     ]
     ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1306)
         I,IR_PHANTOM-N_CHM_PHANTOM-N_TOP_PHANTOM,
         Z_PHANTOM(N_CHM_PHANTOM+1),Z_PHANTOM(IR_PHANTOM+1)-
         Z_PHANTOM(N_CHM_PHANTOM+1),
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
   ELSE[
      IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1306)
         I,IR_PHANTOM-N_CHM_PHANTOM-N_TOP_PHANTOM,
         Z_PHANTOM(IR_PHANTOM),Z_PHANTOM(IR_PHANTOM+1)-
         Z_PHANTOM(IR_PHANTOM),
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1306)
         I,IR_PHANTOM-N_CHM_PHANTOM-N_TOP_PHANTOM,
         Z_PHANTOM(IR_PHANTOM),Z_PHANTOM(IR_PHANTOM+1)-
         Z_PHANTOM(IR_PHANTOM),
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]

   IRA = IRA+1;
   I=I+1;
   IF( IR_PHANTOM=N_CHM_PHANTOM+N_TOP_PHANTOM+1 ) [
      IF (MED(IRA)=0) ["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1307)
         I,IR_PHANTOM-N_CHM_PHANTOM-N_TOP_PHANTOM,
         Z_PHANTOM(N_CHM_PHANTOM+1),Z_PHANTOM(IR_PHANTOM+1)-
         Z_PHANTOM(N_CHM_PHANTOM+1),
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
      ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,1307)
         I,IR_PHANTOM-N_CHM_PHANTOM-N_TOP_PHANTOM,
         Z_PHANTOM(N_CHM_PHANTOM+1),Z_PHANTOM(IR_PHANTOM+1)-
         Z_PHANTOM(N_CHM_PHANTOM+1),
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]
   ELSE[
     IF (MED(IRA)=0)["Medium is vacuum"
         /ECUT(IRA),PCUT(IRA)/ = 0.0;  "avoids output overflows but not used"
         WRITE(IOUTLIST,1307)
         I,IR_PHANTOM-N_CHM_PHANTOM-N_TOP_PHANTOM,
         Z_PHANTOM(IR_PHANTOM),Z_PHANTOM(IR_PHANTOM+1)-
         Z_PHANTOM(IR_PHANTOM),
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),'V','a','c','u','u','m';
     ]
     ELSE["Medium is not vacuum"
         WRITE(IOUTLIST,1307)
         I,IR_PHANTOM-N_CHM_PHANTOM-N_TOP_PHANTOM,
         Z_PHANTOM(IR_PHANTOM),Z_PHANTOM(IR_PHANTOM+1)-
         Z_PHANTOM(IR_PHANTOM),
         RCYS_PHANTOM(IR_PHANTOM,1), ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
     ]
   ]
]

DO I=1,N_PHANTOM[IF(VOL_PHANTOM(I)<=0.0 )[WRITE(IOUTLIST,141)I;]]

110 FORMAT(///1x,79('-')/
            '  Component module',I3,' is an ion chamber or phantom ',
            '(CHAMBER)'/ 1x,79('-')//T5,'Title: ',68A1);
111 FORMAT(/T2,'PHANTOM region & geometry parameters:',
           /T2,'-------------------------------------',
           /T2,'Distance of front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Radius of outer boundary of CM = ',F15.5,' cm');

120 FORMAT(/T5,'PHANTOM CENTRAL PART parameters:',
           /T5,'--------------------------------',
           /T1,' local layer loc.   Z    Zthick  rad.  electr photon',
           ' range-reject  dose  medium',
           /T1,' reg              front                cutoff cutoff',
           ' level   max   zone'
           /T1,'                   (cm)    (cm)  (cm)   (MeV)  (MeV)',
           ' (MeV)  (MeV)');
130 FORMAT(T1,I3,I5,A7,F8.3,F8.4,F7.3,4F7.3,I3,2X,9A1);
131 FORMAT(T9,A8);
1201 FORMAT(/T5,'PHANTOM WALL parameters:',
           /T5,'--------------------------',
        /T1,' local layer loc.  Z    Zthick     rad.     electr photon',
        ' range-reject dose med',
        /T1,' reg             front         inner  outer cutoff cutoff',
        ' level  max   zone'
        /T1,'                 (cm)    (cm)      (cm)      (MeV)  (MeV)',
        ' (MeV) (MeV)');
1301 FORMAT(T1,I3,A4,A7,F8.3,F7.3,2F7.3,2F6.3,F7.3,F6.3,I3,1X,8A1);
1310 FORMAT(T8,A7);
1202 FORMAT(/T5,'PHANTOM side air gap parameters:',
           /T5,'---------------------------------',
        /T1,' local layer loc.  Z    Zthick     rad.     electr photon',
        ' range-reject dose med',
        /T1,' reg             front         inner  outer cutoff cutoff',
        ' level  max   zone'
        /T1,'                 (cm)    (cm)      (cm)      (MeV)  (MeV)',
        ' (MeV) (MeV)');
1302 FORMAT(T1,I3,A4,A7,F8.3,F7.3,2F7.3,2F6.3,F7.3,F6.3,I3,1X,8A1);
1311 FORMAT(T8,A7);
1203 FORMAT(/T5,'PHANTOM container wall parameters:',
           /T5,'-----------------------------------',
        /T1,' local layer loc.  Z    Zthick     rad.     electr photon',
        ' range-reject dose med',
        /T1,' reg             front         inner  outer cutoff cutoff',
        ' level  max   zone'
        /T1,'                 (cm)    (cm)      (cm)      (MeV)  (MeV)',
        ' (MeV) (MeV)');
1303 FORMAT(T1,I3,A4,A7,F8.3,F7.3,2F7.3,2F6.3,F7.3,F6.3,I3,1X,8A1);
1312 FORMAT(T8,A7);
1204 FORMAT(/T5,'PHANTOM TOP PART parameters:',
           /T5,'-----------------------------',
           /T1,' local layer loc.   Z    Zthick  inner electr photon',
           ' range-reject  dose  medium',
           /T1,' reg              front           rad. cutoff cutoff',
           ' level   max   zone'
           /T1,'                   (cm)   (cm)    (cm)  (MeV)  (MeV)',
           ' (MeV)  (MeV)');
1304 FORMAT(T1,I3,I5,'  inner',F8.3,F8.4,5F7.3,I3,2X,9A1);
1305 FORMAT(T1,I3,I5,'  outer',F8.3,F8.4,5F7.3,I3,2X,9A1);
1206 FORMAT(/T5,'PHANTOM BOTTOM PART parameters:',
           /T5,'--------------------------------',
           /T1,' local layer loc.   Z    Zthick  inner electr photon',
           ' range-reject  dose  medium',
           /T1,' reg              front           rad. cutoff cutoff',
           ' level   max   zone'
           /T1,'                   (cm)   (cm)    (cm)  (MeV)  (MeV)',
           ' (MeV)  (MeV)');
1306 FORMAT(T1,I3,I5,'  inner',F8.3,F8.4,5F7.3,I3,2X,9A1);
1307 FORMAT(T1,I3,I5,'  outer',F8.3,F8.4,5F7.3,I3,2X,9A1);
1501 FORMAT(/T5,'Air gap parameters:',
           /T5,'-------------------',
           /T1,' local layer loc.   Z    Zthick   rad. electr photon',
           ' range-reject  dose  medium',
           /T1,' reg              front                cutoff cutoff',
           ' level   max   zone'
           /T1,'                   (cm)   (cm)    (cm)  (MeV)  (MeV)',
           ' (MeV)  (MeV)');
1504 FORMAT(T1,I3,A5,'  airgap',F8.3,F7.3,5F7.3,I3,2X,9A1);
1505 FORMAT(T8,'   at top');


141 FORMAT(/' LOCAL REGION',I4,' IN CHAMBER HAS ZERO VOLUME!');



"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"

IF(IWATCH = 4 | IZLAST = 2)
[  "Creat a graphics file "
   ;$SELECT-COLOUR;
    DO I=1, N_CHM_PHANTOM+N_TOP_PHANTOM+N_BOT_PHANTOM
    [
       WRITE(IOUTGEOM,201)ICOLOUR,'CYLZ',Z_PHANTOM(I-1+1),
                      RCYS_PHANTOM(I,1),
                Z_PHANTOM(I+1),RCYS_PHANTOM(I,1),0.0,0.0;
    ]
]"End of graphics output"

201   FORMAT(' ',I1,A4,10(F7.2,','));


"   end of ISUMRY_PHANTOM
"   ===================
"
RETURN;
END; "End of subroutine ISUMRY_PHANTOM"
%E "Start of subroutine HOWNEAR_PHANTOM
"*******************************************************************************
"
SUBROUTINE HOWNEAR_PHANTOM(DIST);
"
" Returns min. distance to nearest region boundary
" Used to be a function, but changed to a subroutine for convenience
"  and consistency.
"*******************************************************************************
$IMPLICIT-NONE;

;COMIN/CM_PHANTOM,STACK/;

INTEGER LAYER;
$REAL RF_PHANTOM, RF2_PHANTOM, DIST;

IR_PHANTOM=IR(NP)-IRSTART_PHANTOM+1;"local region # "

" CALC. THE LAYER # "
IF( IR_PHANTOM<=N_CHM_PHANTOM ) [ LAYER=IR_PHANTOM; ]
ELSEIF(IR_PHANTOM<=N_CHM_PHANTOM+3 ) [ LAYER=1; ]
ELSEIF(IR_PHANTOM<=N_PHANTOM)[
    LAYER=N_CHM_PHANTOM+(IR_PHANTOM-N_CHM_PHANTOM-3+1)/2;
    "last term gives the layer number, i.e., "
    "for region 1 in top part, the layer number(integer)=(1+1)/2=1"
    "for region 2 in top part, the layer number(integer)=(2+1)/2=1"
    "for region 3 in top part, the layer number(integer)=(3+1)/2=2"
    "......                                        changed by CMa."
    " this will be used only for the top and bottom parts         "
]

RF2_PHANTOM=X(NP)**2+Y(NP)**2;
RF_PHANTOM=SQRT(RF2_PHANTOM);
IF( IR_PHANTOM<=N_CHM_PHANTOM ) [" inside the main ion chamber part "
    DIST=MIN(  Z(NP)-Z_PHANTOM(LAYER),   " upstream "
    Z_PHANTOM(LAYER+1)-Z(NP),     " downstream"
    RCYS_PHANTOM(LAYER,1)-RF_PHANTOM  );
    RETURN;
]
ELSEIF( IR_PHANTOM<=N_CHM_PHANTOM +3 )  [
    " in the side wall or side gap or container wall "
    DIST=MIN(  Z(NP)-Z_PHANTOM(1),      " upstream "
    Z_PHANTOM(N_CHM_PHANTOM+1)-Z(NP),  " downstream "
    ABS( RF_PHANTOM -RCYS_PHANTOM(1, 1) ),
    ABS( RF_PHANTOM -RCYS_PHANTOM(1, 2) ),
    ABS( RF_PHANTOM -RCYS_PHANTOM(1, 3) ) );
    RETURN;
]
ELSEIF( IR_PHANTOM<=N_PHANTOM )[   " except air gap. "
    DIST=MIN(  Z(NP)-ZMIN_PHANTOM,
    " check the front face of the 1st layer in the top"
    ABS( Z(NP)-Z_PHANTOM(1) ),
    " check the back face of the last layer in the top"
    ABS( Z(NP)-Z_PHANTOM(N_CHM_PHANTOM+1) ),
    " check the front face for the 1st layer in the bottom"
    ZMAX_PHANTOM-Z(NP),        " back face for the last in the bottom "
    ABS(Z(NP)-Z_PHANTOM(LAYER)),  " except the above case "
    "this is for the front face of the layer"
    ABS(Z_PHANTOM(LAYER+1)-Z(NP)),
    "this is for the back face of the layer"
    "note we use ABS because the front face in the top layer"
    "and the back face of the bottom layer may not be Z_PHANTOM(LAYER)"
    "and Z_PHANTOM(LAYER+1)     --CMa"
    ABS( RCYS_PHANTOM(LAYER,1)-RF_PHANTOM ) );
    RETURN;
]
ELSEIF( IR(NP)=IREND_PHANTOM & N_GAP_PHANTOM=1)[
    DIST=MIN(Z(NP)-ZFRONT_PHANTOM, ZMIN_PHANTOM-Z(NP));
    RETURN;
]
RETURN;
END; "End of subroutine HOWNEAR_PHANTOM"
"End of CHAMBER_cm.mortran"
%N "Turn off MORTRAN listing
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc I/O functions                                                       "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Iwan Kawrakow, 2003                                       "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Ernesto Mainegra-Hing                                     "
"                   Blake Walters                                             "
"                   Frederic Tessier                                          "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
" Iwan Kawrakow, 2004:                                                        "
"                                                                             "
" re-factored egs_init so that it is easy to program a corresponding egs_init "
" when one loads a EGSnrc user code as a library and therefore no command     "
" line arguments are available. (see beam library).                           "
"                                                                             "
"#############################################################################"


%I4
%C80
%Q1
!INDENT F2;
REPLACE {$max_unit} WITH {99}

REPLACE {$egs_debug(#,#);} WITH {;} " no need for debug info "

REPLACE {;COMIN/my_times/;} WITH {;
  common/my_times/ t_elapsed, t_cpu, t_first;
  $REAL            t_elapsed, t_cpu;
  integer          t_first(8);
  real             egs_tot_time,egs_etime;
};

"******************************************************************************
" subroutine egs_init;
"******************************************************************************
" A call to this subroutine becomes Step 0 in every EGSnrc user code.
" Its purpose is to:
"   - initialize arrays and default values for various transport options
"     (this was previously done in block data, but due to the GNU Fortran
"     compiler complaints and extremely slow compilation when the number of
"     regions is large, we decided to remove block data from the source)
"   - Process command line arguments specifying input file, pegs4 data file,etc.
"     In the current version the following command line options are supported:
"
"       -i or --input ifile          Input file is ifile.egsinp
"
"       -p or --pegs-file file_name  The pegs4 data file is file_name.pegs4dat
"                                    The system will look for it in the
"                                    HEN_HOUSE and the user's pegs4 data areas
"
"       -o or --output ofile         Output data will be writtent to
"                                    ofile.egslog, ofile.egslst, etc., instead
"                                    of ifile.egslog, etc.
"
"       -H or --hen-house dir        Change the HEN_HOUSE to be dir instead
"                                    of the directory specified in the
"                                    machine.macros file.
"
"       -e or --egs-home dir         Change EGS_HOME to be dir instead of
"                                    the directory specified by the EGS_HOME
"                                    environment variable
"
"       -h or --help                 Print a help message and exit
"                                    ignoring all other arguments
"
"       -b or --batch                Specify a 'batch' run. The difference
"                                    between a 'batch' run and an interactive
"                                    run is that in 'batch' mode unit 6 is
"                                    connected to a file, whereas in intarctive
"                                    mode unit 6 goes to the standard output.
"                                    The file name in batch run is determined
"                                    as follows:
"                                     - ofile.egslog, if ofile was specified
"                                       with the -o option
"                                     - ifile.egslog, if there was no -o option
"                                       used but an input file was specified
"                                       with -i
"                                     - test.egslog, if neither -i nor -o was
"                                       used.
"
"       -P or --parallel n           Tell the system that this run is part of
"                                    a parallel run and that this is job number
"                                    n (so that the random number sequence
"                                    can be initialized differently)
"
"       -c or --chunk N              Tell the system to use N histories per
"                                    calculation 'chunk' in parallel runs.
"
"   - open default EGSnrc data file units thus avoiding the necessity for
"     symbolik links
"   - open user code specific I/O units if a .io file is found in
"     the user code area. The format of this file is an integer
"     followed by a string on every line.
"     The string specifies the file extension
"     and the integer the unit number this file should connect to, e.g.
"       4   .egsdat
"       15  .egserr
"       1   .egslst
"     will result in connecting unit 4 to the file ifile.egsdat
"     (or ofile.egsdat, see above) to unit 4, [i|o]file.egserr to unit 15, etc.
"  -  Outputs a summary to standard output about configuration etc
"  -  Creates a temporary working directory in the user code area
"
"  The files always opened (appart from the ones specified in the .io file)
"  are the following:
"
"  1. The PEGS data file (and so, for now, the -p pegs_file command line
"     option must be always given)
"     The algorithm for looking for a PEGS data file is:
"       - The file name passed with -p. In this way, PEGS files can be located
"         everywhere on the file system (not just in $HEN_HOUSE/pegs4/data
"         and $EGS_HOME/pegs4/data) if the absolute path name is given after
"         the -p option.
"       - $EGS_HOME/pegs4/data/pegs_file or
"         $EGS_HOME/pegs4/data/pegs_file.pegs4dat
"       - $HEN_HOUSE/pegs4/data/pegs_file or
"         $HEN_HOUSE/pegs4/data/pegs_file.pegs4dat
"     See note below on how $HEN_HOUSE and $EGS_HOME are determined
"
"  2. If a -i ifile option was given as argument, ifile.egsinp is
"     opened as fortran unit 5.
"     The input file MUST be in the user code directory on $EGS_HOME
"
"  3. If the run is a batch run (the -b option was present on the command
"     line), fortran unit 6 is connected to an output file with a .egslog
"     extension instead of going to standard output.
"     The algorithm for determining the .egslog file name is the following:
"       - If the -o ofile option was present, the output to unit 6 will go
"         to ofile.egslog
"       - If there was no -o option, but there is an inpuit file specified
"         with -i ifile, output to unit 6 will go to ifile.egslog
"       - If neither of the above is true, the output will go to
"         test.egslog.
"
"  Note on determining EGS_HOME:
"  EGS_HOME is normally taken from the environment variable EGS_HOME.
"  However, one can overwrite the environment by giving the
"    -e | --egs-home  new_egs_home_location
"  option on the command line.
"  EGS_HOME must be set, either via the environment or via the command line,
"  otherwise the job will abort.
"
"  Note on determining HEN_HOUSE:
"  HEN_HOUSE is set to the value defined in machine.macros, which is
"  created by the configure script or the configuration wizard in the GUI
"  This value can be overwritten by giving the
"    -H | --hen-house new_hen_house_location
"  option on the command line.
"  HEN_HOUSE is NOT taken from the environment.
"
"  The name of the temporary working directory is created using
"    egsrun_getpid_ifile_hostname, if there was an input file, or
"    egsrun_getpid_noinput_hostname, if there was no input file specified.
"  In the above, getpid is the process id returned bt the getpid() intrinsic
"  and hostname is the host name as determined by egs_get_hostnm().
"  During run time, all output from the program (the .egslog file and
"  all other files specified in the .io file) is kept in the
"  temporary working directory. After succesful completion, egs_finish
"  moves all output back to the user code area and removes the
"  temporary working directory. This implies that if for whatever reason
"  the job terminates prematurely, the temporary working directory
"  with all output will be left behind.
"
"
"
"******************************************************************************
subroutine egs_init;
"******************************************************************************
implicit none;
;COMIN/my_times/;
$REAL dum;

/*
t_elapsed = 0; t_cpu = egs_etime(); dum = egs_tot_time(1);
call egs_date_and_time(t_first);
*/
call egs_set_defaults;
call egs_check_arguments;
call egs_init1;
return; end;

"******************************************************************************
subroutine egs_init1;
"******************************************************************************

implicit none;
;COMIN/EGS-IO,MISC,my_times/;
integer   l, lnblnk1, l1, l2;
integer   i;
character arg*256,tmp_string*512, tmp1_string*512, ucode_dir*512,
          line*80,
          line1*80,dattim*24;
$LOGICAL  have_input,egs_isdir,egs_strip_extension,ex,
          on_egs_home,is_opened;
$INTEGER  mypid;
integer   getpid;
integer   istat, egs_system, u, pos1, pos2,egs_get_unit,itmp;
$REAL     dum;
$declare_write_buffer;

t_elapsed = 0; t_cpu = egs_etime(); dum = egs_tot_time(1);
call egs_date_and_time(t_first);

$set_string(line,'=');
$set_string(line1,'.');

" Handy macros for checking command line arguments "
REPLACE {$check_get_argument(#,#,#);} WITH {
  have_arg = .false.;
  DO i=1,narg-1 [
      call getarg(i,{P3}); l = lnblnk1({P3});
      IF( ( l = lnblnk1({P1}) & {P3}(:l) = {P1} ) |
          ( l = lnblnk1({P2}) & {P3}(:l) = {P2} ) ) [
          have_arg = .true.; call getarg(i+1,{P3}); EXIT;
      ]
  ]
};

REPLACE {$check_argument(#,#,#);} WITH {
  have_arg = .false.;
  DO i=1,narg [
      call getarg(i,{P3}); l = lnblnk1({P3});
      IF( ( l = lnblnk1({P1}) & {P3}(:l) = {P1} ) |
          ( l = lnblnk1({P2}) & {P3}(:l) = {P2} ) ) [
          have_arg = .true.; EXIT;
      ]
  ]
};

IF(~is_pegsless)[
" Get the pegs4 data file "
on_egs_home = .false.;
inquire(file=pegs_file,exist=ex);
IF( ex ) [
    kmpi=egs_get_unit(kmpi);
    IF(kmpi<0)[
      $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
    ]
    open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
    $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
    goto :found_pegs_file:;
]
arg = $cstring(pegs_file);
ex = egs_strip_extension(arg,'.pegs4dat');
l = lnblnk1(egs_home); l1 = lnblnk1('pegs4data') + 2*lnblnk1($file_sep);
l2 = lnblnk1(arg) + lnblnk1('.pegs4dat');
IF( l + l1 + l2 > 256 ) [
    $egs_warning(*,'pegs4 data file name (including absolute path)');
    $warning('(a,i4,a)','is too long (',l+l1+l2,') characters');
]
ELSE [
    pegs_file = $cstring(egs_home) // 'pegs4' // $file_sep // 'data' //
      $file_sep // $cstring(arg) // '.pegs4dat';
    $egs_debug('(a,a)','checking for pegs file ',$cstring(pegs_file));
    inquire(file=pegs_file,exist=ex);
    IF( ex ) [
        kmpi=egs_get_unit(kmpi);
        IF(kmpi<0)[
          $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
        ]
        open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
        $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
        on_egs_home = .true.;
        goto :found_pegs_file:;
    ]
]
l = lnblnk1(hen_house);
IF( l + l1 + l2 > 256 ) [
    $egs_warning(*,'pegs4 data file name (including absolute path)');
    $warning('(a,i4,a)','is too long (',l+l1+l2,') characters');
]
ELSE [
    pegs_file = $cstring(hen_house) // 'pegs4' // $file_sep // 'data' //
       $file_sep // $cstring(arg) // '.pegs4dat';
    $egs_debug('(a,a)','checking for pegs file ',$cstring(pegs_file));
    inquire(file=pegs_file,exist=ex);
    IF( ex ) [
        kmpi=egs_get_unit(kmpi);
        IF(kmpi<0)[
          $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
        ]
        open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
        $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
        goto :found_pegs_file:;
    ]
]

$egs_fatal(*,'could not find pegs4 file named ',$cstring(arg));

]

:found_pegs_file:
;
" Open egsnrc data files "
$set_string(tmp_string,' ');
tmp_string = $cstring(hen_house) // 'data' // $file_sep;

"set proposed unit numbers"
i_nist_data=76;
i_incoh=78;
i_photo_relax=77;
i_photo_cs=79;
i_mscat=11;

REPLACE {$open_data_file(#,#,#,#);} WITH {;
    $set_string({P2},' ');
    {P2} = $cstring({P1}) // {P3};
    inquire(file={P2},exist=ex,opened=is_opened,number=itmp);
    IF( ~ex ) [
        $egs_fatal(*,'EGSnrc data file ',{P3},' does not exist');
    ]
    IF( ~is_opened ) [
        {P4}=egs_get_unit({P4});
        IF({P4}<0)[
          $egs_fatal(*,'failed to get a free Fortran I/O unit for data file ',
                       $cstring({P2}));
        ]
        open({P4},file={P2},status='old',err=:data_file_error:);
    ]
    ELSE [ {P4} = itmp; ]
    $egs_debug('(a,a)','opened data file ',$cstring({P2}));
};
$open_data_file(tmp_string,tmp1_string,'photo_cs.data',$PHOCSUNIT);
$open_data_file(tmp_string,tmp1_string,'msnew.data',$MSCAT-DATAFILE);
$open_data_file(tmp_string,tmp1_string,'incoh.data',$INCOHUNIT);
$open_data_file(tmp_string,tmp1_string,'photo_relax.data',$PHOTOUNIT);

$set_string(ucode_dir,' ');
ucode_dir = $cstring(egs_home) // $cstring(user_code) // $file_sep;

have_input = .false.;
i_input=5;
IF( lnblnk1(input_file) > 0 ) [
    have_input = .true.;
    l = lnblnk1(egs_home); l1 = lnblnk1(user_code)+1;
    l2 = lnblnk1(input_file) + lnblnk1('.egsinp');
    IF( l + l1 + l2 > 1024 ) [
        $egs_fatal(*,'input file name (including path) is too long ',l+l1+l2);
    ]
    ex = egs_strip_extension(input_file,'.egsinp');
    tmp_string = $cstring(ucode_dir) // $cstring(input_file) // '.egsinp';
    inquire(file=tmp_string,exist=ex);
    IF( ~ex ) [
        $egs_fatal(*,'Input file ',$cstring(tmp_string),' does not exist.');
    ]
    $AVAILABLE_UNIT(i_input,tmp_string);
    open(i_input,file=tmp_string,status='old',err=:open_input_error:);
]

" Construct a temporary directory name to run from "
$set_string(work_dir,' ');
work_dir = 'egsrun_'; mypid = getpid();
call egs_itostring(work_dir,mypid,.false.);
call egs_get_hostnm(host_name);
IF( lnblnk1(host_name) < 1 ) host_name = 'unknown';
IF( have_input ) [
    work_dir = $cstring(work_dir) // '_' // $cstring(input_file) //
               '_' // $cstring(host_name) // $file_sep;
]
ELSE [
    work_dir = $cstring(work_dir) // '_noinput_' // $cstring(host_name) //
               $file_sep;
]
$set_string(tmp_string,' ');
tmp_string = $cstring(ucode_dir) // $cstring(work_dir);
DO i=1,lnblnk1(tmp_string) [
    IF( tmp_string(i:i) = '/' ) [
        tmp_string(i:i) = $file_sep;
    ]
]
ex = egs_isdir(tmp_string);
IF( ex ) [
 $egs_fatal(*,'a directory named ',$cstring(tmp_string),' already exists?');
]
tmp1_string = 'mkdir ' // $cstring(tmp_string);
l = lnblnk1(tmp1_string); tmp1_string(l+1:l+1) = char(0);
                 " some systems need the command string to be 0 terminated"
istat = egs_system(tmp1_string);
IF( istat ~= 0 ) [
    $egs_fatal(*,'failed to create working directory ',$cstring(tmp1_string));
]

call egs_open_units(.true.);

" Now print a summary of what happened "
$egs_info('(a)',line);
$egs_info('(a,a,t55,a,$)','EGSnrc version 4 for ',$CANONICAL_SYSTEM,' ');
call egs_get_fdate(dattim);
$egs_info('(a,/,a)',dattim,line);

REPLACE {$write_description(#);} WITH {;
  $egs_info('(a,$)',{P1}); l = pos2 - lnblnk1({P1});
  $egs_info('(a,$)',line1(:l));
};
pos1 = lnblnk1('output file(s)');
pos2 = 80 - lnblnk1($CONFIGURATION_NAME);
pos2 = min(pos2,80-lnblnk1(user_code));
$set_string(tmp_string,' '); tmp_string = pegs_file;
call egs_strip_path(tmp_string);
ex = egs_strip_extension(tmp_string,'.pegs4dat');
IF( on_egs_home ) [ tmp_string = $cstring(tmp_string) // ' on EGS_HOME'; ]
ELSE [ tmp_string = $cstring(tmp_string) // ' on HEN_HOUSE'; ]
IF( lnblnk1(tmp_string) > lnblnk1(pegs_file) ) [
    $set_string(tmp_string,' '); tmp_string = pegs_file;
]
pos2 = min(pos2,80-lnblnk1(tmp_string));
pos2 = min(pos2,80-lnblnk1(host_name));
IF( have_input ) pos2 = min(pos2,80-lnblnk1(input_file));
pos2 = min(pos2,80-lnblnk1(output_file));
IF( pos2 < pos1+2 ) pos2 = pos1 + 2;

$write_description('configuration'); $egs_info('(a)',$CONFIGURATION_NAME);
$write_description('user code'); $egs_info('(a)',$cstring(user_code));
$write_description('pegs file'); $egs_info('(a)',$cstring(tmp_string));
$write_description('using host'); $egs_info('(a)',$cstring(host_name));
IF( have_input ) [
    $write_description('input file'); $egs_info('(a)',$cstring(input_file));
]
$write_description('output file(s)'); $egs_info('(a)',$cstring(output_file));
IF( n_parallel > 0 ) [
    $write_description('number of parallel jobs');
    $egs_info('(i2)',n_parallel);
    $write_description('job number'); $egs_info('(i2)',i_parallel);
]
$egs_info('(a)',line);

return;

" Errors "
:open_input_error:
$egs_fatal(*,'failed to open input file ',$cstring(tmp_string));

:open_pegs_error:
$egs_fatal(*,'failed to open existing pegs file ',$cstring(pegs_file));

:data_file_error:
$egs_fatal(*,'failed to open EGSnrc data file ',$cstring(tmp1_string));

return; end;

"*****************************************************************************
subroutine egs_check_arguments;
"*****************************************************************************
implicit none;

;COMIN/EGS-IO/;

character arg*256,tmp_string*512, line1*80;
$LOGICAL  have_arg,egs_isdir,egs_strip_extension,ex,
          on_egs_home;
integer   narg, iargc, i, lnblnk1, l, l2,i_help,egs_get_unit;
$declare_write_buffer;

narg = iargc();
IF( narg < 1 ) return;

" Check for hen_house "
$check_get_argument('-H','--hen-house',arg);
IF( have_arg ) [
    l = lnblnk1(arg); $set_string(hen_house,' ');
    IF( l > 0 ) [
        IF( l > 254 ) [
            $egs_fatal('(a,i5)',' HEN_HOUSE argument is too long',l);
        ]
        hen_house(:l) = $cstring(arg);
        IF( hen_house(l:l) ~= $file_sep ) hen_house(l+1:l+1) = $file_sep;
    ]
    ELSE [
        $egs_fatal('(a)',' empty argument after -H');
    ]
    DO i=1,lnblnk1(hen_house) [
        IF( hen_house(i:i) = '/' ) [
            hen_house(i:i) = $file_sep;
        ]
    ]
]
IF( ~egs_isdir(hen_house) ) [
    $egs_warning('(a,a)',' HEN_HOUSE directory ',$cstring(hen_house));
    $warning('(a)','does not exist. Hope you know what you are doing.');
]

" Check if the user requested help "
$check_argument('-h','--help',arg);
IF( have_arg ) [
  call getarg(0,arg); call egs_strip_path(arg);
  $egs_info('(//,a,a,a,//)','Usage: ',$cstring(arg),' [args] ');
  tmp_string = $cstring(hen_house) // 'pieces/help_message';
  i_help=98;
  i_help=egs_get_unit(i_help);
  IF(i_help<0)[
     $egs_fatal(*,'failed to get a free Fortran I/O unit for help file');
  ]
  open(i_help,file=tmp_string,status='old',err=:no_help_file:);
  LOOP [
      read(i_help,'(a)',err=:end_of_help:,end=:end_of_help:) line1;
      $egs_info('(a)',line1);
  ]
  :end_of_help:;
  $CALL_EXIT(0);
  :no_help_file:;
  $egs_fatal(*,'Did not find the help_message file!');
]

" Check for batch option "
$check_argument('-b','--batch',arg);
IF( have_arg ) is_batch = .true.;

" Check for parallel run option"
$check_get_argument('-P','--parallel',arg);
IF( have_arg ) [
    read(arg,*,err=:wrong_parallel_arg:) n_parallel;
    IF( n_parallel < 0 ) goto :wrong_parallel_arg:;
    goto :ok_parallel_arg:;
    :wrong_parallel_arg:;
    $egs_warning(*,
     ' Wrong/missing parallel job number argument, -P option ignored');
    n_parallel = 0;
    :ok_parallel_arg:;
]

$check_get_argument('-j','--job',arg);
IF( have_arg ) [
    read(arg,*,err=:wrong_job_arg:) i_parallel;
    IF( i_parallel < 0 ) goto :wrong_job_arg:;
    goto :ok_job_arg:;
    :wrong_job_arg:;
    $egs_warning(*,' Wrong/missing job argument, -j option ognored');
    i_parallel = 0;
    :ok_job_arg:;
]

$check_get_argument('-f','--first-job',arg);
IF( have_arg ) [
    read(arg,*,err=:wrong_first_job_arg:) first_parallel;
    IF( first_parallel < 1 ) goto :wrong_first_job_arg:;
    goto :ok_first_job_arg:;
    :wrong_first_job_arg:;
    $egs_warning(*,' Wrong/missing first job argument, -f option ognored');
    first_parallel = 1;
    :ok_first_job_arg:;
]

IF( n_parallel > 0 | i_parallel > 0 ) [
    IF( n_parallel*i_parallel = 0 ) [
        $egs_warning(*,'You need to specify number of jobs AND job number ',
          '=> will not use parallel run ');
        n_parallel = 0; i_parallel = 0;
    ]
    IF( first_parallel > i_parallel ) [
        $egs_warning(*,'i_parallel (',i_parallel,
          ') can not be smaller than first_parallel (',first_parallel,')');
        first_parallel = i_parallel;
    ]
]

$egs_debug('(a,a)','HEN_HOUSE is ',$cstring(hen_house));

" Check for egs_home "
$check_get_argument('-e','--egs-home',arg);
IF( have_arg ) [
    l = lnblnk1(arg); $set_string(egs_home,' ');
    IF( l = 0 ) [
        $egs_fatal('(a)',' empty argument after -e');
    ]
    IF( l > 254 ) [
        $egs_fatal('(a,i5)',' EGS_HOME argument is too long ',l);
    ]
    egs_home(:l) = $cstring(arg);
    IF( egs_home(l:l) ~= $file_sep ) egs_home(l+1:l+1) = $file_sep;
    DO i=1,lnblnk1(egs_home) [
        IF( egs_home(i:i) = '/' ) [
            egs_home(i:i) = $file_sep;
        ]
    ]
]
IF( ~egs_isdir(egs_home) ) [
  $egs_fatal(*,' EGS_HOME directory ',$cstring(egs_home),' does not exist.');
]
$egs_debug('(a,a)','EGS_HOME is ',$cstring(egs_home));

" Get the pegs4 data file "
on_egs_home = .false.;
is_pegsless=.false.;
$check_get_argument('-p','--pegs-file',arg);
IF( ~have_arg ) [
    $egs_warning(*,'No pegs4 file name supplied.  Will assume you are running
 in pegs-less mode with media details specified in input file.');
    is_pegsless=.true.;
]
ELSE[
    pegs_file = $cstring(arg);
]

" Deduct the user code name from the executable name "
call egs_get_usercode(user_code);

" Check for an input file "
$check_get_argument('-i','--input',arg);
IF( have_arg ) [
    ex = egs_strip_extension(arg,'.egsinp');
    l2 = lnblnk1(arg) + lnblnk1('.egsinp');
    IF( l2 > 256 ) [
        $egs_fatal(*,'input file name is too long ',l2);
    ]
    input_file = $cstring(arg);
]

" Check for an output file option "
$check_get_argument('-o','--output',arg);
IF( have_arg ) [
    l = lnblnk1(arg);
    IF( l > 256 ) [
        $egs_fatal(*,'output file name is too long ',l);
    ]
    output_file(:l) = $cstring(arg);
]
ELSE [
    IF( lnblnk1(input_file) > 0 ) [
        output_file(:lnblnk1(input_file)) = $cstring(input_file);
    ]
    ELSE [
        output_file = 'test';
    ]
]

return; end;

"******************************************************************************
subroutine egs_open_units(flag);
"******************************************************************************
" Open output files.
" Looks for output file definition in user_code.io.
" In addition, if it is a batch run connects a .egslog file to unit 6.
" If flag is .true., open the files in the temporary working directory,
" else open them in the user code directory.
"******************************************************************************
implicit none;
$LOGICAL flag;

;COMIN/EGS-IO/;

character tmp_string*1024, tmp1_string*1024, tmp2_string*1024, ucode_dir*1024,
          input_line*100, arg*20;
integer   i,lnblnk1,u,l,istart,egs_get_unit,i_iofile;
$LOGICAL  ex,is_open;
$declare_write_buffer;

$set_string(tmp_string,' '); $set_string(ucode_dir,' ');
ucode_dir = $cstring(egs_home) // $cstring(user_code) // $file_sep;
IF( flag ) [
    tmp_string = $cstring(ucode_dir) // $cstring(work_dir);
]
ELSE [
    tmp_string = $cstring(ucode_dir);
]

tmp_string = $cstring(tmp_string) // $cstring(output_file);
IF( i_parallel > 0 ) [
    tmp_string = $cstring(tmp_string) // '_w';
    call egs_itostring(tmp_string,i_parallel,.false.);
]
$set_string(tmp1_string,' ');
i_log=6;
IF( is_batch ) [
    tmp1_string = $cstring(tmp_string) // '.egslog';
    $AVAILABLE_UNIT(i_log,tmp1_string);
    open(i_log,file=tmp1_string,status='unknown',err=:output_file_error:);
]
$set_string(tmp2_string,' ');
tmp2_string = $cstring(ucode_dir) // $cstring(user_code) // '.io';
inquire(file=tmp2_string,exist=ex);
n_files = 0;
IF( ex ) [
    i_iofile=99;
    i_iofile=egs_get_unit(i_iofile);
    IF (i_iofile<1)[
      $egs_fatal(*,'failed to get a free Fortran I/O unit for .io file');
    ]
    open(i_iofile,file=tmp2_string,status='old',err=:io_file_error:);
    LOOP [
        read(i_iofile,'(a)',err=:end_of_iofile:,end=:end_of_iofile:) input_line;
        IF( input_line(1:1) = '#' ) NEXT;
        "The DEC and SGI compilers fail at the following statement!"
        "read(input_line,*,err=:end_of_iofile:,end=:end_of_iofile:) u,arg;"
        read(input_line,*,err=:end_of_ioline:,end=:end_of_ioline:) u;
        istart = 1;
        DO i=lnblnk1(input_line),1,-1 [
            IF( input_line(i:i) = ' ' ) [ istart = i+1; EXIT; ]
        ]
        DO i=1,len(arg) [ arg(i:i) = ' '; ]
        DO i=istart,lnblnk1(input_line) [
            arg(i+1-istart:i+1-istart) = input_line(i:i);
        ]
        inquire(unit=u,opened=is_open);
        IF( is_open ) [
            $egs_warning('(a,i3,a,a,a,/,a,/,a,/)',
              'Unit ',u,' which you want to connect to a ',
              $cstring(arg),' file ',
           'is already in use. Will assume this code is being used as',
           'a shared library source and this file will be opened explicitly.');
        ]
        ELSE[
            n_files = n_files + 1;
            IF( n_files > $mx_units ) [
               $egs_fatal(*,'Too many units requested in .io.',
                ' Increas $mx_units and retry');
            ]
            file_units(n_files) = u;
            $set_string(file_extensions(n_files),' ');
            l = lnblnk1(arg);
            IF( l > $max_extension_length ) [
                $egs_fatal(*,'extension ',$cstring(arg),' is longer than ',
                  $max_extension_length,' chars. ',
                  'Increase $max_extension_length and retry ');
            ]
            file_extensions(n_files) = $cstring(arg);
            tmp1_string = $cstring(tmp_string) // $cstring(arg);
            open(u,file=tmp1_string,status='unknown');
            $egs_debug('(a,a,a,i3)','connected ',$cstring(tmp1_string),
              ' to unit ',u);
        ]
        :end_of_ioline:
    ]
    :end_of_iofile:
    close(i_iofile);
]
return;

:output_file_error:
$egs_fatal(*,'failed to open output file ',$cstring(tmp1_string));

:io_file_error:
$egs_fatal(*,'failed to open existing .io file',$cstring(tmp2_string));
return; end;


"******************************************************************************
subroutine egs_finish;
"******************************************************************************
" This subroutine becomes the last step in every EGSnrc user code.
" It's purpose is to move the all output files from the temporary working
" directory to the user code directory and to remove the working dir.
" This was previously done by the egs_run script.
" This routine also prints a summary to standard output.
"******************************************************************************
implicit none;
;COMIN/EGS-IO,my_times/;
character line*80,base*512,base1*512,tmp_string*512,junk_file*128,fname*512;
character dattim*24;
integer  i,l,lnblnk1,istat,egs_system,n_open,unlink,i_junk,egs_get_unit;
$LOGICAL is_open,egs_isdir;
$REAL    t1,t2,tt_cpu;
$declare_write_buffer;

$set_string(line,'=');
IF( n_parallel = 0 | i_parallel > 0 ) [
 "i.e. we want that info if this is not a parallel run (n_parallel = 0)"
 "or if it is parallel but it is not the final egs_finish (after combining"
 "results from parallel runs)"
t_elapsed = egs_tot_time(1); tt_cpu = egs_etime() - t_cpu;
t1 = t_elapsed; t2 = t1/3600;
$egs_info('(//a,/,a,/)',line,'Finished simulation');
$egs_info('(2x,a,t30,f9.1,a,f7.3,a)','Elapsed time: ',t1,' s (',t2,' h)');
t1 = tt_cpu; t2 = t1/3600;
$egs_info('(2x,a,t30,f9.1,a,f7.3,a)','CPU time:',t1,' s (',t2,' h)');
$egs_info('(2x,a,t30,f10.3)','Ratio:',t_elapsed/tt_cpu);
]
call egs_get_fdate(dattim);
$egs_info('(//a,t56,a,/,a)','End of run ',dattim,line);

" Close all I/O units "
n_open=0;
$set_string(base,' ');
base = $cstring(egs_home) // $cstring(user_code);
DO i=1,$max_unit [
    IF( is_batch | i ~= i_log ) [
      inquire(i,opened=is_open);
      IF( is_open ) [
         inquire(i,name=fname);
         IF(index($cstring(fname),$cstring(base))>0)[
              close(i); n_open = n_open+1; ]
      ]
    ]
]

"If work_dir is empty, this is a second call to egs_finish for the last"
"job in a parallel run. This implies that the temporary working "
"directory has been already removed => just return"

IF( lnblnk1(work_dir) = 0 ) [ return; ]

" Now generate a junk file in the working directory so that the move "
" command does not fail in case there are no files "
$set_string(base,' ');
base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
        $cstring(work_dir);
DO i=1,lnblnk1(base) [
    IF( base(i:i) = '/' ) [
        base(i:i) = $file_sep;
    ]
]
IF( egs_isdir(base) ) [
    $set_string(tmp_string,' '); $set_string(junk_file,' ');
    junk_file = $cstring(work_dir);
    l = lnblnk1(junk_file); junk_file(l:l) = ' ';
    junk_file = $cstring(junk_file) // '_junk';
    tmp_string = $cstring(base) // $cstring(junk_file);
    i_junk=99;
    i_junk=egs_get_unit(i_junk);
    IF(i_junk<0)[
      $egs_fatal(*,'failed to get a free Fortran I/O unit for junk file');
    ]
    open(i_junk,file=tmp_string,status='unknown');
    write(i_junk,*) 'junk';
    close(i_junk);

    " Move all files from the working directory to the user code directory "
    $set_string(base1,' ');
    base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
            $cstring(work_dir);
    base1 = $cstring(egs_home) // $cstring(user_code);
    $set_string(tmp_string,' ');
    tmp_string = $move_file // $cstring(base) // '*  ' // $cstring(base1);
    l = lnblnk1(tmp_string)+1;
    tmp_string(l:l) = char(0);
    istat = egs_system(tmp_string);
    IF( istat ~= 0 ) [
        $egs_warning(*,'Moving files from working directory failed ?');
        $warning(*,'=> will not remove working directory');
    ]
    ELSE [
        " Remove the working directory "
        $set_string(tmp_string,' ');
        tmp_string = $remove_directory // $cstring(base);
        l = lnblnk1(tmp_string)+1; tmp_string(l:l) = char(0);
        istat = egs_system(tmp_string);
        IF( istat ~= 0 ) [
            $egs_warning(*,'Failed to remove working directory ',
              $cstring(work_dir));
        ]
        " Remove the junk file "
        $set_string(tmp_string,' ');
        tmp_string = $cstring(base1) // $file_sep // $cstring(junk_file);
        l = lnblnk1(tmp_string)+1; tmp_string(l:l) = char(0);
        istat = unlink(tmp_string);
    ]
]

" Now set work_dir to blank so that all I/O stuff after egs_finish ends up"
" in the user code directory "
$set_string(work_dir,' ');

return; end;

"******************************************************************************
subroutine egs_set_defaults;
"******************************************************************************
" Replaces BLOCK DATA "
implicit none;
$COMIN-SET-DEFAULTS;

integer  i,j,lnblnk1;
$TYPE MEDIA1(24); EQUIVALENCE(MEDIA1(1),MEDIA(1,1));
character fool_dec;
data MEDIA1/$S'NAI                     '/;
data fool_dec/'/'/;
data fool_intel_optimizer/.false./;

vacdst = 1e8;
$set-region-by-region-defaults;

eii_flag = 0; "No EII by default. "
eii_xfile = 'Off';
eii_L_factor = 1.0; "No L-shell EII xsection scaling by default"
"========================================="
"See egsnrc.macros for defaults used below"
"========================================="
xsec_out = $XSEC-DEFAULT;
photon_xsections = $XDATA-DEFAULT;"default photon xsection"
comp_xsections = $COMP-XDATA-DEFAULT;
eadl_relax = $EADL-RELAX-DEFAULT;
mcdf_pe_xsections = $MCDF-PE-DEFAULT;
"Ali:photonuc, 2 lines"
photonuc_xsections = $PHOTONUC-XDATA-DEFAULT;
"EMH:emf"
ExIN=$ExDEF;EyIN=$EyDEF;EzIN=$EzDEF;
" Initially set to input values, could change with regions"
" by converting it to an array over all regions. This is  "
" currently implemented ONLY for the C++ applications     "
BxIN=$BxDEF;ByIN=$ByDEF;BzIN=$BzDEF; EMLMTIN=$EMLMTDEF;
Bx=BxIN;    By=ByIN;    Bz=BzIN;
Bx_new=Bx;  By_new=By;  Bz_new=Bz;
emfield_on=.false.;
IF( ExIN**2+EyIN**2+EzIN**2 + BxIN**2+ByIN**2+BzIN**2 > 0 ) [
    emfield_on=.true.
]

DO i=1,$MXMED [
    iraylm(i) = 0; "Rayleigh data available?"
    DO j=1,len(iray_ff_file(i)) [ iray_ff_file(i)(j:j) = ' ';]
    DO j=1,len(iray_ff_media(i)) [ iray_ff_media(i)(j:j) = ' ';]
      " set all thresholds to zero "
    /ae(i),ap(i),ue(i),up(i),te(i),thmoll(i)/=0;
]
DO i=1,$MXSHXSEC [
  DO j=1,$MXELEMENT [ binding_energies(i,j) = 0; ]
]
ibrdst = $IBRDST-DEFAULT;      " brems angular sampling"
ibr_nist = $IBR-NIST-DEFAULT;  " flag for brems from NIST data base "
pair_nrc = $PAIR-NRC-DEFAULT;  " flag for pair from the NRC data base "
itriplet = $TRIPLET-DEFAULT;   " flag for triplet production "
iprdst = $IPRDST-DEFAULT;      " pair angular sampling "
rhof = 1;
DO i=1,5 [ iausfl(i) = 1; ]
"Ali:photonuc, line below already includes iarg=29,30"
DO i=6,$MXAUS [ iausfl(i) = 0; ]
ximax = $EXACT-BCA-XIMAX; estepe = $MAX-ELOSS;
skindepth_for_bca = $SKIN-DEPTH-FOR-BCA;
transport_algorithm = $TRANSPORT-ALGORITHM-DEFAULT;
bca_algorithm = $BCA-ALGORITHM-DEFAULT;
exact_bca = $EXACT-BCA-DEFAULT;
spin_effects = $SPIN-EFFECTS-DEFAULT;
count_pII_steps = 0; count_all_steps = 0;
radc_flag = 0;
nmed = $default_nmed;
kmpi = 12; kmpo = 8; dunit = 1;
rng_seed = 999999;
latchi = 0;

rmt2 = 2*rm; rmsq = rm*rm;

pi = 4*datan(1d0); twopi = 2*pi; pi5d2 = 2.5*pi;
nbr_split = 1;
i_play_RR = 0; i_survived_RR = 0; prob_RR = -1; n_RR_warning = 0;

$set_string(hen_house,' ');
i = lnblnk1($HEN_HOUSE);
hen_house(:i) = $HEN_HOUSE;
IF( $file_sep ~= fool_dec ) [
    DO j=1,i [
        IF( hen_house(j:j) = '/' ) hen_house(j:j) = $file_sep;
    ]
]
IF( hen_house(i:i) ~= $file_sep ) hen_house(i+1:i+1) = $file_sep;

n_files = 0;
$set_egs_home;
i = lnblnk1(egs_home);
IF( $file_sep ~= fool_dec ) [
    DO j=1,i [
        IF( egs_home(j:j) = '/' ) egs_home(j:j) = $file_sep;
    ]
]
IF( i > 0 & egs_home(i:i) ~= $file_sep ) egs_home(i+1:i+1) = $file_sep;
$set_string(input_file,' ');
$set_string(output_file,' ');
$set_string(work_dir,' ');
$set_string(pegs_file,' ');
$set_string(host_name,' ');
n_parallel = 0; i_parallel = 0; n_chunk = 0; is_batch = .false.;
first_parallel = 1;
return; end;

"*****************************************************************************
subroutine egs_combine_runs(combine_routine,extension);
"*****************************************************************************
" This subroutine loops over job number i from 1 to $max_unit,
" checks if the file output_file_wi.extension exists, and if yes,
" calls the external subroutine combine_routine with that file name.
"*****************************************************************************
implicit none;
external combine_routine;
character*(*) extension;
;COMIN/EGS-IO/;
character*1024 tmp_string,base,command,outfile,parfile_name,base1,
           text_string;
integer  lnblnk1,istat,ipar,egs_system,egs_open_file;
$INTEGER i,k,j,numparfiles,textindex;
$LOGICAL ex,iwin;

iwin=.false.; "start off assuming a non-Windows system"

$set_string(base,' ');
base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
       $cstring(output_file) // '_w';

"the following is to count the number of output files from"
"a parallel run"
$set_string(base1,' ');
base1 = $cstring(egs_home) // $cstring(user_code) // $file_sep //
       $cstring(output_file) // '_w*' // $cstring(extension);
$set_string(outfile,' ');
outfile = $cstring(egs_home) // $cstring(user_code) // $file_sep //
       'parfiles_tmp';
"try Unix/Linux first"
$set_string(command,' ');
command = 'ls ' // $cstring(base1) // ' | wc -l > ' // $cstring(outfile);
istat = egs_system($cstring(command));
IF(istat~=0)["now assume a Windows system"
   command = 'dir ' // $cstring(base1) // ' | find "File(s)" > ' //
   $cstring(outfile);
   istat = egs_system($cstring(command));
   IF(istat~=0)[
$egs_fatal(*,' Failed to write number of output files from parallel runs.');
   ]
   ELSE [
     iwin=.true.;
   ]
]

"now open parfiles_tmp and read the number of files"
ipar=1;
ipar=egs_open_file(ipar,0,1,$cstring(outfile));
IF(iwin)[
"need to do a bit of manipulation of a text string to get the number of files
  read(ipar,'(a)',err=:end_of_parfile:,end=:end_of_parfile:) text_string;
  text_string = $cstring(text_string);
  textindex = index(text_string,'File(s)');
  text_string = text_string(:textindex-1);
  read(text_string,'(i256)',err=:end_of_parfile:) numparfiles;
]
ELSE[
  read(ipar,'(i256)',err=:end_of_parfile:,end=:end_of_parfile:) numparfiles;
]
close(ipar);

"now remove parfiles_tmp"
$set_string(command,' ');

IF(iwin)[
   command = 'del /Q ' // $cstring(outfile);
]
ELSE[
   command = 'rm -f ' // $cstring(outfile);
]
istat = egs_system($cstring(command));
IF(istat~=0)[
   $egs_warning(*,' Failed to delete list of output files from parallel runs.');
]

k=1;
j=1;
WHILE(j<=numparfiles) [
     $set_string(tmp_string,' ');
     tmp_string = $cstring(base);
     call egs_itostring(tmp_string,k,.false.);
     tmp_string = $cstring(tmp_string) // $cstring(extension);
     inquire(file=tmp_string,exist=ex);
     IF( ex ) [
        call combine_routine(tmp_string);
        j=j+1;
     ]
     k=k+1;
]
return;

:end_of_parfile:
$egs_fatal(*,' Failed to read number of output files from parallel runs.');
end;

"******************************************************************************
$LOGICAL function egs_strip_extension(filen,fext);
"******************************************************************************
" Check if the string pointed to by filen ends with the string pointed to by
" fext and if yes, replace with blanks and return .true., otherwise return
" false.
"******************************************************************************
implicit none;
character*(*) filen,fext;
integer  l1,l2,lnblnk1,i;

l1 = lnblnk1(filen); l2 = lnblnk1(fext);
IF( l1 >= l2 & filen(l1-l2+1:l1) = fext(:l2) ) [
    egs_strip_extension = .true.;
    DO i=l1-l2+1,len(filen) [ filen(i:i) = ' '; ]
]
ELSE [ egs_strip_extension = .false.; ]
return; end;

"******************************************************************************
$LOGICAL function egs_is_absolute_path(fn);
"******************************************************************************
" Returns .true., if the string pointed to by fn is an absolute file name,
" .fale. otherwise.
"******************************************************************************
implicit none;
character*(*) fn;
integer  i,lnblnk1;
DO i=1,lnblnk1(fn) [
    IF( fn(i:i) = $file_sep ) [ egs_is_absolute_path = .true.; return; ]
]
egs_is_absolute_path = .false.; return; end;

"******************************************************************************
integer  function egs_get_unit(iunit);
"******************************************************************************
" Returns iunit, if the Fortran I/O unit iunit is not currently in use.
" Otherwise return the first free I/O unit found or -1 if none is available.
"******************************************************************************
implicit none;
$INTEGER iunit, i;
$LOGICAL is_open;

IF( iunit > 0 ) [
    inquire(iunit,opened=is_open);
    IF( ~is_open ) [ egs_get_unit = iunit; return; ]
]
DO i=1,$max_unit [
    inquire(i,opened=is_open);
    IF( ~is_open ) [ egs_get_unit = i; return; ]
]
egs_get_unit = -1; return; end;

"******************************************************************************
integer function egs_open_file(iunit,rl,action,extension);
"******************************************************************************
" Open a file trying to connect to Fortran I/O unit iunit.
" If iunit is already in use, connect to the first free I/O unit found.
" If no free I/O unit is found, then
"   - if action = 0, return -1.
"   - if action ~= 0, call the $egs_fatal macro.
" If extension is an absolute file name (including path), use extension
" as a file name, otherwise use output_file.extension in the temporary
" working directory as name. In both cases use status='unknown' to open the
" file. If rl = 0, open the file for formatted sequential access, otherwise
" open for unformatted direct access with record length = rl.
"******************************************************************************
implicit none;
$INTEGER iunit, rl, action;
character*(*) extension;
;COMIN/EGS-IO/;
$LOGICAL egs_is_absolute_path,is_open;
integer  egs_get_unit;
integer  i,lnblnk1;
character*1024 tmp_string,error_string;
$INTEGER the_unit;
$declare_write_buffer;

egs_open_file = -1; "so that the DEC compiler does not complain that"
                    "the function has an undefined values in some of"
                    "the excution paths (where exit(1) is called."
the_unit = egs_get_unit(iunit);
IF( the_unit < 0 ) [
    IF( action = 0 ) [ egs_open_file = -1; return; ]
    $egs_fatal(*,'No free Fortran I/O units left');
]

IF( egs_is_absolute_path(extension) ) [
    inquire(file=extension,opened=is_open);
    IF(is_open)[
        inquire(file=extension,number=the_unit);
        $egs_warning('(a,a,/,a,i3,/,a,/,a)',
             'File ',$cstring(extension),
             ' is already opened and connected to unit ',the_unit,
             ' Will not try to re-open this file, assuming it has been opened',
             ' by the .io file.');
    ]
    ELSE IF( rl = 0 ) [
        open(the_unit,file=extension,status='unknown');
    ]
    ELSE [
        open(the_unit,file=extension,status='unknown',form='unformatted',
             access='direct', recl=rl);
    ]
    egs_open_file = the_unit; return;
]

$set_string(tmp_string,' ');
tmp_string = $cstring(egs_home) // $cstring(user_code) // $file_sep //
             $cstring(work_dir) // $cstring(output_file);
IF( i_parallel > 0 ) [
    tmp_string = $cstring(tmp_string) // '_w';
    call egs_itostring(tmp_string,i_parallel,.false.);
]
tmp_string = $cstring(tmp_string) // $cstring(extension);

inquire(file=tmp_string,opened=is_open);
IF(is_open)[
    inquire(file=tmp_string,number=the_unit);
    $egs_warning('(a,a,/,a,i3,/,a,/,a,/)',
             'File ',$cstring(tmp_string),
             ' is already opened and connected to unit ',the_unit,
             ' Will not try to re-open this file, assuming it has been opened',
             ' by specifying it in the .io file.');
]
ELSE IF( rl = 0 ) [
    open(the_unit,file=tmp_string,status='unknown',err=:open_error:);
]
ELSE [
    open(the_unit,file=tmp_string,status='unknown',form='unformatted',
         access='direct', recl=rl,err=:open_error:);
]
egs_open_file = the_unit; return;

:open_error:
error_string = 'In egs_open_file: failed to open file ' // $cstring(tmp_string)
      // char(10) // 'iunit = ';
call egs_itostring(error_string,iunit,.false.);
error_string = $cstring(error_string) // ' the_unit = ';
call egs_itostring(error_string,the_unit,.false.);
$egs_fatal('(a)',$cstring(error_string));
end;


"******************************************************************************
integer  function egs_open_datfile(iunit,rl,action,extension);
"******************************************************************************
"
" Open an existing 'data' file.
" First try to connect the file to Fortran unit iunit, but if iunit is
" already in use, use the first free unit instead.
" extension is the datafile extension (e.g. '.egsdat') .
" The algorithm for searching for the file is as follows:
"  1. If extension is an absolute file name (including path),
"     try opening this file, else
"  2. Try output_file.extension in the user code directory.
"  3. Try input_file.extension in the user code directory (if input_file is
"     different from output_file).
" If the file is found, open it using status='old' for
"   a) formatted sequential access, if rl=0
"   b) unformatted direct access with record length = rl, if rl > 0.
"
" Return value:
"   - if all is OK, return the opened unit number
"   - if something fails, then
"       * if action = 0, return error code less than 0.
"       * if action != 0, call the $egs_fatal macro with an error message.
"
"******************************************************************************
implicit none;
$INTEGER iunit,rl,action;
character*(*) extension;

;COMIN/EGS-IO/;

integer  i,the_unit,lnblnk1,egs_get_unit;
$LOGICAL egs_is_absolute_path;
character base*1024, fn*1024;
$declare_write_buffer;

egs_open_datfile = -1; "so that the DEC compiler does not complain that"
                    "the function has an undefined values in some of"
                    "the excution paths (where exit(1) is called."
the_unit = egs_get_unit(iunit);
IF( the_unit < 0 ) [
    IF( action = 0 ) [ egs_open_datfile = -1; return; ]
    $egs_fatal(*,'No free Fortran I/O units left');
]

IF( egs_is_absolute_path(extension) ) [
    IF( rl = 0 ) [
        open(the_unit,file=extension,status='old',err=:no_datfile_0:);
    ]
    ELSE [
        open(the_unit,file=extension,status='old',form='unformatted',
              access='direct',recl=rl,err=:no_datfile_0:);
    ]
    egs_open_datfile = the_unit; return;

    :no_datfile_0:;
    IF( action = 0 ) [ egs_open_datfile = -2; return; ]
    $egs_fatal(*,'Failed to open file ',$cstring(extension));
]

$set_string(base,' '); $set_string(fn,' ');
base = $cstring(egs_home) // $cstring(user_code) // $file_sep;
"fn = $cstring(base) // $cstring(output_file) // $cstring(extension);"
IF( i_parallel > 0 ) [
    fn = $cstring(base) // $cstring(output_file) // '_w';
    call egs_itostring(fn,i_parallel,.false.);
    fn = $cstring(fn) // $cstring(extension);
]
ELSE [
    fn = $cstring(base) // $cstring(output_file) // $cstring(extension);
]
IF( rl = 0 ) [
    open(the_unit,file=fn,status='old',err=:no_datfile_1:);
]
ELSE [
    open(the_unit,file=fn,status='old',form='unformatted',access='direct',
         recl=rl,err=:no_datfile_1:);
]
egs_open_datfile = the_unit; return;

:no_datfile_1:;
$egs_warning('(a,a)','Failed to open ',$cstring(fn));
$set_string(fn,' ');
"fn = $cstring(base) // $cstring(input_file) // $cstring(extension);"
IF( i_parallel > 0 ) [
    fn = $cstring(base) // $cstring(input_file) // '_w';
    call egs_itostring(fn,i_parallel,.false.);
    fn = $cstring(fn) // $cstring(extension);
]
ELSE [
    fn = $cstring(base) // $cstring(input_file) // $cstring(extension);
]
IF( rl = 0 ) [
    open(the_unit,file=fn,status='old',err=:no_datfile_2:);
]
ELSE [
    open(the_unit,file=fn,status='old',form='unformatted',access='direct',
         recl=rl,err=:no_datfile_2:);
]
egs_open_datfile = the_unit; return;

:no_datfile_2:;
$egs_fatal(*,'Failed to open data file');
end;

"******************************************************************************
integer  function egs_open_file_junk(iunit,do_it_anyway,filen);
"******************************************************************************
" Open the file filen for sequential formatted I/O and return the unit
" number it was connected to.
" If iunit ~= 0, try to connect to unit |iuniti|, otherwise
" use the first unconnected unit found.
" If iunit > 0
"    open the unit even if it was already open, if do_it_anyway is .true.,
"    otherwise return -4.
" If iunit < 0
"    if the unit |iunit| is already in use and do_it_anyway is .true.,
"    search for the first available unit, otherwise return -4.
" Return values:
"   unit number, if the file was succesfully opened.
"   -1, if there was no free unit numer to connect to.
"   -2, if the file does not exist.
"   -3, if the file exist, but could not be opened.
"   -4, if |iunit|>0 & do_it_anyway=.false. and |iunit| is already in use.
"******************************************************************************
implicit none;
$INTEGER iunit;
$LOGICAL do_it_anyway;
character*(*) filen;

$LOGICAL aux;
$INTEGER the_unit,i;

inquire(file=filen,exist=aux);
IF( ~aux ) [ egs_open_file_junk = -2; return; ]
IF( iunit < 0 ) [ the_unit = -iunit; ] ELSE [ the_unit = iunit; ]
IF( the_unit ~= 0 ) [
    inquire(unit=the_unit,opened=aux);
    IF( aux ) [
        IF( ~do_it_anyway ) [ egs_open_file_junk = -4; return; ]
        IF( iunit < 0 ) the_unit = 0;
    ]
]
IF( the_unit = 0 ) [
    DO i=1,$max_unit [
        inquire(unit=i,opened=aux);
        IF( ~aux ) [ the_unit = i; EXIT; ]
    ]
    IF( the_unit = 0 ) [ egs_open_file_junk = -1; return; ]
]
open(the_unit,file=filen,status='old',err=:failed_to_open:);
egs_open_file_junk = the_unit; return;
:failed_to_open:
egs_open_file_junk = -3; return; end;

"==============================================================================
subroutine egs_strip_path(fname);
"==============================================================================
" Strip the path name from fname (if any)
implicit none;
character*(*) fname;
integer  i,l,l1,lnblnk1,j;
character slash;
slash = '/';
l = lnblnk1(fname);
DO i=1,l [
    IF( fname(i:i) = slash ) [ fname(i:i) = $file_sep; ]
]
DO i=l,1,-1 [
    IF( fname(i:i) = $file_sep | fname(i:i) = slash ) [
        l1 = l-i;
        fname(:l1) = fname(i+1:l);
        DO j=l1+1,len(fname) [ fname(j:j) = ' '; ]
        return;
    ]
]
return; end;

"==============================================================================
subroutine replace_env(fname);
"==============================================================================
"subroutine to replace environment variables (beginning with $) with their"
"full names or ~ with the full name of $HOME"
"Assumes environment variable or ~ appears only at the beginning of the"
"file name"

;COMIN/EGS-IO/;

character*(*) fname;
character*256 dirname;
integer indsep,ind1,ind2;

indsep = index(fname,$file_sep);
IF(indsep <= 0) return;
"hope that the user has just supplied the file name"
"and it is in the current directory"

ind1=index(fname,'$');
ind2=index(fname,'~');

"examine first character of name"
IF(ind1=1)[
    "get the environment variable"
    call getenv(fname(2:indsep-1),dirname);
    IF(dirname=' ')[
      $egs_fatal('(a,a/,a)',' Error in file name: ',$cstring(fname),
  ' First element in name does not specify a defined environment variable.');
   ]
   fname=$cstring(dirname)//fname(indsep:);
   $egs_info('(//a,a/)',' Retrieving file: ',$cstring(fname));
]
ELSEIF(ind2=1)[
    call getenv('HOME',dirname);
    IF(dirname=' ')[
      $egs_fatal('(a,a/,a)',' Error in file name: ',$cstring(fname),
  ' HOME is undefined.');
   ]
   fname=$cstring(dirname)//fname(indsep:);
   $egs_info('(//a,a/)',' Retrieving file: ',$cstring(fname));
]
return;
end;

"=============================================================================
subroutine egs_get_usercode(ucode);
"=============================================================================
" Deduct the user code name from the executable name
" The algorithm assumes that the executable is called
"   xxx[_debug|noopt][.exe]
" and it will fail if this is not the case.
"=============================================================================
implicit none;
COMIN/EGS-IO/;
character*(*) ucode;
character*512 arg;
integer  l,l1,lnblnk1,i;
$declare_write_buffer;

call getarg(0,arg); call egs_strip_path(arg);
l = lnblnk1(arg);
IF( arg(l-3:l) = '.exe' ) [
    arg(l-3:l) = ' '; l = l - 4;
]
IF( arg(l-5:l) = '_debug' ) [
    arg(l-5:l) = ' '; l = l-5;
]
IF( arg(l-5:l) = '_noopt' ) [
    arg(l-5:l) = ' '; l = l-5;
]
l1 = len(ucode);
IF( l > l1 ) [
    $egs_fatal(*,' user code name is too long (',l,' chars)');
]
$set_string(ucode,' '); ucode(:l) = arg(:l);
return; end;

subroutine egs_itostring(string,i,leave_space);
implicit none;
character*(*) string;
$INTEGER i;
integer  l,lnblnk1,idiv,itmp,iaux;
$LOGICAL first,leave_space;
l = lnblnk1(string)+1; IF( l > 1 & leave_space ) l=l+1;
idiv = 1000000000; itmp = i; first = .false.;
do while(idiv.gt.0) ;
    iaux = itmp/idiv;
    IF( (iaux > 0 | first ) & l <= len(string) ) [
        string(l:l) = char(iaux+48); first = .true.; l = l+1;
    ]
    itmp = itmp - iaux*idiv; idiv = idiv/10;
end do;
return; end;

"=============================================================================
$REAL function egs_rndm();
"=============================================================================
implicit none;
;COMIN/RANDOM/;
$RANDOMSET egs_rndm;
return; end;

"=============================================================================
integer  function egs_add_medium(medname);
implicit none;
character*(*) medname;
$declare_max_medium;
;COMIN/MEDIA,EGS-IO/;
$INTEGER i,l,imed,medname_len;
character c;
$LOGICAL  same;
$declare_write_buffer;

l = min(len(medname),24); medname_len = l;
DO i=1,l [
    c = medname(i:i);
    IF( ichar(c) = 0 ) [ medname_len = i-1; EXIT; ]
]
DO imed=1,nmed [
    l = 24;
    DO i=1,24 [
        IF( media(i,imed)(1:1) = ' ' ) [ l = i-1; EXIT; ]
    ]
    IF( l = medname_len ) [
        same = .true.;
        DO i=1,l [
            c = medname(i:i);
            IF( c ~= media(i,imed)(1:1) ) [ same = .false.; EXIT; ]
        ]
        IF( same ) [
            egs_add_medium = imed; return;
        ]
    ]
]
nmed = nmed + 1;
IF( nmed > $MXMED ) [
  $egs_fatal('(a,/,a,i3,a)',
    'In egs_add_medium: maximum number of media exceeded ',
    'Increase the macro $MXMED (currently ',$MXMED,') and retry');
]
l = min(len(medname),24);
DO i=1,l [
    c = medname(i:i);
    IF( ichar(c) = 0 ) [ l = i-1; EXIT; ]
    media(i,nmed) = ' ';
    media(i,nmed)(1:1) = c;
]
IF( l < 24 ) [
    DO i=l+1,24 [ media(i,nmed) = ' '; ]
]
egs_add_medium = nmed;
return; end;

subroutine egs_get_medium_name(imed,medname);
implicit none;
character*(*) medname;
$declare_max_medium;
;COMIN/MEDIA,EGS-IO/;
$INTEGER i,l,imed;
DO i=1,len(medname) [ medname(i:i) = ' '; ]
IF( imed < 1 | imed > nmed ) [ return; ]
l = 24;
DO l=24,1,-1 [
    IF( media(l,imed)(1:1) ~= ' ' ) EXIT;
]
l = min(l,len(medname));
DO i=1,l [ medname(i:i) = media(i,imed)(1:1); ]
return; end;
;

"============================================================================"
"  Pass pointers to the cross section interpolation coefficients to          "
"  an external subroutine                                                    "
"============================================================================"
subroutine egs_get_electron_data(func,imed,which);
implicit none;
$INTEGER imed,which;
external func;
$declare_max_medium;
;COMIN/ELECIN,MEDIA,EGS-IO/;
$REAL    lemin,lemax;

lemin = (1 - eke0(imed))/eke1(imed);
lemax = (meke(imed) - eke0(imed))/eke1(imed);
    IF( which = 1 ) [
    call func(meke(imed),lemin,lemax,esig0(1,imed),esig1(1,imed));
] ELSE IF( which = 2 ) [
    call func(meke(imed),lemin,lemax,psig0(1,imed),psig1(1,imed));
] ELSE IF( which = 3 ) [
    call func(meke(imed),lemin,lemax,ededx0(1,imed),ededx1(1,imed));
] ELSE IF( which = 4 ) [
    call func(meke(imed),lemin,lemax,pdedx0(1,imed),pdedx1(1,imed));
] ELSE IF( which = 5 ) [
    call func(meke(imed),lemin,lemax,ebr10(1,imed),ebr11(1,imed));
] ELSE IF( which = 6 ) [
    call func(meke(imed),lemin,lemax,pbr10(1,imed),pbr11(1,imed));
] ELSE IF( which = 7 ) [
    call func(meke(imed),lemin,lemax,pbr20(1,imed),pbr21(1,imed));
] ELSE IF( which = 8 ) [
    call func(meke(imed),lemin,lemax,tmxs0(1,imed),tmxs1(1,imed));
] ELSE IF( which = 9 ) [
    call func(meke(imed),lemin,lemax,range_ep(0,1,imed),range_ep(1,1,imed));
] ELSE [
    $egs_fatal(*,'Unknown electron data type ',which);
]
return; end;

subroutine egs_get_photon_data(func,imed,which);
implicit none;
$INTEGER imed,which;
external func;
$declare_max_medium;
;COMIN/PHOTIN,MEDIA,EGS-IO/;
$REAL    lemin,lemax;

lemin = (1 - ge0(imed))/ge1(imed);
lemax = (mge(imed) - ge0(imed))/ge1(imed);
IF( which = 1 ) [
    call func(mge(imed),lemin,lemax,gmfp0(1,imed),gmfp1(1,imed));
] ELSE IF( which = 2 ) [
    call func(mge(imed),lemin,lemax,gbr10(1,imed),gbr11(1,imed));
] ELSE IF( which = 3 ) [
    call func(mge(imed),lemin,lemax,gbr20(1,imed),gbr21(1,imed));
] ELSE IF( which = 4 ) [
    call func(mge(imed),lemin,lemax,cohe0(1,imed),cohe1(1,imed));
] ELSE IF( which = 5 ) [
    call func(mge(imed),lemin,lemax,PHOTONUC0(1,imed),PHOTONUC1(1,imed));
] ELSE [
    $egs_fatal(*,'Unknown photon data type ',which);
]
return; end;

/* Print binding energies: In the case of the EPDL library
   only energies above 1 keV are output for elements not part
   of the current simlation. This is due to the fact that energies
   below 1 keV are taken from the relaxation database only for
   elements requested in the input when EPDL is used. This is not
   an issue when using XCOM.
 */
subroutine egs_print_binding_energies;
implicit none;
$declare_max_medium;
;COMIN/EDGE,MEDIA,EGS-IO/;
$INTEGER    i,j;
integer*4   lnblnk1;
character*3 labels(16);
data labels/'  K',' L1',' L2',' L3',
            ' M1',' M2',' M3',' M4',' M5',
            ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/;

$egs_info('(a,a,a)',
        'Binding energies from ',$cstring(photon_xsections),
        ' photon cross section library');
DO j = 1,$MXELEMENT [
   DO i = 1,$MXPESHELL [
      IF ( binding_energies(i,j) > 0 ) [
         $egs_info('(a,i3,a,a,a,1pe12.4,a)',
         ' Eb(',j,',',labels(i),') = ',binding_energies(i,j),' MeV');
      ]
   ]
]

return;end;


"============================================================================="
"  scale elastic scattering strength by a given factor                        "
"============================================================================="
subroutine egs_scale_xcc(imed,factor);
implicit none;
$INTEGER imed;
$REAL    factor;
$declare_max_medium;
;COMIN/ELECIN,MEDIA/;
IF( imed > 0 & imed <= nmed ) [ xcc(imed) = xcc(imed)*factor; ]
return; end;


"============================================================================"
subroutine egs_write_string(ounit,string);
implicit none;
$INTEGER ounit;
character*(*) string;
write(ounit,'(a,$)') string;
$FLUSH_UNIT(ounit);
return; end;


"============================================================================"
subroutine egs_swap_2(c);
"============================================================================"
" Convert a 2 byte object from little endian to big endian byte order        "
" or vice versa                                                              "
character  c(2),tmp;
tmp=c(2); c(2)=c(1); c(1)=tmp;
return; end;

"============================================================================"
subroutine egs_swap_4(c);
"============================================================================"
" Convert a 2 byte object from little endian to big endian byte order        "
" or vice versa                                                              "
character  c(4),tmp;
tmp=c(4); c(4)=c(1); c(1)=tmp;
tmp=c(3); c(3)=c(2); c(2)=tmp;
return; end;


"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
" Utility subroutines and functions previously in egsnrc.mortran
"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

%E
subroutine set_spline(x,f,a,b,c,d,n);
"======================================================================"
"
" Sets cubic spline interpolation coefficients for the data contained  "
" in the array f(n) at the abscissas x(n)                              "
"                                                                      "
" I.Kawrakow, NRC                                                      "
"======================================================================"

implicit none;

$INTEGER n;
$REAL    x(n),f(n),a(n),b(n),c(n),d(n);

$INTEGER m1,m2,m,mr;
$REAL    s,r;

m1 = 2; m2 = n-1; s = 0;
DO m=1,m2 [
    d(m) = x(m+1) - x(m); r = (f(m+1) - f(m))/d(m);
    c(m) = r - s; s = r;
]
/s,r,c(1),c(n)/=0;
DO m=m1,m2 [
    c(m) = c(m) + r*c(m-1);
    b(m) = 2*(x(m-1) - x(m+1)) - r*s;
    s = d(m); r = s/b(m);
]
mr = m2;
DO m=m1,m2 [
    c(mr) = (d(mr)*c(mr+1) - c(mr))/b(mr);
    mr = mr - 1;
]
DO m=1,m2 [
    s = d(m); r = c(m+1) - c(m); d(m) = r/s;
    c(m) = 3*c(m);
    b(m) = (f(m+1)-f(m))/s - (c(m)+r)*s;
    a(m) = f(m);
]
return; end;
;

$REAL function spline(s,x,a,b,c,d,n);
"======================================================================"
"                                                                      "
" Returns the value of the function at s using the spline coefficients "
" a,b,c,d, which must have been set using set_spline                   "
"                                                                      "
" I.Kawrakow, NRC                                                      "
"======================================================================"

implicit none;

$INTEGER n;
$REAL    s,x(n),a(n),b(n),c(n),d(n);

integer  m_lower,m_upper,direction,m,ml,mu,mav;
$REAL    q;

IF( x(1) > x(n) ) [ direction = 1; m_lower = n; m_upper = 0; ]
ELSE              [ direction = 0; m_lower = 0; m_upper = n; ]
IF ( s >= x(m_upper + direction) ) [
    m = m_upper + 2*direction - 1;
]
ELSE IF( s <= x(m_lower+1-direction) ) [
    m = m_lower - 2*direction + 1;
]
ELSE [   " Perform a binary search to find the interval s is in "
    ml = m_lower; mu = m_upper;
    WHILE ( iabs(mu-ml) > 1 ) [
        mav = (ml+mu)/2;
        IF( s < x(mav) ) [ mu = mav; ]
        ELSE             [ ml = mav; ]
    ]
    m = mu + direction - 1;
]
q = s - x(m);
spline = a(m) + q*(b(m) + q*(c(m) + q*d(m)));
return; end;
;

%E "start of prepare_alias_table subroutine"
"****************************************************************************

subroutine prepare_alias_table(nsbin,xs_array,fs_array,ws_array,ibin_array);

" Prepare an alias sampling table, given the histogram probabilities
" xs_array,fs_array.
"*****************************************************************************
implicit none;

integer   nsbin;
$INTEGER  ibin_array(nsbin);
$REAL     xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin);

$INTEGER  i,j_l,j_h;
$REAL     sum,aux;

sum = 0;
DO i=1,nsbin [
    aux = 0.5*(fs_array(i)+fs_array(i-1))*(xs_array(i)-xs_array(i-1));
    IF( aux < 1e-30 ) aux = 1e-30;
    ws_array(i) = -aux; ibin_array(i) = 1;
    sum = sum + aux;
]
sum = sum/nsbin;

DO i=1,nsbin-1 [

    DO j_h = 1,nsbin [
        IF( ws_array(j_h) < 0 ) [
            IF( abs(ws_array(j_h)) > sum ) GOTO :AT_EXIT_1:;
        ]
    ]
    j_h = nsbin;
    :AT_EXIT_1:

    DO j_l = 1,nsbin [
        IF( ws_array(j_l) < 0 ) [
            IF( abs(ws_array(j_l)) < sum ) GOTO :AT_EXIT_2:;
        ]
    ]
    j_l = nsbin;
    :AT_EXIT_2:

    aux = sum - abs(ws_array(j_l));
    ws_array(j_h) = ws_array(j_h) + aux;
    ws_array(j_l) = -ws_array(j_l)/sum;
    ibin_array(j_l) = j_h;
    IF( i = nsbin-1 ) ws_array(j_h) = 1;

]

return; end;
;

%E   " start of alias_sample1 function "
"******************************************************************************

$REAL function alias_sample1(nsbin,xs_array,fs_array,ws_array,ibin_array);

" Sample a random variable from the alias table
"    xs_array,fs_array,ws_array,ibin_array
" which must have been prepared with prepare_alias_table
"
"******************************************************************************
implicit none;

integer   nsbin;
$INTEGER  ibin_array(nsbin);
$REAL     xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin);

;COMIN/RANDOM/;

$INTEGER j;
$REAL    r1,r2,aj,x,dx,a,rnno1;

$RANDOMSET r1; $RANDOMSET r2;
aj = 1 + r1*nsbin; j = aj; aj = aj - j;
IF( aj > ws_array(j) ) j = ibin_array(j);
x = xs_array(j-1); dx = xs_array(j)-x;
IF( fs_array(j-1) > 0 ) [
    a = fs_array(j)/fs_array(j-1)-1;
    IF( abs(a) < 0.2 ) [
        rnno1 = 0.5*(1-r2)*a;
        alias_sample1 = x + r2*dx*(1+rnno1*(1-r2*a));
    ]
    ELSE [
        alias_sample1 = x - dx/a*(1-sqrt(1+r2*a*(2+a)));
    ]
]
ELSE [
    alias_sample1 = x + dx*sqrt(r2);
]
return; end;
;

%E   " start of prepare_alias_histogram routine "
subroutine prepare_alias_histogram(nsbin,ws_array,ibin_array);
"*************************************************************
"                                                                           "
" Prepares an alias histogram for the probability array ws_array of         "
" dimension nsbin.                                                          "
" On return, the ws_array is modified and contains the alias weights,       "
" ibin_array holds the alias indices.                                       "
" To be used with the integer function sample_alias_histogram, which        "
" returns a bin index j with probability ws_array(j)                        "
"                                                                           "
" Iwan Kawrakow, November 2001
"***************************************************************************"

implicit none;

$INTEGER  nsbin,ibin_array(nsbin);
$REAL     ws_array(nsbin);

$INTEGER  i,j_l,j_h;
$REAL     sum,aux;

sum = 0;
DO i=1,nsbin [
    sum = sum + ws_array(i); ibin_array(i) = -1;
]
sum = sum/nsbin;

DO i=1,nsbin-1 [

    DO j_h = 1,nsbin [
        IF( ibin_array(j_h) < 0 & ws_array(j_h) > sum ) EXIT;
    ]

    DO j_l = 1,nsbin [
        IF( ibin_array(j_l) < 0 & ws_array(j_l) < sum ) EXIT;
    ]

    aux = sum - ws_array(j_l);
    ws_array(j_h) = ws_array(j_h) - aux;
    ws_array(j_l) = ws_array(j_l)/sum;
    ibin_array(j_l) = j_h;

]

DO i=1,nsbin [
    IF( ibin_array(i) < 0 ) [
        ibin_array(i) = i; ws_array(i) = 1;
    ]
]

return;
end;

%E   " start of sample_alias_histogram function "
$INTEGER function sample_alias_histogram(nsbin,ws_array,ibin_array);
"***********************************************************************
"
" This function samples a bin index using the alias sampling technique.
" The arrays ws_array and ibin_array of dimension nsbin must have been
" prepared with the subroutine prepare_alias_histogram.
"
" Iwan Kawrakow, November 2001.
"***********************************************************************

implicit none;

$INTEGER  nsbin,ibin_array(*);
$REAL     ws_array(*);

;COMIN/RANDOM/;

$REAL    r1,r2;
$INTEGER ibin;

$RANDOMSET r1; $RANDOMSET r2;
ibin = 1 + nsbin*r1;
IF( r2 > ws_array(ibin) ) ibin = ibin_array(ibin);
sample_alias_histogram = ibin;
return;
end;

%E   " start of gauss_legendre subroutine "
"******************************************************************************

subroutine gauss_legendre(x1,x2,x,w,n);

"     Given the lower and upper limit of integration, x1 and x2,
"     and given n, this routine returns arrays x and w,
"     containing the abscissas and weights of the Gauss-Legendre
"     n - point quadrature formula
"
"******************************************************************************
$IMPLICIT-NONE;

$INTEGER n;
real*8   x1,x2,x(n),w(n);

real*8     eps,Pi;
parameter (eps = 3.D-14, Pi = 3.141592654D0);

$INTEGER i,m,j;
real*8   xm,xl,z,z1,p1,p2,p3,pp;

m = (n + 1)/2;
xm=0.5d0*(x2+x1); xl=0.5d0*(x2-x1);
DO i=1,m [
    z=cos(Pi*(i-.25d0)/(n+.5d0));
    LOOP [
        p1=1.d0; p2=0.d0;
        DO j=1,n [
            p3 = p2; p2 = p1;
            p1=((2.d0*j-1.d0)*z*p2-(j-1.d0)*p3)/j;
        ]
        pp=n*(z*p1-p2)/(z*z-1.d0);
        z1=z; z=z1-p1/pp;
    ] UNTIL (abs(z-z1) < eps);
    x(i)=xm-xl*z; x(n+1-i)=xm+xl*z;
    w(i)=2.d0*xl/((1.d0-z*z)*pp*pp); w(n+1-i)=w(i);
]
return; end;
;

%E   " start of lnblnk1 function"
"******************************************************************************

integer  function lnblnk1(string);

"Function to return index of last non-blank character in a string"
"We use this instead of lnblnk because there are compilers"
"that do not have lnblnk"

"******************************************************************************
character*(*) string;
integer i;
DO i=len(string),1,-1 [
    j = ichar(string(i:i));
    IF( j = 0 ) [ lnblnk1 = i-1; return; ] "i.e. the same as strlen for "
                                           "0-terminated C-strings"
    IF( j ~= 9 & j ~= 10 & j ~= 11 & j ~= 12 & j ~= 13 & j ~= 32 ) [
        lnblnk1 = i; return;
    ]
]
lnblnk1 = 0; return; end;

%E   " start of erf1 function "
"************************************************************************
"       an error function routine which is needed since some of
"       the compiler don't have it as an intrinsic
"
"       Originally came from some library somewhere (Harwell I think)
"       recoded in mortran
"************************************************************************

$REAL FUNCTION ERF1(X);

$IMPLICIT-NONE;

$REAL x;

double precision A(0:22,2);     " Coefficients in expansion for erf(x) if x<3
                                " (K=1) and for erfc(x) x>3 (K=2)
double precision
       CONST,                   " 2/sqrt(pi)
       BN,BN1,BN2,              " Recursion coefficients B(n),B(n+1),B(n+2)
       Y,FAC;                   " y=x/3 or 3/x and FAC = 2(2y**2-1)
$INTEGER N,                     " recursion index n
         K,                     " K=1,2 for x <= 3 or x > 3
         NLIM(2);               " Maximum value of n in sum for K=1,2

DATA A/  1.0954712997776232 , -0.2891754011269890 ,  0.1104563986337951 ,
        -0.0412531882278565 ,  0.0140828380706516 , -0.0043292954474314 ,
         0.0011982719015923 , -0.0002999729623532 ,  0.0000683258603789 ,
        -0.0000142469884549 ,  0.0000027354087728 , -0.0000004861912872 ,
         0.0000000803872762 , -0.0000000124184183 ,  0.0000000017995326 ,
        -0.0000000002454795 ,  0.0000000000316251 , -0.0000000000038590 ,
         0.0000000000004472 , -0.0000000000000493 ,  0.0000000000000052 ,
        -0.0000000000000005 ,  0.0000000000000001 ,
         0.9750834237085559 , -0.0240493938504146 ,  0.0008204522408804 ,
        -0.0000434293081303 ,  0.0000030184470340 , -0.0000002544733193 ,
         0.0000000248583530 , -0.0000000027317201 ,  0.0000000003308472 ,
         0.0000000000001464 , -0.0000000000000244 ,  0.0000000000000042 ,
        -0.0000000000000008 ,  0.0000000000000001 ,  9*0.0              /;

DATA NLIM/ 22,16 /;
DATA CONST/ 1.128379167095513 /;

IF( x > 3 ) [ y = 3/x; k = 2; ]
ELSE        [ y = x/3; k = 1; ]

" Calculate sum of Chebyshev polynomials by backwards recursion
"
"       sum { A(n)*T(2n+1;y) : n=0,N } = y * ( B(0) - B(1) )
"       sum { A(n)*T(2n;y)   : n=0,N } = ( B(0) - (2*y**2-1) * B(1) ) / 2
"                                      = ( B(0) - B(2) + A(0) ) / 2
"
"       where B(N+2) = B(N+1) = 0
"       and B(n) = 2*(2*y**2-1)*B(n+1) - B(n+2) + A(n) for n=N,(N-1),...,1,0
"
FAC = 2.0 * ( 2.0 * Y*Y - 1.0 );
BN1 = 0.0;                       " Initialise B(N+2) = 0
BN  = 0.0;                       " Initialise B(N+1) = 0

DO n = NLIM(K),0,-1 [
   BN2 = BN1; BN1 = BN;
   BN = FAC * BN1 - BN2 + A(N,K)
]

IF ( k = 1 ) [ erf1 = CONST * Y * ( BN - BN1 ); ]
ELSE       [ erf1 = 1 - CONST * EXP(-X**2) * ( BN - BN2 + A(0,K) )/(4.0 * X); ]

RETURN;
end;

%E   " start of zero function "
"********************************************************"
"   Finds minimum non-zero value which can be used for   "
"   evaluating logarithms without getting a NAN.         "
"                                                        "
" Starting with 10^-20 and decreasing it by 5 orders of  "
" magnitud at a time, a check is made until the compiler "
" recognizes the number as zero and the previous number  "
" used. The same procedure is applied to this number but "
" decreasing it by one order of magnitud. Finally it is  "
" divided by 2..10 until the zero-check is successful.   "
"********************************************************"
$REAL FUNCTION ZERO();
$IMPLICIT-NONE;

$INTEGER i;
$REAL    x, xtemp;

x = 1.E-20;
"jump over 5 orders of magnitude"
DO i=1,100[
   IF (x = 0.0) [EXIT;]
   ELSE[xtemp = x;]
   x = x/1.E5;
]
x = xtemp;
"jump over 1 order of magnitude"
DO i=1,5[
   IF (x ~= 0.0)[xtemp = x;]
   ELSE[EXIT;]
   x = x/10;
]
x = xtemp;
"divide it up by 2...10"
DO i=2,10[
   IF (x ~= 0.0)[xtemp = x;]
   ELSE[EXIT;]
   x = x/i;
]
zero = xtemp;
return;end;
;

%E   " start of toUpper function "
"**************************************"
                                       "
"   Converts a string to upper case.   "
"                                      "
"**************************************"
character*512 function toUpper(a_string);
character*(*) a_string;
character*512 the_string;
$INTEGER cursor, i, lnblnk1;
toUpper = a_string; the_string = a_string;
DO i=1, lnblnk1(the_string) [
   cursor=ICHAR(the_string(i:i));
   IF ((cursor.GE.97).AND.(cursor.LE.122)) [
        cursor=cursor-32;toUpper(i:i)=CHAR(cursor);
   ]
]
return; end;
;

/***********************************************************************
   Tools for reading C/C++ binary files (byte-oriented) in Fortran.
   Note that with gfortran one could use access=stream, but this is not
   available in GNU g77. So, to preserve backwards compatibility we have
   created these tools.
 ************************************************************************/

"================================================================="
 integer*1 function egs_read_byte(iunit, jrec);
"================================================================="
" Reads one byte from a C/C++ binary file at jrec position        "
 implicit none;
 integer iunit, jrec, i, j, ierr;
 integer*1 i_1;
 character c_1;
 equivalence (i_1,c_1);
;COMIN/EGS-IO/;
 read(iunit,rec=jrec,IOSTAT=ierr) c_1;
 IF (ierr.ne.0) [
    $egs_warning(*,' *** egs_read_byte: ERROR READING A byte *** ');
    $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
    egs_read_byte = -1; return;
 ]
 jrec = jrec + 1; egs_read_byte = i_1;
 return; end;

"================================================================="
 integer*2 function egs_read_short(iunit, jrec);
"================================================================="
" Reads short int from a C/C++ binary file at jrec position        "
 implicit none;
 integer iunit, jrec, i, j, ierr;
 integer*2 i_2;
 character c_2(2);
 equivalence (i_2,c_2);
;COMIN/EGS-IO/;
 j = 0;
 DO i=jrec,jrec+1[
  j = j + 1;
  read(iunit,rec=i,IOSTAT=ierr) c_2(j);
  IF (ierr.ne.0) [
    $egs_warning(*,' *** egs_read_short: ERROR READING short integer *** ');
    $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
    egs_read_short = -1; return;
  ]
 ]
 jrec = jrec + 2; egs_read_short = i_2;
 return; end;

"================================================================="
 integer*4 function egs_read_int(iunit, jrec);
"================================================================="
" Reads integer from a C/C++ binary file at jrec position        "
 implicit none;
 integer iunit, jrec, i, j, ierr;
 integer*4 i_4;
 character c_4(4);
 equivalence (i_4,c_4);
;COMIN/EGS-IO/;
 j = 0;
 DO i=jrec,jrec+3[
  j = j + 1;
  read(iunit,rec=i,IOSTAT=ierr) c_4(j);
  IF (ierr.ne.0) [
    $egs_warning(*,' *** egs_read_int: ERROR READING integer *** ');
    $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
    egs_read_int = -1; return;
  ]
 ]
 jrec = jrec + 4; egs_read_int = i_4;
 return; end;


"================================================================="
 real*4 function egs_read_real(iunit, jrec);
"================================================================="
" Reads float from a C/C++ binary file at jrec position        "
 implicit none;
 integer iunit, jrec, i, j, ierr;
 real*4 r_4;
 character c_4(4);
 equivalence (r_4,c_4);
;COMIN/EGS-IO/;
 j = 0;
 DO i=jrec,jrec+3[
  j = j + 1;
  read(iunit,rec=i,IOSTAT=ierr) c_4(j);
  IF (ierr.ne.0) [
    $egs_warning(*,' *** egs_read_real: ERROR READING float *** ');
    $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
    egs_read_real = -1; return;
  ]
 ]
 jrec = jrec + 4; egs_read_real = r_4;
 return; end;

"****************************************************************
"*                                                              *
"*                 Function ibsearch(a, nsh, b)                 *
"*                                                              *
"*       binary search for an element l of array b such that    *
"*   b[l] =< a < b[l+1], array must be monotonically increasing *
"*                                                              *
"****************************************************************
$INTEGER function ibsearch(a, nsh, b);
 implicit none;
 $REAL a, b(*);
 $INTEGER min,max,help,nsh;
 $REAL x;
 min = 1; max = nsh; x = a;
 WHILE ( min < max-1 )[
       help = (max+min)/2;
       IF ( b(help).le.x)[min = help;]
       ELSE[max = help;]
 ]
 ibsearch = min;
 return;end;

%C80
"#############################################################################"
"                                                                             "
"  EGSnrc parameter input functions                                           "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Aaron Merovitz, 1998                                      "
"                   Dave Rogers, 1998                                         "
"                   Iwan Kawrakow, 1998                                       "
"                                                                             "
"  Contributors:    Ernesto Mainegra-Hing                                     "
"                   Blake Walters                                             "
"                   Frederic Tessier                                          "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Iwan Kawrakow, 1998, version 2.0, major rework:                            "
"                                                                             "
"  - Input values taken only if between specified delimiters (prior this      "
"    change, the first VALUES_SOUGHT found was taken, even if it was not      "
"    between the specified delimiters).                                       "
"                                                                             "
"  - Changed argument list to a common block GetInput defined in egs4.macros  "
"    to avoid memory use explosion.                                           "
"                                                                             "
"  - Eliminated initial loop checking for presence of values sought as it is  "
"    not necessary.                                                           "
"                                                                             "
"  - Introduced macros for handling strings (skipping blanks and comments,    "
"    changing to upper case, etc.)                                            "
"                                                                             "
"  - Eliminated string input bug: strings were always converted to upper case "
"                                                                             "
"  - Changed definition of strings to character*$MACRO where $MACRO has a     "
"    certain value that can be be defined in the user code if longer strings  "
"    are required.                                                            "
"                                                                             "
"                                                                             "
"  Iwan Kawrakow, 1999, version 2.1, major rework:                            "
"                                                                             "
"  - Missing or misspelled end delimiter together with a missing value sought  "
"    caused the routine to terminate. It now prints an error message and      "
"    continues to look for additional input.                                  "
"                                                                             "
"  - Introduced an array ERROR_FLAGS where the input status of each of the    "
"    attempted inputs is stored.                                              "
"                                                                             "
"#############################################################################"


SUBROUTINE GET_INPUT;
"                                                                           "
"                                                                           "
" FUNCTION: Extracts the requested values_sought from input file and        "
"           returns it to the caller.                                       "
"                                                                           "
" USAGE   :      Inputs must have the general form:                         "
"              ***************************************                      "
"              * Value_sought=  Value(s)             *                      "
"              ***************************************                      "
"         e.g.:        MEDNUM= 0, 1, 2                                      "
"                      MEDIA= AIR700ICRU                                    "
"                      RAYLEIGH SCATTERING= on                              "
"                                                                           "
"***************************************************************************"
"           >>>>>>>>>>>     BASIC RULES AND FEATURES    <<<<<<<<<<<         "
"***************************************************************************"
"
"   Inputs are all in the format: name of value_sought= value
"   where the name of value_sought must match that expected by the
"   program and the = sign must have no blanks between it and value_sought.
"
"   The value_sought must be the first thing on a line but blanks are
"     allowed before it.
"
"   Various inputs are only sought between certain delimeter strings
"     which are defined below (eg :start I/O control: :stop I/O control:)
"     If not specified, the whole file is searched for a requested value_sought.
"     Delimeter strings are enclosed by colons.
"     Note that within delimeter strings, order of inputs does not matter.
"
"   If a requested quantity is not found, this is noted in $input.errors
"     and this file is printed at the end of the log file.
"
"   A semi-colon implies the end of input for this quantity but is
"     not mandatory.  However, this means they cannot be used in titles.
"   A # sign indicated everything else on the line is a comment (and
"     cannot be used in titles.
"   Case is not important in the names of the quantites.
"
"   Commas separate multiple values for a given quantity and a comma
"     at the end of a line implies there is more input on the next line.
"   Values can extend over as many lines as needed. Use commas to imply
"     there are more values on the next line.
"
"   Blank lines and blanks in general are ignored.
"
"   The maximum record length is 256 characters.
"
"
"*******************************************************************************
"* (1)  *  Integers between parentheses show the value of the internal         *
"*      *  variable corresponding to this input. These are for reference only. *
"*      *                                                                      *
"* (M)  *  The 'M' indicates that the variable at hand has multiple            *
"*      *  input capability.  One may assign an arbitrary number of            *
"*      *  values to that input.                                               *
"*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
"*      *                                                                      *
"* (M2) *  The 'M' with an integer beside it means that the variable           *
"*      *  has that number of inputs.                                          *
"*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
"*      *                                                                      *
"* (I)  *  Regular (one number) integer input value.                           *
"*      *  E.g.:  SOURCE NUMBER= 0                                             *
"*      *                                                                      *
"* (R)  *  Regular (one number) real input value.                              *
"*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
"*      *                                                                      *
"* (C)  *  Regular (one string) character input value(no ; or #).              *
"*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
"*      *                                                                      *
"*******************************************************************************
"                                                                           "
"                                                                           "
" FEATURES: If the amount of values needed for a particular values_sought   "
"           is known and passed throught NVALUE(I), the subroutine will     "
"           check that the number of inputs correspond.  Otherwise,         "
"           NVALUE(I) will return the # of inputs found.                    "
"                                                                           "
"           For any integer or real (TYPE=0 or 1), get_inputs will check    "
"           that the numerical value input is between VALUE_MIN and         "
"           VALUE_MAX.  If not, it sets this value to the DEFAULT.          "
"                                                                           "
"           Writing in the input file can be upper case or lower case.      "
"           However, all FORTRAN >MUST< be programmed in upper case.        "
"              Changed the above: Can now be upper or lower case            "
"                                 IK, Dec. 1998                             "
"                                                                           "
"           For clarity, inputs can be terminated with a semicolon(;).      "
"           This is by no means necessary.                                  "
"                                                                           "
"***************************************************************************"
"          >>>>>>>>>>> IMPLEMENTING INTO NEW USER CODES <<<<<<<<<<<         "
"***************************************************************************"
"                                                                           "
"                   **** DECLARE YOUR INPUTS ****                           "
"                                                                           "
"    REALS AND INTEGERS (TYPE 0 AND 1)                                      "
"                                                                           "
"  I=I+1;                              <--index counter                     "
"  NUM_DRMIN=I;                        <--named pointer to the index num.   "
"  VALUES_SOUGHT(I)='DOSE RBOUND MIN'; <--name of variable                  "
"  NVALUE(I)=1;                        <--# of inputs(left out if not known)"
"  TYPE(I)=0;                          <--Type (0-3)                        "
"  VALUE_MIN(I)=0;                     <--Minimum value                     "
"  VALUE_MAX(I)=$MAXRADII-1;           <--Maximum value                     "
"  DEFAULT(I)=0;                       <--Default value                     "
"                                                                           "
"    CHARACTER INPUTS (TYPE 2)                                              "
"                                                                           "
"  I=I+1;
"  NUM_TITLE=I;
"  VALUES_SOUGHT(I)='TITLE';
"  TYPE(I)=2;
"  NVALUE(I)=1;                        <--left out if not known
"
"    ALLOWED INPTUS (TYPE 3)
"
"  I=I+1;
"  NUM_IWATCH=I;
"  VALUES_SOUGHT(I)='IWATCH';
"  NVALUE(I)=1;                        <--left out if not known
"  TYPE(I)=3;
"  ALLOWED_INPUTS(I,0)='OFF';
"  ALLOWED_INPUTS(I,1)='INTERACTIONS';
"  ALLOWED_INPUTS(I,2)='STEPS';
"  ALLOWED_INPUTS(I,3)='DEPOSITED';
"  ALLOWED_INPUTS(I,4)='GRAPH';
"                                                                           "
"                      **** STATE THE DELIMETER ****                        "
"                                                                           "
"            DELIMETER='TRANSPORT CONTROL'                                  "
"     OR     DELIMETER='NONE';                                              "
"                                                                           "
"  **** CALL THE SUBROUTINE WITH THE APPROPRIATE INDEX NUMBER OF THE ****   "
"                **** VALUES_SOUGHT(use NMIN and NMAX) ****                 "
"                                                                           "
"   The inputs are returned through CHAR_VALUE for character inputs         "
"   or VALUE for integers, reals and allowed inputs                         "
"                                                                           "
"---------------------------------------------------------------------------"


;IMPLICIT NONE;

COMIN/GetInput,EGS-IO/;

"***************************************************************************"
"*                   Variables used by the subroutine                      *"
"***************************************************************************"
CHARACTER*$STRING256 TEXT;      "Used to read in each line of the input file   "
CHARACTER*$STRING256 KEEPTEXT;  "Used to keep an old line of TEXT              "
CHARACTER*$STRING256 ORIGTEXT;  "The text without conversion to upper case     "
CHARACTER*$STRING256  TEXTPIECE; "Used to read a piece of TEXT                 "
CHARACTER*$STRING40  DELIM_START;"Start of the delimeter                       "
CHARACTER*$STRING40  DELIM_END;  "End of the delimeter                         "
CHARACTER*$STRING32  VNAME;      "The name of the variable being extracted.    "
CHARACTER*$STRING32  VNAME1;     "The name of the variable being extracted.    "
$INTEGER       CURSOR;          "Used to read one of the TEXT letters          "
$INTEGER       IINDEX;          "Integer index for clipping string excess.     "
$INTEGER       iVNAME;          "Length of variable name string.               "
$INTEGER       IVAL;            "Value number of the value_sought              "
$INTEGER       UNITNUM;         "Unit number of the input file                 "
$INTEGER       ERR;             "Unit number of the error file                 "
$INTEGER       I,J,K,CHECK;     "Counters and checkers                         "
$INTEGER       LINE;            "Counts the eumber of lines                    "
$INTEGER       INT_VALUE;       "For printing integers                         "
$INTEGER       INT_VALUE_MIN;   "For printing integers                         "
$INTEGER       INT_VALUE_MAX;   "For printing integers                         "
$LOGICAL       ALLOWED;         "For evaluating an allowed_input               "
$LOGICAL       START_FOUND;     "Start of delimeter switch                     "
$INTEGER       ifound,length,lll,Kconvert;
$INTEGER       lnblnk1;"in house lnblnk function becuase not all compilers     "
                       "support this"
logical IDEBUG;
character*1 blank;
$INTEGER    error_level;
$INTEGER    the_level;
data blank/' '/;
data        error_level/1/;
save        error_level;
"---------------------------------------------------------------------------"

"Macro changing text string to upper case"
"REPLACE {$CONVERT-STRING-TO-UPPER-CASE(#);} WITH"
REPLACE {$CONVERT # TO UPPER CASE;} WITH
{;
   DO Kconvert=1, lnblnk1({P1}) [
         CURSOR=ICHAR({P1}(Kconvert:Kconvert));
         IF ((CURSOR.GE.97).AND.(CURSOR.LE.122)) [
            CURSOR=CURSOR-32;
            {P1}(Kconvert:Kconvert)=CHAR(CURSOR);
         ]
   ]
}
;

"Macro to skip leading blanks "
REPLACE {$SKIP LEADING BLANKS IN #;} WITH
{;
  length = len({P1});
  WHILE ( index({P1},blank) = 1 ) [
    IF( length >= 2 ) [ {P1}={P1}(2:); ] ELSE [ EXIT; ]
    length = length - 1;
  ]
}

"Macro that removes everything after comments "
REPLACE {$REMOVE EVERYTHING AFTER # IN #;} WITH
{
  ifound = INDEX({P2},{P1});
  IF( ifound > 1 ) [ {P2} = {P2}(1:ifound-1); ]
  ELSE [ IF( ifound = 1 ) [ {P2} = blank; ] ]
}

REPLACE {$STRING-OUTPUT(#);} WITH
{;
  length = lnblnk1({P1});
  IF( length > 0 ) [
    DO lll=1,length [ write(i_log,'(a1,$)') {P1}(lll:lll); ]
    write(i_log,*); "For a new line"
  ]
}

IDEBUG = .false.;   "set to .true. for debug outputs"
ERROR_FLAG = 0;
IF(IDEBUG) [OUTPUT NMIN,NMAX, $NMAX;(' Entering get_inputs seeking values',
   I5,' to', I5, '  with a max allowed of',I5);
]
IF (NMAX < NMIN | NMAX > $NMAX)[
  OUTPUT NMAX, NMIN, $NMAX;
  (//' Error entering get_inputs: Asked for values from',I5,' to',I5,
  '    with a max of',I5//' This implies a bug in the calling routine'/
  ' Fix it up and try again.  Stopping now.');
  STOP;
]
ERR=i_errors;    "inputfile.errors"
UNITNUM=i_input; "inputfile.egs4inp"
DELIM_START=':START '//DELIMETER(:lnblnk1(DELIMETER))//':';
DELIM_END=':STOP '//DELIMETER(:lnblnk1(DELIMETER))//':';
$CONVERT DELIM_START TO UPPER CASE; "This allows use of lower case letters"
$CONVERT DELIM_END TO UPPER CASE; "This allows use of lower case letters"

IF(IDEBUG) [OUTPUT DELIM_START,DELIM_END;(' start and stop delimeters are:'/
   A/A/);
]
"===================check that each value_sought is there===================="

DO I = NMIN, NMAX  [ "for each value_sought"
   REWIND (UNITNUM);   "Rewind the input file"
   LINE=0;             "reset line counter"
   CHECK=0;            "reset error checker"
   ERROR_FLAGS(I)=0;
   " Set to default for the case the input is not found "
   IF(TYPE(I) = 0 | TYPE(I) = 1) [ VALUE(I,1) = DEFAULT(I); ]
   IF(TYPE(I) = 3) [ VALUE(I,1) = 0; ]
   VNAME=VALUES_SOUGHT(I);
   iVNAME=lnblnk1(VNAME);
   IF( ivname < 1 )
   [
     IF( error_level > 0 ) [
       write(ERR,*) ' ======================= Warning ===================== ';
       write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!         ';
       write(ERR,*) ' ===================================================== ';
     ]
     ERROR_FLAG=1;
     ERROR_FLAGS(I)=1;
     goto :END-NMIN-NMAX-LOOP:;
   ]

   $CONVERT vname TO UPPER CASE; "This allows use of lower case letters"
   iindex = 0;
   IF (DELIMETER = 'NONE') [ start_found = .true.; ]
   ELSE                    [ start_found = .false.; ]
   WHILE ( iindex = 0 )  "Until the value sought is found"
   [
:GI25:
       CONTINUE;
       LINE=LINE+1;
       IF( start_found ) [
         READ(UNITNUM,END=:GI1003:,ERR=:GI1001:,FMT='(A256)') TEXT;
       ]
       ELSE [
         READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;
       ]
       "READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;"
       $SKIP LEADING BLANKS IN text;
       $REMOVE EVERYTHING AFTER '#' IN text;
       $REMOVE EVERYTHING AFTER ';' IN text;
       length = lnblnk1(TEXT);
       TEXT=TEXT(:length);
       origtext = text(:length);
       $CONVERT text TO UPPER CASE;
       IF( ~start_found ) [
         IF (INDEX(TEXT,DELIM_START) ~= 0 ) [ start_found = .true.; ]
         goto :GI25:;
       ]

       iindex=INDEX(TEXT,VNAME(:iVNAME));

       " Check for end delimeter "
       IF( DELIMETER~='NONE' )
       [
         IF (INDEX(TEXT,DELIM_END)~=0)
         [
             IF( error_level > 0 ) [
             WRITE (ERR,*) '***************ERROR***************';
             WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
                           '<<',' NOT FOUND';
             WRITE (ERR,*) 'END OF DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
             ]
             ERROR_FLAG=1;
             ERROR_FLAGS(I)=1;
             GOTO :END-NMIN-NMAX-LOOP:;
         ]
       ]
   ] "end while loop. If we pass this loop, we have the values_sought string "
     "in text"

   CHECK=0; "reset error checker"
   IF( idebug ) [
       write(i_log,*) ' ******* Found: ';
       write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
       write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
   ]

   " Set string pointer to position after vname string and/or "
   " leadinf equals                                           "
   IINDEX=IINDEX+iVNAME;
   TEXT=TEXT(IINDEX:); origtext=origtext(iindex:);
   IF( idebug ) [
       write(i_log,*) ' After removing vname: ';
       write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
       write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
   ]
   IINDEX=INDEX(TEXT,'=');
   IF (IINDEX.NE.0) [
      TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
   ]
   ELSE [
       IINDEX=INDEX(TEXT,':');
       IF (IINDEX.NE.0) [
          TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
       ]
   ]
   IF( idebug ) [
       write(i_log,*) ' After removing leading equals: ';
       write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
       write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
   ]

   "===============read the value(i)======================="
   IF ( (lnblnk1(TEXT)=0) | (lnblnk1(TEXT)=1) )
   [
        IF (vname(:ivname)='TITLE')
        [
           READ (UNITNUM,FMT='(A256)') TEXTPIECE;
           IF (lnblnk1(TEXTPIECE)~=0) [
              TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE));
              $SKIP LEADING BLANKS IN text;
              $SKIP LEADING BLANKS IN origtext;
              GOTO :TITLE-THERE:;
           ]
        ]
        IF( error_level > 0 ) [
        WRITE (ERR,*) '*************ERROR*************';
        WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
        WRITE (ERR,*) 'VALUE NOT THERE!!';
        ]
        ERROR_FLAG=1;
        ERROR_FLAGS(I)=1;
        RETURN;
   ]
:TITLE-THERE:
   CONTINUE;

   " Always check for default. The following sets the value to "
   " default(i) for a numeric input (type=1 or 2) and to 0 for "
   " an 'allowed input' => use only if one input is expected!  "
   iindex = index(text,'DEFAULT');
   IF( iindex ~= 0 )
   [                  "User requested a default value"
       IF( type(i) ~= 2 )
       [
           IF( type(i) ~= 3 ) [ VALUE(I,1)=DEFAULT(I); ]
           ELSE               [ VALUE(I,1)=0;          ]
           goto :END-NMIN-NMAX-LOOP:;
       ]
   ]

   IF ((TYPE(I) = 0)|(TYPE(I) = 1))
   [                                 "Read the number"
       IVAL=1;  "nvalue counter"
       IF( idebug )[write(i_log,*) ' *** Reading an integer or a real value! ';]
       LOOP
       [
           IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
           IF (lnblnk1(TEXT)=0) [
                 IF( error_level > 0 ) [
                 WRITE(ERR,*) '*************ERROR*************';
                 WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                 WRITE (ERR,*) 'VALUE NOT THERE!!';
                 ]
                 ERROR_FLAG=1;
                 ERROR_FLAGS(I)=1;
                 RETURN;
           ]
           READ(TEXT,END=:GI1010:,ERR=:GI1007:,FMT=*) VALUE(I,IVAL);
           IF( idebug ) [write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL);]
"==========================================================================="
"=================================Defaults=================================="

           IF ((VALUE(I,IVAL)>VALUE_MAX(I))|(VALUE(I,IVAL)<VALUE_MIN(I)))
           [
               IF (TYPE(I)=0)
               [
                    INT_VALUE=DEFAULT(I);
                    IF( error_level > 0 ) [
                    WRITE(ERR,*) '************WARNING************';
                    WRITE(ERR,:FMTA:) INT_VALUE,
                                 VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
                    ]
                    :FMTA: FORMAT ( 'Default= ',I9,' used for: ', A );
                    INT_VALUE=VALUE(I,IVAL);
                    INT_VALUE_MIN=VALUE_MIN(I);
                    INT_VALUE_MAX=VALUE_MAX(I);
                    IF( error_level > 0 ) [
                    WRITE(ERR,:FMTB:)
                        VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
                        INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX;
                    ]
                    :FMTB: FORMAT (A,'=', I9,' should be between ',
                                   I9,' and ', I9);
               ]
               IF (TYPE(I)=1)
               [
                    IF( error_level > 0 ) [
                    WRITE(ERR,*) '************WARNING************';
                    WRITE(ERR,:FMTC:) DEFAULT(I),
                                 VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
                    :FMTC: FORMAT ( 'Default= ',F12.6,' used for: ', A );
                    WRITE(ERR,:FMTD:)
                        VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
                        VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I);
                    :FMTD: FORMAT (A,'=', F12.6,' should be between ',
                                   G14.6,' and ', G14.6);
                    ]
               ]
               VALUE(I,IVAL)=DEFAULT(I);
           ] "end IF default"

           IF ( IVAL = NVALUE(I) ) EXIT; "Required inputs found"
"==========================================================================="
"=======================Move to next value, else exit======================="

           IF ((INDEX(TEXT,',')~=0)|(lnblnk1(TEXT)=0))
           [
               IF ( idebug ) [
                   write(i_log,*) ' A comma or a blank text found -> ';
                   write(i_log,*) ' searching for further input';
               ]
               TEXT=TEXT(INDEX(TEXT,',')+1:);
               WHILE (lnblnk1(TEXT)=0)
               [
                   IF ( idebug ) [
                     write(i_log,*) ' Empty text -> reading next line! ';
                   ]
                   LINE=LINE+1;
                   READ (UNITNUM,END=:GI1010:,ERR=:GI1007:,FMT='(A256)') TEXT;
                   $SKIP LEADING BLANKS IN text;
                   $REMOVE EVERYTHING AFTER '#' IN text;
                   $REMOVE EVERYTHING AFTER ';' IN text;
                   length = lnblnk1(TEXT);
                   TEXT=TEXT(:length);
                   origtext = text(:length);
                   $CONVERT text TO UPPER CASE;

                   "Check whether this line containes one of the strings sought"
                   DO K = 1 , NMAX
                   [
                       vname1 = VALUES_SOUGHT(K);
                       length = lnblnk1(vname1);
                       IF( length > 0 )
                       [
                           $SKIP LEADING BLANKS IN vname1;
                           $CONVERT vname1 TO UPPER CASE;
                           IF (INDEX(TEXT,vname1(:length))~=0)
                           [
                             IF( error_level > 0 ) [
                             WRITE(ERR,*) '************ERROR************';
                             WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                             WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
                                      '<--COMMA INDICATES ANOTHER INPUT';
                             WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
                                             TEXT(:lnblnk1(TEXT));
                             WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
                             ]
                             ERROR_FLAG=1;
                             ERROR_FLAGS(I)=1;
                           ]
                       ]
                   ]
                   IF( idebug ) [
                     write(i_log,*) ' Next line: ';
                     write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
                     write(i_log,'(a,$)') ' origtext: ';
                                          $STRING-OUTPUT(origtext);
                   ]
               ]
           ] "end if ~=0"
           ELSE [EXIT;]
           IVAL=IVAL+1;
       ] "end loop"
       IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
           IF( error_level > 0 ) [
           WRITE (ERR,*) '**************ERROR**************';
           WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
           WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)';
           WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
           ]
           ERROR_FLAG=1;
           ERROR_FLAGS(I)=1;
       ]
       ELSE [NVALUE(I)=IVAL;]
:GI1010:
       CONTINUE;
   ] "end IF TYPE"

"============================read the char_value(i)========================="

   IF ((TYPE(I) = 2) | (TYPE(I) = 3))
   [                                   "Read the string"
       IVAL=1;     "nvalue counter"
       IF( idebug ) [write(i_log,*) ' Trying to read a string! ';]
       LOOP
       [
           IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
           IF (lnblnk1(TEXT)=0) [
              IF( error_level > 0 ) [
              WRITE(ERR,*) '*************ERROR*************';
              WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
              WRITE (ERR,*) 'VALUE NOT THERE!!';
              ]
              ERROR_FLAG=1;
              ERROR_FLAGS(I)=1;
              RETURN;
           ]
           IF (vname(:ivname)='TITLE') [
              TEXTPIECE=origtext;
              GOTO :READ-IT:
           ]
           iindex = INDEX(origtext,',');
           IF ( iindex ~= 0 ) [ TEXTPIECE=origtext(:iindex-1); ]
           ELSE               [ TEXTPIECE=origtext;            ]
                      "The above is to avoid conversion to upper case"
                      "for e.g. media names                          "
           :READ-IT:
           CONTINUE;
           READ(TEXTPIECE,ERR=:GI1008:,FMT='(A256)') CHAR_VALUE(I,IVAL);
           $SKIP LEADING BLANKS IN CHAR_VALUE(I,IVAL);
           IF( idebug ) [
             write(i_log,*) ' Read the following char string: ';
             $STRING-OUTPUT(CHAR_VALUE(I,IVAL));
           ]
"===============================Allowed inputs=============================="
           IF (TYPE(I) = 3)
           [
              $CONVERT CHAR_VALUE(I,IVAL) TO UPPER CASE;
              ALLOWED=.FALSE.;
              DO K=0, $MXALINP [
                 vname1 = ALLOWED_INPUTS(I,K);
                 $SKIP LEADING BLANKS IN ALLOWED_INPUTS(I,K);
                 $CONVERT ALLOWED_INPUTS(I,K) TO UPPER CASE;
                 IF (ALLOWED_INPUTS(I,K)=CHAR_VALUE(I,IVAL)) [
                    ALLOWED=.TRUE.;
                    VALUE(I,IVAL)=K;
                    IF( idebug ) [
                      write(i_log,*) ' Found a allowed_value match ',k;
                    ]
                 ]
              ]
              IF (.NOT.ALLOWED) [
                 WRITE(ERR,*) '*************ERROR*************';
                 IF (IVAL~=1) [
                    WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                    WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY';
                 WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND VALUE';
                 ]
                 ELSE [
                    WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                    WRITE(ERR,*) 'INPUT-->',
                               CHAR_VALUE(I,IVAL)(:lnblnk1(CHAR_VALUE(I,IVAL))),
                               '<--NOT ALLOWED';
                    WRITE(ERR,*) 'OPTIONS ARE:';
                    WRITE(ERR,:FMT:)
                    (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_INPUTS(I,K))),
                     K=0,$MXALINP);
                 ]
                 :FMT: FORMAT(A40);
                 ERROR_FLAG=1;
                 ERROR_FLAGS(I)=1;
              ]
           ]
"=======================Move to next value, else exit======================="

           IF (vname(:ivname)='TITLE') [ EXIT; ]
           DO K=1,LEN(KEEPTEXT) [KEEPTEXT(K:K)=' ';]  "erase previous KEEPTEXT"
           KEEPTEXT(:lnblnk1(TEXT))=TEXT;
           iindex = INDEX(TEXT,',');
           IF ( iindex ~= 0 | lnblnk1(TEXT)=0 )
           [
               TEXT=TEXT(INDEX(TEXT,',')+1:);
               origtext=origtext(iindex+1:);
               WHILE (lnblnk1(TEXT)=0)
               [
                   LINE=LINE+1;
                   READ (UNITNUM,ERR=:GI1008:,FMT='(A256)') TEXT;
                   $SKIP LEADING BLANKS IN text;
                   $REMOVE EVERYTHING AFTER '#' IN text;
                   $REMOVE EVERYTHING AFTER ';' IN text;
                   length = lnblnk1(TEXT);
                   TEXT=TEXT(:length);
                   origtext = text(:length);
                   $CONVERT text TO UPPER CASE;

                   "Check whether this line containes one of the strings sought"
                   DO K = 1 , NMAX
                   [
                       vname1 = VALUES_SOUGHT(K);
                       length = lnblnk1(vname1);
                       IF( length > 0 )
                       [
                           $SKIP LEADING BLANKS IN vname1;
                           $CONVERT vname1 TO UPPER CASE;
                           IF (INDEX(TEXT,vname1(:length))~=0)
                           [
                             WRITE(ERR,*) '************ERROR************';
                             WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                             WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
                                      '<--COMMA INDICATES ANOTHER INPUT';
                             WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
                                             TEXT(:lnblnk1(TEXT));
                             WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
                             ERROR_FLAG=1;
                             ERROR_FLAGS(I)=1;
                           ]
                       ]
                   ]
               ]
           ] "end if ~=0"
           ELSE [EXIT;]
           IVAL=IVAL+1;
        ] "end loop"
        IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
           IF( error_level > 0 ) [
           WRITE (ERR,*) '*******************ERROR*******************';
           WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
           WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)';
           WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
           ]
           ERROR_FLAG=1;
           ERROR_FLAGS(I)=1;
        ]
        ELSE [NVALUE(I)=IVAL;]
   ]
"==========================================================================="
"==========================================================================="
   goto :END-NMIN-NMAX-LOOP:;

:GI1003:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '******************ERROR***********************';
        WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
        WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER';
        WRITE (ERR,*) 'VALUE SOUGHT: >>',
          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
        WRITE (ERR,*) 'END DELIMETER: >>',
          DELIM_END(:lnblnk1(DELIM_END)),'<<';
        ]
        ERROR_FLAG=1;
        ERROR_FLAGS(I)=1;
        goto :END-NMIN-NMAX-LOOP:;

:GI1004:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '******************ERROR***********************';
        WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
        WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER';
        WRITE (ERR,*) 'VALUE SOUGHT: >>',
          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
        WRITE (ERR,*) 'START DELIMETER: >>',
          DELIM_START(:lnblnk1(DELIM_START)),'<<';
        ]
        ERROR_FLAG=1;
        ERROR_FLAGS(I)=1;
        goto :END-NMIN-NMAX-LOOP:;

:GI1007:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '***************ERROR***************';
        IF (IVAL>1) [J=IVAL;] ELSE [J=1;]
        WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
        WRITE (ERR,*) 'LINE #',LINE;
        WRITE (ERR,*) 'COULD NOT READ THE VALUE!!';
        WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...';
        WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPUT?';
        ]
        ERROR_FLAG=1; "turn on the error flag"
        ERROR_FLAGS(I)=1; "turn on the error flag"
        GOTO :END-NMIN-NMAX-LOOP:;
:GI1008:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '***************ERROR***************';
        WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
        WRITE (ERR,*) 'LINE #',LINE;
        WRITE (ERR,*) 'COULD NOT READ THE STRING !!';
        ]
        ERROR_FLAG=1; "turn on the error flag"
        ERROR_FLAGS(I)=1; "turn on the error flag"

:END-NMIN-NMAX-LOOP:
    CONTINUE;
] "end do NMAX loop"
RETURN;

"**************if any errors**************"
:GI1001:
      WRITE (ERR,*) '***************ERROR***************';
      WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE;
      goto :GI1009:;
"the following is no longer used so comment it out"
":GI1002:
"      WRITE (ERR,*) '***************ERROR***************';
"      IF (CHECK=100) [
"         WRITE (ERR,*) 'DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
"         WRITE (ERR,*) 'WAS NOT FOUND';
"      ]
"      ELSE [
"         WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
"                       '<<',' NOT FOUND';
"      ]
"      WRITE (ERR,*) 'END OF FILE REACHED';
:GI1009:
      CONTINUE;  "exit if there is an error"
      ERROR_FLAG=1; "turn on the error flag"
      ERROR_FLAGS(I)=1; "turn on the error flag"
      RETURN;

entry get_input_set_error_level(the_level);
error_level = the_level;
return;
END;



%E   "get_inputs.mortran"
"*****************************************************************************
"
subroutine get_transport_parameter(ounit);
"
" is provided for use with the EGSnrc system. It reads all physics
" related parameters from the input file using the get_input routine.
" For a description for the format/conventions used in get_input,
" see the description at the beginning of this file.
" In order to use this routine, include transportp.macros BEFORE
" get_inputs.mortran via the configuration file.
" If the routine is called with ounit > 0, the transport parameter
" settings will be printid on unit ounit.
"
" Version 0.1           Iwan Kawrakow, January 1999
"
"******************************************************************************
"*******************************************************************************
"
"                         MC TRANSPORT PARAMETER
"                         **********************
"
"  All input associated with selection of various transport parameter
"  is not crucial for the execution as there are default values set.
"  Therefore, if some of the input options in this section are
"  missing/misspelled, this will be ignored and defualt parameter assumed
"  As the transport parameter input routine uses get_inputs, a lot
"  of error/warning messages may be produced on UNIT 15, though.
"  If you don't have the intention of changing default settings,
"  simply ignore the error messages.
"
"  The delimeters are
"
"               :start mc transport parameter:
"               :stop mc transport parameter:
"
"  You can change this by including the statement
"
"  REPLACE {$THE_DELIMETER} WITH {'WHATEVER-YOU-LIKE-THE-DELIMETER-TO-BE'}
"
"  in your input file.
"
"  Currently, the following options are available (case does not matter and
"             the internal variables are shown in [ ] brackets):
"
"       Global ECUT=     Global (in all regions) electron transport cut
"                        off energy (in MeV). If this imput is missing,
"                        AE(medium) will be used.
"                        [ ECUT ]
"       Global PCUT=     Global (in all regions) photon transport cut
"                        off energy (in MeV). If this imput is missing,
"                        AP(medium) will be used.
"                        [ PCUT ]
"       Global SMAX=     Global (in all regions) maximum step-size
"                        restriction for electron transport (in cm).
"                        If missing, no geometrical step-size restrictions
"                        will be employed. Note that if you use the default
"                        EGSnrc electron-step algorithm, no SMAX-restriction
"                        is necessary. Option is useful for transport in low
"                        density materials (air) when PRESTA behaviour is
"                        turned on (see below)
"                        [ SMAXIR ]
"       ESTEPE=          Maximum fractional energy loss per step.
"                        Note that this is a global option only, no
"                        region-by-region setting is possible. If missing,
"                        the defualt is 0.25 (25%).
"                        [ ESTEPE ]
"       XImax=           Maximum first elastic scattering moment per step.
"                        Default is 0.5, NEVER use value greater than 1 as
"                        this is beyond the range of MS data available.
"                        [ XIMAX ]
"       Boundary crossing algorithm=
"                        There are two selections possible: EXACT, means
"                        the algorithm will cross boundaries in a single
"                        scattering (SS) mode, the distance from a boundary
"                        at which the transition to SS mode is made is
"                        determined by 'Skin depth for BCA' (see below).
"                        The second option is PRESTA-I, if selected boundaries
"                        will be crossed a la PRESTA, i.e. with lateral
"                        correlations turned off and MS forced at boundaries.
"                        Default is EXACT.
"                        [ bca_algorithm, exact_bca ]
"       Skin depth for BCA=
"                        Determines the distance from a boundary (in elastic
"                        MFP) at which the algorithm will go into single
"                        scattering mode (if EXACT boundary crossing) or
"                        swith off lateral correlations (if PRESTA-I boundary
"                        crossing). Default value is 3 for EXACT or
"                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
"                        for a definition of BLCMIN). Note that if you choose
"                        EXACT boundary crossing and set Skin depth for BCA
"                        to a very large number (e.g. 1e10), the entire
"                        calculation will be in SS mode. If you choose
"                        PRESTA-I boundary crossing and make Skin depth for BCA
"                        large, you will get default EGS4 behavious (no PRESTA)
"                        [ skindepth_for_bca ]
"       Electron-step algorithm=
"                        PRESTA-II (the default), the name is
"                        used for historical reasons
"                        or PRESTA-I
"                        Determines the algorithm used to take into account
"                        lateral and longitudinal correlations in a
"                        condensed history step.
"                        [ transport_algorithm ]
"       Spin effects=    Off, On, default is On
"                        Turns off/on spin effects for electron elastic
"                        scattering. Spin On is ABSOLUTELY necessary for
"                        good backscattering calculations. Will make a
"                        difference even in `well conditioned' situations
"                        (e.g. depth dose curves for RTP energy range
"                        electrons).
"                        [ spin_effects ]
"       Brems angular sampling= Simple, KM, default is KM
"                        If Simple, use only the leading term of the Koch-Motz
"                        distribution to determine the emission angle of
"                        bremsstrahlung photons. If KM, complete
"                        modified Koch-Motz 2BS is used (modifications
"                        concern proper handling of kinematics at low energies,
"                        makes 2BS almost the same as 2BN at low energies).
"                        [ IBRDST ]
"       Brems cross sections= BH, NIST, NRC default is BH
"                        If BH is selected, the Bethe-Heitler bremsstrahlung
"                        cross sections (Coulomb corrected above 50 MeV)
"                        will be used. If NIST is selected, the NIST brems
"                        cross section data base (which is the basis for
"                        the ICRU radiative stopping powers) will be employed.
"                        Differences are negligible for E > ,say, 10 MeV,
"                        but significant in the keV energy range. If NRC is
"                        selected, the NRC brems cross-section data base will
"                        be used, which is a version of the NIST data base
"                        with corrected electron-electron brems contributions
"                        (corrections to the NIST data is typically only
"                        significant for low values of the atomic number Z
"                        and for k/T < 0.005).
"       Triplet production= On or Off (default).  Turns on/off simulation
"                        of triplet production.  If On, then Borsellino's
"                        first Born approximation is used to sample triplet
"                        events based on the triplet cross-section data.
"                        [ itriplet ]
"       Bound Compton scattering=  On, Off, Simple or norej (default)
"                        If Off, Compton scattering will be treated with
"                        Klein-Nishina, with On Compton scattering is
"                        treated in the Impulse approximation.
"                        With Simple, the impulse approximation incoherent
"                        scattering function will be used (i.e., no Doppler
"                        broadenning). With norej the actual total bound
"                        Compton cross section is used and there are no
"                        rejections at run time.
"                        Make sure to use for low energy applications,
"                        not necessary above, say, 1 MeV.
"                        [ IBCMP ]
"       Radiative Compton corrections= On or Off (default). If on, then
"                        include radiative corrections for Compton scattering.
"                        Equations are based on original Brown & Feynman
"                        equations (Phys. Rev. 85, p 231--1952).  Requires
"                        a change to the user codes Makefile to include
"                        $(EGS_SOURCEDIR)rad_compton1.mortran in the
"                        SOURCES (just before
"                        $(EGS_SOURCEDIR)get_inputs.mortran).
"                        [ radc_flag ]
"       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
"                        gryzinski, penelope.  If set to On or ik, then use
"                        Kawrakow's theory to derive EII cross-sections.
"                        If set to casnati, then
"                        use the cross-sections of Casnati (contained in the
"                        file ($HEN_HOUSE/data/eii_casnati.data).  Similar for
"                        kolbenstvedt, gryzinski and penelope. This is only of
"                        interest in kV X-ray calculations.
"                        Case-sensitive except for Off, On or ik options.
"                        [ eii_flag ]
"       Pair angular sampling= Off, Simple, KM.
"                        If off, pairs are set in motion at an angle m/E
"                        relative to the photon direction (m is electron rest
"                        energy, E the photon energy). Simple turns on
"                        the leading term of the angular distribution
"                        (this is sufficient for most applications),
"                        KM (comes from Koch and Motz) turns on using 2BS
"                        from the article by Koch and Motz.  Uniform
"                        Default is Simple, make sure you always use
"                        Simple or KM
"                        [ IPRDST ]
"       Pair cross sections= BH (default) or NRC.  If set to BH, then use
"                        Bethe-Heitler pair production cross-sections.  If set
"                        to NRC, then use NRC pair production cross-sections
"                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
"                        of interest at low energies, where the NRC cross-
"                        sections take into account the assymmetry in the
"                        positron-electron energy distribution.
"                        [ pair_nrc ]
"       Photon cross sections= Photon cross-section data.  Current options are
"                        si (Storm-Israel), epdl (Evaluated Photon Data
"                        Library), xcom (the default), pegs4, mcdf-xcom and
"                        mcdf-epdl:
"                        Allows the use of photon cross-sections other than
"                        from the PEGS4 file (unless the pegs4 option is
"                        specified).  Options mcdf-xcom and mcdf-epdl use
"                        Sabbatucci and Salvat's renormalized photoelectric
"                        cross sections with either xcom or epdl for all other
"                        cross sections.  These are more accurate but can
"                        increase CPU time by up to 6 %.
"                        Note that the user can supply their own cross-section
"                        data as well. The requirement is that the files
"                        photon_xsections_photo.data,
"                        photon_xsections_pair.data,
"                        photon_xsections_triplet.data, and
"                        photon_xsections_rayleigh.data exist in the
"                        $HEN_HOUSE/data directory, where photon_xsections
"                        is the name specified.
"                        Hence this entry is case-sensitive.
"                        [ photon_xsections ]
"       Photon cross-sections output= Off (default) or On.  If On, then
"                        a file $EGS_HOME/user_code/inputfile.xsections is
"                        output containing photon cross-section data used.
"                        [ xsec_out ]
"       Compton cross sections= Bound Compton cross-section data.  User-
"                        supplied bound Compton cross-sections in the file
"                        $HEN_HOUSE/data/comp_xsections_compton.data, where
"                        comp_xsections is the name supplied for this input.
"                        This is only used if Bound Compton scattering= Simple
"                        and is not available on a region-by-region basis
"                        (see below).  The default file (ie in the absence
"                        of any user-supplied data) is compton_sigma.data.
"                        [ comp_xsections ]
"       Rayleigh scattering= Off, On, custom
"                        If On, turn on coherent (Rayleigh) scattering.
"                        Default is On. Should be turned on for low energy
"                        applications.
"                        If custom, user must provide media names and form
"                        factor files for each desired medium. For the rest
"                        of the media, default atomic FF are used.
"                        [ IRAYLR ]
"       ff media names = A list of media names (must match media found in
"                        PEGS4 data file) for which the user is going to
"                        provide custom Rayleigh form factor data.
"                        [ iray_ff_media($MXMED) ]
"       ff file names = A list of names of files containing the Rayleigh
"                       form factor data for the media specified by
"                       the ff media names = input above.  Full directory
"                       paths must be given for all files, and for each medium
"                       specified, iray_ff_media(i), there must be a
"                       corresponding file name, iray_ff_file(i).  For
"                       example files, see the directory
"                       $HEN_HOUSE/data/molecular_form_factors.
"                       [ iray_ff_file($MXMED) ]
"Ali:photonuc, 2 blocks of comments"
"       Photonuclear attenuation= Off (default) or On
"                        If On, models the photonuclear effect. Current
"                        implementation is crude. Available on a
"                        region-by-region basis (see below)
"                        [ IPHOTONUCR ]
"       Photonuclear cross sections= Total photonuclear cross sections. User-
"                        supplied total photonuclear cross-sections in
"                        $HEN_HOUSE/data/photonuc_xsections_photonuc.data,
"                        where photonuc_xsections is the name supplied for
"                        this input (case sensitive). In the absence of
"                        any user-supplied data, or if photonuc_xsections
"                        is set to 'default', the default file is
"                        iaea_photonuc.data.
"                        [ photonuc_xsections ]
"       Photoelectron angular sampling= Off or On
"                        If Off, photo-electrons get the direction of the
"                        `mother' photon, with On, Sauter's furmula is
"                        used (which is, striktly speaking, valid only for
"                        K-shell photo-absorption).
"                        If the user has a better approach, replace the macro
"                            $SELECT-PHOTOELECTRON-DIRECTION;
"                        The only application that
"                        I encountered until now where this option made a
"                        small difference was a big ion chamber (cavity size
"                        comparable with electron range) with high-Z walls
"                        in a low energy photon beam.
"                        Default is On
"                        [ IPHTER ]
"       Atomic relaxations= Off, On, eadl, simple
"                        Default is eadl.  On defaults to eadl.
"                        When simulating atomic relaxations:
"                        - In photo-electric absorption events, the element
"                          (if material is mixture) and the shell the photon
"                          is interacting with are sampled from the appropriate
"                          cross sections
"                        - Shell vacancies created in photoelectric,
"                          compton and electron impact ionization events
"                          are relaxed via emission of fluorescent X-Rays,
"                          Auger and Koster-Cronig electrons.
"                         The eadl option features a more accurate treatment
"                         of relaxation events and uses binding energies
"                         consistent with those in of the photon cross sections
"                         used in the simulation.  If using mcdf-xcom or
"                         mcdf-epdl photon cross sections, you cannot use
"                         the simple option and this will automatically get
"                         reset to eadl.
"                         Make sure to use eadl or simple for low energy
"                         applications.
"                         [ IEDGFL ]
"
"       Atomic relaxations, Rayleigh scattering,
"       Photoelectron angular sampling and Bound Compton scattering
"       and photonuclear effect(Ali:photonuc)
"       can also be turned On/Off on a region-by-region
"       basis. To do so, put e.g.
"
"       Atomic relaxations= On in Regions   or
"       Atomic relaxations= Off in regions
"
"                         in your input file. Then use
"
"       Bound Compton start region=
"       Bound Compton stop region=
"                or
"       Rayleigh start region=
"       Rayleigh stop region=
"                or
"       Relaxations start region=
"       Relaxations stop region=
"                or
"       PE sampling start region=
"       PE sampling stop region=
"                or                  Ali:photonuc
"       Photonuclear start region=
"       Photonuclear stop region=
"
"                         each followed by a lost of of one or more
"                         start and stop regions separated by commas.
"                         Example:
"        Atomic relaxations= On in Regions
"        Relaxations start region=  1, 40
"        Relaxations stop region=  10, 99
"                         will first turn off relaxations everywhere and
"                         then turn on in regions 1-10 and 40-99.
"                         Note that input is checked against min. and max.
"                         region number and ignored if
"                         start region < 1 or stop_region > $MXREG or
"                         start region > stop region.
"
"                         ECUT, PCUT and SMAX can also be set on a
"                         region-by-region basis. To do so, iclude
"                         in your input file
"
"         Set XXXX=              f_value1, f_value2, ...
"         Set XXXX start region= i_value1, i_value2, ...
"         Set XXXX stop region=  j_value1, j_value2, ...
"
"                         where XXXX is ECUT, PCUT or SMAX ,
"                         f_value1, f_value2,... are the desired values for XXXX
"                         and i_value_i and j_value_i are the start and
"                         stop regions.
"
"*******************************************************************************

implicit none;  "Hard coded to catch possible user replacements of the "
                "following common blocks"

character*80 line;
character*512 toUpper;

$INTEGER ounit;
$declare_max_medium;

$COMIN-GET-TRANSPORTP;

$INTEGER  ival,num_ecut,num_pcut,num_smax,num_incoh,num_radc,num_coh,num_relax,
          num_pe_ang,num_brems_ang,num_brems_cs,num_pair_cs,
          num_ffmed,num_ffiles,
          num_pair_ang,num_eii,num_eii_L,num_estepe,num_ximax,num_triplet,
          num_pxsec,num_pxsec_out, num_cxsec,
          num_photonuc, num_photonuc_xsec,"Ali:photonuc, 1 line"
          num_efield, num_bfield, num_emlmt,"EMH: EM fields"
          num_spin,num_bca,num_alg,num_skin,itmp,iitmp,i,j,k,istart,iend,
          egs_open_file,lnblnk1;

$LOGICAL  ecut_inregions,pcut_inregions,smax_inregions,
          incoh_inregions,coh_inregions,relax_inregions,
          pe_inregions,aux_inregions,photonuc_inregions;"Ali:photonuc"

character*15 output_strings(14);"Ali:photonuc, increased by 1"
save         output_strings,line;
save         ecut_inregions,pcut_inregions,smax_inregions,
             incoh_inregions,coh_inregions,relax_inregions,
             pe_inregions,aux_inregions,photonuc_inregions,
             num_photonuc;"Ali:photonuc"


DO k=1,80 [ line(k:k) = '='; ]
delimeter = $THE_DELIMETER;
ival = 0;

;
/ecut_inregions,pcut_inregions,smax_inregions,
 incoh_inregions,coh_inregions,relax_inregions,
 pe_inregions,aux_inregions,
 "Ali:photonuc, 1 line"
 photonuc_inregions/ = .false.;

"open a .errors file exclusively for output from this subroutine"
i_errors=15;
i_errors=egs_open_file(i_errors,0,1,'.errors');

write(i_errors,*)
' If you are not trying to reset transport parameters, ';
write(i_errors,*)
' ignore all the output until the message ';
write(i_errors,*)
' ******************** end input transport parameter *********************** ';
write(i_errors,*);

" ECUT "
ival                = ival + 1;
num_ecut            = ival;                     "Set the variable pointer"
values_sought(ival) = $GLOBAL_ELECTRON_CUTOFF;  "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $GLOBAL-ECUT;

" PCUT "
ival                = ival + 1;
num_pcut            = ival;                     "Set the variable pointer"
values_sought(ival) = $GLOBAL_PHOTON_CUTOFF;    "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $GLOBAL-PCUT;

" SMAX "
ival                = ival + 1;
num_smax            = ival;                     "Set the variable pointer"
values_sought(ival) = $GLOBAL_SMAX;             "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $MAX-SMAX;

" Incoherent (Compton) scattering "
ival                = ival + 1;
num_incoh           = ival;                     "Set the variable pointer"
values_sought(ival) = $INCOHERENT_SCATTERING;   "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;
allowed_inputs(ival,4) = 'Simple';
allowed_inputs(ival,5) = 'norej';

" Radiative corrections for Compton scattering "
ival                = ival + 1;
num_radc            = ival;
values_sought(ival) = $RADC_COMPTON;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';

" Coherent (Rayleigh) scattering "
ival                = ival + 1;
num_coh             = ival;                     "Set the variable pointer"
values_sought(ival) = $COHERENT_SCATTERING;     "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;
allowed_inputs(ival,4) = 'custom';

" Atomic Relaxations "
ival                = ival + 1;
num_relax           = ival;                     "Set the variable pointer"
values_sought(ival) = $ATOMIC_RELAXATIONS;      "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;
allowed_inputs(ival,4) = 'eadl';
allowed_inputs(ival,5) = 'simple';

" Photoelectron angular sampling "
ival                = ival + 1;
num_pe_ang          = ival;                     "Set the variable pointer"
values_sought(ival) = $PE_ANGULAR_SAMPLING;     "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;

" Bremsstrahlung angular sampling "
ival                = ival + 1;
num_brems_ang       = ival;                     "Set the variable pointer"
values_sought(ival) = $BREMS_ANGULAR_SAMPLING;  "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Simple';
allowed_inputs(ival,1) = 'KM';   "means Koch-Motz, Simple turns on just the"
                                 "leading term of the distribution which is"
                                 "probably sufficiently accurate for most"
                                 "applications"

" Bremsstrahlung cross sections "
ival                = ival + 1;
num_brems_cs        = ival;                     "Set the variable pointer"
values_sought(ival) = $BREMS_CROSS_SECTIONS;    "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'BH';
allowed_inputs(ival,1) = 'NIST';                "Only global on/off available"
allowed_inputs(ival,2) = 'NRC';                 "Only global on/off available"


" Pair angular sampling "
ival                = ival + 1;
num_pair_ang        = ival;                     "Set the variable pointer"
values_sought(ival) = $PAIR_ANGULAR_SAMPLING;   "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'Simple';             "Only global on/off available"
allowed_inputs(ival,2) = 'KM';   "means Koch-Motz, Simple turns on just the"
                                 "leading term of the distribution which is"
                                 "probably sufficiently accurate for most"
                                 "applications"
allowed_inputs(ival,3) = 'Uniform';
allowed_inputs(ival,4) = 'Blend';

" Pair cross sections "
ival                = ival + 1;
num_pair_cs         = ival;
values_sought(ival) = $PAIR_CROSS_SECTIONS;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'BH';
allowed_inputs(ival,1) = 'NRC';

" Triplet production "
ival                = ival + 1;
num_triplet         = ival;
values_sought(ival) = $TRIPLET_PRODUCTION;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';

" Spin effects          "
ival                = ival + 1;
num_spin            = ival;                     "Set the variable pointer"
values_sought(ival) = $SPIN_EFFECTS;            "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';                 "Only global on/off available"

" Electron impact ionization "
ival                = ival + 1;
num_eii             = ival;
values_sought(ival) = $ELECTRON_IMPACT_IONI;
nvalue(ival)        = 1;
type(ival)          = 2;
"type(ival)          = 3;"
"allowed_inputs(ival,0) = 'Off';"
"allowed_inputs(ival,1) = 'On';"
"allowed_inputs(ival,2) = 'casnati';"
"allowed_inputs(ival,3) = 'kolbenstvedt';"
"allowed_inputs(ival,4) = 'gryzinski';"

" L-shell EII xsection scaling"
ival                = ival + 1;
num_eii_L= ival;                                "Set the variable pointer"
values_sought(ival) = $SCALE_L_EII_XSECTIONS;   "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0.0;                      "Define the allowed range"
value_max(ival)     = 1.0e+9;
default(ival)       = 1.0;

" ESTEPE "
ival                = ival + 1;
num_estepe          = ival;                     "Set the variable pointer"
values_sought(ival) = $MAXIMUM_ESTEPE;          "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 1e-5;                     "Define the allowed range"
value_max(ival)     = 1;
default(ival)       = $MAX-ELOSS;

" XIMAX "
ival                = ival + 1;
num_ximax           = ival;                     "Set the variable pointer"
values_sought(ival) = $MAXIMUM_XIMAX;           "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1;
default(ival)       = $EXACT-BCA-XIMAX;

" BCA "
ival                = ival + 1;
num_bca             = ival;                     "Set the variable pointer"
values_sought(ival) = $BOUNDARY_ALGORITHM;      "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Exact';
allowed_inputs(ival,1) = 'PRESTA-I';

" Skindepth "
ival                = ival + 1;
num_skin            = ival;                     "Set the variable pointer"
values_sought(ival) = $SKIN_FOR_BCA;            "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = -1;                       "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $SKIN-DEPTH-FOR-BCA;

" Electron-step algorithm "
ival                = ival + 1;
num_alg             = ival;                     "Set the variable pointer"
values_sought(ival) = $ELECTRON_STEP_ALG;       "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'PRESTA-II'; "Better EGSnrc ???"
allowed_inputs(ival,1) = 'PRESTA-I';

" Photon cross sections "
ival                = ival + 1;
num_pxsec           = ival;
values_sought(ival) = $PHOTON_XSECTIONS;
nvalue(ival)        = 1;
type(ival)          = 2;

" Photon cross sections output "
ival                = ival + 1;
num_pxsec_out       = ival;
values_sought(ival) = $PHOTON_XSECTIONS_OUT;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';

" Compton cross sections "
ival                = ival + 1;
num_cxsec           = ival;
values_sought(ival) = $COMPTON_XSECTIONS;
nvalue(ival)        = 1;
type(ival)          = 2;

" E-Field "
ival                = ival + 1;
num_efield          = ival;                     "Set the variable pointer"
values_sought(ival) = $E_FIELD;                 "The code word"
nvalue(ival)        = 3;                        "3 inputs"
type(ival)          = 1;                        "A real number"
value_min(ival)     = -1e15;                    "Define the allowed range"
value_max(ival)     =  1e15;
default(ival)       =  0;

" B-Field "
ival                = ival + 1;
num_bfield          = ival;                     "Set the variable pointer"
values_sought(ival) = $B_FIELD;                 "The code word"
nvalue(ival)        = 3;                        "3 inputs"
type(ival)          = 1;                        "A real number"
value_min(ival)     = -1e10;                    "Define the allowed range"
value_max(ival)     =  1e10;
default(ival)       =  0;

" EM-field step and eloss restriction "
ival                = ival + 1;
num_emlmt           = ival;                     "Set the variable pointer"
values_sought(ival) = $EM_LMT;                 "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0.0;                      "Define the allowed range"
value_max(ival)     = 1.0;
default(ival)       = 0.02;

"Ali:photonuc, 2 blocks"
" Photonuclear "
ival                = ival + 1;
num_photonuc        = ival;           "set the variable pointer"
values_sought(ival) = $PHOTO_NUCLEAR; "the code word"
nvalue(ival)        = 1;              "1 input"
type(ival)          = 3;              "an `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;

" Photonuclear cross sections "
ival                = ival + 1;
num_photonuc_xsec   = ival;
values_sought(ival) = $PHOTONUC_XSECTIONS;
nvalue(ival)        = 1;
type(ival)          = 2;

"Ali:photonuc, 1 line"
Nmin = num_ecut; Nmax = num_photonuc_xsec;
"Nmin = num_ecut; Nmax = num_cxsec;"

CALL GET_INPUT;

IF( error_flags(num_ecut) = 0 ) [
    DO j=1,$MXREG [ ecut(j) = value(num_ecut,1); ]
]
IF( error_flags(num_pcut) = 0 ) [
    DO j=1,$MXREG [ pcut(j) = value(num_pcut,1); ]
]
IF( error_flags(num_smax) = 0 ) [
    DO j=1,$MXREG [ smaxir(j) = value(num_smax,1); ]
]
IF( error_flags(num_brems_ang) = 0 ) [
    ibrdst = value(num_brems_ang,1);
]
IF( error_flags(num_brems_cs) = 0 ) [
    ibr_nist = value(num_brems_cs,1);
]
IF( error_flags(num_radc) = 0 ) [
    radc_flag = value(num_radc,1);
]
IF( error_flags(num_pair_ang) = 0 ) [
    iprdst = value(num_pair_ang,1);
]
IF( error_flags(num_pair_cs) = 0 ) [
    pair_nrc = value(num_pair_cs,1);
]
IF( error_flags(num_triplet) = 0 ) [
    itriplet = value(num_triplet,1);
]
IF( error_flags(num_eii_L) = 0 ) [ eii_L_factor = value(num_eii_L,1); ]
IF( error_flags(num_estepe) = 0 ) [ estepe = value(num_estepe,1); ]
IF( error_flags(num_ximax) = 0 ) [ ximax = value(num_ximax,1); ]
IF( error_flags(num_bca) = 0 ) [
    bca_algorithm = value(num_bca,1);
    IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
]
IF( error_flags(num_alg) = 0 ) [ transport_algorithm = value(num_alg,1); ]
IF( error_flags(num_skin) = 0 ) [ skindepth_for_bca = value(num_skin,1); ]
IF( error_flags(num_spin) = 0 ) [
   itmp = value(num_spin,1);
   IF( itmp = 1 ) [ spin_effects = .true.; ]
   ELSE           [ spin_effects = .false.; ]
]
/******************************************************
   Mantaining compatibility with previous versions
   allowing ON(IK) and OFF besides custom EII data
   compilation files of the form eii_prefix.data.
 ******************************************************/
IF( error_flags(num_eii) = 0 ) [
   eii_xfile = char_value(num_eii,1);eii_flag=1;
   IF (toUpper($cstring(eii_xfile)).eq.'ON' |
       toUpper($cstring(eii_xfile)).eq.'IK' )[
       eii_xfile = 'ik';
    $egs_info(*,'==> Using default EII data compilation ',
              $cstring(eii_xfile));
   ]
   ELSEIF (toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'OFF')[
       eii_xfile='Off';eii_flag=0;
   ]
   ELSE["Using non-default EII data compilation"
    $egs_warning(*,'==> Using non-default EII data compilation ',
                 $cstring(eii_xfile));
   ]
]
/******************************************************
   Use Sabbatucci and Salvat shellwise photoelectric
   cross sections together with XCOM or EPDL cross sections
   for pair production.
 ******************************************************/
IF( error_flags(num_pxsec) = 0 ) [
    photon_xsections = char_value(num_pxsec,1);
    IF ( toUpper( $cstring(photon_xsections) ) = 'MCDF-XCOM' )[
        mcdf_pe_xsections = .true.; photon_xsections = 'xcom';
    ]
    ELSEIF ( toUpper( $cstring(photon_xsections) ) = 'MCDF-EPDL' )[
        mcdf_pe_xsections = .true.; photon_xsections = 'epdl';
    ]
    ELSE[
        mcdf_pe_xsections = .false.;
    ]
]
/**********************************************************/
IF( error_flags(num_pxsec_out) = 0 ) [
    xsec_out = value(num_pxsec_out,1);
]
IF( error_flags(num_cxsec) = 0 ) [
    comp_xsections = char_value(num_cxsec,1);
]
"Ali:photonuc, 3 lines"
IF( error_flags(num_photonuc_xsec) = 0 ) [
    photonuc_xsections = char_value(num_photonuc_xsec,1);
]

IF( error_flags(num_efield) = 0 ) [
    ExIN = value(num_efield,1);
    EyIN = value(num_efield,2);
    EzIN = value(num_efield,3);
    IF( error_flags(num_emlmt) = 0 )[
       EMLMTIN=value(num_emlmt,1);
    ]
    IF( ExIN**2+EyIN**2+EzIN**2 > 0 ) [
        emfield_on=.true.
    ]
]
" Initially set to input values, could change with regions"
" by converting it to an array over all regions. This is  "
" currently implemented only for the C++ applications     "
IF( error_flags(num_bfield) = 0 ) [
    BxIN = value(num_bfield,1);
    ByIN = value(num_bfield,2);
    BzIN = value(num_bfield,3);
    Bx=BxIN;By=ByIN;Bz=BzIN;
    Bx_new=BxIN;By_new=ByIN;Bz_new=BzIN;
    IF( error_flags(num_emlmt) = 0 )[
       EMLMTIN=value(num_emlmt,1);
    ]
    IF( BxIN**2+ByIN**2+BzIN**2 > 0 ) [
        emfield_on=.true.
    ]
]


/***************************************************************/
/* Get media for which to read custom ff and the ff file names */
/***************************************************************/
IF( error_flags(num_coh) = 0 ) [
  IF(value(num_coh,1) = 4)[
   write(*,'(/a/)') ' ===> custom ff requested!';
   ival                = ival + 1;
   num_ffmed           = ival;
   values_sought(ival) = 'ff media names';
   type(ival)          = 2;  "i.e.  character input"
   nvalue(ival)        = 0;
   ival                = ival + 1;
   num_ffiles          = ival;
   values_sought(ival) = 'ff file names';
   type(ival)          = 2;  "i.e.  character input"
   nvalue(ival)        = 0;
   Nmin = num_ffmed; Nmax = num_ffiles;
   CALL GET_INPUT;
   IF( error_flags(num_ffmed) > 0 ) [
    $egs_fatal('(a/,a,I3)','Error reading custom ff! Terminating ...',
               ' error_flag = ', error_flags(num_ffmed));
   ]
   IF( error_flags(num_ffiles) > 0 ) [
    $egs_fatal('(a/,a,I3)','Error reading ff file names! Terminating ...',
               ' error_flag = ', error_flags(num_ffiles));
   ]
   IF (nvalue(num_ffmed)>$MXMED)[
      $egs_fatal('(a,a,i3,a)',
              '***** Number of media with custom ff larger ',
              'than maximum number of media $MXMED = ',$MXMED,
              ' increase $MXMED and try again!!!');
   ]
   DO i=1,nvalue(num_ffmed) [
    iray_ff_media(i) = char_value(num_ffmed,i);
    iray_ff_file(i)  = char_value(num_ffiles,i);
   ]
   value(num_coh,1) = 1; "reset to 1 since custom info in iray_ff_files"
  ]
  write(*,'(/)');
]
/***************************************************************/
/*
 Inputs allowing setting by region are checked with the macro
 $TURN-ON/OFF-IN-REGIONS. For this type of input, the second
 and third entries correspond to turning ON or OFF the interaction
 in specific regions. If no input is found, the default value is
 used.
 */
/***************************************************************/
$TURN-ON/OFF-IN-REGIONS(num_incoh,
                    'Bound Compton start region',
                    'Bound Compton stop region',
                    ibcmp); incoh_inregions = aux_inregions;
$TURN-ON/OFF-IN-REGIONS(num_coh,
                    'Rayleigh start region',
                    'Rayleigh stop region',
                    iraylr); coh_inregions = aux_inregions;
$TURN-ON/OFF-IN-REGIONS(num_relax,
                    'Relaxations start region',
                    'Relaxations stop region',
                    iedgfl); relax_inregions = aux_inregions;
$TURN-ON/OFF-IN-REGIONS(num_pe_ang,
                    'PE sampling start region',
                    'PE sampling stop region',
                    iphter); pe_inregions = aux_inregions;
"Ali:photonuc, 1 block"
$TURN-ON/OFF-IN-REGIONS(num_photonuc,
                    'Photonuclear start region',
                    'Photonuclear stop region',
                    iphotonucr); photonuc_inregions = aux_inregions;
$SET ecut IN REGIONS(num_ecut,0.,1e15,0.,'Set ECUT','Set ECUT start region',
                                         'Set ECUT stop region');
ecut_inregions = aux_inregions;

$SET pcut IN REGIONS(num_pcut,0.,1e15,0.,'Set PCUT','Set PCUT start region',
                                         'Set PCUT stop region');
pcut_inregions = aux_inregions;

$SET smaxir IN REGIONS(num_smax,0.,1e15,0.,'Set SMAX','Set SMAX start region',
                                         'Set SMAX stop region');
smax_inregions = aux_inregions;

write(i_errors,*);
write(i_errors,*)
' ******************** end input transport parameter *********************** ';
write(i_errors,*);

"Check if EADL relaxation requested. Note that original relaxation"
"algorithm using <M> and <N> is only turned ON for all regions."
"Moved past the $TURN-ON/OFF-IN-REGIONS statement to catch the"
"default case."
IF(value(num_relax,1) > 0 & value(num_relax,1) < 5)[
   eadl_relax = .true.;
   "Default relaxation is EADL"
   IF (value(num_relax,1) = 1)[value(num_relax,1)=4;]
]
ELSE [
    IF (mcdf_pe_xsections & value(num_relax,1) = 5)[
       eadl_relax = .true.; value(num_relax,1)=4;
       $egs_warning('(a/,a/,a/)',
                    '    Simplified atomic relaxation not allowed',
                    '    with shellwise PE cross sections. Resetting',
                    '    to detailed EADL atomic relaxation!!!');
    ]
    ELSE [
       eadl_relax = .false.;
    ]
]

" we put the information stored in allowed_inputs into "
" output_strings just in case the user over-rides it "
" before printing out the settings "

output_strings(1) = allowed_inputs(num_pair_ang,iprdst);
itmp = value(num_incoh,1);
output_strings(2) = allowed_inputs(num_incoh,itmp);
$RADC_WARNING;
output_strings(12) = allowed_inputs(num_radc,radc_flag);
itmp = value(num_coh,1);
output_strings(3) = allowed_inputs(num_coh,itmp);
itmp = value(num_relax,1);
output_strings(4) = allowed_inputs(num_relax,itmp);
itmp = value(num_pe_ang,1);
output_strings(5) = allowed_inputs(num_pe_ang,itmp);
output_strings(6) = allowed_inputs(num_brems_ang,ibrdst);
output_strings(7) = allowed_inputs(num_bca,bca_algorithm);
output_strings(8) = allowed_inputs(num_alg,transport_algorithm);
output_strings(9) = allowed_inputs(num_brems_cs,ibr_nist);
output_strings(10) = allowed_inputs(num_pair_cs,pair_nrc);
output_strings(11) = allowed_inputs(num_triplet,itriplet);
"output_strings(13) = allowed_inputs(num_eii,eii_flag);"
"Ali:photonuc, 2 lines"
itmp = value(num_photonuc,1);
output_strings(14) = allowed_inputs(num_photonuc,itmp);

entry show_transport_parameter(ounit);

IF ( ounit <= 0 ) return;

write(ounit,*);
write(ounit,'(a)') line;
write(ounit,*);
write(ounit,'(a,/)')
'                   Electron/Photon transport parameter';
write(ounit,'(a,/)') line;

/* initialized in egs_set_defaults */
write(ounit,'(a,38x,a)') ' Photon cross sections',
      $cstring(photon_xsections);
write(ounit,'(a,37x,a)') ' Compton cross sections', $cstring(comp_xsections);

write(ounit,'(a,$)') ' Photon transport cutoff(MeV)';
IF( pcut_inregions ) [ write(ounit,'(32x,a)') 'Set in regions'; ]
ELSE [
    IF( pcut(1) > 1e-4 ) [ write(ounit,'(32x,g14.4)') pcut(1); ]
    ELSE [ write(ounit,'(32x,a)') 'AP(medium)'; ]
]
write(ounit,'(a,39x,a3)')  ' Pair angular sampling',output_strings(1);
write(ounit,'(a,41x,a3)')  ' Pair cross sections',output_strings(10);
write(ounit,'(a,42x,a3)')  ' Triplet production',output_strings(11);
write(ounit,'(a,36x,a14)') ' Bound Compton scattering',output_strings(2);
write(ounit,'(a,31x,a14)') ' Radiative Compton corrections',output_strings(12);
write(ounit,'(a,41x,a14)') ' Rayleigh scattering',output_strings(3);
write(ounit,'(a,42x,a14)') ' Atomic relaxations',output_strings(4);
write(ounit,'(a,30x,a14)') ' Photoelectron angular sampling',output_strings(5);
"Ali:photonuc, 3 lines. EMH added IF statement"
IF ( value(num_photonuc,1) > 0 )[
 write(ounit,'(a,36x,a14)') ' Photonuclear attenuation',output_strings(14);
 write(ounit,'(a,33x,a)') ' Photonuclear cross sections',
 $cstring(photonuc_xsections);
]

write(ounit,*);

write(ounit,'(a,$)') ' Electron transport cutoff(MeV)';
IF( ecut_inregions ) [ write(ounit,'(30x,a)') 'Set in regions'; ]
ELSE [
    IF( ecut(1) > 1e-4 ) [ write(ounit,'(30x,f7.4)') ecut(1); ]
    ELSE [ write(ounit,'(30x,a)') 'AE(medium)'; ]
]
write(ounit,'(a,30x,a4)') ' Bremsstrahlung cross sections',output_strings(9);
write(ounit,'(a,29x,a3)') ' Bremsstrahlung angular sampling',output_strings(6);
IF( spin_effects ) [ write(ounit,'(a,48x,a)') ' Spin effects','On'; ]
ELSE [ write(ounit,'(a,48x,a)') ' Spin effects','Off'; ]
write(ounit,'(a,34x,a)') ' Electron Impact Ionization',$cstring(eii_xfile);
IF (eii_L_factor ~= 1.0) [
   write(ounit,'(a,25x,f6.4)')
   ' L-shell EII xsections scaling factor',eii_L_factor;
]
write(ounit,'(a,$)') ' Maxium electron step in cm (SMAX)';
IF( smax_inregions ) [ write(ounit,'(27x,a)') 'Set in regions'; ]
ELSE [
    IF( smaxir(1) > 1e-4 ) [ write(ounit,'(27x,g14.4)') smaxir(1); ]
    ELSE [ write(ounit,'(27x,a)') 'Restriction is off'; ]
]
write(ounit,'(a,16x,f6.4)')
 ' Maximum fractional energy loss/step (ESTEPE)',estepe;
write(ounit,'(a,21x,f6.4)')
 ' Maximum 1st elastic moment/step (XIMAX)',ximax;
write(ounit,'(a,33x,a10)')
 ' Boundary crossing algorithm',output_strings(7);
write(ounit,'(a,22x,g9.4)')
 ' Skin-depth for boundary crossing (MFP)',skindepth_for_bca;
write(ounit,'(a,37x,a10)')
 ' Electron-step algorithm',output_strings(8);
IF( ExIN~=0 | EyIN~=0 | EzIN~=0 )[
  write(ounit,'(a,38x,3f10.2)') ' Electric Field [V/cm]',
                  ExIN,EyIN,EzIN;
]
IF( Bx~=0 | By~=0 | Bz~=0 )[
  write(ounit,'(a,41x,3f10.2)') ' Magnetic Field [T]',
                  Bx,By,Bz;
]
IF( ExIN~=0 | EyIN~=0 | EzIN~=0 |
    Bx~=0 | By~=0 | Bz~=0 )[
  write(ounit,'(a,50x,f10.2)') ' EM ESTEPE',EMLMTIN;
]
write(ounit,*);
write(ounit,'(a)') line;
write(ounit,*);

return;
end;
;
/************************************************************************
 *
 * The following subroutine can be used to modify the elastic
 * scattering power in one or more media.
 * To do so, the user includes one or more lines in
 * the transport parameter section of the input file
 *
 *     scale elastic scattering in SOME_MEDIUM= 1.05
 *
 * where SOME_MEDIUM is the name of a medium.
 *
 * The effect of this will be that both, xcc and blcc will
 * get multiplied with the provided factor, leaving the
 * screening angle unchanged but increasing the number of collisions
 * per unit length.
 *
 ************************************************************************/

subroutine set_elastic_parameter;

implicit none;
$INTEGER ounit;
$declare_max_medium;
;COMIN/GetInput,ELECIN,MEDIA,EGS-IO/;
$INTEGER imed,ival,lnblnk1,nchanged;
character*24 medname;

ounit = i_log;
ounit = i_log;
delimeter = $THE_DELIMETER;
call get_input_set_error_level(0);
ival = 0;
DO imed=1,nmed [
    call egs_get_medium_name(imed,medname);
    ival                = ival + 1;
    values_sought(ival) = 'scale elastic scattering in '//
                           medname(:lnblnk1(medname));
    nvalue(ival)        = 1;
    type(ival)          = 1;
    value_min(ival)     = 1e-3;
    value_max(ival)     = 1e3;
    default(ival)       = 1;
]
Nmin = 1; Nmax = nmed;
CALL GET_INPUT;
nchanged = 0;
DO imed=1,nmed [
    IF( error_flags(imed) = 0 ) nchanged = nchanged + 1;
]
IF( nchanged > 0 ) [
    write(ounit,'(//a)')
'================ Elastic scattering scaled as follows ==================';
    DO imed=1,nmed [
        IF( error_flags(imed) = 0 ) [
            call egs_get_medium_name(imed,medname);
            xcc(imed)  = xcc(imed)*value(imed,1);
            blcc(imed) = blcc(imed)*value(imed,1);
            write(ounit,'(a,t30,f10.6)') medname(:lnblnk1(medname)),
              value(imed,1);
        ]
    ]
    write(ounit,'(a//)')
'========================================================================';
]
return; end;
;

"==========================end of get_inputs.mortran=================="
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc media input functions                                               "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Blake Walters, 2013                                       "
"                                                                             "
"  Contributors:    Reid Townson                                              "
"                                                                             "
"#############################################################################"


SUBROUTINE GET_INPUT_PLUS(UNITNUM,DELIM_START,DELIM_END);
"                                                                           "
" A version of GET_INPUT that allows the user to specify a UNITNUM          "
" other than the .egsinp file and different start and end delimiters.       "
" Note that delimiters are interpreted literally.                           "
" If NONE is supplied as DELIM_END, then EOF is taken as the stop           "
" delimiter.                                                                "
"                                                                           "
"---------------------------------------------------------------------------"
;IMPLICIT NONE;

COMIN/GetInput,EGS-IO/;

"***************************************************************************"
"*                   Variables used by the subroutine                      *"
"***************************************************************************"
CHARACTER*$STRING256 TEXT;      "Used to read in each line of the input file   "
CHARACTER*$STRING256 KEEPTEXT;  "Used to keep an old line of TEXT              "
CHARACTER*$STRING256 ORIGTEXT;  "The text without conversion to upper case     "
CHARACTER*$STRING256 TEXTPIECE; "Used to read a piece of TEXT                  "
CHARACTER*$STRING40  DELIM_START;"Start of the delimeter                       "
CHARACTER*$STRING40  DELIM_END;  "End of the delimeter                         "
CHARACTER*$STRING40  ENDSTRING;  "string at which to terminate search          "
CHARACTER*$STRING32  VNAME;      "The name of the variable being extracted.    "
CHARACTER*$STRING32  VNAME1;     "The name of the variable being extracted.    "
$INTEGER       CURSOR;          "Used to read one of the TEXT letters          "
$INTEGER       IINDEX;          "Integer index for clipping string excess.     "
$INTEGER       iVNAME;          "Length of variable name string.               "
$INTEGER       IVAL;            "Value number of the value_sought              "
$INTEGER       UNITNUM;         "Unit number of the input file                 "
$INTEGER       ERR;             "Unit number of the error file                 "
$INTEGER       I,J,K,CHECK;     "Counters and checkers                         "
$INTEGER       LINE;            "Counts the eumber of lines                    "
$INTEGER       INT_VALUE;       "For printing integers                         "
$INTEGER       INT_VALUE_MIN;   "For printing integers                         "
$INTEGER       INT_VALUE_MAX;   "For printing integers                         "
$LOGICAL       ALLOWED;         "For evaluating an allowed_input               "
$LOGICAL       START_FOUND;     "Start of delimeter switch                     "
$INTEGER       ifound,length,lll,Kconvert;
$INTEGER       lnblnk1;"in house lnblnk function becuase not all compilers     "
                       "support this"
logical IDEBUG,end_string;
character*1 blank;
$INTEGER    error_level;
$INTEGER    the_level;
data blank/' '/;
data        error_level/1/;
save        error_level;
"---------------------------------------------------------------------------"

"Macro changing text string to upper case"
"REPLACE {$CONVERT-STRING-TO-UPPER-CASE(#);} WITH"
REPLACE {$CONVERT # TO UPPER CASE;} WITH
{;
   DO Kconvert=1, lnblnk1({P1}) [
         CURSOR=ICHAR({P1}(Kconvert:Kconvert));
         IF ((CURSOR.GE.97).AND.(CURSOR.LE.122)) [
            CURSOR=CURSOR-32;
            {P1}(Kconvert:Kconvert)=CHAR(CURSOR);
         ]
   ]
}
;

"Macro to skip leading blanks "
REPLACE {$SKIP LEADING BLANKS IN #;} WITH
{;
  length = len({P1});
  WHILE ( index({P1},blank) = 1 ) [
    IF( length >= 2 ) [ {P1}={P1}(2:); ] ELSE [ EXIT; ]
    length = length - 1;
  ]
}

"Macro that removes everything after comments "
REPLACE {$REMOVE EVERYTHING AFTER # IN #;} WITH
{
  ifound = INDEX({P2},{P1});
  IF( ifound > 1 ) [ {P2} = {P2}(1:ifound-1); ]
  ELSE [ IF( ifound = 1 ) [ {P2} = blank; ] ]
}

REPLACE {$STRING-OUTPUT(#);} WITH
{;
  length = lnblnk1({P1});
  IF( length > 0 ) [
    DO lll=1,length [ write(i_log,'(a1,$)') {P1}(lll:lll); ]
    write(i_log,*); "For a new line"
  ]
}

IDEBUG = .false.;   "set to .true. for debug outputs"
ERROR_FLAG = 0;
IF(IDEBUG) [OUTPUT NMIN,NMAX, $NMAX;(' Entering get_inputs seeking values',
   I5,' to', I5, '  with a max allowed of',I5);
]
IF (NMAX < NMIN | NMAX > $NMAX)[
  OUTPUT NMAX, NMIN, $NMAX;
  (//' Error entering get_inputs: Asked for values from',I5,' to',I5,
  '    with a max of',I5//' This implies a bug in the calling routine'/
  ' Fix it up and try again.  Stopping now.');
  STOP;
]
ERR=i_errors;    "inputfile.errors"
DELIM_START=DELIM_START(:lnblnk1(DELIM_START));
DELIM_END=DELIM_END(:lnblnk1(DELIM_END));
$SKIP LEADING BLANKS IN DELIM_START;
$SKIP LEADING BLANKS IN DELIM_END;
$CONVERT DELIM_START TO UPPER CASE; "This allows use of lower case letters"
$CONVERT DELIM_END TO UPPER CASE; "This allows use of lower case letters"
$SKIP LEADING BLANKS IN ENDSTRING;
IF(ENDSTRING=blank)[
   end_string=.false.;
]
ELSE[
   $CONVERT ENDSTRING TO UPPER CASE;
   end_string=.false.;
]

IF(IDEBUG) [OUTPUT DELIM_START,DELIM_END;(' start and stop delimeters are:'/
   A/A/);
]
"===================check that each value_sought is there===================="

DO I = NMIN, NMAX  [ "for each value_sought"
   REWIND (UNITNUM);
   LINE=0;             "reset line counter"
   CHECK=0;            "reset error checker"
   ERROR_FLAGS(I)=0;
   " Set to default for the case the input is not found "
   IF(TYPE(I) = 0 | TYPE(I) = 1) [ VALUE(I,1) = DEFAULT(I); ]
   IF(TYPE(I) = 3) [ VALUE(I,1) = 0; ]
   VNAME=VALUES_SOUGHT(I);
   iVNAME=lnblnk1(VNAME);
   IF( ivname < 1 )
   [
     IF( error_level > 0 ) [
       write(ERR,*) ' ======================= Warning ===================== ';
       write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!         ';
       write(ERR,*) ' ===================================================== ';
     ]
     ERROR_FLAG=1;
     ERROR_FLAGS(I)=1;
     goto :END-NMIN-NMAX-LOOP:;
   ]

   $CONVERT vname TO UPPER CASE; "This allows use of lower case letters"
   iindex = 0;
   IF (DELIM_START = 'NONE') [ start_found = .true.; ]
   ELSE                    [ start_found = .false.; ]
   WHILE ( iindex = 0 )  "Until the value sought is found"
   [
:GI25:
       CONTINUE;
       LINE=LINE+1;
       IF( start_found ) [
         READ(UNITNUM,END=:GI1003:,ERR=:GI1001:,FMT='(A256)') TEXT;
       ]
       ELSE [
         READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;
       ]
       "READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;"
       $SKIP LEADING BLANKS IN text;
       $REMOVE EVERYTHING AFTER '#' IN text;
       $REMOVE EVERYTHING AFTER ';' IN text;
       length = lnblnk1(TEXT);
       TEXT=TEXT(:length);
       origtext = text(:length);
       $CONVERT text TO UPPER CASE;
       IF( ~start_found ) [
         IF (INDEX(TEXT,DELIM_START) ~= 0 ) [ start_found = .true.; ]
         goto :GI25:;
       ]

       iindex=INDEX(TEXT,VNAME(:iVNAME));

       " Check for end delimeter "
       IF( DELIM_END~='NONE' )
       [
         IF (INDEX(TEXT,DELIM_END)~=0)
         [
             IF( error_level > 0 ) [
             WRITE (ERR,*) '***************ERROR***************';
             WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
                           '<<',' NOT FOUND';
             WRITE (ERR,*) 'END OF DELIMETER: ',DELIM_END;
             ]
             ERROR_FLAG=1;
             ERROR_FLAGS(I)=1;
             GOTO :END-NMIN-NMAX-LOOP:;
         ]
       ]
   ] "end while loop. If we pass this loop, we have the values_sought string "
     "in text"

   CHECK=0; "reset error checker"
   IF( idebug ) [
       write(i_log,*) ' ******* Found: ';
       write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
       write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
   ]

   " Set string pointer to position after vname string and/or "
   " leadinf equals                                           "
   IINDEX=IINDEX+iVNAME;
   TEXT=TEXT(IINDEX:); origtext=origtext(iindex:);
   IF( idebug ) [
       write(i_log,*) ' After removing vname: ';
       write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
       write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
   ]
   IINDEX=INDEX(TEXT,'=');
   IF (IINDEX.NE.0) [
      TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
   ]
   ELSE [
       IINDEX=INDEX(TEXT,':');
       IF (IINDEX.NE.0) [
          TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
       ]
   ]
   IF( idebug ) [
       write(i_log,*) ' After removing leading equals: ';
       write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
       write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
   ]

   "===============read the value(i)======================="
   IF ( (lnblnk1(TEXT)=0) | (lnblnk1(TEXT)=1) )
   [
        IF (vname(:ivname)='TITLE')
        [
           READ (UNITNUM,FMT='(A256)') TEXTPIECE;
           IF (lnblnk1(TEXTPIECE)~=0) [
              TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE));
              $SKIP LEADING BLANKS IN text;
              $SKIP LEADING BLANKS IN origtext;
              GOTO :TITLE-THERE:;
           ]
        ]
        IF( error_level > 0 ) [
        WRITE (ERR,*) '*************ERROR*************';
        WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
        WRITE (ERR,*) 'VALUE NOT THERE!!';
        ]
        ERROR_FLAG=1;
        ERROR_FLAGS(I)=1;
        RETURN;
   ]
:TITLE-THERE:
   CONTINUE;

   " Always check for default. The following sets the value to "
   " default(i) for a numeric input (type=1 or 2) and to 0 for "
   " an 'allowed input' => use only if one input is expected!  "
   iindex = index(text,'DEFAULT');
   IF( iindex ~= 0 )
   [                  "User requested a default value"
       IF( type(i) ~= 2 )
       [
           IF( type(i) ~= 3 ) [ VALUE(I,1)=DEFAULT(I); ]
           ELSE               [ VALUE(I,1)=0;          ]
           goto :END-NMIN-NMAX-LOOP:;
       ]
   ]

   IF ((TYPE(I) = 0)|(TYPE(I) = 1))
   [                                 "Read the number"
       IVAL=1;  "nvalue counter"
       IF( idebug )[write(i_log,*) ' *** Reading an integer or a real value! ';]
       LOOP
       [
           IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
           IF (lnblnk1(TEXT)=0) [
                 IF( error_level > 0 ) [
                 WRITE(ERR,*) '*************ERROR*************';
                 WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                 WRITE (ERR,*) 'VALUE NOT THERE!!';
                 ]
                 ERROR_FLAG=1;
                 ERROR_FLAGS(I)=1;
                 RETURN;
           ]
           READ(TEXT,END=:GI1010:,ERR=:GI1007:,FMT=*) VALUE(I,IVAL);
           IF( idebug ) [write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL);]
"==========================================================================="
"=================================Defaults=================================="

           IF ((VALUE(I,IVAL)>VALUE_MAX(I))|(VALUE(I,IVAL)<VALUE_MIN(I)))
           [
               IF (TYPE(I)=0)
               [
                    INT_VALUE=DEFAULT(I);
                    IF( error_level > 0 ) [
                    WRITE(ERR,*) '************WARNING************';
                    WRITE(ERR,:FMTA:) INT_VALUE,
                                 VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
                    ]
                    :FMTA: FORMAT ( 'Default= ',I9,' used for: ', A );
                    INT_VALUE=VALUE(I,IVAL);
                    INT_VALUE_MIN=VALUE_MIN(I);
                    INT_VALUE_MAX=VALUE_MAX(I);
                    IF( error_level > 0 ) [
                    WRITE(ERR,:FMTB:)
                        VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
                        INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX;
                    ]
                    :FMTB: FORMAT (A,'=', I9,' should be between ',
                                   I9,' and ', I9);
               ]
               IF (TYPE(I)=1)
               [
                    IF( error_level > 0 ) [
                    WRITE(ERR,*) '************WARNING************';
                    WRITE(ERR,:FMTC:) DEFAULT(I),
                                 VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
                    :FMTC: FORMAT ( 'Default= ',F12.6,' used for: ', A );
                    WRITE(ERR,:FMTD:)
                        VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
                        VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I);
                    :FMTD: FORMAT (A,'=', F12.6,' should be between ',
                                   G14.6,' and ', G14.6);
                    ]
               ]
               VALUE(I,IVAL)=DEFAULT(I);
           ] "end IF default"

           IF ( IVAL = NVALUE(I) ) EXIT; "Required inputs found"
"==========================================================================="
"=======================Move to next value, else exit======================="

           IF ((INDEX(TEXT,',')~=0)|(lnblnk1(TEXT)=0))
           [
               IF ( idebug ) [
                   write(i_log,*) ' A comma or a blank text found -> ';
                   write(i_log,*) ' searching for further input';
               ]
               TEXT=TEXT(INDEX(TEXT,',')+1:);
               WHILE (lnblnk1(TEXT)=0)
               [
                   IF ( idebug ) [
                     write(i_log,*) ' Empty text -> reading next line! ';
                   ]
                   LINE=LINE+1;
                   READ (UNITNUM,END=:GI1010:,ERR=:GI1007:,FMT='(A256)') TEXT;
                   $SKIP LEADING BLANKS IN text;
                   $REMOVE EVERYTHING AFTER '#' IN text;
                   $REMOVE EVERYTHING AFTER ';' IN text;
                   length = lnblnk1(TEXT);
                   TEXT=TEXT(:length);
                   origtext = text(:length);
                   $CONVERT text TO UPPER CASE;

                   "Check whether this line containes one of the strings sought"
                   DO K = 1 , NMAX
                   [
                       vname1 = VALUES_SOUGHT(K);
                       length = lnblnk1(vname1);
                       IF( length > 0 )
                       [
                           $SKIP LEADING BLANKS IN vname1;
                           $CONVERT vname1 TO UPPER CASE;
                           IF (INDEX(TEXT,vname1(:length))~=0)
                           [
                             IF( error_level > 0 ) [
                             WRITE(ERR,*) '************ERROR************';
                             WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                             WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
                                      '<--COMMA INDICATES ANOTHER INPUT';
                             WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
                                             TEXT(:lnblnk1(TEXT));
                             WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
                             ]
                             ERROR_FLAG=1;
                             ERROR_FLAGS(I)=1;
                           ]
                       ]
                   ]
                   IF( idebug ) [
                     write(i_log,*) ' Next line: ';
                     write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
                     write(i_log,'(a,$)') ' origtext: ';
                                          $STRING-OUTPUT(origtext);
                   ]
               ]
           ] "end if ~=0"
           ELSE [EXIT;]
           IVAL=IVAL+1;
       ] "end loop"
       IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
           IF( error_level > 0 ) [
           WRITE (ERR,*) '**************ERROR**************';
           WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
           WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)';
           WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
           ]
           ERROR_FLAG=1;
           ERROR_FLAGS(I)=1;
       ]
       ELSE [NVALUE(I)=IVAL;]
:GI1010:
       CONTINUE;
   ] "end IF TYPE"

"============================read the char_value(i)========================="

   IF ((TYPE(I) = 2) | (TYPE(I) = 3))
   [                                   "Read the string"
       IVAL=1;     "nvalue counter"
       IF( idebug ) [write(i_log,*) ' Trying to read a string! ';]
       LOOP
       [
           IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
           IF (lnblnk1(TEXT)=0) [
              IF( error_level > 0 ) [
              WRITE(ERR,*) '*************ERROR*************';
              WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
              WRITE (ERR,*) 'VALUE NOT THERE!!';
              ]
              ERROR_FLAG=1;
              ERROR_FLAGS(I)=1;
              RETURN;
           ]
           IF (vname(:ivname)='TITLE') [
              TEXTPIECE=origtext;
              GOTO :READ-IT:
           ]
           iindex = INDEX(origtext,',');
           IF ( iindex ~= 0 ) [ TEXTPIECE=origtext(:iindex-1); ]
           ELSE               [ TEXTPIECE=origtext;            ]
                      "The above is to avoid conversion to upper case"
                      "for e.g. media names                          "
           :READ-IT:
           CONTINUE;
           READ(TEXTPIECE,ERR=:GI1008:,FMT='(A256)') CHAR_VALUE(I,IVAL);
           $SKIP LEADING BLANKS IN CHAR_VALUE(I,IVAL);
           IF( idebug ) [
             write(i_log,*) ' Read the following char string: ';
             $STRING-OUTPUT(CHAR_VALUE(I,IVAL));
           ]
"===============================Allowed inputs=============================="
           IF (TYPE(I) = 3)
           [
              $CONVERT CHAR_VALUE(I,IVAL) TO UPPER CASE;
              ALLOWED=.FALSE.;
              DO K=0, $MXALINP [
                 vname1 = ALLOWED_INPUTS(I,K);
                 $SKIP LEADING BLANKS IN ALLOWED_INPUTS(I,K);
                 $CONVERT ALLOWED_INPUTS(I,K) TO UPPER CASE;
                 IF (ALLOWED_INPUTS(I,K)=CHAR_VALUE(I,IVAL)) [
                    ALLOWED=.TRUE.;
                    VALUE(I,IVAL)=K;
                    IF( idebug ) [
                      write(i_log,*) ' Found a allowed_value match ',k;
                    ]
                 ]
              ]
              IF (.NOT.ALLOWED) [
                 WRITE(ERR,*) '*************ERROR*************';
                 IF (IVAL~=1) [
                    WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                    WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY';
                 WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND VALUE';
                 ]
                 ELSE [
                    WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                    WRITE(ERR,*) 'INPUT-->',
                               CHAR_VALUE(I,IVAL)(:lnblnk1(CHAR_VALUE(I,IVAL))),
                               '<--NOT ALLOWED';
                    WRITE(ERR,*) 'OPTIONS ARE:';
                    WRITE(ERR,:FMT:)
                    (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_INPUTS(I,K))),
                     K=0,$MXALINP);
                 ]
                 :FMT: FORMAT(A40);
                 ERROR_FLAG=1;
                 ERROR_FLAGS(I)=1;
              ]
           ]
"=======================Move to next value, else exit======================="

           IF (vname(:ivname)='TITLE') [ EXIT; ]
           DO K=1,LEN(KEEPTEXT) [KEEPTEXT(K:K)=' ';]  "erase previous KEEPTEXT"
           KEEPTEXT(:lnblnk1(TEXT))=TEXT;
           iindex = INDEX(TEXT,',');
           IF ( iindex ~= 0 | lnblnk1(TEXT)=0 )
           [
               TEXT=TEXT(INDEX(TEXT,',')+1:);
               origtext=origtext(iindex+1:);
               WHILE (lnblnk1(TEXT)=0)
               [
                   LINE=LINE+1;
                   READ (UNITNUM,ERR=:GI1008:,FMT='(A256)') TEXT;
                   $SKIP LEADING BLANKS IN text;
                   $REMOVE EVERYTHING AFTER '#' IN text;
                   $REMOVE EVERYTHING AFTER ';' IN text;
                   length = lnblnk1(TEXT);
                   TEXT=TEXT(:length);
                   origtext = text(:length);
                   $CONVERT text TO UPPER CASE;

                   "Check whether this line containes one of the strings sought"
                   DO K = 1 , NMAX
                   [
                       vname1 = VALUES_SOUGHT(K);
                       length = lnblnk1(vname1);
                       IF( length > 0 )
                       [
                           $SKIP LEADING BLANKS IN vname1;
                           $CONVERT vname1 TO UPPER CASE;
                           IF (INDEX(TEXT,vname1(:length))~=0)
                           [
                             WRITE(ERR,*) '************ERROR************';
                             WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                             WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
                                      '<--COMMA INDICATES ANOTHER INPUT';
                             WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
                                             TEXT(:lnblnk1(TEXT));
                             WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
                             ERROR_FLAG=1;
                             ERROR_FLAGS(I)=1;
                           ]
                       ]
                   ]
               ]
           ] "end if ~=0"
           ELSE [EXIT;]
           IVAL=IVAL+1;
        ] "end loop"
        IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
           IF( error_level > 0 ) [
           WRITE (ERR,*) '*******************ERROR*******************';
           WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
           WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)';
           WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
           ]
           ERROR_FLAG=1;
           ERROR_FLAGS(I)=1;
        ]
        ELSE [NVALUE(I)=IVAL;]
   ]
"==========================================================================="
"==========================================================================="
   goto :END-NMIN-NMAX-LOOP:;

:GI1003:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '******************ERROR***********************';
        WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
        WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER';
        WRITE (ERR,*) 'VALUE SOUGHT: >>',
          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
        WRITE (ERR,*) 'END DELIMETER: >>',
          DELIM_END(:lnblnk1(DELIM_END)),'<<';
        ]
        ERROR_FLAG=1;
        ERROR_FLAGS(I)=1;
        goto :END-NMIN-NMAX-LOOP:;

:GI1004:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '******************ERROR***********************';
        WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
        WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER';
        WRITE (ERR,*) 'VALUE SOUGHT: >>',
          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
        WRITE (ERR,*) 'START DELIMETER: >>',
          DELIM_START(:lnblnk1(DELIM_START)),'<<';
        ]
        ERROR_FLAG=1;
        ERROR_FLAGS(I)=1;
        goto :END-NMIN-NMAX-LOOP:;

:GI1007:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '***************ERROR***************';
        IF (IVAL>1) [J=IVAL;] ELSE [J=1;]
        WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
        WRITE (ERR,*) 'LINE #',LINE;
        WRITE (ERR,*) 'COULD NOT READ THE VALUE!!';
        WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...';
        WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPUT?';
        ]
        ERROR_FLAG=1; "turn on the error flag"
        ERROR_FLAGS(I)=1; "turn on the error flag"
        GOTO :END-NMIN-NMAX-LOOP:;
:GI1008:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '***************ERROR***************';
        WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
        WRITE (ERR,*) 'LINE #',LINE;
        WRITE (ERR,*) 'COULD NOT READ THE STRING !!';
        ]
        ERROR_FLAG=1; "turn on the error flag"
        ERROR_FLAGS(I)=1; "turn on the error flag"

:END-NMIN-NMAX-LOOP:
    CONTINUE;
] "end do NMAX loop"
RETURN;

"**************if any errors**************"
:GI1001:
      WRITE (ERR,*) '***************ERROR***************';
      WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE;
      goto :GI1009:;
:GI1009:
      CONTINUE;  "exit if there is an error"
      ERROR_FLAG=1; "turn on the error flag"
      ERROR_FLAGS(I)=1; "turn on the error flag"
      RETURN;

entry get_input_plus_set_error_level(the_level);
error_level = the_level;
return;
END;

"*****************************************************************************
"
subroutine get_media_inputs(ounit);
"subroutine to take the media names in the input file and get the material
"data, either from a user-specified material data file, from material data
"specified explicitly in the input file, or from a user-specified density
"correction file.  This subroutine is called in HATCH.  It assumes that
"the subroutine get_transport_parameter has already been called and that
"the media names in the simulation have already been read in.

implicit none;

REPLACE{$MAXPOINTS}WITH{300};

$INTEGER ounit;
$declare_max_medium;

$COMIN-GET-TRANSPORTP;
COMIN/MEDINP,ELECIN,THRESH,ELEMTB,USEFUL/;

$INTEGER  ival,ival_media,ival_medfile,i,j,k,ival_ae,ival_ue,ival_ap,ival_up,
          ival_rho,ival_elements,ival_rhoz,ival_iunrst,ival_iaprim,ival_gasp,
          ival_pz,ival_sterncid,
          ival_densityfile,medfile_error,ival_outfile,
          egs_open_file,lnblnk1,i_medfile,egs_get_unit,i_mederr,mindex,eindex,
          i_density,i01,length,i_outfile;
$REAL ecut_min, pcut_min;

$LOGICAL  medfile_specified,densityfile_specified,elements_specified,
          outfile_specified($MXMED);
$LOGICAL  iunrst_specified,stern_specified,iaprim_specified,
          gasp_specified,rho_specified,start_delim_found,end_delim_found,
          spec_by_pz,spec_by_rhoz,df_if_elem_mismatch($MXMED),
          df_if_rho_mismatch($MXMED);
$LOGICAL  ex;

$INTEGER CURSOR,Kconvert;

"maybe we do not need to keep ZTBL REAL4, since it is only used here"
$REAL4 ZTBL;

"variables for output of cross-section data to file for plotting"
"some names end with O to avoid conflict with global variables"
"in common blocks above"
$REAL EKE,ELKE,TMXSO,DEDXE,DEDXP,EFRACT,SIGE,SIGP,BREME,BREMP,ETAB(16),
      EIE,PLOTE($MAXPOINTS),PLOTEM($MAXPOINTS),PLOTEEN($MAXPOINTS),
      PLOTEMP($MAXPOINTS), PLOTEMS($MAXPOINTS);
$INTEGER IPLOTE,IFLAG1,IFLAG2,LELKE;
CHARACTER*60 GRAPHTITLE,XAXIS,YAXISPcom,YAXISPmfp,YAXISE,YAXISEmfp,
              SUBTITLE,SERIES;
DATA ETAB/1.,1.25,1.5,1.75,2.,2.5,3.,3.5,4.,4.5,5.,5.5,6.,7.,8.,9./;


character*24 medium_name,med_tmp,sterncid_tmp;
character*256 density_file,material_file,tmp_string,
              spoutput_file($MXMED);
character*80 text_string, text_save, title;
character*40 delim_start,delim_end;
character*1 blank;
character*512 toUpper;

"temporary variables for storing values before committing them"
"to the media library"
$INTEGER nne_tmp,iaprim_tmp,epstfl_tmp,iunrst_tmp;
$REAL rho_tmp,rhoz_tmp($MXEL),z_tmp($MXEL),pz_tmp($MXEL),ae_tmp,ap_tmp,
      ue_tmp,up_tmp,gasp_tmp;
$TYPE asym_tmp($MXEL);

"for stuff read from the density correction file"
$INTEGER nepst_df,nne_df;
$REAL iev_df,rho_df,z_df($MXEL),rhoz_df($MXEL),rhoz_tot;
$TYPE asym_df($MXEL);

data blank/' '/;

save medfile_specified,material_file,df_if_elem_mismatch,df_if_rho_mismatch,
     spoutput_file,outfile_specified;

REPLACE {$WRITE_MEDERR(#)} WITH {
;
IF(n_parallel=0 | i_parallel=first_parallel)[
write(i_mederr,*){P1};
]
;
}
;

call get_input_set_error_level(0);
call get_input_plus_set_error_level(0);

"open a file for output from this routine"
IF(n_parallel=0 | i_parallel=first_parallel)[
  i_mederr=17;
  i_mederr=egs_open_file(i_mederr,0,1,'.mederr');
]

"find min. ecut and pcut"
ecut_min=999.;
pcut_min=999.;
DO i=1,$MXREG[
  IF(ecut(i)<ecut_min)ecut_min=ecut(i);
  IF(pcut(i)<pcut_min)pcut_min=pcut(i);
]

delimeter = 'MEDIA DEFINITION';
ival = 0;

/*
"list of medium names"
ival                = ival + 1;
ival_media           = ival;
values_sought(ival) = 'media names';
type(ival)          = 2;  "i.e.  character input"
nvalue(ival)        = 0;
Nmin = ival_media; Nmax = ival_media;

CALL GET_INPUT;
IF( error_flags(ival_media) > 0 ) [
    $egs_fatal('(a/,a,I3)',
'Error reading media names.  You must supply them if using pegsless mode.',
               ' error_flag = ', error_flags(ival_media));
]
IF (nvalue(ival_media)>$MXMED)[
      $egs_fatal('(a,a,i3,a)',
              '***** Number of media greater than maximum ',
              'allowed. $MXMED = ',$MXMED,
              ' increase $MXMED and try again!!!');
]
"now load media names into variables"
DO i=1,nvalue(ival_media) [
  media_names(i)=char_value(ival_med,i);
  DO j=1,24[
    inpmed(j,i) = char_value(ival_med,i)(j:j);
  ]
]
*/

"full name of media data file"
ival                = ival + 1;
ival_medfile         = ival;
values_sought(ival) = 'material data file';    "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 2;
Nmin = ival_medfile; Nmax = ival_medfile;
CALL GET_INPUT;
IF(error_flags(ival_medfile)=0)[
   material_file=char_value(ival_medfile,1);
   medfile_specified=.true.;
   "try opening it"
   i_medfile=17;
   i_medfile=egs_get_unit(i_medfile);
   IF(i_medfile < 1)[
     $egs_fatal('(a)','Error: Failed to get available fortran unit for',
     ' medium data file.');
   ]
   open(i_medfile,file=material_file,status='old',err=:no_media_file:);
   medfile_specified=.true.;
]
ELSE[
  $WRITE_MEDERR(' Warning: material data file not supplied.');
  $WRITE_MEDERR(' Thus, you must define media explicitly in input file');
  $WRITE_MEDERR(' or via density correction file.');
  medfile_specified=.false.;
]

"get AE, UE, AP, UP, if specified"
ival                = ival + 1;
ival_ae = ival;
values_sought(ival) = 'ae';
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;
value_min(ival)     = 0;
value_max(ival)     = 999.;
default(ival)       = ecut_min;

ival                = ival + 1;
ival_ap = ival;
values_sought(ival) = 'ap';
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;
value_min(ival)     = 0;
value_max(ival)     = 999.;
default(ival)       = pcut_min;

ival                = ival + 1;
ival_ue = ival;
values_sought(ival) = 'ue';
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;
value_min(ival)     = 0;
value_max(ival)     = 999.;
default(ival)       = 50 + prm;

ival                = ival + 1;
ival_up = ival;
values_sought(ival) = 'up';
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;
value_min(ival)     = 0;
value_max(ival)     = 999.;
default(ival)       = 50.0;

Nmin=ival_ae;Nmax=ival_up;
CALL GET_INPUT;
IF(error_flags(ival_ae)=0)[
   ae_tmp=value(ival_ae,1);
]
ELSE[
   $WRITE_MEDERR(' Warning: AE for media not supplied.  Will use min. ECUT.');
   ae_tmp=ecut_min;
]
IF(error_flags(ival_ap)=0)[
   ap_tmp=value(ival_ap,1);
]
ELSE[
   $WRITE_MEDERR(' Warning: AP for media not supplied.  Will use min. PCUT.');
   ap_tmp=pcut_min;
]
IF(error_flags(ival_ue)=0)[
   ue_tmp=value(ival_ue,1);
]
ELSE[
   $WRITE_MEDERR(' Warning: UE for media not supplied.  Will use
     50.5109989461 MeV');
   ue_tmp=50 + prm;
]
IF(error_flags(ival_up)=0)[
   up_tmp=value(ival_up,1);
]
ELSE[
   $WRITE_MEDERR(' Warning: UP for media not supplied.  Will use 50.0 MeV');
   up_tmp=50.;
]

IF(ue_tmp<=ae_tmp)[
   $WRITE_MEDERR(' Error: UE <= AE.  Adjust value(s) and try again.');
   $egs_fatal('(a)',' Error: UE <= AE.  Adjust value(s) and try again.');
]
IF(up_tmp<=ap_tmp)[
   $WRITE_MEDERR(' Error: UP <= AP.  Adjust value(s) and try again.');
   $egs_fatal('(a)',' Error: UP <= AP.  Adjust value(s) and try again.');
]

"now check for individual media inputs in file"
"if not there, get data from material data file"

DO i=1,NMED[

   "convert medium name to string for ease of"
   "implementation"
   DO j=1,24[medium_name(j:j)=media(j,i);]

   "set up defaults"
   elements_specified=.false.;
   rho_specified=.false.;
   densityfile_specified=.false.;
   stern_specified=.false.;
   iunrst_specified=.false.;
   iaprim_specified=.false.;
   gasp_specified=.false.;
   spec_by_rhoz=.false.;
   spec_by_pz=.false.;
   df_if_elem_mismatch(i)=.false.;
   df_if_rho_mismatch(i)=.false.;

   sterncid_tmp=medium_name;
   gasp_tmp=0.0;
   iunrst_tmp=0;
   iaprim_tmp=0;
   epstfl_tmp=0;
   density_file=' ';

   $WRITE_MEDERR(' ');

   $WRITE_MEDERR(' For medium: ',medium_name);

   delimeter=$cstring(medium_name);

   ival=0;

   "see if composition is specified explicitly"
   ival=ival+1;
   ival_elements=ival;
   values_sought(ival) = 'elements';
   type(ival)          = 2;  "i.e.  character input"
   nvalue(ival)        = 0;
   nmin=ival_elements;nmax=ival_elements;
   CALL GET_INPUT;
   IF(error_flags(ival_elements)=0)[
    DO j=1,nvalue(ival_elements)[
        $CONVERT char_value(ival_elements,j) TO UPPER CASE;
    ]
    "now get fraction of each element"
    ival=ival+1;
    ival_pz=ival;
    nne_tmp=nvalue(ival_elements);
    values_sought(ival)='number of atoms';
    type(ival)=0;
    nvalue(ival)=nne_tmp;
    nmin=ival_pz;nmax=ival_pz;
    CALL GET_INPUT;
    IF(nne_tmp>1 & error_flags(ival_pz)=0)[
        "got em.  Use em.  But not if this is an element"
        DO j=1,nne_tmp[
          asym_tmp(j)=char_value(ival_elements,j);
          pz_tmp(j)=value(ival_pz,j);
        ]
        elements_specified=.true.;
        spec_by_pz=.true.;
    ]
    ELSE[
        "check to see if fractional wts specified"
        ival=ival+1;
        ival_rhoz=ival;
        values_sought(ival)='mass fractions';
        type(ival)=1;
        nvalue(ival)=nne_tmp;
        nmin=ival_rhoz;nmax=ival_rhoz;
        IF(nne_tmp=1)[
          "set max, min and default values"
          value_min(ival)=0.0;
          value_max(ival)=1.e15;
          default(ival)=1.;
        ]
        CALL GET_INPUT;
        IF(error_flags(ival_rhoz)=0)[
           "got em.  Use em."
          DO j=1,nne_tmp[
            asym_tmp(j)=char_value(ival_elements,j);
            rhoz_tmp(j)=value(ival_rhoz,j);
          ]
          elements_specified=.true.;
          spec_by_rhoz=.true.;
        ]
     ]
     IF(nne_tmp=1 & ~elements_specified)[
      "an element: set pz to 1 and use default atomic weight"
        asym_tmp(1)=char_value(ival_elements,1);
        pz_tmp(1)=1;
        elements_specified=.true.;
        spec_by_pz=.true.;
     ]
     IF(elements_specified)[
       $WRITE_MEDERR(' Composition specified in .egsinp file.');
     ]
   ]

   "see what else is there"
   ival=ival+1;
   ival_rho=ival;
   values_sought(ival) = 'rho';
   type(ival)=1;
   nvalue(ival)=1;
   value_min(ival)=0.;
   value_max(ival)=1e15;
   default(ival)=1.0;
   nmin=ival_rho;nmax=ival_rho;
   CALL GET_INPUT;
   IF(error_flags(ival_rho)=0)[
      rho_tmp=value(ival_rho,1);
      rho_specified=.true.;
      $WRITE_MEDERR(' Rho specified in .egsinp file.');
   ]

   "now see what else is specified in the .egsinp file"
   ival=ival+1;
   ival_sterncid=ival;
   values_sought(ival)='sterncid';
   type(ival)=2;
   nvalue(ival)=1;
   nmin=ival_sterncid;nmax=ival_sterncid;
   CALL GET_INPUT;
   IF(error_flags(ival_sterncid)=0)[
      sterncid_tmp=char_value(ival_sterncid,1);
      stern_specified=.true.;
      $WRITE_MEDERR(' STERNCID specified in .egsinp file.');
   ]

   ival=ival+1;
   ival_iunrst=ival;
   values_sought(ival)='stopping powers';
   type(ival)=3;
   nvalue(ival)=1;
   allowed_inputs(ival,0)='restricted total';
   allowed_inputs(ival,1)='unrestricted collision';
   allowed_inputs(ival,2)='unrestricted collision and radiative';
   allowed_inputs(ival,3)='unrestricted collision and restricted radiative';
   allowed_inputs(ival,4)='restricted collision and unrestricted radiative';
   allowed_inputs(ival,5)='unrestricted radiative';
   nmin=ival_iunrst;nmax=ival_iunrst;
   CALL GET_INPUT;
   IF(error_flags(ival_iunrst)=0)[
      iunrst_tmp=value(ival_iunrst,1);
      iunrst_specified=.true.;
      $WRITE_MEDERR(' IUNRST specified in .egsinp file.');
   ]

   ival=ival+1;
   ival_iaprim=ival;
   values_sought(ival)='bremsstrahlung correction';
   type(ival)=3;
   nvalue(ival)=1;
   allowed_inputs(ival,0)='KM';
   allowed_inputs(ival,1)='NRC';
   allowed_inputs(ival,2)='none';
   nmin=ival_iaprim;nmax=ival_iaprim;
   CALL GET_INPUT;
   IF(error_flags(ival_iaprim)=0)[
      iaprim_tmp=value(ival_iaprim,1);
      iaprim_specified=.true.;
      $WRITE_MEDERR(' IAPRIM specified in .egsinp file.');
   ]

   ival=ival+1;
   ival_gasp=ival;
   values_sought(ival)='gas pressure';
   type(ival)=1;
   nvalue(ival)=1;
   value_min(ival)=0.;
   value_max(ival)=1e15;
   default(ival)=0.0;
   nmin=ival_gasp;nmax=ival_gasp;
   CALL GET_INPUT;
   IF(error_flags(ival_gasp)=0)[
      gasp_tmp=value(ival_gasp,1);
      gasp_specified=.true.;
      $WRITE_MEDERR(' GASP specified in .egsinp file.');
   ]

   ival=ival+1;
   ival_densityfile=ival;
   values_sought(ival)='density correction file';
   type(ival)          = 2;
   nvalue(ival)=1;
   nmin=ival_densityfile;nmax=ival_densityfile;
   CALL GET_INPUT;
   IF(error_flags(ival_densityfile)=0)[
       density_file=char_value(ival_densityfile,1);
       densityfile_specified=.true.;
       "may get changed to false later if it cannot be opened"
       $WRITE_MEDERR(' Density correction file specified in .egsinp file.');
   ]

   "check if the user has specified an output file for plotting"
   "e- data."
   ival = ival+1;
   ival_outfile = ival;
   values_sought(ival) = 'e- stopping power output file';
   type(ival) = 2;
   nvalue(ival) =1;
   nmin=ival_outfile;nmax=ival_outfile;
   CALL GET_INPUT;
   IF(error_flags(ival_outfile)=0)[
       spoutput_file(i)=char_value(ival_outfile,1);
       outfile_specified(i)=.true.;
       $WRITE_MEDERR(' e- stopping powers will be output to ',
         spoutput_file(i));
   ]
   ELSE [
       outfile_specified(i)=.false.;
   ]

   "done reading the .egsinp file for this medium"
   "see if we need anything from the material data file"
   IF(medfile_specified & (~elements_specified | ~rho_specified |
      ~iunrst_specified | ~iaprim_specified | ~gasp_specified |
      ~stern_specified | ~densityfile_specified))[
   "we assume at this point that the media file has been opened"
   "let us find the delimeters for this medium"
      rewind(i_medfile);
      start_delim_found=.false.;
      end_delim_found=.false.;
      WHILE(~start_delim_found | ~end_delim_found)[
        read(i_medfile,'(a)',end=:stop_medfile_read:)text_string;
        text_save=text_string;
        text_string=toUpper($cstring(text_string));
        mindex=index(text_string,'MEDIUM');
        eindex=index(text_string,'=');
        IF(mindex>0 & eindex>mindex)[
         "remove everything up to ="
         text_string=text_save(eindex+1:);
         text_string=$cstring(text_string);
         $SKIP LEADING BLANKS IN text_string;
         IF(text_string=medium_name)[
            delim_start=text_save;
            start_delim_found=.true.;
         ]
         ELSEIF(start_delim_found)[
            delim_end=text_save;
            end_delim_found=.true.;
         ]

        ]
      ]
      :stop_medfile_read:
      IF(~start_delim_found)[
        $WRITE_MEDERR(' Warning: Data for ',medium_name,' not found');
        $WRITE_MEDERR(' in material data file.');
      ]
      ELSE[
       IF(~end_delim_found)[
        "eof is end delimiter"
        delim_end='NONE';
       ]

       ival=0;
      "now go through and get what is required"
       IF(~elements_specified)[
         ival=ival+1;
         ival_elements=ival;
         values_sought(ival) = 'elements';
         type(ival)          = 2;  "i.e.  character input"
         nvalue(ival)        = 0;
         nmin=ival_elements;nmax=ival_elements;
         CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
         IF(error_flags(ival_elements)=0)[
           "now get fraction of each element"
           ival=ival+1;
           ival_pz=ival;
           nne_tmp=nvalue(ival_elements);
           values_sought(ival)='number of atoms';
           type(ival)=0;
           nvalue(ival)=nne_tmp;
           nmin=ival_pz;nmax=ival_pz;
           CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
           IF(nne_tmp>1 & error_flags(ival_pz)=0)[
              "got em.  Use em.  If its not an element"
              DO j=1,nne_tmp[
                asym_tmp(j)=char_value(ival_elements,j);
                pz_tmp(j)=value(ival_pz,j);
              ]
              elements_specified=.true.;
              spec_by_pz=.true.;
          ]
          ELSE[
              "check to see if fractional wts specified"
              ival=ival+1;
              ival_rhoz=ival;
              values_sought(ival)='mass fractions';
              type(ival)=1;
              nvalue(ival)=nne_tmp;
              nmin=ival_rhoz;nmax=ival_rhoz;
              IF(nne_tmp=1)[
                "set max, min and default values"
                value_min(ival)=0.0;
                value_max(ival)=1.e15;
                default(ival)=1.;
              ]
              CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
              IF(error_flags(ival_rhoz)=0)[
                "got em.  Use em."
                DO j=1,nne_tmp[
                  asym_tmp(j)=char_value(ival_elements,j);
                  rhoz_tmp(j)=value(ival_rhoz,j);
                ]
                elements_specified=.true.;
                spec_by_rhoz=.true.;
              ]
           ]
           IF(nne_tmp=1 & ~elements_specified)[
             asym_tmp(1)=char_value(ival_elements,1);
             pz_tmp(1)=1;
             elements_specified=.true.;
             spec_by_pz=.true.;
           ]
           IF(elements_specified)[
             $WRITE_MEDERR(' Composition specified in material data file');
           ]
         ]
        ]

        IF(~rho_specified)[
         ival=ival+1;
         ival_rho=ival;
         values_sought(ival) = 'rho';
         type(ival)=1;
         nvalue(ival)=1;
         value_min(ival)=0.;
         value_max(ival)=1e15;
         default(ival)=1.0;
         nmin=ival_rho;nmax=ival_rho;
         CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
         IF(error_flags(ival_rho)=0)[
           rho_tmp=value(ival_rho,1);
           rho_specified=.true.;
           $WRITE_MEDERR(' Rho specified in material data file');
         ]
        ]

        IF(~stern_specified)[
         ival=ival+1;
         ival_sterncid=ival;
         values_sought(ival)='sterncid';
         type(ival)=2;
         nvalue(ival)=1;
         nmin=ival_sterncid;nmax=ival_sterncid;
         CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
         IF(error_flags(ival_sterncid)=0)[
            sterncid_tmp=char_value(ival_sterncid,1);
            stern_specified=.true.;
            $WRITE_MEDERR(' STERNCID specified in material data file');
         ]
        ]

        IF(~iunrst_specified)[
         ival=ival+1;
         ival_iunrst=ival;
         values_sought(ival)='stopping powers';
         type(ival)=3;
         nvalue(ival)=1;
         allowed_inputs(ival,0)='restricted total';
         allowed_inputs(ival,1)='unrestricted collision';
         allowed_inputs(ival,2)='unrestricted collision and radiative';
         allowed_inputs(ival,3)=
             'unrestricted collision and restricted radiative';
         allowed_inputs(ival,4)=
             'restricted collision and unrestricted radiative';
         allowed_inputs(ival,5)='unrestricted radiative';
         nmin=ival_iunrst;nmax=ival_iunrst;
         CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
         IF(error_flags(ival_iunrst)=0)[
            iunrst_tmp=value(ival_iunrst,1);
            iunrst_specified=.true.;
            $WRITE_MEDERR(' IUNRST specified in material data file');
         ]
        ]

        IF(~iaprim_specified)[
         ival=ival+1;
         ival_iaprim=ival;
         values_sought(ival)='bremsstrahlung correction';
         type(ival)=3;
         nvalue(ival)=1;
         allowed_inputs(ival,0)='KM';
         allowed_inputs(ival,1)='NRC';
         allowed_inputs(ival,2)='none';
         nmin=ival_iaprim;nmax=ival_iaprim;
         CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
         IF(error_flags(ival_iaprim)=0)[
            iaprim_tmp=value(ival_iaprim,1);
            iaprim_specified=.true.;
            $WRITE_MEDERR(' IAPRIM specified in material data file');
         ]
        ]

        IF(~gasp_specified)[
         ival=ival+1;
         ival_gasp=ival;
         values_sought(ival)='gas pressure';
         type(ival)=1;
         nvalue(ival)=1;
         value_min(ival)=0.;
         value_max(ival)=1.e15;
         default(ival)=0.;
         nmin=ival_gasp;nmax=ival_gasp;
         CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
         IF(error_flags(ival_gasp)=0)[
            gasp_tmp=value(ival_gasp,1);
            gasp_specified=.true.;
            $WRITE_MEDERR(' GASP specified in material data file');
         ]
        ]

        IF(~densityfile_specified)[
         ival=ival+1;
         ival_densityfile=ival;
         values_sought(ival)='density correction file';
         type(ival)          = 2;
         nvalue(ival)=1;
         nmin=ival_densityfile;nmax=ival_densityfile;
         CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
         IF(error_flags(ival_densityfile)=0)[
            density_file=char_value(ival_densityfile,1);
            densityfile_specified=.true.;
            "may get changed to false later if it cannot be opened"
            $WRITE_MEDERR(
            ' Density correction file specified in material data file.');
         ]
        ]
      ]

   ]

   "now, try to open the density correction file, if specified"
   IF(densityfile_specified)[
     "if a file separator is specified in the name, assume the full path + name"
     "of the file is specified"
    write(*,*)' density_file ',density_file;
    IF(index(density_file,$file_sep)>0) [
       tmp_string=$cstring(density_file);
       inquire(file=tmp_string,exist=ex);
       IF(~ex)[
              $WRITE_MEDERR(' Error: Density correction file ',tmp_string);
              $WRITE_MEDERR(' cannot be found.');
       ]
    ]
    ELSE [
       density_file=$cstring(density_file)//'.density';
       "first look in $EGS_HOME/pegs4/density_corrections"
       tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
                  'density_corrections' // $file_sep // density_file;
       inquire(file=tmp_string,exist=ex);
       IF(ex) goto :density_file_found:;
       tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
                  'density_corrections' // $file_sep // 'elements' //
                    $file_sep // density_file;
       inquire(file=tmp_string,exist=ex);
       IF(ex) goto :density_file_found:;
       tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
                  'density_corrections' // $file_sep // 'compounds' //
                    $file_sep // density_file;
       inquire(file=tmp_string,exist=ex);
       IF(ex) goto :density_file_found:;
       "now look in $EGS_HOME/pegs4/density in case directory still there"
       tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
                  'density' // $file_sep // density_file;
       inquire(file=tmp_string,exist=ex);
       IF(ex) goto :density_file_found:;
       "now look through $HEN_HOUSE/pegs4/density_corrections"
       tmp_string=$cstring(hen_house) // 'pegs4' // $file_sep //
                    'density_corrections' // $file_sep // 'elements' //
                    $file_sep // density_file;
       inquire(file=tmp_string,exist=ex);
       IF(ex) goto :density_file_found:;
       tmp_string=$cstring(hen_house) // 'pegs4' // $file_sep //
                    'density_corrections' // $file_sep // 'compounds' //
                    $file_sep // density_file;
       inquire(file=tmp_string,exist=ex);
       IF(ex) goto :density_file_found:;
       $WRITE_MEDERR(' Error: Density correction file',
                        density_file);
       $WRITE_MEDERR(' does not exist in');
       $WRITE_MEDERR(' $EGS_HOME/pegs4/density_corrections, ');
       $WRITE_MEDERR(' $EGS_HOME/pegs4/density_corrections/elements, ');
       $WRITE_MEDERR(' $EGS_HOME/pegs4/density_corrections/compounds, ');
       $WRITE_MEDERR(' $EGS_HOME/pegs4/density, ');
       $WRITE_MEDERR(
        ' $HEN_HOUSE/pegs4/density_corrections/elements or ');
       $WRITE_MEDERR(
        ' $HEN_HOUSE/pegs4/density_corrections/compounds.');
       :density_file_found:
        ]
     ]

       IF(densityfile_specified)[
             "now try to open it"
         i_density=19;
         i_density=egs_get_unit(i_density);
         IF(i_density < 1)[
         $egs_fatal('(a)','Error: Failed to get available fortran unit for',
             ' density correction file.');
         ]
         open(i_density,file=tmp_string,status='old',err=:no_density_file:);
         density_file=tmp_string;
         densityfile_specified=.true.;
         epstfl_tmp=1;

         "the density file is open at this point so just read the data"

         read(i_density,'(a)')title;
         read(i_density,*)nepst_df,iev_df,rho_df,nne_df;
         read(i_density,*)(z_df(j),rhoz_df(j),j=1,nne_df);

         "get atomic symbols and pz based on df header"
         DO j=1,nne_df[
           i01=z_df(j);
           asym_df(j)=ASYMT(i01);
         ]

         "check to see if data read from density file matches"
         "composition and rho already input"
         IF(elements_specified)[
           IF(nne_tmp~=nne_df)[
             df_if_elem_mismatch(i)=.true.;
           ]
           ELSE[
             rhoz_tot=0.;
             DO j=1,nne_tmp["normalize rhoz as it is in dcf"
                 IF(spec_by_pz)[
                   i01=ZTBL(asym_tmp(j));
                   rhoz_tmp(j)=pz_tmp(j)*WATBL(i01);
                 ]
                 rhoz_tot=rhoz_tot+rhoz_tmp(j);
             ]
             DO j=1,nne_df[
               DO k=1,nne_tmp[ "at this point nne_df=nne_tmp"
                 IF(asym_df(j)=asym_tmp(k))[
                   IF(rhoz_df(j)>(1+0.01)*rhoz_tmp(k)/rhoz_tot |
                      rhoz_df(j)<(1-0.01)*rhoz_tmp(k)/rhoz_tot)[
                       df_if_elem_mismatch(i)=.true.;
                   ]
                   exit;
                 ]
               ]
               IF(k>nne_tmp) df_if_elem_mismatch(i)=.true.;
                           "never found the element"
               IF(df_if_elem_mismatch(i)) [exit;];
             ]
           ]
           IF(df_if_elem_mismatch(i))[
         $WRITE_MEDERR(' Warning: composition specified in density correction',
              ' file is not the same as that');
            $WRITE_MEDERR(' specified in input or material data file.');
            $WRITE_MEDERR(
         ' Will use the composition specified in the density correction file.');
            nne_tmp=nne_df;
            DO j=1,nne_tmp[
               z_tmp(j)=z_df(j);
               rhoz_tmp(j)=rhoz_df(j);
               asym_tmp(j)=asym_df(j);
            ]
            spec_by_rhoz=.true.;
           ]
         ]
         ELSE[
            $WRITE_MEDERR(' Composition specified in density correction file');
            nne_tmp=nne_df;
            DO j=1,nne_tmp[
               z_tmp(j)=z_df(j);
               rhoz_tmp(j)=rhoz_df(j);
               asym_tmp(j)=asym_df(j);
            ]
            spec_by_rhoz=.true.;
            elements_specified=.true.;
         ]

         IF(rho_specified)[
          "check to see if rho read from density correction file matches"
          "that already input"
          IF(rho_df>(1+0.01)*rho_tmp | rho_df<(1-0.01)*rho_tmp)[
             $WRITE_MEDERR(' Warning: rho specified in density correction',
              ' file is not the same as that');
            $WRITE_MEDERR(' specified in input or material data file.');
            $WRITE_MEDERR(
           ' Will use rho as specified in the density correction file.');
            rho_tmp=rho_df;
            df_if_rho_mismatch(i)=.true.;
          ]
         ]
         ELSE[
           rho_tmp=rho_df;
           rho_specified=.true.;
           $WRITE_MEDERR(' Rho specified in density correction file');
         ]

         IF(gasp_specified)[
           "any value of gasp other than 1 atm is incompatible with"
           "use of dcf and, since gasp is only used to scale rho when"
           "dcf is used, this input is now unecessary at best"
           $WRITE_MEDERR(' Warning: gas pressure input not required',
              ' when using density correction file.  Will set GASP=0.');
           gasp_specified=.false.;
           gasp_tmp=0.;
         ]

         "close the density file"
         close(i_density);
       ]

   "okay, now commit this to the media library"
   IF(elements_specified & rho_specified)[

       ae(i)=ae_tmp;
       ue(i)=ue_tmp;
       ap(i)=ap_tmp;
       up(i)=up_tmp;

       DO j=1,24[
         inpstrn(j,i) = sterncid_tmp(j:j);
       ]

       nne(i)=nne_tmp;
       rho(i)=rho_tmp;

       DO j=1,nne_tmp[
         inpasym(i,j)=asym_tmp(j);
         "assume we are getting z from asym"
         "redundant in the case where medium defined using"
         "density correction file"
         "ZTBL is a function defined in pegs4_routines.mortran"
         zelem(i,j)=ZTBL(asym_tmp(j));
         i01=zelem(i,j);
         "WATBL defined in pegs4_macros.mortran"
         wa(i,j)=WATBL(i01);
         wa4(i,j)=WATBL(i01);
         "also do $REAL4 math so we can check against cross-sections"
         "calculated by pegs4.mortran"
         IF(spec_by_rhoz)[
            rhoz(i,j)=rhoz_tmp(j);
            rhoz4(i,j)=rhoz_tmp(j);
            pz(i,j)=rhoz(i,j)/wa(i,j);
            pz4(i,j)=rhoz4(i,j)/wa4(i,j);

         ]
         ELSEIF(spec_by_pz)[
            pz(i,j)=pz_tmp(j);
            pz4(i,j)=pz_tmp(j);
            rhoz(i,j)=pz(i,j)*wa(i,j);
            rhoz4(i,j)=pz4(i,j)*wa4(i,j);
         ]
       ]

       iunrst(i)=iunrst_tmp;
       iaprim(i)=iaprim_tmp;
       epstfl(i)=epstfl_tmp;
       inpgasp(i)=gasp_tmp;
       inpdensity_file(i)=density_file;

    ]
    ELSE[
      $WRITE_MEDERR(' Error: Medium ',medium_name,' not correctly defined.');
    ]
]

IF(medfile_specified) close(i_medfile);

IF(n_parallel=0 | i_parallel=first_parallel) close(i_mederr);


entry show_media_parameters(ounit);

IF ( ounit <= 0 ) return;

IF(is_pegsless)[

"show common data"

write(ounit,*);
write(ounit,*)' Medium data: ';
write(ounit,*);
write(ounit,'(a,1p,e14.5,a,e14.5,a)')' AE = ',ae(1),' MeV,  UE = ',ue(1),' MeV';
write(ounit,'(a,1p,e14.5,a,e14.5,a)')' AP = ',ap(1),' MeV,  UP = ',up(1),' MeV';
write(ounit,*);
IF(medfile_specified)[
  write(ounit,*)' Material data file: ',material_file;
]
ELSE[
  write(ounit,*)' No material data file supplied.  Material data obtained from';
  write(ounit,*)' .egsinp file or density correction file.';
]
write(ounit,*);

"now list data for individual media that were successfully read in"

DO i=1,nmed[

  write(ounit,'(a,24a1)')'   Medium: ',(media(j,i),j=1,24);
  write(ounit,'(a,24a1)')' Sterncid: ',(inpstrn(j,i),j=1,24);
  write(ounit,'(a,1p,e14.5,a)')'     rho: ',rho(i),' g/cm^3';
  write(ounit,'(a,24a4)')' Elements: ',(inpasym(i,j),j=1,nne(i));
  write(ounit,'(a,1p,12e14.5)')'    rhoz: ',(rhoz(i,j),j=1,nne(i));
  write(ounit,'(a,1p,12e14.5)')'      pz: ',(pz(i,j),j=1,nne(i));
  write(ounit,'(a,i5)')'  iunrst: ',iunrst(i);
  write(ounit,'(a,i5)')'  iaprim: ',iaprim(i);
  write(ounit,'(a,1p,e14.5,a)')'    gasp: ',inpgasp(i),' atm.';
  IF(epstfl(i)=1)[
    write(ounit,*)' density correction file: ',
        $cstring(inpdensity_file(i));
    IF(df_if_elem_mismatch(i))[
     write(ounit,*)' ****Warning: composition specified in density correction',
              ' file is not the same as that';
     write(ounit,*)' specified in input or material data file.';
      write(ounit,*)
         ' Will use the composition specified in the density correction file.';
    ]
    IF(df_if_rho_mismatch(i))[
     write(ounit,*)' ****Warning: rho specified in density correction',
              ' file is not the same as that';
     write(ounit,*)' specified in input or material data file.';
      write(ounit,*)
         ' Will use rho as specified in the density correction file.';
    ]
  ]
  write(ounit,*);

 "output stopping powers to file for plotting if requested"
  IF(outfile_specified(i) & (n_parallel=0 | i_parallel=first_parallel)) [
    inquire(file=spoutput_file(i),exist=ex);
    IF(ex) [
      $egs_warning('(a)','Warning: stopping power output file ',
            spoutput_file(i),'already exists.  Will overwrite.');
    ]
    i_outfile=20;
    i_outfile=egs_get_unit(i_outfile);
    IF(i_outfile < 1)[
      $egs_warning('(a)','Warning: Failed to get available fortran unit for',
          ' stopping power output file.');
    ]
    open(i_outfile,file=spoutput_file(i),status='unknown',err=:no_output_file:);
    goto :got_outfile:;
    :no_output_file:
    $egs_warning('(a)','Warning: Failed to open stopping power output file ',
                spoutput_file(i));
    goto :end_outfile:;
    :got_outfile:
    IFLAG1=0;IFLAG2=0;IPLOTE=0;MEDIUM=i;
    XAXIS = 'kinetic energy / MeV';
    YAXISE = 'dE/drhoX MeV/g/cm\\S2\\N';
    YAXISEmfp = 'mean free path / cm';
    YAXISPmfp = 'mean free path / cm';
    write(GRAPHTITLE,'(24a1)')(media(j,i),j=1,24);
    SUBTITLE = 'Electron data';
    DO j=1,8[
     DO k=1,16[
       EKE=ETAB(k)*10.**(j-4);
       IF(EKE <= AE(1)-PRM) [
           IF(IFLAG1 = 0) [
             IFLAG1=1; EKE=AE(1)-PRM;
           ] ELSE [ EKE=0.0; ]
       ]

       IF(EKE > UE(1)-PRM) [
           IF(IFLAG2 = 0) [
             IFLAG2=1; EKE=UE(1)-PRM;
           ] ELSE [ EKE=1.E30; ]
       ]
       EIE=EKE+PRM;       TMXSO=0.0;        DEDXE=0.0;
       DEDXP=0.0;           EFRACT=0.0;
       IF(EIE >= AE(1)-0.0001 & EIE <= UE(1)+0.001) [
           ELKE=LOG(EKE);
           $SET INTERVAL ELKE,EKE;
           $EVALUATE DEDXE USING EDEDX(ELKE);"RESTRICTED STOPPING POWERS"

"enable below to plot other quantities"

/*
           $EVALUATE TMXSO USING TMXS(ELKE);"STEP SIZE"
           $EVALUATE DEDXP USING PDEDX(ELKE);
           EFRACT= TMXSO*DEDXE/EKE;

           $EVALUATE SIGE USING ESIG(ELKE);  "--PROBABILITY /CM"

           IF(SIGE = 0.0) [ SIGE=1.E-10; ]

           $EVALUATE SIGP USING PSIG(ELKE);

           IF(SIGP = 0.0) [ SIGP=1.E-10; ]
           $EVALUATE BREME USING EBR1(ELKE);  "--BREM FRACTION OF EVENTS"
           $EVALUATE BREMP USING PBR1(ELKE);
 */
           IPLOTE=IPLOTE+1;   "keep track of how many entries"
           PLOTEEN(IPLOTE)=EKE;
           PLOTE(IPLOTE)=DEDXE/RHO(MEDIUM);
"enable below to plot other quantities
 /*
           PLOTEM(IPLOTE)=1./SIGE;
           PLOTEMP(IPLOTE)=1./(SIGE*BREME);  "--mfp to bremsstrahlung only"
           IF(BREME < 1.) [
                PLOTEMS(IPLOTE)=1./(SIGE*(1.-BREME));  "--mfp to secondaries"
           ]
           ELSE [PLOTEMS(IPLOTE)= 1e6; "it goes forever if BREME=1."]
 */
       ]
     ]
    ]
    IF(IPLOTE>0)[
       "currently only plots stopping powers"
       IF(iunrst(i)=0) [
          SERIES='restricted total stopping power';
       ]
       ELSEIF(iunrst(i)=1) [
          SERIES='unrestricted collision stopping power';
       ]
       ELSEIF(iunrst(i)=2) [
          SERIES='unrestricted collision + radiative stopping power';
       ]
       ELSEIF(iunrst(i)=3) [
       SERIES='unrestricted collision + restricted radiative stopping power';
       ]
       ELSEIF(iunrst(i)=4) [
         SERIES='restricted collision + unrestricted radiative stopping power';
       ]
       ELSEIF(iunrst(i)=5) [
         SERIES='unrestricted radiative stopping power';
       ]
       CALL MEDXVGRPLOT(PLOTEEN,PLOTE,IPLOTE,0,SERIES,
               XAXIS,YAXISE,GRAPHTITLE,SUBTITLE,i_outfile,2);
    ]
    close(i_outfile);
    :end_outfile:
  ]
]
]

return;
:no_media_file:
$egs_fatal('(a)','Error: Cannot open material data file',material_file);
return;
:no_density_file:
$egs_fatal('(a)','Error: Cannot open density correction file: ',
$cstring(density_file));
return;
end;
;

"==========================end of get_inputs.mortran=================="

SUBROUTINE MEDXVGRPLOT (X, Y, NPTS, CURVENUM, SERIESTITLE,
                        XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                        UNITNUM, AXISTYPE);
"a version of XVGRPLOT specifically for plotting stopping powers and"
"associated data.  Note that this is required because xvgrplot.mortran"
"is not included at compile time for all user codes."
IMPLICIT NONE;

COMIN/EGS-IO/;

$INTEGER MAX;
PARAMETER (MAX = 400);  "---MAX used in defining the maximum number of---"
                          "---points that can be plotted in one series. ---"
$INTEGER NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE;
$REAL X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,SMALLESTX,
  SMALLESTY,FUDGE;
$INTEGER TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENGTH;
$INTEGER LOGX, LOGY;
CHARACTER*(*) SUBTITLE;
CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;
$LOGICAL TESTFILE, ALLPOS;

FUDGE = 1.e-10;

IF ( NPTS .gt. MAX) [ "Asked for too many points"
        OUTPUT NPTS, MAX;(//' **************************'/
        ' Number of points asked for =', I5,
        ' is greater than max allowed of', I4/
        ' Setting NPTS to MAX, you could adjust MAX in xvgrplot.mortran'/
        ' **************************'//);
        NPTS1 = MAX;
] ELSE [NPTS1 = NPTS;]

INQUIRE(UNIT = UNITNUM, OPENED = TESTFILE);

IF (~TESTFILE) [ "---File has not been opened - print message.---"
    WRITE(6,:125:) UNITNUM;
    :125: FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------'
                 ,/'   Unit specified (',I2,') is not open.'
                 ,/'   Unit must be opened before using subroutine.'
                 ,/'   Data not written to file.'
                 ,/'  ----------------------------------------------'//);
    RETURN;
] "---End of error message for unopened file---"


TITLELENGTH = 61;    SUBLENGTH = 61;       XAXISLENGTH = 61;
YAXISLENGTH = 61;    SERIESLENGTH = 61;

  "---Find title string length---"
LOOP [
   TITLELENGTH = TITLELENGTH - 1;
] UNTIL (GRAPHTITLE(TITLELENGTH:TITLELENGTH) ~= ' ');

  "---Find subtitle string length---"
LOOP [
    SUBLENGTH = SUBLENGTH - 1;
] UNTIL (SUBTITLE(SUBLENGTH:SUBLENGTH) ~= ' ');

  "---Find x-axis string length---"
LOOP [
    XAXISLENGTH = XAXISLENGTH - 1;
] UNTIL (XTITLE(XAXISLENGTH:XAXISLENGTH) ~= ' ');

  "---Find y-axis string length---"
LOOP [
    YAXISLENGTH = YAXISLENGTH - 1;
] UNTIL (YTITLE(YAXISLENGTH:YAXISLENGTH) ~= ' ');

  "---Find series title length---"
LOOP [
    SERIESLENGTH = SERIESLENGTH - 1;
] UNTIL (SERIESTITLE(SERIESLENGTH:SERIESLENGTH) ~= ' ');

  "---Initialize LOGX, LOGY, to be not set (0)---"
LOGX = 0;          LOGY = 0;

ALLPOS=.TRUE.;
IF ( X(1)=0.0 ) [SMALLESTX = 0.1;] ELSE [SMALLESTX=X(1);]
IF ( Y(1)=0.0 ) [SMALLESTY = 0.1;] ELSE [SMALLESTY=Y(1);]
DO COUNT = 1, NPTS1 [
       IF ((X(COUNT) < SMALLESTX) & (X(COUNT)~=0.)) [SMALLESTX=X(COUNT);]
       IF ((Y(COUNT) < SMALLESTY) & (Y(COUNT)~=0.)) [SMALLESTY=Y(COUNT);]
       IF ((X(COUNT) < 0.)|(Y(COUNT) < 0.)) [ALLPOS=.FALSE.;]
]
IF (ALLPOS) [
     DO COUNT = 1, NPTS1 [
          IF (X(COUNT)=0.) [X(COUNT)=SMALLESTX*FUDGE;]
          IF (Y(COUNT)=0.) [Y(COUNT)=SMALLESTY*FUDGE;]
     ]
]


IF (AXISTYPE > 0) [  "---At least one axis is of log type---"
    DO COUNT = 1, NPTS1 [
      IF (X(COUNT) <= 0.) [ LOGX = 1; ]
      IF (Y(COUNT) <= 0.) [ LOGY = 1; ]
    ]
]
  "---Now begin writing information to unit---"
IF (CURVENUM = 0) [ "---Case where plot file must start from scratch---"
    "---Insert xvgr graph header in file.---"

    "---Start with type of graph.  (lin-lin, log-lin, lin-log, or log-log)---"
    IF (AXISTYPE = 0) [ "---Graph is of type lin-lin---"
      WRITE(UNITNUM,:90:) 'xy';
    ] ELSEIF (AXISTYPE = 1) [ "---Graph is of type log-lin---"
      WRITE(UNITNUM,:90:) 'logy';
      WRITE(UNITNUM,:1080:);
    ] ELSEIF (AXISTYPE = 2) [ "---Graph is of type lin-log---"
      WRITE(UNITNUM,:90:) 'logx';
      WRITE(UNITNUM,:1080:);
    ] ELSEIF (AXISTYPE = 3) [ "---Graph is of type log-log---"
      WRITE(UNITNUM,:90:) 'logxy';
      WRITE(UNITNUM,:1080:);
      WRITE(UNITNUM,:1090:);
    ] ELSE [ "--anything else specified is in error--"
      WRITE(6,:91:) AXISTYPE;
      :91: FORMAT (//'  ------------Error in Subroutine XVGRPLOT-----------'
                 ,/'   AXISTYPE specified (',I2,') is not a valid option.'
                 ,/'  ----------------------------------------------'//);
      RETURN;
    ]
    :90: FORMAT ('@g0 type ',A,' ');
    :1080: FORMAT ('@    xaxis  ticklabel format exponential');
    :1090: FORMAT ('@    yaxis  ticklabel format exponential');

    "---Titles and things---"
    WRITE(UNITNUM,:100:) GRAPHTITLE(1:TITLELENGTH)
                        ,SUBTITLE(1:SUBLENGTH)
                        ,XTITLE(1:XAXISLENGTH)
                        ,YTITLE(1:YAXISLENGTH);
    :100: FORMAT ('@    title "',A,'"'/
                 ,'@    subtitle "',A,'"'/
                 ,'@    legend on'/
                 ,'@    legend box linestyle 0'/
                 ,'@    legend x1 0.6'/
                 ,'@    legend y1 0.75'/
                 ,'@    view xmin 0.250000'/
                 ,'@    xaxis  label "',A,'"'/
                 ,'@    timestamp on'/
                 ,'@    yaxis  label "',A,'"');
]  "---End CURVENUM = 0---"

IF (AXISTYPE = 1 & LOGY = 1) [  "--LOGY error--"
    WRITE(UNITNUM,:90:) 'xy';
    WRITE(6,:95:);
    :95: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
                ,/'  Log scale requested for Y axis when one or more   '
                ,/'  Y data points are 0 or negative.                  '
               ,//'  Y axis scale changed to linear.                   '
                ,/' ---------------------------------------------------'/);
]

IF (AXISTYPE = 2 & LOGX = 1) [  "--LOGX error--"
    WRITE(UNITNUM,:90:) 'xy';
    WRITE(6,:96:);
    :96: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
                ,/'  Log scale requested for X axis when one or more   '
                ,/'  X data points are 0 or negative.                  '
               ,//'  X axis scale changed to linear.                   '
                ,/' ---------------------------------------------------'/);
]

IF (AXISTYPE = 3 & (LOGX = 1 | LOGY = 1)) [  "--LOGX or LOGY error--"
    IF (LOGX = 1 & LOGY = 1) [
      WRITE(UNITNUM,:90:) 'xy';
      WRITE(6,:97:);
      :97: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
                  ,/'  Log scale requested for X axis and Y axis when    '
                  ,/'  one or more X and Y data points are 0 or negative.'
                 ,//'  X and Y axes scales changed to linear.            '
                  ,/' ---------------------------------------------------'/);
    ]
    ELSEIF (LOGX = 1) [ WRITE(UNITNUM,:90:) 'logy'; WRITE(6,:96:); ]
    ELSE              [ WRITE(UNITNUM,:90:) 'logx'; WRITE(6,:95:); ]
]

IF (CURVENUM < 10 ) [
    WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM;
]
ELSE [
    WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM;
]
WRITE(UNITNUM,:150:)  CURVENUM,SERIESTITLE(1:SERIESLENGTH);
:150: FORMAT ('@    legend string ',I2,' "',A,'"');


"---Data set is of type XY---"
WRITE(UNITNUM,:200:);
:200: FORMAT ('@TYPE xy');
IF (CURVENUM < 10) [
       WRITE(UNITNUM,:151:) CURVENUM;
       IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
       ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
]
ELSE [
       WRITE(UNITNUM,:152:) CURVENUM;
       WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
]
    :151: FORMAT ('@    s',I1,' errorbar length 0.000000');
    :152: FORMAT ('@    s',I2,' errorbar length 0.000000');
    :197: FORMAT ('@    s',I1,' symbol color ',I2);
    :198: FORMAT ('@    s',I1,' symbol color ',I1);
    :199: FORMAT ('@    s',I2,' symbol color ',I2);

"---Then write the data to the file.---"
DO COUNT = 1, NPTS1 [ WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT); ]
    :250: FORMAT (1PE15.4,1PE15.4);

"---Insert end of series indicator to file.---"
WRITE(UNITNUM,'(''&'')');

RETURN;
END;
;
"---End of subroutine.---"
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc ranmar random number generator                                      "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2000                                       "
"                   Dave Rogers, 2000                                         "
"                                                                             "
"  Contributors:                                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The following is the initialization routine for the RANMAR random number   "
"  generator (RNG) proposed by Marsaglia and Zaman and designed to be used    "
"  with the EGSnrc system.                                                    "
"                                                                             "
"  Note that this implementation uses integers to store the state of the RNG  "
"  and to generate the next number in the sequence. Only at the end are the   "
"  random numbers are converted to reals by a multiplication with 2**(-24)    "
"  (there are only 24 significant bits). I found the integer implementation   "
"  to be about 30% faster then using reals on Pentium III machines, and       "
"  nearly 70% faster on older SGI workstations.                               "
"                                                                             "
"  The use of RANMAR requires the file ranmar.macros (which defines the       "
"  actual random number generation as a macro).                               "
"                                                                             "
"#############################################################################"


subroutine init_ranmar;

implicit none;

;COMIN/RANDOM/;

integer*4 s,t;
integer*4 i,j,k,l,m,ii,jj;

IF( ixx <= 0 | ixx > 31328 ) ixx = 1802; "Sets Marsaglia default"
IF( jxx <= 0 | jxx > 30081 ) jxx = 9373; "sets Marsaglia default"

i = mod(ixx/177,177) + 2;
j = mod(ixx,    177) + 2;
k = mod(jxx/169,178) + 1;
l = mod(jxx,    169)    ;

DO ii = 1,97 [

    s = 0; t = 8388608;  "t is 2**23 i.e. half of the maximum allowed"
                         "(note that only 24 bits are used)          "

    DO jj = 1,24 [

                         "The if( fool_optimizer ...) statements below are"
                         "to prevent re-arangement of statements for high "
                         "level optimizations and thus different sequences"
                         "on different architectures                      "

        m = mod(mod(i*j,179)*k,179);
        IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
        i = j;
        IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
        j = k;
        IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
        k = m;
        IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
        l = mod(53*l+1,169);
        IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
        IF(mod(l*m,64) >= 32) s = s + t;
        IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
        t = t/2;
        IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
    ]
    urndm(ii) = s;
]

crndm  =   362436;
cdrndm =  7654321;
cmrndm = 16777213;

twom24 = 1./16777216.;

ixx = 97;
jxx = 33;

rng_seed = $NRANMAR + 1;

return;
end; "End of init_ranmar for EGSnrc"

subroutine ranmar_get;
implicit none;
;COMIN/RANDOM/;
$INTEGER i,iopt;
IF( rng_seed = 999999 ) call init_ranmar;
DO i=1,$NRANMAR [
    iopt = urndm(ixx) - urndm(jxx);
    IF(iopt < 0) iopt = iopt + 16777216;
    urndm(ixx) = iopt;
    ixx = ixx - 1; jxx = jxx - 1;
    IF(ixx = 0)        [ ixx = 97; ]
    ELSE IF( jxx = 0 ) [ jxx = 97; ]
    crndm = crndm - cdrndm;
    IF(crndm < 0) crndm = crndm + cmrndm;
    iopt = iopt - crndm;
    IF(iopt < 0) iopt = iopt + 16777216;
    rng_array(i) = iopt;
]
rng_seed = 1; return; end;

;"       end of ranmar.mortran    "

%C80
"#############################################################################"
"                                                                             "
"  EGSnrc auxiliary routines for NRC user codes                               "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2000                                       "
"                   Dave Rogers, 2000                                         "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"
"                                                                             "
"  These are auxiliary routines used in many NRC user codes.                  "
"                                                                             "
"  If you include them via your configuration file, your user code will need  "
"  to define $MXDATA and $STAT. For example, if you are not using the         "
"  statistical analysis package:                                              "
"                                                                             "
"  REPLACE {$MXDATA} WITH {1}; REPLACE{$STAT} WITH {1};                       "
"                                                                             "
"#############################################################################"


%C80
"*****************************************************************************"
"                                                                             "
"                        WATCH                                                "
"                                                                             "
SUBROUTINE WATCH(IARG,IWATCH);

"============================================================================="
"                                                                             "
"     A general purpose auxiliary routine for use with the EGSnrc system
"
"     It prints out information about the particle transport                  "
"                                                                             "
"       For IWATCH = 1 it prints information about each discrete interaction  "
"       For IWATCH = 2 or 3 it prints information about each step as well     "
"       For IWATCH = 4 it prints graphing data for use with EGS_Windows       "
"                                                                             "
"                                                                             "
"    Routine is used via two mandatory and 1 optional call from the user's    "
"          code                                                               "
"                                                                             "
"   1)The routine must be initialized by a call with IARG=-99 before the first"
"          call to SHOWER. It should be after all inputs are in place.        "
"   2)The routine must be called near the beginning of the AUSGAB subroutine  "
"          IF (IWATCH > 0 ) CALL WATCH(IARG,IWATCH);                          "
"   3)The routine may be called at the end of each history with IARG = - 1 so "
"          a message will get printed stated history is complete              "
"                                                                             "
"    Since WATCH cannot output values related to the initial values in a      "
"    shower call, it is useful to also put something like the following       "
"    immediately prior to the CALL SHOWER stmt                                "
"           IF((IWATCH ~= 0) & (IWATCH ~= 4))[                                "
"              OUTPUT 1,EIN,IQI,IRI,XI,YI,ZI,UI,VI,WI,LATCHI,WTI;              "
"               (/' INITIAL SHOWER VALUES',T36,':',                           "
"               I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);                         "
"           ]                                                                 "
"    Note EIN is the kinetic energy of the incident particle                  "
"                                                                             "
"                                                                             "
"   The routine uses up to 132 columns for output.                            "
"                                                                             "
"     JAN 1984  GENERALIZED VERSION WITH INITIALIZATION                       "
"                              DAVE ROGERS NRCC                               "
"     JUN 1987  PUT IN IWATCH = 4 OPTION     AFB                              "
"     JUL 1988  COMPATIBLE WITH X-RAY FLUORESCENCE  DWOR                      "
"     SEP 1990  ADDED ENERGY OUTPUT TO IWATCH = 4 OPTION     AFB              "
"     OCT 1990  UNIX compatible carriage control   DWOR                       "
"     JAN 2000  Rewritten to output relaxation particles and also             "
"               so some of the output makes more sense BW                     "
"                                                                             "
"*****************************************************************************"

"define a local macro"
REPLACE {$CNTOUT(#);(#);} WITH {
   ICOUNT=ICOUNT+1;
   OUTPUT {P1},KE,IQ({P1}),IR({P1}),X({P1}),Y({P1}),Z({P1}),U({P1}),V({P1}),
   W({P1}),LATCH({P1}),WT({P1});  ({P2},I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
}

$IMPLICIT-NONE;
$INTEGER iarg,iwatch,IP,ICOUNT,JHSTRY,J,N;
$REAL KE;
$INTEGER graph_unit;
integer  egs_open_file;
$INTEGER ku,kr,ka;

;COMIN/BOUNDS, STACK,EPCONT,EGS-VARIANCE-REDUCTION,USEFUL,EGS-IO/;

DATA ICOUNT/0/,JHSTRY/1/ graph_unit/-1/;
save     ICOUNT,JHSTRY,graph_unit;

ku = 13; kr = 0; ka = 1;
IF(IARG = -99) [ "Initialize flags so we will get calls thru AUSGAB"
  DO J=1,29[IAUSFL(J)=1;];
  /IAUSFL(22),IAUSFL(23),IAUSFL(24)/=0;
]

IF(IARG = -1) ["main is assumed to call AUSGAB with IARG=-1 at end of history"
  IF(IWATCH = 4) [
    IF( graph_unit < 0 ) [
        graph_unit = egs_open_file(ku,kr,ka,'.egsgph');
    ]
    WRITE(graph_unit,:GRAPHICS_FORMAT:) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY;
    JHSTRY=JHSTRY+1;
  ]
  ELSE[
    OUTPUT JHSTRY;(' END OF HISTORY',I8,3X,40('*')/);
    JHSTRY=JHSTRY+1;ICOUNT=ICOUNT+2;RETURN;
  ]
]

IF( (IWATCH ~= 4) & ((ICOUNT >= 50) | (ICOUNT = 0) | (IARG = -99)) )[
   "PRINT HEADER"
   ICOUNT=1;
   OUTPUT;(//T39,' NP',3X,'ENERGY  Q REGION    X',7X,
   'Y',7X,'Z',6X,'U',6X,'V',6X,'W',6X,'LATCH',2X,'WEIGHT'/);
]

IF((IWATCH = 4) & (IARG >= 0) & (IARG ~= 5)) [ "GRAPHICS OUTPUT"
   IF( graph_unit < 0 ) graph_unit = egs_open_file(ku,kr,ka,'.egsgph');
   WRITE(graph_unit,:GRAPHICS_FORMAT:) NP,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),E(NP);
   :GRAPHICS_FORMAT:FORMAT(2I4,1X,I6,4G15.8,I12);
]

IF(IARG = 5  |  IARG < 0) RETURN;
IF(IWATCH = 4) RETURN; "NONE OF THE REST NEEDED FOR GRAPHICS OUTPUT"

KE=E(NP);IF(IQ(NP).NE.0)[KE=E(NP)-PRM;]

IF(IARG = 0 & IWATCH = 2)[
  $CNTOUT(NP);(T11,'STEP ABOUT TO OCCUR', T36,':');
]
ELSEIF(IARG = 0)[RETURN;]
IF(    IARG = 1)[
   $CNTOUT(NP);(' Discard  AE,AP<E<ECUT',T36,':');]
ELSEIF(IARG = 2)[
   $CNTOUT(NP);(' Discard  E<AE,AP',T36,':');]
ELSEIF(IARG = 3)[
   $CNTOUT(NP);(' Discard -user request',T36,':');]
ELSEIF(IARG = 4)[OUTPUT EDEP,IR(NP);
  (T10,'Local energy deposition',T36,':',F12.5,' MeV in region ',I6);]

ELSEIF(IARG = 6)[
   $CNTOUT(NP);(' bremsstrahlung  about to occur',T36,':');]
ELSEIF(IARG = 7)[
    IF(nbr_split =1) ["no splitting or SBS is on in BEAMnrc"
       DO IP=NPold,NP[
         IF(IQ(IP)=-1)[
           KE = E(IP) - RM;
           $CNTOUT(IP);(T10,'Resulting electron',T36,':');
         ]
         ELSE[
           KE = E(IP);
           $CNTOUT(IP);(T10,'Resulting photon',T36,':');
         ]
       ]
    ]
    ELSE ["splitting case--e- is always at NPold"
      KE = E(NPold) - RM;
      $CNTOUT(NPold);(T10,'Resulting electron',T36,':');
      DO IP=NPold+1,NP[
        KE= E(IP);
        IF(IP = NPold+1)["print info for first one only"
           $CNTOUT(IP);(T10,'Split photons',T36,':');
        ]
        ELSE[ $CNTOUT(IP);(T36,':'); ]
      ]
    ]" end of splitting block"
]

ELSEIF(IARG = 8)[$CNTOUT(NP);(' Moller   about to occur',T36,':');]
ELSEIF(IARG = 9)[
  "surely this logic not needed?"
  IF(NP=NPold)[
     $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
  ]
  ELSE[
     DO IP=NPold,NP[
        KE = E(IP) - ABS(IQ(NP))*RM;
        IF(IP=NPold)[$CNTOUT(IP);(T11,'Resulting electrons',T36,':');]
        ELSE[$CNTOUT(IP);(T36,':');]
     ]
  ]
]

ELSEIF(IARG = 10)[
   $CNTOUT(NP);(' Bhabba   about to occur',T36,':');
]
ELSEIF(IARG = 11)[
  IF(NP=NPold)[
     $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
  ]
  ELSE[
     DO IP=NPold,NP[
        KE = E(IP) - ABS(IQ(IP))*RM;
        IF(IP=NPold)[ $CNTOUT(IP);(T11,'Resulting e- or e+',T36,':'); ]
        ELSE[$CNTOUT(IP);(T36,':');]
     ]
  ]
]

ELSEIF(IARG = 12)[
   $CNTOUT(NP);(' Positron about to decay in flight',T36,':');
]
ELSEIF(IARG = 13)[
  IF(NP=NPold)[
     $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
  ]
  ELSE[
     DO IP=NPold,NP[
        KE = E(IP) - ABS(IQ(IP))*RM;
        IF(IP=NPold)[$CNTOUT(IP);(T11,'Resulting photons',T36,':');]
        ELSE[$CNTOUT(IP);(T36,':');]
     ]
  ]
]

ELSEIF(IARG = 28)[
   $CNTOUT(NP);(' Positron will annihilate at rest',T36,':');
]
ELSEIF(IARG = 14)[
  IF(NP=NPold)[
       $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
  ]
  ELSE[
     DO IP=NPold,NP[
        KE = E(IP) - ABS(IQ(IP))*RM;
        IF(IP=NPold)[$CNTOUT(IP);(' Positron annihilates at rest',T36,':');]
        ELSE[$CNTOUT(IP);(T36,':');]
     ]
  ]
]

ELSEIF(IARG = 15)[
    $CNTOUT(NP);(' Pair production about to occur',T36,':');
]
ELSEIF(IARG = 16)["after pair production"
  IF(NP=NPold & i_survived_rr = 0)[
       $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
  ]
  ELSEIF(NP=NPold & i_survived_rr > 0)["we have cleared the stack"
      OUTPUT i_survived_rr,prob_rr;
       (T10,'Russian Roulette eliminated ',I2,
                    ' particle(s) with probability ',F8.5)
      $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
  ]
  ELSE[
     DO IP=NPold,NP[
        KE = E(IP) - ABS(IQ(IP))*RM;
        IF(IP=NPold)[$CNTOUT(IP);(T11,'Resulting pair',T36,':');]
        ELSE[$CNTOUT(IP);(T36,':');]
     ]
     IF(i_survived_rr > 0)[
        OUTPUT i_survived_rr,prob_rr;
       (T10,'Russian Roulette eliminated ',I2,'
             particle(s) with probability ',F8.5);
       $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
     ]
  ]
]

ELSEIF(IARG = 17)[$CNTOUT(NP);(' Compton  about to occur',T36,':');]
ELSEIF(IARG = 18)["after call to COMPT"
  IF(NP = NPold & i_survived_rr = 0)[
      $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
  ]
  ELSEIF(NP > NPold)["have not cleared the stack with rus rou"
     DO IP=NPold,NPold+1[
        KE = E(IP) - ABS(IQ(IP))*RM;
        IF(IQ(IP).NE.0)[$CNTOUT(IP);(T11,'compton electron created',T36,':');]
        ELSE[$CNTOUT(IP);(T11,'compton scattered photon',T36,':');]
     ]
  ]
  IF(i_survived_rr > 0)["whether the stack has been cleared or not"
       OUTPUT i_survived_rr,prob_rr;
       (T10,'Russian Roulette eliminated ',I2,
                    ' particle(s) with probability ',F8.5)
      $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
  ]
]

ELSEIF(IARG = 19)[
    $CNTOUT(NP);(' Photoelectric about to occur',T36,':');
]
ELSEIF(IARG = 20)[
    IF(NPold=NP & IQ(NP)=0 & i_survived_rr = 0)[
      $CNTOUT(NP);(T11,'Photon energy below N-shell',/,
                   T11,'Photon discarded',T36,':');
    ]
    ELSEIF(IQ(NPold) = -1 & i_survived_rr = 0)[
      KE= E(NPold)-RM;
      $CNTOUT(NPold);(T10,'Resulting photoelectron',T36,':');
    ]
    ELSEIF(i_survived_rr > 0)["done some russian roulette"
       IF(NP=NPold-1 | IQ(NPold) ~= -1)[
          IF(i_survived_rr > 1)["eliminated more than the photoelectron"
              OUTPUT i_survived_rr-1,prob_rr;
              (T10,'Russian Roulette eliminated ',I4,
                    ' particle(s) with probability ',F8.5,' plus');
          ]
          OUTPUT prob_rr;
                 (T10,'Russian Roulette eliminated resulting photoelectron',
                      ' with probability ',F8.5);
       ]
       ELSE["NPold could hold the photoelectron"
           KE = E(NPold) - RM;
           $CNTOUT(NPold);(T10,'Resulting photoelectron?',T36,':');
           OUTPUT i_survived_rr,prob_rr;
           (T10,'Russian Roulette eliminated ',I4,
                    ' particle(s) with probability ',F8.5);
       ]
       $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
    ]
]

ELSEIF(IARG = 24)[$CNTOUT(NP);(' Rayleigh scattering occured',T36,':');]

ELSEIF(IARG = 25)[$CNTOUT(NP);(T10,'Fluorescent X-ray created',T36,':');]

ELSEIF(IARG = 26)[$CNTOUT(NP);(T10,'Coster-Kronig e- created',T36,':');]

ELSEIF(IARG = 27)[$CNTOUT(NP);(T10,'Auger electron created',T36,':');]

IF(IARG = 0  &  IWATCH = 2)[OUTPUT  USTEP,TUSTEP,VSTEP,TVSTEP,EDEP;
(T5,'USTEP,TUSTEP,VSTEP,TVSTEP,EDEP',T36,':    ',5(1PE13.4));ICOUNT=ICOUNT+1;]

IF(NP = 1  |  IARG = 0) RETURN;
IF( IARG <= 3)[
       N=NP-1;
       KE = E(N) - ABS(IQ(N))*RM;
       $CNTOUT(N);(T10,'Now on top of stack',T36,':');
]
RETURN;END;
%I4
%C80
%Q1
%E
"*******************************************************************************
"
"
"                       *****************
"                       *               *
"                       * SIGMA.MORTRAN *
"                       *               *
"                       *****************
"
"
"       SIGMA IS A STATISTICAL ANALYSIS ROUTINE DESIGNED TO BE USED BY EGS
"       USER PROGRAMS TO GIVE THE TOTALS OR AVERAGES AND THEIR UNCERTAINTIES
"       OF THE DATA CALCULATED BY THE MONTE CARLO CODE.
"       THE UNCERTAINTIES ARE RETURNED AS PERCENTS.
"
"       VARIABLES
"       =========
"
"       DATA(NDATA,ISTAT)       THE TWO DIMENSIONAL ARRAY OF DATA TO BE
"                               ANALYZED. ISTAT IS THE NUMBER OF STATISTICAL
"                               BATCHES AND NDATA IS THE NUMBER OF ERRORS TO
"                               BE CALCULATED. AFTER THE END OF THE CALCULATION,
"                               DATA(N,1) CONTAINS THE TOTAL OR AVERAGE AND
"                               DATA(N,2) CONTAINS THE ERROR. NDATA SHOULD
"                               BE < OR = $MAXDATA AND ISTAT SHOULD BE < OR =
"                               $STAT WHCH MUST BE DEFINED IN THE MAIN ROUTINE.
"                               Note $STAT must be 2 or greater, even if istat=1
"
"       MODE    =  0 =>         ANALYSIS ON MEAN VALUES WHERE ZERO DATA IS
"                               IGNORED. (eg. STOPPING POWER RATIO)
"               =  1 =>         ANALYSIS ON MEAN VALUES WHERE ZERO DATA IS NOT
"                               IGNORED. (e.g. DOSE)
"               =  2 =>         ANALYSIS ON TOTAL VALUES (eg. TOTAL EDEP)
"
"       IERR    =  0 =>         NORMAL COMPLETION.
"               =  1 =>         WARNING: MODE OUT OF RANGE, DEFAULTED TO 0
"               = 10 =>         ERROR: ONLY ONE BATCH INPUT, QUICK CALCULATION
"                                      DONE. ERROR=99.9%
"               = 11 =>         ERROR: NO NON-ZERO DATA FOUND IN A GIVEN SET,
"                                       ERROR=99.9%
"               = -1 =>         FATAL ERROR: NDATA OR ISTAT OUT OF RANGE, NO
"                                            CALCULATION DONE.
"
"
"               VERSION  1      A.F.B.  83/7/22
"               Version  2      IK      Jan 6 6000 implemented implicit none
"
"*******************************************************************************
%E
SUBROUTINE SIGMA(NDATA,ISTAT,MODE,IERR);

$IMPLICIT-NONE;

$INTEGER NDATA,ISTAT,MODE,IERR;

REPLACE {;COMIN/ERROR/;} WITH {
 ;COMMON/ERROR/DATA($MXDATA,$STAT);
 $REAL data;
}
;COMIN/ERROR,EGS-IO/;

$INTEGER n,non0,i;
$REAL    stat,sdenom;
real*8   emax,avg,error,datum,argmnt;
                                 "It is a good idea to use double precision"
                                 "in cases with very low stat. uncertainties"

DATA EMAX/99.9/;

IERR=0; "ASSUME NORMAL COMPLETION"

"TEST INPUTS AND SET ERROR CODES AND RETURN IF NEEDED."

IF((MODE < 0) | (MODE > 2)) [MODE=2;IERR=1;]

IF((NDATA.LE.0).OR.(NDATA.GT.$MXDATA).OR.(ISTAT.LE.0).OR.(ISTAT.GT.$STAT)) [
  IERR=-1;RETURN;"FATAL INPUT ERROR, RETURN IMMEDIATELY"
]
IF(ISTAT = 1)[
    IERR=10;"ONLY ONE STATISTICAL BATCH, QUICK CALCULATION"
    DO N=1,NDATA[DATA(N,2)=EMAX;]
    RETURN;
]

"MOST ANOMALIES HAVE BEEN HANDLED. NOW DO THE ANALYSIS"

IF(MODE.NE.0)[STAT=FLOAT(ISTAT);SDENOM=STAT*(STAT-1.);]
DO N=1,NDATA[
   NON0=0;             "NON-ZERO COUNTER"
   AVG=0.0;ERROR=0.0;
   DO I=1,ISTAT[
      DATUM=DATA(N,I);
      IF(DATUM.NE.0.0)[NON0=NON0+1;AVG=AVG+DATUM;ERROR=ERROR+DATUM**2;]
   ]
   IF(NON0 = 0)[IERR=11;ERROR=EMAX;GOTO :TRANSFER:;"NO NON-ZERO DATA "]

   ELSEIF((NON0 = 1) & (MODE = 0))[ERROR=EMAX;GOTO:TRANSFER:;"ONLY ONE DATUM"]

   ELSE[
      IF(MODE = 0)[STAT=FLOAT(NON0);SDENOM=STAT*(STAT-1.);]
   ]

   AVG=AVG/STAT;ARGMNT=ERROR-STAT*AVG**2;
   "FLAG -VE SQUARE ROOTS THAT CAN ONLY OCCUR DUE TO ROUND-OFF ERRORS"
   IF(ARGMNT.LT.0.0)[
      OUTPUT ARGMNT,ERROR,STAT,AVG,SDENOM;
      (' ***** - SQ RT IN SIGMA. ARGMNT,ERROR,STAT,AVG,SDENOM='/' ',5E12.4);
      ARGMNT=0.0;
   ]
   ERROR=SQRT(ARGMNT/SDENOM);

   IF(AVG = 0.)[ERROR=EMAX;]ELSE[ERROR=100.*ERROR/ABS(AVG);]

   IF(MODE =  2)AVG=AVG*STAT;

   :TRANSFER:;
   DATA(N,1)=AVG;DATA(N,2)=MIN(EMAX,ERROR);
] "END OF NDATA LOOP"
RETURN;
END; "END OF SIGMA"
;

"*****************************************************************************
" The following are routines that implement
" the alias sampling technique for sampling from a histogram
" distribution coded for use with EGSnrc
"
" subroutine prepare_alias_sampling
" function   alias_sample
"
" I. Kawrakow, January 2000
"
"*****************************************************************************

subroutine prepare_alias_sampling(nsbin,fs_array,ws_array,ibin_array);
"====================================================================
"
" inputs:  nsbin:    number of bins in the histogram
"          fs_array: bin probabilities
"
" Note that we don't need the bin limits at this point, they
" are needed for the actual sampling (in alias_sample)
"
" outputs: ws_array, ibin_array: alias table ready for sampling
"
"====================================================================

implicit none;

$INTEGER  nsbin,ibin_array(nsbin);
$REAL     fs_array(nsbin),ws_array(nsbin);

$INTEGER  i,j_l,j_h;
$REAL     sum,aux;

sum = 0;
DO i=1,nsbin [
  IF( fs_array(i) < 1e-30 ) fs_array(i) = 1e-30;
  ws_array(i) = -fs_array(i); ibin_array(i) = 1;
  sum = sum + fs_array(i);
]
sum = sum/nsbin;

DO i=1,nsbin-1 [

    DO j_h = 1,nsbin [
        IF( ws_array(j_h) < 0 ) [
            IF( abs(ws_array(j_h)) > sum ) GOTO :AT_EXIT1:;
        ]
    ]
    j_h = nsbin;
    :AT_EXIT1:

    DO j_l = 1,nsbin [
        IF( ws_array(j_l) < 0 ) [
            IF( abs(ws_array(j_l)) < sum ) GOTO :AT_EXIT2:;
        ]
    ]
    j_l = nsbin;
    :AT_EXIT2:

    aux = sum - abs(ws_array(j_l));
    ws_array(j_h) = ws_array(j_h) + aux;
    ws_array(j_l) = -ws_array(j_l)/sum;
    ibin_array(j_l) = j_h;
    IF( i = nsbin-1 ) ws_array(j_h) = 1;

]

return;
end;


$REAL function alias_sample(nsbin,xs_array,ws_array,ibin_array);
"===============================================================
"
" samples from an alias table which must have been prepared
" using prepare_alias_table
"
"===============================================================

implicit none;

$INTEGER nsbin,ibin_array(nsbin);
$REAL    xs_array(0:nsbin),ws_array(nsbin);

;COMIN/RANDOM/;

$REAL    v1,v2,aj;
$INTEGER j;

$RANDOMSET v1; $RANDOMSET v2;
aj = 1 + v1*nsbin; j = aj;
IF( j > nsbin ) j = nsbin; " this happens only if $RANDOMSET produces
                           " numbers in (0,1]
aj = aj - j;
IF( aj > ws_array(j) ) [ j = ibin_array(j); ]
alias_sample = (1-v2)*xs_array(j-1) + v2*xs_array(j);
return;
end;
;
%E
;
"==========================end of nrcaux.mortran======================"



%F
C***************************************************************************
C
C   This file was automatically generated by:
C   EGSnrc-configure-linux version 1.0
C   It contains various subroutines and functions for date, time,
C   CPU time, host name, etc.
C
C   Attention: all changes will be lost the next time you run
C   EGSnrc-configure-linux.
C
C***************************************************************************

C##############################################################################
C
C  EGSnrc egs_system subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C egs_system(command)  runs a system command and returns the status
C                      command must be null-terminated
C*****************************************************************************
      integer function egs_system(command)
      character*(*) command
      integer system, istat
      istat = system(command)
      egs_system = istat
      return
      end

C##############################################################################
C
C  EGSnrc egs_isdir subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C  egs_isdir(file_name)  Returns .true., if the string file_name points to
C                        an existing directory. This version uses the lstat
C                        intrinsic and then tests for bit 14 being set in
C                        the mode element. This works on all Unix systems
C                        that I have access to (Linux, Aix, HP-UX, OSF1,
C                        Solaris, IRIX)
C
C*****************************************************************************

      logical function egs_isdir(file_name)
      implicit none
      character*(*) file_name
      integer*4 lnblnk1, res, array(13), l, lstat
      logical btest
      egs_isdir = .false.
      l = lnblnk1(file_name)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = char(0)
         ! On some systems lstat only works if the string is 0-terminated
      res = lstat(file_name,array)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = ' '
      if( res.eq.0 ) then
            ! Amost all compilers that have the lstat intrinsic return the
            ! file mode in the 3rd array element. But the PGI compiler has
            ! its own opinion on the subject and returns it in the 5th element
            ! That's why the relevant element is written as 3
            ! here, 3 gets replaced by the appropriate element
            ! by the configure script.
          if( btest(array(3),14) ) egs_isdir = .true.
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C***************************************************************************
C
C   egs_fdate(out):  print a 24 char date and time string in the form
C                         'Tue Mar 18 08:16:42 2003'
C                    to the unit specified by out without end of line
C                    i.e. the sequence
C                    write(6,'(a,$)') 'Today is '
C                    call egs_fdate(6)
C                    write(6,'(a)') '. Have a nice date'
C                    should result in something like
C                    Today is Tue Mar 18 08:16:42 2003. Have a nice date
C                    printed to unit 6.
C
C***************************************************************************

      subroutine egs_fdate(ounit)
      integer ounit
      character*24 string
      call fdate(string)
      write(ounit,'(a,$)') string
      end

C***************************************************************************
C
C   egs_get_fdate(string) assignes a 24 char date and time string to string
C                         string must be at least 24 chars long, otherwise
C                         this subroutine has no effect.
C
C***************************************************************************

      subroutine egs_get_fdate(string)
      character*(*) string
      if( len(string).ge.24 ) call fdate(string)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date_and_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


      subroutine egs_date_and_time(vnow)
      integer vnow(8)
      character dat*8,tim*10,zon*5
      call date_and_time(dat,tim,zon,vnow)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*************************************************************************
C
C egs_date(ounit): print a 11 char string in the form
C                     '18-Mar-2003'
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_date(ounit)
      integer ounit
      character string*24, dat*11
      call fdate(string)
      dat(1:2) = string(9:10)
      dat(3:3) = '-'
      dat(4:6) = string(5:7)
      dat(7:7) = '-'
      dat(8:11) = string(21:24)
      write(ounit,'(a,$)') dat
      return
      end

C##############################################################################
C
C  EGSnrc egs_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C $Id: egs_time_v1.f,v 1.1 2003/07/11 19:17:08 iwan Exp $
C*************************************************************************
C
C egs_time(ounit): print a 8 char string in the form hh:mm:ss
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_time(ounit)
      integer ounit
      character string*24
      call fdate(string)
      write(ounit,'(a,$)') string(12:19)
      return
      end

C##############################################################################
C
C  EGSnrc seconds timing subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_secnds(t0): returns seconds passed since midnight minus t0
C
C*****************************************************************************

      real function egs_secnds(t0)
      real t0,t1
      character dat*8,tim*10,zon*5
      integer values(8)
      call date_and_time(dat,tim,zon,values)
      t1 = 3600.*values(5) + 60.*values(6) + values(7) + 0.001*values(8)
      egs_secnds = t1 - t0
      return
      end

C*****************************************************************************
C
C real function egs_tot_time()
C
C   On first call returns seconds passed since 1/1/1970
C   On subsequent calls returns
C     - seconds since last call, if flag = 0
C     - seconds since first call, else
C
C*****************************************************************************

      real function egs_tot_time(flag)
      integer flag
      character dat*8,tim*10,zon*5
      integer vnow(8), vlast(8),i
      real t,egs_time_diff,t0
      data vlast/1970,1,1,5*0/,t0/-1/
      save vlast,t0
      call date_and_time(dat,tim,zon,vnow)
      t = egs_time_diff(vlast,vnow)
      do i=1,8
        vlast(i)=vnow(i)
      end do
      if( t0.lt.0 ) then
        t0 = 0
        egs_tot_time = t
      else
        t0 = t0 + t
        if(flag.eq.0) then
          egs_tot_time = t
        else
          egs_tot_time = t0
        end if
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date and time subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C****************************************************************************
C
C Returns the time difference between vstart and vend
C vstart and vend are integer arrays of dimension 8 with elements
C corresponding to the specification of the data_and_time routine, i.e.
C   array(1) = year
C   array(2) = month of the year   (1...12)
C   array(3) = day of the month    (1...31)
C   array(4) = difference in minutes from UTC
C   array(5) = hour of the day     (1...23)
C   array(6) = minute of the hour  (1...59)
C   array(7) = seconds of the minute (1...59)
C   array(8) = miliseconds of the second (1...999)
C
C Note: this implementation ignores the time difference from UTC field
C
C*****************************************************************************
      real function egs_time_diff(vstart,vend)
      integer    vstart(8),vend(8)
      real       egs_time_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_time_diff = -egs_time_diff_o(vend,vstart)
      else
        egs_time_diff = egs_time_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C day difference between the dates specified by the integer arrays vstart and
C vend. The arrays are v(1)=year, v(2)=month, v(3)=day
C
C******************************************************************************
      integer function egs_day_diff(vstart,vend)
      integer vstart(3),vend(3),egs_day_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_day_diff = -egs_day_diff_o(vend,vstart)
      else
        egs_day_diff = egs_day_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C Returns a 3-letter abreviation of the day of the week in the string day,
C given a day specified by the integer array values
C   values(1)=year, values(2)=month, values(3)=day
C
C******************************************************************************
      subroutine egs_weekday(values,day)
      character*(*) day
      integer       values(3)
      integer       days,vtmp(3),egs_day_diff,aux
      character*3   wdays(7)
      data wdays/'Mon','Tue','Wed','Thu','Fri','Sat','Sun'/
      vtmp(1) = 1970
      vtmp(2) = 1
      vtmp(3) = 1
      days = egs_day_diff(vtmp,values)
      aux = mod(days,7)
      days = 4 + aux
      if( days.gt.7 ) days = days - 7
      day(:len(day)) = ' '
      aux = min(len(day),3)
      day(:aux) = wdays(days)(:aux)
      return
      end

C*****************************************************************************
C
C Same as egs_day_diff above, but assumes that vend specifies a later date
C than vstart.
C
C*****************************************************************************
      integer function egs_day_diff_o(vstart,vend)
      integer vstart(3),vend(3)
      integer    days
      logical    next_month
      integer    tm,m,ty,y
      integer    mdays(12)
      data       mdays/31,28,31,30,31,30,31,31,30,31,30,31/
      days = 0
      ty = vstart(1)
      y  = vend(1)
      tm = vstart(2)
      m  = vend(2)
      next_month = .true.
      do while(next_month)
        if( tm.eq.m.and.ty.eq.y ) then
          next_month = .false.
        else
          days = days + mdays(tm)
          if( tm.eq.2.and.mod(ty,4).eq.0 ) days = days + 1
          tm = tm + 1
          if( tm.gt.12 ) then
            ty = ty + 1
            tm = 1
          end if
        end if
      end do
      days = days + vend(3) - vstart(3)
      egs_day_diff_o = days
      return
      end

C******************************************************************************
C
C Same as egs_time_diff above, but assumes that vend specifies a later date
C than vstart.
C
C******************************************************************************
      real function egs_time_diff_o(vstart,vend)
      integer    vstart(8),vend(8)
      integer    days,hours,minutes,secs,msecs
      integer    egs_day_diff_o
      days = egs_day_diff_o(vstart,vend)
      hours = vend(5) - vstart(5)
      minutes = vend(6) - vstart(6)
      secs = vend(7) - vstart(7)
      msecs = vend(8) - vstart(8)
      egs_time_diff_o = 3600.*(24.*days+hours)+60.*minutes+secs+
     &                  0.001*msecs
      return
      end

C******************************************************************************
C
C Returns in month a 3-letter abreviation of the month specified by mo, if
C mo is between 1 and 12, or an empty string otherwise.
C
C******************************************************************************
      subroutine egs_month(mo,month)
      integer mo
      character*(*) month
      integer iaux
      character*3   months(12)
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      iaux = min(len(month),3)
      month(:len(month)) = ' '
      if( mo.ge.1.and.mo.le.12 ) month(:iaux) = months(mo)(:iaux)
      return
      end

C******************************************************************************
C
C Converts a 3-letter abreviation of a month to its corresponding integer
C value, if the string month is a valid month, or -1 otherwise.
C
C******************************************************************************
      integer function egs_conver_month(month)
      character*3 month
      character*3 months(12)
      integer i
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      do i=1,12
        if( month.eq.months(i) ) then
          egs_conver_month = i
          return
        end if
      end do
      egs_conver_month = -1
      return
      end


C##############################################################################
C
C  EGSnrc egs_etime subroutine
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_etime(): returns CPU time consumed since the start of
C                            the program
C
C*****************************************************************************

      real function egs_etime()
      real tarray(2),etime
      egs_etime = etime(tarray)
      return
      end

C##############################################################################
C
C  EGSnrc canonical system name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the canonical system name as determined by the config.guess script
C or the Windows installation program to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_canonical_system(ounit)
      integer ounit
      write(6,'(a,$)') 'linux64'
      return
      end

C******************************************************************************
C
C Assign the canonical system name as determined by the config.guess script
C or the Windows installation program to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_canonical_system(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('linux64')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'linux64'
      else
        res(:l2) = 'linux64'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc configuration name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the configuration name as specified suring the configuration
C process to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_configuration_name(ounit)
      integer ounit
      write(6,'(a,$)') 'linux'
      return
      end

C******************************************************************************
C
C Assign the configuration name as specified suring the configuration
C process to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_configuration_name(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('linux')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'linux'
      else
        res(:l2) = 'linux'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc hostname subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C Print the host name to the unit specified by ounit without inserting
C a new line character.
C
C*****************************************************************************

      subroutine egs_print_hostnm(ounit)
      integer ounit
      character*256 string
      integer res,hostnm,lnblnk1
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      write(ounit,'(a,$)') string(:lnblnk1(string))
      return
      end

C*****************************************************************************
C
C Assign the host name to the string pointed to be hname.
C
C*****************************************************************************

      subroutine egs_get_hostnm(hname)
      character*(*) hname
      character*256 string
      integer res,hostnm,lnblnk1,l1,l2,l
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      l1 = lnblnk1(string)
      l2 = len(hname)
      hname(:l2) = ' '
      l = min(l1,l2)
      hname(:l) = string(:l)
      return
      end

%M
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc parallel processing functions                                       "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Iwan Kawrakow, 2003                                       "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                   Frederic Tessier                                          "
"                                                                             "
"#############################################################################"
"                                                                             "
" The following set of functions only gets included if we found a working     "
" C compiler that can compile egs_c_utils.c                                   "
"                                                                             "
"#############################################################################"


%I4
%C80
%Q1
!INDENT F2;
#ifdef HAVE_C_COMPILER;

"*****************************************************************************
$INTEGER function egs_create_lockfile(flag);
"*****************************************************************************
" Create a lock file in the user code directory to store parallel processing
" information. To be called from job #1.
"*****************************************************************************
$INTEGER flag;
;COMIN/EGS-IO/;
character*512 fname;
$INTEGER i,lnblnk1,l,istat;

$set_string(fname,' ');
fname = $cstring(egs_home) // $cstring(user_code) // $file_sep //
        $cstring(output_file) // '.lock';
l = lnblnk1(fname)+1;
fname(l:l) = char(0); " String must be null terminated "
call egs_create_control_file(fname,istat);
IF( istat ~= 0 & flag = 1 ) [
    $egs_fatal(*,'Failed to create a lock file named ',$cstring(fname));
]
egs_create_lockfile = istat;
return; end;

"*****************************************************************************
$INTEGER function egs_open_lockfile(flag);
"*****************************************************************************
" Open a lock file in the user code directory to read/write parallel
" processing info. To be called from all jobs except 1.
"*****************************************************************************
$INTEGER flag;
;COMIN/EGS-IO/;
character*512 fname;
$INTEGER i,lnblnk1,l,istat;
$set_string(fname,' ');
fname = $cstring(egs_home) // $cstring(user_code) // $file_sep //
        $cstring(output_file) // '.lock';
l = lnblnk1(fname)+1;
fname(l:l) = char(0); " String must be null terminated "
call egs_open_control_file(fname,istat);
IF( istat ~= 0 & flag = 1 ) [
    $egs_fatal(*,'Failed to open the lock file named ',$cstring(fname));
]
egs_open_lockfile = istat;
return; end;

"*****************************************************************************
subroutine egs_remove_lockfile(istat);
"*****************************************************************************
$INTEGER istat;
;COMIN/EGS-IO/;
character*512 fname;
$INTEGER i,lnblnk1,l;
$set_string(fname,' ');
fname = $cstring(egs_home) // $cstring(user_code) // $file_sep //
        $cstring(output_file) // '.lock';
l = lnblnk1(fname)+1;
fname(l:l) = char(0); " String must be null terminated "
call egs_remove_file(fname,istat);
return; end;

"*****************************************************************************
subroutine egs_pjob_control(ncase,n_run,n_left,n_tot,sum,sum2,res,dres);
"*****************************************************************************
"
" This subroutine controls a parallel run. It only works if the EGS_HOME
" directory is the same for all machines participating in the parallel
" processing (e.g. EGS_HOME is on a NFS for *nix or on a network share on
" Windows).
" n_case: number of histories to be run (all jobs, not just the current
"         job)  (input)
" n_run:  number of histories the user code should run (output). If n_run = 0,
"         then finish simulation, clean up, call egs_finish and
"         egs_pjob_finish (in that order) and exit.
" n_left  no. of histories left to run after current job has been submitted
" n_tot:  should be set to number of histories from previous runs (if any)
"         for first call from job number 1. For all other jobs and for all
"         other calls from job 1, it is set by egs_pjob_control to the the
"         number of histories run so far (including previous runs and other
"         parallel jobs).
"         Note: n_case, n_run and n_tot are $LONG_INT
" sum,    input. for first call and job 1, score and score squared for quantity
" sum2:   of interest, should be zero for first call from jobs other than 1.
"         score for quantity of interest since last call to this subroutine
"         for all other calls.
" res:    combined result for the quantity of interest from previous runs
"         and other parallel jobs, output
" dres:   relative uncertainty of res in %
"
" The shower loop of a user code that wants to use the new parallel processing
" implementation should look something like this:
"
" /sum,sum2/=0; (or result from a previous run, if i_parallel=1)
" /last_sum,last_sum2/=0;
" :start_simulation:
" x=sum-last_sum; x2=sum2-last_sum2; last_sum=sum; last_sum2=sum2;
" call egs_pjob_control(ncase,n_run,n_tot,x,x2,res,dres);
" IF( n_run = 0 ) goto :end_simulation:
" write(6,*) ' running ',n_run,' histories,' n_tot so far: ',n_tot;
" write(6,*) ' result so far: ',res,' +/- ',dres,' %';
" DO icase=1,n_run [
"    get source particle, call shower. sum and sum2 are updated
" ]
" goto :start_simulation:;
" :end_simulation:
" analyze and output results for this job.
" call egs_finish;
"   (after egs_finish all output files are closed and moved to the user code
"    directory from the temporary working directory).
" call egs_pjob_finish(combine_results,'.egsdat');
" output combined results.
" end;
"
" In the above, combine_results is a user supplied subroutine that
" combines parallel runs and takes a file name as an argument.
" egs_pjob_finish  decreases the number of running job, n_job, in the
" job control file by one. If n_job > 0, it simply returns.
" If n_job = 0 (i.e. this job is the last job), it checks for
" data files output_file_wj.egsdat, j=1,99. For each file found, it calls
" combine_results with that file name.
"

implicit none;
$LONG_INT ncase,n_run,n_tot;
$REAL    sum,sum2,res,dres;
;COMIN/EGS-IO,my_times/;

$LONG_INT n_last,n_left,nn_tot;
integer   t_dum(8);
$INTEGER  i,lnblnk1,n_write,n_read,istat,n_job;
$INTEGER  egs_create_lockfile, egs_open_lockfile;
$REAL     tmp,tmp2;
$LOGICAL first_time;
character control_string*256;
data first_time/.true./;
save first_time,n_last;

IF( n_parallel <= 0 ) [
    n_run = ncase; return;
]

IF( first_time ) n_last = 0;

$set_string(control_string,' ');
n_run = ncase/n_parallel/$N_CHUNKS;
n_left = ncase;

REPLACE {$control_format} WITH {
  '(2i15,i4,2(1pe16.8),1pe13.5,0pf7.2,2x,8i5)'};

IF( first_time ) [
   IF( n_run > n_left ) n_run = n_left;
   n_left = ncase - n_run;

   IF( i_parallel = first_parallel ) [ "I'm first job => "
                                       "create the job control file"
       istat = egs_create_lockfile(1); "The 1 tells egs_create_lockfile to "
                                       "print an error message and exit if"
                                       "it fails."
       IF( n_tot > 1 ) [ "=> a continuation from a previous run "
          res = sum/n_tot; dres = sum2/n_tot - res*res;
          IF( res > 0 & dres > 0 ) [ dres = sqrt(dres/(n_tot-1))/res*100; ]
          ELSE [ dres = 99.9 ]
       ] ELSE [ res = 0; dres = 99.9; ]

       /*
       write(control_string,$control_format)
         n_left,n_tot,i_parallel,sum,sum2,res,dres,(t_first(i),i=1,8);
       */
       write(control_string,$control_format)
         n_left,n_tot,1,sum,sum2,res,dres,(t_first(i),i=1,8);
       n_write = lnblnk1(control_string) + 1;
       call egs_write_control_file(control_string,n_write,istat);
       IF( istat ~= n_write ) [
           $egs_fatal(*,'job 1: failed to write to lock file ',n_write,istat);
       ]
       call egs_unlock_control_file(istat);
       IF( istat ~= 0 ) [
           $egs_fatal(*,'job 1: failed to unlock the file ',istat);
       ]
       first_time = .false.;
       n_max_parallel = 1; n_last = n_run;
       return;
   ]
   istat = egs_open_lockfile(1);
]

" Here for all calls except first call from job 1. "

" Lock and rewind the job control file "
call egs_rewind_control_file(istat);
IF( istat ~= 0 ) [
    $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the control ',
      'file', istat);
]

" Read the job control string string "
n_read = len(control_string);
call egs_read_control_file(control_string,n_read,istat);

" Read from the job control string string "
read(control_string,*,err=:error_lockfile_read:) n_left,nn_tot,n_job,tmp,tmp2,
     res,dres,(t_dum(i),i=1,8);

" Update the number of histories finished so far "
nn_tot = nn_tot + n_last;

" Update the score for the quantity of interest "
tmp = tmp + sum; tmp2 = tmp2 + sum2;

" First call => increase number of running jobs "
IF( first_time ) [
    first_time = .false.; n_job = n_job + 1;
    nn_tot = nn_tot + n_tot;
]
n_tot = nn_tot;

" If n_tot > 1, do stat. analysis and put result is res, dres "
IF( n_tot > 1 ) [
    res = tmp/n_tot; dres = tmp2/n_tot - res*res;
    IF( res > 0 & dres > 0 ) [ dres = sqrt(dres/(n_tot-1))/res*100; ]
    ELSE [ dres = 99.9 ]
] ELSE [ res = 0; dres = 99.9; ]

" Take another chunk of histories to run "
IF( n_run > n_left ) [
    n_run = n_left; n_left = 0;
] ELSE [ n_left = n_left - n_run; ]

n_last = n_run;

" Write new job control info into job control string "
$set_string(control_string,' ');
write(control_string,$control_format)
  n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_dum(i),i=1,8);

" Rewind again the job control file "
call egs_rewind_control_file(istat);
IF( istat ~= 0 ) [
    $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the control ',
      'file', istat);

]

" Write the new job control string "
n_write = lnblnk1(control_string) + 1;
call egs_write_control_file(control_string,n_write,istat);
IF( istat ~= n_write ) [
    $egs_fatal(*,'job ',i_parallel,': failed to write to lock file ',
       n_write,istat);
]

" Finally unlock the job control file so that other jobs can access it. "
call egs_unlock_control_file(istat);
IF( istat ~= 0 ) [
    $egs_fatal(*,'job ',i_parallel,': failed to unlock the file ',istat);
]
IF( n_job > n_max_parallel ) n_max_parallel = n_job;
return;

:error_lockfile_read:
$egs_fatal('(a,/a)','Failed to read from job control file: got ',
     $cstring(control_string));
return; end;

"******************************************************************************
subroutine egs_pjob_finish(n_job);
"******************************************************************************
implicit none;
$INTEGER n_job;

;COMIN/EGS-IO,my_times/;

$INTEGER  istat,i,lnblnk1,n_read,n_write;
$LONG_INT n_left,n_tot;
integer   t_start(8),t_end(8);
$REAL     tmp,tmp2,res,dres,t_run;
real      egs_time_diff;
character control_string*256;

" Lock and rewind the job control file "
call egs_rewind_control_file(istat);
IF( istat ~= 0 ) [
    $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the control ',
      'file', istat);
]

" Read the job control string string "
n_read = len(control_string);
call egs_read_control_file(control_string,n_read,istat);

" Read from the job control string string "
read(control_string,*,end=:error2_lockfile_read:,err=:error2_lockfile_read:)
  n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_start(i),i=1,8);

n_job = n_job - 1;
IF( n_job > 0 ) [  " Other jobs still running "
    $set_string(control_string,' ');
    write(control_string,$control_format)
      n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_start(i),i=1,8);
    call egs_rewind_control_file(istat);
    IF( istat ~= 0 ) [
        $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the ',
          'control file, error was:', istat);
    ]
    n_write = lnblnk1(control_string) + 1;
    call egs_write_control_file(control_string,n_write,istat);
    IF( istat ~= n_write ) [
        $egs_fatal(*,'job ',i_parallel,': failed to write to lock file ',
           n_write,istat);
    ]
    call egs_unlock_control_file(istat);
    call egs_close_control_file(istat);
    return;
]

" If here, I'm the last job => remove job control file
/* call egs_unlock_control_file(istat); */
call egs_close_control_file(istat);
call egs_remove_lockfile(istat);
i_parallel = 0; call egs_open_units(.false.);
call egs_date_and_time(t_end);
t_run = egs_time_diff(t_start,t_end);
$egs_info('(/a/,a,t55,i3/,a,t55,i3/,a,f9.1,a,f9.4,a/,a//)',
'**************** finished parallel execution ******************',
' number of parallel jobs requested: ',n_parallel,
' max. number of jobs executing simultaneously: ',n_max_parallel,
' elapsed time since first job started: ',t_run,' s (',t_run/3600,' h)',
'***************************************************************');
return;

:error2_lockfile_read:;
$egs_fatal('(a,/a)',
  'In egs_pjob_finish: failed to read from control string ',
  $cstring(control_string));

return; end;


#endif;
;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc pegs4 routines                                                      "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Blake Walters, 2013                                       "
"                                                                             "
"  Contributors:                                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The content of this file was adapted from the original pegs4 source code   "
"  to enable on-the-fly pegs data generation in EGSnrc. Please see the pegs4  "
"  sources for more information on the authorship of the original code.       "
"                                                                             "
"#############################################################################"


"Compiler directives"
"==================="
%Q1         "Automatically close comments at end of line
            "but NOTE, this doesn't happen inside a REPLACE macro
            "you must open and close within a REPLACE macro.
%C80        "Allow 80 columns of source/line (default is 72)
!INDENT M2; "Indent Mortran compile listing 2 spaces each nesting level
!INDENT F2; "Indent fortran output 2 spaces each nesting level
%L          "Turn on listing
%I4 "INDENT FOUR SPACES EACH LEVEL"

%E
"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
SUBROUTINE EFUNS(E,V);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"
implicit none;
;

$REAL4 E,V(8);

" IK: Variable declarations for implicit none"
$REAL4 BREM,AMOLL,BHAB,ANNIH,ESIG,PSIG;

" IK: Function declarations for implicit none"
$REAL4 BREMTM,AMOLTM,BHABTM,ANIHTM,SPTOTE,SPTOTP,TMXS,THBREM;

"*****SUBROUTINE TO COMPUTE ELECTRON FUNCTIONS TO BE FIT           "
"     IN A WAY THAT AVOIDS REPETITION.                             "
COMIN/THRESHP,DERCON,EGS-IO/;
THBREM=RMP+APP;"threshold for bremsstrahlung"
IF(IUNRSTP.EQ.0 .OR. IUNRSTP.EQ.1 .OR. IUNRSTP.EQ.5)[
"  REGULAR DATA SET OR"
"   UNRESTRICTED COLLISIONAL(1) OR RADIATIVE(5) STOPPING POWERS"
"write(58,*)' here e ',e;"
BREM=BREMTM(E);
AMOLL=AMOLTM(E);
BHAB=BHABTM(E);
ANNIH=ANIHTM(E);
ESIG=BREM+AMOLL; "TOTAL ELECTRON CROSS-SECTION"
V(1)=ESIG;
PSIG=BREM+BHAB+ANNIH;"TOTAL POSITRON CROSS SECTION"
V(2)=PSIG;
V(3)=SPTOTE(E,AEP,APP); "TOTAL ELECTRON STOPPING POWER"
V(4)=SPTOTP(E,AEP,APP);"TOTAL POSITRON STOPPING POWER"
"EBR1=BREM/(BREM+AMOLL)"
IF (ESIG.GT.0.0)[V(5)=BREM/ESIG;]
ELSE["BELOW THRESHOLD FOR BOTH BREMS AND MOLLER. USE THE BRANCHING"
"RATIO THAT EXISTED WHEN CROSS SECTION APPROACHED ZERO"
IF (THBREM.LE.THMOLLP)[V(5)=1.0;]ELSE[V(5)=0.0;]
]
V(6)=BREM/PSIG;"PBR1=BREM/(BREM+BHABA+ANNIH)"
V(7)=(BREM+BHAB)/PSIG;"PBR2=(BREM+BHABA)/(PSIG)"
"MAXIMUM ALLOWED TRANSPORT STEP, FROM MULTIPLE SCATTERING"
V(8)=TMXS(E);
"write(*,*)'v1,v2,v3,v4,v5,v6,v7,v8 ',v(1),v(2),v(3),v(4),v(5),v(6),v(7),v(8);"
]
"  THE FOLLOWING ARE UNDOCUMENTED ADDITIONS"
ELSEIF(IUNRSTP.EQ.2)[ "FULL CSDA DATA SET WITH NO DISCRETE INTERACTIONS"
/V(1),V(2),V(5),V(6),V(7)/=0.0;
"ZERO TOTAL CROSS SECTION FOR EL & POS, AND ZERO BRANCHING RATIOS"
V(3) = SPTOTE(E,E,E);"  TOTAL UNRESTRICTED STOPPING POWER"
V(4) = SPTOTP(E,E,E);
V(8) = TMXS(E);]
ELSEIF(IUNRSTP.EQ.3)["CONSIDER BREM AND ANNIHILATION IN FLIGHT AS"
"     DISCRETE EVENTS BUT TREAT DELTAS IN CSDA"
BREM=BREMTM(E);  ANNIH=ANIHTM(E);
V(1)=BREM; "TOTAL X-SECTION IS JUST BREM"
V(2)=BREM + ANNIH;"POSITRONS ALSO HAVE ANNIHILATION IN FLIGHT"
V(3)=SPTOTE(E,E,APP);"UNRESTRICTED COLLISIONAL+RESTRICTED RADIATIVE"
V(4)=SPTOTP(E,E,APP);"    ''                             ''    "
V(5)=1.0;"ALL ELECTRON EVENTS ARE BREM EVENTS"
V(6)=BREM/V(2);"FRACTION FOR POSITRONS WHICH IS BREM"
V(7)=V(6);"FRACTION WHICH IS BREM + COLLISION(=0)"
V(8)=TMXS(E);]

ELSEIF(IUNRSTP.EQ.4)["CREATE SECONDARIES BUT HAVE NO DISCRETE BREM OR"
"ANNIHILATION IN FLIGHT"

V(1)=AMOLTM(E);"ONLY MOLLERS FOR ELECTRONS"
V(2)=BHABTM(E);"ONLY BHABHA FOR POSITRONS"
V(3)=SPTOTE(E,AEP,E);"RESTRICTED COLLISIONAL + UNRESTRICTED RADIATIVE"
V(4)=SPTOTP(E,AEP,E);"         ''                         ''       "
V(5)=0.0;"I.E. NEVER BREMS"
V(6)=0.0;"I.E. NEVER BREMS"
V(7)=1.0;"ALL BHABHA - NO ANNIHILATION"
V(8)=TMXS(E);]

ELSE ["IUNRST=6 OR 7 NOT ALLOWED HERE"
OUTPUT IUNRSTP; (//'*********IUNRST=',I4,' NOT ALLOWED BY EFUNS*****'/
' IUNRST=6 OR 7 ONLY ALLOWED WITH CALL OR PLTN OPTIONS'//);
$CALL_EXIT(20);]
RETURN;
END; "END OF SUBROUTINE EFUNS"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION BREMTM(E0);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

;
implicit none;
$REAL4 E0,BREMRM;
COMIN/THRESHP,DERCON/;
IF (E0.LE.APP+RMP) [BREMTM=0.; ]
ELSE [BREMTM=BREMRM(E0,APP,E0-RMP);]
RETURN;
END; "END OF FUNCTION BREMTM"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION BREMRM(E,K1,K2);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

;
implicit none;
$REAL4 E,K1,K2;
$INTEGER I;
$REAL4    BREMRZ;
COMIN/MIXDAT/;
BREMRM=0.;
DO I=1,NEP [BREMRM=BREMRM+PZP(I)*BREMRZ(ZELEMP(I),E,K1,K2);]
RETURN;
END; "END OF FUNCTION BREMRM"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION BREMRZ(Z,E,K1,K2);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

implicit none;
$REAL4 Z,E,K1,K2;
EXTERNAL BREMFZ;
$REAL4  DUMMY,BREMDZ,QD,BREMFZ;
"     INITIALIZE BREMFZ                                                "

"    CHANGED"

"    CALL BREMDZ(Z,E,K1);"

"    TO"

"    DUMMY=BREMDZ(Z,E,K1);"

"    FOR SUN COMATIBILITY AFB 89/12/27"
"write(58,*)'2 e ',e;"
DUMMY=BREMDZ(Z,E,K1);
BREMRZ=QD(BREMFZ,K1,K2,'BREMFZ');
"write(58,*)'bremrz ',BREMRZ;"
RETURN;
END; "END OF FUNCTION BREMRZ"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION BREMDZ(Z,E,K);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

implicit none;
$REAL4    Z,E,K,BRMSDZ;
"***ALL ENTRIES TO THIS FUNCTION GIVE THE CONTRIBUTION THAT ELEMENT Z"
"   WOULD HAVE IF THERE WERE ONE PER MOLECULE.                      "
"   ENTRIES STARTING WITH D DO THEIR OWN INITIALIZATION.             "
"   ENTRIES STARTING WITH F RELY ON PREVIOUS D FOR INITIALIZATION.   "
"   BREMDZ.. D-SIGMA/D-K FOR BREMS IN Z                              "
"   BRMSDZ.. K*(D-SIGMA/D-K) FOR SOFT ENERGY LOSS FROM BREMS IN Z    "

"EVALUATES EQUATION 2.7.108 IN SLAC-265"

BREMDZ=BRMSDZ(Z,E,K)/K;
"write(58,*)'bremdz,z,e,k ',BREMDZ,z,e,k;"
RETURN;
END;  "END OF FUNCTION BREMDZ"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION BREMFZ(K);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

implicit none;
$REAL4 K,BRMSFZ;
BREMFZ=BRMSFZ(K)/K;
"write(58,*)'bremfz ',BREMFZ;"
RETURN;
END;  "END OF FUNCTION BREMFZ"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION BRMSFZ(K);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

;
implicit none;
$REAL4 K;
$REAL4 EMKLOC,DELTA,SB1,SB2,EE;
COMIN/LBREMZ/;
EMKLOC=EBREMZ-K;
IF(EMKLOC.EQ.0.0) [EMKLOC=1.E-25;]
DELTA=DELC*K/EMKLOC;
IF (DELTA.GE.DELTAM) [BRMSFZ=0.0;]
ELSE [IF (DELTA.LE.1.)[
SB1=20.867+DELTA*(-3.242+DELTA*0.625)-XLNZ;
SB2=20.209+DELTA*(-1.930+DELTA*(-0.086))-XLNZ;]
ELSE [SB1=21.12-4.184*LOG(DELTA+0.952)-XLNZ;
SB2=SB1;]
EE=EMKLOC/EBREMZ;
BRMSFZ=CONST*((1.+EE*EE)*SB1-0.666667*EE*SB2);]
"write(58,*)' const,ee,sb1,sb2,brmsfz ',const,ee,sb1,sb2,brmsfz;"
RETURN;
END; "END OF FUNCTION BRMSFZ"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION AMOLTM(E0);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

;
implicit none;
$REAL4    E0;
$REAL4    T0,AMOLRM;
"***TOTAL CROSS SECTION FOR MOLLER SCATTERING WITH INCIDENT ELECTRON"
"   ENERGY(TOTAL) OF E0."
COMIN/THRESHP,DERCON/;
IF (E0.LE.THMOLLP) [AMOLTM=0.; ]
ELSE [T0=E0-RMP;
AMOLTM=AMOLRM(E0,AEP,T0*0.5+RMP);] "EQ.2.10.6"
RETURN;
END; "END OF FUNCTION AMOLTM"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION AMOLRM(EN0,EN1,EN2);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

;
implicit none;
$REAL4    EN0,EN1,EN2;
$REAL4    T0,T1,T2,TM,EM,C1,C2,BETASQ,CMOLL2,EPS1,EPSP1,EPS2,EPSP2;
"***MOLLER CROSS SECTION FOR INCIDENT ELECTRON OF TOTAL ENERGY EN0 TO"
"   PRODUCE SECONDARY ELECTRON IN THE TOTAL ENERGY RANGE EN1 TO EN2."
COMIN/PMCONS,MOLVAR,DERCON/;
T0=EN0-RMP;
T1=EN1-RMP;
T2=EN2-RMP;
TM=T0/RMP;
EM=TM+1.;
C1=(TM/EM)**2;
C2=(2.*TM+1.)/EM**2;
BETASQ=1.-1./EM**2;
CMOLL2=RLCP*EDEN*2.*PIP*R0**2/(BETASQ*TM); "CONSTANT FACTOR IN EQ.2.10.3"
EPS1=T1/T0;
EPSP1=1.-EPS1;
EPS2=T2/T0;
EPSP2=1.-EPS2;
AMOLRM=CMOLL2*(C1*(EPS2-EPS1)+1./EPS1-1./EPS2+1./EPSP2-1./EPSP1
  -C2*LOG(EPS2*EPSP1/(EPS1*EPSP2))); "EQ.2.10.3"
RETURN;
END; "END OF FUNCTION AMOLRM"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION BHABTM(E0);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

"***TOTAL CROSS SECTION FOR BHABHA SCATTERING WITH INCIDENT POSITRON"
"   ENERGY(TOTAL) OF E0."
;
implicit none;
$REAL4 E0,BHABRM;
COMIN/THRESHP/;
IF (E0.LE.AEP) [BHABTM=0.;]
ELSE [BHABTM=BHABRM(E0,AEP,E0);]  "EQ.2.11.4"
RETURN;
END; "END OF FUNCTION BHABTM"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION BHABRM(EN0,EN1,EN2);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

"***BHABHA CROSS SECTION FOR INCIDENT POSITRON OF TOTAL ENERGY EN0 TO"
"   PRODUCE SECONDARY ELECTRON IN THE TOTAL ENERGY RANGE EN1 TO EN2."
;
implicit none;
$REAL4 EN0,EN1,EN2;
$REAL4 T0,T1,T2,TM,EM,Y,BETASI,CBHAB2,B1,B2,B3,B4,EPS1,EPS2;
COMIN/PMCONS,MOLVAR,DERCON/;
T0=EN0-RMP;
T1=EN1-RMP;
T2=EN2-RMP;
TM=T0/RMP;
EM=TM+1.;
Y=1./(TM+2.);
BETASI=1./(1.-1./EM**2);
CBHAB2=RLCP*EDEN*2.*PIP*R0**2/TM; "CONSTANT FACTOR IN EQ.2.11.2"
B1=2.-Y**2;
B2=3.-Y*(6.-Y*(1.-Y*2.));
B3=2.-Y*(10.-Y*(16.-Y*8.));
B4=1.-Y*(6.-Y*(12.-Y*8.));
EPS1=T1/T0;
EPS2=T2/T0;
BHABRM=CBHAB2*(BETASI*(1./EPS1-1./EPS2)-B1*LOG(EPS2/EPS1)
  +B2*(EPS2-EPS1)+EPS2*EPS2*(EPS2*B4/3.-0.5*B3)
  - EPS1*EPS1*(EPS1*B4/3.-0.5*B3));  "EQ.2.11.2"
RETURN;
END; "END OF FUNCTION BHABRM"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION ANIHTM(E0);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

"***TOTAL CROSS SECTION FOR TWO-PHOTON POSITRON-ELECTRON ANNIHILATION"
"   WITH INCIDENT POSITRON ENERGY(TOTAL) OF E0."
;
implicit none;
$REAL4    E0;
$REAL4    GAM,P0P2,P0P,CANIH;
COMIN/PMCONS,MOLVAR,DERCON/;
GAM=E0/RMP;   "EQ.2.12.3"
P0P2=GAM*GAM-1.0;
P0P=SQRT(P0P2);  "EQ.2.12.6"
CANIH=RLCP*EDEN*PIP*R0**2/(GAM+1.); "CONSTANT FACTOR IN EQ.2.12.14"
ANIHTM=CANIH*((GAM*GAM+4.*GAM+1.)/P0P2*LOG(GAM+P0P)
   -(GAM+3.)/P0P);   "EQ.2.12.14"
RETURN;
END;  "END OF FUNCTION ANIHTM"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION SPTOTP(E0,EE,EG);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"MODIFIED JAN 1989 DWOR AS SPTOTE                                  "
"******************************************************************"

;
implicit none;
$REAL4 E0,EE,EG;
$REAL4 SPIONP,BRMSTM;
COMIN/THRESHP/;
IF (IUNRSTP.EQ.0) ["RESTRICTED TOTAL STOPPING POWER I.E. NORMAL"
                  SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,EG);
"write(*,*)' eo,ee,eg,spionp,brmstm ',e0,ee,eg,SPIONP(E0,EE),BRMSTM(E0,EG);"]
ELSEIF(IUNRSTP.EQ.1)[SPTOTP=SPIONP(E0,E0);]"UNRESTRICTED COLLISION"
ELSEIF(IUNRSTP.EQ.2)["UNRESTRICTED COLLISION AND RADIATIVE        "
                    SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,E0);]
ELSEIF(IUNRSTP.EQ.3)["UNRESTRICTED COLLISION +RESTRICTED RADIATIVE"
                    SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,EG);]
ELSEIF(IUNRSTP.EQ.4)["RESTRICTED COLLISION +UNRESTRICTED RADIATIVE"
                    SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,E0);]
ELSEIF(IUNRSTP.EQ.5)[SPTOTP=BRMSTM(E0,E0);]"UNRESTRICTED RADIATIVE"
ELSEIF(IUNRSTP.EQ.6)[SPTOTP=BRMSTM(E0,EG);]"RESTRICTED RADIATIVE  "
ELSEIF(IUNRSTP.EQ.7)[SPTOTP=SPIONP(E0,EE);]"RESTRICTED COLLISON   "
RETURN;
END;  "END OF FUNCTION SPTOTP"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION SPTOTE(E0,EE,EG);
"                                VERSION 4.00  --  26 JAN 1986/1900"
" patched DWOR, Jan 1988 to correct IURST=2,3,4 and add 6 and 7    "
"******************************************************************"
;
implicit none;
$REAL4 E0,EE,EG;
$REAL4 SPIONE,BRMSTM;
COMIN/THRESHP/;
IF (IUNRSTP.EQ.0) ["RESTRICTED TOTAL STOPPING POWER I.E. NORMAL"
                  SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,EG);]
ELSEIF(IUNRSTP.EQ.1)[SPTOTE=SPIONE(E0,E0);]"UNRESTRICTED COLLISION"
ELSEIF(IUNRSTP.EQ.2)["UNRESTRICTED COLLISION AND RADIATIVE        "
                    SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,E0);]
ELSEIF(IUNRSTP.EQ.3)["UNRESTRICTED COLLISION +RESTRICTED RADIATIVE"
                    SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,EG);]
ELSEIF(IUNRSTP.EQ.4)["RESTRICTED COLLISION +UNRESTRICTED RADIATIVE"
                    SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,E0);]
ELSEIF(IUNRSTP.EQ.5)[SPTOTE=BRMSTM(E0,E0);]"UNRESTRICTED RADIATIVE"
ELSEIF(IUNRSTP.EQ.6)[SPTOTE=BRMSTM(E0,EG);]"RESTRICTED RADIATIVE  "
ELSEIF(IUNRSTP.EQ.7)[SPTOTE=SPIONE(E0,EE);]"RESTRICTED COLLISON   "
RETURN;
END;  "END OF FUNCTION SPTOTE"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION SPIONE(E0,EE);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

implicit none;
$REAL4 E0,EE,SPIONB;
SPIONE=SPIONB(E0,EE,.FALSE.);
RETURN;
END;  "END OF FUNCTION SPIONE"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION SPIONB(E0,EE,POSITR);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

"***STOPPING POWER FOR AN ELECTRON.  THIS FUNCTION ALSO HAS OTHER    "
"   ENTRY POINTS. . .                                                "
"   SPIONP(E0,EE) - STOPPING POWER FOR A POSITRON                    "
"   SPINIT(MEDIUM) - DOES INITIALIZATION FOR THE OTHER ENTRY POINTS  "
"   WHENEVER THE MEDIUM CHANGES.                                     "
"   THIS FUNCTION IS FOR STOPPING POWER DUE TO COLLISIONS WITH LESS  "
"   THAN EE-RM ENERGY TRANSFER AND DOES NOT INCLUDE SOFT BREMS LOSS. "
"   WE USE BERGER AND SELTZER'S FORMULATION.                         "
"   STOPPING POWER IS RETURNED IN UNITS OF MEV/R.L.                  "
;
implicit none;
$REAL4   E0,EE;
LOGICAL POSITR;
$REAL4   G,EEM,T,ETA2,BETA2,ALETA2,X,D,FTERM,TP2,D2,D3,D4,DELTA;
$INTEGER I;
COMIN/DERCON,LSPION,EPSTAR/; "MOD NOV 24,1988"
"     COMMON POINT FOR E- AND E+ ENTRIES.                              "
G=E0/RMP;
EEM=EE/RMP-1.;
"     T IS BERGER'S TAU                                                "
T=G-1;
ETA2=T*(G+1.);
BETA2=ETA2/G**2;
ALETA2=LOG(ETA2);
X=0.21715*ALETA2;
"     0.21715=ALOG10(E)/2.   THIS FACTOR IS BECAUSE THE DEFINITION OF  "
"     X IS ALOG10(P/(MC)) AND ETA2=ETA**2=(P/MC)**2                    "
IF (.NOT.POSITR)["THIS IS ELECTRON CASE"
"     COMPUTE F-TERM FOR ELECTRON.  MAXIMUM TRANSFER IS T/2            "
"     D IS BERGER'S CAPITOL DELTA.                                     "
D=AMIN1(EEM,0.5*T);
"     EEM IS DEFINED AS EE/RM-1 IS ENERGY TRANSFER THRESHOLD FOR       "
"     DISCRETE MOLLER AND BHABHA SCATTERING(IN UNITS OF RM.)           "
FTERM=-1.-BETA2+LOG((T-D)*D)+T/(T-D)
  +(D*D/2.+(2.*T+1.)*LOG(1.-D/T))/(G*G);]
"     COMPUTE F-TERM FOR POSITRON.  MAXIMUM TRANSFER IS T.             "
ELSE ["THIS IS POSITRON CASE"
D=AMIN1(EEM,T);
TP2=T+2.;
D2=D*D;
D3=D*D2;
D4=D*D3;
FTERM=LOG(T*D)-(BETA2/T)*( T + 2.*D - (3.*D2/2.)/TP2
 -(D-D3/3.)/(TP2*TP2)-(D2/2.-T*D3/3.+D4/4.)/TP2**3);]

"     NOW COMPUTE THE DENSITY CORRECTION TERM.                         "

IF(EPSTFLP = 0) ["USE STANDARD PEGS4 METHOD"
IF (X.LE.X0) [DELTA=0.0;]
ELSEIF (X.LT.X1) [DELTA=TOLN10*X - CBAR + AFACT*(X1 - X)**SK;]
ELSE [DELTA=TOLN10*X - CBAR;]]

ELSE ["USE LINEAR INTERPOLATION OF USER SUPPLIED INPUT TABLE"

"IEPST IS A POINTER SUCH THAT                              "
"       EPSTEN(IEPST) <= E0 < EPSTEN(IEPST+1)              "
"                                                          "
"IEPST IS INITIALIZED IN BLOCK DATA TO 1. WE START FROM    "
"THE PREVIOUS VALUE OF THE POINTER SINCE WE ASSUME THAT    "
"THE CODE IS WORKING UP OR DOWN A GRID.                    "
"  THIS CODING IS FAR FROM OPTIMAL                         "

IF(E0 >= EPSTEN(IEPST))["AT OR ABOVE PREVIOUS ENTRY"
IF(E0 = EPSTEN(IEPST))["FOUND ENTRY, INCLUDING THE POSSIBILITY"
"THAT WE ARE AT THE TOP OF THE TABLE"     GO TO :END-SEARCH:;]

DO I= IEPST,NEPST-1 [
     IF(E0<EPSTEN(I+1))["WE FOUND IT" IEPST = I; GO TO :END-SEARCH:]
     ]
"IF WE FALL THRU TO HERE, WE MUST BE AT UPPER ENERGY"
IEPST = NEPST; GO TO :END-SEARCH:;
]"END OF BLOCK E0>EPSTEN(IEPST)"

ELSE [ "E0<EPSTEN(IEPST)"

DO I = IEPST,2,-1 [
    IF(E0 >= EPSTEN(I-1)) [IEPST = I-1; GO TO :END-SEARCH:;]
    ]
"   IF WE GET HERE WE MUST BE IN THE FIRST REGION"
    IEPST = 1;]

:END-SEARCH:

"NOW JUST INTERPOLATE LINEARLY IN THE ENERGY"
IF(IEPST < NEPST) [
   DELTA = EPSTD(IEPST) + (E0 - EPSTEN(IEPST))/
   (EPSTEN(IEPST+1) - EPSTEN(IEPST)) * (EPSTD(IEPST+1) - EPSTD(IEPST));]
ELSE [DELTA = EPSTD(NEPST);]

]"END OF EPSTFL NON-ZERO BLOCK"

"     NOW PUT IT ALL TOGETHER                                          "
SPIONB=(SPC1/BETA2)*(LOG(T + 2.) - SPC2 + FTERM - DELTA);
RETURN;
END;  "END OF FUNCTION SPIONB"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION SPIONP(E0,EE);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

implicit none;
$REAL4 E0,EE,SPIONB;
SPIONP=SPIONB(E0,EE,.TRUE.);
RETURN;
END;  "END OF FUNCTION SPIONP"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION BRMSTM(E0,EG);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

;
implicit none;
$REAL4 E0,EG,BRMSRM,AU,zero;
parameter (zero=0);
COMIN/DERCON/;
IF (E0.LE.RMP) [BRMSTM=0.; ]
ELSE [AU=AMIN1(EG,E0-RMP);
BRMSTM=BRMSRM(E0,zero,AU);
"write(*,*)'au,e0,brmsrm ',au,e0,BRMSRM(E0,zero,AU);"
]
RETURN;
END; "END OF FUNCTION BRMSTM"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION BRMSRM(E,K1,K2);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"
;
implicit none;
$REAL4 E,K1,K2,BRMSRZ;
$INTEGER I;
COMIN/MIXDAT/;
BRMSRM=0.;
DO I=1,NEP[BRMSRM=BRMSRM+PZP(I)*BRMSRZ(ZELEMP(I),E,K1,K2);
"write(*,*)'i,e,k1,k2,pz,brmsrz ',i,e,k1,k2,PZ(i_med,I),"
"BRMSRZ(ZELEM(i_med,I),E,K1,K2);"]
RETURN;
END; "END OF FUNCTION BRMSRM"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION BRMSRZ(Z,E,K1,K2);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

implicit none;
$REAL4 Z,E,K1,K2;
EXTERNAL BRMSFZ;
$REAL4 DUMMY,BRMSDZ,QD,BRMSFZ;
"     INITIALIZE BRMSFZ                                                "

"    CHANGED"

"    CALL BRMSDZ(Z,E,K1);"

"    TO"

"    DUMMY=BRMSDZ(Z,E,K1);"

"    FOR SUN COMATIBILITY AFB 89/12/27"
"write(58,*)' e ',e;"
DUMMY=BRMSDZ(Z,E,K1);
BRMSRZ=QD(BRMSFZ,K1,K2,'BRMSFZ');
"write(58,*)'brmsrz ',BRMSRZ;"
RETURN;
END; "END OF FUNCTION BRMSRZ"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION BRMSDZ(Z,EA,K);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

;
implicit none;
$REAL4 Z,EA,K;
$REAL4 APRIM,XSIFP,FCOULCP,BRMSFZ;
COMIN/PMCONS,DERCON,MOLVAR,LBREMZ/;
EBREMZ=EA;
DELC=136.*Z**(-1./3.)*RMP/EBREMZ;
CONST=APRIM(Z,EBREMZ)*(AN*RHOP/WM)*R0**2*FSC*Z*(Z+XSIFP(Z))*RLCP;
"write(58,*)' z,ebremz,an,rho,wm,r0,fsc,xsif,rlc,aprim ',z,ebremz,an,rhop,"
"wm,r0,fsc,xsifp(z),RLCP,APRIM(Z,Ebremz);"
XLNZ=4./3.*LOG(Z);
IF (EBREMZ.GE.50)XLNZ=XLNZ+4.*FCOULCP(Z);
".....DELTAM IS THE DELTA AT WHICH THE SQUARE BRACKETS GO TO ZERO      "
DELTAM=EXP((21.12-XLNZ)/4.184)-0.952;
BRMSDZ=BRMSFZ(K);
RETURN;
END;  "END OF FUNCTION BRMSDZ"


"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION APRIM(Z,E);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

"     EMPIRICAL CORRECTION FACTOR TO BREMS CROSS SECTION               "

" This version can be switched to use different values:                "
"   IAPRIM = 0  equivalent to old PEGS4 (default)                      "
"            1  reads in values from unit 22                           "
"            2  sets APRIM to 1.0                                      "
" Future changes can be accommodated by reading in                     "
" different data on unit 22 and if necessary changing the array sizes: "

;
implicit none;
$REAL4 Z,E;
$INTEGER  napre,naprz,ie,iz,aprim_unit,egs_get_unit,lnblnk1;
$REAL4     EM,AINTP;
character  aprim_file*256;
REPLACE {$NAPRE} WITH {115} " Maximum number of energies ( > 18 )      "
REPLACE {$NAPRZ} WITH {14}  " Maximum number of elements ( > 5 )       "

REPLACE {$NAPR1} WITH {{COMPUTE $NAPRE - 18}}
REPLACE {$NAPR2} WITH {{COMPUTE $NAPRZ - 5}}
REPLACE {$NAPR3} WITH {{COMPUTE $NAPRE * $NAPR2}}
;COMIN/DERCON,EPSTAR,EGS-IO/; "NRC CHANGE NOV 88"
$REAL4 APRIMD($NAPRE,$NAPRZ),EPRIM($NAPRE),ZPRIM($NAPRZ),APRIMZ($NAPRE);
DATA APRIMD/
1.32,1.26,1.18,1.13,1.09,1.07,1.05,1.04,1.03, 1.02,8*1.0,$NAPR1*0.0,
1.34,1.27,1.19,1.13,1.09,1.07,1.05,1.04,1.03,1.02, 8*1.0,$NAPR1*0.0,
1.39,1.30,1.21,1.14,1.10,1.07,1.05,1.04,1.03,1.02,0.994,
 2*0.991,0.990,2*0.989,2*0.988,$NAPR1*0.0,
1.46,1.34,1.23,1.15,1.11,1.08, 1.06,1.05,1.03,1.02,0.989,
 0.973,0.971,0.969,0.967,0.965,2*0.963,$NAPR1*0.0,
1.55,1.40,1.26,1.17,1.12,1.09,1.07,1.05,1.03,1.02,0.955,0.935,
 0.930,0.925,0.920,0.915,2*0.911,$NAPR1*0.0,
$NAPR3*0.0/,
EPRIM /
2.,3.,4.,5.,6.,7.,8.,9.,10.,11.,21.,31.,41.,51.,61.,71.,81.,91.,
$NAPR1*0.0/,
ZPRIM /6.,13.,29.,50.,79.,$NAPR2*0.0/;
save APRIMD,EPRIM,ZPRIM,APRIMZ,napre,naprz;

IF (IAPRIMP.EQ.0) [ " PEGS4 default APRIM"
    IF(IAPRFL = 0)[IAPRFL=1;
    /*
    OUTPUT;
    ('0IAPRIM=0, i.e. uses KOCH AND MOTZ empirical corrections to',
    ' bremsstrahlung cross section'/);
    */
    ]
    IF (E.GE.50) [ APRIM=1.; ]
    ELSE [ " INTERPOLATE APRIM OVER Z "
        EM=E/RMP;
        DO IE=1,18[
           APRIMZ(IE)=
           AINTP(Z,ZPRIM,5,APRIMD(IE,1),$NAPRE,.FALSE.,.FALSE.);
           ] " Z INTERPOLATION IS NOW COMPLETE. NOW DO ENERGY "
        APRIM=AINTP(EM,EPRIM,18,APRIMZ,1,.FALSE.,.FALSE.);
    ]
]
ELSEIF (IAPRIMP.EQ.1) [
    IF (IAPRFL.EQ.0) [ " read in data from APRIME.DATA"
        /*
        OUTPUT;('0IAPRIM=1, i.e. uses NRC(based on NIST/ICRU)',
       ' corrections to bremsstrahlung cross section'/);
        */
        aprim_file = $cstring(hen_house) // 'pegs4' // $file_sep //
                     'aprime.data';
        aprim_unit=22;" want unit 22"
        aprim_unit=egs_get_unit(aprim_unit);
        IF( aprim_unit < 1 ) [
             $egs_fatal(*,'APRIM: failed to get a free fortran unit');
        ]
        open(aprim_unit,file=aprim_file,status='old',err=:no_aprim_file:);

        READ(aprim_unit,*) NAPRZ, NAPRE;
        IF (NAPRZ.GT.$NAPRZ) [
            OUTPUT; (//,' TOO MANY ELEMENTS FOR APRIME INTERPOLATION:',
            /,'   CHANGE $NAPRZ AND RECOMPILE PEGS'); $CALL_EXIT(24);]
        IF (NAPRE.GT.$NAPRE) [
            OUTPUT; (//,' TOO MANY ENERGIES FOR APRIME INTERPOLATION:',
            /,'   CHANGE $NAPRE AND RECOMPILE PEGS'); $CALL_EXIT(24);]
        READ(aprim_unit,*) (EPRIM(IE),IE=1,NAPRE);
        DO IE=1,NAPRE [ EPRIM(IE)=1.+EPRIM(IE)/RMP; ]
        DO IZ=1,NAPRZ [READ(aprim_unit,*)ZPRIM(IZ),(APRIMD(IE,IZ),IE=1,NAPRE);]
        IAPRFL=1;
        close(aprim_unit);
        ]
    EM=E/RMP;
    DO IE=1,NAPRE [ " INTERPOLATE APRIM OVER LOG(Z)  "
        APRIMZ(IE)=
        AINTP(Z,ZPRIM,NAPRZ,APRIMD(IE,1),$NAPRE,.TRUE.,.FALSE.);
        ]           " NOW DO ENERGY INTERPOLATION     "
    APRIM=AINTP(EM,EPRIM,NAPRE,APRIMZ,1,.FALSE.,.FALSE.);
    ]
ELSEIF (IAPRIMP.EQ.2) [
        IF(IAPRFL = 0)[IAPRFL=1;
        /*
        OUTPUT;('0IAPRIM = 2, i.e. uses NO corrections to bremsstrahlung',
        ' cross section'/);
        */
        ]
        APRIM=1.0]
ELSE [ OUTPUT IAPRIMP; (//,' ILLEGAL VALUE FOR IAPRIM: ',I4);
       $CALL_EXIT(24); ]
RETURN;
:no_aprim_file:
$egs_fatal(*,'Cannot open file $HEN_HOUSE/pegs4/aprime.data');
RETURN;
END; "END OF FUNCTION APRIM"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION AINTP(X,XA,NX,YA,ISK,XLOG,YLOG);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"
implicit none;

"     LINEAR OR LOG INTERPOLATION FUNCTION.                          "

"CHANGED"
"REAL XA(1),YA(ISK,1);"
"TO"
"REAL XA(NX),YA(ISK,NX);"
"FOR SUN AFB 89/12/27"

$INTEGER NX,ISK;
$REAL4    X;
$REAL4    XA(NX),YA(ISK,NX);
LOGICAL XLOG,YLOG,XLOGL;

$INTEGER I,J;
$REAL4    XI,XJ,XV,YI,YJ;
XLOGL=XLOG;  "SET LOCAL VARIABLE"
"     FIND INTERVAL FOR X INTERPOLATION.                             "
DO J=2,NX[
IF (X.LT.XA(J))GO TO :NSTEP:;]
J=NX;
:NSTEP:    I=J-1;
IF (XA(I).LE.0.0) [XLOGL=.FALSE.;]
IF (.NOT.XLOGL)[ XI=XA(I); XJ=XA(J); XV=X;]
ELSE [XI=LOG(XA(I)); XJ=LOG(XA(J)); XV=LOG(X);]
IF (YLOG.AND.(YA(1,I).EQ.0.0.OR.YA(1,J).EQ.0.0))
   [AINTP=0.0;]
ELSE[
    IF(YLOG)[YI=LOG(YA(1,I));YJ=LOG(YA(1,J));
    IF(XJ.EQ.XI) [AINTP=YI;]
    ELSE [AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI);]
    AINTP=EXP(AINTP);]
    ELSE[YI=YA(1,I); YJ=YA(1,J);
         IF(XJ.EQ.XI) [AINTP=YI;]
         ELSE [AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI);]]
]
RETURN;
END; "END OF FUNCTION AINTP"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION TMXS(E);"MAXIMUM STEP SIZE VALID FOR MULTIPLE SCATTERING"
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

implicit none;
$REAL4 E,TMXB;
$REAL4 SAFETY,TABSMX;
DATA SAFETY/0.8/,TABSMX/10.0/;
save SAFETY,TABSMX;
TMXS=AMIN1(TMXB(E)*SAFETY,TABSMX);
"THE FACTORE 'SAFETY' IS TO KEEP SOMEWHAT BELOW BETHE'S LIMIT"
"TABSMX IS AN ABSOLUTE LIMIT TO SIZE OF ELECTRON TRANSPORT,"
"  INDEPENDENT OF THE MULTIPLE SCATTERING LIMIT"
RETURN;
END;  "END OF FUNCTION TMXS"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION TMXB(E);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

implicit none;
$REAL4 E;
"THIS FUNCTION FINDS THE TRANSPORT DISTANCE WHICH AT THIS ENERGY"
"IS THE LARGEST CONSISTENT WITH BETHE'S CRITERION, NAMELY"
"  XC**2*B.LE.1;   SINCE XC ANB B ARE INCREASING FUNCTIONS OF T"
" THE TRANSPORT DISTANCE, THE CRITERION FOR TMXB IS THEN"
"  XC**2*B=1;      OTHER RELATIONS USED IN THE DERIVATION ARE"
"EXPLAINED IN SUBROUTINES MIX AND MOLIER.  THEY ARE:"
"  XC=XCC*SQRT(T)/(E*BETA**2); "
"  EXP(B)/B = BLCC*T/BETA**2;  "
"FROM THESE IS DERIVED THE EQUATION THIS FUNCTION IS BASED ON:"
"TMXB=(E**2*BETA**2/XCC**2)*BETA**2/LOG(BLCC*(E**2*BETA**2/XCC**2));"
;
$REAL4 ESQ,BETA2,PX2;
COMIN/DERCON,MOLVAR/;
ESQ=E**2;
BETA2=1.0-RMPSQ/ESQ;
PX2=ESQ*BETA2/XCCP**2;
TMXB=PX2*BETA2/LOG(BLCCP*PX2);
RETURN;
END;   "END OF FUNCTION TMXB"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION ALKE(E);"LOG OF KINETIC ENERGY"
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

;
implicit none;
$REAL4 E;
COMIN/DERCON/;
ALKE=LOG(E-RMP);
"write(58,*)' alke,e,rm,e-rm ',alke,e,rmp,e-rmp;"
RETURN;
END;  "END OF FUNCTION ALKE"
"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION ALKEI(X);"INVERSE OF LOG OF KINETIC ENERGY"
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

;
implicit none;
$REAL4 x;
COMIN/DERCON/;
ALKEI=EXP(X) + RMP;
RETURN;
END;  "END OF FUNCTION ALKEI"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
SUBROUTINE PWLF1(NI,NIMX,XL,XU,XR,EP,ZTHR,ZEP,NIP,XFUN,XFI,
                 AX,BX,NALM,NFUN,AF,BF,VFUNS);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

"***PWLF1 IS A ROUTINE WHICH WILL FIT UP TO 10(CURRENTLY) FUNCTIONS  "
"   SIMULTANEOUSLY ON AN INTERVAL (XL,XU) OF THE INDEPENDENT VARIABLE"
"   X OF THE FUNCTIONS. THE FIT IS A PIECEWISE LINEAR FUNCTION OF    "
"   XFUN(X).  XFI IS THE INVERSE FUNCTION OF XFUN.  THE SUBINTERVALS "
"   ARE CHOSEN OF UNIFORM WIDTH IN XFUN(X) AND SUFFICIENT OF THEM    "
"   ARE CHOSEN SO THAT THE FIT GIVES A RELATIVE ERROR[EP FOR ALL     "
"   THE FUNCTIONS OVER ALL THE SUBINTERVALS.                         "
"   QFIT IS AN AUXILIARY FUNCTION.       "
"   EXPLANATION OF THE ARGUMENTS:                                    "
"   NI   ON RETURN IS NUMBER OF SUBINTERVALS USED FOR THE FIT.       "
"   XL   LOWER LIMIT OF INTERVAL ON WHICH TO FIT THE FUNCTIONS.      "
"   XU   UPPER LIMIT                                                 "
"   XR   VALUE OF X WHICH WILL BE FORCED TO BE A SUBINTERVAL BOUNDARY"
"        THE SIGNIFICANCE OF THIS IS THAT THE STRAIGHT LINES ON THE  "
"        SUBINTERVALS ARE CHOSEN TO FIT EXACTLY AT THE SUBINTERVAL   "
"        BOUNDARIES, THUS IF ONE WANTS AN EXACT FIT OF THE FUNCTIONS "
"        AT A PARTICULAR POINT, XR SHOULD BE SET TO THAT VALUE.      "
"        OTHERWISE XR SHOULD BE SET TO XH.  ANOTHER REQUIREMENT      "
"        IS THAT XU SHOULD BE LARGER THAN XL.                        "
"   EP   THE MAXIMUM RELATIVE ERROR ALLOWED THE FIT.                 "
"   NIP  THE MINUIMUM NUMBER OF POINTS INTERIOR TO (XL,XU) AT WHICH  "
"        THE FIT IS TO BE TESTED FOR RELATIVE ERROR VS. EP.          "
"   XFUN A FUNCTION OF X OVER WHICH IT IS HOPED THE FUNCTIONS TO BE  "
"        FIT ARE MORE LINEAR THAN OVER X.  XFUN IS EXPECTED TO BE    "
"        MONOTONICALLY INCREASING IN X.                              "
"   XFI  THE INVERSE OF XFUN. THAT IS XFI(XFUN(X))=X.                "
"   AX,BX ARE COEFFICIENTS USED AS SHOWN BELOW TO DETERMINE WHICH    "
"        SUBINTERVAL A VALUE OF X IS IN.                             "
"   AF,BF ARE ARRAYS OF COEFFICIENTS USED TO GET VALUES OF THE FUNCS."
"   THE PROCEDURE FOR FINDING THE FIT VALUE OF FUNCTION IFUN IS:     "
"   INTERV=AX*XFUN(X)+BX                                             "
"   VALUE=AF(INTERV,IFUN)*XFUN(X)+BF(INTERV,IFUN)                    "
"   NALM  IS THE MAXIMUM NUMBER OF SUBINTERVALS FOR WHICH ARRAY SPACE"
"         HAS BEEN ALLOCATED.                                        "
"   NFUN  IS THE NUMBER OF FUNCTIONS TO BE FITTED(SIMULTANEOUSLY,I.E."
"         ALL FUNCTIONS HAVE THE SAME XFUN AND SUBINTERVALS, AND ALL "
"         ARE REQUIRED TO BE FIT WITH MAX REL ERR[EP)                "
"   VFUNS IS A SUBROUTINE TO FILL AN ARRAY WITH THE VALUES OF THE    "
"   FUNCTIONS TO BE FITTED.                                          "
;
implicit none;

COMIN/EGS-IO/;

$INTEGER NI,NIMX,NIP,NALM,NFUN;
$REAL4    XL,XU,XR,EP,AX,BX,XFUN,XFI;
EXTERNAL XFI,VFUNS,XFUN;
$REAL4 AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN);
"   QFIT IS A LOGICAL FUNCTION WHICH IS TRUE IF THE STATED NUMBER    "
"   OF INTERVALS GIVES A SUFFICIENTLY CLOSE FIT.                     "
LOGICAL QFIT;

" IK: Variable declarations for implicit none"
$INTEGER NL,NU,IPRN,NJ,NK;
$REAL4    REM;
"   FIND # OF INTERVALS REQUIRED.                                    "
NL=0;
NU=1;
IPRN=0;
LOOP [NJ=MIN0(NU,NIMX);
"write(58,*)' 1 nj ',nj;"
IF (QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI,
 AX,BX,NALM,NFUN,AF,BF,VFUNS,0)) EXIT;
IF (NU.GE.NIMX) [
/*
OUTPUT NIMX,EP;
(' NUMBER OF ALLOCATED INTERVALS(=',I5,') WAS INSUFFICIENT'
       ,/ ,' TO GET MAXIMUM RELATIVE ERROR LESS THAN ',1P,G14.6);
*/
"write(58,*)' nj ',nj;"
NI=NJ;RETURN;]
NL=NU;
NU=NU*2;]
"   WE NOW HAVE AN UPPER AND LOWER LIMIT ON NI, REFINE IT.           "
NU=NJ ; "SAVE SUCCESSFUL INDEX"
WHILE(NU.GT.NL+1)["LOOP UNTIL CONVERGENCE"
NJ=(NL+NU)/2;
NK=NJ; "THIS IS NECESSARY BECAUSE QFIT MAY LOWER NJ,BUT NEED ORIGINAL"
" FOR SETTING NL OR MAY GET INTO INFINITE LOOP."
IF (QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI,
AX,BX,NALM,NFUN,AF,BF,VFUNS,0))[NU=NJ;]ELSE[NL=NK;]
]
"     NU IS NOW THE SMALLEST NI WHICH FITS OK.                       "
NI=NU;
IF (NI.EQ.NJ)RETURN;"LAST TEST WAS SUCCESS"
"     CALL IT ONCE MORE TO GET THE FITS.                             "
IF (.NOT.QFIT(NI,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI,
AX,BX,NALM,NFUN,AF,BF,VFUNS,0)) OUTPUT NI;
(' CATASTROPHE---DOES NOT FIT WHEN IT SHOULD,NI=',I5);
RETURN;
END;  "END OF SUBROUTINE PWLF1"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
LOGICAL FUNCTION QFIT(NJ,XL,XH,XR,EP,ZTHR,ZEP,REM,NJP,XFUN,XFI,
 AX,BX,NALM,NFUN,AF,BF,VFUNS,IPRN);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

implicit none;
COMIN/EGS-IO/;
"EXTERNAL XFUN,XFI,VFUNS;"
EXTERNAL VFUNS;
$REAL4    XFUN,XFI;
$INTEGER NJ,NALM,NFUN,NJP,IPRN;
$REAL4    XL,XH,XR,AX,BX,REM,EP;
$REAL4 FSXL(10),FSXH(10),FIP(10),FFIP(10),AFIP(10),RE(10),AER(10);
$REAL4 AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN);
"     CONSTRUCT THE INTERVAL COEFFICIENTS.                             "
"     XR SHOULD BE IN THE INTERVAL (XL,XH).  IF NOT IT WILL BE SE TO TH"
"     NEAREST LIMIT.  SUBINTERVALS WILL BE ARRANGED SO                 "
"     THAT XR IS ALWAYS ON A SUBINTERVAL BOUNDARY.   THE PURPOSE OF THI"
"     FEATURE IS TO MORE EASILY FIT FUNCTIONS WHICH HAVE AN INTERIOR   "
"     DISCONTINUITY IN SLOPE.  EXAMPLES ARE THE MOLLER AND PAIR        "
"     CROSS SECTIONS WHICH CONTRIBUTE DISCONTINUITIES IN SLOPE         "
"     TO THE ELECTRON AND PHOTON INTERACTION PROBABILITIES IN          "
"     THE INTERIOR OF THE ENERGY RANGES FOR THESE PARTICLES.           "
"     IN ABLE TO GIVE SOME VALUE FOR X'S WHICH MAY LIE SLIGHTLY OUTSIDE"
"     THE INTERVAL (XL,XH) AN EXTRA SUBINTERVAL ON EACH SIDE OF (XL,XH)"
"     IS PROVIDED, WHICH USED THE SAME STRAIGHT LINES AS THE ADJACENT  "
"     INCLUDED SUBINTERVAL.  NJ IS THE TOTAL NUMBER OF SUBINTERVALS    "
"     AND NI IS DEFINED TO BE THE NUMBER OF INTERNAL SUBINTERVALS=NJ-2."
"     NJP IS THE MINUMUM NUMBER OF POINTS INTERIOR TO THE INTERVAL     "
"     (XL,XH) AT WHICH THE FIT IS TO BE TESTED.  A NUMBER NIP WILL BE  "
"     CHOSEN AS THE NUMBER OF INTERIOR POINTS WITHIN EACH SUBINTERVAL  "
"     AT WHICH TO TEST SO THAT NIP*NI]=NJP.                        "
$REAL4    XS,XFL,XFH,XFS,XM,DX,W,XLL,SXFL,XSXF,SXFH,DSXF,WIP,
         SXFIP,XIP;
$INTEGER NI,NIP,ISUB,IFUN,JSUB,IP;
$INTEGER nkp;
DATA NKP/3/;
save nkp;
IF (XH.LE.XL)[
OUTPUT XL,XH;(' QFIT ERROR:XL SHOULD BE < XH. XL,XH=',2G14.6);
QFIT=.FALSE.; RETURN;]
XS=AMAX1(XL,AMIN1(XH,XR));
"     GET NUMBER OF INTERNAL SUBINTERVALS ARE ALLOWED AND CHECK        "
NI=NJ-2;
"     AT LEAST 2 SUBINTERVALS ARE NEEDED IF XR(XS) IS NOT AN END POINT."
IF (((XS.EQ.XL.OR.XS.EQ.XH).AND.NI.GE.1).OR.NI.GE.2) [XFL=XFUN(XL);]
ELSE [QFIT=.FALSE.; RETURN;]
XFH=XFUN(XH);
XFS=XFUN(XS);
"write(58,*)'xfh,xfs,xh,xs ',xfh,xfs,xh,xs;"
"     SET SUBINTERVAL WIDTH.                                           "
XM=AMAX1(XFH-XFS,XFS-XFL);
DX=XFH-XFL;
W=XM/AMAX1(1.,AINT(NI*XM/DX));
"write(58,*)' w,xm,ni,dx ',w,xm,ni,dx;"
"     RESET NI TO HOW MANY WE'RE ACTUALLY GOING TO USE.                "
NI=NI-AINT(NI-DX/W);
"     COMPUTE HOW MANY INTERIOR POINTS TO SAMPLE IN EACH SUBINTERVAL.  "
NIP=MAX0(NKP,(NJP+NI-1)/NI);
"     MAKE NIP ODD                                                     "
NIP=(NIP/2)*2+1;
"     SET ACTUAL LOWER LIMIT OF INTERVAL.                              "
IF (XFH-XFS.LE.XFS-XFL) [XLL=XFL;]
ELSE [XLL=XFH-NI*W;]
"     COEFICIENTS FOR USER TO COMPUTE WHICH SUBINTERVAL TO USE.        "
"     ISUBINT=AX*XFUN(X)+BX                                            "
AX=1./W;
BX=2.-XLL*AX;
"     THE RIGHT BOUNDARY OF SUBINTERVAL I IS XFI(XLL+W*(I-1))          "
"     NOW COMPUTE THE FIT COEFFICIENTS FOR THE SUBINTERVALS            "
"     AND FIND MAXIMUM RELATIVE ERROR(REM).                            "
REM=0.0;
QFIT=.TRUE.;
"     LOOP OVER SUBINTERVALS                                           "
"     INITIALIZE LOWER BOUNDARY AND VALUE.                             "
SXFL=AMAX1(XLL,XFL);
ISUB=0;
XSXF=XFI(SXFL);
"write(58,*)' 1 xsxf ',XSXF;"
CALL VFUNS(XSXF,FSXL);
IF (IPRN.NE.0) WRITE(6,:FMT:) ISUB,SXFL,XSXF,(FSXL(IFUN),IFUN=1,NFUN);
:FMT: FORMAT(' QFIT:ISUB,SXF,XSXF,FSX()=',I4,1P,9G11.4/(1X,12G11.4));
DO ISUB=1,NI[
"     ALLOW FOR EXTRA SUBINTERVAL OUTSIDE THE MAIN INTERVAL            "
JSUB=ISUB+1;
SXFH=AMIN1(XLL+W*ISUB,XH);
XSXF=XFI(SXFH);
"write(58,*)' 2 xsxf ',XSXF;"
CALL VFUNS(XSXF,FSXH);
IF (IPRN.NE.0)WRITE(6,:FMT:)ISUB,SXFH,XSXF,(FSXH(IFUN),IFUN=1,NFUN);
DSXF=SXFH-SXFL;
"write(58,*)' xll,w,isub,xh ',xll,w,isub,xh;"
"write(58,*)' dsxf,sxfh,sxfl ',dsxf,sxfh,sxfl;"
DO IFUN=1,NFUN[
AF(JSUB,IFUN)=(FSXH(IFUN)-FSXL(IFUN))/DSXF;
BF(JSUB,IFUN)=(FSXL(IFUN)*SXFH-FSXH(IFUN)*SXFL)/DSXF;] "END OF IFUN"
"     LOOP OVER INTERIOR POINTS TO LOOK FOR MAX. REL.ERROR             "
"     COMPUTE INTERIOR POINT SPACING.                                  "
WIP=DSXF/(NIP+1);
"write(58,*)' dsxf,nip ',dsxf,nip;"
DO IP=1,NIP[
"     VALUE OF XFUN AT THE INTERIOR POINT OF THIS SUBINTERVAL.         "
SXFIP=SXFL+IP*WIP;
XIP=XFI(SXFIP);
"write(58,*)' sxfl,ip,wip ',sxfl,ip,wip;"
"     COMPUTE FUNCTION AT INTERIOR POINT                               "
"write(58,*)' xip ',XIP;"
CALL VFUNS(XIP,FIP);
"     COMPUTE FITTED VALUES.                                           "
DO IFUN=1,NFUN[
FFIP(IFUN)=AF(JSUB,IFUN)*SXFIP+BF(JSUB,IFUN);
AFIP(IFUN)=ABS(FIP(IFUN));
AER(IFUN)=ABS(FFIP(IFUN)-FIP(IFUN));
RE(IFUN)=0.0;
IF (FIP(IFUN).NE.0.0) [RE(IFUN)=AER(IFUN)/AFIP(IFUN);]
IF (AFIP(IFUN).GE.ZTHR(IFUN)) [REM=AMAX1(REM,RE(IFUN));]
ELSEIF (AER(IFUN).GT.ZEP(IFUN)) [QFIT=.FALSE.;]
] "END OF IFUN"
"*****WRITE OUT SO WE CAN SEE HOW WE ARE DOING.                        "
IF (IPRN.NE.0) [
OUTPUT ISUB,IP,SXFIP,XIP,REM,QFIT,(FIP(IFUN),FFIP(IFUN),
 RE(IFUN),AER(IFUN),IFUN=1,NFUN);
(1X,2I4,1P,2G12.5,6P,F12.0,L2,1P,2G11.4,6P,F11.0,1P,G11.4/
 (1X,3(1P,2G11.4,6P,F11.0,1P,G11.4)));]
] "END OF IP"
"     SAVE RIGHT BOUNDARY AND VALUE FOR NEXT SUBINTERVAL.              "
SXFL=SXFH;
DO IFUN=1,NFUN [FSXL(IFUN)=FSXH(IFUN);]
] "END OF ISUB"
"     SET UP SKIRTING SUBINTERVALS(VIA EXTRAPOLATION)                  "
DO IFUN=1,NFUN[
AF(1,IFUN)=AF(2,IFUN);
BF(1,IFUN)=BF(2,IFUN);
AF(NI+2,IFUN)=AF(NI+1,IFUN);
BF(NI+2,IFUN)=BF(NI+1,IFUN);] "END OF IFUN"
QFIT=QFIT.AND.REM.LE.EP;
NJ=NI+2; "TELL ACTUAL NO. OF SUBINTERVALS USED."
"write(58,*)'ni ',ni;"
RETURN;
END; "END OF LOGICAL FUNCTION QFIT

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION QD(F,A,B,MSG);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

implicit none;
COMIN/EGS-IO/;
$REAL4    A,B,F;
EXTERNAL F;
CHARACTER*6 MSG;
logical first_time;
data first_time/.true./;
save first_time;

"    CHANGED"

"    REAL*8 DCADRE,ADUM,BDUM,ERRDUM,MSG;"

"    TO"

"    DOUBLE PRECISION DCADRE,ADUM,BDUM,ERRDUM;"
"    CHARACTER*6 MSG;"

"    FOR SUN COMPATIBILITY AFB 89/12/27"

"DOUBLE PRECISION DCADRE,ADUM,BDUM,ERRDUM;"
$REAL4 DCADRE,ADUM,BDUM,ERRDUM;
$INTEGER IER;

ADUM=A; BDUM=B;
QD=DCADRE(F,ADUM,BDUM,$AERR,$RERR,ERRDUM,IER);
"write(58,*)' qd ',QD;"
IF (IER.GT.66)[
    OUTPUT IER,MSG,A,B,QD,ERRDUM;
    (' DCADRE CODE=',I4,' FOR INTEGRAL ',A6,' FROM ',1P,G14.6,' TO ',G14.6,
    ',QD=',G14.6,'+-',G14.6);
]
RETURN;
END;  "END OF FUNCTION QD"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
"DOUBLE PRECISION FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER);"
$REAL4 FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER);
implicit none;
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"
"                                                                  "
"                                                                  "
"------------------------------------------------------------------"
"-DCADRE--------D-------LIBRARY 1----------------------------------"
"------------------------------------------------------------------"
"                                                                  "
"FUNCTION:          - INTEGRATE F(X) FROM A TO B, USING CAUTIOUS   "
"                     ADAPTIVE ROMBERG EXTRAPOLATION.              "
"                                                                  "
"USAGE:             - FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER)   "
"                                                                  "
"PARAMETERS: DCADRE - ESTIMATE OF THE INTEGRAL OF F(X) FROM A TO B."
"                                                                  "
"            F      - A SINGLE-ARGUMENT REAL FUNCTION SUBPROGRAM   "
"                     SUPPLIED BY THE USER.  F MUST BE DECLARED    "
"                     EXTERNAL IN THE CALLING PROGRAM.             "
"                                                                  "
"            A,B    - THE TWO ENDPOINTS OF THE INTERVAL OF         "
"                     INTEGRATION (INPUT).                         "
"                                                                  "
"            AERR   - DESIRED ABSOLUTE ERROR IN THE ANSWER (INPUT)."
"                                                                  "
"            RERR   - DESIRED RELATIVE ERROR IN THE ANSWER (INPUT)."
"                                                                  "
"            ERROR  - ESTIMATED BOUND ON THE ABSOLUTE ERROR OF     "
"                     THE OUTPUT NUMBER, DCADRE.                   "
"                                                                  "
"            IER    - ERROR PARAMETER                              "
"                                                                  "
"                     WARNING ERROR(WITH FIX) = 64 + N             "
"                                                                  "
"                       N = 1 IMPLIES THAT ONE OR MORE SINGULAR-   "
"                             ITIES WERE SUCCESSFULLY HANDLED.     "
"                                                                  "
"                       N = 2 IMPLIES THAT, IN SOME SUBINTERVAL(S),"
"                             THE ESTIMATE OF THE INTEGRAL WAS     "
"                             ACCEPTED MERELY BECAUSE THE ESTIMATED"
"                             ERROR WAS SMALL, EVEN THOUGH NO REG- "
"                             ULAR BEHAVIOR WAS RECOGNIZED.        "
"                                                                  "
"                     TERMINAL ERROR = 128 + N                     "
"                                                                  "
"                       N = 3 FAILURE DUE TO INSUFFICIENT INTERNAL "
"                             WORKING STORAGE.                     "
"                                                                  "
"                       N = 4 FAILURE.  THIS MAY BE DUE TO TOO MUCH"
"                             NOISE IN THE FUNCTION (RELATIVE TO   "
"                             THE GIVEN ERROR REQUIREMENTS) OR DUE "
"                             TO AN ILL-BEHAVED INTEGRAND.         "
"                                                                  "
"                       N = 5 INDICATES THAT RERR IS GREATER THAN  "
"                             0.1, OR RERR IS LESS THAN 0.0, OR    "
"                             RERR IS TOO SMALL FOR THE PRECISION  "
"                             OF THE MACHINE.                      "
"                                                                  "
"------------------------------------------------------------------"
"VERSION DATE:      - 8 OCTOBER 1974                               "
"                                                                  "
"MORTRAN VERSION    - 4 OCTOBER 1984/1545 (W. R. NELSON)           "
"------------------------------------------------------------------"
"                                                                  "
; "NOTE: SEMI-COLON TO CLEAR MORTRAN BUFFER                        "
"                                                                  "
"ADDED"
"EXTERNAL F;"
"FOR SUN AFB 89/12/27"

"EXTERNAL F;"

DIMENSION T(10,10),R(10),AIT(10),DIF(10),RN(4),TS(2049);
DIMENSION IBEGS(30),BEGIN(30),FINIS(30),EST(30);
DIMENSION REGLSV(30);
LOGICAL H2CONV,AITKEN,RIGHT,REGLAR,REGLSV;
/*
DOUBLE PRECISION T,R,AIT,DIF,RN,TS,BEGIN,FINIS,EST,AITLOW;
DOUBLE PRECISION H2TOL,AITTOL,LENGTH,JUMPTL,ZERO,P1,HALF,ONE;

"CHANGED"
"DOUBLE PRECISION TWO,FOUR,FOURP5,TEN,HUN,CADRE,F,ERROR,A,B;"
"TO"
"DOUBLE PRECISION TWO,FOUR,FOURP5,TEN,HUN,CADRE,ERROR,A,B;"
"FOR SUN AFB 89/12/27"

DOUBLE PRECISION TWO,FOUR,FOURP5,TEN,HUN,CADRE,ERROR,A,B;

DOUBLE PRECISION AERR,RERR,STEPMN,STEPNM,STAGE,CUREST,FNSIZE;
DOUBLE PRECISION PREVER,BEG,FBEG,END,FEND,STEP,ASTEP,TABS,HOVN;
DOUBLE PRECISION FN,SUM,SUMABS,ABSI,VINT,TABTLM,ERGL,ERGOAL;
DOUBLE PRECISION ERRA,ERRR,FEXTRP,ERRER,DIFF,SING,FEXTM1,ALG4O2;
DOUBLE PRECISION H2NXT,SINGNX,SLOPE,FBEG2,ALPHA;
DOUBLE PRECISION ERRET,H2TFEX,FI;
*/
$REAL4 T,R,AIT,DIF,RN,TS,BEGIN,FINIS,EST,AITLOW;
$REAL4 H2TOL,AITTOL,LENGTH,JUMPTL,ZERO,P1,HALF,ONE;
$REAL4 TWO,FOUR,FOURP5,TEN,HUN,CADRE,ERROR,A,B;
$REAL4 AERR,RERR,STEPMN,STEPNM,STAGE,CUREST,FNSIZE;
$REAL4 PREVER,BEG,FBEG,END,FEND,STEP,ASTEP,TABS,HOVN;
$REAL4 FN,SUM,SUMABS,ABSI,VINT,TABTLM,ERGL,ERGOAL;
$REAL4 ERRA,ERRR,FEXTRP,ERRER,DIFF,SING,FEXTM1,ALG4O2;
$REAL4 H2NXT,SINGNX,SLOPE,FBEG2,ALPHA;
$REAL4 ERRET,H2TFEX,FI;
"ADDED"
"REAL RVAL,F;"
"FOR SUN AFB 89/12/27"

$REAL4 RVAL,F;

$INTEGER IBEGS,IER,ISTAGE,IBEG,IEND,L,N,LM1,N2,ISTEP,II,III,I,ISTEP2,IT,NNLEFT;
$INTEGER MAXTS,MAXTBL,MXSTGE;
DATA AITLOW,H2TOL,AITTOL,JUMPTL,MAXTS,MAXTBL,MXSTGE/1.1D0,.15D0,
     .1D0,.01D0,2049,10,30/;
DATA RN(1),RN(2),RN(3),RN(4)/.7142005D0,.3466282D0,.843751D0,
     .1263305D0/;
DATA ZERO,P1,HALF,ONE,TWO,FOUR,FOURP5,TEN,HUN/0.0D0,0.1D0,0.5D0,
     1.0D0,2.0D0,4.0D0,4.5D0,10.0D0,100.0D0/;
save MAXTS,MAXTBL,MXSTGE;
ALG4O2=LOG10(TWO);
/CADRE,ERROR,CUREST,VINT/=ZERO;
IER=0;
LENGTH=ABS(B-A);
IF(LENGTH.EQ.ZERO) GO TO 215;
IF(RERR.GT.P1.OR.RERR.LT.ZERO) GO TO 210;
IF(AERR.EQ.ZERO.AND.(RERR+HUN).LE.HUN) GO TO 210;
ERRR=RERR;
ERRA=ABS(AERR);
STEPMN=(LENGTH/FLOAT(2**MXSTGE));
STEPNM=DMAX1(LENGTH,ABS(A),ABS(B))*TEN;
STAGE=HALF;
ISTAGE=1;
FNSIZE=ZERO;
PREVER=ZERO;
REGLAR=.FALSE.;
"                              THE GIVEN INTERVAL OF INTEGRATION   "
"                                IS THE FIRST INTERVAL CONSIDERED. "
BEG=A;

"CHANGED"
"FBEG=F(BEG)*HALF;"
"TO"
"RVAL=BEG;FBEG=F(RVAL)*HALF;"
"FOR SUN AFB 89/12/27"

RVAL=BEG;FBEG=F(RVAL)*HALF;
"write(*,*)' rval, f, half ',rval,F(RVAL),half;"

TS(1)=FBEG;
IBEG=1;
END=B;

"CHANGED"
"FEND=F(END)*HALF;"
"TO"
"RVAL=END;FEND=F(RVAL)*HALF;"
"FOR SUN AFB 89/12/27"

RVAL=END;FEND=F(RVAL)*HALF;

TS(2)=FEND;
IEND=2;
5 RIGHT=.FALSE.;
"                              INVESTIGATION OF A PARTICULAR       "
"                                SUBINTERVAL BEGINS AT THIS POINT. "
10 STEP=END - BEG;
ASTEP=ABS(STEP);
IF(ASTEP.LT.STEPMN) GO TO 205;
IF(STEPNM+ASTEP.EQ.STEPNM) GO TO 205;
T(1,1)=FBEG + FEND;
TABS=ABS(FBEG) + ABS(FEND);
L=1;
N=1;
H2CONV=.FALSE.;
AITKEN=.FALSE.;
15 LM1=L;
L=L + 1;
"                              CALCULATE THE NEXT TRAPEZOID SUM,   "
"                                T(L,1), WHICH IS BASED ON *N2* + 1"
"                                EQUISPACED POINTS. HERE,          "
"                                N2 = N*2 = 2**(L-1).              "
N2=N + N;
FN=N2;
ISTEP=(IEND - IBEG)/N;
IF(ISTEP.GT.1) GO TO 25;
II=IEND;
IEND=IEND + N;
IF(IEND.GT.MAXTS) GO TO 200;
HOVN=STEP/FN;
III=IEND;
FI=ONE;
DO I=1,N2,2[
TS(III)=TS(II);

"CHANGED"
"TS(III-1)=F(END - FI * HOVN);"
"TO"
"RVAL=END-FI*HOVN;TS(III-1)=F(RVAL);"
"FOR SUN AFB 89/12/27"

RVAL=END-FI*HOVN;TS(III-1)=F(RVAL);

FI=FI+TWO;
III=III-2;
II=II-1;]
ISTEP=2;
25 ISTEP2=IBEG + ISTEP/2;
SUM=ZERO;
SUMABS=ZERO;
DO I=ISTEP2,IEND,ISTEP[
SUM=SUM + TS(I);
SUMABS=SUMABS + ABS(TS(I));]
T(L,1)=T(L-1,1)*HALF+SUM/FN;
TABS=TABS*HALF+SUMABS/FN;
ABSI=ASTEP*TABS;
N=N2;
"                              GET PRELIMINARY VALUE FOR *VINT*    "
"                                FROM LAST TRAPEZOID SUM AND UPDATE"
"                                THE ERROR REQUIREMENT *ERGOAL*    "
"                                FOR THIS SUBINTERVAL.             "
IT=1;
VINT=STEP*T(L,1);
TABTLM=TABS*TEN;
FNSIZE=DMAX1(FNSIZE,ABS(T(L,1)));
ERGL=ASTEP*FNSIZE*TEN;
ERGOAL=STAGE*DMAX1(ERRA,ERRR*ABS(CUREST+VINT));
"                              COMPLETE ROW L AND COLUMN L OF *T*  "
"                                ARRAY.                            "
FEXTRP=ONE;
DO I=1,LM1[
FEXTRP=FEXTRP*FOUR;
T(I,L)=T(L,I) - T(L-1,I);
T(L,I+1)=T(L,I) + T(I,L)/(FEXTRP-ONE);]
ERRER=ASTEP*ABS(T(1,L));
"                              PRELIMINARY DECISION PROCEDURE      "
"                                IF L = 2 AND T(2,1) = T(1,1),     "
"                                GO TO 135 TO FOLLOW UP THE        "
"                                IMPRESSION THAT INTERGRAND IS     "
"                                STRAIGHT LINE.                    "
IF(L.GT.2) GO TO 40;
IF(TABS+P1*ABS(T(1,2)).EQ.TABS) GO TO 135;
GO TO 15;
"                              CACULATE NEXT RATIOS FOR            "
"                                COLUMNS 1,...,L-2 OF T-TABLE      "
"                                RATIO IS SET TO ZERO IF DIFFERENCE"
"                                IN LAST TWO ENTRIES OF COLUMN IS  "
"                                ABOUT ZERO                        "
40 DO 45 I=2,LM1;
DIFF=ZERO;
IF(TABTLM+ABS(T(I-1,L)).NE.TABTLM) DIFF=T(I-1,LM1)/T(I-1,L);
T(I-1,LM1)=DIFF;
45 CONTINUE;
IF(ABS(FOUR-T(1,LM1)).LE.H2TOL) GO TO 60;
IF(T(1,LM1).EQ.ZERO) GO TO 55;
IF(ABS(TWO-ABS(T(1,LM1))).LT.JUMPTL) GO TO 130;
IF(L.EQ.3) GO TO 15;
H2CONV=.FALSE.;
IF(ABS((T(1,LM1)-T(1,L-2))/T(1,LM1)).LE.AITTOL) GO TO 75;
50 IF(REGLAR) GO TO 55;
IF(L.EQ.4) GO TO 15;
55 IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 175;
GO TO 145;
"                              CAUTIOUS ROMBERG EXTRAPOLATION      "
60 IF(H2CONV) GO TO 65;
AITKEN=.FALSE.;
H2CONV=.TRUE.;
65 FEXTRP=FOUR;
70 IT=IT + 1;
VINT=STEP*T(L,IT);
ERRER=ABS(STEP/(FEXTRP-ONE)*T(IT-1,L));
IF(ERRER.LE.ERGOAL) GO TO 160;
IF(ERGL+ERRER.EQ.ERGL) GO TO 160;
IF(IT.EQ.LM1) GO TO 125;
IF(T(IT,LM1).EQ.ZERO) GO TO 70;
IF(T(IT,LM1).LE.FEXTRP) GO TO 125;
IF(ABS(T(IT,LM1)/FOUR-FEXTRP)/FEXTRP.LT.AITTOL)
FEXTRP=FEXTRP*FOUR;
GO TO 70;
"                              INTEGRAND MAY HAVE X**ALPHA TYPE    "
"                                SINGULARITY                       "
"                                RESULTING IN A RATIO OF *SING*  = "
"                                2**(ALPHA + 1)                    "
75 IF(T(1,LM1).LT.AITLOW) GO TO 175;
IF(AITKEN) GO TO 80;
H2CONV=.FALSE.;
AITKEN=.TRUE.;
80 FEXTRP=T(L-2,LM1);
IF(FEXTRP.GT.FOURP5) GO TO 65;
IF(FEXTRP.LT.AITLOW) GO TO 175;
IF(ABS(FEXTRP-T(L-3,LM1))/T(1,LM1).GT.H2TOL) GO TO 175;
SING=FEXTRP;
FEXTM1=ONE/(FEXTRP - ONE);
AIT(1)=ZERO;
DO 85 I=2,L;
AIT(I)=T(I,1) + (T(I,1)-T(I-1,1))*FEXTM1;
R(I)=T(1,I-1);
DIF(I)=AIT(I) - AIT(I-1);
85 CONTINUE;
IT=2;
90 VINT=STEP*AIT(L);
ERRER=ERRER*FEXTM1;
IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 95;
ALPHA=LOG10(SING)/ALG4O2 - ONE;
IER=MAX0(IER,65);
GO TO 160;
95 IT=IT + 1;
IF(IT.EQ.LM1) GO TO 125;
IF(IT.GT.3) GO TO 100;
H2NXT=FOUR;
SINGNX=SING+SING;
100 IF(H2NXT.LT.SINGNX) GO TO 105;
FEXTRP=SINGNX;
SINGNX=SINGNX+SINGNX;
GO TO 110;
105 FEXTRP=H2NXT;
H2NXT=FOUR*H2NXT;
110 DO 115 I=IT,LM1;
R(I+1)=ZERO;
IF(TABTLM+ABS(DIF(I+1)).NE.TABTLM) R(I+1)=DIF(I)/DIF(I+1);
115 CONTINUE;
H2TFEX=-H2TOL*FEXTRP;
IF(R(L)-FEXTRP.LT.H2TFEX) GO TO 125;
IF(R(L-1)-FEXTRP.LT.H2TFEX) GO TO 125;
ERRER=ASTEP*ABS(DIF(L));
FEXTM1=ONE/(FEXTRP - ONE);
DO 120 I=IT,L;
AIT(I)=AIT(I) + DIF(I)*FEXTM1;
DIF(I)=AIT(I) - AIT(I-1);
120 CONTINUE;
GO TO 90;
"                              CURRENT TRAPEZOID SUM AND RESULTING "
"                                EXTRAPOLATED VALUES DID NOT GIVE  "
"                                A SMALL ENOUGH *ERRER*.           "
"                                NOTE -- HAVING PREVER .LT. ERRER  "
"                                IS AN ALMOST CERTAIN SIGN OF      "
"                                BEGINNING TROUBLE WITH IN THE FUNC"
"                                TION VALUES. HENCE, A WATCH FOR,  "
"                                AND CONTROL OF, NOISE SHOULD      "
"                                BEGIN HERE.                       "
125 FEXTRP=DMAX1(PREVER/ERRER,AITLOW);
PREVER=ERRER;
IF(L.LT.5) GO TO 15;
IF(L-IT.GT.2.AND.ISTAGE.LT.MXSTGE) GO TO 170;
ERRET=ERRER/(FEXTRP**(MAXTBL-L));
IF(ERRET.GT.ERGOAL.AND.(ERGL+ERRET).NE.ERGL) GO TO 170;
GO TO 15;
"                              INTEGRAND HAS JUMP (SEE NOTES)      "
130 IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 170;
"                                NOTE THAT  2*FN=2**L              "
DIFF=ABS(T(1,L))*(FN+FN);
GO TO 160;
"                              INTEGRAND IS STRAIGHT LINE          "
"                                TEST THIS ASSUMPTION BY COMPARING "
"                                THE VALUE OF THE INTEGRAND AT     "
"                                FOUR *RANDOMLY CHOSEN* POINTS WITH"
"                                THE VALUE OF THE STRAIGHT LINE    "
"                                INTERPOLATING THE INTEGRAND AT THE"
"                                TWO END POINTS OF THE SUB-INTERVAL"
"                                IF TEST IS PASSED, ACCEPT *VINT*  "
135 SLOPE=(FEND-FBEG)*TWO;
FBEG2=FBEG+FBEG;
DO 140 I=1,4;

"CHANGED"
"DIFF=ABS(F(BEG+RN(I)*STEP) - FBEG2-RN(I)*SLOPE);"
"TO"
"RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);"
"FOR SUN AFB 89/12/27"

RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);

IF(TABTLM+DIFF.NE.TABTLM) GO TO 155;
140 CONTINUE;
GO TO 160;
"                              NOISE MAY BE DOMINANT FEATURE       "
"                                ESTIMATE NOISE LEVEL BY COMPARING "
"                                THE VALUE OF THE INTEGRAND AT     "
"                                FOUR *RANDOMLY CHOSEN* POINTS WITH"
"                                THE VALUE OF THE STRAIGHT LINE    "
"                                INTERPOLATING THE INTEGRAND AT THE"
"                                TWO ENDPOINTS. IF SMALL ENOUGH,   "
"                                ACCEPT *VINT*                     "
145 SLOPE=(FEND-FBEG)*TWO;
FBEG2=FBEG+FBEG;
I=1;

"CHANGED"
"150 DIFF=ABS(F(BEG+RN(I)*STEP) - FBEG2-RN(I)*SLOPE);"
"TO"
"150 RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);"
"FOR SUN AFB 89/12/27"

150 RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);

155 ERRER=DMAX1(ERRER,ASTEP*DIFF);
IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 175;
I=I+1;
IF(I.LE.4) GO TO 150;
IER=66;
"                              INTERGRATION OVER CURRENT SUB-      "
"                                INTERVAL SUCCESSFUL               "
"                                ADD *VINT* TO *DCADRE* AND *ERRER*"
"                                TO *ERROR*, THEN SET UP NEXT SUB- "
"                                INTERVAL, IF ANY.                 "
160 CADRE=CADRE + VINT;
ERROR=ERROR + ERRER;
IF(RIGHT) GO TO 165;
ISTAGE=ISTAGE - 1;
IF(ISTAGE.EQ.0) GO TO 220;
REGLAR=REGLSV(ISTAGE);
BEG=BEGIN(ISTAGE);
END=FINIS(ISTAGE);
CUREST=CUREST - EST(ISTAGE+1) + VINT;
IEND=IBEG - 1;
FEND=TS(IEND);
IBEG=IBEGS(ISTAGE);
GO TO 180;
165 CUREST=CUREST + VINT;
STAGE=STAGE+STAGE;
IEND=IBEG;
IBEG=IBEGS(ISTAGE);
END=BEG;
BEG=BEGIN(ISTAGE);
FEND=FBEG;
FBEG=TS(IBEG);
GO TO 5;
"                              INTEGRATION OVER CURRENT SUBINTERVAL"
"                                IS UNSUCCESSFUL. MARK SUBINTERVAL "
"                                FOR FURTHER SUBDIVISION. SET UP   "
"                                NEXT SUBINTERVAL.                 "
170 REGLAR=.TRUE.;
175 IF(ISTAGE.EQ.MXSTGE) GO TO 205;
IF(RIGHT) GO TO 185;
REGLSV(ISTAGE+1)=REGLAR;
BEGIN(ISTAGE)=BEG;
IBEGS(ISTAGE)=IBEG;
STAGE=STAGE*HALF;
180 RIGHT=.TRUE.;
BEG=(BEG+END)*HALF;
IBEG=(IBEG+IEND)/2;
TS(IBEG)=TS(IBEG)*HALF;
FBEG=TS(IBEG);
GO TO 10;
185 NNLEFT=IBEG - IBEGS(ISTAGE);
IF(IEND+NNLEFT.GE.MAXTS) GO TO 200;
III=IBEGS(ISTAGE);
II=IEND;
DO 190 I=III,IBEG;
II=II + 1;
TS(II)=TS(I);
190 CONTINUE;
DO 195 I=IBEG,II;
TS(III)=TS(I);
III=III + 1;
195 CONTINUE;
IEND=IEND + 1;
IBEG=IEND - NNLEFT;
FEND=FBEG;
FBEG=TS(IBEG);
FINIS(ISTAGE)=END;
END=BEG;
BEG=BEGIN(ISTAGE);
BEGIN(ISTAGE)=END;
REGLSV(ISTAGE)=REGLAR;
ISTAGE=ISTAGE + 1;
REGLAR=REGLSV(ISTAGE);
EST(ISTAGE)=VINT;
CUREST=CUREST + EST(ISTAGE);
GO TO 5;
"                              FAILURE TO HANDLE GIVEN INTEGRA-    "
"                                TION PROBLEM                      "
200 IER=131;
GO TO 215;
205 IER=132;
GO TO 215;
210 IER=133;
215 CADRE=CUREST + VINT;
220 DCADRE=CADRE;
9000 CONTINUE;
9005 RETURN;
END;  "END OF FUNCTION DCADRE"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
SUBROUTINE SPINIT(density_file);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"
;
implicit none;

COMIN/PMCONS,SPCOMM,DERCON,MOLVAR,BREMPRP,ELEMTB,LSPION,EPSTAR,THRESHP,
EGS-IO,MIXDAT,MISC/;

$REAL4 IMEV;
" IK: Variable declarations for implicit none"
$INTEGER IM,J,IZ,IE,I,ICHECK,IESPEL,IPEGEL,density_unit,lnblnk1,egs_get_unit;
$REAL4    VPLASM,ALIADG,EDENL,ALGASP,EPSTRH,
         TLRNCE,EPSTWT;
CHARACTER*256 density_file;

TOLN10=2.0*LOG(10.0);IM=-100;

IF(EPSTFLP < 0 | EPSTFLP > 1) [
        EPSTFLP = 0;
]
"ABOVE IS NRCC MOD DEC 1988"

IF(EPSTFLP=0)["DEFAULT TO STANDARD PEGS4 METHODS"

"MATERIAL MUST BE FOUND IN THE SSB TABLE OR THE S-P"
"      GENERAL FORMULA WILL BE USED.

"CHECK TO SEE IF MATERIAL IS A 'STERNHEIMER-SELTZER-BERGER' (SSB)"
"MATERIAL, FOR WHICH THE DENSITY EFFECT PARAMETERS ARE ALREADY"
"SPECIFIED.  IF IT IS NOT, THEN CALCULATE THEM USING THE GENERAL"
"FORMULA BY STERNHEIMER-PEIERLS (S-P)."

"STERNHEIMER-SELTZER-BERGER (SSB) LOOKUP TABLE SECTION:"
:TRY: DO IM=1,NUMSTMED [DO J=1,LMED
[IF (IDSTRN(J).NE.MEDTBL(J,IM)) NEXT :TRY:;]
"CALCULATION FOLLOWS IF A MATCH IS FOUND"
AFACT=STDATA(1,IM); SK=STDATA(2,IM); X0=STDATA(3,IM);
X1=STDATA(4,IM); IEV=STDATA(5,IM); CBAR=STDATA(6,IM);
IMEV=IEV*1.0E-6; "EV TO MEV"
VPLASM=SQRT(EDEN*R0*C**2/PIP);
GO TO :SSB-PARAMETERS-DEFINED:;]

"STERNHEIMER-PEIERLS (S-P) GENERAL FORMULA SECTION:"
IM=0;
"DETERMINE THE MEAN EXCITATION ENERGY, IMEV (IN MEV)"
IF (NEP.EQ.1) ["ELEMENT"
IZ=ZELEMP(1);
IF (IZ.EQ.1.OR.IZ.EQ.7.OR.IZ.EQ.8) ["I.E., DIATOMIC MOLECULE"
OUTPUT ; (' STOPPED IN SUBROUTINE SPINIT BECAUSE THIS',/,
 ' ELEMENT (H, N, OR O) CAN ONLY EXIST AS A DIATOMIC MOLECULE.',/,
 ' REMEDY:  USE COMP OPTION FOR H2, N2, OR O2 WITH NE=2,PZ=1,1'/,
 '          AND, IN THE CASE OF A GAS, DEFINE STERNHEIMER ID',/,
 '          (I.E., IDSTRN) LIKE H2-GAS');
$CALL_EXIT(21);]
IEV=ITBL(IZ);     "EV"
]

ELSE ["COMPOUND/MIXTURE---USE BRAGG ADDITIVITY RULE"
ALIADG=0.0;
DO IE=1,NEP [
IZ=ZELEMP(IE);
IF (IZ.EQ.1) [IEV=19.2;]   "EV"
ELSEIF (IZ.EQ.6) [IF (GASPP.EQ.0.0) [IEV=81.0;] ELSE [IEV=70.0;]]
ELSEIF (IZ.EQ.7) [IEV=82.0;]
ELSEIF (IZ.EQ.8) [IF (GASPP.EQ.0.0) [IEV=106.0;] ELSE [IEV=97.0;]]
ELSEIF (IZ.EQ.9) [IEV=112.0;]
ELSEIF (IZ.EQ.17) [IEV=180.0;]
ELSE [IEV=1.13*ITBL(IZ);]
"NRCC comment - above 7 lines reflect table 6 in ref 59 of SLAC-265"
"       Berger and Seltzer's fudge to get better agreement with expt"
ALIADG=ALIADG + PZP(IE)*ZELEMP(IE)*LOG(IEV);
]
ALIADG=ALIADG/ZC;
IEV=EXP(ALIADG);    "EV"
]

IMEV=IEV*1.0E-6;  "EV TO MEV"
"COMPUTE VARIOUS STERNHEIMER CONSTANTS"
IF (GASPP.EQ.0.0) [EDENL=EDEN;]
ELSE ["VPLASM MUST BE FOR NTP FOR A GAS, AND EDEN HAS"
"      BEEN DEFINED IN MIX FOR THE ACTUAL PRESSURE"
       EDENL=EDEN/GASPP;]
VPLASM = SQRT(EDENL*R0*C**2/PIP);
"ABOVE PATCHED JAN 9,1989 TO REFLECT ERROR POINTED OUT BY"
"PROF KAMAE, TOKYO UNIVERSITY, VIA HIDEO HIRAYAMA"

CBAR=1. + 2.*LOG(IMEV/(HBAR*2*PIP*VPLASM/ERGMEV));

IF (NEP.EQ.1.AND.INT(ZELEMP(1)).EQ.2.AND.GASPP.NE.0.0)[
          "SPECIAL HE(GAS) CASE"
X0=2.191; X1=3.0; SK=3.297;
]

ELSEIF (NEP.EQ.2.AND.INT(ZELEMP(1)).EQ.1
        .AND.INT(ZELEMP(2)).EQ.1) [
IF (GASPP.EQ.0.0) ["SPECIAL H2(LIQUID) CASE"
X0=0.425; X1=2.0; SK=5.949;
]
ELSE ["SPECIAL H2(GAS) CASE"
X0=1.837; X1=3.0; SK=4.754;
]
]

ELSE ["REGULAR CASES"
SK=3.0;
IF (GASPP.EQ.0.0) ["SOLIDS AND LIQUIDS"
IF (IEV.LT.100.0) [
IF (CBAR.LT.3.681) [X0=0.2; X1=2.0;]
ELSE [X0=0.326*CBAR - 1.0; X1=2.0;]
]
ELSE ["IEV GE 100.0"
IF (CBAR.LT.5.215) [X0=0.2; X1=3.0;]
ELSE [X0=0.326*CBAR - 1.5; X1=3.0;]
]
IF (X0.GE.X1) [OUTPUT X0,X1,CBAR;
(' STOPPED IN SPINIT DUE TO X0.GE.X1 , X0,X1,CBAR=',3G15.5,/
,' IF THIS IS GAS, YOU MUST DEFINE GASP(ATM)'); $CALL_EXIT(21);]
]
ELSE ["GASES---AT NTP AT THIS STAGE"
IF (CBAR.LT.10.0) [X0=1.6; X1=4.0;]
ELSEIF (CBAR.LT.10.5) [X0=1.7; X1=4.0;]
ELSEIF (CBAR.LT.11.0) [X0=1.8; X1=4.0;]
ELSEIF (CBAR.LT.11.5) [X0=1.9; X1=4.0;]
ELSEIF (CBAR.LT.12.25) [X0=2.0; X1=4.0;]
ELSEIF (CBAR.LT.13.804) [X0=2.0; X1=5.0;]
ELSE [X0=0.326*CBAR - 2.5; X1=5.0;]
]
]  "END OF STERNHEIMER-PEIERLS (S-P) GENERAL FORMULA SECTION"

:SSB-PARAMETERS-DEFINED:

"GAS PRESSURE CORRECTION COMES NEXT"
IF (GASPP.NE.0.0) [
ALGASP=LOG(GASPP);
CBAR=CBAR - ALGASP;
X0=X0 - ALGASP/TOLN10;
X1=X1 - ALGASP/TOLN10;
]

IF (IM.EQ.0) [AFACT=(CBAR - TOLN10*X0)/(X1 - X0)**SK;]
]"END OF EPSTFL=0 BLOCK"

ELSE[ "EPSTFL=1 BLOCK  I.E. READ IN THE INPUT FROM THE DENSITY"
     "INPUT FILE"
"get the name of the density file"
density_file=$cstring(density_file);
density_unit=20;
density_unit=egs_get_unit(density_unit);
IF( density_unit < 1 ) [
        $egs_fatal(*,'SPINIT: failed to get a free fortran unit');
]
open(density_unit,file=density_file,status='old',err=:no_density_file:);

READ(density_unit,:A:)EPSTTL;:A:  FORMAT(A);
READ(density_unit,*) NEPST,IEV,EPSTRH,NELEPS;
READ(density_unit,*) (ZEPST(I),WEPST(I),I=1,NELEPS);
READ(density_unit,*) (EPSTEN(I),EPSTD(I),I=1,NEPST);

close(density_unit);

IF(NEPST>150)[OUTPUT NEPST;
(//' *****NEPST=',I4,' IS GREATER THAN THE 150 ALLOWED');$CALL_EXIT(22);]
"CONVERT TO TOTAL ENERGIES"
DO I=1,NEPST[EPSTEN(I) = EPSTEN(I) + RMP;]
IMEV = IEV*1.E-06;

"CHECK THAT WE HAVE COVERED ENERGY RANGES NEEDED"
IF( AEP < EPSTEN(1))[OUTPUT EPSTEN(1),AEP;
(//' ****LOWEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,E10.3/
T20,'WHICH IS HIGHER THAN THE VALUE OF AE=',1P,E10.3,' MEV'/
' ***IT HAS BEEN SET TO AE***'//);EPSTEN(1) = AEP;]
IF( UEP > EPSTEN(NEPST))[ OUTPUT EPSTEN(NEPST),UEP;
(//' ****HIGHEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,E10.3/
T20,'WHICH IS LOWER THAN THE VALUE OF UE=',1P,E10.3,' MEV'/
' ***IT HAS BEEN SET TO UE***'//);EPSTEN(NEPST) = UEP;]

"DO A CHECK ON THE COMPOSITION AND DENSITY TO INSURE THE RIGHT DELTA"
"HAS BEEN PICKED UP. ALLOW A TOLERANCE OF 1 PERCENT ERROR ON THE"
"COMPOSITION BY WEIGHT."

ICHECK=0; "FLAG GETS SET TO UNITY IF THE COMPOSITION DOES NOT MATCH"
    TLRNCE=0.01; "TOLERANCE ALLOWED ON FRACTION BY WEIGHT"

"FIRST CHECK THAT THE NUMBER OF ELEMENTS ARE THE SAME"
IF(NELEPS.NE.NEP) ICHECK=1;

"NOW CHECK THAT THE DENSITIES ARE THE SAME WITHIN TOLERANCE"
IF( (ICHECK.EQ.0)  .AND.
  ( (EPSTRH.LT.((1.0-TLRNCE)*RHOP)) .OR.
    (EPSTRH.GT.((1.0+TLRNCE)*RHOP))
  ) ) ICHECK=1; "DENSITY IS OUT OF RANGE"
"WE MUST FIRST NORMALIZE THE PEGS FRACTIONS BY WEIGHT TO ENSURE THEY"
"ARE NORMALIZED TO UNITY"
EPSTWT = 0.0;DO I=1,NEP[ EPSTWT = EPSTWT + RHOZP(I);]
IF(EPSTWT=0.0)[
OUTPUT;(//' *****IN SPINIT***SOMETHING WRONG, MOLECULAR WEIGHT OF',
'MOLECULE IS ZERO (I.E. SUM OF RHOZ)***'//);]

IF(ICHECK.EQ.0)[
    IESPEL=0;    "INITIALIZE ESP ELEMENT COUNTER"
    ICHECK=1;    "ASSUME FAILURE"
    LOOP["LOOP OVER ESP COMPONENTS"
        IESPEL=IESPEL+1;
        IPEGEL=0;    "INITIALIZE PEGS ELEMENT COUNTER"
        LOOP["LOOP OVER PEGS COMPONENTS"
            IPEGEL=IPEGEL+1;
            IF(INT(ZELEMP(IPEGEL)).EQ.ZEPST(IESPEL))[ICHECK=0;EXIT;]
            ]WHILE(IPEGEL.LT.NEP);
            IF( (ICHECK.EQ.0) "Z OF ELEMENT MATCHES"
            .AND.
            ( (WEPST(IESPEL).LT.((1.0-TLRNCE)*RHOZP(IPEGEL)/EPSTWT))
             .OR. (WEPST(IESPEL).GT.((1.0+TLRNCE)*RHOZP(IPEGEL)/EPSTWT))
            ) ) ICHECK=1; "MATCHED ELEMENT BUT WEIGHT FRACTION WRONG"
        ]WHILE(IESPEL.LT.NELEPS);
    ] "END OF TEST FOR ICHECK = 0"

IF(ICHECK.EQ.1)[ "PRINT MESSAGE AND STOP"
OUTPUT;
(////'0*** COMPOSITION IN INPUT DENSITY FILE DOES NOT MATCH ',
' THAT BEING USED BY PEGS'//' ***** QUITTING EARLY***'////);
$CALL_EXIT(23); " ERRORS DETECTED";
]


]"END OF EPSTFL=1 BLOCK"


SPC1=2.*PIP*R0**2*RMP*EDEN*RLCP;
SPC2=LOG((IMEV/RMP)**2/2.0);
/*
OUTPUT;(//' PARAMETERS COMPUTED IN SPINIT.'//1X,64('-'));
IF(IM.EQ.0) [OUTPUT ;
(' STERNHEIMER-PEIERLS GENERAL FORMULA USED FOR THE DENSITY EFFECT,');]
ELSEIF(IM.GT.0) [OUTPUT;
(' STERNHEIMER-SELTZER-BERGER TABLE USED FOR DENSITY EFFECT');]
ELSEIF(IM = -1) [OUTPUT;
(' STERNHEIMER-SELTZER-BERGER DENSITY EFFECT DATA SUPPLIED BY USER');]
ELSE[
OUTPUT EPSTTL;(' DENSITY EFFECT READ IN DIRECTLY:'/T10,A);]
OUTPUT;(1X,64('-')/);
OUTPUT IEV;(/' ADJUSTED MEAN IONIZATION = ',F8.2,' EV'/1X,38('-')//);
IF(EPSTFLP = 0) [
  write(i_log,*)' IEV,VPLASM,CBAR,X0,X1,SK,AFACT= ',
        IEV,VPLASM,CBAR,X0,X1,SK,AFACT;
]
*/
"$DUMP SPC1,SPC2;"

RETURN;
:no_density_file:
$egs_fatal(*,' Failed to open density file ',density_file);
RETURN;
END;  "END OF SUBROUTINE SPINIT"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
SUBROUTINE MIX;
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"
;

implicit none;

" IK: Variable declarations for implicit none"
$INTEGER I,IZZ;
$REAL4    AL183,ZAB,V2000;

" IK: Function declarations for implicit none"
$REAL4 FCOULCP,XSIFP;

COMIN/MIMSD,MIXDAT,MOLVAR,PMCONS,DERCON,RADLEN,BREMPRP/;
$REAL4 XSI(20),ZZX(20),FZC(20),FCOUL(20),ZZ(20);
" MOLVAR - - MOLECULAR VARIABLES NEEDED BY DIFFER, AND MOLIER      "

" THE FOLLOWING ASSUMES THAT THE MATERIAL BEING DEALT WITH         "
" IS EITHER A COMPOUND, OR A HOMOGENEOUS MIXTURE.                  "
"          MOLECULAR VARIABLES                                     "
" NE       NUMBER OF DIFFERENT TYPES OF ATOMS IN THE MATERIAL.     "
" PZ(I)    PROPORTION OF ELEMENT OF TYPE I.  IF A COUMPOUND,       "
" THEN PZ(I) WILL BE THE NUMBER OF ATOMS OF TYPE I IN THE MOLECULE."
" IF A MIXTURE,SUCH AS CONCRETE, PZ(I) COULD BE THE PER CENT OF    "
" THE ATOMS WHICH ARE OF TYPE I.                                   "
" Z(I)     PERIODIC NUMBER OF ATOMS OF TYPE I                      "
" WA(I)    ATOMIC WEIGHT FOR ATOMS OF TYPE I.                      "
" WM = SUM(PZ(I)*WA(I)) = MOLECULAR  WEIGHT IF A COUMPOUND         "
" OR A 'MIXTURE WEIGHT' IF A MIXTURE.                              "
" RHO      DENSITY OF THE MATERIAL. (IN GRAMS/CM**3)               "
" RHOZ(I)  PARTIAL DENSITY DUE TO ATOMS OF TYPE I. (GM/CM**3)      "
"          ELECTRON DENSITY VARIABLE                               "
" ZC = SUM(PZ(I)*Z(I)) = NUMBER OF ELECTRONS/MOLECULE              "
"          BREMSSTRAHLUNG AND PAIR PRODUCTION VARIABLES ARE WEIGHTE"
" BY PZ(I)*Z(I)**2 FOR THE NUCLEUS, AND BY PZ(I)*Z(I)*XSI(I) FOR   "
" ATOMIC ELECTRONS.                                                "
" TPZ = SUM(PZ(I))                                                 "
" XSI(I) = LOG(A1440/Z(I)**(2./3.))/(LOG(A183/Z(I)**(1./3.))  -    "
"               FCOUL(Z(I)) )                                      "
" ZZX(I) =  PZ(I)*Z(I)*(Z(I)+XSI(I)) = BREMS AND PAAR WEIGHTS      "
" EZ = ZC/TPZ  EFFECTIVE Z                                         "
" ZT = SUM(ZZX(I))                                                 "
" ZA = LOG(A183)*ZT   BUTCHER AND MESSELS L.C.'A' (1960)P.18       "
" ZB = SUM(ZZX(I)*LOG(Z(I)**(-1./3.)  B&M'S L.C.'B' IBID.          "
" ZF = SUM(ZZX(I)*FCOUL(Z(I))),WHERE FCOUL IS THE COULOMB          "
" CORRECTION FUNCTION.                                             "
" RATIOS--                                                         "
" ZG = ZB/ZT ,EXP(ZG)=WEIGHTED GEOMETRIC MEAN OF Z**(-1/3)         "
" ZP = ZB/ZA , B&M IBID.P18 L.C.'P'                                "
" ZV= (ZB-ZF)/ZT                                                   "
" ZU = (ZB-ZF)/ZA                                                  "
"          MULTIPLE SCATTERING VARIABLES                           "
" ACCORDING TO MESSEL AND CRAWFORD(1970), MOST OF THE MULTIPLE     "
" SCATTERING DUE TO THE FIELD OF THE ATOMIC ELECTRONS IS ALREADY   "
" ACCOUNTED FOR BY THE DISCRETE MOLLER SCATTERING. HENCE,THE       "
" FOLLOWING VARIABLES ARE ONLY WEIGHTED BY PZ(I)*Z(I)**2           "
" HOWEVER I HAVE NOT JUSTIFIED THE ABOVE ASSERTION THEORETICALLY   "
" THEORETICALLY, AND COMPARISON OF EXPERIMENTS WITH EGS HAVE       "
" SHOWN EGS PHOTON SPECTRUM DEFICIENT IN THE BACKWARD DIRECTION.   "
" THEREFORE, I WILL EXPERIMENT WITH RESTORING THE ELECTRON SCATTER-"
" ING TERM.  ITS CONTRIBUTION WILL BE REPRESENTED BY THE MACRO VAR-"
" IABLE, $FUDGEMS, WHICH WILL HAVE THE VALUE 0.0 FOR NO ELECTRON   "
" SCATTERING AND 1.0 FOR FULL ELECTRON SCATTERING.  AND WE NOW HAVE"
" WEIGHTING BY PZ(I)*Z(I)*(Z(I)+$FUDGEMS).                         "
" ZZ(I) = PZ(I)*Z(I)*(Z(I)+$FUDGEMS) "
" ZS = SUM(ZZ(I))                                                  "
" ZE = SUM(ZZ(I)*LOG(Z(I)**(-2./3.)))                              "
" ZX = SUM(ZZ(I)*LOG(1.+3.34*(FSC*Z(I))**2))                       "
"               ELECTON DENSITY(ELECTRONS/CM**3)                   "
" EDEN=AN*RHO/WM*ZC                                                "
"          RADIATION LENGTH                                        "
" USEFUL FOR GAUGING THE STEP SIZE, EVEN IF IT IS NOT USED AS THE  "
" UNIT OF DISTANCE.                                                "
"  1./RLC =(AN*RHO/WM)*4.0*FSC*R0**2*                              "
"    SUM( Z(I)*(Z(I)+XSI(I))*(LOG(A183*Z(I)**(-1./3.)-FCOUL(Z(I))) "
"        =(AN*RHO/WM)*4.*FSC*R0**2*(ZAB-ZF)                        "
" INPUT MOLECULAR VARIABLES AND COMPUTE Z-RELATED PARAMETERS       "
/*
OUTPUT ; (/' IN SUBROUTINE MIX: '/);
IF (GASPP.EQ.0.0) [OUTPUT NEP,RHOP;
(' NUMBER OF ELEMENTS = ',I3,',  DENSITY=',1P,G15.6,' (G/CM**3)');]
ELSE [OUTPUT NEP,RHOP,GASPP;
(' NUMBER OF ELEMENTS = ',I3,',  DENSITY=',1P,G15.6,' (G/CM**3) AT NTP',
 '  GAS PRESSURE=',1P,G15.6,' ATM.');]
OUTPUT (I,ZELEMP(I),WAP(I),PZP(I),RHOZP(I),
I=1,NEP);
('0  I       Z(I)           WA(I)          PZ(I)         RHOZ(I) '/
' INDEX   PERIODIC        ATOMIC       PROPORTION     PROPORTION '/
'          NUMBER         WEIGHT        BY NUMBER      BY WEIGHT '//
(I5,1P,4G15.6));
*/
"SCALE RHO FOR GASES BY THE GAS PRESSURE"
IF (GASPP.NE.0.0) [RHOP=GASPP*RHOP;]
"     FIND VARIOUS SUMS AND SET OTHER VARIABLES                        "
AL183 = LOG(A183);
/TPZ,WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZAB/=0.0;
DO I=1,NEP[
TPZ = TPZ + PZP(I);
WM = WM + PZP(I)*WAP(I);
ZC = ZC + PZP(I)*ZELEMP(I);
FZC(I) =(FSC*ZELEMP(I))**2;
FCOUL(I) = FCOULCP(ZELEMP(I));
XSI(I) = XSIFP (ZELEMP(I));
ZZX(I) = PZP(I)*ZELEMP(I)*(ZELEMP(I)+XSI(I));
IF (ZELEMP(I).LE.4.0) [IZZ=ZELEMP(I);
ZAB=ZAB+ZZX(I)*ALRAD(IZZ);] "IN THE CASE OF Z.LE.4 "
ELSE [ZAB=ZAB+ZZX(I)*(AL183+LOG(ZELEMP(I)**(-1./3.)));] "Z.GT.4"
ZT = ZT + ZZX(I);
ZB = ZB + ZZX(I)*LOG(ZELEMP(I)**(-1./3.));
ZF = ZF + ZZX(I)*FCOUL(I);
ZZ(I) = PZP(I)*ZELEMP(I)*(ZELEMP(I)+$FUDGEMS);
ZS = ZS + ZZ(I);
ZE = ZE + ZZ(I)*((-2./3.)*LOG(ZELEMP(I)));
ZX = ZX + ZZ(I)*LOG(1.+3.34*FZC(I));
]
"END OF I LOOP"
EZ = ZC/TPZ;
ZA = AL183*ZT;
ZG = ZB/ZT;
ZP = ZB/ZA;
ZV = (ZB-ZF)/ZT;
ZU = (ZB-ZF)/ZA;
EDEN=AN*RHOP/WM*ZC;
RLCP = 1./( (AN*RHOP/WM)*4.0*FSC*R0**2*(ZAB-ZF) );
/*
OUTPUT WM,ZC,ZT,ZA,ZB,ZAB,ZF,ZG,ZP,ZV,ZU,ZS,ZE,ZX,RLCP,
 (I,XSI(I),ZZX(I),FZC(I),FCOUL(I),ZZ(I),I=1,NEP);
('0Z VARIABLES--WM,ZC,ZT,ZA,ZB,ZAB'/1P,6E14.6/
 '0ZF,ZG,ZP,ZV,ZU,ZS'/1P,6E14.6/'0ZE,ZX,RLC'/1P,3E14.6/
'0(I,XSI,ZZX,FZC,FCOUL,ZZ,I=1,NE)'/
 (I5,1P,5E14.6));
*/
"$DUMP EDEN;"

"NOW COMPUTE MATERIAL-DEPENDENT CONSTANTS FOR MULTIPLE SCATTERING"
"LET B BE MOLIERE'S UPPER CASE B, AND LET BLC BE MOLIERE'S LOWER CASE B"
"THEN USING SCOTT'S NOTATION, A MEASURE OF THE NUMBER OF SCATTERS IS"
"OMEGA0=EXP(BLC).  NOW B AND BLC ARE RELATED BY"
"BLC=B-ALOG(B);, OR EXP(BLC)=EXP(B)/B; "
"NOW LET T BE THE TRANSPORT DISTANCE IN RL. THEN,"
"OMEGA0=EXP(BLC)"
"      =( A6680*RHO*ZS*EXP(ZE/ZS)*RLC/(WM*EXP(ZX/ZS)) )*T/BETA**2"
"WHERE BETA IS V/C FOR THE PARTICLE"
"NOW SUPPOSE THAT XC IS CHI-SUB-C, THE CHARACTERISTIC ANGLE OF"
"MOLIERE'S THEORY.  THEN IT IS GIVEN BY"
"XC= (A22P9/RADDEG)*SQRT( ZS*RHO*RLC/WM ) * SQRT(T) /(E*BETA**2) "
" WHERE E IS THE ENERGY OF THE PARTICLE IN MEV."
"NOW IN MOLIERE'S THEORY, LET XRM BE XC*SQRT(B).  THEN"
" (MOLIERE'S REDUCE ANGLE)=(REAL ANGLE)/XRM."
"FOR THE VARIABLE SAMPLING DONE IN EGS, A DIFFERENT REDUCED"
"ANGLE IS USED:"
" (REDUCED ANGLE FOR VARIABLE SAMPLING)=(REAL ANGLE)/XRV "
" WHERE NOW XRV=XC*SQRT(BLC)."
"THIS IS DONE BECAUSE BLC IS MORE SIMPLY RELATED TO THE TRANSPORT"
"DISTANCE THAN IS B."

"WITH THIS BACKGROUND WE NOW PROCEED TO COMPUTE"
"XR0, TEFF0, BLCC, AND XCC, WHICH ARE PARAMETERS NEEDED IN EGS"
"THESE PARAMETERS ARE USED AS FOLLOWS:(IN OUR NOTATION)"
"XRM=XR0*SQRT(T*B/(T0*BMIN))/(E*BETA) "
"  WHERE B IS EVALUATED FOR DISTANCE T, AND T0 IS THE"
"  DISTANCE THAT WOULD GIVE B=BMIN. T0 IS A FUNCTION OF BETA, AND"
"  IS GIVEN BY THE EXPRESSION  "
"T0=TEFF0*BETA**2;  THIS IS ALSO THE DEFINING RELATION FOR TEFF0"
"BMIN IS THE MINIMUM VALUE OF B FOR WHICH MOLIERE CONSIDERED HIS THEORY"
"VALID.  WE CURRENTLY GIVE BMIN A VALUE OF 4.5."
"OMEGA0=BLCC*T/BETA**2  IS THE USEAGE OF BLCC"
"XRV= XCC*SQRT( T*BLC )/(E*BETA**2) IS THE USAGE OF XCC"

"WE NOW PROCEED TO SOLVE FOR THE ABOVE QUANTITIES."
"COMPARING THE TWO EXPRESSIONS FOR OMEGA0, WE CONCLUDE THAT:"

BLCCP= A6680*RHOP*ZS*EXP(ZE/ZS)*RLCP/(WM*EXP(ZX/ZS)) ;
"NOW USING THE EXPRESSION FOR OMEGA0 AT B=BMIN,WE HAVE"
" OMEGA0=EXP(BLCMIN)"
"       =EXP(BMIN)/BMIN"
"       =BLCC*T0/BETA**2"
"       =BLCC*TEFF0    ,     THEREFORE"

TEFF0P = ( EXP(BMIN)/BMIN )/BLCCP;

"COMPARING THE TWO EXPRESSION FOR XRV WE CONCLUDE THAT"
"XC= XCC * SQRT(T) /(E*BETA**2)"
"COMPARING THIS WITH OUR PREVIOUS EXPRESSION FOR XC, WE OBTAIN"

XCCP= (A22P9/RADDEG) * SQRT( ZS*RHOP*RLCP/WM );

"NOW COMPARING THE TWO EXPRESSIONS FOR XRM WE OBTAIN"
"XRM=XC*SQRT(B)       USING DEFINITION OF XRM"
"   =(XCC(i_med)*SQRT(T)/(E*BETA**2)) *SQRT(B)  AFTER SUBSTITUTING FOR XC"
"   =XR0*SQRT((T*B)/(T0*BMIN))/(E*BETA)  USING EXPRESSION DEFINING XR0"
"   =XR0*SQRT((T*B)/(TEFF0*BETA**2*BMIN))/(E*BETA)  EXPANDING T0"
" THUS AFTER SOME CANCELLATION AND SOLVING FOR XR0 WE OBTAIN"

XR0P = XCCP*SQRT(TEFF0P*BMIN);

"THIS COMPLETE THE MS CALCULATIONS"
/*
OUTPUT BLCCP,XCCP,TEFF0P,XR0P;
('0BLCC,XCC,TEFF0,XR0=',1P,4E14.5);
*/
RETURN;
END; "END OF SUBROUTINE MIX"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
SUBROUTINE DIFFER;
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"
implicit none;
;

" IK: Variable declarations for implicit none"
$REAL4 AL183,F10,F20,A1DEN,A2DEN,B1DEN,B2DEN,C1DEN,C2DEN;
INTEGER I;

COMIN/MOLVAR,BREMPRP,DBRPR,DERCON,RADLEN/;
"**********************************************************************"
"***THE DIFFERENTIAL CROSS-SECTIONS OF BREMSSTRAHLUNG AND PAIR       "
"   PRODUCTION ARE Z-DEPENDENT.  BUTCHER AND MESSEL USE A SAMPLING   "
"   TECHNIQUE FOR BREMSSTRAHLUNG WHICH ALSO DEPENDS ON THE LARGEST   "
"   AND SMALLEST ALLOWED ENERGY VALUES.                              "
"   THIS IS NOW TAKEN INTO ACCOUNT BY THE FUNCTION ILOG2(E/AP) WHICH "
"   GIVES THE NUMBER OF SUBDISTRIBUTIONS NEED TO PRODUCE PHOTONS DOWN"
"   TO THE LIMIT AP.                                                 "
"   THE DIFFERENTAL CROSS SECTIONS USED FOR BREMS AND PAIR ARE--     "
"   (THEY ARE CROSS SECTION PER RADIATION LENGTH)                    "

"***BELOW 50MEV (BETHE-HEITLER)--                                      "
"         BREMS--                                                      "
"     PHI1=(LOG(2)*(4/3+1/(9*LOG(A183)*(1+ZP)))* (1/LOG(2)*(1-EPS)/EPS)"
"    1 * A(DELTAPRIME) + (1/2) * (2*EPS) * B(DELTAPRIME)               "
"         PAIR --                                                      "
"     PHI2=(2/3 - 1/(36*LOG(A183)*(1+ZP)))*(1) * C(DELTAPRIME)         "
"    1  + (1/12*(4/3+1/(9*LOG(A183)*(1+ZP))))* (12*(EPS-1/2)**2)       "
"    2 * A(DELTAPRIME)                                                 "
"       WHERE A,B,C ARE SCREENING REJECTION FUNCTIONS GIVEN BY         "
"       A(D)=(3*F1(D)-F2(D)+8*ZG)/(3*F1(0)-F2(0)+8*ZG)                 "
"       B(D)=(F1(D)+4*ZG)/(F1(0)+4*ZG)                                 "
"       C(D)=(3*F1(D)+F2(D)+16*ZG)/(3*F1(0)+F2(0)+16*ZG)               "
"       AND WHERE                                                      "
"       DELTAPRIME= 136.*EXP(ZG)*RM*DEL= DELCM *DEL                    "
"       AND                                                            "
"       DEL =  EPS/(E*(1-EPS))      BREMSSTRAHLUNG                     "
"           =  1/(E*EPS*(1-EPS))    PAIR PRODUCTION                    "
"       F1(D) AND F2(D) ARE SCREENING FUNCTIONS GIVEN APPROXIMATELY BY "
"             IF D.LE.1 ,THEN                                          "
"       F1(D) = 20.867 - 3.242*D + 0.625*D**2                          "
"       F2(D) = 20.209 - 1.930*D - 0.086*D**2                          "
"         BUT IF D.GT.1 ,THEN                                          "
"       F1(D)=F2(D)= 21.12 - 4.184*ALOG(D+0.952)                       "
"         IN ADDITION WE HAVE THAT                                     "
"       F1(0)= 4.*ALOG(A183)                                           "
"       F2(0)= F1(0) - 2./3.                                           "
"***ABOVE 50 MEV (COULOMB CORRECTED BETHE HEITLER)                     "
"         BREMS--                                                      "
"     PHI1=(LOG(2)*(4/3+1/(9*LOG(A183)*(1+ZU)))* (1/LOG(2)*(1-EPS)/EPS)"
"    1 * A(DELTAPRIME) + (1/2) * (2*EPS) * B(DELTAPRIME)               "
"         PAIR --                                                      "
"     PHI2=(2/3-1/(36*LOG(A183)*(1+ZU)))* 1 * C(DELTAPRIME)            "
"    1  + (1/12*(4/3+1/(9*LOG(A183)*(1+ZU))))* (12*(EPS-1/2)**2)       "
"    2  * A(DELTAPRIME)                                                "
"       WHERE A,B,AND C ARE NOW GIVEN BY                               "
"       A(D) = (3*F1(D)-F2(D)+8*ZV)/(3*F1(0)-F2(0)+8*ZV)               "
"       B(D) = (F1(D)+4*ZV)/(F1(0)+4*ZV)                               "
"       C(D) = (3*F1(D)+F2(D)+16*ZV)/(3*F1(0)+F2(0)+16*ZV)             "
"       AND DELTAPRIME,DEL,F1, AND F2 ARE THE SAME AS BELOW 50 MEV.    "
"   BREMSSTRAHLUNG ALPHA(I), I=1,...,N.  ALPHA(N+1)=0.5                "
AL2 = LOG(2.);
AL183= LOG(A183);
ALPHIP(1)= AL2*(4./3. + 1./(9.*AL183*(1.+ZP)));
ALPHIP(2)= AL2*(4./3. + 1./(9.*AL183*(1.+ZU)));
"*****PAIR PRODUCTION DIFFERENTIAL CROSS-SECTION NUMBERS               "
ALFP1(1)= 2./3. - 1./(36.*AL183*(1.+ZP));
ALFP1(2)= 2./3. - 1./(36.*AL183*(1.+ZU));
ALFP2(1)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZP)));
ALFP2(2)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZU)));
"*****BRANCHING RATIO FOR PAIR PRODUCTION SAMPLING                     "
BPARP(1)= ALFP1(1)/(ALFP1(1)+ALFP2(1));
BPARP(2)= ALFP1(2)/(ALFP1(2)+ALFP2(2));

"*****WE MUST ALWAYS HAVE A,B,C(DELTA) POSITIVE. SHOWER ASSURES THIS BY"
"     REQUIRING DEL.LT.DELPOS(),AND HENCE THAT DELTA.LT.DELCM *DELPOS()"
"     THE CROSS-OVER POINT IS IN THE DELTA.GT.1 REGION,AND THE CROSSING"
"     CONDITION REDUCES TO --                                          "
"       F1(D) + 4*ZG = 0     IF  E.LT.50 MEV                           "
"       F1(D) + 4*ZV = 0     IF  E.GT.50 MEV                           "
"     OR --                                                            "
"       21.12 - 4.184*ALOG(DELCM *DELPOS(1)+0.952) +4.*ZG =0     E.LT.5"
"       21.12 - 4.184*ALOG(DELCM *DELPOS(2)+0.952) +4.*ZV =0     E.GT.5"
"       THUS DELPOS IN THE TWO ENERGY REGIONS IS GIVEN BY              "
DELCMP= 136.0*EXP(ZG)*RMP;
DELPOSP(1)= (EXP((21.12+4.*ZG)/4.184)-0.952)/DELCMP;
DELPOSP(2)= (EXP((21.12+4.*ZV)/4.184)-0.952)/DELCMP;
"     CALCULATION OF THE BETHE-HEITLER(B-H) A,B,C(DELTA).AND THE       "
"     COULUMB CORRECTED(CC) A,B,C(DELTA).  THE SHOWER PROGRAM COMPUTES "
"     THESE SIX SCREENING REJECTION FUNCTION WITH THE EXPRESSIONS--    "
"       DL1(LVL)+DELTA*(DL2(LVL)+DELTA*DL3(LVL))   IF DELTA.LT.1 ,AND B"
"       DL4(LVL)+DL5(LV)*ALOG(DELTA+DL6(LVL))      IF DELTA.GE.1       "
"       WHERE LVL IS USED TO SELECT THE FUNCTION--                     "
"       LVL=1   B-H A(DELTA)                                           "
"          =2   B-H B(DELTA)                                           "
"          =3   B-H C(DELTA)                                           "
"          =4   CC  A(DELTA)                                           "
"          =5   CC  B(DELTA)                                           "
"          =6   CC  C(DELTA)                                           "
"     FIRST COMPUTE THE DENOMINATORS                                   "
F10=4.*AL183;
F20=F10 - 2./3.;
A1DEN =3.0*F10- F20 + 8.0*ZG;
A2DEN =3.0*F10- F20 + 8.0*ZV;
B1DEN = F10 + 4.0*ZG;
B2DEN = F10 + 4.0*ZV;
C1DEN = 3.0*F10+ F20 + 16.0*ZG;
C2DEN = 3.0*F10+ F20 + 16.0*ZV;
"     LVL=1, B-H A(DELTA)                                              "
DLP1(1)= (3.0*20.867-20.209+8.0*ZG)/A1DEN;
DLP2(1)= (3.0*(-3.242)-(-1.930))/A1DEN;
DLP3(1)= (3.0*(0.625)-(0.086))/A1DEN;
DLP4(1)= (2.0*21.12+8.0*ZG)/A1DEN;
DLP5(1)=  2.0*(-4.184)/A1DEN;
DLP6(1)=  0.952;
"     LVL=4, CC  A(DELTA)                                              "
DLP1(4)= (3.0*20.867-20.209+8.0*ZV)/A2DEN;
DLP2(4)= (3.0*(-3.242)-(-1.930))/A2DEN;
DLP3(4)= (3.0*(0.625)-(0.086))/A2DEN;
DLP4(4)= (2.0*21.12+8.0*ZV)/A2DEN;
DLP5(4)=  2.0*(-4.184)/A2DEN;
DLP6(4)=  0.952;
"     LVL=2, B-H B(DELTA)                                              "
DLP1(2)= (20.867+4.0*ZG)/B1DEN;
DLP2(2)= -3.242/B1DEN;
DLP3(2)=  0.625/B1DEN;
DLP4(2)= (21.12+4.0*ZG)/B1DEN;
DLP5(2)= -4.184/B1DEN;
DLP6(2)= 0.952;
"     LVL=5, CC B(DELTA)                                               "
DLP1(5)= (20.867+4.0*ZV)/B2DEN;
DLP2(5)= -3.242/B2DEN;
DLP3(5)= 0.625/B2DEN;
DLP4(5)= (21.12+4.0*ZV)/B2DEN;
DLP5(5)= -4.184/B2DEN;
DLP6(5)= 0.952;
"     LVL=3, B-H C(DELTA)                                              "
DLP1(3)= (3.0*20.867+20.209+16.0*ZG)/C1DEN;
DLP2(3)= (3.0*(-3.242)+(-1.930))/C1DEN;
DLP3(3)= (3.0*0.625+(-0.086))/C1DEN;
DLP4(3)= (4.0*21.12+16.0*ZG)/C1DEN;
DLP5(3)=  4.0*(-4.184)/C1DEN;
DLP6(3)=  0.952;
"     LVL=6, CC  C(DELTA)                                              "
DLP1(6)= (3.0*20.867+20.209+16.0*ZV)/C2DEN;
DLP2(6)= (3.0*(-3.242)+(-1.930))/C2DEN;
DLP3(6)= (3.0*0.625+(-0.086))/C2DEN;
DLP4(6)= (4.0*21.12+16.0*ZV)/C2DEN;
DLP5(6)=  4.0*(-4.184)/C2DEN;
DLP6(6)=  0.952;
"*****PUNCHED AND PRINTED OUTPUT                                       "
/*
OUTPUT ; (/,' IN SUBROUTINE DIFFER:'//
' DIFFERENTIAL CROSS-SECTION DATA,COMMON BREMPR'/
' DL1(6),DL2(6),DL3(6),DL4(6),DL5(6),DL6(6),ALPHI(2),BPAR(2),',
 'DELCM,DELPOS(2)');
OUTPUT DLP1,DLP2,DLP3,DLP4,DLP5,
DLP6,ALPHIP,BPARP,DELCMP,DELPOSP;
(1X,6E14.5);
*/
RETURN;
END; "END OF SUBROUTINE DIFFER"

$REAL4 function FCOULCP(Z);
"************************"
implicit none;
$REAL4 Z,ASQ;
COMIN/DERCON/;
ASQ=(FSC*Z)**2;
FCOULCP = ASQ*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+
 ASQ*(0.0083+ASQ*(-0.002))));
RETURN;
END;  "END OF FUNCTION FCOULC"

$REAL4 function XSIFP(Z);
"**********************"
implicit none;
$REAL4 Z,FCOULCP;
$INTEGER IZ;
COMIN/RADLEN/;
IF (Z.LE.4.0) [IZ=Z;
XSIFP=ALRADP(IZ)/(ALRAD(IZ)-FCOULCP(Z));]
ELSE [
XSIFP=ALOG(A1440*Z**(-2./3.))/(ALOG(A183*Z**(-1./3.))-FCOULCP(Z));]
RETURN;
END;  "END OF FUNCTION XSIF"

"******************************************************************"
"                                STANFORD LINEAR ACCELERATOR CENTER"
$REAL4 FUNCTION ZTBL(IASYM);
"                                VERSION 4.00  --  26 JAN 1986/1900"
"******************************************************************"

;
implicit none;
COMIN/ELEMTB,EGS-IO/;
$TYPE IASYM,IA;
$INTEGER ie;
DATA IA/'A'/;
save ia;
IF (IASYM.EQ.IA)["ALTERNATE SYMBOL FOR ARGON" ZTBL=18.0;RETURN;]
"     PUT IN THE REST LATER                                 "
DO IE=1,NET[
IF (IASYM.EQ.ASYMT(IE)) [ZTBL=IE; RETURN;]
]
OUTPUT IASYM,NET;
(1X,A2,' NOT AN ATOMIC SYMBOL FOR AN ELEMENT WITH Z LE ',I3);
ZTBL=0.0;
RETURN;
"END OF FUNCTION ZTBL" END;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc core source code                                                    "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2000                                       "
"                   Dave Rogers, 2000                                         "
"                                                                             "
"  Contributors:    Ernesto Mainegra-Hing                                     "
"                   Blake Walters                                             "
"                   Frederic Tessier                                          "
"                   Reid Townson                                              "
"                   Victor Malkov                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"


"Compiler directives"
"==================="
%Q1         "Automatically close comments at end of line
            "but NOTE, this doesn't happen inside a REPLACE macro
            "you must open and close within a REPLACE macro.
%C80        "Allow 80 columns of source/line (default is 72)
!INDENT M2; "Indent Mortran compile listing 2 spaces each nesting level
!INDENT F2; "Indent fortran output 2 spaces each nesting level
%L          "Turn on listing

%I4 "INDENT FOUR SPACES EACH LEVEL"

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE ANNIH;
"                                                                  "
"******************************************************************"
"   GAMMA SPECTRUM FOR TWO GAMMA IN-FLIGHT POSITRON ANNIHILATION.  "
"   USING SCHEME BASED ON HEITLER'S P269-27O FORMULAE.             "
"                                                                  "
"   If the user requests radiative splitting (via nbr_split > 1),  "
"   this routine produces 2*nbr_split annihilation photons at once,"
"   each carying the fraction 1/nbr_split of the weight of the     "
"   incident positron.                                             "
"                                                                  "
"   Except for taking out the calculation of                       "
"   LOG((1.0-EP0)/EP0) out of the sampling loop and using a        "
"   rejection function normalized to its maximum, the sampling     "
"   technique is the same as the original EGS4 implementation.     "
"                                                                  "
"   I. Kawrakow, January 2000                                      "
"                                                                  "
"******************************************************************"
$IMPLICIT-NONE;

$COMIN-ANNIH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
                 "COMIN/DEBUG,STACK,UPHIOT,USEFUL,RANDOM,          "
                 "EGS-VARIANCE-REDUCTION/;                         "

$DEFINE-LOCAL-VARIABLES-ANNIH;
$INTEGER ip;

NPold = NP; "Set the old stack counter"
IF( nbr_split <= 0 ) [ return; ]
PAVIP=E(NP)+PRM; "PRECISE AVAILABLE ENERGY OF INCIDENT POSITRON,
                 "i.e. electron assumed to be at rest
AVIP=PAVIP;      "AVAILABLE ENERGY OF INCIDENT POSITRON"
A=AVIP/RM;
"AI=1.0/A;  AI not necessary, IK Oct 97"
G=A-1.0;
T=G-1.0;
P=SQRT(A*T);
POT=P/T;
EP0=1.0/(A+P);
"   SAMPLE 1/EP FROM EP=EP0 TO 1.0-EP0"
"Take the calculation of the logarithm out of the loop, IK Oct 97"
WSAMP=LOG((1.0-EP0)/EP0);

aa = u(np); bb = v(np); cc = w(np);
sinpsi = aa*aa + bb*bb;
IF( sinpsi > 1e-20 ) [
   sinpsi = sqrt(sinpsi);
   sindel = bb/sinpsi; cosdel = aa/sinpsi;
]

IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]

DO ibr = 1,nbr_split [  "nbr_split > 1 means we want splitting for any"
                        "radiative event                              "

    IF( np+1 > $MXSTACK ) [
        $egs_fatal('(//a,i6,a//)',' Stack overflow in ANNIH! np = ',np+1,
                   ' Increase $MXSTACK and try again' );
    ]

    LOOP[
        $RANDOMSET RNNO01;
        EP=EP0*EXP(RNNO01*WSAMP);
        "   NOW DECIDE WHETHER TO ACCEPT"
        $RANDOMSET RNNO02;
        "REJF=1.0-EP+AI*AI*(2.0*G-1.0/EP);"
        "The above rejection function has a maximum = 1 - 2/A**2"
        "For efficiency, it is better to divide by the maximum value, IK Oct 97"
        REJF = 1 - (EP*A-1)**2/(EP*(A*A-2));
    ] UNTIL (RNNO02 <= REJF);


    "   SET UP ENERGIES"
    ESG1=AVIP*EP; "ENERGY OF SECONDARY GAMMA 1"
    PESG1=ESG1; "PRECISE ENERGY OF SECONDARY GAMMA 1"
    E(NP)=PESG1; IQ(NP)=0;
    IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
    $TRANSFER PROPERTIES TO (np) FROM (ip);
    COSTHE=MIN(1.0,(ESG1-RM)*POT/ESG1);
    SINTHE=SQRT(1.0-COSTHE*COSTHE);
    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
    IF( sinpsi >= 1e-10 ) [
        us = sinthe*cphi; vs = sinthe*sphi;
        u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
        v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
        w(np) = cc*costhe - sinpsi*us;
    ]
    ELSE [
        u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
    ]
    np = np + 1;
    PESG2=PAVIP-PESG1; esg2 = pesg2;
    e(np) = pesg2; iq(np) = 0;
    $TRANSFER PROPERTIES TO (np) FROM (np-1);
    COSTHE=MIN(1.0,(ESG2-RM)*POT/ESG2);
    SINTHE=-SQRT(1.0-COSTHE*COSTHE);
    IF( sinpsi >= 1e-10 ) [
        us = sinthe*cphi; vs = sinthe*sphi;
        u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
        v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
        w(np) = cc*costhe - sinpsi*us;
    ]
    ELSE [
        u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
    ]
    np = np + 1;

]
np = np-1;

RETURN;
"END OF SUBROUTINE ANNIH"   END;

"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE ANNIH_AT_REST;
"                                                                  "
" It is handy to be able to initiate annihilation at rest from     "
" places other than the electron discard section (e.g. AUSGAB)     "
" Annihilation at rest takes a sufficent amount of time to not     "
" have any real benefit from this code being inline in the         "
" ELECTR subroutine.                                               "
" I. Kawrakow, June 2005.                                          "
"******************************************************************"
$IMPLICIT-NONE;
$COMIN-ANNIH-ATREST;
$REAL costhe,sinthe,cphi,sphi;
$INTEGER ibr,ip;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;

NPold = NP;
$CHECK-STACK(np+2*nbr_split-1,'ANNIH_AT_REST');
IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]
    " nbr_split > 1 means user wants to use radiative "
    " splitting => produce 2*nbr_split annihilation   "
    " photons at once                                 "
DO ibr = 1, nbr_split [
    "Pick random direction for first gamma
    $RANDOMSET costhe; costhe = 2*costhe-1;
    sinthe = sqrt(max(0.0,(1-costhe)*(1+costhe)));
    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
    e(np) = prm; iq(np) = 0;
    IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
    $TRANSFER PROPERTIES TO (np) FROM (ip);
    u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = costhe;
    np = np+1;
    e(np) = prm; iq(np) = 0;
    $TRANSFER PROPERTIES TO (np) FROM (np-1);
    u(np) = -u(np-1); v(np) = -v(np-1); w(np) = -w(np-1);
    np = np+1;
]
np = np-1;
return; end;


%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE BHABHA;
"                                                                  "
"******************************************************************"
"   DISCRETE BHABHA SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
"   ARBITRARILY DEFINED AND CALCULATED TO MEAN BHABHA SCATTERINGS  "
"   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
"   IT BE TRANSPORTED DISCRETELY, I.E. E=AE OR T=TE.  IT IS NOT    "
"   GUARANTEED THAT THE FINAL POSITRON WILL HAVE THIS MUCH ENERGY  "
"   HOWEVER.  THE EXACT BHABHA DIFFERENTIAL CROSS SECTION IS USED. "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-BHABHA;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
                   "COMIN/DEBUG,EGS-VARIANCE-REDUCTION,STACK,"
                                "THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-BHABHA;

NPold = NP;      "Set the old stack counter"
PEIP=E(NP); "PRECISE ENERGY OF INCIDENT POSITRON"
EIP=PEIP; "ENERGY OF INCIDENT POSITRON"
PEKIN=PEIP-PRM;  "PRECISE K.E. OF INCIDENT POSITRON"
EKIN=PEKIN;
T0=EKIN/RM;
E0=T0+1.;
YY=1./(T0+2.);
E02=E0*E0;
"BETAI2=E02/(E02-1.);" "BLIF 96/2/1 -- not needed for Bhabha fix-up"
BETA2=(E02-1.)/E02;    "BLIF 96/2/1 -- needed for Bhabha fix-up"
EP0=TE(MEDIUM)/EKIN;
EP0C=1.-EP0;
Y2=YY*YY;
YP=1.-2.*YY;
YP2=YP*YP;
B4=YP2*YP;
B3=B4+YP2;
B2=YP*(3.+Y2);
B1=2.-Y2;
"   SAMPLE BR FROM MINIMUM(EP0) TO 1."
LOOP[$RANDOMSET RNNO03;
BR=EP0/(1.-EP0C*RNNO03);
"   APPLY REJECTION FUNCTION"
$RANDOMSET RNNO04;
"REJF2=EP0C*(BETAI2-BR*(B1-BR*(B2-BR*(B3-BR*B4))));BLIF 96/2/1 -- Bhabha fix-up"
REJF2=(1.0-BETA2*BR*(B1-BR*(B2-BR*(B3-BR*B4)))); "BLIF 96/2/1 -- Bhabha fix-up"
]UNTIL RNNO04.LE.REJF2 ;
"   IF E- GOT MORE THAN E+, MOVE THE E+ POINTER AND REFLECT B"
$CHECK-STACK(np+1,'BHABHA');
IF (BR.LT.0.5)[IQ(NP+1)=-1;]ELSE[IQ(NP)=-1;IQ(NP+1)=1;BR=1.-BR;]
"THE ABOVE PUTS E+ ON TOP OF STACK IF IT HAS LESS ENERGY"
"   DIVIDE UP THE ENERGY"
BR=max(BR,0.0); "AVOIDS POSSIBLE NEGATIVE NUMBER DUE TO ROUND-OFF"
PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY 'ELECTRON' 2"
PESE1=PEIP-PEKSE2; "PRECISE ENERGY OF SECONDARY 'ELECTRON' 1"
PESE2=PEKSE2+PRM;  "PRECISE ENERGY OF SECONDARY 'ELECTRON' 2"
ESE1=PESE1;
ESE2=PESE2;
E(NP)=PESE1;
E(NP+1)=PESE2;
"   BHABHA ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS"
H1=(PEIP+PRM)/PEKIN;
"   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON"

"AFB modified the following statement 92/10/28 to avoid"
"numerical difficulties"
"DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);"
DCOSTH=MIN(1.0D0,H1*(PESE1-PRM)/(PESE1+PRM));

SINTHE=DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);
CALL UPHI(2,1);
NP=NP+1;
DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
SINTHE=-DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);
CALL UPHI(3,2);
RETURN;
"END OF SUBROUTINE BHABHA"  END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE BREMS;
"                                                                  "
"******************************************************************"
"   Samples bremsstrahlung energy using                            "
"    - Coulomb corrected Bethe-Heitler above 50 MeV                "
"    - Bethe-Heitler below 50 MeV                                  "
"   if ibr_nist = 0, or                                            "
"    - the NIST bremsstrahlung cross section data base             "
"      (prepared in a form of an alias table for rapid sampling)   "
"   if ibr_nist = 1  or                                            "
"    - the NRC bremsstrahlung cross section data base, which is    "
"      the same as the NIST database, but with corrections to      "
"      the electron-electron contribution, which are mostly        "
"      important for low Z and low k                               "
"   if ibr_nist = 2                                                "
"   and direction using                                            "
"    - formula 2BS from from Koch and Motz if IBRDST=1             "
"    - leading term of the brems angular dsstr. if IBRDST=0        "
"    - photon direction = electron direction if IBRDST<0           "
"                                                                  "
"   This version replaces the original EGS4 implementation         "
"   because of a bug discovered in the EGS4 brems routine          "
"   In order to work properly, the parameter DL1,..,DL6            "
"   are re-calculated in subroutine fix_brems which is called      "
"   from HATCH                                                     "
"   In addition, this version has the internal capability of       "
"   bremsstrahlung splitting.                                      "
"   To use bremsstrahlung splitting, set nbr_split (COMON/BREMPR/) "
"   to the desired number > 1 (1 is the default)                   "
"   Be aware that event-by-event energy conservation is NOT        "
"   guaranteed, so don't use for calculations where this is        "
"   important (e.g. calculation of detector response functions)    "
"   The result will be nbr_split photons, all with the weight      "
"   wt(npold)/nbr_split, and an electron with the original weight  "
"   and energy given by the incident energy - energy of last photon"
"                                                                  "
" I. Kawrakow, January 2000                                        "
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-BREMS;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,   "
                           "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-BREMS;
$REAL z2max,z2maxi,aux1,aux3,aux4,aux5,aux2,weight;

IF( nbr_split < 1 ) return;  "i.e. the user can turn off brems production"
                             "by setting nbr_split to zero!"

NPold = NP;      "Set the old stack counter"
PEIE=E(NP);      "PRECISE ENERGY OF INCIDENT 'ELECTRON'"
EIE=PEIE;        "ENERGY OF INCIDENT 'ELECTRON'"
weight = wt(np)/nbr_split;

"   DECIDE WHICH DISTRIBUTION TO USE (B-H COULOMB CORRECTED IS     "
"   USED FROM 50 TO 20000 MEV, B-H IS USED 1.5 TO 50 MEV)          "
IF (EIE.LT.50.0)[ L=1; ] ELSE [ L=3; ]
L1 = L+1;

ekin = peie-prm;
brmin = ap(medium)/ekin;
"waux = -log(brmin);"
waux = elke - log_ap(medium); "this saves the time consuming log evaluation"
                              "log_ap = log(ap(medium)) is calculated in   "
                              "fix_brems for each medium, elke is needed   "
                              "in electr to calculate the branching ratios "
                              "and therefore it must be known at this point"

IF( ibrdst >= 0 ) [ "inrdst >=0 means we will sample the photon emmision"
                    "angle from KM-2BS (ibrdst=1) or from the leading"
                    "term (ibrdst=0). If nbr_split > 1, we can re-use"
                    "the following quantities several time"

    a = u(np); b = v(np); c = w(np);
    sinpsi = a*a + b*b;
    IF( sinpsi > 1e-20 ) [
       sinpsi = sqrt(sinpsi);
       sindel = b/sinpsi; cosdel = a/sinpsi;
    ]

    ztarg = zbrang(medium);
    tteie = eie/rm;
    beta = sqrt((tteie-1)*(tteie+1))/tteie;
    y2max = 2*beta*(1+beta)*tteie*tteie;
    y2maxi = 1/y2max;
    IF( ibrdst = 1 ) [ z2max = y2max+1; z2maxi = sqrt(z2max); ]

]

IF( ibr_nist >= 1 ) [
    ajj = 1 + (waux + log_ap(medium) - nb_lemin(medium))*nb_dlei(medium);
    jj = ajj; ajj = ajj - jj;
    IF( jj >  $MXBRES ) [ jj = $MXBRES; ajj = -1; ]
]

DO ibr = 1,nbr_split [

    IF( ibr_nist >= 1 ) [ "use the NIST or NRC bremsstrahlung cross section"
                         "data base"
        IF( ekin > nb_emin(medium) ) [
            $RANDOMSET r1;
            IF( r1 < ajj ) [ j = jj+1; ] ELSE [ j = jj; ]
            br = alias_sample1($MXBRXS,nb_xdata(0,j,medium),
                               nb_fdata(0,j,medium),
                               nb_wdata(1,j,medium),nb_idata(1,j,medium));
        ]
        ELSE [ $RANDOMSET br; ]
        esg = ap(medium)*exp(br*waux); pesg = esg;
        pese = peie - pesg; ese = pese;
    ]
    ELSE [

        LOOP [ "User wants to use Bethe-Heitler"

            $RANDOMSET rnno06; $RANDOMSET rnno07;
            br = brmin*exp(rnno06*waux);
            esg = ekin*br; pesg = esg;
            pese = peie - pesg; ese = pese;
            delta = esg/eie/ese*delcm(medium); aux = ese/eie;
            IF( delta < 1 ) [
                phi1 = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
                phi2 = dl1(l1,medium)+delta*(dl2(l1,medium)+
                        delta*dl3(l1,medium));
            ]
            ELSE [
                phi1 = dl4(l,medium)+dl5(l,medium)*log(delta+dl6(l,medium));
                phi2 = phi1;
            ]
            rejf = (1+aux*aux)*phi1 - 2*aux*phi2/3;

        ] UNTIL (rnno07 < rejf);
    ]

    "   SET UP THE NEW PHOTON                                          "
    np=np+1;
    IF( np > $MXSTACK ) [
        $egs_fatal('(//a,i6,a//)',' Stack overflow in BREMS! np = ',np+1,
                   ' Increase $MXSTACK and try again' );
    ]
    e(np) = pesg; iq(np) = 0;
    $TRANSFER PROPERTIES TO (np) FROM (np-1);
    wt(np) = weight;
    IF( ibrdst < 0 ) [  "The photon will inherit the direction from "
                        "the electron. This option is given so that "
                        "the user can implement their own brems angle "
                        "schemes via a call to ausgab"
        u(np) = u(npold); v(np) = v(npold); w(np) = w(npold);
    ]
    ELSE [
       IF( ibrdst = 1 ) [
           /*
              This is the original implementation
              suggested by Alex Bielajew. Commented out as
              the implementation below is way more efficient.
              IK, Sep. 2004.
           ttese = ese/rm; esedei = ttese/tteie;
           rjarg1 = 1+esedei*esedei;
           rjarg2 = 3*rjarg1 - 2*esedei;
           rjarg3 = ((1-esedei)/(2*tteie*esedei))**2;
           $SET-BREM-REJECTION-FUNCTION(REJMIN,0.0);
           $SET-BREM-REJECTION-FUNCTION(REJMID,1.0);
           $SET-BREM-REJECTION-FUNCTION(REJMAX,y2max);
           rejtop = max(rejmin,rejmid,rejmax);
           LOOP [
              $RANDOMSET y2tst; y2tst = y2tst/(1-y2tst+y2maxi);
              $SET-BREM-REJECTION-FUNCTION(REJTST,Y2TST);
              $RANDOMSET rtest;
           ] UNTIL (rtest*rejtop <= REJTST);
           */
           ttese = ese/rm; esedei = ttese/tteie;
           rjarg1 = 1+esedei*esedei;
           rjarg2 = rjarg1 + 2*esedei;
           aux = 2*ese*tteie/esg; aux = aux*aux; aux1 = aux*ztarg;
           IF( aux1 > 10 ) [ rjarg3 = lzbrang(medium) + (1-aux1)/aux1**2; ]
           ELSE [ rjarg3 = log(aux/(1+aux1)); ]
           rejmax = rjarg1*rjarg3-rjarg2;
           LOOP [
               $RANDOMSET y2tst; $RANDOMSET rtest;
               aux3 = z2maxi/(y2tst+(1-y2tst)*z2maxi);
               rtest = rtest*aux3*rejmax;
               y2tst = aux3**2-1; y2tst1 = esedei*y2tst/aux3**4;
               aux4 = 16*y2tst1-rjarg2; aux5 = rjarg1-4*y2tst1;
               IF( rtest < aux4 + aux5*rjarg3 ) EXIT;
               aux2 = log(aux/(1+aux1/aux3**4));
               rejtst = aux4+aux5*aux2;
           ] UNTIL (rtest < rejtst );

       ]
       ELSE [
           $RANDOMSET y2tst; y2tst = y2tst/(1-y2tst+y2maxi);
       ]
       costhe = 1 - 2*y2tst*y2maxi;
       sinthe = sqrt(max((1-costhe)*(1+costhe),0.0));
       $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
       IF( sinpsi >= 1e-10 ) [
           us = sinthe*cphi; vs = sinthe*sphi;
           u(np) = c*cosdel*us - sindel*vs + a*costhe;
           v(np) = c*sindel*us + cosdel*vs + b*costhe;
           w(np) = c*costhe - sinpsi*us;
       ]
       ELSE [
           u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = c*costhe;
       ]
    ]
]

e(npold) = pese;

RETURN;
"END OF SUBROUTINE BREMS"   END;

"******************************************************************"
"                                                          NRCC    "
SUBROUTINE COMPT;
"                                VERSION 1.00  --  12 JAN 1999     "
"******************************************************************"
"                                                                  "
"   Subroutine for sampling incoherent (Compton) scattering        "
"   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
"   Otherwise scattering is modelled in the impulse approximation  "
"   (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325)  "
"   As the total cross section from PEGS4 is not modified (and thus"
"   calculated using Klein-Nishina), all rejections lead to an     "
"   unscattered photon and a zero energy electron.                 "
"   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
"   atomic relaxation is treated in RELAX. This has as a           "
"   consequence that more than one particle can be created as a    "
"   result of an incoherent scattering. The user should therefore  "
"   check their user codes for possible inconsistencies.           "
"                                                                  "
"   I.Kawrakow, January 1999                                       "
"                                                                  "
"   I.Kawrakow, March 2008:                                        "
"      If ibcmp = 2 or 3, the actual bound Compton scattering      "
"      cross section is used and rejections lead to resampling     "
"      instead of rejecting the entire interactions as stated above"
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/COMPTON-DATA,DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM/;

$DEFINE-LOCAL-VARIABLES-COMPT;
$LOGICAL first_time;
$INTEGER ibcmpl;

NPold = NP;       "Set the old stack counter"
peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
ko = peig/rm;     "Gamma energy in units of electron rest energy"
broi = 1 + 2*ko;  "Needed for scattering angle sampling"

$RADC_CHECK;

irl = ir(np); first_time = .true.; ibcmpl = ibcmp(irl);

:resample-compton:;
IF( ibcmpl > 0 ) [ "User wants to take into account binding effects"
                   "=>first sample the shell and see whether an    "
                   "  interaction is possible                      "
    $RANDOMSET rnno17; rnno17 = 1 + rnno17*n_shell(medium);
    i = int(rnno17); "rnno17 = rnno17 - i;
    IF( rnno17 > eno_array(i,medium) ) i = eno_atbin_array(i,medium);
    j = shell_array(i,medium); "j is the shell number in the data list"
    Uj = be_array(j);          "Uj is the binding energy in units of rm"

    " Binding energy rejection "
    IF( ko <= Uj ) [
        IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
        ELSE             [ goto :resample-compton:;     ]
    ]
    Jo = Jo_array(j);          "Jo is the Compton profile parameter"

]

" We always sample the scattering angle from Klein-Nishina"
:RESAMPLE:
;
IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
    IF( first_time ) [
        broi2 = broi*broi;
        alph1 = Log(broi);
        bro   = 1/broi;
        alph2 = ko*(broi+1)*bro*bro;
        alpha = alph1+alph2;
    ]
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        IF( rnno15*alpha < alph1 ) [ "Use 1/br part"
            br = Exp(alph1*rnno16)*bro;
        ]
        ELSE [  "Use the br part."
            br = Sqrt(rnno16*broi2 + (1-rnno16))*bro;
        ]
        temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
        aux = 1+br*br;
        rejf3 = aux - br*sinthe;
        $RANDOMSET rnno19;
    ] UNTIL rnno19*aux.le.rejf3;
]
ELSE [ "At low energies it is faster to sample br uniformely"
    IF( first_time ) [
        bro = 1./broi; bro1 = 1 - bro;
        rejmax = broi + bro;
    ]
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        br = bro + bro1*rnno15;
        temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
        rejf3 = 1 + br*br - br*sinthe;
    ] UNTIL rnno16*br*rejmax.le.rejf3;
]
first_time = .false.;

IF(br < bro | br > 1)  [
    IF( br < 0.99999/broi | br > 1.00001 ) [
        $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
    ]
    goto :RESAMPLE: ;
]

$RADC_REJECTION;

costhe = 1 - temp;
IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
    Uj = 0;
    goto :FINISHED-COMPTON-SAMPLING:;
]

" Check for rejection due to the limited range of pzmax "
br2 = br*br;
aux = ko*(ko-Uj)*temp;
aux1 = 2*aux + Uj*Uj;
pzmax = aux - Uj;
IF( pzmax < 0 & pzmax*pzmax >= aux1 ) [
    IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
    ELSE             [ goto :resample-compton:; ]
]
pzmax = pzmax/sqrt(aux1);
/*
pzmax = (aux - Uj)/sqrt(2*aux + Uj*Uj);
IF( pzmax <= -1 ) [
    IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
    ELSE             [ goto :resample-compton:; ]
]
*/
qc2 = 1 + br*br - 2*br*costhe;
qc  = sqrt(qc2);

IF( pzmax > 1 ) [
    pzmax = 1; af = 0; Fmax = 1; fpz = 1;
    goto :RETRY-PZ:;
]

aux3 = 1 + 2*Jo*abs(pzmax);
aux4 = 0.5*(1-aux3*aux3);
fpz  = 0.5*exp(aux4);
af   = qc*(1+br*(br-costhe)/qc2);

IF( af < 0 ) [
    IF( pzmax > 0 ) fpz = 1 - fpz;
    $RANDOMSET eta_incoh;
    IF( eta_incoh > fpz ) [
        IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
        ELSE             [ goto :resample-compton:; ]
    ]
    af = 0; Fmax = 1; goto :RETRY-PZ:;
]

IF( pzmax < -0.15 ) [
    Fmax = 1-af*0.15;
    fpz1 = fpz*Fmax*Jo;
]
ELSE IF( pzmax < 0.15 ) [
    Fmax = 1 + af*pzmax;
    aux3 = 1/(1+0.33267252734*aux3);
            "0.33267252734 is p/sqrt(2), p is the parameter from Eq. 7.1.25"
            "of Abramowitz and Stegun, needed for approximating Erf        "
    aux4 = fpz*aux3*(0.3480242+aux3*(-0.0958798+aux3*0.7478556)) +
           erfJo_array(j);
    IF( pzmax > 0 ) [
        "fpz1 = 1 - Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
          "missing factor 1/2 in the above found by Cerneliu Costescu"
          "0.62665706866 is sqrt(Pi/8)"
        fpz1 = (1 - Fmax*fpz)*Jo - 0.62665706866*af*aux4;
        fpz = 1 - fpz;
    ]
    ELSE [
        "fpz1 = Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
          "missing factor 1/2 in the above found by Cerneliu Costescu"
          "0.62665706866 is sqrt(Pi/8)"
        fpz1 = Fmax*fpz*Jo - 0.62665706866*af*aux4;
    ]
]
ELSE [
    Fmax = 1 + af*0.15;
    fpz1 = (1 - Fmax*fpz)*Jo;
    fpz = 1 - fpz;
]
$RANDOMSET eta_incoh;
IF(eta_incoh*Jo > fpz1 ) [
    IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
    ELSE             [ goto :resample-compton:; ]
]

"At this point, all rejections are handled, now we need to sample pz "
"between -1 and pzmax using the Compton profile of the selected shell"
"and F(pz,cos(theta)) as a rejection function                        "

:RETRY-PZ:;
IF( ibcmpl ~= 2 ) [
  $RANDOMSET rnno18; rnno18 = rnno18*fpz;
  IF( rnno18 < 0.5 ) [
    rnno18 = Max(1e-30,2*rnno18);
    pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo;
  ]
  ELSE [
    rnno18 = 2*(1-rnno18);
    pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo;
  ]
  IF( abs(pz) > 1 ) goto :RETRY-PZ:;
      "Due to the non-relativistic approximation"
      "for pz, it has to be between -1 and 1    "
  IF( pz < 0.15  ) [
    IF( pz < -0.15 ) [ frej = 1 - af*0.15; ]
    ELSE             [ frej = 1 + af*pz;   ]
    $RANDOMSET eta;
    IF( eta*Fmax > frej ) goto :RETRY-PZ:;
  ]
  "If pz > 0.15, F is always 1 => no need for rejection"
]
ELSE [ pz = 0; Uj = 0; "i.e., no Doppler broadenning and no binding energy" ]

" Calculate energy of scattered photon "
pz2 = pz*pz;
IF( abs(pz) < 0.01 ) [
    br = br*(1 + pz*(qc + (br2-costhe)*pz));
]
ELSE [
    aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
    aux2 = qc2 - br2*pz2*sinthe;
    IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
]
Uj = Uj*prm;

:FINISHED-COMPTON-SAMPLING:
pesg = br*peig; pese = peig - pesg - Uj + prm;
sinthe = Sqrt(sinthe);
call uphi(2,1); e(np) = pesg;
aux = 1 + br*br - 2*br*costhe;
IF( aux > 1e-8 ) [
    costhe = (1-br*costhe)/Sqrt(aux);
    sinthe = (1-costhe)*(1+costhe);
    IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
    ELSE [ sinthe = 0; ]
] ELSE [ costhe = 0; sinthe = -1; ]
np = np + 1;
$CHECK-STACK(np,'COMPT');
call uphi(3,2);
e(np) = pese; iq(np) = -1;

IF( ibcmpl = 1 | ibcmpl = 3 ) [

    " Shell vacancy "
    IF( Uj > 1e-3 ) [
        edep = pzero;

        call relax(Uj,shn_array(j),iz_array(j));
        "relax will put all particles with energies above ecut,pcut on the "
        "stack, the remaining energy will be scored in edep and deposited  "
        "locally (via the call to ausgab below)                            "
    ]
    ELSE [
        edep = Uj;
        edep_local = edep;
        $AUSCALL($SPHOTONA);
    ]
    IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]

]

" Now play Russian Roulette with resulting electrons if the user asked for it"
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"

return;

:INTERACTION-REJECTED:
" Create here a zero energy electron if required (check user codes) "
return;
end;

"******************************************************************"
"                                                          NRCC    "
SUBROUTINE old_COMPT;
"                                VERSION 1.00  --  12 JAN 1999     "
"******************************************************************"
"                                                                  "
"   Subroutine for sampling incoherent (Compton) scattering        "
"   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
"   Otherwise scattering is modelled in the impuls approximation   "
"    (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325) "
"   As the total cross section from PEGS4 is not modified (and thus"
"   calculated using Klein-Nishina), all rejections leed to an     "
"   unscattered photon and a zero energy electron.                 "
"   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
"   atomic relaxation is treated in RELAX. This has as a           "
"   consequence that more than one particle can be created as a    "
"   result of an incoherent scattering. The user should therefore  "
"   check their user codes for possible inconsistencies.           "
"   This version ignores the function F(cos(theta),pz).            "
"   This leads to a small error (at least compared to the cross    "
"   section we want to sample) at low energies (say, below Z keV)  "
"   The advantage is that it is substantially faster then the      "
"   version with F taken into account.                             "
"                                                                  "
"                                                                  "
"   I.Kawrakow, January 1999                                       "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/COMPTON-DATA,EGS-VARIANCE-REDUCTION,DEBUG, "
                               "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-COMPT-old;

i_survived_RR = 0;"0=> all survived russian roulette if played"
                  "must set here since, if bound compton and event is"
                  "rejected, this wouldn't be set to the new 0 value"
NPold = NP;       "Set the old stack counter"
peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
ko = peig/rm;     "Gamma energy in units of electron rest energy"
broi = 1 + 2*ko;  "Needed for scattering angle sampling"

irl = ir(np);
IF( ibcmp(irl) = 1 ) [ "User wants to take into account binding effects"
                       "=>first sample the shell and see whether an    "
                       "  interaction is possible                      "
    $RANDOMSET rnno17;
    DO i=1,n_shell(medium) [
        rnno17 = rnno17 - eno_array(i,medium);
        IF( rnno17 <= 0 ) EXIT;
    ]
    j = shell_array(i,medium); "j is the shell number in the data list"
    Uj = be_array(j);          "Uj is the binding energy in units of rm"

    " Binding energy rejection "
    IF( ko <= Uj ) [ goto :INTERACTION-REJECTED-old:; ]

]

" We always sample the scattering angle from Klein-Nishina"
:RESAMPLE-old:
;
IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
    broi2 = broi*broi;
    alph1 = Log(broi);
    alph2 = ko*(broi+1)/broi2;
    alpha = alph1/(alph1+alph2);
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        IF( rnno15 < alpha ) [ "Use 1/br part"
            br = Exp(alph1*rnno16)/broi;
        ]
        ELSE [  "Use the br part."
            br = Sqrt(rnno16 + (1-rnno16)/broi2);
        ]
        temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
        rejf3 = 1 - br*sinthe/(1+br*br);
        $RANDOMSET rnno19;
    ] UNTIL rnno19.le.rejf3;
]
ELSE [ "At low energies it is faster to sample br uniformely"
    bro = 1./broi; bro1 = 1 - bro;
    rejmax = broi + bro;
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        br = bro + bro1*rnno15;
        temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
        rejf3 = (br + 1./br - sinthe)/rejmax;
    ] UNTIL rnno16.le.rejf3;
]

IF(br < 1./broi | br > 1)  [
    IF( br < 0.99999/broi | br > 1.00001 ) [
    $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
    ]
    goto :RESAMPLE-old: ;
]

IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
    Uj = 0; costhe = 1 - temp;
    goto :FINISHED-COMPTON-SAMPLING-old:;
]

" Sample Doppler broadening using the Compton profile of the selected shell"
br2 = br*br;
costhe = 1 - temp;
aux = ko*(ko-Uj)*temp; aux1 = aux-Uj;
pzmax2 = aux1*aux1/(2*aux+Uj*Uj);
:RETRY-PZ-old:;
$RANDOMSET rnno18;
IF( rnno18 < 0.5 ) [
    rnno18 = Max(1e-30,2*rnno18);
    pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo_array(j);
    pz2 = pz*pz;
    IF( (pz2 <= pzmax2) & (aux1 < 0) ) [goto :INTERACTION-REJECTED-old:; ]
]
ELSE [
    IF( aux1 < 0 ) [goto :INTERACTION-REJECTED-old:; ]
    rnno18 = 2*(1-rnno18);
    pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo_array(j);
    pz2 = pz*pz;
    IF( pz2 >= pzmax2 ) [goto :INTERACTION-REJECTED-old:; ]
]
IF( abs(pz) > 1 ) goto :RETRY-PZ-old:;

" Calculate energy of scattered photon "
aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
aux2 = 1-2*br*costhe+br2*(1-pz2*sinthe);
IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
Uj = Uj*prm;

:FINISHED-COMPTON-SAMPLING-old:
pesg = br*peig; pese = peig - pesg - Uj + prm;
sinthe = Sqrt(sinthe);
call uphi(2,1); e(np) = pesg;
aux = 1 + br*br - 2*br*costhe;
IF( aux > 1e-8 ) [
    costhe = (1-br*costhe)/Sqrt(aux);
    sinthe = (1-costhe)*(1+costhe);
    IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
    ELSE [ sinthe = 0; ]
] ELSE [ costhe = 0; sinthe = -1; ]
np = np + 1;
$CHECK-STACK(np,'COMPT');
call uphi(3,2);
e(np) = pese; iq(np) = -1;

IF( ibcmp(irl) = 1 ) [

    " Shell vacancy "
    IF( Uj > 1e-3 ) [
        edep = 0;

        call relax(Uj,shn_array(j),iz_array(j));
          "relax will put all particles with energies above ecut,pcut on the "
          "stack, the remaining energy will be scored in edep and deposited  "
          "localy (via the call to ausgab below)                             "
    ]
    ELSE [ edep = Uj; ]
    IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]

]

" Now play Russian Roulette with resulting electrons if the user asked for it"
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"

return;

:INTERACTION-REJECTED-old:
" Create here a zero energy electron if required (check user codes) "
return;
end;

%E
"******************************************************************"
"                               NATIONAL RESEARCH COUNCIL OF CANADA"
SUBROUTINE ELECTR(IRCODE);
"******************************************************************"
"   This subroutine has been almost completely recoded to include  "
"   the EGSnrc enhancements.                                       "
"                                                                  "
"   Version 1.0   Iwan Kawrakow       Complete recoding            "
"   Version 1.1   Iwan Kawrakow       Corrected implementation of  "
"                                     fictitious method (important "
"                                     for low energy transport     "
"******************************************************************"

$IMPLICIT-NONE;

$INTEGER IRCODE;

$COMIN-ELECTR; "default replacement produces the following:
               "COMIN/DEBUG,BOUNDS,EGS-VARIANCE-REDUCTION, ELECIN,EPCONT,"
                        "ET-Control,MEDIA,MISC,STACK,THRESH,UPHIIN,"
                        "UPHIOT,USEFUL,USER,RANDOM/;"
;COMIN/EII-DATA/;
;COMIN/EM/;
$REAL lambda_max, sigratio, u_tmp, v_tmp, w_tmp;
LOGICAL random_tustep;

$DEFINE-LOCAL-VARIABLES-ELECTR;
/******* trying to save evaluation of range.
$LOGICAL  do_range;
$REAL     the_range;
*/

data ierust/0/;         "To count negative ustep's"

save ierust;

$CALL-USER-ELECTRON;

ircode = 1; "Set up normal return-which means there is a photon
            "with less available energy than the lowest energy electron,
            "so return to shower so it can call photon to follow it.
            "(For efficiency's sake, we like to stay in this routine
            " as long as there are electrons to process. That's why this
            " apparently convoluted scheme of STACK contro is effected.)

irold = ir(np);    "Initialize previous region
                   "(ir() is an integer that is attached to the particle's
                   " phase space. It contains the region
                   " number that the current particle is in.
                   " Np is the stack pointer, it points to where on the
                   " stack the current particle is.)
irl    = irold;    "region number in local variable


$start_new_particle;
" Default replacement for the above is medium = med(irl); "
" This is made a macro so that it can be replaced with a call to a "
" user provided function start_new_particle(); for the C/C++ interface "

:NEWELECTRON:LOOP
[
    "Go once through this loop for each 'new' electron whose charge and
    "energy has not been checked

    lelec = iq(np); "Save charge in local variable
                    "(iq = -1 for electrons, 0 for photons and 1 for positrons)
    qel   = (1+lelec)/2; " = 0 for electrons, = 1 for positrons "
    peie  = e(np);  "precise energy of incident electron (double precision)
    eie   = peie;   "energy incident electron (conversion to single)

    IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
        "(Ecut is the lower transport threshold.)

    "medium = med(irl);" "(This renders the above assignment redundant!)
    "The above assignment is unnecessary, IK, June 2003"

    IF(WT(NP) = 0.0) [go to :USER-ELECTRON-DISCARD:;] "added May 01"

    :TSTEP:LOOP
    [
        "Go through this loop each time we recompute distance to an interaction
        /******* trying to save evaluation of range.
        do_range = .true.; "compute the range in $COMPUTE-RANGE below"
        ********/
        compute_tstep = .true.; "MFP resampled => calculate distance to the
                                "interaction in the USTEP loop
        eke = eie - rm; "moved here so that kinetic energy will be known"
                        "to user even for a vacuum step, IK January 2000"
        IF(medium ~= 0)
        [
            "Not vacuum. Must sample to see how far to next interaction.

            $SELECT-ELECTRON-MFP;
                " Default FOR $SELECT-ELECTRON-MFP; is: $RANDOMSET rnne1;
                "                                       demfp = -log(rnne1);
                "($RANDOMSET is a macro'ed random number generator)
                "(demfp = differential electron mean free path)

            elke = log(eke);
            "(eke = kinetic energy, rm = rest mass, all in units of MeV)
            $SET INTERVAL elke,eke; "Prepare to approximate cross section

            $EVALUATE-SIG0;
               "The fix up of the fictitious method uses cross section per"
               "energy loss. Therefore, demfp/sig is sub-threshold energy loss"
               "until the next discrete interaction occures (see below)"
               "As this quantity is a single constant for a material,"
               "$SET INTERVAL is not necessary at this point. However, to not"
               "completely alter the logic of the TSTEP and USTEP loops,"
               "this is left for now"

        ] "end non-vacuum test

        :USTEP:LOOP
        [
            "Here for each check with user geometry.
            "Compute size of maximum acceptable step, which is limited
            "by multiple scattering or other approximations.
            IF(medium = 0)
            [
                    "vacuum
                    $EMFIELD_INITIATE_SET_TUSTEP;
                    tstep = vacdst; ustep = tstep; tustep = ustep;
                    callhowfar = .true.; "Always call HOWFAR for vacuum steps!"

                    "(Important definitions:
                    " tstep  = total pathlength to the next discrete interaction
                    " vacdst = infinity (actually 10^8)
                    " tustep = total pathlength of the electron step
                    " ustep  = projected transport distance in the
                    "          direction of motion at the start of the step
                    " Note that tustep and ustep are modified below.
                    " The above provide defaults.)

                    " EM field step size restriction in vacuum
                    $SET-TUSTEP-EM-FIELD;
                    ustep = tustep;
            ]
            ELSE
            [
                "non-vacuum
                $SET-RHOF;    "density ratio scaling template
                              "EGS allows the density to vary
                              "continuously (user option)

                $SCALE-SIG0;
                IF(sig <= 0)
                [
                    "This can happen if the threshold for brems,
                    "(ap + rm), is greater than ae.  Moller threshold is
                    "2*ae - rm. If sig is zero, we are below the
                    "thresholds for both bremsstrahlung and Moller.
                    "In this case we will just lose energy by
                    "ionization loss until we go below cut-off. Do not
                    "assume range is available, so just ask for step
                    "same as vacuum.  Electron transport will reduce
                    "into little steps.
                    "(Note: ae is the lower threshold for creation of a
                    "       secondary Moller electron, ap is the lower
                    "       threshold for creation of a brem.)
                    tstep = vacdst;
                    sig0 = 1.E-15;
                ]
                ELSE
                [
                    $CALCULATE-TSTEP-FROM-DEMFP;
                ] "end sig if-else

                "calculate stopping power"
                IF(lelec < 0) [$EVALUATE dedx0 USING ededx(elke);] "e-"
                ELSE          [$EVALUATE dedx0 USING pdedx(elke);] "e+"
                dedx  = rhof*dedx0;

                "Determine maximum step-size (Formerly $SET-TUSTEP)
                $EVALUATE tmxs USING tmxs(elke);
                tmxs = tmxs/rhof;

                "Compute the range to E_min(medium) (e_min is the first
                "energy in the table). Do not go more than range.
                "Don't replace this macro and don't override range, because
                "the energy loss evaluation below relies on the accurate
                "(and self-consistent) evaluation of range!
                $COMPUTE-RANGE;

                "The RANDOMIZE-TUSTEP option as coded by AFB forced the
                "electrons to approach discrete events (Moller,brems etc.)
                "only in a single scattering mode => waste of CPU time.
                "Moved here and changed by IK Oct 22 1997
                random_tustep = $RANDOMIZE-TUSTEP;
                IF(random_tustep)
                [
                    $RANDOMSET rnnotu;
                    tmxs = rnnotu*min(tmxs,smaxir(irl));
                ]
                ELSE
                [
                    tmxs = min(tmxs,smaxir(irl));
                ]
                tustep = min(tstep,tmxs,range);
                $SET-TUSTEP-EM-FIELD; "optional tustep restriction in EM field

                $CALL-HOWNEAR(tperp);
                dnear(np) = tperp;
                $RANGE-DISCARD;       "optional regional range rejection for"
                                      "particles below e_max_rr if i_do_rr set"

                $USER-RANGE-DISCARD;  "default is ;, but user may implement"

                $SET-SKINDEPTH(eke,elke);
                  "This macro sets the minimum step size for a condensed"
                  "history (CH) step. When the exact BCA is used, the minimum"
                  "CH step is determined by efficiency considerations only"
                  "At about 3 elastic MFP's single scattering becomes more"
                  "efficient than CH and so the algorithm switches off CH"
                  "If one of the various inexact BCA's is invoked, this macro"
                  "provides a simple way to include more sophisticated"
                  "decisions about the maximum acceptable approximated CH step"

                tustep = min(tustep,max(tperp,skindepth));
                $EMFIELD_INITIATE_SET_TUSTEP;
                "The transport logic below is determined by the logical
                "variables callhhowfar, domultiple and dosingle
                "
                "There are the following possibilities:
                "
                "   callhowfar = .false.  This indicates that the
                "   ====================  intended step is shorter than tperp
                "                         independent of BCA used
                "  - domultiple = .false. dosingle = .false. and
                "                         callmsdist = .true.
                "       ==> everything has been done in msdist
                "  - domultiple = .true. and dosingle = .false.
                "       ==> should happen only if exact_bca = .false.
                "           indicates that MS remains to be done
                "  - domultiple = .false. and dosingle = .true.
                "       ==> should happen only if exact_bca = .true.
                "           sampled distance to a single scattering event is
                "           shorter than tperp ==> do single scattering at the
                "           end of the step
                "  - domultiple = .true. and dosingle = .true.
                "       ==> error condition, something with the logic is wrong!
                "
                "   callhowfar = .true. This indicates that the intended step
                "   =================== is longer than tperp and forces a
                "                       call to hawfar which returns the
                "                       straight line distance to the boundary
                "                       in the initial direction of motion
                "                       (via a modification of ustep)
                "  - domultiple = .false. and dosingle = .false.
                "       ==> should happen only of exact_bca=.true.
                "           simply put the particle on the boundary
                "  - domultiple = .false. and dosingle = .true.
                "       ==> should happen only of exact_bca=.true.
                "           single elastic scattering has to be done
                "  - domultiple = .true. and dosingle = .false.
                "       ==> should happen only of exact_bca=.false.
                "           indicates that MS remains to be done
                "  - domultiple = .true. and dosingle = .true.
                "       ==> error condition, something with the logic is wrong!

                "IF(tustep <= tperp & tustep > skindepth)"
                "This statement changed to be consistent with PRESTA-I"
                count_all_steps = count_all_steps + 1;
                is_ch_step = .false.;
                IF((tustep <= tperp) & ((~exact_bca) | (tustep > skindepth)))
                [
                    "We are further way from a boundary than a skindepth, so
                    "perform a normal condensed-history step
                    callhowfar = .false.; "Do not call HAWFAR
                    domultiple = .false.; "Multiple scattering done here
                    dosingle   = .false.; "MS => no single scattering
                    callmsdist = .true.;  "Remember that msdist has been called

                    "Fourth order technique for de
                    $COMPUTE-ELOSS-G(tustep,eke,elke,lelke,de);

                    tvstep = tustep; is_ch_step = .true.;

                    IF (transport_algorithm = $PRESTA-II)
                    [
                      call msdist_pII
                      (
                        "Inputs
                        eke,de,tustep,rhof,medium,qel,spin_effects,
                        u(np),v(np),w(np),x(np),y(np),z(np),
                        "Outputs
                        uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
                      );
                    ]
                    ELSE
                    [
                      call msdist_pI
                      (
                        "Inputs
                        eke,de,tustep,rhof,medium,qel,spin_effects,
                        u(np),v(np),w(np),x(np),y(np),z(np),
                        "Outputs
                        uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
                      );
                    ]
                ]
                ELSE
                [
                    "We are within a skindepth from a boundary, invoke
                    "one of the various boundary-crossing algorithms
                    callmsdist = .false.;
                         "Remember that msdist has not been called
                    IF (exact_bca)
                    [
                        "Cross the boundary in a single scattering mode
                        domultiple = .false.; "Do not do multiple scattering
                        "Sample the distance to a single scattering event
                        $RANDOMSET rnnoss;
                        IF( rnnoss < 1.e-30 ) [
                            rnnoss = 1.e-30;
                        ]
                        lambda = - Log(1 - rnnoss);
                        lambda_max = 0.5*blccl*rm/dedx*(eke/rm+1)**3;
                        IF( lambda >= 0 & lambda_max > 0 ) [
                            IF( lambda < lambda_max ) [
                                tuss=lambda*ssmfp*(1-0.5*lambda/lambda_max);
                            ]
                            ELSE [
                              tuss = 0.5 * lambda * ssmfp;
                            ]
                            IF (tuss < tustep) [
                                tustep = tuss;
                                dosingle = .true.;
                            ]
                            ELSE [
                                dosingle = .false.;
                            ]
                        ]
                        ELSE [
                          $egs_warning(*,' lambda > lambda_max: ',
                             lambda,lambda_max,' eke dedx: ',eke,dedx,
                             ' ir medium blcc: ',ir(np),medium,blcc(medium),
                             ' position = ',x(np),y(np),z(np));
                          dosingle = .false.;
                          np=np-1; return;
                        ]
                        ustep = tustep;
                    ]
                    ELSE
                    [
                        "Boundary crossing a la EGS4/PRESTA-I but using
                        "exact PLC
                        dosingle = .false.;
                        domultiple = .true.;
                        $SET-USTEP;
                    ]
                    IF(ustep < tperp)
                    [
                        callhowfar = .false.;
                    ]
                    ELSE
                    [
                        callhowfar = .true.;
                    ]
                ]
            ] "end non-vacuum test

            $SET-USTEP-EM-FIELD;  "additional ustep restriction in em field
                                  "default for $SET-USTEP-EM-FIELD; is ;(null)
            irold  = ir(np); "save current region
            irnew  = ir(np); "default new region is current region
            idisc  = 0; "default is no discard (this flag is initialized here)
            ustep0 = ustep; "Save the intended ustep."

            "IF(callhowfar) [ call howfar; ]"
            $CALL-HOWFAR-IN-ELECTR; "The above is the default replacement"

            "Now see if user requested discard
            IF(idisc > 0) "(idisc is returned by howfar)
            [
                "User requested immediate discard
                go to :USER-ELECTRON-DISCARD:;
            ]

            $CHECK-NEGATIVE-USTEP;

            IF(ustep = 0 | medium = 0)
            [
                "Do fast step in vacuum
                IF(ustep ~= 0)
                [
                    IF $EM_MACROS_ACTIVE
                    [
                        edep = pzero; "no energy loss in vacuum
                        "transport in EMF in vacuum:"
                        "only a B or and E field can be active"
                        "(not both at the same time)"
                        $EMFieldInVacuum;
                    ]
                    ELSE
                    [
                        "Step in vacuum
                        vstep  = ustep;
                        tvstep = vstep;
                        "( vstep is ustep truncated (possibly) by howfar
                        " tvstep is the total curved path associated with vstep)
                        edep = pzero; "no energy loss in vacuum
                        $VACUUM-ADD-WORK-EM-FIELD;
                            "additional vacuum transport in em field
                        e_range = vacdst;
                        $AUSCALL($TRANAUSB);
                        "Transport the particle
                        x(np) = x(np) + u(np)*vstep;
                        y(np) = y(np) + v(np)*vstep;
                        z(np) = z(np) + w(np)*vstep;
                        dnear(np) = dnear(np) - vstep;
                            "(dnear is distance to the nearest boundary
                            " that goes along with particle stack and
                            " which the user's howfar can supply (option)
                        $SET-ANGLES-EM-FIELD;
                            "default for $SET-ANGLES-EM-FIELD; is ; (null)
                             "(allows for EM field deflection
                    ] "end of EM_MACROS_ACTIVE block"
                ] "end of vacuum step

                IF(irnew ~= irold) [ $electron_region_change; ];

                IF(ustep ~= 0) [$AUSCALL($TRANAUSA);]
                IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
                IF(ustep ~= 0 & idisc < 0) [go to :USER-ELECTRON-DISCARD:;]
                NEXT :TSTEP: ; "(Start again at :TSTEP:)

            ] "Go try another big step in (possibly) new medium

            vstep = ustep;
            $EM_FIELD_SS;
            IF(callhowfar)
            [
                IF(exact_bca)
                [
                    "If callhowfar=.true. and exact_bca=.true. we are"
                    "in a single scattering mode"
                    tvstep = vstep;
                    IF(tvstep ~= tustep)
                    [
                       "Boundary was crossed. Shut off single scattering"
                        dosingle = .false.;
                    ]
                ]
                ELSE
                [
                    "callhowfar=.true. and exact_bca=.false."
                    "=>we are doing an approximate CH step"
                    "calculate the average curved path-length corresponding"
                    "to vstep"
                    $SET-TVSTEP;
                ]
                "Fourth order technique for dedx
                "Must be done for an approx. CH step or a
                "single scattering step.
                $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
            ]
            ELSE
            [
               "callhowfar=.false. => step has not been reduced due to
               "                      boundaries
               tvstep = tustep;
               IF ( ~callmsdist )
               [
                  "Second order technique for dedx
                  "Already done in a normal CH step with call to msdist
                  $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
               ]
            ]

            $SET-TVSTEP-EM-FIELD; "additional path length correction in em field
                "( Calculates tvstep given vstep
                " default for $SET-TVSTEP-EM-FIELD; is ; (null)

            save_de = de;     "the energy loss is used to calculate the number
                              "of MFP gone up to now. If energy loss
                              "fluctuations are implemented, de will be
                              "changed in $DE-FLUCTUATION; => save

            "The following macro template allows the user to change the
            "ionization loss.
            "(Provides a user hook for Landau/Vavilov processes)
            $DE-FLUCTUATION;
                "default for $DE-FLUCTUATION; is ; (null)
            edep = de; "energy deposition variable for user
            $ADD-WORK-EM-FIELD;  "e-loss or gain in em field
            $ADD_WORK_EM_FIELD;  "EEMF implementation"
                "Default for $ADD-WORK-EM-FIELD; is ; (null)
            ekef = eke - de;  "(final kinetic energy)
            eold = eie;       "save old value
            enew = eold - de; "energy at end of transport

            "Now do multiple scattering
            IF ( ~callmsdist )   "everything done if callmsdist = .true.
            [
                IF ( domultiple )
                [
                    "Approximated CH step => do multiple scattering
                    "
                    "ekems, elkems, beta2 have been set in either $SET-TUSTEP
                    "or $SET-TVSTEP if spin_effects is .true., they are
                    "not needed if spin_effects is .false.
                    "
                    "chia2,etap,xi,xi_corr are also set in the above macros
                    "
                    "qel (0 for e-, 1 for e+) and medium are now also required
                    "(for the spin rejection loop)
                    "
                    lambda = blccl*tvstep/beta2/etap/(1+chia2);
                    xi = xi/xi_corr;
                    findindex = .true.; spin_index = .true.;
                    call mscat(lambda,chia2,xi,elkems,beta2,qel,medium,
                               spin_effects,findindex,spin_index,
                               costhe,sinthe);
                ]
                ELSE
                [
                    IF(dosingle)
                    [
                       "Single scattering

                       ekems = Max(ekef,ecut(irl)-rm);
                       p2 = ekems*(ekems + rmt2);
                       beta2 = p2/(p2 + rmsq);
                       chia2 = xcc(medium)/(4*blcc(medium)*p2);
                       IF( spin_effects ) [
                         elkems = Log(ekems);
                         $SET INTERVAL elkems,eke;
                         IF(lelec < 0) [$EVALUATE etap USING etae_ms(elkems);]
                         ELSE          [$EVALUATE etap USING etap_ms(elkems);]
                         chia2 = chia2*etap;
                       ]
                       call sscat(chia2,elkems,beta2,qel,medium,
                                  spin_effects,costhe,sinthe);
                    ]
                    ELSE
                    [
                       theta  = 0; "No deflection in single scattering model
                       sinthe = 0;
                       costhe = 1;
                    ]
                ]
            ]

            "We now know distance and amount of energy loss for this step,
            "and the angle by which the electron will be scattered. Hence,
            "it is time to call the user and inform him of this transport,
            "after which we will do it.

            "Now transport, deduct energy loss, and do multiple scatter.
            e_range = range;
            /******* trying to save evaluation of range.
            the_range = the_range - tvstep*rhof;
            ********/

            /*
               Put expected final position and direction in common
               block variables so that they are available to the
               user for things such as scoring on a grid that is
               different from the geometry grid
            */
            IF( callmsdist ) [
               "Deflection and scattering have been calculated/sampled in msdist
                u_final = uscat;
                v_final = vscat;
                w_final = wscat;
                x_final = xtrans;
                y_final = ytrans;
                z_final = ztrans;
            ]
            ELSE
            [
                IF ~($EM_MACROS_ACTIVE)
                [
                    x_final = x(np) + u(np)*vstep;
                    y_final = y(np) + v(np)*vstep;
                    z_final = z(np) + w(np)*vstep;
                ]

                IF ( domultiple | dosingle )
                [
                    u_tmp = u(np); v_tmp = v(np); w_tmp = w(np);
                    call uphi(2,1); "Apply the deflection, save call to uphi if
                                    "no deflection in a single scattering mode
                    u_final = u(np); v_final = v(np); w_final = w(np);
                    u(np) = u_tmp; v(np) = v_tmp; w(np) = w_tmp;
                ]
                ELSE [ u_final = u(np); v_final = v(np); w_final = w(np); ]
            ]

            $AUSCALL($TRANAUSB);

            "Transport the particle

            x(np) = x_final; y(np) = y_final; z(np) = z_final;
            u(np) = u_final; v(np) = v_final; w(np) = w_final;

            dnear(np) = dnear(np) - vstep;
            irold = ir(np); "save previous region
            $SET-ANGLES-EM-FIELD;
            "Default for $SET-ANGLES-EM-FIELD; is ; (null)


            "Now done with multiple scattering,
            "update energy and see if below cut
            "below subtracts only energy deposited"
            peie  = peie - edep;
            "below subtracts energy deposited + work due to E field"
            "peie = peie - de;"
            eie   = peie;
            e(np) = peie;

            "IF( irnew ~= irl & eie <= ecut(irl)) [
            "IK: the above is clearly a bug. If the particle energy falls "
            "    below ecut, but the particle is actually entering a new "
            "    region, the discard will happen in the current region "
            "    instead the next. If the particle is a positron, all "
            "    resulting annihilation photons will have the new position "
            "    but the old region => confusion in the geometry routine "
            "    is very likely.      Jan 27 2004 "
            IF( irnew = irl & eie <= ecut(irl)) [
               go to :ECUT-DISCARD:;
            ]

            medold = medium;
            IF(medium ~= 0)
            [
                ekeold = eke; eke = eie - rm; "update kinetic energy
                elke   = log(eke);
                $SET INTERVAL elke,eke; "Get updated interval
            ]

            IF(irnew ~= irold) [ $electron_region_change; ]

            "After transport call to user scoring routine
            $AUSCALL($TRANAUSA);

            IF(eie <= ecut(irl)) [
               go to :ECUT-DISCARD:;
            ]

            "Now check for deferred discard request.  May have been set
            "by either howfar, or one of the transport ausgab calls
            IF(idisc < 0) [
              go to :USER-ELECTRON-DISCARD:;
            ]

            IF(medium ~= medold) NEXT :TSTEP:;

            $USER_CONTROLS_TSTEP_RECURSION;
                "NRCC update 87/12/08--default is null

            $UPDATE-DEMFP;

        ] UNTIL(demfp < $EPSEMFP); "end ustep loop

        "Compute final sigma to see if resample is needed.
        "this will take the energy variation of the sigma into
        "account using the fictitious sigma method.

        $EVALUATE-SIGF;

        sigratio = sigf/sig0;

        $RANDOMSET rfict;

    ] UNTIL (rfict <= sigratio) ; "end tstep loop

    " Now sample electron interaction

    IF(lelec < 0)
    [
        "e-,check branching ratio
        $EVALUATE-EBREM-FRACTION;
          "Default is $EVALUATE ebr1 USING ebr1(elke);"
        $RANDOMSET rnno24;
        IF(rnno24 <= ebr1)
        [
            "It was bremsstrahlung
            go to :EBREMS:;
        ]
        ELSE
        [
            "It was Moller, but first check the kinematics.
            "However, if EII is on, we should still permit an interaction
            "even if E<moller threshold as EII interactions go down to
            "the ionization threshold which may be less than thmoll.
            IF(e(np) <= thmoll(medium) & eii_flag = 0)
                 "(thmoll = lower Moller threshold)
            [
                "Not enough energy for Moller, so
                "force it to be a bremsstrahlung---provided ok kinematically.
                IF(ebr1 <= 0) [go to :NEWELECTRON:;]
                    "Brems not allowed either.
                go to :EBREMS:;
            ]
            $AUSCALL($MOLLAUSB);
            call moller;
            "The following macro template allows the user to change the
            "particle selection scheme (e.g., adding importance sampling
            "such as splitting, leading particle selection, etc.).
            "(Default macro is template '$PARTICLE-SELECTION-ELECTR'
            "which in turn has the 'null' replacement ';')
            $PARTICLE-SELECTION-MOLLER;
            $AUSCALL($MOLLAUSA);
            IF( iq(np) = 0 ) return;
        ]

        go to :NEWELECTRON:; "Electron is lowest energy-follow it
    ]

    "e+ interaction. pbr1 = brems/(brems + bhabha + annih
    $EVALUATE-PBREM-FRACTION;
       "Default is $EVALUATE pbr1 USING pbr1(elke);"
    $RANDOMSET rnno25;
    IF(rnno25 < pbr1) [go to :EBREMS:;] "It was bremsstrahlung
    "Decide between bhabha and annihilation
    "pbr2 is (brems + bhabha)/(brems + bhabha + annih)
    $EVALUATE-BHABHA-FRACTION;
       "Default is $EVALUATE pbr2 USING pbr2(elke);"
    IF(rnno25 < pbr2)
    [
        "It is bhabha
        $AUSCALL($BHABAUSB);
        call bhabha;
        "The following macro template allows the user to change the
        "particle selection scheme (e.g., adding importance sampling
        "such as splitting, leading particle selection, etc.).  (default
        "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
        "has the 'null' replacement ';')
        $PARTICLE-SELECTION-BHABHA;
        $AUSCALL($BHABAUSA);
        IF( iq(np) = 0 ) return;
    ]
    ELSE
    [
        "It is in-flight annihilation
        $AUSCALL($ANNIHFAUSB);
        call annih;
        "The following macro template allows the user to change the
        "particle selection scheme (e.g., adding importance sampling
        "such as splitting, leading particle selection, etc.).  (default
        "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
        "has the 'null' replacement ';')
        $PARTICLE-SELECTION-ANNIH;
        $AUSCALL($ANNIHFAUSA);
        EXIT :NEWELECTRON:; "i.e., in order to return to shower
        "After annihilation the gammas are bound to be the lowest energy
        "particles, so return and follow them.
    ] "end pbr2 else

] REPEAT "newelectron

return; "i.e., return to shower


"---------------------------------------------
"Bremsstrahlung-call section
"---------------------------------------------
:EBREMS:
$AUSCALL($BREMAUSB);
call brems;
"The following macro template allows the user to change the particle
"selection scheme (e.g., adding importance sampling such as splitting,
"leading particle selection, etc.).  (default macro is template
"'$PARTICLE-SELECTION-ELECTR' which in turn has the 'null' replacement ';')
$PARTICLE-SELECTION-BREMS;
$AUSCALL($BREMAUSA);
IF(iq(np) = 0)
[
    "Photon was selected.
    return;
    "i.e., return to shower
]
ELSE
[
    "Electron was selected
    go to :NEWELECTRON:;
]

"---------------------------------------------
"Electron cutoff energy discard section
"---------------------------------------------
:ECUT-DISCARD:
IF( medium > 0 ) [
    IF(eie > ae(medium)) [
        idr = $EGSCUTAUS;
        IF(lelec < 0) [edep = e(np) - prm;] ELSE[$POSITRON-ECUT-DISCARD;]
    ]
    ELSE [ idr = $PEGSCUTAUS; edep = e(np) - prm; ]
] ELSE [idr = $EGSCUTAUS; edep = e(np) - prm; ]


$ELECTRON-TRACK-END; "The default replacement for this macros is "
                     "          $AUSCALL(idr);                   "
                     "Use this macro if you wish to modify the   "
                     "treatment of track ends                    "

:POSITRON-ANNIHILATION:; "NRCC extension 86/9/12

IF(lelec > 0) [
    "It's a positron. Produce annihilation gammas if edep < peie
    IF(edep < peie) [
        $AUSCALL($ANNIHRAUSB);
        call annih_at_rest;
        $PARTICLE-SELECTION-ANNIHREST;
        $AUSCALL($ANNIHRAUSA);
        "Now discard the positron and take normal return to follow
        "the annihilation gammas.
        return; "i.e., return to shower
    ]
] "end of positron block

np = np - 1;
ircode = 2; "tell shower an e- or un-annihilated
            "e+ has been discarded

return; "i.e., return to shower"

"---------------------------------------------
"User requested electron discard section
"---------------------------------------------
:USER-ELECTRON-DISCARD:

idisc = abs(idisc);

IF((lelec < 0) | (idisc = 99))[edep = e(np) - prm;]
ELSE                          [edep = e(np) + prm;]

$AUSCALL($USERDAUS);

IF(idisc = 99) goto :POSITRON-ANNIHILATION:;

np = np - 1; ircode = 2;

return; "i.e., return to shower
end;    "End of subroutine electr
"*******************************************************************************


%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE HATCH;
"                                                                  "
"******************************************************************"
"   Setup which the user is expected to do before calling HATCH is:"
"     1. SET 'NMED' TO THE NUMBER OF MEDIA TO BE USED."
"     2. SET THE ARRAY 'MEDIA', WHICH CONTAINS THE NAMES OF THE"
"        MEDIA THAT ARE DESIRED.  THE CHARACTER FORMAT IS A1, SO"
"        THAT MEDIA(IB,IM) CONTAINS THE IB'TH BYTE OF THE NAME OF"
"        THE IM'TH MEDIUM IN A1 FORMAT."
"     3. SET 'DUNIT', THE DISTANCE UNIT TO BE USED."
"        DUNIT.GT.0 MEANS VALUE OF DUNIT IS LENGTH OF DISTANCE UNIT"
"        CENTIMETERS.  DUNIT.LT.0 MEANS USE THE RADIATION LENGTH OF"
"        THE ABS(DUNIT)'TH MEDIUM FOR THE DISTANCE UNIT."
"     4. FILL THE ARRAY 'MED' WITH THE MEDIUM INDICES FOR THE"
"        REGIONS."
"     5. FILL ARRAYS 'ECUT' AND 'PCUT' WITH THE ELECTRON AND PHOTON"
"        CUT-OFF ENERGIES FOR EACH REGION RESPECTIVELY.  SETUP WILL"
"        RAISE THESE IF NECESSARY TO MAKE THEM AT LEAST AS LARGE AS"
"        THE REGION'S MEDIUM'S AE AND AP RESPECTIVELY."
"     6. FILL 'MED' ARRAY.  MED(IR) IS THE MEDIUM INDEX FOR REGION"
"        IR.  A ZERO MEDIUM INDEX MEANS THE REGION IS IN A VACUUM."
"     7. FILL THE ARRAY 'IRAYLR' WITH 1 FOR EACH REGION IN WHICH"
"        RAYLEIGH (COHERENT) SCATTERING IS TO BE INCLUDED."
"
"   KMPO = 8 and KMPI = 12 are set in BLOCK DATA"
"   The echo to unit 8 has been removed since it is sent"
"                                          to /dev/null anyway!"
"           To put it back search $UOUTPUT  and $ECHO and uncomment"
"******************************************************************"

$IMPLICIT-NONE;

character*512 toUpper;
$COMIN-HATCH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,BOUNDS,BREMPR,EGS-VARIANCE-REDUCTION,"
                      "ELECIN,MEDIA,MISC,PHOTIN,STACK,
                      "THRESH,UPHIIN,UPHIOT,USEFUL,USER,RANDOM/;

$DECLARE-PEGS4-COMMON-BLOCKS;

$DEFINE-LOCAL-VARIABLES-HATCH;

character*256 tmp_string;
$INTEGER      lnblnk1;" in house lnblnk function becuase not all compilers"
                      " support this"

DATA MDLABL/$S' MEDIUM='/,LMDL/8/,LMDN/24/,DUNITO/1./;
DATA I1ST/1/,NSINSS/37/,MXSINC/$MXSINC/,ISTEST/0/,NRNA/1000/;

$INIT-PEGS4-VARIABLES;

"   FORMAT STATEMENTS USED MULTIPLE TIMES IN SETUP"
:INT:FORMAT(1X,14I5);
:FLT:FORMAT(1X,1PE14.5,4E14.5);
:BYTE:FORMAT(72A1);

IF (I1ST.NE.0)[ I1ST=0;"RESET FIRST TIME FLAG"
"   DO FIRST TIME INITIALIZATION"

$HATCH-USER-INPUT-INIT;

"   NOW CONSTRUCT PIECEWISE LINEAR FIT TO SINE FUNCTION OVER THE"
"   INTERVAL (0,5*PI/2).  DIVIDE THIS INTERVAL INTO MXSINC SUB-"
"   INTERVALS.  EACH OF THESE SUBINTERVALS IS THEN SUBDIVIDED INTO"
"   NSINSS SUB-SUB-INTERVALS.  THE ANGLES AT THE BOUNDARIES OF"
"   THESE SUB-SUB-INTERVALS AND THEIR SINES ARE USED TO COMPUTE"
"   LEAST SQUARES COEFFICIENTS FOR THE SUBINTERVAL.  AN EXTRA"
"   SUBINTERVAL ON EACH SIDE OF THE INTERVAL (0,5*PI/2) IS INCLUDED"
"   FOR GOOD MEASURE."
NISUB=MXSINC-2;FNSSS=NSINSS;
WID=PI5D2/FLOAT(NISUB);
WSS=WID/(FNSSS-1.0);
ZEROS(1)=0.;ZEROS(2)=PI; ZEROS(3)=TWOPI;

DO ISUB=1,MXSINC ["LOOP OVER SUBINTERVALS"
SX=0.;SY=0.;SXX=0.;SXY=0.;"ZERO SUMS"

XS0=WID*FLOAT(ISUB-2);XS1=XS0+WID;"LOWER & UPPER LIMITS"
"   NOW CHECK TO SEE IF ANY ZEROS ARE IN THE INTERVAL"
IZ=0; DO IZZ=1,3 [
IF ((XS0.LE.ZEROS(IZZ)).AND.(ZEROS(IZZ).LE.XS1))[IZ=IZZ;EXIT;]
] "END OF LOOP OVER ZEROS"
IF (IZ.EQ.0)[XSI=XS0;]ELSE[XSI=ZEROS(IZ);]
DO ISS=1,NSINSS ["LOOP OVER SUB-SUBINTERVALS"
XS=WID*FLOAT(ISUB-2)+WSS*FLOAT(ISS-1)-XSI; "ANGLE VALUE"
YS=SIN(XS+XSI); "SINE OF ANGLE"
SX=SX+XS; "ACCUMULATE SUMS"
SY=SY+YS;
SXX=SXX+XS*XS;
SXY=SXY+XS*YS;
] "END SUB-SUBINTERVAL LOOP"

"   NOW COMPUTE LEAST SQUARES COEFFICIENTS"
IF (IZ.NE.0)["FORCE FIT THROUGH SINES' ZEROS,"
"             FOR SMALL REL.ERR.&GOOD"
"   VALUES OF SINTHE/THETA NEAR ZERO"
SIN1(ISUB)=SXY/SXX;
SIN0(ISUB)=-SIN1(ISUB)*XSI;]
ELSE["DO FULL LEAST SQUARES"
DEL=FNSSS*SXX-SX*SX;
SIN1(ISUB)=(FNSSS*SXY-SY*SX)/DEL;
SIN0(ISUB)=(SY*SXX-SX*SXY)/DEL - SIN1(ISUB)*XSI ; ]
] "END SUB-INTERVAL LOOP"

SINC0=2.0 ;"SET COEFFICIENTS WHICH DETERMINE INTERVAL"
SINC1=1.0/WID;

"   NOW TEST FIT, IF REQUESTED"
IF (ISTEST.NE.0)[
"   FIRST TEST AT POINTS PREVIOUSLY COMPUTED, EXCLUDING"
"   END SUBINTERVALS"
ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
DO ISUB=1,NISUB [ DO ISS=1,NSINSS [
THETA=WID*FLOAT(ISUB-1)+WSS*FLOAT(ISS-1);
CTHET=PI5D2-THETA;
$SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
$EVALUATE SINTHE USING SIN(THETA);
$EVALUATE COSTHE USING SIN(CTHET);
SINT=SIN(THETA); COST=COS(THETA);
ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
ADEV=max(ADEV,ASD,ACD);
IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
S2C2=SINTHE**2+COSTHE**2;
S2C2MN=min(S2C2MN,S2C2);
S2C2MX=max(S2C2MX,S2C2);
IF (ISUB.LT.11)[$egs_info('(1PE20.7,4E20.7)',THETA,SINTHE,SINT,COSTHE,COST);]
] ] "END OF FIXED INTERVAL TEST-OUTPUT RESULTS"
$egs_info('(a,2i5)',' SINE TESTS,MXSINC,NSINSS=',MXSINC,NSINSS);
$egs_info('(a,1PE16.8,3e16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
                                 ADEV,RDEV,S2C2MN,S2C2MX);
"   NOW DO RANDOM TEST"
ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
DO IRN=1,NRNA[ $RANDOMSET THETA;THETA=THETA*PI5D2;
CTHET=PI5D2-THETA;
$SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
$EVALUATE SINTHE USING SIN(THETA);
$EVALUATE COSTHE USING SIN(CTHET);
SINT=SIN(THETA); COST=COS(THETA);
ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
ADEV=max(ADEV,ASD,ACD);
IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
S2C2=SINTHE**2+COSTHE**2;
S2C2MN=min(S2C2MN,S2C2);
S2C2MX=max(S2C2MX,S2C2);
] "END RANDOM ANGLE LOOP"
$egs_info('(a,i7,a)', ' TEST AT ',NRNA,' RANDOM ANGLES IN (0,5*PI/2)');
$egs_info('(1PE16.8,3E16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
                               ADEV,RDEV,S2C2MN,S2C2MX);
] "END OF SINE TABLE TEST"

"   NOW FILL IN POWER OF TWO TABLE.  PWR2I(I)=1/2**(I-1)"
P=1.; DO I=1,$MXPWR2I [PWR2I(I)=P; P=P/2.;]

] "END OF FIRST TIME INITIALIZATION"

"FILL IRAYLM ARRAY BASED ON IRAYLR INPUTS"
$need_rayleigh_data;

"Ali:photonuc, 2 lines"
"FILL IPHOTONUCM ARRAY BASED ON IPHOTONUCR INPUTS"
$need_photonuc_data;
$egs_info('(a,i3)',' ===> Photonuclear flag: ', iphotonuc);

"   NOW SEARCH FILE FOR DATA FOR REQUESTED MATERIALS"
IF(~is_pegsless) REWIND KMPI;
"explicit file name for HP compiler  Nov 23, 1996   DR"
IUECHO=KMPO;
NM=0; "NUMBER OF MEDIA FOUND"
DO IM=1,NMED [LOK(IM)=0;"SET FLAG TELLING WHICH MEDIA ARE OK"
  "NOW TELL USER IF RAYLEIGH OPTION HAS BEEN REQUESTED"
  IF(IRAYLM(IM).EQ.1) [
     $egs_info('(a,i3/)', ' RAYLEIGH OPTION REQUESTED FOR MEDIUM NUMBER',IM);
  ]
]

"Ali:photonuc, 1 block"
DO IM=1,NMED [
  "TELL USER IF PHOTONUC HAS BEEN REQUESTED"
  IF(IPHOTONUCM(IM).EQ.1) [
     $egs_info('(a,i3/)', ' PHOTONUCLEAR REQUESTED FOR MEDIUM NUMBER',IM);
  ]
]

IF(~is_pegsless)[
:MEDIUM:
LOOP["MEDIUM SEARCH LOOP"

:MDLOOK:
LOOP["MEDIUM HEADER SEARCH LOOP"
  "   FIRST LOOK FOR MEDIUM HEADER"
  READ(KMPI,:BYTE:,END=:MDNOMORE:)MBUF;
  DO IB=1,LMDL [IF (MBUF(IB).NE.MDLABL(IB))NEXT:MDLOOK:;]
  "   HEADER MATCHES. NOW SEE IF IT IS ONE OF REQUESTED MEDIA"
  :MDNAME:
  DO IM=1,NMED [
    DO IB=1,LMDN [IL=LMDL+IB; IF (MBUF(IL).NE.MEDIA(IB,IM))NEXT:MDNAME:;
    IF (IB.EQ.LMDN)EXIT:MDLOOK:; ]
  ] "END :MDNAME: DO"
  "   NOT IN NAME TABLE, SO IGNORE IT"
]REPEAT "MDLOOK"

"   'IM' IS THE INDEX OF THE MEDIUM READY TO BE READ"
IF (LOK(IM).NE.0)GO TO :MDLOOK:;"WE ALREADY HAVE THIS ONE"
LOK(IM)=1;NM=NM+1;"SET FOUND FLAG AND STEP MEDIUM COUNTER"

"   NOW READY TO READ IN DATA FOR THIS MEDIUM"
"$UOUTPUT(KMPO)IM,MBUF;(' DATA FOR MEDIUM #',I3,', WHICH IS:',72A1);"

"   NOW PUT OUT LINES SHOWING COMPOSITION OF MEDIUM"
"THE FOLLOWING LINE WAS CHANGED TO STORE THE ELEMENTAL COMPOSITION AFB 88/05/31"
"$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NE;"
"The next two lines were line prior to Dec 89 mods to get IUNRST"
"$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
"(5A1,5X,F11.0,4X,I2);"
"following used to pick up IUNRST, IAPRIM and EPSTFL"
"Problem is that GASP may or may not be printed, so we make"
"a kludge which will work with all old data files"
"FIRST WE ASSUME THERE IS NO GASP VALUE IN THE LINE"
"Note that this reading scheme counts on there being an"
"error when GASP does exist on the line--an error does"
"occur on most compilers, however, we have found that on"
"the rs6000 an error does not occur.  Instead, a warning"
"is printed out and IUNRST,EPSTFL and IAPRIM are set to 0."
"This will make no difference in simulations but will cause"
"a problem when running EXAMIN"

" IK: backspace(kmpi) fails under windows using g77 with I/O error"
"     therefore we read the line in a temporary string and then "
"     use memoty I/O to try to read with and without gasp there. "

read(kmpi,'(a)',err=:hatch_read_error1:) tmp_string;
goto :no_hatch_read_error1:;
:hatch_read_error1:
$egs_fatal(*,'Error while reading pegs4 file');

:no_hatch_read_error1:;
read(tmp_string,1,ERR=:GASP-THERE:)
"READ(KMPI,1,ERR=:GASP-THERE:)"
(MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),IAPRIM(IM);
1   FORMAT(5A1,5X,F11.0,4X,I2,9X,I1,9X,I1,9X,I1);
"IUNRST, EPSTFL AND IAPRIM ARE STORED IN COMIN ELECIN"
GO TO :GASP-NOT-THERE:;

:GASP-THERE:;
"WE MUST REREAD THE LINE WITH THE CORRECT FORMAT"
"BACKSPACE(KMPI);""THIS BACKS UP ONE RECORD TO RE-READ IT"
"READ(KMPI,2)"

"The following output is only there because without it"
"code compiled with the new gfortran GNU compiler "
"fails with run time error. Another bug in their "
"pre-alpha quality I/O system ----IK, Oct 26 2005 "
"write(6,*) 'Found medium with gas pressure';"
$egs_info(*,'Found medium with gas pressure');
read(tmp_string,2)
(MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),
IAPRIM(IM);
2     FORMAT(5A1,5X,F11.0,4X,I2,26X,I1,9X,I1,9X,I1);

:GASP-NOT-THERE:

"THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
"$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NE;"
";$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
"(5A1,',RHO=',1PG11.4,',NE=',I2,',COMPOSITION IS :');"
"THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
"DO IE=1,NE["
DO IE=1,NNE(IM)[
    "THE FOLLOWING LINE, COMMENTED OUT, WAS THE OLD WAY OF READING IN "
    "THE ELEMENTAL COMPOSITION OF EACH MEDIUM. THE INFORMATION WAS NOT"
    "PASSED ON TO EGS. IN THE PRESENT VERSION IT IS READ IN AND STORED"
    "IN COMMON BREMPR. AFB 88/05/31.                                  "
    "READ(KMPI,:BYTE:)MBUF;WRITE(KMPO,:BYTE:)MBUF;"
    $UINPUT(KMPI)
    (MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),
    ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);
    (6A1,2A1,3X,F3.0,3X,F9.0,4X,F12.0,6X,F12.0);
    "$UOUTPUT(KMPO)"
    "(MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),"
    "ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);"
    "(6A1,2A1,',Z=',F3.0,',A=',F9.3,',PZ=',1PE12.5,',RHOZ=',1PE12.5);"
    ]

"   MEDIA AND THRESH"
"$ECHO" READ(KMPI,:FLT:) $LGN(RLC,AE,AP,UE,UP(IM));
TE(IM)=AE(IM)-RM; THMOLL(IM)=TE(IM)*2. + RM ;

"   ACTUAL ARRAY SIZES FROM PEGS"
"$ECHO" READ(KMPI,:INT:)
$LGN(MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE(IM)),IRAYL;
NSGE=MSGE(IM);NGE=MGE(IM);NSEKE=MSEKE(IM);NEKE=MEKE(IM);
NLEKE=MLEKE(IM);NCMFP=MCMFP(IM);NRANGE=MRANGE(IM);

"   BREMPR"
"$ECHO" READ(KMPI,:FLT:)($LGN(DL(I,IM)/1,2,3,4,5,6/),I=1,6);
"$ECHO" READ(KMPI,:FLT:)DELCM(IM),($LGN(ALPHI,BPAR,
   DELPOS(I,IM)),I=1,2);

"   ELECIN"
"$ECHO" READ(KMPI,:FLT:)$LGN(XR0,TEFF0,BLCC,XCC(IM));
"$ECHO" READ(KMPI,:FLT:)$LGN(EKE(IM)/0,1/);
"$ECHO" READ(KMPI,:FLT:)
($LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,
   TMXS(I,IM)/0,1/),I=1,NEKE);

"   PHOTIN"
"$ECHO" READ(KMPI,:FLT:)EBINDA(IM),$LGN(GE(IM)/0,1/);
"$ECHO" READ(KMPI,:FLT:)($LGN(GMFP,GBR1,GBR2(I,IM)/0,1/),I=1,NGE);

"   PHOTIN (CONTINUED)---OPTIONAL RAYLEIGH SCATTERING INPUT"

/* Leave this for compatibility with existing pegs4 data sets.  */
IF (IRAYL.EQ.1) [
"$ECHO" READ(KMPI,:INT:) NGR(IM);
NGRIM=NGR(IM);
"$ECHO" READ(KMPI,:FLT:)$LGN(RCO(IM)/0,1/);
"$ECHO" READ(KMPI,:FLT:)($LGN(RSCT(I,IM)/0,1/),I=1,NGRIM);
"$ECHO" READ(KMPI,:FLT:)($LGN(COHE(I,IM)/0,1/),I=1,NGE);
 "IF(IRAYLM(IM).NE.1) ["
 $egs_info('(a,i3,a)', ' Rayleigh data available for medium',
          IM, ' in PEGS4 data set.');
 "]"
]

/*******************************************************************
 Rayleigh data picked up directly from pgs4form.data or user-supplied
 ff file in egs_init_rayleigh unless user wants to use PEGS4 data.
*********************************************************************/
IF(IRAYLM(IM).EQ.1) ["Rayleigh data requested for medium IM"
  IF(IRAYL.NE.1) ["No data in PEGS4"
    IF(toUpper($cstring(photon_xsections))='PEGS4')
    ["Rayleigh not possible"
     $egs_fatal('(a,i3 /,a /,a)',
     ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
     IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.',
     ' YOU WILL NOT BE ABLE TO USE THE PEGS4 DATA WITH RAYLEIGH ON!');
    ]
    ELSE["Data will be taken from elsewhere (si,epdl,xcom,custom)"
     $egs_warning('(a,i3 /,a)',
     ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
     IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.');
    ]
  ]
 ELSE["Rayleigh data in PEGS4"
    IF(toUpper($cstring(photon_xsections))='PEGS4')
    ["PEGS4 data selected"
      "***********************************************************"
      "Preparing data for new Rayleigh angular sampling when using"
      "the pegs4 data set,                                        "
      "***********************************************************"
       call egs_init_rayleigh_sampling(IM);
    ]
    "ELSE[Taking photon data from either si,epdl,xcom or user]"
  ]
]
/*******************************************************************/

"   THAT'S ALL FOR THIS MEDIUM"
]UNTIL NM.GE.NMED; "LOOP UNTIL WE HAVE ENOUGH.  END :MEDIUM: LOOP"

CLOSE (UNIT=KMPI);

"   WE NOW HAVE DATA FOR ALL MEDIA REQUESTED.  NOW DO DISTANCE UNIT"
"   CHANGE.  DATA FROM PEGS IS IN UNITS OF RADIATION LENGTHS."
"   EGS IS RUN IN UNITS OF 'DUNIT' CENTIMETERS, IF DUNIT.GT.0 "
"   OR IN UNITS OF RLC(-DUNIT) CENTIMETERS IF DUNIT.LT.0."
"   THAT IS, A NEGATIVE DUNIT MEANS UNIT IS TO BE THE RADIATION"
"   LENGTH OF THE MEDIUM WHOSE INDEX IS -DUNIT"
DUNITR=DUNIT; "SAVE REQUESTED"
IF(DUNIT.LT.0.0)[ID=MAX0(1,MIN0($MXMED,int(-DUNIT)));
   DUNIT=RLC(ID);]
IF(DUNIT.NE.1.0) [
$egs_info('(a,1PE14.5,E14.5,a)',' DUNIT REQUESTED&USED ARE: ',
         DUNITR,DUNIT,'(CM.)' );
]
DO IM=1,NMED [
DFACT=RLC(IM)/DUNIT; "CONVERTS RL TO DUNITS"
DFACTI=1.0/DFACT;    "CONVERT RL**-1 TO DUNITS**-1"

FOR I=1 TO MEKE(IM) [
$SCALE $LGN(ESIG,PSIG,EDEDX,PDEDX(I,IM)/0,1/) BY DFACTI;
$SCALE $LGN(TMXS(I,IM)/0,1/) BY DFACT;]
$SCALE TEFF0(IM) BY DFACT;
$SCALE BLCC(IM) BY DFACTI;
$SCALE XCC(IM) BY SQRT(DFACTI);
RLDU(IM)=RLC(IM)/DUNIT;
FOR I=1 TO MGE(IM) [$SCALE $LGN(GMFP(I,IM)/0,1/) BY DFACT; ]
] "END IM DO"

"   SCALE VACDST.  UNDO PREVIOUS SCALE, THEN DO NEW."
VACDST=VACDST*DUNITO/DUNIT;
DUNITO=DUNIT; "SAVE OLD DUNIT"

]"end regular pegs4 intake"
ELSE["pegsless intake of medium data"

$egs_info(*,' PEGSLESS INPUT.  CALCULATING ELECTRON CROSS-SECTIONS.');

$GET-PEGSLESS-XSECTIONS;

]

"   NOW MAKE SURE ECUT AND PCUT ARE NOT LOWER THAN ANY AE OR AP"
"   ALSO SET DEFAULT DENSITIES"
$adjust_rhor_ecut_pcut;

"BREMSSTRAHLUNG ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
"NEXT LINE ADDED AFB 88/05/31"
$INITIALIZE-BREMS-ANGLE;

"PAIR ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
"NEXT LINE ADDED AFB 91/05/29"
$INITIALIZE-PAIR-ANGLE;

" See if user has requested PEGS4 photon cross section data "
IF(toUpper($cstring(photon_xsections)) = 'PEGS4')[
  $egs_warning('(6(a/))','Using photon data from PEGS4 file!!!',
  'However, the new Rayleigh angular sampling will be used.',
  'The original EGS4 angular sampling undersamples large scattering ',
  'angles. This may have little impact as Rayleigh scattering ',
  'is forward peaked.',
  '*********************************************************');

]
ELSE["re-calculates photon xsections using available or user data"
"Ali:photonuc, 2 lines"
    call egs_init_user_photon(photon_xsections,comp_xsections,
    photonuc_xsections,xsec_out);
"    call egs_init_user_photon(photon_xsections,comp_xsections,xsec_out);"
]

call mscati;       "Initialize new MS, step-sizes, etc, IK Oct 97"

"Calling order of the subroutines below is important when using"
"detailed atomic relaxation in order to use the binding energies"
"corresponding to the requested photon cross section library"
IF ( eadl_relax & photon_xsections = 'xcom' )[
   call init_compton; "Initialize bound Compton scattering"
   call EDGSET(1,1);  "Initialize relaxations and photo-absorption data"
]
ELSE[
   call EDGSET(1,1);  "Initialize relaxations and photo-absorption data,"
                      "if requested
   call init_compton; "Initialize bound compton scattering, IK, Jan 99"
                      "if requested
]

IF( xsec_out = 1 & eadl_relax) [
  call egs_print_binding_energies;
]

call fix_brems;    "Re-calculate dl1,... for the different technique"
                   "employed in BREMS. Note that the old EGS sampling"
                   "technique for BREMS had a bug that shows up only"
                   "if AP is not much smaller than electron kinetic energy"

IF( ibr_nist >= 1 ) [ call init_nist_brems; ]
                   "initializes the sampling tables and modifies the total"
                   "brems cross sections if the NIST brems data base is to"
                   "be used                                               "

IF( pair_nrc = 1 ) [ call init_nrc_pair; ]

" Load and initialize EII data if needed. "
call eii_init;

" Load and initialize the triplet data if needed "
call init_triplet;

"   SETUP IS NOW COMPLETE"
IF (NMED.EQ.1)[
   $egs_info(*,'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ONE MEDIUM.');
]
ELSE[
   $egs_info('(a,i5,a)',
             'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ',NMED,' MEDIA.');
]

RETURN;

:MDNOMORE:
$egs_info('(a,i2//,a/,a/)', ' END OF FILE ON UNIT ',KMPI,
  ' PROGRAM STOPPED IN HATCH BECAUSE THE',
  ' FOLLOWING NAMES WERE NOT RECOGNIZED:');
DO IM=1,NMED [
   IF(LOK(IM).NE.1) [
      $egs_info('(40x,a,24a1,a)','''',(MEDIA(I,IM),I=1,LMDN),'''');
   ]
]
STOP;
"END OF SUBROUTINE HATCH"   END;

subroutine fix_brems;
"******************************************************************"
"
" Calculates the parameter for the rejection function used in
" the current implementation of bremsstrahlung sampling
"
" I Kawrakow, January 2000
"
"*******************************************************************"

$IMPLICIT-NONE;
$declare_max_medium;
;COMIN/BREMPR,MEDIA,NIST-BREMS,THRESH/;

$INTEGER medium,i;
$REAL    Zt,Zb,Zf,Zg,Zv,fmax1,fmax2,Zi,pi,fc,xi,aux,
         XSIF,FCOULC;

DO medium = 1,nmed [

    log_ap(medium) = log(ap(medium));
    Zt = 0; Zb = 0; Zf = 0;
    DO i=1, NNE(medium) [
        Zi = ZELEM(medium,i); pi = PZ(medium,i);
        fc = FCOULC(Zi); xi = XSIF(Zi);
        aux = pi*Zi*(Zi + xi);
        Zt = Zt + aux;
        Zb = Zb - aux*Log(Zi)/3;
        Zf = Zf + aux*fc;
    ]
    Zv = (Zb - Zf)/Zt; Zg = Zb/Zt;
    fmax1 = 2*(20.863 + 4*Zg) - 2*(20.029 + 4*Zg)/3;
    fmax2 = 2*(20.863 + 4*Zv) - 2*(20.029 + 4*Zv)/3;

    "These are used in BREMS"
    dl1(1,medium) = (20.863 + 4*Zg)/fmax1;
    dl2(1,medium) = -3.242/fmax1;
    dl3(1,medium) = 0.625/fmax1;
    dl4(1,medium) = (21.12+4*Zg)/fmax1;
    dl5(1,medium) = -4.184/fmax1;
    dl6(1,medium) = 0.952;
    dl1(2,medium) = (20.029+4*Zg)/fmax1;
    dl2(2,medium) = -1.93/fmax1;
    dl3(2,medium) = -0.086/fmax1;
    dl4(2,medium) = (21.12+4*Zg)/fmax1;
    dl5(2,medium) = -4.184/fmax1;
    dl6(2,medium) = 0.952;
    dl1(3,medium) = (20.863 + 4*Zv)/fmax2;
    dl2(3,medium) = -3.242/fmax2;
    dl3(3,medium) = 0.625/fmax2;
    dl4(3,medium) = (21.12+4*Zv)/fmax2;
    dl5(3,medium) = -4.184/fmax2;
    dl6(3,medium) = 0.952;
    dl1(4,medium) = (20.029+4*Zv)/fmax2;
    dl2(4,medium) = -1.93/fmax2;
    dl3(4,medium) = -0.086/fmax2;
    dl4(4,medium) = (21.12+4*Zv)/fmax2;
    dl5(4,medium) = -4.184/fmax2;
    dl6(4,medium) = 0.952;

    "and these in PAIR"
    dl1(5,medium) = (3*(20.863 + 4*Zg) - (20.029 + 4*Zg));
    dl2(5,medium) = (3*(-3.242) - (-1.930));
    dl3(5,medium) = (3*(0.625)-(-0.086));
    dl4(5,medium) = (2*21.12+8*Zg);
    dl5(5,medium) = (2*(-4.184));
    dl6(5,medium) = 0.952;
    dl1(6,medium) = (3*(20.863 + 4*Zg) + (20.029 + 4*Zg));
    dl2(6,medium) = (3*(-3.242) + (-1.930));
    dl3(6,medium) = (3*0.625+(-0.086));
    dl4(6,medium) = (4*21.12+16*Zg);
    dl5(6,medium) = (4*(-4.184));
    dl6(6,medium) = 0.952;
    dl1(7,medium) = (3*(20.863 + 4*Zv) - (20.029 + 4*Zv));
    dl2(7,medium) = (3*(-3.242) - (-1.930));
    dl3(7,medium) = (3*(0.625)-(-0.086));
    dl4(7,medium) = (2*21.12+8*Zv);
    dl5(7,medium) = (2*(-4.184));
    dl6(7,medium) = 0.952;
    dl1(8,medium) = (3*(20.863 + 4*Zv) + (20.029 + 4*Zv));
    dl2(8,medium) = (3*(-3.242) + (-1.930));
    dl3(8,medium) = (3*0.625+(-0.086));
    dl4(8,medium) = (4*21.12+16*Zv);
    dl5(8,medium) = (4*(-4.184));
    dl6(8,medium) = 0.952;

    bpar(2,medium) = dl1(7,medium)/(3*dl1(8,medium) + dl1(7,medium));
    bpar(1,medium) = 12*dl1(8,medium)/(3*dl1(8,medium) + dl1(7,medium));

]
return;
end;


$REAL function FCOULC(Z);
"************************"
$IMPLICIT-NONE;
$REAL Z;
$REAL fine,asq;
data fine/137.03604/;
asq = Z/fine; asq = asq*asq;
FCOULC = asq*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+ASQ*(0.0083+ASQ*(-0.002))));
return;
end;

$REAL function XSIF(Z);
"**********************"
$IMPLICIT-NONE;
$REAL    Z;
$INTEGER iZ;
$REAL    alrad(4),alradp(4),a1440,a183,FCOULC;
data     alrad/5.31,4.79,4.74,4.71/;
data     alradp/6.144,5.621,5.805,5.924/;
data     a1440/1194.0/,A183/184.15/;
IF( Z <= 4 ) [ iZ = Z; xsif = alradp(iZ)/(alrad(iZ) - FCOULC(Z)); ]
ELSE [ xsif = Log(A1440*Z**(-0.666667))/(Log(A183*Z**(-0.33333))-FCOULC(Z)); ]
return;
end;

"******************************************************************"
subroutine init_compton;
"
"  Reads in bound Compton scattering data from unit $INCOHUNIT
"  and performs necessary initializations
"
"  See definitions of variables in egsnrc.macros with definition
"  of COMIN/COMPTON-DATA/
"
"  I.Kawrakow, January 99
"******************************************************************"

implicit none;

$COMIN-INIT-COMPT;

$INTEGER i,j,iz,nsh,j_l,j_h;
$REAL    aux,pztot,atav;
$REAL    aux_erf,erf1;  "using erf1, provided with EGSnrc, because some"
                        "compiler don't have an intrinsic error function"
$LOGICAL getd;

" Initialize radiative Compton corrections, if needed "
$RADC_HATCH;

$need_bound_compton_data(getd);
IF( ~getd ) [
    IF( eadl_relax & photon_xsections = 'xcom' )[
        $egs_fatal('(a,/a,/a)',
                   'You must turn ON Compton binding corrections when using',
                   'a detailed atomic relaxation (eadl_relax=true) since ',
                   'binding energies taken from incoh.data below 1 keV!');
    ]
    $egs_info('(a/)',' Bound Compton scattering not requested! ');
    return;
]

$egs_info('(/a$)','Bound Compton scattering requested, reading data ......');
rewind($INCOHUNIT);
DO j=1,18 [ read($INCOHUNIT,*); ]  "skip 1st 18 lines of comments"
iz = 0;
DO j=1,$MXTOTSH [
    read($INCOHUNIT,*) iz_array(j),shn_array(j),ne_array(j),
                       Jo_array(j),be_array(j);
    Jo_array(j) = Jo_array(j)*137.;
    be_array(j) = be_array(j)*1e-6/PRM;
    aux_erf = 0.70710678119*(1+0.3*Jo_array(j));
    erfJo_array(j) = 0.82436063535*(erf1(aux_erf)-1);
                    "0.82436063535 is exp(0.5)/2"

    "For detailed atomic relaxations set shell type
    "to actual shell number and update binding energies
    "with values from the photo-electric cross sections
    IF (eadl_relax)[
       IF (iz_array(j) ~= iz)[
          shn_array(j) = 1; iz = iz_array(j);
       ]
       ELSE[
          shn_array(j) = shn_array(j-1)+1;
       ]
       IF(binding_energies(shn_array(j),iz_array(j)) > 0)[
         be_array(j) = binding_energies(shn_array(j),iz_array(j))/PRM;
       ]
       ELSE IF(photon_xsections = 'xcom') [
         "Use binding energies from incoh.data below 1 keV"
         binding_energies(shn_array(j),iz_array(j)) = be_array(j)*PRM;
       ]
    ]

]
$egs_info(*,' Done');
$egs_info('(/a)',' Initializing Bound Compton scattering ......');
DO medium = 1,nmed [
    pztot = 0; nsh = 0;
    DO i = 1, nne(medium) [
        iz = int(zelem(medium,i));
        DO j = 1, $MXTOTSH [
            IF( iz = iz_array(j) ) [
                nsh = nsh + 1;
                IF( nsh > $MXMDSH ) [
                    $egs_fatal('(/a,i3,a,i4,a/,a)',' For medium ',medium,
                              ' the number of shells is > ',$MXMDSH,'!',
                              ' Increase the parameter $MXMDSH! ');
                ]
                shell_array(nsh,medium) = j;
                aux = pz(medium,i)*ne_array(j);
                eno_array(nsh,medium) = aux;
                pztot = pztot + aux;
            ]
        ]
    ]
    IF( nsh = 0 ) [
        $egs_fatal('(a,i3,a)', ' Medium ',medium,' has zero shells! ');
    ]
    n_shell(medium) = nsh;
    $egs_info('(a,i3,a,i3,a)', ' Medium ',medium,' has ',nsh,' shells: ');
    DO i=1,nsh [
        j = shell_array(i,medium);
        eno_array(i,medium) = eno_array(i,medium)/pztot;
        $egs_info('(i4,i5,i4,f9.5,e10.3,f10.3)',
                  i,j,shn_array(j),eno_array(i,medium),
                  Jo_array(j),be_array(j)*PRM*1000.);
        eno_array(i,medium) = -eno_array(i,medium);
        eno_atbin_array(i,medium) = i;
    ]
    atav = 1./nsh;
    DO i=1,nsh-1 [
        DO j_h = 1,nsh-1 [
            IF( eno_array(j_h,medium) < 0 ) [
                IF( abs(eno_array(j_h,medium)) > atav ) EXIT;
            ]
        ]
        DO j_l = 1,nsh-1 [
            IF( eno_array(j_l,medium) < 0 ) [
                IF( abs(eno_array(j_l,medium)) < atav ) EXIT;
            ]
        ]
        aux = atav - abs(eno_array(j_l,medium));
        eno_array(j_h,medium) = eno_array(j_h,medium) + aux;
        eno_array(j_l,medium) = -eno_array(j_l,medium)/atav + j_l;
        eno_atbin_array(j_l,medium) = j_h;
        IF( i = nsh-1 ) eno_array(j_h,medium) = 1 + j_h;
    ]
    DO i=1,nsh [
        IF( eno_array(i,medium) < 0 ) [ eno_array(i,medium) = 1 + i; ]
    ]
]

$egs_info('(a/)',' ...... Done.');

$need_relaxation_data(getd);
IF( getd ) return;
$egs_fatal('(/a,/a,/a,/a)',
' In subroutine init_compton: ',
'   Scattering off bound electrons creates atomic vacancies,',
'   potentially starting an atomic relaxation cascade. ',
'   Please turn ON atomic relaxations.');
/*
Turning ON relaxations to setup relaxations for bound Compton
and then turning it back OFF seems inconsistent. One should have
relaxations for all interactions with atomic electrons.

$egs_info('(a/,a/,a/,a//)',
' In subroutine init_compton: ',
'   fluorescence not set but relaxation data are required for ',
'   bound Compton scattering. ',
'   calling EDGSET. ');
iedgfl(1) = 1;              "This was (2) originally  DR"
eadl_relax = .true.;
call edgset(1,1);
iedgfl(1) = 0;              "This was (2) originally  DR"
*/
return;
end;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE MOLLER;
"                                                                  "
"******************************************************************"
"   DISCRETE MOLLER SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
"   ARBITRARILY DEFINED AND CALCULATED TO MEAN MOLLER SCATTERINGS  "
"   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
"   IT BE TRANSPORTED DISCRETELY.  THE THRESHOLD TO TRANSPORT AN   "
"   ELECTRON DISCRETELY IS A TOTAL ENERGY OF AE OR A KINETIC ENERGY"
"   OF TE=AE-RM.  SINCE THE KINETIC ENERGY TRANSFER IS ALWAYS, BY  "
"   DEFINITION, LESS THAN HALF OF THE INCIDENT KINETIC ENERGY, THIS"
"   IMPLIES THAT THE INCIDENT ENERGY, EIE, MUST BE LARGER THAN     "
"   THMOLL=TE*2+RM.  THE REST OF THE COLLISION CONTRIBUTION IS     "
"   SUBTRACTED CONTINUOUSLY FROM THE ELECTRON AS IONIZATION        "
"   LOSS DURING TRANSPORT.                                         "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-MOLLER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "  COMIN/EGS-VARIANCE-REDUCTION, DEBUG,STACK,THRESH,"
                                          "UPHIOT,USEFUL,RANDOM/;"
;COMIN/EII-DATA,ELECIN,EPCONT,EDGE,BREMPR/;

$DEFINE-LOCAL-VARIABLES-MOLLER;

$REAL sigm,pbrem,rsh,Uj,sig_j;
$INTEGER lelke,iele,ish,nsh,ifirst,i,jj,iZ,iarg;

"IRCODE=1;  appears to be unused, IK Oct 97"
NPold = NP;      "Set the old stack counter"
PEIE=E(NP);"PRECISE ENERGY OF INCIDENT ELECTRON"
EIE=PEIE; "ENERGY OF INCIDENT ELECTRON"
PEKIN=PEIE-PRM;  "PRECISE K.E. OF INCIDENT ELECTRON"
EKIN=PEKIN;

IF( eii_flag > 0 & eii_nsh(medium) > 0 ) [
    "The EII flag is set and this medium has shells for which we want to"
    "simulate EII => sample if the interaction is with a EII shell"
    $SET INTERVAL elke,eke;
    $EVALUATE sigm USING esig(elke);
    $EVALUATE pbrem USING ebr1(elke);
    sigm = sigm*(1 - pbrem);
    $RANDOMSET rsh; rsh = sigm*rsh;
    DO iele=1,nne(medium) [
        iZ = int(zelem(medium,iele)+0.5);
        nsh = eii_no(medium,iele);
        IF( nsh > 0 ) [
            ifirst = eii_first(medium,iele);
            DO ish = 1,nsh [
                Uj = binding_energies(ish,iZ);
                IF( ekin > Uj & (Uj > te(medium) | Uj > ap(medium)) ) [
                    jj = ifirst + ish - 1;
                    i = eii_a(jj)*elke + eii_b(jj) + (jj-1)*$N_EII_BINS;
                    sig_j = eii_xsection_a(i)*elke + eii_xsection_b(i);
                    sig_j = sig_j*pz(medium,iele)*eii_cons(medium);
                    rsh = rsh - sig_j;
                    IF( rsh < 0 ) [
                        $AUSCALL($EIIB);
                        call eii_sample(ish,iZ,Uj);
                        $AUSCALL($EIIA);
                        return;
                    ]
                ]
            ]
        ]
    ]
]
IF( ekin <= 2*te(medium) ) return;
T0=EKIN/RM;
E0=T0+1.0;
EXTRAE = EIE - THMOLL(MEDIUM);
E02=E0*E0;
"BETAI2=E02/(E02-1.0); " "BLIF 96/2/1 -- not needed for Moller fix-up"
EP0=TE(MEDIUM)/EKIN;
"G1=(1.-2.*EP0)*BETAI2;" "BLIF 96/2/1 -- not needed for Moller fix-up"
G2=T0*T0/E02;
G3=(2.*T0+1.)/E02;
"   H.H.NAGEL HAS CONSTRUCTED A FACTORIZATION OF THE FREQUENCY"
"   DISTRIBUTION FUNCTION FOR THE MOLLER DIFFERENTIAL CROSS"
"   SECTION USED AS SUGGESTED BY BUTCHER AND MESSEL."
"   (H.H.NAGEL, OP.CIT., P. 53-55)                                 "
"   HOWEVER, A MUCH SIMPLER SAMPLING METHOD WHICH DOES NOT BECOME  "
"   VERY INEFFICIENT NEAR THMOLL IS THE FOLLOWING. . .             "
"   LET BR=EKS/EKIN,  WHERE EKS IS KINETIC ENERGY TRANSFERED TO THE"
"   SECONDARY ELECTRON AND EKIN IS THE INCIDENT KINETIC ENERGY.    "

"   MODIFIED (7 FEB 1974) TO USE THE TRUE MOLLER CROSS SECTION."
"   THAT IS, INSTEAD OF THE E+ E- AVERAGE GIVEN IN THE ROSSI"
"   FORMULA USED BY NAGEL.  THE SAMPLING SCHEME IS THAT"
"   USED BY MESSEL AND CRAWFORD (EPSDF 1970 P.13)"
"   FIRST SAMPLE (1/BR**2) OVER (TE/EKIN,1/2) . . .            "

GMAX=(1.+1.25*G2); "BLIF 96/2/1 -- Moller fix-up"
LOOP[" TO RETRY IF REJECTED"
$RANDOMSET RNNO27;
BR = TE(MEDIUM)/(EKIN-EXTRAE*RNNO27);

"   USE MESSEL AND CRAWFORDS REJECTION FUNCTION."
R=BR/(1.-BR);
$RANDOMSET RNNO28;
REJF4="G1*"(1.+G2*BR*BR+R*(R-G3)); "BLIF 96/2/1 -- Moller fix-up"
RNNO28=GMAX*RNNO28; "BLIF 96/2/1 -- Moller fix-up"
]UNTIL RNNO28.LE.REJF4; "TRY UNTIL ACCEPTED. END REJECTION LOOP"

PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY ELECTRON #2"
PESE1=PEIE-PEKSE2; "PRECISE ENERGY OF SECONDARY ELECTRON #1"
PESE2=PEKSE2+PRM; "PRECISE ENERGY OF SECONDARY ELECTRON #2"
ESE1=PESE1; "ENERGY OF SECONDARY ELECTRON 1"
ESE2=PESE2; "ENERGY OF SECONDARY ELECTRON 2"
E(NP)=PESE1;
$CHECK-STACK(np+1,'MOLLER');
E(NP+1)=PESE2;
"   SINCE BR.LE.0.5, E(NP+1) MUST BE .LE. E(NP). "
"   MOLLER ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS            "

" One possible way of dealing with double counting of angular      "
" deflections in inelastic scattering would be to                  "
" not deflect the 'old' electron as these deflections are          "
" already taken into account in the multiple elastic scattering    "
" This approach has the disadvantage of loosing correlations       "
" between big energy losses and strong angular deflections         "
" The advantage of such an approach is its simplicity.             "
" If spin effects for multiple elastic scattering are turned on,   "
" the double counting is taken into account by the appropriate     "
" modification of the scattering power (which depends on AE)       "
"                                                                  "
"                                                                  "
" IK, June 1999                                                    "

H1=(PEIE+PRM)/PEKIN;
"   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON                     "
DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);
SINTHE=DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);

"sinthe = 0; costhe = 1; <- this will turn off the Moller ang. deflections"

CALL UPHI(2,1);

"   RELATED CHANGE AND (X,Y,Z) SETUP FOR 'NEW' ELECTRON            "
NP=NP+1;
IQ(NP)=-1;
DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
SINTHE=-DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);
CALL UPHI(3,2);
RETURN;
"END OF SUBROUTINE MOLLER"  END;

%E

subroutine mscati;
"**********************************************************************"

" Subroutine to read the pre-calculated q^(2+)-surface, prepare data
" required by the mscat and msdist subroutines, initialize spin effect
" corrections
"
" I.Kawrakow, NRC
"**********************************************************************"

implicit none;

$REAL ededx,ei,eil,eip1,eip1l,si,sip1,eke,elke,aux,ecutmn,tstbm,tstbmn;
$REAL p2,beta2,dedx0,ekef,elkef,estepx,ektmp,elktmp,chi_a2;
$INTEGER
    i,leil,leip1l,neke,lelke,lelkef,lelktmp;
$LOGICAL  ise_monoton, isp_monoton;

$declare_write_buffer;

"cross section per energy loss"
$REAL sigee,sigep,sig,sige_old,sigp_old;

"entry mscat variables
"======================

$COMIN-MSCATI;

" moved the following from prestaII_inputs, "
" if transport_algorithm = presta-I, exact_bca = .false. and
" skin_depth_for_bca <= 1  ==> calculate default presta-I tmin for bca"

IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
ELSE                    [ exact_bca = .false.; ]
IF( estepe <= 0 | estepe >= 1) [ estepe = $MAX-ELOSS; ]
IF( ximax <= 0  | ximax >= 1 ) [
    IF( exact_bca ) [ ximax = $EXACT-BCA-XIMAX;   ]
    ELSE            [ ximax = $INEXACT-BCA-XIMAX; ]
]
IF (transport_algorithm ~= $PRESTA-II &
    transport_algorithm ~= $PRESTA--I &
    transport_algorithm ~= $VMC ) [transport_algorithm = $PRESTA-II;]
IF( skindepth_for_bca <= 1e-4 ) [
    "IF( transport_algorithm = $PRESTA--I & ~exact_bca ) ["
    IF( ~exact_bca ) [
        $egs_info(*,' old PRESTA calculates default min. step-size for BCA: ');
        $set_ecutmn;
        $egs_info(*,'     minimum ECUT found: ',ecutmn);
        tstbmn = 1e30;
        DO medium = 1,nmed [
            tstbm = (ecutmn-prm)*(ecutmn+prm)/ecutmn**2;
            tstbm = blcc(medium)*tstbm*(ecutmn/xcc(medium))**2;
            aux = Log(tstbm);
            IF( aux > 300 ) $egs_info(*,'aux > 300 ? ',aux);
            tstbm = Log(tstbm/aux);
            "Changed the following to the above so that the Intel compiler"
            " does not vectorize the loop with -xK. Vectorizing this loop"
            " on an Athlon CPU results in segmentation fault."
            " IK, Jan 29 2004."
            "tstbm = Log(tstbm/Log(tstbm));"
            tstbmn = Min(tstbmn,tstbm);
        ]
        $egs_info(*,'     default BLCMIN is: ',tstbmn);
        skindepth_for_bca = Exp(tstbmn);
        $egs_info(*,'     this corresponds to ',skindepth_for_bca,
         ' elastic MFPs ');
    ]
    ELSE [ skindepth_for_bca = $SKIN-DEPTH-FOR-BCA; ]
]

" read MS data for screened Rutherford scattering "
call init_ms_SR;

DO medium = 1,nmed
[
    "Absorb Euler constant into the multiple scattering parameter
    "1.16699413758864573 = Exp[2 EulerGamma - 1]
    blcc(medium) = 1.16699413758864573*blcc(medium);

    "Take its square as this is employed throughout
    xcc(medium)  = xcc(medium)**2;
]

IF( spin_effects ) [ call init_spin; ]

"Determine maximum cross section per energy loss for every medium
$egs_info(*,' ');
esige_max = 0;
psige_max = 0;
DO medium = 1,nmed
[

  sigee = 1E-15; sigep = 1E-15;
  neke = meke(medium); "Number of elements in storage array
  ise_monoton = .true.; isp_monoton = .true.;
  sige_old = -1; sigp_old = -1;
  DO i = 1,neke
  [

    ei   = exp((float(i) - eke0(medium))/eke1(medium));
    eil  = log(ei);
    leil = i;
    $EVALUATE ededx USING ededx(eil);
    $EVALUATE sig USING esig(eil);
    sig = sig/ededx;
    IF (sig > sigee) sigee = sig;
    IF( sig < sige_old ) ise_monoton = .false.;
    sige_old = sig;
    $EVALUATE ededx USING pdedx(eil);
    $EVALUATE sig USING psig(eil);
    sig = sig/ededx;
    IF (sig > sigep) sigep = sig;
    IF( sig < sigp_old ) isp_monoton = .false.;
    sigp_old = sig;

  ]
  $egs_info(*,' Medium ',medium,' sige = ',sigee,sigep,' monotone = ',
          ise_monoton,isp_monoton);
  sig_ismonotone(0,medium) = ise_monoton;
  sig_ismonotone(1,medium) = isp_monoton;
  esig_e(medium) = sigee; psig_e(medium) = sigep;
  IF( sigee > esige_max ) esige_max = sigee;
  IF( sigep > psige_max ) psige_max = sigep;
]
$egs_info(*,' ');

$egs_info(*,' Initializing tmxs for estepe = ',estepe,' and ximax = ',ximax);
$egs_info(*,' ');

"Determine upper limit in step size for multiple scattering
DO medium = 1,nmed
[
    " Calculate range array first "
    " =========================== "
    ei   = exp((1 - eke0(medium))/eke1(medium)); "Energy of first table entry
    eil  = log(ei);
    leil = 1;
    E_array(1,medium) = ei;
    expeke1(medium) = Exp(1./eke1(medium))-1;
    range_ep(0,1,medium) = 0; range_ep(1,1,medium) = 0;
    neke = meke(medium); "Number of elements in storage array
    DO i = 1,neke - 1
    [
        eip1   = exp((float(i + 1) - eke0(medium))/eke1(medium)); "Energy at i+1
        E_array(i+1,medium) = eip1;
        " Calculate range. The following expressions result from the"
        " logarithmic interpolation for the (restricted) stopping power "
        " and a power power series expansion of the integral "
        eke = 0.5*(eip1+ei); elke = Log(eke);
        $SET INTERVAL elke,eke;
        $EVALUATE ededx USING pdedx(elke);
        aux = pdedx1(i,medium)/ededx;
        range_ep(1,i+1,medium) = range_ep(1,i,medium) +
          (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
        $EVALUATE ededx USING ededx(elke);
        aux = ededx1(i,medium)/ededx;
        range_ep(0,i+1,medium) = range_ep(0,i,medium) +
          (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
        ei = eip1;
    ]

    " Now tmxs "
    " ======== "

    eil = (1 - eke0(medium))/eke1(medium);
    ei  = Exp(eil); leil = 1; " As in $SET INTERVAL but avoids roundoff
    p2  = ei*(ei+2*rm); beta2 = p2/(p2+rm*rm);
    chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
    $EVALUATE dedx0 USING ededx(eil);
    estepx = 2*p2*beta2*dedx0/ei/Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
    estepx = estepx*ximax;
    IF( estepx > estepe ) [ estepx = estepe; ]
    si = estepx*ei/dedx0;

    DO i = 1,neke - 1
    [

        elke = (i + 1 - eke0(medium))/eke1(medium);
        eke  = Exp(elke); lelke = i+1;
        p2  = eke*(eke+2*rm); beta2 = p2/(p2+rm*rm);
        chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
        $EVALUATE ededx USING ededx(elke);
        estepx = 2*p2*beta2*ededx/eke/
                  Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
        estepx = estepx*ximax;
        IF( estepx > estepe ) [ estepx = estepe; ]
        ekef = (1-estepx)*eke;
        IF( ekef <= E_array(1,medium) )
        [
            sip1 = (E_array(1,medium) - ekef)/dedx0;
            ekef = E_array(1,medium);
            elkef = (1 - eke0(medium))/eke1(medium);
            lelkef = 1;
        ]
        ELSE
        [
            elkef = Log(ekef);
            $SET INTERVAL elkef,eke;
            leip1l = lelkef + 1;
            eip1l  = (leip1l - eke0(medium))/eke1(medium);
            eip1   = E_array(leip1l,medium);
            aux    = (eip1 - ekef)/eip1;
            elktmp = 0.5*(elkef+eip1l+0.25*aux*aux*(1+aux*(1+0.875*aux)));
            ektmp  = 0.5*(ekef+eip1);
            lelktmp = lelkef;
            $EVALUATE ededx USING ededx(elktmp);
            aux = ededx1(lelktmp,medium)/ededx;
            sip1 = (eip1 - ekef)/ededx*(
                     1+aux*(1+2*aux)*((eip1-ekef)/ektmp)**2/24);
        ]
        sip1 = sip1 + range_ep(0,lelke,medium) - range_ep(0,lelkef+1,medium);

        "Now solve these equations
        "  si   = tmxs1 * eil   + tmxs0
        "  sip1 = tmxs1 * eip1l + tmxs0

        tmxs1(i,medium) = (sip1 - si)*eke1(medium);
        tmxs0(i,medium) = sip1 - tmxs1(i,medium)*elke;

        si  = sip1;
    ]

    "Now pick up last table entry which applies only to last energy
    tmxs0(neke,medium) = tmxs0(neke - 1,medium);
    tmxs1(neke,medium) = tmxs1(neke - 1,medium);

]

return;
end;

%E
; "buffer flush

subroutine mscat(lambda,chia2,q1,elke,beta2,qel,medium,
                 spin_effects,find_index,spin_index,
                 cost,sint);
"========================================================================="
"                                                                         "
" Subroutine to sample multiple electron scattering angles from the exact "
" distribution resulting from elastic scattering described by the screened"
" Rutherford cross section (spin_effects=.false.) or by the screened      "
" Rutherford cross times Mott correction (spin_effects=.true.)            "
"                                                                         "
" I.Kawrakow, NRC                                                         "
"========================================================================="

implicit none;

$REAL    lambda, chia2,q1,elke,beta2,cost,sint;
$INTEGER qel,medium;
$LOGICAL spin_effects,find_index,spin_index;

COMIN/MS-Data,RANDOM,EGS-IO/;

$declare_write_buffer;

$REAL    sprob,explambda,wsum,wprob,xi,rejf,spin_rejection,
         cosz,sinz,phi,omega2,llmbda,ai,aj,ak,a,u,du,x1,rnno;
$INTEGER icount,i,j,k;

save     i,j,omega2;

$TURN_OFF_SCATTERING;
" default of above is ';' See definition in egsnrc.macros for example"
" of how to turn off all scattering    DR April 2012"

IF(lambda <= 13.8)
[
    "Test only for lambda = 13.8 implies a 1e-6 error, ie large-lambda cases
    "that contribute to the forward no-scattering amplitude.
    $RANDOMSET sprob;
    explambda = Exp(-lambda);
    IF (sprob < explambda)
    [
        "It was a no scattering event
        cost = 1; sint = 0;
        return;
    ]
    wsum = (1+lambda)*explambda;
    IF ( sprob < wsum )
    [
      :RETRY_1:;
      $RANDOMSET xi;
      xi  = 2*chia2*xi/(1 - xi + chia2);
      cost = 1 - xi;
      IF( spin_effects ) [
          rejf = spin_rejection(qel,medium,elke,beta2,q1,cost,
                                spin_index,.false.);
          $RANDOMSET rnno;
          IF( rnno > rejf ) [ GOTO :RETRY_1:; ]
      ]
      sint = sqrt(xi*(2 - xi));
      return;
    ]
    IF ( lambda <= 1 )      "IK introduced this portion because with
                            "alternative BCAs mscat can be called with
                            " lambda < 1 where there are no pre-calculated
                            "data
    [
        wprob = explambda; wsum = explambda;
        cost = 1; sint = 0;
        icount = 0;
        LOOP
        [
            icount = icount + 1;
            IF (icount > 20) EXIT; "To avoid underflow if sprob very close to 1
            wprob = wprob*lambda/icount;
            wsum = wsum + wprob;
            :RETRY_2:;
            $RANDOMSET xi;
            xi  = 2*chia2*xi/(1 - xi + chia2);
            cosz = 1 - xi;
            IF( spin_effects ) [
                rejf = spin_rejection(qel,medium,elke,beta2,q1,cosz,
                                      spin_index,.false.);
                $RANDOMSET rnno;
                IF( rnno > rejf ) [ GOTO :RETRY_2:; ]
            ]
            sinz = xi*(2 - xi);
            IF ( sinz > 1.e-20 )
            [
               sinz = Sqrt(sinz);
               $RANDOMSET xi;
               phi = xi*6.2831853;
               cost = cost*cosz - sint*sinz*Cos(phi);
               sint = Sqrt(Max(0.0,(1-cost)*(1+cost)));
             ]
        ] UNTIL ( wsum > sprob);
        return;
    ]
]

"It was a multiple scattering event
"Sample the angle from the q^(2+) surface

IF (lambda <= $LAMBMAX_MS ) [

    IF (find_index)
    [
        llmbda = log(lambda);

        " First fix lambda bin
        ai = llmbda*dllambi; i = ai; ai = ai - i;
        $RANDOMSET xi;
        IF(xi < ai) i = i + 1;

        " fix now q1 bin
        IF( q1 < $QMIN_MS ) [ j = 0; ]
        ELSE IF( q1 < $QMAX_MS ) [
            aj = q1*dqmsi; j = aj; aj = aj - j;
            $RANDOMSET xi;
            IF( xi < aj ) j = j + 1;
        ]
        ELSE [ j = $MAXQ_MS; ]

        " Calculate omega2 "
        IF(llmbda < 2.2299) [
          omega2 = chia2*(lambda + 4)*(1.347006 + llmbda*(
            0.209364 - llmbda*(0.45525 - llmbda*(0.50142 - 0.081234*llmbda))));
        ]
        ELSE [
          omega2 = chia2*(lambda + 4)*(-2.77164 + llmbda*(2.94874 -
                   llmbda*(0.1535754 - llmbda*0.00552888)));
        ]

        find_index = .false.;
    ]
    "If this is a re-iteration with the same lambda, then omega2, i, and k
    "should have been defined in the previous iteration

:RETRY_3:;
    $RANDOMSET xi;
    ak = xi*$MAXU_MS; k = ak; ak = ak - k;
    IF( ak > wms_array(i,j,k) ) k = ims_array(i,j,k);
    a = fms_array(i,j,k); u = ums_array(i,j,k);
    du = ums_array(i,j,k+1) - u;
    $RANDOMSET xi;
    IF( abs(a) < 0.2 ) [
        x1 = 0.5*(1-xi)*a;
        u  = u + xi*du*(1+x1*(1-xi*a));
    ]
    ELSE [ u = u - du/a*(1-Sqrt(1+xi*a*(2+a))); ]

    xi      = omega2*u/(1 + 0.5*omega2 - u);
    IF( xi > 1.99999 ) [ xi = 1.99999; ]
      "some machines have trouble when xi is very close to 2 in subsequent"
      "calculations. IK, April 25 2002"
    cost    = 1 - xi;
    IF( spin_effects ) [
        rejf=spin_rejection(qel,medium,elke,beta2,q1,cost,spin_index,.false.);
        $RANDOMSET rnno;
        IF( rnno > rejf ) [ GOTO :RETRY_3:; ]
    ]
    sint    = sqrt(xi*(2-xi));
    return;
]

"This is an error condition

$egs_info(*,' ');
$egs_info(*,' *************************************');
$egs_info(*,' Maximum step size in mscat exceeded! ');
$egs_info(*,' Maximum step size initialized: 100000');
$egs_info(*,' Present lambda: ',lambda);
$egs_info(*,' chia2: ',chia2);
$egs_info(*,' q1 elke beta2: ',q1,elke,beta2);
$egs_info(*,' medium: ',medium);
$egs_fatal(*,' Stopping execution');

end;

%E
; "buffer flush

$REAL function spin_rejection(qel,medium,elke,beta2,q1,cost,
                              spin_index,is_single);
"============================================================================="
"                                                                             "
" Determines the rejection function due to spin effects for                   "
"   charge        qel (=0 for e-, =1 for e+)                                  "
"   log(energy)   elke                                                        "
"   speed         beta2                                                       "
"   1. MS moment  q1                                                          "
"   cos(theta)    cost                                                        "
"                                                                             "
" I.Kawrakow, NRC                                                             "
"============================================================================="

implicit none;

$REAL      elke,beta2,q1,cost;
$INTEGER   qel,medium;
$LOGICAL   spin_index,is_single;
$declare_max_medium;
COMIN/Spin-Data,RANDOM/;

$REAL      rnno,ai,qq1,aj,xi,ak;
$INTEGER   i,j,k;

save       i,j;

IF( spin_index ) [  "Determine the energy and q1 index
    spin_index = .false.;
    IF( beta2 >= b2spin_min ) [
        ai = (beta2 - b2spin_min)*dbeta2i;
        i = ai; ai = ai - i; i = i + $MAXE_SPIN + 1;
    ]
    ELSE IF( elke > espml ) [
        ai = (elke - espml)*dleneri; i = ai; ai = ai - i;
    ]
    ELSE [ i = 0; ai = -1; ]
    $RANDOMSET rnno;
    IF( rnno < ai ) i = i + 1;
    IF( is_single ) [ j = 0; ]
    ELSE [
        qq1 = 2*q1; qq1 = qq1/(1 + qq1);
        aj = qq1*dqq1i; j = aj;
        IF( j >= $MAXQ_SPIN ) [ j = $MAXQ_SPIN; ]
        ELSE [  aj = aj - j;
                $RANDOMSET rnno;
                IF( rnno < aj ) j = j + 1;
        ]
    ]
]
xi = Sqrt(0.5*(1-cost));
ak = xi*$MAXU_SPIN; k = ak; ak = ak - k;
spin_rejection = (1-ak)*spin_rej(medium,qel,i,j,k) +
                     ak*spin_rej(medium,qel,i,j,k+1);
return;
end;

%E
; "buffer flush


subroutine sscat(chia2,elke,beta2,qel,medium,spin_effects,cost,sint);
"============================================================================"
"                                                                            "
" single elastic scattering                                                  "
"                                                                            "
" I.Kawrakow, NRC                                                            "
"============================================================================"

implicit none;

$REAL    chia2,elke,beta2,cost,sint;
$INTEGER qel,medium;
$LOGICAL spin_effects;

COMIN/RANDOM/;

$REAL    xi,rnno,rejf,spin_rejection,qzero;
$LOGICAL spin_index;

$TURN_OFF_SCATTERING;
" default of above is ';' See definition in egsnrc.macros for example"
" of how to turn off all scattering    DR April 2012"

spin_index = .true.;
:RETRY-SPIN:;
$RANDOMSET xi;
xi  = 2*chia2*xi/(1 - xi + chia2);
cost = 1 - xi;
IF( spin_effects ) [
    qzero=0;
    rejf = spin_rejection(qel,medium,elke,beta2,qzero,cost,spin_index,.true.);
    $RANDOMSET rnno;
    IF( rnno > rejf ) goto :RETRY-SPIN:;
]
sint = sqrt(xi*(2 - xi));
return;
end;

%E
; "buffer flush

subroutine init_ms_SR;
"================================================================"
"                                                                "
" Reads in pre-calculated screened Rutherford multiple elastic   "
" scattering data                                                "
"                                                                "
" I. Kawrakow, NRC                                               "
"================================================================"

implicit none;

COMIN/MS-Data,EGS-IO/;
$declare_write_buffer;

integer*4 i,j,k;

$egs_info('(/a,$)','Reading screened Rutherford MS data ............... ');
rewind($MSCAT-DATAFILE);
DO i=0,$MAXL_MS [
    DO j=0,$MAXQ_MS [
        read($MSCAT-DATAFILE,*) (ums_array(i,j,k),k=0,$MAXU_MS);
        read($MSCAT-DATAFILE,*) (fms_array(i,j,k),k=0,$MAXU_MS);
        read($MSCAT-DATAFILE,*) (wms_array(i,j,k),k=0,$MAXU_MS-1);
        read($MSCAT-DATAFILE,*) (ims_array(i,j,k),k=0,$MAXU_MS-1);
        DO k=0,$MAXU_MS-1 [
           fms_array(i,j,k) = fms_array(i,j,k+1)/fms_array(i,j,k)-1;
           ims_array(i,j,k) = ims_array(i,j,k)-1;
        ]
        fms_array(i,j,$MAXU_MS)=fms_array(i,j,$MAXU_MS-1);
    ]
]
$egs_info('(a)',' done ');

llammin = Log($LAMBMIN_MS); llammax = Log($LAMBMAX_MS);
dllamb  = (llammax-llammin)/$MAXL_MS; dllambi = 1./dllamb;
dqms    = $QMAX_MS/$MAXQ_MS; dqmsi = 1./dqms;

return;
end;

%E
; "buffer flush

subroutine init_spin;
"======================================================================="
"                                                                       "
" Reads in spin rejection data for multiple elastic scattering and      "
" initializes interpolation arrays for the screening parameter,         "
" elastic cross section, first and second MS moments                    "
"                                                                       "
" I. Kawrakow, NRC                                                      "
"======================================================================="

implicit none;
$declare_max_medium;
COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
                            "BREMPR is needed for the elemental composition"

$REAL         eta_array(0:1,$0-MAXE_SPI1),
              c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
              earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
              sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
              tau,tauc,beta2,eta,gamma,fmax,
              eil,e,si1e,si2e,si1p,si2p,aae,etap,
              elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
              af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
              df($0-MAXE_SPI1),spline,dloge,eloge;

real*4        dum1,dum2,dum3,aux_o; " These must be 32 bit floats!!!!!"

real*4        fmax_array(0:$MAXQ_SPIN);
integer*2     i2_array(512),ii2;

$INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
              ndata,leil,length,ii4,irec;

character     spin_file*256;
character*6   string;
integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
                       "do not have lnblnk, we supply lnblnk1 in this file

$INTEGER      spin_unit, rec_length, want_spin_unit;
integer       egs_get_unit;
character     data_version*32,endianess*4;
$LOGICAL      swap;

$declare_write_buffer;

$REAL        fine,TF_constant;
parameter    (fine=137.03604, TF_constant=0.88534138);

" stupid GNU compiler complains that the arguments to egs_swap_ are of "
" one kind here, but of some other kind there => need character arrays and "
" equivalence statements"
real*4        tmp_4;
character     c_2(2), c_4(4);
equivalence   (ii2,c_2), (tmp_4,c_4);

" First construct the path to the spin dbase directory "
$set_string(spin_file,' ');
spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms.data';
want_spin_unit = 61;
spin_unit = egs_get_unit(want_spin_unit);
IF( spin_unit < 1 ) [
    $egs_fatal(*,'init_spin: failed to get a free fortran unit');
]
rec_length = 276*$RECL-FACTOR;
open(spin_unit,file=spin_file,form='unformatted',access='direct',
     status='old',recl=rec_length,err=:spin-open-error:);
read(spin_unit,rec=1,err=:spin-read-error:) data_version,endianess,
                      espin_min,espin_max,b2spin_min,b2spin_max;
swap = endianess.ne.$BYTE_ORDER;
IF( swap ) [
    tmp_4 = espin_min; call egs_swap_4(c_4); espin_min = tmp_4;
    tmp_4 = espin_max; call egs_swap_4(c_4); espin_max = tmp_4;
    tmp_4 = b2spin_min; call egs_swap_4(c_4); b2spin_min = tmp_4;
    tmp_4 = b2spin_max; call egs_swap_4(c_4); b2spin_max = tmp_4;
]
$egs_info('(//a,a)','Reading spin data base from ',$cstring(spin_file));
$egs_info('(a)',data_version);
$egs_info('(a,a,a)','Data generated on a machine with ',endianess,
        ' endianess');
$egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
IF( swap ) $egs_info('(a)','=> will need to do byte swaping');
$egs_info('(a,2f9.2,2f9.5,//)','Ranges: ',espin_min,espin_max,
        b2spin_min,b2spin_max);
n_ener = $MAXE_SPIN; n_q = $MAXQ_SPIN; n_point = $MAXU_SPIN;
dloge = log(espin_max/espin_min)/n_ener;
eloge = log(espin_min); earray(0) = espin_min;
$FOOL-INTEL-OPTIMIZER(25) 'Energy grid:';
DO i=1,n_ener [
    eloge = eloge + dloge; earray(i) = exp(eloge);
    $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
]
dbeta2 = (b2spin_max - b2spin_min)/n_ener;
beta2 = b2spin_min; earray(n_ener+1) = espin_max;
DO i=n_ener+2,2*n_ener+1 [
    beta2 = beta2 + dbeta2;
    IF( beta2 < 0.999 ) [ earray(i) = prm*1000.0*(1/sqrt(1-beta2)-1); ]
    ELSE [ earray(i) = 50585.1; ]
    $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
]

" Convert to MeV and set interpolation interavals"
/*
 * IK: Moved here Feb 4 2004.
 *     Bug found and reported by Dr Helmut Schlattl.
 */
espin_min = espin_min/1000; espin_max = espin_max/1000;
dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
espml = Log(espin_min);
dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;

DO medium = 1,NMED [
    $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
            DO j=0,$MAXQ_SPIN [
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = 0;
                ]
            ]
        ]
    ]
    /sum_Z2,sum_A,sum_pz,sum_Z/=0;
    DO i_ele=1,NNE(medium) [
        Z = ZELEM(medium,i_ele);
        iZ = int(Z+0.5);
        $FOOL-INTEL-OPTIMIZER(25) ' Z = ',iZ;
        tmp = PZ(medium,i_ele)*Z*(Z+1);
              "For now, we take into account the contribution of atomic"
              "electrons to elastic scattering by replacing Z**2 with  "
              "Z*(Z+1). The part of the scattering power that is taken "
              "into account by discrete Moller/Bhabha events is        "
              "substracted below => bc is energy dependent. We will    "
              "worry about better approaches in the future (a realistic"
              "inelastic scattering model is needed first)             "
        sum_Z2 = sum_Z2 + tmp;
        sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
        sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
        sum_pz = sum_pz + PZ(medium,i_ele);
        Z23    = Z**0.6666667;
        DO iq=0,1 [
            DO i=0,$MAXE_SPI1 [
                irec = 1 + (iz-1)*4*(n_ener+1) + 2*iq*(n_ener+1) + i+1;
                $FOOL-INTEL-OPTIMIZER(25) '**** energy ',i,earray(i),irec;
                read(spin_unit,rec=irec,err=:spin-read-error:)
                  dum1,dum2,dum3,aux_o,fmax_array,i2_array;
                IF( swap ) [
                  tmp_4 = dum1; call egs_swap_4(c_4); dum1 = tmp_4;
                  tmp_4 = dum2; call egs_swap_4(c_4); dum2 = tmp_4;
                  tmp_4 = dum3; call egs_swap_4(c_4); dum3 = tmp_4;
                  tmp_4 = aux_o; call egs_swap_4(c_4); aux_o = tmp_4;
                ]
                eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
                tau = earray(i)/prm*0.001;  "energy in the file is in keV"
                beta2 = tau*(tau+2)/(tau+1)**2;
                eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
                c_array(iq,i)=c_array(iq,i)+
                  tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
                g_array(iq,i)=g_array(iq,i)+tmp*dum2;
                DO j=0,$MAXQ_SPIN [
                    tmp_4 = fmax_array(j);
                    IF( swap ) call egs_swap_4(c_4);
                    DO k=0,$MAXU_SPIN [
                        ii2 = i2_array((n_point+1)*j + k+1);
                        IF( swap ) call egs_swap_2(c_2);
                        ii4 = ii2;
                        IF( ii4 < 0 ) ii4 = ii4 + 65536;
                        dum1 = ii4; dum1 = dum1*tmp_4/65535;
                        spin_rej(medium,iq,i,j,k) =
                          spin_rej(medium,iq,i,j,k) + tmp*dum1;
                    ]
                ]
            ]
        ]
    ]

    " spin_rej will be used as a rejection function in MS sampling, "
    " so scale maximum to unity"
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            DO j=0,$MAXQ_SPIN [
                fmax = 0;
                DO k=0,$MAXU_SPIN [
                    IF( spin_rej(medium,iq,i,j,k) > fmax )
                       [ fmax = spin_rej(medium,iq,i,j,k); ]
                ]
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
                ]
            ]
        ]
    ]

    " Process eta_array, c_array and g_array to their final form "
    $FOOL-INTEL-OPTIMIZER(25) 'Spin corrections as read in from file';
    DO i=0,$MAXE_SPI1 [
        tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
        DO iq=0,1 [
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
            eta = aux_o/4/tau/(tau+2);
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
                      (Log(1+1/eta)*(1+eta)-1);
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
        ]
        $FOOL-INTEL-OPTIMIZER(25) i,earray(i),eta_array(0,i),eta_array(1,i),
          c_array(0,i),c_array(1,i),g_array(0,i),g_array(1,i);
    ]

    " Prepare interpolation table for the screening parameter "
    eil = (1 - eke0(medium))/eke1(medium);
    e = Exp(eil);
    IF( e <= espin_min ) [
        si1e = eta_array(0,0); si1p = eta_array(1,0);
    ]
    ELSE [
        IF( e <= espin_max ) [
            aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
        ]
        ELSE [
            tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
            aae = (beta2 - b2spin_min)*dbeta2i;
            je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
        ]
        si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
        si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
    ]
    neke = meke(medium);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for eta correction';
    DO i = 1,neke - 1 [
        eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
        IF( e <= espin_min ) [
            si2e = eta_array(0,0); si2p = eta_array(1,0);
        ]
        ELSE [
            IF( e <= espin_max ) [
                aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
            ]
            ELSE [
                tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
                aae = (beta2 - b2spin_min)*dbeta2i;
                je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
            ]
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
        ]
        etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
        etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
        etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) i,e,si2e,si2p,etae_ms1(i,medium),
         etae_ms0(i,medium),etap_ms1(i,medium),etap_ms0(i,medium);
        si1e = si2e; si1p = si2p;
    ]
    etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
    etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
    etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
    etap_ms0(neke,medium) = etap_ms0(neke-1,medium);

    "Prepare correction to the first MS moment due to spin effects"
    "first electrons"
    $FOOL-INTEL-OPTIMIZER(25) 'elarray:';
    DO i=0,$MAXE_SPIN [
        elarray(i) = Log(earray(i)/1000);
        farray(i) = c_array(0,i);
        $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i);
    ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
        elarray(i) = Log(earray(i+1)/1000);
        farray(i) = c_array(0,i+1);
        $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i+1);
    ]
    ndata = $MAXE_SPI1+1;
    IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
    ELSE [ elarray(ndata-1) = Log(1e5); ]
    farray(ndata-1) = 1;
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e-)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1ce_ms1(i,medium),
          q1ce_ms0(i,medium);
        si1e = si2e;
    ]
    q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
    q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
    "now positrons"
    $FOOL-INTEL-OPTIMIZER(25) 'Postrons:';
    DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e+)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1cp_ms1(i,medium),
          q1cp_ms0(i,medium);
        si1e = si2e;
    ]
    q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
    q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);

    "prepare interpolation table for the second MS moment correction"
    "e-"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e-)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2ce_ms1(i,medium),
          q2ce_ms0(i,medium);
        si1e = si2e;
    ]
    q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
    q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
    "e+"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e+)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2cp_ms1(i,medium),
          q2cp_ms0(i,medium);
        si1e = si2e;
    ]
    q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
    q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);

    "Now substract scattering power that is already taken into account in"
    "discrete Moller/Bhabha events"
    tauc = te(medium)/prm;
    si1e = 1;
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        e = Exp(eil); leil=i+1; tau=e/prm;
        IF( tau > 2*tauc ) [
            $EVALUATE sig USING esig(eil);
            $EVALUATE dedx USING ededx(eil);
            sig = sig/dedx;
            IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
                $EVALUATE etap USING etae_ms(eil);
                eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
                g_r = (1+2*eta)*Log(1+1/eta)-2;
                g_m = Log(0.5*tau/tauc)+
                 (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
                 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
                    Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
                 0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
                IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
                si2e = 1 - g_m*sum_Z/sum_Z2;
            ] ELSE [ si2e = 1; ]
        ] ELSE [ si2e = 1; ]
        blcce1(i,medium) = (si2e - si1e)*eke1(medium);
        blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
        si1e = si2e;
    ]
    blcce1(neke,medium) = blcce1(neke-1,medium);
    blcce0(neke,medium) = blcce0(neke-1,medium);

    "We will not bother to do the same for positrons at this time"

    $egs_info('(a)',' done');
]
close(spin_unit);
return;

:spin-open-error:
$egs_fatal('(a,a)','Failed to open spin data file ',$cstring(spin_file));

:spin-read-error:
$egs_fatal(*,'Error while reading spin data file for element',iZ);

return; end;
%E

subroutine init_spin_old;
"======================================================================="
"                                                                       "
" Reads in spin rejection data for multiple elastic scattering and      "
" initializes interpolation arrays for the screening parameter,         "
" elastic cross section, first and second MS moments                    "
"                                                                       "
" This version uses the old EGSnrc ASCII spin data format.              "
" If the installation failed to figure out the byte order of your       "
" machine, rename this subroutine to init_spin, the current init_spin   "
" to init_spin_new (or whatever) and download the old spinms data       "
" directory.
"                                                                       "
" I. Kawrakow, NRC                                                      "
"======================================================================="

implicit none;
$declare_max_medium;
COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
                            "BREMPR is needed for the elemental composition"

$REAL         eta_array(0:1,$0-MAXE_SPI1),
              c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
              earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
              sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
              dum1,dum2,dum3,aux_o,tau,tauc,beta2,eta,gamma,fmax,
              eil,e,si1e,si2e,si1p,si2p,aae,etap,
              elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
              af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
              df($0-MAXE_SPI1),spline;

$INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
              ndata,leil,length,want_spin_unit,spin_unit,egs_get_unit;

character     spin_file*256;
character*6   string;
integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
                       "do not have lnblnk, we supply lnblnk1 in this file
$declare_write_buffer;

$REAL        fine,TF_constant;
parameter    (fine=137.03604, TF_constant=0.88534138);

" First construct the path to the spin dbase directory "
$set_string(spin_file,' ');
spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms' //
             $file_sep // 'z000';
length = lnblnk1(spin_file);

DO medium = 1,NMED [
    $egs_info('(a,i4,a,$)','  Initializing spin data for medium ',medium,
                          ' ..................... ');
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
            DO j=0,$MAXQ_SPIN [
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = 0;
                ]
            ]
        ]
    ]
    /sum_Z2,sum_A,sum_pz,sum_Z/=0;
    DO i_ele=1,NNE(medium) [
        Z = ZELEM(medium,i_ele);
        iZ = int(Z+0.5);
        tmp = PZ(medium,i_ele)*Z*(Z+1);
              "For now, we take into account the contribution of atomic"
              "electrons to elastic scattering by replacing Z**2 with  "
              "Z*(Z+1). The part of the scattering power that is taken "
              "into account by discrete Moller/Bhabha events is        "
              "substracted below => bc is energy dependent. We will    "
              "worry about better approaches in the future (a realistic"
              "inelastic scattering model is needed first)             "
        iii = iZ/100; spin_file(length-2:length-2) = char(iii+48);
        iiZ = iZ - iii*100;
        iii = iiZ/10; spin_file(length-1:length-1) = char(iii+48);
        iiZ = iiZ - 10*iii;
        spin_file(length:length) = char(iiZ+48);
        want_spin_unit = 61;
        spin_unit = egs_get_unit(want_spin_unit);
        IF( spin_unit < 1 ) [
            $egs_fatal(*,'init_spin: failed to get a free fortran unit');
        ]
        open(spin_unit,file=spin_file,status='old',err=:SPIN-DBASE-ERROR:);
        read(spin_unit,*) espin_min,espin_max,b2spin_min,b2spin_max;
        read(spin_unit,*) n_ener,n_q,n_point;
        IF( n_ener ~= $MAXE_SPIN | n_q ~= $MAXQ_SPIN | n_point ~= $MAXU_SPIN) [
            $egs_fatal(*,' Wrong spin file for Z = ',iZ);
        ]
        sum_Z2 = sum_Z2 + tmp;
        sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
        sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
        sum_pz = sum_pz + PZ(medium,i_ele);
        Z23    = Z**0.6666667;
        DO iq=0,1 [
            read(spin_unit,*); read(spin_unit,*);
            DO i=0,$MAXE_SPI1 [
                read(spin_unit,'(a,g14.6)') string,earray(i);
                read(spin_unit,*) dum1,dum2,dum3,aux_o;
                eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
                tau = earray(i)/prm*0.001;  "energy in the file is in keV"
                beta2 = tau*(tau+2)/(tau+1)**2;
                eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
                c_array(iq,i)=c_array(iq,i)+
                  tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
                g_array(iq,i)=g_array(iq,i)+tmp*dum2;
                DO j=0,$MAXQ_SPIN [
                    read(spin_unit,*) tmp_array;
                    DO k=0,$MAXU_SPIN [
                        spin_rej(medium,iq,i,j,k) =
                          spin_rej(medium,iq,i,j,k) + tmp*tmp_array(k);
                    ]
                ]
            ]
        ]
        close(spin_unit);
    ]

    " spin_rej will be used as a rejection function in MS sampling, "
    " so scale maximum to unity"
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            DO j=0,$MAXQ_SPIN [
                fmax = 0;
                DO k=0,$MAXU_SPIN [
                    IF( spin_rej(medium,iq,i,j,k) > fmax )
                       [ fmax = spin_rej(medium,iq,i,j,k); ]
                ]
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
                ]
            ]
        ]
    ]

    " Process eta_array, c_array and g_array to their final form "
    DO i=0,$MAXE_SPI1 [
        tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
        DO iq=0,1 [
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
            eta = aux_o/4/tau/(tau+2);
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
                      (Log(1+1/eta)*(1+eta)-1);
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
        ]
    ]

    " Convert to MeV and set interpolation interavals"
    espin_min = espin_min/1000; espin_max = espin_max/1000;
    dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
    espml = Log(espin_min);
    dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
    dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;

    " Prepare interpolation table for the screening parameter "
    eil = (1 - eke0(medium))/eke1(medium);
    e = Exp(eil);
    IF( e <= espin_min ) [
        si1e = eta_array(0,0); si1p = eta_array(1,0);
    ]
    ELSE [
        IF( e <= espin_max ) [
            aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
        ]
        ELSE [
            tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
            aae = (beta2 - b2spin_min)*dbeta2i;
            je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
        ]
        si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
        si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
    ]
    neke = meke(medium);
    DO i = 1,neke - 1 [
        eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
        IF( e <= espin_min ) [
            si2e = eta_array(0,0); si2p = eta_array(1,0);
        ]
        ELSE [
            IF( e <= espin_max ) [
                aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
            ]
            ELSE [
                tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
                aae = (beta2 - b2spin_min)*dbeta2i;
                je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
            ]
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
        ]
        etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
        etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
        etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
        si1e = si2e; si1p = si2p;
    ]
    etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
    etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
    etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
    etap_ms0(neke,medium) = etap_ms0(neke-1,medium);

    "Prepare correction to the first MS moment due to spin effects"
    "first electrons"
    DO i=0,$MAXE_SPIN [
        elarray(i) = Log(earray(i)/1000);
        farray(i) = c_array(0,i);
    ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
        elarray(i) = Log(earray(i+1)/1000);
        farray(i) = c_array(0,i+1);
    ]
    ndata = $MAXE_SPI1+1;
    IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
    ELSE [ elarray(ndata-1) = Log(1e5); ]
    farray(ndata-1) = 1;
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
        si1e = si2e;
    ]
    q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
    q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
    "now positrons"
    DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
        si1e = si2e;
    ]
    q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
    q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);

    "prepare interpolation table for the second MS moment correction"
    "e-"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
        si1e = si2e;
    ]
    q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
    q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
    "e+"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
    ]
    q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
    q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);

    "Now substract scattering power that is already taken into account in"
    "discrete Moller/Bhabha events"
    tauc = te(medium)/prm;
    si1e = 1;
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        e = Exp(eil); leil=i+1; tau=e/prm;
        IF( tau > 2*tauc ) [
            $EVALUATE sig USING esig(eil);
            $EVALUATE dedx USING ededx(eil);
            sig = sig/dedx;
            IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
                $EVALUATE etap USING etae_ms(eil);
                eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
                g_r = (1+2*eta)*Log(1+1/eta)-2;
                g_m = Log(0.5*tau/tauc)+
                 (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
                 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
                    Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
                 0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
                IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
                si2e = 1 - g_m*sum_Z/sum_Z2;
            ] ELSE [ si2e = 1; ]
        ] ELSE [ si2e = 1; ]
        blcce1(i,medium) = (si2e - si1e)*eke1(medium);
        blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
        si1e = si2e;
    ]
    blcce1(neke,medium) = blcce1(neke-1,medium);
    blcce0(neke,medium) = blcce0(neke-1,medium);

    "We will not bother to do the same for positrons at this time"

    $egs_info('(a)',' done');
]
return;

:SPIN-DBASE-ERROR:
$egs_info(*,' ******************** Error in init_spin ******************* ');
$egs_info('(a,a)','  could not open file ',spin_file);
$egs_fatal(*,' terminating execution ');

end;
%E
; "buffer flush

"======================================================================"
"                 subroutine msdist_pII                                "
"                 =====================                                "
"                                                                      "
"  This subroutine models multiple elastic scattering and spatial      "
"  deflections for a given path-length tustep.                         "
"  For description of input and output variables see below             "
"                                                                      "
"  September 1996      Iwan Kawrakow        Initial coding (in fortran)"
"  March 1997          Alex Bielajew        Adaption for EGS4          "
"  April/Mai 1997      Iwan Kawrakow        Debuging of the EGS4       "
"                                           mortran version by Bielajew"
"  June 1997           Iwan Kawrakow        Improved energy loss       "
"                                           corrections                "
"  June 1999           Iwan Kawrakow        spin effects, removed      "
"                                           $SUBSTEP-ELOSS-EVALUATION  "
"                                                                      "
"======================================================================"
"                                                                      "
subroutine msdist_pII
(
    e0,eloss,tustep,rhof,med,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
    us,vs,ws,xf,yf,zf,ustep                                         "Outputs
);

$IMPLICIT-NONE;

" Input variables
" ===============
$REAL
    e0,     "electron kinetic energy at the beginning of step
    eloss,  "energy loss for this step
    rhof,   "density scaling template (as in EGS)
    tustep, "total pathlength of the step,
    u0,     "x-direction cosine before scattering
    v0,     "y-direction cosine before scattering
    w0,     "z-direction cosine before scattering
    x0,     "initial x-position
    y0,     "initial y-position
    z0      "initial z-position
;
$INTEGER
    med,"medium number
    qel    "=0 for e-, =1 for e+, needed for spin effects
;
$LOGICAL
    spin_effects;
;

" Output variables
" ================
$REAL
    us,    "x-direction cosine after scattering
    vs,    "y-direction cosine after scattering
    ws,    "z-direction cosine after scattering
    xf,    "final x-position after transport
    yf,    "final y-position after transport
    zf,    "final z-position after transport
    ustep  "straight line distance between the initial and final position
;

" Local variables
" ===============
$REAL
    b,         "substep transport distance,
    blccc,     "multiple scattering parameter
    xcccc,     "multiple scattering parameter
    c,         "substep transport distance,
    eta,eta1,  "randomization of the substep transport distances
    chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
    chilog,    "log(1+1/chia2)
    cphi0,     "cosine of the azimuthal angle of the initial particle relative
               "to its coordinates
    cphi1,     "cosine of the first azimuthal angle
    cphi2,     "cosine of the second azimuthal angle
    w1,        "cosine of the first substep polar scattering angle
    w2,        "cosine of the second substep polar scattering angle
    w1v2,      "w1*v2;
    delta,     "transport parameter (see paper)
    e,         "average kinetic energy over the step
    elke,      "Log(e)"
    beta2,     "speed at e in units of c, squared"
    etap,      "correction to the screening parameter derived from PWA
    xi_corr,   "correction to the first MS moments due to spin
    ms_corr,
    tau,       "average kinetic energy over the step divided by electron mass
    tau2,      "tau squared
    epsilon,   "fractional energy loss
    epsilonp,  "fractional energy loss
    temp,temp1,"auxilarity variables for energy loss corrections
    temp2,     "
    factor,    "intermediate factor employed in the energy-loss calculations
    gamma,     "q2/q1
    lambda,    "distance in number of elastic scattering mean free paths
               "for each sample of the multiple scattering angle
    p2,        "average momentum over the step
    p2i,       "inverse of ap2
    q1,        "first moment of the single scattering cross section
    rhophi2,   "xphi**2 + yphi**2 or its inverse
    sint0,     "sine of the initial particle relative to its coordinates
    sint02,    "sint0**2
    sint0i,    "1/sint0
    sint1,     "sine   of the first substep polar scattering angle
    sint2,     "sine   of the second substep polar scattering angle
    sphi0,     "sine of the azimuthal angle of the initial particle relative
               "to its coordinates
    sphi1,     "sine   of the first azimuthal angle
    sphi2,     "sine   of the second azimuthal angle
    u2p,       "intermediate scatter or transport direction cosine
    u2,        "sint2*cphi2;
    v2,        "sint2*sphi2;
    ut,        "x-direction cosine for transport
    vt,        "y-direction cosine for transport
    wt,        "z-direction cosine for transport
    xi,        "first GS - moment
    xphi,      "x - used to calculated azimuthal angles
    xphi2,     "xphi**2
    yphi,      "y - used to calculated azimuthal angles
    yphi2      "yphi**2
;
$LOGICAL
   find_index,  "needed to save locating the q2 index in the 2. call to mscat"
   spin_index   "saves locating the spin rejection index in 2. call to mscat"
;
$INTEGER
   lelke
;
$declare_max_medium;
;COMIN/ELECIN,THRESH,UPHIOT,RANDOM,CH-Steps,USEFUL,EMF-INPUTS/;
;COMIN/EM/;
medium  = med;

count_pII_steps = count_pII_steps + 1;
blccc   = blcc(medium);
xcccc   = xcc(medium);

"Commonly used factors
e       = e0 - 0.5*eloss;
tau     = e/prm;
tau2    = tau*tau;
epsilon = eloss/e0;
epsilonp= eloss/e;
"e       = e * (1 - epsilonp*epsilonp*((6+tau*(10+5*tau))/(tau+1)/(tau+2))/24);
e       = e * (1 - epsilonp*epsilonp*(6+10*tau+5*tau2)/(24*tau2+72*tau+48));
p2      = e*(e + rmt2);
"p2i     = 1/p2;
beta2   = p2/(p2 + rmsq);
"chia2   = xcccc*p2i/(4*blccc);
chia2   = xcccc/(4*p2*blccc);
lambda  = 0.5*tustep*rhof*blccc/beta2; "The 0.5 implies a half-step

temp2  = 0.166666*(4+tau*(6+tau*(7+tau*(4+tau))))*
             (epsilonp/((tau+1)*(tau+2)))**2;
lambda = lambda*(1 - temp2);

IF ( spin_effects ) [
   elke = Log(e);
   $SET INTERVAL elke,eke;
   IF ( lelke < 1 ) [ "This should normally not happen"
       lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
   ]
   IF( qel = 0 ) [
       $EVALUATE etap USING etae_ms(elke);
       $EVALUATE xi_corr USING q1ce_ms(elke);
       $EVALUATE gamma USING q2ce_ms(elke);
   ]
   ELSE [
       $EVALUATE etap USING etap_ms(elke);
       $EVALUATE xi_corr USING q1cp_ms(elke);
       $EVALUATE gamma USING q2cp_ms(elke);
   ]
   $EVALUATE ms_corr USING blcce(elke);
]
ELSE [ etap = 1; xi_corr = 1; gamma = 1; ms_corr = 1; ]

chia2  = chia2*etap;
lambda = lambda/(etap*(1+chia2))*ms_corr;
chilog = Log(1 + 1/chia2);
q1     = 2*chia2*(chilog*(1 + chia2) - 1);
gamma  = 6*chia2*(1 + chia2)*(chilog*(1 + 2*chia2) - 2)/q1*gamma;
xi     = q1*lambda;

"Sample first substep scattering angle
find_index = .true.; spin_index = .true.;
call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
           spin_effects,find_index,spin_index,
           w1,sint1);
$SELECT-AZIMUTHAL-ANGLE(cphi1,sphi1);

"Sample second substep scattering angle
call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
           spin_effects,find_index,spin_index,
           w2,sint2);
$SELECT-AZIMUTHAL-ANGLE(cphi2,sphi2);

"Final direction of motion, relative to z-axis motion
u2  = sint2*cphi2;
v2  = sint2*sphi2;
u2p = w1*u2 + sint1*w2;
us  = u2p*cphi1 - v2*sphi1;
vs  = u2p*sphi1 + v2*cphi1;
ws  = w1*w2 - sint1*u2;

"Calculate delta, b, c

xi = 2*xi*xi_corr;  "xi was for half step, xi_corr corrects for spin effects

$RANDOMSET eta; eta = Sqrt(eta); eta1 = 0.5*(1 - eta);
delta  = 0.9082483-(0.1020621-0.0263747*gamma)*xi;

"Correct the coefficients for energy loss
temp1 = 2 + tau;
temp = (2+tau*temp1)/((tau+1)*temp1);
"Take logarithmic dependence into account as well
temp = temp - (tau+1)/((tau+2)*(chilog*(1+chia2)-1));
temp = temp * epsilonp;
temp1 = 1 - temp;
delta = delta + 0.40824829*(epsilon*(tau+1)/((tau+2)*
          (chilog*(1+chia2)-1)*(chilog*(1+2*chia2)-2)) - 0.25*temp*temp);
           "0.40824829 is 1/Sqrt(6)"
b      = eta*delta;
c      = eta*(1-delta);

"Calculate transport direction cosines
w1v2 = w1*v2;
ut   = b*sint1*cphi1 + c*(cphi1*u2 - sphi1*w1v2) + eta1*us*temp1;
vt   = b*sint1*sphi1 + c*(sphi1*u2 + cphi1*w1v2) + eta1*vs*temp1;
wt   = eta1*(1+temp) +        b*w1 +  c*w2       + eta1*ws*temp1;

"Calculate transport distance
ustep  = tustep*sqrt(ut*ut + vt*vt + wt*wt);

"Rotate into the final direction of motion and transport
"relative to original direction of motion
sint02 = u0**2 + v0**2;
IF (sint02 > 1e-20)
[
    sint0  = sqrt(sint02);
    sint0i = 1/sint0;
    cphi0  = sint0i*u0;
    sphi0  = sint0i*v0;

    "Scattering angles
    u2p    = w0*us + sint0*ws;
    ws     = w0*ws - sint0*us;
    us     = u2p*cphi0 - vs*sphi0;
    vs     = u2p*sphi0 + vs*cphi0;

    "Transport angles
    u2p    = w0*ut + sint0*wt;
    wt     = w0*wt - sint0*ut;
    ut     = u2p*cphi0 - vt*sphi0;
    vt     = u2p*sphi0 + vt*cphi0;
]
ELSE [ wt = w0*wt; ws = w0*ws; ]

$EMFIELD_PII;
"Transport
xf = x0 + tustep*ut;
yf = y0 + tustep*vt;
zf = z0 + tustep*wt;

return;
end;

;

"                 subroutine msdist_pI                                 "
"                 ====================                                 "
"                                                                      "
"  This subroutine models multiple elastic scattering and spatial      "
"  deflections for a given path-length tustep                          "
"  resampling PRESTA-I behaviour.                                      "
"                                                                      "
"  October 1997        Iwan Kawrakow        Initial coding             "
"  June    1999        Iwan Kawrakow        spin effects               "
"                                                                      "
"======================================================================"
"                                                                      "
subroutine msdist_pI
(
    e0,eloss,tustep,rhof,medium,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
    us,vs,ws,xf,yf,zf,ustep                                         "Outputs
);

$IMPLICIT-NONE;

" Input variables
" ===============
$REAL
    e0,     "electron kinetic energy at the beginning of step
    eloss,  "energy loss for this step
    rhof,   "density scaling template (as in EGS)
    tustep, "total pathlength of the step,
    u0,     "x-direction cosine before scattering
    v0,     "y-direction cosine before scattering
    w0,     "z-direction cosine before scattering
    x0,     "initial x-position
    y0,     "initial y-position
    z0      "initial z-position
;
$INTEGER
    medium,"medium number
    qel    "=0 for e-, =1 for e+, needed for spin effects
;
$LOGICAL
    spin_effects
;

" Output variables
" ================
$REAL
    us,    "x-direction cosine after scattering
    vs,    "y-direction cosine after scattering
    ws,    "z-direction cosine after scattering
    xf,    "final x-position after transport
    yf,    "final y-position after transport
    zf,    "final z-position after transport
    ustep  "straight line distance between the initial and final position
;

" Local variables
" ===============
$REAL
    blccc,     "multiple scattering parameter
    xcccc,     "multiple scattering parameter
    z,r,z2,r2, "used to calculate PLC and lateral deflection a la PRESTA-I
    r2max,
    chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
    chilog,    "log(1+1/chia2)
    cphi0,     "cosine of the azimuthal angle of the initial particle relative
               "to its coordinates
    cphi,      "cosine of the azimuthal scattering angle
    sphi,      "sine of the  azimuthal scattering angle
    e,         "average kinetic energy over the step
    elke,      "Log(e)
    beta2,     "speed at e in units of c, squared
    etap,      "correction to the screening angle derived from PWA
    xi_corr,   "correction to the first MS moment due to spin
    ms_corr,
    epsilon,   "fractional energy loss
    temp,      "auxilarity variable for energy loss corrections
    factor,    "intermediate factor employed in the energy-loss calculations
    lambda,    "distance in number of elastic scattering mean free paths
    p2,        "average momentum over the step
    p2i,       "inverse of p2
    q1,        "first moment of the single scattering cross section
    rhophi2,   "xphi**2 + yphi**2 or its inverse
    sint,      "sine of the MS angle
    sint0,     "sine of the initial particle relative to its coordinates
    sint02,    "sint0**2
    sint0i,    "1/sint0
    sphi0,     "sine of the azimuthal angle of the initial particle relative
               "to its coordinates
    u2p,       "intermediate scatter or transport direction cosine
    ut,        "x-direction cosine for transport
    vt,        "y-direction cosine for transport
    wt,        "z-direction cosine for transport
    xi,        "first GS - moment
    xphi,      "x - used to calculated azimuthal angles
    xphi2,     "xphi**2
    yphi,      "y - used to calculated azimuthal angles
    yphi2      "yphi**2
;
$LOGICAL
   find_index, "needed to save locating the q2 index in the 2. call to mscat"
   spin_index
;
$INTEGER
   lelke
;
$declare_max_medium;
;COMIN/ELECIN,THRESH,UPHIOT,RANDOM,EMF-INPUTS/;
;COMIN/EM/;
blccc   = blcc(medium);
xcccc   = xcc(medium);

e       = e0 - 0.5*eloss;
p2      = e*(e + rmt2);
p2i     = 1/p2;
chia2   = xcccc*p2i/(4*blccc);
beta2   = p2/(p2 + rmsq);
lambda  = tustep*rhof*blccc/beta2;

"Account for energy loss in the MS distribution
factor = 1/(1 + 0.9784671*e); "0.9784671 = 1/(2*rm)
epsilon= eloss/e0;
epsilon= epsilon/(1-0.5*epsilon);
temp   = 0.25*(1 - factor*(1 - 0.333333*factor))*epsilon**2;
lambda = lambda*(1 + temp);

IF ( spin_effects ) [
   elke = Log(e);
   $SET INTERVAL elke,eke;
   IF ( lelke < 1 ) [ "This should normally not happen"
       lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
   ]
   IF( qel = 0 ) [
       $EVALUATE etap USING etae_ms(elke);
       $EVALUATE xi_corr USING q1ce_ms(elke);
   ]
   ELSE [
       $EVALUATE etap USING etap_ms(elke);
       $EVALUATE xi_corr USING q1cp_ms(elke);
   ]
   $EVALUATE ms_corr USING blcce(elke);
]
ELSE [ etap = 1; xi_corr = 1; ms_corr = 1; ]

chia2   = xcccc*p2i/(4*blccc)*etap;
lambda = lambda/etap/(1+chia2)*ms_corr;
chilog = Log(1 + 1/chia2);
q1     = 2*chia2*(chilog*(1 + chia2) - 1);
xi     = q1*lambda;

"Sample multiple scattering angle
find_index = .true.; spin_index = .true.;
call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
           spin_effects,find_index,spin_index,
           ws,sint);
$SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
us  = sint*cphi;
vs  = sint*sphi;

"Correct xi used for the PLC calc. for spin effects
xi     = xi*xi_corr;

"Calculate PLC and lateral transport a la PRESTA-I
"Note that we use here the exact expression for <z>
"because it is much simpler and faster than the original PRESTA-I formulas
"(which are also second order approximations)
IF ( xi < 0.1 )
[
   z = 1 - xi*(0.5 - xi*(0.166666667 - 0.041666667*xi));
]
ELSE
[
   z = (1 - Exp(-xi))/xi;
]
r  = 0.5*sint;
r2 = r*r; z2 = z*z;
r2max = 1 - z2;
IF ( r2max < r2 ) [ r2 = r2max; r = Sqrt(r2); ]

"Calculate final position vector
ut   = r*cphi; vt = r*sphi; wt = z;

"Calculate transport distance
ustep = Sqrt(z2 + r2)*tustep;

"Rotate into the final direction of motion and transport
"relative to original direction of motion
sint02 = u0**2 + v0**2;
IF (sint02 > 1e-20)
[
    sint0  = sqrt(sint02);
    sint0i = 1/sint0;
    cphi0  = sint0i*u0;
    sphi0  = sint0i*v0;

    "Scattering angles
    u2p    = w0*us + sint0*ws;
    ws     = w0*ws - sint0*us;
    us     = u2p*cphi0 - vs*sphi0;
    vs     = u2p*sphi0 + vs*cphi0;

    "Transport angles
    u2p    = w0*ut + sint0*wt;
    wt     = w0*wt - sint0*ut;
    ut     = u2p*cphi0 - vt*sphi0;
    vt     = u2p*sphi0 + vt*cphi0;
]
ELSE [ wt = w0*wt; ws = w0*ws; ]

$EMFIELD_PI;
"Transport
xf = x0 + tustep*ut;
yf = y0 + tustep*vt;
zf = z0 + tustep*wt;

return;
end;

;
%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE PAIR;
"                                                                  "
"******************************************************************"
"   For a photon energy below 2.1 MeV, the energies of the pair    "
"   particles are uniformly distributed in the allowed range via   "
"   the default replacement for $SELECT-LOW-ENERGY-PAIR-PRODICTION;"
"   If the user has a better approach, modify this macro.          "
"   For a photon energy between 2.1 and 50 MeV the Bethe-Heitler   "
"   cross section is employed, above 50 MeV the Coulomb-corrected  "
"   Bethe-Heitler is used.                                         "
"   Modified from its original version to make compatible with the "
"   changes made in BREMS.                                         "
"                                                                  "
"   I. Kawrakow                                                    "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-PAIR;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,STACK,"
                                 "THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-PAIR;

$DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;

$REAL    k,xx,abin,rbin,alias_sample1;
$INTEGER ibin, iq1, iq2, iprdst_use;
$LOGICAL do_nrc_pair;
$INTEGER itrip;
$REAL    ftrip;

NPold = NP;      "Set the old stack counter"

IF( i_play_RR = 1 ) [ " The user wants to play Russian Roulette. For pair "
                      " it is much more efficient to do it BEFORE the "
                      " actual sampling "
    i_survived_RR = 0;  "flag they all survive inititally"
    IF( prob_RR <= 0 ) [
        IF( n_RR_warning < $MAX-RR-WARNING ) [
          n_RR_warning = n_RR_warning + 1;
          $egs_warning('(a,g14.6)',
                      'Attempt to play Russian Roulette with prob_RR<0! ');
        ]
    ]
    ELSE [
        $RANDOMSET rnno_RR;
        IF( rnno_RR > prob_RR ) [  "The pair was killed "
            i_survived_RR =2; "flag both particles eliminated"
            IF( np > 1 ) [ np = np-1; ]
            ELSE [ " We have just one photon left on the stack. In order to  "
                   " get a proper exit from PHOTO, we have to leave at least "
                   " one particle on the stack                               "
                wt(np) = 0; e(np) = 0;
            ]
            return;
        ]
        ELSE [ "The pair survived, increase the weight"
            wt(np) = wt(np)/prob_RR;
        ]
    ]
]

$CHECK-STACK(np+1,'PAIR');
PEIG=E(NP); "PRECISE ENERGY OF INCIDENT GAMMA"
EIG=PEIG;   "ENERGY OF INCIDENT GAMMA"
do_nrc_pair = .false.;

IF( itriplet > 0 & eig > 4*rm ) [
    itrip = dli_triplet*gle + bli_triplet;
    ftrip = a_triplet(itrip,medium)*gle + b_triplet(itrip,medium);
    $RANDOMSET rnno34;
    IF( rnno34 < ftrip ) [  " Triplet production "
        call sample_triplet;
        return;
    ]
]

IF( pair_nrc = 1 ) [  "Sample from the NRC pair cross section data base"
                      "(privided the energy is within the available range)"
    k = eig/rm;
    IF( k < nrcp_emax ) [
        do_nrc_pair = .true.;
        IF( k <= nrcp_emin ) [ ibin = 1; ]
        ELSE [
            abin = 1 + log((k-2)/(nrcp_emin-2))*nrcp_dlei;
            ibin = abin; abin = abin - ibin;
            $RANDOMSET rbin;
            IF( rbin < abin ) ibin = ibin + 1;
        ]
        xx = alias_sample1($NRC-PAIR-NX-1,nrcp_xdata,
                nrcp_fdata(1,ibin,medium),nrcp_wdata(1,ibin,medium),
                nrcp_idata(1,ibin,medium));
           " The above returns the energy fraction of the positron "
        IF( xx > 0.5 ) [
            pese1 = prm*(1 + xx*(k-2)); iq1 = 1;
            pese2 = peig - pese1; iq2 = -1;
        ]
        ELSE [
            pese2 = prm*(1 + xx*(k-2)); iq2 = 1;
            pese1 = peig - pese2; iq1 = -1;
        ]
    ]
]


IF( ~do_nrc_pair ) [
IF (EIG.LE.2.1) [
    "   BELOW 2.1,USE APPROXIMATION"
    $SELECT-LOW-ENERGY-PAIR-PRODICTION;
]
ELSE[   "ABOVE 2.1, MUST SAMPLE"

    "   DECIDE WHETHER TO USE BETHE-HEITLER or BH
    "   COULOMB CORRECTED

    IF (EIG.LT.50.) [ "Use BH without Coulomb correction"

        L = 5;
        L1 = L + 1;

        "Find the actual rejection maximum for this photon energy"
        delta = 4*delcm(medium)/eig;
        IF( delta < 1 ) [
           Amax = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
           Bmax = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
        ]
        ELSE [
           aux2 = log(delta+dl6(l,medium));
           Amax = dl4(l,medium)+dl5(l,medium)*aux2;
           Bmax = dl4(l1,medium)+dl5(l1,medium)*aux2;
        ]
        "and then calculate the probability for sampling from (br-1/2)**2"
        aux1 = 1 - rmt2/eig; aux1 = aux1*aux1;
        aux1 = aux1*Amax/3; aux1 = aux1/(Bmax+aux1);
    ]
    ELSE [
        "Use BH Coulomb-corrected"
        L = 7;
        "The absolute maxima are close to the actual maxima at high energies"
        "=>use the absolute maxima to save time"
        Amax = dl1(l,medium); Bmax = dl1(l+1,medium);
        aux1 = bpar(2,medium)*(1-bpar(1,medium)*rm/eig);
    ]

    del0 = eig*delcm(medium);
    Eavail = eig - rmt2;

    LOOP [

        $RANDOMSET RNNO30; $RANDOMSET RNNO31; $RANDOMSET RNNO34;
        IF( rnno30 > aux1 ) [ "use the uniform part"
            br = 0.5*rnno31;  rejmax = Bmax; l1 = l+1;
        ]
        ELSE [  "use the (br-1/2)**2 part of the distribution"
            $RANDOMSET rnno32; $RANDOMSET rnno33;
            br = 0.5*(1-max(rnno31,rnno32,rnno33));
            rejmax = Amax; l1 = l;
        ]
        Eminus = br*Eavail + rm;
        Eplus  = eig - Eminus;
        delta = del0/(Eminus*Eplus);
        IF( delta < 1 ) [
           rejf = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
        ]
        ELSE [
          rejf = dl4(l1,medium)+dl5(l1,medium)*log(delta+dl6(l1,medium));
        ]

    ] UNTIL ( rnno34*rejmax <= rejf );

    pese2 = Eminus; pese1 = peig - pese2;
    $RANDOMSET RNNO34;
    IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]

]
]

"   ENERGY GOING TO LOWER SECONDARY HAS NOW BEEN DETERMINED"
ESE2=PESE2;
E(NP)=PESE1; E(NP+1)=PESE2;
"   THIS AVERAGE ANGLE OF EMISSION FOR BOTH PAIR PRODUCTION AND"
"   BREMSSTRAHLUNG IS MUCH SMALLER THAN THE AVERAGE ANGLE OF"
"   MULTIPLE SCATTERING FOR DELTA T TRANSPORT=0.01 R.L."
"   THE INITIAL AND FINAL MOMENTA ARE COPLANAR "
"   SET UP A NEW 'ELECTRON'  "
$SET-PAIR-ANGLE;
" DEFAULT FOR $SET-PAIR-ANGLE; is to select the angle from the leading term"
" of the angular distribution "
CALL UPHI(1,1);
"   SET UP A NEW 'ELECTRON' "
NP=NP+1;
SINTHE=-SINTHE;
CALL UPHI(3,2);

IQ(NP)=iq2; IQ(NP-1)=iq1;
RETURN;
"END OF SUBROUTINE PAIR"    END;

"***************************************************************************"
"                                                                           "
" Sampling of triplet production events.                                    "
"                                                                           "
" The treatment is based on Borsellino's first Born approximation           "
" result (see Eq. 4B-3002 in the pair article of Motz, Olsen & Koch)        "
" As the kinematic of the process is already complicated enough and the     "
" cross section itself is not simple either, a Markov-chain method is used  "
" to sample triplet events from the Borsellino equation without any         "
" additional approximations (other then the use of the first Born           "
" approximation and the assumption of free electrons implied by             "
" Borsellino's derivation)                                                  "
"                                                                           "
" Iwan Kawrakow, April 2005.                                                "
"***************************************************************************"

subroutine sample_triplet;

"***************************************************************************"
implicit none;
$declare_max_medium;
;COMIN/EPCONT,STACK,MEDIA,THRESH,USEFUL,RANDOM,USER,EGS-IO/;
$declare_write_buffer;

" We use double precision throughout as in many cases the kinematically "
" permitted angular interval is too small to be resolved accurately enough "
" in single precision "

real*8 fmax_array($MAX_TRIPLET), eta_p_array($MAX_TRIPLET),
       eta_Ep_array($MAX_TRIPLET), eta_costp_array($MAX_TRIPLET),
       eta_costm_array($MAX_TRIPLET), ebin_array($MAX_TRIPLET),
       wp_array($MAX_TRIPLET), qmin_array($MAX_TRIPLET);

real*8 kmin, kmax, dlogki, alogkm, prmi, tiny_eta;

real*8 ai,rnno,k,qmin,qmax,aux,a1,a2,a3,D,px1,px2,pp_min,pp_max,
       Ep_min,Ep_max,k2p2,k2p2x,peig,b,aux1,aux12,D1,aux3,xmin,xmax,
       aux6,aux7,uu,cphi,sphi,cphi_factor,aux5,phi,tmp;
real*8 Er,pr,pr2,eta_pr;
real*8 Ep,pp,pp2,wEp,cost_p,sint_p,eta_Ep,mup_min,wmup,
       eta_costp,Epp,pp_sintp,pp_sntp2;
real*8 Em,pm,pm2,cost_m,sint_m,Emm,wmum,pm_sintm,
       eta_costm;
real*8 k2,k3,s2,s3,k2k3i,k22,k32,q2,aux4,S_1,S_2,sigma;
real*8 ppx, ppy, ppz, pmx, pmy, pmz, prx, pry, prz,
       a,c,sindel,cosdel,sinpsi;

$INTEGER i;
$LOGICAL use_it;
$INTEGER iscore; " needed for BEAM "

$LOGICAL is_initialized;
data is_initialized/.false./;
save is_initialized,fmax_array,eta_p_array,eta_Ep_array,eta_costp_array,
     eta_costm_array,ebin_array,wp_array,qmin_array,
     kmin,kmax,dlogki,alogkm,prmi,tiny_eta;

IF( ~is_initialized ) [
    is_initialized = .true.;
    tiny_eta = 1e-6;
    " Set current cross section value to -1 in each energy bin "
    DO i=1,$MAX_TRIPLET [ fmax_array(i) = -1; ]
    " Find the maximum energy of the cross section data "
    kmax = 0; kmin = 4.1*prm;
    DO i=1,nmed [ IF( up(i) > kmax ) kmax = UP(i); ]
    IF( kmax <= kmin ) return;
    dlogki = $MAX_TRIPLET - 1; dlogki = dlogki/log(kmax/kmin);
    alogkm = 1 - dlogki*log(kmin);
    prmi = 1/prm;
    DO i=1,$MAX_TRIPLET [
        k = 4.1*exp((i-1.)/dlogki); ebin_array(i) = k;
        qmin = 4*k/(k*(k-1)+(k+1)*sqrt(k*(k-4)));
        qmax = (k*(k-1) + (k+1)*sqrt(k*(k-4)))/(2*k+1);
        qmin_array(i) = qmin; wp_array(i) = log(qmax/qmin);
    ]
]

peig = e(np);
IF( peig <= 4*prm ) return;
$CHECK-STACK(np+2,'sample_triplet');

" Determine energy bin "
IF( peig <= kmin ) [ i = 1; ]
ELSE IF( peig >= kmax ) [ i = $MAX_TRIPLET; ]
ELSE [
    ai = alogkm + dlogki*gle; i = ai; ai = ai - i;
    $RANDOMSET rnno;
    IF( rnno < ai ) [ i = i+1; ]
]

" First use the bin energy to sample the random numbers "
" that determine recoil momentum and electron/postron angles "
k = ebin_array(i);

/*
   In the following:  k is incident photon energy in units of m*c^2
                      (all energies are in units of m*c^2, momenta in
                       units of m*c)
                      Er,pr is energy, momentum of the recoil electron
                      Ep,pp is energy, momentum of the pair positron
                      Em,pm is energy, momentum of the pair electron
                      cost_p, sint_p is cos, sin of the positron angle
                                     with respect to k
                      cost_m, sint_m same but for the electron
                      cphi is cos of azimuthal angle between positron
                              and pair electron directions.
*/

:retry_triplet:;

" Pick the recoil electron momentum from 1/p.
$RANDOMSET eta_pr; IF( eta_pr < tiny_eta ) eta_pr = tiny_eta;
pr = qmin_array(i)*exp(eta_pr*wp_array(i));
pr2 = pr*pr; Er = sqrt(1+pr2);

" Determine min./max. kinematically permitted postron energy for "
" this k and p "
aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
ELSE            [ pp_min = px2; pp_max = px1; ]
Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);

" Pick the positron energy "
$RANDOMSET eta_Ep; IF( eta_Ep < tiny_eta ) eta_Ep = tiny_eta;
wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;

" Now we can determine the pair electron energy from energy conservation "
Em = k + 1 - Er - Ep;
pm2 = Em*Em-1; pm = sqrt(pm2);

" The minimum cosine of the positron angle follows from the kinematics. "
mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);

" Now pick the positron direction from 1/(Ep-pp*cost_p) "
$RANDOMSET eta_costp; IF( eta_costp < tiny_eta ) eta_costp = tiny_eta;
Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
wmup = wmup*(cost_p - Epp);
sint_p = 1-cost_p*cost_p;
IF( sint_p > 1e-20 ) [ sint_p = sqrt(sint_p); ] ELSE [ sint_p = 1e-10; ]
k2p2x = k2p2 - 2*k*pp*cost_p;

" The minimum amd maximum cosine of the pair electron angle follows from "
" the kinematics "
b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
D1 = pm2*(aux12+pp_sntp2)-b*b/4;
if( D1 <= 0 ) [ goto :retry_triplet:; ]
D = 2*pp_sintp*sqrt(D1);
aux3 = 0.5/(aux12+pp_sntp2);
xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;

" Now pick the electron direction from "
"  1/(Em-pm*cost_m)/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) "
" We have to take into account the "
" 1/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) factor in the sampling "
" otherwise we end up with 1/sqrt() singularities near the ends of the "
" allowed cost_m range                                                 "
$RANDOMSET eta_costm; IF( eta_costm < tiny_eta ) eta_costm = tiny_eta;
aux6 = sqrt((Em-xmin)/(Em-xmax));
aux7 = aux6*tan(1.570796326794897*eta_costm);
uu = (aux7-1)/(aux7+1);
cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu));
wmum = sqrt((xmax-cost_m)*(cost_m-xmin));
wmum = wmum*aux6*(Em-cost_m)/(Em-xmin);
cost_m = cost_m/pm;
sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;

" Now we have selected all independent kinematic variables. "
" Determine the azimuthal angle between the pair electrons "
cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
sphi = sqrt(1-cphi*cphi);

" And now evaluate the Borsellino cross section "
k3 = k*(pp*cost_p - Ep); k2 = k*(pm*cost_m - Em);
k22 = k2*k2; k32 = k3*k3; k2k3i = 1/(k2*k3);
s2 = pp*pm*(cost_p*cost_m + sint_p*sint_m*cphi) - Ep*Em;
s3 = k2 - Em + 1 - s2; q2 = 2*(Er-1);
S_1 = k32+k22+(q2-2)*s2-(1-q2/2)*(k32+k22)*k2k3i;
aux4 = k3*Ep-k2*Em;
S_2 = -q2*(Ep*Ep+Em*Em) + 2*s2 - (2*aux4*aux4 - k22 - k32)*k2k3i;
sigma = abs(pp*pm2*pm*k2k3i/(q2*q2*(Em*s3+Er))*(S_1*(1-q2/4)+S_2*(1+q2/4)));

" We get the following factor due to the transformation from phi to "
" the recoil momentum pr "
cphi_factor = abs(2*Er*pm2-Em*(k2p2x-pr2-pm2))/(2*pp_sintp*pm_sintm*pm2*sphi);

" We have to also multiply by the various factors from the sampling of "
" pr, Ep, cost_p and cost_m "
sigma = sigma*cphi_factor*wEp*wmup*wmum*wp_array(i)*pr2/Er;
IF( sigma < 0 ) [
    $egs_warning(*,'In triplet sigma < 0 ? ',sigma);
]

" Now determine if we accept this new event "
use_it = .true.;
IF( sigma < fmax_array(i) ) [
    $RANDOMSET rnno;
    IF( sigma < fmax_array(i)*rnno ) [ use_it = .false. ]
]
IF( use_it ) [       " Yes, event accepted "
    fmax_array(i) = sigma;
    eta_p_array(i) = eta_pr; eta_Ep_array(i) = eta_Ep;
    eta_costp_array(i) = eta_costp; eta_costm_array(i) = eta_costm;
] ELSE [             " Nop, event rejected => use last accepted "
    eta_pr = eta_p_array(i); eta_Ep = eta_Ep_array(i);
    eta_costp = eta_costp_array(i); eta_costm = eta_costm_array(i);
]

" We now have a set of random number accepted for sampling around "
" the i'th bin energy. We need to recalculate all variables using "
" the actual photon energy "

k = peig*prmi;
aux5 = k*(k-1)+(k+1)*sqrt(k*(k-4));
qmin = 4*k/aux5; qmax = aux5/(2*k+1);
pr = qmin*exp(eta_pr*log(qmax/qmin));
pr2 = pr*pr; Er = sqrt(1+pr2);

aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
ELSE            [ pp_min = px2; pp_max = px1; ]
Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);

wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;
Em = k + 1 - Er - Ep;
pm2 = Em*Em-1; pm = sqrt(pm2);

mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);
Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
sint_p = sqrt(1-cost_p*cost_p);
k2p2x = k2p2 - 2*k*pp*cost_p;

b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
D1 = pm2*(aux12+pp_sntp2)-b*b/4;
if( D1 <= 0 ) [ goto :retry_triplet:; ]
D = 2*pp_sintp*sqrt(D1);
aux3 = 0.5/(aux12+pp_sntp2);
xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;
aux6 = sqrt((Em-xmin)/(Em-xmax));
aux7 = aux6*tan(1.570796326794897*eta_costm);
uu = (aux7-1)/(aux7+1);
cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))/pm;
sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;

cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
sphi = sqrt(1-cphi*cphi);

/*
   OK, now the final momenta are
     Positron:     (pp*sint_p,      0,             pp*cost_p)
     Electron:     (pm*sint_m*cphi,pm*sint_m*sphi, pm*cost_m)
 Recoil electron:  k - pp - pm
   This is in a frame where the photon is moving along the z axis.
   We have to pick another azimuthal angle randomly, rotate the
   x- and y- components of pp and pm by that, determine the recoil
   momentum from momentum conservation and then rotate all three
   momenta back into the lab frame.
*/
$RANDOMSET phi; phi = phi*6.283185307179586;
ppx = pp*sint_p; ppy = 0;
pmx = pm*sint_m*cphi; pmy = pm*sint_m*sphi;
cphi = cos(phi); sphi = sin(phi);
tmp = ppx*sphi; ppx = ppx*cphi - ppy*sphi; ppy = tmp + ppy*cphi;
tmp = pmx*sphi; pmx = pmx*cphi - pmy*sphi; pmy = tmp + pmy*cphi;
ppz = pp*cost_p; pmz = pm*cost_m;
prx = -ppx-pmx; pry = -ppy-pmy; prz = k - ppz - pmz;
" Set up particles on the stack ";
" We always put the recoil electron on top (even if its energy is higher "
" then the energies of the pair particles) because                       "
"   - that way, we know which particle is the recoil  electron in case   "
"     we want to score some quantity related to it                       "
"   - its energy is, on average, lower than the pair particle energies   "
NPold = np;
$TRANSFER PROPERTIES TO (np)   FROM (np);
$TRANSFER PROPERTIES TO (np+1) FROM (np);
$TRANSFER PROPERTIES TO (np+2) FROM (np+1);
pp = 1/pp; pm = 1/pm; pr = 1/pr;
a = u(np); b = v(np); c = w(np); sinpsi = a*a + b*b;
IF( sinpsi > 1e-20 ) [
    sinpsi = sqrt(sinpsi); sindel = b/sinpsi; cosdel = a/sinpsi;
    IF( Ep > Em ) [
        u(np)   = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
        v(np)   = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
        w(np)   = pp*(c*ppz - sinpsi*ppx); iq(np) = 1; E(np) = Ep*prm;
        u(np+1) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
        v(np+1) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
        w(np+1) = pm*(c*pmz - sinpsi*pmx); iq(np+1) = -1; E(np+1) = Em*prm;
    ]
    ELSE [
        u(np+1) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
        v(np+1) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
        w(np+1) = pp*(c*ppz - sinpsi*ppx); iq(np+1) = 1; E(np+1) = Ep*prm;
        u(np)   = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
        v(np)   = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
        w(np)   = pm*(c*pmz - sinpsi*pmx); iq(np) = -1; E(np) = Em*prm;
    ]
    np = np + 2;
    u(np)   = pr*(c*cosdel*prx - sindel*pry + a*prz);
    v(np)   = pr*(c*sindel*prx + cosdel*pry + b*prz);
    w(np)   = pr*(c*prz - sinpsi*prx); iq(np) = -1; E(np) = Er*prm;
] ELSE [
    IF( Ep > Em ) [
        u(np) = pp*ppx; v(np) = pp*ppy; w(np) = c*pp*ppz;
        iq(np) = 1; E(np) = Ep*prm;
        u(np+1) = pm*pmx; v(np+1) = pm*pmy; w(np+1) = c*pm*pmz;
        iq(np+1) = -1; E(np+1) = Em*prm;
    ]
    ELSE [
        u(np+1) = pp*ppx; v(np+1) = pp*ppy; w(np+1) = c*pp*ppz;
        iq(np+1) = 1; E(np+1) = Ep*prm;
        u(np) = pm*pmx; v(np) = pm*pmy; w(np) = c*pm*pmz;
        iq(np) = -1; E(np) = Em*prm;
    ]
    np = np + 2;
    u(np) = pr*prx; v(np) = pr*pry; w(np) = c*pr*prz;
    iq(np) = -1; E(np) = Er*prm;
]

return; end;

%E
"******************************************************************"
SUBROUTINE PHOTO;
"******************************************************************"
" Programmers:  I. Kawrakow, complete recoding,                    "
"                            Fluorescent X-rays, Auger,            "
"                            Coster-Kronig treated in RELAX        "
"               A.F. Bielajew (NRC) photoelectric angular distn    "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-PHOTO; "default replacement is:
              "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
                  "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"

$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
$DEFINE-LOCAL-VARIABLES-PHOTO;
/* $REAL ftot,iprob; */
data n_warning/0/;

IF ( mcdf_pe_xsections )[call egs_shellwise_photo();return;]

NPold = NP;      "Set the old stack counter"
PEIG=E(NP); irl = ir(np);
IF( peig < edge_energies(2,1) ) [
    IF( n_warning < 100 ) [
        n_warning = n_warning + 1;
        $egs_info(*,' Subroutine PHOTO called with E = ',peig,
                   ' which is below the current min. energy of 1 keV! ');
        $egs_info(*,' Converting now this photon to an electron, ');
        $egs_info(*,' but you should check your code! ');
    ]
    iq(np) = -1;
    e(np) = peig + prm;
    return;
]

iZ = iedgfl(irl);
do_relax = .false.;
edep = pzero;
IF( iedgfl(irl) ~= 0 ) [   " User requested atomic relaxations "
                           " first sample the element "
    IF( nne(medium) = 1 ) [
        iZ = int( zelem(medium,1) + 0.5 );
        DO j=1,edge_number(iZ) [
            IF( peig >= edge_energies(j,iZ) ) EXIT;
        ]
    ]
    ELSE [
        aux = peig*peig; aux1 = aux*peig; aux = aux*Sqrt(peig);
        sigtot = 0;
        DO k=1,nne(medium) [
            iZ = int( zelem(medium,k) + 0.5 );
            IF( iZ < 1 | iZ > $MXELEMENT ) [
                $egs_info(*,' Error in PHOTO: ');
                $egs_fatal(*,'   Atomic number of element ',k,
                   ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
            ]
            IF( peig > edge_energies(1,iZ) ) [
                j = 1;
                sigma = (edge_a(1,iZ) + edge_b(1,iZ)/peig +
                     edge_c(1,iZ)/aux + edge_d(1,iZ)/aux1)/peig;
            ]
            ELSE [
                DO j=2,edge_number(iZ) [
                    IF( peig >= edge_energies(j,iZ) ) EXIT;
                ]
                sigma = edge_a(j,iZ) + gle*(edge_b(j,iZ) + gle*(edge_c(j,iZ) +
                        gle*edge_d(j,iZ) ));
                sigma = Exp(sigma);
            ]
            sigma = sigma * pz(medium,k);
            sigtot = sigtot + sigma;
            probs(k) = sigma;
            ints(k) = j;
        ]
        $RANDOMSET br; br = br*sigtot;
        DO k=1,nne(medium) [
            br = br - probs(k);
            IF( br <= 0 ) EXIT;
        ]
        iZ = int( zelem(medium,k) + 0.5 );
        j  = ints(k);
    ]
    " Now we know the atomic number (iZ) and the energy interval the "
    " photon energy is in (j). It is time to sample the shell the photon "
    " is interacting with. "
    " left for now as before, to be changed!!! "
    IF( peig <= binding_energies($MXSHELL,iZ) )
    [   "Outer shells, no atomic relaxation"
           "EADL relax: Below  M2-shell -> just emit e- "
           iq(np) = -1;
           e(np) = peig + prm;
    ]
    ELSE ["Above  N-shell -> sample the shell the photon is interacting with"
        $RANDOMSET br; /* ftot = 1;  */
        DO k=1,$MXINTER [
            IF( peig > binding_energies(k,iZ) ) [
                IF( br < interaction_prob(k,iZ) ) EXIT;
                br = (br - interaction_prob(k,iZ))/(1-interaction_prob(k,iZ));
            ]
        ]
        "Interaction possible with any shell from k=1 to $MXSHELL"
        "Defaults to $MXSHELL interaction if DO loop completes"
        "****************"
        "EADL APPROACH 1: Do not allow interaction below L3. Deviates"
        "**************** from previous EGSnrc approach as it doesn't"
        "                 generate e- nor x-rays from <M> and <N> shells."
        IF (eadl_relax & k > 4)[
           "No initial vacancy below L3 for now, just emit e-"
           iq(np) = -1;
           e(np) = peig + prm;
        ]
        ELSE["EADL:    Interacts with K,L1..L3 shells"
             "default: Interacts with K,L1..L3,<M>, and <N> shells"
           e_vac = binding_energies(k,iZ);
           e(np) = peig - e_vac + prm; do_relax = .true.;
           iq(np) = -1;
        ]
    ]
]
ELSE [
    e(np) = peig + prm; iq(np) = -1;
]

IF( iq(np) = -1 ) [
    $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
]

"****************"
"EADL APPROACH 2: PE interactions with K, L1...L3,<M> and <N> shells,"
"**************** but vacancies below L3 deposit energy locally. It wont"
"                 produce x-rays from <M> and <N> shells."
"IF ($EADL_RELAX & k > 4)[
"   edep = e_vac; do_relax = .false.;
"]
IF( do_relax ) [
    call relax(e_vac,k,iZ);
]

IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"

;
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"

return;
end;

%E
"******************************************************************"
subroutine egs_shellwise_photo;
"******************************************************************"
" Derived from PHOTO by I. Kawrakow and A.F. Bielajew              "
" Shellwise implementation and      "
"                                sampling optimizations            "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-PHOTO; "default replacement is:
              "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
                  "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"
;COMIN/PE-SHELL-DATA/;

$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
$DEFINE-LOCAL-VARIABLES-PHOTO;
$REAL slope, logE, int_prob;
$INTEGER zpos, ibsearch;
data n_warning/0/;

NPold = NP;      "Set the old stack counter"
PEIG=E(NP); irl = ir(np);
do_relax = .false.;
IF( peig < $RELAX-CUTOFF ) [
    IF( n_warning < 100 ) [
        n_warning = n_warning + 1;
        $egs_info(*,' Subroutine egs_shellwise_photo called with E = ',
                    peig,' which is below the current min. energy of ',
                   $RELAX-CUTOFF,' keV! ');
        $egs_info(*,' Converting now this photon to an electron, ');
        $egs_info(*,' but you should check your code! ');
    ]
    iq(np) = -1;
    e(np) = peig + prm;
    return;
]

edep = pzero;

IF( iedgfl(irl) ~= 0 ) [" User requested atomic relaxations "
                        " sample element and atomic shell for"
   j = -1;              " the interaction."
   IF( nne(medium) = 1 ) [
    iZ = int( zelem(medium,1) + 0.5 ); zpos = pe_zpos(iZ);
    IF( pe_nshell(zpos) > 0) [
      logE = log(peig);
      j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
    ]
   ]
   ELSE [
      $RANDOMSET br; logE = log(peig);
      "DO k=1,nne(medium) ["
      DO k=nne(medium),1,-1 [
          iZ = int( zelem(medium,k) + 0.5 );zpos = pe_zpos(iZ);
          IF( iZ < 1 | iZ > $MXELEMENT ) [
              $egs_info(*,' Error in egs_shellwise_photo: ');
              $egs_fatal(*,'   Atomic number of element ',k,
                 ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
          ]
          j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
          slope    = pe_elem_prob(j+1,k,medium) - pe_elem_prob(j,k,medium);
          slope    = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
          int_prob = pe_elem_prob(j,k,medium)+slope*(logE-pe_energy(j,zpos));
          br -= exp(int_prob);
          IF ( br <= 0 ) EXIT;
      ]
   ]
   " Now we know the atomic number (iZ) and the energy interval the "
   " photon energy is in (j). It is time to sample the shell the photon "
   " is interacting with. "
   IF( peig < pe_be(zpos,pe_nshell(zpos)) | pe_nshell(zpos) = 0 )
   [   "no atomic relaxation, create photo-electron"
         iq(np) = -1;
         e(np) = peig + prm;
   ]
   ELSE ["sample the shell the photon is interacting with"
      $RANDOMSET br; sigtot = 0;
      DO k=1,pe_nshell(zpos) [
          IF( peig > pe_be(zpos,k) ) [
            slope = pe_xsection(j+1,zpos,k) - pe_xsection(j,zpos,k);
            slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
            int_prob=pe_xsection(j,zpos,k)+slope*(logE-pe_energy(j,zpos));
            br -= exp(int_prob); sigtot += exp(int_prob);
            IF ( br <= 0 ) EXIT;
          ]
      ]
      IF (k > pe_nshell(zpos))["outer shell, create photo-electron"
         iq(np) = -1;
         e(np) = peig + prm;
      ]
      ELSE[
         e_vac = pe_be(zpos,k);
         e(np) = peig - e_vac + prm; do_relax = .true.;
         iq(np) = -1;
      ]
   ]
]
ELSE ["No atomic relaxations, just create photo-electron"
    e(np) = peig + prm; iq(np) = -1;
]

IF( iq(np) = -1 ) [
    $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
]

IF( do_relax ) [
    call egs_eadl_relax(iZ,k);
]

IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"

;
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"

return;
end;

"*************************************************************************"
subroutine egs_read_shellwise_pe;
"*************************************************************************"

$IMPLICIT-NONE;

$declare_max_medium;
$COMIN-SHELLWISE-PE-INIT;

$INTEGER   lnblnk1,egs_get_unit,pe_sw_unit,ounit,egs_open_file;
$INTEGER   sorted($MXELEMENT),i,j,k,l,m;
$REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
$REAL      rest_xs($MXNE,$MXELEMENT);
$REAL      tmp_e($MXNE,$MXPESHELL), tmp_xs($MXNE,$MXPESHELL);
$REAL      new_e($MXNE),deltaEb,slope;
$INTEGER   zread($MXELEMENT),ib($MXPESHELL),ibsearch;
character  data_dir*128,pe_sw_file*144;

$INTEGER  medio,iZ,iZpos,egs_read_int,pos,curr_rec;
real*4    egs_read_real,e_r, e_old,sigma_r;
integer*2 nz, egs_read_short,ish, i_nshell,i_nge;
$LOGICAL  is_open, is_there, shift_required;

character*3 labels(16);
data labels/'  K',' L1',' L2',' L3',
            ' M1',' M2',' M3',' M4',' M5',
            ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/;

/*********************************************
   Open PE shellwise data file photo_shellwise.data
 **********************************************/
$egs_info('(/a$)',
' Reading renormalized photoelectric cross sections ......');
data_dir = $cstring(hen_house) // 'data' // $file_sep;
pe_sw_file = $cstring(data_dir) // 'photo_shellwise.data';

/* Open a fortran unit for reading data */
pe_sw_unit = egs_get_unit(0);
IF( pe_sw_unit < 1 ) [
  $egs_fatal(*,'egs_init_shellwise_pe: failed to get a free Fortran I/O unit');
]
open(pe_sw_unit,file=pe_sw_file,status='old',
     form='UNFORMATTED',ACCESS='direct',recl=1,
     err=:no-pe-sw-file:);
GOTO :read-pe-sw:;
:no-pe-sw-file:
$egs_fatal('(2a)','egs_init_shellwise_pe: failed to open ',
           pe_sw_file);
:read-pe-sw:
is_open = .true.;
/******************************
   Array initialization
 ******************************/
DO medio = 1,nmed [
   DO i=1,nne(medio) [
      pe_nshell(i*medio) = 0;
      pe_nge(i*medio) = 0;
      pe_zsorted(i,medio) = 0;
   ]
]
DO l = 1,$MXELEMENT [
   pe_zpos(l) = -1;
   DO k = 1,$MXNE [
      pe_energy(k,l) = 0.0;
      DO m = 1,$MXPESHELL [
         pe_xsection(k,l,m) = 0.0;
      ]
   ]
   DO k = 1,$MXPESHELL [
      pe_be(l,k) = -99;
   ]
]

/******************************
   Get shellwise PE xsections
 ******************************/
curr_rec = 1; iZpos = 0;
nz = egs_read_short(pe_sw_unit,curr_rec);
"$egs_info('(a,i2,a)','PE shellwise data available for ',nz,' elements....');"
DO medio = 1,nmed [
   DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
   call egs_heap_sort(nne(medio),z_sorted,sorted);
   DO i=1,nne(medio) [pe_zsorted(i,medio) = z_sorted(i);]
   DO i=1,nne(medio) [
      iZ = z_sorted(i);
      "Now check whether we have already loaded the data for"
      "this atomic number"
      is_there = .false.;
      DO j = 1,medio-1 [
         DO k = 1, nne(j)[
           IF( iZ = pe_zsorted(k,j) ) [
               is_there = .true.; EXIT;
           ]
         ]
      ]
      IF (is_there) NEXT;
      "Read data for this element"
      iZpos += 1; zread(iZpos) = iZ;
      pe_zpos(iZ) = iZpos;
      pos         = 3 + (iZ-1)*4;
      curr_rec    = egs_read_int(pe_sw_unit,pos) + 1;
      i_nge       = egs_read_short(pe_sw_unit,curr_rec);
      i_nshell    = egs_read_short(pe_sw_unit,curr_rec);
      "$egs_info('(a,i2,a,i3,a,i2,a)','Element ',iZ,' has ',i_nge,
      "  ' energy points and ',i_nshell,' shells');
      pe_nge(iZpos) = i_nge; pe_nshell(iZpos) = i_nshell;
      e_old = -1.0; ish = 0;
      DO j = 1,i_nge[
         e_r = egs_read_real(pe_sw_unit,curr_rec);
         sigma_r = egs_read_real(pe_sw_unit,curr_rec);
         pe_energy(j,iZpos) = e_r;
         pe_xsection(j,iZpos,0) = sigma_r;
         rest_xs(j,iZpos) = sigma_r;
         DO k = 1, i_nshell[
            sigma_r =  egs_read_real(pe_sw_unit,curr_rec);
            pe_xsection(j,iZpos,k) = sigma_r;
            rest_xs(j,iZpos) = rest_xs(j,iZpos) - sigma_r;

         ]
         "Extract binding energies from the data base"
         IF (e_r - e_old < 1e-15)[
            pe_be(iZpos,i_nshell-ish) = e_r;
            ish += 1;
         ]
         e_old = e_r;

      ]
      "DO k = 1, i_nshell[
      "   $egs_info('(a2,a3,a2,1pe12.4,a4)',
      "             'E(',labels(k),')=',pe_be(iZpos,k),' MeV');
      "]

   ]
]
pe_ne = iZpos;
"$egs_info('(a,i2,a/)','Finished processing ',iZpos,' elements!');

/*********************************************
 Adjust xsections to current binding energies
 Shift energy scale for each subshell when
 required.
 *********************************************/
"$egs_info(*,' Adjusting cross sections to new binding energies ...');
DO i=1,pe_ne[
   iZ = zread(i);
   IF (pe_nshell(i) = 0)[
      DO j=1,pe_nge(i)[
         pe_energy(j,i) =  log(pe_energy(j,i));
      ]
      NEXT;
   ]
   "Shift energy scale for different binding energy sets"
   DO l=1,pe_nshell(i)[
      IF ( pe_be(i,l) ~= binding_energies(l,iZ))[
           shift_required = .true.;
           deltaEb = binding_energies(l,iZ)-pe_be(i,l);
           "$egs_info('(2(a,a,a,1pe12.4),a,1pe12.4,a,e12.4)',
           "           'Eb_p_',labels(l),' = ',pe_be(i,l),
           "          ' Eb_e_',labels(l),' = ',binding_energies(l,iZ),
           "          ' diff = ',pe_be(i,l)-binding_energies(l,iZ),
           "          ' -> ', 100*(1.0 - binding_energies(l,iZ) / pe_be(i,l))
           "          );
      ]
      ELSE[shift_required =.false.;]
      is_there = .false.;
      DO j=1,pe_nge(i)[
         tmp_e(j,l)  = pe_energy(j,i);
         tmp_xs(j,l) = pe_xsection(j,i,l);
         IF ( shift_required &
              pe_energy(j,i) => pe_be(i,l) )[
            tmp_e(j,l) += deltaEb;
            "$egs_info(*,'Shifting ',pe_energy(j,i),' to ',tmp_e(j,l));
            "Determine edge position in energy array"
            IF (pe_energy(j,i) = pe_be(i,l) & ~is_there)[
               ib(l) = j; is_there = .true.;
            ]
            "Update new energy grid"
            IF (l = 1)[
               new_e(j) = tmp_e(j,l);
            ]
            "ELSE IF(tmp_e(j,l) < binding_energies(l-1,iZ))[
            ELSE IF(j < ib(l-1))[
               new_e(j) = tmp_e(j,l);
            ]
         ]
      ]
      pe_be(i,l) = binding_energies(l,iZ);
   ]
   "Re-compute sub-shell xsections for new energy grid new_e"
   "Not needed for K shell"
   DO l=2,pe_nshell(i)[
      DO j=1,pe_nge(i)[
         IF ( new_e(j) >= pe_be(i,l-1) )[
            m = ibsearch(new_e(j),pe_nge(i),tmp_e(1,l));
            slope = log(tmp_xs(m+1,l)/tmp_xs(m,l));
            slope = slope/log(tmp_e(m+1,l)/tmp_e(m,l));
            pe_xsection(j,i,l) = log(tmp_xs(m,l));
            pe_xsection(j,i,l) += slope*log(new_e(j)/tmp_e(m,l));
            pe_xsection(j,i,l) = exp(pe_xsection(j,i,l));
         ]
      ]
   ]
   "Re-compute total xsections for new energy grid new_e"
   "$egs_info(*,'-> Z = ',iZ);"
   DO j=1,pe_nge(i)[
      IF ( j < ib(pe_nshell(i)))[
         new_e(j) = pe_energy(j,i);
      ]
      m = ibsearch(new_e(j),pe_nge(i),pe_energy(1,i));
      slope = log(rest_xs(m+1,i)/rest_xs(m,i));
      slope = slope/log(pe_energy(m+1,i)/pe_energy(m,i));
      pe_xsection(j,i,0)  = log(rest_xs(m,i));
      pe_xsection(j,i,0) += slope*log(new_e(j)/pe_energy(m,i));
      pe_xsection(j,i,0) = exp(pe_xsection(j,i,0));
      "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4,1x,1pe12.4)',
      "         new_e(j),pe_xsection(j,i,0),pe_energy(j,i),rest_xs(j,i));
      DO l=1,pe_nshell(i)[
         pe_xsection(j,i,0) += pe_xsection(j,i,l);
      ]
      "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4)',
      "         new_e(j),pe_xsection(j,i,0));
   ]
   "Normalize shell cross sections to total for sampling"
   "and update energy grid of ith element."
   " Prepare for log/log interpolation."
   DO j=1,pe_nge(i)[
      pe_energy(j,i) =  log(new_e(j));
      DO l=1,pe_nshell(i)[
         pe_xsection(j,i,l) = log(pe_xsection(j,i,l)/pe_xsection(j,i,0));
      ]
   ]
]

$egs_info('(a/)',' done');

IF( is_open ) close(pe_sw_unit);
return;
end;


"******************************************************************"
SUBROUTINE RELAX(energy,n,iZ);
"******************************************************************"
" Subroutine to fill a vacancy in shell n, element iZ              "
" by emitting fluorescent X-rays, Auger and Coster-Kronig electrons"
" Transitions between K,L1,L2,L3,average M,average N are taken into"
" account. Particles with energies above the transport cut-offs    "
" (ECUT and PCUT) are placed on the stack, energy of sub-threshold "
" particles is stored in EDEP.                                     "
" In this version a global cut-off of 1 keV applies                "
"  i.e. if ECUT-RM or PCUT is below 1 keV, binding energies below  "
"  1 keV will still be absorbed locally (due to lack of data)      "
"                                                                  "
" Version 1:  I. Kawrakow, December 1998                           "
"******************************************************************"
implicit none;

" Input variables "
"================="
$INTEGER n,iZ;
$REAL    energy;  "

$declare_write_buffer;

" Local variables "
"================="
REPLACE {$MXVAC} WITH {50}  "Maximum number of vacancies during the"
                            "relaxation cascade                    "

$INTEGER vac_array($MXVAC), "array with shell vacancies            "
         n_vac,             "current number of vacancies           "
         shell;             "current shell                         "
$INTEGER final,finala,      "code of final state                   "
         final1,final2,     "two vacancies in the final state in   "
                            "the case of Auger transitions         "
         iql,               "particle charge                       "
         irl;               "present region"
$INTEGER first_transition($MXINTER),
         last_transition($MXINTER);
                            "first and last transition for a given "
                            "shell in the list of all possible     "
                            "transitions                           "
$INTEGER final_state($MXTRANS);
           " final_state(i) is the final atomic state                "
           " after transition i coded as follows:                    "
           "   * fluorescence - final_state is the shell number      "
           "                    of the new vacancy                   "
           "   * Coster-Kronig - final_state is the shell number     "
           "                     of the new vacancy + 10             "
           "   * Auger - final_state is n1 + 100*n2 where n1 and n2  "
           "             are the shell numbers of the 2 new vacancies"

$INTEGER k, np_old, ip, iarg;
$REAL    e_array($MXVAC),   "array with vacancy energies           "
         Ei,Ef,             "initial,final binding energies        "
         Ex,                "kinetic energy of emitted particle    "
         eta,               "a random number                       "
         e_check,           "energy conservation check             "
         min_E,ekcut,pkcut,elcut; "cut-off energies  "

$REAL    xphi,yphi,xphi2,yphi2,rhophi2,
         cphi,sphi;         "for azimuthal angle selection"

" Global EGS4 variables "
"======================="
$COMIN-RELAX;
;COMIN/RELAX-USER/;

data first_transition/1,20,27,33,38/;
data last_transition/19,26,32,37,39/;
data final_state/ "See the final_state definition above"
         4,3,5,6,                           " K-shell fluorescence    "
         202,302,402,404,403,303,           " K-shell Auger           "
         502,503,504,602,603,604,           " K-shell Auger           "
         505,605,606,                       " K-shell Auger           "
         13,14,                             " L1 Coster-Kronig        "
         5,6,                               " L1 fluorescence         "
         505,605,606,                       " L1 Auger                "
         14,                                " L2 Coster-Kronig        "
         5,6,                               " L2 fluorescence         "
         505,605,606,                       " L2 Auger                "
         5,6,                               " L3 fluorescence         "
         505,605,606,                       " L3 Auger                "
         6,                                 " M  fluorescence         "
         606/;                              " M  Auger                "

save first_transition,last_transition,final_state; "to avoid problems with "
                                                   "non-static compiler options"

IF (eadl_relax)[
   call egs_eadl_relax(iZ,n);
   return;
]

IF( n < 1 | n > $MXSHELL ) [ return; ] "unknown vacancy"

iz_relax = iZ;
irl = ir(np);
ekcut = ecut(irl)-rm; pkcut = pcut(irl);
min_E = $RELAX-CUTOFF;

IF( energy <= min_E ) [
    edep = edep + energy;  "We assume that edep is zeroed "
                        "(or set to the appropriate value) in the routine "
                        "calling RELAX "
    edep_local = energy;

    "Assign this energy deposition to an electron."
    "Note that this should NOT be treated as though it came from a photon,"
    "even if a photon initiated the relaxations. Rather, energy remaining"
    "in vacancies should be given to an electron or absorbed locally."
    $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

    return;
]

" Set-up the array of vacancies for the relaxation cascade "
n_vac = 1; vac_array(n_vac) = n; np_old = np;
e_check = 0; e_array(n_vac) = energy;

:START: LOOP[     "Until no  >N-shell vacancies"

    shell = vac_array(n_vac); Ei = e_array(n_vac); n_vac = n_vac - 1;

    IF( Ei <= min_E ) [  " Below cut-off -> local absorption "
        edep = edep + Ei;

        edep_local = Ei;

        "Assign this energy deposition to an electron."
        "Note that this should NOT be treated as though it came from a photon,"
        "even if a photon initiated the relaxations. Rather, energy remaining"
        "in vacancies should be given to an electron or absorbed locally."
        $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

        IF( n_vac > 0 ) goto :START: ;
        EXIT;
    ]

    "Set the relax_user common block variables, IK March 22 2004"
    ish_relax = shell; u_relax = Ei;
    IF( shell = $MXSHELL ) [ "This is N-shell vacancy -> just produce Auger"
        IF( Ei > ekcut ) [
            np = np + 1;
            $CHECK-STACK(np,'RELAX');
            e(np) = Ei + prm; iq(np) = -1;
            $TRANSFER PROPERTIES TO (np) FROM (np-1);
            $RANDOMSET eta; eta = 2*eta - 1; w(np) = eta;
            eta = (1-eta)*(1+eta);
            IF( eta > 1e-20 ) [
                eta = Sqrt(eta);
                $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
                u(np) = eta*cphi; v(np) = eta*sphi;
            ]
            ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
            $AUSCALL($AUGERTRA);
        ]
        ELSE             [
            edep = edep + Ei;

            edep_local = Ei;
            $AUSCALL($SELECTRONA);
        ]
        IF( n_vac > 0 ) goto :START: ;
        EXIT;
    ]
    " Sample transition number for this vacancy "
    $RANDOMSET eta;
    DO k=first_transition(shell),last_transition(shell)-1 [
        eta = eta - relaxation_prob(k,iZ);
        IF( eta <= 0 ) EXIT;
    ]
    final = final_state(k); finala = final;
    IF( final < 100 ) [
        IF( final < 10 ) [ "fuorescence"
            iql = 0; elcut = pkcut;
        ]
        ELSE             [ "Coster-Kronig"
            final = final - 10;
            iql = -1; elcut = ekcut;
        ]
        Ef = binding_energies(final,iZ);
        Ex = Ei - Ef;
        n_vac = n_vac + 1;
        vac_array(n_vac) = final;
        e_array(n_vac) = Ef
    ]
    ELSE [  "Auger"
        final1 = final/100; final2 = final - final1*100;
        n_vac  = n_vac + 1;
        vac_array(n_vac) = final1;
        e_array(n_vac) = binding_energies(final1,iZ);
        n_vac  = n_vac + 1;
        vac_array(n_vac) = final2;
        e_array(n_vac) = binding_energies(final2,iZ);
        iql = -1;
        Ex = Ei - e_array(n_vac) - e_array(n_vac-1);
        elcut = ekcut;
    ]
    IF( Ex <= elcut ) [ "Below cut-off"
        edep = edep + Ex;

        IF( finala <  10 ) [
            edep_local = Ex;
            $AUSCALL($SPHOTONA);
        ]
        ELSE [
            edep_local = Ex;
            $AUSCALL($SELECTRONA);
        ]
    ]
    ELSE [
        np = np + 1;
        $CHECK-STACK(np,'RELAX');
        iq(np) = iql;
        IF( iql = 0 ) [ e(np) = Ex; ] ELSE [ e(np) = Ex + rm;]
        $TRANSFER PROPERTIES TO (np) FROM (np-1);
        $RANDOMSET eta;
        eta = 2*eta - 1;
        w(np) = eta;
        eta = (1-eta)*(1+eta);
        IF( eta > 1e-20 ) [
            eta = Sqrt(eta);
            $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
            u(np) = eta*cphi;
            v(np) = eta*sphi;
        ]
        ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
        IF     ( finala <  10 ) [ $AUSCALL($FLUORTRA);  ]
        ELSE IF( finala < 100 ) [ $AUSCALL($COSKROTRA); ]
        ELSE                    [ $AUSCALL($AUGERTRA);  ]
    ]
]

return;
end;

"*************************************************************************"
subroutine egs_init_relax;
"*************************************************************************"
" Reads EADL atomic relaxation data from $HEN_HOUSE/data/relax.data. This "
" data base was originally created by I. Kawrakow to be used with C++ user"
" codes. It has been re-created using 4 bytes integers instead of using   "
" optimized integer sizes to save space. It is now about 34% larger (760K)"
" than before (557K). Reason for this was that some compilers need a switch"
" to get it to read binary files on byte at a time. This would have been a"
" nuisance for users when configuring the already complex system.         "
"                                                                        "
" The final relaxation state from radiative transitions assumes C-style  "
" array indexing and hence needs to be increased by 1.                   "
" Similarly, for non-radiative transitions, there is need to increase the"
" codified value of the two electron states by 65. The reason is that the"
" two transition states are encoded as 64*state1+state2. Because of the C"
" style indexing, state1 and state2 must be increased by 1, increasing the"
" above codified value by 65.                                            "
"                                                                        "
"Shell information for all media elements stored in one-dimensional arrays:"
"                                                                        "
" ish              => absolute shell index (1...shell_ntot)              "
" shell_be(ish)    => shell binding energy                               "
" shell_type(ish)  => shell type according to EADL notation              "
" shell_Z(ish)     => Z of shell element                                 "
" shell_num(ish)   =>  relative shell position within one element        "
" shell_ntot       => total number of shells for all media elements      "
" relax_first(ish) => initial absolute relaxation position               "
" relax_ntran(ish) => number of transitions                              "
" shell_eadl(Z,shell_num(ish)) => absolute shell position for element Z  "
"                                                                        "
"Transition information for all shells also stored in one-dimensional arrays:"
"                                                                         "
" transition index itran runs from 1...relax_ntot                         "
" relax_prob(itran)  => transition probabilities                          "
" relax_atbin(itran) => holds the alias indices                           "
" relax_state(itran) => final relaxation state:                           "
"                       radiative: relative shell position                "
"                   non-radiative: relative position of shells(64*sh1+sh2)"
"                                                                         "
"                              Originally coded by IK in a standalone code"
"                          Modified for use with EGSnrc by EMH, June 2011 "
"                          Corrected bugs and commented by EMH, April 2012"
"*************************************************************************"
$IMPLICIT-NONE;

$declare_max_medium;
$COMIN-RELAX-INIT;

$INTEGER   lnblnk1,egs_get_unit,relax_unit,ounit,egs_open_file;
$INTEGER   sorted($MXELEMENT),i,j,k,k1,k2,m;
$REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
character  data_dir*128,relax_file*144;

$INTEGER  ish,medio,iZ,ntran;
$REAL     Ec, Pc, tmp, min_be, sumw,Ex;
$LOGICAL  is_open, is_there;
$REAL     wtmp($MAXTRANS);
$INTEGER  itmp($MAXTRANS);

integer*4 pos, curr_rec, sh_eadl;
integer*4 nz, nshell, tr_type;
integer*4 ttype;
real*4    be_r, prob_r;


DO iZ=1,$MXELEMENT[
 DO k=1,$MXESHLL[
   shell_eadl(iZ,k) = -1;
 ]
]

/*********************************************
   Determine minimum energy
 **********************************************/
/*Pc = 1e30; Ec = 1e30;
DO medio = 1,nmed [
    tmp = AE(medio) - rm; Ec = min(Ec,tmp); Pc = min(Pc,ap(medio));
]
min_be = min(Ec,Pc);  "This is the minimum binding energy for which we need"
                      "relaxation data"
*/
min_be = $RELAX-CUTOFF;
$egs_debug('(a)',' ************ relax_init **************** ');
$egs_debug('(a,f10.7)',
        ' Minimum binding energy requiring relaxation data: ',min_be);

/*********************************************
   Open EADL relaxation data file relax.data
 **********************************************/
$egs_info('(/a)',' Reading EADL relaxation data ......');
data_dir = $cstring(hen_house) // 'data' // $file_sep;
relax_file = $cstring(data_dir) // 'relax.data';

/* Open a fortran unit for reading relaxation data */
relax_unit = egs_get_unit(0);
IF( relax_unit < 1 ) [
   $egs_fatal(*,'egs_init_relax: failed to get a free Fortran I/O unit');
]
open(relax_unit,file=relax_file,status='old',
     form='UNFORMATTED',ACCESS='direct',recl=$RECL-FACTOR,
     err=:no-relax-file:);
GOTO :read-relax:;
:no-relax-file:
$egs_fatal('(2a)','egs_init_relax: failed to open ',
           relax_file);
:read-relax:
is_open = .true.;
/*********************************************
   Get EADL relaxation data from relax.data
 **********************************************/
curr_rec = 1;
read(relax_unit,rec=curr_rec) nz;
"$egs_info('(a,i2,a)','Relaxation data for ',nz,' elements....');"
shell_ntot = 0;relax_ntot = 0;
DO medio = 1,nmed [
   DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
   call egs_heap_sort(nne(medio),z_sorted,sorted);
   DO i=1,nne(medio) [
      iZ = z_sorted(i);
      "Now check whether we have already loaded the data for"
      "this atomic number"
      is_there = .false.;
      DO j = 1,shell_ntot [
         IF( iZ = shell_Z(j) ) [ is_there = .true.; EXIT; ]
      ]
      IF (is_there) NEXT;
      pos = iZ + 1;
      read(relax_unit,rec=pos) curr_rec;
      read(relax_unit,rec=curr_rec) nshell;
      IF( shell_ntot + nshell > $MAXSHELL ) [
         $egs_fatal('(a,i5,a/,a//)',' Too many shells to fit in the list: ',
                shell_ntot + nshell,' (at least).',
                ' Increase the parameter $MAXSHELL and retry ');
      ]
      $egs_info('(a,i3,a,i2,a)',
      '  Z = ',iZ,' has ',nshell,' shells');
      DO ish=shell_ntot+1,shell_ntot+nshell[
        curr_rec  = curr_rec+1;
        read(relax_unit, rec=curr_rec) shell_type(ish);
        curr_rec  = curr_rec+1;
        read(relax_unit, rec=curr_rec) ntran;
        curr_rec  = curr_rec+1;
        read(relax_unit, rec=curr_rec) be_r; shell_be(ish) = be_r;

        shell_Z(ish) = iZ;
        shell_num(ish) = ish - shell_ntot;
        shell_eadl(iZ,shell_num(ish)) = ish;
        IF (binding_energies(shell_num(ish),iZ) > 0)[
           shell_be(ish) = binding_energies(shell_num(ish),iZ);
        ]
        ELSE IF( photon_xsections = 'epdl' )[
          "Use binding energies from relax.data below 1 keV"
           binding_energies(shell_num(ish),iZ) = shell_be(ish);
        ]
        DO k=1,ntran[
            curr_rec  = curr_rec+1;
            read(relax_unit,rec=curr_rec) itmp(k);
            curr_rec  = curr_rec+1;
            read(relax_unit,rec=curr_rec) prob_r;wtmp(k)=prob_r;
            /*Relaxation data uses C-style array indexing.
              Hence final relaxation state increased by 1  for
              radiative and by 65 for non-radiative transitions*/
            IF (itmp(k)<64) [itmp(k) +=1;]
            ELSE            [itmp(k) += 65;]
        ]
        IF( shell_be(ish) < min_be ) [
            relax_first(ish) = -1;
            relax_ntran(ish) = -1;
        ]
        ELSE [
            sumw = 0;
            DO k=1,ntran [  sumw = sumw + wtmp(k); ]
            IF( sumw > 1 ) [
                DO k=1,ntran [  wtmp(k) = wtmp(k)/sumw; ]
            ]
            ELSE IF( sumw < 1 ) [
                ntran = ntran + 1; itmp(ntran) = -1; wtmp(ntran) = 1-sumw;
            ]
            IF( relax_ntot + ntran > $MAXRELAX ) [
               $egs_fatal('(a,i5,a/,a/)',' Too many relaxation transitions: ',
                 relax_ntot + ntran,' (at least).',
                 ' Increase $MAXRELAX and retry ');
            ]
            relax_first(ish) = relax_ntot+1; relax_ntran(ish) = ntran;
            call prepare_alias_histogram(ntran,wtmp,
                                 relax_atbin(relax_ntot+1));
            DO k=1,ntran [
               j = relax_ntot + k;
               relax_state(j) = itmp(k); relax_prob(j) = wtmp(k);
            ]
            relax_ntot = relax_ntot + ntran;
        ]
      ]

      shell_ntot = shell_ntot + nshell;

   ]

]
$egs_debug('(a,i4,a)',' There are ',
        shell_ntot,' shells in the list of shells ');
$egs_info('(a/)',' ...... Done.');
/***********************************************/

IF( is_open ) close(relax_unit);
return;

stop;
end;

"Macro to check that the stack size is not exceeded"
REPLACE {$CHECK-RELAX-STACK(#,#);} WITH {;
  IF( {P1} > $MXSTACK ) [
      $egs_warning('(3(a,f10.6),a,i2)',
       'Evac = ',Evac, ' Ef = ',Ef,
       "' Z = ',iZ,' Nvac = ',Nvac,"
       ' min_E = ', min_E,' iq = ',iqf);
;  "---------- BUFFER FLUSH SEMICOLON ----------"
      $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
          ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
          ' Increase $MXSTACK and try again ');
  ]
};

"***********************************************************************"
  subroutine egs_eadl_relax(iZ, shell_egs);
"************************************************************************"
" Subroutine, called from subroutine relax, to fill a vacancy in         "
" shell shell_egs in element iZ by emitting fluorescent X-rays, Auger    "
" and Coster-Kronig electrons.  Uses EADL data.                          "
" Results passed via variables in comins.                                "
"   edep                                                                 "
"   edep_local                                                           "
"   e(np)                                                                "
"                                                                        "
" There are calls to ausgab with IARG values                             "
"   24  A fluorescent transition just occurred                           "
"   26  An Auger transition just occurred                                "
"   32  Sub-threshold fluorescent transition just occurred               "
"   33  Sub-threshold Auger transition just occurred                     "
"                                                                        "
" There is an inconsistency in the binding energies (BE) as COMPT uses   "
" different BE (incoh.data)                                              "
"                                                                        "
" Explain need to reduce new_state by 1 below as alias sampling provides "
" bin number from 1...nbin and not 0...nbin-1                            "
"                                                                        "
"                             Originally coded by IK in a standalone code"
"                         Modified for use with EGSnrc by EMH, June 2011 "
"                         Corrected bugs and commented by EMH, April 2012"
"************************************************************************"

$IMPLICIT-NONE;

$declare_max_medium;
$COMIN-RELAX-EADL;
;COMIN/RELAX-USER/;

$REAL    Ec,Pc,min_E,rnno,Evac,Ef,Ef1,Ef2,Ex,Ecc,
         cost,sint,cphi,sphi;
"Ec      ecut as k.e. for current region"
"Pc      pcut for current region"
"min_E   the minimum energy for transitions to continue"
"rnno    a random number"
"Evac    binding energy of current vacancy"
"Ef      the sum of the binding energies of the new vacancies"
"Ef1     the first new binding energy of for non-radiative transitions"
"Ef2     the second new binding energy of for non-radiative transitions"
"Ex      the change in total binding energy"
"Ecc     the cutoff energy (Ec or Pc)"
"cost,sint,cphi,sphi variables for calculating particle direction"

$INTEGER  shell, shell_egs, iZ, iarg;
"shell       number in master eadl list"
"shell_egs   shell number in current element"
"iZ          atomic number of element"

$INTEGER  irl,vacs($MAXVAC),nvac,vac,new_state,iqf,np_save,new1,new2;
"irl           current region"
"vacs($MAXVAC) array of vacancy shell numbers"
"nvac          current number of vacancies in vacs"
"vac           shell number of current vacancy"
"new_state     the state number that represents the new vacancy"
"iqf           the charge of the emitted relaxation particle"
"np_save       the stack index of the particle inducing in relaxations"
"new1          the first new vacancy for non-radiative transitions"
"new2          the second new vacancy for non-radiative transitions"

$INTEGER sample_alias_histogram;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;

shell = shell_eadl(iZ,shell_egs);
IF( shell < 1 | shell > $MAXSHELL ) [ return; ] "unknown vacancy"

irl = ir(np);
Ec = ecut(irl) - rm;
Pc = pcut(irl);
min_E = $RELAX-CUTOFF;

Evac = shell_be(shell); "provides relevant binding energy for this vacancy"
"store some information in comin RELAX-FOR-USER.  This just duplicates"
"various pieces of info so the user can access them."
rfu_Z  = shell_Z(shell); "Z of element the relaxing shell belongs to"
rfu_j0 = shell;         "shell # of vacancy that initiated cascade in long list"
rfu_n0 = shell_num(shell); "same but number is shell number in element iZ"
rfu_t0 = shell_type(shell); "the shell type (encodes the type of relaxation)"
rfu_E0 = Evac;          "B.E. of vacancy that initiated cascade"
"
"Local energy deposition for vacancies below L3 shell."
"Added here for consistency in algorithm for as long as"
"<M> and <N> shells considered instead of proper shells."
"AUSGAB call should be updated when charge of particle"
"creating vacancy becomes available."
IF (shell_egs > 4 & ~mcdf_pe_xsections) [
    edep = Evac;        "add energy of vacancy to edep"
    edep_local = Evac;  "set value of edep_local to energy of vacancy"

    "Assign this energy deposition to an electron."
    "Note that this should NOT be treated as though it came from a photon,"
    "even if a photon initiated the relaxations. Rather, energy remaining"
    "in vacancies should be given to an electron or absorbed locally."
    $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

    return; "invokes $AUSCALL($PHOTXAUS) in COMPT;"
]

vac = shell; Nvac = 0; np_save = np;
LOOP [ "from here to end of routine over all vacancies created"

    "check if energy of vacancy < cutoff OR no transitions from this shell"
    IF( Evac < min_E | relax_ntran(vac) < 1 ) [
        edep += Evac;         "add energy of vacancy to edep"
        edep_local = Evac;    "set value of edep_local to energy of vacancy"

        "Assign this energy deposition to an electron."
        "Note that this should NOT be treated as though it came from a photon,"
        "even if a photon initiated the relaxations. Rather, energy remaining"
        "in vacancies should be given to an electron or absorbed locally."
        $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

        go to :VACANCY:;      "exit loop and if Nvac still 0, exit routine"
    ]

    "prepare_alias_histogram is called from subroutine egs_init_relax and"
    "sample_alias_histogram uses the array of bin probabilities and bin"
    "numbers relax_prob(relax_first(vac) and relax_atbin(relax_first(vac))"
    "to return the bin which has been sampled, i.e. new_state"
    "relax_ntran(vac) tells how many transitions are available"
    new_state = sample_alias_histogram(relax_ntran(vac),
                  relax_prob(relax_first(vac)),
                  relax_atbin(relax_first(vac)));
    IF( new_state < 0 ) [ "this may happen if the sum of probabilities from"
                          "EADL was < 1. In this case the entire energy is"
                          "given to an electron and no new vacancy is created"
        Ef = 0;
        iqf = -1;
        Ecc = Ec;
    ]
    ELSE[
        new_state = relax_state(relax_first(vac)+new_state-1);
     IF( new_state <= 64 ) [ "It was a radiative transition, i.e. fluorescence"
        iqf = 0;
        new_state += vac - shell_num(vac);
        Ef = shell_be(new_state);
        Nvac += 1;
        vacs(Nvac) = new_state;
        Ecc = Pc;
     ] "end of fluorescence block"

     ELSE [ "It was a non-radiative transition (Auger or Coster-Kronig)"
        iqf = -1; new1 = new_state/64; new2 = new_state - 64*new1;
        new1 += vac - shell_num(vac); new2 += vac - shell_num(vac);
        Ef1 = shell_be(new1); Ef2 = shell_be(new2);
        Nvac += 1; vacs(Nvac) = new1;
        Nvac += 1; vacs(Nvac) = new2;
        Ef = Ef1 + Ef2; Ecc = Ec;
     ] "end Auger or Coster-Kronig block"
    ]
    Ex = Evac - Ef;
    edep_local = 0;
    IF( Ex > Ecc ) [
        np += 1; $CHECK-RELAX-STACK(np,'new_relax');
        iq(np) = iqf;
        $TRANSFER PROPERTIES TO (np) FROM (np_save);
        $RANDOMSET rnno; cost = 2*rnno-1; sint = 1-cost*cost;
        IF( sint > 0 ) [
            sint = sqrt(sint);
            $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
            u(np) = sint*cphi; v(np) = sint*sphi; w(np) = cost;
        ] ELSE [ u(np) = 0; v(np) = 0; w(np) = cost; ]
        rfu_j = vac; rfu_n = shell_num(vac); rfu_t = shell_type(vac);
        rfu_E = shell_be(vac);
        IF( iqf = 0 ) [
            e(np) = Ex; $AUSCALL($FLUORTRA);
        ]
        ELSE [
            e(np) = Ex + rm; $AUSCALL($AUGERTRA);
        ]
    ] ELSE [ "Ex <= Ecc"
        edep += Ex;

        IF( iqf = 0 ) [
            edep_local = Ex;
            $AUSCALL($SPHOTONA);
        ] ELSE [
            edep_local = Ex;
            $AUSCALL($SELECTRONA);
        ]
    ] "end Ex <= Ecc block"
    :VACANCY:;
    IF( Nvac = 0 ) EXIT;
    "get next vacancy to process"
    vac = vacs(Nvac); Evac = shell_be(vac); Nvac -= 1;
] "end of main loop"
return;
end;
;

"***************************************************************************"
"     Triplet production stuff                                              "
"***************************************************************************"

REPLACE {$N_TRIPLET_DATA} WITH {55}
REPLACE {$N_ELEMENT} WITH {100}
;
subroutine init_triplet;
implicit none;
$declare_max_medium;
$COMIN-INIT-TRIPLET;
$REAL  energies($N_TRIPLET_DATA), sig_pair($N_ELEMENT,$N_TRIPLET_DATA),
       sig_triplet($N_ELEMENT,$N_TRIPLET_DATA), f_triplet($N_TRIPLET_DATA),
       sigp($N_TRIPLET_DATA), sigt($N_TRIPLET_DATA),
       as($N_TRIPLET_DATA), bs($N_TRIPLET_DATA), cs($N_TRIPLET_DATA),
       ds($N_TRIPLET_DATA);
character*128  triplet_data_file;
$INTEGER want_triplet_unit, triplet_unit, triplet_out;
$INTEGER i, iel, imed, lnblnk1, egs_get_unit, ntrip, iz1, izi, ifirst;
$REAL    logE, f_new, f_old, spline;

IF( itriplet = 0 ) return;
$set_string(triplet_data_file,' ');
triplet_data_file = $cstring(hen_house) // 'data' // $file_sep //
                    'triplet.data';
want_triplet_unit = 63;
triplet_unit = egs_get_unit(want_triplet_unit);
IF( triplet_unit < 1 ) [
    $egs_fatal(*,'init_triplet: failed to get a free Fortran I/O unit');
]
open(triplet_unit,file=triplet_data_file,err=:no-triplet-file:);
$egs_info('(a,$)',' init_triplet: reading triplet data ... ');
read(triplet_unit,*) ntrip;
IF( ntrip > $N_TRIPLET_DATA ) [
    $egs_fatal(*,'Max. number of data points per element is ',$N_TRIPLET_DATA);
]
read(triplet_unit,*,err=:error_triplet_data:) (energies(i),i=1,ntrip);
DO iel=1,$N_ELEMENT [
    read(triplet_unit,*);
    read(triplet_unit,*,err=:error_triplet_data:)
        (sig_pair(iel,i),i=1,ntrip);
    read(triplet_unit,*,err=:error_triplet_data:)
        (sig_triplet(iel,i),i=1,ntrip);
]
$egs_info(*,'OK');
ifirst = 0;
DO i=1,ntrip [
    IF( ifirst = 0 & energies(i) > 4.01*rm ) ifirst = i;
    energies(i) = log(energies(i));
]
log_4rm = log(4*rm);
energies(ifirst-1) = log_4rm;
dl_triplet = (energies(ntrip) - log_4rm)/$MAX_TRIPLET;
dli_triplet = 1/dl_triplet;
bli_triplet = 1 - log_4rm/dl_triplet;

DO imed = 1, nmed [

    $egs_info('(a,i3,a,$)',
      '   Preparing triplet fraction data for medium ',imed,' ... ');
    iz1 = zelem(imed,1) + 0.1;
    DO i=1,ntrip [
        sigp(i) = pz(imed,1)*sig_pair(iz1,i);
        sigt(i) = pz(imed,1)*sig_triplet(iz1,i);
        DO iel=2,nne(imed) [
            izi = zelem(imed,iel) + 0.1;
            sigp(i) = sigp(i) + pz(imed,iel)*sig_pair(izi,i);
            sigt(i) = sigt(i) + pz(imed,iel)*sig_triplet(izi,i);
        ]
    ]

    DO i=ifirst,ntrip [ f_triplet(i-ifirst+2) = sigt(i)/(sigp(i) + sigt(i)); ]
    f_triplet(1) = 0;
    call set_spline(energies(ifirst-1),f_triplet,as,bs,cs,ds,ntrip-ifirst+2);

    logE = log_4rm; f_old = 0;
    DO i=1, $MAX_TRIPLET-1 [
        logE = logE + dl_triplet;
        f_new = spline(logE,energies(ifirst-1),as,bs,cs,ds,ntrip-ifirst+2);
        a_triplet(i,imed) = (f_new - f_old)*dli_triplet;
        b_triplet(i,imed) = f_new - a_triplet(i,imed)*logE;
        f_old = f_new;
    ]
    $egs_info(*,'OK');

]
close(triplet_unit);
return;

:no-triplet-file:;
$egs_fatal('(a,a)',' init_triplet: failed to open the data file ',
             triplet_data_file(:lnblnk1(triplet_data_file)));

:error_triplet_data:;
$egs_fatal(*,' init_triplet: error while reading triplet data ');

return; end;

%E
"******************************************************************"
SUBROUTINE EDGSET(NREGLO,NREGHI);
"******************************************************************"
" SUBPROGRAM TO SET UP PARAMETERS FOR ATOMIC RELAXATIONS           "
" and proper handling of photo-electric absorption
"******************************************************************"
" Programmer:   I. Kawrakow, (NRC)                                 "
"******************************************************************"
"                                                                  "
"  Input:  NREGLO and NREGHI, not needed but left there for        "
"                             compatibility with older user codes  "
"
"  This routine is called from HATCH, it checks whether one of the "
"  elements of IEDGFL has been set to an integer number between    "
"  1 and 100 and if so reads in photo-absorption and relaxation    "
"  data. Note that the array IEDGFL, which used to be the          "
"  `effecvtive' atomic number of a medium is not used for any      "
"  purpose other than to indicate that relaxations are requested   "
"  (if non-zero).
"******************************************************************"
"                                                                  "

$IMPLICIT-NONE;

;COMIN/EDGE,X-OPTIONS,EGS-IO/;

"Input variables"
integer  NREGLO,NREGHI;

$INTEGER i,j,k,jj,iz;
logical  do_relax;
logical  got_data;
save     got_data;
data     got_data/.false./;

IF( got_data ) return;
   "EDGSET is now called from HATCH. In older user codes it was called
   "from within the user code. If this happens, and the data is already
   "available, we don't need to read it again. That's why the above
   "statement.

$egs_info('(a/,a)',
          'Output from subroutine EDGSET:',
          '==============================');

$need_relaxation_data(do_relax);
IF( ~do_relax ) [

    IF(eadl_relax)[
        $egs_fatal('(a,/a)',
                   'You must turn ON atomic relaxations when requesting',
                   'detailed atomic relaxation (eadl_relax=true)!');
    ]
    $egs_info('(a/)',' Atomic relaxations not requested! ');
    return;
]

$egs_info('(a/)',' Atomic relaxations requested! ');

$egs_info('(a$)',' Reading simplified photo-absorption data .....');

got_data = .true.;
rewind($PHOTOUNIT);

DO i=1,$MXELEMENT
[
    IF (eadl_relax)[
       "Skip, using binding_energies from *_photo.data file
       read($PHOTOUNIT,*);
    ]
    ELSE[
       read($PHOTOUNIT,*) j,(binding_energies(k,i),k=1,$MXSHELL);
       DO k=1,$MXSHELL [
          binding_energies(k,i) = binding_energies(k,i)*1e-6; "Convert to MeV"
       ]
    ]
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT
[
    read($PHOTOUNIT,*) j,(interaction_prob(k,i),k=1,$MXINTER);
    interaction_prob($MXSHELL,i)=1.01;
]
$egs_info('(a)',' Done');

$egs_info('(/a$)',' Reading simplified relaxation data .....');
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=1,19);   "K-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=20,26);   "L1-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=27,32);   "L2-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=33,37);   "L3-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,relaxation_prob(38,i);   "M-shell"
]
$egs_info('(a)',' Done');
$egs_info('(/a$)',' Reading parametrized XCOM photo cross section data .....');
rewind($PHOCSUNIT);
DO i=1,$MXELEMENT [
    read($PHOCSUNIT,*) j,edge_number(i);
    DO j=1,edge_number(i) [
        read($PHOCSUNIT,*) edge_a(j,i),edge_b(j,i),edge_c(j,i),
                           edge_d(j,i),edge_energies(j,i);
    ]
]
$egs_info('(a)',' Done');

IF (eadl_relax)[
 call egs_init_relax;
]

RETURN;
END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE PHOTON(IRCODE);
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$INTEGER IRCODE; "1 => normal return"

$COMIN-PHOTON;   "default replacement produces the following:
                 "COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,"
                 "  UPHIOT,USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION/;"

$DEFINE-LOCAL-VARIABLES-PHOTON;


IRCODE=1;"set up normal return"
PEIG=E(NP);
EIG=PEIG; "energy of incident gamma"
IRL=IR(NP);
$start_new_particle;

IF(EIG <= PCUT(IRL)) [GO TO :PCUT-DISCARD:;]

:PNEWENERGY:
LOOP["enter this loop for each photon with new energy"

IF(WT(NP) = 0.0) [go to :USER-PHOTON-DISCARD:;] "added May 01"

GLE=LOG(EIG);"GLE IS GAMMA LOG ENERGY"

"   here to sample no. mfp to transport before interacting"

$SELECT-PHOTON-MFP;
" DEFAULT FOR $SELECT-PHOTON-MFP; IS:  $RANDOMSET RNNO35;"
"                                      DPMFP=-LOG(RNNO35);"
"NOTE:  THIS TEMPLATE CAN ALSO BE OVER-RIDDEN BY OTHER SCHEMES,"
"       SUCH AS THE 'EXPONENTIAL TRANSFORM' TECHNIQUE."

IROLD=IR(NP);"INITIALIZE PREVIOUS REGION"

:PNEWMEDIUM:
LOOP["HERE EACH TIME WE CHANGE MEDIUM DURING PHOTON TRANSPORT"
IF (MEDIUM.NE.0)[$SET INTERVAL GLE,GE;"SET PWLF INTERVAL"
$EVALUATE GMFPR0 USING GMFP(GLE);]

:PTRANS:
LOOP["PHOTON TRANSPORT LOOP"
IF (MEDIUM.EQ.0)[TSTEP=VACDST;]
ELSE [$SET-RHOF;    "DENSITY RATIO SCALING TEMPLATE"
GMFP=GMFPR0/RHOF;
$RAYLEIGH-CORRECTION;  "A RAYLEIGH SCATTERING TEMPLATE"
"Ali:photonuc, 1 line"
$PHOTONUC-CORRECTION;  "A PHOTONUCLEAR TEMPLATE"
TSTEP=GMFP*DPMFP;]
"   SET DEFAULT VALUES FOR FLAGS SENT BACK FROM USER"
IRNEW=IR(NP);"SET DEFAULT NEW REGION NUMBER"
IDISC=0;"ASSUME PHOTON NOT DISCARDED"
USTEP=TSTEP;"TRANSFER TRANSPORT DISTANCE TO USER VARIABLE"
TUSTEP=USTEP;

"IF (USTEP.GT.DNEAR(NP)) [;CALL HOWFAR;]"
$CALL-HOWFAR-IN-PHOTON; "The above is the default replacement"


"   NOW CHECK FOR USER DISCARD REQUEST"
IF (IDISC.GT.0)["USER REQUESTED IMMEDIATE DISCARD"
GO TO :USER-PHOTON-DISCARD:;]

VSTEP=USTEP; "SET VARIABLE FOR OUTPUT CODE"
TVSTEP=VSTEP;
EDEP=PZERO; "NO ENERGY DEPOSITION ON PHOTON TRANSPORT"

x_final = x(np) + u(np)*vstep;
y_final = y(np) + v(np)*vstep;
z_final = z(np) + w(np)*vstep;

$AUSCALL($TRANAUSB);

"   TRANSPORT THE PHOTON"
x(np) = x_final; y(np) = y_final; z(np) = z_final;
DNEAR(NP)=DNEAR(NP)-USTEP;"DEDUCT FROM DISTANCE TO NEAREST BOUNDARY"
IF (MEDIUM.NE.0)[DPMFP=MAX(0.,DPMFP-USTEP/GMFP);] "DEDUCT MFP'S"
IROLD=IR(NP); "SAVE PREVIOUS REGION"

MEDOLD=MEDIUM;
IF (IRNEW.NE.IROLD) ["REGION CHANGE"
  $photon_region_change;
]

"   AFTER TRANSPORT CALL TO USER"
$AUSCALL($TRANAUSA);
"oct 31 bug found by C Ma. PCUT discard now after AUSGAB call"
IF(EIG.LE.PCUT(IRL)) [GO TO :PCUT-DISCARD:;]

"   NOW CHECK FOR DEFERRED DISCARD REQUEST.  MAY HAVE BEEN SET"
"   BY EITHER HOWFAR, OR ONE OF THE TRANSPORT AUSGAB CALLS"
IF (IDISC.LT.0) GO TO :USER-PHOTON-DISCARD:;

IF (MEDIUM.NE.MEDOLD) EXIT :PTRANS:;

IF (MEDIUM.NE.0.AND.DPMFP.LE.$EPSGMFP)["TIME FOR AN INTERACTION"
EXIT :PNEWMEDIUM:;]
]REPEAT ":PTRANS: LOOP"

]REPEAT ":PNEWMEDIUM: LOOP"


"   IT IS FINALLY TIME TO INTERACT."
"   THE FOLLOWING MACRO ALLOWS ONE TO INTRODUCE RAYLEIGH SCATTERING"
$RAYLEIGH-SCATTERING;
"Ali:photonuclear, 1 line"
$PHOTONUCLEAR;
$RANDOMSET RNNO36; "THIS RANDOM NUMBER DETERMINES WHICH INTERACTION"
"   GBR1=PAIR/(PAIR+COMPTON+PHOTO)=PAIR/GTOTAL"
$EVALUATE GBR1 USING GBR1(GLE);
IF((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )["IT WAS A PAIR PRODUCTION"
    $AUSCALL($PAIRAUSB);
    CALL PAIR;
    "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
    "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
    "   LEADING PARTICLE SELECTION, ETC.))."
    "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
    "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
    $PARTICLE-SELECTION-PAIR;
    $AUSCALL($PAIRAUSA);
    IF( iq(np) ~= 0 ) [ EXIT :PNEWENERGY:; ]
    ELSE [ "this may happen if pair electrons killed via Russian Roulette"
        goto :PAIR-ELECTRONS-KILLED:;
    ]
]
"GBR2=(PAIR+COMPTON)/GTOTAL"
$EVALUATE GBR2 USING GBR2(GLE);
IF (RNNO36.LT.GBR2)["IT WAS A COMPTON"
    $AUSCALL($COMPAUSB);
    CALL COMPT;
    "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
    "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
    "   LEADING PARTICLE SELECTION, ETC.))."
    "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
    "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
    $PARTICLE-SELECTION-COMPT;
    $AUSCALL($COMPAUSA);
    IF (IQ(NP).NE.0"NOT PHOTON")EXIT:PNEWENERGY:;
]
ELSE["IT WAS PHOTOELECTRIC EFFECT"
    $AUSCALL($PHOTOAUSB);
    CALL PHOTO;
    "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
    "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
    "   LEADING PARTICLE SELECTION, ETC.))."
    "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
    "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
    $PARTICLE-SELECTION-PHOTO;
    IF (NP = 0 | NP < NPOLD ) [RETURN;]
      "The above may happen if Russian Roulette is on"
      "NP<NPOLD means that only electrons were created in the interaction"
      "and that all of them were killed. Hence, the top particle on the "
      "stack is from a previous interaction and may be in another region"
      "To avoid problems with the :PNEWENERGY: loop logic, we simply force"
      "a return to shower so that ELECTR or PHOTON are properly re-entered."
      "Changed by IK Dec. 21 2006 after D. Rogers and R. Taylor found a"
      "wrong dose with brems splitting and Russian Roulette on in a low "
      "energy calculation."

    $AUSCALL($PHOTOAUSA);
    IF (IQ(NP) ~= 0 ) EXIT :PNEWENERGY:;
] "END OF PHOTO ELECTRIC BLOCK"

:PAIR-ELECTRONS-KILLED:

"   IF HERE, THEN GAMMA IS LOWEST ENERGY PARTICLE."
PEIG=E(NP);
EIG=PEIG;
IF(EIG.LT.PCUT(IRL)) GO TO :PCUT-DISCARD:;
]REPEAT ":PNEWENERGY: LOOP"

"   IF HERE, MEANS ELECTRON TO BE TRANSPORTED NEXT"
RETURN;

"---------------------------------------------"
"PHOTON CUTOFF ENERGY DISCARD SECTION         "
"---------------------------------------------"
:PCUT-DISCARD:
IF( medium > 0 ) [
    IF(EIG.GT.AP(MEDIUM)) [IDR=$EGSCUTAUS;]ELSE[IDR=$PEGSCUTAUS;]
] ELSE [ IDR=$EGSCUTAUS; ]
EDEP=PEIG;"GET ENERGY DEPOSITION FOR USER"
$PHOTON-TRACK-END;
IRCODE=2;
NP=NP-1;
RETURN;

"---------------------------------------------"
"User requested photon discard section        "
"---------------------------------------------"
:USER-PHOTON-DISCARD:
EDEP=PEIG;
$AUSCALL($USERDAUS);
IRCODE=2;
NP=NP-1;
RETURN;

"END OF SUBROUTINE PHOTON"  END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE SHOWER(IQI,EI,XI,YI,ZI,UI,VI,WI,IRI,WTI);
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-SHOWER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,STACK,UPHIOT,RANDOM/;

"Input variables"
$REAL EI,      "initial shower energy"
      XI,YI,ZI,"initial co-ordinates"
      UI,VI,WI,"initial direction cosines"
      WTI;     "initial weight"

$INTEGER
      IQI,     "initial particle charge"
      IRI;     "initial region number"

"Local variables"
DOUBLE PRECISION
      DEG,    "energy for pi-zero option"
      DPGL,   "angle factor for pi-zero option"
      DEI,    "incident energy for pi-zero option"
      DPI,    "intermediate factor for pi-zero option"
      DCSTH,  "random number for pi-zero option"
      DCOSTH, "cos(theta) for pi-zero option"
      PI0MSQ; "pi-zero mass squared (in MeV**2)"

$REAL DNEARI, "initial distance to closest boundary"
      CSTH;   "random number for pi-zero option"

$INTEGER
      IRCODE; "status returned by ELECTR or PHOTON"

DATA PI0MSQ/1.8215416D4/;  "PI-ZERO MASS (MEV) SQUARED"

NP=1; NPold = NP;      "Set the old stack counter"
DNEARI=0.0;
IQ(1)=IQI; E(1)=EI; U(1)=UI; V(1)=VI; W(1)=WI;
$TRANSFER PROPERTIES TO (1) FROM I;

IF (IQI = 2) ["PI-ZERO OPTION"
  "IF(EI <= PI0MSQ) [OUTPUT EI;    corrected Oct 24 1995 e-mail Hideo H "
  "                  noted by      Dr.  Muroyama at Nagoya University
  IF(EI**2 <= PI0MSQ) [
     $egs_fatal('(//a/,a,g15.5,a)',
     ' Stopped in subroutine SHOWER---PI-ZERO option invoked',
     ' but the total energy was too small (EI=',EI,' MeV)');
  ]
  $RANDOMSET CSTH;
  DCSTH=CSTH; DEI=EI; DPI=DSQRT(DEI*DEI-PI0MSQ);
  DEG=DEI+DPI*DCSTH; DPGL=DPI+DEI*DCSTH; DCOSTH=DPGL/DEG;
  COSTHE=DCOSTH; SINTHE=DSQRT(1.D0-DCOSTH*DCOSTH);
  IQ(1)=0; E(1)=DEG/2.;
  CALL UPHI(2,1);
  NP=2;
  DEG=DEI-DPI*DCSTH; DPGL=DPI-DEI*DCSTH; DCOSTH=DPGL/DEG;
  COSTHE=DCOSTH; SINTHE=-DSQRT(1.D0-DCOSTH*DCOSTH);
  IQ(2)=0; E(2)=DEG/2.;
  CALL UPHI(3,2);
]"end of pi-zero option"

"The following convoluted logic is difficult to follow"
"when one modifies the outcome of certain interactions"
"using nbr_split, Russian Roulette, or one of the     "
"particle selection macros. I'm simplifying it        "
"so that ircode becomes irrelevant. IK, August 2002   "
":TOPSTACK:"
"LOOP["
"   $KERMA-INSERT;"
"   IF(IQ(NP) = 0) GO TO :PHOTON:;"
"   LOOP ["
"      :ELECTRON:"
"      CALL ELECTR(IRCODE);"
"      IF(IRCODE.EQ.2) EXIT; "
"      :PHOTON:"
"      CALL PHOTON(IRCODE);"
"      IF(IRCODE.EQ.2) EXIT;"
"   ]REPEAT"
"   IF(NP <= 0) EXIT;"
"]REPEAT "

LOOP [
    ;
    IF( np <= 0 ) EXIT;
    $KERMA-INSERT;  " DEFAULT FOR $KERMA-INSERT; IS ; (NULL)"
    IF( iq(np) = 0 ) [ call photon(ircode); ]
    ELSE             [ call electr(ircode); ]

]

RETURN;
"end of subroutine shower"  END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE UPHI(IENTRY,LVL);
"                                                                  "
"******************************************************************"
"   UPHI STANDS FOR 'UNIFORM PHI DISTRIBUTION'.                    "
"   SET COORDINATES FOR NEW PARTICLE OR RESET DIRECTION COSINES OF "
"   OLD ONE.  GENERATE RANDOM AZIMUTH SELECTION AND REPLACE THE    "
"   DIRECTION COSINES WITH THEIR NEW VALUES.                       "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-UPHI;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM/;

"Input variables"
integer  IENTRY,LVL; "entry switches"

"Local variables"
$REAL CTHET,  "5/2*pi-THETA, used to evaluate cos(THETA) using the sine table"
      RNNO38, "random number for azimuthal angle selection"
      PHI,    "azimuthal scattering angle"
      CPHI,   "5/2*pi-PHI"
      A,B,C,  "direction cosines before rotation"
      SINPS2, "SINPS2=A*A+B*B"
      SINPSI, "Sqrt(SINPS2)"
      US,VS,  "x- and y- component of scattering vector"
      SINDEL,COSDEL;
              "aux. variables for the rotation algorithm"

$INTEGER
      IARG,   "index for AUSGAB"
      LPHI,LTHETA,LCTHET,LCPHI;
              "indeces for sine table"

$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
save CTHET,PHI,CPHI,A,B,C,SINPS2,SINPSI,US,VS,SINDEL,COSDEL;

$AUSCALL($UPHIAUSB);
GO TO (:UPHI:,:UPHI2:,:NRK:),IENTRY;
"   IENTRY OUT-OF-BOUNDS IF HERE"  GO TO :ERROR:;

:UPHI:; "NOTE: AFB 88/12/12 ADDED SEMI-COLON, ELSE BUG WHEN OVERRIDING SIN"
        "TABLE LOOK-UP"
$SET INTERVAL THETA,SINC;
$EVALUATE SINTHE USING SIN(THETA);
CTHET=PI5D2-THETA;$SET INTERVAL CTHET,SINC;
$EVALUATE COSTHE USING SIN(CTHET);

"   USE THE FOLLOWING ENTRY IF SINTHE AND COSTHE ARE ALREADY KNOWN."
"   SELECT PHI UNIFORMLY OVER THE INTERVAL (0,TWO PI). THEN USE    "
"   PWLF OF SIN FUNCTION TO GET SIN(PHI) AND COS(PHI).  THE COSINE "
"   IS GOTTEN BY COS(PHI)=SIN(9*PI/4 - PHI).                       "

:UPHI2:;

" It is much faster to use the box method for azimuthal angle selection"
" than the following                                                   "
" $RANDOMSET RNNO38;
" PHI=RNNO38*TWOPI;$SET INTERVAL PHI,SINC;
" $EVALUATE SINPHI USING SIN(PHI);
" CPHI=PI5D2-PHI;$SET INTERVAL CPHI,SINC;
" $EVALUATE COSPHI USING SIN(CPHI);
$SELECT-AZIMUTHAL-ANGLE(cosphi,sinphi);

"   USE THE FOLLOWING ENTRY FOR THE SECOND OF TWO PARTICLES WHEN WE"
"   KNOW TWO PARTICLES HAVE A RELATIONSHIP IN THEIR CORRECTIONS.   "
"   NOTE: SINTHE AND COSTHE CAN BE CHANGED OUTSIDE THROUGH COMMON. "
"   LVL IS A PARAMETER TELLING WHICH PARTICLES TO WORK WITH.       "
"   THETA (SINTHE AND COSTHE) ARE ALWAYS RELATIVE TO THE DIRECTION "
"   OF THE INCIDENT PARTICLE BEFORE ITS DIRECTION WAS ADJUSTED.    "
"   THUS WHEN TWO PARTICLES NEED TO HAVE THEIR DIRECTIONS COMPUTED,"
"   THE ORIGINAL INCIDENT DIRECTION IS SAVED IN THE VARIABLE A,B,C "
"   SO THAT IT CAN BE USED ON BOTH CALLS."

"   LVL=1 -- OLD PARTICLE, SAVE ITS DIRECTION AND ADJUST IT"
"   LVL=2 -- NEW PARTICLE. ADJUST DIRECTION USING SAVED A,B,C"
"   LVL=3 -- BREMSSTRAHLUNG GAMMA.  SAVE ELECTRON DIRECTION (NEXT  "
"   TO TOP OF STACK), AND THEN ADJUST GAMMA DIRECTION."

:NRK:
GO TO (:OLD-PARTICLE:,:NEW-PARTICLE:,:BREMS-GAMMA:),LVL;
"   LVL OUT-OF-BOUNDS IF HERE"   GO TO :ERROR:;

:OLD-PARTICLE:
A=U(NP);B=V(NP);C=W(NP);
GO TO :ADJUST:;

:BREMS-GAMMA:
A=U(NP-1);B=V(NP-1);C=W(NP-1);

:NEW-PARTICLE:
$TRANSFER PROPERTIES TO (NP) FROM (NP-1);

"   SEE H.H. NAGEL DISSERTATION FOR COORDINATE SYSTEM DESCRIPTION. "
"   A ROTATION IS PERFORMED TO TRANSFORM DIRECTION COSINES OF THE  "
"   PARTICLE BACK TO THE PHYSICAL FRAME (FROM THE TRANSPORT FRAME) "

:ADJUST:
SINPS2=A*A+B*B;
"   If SINPS2 is small, no rotation is needed    "
IF (SINPS2.LT.1.0E-20)["small polar angle case"
   U(NP)=SINTHE*COSPHI;
   V(NP)=SINTHE*SINPHI;
   W(NP)=C*COSTHE;    "fixed March 2001 from =COSTHE"
] "end small polar angle case"
ELSE["large polar angle case"
   SINPSI=SQRT(SINPS2);
   US=SINTHE*COSPHI;
   VS=SINTHE*SINPHI;
   SINDEL=B/SINPSI;
   COSDEL=A/SINPSI;
   U(NP)=C*COSDEL*US-SINDEL*VS+A*COSTHE;
   V(NP)=C*SINDEL*US+COSDEL*VS+B*COSTHE;
   W(NP)=-SINPSI*US+C*COSTHE;
]"end large polar angle case"

$AUSCALL($UPHIAUSA);

RETURN;

:ERROR: "REACH THIS POINT IF EITHER IENTRY OR LVL NE 1,2, OR 3"
$egs_fatal('(a,2i6)',' STOPPED IN UPHI WITH IENTRY,LVL=',IENTRY,LVL);

"END OF SUBROUTINE UPHI"    END;

;
%E
"*************************************************************************
"
" The following is a set of macros and subroutines that implement
" bremsstrahlung sampling from the S. Seltzer (NIST) cross sections
" (which are the basis for ICRU radiative stopping powers, into the
" EGSnrc environment) or the NRC cross sections, which are essentially
" the same as NIST, but with corrections to the electron-electron
" contribution (corrections are only significant for low values of
" atomic number Z and low values of the emitted photon energy k.
"
" In order to use it, you have to `turn on' this option by
" setting ibr_nist (which is in COMON/BREMPR/) to ibr_nist=1 for the
" original NIST data (nist_brems.data) or ibr_nist=2 for the NRC
" data (nrc_brems.data).
"
" If this option is turned on, subroutine HATCH will call
" subroutine init_nist_brems.
" In init_nist_brems the NIST cross sections are read in,
" total bremsstrahlung cross sections are calculated using
" 64 point Gauss-Legendre quadrature, the interpolation arrays
" that are used for total cross sections and brems fraction interpolations
" (esig0, esig1, ebr10, ebr11               for electrons)
" (psig0, psig1, pbr10, pbr11, pbr20, pbr21 for positrons)
" are updated and alias sampling tables for rapid sampling of brems
" energies are created. These alias sampling tables are then used
" during the simulation in subroutine BREMS.
" Be aware that there is a slight inconsistency when using this option
" as resttricted radiative stopping powers used are the ones coming
" from PEGS and so, they are calculated using Bethe-Heitler.
" This will not matter at all if
"   - AP is much smaller than the electron energy
"       and/or
"   - the restricted radiative stopping power is much smaller
"     then the restricted collision stopping power
" Both conditions are usually satisfied.
"
" I. Kawrakow, NRC, January 2000.
"
" Added NRC brems cross-sections
" F. Tessier, NRC, August 2007.
"
"****************************************************************************

subroutine init_nist_brems;
"**************************"

$IMPLICIT-NONE;

$REAL    energy_array($MXBREN),x_array($MXBRXX),
         cs_array($MXBREN,$MXBRXX,$MXBREL);
$REAL    xi_array($MXBRXX);
real*8   x_gauss($MXGAUSS),w_gauss($MXGAUSS);

$INTEGER nmix,kmix,i,n,k,j,ii;
$INTEGER ngauss,i_gauss;
$INTEGER lnblnk1,egs_get_unit;
$INTEGER ifirst,ilast,nener,neke,leil;

$REAL    cs($MXBREN,$MXBRXX),ee($MXBREN),ele($MXBREN);
$REAL    csx($MXBRXX),afx($MXBRXX),bfx($MXBRXX),cfx($MXBRXX),dfx($MXBRXX);
$REAL    cse($MXBREN),afe($MXBREN),bfe($MXBREN),cfe($MXBREN),dfe($MXBREN);
$REAL    Z,sumA;
$REAL    emin,xi,res,spline,eil,ei,beta2,aux,sigb,sigt,ebr1,ebr2;
$REAL    sigee,sigep,sige,si_esig,si1_esig,si_ebr1,si1_ebr1,ededx,
         sig_bhabha,si_psig,si1_psig,si_pbr1,si1_pbr1,si_pbr2,si1_pbr2;
$INTEGER iz;
$REAL    ple,qle,x,f,error,max_error,x_max_error,f_max_error;
$INTEGER ndat,k_max_error;
character tmp_string*512, tmp1_string*512;
integer  itmp;

$declare_write_buffer;

$REAL amu;
parameter (amu = 1660.5655);  "converts the cross sections from mB/per atom"
                              "to cm^2/g"
$LOGICAL ex,is_opened;
$declare_max_medium;
$COMIN-INIT-NIST-BREMS;

$set_string(tmp_string,' ');
tmp_string = $cstring(hen_house) // 'data' // $file_sep;

IF( ibr_nist = 1 ) [
    $open_data_file(tmp_string,tmp1_string,'nist_brems.data',$NIST-DATA-UNIT);
]
ELSE IF (ibr_nist = 2) [
    $open_data_file(tmp_string,tmp1_string,'nrc_brems.data',$NIST-DATA-UNIT);
]
ELSE [
    $egs_fatal(*,' init_nist_brems: unknown value of ibr_nist!
    ibr_nist = ', ibr_nist);
]

"Get the S. Seltzer (ibr_nist=1) or NRC's (ibr_nist=2) brems cross sections"
"
rewind($NIST-DATA-UNIT);
read($NIST-DATA-UNIT,*);
read($NIST-DATA-UNIT,*) nmix,kmix;
IF (kmix > $MXBRXX) [
    $egs_fatal(*,' init_nist_brems: to many k values in data file!');
]
IF (nmix > $MXBREN) [
    $egs_fatal(*,' init_nist_brems: to many T values in data file!');
]

read($NIST-DATA-UNIT,*) (energy_array(n),n=1,nmix);
DO n=1,nmix [ energy_array(n) = $NIST-ENERGY-SCALE*energy_array(n); ]
read($NIST-DATA-UNIT,*) (x_array(k),k=1,kmix);
read($NIST-DATA-UNIT,*);
DO i=1,$MXBREL [
    read($NIST-DATA-UNIT,*) ((cs_array(n,k,i),n=1,nmix),k=1,kmix);
]
close($NIST-DATA-UNIT);

DO k=1,kmix [
    xi_array(k)=Log(1-x_array(k)+1e-6);
    IF( fool_intel_optimizer ) [
        $egs_info(*,'xi_array(k): ',xi_array(k));
    ]
]

"Get abscissas and weights for Gauss-Legendre quadrature"
"
ngauss = $MXGAUSS;
call gauss_legendre(0d0,1d0,x_gauss,w_gauss,ngauss);

"Calculate total brems cross sections and sampling tables"
"for all media                                           "

$egs_info(*,' ');
IF (ibr_nist = 1) [
$egs_info(*,'Using NIST brems cross sections! ');
]
ELSE IF (ibr_nist = 2) [
    $egs_info(*,'Using NRC brems cross sections! ');
]
$egs_info(*,' ');
DO medium=1,nmed [

    log_ap(medium) = log(ap(medium));
    $egs_info(*,' Initializing brems data for medium ',medium,'...');
    emin = max(ae(medium) - rm, ap(medium));
    DO i=1,nmix [
        IF( energy_array(i) >= emin ) EXIT;
    ]
    ifirst = i;
    DO i=nmix,1,-1 [
        IF( energy_array(i) < ue(medium) - rm ) EXIT;
    ]
    ilast = i+1;
    IF( ifirst < 1 | ilast > nmix ) [
        $egs_info(*,' init_nist_brems: data available only for ');
        $egs_info(*,energy_array(1),' <= E <= ',energy_array(nmix));
        $egs_info(*,' will use spline interpolations to get cross ');
        $egs_info(*,' sections beyond the available data but this may');
        $egs_info(*,' produce nonsense!');
        IF( ifirst < 1 ) ifirst=1;
        IF( ilast > nmix ) ilast = nmix;
    ]
    DO i=ifirst,ilast [
        ii = i+1 - ifirst;
        ee(ii) = energy_array(i); ele(ii) = log(ee(ii));
        sumA = 0;
        DO j=1,NNE(medium) [ sumA = sumA + pz(medium,j)*wa(medium,j); ]
        sumA = sumA*amu;
        DO k=1,kmix [
            cs(ii,k) = 0;
            DO j=1,NNE(medium) [
                Z = zelem(medium,j); iz = int(Z+0.1); Z = Z*Z/sumA;
                cs(ii,k) = cs(ii,k) + pz(medium,j)*Z*cs_array(i,k,iz);
            ]
            csx(k) = Log(cs(ii,k));
        ]
        call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
        "
        " Integrate
        "
        cse(ii) = 0; aux = Log(ee(ii)/ap(medium));
        DO i_gauss = 1,ngauss [
            xi = log(1 - ap(medium)/ee(ii)*exp(x_gauss(i_gauss)*aux)+1e-6);
            res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
            cse(ii) = cse(ii) + w_gauss(i_gauss)*exp(res);
        ]
    ]
    nener = ilast - ifirst + 1;
    call set_spline(ele,cse,afe,bfe,cfe,dfe,nener);
    "
    " Now replace the PEGS cross sections "
    "
    neke = meke(medium);
    sigee = 1E-15; sigep = 1E-15;
    DO i = 1,neke [
        eil = (float(i) - eke0(medium))/eke1(medium); ei = exp(eil);
        leil = i;
        beta2 = ei*(ei+2*rm)/(ei+rm)**2;
        IF( ei <= ap(medium) ) [ sigb = 1e-30; ]
        ELSE [
            sigb = spline(eil,ele,afe,bfe,cfe,dfe,nener);
            sigb = sigb*log(ei/ap(medium))/beta2*rho(medium);
        ]
        $EVALUATE sigt USING esig(eil);  " sigt is the total cross section "
        $EVALUATE ebr1 USING ebr1(eil);  " coming from PEGS, ebr1*sigt is "
                                         " then the brems cross section "
        IF( sigt < 0 ) sigt = 0;
        IF( ebr1 > 1 ) ebr1 = 1;
        IF( ebr1 < 0 ) ebr1 = 0;
        IF( i > 1 ) [
            si_esig = si1_esig;
            si_ebr1 = si1_ebr1;
            si1_esig = sigt*(1 - ebr1) + sigb;
            si1_ebr1 = sigb/si1_esig;
            esig1(i-1,medium) = (si1_esig - si_esig)*eke1(medium);
            esig0(i-1,medium) = si1_esig - esig1(i-1,medium)*eil;
            ebr11(i-1,medium) = (si1_ebr1 - si_ebr1)*eke1(medium);
            ebr10(i-1,medium) = si1_ebr1 - ebr11(i-1,medium)*eil;
        ]
        ELSE [
            si1_esig = sigt*(1 - ebr1) + sigb;
            si1_ebr1 = sigb/si1_esig;
        ]

        "
        " Positrons "
        "
        $EVALUATE sigt USING psig(eil);
        $EVALUATE ebr1 USING pbr1(eil);
        $EVALUATE ebr2 USING pbr2(eil);
        IF( sigt < 0 ) sigt = 0;
        IF( ebr1 > 1 ) ebr1 = 1;
        IF( ebr1 < 0 ) ebr1 = 0;
        IF( ebr2 > 1 ) ebr2 = 1;
        IF( ebr2 < 0 ) ebr2 = 0;
        sig_bhabha = sigt*(ebr2 - ebr1);
        IF( sig_bhabha < 0 ) sig_bhabha = 0;
        IF( i > 1 ) [
            si_psig = si1_psig;
            si_pbr1 = si1_pbr1;
            si_pbr2 = si1_pbr2;
            si1_psig = sigt*(1 - ebr1) + sigb;
            si1_pbr1 = sigb/si1_psig;
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
            psig1(i-1,medium) = (si1_psig - si_psig)*eke1(medium);
            psig0(i-1,medium) = si1_psig - psig1(i-1,medium)*eil;
            pbr11(i-1,medium) = (si1_pbr1 - si_pbr1)*eke1(medium);
            pbr10(i-1,medium) = si1_pbr1 - pbr11(i-1,medium)*eil;
            pbr21(i-1,medium) = (si1_pbr2 - si_pbr2)*eke1(medium);
            pbr20(i-1,medium) = si1_pbr2 - pbr21(i-1,medium)*eil;
        ]
        ELSE [
            si1_psig = sigt*(1 - ebr1) + sigb;
            si1_pbr1 = sigb/si1_psig;
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
        ]
        $EVALUATE ededx USING ededx(eil);
        sige = si1_esig/ededx;
        IF( sige > sigee ) sigee = sige;
        $EVALUATE ededx USING pdedx(eil);
        sige = si1_psig/ededx;
        IF( sige > sigep ) sigep = sige;
    ]
    esig1(neke,medium) = esig1(neke-1,medium);
    esig0(neke,medium) = esig0(neke-1,medium);
    ebr11(neke,medium) = ebr11(neke-1,medium);
    ebr10(neke,medium) = ebr10(neke-1,medium);
    psig1(neke,medium) = psig1(neke-1,medium);
    psig0(neke,medium) = psig0(neke-1,medium);
    pbr11(neke,medium) = pbr11(neke-1,medium);
    pbr10(neke,medium) = pbr10(neke-1,medium);
    pbr21(neke,medium) = pbr21(neke-1,medium);
    pbr20(neke,medium) = pbr20(neke-1,medium);
    $egs_info(*,' Max. new cross sections per energy loss: ',sigee,sigep);
    esig_e(medium) = sigee; psig_e(medium) = sigep;
    IF( sigee > esige_max ) esige_max = sigee;
    IF( sigep > psige_max ) psige_max = sigep;

    "
    " Now prepare the arrays for brems sampling
    "
    nb_emin(medium) = energy_array(ifirst);
    IF( nb_emin(medium) <= ap(medium) ) [
        nb_emin(medium) = energy_array(ifirst+1);
    ]
    nb_emax(medium) = energy_array(ilast);
    nb_lemin(medium) = log(nb_emin(medium));
    nb_lemax(medium) = log(nb_emax(medium));
    nb_dle(medium) = (nb_lemax(medium) - nb_lemin(medium))/($MXBRES-1);
    nb_dlei(medium) = 1/nb_dle(medium);
    "
    eil = nb_lemin(medium) - nb_dle(medium);
    DO i=1,$MXBRES [
        eil = eil + nb_dle(medium); ei = exp(eil);
        DO ii=1,nener [
            IF( ei < ee(ii) ) EXIT;
        ]
        ii = ii-1;
        IF( ii < 1) ii = 1;
        IF( ii > nener-1 ) ii = nener-1;
        "
        " ple and qle are energy interpolation coefficients
        "
        ple = (eil - ele(ii))/(ele(ii+1)-ele(ii)); qle = 1 - ple;
        DO k=1,kmix [
            csx(k) = log(qle*cs(ii,k) + ple*cs(ii+1,k));
        ]
        call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
        "
        " fill the abscissas for this energy
        "
        x = ap(medium)/ei; aux = -log(x);
        xi = log(1 - x+1e-6);
        res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
        nb_xdata(0,i,medium) = 0;
        nb_fdata(0,i,medium) = exp(res);

        DO k=1,kmix [
            IF( x_array(k) > x ) EXIT;
        ]
        IF( k > kmix ) k = kmix;
        ndat = 0;
        DO j=k+1,kmix-1 [
            ndat = ndat+1;
            nb_xdata(ndat,i,medium) = log(x_array(j)/x)/aux;
            nb_fdata(ndat,i,medium) = exp(csx(j));
            IF( fool_intel_optimizer ) [
                $egs_info(*,'nb_xdata(ndat,i,medium): ',
                        nb_xdata(ndat,i,medium));
            ]
        ]
        ndat = ndat+1;
        nb_xdata(ndat,i,medium) = 1;
        nb_fdata(ndat,i,medium) = exp(csx(kmix));
        "
        " Now expand the arrays by filling intermediate points
        " at the positions that show the maxium relative error
        " when using linear interpolation in x.
        " If arrays were allocated dynamically one could use
        " a certain condition to stop the iteration but in our case
        " memory is allocated anyway and so we use the maximum
        " space provided
        "
        IF( ndat >= $MXBRXS ) goto :SKIP-LOOP:;
        LOOP [
            x_max_error = 0; f_max_error = 0; k_max_error = 0;
            max_error = 0;
            DO k=0,ndat-1 [
                x = 0.5*(nb_xdata(k,i,medium) + nb_xdata(k+1,i,medium));
                f = 0.5*(nb_fdata(k,i,medium) + nb_fdata(k+1,i,medium));
                xi = log(1 - ap(medium)/ei*exp(x*aux)+1e-6);
                res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
                res = exp(res);
                error = abs(1-f/res);
                IF( error > max_error ) [
                    x_max_error = x;
                    f_max_error = res;
                    max_error = error;
                    k_max_error = k;
                ]
            ]
            ndat = ndat+1;
            DO k=ndat,k_max_error+2,-1 [
                nb_xdata(k,i,medium) = nb_xdata(k-1,i,medium);
                nb_fdata(k,i,medium) = nb_fdata(k-1,i,medium);
            ]
            nb_xdata(k_max_error+1,i,medium) = x_max_error;
            nb_fdata(k_max_error+1,i,medium) = f_max_error;
        ] UNTIL (ndat = $MXBRXS);

        :SKIP-LOOP:
        "
        " Now generate the alias tables for rapid brems sampling
        " during run time
        "
        call prepare_alias_table($MXBRXS,nb_xdata(0,i,medium),
               nb_fdata(0,i,medium),nb_wdata(1,i,medium),nb_idata(1,i,medium));

    ]
]
$egs_info(*,' ');
$egs_info(*,' ');
return;
" Errors "
:data_file_error:
$egs_fatal(*,'failed to open EGSnrc data file ',$cstring(tmp1_string));
return;
end;

%E
/***************************************************************************
 *
 * A subroutine to initialize pair energy sampling from the NRC
 * cross sections differential in the positron energy.
 * These cross sections are calculated as the product of the
 * exact cross section without screening times the ratio
 * of the first Born approximation with screening to the first
 * Born approximation without screening.
 * At high energies (above, say, 50 MeV) the NRC cross sections are
 * are very close to the Bethe-Heitler cross sections but
 * there are significant differences at low energies. In particular,
 * the asymetrie in the energy distribution between the positron
 * and the electron is properly taken into account.
 *
 * I. Kawrakow, April 2005.
 *
 ***************************************************************************/

subroutine init_nrc_pair;
implicit none;
$declare_max_medium;
;COMIN/MEDIA,BREMPR,ELECIN,NRC-PAIR-DATA,THRESH,USEFUL,EGS-IO/;
$declare_write_buffer;

character     nrcp_file*256, endianess*4;
integer       egs_get_unit;
$INTEGER      nrcp_unit, want_nrcp_unit, rec_length;
$INTEGER      i, lnblnk1;
$REAL         tmp, ddx, xx, Z;
real*4        emin, emax;
integer*4     ne, nb, ix, ie, irec, i_ele, nbb, iz;
REPLACE {$cdum_size} WITH {{COMPUTE 4*($NRC-PAIR-NXX-4)-1}};
character     endian, cdum($cdum_size);
$LOGICAL      swap;
real*4        tmp_4, tarray($NRC-PAIR-NXX);
integer*4     itmp_4;
character     c_4(4), ic_4(4);
equivalence   (tmp_4,c_4), (itmp_4, ic_4);

$set_string(nrcp_file,' ');
nrcp_file = $cstring(hen_house) // 'data' // $file_sep // 'pair_nrc1.data';
want_nrcp_unit = 62;
nrcp_unit = egs_get_unit(want_nrcp_unit);
IF( nrcp_unit < 1 ) [
    $egs_fatal(*,'init_nrc_pair: failed to get a free fortran unit');
]

rec_length = $NRC-PAIR-NXX*$RECL-FACTOR;
open(nrcp_unit,file=nrcp_file,form='unformatted',access='direct',
        status='old',recl=rec_length,err=:nrcp-open-error:);
read(nrcp_unit,rec=1,err=:nrcp-read-error:) emin, emax, ne, nb, endian, cdum;
IF( ichar(endian) = 0 ) [ endianess = '1234'; ] ELSE [ endianess = '4321'; ]
swap = endianess.ne.$BYTE_ORDER;
IF( swap ) [
    tmp_4 = emin; call egs_swap_4(c_4); emin = tmp_4;
    tmp_4 = emax; call egs_swap_4(c_4); emax = tmp_4;
    itmp_4 = ne; call egs_swap_4(ic_4); ne = itmp_4;
    itmp_4 = nb; call egs_swap_4(ic_4); nb = itmp_4;
]
$egs_info('(//a,a)','Reading NRC pair data base from ',$cstring(nrcp_file));
$egs_info('(a,a,a)','Data generated on a machine with ',endianess,' endianess');
$egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
IF( swap ) [ $egs_info('(a)','=> will need to do byte swaping'); ]
$egs_info('(a,2f9.3)','Energy range of the data: ',emin,emax);
IF( nb ~= $NRC-PAIR-NXX ) [
    $egs_fatal(*,'Inconsistent x-grid size');
]
IF( ne ~= $NRC-PAIR-NEE ) [
    $egs_fatal(*,'Inconsistent energy grid size');
]
nrcp_emin = emin; nrcp_emax = emax;
nrcp_dle = log((emax-2)/(emin-2))/(ne-1); nrcp_dlei = 1/nrcp_dle;

nbb = nb/2; ddx = sqrt(0.5)/nbb;
DO ix=0,nbb [ xx = ddx*ix; nrcp_xdata(ix+1) = xx*xx; ]
do ix=nbb-1,0,-1 [ xx = ddx*ix; nrcp_xdata(nb-ix) = 1 - xx*xx; ]

DO medium = 1,NMED [
    $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
    DO ie=1,$NRC-PAIR-NEE [
        DO ix=1,$NRC-PAIR-NXX [ nrcp_fdata(ix,ie,medium) = 0; ]
    ]
    DO i_ele=1,NNE(medium) [
        Z = ZELEM(medium,i_ele); iz = int(Z+0.5);
        tmp = PZ(medium,i_ele)*Z*Z;
        irec = (iz-1)*ne + 2;
        DO ie=1,$NRC-PAIR-NEE [
            read(nrcp_unit,rec=irec,err=:nrcp-read-error:) tarray;
            DO ix=1,$NRC-PAIR-NXX [
                tmp_4 = tarray(ix);
                IF( swap ) [ call egs_swap_4(c_4); ]
                nrcp_fdata(ix,ie,medium)=nrcp_fdata(ix,ie,medium)+tmp*tmp_4;
            ]
            irec = irec + 1;
        ]
    ]
    DO ie=1,$NRC-PAIR-NEE [
        call prepare_alias_table(nb-1,nrcp_xdata,nrcp_fdata(1,ie,medium),
                nrcp_wdata(1,ie,medium),nrcp_idata(1,ie,medium));
    ]

    $egs_info('(a)',' done');

]
$egs_info(*,' ');
close(nrcp_unit);
return;

:nrcp-open-error:;
$egs_fatal(*,'Failed to open NRC pair data file');

:nrcp-read-error:;
$egs_fatal(*,'I/O error while reading NRC pair data file');

end;

%E
"******************************************************************"
"                               NATIONAL RESEARCH COUNCIL OF CANADA"
"                                                                  "
subroutine vmc_electron(ircode);
"                                                                  "
"******************************************************************"
"   This subroutine performs condensed history simulation of       "
"   electron/positron transport according to VMC                   "
"                                                                  "
"   Version 1.0   Iwan Kawrakow       Initial coding               "
"                                     coding is in EGSnrc style    "
"                                     for maximum compatibility    "
"                                     with EGSnrc user codes       "
"******************************************************************"

$IMPLICIT-NONE;

;COMIN/EGS-IO/;

$INTEGER ircode;
$egs_fatal('(//a//)',
' ********* VMC Transport option not in this distribution ****** ');
end;

" Subroutine versions of the random number generator "
" Included here because it makes life easier for using the EGSnrc RNG"
" from within the C-interface. "
subroutine egs_init_default_rng;
;COMIN/RANDOM/;
$RNG-DEFAULT-INITIALIZATION;
return; end;

subroutine egs_init_rng(arg1,arg2);
$INTEGER arg1,arg2;
;COMIN/RANDOM/;
$declare_write_buffer;
$INITIALIZE RNG USING arg1 AND arg2;
return; end;

subroutine egs_get_rndm(ran);
$REAL ran;
;COMIN/RANDOM/;
$RANDOMSET ran;
return; end;

subroutine egs_get_rndm_array(n,rarray);
$INTEGER n;
$REAL    rarray(*);
;COMIN/RANDOM/;
$REAL    rtmp;
$INTEGER i;
IF( n < 1 ) return;
DO i=1,n [
    $RANDOMSET rtmp; rarray(i) = rtmp;
]
return; end;

/****************************************************************************
 *
 * Subroutines for modelling Electron Impact Ionization (EII) in EGSnrc.
 * This implementation uses EII cross section derived from a GOS
 * approach using photo-ionization cross sections from EPDL97 for the
 * OOS. It is called "simple" because
 *   - Ionizations of only K-, LI-, LII- and LIII-shell with binding
 *     energies above 1 keV are taken into account
 *   - Simplified versions of the differential cross sections are used
 *     (but it is made sure that the total energy loss is still
 *      correctly reproduced).
 *
 * EII is turned on by setting the flag eii_flag in COMIN/EII-DATA/ to 1.
 *
 * Iwan Kawrakow, March 2004.
 *
 *****************************************************************************/

"**************************************************************************"
"Init EII. This subroutine is called from HATCH after all media are known, "
"threshold energies and interpolation data have been initialized.          "
"**************************************************************************"
subroutine eii_init;
"**************************************************************************"
implicit none;
$COMIN-EII-INIT;
$INTEGER imed,iele,ish,nsh,iZ,j,i,itmp,nskip,nbin,ii,nsh_tot,iii,k;
$INTEGER jj,jjj;
integer*4 lnblnk1;
$INTEGER tmp_array($MXELEMENT);
$INTEGER want_eii_unit,eii_unit,eii_out,egs_open_file;
integer  egs_get_unit;
$REAL    e_eii_min,emax,fmax,aux_array($N_EII_BINS);
$REAL    sigo,loge,tau,beta2,p2,uwm,Wmax;
$REAL    ss_0, ss_1, sh_0, sh_1, aux, av_e, con_med, dedx_old, sigm_old;
$REAL    dedx,e,sig,sigm,wbrem,sum_a,sum_z,sum_pz,sum_wa,Ec,Ecc;
$REAL    sum_sh,sum_occn,U,sum_sigma,sum_dedx;
$REAL    sigma,sigma_old,wbrem_old,sig_j,de;
$INTEGER lloge;
$LOGICAL check_it,is_monotone,getd;
$REAL    sigma_max;
character eii_file*128;
character*512 toUpper;
$INTEGER occn_numbers(4);
$declare_write_buffer;
$REAL    cons;
parameter (cons = 0.153536); " 2*Pi*Re^2*rm/u "
data     occn_numbers/2,2,2,4/;

DO j=1,$MXELEMENT [ eii_nshells(j) = 0; ]
DO j=1,$MXMED [ eii_nsh(j) = 0; ]
IF( eii_flag = 0 ) [ return; ]

$need_relaxation_data(getd);
IF( ~getd )[
  $egs_fatal('(/a,/a,/a,/a)',
          ' In subroutine eii_init: ',
          '   Scattering off bound electrons creates atomic vacancies,',
          '   potentially starting an atomic relaxation cascade. ',
          '   Please turn ON atomic relaxations.');
]

/*
  find minimum of all threshold energies
 */
e_eii_min = 1e30;
DO imed = 1,nmed [
    IF( ae(imed)-rm < e_eii_min ) e_eii_min = ae(imed) - rm;
    IF( ap(imed) < e_eii_min ) e_eii_min = ap(imed);
]
$egs_info(*,' ');
$egs_info(*,'eii_init: minimum threshold energy found: ',e_eii_min);

/*
  determine elements that need to load EII data
 */
DO imed = 1,nmed [
    DO iele = 1,nne(imed) [
        iZ = int(zelem(imed,iele)+0.5);
        IF( eii_nshells(iZ) = 0 ) [
            nsh = 0;
            DO ish=1,4 [
                IF( binding_energies(ish,iZ) > e_eii_min ) nsh = nsh+1;
            ]
            eii_nshells(iZ) = nsh;
        ]
    ]
]

/* total number of shells that need to be loaded */
nsh = 0;
DO iZ=1,$MXELEMENT [
    nsh = nsh + eii_nshells(iZ);
]
IF( nsh = 0 ) [
    $egs_info(*,'*** EII requested but no shells with binding energies ');
    $egs_info(*,'    above the specified threshold found');
    $egs_info(*,'    => turning off EII');
    eii_flag = 0;
]
IF( nsh > $MAX_EII_SHELLS ) [
    $egs_info(*,'*** Number of shells with binding energies greater than ');
    $egs_info(*,'    the specified thresholds is ',nsh);
    $egs_info(*,'    This is more than the allocated arrays can hold');
    $egs_fatal(*,'    Increase the macro $MAX_EII_SHELLS and retry');
]
$egs_info(*,'eii_init: number of shells to simulate EII: ',nsh);
nsh_tot = nsh;
tmp_array(1) = 0;
DO j=2,$MXELEMENT [ tmp_array(j) = tmp_array(j-1) + eii_nshells(j-1); ]

/* set EII active shells per medium and for each element */
DO imed=1,nmed [
    nsh = 0;
    DO iele=1,nne(imed) [
        iZ = int(zelem(imed,iele)+0.5);
        eii_no(imed,iele) = eii_nshells(iZ);
        nsh = nsh + eii_nshells(iZ);
        IF( eii_nshells(iZ) > 0 ) [ eii_first(imed,iele) = tmp_array(iZ) + 1; ]
        ELSE [ eii_first(imed,iele) = 0; ]
    ]
    eii_nsh(imed) = nsh;
]

/* read EII data */
$set_string(eii_file,' ');
eii_file = $cstring(hen_house) // 'data' // $file_sep // 'eii_'//
           $cstring(eii_xfile) //'.data';
want_eii_unit = 62;
eii_unit = egs_get_unit(want_eii_unit);
IF( eii_unit < 1 ) [
    $egs_fatal(*,'eii_init: failed to get a free Fortran I/O unit');
]
open(eii_unit,file=$cstring(eii_file),status='old',err=:no-eii-file:);
$egs_info('(//a,a)','Opened EII data file ',$cstring(eii_file));
$egs_info('(a,$)',' eii_init: reading EII data ... ');
read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) nskip;
DO j=1,nskip [
    read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:);
]
read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) emax,nbin;
IF( nbin ~= $N_EII_BINS ) [
    $egs_fatal(*,'Inconsistent EII data file');
]
IF (xsec_out = 1)[
   eii_out = egs_open_file(93,0,1,'.eiixsec');
]
ii = 0;
DO j=1,$MXELEMENT [
    read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) iZ,nsh;
    IF (xsec_out = 1 & eii_nshells(iZ) > 0)[
     write(eii_out,*) '=================================';
     write(eii_out,'(a,i3)') 'EII xsections for element Z = ',iZ;
     write(eii_out,*) '=================================';
    ]
    IF( nsh < eii_nshells(iZ) ) [
        $egs_info(*,'EII data file has data for ',nsh,' shells for element ');
        $egs_info(*,iZ,' but according');
        $egs_info(*,'to binding energies and thresholds ',eii_nshells(iZ));
        $egs_info(*,'shells are required');
        $egs_fatal(*,'This is a fatal error.');
    ]
    DO ish=1,nsh [
        read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) fmax;
        read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:)
           aux_array;
        "Scale L-shell EII xsections by eii_L_factor. Defaults to 1."
        IF (ish>1 & ish < 5) [fmax = fmax*eii_L_factor;]
        IF( ish <= eii_nshells(iZ) ) [
            IF (xsec_out = 1)[
              IF(ish = 1)[
               write(eii_out,'(a,f10.2,a)')
               'K-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSEIF (ish = 2)[
               write(eii_out,'(a,f9.2,a)')
               '=> LI-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSEIF (ish = 3)[
               write(eii_out,'(a,f8.2,a)')
               '=> LII-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSEIF (ish = 4)[
               write(eii_out,'(a,f8.2,a)')
               '=> LIII-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSE[ write(eii_out,*) '=> Wrong number of shells!';]
              write(eii_out,*) '   E/keV     sigma/(b/atom)';
              write(eii_out,*) '---------------------------';
            ]
            ii = ii+1; eii_z(ii) = iZ; eii_sh(ii) = ish;
            eii_a(ii) = nbin;
            eii_a(ii) = eii_a(ii)/log(emax/binding_energies(ish,iZ));
            eii_b(ii) = 1 - eii_a(ii)*log(binding_energies(ish,iZ));
            DO k=1,nbin [
                IF( k > 1 ) [ sigo = fmax*aux_array(k-1); ]
                ELSE [ sigo = 0; ]
                loge = (k - eii_b(ii))/eii_a(ii); iii = nbin*(ii-1)+k;
                eii_xsection_a(iii) = (fmax*aux_array(k)-sigo)*eii_a(ii);
                eii_xsection_b(iii) = sigo - eii_xsection_a(iii)*loge;
                IF (xsec_out = 1)[
                   write(eii_out,'(f12.2,2X,10f9.2)')
                   Exp((k+1-eii_b(ii))/eii_a(ii))*1000.0,fmax*aux_array(k);
                ]
            ]
        ]
    ]
    IF( ii = nsh_tot ) [ EXIT; ]
]
close(eii_unit);
IF (xsec_out = 1)[ close(eii_out); ]
$egs_info(*,' OK '); $egs_info(*,' ');

/*
   Adjust restricted stopping power and discrete inelastic cross sections

   Discrete interaction cross sections for all shells that come from PEGS4
   are calculated using the Moller cross section
     => we must subtract the Moller cross section for the shells that will
        have EII and then add the EII cross sections for these shells
   The restricted stopping power that comes from PEGS4 is calculated assuming
   that all shells will be producing secondaries according to Moller
     => we must add the energy lost in Moller events in EII shells to the
        restricted stopping power and then subtract the average energy lost
        in EII events.
 */
DO imed = 1,nmed [
    Ec = ae(imed) - rm; Ecc = min(Ec,ap(imed));
    /sum_z,sum_pz,sum_a,sum_wa/=0;
    DO iele=1,nne(imed) [
        sum_z = sum_z + pz(imed,iele)*zelem(imed,iele);
        sum_pz = sum_pz + pz(imed,iele);
        sum_wa = sum_wa + rhoz(imed,iele);
        sum_a = sum_a + pz(imed,iele)*wa(imed,iele);
    ]
    con_med = rho(imed)/1.6605655/sum_a;
    eii_cons(imed) = con_med;
    IF( eii_nsh(imed) > 0 ) [
        is_monotone = .true.;
        sigma_max = 0;
        DO j=1,meke(imed) [
            loge = (j - eke0(imed))/eke1(imed); e = Exp(loge);
            tau = e/rm; beta2 = tau*(tau+2)/(tau+1)**2;
            p2 = 2*rm*tau*(tau+2);
            lloge = j;
            medium = imed;
            $EVALUATE dedx USING ededx(loge);
            IF( e > ap(medium) | e > 2*Ec ) [
                $EVALUATE sig USING esig(loge);
            ] ELSE [ sig = 0; ]
            IF( e > 2*Ec ) [
                $EVALUATE wbrem USING ebr1(loge);
                sigm = sig*(1-wbrem);
            ] ELSE [ sigm = 0; wbrem = 1; ]
            /sum_occn,sum_sigma,sum_dedx/=0;
            DO iele=1,nne(imed) [
                iZ = int(zelem(imed,iele)+0.5);
                sum_sh = 0;
                DO ish = 1,eii_no(imed,iele) [
                    "jj is the shell index in the list of EII shells "
                    jj = eii_first(imed,iele) + ish - 1;
                    "jjj is shell type (1 = K, 2 = LI, 3 = LII, etc.)
                    jjj = eii_sh(jj); U = binding_energies(jjj,iZ);
                    Wmax = (e+U)/2; uwm = U/Wmax;
                    "IF( Uj >= Ecc ) sum_sh = sum_sh + occn_numbers(jjj);
                    IF( U < e & U > Ecc ) [
                        " At this energy interactions with this shell will "
                        " be done using the EII differential x-section "
                        sum_sh = sum_sh + occn_numbers(jjj);
                        ss_0 = 2*(log(p2/U)-uwm**3*log(p2/Wmax)-
                          (beta2+0.833333)*(1-uwm**3))/3/U;
                        sh_0 = ((1-uwm)*(1+uwm/(2-uwm))+U*(Wmax-U)/(e+rm)**2
                          - (2*tau+1)/(tau+1)**2*uwm/2*log((2-uwm)/uwm))/U;
                        ss_1 = log(p2/U)-uwm**2*log(p2/Wmax)-
                          (beta2+1)*(1-uwm**2);
                        sh_1 = log(Wmax/U/(2-uwm))+2*(Wmax-U)/(2*Wmax-U)
                          +(Wmax**2-U**2)/(e+rm)**2/2
                          -(2*tau+1)/(tau+1)**2*log((2*Wmax-U)/Wmax);
                        av_E = (ss_1 + sh_1)/(ss_0 + sh_0);
                          "av_E is the average energy lost in a collision"
                          "with this shell"
                        i = eii_a(jjj)*loge + eii_b(jjj);
                        i = (jj-1)*$N_EII_BINS + i;
                        sig_j = eii_xsection_a(i)*loge + eii_xsection_b(i);
                        sig_j = sig_j*pz(imed,iele)*con_med;
                        sum_sigma = sum_sigma + sig_j;
                        sum_dedx = sum_dedx + sig_j*av_E;
                    ]
                ]
                sum_occn = sum_occn + sum_sh*pz(imed,iele);
            ]
            sigm = sigm + sum_sigma;
            dedx = dedx - sum_dedx;
            aux = Ec/e;
            IF( e > 2*Ec ) [
                sigo = cons*sum_occn*rho(imed)/(beta2*Ec)*(
                        (1-2*aux)*(1+aux/(1-aux)+(tau/(tau+1))**2*aux/2)-
                        (2*tau+1)/(tau+1)**2*aux*log((1-aux)/aux))/sum_a;
                de = cons*sum_occn*rho(imed)/beta2*(
                  log(0.25/aux/(1-aux))+(1-2*aux)/(1-aux)+
                  (tau/(tau+1))**2*(1-4*aux*aux)/8-
                  (2*tau+1)/(tau+1)**2*log(2*(1-aux)))/sum_a;
                sigm = sigm - sigo;
                "sigm = sig*(1-wbrem)*(1-sum_occn/sum_z);
                dedx = dedx + de;
            ]
            sigma = sigm + wbrem*sig;
            IF( sigma/dedx > sigma_max ) sigma_max = sigma/dedx;
            IF( sigma > 0 ) [ wbrem = wbrem*sig/sigma; ]
            ELSE [ wbrem = 1; ]
            IF( j > 1 ) [
                ededx1(j-1,imed) = (dedx - dedx_old)*eke1(imed);
                ededx0(j-1,imed) = dedx - ededx1(j-1,imed)*loge;
                esig1(j-1,imed) = (sigma - sigma_old)*eke1(imed);
                esig0(j-1,imed) = sigma - esig1(j-1,imed)*loge;
                ebr11(j-1,imed) = (wbrem - wbrem_old)*eke1(imed);
                ebr10(j-1,imed) = wbrem - ebr11(j-1,imed)*loge;
                IF( sigma/dedx < sigma_old/dedx_old ) is_monotone = .false.;
            ]
            dedx_old = dedx; sigm_old = sigm;
            sigma_old = sigma; wbrem_old = wbrem;
        ]
        ededx1(meke(imed),imed) = ededx1(meke(imed)-1,imed);
        ededx0(meke(imed),imed) = ededx0(meke(imed)-1,imed);
        esig1(meke(imed),imed) = esig1(meke(imed)-1,imed);
        esig0(meke(imed),imed) = esig0(meke(imed)-1,imed);
        ebr11(meke(imed),imed) = ebr11(meke(imed)-1,imed);
        ebr10(meke(imed),imed) = ebr10(meke(imed)-1,imed);
        $egs_info(*,'eii_init: for medium ',imed,' adjusted sige = ',
                sigma_max,' monotone = ',is_monotone);
        sig_ismonotone(0,imed) = is_monotone;
        esig_e(imed) = sigma_max;
    ]
]
return;

:eii-reading-error:
$egs_fatal(*,'I/O error while reading EII data');

:no-eii-file:
$egs_fatal('(//a,a,/a,/a/)','Failed to open EII data file ',$cstring(eii_file),
          'Make sure file exists in your $HEN_HOUSE/data directory!',
          '****BEWARE of case sensitive file names!!!');

return; end;

"*****************************************************************************"

subroutine eii_sample(ish,iZ,Uj);
implicit none;
$INTEGER ish,iZ;
$REAL    Uj;

$COMIN-EII-SAMPLE;

$REAL T,tau,tau1,tau12,tau2,p2,beta2,c1,c2,Wmax,xmax,fm_s,fm_h,prob_s,prob;
$REAL r1,r2,r3,wx,wxx,aux,frej;
real*8 peie,pese1,pese2,dcosth,h1;
$INTEGER iarg;
$REAL    eta,cphi,sphi;
$INTEGER np_save,ip,j;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;

/* calculate some useful constants */
peie = e(np);
T = peie - rm; tau = T/rm; tau1 = tau+1;
tau12 = tau1*tau1; tau2 = tau*tau; p2 = tau2 + 2*tau;
beta2 = p2/tau12;
"c1 = tau2/tau12; "
Wmax = 0.5*(T+Uj); xmax = Uj/Wmax;
c1 = (Wmax/peie)**2;
c2 = (2*tau+1)/tau12;
fm_s = log(rmt2*p2/Uj) - beta2 - 0.5;
prob_s = 0.66666667*fm_s*(1+xmax+xmax*xmax);
"fm_h = 1 + c1 - c2;"
fm_h = 2 + c1 - c2;
IF( fm_h < 1 ) fm_h = 1;
prob = fm_h + prob_s;

LOOP [
    $RANDOMSET r1; $RANDOMSET r2; $RANDOMSET r3;
    IF( r1*prob < fm_h ) [ "Use the hard collision cross section "
        wx = 1/(r2*xmax+1-r2); wxx = wx*xmax; aux = wxx/(2-wxx);
        frej = (1 + aux*(aux-c2)+c1*wxx*wxx)/fm_h;
    ] ELSE [               "Use the soft collision cross section "
        wx = 1/(r2*xmax**3+1-r2)**0.333333333;
        frej = 1 - log(wx)/fm_s;
    ]
] UNTIL ( r3 < frej );

wx = wx*Uj;

/* set-up new particles */
h1 = (peie + prm)/T; pese1 = peie - wx;
e(np) = pese1;
dcosth = h1*(pese1-prm)/(pese1+prm);
sinthe = dsqrt(1-dcosth); costhe = dsqrt(dcosth);
call uphi(2,1);

pese2 = wx - Uj + prm;
edep_local = 0;
IF( pese2 > ae(medium) ) [
    $CHECK-STACK(np+1,'eii_sample');
    np = np+1; e(np) = pese2;
    dcosth = h1*(pese2-prm)/(pese2+prm);
    sinthe = -dsqrt(1-dcosth); costhe = dsqrt(dcosth);
    iq(np) = -1; call uphi(3,2);
    edep = 0;
] ELSE [
    edep = wx - Uj;
    edep_local = edep;
    $AUSCALL($SELECTRONA);
]
"ish ranges from 1 to 4 for K,L1,L2,L3 shells"
call relax(Uj,ish,iZ);

IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); ]

/*
IF( nbr_split > 1 ) [
    np_save = np;
    DO ip=NPold+1,np_save [
        IF( iq(ip) = 0 ) [
            wt(ip) = wt(ip)/nbr_split;
            DO j = 1,nbr_split-1 [
                np = np + 1; $CHECK-STACK(np,'eii_sample');
                iq(np) = 0; e(np) = e(ip);
                $TRANSFER PROPERTIES TO (np) FROM (ip);
                $RANDOMSET eta; eta = 2*eta - 1; w(np) = eta;
                eta = (1-eta)*(1+eta);
                IF( eta > 1e-20 ) [
                    eta = Sqrt(eta);
                    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
                    u(np) = eta*cphi; v(np) = eta*sphi;
                ] ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
            ]
        ]
    ]
]
*/


return; end;

"============================================================================"
subroutine egs_scale_photon_xsection(imed,fac,which);
"============================================================================"
"
"  Scale the photon cross section 'which' by factor fac for medium imed.
"  which = 0 for all cross sections
"        = 1 for Rayleigh scattering
"        = 2 for Compton scattering
"        = 3 for Pair production
"        = 4 for photo-absorption
"  If imed = 0, scaling is done for all media.
"============================================================================"
implicit none;
$INTEGER imed,which;
$REAL    fac;
$declare_max_medium;
;COMIN/MEDIA,PHOTIN,EGS-IO/;
$INTEGER ifirst,ilast,medium,j;
$LOGICAL has_r;
$REAL    gle,gmfp,gbr1,gbr2,cohfac,aux,gmfp_old,gbr1_old,gbr2_old,cohfac_old;
character*8 strings(5);
data       strings/'photon','Rayleigh','Compton','pair','photo'/;

IF( which < 0 | which > 4 ) [ return; ]
IF( imed > 0 & imed <= nmed ) [ ifirst = imed; ilast = imed; ]
ELSE [ ifirst = 1; ilast = nmed; ]
IF( which = 1 ) [
    has_r = .false.;
    DO medium = ifirst, ilast [
        IF( iraylm(medium) = 1 ) [ has_r = .true.; ]
    ]
    IF( ~has_r ) return;
]
$egs_info(*,' ');
DO medium = ifirst,ilast [

    $egs_info('(a,a,a,i3,a,f9.5)',
            'Scaling ',strings(which+1),' x-section data for medium',
            medium,' with ',fac);

    DO j = 1,mge(medium) [

        gle = (j - ge0(medium))/ge1(medium);
        gmfp = gmfp0(j,medium) + gmfp1(j,medium)*gle;
        gbr1 = gbr10(j,medium) + gbr11(j,medium)*gle;
        gbr2 = gbr20(j,medium) + gbr21(j,medium)*gle;
        IF( iraylm(medium) = 1 ) [
            cohfac = cohe0(j,medium) + cohe1(j,medium)*gle;
        ] ELSE [ cohfac = 1; ]
        IF( which = 0 ) [ gmfp = gmfp/fac; ]
        ELSE IF( which = 1 ) [ cohfac = cohfac/(fac*(1-cohfac)+cohfac); ]
        ELSE [
            IF( which = 2 ) [
                aux = fac*(gbr2-gbr1) + gbr1 + 1 - gbr2;
                gbr2 = (gbr1 + fac*(gbr2-gbr1))/aux; gbr1 = gbr1/aux;
            ]
            ELSE IF( which = 3 ) [
                aux = fac*gbr1 + 1 - gbr1;
                gbr2 = (fac*gbr1 + gbr2-gbr1)/aux; gbr1 = fac*gbr1/aux;
            ]
            ELSE [
                aux = gbr2 + fac*(1-gbr2);
                gbr1 = gbr1/aux; gbr2 = gbr2/aux;
            ]
            gmfp = gmfp/aux;
            cohfac = cohfac*aux/(aux*cohfac + 1 - cohfac);
        ]
        IF( j > 1 ) [
            gmfp1(j-1,medium) = (gmfp - gmfp_old)*ge1(medium);
            gmfp0(j-1,medium) = gmfp - gmfp1(j-1,medium)*gle;
            gbr11(j-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
            gbr10(j-1,medium) = gbr1 - gbr11(j-1,medium)*gle;
            gbr21(j-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
            gbr20(j-1,medium) = gbr2 - gbr21(j-1,medium)*gle;
            cohe1(j-1,medium) = (cohfac - cohfac_old)*ge1(medium);
            cohe0(j-1,medium) = cohfac - cohe1(j-1,medium)*gle;
        ]
        gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohfac_old = cohfac;

    ]
    gmfp1(mge(medium),medium) = gmfp1(mge(medium)-1,medium);
    gmfp0(mge(medium),medium) = gmfp0(mge(medium)-1,medium);
    gbr11(mge(medium),medium) = gbr11(mge(medium)-1,medium);
    gbr10(mge(medium),medium) = gbr10(mge(medium)-1,medium);
    gbr21(mge(medium),medium) = gbr21(mge(medium)-1,medium);
    gbr20(mge(medium),medium) = gbr20(mge(medium)-1,medium);
    cohe1(mge(medium),medium) = cohe1(mge(medium)-1,medium);
    cohe0(mge(medium),medium) = cohe0(mge(medium)-1,medium);
]

return; end;

/*============================================================================

 Subroutines to initialize photon cross section data.
 The data is read from string_photo.data, string_pair.data,
 string_triplet.data, and string_rayleigh.data, where string is the argument
 passed to the subroutine.

============================================================================*/

REPLACE {$OPEN-UNIT(#,#,#);} WITH {
    {P1} = {P2};
    {P1} = egs_get_unit({P1});
    IF( {P1} < 1 ) [
        $egs_fatal(*,
         'egs_init_user_photon: failed to get a free Fortran I/O unit');
    ]
    tmp_string = {P3};
    open({P1},file={P3},status='old',err=:no-user-data-file:);
};

REPLACE {$MXINPUT} WITH {2000};
REPLACE {$MXBCINP} WITH {183};

"============================================================================="
"Ali:photonuc, 1 line"
 subroutine egs_init_user_photon(prefix,comp_prefix,photonuc_prefix,out);
"subroutine egs_init_user_photon(prefix,comp_prefix,out);"
"============================================================================="
implicit none;
$declare_max_medium;
character*(*) prefix, comp_prefix,
"Ali:photonuc, 1 line"
              photonuc_prefix;
$INTEGER      out;
;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,COMPTON-DATA,X-OPTIONS/;
$INTEGER   lnblnk1,egs_get_unit,medium,
           photo_unit,pair_unit,rayleigh_unit,triplet_unit,
           ounit,egs_open_file,compton_unit,
"Ali:photonuc, 1 line"
           photonuc_unit;
$INTEGER   nge,sorted($MXEL),i,j,k,iz,iz_old,ndat;
$REAL      z_sorted($MXEL),pz_sorted($MXEL);
$REAL      sig_photo($MXGE),sig_pair($MXGE),sig_triplet($MXGE),
           sig_rayleigh($MXGE),sig_compton($MXGE);
$REAL      sigma,cohe,gmfp,gbr1,gbr2,sig_KN,gle,e,sig_p;
$REAL      cohe_old,gmfp_old,gbr1_old,gbr2_old,
"Ali:photonuc, 3 lines"
           sig_photonuc($MXGE),
           photonuc,
           photonuc_old;

$REAL      etmp($MXINPUT),ftmp($MXINPUT);
$REAL      sumZ,sumA,con1,con2,egs_KN_sigma0;
$REAL      bc_emin,bc_emax,bc_dle,bc_data($MXBCINP),bc_tmp($MXBCINP),bcf,aj;
$INTEGER   bc_ne;
$LOGICAL   input_compton_data,
"Ali:photonuc, 1 line"
           input_photonuc_data;
character  data_dir*128,photo_file*140,pair_file*140,rayleigh_file*144,
           triplet_file*142,tmp_string*144,compton_file*144,
"Ali:photonuc, 1 line"
           photonuc_file*144;

$egs_info('(/a$)','(Re)-initializing photon cross sections');
$egs_info('(a,a/)',' with files from the series: ',
      prefix(:lnblnk1(prefix)));

$egs_info('(a,a)',' Compton cross sections: ',$cstring(comp_prefix));

"Ali:photonuc, 1 block"
IF(iphotonuc = 1) [
 $egs_info('(a,a)',' Photonuclear cross sections: ',
 $cstring(photonuc_prefix));
 input_photonuc_data = .false.;
 IF(lnblnk1(photonuc_prefix) > 0 & photonuc_prefix(1:7) ~= 'default') [
   input_photonuc_data = .true.;
 ]
]

input_compton_data = .false.;
IF( ibcmp(1) > 1 & lnblnk1(comp_prefix) > 0 ) [
    IF( comp_prefix(1:7) ~= 'default' ) input_compton_data = .true.;
]
data_dir = $cstring(hen_house) // 'data' // $file_sep;
photo_file = $cstring(data_dir) // $cstring(prefix) // '_photo.data';
pair_file = $cstring(data_dir) // $cstring(prefix) // '_pair.data';
triplet_file = $cstring(data_dir) // $cstring(prefix) // '_triplet.data';
rayleigh_file = $cstring(data_dir) // $cstring(prefix) // '_rayleigh.data';
IF( input_compton_data ) [
    compton_file = $cstring(data_dir) // $cstring(comp_prefix) //
                   '_compton.data';
]
ELSE [
    compton_file = $cstring(data_dir) // 'compton_sigma.data';
]
"Ali: I moved this info line from inside the IF statement
" because it's useful to print the cross section file either way
$egs_info('(a,a)',' Using Compton cross sections from ',
          $cstring(compton_file));

"Ali:photonuc, 1 block"
IF(iphotonuc = 1) [
 IF( input_photonuc_data ) [
    photonuc_file = $cstring(data_dir) // $cstring(photonuc_prefix) //
                    '_photonuc.data';
 ]
 ELSE [
    photonuc_file = $cstring(data_dir) // 'iaea_photonuc.data';
 ]
 $egs_info('(a,a)',' Using photonuclear cross sections from ',
  $cstring(photonuc_file));
]

$OPEN-UNIT(photo_unit,83,photo_file);
$OPEN-UNIT(pair_unit,84,pair_file);
$OPEN-UNIT(triplet_unit,85,triplet_file);
$OPEN-UNIT(rayleigh_unit,86,rayleigh_file);
IF( ibcmp(1) > 1 ) [ $OPEN-UNIT(compton_unit,88,compton_file); ]
" Note: ibcmp > 1 means the user wants to use Bound Compton scattering "
"       without rejections. For this we have to use the actual bound   "
"       Compton scattering cross section, which is now available in a  "
"       file called bound_compton.data (the file actually contains the "
"       ratio of the Bound Compton to the KN cross section).           "
"       Because this option is not available on a region by region     "
"       basis, we just need to check ibcmp(1)                          "
"Ali:photonuc, 1 line"
IF( iphotonuc = 1 ) [ $OPEN-UNIT(photonuc_unit,89,photonuc_file); ]

IF( out = 1 ) [
    ounit = egs_open_file(87,0,1,'.xsections');
    write(ounit,'(/a,a,a)') 'Photon cross sections initialized from ',
       $cstring(prefix),' data files';
    write(ounit,'(a,/)')
'============================================================================';
    write(ounit,'(a,/)') 'Grid energies and cross sections are output';
"Ali:photonuc, 1 block"
    IF(iphotonuc = 1) [
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a)')
         'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ',
         ' GMFP(cm) ';
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a/)')
         '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh',
         'w/ Ray + photnuc';
    ]
    ELSE[
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a)')
            'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ';
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a/)')
            '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh';
   ]
]
/* Replace binding energies with the edges in the photo-absorption file */
DO iz=1,100 [
    read(photo_unit,*) ndat;
    read(photo_unit,*) (etmp(k),ftmp(k),k=1,ndat);
    k = 0;
    DO j=ndat,2,-1 [
        IF( etmp(j)-etmp(j-1) < 1e-5 ) [
            k = k+1;
            IF ( k <= $MXSHXSEC )[
               binding_energies(k,iz) = exp(etmp(j));
            ]
            ELSE[
              $egs_fatal('(i3,a,i3,//a)',
                         k,' binding energies read exceeding array size of',
                         $MXSHXSEC,'Increase $MXSHXSEC in egsnrc.macros!');
            ]
            IF( ~eadl_relax & k >= 4 ) EXIT;
        ]
    ]
]

IF (mcdf_pe_xsections)[call egs_read_shellwise_pe();]

DO medium = 1,nmed [

    mge(medium) = $MXGE; nge = $MXGE;
    ge1(medium) = nge-1; ge1(medium) = ge1(medium)/log(up(medium)/ap(medium));
    ge0(medium) = 1 - ge1(medium)*log(ap(medium));

    $egs_info('(a,i3,a,$)',' Working on medium ',medium,' ... ');
    IF( out = 1 ) [
        write(ounit,'(/,2x,a,i3,a,24a1/)') 'Medium ',medium,': ',
          (media(k,medium),k=1,24);
    ]
    /sumZ,sumA/ = 0;
    DO i=1,nne(medium) [
        z_sorted(i) = zelem(medium,i);
        sumZ = sumZ + pz(medium,i)*zelem(medium,i);
        sumA = sumA + pz(medium,i)*wa(medium,i);
    ]
    con1 = sumZ*rho(medium)/(sumA*1.6605655);
    con2 = rho(medium)/(sumA*1.6605655);
    call egs_heap_sort(nne(medium),z_sorted,sorted);
    DO i=1,nne(medium) [ pz_sorted(i) = pz(medium,sorted(i)); ]

    IF (mcdf_pe_xsections)[
       call egsi_get_shell_data(medium,nge,nne(medium),z_sorted,pz_sorted,
                                ge1(medium),ge0(medium),sig_photo);
    ]
    ELSE[
       call egsi_get_data(0,photo_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_photo);
    ]
    call egsi_get_data(0,rayleigh_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_rayleigh);
    call egsi_get_data(1,pair_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_pair);
    call egsi_get_data(2,triplet_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_triplet);
"Ali:photonuc, 1 block"
    IF( iphotonuc = 1 ) [
      call egsi_get_data(3,photonuc_unit,nge,nne(medium),z_sorted,pz_sorted,
                        ge1(medium),ge0(medium),sig_photonuc);
    ]

    IF( ibcmp(1) > 1 ) [
        "Get the bound compton cross section data"
        IF( input_compton_data ) [
            call egsi_get_data(0,compton_unit,nge,nne(medium),
                    z_sorted,pz_sorted,ge1(medium),ge0(medium),
                    sig_compton);
        ]
        ELSE [
            rewind(compton_unit);
            read(compton_unit,*) bc_emin,bc_emax,bc_ne;
            IF( bc_ne > $MXBCINP ) [
              $egs_fatal(*,'Number of input Compton data exceeds array size');
            ]
            "write(6,*) 'bc emin,emax,ne = ',bc_emin,bc_emax,bc_ne;
            bc_dle = log(bc_emax/bc_emin)/(bc_ne-1);
            DO j=1,bc_ne [ bc_data(j) = 0; ]
            iz_old = 1;
            DO i=1,nne(medium) [
                iz = int(z_sorted(i)+0.5);
                "write(6,*) ' reading bc data for ',iz;
                DO j=iz_old,iz [ read(compton_unit,*) (bc_tmp(k),k=1,bc_ne); ]
                DO j=1,bc_ne [
                    bc_data(j)=bc_data(j)+pz_sorted(i)*z_sorted(i)*bc_tmp(j);
                ]
                iz_old = iz+1;
            ]
            DO j=1,bc_ne [ bc_data(j)=log(bc_data(j)/sumZ); ]
        ]
    ]

    /* prepare data needed for Rayleigh scattering sampling */
    call egs_init_rayleigh(medium,sig_rayleigh);

    DO i=1,nge [

        gle = (i - ge0(medium))/ge1(medium); e = exp(gle);
        sig_KN = sumZ*egs_KN_sigma0(e);
        IF( ibcmp(1) > 1 ) [
            IF( input_compton_data ) [
                sig_KN = sig_compton(i);
            ]
            ELSE [
                "Apply the bound Compton correction to sig_KN"
                IF( e <= bc_emin ) [ bcf = exp(bc_data(1)); ]
                ELSE IF( e < bc_emax ) [
                    aj = 1 + log(e/bc_emin)/bc_dle;
                    j = int(aj); aj = aj - j;
                    bcf = exp(bc_data(j)*(1-aj) + bc_data(j+1)*aj);
                ]
                ELSE [ bcf = 1; ]
                sig_KN = sig_KN*bcf;
                "write(6,*) 'e = ',e,' bcf = ',bcf;
            ]
        ]
        sig_p  = sig_pair(i) + sig_triplet(i);
        sigma  = sig_KN + sig_p + sig_photo(i);
        gmfp   = 1/(sigma*con2);
        gbr1   = sig_p/sigma;
        gbr2   = gbr1 + sig_KN/sigma;
        cohe   = sigma/(sig_rayleigh(i) + sigma);
"Ali:photonuc, 1 line"
        photonuc = sigma/(sig_photonuc(i) + sigma);

        IF( out = 1 ) [
"Ali:photonuc, 1 block"
           IF(iphotonucm(medium) = 1) [
              write(ounit,'(6(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,
              gmfp*cohe,gmfp*cohe*photonuc;
           ]
           ELSE[
              write(ounit,'(5(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,gmfp*cohe;
           ]
        ]
        IF( i > 1 ) [
            gmfp1(i-1,medium) = (gmfp - gmfp_old)*ge1(medium);
            gmfp0(i-1,medium) =  gmfp - gmfp1(i-1,medium)*gle;
            gbr11(i-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
            gbr10(i-1,medium) =  gbr1 - gbr11(i-1,medium)*gle;
            gbr21(i-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
            gbr20(i-1,medium) =  gbr2 - gbr21(i-1,medium)*gle;
            cohe1(i-1,medium) = (cohe - cohe_old)*ge1(medium);
            cohe0(i-1,medium) =  cohe - cohe1(i-1,medium)*gle;
"Ali:photonuc, 2 lines"
            photonuc1(i-1,medium) = (photonuc - photonuc_old)*ge1(medium);
            photonuc0(i-1,medium) =  photonuc - photonuc1(i-1,medium)*gle;
        ]
        gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohe_old = cohe;
"Ali:photonuc, 1 line"
        photonuc_old = photonuc;
    ]

    gmfp1(nge,medium) = gmfp1(nge-1,medium);
    gmfp0(nge,medium) = gmfp - gmfp1(nge,medium)*gle;
    gbr11(nge,medium) = gbr11(nge-1,medium);
    gbr10(nge,medium) = gbr1 - gbr11(nge,medium)*gle;
    gbr21(nge,medium) = gbr21(nge-1,medium);
    gbr20(nge,medium) = gbr2 - gbr21(nge,medium)*gle;
    cohe1(nge,medium) = cohe1(nge-1,medium);
    cohe0(nge,medium) = cohe - cohe1(nge,medium)*gle;
"Ali:photonuc, 2 lines"
    photonuc1(nge,medium) = photonuc1(nge-1,medium);
    photonuc0(nge,medium) = photonuc - photonuc1(nge,medium)*gle;

    $egs_info('(a)','OK');
]

close(photo_unit); close(pair_unit);
close(triplet_unit); close(rayleigh_unit);
"Ali:photonuc, 1 line"
IF( iphotonuc = 1 ) [ close(photonuc_unit);]
IF( ibcmp(1) > 1 ) [ close(compton_unit);]
IF( out = 1 )      [ close(ounit); ]
return;

:no-user-data-file:;
$egs_fatal('(//a,a)','Failed to open data file ',$cstring(tmp_string));

return; end;

/*********************************************************************/
subroutine egs_init_rayleigh(medium,sig_rayleigh);
/*********************************************************************
 This routine is called after Rayleigh data has been read from one of
 the available data bases (si, xcom, epdl). Therefore total Rayleigh
 xsections are already available. Here one reads in either custom FF
 for a medium or builds the FF using the atomic FF (default) and the
 IAM (Independent Atom Model). The total Rayleigh xsection must also
 be calculated for the media with user-supplied FF.
 *********************************************************************/
$IMPLICIT-NONE;
$declare_max_medium;
;COMIN/THRESH,          "for threshold energies"
       EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
       rayleigh_inputs,rayleigh_sampling/;

$REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
$REAL xsc, fsc;
$REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
$REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
$REAL totRayleigh2,pzmin;
$REAL emin, emax;
$INTEGER i,j,k,ff_unit, egs_get_unit, ne;
$INTEGER lnblnk1, EOF, nff, medium, ncustom;
character dummy*24, afac_file*128, ff_file*128;

IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"

/*****************************************************************
   Figure out if custom ff needed for medium: check that medium
   is in the list iray_ff_media, else the default atomic ff used.
   This used to be done in subroutine get_transport_parameter
   but was moved here, since it is up to the the user-code to
   read in the information and it is not ensured that the media
   information will be read before getting the transport parameters.
****************************************************************/
ncustom=0;write(dummy,'(24a1)')(media(j,medium),j=1,24);ff_file=' ';
DO i=1,$MXMED[IF(lnblnk1(iray_ff_file(i))~=0)[ncustom = ncustom + 1;]]
DO i=1,ncustom[IF (dummy(:lnblnk1(dummy)) = iray_ff_media(i))[
   ff_file = iray_ff_file(i);
];]

/* Open a fortran unit for reading form factors */
ff_unit = egs_get_unit(0);
IF( ff_unit < 1 ) [
   $egs_fatal(*,
   'egs_init_rayleigh: failed to get a free Fortran I/O unit');
]

/***********************************************************
   Read the FF and calculate the xsections for the custom FF
   or calculate the FF for a molecule using the IAM in the
   atomic case.
 ***********************************************************/
IF ( lnblnk1(ff_file) > 0) ["custom FF requested"
     open(ff_unit,file=$cstring(ff_file),
          status='old',err=:no-ff-file:);
     GOTO :read-ff:;
     :no-ff-file:
     $egs_fatal('(2a)','egs_init_rayleigh: failed to open custom ff file ',
             $cstring(ff_file));
     :read-ff:
     $egs_info('(/2a)','Opened custom ff file ',$cstring(ff_file));
     " read Rayleigh molecular form factor data from a file"
     " which is given as Fmol/sqrt(MW) hence no need to compute"
     " MW to get the xsections in cm-1. See conv variable below"
     j = 0;
     LOOP [
       j = j + 1;
       read(ff_unit,*,IOSTAT = EOF) xsc, fsc;
       IF (EOF < 0) EXIT;
       IF (j <= $MXRAYFF)[xgrid(j,medium)=xsc;ff(j,medium)=fsc;]
     ] REPEAT
     nff = j-1;
     IF (nff > $MXRAYFF)[
        $egs_fatal('(a,/,a,i5,a,i5,/,a)',
        'subroutine egs_init_rayleigh: form factors size too small!!',
        '$XRAYFF =  ', $MXRAYFF,', and need to be ',nff,
        ' and try again!!!');
     ]
     "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
     "and much less for higher energies"
     IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
     write(*,*) '\n  -> ', nff, ' values of mol. ff read!';
     /* Now calculate Rayleigh xsections */
     "Since MW already included in the molecular FF,"
     "must multiply by sumA which is MW for compound"
     "or unity for mixtures."
     sumA = 0.0;
     DO j=1,nne(medium)[sumA=sumA+PZ(medium,j)*WA(medium,j);]
     DO j=1,MGE(medium) [
       gle=(j-GE0(medium))/GE1(medium);e=exp(gle);
       sig_rayleigh(j)=egs_rayleigh_sigma(medium,e,nff,
                       xgrid(1,medium),ff(1,medium))*sumA;
     ]
]
ELSE[
     $set_string(afac_file,' ');
     afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
     open(ff_unit,file=$cstring(afac_file),
       status='old',err=:no-afac-file:);
     GOTO :read-afac:;
     :no-afac-file:
     $egs_fatal('(2a)','egs_init_rayleigh: failed to open atomic ff file',
             $cstring(afac_file));
     :read-afac:
     " read Rayleigh atomic form factor data from a file"
     read(ff_unit,*) xval, aff;
     "calculate form factor using independent atom model"
     DO i=1,$MXRAYFF[
       ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
       DO j=1,nne(medium)[
        ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
       ]
       ff(i,medium) = sqrt(ff(i,medium));
     ]
     nff = $MXRAYFF;
     "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
     "and much less for higher energies"
     IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
     $egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');
]
close(ff_unit);
/* call routine for preparing sampling data */
/* The following is inconsistent with the $SET INTERVAL macro. IK, July 21 2009
   This is because the actual min/max energy of the interpolation
   grid coming from PEGS might be lower/higher than ap/up.
   The medium specific constants ge0(medium) and ge1(medium) come
   from PEGS => one has to use those to find the actual emin/emax.
   If not done that way, the tabulated data will be inconsistent
   with the $SET INTERVAL macro.
call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
                             mge(medium),ap(medium),up(medium),
                             pe_array(1,medium),$RAYCDFSIZE,
                             fcum(1,medium),i_array(1,medium),
                             b_array(1,medium),c_array(1,medium));
*/
emin = exp((1 - ge0(medium))/ge1(medium));
emax = exp((mge(medium) - ge0(medium))/ge1(medium));
call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
                             mge(medium),emin,emax,
                             pe_array(1,medium),$RAYCDFSIZE,
                             fcum(1,medium),i_array(1,medium),
                             b_array(1,medium),c_array(1,medium));

/* prepare coefficients for pmax interpolation */
ne=MGE(medium);dle=log(up(medium)/ap(medium))/(ne-1);
dlei=1/dle;
DO i=1,ne-1 [
   /*  The stuff below is inconsistent with the
       $SET INTERVAL macro (see above) IK, July 21 2009
   gle = log(ap(medium)) + dle*(i-1);
   pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*dlei;
   pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
   */
   gle = (i - ge0(medium))/ge1(medium);
   pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
   pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
]
pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);

return; end;

/*********************************************************************/
subroutine egs_init_rayleigh_sampling(medium);
/*********************************************************************
 This routine is called from HATCH if user requested to use the photon
 xsection data from the pegs4 file. Here one reads in atomic FF and
 builds the FF using the IAM (Independent Atom Model).
 *********************************************************************/
$IMPLICIT-NONE;
$declare_max_medium;
;COMIN/THRESH,          "for threshold energies"
       EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
       rayleigh_inputs,rayleigh_sampling/;

$REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
$REAL xsc, fsc;
$REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
$REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
$REAL totRayleigh2,pzmin;
$REAL emin, emax;
$INTEGER i,j,k,ff_unit, egs_get_unit, ne;
$INTEGER lnblnk1, EOF, nff, medium, ncustom;
character dummy*24, afac_file*128, ff_file*128;

IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"

/* Open a fortran unit for reading form factors */
ff_unit = egs_get_unit(0);
IF( ff_unit < 1 ) [
   $egs_fatal(*,
   'egs_init_rayleigh: failed to get a free Fortran I/O unit');
]

$set_string(afac_file,' ');
afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
open(ff_unit,file=$cstring(afac_file),status='old',err=:no-afac-file:);
GOTO :read-afac:;
:no-afac-file:
$egs_fatal('(2a)',
        'egs_init_rayleigh_sampling: failed to open atomic ff file ',
        $cstring(afac_file));
:read-afac:
" read Rayleigh atomic form factor data from a file"
read(ff_unit,*) xval, aff;
"calculate form factor using independent atom model"
DO i=1,$MXRAYFF[
  ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
  DO j=1,nne(medium)[
   ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
  ]
  ff(i,medium) = sqrt(ff(i,medium));
]
nff = $MXRAYFF;
"To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
"and much less for higher energies"
IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
"write(*,*) '\n  -> ', nff, ' atomic ff values computed!';
$egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');

close(ff_unit);
/* call routine for preparing sampling data */
emin = exp((1 - ge0(medium))/ge1(medium));
emax = exp((mge(medium) - ge0(medium))/ge1(medium));
call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
                             mge(medium),emin,emax,
                             pe_array(1,medium),$RAYCDFSIZE,
                             fcum(1,medium),i_array(1,medium),
                             b_array(1,medium),c_array(1,medium));

/* prepare coefficients for pmax interpolation */
ne=MGE(medium);
DO i=1,ne-1 [
   gle = (i - ge0(medium))/ge1(medium);
   pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
   pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
]
pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);

return; end;

/**********************************************************
   Analytic expression of the Rayleigh xsection in barns.
 **********************************************************/
$REAL function egs_rayleigh_sigma(imed,E,ndat,x,f);
$IMPLICIT-NONE;
$INTEGER i, j, k,imed, ndat;
$REAL hc2,conv,b,hc;
parameter (hc  = 0.0123984768438,  "[Armstrong]*[MeV]"
           hc2 = 0.0001537222280); "h*c squared"
$REAL x($MXRAYFF), f($MXRAYFF), zero, E, xmax;
real*8 x1,x2,pow_x1,pow_x2,raysig,C,C2,f1,f2;
C=2.*hc2/(E*E);C2=C*C;xmax=E/hc;
egs_rayleigh_sigma = 0.0;
DO i=1,ndat-1[
   IF (x(i) = 0.0) x(i) = zero();IF (x(i+1) = 0.0) x(i+1) = zero();
   IF (f(i) = 0.0) f(i) = zero(); IF (f(i+1) = 0.0) f(i+1) = zero();
   b = log(f(i+1)/f(i))/log(x(i+1)/x(i));
   x1=x(i);x2=x(i+1);IF(x2 > xmax) [x2=xmax;]
   pow_x1=x1**(2*b);pow_x2=x2**(2*b);
   raysig = pow_x2*(x2**2/(b+1)-(C*x2**4)/(b+2)+(C2*x2**6)/(2*b+6));
   raysig = raysig - pow_x1*(x1**2/(b+1)-(C*x1**4)/(b+2)+(C2*x1**6)/(2*b+6));
   raysig = raysig*f(i)*f(i)/pow_x1;
   egs_rayleigh_sigma = egs_rayleigh_sigma + raysig;
   IF(x(i+1)>xmax)[EXIT;]"exit loop"
]
/*totRayleigh = 2.*Pi*R02*1E24*C*totRayleigh;"in barns"
 2*Pi*Ro^2*1E24 = 0.49893439187842413747
 */
egs_rayleigh_sigma = 0.49893439187842413747*C*egs_rayleigh_sigma;"in barns"
return;
end;
/******************************************************
   Rayleigh run time sampling routine
 *******************************************************/
subroutine egs_rayleigh_sampling(medium,e,gle,lgle,costhe,sinthe);
$IMPLICIT-NONE;
$declare_max_medium;
real*8 e;
$REAL gle,costhe,sinthe,pmax,xv,xmax,csqthe;
$REAL rnnray1,rnnray0,hc_i,twice_hc2,dwi;
parameter(hc_i=80.65506856998,      "h*c inverse"
          twice_hc2=0.000307444456);"2*(hc)^2"
          "h*c=0.0123984768438 [Armstrong]*[MeV]"
$INTEGER lgle,ib,ibin,medium, trials;
;COMIN/RANDOM,rayleigh_sampling/;
dwi = $RAYCDFSIZE-1;
$EVALUATE pmax USING pmax(gle);xmax = hc_i*e;
LOOP [
    $RANDOMSET rnnray1;
    LOOP [
        $RANDOMSET rnnray0; rnnray0 = rnnray0*pmax;
        ibin = 1 + rnnray0*dwi; /* rnno = rnno + 1 - ibin; */
        ib = i_array(ibin,medium);
        IF( i_array(ibin+1,medium) > ib ) [
          LOOP [IF(rnnray0<fcum(ib+1,medium)) EXIT; ib=ib+1;]
        ]
        rnnray0 = (rnnray0 - fcum(ib,medium))*c_array(ib,medium);
        xv = xgrid(ib,medium)*exp(log(1+rnnray0)*b_array(ib,medium));
    ] UNTIL (xv < xmax);
    xv = xv/e;
    costhe = 1 - twice_hc2*xv*xv;csqthe=costhe*costhe;
] UNTIL ( 2*rnnray1 < 1 + csqthe );
sinthe=sqrt(1.0-csqthe);
return;
end;
/******************************************************
   Prepares Rayleigh run time sampling data
 *******************************************************/
subroutine prepare_rayleigh_data(ndat,x,f,
                                 ne,emin,emax,pe_array,
                                 ncbin,fcum,i_array,
                                 b_array,c_array);
$IMPLICIT-NONE;

/******* input F (form factor) data ********************************/
$INTEGER    ndat;         " number of F data points "
$REAL       x(ndat),      " x values of F data "
            f(ndat);      " F data "

/******* energy range to initialize ********************************/
$INTEGER    ne;           " number of energy bins "
$REAL       emin,         " minimum photon energy (i.e. AP(medium))"
            emax,         " maximum photon energy (i.e. UP(medium))"
            pe_array(ne); " integral over F^2 from 0 to xmax(E)    "
                          " i.e., pe_array(E) = fcum(xmax(E))      "


/******* cumulative distribution **********************************/
$INTEGER    ncbin;          " number of cumulative bins (input)"
$REAL       fcum(ndat);     " cumulative distribution (output)"
$INTEGER    i_array(ncbin); " original data bin in which the i'th "
                            " cumulative bin edge falls.          "

/******* sampling data ********************************************/
$REAL       b_array(ndat),  " F interpolation coefficient "
            c_array(ndat);  " needed for sampling at run time "

$REAL zero;

real*8 sum0,a,b,x1,x2,pow_x1,pow_x2,dle,e,xmax,
       anorm,anorm1,anorm2,w,dw,xold,t,aux;
$INTEGER i,j,k,ibin;

;COMIN/USEFUL/;

write(*,'(a$)') '      preparing data for Rayleigh sampling ... ';

/* this to avoid NAN in the log(f(i)) below */
DO i=1,ndat [IF (f(i) = 0.0) f(i) = zero();]

/**********************************************************
 *
 * Calculate the cumulative distribution
 *
 *********************************************************/
sum0=0; fcum(1)=0;
DO i=1,ndat-1 [
    b = log(f(i+1)/f(i))/log(x(i+1)/x(i)); b_array(i) = b;
    x1 = x(i); x2 = x(i+1);
    pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
    sum0=sum0+f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
    fcum(i+1) = sum0;
]

/*************************************************************
 *
 * Now the maximum cumulative probability as a function of
 * incident photon energy. We have xmax = 2*E*20.60744/m, so
 * pe_array(E) = fcum(xmax)
 *
 **************************************************************/
dle = log(emax/emin)/(ne-1); i = 1;
DO j=1,ne [
    e = emin*exp(dle*(j-1)); xmax = 20.607544d0*2*e/prm;
    DO k=i,ndat-1 [
        IF( xmax >= x(k) & xmax < x(k+1) ) EXIT;
    ]
    i = k; b = b_array(i);
    x1 = x(i); x2 = xmax;
    pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
    pe_array(j) = fcum(i) +
      f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
]
i_array(ncbin) = i;

/***********************************************************************
 *
 * Now renormalize data so that pe_array(emax)=1
 * Note that we make pe_array(j) slightly larger so that fcum(xmax) is
 * never underestimated when interpolating
 *
 ***********************************************************************/
anorm = 1d0/sqrt(pe_array(ne));
anorm1 = 1.005d0/pe_array(ne);
anorm2 = 1d0/pe_array(ne);
DO j=1,ne [
    pe_array(j) = pe_array(j)*anorm1;
    IF( pe_array(j) > 1 ) pe_array(j) = 1;
]
DO j=1,ndat [
    f(j) = f(j)*anorm; fcum(j) = fcum(j)*anorm2;
    c_array(j) = (1+b_array(j))/(x(j)*f(j))**2;
]

/***********************************************************************
 *
 * Now prepare uniform cumulative bins
 *
 ***********************************************************************/
dw = 1d0/(ncbin-1);
xold = x(1); ibin = 1;
b = b_array(1);
pow_x1 = x(1)**(2*b);
i_array(1) = 1;
DO i=2,ncbin-1 [
    w = dw;
    LOOP [
        x1 = xold; x2 = x(ibin+1);
        t = x1*x1*x1**(2*b);
        pow_x2 = x2**(2*b);
        aux=f(ibin)*f(ibin)*(x2*x2*pow_x2-t)/((1+b)*pow_x1);
        IF( aux > w ) [
            xold = exp(log(t+w*(1+b)*pow_x1/f(ibin)/f(ibin))/(2+2*b));
            i_array(i) = ibin;
            EXIT;
        ]
        w = w - aux; xold = x2; ibin = ibin+1;
        b = b_array(ibin); pow_x1 = xold**(2*b);
    ]
]

/*************************************************************************
 *
 * Change definition of b_array because that's what is needed at run time
 *
 **************************************************************************/
DO j=1,ndat [ b_array(j) = 0.5/(1 + b_array(j)); ]


write(*,'(a /)') 'done';

return; end;

"============================================================================="
$REAL function egs_KN_sigma0(e);
"=========================================================================="
implicit none;
$REAL    e;
$REAL    con,ko,c1,c2,c3,eps1,eps2;
data     con/0.1274783851/;
;COMIN/USEFUL/;
ko = e/prm;
IF( ko < 0.01 ) [
    egs_KN_sigma0 = 8.*con/3.*(1-ko*(2-ko*(5.2-13.3*ko)))/prm;
    return;
]
c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
eps2 = 1; eps1 = 1./(1+2*ko);
egs_KN_sigma0 = (c1*(1./eps1-1./eps2)+c2*log(eps2/eps1)+eps2*(c3+0.5*eps2)-
                eps1*(c3+0.5*eps1))/e*con;
return; end;

"============================================================================="
$REAL function egs_KN_sigma1(e);
"=========================================================================="
implicit none;
$REAL    e;
$REAL    con,ko,c1,c2,c3,eps1,eps2;
data     con/0.1274783851/;
;COMIN/USEFUL/;
ko = e/prm; c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
eps2 = 1; eps1 = 1./(1+2*ko);
egs_KN_sigma1 = c1*(1./eps1-1./eps2);
egs_KN_sigma1 = egs_KN_sigma1 + log(eps2/eps1)*(c2 - c1) - c2*(eps2-eps1);
egs_KN_sigma1 = egs_KN_sigma1 + c3*(eps2-eps1)*(1-0.5*(eps1+eps2));
egs_KN_sigma1 = egs_KN_sigma1 +
         (eps2-eps1)*(0.5*(eps1+eps2)-(eps1*eps1+eps2*eps2+eps1*eps2)/3);
egs_KN_sigma1 = egs_KN_sigma1*con;
return; end;

"============================================================================="
subroutine egsi_get_data(flag,iunit,n,ne,zsorted,pz_sorted,ge1,ge0,data);
"=========================================================================="
implicit none;
COMIN/EGS-IO/;
$REAL    eth;
$INTEGER flag,iunit,n,ne;
$REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
$REAL    etmp($MXINPUT),ftmp($MXINPUT);
$REAL    gle,sig,p,e;
$INTEGER i,j,k,kk,iz,iz_old,ndat,iiz;

;COMIN/USEFUL/;

"Ali:photonuc. The whole routine is commented out and re-written
"to accommodate reading photonuclear cross sections. A copy of the
"commented original routine is at the bottom.
" flag = 0: photoelectric, Rayleigh, Compton
" flag = 1: pair
" flag = 2: triplet
" flag = 3: photonuclear

rewind(iunit);
iz_old = 0;
DO k=1,n [ data(k) = 0; ]
DO i=1,ne [
    iiz = int(zsorted(i)+0.5);
    DO iz=iz_old+1,iiz [
        read(iunit,*,err=:user-data-failure:) ndat;
        IF( ndat > $MXINPUT ) [
            $egs_fatal(*,'Too many input data points. Max. is ',$MXINPUT);
        ]
        IF( flag = 0 | flag = 3) [
            read(iunit,*,err=:user-data-failure:) (etmp(k),ftmp(k),k=1,ndat);
        ]
        ELSE [
            read(iunit,*,err=:user-data-failure:) (etmp(k+1),ftmp(k+1),
                k=1,ndat);
            IF( flag = 1 ) [ eth = 2*rm; ] ELSE [ eth = 4*rm; ]
            ndat = ndat + 1;
            DO k=2,ndat [
                ftmp(k) = ftmp(k) - 3*log(1-eth/exp(etmp(k)));
            ]
            ftmp(1) = ftmp(2); etmp(1) = log(eth);
        ]
    ]
    iz_old = iiz;
    DO k=1,n [
        gle = (k - ge0)/ge1; e = exp(gle);
        IF( gle < etmp(1) | gle >= etmp(ndat) ) [
            IF( flag = 0 ) [
                $egs_fatal(*,'Energy ',exp(gle),
                   ' is outside the available data range of ',
                   exp(etmp(1)),exp(etmp(ndat)));
            ]
            ELSEIF (flag = 1 | flag = 2) [
                IF( gle < etmp(1) ) [ sig = 0; ]
                ELSE [ sig = exp(ftmp(ndat)); ]
            ]
            ELSE [ "photonuclear, zero it before and after
             sig = 0;
            ]
        ] ELSE [
            DO kk=1,ndat-1 [
                IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
            ]
            IF( flag ~= 3) ["log/log interpolation"
               p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
               sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
            ]
            ELSE["lin/lin interpolation for photonuc"
               p = (e - exp(etmp(kk)))/(exp(etmp(kk+1)) - exp(etmp(kk)));
               sig = p*exp(ftmp(kk+1)) + (1-p)*exp(ftmp(kk));
            ]
        ]
        IF( (flag = 1 | flag = 2) & e > eth ) sig = sig*(1-eth/e)**3;
        data(k) = data(k) + pz_sorted(i)*sig;
    ]
]

return;

:user-data-failure:;
$egs_fatal(*,'Error while reading user photon cross sections from unit ',
     iunit);

return; end;

/*****************************************************************
   Prepare photoelectric cross section data base for medium imed
   on same energy grid as for the other photon interactions.
   Normalize elemental PE cross sections to medium cross section
   to use for selecting element the photon interacts with.
 *****************************************************************/
"============================================================================="
subroutine egsi_get_shell_data(imed,n,ne,zsorted,pz_sorted,ge1,ge0,data);
"=========================================================================="
implicit none;
$declare_max_medium;
;COMIN/EGS-IO,BREMPR,USEFUL,MEDIA,PE-SHELL-DATA/;
$INTEGER n,   "number of data points requested"
         ne,  "number of elements in medium"
         ndat;"number of data points from original grid"
$REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
$REAL    sigma($MXNE),sigmaMedium;
"$INTEGER sorted(*);
real*4    etmp($MXINPUT),ftmp($MXINPUT);
real*4    gle,sig,p;
$INTEGER i,j,k,kk,iz,zpos,imed;

DO k=1,n  [ data(k)  = 0;]
DO k=1,ne [ sigma(k) = 0;]
DO i=1,ne [
    iz = int(zsorted(i)+0.5);
    zpos = pe_zpos(iz); ndat = pe_nge(zpos);
    "Total cross sections for a given element"
    "on initial energy grid"
    DO k=1,ndat[
       pe_elem_prob(k,i,imed) = pz_sorted(i)*pe_xsection(k,zpos,0);
       "etmp(k) = log(pe_energy(k,zpos)); Done in egs_read_shellwise_pe
       etmp(k) = pe_energy(k,zpos);
       ftmp(k) = log(pe_xsection(k,zpos,0));
    ]
    "Total cross sections for a given element"
    "on requested energy grid"
    DO k=1,n [
        gle = (k - ge0)/ge1;
        IF( gle < etmp(1) | gle >= etmp(ndat) ) [
            $egs_fatal(*,'egsi_get_shell_data: Energy ',exp(gle),
                         ' is outside the available data range of ',
                         exp(etmp(1)),exp(etmp(ndat)));
        ] ELSE [
            "Find energy interval gle falls in"
            DO kk=1,ndat-1 [
                IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
            ]
            "log/log interpolation"
            p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
            sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
        ]
        data(k) = data(k) + pz_sorted(i)*sig;
        "data(k) = data(k) + pz(imed,sorted(i))*sig;
    ]
]
"Normalize elemental cross section to medium cross section"
"Prepare for log/log interpolation"
DO i=1,ne [
   iz = int(zsorted(i)+0.5);
   zpos = pe_zpos(iz); ndat = pe_nge(zpos);
   DO k=1,ndat[
      sig = sigmaMedium(imed,pe_energy(k,zpos));
      pe_elem_prob(k,i,imed) = log(pe_elem_prob(k,i,imed)/sig);
   ]
]

return; end;

/***************************************************************
   Calculate photoelectric cross section for medium imed using
   log/log linear interpolation and binary search to find energy
   interval
 ***************************************************************/
$REAL function sigmaMedium(imed, logE);

implicit none;
$declare_max_medium;
;COMIN/BREMPR,PE-SHELL-DATA/;
$REAL logE, slope, sigma;
$INTEGER k,imed,Z,zpos,m,ibsearch;

sigmaMedium = 0;
DO k=1,nne(imed) [
   Z = int( zelem(imed,k) + 0.5 );zpos = pe_zpos(Z);
   m = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
   slope = log(pe_xsection(m+1,zpos,0)/pe_xsection(m,zpos,0));
   slope = slope/(pe_energy(m+1,zpos)-pe_energy(m,zpos));
   sigma = log(pe_xsection(m,zpos,0));
   sigma += slope*(logE - pe_energy(m,zpos));
   sigma = exp(sigma);
   sigmaMedium += pz(imed,k)*sigma;
]
return; end;

"============================================================================="
subroutine egs_heap_sort(n,rarray,jarray);
"************************************************************************
"  egs_heap_sort will sort the real array rarray of dimension n in
"  ascending order and at the same time put into the integer array
"  jarray the original position of the elements, e.g.
"  if rarray was on input (5,14,8,2), it will be after completion
"  of heap_sort (2,5,8,14) and jarray will be (4,1,3,2).
"  heap_sort uses the heap sort algorithm, the implementation is
"  based  on hpsort from Numerical Recipies with a couple of
"  modifications.
"
"  Iwan Kawrakow, NRC, July 2001
"*************************************************************************

implicit none;

$INTEGER n,jarray(*);
$REAL    rarray(*);
$INTEGER i,ir,j,l,ira;
$REAL    rra;

DO i=1,n [ jarray(i)=i; ]
IF (n < 2) return;
l=n/2+1; ir=n;

LOOP [
   IF (l > 1)  [
       l=l-1; rra=rarray(l); ira=l;
   ]
   ELSE [
       rra=rarray(ir); ira=jarray(ir);
       rarray(ir)=rarray(1); jarray(ir)=jarray(1);
       ir=ir-1;
       IF (ir = 1) [
           rarray(1)=rra; jarray(1)=ira; return;
       ]
   ]
   i=l; j=l+l;
   LOOP [
       IF( j > ir ) EXIT;
       IF (j < ir) [ IF (rarray(j) < rarray(j+1) ) j=j+1; ]
       IF (rra < rarray(j)) [
           rarray(i)=rarray(j); jarray(i)=jarray(j);
           i=j; j=j+j;
       ] ELSE [ j=ir+1; ]
   ]
   rarray(i)=rra; jarray(i)=ira;
]
return; end;

%E
"Ali:photonuc, 1 subroutine"
"******************************************************************"
SUBROUTINE PHOTONUC;
"******************************************************************"
" Placeholder for photonuclear modelling. Currently the photon is
" discarded and its energy is thrown away (i.e. not deposited).
"******************************************************************"
$IMPLICIT-NONE;
$COMIN-PHOTONUC; "current default replacement is:
                 "COMIN/STACK,EPCONT,USEFUL/"
$DEFINE-LOCAL-VARIABLES-PHOTONUC; "currently empty"

npold = np; "set the old stack counter"
edep = pzero; e(np) = pzero; wt(np) = 0;

return;
end;
"******************************************************************"

%%
