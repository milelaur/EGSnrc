      implicit none
      integer*8 ITEMP,NOSCAT,INOMSD
      integer*4 itmax,IORSTRT,i,ix,iz,it,ib,NBATCH,irl,izd,ixd,j,MEDNUM,
     * LGLE,ISUMX,jj,IBATCH,IBTCH,ICASE,ipk,ICUM, IDSMAX,NDATA,IERR,I1,I
     *2,I3,NETADJ,ISTAT
      real*8 DEPTH,VOLUME,RLOW2, PATHL,DELTAP,COHFAC,EK0,TIMEB,TIMCPU,BA
     *TCHT, TDSMAX,TDOS,TDOS2,RATIO,ETIMETOT, TEMP1,TEMP2,FMASS,aux
      integer*4 IRIN,NRCFLG
      real*8 EI,XIN,YIN,ZIN,UIN,VIN,WIN,WEIGHT
      INTEGER MAKE_IT_AN_INT,JTEMP
      CHARACTER*80 TEXT
      integer*8 JCASE
      real CPUT0,CPUT1,CPUT2,TDUM
      real egs_tot_time, egs_etime
      real*8 GWATE(60)
      real*8 SCORE_NORM_NUM, SCORE_TEMP
      REAL*8 SCORE_TEMP2
      COMMON/BOUNDS/ECUT( 12001),PCUT( 12001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      CHARACTER*4 BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,
     *SCHAR, TCHAR,UCHAR,VCHAR
      COMMON/CHARS/ BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHA
     *R,SCHAR,TCHAR,UCHAR,VCHAR
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      CHARACTER*4 CDSTBL( 12001),CTRTBL( 12001),CABSRB( 12001)
      COMMON/GEOM/ZPLANE( 201),RCYL(0:60), CYRAD2( 61), NZ,NR,NREG,NDOSE
     *,NZDOSE,NRDOSE,NPLANE, NZDMIN,NZDMAX,NRDMIN,NRDMAX, NTRACK( 12001)
     *,CDSTBL,CTRTBL,CABSRB,IDSTBL( 12001,2)
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,NZDMIN,NZDMAX,NRDM
     *IN,NRDMAX, NTRACK,IDSTBL
      CHARACTER*1 TITLE(80)
      COMMON/IODAT1/TITLE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(200,60),TMCPUO,TIMMAX,ST
     *ATLM,EIN,EKMAX, IDAT,IRESTART,IQIN,NESTEP,NSMAX,IXXIN,JXXIN,IVAL,D
     *ATCOUNT
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN,EKMAX
      integer*4 IDAT,IRESTART,IQIN,NESTEP,NSMAX, IXXIN,JXXIN,IVAL,DATCOU
     *NT
      integer*8 NCASE,NCASEO,NCASET
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/NRCNEW/NEWNRC,DECISION
      integer*4 NEWNRC,DECISION
      COMMON/PHOTIN/ EBINDA(10), GE0(10),GE1(10), GMFP0(2000,10),GMFP1(2
     *000,10),GBR10(2000,10),GBR11(2000,10),GBR20(2000,10),GBR21(2000,10
     *), RCO0(10),RCO1(10), RSCT0(100,10),RSCT1(100,10), COHE0(2000,10),
     *COHE1(2000,10),  PHOTONUC0(2000,10),PHOTONUC1(2000,10), DPMFP, MPG
     *EM(1,10), NGR(10)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/PLOTC/ IPLOTR(60),IPLOTZ(200),IOPLOT,IPLTLP,IPLTPL,IPLPHB,N
     *PLOTR,NPLOTZ
      integer*4 IPLOTR,IPLOTZ,IOPLOT,IPLTLP,IPLTPL,IPLPHB,NPLOTR,NPLOTZ
      COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE
      integer*4 ICHPIN,ILPIN,IOUT,IPAGE
      LOGICAL RUSROU
      COMMON/RUSROU/RRZ,RRCUT,RUSROU
      real*8 RRZ,RRCUT
      COMMON/SCORE/ SCDOSE(200,60,7),SCDOSE2(200,60,7), SCKERMA(200,60,7
     *),SCKERMA2(200,60,7), SCDOSEtoKERMA2(200,60,7),SCPDST(500),SCPDST2
     *(500), SCPCUM(500),SCPCUM2(500),SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCD
     *FBK(4),SCDFBK2(4),SCDFEP(4),SCDFEP2(4),SCDFDIFF(4),SCDFDIFF2(4), S
     *CSTP,SCSTP2,SCDSTP,SCDSTP2, PIISTP, SCSTP_LAST, SCDSTP_LAST,SCDOSE
     *_LAST(200,60,7), SCKERMA_LAST(200,60,7), SCKERMA_LASTOLD(200,60,7)
     *,SCPDST_LAST, IHSTRY, DFEN(4,4), PHENER,WT1OLD,BINTOP(500),SLOTE,D
     *ELTAE, SCDOSE_TMP(200,60,7), SCKERMA_TMP(200,60,7), SCKERMA_TMPOLD
     *(200,60,7), SCSTP_TMP,SCDSTP_TMP, MXNP,IFULL,ISTORE,IKERMA, IWATCH
     *,IOOPTN,IOUTSP, IPHR( 12001),MAXBIN,NCOMPT,during_pe_compt,during_
     *eii
      real*8 SCDOSE,SCDOSE2,SCKERMA,SCKERMA2,SCDOSEtoKERMA2,SCPDST,SCPDS
     *T2, SCPCUM,SCPCUM2,SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCDFBK,SCDFBK2,S
     *CDFEP,SCDFEP2,SCDFDIFF,SCDFDIFF2, SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIIS
     *TP
      integer*8 SCSTP_LAST, SCDSTP_LAST, SCDOSE_LAST, SCKERMA_LAST, SCKE
     *RMA_LASTOLD,SCPDST_LAST, IHSTRY
      real*8 DFEN, PHENER,WT1OLD,BINTOP,SLOTE,DELTAE, SCDOSE_TMP,SCKERMA
     *_TMP,SCKERMA_TMPOLD,SCSTP_TMP,SCDSTP_TMP
      integer*4 MXNP,IFULL,ISTORE,IKERMA, IWATCH,IOOPTN,IOUTSP, IPHR,MAX
     *BIN,NCOMPT,during_pe_compt,during_eii
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(100,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBE
     *AM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,
     *DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,P
     *ROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,
     *ZSOFST,                                                      SVTMP
     *1,SVTMP2,SVTMP3,SVTMP4,
     *         RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                       XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,W
     *EIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/SPECTR/ CDFINV(1000,2),ENSRCD(0:300),SRCPDF(300),SRCCDF(300
     *), NENSRC
      integer*4 NENSRC
      real*8 CDFINV,ENSRCD,SRCPDF,SRCCDF
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERRR/ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN, MINZ,MAXZ,MINR,MAXR
     *,IREJCT
      real*8 ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN
      integer*4 MINZ,MAXZ,MINR,MAXR,IREJCT
      COMMON/USERMI/EXPMFP,GWTOLD,ICSDA
      integer*4 ICSDA
      real*8 EXPMFP,GWTOLD
      COMMON/USERVR/ CEXPTR,GWAIT,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,
     *IQINC,MONOEN, cs_enhance,cs_enhance_current,ienhance,iefl( 12001),
     *ics_enhance, do_fast_step
      integer*4 ienhance,iefl,ics_enhance, IFORCE,NFMIN,NFMAX,NFTIME,ISO
     *URC,IFPB,IQINC,MONOEN
      real*8 CEXPTR,GWAIT,cs_enhance,cs_enhance_current
      logical do_fast_step
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      COMMON/RWPHSP/ STRING_TEMP_ZLAST_OUT,  STRING_TEMP_OUT,  IHSTRY_PH
     *SP,   iaea_dummy_long,  NHSTRY_DOS,   ESHORT,  WEIGHTTMP,  WT_PHSP
     *_SHORT,  X_PHSP_SHORT,  Y_PHSP_SHORT,  Z_PHSP_SHORT,  U_PHSP_SHORT
     *,  V_PHSP_SHORT,  W_PHSP_SHORT,  ZLAST_PHSP_SHORT,  MUIDX_PHSP_SHO
     *RT,  EKMAX_PHSP_SHORT,  EKMINE_PHSP_SHORT,  NINC_PHSP_SHORT,  dosx
     *yz2beam_index,  iaea_extra_floats,  NUM_PHSP_TOT,  PHOT_PHSP_TOT,
     *iaea_result,   iaea_n_stat,  iaea_q_typ,  iaea_typ_q,  iaea_q_inde
     *x,  I_PHSP,  IERR_PHSP,  LATCHTMP,  WRITE_PHSP_COUNTER,  WRITE_PHS
     *P_SOFAR,  PHSP_RESTART,  PHSP_RECL,  PHSP_RECL_OLD,  iaea_extra_in
     *ts,  iaea_extra_int_types,iaea_extra_float_types,   iaea_i_zlast,
     * iaea_i_latch,  iaea_i_muidx,  iaea_n_extra_ints,  iaea_n_extra_fl
     *oats,  i_iaea_open_for_write,   iaea_i_zlast_out,  iaea_i_latch_ou
     *t,  iaea_i_muidx_out,  dosxyz2beam_izscore,  MODE_RW
      CHARACTER*32000 STRING_TEMP_ZLAST_OUT(1)
      CHARACTER*28000 STRING_TEMP_OUT(1)
      integer*8 IHSTRY_PHSP(1),iaea_dummy_long,NHSTRY_DOS
      REAL*4 ESHORT,WEIGHTTMP,WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT, Z
     *_PHSP_SHORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,ZLAST_PHSP_SHO
     *RT, MUIDX_PHSP_SHORT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP
     *_SHORT,dosxyz2beam_index, iaea_extra_floats(10)
      INTEGER NUM_PHSP_TOT,PHOT_PHSP_TOT, iaea_result,iaea_n_stat,iaea_q
     *_typ(3),iaea_typ_q(3),iaea_q_index,I_PHSP, IERR_PHSP,LATCHTMP, WRI
     *TE_PHSP_COUNTER(1),WRITE_PHSP_SOFAR(1), PHSP_RESTART,PHSP_RECL,PHS
     *P_RECL_OLD,iaea_extra_ints(10), iaea_extra_int_types(10),iaea_extr
     *a_float_types(10),iaea_i_zlast, iaea_i_latch,iaea_i_muidx,iaea_n_e
     *xtra_ints,iaea_n_extra_floats, i_iaea_open_for_write,iaea_i_zlast_
     *out,iaea_i_latch_out, iaea_i_muidx_out,dosxyz2beam_izscore
      CHARACTER*5 MODE_RW
      INTEGER LATCH_TEMP_OUT,NUM_PHSP_TOFLUSH,TEMP_PHSP_COUNTER,REM_PHSP
      REAL*4 REAL_TEMP_OUT(7)
      CHARACTER*32 REC_TEMP_OUT
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      external combine_results
      integer*4 egs_open_file, egs_open_datfile, rng_unit, data_unit
#define HAVE_C_COMPILER
#ifdef HAVE_C_COMPILER
      real*8 part_dose, part2_dose, current_result, current_uncertainty
      integer*8 n_run,n_tot,n_last
      integer*4 n_job
      logical first_time
#endif
      logical is_finished
      call egs_init
      BLANK=' '
      ASTER='*'
      ACHAR='A'
      BCHAR='B'
      CCHAR='C'
      DCHAR='D'
      ICHAR='I'
      MCHAR='M'
      RCHAR='R'
      SCHAR='S'
      TCHAR='T'
      UCHAR='U'
      VCHAR='V'
      CPUT0=egs_etime()
      WRITE(6,1010)' '
1010  FORMAT(//1x,79('*')/ / 9X,a,$)
      call egs_fdate(6)
      WRITE(6,1020)
1020  FORMAT(//1x,79('*')/)
      WRITE(6,1030)200,60
1030  FORMAT(' *',T34,'************',T80,'*'/ ' *',T34,'*          *',T8
     *0,'*'/ ' *',T34,'* DOSRZnrc *',T80,'*'/ ' *',T34,'*          *',T8
     *0,'*'/ ' *',T34,'************',T80,'*'// '   Developed by National
     * Research Council of Canada',/ '   ',' ',' on ','linux',/ / ' Numb
     *er of planar regions      = ',I3/ ' Number of cylindrical regions=
     * ',I3 /)
      JTEMP = 2*500
      IF ((JTEMP .GT.  12000)) THEN
        WRITE(6,1040)500
1040    FORMAT(///' *********************************************'/ ' Yo
     *u have used such a large value of EBIN(=',I6,' ) that you must use
     *'/ ' the alternative form of the REPLACE {$MXDATA} macro near thet
     *op of'/ ' dosrznrc.mortran and then recompile', ///' *************
     *********************************'///)
        STOP
      END IF
      IOUT=1
      CALL INPUTS
      IF ((ERROR_FLAG.EQ.1)) THEN
        GOTO 1050
      END IF
      IF (( istore .GT. 0 )) THEN
        rng_unit = egs_open_file(2,0,1,'.egsrns')
      ELSE IF(( irestart .EQ. 4 )) THEN
        rng_unit = egs_open_datfile(2,0,1,'.egsrns')
      END IF
      IF (((IFULL.EQ.0).OR.(IFULL.EQ.2).OR.(IFULL.EQ.3))) THEN
        ITMAX=2
      ELSE
        ITMAX=7
      END IF
      IF ((IRESTART.EQ.5)) THEN
        call egs_combine_runs(combine_results,'.egsdat')
        NBATCH=0
        NCASET=NCASEO
      ELSE
        IF ((NCASE/10.EQ.0)) THEN
          NCASE=10
        END IF
        JCASE=NCASE/10
        NCASE=JCASE*10
      END IF
      DECISION=0
      MXNP=0
      IHSTRY=NCASEO
      NHSTRY=0
      IF ((ISOURC.EQ.2)) THEN
        NR=1
        RCYL(1)=1000.
        NREG=NZ+1
        CYRAD2(1)=RCYL(1)**2
      END IF
      NDOSE=NZDOSE*NRDOSE
      IF ((IFULL.EQ.1)) THEN
        ITMAX=7
      ELSE
        ITMAX=2
      END IF
      IF ((IREJCT .EQ. 1)) THEN
        ZMINR=ZPLANE(MINZ)
        ZMAXR=ZPLANE(MAXZ)
        IF ((MINR.EQ.0)) THEN
          RMINR=0.0
        ELSE
          RMINR=RCYL(MINR)
        END IF
        RMAXR=RCYL(MAXR)
      END IF
      CTRTBL(1)=BLANK
      CDSTBL(1)=BLANK
      DO 1061 IZ=1,NZ
        DO 1071 IX=1,NR
          IRL=IZ+NZ*(IX-1)+1
          IZD=IZ+1-NZDMIN
          IXD=IX-NRDMIN
          IF (( (IZD.LE.0).OR. (IZD.GT.NZDOSE).OR. (IXD.LE.0).OR. (IXD.G
     *    T.NRDOSE))) THEN
            CDSTBL(IRL)=BLANK
            IDSTBL(IRL,1)=0
            IDSTBL(IRL,2)=0
            NTRACK(IRL)=0
          ELSE
            CDSTBL(IRL)=DCHAR
            IDSTBL(IRL,1)=IZD
            IDSTBL(IRL,2)=IXD
            NTRACK(IRL)=1
          END IF
          IF (( (IZ.LT.MINZ).OR. (IZ.GE.MAXZ).OR. (IX.LE.MINR).OR. (IX.G
     *    T.MAXR) )) THEN
            CTRTBL(IRL)=BLANK
          ELSE
            CTRTBL(IRL)=TCHAR
          END IF
1071    CONTINUE
1072    CONTINUE
1061  CONTINUE
1062  CONTINUE
      DO 1081 J=1,5
        IAUSFL(J)=1
1081  CONTINUE
1082  CONTINUE
      DO 1091 J=6,35
        IAUSFL(J)=0
1091  CONTINUE
1092  CONTINUE
      IF ((IFULL .EQ. 1 .OR. IFULL .EQ. 3 .OR. IKERMA .EQ. 1)) THEN
        iausfl(6) = 1
        iausfl(17) = 1
        iausfl(18) = 1
        iausfl(19) = 1
        iausfl(20) = 1
        iausfl(21) = 1
        iausfl(10) = 1
        iausfl(35) = 1
        iausfl(32) = 1
        iausfl(33) = 1
      END IF
      IF ((IFULL .EQ. 4)) THEN
        iausfl(8) = 1
      END IF
      IF ((cs_enhance .GT. 1.0001)) THEN
        write(6,*) 'flagged all photon intereaction types'
        iausfl(16) = 1
        iausfl(18) = 1
        iausfl(19) = 1
        iausfl(20) = 1
        iausfl(21) = 1
        iausfl(24) = 1
        iausfl(25) = 1
      ELSE
        DO 1101 j=1, 12001
          iefl(j) = 0
1101    CONTINUE
1102    CONTINUE
      END IF
      DUNIT=1
      WRITE(6,1110)
1110  FORMAT(/' CALL TO HATCH AT  ',$)
      call egs_time(6)
      write(6,*)
      CALL HATCH
      WRITE(6,1120)
1120  FORMAT(/' HATCH COMPLETED AT ',$)
      call egs_time(6)
      write(6,*)
      IF ((MONOEN.EQ.0.AND.ISOURC.NE.21.AND.ISOURC.NE.22.AND.ISOURC.NE.2
     *3)) THEN
        IF ((IQIN.EQ.0)) THEN
          EI=EIN
        ELSE
          EI=EIN+RM
        END IF
        EKMAX=EIN
      ELSE IF((MONOEN.EQ.1)) THEN
        CALL ENSRC1
        EKMAX=ENSRCD(NENSRC)
      ELSE IF((ISOURC.EQ.21.OR.ISOURC.EQ.22)) THEN
        EKMAX=EKSRCM
      END IF
      DO 1131 I=1,NMED
        IF (((EKMAX.GT.UP(I)).OR.(EKMAX.GT.UE(I)-RM))) THEN
          WRITE(6,1140)I,EKMAX,UP(I),UE(I)
1140      FORMAT(//1X,50('*')// ' FOR MEDIUM',I3,' INCIDENT ENERGY=',F10
     *.1,' MeV'/ ' IS GREATER THAN COVERED BY DATA FILE WHERE UP,UE=',2F
     *10.1,' MeV'/ '     EXECUTION WILL TERMINATE AFTER COMPLETION OF IN
     *PUT FILE'// 1X,50('*')//)
          GOTO 1150
        END IF
1131  CONTINUE
1132  CONTINUE
      DO 1161 IZ=1,NZ
        DEPTH=ZPLANE(IZ+1)-ZPLANE(IZ)
        DO 1171 IX=1,NR
          IRL=IZ+NZ*(IX-1)+1
          MEDNUM=MED(IRL)
          IF ((MEDNUM.NE.0)) THEN
            IF (((ISOURC.EQ.2).OR.(ISOURC.EQ.4))) THEN
              VOLUME=DEPTH
            ELSE
              IF ((IX.EQ.1)) THEN
                RLOW2=0.0
              ELSE
                RLOW2=CYRAD2(IX-1)
              END IF
              VOLUME=PI*DEPTH*(CYRAD2(IX)-RLOW2)
            END IF
            AMASS(IZ,IX)=RHOR(IRL)*VOLUME
          ELSE
            AMASS(IZ,IX)=0.0
          END IF
1171    CONTINUE
1172    CONTINUE
1161  CONTINUE
1162  CONTINUE
      CALL SRCOTO(WEIGHT)
      IF (((IFPB.EQ.0).AND.(IFORCE.NE.0).AND.(IQIN.EQ.0).AND.(MONOEN.EQ.
     *0))) THEN
        WRITE(6,1180)
1180    FORMAT(/' ********* Initializing front parallel beam for photons
     * *******'/)
        IF (((IFPB.EQ.0).AND.(IFORCE.EQ.1))) THEN
          GLE=LOG(EIN)
          DO 1191 IX=1,NR
            PATHL=0.0
            DO 1201 IZ=1,NZ
              IRL=IZ+NZ*(IX-1)+1
              MEDIUM=MED(IRL)
              IF ((MEDIUM.EQ.0)) THEN
                DELTAP=0.
              ELSE
                LGLE=GE1(MEDIUM)*GLE+GE0(MEDIUM)
                DELTAP=GMFP1(LGLE,MEDIUM)*GLE+GMFP0(LGLE,MEDIUM)
                IF ((IRAYLR(IRL).EQ.1)) THEN
                  COHFAC=COHE1(LGLE,MEDIUM)*GLE+COHE0(LGLE,MEDIUM)
                ELSE
                  COHFAC=1.0
                END IF
              END IF
              IF ((DELTAP.NE.0)) THEN
                DELTAP=(ZPLANE(IZ+1)-ZPLANE(IZ))/(COHFAC*DELTAP)
                PATHL=PATHL+DELTAP
              END IF
              IF ((PATHL.LE.1.0E-3)) THEN
                GWATE(IX)=PATHL*(1.-0.5*PATHL)
              ELSE
                GWATE(IX)=1.-EXP(-PATHL)
              END IF
1201        CONTINUE
1202        CONTINUE
1191      CONTINUE
1192      CONTINUE
        END IF
        do_fast_step = .true.
      ELSE
        do_fast_step = .false.
      END IF
      EK0=EIN
      CALL ISUMRY
      write(iout,100) ' '
      call egs_fdate(iout)
      write(iout,*)
      WRITE(IOUT,200)
      WRITE(6,200)
      IF ((IRESTART .EQ.0)) THEN
        WRITE(6,201)
        WRITE(IOUT,201)
      ELSE IF((IRESTART .EQ.1)) THEN
        WRITE(6,202) NCASE,NCASEO
        write(6,'(21x,a,$)') 'New RNG state: '
        write(6,'(a,2i4,$)') ' ixx jxx = ',ixx,jxx
        write(6,*)
        WRITE(IOUT,202) NCASE,NCASEO
        write(iout,'(21x,a,$)') 'New RNG state: '
        write(iout,'(a,2i4,$)') ' ixx jxx = ',ixx,jxx
        write(iout,*)
      ELSE IF((IRESTART .EQ.3)) THEN
        WRITE(6,204)
        WRITE(IOUT,204)
        GO TO 1210
      ELSE IF((IRESTART.EQ.4)) THEN
        WRITE(6,206)
        WRITE(IOUT,206)
      ELSE IF((IRESTART.EQ.5)) THEN
        WRITE(6,205)
        WRITE(IOUT,205)
        GO TO 1210
      END IF
      IF((IWATCH.NE.0))CALL WATCH(-99,IWATCH)
      CPUT1=egs_etime()
      tdum = egs_tot_time(1)
      ETIMETOT=0
      TIMEB=0
      NETADJ=0
      IF((idat .EQ. 0))data_unit = egs_open_file(4,0,1,'.egsdat')
#ifdef HAVE_C_COMPILER
      n_tot = ncaseo
      first_time = .true.
      is_finished = .false.
      part_dose=0
      part2_dose=0
1220  CONTINUE
      IF (( n_parallel .GT. 0 )) THEN
        call egs_pjob_control(ncase,n_run,n_left,n_tot,part_dose,part2_d
     *  ose, current_result, current_uncertainty)
        IF (( n_run .EQ. 0 )) THEN
          write(6,'(//a,a//)') '****** No histories left in job control
     *file', '       => end simulation'
          goto 1210
        END IF
        jcase = n_run/10
        IF (( jcase .LT. 1 )) THEN
          jcase = 1
          n_run = jcase*10
        END IF
        IF (( first_time )) THEN
          first_time = .false.
          n_last = n_run
          write(6,'(//a,i12,a//)') '****** Running ',n_run,' histories'
        ELSE
          write(6,'(//a,i12,a)') '***** Finished ',n_last,' histories'
          write(6,'(/a/,20x,1pe11.4,a,0pf5.2,a/,a,i12,a//)') '      curr
     *ent result including previous runs and other parallel jobs: ', cur
     *    rent_result, ' +/- ',current_uncertainty,' %', '      will run
     * another ',n_run,' histories'
        END IF
      END IF
#endif
      DO 1231 IBATCH=1,10
        IBTCH=IBATCH
        IF ((IBATCH.EQ.1)) THEN
          WRITE(6,1240)' '
1240      FORMAT(/' BATCH #',2X,'time-elapsed',2X,'total cputime',2X,'ra
     *tio',2X, 'time of day',2X,'peak region stats(%)'// ' ',4X,'1',10X,
     *'0.0',12X,'0.0',6X,'0.00',3X,a,$)
          call egs_time(6)
          call flush(6)
        ELSE
          TIMEB = egs_tot_time(0)
          ETIMETOT=ETIMETOT+TIMEB
          CPUT2=egs_etime()
          TIMCPU=CPUT2-CPUT1
          WRITE(6,1250)IBATCH,ETIMETOT,TIMCPU,ETIMETOT/TIMCPU
1250      FORMAT(' ',3X,I2,5X,F8.1,7X,F8.1,2X,F8.2,3X,' ',$)
          call egs_time(6)
          call flush(6)
          BATCHT=TIMCPU/dble(IBATCH-1)
          IF ((TIMCPU+1.1*BATCHT.GT.TIMMAX*3600.)) THEN
            WRITE(IOUT,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY
            WRITE(6,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY
            GO TO 1210
          END IF
        END IF
        DO 1261 ICASE=1,JCASE
          IF((ISOURC .NE. 23))IHSTRY=IHSTRY+1
          NFTIME=0
          IF ((IRESTART.EQ.4)) THEN
            read(rng_unit,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_s
     *      eed, rng_array
            twom24 = 1./16777216.
          END IF
          IF ((ISTORE.EQ.1)) THEN
            rewind(rng_unit)
            write(rng_unit,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_
     *      seed, rng_array
          ELSE IF((ISTORE.EQ.2)) THEN
            write(rng_unit,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_
     *      seed, rng_array
          END IF
          CALL SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
          IF ((MONOEN.NE.0.AND.ISOURC.NE.21.AND.ISOURC.NE.22.AND.ISOURC.
     *    NE.23)) THEN
            CALL ENSRCH(EIN)
            IF ((IQIN.EQ.0)) THEN
              EI=EIN
            ELSE
              EI=EIN+RM
            END IF
          ELSE IF((ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOURC.EQ.23)) THEN
            EI=EIN
          END IF
          IF (((ISOURC.EQ.21 .OR. ISOURC.EQ.22 .OR. ISOURC.EQ.23) .AND.
     *    IFULL.EQ.2 .AND. WEIGHT.LT.1.)) THEN
            WRITE(6,1270)WEIGHT
1270        FORMAT(//' ****WARNING****'/ ' A particle of weight ',F10.5,
     *' from the phase space source is being used'/ ' Pulse height distr
     *ibution only makes sense if all particles have'/ ' weight=1.  Will
     * run simulation with IFULL= dose and stoppers'//)
            WRITE(1,'(//'' ****WARNING****''/
     *     '' A particle of weight '',F10.5,'' from the phase space sour
     *ce is being used''/'' Pulse height distribution only makes sense i
     *f all particles have''/          '' weight=1.  Will run simulation
     * with IFULL= dose and stoppers''//)')
            IFULL=0
          END IF
          IF (( do_fast_step )) THEN
            IX=(IRIN-2)/NZ+1
            GWAIT=GWATE(IX)
            WEIGHT=GWAIT
          END IF
          LATCHI=0
          IF ((IFULL.EQ.1)) THEN
            NEWNRC=NRCFLG
            LATCHI=IBSET(LATCHI,NRCFLG/10)
          END IF
          IF (((IWATCH .NE. 0) .AND. (IWATCH .NE. 4))) THEN
            WRITE(6,1280)1,EIN,IQIN,IRIN,XIN,YIN,ZIN,UIN,VIN,WIN,LATCHI,
     *      WEIGHT
1280        FORMAT(/' INITIAL SHOWER VALUES',T36,':', I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
          END IF
          CALL SHOWER(IQIN,EI,XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT)
          IF((IWATCH .GT. 0))CALL WATCH(-1,IWATCH)
1261    CONTINUE
1262    CONTINUE
        IF ((IDAT.EQ.0)) THEN
          SCSTP=SCSTP+SCSTP_TMP
          SCSTP2=SCSTP2+SCSTP_TMP*SCSTP_TMP
          SCSTP_TMP=0
          SCDSTP=SCDSTP+SCDSTP_TMP
          SCDSTP2=SCDSTP2+SCDSTP_TMP*SCDSTP_TMP
          SCDSTP_TMP=0
          DO 1291 IZ=1,NZDOSE
            DO 1301 IX=1,NRDOSE
              DO 1311 IT=1,ITMAX
                SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT)
                SCDOSE2(IZ,IX,IT)=SCDOSE2(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT)
     *          * SCDOSE_TMP(IZ,IX,IT)
                IF ((IKERMA.EQ.1)) THEN
                  SCKERMA(IZ,IX,IT)=SCKERMA(IZ,IX,IT)+SCKERMA_TMP(IZ,IX,
     *            IT)
                  SCKERMA2(IZ,IX,IT)=SCKERMA2(IZ,IX,IT)+SCKERMA_TMP(IZ,I
     *            X,IT)* SCKERMA_TMP(IZ,IX,IT)
                  IF ((SCDOSE_LAST(IZ,IX,IT).EQ.SCKERMA_LAST(IZ,IX,IT)))
     *             THEN
                    SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)+ S
     *              CDOSE_TMP(IZ,IX,IT)*SCKERMA_TMP(IZ,IX,IT)
                  END IF
                  SCKERMA_TMP(IZ,IX,IT)=0.
                END IF
                SCDOSE_TMP(IZ,IX,IT)=0.
1311          CONTINUE
1312          CONTINUE
1301        CONTINUE
1302        CONTINUE
1291      CONTINUE
1292      CONTINUE
          rewind(data_unit)
          WRITE(data_unit,*)SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIISTP+count_pII
     *    _steps
          WRITE(data_unit,*) (((SCDOSE(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE
     *    ),IZ=1,NZDOSE)
          WRITE(data_unit,*) (((SCDOSE2(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOS
     *    E),IZ=1,NZDOSE)
          IF ((IKERMA.EQ.1)) THEN
            WRITE(data_unit,*) (((SCKERMA(IZ,IX,IT),IT=1,ITMAX),IX=1,NRD
     *      OSE),IZ=1,NZDOSE)
            WRITE(data_unit,*) (((SCKERMA2(IZ,IX,IT),IT=1,ITMAX),IX=1,NR
     *      DOSE),IZ=1,NZDOSE)
            WRITE(data_unit,*) (((SCDOSEtoKERMA2(IZ,IX,IT),IT=1,ITMAX),I
     *      X=1,NRDOSE),IZ=1,NZDOSE)
          END IF
          IF ((IFULL.EQ.2)) THEN
            IF ((PHENER.GT.0.)) THEN
              IF ((SLOTE.GT.0.0)) THEN
                IB=MIN0(int(PHENER/SLOTE+0.999),500)
              ELSE
                IB = MAXBIN
1321            IF(((IB.EQ.1).OR.(BINTOP(IB-1).LT.PHENER)))GO TO 1322
                  IB=IB-1
                GO TO 1321
1322            CONTINUE
              END IF
              SCPDST(IB)=SCPDST(IB)+WT1OLD
              SCPDST2(IB)=SCPDST2(IB)+WT1OLD*WT1OLD
              DO 1331 ICUM=IB,MAXBIN
                SCPCUM(ICUM)=SCPCUM(ICUM)+WT1OLD
                SCPCUM2(ICUM)=SCPCUM2(ICUM)+WT1OLD*WT1OLD
1331          CONTINUE
1332          CONTINUE
              IF ((IWATCH.EQ.3)) THEN
                WRITE(6,1340)PHENER,IB,1
1340            FORMAT(' PULSE HEIGHT ENERGY=', F10.4,' MeV, IN BIN',I3,
     *' WITH WEIGHT',1PE10.3)
              END IF
              DO 1351 IPK=1,4
                IF (((PHENER.GE.DFEN(IPK,2)).AND.(PHENER.LE.DFEN(IPK,3))
     *          )) THEN
                  SCDFEP(IPK) = SCDFEP(IPK)+WT1OLD
                  SCDFEP2(IPK) = SCDFEP2(IPK)+WT1OLD*WT1OLD
                  SCDFDIFF(IPK)=SCDFDIFF(IPK)+WT1OLD
                  SCDFDIFF2(IPK)=SCDFDIFF2(IPK)+WT1OLD*WT1OLD
                  IF ((IWATCH.EQ.3)) THEN
                    WRITE(6,1360)IPK
1360                FORMAT(T50,'IT WAS IN ONE OF THE PEAKS,IPK=',I3/)
                  END IF
                ELSE IF(((PHENER.GE.DFEN(IPK,1)).AND.(PHENER.LT.DFEN(IPK
     *          ,2)))) THEN
                  SCDFBK(IPK)=SCDFBK(IPK)+WT1OLD
                  SCDFBK2(IPK)=SCDFBK2(IPK)+WT1OLD*WT1OLD
                  SCDFDIFF(IPK)=SCDFDIFF(IPK)-WT1OLD
                  SCDFDIFF2(IPK)=SCDFDIFF2(IPK)-WT1OLD*WT1OLD
                END IF
1351          CONTINUE
1352          CONTINUE
              PHENER=0
            END IF
            WRITE(data_unit,*)(SCPDST(IB),SCPDST2(IB),IB=1,MAXBIN)
            WRITE(data_unit,*)(SCPCUM(IB),SCPCUM2(IB),IB=1,MAXBIN)
            WRITE(data_unit,*)(SCDFEP(IPK),SCDFEP2(IPK),IPK=1,4)
            WRITE(data_unit,*)(SCDFBK(IPK),SCDFBK2(IPK),IPK=1,4)
            WRITE(data_unit,*)(SCDFDIFF(IPK),SCDFDIFF2(IPK),IPK=1,4)
          END IF
        END IF
        CPUT2=egs_etime()
        TIMCPU=CPUT2-CPUT1+TMCPUO
        IF ((IDAT.EQ.0)) THEN
          write(data_unit,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_s
     *    eed, rng_array
          WRITE(data_unit,*) IHSTRY,TIMCPU,NNREAD
          write(data_unit,*) SCOMEG,SCOMEG2
        END IF
        TDSMAX=0.0
        DO 1371 IRL=2,NREG
          IF ((CDSTBL(IRL).EQ.DCHAR)) THEN
            IZD=IDSTBL(IRL,1)
            IXD=IDSTBL(IRL,2)
            FMASS=AMASS(IZD+NZDMIN-1,IXD+NRDMIN)
            IF (((SCDOSE(IZD,IXD,1)+SCDOSE_TMP(IZD,IXD,1))/FMASS.GT.TDSM
     *      AX)) THEN
              TDSMAX=(SCDOSE(IZD,IXD,1)+SCDOSE_TMP(IZD,IXD,1))/FMASS
              IDSMAX=IRL
            END IF
          END IF
1371    CONTINUE
1372    CONTINUE
        IF ((TDSMAX.GT.0.0)) THEN
          IZD=IDSTBL(IDSMAX,1)
          IXD=IDSTBL(IDSMAX,2)
          TDOS=SCDOSE(IZD,IXD,1)+SCDOSE_TMP(IZD,IXD,1)
          TDOS2=SCDOSE2(IZD,IXD,1)+SCDOSE_TMP(IZD,IXD,1)*SCDOSE_TMP(IZD,
     *    IXD,1)
          IF ((ISOURC.EQ.21.OR.ISOURC.EQ.22)) THEN
            SCORE_NORM_NUM= dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCA
     *      SE_PHSP)*NINCSRC
          ELSE
            SCORE_NORM_NUM=dble(IHSTRY)
          END IF
          IF ((SCORE_NORM_NUM.GT.1.)) THEN
            TDOS=TDOS/SCORE_NORM_NUM
            TDOS2=TDOS2/SCORE_NORM_NUM
            TDOS2=(TDOS2-TDOS*TDOS)/(SCORE_NORM_NUM-1)
            IF((TDOS2.GE.0.))TDOS2=SQRT(TDOS2)
            TDOS2=MIN(TDOS2/TDOS*100.,99.9)
            IF (( (TDOS2 .LE. STATLM) .AND. (STATLM .NE. 0.0) )) THEN
              WRITE(6,230)IDSMAX,TDOS2,IBTCH
              WRITE(IOUT,230)IDSMAX,TDOS2,IBTCH
              GO TO 1210
            END IF
          END IF
        END IF
        WRITE(6,1380)TDOS2
1380    FORMAT(' ',9X,F6.3)
1231  CONTINUE
1232  CONTINUE
#ifdef HAVE_C_COMPILER
      IF (( n_parallel .GT. 0 )) THEN
        goto 1220
      END IF
#endif
      WRITE(IOUT,240) STATLM,TDOS2,IBTCH
      WRITE(6,240) STATLM,TDOS2,IBTCH
1210  CONTINUE
      write(6,'(/a,$)') '********* FINAL RANDOM NUMBER STATE:'
      write(6,'(a,2i4,$)') ' ixx jxx = ',ixx,jxx
      write(6,'(a)') '  *********'
      write(iout,'(/a,$)') '********* FINAL RANDOM NUMBER STATE:'
      write(iout,'(a,2i4,$)') ' ixx jxx = ',ixx,jxx
      write(iout,'(a)') '  *********'
      TIMEB = egs_tot_time(0)
      ETIMETOT=ETIMETOT+TIMEB
      CPUT2=egs_etime()
      TIMCPU=CPUT2-CPUT1+TMCPUO
      IF ((TMCPUO.EQ.0)) THEN
        RATIO=ETIMETOT/TIMCPU
      ELSE
        RATIO=0.
      END IF
      IF ((IRESTART.EQ.3)) THEN
        WRITE(IOUT,250)TMCPUO,TMCPUO/3600
        WRITE(6,250)TMCPUO,TMCPUO/3600
        WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO
        WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO
      ELSE IF((IRESTART.EQ.5)) THEN
        WRITE(IOUT,255)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT
     *  )
        WRITE(6,255)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT)
        WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO
        WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO
      ELSE
        IF ((RATIO.NE.0.0)) THEN
          WRITE(IOUT,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO
          WRITE(6,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO
        ELSE
          WRITE(IOUT,270) TIMCPU,TIMCPU/3600.
          WRITE(6,270) TIMCPU,TIMCPU/3600.
        END IF
        IF (((IHSTRY.NE.0).AND.(TIMCPU.NE.0.0))) THEN
          WRITE(IOUT,280)TIMCPU/dble(IHSTRY),3600.*dble(IHSTRY)/TIMCPU
          WRITE(6,280)TIMCPU/dble(IHSTRY),3600.*dble(IHSTRY)/TIMCPU
        END IF
      END IF
1390  CONTINUE
      IF ((ISOURC.EQ.21.OR.ISOURC.EQ.22)) THEN
        SCORE_NORM_NUM=dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/ dble(NCASE_P
     *  HSP)*NINCSRC
      ELSE
        SCORE_NORM_NUM=dble(IHSTRY)
      END IF
      SCORE_TEMP=SCSTP/SCORE_NORM_NUM
      SCSTP2=SCSTP2/SCORE_NORM_NUM
      SCSTP2=(SCSTP2-SCORE_TEMP*SCORE_TEMP)/(SCORE_NORM_NUM-1)
      IF((SCSTP2.GE.0.))SCSTP2= SQRT(SCSTP2)
      IF ((SCORE_TEMP.NE.0.)) THEN
        SCSTP2 = SCSTP2/SCORE_TEMP*100.
        IF (( SCSTP2 .GT. 99.9 )) THEN
          SCSTP2 = 99.9
        END IF
      ELSE
        SCSTP2=99.9
      END IF
      SCORE_TEMP=SCDSTP/SCORE_NORM_NUM
      SCDSTP2=SCDSTP2/SCORE_NORM_NUM
      SCDSTP2=(SCDSTP2-SCORE_TEMP*SCORE_TEMP)/(SCORE_NORM_NUM-1)
      IF((SCDSTP2.GE.0.))SCDSTP2= SQRT(SCDSTP2)
      IF ((SCORE_TEMP.NE.0.)) THEN
        SCDSTP2 = SCDSTP2/SCORE_TEMP*100.
        IF (( SCDSTP2 .GT. 99.9 )) THEN
          SCDSTP2 = 99.9
        END IF
      ELSE
        SCDSTP2=99.9
      END IF
      IF ((IDAT.EQ.1)) THEN
        DO 1401 IT=1,ITMAX
          DO 1411 IX=1,NRDOSE
            DO 1421 IZ=1,NZDOSE
              SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT)
              SCDOSE2(IZ,IX,IT)=SCDOSE2(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT)*
     *        SCDOSE_TMP(IZ,IX,IT)
              IF ((IKERMA.EQ.1)) THEN
                SCKERMA(IZ,IX,IT)=SCKERMA(IZ,IX,IT)+SCKERMA_TMP(IZ,IX,IT
     *          )
                SCKERMA2(IZ,IX,IT)=SCKERMA2(IZ,IX,IT)+ SCKERMA_TMP(IZ,IX
     *          ,IT)* SCKERMA_TMP(IZ,IX,IT)
                IF ((SCDOSE_LAST(IZ,IX,IT).EQ.SCKERMA_LAST(IZ,IX,IT))) T
     *          HEN
                  SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)+ SCD
     *            OSE_TMP(IZ,IX,IT)*SCKERMA_TMP(IZ,IX,IT)
                END IF
              END IF
1421        CONTINUE
1422        CONTINUE
1411      CONTINUE
1412      CONTINUE
1401    CONTINUE
1402    CONTINUE
        IF ((IFULL.EQ.2)) THEN
          IF ((PHENER.GT.0.)) THEN
            IF ((SLOTE.GT.0.0)) THEN
              IB=MIN0(int(PHENER/SLOTE+0.999),500)
            ELSE
              IB = MAXBIN
1431          IF(((IB.EQ.1).OR.(BINTOP(IB-1).LT.PHENER)))GO TO 1432
                IB=IB-1
              GO TO 1431
1432          CONTINUE
            END IF
            SCPDST(IB)=SCPDST(IB)+WT1OLD
            SCPDST2(IB)=SCPDST2(IB)+WT1OLD*WT1OLD
            DO 1441 ICUM=IB,MAXBIN
              SCPCUM(ICUM)=SCPCUM(ICUM)+WT1OLD
              SCPCUM2(ICUM)=SCPCUM2(ICUM)+WT1OLD*WT1OLD
1441        CONTINUE
1442        CONTINUE
            IF ((IWATCH.EQ.3)) THEN
              WRITE(6,1450)PHENER,IB,1
1450          FORMAT(' PULSE HEIGHT ENERGY=', F10.4,' MeV, IN BIN',I3,'W
     *ITH WEIGHT',1PE10.3)
            END IF
            DO 1461 IPK=1,4
              IF (((PHENER.GE.DFEN(IPK,2)).AND.(PHENER.LE.DFEN(IPK,3))))
     *         THEN
                SCDFEP(IPK) = SCDFEP(IPK)+WT1OLD
                SCDFEP2(IPK) = SCDFEP2(IPK)+WT1OLD*WT1OLD
                SCDFDIFF(IPK)=SCDFDIFF(IPK)+WT1OLD
                SCDFDIFF2(IPK)=SCDFDIFF2(IPK)+WT1OLD*WT1OLD
                IF ((IWATCH.EQ.3)) THEN
                  WRITE(6,1470)IPK
1470              FORMAT(T50,'IT WAS IN ONE OF THE PEAKS,IPK=',I3/)
                END IF
              ELSE IF(((PHENER.GE.DFEN(IPK,1)).AND.(PHENER.LT.DFEN(IPK,2
     *        )))) THEN
                SCDFBK(IPK)=SCDFBK(IPK)+WT1OLD
                SCDFBK2(IPK)=SCDFBK2(IPK)+WT1OLD*WT1OLD
                SCDFDIFF(IPK)=SCDFDIFF(IPK)-WT1OLD
                SCDFDIFF2(IPK)=SCDFDIFF2(IPK)-WT1OLD*WT1OLD
              END IF
1461        CONTINUE
1462        CONTINUE
            PHENER=0
          END IF
        END IF
      END IF
      IF (((ISOURC.EQ.4).AND.(NR.GT.1))) THEN
        DO 1481 IT=1,ITMAX
          DO 1491 IX=2,NRDOSE
            DO 1501 IZ=1,NZDOSE
              SCDOSE(IZ,IX,IT)= SCDOSE(IZ,IX,IT)+SCDOSE(IZ,IX-1,IT)
              SCDOSE2(IZ,IX,IT)= SCDOSE2(IZ,IX,IT)+SCDOSE2(IZ,IX-1,IT)
              SCKERMA(IZ,IX,IT)= SCKERMA(IZ,IX,IT)+SCKERMA(IZ,IX-1,IT)
              SCKERMA2(IZ,IX,IT)= SCKERMA2(IZ,IX,IT)+SCKERMA2(IZ,IX-1,IT
     *        )
1501        CONTINUE
1502        CONTINUE
1491      CONTINUE
1492      CONTINUE
1481    CONTINUE
1482    CONTINUE
      END IF
      IF ((IFULL.EQ.2)) THEN
        DO 1511 IX=1,NRDOSE
          DO 1521 IZ=1,NZDOSE
            IRL=IZ+NZ*(IX-1)+1
            IF ((IPHR(IRL).NE.0)) THEN
              SCPHEN=SCPHEN+SCDOSE(IZ,IX,1)
              SCPHEN2=SCPHEN2+SCDOSE2(IZ,IX,1)
            END IF
1521      CONTINUE
1522      CONTINUE
1511    CONTINUE
1512    CONTINUE
      END IF
      DO 1531 IT=1,ITMAX
        DO 1541 IX=1,NRDOSE
          DO 1551 IZ=1,NZDOSE
            SCORE_TEMP=SCDOSE(IZ,IX,IT)/SCORE_NORM_NUM
            SCDOSE2(IZ,IX,IT)=SCDOSE2(IZ,IX,IT)/SCORE_NORM_NUM
            SCDOSE2(IZ,IX,IT)=(SCDOSE2(IZ,IX,IT)-SCORE_TEMP*SCORE_TEMP)/
     *      (SCORE_NORM_NUM-1)
            IF((SCDOSE2(IZ,IX,IT).GE.0.))SCDOSE2(IZ,IX,IT)= SQRT(SCDOSE2
     *      (IZ,IX,IT))
            IF ((SCORE_TEMP.NE.0.)) THEN
              SCDOSE2(IZ,IX,IT) = SCDOSE2(IZ,IX,IT)/SCORE_TEMP*100.
              IF (( SCDOSE2(IZ,IX,IT) .GT. 99.9 )) THEN
                SCDOSE2(IZ,IX,IT) = 99.9
              END IF
            ELSE
              SCDOSE2(IZ,IX,IT)=99.9
            END IF
            IF ((IKERMA.EQ.1)) THEN
              SCORE_TEMP=SCKERMA(IZ,IX,IT)/SCORE_NORM_NUM
              SCKERMA2(IZ,IX,IT)=SCKERMA2(IZ,IX,IT)/SCORE_NORM_NUM
              SCKERMA2(IZ,IX,IT)=(SCKERMA2(IZ,IX,IT)-SCORE_TEMP*SCORE_TE
     *        MP)/(SCORE_NORM_NUM-1)
              IF((SCKERMA2(IZ,IX,IT).GE.0.))SCKERMA2(IZ,IX,IT)= SQRT(SCK
     *        ERMA2(IZ,IX,IT))
              IF ((SCORE_TEMP.NE.0.)) THEN
                SCKERMA2(IZ,IX,IT) = SCKERMA2(IZ,IX,IT)/SCORE_TEMP*100.
                IF (( SCKERMA2(IZ,IX,IT) .GT. 99.9 )) THEN
                  SCKERMA2(IZ,IX,IT) = 99.9
                END IF
              ELSE
                SCKERMA2(IZ,IX,IT)=99.9
              END IF
              SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)/ SCORE_N
     *        ORM_NUM- SCDOSE(IZ,IX,IT)* SCKERMA(IZ,IX,IT)/ (SCORE_NORM_
     *        NUM**2)
              SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)/ (SCDOSE
     *        (IZ,IX,IT)*SCKERMA(IZ,IX,IT)/ (SCORE_NORM_NUM**2))
              SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)/ (SCORE_
     *        NORM_NUM-1)
              SCDOSEtoKERMA2(IZ,IX,IT)=(SCDOSE2(IZ,IX,IT)/100.)**2+ (SCK
     *        ERMA2(IZ,IX,IT)/100.)**2- 2*SCDOSEtoKERMA2(IZ,IX,IT)
              IF ((SCDOSEtoKERMA2(IZ,IX,IT).GT.0.)) THEN
                SCDOSEtoKERMA2(IZ,IX,IT)= 100*SQRT(SCDOSEtoKERMA2(IZ,IX,
     *          IT))
              END IF
              IF (( SCDOSEtoKERMA2(IZ,IX,IT) .GT. 99.9 )) THEN
                SCDOSEtoKERMA2(IZ,IX,IT) = 99.9
              END IF
            END IF
1551      CONTINUE
1552      CONTINUE
1541    CONTINUE
1542    CONTINUE
1531  CONTINUE
1532  CONTINUE
      SCORE_TEMP=SCOMEG/dble(IHSTRY)
      SCOMEG2=SCOMEG2/dble(IHSTRY)
      SCOMEG2=(SCOMEG2-SCORE_TEMP*SCORE_TEMP)/(dble(IHSTRY)-1)
      IF((SCOMEG2.GE.0.))SCOMEG2= SQRT(SCOMEG2)
      IF ((SCORE_TEMP.NE.0.)) THEN
        SCOMEG2 = SCOMEG2/SCORE_TEMP*100.
        IF (( SCOMEG2 .GT. 99.9 )) THEN
          SCOMEG2 = 99.9
        END IF
      ELSE
        SCOMEG2=99.9
      END IF
      SCOMEG = SCOMEG/dble(IHSTRY)
      WRITE(6,1560)SCOMEG,SCOMEG2
1560  FORMAT(/' OMEG =',1PE12.3,'(',0PF5.1,'%)'/)
      IF ((IFULL.EQ.2)) THEN
        DO 1571 IB=1,MAXBIN
          SCPTOT=SCPTOT+SCPDST(IB)
          SCPTOT2=SCPTOT2+SCPDST2(IB)
1571    CONTINUE
1572    CONTINUE
        SCORE_TEMP=SCPTOT/SCORE_NORM_NUM
        SCPTOT2=SCPTOT2/SCORE_NORM_NUM
        SCPTOT2=(SCPTOT2-SCORE_TEMP*SCORE_TEMP)/(SCORE_NORM_NUM-1)
        IF((SCPTOT2.GE.0.))SCPTOT2= SQRT(SCPTOT2)
        IF ((SCORE_TEMP.NE.0.)) THEN
          SCPTOT2 = SCPTOT2/SCORE_TEMP*100.
          IF (( SCPTOT2 .GT. 99.9 )) THEN
            SCPTOT2 = 99.9
          END IF
        ELSE
          SCPTOT2=99.9
        END IF
        SCORE_TEMP=SCPHEN/SCORE_NORM_NUM
        SCPHEN2=SCPHEN2/SCORE_NORM_NUM
        SCPHEN2=(SCPHEN2-SCORE_TEMP*SCORE_TEMP)/(SCORE_NORM_NUM-1)
        IF((SCPHEN2.GE.0.))SCPHEN2= SQRT(SCPHEN2)
        IF ((SCORE_TEMP.NE.0.)) THEN
          SCPHEN2 = SCPHEN2/SCORE_TEMP*100.
          IF (( SCPHEN2 .GT. 99.9 )) THEN
            SCPHEN2 = 99.9
          END IF
        ELSE
          SCPHEN2=99.9
        END IF
        DO 1581 IPK=1,4
          SCORE_TEMP=SCDFEP(IPK)/SCORE_NORM_NUM
          SCDFEP2(IPK)=SCDFEP2(IPK)/SCORE_NORM_NUM
          SCDFEP2(IPK)=(SCDFEP2(IPK)-SCORE_TEMP*SCORE_TEMP)/(SCORE_NORM_
     *    NUM-1)
          IF((SCDFEP2(IPK).GE.0.))SCDFEP2(IPK)= SQRT(SCDFEP2(IPK))
          IF ((SCORE_TEMP.NE.0.)) THEN
            SCDFEP2(IPK) = SCDFEP2(IPK)/SCORE_TEMP*100.
            IF (( SCDFEP2(IPK) .GT. 99.9 )) THEN
              SCDFEP2(IPK) = 99.9
            END IF
          ELSE
            SCDFEP2(IPK)=99.9
          END IF
          SCORE_TEMP=SCDFBK(IPK)/SCORE_NORM_NUM
          SCDFBK2(IPK)=SCDFBK2(IPK)/SCORE_NORM_NUM
          SCDFBK2(IPK)=(SCDFBK2(IPK)-SCORE_TEMP*SCORE_TEMP)/(SCORE_NORM_
     *    NUM-1)
          IF((SCDFBK2(IPK).GE.0.))SCDFBK2(IPK)= SQRT(SCDFBK2(IPK))
          IF ((SCORE_TEMP.NE.0.)) THEN
            SCDFBK2(IPK) = SCDFBK2(IPK)/SCORE_TEMP*100.
            IF (( SCDFBK2(IPK) .GT. 99.9 )) THEN
              SCDFBK2(IPK) = 99.9
            END IF
          ELSE
            SCDFBK2(IPK)=99.9
          END IF
          SCDFEP(IPK)=SCDFEP(IPK)-SCDFBK(IPK)
          SCDFEP2(IPK)=(SCDFEP2(IPK)*SCDFEP(IPK)/SCORE_NORM_NUM/100.)**2
     *    + (SCDFBK2(IPK)*SCDFBK(IPK)/SCORE_NORM_NUM/100.)**2+ 2/(SCORE_
     *    NORM_NUM**2)*(SCDFEP(IPK)*SCDFBK(IPK))/ (SCORE_NORM_NUM-1)
          IF ((SCDFEP2(IPK).GT.0.)) THEN
            SCDFEP2(IPK)=SQRT(SCDFEP2(IPK))/(SCDFEP(IPK)/SCORE_NORM_NUM)
          END IF
          IF (( SCDFEP2(IPK) .GT. 0.999 )) THEN
            SCDFEP2(IPK) = 0.999
          END IF
          SCDFEP(IPK)=SCDFEP(IPK)/SCPTOT
          SCDFEP2(IPK)=SCDFEP2(IPK)**2+(SCPTOT2/100.)**2- 2*(SCDFDIFF2(I
     *    PK)/SCORE_NORM_NUM - SCDFDIFF(IPK)*SCPTOT/ (SCORE_NORM_NUM)**2
     *    )/ (SCDFDIFF(IPK)*SCPTOT/(SCORE_NORM_NUM)**2)/(SCORE_NORM_NUM-
     *    1)
          IF((SCDFEP2(IPK).GT.0.))SCDFEP2(IPK)=100*SQRT(SCDFEP2(IPK))
          IF((SCDFEP2(IPK).GT.99.9))SCDFEP2(IPK)=99.9
1581    CONTINUE
1582    CONTINUE
        DO 1591 IB=1,MAXBIN
          SCORE_TEMP2=SCPDST2(IB)
          SCORE_TEMP=SCPDST(IB)/SCORE_NORM_NUM
          SCPDST2(IB)=SCPDST2(IB)/SCORE_NORM_NUM
          SCPDST2(IB)=(SCPDST2(IB)-SCORE_TEMP*SCORE_TEMP)/(SCORE_NORM_NU
     *    M-1)
          IF((SCPDST2(IB).GE.0.))SCPDST2(IB)= SQRT(SCPDST2(IB))
          IF ((SCORE_TEMP.NE.0.)) THEN
            SCPDST2(IB) = SCPDST2(IB)/SCORE_TEMP*100.
            IF (( SCPDST2(IB) .GT. 99.9 )) THEN
              SCPDST2(IB) = 99.9
            END IF
          ELSE
            SCPDST2(IB)=99.9
          END IF
          SCPDST2(IB)=(SCPDST2(IB)/100.)**2+(SCPTOT2/100.)**2- 2*(SCORE_
     *    TEMP2/SCORE_NORM_NUM-SCPDST(IB)*SCPTOT/(SCORE_NORM_NUM**2))/ (
     *    SCPDST(IB)*SCPTOT/(SCORE_NORM_NUM**2))/(SCORE_NORM_NUM-1)
          IF((SCPDST2(IB).GT.0.))SCPDST2(IB)=100*SQRT(SCPDST2(IB))
          IF((SCPDST2(IB).GT.99.9))SCPDST2(IB)=99.9
          SCPDST(IB)=SCPDST(IB)/SCPTOT
          SCORE_TEMP2=SCPCUM2(IB)
          SCORE_TEMP=SCPCUM(IB)/SCORE_NORM_NUM
          SCPCUM2(IB)=SCPCUM2(IB)/SCORE_NORM_NUM
          SCPCUM2(IB)=(SCPCUM2(IB)-SCORE_TEMP*SCORE_TEMP)/(SCORE_NORM_NU
     *    M-1)
          IF((SCPCUM2(IB).GE.0.))SCPCUM2(IB)= SQRT(SCPCUM2(IB))
          IF ((SCORE_TEMP.NE.0.)) THEN
            SCPCUM2(IB) = SCPCUM2(IB)/SCORE_TEMP*100.
            IF (( SCPCUM2(IB) .GT. 99.9 )) THEN
              SCPCUM2(IB) = 99.9
            END IF
          ELSE
            SCPCUM2(IB)=99.9
          END IF
          SCPCUM2(IB)=(SCPCUM2(IB)/100.)**2+(SCPTOT2/100.)**2- 2*(SCORE_
     *    TEMP2/SCORE_NORM_NUM-SCPCUM(IB)*SCPTOT/(SCORE_NORM_NUM**2))/ (
     *    SCPCUM(IB)*SCPTOT/(SCORE_NORM_NUM**2))/(SCORE_NORM_NUM-1)
          IF((SCPCUM2(IB).GT.0.))SCPCUM2(IB)=100*SQRT(SCPCUM2(IB))
          IF((SCPCUM2(IB).GT.99.9))SCPCUM2(IB)=99.9
          SCPCUM(IB)=SCPCUM(IB)/SCPTOT
1591    CONTINUE
1592    CONTINUE
        SCPTOT=SCPTOT/SCORE_NORM_NUM
        SCPHEN=SCPHEN/SCORE_NORM_NUM
      END IF
      IF ((ISOURC.EQ.21.OR.ISOURC.EQ.22)) THEN
        AINFLU=dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*NINC
     *  SRC
      ELSE IF((ISOURC.EQ.23)) THEN
        AINFLU=dble(IHSTRY)
      ELSE
        AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET)
      END IF
      DO 1601 IT=1,ITMAX
        DO 1611 IX=1,NRDOSE
          DO 1621 IZ=1,NZDOSE
            IF ((SCDOSE(IZ,IX,IT).NE.0.0)) THEN
              FMASS=AMASS(IZ+NZDMIN-1,IX+NRDMIN)
              IF((FMASS.EQ.0.0))FMASS=1.0
              SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)*1.602E-10/(FMASS*AINFLU)
              IF ((SCKERMA(IZ,IX,IT) .NE. 0)) THEN
                SCKERMA(IZ,IX,IT)=SCKERMA(IZ,IX,IT)*1.602E-10/(FMASS*AIN
     *          FLU)
              END IF
            END IF
1621      CONTINUE
1622      CONTINUE
1611    CONTINUE
1612    CONTINUE
1601  CONTINUE
1602  CONTINUE
      CALL OSUMRY
1150  CONTINUE
1050  CONTINUE
      WRITE(6,1630)' '
1630  FORMAT(/ ' End of run',9X,a,$)
      call egs_fdate(6)
      WRITE(6,1640)
1640  FORMAT(//1x,79('*')/1x,79('*')/)
      IF ((ERROR_FLAG.EQ.1)) THEN
        WRITE(6,1650)
1650    FORMAT(//' **********  ERRORS AND WARNING MESSAGES  ********** '
     *//)
      END IF
      rewind (i_errors)
9998  CONTINUE
      READ (i_errors,END=9999, FMT='(A80)') TEXT
      WRITE (*,'(A79)') TEXT
      GOTO 9998
9999  CONTINUE
      backspace(i_errors)
      write(i_errors,'(/a,9x,a,$)') ' '
      call egs_fdate(i_errors)
      write(i_errors,*)
      write(iout,'(/a,9x,a,$)') ' '
      call egs_fdate(iout)
      write(iout,*)
      call egs_finish
#ifdef HAVE_C_COMPILER
      IF (( n_parallel .GT. 0 .AND. .NOT.is_finished )) THEN
        call egs_pjob_finish(n_job)
        IF (( n_job .EQ. 0 )) THEN
          is_finished = .true.
          call egs_combine_runs(combine_results,'.egsdat')
          NCASET=NCASEO
          IHSTRY=NCASET
          CALL SRCOTO(WEIGHT)
          goto 1390
        END IF
      END IF
#endif
      call SRCEND
      call exit(0)
100   FORMAT(' ',80A1//' CALCULATION USING DOSRZnrc(EGSnrc) ',' ',' ', /
     *'ON ','linux',' ',T54,a,$)
200   FORMAT(/' ',79('*')/ /' ',T20,'EXECUTION INFORMATION AND WARNING M
     *ESSAGES'/ /' ',79('*')/ /' USING DOSRZnrc(EGSnrc) ',' ',' ')
201   FORMAT(/' ********* NEW INPUT FILE *********'/)
202   FORMAT(/' ********* RESTARTED INPUT FILE ********* '/ ' ',10X,I12,
     *' NEW + ',I12,' OLD HISTORIES'/ ' ',20X,'NEW RN SEEDS=',$)
204   FORMAT(/' ********* DATA ANALYSIS ONLY *********'/)
205   FORMAT(/' ********* ANALYZING RESULTS FROM PARALLEL RUNS *******'/
     *)
206   FORMAT(/' ********* READING RANDOM NUMBER STATE FROM UNIT 2 ****'/
     *)
210   FORMAT(/' ********* Not enough time to finish within', ' limit of'
     *,F8.2,' hours *******'/'*********',I5,' batches used********'/ ' '
     *,I12,' histories run, ',I12,' histories analyzed'//)
220   FORMAT(I12,1X,2I1)
230   FORMAT(/' DESIRED STATISTICAL ACCURACY OBTAINED.'/ ' STATS IN PEAK
     * DOSE REGION (REGION ',I3,')= ',F6.3, ' AFTER ',I2,' BATCHES')
240   FORMAT(/' *********DESIRED STATISTICAL ACCURACY OF ',F6.3,'%', ' N
     *OT REACHED*********'/ ' STATS IN PEAK DOSE REGION= ',F6.3,' % AFTE
     *R ',I2,' BATCHES')
250   FORMAT(/' FOR OLD RUN:'/ ' ----------- '/ ' Total cputime =',F8.1,
     *'s (=',F5.2,' h)')
255   FORMAT(/' FOR PARALLEL RUNS:'/ ' ----------------- '/ ' On ',I5,'m
     *achines '/ ' Total cputime =',F8.1,'s (=',F8.2,' h), cputime/machi
     *ne =', F8.1,'s')
260   FORMAT(/' Finished simulations: elapsed,cputime', ',ratio= ',2F8.1
     *,'(=',F5.2,'h)',F8.2)
270   FORMAT(/' Finished simulations: cputime=',F8.1,'(=',F5.2,' h)')
280   FORMAT(/' cputime per history =',F10.5,' sec. number of historiesp
     *er', 1x,' hour =',F12.0)
      END
      SUBROUTINE AUSGAB(IARG)
      implicit none
      integer*4 IARG
      REAL*8 FTMP
      CHARACTER*4 BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,
     *SCHAR, TCHAR,UCHAR,VCHAR
      COMMON/CHARS/ BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHA
     *R,SCHAR,TCHAR,UCHAR,VCHAR
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      CHARACTER*4 CDSTBL( 12001),CTRTBL( 12001),CABSRB( 12001)
      COMMON/GEOM/ZPLANE( 201),RCYL(0:60), CYRAD2( 61), NZ,NR,NREG,NDOSE
     *,NZDOSE,NRDOSE,NPLANE, NZDMIN,NZDMAX,NRDMIN,NRDMAX, NTRACK( 12001)
     *,CDSTBL,CTRTBL,CABSRB,IDSTBL( 12001,2)
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,NZDMIN,NZDMAX,NRDM
     *IN,NRDMAX, NTRACK,IDSTBL
      COMMON/NRCNEW/NEWNRC,DECISION
      integer*4 NEWNRC,DECISION
      LOGICAL RUSROU
      COMMON/RUSROU/RRZ,RRCUT,RUSROU
      real*8 RRZ,RRCUT
      COMMON/SCORE/ SCDOSE(200,60,7),SCDOSE2(200,60,7), SCKERMA(200,60,7
     *),SCKERMA2(200,60,7), SCDOSEtoKERMA2(200,60,7),SCPDST(500),SCPDST2
     *(500), SCPCUM(500),SCPCUM2(500),SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCD
     *FBK(4),SCDFBK2(4),SCDFEP(4),SCDFEP2(4),SCDFDIFF(4),SCDFDIFF2(4), S
     *CSTP,SCSTP2,SCDSTP,SCDSTP2, PIISTP, SCSTP_LAST, SCDSTP_LAST,SCDOSE
     *_LAST(200,60,7), SCKERMA_LAST(200,60,7), SCKERMA_LASTOLD(200,60,7)
     *,SCPDST_LAST, IHSTRY, DFEN(4,4), PHENER,WT1OLD,BINTOP(500),SLOTE,D
     *ELTAE, SCDOSE_TMP(200,60,7), SCKERMA_TMP(200,60,7), SCKERMA_TMPOLD
     *(200,60,7), SCSTP_TMP,SCDSTP_TMP, MXNP,IFULL,ISTORE,IKERMA, IWATCH
     *,IOOPTN,IOUTSP, IPHR( 12001),MAXBIN,NCOMPT,during_pe_compt,during_
     *eii
      real*8 SCDOSE,SCDOSE2,SCKERMA,SCKERMA2,SCDOSEtoKERMA2,SCPDST,SCPDS
     *T2, SCPCUM,SCPCUM2,SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCDFBK,SCDFBK2,S
     *CDFEP,SCDFEP2,SCDFDIFF,SCDFDIFF2, SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIIS
     *TP
      integer*8 SCSTP_LAST, SCDSTP_LAST, SCDOSE_LAST, SCKERMA_LAST, SCKE
     *RMA_LASTOLD,SCPDST_LAST, IHSTRY
      real*8 DFEN, PHENER,WT1OLD,BINTOP,SLOTE,DELTAE, SCDOSE_TMP,SCKERMA
     *_TMP,SCKERMA_TMPOLD,SCSTP_TMP,SCDSTP_TMP
      integer*4 MXNP,IFULL,ISTORE,IKERMA, IWATCH,IOOPTN,IOUTSP, IPHR,MAX
     *BIN,NCOMPT,during_pe_compt,during_eii
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERRR/ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN, MINZ,MAXZ,MINR,MAXR
     *,IREJCT
      real*8 ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN
      integer*4 MINZ,MAXZ,MINR,MAXR,IREJCT
      COMMON/USERMI/EXPMFP,GWTOLD,ICSDA
      integer*4 ICSDA
      real*8 EXPMFP,GWTOLD
      COMMON/USERVR/ CEXPTR,GWAIT,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,
     *IQINC,MONOEN, cs_enhance,cs_enhance_current,ienhance,iefl( 12001),
     *ics_enhance, do_fast_step
      integer*4 ienhance,iefl,ics_enhance, IFORCE,NFMIN,NFMAX,NFTIME,ISO
     *URC,IFPB,IQINC,MONOEN
      real*8 CEXPTR,GWAIT,cs_enhance,cs_enhance_current
      logical do_fast_step
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(100,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBE
     *AM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,
     *DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,P
     *ROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,
     *ZSOFST,                                                      SVTMP
     *1,SVTMP2,SVTMP3,SVTMP4,
     *         RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                       XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,W
     *EIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(200,60),TMCPUO,TIMMAX,ST
     *ATLM,EIN,EKMAX, IDAT,IRESTART,IQIN,NESTEP,NSMAX,IXXIN,JXXIN,IVAL,D
     *ATCOUNT
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN,EKMAX
      integer*4 IDAT,IRESTART,IQIN,NESTEP,NSMAX, IXXIN,JXXIN,IVAL,DATCOU
     *NT
      integer*8 NCASE,NCASEO,NCASET
      integer*4 IRL,IZD,IXD,IQL,ip,IX,IZ,IGEOM,IB,IPK,I,II,ICUM
      real*8 aux1,R1,XSI
      LOGICAL BTEST
      INTEGER IBSET,IBCLR
      integer*4 IGBUG1,IGBUG2
      save IGBUG1,IGBUG2
      data IGBUG1/0/,IGBUG2/0/
      MXNP=MAX(MXNP,NP)
      IF ((ienhance .EQ. 1)) THEN
        IF ((iarg .EQ. 15 .OR. iarg .EQ. 17 .OR. iarg .EQ. 19 .OR. iarg
     *  .EQ. 23)) THEN
          np = np + 1
          IF ((np .GT. 500)) THEN
            WRITE(6,1660)500
1660        FORMAT(' Enhance cs unable to add to stack'/ '       since e
     *xceeding $MXSTACK=',I6/ ' Stopping.'/ 1x,80('*')/)
            stop
          END IF
          X(np)=X(np - 1)
          Y(np)=Y(np - 1)
          Z(np)=Z(np - 1)
          IR(np)=IR(np - 1)
          WT(np)=WT(np - 1)
          DNEAR(np)=DNEAR(np - 1)
          LATCH(np)=LATCH(np - 1)
          e(np) = e(np - 1)
          u(np) = u(np - 1)
          v(np) = v(np - 1)
          w(np) = w(np - 1)
          iq(np) = iq(np - 1)
          IF((rng_seed .GT. 128))call ranmar_get
          R1 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          aux1 = 1 - 1./cs_enhance_current
          IF (( R1 .GT. aux1 )) THEN
            wt(np-1) = 0
            e(np-1) = 0
            dnear(np-1) = -1
          END IF
          wt(np) = wt(np)*1.0/cs_enhance_current
          return
        END IF
        IF (( ( iarg .EQ. 18  .OR. iarg .EQ. 20  .OR. iarg .EQ. 24)  .AN
     *  D. ienhance .EQ. 1 )) THEN
          ienhance=0
          DO 1671 ip=NPold,NP
            IF (( iq(ip) .EQ. 0 )) THEN
              IF((rng_seed .GT. 128))call ranmar_get
              R1 = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF ((R1.LT.1.0/cs_enhance_current)) THEN
                WT(ip)=WT(ip)*cs_enhance_current
              ELSE
                wt(ip) = 0
                e(ip) = 0
                dnear(ip) = -1
              END IF
            END IF
1671      CONTINUE
1672      CONTINUE
          return
        END IF
      END IF
      IRL=IR(NP)
      IF ((IRL .EQ. 1)) THEN
        IF((IWATCH .GT. 0))CALL WATCH(IARG,IWATCH)
        RETURN
      END IF
      IRL=IR(NP)
      IF((IRL.EQ.1))RETURN
      IZD=IDSTBL(IRL,1)
      IXD=IDSTBL(IRL,2)
      IQL=IQ(NP)
      IF ((IARG .EQ. 0)) THEN
        IF ((IQL.NE.0)) THEN
          IF ((NHSTRY.EQ.SCSTP_LAST)) THEN
            SCSTP_TMP=SCSTP_TMP + 1
          ELSE
            SCSTP=SCSTP+SCSTP_TMP
            SCSTP2=SCSTP2 + SCSTP_TMP*SCSTP_TMP
            SCSTP_TMP=1
            SCSTP_LAST=NHSTRY
          END IF
          IF ((CDSTBL(IRL).EQ.DCHAR)) THEN
            IF ((NHSTRY.EQ.SCDSTP_LAST)) THEN
              SCDSTP_TMP=SCDSTP_TMP + 1
            ELSE
              SCDSTP=SCDSTP+SCDSTP_TMP
              SCDSTP2=SCDSTP2 + SCDSTP_TMP*SCDSTP_TMP
              SCDSTP_TMP=1
              SCDSTP_LAST=NHSTRY
            END IF
          END IF
        ELSE
          IF ((RUSROU.AND.(W(NP).GT.0.0))) THEN
            IF (((Z(NP).LE.RRZ).AND.(Z(NP)+USTEP*W(NP).GE.RRZ))) THEN
              IF((rng_seed .GT. 128))call ranmar_get
              XSI = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF ((XSI.LT.RRCUT)) THEN
                WT(NP)=WT(NP)/RRCUT
              ELSE
                WT(NP)=0.0
              END IF
            END IF
          END IF
        END IF
      END IF
      IF((IWATCH.GT.0))CALL WATCH(IARG,IWATCH)
      IF ((IFULL .EQ. 1)) THEN
        IF ((IARG.EQ.16 .OR. IARG.EQ.18 .OR. IARG.EQ.20)) THEN
          IF ((NP.GE.NPold)) THEN
            DO 1681 II=NPold,NP
              IF ((IQ(II).NE.0)) THEN
                DO 1691 I=1,5
                  LATCH(II)=IBCLR(LATCH(II),I)
1691            CONTINUE
1692            CONTINUE
                LATCH(II)=IBSET(LATCH(II),5)
              END IF
1681        CONTINUE
1682        CONTINUE
          END IF
        ELSE IF((IQ(NP).EQ.0 .AND. (IARG.EQ.1 .OR. IARG.EQ.2))) THEN
          DO 1701 I=1,5
            LATCH(NP)=IBCLR(LATCH(NP),I)
1701      CONTINUE
1702      CONTINUE
          LATCH(NP)=IBSET(LATCH(NP),5)
        ELSE IF((((IARG.EQ.5).AND.(IRNEW.NE.IROLD)).OR.DECISION.EQ.1)) T
     *  HEN
          DO 1711 I=1,5
            LATCH(NP)=IBCLR(LATCH(NP),I)
1711      CONTINUE
1712      CONTINUE
          LATCH(NP)=IBSET(LATCH(NP),NEWNRC/10)
          DECISION=0
        END IF
      ELSE IF((IFULL .EQ. 3)) THEN
        IF (( iarg .EQ. 18 )) THEN
          IF (( NP .GT. NPold .OR. i_survived_rr .GT. 0 )) THEN
            DO 1721 ip=NPold,NP
              IF (( iq(ip) .EQ. 0 )) THEN
                latch(ip) = IBSET(latch(ip),6)
              END IF
1721        CONTINUE
1722        CONTINUE
          END IF
        ELSE IF(( iarg .EQ. 20 )) THEN
          IF (( NP .GT. NPold .OR. i_survived_rr.GT.0 )) THEN
            DO 1731 ip=NPold,NP
              IF (( iq(ip) .EQ. 0 )) THEN
                latch(ip) = IBSET(latch(ip),7)
              END IF
1731        CONTINUE
1732        CONTINUE
          END IF
        END IF
      END IF
      IF ((IKERMA .EQ. 1)) THEN
        IF (( iarg .EQ. 19 .OR. iarg .EQ. 17 )) THEN
          during_pe_compt = 1
          return
        END IF
        IF (( iarg .EQ. 20 .OR. iarg .EQ. 18 )) THEN
          during_pe_compt = 0
        END IF
        IF (( iarg .EQ. 31 )) THEN
          during_eii = 1
          return
        END IF
        IF (( iarg .EQ. 32 )) THEN
          during_eii = 0
          return
        END IF
        IF ((IARG .EQ. 4 .AND. .NOT.BTEST(LATCH(NP),8) .AND. during_eii
     *  .EQ. 0 .AND. during_pe_compt .EQ. 0)) THEN
          IF ((NHSTRY.EQ.SCKERMA_LAST(IZD,IXD,1))) THEN
            SCKERMA_TMP(IZD,IXD,1)=SCKERMA_TMP(IZD,IXD,1) + WT(NP)*EDEP
          ELSE
            SCKERMA(IZD,IXD,1)=SCKERMA(IZD,IXD,1)+SCKERMA_TMP(IZD,IXD,1)
            SCKERMA2(IZD,IXD,1)=SCKERMA2(IZD,IXD,1) + SCKERMA_TMP(IZD,IX
     *      D,1)*SCKERMA_TMP(IZD,IXD,1)
            IF (('SCKERMA'.EQ.'SCKERMA')) THEN
              SCKERMA_TMPOLD(IZD,IXD,1)=SCKERMA_TMP(IZD,IXD,1)
              SCKERMA_LASTOLD(IZD,IXD,1)=SCKERMA_LAST(IZD,IXD,1)
            ELSE IF(('SCKERMA'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND. SCKER
     *      MA_LAST(IZD,IXD,1).EQ.SCKERMA_LASTOLD(IZD,IXD,1))) THEN
              SCDOSEtoKERMA2(IZD,IXD,1)=SCDOSEtoKERMA2(IZD,IXD,1)+SCKERM
     *        A_TMP(IZD,IXD,1)* SCKERMA_TMPOLD(IZD,IXD,1)
            END IF
            SCKERMA_TMP(IZD,IXD,1)=WT(NP)*EDEP
            SCKERMA_LAST(IZD,IXD,1)=NHSTRY
          END IF
          IF ((IFULL.EQ.3 .AND. (BTEST(LATCH(NP),6) .OR. BTEST(LATCH(NP)
     *    ,7)))) THEN
            IF ((NHSTRY.EQ.SCKERMA_LAST(IZD,IXD,2))) THEN
              SCKERMA_TMP(IZD,IXD,2)=SCKERMA_TMP(IZD,IXD,2) + WT(NP)*EDE
     *        P
            ELSE
              SCKERMA(IZD,IXD,2)=SCKERMA(IZD,IXD,2)+SCKERMA_TMP(IZD,IXD,
     *        2)
              SCKERMA2(IZD,IXD,2)=SCKERMA2(IZD,IXD,2) + SCKERMA_TMP(IZD,
     *        IXD,2)*SCKERMA_TMP(IZD,IXD,2)
              IF (('SCKERMA'.EQ.'SCKERMA')) THEN
                SCKERMA_TMPOLD(IZD,IXD,2)=SCKERMA_TMP(IZD,IXD,2)
                SCKERMA_LASTOLD(IZD,IXD,2)=SCKERMA_LAST(IZD,IXD,2)
              ELSE IF(('SCKERMA'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND. SCK
     *        ERMA_LAST(IZD,IXD,2).EQ.SCKERMA_LASTOLD(IZD,IXD,2))) THEN
                SCDOSEtoKERMA2(IZD,IXD,2)=SCDOSEtoKERMA2(IZD,IXD,2)+SCKE
     *          RMA_TMP(IZD,IXD,2)* SCKERMA_TMPOLD(IZD,IXD,2)
              END IF
              SCKERMA_TMP(IZD,IXD,2)=WT(NP)*EDEP
              SCKERMA_LAST(IZD,IXD,2)=NHSTRY
            END IF
          END IF
        END IF
        IF (( iarg .EQ. 34 )) THEN
          IF (( during_pe_compt .EQ. 1 )) THEN
            IF ((NHSTRY.EQ.SCKERMA_LAST(IZD,IXD,1))) THEN
              SCKERMA_TMP(IZD,IXD,1)=SCKERMA_TMP(IZD,IXD,1) + WT(NP)*ede
     *        p_local
            ELSE
              SCKERMA(IZD,IXD,1)=SCKERMA(IZD,IXD,1)+SCKERMA_TMP(IZD,IXD,
     *        1)
              SCKERMA2(IZD,IXD,1)=SCKERMA2(IZD,IXD,1) + SCKERMA_TMP(IZD,
     *        IXD,1)*SCKERMA_TMP(IZD,IXD,1)
              IF (('SCKERMA'.EQ.'SCKERMA')) THEN
                SCKERMA_TMPOLD(IZD,IXD,1)=SCKERMA_TMP(IZD,IXD,1)
                SCKERMA_LASTOLD(IZD,IXD,1)=SCKERMA_LAST(IZD,IXD,1)
              ELSE IF(('SCKERMA'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND. SCK
     *        ERMA_LAST(IZD,IXD,1).EQ.SCKERMA_LASTOLD(IZD,IXD,1))) THEN
                SCDOSEtoKERMA2(IZD,IXD,1)=SCDOSEtoKERMA2(IZD,IXD,1)+SCKE
     *          RMA_TMP(IZD,IXD,1)* SCKERMA_TMPOLD(IZD,IXD,1)
              END IF
              SCKERMA_TMP(IZD,IXD,1)=WT(NP)*edep_local
              SCKERMA_LAST(IZD,IXD,1)=NHSTRY
            END IF
            IF ((IFULL.EQ.3 .AND. (BTEST(LATCH(NP),6) .OR. BTEST(LATCH(N
     *      P),7)))) THEN
              IF ((NHSTRY.EQ.SCKERMA_LAST(IZD,IXD,2))) THEN
                SCKERMA_TMP(IZD,IXD,2)=SCKERMA_TMP(IZD,IXD,2) + WT(NP)*e
     *          dep_local
              ELSE
                SCKERMA(IZD,IXD,2)=SCKERMA(IZD,IXD,2)+SCKERMA_TMP(IZD,IX
     *          D,2)
                SCKERMA2(IZD,IXD,2)=SCKERMA2(IZD,IXD,2) + SCKERMA_TMP(IZ
     *          D,IXD,2)*SCKERMA_TMP(IZD,IXD,2)
                IF (('SCKERMA'.EQ.'SCKERMA')) THEN
                  SCKERMA_TMPOLD(IZD,IXD,2)=SCKERMA_TMP(IZD,IXD,2)
                  SCKERMA_LASTOLD(IZD,IXD,2)=SCKERMA_LAST(IZD,IXD,2)
                ELSE IF(('SCKERMA'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND. S
     *          CKERMA_LAST(IZD,IXD,2).EQ.SCKERMA_LASTOLD(IZD,IXD,2))) T
     *          HEN
                  SCDOSEtoKERMA2(IZD,IXD,2)=SCDOSEtoKERMA2(IZD,IXD,2)+SC
     *            KERMA_TMP(IZD,IXD,2)* SCKERMA_TMPOLD(IZD,IXD,2)
                END IF
                SCKERMA_TMP(IZD,IXD,2)=WT(NP)*edep_local
                SCKERMA_LAST(IZD,IXD,2)=NHSTRY
              END IF
            END IF
            return
          ELSE
            return
          END IF
        END IF
        IF ((IARG .EQ. 16)) THEN
          IF ((NP.GT.NPold .OR. i_survived_rr .GT. 0)) THEN
            DO 1741 IP=NPold,NP
              IF ((IQ(IP).NE.0 .AND. .NOT.BTEST(LATCH(IP),8))) THEN
                IF ((NHSTRY.EQ.SCKERMA_LAST(IZD,IXD,1))) THEN
                  SCKERMA_TMP(IZD,IXD,1)=SCKERMA_TMP(IZD,IXD,1) + WT(IP)
     *            *(E(IP)-PRM)
                ELSE
                  SCKERMA(IZD,IXD,1)=SCKERMA(IZD,IXD,1)+SCKERMA_TMP(IZD,
     *            IXD,1)
                  SCKERMA2(IZD,IXD,1)=SCKERMA2(IZD,IXD,1) + SCKERMA_TMP(
     *            IZD,IXD,1)*SCKERMA_TMP(IZD,IXD,1)
                  IF (('SCKERMA'.EQ.'SCKERMA')) THEN
                    SCKERMA_TMPOLD(IZD,IXD,1)=SCKERMA_TMP(IZD,IXD,1)
                    SCKERMA_LASTOLD(IZD,IXD,1)=SCKERMA_LAST(IZD,IXD,1)
                  ELSE IF(('SCKERMA'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND.
     *             SCKERMA_LAST(IZD,IXD,1).EQ.SCKERMA_LASTOLD(IZD,IXD,1)
     *            )) THEN
                    SCDOSEtoKERMA2(IZD,IXD,1)=SCDOSEtoKERMA2(IZD,IXD,1)+
     *              SCKERMA_TMP(IZD,IXD,1)* SCKERMA_TMPOLD(IZD,IXD,1)
                  END IF
                  SCKERMA_TMP(IZD,IXD,1)=WT(IP)*(E(IP)-PRM)
                  SCKERMA_LAST(IZD,IXD,1)=NHSTRY
                END IF
                IF ((IFULL .EQ. 3 .AND. (BTEST(LATCH(IP),6) .OR. BTEST(L
     *          ATCH(IP),7)))) THEN
                  IF ((NHSTRY.EQ.SCKERMA_LAST(IZD,IXD,2))) THEN
                    SCKERMA_TMP(IZD,IXD,2)=SCKERMA_TMP(IZD,IXD,2) + WT(I
     *              P)*(E(IP)-PRM)
                  ELSE
                    SCKERMA(IZD,IXD,2)=SCKERMA(IZD,IXD,2)+SCKERMA_TMP(IZ
     *              D,IXD,2)
                    SCKERMA2(IZD,IXD,2)=SCKERMA2(IZD,IXD,2) + SCKERMA_TM
     *              P(IZD,IXD,2)*SCKERMA_TMP(IZD,IXD,2)
                    IF (('SCKERMA'.EQ.'SCKERMA')) THEN
                      SCKERMA_TMPOLD(IZD,IXD,2)=SCKERMA_TMP(IZD,IXD,2)
                      SCKERMA_LASTOLD(IZD,IXD,2)=SCKERMA_LAST(IZD,IXD,2)
                    ELSE IF(('SCKERMA'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AN
     *              D. SCKERMA_LAST(IZD,IXD,2).EQ.SCKERMA_LASTOLD(IZD,IX
     *              D,2))) THEN
                      SCDOSEtoKERMA2(IZD,IXD,2)=SCDOSEtoKERMA2(IZD,IXD,2
     *                )+SCKERMA_TMP(IZD,IXD,2)* SCKERMA_TMPOLD(IZD,IXD,2
     *                )
                    END IF
                    SCKERMA_TMP(IZD,IXD,2)=WT(IP)*(E(IP)-PRM)
                    SCKERMA_LAST(IZD,IXD,2)=NHSTRY
                  END IF
                END IF
              END IF
1741        CONTINUE
1742        CONTINUE
          END IF
        END IF
        IF ((IARG .EQ. 18)) THEN
          IF ((NP.GT.NPold)) THEN
            DO 1751 IP=NPold,NP
              IF ((IQ(IP) .NE. 0 .AND. .NOT.BTEST(LATCH(IP),8))) THEN
                IF ((NHSTRY.EQ.SCKERMA_LAST(IZD,IXD,1))) THEN
                  SCKERMA_TMP(IZD,IXD,1)=SCKERMA_TMP(IZD,IXD,1) + WT(IP)
     *            *(E(IP) - PRM)
                ELSE
                  SCKERMA(IZD,IXD,1)=SCKERMA(IZD,IXD,1)+SCKERMA_TMP(IZD,
     *            IXD,1)
                  SCKERMA2(IZD,IXD,1)=SCKERMA2(IZD,IXD,1) + SCKERMA_TMP(
     *            IZD,IXD,1)*SCKERMA_TMP(IZD,IXD,1)
                  IF (('SCKERMA'.EQ.'SCKERMA')) THEN
                    SCKERMA_TMPOLD(IZD,IXD,1)=SCKERMA_TMP(IZD,IXD,1)
                    SCKERMA_LASTOLD(IZD,IXD,1)=SCKERMA_LAST(IZD,IXD,1)
                  ELSE IF(('SCKERMA'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND.
     *             SCKERMA_LAST(IZD,IXD,1).EQ.SCKERMA_LASTOLD(IZD,IXD,1)
     *            )) THEN
                    SCDOSEtoKERMA2(IZD,IXD,1)=SCDOSEtoKERMA2(IZD,IXD,1)+
     *              SCKERMA_TMP(IZD,IXD,1)* SCKERMA_TMPOLD(IZD,IXD,1)
                  END IF
                  SCKERMA_TMP(IZD,IXD,1)=WT(IP)*(E(IP) - PRM)
                  SCKERMA_LAST(IZD,IXD,1)=NHSTRY
                END IF
                IF ((IFULL.EQ.3 .AND. (BTEST(LATCH(IP),6) .OR. BTEST(LAT
     *          CH(IP),7)))) THEN
                  IF ((NHSTRY.EQ.SCKERMA_LAST(IZD,IXD,2))) THEN
                    SCKERMA_TMP(IZD,IXD,2)=SCKERMA_TMP(IZD,IXD,2) + WT(I
     *              P)*(E(IP)-PRM)
                  ELSE
                    SCKERMA(IZD,IXD,2)=SCKERMA(IZD,IXD,2)+SCKERMA_TMP(IZ
     *              D,IXD,2)
                    SCKERMA2(IZD,IXD,2)=SCKERMA2(IZD,IXD,2) + SCKERMA_TM
     *              P(IZD,IXD,2)*SCKERMA_TMP(IZD,IXD,2)
                    IF (('SCKERMA'.EQ.'SCKERMA')) THEN
                      SCKERMA_TMPOLD(IZD,IXD,2)=SCKERMA_TMP(IZD,IXD,2)
                      SCKERMA_LASTOLD(IZD,IXD,2)=SCKERMA_LAST(IZD,IXD,2)
                    ELSE IF(('SCKERMA'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AN
     *              D. SCKERMA_LAST(IZD,IXD,2).EQ.SCKERMA_LASTOLD(IZD,IX
     *              D,2))) THEN
                      SCDOSEtoKERMA2(IZD,IXD,2)=SCDOSEtoKERMA2(IZD,IXD,2
     *                )+SCKERMA_TMP(IZD,IXD,2)* SCKERMA_TMPOLD(IZD,IXD,2
     *                )
                    END IF
                    SCKERMA_TMP(IZD,IXD,2)=WT(IP)*(E(IP)-PRM)
                    SCKERMA_LAST(IZD,IXD,2)=NHSTRY
                  END IF
                END IF
              END IF
1751        CONTINUE
1752        CONTINUE
          END IF
        END IF
        IF ((IARG .EQ. 20)) THEN
          DO 1761 IP=NPold,NP
            IF ((IQ(IP).NE.0 .AND. .NOT.BTEST(LATCH(IP),8))) THEN
              IF ((NHSTRY.EQ.SCKERMA_LAST(IZD,IXD,1))) THEN
                SCKERMA_TMP(IZD,IXD,1)=SCKERMA_TMP(IZD,IXD,1) + WT(IP)*(
     *          E(IP) - PRM)
              ELSE
                SCKERMA(IZD,IXD,1)=SCKERMA(IZD,IXD,1)+SCKERMA_TMP(IZD,IX
     *          D,1)
                SCKERMA2(IZD,IXD,1)=SCKERMA2(IZD,IXD,1) + SCKERMA_TMP(IZ
     *          D,IXD,1)*SCKERMA_TMP(IZD,IXD,1)
                IF (('SCKERMA'.EQ.'SCKERMA')) THEN
                  SCKERMA_TMPOLD(IZD,IXD,1)=SCKERMA_TMP(IZD,IXD,1)
                  SCKERMA_LASTOLD(IZD,IXD,1)=SCKERMA_LAST(IZD,IXD,1)
                ELSE IF(('SCKERMA'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND. S
     *          CKERMA_LAST(IZD,IXD,1).EQ.SCKERMA_LASTOLD(IZD,IXD,1))) T
     *          HEN
                  SCDOSEtoKERMA2(IZD,IXD,1)=SCDOSEtoKERMA2(IZD,IXD,1)+SC
     *            KERMA_TMP(IZD,IXD,1)* SCKERMA_TMPOLD(IZD,IXD,1)
                END IF
                SCKERMA_TMP(IZD,IXD,1)=WT(IP)*(E(IP) - PRM)
                SCKERMA_LAST(IZD,IXD,1)=NHSTRY
              END IF
              IF ((IFULL .EQ. 3 .AND. (BTEST(LATCH(IP),6) .OR. BTEST(LAT
     *        CH(IP),7)))) THEN
                IF ((NHSTRY.EQ.SCKERMA_LAST(IZD,IXD,2))) THEN
                  SCKERMA_TMP(IZD,IXD,2)=SCKERMA_TMP(IZD,IXD,2) + WT(IP)
     *            *(E(IP)-PRM)
                ELSE
                  SCKERMA(IZD,IXD,2)=SCKERMA(IZD,IXD,2)+SCKERMA_TMP(IZD,
     *            IXD,2)
                  SCKERMA2(IZD,IXD,2)=SCKERMA2(IZD,IXD,2) + SCKERMA_TMP(
     *            IZD,IXD,2)*SCKERMA_TMP(IZD,IXD,2)
                  IF (('SCKERMA'.EQ.'SCKERMA')) THEN
                    SCKERMA_TMPOLD(IZD,IXD,2)=SCKERMA_TMP(IZD,IXD,2)
                    SCKERMA_LASTOLD(IZD,IXD,2)=SCKERMA_LAST(IZD,IXD,2)
                  ELSE IF(('SCKERMA'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND.
     *             SCKERMA_LAST(IZD,IXD,2).EQ.SCKERMA_LASTOLD(IZD,IXD,2)
     *            )) THEN
                    SCDOSEtoKERMA2(IZD,IXD,2)=SCDOSEtoKERMA2(IZD,IXD,2)+
     *              SCKERMA_TMP(IZD,IXD,2)* SCKERMA_TMPOLD(IZD,IXD,2)
                  END IF
                  SCKERMA_TMP(IZD,IXD,2)=WT(IP)*(E(IP)-PRM)
                  SCKERMA_LAST(IZD,IXD,2)=NHSTRY
                END IF
              END IF
            END IF
1761      CONTINUE
1762      CONTINUE
        END IF
      END IF
      IF((IARG.GE.5.OR.EDEP.EQ.0))RETURN
      FTMP=WT(NP)*EDEP
      IF ((CDSTBL(IRL).EQ.DCHAR)) THEN
        IF ((NHSTRY.EQ.SCDOSE_LAST(IZD,IXD,1))) THEN
          SCDOSE_TMP(IZD,IXD,1)=SCDOSE_TMP(IZD,IXD,1) + FTMP
        ELSE
          SCDOSE(IZD,IXD,1)=SCDOSE(IZD,IXD,1)+SCDOSE_TMP(IZD,IXD,1)
          SCDOSE2(IZD,IXD,1)=SCDOSE2(IZD,IXD,1) + SCDOSE_TMP(IZD,IXD,1)*
     *    SCDOSE_TMP(IZD,IXD,1)
          IF (('SCDOSE'.EQ.'SCKERMA')) THEN
            SCKERMA_TMPOLD(IZD,IXD,1)=SCDOSE_TMP(IZD,IXD,1)
            SCKERMA_LASTOLD(IZD,IXD,1)=SCDOSE_LAST(IZD,IXD,1)
          ELSE IF(('SCDOSE'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND. SCDOSE_L
     *    AST(IZD,IXD,1).EQ.SCKERMA_LASTOLD(IZD,IXD,1))) THEN
            SCDOSEtoKERMA2(IZD,IXD,1)=SCDOSEtoKERMA2(IZD,IXD,1)+SCDOSE_T
     *      MP(IZD,IXD,1)* SCKERMA_TMPOLD(IZD,IXD,1)
          END IF
          SCDOSE_TMP(IZD,IXD,1)=FTMP
          SCDOSE_LAST(IZD,IXD,1)=NHSTRY
        END IF
        IF (((IFULL .EQ. 3) .AND. (BTEST(LATCH(NP),6) .OR. BTEST(LATCH(N
     *  P),7)))) THEN
          IF ((NHSTRY.EQ.SCDOSE_LAST(IZD,IXD,2))) THEN
            SCDOSE_TMP(IZD,IXD,2)=SCDOSE_TMP(IZD,IXD,2) + FTMP
          ELSE
            SCDOSE(IZD,IXD,2)=SCDOSE(IZD,IXD,2)+SCDOSE_TMP(IZD,IXD,2)
            SCDOSE2(IZD,IXD,2)=SCDOSE2(IZD,IXD,2) + SCDOSE_TMP(IZD,IXD,2
     *      )*SCDOSE_TMP(IZD,IXD,2)
            IF (('SCDOSE'.EQ.'SCKERMA')) THEN
              SCKERMA_TMPOLD(IZD,IXD,2)=SCDOSE_TMP(IZD,IXD,2)
              SCKERMA_LASTOLD(IZD,IXD,2)=SCDOSE_LAST(IZD,IXD,2)
            ELSE IF(('SCDOSE'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND. SCDOSE
     *      _LAST(IZD,IXD,2).EQ.SCKERMA_LASTOLD(IZD,IXD,2))) THEN
              SCDOSEtoKERMA2(IZD,IXD,2)=SCDOSEtoKERMA2(IZD,IXD,2)+SCDOSE
     *        _TMP(IZD,IXD,2)* SCKERMA_TMPOLD(IZD,IXD,2)
            END IF
            SCDOSE_TMP(IZD,IXD,2)=FTMP
            SCDOSE_LAST(IZD,IXD,2)=NHSTRY
          END IF
        END IF
        IF ((IARG.EQ.0)) THEN
          IF ((IFULL.NE.3)) THEN
            IF ((NHSTRY.EQ.SCDOSE_LAST(IZD,IXD,2))) THEN
              SCDOSE_TMP(IZD,IXD,2)=SCDOSE_TMP(IZD,IXD,2) + FTMP
            ELSE
              SCDOSE(IZD,IXD,2)=SCDOSE(IZD,IXD,2)+SCDOSE_TMP(IZD,IXD,2)
              SCDOSE2(IZD,IXD,2)=SCDOSE2(IZD,IXD,2) + SCDOSE_TMP(IZD,IXD
     *        ,2)*SCDOSE_TMP(IZD,IXD,2)
              IF (('SCDOSE'.EQ.'SCKERMA')) THEN
                SCKERMA_TMPOLD(IZD,IXD,2)=SCDOSE_TMP(IZD,IXD,2)
                SCKERMA_LASTOLD(IZD,IXD,2)=SCDOSE_LAST(IZD,IXD,2)
              ELSE IF(('SCDOSE'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND. SCDO
     *        SE_LAST(IZD,IXD,2).EQ.SCKERMA_LASTOLD(IZD,IXD,2))) THEN
                SCDOSEtoKERMA2(IZD,IXD,2)=SCDOSEtoKERMA2(IZD,IXD,2)+SCDO
     *          SE_TMP(IZD,IXD,2)* SCKERMA_TMPOLD(IZD,IXD,2)
              END IF
              SCDOSE_TMP(IZD,IXD,2)=FTMP
              SCDOSE_LAST(IZD,IXD,2)=NHSTRY
            END IF
          END IF
        END IF
        IF (((IWATCH.GT.1).AND.(IWATCH.NE.4))) THEN
          WRITE(6,1770)FTMP,IRL,IARG
1770      FORMAT(9x,' ***weighted dose deposition  = ',1PE14.7, ' MeV. I
     *RL= ',I3, ' IARG= ',I3)
        END IF
      END IF
      IF ((IFULL.EQ.1)) THEN
        IF ((CDSTBL(IRL).EQ.DCHAR)) THEN
          IX=(IRL-2)/NZ+1
          IZ=IRL-1-NZ*(IX-1)
          DO 1781 I=1,5
            IF ((BTEST(LATCH(NP),I))) THEN
              IGEOM=I*10
              GO TO1782
            END IF
1781      CONTINUE
1782      CONTINUE
          IF ((IGEOM.EQ.10)) THEN
            IF ((NHSTRY.EQ.SCDOSE_LAST(IZD,IXD,3))) THEN
              SCDOSE_TMP(IZD,IXD,3)=SCDOSE_TMP(IZD,IXD,3) + FTMP
            ELSE
              SCDOSE(IZD,IXD,3)=SCDOSE(IZD,IXD,3)+SCDOSE_TMP(IZD,IXD,3)
              SCDOSE2(IZD,IXD,3)=SCDOSE2(IZD,IXD,3) + SCDOSE_TMP(IZD,IXD
     *        ,3)*SCDOSE_TMP(IZD,IXD,3)
              IF (('SCDOSE'.EQ.'SCKERMA')) THEN
                SCKERMA_TMPOLD(IZD,IXD,3)=SCDOSE_TMP(IZD,IXD,3)
                SCKERMA_LASTOLD(IZD,IXD,3)=SCDOSE_LAST(IZD,IXD,3)
              ELSE IF(('SCDOSE'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND. SCDO
     *        SE_LAST(IZD,IXD,3).EQ.SCKERMA_LASTOLD(IZD,IXD,3))) THEN
                SCDOSEtoKERMA2(IZD,IXD,3)=SCDOSEtoKERMA2(IZD,IXD,3)+SCDO
     *          SE_TMP(IZD,IXD,3)* SCKERMA_TMPOLD(IZD,IXD,3)
              END IF
              SCDOSE_TMP(IZD,IXD,3)=FTMP
              SCDOSE_LAST(IZD,IXD,3)=NHSTRY
            END IF
          ELSE IF((IGEOM.EQ.20)) THEN
            IF ((NHSTRY.EQ.SCDOSE_LAST(IZD,IXD,4))) THEN
              SCDOSE_TMP(IZD,IXD,4)=SCDOSE_TMP(IZD,IXD,4) + FTMP
            ELSE
              SCDOSE(IZD,IXD,4)=SCDOSE(IZD,IXD,4)+SCDOSE_TMP(IZD,IXD,4)
              SCDOSE2(IZD,IXD,4)=SCDOSE2(IZD,IXD,4) + SCDOSE_TMP(IZD,IXD
     *        ,4)*SCDOSE_TMP(IZD,IXD,4)
              IF (('SCDOSE'.EQ.'SCKERMA')) THEN
                SCKERMA_TMPOLD(IZD,IXD,4)=SCDOSE_TMP(IZD,IXD,4)
                SCKERMA_LASTOLD(IZD,IXD,4)=SCDOSE_LAST(IZD,IXD,4)
              ELSE IF(('SCDOSE'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND. SCDO
     *        SE_LAST(IZD,IXD,4).EQ.SCKERMA_LASTOLD(IZD,IXD,4))) THEN
                SCDOSEtoKERMA2(IZD,IXD,4)=SCDOSEtoKERMA2(IZD,IXD,4)+SCDO
     *          SE_TMP(IZD,IXD,4)* SCKERMA_TMPOLD(IZD,IXD,4)
              END IF
              SCDOSE_TMP(IZD,IXD,4)=FTMP
              SCDOSE_LAST(IZD,IXD,4)=NHSTRY
            END IF
          ELSE IF((IGEOM.EQ.30)) THEN
            IF ((NHSTRY.EQ.SCDOSE_LAST(IZD,IXD,5))) THEN
              SCDOSE_TMP(IZD,IXD,5)=SCDOSE_TMP(IZD,IXD,5) + FTMP
            ELSE
              SCDOSE(IZD,IXD,5)=SCDOSE(IZD,IXD,5)+SCDOSE_TMP(IZD,IXD,5)
              SCDOSE2(IZD,IXD,5)=SCDOSE2(IZD,IXD,5) + SCDOSE_TMP(IZD,IXD
     *        ,5)*SCDOSE_TMP(IZD,IXD,5)
              IF (('SCDOSE'.EQ.'SCKERMA')) THEN
                SCKERMA_TMPOLD(IZD,IXD,5)=SCDOSE_TMP(IZD,IXD,5)
                SCKERMA_LASTOLD(IZD,IXD,5)=SCDOSE_LAST(IZD,IXD,5)
              ELSE IF(('SCDOSE'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND. SCDO
     *        SE_LAST(IZD,IXD,5).EQ.SCKERMA_LASTOLD(IZD,IXD,5))) THEN
                SCDOSEtoKERMA2(IZD,IXD,5)=SCDOSEtoKERMA2(IZD,IXD,5)+SCDO
     *          SE_TMP(IZD,IXD,5)* SCKERMA_TMPOLD(IZD,IXD,5)
              END IF
              SCDOSE_TMP(IZD,IXD,5)=FTMP
              SCDOSE_LAST(IZD,IXD,5)=NHSTRY
            END IF
          ELSE IF((IGEOM.EQ.40)) THEN
            IF ((NHSTRY.EQ.SCDOSE_LAST(IZD,IXD,6))) THEN
              SCDOSE_TMP(IZD,IXD,6)=SCDOSE_TMP(IZD,IXD,6) + FTMP
            ELSE
              SCDOSE(IZD,IXD,6)=SCDOSE(IZD,IXD,6)+SCDOSE_TMP(IZD,IXD,6)
              SCDOSE2(IZD,IXD,6)=SCDOSE2(IZD,IXD,6) + SCDOSE_TMP(IZD,IXD
     *        ,6)*SCDOSE_TMP(IZD,IXD,6)
              IF (('SCDOSE'.EQ.'SCKERMA')) THEN
                SCKERMA_TMPOLD(IZD,IXD,6)=SCDOSE_TMP(IZD,IXD,6)
                SCKERMA_LASTOLD(IZD,IXD,6)=SCDOSE_LAST(IZD,IXD,6)
              ELSE IF(('SCDOSE'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND. SCDO
     *        SE_LAST(IZD,IXD,6).EQ.SCKERMA_LASTOLD(IZD,IXD,6))) THEN
                SCDOSEtoKERMA2(IZD,IXD,6)=SCDOSEtoKERMA2(IZD,IXD,6)+SCDO
     *          SE_TMP(IZD,IXD,6)* SCKERMA_TMPOLD(IZD,IXD,6)
              END IF
              SCDOSE_TMP(IZD,IXD,6)=FTMP
              SCDOSE_LAST(IZD,IXD,6)=NHSTRY
            END IF
            IF ((IX.EQ.1)) THEN
              IGBUG2=IGBUG2+1
              IF ((IGBUG2.LE.100)) THEN
                WRITE(6,1790)IGBUG2,IGEOM
1790            FORMAT(' **** INSIDE DOSE???. BUG NO.',I3,' IGEOM=',I3)
              END IF
            END IF
          ELSE IF((IGEOM.EQ.50)) THEN
            IF ((NHSTRY.EQ.SCDOSE_LAST(IZD,IXD,7))) THEN
              SCDOSE_TMP(IZD,IXD,7)=SCDOSE_TMP(IZD,IXD,7) + FTMP
            ELSE
              SCDOSE(IZD,IXD,7)=SCDOSE(IZD,IXD,7)+SCDOSE_TMP(IZD,IXD,7)
              SCDOSE2(IZD,IXD,7)=SCDOSE2(IZD,IXD,7) + SCDOSE_TMP(IZD,IXD
     *        ,7)*SCDOSE_TMP(IZD,IXD,7)
              IF (('SCDOSE'.EQ.'SCKERMA')) THEN
                SCKERMA_TMPOLD(IZD,IXD,7)=SCDOSE_TMP(IZD,IXD,7)
                SCKERMA_LASTOLD(IZD,IXD,7)=SCDOSE_LAST(IZD,IXD,7)
              ELSE IF(('SCDOSE'.EQ.'SCDOSE' .AND. IKERMA.EQ.1 .AND. SCDO
     *        SE_LAST(IZD,IXD,7).EQ.SCKERMA_LASTOLD(IZD,IXD,7))) THEN
                SCDOSEtoKERMA2(IZD,IXD,7)=SCDOSEtoKERMA2(IZD,IXD,7)+SCDO
     *          SE_TMP(IZD,IXD,7)* SCKERMA_TMPOLD(IZD,IXD,7)
              END IF
              SCDOSE_TMP(IZD,IXD,7)=FTMP
              SCDOSE_LAST(IZD,IXD,7)=NHSTRY
            END IF
          ELSE
            IGBUG1=IGBUG1+1
            IF ((IGBUG1.LE.100)) THEN
              WRITE(6,1800)IGBUG1,IGEOM
1800          FORMAT(' **** LOST REGION. BUG NO.',I3,' IGEOM=',I3)
            END IF
          END IF
        END IF
        IF (((NP.GT.1).AND.(IARG.GE.1).AND.(IARG.LE.3))) THEN
          DO 1811 I=1,5
            IF ((BTEST(LATCH(NP-1),I))) THEN
              NEWNRC=I*10
              GO TO1812
            END IF
1811      CONTINUE
1812      CONTINUE
        END IF
      END IF
      IF ((IFULL.EQ.2 .AND. IPHR(IRL).NE.0)) THEN
        IF ((NHSTRY.EQ.SCPDST_LAST)) THEN
          PHENER=PHENER+EDEP
          WT1OLD=WT(1)
        ELSE
          IF ((PHENER.GT.0.)) THEN
            IF ((SLOTE.GT.0.0)) THEN
              IB=MIN0(int(PHENER/SLOTE+0.999),500)
            ELSE
              IB = MAXBIN
1821          IF(((IB.EQ.1).OR.(BINTOP(IB-1).LT.PHENER)))GO TO 1822
                IB=IB-1
              GO TO 1821
1822          CONTINUE
            END IF
            SCPDST(IB)=SCPDST(IB)+WT1OLD
            SCPDST2(IB)=SCPDST2(IB)+WT1OLD*WT1OLD
            DO 1831 ICUM=IB,MAXBIN
              SCPCUM(ICUM)=SCPCUM(ICUM)+WT1OLD
              SCPCUM2(ICUM)=SCPCUM2(ICUM)+WT1OLD*WT1OLD
1831        CONTINUE
1832        CONTINUE
            IF ((IWATCH.EQ.3)) THEN
              WRITE(6,1840)PHENER,IB,1
1840          FORMAT(' Pulse height energy=', F10.4,' MeV, in bin',I3,'w
     *ith WEIGHT',1PE10.3)
            END IF
            DO 1851 IPK=1,4
              IF (((PHENER.GE.DFEN(IPK,2)).AND.(PHENER.LE.DFEN(IPK,3))))
     *         THEN
                SCDFEP(IPK) = SCDFEP(IPK)+WT1OLD
                SCDFEP2(IPK) = SCDFEP2(IPK)+WT1OLD*WT1OLD
                SCDFDIFF(IPK)=SCDFDIFF(IPK)+WT1OLD
                SCDFDIFF2(IPK)=SCDFDIFF2(IPK)+WT1OLD*WT1OLD
                IF ((IWATCH.EQ.3)) THEN
                  WRITE(6,1860)IPK
1860              FORMAT(T50,'IT WAS IN ONE OF THE PEAKS,IPK=',I3/)
                END IF
              ELSE IF(((PHENER.GE.DFEN(IPK,1)).AND.(PHENER.LT.DFEN(IPK,2
     *        )))) THEN
                SCDFBK(IPK)=SCDFBK(IPK)+WT1OLD
                SCDFBK2(IPK)=SCDFBK2(IPK)+WT1OLD*WT1OLD
                SCDFDIFF(IPK)=SCDFDIFF(IPK)-WT1OLD
                SCDFDIFF2(IPK)=SCDFDIFF2(IPK)-WT1OLD*WT1OLD
              END IF
1851        CONTINUE
1852        CONTINUE
          END IF
          SCPDST_LAST=NHSTRY
          PHENER=EDEP
          WT1OLD=WT(1)
        END IF
      END IF
      RETURN
      END
      SUBROUTINE HOWFAR
      implicit none
      CHARACTER*4 BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,
     *SCHAR, TCHAR,UCHAR,VCHAR
      COMMON/CHARS/ BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHA
     *R,SCHAR,TCHAR,UCHAR,VCHAR
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      CHARACTER*4 CDSTBL( 12001),CTRTBL( 12001),CABSRB( 12001)
      COMMON/GEOM/ZPLANE( 201),RCYL(0:60), CYRAD2( 61), NZ,NR,NREG,NDOSE
     *,NZDOSE,NRDOSE,NPLANE, NZDMIN,NZDMAX,NRDMIN,NRDMAX, NTRACK( 12001)
     *,CDSTBL,CTRTBL,CABSRB,IDSTBL( 12001,2)
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,NZDMIN,NZDMAX,NRDM
     *IN,NRDMAX, NTRACK,IDSTBL
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/NRCNEW/NEWNRC,DECISION
      integer*4 NEWNRC,DECISION
      COMMON/SCORE/ SCDOSE(200,60,7),SCDOSE2(200,60,7), SCKERMA(200,60,7
     *),SCKERMA2(200,60,7), SCDOSEtoKERMA2(200,60,7),SCPDST(500),SCPDST2
     *(500), SCPCUM(500),SCPCUM2(500),SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCD
     *FBK(4),SCDFBK2(4),SCDFEP(4),SCDFEP2(4),SCDFDIFF(4),SCDFDIFF2(4), S
     *CSTP,SCSTP2,SCDSTP,SCDSTP2, PIISTP, SCSTP_LAST, SCDSTP_LAST,SCDOSE
     *_LAST(200,60,7), SCKERMA_LAST(200,60,7), SCKERMA_LASTOLD(200,60,7)
     *,SCPDST_LAST, IHSTRY, DFEN(4,4), PHENER,WT1OLD,BINTOP(500),SLOTE,D
     *ELTAE, SCDOSE_TMP(200,60,7), SCKERMA_TMP(200,60,7), SCKERMA_TMPOLD
     *(200,60,7), SCSTP_TMP,SCDSTP_TMP, MXNP,IFULL,ISTORE,IKERMA, IWATCH
     *,IOOPTN,IOUTSP, IPHR( 12001),MAXBIN,NCOMPT,during_pe_compt,during_
     *eii
      real*8 SCDOSE,SCDOSE2,SCKERMA,SCKERMA2,SCDOSEtoKERMA2,SCPDST,SCPDS
     *T2, SCPCUM,SCPCUM2,SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCDFBK,SCDFBK2,S
     *CDFEP,SCDFEP2,SCDFDIFF,SCDFDIFF2, SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIIS
     *TP
      integer*8 SCSTP_LAST, SCDSTP_LAST, SCDOSE_LAST, SCKERMA_LAST, SCKE
     *RMA_LASTOLD,SCPDST_LAST, IHSTRY
      real*8 DFEN, PHENER,WT1OLD,BINTOP,SLOTE,DELTAE, SCDOSE_TMP,SCKERMA
     *_TMP,SCKERMA_TMPOLD,SCSTP_TMP,SCDSTP_TMP
      integer*4 MXNP,IFULL,ISTORE,IKERMA, IWATCH,IOOPTN,IOUTSP, IPHR,MAX
     *BIN,NCOMPT,during_pe_compt,during_eii
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      logical OUTEND,OUTSID
      integer*4 IQL,IRL,IX,IZ,IHITP,IHITC,IZNEW,IXNEW,NWNRCL,IMSOFF
      real*8 WL,TPLANE,TCYL,U1,V1,A,X1,Y1,B,B2,C,COUT,CIN,RAD
      IF ((WT(NP).EQ.0.0)) THEN
        IDISC=1
        RETURN
      END IF
      OUTEND=.FALSE.
      OUTSID=.FALSE.
      IQL=IQ(NP)
      IRL=IR(NP)
      IF (((IRL.EQ.1).OR.(CABSRB(IRL).EQ.ACHAR))) THEN
        IDISC=1
        RETURN
      END IF
      IX=(IRL-2)/NZ+1
      IZ=IRL-1-NZ*(IX-1)
      WL=W(NP)
      IF ((WL.GT.0.0)) THEN
        IHITP=1
        TPLANE=(ZPLANE(IZ+1)-Z(NP))/WL
      ELSE IF((WL.LT.0.0)) THEN
        IHITP=-1
        TPLANE=(ZPLANE(IZ)-Z(NP))/WL
      ELSE
        IHITP=0
        TPLANE=1.0E30
      END IF
      U1=U(NP)
      V1=V(NP)
      A=U1*U1+V1*V1
      IF ((A.EQ.0.0)) THEN
        IHITC=0
        TCYL=1.0E30
      ELSE
        X1=X(NP)
        Y1=Y(NP)
        B=X1*U1+Y1*V1
        B2=B*B
        COUT=X1*X1+Y1*Y1-CYRAD2(IX)
        IF ((COUT.GT.0.0)) THEN
          IF ((IWATCH .GT. 0 .AND. IWATCH .LT. 4 )) THEN
            WRITE(6,1870)COUT
1870        FORMAT(' COUT=',E11.3)
          END IF
          COUT=0.0
        END IF
        IF ((B.GT.0.0)) THEN
          IHITC=1
          IF ((COUT/B2.GT.-1.0E-3)) THEN
            TCYL=-0.5*COUT/B
          ELSE
            TCYL=-COUT/(SQRT(B2-A*COUT)+B)
          END IF
        ELSE IF((B.LT.0.0)) THEN
          IHITC=1
          IF ((COUT/B2.GT.-1.0E-3)) THEN
            TCYL=-2.*B/A*(1.-0.25*A*COUT/B2)
          ELSE
            TCYL=(SQRT(B2-A*COUT)-B)/A
          END IF
          IF ((IX.NE.1)) THEN
            CIN=X1*X1+Y1*Y1-CYRAD2(IX-1)
            IF ((CIN.LT.0.0)) THEN
              IF ((IWATCH .GT. 0 .AND. IWATCH .LT. 4 )) THEN
                WRITE(6,1880)CIN
1880            FORMAT(' CIN=',E11.3)
              END IF
              CIN=0.0
            END IF
            RAD=B2-A*CIN
            IF ((RAD.GE.0.0)) THEN
              IHITC=-1
              IF ((CIN/B2.LT.1.0E-3)) THEN
                TCYL=-0.5*CIN/B
              ELSE
                TCYL=CIN/(SQRT(RAD)-B)
              END IF
            END IF
          END IF
        ELSE
          IHITC=1
          TCYL=SQRT(-COUT/A)
        END IF
      END IF
      IZNEW=IZ+IHITP
      IF(((IZNEW.LT.1).OR.(IZNEW.GT.NZ)))OUTEND=.TRUE.
      IXNEW=IX+IHITC
      IF((IXNEW.GT.NR))OUTSID=.TRUE.
      IF (((IHITP.NE.0).AND.(IHITC.NE.0))) THEN
        IF ((TPLANE.LT.TCYL)) THEN
          IF ((OUTEND)) THEN
            NWNRCL=0
            IF ((TPLANE.LE.USTEP)) THEN
              USTEP=TPLANE
              IRNEW=1
              IMSOFF=0
              NEWNRC=NWNRCL
              IF((USTEP.EQ.0 .AND. IRNEW.NE.IROLD))DECISION=1
            END IF
            RETURN
          ELSE
            NWNRCL=20-10*IHITP
            IF ((TPLANE.LE.USTEP)) THEN
              USTEP=TPLANE
              IRNEW=IRL+IHITP
              IMSOFF=0
              NEWNRC=NWNRCL
              IF((USTEP.EQ.0 .AND. IRNEW.NE.IROLD))DECISION=1
            END IF
            RETURN
          END IF
        ELSE IF((TCYL.LT.TPLANE)) THEN
          IF ((OUTSID)) THEN
            NWNRCL=0
            IF ((TCYL.LE.USTEP)) THEN
              USTEP=TCYL
              IRNEW=1
              IMSOFF=0
              NEWNRC=NWNRCL
              IF((USTEP.EQ.0 .AND. IRNEW.NE.IROLD))DECISION=1
            END IF
            RETURN
          ELSE
            NWNRCL=30+10*IHITC
            IF ((TCYL.LE.USTEP)) THEN
              USTEP=TCYL
              IRNEW=IRL+NZ*IHITC
              IMSOFF=0
              NEWNRC=NWNRCL
              IF((USTEP.EQ.0 .AND. IRNEW.NE.IROLD))DECISION=1
            END IF
            RETURN
          END IF
        ELSE
          IF ((OUTEND.OR.OUTSID)) THEN
            NWNRCL=0
            IF ((TCYL.LE.USTEP)) THEN
              USTEP=TCYL
              IRNEW=1
              IMSOFF=0
              NEWNRC=NWNRCL
              IF((USTEP.EQ.0 .AND. IRNEW.NE.IROLD))DECISION=1
            END IF
            RETURN
          ELSE
            NWNRCL=20-10*IHITP
            IF ((TCYL.LE.USTEP)) THEN
              USTEP=TCYL
              IRNEW=IRL+IHITP+NZ*IHITC
              IMSOFF=0
              NEWNRC=NWNRCL
              IF((USTEP.EQ.0 .AND. IRNEW.NE.IROLD))DECISION=1
            END IF
            RETURN
          END IF
        END IF
      ELSE IF((IHITP.NE.0)) THEN
        IF ((OUTEND)) THEN
          NWNRCL=0
          IF ((TPLANE.LE.USTEP)) THEN
            USTEP=TPLANE
            IRNEW=1
            IMSOFF=0
            NEWNRC=NWNRCL
            IF((USTEP.EQ.0 .AND. IRNEW.NE.IROLD))DECISION=1
          END IF
          RETURN
        ELSE
          NWNRCL=20-10*IHITP
          IF ((TPLANE.LE.USTEP)) THEN
            USTEP=TPLANE
            IRNEW=IRL+IHITP
            IMSOFF=0
            NEWNRC=NWNRCL
            IF((USTEP.EQ.0 .AND. IRNEW.NE.IROLD))DECISION=1
          END IF
          RETURN
        END IF
      ELSE
        IF ((OUTSID)) THEN
          NWNRCL=0
          IF ((TCYL.LE.USTEP)) THEN
            USTEP=TCYL
            IRNEW=1
            IMSOFF=0
            NEWNRC=NWNRCL
            IF((USTEP.EQ.0 .AND. IRNEW.NE.IROLD))DECISION=1
          END IF
          RETURN
        ELSE
          NWNRCL=30+10*IHITC
          IF ((TCYL.LE.USTEP)) THEN
            USTEP=TCYL
            IRNEW=IRL+NZ*IHITC
            IMSOFF=0
            NEWNRC=NWNRCL
            IF((USTEP.EQ.0 .AND. IRNEW.NE.IROLD))DECISION=1
          END IF
          RETURN
        END IF
      END IF
      END
      SUBROUTINE INPUTS
      implicit none
      COMMON/BOUNDS/ECUT( 12001),PCUT( 12001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      CHARACTER*4 BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,
     *SCHAR, TCHAR,UCHAR,VCHAR
      COMMON/CHARS/ BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHA
     *R,SCHAR,TCHAR,UCHAR,VCHAR
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      CHARACTER*4 CDSTBL( 12001),CTRTBL( 12001),CABSRB( 12001)
      COMMON/GEOM/ZPLANE( 201),RCYL(0:60), CYRAD2( 61), NZ,NR,NREG,NDOSE
     *,NZDOSE,NRDOSE,NPLANE, NZDMIN,NZDMAX,NRDMIN,NRDMAX, NTRACK( 12001)
     *,CDSTBL,CTRTBL,CABSRB,IDSTBL( 12001,2)
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,NZDMIN,NZDMAX,NRDM
     *IN,NRDMAX, NTRACK,IDSTBL
      CHARACTER*1 TITLE(80)
      COMMON/IODAT1/TITLE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(200,60),TMCPUO,TIMMAX,ST
     *ATLM,EIN,EKMAX, IDAT,IRESTART,IQIN,NESTEP,NSMAX,IXXIN,JXXIN,IVAL,D
     *ATCOUNT
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN,EKMAX
      integer*4 IDAT,IRESTART,IQIN,NESTEP,NSMAX, IXXIN,JXXIN,IVAL,DATCOU
     *NT
      integer*8 NCASE,NCASEO,NCASET
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PLOTC/ IPLOTR(60),IPLOTZ(200),IOPLOT,IPLTLP,IPLTPL,IPLPHB,N
     *PLOTR,NPLOTZ
      integer*4 IPLOTR,IPLOTZ,IOPLOT,IPLTLP,IPLTPL,IPLPHB,NPLOTR,NPLOTZ
      LOGICAL RUSROU
      COMMON/RUSROU/RRZ,RRCUT,RUSROU
      real*8 RRZ,RRCUT
      COMMON/SCORE/ SCDOSE(200,60,7),SCDOSE2(200,60,7), SCKERMA(200,60,7
     *),SCKERMA2(200,60,7), SCDOSEtoKERMA2(200,60,7),SCPDST(500),SCPDST2
     *(500), SCPCUM(500),SCPCUM2(500),SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCD
     *FBK(4),SCDFBK2(4),SCDFEP(4),SCDFEP2(4),SCDFDIFF(4),SCDFDIFF2(4), S
     *CSTP,SCSTP2,SCDSTP,SCDSTP2, PIISTP, SCSTP_LAST, SCDSTP_LAST,SCDOSE
     *_LAST(200,60,7), SCKERMA_LAST(200,60,7), SCKERMA_LASTOLD(200,60,7)
     *,SCPDST_LAST, IHSTRY, DFEN(4,4), PHENER,WT1OLD,BINTOP(500),SLOTE,D
     *ELTAE, SCDOSE_TMP(200,60,7), SCKERMA_TMP(200,60,7), SCKERMA_TMPOLD
     *(200,60,7), SCSTP_TMP,SCDSTP_TMP, MXNP,IFULL,ISTORE,IKERMA, IWATCH
     *,IOOPTN,IOUTSP, IPHR( 12001),MAXBIN,NCOMPT,during_pe_compt,during_
     *eii
      real*8 SCDOSE,SCDOSE2,SCKERMA,SCKERMA2,SCDOSEtoKERMA2,SCPDST,SCPDS
     *T2, SCPCUM,SCPCUM2,SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCDFBK,SCDFBK2,S
     *CDFEP,SCDFEP2,SCDFDIFF,SCDFDIFF2, SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIIS
     *TP
      integer*8 SCSTP_LAST, SCDSTP_LAST, SCDOSE_LAST, SCKERMA_LAST, SCKE
     *RMA_LASTOLD,SCPDST_LAST, IHSTRY
      real*8 DFEN, PHENER,WT1OLD,BINTOP,SLOTE,DELTAE, SCDOSE_TMP,SCKERMA
     *_TMP,SCKERMA_TMPOLD,SCSTP_TMP,SCDSTP_TMP
      integer*4 MXNP,IFULL,ISTORE,IKERMA, IWATCH,IOOPTN,IOUTSP, IPHR,MAX
     *BIN,NCOMPT,during_pe_compt,during_eii
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(100,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBE
     *AM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,
     *DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,P
     *ROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,
     *ZSOFST,                                                      SVTMP
     *1,SVTMP2,SVTMP3,SVTMP4,
     *         RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                       XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,W
     *EIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/SPECTR/ CDFINV(1000,2),ENSRCD(0:300),SRCPDF(300),SRCCDF(300
     *), NENSRC
      integer*4 NENSRC
      real*8 CDFINV,ENSRCD,SRCPDF,SRCCDF
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERRR/ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN, MINZ,MAXZ,MINR,MAXR
     *,IREJCT
      real*8 ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN
      integer*4 MINZ,MAXZ,MINR,MAXR,IREJCT
      COMMON/USERMI/EXPMFP,GWTOLD,ICSDA
      integer*4 ICSDA
      real*8 EXPMFP,GWTOLD
      COMMON/USERVR/ CEXPTR,GWAIT,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,
     *IQINC,MONOEN, cs_enhance,cs_enhance_current,ienhance,iefl( 12001),
     *ics_enhance, do_fast_step
      integer*4 ienhance,iefl,ics_enhance, IFORCE,NFMIN,NFMAX,NFTIME,ISO
     *URC,IFPB,IQINC,MONOEN
      real*8 CEXPTR,GWAIT,cs_enhance,cs_enhance_current
      logical do_fast_step
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      common/ET_control/ smaxir( 12001),estepe,ximax,  skindepth_for_bca
     *,transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,10), eno_array(200,10), eno_atbin_array(200,10), n
     *_shell(10), radc_flag,  ibcmp( 12001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 INEXT
      integer*4 MODEIN
      real*8 TEMP1,TEMP2,TEMP3,TEMP4
      integer*4 IFLUOR
      integer*4 IZ, IREGLO, IREGHI
      integer*4 IESTEP
      real*8 ESTEP, SMAX
      real*8 FESTEP
      real*8 ADDING
      integer*4 I, J, K, PLN, COUNT, SLENGHT, REGNUM, lux_level
      integer*4 NUM_TITLE,  NUM_IWATCH, NUM_STRAND, NUM_IRESTART , NUM_O
     *UTOPTS, NUM_STORE, NUM_ETRANS, NUM_DZMIN, NUM_DZMAX, NUM_DRMIN, NU
     *M_DRMAX,  NUM_HIST, NUM_SEEDS, NUM_MXTIME, NUM_IFULL, NUM_STATLM,
     *NUM_SCKERMA, NUM_BREMDST,  NUM_REGSVOL, NUM_SLOTE, NUM_DELTAE, NUM
     *_TOPEBIN,  NUM_ESTEPE, NUM_SMAX, NUM_ECUT, NUM_PCUT, NUM_RAYLEIGH,
     * NUM_IREJCT, NUM_HOWFAR, NUM_ESAVEIN, NUM_IFLUOR, NUM_FLUIZ, NUM_F
     *REGSTART, NUM_FREGSTOP, NUM_RRPARAM, NUM_RRMINPL, NUM_RRMAXPL, NUM
     *_RRMINRA, NUM_RRMAXRA, NUM_RUSROU, NUM_RUSFRAC, NUM_XTRANSF, NUM_F
     *ORCE, NUM_STRTFRC, NUM_STPFRC, NUM_NESTEP, NUM_NSMAX, NUM_ADJEREG,
     * NUM_ADJSLREG, NUM_ADJUSTED, NUM_NENH, NUM_NENHLO, NUM_NENHHI, NUM
     *_FRAKESTEP, num_compton,i_bound_compton, num_pe_ang,i_pe_ang,num_s
     *pin,i_spin,  NUM_BREMSPLIT, NUM_BREMPEVEN, NUM_I_PLAY_RR
      real*8 EPHTOP,fsmax
      integer*4 IPK,JJ,ii,ics_start,ics_stop,ismax,ib,it,itmax,ix
      integer*4 egs_open_datfile, data_unit
      IVAL=0
      ERROR_FLAG=0
      DO 1891 J=1,100
        NVALUE(J)=0
1891  CONTINUE
1892  CONTINUE
      WRITE(6,1900)
1900  FORMAT(//' DOSRZnrc(EGSnrc) ',' ',' ON ','linux',' '/)
      IVAL=IVAL+1
      NUM_TITLE=IVAL
      VALUES_SOUGHT(IVAL)='TITLE'
      TYPE(IVAL)=2
      NVALUE(IVAL)=1
      DELIMETER='NONE'
      NMIN = NUM_TITLE
      NMAX = NUM_TITLE
      CALL GET_INPUT
      WRITE(6,1910)
1910  FORMAT(' ')
      WRITE(6,1920)
1920  FORMAT(' ')
      WRITE(6,1930)
1930  FORMAT(' *** INPUT CARD I01 ***')
      READ (CHAR_VALUE(NUM_TITLE,1),FMT='(80A1)') (TITLE(I),I=1,80)
      WRITE (*,1940) (TITLE(I),I=1,79)
1940  FORMAT ('TITLE: ',79A1)
      WRITE(6,1950)
1950  FORMAT(' ')
      DELIMETER='I/O CONTROL'
      IVAL=IVAL+1
      NUM_IWATCH=IVAL
      VALUES_SOUGHT(IVAL)='IWATCH'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='OFF'
      ALLOWED_INPUTS(IVAL,1)='INTERACTIONS'
      ALLOWED_INPUTS(IVAL,2)='STEPS'
      ALLOWED_INPUTS(IVAL,3)='DEPOSITED'
      ALLOWED_INPUTS(IVAL,4)='GRAPH'
      IVAL=IVAL+1
      NUM_STRAND=IVAL
      VALUES_SOUGHT(IVAL)='STORE INITIAL RANDOM NUMBERS'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='NO'
      ALLOWED_INPUTS(IVAL,1)='LAST'
      ALLOWED_INPUTS(IVAL,2)='ALL'
      IVAL=IVAL+1
      NUM_IRESTART =IVAL
      VALUES_SOUGHT(IVAL)='IRESTART'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='FIRST'
      ALLOWED_INPUTS(IVAL,1)='RESTART'
      ALLOWED_INPUTS(IVAL,3)='ANALYZE'
      ALLOWED_INPUTS(IVAL,4)='START-RNS'
      ALLOWED_INPUTS(IVAL,5)='PARALLEL'
      IVAL=IVAL+1
      NUM_OUTOPTS=IVAL
      VALUES_SOUGHT(IVAL)='OUTPUT OPTIONS'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='SHORT'
      ALLOWED_INPUTS(IVAL,1)='DOSE SUMMARY'
      ALLOWED_INPUTS(IVAL,2)='MATERIAL SUMMARY'
      ALLOWED_INPUTS(IVAL,3)='MATERIAL AND DOSE SUMMARY'
      ALLOWED_INPUTS(IVAL,4)='LONG'
      IVAL=IVAL+1
      NUM_STORE=IVAL
      VALUES_SOUGHT(IVAL)='STORE DATA ARRAYS'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='YES'
      ALLOWED_INPUTS(IVAL,1)='NO'
      IVAL=IVAL+1
      NUM_ETRANS=IVAL
      VALUES_SOUGHT(IVAL)='ELECTRON TRANSPORT'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='NORMAL'
      ALLOWED_INPUTS(IVAL,1)='NO INTERACTIONS'
      IVAL=IVAL+1
      NUM_DZMIN=IVAL
      VALUES_SOUGHT(IVAL)='DOSE ZBOUND MIN'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=1
      VALUE_MAX(IVAL)=200
      DEFAULT(IVAL)=1
      IVAL=IVAL+1
      NUM_DZMAX=IVAL
      VALUES_SOUGHT(IVAL)='DOSE ZBOUND MAX'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=2
      VALUE_MAX(IVAL)=200+1
      DEFAULT(IVAL)=200+1
      IVAL=IVAL+1
      NUM_DRMIN=IVAL
      VALUES_SOUGHT(IVAL)='DOSE RBOUND MIN'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=60-1
      DEFAULT(IVAL)=0
      IVAL=IVAL+1
      NUM_DRMAX=IVAL
      VALUES_SOUGHT(IVAL)='DOSE RBOUND MAX'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=1
      VALUE_MAX(IVAL)=60
      DEFAULT(IVAL)=60
      DELIMETER='I/O CONTROL'
      NMIN = NUM_IWATCH
      NMAX = NUM_DRMAX
      CALL GET_INPUT
      WRITE(6,1960)
1960  FORMAT(' *** INPUT CARD IO2 ***')
      IWATCH=VALUE(NUM_IWATCH,1)
      ISTORE=VALUE(NUM_STRAND,1)
      IRESTART =VALUE(NUM_IRESTART ,1)
      IOOPTN=VALUE(NUM_OUTOPTS,1)
      IDAT=VALUE(NUM_STORE,1)
      ICSDA=VALUE(NUM_ETRANS,1)
      NZDMIN=VALUE(NUM_DZMIN,1)
      NZDMAX=VALUE(NUM_DZMAX,1)
      NRDMIN=VALUE(NUM_DRMIN,1)
      NRDMAX=VALUE(NUM_DRMAX,1)
      NZDOSE=NZDMAX-NZDMIN
      NRDOSE=NRDMAX-NRDMIN
      WRITE(6,1970)IWATCH,ISTORE,IRESTART ,IOOPTN,IDAT,ICSDA
1970  FORMAT(/ ' DO NOT TRACK(0) OR TRACK(>0) EVERY INTERACTION:',T72,I4
     */ ' DO NOT STORE(0) OR STORE(1,2) INITIAL RANDOM #s:',T72,I4/ ' FI
     *RST RUN(0),RESTARTED(1),ANALYZE(3),start-RNS(4),parallel(5):', T72
     *,I4/ ' OUTPUT OPTION (1 THRU 4):',T72,I4/ ' STORE DATA(0) OR NOT(1
     *):',T72,I4/ ' CSDA CALCULATION(1) OR NOT(0)':,T72,I4/)
      WRITE(6,1980)
1980  FORMAT(/' ******DOSE SCORING BOUNDARIES******')
      WRITE(6,1990)NZDMIN,NZDMAX,NRDMIN,NRDMAX
1990  FORMAT(' NZDMIN,NZDMAX,NRDMIN,NRDMAX: ',3(I5,','),I5/)
      WRITE(6,2000)
2000  FORMAT(' ')
      IF ((IDAT.EQ.1)) THEN
        INEXT=0
      ELSE
        INEXT=1
      END IF
      IF ((IRESTART .EQ.4)) THEN
        IDAT=1
        ISTORE=0
      END IF
      IVAL=IVAL+1
      NUM_HIST=IVAL
      VALUES_SOUGHT(IVAL)='NUMBER OF HISTORIES'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=1
      VALUE_MAX(IVAL)=4.611686e18
      DEFAULT(IVAL)=20000
      IVAL=IVAL+1
      NUM_MXTIME=IVAL
      VALUES_SOUGHT(IVAL)='MAX CPU HOURS ALLOWED'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=1000
      DEFAULT(IVAL)=999.
      IVAL=IVAL+1
      NUM_IFULL=IVAL
      VALUES_SOUGHT(IVAL)='IFULL'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='DOSE AND STOPPERS'
      ALLOWED_INPUTS(IVAL,1)='ENTRANCE REGIONS'
      ALLOWED_INPUTS(IVAL,2)='PULSE HEIGHT DISTRIBUTION'
      ALLOWED_INPUTS(IVAL,3)='SCATTER FRACTION'
      ALLOWED_INPUTS(IVAL,4)='OFMET Fricke'
      IVAL=IVAL+1
      NUM_STATLM=IVAL
      VALUES_SOUGHT(IVAL)='STATISTICAL ACCURACY SOUGHT'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=0.0
      VALUE_MAX(IVAL)=100.0
      DEFAULT(IVAL)=0.0
      IVAL=IVAL+1
      NUM_SCKERMA=IVAL
      VALUES_SOUGHT(IVAL)='SCORE KERMA'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='NO'
      ALLOWED_INPUTS(IVAL,1)='YES'
      DELIMETER='MONTE CARLO INPUTS'
      NMIN = NUM_HIST
      NMAX = NUM_SCKERMA
      CALL GET_INPUT
      ival = ival + 1
      VALUES_SOUGHT(IVAL)='INITIAL RANDOM NO. SEEDS'
      nvalue(ival) = 2
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) = 30081
      default(ival) = 9373
      delimeter = 'MONTE CARLO INPUTS'
      nmin = ival
      nmax = ival
      call get_input
      IF (( error_flags(ival) .EQ. 0 )) THEN
        ixxin = value(ival,1)
        jxxin = value(ival,2)
      ELSE
        ixxin = 0
        jxxin = 0
      END IF
      IF((i_parallel .GT. 0))jxxin = jxxin - 1 + i_parallel
      ixx = ixxin
      jxx = jxxin
      call init_ranmar
      WRITE(6,2010)
2010  FORMAT(/,' *** INPUT CARD MC1 ***')
      NCASE=VALUE(NUM_HIST,1)
      TIMMAX=VALUE(NUM_MXTIME,1)
      IFULL=VALUE(NUM_IFULL,1)
      STATLM=VALUE(NUM_STATLM,1)
      IKERMA=VALUE(NUM_SCKERMA,1)
      during_pe_compt=0
      during_eii=0
      IF ((IWATCH.EQ.0 .AND. NCASE .LT. 100)) THEN
        NCASE=100
      END IF
      WRITE(6,2020)NCASE,IXXIN,JXXIN,TIMMAX,IFULL,STATLM,IKERMA
2020  FORMAT(/ ' # OF HISTORIES:',T60,I12/ ' 1st initial random number s
     *eed: ',T60,I12/,' 2nd initial random number seed: ',T60,I12/, ' MA
     *XIMUM CPU TIME ALLOWED:' ,T60,F10.2,'HRS'/ ' SCORING OPTION IFULL(
     *0,1,2,3):' ,T60,I12/ ' STATISTICAL ACCURACY DESIRED:' ,T60,F10.4,'
     *%'/ ' KERMA WILL(1) or WILL NOT(0) be scored:',T60,I2)
      IF ((ERROR_FLAG.EQ.1)) THEN
        GOTO 2030
      END IF
      CALL GEOMRZ
      IF ((NMED.GT.10)) THEN
        WRITE(6,2040)10
2040    FORMAT(//' *****************ERROR******************'/ ' No. of m
     *edia > max. no. of media allowed (',I4,')'/ ' Increase $MXMED in s
     *rcrznrc.mortran, recompile'/ ' and try again.'//)
        ERROR_FLAG=1
      END IF
      IF ((ERROR_FLAG.EQ.1)) THEN
        WRITE(15,*) '***********ERROR IN SUBROUTINE GEOMRZ************'
        GOTO 2030
      END IF
      IF (( NZDMAX .GT. NZ+1 )) THEN
        NZDMAX=NZ+1
        WRITE(6,2050)NZDMAX
2050    FORMAT(/'===> MAX. SCORING PLANE # RESET TO: ',I6)
      END IF
      IF (( NZDMIN .GE. NZDMAX )) THEN
        NZDMIN = NZDMAX -1
        WRITE(6,2060)NZDMIN
2060    FORMAT(/'===> MIN. SCORING PLANE # RESET TO: ',I6)
      END IF
      IF (( NRDMAX .GT. NR )) THEN
        NRDMAX=NR
        WRITE(6,2070)NRDMAX
2070    FORMAT(/'===> MAX. SCORING CYLINDER # RESET TO: ',I6)
      END IF
      IF (( NRDMIN .GE. NRDMAX )) THEN
        NRDMIN = NRDMAX -1
        WRITE(6,2080)NRDMIN
2080    FORMAT(/'===> MIN. SCORING CYLINDER # RESET TO: ',I6)
      END IF
      NZDOSE=NZDMAX-NZDMIN
      NRDOSE=NRDMAX-NRDMIN
      IF ((NZDOSE.GT.500)) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,'(a,i5/,a,i5/,a/,a)') 'INPUTS: Number of dose scorin
     *g slab regions NZDOSE =',NZDOSE, 'is larger than plotting arrays s
     *ize $PLTDIM = ',500, 'Setting NZDOSE to $PLTDIM.', 'You can reset
     *$PLTDIM in dosrznrc.mortran.'
        NZDOSE=500
      END IF
      IF ((NRDOSE.GT.500)) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,'(a,i5/,a,i5/,a/,a)') 'INPUTS: Number of dose scorin
     *g cyl. regions NRDOSE =',NRDOSE, 'is larger than plotting arrays s
     *ize $PLTDIM = ',500, 'Setting NZDOSE to $PLTDIM.', 'You can reset
     *$PLTDIM in dosrznrc.mortran.'
        NRDOSE=500
      END IF
      IF ((IFULL.EQ.2)) THEN
        WRITE(6,2090)
2090    FORMAT(/' INPUT FOR PULSE HEIGHT DISTRIBUTION'/)
        DO 2101 J=1,NREG
          IPHR(J)=0
2101    CONTINUE
2102    CONTINUE
        IVAL=IVAL+1
        NUM_REGSVOL=IVAL
        VALUES_SOUGHT(IVAL)='REGION OF SENSITIVE VOLUME'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=1
        VALUE_MAX(IVAL)=NREG
        DEFAULT(IVAL)=NREG
        IVAL=IVAL+1
        NUM_SLOTE=IVAL
        VALUES_SOUGHT(IVAL)='SLOTE'
        TYPE(IVAL)=1
        VALUE_MIN(IVAL)=-10000.0
        VALUE_MAX(IVAL)=10000.0
        DEFAULT(IVAL)=1.25
        IVAL=IVAL+1
        NUM_DELTAE=IVAL
        VALUES_SOUGHT(IVAL)='DELTAE'
        TYPE(IVAL)=1
        VALUE_MIN(IVAL)=1.e-20
        VALUE_MAX(IVAL)=100000.0
        DEFAULT(IVAL)=0.005
        DELIMETER='PULSE HEIGHT DISTRIBUTION INPUT'
        NMIN = NUM_REGSVOL
        NMAX = NUM_DELTAE
        CALL GET_INPUT
        WRITE(6,2110)
2110    FORMAT(/' *** INPUT CARD PHD1 ***'/)
        DO 2121 J=1,NVALUE(NUM_REGSVOL)
          REGNUM=VALUE(NUM_REGSVOL,J)
          IPHR(REGNUM)=1
          WRITE(6,2130)REGNUM,MED(REGNUM)
2130      FORMAT(/T10,' REGION',I4,'  HAS MEDIUM',I3)
2121    CONTINUE
2122    CONTINUE
        WRITE(6,2140)
2140    FORMAT(' ')
        WRITE(6,2150)
2150    FORMAT(/' *** INPUT CARD PHD2 ***'/)
        SLOTE=VALUE(NUM_SLOTE,1)
        DELTAE=VALUE(NUM_DELTAE,1)
        IF ((SLOTE .GT. 0.0)) THEN
          WRITE(6,2160)SLOTE,SLOTE*dble(500)
2160      FORMAT(/' EQUAL BINS OF',F10.4,' MeV WILL COVER UP TO',F10.3,'
     * MeV')
        ELSE
          IVAL=IVAL+1
          NUM_TOPEBIN=IVAL
          VALUES_SOUGHT(IVAL)='TOPS OF ENERGY BINS'
          TYPE(IVAL)=1
          VALUE_MIN(IVAL)=1.e-20
          VALUE_MAX(IVAL)=100000.0
          DEFAULT(IVAL)=1.25
          NMIN = NUM_TOPEBIN
          NMAX = NUM_TOPEBIN
          CALL GET_INPUT
          DO 2171 J=1,NVALUE(NUM_TOPEBIN)
            BINTOP(J)=VALUE(NUM_TOPEBIN,J)
2171      CONTINUE
2172      CONTINUE
          MAXBIN = NVALUE(NUM_TOPEBIN)
          IF ((NVALUE(NUM_TOPEBIN) .GT. 500+1)) THEN
            WRITE(6,2180)500
2180        FORMAT(/' ****Tried to use more than max number of energy bi
     *ns ',I5/ '     Either increase $EBIN or reduce number of bins')
            STOP
          END IF
          WRITE(6,2190)NVALUE(NUM_TOPEBIN),(BINTOP(J),J=1,NVALUE(NUM_TOP
     *    EBIN))
2190      FORMAT(/' READ A TOTAL OF',I4,' ENERGY BINS'/ (5F15.4))
        END IF
      END IF
      CALL SRCRZ
      CALL SRCINI (SVTMP1,SVTMP2,SVTMP3,SVTMP4,0)
      IF ((ERROR_FLAG.EQ.1)) THEN
        WRITE(15,*) '***********ERROR IN SUBROUTINE SRCRZ************'
        GOTO 2030
      END IF
      IF ((ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOURC.EQ.23)) THEN
        MONOEN=0
      ELSE
        CALL ENSRC
      END IF
      IF ((ERROR_FLAG.EQ.1)) THEN
        WRITE(15,*) '***********ERROR IN SUBROUTINE ENSRC************'
        GOTO 2030
      END IF
      WRITE(6,2200)
2200  FORMAT(' ')
      IF ((IFULL .EQ. 3 .AND. IQIN .NE. 0)) THEN
        WRITE(6,2210)
2210    FORMAT(// 1x,70('@')/'  Changed IFULL to 0 from 3 since photon b
     *eam not input')
        IFULL = 0
      END IF
      IF ((IFULL.EQ.2)) THEN
        IF ((IQIN.EQ.1)) THEN
          EPHTOP=EIN+1.022
        ELSE
          EPHTOP=EIN
        END IF
        IF ((SLOTE.GT.0.0)) THEN
2221      IF((SLOTE*dble(500).GT.1.05*EPHTOP))GO TO 2222
            SLOTE=SLOTE*2.
            WRITE(6,2230)SLOTE
2230        FORMAT(/' ***HAVE DOUBLED SLOTE TO',F12.4, ' MeV TO REACH MA
     *XIMUM INPUT ENERGY')
          GO TO 2221
2222      CONTINUE
          MAXBIN=int(1.05*EPHTOP/SLOTE+0.999)
          WRITE(6,2240)MAXBIN
2240      FORMAT(/' MAXBIN set to',I5,' to cover spectrum'/)
        ELSE
          IF ((BINTOP(MAXBIN).LE.EPHTOP)) THEN
            WRITE(6,2250)MAXBIN,EPHTOP
2250        FORMAT(/' ***CHANGED BINTOP(',I3,') TO REACH', F10.3,' MeV**
     **')
            BINTOP(MAXBIN)=EPHTOP
          END IF
        END IF
        DFEN(1,2)=EPHTOP-DELTAE
        DFEN(2,2)=DFEN(1,2)-PRM
        DFEN(3,2)=DFEN(1,2)-1.022
        DFEN(4,2)=PRM-DELTAE
        DO 2261 IPK=1,4
          DFEN(IPK,1) = DFEN(IPK,2) - DELTAE
          DFEN(IPK,3) = DFEN(IPK,2) +2*DELTAE
          DFEN(IPK,4) = DFEN(IPK,3) +DELTAE
2261    CONTINUE
2262    CONTINUE
      END IF
      call get_transport_parameter(6)
      IVAL = IVAL + 1
      NUM_BREMSPLIT = IVAL
      VALUES_SOUGHT(IVAL)='BREM SPLITTING'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='OFF'
      ALLOWED_INPUTS(IVAL,1)='ON'
      IVAL = IVAL + 1
      NUM_BREMPEVEN = IVAL
      VALUES_SOUGHT(IVAL)='NUMBER OF BREMS PER EVENT'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=200
      DEFAULT(IVAL)=200
      IVAL = IVAL + 1
      NUM_I_PLAY_RR = IVAL
      VALUES_SOUGHT(IVAL)='CHARGED PARTICLE RUSSIAN ROULETTE'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='OFF'
      ALLOWED_INPUTS(IVAL,1)='ON'
      IVAL=IVAL+1
      NUM_IREJCT=IVAL
      VALUES_SOUGHT(IVAL)='ELECTRON RANGE REJECTION'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='OFF'
      ALLOWED_INPUTS(IVAL,1)='ON'
      IVAL=IVAL+1
      NUM_ESAVEIN=IVAL
      VALUES_SOUGHT(IVAL)='ESAVEIN'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=0.
      VALUE_MAX(IVAL)=EIN+PRM
      DEFAULT(IVAL) =EIN+PRM
      DELIMETER='VARIANCE REDUCTION'
      NMIN = NUM_BREMSPLIT
      NMAX = NUM_ESAVEIN
      CALL GET_INPUT
      IBRSPL=VALUE(NUM_BREMSPLIT,1)
      nbr_split =VALUE(NUM_BREMPEVEN,1)
      IF ((IBRSPL .EQ. 1)) THEN
        IF(((nbr_split .GT. 200)))nbr_split =200
      ELSE
        nbr_split = 1
      END IF
      I_PLAY_RR=VALUE(NUM_I_PLAY_RR,1)
      IF ((I_PLAY_RR.EQ.1)) THEN
        PROB_RR=1./dble(nbr_split)
      ELSE
        PROB_RR=1.
      END IF
      IREJCT=VALUE(NUM_IREJCT,1)
      ESAVEIN=VALUE(NUM_ESAVEIN,1)
      IF ((IREJCT .EQ. 1 )) THEN
        DO 2271 ii=1, 12001
          i_do_rr(ii) = 1
          e_max_rr(ii) = ESAVEIN
2271    CONTINUE
2272    CONTINUE
      END IF
      WRITE(6,2280)IBRSPL,nbr_split,I_PLAY_RR,PROB_RR,IREJCT,ESAVEIN
2280  FORMAT(/ ' BREMSSTRAHLUNG SPLITTING OFF(0) OR ON(1):' ,T60,I12/ 'E
     *ACH BREMSSTRAHLUNG SPLIT INTO:' ,T60,I12// ' CHARGED PARTICLE RUSS
     *IAN ROULETT OFF(0) OR ON(1):' ,T60,I12/ ' PROBABILITY OF SURVIVAL:
     *' ,T60,F10.4// ' WITHOUT(0) OR WITH(1) RANGE REJECTION:' ,T60,I12/
     * ' ESAVEIN CUTOFF VALUE FOR regional RANGE REJECTION :' ,T60,F10.4
     *,' MeV'/)
      IF ((IFULL.EQ.2 .AND. nbr_split .GT. 1)) THEN
        WRITE(6,2290)
2290    FORMAT(//' ****WARNING****'/ ' You cannot calculate a pulse heig
     *ht distribution with'/ ' bremsstrahlung splitting on.  Will run si
     *mulation with'/ ' IFULL= dose and stoppers'//)
        WRITE(1,'(//'' ****WARNING****''/
     *                         ''You cannot calculate a pulse height dis
     *tribution with''/                      '' bremsstrahlung splitting
     * on.  Will run simulation with''/                    '' IFULL= dos
     *e and stoppers''//)')
        IFULL=0
      END IF
      IVAL=IVAL+1
      NUM_RUSROU=IVAL
      VALUES_SOUGHT(IVAL)='RUSSIAN ROULETTE DEPTH'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=-1.e10
      VALUE_MAX(IVAL)=1.e10
      DEFAULT(IVAL)=0.0
      IVAL=IVAL+1
      NUM_RUSFRAC=IVAL
      VALUES_SOUGHT(IVAL)='RUSSIAN ROULETTE FRACTION'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=-1.e10
      VALUE_MAX(IVAL)=1.e10
      DEFAULT(IVAL)=0.0
      IVAL=IVAL+1
      NUM_XTRANSF=IVAL
      VALUES_SOUGHT(IVAL)='EXPONENTIAL TRANSFORM C'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=-1.e10
      VALUE_MAX(IVAL)=1.e10
      DEFAULT(IVAL)=0.0
      DELIMETER='VARIANCE REDUCTION'
      NMIN = NUM_RUSROU
      NMAX = NUM_XTRANSF
      CALL GET_INPUT
      WRITE(6,2300)
2300  FORMAT(' *** INPUT CARD TC2C ***')
      RRZ=VALUE(NUM_RUSROU,1)
      RRCUT=VALUE(NUM_RUSFRAC,1)
      CEXPTR=VALUE(NUM_XTRANSF,1)
      RUSROU=.FALSE.
      IF((RRZ+RRCUT.NE.0.0))RUSROU=.TRUE.
      IF ((RUSROU)) THEN
        WRITE(6,2310)RRZ,RRCUT
2310    FORMAT(/' RUSSIAN ROULETTE WILL BE PLAYED'/ ' RUSSIAN ROULETTE P
     *LANE:',T30,E14.7/ ' SURVIVAL PROBABILITY:',T30,E14.7/)
      ELSE
        WRITE(6,2320)
2320    FORMAT(' RUSSIAN ROULETTE WILL NOT BE PLAYED'/)
      END IF
      IF ((CEXPTR.EQ.0)) THEN
        WRITE(6,2330)
2330    FORMAT(' NO PATHLENGTH BIASING TO BE DONE'/)
      ELSE
        WRITE(6,2340)CEXPTR
2340    FORMAT(' CEXPTR PARAMATER:',T30,E14.7/)
      END IF
      IF ((IFULL.EQ.2 .AND. RUSROU)) THEN
        WRITE(6,2350)
2350    FORMAT(//' ****WARNING****'/ ' You cannot calculate a pulse heig
     *ht distribution with'/ ' Russian Roulette on.  Will run simulation
     * with'/ ' IFULL= dose and stoppers'//)
        WRITE(1,'(//'' ****WARNING****''/
     *                         '' You cannot calculate a pulse height di
     *stribution with''/                     '' Russian Roulette on.  Wi
     *ll run simulation with''/                            '' IFULL= dos
     *e and stoppers''//)')
        IFULL=0
      END IF
      IF ((IFULL.EQ.2 .AND. CEXPTR.NE.0)) THEN
        WRITE(6,2360)
2360    FORMAT(//' ****WARNING****'/ ' You cannot calculate a pulse heig
     *ht distribution with'/ ' pathlength biasing.  Will run simulationw
     *ith'/ ' IFULL= dose and stoppers'//)
        WRITE(1,'(//'' ****WARNING****''/
     *                         '' You cannot calculate a pulse height di
     *stribution with''/                     '' pathlength biasing.  Wil
     *l run simulation with''/                             '' IFULL= dos
     *e and stoppers''//)')
        IFULL=0
      END IF
      IVAL=IVAL+1
      NUM_FORCE=IVAL
      VALUES_SOUGHT(IVAL)='PHOTON FORCING'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      DEFAULT(IVAL)=0
      ALLOWED_INPUTS(IVAL,0)='OFF'
      ALLOWED_INPUTS(IVAL,1)='ON'
      IVAL=IVAL+1
      NUM_STRTFRC=IVAL
      VALUES_SOUGHT(IVAL)='START FORCING'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=NREG
      DEFAULT(IVAL)=1
      IVAL=IVAL+1
      NUM_STPFRC=IVAL
      VALUES_SOUGHT(IVAL)='STOP FORCING AFTER'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(NUM_STPFRC)=0
      VALUE_MAX(NUM_STPFRC)=NREG+1
      DEFAULT(NUM_STPFRC)=1
      DELIMETER='VARIANCE REDUCTION'
      NMIN = NUM_FORCE
      NMAX = NUM_STPFRC
      CALL GET_INPUT
      WRITE(6,2370)
2370  FORMAT(' *** INPUT CARD TC3 ***')
      IFORCE=VALUE(NUM_FORCE,1)
      NFMIN=VALUE(NUM_STRTFRC,1)
      NFMAX=VALUE(NUM_STPFRC,1)
      IF ((IFORCE.EQ.0)) THEN
        WRITE(6,2380)
2380    FORMAT(/' NO INTERACTION FORCING IS IN EFFECT'/)
      ELSE
        IF((NFMAX.LT.NFMIN))NFMAX=NFMIN
        WRITE(6,2390)NFMIN,NFMAX
2390    FORMAT(/' FORCED PHOTON INTERACTIONS IN EFFECT FROM',I3,' TO',I3
     *, ' # INTERACTIONS'/)
      END IF
      IF ((IFULL.EQ.2 .AND. (NFMAX.GT.NFMIN .OR. NFMIN.GT.1))) THEN
        WRITE(6,2400)
2400    FORMAT(//' ****WARNING****'/ ' You cannot calculate a pulse heig
     *ht distribution with'/ ' more than 1 interaction forced or if thef
     *orced interaction'/ ' is > the first interaction.  Will run simula
     *tion with'/ ' IFULL= dose and stoppers'//)
        WRITE(1,'(//'' ****WARNING****''/
     *                         '' You cannot calculate a pulse height di
     *stribution with''/                     '' more than 1 interaction
     *forced or if the forced interaction''/               '' is > the f
     *irst interaction.  Will run simulation with''/
     * '' IFULL= dose and stoppers''//)')
        IFULL=0
      END IF
      WRITE(6,2410)
2410  FORMAT(' ')
      IVAL=IVAL+1
      NUM_NENH=IVAL
      VALUES_SOUGHT(IVAL)='CS ENHANCEMENT FACTOR'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=1.0
      VALUE_MAX(IVAL)=10000.0
      DEFAULT(IVAL)=200.0
      IVAL = IVAL + 1
      NUM_NENHLO = IVAL
      VALUES_SOUGHT(IVAL)='CS ENHANCEMENT START REGION'
      NVALUE(IVAL)=0
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=NREG
      DEFAULT(IVAL)=1
      IVAL = IVAL + 1
      NUM_NENHHI = IVAL
      VALUES_SOUGHT(IVAL)='CS ENHANCEMENT STOP REGION'
      NVALUE(IVAL)=0
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=NREG
      DEFAULT(IVAL)=1
      NMIN = NUM_NENH
      NMAX = NUM_NENHHI
      CALL GET_INPUT
      cs_enhance = VALUE(NUM_NENH,1)
      DO 2421 jj=1,NREG
        iefl(jj)=0
2421  CONTINUE
2422  CONTINUE
      DO 2431 ii=1,NVALUE(NUM_NENHLO)
        ics_start=VALUE(NUM_NENHLO,ii)
        ics_stop=VALUE(NUM_NENHHI,ii)
        DO 2441 jj=ics_start,ics_stop
          iefl(jj)=1
2441    CONTINUE
2442    CONTINUE
2431  CONTINUE
2432  CONTINUE
      COUNT=0
      DO 2451 jj=2,NREG
        COUNT = COUNT + iefl(jj)
2451  CONTINUE
2452  CONTINUE
      IF ((COUNT .GT. 0 .AND. (cs_enhance .GT. 1.0001) )) THEN
        WRITE(6,2460)
2460    FORMAT('Cross section enhancement in regions ')
        WRITE(6,2470)(iefl(jj),jj=1,NREG)
2470    FORMAT(20 I4)
        WRITE(6,2480)cs_enhance
2480    FORMAT(' Cross section enhancement factor: ',T60,F6.1/)
        ics_enhance = 1
      ELSE
        WRITE(6,2490)
2490    FORMAT(' No cross section enhancement')
        ics_enhance = 0
      END IF
      IF ((IFULL.EQ.2 .AND. ics_enhance.EQ.1)) THEN
        WRITE(6,2500)
2500    FORMAT(//' ****WARNING****'/ ' You cannot calculate a pulse heig
     *ht distribution with'/ ' cross section enhancement.  Will run simu
     *lation with'/ ' IFULL= dose and stoppers'//)
        WRITE(1,'(//'' ****WARNING****''/
     *                         '' You cannot calculate a pulse height di
     *stribution with''/                     '' cross section enhancemen
     *t.  Will run simulation with''/                      '' IFULL= dos
     *e and stoppers''//)')
        IFULL=0
      END IF
      CALL PLOTSN
      IF ((ERROR_FLAG.EQ.1)) THEN
        GOTO 2030
      END IF
      IF (((IFULL.EQ.0).OR.(IFULL.EQ.2).OR.(IFULL.EQ.3))) THEN
        ITMAX=2
      ELSE
        ITMAX=7
      END IF
      NCASEO=0
      NCASET=0
      TMCPUO=0
      IF ((IRESTART.EQ.0.OR.IRESTART.EQ.5)) THEN
        NNREAD=0
        SCSTP=0
        SCSTP2=0
        SCSTP_TMP=0
        SCSTP_LAST=0
        SCDSTP=0
        SCDSTP2=0
        SCDSTP_TMP=0
        SCDSTP_LAST=0
        PIISTP=0
        DO 2511 IT=1,ITMAX
          DO 2521 IX=1,NR
            DO 2531 IZ=1,NZ
              SCDOSE(IZ,IX,IT)=0.0
              SCDOSE2(IZ,IX,IT)=0.0
              SCDOSE_TMP(IZ,IX,IT)=0.0
              SCDOSE_LAST(IZ,IX,IT)=0
              IF ((IKERMA.EQ.1)) THEN
                SCKERMA(IZ,IX,IT)=0.0
                SCKERMA2(IZ,IX,IT)=0.0
                SCKERMA_TMP(IZ,IX,IT)=0.0
                SCKERMA_LAST(IZ,IX,IT)=0
                SCDOSEtoKERMA2(IZ,IX,IT)=0.0
              END IF
2531        CONTINUE
2532        CONTINUE
2521      CONTINUE
2522      CONTINUE
2511    CONTINUE
2512    CONTINUE
        IF ((IFULL.EQ.2)) THEN
          DO 2541 IB=1,MAXBIN
            SCPDST(IB)=0.0
            SCPDST2(IB)=0.0
            SCPCUM(IB)=0.0
            SCPCUM2(IB)=0.0
2541      CONTINUE
2542      CONTINUE
          DO 2551 IPK=1,4
            SCDFEP(IPK)=0.0
            SCDFEP2(IPK)=0.0
            SCDFBK(IPK)=0.0
            SCDFBK2(IPK)=0.0
            SCDFDIFF(IPK)=0.0
            SCDFDIFF2(IPK)=0.0
2551      CONTINUE
2552      CONTINUE
          SCPTOT=0.0
          SCPTOT2=0.0
          SCPDST_LAST=0
        END IF
      ELSE IF((IRESTART.EQ.4)) THEN
        WRITE(6,2560)
2560    FORMAT(/' Will READ RANDOM NUMBER PARAMETERS FROM UNIT 2:')
      ELSE
        WRITE(6,2570)
2570    FORMAT(/' ***START READING DATA FILE from PREVIOUS RUN***'/)
        data_unit = egs_open_datfile(4,0,1,'.egsdat')
        READ(data_unit,*,END=2580)SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIISTP
        READ(data_unit,*,END=2580) (((SCDOSE(IZ,IX,IT),IT=1,ITMAX),IX=1,
     *  NRDOSE),IZ=1,NZDOSE)
        READ(data_unit,*,END=2580) (((SCDOSE2(IZ,IX,IT),IT=1,ITMAX),IX=1
     *  ,NRDOSE),IZ=1,NZDOSE)
        IF ((IKERMA.EQ.1)) THEN
          READ(data_unit,*,END=2580) (((SCKERMA(IZ,IX,IT),IT=1,ITMAX),IX
     *    =1,NRDOSE),IZ=1,NZDOSE)
          READ(data_unit,*,END=2580) (((SCKERMA2(IZ,IX,IT),IT=1,ITMAX),I
     *    X=1,NRDOSE),IZ=1,NZDOSE)
          READ(data_unit,*,END=2580) (((SCDOSEtoKERMA2(IZ,IX,IT),IT=1,IT
     *    MAX),IX=1,NRDOSE),IZ=1,NZDOSE)
        END IF
        IF ((IFULL.EQ.2)) THEN
          READ(data_unit,*,END=2580)(SCPDST(IB),SCPDST2(IB),IB=1,MAXBIN)
          READ(data_unit,*,END=2580)(SCPCUM(IB),SCPCUM2(IB),IB=1,MAXBIN)
          READ(data_unit,*,END=2580)(SCDFEP(IPK),SCDFEP2(IPK),IPK=1,4)
          READ(data_unit,*,END=2580)(SCDFBK(IPK),SCDFBK2(IPK),IPK=1,4)
          READ(data_unit,*,END=2580)(SCDFDIFF(IPK),SCDFDIFF2(IPK),IPK=1,
     *    4)
        END IF
        read(data_unit,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed
     *  , rng_array
        twom24 = 1./16777216.
        READ(data_unit,*,END=2580)NCASEO,TMCPUO,NNREAD
        READ(data_unit,*,END=2590) SCOMEG,SCOMEG2
        goto 2600
2590    WRITE(6,2610)
2610    FORMAT('  Warning: Solid angle information not in data file')
        WRITE(6,2620)
2620    FORMAT('           This may cause errors in absolute normalizati
     *ons!')
2600    CLOSE(data_unit)
      END IF
      IF ((IRESTART .EQ.3)) THEN
        NCASE=0
      END IF
      NCASET=NCASE+NCASEO
2030  CONTINUE
      IF ((ERROR_FLAG.EQ.0)) THEN
        WRITE(6,2630)
2630    FORMAT(/' ********* SUCCESSFUL INPUT ACCOMPLISHED *********')
        WRITE (15,*) ' '
        WRITE (15,*) ' '
        WRITE (15,*) ' *************************************************
     *'
        WRITE (15,*) ' ********* SUCCESSFUL INPUT ACCOMPLISHED *********
     *'
        WRITE (15,*) ' *************************************************
     *'
        WRITE (15,*) ' '
        WRITE (15,*) ' '
        DO 2641 J=1,5
          WRITE(6,2650)
2650      FORMAT(' ')
2641    CONTINUE
2642    CONTINUE
        RETURN
      END IF
      IF ((ERROR_FLAG.EQ.1)) THEN
        WRITE(15,*) ' '
        WRITE(15,*) ' '
        WRITE(15,*) '************************************************'
        WRITE(15,*) '********UNSUCCESSFUL INPUTS ACCOMPLISHED********'
        WRITE(15,*) '************************************************'
        WRITE(15,*) ' '
        WRITE(15,*) ' '
        WRITE(6,2660)
2660    FORMAT(/' ERROR_FLAG=1 => INPUT DATA IS NOT CORRECT! see error f
     *ile')
        RETURN
      END IF
2580  WRITE(6,2670)
2670  FORMAT(/' End of egsdat file from previous run encountered before'
     *, ' it was all read in - have to quit ')
      ERROR_FLAG=1
      RETURN
      END
      SUBROUTINE ISUMRY
      implicit none
      COMMON/BOUNDS/ECUT( 12001),PCUT( 12001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      common/ET_control/ smaxir( 12001),estepe,ximax,  skindepth_for_bca
     *,transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      CHARACTER*4 CDSTBL( 12001),CTRTBL( 12001),CABSRB( 12001)
      COMMON/GEOM/ZPLANE( 201),RCYL(0:60), CYRAD2( 61), NZ,NR,NREG,NDOSE
     *,NZDOSE,NRDOSE,NPLANE, NZDMIN,NZDMAX,NRDMIN,NRDMAX, NTRACK( 12001)
     *,CDSTBL,CTRTBL,CABSRB,IDSTBL( 12001,2)
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,NZDMIN,NZDMAX,NRDM
     *IN,NRDMAX, NTRACK,IDSTBL
      CHARACTER*1 TITLE(80)
      COMMON/IODAT1/TITLE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(200,60),TMCPUO,TIMMAX,ST
     *ATLM,EIN,EKMAX, IDAT,IRESTART,IQIN,NESTEP,NSMAX,IXXIN,JXXIN,IVAL,D
     *ATCOUNT
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN,EKMAX
      integer*4 IDAT,IRESTART,IQIN,NESTEP,NSMAX, IXXIN,JXXIN,IVAL,DATCOU
     *NT
      integer*8 NCASE,NCASEO,NCASET
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      LOGICAL RUSROU
      COMMON/RUSROU/RRZ,RRCUT,RUSROU
      real*8 RRZ,RRCUT
      COMMON/SCORE/ SCDOSE(200,60,7),SCDOSE2(200,60,7), SCKERMA(200,60,7
     *),SCKERMA2(200,60,7), SCDOSEtoKERMA2(200,60,7),SCPDST(500),SCPDST2
     *(500), SCPCUM(500),SCPCUM2(500),SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCD
     *FBK(4),SCDFBK2(4),SCDFEP(4),SCDFEP2(4),SCDFDIFF(4),SCDFDIFF2(4), S
     *CSTP,SCSTP2,SCDSTP,SCDSTP2, PIISTP, SCSTP_LAST, SCDSTP_LAST,SCDOSE
     *_LAST(200,60,7), SCKERMA_LAST(200,60,7), SCKERMA_LASTOLD(200,60,7)
     *,SCPDST_LAST, IHSTRY, DFEN(4,4), PHENER,WT1OLD,BINTOP(500),SLOTE,D
     *ELTAE, SCDOSE_TMP(200,60,7), SCKERMA_TMP(200,60,7), SCKERMA_TMPOLD
     *(200,60,7), SCSTP_TMP,SCDSTP_TMP, MXNP,IFULL,ISTORE,IKERMA, IWATCH
     *,IOOPTN,IOUTSP, IPHR( 12001),MAXBIN,NCOMPT,during_pe_compt,during_
     *eii
      real*8 SCDOSE,SCDOSE2,SCKERMA,SCKERMA2,SCDOSEtoKERMA2,SCPDST,SCPDS
     *T2, SCPCUM,SCPCUM2,SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCDFBK,SCDFBK2,S
     *CDFEP,SCDFEP2,SCDFDIFF,SCDFDIFF2, SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIIS
     *TP
      integer*8 SCSTP_LAST, SCDSTP_LAST, SCDOSE_LAST, SCKERMA_LAST, SCKE
     *RMA_LASTOLD,SCPDST_LAST, IHSTRY
      real*8 DFEN, PHENER,WT1OLD,BINTOP,SLOTE,DELTAE, SCDOSE_TMP,SCKERMA
     *_TMP,SCKERMA_TMPOLD,SCSTP_TMP,SCDSTP_TMP
      integer*4 MXNP,IFULL,ISTORE,IKERMA, IWATCH,IOOPTN,IOUTSP, IPHR,MAX
     *BIN,NCOMPT,during_pe_compt,during_eii
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(100,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBE
     *AM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,
     *DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,P
     *ROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,
     *ZSOFST,                                                      SVTMP
     *1,SVTMP2,SVTMP3,SVTMP4,
     *         RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                       XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,W
     *EIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/SPECTR/ CDFINV(1000,2),ENSRCD(0:300),SRCPDF(300),SRCCDF(300
     *), NENSRC
      integer*4 NENSRC
      real*8 CDFINV,ENSRCD,SRCPDF,SRCCDF
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERRR/ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN, MINZ,MAXZ,MINR,MAXR
     *,IREJCT
      real*8 ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN
      integer*4 MINZ,MAXZ,MINR,MAXR,IREJCT
      COMMON/USERMI/EXPMFP,GWTOLD,ICSDA
      integer*4 ICSDA
      real*8 EXPMFP,GWTOLD
      COMMON/USERVR/ CEXPTR,GWAIT,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,
     *IQINC,MONOEN, cs_enhance,cs_enhance_current,ienhance,iefl( 12001),
     *ics_enhance, do_fast_step
      integer*4 ienhance,iefl,ics_enhance, IFORCE,NFMIN,NFMAX,NFTIME,ISO
     *URC,IFPB,IQINC,MONOEN
      real*8 CEXPTR,GWAIT,cs_enhance,cs_enhance_current
      logical do_fast_step
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      integer*4 IOUT,j,isumx,jj,i,ii
      real*8 EK0
      logical start_fluor
      integer*4 i_start,i_stop
      IOUT=1
      WRITE (IOUT, *) '\f'
      write(iout,100) title
100   FORMAT( ' ',80A1,/1X,79('*')/ ' *',T80, '*'/ ' *',T80, '*'/ ' *',T
     *34,'************',T80,'*'/ ' *',T34,'*          *',T80,'*'/ ' *',T
     *34,'* DOSRZnrc *',T80,'*'/ ' *',T34,'*          *',T80,'*'/ ' *',T
     *34,'************',T80,'*'/ ' *',T80, '*'/ ' *           Cylindrica
     *l-geometry dose-scoring EGSnrc user-code ', T80,'*'/ ' *',T80, '*'
     */ ' *   DOSRZnrc was developed by the National Research Council of
     * Canada', T80,'*'/ ' *',T80, '*'/ ' *     It uses the EGSnrc CodeS
     *ystem developed at NRC ',T80,'*'/ ' *     (based on the EGS4 Code 
     *System Carlo developed by SLAC and NRC)', T80,'*'/ ' *  running on
     * ','linux',' ',T80,'*'/ ' *',T80, '*'/ ' *', T54,' ',$)
      call egs_fdate(iout)
      write(iout,'(" *",/1X,79("*"))')
      call show_transport_parameter(iout)
      WRITE(IOUT,200) NCASE,NCASET,IQIN
      IF ((MONOEN.EQ.0.AND.(ISOURC.LT.21.OR.ISOURC.GT.23))) THEN
        WRITE(IOUT,201) EIN
      ELSE IF((MONOEN.EQ.1)) THEN
        CALL ENSRCO
      ELSE IF((ISOURC.EQ.21.OR.ISOURC.EQ.22)) THEN
        WRITE(IOUT,202) EKSRCM
      END IF
      DO 2681 I=2,NREG
        IF (( (ECUT(I) .NE. ECUT(2)) .OR.(PCUT(I) .NE. PCUT(2)) )) THEN
          jj = MIN(12,NREG)
          WRITE(IOUT,'( ''First ECUTs:''/(6(F12.3)))') (ECUT(ii),ii=2,jj
     *    )
          WRITE(IOUT,'( ''First PCUTs:''/(6(F12.3)))') (PCUT(ii),ii=2,jj
     *    )
          GO TO 2690
        END IF
2681  CONTINUE
2682  CONTINUE
      WRITE(IOUT,220) ECUT(2),PCUT(2)
2690  IF ((IFORCE.NE.0)) THEN
        WRITE(IOUT,230)NFMIN,NFMAX
      ELSE
        WRITE(IOUT,231)
      END IF
      IF ((ics_enhance .EQ. 1)) THEN
        WRITE(IOUT,235) cs_enhance,(j,iefl(j),j=2,NREG)
      ELSE
        WRITE(IOUT,236)
      END IF
      IF ((IREJCT.EQ.0)) THEN
        WRITE(IOUT,243)
      ELSE
        WRITE(IOUT,242) ESAVEIN
      END IF
      DO 2701 I=1,NREG
        IF ((IRAYLR(I).EQ.1)) THEN
          WRITE(IOUT,244)
          GO TO2702
        END IF
2701  CONTINUE
2702  CONTINUE
      WRITE(IOUT,260) TIMMAX,STATLM,IXXIN,JXXIN
      IF ((IBRSPL .EQ. 0)) THEN
        WRITE(IOUT,312)
      ELSE
        WRITE(IOUT,313) nbr_split
      END IF
      IF ((I_PLAY_RR .EQ. 0)) THEN
        WRITE(IOUT,314)
      ELSE
        WRITE(IOUT,315) PROB_RR
      END IF
      IF((RUSROU))WRITE(IOUT,265)RRZ,RRCUT
      IF((CEXPTR.NE.0))WRITE(IOUT,266)CEXPTR
      IF((ESAVEIN .GT. 0.0))WRITE(IOUT,267)ESAVEIN
      IF ((NESTEP.EQ.0)) THEN
        WRITE(IOUT,282)
      ELSE IF((NESTEP.EQ.NREG)) THEN
        WRITE(IOUT,283)
      ELSE
        WRITE(IOUT,284)NESTEP
      END IF
      IF ((NSMAX.EQ.0)) THEN
        WRITE(IOUT,285)
      ELSE IF((NSMAX.EQ.NREG)) THEN
        WRITE(IOUT,286)
      ELSE
        WRITE(IOUT,287)NSMAX
      END IF
      IF ((ICSDA.EQ.0)) THEN
        WRITE(IOUT,289)
      ELSE
        WRITE(IOUT,290)
      END IF
      ISUMX=0
      DO 2711 JJ=1,NREG
        ISUMX=ISUMX+IEDGFL(JJ)
2711  CONTINUE
2712  CONTINUE
      IF ((ISUMX.EQ.0)) THEN
        WRITE(IOUT,307)
      ELSE
        WRITE(IOUT,306)
        start_fluor = .false.
        DO 2721 jj=1,NREG
          IF (( IEDGFL(JJ) .GT. 0 .AND. IEDGFL(JJ) .LE. 100 )) THEN
            IF (( .NOT.start_fluor )) THEN
              start_fluor = .true.
              i_start = jj
            ELSE
              i_stop = jj
            END IF
          ELSE
            IF (( start_fluor )) THEN
              write(iout,'(24x,i5,a,i5)') i_start,' -- ',i_stop
              start_fluor = .false.
            END IF
          END IF
2721    CONTINUE
2722    CONTINUE
        IF((start_fluor))write(iout,'(24x,i5,a,i5)') i_start,' -- ',i_st
     *  op
      END IF
      EK0=EIN
      WRITE(IOUT,300) NMED
      DO 2731 I=1,NMED
        WRITE(IOUT,310) I,(MEDIA(J,I),J=1,6),RHO(I),AE(I),AP(I),UE(I),UP
     *  (I)
2731  CONTINUE
2732  CONTINUE
      CALL GEOMRZ_ISUMRY(IOUT)
      CALL SRCOUT
      IF ((IOOPTN.GE.2)) THEN
        CABSRB(1)='0'
        CALL MATERIALGRID(NR, NZ, AMASS, 1, ECUT, PCUT, RCYL, ZPLANE, ME
     *  D, MEDIA, CDSTBL, CTRTBL, CABSRB)
      END IF
      IF ((IFULL.EQ.2)) THEN
        WRITE(6,2740)(I,IPHR(I),I=1,NREG)
2740    FORMAT(///' PULSE HEIGHT DISTRIBUTION IS SCORED IN ', 'THOSE REG
     *IONS DENOTED WITH A 1'/(10(I3,'(',I1,'), ')))
        WRITE(IOUT,311)(I,IPHR(I),I=1,NREG)
      END IF
      WRITE (IOUT, *) '\f'
      RETURN
200   FORMAT ( ' ',T20,'MONTE CARLO, TRANSPORT, AND SCATTER CONTROLS'/ /
     *' ',79('*')// ' ',T20,'MAX # OF HISTORIES TO RUN',T53,I12/ ' ',T20
     *,'MAX # OF HISTORIES TO ANALYZE',T53,I12/ ' ',T20,'INCIDENT CHARGE
     *',T63,I2)
201   FORMAT(' ',T20,'INCIDENT KINETIC ENERGY',T57,F9.3,' (MeV)')
202   FORMAT(' ',T20,'MAXIMUM INCIDENT KINETIC ENERGY',T57,F9.3,' (MeV)'
     *)
210   FORMAT(' ',T20,'FRACTIONAL ELECTRON ENERGY/STEP',T60,'DEFAULT')
211   FORMAT(' ',T20,'FRACTIONAL ELECTRON ENERGY/STEP',T60,F5.3)
220   FORMAT(' ',T20,'GLOBAL ELECTRON TRANSPORT CUT-OFF', T56,0PF9.3,' (
     *MeV)'/ ' ',T20,'GLOBAL PHOTON TRANSPORT CUT-OFF', T56,F9.3,' (MeV)
     *')
230   FORMAT(' ',T20,'MIN/MAX PHOTON STEP FORCED',T60,I6,'/',I6)
231   FORMAT(' ',T20,'PHOTON FORCE INTERACTION SWITCH',T60,'OFF')
235   FORMAT(T20,'Cross section enhancement factor of',T56,F8.1/ T20,'In
     * regions with a 1:'/ (T10, 10('(',I3,',',I1,')')))
236   FORMAT(T20,'No cross section enhancement used')
242   FORMAT(' ',T20,'RANGE REJECTION SWITCH',T60,'ON'/ T20,'  Range rej
     *ection for energy  <',T56,F9.3,' (MeV)'/ T20,'  Ranges determinedi
     *nternally from stopping powers')
243   FORMAT(' ',T20,'RANGE REJECTION SWITCH',T60,'OFF')
244   FORMAT(' ',T20,'RAYLEIGH SCATTERING INCLUDED')
260   FORMAT(' ',T20,'MAXIMUM CPUTIME ALLOWED',T59,F5.2,' (HRS)'/ ' ',T2
     *0,'STATS IN PEAK REGION OBJECTIVE',T59,F6.2,' %'/ ' ',T20,'1ST INI
     *TIAL RANDOM NUMBER SEED',T57,I12/ ' ',T20,'2ND INITIAL RANDOM NUMB
     *ER SEED',T57,I12)
265   FORMAT(' ',T20,'RUS ROU FOR PHOTONS CROSSING Z = ',T60,F10.3,' cm'
     */ T25,'WITH PROBABILITY OF SURVIVAL:',T60,F7.4)
266   FORMAT(' ',T20,'PATHLENGTH EXPONENTIAL TRANSFORMATION'/ T25,'VARIA
     *BLE FOR FORWARD GOING PHOTNS: ',T60,F10.3)
267   FORMAT(' ',T20,'DISCARD ALL ELECTRONS BELOW:',T60,F7.3/ T25,'IF TO
     *O FAR FROM CLOSEST BOUNDRY')
270   FORMAT(' ',T20,'# ZONES MULT SCATTERING SWITCHED OFF',T60,'NONE')
271   FORMAT(' ',T20,'# ZONES MULT SCATTERING SWITCHED OFF',T60,'ALL')
272   FORMAT(' ',T20,'# ZONES MULT SCATTERING SWITCHED OFF',T60,I2)
273   FORMAT(' ',T20,'# ZONES MOLL SCATTERING SWITCHED OFF',T60,'NONE')
274   FORMAT(' ',T20,'# ZONES MOLL SCATTERING SWITCHED OFF',T60,'ALL')
275   FORMAT(' ',T20,'# ZONES MOLL SCATTERING SWITCHED OFF',T60,I2)
276   FORMAT(' ',T20,'# ZONES BREM SCATTERING SWITCHED OFF',T60,'NONE')
277   FORMAT(' ',T20,'# ZONES BREM SCATTERING SWITCHED OFF',T60,'ALL')
278   FORMAT(' ',T20,'# ZONES BREM SCATTERING SWITCHED OFF',T60,I2)
279   FORMAT(' ',T20,'# ZONES BHAB SCATTERING SWITCHED OFF',T60,'NONE')
280   FORMAT(' ',T20,'# ZONES BHAB SCATTERING SWITCHED OFF',T60,'ALL')
281   FORMAT(' ',T20,'# ZONES BHAB SCATTERING SWITCHED OFF',T60,I2)
282   FORMAT(' ',T20,'# ZONES ELEC ENERGY LOSS/STEP ALTERED',T60,'NONE')
283   FORMAT(' ',T20,'# ZONES ELEC ENERGY LOSS/STEP ALTERED',T60,'ALL')
284   FORMAT(' ',T20,'# ZONES ELEC ENERGY LOSS/STEP ALTERED',T60,I2)
285   FORMAT(' ',T20,'# ZONES MAX ELEC STEP SIZE ALTERED',T60,'NONE')
286   FORMAT(' ',T20,'# ZONES MAX ELEC STEP SIZE ALTERED',T60,'ALL')
287   FORMAT(' ',T20,'# ZONES MAX ELEC STEP SIZE ALTERED',T60,I2)
289   FORMAT(' ',T20,'NORMAL ELECTRON TRANSPORT WITH DISCRETE INTERACTIO
     *NS')
290   FORMAT( / ' ',T20,'NO DISCRETE ELECTRON INTERACTIONS SAMPLED'/ ' '
     *,T20,'========================================='/)
300   FORMAT( ' ',79('*')/ / ' ',T20,'MATERIAL SUMMARY   ',I1,' MATERIAL
     *S USED'/ / ' ',79('*')// ' # MATERIAL  DENSITY(g/cm**3)',6X,'AE(Me
     *V)',4X,'AP(MeV)', 9X,'UE(MeV)',4X,'UP(MeV)'/ ' - --------  -------
     *---------',6X,'-------',4X,'-------', 9X,'-------',4X,'-------')
305   FORMAT(T22,' REGION(',I4,') HAS FLUORESCENT X-RAYS FOR Z=',I3)
306   FORMAT(T20,' The following regions have atomic relaxations on: ')
307   FORMAT(T20,' Atomic relaxations are off')
310   FORMAT(' ',I1,3X,6A1,4X,1PE10.3,2(7X,0PF9.3,2X,F9.3))
311   FORMAT(///' PULSE HEIGHT DISTRIBUTION IS SCORED IN THOSE REGIONS',
     *' DENOTED WITH A 1'/(10(I3,'(',I1,'), ')))
312   FORMAT(T20,'Bremsstrahlung splitting',T60,'OFF')
313   FORMAT(T20,'Bremsstrahlung splitting',T60,'ON'/T20, 'Initially, ea
     *ch bremsstrahlung photon split into ',I3,' photons')
314   FORMAT(T20,'Charged particle Russian Roulette',T60,'OFF')
315   FORMAT(T20,'Charged particle Russian Roulette',T60,'ON'/T20, 'With
     * probability of survival =',T60,F9.3)
      END
      SUBROUTINE OSUMRY
      implicit none
      integer*4 NCOMP
      real*8 RESULTS(200, 60, 7), UNCRTY(200, 60, 7), RADIAL_BINS(60),DE
     *PTH_BINS( 201)
      CHARACTER*60 EXPLANATIONS(7)
      CHARACTER*4 LABELS(7)
      real*8 FRACS(200,60,3:6)
      integer*4 IXD,IZD,IT,IZ,IX,IRL,I,IR
      real*8 TEMP
      CHARACTER*4 BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,
     *SCHAR, TCHAR,UCHAR,VCHAR
      COMMON/CHARS/ BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHA
     *R,SCHAR,TCHAR,UCHAR,VCHAR
      CHARACTER*4 CDSTBL( 12001),CTRTBL( 12001),CABSRB( 12001)
      COMMON/GEOM/ZPLANE( 201),RCYL(0:60), CYRAD2( 61), NZ,NR,NREG,NDOSE
     *,NZDOSE,NRDOSE,NPLANE, NZDMIN,NZDMAX,NRDMIN,NRDMAX, NTRACK( 12001)
     *,CDSTBL,CTRTBL,CABSRB,IDSTBL( 12001,2)
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,NZDMIN,NZDMAX,NRDM
     *IN,NRDMAX, NTRACK,IDSTBL
      CHARACTER*1 TITLE(80)
      COMMON/IODAT1/TITLE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(200,60),TMCPUO,TIMMAX,ST
     *ATLM,EIN,EKMAX, IDAT,IRESTART,IQIN,NESTEP,NSMAX,IXXIN,JXXIN,IVAL,D
     *ATCOUNT
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN,EKMAX
      integer*4 IDAT,IRESTART,IQIN,NESTEP,NSMAX, IXXIN,JXXIN,IVAL,DATCOU
     *NT
      integer*8 NCASE,NCASEO,NCASET
      COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE
      integer*4 ICHPIN,ILPIN,IOUT,IPAGE
      COMMON/PLOTC/ IPLOTR(60),IPLOTZ(200),IOPLOT,IPLTLP,IPLTPL,IPLPHB,N
     *PLOTR,NPLOTZ
      integer*4 IPLOTR,IPLOTZ,IOPLOT,IPLTLP,IPLTPL,IPLPHB,NPLOTR,NPLOTZ
      COMMON/SCORE/ SCDOSE(200,60,7),SCDOSE2(200,60,7), SCKERMA(200,60,7
     *),SCKERMA2(200,60,7), SCDOSEtoKERMA2(200,60,7),SCPDST(500),SCPDST2
     *(500), SCPCUM(500),SCPCUM2(500),SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCD
     *FBK(4),SCDFBK2(4),SCDFEP(4),SCDFEP2(4),SCDFDIFF(4),SCDFDIFF2(4), S
     *CSTP,SCSTP2,SCDSTP,SCDSTP2, PIISTP, SCSTP_LAST, SCDSTP_LAST,SCDOSE
     *_LAST(200,60,7), SCKERMA_LAST(200,60,7), SCKERMA_LASTOLD(200,60,7)
     *,SCPDST_LAST, IHSTRY, DFEN(4,4), PHENER,WT1OLD,BINTOP(500),SLOTE,D
     *ELTAE, SCDOSE_TMP(200,60,7), SCKERMA_TMP(200,60,7), SCKERMA_TMPOLD
     *(200,60,7), SCSTP_TMP,SCDSTP_TMP, MXNP,IFULL,ISTORE,IKERMA, IWATCH
     *,IOOPTN,IOUTSP, IPHR( 12001),MAXBIN,NCOMPT,during_pe_compt,during_
     *eii
      real*8 SCDOSE,SCDOSE2,SCKERMA,SCKERMA2,SCDOSEtoKERMA2,SCPDST,SCPDS
     *T2, SCPCUM,SCPCUM2,SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCDFBK,SCDFBK2,S
     *CDFEP,SCDFEP2,SCDFDIFF,SCDFDIFF2, SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIIS
     *TP
      integer*8 SCSTP_LAST, SCDSTP_LAST, SCDOSE_LAST, SCKERMA_LAST, SCKE
     *RMA_LASTOLD,SCPDST_LAST, IHSTRY
      real*8 DFEN, PHENER,WT1OLD,BINTOP,SLOTE,DELTAE, SCDOSE_TMP,SCKERMA
     *_TMP,SCKERMA_TMPOLD,SCSTP_TMP,SCDSTP_TMP
      integer*4 MXNP,IFULL,ISTORE,IKERMA, IWATCH,IOOPTN,IOUTSP, IPHR,MAX
     *BIN,NCOMPT,during_pe_compt,during_eii
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(100,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBE
     *AM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,
     *DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,P
     *ROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,
     *ZSOFST,                                                      SVTMP
     *1,SVTMP2,SVTMP3,SVTMP4,
     *         RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                       XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,W
     *EIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/USERRR/ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN, MINZ,MAXZ,MINR,MAXR
     *,IREJCT
      real*8 ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN
      integer*4 MINZ,MAXZ,MINR,MAXR,IREJCT
      COMMON/USERMI/EXPMFP,GWTOLD,ICSDA
      integer*4 ICSDA
      real*8 EXPMFP,GWTOLD
      COMMON/USERVR/ CEXPTR,GWAIT,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,
     *IQINC,MONOEN, cs_enhance,cs_enhance_current,ienhance,iefl( 12001),
     *ics_enhance, do_fast_step
      integer*4 ienhance,iefl,ics_enhance, IFORCE,NFMIN,NFMAX,NFTIME,ISO
     *URC,IFPB,IQINC,MONOEN
      real*8 CEXPTR,GWAIT,cs_enhance,cs_enhance_current
      logical do_fast_step
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      integer*4 egs_open_file, dose_unit
      IF ((IFULL.EQ.2)) THEN
        write(1,'(a)') '\f'
        write(iout,101) title
        call egs_fdate(iout)
        write(iout,104)
        CALL PLOTPH(TITLE,SCPDST,SCPDST2,SCPCUM,SCPCUM2, SCPTOT,SCPTOT2,
     *  SCDFEP,SCDFEP2,MAXBIN,SLOTE,BINTOP, IHSTRY,SCOMEG,SCOMEG2,SCPHEN
     *  ,SCPHEN2)
      END IF
      write(1,'(a)') '\f'
      write(iout,100) title
      call egs_fdate(iout)
      write(iout,105)
      IF ((IBRSPL .EQ. 1)) THEN
        WRITE(IOUT,90) nbr_split
      END IF
      IF ((ISOURC.EQ.21.OR.ISOURC.EQ.22)) THEN
        WRITE(IOUT,200) SCSTP,SCSTP2, SCSTP/(dble(NNREAD+NRCYCL*(NNREAD-
     *  IHSTRY))/dble(NCASE_PHSP)*NINCSRC), SCSTP2,(count_pII_steps+PIIS
     *  TP)/SCSTP,SCSTP2
      ELSE
        WRITE(IOUT,200) SCSTP,SCSTP2,SCSTP/dble(IHSTRY), SCSTP2,(count_p
     *  II_steps+PIISTP)/SCSTP,SCSTP2
      END IF
      IF ((ISOURC.EQ.21.OR.ISOURC.EQ.22)) THEN
        WRITE(IOUT,210) SCDSTP,SCDSTP2, SCDSTP/(dble(NNREAD+NRCYCL*(NNRE
     *  AD-IHSTRY))/dble(NCASE_PHSP)*NINCSRC), SCDSTP2,(count_pII_steps+
     *  PIISTP)/SCDSTP,SCDSTP2
      ELSE
        WRITE(IOUT,210) SCDSTP,SCDSTP2, SCDSTP/dble(IHSTRY), SCDSTP2,(co
     *  unt_pII_steps+PIISTP)/SCDSTP,SCDSTP2
      END IF
      IF ((IFULL.EQ.1)) THEN
        DO 2751 IXD=1,NRDOSE
          DO 2761 IZD=1,NZDOSE
            TEMP=SCDOSE(IZD,IXD,1)
            IF ((TEMP.EQ.0)) THEN
              DO 2771 IT=3,6
                FRACS(IZD,IXD,IT)=0.0
2771          CONTINUE
2772          CONTINUE
            ELSE
              DO 2781 IT=3,6
                FRACS(IZD,IXD,IT)=100.*SCDOSE(IZD,IXD,IT)/TEMP
2781          CONTINUE
2782          CONTINUE
            END IF
2761      CONTINUE
2762      CONTINUE
2751    CONTINUE
2752    CONTINUE
      END IF
      IF (((IOOPTN.EQ.1).OR.(IOOPTN.GT.2))) THEN
        IF ((NDOSE.EQ.1)) THEN
          IZ=NZDMIN
          IX=NRDMAX
          IRL=IZ+NZ*(IX-1)+1
          IF ((ISOURC.EQ.3.OR.ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOURC.EQ.
     *    23)) THEN
            WRITE(IOUT,299) IRL,IZ,IX,(SCDOSE(1,1,IT),SCDOSE2(1,1,IT),IT
     *      =1,2)
          ELSE
            WRITE(IOUT,300) IRL,IZ,IX,(SCDOSE(1,1,IT),SCDOSE2(1,1,IT),IT
     *      =1,2)
          END IF
          IF ((IFULL.EQ.1)) THEN
            WRITE(IOUT,302) (SCDOSE(1,1,IT),SCDOSE2(1,1,IT),FRACS(1,1,IT
     *      ),IT=3,6)
            IF ((ISOURC.EQ.3)) THEN
              IF ((IRL.EQ.NSRCRG)) THEN
                WRITE(IOUT,303)SCDOSE(1,1,7),SCDOSE2(1,1,7)
              END IF
            END IF
          END IF
        ELSE
          WRITE(IOUT,400)
          IF ((IFULL.NE.3)) THEN
            IF ((ISOURC.EQ.3.OR.ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOURC.E
     *      Q.23)) THEN
              WRITE(IOUT,399)
            ELSE
              WRITE(IOUT,401)
            END IF
          END IF
          IF ((IFULL.EQ.1)) THEN
            WRITE(IOUT,410)
            ICHPIN=12
            IPAGE=0
            WRITE(IOUT,411)
            DO 2791 IXD=1,NRDOSE
              DO 2801 IZD=1,NZDOSE
                IZ=IZD-1+NZDMIN
                IX=IXD+NRDMIN
                IRL=IZ+NZ*(IX-1)+1
                WRITE(IOUT,412) IRL,IZ,IX, (SCDOSE(IZD,IXD,IT),IT=1,7-1)
     *          , (SCDOSE2(IZ,IX,IT),IT=1,7-1), (FRACS(IZ,IX,IT),IT=3,6)
2801          CONTINUE
2802          CONTINUE
2791        CONTINUE
2792        CONTINUE
            IF ((ISOURC.EQ.3)) THEN
              IF ((CDSTBL(NSRCRG).EQ.DCHAR)) THEN
                IX=(NSRCRG-2)/NZ+1
                IZ=NSRCRG-1-NZ*(IX-1)
                IZD=IZ-NZDMIN+1
                IXD=IX-NRDMIN
                WRITE(IOUT,304)NSRCRG,IZ,IX, SCDOSE(IZD,IXD,7),SCDOSE2(I
     *          ZD,IXD,7)
              END IF
            END IF
          ELSE
            IF ((IFULL.EQ.3)) THEN
              IF ((ISOURC.EQ.3.OR.ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOURC
     *        .EQ.23)) THEN
                WRITE(IOUT,2810)
              ELSE
                WRITE(IOUT,2820)
              END IF
              WRITE(IOUT,2830)
            ELSE
              WRITE(IOUT,402)
            END IF
            DO 2841 IXD=1,NRDOSE
              DO 2851 IZD=1,NZDOSE
                IZ=IZD-1+NZDMIN
                IX=IXD+NRDMIN
                IRL=IZ+NZ*(IX-1)+1
                WRITE(IOUT,403) IRL,IZ,IX,(SCDOSE(IZD,IXD,IT),SCDOSE2(IZ
     *          D,IXD,IT),IT=1,2)
2851          CONTINUE
2852          CONTINUE
2841        CONTINUE
2842        CONTINUE
            dose_unit = egs_open_file(10,0,1,'.egsdose')
            WRITE(dose_unit,'(80A1)') TITLE
            WRITE(dose_unit, '('' There are'',I5,'' radial zones, midpoi
     *nts:'')')NR
            WRITE(dose_unit,'( 8(F9.4,'',''))')((RCYL(I-1)+RCYL(I))/2.,I
     *      =1,NR)
            WRITE(dose_unit,'('' There are '',I5,'' depth regions'')') N
     *      Z
            DO 2861 IZ=1,NZ
              WRITE(dose_unit,'('' Depth centered at: '',F12.3)') (ZPLAN
     *        E(IZ)+ZPLANE(IZ+1))/2.
              WRITE(dose_unit,'( 4(1PE10.3,''+/-'',0PF5.2,''% ''))') (SC
     *        DOSE(IZ,IR,1),SCDOSE2(IZ,IR,1), IR=1,NR)
2861        CONTINUE
2862        CONTINUE
            close(dose_unit)
          END IF
        END IF
      END IF
      IF (((IOOPTN.EQ.0).OR.(IOOPTN.EQ.2).OR.(IOOPTN.EQ.4))) THEN
        DO 2871 IXD=1,NRDOSE
          DO 2881 IZD=1,NZDOSE
            RESULTS(IZD,IXD,1)=SCDOSE(IZD,IXD,1)
            RESULTS(IZD,IXD,2)=SCDOSE(IZD,IXD,2)
            RESULTS(IZD,IXD,3)=SCKERMA(IZD,IXD,1)
            RESULTS(IZD,IXD,4)=SCDOSE(IZD,IXD,1)/SCKERMA(IZD,IXD,1)
            UNCRTY(IZD,IXD,1)=SCDOSE2(IZD,IXD,1)
            UNCRTY(IZD,IXD,2)=SCDOSE2(IZD,IXD,2)
            UNCRTY(IZD,IXD,3)=SCKERMA2(IZD,IXD,1)
            UNCRTY(IZD,IXD,4)=SCDOSEtoKERMA2(IZD,IXD,1)
            IF (((IFULL.EQ.1).AND.(IKERMA.EQ.0))) THEN
              DO 2891 IT=3,6
                RESULTS(IZD,IXD,IT-1)=FRACS(IZD,IXD,IT)
                UNCRTY(IZD,IXD,IT-1)=SCDOSE2(IZD,IXD,IT)
2891          CONTINUE
2892          CONTINUE
            END IF
            IF (((IFULL.EQ.1).AND.(IKERMA.EQ.1))) THEN
              RESULTS(IZD,IXD,2)=SCKERMA(IZD,IXD,1)
              RESULTS(IZD,IXD,3)=SCDOSE(IZD,IXD,1)/SCKERMA(IZD,IXD,1)
              UNCRTY(IZD,IXD,2)=SCKERMA2(IZD,IXD,1)
              UNCRTY(IZD,IXD,3)=SCDOSEtoKERMA2(IZD,IXD,1)
              DO 2901 IT=4,7
                RESULTS(IZD,IXD,IT)=FRACS(IZD,IXD,IT-1)
                UNCRTY(IZD,IXD,IT)=SCDOSE2(IZD,IXD,IT-1)
2901          CONTINUE
2902          CONTINUE
            END IF
            IF ((IFULL.EQ.3)) THEN
              RESULTS(IZD,IXD,4)=SCKERMA(IZD,IXD,2)
              RESULTS(IZD,IXD,5)=SCDOSE(IZD,IXD,1)/SCKERMA(IZD,IXD,1)
              RESULTS(IZD,IXD,6)=SCDOSE(IZD,IXD,2)/SCKERMA(IZD,IXD,2)
              UNCRTY(IZD,IXD,4)=SCKERMA2(IZD,IXD,2)
              UNCRTY(IZD,IXD,5)=SCDOSEtoKERMA2(IZD,IXD,1)
              UNCRTY(IZD,IXD,6)=SCDOSEtoKERMA2(IZD,IXD,2)
            END IF
2881      CONTINUE
2882      CONTINUE
2871    CONTINUE
2872    CONTINUE
        IF ((IKERMA.EQ.1)) THEN
          IF ((IFULL.EQ.0)) THEN
            NCOMP=4
          END IF
          IF ((IFULL.EQ.1)) THEN
            NCOMP=7
          END IF
          IF ((IFULL.EQ.2)) THEN
            NCOMP=4
          END IF
          IF ((IFULL.EQ.3)) THEN
            NCOMP=6
          END IF
        END IF
        IF ((IKERMA.EQ.0)) THEN
          IF ((IFULL.EQ.1)) THEN
            NCOMP=5
          ELSE
            NCOMP=2
          END IF
        END IF
        DO 2911 IX=1,NRDOSE+1
          RADIAL_BINS(IX)=RCYL(IX+NRDMIN-1)
2911    CONTINUE
2912    CONTINUE
        DO 2921 IZ=1,NZDOSE+1
          DEPTH_BINS(IZ)=ZPLANE(IZ+NZDMIN-1)
2921    CONTINUE
2922    CONTINUE
        IF ((ISOURC.EQ.3.OR.ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOURC.EQ.23
     *  )) THEN
          EXPLANATIONS(1)='Total dose (Gray/incident particle)'
        ELSE
          EXPLANATIONS(1)='Total dose (Gray/incident fluence)'
        END IF
        LABELS(1)='T  :'
        IF ((IFULL.EQ.3)) THEN
          EXPLANATIONS(2)='Scatter dose (after Compton or fluorecent rea
     *bsorbed)'
          LABELS(2)='Sca:'
        ELSE
          EXPLANATIONS(2)='Total dose minus stoppers'
          LABELS(2)='T-S:'
        END IF
        EXPLANATIONS(3)='Kerma'
        LABELS(3)='K  :'
        IF ((IFULL.NE.3)) THEN
          EXPLANATIONS(4)='Dose to kerma'
          LABELS(4)='D/K:'
        ELSE
          EXPLANATIONS(4)='Kerma scatter'
          LABELS(4)='Ksc:'
          EXPLANATIONS(5)='Dose to kerma'
          lABELS(5)='D/K:'
          EXPLANATIONS(6)='Dose to kerma scatter'
          LABELS(6)='DsKs'
        END IF
        IF ((IFULL.EQ.1).AND.(IKERMA.EQ.0)) THEN
          EXPLANATIONS(2)='% dose from front wall (error is % OF %)'
          LABELS(2)='FT :'
          EXPLANATIONS(3)='% dose from outer wall'
          LABELS(3)='OUT:'
          EXPLANATIONS(4)='% dose from back wall'
          LABELS(4)='BK :'
          EXPLANATIONS(5)='% dose from inner wall'
          LABELS(5)='IN :'
        END IF
        IF ((IFULL.EQ.1).AND.(IKERMA.EQ.1)) THEN
          EXPLANATIONS(2)='Total kerma'
          LABELS(2)='K  :'
          EXPLANATIONS(3)='Total dose to kerma'
          LABELS(3)='D/K:'
          EXPLANATIONS(4)='% dose from front wall (error is % of %)'
          LABELS(4)='FT :'
          EXPLANATIONS(5)='% dose from outer wall'
          LABELS(5)='OUT:'
          EXPLANATIONS(6)='% dose from back wall'
          LABELS(6)='BK :'
          EXPLANATIONS(7)='% dose from inner wall'
          LABELS(7)='IN :'
        END IF
        CALL ZONEGRID(NRDOSE, NZDOSE, NRDMIN, NZDMIN, NZ, RESULTS, UNCRT
     *  Y, NCOMP, RADIAL_BINS, DEPTH_BINS, LABELS, EXPLANATIONS)
      END IF
      IF ((ILPIN.NE.6)) THEN
        write(iout,'(a)') '\f'
      END IF
      IF((IOPLOT.EQ.1))CALL PLOTEN
      RETURN
90    FORMAT(/' Final bremsstrahlung photons split into ',I3,' photons'/
     *)
100   FORMAT(' ',80A1/' ',T59,$)
105   FORMAT(///T30,'SUMMARY OF DOSE REGION RESULTS'/ ' ',T30,'*********
     **********************')
101   FORMAT(' ',80A1/' ',T55,$)
104   FORMAT(/// T30,'Summary of pulse height distribution'/ T30,'******
     *******************************')
200   FORMAT(/' ',T26,'Total # charged particle steps',T58, 1PE10.3,' +/
     *-',0PF6.3,'%'/ ' ',T13,'# of charged particle steps/initial histor
     *y',T58, 1PE10.3,' +/-',0PF6.3,'%'/ ' ','# of presta-II steps/total
     * # of charged particle steps', T61,F7.3,' +/-',0PF6.3,'%')
210   FORMAT(/' ',T19,'# charged particle steps in dose reg.' ,T58,1PE10
     *.3,' +/-',0PF6.3,'%'/ ' ',T17,'# of steps in dose reg./initial his
     *tory' ,T58,1PE10.3,' +/-',0PF6.3,'%'/ ' ',T12,'# of presta-II step
     *s/# of steps in dose reg.', T61,F7.3,' +/-',0PF6.3,'%')
299   FORMAT(/' Geometrical zone number:',T53,I10/ ' Planar zone number:
     *',T53,I10/ ' Cylndrical zone number:',T53,I10// ' Total dose (Gray
     */(source particle)):', T50,1PE11.4,' +/- ',0PF6.3,'%'/ ' Total dos
     *e minus stoppers:', T50,1PE11.4,' +/- ',0PF6.3,'%')
300   FORMAT(/' Geometrical zone number:',T53,I10/ ' Planar zone number:
     *',T53,I10/ ' Cylndrical zone number:',T53,I10// ' Total dose (Gray
     */(incident fluence)):', T50,1PE11.4,' +/- ',0PF6.3,'%'/ ' Total do
     *se minus stoppers:', T50,1PE11.4,' +/- ',0PF6.3,'%')
302   FORMAT( ' Total dose from front planar wall:', T50,1PE11.4,' +/- '
     *,0PF6.3,'%',1X,'(',0PF5.1,'%)'/ ' Total dose from outside curved w
     *all:', T50,1PE11.4,' +/- ',0PF6.3,'%',1X,'(',0PF5.1,'%)'/ ' Totald
     *ose from back planar wall:', T50,1PE11.4,' +/- ',0PF6.3,'%',1X,'('
     *,0PF5.1,'%)'/ ' Total dose from inner curved wall:', T50,1PE11.4,'
     * +/- ',0PF6.3,'%',1X,'(',0PF5.1,'%)')
303   FORMAT(' Total dose deposited by particles emergent ', 'from the d
     *ose/source region:', T50,1PE11.4,' +/- ',0PF6.3,'%')
304   FORMAT(/' ','Dose scored in source region due to emergent ', 'part
     *icles : Z# P# C#    Dose    uncertainty'/' ', 57X,I2,I3,I3,E11.3,E
     *12.3)
400   FORMAT(/' ',T20,'Z# : Geometrical zone number'/ ' ',T20,'P# : Plan
     *ar zone number'/ ' ',T20,'C# : Cylndrical zone number')
399   FORMAT(' ',T20,'T  : Total dose (Gray/(source particle))'/ ' ',T20
     *,'T-S: Total dose minus stoppers')
2810  FORMAT(' ',T20,'T  : Total dose (Gray/(source particle))'/ ' ',T20
     *, 'Sca: Scatter dose (after Compton or fluorecent  reabsorbed ')
401   FORMAT(' ',T20,'T  : Total dose (Gray/(incident fluence))'/ ' ',T2
     *0,'T-S: Total dose minus stoppers')
2820  FORMAT(' ',T20,'T  : Total dose (Gray/(incident fluence))'/ ' ',T2
     *0, 'Sca: Scatter dose (after Compton or fluorecent  reabsorbed ')
402   FORMAT(/'  Z# P# C#          T                  T-S'/ ' --- -- ---
     *------------------ -------------------')
2830  FORMAT(/'  Z# P# C#          T                  Sca'/ ' --- -- ---
     *------------------ -------------------')
403   FORMAT(' ',I3,2(1X,I2),1X,2(1PE11.4,' +/-',0PF6.3,'% '))
410   FORMAT(' ',T20,'F  : TOTAL DOSE FROM FRONT PLANAR WALL'/ ' ',T20,'
     *O  : TOTAL DOSE FROM OUTSIDE CURVED WALL'/ ' ',T20,'B  : TOTAL DOS
     *E FROM BACK PLANAR WALL'/ ' ',T20,'I  : TOTAL DOSE FROM INNER CURV
     *ED WALL')
411   FORMAT(/'  Z# P# C# ', '     T         T-S         F          O  '
     *, '     B          I'/ ' --- -- -- ', '---------- ---------- -----
     *----- ---------- ', '---------- ----------')
412   FORMAT(' ',I3,2(1X,I2),1X,1PE11.4,5(1X,E10.3)/ '   %ERROR=', 6(3X,
     *0PF6.3,4X)/ '    %DOSE=',21X,4(2X,0PF7.3,2X))
      END
      CHARACTER*(*) FUNCTION CMPRES(UNCOMP)
      implicit none
      CHARACTER*(*) UNCOMP
      logical HOLRTH
      integer*4 INDX,NARG,I,NRES
      HOLRTH=.FALSE.
      INDX=1
      NARG=LEN(UNCOMP)
      DO 2931 I=1,NARG
        IF((UNCOMP(I:I).EQ.''''))HOLRTH=.NOT.HOLRTH
        IF ((HOLRTH)) THEN
          CMPRES(INDX:INDX)=UNCOMP(I:I)
          INDX=INDX+1
        ELSE
          IF ((UNCOMP(I:I).NE.' ')) THEN
            CMPRES(INDX:INDX)=UNCOMP(I:I)
            INDX=INDX+1
          END IF
        END IF
2931  CONTINUE
2932  CONTINUE
      NRES=LEN(CMPRES)
      IF ((INDX.LE.NRES)) THEN
        DO 2941 I=INDX,NRES
          CMPRES(I:I)=' '
2941    CONTINUE
2942    CONTINUE
      END IF
      RETURN
      END
      SUBROUTINE PLOTPH(TITLE,PDST,PDSTUN,PCUM,PCUMUN,PTOT,PTOTUN,DFEP,D
     *FEPUN, MAXBIN,SLOTE,BINTOP,IHSTRY,OMEG,OMEGUN,PHEN,PHENUN)
      implicit none
      CHARACTER SPACE,BAR,LINE(61),SYMBOL(6)
      REAL*8 PDST(500),PDSTUN(500),PTOT,PTOTUN,DFEP(4),DFEPUN(4), PCUM(5
     *00),PCUMUN(500),omeg,omegun,phen,phenun
      real*8 BINTOP(500),xplot(500),yplot(500), errplot(500),SLOTE
      integer*8 ihstry
      integer*4 maxbin
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(200,60),TMCPUO,TIMMAX,ST
     *ATLM,EIN,EKMAX, IDAT,IRESTART,IQIN,NESTEP,NSMAX,IXXIN,JXXIN,IVAL,D
     *ATCOUNT
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN,EKMAX
      integer*4 IDAT,IRESTART,IQIN,NESTEP,NSMAX, IXXIN,JXXIN,IVAL,DATCOU
     *NT
      integer*8 NCASE,NCASEO,NCASET
      character*1 TITLE(80)
      character*60 xtitle,ytitle,subtitle,seriestitle,plottitle
      character*80 graphtitle
      integer*4 NHIST,IOUT,IB,j,ilev,ipk,iunit,icurvenum,iplttype,iaxist
     *ype
      real*8 HIST,sfac,eb,sum,uncert,binw,histmin
      integer*4 egs_open_file
      DATA SPACE/' '/,BAR/'|'/,SYMBOL/'*','+','$','-','#','@'/
      DATA NHIST/61/,HIST/61./,IOUT/1/
      sfac=0
      DO 2951 IB=1,MAXBIN
        IF (( PDST(IB) .GT. sfac )) THEN
          sfac = PDST(IB)
        END IF
2951  CONTINUE
2952  CONTINUE
      WRITE(IOUT,4) IHSTRY
      WRITE(IOUT,5)
      DO 2961 IB=1,MAXBIN
        IF ((SLOTE.GT.0.0)) THEN
          EB=IB*SLOTE
        ELSE
          EB=BINTOP(IB)
        END IF
        DO 2971 J=1,NHIST
          LINE(J)=SPACE
2971    CONTINUE
2972    CONTINUE
        ILEV=0
        IF ((PDST(IB).GT.0.0)) THEN
          ILEV=HIST+DLOG10(PDST(IB)/SFAC)*20.+0.5
        END IF
        IF (((ILEV.GT.0).AND.(ILEV.LE.NHIST))) THEN
          LINE(ILEV)=SYMBOL(1)
        END IF
        DO 2981 J=1,4
          ILEV=20*J-19
          IF((LINE(ILEV).EQ.SPACE))LINE(ILEV)=BAR
2981    CONTINUE
2982    CONTINUE
        WRITE(IOUT,10) LINE,EB,PDST(IB),PDSTUN(IB),PCUM(IB),PCUMUN(IB)
2961  CONTINUE
2962  CONTINUE
      WRITE(IOUT,30)
      SUM=0.0
      DO 2991 IPK=1,4
        SUM=SUM+DFEP(IPK)
2991  CONTINUE
2992  CONTINUE
      IF ((SUM.GE.0.00005 )) THEN
        WRITE(IOUT,40) (DFEP(IPK),DFEPUN(IPK),IPK=1,4)
      END IF
      IF ((OMEG.EQ.0.0)) THEN
        WRITE(IOUT,50) PTOT,PTOTUN
      ELSE
        UNCERT=SQRT(PTOTUN**2 + OMEGUN**2)
        WRITE(IOUT,60) OMEG,OMEGUN,PTOT/(4.*3.141593),PTOTUN,PTOT/OMEG,U
     *  NCERT
      END IF
      WRITE(IOUT,70) PHEN,PHENUN
      iunit = egs_open_file(9,0,1,'.egseff')
      WRITE(IUNIT,75) TITLE
      WRITE(IUNIT,80)MAXBIN
      DO 3001 IB=1,MAXBIN
        IF ((SLOTE.GT.0.0)) THEN
          EB=IB*SLOTE
          BINW=SLOTE
        ELSE
          EB=BINTOP(IB)
          IF ((IB.EQ.1)) THEN
            BINW=BINTOP(1)
          ELSE
            BINW=EB-BINTOP(IB-1)
          END IF
        END IF
        IF ((BINW.EQ.0.0)) THEN
          BINW = 1E-9
        END IF
        xplot(IB) = EB
        yplot(IB) = PDST(IB)/BINW
        IF ((PDST(IB) .NE. 0.0)) THEN
          errplot(IB)=PDSTUN(IB)*PDST(IB)/(BINW*100.)
        ELSE
          errplot(IB) = 0.0
        END IF
        WRITE(IUNIT,90) EB,PDST(IB)/BINW,errplot(IB)
3001  CONTINUE
3002  CONTINUE
      WRITE(IUNIT,100) (DFEP(IPK),DFEPUN(IPK),IPK=1,4),PTOT,PTOTUN
      close(iunit)
      iunit = egs_open_file(22,0,1,'.plotphd')
      DO 3011 J=1,80
        graphtitle(j:j)=title(j)
3011  CONTINUE
3012  CONTINUE
      xtitle='energy/MeV'
      ytitle='cts/MeV'
      subtitle='pulse height distribution from dosrznrc'
      icurvenum=0
      iplttype=1
      histmin=0.0
      iaxistype = 0
      seriestitle=' '
      call xvgrplot(xplot,yplot,errplot,MAXBIN,icurvenum,seriestitle, xt
     *itle,ytitle,graphtitle,subtitle,iunit,iplttype,histmin,iaxistype)
      close(iunit)
4     FORMAT(/I12,' HISTORIES ANALYSED'/)
5     FORMAT(/65X,'EBIN'/' 3',19X,'2',19X,'1',7X, '-LOG',8X,'0    TOP',9
     *X,'PDST              CUMULATIVE')
10    FORMAT(1X,61A1,F8.4,1X,2(0PF11.4,' (',F6.3,'%)'))
20    FORMAT(/62X,'TOTALS',2X,6(I4,3X))
30    FORMAT(/' PLOT NORMALIZED TO PEAK OF ONE, ', 'PDST IS NORMALIZED T
     *O UNIT AREA'/)
40    FORMAT(' PEAK EFFICIENCIES PER COUNT IN SPECTRUM'// ' FULL ENERGYP
     *EAK',T30,F10.4,'(+-',F6.3,'%)'/ ' SINGLE ESCAPE PK',T30,F10.4,'(+-
     *',F6.3,'%)'/ ' DOUBLE ESCAPE PK',T30,F10.4,'(+-',F6.3,'%)'/ ' 511 
     *KEV PK' ,T30,F10.4,'(+-',F6.3,'%)'/)
50    FORMAT(/'  FRACTION OF INITIAL PARTICLES (HITTING DETECTOR HOUSING
     * ', '(if parallel beam) WHICH CAUSE PULSE = ',0PF14.4,'(',F6.3,'%)
     *')
60    FORMAT(/' SOLID ANGLE SUBTENDED BY DETECTOR HOUSING =       ', 1PE
     *13.3,'(',0PF5.1,'%)'/ /' FRACTION OF PARTICLES INTO 4-PI WHICH CAU
     *SE A PULSE =          ', 1PE13.3,'(',0PF5.1,'%)'/ /'FRACTION OF PA
     *RTICLES INCIDENT ON HOUSING WHICH CAUSE A PULSE =',1PE13.3,'(',0PF
     *5.1,'%)')
70    FORMAT(/'  ENERGY DEPOSITED IN DETECTOR PER INITIAL PARTICLE:', 0P
     *F14.5,' MeV (+-',F6.3,'%)')
75    FORMAT(1X,80A1)
80    FORMAT(I5,T40,'# energy bins to follow, bin top,cts/MeV,uncertaint
     *y(abs)')
90    FORMAT(3(E12.4,','))
100   FORMAT( 1X,'NOW INDIVIDUAL PEAK AND TOTAL EFFICIENCIES'/ (2E12.4))
      RETURN
      END
      SUBROUTINE PLOTSN
      implicit none
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      INTEGER NUM_IOPLOT, NUM_IPLTLP, NUM_IPLTPL, NUM_IPLPHB, NUM_IPLTRA
     *D, NUM_IPLTPLN
      INTEGER I
      INTEGER ICOL1, ICOL2, NPTS, PLTYPE, IAXISTYPE, UNITNUM, CURVENUM,
     *CHECK
      integer int
      INTEGER IX2CHAR, IZ2CHAR
      LOGICAL NEGVAL
      CHARACTER*103 FMT120
      CHARACTER*103 FMT121
      CHARACTER*4 CH_IX, CH_IZ
      CHARACTER*1 a(3)
      CHARACTER*60 SERIESTITLE, XTITLE, YTITLE, SUBTITLE
      CHARACTER*80 GRAPHTITLE
      CHARACTER CMPRES*103,FMT*103
      real*8 XCOORD(500), YCOORD(500), UNCERT(500)
      CHARACTER*4 HCHAR,PCHAR
      CHARACTER*4 DIGITS(10)
      CHARACTER*4 CDSTBL( 12001),CTRTBL( 12001),CABSRB( 12001)
      COMMON/GEOM/ZPLANE( 201),RCYL(0:60), CYRAD2( 61), NZ,NR,NREG,NDOSE
     *,NZDOSE,NRDOSE,NPLANE, NZDMIN,NZDMAX,NRDMIN,NRDMAX, NTRACK( 12001)
     *,CDSTBL,CTRTBL,CABSRB,IDSTBL( 12001,2)
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,NZDMIN,NZDMAX,NRDM
     *IN,NRDMAX, NTRACK,IDSTBL
      CHARACTER*1 TITLE(80)
      COMMON/IODAT1/TITLE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(200,60),TMCPUO,TIMMAX,ST
     *ATLM,EIN,EKMAX, IDAT,IRESTART,IQIN,NESTEP,NSMAX,IXXIN,JXXIN,IVAL,D
     *ATCOUNT
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN,EKMAX
      integer*4 IDAT,IRESTART,IQIN,NESTEP,NSMAX, IXXIN,JXXIN,IVAL,DATCOU
     *NT
      integer*8 NCASE,NCASEO,NCASET
      COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE
      integer*4 ICHPIN,ILPIN,IOUT,IPAGE
      COMMON/PLOTC/ IPLOTR(60),IPLOTZ(200),IOPLOT,IPLTLP,IPLTPL,IPLPHB,N
     *PLOTR,NPLOTZ
      integer*4 IPLOTR,IPLOTZ,IOPLOT,IPLTLP,IPLTPL,IPLPHB,NPLOTR,NPLOTZ
      COMMON/SCORE/ SCDOSE(200,60,7),SCDOSE2(200,60,7), SCKERMA(200,60,7
     *),SCKERMA2(200,60,7), SCDOSEtoKERMA2(200,60,7),SCPDST(500),SCPDST2
     *(500), SCPCUM(500),SCPCUM2(500),SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCD
     *FBK(4),SCDFBK2(4),SCDFEP(4),SCDFEP2(4),SCDFDIFF(4),SCDFDIFF2(4), S
     *CSTP,SCSTP2,SCDSTP,SCDSTP2, PIISTP, SCSTP_LAST, SCDSTP_LAST,SCDOSE
     *_LAST(200,60,7), SCKERMA_LAST(200,60,7), SCKERMA_LASTOLD(200,60,7)
     *,SCPDST_LAST, IHSTRY, DFEN(4,4), PHENER,WT1OLD,BINTOP(500),SLOTE,D
     *ELTAE, SCDOSE_TMP(200,60,7), SCKERMA_TMP(200,60,7), SCKERMA_TMPOLD
     *(200,60,7), SCSTP_TMP,SCDSTP_TMP, MXNP,IFULL,ISTORE,IKERMA, IWATCH
     *,IOOPTN,IOUTSP, IPHR( 12001),MAXBIN,NCOMPT,during_pe_compt,during_
     *eii
      real*8 SCDOSE,SCDOSE2,SCKERMA,SCKERMA2,SCDOSEtoKERMA2,SCPDST,SCPDS
     *T2, SCPCUM,SCPCUM2,SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCDFBK,SCDFBK2,S
     *CDFEP,SCDFEP2,SCDFDIFF,SCDFDIFF2, SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIIS
     *TP
      integer*8 SCSTP_LAST, SCDSTP_LAST, SCDOSE_LAST, SCKERMA_LAST, SCKE
     *RMA_LASTOLD,SCPDST_LAST, IHSTRY
      real*8 DFEN, PHENER,WT1OLD,BINTOP,SLOTE,DELTAE, SCDOSE_TMP,SCKERMA
     *_TMP,SCKERMA_TMPOLD,SCSTP_TMP,SCDSTP_TMP
      integer*4 MXNP,IFULL,ISTORE,IKERMA, IWATCH,IOOPTN,IOUTSP, IPHR,MAX
     *BIN,NCOMPT,during_pe_compt,during_eii
      COMMON/USERRR/ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN, MINZ,MAXZ,MINR,MAXR
     *,IREJCT
      real*8 ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN
      integer*4 MINZ,MAXZ,MINR,MAXR,IREJCT
      COMMON/USERMI/EXPMFP,GWTOLD,ICSDA
      integer*4 ICSDA
      real*8 EXPMFP,GWTOLD
      COMMON/USERVR/ CEXPTR,GWAIT,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,
     *IQINC,MONOEN, cs_enhance,cs_enhance_current,ienhance,iefl( 12001),
     *ics_enhance, do_fast_step
      integer*4 ienhance,iefl,ics_enhance, IFORCE,NFMIN,NFMAX,NFTIME,ISO
     *URC,IFPB,IQINC,MONOEN
      real*8 CEXPTR,GWAIT,cs_enhance,cs_enhance_current
      logical do_fast_step
      integer*4 IPLTUNX,IPLTUN,J,IZD,IXD,NPPAGE,IX,ICOUNT,IXR,IZ,IZZ
      real*8 TDSMAX,HISTXMIN
      integer*4 egs_open_file
      DATA DIGITS /'0','1','2','3','4','5','6','7','8','9'/
      DATA HCHAR/'H'/,PCHAR/'P'/
      save NUM_IOPLOT,NUM_IPLTLP,NUM_IPLTPL,NUM_IPLPHB,NUM_IPLTRAD,NUM_I
     *PLTPLN, I,ICOL1, ICOL2, NPTS, PLTYPE, IAXISTYPE, UNITNUM, CURVENUM
     *, CHECK, IX2CHAR, IZ2CHAR, NEGVAL, FMT120, FMT121, CH_IX, CH_IZ, a
     *, SERIESTITLE, XTITLE, YTITLE, SUBTITLE, FMT, XCOORD,YCOORD,UNCERT
     *,HCHAR,PCHAR,DIGITS, IPLTUNX,IPLTUN,J,IZD,IXD,NPPAGE,IX,ICOUNT,IXR
     *,IZ,IZZ, TDSMAX,HISTXMIN,int
      DATA FMT120/
     *'(1X,F7.3,T10,''|'',T35,''|'',T59,''|'',T83,''|'',T107,
     *''|'',T131,''|'',T<ICOL2+10>,''S'',T<ICOL1+10>,''T'')'/
      DATA FMT121/
     *'(1X,F7.3,T10,''+'',T35,''+'',T59,''+'',T83,''+'',T107,
     *''+'',T131,''+'',T<ICOL2+10>,''S'',T<ICOL1+10>,''T'')'/
      DELIMETER='PLOT CONTROL'
      IVAL=0
      IVAL=IVAL+1
      NUM_IOPLOT=IVAL
      VALUES_SOUGHT(IVAL)='PLOTTING'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='OFF'
      ALLOWED_INPUTS(IVAL,1)='ON'
      NMIN = NUM_IOPLOT
      NMAX = NUM_IOPLOT
      CALL GET_INPUT
      IOPLOT=VALUE(NUM_IOPLOT,1)
      WRITE(6,3020)
3020  FORMAT(/' *** INPUT for plotting ***')
      IF ((IOPLOT.EQ.1)) THEN
        WRITE(6,3030)
3030    FORMAT(/'PLOTTING WILL BE DONE')
      END IF
      IF ((IOPLOT.EQ.0)) THEN
        WRITE(6,3040)
3040    FORMAT(/' NO PLOTTING OR PLOT PREPARATION WILL BE DONE')
      ELSE
        WRITE(6,3050)
3050    FORMAT(//' *** INPUT which types of plots ***')
        IVAL=IVAL+1
        NUM_IPLTLP=IVAL
        VALUES_SOUGHT(IVAL)='LINE PRINTER OUTPUT'
        NVALUE(IVAL)=1
        TYPE(IVAL)=3
        ALLOWED_INPUTS(IVAL,0)='OFF'
        ALLOWED_INPUTS(IVAL,1)='ON'
        NMIN = NUM_IPLTLP
        NMAX = NUM_IPLTLP
        CALL GET_INPUT
        IPLTLP=VALUE(NUM_IPLTLP,1)
        IF ((IPLTLP.EQ.0)) THEN
          WRITE(6,3060)
3060      FORMAT(/' NO LINEPRINTER PLOTS WILL BE DRAWN')
        ELSE
          WRITE(6,3070)
3070      FORMAT(/' LINEPRINTER PLOTS WILL BE DRAWN')
        END IF
        IVAL=IVAL+1
        NUM_IPLTPL=IVAL
        VALUES_SOUGHT(IVAL)='EXTERNAL PLOTTER OUTPUT'
        NVALUE(IVAL)=1
        TYPE(IVAL)=3
        ALLOWED_INPUTS(IVAL,0)='OFF'
        ALLOWED_INPUTS(IVAL,1)='ON'
        NMIN = NUM_IPLTPL
        NMAX = NUM_IPLTPL
        CALL GET_INPUT
        IPLTPL=VALUE(NUM_IPLTPL,1)
        IF ((IPLTPL.EQ.0)) THEN
          WRITE(6,3080)
3080      FORMAT(/' No plotter files will be prepared')
        ELSE
          WRITE(6,3090)
3090      FORMAT(/' Files will be prepared for external plotter')
          IPLTUNX=23
          IPLTUN=3
          WRITE(6,3100)
3100      FORMAT(/' *** INPUT type of plot ***')
          IVAL=IVAL+1
          NUM_IPLPHB=IVAL
          VALUES_SOUGHT(IVAL)='EXTERNAL PLOT TYPE'
          NVALUE(IVAL)=1
          TYPE(IVAL)=3
          ALLOWED_INPUTS(IVAL,1)='POINT'
          ALLOWED_INPUTS(IVAL,2)='HISTOGRAM'
          ALLOWED_INPUTS(IVAL,3)='BOTH'
          NMIN = NUM_IPLPHB
          NMAX = NUM_IPLPHB
          CALL GET_INPUT
          IPLPHB=VALUE(NUM_IPLPHB,1)
          WRITE(6,3110)IPLPHB
3110      FORMAT(/' POINT PLOT(1)/HISTOGRAM(2)/BOTH(3) WILL BE PREPARED:
     *',I2)
        END IF
        WRITE(6,3120)
3120    FORMAT(/' *** INPUT which plots to do ***')
        IVAL=IVAL+1
        NUM_IPLTRAD=IVAL
        VALUES_SOUGHT(IVAL)='PLOT RADIAL REGION IX'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=0
        VALUE_MAX(IVAL)=NR
        DEFAULT(IVAL)=NR
        NVALUE(IVAL)=0
        NMIN = NUM_IPLTRAD
        NMAX = NUM_IPLTRAD
        CALL GET_INPUT
        NPLOTR=NVALUE(NUM_IPLTRAD)
        IF ((VALUE(NUM_IPLTRAD,1) .GT. 0)) THEN
          DO 3131 J=1,NPLOTR
            IPLOTR(J)=VALUE(NUM_IPLTRAD,J)
            IF ((IPLOTR(J).LT.NRDMIN+1.OR.IPLOTR(J).GT.NRDMAX)) THEN
              WRITE(6,3140)IPLOTR(J)
3140          FORMAT(' *************************************************
     ******'/ ' ** WARNING: DOSE IS NOT SCORED IN RADIAL REGION ',I3,' *
     **'/ ' **          DOSE WILL NOT BE PLOTTED FOR THIS REGION *'/ ' *
     ******************************************************'/)
              IPLOTR(J)=0
            ELSE
              WRITE(6,3150)IPLOTR(J)
3150          FORMAT('PLOTTING RADIAL ZONE ', I3)
              IPLOTR(J)=IPLOTR(J)-NRDMIN
            END IF
3131      CONTINUE
3132      CONTINUE
          WRITE(6,3160)
3160      FORMAT(' ')
        ELSE
          NPLOTR=0
        END IF
        IVAL=IVAL+1
        NUM_IPLTPLN=IVAL
        VALUES_SOUGHT(IVAL)='PLOT PLANAR REGION IZ'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=0
        VALUE_MAX(IVAL)=NZ
        DEFAULT(IVAL)=NZ
        NVALUE(IVAL)=0
        NMIN = NUM_IPLTPLN
        NMAX = NUM_IPLTPLN
        CALL GET_INPUT
        NPLOTZ=NVALUE(NUM_IPLTPLN)
        IF ((VALUE(NUM_IPLTPLN,1) .GT. 0)) THEN
          DO 3171 J=1,NPLOTZ
            IPLOTZ(J)=VALUE(NUM_IPLTPLN,J)
            IF ((IPLOTZ(J).LT.NZDMIN.OR.IPLOTZ(J).GE.NZDMAX)) THEN
              WRITE(6,3180)IPLOTZ(J)
3180          FORMAT(' *************************************************
     ******'/ ' ** WARNING: DOSE IS NOT SCORED IN PLANAR REGION ',I3,' *
     **'/ ' **          DOSE WILL NOT BE PLOTTED IN THIS REGION **'/ ' *
     ******************************************************'/)
              IPLOTZ(J)=0
            ELSE
              WRITE(6,3190)IPLOTZ(J)
3190          FORMAT('PLOTTING PLANAR ZONE ', I3)
              IPLOTZ(J)=IPLOTZ(J)-NZDMIN+1
            END IF
3171      CONTINUE
3172      CONTINUE
          WRITE(6,3200)
3200      FORMAT(' ')
        ELSE
          NPLOTZ=0
        END IF
      END IF
      RETURN
      ENTRY PLOTEN
      TDSMAX=0.0
      DO 3211 IZD=1,NZDOSE
        DO 3221 IXD=1,NRDOSE
          IF ((TDSMAX.LT.SCDOSE(IZD,IXD,1))) THEN
            TDSMAX=SCDOSE(IZD,IXD,1)
          END IF
3221    CONTINUE
3222    CONTINUE
3211  CONTINUE
3212  CONTINUE
      IF ((IPLTLP.EQ.1)) THEN
        IF ((NPLOTR.NE.0)) THEN
          write(iout,100) title
          call egs_fdate(iout)
          write(iout,106) tdsmax
          IF ((TDSMAX.EQ.0.0)) THEN
            WRITE(IOUT,130)
            RETURN
          END IF
          NPPAGE=(66-3-2)/(4+NZDOSE)
          IX=1
          ICOUNT=0
          DO 3231 IXR=1,NPLOTR
            IX=IPLOTR(IXR)
            IF ((IX.GT.0)) THEN
              IF ((ICOUNT.GE.NPPAGE)) THEN
                ICOUNT=0
                write(iout,100)
                call egs_fdate(iout)
                write(iout,106) tdsmax
              END IF
              ICOUNT=ICOUNT+1
              IF (((ISOURC.EQ.2).OR.(ISOURC.EQ.4))) THEN
                WRITE(IOUT,110) RCYL(IX+NRDMIN)
              ELSE
                WRITE(IOUT,102)IX+NRDMIN,RCYL(IX+NRDMIN)
              END IF
              DO 3241 IZ=1,NZDOSE
                ICOL1=IDINT(SCDOSE(IZ,IX,1)/TDSMAX*120.+.999)
                ICOL2=IDINT(SCDOSE(IZ,IX,2)/TDSMAX*120.+.999)
                IF ((MOD(IZ,5).NE.0)) THEN
                  WRITE(FMT120(72:81),'(I10)')ICOL2+10
                  WRITE(FMT120(88:97),'(I10)')ICOL1+10
                  FMT=CMPRES(FMT120)
                  WRITE(IOUT,FMT)ZPLANE(IZ+NZDMIN)
                ELSE
                  WRITE(FMT121(72:81),'(I10)')ICOL2+10
                  WRITE(FMT121(88:97),'(I10)')ICOL1+10
                  FMT=CMPRES(FMT121)
                  WRITE(IOUT,FMT)ZPLANE(IZ+NZDMIN)
                END IF
3241          CONTINUE
3242          CONTINUE
            END IF
3231      CONTINUE
3232      CONTINUE
        END IF
        IF ((NPLOTZ.NE.0)) THEN
          write(iout,100)
          call egs_fdate(iout)
          write(iout,106) tdsmax
          NPPAGE=(66-3-2)/(4+NRDOSE)
          IZ=1
          ICOUNT=0
          DO 3251 IZZ=1,NPLOTZ
            IZ=IPLOTZ(IZZ)
            IF ((IZ.GT.0)) THEN
              IF ((ICOUNT.GE.NPPAGE)) THEN
                ICOUNT=0
                write(iout,100)
                call egs_fdate(iout)
                write(iout,106) tdsmax
              END IF
              ICOUNT=ICOUNT+1
              WRITE(IOUT,103)IZ+NZDMIN-1,ZPLANE(IZ+NZDMIN-1),ZPLANE(IZ+N
     *        ZDMIN)
              DO 3261 IX=1,NRDOSE
                ICOL1=IDINT(SCDOSE(IZ,IX,1)/TDSMAX*120.+.999)
                ICOL2=IDINT(SCDOSE(IZ,IX,2)/TDSMAX*120.+.999)
                IF ((MOD(IX,5).NE.0)) THEN
                  WRITE(FMT120(72:81),'(I10)')ICOL2+10
                  WRITE(FMT120(88:97),'(I10)')ICOL1+10
                  FMT=CMPRES(FMT120)
                  WRITE(IOUT,FMT)RCYL(IX+NRDMIN)
                ELSE
                  WRITE(FMT121(72:81),'(I10)')ICOL2+10
                  WRITE(FMT121(88:97),'(I10)')ICOL1+10
                  FMT=CMPRES(FMT121)
                  WRITE(IOUT,FMT)RCYL(IX+NRDMIN)
                END IF
3261          CONTINUE
3262          CONTINUE
            END IF
3251      CONTINUE
3252      CONTINUE
        END IF
      END IF
      IF ((IPLTPL.EQ.1)) THEN
        DO 3271 I=1,80
          GRAPHTITLE(I:I)=TITLE(I)
3271    CONTINUE
3272    CONTINUE
        J=0
        CURVENUM=0
        IF ((NPLOTR .GT. 0)) THEN
          IPLTUNX = egs_open_file(23,0,1,'_dd.plotdat')
          DO 3281 IXR=1,NPLOTR
            IX=IPLOTR(IXR)
            IF ((IX.GT.0)) THEN
              IF (((IPLPHB.EQ.1).OR.(IPLPHB.EQ.3))) THEN
                DO 3291 IZ=1,NZDOSE
                  XCOORD(IZ) = (ZPLANE(IZ+NZDMIN-1)+ZPLANE(IZ+NZDMIN))/2
     *            .
                  YCOORD(IZ) = SCDOSE(IZ,IX,1)
                  UNCERT(IZ) = SCDOSE2(IZ,IX,1)*SCDOSE(IZ,IX,1)/100.
3291            CONTINUE
3292            CONTINUE
                IX2CHAR=IX+NRDMIN
                NEGVAL=.FALSE.
                IF ((IX2CHAR .LT. 0)) THEN
                  NEGVAL=.TRUE.
                  IX2CHAR = ABS(IX2CHAR)
                END IF
                IF (((IX2CHAR .EQ. MOD(IX2CHAR,1000)))) THEN
                  CHECK=1
                  IF ((IX2CHAR .EQ. MOD(IX2CHAR,10))) THEN
                    IF ((NEGVAL)) THEN
                      CH_IX='-'//CHAR(IX2CHAR+48)
                    ELSE
                      CH_IX=CHAR(IX2CHAR+48)
                    END IF
                    CHECK=0
                  END IF
                  IF (((CHECK.NE.0).AND.(IX2CHAR .EQ. MOD(IX2CHAR,100)))
     *            ) THEN
                    a(1)=CHAR((IX2CHAR/10)+48)
                    int=(MOD(IX2CHAR,10)+48)
                    a(2)=CHAR(int)
                    IF ((NEGVAL)) THEN
                      CH_IX='-'//a(1)//a(2)
                    ELSE
                      CH_IX=a(1)//a(2)
                    END IF
                    CHECK=0
                  END IF
                  IF ((CHECK.NE.0)) THEN
                    a(1)=CHAR((IX2CHAR/100)+48)
                    int=(MOD(IX2CHAR,100)/10+48)
                    a(2)=CHAR(int)
                    int=MOD(IX2CHAR,10)+48
                    a(3)=CHAR(int)
                    IF ((NEGVAL)) THEN
                      CH_IX='-'//a(1)//a(2)//a(3)
                    ELSE
                      CH_IX=a(1)//a(2)//a(3)
                    END IF
                  END IF
                ELSE
                  CH_IX='3max'
                END IF
                NPTS=NZDOSE
                SERIESTITLE='dose at r # ' // CH_IX
                XTITLE='depth/cm'
                IF ((ISOURC.EQ.3.OR.ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOU
     *          RC.EQ.23)) THEN
                  YTITLE='dose per incident particle/Gy'
                ELSE
                  YTITLE='dose per incident fluence/Gy cm\\S2\\N'
                END IF
                call egs_get_fdate(SUBTITLE)
                SUBTITLE='dose vs. depth on '//SUBTITLE(1:24)
                UNITNUM=IPLTUNX
                PLTYPE=0
                HISTXMIN=ZPLANE(1)
                IAXISTYPE=0
                CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM, S
     *          ERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UNITNU
     *          M, PLTYPE, HISTXMIN, IAXISTYPE)
                CURVENUM=CURVENUM+1
                IF ((IKERMA .EQ. 1)) THEN
                  DO 3301 IZ=1,NZDOSE
                    XCOORD(IZ)=(ZPLANE(IZ+NZDMIN-1)+ZPLANE(IZ+NZDMIN))/2
     *              .
                    YCOORD(IZ)=SCKERMA(IZ,IX,1)
                    UNCERT(IZ)=SCKERMA2(IZ,IX,1)*SCKERMA(IZ,IX,1)/100.
3301              CONTINUE
3302              CONTINUE
                  NPTS=NZDOSE
                  SERIESTITLE='kerma at r # ' // CH_IX
                  CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM,
     *             SERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UN
     *            ITNUM, PLTYPE, HISTXMIN, IAXISTYPE)
                  CURVENUM=CURVENUM+1
                  DO 3311 IZ=1,NZDOSE
                    XCOORD(IZ)=(ZPLANE(IZ+NZDMIN-1)+ZPLANE(IZ+NZDMIN))/2
     *              .
                    IF ((SCKERMA(IZ,IX,1).NE.0.0)) THEN
                      YCOORD(IZ)=SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1)
                      UNCERT(IZ)=SCDOSEtoKERMA2(IZ,IX,1)* (SCDOSE(IZ,IX,
     *                1)/SCKERMA(IZ,IX,1))/100.
                    ELSE
                      YCOORD(IZ)=0.
                      UNCERT(IZ)=0.
                    END IF
3311              CONTINUE
3312              CONTINUE
                  NPTS=NZDOSE
                  SERIESTITLE='dose/kerma at r # ' // CH_IX
                  CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM,
     *             SERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UN
     *            ITNUM, PLTYPE, HISTXMIN, IAXISTYPE)
                  CURVENUM=CURVENUM+1
                END IF
              END IF
              IF (((IPLPHB.EQ.2).OR.(IPLPHB.EQ.3))) THEN
                DO 3321 IZ=1,NZDOSE
                  XCOORD(IZ) = ZPLANE(IZ+NZDMIN)
                  YCOORD(IZ) = SCDOSE(IZ,IX,1)
                  UNCERT(IZ) = SCDOSE2(IZ,IX,1)*SCDOSE(IZ,IX,1)/100.
3321            CONTINUE
3322            CONTINUE
                IX2CHAR=IX+NRDMIN
                NEGVAL=.FALSE.
                IF ((IX2CHAR .LT. 0)) THEN
                  NEGVAL=.TRUE.
                  IX2CHAR = ABS(IX2CHAR)
                END IF
                IF (((IX2CHAR .EQ. MOD(IX2CHAR,1000)))) THEN
                  CHECK=1
                  IF ((IX2CHAR .EQ. MOD(IX2CHAR,10))) THEN
                    IF ((NEGVAL)) THEN
                      CH_IX='-'//CHAR(IX2CHAR+48)
                    ELSE
                      CH_IX=CHAR(IX2CHAR+48)
                    END IF
                    CHECK=0
                  END IF
                  IF (((CHECK.NE.0).AND.(IX2CHAR .EQ. MOD(IX2CHAR,100)))
     *            ) THEN
                    a(1)=CHAR((IX2CHAR/10)+48)
                    int=(MOD(IX2CHAR,10)+48)
                    a(2)=CHAR(int)
                    IF ((NEGVAL)) THEN
                      CH_IX='-'//a(1)//a(2)
                    ELSE
                      CH_IX=a(1)//a(2)
                    END IF
                    CHECK=0
                  END IF
                  IF ((CHECK.NE.0)) THEN
                    a(1)=CHAR((IX2CHAR/100)+48)
                    int=(MOD(IX2CHAR,100)/10+48)
                    a(2)=CHAR(int)
                    int=MOD(IX2CHAR,10)+48
                    a(3)=CHAR(int)
                    IF ((NEGVAL)) THEN
                      CH_IX='-'//a(1)//a(2)//a(3)
                    ELSE
                      CH_IX=a(1)//a(2)//a(3)
                    END IF
                  END IF
                ELSE
                  CH_IX='3max'
                END IF
                NPTS=NZDOSE
                SERIESTITLE='dose at r # ' // CH_IX
                XTITLE='depth/cm'
                IF ((ISOURC.EQ.3.OR.ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOU
     *          RC.EQ.23)) THEN
                  YTITLE='dose per incident particle/Gy'
                ELSE
                  YTITLE='dose per incident fluence/Gy cm\\S2\\N'
                END IF
                call egs_get_fdate(SUBTITLE)
                SUBTITLE='dose vs. depth on '//SUBTITLE(1:24)
                UNITNUM=IPLTUNX
                PLTYPE=1
                HISTXMIN=ZPLANE(1)
                IAXISTYPE=0
                CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM, S
     *          ERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UNITNU
     *          M, PLTYPE, HISTXMIN, IAXISTYPE)
                CURVENUM=CURVENUM+1
                IF ((IKERMA .EQ. 1)) THEN
                  DO 3331 IZ=1,NZDOSE
                    XCOORD(IZ)=ZPLANE(IZ+NZDMIN)
                    YCOORD(IZ)=SCKERMA(IZ,IX,1)
                    UNCERT(IZ)=SCKERMA2(IZ,IX,1)*SCKERMA(IZ,IX,1)/100.
3331              CONTINUE
3332              CONTINUE
                  NPTS=NZDOSE
                  SERIESTITLE='kerma at r # ' // CH_IX
                  CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM,
     *             SERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UN
     *            ITNUM, PLTYPE, HISTXMIN, IAXISTYPE)
                  CURVENUM=CURVENUM+1
                  DO 3341 IZ=1,NZDOSE
                    XCOORD(IZ)=ZPLANE(IZ+NZDMIN)
                    IF ((SCKERMA(IZ,IX,1).NE.0.)) THEN
                      YCOORD(IZ)=SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1)
                      UNCERT(IZ)=SCDOSEtoKERMA2(IZ,IX,1)* (SCDOSE(IZ,IX,
     *                1)/SCKERMA(IZ,IX,1))/100.
                    ELSE
                      YCOORD(IZ)=0.
                      UNCERT(IZ)=0.
                    END IF
3341              CONTINUE
3342              CONTINUE
                  NPTS=NZDOSE
                  SERIESTITLE='dose/kerma at r # ' // CH_IX
                  CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM,
     *             SERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UN
     *            ITNUM, PLTYPE, HISTXMIN, IAXISTYPE)
                  CURVENUM=CURVENUM+1
                END IF
              END IF
            END IF
3281      CONTINUE
3282      CONTINUE
          close(23)
        END IF
        CURVENUM=0
        IF ((NPLOTZ .GT. 0)) THEN
          IPLTUNX = egs_open_file(23,0,1,'_rad.plotdat')
          DO 3351 IZZ=1,NPLOTZ
            IZ=IPLOTZ(IZZ)
            IF ((IZ.GT.0)) THEN
              IF (((IPLPHB.EQ.1).OR.(IPLPHB.EQ.3))) THEN
                DO 3361 IX=1,NRDOSE
                  XCOORD(IX) = (RCYL(IX+NRDMIN-1)+RCYL(IX+NRDMIN))/2.
                  YCOORD(IX) = SCDOSE(IZ,IX,1)
                  UNCERT(IX) = SCDOSE2(IZ,IX,1)*SCDOSE(IZ,IX,1)/100.
3361            CONTINUE
3362            CONTINUE
                IZ2CHAR=IZ+NZDMIN-1
                NEGVAL=.FALSE.
                IF ((IZ2CHAR .LT. 0)) THEN
                  NEGVAL=.TRUE.
                  IZ2CHAR = ABS(IZ2CHAR)
                END IF
                IF (((IZ2CHAR .EQ. MOD(IZ2CHAR,1000)))) THEN
                  CHECK=1
                  IF ((IZ2CHAR .EQ. MOD(IZ2CHAR,10))) THEN
                    IF ((NEGVAL)) THEN
                      CH_IZ='-'//CHAR(IZ2CHAR+48)
                    ELSE
                      CH_IZ=CHAR(IZ2CHAR+48)
                    END IF
                    CHECK=0
                  END IF
                  IF (((CHECK.NE.0).AND.(IZ2CHAR .EQ. MOD(IZ2CHAR,100)))
     *            ) THEN
                    a(1)=CHAR((IZ2CHAR/10)+48)
                    int=(MOD(IZ2CHAR,10)+48)
                    a(2)=CHAR(int)
                    IF ((NEGVAL)) THEN
                      CH_IZ='-'//a(1)//a(2)
                    ELSE
                      CH_IZ=a(1)//a(2)
                    END IF
                    CHECK=0
                  END IF
                  IF ((CHECK.NE.0)) THEN
                    a(1)=CHAR((IZ2CHAR/100)+48)
                    int=(MOD(IZ2CHAR,100)/10+48)
                    a(2)=CHAR(int)
                    int=MOD(IZ2CHAR,10)+48
                    a(3)=CHAR(int)
                    IF ((NEGVAL)) THEN
                      CH_IZ='-'//a(1)//a(2)//a(3)
                    ELSE
                      CH_IZ=a(1)//a(2)//a(3)
                    END IF
                  END IF
                ELSE
                  CH_IZ='3max'
                END IF
                NPTS=NRDOSE
                SERIESTITLE='dose at z # ' // CH_IZ
                XTITLE='radius/cm'
                IF ((ISOURC.EQ.3.OR.ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOU
     *          RC.EQ.23)) THEN
                  YTITLE='dose per incident particle/Gy'
                ELSE
                  YTITLE='dose per incident fluence/Gy cm\\S2\\N'
                END IF
                call egs_get_fdate(SUBTITLE)
                SUBTITLE='dose vs. radius on '//SUBTITLE(1:24)
                UNITNUM=IPLTUNX
                PLTYPE=0
                HISTXMIN=RCYL(NRDMIN)
                IAXISTYPE=0
                CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM, S
     *          ERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UNITNU
     *          M, PLTYPE, HISTXMIN, IAXISTYPE)
                CURVENUM=CURVENUM+1
                IF ((IKERMA .EQ. 1)) THEN
                  DO 3371 IX=1,NRDOSE
                    XCOORD(IX)=(RCYL(IX+NRDMIN-1)+RCYL(IX+NRDMIN))/2.
                    YCOORD(IX)=SCKERMA(IZ,IX,1)
                    UNCERT(IX)=SCKERMA2(IZ,IX,1)*SCKERMA(IZ,IX,1)/100.
3371              CONTINUE
3372              CONTINUE
                  SERIESTITLE='kerma at z # ' // CH_IZ
                  CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM,
     *             SERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UN
     *            ITNUM, PLTYPE, HISTXMIN, IAXISTYPE)
                  CURVENUM=CURVENUM+1
                  DO 3381 IX=1,NRDOSE
                    IF ((SCKERMA(IZ,IX,1).NE.0.)) THEN
                      YCOORD(IX)=SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1)
                      UNCERT(IX)=SCDOSEtoKERMA2(IZ,IX,1)* (SCDOSE(IZ,IX,
     *                1)/SCKERMA(IZ,IX,1))/100.
                    ELSE
                      YCOORD(IX)=0.
                      UNCERT(IX)=0.
                    END IF
3381              CONTINUE
3382              CONTINUE
                  SERIESTITLE='dose/kerma at z # ' // CH_IZ
                  CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM,
     *             SERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UN
     *            ITNUM, PLTYPE, HISTXMIN, IAXISTYPE)
                  CURVENUM=CURVENUM+1
                END IF
              END IF
              IF (((IPLPHB.EQ.2).OR.(IPLPHB.EQ.3))) THEN
                DO 3391 IX=1,NRDOSE
                  XCOORD(IX) = RCYL(NRDMIN+IX)
                  YCOORD(IX) = SCDOSE(IZ,IX,1)
                  UNCERT(IX) = SCDOSE2(IZ,IX,1)*SCDOSE(IZ,IX,1)/100.
3391            CONTINUE
3392            CONTINUE
                IZ2CHAR=IZ+NZDMIN-1
                NEGVAL=.FALSE.
                IF ((IZ2CHAR .LT. 0)) THEN
                  NEGVAL=.TRUE.
                  IZ2CHAR = ABS(IZ2CHAR)
                END IF
                IF (((IZ2CHAR .EQ. MOD(IZ2CHAR,1000)))) THEN
                  CHECK=1
                  IF ((IZ2CHAR .EQ. MOD(IZ2CHAR,10))) THEN
                    IF ((NEGVAL)) THEN
                      CH_IZ='-'//CHAR(IZ2CHAR+48)
                    ELSE
                      CH_IZ=CHAR(IZ2CHAR+48)
                    END IF
                    CHECK=0
                  END IF
                  IF (((CHECK.NE.0).AND.(IZ2CHAR .EQ. MOD(IZ2CHAR,100)))
     *            ) THEN
                    a(1)=CHAR((IZ2CHAR/10)+48)
                    int=(MOD(IZ2CHAR,10)+48)
                    a(2)=CHAR(int)
                    IF ((NEGVAL)) THEN
                      CH_IZ='-'//a(1)//a(2)
                    ELSE
                      CH_IZ=a(1)//a(2)
                    END IF
                    CHECK=0
                  END IF
                  IF ((CHECK.NE.0)) THEN
                    a(1)=CHAR((IZ2CHAR/100)+48)
                    int=(MOD(IZ2CHAR,100)/10+48)
                    a(2)=CHAR(int)
                    int=MOD(IZ2CHAR,10)+48
                    a(3)=CHAR(int)
                    IF ((NEGVAL)) THEN
                      CH_IZ='-'//a(1)//a(2)//a(3)
                    ELSE
                      CH_IZ=a(1)//a(2)//a(3)
                    END IF
                  END IF
                ELSE
                  CH_IZ='3max'
                END IF
                NPTS=NRDOSE
                SERIESTITLE='dose at z # ' // CH_IZ
                XTITLE='radius/cm'
                IF ((ISOURC.EQ.3.OR.ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOU
     *          RC.EQ.23)) THEN
                  YTITLE='dose per incident particle/Gy'
                ELSE
                  YTITLE='dose per incident fluence/Gy cm\\S2\\N'
                END IF
                call egs_get_fdate(SUBTITLE)
                SUBTITLE='dose vs radius on '//SUBTITLE(1:24)
                UNITNUM=IPLTUNX
                PLTYPE=1
                HISTXMIN=RCYL(NRDMIN)
                IAXISTYPE=0
                CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM, S
     *          ERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UNITNU
     *          M, PLTYPE, HISTXMIN, IAXISTYPE)
                CURVENUM=CURVENUM+1
                IF ((IKERMA .EQ. 1)) THEN
                  DO 3401 IX=1,NRDOSE
                    XCOORD(IX) = RCYL(NRDMIN+IX)
                    YCOORD(IX)=SCKERMA(IZ,IX,1)
                    UNCERT(IX)=SCKERMA2(IZ,IX,1)*SCKERMA(IZ,IX,1)/100.
3401              CONTINUE
3402              CONTINUE
                  SERIESTITLE='kerma at z # ' // CH_IZ
                  CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM,
     *             SERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UN
     *            ITNUM, PLTYPE, HISTXMIN, IAXISTYPE)
                  CURVENUM=CURVENUM+1
                  DO 3411 IX=1,NRDOSE
                    IF ((SCKERMA(IZ,IX,1).NE.0.)) THEN
                      YCOORD(IX)=SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1)
                      UNCERT(IX)=SCDOSEtoKERMA2(IZ,IX,1)* (SCDOSE(IZ,IX,
     *                1)/SCKERMA(IZ,IX,1))/100.
                    ELSE
                      YCOORD(IX)=0.
                      UNCERT(IX)=0.
                    END IF
3411              CONTINUE
3412              CONTINUE
                  SERIESTITLE='dose/kerma at z # ' // CH_IZ
                  CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM,
     *             SERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UN
     *            ITNUM, PLTYPE, HISTXMIN, IAXISTYPE)
                  CURVENUM=CURVENUM+1
                END IF
              END IF
            END IF
3351      CONTINUE
3352      CONTINUE
          close(23)
        END IF
      END IF
      RETURN
100   FORMAT(' ',80A1/ /' NRC CALCULATION USING DOSRZnrc ',' ',' ',40X,$
     *)
106   FORMAT(///' ',T60,'SCALED TO A MAX OF',1PE11.4,' Gy.cm**2')
102   FORMAT(' '/// ' ',11X,' DEPTH/DOSE PLOT FOR RADIAL DOSE ZONE #',I2
     *,' TO RADIUS',F10.3)
103   FORMAT(' '/// ' ',11X,' RADIUS/DOSE PLOT FOR PLANAR DOSE REGION #'
     *,I2, ' FROM',F10.3,' TO',F10.3,' cm')
110   FORMAT(//// ' ',14X,'CENTRAL AXIS DEPTH-DOSE FOR BEAM RADIUS',F12.
     *3,' cm')
130   FORMAT(' MAXIMUM DOSE = 0.000, NO PLOTTING WILL BE DONE')
      END
      subroutine hownear(tperp,x,y,z,ir)
      implicit none
      CHARACTER*4 CDSTBL( 12001),CTRTBL( 12001),CABSRB( 12001)
      COMMON/GEOM/ZPLANE( 201),RCYL(0:60), CYRAD2( 61), NZ,NR,NREG,NDOSE
     *,NZDOSE,NRDOSE,NPLANE, NZDMIN,NZDMAX,NRDMIN,NRDMAX, NTRACK( 12001)
     *,CDSTBL,CTRTBL,CABSRB,IDSTBL( 12001,2)
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,NZDMIN,NZDMAX,NRDM
     *IN,NRDMAX, NTRACK,IDSTBL
      real*8 tperp,  x,  y,  z
      integer*4 ir
      real*8 r
      integer*4 ix,  iz
      r = sqrt(x**2 + y**2)
      ix = (ir - 2)/nz + 1
      iz = ir - 1 - nz*(ix - 1)
      tperp = min(z - zplane(iz),zplane(iz + 1) - z,rcyl(ix) - r)
      IF ((ix .NE. 1)) THEN
        tperp = min(tperp,r - rcyl(ix - 1))
      END IF
      return
      end
      subroutine combine_results(file_name)
      implicit none
      character*(*) file_name
      COMMON/SCORE/ SCDOSE(200,60,7),SCDOSE2(200,60,7), SCKERMA(200,60,7
     *),SCKERMA2(200,60,7), SCDOSEtoKERMA2(200,60,7),SCPDST(500),SCPDST2
     *(500), SCPCUM(500),SCPCUM2(500),SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCD
     *FBK(4),SCDFBK2(4),SCDFEP(4),SCDFEP2(4),SCDFDIFF(4),SCDFDIFF2(4), S
     *CSTP,SCSTP2,SCDSTP,SCDSTP2, PIISTP, SCSTP_LAST, SCDSTP_LAST,SCDOSE
     *_LAST(200,60,7), SCKERMA_LAST(200,60,7), SCKERMA_LASTOLD(200,60,7)
     *,SCPDST_LAST, IHSTRY, DFEN(4,4), PHENER,WT1OLD,BINTOP(500),SLOTE,D
     *ELTAE, SCDOSE_TMP(200,60,7), SCKERMA_TMP(200,60,7), SCKERMA_TMPOLD
     *(200,60,7), SCSTP_TMP,SCDSTP_TMP, MXNP,IFULL,ISTORE,IKERMA, IWATCH
     *,IOOPTN,IOUTSP, IPHR( 12001),MAXBIN,NCOMPT,during_pe_compt,during_
     *eii
      real*8 SCDOSE,SCDOSE2,SCKERMA,SCKERMA2,SCDOSEtoKERMA2,SCPDST,SCPDS
     *T2, SCPCUM,SCPCUM2,SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCDFBK,SCDFBK2,S
     *CDFEP,SCDFEP2,SCDFDIFF,SCDFDIFF2, SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIIS
     *TP
      integer*8 SCSTP_LAST, SCDSTP_LAST, SCDOSE_LAST, SCKERMA_LAST, SCKE
     *RMA_LASTOLD,SCPDST_LAST, IHSTRY
      real*8 DFEN, PHENER,WT1OLD,BINTOP,SLOTE,DELTAE, SCDOSE_TMP,SCKERMA
     *_TMP,SCKERMA_TMPOLD,SCSTP_TMP,SCDSTP_TMP
      integer*4 MXNP,IFULL,ISTORE,IKERMA, IWATCH,IOOPTN,IOUTSP, IPHR,MAX
     *BIN,NCOMPT,during_pe_compt,during_eii
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(200,60),TMCPUO,TIMMAX,ST
     *ATLM,EIN,EKMAX, IDAT,IRESTART,IQIN,NESTEP,NSMAX,IXXIN,JXXIN,IVAL,D
     *ATCOUNT
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN,EKMAX
      integer*4 IDAT,IRESTART,IQIN,NESTEP,NSMAX, IXXIN,JXXIN,IVAL,DATCOU
     *NT
      integer*8 NCASE,NCASEO,NCASET
      CHARACTER*4 CDSTBL( 12001),CTRTBL( 12001),CABSRB( 12001)
      COMMON/GEOM/ZPLANE( 201),RCYL(0:60), CYRAD2( 61), NZ,NR,NREG,NDOSE
     *,NZDOSE,NRDOSE,NPLANE, NZDMIN,NZDMAX,NRDMIN,NRDMAX, NTRACK( 12001)
     *,CDSTBL,CTRTBL,CABSRB,IDSTBL( 12001,2)
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,NZDMIN,NZDMAX,NRDM
     *IN,NRDMAX, NTRACK,IDSTBL
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(100,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBE
     *AM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,
     *DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,P
     *ROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,
     *ZSOFST,                                                      SVTMP
     *1,SVTMP2,SVTMP3,SVTMP4,
     *         RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                       XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,W
     *EIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      integer*4 egs_get_unit,lnblnk1
      integer*4 ix,iz,it,ib,iorstrt,ipk,iout,itmax
      REAL*8 TEMPSCSTP, TEMPSCSTP2, TEMPSCDSTP, TEMPSCDSTP2, TEMPSCR8(20
     *0,60,7),TEMPSCPDST(500), TEMPSCPDST2(500),TEMPSCPCUM(500),TEMPSCPC
     *UM2(500), TEMPSCOMEG, TEMPSCOMEG2, TEMPSCPK(4), TEMPSCPK2(4), TEMP
     *PIISTP
      real*8 TEMPNCASE,TEMPTMCPU
      integer*8 TEMPNNREAD
      logical first_time
      data first_time/.true./
      save first_time
      iout = 1
      IF (((IFULL.EQ.0).OR.(IFULL.EQ.2).OR.(IFULL.EQ.3))) THEN
        ITMAX=2
      ELSE
        ITMAX=7
      END IF
      IF (( first_time )) THEN
        first_time = .false.
        WRITE(6,3420)
3420    FORMAT(/1X,'Summing the following .egsdat files')
        WRITE(6,3430)
3430    FORMAT(1X,'------------------------------------'/)
        WRITE(IOUT,'(/1X,''Summing .egsdat files'')')
        WRITE(IOUT,'(1X,''---------------------''/)')
        SCSTP=0
        SCSTP2=0
        PIISTP=0
        SCDSTP=0
        SCDSTP2=0
        TMCPUO=0
        NCASEO=0
        NNREAD=0
        SCOMEG=0
        SCOMEG2=0
        DO 3441 iz=1,nzdose
          DO 3451 ix=1,nrdose
            DO 3461 it=1,itmax
              SCDOSE(IZ,IX,IT)=0
              SCDOSE2(IZ,IX,IT)=0
              SCKERMA(IZ,IX,IT)=0
              SCKERMA2(IZ,IX,IT)=0
              SCDOSEtoKERMA2(IZ,IX,IT)=0
3461        CONTINUE
3462        CONTINUE
3451      CONTINUE
3452      CONTINUE
3441    CONTINUE
3442    CONTINUE
        DO 3471 ib=1,MAXBIN
          SCPDST(IB)=0
          SCPDST2(IB)=0
3471    CONTINUE
3472    CONTINUE
        DO 3481 ipk=1,4
          SCDFEP(IPK)=0
          SCDFEP2(IPK)=0
          SCDFBK(IPK)=0
          SCDFBK2(IPK)=0
          SCDFDIFF(IPK)=0
          SCDFDIFF2(IPK)=0
3481    CONTINUE
3482    CONTINUE
        DATCOUNT=0
      END IF
      IORSTRT = egs_get_unit(4)
      WRITE(IOUT,'(A)') file_name(:lnblnk1(file_name))
      WRITE(6,'(A)') file_name(:lnblnk1(file_name))
      open(IORSTRT,file=file_name,status='old',err=3490)
      DATCOUNT=DATCOUNT+1
      READ(IORSTRT,*)TEMPSCSTP,TEMPSCSTP2,TEMPSCDSTP,TEMPSCDSTP2,TEMPPII
     *STP
      SCSTP=SCSTP+TEMPSCSTP
      SCSTP2=SCSTP2+TEMPSCSTP2
      PIISTP=PIISTP+TEMPPIISTP
      SCDSTP=SCDSTP+TEMPSCDSTP
      SCDSTP2=SCDSTP2+TEMPSCDSTP2
      READ(IORSTRT,*) (((TEMPSCR8(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=
     *1,NZDOSE)
      DO 3501 IZ=1,NZDOSE
        DO 3511 IX=1,NRDOSE
          DO 3521 IT=1,ITMAX
            SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+TEMPSCR8(IZ,IX,IT)
3521      CONTINUE
3522      CONTINUE
3511    CONTINUE
3512    CONTINUE
3501  CONTINUE
3502  CONTINUE
      READ(IORSTRT,*) (((TEMPSCR8(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=
     *1,NZDOSE)
      DO 3531 IZ=1,NZDOSE
        DO 3541 IX=1,NRDOSE
          DO 3551 IT=1,ITMAX
            SCDOSE2(IZ,IX,IT)=SCDOSE2(IZ,IX,IT)+TEMPSCR8(IZ,IX,IT)
3551      CONTINUE
3552      CONTINUE
3541    CONTINUE
3542    CONTINUE
3531  CONTINUE
3532  CONTINUE
      IF ((IKERMA.EQ.1)) THEN
        READ(IORSTRT,*) (((TEMPSCR8(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),I
     *  Z=1,NZDOSE)
        DO 3561 IZ=1,NZDOSE
          DO 3571 IX=1,NRDOSE
            DO 3581 IT=1,ITMAX
              SCKERMA(IZ,IX,IT)=SCKERMA(IZ,IX,IT)+TEMPSCR8(IZ,IX,IT)
3581        CONTINUE
3582        CONTINUE
3571      CONTINUE
3572      CONTINUE
3561    CONTINUE
3562    CONTINUE
        READ(IORSTRT,*) (((TEMPSCR8(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),I
     *  Z=1,NZDOSE)
        DO 3591 IZ=1,NZDOSE
          DO 3601 IX=1,NRDOSE
            DO 3611 IT=1,ITMAX
              SCKERMA2(IZ,IX,IT)=SCKERMA2(IZ,IX,IT)+TEMPSCR8(IZ,IX,IT)
3611        CONTINUE
3612        CONTINUE
3601      CONTINUE
3602      CONTINUE
3591    CONTINUE
3592    CONTINUE
        READ(IORSTRT,*) (((TEMPSCR8(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),I
     *  Z=1,NZDOSE)
        DO 3621 IZ=1,NZDOSE
          DO 3631 IX=1,NRDOSE
            DO 3641 IT=1,ITMAX
              SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)+ TEMPSCR
     *        8(IZ,IX,IT)
3641        CONTINUE
3642        CONTINUE
3631      CONTINUE
3632      CONTINUE
3621    CONTINUE
3622    CONTINUE
      END IF
      IF ((IFULL.EQ.2)) THEN
        READ(IORSTRT,*)(TEMPSCPDST(IB),TEMPSCPDST2(IB),IB=1,MAXBIN)
        READ(IORSTRT,*)(TEMPSCPCUM(IB),TEMPSCPCUM2(IB),IB=1,MAXBIN)
        DO 3651 IB=1,MAXBIN
          SCPDST(IB)=SCPDST(IB)+TEMPSCPDST(IB)
          SCPDST2(IB)=SCPDST2(IB)+TEMPSCPDST2(IB)
          SCPCUM(IB)=SCPCUM(IB)+TEMPSCPCUM(IB)
          SCPCUM2(IB)=SCPCUM2(IB)+TEMPSCPCUM2(IB)
3651    CONTINUE
3652    CONTINUE
        READ(IORSTRT,*)(TEMPSCPK(IPK),TEMPSCPK2(IPK),IPK=1,4)
        DO 3661 IPK=1,4
          SCDFEP(IPK)=SCDFEP(IPK)+TEMPSCPK(IPK)
          SCDFEP2(IPK)=SCDFEP2(IPK)+TEMPSCPK2(IPK)
3661    CONTINUE
3662    CONTINUE
        READ(IORSTRT,*)(TEMPSCPK(IPK),TEMPSCPK2(IPK),IPK=1,4)
        DO 3671 IPK=1,4
          SCDFBK(IPK)=SCDFBK(IPK)+TEMPSCPK(IPK)
          SCDFBK2(IPK)=SCDFBK2(IPK)+TEMPSCPK2(IPK)
3671    CONTINUE
3672    CONTINUE
        READ(IORSTRT,*)(TEMPSCPK(IPK),TEMPSCPK2(IPK),IPK=1,4)
        DO 3681 IPK=1,4
          SCDFDIFF(IPK)=SCDFDIFF(IPK)+TEMPSCPK(IPK)
          SCDFDIFF2(IPK)=SCDFDIFF2(IPK)+TEMPSCPK2(IPK)
3681    CONTINUE
3682    CONTINUE
      END IF
      read(IORSTRT,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed, rn
     *g_array
      twom24 = 1./16777216.
      READ(IORSTRT,*) TEMPNCASE,TEMPTMCPU,TEMPNNREAD
      TMCPUO=TMCPUO+TEMPTMCPU
      NCASEO=NCASEO+TEMPNCASE
      NNREAD=NNREAD+TEMPNNREAD
      write(6,*) '  ncase = ',TEMPNCASE,' cpu = ',TEMPTMCPU,' total cpu
     *= ', TMCPUO
      write(iout,*) '  ncase = ',TEMPNCASE,' cpu = ',TEMPTMCPU,' total c
     *pu = ', TMCPUO
      READ(IORSTRT,*,END=3690) TEMPSCOMEG,TEMPSCOMEG2
      SCOMEG=SCOMEG+TEMPSCOMEG
      SCOMEG2=SCOMEG2+TEMPSCOMEG2
      goto 3700
3690  WRITE(6,3710)
3710  FORMAT('  Warning: Solid angle information not in data file')
      WRITE(6,3720)
3720  FORMAT('           This may cause errors in absolute normalization
     *s!')
3700  CLOSE(UNIT=IORSTRT)
      return
3490  CONTINUE
      WRITE(6,*) 'Error opening file', file_name(:lnblnk1(file_name))
      return
      end
      subroutine init_ranmar
      implicit none
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      integer*4 s,t
      integer*4 i,j,k,l,m,ii,jj
      IF((ixx .LE. 0 .OR. ixx .GT. 31328))ixx = 1802
      IF((jxx .LE. 0 .OR. jxx .GT. 30081))jxx = 9373
      i = mod(ixx/177,177) + 2
      j = mod(ixx, 177) + 2
      k = mod(jxx/169,178) + 1
      l = mod(jxx, 169)
      DO 3731 ii=1,97
        s = 0
        t = 8388608
        DO 3741 jj=1,24
          m = mod(mod(i*j,179)*k,179)
          IF (( fool_optimizer .EQ. 999 )) THEN
            write(6,*) i,j,k,m,s,t
          END IF
          i = j
          IF (( fool_optimizer .EQ. 999 )) THEN
            write(6,*) i,j,k,m,s,t
          END IF
          j = k
          IF (( fool_optimizer .EQ. 999 )) THEN
            write(6,*) i,j,k,m,s,t
          END IF
          k = m
          IF (( fool_optimizer .EQ. 999 )) THEN
            write(6,*) i,j,k,m,s,t
          END IF
          l = mod(53*l+1,169)
          IF (( fool_optimizer .EQ. 999 )) THEN
            write(6,*) i,j,k,m,s,t
          END IF
          IF((mod(l*m,64) .GE. 32))s = s + t
          IF (( fool_optimizer .EQ. 999 )) THEN
            write(6,*) i,j,k,m,s,t
          END IF
          t = t/2
          IF (( fool_optimizer .EQ. 999 )) THEN
            write(6,*) i,j,k,m,s,t
          END IF
3741    CONTINUE
3742    CONTINUE
        urndm(ii) = s
3731  CONTINUE
3732  CONTINUE
      crndm = 362436
      cdrndm = 7654321
      cmrndm = 16777213
      twom24 = 1./16777216.
      ixx = 97
      jxx = 33
      rng_seed = 128 + 1
      return
      end
      subroutine ranmar_get
      implicit none
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      integer*4 i,iopt
      IF((rng_seed .EQ. 999999))call init_ranmar
      DO 3751 i=1,128
        iopt = urndm(ixx) - urndm(jxx)
        IF((iopt .LT. 0))iopt = iopt + 16777216
        urndm(ixx) = iopt
        ixx = ixx - 1
        jxx = jxx - 1
        IF ((ixx .EQ. 0)) THEN
          ixx = 97
        ELSE IF(( jxx .EQ. 0 )) THEN
          jxx = 97
        END IF
        crndm = crndm - cdrndm
        IF((crndm .LT. 0))crndm = crndm + cmrndm
        iopt = iopt - crndm
        IF((iopt .LT. 0))iopt = iopt + 16777216
        rng_array(i) = iopt
3751  CONTINUE
3752  CONTINUE
      rng_seed = 1
      return
      end
      SUBROUTINE SRCRZ
      implicit none
      integer*4 LATCHM,NHSTRYM
      real*8 ZLASTM,EINM,WEIGHTM,XINM,YINM,UINM,VINM
      CHARACTER*5 LINE1
      integer*4 K,IB
      real*8 TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,TEMP6,TEMP7,TEMP8,TEMP9,FNORM
      character*80 filnam
      integer*4 ICORRL
      integer*8 TEMPDIV
      real*8 SCARG1,SCARG2,SCARG3,SCARG4
      integer*4 ICOUNT,IERROR
      real*8 RLAST
      real*8 WEIGHT
      integer*4 IBNSOK,I,IRDIST
      real*8 COTANG,FACTOR,GRIDSZ,AK
      integer*4 IRIN,NRCFLG
      real*8 XIN,YIN,ZIN,UIN,VIN,WIN
      integer*4 IX,IXIN,IZ,IZ1,LATCHI
      real*8 R2,D,PHI,WHICH,RNNO1,RNNO2,ZLAST
      integer*4 IZIN
      real*8 YTEMP,VTEMP,ZINC
      real*8 dist_phsp, theta_phsp, cost_phsp, sint_phsp, chamber_c, xof
     *fset, yoffset
      logical check
      integer*4 count_phsp
      real*8 tf,xtmp,ytmp,phbb,pha,phb,phd,radp
      integer*4 N_RUN_CHUNK
      character*80 the_beam_code, the_pegs_file, the_input_file
      integer*4 lnblnk1
      integer*8 tmp_mod
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      INTEGER NUM_IPART, NUM_SOURCE, NUM_SOPTS, NUM_MODEIN, NUM_RDFIL, N
     *UM_NRDIST, NUM_RDISTF, NUM_RPDF, NUM_RDIOUTSP, NUM_FILSPC, NUM_BEA
     *M_CODE, NUM_PEGS_FILE, NUM_IFILE, NUM_WW23, error_flag_save
      integer*4 MODEIN
      CHARACTER*4 CDSTBL( 12001),CTRTBL( 12001),CABSRB( 12001)
      COMMON/GEOM/ZPLANE( 201),RCYL(0:60), CYRAD2( 61), NZ,NR,NREG,NDOSE
     *,NZDOSE,NRDOSE,NPLANE, NZDMIN,NZDMAX,NRDMIN,NRDMAX, NTRACK( 12001)
     *,CDSTBL,CTRTBL,CABSRB,IDSTBL( 12001,2)
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,NZDMIN,NZDMAX,NRDM
     *IN,NRDMAX, NTRACK,IDSTBL
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(200,60),TMCPUO,TIMMAX,ST
     *ATLM,EIN,EKMAX, IDAT,IRESTART,IQIN,NESTEP,NSMAX,IXXIN,JXXIN,IVAL,D
     *ATCOUNT
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN,EKMAX
      integer*4 IDAT,IRESTART,IQIN,NESTEP,NSMAX, IXXIN,JXXIN,IVAL,DATCOU
     *NT
      integer*8 NCASE,NCASEO,NCASET
      COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE
      integer*4 ICHPIN,ILPIN,IOUT,IPAGE
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/SCORE/ SCDOSE(200,60,7),SCDOSE2(200,60,7), SCKERMA(200,60,7
     *),SCKERMA2(200,60,7), SCDOSEtoKERMA2(200,60,7),SCPDST(500),SCPDST2
     *(500), SCPCUM(500),SCPCUM2(500),SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCD
     *FBK(4),SCDFBK2(4),SCDFEP(4),SCDFEP2(4),SCDFDIFF(4),SCDFDIFF2(4), S
     *CSTP,SCSTP2,SCDSTP,SCDSTP2, PIISTP, SCSTP_LAST, SCDSTP_LAST,SCDOSE
     *_LAST(200,60,7), SCKERMA_LAST(200,60,7), SCKERMA_LASTOLD(200,60,7)
     *,SCPDST_LAST, IHSTRY, DFEN(4,4), PHENER,WT1OLD,BINTOP(500),SLOTE,D
     *ELTAE, SCDOSE_TMP(200,60,7), SCKERMA_TMP(200,60,7), SCKERMA_TMPOLD
     *(200,60,7), SCSTP_TMP,SCDSTP_TMP, MXNP,IFULL,ISTORE,IKERMA, IWATCH
     *,IOOPTN,IOUTSP, IPHR( 12001),MAXBIN,NCOMPT,during_pe_compt,during_
     *eii
      real*8 SCDOSE,SCDOSE2,SCKERMA,SCKERMA2,SCDOSEtoKERMA2,SCPDST,SCPDS
     *T2, SCPCUM,SCPCUM2,SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCDFBK,SCDFBK2,S
     *CDFEP,SCDFEP2,SCDFDIFF,SCDFDIFF2, SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIIS
     *TP
      integer*8 SCSTP_LAST, SCDSTP_LAST, SCDOSE_LAST, SCKERMA_LAST, SCKE
     *RMA_LASTOLD,SCPDST_LAST, IHSTRY
      real*8 DFEN, PHENER,WT1OLD,BINTOP,SLOTE,DELTAE, SCDOSE_TMP,SCKERMA
     *_TMP,SCKERMA_TMPOLD,SCSTP_TMP,SCDSTP_TMP
      integer*4 MXNP,IFULL,ISTORE,IKERMA, IWATCH,IOOPTN,IOUTSP, IPHR,MAX
     *BIN,NCOMPT,during_pe_compt,during_eii
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(100,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBE
     *AM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,
     *DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,P
     *ROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,
     *ZSOFST,                                                      SVTMP
     *1,SVTMP2,SVTMP3,SVTMP4,
     *         RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                       XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,W
     *EIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USERRR/ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN, MINZ,MAXZ,MINR,MAXR
     *,IREJCT
      real*8 ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN
      integer*4 MINZ,MAXZ,MINR,MAXR,IREJCT
      COMMON/USERMI/EXPMFP,GWTOLD,ICSDA
      integer*4 ICSDA
      real*8 EXPMFP,GWTOLD
      COMMON/USERVR/ CEXPTR,GWAIT,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,
     *IQINC,MONOEN, cs_enhance,cs_enhance_current,ienhance,iefl( 12001),
     *ics_enhance, do_fast_step
      integer*4 ienhance,iefl,ics_enhance, IFORCE,NFMIN,NFMAX,NFTIME,ISO
     *URC,IFPB,IQINC,MONOEN
      real*8 CEXPTR,GWAIT,cs_enhance,cs_enhance_current
      logical do_fast_step
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/RWPHSP/ STRING_TEMP_ZLAST_OUT,  STRING_TEMP_OUT,  IHSTRY_PH
     *SP,   iaea_dummy_long,  NHSTRY_DOS,   ESHORT,  WEIGHTTMP,  WT_PHSP
     *_SHORT,  X_PHSP_SHORT,  Y_PHSP_SHORT,  Z_PHSP_SHORT,  U_PHSP_SHORT
     *,  V_PHSP_SHORT,  W_PHSP_SHORT,  ZLAST_PHSP_SHORT,  MUIDX_PHSP_SHO
     *RT,  EKMAX_PHSP_SHORT,  EKMINE_PHSP_SHORT,  NINC_PHSP_SHORT,  dosx
     *yz2beam_index,  iaea_extra_floats,  NUM_PHSP_TOT,  PHOT_PHSP_TOT,
     *iaea_result,   iaea_n_stat,  iaea_q_typ,  iaea_typ_q,  iaea_q_inde
     *x,  I_PHSP,  IERR_PHSP,  LATCHTMP,  WRITE_PHSP_COUNTER,  WRITE_PHS
     *P_SOFAR,  PHSP_RESTART,  PHSP_RECL,  PHSP_RECL_OLD,  iaea_extra_in
     *ts,  iaea_extra_int_types,iaea_extra_float_types,   iaea_i_zlast,
     * iaea_i_latch,  iaea_i_muidx,  iaea_n_extra_ints,  iaea_n_extra_fl
     *oats,  i_iaea_open_for_write,   iaea_i_zlast_out,  iaea_i_latch_ou
     *t,  iaea_i_muidx_out,  dosxyz2beam_izscore,  MODE_RW
      CHARACTER*32000 STRING_TEMP_ZLAST_OUT(1)
      CHARACTER*28000 STRING_TEMP_OUT(1)
      integer*8 IHSTRY_PHSP(1),iaea_dummy_long,NHSTRY_DOS
      REAL*4 ESHORT,WEIGHTTMP,WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT, Z
     *_PHSP_SHORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,ZLAST_PHSP_SHO
     *RT, MUIDX_PHSP_SHORT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP
     *_SHORT,dosxyz2beam_index, iaea_extra_floats(10)
      INTEGER NUM_PHSP_TOT,PHOT_PHSP_TOT, iaea_result,iaea_n_stat,iaea_q
     *_typ(3),iaea_typ_q(3),iaea_q_index,I_PHSP, IERR_PHSP,LATCHTMP, WRI
     *TE_PHSP_COUNTER(1),WRITE_PHSP_SOFAR(1), PHSP_RESTART,PHSP_RECL,PHS
     *P_RECL_OLD,iaea_extra_ints(10), iaea_extra_int_types(10),iaea_extr
     *a_float_types(10),iaea_i_zlast, iaea_i_latch,iaea_i_muidx,iaea_n_e
     *xtra_ints,iaea_n_extra_floats, i_iaea_open_for_write,iaea_i_zlast_
     *out,iaea_i_latch_out, iaea_i_muidx_out,dosxyz2beam_izscore
      CHARACTER*5 MODE_RW
      INTEGER LATCH_TEMP_OUT,NUM_PHSP_TOFLUSH,TEMP_PHSP_COUNTER,REM_PHSP
      REAL*4 REAL_TEMP_OUT(7)
      CHARACTER*32 REC_TEMP_OUT
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*8 last_nhstry
      real*8 min_weight_23, max_weight_23, xin_tmp, yin_tmp, zin_tmp,Z_S
     *OURCE,MUIDX
      integer*4 secret_option_23,ilen,ismode,IMUPHSP,IZSCORE
      save TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,TEMP6,TEMP7,TEMP8,TEMP9,FNORM,I
     *BNSOK,MODEIN, dist_phsp, theta_phsp, cost_phsp, sint_phsp, chamber
     *_c,count_phsp, xoffset, yoffset, the_beam_code, the_pegs_file, the
     *_input_file, last_nhstry,min_weight_23, max_weight_23, secret_opti
     *on_23
      ENFLAG = 0
      WRITE(6,3760)
3760  FORMAT(/' *** Source inputs read by srcrz ***'/)
      WRITE(6,3770)
3770  FORMAT(' charge of the incident beam (-1,0,1 [& 2 with source 21])
     *,'/ ' source configuration'/ '      (0) parallel beam incident fro
     *m the front:(0),radius(cm)'/ '                      incident direc
     *tion cosines (U,V,W)'/ '   or (1) point source on axis incident fr
     *om the front(1)'/ '                      source to front face dist
     *ance,radius(cm)'/ '   or (2) broad parallel beam incident from the
     * front(2)'/ '                      no configuration input necessar
     *y,unit area beam'/ '   or (3) uniform isotropically radiating disk
     *(3)'/ '                      min,max radius, min,max Z'/ '   or (4
     *) axial fluence for various beam radii'/ '                      ra
     *dius of central axis region')
      WRITE(6,3780)
3780  FORMAT('   or (10) parallel beam incident from the side(10)'/ '   
     *                half-width,half-height of beam at center(cm)'/'   
     *or (11) point source incident from the side(11)'/ '           sour
     *ce to center distance(cm)'/ 'half-width,half-height of beam at cen
     *ter(cm)'/ '   or (12) point source incident from off axis(12)'/ ' 
     *                      perpendicular distance off central axis(cm)'
     */ '                       perpendicular distance from front face(c
     *m)'/ '   or (13) broad parallel beam incident from any angle:(13)'
     */ '                      incident direction cosines (U,V,W)'/ '   
     *or (14) point source on axisfrom front but restricted:(14),'/ '   
     *                   source to front face dist, outer,inner radius(c
     *m)'/ '   or (20) parallel beam incident from the front with radial
     * distribution'/ '   or (21)full phase-space on front: each particl
     *e read from unit 42'/ '                  file MODE (0. = default, 
     *2. with ZLAST as well),'/ '                      NRCYCL, IPARALLEL
     *, PARNUM'/ '   or (22)full phase-space from any angle: each partic
     *le read from unit 42'/'                      file MODE (0. = defau
     *lt, 2. with ZLAST aswell),'/ '                      distance from 
     *centre of source plane to point of'/ '                      rotati
     *on, angle of rotation about Z axis, Z offset'/ '                  
     *    of point of rotation, NRCYCL, IPARALLEL, PARNUM,'/ '          
     *            X offset of source, Y offset of source.'/ '   or (23) 
     *BEAM treatment headsimulation from any angle: name of BEAM'/ '    
     *                  simulation (eg BEAM_accelname), name of BEAM inp
     *ut'/ '         file (no .egsinp extension), name of BEAM pegs data
     *'/ '                    (no .pegs4dat extension), min. and max. we
     *ights of'/ '                      particles to use (defaults to -1
     *e30- 1e30),'/ '                      distance from centre of BEAM 
     *scoring plane to point of'/ '                      rotation, angle
     * of rotation about Z axis, Z offset'/ '                      of po
     *int of rotation, X offset of source, Y offset'/ '  of source.'//)
      DELIMETER='SOURCE INPUTS'
      IVAL = IVAL + 1
      NUM_IPART = IVAL
      VALUES_SOUGHT(IVAL)='INCIDENT PARTICLE'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      DEFAULT(IVAL)=0
      ALLOWED_INPUTS(IVAL,4)='ELECTRON'
      ALLOWED_INPUTS(IVAL,0)='PHOTON'
      ALLOWED_INPUTS(IVAL,1)='POSITRON'
      ALLOWED_INPUTS(IVAL,2)='ALL'
      ALLOWED_INPUTS(IVAL,3)='CHARGED'
      NMIN = NUM_IPART
      NMAX = NUM_IPART
      CALL GET_INPUT
      IVAL = IVAL + 1
      NUM_SOURCE = IVAL
      VALUES_SOUGHT(IVAL)='SOURCE NUMBER'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=23
      DEFAULT(IVAL)=0
      NMIN = NUM_SOURCE
      NMAX = NUM_SOURCE
      CALL GET_INPUT
      ISOURC=VALUE(NUM_SOURCE,1)
      IF ((ISOURC.NE.20)) THEN
        IVAL = IVAL + 1
        NUM_SOPTS = IVAL
        VALUES_SOUGHT(IVAL)='SOURCE OPTIONS'
        IF ((ISOURC.EQ.22)) THEN
          NVALUE(IVAL)=9
        ELSE IF(( ISOURC.EQ.23 )) THEN
          NVALUE(IVAL)=5
        ELSE
          NVALUE(IVAL)=4
        END IF
        TYPE(IVAL)=1
        VALUE_MIN(IVAL)=-999999
        VALUE_MAX(IVAL)=999999
        DEFAULT(IVAL)=1
        NMIN = NUM_SOPTS
        NMAX = NUM_SOPTS
        CALL GET_INPUT
        TEMP1=VALUE(NUM_SOPTS,1)
        TEMP2=VALUE(NUM_SOPTS,2)
        TEMP3=VALUE(NUM_SOPTS,3)
        TEMP4=VALUE(NUM_SOPTS,4)
        IF ((ISOURC.EQ.22)) THEN
          TEMP5=VALUE(NUM_SOPTS,5)
          TEMP6=VALUE(NUM_SOPTS,6)
          TEMP7=VALUE(NUM_SOPTS,7)
          TEMP8=VALUE(NUM_SOPTS,8)
          TEMP9=VALUE(NUM_SOPTS,9)
        END IF
        IF((ISOURC.EQ.23))TEMP5=VALUE(NUM_SOPTS,5)
      END IF
      IQIN=VALUE(NUM_IPART,1)
      IF ((IQIN.EQ.4)) THEN
        IQIN=-1
      END IF
      WRITE(*,*)' IQIN ',IQIN
      IF ((ISOURC.EQ.20)) THEN
        IVAL = IVAL + 1
        NUM_MODEIN = IVAL
        VALUES_SOUGHT(IVAL)='MODEIN'
        NVALUE(IVAL)=1
        TYPE(IVAL)=3
        DEFAULT(IVAL)=1
        ALLOWED_INPUTS(IVAL,0)='LOCAL'
        ALLOWED_INPUTS(IVAL,1)='EXTERNAL'
        NMIN = NUM_MODEIN
        NMAX = NUM_MODEIN
        CALL GET_INPUT
        MODEIN=VALUE(NUM_MODEIN,1)
        IF ((MODEIN.EQ.1)) THEN
          IVAL = IVAL + 1
          NUM_RDFIL = IVAL
          VALUES_SOUGHT(IVAL)='RDIST FILENAME'
          NVALUE(IVAL)=1
          TYPE(IVAL)=2
          NMIN = NUM_RDFIL
          NMAX = NUM_RDFIL
          CALL GET_INPUT
        ELSE
          IVAL = IVAL + 1
          NUM_NRDIST = IVAL
          VALUES_SOUGHT(IVAL)='NRDIST'
          NVALUE(IVAL)=1
          TYPE(IVAL)=0
          VALUE_MIN(IVAL)=1
          VALUE_MAX(IVAL)=100
          DEFAULT(IVAL)=1
          NMIN = NUM_NRDIST
          NMAX = NUM_NRDIST
          CALL GET_INPUT
          NRDIST=VALUE(NUM_NRDIST,1)
          IVAL = IVAL + 1
          NUM_RDISTF = IVAL
          VALUES_SOUGHT(IVAL)='RDISTF'
          NVALUE(IVAL)=NRDIST
          TYPE(IVAL)=1
          VALUE_MIN(IVAL)=0
          VALUE_MAX(IVAL)=999999
          DEFAULT(IVAL)=1.0
          IVAL = IVAL + 1
          NUM_RPDF = IVAL
          VALUES_SOUGHT(IVAL)='RPDF'
          NVALUE(IVAL)=NRDIST
          TYPE(IVAL)=1
          VALUE_MIN(IVAL)=0
          VALUE_MAX(IVAL)=999999
          DEFAULT(IVAL)=1.0
          NMIN=NUM_NRDIST
          NMAX=NUM_RPDF
          NMIN = NMIN
          NMAX = NMAX
          CALL GET_INPUT
        END IF
        IVAL = IVAL + 1
        NUM_RDIOUTSP = IVAL
        VALUES_SOUGHT(IVAL)='RDIST IOUTSP'
        NVALUE(IVAL)=1
        TYPE(IVAL)=3
        DEFAULT(IVAL)=0
        ALLOWED_INPUTS(IVAL,0)='NONE'
        ALLOWED_INPUTS(IVAL,1)='INCLUDE'
        NMIN = NUM_RDIOUTSP
        NMAX = NUM_RDIOUTSP
        CALL GET_INPUT
      END IF
      IF (((ISOURC.EQ.21).OR.(ISOURC.EQ.22))) THEN
        IVAL = IVAL + 1
        NUM_FILSPC = IVAL
        VALUES_SOUGHT(IVAL)='FILSPC'
        TYPE(IVAL)=2
        NMIN = NUM_FILSPC
        NMAX = NUM_FILSPC
        CALL GET_INPUT
      END IF
      IF (( ISOURC .EQ. 23 )) THEN
        IVAL = IVAL + 1
        NUM_BEAM_CODE = IVAL
        VALUES_SOUGHT(IVAL)='BEAM CODE'
        TYPE(IVAL)=2
        IVAL = IVAL + 1
        NUM_PEGS_FILE = IVAL
        VALUES_SOUGHT(IVAL)='PEGS FILE'
        TYPE(IVAL)=2
        IVAL = IVAL + 1
        NUM_IFILE = IVAL
        VALUES_SOUGHT(IVAL)='INPUT FILE'
        TYPE(IVAL)=2
        NMIN = NUM_BEAM_CODE
        NMAX = NUM_IFILE
        CALL GET_INPUT
        IVAL = IVAL + 1
        VALUES_SOUGHT(IVAL)='SECRET'
        nvalue(ival) = 1
        type(ival) = 3
        allowed_inputs(ival,0) = 'no'
        allowed_inputs(ival,1) = 'yes'
        IVAL = IVAL + 1
        NUM_WW23 = IVAL
        VALUES_SOUGHT(IVAL)='WEIGHT WINDOW'
        NVALUE(IVAL)=2
        TYPE(IVAL)=1
        VALUE_MIN(IVAL)=-1e30
        VALUE_MAX(IVAL)= 1e30
        error_flag_save = error_flag
        NMIN = NUM_WW23-1
        NMAX = NUM_WW23
        CALL GET_INPUT
        error_flag = error_flag_save
        IF (( error_flags(NUM_BEAM_CODE) .EQ. 0 )) THEN
          READ (CHAR_VALUE(NUM_BEAM_CODE,1),FMT='(A)') the_beam_code
        ELSE
          error_flag = 1
        END IF
        IF (( error_flags(NUM_PEGS_FILE) .EQ. 0 )) THEN
          READ (CHAR_VALUE(NUM_PEGS_FILE,1),FMT='(A)') the_pegs_file
        ELSE
          error_flag = 1
        END IF
        IF (( error_flags(NUM_IFILE) .EQ. 0 )) THEN
          READ (CHAR_VALUE(NUM_IFILE,1),FMT='(A)') the_input_file
        ELSE
          error_flag = 1
        END IF
        min_weight_23 = -1e30
        max_weight_23 = 1e30
        secret_option_23 = 0
        IF (( error_flags(NUM_WW23) .EQ. 0 )) THEN
          min_weight_23 = value(num_ww23,1)
          max_weight_23 = value(num_ww23,2)
        END IF
        IF (( error_flags(NUM_WW23-1) .EQ. 0 )) THEN
          secret_option_23 = value(NUM_WW23-1,1)
        END IF
      END IF
      IF ((ISOURC.EQ.20)) THEN
        IF ((MODEIN.EQ.1)) THEN
          READ (CHAR_VALUE(NUM_RDFIL,1),FMT='(A)') FILNAM
        ELSE
          NRDIST=VALUE(NUM_NRDIST,1)
          DO 3791 K=1,NRDIST
            RDISTF(K)=VALUE(NUM_RDISTF,K)
            RPDF(K)=VALUE(NUM_RPDF,K)
3791      CONTINUE
3792      CONTINUE
        END IF
        IOUTSP=VALUE(NUM_RDIOUTSP,1)
      END IF
      IF (((ISOURC .EQ. 21) .OR. (ISOURC .EQ. 22))) THEN
        READ (CHAR_VALUE(NUM_FILSPC,1),FMT='(256A1)') FILSPC
      END IF
      WRITE(6,3800)IQIN,ISOURC,TEMP1,TEMP2,TEMP3,TEMP4
3800  FORMAT(T10,'SRCRZ read:', 2I5,4F12.5)
      IF((ISOURC.EQ.22))WRITE(6,3810)TEMP5,TEMP6,TEMP7,TEMP8,TEMP9
3810  FORMAT(T10,'           ',5F12.5)
      IF(((IQIN .LT. -1) .OR. (IQIN .GT. 1 .AND. (ISOURC .LT. 21 .OR. IS
     *OURC .GT. 23)) .OR. (IQIN .GT. 3 .AND. (ISOURC .LT. 21 .OR. ISOURC
     * .GT. 23))))IQIN = 0
      SVTMP1=TEMP1
      SVTMP2=TEMP2
      SVTMP3=TEMP3
      SVTMP4=TEMP4
      RETURN
      ENTRY SRCINI(SCARG1,SCARG2,SCARG3,SCARG4,ICORRL)
      NHSTRY=0
      last_nhstry = 0
      IF ((ISOURC .EQ. 0)) THEN
        RBEAM=TEMP1
        FNORM=TEMP2**2+TEMP3**2+TEMP4**2
        IF ((FNORM.EQ.0.0)) THEN
          UINC=0.0
          VINC=0.0
          WINC=1.0
        ELSE
          FNORM=SQRT(FNORM)
          UINC=TEMP2/FNORM
          VINC=TEMP3/FNORM
          WINC=TEMP4/FNORM
        END IF
        TEMP5=RCYL(NR)
        IF(((RBEAM.LE.0.0).OR.(RBEAM.GT.TEMP5)))RBEAM=TEMP5
        WRITE(6,3820)IQIN,RBEAM,UINC,VINC,WINC
3820    FORMAT(/' Electric charge of the source:',T60,I12/ ' Parallel be
     *am incident from the front(+ve Z-axis)'/ ' Radius of beam at the f
     *ront face of the target:',T60,F10.4,' cm'/ ' X-axis direction cosi
     *ne:',T60,F10.4/ ' Y-axis direction cosine:',T60,F10.4/ ' Z-axis di
     *rection cosine:',T60,F10.4/)
      ELSE IF((ISOURC.EQ.1)) THEN
        DISTZ=TEMP1
        RBEAM=TEMP2
        TEMP3=RCYL(NR)
        IF((DISTZ.LE.0.0))DISTZ=100.
        IF(((RBEAM.LE.0.0).OR.(RBEAM.GT.TEMP3)))RBEAM=TEMP3
        WRITE(6,3830)IQIN,DISTZ,RBEAM
3830    FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' POINT SOURC
     *E ON AXIS INCIDENT FROM THE FRONT(+VE Z-AXIS)'/ ' SOURCE DISTANCET
     *O THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/ ' RADIUS OF THE 
     *BEAM ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/)
      ELSE IF((ISOURC.EQ.2)) THEN
        RBEAM=0.0
        NR=1
        NREG=NPLANE
        RCYL(1)=1000.0
        CYRAD2(1)=1.0E6
        WRITE(6,3840)IQIN,RBEAM
3840    FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' BROAD PARAL
     *LEL BEAM INCIDENT FROM THE FRONT (+VE Z-AXIS)'/ ' RADIUS OF THE BE
     *AM ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/)
        IF ((NMED.NE.1)) THEN
          WRITE(6,3850)
3850      FORMAT(/' **** ALL REGIONS IN A SLAB MUST BE SAME MATERIAL****
     ***'/)
        END IF
      ELSE IF((ISOURC .EQ. 3)) THEN
        RBEAM=TEMP2
        IF ((RBEAM .GT. RCYL(NR))) THEN
          WRITE(6,3860)RBEAM, RCYL(NR)
3860      FORMAT(//' ***  Source radius too big at',F10.3,' Reduced to',
     *F10.3,' cm')
          RBEAM = RCYL(NR)
        END IF
        RBEAM2 = RBEAM**2
        RMINBM = TEMP1
        IF ((RMINBM .GT. RBEAM)) THEN
          RMINBM=RBEAM
        END IF
        RMINSQ = RMINBM**2
        ZSMIN=TEMP3
        ZSMAX=TEMP4
        IF ((ZSMIN .LT. ZPLANE(1))) THEN
          ZSMIN= ZPLANE(1)
        END IF
        IF ((ZSMAX .GT. ZPLANE(NPLANE))) THEN
          ZSMAX = ZPLANE(NPLANE)
        END IF
        WRITE(6,3870)IQIN,RMINBM,RBEAM,ZSMIN,ZSMAX
3870    FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' UNIFORM ISO
     *TROPICALLY RADIATING RING: INNER,OUTER Radius',2F10.3 / '  FRONT,B
     *ack DEPTH:',T50,2F10.3 /)
      ELSE IF((ISOURC .EQ. 4)) THEN
        RBEAM=TEMP1
        IF ((RCYL(NR).LT.650.)) THEN
          IF ((NR.LT.60)) THEN
            NR=NR+1
            NREG=NZ*NR+1
          ELSE
            WRITE(6,3880)
3880        FORMAT(/' ***WARNING***  LAST RADIAL BIN INCREASED TO 1000cm
     *'/)
          END IF
          RCYL(NR)=1000.0
          CYRAD2(NR)=1.0E6
        END IF
        IF(((RBEAM.LE.0.0).OR.(RBEAM.GT.RCYL(NR))))RBEAM=RCYL(NR)
        WRITE(6,3890)IQIN,RBEAM
3890    FORMAT(/' ELECTRIC CHARGE OF BEAM:',T60,I12/ ' CENTRAL AXIS FLUE
     *NCE VS BEAM RADIUS'/ ' RADII INPUT ABOVE WILL BE CONSIDERED AS BEA
     *M RADII'/ ' RADIUS OF CENTRAL AXIS ZONE: ',T60,F10.4,' cm'/)
        IF ((NMED.NE.1)) THEN
          WRITE(6,3900)
3900      FORMAT(/' **** ALL REGIONS IN A SLAB MUST BE SAME MATERIAL****
     ***'/)
        END IF
      ELSE IF((ISOURC .EQ. 10)) THEN
        XBEAM=TEMP1
        ZBEAM=TEMP2
        TEMP3=RCYL(NR)
        IF(((XBEAM.LE.0.0).OR.(XBEAM.GT.TEMP3)))XBEAM=TEMP3
        TEMP3=0.5*(ZPLANE(NPLANE)-ZPLANE(1))
        IF(((ZBEAM.LE.0.0).OR.(ZBEAM.GT.TEMP3)))ZBEAM=TEMP3
        WRITE(6,3910)IQIN,XBEAM,ZBEAM
3910    FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' PARALLEL BE
     *AM INCIDENT FROM THE SIDE'/ ' HALF-WIDTH(X-AXIS) OF THE BEAM AT TH
     *E TARGET MIDPOINT',T60,F10.4,' cm'/ ' HALF-HEIGHT(Z-AXIS/) OF THEB
     *EAM AT THE TARGET MIDPOINT', T60,F10.4,' cm'/)
      ELSE IF((ISOURC .EQ. 11)) THEN
        DISTRH = TEMP1
        IF((DISTRH .LT. 0.0))DISTRH=-DISTRH
        IF((DISTRH .EQ. 0.0))DISTRH=100.0
        XBEAM = TEMP2
        ZBEAM = TEMP3
        TEMP4 = RCYL(NR)
        IF ((DISTRH .LE. TEMP4)) THEN
          WRITE(6,3920)
3920      FORMAT(' SOURCE FROM WITHIN TARGET, INPUT IGNORED')
          ERROR_FLAG=1
        END IF
        TEMP4=TEMP4*SQRT((DISTRH+TEMP4)*(DISTRH-TEMP4))/DISTRH
        IF(((XBEAM .LE. 0.0) .OR. (XBEAM .GT. TEMP4)))XBEAM=TEMP4
        TEMP4=0.5*(ZPLANE(NPLANE)-ZPLANE(1))
        IF(((ZBEAM .LE. 0.0) .OR. (ZBEAM .GT. TEMP4)))ZBEAM=TEMP4
        IF ((ICORRL .EQ. 0)) THEN
          WRITE(6,3930)IQIN,DISTRH,XBEAM,ZBEAM
3930      FORMAT(/' Electric charge of the source:',T60,I12/ ' Point sou
     *rce on axis incident from the side(Y-axis)'/ ' Source distance tot
     *arget midpoint:',T60,F10.4,' cm'/ ' Half-width(X-axis) of the beam
     * at the target midpoint',T60,F10.4,' cm'/ ' Half-height(Z-axis/)of
     * the beam at the target midpoint', T60,F10.4,' cm'/)
        END IF
      ELSE IF((ISOURC .EQ. 12)) THEN
        DISTRH=TEMP1
        IF((DISTRH .LT. 0.0))DISTRH=-DISTRH
        DISTZ=TEMP2
        RBEAM=RCYL(NR)
        IF ((DISTRH .GT. RBEAM)) THEN
          XBEAM=RBEAM*SQRT((DISTRH-RBEAM)*(DISTRH+RBEAM))/DISTRH
          ZBEAM=0.5*(ZPLANE(NPLANE)-ZPLANE(1))
        ELSE
          XBEAM=0.0
          ZBEAM=0.0
        END IF
        IF (((DISTRH .LE. RBEAM) .AND. DISTZ .GE. ZPLANE(1)-ZPLANE(NPLAN
     *  E) .AND. DISTZ.LE.0.0)) THEN
          WRITE(6,3940)
3940      FORMAT(' Source from within target, input ignored')
          ERROR_FLAG=1
        END IF
        WRITE(6,3950)IQIN,DISTRH,DISTZ,RBEAM,XBEAM,ZBEAM
3950    FORMAT(/' Electric charge of the source:',T60,I12/ ' Point sourc
     *e off axis'/ ' Distance of source off the central axis',T60,F10.4,
     *' cm'/ ' Perpendicular distance of source from front plane',T60,F1
     *0.4,' cm'/ ' Radius of the beam on the front face of the target:',
     *T60,F10.4,' cm'/ ' Half-width(X-axis) of the beam between thetange
     *nt points', T60,F10.4,' cm'/ ' Half-height(z-axis) of the beam bet
     *ween the tangent points', T60,F10.4,' cm'/)
      ELSE IF((ISOURC .EQ. 13)) THEN
        FNORM=TEMP1**2+TEMP2**2+TEMP3**2
        IF ((FNORM .EQ. 0.0)) THEN
          UINC=0.0
          VINC=0.0
          WINC=1.0
        ELSE
          FNORM=SQRT(FNORM)
          WINC=TEMP3/FNORM
          VINC=-SQRT((1.0-WINC)*(1.0+WINC))
          UINC=0.0
        END IF
        RBEAM=RCYL(NR)
        IF ((ABS(WINC).NE.1.0)) THEN
          XBEAM=RBEAM
          ZBEAM=0.5*(ZPLANE(NPLANE)-ZPLANE(1))
        ELSE
          XBEAM=0.0
          ZBEAM=0.0
        END IF
        WRITE(6,3960)IQIN,UINC,VINC,WINC,RBEAM,XBEAM,ZBEAM
3960    FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' PARALLEL BE
     *AM AT ANY ANGLE WITH RESPECT TO THE TARGET'/ ' X-AXIS DIRECTION CO
     *SINE:',T60,F10.4/ ' Y-AXIS DIRECTION COSINE:',T60,F10.4/ ' Z-AXISD
     *IRECTION COSINE:',T60,F10.4/ ' RADIUS OF THE BEAM ON THE FRONT FAC
     *E OF THE TARGET:',T60,F10.4,' cm'/ ' HALF-WIDTH(X-AXIS) OF THE BEA
     *M BETWEEN THE TANGENT POINTS', T60,F10.4,' cm'/ ' HALF-HEIGHT(Z-AX
     *IS) OF THE BEAM BETWEEN THE TANGENT POINTS', T60,F10.4,' cm'/)
      ELSE IF((ISOURC .EQ. 14)) THEN
        DISTZ=TEMP1
        RBEAM=TEMP2
        RMINBM=TEMP3
        IF((DISTZ.LE.0.0))DISTZ=100.
        IF(((RBEAM.LE.0.0).OR.(RBEAM.GT.RCYL(NR))))RBEAM=RCYL(NR)
        IF ((RMINBM.EQ.0.0)) THEN
          WRITE(6,3970)
3970      FORMAT(/' ***WHY USE ISOURC=14 WITH RMINB=0.0?***')
        END IF
        WRITE(6,3980)IQIN,DISTZ,RBEAM,RMINBM
3980    FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' POINT SOURC
     *E ON AXIS INCIDENT FROM THE FRONT(+VE Z-AXIS)'/ ' SOURCE DISTANCET
     *O THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/ ' RADIUS OF THE 
     *BEAM ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/ ' INNER RA
     *DIUS OF BEAM ON FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/)
      ELSE IF((ISOURC .EQ. 15)) THEN
        call src15_ini(temp1,temp2,temp3,temp4,ERROR_FLAG)
      ELSE IF((ISOURC .EQ. 16)) THEN
        call src16_ini(temp1,temp2,temp3,temp4,ERROR_FLAG)
      ELSE IF((ISOURC .EQ. 17)) THEN
        DISTZ=TEMP1
        XBEAM=TEMP2
        YBEAM=TEMP3
        TEMP4=RCYL(NR)
        IF((DISTZ.LE.0.0))DISTZ=100.
        IF(((RBEAM.LE.0.0).OR.(RBEAM.GT.TEMP4)))RBEAM=TEMP4
        WRITE(6,3990)IQIN,DISTZ,XBEAM,YBEAM
3990    FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' POINT SOURC
     *E ON AXIS INCIDENT FROM THE FRONT(+VE Z-AXIS)'/ ' SOURCE DISTANCET
     *O THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/ ' X-AXIS HALF-WI
     *DTH ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/ ' Y-AXIS HA
     *LF-WIDTH ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/)
      ELSE IF((ISOURC .EQ. 20)) THEN
        WRITE(6,4000)
4000    FORMAT(' Local input(0) or external file(1): ',$)
        WRITE(6,4010)
4010    FORMAT(/' RADIAL DISTRIBUTION:')
        IF ((MODEIN.EQ.0)) THEN
          WRITE(6,4020)
4020      FORMAT(' Number of radial bins: ',$)
          IF (((NRDIST.LT.1).OR.(NRDIST.GT.100))) THEN
            WRITE(6,4030)
4030        FORMAT(/' *** NUMBER RADIAL BINS OUT OF RANGE (<1 OR >100),'
     *, ' RESET TO 100 ***')
            NRDIST=100
          END IF
          WRITE(6,4040)NRDIST
4040      FORMAT(' INPUT',I4,' SETS OF RDISTF,RPDF IN 2F20.0 FORMAT')
          WRITE(6,4050)
4050      FORMAT('   RDISTF INCREASING IN SIZE, RPDF NON-NEGATIVE')
          DO 4061 IB=1,NRDIST
4061      CONTINUE
4062      CONTINUE
        ELSE
          WRITE(6,4070)
4070      FORMAT(' Input name of file with spectrum (up to 80 char with.
     *ext): '/)
          WRITE(6,4080)FILNAM
4080      FORMAT(/' Read input radial distribution from: '/80A1)
          call replace_env(FILNAM)
          OPEN(UNIT=9,file=filnam,STATUS='OLD')
          READ(9,*)NRDIST
          IF (((NRDIST.LT.1).OR.(NRDIST.GT.100))) THEN
            WRITE(6,4090)
4090        FORMAT(' *** Number radial bins out of range (<1 OR >100),',
     *' RESET TO 100 ***')
            NRDIST=100
          END IF
          DO 4101 IB=1,NRDIST
            READ(9,*)RDISTF(IB),RPDF(IB)
4101      CONTINUE
4102      CONTINUE
          CLOSE(UNIT=9)
          WRITE(6,4110)NRDIST
4110      FORMAT('    HAVE READ',I5,' INPUT RADIAL BINS FROM FILE')
        END IF
        ICOUNT=0
        RLAST=0
        IERROR=0
4120    CONTINUE
4121      CONTINUE
          ICOUNT=ICOUNT+1
          IF ((ICOUNT.GT.NRDIST)) THEN
            GO TO 4122
          END IF
          IF ((RDISTF(ICOUNT).LE.RLAST)) THEN
            IERROR=1
            WRITE(6,4130)
4130        FORMAT(' *** RDISTF>=LAST ONE. NOT ALLOWED,', ' TERMINATINGR
     *ADIAL DISTRIBUTION INPUT.')
          ELSE IF((RDISTF(ICOUNT).GT.RCYL(NR))) THEN
            IERROR=1
            WRITE(6,4140)RCYL(NR)
4140        FORMAT(' *** RDISTF>',G14.7,', GEOMETRY SIZE.', ' TERMINATIN
     *G RADIAL DISTRIBUTION INPUT')
          ELSE IF((RPDF(ICOUNT).LT.0.0)) THEN
            IERROR=1
            WRITE(6,4150)
4150        FORMAT(' PDF < 0 NOT ALLOWED,', ' TERMINATING RADIAL DISTRIB
     *UTION INPUT')
          END IF
          IF ((IERROR.EQ.1)) THEN
            ICOUNT=ICOUNT-1
            IF ((ICOUNT.EQ.0)) THEN
              WRITE(6,4160)
4160          FORMAT(' *** NO RADIAL DISTRIBUTION DEFINED,', ' STOPPINGE
     *XECUTION ***')
              STOP
            END IF
            WRITE(6,4170)ICOUNT
4170        FORMAT(' RADIAL DITRIBUTION INPUT APPEARS TO BE INCOMPLETE,'
     *, ' NRDIST RESET TO ',I12)
            NRDIST=ICOUNT
            GO TO 4122
          END IF
          RLAST=RDISTF(ICOUNT)
        GO TO 4121
4122    CONTINUE
        WRITE(6,4180)RDISTF(NRDIST)
4180    FORMAT('    RADIAL DISTRIBUTION RANGES FROM 0 TO',F12.3,' cm')
        WRITE(6,4190)
4190    FORMAT(' PRINT DISTRIBUTION DATA IN OUTPUT SUMMARY, YES(1) OF NO
     *(0): ',$)
        IF((IOUTSP.NE.1))IOUTSP=0
        WRITE(6,'('' '')')
      ELSE IF(( ISOURC .EQ. 23 )) THEN
        dist_phsp = temp1
        theta_phsp = temp2
        cost_phsp = cos(theta_phsp*0.017453292222)
        sint_phsp = sin(theta_phsp*0.017453292222)
        chamber_c = temp3
        xoffset = temp4
        yoffset = temp5
        ENFLAG=1
        iqinc = iqin
        WRITE(6,4200)iqinc,min_weight_23,max_weight_23, the_beam_code(:l
     *  nblnk1(the_beam_code)),the_pegs_file(:lnblnk1(the_pegs_file)), t
     *  he_input_file(:lnblnk1(the_input_file)), dist_phsp,theta_phsp,ch
     *  amber_c,xoffset,yoffset
4200    FORMAT(/' Full treatment head simulation from an angle'/, '    P
     *article charge                               : ',i3,/ '    Weightw
     *indow                                 : ',2g15.6,/ '    BEAMnrc us
     *er code                             : ',a,/ '    PEGS data file   
     *                           : ',a,/ '    Input file                
     *       : ',a,/ '    Rotation point to phsp-plane midpoint distance
     *: ',f10.4,/ '    Incident angle (degrees)             : ',f10.4,/ 
     *'    Rotation point (will be set to chamber center'/, '      if gr
     *eater than 1e4 or less than -1e4):     :',g14.4, ' cm.'/ '    X of
     *fset of phsp plane (before rotation)  : ',f10.4,' cm'/ '    Y offs
     *et of phsp plane (before rotation)    : ',f10.4,' cm')
        write(6,'(//a)') 'About to call init_beamsource'
        call init_beamsource(i_parallel,n_parallel,i_log,'linux', hen_ho
     *  use,egs_home,the_beam_code, the_pegs_file,the_input_file)
        call maxenergy_beamsource(EKSRCM)
        EIN=EKSRCM
        WRITE(6,4210)EKSRCM
4210    FORMAT('    Max. kinetic energy of simulation             : ',f1
     *0.4,' MeV'/)
      ELSE IF(((ISOURC .EQ. 21) .OR. (ISOURC .EQ. 22))) THEN
        IQINC=IQIN
        IF ((ISOURC .EQ. 22)) THEN
          dist_phsp=TEMP2
          theta_phsp = temp3
          cost_phsp = cos(theta_phsp*0.017453292222)
          sint_phsp = sin(theta_phsp*0.017453292222)
          chamber_c = temp4
          count_phsp = 0
          xoffset = TEMP8
          yoffset = TEMP9
        END IF
        IMODE=TEMP1
        IF ((ISOURC.EQ.21)) THEN
          NRCYCL=TEMP2
          IPARALLEL=TEMP3
          PARNUM=TEMP4
        ELSE IF((ISOURC.EQ.22)) THEN
          NRCYCL=TEMP5
          IPARALLEL=TEMP6
          PARNUM=TEMP7
        END IF
        IF((IMODE.NE.2))IMODE=0
        WRITE(6,4220)IMODE
4220    FORMAT(/' MODE',I2,' Phase-space file to be read from unit 42...
     *'/ ' Input name of file with phase space data (1 - 80 CHARS,', 'wi
     *th .EXT): ')
        WRITE(6,4230)FILSPC
4230    FORMAT(/' Reading phase space information from: '/10x,256A1)
        call replace_env(SPCNAM)
        i_iaea_in=0
        ilen=lnblnk1(SPCNAM)
        IF ((SPCNAM(ilen-8:ilen).EQ.'.IAEAphsp')) THEN
          i_iaea_in=1
          SPCNAM=SPCNAM(:ilen-9)
        END IF
        IF ((i_iaea_in.EQ.1)) THEN
          i_unit_in=42
          call iaea_new_source(i_unit_in,SPCNAM,1,iaea_result)
          IF ((iaea_result.LT.0)) THEN
            WRITE(i_log,*)' Error opening IAEA phase space source.'
          END IF
          call iaea_get_max_particles(i_unit_in,-1,iaea_dummy_long)
          NCASE_PHSP=iaea_dummy_long
          call iaea_get_max_particles(i_unit_in,1,iaea_dummy_long)
          NPHOTPHSP=iaea_dummy_long
          call iaea_get_total_original_particles(i_unit_in,iaea_dummy_lo
     *    ng)
          NINCSRC=iaea_dummy_long
          call iaea_get_maximum_energy(i_unit_in,EKMAX_PHSP_SHORT)
          TEMP2=EKMAX_PHSP_SHORT
          call iaea_get_constant_variable(i_unit_in,2,Z_PHSP_SHORT,iaea_
     *    result)
          IF ((iaea_result.EQ.-3)) THEN
            write(i_log,*) ' Z positions of each particle will be read f
     *rom phase space data.'
            Z_SOURCE=999.
            IZSCORE=1
          ELSE IF((iaea_result.LT.0)) THEN
            write(i_log,*)' Error reading Z position where IAEA phsp was
     * scored.'
            IZSCORE=0
          ELSE
            Z_SOURCE=Z_PHSP_SHORT
            IZSCORE=0
          END IF
          call iaea_get_extra_numbers(i_unit_in,iaea_n_extra_floats,iaea
     *    _n_extra_ints)
          IF ((iaea_n_extra_floats .EQ. -1 .OR. iaea_n_extra_ints .EQ. -
     *    1)) THEN
            write(i_log,*)' Error reading number of extra variables stor
     *ed in IAEA phsp'
          END IF
          call iaea_get_type_extra_variables(i_unit_in,iaea_result,iaea_
     *    extra_int_types, iaea_extra_float_types)
          IF ((iaea_result.EQ.-1)) THEN
            write(i_log,*)' Error getting types of extra variables store
     *d in IAEA phsp'
          END IF
          DO 4241 I_PHSP=1,iaea_n_extra_ints
            IF ((iaea_extra_int_types(I_PHSP).EQ.2)) THEN
              iaea_i_latch=I_PHSP
              GO TO4242
            END IF
4241      CONTINUE
4242      CONTINUE
          IF ((iaea_i_latch.EQ.-99)) THEN
            write(i_log,*)' Warning: IAEA format phsp file does not stor
     *e LATCH'
          END IF
          DO 4251 I_PHSP=1,iaea_n_extra_floats
            IF ((iaea_extra_float_types(I_PHSP).EQ.3)) THEN
              iaea_i_zlast=I_PHSP
              GO TO4252
            END IF
4251      CONTINUE
4252      CONTINUE
          IF ((iaea_i_zlast.EQ.-99)) THEN
            ismode=0
          ELSE
            ismode=1
          END IF
          iaea_i_muidx=MAX(1,iaea_i_zlast+1)
          IF ((iaea_i_muidx.GT.iaea_n_extra_floats .OR. iaea_extra_float
     *    _types(iaea_i_muidx).NE.0)) THEN
            iaea_i_muidx=-99
            IMUPHSP=0
          ELSE
            IMUPHSP=1
          END IF
          WRITE(6,4260)NCASE_PHSP,NPHOTPHSP,TEMP2,NINCSRC
4260      FORMAT(T10,' IAEA format Phase space source with:'/ T5,'      
     *        Total number of particles =',I13/ T5,'              Number
     * of photons =',I13/ T5,'              Maximumparticle kinetic ener
     *gy =',F13.3,' MeV'/ T5,' # of particles incident from original sou
     *rce =',F13.1/)
          IF ((IZSCORE.EQ.0)) THEN
            WRITE(6,4270)Z_SOURCE
4270        FORMAT(T5,'                        Z where source scored =',
     *F13.3,' cm'/)
          END IF
          call iaea_check_file_size_byte_order(i_unit_in,iaea_result)
          IF ((iaea_result.EQ.-3)) THEN
            WRITE(i_log,*)' ERROR: Size of phase space file does not mat
     *ch'
            WRITE(i_log,*)' the value of checksum in the header.  Someth
     *ing may be'
            WRITE(i_log,*)' wrong.  Check your file.'
            call exit(1)
          ELSE IF((iaea_result.EQ.-4)) THEN
            WRITE(i_log,*)' ERROR: Byte order in the phase space file do
     *es not'
            WRITE(i_log,*)' match the machine you are running on.'
            call exit(1)
          ELSE IF((iaea_result.EQ.-5)) THEN
            WRITE(i_log,*)' ERROR: Size of file does not match the value
     * of checksum'
            WRITE(i_log,*)' in the header AND there is a byte order mism
     *atch between'
            WRITE(i_log,*)' the file and the machine you are running on.
     *'
            call exit(1)
          ELSE IF((iaea_result.EQ.-1)) THEN
            WRITE(i_log,*)' ERROR: Cannot open phase space header.'
            call exit(1)
          ELSE IF((iaea_result.EQ.-2)) THEN
            WRITE(i_log,*)' ERROR: Something is wrong with the phase spa
     *ce file.'
            call exit(1)
          END IF
        ELSE
          IF ((IMODE.GT.0)) THEN
            PHSP_RECL=4*8
            OPEN(UNIT=42,FILE=SPCNAM,FORM='UNFORMATTED',ACCESS='DIRECT',
     *       RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP)
            IF ((IERR_PHSP.NE.0)) THEN
              WRITE(6,4280)
4280          FORMAT(/' ***error opening file as MODE2 ****' /' *** THEF
     *ILE FORMAT MAY BE WRONG (I.E., NOT A MODE2 FILE) ***'/ /' *** WENO
     *W TRY TO OPEN IT AS A MODE3 FILE ***'//)
              OPEN(UNIT=42,STATUS='OLD',FILE=SPCNAM, FORM='UNFORMATTED',
     *         IOSTAT=IERR_PHSP)
              IF ((IERR_PHSP.NE.0)) THEN
                WRITE(6,4290)
4290            FORMAT(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***')
                STOP
              END IF
              READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT_PHS
     *        P_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT
              NCASE_PHSP=NUM_PHSP_TOT
              NPHOTPHSP=PHOT_PHSP_TOT
              TEMP2=EKMAX_PHSP_SHORT
              TEMP3=EKMINE_PHSP_SHORT
              NINCSRC=NINC_PHSP_SHORT
              IF ((IERR_PHSP.NE.0)) THEN
                WRITE(6,4300)
4300            FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FILE**
     ** '//)
                STOP
              END IF
              IF ((LINE1 .NE. 'MODE3')) THEN
                WRITE(6,4310)
4310            FORMAT(//' That file does not start with MODE3,', ' as a
     *ll old compressed files (with ZLAST) must'/ '  Check it out and tr
     *y again!'///)
                IERR_PHSP=1
                STOP
              ELSE
                WRITE(6,4320)
4320            FORMAT(//' This is a MODE3 file! '/ ' Please convert iti
     *nto a MODE2 file using [readphsp] ', ' and try again!'///)
                IERR_PHSP=1
                STOP
              END IF
            END IF
            READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT_PHSP_
     *      TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT
            NCASE_PHSP=NUM_PHSP_TOT
            NPHOTPHSP=PHOT_PHSP_TOT
            TEMP2=EKMAX_PHSP_SHORT
            TEMP3=EKMINE_PHSP_SHORT
            NINCSRC=NINC_PHSP_SHORT
            IF ((IERR_PHSP.NE.0)) THEN
              WRITE(6,4330)
4330          FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FILE***'
     *//)
              STOP
            END IF
            IF ((LINE1 .NE. 'MODE2')) THEN
              WRITE(6,4340)
4340          FORMAT(//' That file does not start with MODE2,', ' as sta
     *ndard compressed files with ZLAST must'/ '  Check it out and try a
     *gain!'///)
              IERR_PHSP=1
              STOP
            END IF
          ELSE IF((IMODE.EQ.0)) THEN
            PHSP_RECL=4*7
            OPEN(UNIT=42,FILE=SPCNAM,FORM='UNFORMATTED',ACCESS='DIRECT',
     *       RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP)
            IF ((IERR_PHSP.NE.0)) THEN
              WRITE(6,4350)
4350          FORMAT(/' ***ERROR opening file as MODE0****' /' *** THE F
     *ILE FORMAT MAY BE WRONG (I.E., NOT A MODE0 FILE) ***'/ /' *** WE N
     *OW TRY TO OPEN IT AS A MODE1 FILE ***'//)
              OPEN(UNIT=42,STATUS='OLD',FILE=SPCNAM, FORM='UNFORMATTED',
     *         IOSTAT=IERR_PHSP)
              IF ((IERR_PHSP.NE.0)) THEN
                WRITE(6,4360)
4360            FORMAT(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***')
                STOP
              END IF
              READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT_PHS
     *        P_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT
              NCASE_PHSP=NUM_PHSP_TOT
              NPHOTPHSP=PHOT_PHSP_TOT
              TEMP2=EKMAX_PHSP_SHORT
              TEMP3=EKMINE_PHSP_SHORT
              NINCSRC=NINC_PHSP_SHORT
              IF ((IERR_PHSP.NE.0)) THEN
                WRITE(6,4370)
4370            FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FILE**
     ** '//)
                STOP
              END IF
              IF ((LINE1 .NE. 'MODE1')) THEN
                WRITE(6,4380)
4380            FORMAT(//' That file does not start with MODE1,', ' as a
     *ll old compressed files must'/ '  Check it out and try again!'///)
                IERR_PHSP=1
                STOP
              ELSE
                WRITE(6,4390)
4390            FORMAT(//' This is a MODE1 file! '/ ' Please convert iti
     *nto a MODE0 file using [readphsp] ', 'and try again!'///)
                IERR_PHSP=1
                STOP
              END IF
            END IF
            READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT_PHSP_
     *      TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT
            NCASE_PHSP=NUM_PHSP_TOT
            NPHOTPHSP=PHOT_PHSP_TOT
            TEMP2=EKMAX_PHSP_SHORT
            TEMP3=EKMINE_PHSP_SHORT
            NINCSRC=NINC_PHSP_SHORT
            IF ((IERR_PHSP.NE.0)) THEN
              WRITE(6,4400)
4400          FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FILE***'
     *//)
              STOP
            END IF
            IF ((LINE1 .NE. 'MODE0')) THEN
              WRITE(6,4410)
4410          FORMAT(/' Does not start with MODE0 as files without ZLAST
     * must'/ '  Try again!'//)
              IERR_PHSP=1
              STOP
            END IF
          ELSE IF((IMODE.LT.0)) THEN
            WRITE(6,4420)
4420        FORMAT(/' First, try to open it as a MODE0 file')
            PHSP_RECL=4*7
            OPEN(UNIT=42,FILE=SPCNAM,FORM='UNFORMATTED',ACCESS='DIRECT',
     *       RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP)
            IF ((IERR_PHSP.NE.0)) THEN
              WRITE(6,4430)
4430          FORMAT(/' Now try to open it as a MODE2 file')
              IMODE=1
              PHSP_RECL=4*8
              OPEN(UNIT=42,FILE=SPCNAM,FORM='UNFORMATTED',ACCESS='DIRECT
     *', RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP)
              IF ((IERR_PHSP.NE.0)) THEN
                WRITE(6,4440)
4440            FORMAT(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***')
              ELSE
                READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT_P
     *          HSP_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SH
     *          ORT
                NCASE_PHSP=NUM_PHSP_TOT
                NPHOTPHSP=PHOT_PHSP_TOT
                TEMP2=EKMAX_PHSP_SHORT
                TEMP3=EKMINE_PHSP_SHORT
                NINCSRC=NINC_PHSP_SHORT
                IF ((IERR_PHSP.NE.0)) THEN
                  WRITE(6,4450)
4450              FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FILE
     **** '//)
                  STOP
                END IF
                IF ((LINE1.NE.'MODE2')) THEN
                  WRITE(6,4460)
4460              FORMAT(//' That file does not start with MODE2,', ' as
     * standard compressed files with ZLAST must'/ '  Check it out and t
     *ry again!'///)
                  CLOSE(42)
                  STOP
                END IF
              END IF
            ELSE
              READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT_PHS
     *        P_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT
              NCASE_PHSP=NUM_PHSP_TOT
              NPHOTPHSP=PHOT_PHSP_TOT
              TEMP2=EKMAX_PHSP_SHORT
              TEMP3=EKMINE_PHSP_SHORT
              NINCSRC=NINC_PHSP_SHORT
              IF ((IERR_PHSP.NE.0)) THEN
                WRITE(6,4470)
4470            FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FILE**
     ** '//)
                STOP
              END IF
              IMODE=0
              IF ((LINE1.NE.'MODE0')) THEN
                WRITE(6,4480)
4480            FORMAT(/' The file does not start with MODE0 as it suppo
     *sed to')
                CLOSE(42)
                WRITE(6,4490)
4490            FORMAT(/' Now try to open it as a MODE2 file')
                IMODE=1
                PHSP_RECL=4*8
                OPEN(UNIT=42,FILE=SPCNAM,FORM='UNFORMATTED',ACCESS='DIRE
     *CT', RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP)
                IF ((IERR_PHSP.NE.0)) THEN
                  WRITE(6,4500)
4500              FORMAT(//' *** PHASE SPACE FILE CANNOT BE OPENED. ***'
     *)
                ELSE
                  READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT
     *            _PHSP_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHS
     *            P_SHORT
                  NCASE_PHSP=NUM_PHSP_TOT
                  NPHOTPHSP=PHOT_PHSP_TOT
                  TEMP2=EKMAX_PHSP_SHORT
                  TEMP3=EKMINE_PHSP_SHORT
                  NINCSRC=NINC_PHSP_SHORT
                  IF ((IERR_PHSP.NE.0)) THEN
                    WRITE(6,4510)
4510                FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FI
     *LE*** '//)
                    STOP
                  END IF
                  IF ((LINE1.NE.'MODE2')) THEN
                    WRITE(6,4520)
4520                FORMAT(//' That file does not start with MODE2,', 'a
     *s standard compressed files with ZLAST must'/ '  Check it out and 
     *try again!'///)
                    CLOSE(42)
                    STOP
                  END IF
                END IF
              END IF
            END IF
          END IF
          WRITE(6,4530)NCASE_PHSP,NPHOTPHSP,TEMP2,TEMP3,NINCSRC
4530      FORMAT(' Total number of particles in file      :',I10/ ' Tota
     *l number of photons                :',I10/ ' (the rest are electro
     *ns and positrons)'// ' Maximum kinetic energy of the particles:',F
     *10.3,' MeV'/ ' Minimum kinetic energy of the electrons:',F10.3,' M
     *eV'/ ' # particles incident when phase space created :',F15.0/)
          EKSRCM=TEMP2
          EIN=TEMP2
          IF ((NCASE_PHSP .LT. 0 .OR. NPHOTPHSP .LT. 0 .OR. TEMP2 .LE. 0
     *     .OR. TEMP3 .LT.0 .OR. NINCSRC .LE.0.0)) THEN
            WRITE(6,4540)
4540        FORMAT(3(1x,79('*')/)/' Something is wrong in the above' /'L
     *ikely the file is the wrong format (need to swap bytes)'/ 3(1x,79(
     *'*')/))
            STOP
          END IF
          NHSTRYM=0
          IF ((IMODE.NE.0)) THEN
            READ(42,REC=2,IOSTAT=IERR_PHSP) LATCHM,ESHORT,X_PHSP_SHORT,Y
     *      _PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT,ZLAST_P
     *      HSP_SHORT
          ELSE
            READ(42,REC=2,IOSTAT=IERR_PHSP) LATCHM,ESHORT,X_PHSP_SHORT,Y
     *      _PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT
          END IF
          IF ((2.EQ.76695869)) THEN
            write(*,*)' x,y,u,v,wt,eshort,latch', X_PHSP_SHORT,Y_PHSP_SH
     *      ORT,U_PHSP_SHORT,V_PHSP_SHORT, WT_PHSP_SHORT,ESHORT,LATCHM
          END IF
          IF ((ESHORT.LT.0.0)) THEN
            NHSTRYM=NHSTRYM+1
            ESHORT=ABS(ESHORT)
          END IF
          EINM=ESHORT
          WEIGHTM=WT_PHSP_SHORT
          XINM=X_PHSP_SHORT
          YINM=Y_PHSP_SHORT
          UINM=U_PHSP_SHORT
          VINM=V_PHSP_SHORT
          IF((IMODE.NE.0))ZLASTM=ZLAST_PHSP_SHORT
          IF ((NHSTRYM.NE.1)) THEN
            DOSE_STAT=1
            WRITE(6,4550)
4550        FORMAT(//' ***WARNING***'/ ' Cannot read no. of primary (non
     *-phsp) histories from ph-sp source.'/ ' Dose and fluence will be a
     *nalyzed assuming each particle read from'/ ' the ph-sp file is ani
     *ndependent history.  May result in an'/ ' underestimate of uncerta
     *inties.'//)
          END IF
        END IF
        IF (( isourc .EQ. 22 )) THEN
          WRITE(6,4560)dist_phsp,theta_phsp,chamber_c,xoffset,yoffset
4560      FORMAT(/' Phase space file from an angle'/, '    Rotation poin
     *t to phsp-plane midpoint distance: ',f10.4,/ '    Incident angle (
     *degrees)                      : ',f10.4,/ '    Rotation point (wil
     *l be set to chamber center'/, '      if greater than 1e4 or less t
     *han -1e4):     : ',g14.4, ' cm.'/ '    X offset of phsp plane (bef
     *ore rotation)      : ',f10.4,' cm'/ '    Y offset of phsp plane (b
     *efore rotation)      : ',f10.4,' cm'/)
        END IF
        IF ((IPARALLEL.GT.1 .AND. n_parallel.GT.0)) THEN
          WRITE(6,4570)IPARALLEL, n_parallel
4570      FORMAT(/' You have set IPARALLEL in the input file to ',I4,/ '
     * But you are also running a C compiled code with n_parallel=',I4,/
     *' IPARALLEL will be reset to 1, and control of the parallel run '/
     * ' will be from the code.'/)
          IPARALLEL=1
        END IF
        IF((IPARALLEL.LE.0))IPARALLEL=1
        IF((PARNUM.LT.0))PARNUM=0
        IF ((IPARALLEL.GT.1)) THEN
          IF ((PARNUM.GE.1 .AND. PARNUM.LE.IPARALLEL)) THEN
            WRITE(6,4580)IPARALLEL,INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+
     *      1, INT(PARNUM*NCASE_PHSP/IPARALLEL)
4580        FORMAT(/' This is one of ',I4,' parallel jobs.'/ ' It will u
     *se from particle ',I12,' to particle ',I12,/ ' from the phase spac
     *e source in the simulation.'/)
          ELSE
            WRITE(6,4590)IPARALLEL
4590        FORMAT(/' IPARALLEL input indicates that this is one of ',I4
     *,' parallel jobs.'/ ' But PARNUM is out of range (<1 or >IPARALLEL
     *).  Therefore, phsp '/ ' source will not be partitioned.'/)
            PARNUM=0
            IPARALLEL=1
          END IF
        END IF
        IF ((NRCYCL.LE.0)) THEN
          IF ((IQIN.EQ.1)) THEN
            WRITE(6,4600)
4600        FORMAT(/' NRCYCL cannot be calculated automatically because'
     */ ' INCIDENT PARTICLE= positrons '/)
            NRCYCL=0
          ELSE
            WRITE(6,4610)
4610        FORMAT(/' NRCYCL will be calculated automatically'/)
            IF ((IQIN.EQ.-1 .OR. IQIN.EQ.3)) THEN
              TEMPDIV=NCASE_PHSP-NPHOTPHSP
            ELSE IF((IQIN.EQ.0)) THEN
              TEMPDIV=NPHOTPHSP
            ELSE IF((IQIN.EQ.2)) THEN
              TEMPDIV=NCASE_PHSP
            END IF
            IF ((NINT(dble(IPARALLEL*NCASE)/dble(TEMPDIV)).LE.1)) THEN
              NRCYCL=0
            ELSE IF((MOD(IPARALLEL*NCASE,TEMPDIV).EQ.0)) THEN
              NRCYCL=(IPARALLEL*NCASE)/TEMPDIV-1
            ELSE
              NRCYCL=(IPARALLEL*NCASE)/TEMPDIV
            END IF
          END IF
        END IF
        WRITE(6,4620)NRCYCL
4620    FORMAT(/' Particles will be recycled ',I4,' times before movingo
     *n to next one.'/)
        CYCLNUM=0
        ENFLAG=1
        N_RUN_CHUNK_OLD=0
      ELSE
        ISOURC=0
        RBEAM=RCYL(NR)
        WRITE(6,4630)IQIN,RBEAM
4630    FORMAT(/ ' Electric charge of the source:',T60,I12/ ' Parallel b
     *eam incident from the front(+ve Z-axis)'/ ' Radius of beam at thef
     *ront face of the target:',T60,F10.4,' cm'/)
      END IF
      RETURN
4640  CONTINUE
      ERROR_FLAG=1
      RETURN
      ENTRY SRCOTO(WEIGHT)
      IFPB=1
      IF (((ISOURC.EQ.0).OR.(ISOURC.EQ.2).OR.(ISOURC.EQ.4))) THEN
        IFPB=0
        IF(((ISOURC.EQ.0).AND.(WINC.NE.1.)))IFPB=1
        RBEAM=RBEAM*0.9999
        RBEAM2=RBEAM**2
        WEIGHT=1.0
        AFACE=PI*RBEAM2
        IF ((ISOURC .EQ. 0)) THEN
          AINFLU=dble(NCASET)/AFACE
        ELSE
          AINFLU=dble(NCASET)
        END IF
      ELSE IF((ISOURC .EQ. 1)) THEN
        RBEAM=RBEAM*0.9999
        RBEAM2=RBEAM**2
        DISTZ2=DISTZ**2
        DISTRH=0.0
        ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1))
        ZSOFST=ZPLANE(1)-DISTZ
        AFACE=PI*RBEAM**2
        PROBFC=1.0
        AINFLU=dble(NCASET)/DISTZ2
      ELSE IF((ISOURC .EQ. 3)) THEN
        WEIGHT=1.0
        AINFLU=dble(NCASET)
        ZSOFST=0.5*(ZSMAX - ZSMIN)+ ZSMIN
        ZBEAM=0.5*(ZSMAX - ZSMIN)
      ELSE IF((ISOURC .EQ. 10)) THEN
        XBEAM=XBEAM*0.9999
        ZBEAM=ZBEAM*0.9999
        ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1))
        RCYL1=RCYL(NR)
        RCYL2=RCYL1**2
        ASIDE=4.0*XBEAM*ZBEAM
        WEIGHT=1.
        AINFLU=dble(NCASET)/ASIDE
      ELSE IF((ISOURC .EQ. 11)) THEN
        XBEAM=XBEAM*0.9999
        ZBEAM=ZBEAM*0.9999
        ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1))
        ZSOFST=ZCOFST
        RCYL1=RCYL(NR)
        RCYL2=RCYL1**2
        DSTRH2=DISTRH**2
        ASIDE=4.0*XBEAM*ZBEAM
        PROBSD=1.0
        AINFLU = dble(NCASET)/DSTRH2
      ELSE IF((ISOURC .EQ. 12)) THEN
        RBEAM = RBEAM*0.9999
        XBEAM = XBEAM*0.9999
        ZBEAM = ZBEAM*0.9999
        ZCOFST = 0.5*(ZPLANE(NPLANE)+ZPLANE(1))
        ZSOFST = ZPLANE(1)-DISTZ
        RBEAM2 = RBEAM**2
        RCYL1 = RCYL(NR)
        RCYL2 = RCYL1**2
        DSTRH2 = DISTRH**2
        DISTZ2 = DISTZ**2
        DISTB = DISTZ-(ZPLANE(NPLANE)-ZPLANE(1))
        DISTB2 = DISTB**2
        AFACE = PI*RBEAM2
        ASIDE = 4.0*XBEAM*ZBEAM
        AINFLU = NCASET/(DSTRH2+(ZCOFST-ZSOFST)**2)
        IF ((DISTRH .LE. RCYL(NR))) THEN
          PROBSD = 0
          IF ((DISTZ .GE. 0.0)) THEN
            PROBFC = 1.0
            PROBBK = 0.0
          ELSE IF((DISTZ .LE. (ZPLANE(1)-ZPLANE(NPLANE)))) THEN
            PROBFC = 0.0
            PROBBK = 1.0
          END IF
        ELSE IF(((DISTZ .GE. (ZPLANE(1)-ZPLANE(NPLANE)) .AND. (DISTZ .LE
     *  . 0.0)))) THEN
          PROBFC = 0.0
          PROBBK = 0.0
          PROBSD = 1.0
        ELSE
          COTANG = ZSOFST/DISTRH
          IF ((COTANG .LT. 0.0)) THEN
            FACTOR = AFACE*ABS(COTANG)/ASIDE
            PROBSD = 1.0/(1.0+FACTOR)
            PROBFC = FACTOR/(1.0+FACTOR)
            PROBBK = 0.0
          ELSE
            FACTOR = AFACE*COTANG/ASIDE
            PROBSD = 1.0/(1.0+FACTOR)
            PROBBK = FACTOR/(1.0+FACTOR)
            PROBFC = 0.0
          END IF
        END IF
      ELSE IF((ISOURC .EQ. 15)) THEN
        call src15_oto(iout)
      ELSE IF((ISOURC .EQ. 16)) THEN
        call src16_oto(iout)
      ELSE IF((ISOURC .EQ. 17)) THEN
        XBEAM=XBEAM*0.9999
        YBEAM=YBEAM*0.9999
        DISTZ2=DISTZ**2
        DISTRH=0.0
        ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1))
        ZSOFST=ZPLANE(1)-DISTZ
        AFACE=4.0*XBEAM*YBEAM
        PROBFC=1.0
        AINFLU=FLOAT(NCASET)/DISTZ2
      ELSE IF((ISOURC .EQ. 13)) THEN
        RBEAM=RBEAM*0.9999
        XBEAM=XBEAM*0.9999
        ZBEAM=ZBEAM*0.9999
        RBEAM2=RBEAM**2
        RCYL1=RCYL(NR)
        RCYL2=RCYL1**2
        ZCOFST=0.5*(ZPLANE(1)+ZPLANE(NPLANE))
        AFACE=PI*RBEAM2
        ASIDE=4.0*XBEAM*ZBEAM
        WEIGHT=1.0
        AINFLU=NCASET/(ABS(WINC)*AFACE+SQRT(UINC**2+VINC**2)*ASIDE)
        IF ((WINC.EQ.1.0)) THEN
          PROBFC=1.0
          PROBSD=0.0
          PROBBK=0.0
        ELSE IF((WINC.EQ.0.0)) THEN
          PROBFC=0.0
          PROBSD=1.0
          PROBBK=0.0
        ELSE IF((WINC.EQ.-1.0)) THEN
          PROBFC=0.0
          PROBSD=0.0
          PROBBK=1.0
        ELSE
          IF ((WINC.LT.0.0)) THEN
            FACTOR=AFACE*ABS(WINC)/(ASIDE*SQRT(UINC**2+VINC**2))
            PROBFC=0.0
            PROBSD=1.0/(1.0+FACTOR)
            PROBBK=FACTOR/(1.0+FACTOR)
          ELSE
            FACTOR=AFACE*WINC/(ASIDE*SQRT(UINC**2+VINC**2))
            PROBFC=FACTOR/(1.0+FACTOR)
            PROBSD=1.0/(1.0+FACTOR)
            PROBBK=0.0
          END IF
        END IF
      ELSE IF((ISOURC .EQ. 14)) THEN
        RBEAM=RBEAM*0.9999
        RBEAM2=RBEAM**2
        RMINSQ=RMINBM**2
        DISTZ2=DISTZ**2
        DISTRH=0.0
        ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1))
        ZSOFST=ZPLANE(1)-DISTZ
        AFACE=PI*RBEAM**2
        PROBFC=1.0
        AINFLU=dble(NCASET)/DISTZ2
      ELSE IF((ISOURC .EQ. 20)) THEN
        RCDF(1)=0.5*RDISTF(1)**2*RPDF(1)
        DO 4651 IB=2,NRDIST
          RCDF(IB)=RCDF(IB-1)+0.5*(RDISTF(IB)**2-RDISTF(IB-1)**2)*RPDF(I
     *    B)
4651    CONTINUE
4652    CONTINUE
        FNORM=1./RCDF(NRDIST)
        IBNSOK=0
        GRIDSZ=1./dble(100)
        DO 4661 IB=1,NRDIST
          RCDF(IB)=FNORM*RCDF(IB)
          IF ((IB.EQ.1)) THEN
            IF((RCDF(1).LT.GRIDSZ))IBNSOK=1
          ELSE IF(((RCDF(IB)-RCDF(IB-1)).LT.GRIDSZ)) THEN
            IBNSOK=1.0
          END IF
4661    CONTINUE
4662    CONTINUE
        IF ((IBNSOK.NE.0)) THEN
          WRITE(6,4670)
4670      FORMAT(///' *******WARNING******'/ T15,'SOME OF NORMALIZED BIN
     * PROBABILITIES SO SMALL BINS MAY BE MISSED'/)
        END IF
        DO 4681 K=1,100
          AK=dble(K)*GRIDSZ
          DO 4691 I=1,NRDIST
            IRDIST=I
            IF ((AK.LE.RCDF(I))) THEN
              GOTO 4700
            END IF
4691      CONTINUE
4692      CONTINUE
          WRITE(6,4710)
4710      FORMAT(' *** FELL THROUGH RADIAL SAMPLING ROUTINE *** ')
4700      IF ((IRDIST.NE.1)) THEN
            RCDFIN(K,1)=RDISTF(IRDIST-1)**2
          ELSE
            RCDFIN(K,1)=0.0
          END IF
          RCDFIN(K,2)=RDISTF(IRDIST)**2-RCDFIN(K,1)
4681    CONTINUE
4682    CONTINUE
        IF ((IWATCH.NE.0)) THEN
          WRITE(6,4720)
4720      FORMAT(/' RDISTF,   RPDF,   RCDF:'//)
          WRITE(6,4730)(RDISTF(IB),RPDF(IB),RCDF(IB),IB=1,NRDIST)
4730      FORMAT(3E17.7)
          WRITE(6,4740)
4740      FORMAT(//)
        END IF
        WEIGHT=1.0
        AINFLU=dble(NCASET)/(PI*RDISTF(NRDIST)**2)
      ELSE IF(( ISOURC .EQ. 23 )) THEN
        AINFLU=dble(NCASET)
        WEIGHT=1.0
        IF (( chamber_c .GT. 1e4 .OR. chamber_c .LT. -1e4 )) THEN
          chamber_c = 0.5*(zplane(1) + zplane(nplane))
        END IF
      ELSE IF(((ISOURC .EQ. 21) .OR. (ISOURC .EQ. 22))) THEN
        AINFLU=dble(NCASET)
        WEIGHT=1.0
        IF (( chamber_c .GT. 1e4 .OR. chamber_c .LT. -1e4 )) THEN
          chamber_c = 0.5*(zplane(1) + zplane(nplane))
        END IF
        IF ((IPARALLEL.GT.1 .AND. PARNUM .GT. 0)) THEN
          IF ((IHSTRY.LT.NCASE_PHSP/IPARALLEL)) THEN
            NPHSPN=INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+IHSTRY
          ELSE
            tmp_mod = NCASE_PHSP
            NPHSPN=tmp_mod*(PARNUM-1)/IPARALLEL+ MOD(IHSTRY,tmp_mod/IPAR
     *      ALLEL)
          END IF
        ELSE
          IF ((IHSTRY.LT.NCASE_PHSP)) THEN
            NPHSPN = IHSTRY
          ELSE
            tmp_mod = NCASE_PHSP
            NPHSPN=MOD(IHSTRY,tmp_mod)
          END IF
        END IF
        IF ((i_iaea_in.EQ.1)) THEN
          iaea_dummy_long=NPHSPN+1
          call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result)
          IF ((iaea_result.LT.0)) THEN
            WRITE(i_log,*)' Error going to record ',NPHSPN+1,' in IAEA p
     *hsp file.'
            call exit(1)
          END IF
        END IF
      END IF
      RETURN
      ENTRY SRCOUT
      WRITE(IOUT,500)
      IF ((ISOURC .EQ. 0)) THEN
        WRITE(IOUT,510) RBEAM,UINC,VINC,WINC,AINFLU
      ELSE IF((ISOURC .EQ. 1)) THEN
        WRITE(IOUT,520) DISTZ,RBEAM,AINFLU
      ELSE IF((ISOURC .EQ. 2)) THEN
        WRITE(IOUT,560)
      ELSE IF((ISOURC .EQ. 3)) THEN
        WRITE(IOUT,570)RMINBM,RBEAM,ZSMIN,ZSMAX
      ELSE IF((ISOURC .EQ. 4)) THEN
        WRITE(IOUT,590) RBEAM
      ELSE IF((ISOURC .EQ. 10)) THEN
        WRITE(IOUT,530)XBEAM,ZBEAM
        IF((((XBEAM/0.9999).LT.RCYL(NR)).OR. ((ZBEAM/0.9999).LT.(0.5*(ZP
     *  LANE(NPLANE)-ZPLANE(1))))))WRITE(IOUT,550)
      ELSE IF((ISOURC .EQ. 11)) THEN
        WRITE(IOUT,540)DISTRH,XBEAM,ZBEAM
        IF(((XBEAM/0.9999.LT.(RCYL(NR)*SQRT(DISTRH**2-RCYL(NR)**2)/DISTR
     *  H)).OR. (ZBEAM/0.9999.LT.(0.5*(ZPLANE(NPLANE)-ZPLANE(1))))))WRIT
     *  E(IOUT,550)
      ELSE IF((ISOURC .EQ. 12)) THEN
        WRITE(IOUT,580)DISTRH,DISTZ
      ELSE IF((ISOURC .EQ. 15)) THEN
        call src15_describe(iout)
      ELSE IF((ISOURC .EQ. 16)) THEN
        call src16_describe(iout)
      ELSE IF((ISOURC .EQ. 17)) THEN
        WRITE(IOUT,535) DISTZ,XBEAM,YBEAM,AINFLU
      ELSE IF((ISOURC .EQ. 13)) THEN
        WRITE(IOUT,585) UINC,VINC,WINC,AINFLU
      ELSE IF((ISOURC .EQ. 14)) THEN
        WRITE(IOUT,525) DISTZ,RMINBM,RBEAM,AINFLU
      ELSE IF((ISOURC .EQ. 20)) THEN
        WRITE(IOUT,595)
        IF ((IOUTSP.EQ.1)) THEN
          WRITE(IOUT,610)NRDIST
          DO 4751 IB=1,NRDIST
            WRITE(IOUT,620)IB,RDISTF(IB),RPDF(IB),RCDF(IB)
4751      CONTINUE
4752      CONTINUE
        END IF
        IF((IBNSOK.NE.0.0))WRITE(IOUT,630)
      ELSE IF((ISOURC .EQ. 21)) THEN
        WRITE(IOUT,640) FILSPC,ZPLANE(1),AINFLU
      ELSE IF((ISOURC .EQ. 22)) THEN
        WRITE(IOUT,677) FILSPC,dist_phsp,theta_phsp,chamber_c, xoffset,y
     *  offset,AINFLU
      ELSE IF((ISOURC.EQ.23)) THEN
        WRITE(IOUT,679) iqinc,min_weight_23,max_weight_23, the_beam_code
     *  (:lnblnk1(the_beam_code)),the_pegs_file(:lnblnk1(the_pegs_file))
     *  , the_input_file(:lnblnk1(the_input_file)), dist_phsp,theta_phsp
     *  ,chamber_c,xoffset,yoffset,EKSRCM
      END IF
      IF ((ISOURC .EQ. 21 .OR. ISOURC .EQ. 22)) THEN
        WRITE(IOUT,4760) NCASE_PHSP,NPHOTPHSP,TEMP2,TEMP3,NINCSRC
4760    FORMAT(T15, ' Total number of particles in file      :',I10/ T15
     *, ' Total number of photons                :',I10/ T15, ' (the res
     *t are electrons and positrons)'// T15, ' Maximum kinetic energyof 
     *the particles:',F10.3,' MeV'/ T15, ' Minimum kinetic energy ofthe 
     *electrons:',F10.3,' MeV'/ T15, ' # particles incident when phase s
     *pace created :',F12.0/)
        IF ((DOSE_STAT.EQ.1)) THEN
          WRITE(IOUT,'(//'' ***WARNING***''/
     *                   '' Cannot read no. of primary (non-phsp) histor
     *ies from ph-sp source.''/        '' Dose and fluence will be analy
     *zed assuming each particle read from''/        '' the ph-sp file i
     *s an independent history.  May result in an''/               '' un
     *derestimate of uncertainties.''//)')
        END IF
        IF ((IPARALLEL.GT.1)) THEN
          IF ((PARNUM.GE.1 .AND. PARNUM.LE.IPARALLEL)) THEN
            WRITE(IOUT,'(/'' This is one of '',I4,'' parallel jobs.''/
     *                               '' It will use from particle '',I12
     *,'' to particle '',I12,/                     '' from the phase spa
     *ce source in the simulation.''/)') IPARALLEL,INT((PARNUM-1)*NCASE_
     *      PHSP/IPARALLEL)+1, INT(PARNUM*NCASE_PHSP/IPARALLEL)
          END IF
        END IF
        IF ((NRCYCL.GT.0)) THEN
          WRITE(IOUT,'(/'' Particles will be recycled '',
     *                              I4,'' times before moving on to next
     * one.''/)') NRCYCL
        END IF
      END IF
      RETURN
      ENTRY SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
      IF ((n_parallel.GT.0 .AND. (ISOURC.EQ.21 .OR. ISOURC.EQ.22))) THEN
        IF((N_RUN_CHUNK_OLD.EQ.0))P_PER_PHSP_CHUNK=NCASE_PHSP/(n_paralle
     *  l*10)
        N_RUN_CHUNK=(NCASE-N_LEFT)*n_parallel*10/NCASE
        other_num_1=N_RUN_CHUNK*NCASE
        other_num_2=(NCASE-N_LEFT)*n_parallel*10
        IF ((other_num_1.LT.other_num_2)) THEN
          N_RUN_CHUNK=N_RUN_CHUNK+1
        END IF
        IF ((N_RUN_CHUNK .NE. N_RUN_CHUNK_OLD)) THEN
          N_RUN_CHUNK_OLD=N_RUN_CHUNK
          NPHSPN_MIN=(N_RUN_CHUNK-1)*P_PER_PHSP_CHUNK+1
          IF ((N_LEFT.EQ.0)) THEN
            NPHSPN_MAX=NCASE_PHSP
          ELSE
            NPHSPN_MAX=NPHSPN_MIN+P_PER_PHSP_CHUNK-1
          END IF
          NPHSPN=NPHSPN_MIN-1
          IF ((i_iaea_in.EQ.1)) THEN
            iaea_dummy_long=NPHSPN+1
            call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result)
            IF ((iaea_result.LT.0)) THEN
              WRITE(i_log,*)' Error going to record ',NPHSPN+1,' in IAEA
     * phsp file.'
              call exit(1)
            END IF
          END IF
          CYCLNUM=0
          write(6,'(/a/,a,i12,a,i12/,a//)') '      This simulation uses
     *a phase space source.', '      This run will use from particle',NP
     *    HSPN_MIN,' to particle ', NPHSPN_MAX, '      in the source fil
     *e.'
        END IF
      END IF
      IF (((ISOURC .EQ. 0) .OR. (ISOURC .EQ. 2) .OR.(ISOURC .EQ. 4))) TH
     *EN
        IF ((RBEAM .EQ. 0.0)) THEN
          XIN=0.0
          YIN=0.0
          IRIN=2
        ELSE
4771      CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*RBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            YIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            YIN=(2.0*YIN-1.0)*RBEAM
            R2=XIN**2+YIN**2
            IF((R2.LE.RBEAM2))GO TO4772
          GO TO 4771
4772      CONTINUE
          DO 4781 IX=1,NR
            IXIN=IX
            IF((R2.LE.CYRAD2(IX)))GO TO4782
4781      CONTINUE
4782      CONTINUE
          IRIN=2+(IXIN-1)*NZ
        END IF
        ZIN=ZPLANE(1)
        IF ((IFPB .EQ. 0)) THEN
          UIN=0.0
          VIN=0.0
          WIN=1.0
        ELSE
          UIN=UINC
          VIN=VINC
          WIN=WINC
        END IF
        NRCFLG=10
        WEIGHT=1.0
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 1 .OR. ISOURC .EQ. 14)) THEN
4791    CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          XIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          XIN=(2.0*XIN-1.0)*RBEAM
          IF((rng_seed .GT. 128))call ranmar_get
          YIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          YIN=(2.0*YIN-1.0)*RBEAM
          R2=XIN**2+YIN**2
          IF((R2.LE.RBEAM2))GO TO4792
        GO TO 4791
4792    CONTINUE
        DO 4801 IX=1,NR
          IXIN=IX
          IF((R2.LE.CYRAD2(IX)))GO TO4802
4801    CONTINUE
4802    CONTINUE
        IRIN=2+(IXIN-1)*NZ
        ZIN=ZPLANE(1)
        IF ((ISOURC.EQ.14 .AND. R2.LE.RMINSQ)) THEN
          WEIGHT=0.0
        ELSE
          IF ((DISTRH.EQ.0.0)) THEN
            D=SQRT(R2+DISTZ**2)
          ELSE
            D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTZ**2)
          END IF
          UIN=XIN/D
          VIN=(YIN-DISTRH)/D
          WIN=DISTZ/D
          NRCFLG=10
          WEIGHT=AFACE*DISTZ/(D**3)/PROBFC
          SCOMEG=SCOMEG+WEIGHT
          SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
        END IF
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 3)) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        ZIN = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        ZIN=ZSOFST+(2.0*ZIN-1.0)*ZBEAM
        DO 4811 IZ=1,NPLANE-1
          IF((ZIN .LE. ZPLANE(IZ+1) .AND. ZIN .GE. ZPLANE(IZ)))GO TO4812
4811    CONTINUE
4812    CONTINUE
4821    CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          XIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          XIN=(2.0*XIN-1.0)*RBEAM
          IF((rng_seed .GT. 128))call ranmar_get
          YIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          YIN=(2.0*YIN-1.0)*RBEAM
          R2=XIN**2+YIN**2
          IF(((R2 .LE. RBEAM2 .AND. R2 .GE. RMINSQ)))GO TO4822
        GO TO 4821
4822    CONTINUE
        DO 4831 IX=1,NR
          IF((R2 .LE. CYRAD2(IX)))GO TO4832
4831    CONTINUE
4832    CONTINUE
        IRIN = IZ + NZ*(IX-1)+1
        IF((rng_seed .GT. 128))call ranmar_get
        COSTHE = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        COSTHE=2.*COSTHE-1
        SINTHE=SQRT(1.0-COSTHE**2)
        IF((rng_seed .GT. 128))call ranmar_get
        PHI = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        PHI=TWOPI*PHI
        UIN=SINTHE*COS(PHI)
        VIN=SINTHE*SIN(PHI)
        WIN=COSTHE
        NRCFLG=50
        WEIGHT=1.0
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 10)) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        XIN = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        XIN=(2.0*XIN-1.0)*XBEAM
        IF((rng_seed .GT. 128))call ranmar_get
        ZIN = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
        YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
        DO 4841 IZ=2,NPLANE
          IZ1=IZ
          IF((ZIN.LE.ZPLANE(IZ)))GO TO4842
4841    CONTINUE
4842    CONTINUE
        IRIN=(NR-1)*NZ+IZ1
        UIN=0.0
        VIN=-1.0
        WIN=0.0
        NRCFLG=20
        WEIGHT=1.0
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 11)) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        XIN = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        XIN=(2.0*XIN-1.0)*XBEAM
        IF((rng_seed .GT. 128))call ranmar_get
        ZIN = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
        YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
        DO 4851 IZ=2,NPLANE
          IZ1=IZ
          IF((ZIN.LE.ZPLANE(IZ)))GO TO4852
4851    CONTINUE
4852    CONTINUE
        IRIN=(NR-1)*NZ+IZ1
        D=SQRT(RCYL2+DSTRH2-2.0*DISTRH*YIN+(ZIN-ZSOFST)**2)
        UIN=XIN/D
        VIN=(YIN-DISTRH)/D
        WIN=(ZIN-ZSOFST)/D
        WEIGHT=ASIDE*(DISTRH-RCYL2/YIN)/(D**3)/PROBSD
        SCOMEG=SCOMEG+WEIGHT
        SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
        NRCFLG=20
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 12)) THEN
        IF ((PROBFC.EQ.1.0)) THEN
4861      CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*RBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            YIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            YIN=(2.0*YIN-1.0)*RBEAM
            R2=XIN**2+YIN**2
            IF((R2.LE.RBEAM2))GO TO4862
          GO TO 4861
4862      CONTINUE
          DO 4871 IX=1,NR
            IXIN=IX
            IF((R2.LE.CYRAD2(IX)))GO TO4872
4871      CONTINUE
4872      CONTINUE
          IRIN=2+(IXIN-1)*NZ
          ZIN=ZPLANE(1)
          IF ((ISOURC.EQ.14 .AND. R2.LE.RMINSQ)) THEN
            WEIGHT=0.0
          ELSE
            IF ((DISTRH.EQ.0.0)) THEN
              D=SQRT(R2+DISTZ**2)
            ELSE
              D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTZ**2)
            END IF
            UIN=XIN/D
            VIN=(YIN-DISTRH)/D
            WIN=DISTZ/D
            NRCFLG=10
            WEIGHT=AFACE*DISTZ/(D**3)/PROBFC
            SCOMEG=SCOMEG+WEIGHT
            SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
          END IF
        ELSE IF((PROBBK.EQ.1.0)) THEN
4881      CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*RBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            YIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            YIN=(2.0*YIN-1.0)*RBEAM
            R2=XIN**2+YIN**2
            IF((R2.LE.RBEAM2))GO TO4882
          GO TO 4881
4882      CONTINUE
          DO 4891 IX=1,NR
            IXIN=IX
            IF((R2.LE.CYRAD2(IX)))GO TO4892
4891      CONTINUE
4892      CONTINUE
          IRIN=1+IXIN*NZ
          ZIN=ZPLANE(NPLANE)
          IF ((DISTRH.EQ.0.0)) THEN
            D=SQRT(R2+DISTB2)
          ELSE
            D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTB2)
          END IF
          UIN=XIN/D
          VIN=(YIN-DISTRH)/D
          WIN=-DISTB/D
          NRCFLG=30
          WEIGHT=AFACE*DISTB/(D**3)/PROBBK
          SCOMEG=SCOMEG+WEIGHT
          SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
        ELSE IF((PROBSD.EQ.1.0)) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          XIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          XIN=(2.0*XIN-1.0)*XBEAM
          IF((rng_seed .GT. 128))call ranmar_get
          ZIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
          YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
          DO 4901 IZ=2,NPLANE
            IZ1=IZ
            IF((ZIN.LE.ZPLANE(IZ)))GO TO4902
4901      CONTINUE
4902      CONTINUE
          IRIN=(NR-1)*NZ+IZ1
          D=SQRT(RCYL2+DSTRH2-2.0*DISTRH*YIN+(ZIN-ZSOFST)**2)
          UIN=XIN/D
          VIN=(YIN-DISTRH)/D
          WIN=(ZIN-ZSOFST)/D
          WEIGHT=ASIDE*(DISTRH-RCYL2/YIN)/(D**3)/PROBSD
          SCOMEG=SCOMEG+WEIGHT
          SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
          NRCFLG=20
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          WHICH = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF ((WHICH.LE.PROBSD)) THEN
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*XBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            ZIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
            YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
            DO 4911 IZ=2,NPLANE
              IZ1=IZ
              IF((ZIN.LE.ZPLANE(IZ)))GO TO4912
4911        CONTINUE
4912        CONTINUE
            IRIN=(NR-1)*NZ+IZ1
            D=SQRT(RCYL2+DSTRH2-2.0*DISTRH*YIN+(ZIN-ZSOFST)**2)
            UIN=XIN/D
            VIN=(YIN-DISTRH)/D
            WIN=(ZIN-ZSOFST)/D
            WEIGHT=ASIDE*(DISTRH-RCYL2/YIN)/(D**3)/PROBSD
            SCOMEG=SCOMEG+WEIGHT
            SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
            NRCFLG=20
          ELSE IF((WHICH.LE.(PROBSD+PROBFC))) THEN
4921        CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              XIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              XIN=(2.0*XIN-1.0)*RBEAM
              IF((rng_seed .GT. 128))call ranmar_get
              YIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              YIN=(2.0*YIN-1.0)*RBEAM
              R2=XIN**2+YIN**2
              IF((R2.LE.RBEAM2))GO TO4922
            GO TO 4921
4922        CONTINUE
            DO 4931 IX=1,NR
              IXIN=IX
              IF((R2.LE.CYRAD2(IX)))GO TO4932
4931        CONTINUE
4932        CONTINUE
            IRIN=2+(IXIN-1)*NZ
            ZIN=ZPLANE(1)
            IF ((ISOURC.EQ.14 .AND. R2.LE.RMINSQ)) THEN
              WEIGHT=0.0
            ELSE
              IF ((DISTRH.EQ.0.0)) THEN
                D=SQRT(R2+DISTZ**2)
              ELSE
                D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTZ**2)
              END IF
              UIN=XIN/D
              VIN=(YIN-DISTRH)/D
              WIN=DISTZ/D
              NRCFLG=10
              WEIGHT=AFACE*DISTZ/(D**3)/PROBFC
              SCOMEG=SCOMEG+WEIGHT
              SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
            END IF
          ELSE
4941        CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              XIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              XIN=(2.0*XIN-1.0)*RBEAM
              IF((rng_seed .GT. 128))call ranmar_get
              YIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              YIN=(2.0*YIN-1.0)*RBEAM
              R2=XIN**2+YIN**2
              IF((R2.LE.RBEAM2))GO TO4942
            GO TO 4941
4942        CONTINUE
            DO 4951 IX=1,NR
              IXIN=IX
              IF((R2.LE.CYRAD2(IX)))GO TO4952
4951        CONTINUE
4952        CONTINUE
            IRIN=1+IXIN*NZ
            ZIN=ZPLANE(NPLANE)
            IF ((DISTRH.EQ.0.0)) THEN
              D=SQRT(R2+DISTB2)
            ELSE
              D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTB2)
            END IF
            UIN=XIN/D
            VIN=(YIN-DISTRH)/D
            WIN=-DISTB/D
            NRCFLG=30
            WEIGHT=AFACE*DISTB/(D**3)/PROBBK
            SCOMEG=SCOMEG+WEIGHT
            SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
          END IF
        END IF
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 15)) THEN
        call src15_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 16)) THEN
        call src16_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 17)) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        XIN = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        XIN=(2.0*XIN-1.0)*XBEAM
        IF((rng_seed .GT. 128))call ranmar_get
        YIN = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        YIN=(2.0*YIN-1.0)*YBEAM
        R2=XIN**2+YIN**2
        DO 4961 IX=1,NR
          IXIN=IX
          IF((R2.LE.CYRAD2(IX)))GO TO4962
4961    CONTINUE
4962    CONTINUE
        IRIN=2+(IXIN-1)*NZ
        ZIN=ZPLANE(1)
        IF ((DISTRH.EQ.0.0)) THEN
          D=SQRT(R2+DISTZ**2)
        ELSE
          D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTZ**2)
        END IF
        UIN=XIN/D
        VIN=(YIN-DISTRH)/D
        WIN=DISTZ/D
        NRCFLG=10
        WEIGHT=AFACE*DISTZ/(D**3)/PROBFC
        SCOMEG=SCOMEG+WEIGHT
        SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 13)) THEN
        UIN=UINC
        VIN=VINC
        WIN=WINC
        IF ((PROBFC.EQ.1.0)) THEN
4971      CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*RBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            YIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            YIN=(2.0*YIN-1.0)*RBEAM
            R2=XIN**2+YIN**2
            IF((R2.LE.RBEAM2))GO TO4972
          GO TO 4971
4972      CONTINUE
          DO 4981 IX=1,NR
            IXIN=IX
            IF((R2.LE.CYRAD2(IX)))GO TO4982
4981      CONTINUE
4982      CONTINUE
          IRIN=2+(IXIN-1)*NZ
          ZIN=ZPLANE(1)
          NRCFLG=10
        ELSE IF((PROBBK.EQ.1.0)) THEN
4991      CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*RBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            YIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            YIN=(2.0*YIN-1.0)*RBEAM
            R2=XIN**2+YIN**2
            IF((R2.LE.RBEAM2))GO TO4992
          GO TO 4991
4992      CONTINUE
          DO 5001 IX=1,NR
            IXIN=IX
            IF((R2.LE.CYRAD2(IX)))GO TO5002
5001      CONTINUE
5002      CONTINUE
          IRIN=1+IXIN*NZ
          ZIN=ZPLANE(NPLANE)
          NRCFLG=30
        ELSE IF((PROBSD.EQ.1.0)) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          XIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          XIN=(2.0*XIN-1.0)*XBEAM
          IF((rng_seed .GT. 128))call ranmar_get
          ZIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
          YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
          DO 5011 IZ=2,NPLANE
            IZ1=IZ
            IF((ZIN.LE.ZPLANE(IZ)))GO TO5012
5011      CONTINUE
5012      CONTINUE
          IRIN=(NR-1)*NZ+IZ1
          NRCFLG=20
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          WHICH = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF ((WHICH.LE.PROBSD)) THEN
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*XBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            ZIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
            YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
            DO 5021 IZ=2,NPLANE
              IZ1=IZ
              IF((ZIN.LE.ZPLANE(IZ)))GO TO5022
5021        CONTINUE
5022        CONTINUE
            IRIN=(NR-1)*NZ+IZ1
            NRCFLG=20
          ELSE IF((WHICH.LE.(PROBSD+PROBFC))) THEN
5031        CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              XIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              XIN=(2.0*XIN-1.0)*RBEAM
              IF((rng_seed .GT. 128))call ranmar_get
              YIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              YIN=(2.0*YIN-1.0)*RBEAM
              R2=XIN**2+YIN**2
              IF((R2.LE.RBEAM2))GO TO5032
            GO TO 5031
5032        CONTINUE
            DO 5041 IX=1,NR
              IXIN=IX
              IF((R2.LE.CYRAD2(IX)))GO TO5042
5041        CONTINUE
5042        CONTINUE
            IRIN=2+(IXIN-1)*NZ
            ZIN=ZPLANE(1)
            NRCFLG=10
          ELSE
5051        CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              XIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              XIN=(2.0*XIN-1.0)*RBEAM
              IF((rng_seed .GT. 128))call ranmar_get
              YIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              YIN=(2.0*YIN-1.0)*RBEAM
              R2=XIN**2+YIN**2
              IF((R2.LE.RBEAM2))GO TO5052
            GO TO 5051
5052        CONTINUE
            DO 5061 IX=1,NR
              IXIN=IX
              IF((R2.LE.CYRAD2(IX)))GO TO5062
5061        CONTINUE
5062        CONTINUE
            IRIN=1+IXIN*NZ
            ZIN=ZPLANE(NPLANE)
            NRCFLG=30
          END IF
        END IF
        WEIGHT=1.0
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 20)) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO1 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO2 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        K=MIN(dble(100)*RNNO1+1.,dble(100))
        XIN=SQRT(RCDFIN(K,1)+RNNO2*RCDFIN(K,2))
        YIN=0.0
        ZIN=ZPLANE(1)
        DO 5071 IX=1,NR
          IXIN=IX
          IF((XIN.LE.RCYL(IX)))GO TO5072
5071    CONTINUE
5072    CONTINUE
        IRIN=2+(IXIN-1)*NZ
        WIN=1.0
        UIN=0.0
        VIN=0.0
        NRCFLG=10
        WEIGHT=1.0
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 21)) THEN
        IF ((NRCYCL.GT.0 .AND. CYCLNUM.GT.0 .AND. CYCLNUM.LE.NRCYCL)) TH
     *  EN
          CYCLNUM=CYCLNUM+1
          XIN=XINOLD
          YIN=YINOLD
          ZIN=ZINOLD
          UIN=UINOLD
          VIN=VINOLD
          WIN=WINOLD
          IRIN=IRINOLD
          NRCFLG=NRCFLGOLD
          WEIGHT=WEIGHTOLD
          NNREAD=NNREAD+1
        ELSE
5080      CONTINUE
          NPHSPN=NPHSPN+1
          IF ((IPARALLEL.GT.1 .AND. PARNUM.GT.0 .AND. NPHSPN .GT. INT(PA
     *    RNUM*NCASE_PHSP/IPARALLEL))) THEN
            NPHSPN=INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+1
            OUTCNT=OUTCNT+1
            WRITE(6,5090)
5090        FORMAT(' ***WARNING*** Used all particles from partition ins
     *ource file.'/ '               Restarting from first particle in pa
     *rtition.')
            WRITE(IOUT, '('' ***WARNING*** Used all particles from parti
     *tion in source file.''/           ''               Restarting from
     * first particle in partition.'')')
            IF ((i_iaea_in.EQ.1)) THEN
              NHSTRY=OUTCNT*NINCSRC/IPARALLEL
              iaea_dummy_long=NPHSPN
              call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result
     *        )
              IF ((iaea_result.LT.0)) THEN
                WRITE(i_log,*)' Error going to record ',NPHSPN,' in IAEA
     * phsp file.'
                call exit(1)
              END IF
            END IF
          ELSE IF((n_parallel.GT.0 .AND. NPHSPN.GT.NPHSPN_MAX)) THEN
            NPHSPN=NPHSPN_MIN
            OUTCNT=OUTCNT+1
            WRITE(6,5100)
5100        FORMAT(///' ***WARNING*** USED ALL PARTICLES FROM CHUNK IN S
     *OURCE FILE!'/ '               RESTARTING FROM FIRST PARTICLE IN TH
     *IS CHUNK.'// /1x,79('*')//)
            IF ((i_iaea_in.EQ.1)) THEN
              NHSTRY=OUTCNT*NINCSRC/(n_parallel*10)
              iaea_dummy_long=NPHSPN
              call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result
     *        )
              IF ((iaea_result.LT.0)) THEN
                WRITE(i_log,*)' Error going to record ',NPHSPN,' in IAEA
     * phsp file.'
                call exit(1)
              END IF
            END IF
          ELSE IF((NPHSPN.GT.NCASE_PHSP)) THEN
            NPHSPN=1
            OUTCNT=OUTCNT+1
            WRITE(6,5110)
5110        FORMAT(' ***WARNING*** Used all particles from source file.'
     */ '               Restarting from first particle.')
            WRITE(IOUT, '('' ***WARNING*** Used all particles from sourc
     *e file.''/                        ''               Restarting from
     * first particle.'')')
            IF ((i_iaea_in.EQ.1)) THEN
              NHSTRY=OUTCNT*NINCSRC
              iaea_dummy_long=NPHSPN
              call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result
     *        )
              IF ((iaea_result.LT.0)) THEN
                WRITE(i_log,*)' Error going to record ',NPHSPN,' in IAEA
     * phsp file.'
                call exit(1)
              END IF
            END IF
          END IF
          IF ((OUTCNT.GT.1000)) THEN
            WRITE(6,5120)
5120        FORMAT(' ***ERROR*** >1000 restart warnings.')
            WRITE(IOUT, '('' ***ERROR*** >1000 restart warnings.'')')
            STOP
          END IF
          IF ((i_iaea_in.EQ.1)) THEN
            NPASS=0
            call iaea_get_particle(i_unit_in,iaea_n_stat,iaea_q_index,ES
     *      HORT,WT_PHSP_SHORT, X_PHSP_SHORT,Y_PHSP_SHORT,Z_PHSP_SHORT,U
     *      _PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,iaea_extra_floats,iae
     *      a_extra_ints)
            IF ((iaea_n_stat.EQ.-1)) THEN
              WRITE(i_log,*)' Error getting particle data from IAEA phsp
     * file.'
              call exit(1)
            ELSE IF((iaea_n_stat.EQ.-2)) THEN
              WRITE(i_log,*)' WARNING: Reached end of IAEA phsp file.  F
     *ile restarted.'
            ELSE IF((iaea_n_stat.GE.0)) THEN
              NHSTRY=NHSTRY+iaea_n_stat
              IF ((iaea_i_latch.EQ.-99)) THEN
                LATCHI=0
              ELSE
                LATCHI=iaea_extra_ints(iaea_i_latch)
              END IF
              IQIN=iaea_typ_q(iaea_q_index)
              IF (( (IQIN.EQ.1) .OR. (IQIN.EQ.-1) )) THEN
                ESHORT = ESHORT + 0.5109989461
              END IF
              EIN=ESHORT
              IF ((iaea_i_zlast.EQ.-99)) THEN
                ZLAST_PHSP_SHORT=0
              ELSE
                ZLAST_PHSP_SHORT= iaea_extra_floats(iaea_i_zlast)
              END IF
              IF ((iaea_i_muidx.EQ.-99)) THEN
                MUIDX_PHSP_SHORT=0
              ELSE
                MUIDX_PHSP_SHORT= iaea_extra_floats(iaea_i_muidx)
              END IF
              WEIGHT=WT_PHSP_SHORT
              XIN=X_PHSP_SHORT
              YIN=Y_PHSP_SHORT
              ZIN=Z_PHSP_SHORT
              UIN=U_PHSP_SHORT
              VIN=V_PHSP_SHORT
              WIN=W_PHSP_SHORT
              ZLAST=ZLAST_PHSP_SHORT
              MUIDX=MUIDX_PHSP_SHORT
            END IF
          ELSE
            IF ((IMODE.NE.0)) THEN
              READ(42,REC=NPHSPN+1,IOSTAT=IERR_PHSP) LATCHI,ESHORT,X_PHS
     *        P_SHORT,Y_PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SH
     *        ORT,ZLAST_PHSP_SHORT
            ELSE
              READ(42,REC=NPHSPN+1,IOSTAT=IERR_PHSP) LATCHI,ESHORT,X_PHS
     *        P_SHORT,Y_PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SH
     *        ORT
            END IF
            IF ((NPHSPN+1.EQ.76695869)) THEN
              write(*,*)' x,y,u,v,wt,eshort,latch', X_PHSP_SHORT,Y_PHSP_
     *        SHORT,U_PHSP_SHORT,V_PHSP_SHORT, WT_PHSP_SHORT,ESHORT,LATC
     *        HI
            END IF
            IF ((ESHORT.LT.0.0)) THEN
              NHSTRY=NHSTRY+1
              ESHORT=ABS(ESHORT)
            END IF
            EIN=ESHORT
            WEIGHT=WT_PHSP_SHORT
            XIN=X_PHSP_SHORT
            YIN=Y_PHSP_SHORT
            UIN=U_PHSP_SHORT
            VIN=V_PHSP_SHORT
            IF((IMODE.NE.0))ZLAST=ZLAST_PHSP_SHORT
            IF ((IERR_PHSP.EQ.0)) THEN
              EIN=ESHORT
              IF ((btest(LATCHI, 31))) THEN
                NPASS = 1
                LATCHI = ibclr(LATCHI,31)
              ELSE
                NPASS = 0
              END IF
              IF ((btest(LATCHI, 30))) THEN
                IQIN = -1
                LATCHI = ibclr(LATCHI,30)
                LATCHI = ibclr(LATCHI,29)
              ELSE
                IF ((btest(LATCHI, 29))) THEN
                  IQIN = 1
                  LATCHI = ibclr(LATCHI,29)
                ELSE
                  IQIN = 0
                END IF
              END IF
              WIN = min( 1., UIN**2 + VIN**2)
              WIN = sqrt(1. - WIN)
              WIN = SIGN(WIN,WEIGHT)
              WEIGHT=ABS(WEIGHT)
            END IF
          END IF
          NNREAD=NNREAD+1
          IF((DOSE_STAT.EQ.1 .OR. NHSTRY.EQ.0))NHSTRY=NHSTRY+1
          IF((NPASS.EQ.1))GOTO 5080
          IF ((IQIN .EQ.-1 .AND. IQINC.NE.-1 .AND. IQINC.NE.2 .AND. IQIN
     *    C .NE.3)) THEN
            GOTO 5080
          END IF
          IF ((IQIN .EQ. 1 .AND. IQINC.NE. 1 .AND. IQINC.NE.2 .AND. IQIN
     *    C .NE.3)) THEN
            GOTO 5080
          END IF
          IF ((IQIN .EQ. 0 .AND. IQINC.NE. 0 .AND. IQINC.NE.2)) THEN
            GOTO 5080
          END IF
          R2 = XIN**2 +YIN**2
          IF ((R2 .GT. CYRAD2(NR))) THEN
            GOTO 5080
          END IF
          DO 5131 IX=1,NR
            IXIN=IX
            IF((R2 .LE. CYRAD2(IX)))GO TO5132
5131      CONTINUE
5132      CONTINUE
          IRIN=2+(IXIN-1)*NZ
          ZIN=ZPLANE(1)
          NRCFLG = 10
          IF ((NRCYCL.GT.0)) THEN
            CYCLNUM=1
            XINOLD=XIN
            YINOLD=YIN
            ZINOLD=ZIN
            UINOLD=UIN
            VINOLD=VIN
            WINOLD=WIN
            IRINOLD=IRIN
            NRCFLGOLD=NRCFLG
            WEIGHTOLD=WEIGHT
          END IF
        END IF
      ELSE IF(( ISOURC .EQ. 23 )) THEN
5141    CONTINUE
5150      CONTINUE
          call sample_beamsource(ein,xin,yin,zin,uin,vin,win,weight,iqin
     *    ,latchi, nhstry,iphatin)
          IF((iqinc .LT. 2 .AND. iqin .NE. iqinc))goto 5150
          IF((iqinc .EQ. 3 .AND. iqin .EQ. 0))goto 5150
          IF (( weight .LT. min_weight_23 .OR. weight .GT. max_weight_23
     *     )) THEN
            goto 5150
          END IF
          IF (( secret_option_23 .EQ. 1 )) THEN
            IF (( xin .GT. 0 )) THEN
              xin = -xin
              uin = -uin
            END IF
          END IF
          xin_tmp = xin
          yin_tmp = yin
          zin_tmp = zin
          xin=xin+xoffset
          yin=yin+yoffset
          zin = -dist_phsp*cost_phsp + yin*sint_phsp + chamber_c
          yin = dist_phsp*sint_phsp + yin*cost_phsp
          vtemp = vin
          vin = -win*sint_phsp + vin*cost_phsp
          win = win*cost_phsp + vtemp*sint_phsp
          radp = xin*xin + yin*yin
          IF (( radp .GT. CYRAD2(nr) .OR. zin .LT. zplane(1) .OR. zin .G
     *    T. zplane(nz+1) )) THEN
            check = .true.
            IF (( zin .LT. zplane(1) .AND. win .GT. 0 )) THEN
              tf = (zplane(1)-zin)/win
            ELSE IF(( zin .GT. zplane(nz+1) .AND. win .LT. 0 )) THEN
              tf = (zplane(nz+1) - zin)/win
            ELSE
              check = .false.
            END IF
            IF (( check )) THEN
              xtmp = xin + uin*tf
              ytmp = yin + vin*tf
              radp = xtmp*xtmp + ytmp*ytmp
              IF (( radp .LE. CYRAD2(nr) )) THEN
                xin = xtmp
                yin = ytmp
                IF (( zin .LT. zplane(1) )) THEN
                  zin = zplane(1)
                  iz = 1
                ELSE
                  zin = zplane(nz+1)
                  iz = nz
                END IF
                DO 5161 ix=1,nr
                  IF((radp .LE. CYRAD2(ix)))GO TO5162
5161            CONTINUE
5162            CONTINUE
                GO TO5142
              END IF
              radp = xin*xin + yin*yin
            END IF
            IF((radp .LT. CYRAD2(nr)))GO TO5141
            phbb = uin*uin + vin*vin
            IF((phbb .LT. 1e-15))GO TO5141
            pha = (xin*uin + yin*vin)/phbb
            IF((pha .GT. 0))GO TO5141
            phb = (radp - CYRAD2(nr))/phbb
            phd = pha*pha - phb
            IF((phd .LT. 0))GO TO5141
            tf = -pha-sqrt(phd)
            IF((tf .LT. 0))GO TO5141
            zin = zin + tf*win
            IF((zin .LT. zplane(1) .OR. zin .GT. zplane(nz+1)))GO TO5141
            ix = nr
            xin = xin + uin*tf
            yin = yin + vin*tf
            DO 5171 iz=2,nplane
              IF((zin .LE. zplane(iz)))GO TO5172
5171        CONTINUE
5172        CONTINUE
            iz = iz-1
            GO TO5142
          ELSE
            DO 5181 iz=2,nplane
              IF((zin .LE. zplane(iz)))GO TO5182
5181        CONTINUE
5182        CONTINUE
            iz = iz-1
            DO 5191 ix=1,nr
              IF((radp .LE. CYRAD2(ix)))GO TO5192
5191        CONTINUE
5192        CONTINUE
            GO TO5142
          END IF
        GO TO 5141
5142    CONTINUE
        irin = 1 + (ix-1)*nz + iz
        ihstry = ihstry + nhstry - last_nhstry
        last_nhstry = nhstry
      ELSE IF((ISOURC .EQ. 22)) THEN
        IF ((NRCYCL.GT.0 .AND. CYCLNUM.GT.0 .AND. CYCLNUM.LE.NRCYCL)) TH
     *  EN
          CYCLNUM=CYCLNUM+1
          XIN=XINOLD
          YIN=YINOLD
          ZIN=ZINOLD
          UIN=UINOLD
          VIN=VINOLD
          WIN=WINOLD
          IRIN=IRINOLD
          NRCFLG=NRCFLGOLD
          WEIGHT=WEIGHTOLD
          NNREAD=NNREAD+1
        ELSE
5200      CONTINUE
          NPHSPN=NPHSPN+1
          IF ((IPARALLEL.GT.1 .AND. PARNUM.GT.0 .AND. NPHSPN .GT. INT(PA
     *    RNUM*NCASE_PHSP/IPARALLEL))) THEN
            NPHSPN=INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+1
            OUTCNT=OUTCNT+1
            WRITE(6,5210)
5210        FORMAT(' ***WARNING*** Used all particles from partition ins
     *ource file.'/ '               Restarting from first particle in pa
     *rtition.')
            WRITE(IOUT, '('' ***WARNING*** Used all particles from parti
     *tion in source file.''/           ''               Restarting from
     * first particle in partition.'')')
            IF ((i_iaea_in.EQ.1)) THEN
              NHSTRY=OUTCNT*NINCSRC/IPARALLEL
              iaea_dummy_long=NPHSPN
              call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result
     *        )
              IF ((iaea_result.LT.0)) THEN
                WRITE(i_log,*)' Error going to record ',NPHSPN,' in IAEA
     * phsp file.'
                call exit(1)
              END IF
            END IF
          ELSE IF((n_parallel.GT.0 .AND. NPHSPN.GT.NPHSPN_MAX)) THEN
            NPHSPN=NPHSPN_MIN
            OUTCNT=OUTCNT+1
            WRITE(6,5220)
5220        FORMAT(///' ***WARNING*** USED ALL PARTICLES FROM CHUNK IN S
     *OURCE FILE!'/ '               RESTARTING FROM FIRST PARTICLE IN TH
     *IS CHUNK.'// /1x,79('*')//)
            IF ((i_iaea_in.EQ.1)) THEN
              NHSTRY=OUTCNT*NINCSRC/(n_parallel*10)
              iaea_dummy_long=NPHSPN
              call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result
     *        )
              IF ((iaea_result.LT.0)) THEN
                WRITE(i_log,*)' Error going to record ',NPHSPN,' in IAEA
     * phsp file.'
                call exit(1)
              END IF
            END IF
          ELSE IF((NPHSPN.GT.NCASE_PHSP)) THEN
            NPHSPN=1
            OUTCNT=OUTCNT+1
            WRITE(6,5230)
5230        FORMAT(' ***WARNING*** Used all particles from source file.'
     */ '               Restarting from first particle.')
            WRITE(IOUT, '('' ***WARNING*** Used all particles from sourc
     *e file.''/                        ''               Restarting from
     * first particle.'')')
            IF ((i_iaea_in.EQ.1)) THEN
              NHSTRY=OUTCNT*NINCSRC
              iaea_dummy_long=NPHSPN
              call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result
     *        )
              IF ((iaea_result.LT.0)) THEN
                WRITE(i_log,*)' Error going to record ',NPHSPN,' in IAEA
     * phsp file.'
                call exit(1)
              END IF
            END IF
          END IF
          IF ((OUTCNT.GT.1000)) THEN
            WRITE(6,5240)
5240        FORMAT(' ***ERROR*** >1000 restart warnings.')
            WRITE(IOUT, '('' ***ERROR*** >1000 restart warnings.'')')
            STOP
          END IF
          IF ((i_iaea_in.EQ.1)) THEN
            NPASS=0
            call iaea_get_particle(i_unit_in,iaea_n_stat,iaea_q_index,ES
     *      HORT,WT_PHSP_SHORT, X_PHSP_SHORT,Y_PHSP_SHORT,Z_PHSP_SHORT,U
     *      _PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,iaea_extra_floats,iae
     *      a_extra_ints)
            IF ((iaea_n_stat.EQ.-1)) THEN
              WRITE(i_log,*)' Error getting particle data from IAEA phsp
     * file.'
              call exit(1)
            ELSE IF((iaea_n_stat.EQ.-2)) THEN
              WRITE(i_log,*)' WARNING: Reached end of IAEA phsp file.  F
     *ile restarted.'
            ELSE IF((iaea_n_stat.GE.0)) THEN
              NHSTRY=NHSTRY+iaea_n_stat
              IF ((iaea_i_latch.EQ.-99)) THEN
                LATCHI=0
              ELSE
                LATCHI=iaea_extra_ints(iaea_i_latch)
              END IF
              IQIN=iaea_typ_q(iaea_q_index)
              IF (( (IQIN.EQ.1) .OR. (IQIN.EQ.-1) )) THEN
                ESHORT = ESHORT + 0.5109989461
              END IF
              EIN=ESHORT
              IF ((iaea_i_zlast.EQ.-99)) THEN
                ZLAST_PHSP_SHORT=0
              ELSE
                ZLAST_PHSP_SHORT= iaea_extra_floats(iaea_i_zlast)
              END IF
              IF ((iaea_i_muidx.EQ.-99)) THEN
                MUIDX_PHSP_SHORT=0
              ELSE
                MUIDX_PHSP_SHORT= iaea_extra_floats(iaea_i_muidx)
              END IF
              WEIGHT=WT_PHSP_SHORT
              XIN=X_PHSP_SHORT
              YIN=Y_PHSP_SHORT
              ZIN=Z_PHSP_SHORT
              UIN=U_PHSP_SHORT
              VIN=V_PHSP_SHORT
              WIN=W_PHSP_SHORT
              ZLAST=ZLAST_PHSP_SHORT
              MUIDX=MUIDX_PHSP_SHORT
            END IF
          ELSE
            IF ((IMODE.NE.0)) THEN
              READ(42,REC=NPHSPN+1,IOSTAT=IERR_PHSP) LATCHI,ESHORT,X_PHS
     *        P_SHORT,Y_PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SH
     *        ORT,ZLAST_PHSP_SHORT
            ELSE
              READ(42,REC=NPHSPN+1,IOSTAT=IERR_PHSP) LATCHI,ESHORT,X_PHS
     *        P_SHORT,Y_PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SH
     *        ORT
            END IF
            IF ((NPHSPN+1.EQ.76695869)) THEN
              write(*,*)' x,y,u,v,wt,eshort,latch', X_PHSP_SHORT,Y_PHSP_
     *        SHORT,U_PHSP_SHORT,V_PHSP_SHORT, WT_PHSP_SHORT,ESHORT,LATC
     *        HI
            END IF
            IF ((ESHORT.LT.0.0)) THEN
              NHSTRY=NHSTRY+1
              ESHORT=ABS(ESHORT)
            END IF
            EIN=ESHORT
            WEIGHT=WT_PHSP_SHORT
            XIN=X_PHSP_SHORT
            YIN=Y_PHSP_SHORT
            UIN=U_PHSP_SHORT
            VIN=V_PHSP_SHORT
            IF((IMODE.NE.0))ZLAST=ZLAST_PHSP_SHORT
            IF ((IERR_PHSP.EQ.0)) THEN
              EIN=ESHORT
              IF ((btest(LATCHI, 31))) THEN
                NPASS = 1
                LATCHI = ibclr(LATCHI,31)
              ELSE
                NPASS = 0
              END IF
              IF ((btest(LATCHI, 30))) THEN
                IQIN = -1
                LATCHI = ibclr(LATCHI,30)
                LATCHI = ibclr(LATCHI,29)
              ELSE
                IF ((btest(LATCHI, 29))) THEN
                  IQIN = 1
                  LATCHI = ibclr(LATCHI,29)
                ELSE
                  IQIN = 0
                END IF
              END IF
              WIN = min( 1., UIN**2 + VIN**2)
              WIN = sqrt(1. - WIN)
              WIN = SIGN(WIN,WEIGHT)
              WEIGHT=ABS(WEIGHT)
            END IF
          END IF
          NNREAD=NNREAD+1
          IF((DOSE_STAT.EQ.1 .OR. NHSTRY.EQ.0))NHSTRY=NHSTRY+1
          IF((NPASS.EQ.1))GOTO 5200
          IF ((IQIN.EQ.-1 .AND. IQINC.NE.-1 .AND. IQINC.NE.2 .AND. IQINC
     *     .NE.3)) THEN
            GOTO 5200
          END IF
          IF ((IQIN.EQ. 1 .AND. IQINC.NE. 1 .AND. IQINC.NE.2 .AND. IQINC
     *     .NE.3)) THEN
            GOTO 5200
          END IF
          IF ((IQIN.EQ. 0 .AND. IQINC.NE. 0 .AND. IQINC.NE.2)) THEN
            GOTO 5200
          END IF
          xin=xin+xoffset
          yin=yin+yoffset
          zin = -dist_phsp*cost_phsp + yin*sint_phsp + chamber_c
          yin = dist_phsp*sint_phsp + yin*cost_phsp
          vtemp = vin
          vin = -win*sint_phsp + vin*cost_phsp
          win = win*cost_phsp + vtemp*sint_phsp
          radp = xin*xin + yin*yin
          IF (( radp .GT. CYRAD2(nr) .OR. zin .LT. zplane(1) .OR. zin .G
     *    T. zplane(nz+1) )) THEN
            check = .true.
            IF (( zin .LT. zplane(1) .AND. win .GT. 0 )) THEN
              tf = (zplane(1)-zin)/win
            ELSE IF(( zin .GT. zplane(nz+1) .AND. win .LT. 0 )) THEN
              tf = (zplane(nz+1) - zin)/win
            ELSE
              check = .false.
            END IF
            IF (( check )) THEN
              xtmp = xin + uin*tf
              ytmp = yin + vin*tf
              radp = xtmp*xtmp + ytmp*ytmp
              IF (( radp .LE. CYRAD2(nr) )) THEN
                xin = xtmp
                yin = ytmp
                IF (( zin .LT. zplane(1) )) THEN
                  zin = zplane(1)
                  iz = 1
                ELSE
                  zin = zplane(nz+1)
                  iz = nz
                END IF
                DO 5251 ix=1,nr
                  IF((radp .LE. CYRAD2(ix)))GO TO5252
5251            CONTINUE
5252            CONTINUE
                goto 5260
              END IF
              radp = xin*xin + yin*yin
            END IF
            IF((radp .LT. CYRAD2(nr)))goto 5200
            phbb = uin*uin + vin*vin
            IF((phbb .LT. 1e-15))goto 5200
            pha = (xin*uin + yin*vin)/phbb
            IF((pha .GT. 0))goto 5200
            phb = (radp - CYRAD2(nr))/phbb
            phd = pha*pha - phb
            IF((phd .LT. 0))goto 5200
            tf = -pha-sqrt(phd)
            IF((tf .LT. 0))goto 5200
            zin = zin + tf*win
            IF((zin .LT. zplane(1) .OR. zin .GT. zplane(nz+1)))goto 5200
            ix = nr
            xin = xin + uin*tf
            yin = yin + vin*tf
            DO 5271 iz=2,nplane
              IF((zin .LE. zplane(iz)))GO TO5272
5271        CONTINUE
5272        CONTINUE
            iz = iz-1
            goto 5260
          END IF
          DO 5281 iz=2,nplane
            IF((zin .LE. zplane(iz)))GO TO5282
5281      CONTINUE
5282      CONTINUE
          iz = iz-1
          DO 5291 ix=1,nr
            IF((radp .LE. CYRAD2(ix)))GO TO5292
5291      CONTINUE
5292      CONTINUE
5260      count_phsp = count_phsp + 1
          irin = 1 + (ix-1)*nz + iz
          NRCFLG = 20
          IF ((NRCYCL.GT.0)) THEN
            CYCLNUM=1
            XINOLD=XIN
            YINOLD=YIN
            ZINOLD=ZIN
            UINOLD=UIN
            VINOLD=VIN
            WINOLD=WIN
            IRINOLD=IRIN
            NRCFLGOLD=NRCFLG
            WEIGHTOLD=WEIGHT
          END IF
        END IF
      END IF
      RETURN
      ENTRY SRCEND
      IF (( ISOURC .EQ. 23 )) THEN
        call finish_beamsource
      END IF
      return
100   FORMAT(' ',2(I2,' '),4(G14.7,' '))
200   FORMAT(' ',I1)
300   FORMAT(' ',I3)
400   FORMAT(' ',2(G14.7,' '))
500   FORMAT(/' ',79('*')//T30,'SOURCE PARAMETERS'//' ',79('*')/)
510   FORMAT(T20,'Parallel beam on front face, radius=',F8.3,'cm'/T30,' 
     *X-axis direction cosine=',F10.4/T30,' Y-axis direction cosine=',F1
     *0.4/T30,' Z-axis direction cosine=',F10.4/T30,' Incident fluence='
     *, 1PE13.3,'/cm**2')
520   FORMAT(T5,'Point source on cyl axis',F8.1,' cm away, collimated to
     * R =',F8.3,' cm',/T5,'Incident fluence(at front face on axis) * ',
     *'Solid angle=',1PE14.3)
525   FORMAT(T5,'Point source on cyl axis',F8.1,' cm away'/T10,'Collimat
     *ed to radii =',F8.3,' cm to ',F8.3,' cm',/T5,'Incident fluence(at 
     *front face on axis) * ','SOLID ANGLE=',1PE14.3)
530   FORMAT(T20,'PARALLEL BEAM INCIDENT ON CYLINDRICAL WALL',/T21,'RADI
     *AL DIMENSION=',F8.3,' cm, HALF-LENGTH=',F8.3,' cm')
535   FORMAT(T5,'Point source on cyl axis',F8.1,' cm away'/T10,'Collimat
     *ed to x =',F8.3,' cm, y = ',F8.3,' cm',/T5,'Incident fluence(at fr
     *ont face on axis) * ','SOLID ANGLE=',1PE14.3)
540   FORMAT(T20,'POINT SOURCE INCIDENT FROM SIDE',F8.1,' cm',' FROM MID
     *-POINT'/T25,'RADIAL DIMENSION=',F8.3,' cm',' HALF-LENGTH=',F8.3,' 
     *cm')
550   FORMAT(/T30,'NOTE BEAM DOES NOT COVER THE DETECTOR'/T30,37('*') )
560   FORMAT(' ',T20,'BROAD PARALLEL BEAM ON CYLINDRICAL AXIS')
570   FORMAT(T10,'ISOTROPICALLY RADIATING, UNIFORM SOURCE LOCATED'/'    
     *  between radii',2F10.3,' and DEPTHS', 2F10.3)
580   FORMAT(' ',T20,'POINT SOURCE OFF AXIS, RADIAL COORDINATE ',F8.3,' 
     *cm'/' ',T20,'PERPENDICULAR DISTANCE OF SOURCE FROM FRONT FACE ',F8
     *.3,' cm')
585   FORMAT(T20,'BROAD PARALLEL BEAM FROM ANY ANGLE'/T30,' X-AXIS DIREC
     *TION COSINE=',F10.4/T30,' Y-AXIS DIRECTION COSINE=',F10.4/T30,' Z-
     *AXIS DIRECTION COSINE=',F10.4/T30,' INCIDENT FLUENCE=', 1PE13.3,'/
     *cm**2')
590   FORMAT(' ',T23,'CENTRAL AXIS FLUENCE VS BEAM RADIUS'/T25,'CENTRAL 
     *AXIS RADIUS=',F9.4,' cm'//12X,'  TREAT RADIAL BINS AS BEAM RADIUS,
     * NOT SCORING REGION RADIUS'/)
595   FORMAT(' ',T20,'RADIAL DISTRIBUTION, FRONTAL PARELLEL BEAM'/)
605   FORMAT(80A1)
600   FORMAT(27A1)
610   FORMAT(' ',T20,'RADIAL DISTBN, # OF INCIDENT RADIAL BINS:',T60,I5/
     *' ',T20,'BIN    KINETIC RADIAL     PROBABILITY  CUMULATIVE PROB')
620   FORMAT(' ',T20,I3,T28,F7.3,T45,1PE10.3,T60,0PF7.4)
630   FORMAT(/' *******WARNING******'/T20,'SOME OF NORMALIZED BIN',' PRO
     *BABILITIES SO SMALL BINS MAY BE MISSED'/)
640   FORMAT(T20,'Full phase space input for each incident particle. '/T
     *5,' Source data file: ',256A1/T25,' Source incident on front face,
     * Z =',F14.4,' cm.'/T25,' # of particles read from ph-sp file =', 1
     *PE13.3,'.')
642   FORMAT(T20,'Full phase space input for each incident particle. '/T
     *5,' Source data file: ',80A1/T25,' Source incident on plane, Y =',
     *F14.4,' cm.'/T25,' Centre of source plane at Z =',F14.4,' cm.'/T25
     *,' # of particles read from ph-sp file =', 1PE13.3,'.')
650   FORMAT(I1,1X,I7,1X,F5.0,1X,2(F4.0,1X),F1.0,1X,2(F10.8,1X),E10.4)
660   FORMAT(40A1/22A1/80A1/I10,3X,3F6.0/)
670   FORMAT(40A1/22A1/80A1/I10,3X,3F6.0//)
677   FORMAT(T20,'Full phase space input for each incident particle. '/T
     *5,' Source data file: ',256A1/T25,' Source incident on plane ',F14
     *.4,' cm from the point of rotation'/T25,' Angle with respect to z-
     *axis ',F14.4,' degrees.'/T25,' z-position of point of rotation ',f
     *14.4,/T25,' X offset of phsp (before rotation)',F14.4,' cm'/T25,' 
     *Y offset of phsp (before rotation)',F14.4,' cm'/T25,' # of particl
     *es read from ph-sp file =', 1PE13.3,'.')
679   FORMAT(T20,' Full treatment head simulation from an angle'/,T10,' 
     *   Particle charge                               : ',i3,/T10,'    
     *Weight window                                 : ',2g15.6,/T10,'   
     * BEAMnrc user code                             : ',a,/T10,'    PEG
     *S data file                                : ',a,/T10,'    Input f
     *ile                                    : ',a,/T10,'    Rotation po
     *int to phsp-plane midpoint distance: ',f10.4,/T10,'    Incident an
     *gle (degrees)                      : ',f10.4,/T10,'    Rotation po
     *int (will be set to chamber center'/,T10,'      if greater than 1e
     *4 or less than -1e4):     : ',g14.4,' cm'/T10,'    X offset of phs
     *p plane (before rotation)      : ',f10.4,' cm'/T10,'    Y offset o
     *f phsp plane (before rotation)      : ',f10.4,' cm'/T10,'    Max. 
     *kinetic energy of simulation             : ',f10.4,' MeV')
      END
      subroutine src15
      implicit none
      CHARACTER*4 CDSTBL( 12001),CTRTBL( 12001),CABSRB( 12001)
      COMMON/GEOM/ZPLANE( 201),RCYL(0:60), CYRAD2( 61), NZ,NR,NREG,NDOSE
     *,NZDOSE,NRDOSE,NPLANE, NZDMIN,NZDMAX,NRDMIN,NRDMAX, NTRACK( 12001)
     *,CDSTBL,CTRTBL,CABSRB,IDSTBL( 12001,2)
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,NZDMIN,NZDMAX,NRDM
     *IN,NRDMAX, NTRACK,IDSTBL
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(200,60),TMCPUO,TIMMAX,ST
     *ATLM,EIN,EKMAX, IDAT,IRESTART,IQIN,NESTEP,NSMAX,IXXIN,JXXIN,IVAL,D
     *ATCOUNT
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN,EKMAX
      integer*4 IDAT,IRESTART,IQIN,NESTEP,NSMAX, IXXIN,JXXIN,IVAL,DATCOU
     *NT
      integer*8 NCASE,NCASEO,NCASET
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(100,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBE
     *AM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,
     *DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,P
     *ROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,
     *ZSOFST,                                                      SVTMP
     *1,SVTMP2,SVTMP3,SVTMP4,
     *         RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                       XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,W
     *EIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      real*8 temp1,temp2,temp3,temp4
      real*8 XIN,YIN,ZIN,UIN,VIN,WIN,WEIGHT
      integer*4 NRCFLG,IRIN,iout,error_flag
      real*8 theta,cost,sint,d,d2,yo,zo,dz,R,R2,area,w0,pi,zc,ro2
      real*8 fak,x1,y1,x2,y2,x3,y3,xmin,xmax,delx,ymin,ymax,dely
      real*8 count,sumw,sumw2
      logical just_fb,just_side,enter_fb,enter_side
      real*8 eta1,eta2,xx,yy,zz,dist2,dist,uli,vli,wli, xli,yli,zli,rad2
     *,ts,tf,ur2,ux,ux2,rr2,del,error
      integer*4 ix,iz
      save cost,sint,d,d2,yo,zo,dz,R,R2,xmin,delx,ymin,dely, zc,area,w0,
     *count,sumw,sumw2,just_fb,just_side,pi,ro2
      entry src15_ini(temp1,temp2,temp3,temp4,error_flag)
      pi = 4*datan(1d0)
      theta = temp2
      IF (( theta .GT. 180 )) THEN
        theta = 360 - theta
      END IF
      theta = theta*pi/180
      cost = cos(theta)
      sint = sin(theta)
      d = temp1
      d2 = d*d
      yo = d*sint
      zo = -d*cost
      R = RCYL(NR)
      R2 = R*R
      dz = 0.5*(ZPLANE(NPLANE)-ZPLANE(1))
      zc = 0.5*(ZPLANE(NPLANE)+ZPLANE(1))
      IF (( yo .GT. -R .AND. yo .LT. R .AND. zo .GT. -dz .AND. zo .LT. d
     *z )) THEN
        error_flag = 1
      END IF
      just_fb = .false.
      just_side = .false.
      IF (( yo .GE. -R .AND. yo .LE. R )) THEN
        just_fb = .true.
      END IF
      IF (( zo .GE. -dz .AND. zo .LE. dz )) THEN
        just_side = .true.
      END IF
      IF (( just_fb )) THEN
        IF (( zo .LT. -dz )) THEN
          fak = 1./(1-(-R*sint + dz*cost)/d)
          x1 = R*fak
          y1 = (-R*cost-dz*sint)*fak
          fak = 1./(1-(R*sint + dz*cost)/d)
          x2 = R*fak
          y2 = (R*cost-dz*sint)*fak
        ELSE
          fak = 1./(1-(-R*sint - dz*cost)/d)
          x1 = R*fak
          y1 = (-R*cost+dz*sint)*fak
          fak = 1./(1-(R*sint - dz*cost)/d)
          x2 = R*fak
          y2 = (R*cost+dz*sint)*fak
        END IF
        ymin = MIN(y1,y2)
        ymax = MAX(y1,y2)
        xmax = MAX(x1,x2)
        xmin = -xmax
      ELSE IF(( just_side )) THEN
        fak = 1./(1-(R*sint + dz*cost)/d)
        x1 = R*fak
        y1 = (R*cost-dz*sint)*fak
        fak = 1./(1-(R*sint - dz*cost)/d)
        x2 = R*fak
        y2 = (R*cost+dz*sint)*fak
        ymin = MIN(y1,y2)
        ymax = MAX(y1,y2)
        xmax = MAX(x1,x2)
        xmin = -xmax
      ELSE
        IF (( zo .LT. -dz )) THEN
          fak = 1./(1-(-R*sint + dz*cost)/d)
          x1 = R*fak
          y1 = (-R*cost-dz*sint)*fak
        ELSE
          fak = 1./(1-(-R*sint - dz*cost)/d)
          x1 = R*fak
          y1 = (-R*cost+dz*sint)*fak
        END IF
        fak = 1./(1-(R*sint + dz*cost)/d)
        x2 = R*fak
        y2 = (R*cost-dz*sint)*fak
        fak = 1./(1-(R*sint - dz*cost)/d)
        x3 = R*fak
        y3 = (R*cost+dz*sint)*fak
        xmax = max(x1,x2,x3)
        xmin = -xmax
        ymin = min(y1,y2,y3)
        ymax = max(y1,y2,y3)
      END IF
      delx = xmax - xmin
      dely = ymax - ymin
      area = delx*dely
      w0 = area/d2
      ro2 = yo*yo
      WRITE(6,5300)IQIN,d,temp2,xmin,xmax,ymin,ymax
5300  FORMAT(/' Electric charge of the source:',T60,I12/ ' Point sourceo
     *ff axis'/ ' Distance of source from centre of chamber: ',T60,f10.4
     *,/ ' Angle to z-axis (degrees): ',T60,f10.4,/, ' Rectangle in the 
     *plane perpendicular to the source-chamber'/ ' axis seen from theso
     *urce: ',/,T40,4f10.4/)
      return
      entry src15_oto(iout)
      ainflu = NCASET/d2
      return
      entry src15_describe(iout)
      write(iout,580) d,theta,yo,zo
580   format(' ',t20,'POINT SOURCE OFF AXIS',/,' ',t20, 'distance to cha
     *mber centre: ',f8.3,' cm',/,' ',t20, 'angle: ',f8.3,' degrees ',/,
     *' ',t20, 'source position: y = ',f8.3,' z = ',f8.3)
      return
      entry src15_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
      count = count + 1
      IF((rng_seed .GT. 128))call ranmar_get
      eta1 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((rng_seed .GT. 128))call ranmar_get
      eta2 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      xx = xmin + delx*eta1
      yy = ymin + dely*eta2
      dist2 = d2 + xx*xx + yy*yy
      dist = sqrt(dist2)
      w0 = d/dist
      zz = yy*sint
      yy = yy*cost
      uli = xx/dist
      vli = (yy-yo)/dist
      wli = (zz-zo)/dist
      tf = 1e15
      ts = 1e15
      enter_fb = .false.
      enter_side = .false.
      IF (( .NOT.just_side )) THEN
        IF (( zo .LT. -dz )) THEN
          tf = (-dz-zo)/wli
        ELSE
          tf = (dz - zo)/wli
        END IF
        xli = uli*tf
        yli = vli*tf + yo
        IF (( xli*xli + yli*yli .LT. R2 )) THEN
          enter_fb = .true.
        ELSE
          tf = 1e15
        END IF
      END IF
      IF (( .NOT.just_fb )) THEN
        ur2 = uli*uli + vli*vli
        ux = -yo*vli/ur2
        ux2 = ux*ux
        rr2 = ro2/ur2
        del = ux2 - rr2 + R2/ur2
        IF (( del .GE. 0 )) THEN
          ts = ux - sqrt(del)
          IF (( ts .GT. 0 )) THEN
            zli = zo + wli*ts
            IF (( zli .GE. -dz .AND. zli .LE. dz )) THEN
              enter_side = .true.
            END IF
          END IF
          IF (( .NOT.enter_side )) THEN
            ts = 1e15
          END IF
        END IF
      END IF
      IF (( .NOT.enter_fb .AND. .NOT.enter_side )) THEN
        weight = 0
        xin = 0
        yin = 0
        zin = zplane(1)
        uin = 0
        vin = 0
        win = 1
        irin = 2
        return
      END IF
      uin = uli
      vin = vli
      win = wli
      weight = w0*area/dist2
      sumw = sumw + weight
      sumw2 = sumw2 + weight*weight
      IF (( tf .LT. ts )) THEN
        xin = xli
        yin = yli
        IF (( zo .LT. -dz )) THEN
          zin = zplane(1)
          iz = 1
        ELSE
          zin = zplane(nplane)
          iz = nplane-1
        END IF
        rad2 = xli*xli+yli*yli
        DO 5311 ix=1,nr
          IF((rad2 .LE. CYRAD2(IX)))GO TO5312
5311    CONTINUE
5312    CONTINUE
      ELSE
        zin = zli + zc
        xin = ts*uli
        yin = yo + vli*ts
        ix = nr
        DO 5321 iz=1,nz
          IF((zin .GE. zplane(iz) .AND. zin .LT. zplane(iz+1)))GO TO5322
5321    CONTINUE
5322    CONTINUE
      END IF
      irin = 1 + (ix-1)*nz + iz
      return
      entry src15_out(iout)
      sumw = sumw/count
      sumw2 = sumw2/count
      error = (sumw2 - sumw*sumw)/(count-1)
      IF (( error .GT. 0 )) THEN
        error = sqrt(error)
      END IF
      write(iout,600) sumw,sumw2
600   format(//'  Source 15: solid angle for detector: ',g14.5,' +/- ',g
     *14.5,//)
      return
      end
      subroutine src16
      implicit none
      CHARACTER*4 CDSTBL( 12001),CTRTBL( 12001),CABSRB( 12001)
      COMMON/GEOM/ZPLANE( 201),RCYL(0:60), CYRAD2( 61), NZ,NR,NREG,NDOSE
     *,NZDOSE,NRDOSE,NPLANE, NZDMIN,NZDMAX,NRDMIN,NRDMAX, NTRACK( 12001)
     *,CDSTBL,CTRTBL,CABSRB,IDSTBL( 12001,2)
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,NZDMIN,NZDMAX,NRDM
     *IN,NRDMAX, NTRACK,IDSTBL
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(200,60),TMCPUO,TIMMAX,ST
     *ATLM,EIN,EKMAX, IDAT,IRESTART,IQIN,NESTEP,NSMAX,IXXIN,JXXIN,IVAL,D
     *ATCOUNT
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN,EKMAX
      integer*4 IDAT,IRESTART,IQIN,NESTEP,NSMAX, IXXIN,JXXIN,IVAL,DATCOU
     *NT
      integer*8 NCASE,NCASEO,NCASET
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(100,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBE
     *AM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,
     *DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,P
     *ROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,
     *ZSOFST,                                                      SVTMP
     *1,SVTMP2,SVTMP3,SVTMP4,
     *         RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                       XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,W
     *EIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      real*8 temp1,temp2,temp3,temp4
      real*8 XIN,YIN,ZIN,UIN,VIN,WIN,WEIGHT
      integer*4 NRCFLG,IRIN,iout,error_flag
      real*8 pi,theta,cost,sint,d0,d02,R,R2,dz,dr,zc,u,aux,u2, xo,yo,zo,
     *a_side,a_fb,atot,wfb,dist,dist2,rs, delxs,delys,rs2,rad2,eta,sumw,
     *sumw2,count,zz
      logical point_source,do_fb,do_side,do_both,is_circle
      integer*4 ix,iz
      save pi,cost,sint,d0,d02,R,R2,dz,dr,zc,theta, xo,yo,zo,a_side,a_fb
     *,atot,wfb,rs,delxs,delys,rs2, sumw,sumw2,count,point_source,do_fb,
     *do_side,is_circle
      entry src16_ini(temp1,temp2,temp3,temp4,error_flag)
      pi = 4*datan(1d0)
      count = 0
      theta = temp2
      theta = theta*pi/180
      cost = cos(theta)
      sint = sin(theta)
      d0 = temp1
      d02 = d0*d0
      R = RCYL(NR)
      R2 = R*R
      dz = 0.5*(ZPLANE(NPLANE)-ZPLANE(1))
      zc = 0.5*(ZPLANE(NPLANE)+ZPLANE(1))
      IF (( temp3 .LE. 0 .AND. temp4 .LE. 0 )) THEN
        point_source = .true.
        zo = -d0*cost
        yo = d0*sint
        xo = 0
        do_fb = .false.
        do_side = .false.
        do_both = .false.
        a_side = 0
        a_fb = 0
        IF (( abs(yo) .GT. R )) THEN
          u = R/yo
          aux = sqrt(1-u*u)
          dr = R*aux
          do_side = .true.
          a_side = 4*dz*R*yo*(aux-u*atan(aux/u))
        END IF
        IF (( abs(zo) .GT. dz )) THEN
          a_fb = pi*R2*(abs(zo)-dz)
          do_fb = .true.
        END IF
        atot = a_fb + a_side
        wfb = a_fb/atot
        IF (( do_side .AND. do_fb )) THEN
          do_both = .true.
        END IF
      ELSE
        point_source = .false.
        is_circle = .false.
        IF (( temp4 .LE. 0 .OR. temp3 .LE. 0 )) THEN
          IF (( temp4 .LE. 0 )) THEN
            rs = temp3
          ELSE
            rs = temp4
          END IF
          rs = temp3
          rs2 = rs*rs
          delxs = rs
          delys = rs
          is_circle = .true.
        ELSE
          delxs = temp3
          delys = temp4
          rs2 = 1.1*(delxs*delxs+delys*delys)
        END IF
      END IF
      WRITE(6,5330)IQIN
5330  FORMAT(/' Electric charge of the source:',T60,I12)
      IF (( point_source )) THEN
        WRITE(6,5340)d0,temp2,wfb,1-wfb
5340    FORMAT(' Point source off axis (source 16 implementation)'/ ' Di
     *stance of source from centre of chamber: ',T60,f10.4,/ ' Angle toz
     *-axis (degrees): ',T60,f10.4,/, ' Estimated probability to strike 
     *front/back face: ',T60,f12.6,/ ' Estimated probability to strikesi
     *de face: ',T60,f12.6)
      ELSE
        IF (( is_circle )) THEN
          WRITE(6,5350)d0,temp2,rs
5350      FORMAT(' Disk irradiating the chamber (source 16 implementatio
     *n)'/ ' Distance of source centre to chamber centre: ',T60,f10.4,/'
     * Angle to z-axis (degrees): ',T60,f10.4,/, ' Radius of the source:
     * ',T60,f10.4)
        ELSE
          WRITE(6,5360)d0,temp2,delxs,delys
5360      FORMAT(' Rectangle irradiating the chamber (source 16 implemen
     *tation)'/ ' Distance of source centre to chamber centre: ',T60,f10
     *.4,/ ' Angle to z-axis (degrees): ',T60,f10.4,/, ' Rectangle half-
     *sizes: ',T60,2f10.4)
        END IF
      END IF
      return
      entry src16_oto(iout)
      ainflu = NCASET/d02
      return
      entry src16_describe(iout)
      IF (( point_source )) THEN
        write(iout,'(t20,a)') 'POINT SOURCE OFF AXIS (source 16)'
      ELSE
        IF (( is_circle )) THEN
          write(iout,'(t20,a)') 'Radiating circle off axis (source 16)'
          write(iout,'(t20,a,f10.4)') 'Source radius: ',rs
        ELSE
          write(iout,'(t20,a)') 'Radiating rectangle off axis (source 16
     *)'
          write(iout,'(t20,a,2f10.4)') 'Source half-sizes: ',delxs,delys
        END IF
      END IF
      write(iout,'(t20,a,f10.4)') 'Distance between source and chamber c
     *entres: ',d0
      write(iout,'(t20,a,f10.4,a)') 'Angle to z-axis (degrees): ',theta*
     *180/pi,' degrees'
      return
      entry src16_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
      count = count + 1
      IF (( .NOT.point_source )) THEN
5371    CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          xo = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          xo = delxs*(2*xo-1)
          IF((rng_seed .GT. 128))call ranmar_get
          yo = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          yo = delys*(2*yo-1)
          IF((( xo*xo + yo*yo .LT. rs2 )))GO TO5372
        GO TO 5371
5372    CONTINUE
        zo = yo*sint - d0*cost
        yo = d0*sint + yo*cost
        yo = sqrt(yo*yo+xo*xo)
        do_fb = .false.
        do_side = .false.
        do_both = .false.
        a_side = 0
        a_fb = 0
        IF (( abs(yo) .GT. R )) THEN
          u = R/yo
          do_side = .true.
          IF (( u .LT. 0.1 )) THEN
            u2 = u*u
            aux = 1 - u2/2 - u2*u2/8
            a_side = 4*dz*R*yo*(aux-pi*u/2+u2+u2*u2/6)
          ELSE
            aux = sqrt(1-u*u)
            a_side = 4*dz*R*yo*(aux-u*atan(aux/u))
          END IF
          dr = R*aux
        END IF
        IF (( abs(zo) .GT. dz )) THEN
          a_fb = pi*R2*(abs(zo)-dz)
          do_fb = .true.
        END IF
        atot = a_fb + a_side
        IF (( do_side .AND. do_fb )) THEN
          wfb = a_fb/atot
          do_both = .true.
        END IF
      END IF
      IF (( do_both )) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        eta = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( eta .LT. wfb )) THEN
          do_fb = .true.
          do_side = .false.
        ELSE
          do_fb = .false.
          do_side = .true.
        END IF
      END IF
      IF (( do_fb )) THEN
5381    CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          xin = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          xin = R*(2*xin-1)
          IF((rng_seed .GT. 128))call ranmar_get
          yin = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          yin = R*(2*yin-1)
          rad2 = xin*xin + yin*yin
          IF(((rad2 .LE. R2 )))GO TO5382
        GO TO 5381
5382    CONTINUE
        DO 5391 ix=1,nr
          IF((rad2 .LE. CYRAD2(ix)))GO TO5392
5391    CONTINUE
5392    CONTINUE
        IF (( zo .LT. -dz )) THEN
          zin = -dz
          iz = 1
        ELSE
          zin = dz
          iz = nz
        END IF
      ELSE
        IF((rng_seed .GT. 128))call ranmar_get
        zin = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        zin = dz*(2*zin-1)
5401    CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          xin = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          eta = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          xin = dr*(2*xin-1)
          yin = sqrt(R2 - xin*xin)
          IF((( eta .LT. (yo-R2/yin)/(yo-R) )))GO TO5402
        GO TO 5401
5402    CONTINUE
        ix = nr
        zz = zin + zc
        DO 5411 iz=1,nz
          IF((zz .GE. zplane(iz) .AND. zz .LT. zplane(iz+1)))GO TO5412
5411    CONTINUE
5412    CONTINUE
      END IF
      uin = xin
      vin = yin - yo
      win = zin - zo
      dist2 = uin*uin + vin*vin + win*win
      dist = sqrt(dist2)
      uin = uin/dist
      vin = vin/dist
      win = win/dist
      weight = atot/dist2/dist
      sumw = sumw + weight
      sumw2 = sumw2 + weight*weight
      irin = 1 + (ix-1)*nz + iz
      zin = zin + zc
      return
      end
#define HAVE_LOAD_DSO
#ifndef HAVE_LOAD_DSO
      subroutine init_beamsource(i_parallel,n_parallel,i_log,conf_name,
     *hen_house,egs_home,the_beam_code, the_pegs_file,the_input_file)
      integer*4 i_parallel,n_parallel
      character*(*) conf_name
      character*(*) hen_house,egs_home,the_beam_code,the_pegs_file,the_i
     *nput_file
      write(6,*) 'You need a working C compiler to use source 23!'
      call exit(1)
      end
      subroutine sample_beamsource(ein,xin,yin,zin,uin,vin,win,weight,iq
     *in,latchi, nhstry,iphatin)
      return
      end
      subroutine finish_beamsource
      return
      end
#endif
      SUBROUTINE ENSRC
      implicit none
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      INTEGER NUM_EITYPE, NUM_KIEN, NUM_SPFIL, NUM_SPIOUSP
      COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE
      integer*4 ICHPIN,ILPIN,IOUT,IPAGE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(200,60),TMCPUO,TIMMAX,ST
     *ATLM,EIN,EKMAX, IDAT,IRESTART,IQIN,NESTEP,NSMAX,IXXIN,JXXIN,IVAL,D
     *ATCOUNT
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN,EKMAX
      integer*4 IDAT,IRESTART,IQIN,NESTEP,NSMAX, IXXIN,JXXIN,IVAL,DATCOU
     *NT
      integer*8 NCASE,NCASEO,NCASET
      COMMON/SCORE/ SCDOSE(200,60,7),SCDOSE2(200,60,7), SCKERMA(200,60,7
     *),SCKERMA2(200,60,7), SCDOSEtoKERMA2(200,60,7),SCPDST(500),SCPDST2
     *(500), SCPCUM(500),SCPCUM2(500),SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCD
     *FBK(4),SCDFBK2(4),SCDFEP(4),SCDFEP2(4),SCDFDIFF(4),SCDFDIFF2(4), S
     *CSTP,SCSTP2,SCDSTP,SCDSTP2, PIISTP, SCSTP_LAST, SCDSTP_LAST,SCDOSE
     *_LAST(200,60,7), SCKERMA_LAST(200,60,7), SCKERMA_LASTOLD(200,60,7)
     *,SCPDST_LAST, IHSTRY, DFEN(4,4), PHENER,WT1OLD,BINTOP(500),SLOTE,D
     *ELTAE, SCDOSE_TMP(200,60,7), SCKERMA_TMP(200,60,7), SCKERMA_TMPOLD
     *(200,60,7), SCSTP_TMP,SCDSTP_TMP, MXNP,IFULL,ISTORE,IKERMA, IWATCH
     *,IOOPTN,IOUTSP, IPHR( 12001),MAXBIN,NCOMPT,during_pe_compt,during_
     *eii
      real*8 SCDOSE,SCDOSE2,SCKERMA,SCKERMA2,SCDOSEtoKERMA2,SCPDST,SCPDS
     *T2, SCPCUM,SCPCUM2,SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCDFBK,SCDFBK2,S
     *CDFEP,SCDFEP2,SCDFDIFF,SCDFDIFF2, SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIIS
     *TP
      integer*8 SCSTP_LAST, SCDSTP_LAST, SCDOSE_LAST, SCKERMA_LAST, SCKE
     *RMA_LASTOLD,SCPDST_LAST, IHSTRY
      real*8 DFEN, PHENER,WT1OLD,BINTOP,SLOTE,DELTAE, SCDOSE_TMP,SCKERMA
     *_TMP,SCKERMA_TMPOLD,SCSTP_TMP,SCDSTP_TMP
      integer*4 MXNP,IFULL,ISTORE,IKERMA, IWATCH,IOOPTN,IOUTSP, IPHR,MAX
     *BIN,NCOMPT,during_pe_compt,during_eii
      COMMON/SPECTR/ CDFINV(1000,2),ENSRCD(0:300),SRCPDF(300),SRCCDF(300
     *), NENSRC
      integer*4 NENSRC
      real*8 CDFINV,ENSRCD,SRCPDF,SRCCDF
      COMMON/USERRR/ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN, MINZ,MAXZ,MINR,MAXR
     *,IREJCT
      real*8 ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN
      integer*4 MINZ,MAXZ,MINR,MAXR,IREJCT
      COMMON/USERMI/EXPMFP,GWTOLD,ICSDA
      integer*4 ICSDA
      real*8 EXPMFP,GWTOLD
      COMMON/USERVR/ CEXPTR,GWAIT,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,
     *IQINC,MONOEN, cs_enhance,cs_enhance_current,ienhance,iefl( 12001),
     *ics_enhance, do_fast_step
      integer*4 ienhance,iefl,ics_enhance, IFORCE,NFMIN,NFMAX,NFTIME,ISO
     *URC,IFPB,IQINC,MONOEN
      real*8 CEXPTR,GWAIT,cs_enhance,cs_enhance_current
      logical do_fast_step
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(100,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBE
     *AM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,
     *DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,P
     *ROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,
     *ZSOFST,                                                      SVTMP
     *1,SVTMP2,SVTMP3,SVTMP4,
     *         RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                       XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,W
     *EIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      integer*4  srcbin_at(300), mode
      real*8   srcpdf_at(300), enmin,enmax,sume1,sume, Ek_max,Emono
      logical is_mono
      character*256 filnam,spec_title
      integer*4 lnblnk1
      save enmin,enmax, srcbin_at, srcpdf_at,Emono, is_mono,mode,filnam,
     *spec_title
      integer*4 ib
      real*8 enin,alias_sample
      DELIMETER='SOURCE INPUTS'
      IF ((ENFLAG.EQ.1)) THEN
        MONOEN = 2
        RETURN
      END IF
      WRITE(6,5420)
5420  FORMAT(' *** INPUT CARD TC1 ***')
      IVAL = IVAL +1
      NUM_EITYPE = IVAL
      VALUES_SOUGHT(IVAL)='INCIDENT ENERGY'
      TYPE(IVAL)=3
      NVALUE(IVAL)=1
      ALLOWED_INPUTS(IVAL,0)='MONOENERGETIC'
      ALLOWED_INPUTS(IVAL,1)='SPECTRUM'
      NMIN = NUM_EITYPE
      NMAX = NUM_EITYPE
      CALL GET_INPUT
      MONOEN=VALUE(NUM_EITYPE,1)
      IF ((MONOEN .EQ. 0)) THEN
        WRITE(6,5430)
5430    FORMAT(' MONOENERGETIC BEAM:')
        IVAL = IVAL +1
        NUM_KIEN = IVAL
        VALUES_SOUGHT(IVAL)='INCIDENT KINETIC ENERGY(MEV)'
        TYPE(IVAL)=1
        NVALUE(IVAL)=1
        VALUE_MIN(IVAL)=0.001
        VALUE_MAX(IVAL)=200000
        DEFAULT(IVAL)=1.25
        NMIN = NUM_KIEN
        NMAX = NUM_KIEN
        CALL GET_INPUT
        EIN=VALUE(NUM_KIEN,1)
        WRITE(6,5440)EIN
5440    FORMAT(/' KINETIC ENERGY OF THE INCIDENT BEAM: ',T60,F10.4)
        is_mono = .true.
        Emono = EIN
      ELSE
        WRITE(6,5450)
5450    FORMAT(' ENERGY SPECTRUM:')
        is_mono = .false.
        IVAL = IVAL +1
        NUM_SPFIL = IVAL
        VALUES_SOUGHT(IVAL)='SPEC FILENAME'
        TYPE(IVAL)=2
        NMIN = NUM_SPFIL
        NMAX = NUM_SPFIL
        CALL GET_INPUT
        READ (CHAR_VALUE(NUM_SPFIL,1),FMT='(A)') filnam
        WRITE(6,5460)filnam
5460    FORMAT(/'   READ INPUT ENERGY SPECTRUM FROM: ',A)
        call replace_env(filnam)
        OPEN(9,file=filnam,STATUS='OLD')
        READ(9,'(A)') spec_title
        READ(9,*) nensrc,ensrcd(0),mode
        enmin = ensrcd(0)
        IF ((NENSRC .GT. 300)) THEN
          WRITE(6,5470)NENSRC,300
5470      FORMAT(//' ********** Asked for too many energy bins******'/ '
     * NENSRC =',I4, ' reduced to max allowed =',I4/1x,30('*')//)
          NENSRC = 300
        END IF
        READ(9,*)(ENSRCD(IB),SRCPDF(IB),IB=1,NENSRC)
        CLOSE(UNIT=9)
        WRITE(6,5480)NENSRC
5480    FORMAT('    HAVE READ',I5,' INPUT ENERGY BINS FROM FILE')
        IF ((MODE.EQ.0)) THEN
          WRITE(6,5490)
5490      FORMAT('      Counts/bin assumed')
        ELSE IF((MODE .EQ. 1)) THEN
          WRITE(6,5500)
5500      FORMAT('      Counts/MeV assumed')
          DO 5511 IB=1,NENSRC
            SRCPDF(IB) = SRCPDF(IB)*(ENSRCD(IB)-ENSRCD(IB-1))
5511      CONTINUE
5512      CONTINUE
        ELSE
          WRITE(6,5520)MODE
5520      FORMAT(///'*****MODE not 0 or 1 in spectrum file? **' /80('*')
     *//)
        END IF
        EIN=ENSRCD(NENSRC)
        WRITE(6,5530)ENMIN,EIN
5530    FORMAT('    ENERGY RANGES FROM',F10.3,' MeV TO',F12.3,' MeV')
        enmax = ein
        IVAL = IVAL +1
        NUM_SPIOUSP = IVAL
        VALUES_SOUGHT(IVAL)='SPEC IOUTSP'
        TYPE(IVAL)=3
        DEFAULT(IVAL)=0
        ALLOWED_INPUTS(IVAL,0)='NONE'
        ALLOWED_INPUTS(IVAL,1)='INCLUDE'
        NMIN = NUM_SPIOUSP
        NMAX = NUM_SPIOUSP
        CALL GET_INPUT
        IOUTSP=VALUE(NUM_SPIOUSP,1)
      END IF
      WRITE(6,5540)
5540  FORMAT(' ')
      RETURN
      ENTRY ENSRC1
      IF((is_mono))return
      IF (( enmin .GE. ensrcd(1) )) THEN
        write(6,*) ' Bad spectrum: minimum energy is > top of first bin!
     * '
        stop
      END IF
      call prepare_alias_sampling(nensrc,srcpdf,srcpdf_at,srcbin_at)
      RETURN
      ENTRY ENSRCO
      IF (( is_mono )) THEN
        write(iout,'(18x,a,f9.3,a)') 'Mono-energy: ',Emono,' MeV'
        return
      END IF
      IF ((enflag .EQ. 1)) THEN
        return
      END IF
      WRITE(IOUT,105) FILNAM(:lnblnk1(FILNAM)),SPEC_TITLE(:lnblnk1(SPEC_
     *TITLE))
105   FORMAT(18x,' Spectrum file and title:'/18x,A/18x,A)
      sume1 = 0
      sume = 0
      DO 5551 ib=1,nensrc
        sume = sume + srcpdf(ib)
        sume1 = sume1 + srcpdf(ib)*(ensrcd(ib)+ensrcd(ib-1))/2
5551  CONTINUE
5552  CONTINUE
      WRITE(IOUT,'(20x,a,f10.4)') ' Average spectrum energy is ',sume1/s
     *ume
      IF ((IOUTSP.EQ.1)) THEN
        IF ((MODE.EQ.0)) THEN
          WRITE(IOUT,'(20x,'' Counts/bin assumed'')')
        ELSE
          WRITE(IOUT,'(20x,'' Counts/MeV assumed'')')
        END IF
        WRITE(IOUT,110)NENSRC,enmin
        DO 5561 IB=1,NENSRC
          WRITE(IOUT,120)IB,ensrcd(ib),srcpdf(ib),srcpdf_at(ib),srcbin_a
     *    t(ib)
5561    CONTINUE
5562    CONTINUE
      END IF
      RETURN
      ENTRY ENSRCH(ENIN)
      IF (( is_mono )) THEN
        enin = Emono
        return
      END IF
      enin = alias_sample(nensrc,ensrcd,srcpdf_at,srcbin_at)
      RETURN
      ENTRY ENSRC_EMAX(Ek_max)
      IF (( is_mono )) THEN
        Ek_max = Emono
      ELSE
        Ek_max = ensrcd(nensrc)
      END IF
      return
100   FORMAT(' ',I1)
102   FORMAT(' ',G14.7)
110   FORMAT(' ',T20,'Energy dist''n, # of incident energy bins:',T60,I3
     */ T20,' Lower energy of first bin:',T60,F7.3,' (MeV)'/ ' ',T20,'bi
     *n    kinetic energy     probability  at prob   at bin')
120   FORMAT(' ',T20,I3,T28,F7.3,T45,1PE10.3,T60,0PF7.4,T70,i4)
      END
      SUBROUTINE GEOMRZ
      implicit none
      CHARACTER*4 CDSTBL( 12001),CTRTBL( 12001),CABSRB( 12001)
      COMMON/GEOM/ZPLANE( 201),RCYL(0:60), CYRAD2( 61), NZ,NR,NREG,NDOSE
     *,NZDOSE,NRDOSE,NPLANE, NZDMIN,NZDMAX,NRDMIN,NRDMAX, NTRACK( 12001)
     *,CDSTBL,CTRTBL,CABSRB,IDSTBL( 12001,2)
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,NZDMIN,NZDMAX,NRDM
     *IN,NRDMAX, NTRACK,IDSTBL
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(200,60),TMCPUO,TIMMAX,ST
     *ATLM,EIN,EKMAX, IDAT,IRESTART,IQIN,NESTEP,NSMAX,IXXIN,JXXIN,IVAL,D
     *ATCOUNT
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN,EKMAX
      integer*4 IDAT,IRESTART,IQIN,NESTEP,NSMAX, IXXIN,JXXIN,IVAL,DATCOU
     *NT
      integer*8 NCASE,NCASEO,NCASET
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/SCORE/ SCDOSE(200,60,7),SCDOSE2(200,60,7), SCKERMA(200,60,7
     *),SCKERMA2(200,60,7), SCDOSEtoKERMA2(200,60,7),SCPDST(500),SCPDST2
     *(500), SCPCUM(500),SCPCUM2(500),SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCD
     *FBK(4),SCDFBK2(4),SCDFEP(4),SCDFEP2(4),SCDFDIFF(4),SCDFDIFF2(4), S
     *CSTP,SCSTP2,SCDSTP,SCDSTP2, PIISTP, SCSTP_LAST, SCDSTP_LAST,SCDOSE
     *_LAST(200,60,7), SCKERMA_LAST(200,60,7), SCKERMA_LASTOLD(200,60,7)
     *,SCPDST_LAST, IHSTRY, DFEN(4,4), PHENER,WT1OLD,BINTOP(500),SLOTE,D
     *ELTAE, SCDOSE_TMP(200,60,7), SCKERMA_TMP(200,60,7), SCKERMA_TMPOLD
     *(200,60,7), SCSTP_TMP,SCDSTP_TMP, MXNP,IFULL,ISTORE,IKERMA, IWATCH
     *,IOOPTN,IOUTSP, IPHR( 12001),MAXBIN,NCOMPT,during_pe_compt,during_
     *eii
      real*8 SCDOSE,SCDOSE2,SCKERMA,SCKERMA2,SCDOSEtoKERMA2,SCPDST,SCPDS
     *T2, SCPCUM,SCPCUM2,SCPTOT,SCPTOT2,SCPHEN,SCPHEN2, SCDFBK,SCDFBK2,S
     *CDFEP,SCDFEP2,SCDFDIFF,SCDFDIFF2, SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIIS
     *TP
      integer*8 SCSTP_LAST, SCDSTP_LAST, SCDOSE_LAST, SCKERMA_LAST, SCKE
     *RMA_LASTOLD,SCPDST_LAST, IHSTRY
      real*8 DFEN, PHENER,WT1OLD,BINTOP,SLOTE,DELTAE, SCDOSE_TMP,SCKERMA
     *_TMP,SCKERMA_TMPOLD,SCSTP_TMP,SCDSTP_TMP
      integer*4 MXNP,IFULL,ISTORE,IKERMA, IWATCH,IOOPTN,IOUTSP, IPHR,MAX
     *BIN,NCOMPT,during_pe_compt,during_eii
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(100,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBE
     *AM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,
     *DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,P
     *ROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,
     *ZSOFST,                                                      SVTMP
     *1,SVTMP2,SVTMP3,SVTMP4,
     *         RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                       XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,W
     *EIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/USERRR/ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN, MINZ,MAXZ,MINR,MAXR
     *,IREJCT
      real*8 ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN
      integer*4 MINZ,MAXZ,MINR,MAXR,IREJCT
      COMMON/USERMI/EXPMFP,GWTOLD,ICSDA
      integer*4 ICSDA
      real*8 EXPMFP,GWTOLD
      COMMON/USERVR/ CEXPTR,GWAIT,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,
     *IQINC,MONOEN, cs_enhance,cs_enhance_current,ienhance,iefl( 12001),
     *ics_enhance, do_fast_step
      integer*4 ienhance,iefl,ics_enhance, IFORCE,NFMIN,NFMAX,NFTIME,ISO
     *URC,IFPB,IQINC,MONOEN
      real*8 CEXPTR,GWAIT,cs_enhance,cs_enhance_current
      logical do_fast_step
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      integer*4 MEDNUM, NREGLO, NREGHI
      integer*4 NZHI, NZLO, NRHI, NRLO
      integer*4 ITERSE,NSLAB(100), DESCRIBE
      real*8 DELTAZ(100),RHORI
      integer*4 NUM_ITERSE, NUM_FTFACE, NUM_NSLAB, NUM_DELTAZ, NUM_ZPLAN
     *ES, NUM_RCYL
      integer*4 NUM_MEDIA, NUM_RHOR, NUM_DESCRIB, NUM_MEDNUM, NUM_NREGLO
     *, NUM_NREGHI, NUM_NPLANLO, NUM_NPLANHI, NUM_NRADLO, NUM_NRADHI
      integer*4 ERR
      integer*4 IOUT
      integer*4 lnblnk1
      integer*4 I,J,K,PLN,COUNT
      integer*4 IX, IZ, REGNUM, SLENGHT
      real*8 ADDING
      save describe
      I=0
      ERR=15
      ERROR_FLAG=0
      DELIMETER = 'GEOMETRICAL INPUTS'
      NUM_ITERSE = IVAL
      VALUES_SOUGHT(IVAL)='METHOD OF INPUT'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='GROUPS'
      ALLOWED_INPUTS(IVAL,1)='INDIVIDUAL'
      NMIN = IVAL
      NMAX = IVAL
      CALL GET_INPUT
      ITERSE=VALUE(IVAL,1)
      IVAL = IVAL + 1
      NUM_FTFACE = IVAL
      VALUES_SOUGHT(IVAL)='Z OF FRONT FACE'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=-999999
      VALUE_MAX(IVAL)=999999
      DEFAULT(IVAL)=0.0
      NMIN = IVAL
      NMAX = IVAL
      CALL GET_INPUT
      ZPLANE(1)=VALUE(IVAL,1)
      IF ((ITERSE.EQ.0)) THEN
        IVAL = IVAL + 1
        NUM_NSLAB = IVAL
        VALUES_SOUGHT(IVAL)='NSLAB'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=0
        VALUE_MAX(IVAL)=999999
        DEFAULT(IVAL)=1
        NMIN = IVAL
        NMAX = IVAL
        CALL GET_INPUT
        IVAL = IVAL + 1
        NUM_DELTAZ = IVAL
        VALUES_SOUGHT(IVAL)='SLAB THICKNESS'
        TYPE(IVAL)=1
        VALUE_MIN(IVAL)=0
        VALUE_MAX(IVAL)=999999
        DEFAULT(IVAL)=1.0
        NMIN = IVAL
        NMAX = IVAL
        CALL GET_INPUT
        DO 5571 K=1,NVALUE(NUM_NSLAB)
          NSLAB(K)=VALUE(NUM_NSLAB,K)
5571    CONTINUE
5572    CONTINUE
        DO 5581 K=1,NVALUE(NUM_DELTAZ)
          DELTAZ(K)=VALUE(NUM_DELTAZ,K)
5581    CONTINUE
5582    CONTINUE
        COUNT=1
        DO 5591 PLN=1,NVALUE(NUM_NSLAB)
          IF ((PLN.EQ.1)) THEN
            ADDING=0
          ELSE
            ADDING=ADDING+DELTAZ(PLN-1)*NSLAB(PLN-1)
          END IF
          DO 5601 K=1,NSLAB(PLN)
            COUNT=COUNT+1
            ZPLANE(COUNT)=ZPLANE(1)+ADDING+DELTAZ(PLN)*K
5601      CONTINUE
5602      CONTINUE
5591    CONTINUE
5592    CONTINUE
        NZ=COUNT-1
        IF (( NZ-1 .GT. 200)) THEN
          WRITE(6,5610)NZ-1, 200
5610      FORMAT(///' Number of depth regions,',I3,' is greater than $MA
     *XZREG=',I3/ '  You must change the definition of $MAXZREG in the u
     *ser code'/ '      and recompile'///)
          STOP
        END IF
      END IF
      IF ((ITERSE.EQ.1)) THEN
        IVAL = IVAL + 1
        NUM_ZPLANES = IVAL
        VALUES_SOUGHT(IVAL)='DEPTH BOUNDARIES'
        TYPE(IVAL)=1
        VALUE_MIN(IVAL)=-999999
        VALUE_MAX(IVAL)=999999
        DEFAULT(IVAL)=1.0
        NMIN = IVAL
        NMAX = IVAL
        CALL GET_INPUT
        NZ=NVALUE(IVAL)
        IF (( NZ-1 .GT. 200)) THEN
          WRITE(6,5620)NZ-1, 200
5620      FORMAT(///' Number of depth regions,',I3,' is greater than $MA
     *XZREG=',I3/ '  You must change the definition of $MAXZREG in the u
     *ser code'/ '      and recompile'///)
          STOP
        END IF
      END IF
      IVAL = IVAL + 1
      NUM_RCYL = IVAL
      VALUES_SOUGHT(IVAL)='RADII'
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=0.0000001
      VALUE_MAX(IVAL)=999999.9
      DEFAULT(IVAL)=1000.0
      NMIN = NUM_RCYL
      NMAX = NUM_RCYL
      CALL GET_INPUT
      NR=NVALUE(NUM_RCYL)
      IF (( NR .GT. 60 )) THEN
        WRITE(6,5630)NR, 60
5630    FORMAT(///' Number of radial regions,',I3,' is greater than $MAX
     *RADII',I3,/ '  You must change the definition of $MAXRADII in theu
     *ser code'/ '      and recompile'///)
        STOP
      END IF
      NREG=NR*NZ+1
      IF (( NREG .GT.  12001 )) THEN
        WRITE(6,5640)NREG,  12001
5640    FORMAT(///' Total number of regions,',I6,' is greater than $MXRE
     *G=',I6,/ '  You must change the definition of $MXREG in the user c
     *ode'/ '      and recompile'///)
        STOP
      END IF
      IVAL = IVAL + 1
      NUM_MEDIA = IVAL
      VALUES_SOUGHT(IVAL)='MEDIA'
      TYPE(IVAL)=2
      NMIN = IVAL
      NMAX = IVAL
      CALL GET_INPUT
      NMED=NVALUE(IVAL)
      IVAL = IVAL + 1
      NUM_DESCRIB = IVAL
      VALUES_SOUGHT(IVAL)='DESCRIPTION BY'
      TYPE(IVAL)=3
      NVALUE(IVAL)=1
      ALLOWED_INPUTS(IVAL,0)='REGIONS'
      ALLOWED_INPUTS(IVAL,1)='PLANES'
      ALLOWED_INPUTS(IVAL,2)='REGIONS + DENSITY'
      ALLOWED_INPUTS(IVAL,3)='PLANES + DENSITY'
      NMIN = NUM_DESCRIB
      NMAX = NUM_DESCRIB
      CALL GET_INPUT
      DESCRIBE=VALUE(NUM_DESCRIB,1)
      IVAL = IVAL + 1
      NUM_MEDNUM = IVAL
      VALUES_SOUGHT(IVAL)='MEDNUM'
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=NMED
      DEFAULT(IVAL)=1
      IF ((DESCRIBE.EQ.2 .OR. DESCRIBE.EQ.3)) THEN
        IVAL = IVAL + 1
        NUM_RHOR = IVAL
        VALUES_SOUGHT(IVAL)='RHOR'
        TYPE(IVAL)=1
        VALUE_MIN(IVAL)=0.0
        VALUE_MAX(IVAL)=999999.0
        DEFAULT(IVAL)=0.0
      END IF
      IF ((DESCRIBE.EQ.0 .OR. DESCRIBE.EQ.2)) THEN
        IVAL = IVAL + 1
        NUM_NREGLO = IVAL
        VALUES_SOUGHT(IVAL)='START REGION'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=0
        VALUE_MAX(IVAL)=NREG
        DEFAULT(IVAL)=1
        IVAL = IVAL + 1
        NUM_NREGHI = IVAL
        VALUES_SOUGHT(IVAL)='STOP REGION'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=0
        VALUE_MAX(IVAL)=NREG
        DEFAULT(IVAL)=1
        NMIN = NUM_ITERSE
        NMAX = NUM_NREGHI
        CALL GET_INPUT
      END IF
      IF ((DESCRIBE.EQ.1 .OR. DESCRIBE.EQ.3)) THEN
        IVAL = IVAL + 1
        NUM_NPLANLO = IVAL
        VALUES_SOUGHT(IVAL)='START ZSLAB'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=1
        VALUE_MAX(IVAL)=NZ
        DEFAULT(IVAL)=1
        IVAL = IVAL + 1
        NUM_NPLANHI = IVAL
        VALUES_SOUGHT(IVAL)='STOP ZSLAB'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=1
        VALUE_MAX(IVAL)=NZ
        DEFAULT(IVAL)=1
        IVAL = IVAL + 1
        NUM_NRADLO = IVAL
        VALUES_SOUGHT(IVAL)='START RING'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=1
        VALUE_MAX(IVAL)=NR
        DEFAULT(IVAL)=1
        IVAL = IVAL + 1
        NUM_NRADHI = IVAL
        VALUES_SOUGHT(IVAL)='STOP RING'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=1
        VALUE_MAX(IVAL)=NR
        DEFAULT(IVAL)=1
        NMIN = NUM_ITERSE
        NMAX = NUM_NRADHI
        CALL GET_INPUT
      END IF
      WRITE(6,5650)
5650  FORMAT(' *** INPUT CARD CGM1 ***')
      ITERSE=VALUE(NUM_ITERSE,1)
      WRITE(6,5660)ITERSE
5660  FORMAT(' TERSE(0), RAPID(1) OR DETAILED(2) INPUT:',T60,I12/)
      IF ((ITERSE.EQ.0)) THEN
        WRITE(6,5670)
5670    FORMAT(' *** CARD CGM2A *** (Input groups of slabs) ')
        WRITE(6,5680)NZ
5680    FORMAT(' Number of planar slabs: ',T60,I12)
        NPLANE=NZ+1
        WRITE(6,5690)
5690    FORMAT(' Geometrical Z-plane coordinates:')
        WRITE(6,5700)(ZPLANE(I),I=1,NZ+1)
5700    FORMAT(6F10.4)
        WRITE(6,5710)
5710    FORMAT(' ')
      END IF
      IF ((ITERSE.EQ.1)) THEN
        WRITE(6,5720)
5720    FORMAT(' *** INPUT CARD CGM2B *** (DETAILED INPUT)')
        DO 5731 I=1,NZ
          ZPLANE(I+1)=VALUE(NUM_ZPLANES,I)
5731    CONTINUE
5732    CONTINUE
        WRITE(6,5740)NZ
5740    FORMAT(' NUMBER OF PLANAR SLABS: ',T60,I12)
        NPLANE=NZ+1
        WRITE(6,5750)
5750    FORMAT(' GEOMETRICAL Z-PLANE COORDINATES:')
        WRITE(6,5760)(ZPLANE(I),I=1,NPLANE)
5760    FORMAT(6F10.4)
        WRITE(6,5770)
5770    FORMAT(' ')
      END IF
      WRITE(6,5780)
5780  FORMAT(' *** INPUT CARD CG3 ***')
      WRITE(6,5790)NR
5790  FORMAT(' Number of concentric rings: ', T60, I12)
      RCYL(0)=0.0
      DO 5801 I=1,NR
        RCYL(I)=VALUE(NUM_RCYL,I)
        CYRAD2(I)=VALUE(NUM_RCYL,I)**2
5801  CONTINUE
5802  CONTINUE
      DO 5811 I=1,NR
        WRITE(6,5820)I,RCYL(I)
5820    FORMAT(' Ring radius #',I2,':',T60,F10.4,' cm')
5811  CONTINUE
5812  CONTINUE
      WRITE(6,5830)
5830  FORMAT(/' *** INPUT CARD M1 ***')
      WRITE(6,5840)10, NMED
5840  FORMAT(' Number of media(<=',I3,'):',T60,I12/)
      IF ((NMED .GT. 10 )) THEN
        WRITE(6,5850)
5850    FORMAT(' ************************ERROR************************')
        WRITE(6,5860)
5860    FORMAT(' Number of media exceeds $MXMED - increase value and rec
     *ompile')
        WRITE(6,5870)
5870    FORMAT(' ************************ERROR************************'/
     */)
        WRITE(ERR,'('' Asked for'',I3,'' media and $MXMED is'',I3//)') N
     *  MED, 10
        ERROR_FLAG = 1
      END IF
      WRITE(6,5880)
5880  FORMAT(' *** INPUT CARD M2 ***')
      DO 5891 I=1,NMED
        SLENGHT=lnblnk1(CHAR_VALUE(NUM_MEDIA,I))
        READ (CHAR_VALUE(NUM_MEDIA,I),FMT='(24A1)') (MEDIA(J,I),J=1,SLEN
     *  GHT)
        IF ((SLENGHT.LT.24)) THEN
          DO 5901 J=SLENGHT+1,24
            MEDIA(J,I)=' '
5901      CONTINUE
5902      CONTINUE
        END IF
        WRITE(6,5910)I,(MEDIA(J,I),J=1,24)
5910    FORMAT(' MEDIUM #',I1,':',T55,24A1)
5891  CONTINUE
5892  CONTINUE
      WRITE(6,5920)
5920  FORMAT(/' *** INPUT CARD M3 ***')
      MED(1)=0
      DO 5931 I=2,NREG
        MED(I)=1
5931  CONTINUE
5932  CONTINUE
      WRITE(6,5940)NREG
5940  FORMAT(/' # of geometrical zones = ',T60,I12)
      WRITE (*,*) 'REGION(  1) = MATERIAL( 0) (VACUUM)'
      IF ((DESCRIBE.EQ.0 .OR. DESCRIBE.EQ.2)) THEN
        IF (((NVALUE(NUM_NREGLO).NE.NVALUE(NUM_MEDNUM)).OR. (NVALUE(NUM_
     *  NREGHI).NE.NVALUE(NUM_MEDNUM)))) THEN
          WRITE(ERR,*)'**************ERROR**************'
          WRITE(ERR,*)'MEDNUM HAS      ',NVALUE(NUM_MEDNUM),' VALUES'
          WRITE(ERR,*)'START REGION HAS',NVALUE(NUM_NREGLO),' VALUES'
          WRITE(ERR,*)'STOP REGION HAS ',NVALUE(NUM_NREGHI),' VALUES'
          WRITE(ERR,*)'>>>> THEY MUST ALL HAVE THE SAME NUMBER OF VALUES
     *'
          ERROR_FLAG=1
        END IF
        IF (( DESCRIBE .EQ. 2 )) THEN
          IF (( NVALUE(NUM_RHOR).NE.NVALUE(NUM_MEDNUM))) THEN
            WRITE(ERR,*)'**************ERROR**************'
            WRITE(ERR,*)'MEDNUM HAS      ',NVALUE(NUM_MEDNUM),' VALUES'
            WRITE(ERR,*)'RHOR HAS        ',NVALUE(NUM_RHOR),' VALUES'
            WRITE(ERR,*)'>>>> THEY MUST BOTH HAVE THE SAME NUMBER OF VAL
     *UES'
            ERROR_FLAG=1
          END IF
        END IF
        IF ((VALUE(NUM_MEDNUM,1) .GE. 0)) THEN
          DO 5951 I=1,NVALUE(NUM_MEDNUM)
            RHORI=0.0
            MEDNUM=VALUE(NUM_MEDNUM,I)
            IF((DESCRIBE.EQ.2))RHORI=VALUE(NUM_RHOR,I)
            NREGLO=VALUE(NUM_NREGLO,I)
            NREGHI=VALUE(NUM_NREGHI,I)
            IF ((NREGHI.LE.NREGLO)) THEN
              IF (( NREGLO .GT. 0 .AND. NREGLO .LE.  12001 )) THEN
                MED(NREGLO)=MEDNUM
                IF((RHORI.GT.0.0))RHOR(NREGLO)=RHORI
                IF ((DESCRIBE.EQ.2)) THEN
                  IF ((RHORI.GT.0.0)) THEN
                    WRITE(6,5960)NREGLO,MEDNUM,RHORI
5960                FORMAT(' REGION(',I3,') = MATERIAL(',I2,'), RHOR =',
     *F8.5)
                  ELSE
                    WRITE(6,5970)NREGLO,MEDNUM
5970                FORMAT(' REGION(',I3,') = MATERIAL(',I2,'), RHOR = D
     *EFAULT')
                  END IF
                ELSE
                  WRITE(6,5980)NREGLO,MEDNUM
5980              FORMAT(' REGION(',I3,') = MATERIAL(',I2,')')
                END IF
              END IF
            ELSE
              DO 5991 K=NREGLO,NREGHI
                IF (( K .GT. 0 .AND. K .LE.  12001 )) THEN
                  MED(K)=MEDNUM
                  IF((RHORI.GT.0.0))RHOR(K)=RHORI
                END IF
5991          CONTINUE
5992          CONTINUE
              IF ((DESCRIBE.EQ.2)) THEN
                IF ((RHORI.GT.0.0)) THEN
                  WRITE(6,6000)NREGLO,NREGHI,MEDNUM,RHORI
6000              FORMAT(' REGION(',I3,') TO REGION(',I3,') = MATERIAL('
     *,I2,'), RHOR =',F8.5)
                ELSE
                  WRITE(6,6010)NREGLO,NREGHI,MEDNUM
6010              FORMAT(' REGION(',I3,') TO REGION(',I3,') = MATERIAL('
     *,I2,'), RHOR = DEFAULT')
                END IF
              ELSE
                WRITE(6,6020)NREGLO,NREGHI,MEDNUM
6020            FORMAT(' REGION(',I3,') TO REGION(',I3,') = MATERIAL(',I
     *2,')')
              END IF
            END IF
5951      CONTINUE
5952      CONTINUE
        END IF
      END IF
      IF ((DESCRIBE.EQ.1 .OR. DESCRIBE.EQ.3)) THEN
        IF (((NVALUE(NUM_NPLANLO).NE.NVALUE(NUM_MEDNUM)).OR. (NVALUE(NUM
     *  _NPLANLO).NE.NVALUE(NUM_MEDNUM)).OR. (NVALUE(NUM_NRADLO).NE.NVAL
     *  UE(NUM_MEDNUM)).OR. (NVALUE(NUM_NRADHI).NE.NVALUE(NUM_MEDNUM))))
     *   THEN
          WRITE(ERR,*)'**************ERROR**************'
          WRITE(ERR,*)'MEDNUM has      ',NVALUE(NUM_MEDNUM),' values'
          WRITE(ERR,*)'START PLANE has ',NVALUE(NUM_NPLANLO),' values'
          WRITE(ERR,*)'STOP PLANE has  ',NVALUE(NUM_NPLANHI),' values'
          WRITE(ERR,*)'START RING has  ',NVALUE(NUM_NRADLO),' values'
          WRITE(ERR,*)'STOP RING has   ',NVALUE(NUM_NRADHI),' values'
          WRITE(ERR,*)'>>>> They must all have the same number of values
     *'
          ERROR_FLAG=1
        END IF
        IF ((DESCRIBE.EQ.3 .AND. NVALUE(NUM_RHOR).NE.NVALUE(NUM_MEDNUM))
     *  ) THEN
          WRITE(ERR,*)'**************ERROR**************'
          WRITE(ERR,*)'MEDNUM HAS      ',NVALUE(NUM_MEDNUM),' VALUES'
          WRITE(ERR,*)'RHOR HAS        ',NVALUE(NUM_RHOR),' VALUES'
          WRITE(ERR,*)'>>>> THEY MUST BOTH HAVE THE SAME NUMBER OF VALUE
     *S'
          ERROR_FLAG=1
        END IF
        IF ((VALUE(NUM_MEDNUM,1) .GE. 0)) THEN
          DO 6031 I=1,NVALUE(NUM_MEDNUM)
            RHORI=0.0
            MEDNUM=VALUE(NUM_MEDNUM,I)
            IF((DESCRIBE.EQ.3))RHORI=VALUE(NUM_RHOR,I)
            NZLO=VALUE(NUM_NPLANLO,I)
            NZHI=VALUE(NUM_NPLANHI,I)
            NRLO=VALUE(NUM_NRADLO,I)
            NRHI=VALUE(NUM_NRADHI,I)
            IF ((NZLO.GT.NZHI)) THEN
              NZHI=NZLO
            END IF
            IF ((NRLO.GT.NRHI)) THEN
              NRHI=NRLO
            END IF
            DO 6041 IZ=NZLO,NZHI
              DO 6051 IX=NRLO,NRHI
                REGNUM=IZ+NZ*(IX-1)+1
                IF (( regnum .GT. 0 .AND. regnum .LE.  12001 )) THEN
                  MED(REGNUM)=MEDNUM
                  IF((RHORI.GT.0.0))RHOR(REGNUM)=RHORI
                  IF ((DESCRIBE.EQ.3)) THEN
                    IF ((RHORI.GT.0.0)) THEN
                      WRITE(6,6060)IZ,IX,MEDNUM,RHORI
6060                  FORMAT(' ZPLANE(',I3,'),RADIUS(',I3,') = MATERIAL(
     *',I2,') RHOR =',F8.5)
                    ELSE
                      WRITE(6,6070)IZ,IX,MEDNUM
6070                  FORMAT(' ZPLANE(',I3,'),RADIUS(',I3,') = MATERIAL(
     *',I2,') RHOR = DEFAULT')
                    END IF
                  ELSE
                    WRITE(6,6080)IZ,IX,MEDNUM
6080                FORMAT(' ZPLANE(',I3,'),RADIUS(',I3,') = MATERIAL(',
     *I2,')')
                  END IF
                END IF
6051          CONTINUE
6052          CONTINUE
6041        CONTINUE
6042        CONTINUE
6031      CONTINUE
6032      CONTINUE
        END IF
      END IF
      WRITE(6,6090)
6090  FORMAT(' ')
      RETURN
      ENTRY GEOMRZ_ISUMRY(IOUT)
      IF ((DESCRIBE.EQ.2.OR.DESCRIBE.EQ.3)) THEN
        WRITE(IOUT,100)
        RHORI=0.0
        DO 6101 I=2,NREG
          IF ((RHORI.GT.0.0 .AND. (RHOR(I).NE.RHORI .OR. MED(I).NE.MED(I
     *    -1)))) THEN
            NREGHI=I-1
            WRITE(IOUT,200)NREGLO,NREGHI,MED(NREGLO),RHORI
            RHORI=0.0
          END IF
          IF ((RHOR(I).GT.0.0 .AND. RHOR(I).NE.RHO(MED(I)) .AND. RHORI.E
     *    Q.0.0)) THEN
            NREGLO=I
            RHORI=RHOR(I)
          END IF
          IF ((I.EQ.NREG .AND. RHORI.GT.0.0)) THEN
            NREGHI=I
            WRITE(IOUT,200)NREGLO,NREGHI,MED(NREGLO),RHORI
          END IF
6101    CONTINUE
6102    CONTINUE
      END IF
100   FORMAT(/' ',T25,'NON-DEFAULT DENSITIES'// ' ',T10,'    Region #   
     *   Medium             Rhor  '/ ' ',T10,'from        to #          
     *   (g/cm**3)'/)
200   FORMAT(' ',T10,I3,2I11,F20.5)
      RETURN
      END
      SUBROUTINE GET_INPUT
      IMPLICIT NONE
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      CHARACTER*256 TEXT
      CHARACTER*256 KEEPTEXT
      CHARACTER*256 ORIGTEXT
      CHARACTER*256 TEXTPIECE
      CHARACTER*80 DELIM_START
      CHARACTER*80 DELIM_END
      CHARACTER*64 VNAME
      CHARACTER*64 VNAME1
      integer*4 CURSOR
      integer*4 IINDEX
      integer*4 iVNAME
      integer*4 IVAL
      integer*4 UNITNUM
      integer*4 ERR
      integer*4 I,J,K,CHECK
      integer*4 LINE
      integer*4 INT_VALUE
      integer*4 INT_VALUE_MIN
      integer*4 INT_VALUE_MAX
      logical ALLOWED
      logical START_FOUND
      integer*4 ifound,length,lll,Kconvert
      integer*4 lnblnk1
      logical IDEBUG
      character*1 blank
      integer*4 error_level
      integer*4 the_level
      data blank/' '/
      data error_level/1/
      save error_level
      IDEBUG = .false.
      ERROR_FLAG = 0
      IF ((IDEBUG)) THEN
        WRITE(6,6110)NMIN,NMAX, 100
6110    FORMAT(' Entering get_inputs seeking values', I5,' to', I5, '  w
     *ith a max allowed of',I5)
      END IF
      IF ((NMAX .LT. NMIN .OR. NMAX .GT. 100)) THEN
        WRITE(6,6120)NMAX, NMIN, 100
6120    FORMAT(//' Error entering get_inputs: Asked for values from',I5,
     *' to',I5, '    with a max of',I5//' This implies a bug in the call
     *ing routine'/ ' Fix it up and try again.  Stopping now.')
        STOP
      END IF
      ERR=i_errors
      UNITNUM=i_input
      DELIM_START=':START '//DELIMETER(:lnblnk1(DELIMETER))//':'
      DELIM_END=':STOP '//DELIMETER(:lnblnk1(DELIMETER))//':'
      DO 6131 Kconvert=1,lnblnk1(DELIM_START)
        CURSOR=ICHAR(DELIM_START(Kconvert:Kconvert))
        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
          CURSOR=CURSOR-32
          DELIM_START(Kconvert:Kconvert)=CHAR(CURSOR)
        END IF
6131  CONTINUE
6132  CONTINUE
      DO 6141 Kconvert=1,lnblnk1(DELIM_END)
        CURSOR=ICHAR(DELIM_END(Kconvert:Kconvert))
        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
          CURSOR=CURSOR-32
          DELIM_END(Kconvert:Kconvert)=CHAR(CURSOR)
        END IF
6141  CONTINUE
6142  CONTINUE
      IF ((IDEBUG)) THEN
        WRITE(6,6150)DELIM_START,DELIM_END
6150    FORMAT(' start and stop delimeters are:'/ A/A/)
      END IF
      DO 6161 I=NMIN,NMAX
        REWIND (UNITNUM)
        LINE=0
        CHECK=0
        ERROR_FLAGS(I)=0
        IF ((TYPE(I) .EQ. 0 .OR. TYPE(I) .EQ. 1)) THEN
          VALUE(I,1) = DEFAULT(I)
        END IF
        IF ((TYPE(I) .EQ. 3)) THEN
          VALUE(I,1) = 0
        END IF
        VNAME=VALUES_SOUGHT(I)
        iVNAME=lnblnk1(VNAME)
        IF (( ivname .LT. 1 )) THEN
          IF (( error_level .GT. 0 )) THEN
            write(ERR,*) ' ======================= Warning =============
     *======== '
            write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!
     *         '
            write(ERR,*) ' =============================================
     *======== '
          END IF
          ERROR_FLAG=1
          ERROR_FLAGS(I)=1
          goto 6170
        END IF
        DO 6181 Kconvert=1,lnblnk1(vname)
          CURSOR=ICHAR(vname(Kconvert:Kconvert))
          IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
            CURSOR=CURSOR-32
            vname(Kconvert:Kconvert)=CHAR(CURSOR)
          END IF
6181    CONTINUE
6182    CONTINUE
        iindex = 0
        IF ((DELIMETER .EQ. 'NONE')) THEN
          start_found = .true.
        ELSE
          start_found = .false.
        END IF
6191    IF(iindex.NE.0)GO TO 6192
6200      CONTINUE
          LINE=LINE+1
          IF (( start_found )) THEN
            READ(UNITNUM,END=6210,ERR=6220,FMT='(A256)') TEXT
          ELSE
            READ(UNITNUM,END=6230,ERR=6220,FMT='(A256)') TEXT
          END IF
          length = len(text)
6241      IF(index(text,blank).NE.1)GO TO 6242
            IF (( length .GE. 2 )) THEN
              text=text(2:)
            ELSE
              GO TO6242
            END IF
            length = length - 1
          GO TO 6241
6242      CONTINUE
          ifound = INDEX(text,'#')
          IF (( ifound .GT. 1 )) THEN
            text = text(1:ifound-1)
          ELSE
            IF (( ifound .EQ. 1 )) THEN
              text = blank
            END IF
          END IF
          ifound = INDEX(text,';')
          IF (( ifound .GT. 1 )) THEN
            text = text(1:ifound-1)
          ELSE
            IF (( ifound .EQ. 1 )) THEN
              text = blank
            END IF
          END IF
          length = lnblnk1(TEXT)
          TEXT=TEXT(:length)
          origtext = text(:length)
          DO 6251 Kconvert=1,lnblnk1(text)
            CURSOR=ICHAR(text(Kconvert:Kconvert))
            IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
              CURSOR=CURSOR-32
              text(Kconvert:Kconvert)=CHAR(CURSOR)
            END IF
6251      CONTINUE
6252      CONTINUE
          IF (( .NOT.start_found )) THEN
            IF ((INDEX(TEXT,DELIM_START) .NE. 0 )) THEN
              start_found = .true.
            END IF
            goto 6200
          END IF
          iindex=INDEX(TEXT,VNAME(:iVNAME))
          IF (( DELIMETER.NE.'NONE' )) THEN
            IF ((INDEX(TEXT,DELIM_END).NE.0)) THEN
              IF (( error_level .GT. 0 )) THEN
                WRITE (ERR,*) '***************ERROR***************'
                WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUG
     *          HT(I))), '<<',' NOT FOUND'
                WRITE (ERR,*) 'END OF DELIMETER: ',DELIMETER(:lnblnk1(DE
     *          LIMETER))
              END IF
              ERROR_FLAG=1
              ERROR_FLAGS(I)=1
              GOTO 6170
            END IF
          END IF
        GO TO 6191
6192    CONTINUE
        CHECK=0
        IF (( idebug )) THEN
          write(i_log,*) ' ******* Found: '
          write(i_log,'(a,$)') ' text:     '
          length = lnblnk1(text)
          IF (( length .GT. 0 )) THEN
            DO 6261 lll=1,length
              write(i_log,'(a1,$)') text(lll:lll)
6261        CONTINUE
6262        CONTINUE
            write(i_log,*)
          END IF
          write(i_log,'(a,$)') ' origtext: '
          length = lnblnk1(origtext)
          IF (( length .GT. 0 )) THEN
            DO 6271 lll=1,length
              write(i_log,'(a1,$)') origtext(lll:lll)
6271        CONTINUE
6272        CONTINUE
            write(i_log,*)
          END IF
        END IF
        IINDEX=IINDEX+iVNAME
        TEXT=TEXT(IINDEX:)
        origtext=origtext(iindex:)
        IF (( idebug )) THEN
          write(i_log,*) ' After removing vname: '
          write(i_log,'(a,$)') ' text:     '
          length = lnblnk1(text)
          IF (( length .GT. 0 )) THEN
            DO 6281 lll=1,length
              write(i_log,'(a1,$)') text(lll:lll)
6281        CONTINUE
6282        CONTINUE
            write(i_log,*)
          END IF
          write(i_log,'(a,$)') ' origtext: '
          length = lnblnk1(origtext)
          IF (( length .GT. 0 )) THEN
            DO 6291 lll=1,length
              write(i_log,'(a1,$)') origtext(lll:lll)
6291        CONTINUE
6292        CONTINUE
            write(i_log,*)
          END IF
        END IF
        IINDEX=INDEX(TEXT,'=')
        IF ((IINDEX.NE.0)) THEN
          TEXT=TEXT(IINDEX+1:)
          origtext=origtext(iindex+1:)
        ELSE
          IINDEX=INDEX(TEXT,':')
          IF ((IINDEX.NE.0)) THEN
            TEXT=TEXT(IINDEX+1:)
            origtext=origtext(iindex+1:)
          END IF
        END IF
        IF (( idebug )) THEN
          write(i_log,*) ' After removing leading equals: '
          write(i_log,'(a,$)') ' text:     '
          length = lnblnk1(text)
          IF (( length .GT. 0 )) THEN
            DO 6301 lll=1,length
              write(i_log,'(a1,$)') text(lll:lll)
6301        CONTINUE
6302        CONTINUE
            write(i_log,*)
          END IF
          write(i_log,'(a,$)') ' origtext: '
          length = lnblnk1(origtext)
          IF (( length .GT. 0 )) THEN
            DO 6311 lll=1,length
              write(i_log,'(a1,$)') origtext(lll:lll)
6311        CONTINUE
6312        CONTINUE
            write(i_log,*)
          END IF
        END IF
        IF (( (lnblnk1(TEXT).EQ.0) .OR. (lnblnk1(TEXT).EQ.1) )) THEN
          IF ((vname(:ivname).EQ.'TITLE')) THEN
            READ (UNITNUM,FMT='(A256)') TEXTPIECE
            IF ((lnblnk1(TEXTPIECE).NE.0)) THEN
              TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE))
              length = len(text)
6321          IF(index(text,blank).NE.1)GO TO 6322
                IF (( length .GE. 2 )) THEN
                  text=text(2:)
                ELSE
                  GO TO6322
                END IF
                length = length - 1
              GO TO 6321
6322          CONTINUE
              length = len(origtext)
6331          IF(index(origtext,blank).NE.1)GO TO 6332
                IF (( length .GE. 2 )) THEN
                  origtext=origtext(2:)
                ELSE
                  GO TO6332
                END IF
                length = length - 1
              GO TO 6331
6332          CONTINUE
              GOTO 6340
            END IF
          END IF
          IF (( error_level .GT. 0 )) THEN
            WRITE (ERR,*) '*************ERROR*************'
            WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
            WRITE (ERR,*) 'VALUE NOT THERE!!'
          END IF
          ERROR_FLAG=1
          ERROR_FLAGS(I)=1
          RETURN
        END IF
6340    CONTINUE
        iindex = index(text,'DEFAULT')
        IF (( iindex .NE. 0 )) THEN
          IF (( type(i) .NE. 2 )) THEN
            IF (( type(i) .NE. 3 )) THEN
              VALUE(I,1)=DEFAULT(I)
            ELSE
              VALUE(I,1)=0
            END IF
            goto 6170
          END IF
        END IF
        IF (((TYPE(I) .EQ. 0).OR.(TYPE(I) .EQ. 1))) THEN
          IVAL=1
          IF (( idebug )) THEN
            write(i_log,*) ' *** Reading an integer or a real value! '
          END IF
6351      CONTINUE
            IF (( idebug )) THEN
              write(i_log,*) ' In LOOP, ival = ',ival
            END IF
            IF ((lnblnk1(TEXT).EQ.0)) THEN
              IF (( error_level .GT. 0 )) THEN
                WRITE(ERR,*) '*************ERROR*************'
                WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                WRITE (ERR,*) 'VALUE NOT THERE!!'
              END IF
              ERROR_FLAG=1
              ERROR_FLAGS(I)=1
              RETURN
            END IF
            READ(TEXT,END=6360,ERR=6370,FMT=*) VALUE(I,IVAL)
            IF (( idebug )) THEN
              write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL)
            END IF
            IF (((VALUE(I,IVAL).GT.VALUE_MAX(I)).OR.(VALUE(I,IVAL).LT.VA
     *      LUE_MIN(I)))) THEN
              IF ((TYPE(I).EQ.0)) THEN
                INT_VALUE=DEFAULT(I)
                IF (( error_level .GT. 0 )) THEN
                  WRITE(ERR,*) '************WARNING************'
                  WRITE(ERR,6380) INT_VALUE, VALUES_SOUGHT(I)(:lnblnk1(V
     *            ALUES_SOUGHT(I)))
                END IF
6380            FORMAT ( 'Default= ',I9,' used for: ', A )
                INT_VALUE=VALUE(I,IVAL)
                INT_VALUE_MIN=VALUE_MIN(I)
                INT_VALUE_MAX=VALUE_MAX(I)
                IF (( error_level .GT. 0 )) THEN
                  WRITE(ERR,6390) VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGH
     *            T(I))), INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX
                END IF
6390            FORMAT (A,'=', I9,' should be between ', I9,' and ', I9)
              END IF
              IF ((TYPE(I).EQ.1)) THEN
                IF (( error_level .GT. 0 )) THEN
                  WRITE(ERR,*) '************WARNING************'
                  WRITE(ERR,6400) DEFAULT(I), VALUES_SOUGHT(I)(:lnblnk1(
     *            VALUES_SOUGHT(I)))
6400              FORMAT ( 'Default= ',F12.6,' used for: ', A )
                  WRITE(ERR,6410) VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGH
     *            T(I))), VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I)
6410              FORMAT (A,'=', F12.6,' should be between ', G14.6,' an
     *d ', G14.6)
                END IF
              END IF
              VALUE(I,IVAL)=DEFAULT(I)
            END IF
            IF((IVAL .EQ. NVALUE(I)))GO TO6352
            IF (((INDEX(TEXT,',').NE.0).OR.(lnblnk1(TEXT).EQ.0))) THEN
              IF (( idebug )) THEN
                write(i_log,*) ' A comma or a blank text found -> '
                write(i_log,*) ' searching for further input'
              END IF
              TEXT=TEXT(INDEX(TEXT,',')+1:)
6421          IF(lnblnk1(TEXT).NE.0)GO TO 6422
                IF (( idebug )) THEN
                  write(i_log,*) ' Empty text -> reading next line! '
                END IF
                LINE=LINE+1
                READ (UNITNUM,END=6360,ERR=6370,FMT='(A256)') TEXT
                length = len(text)
6431            IF(index(text,blank).NE.1)GO TO 6432
                  IF (( length .GE. 2 )) THEN
                    text=text(2:)
                  ELSE
                    GO TO6432
                  END IF
                  length = length - 1
                GO TO 6431
6432            CONTINUE
                ifound = INDEX(text,'#')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                ifound = INDEX(text,';')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                length = lnblnk1(TEXT)
                TEXT=TEXT(:length)
                origtext = text(:length)
                DO 6441 Kconvert=1,lnblnk1(text)
                  CURSOR=ICHAR(text(Kconvert:Kconvert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                    CURSOR=CURSOR-32
                    text(Kconvert:Kconvert)=CHAR(CURSOR)
                  END IF
6441            CONTINUE
6442            CONTINUE
                DO 6451 K=1,NMAX
                  vname1 = VALUES_SOUGHT(K)
                  length = lnblnk1(vname1)
                  IF (( length .GT. 0 )) THEN
                    length = len(vname1)
6461                IF(index(vname1,blank).NE.1)GO TO 6462
                      IF (( length .GE. 2 )) THEN
                        vname1=vname1(2:)
                      ELSE
                        GO TO6462
                      END IF
                      length = length - 1
                    GO TO 6461
6462                CONTINUE
                    DO 6471 Kconvert=1,lnblnk1(vname1)
                      CURSOR=ICHAR(vname1(Kconvert:Kconvert))
                      IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                        CURSOR=CURSOR-32
                        vname1(Kconvert:Kconvert)=CHAR(CURSOR)
                      END IF
6471                CONTINUE
6472                CONTINUE
                    IF ((INDEX(TEXT,vname1(:length)).NE.0)) THEN
                      IF (( error_level .GT. 0 )) THEN
                        WRITE(ERR,*) '************ERROR************'
                        WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                        WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)), '<--C
     *OMMA INDICATES ANOTHER INPUT'
                        WRITE(ERR,*) 'SEARCHED NEXT LINE: ', TEXT(:lnbln
     *                  k1(TEXT))
                        WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED'
                      END IF
                      ERROR_FLAG=1
                      ERROR_FLAGS(I)=1
                    END IF
                  END IF
6451            CONTINUE
6452            CONTINUE
                IF (( idebug )) THEN
                  write(i_log,*) ' Next line: '
                  write(i_log,'(a,$)') ' text:     '
                  length = lnblnk1(text)
                  IF (( length .GT. 0 )) THEN
                    DO 6481 lll=1,length
                      write(i_log,'(a1,$)') text(lll:lll)
6481                CONTINUE
6482                CONTINUE
                    write(i_log,*)
                  END IF
                  write(i_log,'(a,$)') ' origtext: '
                  length = lnblnk1(origtext)
                  IF (( length .GT. 0 )) THEN
                    DO 6491 lll=1,length
                      write(i_log,'(a1,$)') origtext(lll:lll)
6491                CONTINUE
6492                CONTINUE
                    write(i_log,*)
                  END IF
                END IF
              GO TO 6421
6422          CONTINUE
            ELSE
              GO TO6352
            END IF
            IVAL=IVAL+1
          GO TO 6351
6352      CONTINUE
          IF (((NVALUE(I).NE.0).AND.(NVALUE(I).NE.IVAL))) THEN
            IF (( error_level .GT. 0 )) THEN
              WRITE (ERR,*) '**************ERROR**************'
              WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I)
              WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)'
              WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED'
            END IF
            ERROR_FLAG=1
            ERROR_FLAGS(I)=1
          ELSE
            NVALUE(I)=IVAL
          END IF
6360      CONTINUE
        END IF
        IF (((TYPE(I) .EQ. 2) .OR. (TYPE(I) .EQ. 3))) THEN
          IVAL=1
          IF (( idebug )) THEN
            write(i_log,*) ' Trying to read a string! '
          END IF
6501      CONTINUE
            IF (( idebug )) THEN
              write(i_log,*) ' In LOOP, ival = ',ival
            END IF
            IF ((lnblnk1(TEXT).EQ.0)) THEN
              IF (( error_level .GT. 0 )) THEN
                WRITE(ERR,*) '*************ERROR*************'
                WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                WRITE (ERR,*) 'VALUE NOT THERE!!'
              END IF
              ERROR_FLAG=1
              ERROR_FLAGS(I)=1
              RETURN
            END IF
            IF ((vname(:ivname).EQ.'TITLE')) THEN
              TEXTPIECE=origtext
              GOTO 6510
            END IF
            iindex = INDEX(origtext,',')
            IF (( iindex .NE. 0 )) THEN
              TEXTPIECE=origtext(:iindex-1)
            ELSE
              TEXTPIECE=origtext
            END IF
6510        CONTINUE
            READ(TEXTPIECE,ERR=6520,FMT='(A256)') CHAR_VALUE(I,IVAL)
            length = len(CHAR_VALUE(I,IVAL))
6531        IF(index(CHAR_VALUE(I,IVAL),blank).NE.1)GO TO 6532
              IF (( length .GE. 2 )) THEN
                CHAR_VALUE(I,IVAL)=CHAR_VALUE(I,IVAL)(2:)
              ELSE
                GO TO6532
              END IF
              length = length - 1
            GO TO 6531
6532        CONTINUE
            IF (( idebug )) THEN
              write(i_log,*) ' Read the following char string: '
              length = lnblnk1(CHAR_VALUE(I,IVAL))
              IF (( length .GT. 0 )) THEN
                DO 6541 lll=1,length
                  write(i_log,'(a1,$)') CHAR_VALUE(I,IVAL)(lll:lll)
6541            CONTINUE
6542            CONTINUE
                write(i_log,*)
              END IF
            END IF
            IF ((TYPE(I) .EQ. 3)) THEN
              DO 6551 Kconvert=1,lnblnk1(CHAR_VALUE(I,IVAL))
                CURSOR=ICHAR(CHAR_VALUE(I,IVAL)(Kconvert:Kconvert))
                IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                  CURSOR=CURSOR-32
                  CHAR_VALUE(I,IVAL)(Kconvert:Kconvert)=CHAR(CURSOR)
                END IF
6551          CONTINUE
6552          CONTINUE
              ALLOWED=.FALSE.
              DO 6561 K=0,5
                vname1 = ALLOWED_INPUTS(I,K)
                length = len(ALLOWED_INPUTS(I,K))
6571            IF(index(ALLOWED_INPUTS(I,K),blank).NE.1)GO TO 6572
                  IF (( length .GE. 2 )) THEN
                    ALLOWED_INPUTS(I,K)=ALLOWED_INPUTS(I,K)(2:)
                  ELSE
                    GO TO6572
                  END IF
                  length = length - 1
                GO TO 6571
6572            CONTINUE
                DO 6581 Kconvert=1,lnblnk1(ALLOWED_INPUTS(I,K))
                  CURSOR=ICHAR(ALLOWED_INPUTS(I,K)(Kconvert:Kconvert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                    CURSOR=CURSOR-32
                    ALLOWED_INPUTS(I,K)(Kconvert:Kconvert)=CHAR(CURSOR)
                  END IF
6581            CONTINUE
6582            CONTINUE
                IF ((ALLOWED_INPUTS(I,K).EQ.CHAR_VALUE(I,IVAL))) THEN
                  ALLOWED=.TRUE.
                  VALUE(I,IVAL)=K
                  IF (( idebug )) THEN
                    write(i_log,*) ' Found a allowed_value match ',k
                  END IF
                END IF
6561          CONTINUE
6562          CONTINUE
              IF ((.NOT.ALLOWED)) THEN
                WRITE(ERR,*) '*************ERROR*************'
                IF ((IVAL.NE.1)) THEN
                  WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                  WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY'
                  WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND
     * VALUE'
                ELSE
                  WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                  WRITE(ERR,*) 'INPUT-->', CHAR_VALUE(I,IVAL)(:lnblnk1(C
     *            HAR_VALUE(I,IVAL))), '<--NOT ALLOWED'
                  WRITE(ERR,*) 'OPTIONS ARE:'
                  WRITE(ERR,1940) (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_
     *            INPUTS(I,K))),K=0,5)
                END IF
1940            FORMAT(A40)
                ERROR_FLAG=1
                ERROR_FLAGS(I)=1
              END IF
            END IF
            IF ((vname(:ivname).EQ.'TITLE')) THEN
              GO TO6502
            END IF
            DO 6591 K=1,LEN(KEEPTEXT)
              KEEPTEXT(K:K)=' '
6591        CONTINUE
6592        CONTINUE
            KEEPTEXT(:lnblnk1(TEXT))=TEXT
            iindex = INDEX(TEXT,',')
            IF (( iindex .NE. 0 .OR. lnblnk1(TEXT).EQ.0 )) THEN
              TEXT=TEXT(INDEX(TEXT,',')+1:)
              origtext=origtext(iindex+1:)
6601          IF(lnblnk1(TEXT).NE.0)GO TO 6602
                LINE=LINE+1
                READ (UNITNUM,ERR=6520,FMT='(A256)') TEXT
                length = len(text)
6611            IF(index(text,blank).NE.1)GO TO 6612
                  IF (( length .GE. 2 )) THEN
                    text=text(2:)
                  ELSE
                    GO TO6612
                  END IF
                  length = length - 1
                GO TO 6611
6612            CONTINUE
                ifound = INDEX(text,'#')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                ifound = INDEX(text,';')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                length = lnblnk1(TEXT)
                TEXT=TEXT(:length)
                origtext = text(:length)
                DO 6621 Kconvert=1,lnblnk1(text)
                  CURSOR=ICHAR(text(Kconvert:Kconvert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                    CURSOR=CURSOR-32
                    text(Kconvert:Kconvert)=CHAR(CURSOR)
                  END IF
6621            CONTINUE
6622            CONTINUE
                DO 6631 K=1,NMAX
                  vname1 = VALUES_SOUGHT(K)
                  length = lnblnk1(vname1)
                  IF (( length .GT. 0 )) THEN
                    length = len(vname1)
6641                IF(index(vname1,blank).NE.1)GO TO 6642
                      IF (( length .GE. 2 )) THEN
                        vname1=vname1(2:)
                      ELSE
                        GO TO6642
                      END IF
                      length = length - 1
                    GO TO 6641
6642                CONTINUE
                    DO 6651 Kconvert=1,lnblnk1(vname1)
                      CURSOR=ICHAR(vname1(Kconvert:Kconvert))
                      IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                        CURSOR=CURSOR-32
                        vname1(Kconvert:Kconvert)=CHAR(CURSOR)
                      END IF
6651                CONTINUE
6652                CONTINUE
                    IF ((INDEX(TEXT,vname1(:length)).NE.0)) THEN
                      WRITE(ERR,*) '************ERROR************'
                      WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                      WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)), '<--COM
     *MA INDICATES ANOTHER INPUT'
                      WRITE(ERR,*) 'SEARCHED NEXT LINE: ', TEXT(:lnblnk1
     *                (TEXT))
                      WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED'
                      ERROR_FLAG=1
                      ERROR_FLAGS(I)=1
                    END IF
                  END IF
6631            CONTINUE
6632            CONTINUE
              GO TO 6601
6602          CONTINUE
            ELSE
              GO TO6502
            END IF
            IVAL=IVAL+1
          GO TO 6501
6502      CONTINUE
          IF (((NVALUE(I).NE.0).AND.(NVALUE(I).NE.IVAL))) THEN
            IF (( error_level .GT. 0 )) THEN
              WRITE (ERR,*) '*******************ERROR*******************
     *'
              WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I)
              WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)'
              WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED'
            END IF
            ERROR_FLAG=1
            ERROR_FLAGS(I)=1
          ELSE
            NVALUE(I)=IVAL
          END IF
        END IF
        goto 6170
6210    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '******************ERROR***********************'
          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND'
          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER'
          WRITE (ERR,*) 'VALUE SOUGHT: >>', VALUES_SOUGHT(I)(:lnblnk1(VA
     *    LUES_SOUGHT(I))),'<<'
          WRITE (ERR,*) 'END DELIMETER: >>', DELIM_END(:lnblnk1(DELIM_EN
     *    D)),'<<'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
        goto 6170
6230    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '******************ERROR***********************'
          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND'
          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER'
          WRITE (ERR,*) 'VALUE SOUGHT: >>', VALUES_SOUGHT(I)(:lnblnk1(VA
     *    LUES_SOUGHT(I))),'<<'
          WRITE (ERR,*) 'START DELIMETER: >>', DELIM_START(:lnblnk1(DELI
     *    M_START)),'<<'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
        goto 6170
6370    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '***************ERROR***************'
          IF ((IVAL.GT.1)) THEN
            J=IVAL
          ELSE
            J=1
          END IF
          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I)
          WRITE (ERR,*) 'LINE #',LINE
          WRITE (ERR,*) 'COULD NOT READ THE VALUE!!'
          WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...'
          WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPU
     *T?'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
        GOTO 6170
6520    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '***************ERROR***************'
          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I)
          WRITE (ERR,*) 'LINE #',LINE
          WRITE (ERR,*) 'COULD NOT READ THE STRING !!'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
6170    CONTINUE
6161  CONTINUE
6162  CONTINUE
      RETURN
6220  WRITE (ERR,*) '***************ERROR***************'
      WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE
      goto 6660
6660  CONTINUE
      ERROR_FLAG=1
      ERROR_FLAGS(I)=1
      RETURN
      entry get_input_set_error_level(the_level)
      error_level = the_level
      return
      END
      subroutine get_transport_parameter(ounit)
      implicit none
      character*80 line
      character*512 toUpper
      integer*4 ounit
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      COMMON/BOUNDS/ECUT( 12001),PCUT( 12001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      common/ET_control/ smaxir( 12001),estepe,ximax,  skindepth_for_bca
     *,transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,10), eno_array(200,10), eno_atbin_array(200,10), n
     *_shell(10), radc_flag,  ibcmp( 12001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(10), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),
     *eii_sh(40),  eii_nshells(100),  eii_nsh(10),  eii_first(10,50),  e
     *ii_no(10,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/rayleigh_inputs/iray_ff_media(10),iray_ff_file(10)
      character*24 iray_ff_media
      character*128 iray_ff_file
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      integer*4 ival,num_ecut,num_pcut,num_smax,num_incoh,num_radc,num_c
     *oh,num_relax, num_pe_ang,num_brems_ang,num_brems_cs,num_pair_cs, n
     *um_ffmed,num_ffiles, num_pair_ang,num_eii,num_eii_L,num_estepe,num
     *_ximax,num_triplet, num_pxsec,num_pxsec_out, num_cxsec, num_photon
     *uc, num_photonuc_xsec, num_efield, num_bfield, num_emlmt, num_spin
     *,num_bca,num_alg,num_skin,itmp,iitmp,i,j,k,istart,iend, egs_open_f
     *ile,lnblnk1
      logical ecut_inregions,pcut_inregions,smax_inregions, incoh_inregi
     *ons,coh_inregions,relax_inregions, pe_inregions,aux_inregions,phot
     *onuc_inregions
      character*15 output_strings(14)
      save output_strings,line
      save ecut_inregions,pcut_inregions,smax_inregions, incoh_inregions
     *,coh_inregions,relax_inregions, pe_inregions,aux_inregions,photonu
     *c_inregions, num_photonuc
      DO 6671 k=1,80
        line(k:k) = '='
6671  CONTINUE
6672  CONTINUE
      delimeter = 'MC TRANSPORT PARAMETER'
      ival = 0
      ecut_inregions=.false.
      pcut_inregions=.false.
      smax_inregions=.false.
      incoh_inregions=.false.
      coh_inregions=.false.
      relax_inregions=.false.
      pe_inregions=.false.
      aux_inregions=.false.
      photonuc_inregions=.false.
      i_errors=15
      i_errors=egs_open_file(i_errors,0,1,'.errors')
      write(i_errors,*) ' If you are not trying to reset transport param
     *eters, '
      write(i_errors,*) ' ignore all the output until the message '
      write(i_errors,*) ' ******************** end input transport param
     *eter *********************** '
      write(i_errors,*)
      ival = ival + 1
      num_ecut = ival
      values_sought(ival) = 'Global ECUT'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      num_pcut = ival
      values_sought(ival) = 'Global PCUT'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      num_smax = ival
      values_sought(ival) = 'Global SMAX'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1e15
      default(ival) = 1e10
      ival = ival + 1
      num_incoh = ival
      values_sought(ival) = 'Bound Compton scattering'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      allowed_inputs(ival,4) = 'Simple'
      allowed_inputs(ival,5) = 'norej'
      ival = ival + 1
      num_radc = ival
      values_sought(ival) = 'Radiative Compton corrections'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_coh = ival
      values_sought(ival) = 'Rayleigh scattering'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      allowed_inputs(ival,4) = 'custom'
      ival = ival + 1
      num_relax = ival
      values_sought(ival) = 'Atomic relaxations'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      allowed_inputs(ival,4) = 'eadl'
      allowed_inputs(ival,5) = 'simple'
      ival = ival + 1
      num_pe_ang = ival
      values_sought(ival) = 'Photoelectron angular sampling'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      ival = ival + 1
      num_brems_ang = ival
      values_sought(ival) = 'Brems angular sampling'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Simple'
      allowed_inputs(ival,1) = 'KM'
      ival = ival + 1
      num_brems_cs = ival
      values_sought(ival) = 'Brems cross sections'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'BH'
      allowed_inputs(ival,1) = 'NIST'
      allowed_inputs(ival,2) = 'NRC'
      ival = ival + 1
      num_pair_ang = ival
      values_sought(ival) = 'Pair angular sampling'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'Simple'
      allowed_inputs(ival,2) = 'KM'
      allowed_inputs(ival,3) = 'Uniform'
      allowed_inputs(ival,4) = 'Blend'
      ival = ival + 1
      num_pair_cs = ival
      values_sought(ival) = 'Pair cross sections'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'BH'
      allowed_inputs(ival,1) = 'NRC'
      ival = ival + 1
      num_triplet = ival
      values_sought(ival) = 'Triplet production'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_spin = ival
      values_sought(ival) = 'Spin effects'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_eii = ival
      values_sought(ival) = 'Electron Impact Ionization'
      nvalue(ival) = 1
      type(ival) = 2
      ival = ival + 1
      num_eii_L= ival
      values_sought(ival) = 'scale L EII cross-sections'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0.0
      value_max(ival) = 1.0e+9
      default(ival) = 1.0
      ival = ival + 1
      num_estepe = ival
      values_sought(ival) = 'ESTEPE'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 1e-5
      value_max(ival) = 1
      default(ival) = 0.25
      ival = ival + 1
      num_ximax = ival
      values_sought(ival) = 'XImax'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1
      default(ival) = 0.5
      ival = ival + 1
      num_bca = ival
      values_sought(ival) = 'Boundary crossing algorithm'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Exact'
      allowed_inputs(ival,1) = 'PRESTA-I'
      ival = ival + 1
      num_skin = ival
      values_sought(ival) = 'Skin depth for BCA'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = -1
      value_max(ival) = 1e15
      default(ival) = 3
      ival = ival + 1
      num_alg = ival
      values_sought(ival) = 'Electron-step algorithm'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'PRESTA-II'
      allowed_inputs(ival,1) = 'PRESTA-I'
      ival = ival + 1
      num_pxsec = ival
      values_sought(ival) = 'Photon cross sections'
      nvalue(ival) = 1
      type(ival) = 2
      ival = ival + 1
      num_pxsec_out = ival
      values_sought(ival) = 'Photon cross-sections output'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_cxsec = ival
      values_sought(ival) = 'Compton cross sections'
      nvalue(ival) = 1
      type(ival) = 2
      ival = ival + 1
      num_efield = ival
      values_sought(ival) = 'Electric Field'
      nvalue(ival) = 3
      type(ival) = 1
      value_min(ival) = -1e15
      value_max(ival) = 1e15
      default(ival) = 0
      ival = ival + 1
      num_bfield = ival
      values_sought(ival) = 'Magnetic Field'
      nvalue(ival) = 3
      type(ival) = 1
      value_min(ival) = -1e10
      value_max(ival) = 1e10
      default(ival) = 0
      ival = ival + 1
      num_emlmt = ival
      values_sought(ival) = 'EM ESTEPE'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0.0
      value_max(ival) = 1.0
      default(ival) = 0.02
      ival = ival + 1
      num_photonuc = ival
      values_sought(ival) = 'Photonuclear attenuation'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      ival = ival + 1
      num_photonuc_xsec = ival
      values_sought(ival) = 'Photonuclear cross sections'
      nvalue(ival) = 1
      type(ival) = 2
      Nmin = num_ecut
      Nmax = num_photonuc_xsec
      CALL GET_INPUT
      IF (( error_flags(num_ecut) .EQ. 0 )) THEN
        DO 6681 j=1, 12001
          ecut(j) = value(num_ecut,1)
6681    CONTINUE
6682    CONTINUE
      END IF
      IF (( error_flags(num_pcut) .EQ. 0 )) THEN
        DO 6691 j=1, 12001
          pcut(j) = value(num_pcut,1)
6691    CONTINUE
6692    CONTINUE
      END IF
      IF (( error_flags(num_smax) .EQ. 0 )) THEN
        DO 6701 j=1, 12001
          smaxir(j) = value(num_smax,1)
6701    CONTINUE
6702    CONTINUE
      END IF
      IF (( error_flags(num_brems_ang) .EQ. 0 )) THEN
        ibrdst = value(num_brems_ang,1)
      END IF
      IF (( error_flags(num_brems_cs) .EQ. 0 )) THEN
        ibr_nist = value(num_brems_cs,1)
      END IF
      IF (( error_flags(num_radc) .EQ. 0 )) THEN
        radc_flag = value(num_radc,1)
      END IF
      IF (( error_flags(num_pair_ang) .EQ. 0 )) THEN
        iprdst = value(num_pair_ang,1)
      END IF
      IF (( error_flags(num_pair_cs) .EQ. 0 )) THEN
        pair_nrc = value(num_pair_cs,1)
      END IF
      IF (( error_flags(num_triplet) .EQ. 0 )) THEN
        itriplet = value(num_triplet,1)
      END IF
      IF (( error_flags(num_eii_L) .EQ. 0 )) THEN
        eii_L_factor = value(num_eii_L,1)
      END IF
      IF (( error_flags(num_estepe) .EQ. 0 )) THEN
        estepe = value(num_estepe,1)
      END IF
      IF (( error_flags(num_ximax) .EQ. 0 )) THEN
        ximax = value(num_ximax,1)
      END IF
      IF (( error_flags(num_bca) .EQ. 0 )) THEN
        bca_algorithm = value(num_bca,1)
        IF (( bca_algorithm .EQ. 0 )) THEN
          exact_bca = .true.
        END IF
      END IF
      IF (( error_flags(num_alg) .EQ. 0 )) THEN
        transport_algorithm = value(num_alg,1)
      END IF
      IF (( error_flags(num_skin) .EQ. 0 )) THEN
        skindepth_for_bca = value(num_skin,1)
      END IF
      IF (( error_flags(num_spin) .EQ. 0 )) THEN
        itmp = value(num_spin,1)
        IF (( itmp .EQ. 1 )) THEN
          spin_effects = .true.
        ELSE
          spin_effects = .false.
        END IF
      END IF
      IF (( error_flags(num_eii) .EQ. 0 )) THEN
        eii_xfile = char_value(num_eii,1)
        eii_flag=1
        IF ((toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'ON' .OR. toUppe
     *  r(eii_xfile(:lnblnk1(eii_xfile))).eq.'IK' )) THEN
          eii_xfile = 'ik'
          write(i_log,*) '==> Using default EII data compilation ', eii_
     *    xfile(:lnblnk1(eii_xfile))
        ELSE IF((toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'OFF')) THEN
          eii_xfile='Off'
          eii_flag=0
        ELSE
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) '==> Using non-default EII data compilation ',
     *    eii_xfile(:lnblnk1(eii_xfile))
        END IF
      END IF
      IF (( error_flags(num_pxsec) .EQ. 0 )) THEN
        photon_xsections = char_value(num_pxsec,1)
        IF (( toUpper( photon_xsections(:lnblnk1(photon_xsections)) ) .E
     *  Q. 'MCDF-XCOM' )) THEN
          mcdf_pe_xsections = .true.
          photon_xsections = 'xcom'
        ELSE IF(( toUpper( photon_xsections(:lnblnk1(photon_xsections))
     *  ) .EQ. 'MCDF-EPDL' )) THEN
          mcdf_pe_xsections = .true.
          photon_xsections = 'epdl'
        ELSE
          mcdf_pe_xsections = .false.
        END IF
      END IF
      IF (( error_flags(num_pxsec_out) .EQ. 0 )) THEN
        xsec_out = value(num_pxsec_out,1)
      END IF
      IF (( error_flags(num_cxsec) .EQ. 0 )) THEN
        comp_xsections = char_value(num_cxsec,1)
      END IF
      IF (( error_flags(num_photonuc_xsec) .EQ. 0 )) THEN
        photonuc_xsections = char_value(num_photonuc_xsec,1)
      END IF
      IF (( error_flags(num_efield) .EQ. 0 )) THEN
        ExIN = value(num_efield,1)
        EyIN = value(num_efield,2)
        EzIN = value(num_efield,3)
        IF (( error_flags(num_emlmt) .EQ. 0 )) THEN
          EMLMTIN=value(num_emlmt,1)
        END IF
        IF (( ExIN**2+EyIN**2+EzIN**2 .GT. 0 )) THEN
          emfield_on=.true.
        END IF
      END IF
      IF (( error_flags(num_bfield) .EQ. 0 )) THEN
        BxIN = value(num_bfield,1)
        ByIN = value(num_bfield,2)
        BzIN = value(num_bfield,3)
        Bx=BxIN
        By=ByIN
        Bz=BzIN
        Bx_new=BxIN
        By_new=ByIN
        Bz_new=BzIN
        IF (( error_flags(num_emlmt) .EQ. 0 )) THEN
          EMLMTIN=value(num_emlmt,1)
        END IF
        IF (( BxIN**2+ByIN**2+BzIN**2 .GT. 0 )) THEN
          emfield_on=.true.
        END IF
      END IF
      IF (( error_flags(num_coh) .EQ. 0 )) THEN
        IF ((value(num_coh,1) .EQ. 4)) THEN
          write(*,'(/a/)') ' ===> custom ff requested!'
          ival = ival + 1
          num_ffmed = ival
          values_sought(ival) = 'ff media names'
          type(ival) = 2
          nvalue(ival) = 0
          ival = ival + 1
          num_ffiles = ival
          values_sought(ival) = 'ff file names'
          type(ival) = 2
          nvalue(ival) = 0
          Nmin = num_ffmed
          Nmax = num_ffiles
          CALL GET_INPUT
          IF (( error_flags(num_ffmed) .GT. 0 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a/,a,I3)') 'Error reading custom ff! Terminati
     *ng ...', ' error_flag = ', error_flags(num_ffmed)
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          IF (( error_flags(num_ffiles) .GT. 0 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a/,a,I3)') 'Error reading ff file names! Termi
     *nating ...', ' error_flag = ', error_flags(num_ffiles)
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          IF ((nvalue(num_ffmed).GT.10)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a,a,i3,a)') '***** Number of media with custom
     * ff larger ', 'than maximum number of media $MXMED = ',10, ' incre
     *ase $MXMED and try again!!!'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          DO 6711 i=1,nvalue(num_ffmed)
            iray_ff_media(i) = char_value(num_ffmed,i)
            iray_ff_file(i) = char_value(num_ffiles,i)
6711      CONTINUE
6712      CONTINUE
          value(num_coh,1) = 1
        END IF
        write(*,'(/)')
      END IF
      aux_inregions = .false.
      IF (( error_flags(num_incoh) .EQ. 0 )) THEN
        write(i_log,*) 'Bound Compton start region'
        itmp = value(num_incoh,1)
        IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
          ival = ival + 1
          values_sought(ival) = 'Bound Compton start region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  12001
          default(ival) = 1
          ival = ival + 1
          values_sought(ival) = 'Bound Compton stop region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  12001
          default(ival) = 1
          Nmin = ival-1
          Nmax = ival
          CALL GET_INPUT
          IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ.
     *    0 )) THEN
            IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
              iitmp = itmp-2
              DO 6721 j=1, 12001
                ibcmp(j) = iitmp
6721          CONTINUE
6722          CONTINUE
              iitmp = 1 - iitmp
              DO 6731 k=1,nvalue(ival)
                istart = value(ival-1,k)
                iend = value(ival,k)
                write(i_log,*) 'Bound Compton start region',istart
                write(i_log,*) 'Bound Compton stop region',iend
                IF (( istart .LE. iend )) THEN
                  DO 6741 j=istart,iend
                    ibcmp(j) = iitmp
6741              CONTINUE
6742              CONTINUE
                  aux_inregions = .true.
                END IF
6731          CONTINUE
6732          CONTINUE
            ELSE
              value(num_incoh,1) = ibcmp(1)
            END IF
          ELSE
            value(num_incoh,1) = ibcmp(1)
          END IF
        ELSE
          IF((itmp .GT. 3))itmp = itmp-2
          write(i_log,*) ' Setting all to ',itmp
          DO 6751 j=1, 12001
            ibcmp(j) = itmp
6751      CONTINUE
6752      CONTINUE
        END IF
      ELSE
        IF ((ibcmp(1) .EQ. 2 .OR. ibcmp(1) .EQ. 3)) THEN
          value(num_incoh,1) = ibcmp(1)+2
        ELSE
          value(num_incoh,1) = ibcmp(1)
        END IF
      END IF
      incoh_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_coh) .EQ. 0 )) THEN
        write(i_log,*) 'Rayleigh start region'
        itmp = value(num_coh,1)
        IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
          ival = ival + 1
          values_sought(ival) = 'Rayleigh start region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  12001
          default(ival) = 1
          ival = ival + 1
          values_sought(ival) = 'Rayleigh stop region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  12001
          default(ival) = 1
          Nmin = ival-1
          Nmax = ival
          CALL GET_INPUT
          IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ.
     *    0 )) THEN
            IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
              iitmp = itmp-2
              DO 6761 j=1, 12001
                iraylr(j) = iitmp
6761          CONTINUE
6762          CONTINUE
              iitmp = 1 - iitmp
              DO 6771 k=1,nvalue(ival)
                istart = value(ival-1,k)
                iend = value(ival,k)
                write(i_log,*) 'Rayleigh start region',istart
                write(i_log,*) 'Rayleigh stop region',iend
                IF (( istart .LE. iend )) THEN
                  DO 6781 j=istart,iend
                    iraylr(j) = iitmp
6781              CONTINUE
6782              CONTINUE
                  aux_inregions = .true.
                END IF
6771          CONTINUE
6772          CONTINUE
            ELSE
              value(num_coh,1) = iraylr(1)
            END IF
          ELSE
            value(num_coh,1) = iraylr(1)
          END IF
        ELSE
          IF((itmp .GT. 3))itmp = itmp-2
          write(i_log,*) ' Setting all to ',itmp
          DO 6791 j=1, 12001
            iraylr(j) = itmp
6791      CONTINUE
6792      CONTINUE
        END IF
      ELSE
        IF ((iraylr(1) .EQ. 2 .OR. iraylr(1) .EQ. 3)) THEN
          value(num_coh,1) = iraylr(1)+2
        ELSE
          value(num_coh,1) = iraylr(1)
        END IF
      END IF
      coh_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_relax) .EQ. 0 )) THEN
        write(i_log,*) 'Relaxations start region'
        itmp = value(num_relax,1)
        IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
          ival = ival + 1
          values_sought(ival) = 'Relaxations start region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  12001
          default(ival) = 1
          ival = ival + 1
          values_sought(ival) = 'Relaxations stop region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  12001
          default(ival) = 1
          Nmin = ival-1
          Nmax = ival
          CALL GET_INPUT
          IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ.
     *    0 )) THEN
            IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
              iitmp = itmp-2
              DO 6801 j=1, 12001
                iedgfl(j) = iitmp
6801          CONTINUE
6802          CONTINUE
              iitmp = 1 - iitmp
              DO 6811 k=1,nvalue(ival)
                istart = value(ival-1,k)
                iend = value(ival,k)
                write(i_log,*) 'Relaxations start region',istart
                write(i_log,*) 'Relaxations stop region',iend
                IF (( istart .LE. iend )) THEN
                  DO 6821 j=istart,iend
                    iedgfl(j) = iitmp
6821              CONTINUE
6822              CONTINUE
                  aux_inregions = .true.
                END IF
6811          CONTINUE
6812          CONTINUE
            ELSE
              value(num_relax,1) = iedgfl(1)
            END IF
          ELSE
            value(num_relax,1) = iedgfl(1)
          END IF
        ELSE
          IF((itmp .GT. 3))itmp = itmp-2
          write(i_log,*) ' Setting all to ',itmp
          DO 6831 j=1, 12001
            iedgfl(j) = itmp
6831      CONTINUE
6832      CONTINUE
        END IF
      ELSE
        IF ((iedgfl(1) .EQ. 2 .OR. iedgfl(1) .EQ. 3)) THEN
          value(num_relax,1) = iedgfl(1)+2
        ELSE
          value(num_relax,1) = iedgfl(1)
        END IF
      END IF
      relax_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_pe_ang) .EQ. 0 )) THEN
        write(i_log,*) 'PE sampling start region'
        itmp = value(num_pe_ang,1)
        IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
          ival = ival + 1
          values_sought(ival) = 'PE sampling start region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  12001
          default(ival) = 1
          ival = ival + 1
          values_sought(ival) = 'PE sampling stop region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  12001
          default(ival) = 1
          Nmin = ival-1
          Nmax = ival
          CALL GET_INPUT
          IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ.
     *    0 )) THEN
            IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
              iitmp = itmp-2
              DO 6841 j=1, 12001
                iphter(j) = iitmp
6841          CONTINUE
6842          CONTINUE
              iitmp = 1 - iitmp
              DO 6851 k=1,nvalue(ival)
                istart = value(ival-1,k)
                iend = value(ival,k)
                write(i_log,*) 'PE sampling start region',istart
                write(i_log,*) 'PE sampling stop region',iend
                IF (( istart .LE. iend )) THEN
                  DO 6861 j=istart,iend
                    iphter(j) = iitmp
6861              CONTINUE
6862              CONTINUE
                  aux_inregions = .true.
                END IF
6851          CONTINUE
6852          CONTINUE
            ELSE
              value(num_pe_ang,1) = iphter(1)
            END IF
          ELSE
            value(num_pe_ang,1) = iphter(1)
          END IF
        ELSE
          IF((itmp .GT. 3))itmp = itmp-2
          write(i_log,*) ' Setting all to ',itmp
          DO 6871 j=1, 12001
            iphter(j) = itmp
6871      CONTINUE
6872      CONTINUE
        END IF
      ELSE
        IF ((iphter(1) .EQ. 2 .OR. iphter(1) .EQ. 3)) THEN
          value(num_pe_ang,1) = iphter(1)+2
        ELSE
          value(num_pe_ang,1) = iphter(1)
        END IF
      END IF
      pe_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_photonuc) .EQ. 0 )) THEN
        write(i_log,*) 'Photonuclear start region'
        itmp = value(num_photonuc,1)
        IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
          ival = ival + 1
          values_sought(ival) = 'Photonuclear start region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  12001
          default(ival) = 1
          ival = ival + 1
          values_sought(ival) = 'Photonuclear stop region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  12001
          default(ival) = 1
          Nmin = ival-1
          Nmax = ival
          CALL GET_INPUT
          IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ.
     *    0 )) THEN
            IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
              iitmp = itmp-2
              DO 6881 j=1, 12001
                iphotonucr(j) = iitmp
6881          CONTINUE
6882          CONTINUE
              iitmp = 1 - iitmp
              DO 6891 k=1,nvalue(ival)
                istart = value(ival-1,k)
                iend = value(ival,k)
                write(i_log,*) 'Photonuclear start region',istart
                write(i_log,*) 'Photonuclear stop region',iend
                IF (( istart .LE. iend )) THEN
                  DO 6901 j=istart,iend
                    iphotonucr(j) = iitmp
6901              CONTINUE
6902              CONTINUE
                  aux_inregions = .true.
                END IF
6891          CONTINUE
6892          CONTINUE
            ELSE
              value(num_photonuc,1) = iphotonucr(1)
            END IF
          ELSE
            value(num_photonuc,1) = iphotonucr(1)
          END IF
        ELSE
          IF((itmp .GT. 3))itmp = itmp-2
          write(i_log,*) ' Setting all to ',itmp
          DO 6911 j=1, 12001
            iphotonucr(j) = itmp
6911      CONTINUE
6912      CONTINUE
        END IF
      ELSE
        IF ((iphotonucr(1) .EQ. 2 .OR. iphotonucr(1) .EQ. 3)) THEN
          value(num_photonuc,1) = iphotonucr(1)+2
        ELSE
          value(num_photonuc,1) = iphotonucr(1)
        END IF
      END IF
      photonuc_inregions = aux_inregions
      aux_inregions = .false.
      ival = ival + 1
      num_ecut = ival
      values_sought(ival) = 'Set ECUT'
      nvalue(ival) = 0
      type(ival) = 1
      value_min(ival) = 0.
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      values_sought(ival) = 'Set ECUT start region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  12001
      default(ival) = 1
      ival = ival + 1
      values_sought(ival) = 'Set ECUT stop region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  12001
      default(ival) = 1
      Nmin = num_ecut
      Nmax = num_ecut+2
      error_flag = 0
      CALL GET_INPUT
      IF (( error_flag .EQ. 0 )) THEN
        IF (( nvalue(num_ecut) .EQ. nvalue(ival) .AND. nvalue(ival-1) .E
     *  Q. nvalue(ival) )) THEN
          DO 6921 k=1,nvalue(ival)
            istart = value(ival-1,k)
            iend = value(ival,k)
            IF (( istart .LE. iend )) THEN
              DO 6931 j=istart,iend
                ecut(j) = value(num_ecut,k)
6931          CONTINUE
6932          CONTINUE
              aux_inregions = .true.
            END IF
6921      CONTINUE
6922      CONTINUE
        END IF
      END IF
      ecut_inregions = aux_inregions
      aux_inregions = .false.
      ival = ival + 1
      num_pcut = ival
      values_sought(ival) = 'Set PCUT'
      nvalue(ival) = 0
      type(ival) = 1
      value_min(ival) = 0.
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      values_sought(ival) = 'Set PCUT start region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  12001
      default(ival) = 1
      ival = ival + 1
      values_sought(ival) = 'Set PCUT stop region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  12001
      default(ival) = 1
      Nmin = num_pcut
      Nmax = num_pcut+2
      error_flag = 0
      CALL GET_INPUT
      IF (( error_flag .EQ. 0 )) THEN
        IF (( nvalue(num_pcut) .EQ. nvalue(ival) .AND. nvalue(ival-1) .E
     *  Q. nvalue(ival) )) THEN
          DO 6941 k=1,nvalue(ival)
            istart = value(ival-1,k)
            iend = value(ival,k)
            IF (( istart .LE. iend )) THEN
              DO 6951 j=istart,iend
                pcut(j) = value(num_pcut,k)
6951          CONTINUE
6952          CONTINUE
              aux_inregions = .true.
            END IF
6941      CONTINUE
6942      CONTINUE
        END IF
      END IF
      pcut_inregions = aux_inregions
      aux_inregions = .false.
      ival = ival + 1
      num_smax = ival
      values_sought(ival) = 'Set SMAX'
      nvalue(ival) = 0
      type(ival) = 1
      value_min(ival) = 0.
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      values_sought(ival) = 'Set SMAX start region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  12001
      default(ival) = 1
      ival = ival + 1
      values_sought(ival) = 'Set SMAX stop region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  12001
      default(ival) = 1
      Nmin = num_smax
      Nmax = num_smax+2
      error_flag = 0
      CALL GET_INPUT
      IF (( error_flag .EQ. 0 )) THEN
        IF (( nvalue(num_smax) .EQ. nvalue(ival) .AND. nvalue(ival-1) .E
     *  Q. nvalue(ival) )) THEN
          DO 6961 k=1,nvalue(ival)
            istart = value(ival-1,k)
            iend = value(ival,k)
            IF (( istart .LE. iend )) THEN
              DO 6971 j=istart,iend
                smaxir(j) = value(num_smax,k)
6971          CONTINUE
6972          CONTINUE
              aux_inregions = .true.
            END IF
6961      CONTINUE
6962      CONTINUE
        END IF
      END IF
      smax_inregions = aux_inregions
      write(i_errors,*)
      write(i_errors,*) ' ******************** end input transport param
     *eter *********************** '
      write(i_errors,*)
      IF ((value(num_relax,1) .GT. 0 .AND. value(num_relax,1) .LT. 5)) T
     *HEN
        eadl_relax = .true.
        IF ((value(num_relax,1) .EQ. 1)) THEN
          value(num_relax,1)=4
        END IF
      ELSE
        IF ((mcdf_pe_xsections .AND. value(num_relax,1) .EQ. 5)) THEN
          eadl_relax = .true.
          value(num_relax,1)=4
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,'(a/,a/,a/)') '    Simplified atomic relaxation no
     *t allowed', '    with shellwise PE cross sections. Resetting', '
     *  to detailed EADL atomic relaxation!!!'
        ELSE
          eadl_relax = .false.
        END IF
      END IF
      output_strings(1) = allowed_inputs(num_pair_ang,iprdst)
      itmp = value(num_incoh,1)
      output_strings(2) = allowed_inputs(num_incoh,itmp)
      IF (( radc_flag .EQ. 1 )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) 'You are trying to use radiative Compton correcti
     *ons'
        write(i_log,*) 'without having included rad_compton1.mortran'
        write(i_log,'(a//)') 'Turning radiative Compton corrections OFF
     *...'
        radc_flag = 0
      END IF
      output_strings(12) = allowed_inputs(num_radc,radc_flag)
      itmp = value(num_coh,1)
      output_strings(3) = allowed_inputs(num_coh,itmp)
      itmp = value(num_relax,1)
      output_strings(4) = allowed_inputs(num_relax,itmp)
      itmp = value(num_pe_ang,1)
      output_strings(5) = allowed_inputs(num_pe_ang,itmp)
      output_strings(6) = allowed_inputs(num_brems_ang,ibrdst)
      output_strings(7) = allowed_inputs(num_bca,bca_algorithm)
      output_strings(8) = allowed_inputs(num_alg,transport_algorithm)
      output_strings(9) = allowed_inputs(num_brems_cs,ibr_nist)
      output_strings(10) = allowed_inputs(num_pair_cs,pair_nrc)
      output_strings(11) = allowed_inputs(num_triplet,itriplet)
      itmp = value(num_photonuc,1)
      output_strings(14) = allowed_inputs(num_photonuc,itmp)
      entry show_transport_parameter(ounit)
      IF((ounit .LE. 0))return
      write(ounit,*)
      write(ounit,'(a)') line
      write(ounit,*)
      write(ounit,'(a,/)') '                   Electron/Photon transport
     * parameter'
      write(ounit,'(a,/)') line
      write(ounit,'(a,38x,a)') ' Photon cross sections', photon_xsection
     *s(:lnblnk1(photon_xsections))
      write(ounit,'(a,37x,a)') ' Compton cross sections', comp_xsections
     *(:lnblnk1(comp_xsections))
      write(ounit,'(a,$)') ' Photon transport cutoff(MeV)'
      IF (( pcut_inregions )) THEN
        write(ounit,'(32x,a)') 'Set in regions'
      ELSE
        IF (( pcut(1) .GT. 1e-4 )) THEN
          write(ounit,'(32x,g14.4)') pcut(1)
        ELSE
          write(ounit,'(32x,a)') 'AP(medium)'
        END IF
      END IF
      write(ounit,'(a,39x,a3)') ' Pair angular sampling',output_strings(
     *1)
      write(ounit,'(a,41x,a3)') ' Pair cross sections',output_strings(10
     *)
      write(ounit,'(a,42x,a3)') ' Triplet production',output_strings(11)
      write(ounit,'(a,36x,a14)') ' Bound Compton scattering',output_stri
     *ngs(2)
      write(ounit,'(a,31x,a14)') ' Radiative Compton corrections',output
     *_strings(12)
      write(ounit,'(a,41x,a14)') ' Rayleigh scattering',output_strings(3
     *)
      write(ounit,'(a,42x,a14)') ' Atomic relaxations',output_strings(4)
      write(ounit,'(a,30x,a14)') ' Photoelectron angular sampling',outpu
     *t_strings(5)
      IF (( value(num_photonuc,1) .GT. 0 )) THEN
        write(ounit,'(a,36x,a14)') ' Photonuclear attenuation',output_st
     *  rings(14)
        write(ounit,'(a,33x,a)') ' Photonuclear cross sections', photonu
     *  c_xsections(:lnblnk1(photonuc_xsections))
      END IF
      write(ounit,*)
      write(ounit,'(a,$)') ' Electron transport cutoff(MeV)'
      IF (( ecut_inregions )) THEN
        write(ounit,'(30x,a)') 'Set in regions'
      ELSE
        IF (( ecut(1) .GT. 1e-4 )) THEN
          write(ounit,'(30x,f7.4)') ecut(1)
        ELSE
          write(ounit,'(30x,a)') 'AE(medium)'
        END IF
      END IF
      write(ounit,'(a,30x,a4)') ' Bremsstrahlung cross sections',output_
     *strings(9)
      write(ounit,'(a,29x,a3)') ' Bremsstrahlung angular sampling',outpu
     *t_strings(6)
      IF (( spin_effects )) THEN
        write(ounit,'(a,48x,a)') ' Spin effects','On'
      ELSE
        write(ounit,'(a,48x,a)') ' Spin effects','Off'
      END IF
      write(ounit,'(a,34x,a)') ' Electron Impact Ionization',eii_xfile(:
     *lnblnk1(eii_xfile))
      IF ((eii_L_factor .NE. 1.0)) THEN
        write(ounit,'(a,25x,f6.4)') ' L-shell EII xsections scaling fact
     *or',eii_L_factor
      END IF
      write(ounit,'(a,$)') ' Maxium electron step in cm (SMAX)'
      IF (( smax_inregions )) THEN
        write(ounit,'(27x,a)') 'Set in regions'
      ELSE
        IF (( smaxir(1) .GT. 1e-4 )) THEN
          write(ounit,'(27x,g14.4)') smaxir(1)
        ELSE
          write(ounit,'(27x,a)') 'Restriction is off'
        END IF
      END IF
      write(ounit,'(a,16x,f6.4)') ' Maximum fractional energy loss/step
     *(ESTEPE)',estepe
      write(ounit,'(a,21x,f6.4)') ' Maximum 1st elastic moment/step (XIM
     *AX)',ximax
      write(ounit,'(a,33x,a10)') ' Boundary crossing algorithm',output_s
     *trings(7)
      write(ounit,'(a,22x,g9.4)') ' Skin-depth for boundary crossing (MF
     *P)',skindepth_for_bca
      write(ounit,'(a,37x,a10)') ' Electron-step algorithm',output_strin
     *gs(8)
      IF (( ExIN.NE.0 .OR. EyIN.NE.0 .OR. EzIN.NE.0 )) THEN
        write(ounit,'(a,38x,3f10.2)') ' Electric Field [V/cm]', ExIN,EyI
     *  N,EzIN
      END IF
      IF (( Bx.NE.0 .OR. By.NE.0 .OR. Bz.NE.0 )) THEN
        write(ounit,'(a,41x,3f10.2)') ' Magnetic Field [T]', Bx,By,Bz
      END IF
      IF (( ExIN.NE.0 .OR. EyIN.NE.0 .OR. EzIN.NE.0 .OR. Bx.NE.0 .OR. By
     *.NE.0 .OR. Bz.NE.0 )) THEN
        write(ounit,'(a,50x,f10.2)') ' EM ESTEPE',EMLMTIN
      END IF
      write(ounit,*)
      write(ounit,'(a)') line
      write(ounit,*)
      return
      end
      subroutine set_elastic_parameter
      implicit none
      integer*4 ounit
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 imed,ival,lnblnk1,nchanged
      character*24 medname
      ounit = i_log
      ounit = i_log
      delimeter = 'MC TRANSPORT PARAMETER'
      call get_input_set_error_level(0)
      ival = 0
      DO 6981 imed=1,nmed
        call egs_get_medium_name(imed,medname)
        ival = ival + 1
        values_sought(ival) = 'scale elastic scattering in '// medname(:
     *  lnblnk1(medname))
        nvalue(ival) = 1
        type(ival) = 1
        value_min(ival) = 1e-3
        value_max(ival) = 1e3
        default(ival) = 1
6981  CONTINUE
6982  CONTINUE
      Nmin = 1
      Nmax = nmed
      CALL GET_INPUT
      nchanged = 0
      DO 6991 imed=1,nmed
        IF((error_flags(imed) .EQ. 0))nchanged = nchanged + 1
6991  CONTINUE
6992  CONTINUE
      IF (( nchanged .GT. 0 )) THEN
        write(ounit,'(//a)') '================ Elastic scattering scaled
     * as follows =================='
        DO 7001 imed=1,nmed
          IF (( error_flags(imed) .EQ. 0 )) THEN
            call egs_get_medium_name(imed,medname)
            xcc(imed) = xcc(imed)*value(imed,1)
            blcc(imed) = blcc(imed)*value(imed,1)
            write(ounit,'(a,t30,f10.6)') medname(:lnblnk1(medname)), val
     *      ue(imed,1)
          END IF
7001    CONTINUE
7002    CONTINUE
        write(ounit,'(a//)') '==========================================
     *=============================='
      END IF
      return
      end
      SUBROUTINE GET_INPUT_PLUS(UNITNUM,DELIM_START,DELIM_END)
      IMPLICIT NONE
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      CHARACTER*256 TEXT
      CHARACTER*256 KEEPTEXT
      CHARACTER*256 ORIGTEXT
      CHARACTER*256 TEXTPIECE
      CHARACTER*80 DELIM_START
      CHARACTER*80 DELIM_END
      CHARACTER*80 ENDSTRING
      CHARACTER*64 VNAME
      CHARACTER*64 VNAME1
      integer*4 CURSOR
      integer*4 IINDEX
      integer*4 iVNAME
      integer*4 IVAL
      integer*4 UNITNUM
      integer*4 ERR
      integer*4 I,J,K,CHECK
      integer*4 LINE
      integer*4 INT_VALUE
      integer*4 INT_VALUE_MIN
      integer*4 INT_VALUE_MAX
      logical ALLOWED
      logical START_FOUND
      integer*4 ifound,length,lll,Kconvert
      integer*4 lnblnk1
      logical IDEBUG,end_string
      character*1 blank
      integer*4 error_level
      integer*4 the_level
      data blank/' '/
      data error_level/1/
      save error_level
      IDEBUG = .false.
      ERROR_FLAG = 0
      IF ((IDEBUG)) THEN
        WRITE(6,7010)NMIN,NMAX, 100
7010    FORMAT(' Entering get_inputs seeking values', I5,' to', I5, '  w
     *ith a max allowed of',I5)
      END IF
      IF ((NMAX .LT. NMIN .OR. NMAX .GT. 100)) THEN
        WRITE(6,7020)NMAX, NMIN, 100
7020    FORMAT(//' Error entering get_inputs: Asked for values from',I5,
     *' to',I5, '    with a max of',I5//' This implies a bug in the call
     *ing routine'/ ' Fix it up and try again.  Stopping now.')
        STOP
      END IF
      ERR=i_errors
      DELIM_START=DELIM_START(:lnblnk1(DELIM_START))
      DELIM_END=DELIM_END(:lnblnk1(DELIM_END))
      length = len(DELIM_START)
7031  IF(index(DELIM_START,blank).NE.1)GO TO 7032
        IF (( length .GE. 2 )) THEN
          DELIM_START=DELIM_START(2:)
        ELSE
          GO TO7032
        END IF
        length = length - 1
      GO TO 7031
7032  CONTINUE
      length = len(DELIM_END)
7041  IF(index(DELIM_END,blank).NE.1)GO TO 7042
        IF (( length .GE. 2 )) THEN
          DELIM_END=DELIM_END(2:)
        ELSE
          GO TO7042
        END IF
        length = length - 1
      GO TO 7041
7042  CONTINUE
      DO 7051 Kconvert=1,lnblnk1(DELIM_START)
        CURSOR=ICHAR(DELIM_START(Kconvert:Kconvert))
        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
          CURSOR=CURSOR-32
          DELIM_START(Kconvert:Kconvert)=CHAR(CURSOR)
        END IF
7051  CONTINUE
7052  CONTINUE
      DO 7061 Kconvert=1,lnblnk1(DELIM_END)
        CURSOR=ICHAR(DELIM_END(Kconvert:Kconvert))
        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
          CURSOR=CURSOR-32
          DELIM_END(Kconvert:Kconvert)=CHAR(CURSOR)
        END IF
7061  CONTINUE
7062  CONTINUE
      length = len(ENDSTRING)
7071  IF(index(ENDSTRING,blank).NE.1)GO TO 7072
        IF (( length .GE. 2 )) THEN
          ENDSTRING=ENDSTRING(2:)
        ELSE
          GO TO7072
        END IF
        length = length - 1
      GO TO 7071
7072  CONTINUE
      IF ((ENDSTRING.EQ.blank)) THEN
        end_string=.false.
      ELSE
        DO 7081 Kconvert=1,lnblnk1(ENDSTRING)
          CURSOR=ICHAR(ENDSTRING(Kconvert:Kconvert))
          IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
            CURSOR=CURSOR-32
            ENDSTRING(Kconvert:Kconvert)=CHAR(CURSOR)
          END IF
7081    CONTINUE
7082    CONTINUE
        end_string=.false.
      END IF
      IF ((IDEBUG)) THEN
        WRITE(6,7090)DELIM_START,DELIM_END
7090    FORMAT(' start and stop delimeters are:'/ A/A/)
      END IF
      DO 7101 I=NMIN,NMAX
        REWIND (UNITNUM)
        LINE=0
        CHECK=0
        ERROR_FLAGS(I)=0
        IF ((TYPE(I) .EQ. 0 .OR. TYPE(I) .EQ. 1)) THEN
          VALUE(I,1) = DEFAULT(I)
        END IF
        IF ((TYPE(I) .EQ. 3)) THEN
          VALUE(I,1) = 0
        END IF
        VNAME=VALUES_SOUGHT(I)
        iVNAME=lnblnk1(VNAME)
        IF (( ivname .LT. 1 )) THEN
          IF (( error_level .GT. 0 )) THEN
            write(ERR,*) ' ======================= Warning =============
     *======== '
            write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!
     *         '
            write(ERR,*) ' =============================================
     *======== '
          END IF
          ERROR_FLAG=1
          ERROR_FLAGS(I)=1
          goto 6170
        END IF
        DO 7111 Kconvert=1,lnblnk1(vname)
          CURSOR=ICHAR(vname(Kconvert:Kconvert))
          IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
            CURSOR=CURSOR-32
            vname(Kconvert:Kconvert)=CHAR(CURSOR)
          END IF
7111    CONTINUE
7112    CONTINUE
        iindex = 0
        IF ((DELIM_START .EQ. 'NONE')) THEN
          start_found = .true.
        ELSE
          start_found = .false.
        END IF
7121    IF(iindex.NE.0)GO TO 7122
6200      CONTINUE
          LINE=LINE+1
          IF (( start_found )) THEN
            READ(UNITNUM,END=6210,ERR=6220,FMT='(A256)') TEXT
          ELSE
            READ(UNITNUM,END=6230,ERR=6220,FMT='(A256)') TEXT
          END IF
          length = len(text)
7131      IF(index(text,blank).NE.1)GO TO 7132
            IF (( length .GE. 2 )) THEN
              text=text(2:)
            ELSE
              GO TO7132
            END IF
            length = length - 1
          GO TO 7131
7132      CONTINUE
          ifound = INDEX(text,'#')
          IF (( ifound .GT. 1 )) THEN
            text = text(1:ifound-1)
          ELSE
            IF (( ifound .EQ. 1 )) THEN
              text = blank
            END IF
          END IF
          ifound = INDEX(text,';')
          IF (( ifound .GT. 1 )) THEN
            text = text(1:ifound-1)
          ELSE
            IF (( ifound .EQ. 1 )) THEN
              text = blank
            END IF
          END IF
          length = lnblnk1(TEXT)
          TEXT=TEXT(:length)
          origtext = text(:length)
          DO 7141 Kconvert=1,lnblnk1(text)
            CURSOR=ICHAR(text(Kconvert:Kconvert))
            IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
              CURSOR=CURSOR-32
              text(Kconvert:Kconvert)=CHAR(CURSOR)
            END IF
7141      CONTINUE
7142      CONTINUE
          IF (( .NOT.start_found )) THEN
            IF ((INDEX(TEXT,DELIM_START) .NE. 0 )) THEN
              start_found = .true.
            END IF
            goto 6200
          END IF
          iindex=INDEX(TEXT,VNAME(:iVNAME))
          IF (( DELIM_END.NE.'NONE' )) THEN
            IF ((INDEX(TEXT,DELIM_END).NE.0)) THEN
              IF (( error_level .GT. 0 )) THEN
                WRITE (ERR,*) '***************ERROR***************'
                WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUG
     *          HT(I))), '<<',' NOT FOUND'
                WRITE (ERR,*) 'END OF DELIMETER: ',DELIM_END
              END IF
              ERROR_FLAG=1
              ERROR_FLAGS(I)=1
              GOTO 6170
            END IF
          END IF
        GO TO 7121
7122    CONTINUE
        CHECK=0
        IF (( idebug )) THEN
          write(i_log,*) ' ******* Found: '
          write(i_log,'(a,$)') ' text:     '
          length = lnblnk1(text)
          IF (( length .GT. 0 )) THEN
            DO 7151 lll=1,length
              write(i_log,'(a1,$)') text(lll:lll)
7151        CONTINUE
7152        CONTINUE
            write(i_log,*)
          END IF
          write(i_log,'(a,$)') ' origtext: '
          length = lnblnk1(origtext)
          IF (( length .GT. 0 )) THEN
            DO 7161 lll=1,length
              write(i_log,'(a1,$)') origtext(lll:lll)
7161        CONTINUE
7162        CONTINUE
            write(i_log,*)
          END IF
        END IF
        IINDEX=IINDEX+iVNAME
        TEXT=TEXT(IINDEX:)
        origtext=origtext(iindex:)
        IF (( idebug )) THEN
          write(i_log,*) ' After removing vname: '
          write(i_log,'(a,$)') ' text:     '
          length = lnblnk1(text)
          IF (( length .GT. 0 )) THEN
            DO 7171 lll=1,length
              write(i_log,'(a1,$)') text(lll:lll)
7171        CONTINUE
7172        CONTINUE
            write(i_log,*)
          END IF
          write(i_log,'(a,$)') ' origtext: '
          length = lnblnk1(origtext)
          IF (( length .GT. 0 )) THEN
            DO 7181 lll=1,length
              write(i_log,'(a1,$)') origtext(lll:lll)
7181        CONTINUE
7182        CONTINUE
            write(i_log,*)
          END IF
        END IF
        IINDEX=INDEX(TEXT,'=')
        IF ((IINDEX.NE.0)) THEN
          TEXT=TEXT(IINDEX+1:)
          origtext=origtext(iindex+1:)
        ELSE
          IINDEX=INDEX(TEXT,':')
          IF ((IINDEX.NE.0)) THEN
            TEXT=TEXT(IINDEX+1:)
            origtext=origtext(iindex+1:)
          END IF
        END IF
        IF (( idebug )) THEN
          write(i_log,*) ' After removing leading equals: '
          write(i_log,'(a,$)') ' text:     '
          length = lnblnk1(text)
          IF (( length .GT. 0 )) THEN
            DO 7191 lll=1,length
              write(i_log,'(a1,$)') text(lll:lll)
7191        CONTINUE
7192        CONTINUE
            write(i_log,*)
          END IF
          write(i_log,'(a,$)') ' origtext: '
          length = lnblnk1(origtext)
          IF (( length .GT. 0 )) THEN
            DO 7201 lll=1,length
              write(i_log,'(a1,$)') origtext(lll:lll)
7201        CONTINUE
7202        CONTINUE
            write(i_log,*)
          END IF
        END IF
        IF (( (lnblnk1(TEXT).EQ.0) .OR. (lnblnk1(TEXT).EQ.1) )) THEN
          IF ((vname(:ivname).EQ.'TITLE')) THEN
            READ (UNITNUM,FMT='(A256)') TEXTPIECE
            IF ((lnblnk1(TEXTPIECE).NE.0)) THEN
              TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE))
              length = len(text)
7211          IF(index(text,blank).NE.1)GO TO 7212
                IF (( length .GE. 2 )) THEN
                  text=text(2:)
                ELSE
                  GO TO7212
                END IF
                length = length - 1
              GO TO 7211
7212          CONTINUE
              length = len(origtext)
7221          IF(index(origtext,blank).NE.1)GO TO 7222
                IF (( length .GE. 2 )) THEN
                  origtext=origtext(2:)
                ELSE
                  GO TO7222
                END IF
                length = length - 1
              GO TO 7221
7222          CONTINUE
              GOTO 6340
            END IF
          END IF
          IF (( error_level .GT. 0 )) THEN
            WRITE (ERR,*) '*************ERROR*************'
            WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
            WRITE (ERR,*) 'VALUE NOT THERE!!'
          END IF
          ERROR_FLAG=1
          ERROR_FLAGS(I)=1
          RETURN
        END IF
6340    CONTINUE
        iindex = index(text,'DEFAULT')
        IF (( iindex .NE. 0 )) THEN
          IF (( type(i) .NE. 2 )) THEN
            IF (( type(i) .NE. 3 )) THEN
              VALUE(I,1)=DEFAULT(I)
            ELSE
              VALUE(I,1)=0
            END IF
            goto 6170
          END IF
        END IF
        IF (((TYPE(I) .EQ. 0).OR.(TYPE(I) .EQ. 1))) THEN
          IVAL=1
          IF (( idebug )) THEN
            write(i_log,*) ' *** Reading an integer or a real value! '
          END IF
7231      CONTINUE
            IF (( idebug )) THEN
              write(i_log,*) ' In LOOP, ival = ',ival
            END IF
            IF ((lnblnk1(TEXT).EQ.0)) THEN
              IF (( error_level .GT. 0 )) THEN
                WRITE(ERR,*) '*************ERROR*************'
                WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                WRITE (ERR,*) 'VALUE NOT THERE!!'
              END IF
              ERROR_FLAG=1
              ERROR_FLAGS(I)=1
              RETURN
            END IF
            READ(TEXT,END=6360,ERR=6370,FMT=*) VALUE(I,IVAL)
            IF (( idebug )) THEN
              write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL)
            END IF
            IF (((VALUE(I,IVAL).GT.VALUE_MAX(I)).OR.(VALUE(I,IVAL).LT.VA
     *      LUE_MIN(I)))) THEN
              IF ((TYPE(I).EQ.0)) THEN
                INT_VALUE=DEFAULT(I)
                IF (( error_level .GT. 0 )) THEN
                  WRITE(ERR,*) '************WARNING************'
                  WRITE(ERR,6380) INT_VALUE, VALUES_SOUGHT(I)(:lnblnk1(V
     *            ALUES_SOUGHT(I)))
                END IF
6380            FORMAT ( 'Default= ',I9,' used for: ', A )
                INT_VALUE=VALUE(I,IVAL)
                INT_VALUE_MIN=VALUE_MIN(I)
                INT_VALUE_MAX=VALUE_MAX(I)
                IF (( error_level .GT. 0 )) THEN
                  WRITE(ERR,6390) VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGH
     *            T(I))), INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX
                END IF
6390            FORMAT (A,'=', I9,' should be between ', I9,' and ', I9)
              END IF
              IF ((TYPE(I).EQ.1)) THEN
                IF (( error_level .GT. 0 )) THEN
                  WRITE(ERR,*) '************WARNING************'
                  WRITE(ERR,6400) DEFAULT(I), VALUES_SOUGHT(I)(:lnblnk1(
     *            VALUES_SOUGHT(I)))
6400              FORMAT ( 'Default= ',F12.6,' used for: ', A )
                  WRITE(ERR,6410) VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGH
     *            T(I))), VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I)
6410              FORMAT (A,'=', F12.6,' should be between ', G14.6,' an
     *d ', G14.6)
                END IF
              END IF
              VALUE(I,IVAL)=DEFAULT(I)
            END IF
            IF((IVAL .EQ. NVALUE(I)))GO TO7232
            IF (((INDEX(TEXT,',').NE.0).OR.(lnblnk1(TEXT).EQ.0))) THEN
              IF (( idebug )) THEN
                write(i_log,*) ' A comma or a blank text found -> '
                write(i_log,*) ' searching for further input'
              END IF
              TEXT=TEXT(INDEX(TEXT,',')+1:)
7241          IF(lnblnk1(TEXT).NE.0)GO TO 7242
                IF (( idebug )) THEN
                  write(i_log,*) ' Empty text -> reading next line! '
                END IF
                LINE=LINE+1
                READ (UNITNUM,END=6360,ERR=6370,FMT='(A256)') TEXT
                length = len(text)
7251            IF(index(text,blank).NE.1)GO TO 7252
                  IF (( length .GE. 2 )) THEN
                    text=text(2:)
                  ELSE
                    GO TO7252
                  END IF
                  length = length - 1
                GO TO 7251
7252            CONTINUE
                ifound = INDEX(text,'#')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                ifound = INDEX(text,';')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                length = lnblnk1(TEXT)
                TEXT=TEXT(:length)
                origtext = text(:length)
                DO 7261 Kconvert=1,lnblnk1(text)
                  CURSOR=ICHAR(text(Kconvert:Kconvert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                    CURSOR=CURSOR-32
                    text(Kconvert:Kconvert)=CHAR(CURSOR)
                  END IF
7261            CONTINUE
7262            CONTINUE
                DO 7271 K=1,NMAX
                  vname1 = VALUES_SOUGHT(K)
                  length = lnblnk1(vname1)
                  IF (( length .GT. 0 )) THEN
                    length = len(vname1)
7281                IF(index(vname1,blank).NE.1)GO TO 7282
                      IF (( length .GE. 2 )) THEN
                        vname1=vname1(2:)
                      ELSE
                        GO TO7282
                      END IF
                      length = length - 1
                    GO TO 7281
7282                CONTINUE
                    DO 7291 Kconvert=1,lnblnk1(vname1)
                      CURSOR=ICHAR(vname1(Kconvert:Kconvert))
                      IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                        CURSOR=CURSOR-32
                        vname1(Kconvert:Kconvert)=CHAR(CURSOR)
                      END IF
7291                CONTINUE
7292                CONTINUE
                    IF ((INDEX(TEXT,vname1(:length)).NE.0)) THEN
                      IF (( error_level .GT. 0 )) THEN
                        WRITE(ERR,*) '************ERROR************'
                        WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                        WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)), '<--C
     *OMMA INDICATES ANOTHER INPUT'
                        WRITE(ERR,*) 'SEARCHED NEXT LINE: ', TEXT(:lnbln
     *                  k1(TEXT))
                        WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED'
                      END IF
                      ERROR_FLAG=1
                      ERROR_FLAGS(I)=1
                    END IF
                  END IF
7271            CONTINUE
7272            CONTINUE
                IF (( idebug )) THEN
                  write(i_log,*) ' Next line: '
                  write(i_log,'(a,$)') ' text:     '
                  length = lnblnk1(text)
                  IF (( length .GT. 0 )) THEN
                    DO 7301 lll=1,length
                      write(i_log,'(a1,$)') text(lll:lll)
7301                CONTINUE
7302                CONTINUE
                    write(i_log,*)
                  END IF
                  write(i_log,'(a,$)') ' origtext: '
                  length = lnblnk1(origtext)
                  IF (( length .GT. 0 )) THEN
                    DO 7311 lll=1,length
                      write(i_log,'(a1,$)') origtext(lll:lll)
7311                CONTINUE
7312                CONTINUE
                    write(i_log,*)
                  END IF
                END IF
              GO TO 7241
7242          CONTINUE
            ELSE
              GO TO7232
            END IF
            IVAL=IVAL+1
          GO TO 7231
7232      CONTINUE
          IF (((NVALUE(I).NE.0).AND.(NVALUE(I).NE.IVAL))) THEN
            IF (( error_level .GT. 0 )) THEN
              WRITE (ERR,*) '**************ERROR**************'
              WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I)
              WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)'
              WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED'
            END IF
            ERROR_FLAG=1
            ERROR_FLAGS(I)=1
          ELSE
            NVALUE(I)=IVAL
          END IF
6360      CONTINUE
        END IF
        IF (((TYPE(I) .EQ. 2) .OR. (TYPE(I) .EQ. 3))) THEN
          IVAL=1
          IF (( idebug )) THEN
            write(i_log,*) ' Trying to read a string! '
          END IF
7321      CONTINUE
            IF (( idebug )) THEN
              write(i_log,*) ' In LOOP, ival = ',ival
            END IF
            IF ((lnblnk1(TEXT).EQ.0)) THEN
              IF (( error_level .GT. 0 )) THEN
                WRITE(ERR,*) '*************ERROR*************'
                WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                WRITE (ERR,*) 'VALUE NOT THERE!!'
              END IF
              ERROR_FLAG=1
              ERROR_FLAGS(I)=1
              RETURN
            END IF
            IF ((vname(:ivname).EQ.'TITLE')) THEN
              TEXTPIECE=origtext
              GOTO 6510
            END IF
            iindex = INDEX(origtext,',')
            IF (( iindex .NE. 0 )) THEN
              TEXTPIECE=origtext(:iindex-1)
            ELSE
              TEXTPIECE=origtext
            END IF
6510        CONTINUE
            READ(TEXTPIECE,ERR=6520,FMT='(A256)') CHAR_VALUE(I,IVAL)
            length = len(CHAR_VALUE(I,IVAL))
7331        IF(index(CHAR_VALUE(I,IVAL),blank).NE.1)GO TO 7332
              IF (( length .GE. 2 )) THEN
                CHAR_VALUE(I,IVAL)=CHAR_VALUE(I,IVAL)(2:)
              ELSE
                GO TO7332
              END IF
              length = length - 1
            GO TO 7331
7332        CONTINUE
            IF (( idebug )) THEN
              write(i_log,*) ' Read the following char string: '
              length = lnblnk1(CHAR_VALUE(I,IVAL))
              IF (( length .GT. 0 )) THEN
                DO 7341 lll=1,length
                  write(i_log,'(a1,$)') CHAR_VALUE(I,IVAL)(lll:lll)
7341            CONTINUE
7342            CONTINUE
                write(i_log,*)
              END IF
            END IF
            IF ((TYPE(I) .EQ. 3)) THEN
              DO 7351 Kconvert=1,lnblnk1(CHAR_VALUE(I,IVAL))
                CURSOR=ICHAR(CHAR_VALUE(I,IVAL)(Kconvert:Kconvert))
                IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                  CURSOR=CURSOR-32
                  CHAR_VALUE(I,IVAL)(Kconvert:Kconvert)=CHAR(CURSOR)
                END IF
7351          CONTINUE
7352          CONTINUE
              ALLOWED=.FALSE.
              DO 7361 K=0,5
                vname1 = ALLOWED_INPUTS(I,K)
                length = len(ALLOWED_INPUTS(I,K))
7371            IF(index(ALLOWED_INPUTS(I,K),blank).NE.1)GO TO 7372
                  IF (( length .GE. 2 )) THEN
                    ALLOWED_INPUTS(I,K)=ALLOWED_INPUTS(I,K)(2:)
                  ELSE
                    GO TO7372
                  END IF
                  length = length - 1
                GO TO 7371
7372            CONTINUE
                DO 7381 Kconvert=1,lnblnk1(ALLOWED_INPUTS(I,K))
                  CURSOR=ICHAR(ALLOWED_INPUTS(I,K)(Kconvert:Kconvert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                    CURSOR=CURSOR-32
                    ALLOWED_INPUTS(I,K)(Kconvert:Kconvert)=CHAR(CURSOR)
                  END IF
7381            CONTINUE
7382            CONTINUE
                IF ((ALLOWED_INPUTS(I,K).EQ.CHAR_VALUE(I,IVAL))) THEN
                  ALLOWED=.TRUE.
                  VALUE(I,IVAL)=K
                  IF (( idebug )) THEN
                    write(i_log,*) ' Found a allowed_value match ',k
                  END IF
                END IF
7361          CONTINUE
7362          CONTINUE
              IF ((.NOT.ALLOWED)) THEN
                WRITE(ERR,*) '*************ERROR*************'
                IF ((IVAL.NE.1)) THEN
                  WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                  WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY'
                  WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND
     * VALUE'
                ELSE
                  WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                  WRITE(ERR,*) 'INPUT-->', CHAR_VALUE(I,IVAL)(:lnblnk1(C
     *            HAR_VALUE(I,IVAL))), '<--NOT ALLOWED'
                  WRITE(ERR,*) 'OPTIONS ARE:'
                  WRITE(ERR,1940) (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_
     *            INPUTS(I,K))),K=0,5)
                END IF
1940            FORMAT(A40)
                ERROR_FLAG=1
                ERROR_FLAGS(I)=1
              END IF
            END IF
            IF ((vname(:ivname).EQ.'TITLE')) THEN
              GO TO7322
            END IF
            DO 7391 K=1,LEN(KEEPTEXT)
              KEEPTEXT(K:K)=' '
7391        CONTINUE
7392        CONTINUE
            KEEPTEXT(:lnblnk1(TEXT))=TEXT
            iindex = INDEX(TEXT,',')
            IF (( iindex .NE. 0 .OR. lnblnk1(TEXT).EQ.0 )) THEN
              TEXT=TEXT(INDEX(TEXT,',')+1:)
              origtext=origtext(iindex+1:)
7401          IF(lnblnk1(TEXT).NE.0)GO TO 7402
                LINE=LINE+1
                READ (UNITNUM,ERR=6520,FMT='(A256)') TEXT
                length = len(text)
7411            IF(index(text,blank).NE.1)GO TO 7412
                  IF (( length .GE. 2 )) THEN
                    text=text(2:)
                  ELSE
                    GO TO7412
                  END IF
                  length = length - 1
                GO TO 7411
7412            CONTINUE
                ifound = INDEX(text,'#')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                ifound = INDEX(text,';')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                length = lnblnk1(TEXT)
                TEXT=TEXT(:length)
                origtext = text(:length)
                DO 7421 Kconvert=1,lnblnk1(text)
                  CURSOR=ICHAR(text(Kconvert:Kconvert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                    CURSOR=CURSOR-32
                    text(Kconvert:Kconvert)=CHAR(CURSOR)
                  END IF
7421            CONTINUE
7422            CONTINUE
                DO 7431 K=1,NMAX
                  vname1 = VALUES_SOUGHT(K)
                  length = lnblnk1(vname1)
                  IF (( length .GT. 0 )) THEN
                    length = len(vname1)
7441                IF(index(vname1,blank).NE.1)GO TO 7442
                      IF (( length .GE. 2 )) THEN
                        vname1=vname1(2:)
                      ELSE
                        GO TO7442
                      END IF
                      length = length - 1
                    GO TO 7441
7442                CONTINUE
                    DO 7451 Kconvert=1,lnblnk1(vname1)
                      CURSOR=ICHAR(vname1(Kconvert:Kconvert))
                      IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                        CURSOR=CURSOR-32
                        vname1(Kconvert:Kconvert)=CHAR(CURSOR)
                      END IF
7451                CONTINUE
7452                CONTINUE
                    IF ((INDEX(TEXT,vname1(:length)).NE.0)) THEN
                      WRITE(ERR,*) '************ERROR************'
                      WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                      WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)), '<--COM
     *MA INDICATES ANOTHER INPUT'
                      WRITE(ERR,*) 'SEARCHED NEXT LINE: ', TEXT(:lnblnk1
     *                (TEXT))
                      WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED'
                      ERROR_FLAG=1
                      ERROR_FLAGS(I)=1
                    END IF
                  END IF
7431            CONTINUE
7432            CONTINUE
              GO TO 7401
7402          CONTINUE
            ELSE
              GO TO7322
            END IF
            IVAL=IVAL+1
          GO TO 7321
7322      CONTINUE
          IF (((NVALUE(I).NE.0).AND.(NVALUE(I).NE.IVAL))) THEN
            IF (( error_level .GT. 0 )) THEN
              WRITE (ERR,*) '*******************ERROR*******************
     *'
              WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I)
              WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)'
              WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED'
            END IF
            ERROR_FLAG=1
            ERROR_FLAGS(I)=1
          ELSE
            NVALUE(I)=IVAL
          END IF
        END IF
        goto 6170
6210    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '******************ERROR***********************'
          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND'
          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER'
          WRITE (ERR,*) 'VALUE SOUGHT: >>', VALUES_SOUGHT(I)(:lnblnk1(VA
     *    LUES_SOUGHT(I))),'<<'
          WRITE (ERR,*) 'END DELIMETER: >>', DELIM_END(:lnblnk1(DELIM_EN
     *    D)),'<<'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
        goto 6170
6230    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '******************ERROR***********************'
          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND'
          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER'
          WRITE (ERR,*) 'VALUE SOUGHT: >>', VALUES_SOUGHT(I)(:lnblnk1(VA
     *    LUES_SOUGHT(I))),'<<'
          WRITE (ERR,*) 'START DELIMETER: >>', DELIM_START(:lnblnk1(DELI
     *    M_START)),'<<'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
        goto 6170
6370    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '***************ERROR***************'
          IF ((IVAL.GT.1)) THEN
            J=IVAL
          ELSE
            J=1
          END IF
          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I)
          WRITE (ERR,*) 'LINE #',LINE
          WRITE (ERR,*) 'COULD NOT READ THE VALUE!!'
          WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...'
          WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPU
     *T?'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
        GOTO 6170
6520    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '***************ERROR***************'
          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I)
          WRITE (ERR,*) 'LINE #',LINE
          WRITE (ERR,*) 'COULD NOT READ THE STRING !!'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
6170    CONTINUE
7101  CONTINUE
7102  CONTINUE
      RETURN
6220  WRITE (ERR,*) '***************ERROR***************'
      WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE
      goto 6660
6660  CONTINUE
      ERROR_FLAG=1
      ERROR_FLAGS(I)=1
      RETURN
      entry get_input_plus_set_error_level(the_level)
      error_level = the_level
      return
      END
      subroutine get_media_inputs(ounit)
      implicit none
      integer*4 ounit
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      COMMON/BOUNDS/ECUT( 12001),PCUT( 12001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      common/ET_control/ smaxir( 12001),estepe,ximax,  skindepth_for_bca
     *,transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,10), eno_array(200,10), eno_atbin_array(200,10), n
     *_shell(10), radc_flag,  ibcmp( 12001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(10), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),
     *eii_sh(40),  eii_nshells(100),  eii_nsh(10),  eii_first(10,50),  e
     *ii_no(10,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/rayleigh_inputs/iray_ff_media(10),iray_ff_file(10)
      character*24 iray_ff_media
      character*128 iray_ff_file
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      COMMON/MEDINP/inpdensity_file(10),inpasym(10,50), inpstrn(24,10),p
     *z4(10,50), rhoz4(10,50),wa4(10,50),inpgasp(10)
      character*256 inpdensity_file
      CHARACTER*4 inpasym,inpstrn
      real*4 pz4,rhoz4,wa4,inpgasp
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100)
      integer*4 NET
      real*4 ITBL,WATBL,RHOTBL
      CHARACTER*4 ASYMT
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      integer*4 ival,ival_media,ival_medfile,i,j,k,ival_ae,ival_ue,ival_
     *ap,ival_up, ival_rho,ival_elements,ival_rhoz,ival_iunrst,ival_iapr
     *im,ival_gasp, ival_pz,ival_sterncid, ival_densityfile,medfile_erro
     *r,ival_outfile, egs_open_file,lnblnk1,i_medfile,egs_get_unit,i_med
     *err,mindex,eindex, i_density,i01,length,i_outfile
      real*8 ecut_min, pcut_min
      logical medfile_specified,densityfile_specified,elements_specified
     *, outfile_specified(10)
      logical iunrst_specified,stern_specified,iaprim_specified, gasp_sp
     *ecified,rho_specified,start_delim_found,end_delim_found, spec_by_p
     *z,spec_by_rhoz,df_if_elem_mismatch(10), df_if_rho_mismatch(10)
      logical ex
      integer*4 CURSOR,Kconvert
      real*4 ZTBL
      real*8 EKE,ELKE,TMXSO,DEDXE,DEDXP,EFRACT,SIGE,SIGP,BREME,BREMP,ETA
     *B(16), EIE,PLOTE(300),PLOTEM(300),PLOTEEN(300), PLOTEMP(300), PLOT
     *EMS(300)
      integer*4 IPLOTE,IFLAG1,IFLAG2,LELKE
      CHARACTER*60 GRAPHTITLE,XAXIS,YAXISPcom,YAXISPmfp,YAXISE,YAXISEmfp
     *, SUBTITLE,SERIES
      DATA ETAB/1.,1.25,1.5,1.75,2.,2.5,3.,3.5,4.,4.5,5.,5.5,6.,7.,8.,9.
     */
      character*24 medium_name,med_tmp,sterncid_tmp
      character*256 density_file,material_file,tmp_string, spoutput_file
     *(10)
      character*80 text_string, text_save, title
      character*80 delim_start,delim_end
      character*1 blank
      character*512 toUpper
      integer*4 nne_tmp,iaprim_tmp,epstfl_tmp,iunrst_tmp
      real*8 rho_tmp,rhoz_tmp(50),z_tmp(50),pz_tmp(50),ae_tmp,ap_tmp, ue
     *_tmp,up_tmp,gasp_tmp
      CHARACTER*4 asym_tmp(50)
      integer*4 nepst_df,nne_df
      real*8 iev_df,rho_df,z_df(50),rhoz_df(50),rhoz_tot
      CHARACTER*4 asym_df(50)
      data blank/' '/
      save medfile_specified,material_file,df_if_elem_mismatch,df_if_rho
     *_mismatch, spoutput_file,outfile_specified
      call get_input_set_error_level(0)
      call get_input_plus_set_error_level(0)
      IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
        i_mederr=17
        i_mederr=egs_open_file(i_mederr,0,1,'.mederr')
      END IF
      ecut_min=999.
      pcut_min=999.
      DO 7461 i=1, 12001
        IF((ecut(i).LT.ecut_min))ecut_min=ecut(i)
        IF((pcut(i).LT.pcut_min))pcut_min=pcut(i)
7461  CONTINUE
7462  CONTINUE
      delimeter = 'MEDIA DEFINITION'
      ival = 0
      ival = ival + 1
      ival_medfile = ival
      values_sought(ival) = 'material data file'
      nvalue(ival) = 1
      type(ival) = 2
      Nmin = ival_medfile
      Nmax = ival_medfile
      CALL GET_INPUT
      IF ((error_flags(ival_medfile).EQ.0)) THEN
        material_file=char_value(ival_medfile,1)
        medfile_specified=.true.
        i_medfile=17
        i_medfile=egs_get_unit(i_medfile)
        IF ((i_medfile .LT. 1)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a)') 'Error: Failed to get available fortran uni
     *t for', ' medium data file.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_medfile,file=material_file,status='old',err=7470)
        medfile_specified=.true.
      ELSE
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Warning: material data file not supplied.'
        END IF
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Thus, you must define media explicitly in i
     *nput file'
        END IF
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' or via density correction file.'
        END IF
        medfile_specified=.false.
      END IF
      ival = ival + 1
      ival_ae = ival
      values_sought(ival) = 'ae'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 999.
      default(ival) = ecut_min
      ival = ival + 1
      ival_ap = ival
      values_sought(ival) = 'ap'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 999.
      default(ival) = pcut_min
      ival = ival + 1
      ival_ue = ival
      values_sought(ival) = 'ue'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 999.
      default(ival) = 50 + prm
      ival = ival + 1
      ival_up = ival
      values_sought(ival) = 'up'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 999.
      default(ival) = 50.0
      Nmin=ival_ae
      Nmax=ival_up
      CALL GET_INPUT
      IF ((error_flags(ival_ae).EQ.0)) THEN
        ae_tmp=value(ival_ae,1)
      ELSE
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Warning: AE for media not supplied.  Will u
     *se min. ECUT.'
        END IF
        ae_tmp=ecut_min
      END IF
      IF ((error_flags(ival_ap).EQ.0)) THEN
        ap_tmp=value(ival_ap,1)
      ELSE
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Warning: AP for media not supplied.  Will u
     *se min. PCUT.'
        END IF
        ap_tmp=pcut_min
      END IF
      IF ((error_flags(ival_ue).EQ.0)) THEN
        ue_tmp=value(ival_ue,1)
      ELSE
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Warning: UE for media not supplied.  Will u
     *se                     50.5109989461 MeV'
        END IF
        ue_tmp=50 + prm
      END IF
      IF ((error_flags(ival_up).EQ.0)) THEN
        up_tmp=value(ival_up,1)
      ELSE
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Warning: UP for media not supplied.  Will u
     *se 50.0 MeV'
        END IF
        up_tmp=50.
      END IF
      IF ((ue_tmp.LE.ae_tmp)) THEN
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Error: UE <= AE.  Adjust value(s) and try a
     *gain.'
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(a)') ' Error: UE <= AE.  Adjust value(s) and try a
     *gain.'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF ((up_tmp.LE.ap_tmp)) THEN
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Error: UP <= AP.  Adjust value(s) and try a
     *gain.'
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(a)') ' Error: UP <= AP.  Adjust value(s) and try a
     *gain.'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      DO 7481 i=1,NMED
        DO 7491 j=1,24
          medium_name(j:j)=media(j,i)
7491    CONTINUE
7492    CONTINUE
        elements_specified=.false.
        rho_specified=.false.
        densityfile_specified=.false.
        stern_specified=.false.
        iunrst_specified=.false.
        iaprim_specified=.false.
        gasp_specified=.false.
        spec_by_rhoz=.false.
        spec_by_pz=.false.
        df_if_elem_mismatch(i)=.false.
        df_if_rho_mismatch(i)=.false.
        sterncid_tmp=medium_name
        gasp_tmp=0.0
        iunrst_tmp=0
        iaprim_tmp=0
        epstfl_tmp=0
        density_file=' '
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' '
        END IF
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' For medium: ',medium_name
        END IF
        delimeter=medium_name(:lnblnk1(medium_name))
        ival=0
        ival=ival+1
        ival_elements=ival
        values_sought(ival) = 'elements'
        type(ival) = 2
        nvalue(ival) = 0
        nmin=ival_elements
        nmax=ival_elements
        CALL GET_INPUT
        IF ((error_flags(ival_elements).EQ.0)) THEN
          DO 7501 j=1,nvalue(ival_elements)
            DO 7511 Kconvert=1,lnblnk1(char_value(ival_elements,j))
              CURSOR=ICHAR(char_value(ival_elements,j)(Kconvert:Kconvert
     *        ))
              IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                CURSOR=CURSOR-32
                char_value(ival_elements,j)(Kconvert:Kconvert)=CHAR(CURS
     *          OR)
              END IF
7511        CONTINUE
7512        CONTINUE
7501      CONTINUE
7502      CONTINUE
          ival=ival+1
          ival_pz=ival
          nne_tmp=nvalue(ival_elements)
          values_sought(ival)='number of atoms'
          type(ival)=0
          nvalue(ival)=nne_tmp
          nmin=ival_pz
          nmax=ival_pz
          CALL GET_INPUT
          IF ((nne_tmp.GT.1 .AND. error_flags(ival_pz).EQ.0)) THEN
            DO 7521 j=1,nne_tmp
              asym_tmp(j)=char_value(ival_elements,j)
              pz_tmp(j)=value(ival_pz,j)
7521        CONTINUE
7522        CONTINUE
            elements_specified=.true.
            spec_by_pz=.true.
          ELSE
            ival=ival+1
            ival_rhoz=ival
            values_sought(ival)='mass fractions'
            type(ival)=1
            nvalue(ival)=nne_tmp
            nmin=ival_rhoz
            nmax=ival_rhoz
            IF ((nne_tmp.EQ.1)) THEN
              value_min(ival)=0.0
              value_max(ival)=1.e15
              default(ival)=1.
            END IF
            CALL GET_INPUT
            IF ((error_flags(ival_rhoz).EQ.0)) THEN
              DO 7531 j=1,nne_tmp
                asym_tmp(j)=char_value(ival_elements,j)
                rhoz_tmp(j)=value(ival_rhoz,j)
7531          CONTINUE
7532          CONTINUE
              elements_specified=.true.
              spec_by_rhoz=.true.
            END IF
          END IF
          IF ((nne_tmp.EQ.1 .AND. .NOT.elements_specified)) THEN
            asym_tmp(1)=char_value(ival_elements,1)
            pz_tmp(1)=1
            elements_specified=.true.
            spec_by_pz=.true.
          END IF
          IF ((elements_specified)) THEN
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' Composition specified in .egsinp file.'
            END IF
          END IF
        END IF
        ival=ival+1
        ival_rho=ival
        values_sought(ival) = 'rho'
        type(ival)=1
        nvalue(ival)=1
        value_min(ival)=0.
        value_max(ival)=1e15
        default(ival)=1.0
        nmin=ival_rho
        nmax=ival_rho
        CALL GET_INPUT
        IF ((error_flags(ival_rho).EQ.0)) THEN
          rho_tmp=value(ival_rho,1)
          rho_specified=.true.
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' Rho specified in .egsinp file.'
          END IF
        END IF
        ival=ival+1
        ival_sterncid=ival
        values_sought(ival)='sterncid'
        type(ival)=2
        nvalue(ival)=1
        nmin=ival_sterncid
        nmax=ival_sterncid
        CALL GET_INPUT
        IF ((error_flags(ival_sterncid).EQ.0)) THEN
          sterncid_tmp=char_value(ival_sterncid,1)
          stern_specified=.true.
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' STERNCID specified in .egsinp file.'
          END IF
        END IF
        ival=ival+1
        ival_iunrst=ival
        values_sought(ival)='stopping powers'
        type(ival)=3
        nvalue(ival)=1
        allowed_inputs(ival,0)='restricted total'
        allowed_inputs(ival,1)='unrestricted collision'
        allowed_inputs(ival,2)='unrestricted collision and radiative'
        allowed_inputs(ival,3)='unrestricted collision and restricted ra
     *diative'
        allowed_inputs(ival,4)='restricted collision and unrestricted ra
     *diative'
        allowed_inputs(ival,5)='unrestricted radiative'
        nmin=ival_iunrst
        nmax=ival_iunrst
        CALL GET_INPUT
        IF ((error_flags(ival_iunrst).EQ.0)) THEN
          iunrst_tmp=value(ival_iunrst,1)
          iunrst_specified=.true.
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' IUNRST specified in .egsinp file.'
          END IF
        END IF
        ival=ival+1
        ival_iaprim=ival
        values_sought(ival)='bremsstrahlung correction'
        type(ival)=3
        nvalue(ival)=1
        allowed_inputs(ival,0)='KM'
        allowed_inputs(ival,1)='NRC'
        allowed_inputs(ival,2)='none'
        nmin=ival_iaprim
        nmax=ival_iaprim
        CALL GET_INPUT
        IF ((error_flags(ival_iaprim).EQ.0)) THEN
          iaprim_tmp=value(ival_iaprim,1)
          iaprim_specified=.true.
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' IAPRIM specified in .egsinp file.'
          END IF
        END IF
        ival=ival+1
        ival_gasp=ival
        values_sought(ival)='gas pressure'
        type(ival)=1
        nvalue(ival)=1
        value_min(ival)=0.
        value_max(ival)=1e15
        default(ival)=0.0
        nmin=ival_gasp
        nmax=ival_gasp
        CALL GET_INPUT
        IF ((error_flags(ival_gasp).EQ.0)) THEN
          gasp_tmp=value(ival_gasp,1)
          gasp_specified=.true.
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' GASP specified in .egsinp file.'
          END IF
        END IF
        ival=ival+1
        ival_densityfile=ival
        values_sought(ival)='density correction file'
        type(ival) = 2
        nvalue(ival)=1
        nmin=ival_densityfile
        nmax=ival_densityfile
        CALL GET_INPUT
        IF ((error_flags(ival_densityfile).EQ.0)) THEN
          density_file=char_value(ival_densityfile,1)
          densityfile_specified=.true.
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' Density correction file specified in .egs
     *inp file.'
          END IF
        END IF
        ival = ival+1
        ival_outfile = ival
        values_sought(ival) = 'e- stopping power output file'
        type(ival) = 2
        nvalue(ival) =1
        nmin=ival_outfile
        nmax=ival_outfile
        CALL GET_INPUT
        IF ((error_flags(ival_outfile).EQ.0)) THEN
          spoutput_file(i)=char_value(ival_outfile,1)
          outfile_specified(i)=.true.
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' e- stopping powers will be output to ', s
     *      poutput_file(i)
          END IF
        ELSE
          outfile_specified(i)=.false.
        END IF
        IF ((medfile_specified .AND. (.NOT.elements_specified .OR. .NOT.
     *  rho_specified .OR. .NOT.iunrst_specified .OR. .NOT.iaprim_specif
     *  ied .OR. .NOT.gasp_specified .OR. .NOT.stern_specified .OR. .NOT
     *  .densityfile_specified))) THEN
          rewind(i_medfile)
          start_delim_found=.false.
          end_delim_found=.false.
7541      IF((.NOT.(.NOT.start_delim_found)).AND.(.NOT.(.NOT.end_delim_f
     *    ound)))GO TO 7542
            read(i_medfile,'(a)',end=7550)text_string
            text_save=text_string
            text_string=toUpper(text_string(:lnblnk1(text_string)))
            mindex=index(text_string,'MEDIUM')
            eindex=index(text_string,'=')
            IF ((mindex.GT.0 .AND. eindex.GT.mindex)) THEN
              text_string=text_save(eindex+1:)
              text_string=text_string(:lnblnk1(text_string))
              length = len(text_string)
7561          IF(index(text_string,blank).NE.1)GO TO 7562
                IF (( length .GE. 2 )) THEN
                  text_string=text_string(2:)
                ELSE
                  GO TO7562
                END IF
                length = length - 1
              GO TO 7561
7562          CONTINUE
              IF ((text_string.EQ.medium_name)) THEN
                delim_start=text_save
                start_delim_found=.true.
              ELSE IF((start_delim_found)) THEN
                delim_end=text_save
                end_delim_found=.true.
              END IF
            END IF
          GO TO 7541
7542      CONTINUE
7550      IF ((.NOT.start_delim_found)) THEN
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' Warning: Data for ',medium_name,' not f
     *ound'
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' in material data file.'
            END IF
          ELSE
            IF ((.NOT.end_delim_found)) THEN
              delim_end='NONE'
            END IF
            ival=0
            IF ((.NOT.elements_specified)) THEN
              ival=ival+1
              ival_elements=ival
              values_sought(ival) = 'elements'
              type(ival) = 2
              nvalue(ival) = 0
              nmin=ival_elements
              nmax=ival_elements
              CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
              IF ((error_flags(ival_elements).EQ.0)) THEN
                ival=ival+1
                ival_pz=ival
                nne_tmp=nvalue(ival_elements)
                values_sought(ival)='number of atoms'
                type(ival)=0
                nvalue(ival)=nne_tmp
                nmin=ival_pz
                nmax=ival_pz
                CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
                IF ((nne_tmp.GT.1 .AND. error_flags(ival_pz).EQ.0)) THEN
                  DO 7571 j=1,nne_tmp
                    asym_tmp(j)=char_value(ival_elements,j)
                    pz_tmp(j)=value(ival_pz,j)
7571              CONTINUE
7572              CONTINUE
                  elements_specified=.true.
                  spec_by_pz=.true.
                ELSE
                  ival=ival+1
                  ival_rhoz=ival
                  values_sought(ival)='mass fractions'
                  type(ival)=1
                  nvalue(ival)=nne_tmp
                  nmin=ival_rhoz
                  nmax=ival_rhoz
                  IF ((nne_tmp.EQ.1)) THEN
                    value_min(ival)=0.0
                    value_max(ival)=1.e15
                    default(ival)=1.
                  END IF
                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
                  IF ((error_flags(ival_rhoz).EQ.0)) THEN
                    DO 7581 j=1,nne_tmp
                      asym_tmp(j)=char_value(ival_elements,j)
                      rhoz_tmp(j)=value(ival_rhoz,j)
7581                CONTINUE
7582                CONTINUE
                    elements_specified=.true.
                    spec_by_rhoz=.true.
                  END IF
                END IF
                IF ((nne_tmp.EQ.1 .AND. .NOT.elements_specified)) THEN
                  asym_tmp(1)=char_value(ival_elements,1)
                  pz_tmp(1)=1
                  elements_specified=.true.
                  spec_by_pz=.true.
                END IF
                IF ((elements_specified)) THEN
                  IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel
     *            )) THEN
                    write(i_mederr,*)' Composition specified in material
     * data file'
                  END IF
                END IF
              END IF
            END IF
            IF ((.NOT.rho_specified)) THEN
              ival=ival+1
              ival_rho=ival
              values_sought(ival) = 'rho'
              type(ival)=1
              nvalue(ival)=1
              value_min(ival)=0.
              value_max(ival)=1e15
              default(ival)=1.0
              nmin=ival_rho
              nmax=ival_rho
              CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
              IF ((error_flags(ival_rho).EQ.0)) THEN
                rho_tmp=value(ival_rho,1)
                rho_specified=.true.
                IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *           THEN
                  write(i_mederr,*)' Rho specified in material data file
     *'
                END IF
              END IF
            END IF
            IF ((.NOT.stern_specified)) THEN
              ival=ival+1
              ival_sterncid=ival
              values_sought(ival)='sterncid'
              type(ival)=2
              nvalue(ival)=1
              nmin=ival_sterncid
              nmax=ival_sterncid
              CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
              IF ((error_flags(ival_sterncid).EQ.0)) THEN
                sterncid_tmp=char_value(ival_sterncid,1)
                stern_specified=.true.
                IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *           THEN
                  write(i_mederr,*)' STERNCID specified in material data
     * file'
                END IF
              END IF
            END IF
            IF ((.NOT.iunrst_specified)) THEN
              ival=ival+1
              ival_iunrst=ival
              values_sought(ival)='stopping powers'
              type(ival)=3
              nvalue(ival)=1
              allowed_inputs(ival,0)='restricted total'
              allowed_inputs(ival,1)='unrestricted collision'
              allowed_inputs(ival,2)='unrestricted collision and radiati
     *ve'
              allowed_inputs(ival,3)= 'unrestricted collision and restri
     *cted radiative'
              allowed_inputs(ival,4)= 'restricted collision and unrestri
     *cted radiative'
              allowed_inputs(ival,5)='unrestricted radiative'
              nmin=ival_iunrst
              nmax=ival_iunrst
              CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
              IF ((error_flags(ival_iunrst).EQ.0)) THEN
                iunrst_tmp=value(ival_iunrst,1)
                iunrst_specified=.true.
                IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *           THEN
                  write(i_mederr,*)' IUNRST specified in material data f
     *ile'
                END IF
              END IF
            END IF
            IF ((.NOT.iaprim_specified)) THEN
              ival=ival+1
              ival_iaprim=ival
              values_sought(ival)='bremsstrahlung correction'
              type(ival)=3
              nvalue(ival)=1
              allowed_inputs(ival,0)='KM'
              allowed_inputs(ival,1)='NRC'
              allowed_inputs(ival,2)='none'
              nmin=ival_iaprim
              nmax=ival_iaprim
              CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
              IF ((error_flags(ival_iaprim).EQ.0)) THEN
                iaprim_tmp=value(ival_iaprim,1)
                iaprim_specified=.true.
                IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *           THEN
                  write(i_mederr,*)' IAPRIM specified in material data f
     *ile'
                END IF
              END IF
            END IF
            IF ((.NOT.gasp_specified)) THEN
              ival=ival+1
              ival_gasp=ival
              values_sought(ival)='gas pressure'
              type(ival)=1
              nvalue(ival)=1
              value_min(ival)=0.
              value_max(ival)=1.e15
              default(ival)=0.
              nmin=ival_gasp
              nmax=ival_gasp
              CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
              IF ((error_flags(ival_gasp).EQ.0)) THEN
                gasp_tmp=value(ival_gasp,1)
                gasp_specified=.true.
                IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *           THEN
                  write(i_mederr,*)' GASP specified in material data fil
     *e'
                END IF
              END IF
            END IF
            IF ((.NOT.densityfile_specified)) THEN
              ival=ival+1
              ival_densityfile=ival
              values_sought(ival)='density correction file'
              type(ival) = 2
              nvalue(ival)=1
              nmin=ival_densityfile
              nmax=ival_densityfile
              CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
              IF ((error_flags(ival_densityfile).EQ.0)) THEN
                density_file=char_value(ival_densityfile,1)
                densityfile_specified=.true.
                IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *           THEN
                  write(i_mederr,*)' Density correction file specified i
     *n material data file.'
                END IF
              END IF
            END IF
          END IF
        END IF
        IF ((densityfile_specified)) THEN
          write(*,*)' density_file ',density_file
          IF ((index(density_file,'/').GT.0)) THEN
            tmp_string=density_file(:lnblnk1(density_file))
            inquire(file=tmp_string,exist=ex)
            IF ((.NOT.ex)) THEN
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' Error: Density correction file ',tmp_
     *          string
              END IF
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' cannot be found.'
              END IF
            END IF
          ELSE
            density_file=density_file(:lnblnk1(density_file))//'.density
     *'
            tmp_string=egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/' //
     *       'density_corrections' // '/' // density_file
            inquire(file=tmp_string,exist=ex)
            IF((ex))goto 7590
            tmp_string=egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/' //
     *       'density_corrections' // '/' // 'elements' // '/' // densit
     *      y_file
            inquire(file=tmp_string,exist=ex)
            IF((ex))goto 7590
            tmp_string=egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/' //
     *       'density_corrections' // '/' // 'compounds' // '/' // densi
     *      ty_file
            inquire(file=tmp_string,exist=ex)
            IF((ex))goto 7590
            tmp_string=egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/' //
     *       'density' // '/' // density_file
            inquire(file=tmp_string,exist=ex)
            IF((ex))goto 7590
            tmp_string=hen_house(:lnblnk1(hen_house)) // 'pegs4' // '/'
     *      // 'density_corrections' // '/' // 'elements' // '/' // dens
     *      ity_file
            inquire(file=tmp_string,exist=ex)
            IF((ex))goto 7590
            tmp_string=hen_house(:lnblnk1(hen_house)) // 'pegs4' // '/'
     *      // 'density_corrections' // '/' // 'compounds' // '/' // den
     *      sity_file
            inquire(file=tmp_string,exist=ex)
            IF((ex))goto 7590
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' Error: Density correction file', densit
     *        y_file
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' does not exist in'
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' $EGS_HOME/pegs4/density_corrections, '
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' $EGS_HOME/pegs4/density_corrections/ele
     *ments, '
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' $EGS_HOME/pegs4/density_corrections/com
     *pounds, '
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' $EGS_HOME/pegs4/density, '
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' $HEN_HOUSE/pegs4/density_corrections/el
     *ements or '
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' $HEN_HOUSE/pegs4/density_corrections/co
     *mpounds.'
            END IF
7590        CONTINUE
          END IF
        END IF
        IF ((densityfile_specified)) THEN
          i_density=19
          i_density=egs_get_unit(i_density)
          IF ((i_density .LT. 1)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a)') 'Error: Failed to get available fortran u
     *nit for', ' density correction file.'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(i_density,file=tmp_string,status='old',err=7600)
          density_file=tmp_string
          densityfile_specified=.true.
          epstfl_tmp=1
          read(i_density,'(a)')title
          read(i_density,*)nepst_df,iev_df,rho_df,nne_df
          read(i_density,*)(z_df(j),rhoz_df(j),j=1,nne_df)
          DO 7611 j=1,nne_df
            i01=z_df(j)
            asym_df(j)=ASYMT(i01)
7611      CONTINUE
7612      CONTINUE
          IF ((elements_specified)) THEN
            IF ((nne_tmp.NE.nne_df)) THEN
              df_if_elem_mismatch(i)=.true.
            ELSE
              rhoz_tot=0.
              DO 7621 j=1,nne_tmp
                IF ((spec_by_pz)) THEN
                  i01=ZTBL(asym_tmp(j))
                  rhoz_tmp(j)=pz_tmp(j)*WATBL(i01)
                END IF
                rhoz_tot=rhoz_tot+rhoz_tmp(j)
7621          CONTINUE
7622          CONTINUE
              DO 7631 j=1,nne_df
                DO 7641 k=1,nne_tmp
                  IF ((asym_df(j).EQ.asym_tmp(k))) THEN
                    IF ((rhoz_df(j).GT.(1+0.01)*rhoz_tmp(k)/rhoz_tot .OR
     *              . rhoz_df(j).LT.(1-0.01)*rhoz_tmp(k)/rhoz_tot)) THEN
                      df_if_elem_mismatch(i)=.true.
                    END IF
                    exit
                  END IF
7641            CONTINUE
7642            CONTINUE
                IF((k.GT.nne_tmp))df_if_elem_mismatch(i)=.true.
                IF ((df_if_elem_mismatch(i))) THEN
                  exit
                END IF
7631          CONTINUE
7632          CONTINUE
            END IF
            IF ((df_if_elem_mismatch(i))) THEN
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' Warning: composition specified in den
     *sity correction', ' file is not the same as that'
              END IF
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' specified in input or material data f
     *ile.'
              END IF
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' Will use the composition specified in
     * the density correction file.'
              END IF
              nne_tmp=nne_df
              DO 7651 j=1,nne_tmp
                z_tmp(j)=z_df(j)
                rhoz_tmp(j)=rhoz_df(j)
                asym_tmp(j)=asym_df(j)
7651          CONTINUE
7652          CONTINUE
              spec_by_rhoz=.true.
            END IF
          ELSE
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' Composition specified in density correc
     *tion file'
            END IF
            nne_tmp=nne_df
            DO 7661 j=1,nne_tmp
              z_tmp(j)=z_df(j)
              rhoz_tmp(j)=rhoz_df(j)
              asym_tmp(j)=asym_df(j)
7661        CONTINUE
7662        CONTINUE
            spec_by_rhoz=.true.
            elements_specified=.true.
          END IF
          IF ((rho_specified)) THEN
            IF ((rho_df.GT.(1+0.01)*rho_tmp .OR. rho_df.LT.(1-0.01)*rho_
     *      tmp)) THEN
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' Warning: rho specified in density cor
     *rection', ' file is not the same as that'
              END IF
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' specified in input or material data f
     *ile.'
              END IF
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' Will use rho as specified in the dens
     *ity correction file.'
              END IF
              rho_tmp=rho_df
              df_if_rho_mismatch(i)=.true.
            END IF
          ELSE
            rho_tmp=rho_df
            rho_specified=.true.
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' Rho specified in density correction fil
     *e'
            END IF
          END IF
          IF ((gasp_specified)) THEN
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' Warning: gas pressure input not require
     *d', ' when using density correction file.  Will set GASP=0.'
            END IF
            gasp_specified=.false.
            gasp_tmp=0.
          END IF
          close(i_density)
        END IF
        IF ((elements_specified .AND. rho_specified)) THEN
          ae(i)=ae_tmp
          ue(i)=ue_tmp
          ap(i)=ap_tmp
          up(i)=up_tmp
          DO 7671 j=1,24
            inpstrn(j,i) = sterncid_tmp(j:j)
7671      CONTINUE
7672      CONTINUE
          nne(i)=nne_tmp
          rho(i)=rho_tmp
          DO 7681 j=1,nne_tmp
            inpasym(i,j)=asym_tmp(j)
            zelem(i,j)=ZTBL(asym_tmp(j))
            i01=zelem(i,j)
            wa(i,j)=WATBL(i01)
            wa4(i,j)=WATBL(i01)
            IF ((spec_by_rhoz)) THEN
              rhoz(i,j)=rhoz_tmp(j)
              rhoz4(i,j)=rhoz_tmp(j)
              pz(i,j)=rhoz(i,j)/wa(i,j)
              pz4(i,j)=rhoz4(i,j)/wa4(i,j)
            ELSE IF((spec_by_pz)) THEN
              pz(i,j)=pz_tmp(j)
              pz4(i,j)=pz_tmp(j)
              rhoz(i,j)=pz(i,j)*wa(i,j)
              rhoz4(i,j)=pz4(i,j)*wa4(i,j)
            END IF
7681      CONTINUE
7682      CONTINUE
          iunrst(i)=iunrst_tmp
          iaprim(i)=iaprim_tmp
          epstfl(i)=epstfl_tmp
          inpgasp(i)=gasp_tmp
          inpdensity_file(i)=density_file
        ELSE
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' Error: Medium ',medium_name,' not correct
     *ly defined.'
          END IF
        END IF
7481  CONTINUE
7482  CONTINUE
      IF((medfile_specified))close(i_medfile)
      IF((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))close(i_med
     *err)
      entry show_media_parameters(ounit)
      IF((ounit .LE. 0))return
      IF ((is_pegsless)) THEN
        write(ounit,*)
        write(ounit,*)' Medium data: '
        write(ounit,*)
        write(ounit,'(a,1p,e14.5,a,e14.5,a)')' AE = ',ae(1),' MeV,  UE =
     * ',ue(1),' MeV'
        write(ounit,'(a,1p,e14.5,a,e14.5,a)')' AP = ',ap(1),' MeV,  UP =
     * ',up(1),' MeV'
        write(ounit,*)
        IF ((medfile_specified)) THEN
          write(ounit,*)' Material data file: ',material_file
        ELSE
          write(ounit,*)' No material data file supplied.  Material data
     * obtained from'
          write(ounit,*)' .egsinp file or density correction file.'
        END IF
        write(ounit,*)
        DO 7691 i=1,nmed
          write(ounit,'(a,24a1)')'   Medium: ',(media(j,i),j=1,24)
          write(ounit,'(a,24a1)')' Sterncid: ',(inpstrn(j,i),j=1,24)
          write(ounit,'(a,1p,e14.5,a)')'     rho: ',rho(i),' g/cm^3'
          write(ounit,'(a,24a4)')' Elements: ',(inpasym(i,j),j=1,nne(i))
          write(ounit,'(a,1p,12e14.5)')'    rhoz: ',(rhoz(i,j),j=1,nne(i
     *    ))
          write(ounit,'(a,1p,12e14.5)')'      pz: ',(pz(i,j),j=1,nne(i))
          write(ounit,'(a,i5)')'  iunrst: ',iunrst(i)
          write(ounit,'(a,i5)')'  iaprim: ',iaprim(i)
          write(ounit,'(a,1p,e14.5,a)')'    gasp: ',inpgasp(i),' atm.'
          IF ((epstfl(i).EQ.1)) THEN
            write(ounit,*)' density correction file: ', inpdensity_file(
     *      i)(:lnblnk1(inpdensity_file(i)))
            IF ((df_if_elem_mismatch(i))) THEN
              write(ounit,*)' ****Warning: composition specified in dens
     *ity correction', ' file is not the same as that'
              write(ounit,*)' specified in input or material data file.'
              write(ounit,*) ' Will use the composition specified in the
     * density correction file.'
            END IF
            IF ((df_if_rho_mismatch(i))) THEN
              write(ounit,*)' ****Warning: rho specified in density corr
     *ection', ' file is not the same as that'
              write(ounit,*)' specified in input or material data file.'
              write(ounit,*) ' Will use rho as specified in the density
     *correction file.'
            END IF
          END IF
          write(ounit,*)
          IF ((outfile_specified(i) .AND. (n_parallel.EQ.0 .OR. i_parall
     *    el.EQ.first_parallel))) THEN
            inquire(file=spoutput_file(i),exist=ex)
            IF ((ex)) THEN
              write(i_log,'(/a)') '***************** Warning: '
              write(i_log,'(a)') 'Warning: stopping power output file ',
     *         spoutput_file(i),'already exists.  Will overwrite.'
            END IF
            i_outfile=20
            i_outfile=egs_get_unit(i_outfile)
            IF ((i_outfile .LT. 1)) THEN
              write(i_log,'(/a)') '***************** Warning: '
              write(i_log,'(a)') 'Warning: Failed to get available fortr
     *an unit for', ' stopping power output file.'
            END IF
            open(i_outfile,file=spoutput_file(i),status='unknown',err=77
     *      00)
            goto 7710
7700        write(i_log,'(/a)') '***************** Warning: '
            write(i_log,'(a)') 'Warning: Failed to open stopping power o
     *utput file ', spoutput_file(i)
            goto 7720
7710        IFLAG1=0
            IFLAG2=0
            IPLOTE=0
            MEDIUM=i
            XAXIS = 'kinetic energy / MeV'
            YAXISE = 'dE/drhoX MeV/g/cm\\S2\\N'
            YAXISEmfp = 'mean free path / cm'
            YAXISPmfp = 'mean free path / cm'
            write(GRAPHTITLE,'(24a1)')(media(j,i),j=1,24)
            SUBTITLE = 'Electron data'
            DO 7731 j=1,8
              DO 7741 k=1,16
                EKE=ETAB(k)*10.**(j-4)
                IF ((EKE .LE. AE(1)-PRM)) THEN
                  IF ((IFLAG1 .EQ. 0)) THEN
                    IFLAG1=1
                    EKE=AE(1)-PRM
                  ELSE
                    EKE=0.0
                  END IF
                END IF
                IF ((EKE .GT. UE(1)-PRM)) THEN
                  IF ((IFLAG2 .EQ. 0)) THEN
                    IFLAG2=1
                    EKE=UE(1)-PRM
                  ELSE
                    EKE=1.E30
                  END IF
                END IF
                EIE=EKE+PRM
                TMXSO=0.0
                DEDXE=0.0
                DEDXP=0.0
                EFRACT=0.0
                IF ((EIE .GE. AE(1)-0.0001 .AND. EIE .LE. UE(1)+0.001))
     *          THEN
                  ELKE=LOG(EKE)
                  LELKE=EKE1(MEDIUM)*ELKE+EKE0(MEDIUM)
                  DEDXE=EDEDX1(LELKE,MEDIUM)*ELKE+EDEDX0(LELKE,MEDIUM)
                  IPLOTE=IPLOTE+1
                  PLOTEEN(IPLOTE)=EKE
                  PLOTE(IPLOTE)=DEDXE/RHO(MEDIUM)
                END IF
7741          CONTINUE
7742          CONTINUE
7731        CONTINUE
7732        CONTINUE
            IF ((IPLOTE.GT.0)) THEN
              IF ((iunrst(i).EQ.0)) THEN
                SERIES='restricted total stopping power'
              ELSE IF((iunrst(i).EQ.1)) THEN
                SERIES='unrestricted collision stopping power'
              ELSE IF((iunrst(i).EQ.2)) THEN
                SERIES='unrestricted collision + radiative stopping powe
     *r'
              ELSE IF((iunrst(i).EQ.3)) THEN
                SERIES='unrestricted collision + restricted radiative st
     *opping power'
              ELSE IF((iunrst(i).EQ.4)) THEN
                SERIES='restricted collision + unrestricted radiative st
     *opping power'
              ELSE IF((iunrst(i).EQ.5)) THEN
                SERIES='unrestricted radiative stopping power'
              END IF
              CALL MEDXVGRPLOT(PLOTEEN,PLOTE,IPLOTE,0,SERIES, XAXIS,YAXI
     *        SE,GRAPHTITLE,SUBTITLE,i_outfile,2)
            END IF
            close(i_outfile)
7720        CONTINUE
          END IF
7691    CONTINUE
7692    CONTINUE
      END IF
      return
7470  write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a)') 'Error: Cannot open material data file',materia
     *l_file
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
7600  write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a)') 'Error: Cannot open density correction file: ',
     * density_file(:lnblnk1(density_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      SUBROUTINE MEDXVGRPLOT (X, Y, NPTS, CURVENUM, SERIESTITLE, XTITLE,
     * YTITLE, GRAPHTITLE, SUBTITLE, UNITNUM, AXISTYPE)
      IMPLICIT NONE
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 MAX
      PARAMETER (MAX = 400)
      integer*4 NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE
      real*8 X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,SMALLESTX, SMALLESTY,FUDGE
      integer*4 TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENG
     *TH
      integer*4 LOGX, LOGY
      CHARACTER*(*) SUBTITLE
      CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE
      logical TESTFILE, ALLPOS
      FUDGE = 1.e-10
      IF (( NPTS .gt. MAX)) THEN
        WRITE(6,7750)NPTS, MAX
7750    FORMAT(//' **************************'/ ' Number of points asked
     * for =', I5, ' is greater than max allowed of', I4/ ' Setting NPTS
     * to MAX, you could adjust MAX in xvgrplot.mortran'/ ' ************
     ***************'//)
        NPTS1 = MAX
      ELSE
        NPTS1 = NPTS
      END IF
      INQUIRE(UNIT = UNITNUM,OPENED=TESTFILE)
      IF ((.NOT.TESTFILE)) THEN
        WRITE(6,7760) UNITNUM
7760    FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------' ,/'
     *   Unit specified (',I2,') is not open.' ,/'   Unit must be opened
     * before using subroutine.' ,/'   Data not written to file.' ,/'  -
     *---------------------------------------------'//)
        RETURN
      END IF
      TITLELENGTH = 61
      SUBLENGTH = 61
      XAXISLENGTH = 61
      YAXISLENGTH = 61
      SERIESLENGTH = 61
7771  CONTINUE
        TITLELENGTH = TITLELENGTH - 1
        IF(((GRAPHTITLE(TITLELENGTH:TITLELENGTH) .NE. ' ')))GO TO7772
      GO TO 7771
7772  CONTINUE
7781  CONTINUE
        SUBLENGTH = SUBLENGTH - 1
        IF(((SUBTITLE(SUBLENGTH:SUBLENGTH) .NE. ' ')))GO TO7782
      GO TO 7781
7782  CONTINUE
7791  CONTINUE
        XAXISLENGTH = XAXISLENGTH - 1
        IF(((XTITLE(XAXISLENGTH:XAXISLENGTH) .NE. ' ')))GO TO7792
      GO TO 7791
7792  CONTINUE
7801  CONTINUE
        YAXISLENGTH = YAXISLENGTH - 1
        IF(((YTITLE(YAXISLENGTH:YAXISLENGTH) .NE. ' ')))GO TO7802
      GO TO 7801
7802  CONTINUE
7811  CONTINUE
        SERIESLENGTH = SERIESLENGTH - 1
        IF(((SERIESTITLE(SERIESLENGTH:SERIESLENGTH) .NE. ' ')))GO TO7812
      GO TO 7811
7812  CONTINUE
      LOGX = 0
      LOGY = 0
      ALLPOS=.TRUE.
      IF (( X(1).EQ.0.0 )) THEN
        SMALLESTX = 0.1
      ELSE
        SMALLESTX=X(1)
      END IF
      IF (( Y(1).EQ.0.0 )) THEN
        SMALLESTY = 0.1
      ELSE
        SMALLESTY=Y(1)
      END IF
      DO 7821 COUNT=1,NPTS1
        IF (((X(COUNT) .LT. SMALLESTX) .AND. (X(COUNT).NE.0.))) THEN
          SMALLESTX=X(COUNT)
        END IF
        IF (((Y(COUNT) .LT. SMALLESTY) .AND. (Y(COUNT).NE.0.))) THEN
          SMALLESTY=Y(COUNT)
        END IF
        IF (((X(COUNT) .LT. 0.).OR.(Y(COUNT) .LT. 0.))) THEN
          ALLPOS=.FALSE.
        END IF
7821  CONTINUE
7822  CONTINUE
      IF ((ALLPOS)) THEN
        DO 7831 COUNT=1,NPTS1
          IF ((X(COUNT).EQ.0.)) THEN
            X(COUNT)=SMALLESTX*FUDGE
          END IF
          IF ((Y(COUNT).EQ.0.)) THEN
            Y(COUNT)=SMALLESTY*FUDGE
          END IF
7831    CONTINUE
7832    CONTINUE
      END IF
      IF ((AXISTYPE .GT. 0)) THEN
        DO 7841 COUNT=1,NPTS1
          IF ((X(COUNT) .LE. 0.)) THEN
            LOGX = 1
          END IF
          IF ((Y(COUNT) .LE. 0.)) THEN
            LOGY = 1
          END IF
7841    CONTINUE
7842    CONTINUE
      END IF
      IF ((CURVENUM .EQ. 0)) THEN
        IF ((AXISTYPE .EQ. 0)) THEN
          WRITE(UNITNUM,7850) 'xy'
        ELSE IF((AXISTYPE .EQ. 1)) THEN
          WRITE(UNITNUM,7850) 'logy'
          WRITE(UNITNUM,7860)
        ELSE IF((AXISTYPE .EQ. 2)) THEN
          WRITE(UNITNUM,7850) 'logx'
          WRITE(UNITNUM,7860)
        ELSE IF((AXISTYPE .EQ. 3)) THEN
          WRITE(UNITNUM,7850) 'logxy'
          WRITE(UNITNUM,7860)
          WRITE(UNITNUM,7870)
        ELSE
          WRITE(6,7880) AXISTYPE
7880      FORMAT (//'  ------------Error in Subroutine XVGRPLOT---------
     *--' ,/'   AXISTYPE specified (',I2,') is not a valid option.' ,/' 
     *----------------------------------------------'//)
          RETURN
        END IF
7850    FORMAT ('@g0 type ',A,' ')
7860    FORMAT ('@    xaxis  ticklabel format exponential')
7870    FORMAT ('@    yaxis  ticklabel format exponential')
        WRITE(UNITNUM,7890) GRAPHTITLE(1:TITLELENGTH) ,SUBTITLE(1:SUBLEN
     *  GTH) ,XTITLE(1:XAXISLENGTH) ,YTITLE(1:YAXISLENGTH)
7890    FORMAT ('@    title "',A,'"'/ ,'@    subtitle "',A,'"'/ ,'@    l
     *egend on'/ ,'@    legend box linestyle 0'/ ,'@    legend x1 0.6'/,
     *'@    legend y1 0.75'/ ,'@    view xmin 0.250000'/ ,'@    xaxis  l
     *abel "',A,'"'/ ,'@    timestamp on'/ ,'@    yaxis  label "',A,'"')
      END IF
      IF ((AXISTYPE .EQ. 1 .AND. LOGY .EQ. 1)) THEN
        WRITE(UNITNUM,7850) 'xy'
        WRITE(6,7900)
7900    FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------',
     */'  Log scale requested for Y axis when one or more   ' ,/'  Ydata
     * points are 0 or negative.                  ' ,//'  Y axis scale c
     *hanged to linear.                   ' ,/' ------------------------
     *---------------------------'/)
      END IF
      IF ((AXISTYPE .EQ. 2 .AND. LOGX .EQ. 1)) THEN
        WRITE(UNITNUM,7850) 'xy'
        WRITE(6,7910)
7910    FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------',
     */'  Log scale requested for X axis when one or more   ' ,/'  Xdata
     * points are 0 or negative.                  ' ,//'  X axis scale c
     *hanged to linear.                   ' ,/' ------------------------
     *---------------------------'/)
      END IF
      IF ((AXISTYPE .EQ. 3 .AND. (LOGX .EQ. 1 .OR. LOGY .EQ. 1))) THEN
        IF ((LOGX .EQ. 1 .AND. LOGY .EQ. 1)) THEN
          WRITE(UNITNUM,7850) 'xy'
          WRITE(6,7920)
7920      FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------
     *' ,/'  Log scale requested for X axis and Y axis when    ' ,/'  on
     *e or more X and Y data points are 0 or negative.' ,//'  X and Y ax
     *es scales changed to linear.            ' ,/' --------------------
     *-------------------------------'/)
        ELSE IF((LOGX .EQ. 1)) THEN
          WRITE(UNITNUM,7850) 'logy'
          WRITE(6,7910)
        ELSE
          WRITE(UNITNUM,7850) 'logx'
          WRITE(6,7900)
        END IF
      END IF
      IF ((CURVENUM .LT. 10 )) THEN
        WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM
      ELSE
        WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM
      END IF
      WRITE(UNITNUM,7930) CURVENUM,SERIESTITLE(1:SERIESLENGTH)
7930  FORMAT ('@    legend string ',I2,' "',A,'"')
      WRITE(UNITNUM,7940)
7940  FORMAT ('@TYPE xy')
      IF ((CURVENUM .LT. 10)) THEN
        WRITE(UNITNUM,7950) CURVENUM
        IF ((CURVENUM .EQ. 9)) THEN
          WRITE(UNITNUM,7960) CURVENUM, CURVENUM+1
        ELSE
          WRITE(UNITNUM,7970) CURVENUM, CURVENUM+1
        END IF
      ELSE
        WRITE(UNITNUM,7980) CURVENUM
        WRITE(UNITNUM,7990) CURVENUM, CURVENUM+1
      END IF
7950  FORMAT ('@    s',I1,' errorbar length 0.000000')
7980  FORMAT ('@    s',I2,' errorbar length 0.000000')
7960  FORMAT ('@    s',I1,' symbol color ',I2)
7970  FORMAT ('@    s',I1,' symbol color ',I1)
7990  FORMAT ('@    s',I2,' symbol color ',I2)
      DO 8001 COUNT=1,NPTS1
        WRITE(UNITNUM,8010) X(COUNT),Y(COUNT)
8001  CONTINUE
8002  CONTINUE
8010  FORMAT (1PE15.4,1PE15.4)
      WRITE(UNITNUM,'(''&'')')
      RETURN
      END
      SUBROUTINE ZONEGRID(NRADIAL, NDEPTH, NRMIN, NZMIN, NZ, RESULTS, UN
     *CRT, NCOMP, RADIAL_BINS, DEPTH_BINS, LABELS, EXPLANATIONS)
      IMPLICIT NONE
      CHARACTER*1 TITLE(80)
      COMMON/IODAT1/TITLE
      integer*4 RADNUM, DEEPNUM, NRADIAL, NDEPTH, NCOMP, REGNUM, FMT, TM
     *P1
      logical SFIG
      logical ROT
      real*8 RESULTS(200,60,7), UNCRT(200,60,7), RADIAL_BINS(60),DEPTH_B
     *INS( 201), TMP2,TMP3
      CHARACTER*60 EXPLANATIONS(7)
      CHARACTER*4 LABELS(7)
      integer*4 IOUT, ICOMP, IX, IZ, HSET, PGTHROW, DLYPT, COUNT,NZMIN,N
     *RMIN,NZ
      ROT=.FALSE.
      SFIG=.TRUE.
      IF ((NCOMP.GT.4)) THEN
        PGTHROW=20
      ELSE
        PGTHROW=17
      END IF
      IOUT=1
      RADNUM=NRADIAL
      DEEPNUM=NDEPTH
      COUNT = 0
      DO 8021 IX=1,RADNUM
        DO 8031 IZ=1,DEEPNUM
          DO 8041 ICOMP=1,NCOMP
            IF ((UNCRT(IZ, IX, ICOMP) .LT. 0.3)) THEN
              COUNT = COUNT + 1
            END IF
8041      CONTINUE
8042      CONTINUE
8031    CONTINUE
8032    CONTINUE
8021  CONTINUE
8022  CONTINUE
      IF ((COUNT/(RADNUM*DEEPNUM*NCOMP) .GT. 0.1)) THEN
        SFIG=.FALSE.
      END IF
      IF (((DEEPNUM.LE.3).AND.(RADNUM.GT.3))) THEN
        ROT=.TRUE.
        DO 8051 IX=1,RADNUM
          IF ((IX .LE. DEEPNUM+1)) THEN
            TMP3=RADIAL_BINS(IX)
            RADIAL_BINS(IX)=DEPTH_BINS(IX)
            DEPTH_BINS(IX)=TMP3
          ELSE
            DEPTH_BINS(IX)=RADIAL_BINS(IX)
          END IF
          IF ((IX .LE. DEEPNUM)) THEN
            DO 8061 IZ=IX+1,DEEPNUM
              DO 8071 ICOMP=1,NCOMP
                TMP2=RESULTS(IZ,IX,ICOMP)
                RESULTS(IZ,IX,ICOMP)=RESULTS(IX,IZ,ICOMP)
                RESULTS(IX,IZ,ICOMP)=TMP2
                TMP2=UNCRT(IZ,IX,ICOMP)
                UNCRT(IZ,IX,ICOMP)=UNCRT(IX,IZ,ICOMP)
                UNCRT(IX,IZ,ICOMP)=TMP2
8071          CONTINUE
8072          CONTINUE
8061        CONTINUE
8062        CONTINUE
          ELSE
            DO 8081 IZ=1,DEEPNUM
              DO 8091 ICOMP=1,NCOMP
                RESULTS(IX,IZ,ICOMP)=RESULTS(IZ,IX,ICOMP)
                UNCRT(IX,IZ,ICOMP)=UNCRT(IZ,IX,ICOMP)
8091          CONTINUE
8092          CONTINUE
8081        CONTINUE
8082        CONTINUE
          END IF
8051    CONTINUE
8052    CONTINUE
        DEPTH_BINS(RADNUM+1)=RADIAL_BINS(RADNUM+1)
        TMP1=RADNUM
        RADNUM=DEEPNUM
        DEEPNUM=TMP1
      END IF
      WRITE (IOUT, *) '\f'
      WRITE(IOUT, 400) ' '
      call egs_fdate(iout)
      write(iout,'(//)')
      IF ((ROT)) THEN
        WRITE(IOUT, 93) TITLE
      ELSE
        WRITE(IOUT, 94) TITLE
      END IF
      DO 8101 ICOMP=1,NCOMP
        WRITE(IOUT, 95) LABELS(ICOMP), EXPLANATIONS(ICOMP)
8101  CONTINUE
8102  CONTINUE
      DO 8111 HSET=1,RADNUM,3
        IF ((RADNUM-HSET.GT.1)) THEN
          FMT=3
        ELSE
          IF ((MOD(RADNUM,3) .EQ. 1)) THEN
            FMT=1
          END IF
          IF ((MOD(RADNUM,3) .EQ. 2)) THEN
            FMT=2
          END IF
        END IF
        WRITE (IOUT, 91) (RADIAL_BINS(IX),IX=HSET,HSET+FMT)
        PGTHROW=PGTHROW+1
        DO 8121 IZ=1,DEEPNUM
          IF ((ROT)) THEN
            REGNUM= (IZ+NRMIN-1)*NZ + HSET+NZMIN
          ELSE
            REGNUM= (HSET+NRMIN-1)*NZ + IZ+NZMIN
          END IF
          IF ((FMT.EQ.1)) THEN
            WRITE (IOUT, 10) DEPTH_BINS(IZ)
            IF ((SFIG)) THEN
              IF ((ROT)) THEN
                WRITE (IOUT, 15) REGNUM,HSET+NZMIN-1,IZ+NRMIN
              ELSE
                WRITE (IOUT, 15) REGNUM,IZ+NZMIN-1,HSET+NRMIN
              END IF
            ELSE
              IF ((ROT)) THEN
                WRITE (IOUT, 18) REGNUM,HSET+NZMIN-1,IZ+NRMIN
              ELSE
                WRITE (IOUT, 18) REGNUM,IZ+NZMIN-1,HSET+NRMIN
              END IF
            END IF
          END IF
          IF ((FMT.EQ.2)) THEN
            WRITE (IOUT, 11) DEPTH_BINS(IZ)
            IF ((SFIG)) THEN
              IF ((ROT)) THEN
                WRITE(IOUT,14) REGNUM,HSET+NZMIN-1,IZ+NRMIN, REGNUM+1,HS
     *          ET+NZMIN,IZ+NRMIN
              ELSE
                WRITE(IOUT,14) REGNUM,IZ+NZMIN-1,HSET+NRMIN, REGNUM+NZ,I
     *          Z+NZMIN-1,HSET+NRMIN+1
              END IF
            ELSE
              IF ((ROT)) THEN
                WRITE(IOUT,17) REGNUM,HSET+NZMIN-1,IZ+NRMIN, REGNUM+1,HS
     *          ET+NZMIN, IZ+NRMIN
              ELSE
                WRITE(IOUT,17) REGNUM,IZ+NZMIN-1,HSET+NRMIN, REGNUM+NZ,I
     *          Z+NZMIN-1,HSET+NRMIN+1
              END IF
            END IF
          END IF
          IF ((FMT.EQ.3)) THEN
            WRITE (IOUT, 12) DEPTH_BINS(IZ)
            IF ((SFIG)) THEN
              IF ((ROT)) THEN
                WRITE (IOUT,13)REGNUM,HSET+NZMIN-1,IZ+NRMIN, REGNUM+1,HS
     *          ET+NZMIN,IZ+NRMIN, REGNUM+2,HSET+NZMIN+1,IZ+NRMIN
              ELSE
                WRITE (IOUT, 13) REGNUM,IZ+NZMIN-1,HSET+NRMIN, REGNUM+NZ
     *          ,IZ+NZMIN-1,HSET+NRMIN+1, REGNUM+NZ*2,IZ+NZMIN-1,HSET+NR
     *          MIN+2
              END IF
            ELSE
              IF ((ROT)) THEN
                WRITE (IOUT,16)REGNUM,HSET+NZMIN-1,IZ+NRMIN, REGNUM+1,HS
     *          ET+NZMIN,IZ+NRMIN, REGNUM+2,HSET+NZMIN+1,IZ+NRMIN
              ELSE
                WRITE (IOUT, 16)REGNUM,IZ+NZMIN-1,HSET+NRMIN, REGNUM+NZ,
     *          IZ+NZMIN-1,HSET+NRMIN+1, REGNUM+NZ*2,IZ+NZMIN-1,HSET+NRM
     *          IN+2
              END IF
            END IF
          END IF
          PGTHROW=PGTHROW+2
          DO 8131 ICOMP=1,NCOMP
            IF ((SFIG)) THEN
              IF ((FMT.EQ.3)) THEN
                WRITE(IOUT, 3) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP), UNC
     *          RT(IZ,HSET,ICOMP),LABELS(ICOMP), RESULTS(IZ,HSET+1,ICOMP
     *          ),UNCRT(IZ,HSET+1,ICOMP), LABELS(ICOMP),RESULTS(IZ,HSET+
     *          2,ICOMP), UNCRT(IZ,HSET+2,ICOMP)
              END IF
              IF ((FMT.EQ.2)) THEN
                WRITE(IOUT, 2) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP), UNC
     *          RT(IZ,HSET,ICOMP),LABELS(ICOMP), RESULTS(IZ,HSET+1,ICOMP
     *          ),UNCRT(IZ,HSET+1,ICOMP)
              END IF
              IF ((FMT.EQ.1)) THEN
                WRITE(IOUT, 1) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP), UNC
     *          RT(IZ,HSET,ICOMP)
              END IF
            ELSE
              IF ((FMT.EQ.3)) THEN
                WRITE(IOUT, 6) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP), UNC
     *          RT(IZ,HSET,ICOMP),LABELS(ICOMP), RESULTS(IZ,HSET+1,ICOMP
     *          ),UNCRT(IZ,HSET+1,ICOMP), LABELS(ICOMP),RESULTS(IZ,HSET+
     *          2,ICOMP), UNCRT(IZ,HSET+2,ICOMP)
              END IF
              IF ((FMT.EQ.2)) THEN
                WRITE(IOUT, 5) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP), UNC
     *          RT(IZ,HSET,ICOMP),LABELS(ICOMP), RESULTS(IZ,HSET+1,ICOMP
     *          ),UNCRT(IZ,HSET+1,ICOMP)
              END IF
              IF ((FMT.EQ.1)) THEN
                WRITE(IOUT, 4) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP), UNC
     *          RT(IZ,HSET,ICOMP)
              END IF
            END IF
            PGTHROW=PGTHROW+1
8131      CONTINUE
8132      CONTINUE
          IF ((MOD(PGTHROW,65).GT.(61-NCOMP))) THEN
            IF ((IZ.NE.DEEPNUM)) THEN
              IF ((FMT.EQ.1)) THEN
                WRITE (IOUT, 10) DEPTH_BINS(IZ+1)
              END IF
              IF ((FMT.EQ.2)) THEN
                WRITE (IOUT, 11) DEPTH_BINS(IZ+1)
              END IF
              IF ((FMT.EQ.3)) THEN
                WRITE (IOUT, 12) DEPTH_BINS(IZ+1)
              END IF
              WRITE (IOUT, *) '\f'
              PGTHROW=10
              WRITE(IOUT, 400) ' '
              call egs_fdate(iout)
              write(iout,'(//)')
              IF ((ROT)) THEN
                WRITE(IOUT, 93) TITLE
              ELSE
                WRITE(IOUT, 94) TITLE
              END IF
              WRITE (IOUT, 91) (RADIAL_BINS(IX),IX=HSET,HSET+FMT)
            ELSE
              DLYPT = HSET
            END IF
          END IF
8121    CONTINUE
8122    CONTINUE
        IF ((FMT.EQ.1)) THEN
          WRITE (IOUT, 10) DEPTH_BINS(DEEPNUM+1)
        END IF
        IF ((FMT.EQ.2)) THEN
          WRITE (IOUT, 11) DEPTH_BINS(DEEPNUM+1)
        END IF
        IF ((FMT.EQ.3)) THEN
          WRITE (IOUT, 12) DEPTH_BINS(DEEPNUM+1)
        END IF
        IF (((DLYPT.EQ.HSET).AND.(RADNUM-HSET.GT.2))) THEN
          WRITE (IOUT, *) '\f'
          PGTHROW=10
          WRITE(IOUT, 400) ' '
          call egs_fdate(iout)
          write(iout,'(//)')
          IF ((ROT)) THEN
            WRITE(IOUT, 93) TITLE
          ELSE
            WRITE(IOUT, 94) TITLE
          END IF
        END IF
        PGTHROW=PGTHROW+1
8111  CONTINUE
8112  CONTINUE
1     FORMAT (T11, '|', A4, 1PE10.3, '+-', 0PF4.1, '%', '|')
2     FORMAT (T11, '|', 1 (A4, 1PE10.3, '+-', 0PF4.1, '%', ' |'), A4, 1P
     *E10.3, '+-', 0PF4.1, '%', '|')
3     FORMAT (T11, '|', 2 (A4, 1PE10.3, '+-', 0PF4.1, '%', ' |'), A4, 1P
     *E10.3, '+-', 0PF4.1, '%', '|')
4     FORMAT (T11, '|', A4, 1PE10.3, '+-', 0PF5.2, '%', '|')
5     FORMAT (T11, '|', 1 (A4, 1PE10.3, '+-', 0PF5.2, '%', ' |'), A4, 1P
     *E10.3, '+-', 0PF5.2, '%', '|')
6     FORMAT (T10, '|', 2 (A4, 1PE10.3, '+-', 0PF5.2, '%', '|'), A4, 1PE
     *10.3, '+-', 0PF5.2, '%', '|')
10    FORMAT (1X, F9.4, T11, 1 (23 ('-')))
11    FORMAT (1X, F9.4, T11, 2 (23 ('-')))
12    FORMAT (1X, F9.4, T11, 3 (23 ('-')))
13    FORMAT (T11, '|', 2 ('IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |'), 'I
     *RL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'|')
14    FORMAT (T11, '|', 'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |', 'IRL',
     *I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'|')
15    FORMAT (T11, '|', 'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'|')
16    FORMAT (T10, '|', 2 ('IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |'), 'I
     *RL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |')
17    FORMAT (T11, '|', 1 ('IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'  |'), '
     *IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |')
18    FORMAT (T11, '|', 'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |')
91    FORMAT (/ T7,F9.4,T30,F9.4,T53,F9.4,T70,F9.4)
93    FORMAT (' ',79A1 // T19, 27H ZONAL OUTPUT GRID: ROTATED / T20, '**
     *************************')
94    FORMAT (' ',79A1 // T19, 31H ZONAL OUTPUT GRID: NON-ROTATED / T20,
     *'******************************')
95    FORMAT (T14, A4, T19, A60)
400   FORMAT (T54,a1,$)
      RETURN
      END
      SUBROUTINE MATERIALGRID(NRADIAL, NDEPTH, MASSVOL, MORV, ECUTS, PCU
     *TS, RCYL, ZPLANE, MED, MEDIA, CDSTBL, CTRTBL, CABSRB)
      IMPLICIT NONE
      CHARACTER*1 TITLE(80)
      COMMON/IODAT1/TITLE
      integer*4 RADNUM, DEEPNUM, NRADIAL, NDEPTH, NCOMP, REGNUM, FMT, TM
     *P1
      logical ESTEPSON, ECUTON, PCUTON, ROT
      real*8 VALUES(200,60,7), RCYL(60),ZPLANE(200), RADIAL_BINS(200),DE
     *PTH_BINS(200), MASSVOL(200,60), ECUTS( 12001), PCUTS( 12001), TMP2
     *(200,60,7),TMP3(200),CHINDEX(200)
      CHARACTER*60 EXPLANATIONS(7)
      CHARACTER*4 LABELS(7)
      CHARACTER*4 MED_NAME1(11),MED_NAME2(11),MED_NAME3(11)
      CHARACTER*4 MEDIA(24, 10)
      CHARACTER*4 CDSTBL( 12001), CTRTBL( 12001),CABSRB( 12001)
      integer*2 MED( 12001)
      integer*4 MNUM1, MNUM2, MNUM3, MORV
      integer*4 IOUT, ICOMP, IZ, IX, IRL, HSET, PGTHROW, DLYPT, J, COUNT
      ROT=.FALSE.
      ESTEPSON=.FALSE.
      ECUTON=.FALSE.
      PCUTON=.FALSE.
      NCOMP=1
      PGTHROW=14+NCOMP
      IOUT=1
      DEEPNUM=NDEPTH
      RADNUM=NRADIAL
      IF ((RCYL(1).EQ.0.)) THEN
        DO 8141 IX=1,RADNUM+1
          RADIAL_BINS(IX)=RCYL(IX)
8141    CONTINUE
8142    CONTINUE
      ELSE
        DO 8151 IX=1,RADNUM+1
          RADIAL_BINS(IX+1)=RCYL(IX)
8151    CONTINUE
8152    CONTINUE
      END IF
      DO 8161 IZ=1,DEEPNUM+1
        DEPTH_BINS(IZ)=ZPLANE(IZ)
8161  CONTINUE
8162  CONTINUE
      IF ((MORV.EQ.1)) THEN
        LABELS(NCOMP)='MASS'
        EXPLANATIONS(NCOMP)='MASS OF EACH REGION IN GRAMS'
      END IF
      IF ((MORV.EQ.2)) THEN
        LABELS(NCOMP)='VOL '
        EXPLANATIONS(NCOMP)='VOLUME OF EACH REGION IN cm^3'
      END IF
      DO 8171 IX=1,RADNUM
        DO 8181 IZ=1,DEEPNUM
          VALUES(IZ, IX, NCOMP)=MASSVOL(IZ, IX)
          IRL=IZ+DEEPNUM*(IX-1)+1
          IF ((CDSTBL(1).EQ.'0')) THEN
            CDSTBL(IRL)=' '
          END IF
          IF ((CTRTBL(1).EQ.'0')) THEN
            CTRTBL(IRL)=' '
          END IF
          IF ((CABSRB(1).EQ.'0')) THEN
            CABSRB(IRL)=' '
          END IF
          IF ((ECUTS(IRL).NE.ECUTS(2))) THEN
            ECUTON=.TRUE.
          END IF
          IF ((PCUTS(IRL).NE.PCUTS(2))) THEN
            PCUTON=.TRUE.
          END IF
8181    CONTINUE
8182    CONTINUE
8171  CONTINUE
8172  CONTINUE
      IF ((ECUTON)) THEN
        NCOMP=NCOMP+1
        LABELS(NCOMP)='ECUT'
        EXPLANATIONS(NCOMP)='ECUT (PRINTED BECAUSE DIFFERENT FROM GLOBAL
     *)'
        DO 8191 IX=1,RADNUM
          DO 8201 IZ=1,DEEPNUM
            IRL=IZ+DEEPNUM*(IX-1)+1
            VALUES(IZ, IX, NCOMP)=ECUTS(IRL)
8201      CONTINUE
8202      CONTINUE
8191    CONTINUE
8192    CONTINUE
      END IF
      IF ((PCUTON)) THEN
        NCOMP=NCOMP+1
        LABELS(NCOMP)='PCUT'
        EXPLANATIONS(NCOMP)='PCUT (PRINTED BECAUSE DIFFERENT FROM GLOBAL
     *)'
        DO 8211 IX=1,RADNUM
          DO 8221 IZ=1,DEEPNUM
            IRL=IZ+DEEPNUM*(IX-1)+1
            VALUES(IZ, IX, NCOMP)=PCUTS(IRL)
8221      CONTINUE
8222      CONTINUE
8211    CONTINUE
8212    CONTINUE
      END IF
      PGTHROW=14+NCOMP
      IF (((DEEPNUM.LE.3).AND.(RADNUM.GT.3))) THEN
        ROT=.TRUE.
        CHINDEX(RADNUM+1)=RADIAL_BINS(RADNUM+1)
        DO 8231 IX=1,RADNUM
          TMP3(IX)=DEPTH_BINS(IX)
          CHINDEX(IX)=RADIAL_BINS(IX)
          DEPTH_BINS(IX)=CHINDEX(IX)
          RADIAL_BINS(IX)=TMP3(IX)
          DO 8241 IZ=1,DEEPNUM
            DO 8251 ICOMP=1,NCOMP
              TMP2(IZ, IX, ICOMP)=VALUES(IZ, IX, ICOMP)
8251        CONTINUE
8252        CONTINUE
8241      CONTINUE
8242      CONTINUE
8231    CONTINUE
8232    CONTINUE
        DO 8261 IX=1,RADNUM
          DO 8271 IZ=1,DEEPNUM
            DO 8281 ICOMP=1,NCOMP
              VALUES(IX, IZ, ICOMP)=TMP2(IZ, IX, ICOMP)
8281        CONTINUE
8282        CONTINUE
8271      CONTINUE
8272      CONTINUE
8261    CONTINUE
8262    CONTINUE
        DEPTH_BINS(RADNUM+1)=CHINDEX(RADNUM+1)
        TMP1=RADNUM
        RADNUM=DEEPNUM
        DEEPNUM=TMP1
      END IF
      WRITE (IOUT, *) '\f'
      WRITE(IOUT, 400) ' '
      call egs_fdate(iout)
      write(iout,'(//)')
      IF ((ROT)) THEN
        WRITE(IOUT, 93) TITLE
      ELSE
        WRITE(IOUT, 94) TITLE
      END IF
      WRITE(IOUT, 95) (LABELS(ICOMP),EXPLANATIONS(ICOMP), ICOMP=1, NCOMP
     *)
      DO 8291 HSET=1,RADNUM,3
        IF ((RADNUM-HSET.GT.1)) THEN
          FMT=3
        ELSE
          IF ((MOD(RADNUM,3) .EQ. 1)) THEN
            FMT=1
          END IF
          IF ((MOD(RADNUM,3) .EQ. 2)) THEN
            FMT=2
          END IF
        END IF
        WRITE (IOUT, 91) (RADIAL_BINS(IX),IX=HSET,HSET+FMT)
        PGTHROW=PGTHROW+1
        DO 8301 IZ=1,DEEPNUM
          IF ((ROT)) THEN
            REGNUM=2+(IZ-1)*FMT+(HSET-1)*RADNUM
          ELSE
            REGNUM=( IZ+1+((HSET-1)*DEEPNUM) )
          END IF
          IF ((ROT)) THEN
            MNUM1=MED(REGNUM)
            MNUM2=MED(REGNUM+1)
            MNUM3=MED(REGNUM+2)
          ELSE
            MNUM1=MED(REGNUM)
            MNUM2=MED(REGNUM+DEEPNUM)
            MNUM3=MED(REGNUM+DEEPNUM*2)
          END IF
          IF ((MNUM1.EQ.0)) THEN
            MED_NAME1(1)='V'
            MED_NAME1(2)='A'
            MED_NAME1(3)='C'
            MED_NAME1(4)='U'
            MED_NAME1(5)='U'
            MED_NAME1(6)='M'
            DO 8311 J=7,11
              MED_NAME1(J)=' '
8311        CONTINUE
8312        CONTINUE
          ELSE
            DO 8321 COUNT=1,11
              MED_NAME1(COUNT) = MEDIA(COUNT, MNUM1)
8321        CONTINUE
8322        CONTINUE
          END IF
          IF ((MNUM2.EQ.0)) THEN
            MED_NAME2(1)='V'
            MED_NAME2(2)='A'
            MED_NAME2(3)='C'
            MED_NAME2(4)='U'
            MED_NAME2(5)='U'
            MED_NAME2(6)='M'
            DO 8331 J=7,11
              MED_NAME2(J)=' '
8331        CONTINUE
8332        CONTINUE
          ELSE
            DO 8341 COUNT=1,11
              MED_NAME2(COUNT) = MEDIA(COUNT,MNUM2)
8341        CONTINUE
8342        CONTINUE
          END IF
          IF ((MNUM3.EQ.0)) THEN
            MED_NAME3(1)='V'
            MED_NAME3(2)='A'
            MED_NAME3(3)='C'
            MED_NAME3(4)='U'
            MED_NAME3(5)='U'
            MED_NAME3(6)='M'
            DO 8351 J=7,11
              MED_NAME3(J)=' '
8351        CONTINUE
8352        CONTINUE
          ELSE
            DO 8361 COUNT=1,11
              MED_NAME3(COUNT) = MEDIA(COUNT,MNUM3)
8361        CONTINUE
8362        CONTINUE
          END IF
          IF ((FMT.EQ.1)) THEN
            WRITE (IOUT, 10) DEPTH_BINS(IZ)
            IF ((ROT)) THEN
              WRITE (IOUT, 15) REGNUM,HSET,IZ
            ELSE
              WRITE (IOUT, 15) REGNUM,IZ,HSET
            END IF
            WRITE (IOUT, 4) CDSTBL(REGNUM),CTRTBL(REGNUM), CABSRB(REGNUM
     *      ), (MED_NAME1(J),J=1,11)
          END IF
          IF ((FMT.EQ.2)) THEN
            WRITE (IOUT, 11) DEPTH_BINS(IZ)
            IF ((ROT)) THEN
              WRITE(IOUT,14) REGNUM,HSET,IZ, REGNUM+1,HSET+1,IZ
              WRITE(IOUT, 5) CDSTBL(REGNUM),CTRTBL(REGNUM), CABSRB(REGNU
     *        M), (MED_NAME1(J),J=1,11), CDSTBL(REGNUM+1),CTRTBL(REGNUM+
     *        1), CABSRB(REGNUM+1), (MED_NAME2(J),J=1,11)
            ELSE
              WRITE(IOUT,14) REGNUM,IZ,HSET, REGNUM+DEEPNUM,IZ,HSET+1
              WRITE(IOUT, 5) CDSTBL(REGNUM),CTRTBL(REGNUM), CABSRB(REGNU
     *        M), (MED_NAME1(J),J=1,11), CDSTBL(REGNUM+DEEPNUM),CTRTBL(R
     *        EGNUM+DEEPNUM), CABSRB(REGNUM+DEEPNUM),(MED_NAME2(J),J=1,1
     *        1)
            END IF
          END IF
          IF ((FMT.EQ.3)) THEN
            WRITE (IOUT, 12) DEPTH_BINS(IZ)
            IF ((ROT)) THEN
              WRITE (IOUT, 13) REGNUM,HSET,IZ,REGNUM+1, HSET+1,IZ,REGNUM
     *        +2,HSET+2,IZ
              WRITE (IOUT, 6) CDSTBL(REGNUM),CTRTBL(REGNUM), CABSRB(REGN
     *        UM), (MED_NAME1(J),J=1,11), CDSTBL(REGNUM+1),CTRTBL(REGNUM
     *        +1), CABSRB(REGNUM+1), (MED_NAME2(J),J=1,11), CDSTBL(REGNU
     *        M+2),CTRTBL(REGNUM+2), CABSRB(REGNUM+2), (MED_NAME3(J),J=1
     *        ,11)
            ELSE
              WRITE (IOUT, 13) REGNUM,IZ,HSET,REGNUM+DEEPNUM, IZ,HSET+1,
     *        REGNUM+DEEPNUM*2,IZ,HSET+2
              WRITE (IOUT, 6) CDSTBL(REGNUM),CTRTBL(REGNUM), CABSRB(REGN
     *        UM), (MED_NAME1(J),J=1,11), CDSTBL(REGNUM+DEEPNUM),CTRTBL(
     *        REGNUM+DEEPNUM), CABSRB(REGNUM+DEEPNUM), (MED_NAME2(J),J=1
     *        ,11), CDSTBL(REGNUM+DEEPNUM*2),CTRTBL(REGNUM+DEEPNUM*2), C
     *        ABSRB(REGNUM+DEEPNUM*2), (MED_NAME3(J),J=1,11)
            END IF
          END IF
          PGTHROW=PGTHROW+3
          DO 8371 ICOMP=1,NCOMP
            IF ((FMT.EQ.3)) THEN
              WRITE(IOUT, 3) LABELS(ICOMP),VALUES(IZ,HSET,ICOMP), LABELS
     *        (ICOMP),VALUES(IZ,HSET+1,ICOMP), LABELS(ICOMP),VALUES(IZ,H
     *        SET+2,ICOMP)
            END IF
            IF ((FMT.EQ.2)) THEN
              WRITE(IOUT, 2) LABELS(ICOMP),VALUES(IZ,HSET,ICOMP), LABELS
     *        (ICOMP),VALUES(IZ,HSET+1,ICOMP)
            END IF
            IF ((FMT.EQ.1)) THEN
              WRITE(IOUT, 1) LABELS(ICOMP),VALUES(IZ,HSET,ICOMP)
            END IF
            PGTHROW=PGTHROW+1
8371      CONTINUE
8372      CONTINUE
          IF ((MOD(PGTHROW,65).GT.(60-NCOMP))) THEN
            IF ((IZ.NE.DEEPNUM)) THEN
              IF ((FMT.EQ.1)) THEN
                WRITE (IOUT, 10) DEPTH_BINS(IZ+1)
              END IF
              IF ((FMT.EQ.2)) THEN
                WRITE (IOUT, 11) DEPTH_BINS(IZ+1)
              END IF
              IF ((FMT.EQ.3)) THEN
                WRITE (IOUT, 12) DEPTH_BINS(IZ+1)
              END IF
              WRITE (IOUT, *) '\f'
              PGTHROW=15
              WRITE(IOUT, 400) ' '
              call egs_fdate(iout)
              write(iout,'(//)')
              IF ((ROT)) THEN
                WRITE(IOUT, 93) TITLE
              ELSE
                WRITE(IOUT, 94) TITLE
              END IF
              WRITE (IOUT, 91) (RADIAL_BINS(IX),IX=HSET,HSET+FMT)
            ELSE
              DLYPT = HSET
            END IF
          END IF
8301    CONTINUE
8302    CONTINUE
        IF ((FMT.EQ.1)) THEN
          WRITE (IOUT, 10) DEPTH_BINS(DEEPNUM+1)
        END IF
        IF ((FMT.EQ.2)) THEN
          WRITE (IOUT, 11) DEPTH_BINS(DEEPNUM+1)
        END IF
        IF ((FMT.EQ.3)) THEN
          WRITE (IOUT, 12) DEPTH_BINS(DEEPNUM+1)
        END IF
        IF (((DLYPT.EQ.HSET).AND.(RADNUM-HSET.GT.2))) THEN
          WRITE (IOUT, *) '\f'
          PGTHROW=17
          WRITE(IOUT, 400) ' '
          call egs_fdate(iout)
          write(iout,'(//)')
          IF ((ROT)) THEN
            WRITE(IOUT, 93) TITLE
          ELSE
            WRITE(IOUT, 94) TITLE
          END IF
        END IF
        PGTHROW=PGTHROW+1
8291  CONTINUE
8292  CONTINUE
1     FORMAT (T11, '|', 2X, A4, 2X, 1PE10.3, 2X, ' |')
2     FORMAT (T11, '|', 2 (2X, A4, 2X, 1PE10.3, 2X, ' |'))
3     FORMAT (T11, '|', 3 (2X, A4, 2X, 1PE10.3, 2X, ' |'))
4     FORMAT (T11, '|', 1X, '/', 3 (A1, '/'), 11A1, '  |')
5     FORMAT (T11, '|', 2 (1X, '/', 3 (A1, '/'), 11A1, '  |'))
6     FORMAT (T11, '|', 3 (1X, '/', 3 (A1, '/'), 11A1, '  |'))
10    FORMAT (1X, F9.4, T11, 23 ('-'))
11    FORMAT (1X, F9.4, T11, 45 ('-'))
12    FORMAT (1X, F9.4, T11, 67 ('-'))
13    FORMAT (T11, '|', 3 ('IRL', I3, 1X, 'IZ ', I3, 1X, 'IX ', I3, 1X,'
     *|'))
14    FORMAT (T11, '|', 2 ('IRL', I3, 1X, 'IZ ', I3, 1X, 'IX ', I3, 1X,'
     *|'))
15    FORMAT (T11, '|', 'IRL', I3, 1X, 'IZ ', I3, 1X, 'IX ', I3, 1X, '|'
     *)
91    FORMAT (/ T7, F9.4, T30, F9.4, T53, F9.4, T70, F9.4)
93    FORMAT (' ',79A1 // T19, 29H ZONAL MATERIAL GRID: ROTATED / T21, '
     ***************************'/, /T4 , '/X/Y/Z/MED :  X = " " IS DEFA
     *ULT: OPTION NOT USED'/, T18, '  = "D" IF DOSE SCORING REGION'/, T1
     *8, 'X = "C" IF CAVITY REGION'/, T18, 'X = "S" IF SPR SCORING REGIO
     *N'/, T18, 'Y = "T" IF TRACKING REGION'/, T18, 'Z = "A" IF TOTALLYA
     *BSORBING REGION'/, T16, 'MED = MEDIUM NAME, 11 CHARACTER ABREVIATI
     *ON')
94    FORMAT (' ',79A1 // T19, 33H ZONAL MATERIAL GRID: NON-ROTATED / T2
     *1, '******************************'/ /T4 , '/X/Y/Z/MED :  X = " "I
     *S DEFAULT: OPTION NOT USED'/, T18, '  = "D" IF DOSE SCORING REGION
     *'/, T18, '  = "C" IF CAVITY REGION'/, T18, '  = "S" IF SPR SCORING
     * REGION'/, T18, 'Y = "T" IF TRACKING REGION'/, T18, 'Z = "A" IF TO
     *TALLY ABSORBING REGION'/, T16, 'MED = MEDIUM NAME, 11 CHARACTER AB
     *REVIATION')
95    FORMAT (T10, A4, ' = ', A60)
400   FORMAT (/T54,a1,$)
      RETURN
      END
      SUBROUTINE WATCH(IARG,IWATCH)
      implicit none
      integer*4 iarg,iwatch,IP,ICOUNT,JHSTRY,J,N
      real*8 KE
      integer*4 graph_unit
      integer egs_open_file
      integer*4 ku,kr,ka
      COMMON/BOUNDS/ECUT( 12001),PCUT( 12001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DATA ICOUNT/0/,JHSTRY/1/ graph_unit/-1/
      save ICOUNT,JHSTRY,graph_unit
      ku = 13
      kr = 0
      ka = 1
      IF ((IARG .EQ. -99)) THEN
        DO 8381 J=1,29
          IAUSFL(J)=1
8381    CONTINUE
8382    CONTINUE
        IAUSFL(22)=0
        IAUSFL(23)=0
        IAUSFL(24)=0
      END IF
      IF ((IARG .EQ. -1)) THEN
        IF ((IWATCH .EQ. 4)) THEN
          IF (( graph_unit .LT. 0 )) THEN
            graph_unit = egs_open_file(ku,kr,ka,'.egsgph')
          END IF
          WRITE(graph_unit,8390) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY
          JHSTRY=JHSTRY+1
        ELSE
          WRITE(6,8400)JHSTRY
8400      FORMAT(' END OF HISTORY',I8,3X,40('*')/)
          JHSTRY=JHSTRY+1
          ICOUNT=ICOUNT+2
          RETURN
        END IF
      END IF
      IF (( (IWATCH .NE. 4) .AND. ((ICOUNT .GE. 50) .OR. (ICOUNT .EQ. 0)
     * .OR. (IARG .EQ. -99)) )) THEN
        ICOUNT=1
        WRITE(6,8410)
8410    FORMAT(//T39,' NP',3X,'ENERGY  Q REGION    X',7X, 'Y',7X,'Z',6X,
     *'U',6X,'V',6X,'W',6X,'LATCH',2X,'WEIGHT'/)
      END IF
      IF (((IWATCH .EQ. 4) .AND. (IARG .GE. 0) .AND. (IARG .NE. 5))) THE
     *N
        IF((graph_unit .LT. 0))graph_unit = egs_open_file(ku,kr,ka,'.egs
     *gph')
        WRITE(graph_unit,8390) NP,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),E(NP)
8390    FORMAT(2I4,1X,I6,4G15.8,I12)
      END IF
      IF((IARG .EQ. 5 .OR. IARG .LT. 0))RETURN
      IF((IWATCH .EQ. 4))RETURN
      KE=E(NP)
      IF ((IQ(NP).NE.0)) THEN
        KE=E(NP)-PRM
      END IF
      IF ((IARG .EQ. 0 .AND. IWATCH .EQ. 2)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8420)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8420    FORMAT(T11,'STEP ABOUT TO OCCUR', T36,':',I5,F9.3,2I4,3F8.3,3F7.
     *3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 0)) THEN
        RETURN
      END IF
      IF (( IARG .EQ. 1)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8430)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8430    FORMAT(' Discard  AE,AP<E<ECUT',T36,':',I5,F9.3,2I4,3F8.3,3F7.3,
     *I10,1PE10.3)
      ELSE IF((IARG .EQ. 2)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8440)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8440    FORMAT(' Discard  E<AE,AP',T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1
     *PE10.3)
      ELSE IF((IARG .EQ. 3)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8450)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8450    FORMAT(' Discard -user request',T36,':',I5,F9.3,2I4,3F8.3,3F7.3,
     *I10,1PE10.3)
      ELSE IF((IARG .EQ. 4)) THEN
        WRITE(6,8460)EDEP,IR(NP)
8460    FORMAT(T10,'Local energy deposition',T36,':',F12.5,' MeV in regi
     *on ',I6)
      ELSE IF((IARG .EQ. 6)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8470)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8470    FORMAT(' bremsstrahlung  about to occur',T36,':',I5,F9.3,2I4,3F8
     *.3,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 7)) THEN
        IF ((nbr_split .EQ.1)) THEN
          DO 8481 IP=NPold,NP
            IF ((IQ(IP).EQ.-1)) THEN
              KE = E(IP) - RM
              ICOUNT=ICOUNT+1
              WRITE(6,8490)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8490          FORMAT(T10,'Resulting electron',T36,':',I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
            ELSE
              KE = E(IP)
              ICOUNT=ICOUNT+1
              WRITE(6,8500)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8500          FORMAT(T10,'Resulting photon',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
            END IF
8481      CONTINUE
8482      CONTINUE
        ELSE
          KE = E(NPold) - RM
          ICOUNT=ICOUNT+1
          WRITE(6,8510)NPold,KE,IQ(NPold),IR(NPold),X(NPold),Y(NPold),Z(
     *    NPold),U(NPold),V(NPold), W(NPold),LATCH(NPold),WT(NPold)
8510      FORMAT(T10,'Resulting electron',T36,':',I5,F9.3,2I4,3F8.3,3F7.
     *3,I10,1PE10.3)
          DO 8521 IP=NPold+1,NP
            KE= E(IP)
            IF ((IP .EQ. NPold+1)) THEN
              ICOUNT=ICOUNT+1
              WRITE(6,8530)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8530          FORMAT(T10,'Split photons',T36,':',I5,F9.3,2I4,3F8.3,3F7.3
     *,I10,1PE10.3)
            ELSE
              ICOUNT=ICOUNT+1
              WRITE(6,8540)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8540          FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
            END IF
8521      CONTINUE
8522      CONTINUE
        END IF
      ELSE IF((IARG .EQ. 8)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8550)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8550    FORMAT(' Moller   about to occur',T36,':',I5,F9.3,2I4,3F8.3,3F7.
     *3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 9)) THEN
        IF ((NP.EQ.NPold)) THEN
          ICOUNT=ICOUNT+1
          WRITE(6,8560)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8560      FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
        ELSE
          DO 8571 IP=NPold,NP
            KE = E(IP) - ABS(IQ(NP))*RM
            IF ((IP.EQ.NPold)) THEN
              ICOUNT=ICOUNT+1
              WRITE(6,8580)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8580          FORMAT(T11,'Resulting electrons',T36,':',I5,F9.3,2I4,3F8.3
     *,3F7.3,I10,1PE10.3)
            ELSE
              ICOUNT=ICOUNT+1
              WRITE(6,8590)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8590          FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
            END IF
8571      CONTINUE
8572      CONTINUE
        END IF
      ELSE IF((IARG .EQ. 10)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8600)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8600    FORMAT(' Bhabba   about to occur',T36,':',I5,F9.3,2I4,3F8.3,3F7.
     *3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 11)) THEN
        IF ((NP.EQ.NPold)) THEN
          ICOUNT=ICOUNT+1
          WRITE(6,8610)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8610      FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
        ELSE
          DO 8621 IP=NPold,NP
            KE = E(IP) - ABS(IQ(IP))*RM
            IF ((IP.EQ.NPold)) THEN
              ICOUNT=ICOUNT+1
              WRITE(6,8630)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8630          FORMAT(T11,'Resulting e- or e+',T36,':',I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
            ELSE
              ICOUNT=ICOUNT+1
              WRITE(6,8640)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8640          FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
            END IF
8621      CONTINUE
8622      CONTINUE
        END IF
      ELSE IF((IARG .EQ. 12)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8650)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8650    FORMAT(' Positron about to decay in flight',T36,':',I5,F9.3,2I4,
     *3F8.3,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 13)) THEN
        IF ((NP.EQ.NPold)) THEN
          ICOUNT=ICOUNT+1
          WRITE(6,8660)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8660      FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
        ELSE
          DO 8671 IP=NPold,NP
            KE = E(IP) - ABS(IQ(IP))*RM
            IF ((IP.EQ.NPold)) THEN
              ICOUNT=ICOUNT+1
              WRITE(6,8680)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8680          FORMAT(T11,'Resulting photons',T36,':',I5,F9.3,2I4,3F8.3,3
     *F7.3,I10,1PE10.3)
            ELSE
              ICOUNT=ICOUNT+1
              WRITE(6,8690)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8690          FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
            END IF
8671      CONTINUE
8672      CONTINUE
        END IF
      ELSE IF((IARG .EQ. 28)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8700)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8700    FORMAT(' Positron will annihilate at rest',T36,':',I5,F9.3,2I4,3
     *F8.3,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 14)) THEN
        IF ((NP.EQ.NPold)) THEN
          ICOUNT=ICOUNT+1
          WRITE(6,8710)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8710      FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
        ELSE
          DO 8721 IP=NPold,NP
            KE = E(IP) - ABS(IQ(IP))*RM
            IF ((IP.EQ.NPold)) THEN
              ICOUNT=ICOUNT+1
              WRITE(6,8730)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8730          FORMAT(' Positron annihilates at rest',T36,':',I5,F9.3,2I4
     *,3F8.3,3F7.3,I10,1PE10.3)
            ELSE
              ICOUNT=ICOUNT+1
              WRITE(6,8740)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8740          FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
            END IF
8721      CONTINUE
8722      CONTINUE
        END IF
      ELSE IF((IARG .EQ. 15)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8750)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8750    FORMAT(' Pair production about to occur',T36,':',I5,F9.3,2I4,3F8
     *.3,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 16)) THEN
        IF ((NP.EQ.NPold .AND. i_survived_rr .EQ. 0)) THEN
          ICOUNT=ICOUNT+1
          WRITE(6,8760)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8760      FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
        ELSE IF((NP.EQ.NPold .AND. i_survived_rr .GT. 0)) THEN
          WRITE(6,8770)i_survived_rr,prob_rr
8770      FORMAT(T10,'Russian Roulette eliminated ',I2, ' particle(s) wi
     *th probability ',F8.5)
          ICOUNT=ICOUNT+1
          WRITE(6,8780)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8780      FORMAT(T10,'Now on top of stack',T36,':',I5,F9.3,2I4,3F8.3,3F7
     *.3,I10,1PE10.3)
        ELSE
          DO 8791 IP=NPold,NP
            KE = E(IP) - ABS(IQ(IP))*RM
            IF ((IP.EQ.NPold)) THEN
              ICOUNT=ICOUNT+1
              WRITE(6,8800)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8800          FORMAT(T11,'Resulting pair',T36,':',I5,F9.3,2I4,3F8.3,3F7.
     *3,I10,1PE10.3)
            ELSE
              ICOUNT=ICOUNT+1
              WRITE(6,8810)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8810          FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
            END IF
8791      CONTINUE
8792      CONTINUE
          IF ((i_survived_rr .GT. 0)) THEN
            WRITE(6,8820)i_survived_rr,prob_rr
8820        FORMAT(T10,'Russian Roulette eliminated ',I2,'              
     *                  particle(s) with probability ',F8.5)
            ICOUNT=ICOUNT+1
            WRITE(6,8830)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(N
     *      P), W(NP),LATCH(NP),WT(NP)
8830        FORMAT(T10,'Now on top of stack',T36,':',I5,F9.3,2I4,3F8.3,3
     *F7.3,I10,1PE10.3)
          END IF
        END IF
      ELSE IF((IARG .EQ. 17)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8840)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8840    FORMAT(' Compton  about to occur',T36,':',I5,F9.3,2I4,3F8.3,3F7.
     *3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 18)) THEN
        IF ((NP .EQ. NPold .AND. i_survived_rr .EQ. 0)) THEN
          ICOUNT=ICOUNT+1
          WRITE(6,8850)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8850      FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
        ELSE IF((NP .GT. NPold)) THEN
          DO 8861 IP=NPold,NPold+1
            KE = E(IP) - ABS(IQ(IP))*RM
            IF ((IQ(IP).NE.0)) THEN
              ICOUNT=ICOUNT+1
              WRITE(6,8870)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8870          FORMAT(T11,'compton electron created',T36,':',I5,F9.3,2I4,
     *3F8.3,3F7.3,I10,1PE10.3)
            ELSE
              ICOUNT=ICOUNT+1
              WRITE(6,8880)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8880          FORMAT(T11,'compton scattered photon',T36,':',I5,F9.3,2I4,
     *3F8.3,3F7.3,I10,1PE10.3)
            END IF
8861      CONTINUE
8862      CONTINUE
        END IF
        IF ((i_survived_rr .GT. 0)) THEN
          WRITE(6,8890)i_survived_rr,prob_rr
8890      FORMAT(T10,'Russian Roulette eliminated ',I2, ' particle(s) wi
     *th probability ',F8.5)
          ICOUNT=ICOUNT+1
          WRITE(6,8900)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8900      FORMAT(T10,'Now on top of stack',T36,':',I5,F9.3,2I4,3F8.3,3F7
     *.3,I10,1PE10.3)
        END IF
      ELSE IF((IARG .EQ. 19)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8910)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8910    FORMAT(' Photoelectric about to occur',T36,':',I5,F9.3,2I4,3F8.3
     *,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 20)) THEN
        IF ((NPold.EQ.NP .AND. IQ(NP).EQ.0 .AND. i_survived_rr .EQ. 0))
     *  THEN
          ICOUNT=ICOUNT+1
          WRITE(6,8920)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8920      FORMAT(T11,'Photon energy below N-shell',/, T11,'Photon discar
     *ded',T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
        ELSE IF((IQ(NPold) .EQ. -1 .AND. i_survived_rr .EQ. 0)) THEN
          KE= E(NPold)-RM
          ICOUNT=ICOUNT+1
          WRITE(6,8930)NPold,KE,IQ(NPold),IR(NPold),X(NPold),Y(NPold),Z(
     *    NPold),U(NPold),V(NPold), W(NPold),LATCH(NPold),WT(NPold)
8930      FORMAT(T10,'Resulting photoelectron',T36,':',I5,F9.3,2I4,3F8.3
     *,3F7.3,I10,1PE10.3)
        ELSE IF((i_survived_rr .GT. 0)) THEN
          IF ((NP.EQ.NPold-1 .OR. IQ(NPold) .NE. -1)) THEN
            IF ((i_survived_rr .GT. 1)) THEN
              WRITE(6,8940)i_survived_rr-1,prob_rr
8940          FORMAT(T10,'Russian Roulette eliminated ',I4, ' particle(s
     *) with probability ',F8.5,' plus')
            END IF
            WRITE(6,8950)prob_rr
8950        FORMAT(T10,'Russian Roulette eliminated resulting photoelect
     *ron', ' with probability ',F8.5)
          ELSE
            KE = E(NPold) - RM
            ICOUNT=ICOUNT+1
            WRITE(6,8960)NPold,KE,IQ(NPold),IR(NPold),X(NPold),Y(NPold),
     *      Z(NPold),U(NPold),V(NPold), W(NPold),LATCH(NPold),WT(NPold)
8960        FORMAT(T10,'Resulting photoelectron?',T36,':',I5,F9.3,2I4,3F
     *8.3,3F7.3,I10,1PE10.3)
            WRITE(6,8970)i_survived_rr,prob_rr
8970        FORMAT(T10,'Russian Roulette eliminated ',I4, ' particle(s)w
     *ith probability ',F8.5)
          END IF
          ICOUNT=ICOUNT+1
          WRITE(6,8980)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8980      FORMAT(T10,'Now on top of stack',T36,':',I5,F9.3,2I4,3F8.3,3F7
     *.3,I10,1PE10.3)
        END IF
      ELSE IF((IARG .EQ. 24)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8990)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8990    FORMAT(' Rayleigh scattering occured',T36,':',I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 25)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,9000)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
9000    FORMAT(T10,'Fluorescent X-ray created',T36,':',I5,F9.3,2I4,3F8.3
     *,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 26)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,9010)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
9010    FORMAT(T10,'Coster-Kronig e- created',T36,':',I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 27)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,9020)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
9020    FORMAT(T10,'Auger electron created',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
      END IF
      IF ((IARG .EQ. 0 .AND. IWATCH .EQ. 2)) THEN
        WRITE(6,9030)USTEP,TUSTEP,VSTEP,TVSTEP,EDEP
9030    FORMAT(T5,'USTEP,TUSTEP,VSTEP,TVSTEP,EDEP',T36,':    ',5(1PE13.4
     *))
        ICOUNT=ICOUNT+1
      END IF
      IF((NP .EQ. 1 .OR. IARG .EQ. 0))RETURN
      IF (( IARG .LE. 3)) THEN
        N=NP-1
        KE = E(N) - ABS(IQ(N))*RM
        ICOUNT=ICOUNT+1
        WRITE(6,9040)N,KE,IQ(N),IR(N),X(N),Y(N),Z(N),U(N),V(N), W(N),LAT
     *  CH(N),WT(N)
9040    FORMAT(T10,'Now on top of stack',T36,':',I5,F9.3,2I4,3F8.3,3F7.3
     *,I10,1PE10.3)
      END IF
      RETURN
      END
      SUBROUTINE SIGMA(NDATA,ISTAT,MODE,IERR)
      implicit none
      integer*4 NDATA,ISTAT,MODE,IERR
      COMMON/ERROR/DATA( 12000,2)
      real*8 data
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 n,non0,i
      real*8 stat,sdenom
      real*8 emax,avg,error,datum,argmnt
      DATA EMAX/99.9/
      IERR=0
      IF (((MODE .LT. 0) .OR. (MODE .GT. 2))) THEN
        MODE=2
        IERR=1
      END IF
      IF (((NDATA.LE.0).OR.(NDATA.GT. 12000).OR.(ISTAT.LE.0).OR.(ISTAT.G
     *T.2))) THEN
        IERR=-1
        RETURN
      END IF
      IF ((ISTAT .EQ. 1)) THEN
        IERR=10
        DO 9051 N=1,NDATA
          DATA(N,2)=EMAX
9051    CONTINUE
9052    CONTINUE
        RETURN
      END IF
      IF ((MODE.NE.0)) THEN
        STAT=FLOAT(ISTAT)
        SDENOM=STAT*(STAT-1.)
      END IF
      DO 9061 N=1,NDATA
        NON0=0
        AVG=0.0
        ERROR=0.0
        DO 9071 I=1,ISTAT
          DATUM=DATA(N,I)
          IF ((DATUM.NE.0.0)) THEN
            NON0=NON0+1
            AVG=AVG+DATUM
            ERROR=ERROR+DATUM**2
          END IF
9071    CONTINUE
9072    CONTINUE
        IF ((NON0 .EQ. 0)) THEN
          IERR=11
          ERROR=EMAX
          GOTO 9080
        ELSE IF(((NON0 .EQ. 1) .AND. (MODE .EQ. 0))) THEN
          ERROR=EMAX
          GOTO9080
        ELSE
          IF ((MODE .EQ. 0)) THEN
            STAT=FLOAT(NON0)
            SDENOM=STAT*(STAT-1.)
          END IF
        END IF
        AVG=AVG/STAT
        ARGMNT=ERROR-STAT*AVG**2
        IF ((ARGMNT.LT.0.0)) THEN
          WRITE(6,9090)ARGMNT,ERROR,STAT,AVG,SDENOM
9090      FORMAT(' ***** - SQ RT IN SIGMA. ARGMNT,ERROR,STAT,AVG,SDENOM=
     *'/' ',5E12.4)
          ARGMNT=0.0
        END IF
        ERROR=SQRT(ARGMNT/SDENOM)
        IF ((AVG .EQ. 0.)) THEN
          ERROR=EMAX
        ELSE
          ERROR=100.*ERROR/ABS(AVG)
        END IF
        IF((MODE .EQ. 2))AVG=AVG*STAT
9080    CONTINUE
        DATA(N,1)=AVG
        DATA(N,2)=MIN(EMAX,ERROR)
9061  CONTINUE
9062  CONTINUE
      RETURN
      END
      subroutine prepare_alias_sampling(nsbin,fs_array,ws_array,ibin_arr
     *ay)
      implicit none
      integer*4 nsbin,ibin_array(nsbin)
      real*8 fs_array(nsbin),ws_array(nsbin)
      integer*4 i,j_l,j_h
      real*8 sum,aux
      sum = 0
      DO 9101 i=1,nsbin
        IF((fs_array(i) .LT. 1e-30))fs_array(i) = 1e-30
        ws_array(i) = -fs_array(i)
        ibin_array(i) = 1
        sum = sum + fs_array(i)
9101  CONTINUE
9102  CONTINUE
      sum = sum/nsbin
      DO 9111 i=1,nsbin-1
        DO 9121 j_h=1,nsbin
          IF (( ws_array(j_h) .LT. 0 )) THEN
            IF((abs(ws_array(j_h)) .GT. sum))GOTO 9130
          END IF
9121    CONTINUE
9122    CONTINUE
        j_h = nsbin
9130    CONTINUE
          DO 9131 j_l=1,nsbin
          IF (( ws_array(j_l) .LT. 0 )) THEN
            IF((abs(ws_array(j_l)) .LT. sum))GOTO 9140
          END IF
9131    CONTINUE
9132    CONTINUE
        j_l = nsbin
9140    aux = sum - abs(ws_array(j_l))
        ws_array(j_h) = ws_array(j_h) + aux
        ws_array(j_l) = -ws_array(j_l)/sum
        ibin_array(j_l) = j_h
        IF((i .EQ. nsbin-1))ws_array(j_h) = 1
9111  CONTINUE
9112  CONTINUE
      return
      end
      real*8 function alias_sample(nsbin,xs_array,ws_array,ibin_array)
      implicit none
      integer*4 nsbin,ibin_array(nsbin)
      real*8 xs_array(0:nsbin),ws_array(nsbin)
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      real*8 v1,v2,aj
      integer*4 j
      IF((rng_seed .GT. 128))call ranmar_get
      v1 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((rng_seed .GT. 128))call ranmar_get
      v2 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      aj = 1 + v1*nsbin
      j = aj
      IF((j .GT. nsbin))j = nsbin
      aj = aj - j
      IF (( aj .GT. ws_array(j) )) THEN
        j = ibin_array(j)
      END IF
      alias_sample = (1-v2)*xs_array(j-1) + v2*xs_array(j)
      return
      end
      SUBROUTINE XVGRPLOT (X, Y, ERRY, NPTS, CURVENUM, SERIESTITLE, XTIT
     *LE, YTITLE, GRAPHTITLE, SUBTITLE, UNITNUM, TYPE, HISTXMIN, AXISTYP
     *E)
      IMPLICIT NONE
      integer*4 MAX, IDEBUG
      PARAMETER (MAX = 400)
      integer*4 NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE
      real*8 X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,HISTXMIN,ERRYOLD,SMALLESTX,
     * SMALLESTY,FUDGE
      integer*4 TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENG
     *TH
      integer*4 LOGX, LOGY, LOGDY,ZEROYCOUNT
      CHARACTER*(*) SUBTITLE
      CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE
      CHARACTER*10 INDEX
      CHARACTER*3 INDEXNUM
      logical TESTFILE, ALLPOS
      real*8 one
      parameter (one = 1)
      FUDGE = 1.e-10
      IDEBUG = 0
      IF ((IDEBUG .EQ. 1)) THEN
        write(6,'(//'' Entering xvgrplot ''/)')
        write(6,'('' Curve'',I3,'' to go to unit'',I3)')CURVENUM,UNITNUM
        write(6,'(''SERIESTITLE: '',a60)') SERIESTITLE
        write(6,'(''XTITLE:      '',a60)') XTITLE
        write(6,'(''YTITLE       '',a60)') YTITLE
        write(6,'(''GRAPHTILE:   '',a60)') graphtitle
        write(6,'(''SUBTITLE:    '',a80)') subtitle
      END IF
      IF (( NPTS .gt. MAX)) THEN
        WRITE(6,9150)NPTS, MAX
9150    FORMAT(//' **************************'/ ' Number of points asked
     * for =', I5, ' is greater than max allowed of', I4/ ' Setting NPTS
     * to MAX, you could adjust MAX in xvgrplot.mortran'/ ' ************
     ***************'//)
        NPTS1 = MAX
      ELSE
        NPTS1 = NPTS
      END IF
      INQUIRE(UNIT = UNITNUM,OPENED=TESTFILE)
      IF ((.NOT.TESTFILE)) THEN
        WRITE(6,7760) UNITNUM
7760    FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------' ,/'
     *   Unit specified (',I2,') is not open.' ,/'   Unit must be opened
     * before using subroutine.' ,/'   Data not written to file.' ,/'  -
     *---------------------------------------------'//)
        RETURN
      END IF
      IF ((GRAPHTITLE .EQ. ' ')) THEN
        GRAPHTITLE = 'Untitled Graph - No title specified in subroutine'
      END IF
      IF ((XTITLE .EQ. ' ')) THEN
        XTITLE = 'X-axis not titled in subroutine'
      END IF
      IF ((YTITLE .EQ. ' ')) THEN
        YTITLE = 'Y-axis not titled in subroutine'
      END IF
      IF ((SERIESTITLE .EQ. ' ')) THEN
        SERIESTITLE = 'series # '
        INDEX = '0123456789'
        INDEXNUM = INDEX(CURVENUM+1:CURVENUM+1)
        SERIESTITLE(9:9) = INDEXNUM
      END IF
      TITLELENGTH = 61
      SUBLENGTH = 61
      XAXISLENGTH = 61
      YAXISLENGTH = 61
      SERIESLENGTH = 61
9161  CONTINUE
        TITLELENGTH = TITLELENGTH - 1
        IF(((GRAPHTITLE(TITLELENGTH:TITLELENGTH) .NE. ' ')))GO TO9162
      GO TO 9161
9162  CONTINUE
9171  CONTINUE
        SUBLENGTH = SUBLENGTH - 1
        IF(((SUBTITLE(SUBLENGTH:SUBLENGTH) .NE. ' ')))GO TO9172
      GO TO 9171
9172  CONTINUE
9181  CONTINUE
        XAXISLENGTH = XAXISLENGTH - 1
        IF(((XTITLE(XAXISLENGTH:XAXISLENGTH) .NE. ' ')))GO TO9182
      GO TO 9181
9182  CONTINUE
9191  CONTINUE
        YAXISLENGTH = YAXISLENGTH - 1
        IF(((YTITLE(YAXISLENGTH:YAXISLENGTH) .NE. ' ')))GO TO9192
      GO TO 9191
9192  CONTINUE
9201  CONTINUE
        SERIESLENGTH = SERIESLENGTH - 1
        IF(((SERIESTITLE(SERIESLENGTH:SERIESLENGTH) .NE. ' ')))GO TO9202
      GO TO 9201
9202  CONTINUE
      IF (( IDEBUG .EQ. 1)) THEN
        WRITE(6,9210)SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITL
     *  ELENGTH
9210    FORMAT(' SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELEN
     *GTH'/ 5I10)
      END IF
      LOGX = 0
      LOGY = 0
      LOGDY = 0
      ZEROYCOUNT=0
      ALLPOS=.TRUE.
      IF (( X(1).EQ.0.0 )) THEN
        SMALLESTX = 0.1
      ELSE
        SMALLESTX=X(1)
      END IF
      IF (( Y(1).EQ.0.0 )) THEN
        SMALLESTY = 0.1
      ELSE
        SMALLESTY=Y(1)
      END IF
      DO 9221 COUNT=1,NPTS1
        IF (((X(COUNT) .LT. SMALLESTX) .AND. (X(COUNT).NE.0.))) THEN
          SMALLESTX=X(COUNT)
        END IF
        IF (((Y(COUNT) .LT. SMALLESTY) .AND. (Y(COUNT).NE.0.))) THEN
          SMALLESTY=Y(COUNT)
        END IF
        IF (((X(COUNT) .LT. 0.).OR.(Y(COUNT) .LT. 0.))) THEN
          ALLPOS=.FALSE.
        END IF
9221  CONTINUE
9222  CONTINUE
      IF ((ALLPOS)) THEN
        DO 9231 COUNT=1,NPTS1
          IF ((X(COUNT).EQ.0.)) THEN
            X(COUNT)=SMALLESTX*FUDGE
          END IF
          IF ((Y(COUNT).EQ.0.)) THEN
            Y(COUNT)=SMALLESTY*FUDGE
          END IF
9231    CONTINUE
9232    CONTINUE
      END IF
      IF ((AXISTYPE .GT. 0)) THEN
        DO 9241 COUNT=1,NPTS1
          IF ((X(COUNT) .LE. 0.)) THEN
            LOGX = 1
          END IF
          IF ((Y(COUNT) .LE. 0.)) THEN
            LOGY = 1
          END IF
          IF (((Y(COUNT)-ERRY(COUNT)) .LE. 0.)) THEN
            LOGDY = 1
          END IF
9241    CONTINUE
9242    CONTINUE
      ELSE
        DO 9251 COUNT=1,NPTS1
          IF ((Y(COUNT)-ERRY(COUNT) .LT. Y(COUNT)-0.9999*Y(COUNT) .AND.
     *    Y(COUNT).GT.0.)) THEN
            ZEROYCOUNT=ZEROYCOUNT+1
            IF ((ZEROYCOUNT.EQ.1)) THEN
              WRITE(6,9260)
9260          FORMAT (/' ------------WARNING from Subroutine XVGRPLOT---
     *--------' ,/'  Some errors give 0 value and so are adjusted so   '
     * ,/'  that you can switch to a log Y scale while in xmgr.   ',/' -
     *------------------------------------------------------'/)
            END IF
            ERRYOLD=ERRY(COUNT)
            ERRY(COUNT) = 0.9999*Y(COUNT)
          END IF
9251    CONTINUE
9252    CONTINUE
      END IF
      IF ((CURVENUM .EQ. 0)) THEN
        IF ((AXISTYPE .EQ. 0)) THEN
          WRITE(UNITNUM,7850) 'xy'
        ELSE IF((AXISTYPE .EQ. 1)) THEN
          WRITE(UNITNUM,7850) 'logy'
          WRITE(UNITNUM,7860)
        ELSE IF((AXISTYPE .EQ. 2)) THEN
          WRITE(UNITNUM,7850) 'logx'
          WRITE(UNITNUM,7860)
        ELSE IF((AXISTYPE .EQ. 3)) THEN
          WRITE(UNITNUM,7850) 'logxy'
          WRITE(UNITNUM,7860)
          WRITE(UNITNUM,7870)
        ELSE
          WRITE(6,7880) AXISTYPE
7880      FORMAT (//'  ------------Error in Subroutine XVGRPLOT---------
     *--' ,/'   AXISTYPE specified (',I2,') is not a valid option.' ,/' 
     *----------------------------------------------'//)
          RETURN
        END IF
7850    FORMAT ('@g0 type ',A,' ')
7860    FORMAT ('@    xaxis  ticklabel format exponential')
7870    FORMAT ('@    yaxis  ticklabel format exponential')
        WRITE(UNITNUM,7890) GRAPHTITLE(1:TITLELENGTH) ,SUBTITLE(1:SUBLEN
     *  GTH) ,XTITLE(1:XAXISLENGTH) ,YTITLE(1:YAXISLENGTH)
7890    FORMAT ('@    title "',A,'"'/ ,'@    subtitle "',A,'"'/ ,'@    l
     *egend on'/ ,'@    legend box linestyle 0'/ ,'@    legend x1 0.6'/,
     *'@    legend y1 0.75'/ ,'@    view xmin 0.250000'/ ,'@    xaxis  l
     *abel "',A,'"'/ ,'@    timestamp on'/ ,'@    yaxis  label "',A,'"')
      END IF
      IF ((AXISTYPE .EQ. 1 .AND. LOGY .EQ. 1)) THEN
        WRITE(UNITNUM,7850) 'xy'
        WRITE(6,7900)
7900    FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------',
     */'  Log scale requested for Y axis when one or more   ' ,/'  Ydata
     * points are 0 or negative.                  ' ,//'  Y axis scale c
     *hanged to linear.                   ' ,/' ------------------------
     *---------------------------'/)
      END IF
      IF ((AXISTYPE .EQ. 2 .AND. LOGX .EQ. 1)) THEN
        WRITE(UNITNUM,7850) 'xy'
        WRITE(6,7910)
7910    FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------',
     */'  Log scale requested for X axis when one or more   ' ,/'  Xdata
     * points are 0 or negative.                  ' ,//'  X axis scale c
     *hanged to linear.                   ' ,/' ------------------------
     *---------------------------'/)
      END IF
      IF ((AXISTYPE .EQ. 3 .AND. (LOGX .EQ. 1 .OR. LOGY .EQ. 1))) THEN
        IF ((LOGX .EQ. 1 .AND. LOGY .EQ. 1)) THEN
          WRITE(UNITNUM,7850) 'xy'
          WRITE(6,7920)
7920      FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------
     *' ,/'  Log scale requested for X axis and Y axis when    ' ,/'  on
     *e or more X and Y data points are 0 or negative.' ,//'  X and Y ax
     *es scales changed to linear.            ' ,/' --------------------
     *-------------------------------'/)
        ELSE IF((LOGX .EQ. 1)) THEN
          WRITE(UNITNUM,7850) 'logy'
          WRITE(6,7910)
        ELSE
          WRITE(UNITNUM,7850) 'logx'
          WRITE(6,7900)
        END IF
      END IF
      IF ((LOGDY .EQ. 1 .AND. LOGY .NE. 1 .AND. (AXISTYPE .EQ. 3 .OR. AX
     *ISTYPE .EQ. 1))) THEN
        WRITE(6,9270)
9270    FORMAT (/' ------------WARNING from Subroutine XVGRPLOT---------
     *--' ,/'  Log scale requested for Y axis, and Y value less      ' ,
     */'  error gives 0 or negative value.                      ' ,//'  
     *Error adjusted to aviod negavite values on log scale. ' ,/' ------
     *-------------------------------------------------'/)
        DO 9281 COUNT=1,NPTS1
          IF ((Y(COUNT)-ERRY(COUNT) .LT. Y(COUNT)-0.9999*Y(COUNT))) THEN
            ERRYOLD = ERRY(COUNT)
            ERRY(COUNT) = 0.9999*Y(COUNT)
            WRITE(6,9290) COUNT,ERRYOLD,ERRY(COUNT)
9290        FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, '
     * to' /'        ',1PE11.4,'.')
          END IF
9281    CONTINUE
9282    CONTINUE
        WRITE(6,9300)
9300    FORMAT (/' -----------------------------------------------------
     *--'/)
      END IF
      IF ((CURVENUM .LT. 10 )) THEN
        WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM
      ELSE
        WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM
      END IF
      WRITE(UNITNUM,7930) CURVENUM,SERIESTITLE(1:SERIESLENGTH)
7930  FORMAT ('@    legend string ',I2,' "',A,'"')
      IF ((TYPE .EQ. 0)) THEN
        DO 9311 COUNT=1,NPTS1
          IF ((ERRY(COUNT) .NE. 0)) THEN
            GOTO 9320
          END IF
9311    CONTINUE
9312    CONTINUE
        WRITE(UNITNUM,7940)
7940    FORMAT ('@TYPE xy')
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,7950) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,7960) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,7970) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,7980) CURVENUM
          WRITE(UNITNUM,7990) CURVENUM, CURVENUM+1
        END IF
7950    FORMAT ('@    s',I1,' errorbar length 0.000000')
7980    FORMAT ('@    s',I2,' errorbar length 0.000000')
7960    FORMAT ('@    s',I1,' symbol color ',I2)
7970    FORMAT ('@    s',I1,' symbol color ',I1)
7990    FORMAT ('@    s',I2,' symbol color ',I2)
        DO 9331 COUNT=1,NPTS1
          WRITE(UNITNUM,8010) X(COUNT),Y(COUNT)
9331    CONTINUE
9332    CONTINUE
8010    FORMAT (1PE15.4,1PE15.4)
        GOTO 9340
9320    CONTINUE
        WRITE(UNITNUM,9350)
9350    FORMAT ('@TYPE xydy')
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,7950) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,7960) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,7970) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,7980) CURVENUM
          WRITE(UNITNUM,7990) CURVENUM, CURVENUM+1
        END IF
        DO 9361 COUNT=1,NPTS1
          WRITE(UNITNUM,9370) X(COUNT),Y(COUNT),ERRY(COUNT)
9361    CONTINUE
9362    CONTINUE
9370    FORMAT (1PE15.4,1PE15.4,1PE15.4)
9340    CONTINUE
      ELSE
        YMIN = ABS(1.E5 * Y(1))
        DO 9381 COUNT=1,NPTS1
          IF ((ABS(Y(COUNT)) .LT. YMIN)) THEN
            YMIN = ABS(Y(COUNT))
          END IF
9381    CONTINUE
9382    CONTINUE
        YMIN = SIGN(one,Y(1)) * 1.E-5 * YMIN
        Y(NPTS1+1) = YMIN
        IF (((AXISTYPE .EQ. 2 .OR. AXISTYPE .EQ. 3) .AND. HISTXMIN .EQ.
     *  0)) THEN
          IF ((X(1) .EQ. (X(2)-X(1)))) THEN
            HISTXMIN = X(1)-0.5*(X(2)-X(1))
          ELSE
            HISTXMIN = X(1)-(X(2)-X(1))
          END IF
          WRITE(6,9390) HISTXMIN
9390      FORMAT (/' ---------WARNING from Subroutine XVGRPLOT--------',
     */'  Minimum bin for X specified as 0 with log scale  ' ,/'  on X a
     *xis.  Minimum X bin set to ',1PE10.3,'.' ,/' ---------------------
     *----------------------------'/)
        END IF
        DO 9401 COUNT=1,NPTS1
          IF ((ERRY(COUNT) .NE. 0.)) THEN
            GOTO 9410
          END IF
9401    CONTINUE
9402    CONTINUE
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,7950) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,7960) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,7970) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,7980) CURVENUM
          WRITE(UNITNUM,7990) CURVENUM, CURVENUM+1
        END IF
        WRITE(UNITNUM,7940)
        WRITE(UNITNUM,8010) HISTXMIN,YMIN
        WRITE(UNITNUM,8010) HISTXMIN,Y(1)
        DO 9421 COUNT=1,NPTS1
          WRITE(UNITNUM,8010) X(COUNT),Y(COUNT)
          WRITE(UNITNUM,8010) X(COUNT),Y(COUNT+1)
9421    CONTINUE
9422    CONTINUE
        GOTO 9430
9410    CONTINUE
        ERRY(NPTS1+1) = 0.0
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,7950) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,7960) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,7970) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,7980) CURVENUM
          WRITE(UNITNUM,7990) CURVENUM, CURVENUM+1
        END IF
        WRITE(UNITNUM,9350)
        IF ((HISTXMIN .EQ. 0.0)) THEN
          HISTXMIN = SMALLESTX*FUDGE
        END IF
        WRITE(UNITNUM,9370) HISTXMIN, YMIN, 0.
        WRITE(UNITNUM,9370) HISTXMIN, Y(1), 0.
        WRITE(UNITNUM,9370) (X(1)+HISTXMIN)/2., Y(1), ERRY(1)
        DO 9441 COUNT=1,NPTS1
          WRITE (UNITNUM,9370) X(COUNT),Y(COUNT),0.
          WRITE (UNITNUM,9370) X(COUNT),Y(COUNT+1),0.
          IF ((COUNT .LT. NPTS1)) THEN
            WRITE (UNITNUM,9370) (X(COUNT)+X(COUNT+1))/2.,Y(COUNT+1),ERR
     *      Y(COUNT+1)
          END IF
9441    CONTINUE
9442    CONTINUE
9430    CONTINUE
      END IF
      WRITE(UNITNUM,'(''&'')')
      RETURN
      END
C##############################################################################
C
C   This file was automatically generated by configure version 2.0
C   It contains various subroutines and functions for date, time,
C   CPU time, host name, etc.
C
C   Attention: all changes will be lost the next time you run configure!
C
C##############################################################################


C##############################################################################
C
C  EGSnrc egs_system subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C egs_system(command)  runs a system command and returns the status
C                      command must be null-terminated
C*****************************************************************************
      integer function egs_system(command)
      character*(*) command
      integer system, istat
      istat = system(command)
      egs_system = istat
      return
      end

C##############################################################################
C
C  EGSnrc egs_isdir subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C  egs_isdir(file_name)  Returns .true., if the string file_name points to
C                        an existing directory. This version uses the lstat
C                        intrinsic and then tests for bit 14 being set in
C                        the mode element. This works on all Unix systems
C                        that I have access to (Linux, Aix, HP-UX, OSF1,
C                        Solaris, IRIX)
C
C*****************************************************************************

      logical function egs_isdir(file_name)
      implicit none
      character*(*) file_name
      integer*4 lnblnk1, res, array(13), l, lstat
      logical btest
      egs_isdir = .false.
      l = lnblnk1(file_name)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = char(0)
         ! On some systems lstat only works if the string is 0-terminated
      res = lstat(file_name,array)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = ' '
      if( res.eq.0 ) then
            ! Amost all compilers that have the lstat intrinsic return the
            ! file mode in the 3rd array element. But the PGI compiler has
            ! its own opinion on the subject and returns it in the 5th element
            ! That's why the relevant element is written as 3
            ! here, 3 gets replaced by the appropriate element
            ! by the configure script.
          if( btest(array(3),14) ) egs_isdir = .true.
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C***************************************************************************
C
C   egs_fdate(out):  print a 24 char date and time string in the form
C                         'Tue Mar 18 08:16:42 2003'
C                    to the unit specified by out without end of line
C                    i.e. the sequence
C                    write(6,'(a,$)') 'Today is '
C                    call egs_fdate(6)
C                    write(6,'(a)') '. Have a nice date'
C                    should result in something like
C                    Today is Tue Mar 18 08:16:42 2003. Have a nice date
C                    printed to unit 6.
C
C***************************************************************************

      subroutine egs_fdate(ounit)
      integer ounit
      character*24 string
      call fdate(string)
      write(ounit,'(a,$)') string
      end

C***************************************************************************
C
C   egs_get_fdate(string) assignes a 24 char date and time string to string
C                         string must be at least 24 chars long, otherwise
C                         this subroutine has no effect.
C
C***************************************************************************

      subroutine egs_get_fdate(string)
      character*(*) string
      if( len(string).ge.24 ) call fdate(string)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date_and_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


      subroutine egs_date_and_time(vnow)
      integer vnow(8)
      character dat*8,tim*10,zon*5
      call date_and_time(dat,tim,zon,vnow)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*************************************************************************
C
C egs_date(ounit): print a 11 char string in the form
C                     '18-Mar-2003'
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_date(ounit)
      integer ounit
      character string*24, dat*11
      call fdate(string)
      dat(1:2) = string(9:10)
      dat(3:3) = '-'
      dat(4:6) = string(5:7)
      dat(7:7) = '-'
      dat(8:11) = string(21:24)
      write(ounit,'(a,$)') dat
      return
      end

C##############################################################################
C
C  EGSnrc egs_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C $Id: egs_time_v1.f,v 1.1 2003/07/11 19:17:08 iwan Exp $
C*************************************************************************
C
C egs_time(ounit): print a 8 char string in the form hh:mm:ss
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_time(ounit)
      integer ounit
      character string*24
      call fdate(string)
      write(ounit,'(a,$)') string(12:19)
      return
      end

C##############################################################################
C
C  EGSnrc seconds timing subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_secnds(t0): returns seconds passed since midnight minus t0
C
C*****************************************************************************

      real function egs_secnds(t0)
      real t0,t1
      character dat*8,tim*10,zon*5
      integer values(8)
      call date_and_time(dat,tim,zon,values)
      t1 = 3600.*values(5) + 60.*values(6) + values(7) + 0.001*values(8)
      egs_secnds = t1 - t0
      return
      end

C*****************************************************************************
C
C real function egs_tot_time()
C
C   On first call returns seconds passed since 1/1/1970
C   On subsequent calls returns
C     - seconds since last call, if flag = 0
C     - seconds since first call, else
C
C*****************************************************************************

      real function egs_tot_time(flag)
      integer flag
      character dat*8,tim*10,zon*5
      integer vnow(8), vlast(8),i
      real t,egs_time_diff,t0
      data vlast/1970,1,1,5*0/,t0/-1/
      save vlast,t0
      call date_and_time(dat,tim,zon,vnow)
      t = egs_time_diff(vlast,vnow)
      do i=1,8
        vlast(i)=vnow(i)
      end do
      if( t0.lt.0 ) then
        t0 = 0
        egs_tot_time = t
      else
        t0 = t0 + t
        if(flag.eq.0) then
          egs_tot_time = t
        else
          egs_tot_time = t0
        end if
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date and time subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C****************************************************************************
C
C Returns the time difference between vstart and vend
C vstart and vend are integer arrays of dimension 8 with elements
C corresponding to the specification of the data_and_time routine, i.e.
C   array(1) = year
C   array(2) = month of the year   (1...12)
C   array(3) = day of the month    (1...31)
C   array(4) = difference in minutes from UTC
C   array(5) = hour of the day     (1...23)
C   array(6) = minute of the hour  (1...59)
C   array(7) = seconds of the minute (1...59)
C   array(8) = miliseconds of the second (1...999)
C
C Note: this implementation ignores the time difference from UTC field
C
C*****************************************************************************
      real function egs_time_diff(vstart,vend)
      integer    vstart(8),vend(8)
      real       egs_time_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_time_diff = -egs_time_diff_o(vend,vstart)
      else
        egs_time_diff = egs_time_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C day difference between the dates specified by the integer arrays vstart and
C vend. The arrays are v(1)=year, v(2)=month, v(3)=day
C
C******************************************************************************
      integer function egs_day_diff(vstart,vend)
      integer vstart(3),vend(3),egs_day_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_day_diff = -egs_day_diff_o(vend,vstart)
      else
        egs_day_diff = egs_day_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C Returns a 3-letter abreviation of the day of the week in the string day,
C given a day specified by the integer array values
C   values(1)=year, values(2)=month, values(3)=day
C
C******************************************************************************
      subroutine egs_weekday(values,day)
      character*(*) day
      integer       values(3)
      integer       days,vtmp(3),egs_day_diff,aux
      character*3   wdays(7)
      data wdays/'Mon','Tue','Wed','Thu','Fri','Sat','Sun'/
      vtmp(1) = 1970
      vtmp(2) = 1
      vtmp(3) = 1
      days = egs_day_diff(vtmp,values)
      aux = mod(days,7)
      days = 4 + aux
      if( days.gt.7 ) days = days - 7
      day(:len(day)) = ' '
      aux = min(len(day),3)
      day(:aux) = wdays(days)(:aux)
      return
      end

C*****************************************************************************
C
C Same as egs_day_diff above, but assumes that vend specifies a later date
C than vstart.
C
C*****************************************************************************
      integer function egs_day_diff_o(vstart,vend)
      integer vstart(3),vend(3)
      integer    days
      logical    next_month
      integer    tm,m,ty,y
      integer    mdays(12)
      data       mdays/31,28,31,30,31,30,31,31,30,31,30,31/
      days = 0
      ty = vstart(1)
      y  = vend(1)
      tm = vstart(2)
      m  = vend(2)
      next_month = .true.
      do while(next_month)
        if( tm.eq.m.and.ty.eq.y ) then
          next_month = .false.
        else
          days = days + mdays(tm)
          if( tm.eq.2.and.mod(ty,4).eq.0 ) days = days + 1
          tm = tm + 1
          if( tm.gt.12 ) then
            ty = ty + 1
            tm = 1
          end if
        end if
      end do
      days = days + vend(3) - vstart(3)
      egs_day_diff_o = days
      return
      end

C******************************************************************************
C
C Same as egs_time_diff above, but assumes that vend specifies a later date
C than vstart.
C
C******************************************************************************
      real function egs_time_diff_o(vstart,vend)
      integer    vstart(8),vend(8)
      integer    days,hours,minutes,secs,msecs
      integer    egs_day_diff_o
      days = egs_day_diff_o(vstart,vend)
      hours = vend(5) - vstart(5)
      minutes = vend(6) - vstart(6)
      secs = vend(7) - vstart(7)
      msecs = vend(8) - vstart(8)
      egs_time_diff_o = 3600.*(24.*days+hours)+60.*minutes+secs+
     &                  0.001*msecs
      return
      end

C******************************************************************************
C
C Returns in month a 3-letter abreviation of the month specified by mo, if
C mo is between 1 and 12, or an empty string otherwise.
C
C******************************************************************************
      subroutine egs_month(mo,month)
      integer mo
      character*(*) month
      integer iaux
      character*3   months(12)
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      iaux = min(len(month),3)
      month(:len(month)) = ' '
      if( mo.ge.1.and.mo.le.12 ) month(:iaux) = months(mo)(:iaux)
      return
      end

C******************************************************************************
C
C Converts a 3-letter abreviation of a month to its corresponding integer
C value, if the string month is a valid month, or -1 otherwise.
C
C******************************************************************************
      integer function egs_conver_month(month)
      character*3 month
      character*3 months(12)
      integer i
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      do i=1,12
        if( month.eq.months(i) ) then
          egs_conver_month = i
          return
        end if
      end do
      egs_conver_month = -1
      return
      end


C##############################################################################
C
C  EGSnrc egs_etime subroutine
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_etime(): returns CPU time consumed since the start of
C                            the program
C
C*****************************************************************************

      real function egs_etime()
      real tarray(2),etime
      egs_etime = etime(tarray)
      return
      end

C##############################################################################
C
C  EGSnrc canonical system name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the canonical system name as determined by the config.guess script
C or the Windows installation program to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_canonical_system(ounit)
      integer ounit
      write(6,'(a,$)') 'x86_64-unknown-linux-gnu'
      return
      end

C******************************************************************************
C
C Assign the canonical system name as determined by the config.guess script
C or the Windows installation program to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_canonical_system(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('x86_64-unknown-linux-gnu')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'x86_64-unknown-linux-gnu'
      else
        res(:l2) = 'x86_64-unknown-linux-gnu'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc configuration name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the configuration name as specified suring the configuration
C process to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_configuration_name(ounit)
      integer ounit
      write(6,'(a,$)') 'linux'
      return
      end

C******************************************************************************
C
C Assign the configuration name as specified suring the configuration
C process to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_configuration_name(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('linux')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'linux'
      else
        res(:l2) = 'linux'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc hostname subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C Print the host name to the unit specified by ounit without inserting
C a new line character.
C
C*****************************************************************************

      subroutine egs_print_hostnm(ounit)
      integer ounit
      character*256 string
      integer res,hostnm,lnblnk1
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      write(ounit,'(a,$)') string(:lnblnk1(string))
      return
      end

C*****************************************************************************
C
C Assign the host name to the string pointed to be hname.
C
C*****************************************************************************

      subroutine egs_get_hostnm(hname)
      character*(*) hname
      character*256 string
      integer res,hostnm,lnblnk1,l1,l2,l
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      l1 = lnblnk1(string)
      l2 = len(hname)
      hname(:l2) = ' '
      l = min(l1,l2)
      hname(:l) = string(:l)
      return
      end

      subroutine egs_init
      implicit none
      common/my_times/ t_elapsed, t_cpu, t_first
      real*8 t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      real*8 dum
      call egs_set_defaults
      call egs_check_arguments
      call egs_init1
      return
      end
      subroutine egs_init1
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      common/my_times/ t_elapsed, t_cpu, t_first
      real*8 t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      integer l, lnblnk1, l1, l2
      integer i
      character arg*256,tmp_string*512, tmp1_string*512, ucode_dir*512,
     *line*80, line1*80,dattim*24
      logical have_input,egs_isdir,egs_strip_extension,ex, on_egs_home,i
     *s_opened
      integer*4 mypid
      integer getpid
      integer istat, egs_system, u, pos1, pos2,egs_get_unit,itmp
      real*8 dum
      t_elapsed = 0
      t_cpu = egs_etime()
      dum = egs_tot_time(1)
      call egs_date_and_time(t_first)
      DO 9451 i=1,len(line)
        line(i:i) = '='
9451  CONTINUE
9452  CONTINUE
      DO 9461 i=1,len(line1)
        line1(i:i) = '.'
9461  CONTINUE
9462  CONTINUE
      IF ((.NOT.is_pegsless)) THEN
        on_egs_home = .false.
        inquire(file=pegs_file,exist=ex)
        IF (( ex )) THEN
          kmpi=egs_get_unit(kmpi)
          IF ((kmpi.LT.0)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'failed to get a free Fortran I/O unit for pe
     *gs file'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(kmpi,file=pegs_file,status='old',err=9470)
          goto 9480
        END IF
        arg = pegs_file(:lnblnk1(pegs_file))
        ex = egs_strip_extension(arg,'.pegs4dat')
        l = lnblnk1(egs_home)
        l1 = lnblnk1('pegs4data') + 2*lnblnk1('/')
        l2 = lnblnk1(arg) + lnblnk1('.pegs4dat')
        IF (( l + l1 + l2 .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'pegs4 data file name (including absolute path)
     *'
          write(i_log,'(a,i4,a)') 'is too long (',l+l1+l2,') characters'
        ELSE
          pegs_file = egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/' //
     *    'data' // '/' // arg(:lnblnk1(arg)) // '.pegs4dat'
          inquire(file=pegs_file,exist=ex)
          IF (( ex )) THEN
            kmpi=egs_get_unit(kmpi)
            IF ((kmpi.LT.0)) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'failed to get a free Fortran I/O unit for
     *pegs file'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            open(kmpi,file=pegs_file,status='old',err=9470)
            on_egs_home = .true.
            goto 9480
          END IF
        END IF
        l = lnblnk1(hen_house)
        IF (( l + l1 + l2 .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'pegs4 data file name (including absolute path)
     *'
          write(i_log,'(a,i4,a)') 'is too long (',l+l1+l2,') characters'
        ELSE
          pegs_file = hen_house(:lnblnk1(hen_house)) // 'pegs4' // '/' /
     *    / 'data' // '/' // arg(:lnblnk1(arg)) // '.pegs4dat'
          inquire(file=pegs_file,exist=ex)
          IF (( ex )) THEN
            kmpi=egs_get_unit(kmpi)
            IF ((kmpi.LT.0)) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'failed to get a free Fortran I/O unit for
     *pegs file'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            open(kmpi,file=pegs_file,status='old',err=9470)
            goto 9480
          END IF
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'could not find pegs4 file named ',arg(:lnblnk1(a
     *  rg))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
9480  CONTINUE
      DO 9491 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
9491  CONTINUE
9492  CONTINUE
      tmp_string = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      i_nist_data=76
      i_incoh=78
      i_photo_relax=77
      i_photo_cs=79
      i_mscat=11
      DO 9501 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
9501  CONTINUE
9502  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'photo_cs.data'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','photo_cs.data',' does not ex
     *ist'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_photo_cs=egs_get_unit(i_photo_cs)
        IF ((i_photo_cs.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_photo_cs,file=tmp1_string,status='old',err=9510)
      ELSE
        i_photo_cs = itmp
      END IF
      DO 9521 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
9521  CONTINUE
9522  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'msnew.data'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','msnew.data',' does not exist
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_mscat=egs_get_unit(i_mscat)
        IF ((i_mscat.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_mscat,file=tmp1_string,status='old',err=9510)
      ELSE
        i_mscat = itmp
      END IF
      DO 9531 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
9531  CONTINUE
9532  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'incoh.data'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','incoh.data',' does not exist
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_incoh=egs_get_unit(i_incoh)
        IF ((i_incoh.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_incoh,file=tmp1_string,status='old',err=9510)
      ELSE
        i_incoh = itmp
      END IF
      DO 9541 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
9541  CONTINUE
9542  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'photo_relax.dat
     *a'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','photo_relax.data',' does not
     * exist'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_photo_relax=egs_get_unit(i_photo_relax)
        IF ((i_photo_relax.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_photo_relax,file=tmp1_string,status='old',err=9510)
      ELSE
        i_photo_relax = itmp
      END IF
      DO 9551 i=1,len(ucode_dir)
        ucode_dir(i:i) = ' '
9551  CONTINUE
9552  CONTINUE
      ucode_dir = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(use
     *r_code)) // '/'
      have_input = .false.
      i_input=5
      IF (( lnblnk1(input_file) .GT. 0 )) THEN
        have_input = .true.
        l = lnblnk1(egs_home)
        l1 = lnblnk1(user_code)+1
        l2 = lnblnk1(input_file) + lnblnk1('.egsinp')
        IF (( l + l1 + l2 .GT. 1024 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'input file name (including path) is too long '
     *    ,l+l1+l2
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        ex = egs_strip_extension(input_file,'.egsinp')
        tmp_string = ucode_dir(:lnblnk1(ucode_dir)) // input_file(:lnbln
     *  k1(input_file)) // '.egsinp'
        inquire(file=tmp_string,exist=ex)
        IF (( .NOT.ex )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'Input file ',tmp_string(:lnblnk1(tmp_string)),
     *    ' does not exist.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_input,file=tmp_string,status='old',err=9560)
      END IF
      DO 9571 i=1,len(work_dir)
        work_dir(i:i) = ' '
9571  CONTINUE
9572  CONTINUE
      work_dir = 'egsrun_'
      mypid = getpid()
      call egs_itostring(work_dir,mypid,.false.)
      call egs_get_hostnm(host_name)
      IF((lnblnk1(host_name) .LT. 1))host_name = 'unknown'
      IF (( have_input )) THEN
        work_dir = work_dir(:lnblnk1(work_dir)) // '_' // input_file(:ln
     *  blnk1(input_file)) // '_' // host_name(:lnblnk1(host_name)) // '
     */'
      ELSE
        work_dir = work_dir(:lnblnk1(work_dir)) // '_noinput_' // host_n
     *  ame(:lnblnk1(host_name)) // '/'
      END IF
      DO 9581 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
9581  CONTINUE
9582  CONTINUE
      tmp_string = ucode_dir(:lnblnk1(ucode_dir)) // work_dir(:lnblnk1(w
     *ork_dir))
      DO 9591 i=1,lnblnk1(tmp_string)
        IF (( tmp_string(i:i) .EQ. '/' )) THEN
          tmp_string(i:i) = '/'
        END IF
9591  CONTINUE
9592  CONTINUE
      ex = egs_isdir(tmp_string)
      IF (( ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'a directory named ',tmp_string(:lnblnk1(tmp_stri
     *  ng)),' already exists?'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp1_string = 'mkdir ' // tmp_string(:lnblnk1(tmp_string))
      l = lnblnk1(tmp1_string)
      tmp1_string(l+1:l+1) = char(0)
      istat = egs_system(tmp1_string)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'failed to create working directory ',tmp1_string
     *  (:lnblnk1(tmp1_string))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      call egs_open_units(.true.)
      write(i_log,'(a)') line
      write(i_log,'(a,a,t55,a,$)') 'EGSnrc version 4 for ','x86_64-unkno
     *wn-linux-gnu',' '
      call egs_get_fdate(dattim)
      write(i_log,'(a,/,a)') dattim,line
      pos1 = lnblnk1('output file(s)')
      pos2 = 80 - lnblnk1('linux')
      pos2 = min(pos2,80-lnblnk1(user_code))
      DO 9601 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
9601  CONTINUE
9602  CONTINUE
      tmp_string = pegs_file
      call egs_strip_path(tmp_string)
      ex = egs_strip_extension(tmp_string,'.pegs4dat')
      IF (( on_egs_home )) THEN
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // ' on EGS_HOME'
      ELSE
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // ' on HEN_HOUSE'
      END IF
      IF (( lnblnk1(tmp_string) .GT. lnblnk1(pegs_file) )) THEN
        DO 9611 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
9611    CONTINUE
9612    CONTINUE
        tmp_string = pegs_file
      END IF
      pos2 = min(pos2,80-lnblnk1(tmp_string))
      pos2 = min(pos2,80-lnblnk1(host_name))
      IF((have_input))pos2 = min(pos2,80-lnblnk1(input_file))
      pos2 = min(pos2,80-lnblnk1(output_file))
      IF((pos2 .LT. pos1+2))pos2 = pos1 + 2
      write(i_log,'(a,$)') 'configuration'
      l = pos2 - lnblnk1('configuration')
      write(i_log,'(a,$)') line1(:l)
      write(i_log,'(a)') 'linux'
      write(i_log,'(a,$)') 'user code'
      l = pos2 - lnblnk1('user code')
      write(i_log,'(a,$)') line1(:l)
      write(i_log,'(a)') user_code(:lnblnk1(user_code))
      write(i_log,'(a,$)') 'pegs file'
      l = pos2 - lnblnk1('pegs file')
      write(i_log,'(a,$)') line1(:l)
      write(i_log,'(a)') tmp_string(:lnblnk1(tmp_string))
      write(i_log,'(a,$)') 'using host'
      l = pos2 - lnblnk1('using host')
      write(i_log,'(a,$)') line1(:l)
      write(i_log,'(a)') host_name(:lnblnk1(host_name))
      IF (( have_input )) THEN
        write(i_log,'(a,$)') 'input file'
        l = pos2 - lnblnk1('input file')
        write(i_log,'(a,$)') line1(:l)
        write(i_log,'(a)') input_file(:lnblnk1(input_file))
      END IF
      write(i_log,'(a,$)') 'output file(s)'
      l = pos2 - lnblnk1('output file(s)')
      write(i_log,'(a,$)') line1(:l)
      write(i_log,'(a)') output_file(:lnblnk1(output_file))
      IF (( n_parallel .GT. 0 )) THEN
        write(i_log,'(a,$)') 'number of parallel jobs'
        l = pos2 - lnblnk1('number of parallel jobs')
        write(i_log,'(a,$)') line1(:l)
        write(i_log,'(i2)') n_parallel
        write(i_log,'(a,$)') 'job number'
        l = pos2 - lnblnk1('job number')
        write(i_log,'(a,$)') line1(:l)
        write(i_log,'(i2)') i_parallel
      END IF
      write(i_log,'(a)') line
      return
9560  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open input file ',tmp_string(:lnblnk1(tm
     *p_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
9470  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open existing pegs file ',pegs_file(:lnb
     *lnk1(pegs_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
9510  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open EGSnrc data file ',tmp1_string(:lnb
     *lnk1(tmp1_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_check_arguments
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character arg*256,tmp_string*512, line1*80
      logical have_arg,egs_isdir,egs_strip_extension,ex, on_egs_home
      integer narg, iargc, i, lnblnk1, l, l2,i_help,egs_get_unit
      narg = iargc()
      IF((narg .LT. 1))return
      have_arg = .false.
      DO 9621 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-H') .AND. arg(:l) .EQ. '-H' ) .OR. ( l
     *  .EQ. lnblnk1('--hen-house') .AND. arg(:l) .EQ. '--hen-house' ) )
     *  ) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9622
        END IF
9621  CONTINUE
9622  CONTINUE
      IF (( have_arg )) THEN
        l = lnblnk1(arg)
        DO 9631 i=1,len(hen_house)
          hen_house(i:i) = ' '
9631    CONTINUE
9632    CONTINUE
        IF (( l .GT. 0 )) THEN
          IF (( l .GT. 254 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a,i5)') ' HEN_HOUSE argument is too long',l
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          hen_house(:l) = arg(:lnblnk1(arg))
          IF((hen_house(l:l) .NE. '/'))hen_house(l+1:l+1) = '/'
        ELSE
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a)') ' empty argument after -H'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        DO 9641 i=1,lnblnk1(hen_house)
          IF (( hen_house(i:i) .EQ. '/' )) THEN
            hen_house(i:i) = '/'
          END IF
9641    CONTINUE
9642    CONTINUE
      END IF
      IF (( .NOT.egs_isdir(hen_house) )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,'(a,a)') ' HEN_HOUSE directory ',hen_house(:lnblnk1(
     *  hen_house))
        write(i_log,'(a)') 'does not exist. Hope you know what you are d
     *oing.'
      END IF
      have_arg = .false.
      DO 9651 i=1,narg
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-h') .AND. arg(:l) .EQ. '-h' ) .OR. ( l
     *  .EQ. lnblnk1('--help') .AND. arg(:l) .EQ. '--help' ) )) THEN
          have_arg = .true.
          GO TO9652
        END IF
9651  CONTINUE
9652  CONTINUE
      IF (( have_arg )) THEN
        call getarg(0,arg)
        call egs_strip_path(arg)
        write(i_log,'(//,a,a,a,//)') 'Usage: ',arg(:lnblnk1(arg)),' [arg
     *s] '
        tmp_string = hen_house(:lnblnk1(hen_house)) // 'pieces/help_mess
     *age'
        i_help=98
        i_help=egs_get_unit(i_help)
        IF ((i_help.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for help
     * file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_help,file=tmp_string,status='old',err=9660)
9671    CONTINUE
          read(i_help,'(a)',err=9680,end=9680) line1
          write(i_log,'(a)') line1
        GO TO 9671
9672    CONTINUE
9680    CONTINUE
        call exit(0)
9660    CONTINUE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Did not find the help_message file!'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      have_arg = .false.
      DO 9691 i=1,narg
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-b') .AND. arg(:l) .EQ. '-b' ) .OR. ( l
     *  .EQ. lnblnk1('--batch') .AND. arg(:l) .EQ. '--batch' ) )) THEN
          have_arg = .true.
          GO TO9692
        END IF
9691  CONTINUE
9692  CONTINUE
      IF((have_arg))is_batch = .true.
      have_arg = .false.
      DO 9701 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-P') .AND. arg(:l) .EQ. '-P' ) .OR. ( l
     *  .EQ. lnblnk1('--parallel') .AND. arg(:l) .EQ. '--parallel' ) ))
     *  THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9702
        END IF
9701  CONTINUE
9702  CONTINUE
      IF (( have_arg )) THEN
        read(arg,*,err=9710) n_parallel
        IF((n_parallel .LT. 0))goto 9710
        goto 9720
9710    CONTINUE
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Wrong/missing parallel job number argument, -P
     *option ignored'
        n_parallel = 0
9720    CONTINUE
      END IF
      have_arg = .false.
      DO 9731 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-j') .AND. arg(:l) .EQ. '-j' ) .OR. ( l
     *  .EQ. lnblnk1('--job') .AND. arg(:l) .EQ. '--job' ) )) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9732
        END IF
9731  CONTINUE
9732  CONTINUE
      IF (( have_arg )) THEN
        read(arg,*,err=9740) i_parallel
        IF((i_parallel .LT. 0))goto 9740
        goto 9750
9740    CONTINUE
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Wrong/missing job argument, -j option ognored'
        i_parallel = 0
9750    CONTINUE
      END IF
      have_arg = .false.
      DO 9761 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-f') .AND. arg(:l) .EQ. '-f' ) .OR. ( l
     *  .EQ. lnblnk1('--first-job') .AND. arg(:l) .EQ. '--first-job' ) )
     *  ) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9762
        END IF
9761  CONTINUE
9762  CONTINUE
      IF (( have_arg )) THEN
        read(arg,*,err=9770) first_parallel
        IF((first_parallel .LT. 1))goto 9770
        goto 9780
9770    CONTINUE
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Wrong/missing first job argument, -f option ogn
     *ored'
        first_parallel = 1
9780    CONTINUE
      END IF
      IF (( n_parallel .GT. 0 .OR. i_parallel .GT. 0 )) THEN
        IF (( n_parallel*i_parallel .EQ. 0 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'You need to specify number of jobs AND job num
     *ber ', '=> will not use parallel run '
          n_parallel = 0
          i_parallel = 0
        END IF
        IF (( first_parallel .GT. i_parallel )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'i_parallel (',i_parallel, ') can not be smalle
     *r than first_parallel (',first_parallel,')'
          first_parallel = i_parallel
        END IF
      END IF
      have_arg = .false.
      DO 9791 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-e') .AND. arg(:l) .EQ. '-e' ) .OR. ( l
     *  .EQ. lnblnk1('--egs-home') .AND. arg(:l) .EQ. '--egs-home' ) ))
     *  THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9792
        END IF
9791  CONTINUE
9792  CONTINUE
      IF (( have_arg )) THEN
        l = lnblnk1(arg)
        DO 9801 i=1,len(egs_home)
          egs_home(i:i) = ' '
9801    CONTINUE
9802    CONTINUE
        IF (( l .EQ. 0 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a)') ' empty argument after -e'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF (( l .GT. 254 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,i5)') ' EGS_HOME argument is too long ',l
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        egs_home(:l) = arg(:lnblnk1(arg))
        IF((egs_home(l:l) .NE. '/'))egs_home(l+1:l+1) = '/'
        DO 9811 i=1,lnblnk1(egs_home)
          IF (( egs_home(i:i) .EQ. '/' )) THEN
            egs_home(i:i) = '/'
          END IF
9811    CONTINUE
9812    CONTINUE
      END IF
      IF (( .NOT.egs_isdir(egs_home) )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' EGS_HOME directory ',egs_home(:lnblnk1(egs_home
     *  )),' does not exist.'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      on_egs_home = .false.
      is_pegsless=.false.
      have_arg = .false.
      DO 9821 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-p') .AND. arg(:l) .EQ. '-p' ) .OR. ( l
     *  .EQ. lnblnk1('--pegs-file') .AND. arg(:l) .EQ. '--pegs-file' ) )
     *  ) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9822
        END IF
9821  CONTINUE
9822  CONTINUE
      IF (( .NOT.have_arg )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) 'No pegs4 file name supplied.  Will assume you ar
     *e running    in pegs-less mode with media details specified in inp
     *ut file.'
        is_pegsless=.true.
      ELSE
        pegs_file = arg(:lnblnk1(arg))
      END IF
      call egs_get_usercode(user_code)
      have_arg = .false.
      DO 9831 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-i') .AND. arg(:l) .EQ. '-i' ) .OR. ( l
     *  .EQ. lnblnk1('--input') .AND. arg(:l) .EQ. '--input' ) )) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9832
        END IF
9831  CONTINUE
9832  CONTINUE
      IF (( have_arg )) THEN
        ex = egs_strip_extension(arg,'.egsinp')
        l2 = lnblnk1(arg) + lnblnk1('.egsinp')
        IF (( l2 .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'input file name is too long ',l2
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        input_file = arg(:lnblnk1(arg))
      END IF
      have_arg = .false.
      DO 9841 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-o') .AND. arg(:l) .EQ. '-o' ) .OR. ( l
     *  .EQ. lnblnk1('--output') .AND. arg(:l) .EQ. '--output' ) )) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9842
        END IF
9841  CONTINUE
9842  CONTINUE
      IF (( have_arg )) THEN
        l = lnblnk1(arg)
        IF (( l .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'output file name is too long ',l
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        output_file(:l) = arg(:lnblnk1(arg))
      ELSE
        IF (( lnblnk1(input_file) .GT. 0 )) THEN
          output_file(:lnblnk1(input_file)) = input_file(:lnblnk1(input_
     *    file))
        ELSE
          output_file = 'test'
        END IF
      END IF
      return
      end
      subroutine egs_open_units(flag)
      implicit none
      logical flag
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character tmp_string*1024, tmp1_string*1024, tmp2_string*1024, uco
     *de_dir*1024, input_line*100, arg*20
      integer i,lnblnk1,u,l,istart,egs_get_unit,i_iofile
      logical ex,is_open
      DO 9851 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
9851  CONTINUE
9852  CONTINUE
      DO 9861 i=1,len(ucode_dir)
        ucode_dir(i:i) = ' '
9861  CONTINUE
9862  CONTINUE
      ucode_dir = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(use
     *r_code)) // '/'
      IF (( flag )) THEN
        tmp_string = ucode_dir(:lnblnk1(ucode_dir)) // work_dir(:lnblnk1
     *  (work_dir))
      ELSE
        tmp_string = ucode_dir(:lnblnk1(ucode_dir))
      END IF
      tmp_string = tmp_string(:lnblnk1(tmp_string)) // output_file(:lnbl
     *nk1(output_file))
      IF (( i_parallel .GT. 0 )) THEN
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // '_w'
        call egs_itostring(tmp_string,i_parallel,.false.)
      END IF
      DO 9871 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
9871  CONTINUE
9872  CONTINUE
      i_log=6
      IF (( is_batch )) THEN
        tmp1_string = tmp_string(:lnblnk1(tmp_string)) // '.egslog'
        open(i_log,file=tmp1_string,status='unknown',err=9880)
      END IF
      DO 9891 i=1,len(tmp2_string)
        tmp2_string(i:i) = ' '
9891  CONTINUE
9892  CONTINUE
      tmp2_string = ucode_dir(:lnblnk1(ucode_dir)) // user_code(:lnblnk1
     *(user_code)) // '.io'
      inquire(file=tmp2_string,exist=ex)
      n_files = 0
      IF (( ex )) THEN
        i_iofile=99
        i_iofile=egs_get_unit(i_iofile)
        IF ((i_iofile.LT.1)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for .io
     *file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_iofile,file=tmp2_string,status='old',err=9900)
9911    CONTINUE
          read(i_iofile,'(a)',err=9920,end=9920) input_line
          IF((input_line(1:1) .EQ. '#'))GO TO9911
          read(input_line,*,err=9930,end=9930) u
          istart = 1
          DO 9941 i=lnblnk1(input_line),1,-1
            IF (( input_line(i:i) .EQ. ' ' )) THEN
              istart = i+1
              GO TO9942
            END IF
9941      CONTINUE
9942      CONTINUE
          DO 9951 i=1,len(arg)
            arg(i:i) = ' '
9951      CONTINUE
9952      CONTINUE
          DO 9961 i=istart,lnblnk1(input_line)
            arg(i+1-istart:i+1-istart) = input_line(i:i)
9961      CONTINUE
9962      CONTINUE
          inquire(unit=u,opened=is_open)
          IF (( is_open )) THEN
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,'(a,i3,a,a,a,/,a,/,a,/)') 'Unit ',u,' which you
     *want to connect to a ', arg(:lnblnk1(arg)),' file ', 'is already i
     *n use. Will assume this code is being used as', 'a shared library
     *source and this file will be opened explicitly.'
          ELSE
            n_files = n_files + 1
            IF (( n_files .GT. 20 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'Too many units requested in .io.', ' Incre
     *as $mx_units and retry'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            file_units(n_files) = u
            DO 9971 i=1,len(file_extensions(n_files))
              file_extensions(n_files)(i:i) = ' '
9971        CONTINUE
9972        CONTINUE
            l = lnblnk1(arg)
            IF (( l .GT. 10 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'extension ',arg(:lnblnk1(arg)),' is longer
     * than ', 10,' chars. ', 'Increase $max_extension_length and retry
     *'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            file_extensions(n_files) = arg(:lnblnk1(arg))
            tmp1_string = tmp_string(:lnblnk1(tmp_string)) // arg(:lnbln
     *      k1(arg))
            open(u,file=tmp1_string,status='unknown')
          END IF
9930      CONTINUE
        GO TO 9911
9912    CONTINUE
9920    close(i_iofile)
      END IF
      return
9880  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open output file ',tmp1_string(:lnblnk1(
     *tmp1_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
9900  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open existing .io file',tmp2_string(:lnb
     *lnk1(tmp2_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_finish
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/my_times/ t_elapsed, t_cpu, t_first
      real*8 t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      character line*80,base*512,base1*512,tmp_string*512,junk_file*128,
     *fname*512
      character dattim*24
      integer i,l,lnblnk1,istat,egs_system,n_open,unlink,i_junk,egs_get_
     *unit
      logical is_open,egs_isdir
      real*8 t1,t2,tt_cpu
      DO 9981 i=1,len(line)
        line(i:i) = '='
9981  CONTINUE
9982  CONTINUE
      IF (( n_parallel .EQ. 0 .OR. i_parallel .GT. 0 )) THEN
        t_elapsed = egs_tot_time(1)
        tt_cpu = egs_etime() - t_cpu
        t1 = t_elapsed
        t2 = t1/3600
        write(i_log,'(//a,/,a,/)') line,'Finished simulation'
        write(i_log,'(2x,a,t30,f9.1,a,f7.3,a)') 'Elapsed time: ',t1,' s
     *(',t2,' h)'
        t1 = tt_cpu
        t2 = t1/3600
        write(i_log,'(2x,a,t30,f9.1,a,f7.3,a)') 'CPU time:',t1,' s (',t2
     *  ,' h)'
        write(i_log,'(2x,a,t30,f10.3)') 'Ratio:',t_elapsed/tt_cpu
      END IF
      call egs_get_fdate(dattim)
      write(i_log,'(//a,t56,a,/,a)') 'End of run ',dattim,line
      n_open=0
      DO 9991 i=1,len(base)
        base(i:i) = ' '
9991  CONTINUE
9992  CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e))
      DO 10001 i=1,99
        IF (( is_batch .OR. i .NE. i_log )) THEN
          inquire(i,opened=is_open)
          IF (( is_open )) THEN
            inquire(i,name=fname)
            IF ((index(fname(:lnblnk1(fname)),base(:lnblnk1(base))).GT.0
     *      )) THEN
              close(i)
              n_open = n_open+1
            END IF
          END IF
        END IF
10001 CONTINUE
10002 CONTINUE
      IF (( lnblnk1(work_dir) .EQ. 0 )) THEN
        return
      END IF
      DO 10011 i=1,len(base)
        base(i:i) = ' '
10011 CONTINUE
10012 CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e)) // '/' // work_dir(:lnblnk1(work_dir))
      DO 10021 i=1,lnblnk1(base)
        IF (( base(i:i) .EQ. '/' )) THEN
          base(i:i) = '/'
        END IF
10021 CONTINUE
10022 CONTINUE
      IF (( egs_isdir(base) )) THEN
        DO 10031 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
10031   CONTINUE
10032   CONTINUE
        DO 10041 i=1,len(junk_file)
          junk_file(i:i) = ' '
10041   CONTINUE
10042   CONTINUE
        junk_file = work_dir(:lnblnk1(work_dir))
        l = lnblnk1(junk_file)
        junk_file(l:l) = ' '
        junk_file = junk_file(:lnblnk1(junk_file)) // '_junk'
        tmp_string = base(:lnblnk1(base)) // junk_file(:lnblnk1(junk_fil
     *  e))
        i_junk=99
        i_junk=egs_get_unit(i_junk)
        IF ((i_junk.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for junk
     * file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_junk,file=tmp_string,status='unknown')
        write(i_junk,*) 'junk'
        close(i_junk)
        DO 10051 i=1,len(base1)
          base1(i:i) = ' '
10051   CONTINUE
10052   CONTINUE
        base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_c
     *  ode)) // '/' // work_dir(:lnblnk1(work_dir))
        base1 = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_
     *  code))
        DO 10061 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
10061   CONTINUE
10062   CONTINUE
        tmp_string = 'mv -f ' // base(:lnblnk1(base)) // '*  ' // base1(
     *  :lnblnk1(base1))
        l = lnblnk1(tmp_string)+1
        tmp_string(l:l) = char(0)
        istat = egs_system(tmp_string)
        IF (( istat .NE. 0 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'Moving files from working directory failed ?'
          write(i_log,*) '=> will not remove working directory'
        ELSE
          DO 10071 i=1,len(tmp_string)
            tmp_string(i:i) = ' '
10071     CONTINUE
10072     CONTINUE
          tmp_string = 'rm -rf ' // base(:lnblnk1(base))
          l = lnblnk1(tmp_string)+1
          tmp_string(l:l) = char(0)
          istat = egs_system(tmp_string)
          IF (( istat .NE. 0 )) THEN
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,*) 'Failed to remove working directory ', work_d
     *      ir(:lnblnk1(work_dir))
          END IF
          DO 10081 i=1,len(tmp_string)
            tmp_string(i:i) = ' '
10081     CONTINUE
10082     CONTINUE
          tmp_string = base1(:lnblnk1(base1)) // '/' // junk_file(:lnbln
     *    k1(junk_file))
          l = lnblnk1(tmp_string)+1
          tmp_string(l:l) = char(0)
          istat = unlink(tmp_string)
        END IF
      END IF
      DO 10091 i=1,len(work_dir)
        work_dir(i:i) = ' '
10091 CONTINUE
10092 CONTINUE
      return
      end
      subroutine egs_set_defaults
      implicit none
      COMMON/BOUNDS/ECUT( 12001),PCUT( 12001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,10), eno_array(200,10), eno_atbin_array(200,10), n
     *_shell(10), radc_flag,  ibcmp( 12001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      common/ET_control/ smaxir( 12001),estepe,ximax,  skindepth_for_bca
     *,transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PHOTIN/ EBINDA(10), GE0(10),GE1(10), GMFP0(2000,10),GMFP1(2
     *000,10),GBR10(2000,10),GBR11(2000,10),GBR20(2000,10),GBR21(2000,10
     *), RCO0(10),RCO1(10), RSCT0(100,10),RSCT1(100,10), COHE0(2000,10),
     *COHE1(2000,10),  PHOTONUC0(2000,10),PHOTONUC1(2000,10), DPMFP, MPG
     *EM(1,10), NGR(10)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      real*8 SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/spin_data/ spin_rej(10,0:1,0: 31,0:15,0:31), espin_min,espi
     *n_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dleneri,d
     *qq1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(10), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),
     *eii_sh(40),  eii_nshells(100),  eii_nsh(10),  eii_first(10,50),  e
     *ii_no(10,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      COMMON/rayleigh_inputs/iray_ff_media(10),iray_ff_file(10)
      character*24 iray_ff_media
      character*128 iray_ff_file
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      integer i,j,lnblnk1
      CHARACTER*4 MEDIA1(24)
      EQUIVALENCE(MEDIA1(1),MEDIA(1,1))
      character fool_dec
      data MEDIA1/'N','A','I',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','
     *',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '/
      data fool_dec/'/'/
      data fool_intel_optimizer/.false./
      vacdst = 1e8
      DO 10101 i=1, 12001
        ecut(i) = 0.
        pcut(i) = 0.
        ibcmp(i) = 3
        iedgfl(i) = 1
        iphter(i) = 1
        smaxir(i) = 1e10
        i_do_rr(i) = 0
        e_max_rr(i) = 0
        med(i) = 1
        rhor(i) = 0
        iraylr(i) = 1
        iphotonucr(i) = 0
10101 CONTINUE
10102 CONTINUE
      eii_flag = 0
      eii_xfile = 'Off'
      eii_L_factor = 1.0
      xsec_out = 0
      photon_xsections = 'xcom'
      comp_xsections = 'default'
      eadl_relax = .true.
      mcdf_pe_xsections = .false.
      photonuc_xsections = 'default'
      ExIN=0
      EyIN=0
      EzIN=0
      BxIN=0
      ByIN=0
      BzIN=0
      EMLMTIN=0.02
      Bx=BxIN
      By=ByIN
      Bz=BzIN
      Bx_new=Bx
      By_new=By
      Bz_new=Bz
      emfield_on=.false.
      IF (( ExIN**2+EyIN**2+EzIN**2 + BxIN**2+ByIN**2+BzIN**2 .GT. 0 ))
     *THEN
        emfield_on=.true.
      END IF
      DO 10111 i=1,10
        iraylm(i) = 0
        DO 10121 j=1,len(iray_ff_file(i))
          iray_ff_file(i)(j:j) = ' '
10121   CONTINUE
10122   CONTINUE
        DO 10131 j=1,len(iray_ff_media(i))
          iray_ff_media(i)(j:j) = ' '
10131   CONTINUE
10132   CONTINUE
        ae(i)=0
        ap(i)=0
        ue(i)=0
        up(i)=0
        te(i)=0
        thmoll(i)=0
10111 CONTINUE
10112 CONTINUE
      DO 10141 i=1,30
        DO 10151 j=1,100
          binding_energies(i,j) = 0
10151   CONTINUE
10152   CONTINUE
10141 CONTINUE
10142 CONTINUE
      ibrdst = 1
      ibr_nist = 0
      pair_nrc = 0
      itriplet = 0
      iprdst = 1
      rhof = 1
      DO 10161 i=1,5
        iausfl(i) = 1
10161 CONTINUE
10162 CONTINUE
      DO 10171 i=6,35
        iausfl(i) = 0
10171 CONTINUE
10172 CONTINUE
      ximax = 0.5
      estepe = 0.25
      skindepth_for_bca = 3
      transport_algorithm = 0
      bca_algorithm = 0
      exact_bca = .true.
      spin_effects = .true.
      count_pII_steps = 0
      count_all_steps = 0
      radc_flag = 0
      nmed = 1
      kmpi = 12
      kmpo = 8
      dunit = 1
      rng_seed = 999999
      latchi = 0
      rmt2 = 2*rm
      rmsq = rm*rm
      pi = 4*datan(1d0)
      twopi = 2*pi
      pi5d2 = 2.5*pi
      nbr_split = 1
      i_play_RR = 0
      i_survived_RR = 0
      prob_RR = -1
      n_RR_warning = 0
      DO 10181 i=1,len(hen_house)
        hen_house(i:i) = ' '
10181 CONTINUE
10182 CONTINUE
      i = lnblnk1('/home/miia/EGSnrc/HEN_HOUSE/')
      hen_house(:i) = '/home/miia/EGSnrc/HEN_HOUSE/'
      IF (( '/' .NE. fool_dec )) THEN
        DO 10191 j=1,i
          IF((hen_house(j:j) .EQ. '/'))hen_house(j:j) = '/'
10191   CONTINUE
10192   CONTINUE
      END IF
      IF((hen_house(i:i) .NE. '/'))hen_house(i+1:i+1) = '/'
      n_files = 0
      DO 10201 i=1,len(egs_home)
        egs_home(i:i) = ' '
10201 CONTINUE
10202 CONTINUE
      call getenv('EGS_HOME',egs_home)
      i = lnblnk1(egs_home)
      IF (( '/' .NE. fool_dec )) THEN
        DO 10211 j=1,i
          IF((egs_home(j:j) .EQ. '/'))egs_home(j:j) = '/'
10211   CONTINUE
10212   CONTINUE
      END IF
      IF((i .GT. 0 .AND. egs_home(i:i) .NE. '/'))egs_home(i+1:i+1) = '/'
      DO 10221 i=1,len(input_file)
        input_file(i:i) = ' '
10221 CONTINUE
10222 CONTINUE
      DO 10231 i=1,len(output_file)
        output_file(i:i) = ' '
10231 CONTINUE
10232 CONTINUE
      DO 10241 i=1,len(work_dir)
        work_dir(i:i) = ' '
10241 CONTINUE
10242 CONTINUE
      DO 10251 i=1,len(pegs_file)
        pegs_file(i:i) = ' '
10251 CONTINUE
10252 CONTINUE
      DO 10261 i=1,len(host_name)
        host_name(i:i) = ' '
10261 CONTINUE
10262 CONTINUE
      n_parallel = 0
      i_parallel = 0
      n_chunk = 0
      is_batch = .false.
      first_parallel = 1
      return
      end
      subroutine egs_combine_runs(combine_routine,extension)
      implicit none
      external combine_routine
      character*(*) extension
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*1024 tmp_string,base,command,outfile,parfile_name,base1,
     * text_string
      integer lnblnk1,istat,ipar,egs_system,egs_open_file
      integer*4 i,k,j,numparfiles,textindex
      logical ex,iwin
      iwin=.false.
      DO 10271 i=1,len(base)
        base(i:i) = ' '
10271 CONTINUE
10272 CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e)) // '/' // output_file(:lnblnk1(output_file)) // '_w'
      DO 10281 i=1,len(base1)
        base1(i:i) = ' '
10281 CONTINUE
10282 CONTINUE
      base1 = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_co
     *de)) // '/' // output_file(:lnblnk1(output_file)) // '_w*' // exte
     *nsion(:lnblnk1(extension))
      DO 10291 i=1,len(outfile)
        outfile(i:i) = ' '
10291 CONTINUE
10292 CONTINUE
      outfile = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_
     *code)) // '/' // 'parfiles_tmp'
      DO 10301 i=1,len(command)
        command(i:i) = ' '
10301 CONTINUE
10302 CONTINUE
      command = 'ls ' // base1(:lnblnk1(base1)) // ' | wc -l > ' // outf
     *ile(:lnblnk1(outfile))
      istat = egs_system(command(:lnblnk1(command)))
      IF ((istat.NE.0)) THEN
        command = 'dir ' // base1(:lnblnk1(base1)) // ' | find "File(s)"
     * > ' // outfile(:lnblnk1(outfile))
        istat = egs_system(command(:lnblnk1(command)))
        IF ((istat.NE.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) ' Failed to write number of output files from p
     *arallel runs.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        ELSE
          iwin=.true.
        END IF
      END IF
      ipar=1
      ipar=egs_open_file(ipar,0,1,outfile(:lnblnk1(outfile)))
      IF ((iwin)) THEN
        read(ipar,'(a)',err=10310,end=10310) text_string
        text_string = text_string(:lnblnk1(text_string))
        textindex = index(text_string,'File(s)')
        text_string = text_string(:textindex-1)
        read(text_string,'(i256)',err=10310) numparfiles
      ELSE
        read(ipar,'(i256)',err=10310,end=10310) numparfiles
      END IF
      close(ipar)
      DO 10321 i=1,len(command)
        command(i:i) = ' '
10321 CONTINUE
10322 CONTINUE
      IF ((iwin)) THEN
        command = 'del /Q ' // outfile(:lnblnk1(outfile))
      ELSE
        command = 'rm -f ' // outfile(:lnblnk1(outfile))
      END IF
      istat = egs_system(command(:lnblnk1(command)))
      IF ((istat.NE.0)) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Failed to delete list of output files from para
     *llel runs.'
      END IF
      k=1
      j=1
10331 IF(j.GT.numparfiles)GO TO 10332
        DO 10341 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
10341   CONTINUE
10342   CONTINUE
        tmp_string = base(:lnblnk1(base))
        call egs_itostring(tmp_string,k,.false.)
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // extension(:lnbl
     *  nk1(extension))
        inquire(file=tmp_string,exist=ex)
        IF (( ex )) THEN
          call combine_routine(tmp_string)
          j=j+1
        END IF
        k=k+1
      GO TO 10331
10332 CONTINUE
      return
10310 write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' Failed to read number of output files from parall
     *el runs.'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      logical function egs_strip_extension(filen,fext)
      implicit none
      character*(*) filen,fext
      integer l1,l2,lnblnk1,i
      l1 = lnblnk1(filen)
      l2 = lnblnk1(fext)
      IF (( l1 .GE. l2 .AND. filen(l1-l2+1:l1) .EQ. fext(:l2) )) THEN
        egs_strip_extension = .true.
        DO 10351 i=l1-l2+1,len(filen)
          filen(i:i) = ' '
10351   CONTINUE
10352   CONTINUE
      ELSE
        egs_strip_extension = .false.
      END IF
      return
      end
      logical function egs_is_absolute_path(fn)
      implicit none
      character*(*) fn
      integer i,lnblnk1
      DO 10361 i=1,lnblnk1(fn)
        IF (( fn(i:i) .EQ. '/' )) THEN
          egs_is_absolute_path = .true.
          return
        END IF
10361 CONTINUE
10362 CONTINUE
      egs_is_absolute_path = .false.
      return
      end
      integer function egs_get_unit(iunit)
      implicit none
      integer*4 iunit, i
      logical is_open
      IF (( iunit .GT. 0 )) THEN
        inquire(iunit,opened=is_open)
        IF (( .NOT.is_open )) THEN
          egs_get_unit = iunit
          return
        END IF
      END IF
      DO 10371 i=1,99
        inquire(i,opened=is_open)
        IF (( .NOT.is_open )) THEN
          egs_get_unit = i
          return
        END IF
10371 CONTINUE
10372 CONTINUE
      egs_get_unit = -1
      return
      end
      integer function egs_open_file(iunit,rl,action,extension)
      implicit none
      integer*4 iunit, rl, action
      character*(*) extension
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      logical egs_is_absolute_path,is_open
      integer egs_get_unit
      integer i,lnblnk1
      character*1024 tmp_string,error_string
      integer*4 the_unit
      egs_open_file = -1
      the_unit = egs_get_unit(iunit)
      IF (( the_unit .LT. 0 )) THEN
        IF (( action .EQ. 0 )) THEN
          egs_open_file = -1
          return
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'No free Fortran I/O units left'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( egs_is_absolute_path(extension) )) THEN
        inquire(file=extension,opened=is_open)
        IF ((is_open)) THEN
          inquire(file=extension,number=the_unit)
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,'(a,a,/,a,i3,/,a,/,a)') 'File ',extension(:lnblnk1
     *    (extension)), ' is already opened and connected to unit ',the_
     *    unit, ' Will not try to re-open this file, assuming it has bee
     *n opened', ' by the .io file.'
        ELSE IF(( rl .EQ. 0 )) THEN
          open(the_unit,file=extension,status='unknown')
        ELSE
          open(the_unit,file=extension,status='unknown',form='unformatte
     *d', access='direct', recl=rl)
        END IF
        egs_open_file = the_unit
        return
      END IF
      DO 10381 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
10381 CONTINUE
10382 CONTINUE
      tmp_string = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(us
     *er_code)) // '/' // work_dir(:lnblnk1(work_dir)) // output_file(:l
     *nblnk1(output_file))
      IF (( i_parallel .GT. 0 )) THEN
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // '_w'
        call egs_itostring(tmp_string,i_parallel,.false.)
      END IF
      tmp_string = tmp_string(:lnblnk1(tmp_string)) // extension(:lnblnk
     *1(extension))
      inquire(file=tmp_string,opened=is_open)
      IF ((is_open)) THEN
        inquire(file=tmp_string,number=the_unit)
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,'(a,a,/,a,i3,/,a,/,a,/)') 'File ',tmp_string(:lnblnk
     *  1(tmp_string)), ' is already opened and connected to unit ',the_
     *  unit, ' Will not try to re-open this file, assuming it has been
     *opened', ' by specifying it in the .io file.'
      ELSE IF(( rl .EQ. 0 )) THEN
        open(the_unit,file=tmp_string,status='unknown',err=10390)
      ELSE
        open(the_unit,file=tmp_string,status='unknown',form='unformatted
     *', access='direct', recl=rl,err=10390)
      END IF
      egs_open_file = the_unit
      return
10390 error_string = 'In egs_open_file: failed to open file ' // tmp_str
     *ing(:lnblnk1(tmp_string)) // char(10) // 'iunit = '
      call egs_itostring(error_string,iunit,.false.)
      error_string = error_string(:lnblnk1(error_string)) // ' the_unit
     *= '
      call egs_itostring(error_string,the_unit,.false.)
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a)') error_string(:lnblnk1(error_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      integer function egs_open_datfile(iunit,rl,action,extension)
      implicit none
      integer*4 iunit,rl,action
      character*(*) extension
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer i,the_unit,lnblnk1,egs_get_unit
      logical egs_is_absolute_path
      character base*1024, fn*1024
      egs_open_datfile = -1
      the_unit = egs_get_unit(iunit)
      IF (( the_unit .LT. 0 )) THEN
        IF (( action .EQ. 0 )) THEN
          egs_open_datfile = -1
          return
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'No free Fortran I/O units left'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( egs_is_absolute_path(extension) )) THEN
        IF (( rl .EQ. 0 )) THEN
          open(the_unit,file=extension,status='old',err=10400)
        ELSE
          open(the_unit,file=extension,status='old',form='unformatted',
     *    access='direct',recl=rl,err=10400)
        END IF
        egs_open_datfile = the_unit
        return
10400   CONTINUE
        IF (( action .EQ. 0 )) THEN
          egs_open_datfile = -2
          return
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Failed to open file ',extension(:lnblnk1(extensi
     *  on))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      DO 10411 i=1,len(base)
        base(i:i) = ' '
10411 CONTINUE
10412 CONTINUE
      DO 10421 i=1,len(fn)
        fn(i:i) = ' '
10421 CONTINUE
10422 CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e)) // '/'
      IF (( i_parallel .GT. 0 )) THEN
        fn = base(:lnblnk1(base)) // output_file(:lnblnk1(output_file))
     *  // '_w'
        call egs_itostring(fn,i_parallel,.false.)
        fn = fn(:lnblnk1(fn)) // extension(:lnblnk1(extension))
      ELSE
        fn = base(:lnblnk1(base)) // output_file(:lnblnk1(output_file))
     *  // extension(:lnblnk1(extension))
      END IF
      IF (( rl .EQ. 0 )) THEN
        open(the_unit,file=fn,status='old',err=10430)
      ELSE
        open(the_unit,file=fn,status='old',form='unformatted',access='di
     *rect', recl=rl,err=10430)
      END IF
      egs_open_datfile = the_unit
      return
10430 CONTINUE
      write(i_log,'(/a)') '***************** Warning: '
      write(i_log,'(a,a)') 'Failed to open ',fn(:lnblnk1(fn))
      DO 10441 i=1,len(fn)
        fn(i:i) = ' '
10441 CONTINUE
10442 CONTINUE
      IF (( i_parallel .GT. 0 )) THEN
        fn = base(:lnblnk1(base)) // input_file(:lnblnk1(input_file)) //
     *   '_w'
        call egs_itostring(fn,i_parallel,.false.)
        fn = fn(:lnblnk1(fn)) // extension(:lnblnk1(extension))
      ELSE
        fn = base(:lnblnk1(base)) // input_file(:lnblnk1(input_file)) //
     *   extension(:lnblnk1(extension))
      END IF
      IF (( rl .EQ. 0 )) THEN
        open(the_unit,file=fn,status='old',err=10450)
      ELSE
        open(the_unit,file=fn,status='old',form='unformatted',access='di
     *rect', recl=rl,err=10450)
      END IF
      egs_open_datfile = the_unit
      return
10450 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Failed to open data file'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      integer function egs_open_file_junk(iunit,do_it_anyway,filen)
      implicit none
      integer*4 iunit
      logical do_it_anyway
      character*(*) filen
      logical aux
      integer*4 the_unit,i
      inquire(file=filen,exist=aux)
      IF (( .NOT.aux )) THEN
        egs_open_file_junk = -2
        return
      END IF
      IF (( iunit .LT. 0 )) THEN
        the_unit = -iunit
      ELSE
        the_unit = iunit
      END IF
      IF (( the_unit .NE. 0 )) THEN
        inquire(unit=the_unit,opened=aux)
        IF (( aux )) THEN
          IF (( .NOT.do_it_anyway )) THEN
            egs_open_file_junk = -4
            return
          END IF
          IF((iunit .LT. 0))the_unit = 0
        END IF
      END IF
      IF (( the_unit .EQ. 0 )) THEN
        DO 10461 i=1,99
          inquire(unit=i,opened=aux)
          IF (( .NOT.aux )) THEN
            the_unit = i
            GO TO10462
          END IF
10461   CONTINUE
10462   CONTINUE
        IF (( the_unit .EQ. 0 )) THEN
          egs_open_file_junk = -1
          return
        END IF
      END IF
      open(the_unit,file=filen,status='old',err=10470)
      egs_open_file_junk = the_unit
      return
10470 egs_open_file_junk = -3
      return
      end
      subroutine egs_strip_path(fname)
      implicit none
      character*(*) fname
      integer i,l,l1,lnblnk1,j
      character slash
      slash = '/'
      l = lnblnk1(fname)
      DO 10481 i=1,l
        IF (( fname(i:i) .EQ. slash )) THEN
          fname(i:i) = '/'
        END IF
10481 CONTINUE
10482 CONTINUE
      DO 10491 i=l,1,-1
        IF (( fname(i:i) .EQ. '/' .OR. fname(i:i) .EQ. slash )) THEN
          l1 = l-i
          fname(:l1) = fname(i+1:l)
          DO 10501 j=l1+1,len(fname)
            fname(j:j) = ' '
10501     CONTINUE
10502     CONTINUE
          return
        END IF
10491 CONTINUE
10492 CONTINUE
      return
      end
      subroutine replace_env(fname)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*(*) fname
      character*256 dirname
      integer indsep,ind1,ind2
      indsep = index(fname,'/')
      IF((indsep .LE. 0))return
      ind1=index(fname,'$')
      ind2=index(fname,'~')
      IF ((ind1.EQ.1)) THEN
        call getenv(fname(2:indsep-1),dirname)
        IF ((dirname.EQ.' ')) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,a/,a)') ' Error in file name: ',fname(:lnblnk1
     *    (fname)), ' First element in name does not specify a defined e
     *nvironment variable.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        fname=dirname(:lnblnk1(dirname))//fname(indsep:)
        write(i_log,'(//a,a/)') ' Retrieving file: ',fname(:lnblnk1(fnam
     *  e))
      ELSE IF((ind2.EQ.1)) THEN
        call getenv('HOME',dirname)
        IF ((dirname.EQ.' ')) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,a/,a)') ' Error in file name: ',fname(:lnblnk1
     *    (fname)), ' HOME is undefined.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        fname=dirname(:lnblnk1(dirname))//fname(indsep:)
        write(i_log,'(//a,a/)') ' Retrieving file: ',fname(:lnblnk1(fnam
     *  e))
      END IF
      return
      end
      subroutine egs_get_usercode(ucode)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*(*) ucode
      character*512 arg
      integer l,l1,lnblnk1,i
      call getarg(0,arg)
      call egs_strip_path(arg)
      l = lnblnk1(arg)
      IF (( arg(l-3:l) .EQ. '.exe' )) THEN
        arg(l-3:l) = ' '
        l = l - 4
      END IF
      IF (( arg(l-5:l) .EQ. '_debug' )) THEN
        arg(l-5:l) = ' '
        l = l-5
      END IF
      IF (( arg(l-5:l) .EQ. '_noopt' )) THEN
        arg(l-5:l) = ' '
        l = l-5
      END IF
      l1 = len(ucode)
      IF (( l .GT. l1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' user code name is too long (',l,' chars)'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      DO 10511 i=1,len(ucode)
        ucode(i:i) = ' '
10511 CONTINUE
10512 CONTINUE
      ucode(:l) = arg(:l)
      return
      end
      subroutine egs_itostring(string,i,leave_space)
      implicit none
      character*(*) string
      integer*4 i
      integer l,lnblnk1,idiv,itmp,iaux
      logical first,leave_space
      l = lnblnk1(string)+1
      IF((l .GT. 1 .AND. leave_space))l=l+1
      idiv = 1000000000
      itmp = i
      first = .false.
      do while(idiv.gt.0)
      iaux = itmp/idiv
      IF (( (iaux .GT. 0 .OR. first ) .AND. l .LE. len(string) )) THEN
        string(l:l) = char(iaux+48)
        first = .true.
        l = l+1
      END IF
      itmp = itmp - iaux*idiv
      idiv = idiv/10
      end do
      return
      end
      real*8 function egs_rndm()
      implicit none
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      IF((rng_seed .GT. 128))call ranmar_get
      egs_rndm = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      return
      end
      integer function egs_add_medium(medname)
      implicit none
      character*(*) medname
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,l,imed,medname_len
      character c
      logical same
      l = min(len(medname),24)
      medname_len = l
      DO 10521 i=1,l
        c = medname(i:i)
        IF (( ichar(c) .EQ. 0 )) THEN
          medname_len = i-1
          GO TO10522
        END IF
10521 CONTINUE
10522 CONTINUE
      DO 10531 imed=1,nmed
        l = 24
        DO 10541 i=1,24
          IF (( media(i,imed)(1:1) .EQ. ' ' )) THEN
            l = i-1
            GO TO10542
          END IF
10541   CONTINUE
10542   CONTINUE
        IF (( l .EQ. medname_len )) THEN
          same = .true.
          DO 10551 i=1,l
            c = medname(i:i)
            IF (( c .NE. media(i,imed)(1:1) )) THEN
              same = .false.
              GO TO10552
            END IF
10551     CONTINUE
10552     CONTINUE
          IF (( same )) THEN
            egs_add_medium = imed
            return
          END IF
        END IF
10531 CONTINUE
10532 CONTINUE
      nmed = nmed + 1
      IF (( nmed .GT. 10 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(a,/,a,i3,a)') 'In egs_add_medium: maximum number o
     *f media exceeded ', 'Increase the macro $MXMED (currently ',10,')
     *and retry'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      l = min(len(medname),24)
      DO 10561 i=1,l
        c = medname(i:i)
        IF (( ichar(c) .EQ. 0 )) THEN
          l = i-1
          GO TO10562
        END IF
        media(i,nmed) = ' '
        media(i,nmed)(1:1) = c
10561 CONTINUE
10562 CONTINUE
      IF (( l .LT. 24 )) THEN
        DO 10571 i=l+1,24
          media(i,nmed) = ' '
10571   CONTINUE
10572   CONTINUE
      END IF
      egs_add_medium = nmed
      return
      end
      subroutine egs_get_medium_name(imed,medname)
      implicit none
      character*(*) medname
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,l,imed
      DO 10581 i=1,len(medname)
        medname(i:i) = ' '
10581 CONTINUE
10582 CONTINUE
      IF (( imed .LT. 1 .OR. imed .GT. nmed )) THEN
        return
      END IF
      l = 24
      DO 10591 l=24,1,-1
        IF((media(l,imed)(1:1) .NE. ' '))GO TO10592
10591 CONTINUE
10592 CONTINUE
      l = min(l,len(medname))
      DO 10601 i=1,l
        medname(i:i) = media(i,imed)(1:1)
10601 CONTINUE
10602 CONTINUE
      return
      end
      subroutine egs_get_electron_data(func,imed,which)
      implicit none
      integer*4 imed,which
      external func
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 lemin,lemax
      lemin = (1 - eke0(imed))/eke1(imed)
      lemax = (meke(imed) - eke0(imed))/eke1(imed)
      IF (( which .EQ. 1 )) THEN
        call func(meke(imed),lemin,lemax,esig0(1,imed),esig1(1,imed))
      ELSE IF(( which .EQ. 2 )) THEN
        call func(meke(imed),lemin,lemax,psig0(1,imed),psig1(1,imed))
      ELSE IF(( which .EQ. 3 )) THEN
        call func(meke(imed),lemin,lemax,ededx0(1,imed),ededx1(1,imed))
      ELSE IF(( which .EQ. 4 )) THEN
        call func(meke(imed),lemin,lemax,pdedx0(1,imed),pdedx1(1,imed))
      ELSE IF(( which .EQ. 5 )) THEN
        call func(meke(imed),lemin,lemax,ebr10(1,imed),ebr11(1,imed))
      ELSE IF(( which .EQ. 6 )) THEN
        call func(meke(imed),lemin,lemax,pbr10(1,imed),pbr11(1,imed))
      ELSE IF(( which .EQ. 7 )) THEN
        call func(meke(imed),lemin,lemax,pbr20(1,imed),pbr21(1,imed))
      ELSE IF(( which .EQ. 8 )) THEN
        call func(meke(imed),lemin,lemax,tmxs0(1,imed),tmxs1(1,imed))
      ELSE IF(( which .EQ. 9 )) THEN
        call func(meke(imed),lemin,lemax,range_ep(0,1,imed),range_ep(1,1
     *  ,imed))
      ELSE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Unknown electron data type ',which
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      return
      end
      subroutine egs_get_photon_data(func,imed,which)
      implicit none
      integer*4 imed,which
      external func
      COMMON/PHOTIN/ EBINDA(10), GE0(10),GE1(10), GMFP0(2000,10),GMFP1(2
     *000,10),GBR10(2000,10),GBR11(2000,10),GBR20(2000,10),GBR21(2000,10
     *), RCO0(10),RCO1(10), RSCT0(100,10),RSCT1(100,10), COHE0(2000,10),
     *COHE1(2000,10),  PHOTONUC0(2000,10),PHOTONUC1(2000,10), DPMFP, MPG
     *EM(1,10), NGR(10)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 lemin,lemax
      lemin = (1 - ge0(imed))/ge1(imed)
      lemax = (mge(imed) - ge0(imed))/ge1(imed)
      IF (( which .EQ. 1 )) THEN
        call func(mge(imed),lemin,lemax,gmfp0(1,imed),gmfp1(1,imed))
      ELSE IF(( which .EQ. 2 )) THEN
        call func(mge(imed),lemin,lemax,gbr10(1,imed),gbr11(1,imed))
      ELSE IF(( which .EQ. 3 )) THEN
        call func(mge(imed),lemin,lemax,gbr20(1,imed),gbr21(1,imed))
      ELSE IF(( which .EQ. 4 )) THEN
        call func(mge(imed),lemin,lemax,cohe0(1,imed),cohe1(1,imed))
      ELSE IF(( which .EQ. 5 )) THEN
        call func(mge(imed),lemin,lemax,PHOTONUC0(1,imed),PHOTONUC1(1,im
     *  ed))
      ELSE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Unknown photon data type ',which
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      return
      end
      subroutine egs_print_binding_energies
      implicit none
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,j
      integer*4 lnblnk1
      character*3 labels(16)
      data labels/'  K',' L1',' L2',' L3', ' M1',' M2',' M3',' M4',' M5'
     *, ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/
      write(i_log,'(a,a,a)') 'Binding energies from ',photon_xsections(:
     *lnblnk1(photon_xsections)), ' photon cross section library'
      DO 10611 j=1,100
        DO 10621 i=1,16
          IF (( binding_energies(i,j) .GT. 0 )) THEN
            write(i_log,'(a,i3,a,a,a,1pe12.4,a)') ' Eb(',j,',',labels(i)
     *      ,') = ',binding_energies(i,j),' MeV'
          END IF
10621   CONTINUE
10622   CONTINUE
10611 CONTINUE
10612 CONTINUE
      return
      end
      subroutine egs_scale_xcc(imed,factor)
      implicit none
      integer*4 imed
      real*8 factor
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      IF (( imed .GT. 0 .AND. imed .LE. nmed )) THEN
        xcc(imed) = xcc(imed)*factor
      END IF
      return
      end
      subroutine egs_write_string(ounit,string)
      implicit none
      integer*4 ounit
      character*(*) string
      write(ounit,'(a,$)') string
      call flush(ounit)
      return
      end
      subroutine egs_swap_2(c)
      character c(2),tmp
      tmp=c(2)
      c(2)=c(1)
      c(1)=tmp
      return
      end
      subroutine egs_swap_4(c)
      character c(4),tmp
      tmp=c(4)
      c(4)=c(1)
      c(1)=tmp
      tmp=c(3)
      c(3)=c(2)
      c(2)=tmp
      return
      end
      subroutine set_spline(x,f,a,b,c,d,n)
      implicit none
      integer*4 n
      real*8 x(n),f(n),a(n),b(n),c(n),d(n)
      integer*4 m1,m2,m,mr
      real*8 s,r
      m1 = 2
      m2 = n-1
      s = 0
      DO 10631 m=1,m2
        d(m) = x(m+1) - x(m)
        r = (f(m+1) - f(m))/d(m)
        c(m) = r - s
        s = r
10631 CONTINUE
10632 CONTINUE
      s=0
      r=0
      c(1)=0
      c(n)=0
      DO 10641 m=m1,m2
        c(m) = c(m) + r*c(m-1)
        b(m) = 2*(x(m-1) - x(m+1)) - r*s
        s = d(m)
        r = s/b(m)
10641 CONTINUE
10642 CONTINUE
      mr = m2
      DO 10651 m=m1,m2
        c(mr) = (d(mr)*c(mr+1) - c(mr))/b(mr)
        mr = mr - 1
10651 CONTINUE
10652 CONTINUE
      DO 10661 m=1,m2
        s = d(m)
        r = c(m+1) - c(m)
        d(m) = r/s
        c(m) = 3*c(m)
        b(m) = (f(m+1)-f(m))/s - (c(m)+r)*s
        a(m) = f(m)
10661 CONTINUE
10662 CONTINUE
      return
      end
      real*8 function spline(s,x,a,b,c,d,n)
      implicit none
      integer*4 n
      real*8 s,x(n),a(n),b(n),c(n),d(n)
      integer m_lower,m_upper,direction,m,ml,mu,mav
      real*8 q
      IF (( x(1) .GT. x(n) )) THEN
        direction = 1
        m_lower = n
        m_upper = 0
      ELSE
        direction = 0
        m_lower = 0
        m_upper = n
      END IF
      IF (( s .GE. x(m_upper + direction) )) THEN
        m = m_upper + 2*direction - 1
      ELSE IF(( s .LE. x(m_lower+1-direction) )) THEN
        m = m_lower - 2*direction + 1
      ELSE
        ml = m_lower
        mu = m_upper
10671   IF(iabs(mu-ml).LE.1)GO TO 10672
          mav = (ml+mu)/2
          IF (( s .LT. x(mav) )) THEN
            mu = mav
          ELSE
            ml = mav
          END IF
        GO TO 10671
10672   CONTINUE
        m = mu + direction - 1
      END IF
      q = s - x(m)
      spline = a(m) + q*(b(m) + q*(c(m) + q*d(m)))
      return
      end
      subroutine prepare_alias_table(nsbin,xs_array,fs_array,ws_array,ib
     *in_array)
      implicit none
      integer nsbin
      integer*4 ibin_array(nsbin)
      real*8 xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin)
      integer*4 i,j_l,j_h
      real*8 sum,aux
      sum = 0
      DO 10681 i=1,nsbin
        aux = 0.5*(fs_array(i)+fs_array(i-1))*(xs_array(i)-xs_array(i-1)
     *  )
        IF((aux .LT. 1e-30))aux = 1e-30
        ws_array(i) = -aux
        ibin_array(i) = 1
        sum = sum + aux
10681 CONTINUE
10682 CONTINUE
      sum = sum/nsbin
      DO 10691 i=1,nsbin-1
        DO 10701 j_h=1,nsbin
          IF (( ws_array(j_h) .LT. 0 )) THEN
            IF((abs(ws_array(j_h)) .GT. sum))GOTO 10710
          END IF
10701   CONTINUE
10702   CONTINUE
        j_h = nsbin
10710   CONTINUE
          DO 10711 j_l=1,nsbin
          IF (( ws_array(j_l) .LT. 0 )) THEN
            IF((abs(ws_array(j_l)) .LT. sum))GOTO 10720
          END IF
10711   CONTINUE
10712   CONTINUE
        j_l = nsbin
10720   aux = sum - abs(ws_array(j_l))
        ws_array(j_h) = ws_array(j_h) + aux
        ws_array(j_l) = -ws_array(j_l)/sum
        ibin_array(j_l) = j_h
        IF((i .EQ. nsbin-1))ws_array(j_h) = 1
10691 CONTINUE
10692 CONTINUE
      return
      end
      real*8 function alias_sample1(nsbin,xs_array,fs_array,ws_array,ibi
     *n_array)
      implicit none
      integer nsbin
      integer*4 ibin_array(nsbin)
      real*8 xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin)
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      integer*4 j
      real*8 r1,r2,aj,x,dx,a,rnno1
      IF((rng_seed .GT. 128))call ranmar_get
      r1 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((rng_seed .GT. 128))call ranmar_get
      r2 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      aj = 1 + r1*nsbin
      j = aj
      aj = aj - j
      IF((aj .GT. ws_array(j)))j = ibin_array(j)
      x = xs_array(j-1)
      dx = xs_array(j)-x
      IF (( fs_array(j-1) .GT. 0 )) THEN
        a = fs_array(j)/fs_array(j-1)-1
        IF (( abs(a) .LT. 0.2 )) THEN
          rnno1 = 0.5*(1-r2)*a
          alias_sample1 = x + r2*dx*(1+rnno1*(1-r2*a))
        ELSE
          alias_sample1 = x - dx/a*(1-sqrt(1+r2*a*(2+a)))
        END IF
      ELSE
        alias_sample1 = x + dx*sqrt(r2)
      END IF
      return
      end
      subroutine prepare_alias_histogram(nsbin,ws_array,ibin_array)
      implicit none
      integer*4 nsbin,ibin_array(nsbin)
      real*8 ws_array(nsbin)
      integer*4 i,j_l,j_h
      real*8 sum,aux
      sum = 0
      DO 10731 i=1,nsbin
        sum = sum + ws_array(i)
        ibin_array(i) = -1
10731 CONTINUE
10732 CONTINUE
      sum = sum/nsbin
      DO 10741 i=1,nsbin-1
        DO 10751 j_h=1,nsbin
          IF((ibin_array(j_h) .LT. 0 .AND. ws_array(j_h) .GT. sum))GO TO
     *    10752
10751   CONTINUE
10752   CONTINUE
        DO 10761 j_l=1,nsbin
          IF((ibin_array(j_l) .LT. 0 .AND. ws_array(j_l) .LT. sum))GO TO
     *    10762
10761   CONTINUE
10762   CONTINUE
        aux = sum - ws_array(j_l)
        ws_array(j_h) = ws_array(j_h) - aux
        ws_array(j_l) = ws_array(j_l)/sum
        ibin_array(j_l) = j_h
10741 CONTINUE
10742 CONTINUE
      DO 10771 i=1,nsbin
        IF (( ibin_array(i) .LT. 0 )) THEN
          ibin_array(i) = i
          ws_array(i) = 1
        END IF
10771 CONTINUE
10772 CONTINUE
      return
      end
      integer*4 function sample_alias_histogram(nsbin,ws_array,ibin_arra
     *y)
      implicit none
      integer*4 nsbin,ibin_array(*)
      real*8 ws_array(*)
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      real*8 r1,r2
      integer*4 ibin
      IF((rng_seed .GT. 128))call ranmar_get
      r1 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((rng_seed .GT. 128))call ranmar_get
      r2 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      ibin = 1 + nsbin*r1
      IF((r2 .GT. ws_array(ibin)))ibin = ibin_array(ibin)
      sample_alias_histogram = ibin
      return
      end
      subroutine gauss_legendre(x1,x2,x,w,n)
      implicit none
      integer*4 n
      real*8 x1,x2,x(n),w(n)
      real*8 eps,Pi
      parameter (eps = 3.D-14,Pi=3.141592654D0)
      integer*4 i,m,j
      real*8 xm,xl,z,z1,p1,p2,p3,pp
      m = (n + 1)/2
      xm=0.5d0*(x2+x1)
      xl=0.5d0*(x2-x1)
      DO 10781 i=1,m
        z=cos(Pi*(i-.25d0)/(n+.5d0))
10791   CONTINUE
          p1=1.d0
          p2=0.d0
          DO 10801 j=1,n
            p3 = p2
            p2 = p1
            p1=((2.d0*j-1.d0)*z*p2-(j-1.d0)*p3)/j
10801     CONTINUE
10802     CONTINUE
          pp=n*(z*p1-p2)/(z*z-1.d0)
          z1=z
          z=z1-p1/pp
          IF(((abs(z-z1) .LT. eps)))GO TO10792
        GO TO 10791
10792   CONTINUE
        x(i)=xm-xl*z
        x(n+1-i)=xm+xl*z
        w(i)=2.d0*xl/((1.d0-z*z)*pp*pp)
        w(n+1-i)=w(i)
10781 CONTINUE
10782 CONTINUE
      return
      end
      integer function lnblnk1(string)
      character*(*) string
      integer i
      DO 10811 i=len(string),1,-1
        j = ichar(string(i:i))
        IF (( j .EQ. 0 )) THEN
          lnblnk1 = i-1
          return
        END IF
        IF (( j .NE. 9 .AND. j .NE. 10 .AND. j .NE. 11 .AND. j .NE. 12 .
     *  AND. j .NE. 13 .AND. j .NE. 32 )) THEN
          lnblnk1 = i
          return
        END IF
10811 CONTINUE
10812 CONTINUE
      lnblnk1 = 0
      return
      end
      real*8 FUNCTION ERF1(X)
      implicit none
      real*8 x
      double precision A(0:22,2)
      double precision CONST,  BN,BN1,BN2,  Y,FAC
      integer*4 N,  K,  NLIM(2)
      DATA A/ 1.0954712997776232 , -0.2891754011269890 , 0.1104563986337
     *951 , -0.0412531882278565 , 0.0140828380706516 , -0.00432929544743
     *14 , 0.0011982719015923 , -0.0002999729623532 , 0.0000683258603789
     * , -0.0000142469884549 , 0.0000027354087728 , -0.0000004861912872
     *, 0.0000000803872762 , -0.0000000124184183 , 0.0000000017995326 ,
     *-0.0000000002454795 , 0.0000000000316251 , -0.0000000000038590 , 0
     *.0000000000004472 , -0.0000000000000493 , 0.0000000000000052 , -0.
     *0000000000000005 , 0.0000000000000001 , 0.9750834237085559 , -0.02
     *40493938504146 , 0.0008204522408804 , -0.0000434293081303 , 0.0000
     *030184470340 , -0.0000002544733193 , 0.0000000248583530 , -0.00000
     *00027317201 , 0.0000000003308472 , 0.0000000000001464 , -0.0000000
     *000000244 , 0.0000000000000042 , -0.0000000000000008 , 0.000000000
     *0000001 , 9*0.0 /
      DATA NLIM/ 22,16 /
      DATA CONST/ 1.128379167095513 /
      IF (( x .GT. 3 )) THEN
        y = 3/x
        k = 2
      ELSE
        y = x/3
        k = 1
      END IF
      FAC = 2.0 * ( 2.0 * Y*Y - 1.0 )
      BN1 = 0.0
      BN = 0.0
      DO 10821 n=NLIM(K),0,-1
        BN2 = BN1
        BN1 = BN
        BN = FAC * BN1 - BN2 + A(N,K)
10821 CONTINUE
10822 CONTINUE
      IF (( k .EQ. 1 )) THEN
        erf1 = CONST * Y * ( BN - BN1 )
      ELSE
        erf1 = 1 - CONST * EXP(-X**2) * ( BN - BN2 + A(0,K) )/(4.0 * X)
      END IF
      RETURN
      end
      real*8 FUNCTION ZERO()
      implicit none
      integer*4 i
      real*8 x, xtemp
      x = 1.E-20
      DO 10831 i=1,100
        IF ((x .EQ. 0.0)) THEN
          GO TO10832
        ELSE
          xtemp = x
        END IF
        x = x/1.E5
10831 CONTINUE
10832 CONTINUE
      x = xtemp
      DO 10841 i=1,5
        IF ((x .NE. 0.0)) THEN
          xtemp = x
        ELSE
          GO TO10842
        END IF
        x = x/10
10841 CONTINUE
10842 CONTINUE
      x = xtemp
      DO 10851 i=2,10
        IF ((x .NE. 0.0)) THEN
          xtemp = x
        ELSE
          GO TO10852
        END IF
        x = x/i
10851 CONTINUE
10852 CONTINUE
      zero = xtemp
      return
      end
      character*512 function toUpper(a_string)
      character*(*) a_string
      character*512 the_string
      integer*4 cursor, i, lnblnk1
      toUpper = a_string
      the_string = a_string
      DO 10861 i=1,lnblnk1(the_string)
        cursor=ICHAR(the_string(i:i))
        IF (((cursor.GE.97).AND.(cursor.LE.122))) THEN
          cursor=cursor-32
          toUpper(i:i)=CHAR(cursor)
        END IF
10861 CONTINUE
10862 CONTINUE
      return
      end
      integer*1 function egs_read_byte(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      integer*1 i_1
      character c_1
      equivalence (i_1,c_1)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      read(iunit,rec=jrec,IOSTAT=ierr) c_1
      IF ((ierr.ne.0)) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' *** egs_read_byte: ERROR READING A byte *** '
        write(i_log,*) ' From unit ',iunit,' position ',jrec,' bytes'
        egs_read_byte = -1
        return
      END IF
      jrec = jrec + 1
      egs_read_byte = i_1
      return
      end
      integer*2 function egs_read_short(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      integer*2 i_2
      character c_2(2)
      equivalence (i_2,c_2)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      j = 0
      DO 10871 i=jrec,jrec+1
        j = j + 1
        read(iunit,rec=i,IOSTAT=ierr) c_2(j)
        IF ((ierr.ne.0)) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' *** egs_read_short: ERROR READING short integ
     *er *** '
          write(i_log,*) ' From unit ',iunit,' position ',jrec,' bytes'
          egs_read_short = -1
          return
        END IF
10871 CONTINUE
10872 CONTINUE
      jrec = jrec + 2
      egs_read_short = i_2
      return
      end
      integer*4 function egs_read_int(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      integer*4 i_4
      character c_4(4)
      equivalence (i_4,c_4)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      j = 0
      DO 10881 i=jrec,jrec+3
        j = j + 1
        read(iunit,rec=i,IOSTAT=ierr) c_4(j)
        IF ((ierr.ne.0)) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' *** egs_read_int: ERROR READING integer *** '
          write(i_log,*) ' From unit ',iunit,' position ',jrec,' bytes'
          egs_read_int = -1
          return
        END IF
10881 CONTINUE
10882 CONTINUE
      jrec = jrec + 4
      egs_read_int = i_4
      return
      end
      real*4 function egs_read_real(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      real*4 r_4
      character c_4(4)
      equivalence (r_4,c_4)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      j = 0
      DO 10891 i=jrec,jrec+3
        j = j + 1
        read(iunit,rec=i,IOSTAT=ierr) c_4(j)
        IF ((ierr.ne.0)) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' *** egs_read_real: ERROR READING float *** '
          write(i_log,*) ' From unit ',iunit,' position ',jrec,' bytes'
          egs_read_real = -1
          return
        END IF
10891 CONTINUE
10892 CONTINUE
      jrec = jrec + 4
      egs_read_real = r_4
      return
      end
      integer*4 function ibsearch(a, nsh, b)
      implicit none
      real*8 a, b(*)
      integer*4 min,max,help,nsh
      real*8 x
      min = 1
      max = nsh
      x = a
10901 IF(min.GE.max-1)GO TO 10902
        help = (max+min)/2
        IF (( b(help).le.x)) THEN
          min = help
        ELSE
          max = help
        END IF
      GO TO 10901
10902 CONTINUE
      ibsearch = min
      return
      end
#ifdef HAVE_C_COMPILER
      integer*4 function egs_create_lockfile(flag)
      integer*4 flag
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*512 fname
      integer*4 i,lnblnk1,l,istat
      DO 10911 i=1,len(fname)
        fname(i:i) = ' '
10911 CONTINUE
10912 CONTINUE
      fname = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_co
     *de)) // '/' // output_file(:lnblnk1(output_file)) // '.lock'
      l = lnblnk1(fname)+1
      fname(l:l) = char(0)
      call egs_create_control_file(fname,istat)
      IF (( istat .NE. 0 .AND. flag .EQ. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Failed to create a lock file named ',fname(:lnbl
     *  nk1(fname))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      egs_create_lockfile = istat
      return
      end
      integer*4 function egs_open_lockfile(flag)
      integer*4 flag
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*512 fname
      integer*4 i,lnblnk1,l,istat
      DO 10921 i=1,len(fname)
        fname(i:i) = ' '
10921 CONTINUE
10922 CONTINUE
      fname = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_co
     *de)) // '/' // output_file(:lnblnk1(output_file)) // '.lock'
      l = lnblnk1(fname)+1
      fname(l:l) = char(0)
      call egs_open_control_file(fname,istat)
      IF (( istat .NE. 0 .AND. flag .EQ. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Failed to open the lock file named ',fname(:lnbl
     *  nk1(fname))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      egs_open_lockfile = istat
      return
      end
      subroutine egs_remove_lockfile(istat)
      integer*4 istat
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*512 fname
      integer*4 i,lnblnk1,l
      DO 10931 i=1,len(fname)
        fname(i:i) = ' '
10931 CONTINUE
10932 CONTINUE
      fname = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_co
     *de)) // '/' // output_file(:lnblnk1(output_file)) // '.lock'
      l = lnblnk1(fname)+1
      fname(l:l) = char(0)
      call egs_remove_file(fname,istat)
      return
      end
      subroutine egs_pjob_control(ncase,n_run,n_left,n_tot,sum,sum2,res,
     *dres)
      implicit none
      integer*8 ncase,n_run,n_tot
      real*8 sum,sum2,res,dres
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/my_times/ t_elapsed, t_cpu, t_first
      real*8 t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      integer*8 n_last,n_left,nn_tot
      integer t_dum(8)
      integer*4 i,lnblnk1,n_write,n_read,istat,n_job
      integer*4 egs_create_lockfile, egs_open_lockfile
      real*8 tmp,tmp2
      logical first_time
      character control_string*256
      data first_time/.true./
      save first_time,n_last
      IF (( n_parallel .LE. 0 )) THEN
        n_run = ncase
        return
      END IF
      IF((first_time))n_last = 0
      DO 10941 i=1,len(control_string)
        control_string(i:i) = ' '
10941 CONTINUE
10942 CONTINUE
      n_run = ncase/n_parallel/10
      n_left = ncase
      IF (( first_time )) THEN
        IF((n_run .GT. n_left))n_run = n_left
        n_left = ncase - n_run
        IF (( i_parallel .EQ. first_parallel )) THEN
          istat = egs_create_lockfile(1)
          IF (( n_tot .GT. 1 )) THEN
            res = sum/n_tot
            dres = sum2/n_tot - res*res
            IF (( res .GT. 0 .AND. dres .GT. 0 )) THEN
              dres = sqrt(dres/(n_tot-1))/res*100
            ELSE
              dres = 99.9
            END IF
          ELSE
            res = 0
            dres = 99.9
          END IF
          write(control_string,'(2i15,i4,2(1pe16.8),1pe13.5,0pf7.2,2x,8i
     *5)') n_left,n_tot,1,sum,sum2,res,dres,(t_first(i),i=1,8)
          n_write = lnblnk1(control_string) + 1
          call egs_write_control_file(control_string,n_write,istat)
          IF (( istat .NE. n_write )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'job 1: failed to write to lock file ',n_writ
     *      e,istat
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          call egs_unlock_control_file(istat)
          IF (( istat .NE. 0 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'job 1: failed to unlock the file ',istat
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          first_time = .false.
          n_max_parallel = 1
          n_last = n_run
          return
        END IF
        istat = egs_open_lockfile(1)
      END IF
      call egs_rewind_control_file(istat)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'job ',i_parallel,': failed to rewind or lock the
     * control ', 'file', istat
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      n_read = len(control_string)
      call egs_read_control_file(control_string,n_read,istat)
      read(control_string,*,err=10950) n_left,nn_tot,n_job,tmp,tmp2, res
     *,dres,(t_dum(i),i=1,8)
      nn_tot = nn_tot + n_last
      tmp = tmp + sum
      tmp2 = tmp2 + sum2
      IF (( first_time )) THEN
        first_time = .false.
        n_job = n_job + 1
        nn_tot = nn_tot + n_tot
      END IF
      n_tot = nn_tot
      IF (( n_tot .GT. 1 )) THEN
        res = tmp/n_tot
        dres = tmp2/n_tot - res*res
        IF (( res .GT. 0 .AND. dres .GT. 0 )) THEN
          dres = sqrt(dres/(n_tot-1))/res*100
        ELSE
          dres = 99.9
        END IF
      ELSE
        res = 0
        dres = 99.9
      END IF
      IF (( n_run .GT. n_left )) THEN
        n_run = n_left
        n_left = 0
      ELSE
        n_left = n_left - n_run
      END IF
      n_last = n_run
      DO 10961 i=1,len(control_string)
        control_string(i:i) = ' '
10961 CONTINUE
10962 CONTINUE
      write(control_string,'(2i15,i4,2(1pe16.8),1pe13.5,0pf7.2,2x,8i5)')
     * n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_dum(i),i=1,8)
      call egs_rewind_control_file(istat)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'job ',i_parallel,': failed to rewind or lock the
     * control ', 'file', istat
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      n_write = lnblnk1(control_string) + 1
      call egs_write_control_file(control_string,n_write,istat)
      IF (( istat .NE. n_write )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'job ',i_parallel,': failed to write to lock file
     * ', n_write,istat
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      call egs_unlock_control_file(istat)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'job ',i_parallel,': failed to unlock the file ',
     *  istat
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF((n_job .GT. n_max_parallel))n_max_parallel = n_job
      return
10950 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,/a)') 'Failed to read from job control file: got '
     *, control_string(:lnblnk1(control_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_pjob_finish(n_job)
      implicit none
      integer*4 n_job
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/my_times/ t_elapsed, t_cpu, t_first
      real*8 t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      integer*4 istat,i,lnblnk1,n_read,n_write
      integer*8 n_left,n_tot
      integer t_start(8),t_end(8)
      real*8 tmp,tmp2,res,dres,t_run
      real egs_time_diff
      character control_string*256
      call egs_rewind_control_file(istat)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'job ',i_parallel,': failed to rewind or lock the
     * control ', 'file', istat
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      n_read = len(control_string)
      call egs_read_control_file(control_string,n_read,istat)
      read(control_string,*,end=10970,err=10970) n_left,n_tot,n_job,tmp,
     *tmp2,res,dres,(t_start(i),i=1,8)
      n_job = n_job - 1
      IF (( n_job .GT. 0 )) THEN
        DO 10981 i=1,len(control_string)
          control_string(i:i) = ' '
10981   CONTINUE
10982   CONTINUE
        write(control_string,'(2i15,i4,2(1pe16.8),1pe13.5,0pf7.2,2x,8i5)
     *') n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_start(i),i=1,8)
        call egs_rewind_control_file(istat)
        IF (( istat .NE. 0 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'job ',i_parallel,': failed to rewind or lock t
     *he ', 'control file, error was:', istat
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        n_write = lnblnk1(control_string) + 1
        call egs_write_control_file(control_string,n_write,istat)
        IF (( istat .NE. n_write )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'job ',i_parallel,': failed to write to lock fi
     *le ', n_write,istat
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        call egs_unlock_control_file(istat)
        call egs_close_control_file(istat)
        return
      END IF
      call egs_close_control_file(istat)
      call egs_remove_lockfile(istat)
      i_parallel = 0
      call egs_open_units(.false.)
      call egs_date_and_time(t_end)
      t_run = egs_time_diff(t_start,t_end)
      write(i_log,'(/a/,a,t55,i3/,a,t55,i3/,a,f9.1,a,f9.4,a/,a//)') '***
     ************** finished parallel execution ******************', ' n
     *umber of parallel jobs requested: ',n_parallel, ' max. number of j
     *obs executing simultaneously: ',n_max_parallel, ' elapsed time sin
     *ce first job started: ',t_run,' s (',t_run/3600,' h)', '**********
     ******************************************************'
      return
10970 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,/a)') 'In egs_pjob_finish: failed to read from con
     *trol string ', control_string(:lnblnk1(control_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
#endif
      SUBROUTINE EFUNS(E,V)
      implicit none
      real*4 E,V(8)
      real*4 BREM,AMOLL,BHAB,ANNIH,ESIG,PSIG
      real*4 BREMTM,AMOLTM,BHABTM,ANIHTM,SPTOTE,SPTOTP,TMXS,THBREM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      THBREM=RMP+APP
      IF ((IUNRSTP.EQ.0 .OR. IUNRSTP.EQ.1 .OR. IUNRSTP.EQ.5)) THEN
        BREM=BREMTM(E)
        AMOLL=AMOLTM(E)
        BHAB=BHABTM(E)
        ANNIH=ANIHTM(E)
        ESIG=BREM+AMOLL
        V(1)=ESIG
        PSIG=BREM+BHAB+ANNIH
        V(2)=PSIG
        V(3)=SPTOTE(E,AEP,APP)
        V(4)=SPTOTP(E,AEP,APP)
        IF ((ESIG.GT.0.0)) THEN
          V(5)=BREM/ESIG
        ELSE
          IF ((THBREM.LE.THMOLLP)) THEN
            V(5)=1.0
          ELSE
            V(5)=0.0
          END IF
        END IF
        V(6)=BREM/PSIG
        V(7)=(BREM+BHAB)/PSIG
        V(8)=TMXS(E)
      ELSE IF((IUNRSTP.EQ.2)) THEN
        V(1)=0.0
        V(2)=0.0
        V(5)=0.0
        V(6)=0.0
        V(7)=0.0
        V(3) = SPTOTE(E,E,E)
        V(4) = SPTOTP(E,E,E)
        V(8) = TMXS(E)
      ELSE IF((IUNRSTP.EQ.3)) THEN
        BREM=BREMTM(E)
        ANNIH=ANIHTM(E)
        V(1)=BREM
        V(2)=BREM + ANNIH
        V(3)=SPTOTE(E,E,APP)
        V(4)=SPTOTP(E,E,APP)
        V(5)=1.0
        V(6)=BREM/V(2)
        V(7)=V(6)
        V(8)=TMXS(E)
      ELSE IF((IUNRSTP.EQ.4)) THEN
        V(1)=AMOLTM(E)
        V(2)=BHABTM(E)
        V(3)=SPTOTE(E,AEP,E)
        V(4)=SPTOTP(E,AEP,E)
        V(5)=0.0
        V(6)=0.0
        V(7)=1.0
        V(8)=TMXS(E)
      ELSE
        WRITE(6,10990)IUNRSTP
10990   FORMAT(//'*********IUNRST=',I4,' NOT ALLOWED BY EFUNS*****'/ ' I
     *UNRST=6 OR 7 ONLY ALLOWED WITH CALL OR PLTN OPTIONS'//)
        call exit(20)
      END IF
      RETURN
      END
      real*4 FUNCTION BREMTM(E0)
      implicit none
      real*4 E0,BREMRM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      IF ((E0.LE.APP+RMP)) THEN
        BREMTM=0.
      ELSE
        BREMTM=BREMRM(E0,APP,E0-RMP)
      END IF
      RETURN
      END
      real*4 FUNCTION BREMRM(E,K1,K2)
      implicit none
      real*4 E,K1,K2
      integer*4 I
      real*4 BREMRZ
      COMMON/MIXDAT/NEP,LMED,PZP(50),ZELEMP(50),WAP(50),RHOZP(50), GASPP
     *,EZ,TPZ,IDSTRN(24)
      integer*4 NEP,LMED
      real*4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ
      CHARACTER*4 IDSTRN
      BREMRM=0.
      DO 11001 I=1,NEP
        BREMRM=BREMRM+PZP(I)*BREMRZ(ZELEMP(I),E,K1,K2)
11001 CONTINUE
11002 CONTINUE
      RETURN
      END
      real*4 FUNCTION BREMRZ(Z,E,K1,K2)
      implicit none
      real*4 Z,E,K1,K2
      EXTERNAL BREMFZ
      real*4 DUMMY,BREMDZ,QD,BREMFZ
      DUMMY=BREMDZ(Z,E,K1)
      BREMRZ=QD(BREMFZ,K1,K2,'BREMFZ')
      RETURN
      END
      real*4 FUNCTION BREMDZ(Z,E,K)
      implicit none
      real*4 Z,E,K,BRMSDZ
      BREMDZ=BRMSDZ(Z,E,K)/K
      RETURN
      END
      real*4 FUNCTION BREMFZ(K)
      implicit none
      real*4 K,BRMSFZ
      BREMFZ=BRMSFZ(K)/K
      RETURN
      END
      real*4 FUNCTION BRMSFZ(K)
      implicit none
      real*4 K
      real*4 EMKLOC,DELTA,SB1,SB2,EE
      COMMON/LBREMZ/CONST,DELC,EBREMZ,DELTAM,XLNZ
      real*4 CONST,DELC,EBREMZ,DELTAM,XLNZ
      EMKLOC=EBREMZ-K
      IF ((EMKLOC.EQ.0.0)) THEN
        EMKLOC=1.E-25
      END IF
      DELTA=DELC*K/EMKLOC
      IF ((DELTA.GE.DELTAM)) THEN
        BRMSFZ=0.0
      ELSE
        IF ((DELTA.LE.1.)) THEN
          SB1=20.867+DELTA*(-3.242+DELTA*0.625)-XLNZ
          SB2=20.209+DELTA*(-1.930+DELTA*(-0.086))-XLNZ
        ELSE
          SB1=21.12-4.184*LOG(DELTA+0.952)-XLNZ
          SB2=SB1
        END IF
        EE=EMKLOC/EBREMZ
        BRMSFZ=CONST*((1.+EE*EE)*SB1-0.666667*EE*SB2)
      END IF
      RETURN
      END
      real*4 FUNCTION AMOLTM(E0)
      implicit none
      real*4 E0
      real*4 T0,AMOLRM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      IF ((E0.LE.THMOLLP)) THEN
        AMOLTM=0.
      ELSE
        T0=E0-RMP
        AMOLTM=AMOLRM(E0,AEP,T0*0.5+RMP)
      END IF
      RETURN
      END
      real*4 FUNCTION AMOLRM(EN0,EN1,EN2)
      implicit none
      real*4 EN0,EN1,EN2
      real*4 T0,T1,T2,TM,EM,C1,C2,BETASQ,CMOLL2,EPS1,EPSP1,EPS2,EPSP2
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      T0=EN0-RMP
      T1=EN1-RMP
      T2=EN2-RMP
      TM=T0/RMP
      EM=TM+1.
      C1=(TM/EM)**2
      C2=(2.*TM+1.)/EM**2
      BETASQ=1.-1./EM**2
      CMOLL2=RLCP*EDEN*2.*PIP*R0**2/(BETASQ*TM)
      EPS1=T1/T0
      EPSP1=1.-EPS1
      EPS2=T2/T0
      EPSP2=1.-EPS2
      AMOLRM=CMOLL2*(C1*(EPS2-EPS1)+1./EPS1-1./EPS2+1./EPSP2-1./EPSP1 -C
     *2*LOG(EPS2*EPSP1/(EPS1*EPSP2)))
      RETURN
      END
      real*4 FUNCTION BHABTM(E0)
      implicit none
      real*4 E0,BHABRM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      IF ((E0.LE.AEP)) THEN
        BHABTM=0.
      ELSE
        BHABTM=BHABRM(E0,AEP,E0)
      END IF
      RETURN
      END
      real*4 FUNCTION BHABRM(EN0,EN1,EN2)
      implicit none
      real*4 EN0,EN1,EN2
      real*4 T0,T1,T2,TM,EM,Y,BETASI,CBHAB2,B1,B2,B3,B4,EPS1,EPS2
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      T0=EN0-RMP
      T1=EN1-RMP
      T2=EN2-RMP
      TM=T0/RMP
      EM=TM+1.
      Y=1./(TM+2.)
      BETASI=1./(1.-1./EM**2)
      CBHAB2=RLCP*EDEN*2.*PIP*R0**2/TM
      B1=2.-Y**2
      B2=3.-Y*(6.-Y*(1.-Y*2.))
      B3=2.-Y*(10.-Y*(16.-Y*8.))
      B4=1.-Y*(6.-Y*(12.-Y*8.))
      EPS1=T1/T0
      EPS2=T2/T0
      BHABRM=CBHAB2*(BETASI*(1./EPS1-1./EPS2)-B1*LOG(EPS2/EPS1) +B2*(EPS
     *2-EPS1)+EPS2*EPS2*(EPS2*B4/3.-0.5*B3) - EPS1*EPS1*(EPS1*B4/3.-0.5*
     *B3))
      RETURN
      END
      real*4 FUNCTION ANIHTM(E0)
      implicit none
      real*4 E0
      real*4 GAM,P0P2,P0P,CANIH
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      GAM=E0/RMP
      P0P2=GAM*GAM-1.0
      P0P=SQRT(P0P2)
      CANIH=RLCP*EDEN*PIP*R0**2/(GAM+1.)
      ANIHTM=CANIH*((GAM*GAM+4.*GAM+1.)/P0P2*LOG(GAM+P0P) -(GAM+3.)/P0P)
      RETURN
      END
      real*4 FUNCTION SPTOTP(E0,EE,EG)
      implicit none
      real*4 E0,EE,EG
      real*4 SPIONP,BRMSTM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      IF ((IUNRSTP.EQ.0)) THEN
        SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.1)) THEN
        SPTOTP=SPIONP(E0,E0)
      ELSE IF((IUNRSTP.EQ.2)) THEN
        SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.3)) THEN
        SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.4)) THEN
        SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.5)) THEN
        SPTOTP=BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.6)) THEN
        SPTOTP=BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.7)) THEN
        SPTOTP=SPIONP(E0,EE)
      END IF
      RETURN
      END
      real*4 FUNCTION SPTOTE(E0,EE,EG)
      implicit none
      real*4 E0,EE,EG
      real*4 SPIONE,BRMSTM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      IF ((IUNRSTP.EQ.0)) THEN
        SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.1)) THEN
        SPTOTE=SPIONE(E0,E0)
      ELSE IF((IUNRSTP.EQ.2)) THEN
        SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.3)) THEN
        SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.4)) THEN
        SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.5)) THEN
        SPTOTE=BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.6)) THEN
        SPTOTE=BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.7)) THEN
        SPTOTE=SPIONE(E0,EE)
      END IF
      RETURN
      END
      real*4 FUNCTION SPIONE(E0,EE)
      implicit none
      real*4 E0,EE,SPIONB
      SPIONE=SPIONB(E0,EE,.FALSE.)
      RETURN
      END
      real*4 FUNCTION SPIONB(E0,EE,POSITR)
      implicit none
      real*4 E0,EE
      LOGICAL POSITR
      real*4 G,EEM,T,ETA2,BETA2,ALETA2,X,D,FTERM,TP2,D2,D3,D4,DELTA
      integer*4 I
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/LSPION/CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      real*4 CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20), EPSTTL,NEPST,IEPST
     *,EPSTFLP, NELEPS,ZEPST(20),IAPRFL,IAPRIMP
      integer*4 ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP
      CHARACTER EPSTTL*80
      real*4 EPSTEN,EPSTD,WEPST
      G=E0/RMP
      EEM=EE/RMP-1.
      T=G-1
      ETA2=T*(G+1.)
      BETA2=ETA2/G**2
      ALETA2=LOG(ETA2)
      X=0.21715*ALETA2
      IF ((.NOT.POSITR)) THEN
        D=AMIN1(EEM,0.5*T)
        FTERM=-1.-BETA2+LOG((T-D)*D)+T/(T-D) +(D*D/2.+(2.*T+1.)*LOG(1.-D
     *  /T))/(G*G)
      ELSE
        D=AMIN1(EEM,T)
        TP2=T+2.
        D2=D*D
        D3=D*D2
        D4=D*D3
        FTERM=LOG(T*D)-(BETA2/T)*( T + 2.*D - (3.*D2/2.)/TP2 -(D-D3/3.)/
     *  (TP2*TP2)-(D2/2.-T*D3/3.+D4/4.)/TP2**3)
      END IF
      IF ((EPSTFLP .EQ. 0)) THEN
        IF ((X.LE.X0)) THEN
          DELTA=0.0
        ELSE IF((X.LT.X1)) THEN
          DELTA=TOLN10*X - CBAR + AFACT*(X1 - X)**SK
        ELSE
          DELTA=TOLN10*X - CBAR
        END IF
      ELSE
        IF ((E0 .GE. EPSTEN(IEPST))) THEN
          IF ((E0 .EQ. EPSTEN(IEPST))) THEN
            GO TO 11010
          END IF
          DO 11021 I=IEPST,NEPST-1
            IF ((E0.LT.EPSTEN(I+1))) THEN
              IEPST = I
              GO TO 11010
            END IF
11021     CONTINUE
11022     CONTINUE
          IEPST = NEPST
          GO TO 11010
        ELSE
          DO 11031 I=IEPST,2,-1
            IF ((E0 .GE. EPSTEN(I-1))) THEN
              IEPST = I-1
              GO TO 11010
            END IF
11031     CONTINUE
11032     CONTINUE
          IEPST = 1
        END IF
11010   IF ((IEPST .LT. NEPST)) THEN
          DELTA = EPSTD(IEPST) + (E0 - EPSTEN(IEPST))/ (EPSTEN(IEPST+1)
     *    - EPSTEN(IEPST)) * (EPSTD(IEPST+1) - EPSTD(IEPST))
        ELSE
          DELTA = EPSTD(NEPST)
        END IF
      END IF
      SPIONB=(SPC1/BETA2)*(LOG(T + 2.) - SPC2 + FTERM - DELTA)
      RETURN
      END
      real*4 FUNCTION SPIONP(E0,EE)
      implicit none
      real*4 E0,EE,SPIONB
      SPIONP=SPIONB(E0,EE,.TRUE.)
      RETURN
      END
      real*4 FUNCTION BRMSTM(E0,EG)
      implicit none
      real*4 E0,EG,BRMSRM,AU,zero
      parameter (zero=0)
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      IF ((E0.LE.RMP)) THEN
        BRMSTM=0.
      ELSE
        AU=AMIN1(EG,E0-RMP)
        BRMSTM=BRMSRM(E0,zero,AU)
      END IF
      RETURN
      END
      real*4 FUNCTION BRMSRM(E,K1,K2)
      implicit none
      real*4 E,K1,K2,BRMSRZ
      integer*4 I
      COMMON/MIXDAT/NEP,LMED,PZP(50),ZELEMP(50),WAP(50),RHOZP(50), GASPP
     *,EZ,TPZ,IDSTRN(24)
      integer*4 NEP,LMED
      real*4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ
      CHARACTER*4 IDSTRN
      BRMSRM=0.
      DO 11041 I=1,NEP
        BRMSRM=BRMSRM+PZP(I)*BRMSRZ(ZELEMP(I),E,K1,K2)
11041 CONTINUE
11042 CONTINUE
      RETURN
      END
      real*4 FUNCTION BRMSRZ(Z,E,K1,K2)
      implicit none
      real*4 Z,E,K1,K2
      EXTERNAL BRMSFZ
      real*4 DUMMY,BRMSDZ,QD,BRMSFZ
      DUMMY=BRMSDZ(Z,E,K1)
      BRMSRZ=QD(BRMSFZ,K1,K2,'BRMSFZ')
      RETURN
      END
      real*4 FUNCTION BRMSDZ(Z,EA,K)
      implicit none
      real*4 Z,EA,K
      real*4 APRIM,XSIFP,FCOULCP,BRMSFZ
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/LBREMZ/CONST,DELC,EBREMZ,DELTAM,XLNZ
      real*4 CONST,DELC,EBREMZ,DELTAM,XLNZ
      EBREMZ=EA
      DELC=136.*Z**(-1./3.)*RMP/EBREMZ
      CONST=APRIM(Z,EBREMZ)*(AN*RHOP/WM)*R0**2*FSC*Z*(Z+XSIFP(Z))*RLCP
      XLNZ=4./3.*LOG(Z)
      IF((EBREMZ.GE.50))XLNZ=XLNZ+4.*FCOULCP(Z)
      DELTAM=EXP((21.12-XLNZ)/4.184)-0.952
      BRMSDZ=BRMSFZ(K)
      RETURN
      END
      real*4 FUNCTION APRIM(Z,E)
      implicit none
      real*4 Z,E
      integer*4 napre,naprz,ie,iz,aprim_unit,egs_get_unit,lnblnk1
      real*4 EM,AINTP
      character aprim_file*256
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20), EPSTTL,NEPST,IEPST
     *,EPSTFLP, NELEPS,ZEPST(20),IAPRFL,IAPRIMP
      integer*4 ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP
      CHARACTER EPSTTL*80
      real*4 EPSTEN,EPSTD,WEPST
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*4 APRIMD(115,14),EPRIM(115),ZPRIM(14),APRIMZ(115)
      DATA APRIMD/ 1.32,1.26,1.18,1.13,1.09,1.07,1.05,1.04,1.03, 1.02,8*
     *1.0, 97*0.0, 1.34,1.27,1.19,1.13,1.09,1.07,1.05,1.04,1.03,1.02, 8*
     *1.0, 97*0.0, 1.39,1.30,1.21,1.14,1.10,1.07,1.05,1.04,1.03,1.02,0.9
     *94, 2*0.991,0.990,2*0.989,2*0.988, 97*0.0, 1.46,1.34,1.23,1.15,1.1
     *1,1.08, 1.06,1.05,1.03,1.02,0.989, 0.973,0.971,0.969,0.967,0.965,2
     **0.963, 97*0.0, 1.55,1.40,1.26,1.17,1.12,1.09,1.07,1.05,1.03,1.02,
     *0.955,0.935, 0.930,0.925,0.920,0.915,2*0.911, 97*0.0,  1035*0.0/,
     *EPRIM / 2.,3.,4.,5.,6.,7.,8.,9.,10.,11.,21.,31.,41.,51.,61.,71.,81
     *.,91.,  97*0.0/, ZPRIM /6.,13.,29.,50.,79., 9*0.0/
      save APRIMD,EPRIM,ZPRIM,APRIMZ,napre,naprz
      IF ((IAPRIMP.EQ.0)) THEN
        IF ((IAPRFL .EQ. 0)) THEN
          IAPRFL=1
        END IF
        IF ((E.GE.50)) THEN
          APRIM=1.
        ELSE
          EM=E/RMP
          DO 11051 IE=1,18
            APRIMZ(IE)= AINTP(Z,ZPRIM,5,APRIMD(IE,1),115,.FALSE.,.FALSE.
     *      )
11051     CONTINUE
11052     CONTINUE
          APRIM=AINTP(EM,EPRIM,18,APRIMZ,1,.FALSE.,.FALSE.)
        END IF
      ELSE IF((IAPRIMP.EQ.1)) THEN
        IF ((IAPRFL.EQ.0)) THEN
          aprim_file = hen_house(:lnblnk1(hen_house)) // 'pegs4' // '/'
     *    // 'aprime.data'
          aprim_unit=22
          aprim_unit=egs_get_unit(aprim_unit)
          IF (( aprim_unit .LT. 1 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'APRIM: failed to get a free fortran unit'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(aprim_unit,file=aprim_file,status='old',err=11060)
          READ(aprim_unit,*) NAPRZ, NAPRE
          IF ((NAPRZ.GT.14)) THEN
            WRITE(6,11070)
11070       FORMAT(//,' TOO MANY ELEMENTS FOR APRIME INTERPOLATION:', /,
     *'   CHANGE $NAPRZ AND RECOMPILE PEGS')
            call exit(24)
          END IF
          IF ((NAPRE.GT.115)) THEN
            WRITE(6,11080)
11080       FORMAT(//,' TOO MANY ENERGIES FOR APRIME INTERPOLATION:', /,
     *'   CHANGE $NAPRE AND RECOMPILE PEGS')
            call exit(24)
          END IF
          READ(aprim_unit,*) (EPRIM(IE),IE=1,NAPRE)
          DO 11091 IE=1,NAPRE
            EPRIM(IE)=1.+EPRIM(IE)/RMP
11091     CONTINUE
11092     CONTINUE
          DO 11101 IZ=1,NAPRZ
            READ(aprim_unit,*)ZPRIM(IZ),(APRIMD(IE,IZ),IE=1,NAPRE)
11101     CONTINUE
11102     CONTINUE
          IAPRFL=1
          close(aprim_unit)
        END IF
        EM=E/RMP
        DO 11111 IE=1,NAPRE
          APRIMZ(IE)= AINTP(Z,ZPRIM,NAPRZ,APRIMD(IE,1),115,.TRUE.,.FALSE
     *    .)
11111   CONTINUE
11112   CONTINUE
        APRIM=AINTP(EM,EPRIM,NAPRE,APRIMZ,1,.FALSE.,.FALSE.)
      ELSE IF((IAPRIMP.EQ.2)) THEN
        IF ((IAPRFL .EQ. 0)) THEN
          IAPRFL=1
        END IF
        APRIM=1.0
      ELSE
        WRITE(6,11120)IAPRIMP
11120   FORMAT(//,' ILLEGAL VALUE FOR IAPRIM: ',I4)
        call exit(24)
      END IF
      RETURN
11060 write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Cannot open file $HEN_HOUSE/pegs4/aprime.data'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      RETURN
      END
      real*4 FUNCTION AINTP(X,XA,NX,YA,ISK,XLOG,YLOG)
      implicit none
      integer*4 NX,ISK
      real*4 X
      real*4 XA(NX),YA(ISK,NX)
      LOGICAL XLOG,YLOG,XLOGL
      integer*4 I,J
      real*4 XI,XJ,XV,YI,YJ
      XLOGL=XLOG
      DO 11131 J=2,NX
        IF((X.LT.XA(J)))GO TO 11140
11131 CONTINUE
11132 CONTINUE
      J=NX
11140 I=J-1
      IF ((XA(I).LE.0.0)) THEN
        XLOGL=.FALSE.
      END IF
      IF ((.NOT.XLOGL)) THEN
        XI=XA(I)
        XJ=XA(J)
        XV=X
      ELSE
        XI=LOG(XA(I))
        XJ=LOG(XA(J))
        XV=LOG(X)
      END IF
      IF ((YLOG.AND.(YA(1,I).EQ.0.0.OR.YA(1,J).EQ.0.0))) THEN
        AINTP=0.0
      ELSE
        IF ((YLOG)) THEN
          YI=LOG(YA(1,I))
          YJ=LOG(YA(1,J))
          IF ((XJ.EQ.XI)) THEN
            AINTP=YI
          ELSE
            AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI)
          END IF
          AINTP=EXP(AINTP)
        ELSE
          YI=YA(1,I)
          YJ=YA(1,J)
          IF ((XJ.EQ.XI)) THEN
            AINTP=YI
          ELSE
            AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI)
          END IF
        END IF
      END IF
      RETURN
      END
      real*4 FUNCTION TMXS(E)
      implicit none
      real*4 E,TMXB
      real*4 SAFETY,TABSMX
      DATA SAFETY/0.8/,TABSMX/10.0/
      save SAFETY,TABSMX
      TMXS=AMIN1(TMXB(E)*SAFETY,TABSMX)
      RETURN
      END
      real*4 FUNCTION TMXB(E)
      implicit none
      real*4 E
      real*4 ESQ,BETA2,PX2
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      ESQ=E**2
      BETA2=1.0-RMPSQ/ESQ
      PX2=ESQ*BETA2/XCCP**2
      TMXB=PX2*BETA2/LOG(BLCCP*PX2)
      RETURN
      END
      real*4 FUNCTION ALKE(E)
      implicit none
      real*4 E
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      ALKE=LOG(E-RMP)
      RETURN
      END
      real*4 FUNCTION ALKEI(X)
      implicit none
      real*4 x
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      ALKEI=EXP(X) + RMP
      RETURN
      END
      SUBROUTINE PWLF1(NI,NIMX,XL,XU,XR,EP,ZTHR,ZEP,NIP,XFUN,XFI, AX,BX,
     *NALM,NFUN,AF,BF,VFUNS)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 NI,NIMX,NIP,NALM,NFUN
      real*4 XL,XU,XR,EP,AX,BX,XFUN,XFI
      EXTERNAL XFI,VFUNS,XFUN
      real*4 AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN)
      LOGICAL QFIT
      integer*4 NL,NU,IPRN,NJ,NK
      real*4 REM
      NL=0
      NU=1
      IPRN=0
11151 CONTINUE
        NJ=MIN0(NU,NIMX)
        IF((QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI, AX,BX,NALM,NF
     *  UN,AF,BF,VFUNS,0)))GO TO11152
        IF ((NU.GE.NIMX)) THEN
          NI=NJ
          RETURN
        END IF
        NL=NU
        NU=NU*2
      GO TO 11151
11152 CONTINUE
      NU=NJ
11161 IF(NU.LE.NL+1)GO TO 11162
        NJ=(NL+NU)/2
        NK=NJ
        IF ((QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI, AX,BX,NALM,N
     *  FUN,AF,BF,VFUNS,0))) THEN
          NU=NJ
        ELSE
          NL=NK
        END IF
      GO TO 11161
11162 CONTINUE
      NI=NU
      IF((NI.EQ.NJ))RETURN
      IF((.NOT.QFIT(NI,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI, AX,BX,NALM
     *,NFUN,AF,BF,VFUNS,0)))WRITE(6,11170)NI
11170 FORMAT(' CATASTROPHE---DOES NOT FIT WHEN IT SHOULD,NI=',I5)
      RETURN
      END
      LOGICAL FUNCTION QFIT(NJ,XL,XH,XR,EP,ZTHR,ZEP,REM,NJP,XFUN,XFI, AX
     *,BX,NALM,NFUN,AF,BF,VFUNS,IPRN)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      EXTERNAL VFUNS
      real*4 XFUN,XFI
      integer*4 NJ,NALM,NFUN,NJP,IPRN
      real*4 XL,XH,XR,AX,BX,REM,EP
      real*4 FSXL(10),FSXH(10),FIP(10),FFIP(10),AFIP(10),RE(10),AER(10)
      real*4 AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN)
      real*4 XS,XFL,XFH,XFS,XM,DX,W,XLL,SXFL,XSXF,SXFH,DSXF,WIP, SXFIP,X
     *IP
      integer*4 NI,NIP,ISUB,IFUN,JSUB,IP
      integer*4 nkp
      DATA NKP/3/
      save nkp
      IF ((XH.LE.XL)) THEN
        WRITE(6,11180)XL,XH
11180   FORMAT(' QFIT ERROR:XL SHOULD BE < XH. XL,XH=',2G14.6)
        QFIT=.FALSE.
        RETURN
      END IF
      XS=AMAX1(XL,AMIN1(XH,XR))
      NI=NJ-2
      IF ((((XS.EQ.XL.OR.XS.EQ.XH).AND.NI.GE.1).OR.NI.GE.2)) THEN
        XFL=XFUN(XL)
      ELSE
        QFIT=.FALSE.
        RETURN
      END IF
      XFH=XFUN(XH)
      XFS=XFUN(XS)
      XM=AMAX1(XFH-XFS,XFS-XFL)
      DX=XFH-XFL
      W=XM/AMAX1(1.,AINT(NI*XM/DX))
      NI=NI-AINT(NI-DX/W)
      NIP=MAX0(NKP,(NJP+NI-1)/NI)
      NIP=(NIP/2)*2+1
      IF ((XFH-XFS.LE.XFS-XFL)) THEN
        XLL=XFL
      ELSE
        XLL=XFH-NI*W
      END IF
      AX=1./W
      BX=2.-XLL*AX
      REM=0.0
      QFIT=.TRUE.
      SXFL=AMAX1(XLL,XFL)
      ISUB=0
      XSXF=XFI(SXFL)
      CALL VFUNS(XSXF,FSXL)
      IF((IPRN.NE.0))WRITE(6,1940) ISUB,SXFL,XSXF,(FSXL(IFUN),IFUN=1,NFU
     *N)
1940  FORMAT(' QFIT:ISUB,SXF,XSXF,FSX()=',I4,1P,9G11.4/(1X,12G11.4))
      DO 11191 ISUB=1,NI
        JSUB=ISUB+1
        SXFH=AMIN1(XLL+W*ISUB,XH)
        XSXF=XFI(SXFH)
        CALL VFUNS(XSXF,FSXH)
        IF((IPRN.NE.0))WRITE(6,1940)ISUB,SXFH,XSXF,(FSXH(IFUN),IFUN=1,NF
     *  UN)
        DSXF=SXFH-SXFL
        DO 11201 IFUN=1,NFUN
          AF(JSUB,IFUN)=(FSXH(IFUN)-FSXL(IFUN))/DSXF
          BF(JSUB,IFUN)=(FSXL(IFUN)*SXFH-FSXH(IFUN)*SXFL)/DSXF
11201   CONTINUE
11202   CONTINUE
        WIP=DSXF/(NIP+1)
        DO 11211 IP=1,NIP
          SXFIP=SXFL+IP*WIP
          XIP=XFI(SXFIP)
          CALL VFUNS(XIP,FIP)
          DO 11221 IFUN=1,NFUN
            FFIP(IFUN)=AF(JSUB,IFUN)*SXFIP+BF(JSUB,IFUN)
            AFIP(IFUN)=ABS(FIP(IFUN))
            AER(IFUN)=ABS(FFIP(IFUN)-FIP(IFUN))
            RE(IFUN)=0.0
            IF ((FIP(IFUN).NE.0.0)) THEN
              RE(IFUN)=AER(IFUN)/AFIP(IFUN)
            END IF
            IF ((AFIP(IFUN).GE.ZTHR(IFUN))) THEN
              REM=AMAX1(REM,RE(IFUN))
            ELSE IF((AER(IFUN).GT.ZEP(IFUN))) THEN
              QFIT=.FALSE.
            END IF
11221     CONTINUE
11222     CONTINUE
          IF ((IPRN.NE.0)) THEN
            WRITE(6,11230)ISUB,IP,SXFIP,XIP,REM,QFIT,(FIP(IFUN),FFIP(IFU
     *      N), RE(IFUN),AER(IFUN),IFUN=1,NFUN)
11230       FORMAT(1X,2I4,1P,2G12.5,6P,F12.0,L2,1P,2G11.4,6P,F11.0,1P,G1
     *1.4/ (1X,3(1P,2G11.4,6P,F11.0,1P,G11.4)))
          END IF
11211   CONTINUE
11212   CONTINUE
        SXFL=SXFH
        DO 11241 IFUN=1,NFUN
          FSXL(IFUN)=FSXH(IFUN)
11241   CONTINUE
11242   CONTINUE
11191 CONTINUE
11192 CONTINUE
      DO 11251 IFUN=1,NFUN
        AF(1,IFUN)=AF(2,IFUN)
        BF(1,IFUN)=BF(2,IFUN)
        AF(NI+2,IFUN)=AF(NI+1,IFUN)
        BF(NI+2,IFUN)=BF(NI+1,IFUN)
11251 CONTINUE
11252 CONTINUE
      QFIT=QFIT.AND.REM.LE.EP
      NJ=NI+2
      RETURN
      END
      real*4 FUNCTION QD(F,A,B,MSG)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*4 A,B,F
      EXTERNAL F
      CHARACTER*6 MSG
      logical first_time
      data first_time/.true./
      save first_time
      real*4 DCADRE,ADUM,BDUM,ERRDUM
      integer*4 IER
      ADUM=A
      BDUM=B
      QD=DCADRE(F,ADUM,BDUM,1.E-16,1.E-5,ERRDUM,IER)
      IF ((IER.GT.66)) THEN
        WRITE(6,11260)IER,MSG,A,B,QD,ERRDUM
11260   FORMAT(' DCADRE CODE=',I4,' FOR INTEGRAL ',A6,' FROM ',1P,G14.6,
     *' TO ',G14.6, ',QD=',G14.6,'+-',G14.6)
      END IF
      RETURN
      END
      real*4 FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER)
      implicit none
      DIMENSION T(10,10),R(10),AIT(10),DIF(10),RN(4),TS(2049)
      DIMENSION IBEGS(30),BEGIN(30),FINIS(30),EST(30)
      DIMENSION REGLSV(30)
      LOGICAL H2CONV,AITKEN,RIGHT,REGLAR,REGLSV
      real*4 T,R,AIT,DIF,RN,TS,BEGIN,FINIS,EST,AITLOW
      real*4 H2TOL,AITTOL,LENGTH,JUMPTL,ZERO,P1,HALF,ONE
      real*4 TWO,FOUR,FOURP5,TEN,HUN,CADRE,ERROR,A,B
      real*4 AERR,RERR,STEPMN,STEPNM,STAGE,CUREST,FNSIZE
      real*4 PREVER,BEG,FBEG,END,FEND,STEP,ASTEP,TABS,HOVN
      real*4 FN,SUM,SUMABS,ABSI,VINT,TABTLM,ERGL,ERGOAL
      real*4 ERRA,ERRR,FEXTRP,ERRER,DIFF,SING,FEXTM1,ALG4O2
      real*4 H2NXT,SINGNX,SLOPE,FBEG2,ALPHA
      real*4 ERRET,H2TFEX,FI
      real*4 RVAL,F
      integer*4 IBEGS,IER,ISTAGE,IBEG,IEND,L,N,LM1,N2,ISTEP,II,III,I,IST
     *EP2,IT,NNLEFT
      integer*4 MAXTS,MAXTBL,MXSTGE
      DATA AITLOW,H2TOL,AITTOL,JUMPTL,MAXTS,MAXTBL,MXSTGE/1.1D0,.15D0, .
     *1D0,.01D0,2049,10,30/
      DATA RN(1),RN(2),RN(3),RN(4)/.7142005D0,.3466282D0,.843751D0, .126
     *3305D0/
      DATA ZERO,P1,HALF,ONE,TWO,FOUR,FOURP5,TEN,HUN/0.0D0,0.1D0,0.5D0, 1
     *.0D0,2.0D0,4.0D0,4.5D0,10.0D0,100.0D0/
      save MAXTS,MAXTBL,MXSTGE
      ALG4O2=LOG10(TWO)
      CADRE=ZERO
      ERROR=ZERO
      CUREST=ZERO
      VINT=ZERO
      IER=0
      LENGTH=ABS(B-A)
      IF((LENGTH.EQ.ZERO))GO TO 215
      IF((RERR.GT.P1.OR.RERR.LT.ZERO))GO TO 210
      IF((AERR.EQ.ZERO.AND.(RERR+HUN).LE.HUN))GO TO 210
      ERRR=RERR
      ERRA=ABS(AERR)
      STEPMN=(LENGTH/FLOAT(2**MXSTGE))
      STEPNM=DMAX1(LENGTH,ABS(A),ABS(B))*TEN
      STAGE=HALF
      ISTAGE=1
      FNSIZE=ZERO
      PREVER=ZERO
      REGLAR=.FALSE.
      BEG=A
      RVAL=BEG
      FBEG=F(RVAL)*HALF
      TS(1)=FBEG
      IBEG=1
      END=B
      RVAL=END
      FEND=F(RVAL)*HALF
      TS(2)=FEND
      IEND=2
5     RIGHT=.FALSE.
10    STEP=END - BEG
      ASTEP=ABS(STEP)
      IF((ASTEP.LT.STEPMN))GO TO 205
      IF((STEPNM+ASTEP.EQ.STEPNM))GO TO 205
      T(1,1)=FBEG + FEND
      TABS=ABS(FBEG) + ABS(FEND)
      L=1
      N=1
      H2CONV=.FALSE.
      AITKEN=.FALSE.
15    LM1=L
      L=L + 1
      N2=N + N
      FN=N2
      ISTEP=(IEND - IBEG)/N
      IF((ISTEP.GT.1))GO TO 25
      II=IEND
      IEND=IEND + N
      IF((IEND.GT.MAXTS))GO TO 200
      HOVN=STEP/FN
      III=IEND
      FI=ONE
      DO 11271 I=1,N2,2
        TS(III)=TS(II)
        RVAL=END-FI*HOVN
        TS(III-1)=F(RVAL)
        FI=FI+TWO
        III=III-2
        II=II-1
11271 CONTINUE
11272 CONTINUE
      ISTEP=2
25    ISTEP2=IBEG + ISTEP/2
      SUM=ZERO
      SUMABS=ZERO
      DO 11281 I=ISTEP2,IEND,ISTEP
        SUM=SUM + TS(I)
        SUMABS=SUMABS + ABS(TS(I))
11281 CONTINUE
11282 CONTINUE
      T(L,1)=T(L-1,1)*HALF+SUM/FN
      TABS=TABS*HALF+SUMABS/FN
      ABSI=ASTEP*TABS
      N=N2
      IT=1
      VINT=STEP*T(L,1)
      TABTLM=TABS*TEN
      FNSIZE=DMAX1(FNSIZE,ABS(T(L,1)))
      ERGL=ASTEP*FNSIZE*TEN
      ERGOAL=STAGE*DMAX1(ERRA,ERRR*ABS(CUREST+VINT))
      FEXTRP=ONE
      DO 11291 I=1,LM1
        FEXTRP=FEXTRP*FOUR
        T(I,L)=T(L,I) - T(L-1,I)
        T(L,I+1)=T(L,I) + T(I,L)/(FEXTRP-ONE)
11291 CONTINUE
11292 CONTINUE
      ERRER=ASTEP*ABS(T(1,L))
      IF((L.GT.2))GO TO 40
      IF((TABS+P1*ABS(T(1,2)).EQ.TABS))GO TO 135
      GO TO 15
40    DO 45 I=2,LM1
      DIFF=ZERO
      IF((TABTLM+ABS(T(I-1,L)).NE.TABTLM))DIFF=T(I-1,LM1)/T(I-1,L)
      T(I-1,LM1)=DIFF
45    CONTINUE
      IF((ABS(FOUR-T(1,LM1)).LE.H2TOL))GO TO 60
      IF((T(1,LM1).EQ.ZERO))GO TO 55
      IF((ABS(TWO-ABS(T(1,LM1))).LT.JUMPTL))GO TO 130
      IF((L.EQ.3))GO TO 15
      H2CONV=.FALSE.
      IF((ABS((T(1,LM1)-T(1,L-2))/T(1,LM1)).LE.AITTOL))GO TO 75
50    IF(REGLAR) GO TO 55
      IF((L.EQ.4))GO TO 15
55    IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 175
      GO TO 145
60    IF(H2CONV) GO TO 65
      AITKEN=.FALSE.
      H2CONV=.TRUE.
65    FEXTRP=FOUR
70    IT=IT + 1
      VINT=STEP*T(L,IT)
      ERRER=ABS(STEP/(FEXTRP-ONE)*T(IT-1,L))
      IF((ERRER.LE.ERGOAL))GO TO 160
      IF((ERGL+ERRER.EQ.ERGL))GO TO 160
      IF((IT.EQ.LM1))GO TO 125
      IF((T(IT,LM1).EQ.ZERO))GO TO 70
      IF((T(IT,LM1).LE.FEXTRP))GO TO 125
      IF((ABS(T(IT,LM1)/FOUR-FEXTRP)/FEXTRP.LT.AITTOL))FEXTRP=FEXTRP*FOU
     *R
      GO TO 70
75    IF(T(1,LM1).LT.AITLOW) GO TO 175
      IF((AITKEN))GO TO 80
      H2CONV=.FALSE.
      AITKEN=.TRUE.
80    FEXTRP=T(L-2,LM1)
      IF((FEXTRP.GT.FOURP5))GO TO 65
      IF((FEXTRP.LT.AITLOW))GO TO 175
      IF((ABS(FEXTRP-T(L-3,LM1))/T(1,LM1).GT.H2TOL))GO TO 175
      SING=FEXTRP
      FEXTM1=ONE/(FEXTRP - ONE)
      AIT(1)=ZERO
      DO 85 I=2,L
      AIT(I)=T(I,1) + (T(I,1)-T(I-1,1))*FEXTM1
      R(I)=T(1,I-1)
      DIF(I)=AIT(I) - AIT(I-1)
85    CONTINUE
      IT=2
90    VINT=STEP*AIT(L)
      ERRER=ERRER*FEXTM1
      IF((ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL))GO TO 95
      ALPHA=LOG10(SING)/ALG4O2 - ONE
      IER=MAX0(IER,65)
      GO TO 160
95    IT=IT + 1
      IF((IT.EQ.LM1))GO TO 125
      IF((IT.GT.3))GO TO 100
      H2NXT=FOUR
      SINGNX=SING+SING
100   IF(H2NXT.LT.SINGNX) GO TO 105
      FEXTRP=SINGNX
      SINGNX=SINGNX+SINGNX
      GO TO 110
105   FEXTRP=H2NXT
      H2NXT=FOUR*H2NXT
110   DO 115 I=IT,LM1
      R(I+1)=ZERO
      IF((TABTLM+ABS(DIF(I+1)).NE.TABTLM))R(I+1)=DIF(I)/DIF(I+1)
115   CONTINUE
      H2TFEX=-H2TOL*FEXTRP
      IF((R(L)-FEXTRP.LT.H2TFEX))GO TO 125
      IF((R(L-1)-FEXTRP.LT.H2TFEX))GO TO 125
      ERRER=ASTEP*ABS(DIF(L))
      FEXTM1=ONE/(FEXTRP - ONE)
      DO 120 I=IT,L
      AIT(I)=AIT(I) + DIF(I)*FEXTM1
      DIF(I)=AIT(I) - AIT(I-1)
120   CONTINUE
      GO TO 90
125   FEXTRP=DMAX1(PREVER/ERRER,AITLOW)
      PREVER=ERRER
      IF((L.LT.5))GO TO 15
      IF((L-IT.GT.2.AND.ISTAGE.LT.MXSTGE))GO TO 170
      ERRET=ERRER/(FEXTRP**(MAXTBL-L))
      IF((ERRET.GT.ERGOAL.AND.(ERGL+ERRET).NE.ERGL))GO TO 170
      GO TO 15
130   IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 170
      DIFF=ABS(T(1,L))*(FN+FN)
      GO TO 160
135   SLOPE=(FEND-FBEG)*TWO
      FBEG2=FBEG+FBEG
      DO 140 I=1,4
      RVAL=BEG+RN(I)*STEP
      DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE)
      IF((TABTLM+DIFF.NE.TABTLM))GO TO 155
140   CONTINUE
      GO TO 160
145   SLOPE=(FEND-FBEG)*TWO
      FBEG2=FBEG+FBEG
      I=1
150   RVAL=BEG+RN(I)*STEP
      DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE)
155   ERRER=DMAX1(ERRER,ASTEP*DIFF)
      IF((ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL))GO TO 175
      I=I+1
      IF((I.LE.4))GO TO 150
      IER=66
160   CADRE=CADRE + VINT
      ERROR=ERROR + ERRER
      IF((RIGHT))GO TO 165
      ISTAGE=ISTAGE - 1
      IF((ISTAGE.EQ.0))GO TO 220
      REGLAR=REGLSV(ISTAGE)
      BEG=BEGIN(ISTAGE)
      END=FINIS(ISTAGE)
      CUREST=CUREST - EST(ISTAGE+1) + VINT
      IEND=IBEG - 1
      FEND=TS(IEND)
      IBEG=IBEGS(ISTAGE)
      GO TO 180
165   CUREST=CUREST + VINT
      STAGE=STAGE+STAGE
      IEND=IBEG
      IBEG=IBEGS(ISTAGE)
      END=BEG
      BEG=BEGIN(ISTAGE)
      FEND=FBEG
      FBEG=TS(IBEG)
      GO TO 5
170   REGLAR=.TRUE.
175   IF(ISTAGE.EQ.MXSTGE) GO TO 205
      IF((RIGHT))GO TO 185
      REGLSV(ISTAGE+1)=REGLAR
      BEGIN(ISTAGE)=BEG
      IBEGS(ISTAGE)=IBEG
      STAGE=STAGE*HALF
180   RIGHT=.TRUE.
      BEG=(BEG+END)*HALF
      IBEG=(IBEG+IEND)/2
      TS(IBEG)=TS(IBEG)*HALF
      FBEG=TS(IBEG)
      GO TO 10
185   NNLEFT=IBEG - IBEGS(ISTAGE)
      IF((IEND+NNLEFT.GE.MAXTS))GO TO 200
      III=IBEGS(ISTAGE)
      II=IEND
      DO 190 I=III,IBEG
      II=II + 1
      TS(II)=TS(I)
190   CONTINUE
      DO 195 I=IBEG,II
      TS(III)=TS(I)
      III=III + 1
195   CONTINUE
      IEND=IEND + 1
      IBEG=IEND - NNLEFT
      FEND=FBEG
      FBEG=TS(IBEG)
      FINIS(ISTAGE)=END
      END=BEG
      BEG=BEGIN(ISTAGE)
      BEGIN(ISTAGE)=END
      REGLSV(ISTAGE)=REGLAR
      ISTAGE=ISTAGE + 1
      REGLAR=REGLSV(ISTAGE)
      EST(ISTAGE)=VINT
      CUREST=CUREST + EST(ISTAGE)
      GO TO 5
200   IER=131
      GO TO 215
205   IER=132
      GO TO 215
210   IER=133
215   CADRE=CUREST + VINT
220   DCADRE=CADRE
9000  CONTINUE
9005  RETURN
      END
      SUBROUTINE SPINIT(density_file)
      implicit none
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/SPCOMM/MEDTBL(24,73), NUMSTMED,STDATA(6,73)
      CHARACTER*4 MEDTBL
      integer*4 NUMSTMED
      real*4 STDATA
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6), DE
     *LCMP,ALPHIP(2),BPARP(2),DELPOSP(2)
      real*4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP
      COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100)
      integer*4 NET
      real*4 ITBL,WATBL,RHOTBL
      CHARACTER*4 ASYMT
      COMMON/LSPION/CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      real*4 CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20), EPSTTL,NEPST,IEPST
     *,EPSTFLP, NELEPS,ZEPST(20),IAPRFL,IAPRIMP
      integer*4 ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP
      CHARACTER EPSTTL*80
      real*4 EPSTEN,EPSTD,WEPST
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MIXDAT/NEP,LMED,PZP(50),ZELEMP(50),WAP(50),RHOZP(50), GASPP
     *,EZ,TPZ,IDSTRN(24)
      integer*4 NEP,LMED
      real*4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ
      CHARACTER*4 IDSTRN
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      real*4 IMEV
      integer*4 IM,J,IZ,IE,I,ICHECK,IESPEL,IPEGEL,density_unit,lnblnk1,e
     *gs_get_unit
      real*4 VPLASM,ALIADG,EDENL,ALGASP,EPSTRH, TLRNCE,EPSTWT
      CHARACTER*256 density_file
      TOLN10=2.0*LOG(10.0)
      IM=-100
      IF ((EPSTFLP .LT. 0 .OR. EPSTFLP .GT. 1)) THEN
        EPSTFLP = 0
      END IF
      IF ((EPSTFLP.EQ.0)) THEN
11300   CONTINUE
          DO 11301 IM=1,NUMSTMED
          DO 11311 J=1,LMED
            IF((IDSTRN(J).NE.MEDTBL(J,IM)))GO TO 11301
11311     CONTINUE
11312     CONTINUE
          AFACT=STDATA(1,IM)
          SK=STDATA(2,IM)
          X0=STDATA(3,IM)
          X1=STDATA(4,IM)
          IEV=STDATA(5,IM)
          CBAR=STDATA(6,IM)
          IMEV=IEV*1.0E-6
          VPLASM=SQRT(EDEN*R0*C**2/PIP)
          GO TO 11320
11301   CONTINUE
11302   CONTINUE
        IM=0
        IF ((NEP.EQ.1)) THEN
          IZ=ZELEMP(1)
          IF ((IZ.EQ.1.OR.IZ.EQ.7.OR.IZ.EQ.8)) THEN
            WRITE(6,11330)
11330       FORMAT(' STOPPED IN SUBROUTINE SPINIT BECAUSE THIS',/, ' ELE
     *MENT (H, N, OR O) CAN ONLY EXIST AS A DIATOMIC MOLECULE.',/, ' REM
     *EDY:  USE COMP OPTION FOR H2, N2, OR O2 WITH NE=2,PZ=1,1'/, '     
     *AND, IN THE CASE OF A GAS, DEFINE STERNHEIMER ID',/, '   (I.E., ID
     *STRN) LIKE H2-GAS')
            call exit(21)
          END IF
          IEV=ITBL(IZ)
        ELSE
          ALIADG=0.0
          DO 11341 IE=1,NEP
            IZ=ZELEMP(IE)
            IF ((IZ.EQ.1)) THEN
              IEV=19.2
            ELSE IF((IZ.EQ.6)) THEN
              IF ((GASPP.EQ.0.0)) THEN
                IEV=81.0
              ELSE
                IEV=70.0
              END IF
            ELSE IF((IZ.EQ.7)) THEN
              IEV=82.0
            ELSE IF((IZ.EQ.8)) THEN
              IF ((GASPP.EQ.0.0)) THEN
                IEV=106.0
              ELSE
                IEV=97.0
              END IF
            ELSE IF((IZ.EQ.9)) THEN
              IEV=112.0
            ELSE IF((IZ.EQ.17)) THEN
              IEV=180.0
            ELSE
              IEV=1.13*ITBL(IZ)
            END IF
            ALIADG=ALIADG + PZP(IE)*ZELEMP(IE)*LOG(IEV)
11341     CONTINUE
11342     CONTINUE
          ALIADG=ALIADG/ZC
          IEV=EXP(ALIADG)
        END IF
        IMEV=IEV*1.0E-6
        IF ((GASPP.EQ.0.0)) THEN
          EDENL=EDEN
        ELSE
          EDENL=EDEN/GASPP
        END IF
        VPLASM = SQRT(EDENL*R0*C**2/PIP)
        CBAR=1. + 2.*LOG(IMEV/(HBAR*2*PIP*VPLASM/ERGMEV))
        IF ((NEP.EQ.1.AND.INT(ZELEMP(1)).EQ.2.AND.GASPP.NE.0.0)) THEN
          X0=2.191
          X1=3.0
          SK=3.297
        ELSE IF((NEP.EQ.2.AND.INT(ZELEMP(1)).EQ.1 .AND.INT(ZELEMP(2)).EQ
     *  .1)) THEN
          IF ((GASPP.EQ.0.0)) THEN
            X0=0.425
            X1=2.0
            SK=5.949
          ELSE
            X0=1.837
            X1=3.0
            SK=4.754
          END IF
        ELSE
          SK=3.0
          IF ((GASPP.EQ.0.0)) THEN
            IF ((IEV.LT.100.0)) THEN
              IF ((CBAR.LT.3.681)) THEN
                X0=0.2
                X1=2.0
              ELSE
                X0=0.326*CBAR - 1.0
                X1=2.0
              END IF
            ELSE
              IF ((CBAR.LT.5.215)) THEN
                X0=0.2
                X1=3.0
              ELSE
                X0=0.326*CBAR - 1.5
                X1=3.0
              END IF
            END IF
            IF ((X0.GE.X1)) THEN
              WRITE(6,11350)X0,X1,CBAR
11350         FORMAT(' STOPPED IN SPINIT DUE TO X0.GE.X1 , X0,X1,CBAR=',
     *3G15.5,/ ,' IF THIS IS GAS, YOU MUST DEFINE GASP(ATM)')
              call exit(21)
            END IF
          ELSE
            IF ((CBAR.LT.10.0)) THEN
              X0=1.6
              X1=4.0
            ELSE IF((CBAR.LT.10.5)) THEN
              X0=1.7
              X1=4.0
            ELSE IF((CBAR.LT.11.0)) THEN
              X0=1.8
              X1=4.0
            ELSE IF((CBAR.LT.11.5)) THEN
              X0=1.9
              X1=4.0
            ELSE IF((CBAR.LT.12.25)) THEN
              X0=2.0
              X1=4.0
            ELSE IF((CBAR.LT.13.804)) THEN
              X0=2.0
              X1=5.0
            ELSE
              X0=0.326*CBAR - 2.5
              X1=5.0
            END IF
          END IF
        END IF
11320   IF ((GASPP.NE.0.0)) THEN
          ALGASP=LOG(GASPP)
          CBAR=CBAR - ALGASP
          X0=X0 - ALGASP/TOLN10
          X1=X1 - ALGASP/TOLN10
        END IF
        IF ((IM.EQ.0)) THEN
          AFACT=(CBAR - TOLN10*X0)/(X1 - X0)**SK
        END IF
      ELSE
        density_file=density_file(:lnblnk1(density_file))
        density_unit=20
        density_unit=egs_get_unit(density_unit)
        IF (( density_unit .LT. 1 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'SPINIT: failed to get a free fortran unit'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(density_unit,file=density_file,status='old',err=7600)
        READ(density_unit,11360)EPSTTL
11360   FORMAT(A)
        READ(density_unit,*) NEPST,IEV,EPSTRH,NELEPS
        READ(density_unit,*) (ZEPST(I),WEPST(I),I=1,NELEPS)
        READ(density_unit,*) (EPSTEN(I),EPSTD(I),I=1,NEPST)
        close(density_unit)
        IF ((NEPST.GT.150)) THEN
          WRITE(6,11370)NEPST
11370     FORMAT(//' *****NEPST=',I4,' IS GREATER THAN THE 150 ALLOWED')
          call exit(22)
        END IF
        DO 11381 I=1,NEPST
          EPSTEN(I) = EPSTEN(I) + RMP
11381   CONTINUE
11382   CONTINUE
        IMEV = IEV*1.E-06
        IF (( AEP .LT. EPSTEN(1))) THEN
          WRITE(6,11390)EPSTEN(1),AEP
11390     FORMAT(//' ****LOWEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,E
     *10.3/ T20,'WHICH IS HIGHER THAN THE VALUE OF AE=',1P,E10.3,' MEV'/
     * ' ***IT HAS BEEN SET TO AE***'//)
          EPSTEN(1) = AEP
        END IF
        IF (( UEP .GT. EPSTEN(NEPST))) THEN
          WRITE(6,11400)EPSTEN(NEPST),UEP
11400     FORMAT(//' ****HIGHEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,
     *E10.3/ T20,'WHICH IS LOWER THAN THE VALUE OF UE=',1P,E10.3,' MEV'/
     * ' ***IT HAS BEEN SET TO UE***'//)
          EPSTEN(NEPST) = UEP
        END IF
        ICHECK=0
        TLRNCE=0.01
        IF((NELEPS.NE.NEP))ICHECK=1
        IF(((ICHECK.EQ.0) .AND. ( (EPSTRH.LT.((1.0-TLRNCE)*RHOP)) .OR. (
     *  EPSTRH.GT.((1.0+TLRNCE)*RHOP)) )))ICHECK=1
        EPSTWT = 0.0
        DO 11411 I=1,NEP
          EPSTWT = EPSTWT + RHOZP(I)
11411   CONTINUE
11412   CONTINUE
        IF ((EPSTWT.EQ.0.0)) THEN
          WRITE(6,11420)
11420     FORMAT(//' *****IN SPINIT***SOMETHING WRONG, MOLECULAR WEIGHTO
     *F', 'MOLECULE IS ZERO (I.E. SUM OF RHOZ)***'//)
        END IF
        IF ((ICHECK.EQ.0)) THEN
          IESPEL=0
          ICHECK=1
11431     CONTINUE
            IESPEL=IESPEL+1
            IPEGEL=0
11441       CONTINUE
              IPEGEL=IPEGEL+1
              IF ((INT(ZELEMP(IPEGEL)).EQ.ZEPST(IESPEL))) THEN
                ICHECK=0
                GO TO11442
              END IF
              IF(IPEGEL.GE.NEP)GO TO11442
            GO TO 11441
11442       CONTINUE
            IF(((ICHECK.EQ.0)  .AND. ( (WEPST(IESPEL).LT.((1.0-TLRNCE)*R
     *      HOZP(IPEGEL)/EPSTWT)) .OR. (WEPST(IESPEL).GT.((1.0+TLRNCE)*R
     *      HOZP(IPEGEL)/EPSTWT)) )))ICHECK=1
            IF(IESPEL.GE.NELEPS)GO TO11432
          GO TO 11431
11432     CONTINUE
        END IF
        IF ((ICHECK.EQ.1)) THEN
          WRITE(6,11450)
11450     FORMAT(////'0*** COMPOSITION IN INPUT DENSITY FILE DOES NOT MA
     *TCH ', ' THAT BEING USED BY PEGS'//' ***** QUITTING EARLY***'////)
          call exit(23)
        END IF
      END IF
      SPC1=2.*PIP*R0**2*RMP*EDEN*RLCP
      SPC2=LOG((IMEV/RMP)**2/2.0)
      RETURN
7600  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' Failed to open density file ',density_file
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      RETURN
      END
      SUBROUTINE MIX
      implicit none
      integer*4 I,IZZ
      real*4 AL183,ZAB,V2000
      real*4 FCOULCP,XSIFP
      COMMON/MIMSD/BMIN
      real*4 BMIN
      COMMON/MIXDAT/NEP,LMED,PZP(50),ZELEMP(50),WAP(50),RHOZP(50), GASPP
     *,EZ,TPZ,IDSTRN(24)
      integer*4 NEP,LMED
      real*4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ
      CHARACTER*4 IDSTRN
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183
      real*4 ALRAD,ALRADP,A1440,A183
      COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6), DE
     *LCMP,ALPHIP(2),BPARP(2),DELPOSP(2)
      real*4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP
      real*4 XSI(20),ZZX(20),FZC(20),FCOUL(20),ZZ(20)
      IF ((GASPP.NE.0.0)) THEN
        RHOP=GASPP*RHOP
      END IF
      AL183 = LOG(A183)
      TPZ=0.0
      WM=0.0
      ZC=0.0
      ZT=0.0
      ZB=0.0
      ZF=0.0
      ZS=0.0
      ZE=0.0
      ZX=0.0
      ZAB=0.0
      DO 11461 I=1,NEP
        TPZ = TPZ + PZP(I)
        WM = WM + PZP(I)*WAP(I)
        ZC = ZC + PZP(I)*ZELEMP(I)
        FZC(I) =(FSC*ZELEMP(I))**2
        FCOUL(I) = FCOULCP(ZELEMP(I))
        XSI(I) = XSIFP (ZELEMP(I))
        ZZX(I) = PZP(I)*ZELEMP(I)*(ZELEMP(I)+XSI(I))
        IF ((ZELEMP(I).LE.4.0)) THEN
          IZZ=ZELEMP(I)
          ZAB=ZAB+ZZX(I)*ALRAD(IZZ)
        ELSE
          ZAB=ZAB+ZZX(I)*(AL183+LOG(ZELEMP(I)**(-1./3.)))
        END IF
        ZT = ZT + ZZX(I)
        ZB = ZB + ZZX(I)*LOG(ZELEMP(I)**(-1./3.))
        ZF = ZF + ZZX(I)*FCOUL(I)
        ZZ(I) = PZP(I)*ZELEMP(I)*(ZELEMP(I)+1.0)
        ZS = ZS + ZZ(I)
        ZE = ZE + ZZ(I)*((-2./3.)*LOG(ZELEMP(I)))
        ZX = ZX + ZZ(I)*LOG(1.+3.34*FZC(I))
11461 CONTINUE
11462 CONTINUE
      EZ = ZC/TPZ
      ZA = AL183*ZT
      ZG = ZB/ZT
      ZP = ZB/ZA
      ZV = (ZB-ZF)/ZT
      ZU = (ZB-ZF)/ZA
      EDEN=AN*RHOP/WM*ZC
      RLCP = 1./( (AN*RHOP/WM)*4.0*FSC*R0**2*(ZAB-ZF) )
      BLCCP= A6680*RHOP*ZS*EXP(ZE/ZS)*RLCP/(WM*EXP(ZX/ZS))
      TEFF0P = ( EXP(BMIN)/BMIN )/BLCCP
      XCCP= (A22P9/RADDEG) * SQRT( ZS*RHOP*RLCP/WM )
      XR0P = XCCP*SQRT(TEFF0P*BMIN)
      RETURN
      END
      SUBROUTINE DIFFER
      implicit none
      real*4 AL183,F10,F20,A1DEN,A2DEN,B1DEN,B2DEN,C1DEN,C2DEN
      INTEGER I
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6), DE
     *LCMP,ALPHIP(2),BPARP(2),DELPOSP(2)
      real*4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP
      COMMON/DBRPR/ALFP1(2),ALFP2(2),AL2
      real*4 ALFP1,ALFP2,al2
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183
      real*4 ALRAD,ALRADP,A1440,A183
      AL2 = LOG(2.)
      AL183= LOG(A183)
      ALPHIP(1)= AL2*(4./3. + 1./(9.*AL183*(1.+ZP)))
      ALPHIP(2)= AL2*(4./3. + 1./(9.*AL183*(1.+ZU)))
      ALFP1(1)= 2./3. - 1./(36.*AL183*(1.+ZP))
      ALFP1(2)= 2./3. - 1./(36.*AL183*(1.+ZU))
      ALFP2(1)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZP)))
      ALFP2(2)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZU)))
      BPARP(1)= ALFP1(1)/(ALFP1(1)+ALFP2(1))
      BPARP(2)= ALFP1(2)/(ALFP1(2)+ALFP2(2))
      DELCMP= 136.0*EXP(ZG)*RMP
      DELPOSP(1)= (EXP((21.12+4.*ZG)/4.184)-0.952)/DELCMP
      DELPOSP(2)= (EXP((21.12+4.*ZV)/4.184)-0.952)/DELCMP
      F10=4.*AL183
      F20=F10 - 2./3.
      A1DEN =3.0*F10- F20 + 8.0*ZG
      A2DEN =3.0*F10- F20 + 8.0*ZV
      B1DEN = F10 + 4.0*ZG
      B2DEN = F10 + 4.0*ZV
      C1DEN = 3.0*F10+ F20 + 16.0*ZG
      C2DEN = 3.0*F10+ F20 + 16.0*ZV
      DLP1(1)= (3.0*20.867-20.209+8.0*ZG)/A1DEN
      DLP2(1)= (3.0*(-3.242)-(-1.930))/A1DEN
      DLP3(1)= (3.0*(0.625)-(0.086))/A1DEN
      DLP4(1)= (2.0*21.12+8.0*ZG)/A1DEN
      DLP5(1)= 2.0*(-4.184)/A1DEN
      DLP6(1)= 0.952
      DLP1(4)= (3.0*20.867-20.209+8.0*ZV)/A2DEN
      DLP2(4)= (3.0*(-3.242)-(-1.930))/A2DEN
      DLP3(4)= (3.0*(0.625)-(0.086))/A2DEN
      DLP4(4)= (2.0*21.12+8.0*ZV)/A2DEN
      DLP5(4)= 2.0*(-4.184)/A2DEN
      DLP6(4)= 0.952
      DLP1(2)= (20.867+4.0*ZG)/B1DEN
      DLP2(2)= -3.242/B1DEN
      DLP3(2)= 0.625/B1DEN
      DLP4(2)= (21.12+4.0*ZG)/B1DEN
      DLP5(2)= -4.184/B1DEN
      DLP6(2)= 0.952
      DLP1(5)= (20.867+4.0*ZV)/B2DEN
      DLP2(5)= -3.242/B2DEN
      DLP3(5)= 0.625/B2DEN
      DLP4(5)= (21.12+4.0*ZV)/B2DEN
      DLP5(5)= -4.184/B2DEN
      DLP6(5)= 0.952
      DLP1(3)= (3.0*20.867+20.209+16.0*ZG)/C1DEN
      DLP2(3)= (3.0*(-3.242)+(-1.930))/C1DEN
      DLP3(3)= (3.0*0.625+(-0.086))/C1DEN
      DLP4(3)= (4.0*21.12+16.0*ZG)/C1DEN
      DLP5(3)= 4.0*(-4.184)/C1DEN
      DLP6(3)= 0.952
      DLP1(6)= (3.0*20.867+20.209+16.0*ZV)/C2DEN
      DLP2(6)= (3.0*(-3.242)+(-1.930))/C2DEN
      DLP3(6)= (3.0*0.625+(-0.086))/C2DEN
      DLP4(6)= (4.0*21.12+16.0*ZV)/C2DEN
      DLP5(6)= 4.0*(-4.184)/C2DEN
      DLP6(6)= 0.952
      RETURN
      END
      real*4 function FCOULCP(Z)
      implicit none
      real*4 Z,ASQ
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      ASQ=(FSC*Z)**2
      FCOULCP = ASQ*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+ ASQ*(0.0083+ASQ
     **(-0.002))))
      RETURN
      END
      real*4 function XSIFP(Z)
      implicit none
      real*4 Z,FCOULCP
      integer*4 IZ
      COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183
      real*4 ALRAD,ALRADP,A1440,A183
      IF ((Z.LE.4.0)) THEN
        IZ=Z
        XSIFP=ALRADP(IZ)/(ALRAD(IZ)-FCOULCP(Z))
      ELSE
        XSIFP=ALOG(A1440*Z**(-2./3.))/(ALOG(A183*Z**(-1./3.))-FCOULCP(Z)
     *  )
      END IF
      RETURN
      END
      real*4 FUNCTION ZTBL(IASYM)
      implicit none
      COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100)
      integer*4 NET
      real*4 ITBL,WATBL,RHOTBL
      CHARACTER*4 ASYMT
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      CHARACTER*4 IASYM,IA
      integer*4 ie
      DATA IA/'A'/
      save ia
      IF ((IASYM.EQ.IA)) THEN
        ZTBL=18.0
        RETURN
      END IF
      DO 11471 IE=1,NET
        IF ((IASYM.EQ.ASYMT(IE))) THEN
          ZTBL=IE
          RETURN
        END IF
11471 CONTINUE
11472 CONTINUE
      WRITE(6,11480)IASYM,NET
11480 FORMAT(1X,A2,' NOT AN ATOMIC SYMBOL FOR AN ELEMENT WITH Z LE ',I3)
      ZTBL=0.0
      RETURN
      END
      SUBROUTINE ANNIH
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DOUBLE PRECISION PAVIP,  PESG1,  PESG2
      real*8 AVIP,  A,                  G,T,P,                      POT,
     *
     *     EP0,                                                 WSAMP,
     *                       RNNO01,
     *                     RNNO02,
     *                                   EP,
     * REJF,                                                       ESG1,
     *                                      ESG2,
     *               aa,bb,cc,sinpsi,sindel,cosdel,us,vs,cphi,sphi
      integer*4
     *                     ibr
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      integer*4 ip
      NPold = NP
      IF (( nbr_split .LE. 0 )) THEN
        return
      END IF
      PAVIP=E(NP)+PRM
      AVIP=PAVIP
      A=AVIP/RM
      G=A-1.0
      T=G-1.0
      P=SQRT(A*T)
      POT=P/T
      EP0=1.0/(A+P)
      WSAMP=LOG((1.0-EP0)/EP0)
      aa = u(np)
      bb = v(np)
      cc = w(np)
      sinpsi = aa*aa + bb*bb
      IF (( sinpsi .GT. 1e-20 )) THEN
        sinpsi = sqrt(sinpsi)
        sindel = bb/sinpsi
        cosdel = aa/sinpsi
      END IF
      IF (( nbr_split .GT. 1 )) THEN
        wt(np) = wt(np)/nbr_split
      END IF
      DO 11491 ibr=1,nbr_split
        IF (( np+1 .GT. 500 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//a,i6,a//)') ' Stack overflow in ANNIH! np = ',
     *    np+1, ' Increase $MXSTACK and try again'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
11501   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO01 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          EP=EP0*EXP(RNNO01*WSAMP)
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO02 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          REJF = 1 - (EP*A-1)**2/(EP*(A*A-2))
          IF(((RNNO02 .LE. REJF)))GO TO11502
        GO TO 11501
11502   CONTINUE
        ESG1=AVIP*EP
        PESG1=ESG1
        E(NP)=PESG1
        IQ(NP)=0
        IF (( ibr .EQ. 1 )) THEN
          ip = npold
        ELSE
          ip = np-1
        END IF
        X(np)=X(ip)
        Y(np)=Y(ip)
        Z(np)=Z(ip)
        IR(np)=IR(ip)
        WT(np)=WT(ip)
        DNEAR(np)=DNEAR(ip)
        LATCH(np)=LATCH(ip)
        COSTHE=MAX(-1.0,MIN(1.0,(ESG1-RM)*POT/ESG1))
        SINTHE=SQRT(1.0-COSTHE*COSTHE)
11511   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          xphi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          xphi = 2*xphi - 1
          xphi2 = xphi*xphi
          IF((rng_seed .GT. 128))call ranmar_get
          yphi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          yphi2 = yphi*yphi
          rhophi2 = xphi2 + yphi2
          IF(rhophi2.LE.1)GO TO11512
        GO TO 11511
11512   CONTINUE
        rhophi2 = 1/rhophi2
        cphi = (xphi2 - yphi2)*rhophi2
        sphi = 2*xphi*yphi*rhophi2
        IF (( sinpsi .GE. 1e-10 )) THEN
          us = sinthe*cphi
          vs = sinthe*sphi
          u(np) = cc*cosdel*us - sindel*vs + aa*costhe
          v(np) = cc*sindel*us + cosdel*vs + bb*costhe
          w(np) = cc*costhe - sinpsi*us
        ELSE
          u(np) = sinthe*cphi
          v(np) = sinthe*sphi
          w(np) = cc*costhe
        END IF
        np = np + 1
        PESG2=PAVIP-PESG1
        esg2 = pesg2
        e(np) = pesg2
        iq(np) = 0
        X(np)=X(np-1)
        Y(np)=Y(np-1)
        Z(np)=Z(np-1)
        IR(np)=IR(np-1)
        WT(np)=WT(np-1)
        DNEAR(np)=DNEAR(np-1)
        LATCH(np)=LATCH(np-1)
        COSTHE=MAX(-1.0,MIN(1.0,(ESG2-RM)*POT/ESG2))
        SINTHE=-SQRT(1.0-COSTHE*COSTHE)
        IF (( sinpsi .GE. 1e-10 )) THEN
          us = sinthe*cphi
          vs = sinthe*sphi
          u(np) = cc*cosdel*us - sindel*vs + aa*costhe
          v(np) = cc*sindel*us + cosdel*vs + bb*costhe
          w(np) = cc*costhe - sinpsi*us
        ELSE
          u(np) = sinthe*cphi
          v(np) = sinthe*sphi
          w(np) = cc*costhe
        END IF
        np = np + 1
11491 CONTINUE
11492 CONTINUE
      np = np-1
      RETURN
      END
      SUBROUTINE ANNIH_AT_REST
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 costhe,sinthe,cphi,sphi
      integer*4 ibr,ip
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      NPold = NP
      IF (( np+2*nbr_split-1 .GT. 500 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','ANNIH_AT_RES
     *T', ' stack size exceeded! ',' $MAXSTACK = ',500,' np = ',np+2*nbr
     *  _split-1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( nbr_split .GT. 1 )) THEN
        wt(np) = wt(np)/nbr_split
      END IF
      DO 11521 ibr=1,nbr_split
        IF((rng_seed .GT. 128))call ranmar_get
        costhe = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        costhe = 2*costhe-1
        sinthe = sqrt(max(0.0,(1-costhe)*(1+costhe)))
11531   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          xphi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          xphi = 2*xphi - 1
          xphi2 = xphi*xphi
          IF((rng_seed .GT. 128))call ranmar_get
          yphi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          yphi2 = yphi*yphi
          rhophi2 = xphi2 + yphi2
          IF(rhophi2.LE.1)GO TO11532
        GO TO 11531
11532   CONTINUE
        rhophi2 = 1/rhophi2
        cphi = (xphi2 - yphi2)*rhophi2
        sphi = 2*xphi*yphi*rhophi2
        e(np) = prm
        iq(np) = 0
        IF (( ibr .EQ. 1 )) THEN
          ip = npold
        ELSE
          ip = np-1
        END IF
        X(np)=X(ip)
        Y(np)=Y(ip)
        Z(np)=Z(ip)
        IR(np)=IR(ip)
        WT(np)=WT(ip)
        DNEAR(np)=DNEAR(ip)
        LATCH(np)=LATCH(ip)
        u(np) = sinthe*cphi
        v(np) = sinthe*sphi
        w(np) = costhe
        np = np+1
        e(np) = prm
        iq(np) = 0
        X(np)=X(np-1)
        Y(np)=Y(np-1)
        Z(np)=Z(np-1)
        IR(np)=IR(np-1)
        WT(np)=WT(np-1)
        DNEAR(np)=DNEAR(np-1)
        LATCH(np)=LATCH(np-1)
        u(np) = -u(np-1)
        v(np) = -v(np-1)
        w(np) = -w(np-1)
        np = np+1
11521 CONTINUE
11522 CONTINUE
      np = np-1
      return
      end
      SUBROUTINE BHABHA
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DOUBLE PRECISION PEIP,  PEKIN,  PEKSE2,  PESE1,  PESE2,  H1,  DCOS
     *TH
      real*8 EIP,  EKIN,  T0,  E0,  E02,  YY,  Y2,YP,YP2, BETA2,  EP0,
     *EP0C,  B1,B2,B3,B4,  RNNO03,RNNO04, BR,  REJF2,  ESE1,  ESE2
      NPold = NP
      PEIP=E(NP)
      EIP=PEIP
      PEKIN=PEIP-PRM
      EKIN=PEKIN
      T0=EKIN/RM
      E0=T0+1.
      YY=1./(T0+2.)
      E02=E0*E0
      BETA2=(E02-1.)/E02
      EP0=TE(MEDIUM)/EKIN
      EP0C=1.-EP0
      Y2=YY*YY
      YP=1.-2.*YY
      YP2=YP*YP
      B4=YP2*YP
      B3=B4+YP2
      B2=YP*(3.+Y2)
      B1=2.-Y2
11541 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO03 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        BR=EP0/(1.-EP0C*RNNO03)
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO04 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        REJF2=(1.0-BETA2*BR*(B1-BR*(B2-BR*(B3-BR*B4))))
        IF((RNNO04.LE.REJF2))GO TO11542
      GO TO 11541
11542 CONTINUE
      IF (( np+1 .GT. 500 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','BHABHA', ' s
     *tack size exceeded! ',' $MAXSTACK = ',500,' np = ',np+1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF ((BR.LT.0.5)) THEN
        IQ(NP+1)=-1
      ELSE
        IQ(NP)=-1
        IQ(NP+1)=1
        BR=1.-BR
      END IF
      BR=max(BR,0.0)
      PEKSE2=BR*EKIN
      PESE1=PEIP-PEKSE2
      PESE2=PEKSE2+PRM
      ESE1=PESE1
      ESE2=PESE2
      E(NP)=PESE1
      E(NP+1)=PESE2
      H1=(PEIP+PRM)/PEKIN
      DCOSTH=MIN(1.0D0,H1*(PESE1-PRM)/(PESE1+PRM))
      SINTHE=DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(2,1)
      NP=NP+1
      DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM)
      SINTHE=-DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(3,2)
      RETURN
      END
      SUBROUTINE BREMS
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/nist_brems/ nb_fdata(0:50,100,10), nb_xdata(0:50,100,10), n
     *b_wdata(50,100,10), nb_idata(50,100,10), nb_emin(10),nb_emax(10),
     *nb_lemin(10),nb_lemax(10), nb_dle(10),nb_dlei(10), log_ap(10)
      real*8 nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lema
     *x, nb_dle,nb_dlei,log_ap
      integer*4 nb_idata
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DOUBLE PRECISION PEIE,  PESG,  PESE
      real*8 EIE,  EKIN,  brmin,  waux,  aux,  r1,  ajj,  alias_sample1,
     * RNNO06,  RNNO07,  BR,  ESG,  ESE,  DELTA,  phi1,  phi2,  REJF
      real*8 a,b,c,                               sinpsi, sindel, cosdel
     *, us, vs,
     *                                                ztarg,
     *             tteie,                                    beta,
     *                       y2max,
     *      y2maxi,                                                   tt
     *ese,                                      rjarg1,rjarg2,rjarg3,rej
     *min,rejmid,rejmax,rejtop,rejtst,
     *                 esedei,                                 y2tst,
     *                             y2tst1,
     *                                           rtest,
     *                            xphi,yphi,xphi2,yphi2,rhophi2,cphi,sph
     *i
      integer*4
     *                 L,L1,ibr,jj,j
      real*8 z2max,z2maxi,aux1,aux3,aux4,aux5,aux2,weight
      IF((nbr_split .LT. 1))return
      NPold = NP
      PEIE=E(NP)
      EIE=PEIE
      weight = wt(np)/nbr_split
      IF ((EIE.LT.50.0)) THEN
        L=1
      ELSE
        L=3
      END IF
      L1 = L+1
      ekin = peie-prm
      brmin = ap(medium)/ekin
      waux = elke - log_ap(medium)
      IF (( ibrdst .GE. 0 )) THEN
        a = u(np)
        b = v(np)
        c = w(np)
        sinpsi = a*a + b*b
        IF (( sinpsi .GT. 1e-20 )) THEN
          sinpsi = sqrt(sinpsi)
          sindel = b/sinpsi
          cosdel = a/sinpsi
        END IF
        ztarg = zbrang(medium)
        tteie = eie/rm
        beta = sqrt((tteie-1)*(tteie+1))/tteie
        y2max = 2*beta*(1+beta)*tteie*tteie
        y2maxi = 1/y2max
        IF (( ibrdst .EQ. 1 )) THEN
          z2max = y2max+1
          z2maxi = sqrt(z2max)
        END IF
      END IF
      IF (( ibr_nist .GE. 1 )) THEN
        ajj = 1 + (waux + log_ap(medium) - nb_lemin(medium))*nb_dlei(med
     *  ium)
        jj = ajj
        ajj = ajj - jj
        IF (( jj .GT. 100 )) THEN
          jj = 100
          ajj = -1
        END IF
      END IF
      DO 11551 ibr=1,nbr_split
        IF (( ibr_nist .GE. 1 )) THEN
          IF (( ekin .GT. nb_emin(medium) )) THEN
            IF((rng_seed .GT. 128))call ranmar_get
            r1 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF (( r1 .LT. ajj )) THEN
              j = jj+1
            ELSE
              j = jj
            END IF
            br = alias_sample1(50,nb_xdata(0,j,medium), nb_fdata(0,j,med
     *      ium), nb_wdata(1,j,medium),nb_idata(1,j,medium))
          ELSE
            IF((rng_seed .GT. 128))call ranmar_get
            br = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
          END IF
          esg = ap(medium)*exp(br*waux)
          pesg = esg
          pese = peie - pesg
          ese = pese
        ELSE
11561     CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            rnno06 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rng_seed .GT. 128))call ranmar_get
            rnno07 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            br = brmin*exp(rnno06*waux)
            esg = ekin*br
            pesg = esg
            pese = peie - pesg
            ese = pese
            delta = esg/eie/ese*delcm(medium)
            aux = ese/eie
            IF (( delta .LT. 1 )) THEN
              phi1 = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medi
     *        um))
              phi2 = dl1(l1,medium)+delta*(dl2(l1,medium)+ delta*dl3(l1,
     *        medium))
            ELSE
              phi1 = dl4(l,medium)+dl5(l,medium)*log(delta+dl6(l,medium)
     *        )
              phi2 = phi1
            END IF
            rejf = (1+aux*aux)*phi1 - 2*aux*phi2/3
            IF(((rnno07 .LT. rejf)))GO TO11562
          GO TO 11561
11562     CONTINUE
        END IF
        np=np+1
        IF (( np .GT. 500 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//a,i6,a//)') ' Stack overflow in BREMS! np = ',
     *    np+1, ' Increase $MXSTACK and try again'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        e(np) = pesg
        iq(np) = 0
        X(np)=X(np-1)
        Y(np)=Y(np-1)
        Z(np)=Z(np-1)
        IR(np)=IR(np-1)
        WT(np)=WT(np-1)
        DNEAR(np)=DNEAR(np-1)
        LATCH(np)=LATCH(np-1)
        wt(np) = weight
        IF (( ibrdst .LT. 0 )) THEN
          u(np) = u(npold)
          v(np) = v(npold)
          w(np) = w(npold)
        ELSE
          IF (( ibrdst .EQ. 1 )) THEN
            ttese = ese/rm
            esedei = ttese/tteie
            rjarg1 = 1+esedei*esedei
            rjarg2 = rjarg1 + 2*esedei
            aux = 2*ese*tteie/esg
            aux = aux*aux
            aux1 = aux*ztarg
            IF (( aux1 .GT. 10 )) THEN
              rjarg3 = lzbrang(medium) + (1-aux1)/aux1**2
            ELSE
              rjarg3 = log(aux/(1+aux1))
            END IF
            rejmax = rjarg1*rjarg3-rjarg2
11571       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              y2tst = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF((rng_seed .GT. 128))call ranmar_get
              rtest = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              aux3 = z2maxi/(y2tst+(1-y2tst)*z2maxi)
              rtest = rtest*aux3*rejmax
              y2tst = aux3**2-1
              y2tst1 = esedei*y2tst/aux3**4
              aux4 = 16*y2tst1-rjarg2
              aux5 = rjarg1-4*y2tst1
              IF((rtest .LT. aux4 + aux5*rjarg3))GO TO11572
              aux2 = log(aux/(1+aux1/aux3**4))
              rejtst = aux4+aux5*aux2
              IF(((rtest .LT. rejtst )))GO TO11572
            GO TO 11571
11572       CONTINUE
          ELSE
            IF((rng_seed .GT. 128))call ranmar_get
            y2tst = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            y2tst = y2tst/(1-y2tst+y2maxi)
          END IF
          costhe = 1 - 2*y2tst*y2maxi
          sinthe = sqrt(max((1-costhe)*(1+costhe),0.0))
11581     CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            xphi = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            xphi = 2*xphi - 1
            xphi2 = xphi*xphi
            IF((rng_seed .GT. 128))call ranmar_get
            yphi = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            yphi2 = yphi*yphi
            rhophi2 = xphi2 + yphi2
            IF(rhophi2.LE.1)GO TO11582
          GO TO 11581
11582     CONTINUE
          rhophi2 = 1/rhophi2
          cphi = (xphi2 - yphi2)*rhophi2
          sphi = 2*xphi*yphi*rhophi2
          IF (( sinpsi .GE. 1e-10 )) THEN
            us = sinthe*cphi
            vs = sinthe*sphi
            u(np) = c*cosdel*us - sindel*vs + a*costhe
            v(np) = c*sindel*us + cosdel*vs + b*costhe
            w(np) = c*costhe - sinpsi*us
          ELSE
            u(np) = sinthe*cphi
            v(np) = sinthe*sphi
            w(np) = c*costhe
          END IF
        END IF
11551 CONTINUE
11552 CONTINUE
      e(npold) = pese
      RETURN
      END
      SUBROUTINE COMPT
      implicit none
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,10), eno_array(200,10), eno_atbin_array(200,10), n
     *_shell(10), radc_flag,  ibcmp( 12001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      DOUBLE PRECISION PEIG,  PESG,  PESE
      real*8 ko,  broi,  broi2,  bro,  bro1,  alph1,  alph2,  alpha,  rn
     *no15,rnno16,rnno17,rnno18,rnno19,  br,  temp,  rejf3,  rejmax,  Uj
     *,  Jo,  br2,  fpz,fpz1, qc,  qc2,  af,  Fmax,  frej,  eta_incoh, e
     *ta,  aux,aux1,aux2,aux3,aux4,  pzmax,  pz,  pz2,  rnno_RR
      integer*4 irl,  i,  j,  iarg,  ip
      logical first_time
      integer*4 ibcmpl
      NPold = NP
      peig=E(NP)
      ko = peig/rm
      broi = 1 + 2*ko
      irl = ir(np)
      first_time = .true.
      ibcmpl = ibcmp(irl)
11590 CONTINUE
      IF (( ibcmpl .GT. 0 )) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        rnno17 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        rnno17 = 1 + rnno17*n_shell(medium)
        i = int(rnno17)
        IF((rnno17 .GT. eno_array(i,medium)))i = eno_atbin_array(i,mediu
     *  m)
        j = shell_array(i,medium)
        Uj = be_array(j)
        IF (( ko .LE. Uj )) THEN
          IF (( ibcmpl .EQ. 1 )) THEN
            goto 11600
          ELSE
            goto 11590
          END IF
        END IF
        Jo = Jo_array(j)
      END IF
11610 CONTINUE
      IF (( ko .GT. 2 )) THEN
        IF (( first_time )) THEN
          broi2 = broi*broi
          alph1 = Log(broi)
          bro = 1/broi
          alph2 = ko*(broi+1)*bro*bro
          alpha = alph1+alph2
        END IF
11621   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          rnno15 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          rnno16 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF (( rnno15*alpha .LT. alph1 )) THEN
            br = Exp(alph1*rnno16)*bro
          ELSE
            br = Sqrt(rnno16*broi2 + (1-rnno16))*bro
          END IF
          temp = (1-br)/(ko*br)
          sinthe = Max(0.,temp*(2-temp))
          aux = 1+br*br
          rejf3 = aux - br*sinthe
          IF((rng_seed .GT. 128))call ranmar_get
          rnno19 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rnno19*aux.le.rejf3))GO TO11622
        GO TO 11621
11622   CONTINUE
      ELSE
        IF (( first_time )) THEN
          bro = 1./broi
          bro1 = 1 - bro
          rejmax = broi + bro
        END IF
11631   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          rnno15 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          rnno16 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          br = bro + bro1*rnno15
          temp = (1-br)/(ko*br)
          sinthe = Max(0.,temp*(2-temp))
          rejf3 = 1 + br*br - br*sinthe
          IF((rnno16*br*rejmax.le.rejf3))GO TO11632
        GO TO 11631
11632   CONTINUE
      END IF
      first_time = .false.
      IF ((br .LT. bro .OR. br .GT. 1)) THEN
        IF (( br .LT. 0.99999/broi .OR. br .GT. 1.00001 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' sampled br outside of allowed range! ',ko,1./
     *    broi,br
        END IF
        goto 11610
      END IF
      costhe = 1 - temp
      IF (( ibcmp(irl) .EQ. 0 )) THEN
        Uj = 0
        goto 11640
      END IF
      br2 = br*br
      aux = ko*(ko-Uj)*temp
      aux1 = 2*aux + Uj*Uj
      pzmax = aux - Uj
      IF (( pzmax .LT. 0 .AND. pzmax*pzmax .GE. aux1 )) THEN
        IF (( ibcmpl .EQ. 1 )) THEN
          goto 11600
        ELSE
          goto 11590
        END IF
      END IF
      pzmax = pzmax/sqrt(aux1)
      qc2 = 1 + br*br - 2*br*costhe
      qc = sqrt(qc2)
      IF (( pzmax .GT. 1 )) THEN
        pzmax = 1
        af = 0
        Fmax = 1
        fpz = 1
        goto 11650
      END IF
      aux3 = 1 + 2*Jo*abs(pzmax)
      aux4 = 0.5*(1-aux3*aux3)
      fpz = 0.5*exp(aux4)
      af = qc*(1+br*(br-costhe)/qc2)
      IF (( af .LT. 0 )) THEN
        IF((pzmax .GT. 0))fpz = 1 - fpz
        IF((rng_seed .GT. 128))call ranmar_get
        eta_incoh = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( eta_incoh .GT. fpz )) THEN
          IF (( ibcmpl .EQ. 1 )) THEN
            goto 11600
          ELSE
            goto 11590
          END IF
        END IF
        af = 0
        Fmax = 1
        goto 11650
      END IF
      IF (( pzmax .LT. -0.15 )) THEN
        Fmax = 1-af*0.15
        fpz1 = fpz*Fmax*Jo
      ELSE IF(( pzmax .LT. 0.15 )) THEN
        Fmax = 1 + af*pzmax
        aux3 = 1/(1+0.33267252734*aux3)
        aux4 = fpz*aux3*(0.3480242+aux3*(-0.0958798+aux3*0.7478556)) + e
     *  rfJo_array(j)
        IF (( pzmax .GT. 0 )) THEN
          fpz1 = (1 - Fmax*fpz)*Jo - 0.62665706866*af*aux4
          fpz = 1 - fpz
        ELSE
          fpz1 = Fmax*fpz*Jo - 0.62665706866*af*aux4
        END IF
      ELSE
        Fmax = 1 + af*0.15
        fpz1 = (1 - Fmax*fpz)*Jo
        fpz = 1 - fpz
      END IF
      IF((rng_seed .GT. 128))call ranmar_get
      eta_incoh = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF ((eta_incoh*Jo .GT. fpz1 )) THEN
        IF (( ibcmpl .EQ. 1 )) THEN
          goto 11600
        ELSE
          goto 11590
        END IF
      END IF
11650 CONTINUE
      IF (( ibcmpl .NE. 2 )) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        rnno18 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        rnno18 = rnno18*fpz
        IF (( rnno18 .LT. 0.5 )) THEN
          rnno18 = Max(1e-30,2*rnno18)
          pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo
        ELSE
          rnno18 = 2*(1-rnno18)
          pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo
        END IF
        IF((abs(pz) .GT. 1))goto 11650
        IF (( pz .LT. 0.15 )) THEN
          IF (( pz .LT. -0.15 )) THEN
            frej = 1 - af*0.15
          ELSE
            frej = 1 + af*pz
          END IF
          IF((rng_seed .GT. 128))call ranmar_get
          eta = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((eta*Fmax .GT. frej))goto 11650
        END IF
      ELSE
        pz = 0
        Uj = 0
      END IF
      pz2 = pz*pz
      IF (( abs(pz) .LT. 0.01 )) THEN
        br = br*(1 + pz*(qc + (br2-costhe)*pz))
      ELSE
        aux = 1 - pz2*br*costhe
        aux1 = 1 - pz2*br2
        aux2 = qc2 - br2*pz2*sinthe
        IF (( aux2 .GT. 1e-10 )) THEN
          br = br/aux1*(aux+pz*Sqrt(aux2))
        END IF
      END IF
      Uj = Uj*prm
11640 pesg = br*peig
      pese = peig - pesg - Uj + prm
      sinthe = Sqrt(sinthe)
      call uphi(2,1)
      e(np) = pesg
      aux = 1 + br*br - 2*br*costhe
      IF (( aux .GT. 1e-8 )) THEN
        costhe = (1-br*costhe)/Sqrt(aux)
        sinthe = (1-costhe)*(1+costhe)
        IF (( sinthe .GT. 0 )) THEN
          sinthe = -Sqrt(sinthe)
        ELSE
          sinthe = 0
        END IF
      ELSE
        costhe = 0
        sinthe = -1
      END IF
      np = np + 1
      IF (( np .GT. 500 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','COMPT', ' st
     *ack size exceeded! ',' $MAXSTACK = ',500,' np = ',np
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      call uphi(3,2)
      e(np) = pese
      iq(np) = -1
      IF (( ibcmpl .EQ. 1 .OR. ibcmpl .EQ. 3 )) THEN
        IF (( Uj .GT. 1e-3 )) THEN
          edep = pzero
          call relax(Uj,shn_array(j),iz_array(j))
        ELSE
          edep = Uj
          edep_local = edep
          IARG=33
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
        END IF
        IF (( edep .GT. 0 )) THEN
          IARG=4
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,11660)prob_RR
11660       FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold+1
11671     CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF((rng_seed .GT. 128))call ranmar_get
              rnno_RR = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO11672
          GO TO 11671
11672     CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
11600 return
      end
      SUBROUTINE old_COMPT
      implicit none
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,10), eno_array(200,10), eno_atbin_array(200,10), n
     *_shell(10), radc_flag,  ibcmp( 12001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      DOUBLE PRECISION PEIG,  PESG,  PESE
      real*8 ko,  broi,  broi2,  bro,  bro1,  alph1,  alph2,  alpha,  rn
     *no15,rnno16,rnno17,rnno18,rnno19,  br,  temp,  rejf3,  rejmax,  Uj
     *,  br2,  aux,aux1,aux2, pzmax2,  pz,  pz2,  rnno_RR
      integer*4 irl,  i,  j,  iarg,  ip
      i_survived_RR = 0
      NPold = NP
      peig=E(NP)
      ko = peig/rm
      broi = 1 + 2*ko
      irl = ir(np)
      IF (( ibcmp(irl) .EQ. 1 )) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        rnno17 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        DO 11681 i=1,n_shell(medium)
          rnno17 = rnno17 - eno_array(i,medium)
          IF((rnno17 .LE. 0))GO TO11682
11681   CONTINUE
11682   CONTINUE
        j = shell_array(i,medium)
        Uj = be_array(j)
        IF (( ko .LE. Uj )) THEN
          goto 11690
        END IF
      END IF
11700 CONTINUE
      IF (( ko .GT. 2 )) THEN
        broi2 = broi*broi
        alph1 = Log(broi)
        alph2 = ko*(broi+1)/broi2
        alpha = alph1/(alph1+alph2)
11711   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          rnno15 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          rnno16 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF (( rnno15 .LT. alpha )) THEN
            br = Exp(alph1*rnno16)/broi
          ELSE
            br = Sqrt(rnno16 + (1-rnno16)/broi2)
          END IF
          temp = (1-br)/ko/br
          sinthe = Max(0.,temp*(2-temp))
          rejf3 = 1 - br*sinthe/(1+br*br)
          IF((rng_seed .GT. 128))call ranmar_get
          rnno19 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rnno19.le.rejf3))GO TO11712
        GO TO 11711
11712   CONTINUE
      ELSE
        bro = 1./broi
        bro1 = 1 - bro
        rejmax = broi + bro
11721   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          rnno15 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          rnno16 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          br = bro + bro1*rnno15
          temp = (1-br)/ko/br
          sinthe = Max(0.,temp*(2-temp))
          rejf3 = (br + 1./br - sinthe)/rejmax
          IF((rnno16.le.rejf3))GO TO11722
        GO TO 11721
11722   CONTINUE
      END IF
      IF ((br .LT. 1./broi .OR. br .GT. 1)) THEN
        IF (( br .LT. 0.99999/broi .OR. br .GT. 1.00001 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' sampled br outside of allowed range! ',ko,1./
     *    broi,br
        END IF
        goto 11700
      END IF
      IF (( ibcmp(irl) .EQ. 0 )) THEN
        Uj = 0
        costhe = 1 - temp
        goto 11730
      END IF
      br2 = br*br
      costhe = 1 - temp
      aux = ko*(ko-Uj)*temp
      aux1 = aux-Uj
      pzmax2 = aux1*aux1/(2*aux+Uj*Uj)
11740 CONTINUE
      IF((rng_seed .GT. 128))call ranmar_get
      rnno18 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF (( rnno18 .LT. 0.5 )) THEN
        rnno18 = Max(1e-30,2*rnno18)
        pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo_array(j)
        pz2 = pz*pz
        IF (( (pz2 .LE. pzmax2) .AND. (aux1 .LT. 0) )) THEN
          goto 11690
        END IF
      ELSE
        IF (( aux1 .LT. 0 )) THEN
          goto 11690
        END IF
        rnno18 = 2*(1-rnno18)
        pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo_array(j)
        pz2 = pz*pz
        IF (( pz2 .GE. pzmax2 )) THEN
          goto 11690
        END IF
      END IF
      IF((abs(pz) .GT. 1))goto 11740
      aux = 1 - pz2*br*costhe
      aux1 = 1 - pz2*br2
      aux2 = 1-2*br*costhe+br2*(1-pz2*sinthe)
      IF (( aux2 .GT. 1e-10 )) THEN
        br = br/aux1*(aux+pz*Sqrt(aux2))
      END IF
      Uj = Uj*prm
11730 pesg = br*peig
      pese = peig - pesg - Uj + prm
      sinthe = Sqrt(sinthe)
      call uphi(2,1)
      e(np) = pesg
      aux = 1 + br*br - 2*br*costhe
      IF (( aux .GT. 1e-8 )) THEN
        costhe = (1-br*costhe)/Sqrt(aux)
        sinthe = (1-costhe)*(1+costhe)
        IF (( sinthe .GT. 0 )) THEN
          sinthe = -Sqrt(sinthe)
        ELSE
          sinthe = 0
        END IF
      ELSE
        costhe = 0
        sinthe = -1
      END IF
      np = np + 1
      IF (( np .GT. 500 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','COMPT', ' st
     *ack size exceeded! ',' $MAXSTACK = ',500,' np = ',np
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      call uphi(3,2)
      e(np) = pese
      iq(np) = -1
      IF (( ibcmp(irl) .EQ. 1 )) THEN
        IF (( Uj .GT. 1e-3 )) THEN
          edep = 0
          call relax(Uj,shn_array(j),iz_array(j))
        ELSE
          edep = Uj
        END IF
        IF (( edep .GT. 0 )) THEN
          IARG=4
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,11750)prob_RR
11750       FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold+1
11761     CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF((rng_seed .GT. 128))call ranmar_get
              rnno_RR = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO11762
          GO TO 11761
11762     CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
11690 return
      end
      SUBROUTINE ELECTR(IRCODE)
      implicit none
      integer*4 IRCODE
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/BOUNDS/ECUT( 12001),PCUT( 12001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      real*8 SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERRR/ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN, MINZ,MAXZ,MINR,MAXR
     *,IREJCT
      real*8 ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN
      integer*4 MINZ,MAXZ,MINR,MAXR,IREJCT
      COMMON/USERMI/EXPMFP,GWTOLD,ICSDA
      integer*4 ICSDA
      real*8 EXPMFP,GWTOLD
      COMMON/USERVR/ CEXPTR,GWAIT,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,
     *IQINC,MONOEN, cs_enhance,cs_enhance_current,ienhance,iefl( 12001),
     *ics_enhance, do_fast_step
      integer*4 ienhance,iefl,ics_enhance, IFORCE,NFMIN,NFMAX,NFTIME,ISO
     *URC,IFPB,IQINC,MONOEN
      real*8 CEXPTR,GWAIT,cs_enhance,cs_enhance_current
      logical do_fast_step
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/ET_control/ smaxir( 12001),estepe,ximax,  skindepth_for_bca
     *,transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(10), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),
     *eii_sh(40),  eii_nshells(100),  eii_nsh(10),  eii_first(10,50),  e
     *ii_no(10,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      real*8 lambda_max, sigratio, u_tmp, v_tmp, w_tmp
      LOGICAL random_tustep
      DOUBLE PRECISION  demfp,  peie,  total_tstep,  total_de
      real*8 ekems,  elkems,  chia2,  etap,  lambda,  blccl,  xccl,  xi,
     *  xi_corr,  ms_corr, p2,  beta2,  de,  save_de,  dedx,  dedx0,  de
     *dxmid,  ekei,  elkei,  aux,  ebr1,  eie,  ekef,  elkef,  ekeold,
     *eketmp,  elktmp,  fedep,  tuss,  pbr1,  pbr2,  range,  rfict,  rnn
     *e1,  rnno24,  rnno25,  rnnotu,  rnnoss,  sig,  sig0,  sigf,  skind
     *epth,  ssmfp,  tmxs,  tperp,  ustep0,  uscat,  vscat,  wscat,  xtr
     *ans,  ytrans,  ztrans,  cphi,sphi
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      integer*4 iarg,  idr,  ierust,  irl,  lelec,  qel,  lelke,  lelkem
     *s,  lelkef,  lelktmp,  ibr
      logical  callhowfar,   domultiple,  dosingle,   callmsdist,
     *                findindex,
     *              spin_index,                                   comput
     *e_tstep
     *
      data ierust/0/
      save ierust
      ircode = 1
      irold = ir(np)
      irl = irold
      medium = med(irl)
11770 CONTINUE
11771   CONTINUE
        lelec = iq(np)
        qel = (1+lelec)/2
        peie = e(np)
        eie = peie
        IF ((eie .LE. ecut(irl))) THEN
          go to 11780
        END IF
        IF ((WT(NP) .EQ. 0.0)) THEN
          go to 11790
        END IF
11800   CONTINUE
11801     CONTINUE
          compute_tstep = .true.
          eke = eie - rm
          IF ((medium .NE. 0)) THEN
            IF ((ICSDA.EQ.0)) THEN
              IF((rng_seed .GT. 128))call ranmar_get
              RNNE1 = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF ((RNNE1.EQ.0.0)) THEN
                RNNE1=1.E-30
              END IF
              DEMFP=MAX(-LOG(RNNE1),1.E-8)
            ELSE
              DEMFP=VACDST
            END IF
            elke = log(eke)
            Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
            IF (( sig_ismonotone(qel,medium) )) THEN
              IF ((lelec .LT. 0)) THEN
                sigf=esig1(Lelke,MEDIUM)*elke+esig0(Lelke,MEDIUM)
                dedx0=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
                sigf = sigf/dedx0
              ELSE
                sigf=psig1(Lelke,MEDIUM)*elke+psig0(Lelke,MEDIUM)
                dedx0=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
                sigf = sigf/dedx0
              END IF
              sig0 = sigf
            ELSE
              IF (( lelec .LT. 0 )) THEN
                sig0 = esig_e(medium)
              ELSE
                sig0 = psig_e(medium)
              END IF
            END IF
          END IF
11810     CONTINUE
11811       CONTINUE
            IF ((medium .EQ. 0)) THEN
              tstep = vacdst
              ustep = tstep
              tustep = ustep
              callhowfar = .true.
              ustep = tustep
            ELSE
              RHOF=RHOR(IRL)/RHO(MEDIUM)
              sig = sig0
              IF ((sig .LE. 0)) THEN
                tstep = vacdst
                sig0 = 1.E-15
              ELSE
                IF (( compute_tstep )) THEN
                  total_de = demfp/sig
                  fedep = total_de
                  ekef = eke - fedep
                  IF (( ekef .LE. E_array(1,medium) )) THEN
                    tstep = vacdst
                  ELSE
                    elkef = Log(ekef)
                    Lelkef=eke1(MEDIUM)*elkef+eke0(MEDIUM)
                    IF (( lelkef .EQ. lelke )) THEN
                      fedep = 1 - ekef/eke
                      elktmp = 0.5*(elke+elkef+0.25*fedep*fedep*(1+fedep
     *                *(1+0.875*fedep)))
                      lelktmp = lelke
                      IF ((lelec .LT. 0)) THEN
                        dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = ededx1(lelktmp,medium)*dedxmid
                      ELSE
                        dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = pdedx1(lelktmp,medium)*dedxmid
                      END IF
                      aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
                      tstep = fedep*eke*dedxmid*(1+aux)
                    ELSE
                      ekei = E_array(lelke,medium)
                      elkei = (lelke - eke0(medium))/eke1(medium)
                      fedep = 1 - ekei/eke
                      elktmp = 0.5*(elke+elkei+0.25*fedep*fedep*(1+fedep
     *                *(1+0.875*fedep)))
                      lelktmp = lelke
                      IF ((lelec .LT. 0)) THEN
                        dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = ededx1(lelktmp,medium)*dedxmid
                      ELSE
                        dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = pdedx1(lelktmp,medium)*dedxmid
                      END IF
                      aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
                      tuss = fedep*eke*dedxmid*(1+aux)
                      ekei = E_array(lelkef+1,medium)
                      elkei = (lelkef + 1 - eke0(medium))/eke1(medium)
                      fedep = 1 - ekef/ekei
                      elktmp = 0.5*(elkei+elkef+0.25*fedep*fedep*(1+fede
     *                p*(1+0.875*fedep)))
                      lelktmp = lelkef
                      IF ((lelec .LT. 0)) THEN
                        dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = ededx1(lelktmp,medium)*dedxmid
                      ELSE
                        dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = pdedx1(lelktmp,medium)*dedxmid
                      END IF
                      aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
                      tstep = fedep*ekei*dedxmid*(1+aux)
                      tstep=tstep+tuss+ range_ep(qel,lelke,medium)-range
     *                _ep(qel,lelkef+1,medium)
                    END IF
                  END IF
                  total_tstep = tstep
                  compute_tstep = .false.
                END IF
                tstep = total_tstep/rhof
              END IF
              IF ((lelec .LT. 0)) THEN
                dedx0=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
              ELSE
                dedx0=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
              END IF
              dedx = rhof*dedx0
              tmxs=tmxs1(Lelke,MEDIUM)*elke+tmxs0(Lelke,MEDIUM)
              tmxs = tmxs/rhof
              ekei = E_array(lelke,medium)
              elkei = (lelke - eke0(medium))/eke1(medium)
              fedep = 1 - ekei/eke
              elktmp = 0.5*(elke+elkei+0.25*fedep*fedep*(1+fedep*(1+0.87
     *        5*fedep)))
              lelktmp = lelke
              IF ((lelec .LT. 0)) THEN
                dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelktmp,MED
     *          IUM)
                dedxmid = 1/dedxmid
                aux = ededx1(lelktmp,medium)*dedxmid
              ELSE
                dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelktmp,MED
     *          IUM)
                dedxmid = 1/dedxmid
                aux = pdedx1(lelktmp,medium)*dedxmid
              END IF
              aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
              range = fedep*eke*dedxmid*(1+aux)
              range = (range + range_ep(qel,lelke,medium))/rhof
              random_tustep = .false.
              IF ((random_tustep)) THEN
                IF((rng_seed .GT. 128))call ranmar_get
                rnnotu = rng_array(rng_seed)*twom24
                rng_seed = rng_seed + 1
                tmxs = rnnotu*min(tmxs,smaxir(irl))
              ELSE
                tmxs = min(tmxs,smaxir(irl))
              END IF
              tustep = min(tstep,tmxs,range)
              call hownear(tperp,x(np),y(np),z(np),ir(np))
              dnear(np) = tperp
              IF (( i_do_rr(irl) .EQ. 1 .AND. e(np) .LT. e_max_rr(irl) )
     *        ) THEN
                IF ((tperp .GE. range)) THEN
                  idisc = 50 + 49*iq(np)
                  go to 11790
                END IF
              END IF
              blccl = rhof*blcc(medium)
              xccl = rhof*xcc(medium)
              p2 = eke*(eke+rmt2)
              beta2 = p2/(p2 + rmsq)
              IF (( spin_effects )) THEN
                IF ((lelec .LT. 0)) THEN
                  etap=etae_ms1(Lelke,MEDIUM)*elke+etae_ms0(Lelke,MEDIUM
     *            )
                ELSE
                  etap=etap_ms1(Lelke,MEDIUM)*elke+etap_ms0(Lelke,MEDIUM
     *            )
                END IF
                ms_corr=blcce1(Lelke,MEDIUM)*elke+blcce0(Lelke,MEDIUM)
                blccl = blccl/etap/(1+0.25*etap*xccl/blccl/p2)*ms_corr
              END IF
              ssmfp=beta2/blccl
              skindepth = skindepth_for_bca*ssmfp
              tustep = min(tustep,max(tperp,skindepth))
              count_all_steps = count_all_steps + 1
              is_ch_step = .false.
              IF (((tustep .LE. tperp) .AND. ((.NOT.exact_bca) .OR. (tus
     *        tep .GT. skindepth)))) THEN
                callhowfar = .false.
                domultiple = .false.
                dosingle = .false.
                callmsdist = .true.
                tuss = range - range_ep(qel,lelke,medium)/rhof
                IF (( tuss .GE. tustep )) THEN
                  IF (( lelec .LT. 0 )) THEN
                    dedxmid=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIU
     *              M)
                    aux = ededx1(lelke,medium)/dedxmid
                  ELSE
                    dedxmid=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIU
     *              M)
                    aux = pdedx1(lelke,medium)/dedxmid
                  END IF
                  de = dedxmid*tustep*rhof
                  fedep = de/eke
                  de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.2
     *            5*fedep*(2-aux*(4-aux)))))
                ELSE
                  lelktmp = lelke
                  tuss = (range - tustep)*rhof
                  IF (( tuss .LE. 0 )) THEN
                    de = eke - TE(medium)*0.99
                  ELSE
11821               IF(tuss.GE.range_ep(qel,lelktmp,medium))GO TO 11822
                      lelktmp = lelktmp - 1
                    GO TO 11821
11822               CONTINUE
                    elktmp = (lelktmp+1-eke0(medium))/eke1(medium)
                    eketmp = E_array(lelktmp+1,medium)
                    tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof
                    IF (( lelec .LT. 0 )) THEN
                      dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelkt
     *                mp,MEDIUM)
                      aux = ededx1(lelktmp,medium)/dedxmid
                    ELSE
                      dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelkt
     *                mp,MEDIUM)
                      aux = pdedx1(lelktmp,medium)/dedxmid
                    END IF
                    de = dedxmid*tuss*rhof
                    fedep = de/eketmp
                    de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0
     *              .25*fedep*(2-aux*(4-aux)))))
                    de = de + eke - eketmp
                  END IF
                END IF
                tvstep = tustep
                is_ch_step = .true.
                IF ((transport_algorithm .EQ. 0)) THEN
                  call msdist_pII (  eke,de,tustep,rhof,medium,qel,spin_
     *            effects, u(np),v(np),w(np),x(np),y(np),z(np),  uscat,v
     *            scat,wscat,xtrans,ytrans,ztrans,ustep )
                ELSE
                  call msdist_pI (  eke,de,tustep,rhof,medium,qel,spin_e
     *            ffects, u(np),v(np),w(np),x(np),y(np),z(np),  uscat,vs
     *            cat,wscat,xtrans,ytrans,ztrans,ustep )
                END IF
              ELSE
                callmsdist = .false.
                IF ((exact_bca)) THEN
                  domultiple = .false.
                  IF((rng_seed .GT. 128))call ranmar_get
                  rnnoss = rng_array(rng_seed)*twom24
                  rng_seed = rng_seed + 1
                  IF (( rnnoss .LT. 1.e-30 )) THEN
                    rnnoss = 1.e-30
                  END IF
                  lambda = - Log(1 - rnnoss)
                  lambda_max = 0.5*blccl*rm/dedx*(eke/rm+1)**3
                  IF (( lambda .GE. 0 .AND. lambda_max .GT. 0 )) THEN
                    IF (( lambda .LT. lambda_max )) THEN
                      tuss=lambda*ssmfp*(1-0.5*lambda/lambda_max)
                    ELSE
                      tuss = 0.5 * lambda * ssmfp
                    END IF
                    IF ((tuss .LT. tustep)) THEN
                      tustep = tuss
                      dosingle = .true.
                    ELSE
                      dosingle = .false.
                    END IF
                  ELSE
                    write(i_log,'(/a)') '***************** Warning: '
                    write(i_log,*) ' lambda > lambda_max: ', lambda,lamb
     *              da_max,' eke dedx: ',eke,dedx, ' ir medium blcc: ',i
     *              r(np),medium,blcc(medium), ' position = ',x(np),y(np
     *              ),z(np)
                    dosingle = .false.
                    np=np-1
                    return
                  END IF
                  ustep = tustep
                ELSE
                  dosingle = .false.
                  domultiple = .true.
                  ekems = eke - 0.5*tustep*dedx
                  p2 = ekems*(ekems+rmt2)
                  beta2 = p2/(p2 + rmsq)
                  chia2 = xccl/(4*blccl*p2)
                  xi = 0.5*xccl/p2/beta2*tustep
                  IF (( spin_effects )) THEN
                    elkems = Log(ekems)
                    Lelkems=eke1(MEDIUM)*elkems+eke0(MEDIUM)
                    IF ((lelec .LT. 0)) THEN
                      etap=etae_ms1(Lelkems,MEDIUM)*elkems+etae_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1ce_ms1(Lelkems,MEDIUM)*elkems+q1ce_ms0(L
     *                elkems,MEDIUM)
                    ELSE
                      etap=etap_ms1(Lelkems,MEDIUM)*elkems+etap_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1cp_ms1(Lelkems,MEDIUM)*elkems+q1cp_ms0(L
     *                elkems,MEDIUM)
                    END IF
                    chia2 = chia2*etap
                    xi = xi*xi_corr
                    ms_corr=blcce1(Lelkems,MEDIUM)*elkems+blcce0(Lelkems
     *              ,MEDIUM)
                    blccl = blccl*ms_corr
                  ELSE
                    xi_corr = 1
                    etap = 1
                  END IF
                  xi = xi*(Log(1+1./chia2)-1/(1+chia2))
                  IF (( xi .LT. 0.1 )) THEN
                    ustep = tustep*(1 - xi*(0.5 - xi*0.166667))
                  ELSE
                    ustep = tustep*(1 - Exp(-xi))/xi
                  END IF
                END IF
                IF ((ustep .LT. tperp)) THEN
                  callhowfar = .false.
                ELSE
                  callhowfar = .true.
                END IF
              END IF
            END IF
            irold = ir(np)
            irnew = ir(np)
            idisc = 0
            ustep0 = ustep
            IF ((callhowfar .OR. wt(np) .LE. 0)) THEN
              call howfar
            END IF
            IF ((idisc .GT. 0)) THEN
              go to 11790
            END IF
            IF ((ustep .LE. 0)) THEN
              IF ((ustep .LT. -1e-4)) THEN
                ierust = ierust + 1
                WRITE(6,11830)ierust,ustep,dedx,e(np)-prm, ir(np),irnew,
     *          irold,x(np),y(np),z(np)
11830           FORMAT(i4,' Negative ustep = ',e12.5,' dedx=',F8.4,' ke=
     *',F8.4, ' ir,irnew,irold =',3i4,' x,y,z =',4e10.3)
                IF ((ierust .GT. 1000)) THEN
                  WRITE(6,11840)
11840             FORMAT(////' Called exit---too many ustep errors'///)
                  call exit(1)
                END IF
              END IF
              ustep = 0
            END IF
            IF ((ustep .EQ. 0 .OR. medium .EQ. 0)) THEN
              IF ((ustep .NE. 0)) THEN
                IF (.false.) THEN
                  edep = pzero
                ELSE
                  vstep = ustep
                  tvstep = vstep
                  edep = pzero
                  e_range = vacdst
                  IARG=0
                  IF ((IAUSFL(IARG+1).NE.0)) THEN
                    CALL AUSGAB(IARG)
                  END IF
                  x(np) = x(np) + u(np)*vstep
                  y(np) = y(np) + v(np)*vstep
                  z(np) = z(np) + w(np)*vstep
                  dnear(np) = dnear(np) - vstep
                END IF
              END IF
              IF ((irnew .NE. irold)) THEN
                ir(np) = irnew
                irl = irnew
                medium = med(irl)
              END IF
              IF ((ustep .NE. 0)) THEN
                IARG=5
                IF ((IAUSFL(IARG+1).NE.0)) THEN
                  CALL AUSGAB(IARG)
                END IF
              END IF
              IF ((eie .LE. ecut(irl))) THEN
                go to 11780
              END IF
              IF ((ustep .NE. 0 .AND. idisc .LT. 0)) THEN
                go to 11790
              END IF
              GO TO 11801
            END IF
            vstep = ustep
            IF ((callhowfar)) THEN
              IF ((exact_bca)) THEN
                tvstep = vstep
                IF ((tvstep .NE. tustep)) THEN
                  dosingle = .false.
                END IF
              ELSE
                IF (( vstep .LT. ustep0 )) THEN
                  ekems = eke - 0.5*tustep*vstep/ustep0*dedx
                  p2 = ekems*(ekems+rmt2)
                  beta2 = p2/(p2 + rmsq)
                  chia2 = xccl/(4*blccl*p2)
                  xi = 0.5*xccl/p2/beta2*vstep
                  IF (( spin_effects )) THEN
                    elkems = Log(ekems)
                    Lelkems=eke1(MEDIUM)*elkems+eke0(MEDIUM)
                    IF ((lelec .LT. 0)) THEN
                      etap=etae_ms1(Lelkems,MEDIUM)*elkems+etae_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1ce_ms1(Lelkems,MEDIUM)*elkems+q1ce_ms0(L
     *                elkems,MEDIUM)
                    ELSE
                      etap=etap_ms1(Lelkems,MEDIUM)*elkems+etap_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1cp_ms1(Lelkems,MEDIUM)*elkems+q1cp_ms0(L
     *                elkems,MEDIUM)
                    END IF
                    chia2 = chia2*etap
                    xi = xi*xi_corr
                    ms_corr=blcce1(Lelkems,MEDIUM)*elkems+blcce0(Lelkems
     *              ,MEDIUM)
                    blccl = blccl*ms_corr
                  ELSE
                    xi_corr = 1
                    etap = 1
                  END IF
                  xi = xi*(Log(1+1./chia2)-1/(1+chia2))
                  IF (( xi .LT. 0.1 )) THEN
                    tvstep = vstep*(1 + xi*(0.5 + xi*0.333333))
                  ELSE
                    IF (( xi .LT. 0.999999 )) THEN
                      tvstep = -vstep*Log(1 - xi)/xi
                    ELSE
                      write(i_log,*) ' Stoped in SET-TVSTEP because xi >
     * 1! '
                      write(i_log,*) ' Medium: ',medium
                      write(i_log,*) ' Initial energy: ',eke
                      write(i_log,*) ' Average step energy: ',ekems
                      write(i_log,*) ' tustep: ',tustep
                      write(i_log,*) ' ustep0: ',ustep0
                      write(i_log,*) ' vstep:  ',vstep
                      write(i_log,*) ' ==> xi = ',xi
                      write(i_log,'(/a)') '***************** Error: '
                      write(i_log,*) 'This is a fatal error condition'
                      write(i_log,'(/a)') '***************** Quiting now
     *.'
                      call exit(1)
                    END IF
                  END IF
                ELSE
                  tvstep = tustep
                END IF
              END IF
              tuss = range - range_ep(qel,lelke,medium)/rhof
              IF (( tuss .GE. tvstep )) THEN
                IF (( lelec .LT. 0 )) THEN
                  dedxmid=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
                  aux = ededx1(lelke,medium)/dedxmid
                ELSE
                  dedxmid=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
                  aux = pdedx1(lelke,medium)/dedxmid
                END IF
                de = dedxmid*tvstep*rhof
                fedep = de/eke
                de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.25*
     *          fedep*(2-aux*(4-aux)))))
              ELSE
                lelktmp = lelke
                tuss = (range - tvstep)*rhof
                IF (( tuss .LE. 0 )) THEN
                  de = eke - TE(medium)*0.99
                ELSE
11851             IF(tuss.GE.range_ep(qel,lelktmp,medium))GO TO 11852
                    lelktmp = lelktmp - 1
                  GO TO 11851
11852             CONTINUE
                  elktmp = (lelktmp+1-eke0(medium))/eke1(medium)
                  eketmp = E_array(lelktmp+1,medium)
                  tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof
                  IF (( lelec .LT. 0 )) THEN
                    dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelktmp
     *              ,MEDIUM)
                    aux = ededx1(lelktmp,medium)/dedxmid
                  ELSE
                    dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelktmp
     *              ,MEDIUM)
                    aux = pdedx1(lelktmp,medium)/dedxmid
                  END IF
                  de = dedxmid*tuss*rhof
                  fedep = de/eketmp
                  de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.2
     *            5*fedep*(2-aux*(4-aux)))))
                  de = de + eke - eketmp
                END IF
              END IF
            ELSE
              tvstep = tustep
              IF (( .NOT.callmsdist )) THEN
                tuss = range - range_ep(qel,lelke,medium)/rhof
                IF (( tuss .GE. tvstep )) THEN
                  IF (( lelec .LT. 0 )) THEN
                    dedxmid=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIU
     *              M)
                    aux = ededx1(lelke,medium)/dedxmid
                  ELSE
                    dedxmid=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIU
     *              M)
                    aux = pdedx1(lelke,medium)/dedxmid
                  END IF
                  de = dedxmid*tvstep*rhof
                  fedep = de/eke
                  de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.2
     *            5*fedep*(2-aux*(4-aux)))))
                ELSE
                  lelktmp = lelke
                  tuss = (range - tvstep)*rhof
                  IF (( tuss .LE. 0 )) THEN
                    de = eke - TE(medium)*0.99
                  ELSE
11861               IF(tuss.GE.range_ep(qel,lelktmp,medium))GO TO 11862
                      lelktmp = lelktmp - 1
                    GO TO 11861
11862               CONTINUE
                    elktmp = (lelktmp+1-eke0(medium))/eke1(medium)
                    eketmp = E_array(lelktmp+1,medium)
                    tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof
                    IF (( lelec .LT. 0 )) THEN
                      dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelkt
     *                mp,MEDIUM)
                      aux = ededx1(lelktmp,medium)/dedxmid
                    ELSE
                      dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelkt
     *                mp,MEDIUM)
                      aux = pdedx1(lelktmp,medium)/dedxmid
                    END IF
                    de = dedxmid*tuss*rhof
                    fedep = de/eketmp
                    de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0
     *              .25*fedep*(2-aux*(4-aux)))))
                    de = de + eke - eketmp
                  END IF
                END IF
              END IF
            END IF
            save_de = de
            edep = de
            ekef = eke - de
            eold = eie
            enew = eold - de
            IF (( .NOT.callmsdist )) THEN
              IF (( domultiple )) THEN
                lambda = blccl*tvstep/beta2/etap/(1+chia2)
                xi = xi/xi_corr
                findindex = .true.
                spin_index = .true.
                call mscat(lambda,chia2,xi,elkems,beta2,qel,medium, spin
     *          _effects,findindex,spin_index, costhe,sinthe)
              ELSE
                IF ((dosingle)) THEN
                  ekems = Max(ekef,ecut(irl)-rm)
                  p2 = ekems*(ekems + rmt2)
                  beta2 = p2/(p2 + rmsq)
                  chia2 = xcc(medium)/(4*blcc(medium)*p2)
                  IF (( spin_effects )) THEN
                    elkems = Log(ekems)
                    Lelkems=eke1(MEDIUM)*elkems+eke0(MEDIUM)
                    IF ((lelec .LT. 0)) THEN
                      etap=etae_ms1(Lelkems,MEDIUM)*elkems+etae_ms0(Lelk
     *                ems,MEDIUM)
                    ELSE
                      etap=etap_ms1(Lelkems,MEDIUM)*elkems+etap_ms0(Lelk
     *                ems,MEDIUM)
                    END IF
                    chia2 = chia2*etap
                  END IF
                  call sscat(chia2,elkems,beta2,qel,medium, spin_effects
     *            ,costhe,sinthe)
                ELSE
                  theta = 0
                  sinthe = 0
                  costhe = 1
                END IF
              END IF
            END IF
            e_range = range
            IF (( callmsdist )) THEN
              u_final = uscat
              v_final = vscat
              w_final = wscat
              x_final = xtrans
              y_final = ytrans
              z_final = ztrans
            ELSE
              IF (.NOT.(.false.)) THEN
                x_final = x(np) + u(np)*vstep
                y_final = y(np) + v(np)*vstep
                z_final = z(np) + w(np)*vstep
              END IF
              IF (( domultiple .OR. dosingle )) THEN
                u_tmp = u(np)
                v_tmp = v(np)
                w_tmp = w(np)
                call uphi(2,1)
                u_final = u(np)
                v_final = v(np)
                w_final = w(np)
                u(np) = u_tmp
                v(np) = v_tmp
                w(np) = w_tmp
              ELSE
                u_final = u(np)
                v_final = v(np)
                w_final = w(np)
              END IF
            END IF
            IARG=0
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            x(np) = x_final
            y(np) = y_final
            z(np) = z_final
            u(np) = u_final
            v(np) = v_final
            w(np) = w_final
            dnear(np) = dnear(np) - vstep
            irold = ir(np)
            peie = peie - edep
            eie = peie
            e(np) = peie
            IF (( irnew .EQ. irl .AND. eie .LE. ecut(irl))) THEN
              go to 11780
            END IF
            medold = medium
            IF ((medium .NE. 0)) THEN
              ekeold = eke
              eke = eie - rm
              elke = log(eke)
              Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
            END IF
            IF ((irnew .NE. irold)) THEN
              ir(np) = irnew
              irl = irnew
              medium = med(irl)
            END IF
            IARG=5
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            IF ((eie .LE. ecut(irl))) THEN
              go to 11780
            END IF
            IF ((idisc .LT. 0)) THEN
              go to 11790
            END IF
            IF((medium .NE. medold))GO TO 11801
            demfp = demfp - save_de*sig
            total_de = total_de - save_de
            total_tstep = total_tstep - tvstep*rhof
            IF (( total_tstep .LT. 1e-9 )) THEN
              demfp = 0
            END IF
            IF(((demfp .LT. 1.E-8)))GO TO11812
          GO TO 11811
11812     CONTINUE
          IF ((lelec .LT. 0)) THEN
            sigf=esig1(Lelke,MEDIUM)*elke+esig0(Lelke,MEDIUM)
            dedx0=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
            sigf = sigf/dedx0
          ELSE
            sigf=psig1(Lelke,MEDIUM)*elke+psig0(Lelke,MEDIUM)
            dedx0=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
            sigf = sigf/dedx0
          END IF
          sigratio = sigf/sig0
          IF((rng_seed .GT. 128))call ranmar_get
          rfict = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF(((rfict .LE. sigratio)))GO TO11802
        GO TO 11801
11802   CONTINUE
        IF ((lelec .LT. 0)) THEN
          ebr1=ebr11(Lelke,MEDIUM)*elke+ebr10(Lelke,MEDIUM)
          IF((rng_seed .GT. 128))call ranmar_get
          rnno24 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF ((rnno24 .LE. ebr1)) THEN
            go to 11870
          ELSE
            IF ((e(np) .LE. thmoll(medium) .AND. eii_flag .EQ. 0)) THEN
              IF ((ebr1 .LE. 0)) THEN
                go to 11770
              END IF
              go to 11870
            END IF
            IARG=8
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            call moller
            IARG=9
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            IF((iq(np) .EQ. 0))return
          END IF
          go to 11770
        END IF
        pbr1=pbr11(Lelke,MEDIUM)*elke+pbr10(Lelke,MEDIUM)
        IF((rng_seed .GT. 128))call ranmar_get
        rnno25 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF ((rnno25 .LT. pbr1)) THEN
          go to 11870
        END IF
        pbr2=pbr21(Lelke,MEDIUM)*elke+pbr20(Lelke,MEDIUM)
        IF ((rnno25 .LT. pbr2)) THEN
          IARG=10
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          call bhabha
          IARG=11
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          IF((iq(np) .EQ. 0))return
        ELSE
          IARG=12
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          call annih
          IARG=13
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          GO TO 11772
        END IF
      GO TO 11771
11772 CONTINUE
      return
11870 IARG=6
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      call brems
      IARG=7
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      IF ((iq(np) .EQ. 0)) THEN
        return
      ELSE
        go to 11770
      END IF
11780 IF (( medium .GT. 0 )) THEN
        IF ((eie .GT. ae(medium))) THEN
          idr = 1
          IF ((lelec .LT. 0)) THEN
            edep = e(np) - prm
          ELSE
            EDEP=PEIE-PRM
          END IF
        ELSE
          idr = 2
          edep = e(np) - prm
        END IF
      ELSE
        idr = 1
        edep = e(np) - prm
      END IF
      IARG=idr
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
11880 CONTINUE
      IF ((lelec .GT. 0)) THEN
        IF ((edep .LT. peie)) THEN
          IARG=28
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          call annih_at_rest
          IARG=14
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          return
        END IF
      END IF
      np = np - 1
      ircode = 2
      return
11790 idisc = abs(idisc)
      IF (((lelec .LT. 0) .OR. (idisc .EQ. 99))) THEN
        edep = e(np) - prm
      ELSE
        edep = e(np) + prm
      END IF
      IARG=3
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      IF((idisc .EQ. 99))goto 11880
      np = np - 1
      ircode = 2
      return
      end
      SUBROUTINE HATCH
      implicit none
      character*512 toUpper
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/BOUNDS/ECUT( 12001),PCUT( 12001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PHOTIN/ EBINDA(10), GE0(10),GE1(10), GMFP0(2000,10),GMFP1(2
     *000,10),GBR10(2000,10),GBR11(2000,10),GBR20(2000,10),GBR21(2000,10
     *), RCO0(10),RCO1(10), RSCT0(100,10),RSCT1(100,10), COHE0(2000,10),
     *COHE1(2000,10),  PHOTONUC0(2000,10),PHOTONUC1(2000,10), DPMFP, MPG
     *EM(1,10), NGR(10)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      real*8 SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERRR/ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN, MINZ,MAXZ,MINR,MAXR
     *,IREJCT
      real*8 ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN
      integer*4 MINZ,MAXZ,MINR,MAXR,IREJCT
      COMMON/USERMI/EXPMFP,GWTOLD,ICSDA
      integer*4 ICSDA
      real*8 EXPMFP,GWTOLD
      COMMON/USERVR/ CEXPTR,GWAIT,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,
     *IQINC,MONOEN, cs_enhance,cs_enhance_current,ienhance,iefl( 12001),
     *ics_enhance, do_fast_step
      integer*4 ienhance,iefl,ics_enhance, IFORCE,NFMIN,NFMAX,NFTIME,ISO
     *URC,IFPB,IQINC,MONOEN
      real*8 CEXPTR,GWAIT,cs_enhance,cs_enhance_current
      logical do_fast_step
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/ET_control/ smaxir( 12001),estepe,ximax,  skindepth_for_bca
     *,transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      COMMON/LBREMZ/CONST,DELC,EBREMZ,DELTAM,XLNZ
      real*4 CONST,DELC,EBREMZ,DELTAM,XLNZ
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20), EPSTTL,NEPST,IEPST
     *,EPSTFLP, NELEPS,ZEPST(20),IAPRFL,IAPRIMP
      integer*4 ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP
      CHARACTER EPSTTL*80
      real*4 EPSTEN,EPSTD,WEPST
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/LSPION/CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      real*4 CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      COMMON/PWLFIN/EPE,ZTHRE(8),ZEPE(8),NIPE,NALE
      real*4 EPE,ZTHRE,ZEPE
      integer*4 NIPE,NALE
      COMMON/RSLTS/NEL,AXE,BXE,AFE(500,8),BFE(500,8)
      real*4 AXE,BXE,AFE,BFE
      integer*4 NEL
      COMMON/SPCOMM/MEDTBL(24,73), NUMSTMED,STDATA(6,73)
      CHARACTER*4 MEDTBL
      integer*4 NUMSTMED
      real*4 STDATA
      COMMON/MIXDAT/NEP,LMED,PZP(50),ZELEMP(50),WAP(50),RHOZP(50), GASPP
     *,EZ,TPZ,IDSTRN(24)
      integer*4 NEP,LMED
      real*4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ
      CHARACTER*4 IDSTRN
      COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183
      real*4 ALRAD,ALRADP,A1440,A183
      COMMON/MIMSD/BMIN
      real*4 BMIN
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6), DE
     *LCMP,ALPHIP(2),BPARP(2),DELPOSP(2)
      real*4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP
      COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100)
      integer*4 NET
      real*4 ITBL,WATBL,RHOTBL
      CHARACTER*4 ASYMT
      COMMON/MEDINP/inpdensity_file(10),inpasym(10,50), inpstrn(24,10),p
     *z4(10,50), rhoz4(10,50),wa4(10,50),inpgasp(10)
      character*256 inpdensity_file
      CHARACTER*4 inpasym,inpstrn
      real*4 pz4,rhoz4,wa4,inpgasp
      real*4 XSIFP,WADUM,PZDUM,RHOZDUM,RLCDUM,ALKE,ALKEI
      integer*4 I01
      EXTERNAL ALKE,ALKEI,EFUNS
      CHARACTER*4 MEDTB1(24,20),MEDTB2(24,20),MEDTB3(24,20),MEDTB4(24,13
     *)
      EQUIVALENCE (MEDTBL(1,1),MEDTB1(1,1))
      EQUIVALENCE (MEDTBL(1,21),MEDTB2(1,1))
      EQUIVALENCE (MEDTBL(1,41),MEDTB3(1,1))
      EQUIVALENCE (MEDTBL(1,61),MEDTB4(1,1))
      real*4 STDAT1(6,20),STDAT2(6,20),STDAT3(6,20),STDAT4(6,13)
      EQUIVALENCE (STDATA(1,1),STDAT1(1,1))
      EQUIVALENCE (STDATA(1,21),STDAT2(1,1))
      EQUIVALENCE (STDATA(1,41),STDAT3(1,1))
      EQUIVALENCE (STDATA(1,61),STDAT4(1,1))
      CHARACTER*4 MBUF(72),MDLABL(8)
      real*8 ACD ,  ADEV ,  ASD ,  COST ,  CTHET ,  DEL ,  DFACT ,  DFAC
     *TI,  DUNITO,  DUNITR,  FNSSS ,  P ,  PZNORM,  RDEV ,  S2C2 ,  S2C2
     *MN,  S2C2MX,  SINT ,  SX ,  SXX ,  SXY ,   SY ,   WID ,  XS ,  XS0
     * ,  XS1 ,  XSI ,  WSS ,  YS ,  ZEROS(3)
      integer*4 I ,  I1ST ,  IB ,  ID ,  IE ,  IL ,  IM ,  IRAYL ,  IRN
     *,  ISTEST,  ISUB ,  ISS ,  IZ ,   IZZ ,  J ,  JR ,  LCTHET,  LMDL
     *,  LMDN ,  LTHETA,  MD ,  MXSINC,  NCMFP ,   NEKE ,   NGE ,   NGRI
     *M ,  NISUB ,  NLEKE ,    NM ,  NRANGE,    NRNA ,  NSEKE ,   NSGE ,
     *   NSINSS,  LOK(10)
      character*256 tmp_string
      integer*4 lnblnk1
      DATA MDLABL/' ','M','E','D','I','U','M','='/,LMDL/8/,LMDN/24/,DUNI
     *TO/1./
      DATA I1ST/1/,NSINSS/37/,MXSINC/1002/,ISTEST/0/,NRNA/1000/
      PIP=3.1415926536
      C=2.997925E+10
      HBAR=1.05450E-27
      ECGS=4.80298E-10
      EMKS=1.60210E-19
      AN=6.02252E+23
      RADDEG=180./PIP
      FSC = ECGS**2/(HBAR*C)
      ERGMEV = (1.E+6)*(EMKS*1.E+7)
      RME = PRM/C**2*ERGMEV
      RMP = PRM
      R0 = (ECGS**2)/(RME*C**2)
      RMPSQ = RMP*RMP
      A22P9 = RADDEG*SQRT(4.*PIP*AN)*ECGS**2/ERGMEV
      A6680 = 4.0*PIP*AN*(HBAR/(RME*C))**2*(0.885**2/(1.167*1.13))
      DATA AFACT/0.0/,SK/0.0/,X0/0.0/,X1/0.0/,CBAR/0.0/,IEV/0.0/
      DATA LMED/24/,NUMSTMED/73/
      DATA EPE/.01/,ZTHRE,ZEPE/16*0.0/,NIPE/20/,NALE/500/
      DATA BMIN/4.5/
      DATA ALRAD/5.31,4.79,4.74,4.71/,ALRADP/6.144,5.621,5.805,5.924/, A
     *1440/1194.0/,A183/184.15/
      DATA MEDTB1/ 'H','2','-','G','A','S',18*' ','H','2','-','L','I','Q
     *','U','I','D',15*' ','H','E','-','G','A','S',18*' ','L','I',22*' '
     *, 'B','E',22*' ','C','-','2','.','2','6','5',' ','G','/','C','M','
     **','*','3',9*' ','C','-','1','.','7','0',' ','G','/','C','M','*','
     **','3',10*' ', 'N','2','-','G','A','S',18*' ','O','2','-','G','A',
     *'S',18*' ','N','E','-','G','A','S',18*' ','N','A',22*' ', 'M','G',
     *22*' ','A','L',22*' ','S','I',22*' ','A','R','-','G','A','S',18*'
     *', 'K',23*' ','C','A',22*' ','T','I',22*' ','V',23*' ','M','N',22*
     *' ' /
      DATA MEDTB2/ 'F','E',22*' ','C','O',22*' ','N','I',22*' ','C','U',
     *22*' ','Z','N',22*' ', 'G','E',22*' ','S','E',22*' ','K','R','-','
     *G','A','S',18*' ','R','B',22*' ', 'M','O',22*' ','A','G',22*' ','C
     *','D',22*' ','I','N',22*' ','S','N',22*' ', 'X','E','-','G','A','S
     *',18*' ','C','S',22*' ','G','D',22*' ','T','A',22*' ', 'W',23*' ',
     *'P','T',22*' ' /
      DATA MEDTB3/ 'A','U',22*' ','H','G',22*' ','P','B',22*' ','R','N',
     *'-','G','A','S',18*' ', 'U',23*' ', 'A','I','R','-','G','A','S',17
     **' ','C','O','2','-','G','A','S',17*' ','P','O','L','Y','E','T','H
     *','Y','L','E','N','E',12*' ', 'P','O','L','Y','P','R','O','P','Y',
     *'L','E','N','E',11*' ','X','Y','L','E','N','E',18*' ','T','O','L',
     *'U','E','N','E',17*' ', 'N','Y','L','O','N',19*' ','V','I','N','Y'
     *,'L','T','O','L','U','E','N','E',12*' ','A','1','5','0','-','P','L
     *','A','S','T','I','C',12*' ', 'S','T','I','L','B','E','N','E',16*'
     * ','P','O','L','Y','S','T','Y','R','E','N','E',13*' ','A','N','T',
     *'H','R','A','C','E','N','E',14*' ', 'L','E','X','A','N',19*' ','L'
     *,'U','C','I','T','E',18*' ','H','2','O',21*' ' /
      DATA MEDTB4/ 'M','Y','L','A','R',19*' ', 'K','A','P','T','O','N',1
     *8*' ','L','I','F',21*' ','P','O','L','Y','V','I','N','Y','L','-','
     *C','L',12*' ', 'P','Y','R','E','X','-','G','L','A','S','S',13*' ',
     *'S','I','O','2',20*' ','C','A','F','2',20*' ', 'P','H','O','T','O'
     *,'E','M','U','L','S','I','O','N',11*' ','A','G','C','L',20*' ','N'
     *,'A','I',21*' ', 'L','I','I',21*' ','A','G','B','R',20*' ','C','S'
     *,'I',21*' ' /
      DATA STDAT1/ 0.03535,6.790,1.864,3.5,19.2,9.584, 0.09179,5.831,0.4
     *76,2.0,21.8,3.263, 0.0114,7.625,2.202,4.0,41.8,11.139, 0.3492,3.23
     *3,0.0966,2.0,40.0,3.122, 0.3518,3.034,-0.0089,2.0,63.7,2.785, 0.58
     *48,2.360,-0.0089,2.0,78.0,2.868, 0.7154,2.191,-0.0089,2.0,78.0,3.1
     *55, 0.2120,3.041,1.738,4.0,82.0,10.540, 0.2666,2.825,1.754,4.0,95.
     *0,10.700, 0.1202,3.357,2.073,4.5,137.0,11.904, 0.2204,3.103,0.4515
     *,2.8,149.0,5.053, 0.1714,3.223,0.2386,2.8,156.0,4.530, 0.3346,2.79
     *5,0.0966,2.5,166.0,4.239, 0.3755,2.720,0.0966,2.5,173.0,4.435, 0.1
     *902,2.982,1.764,4.5,188.0,11.948, 0.3041,2.674,0.2386,3.0,190.0,5.
     *642, 0.2177,2.874,0.1751,3.0,191.0,5.040, 0.1782,2.946,0.0485,3.0,
     *233.0,4.445, 0.1737,2.935,-0.0089,3.0,245.0,4.266, 0.1996,2.812,-0
     *.0089,3.0,272.0,4.270 /
      DATA STDAT2/ 0.2101,2.771,-0.0089,3.0,286.0,4.291, 0.2229,2.713,-0
     *.0089,3.0,297.0,4.260, 0.2504,2.619,-0.0089,3.0,311.0,4.312, 0.255
     *7,2.613,-0.0089,3.0,322.0,4.419, 0.3163,2.468,0.0485,3.0,330.0,4.6
     *91, 0.2809,2.647,0.2386,3.0,350.0,5.141, 0.2979,2.635,0.2386,3.0,3
     *48.0,5.321, 0.1519,3.030,1.716,4.8,352.0,12.512, 0.1450,3.078,0.45
     *15,3.5,363.0,6.478, 0.2228,2.824,0.1751,3.0,424.0,4.879, 0.3091,2.
     *563,-0.0089,3.0,470.0,5.063, 0.1853,2.819,0.0485,3.3,469.0,5.273,
     *0.2004,2.790,0.1751,3.3,487.0,5.517, 0.1898,2.839,0.2386,3.3,488.0
     *,5.534, 0.1329,3.020,1.563,5.0,482.0,12.728, 0.2214,2.784,0.4515,3
     *.5,488.0,6.914, 0.2068,2.686,0.0485,3.5,591.0,5.874, 0.1663,2.805,
     *0.1751,3.5,718.0,5.526, 0.1499,2.870,0.1751,3.5,727.0,5.406, 0.146
     *5,2.903,0.0966,3.5,790.0,5.473 /
      DATA STDAT3/ 0.1533,2.881,0.0966,3.5,790.0,5.575, 0.1824,2.798,0.2
     *386,3.5,800.0,5.961, 0.1861,2.814,0.2386,3.5,823.0,6.202, 0.1130,3
     *.023,1.537,5.3,794.0,13.284, 0.1362,3.034,0.2386,3.5,890.0,5.869,
     *0.2466,2.879,1.742,4.0,85.7,10.595, 0.1999,3.022,1.648,4.0,88.7,10
     *.239, 0.4875,2.544,0.1379,2.0,57.4,3.002, 0.2493,2.975,0.1537,2.3,
     *59.2,3.126, 0.2755,2.911,0.1695,2.3,61.8,3.270, 0.2830,2.890,0.172
     *2,2.3,62.5,3.303, 0.5345,2.439,0.1336,2.0,63.9,3.063, 0.3495,2.749
     *,0.1467,2.2,64.7,3.201, 0.5462,2.435,0.1329,2.0,65.1,3.110, 0.2989
     *,2.851,0.1731,2.3,67.7,3.367, 0.3670,2.724,0.1647,2.2,68.7,3.300,
     *0.5858,2.364,0.1146,2.0,69.5,3.151, 0.3865,2.664,0.1608,2.2,73.1,3
     *.321, 0.3996,2.606,0.1824,2.2,74.0,3.330, 0.2065,3.007,0.2400,2.5,
     *75.0,3.502 /
      DATA STDAT4/ 0.3124,2.782,0.1561,2.3,78.7,3.326, 0.4061,2.614,0.14
     *92,2.2,79.3,3.342, 0.1308,3.476,0.0171,2.5,94.0,3.167, 0.1873,2.96
     *2,0.1558,2.8,108.2,4.053, 0.2988,2.805,0.1479,2.5,134.0,3.971, 0.1
     *440,3.220,0.1385,2.8,139.2,4.003, 0.3750,2.592,0.0676,2.5,166.0,4.
     *065, 0.3416,2.496,0.1009,3.0,331.0,5.332, 0.1243,3.002,-0.0138,3.5
     *,398.4,5.344, 0.1560,2.926,0.1203,3.5,452.0,6.057, 0.1785,2.845,0.
     *0892,3.5,485.1,6.267, 0.1351,2.976,0.0358,3.5,487.2,5.616, 0.1796,
     *2.840,0.0395,3.5,553.1,6.281 /
      DATA NET/100/
      DATA ITBL/19.2,41.8,40.,63.7,76.0,78.0,82.0,95.0,115.,137., 149.,1
     *56.,166.,173.,173.,180.,174.,188.,190.,191.,216.,233.,245., 257.,2
     *72.,286.,297.,311.,322.,330.,334.,350.,347.,348.,357.,352., 363.,3
     *66.,379.,393.,417.,424.,428.,441.,449.,470.,470.,469.,488., 488.,4
     *87.,485.,491.,482.,488.,491.,501.,523.,535.,546.,560.,574., 580.,5
     *91.,614.,628.,650.,658.,674.,684.,694.,705.,718.,727.,736., 746.,7
     *57.,790.,790.,800.,810.,823.,823.,830.,825.,794.,827.,826., 841.,8
     *47.,878.,890.,902.,921.,934.,939.,952.,966.,980.,994./
      DATA WATBL/1.00797,4.0026,6.939,9.0122,10.811,12.01115,14.0067, 15
     *.9994,18.9984,20.183,22.9898,24.312,26.9815,28.088,30.9738, 32.064
     *,35.453,39.948,39.102,40.08,44.956,47.90,50.942,51.998, 54.9380,55
     *.847,58.9332,58.71,63.54,65.37,69.72,72.59,74.9216, 78.96,79.808,8
     *3.80,85.47,87.62,88.905,91.22,92.906,95.94,99.0, 101.07,102.905,10
     *6.4,107.87,112.4,114.82,118.69,121.75,127.60, 126.9044,131.30,132.
     *905,137.34,138.91, 140.12,140.907,144.24,147.,150.35,151.98,157.25
     *,158.924,162.50, 164.930,167.26,168.934,173.04,174.97,178.49,180.9
     *48,183.85, 186.2,190.2,192.2,195.08,196.987,200.59,204.37,207.19,2
     *08.980, 210.,210.,222.,223.,226.,227.,232.036,231.,238.03,237.,242
     *., 243.,247.,247.,248.,254.,253./
      DATA RHOTBL/0.0808,0.19,0.534,1.85,2.5,2.26,1.14,1.568,1.5,1.0, 0.
     *9712,1.74,2.702,2.4,1.82,2.07,2.2,1.65,0.86,1.55,3.02,4.54, 5.87,7
     *.14,7.3,7.86,8.71,8.90,8.9333,7.140,5.91,5.36,5.73,4.80, 4.2,3.4,1
     *.53,2.6,4.47,6.4,8.57,9.01,11.50,12.20,12.50,12.,10.5, 8.65,7.30,7
     *.31,6.684,6.24,4.93,2.7,1.873,3.5,6.15,6.90,6.769, 7.007, 1. ,7.54
     *,5.17,7.87,8.25,8.56,8.80,9.06,9.32,6.96,9.85, 11.40,16.60,19.30,2
     *0.53,22.48,22.42,21.45,19.30,14.19,11.85, 11.34,9.78,9.30, 1. ,4.,
     * 1. ,5., 1. ,11.0,15.37,18.90, 20.5,19.737,11.7,7.,1. , 1. , 1. ,
     *1. /
      DATA ASYMT/'H','HE','LI','BE','B','C','N','O','F','NE', 'NA','MG',
     *'AL','SI','P','S','CL','AR','K','CA','SC','TI', 'V','CR','MN','FE'
     *,'CO','NI','CU','ZN','GA','GE','AS','SE','BR', 'KR','RB','SR','Y',
     *'ZR','NB','MO','TC','RU','RH','PD','AG','CD', 'IN','SN','SB','TE',
     *'I','XE','CS','BA','LA','CE','PR','ND', 'PM','SM','EU','GD','TB','
     *DY','HO','ER','TM','YB','LU','HF','TA', 'W','RE','OS','IR','PT','A
     *U','HG','TL','PB','BI','PO','AT','RN', 'FR','RA','AC','TH','PA','U
     *','NP','PU','AM','CM','BK','CF','ES', 'FM'/
      DATA EPSTFLP/0/,IEPST/1/,IAPRIMP/1/,IAPRFL/0/
11890 FORMAT(1X,14I5)
11900 FORMAT(1X,1PE14.5,4E14.5)
11910 FORMAT(72A1)
      IF ((I1ST.NE.0)) THEN
        I1ST=0
        DO 11921 J=1, 12001
          IF ((SMAXIR(J).LE.0.0)) THEN
            SMAXIR(J)=1E10
          END IF
11921   CONTINUE
11922   CONTINUE
        NISUB=MXSINC-2
        FNSSS=NSINSS
        WID=PI5D2/FLOAT(NISUB)
        WSS=WID/(FNSSS-1.0)
        ZEROS(1)=0.
        ZEROS(2)=PI
        ZEROS(3)=TWOPI
        DO 11931 ISUB=1,MXSINC
          SX=0.
          SY=0.
          SXX=0.
          SXY=0.
          XS0=WID*FLOAT(ISUB-2)
          XS1=XS0+WID
          IZ=0
          DO 11941 IZZ=1,3
            IF (((XS0.LE.ZEROS(IZZ)).AND.(ZEROS(IZZ).LE.XS1))) THEN
              IZ=IZZ
              GO TO11942
            END IF
11941     CONTINUE
11942     CONTINUE
          IF ((IZ.EQ.0)) THEN
            XSI=XS0
          ELSE
            XSI=ZEROS(IZ)
          END IF
          DO 11951 ISS=1,NSINSS
            XS=WID*FLOAT(ISUB-2)+WSS*FLOAT(ISS-1)-XSI
            YS=SIN(XS+XSI)
            SX=SX+XS
            SY=SY+YS
            SXX=SXX+XS*XS
            SXY=SXY+XS*YS
11951     CONTINUE
11952     CONTINUE
          IF ((IZ.NE.0)) THEN
            SIN1(ISUB)=SXY/SXX
            SIN0(ISUB)=-SIN1(ISUB)*XSI
          ELSE
            DEL=FNSSS*SXX-SX*SX
            SIN1(ISUB)=(FNSSS*SXY-SY*SX)/DEL
            SIN0(ISUB)=(SY*SXX-SX*SXY)/DEL - SIN1(ISUB)*XSI
          END IF
11931   CONTINUE
11932   CONTINUE
        SINC0=2.0
        SINC1=1.0/WID
        IF ((ISTEST.NE.0)) THEN
          ADEV=0.
          RDEV=0.
          S2C2MN=10.
          S2C2MX=0.
          DO 11961 ISUB=1,NISUB
            DO 11971 ISS=1,NSINSS
              THETA=WID*FLOAT(ISUB-1)+WSS*FLOAT(ISS-1)
              CTHET=PI5D2-THETA
              SINTHE=sin(THETA)
              COSTHE=sin(CTHET)
              SINT=SIN(THETA)
              COST=COS(THETA)
              ASD=ABS(SINTHE-SINT)
              ACD=ABS(COSTHE-COST)
              ADEV=max(ADEV,ASD,ACD)
              IF((SINT.NE.0.0))RDEV=max(RDEV,ASD/ABS(SINT))
              IF((COST.NE.0.0))RDEV=max(RDEV,ACD/ABS(COST))
              S2C2=SINTHE**2+COSTHE**2
              S2C2MN=min(S2C2MN,S2C2)
              S2C2MX=max(S2C2MX,S2C2)
              IF ((ISUB.LT.11)) THEN
                write(i_log,'(1PE20.7,4E20.7)') THETA,SINTHE,SINT,COSTHE
     *          ,COST
              END IF
11971       CONTINUE
11972       CONTINUE
11961     CONTINUE
11962     CONTINUE
          write(i_log,'(a,2i5)') ' SINE TESTS,MXSINC,NSINSS=',MXSINC,NSI
     *    NSS
          write(i_log,'(a,1PE16.8,3e16.8)') ' ADEV,RDEV,S2C2(MN,MX) =',
     *    ADEV,RDEV,S2C2MN,S2C2MX
          ADEV=0.
          RDEV=0.
          S2C2MN=10.
          S2C2MX=0.
          DO 11981 IRN=1,NRNA
            IF((rng_seed .GT. 128))call ranmar_get
            THETA = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            THETA=THETA*PI5D2
            CTHET=PI5D2-THETA
            SINTHE=sin(THETA)
            COSTHE=sin(CTHET)
            SINT=SIN(THETA)
            COST=COS(THETA)
            ASD=ABS(SINTHE-SINT)
            ACD=ABS(COSTHE-COST)
            ADEV=max(ADEV,ASD,ACD)
            IF((SINT.NE.0.0))RDEV=max(RDEV,ASD/ABS(SINT))
            IF((COST.NE.0.0))RDEV=max(RDEV,ACD/ABS(COST))
            S2C2=SINTHE**2+COSTHE**2
            S2C2MN=min(S2C2MN,S2C2)
            S2C2MX=max(S2C2MX,S2C2)
11981     CONTINUE
11982     CONTINUE
          write(i_log,'(a,i7,a)') ' TEST AT ',NRNA,' RANDOM ANGLES IN (0
     *,5*PI/2)'
          write(i_log,'(1PE16.8,3E16.8)') ' ADEV,RDEV,S2C2(MN,MX) =', AD
     *    EV,RDEV,S2C2MN,S2C2MX
        END IF
        P=1.
        DO 11991 I=1,50
          PWR2I(I)=P
          P=P/2.
11991   CONTINUE
11992   CONTINUE
      END IF
      DO 12001 J=1,NMED
12010   CONTINUE
          DO 12011 I=1, 12001
          IF ((IRAYLR(I).EQ.1.AND.MED(I).EQ.J)) THEN
            IRAYLM(J)=1
            GO TO 12012
          END IF
12011   CONTINUE
12012   CONTINUE
12001 CONTINUE
12002 CONTINUE
      IPHOTONUC=0
      DO 12021 J=1,NMED
12030   CONTINUE
          DO 12031 I=1, 12001
          IF ((IPHOTONUCR(I).EQ.1.AND.MED(I).EQ.J)) THEN
            IPHOTONUCM(J)=1
            IPHOTONUC=1
            GO TO 12032
          END IF
12031   CONTINUE
12032   CONTINUE
12021 CONTINUE
12022 CONTINUE
      write(i_log,'(a,i3)') ' ===> Photonuclear flag: ', iphotonuc
      IF((.NOT.is_pegsless))REWIND KMPI
      NM=0
      DO 12041 IM=1,NMED
        LOK(IM)=0
        IF ((IRAYLM(IM).EQ.1)) THEN
          write(i_log,'(a,i3/)') ' RAYLEIGH OPTION REQUESTED FOR MEDIUM
     *NUMBER',IM
        END IF
12041 CONTINUE
12042 CONTINUE
      DO 12051 IM=1,NMED
        IF ((IPHOTONUCM(IM).EQ.1)) THEN
          write(i_log,'(a,i3/)') ' PHOTONUCLEAR REQUESTED FOR MEDIUM NUM
     *BER',IM
        END IF
12051 CONTINUE
12052 CONTINUE
      IF ((.NOT.is_pegsless)) THEN
12060   CONTINUE
12061     CONTINUE
12070     CONTINUE
12071       CONTINUE
            READ(KMPI,11910,END=12080)MBUF
            DO 12091 IB=1,LMDL
              IF((MBUF(IB).NE.MDLABL(IB)))GO TO 12071
12091       CONTINUE
12092       CONTINUE
12100       CONTINUE
              DO 12101 IM=1,NMED
              DO 12111 IB=1,LMDN
                IL=LMDL+IB
                IF((MBUF(IL).NE.MEDIA(IB,IM)))GO TO 12101
                IF((IB.EQ.LMDN))GO TO 12072
12111         CONTINUE
12112         CONTINUE
12101       CONTINUE
12102       CONTINUE
          GO TO 12071
12072     CONTINUE
          IF((LOK(IM).NE.0))GO TO 12070
          LOK(IM)=1
          NM=NM+1
          read(kmpi,'(a)',err=12120) tmp_string
          goto 12130
12120     write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'Error while reading pegs4 file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
12130     CONTINUE
          read(tmp_string,1,ERR=12140)  (MBUF(I),I=1,5),RHO(IM),NNE(IM),
     *    IUNRST(IM),EPSTFL(IM),IAPRIM(IM)
1         FORMAT(5A1,5X,F11.0,4X,I2,9X,I1,9X,I1,9X,I1)
          GO TO 12150
12140     CONTINUE
          write(i_log,*) 'Found medium with gas pressure'
          read(tmp_string,2) (MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),
     *    EPSTFL(IM), IAPRIM(IM)
2         FORMAT(5A1,5X,F11.0,4X,I2,26X,I1,9X,I1,9X,I1)
12150     CONTINUE
            DO 12151 IE=1,NNE(IM)
            READ(KMPI,12160)(MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2), ZELEM
     *      (IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE)
12160       FORMAT (6A1,2A1,3X,F3.0,3X,F9.0,4X,F12.0,6X,F12.0)
12151     CONTINUE
12152     CONTINUE
          READ(KMPI,11900) RLC(IM),AE(IM),AP(IM),UE(IM),UP(IM)
          TE(IM)=AE(IM)-RM
          THMOLL(IM)=TE(IM)*2. + RM
          READ(KMPI,11890) MSGE(IM),MGE(IM),MSEKE(IM),MEKE(IM),MLEKE(IM)
     *    ,MCMFP(IM),MRANGE(IM),IRAYL
          NSGE=MSGE(IM)
          NGE=MGE(IM)
          NSEKE=MSEKE(IM)
          NEKE=MEKE(IM)
          NLEKE=MLEKE(IM)
          NCMFP=MCMFP(IM)
          NRANGE=MRANGE(IM)
          READ(KMPI,11900)(DL1(I,IM),DL2(I,IM),DL3(I,IM),DL4(I,IM),DL5(I
     *    ,IM),DL6(I,IM),I=1,6)
          READ(KMPI,11900)DELCM(IM),(ALPHI(I,IM),BPAR(I,IM),DELPOS(I,IM)
     *    ,I=1,2)
          READ(KMPI,11900)XR0(IM),TEFF0(IM),BLCC(IM),XCC(IM)
          READ(KMPI,11900)EKE0(IM),EKE1(IM)
          READ(KMPI,11900) (ESIG0(I,IM),ESIG1(I,IM),PSIG0(I,IM),PSIG1(I,
     *    IM),EDEDX0(I,IM),EDEDX1(I,IM),PDEDX0(I,IM),PDEDX1(I,IM),EBR10(
     *    I,IM),EBR11(I,IM),PBR10(I,IM),PBR11(I,IM),PBR20(I,IM),PBR21(I,
     *    IM),TMXS0(I,IM),TMXS1(I,IM),I=1,NEKE)
          READ(KMPI,11900)EBINDA(IM),GE0(IM),GE1(IM)
          READ(KMPI,11900)(GMFP0(I,IM),GMFP1(I,IM),GBR10(I,IM),GBR11(I,I
     *    M),GBR20(I,IM),GBR21(I,IM),I=1,NGE)
          IF ((IRAYL.EQ.1)) THEN
            READ(KMPI,11890) NGR(IM)
            NGRIM=NGR(IM)
            READ(KMPI,11900)RCO0(IM),RCO1(IM)
            READ(KMPI,11900)(RSCT0(I,IM),RSCT1(I,IM),I=1,NGRIM)
            READ(KMPI,11900)(COHE0(I,IM),COHE1(I,IM),I=1,NGE)
            write(i_log,'(a,i3,a)') ' Rayleigh data available for medium
     *', IM, ' in PEGS4 data set.'
          END IF
          IF ((IRAYLM(IM).EQ.1)) THEN
            IF ((IRAYL.NE.1)) THEN
              IF ((toUpper(photon_xsections(:lnblnk1(photon_xsections)))
     *        .EQ.'PEGS4')) THEN
                write(i_log,'(/a)') '***************** Error: '
                write(i_log,'(a,i3 /,a /,a)') ' IN HATCH: REQUESTED RAYL
     *EIGH OPTION FOR MEDIUM', IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PE
     *GS4 FILE.', ' YOU WILL NOT BE ABLE TO USE THE PEGS4 DATA WITH RAYL
     *EIGH ON!'
                write(i_log,'(/a)') '***************** Quiting now.'
                call exit(1)
              ELSE
                write(i_log,'(/a)') '***************** Warning: '
                write(i_log,'(a,i3 /,a)') ' IN HATCH: REQUESTED RAYLEIGH
     * OPTION FOR MEDIUM', IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4
     *FILE.'
              END IF
            ELSE
              IF ((toUpper(photon_xsections(:lnblnk1(photon_xsections)))
     *        .EQ.'PEGS4')) THEN
                call egs_init_rayleigh_sampling(IM)
              END IF
            END IF
          END IF
          IF((NM.GE.NMED))GO TO12062
        GO TO 12061
12062   CONTINUE
        CLOSE (UNIT=KMPI)
        DUNITR=DUNIT
        IF ((DUNIT.LT.0.0)) THEN
          ID=MAX0(1,MIN0(10,int(-DUNIT)))
          DUNIT=RLC(ID)
        END IF
        IF ((DUNIT.NE.1.0)) THEN
          write(i_log,'(a,1PE14.5,E14.5,a)') ' DUNIT REQUESTED&USED ARE:
     * ', DUNITR,DUNIT,'(CM.)'
        END IF
        DO 12171 IM=1,NMED
          DFACT=RLC(IM)/DUNIT
          DFACTI=1.0/DFACT
          I=1
            GO TO 12183
12181       I=I+1
12183       IF(I-(MEKE(IM)).GT.0)GO TO 12182
            ESIG0(I,IM)=ESIG0(I,IM)*DFACTI
            ESIG1(I,IM)=ESIG1(I,IM)*DFACTI
            PSIG0(I,IM)=PSIG0(I,IM)*DFACTI
            PSIG1(I,IM)=PSIG1(I,IM)*DFACTI
            EDEDX0(I,IM)=EDEDX0(I,IM)*DFACTI
            EDEDX1(I,IM)=EDEDX1(I,IM)*DFACTI
            PDEDX0(I,IM)=PDEDX0(I,IM)*DFACTI
            PDEDX1(I,IM)=PDEDX1(I,IM)*DFACTI
            TMXS0(I,IM)=TMXS0(I,IM)*DFACT
            TMXS1(I,IM)=TMXS1(I,IM)*DFACT
          GO TO 12181
12182     CONTINUE
          TEFF0(IM)=TEFF0(IM)*DFACT
          BLCC(IM)=BLCC(IM)*DFACTI
          XCC(IM)=XCC(IM)*SQRT(DFACTI)
          RLDU(IM)=RLC(IM)/DUNIT
          I=1
            GO TO 12193
12191       I=I+1
12193       IF(I-(MGE(IM)).GT.0)GO TO 12192
            GMFP0(I,IM)=GMFP0(I,IM)*DFACT
            GMFP1(I,IM)=GMFP1(I,IM)*DFACT
          GO TO 12191
12192     CONTINUE
12171   CONTINUE
12172   CONTINUE
        VACDST=VACDST*DUNITO/DUNIT
        DUNITO=DUNIT
      ELSE
        write(i_log,*) ' PEGSLESS INPUT.  CALCULATING ELECTRON CROSS-SEC
     *TIONS.'
        call get_media_inputs(-1)
        DO 12201 IM=1,NMED
          AEP=AE(IM)
          UEP=UE(IM)
          APP=AP(IM)
          UPP=UP(IM)
          NEP=NNE(IM)
          IUNRSTP=IUNRST(IM)
          IAPRIMP=IAPRIM(IM)
          EPSTFLP=EPSTFL(IM)
          GASPP=INPGASP(IM)
          RHOP=RHO(IM)
          DO 12211 J=1,NEP
            ZELEMP(J)=ZELEM(IM,J)
            PZP(J)=PZ4(IM,J)
            RHOZP(J)=RHOZ4(IM,J)
            WAP(J)=WA4(IM,J)
12211     CONTINUE
12212     CONTINUE
          DO 12221 IB=1,LMDN
            IDSTRN(IB)=INPSTRN(IB,IM)
12221     CONTINUE
12222     CONTINUE
          TEP=AEP-RMP
          THMOLLP=AEP+TEP
          IF ((UEP.LE.AEP)) THEN
            write(i_log,'(a,24a1)')'  Error: Material not defined: ', (m
     *      edia(j,IM),j=1,24)
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'Material used in the geometry was not define
     *d in the' ,' material data.'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          CALL MIX
          CALL SPINIT(inpdensity_file(IM))
          CALL DIFFER
          CALL PWLF1(NEL,NALE,AEP,UEP,THMOLLP,EPE,ZTHRE,ZEPE,NIPE,ALKE,
     *    ALKEI,AXE,BXE,500,8,AFE,BFE,EFUNS)
          TE(IM)=AE(IM)-RM
          THMOLL(IM)=TE(IM)*2. + RM
          RLC(IM)=RLCP
          XCC(IM)=XCCP
          BLCC(IM)=BLCCP
          XR0(IM)=XR0P
          TEFF0(IM)=TEFF0P
          DELCM(IM)=DELCMP
          DO 12231 I=1,2
            ALPHI(I,IM)=ALPHIP(I)
            BPAR(I,IM)=BPARP(I)
            DELPOS(I,IM)=DELPOSP(I)
12231     CONTINUE
12232     CONTINUE
          DO 12241 I=1,6
            DL1(I,IM)=DLP1(I)
            DL2(I,IM)=DLP2(I)
            DL3(I,IM)=DLP3(I)
            DL4(I,IM)=DLP4(I)
            DL5(I,IM)=DLP5(I)
            DL6(I,IM)=DLP6(I)
12241     CONTINUE
12242     CONTINUE
          MSGE(IM)=0
          MSEKE(IM)=0
          MLEKE(IM)=0
          MCMFP(IM)=0
          MRANGE(IM)=0
          MGE(IM)=2000
          MEKE(IM)=NEL
          NSGE=MSGE(IM)
          NGE=MGE(IM)
          NSEKE=MSEKE(IM)
          NEKE=MEKE(IM)
          NLEKE=MLEKE(IM)
          NCMFP=MCMFP(IM)
          NRANGE=MRANGE(IM)
          EKE0(IM)=BXE
          EKE1(IM)=AXE
          DO 12251 I=1,NEKE
            ESIG0(I,IM)=BFE(I,1)
            ESIG1(I,IM)=AFE(I,1)
            PSIG0(I,IM)=BFE(I,2)
            PSIG1(I,IM)=AFE(I,2)
            EDEDX0(I,IM)=BFE(I,3)
            EDEDX1(I,IM)=AFE(I,3)
            PDEDX0(I,IM)=BFE(I,4)
            PDEDX1(I,IM)=AFE(I,4)
            EBR10(I,IM)=BFE(I,5)
            EBR11(I,IM)=AFE(I,5)
            PBR10(I,IM)=BFE(I,6)
            PBR11(I,IM)=AFE(I,6)
            PBR20(I,IM)=BFE(I,7)
            PBR21(I,IM)=AFE(I,7)
            TMXS0(I,IM)=BFE(I,8)
            TMXS1(I,IM)=AFE(I,8)
12251     CONTINUE
12252     CONTINUE
12201   CONTINUE
12202   CONTINUE
        DUNITR=DUNIT
        IF ((DUNIT.LT.0.0)) THEN
          ID=MAX0(1,MIN0(10,int(-DUNIT)))
          DUNIT=RLC(ID)
        END IF
        IF ((DUNIT.NE.1.0)) THEN
          write(i_log,'(a,1PE14.5,E14.5,a)') ' DUNIT REQUESTED&USED ARE:
     * ', DUNITR,DUNIT,'(CM.)'
        END IF
        DO 12261 IM=1,NMED
          DFACT=RLC(IM)/DUNIT
          DFACTI=1.0/DFACT
          I=1
            GO TO 12273
12271       I=I+1
12273       IF(I-(MEKE(IM)).GT.0)GO TO 12272
            ESIG0(I,IM)=ESIG0(I,IM)*DFACTI
            ESIG1(I,IM)=ESIG1(I,IM)*DFACTI
            PSIG0(I,IM)=PSIG0(I,IM)*DFACTI
            PSIG1(I,IM)=PSIG1(I,IM)*DFACTI
            EDEDX0(I,IM)=EDEDX0(I,IM)*DFACTI
            EDEDX1(I,IM)=EDEDX1(I,IM)*DFACTI
            PDEDX0(I,IM)=PDEDX0(I,IM)*DFACTI
            PDEDX1(I,IM)=PDEDX1(I,IM)*DFACTI
            TMXS0(I,IM)=TMXS0(I,IM)*DFACT
            TMXS1(I,IM)=TMXS1(I,IM)*DFACT
          GO TO 12271
12272     CONTINUE
          TEFF0(IM)=TEFF0(IM)*DFACT
          BLCC(IM)=BLCC(IM)*DFACTI
          XCC(IM)=XCC(IM)*SQRT(DFACTI)
          RLDU(IM)=RLC(IM)/DUNIT
          I=1
            GO TO 12283
12281       I=I+1
12283       IF(I-(MGE(IM)).GT.0)GO TO 12282
            GMFP0(I,IM)=GMFP0(I,IM)*DFACT
            GMFP1(I,IM)=GMFP1(I,IM)*DFACT
          GO TO 12281
12282     CONTINUE
12261   CONTINUE
12262   CONTINUE
        VACDST=VACDST*DUNITO/DUNIT
        DUNITO=DUNIT
        call show_media_parameters(i_log)
      END IF
      DO 12291 JR=1, 12001
        MD=MED(JR)
        IF (((MD.GE.1).AND.(MD.LE.NMED))) THEN
          ECUT(JR)=max(ECUT(JR),AE(MD))
          PCUT(JR)=max(PCUT(JR),AP(MD))
          IF ((RHOR(JR).EQ.0.0)) THEN
            RHOR(JR)=RHO(MD)
          END IF
        END IF
12291 CONTINUE
12292 CONTINUE
      IF ((IBRDST.EQ.1)) THEN
        DO 12301 IM=1,NMED
          ZBRANG(IM)=0.0
          PZNORM=0.0
          DO 12311 IE=1,NNE(IM)
            ZBRANG(IM)= ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+
     *      1.0)
            PZNORM=PZNORM+PZ(IM,IE)
12311     CONTINUE
12312     CONTINUE
          ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.)
          LZBRANG(IM)=-log(ZBRANG(IM))
12301   CONTINUE
12302   CONTINUE
      END IF
      IF ((IPRDST.GT.0)) THEN
        DO 12321 IM=1,NMED
          ZBRANG(IM)=0.0
          PZNORM=0.0
          DO 12331 IE=1,NNE(IM)
            ZBRANG(IM)= ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+
     *      1.0)
            PZNORM=PZNORM+PZ(IM,IE)
12331     CONTINUE
12332     CONTINUE
          ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.)
12321   CONTINUE
12322   CONTINUE
      END IF
      IF ((toUpper(photon_xsections(:lnblnk1(photon_xsections))) .EQ. 'P
     *EGS4')) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,'(6(a/))') 'Using photon data from PEGS4 file!!!', '
     *However, the new Rayleigh angular sampling will be used.', 'The or
     *iginal EGS4 angular sampling undersamples large scattering ', 'ang
     *les. This may have little impact as Rayleigh scattering ', 'is for
     *ward peaked.', '**************************************************
     ********'
      ELSE
        call egs_init_user_photon(photon_xsections,comp_xsections, photo
     *  nuc_xsections,xsec_out)
      END IF
      call mscati
      IF (( eadl_relax .AND. photon_xsections .EQ. 'xcom' )) THEN
        call init_compton
        call EDGSET(1,1)
      ELSE
        call EDGSET(1,1)
        call init_compton
      END IF
      IF (( xsec_out .EQ. 1 .AND. eadl_relax)) THEN
        call egs_print_binding_energies
      END IF
      call fix_brems
      IF (( ibr_nist .GE. 1 )) THEN
        call init_nist_brems
      END IF
      IF (( pair_nrc .EQ. 1 )) THEN
        call init_nrc_pair
      END IF
      call eii_init
      call init_triplet
      IF ((NMED.EQ.1)) THEN
        write(i_log,*) 'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ONE MEDIUM.'
      ELSE
        write(i_log,'(a,i5,a)') 'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ',N
     *  MED,' MEDIA.'
      END IF
      RETURN
12080 write(i_log,'(a,i2//,a/,a/)') ' END OF FILE ON UNIT ',KMPI, ' PROG
     *RAM STOPPED IN HATCH BECAUSE THE', ' FOLLOWING NAMES WERE NOT RECO
     *GNIZED:'
      DO 12341 IM=1,NMED
        IF ((LOK(IM).NE.1)) THEN
          write(i_log,'(40x,a,24a1,a)') '''',(MEDIA(I,IM),I=1,LMDN),''''
        END IF
12341 CONTINUE
12342 CONTINUE
      STOP
      END
      subroutine fix_brems
      implicit none
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/nist_brems/ nb_fdata(0:50,100,10), nb_xdata(0:50,100,10), n
     *b_wdata(50,100,10), nb_idata(50,100,10), nb_emin(10),nb_emax(10),
     *nb_lemin(10),nb_lemax(10), nb_dle(10),nb_dlei(10), log_ap(10)
      real*8 nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lema
     *x, nb_dle,nb_dlei,log_ap
      integer*4 nb_idata
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      integer*4 medium,i
      real*8 Zt,Zb,Zf,Zg,Zv,fmax1,fmax2,Zi,pi,fc,xi,aux, XSIF,FCOULC
      DO 12351 medium=1,nmed
        log_ap(medium) = log(ap(medium))
        Zt = 0
        Zb = 0
        Zf = 0
        DO 12361 i=1,NNE(medium)
          Zi = ZELEM(medium,i)
          pi = PZ(medium,i)
          fc = FCOULC(Zi)
          xi = XSIF(Zi)
          aux = pi*Zi*(Zi + xi)
          Zt = Zt + aux
          Zb = Zb - aux*Log(Zi)/3
          Zf = Zf + aux*fc
12361   CONTINUE
12362   CONTINUE
        Zv = (Zb - Zf)/Zt
        Zg = Zb/Zt
        fmax1 = 2*(20.863 + 4*Zg) - 2*(20.029 + 4*Zg)/3
        fmax2 = 2*(20.863 + 4*Zv) - 2*(20.029 + 4*Zv)/3
        dl1(1,medium) = (20.863 + 4*Zg)/fmax1
        dl2(1,medium) = -3.242/fmax1
        dl3(1,medium) = 0.625/fmax1
        dl4(1,medium) = (21.12+4*Zg)/fmax1
        dl5(1,medium) = -4.184/fmax1
        dl6(1,medium) = 0.952
        dl1(2,medium) = (20.029+4*Zg)/fmax1
        dl2(2,medium) = -1.93/fmax1
        dl3(2,medium) = -0.086/fmax1
        dl4(2,medium) = (21.12+4*Zg)/fmax1
        dl5(2,medium) = -4.184/fmax1
        dl6(2,medium) = 0.952
        dl1(3,medium) = (20.863 + 4*Zv)/fmax2
        dl2(3,medium) = -3.242/fmax2
        dl3(3,medium) = 0.625/fmax2
        dl4(3,medium) = (21.12+4*Zv)/fmax2
        dl5(3,medium) = -4.184/fmax2
        dl6(3,medium) = 0.952
        dl1(4,medium) = (20.029+4*Zv)/fmax2
        dl2(4,medium) = -1.93/fmax2
        dl3(4,medium) = -0.086/fmax2
        dl4(4,medium) = (21.12+4*Zv)/fmax2
        dl5(4,medium) = -4.184/fmax2
        dl6(4,medium) = 0.952
        dl1(5,medium) = (3*(20.863 + 4*Zg) - (20.029 + 4*Zg))
        dl2(5,medium) = (3*(-3.242) - (-1.930))
        dl3(5,medium) = (3*(0.625)-(-0.086))
        dl4(5,medium) = (2*21.12+8*Zg)
        dl5(5,medium) = (2*(-4.184))
        dl6(5,medium) = 0.952
        dl1(6,medium) = (3*(20.863 + 4*Zg) + (20.029 + 4*Zg))
        dl2(6,medium) = (3*(-3.242) + (-1.930))
        dl3(6,medium) = (3*0.625+(-0.086))
        dl4(6,medium) = (4*21.12+16*Zg)
        dl5(6,medium) = (4*(-4.184))
        dl6(6,medium) = 0.952
        dl1(7,medium) = (3*(20.863 + 4*Zv) - (20.029 + 4*Zv))
        dl2(7,medium) = (3*(-3.242) - (-1.930))
        dl3(7,medium) = (3*(0.625)-(-0.086))
        dl4(7,medium) = (2*21.12+8*Zv)
        dl5(7,medium) = (2*(-4.184))
        dl6(7,medium) = 0.952
        dl1(8,medium) = (3*(20.863 + 4*Zv) + (20.029 + 4*Zv))
        dl2(8,medium) = (3*(-3.242) + (-1.930))
        dl3(8,medium) = (3*0.625+(-0.086))
        dl4(8,medium) = (4*21.12+16*Zv)
        dl5(8,medium) = (4*(-4.184))
        dl6(8,medium) = 0.952
        bpar(2,medium) = dl1(7,medium)/(3*dl1(8,medium) + dl1(7,medium))
        bpar(1,medium) = 12*dl1(8,medium)/(3*dl1(8,medium) + dl1(7,mediu
     *  m))
12351 CONTINUE
12352 CONTINUE
      return
      end
      real*8 function FCOULC(Z)
      implicit none
      real*8 Z
      real*8 fine,asq
      data fine/137.03604/
      asq = Z/fine
      asq = asq*asq
      FCOULC = asq*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+ASQ*(0.0083+ASQ*(
     *-0.002))))
      return
      end
      real*8 function XSIF(Z)
      implicit none
      real*8 Z
      integer*4 iZ
      real*8 alrad(4),alradp(4),a1440,a183,FCOULC
      data alrad/5.31,4.79,4.74,4.71/
      data alradp/6.144,5.621,5.805,5.924/
      data a1440/1194.0/,A183/184.15/
      IF (( Z .LE. 4 )) THEN
        iZ = Z
        xsif = alradp(iZ)/(alrad(iZ) - FCOULC(Z))
      ELSE
        xsif = Log(A1440*Z**(-0.666667))/(Log(A183*Z**(-0.33333))-FCOULC
     *  (Z))
      END IF
      return
      end
      subroutine init_compton
      implicit none
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,10), eno_array(200,10), eno_atbin_array(200,10), n
     *_shell(10), radc_flag,  ibcmp( 12001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      integer*4 i,j,iz,nsh,j_l,j_h
      real*8 aux,pztot,atav
      real*8 aux_erf,erf1
      logical getd
      IF (( radc_flag .EQ. 1 )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) 'You are trying to use radiative Compton correcti
     *ons'
        write(i_log,*) 'without having included rad_compton1.mortran'
        write(i_log,'(a//)') 'Turning radiative Compton corrections OFF
     *...'
        radc_flag = 0
      END IF
      getd = .false.
      DO 12371 j=1, 12001
        medium = med(j)
        IF (( medium .GT. 0 .AND. medium .LE. nmed)) THEN
          IF (( ibcmp(j) .GT. 0 )) THEN
            getd = .true.
            GO TO12372
          END IF
        END IF
12371 CONTINUE
12372 CONTINUE
      IF (( .NOT.getd )) THEN
        IF (( eadl_relax .AND. photon_xsections .EQ. 'xcom' )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,/a,/a)') 'You must turn ON Compton binding cor
     *rections when using', 'a detailed atomic relaxation (eadl_relax=tr
     *ue) since ', 'binding energies taken from incoh.data below 1 keV!'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        write(i_log,'(a/)') ' Bound Compton scattering not requested! '
        return
      END IF
      write(i_log,'(/a$)') 'Bound Compton scattering requested, reading
     *data ......'
      rewind(i_incoh)
      DO 12381 j=1,18
        read(i_incoh,*)
12381 CONTINUE
12382 CONTINUE
      iz = 0
      DO 12391 j=1,1538
        read(i_incoh,*) iz_array(j),shn_array(j),ne_array(j), Jo_array(j
     *  ),be_array(j)
        Jo_array(j) = Jo_array(j)*137.
        be_array(j) = be_array(j)*1e-6/PRM
        aux_erf = 0.70710678119*(1+0.3*Jo_array(j))
        erfJo_array(j) = 0.82436063535*(erf1(aux_erf)-1)
        IF ((eadl_relax)) THEN
          IF ((iz_array(j) .NE. iz)) THEN
            shn_array(j) = 1
            iz = iz_array(j)
          ELSE
            shn_array(j) = shn_array(j-1)+1
          END IF
          IF ((binding_energies(shn_array(j),iz_array(j)) .GT. 0)) THEN
            be_array(j) = binding_energies(shn_array(j),iz_array(j))/PRM
          ELSE IF((photon_xsections .EQ. 'xcom')) THEN
            binding_energies(shn_array(j),iz_array(j)) = be_array(j)*PRM
          END IF
        END IF
12391 CONTINUE
12392 CONTINUE
      write(i_log,*) ' Done'
      write(i_log,'(/a)') ' Initializing Bound Compton scattering ......
     *'
      DO 12401 medium=1,nmed
        pztot = 0
        nsh = 0
        DO 12411 i=1,nne(medium)
          iz = int(zelem(medium,i))
          DO 12421 j=1,1538
            IF (( iz .EQ. iz_array(j) )) THEN
              nsh = nsh + 1
              IF (( nsh .GT. 200 )) THEN
                write(i_log,'(/a)') '***************** Error: '
                write(i_log,'(/a,i3,a,i4,a/,a)') ' For medium ',medium,
     *          ' the number of shells is > ',200,'!', ' Increase the pa
     *rameter $MXMDSH! '
                write(i_log,'(/a)') '***************** Quiting now.'
                call exit(1)
              END IF
              shell_array(nsh,medium) = j
              aux = pz(medium,i)*ne_array(j)
              eno_array(nsh,medium) = aux
              pztot = pztot + aux
            END IF
12421     CONTINUE
12422     CONTINUE
12411   CONTINUE
12412   CONTINUE
        IF (( nsh .EQ. 0 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,i3,a)') ' Medium ',medium,' has zero shells! '
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        n_shell(medium) = nsh
        write(i_log,'(a,i3,a,i3,a)') ' Medium ',medium,' has ',nsh,' she
     *lls: '
        DO 12431 i=1,nsh
          j = shell_array(i,medium)
          eno_array(i,medium) = eno_array(i,medium)/pztot
          write(i_log,'(i4,i5,i4,f9.5,e10.3,f10.3)') i,j,shn_array(j),en
     *    o_array(i,medium), Jo_array(j),be_array(j)*PRM*1000.
          eno_array(i,medium) = -eno_array(i,medium)
          eno_atbin_array(i,medium) = i
12431   CONTINUE
12432   CONTINUE
        atav = 1./nsh
        DO 12441 i=1,nsh-1
          DO 12451 j_h=1,nsh-1
            IF (( eno_array(j_h,medium) .LT. 0 )) THEN
              IF((abs(eno_array(j_h,medium)) .GT. atav))GO TO12452
            END IF
12451     CONTINUE
12452     CONTINUE
          DO 12461 j_l=1,nsh-1
            IF (( eno_array(j_l,medium) .LT. 0 )) THEN
              IF((abs(eno_array(j_l,medium)) .LT. atav))GO TO12462
            END IF
12461     CONTINUE
12462     CONTINUE
          aux = atav - abs(eno_array(j_l,medium))
          eno_array(j_h,medium) = eno_array(j_h,medium) + aux
          eno_array(j_l,medium) = -eno_array(j_l,medium)/atav + j_l
          eno_atbin_array(j_l,medium) = j_h
          IF((i .EQ. nsh-1))eno_array(j_h,medium) = 1 + j_h
12441   CONTINUE
12442   CONTINUE
        DO 12471 i=1,nsh
          IF (( eno_array(i,medium) .LT. 0 )) THEN
            eno_array(i,medium) = 1 + i
          END IF
12471   CONTINUE
12472   CONTINUE
12401 CONTINUE
12402 CONTINUE
      write(i_log,'(a/)') ' ...... Done.'
      getd = .false.
      DO 12481 j=1, 12001
        IF (( iedgfl(j) .GT. 0 .AND. iedgfl(j) .LE. 100 )) THEN
          getd = .true.
          GO TO12482
        END IF
12481 CONTINUE
12482 CONTINUE
      IF((getd))return
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(/a,/a,/a,/a)') ' In subroutine init_compton: ', '
     *Scattering off bound electrons creates atomic vacancies,', '   pot
     *entially starting an atomic relaxation cascade. ', '   Please turn
     * ON atomic relaxations.'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      SUBROUTINE MOLLER
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(10), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),
     *eii_sh(40),  eii_nshells(100),  eii_nsh(10),  eii_first(10,50),  e
     *ii_no(10,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      DOUBLE PRECISION PEIE,  PEKSE2,  PESE1,  PESE2,  PEKIN,  H1,  DCOS
     *TH
      real*8 EIE,  EKIN,  T0,  E0,  EXTRAE,  E02,  EP0,  G2,G3,  GMAX,
     *BR,  R,  REJF4,  RNNO27,  RNNO28,  ESE1,  ESE2
      real*8 sigm,pbrem,rsh,Uj,sig_j
      integer*4 lelke,iele,ish,nsh,ifirst,i,jj,iZ,iarg
      NPold = NP
      PEIE=E(NP)
      EIE=PEIE
      PEKIN=PEIE-PRM
      EKIN=PEKIN
      IF (( eii_flag .GT. 0 .AND. eii_nsh(medium) .GT. 0 )) THEN
        Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
        sigm=esig1(Lelke,MEDIUM)*elke+esig0(Lelke,MEDIUM)
        pbrem=ebr11(Lelke,MEDIUM)*elke+ebr10(Lelke,MEDIUM)
        sigm = sigm*(1 - pbrem)
        IF((rng_seed .GT. 128))call ranmar_get
        rsh = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        rsh = sigm*rsh
        DO 12491 iele=1,nne(medium)
          iZ = int(zelem(medium,iele)+0.5)
          nsh = eii_no(medium,iele)
          IF (( nsh .GT. 0 )) THEN
            ifirst = eii_first(medium,iele)
            DO 12501 ish=1,nsh
              Uj = binding_energies(ish,iZ)
              IF (( ekin .GT. Uj .AND. (Uj .GT. te(medium) .OR. Uj .GT.
     *        ap(medium)) )) THEN
                jj = ifirst + ish - 1
                i = eii_a(jj)*elke + eii_b(jj) + (jj-1)*250
                sig_j = eii_xsection_a(i)*elke + eii_xsection_b(i)
                sig_j = sig_j*pz(medium,iele)*eii_cons(medium)
                rsh = rsh - sig_j
                IF (( rsh .LT. 0 )) THEN
                  IARG=31
                  IF ((IAUSFL(IARG+1).NE.0)) THEN
                    CALL AUSGAB(IARG)
                  END IF
                  call eii_sample(ish,iZ,Uj)
                  IARG=32
                  IF ((IAUSFL(IARG+1).NE.0)) THEN
                    CALL AUSGAB(IARG)
                  END IF
                  return
                END IF
              END IF
12501       CONTINUE
12502       CONTINUE
          END IF
12491   CONTINUE
12492   CONTINUE
      END IF
      IF((ekin .LE. 2*te(medium)))return
      T0=EKIN/RM
      E0=T0+1.0
      EXTRAE = EIE - THMOLL(MEDIUM)
      E02=E0*E0
      EP0=TE(MEDIUM)/EKIN
      G2=T0*T0/E02
      G3=(2.*T0+1.)/E02
      GMAX=(1.+1.25*G2)
12511 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO27 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        BR = TE(MEDIUM)/(EKIN-EXTRAE*RNNO27)
        R=BR/(1.-BR)
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO28 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        REJF4=(1.+G2*BR*BR+R*(R-G3))
        RNNO28=GMAX*RNNO28
        IF((RNNO28.LE.REJF4))GO TO12512
      GO TO 12511
12512 CONTINUE
      PEKSE2=BR*EKIN
      PESE1=PEIE-PEKSE2
      PESE2=PEKSE2+PRM
      ESE1=PESE1
      ESE2=PESE2
      E(NP)=PESE1
      IF (( np+1 .GT. 500 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','MOLLER', ' s
     *tack size exceeded! ',' $MAXSTACK = ',500,' np = ',np+1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      E(NP+1)=PESE2
      H1=(PEIE+PRM)/PEKIN
      DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM)
      SINTHE=DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(2,1)
      NP=NP+1
      IQ(NP)=-1
      DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM)
      SINTHE=-DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(3,2)
      RETURN
      END
      subroutine mscati
      implicit none
      real*8 ededx,ei,eil,eip1,eip1l,si,sip1,eke,elke,aux,ecutmn,tstbm,t
     *stbmn
      real*8 p2,beta2,dedx0,ekef,elkef,estepx,ektmp,elktmp,chi_a2
      integer*4 i,leil,leip1l,neke,lelke,lelkef,lelktmp
      logical ise_monoton, isp_monoton
      real*8 sigee,sigep,sig,sige_old,sigp_old
      COMMON/BOUNDS/ECUT( 12001),PCUT( 12001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/ET_control/ smaxir( 12001),estepe,ximax,  skindepth_for_bca
     *,transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      IF (( bca_algorithm .EQ. 0 )) THEN
        exact_bca = .true.
      ELSE
        exact_bca = .false.
      END IF
      IF (( estepe .LE. 0 .OR. estepe .GE. 1)) THEN
        estepe = 0.25
      END IF
      IF (( ximax .LE. 0 .OR. ximax .GE. 1 )) THEN
        IF (( exact_bca )) THEN
          ximax = 0.5
        ELSE
          ximax = 0.5
        END IF
      END IF
      IF ((transport_algorithm .NE. 0 .AND. transport_algorithm .NE. 1 .
     *AND. transport_algorithm .NE. 2 )) THEN
        transport_algorithm = 0
      END IF
      IF (( skindepth_for_bca .LE. 1e-4 )) THEN
        IF (( .NOT.exact_bca )) THEN
          write(i_log,*) ' old PRESTA calculates default min. step-size
     *for BCA: '
          ecutmn = 1e30
          DO 12521 i=1, 12001
            IF (( med(i) .GT. 0 .AND. med(i) .LE. nmed )) THEN
              ecutmn = Min(ecutmn,ecut(i))
            END IF
12521     CONTINUE
12522     CONTINUE
          write(i_log,*) '     minimum ECUT found: ',ecutmn
          tstbmn = 1e30
          DO 12531 medium=1,nmed
            tstbm = (ecutmn-prm)*(ecutmn+prm)/ecutmn**2
            tstbm = blcc(medium)*tstbm*(ecutmn/xcc(medium))**2
            aux = Log(tstbm)
            IF((aux .GT. 300))write(i_log,*) 'aux > 300 ? ',aux
            tstbm = Log(tstbm/aux)
            tstbmn = Min(tstbmn,tstbm)
12531     CONTINUE
12532     CONTINUE
          write(i_log,*) '     default BLCMIN is: ',tstbmn
          skindepth_for_bca = Exp(tstbmn)
          write(i_log,*) '     this corresponds to ',skindepth_for_bca,
     *    ' elastic MFPs '
        ELSE
          skindepth_for_bca = 3
        END IF
      END IF
      call init_ms_SR
      DO 12541 medium=1,nmed
        blcc(medium) = 1.16699413758864573*blcc(medium)
        xcc(medium) = xcc(medium)**2
12541 CONTINUE
12542 CONTINUE
      IF (( spin_effects )) THEN
        call init_spin
      END IF
      write(i_log,*) ' '
      esige_max = 0
      psige_max = 0
      DO 12551 medium=1,nmed
        sigee = 1E-15
        sigep = 1E-15
        neke = meke(medium)
        ise_monoton = .true.
        isp_monoton = .true.
        sige_old = -1
        sigp_old = -1
        DO 12561 i=1,neke
          ei = exp((float(i) - eke0(medium))/eke1(medium))
          eil = log(ei)
          leil = i
          ededx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
          sig=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
          sig = sig/ededx
          IF((sig .GT. sigee))sigee = sig
          IF((sig .LT. sige_old))ise_monoton = .false.
          sige_old = sig
          ededx=pdedx1(Leil,MEDIUM)*eil+pdedx0(Leil,MEDIUM)
          sig=psig1(Leil,MEDIUM)*eil+psig0(Leil,MEDIUM)
          sig = sig/ededx
          IF((sig .GT. sigep))sigep = sig
          IF((sig .LT. sigp_old))isp_monoton = .false.
          sigp_old = sig
12561   CONTINUE
12562   CONTINUE
        write(i_log,*) ' Medium ',medium,' sige = ',sigee,sigep,' monoto
     *ne = ', ise_monoton,isp_monoton
        sig_ismonotone(0,medium) = ise_monoton
        sig_ismonotone(1,medium) = isp_monoton
        esig_e(medium) = sigee
        psig_e(medium) = sigep
        IF((sigee .GT. esige_max))esige_max = sigee
        IF((sigep .GT. psige_max))psige_max = sigep
12551 CONTINUE
12552 CONTINUE
      write(i_log,*) ' '
      write(i_log,*) ' Initializing tmxs for estepe = ',estepe,' and xim
     *ax = ',ximax
      write(i_log,*) ' '
      DO 12571 medium=1,nmed
        ei = exp((1 - eke0(medium))/eke1(medium))
        eil = log(ei)
        leil = 1
        E_array(1,medium) = ei
        expeke1(medium) = Exp(1./eke1(medium))-1
        range_ep(0,1,medium) = 0
        range_ep(1,1,medium) = 0
        neke = meke(medium)
        DO 12581 i=1,neke - 1
          eip1 = exp((float(i + 1) - eke0(medium))/eke1(medium))
          E_array(i+1,medium) = eip1
          eke = 0.5*(eip1+ei)
          elke = Log(eke)
          Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
          ededx=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
          aux = pdedx1(i,medium)/ededx
          range_ep(1,i+1,medium) = range_ep(1,i,medium) + (eip1-ei)/eded
     *    x*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24)
          ededx=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
          aux = ededx1(i,medium)/ededx
          range_ep(0,i+1,medium) = range_ep(0,i,medium) + (eip1-ei)/eded
     *    x*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24)
          ei = eip1
12581   CONTINUE
12582   CONTINUE
        eil = (1 - eke0(medium))/eke1(medium)
        ei = Exp(eil)
        leil = 1
        p2 = ei*(ei+2*rm)
        beta2 = p2/(p2+rm*rm)
        chi_a2 = Xcc(medium)/(4*p2*blcc(medium))
        dedx0=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
        estepx = 2*p2*beta2*dedx0/ei/Xcc(medium)/(Log(1+1./chi_a2)*(1+ch
     *  i_a2)-1)
        estepx = estepx*ximax
        IF (( estepx .GT. estepe )) THEN
          estepx = estepe
        END IF
        si = estepx*ei/dedx0
        DO 12591 i=1,neke - 1
          elke = (i + 1 - eke0(medium))/eke1(medium)
          eke = Exp(elke)
          lelke = i+1
          p2 = eke*(eke+2*rm)
          beta2 = p2/(p2+rm*rm)
          chi_a2 = Xcc(medium)/(4*p2*blcc(medium))
          ededx=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
          estepx = 2*p2*beta2*ededx/eke/ Xcc(medium)/(Log(1+1./chi_a2)*(
     *    1+chi_a2)-1)
          estepx = estepx*ximax
          IF (( estepx .GT. estepe )) THEN
            estepx = estepe
          END IF
          ekef = (1-estepx)*eke
          IF (( ekef .LE. E_array(1,medium) )) THEN
            sip1 = (E_array(1,medium) - ekef)/dedx0
            ekef = E_array(1,medium)
            elkef = (1 - eke0(medium))/eke1(medium)
            lelkef = 1
          ELSE
            elkef = Log(ekef)
            Lelkef=eke1(MEDIUM)*elkef+eke0(MEDIUM)
            leip1l = lelkef + 1
            eip1l = (leip1l - eke0(medium))/eke1(medium)
            eip1 = E_array(leip1l,medium)
            aux = (eip1 - ekef)/eip1
            elktmp = 0.5*(elkef+eip1l+0.25*aux*aux*(1+aux*(1+0.875*aux))
     *      )
            ektmp = 0.5*(ekef+eip1)
            lelktmp = lelkef
            ededx=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelktmp,MEDIUM)
            aux = ededx1(lelktmp,medium)/ededx
            sip1 = (eip1 - ekef)/ededx*( 1+aux*(1+2*aux)*((eip1-ekef)/ek
     *      tmp)**2/24)
          END IF
          sip1 = sip1 + range_ep(0,lelke,medium) - range_ep(0,lelkef+1,m
     *    edium)
          tmxs1(i,medium) = (sip1 - si)*eke1(medium)
          tmxs0(i,medium) = sip1 - tmxs1(i,medium)*elke
          si = sip1
12591   CONTINUE
12592   CONTINUE
        tmxs0(neke,medium) = tmxs0(neke - 1,medium)
        tmxs1(neke,medium) = tmxs1(neke - 1,medium)
12571 CONTINUE
12572 CONTINUE
      return
      end
      subroutine mscat(lambda,chia2,q1,elke,beta2,qel,medium, spin_effec
     *ts,find_index,spin_index, cost,sint)
      implicit none
      real*8 lambda, chia2,q1,elke,beta2,cost,sint
      integer*4 qel,medium
      logical spin_effects,find_index,spin_index
      common/ms_data/ ums_array(0:63,0:7,0:31), fms_array(0:63,0:7,0:31)
     *, wms_array(0:63,0:7,0:31), ims_array(0:63,0:7,0:31), llammin,llam
     *max,dllamb,dllambi,dqms,dqmsi
      real*4 ums_array,fms_array,wms_array, llammin,llammax,dllamb,dllam
     *bi,dqms,dqmsi
      integer*2 ims_array
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 sprob,explambda,wsum,wprob,xi,rejf,spin_rejection, cosz,sin
     *z,phi,omega2,llmbda,ai,aj,ak,a,u,du,x1,rnno
      integer*4 icount,i,j,k
      save i,j,omega2
      IF ((lambda .LE. 13.8)) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        sprob = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        explambda = Exp(-lambda)
        IF ((sprob .LT. explambda)) THEN
          cost = 1
          sint = 0
          return
        END IF
        wsum = (1+lambda)*explambda
        IF (( sprob .LT. wsum )) THEN
12600     CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          xi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          xi = 2*chia2*xi/(1 - xi + chia2)
          cost = 1 - xi
          IF (( spin_effects )) THEN
            rejf = spin_rejection(qel,medium,elke,beta2,q1,cost, spin_in
     *      dex,.false.)
            IF((rng_seed .GT. 128))call ranmar_get
            rnno = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF (( rnno .GT. rejf )) THEN
              GOTO 12600
            END IF
          END IF
          sint = sqrt(xi*(2 - xi))
          return
        END IF
        IF (( lambda .LE. 1 )) THEN
          wprob = explambda
          wsum = explambda
          cost = 1
          sint = 0
          icount = 0
12611     CONTINUE
            icount = icount + 1
            IF((icount .GT. 20))GO TO12612
            wprob = wprob*lambda/icount
            wsum = wsum + wprob
12620       CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            xi = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            xi = 2*chia2*xi/(1 - xi + chia2)
            cosz = 1 - xi
            IF (( spin_effects )) THEN
              rejf = spin_rejection(qel,medium,elke,beta2,q1,cosz, spin_
     *        index,.false.)
              IF((rng_seed .GT. 128))call ranmar_get
              rnno = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rnno .GT. rejf )) THEN
                GOTO 12620
              END IF
            END IF
            sinz = xi*(2 - xi)
            IF (( sinz .GT. 1.e-20 )) THEN
              sinz = Sqrt(sinz)
              IF((rng_seed .GT. 128))call ranmar_get
              xi = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              phi = xi*6.2831853
              cost = cost*cosz - sint*sinz*Cos(phi)
              sint = Sqrt(Max(0.0,(1-cost)*(1+cost)))
            END IF
            IF((( wsum .GT. sprob)))GO TO12612
          GO TO 12611
12612     CONTINUE
          return
        END IF
      END IF
      IF ((lambda .LE. 1e5 )) THEN
        IF ((find_index)) THEN
          llmbda = log(lambda)
          ai = llmbda*dllambi
          i = ai
          ai = ai - i
          IF((rng_seed .GT. 128))call ranmar_get
          xi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((xi .LT. ai))i = i + 1
          IF (( q1 .LT. 1e-3 )) THEN
            j = 0
          ELSE IF(( q1 .LT. 0.5 )) THEN
            aj = q1*dqmsi
            j = aj
            aj = aj - j
            IF((rng_seed .GT. 128))call ranmar_get
            xi = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((xi .LT. aj))j = j + 1
          ELSE
            j = 7
          END IF
          IF ((llmbda .LT. 2.2299)) THEN
            omega2 = chia2*(lambda + 4)*(1.347006 + llmbda*( 0.209364 -
     *      llmbda*(0.45525 - llmbda*(0.50142 - 0.081234*llmbda))))
          ELSE
            omega2 = chia2*(lambda + 4)*(-2.77164 + llmbda*(2.94874 - ll
     *      mbda*(0.1535754 - llmbda*0.00552888)))
          END IF
          find_index = .false.
        END IF
12630   CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        xi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        ak = xi*31
        k = ak
        ak = ak - k
        IF((ak .GT. wms_array(i,j,k)))k = ims_array(i,j,k)
        a = fms_array(i,j,k)
        u = ums_array(i,j,k)
        du = ums_array(i,j,k+1) - u
        IF((rng_seed .GT. 128))call ranmar_get
        xi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( abs(a) .LT. 0.2 )) THEN
          x1 = 0.5*(1-xi)*a
          u = u + xi*du*(1+x1*(1-xi*a))
        ELSE
          u = u - du/a*(1-Sqrt(1+xi*a*(2+a)))
        END IF
        xi = omega2*u/(1 + 0.5*omega2 - u)
        IF (( xi .GT. 1.99999 )) THEN
          xi = 1.99999
        END IF
        cost = 1 - xi
        IF (( spin_effects )) THEN
          rejf=spin_rejection(qel,medium,elke,beta2,q1,cost,spin_index,.
     *    false.)
          IF((rng_seed .GT. 128))call ranmar_get
          rnno = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF (( rnno .GT. rejf )) THEN
            GOTO 12630
          END IF
        END IF
        sint = sqrt(xi*(2-xi))
        return
      END IF
      write(i_log,*) ' '
      write(i_log,*) ' *************************************'
      write(i_log,*) ' Maximum step size in mscat exceeded! '
      write(i_log,*) ' Maximum step size initialized: 100000'
      write(i_log,*) ' Present lambda: ',lambda
      write(i_log,*) ' chia2: ',chia2
      write(i_log,*) ' q1 elke beta2: ',q1,elke,beta2
      write(i_log,*) ' medium: ',medium
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' Stopping execution'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      real*8 function spin_rejection(qel,medium,elke,beta2,q1,cost, spin
     *_index,is_single)
      implicit none
      real*8 elke,beta2,q1,cost
      integer*4 qel,medium
      logical spin_index,is_single
      common/spin_data/ spin_rej(10,0:1,0: 31,0:15,0:31), espin_min,espi
     *n_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dleneri,d
     *qq1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      real*8 rnno,ai,qq1,aj,xi,ak
      integer*4 i,j,k
      save i,j
      IF (( spin_index )) THEN
        spin_index = .false.
        IF (( beta2 .GE. b2spin_min )) THEN
          ai = (beta2 - b2spin_min)*dbeta2i
          i = ai
          ai = ai - i
          i = i + 15 + 1
        ELSE IF(( elke .GT. espml )) THEN
          ai = (elke - espml)*dleneri
          i = ai
          ai = ai - i
        ELSE
          i = 0
          ai = -1
        END IF
        IF((rng_seed .GT. 128))call ranmar_get
        rnno = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((rnno .LT. ai))i = i + 1
        IF (( is_single )) THEN
          j = 0
        ELSE
          qq1 = 2*q1
          qq1 = qq1/(1 + qq1)
          aj = qq1*dqq1i
          j = aj
          IF (( j .GE. 15 )) THEN
            j = 15
          ELSE
            aj = aj - j
            IF((rng_seed .GT. 128))call ranmar_get
            rnno = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rnno .LT. aj))j = j + 1
          END IF
        END IF
      END IF
      xi = Sqrt(0.5*(1-cost))
      ak = xi*31
      k = ak
      ak = ak - k
      spin_rejection = (1-ak)*spin_rej(medium,qel,i,j,k) + ak*spin_rej(m
     *edium,qel,i,j,k+1)
      return
      end
      subroutine sscat(chia2,elke,beta2,qel,medium,spin_effects,cost,sin
     *t)
      implicit none
      real*8 chia2,elke,beta2,cost,sint
      integer*4 qel,medium
      logical spin_effects
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      real*8 xi,rnno,rejf,spin_rejection,qzero
      logical spin_index
      spin_index = .true.
12640 CONTINUE
      IF((rng_seed .GT. 128))call ranmar_get
      xi = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      xi = 2*chia2*xi/(1 - xi + chia2)
      cost = 1 - xi
      IF (( spin_effects )) THEN
        qzero=0
        rejf = spin_rejection(qel,medium,elke,beta2,qzero,cost,spin_inde
     *  x,.true.)
        IF((rng_seed .GT. 128))call ranmar_get
        rnno = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((rnno .GT. rejf))goto 12640
      END IF
      sint = sqrt(xi*(2 - xi))
      return
      end
      subroutine init_ms_SR
      implicit none
      common/ms_data/ ums_array(0:63,0:7,0:31), fms_array(0:63,0:7,0:31)
     *, wms_array(0:63,0:7,0:31), ims_array(0:63,0:7,0:31), llammin,llam
     *max,dllamb,dllambi,dqms,dqmsi
      real*4 ums_array,fms_array,wms_array, llammin,llammax,dllamb,dllam
     *bi,dqms,dqmsi
      integer*2 ims_array
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,j,k
      write(i_log,'(/a,$)') 'Reading screened Rutherford MS data .......
     *........ '
      rewind(i_mscat)
      DO 12651 i=0,63
        DO 12661 j=0,7
          read(i_mscat,*) (ums_array(i,j,k),k=0,31)
          read(i_mscat,*) (fms_array(i,j,k),k=0,31)
          read(i_mscat,*) (wms_array(i,j,k),k=0,31-1)
          read(i_mscat,*) (ims_array(i,j,k),k=0,31-1)
          DO 12671 k=0,31-1
            fms_array(i,j,k) = fms_array(i,j,k+1)/fms_array(i,j,k)-1
            ims_array(i,j,k) = ims_array(i,j,k)-1
12671     CONTINUE
12672     CONTINUE
          fms_array(i,j,31)=fms_array(i,j,31-1)
12661   CONTINUE
12662   CONTINUE
12651 CONTINUE
12652 CONTINUE
      write(i_log,'(a)') ' done '
      llammin = Log(1.)
      llammax = Log(1e5)
      dllamb = (llammax-llammin)/63
      dllambi = 1./dllamb
      dqms = 0.5/7
      dqmsi = 1./dqms
      return
      end
      subroutine init_spin
      implicit none
      common/spin_data/ spin_rej(10,0:1,0: 31,0:15,0:31), espin_min,espi
     *n_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dleneri,d
     *qq1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 eta_array(0:1,0: 31), c_array(0:1,0: 31),g_array(0:1,0: 31)
     *, earray(0: 31),tmp_array(0: 31), sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,
     *Z23,g_m,g_r,sig,dedx, tau,tauc,beta2,eta,gamma,fmax, eil,e,si1e,si
     *2e,si1p,si2p,aae,etap, elarray(0: 31),farray(0: 31), af(0: 31),bf(
     *0: 31),cf(0: 31), df(0: 31),spline,dloge,eloge
      real*4 dum1,dum2,dum3,aux_o
      real*4 fmax_array(0:15)
      integer*2 i2_array(512),ii2
      integer*4 iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke, nd
     *ata,leil,length,ii4,irec
      character spin_file*256
      character*6 string
      integer*4 lnblnk1
      integer*4 spin_unit, rec_length, want_spin_unit
      integer egs_get_unit
      character data_version*32,endianess*4
      logical swap
      real*8 fine,TF_constant
      parameter (fine=137.03604,TF_constant=0.88534138)
      real*4 tmp_4
      character c_2(2), c_4(4)
      equivalence (ii2,c_2), (tmp_4,c_4)
      DO 12681 i=1,len(spin_file)
        spin_file(i:i) = ' '
12681 CONTINUE
12682 CONTINUE
      spin_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'sp
     *inms.data'
      want_spin_unit = 61
      spin_unit = egs_get_unit(want_spin_unit)
      IF (( spin_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'init_spin: failed to get a free fortran unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      rec_length = 276*4
      open(spin_unit,file=spin_file,form='unformatted',access='direct',
     *status='old',recl=rec_length,err=12690)
      read(spin_unit,rec=1,err=12700) data_version,endianess, espin_min,
     *espin_max,b2spin_min,b2spin_max
      swap = endianess.ne.'1234'
      IF (( swap )) THEN
        tmp_4 = espin_min
        call egs_swap_4(c_4)
        espin_min = tmp_4
        tmp_4 = espin_max
        call egs_swap_4(c_4)
        espin_max = tmp_4
        tmp_4 = b2spin_min
        call egs_swap_4(c_4)
        b2spin_min = tmp_4
        tmp_4 = b2spin_max
        call egs_swap_4(c_4)
        b2spin_max = tmp_4
      END IF
      write(i_log,'(//a,a)') 'Reading spin data base from ',spin_file(:l
     *nblnk1(spin_file))
      write(i_log,'(a)') data_version
      write(i_log,'(a,a,a)') 'Data generated on a machine with ',endiane
     *ss, ' endianess'
      write(i_log,'(a,a)') 'The endianess of this CPU is ','1234'
      IF((swap))write(i_log,'(a)') '=> will need to do byte swaping'
      write(i_log,'(a,2f9.2,2f9.5,//)') 'Ranges: ',espin_min,espin_max,
     *b2spin_min,b2spin_max
      n_ener = 15
      n_q = 15
      n_point = 31
      dloge = log(espin_max/espin_min)/n_ener
      eloge = log(espin_min)
      earray(0) = espin_min
      IF (( fool_intel_optimizer )) THEN
        write(25,*) 'Energy grid:'
      END IF
      DO 12711 i=1,n_ener
        eloge = eloge + dloge
        earray(i) = exp(eloge)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) i,earray(i)
        END IF
12711 CONTINUE
12712 CONTINUE
      dbeta2 = (b2spin_max - b2spin_min)/n_ener
      beta2 = b2spin_min
      earray(n_ener+1) = espin_max
      DO 12721 i=n_ener+2,2*n_ener+1
        beta2 = beta2 + dbeta2
        IF (( beta2 .LT. 0.999 )) THEN
          earray(i) = prm*1000.0*(1/sqrt(1-beta2)-1)
        ELSE
          earray(i) = 50585.1
        END IF
        IF (( fool_intel_optimizer )) THEN
          write(25,*) i,earray(i)
        END IF
12721 CONTINUE
12722 CONTINUE
      espin_min = espin_min/1000
      espin_max = espin_max/1000
      dlener = Log(espin_max/espin_min)/15
      dleneri = 1/dlener
      espml = Log(espin_min)
      dbeta2 = (b2spin_max-b2spin_min)/15
      dbeta2i = 1/dbeta2
      dqq1 = 0.5/15
      dqq1i = 1/dqq1
      DO 12731 medium=1,NMED
        write(i_log,'(a,i4,a,$)') '  medium ',medium,' .................
     *.... '
        DO 12741 iq=0,1
          DO 12751 i=0, 31
            eta_array(iq,i)=0
            c_array(iq,i)=0
            g_array(iq,i)=0
            DO 12761 j=0,15
              DO 12771 k=0,31
                spin_rej(medium,iq,i,j,k) = 0
12771         CONTINUE
12772         CONTINUE
12761       CONTINUE
12762       CONTINUE
12751     CONTINUE
12752     CONTINUE
12741   CONTINUE
12742   CONTINUE
        sum_Z2=0
        sum_A=0
        sum_pz=0
        sum_Z=0
        DO 12781 i_ele=1,NNE(medium)
          Z = ZELEM(medium,i_ele)
          iZ = int(Z+0.5)
          IF (( fool_intel_optimizer )) THEN
            write(25,*) ' Z = ',iZ
          END IF
          tmp = PZ(medium,i_ele)*Z*(Z+1)
          sum_Z2 = sum_Z2 + tmp
          sum_Z = sum_Z + PZ(medium,i_ele)*Z
          sum_A = sum_A + PZ(medium,i_ele)*WA(medium,i_ele)
          sum_pz = sum_pz + PZ(medium,i_ele)
          Z23 = Z**0.6666667
          DO 12791 iq=0,1
            DO 12801 i=0, 31
              irec = 1 + (iz-1)*4*(n_ener+1) + 2*iq*(n_ener+1) + i+1
              IF (( fool_intel_optimizer )) THEN
                write(25,*) '**** energy ',i,earray(i),irec
              END IF
              read(spin_unit,rec=irec,err=12700) dum1,dum2,dum3,aux_o,fm
     *        ax_array,i2_array
              IF (( swap )) THEN
                tmp_4 = dum1
                call egs_swap_4(c_4)
                dum1 = tmp_4
                tmp_4 = dum2
                call egs_swap_4(c_4)
                dum2 = tmp_4
                tmp_4 = dum3
                call egs_swap_4(c_4)
                dum3 = tmp_4
                tmp_4 = aux_o
                call egs_swap_4(c_4)
                aux_o = tmp_4
              END IF
              eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o)
              tau = earray(i)/prm*0.001
              beta2 = tau*(tau+2)/(tau+1)**2
              eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2)
              c_array(iq,i)=c_array(iq,i)+ tmp*(Log(1+1/eta)-1/(1+eta))*
     *        dum1*dum3
              g_array(iq,i)=g_array(iq,i)+tmp*dum2
              DO 12811 j=0,15
                tmp_4 = fmax_array(j)
                IF((swap))call egs_swap_4(c_4)
                DO 12821 k=0,31
                  ii2 = i2_array((n_point+1)*j + k+1)
                  IF((swap))call egs_swap_2(c_2)
                  ii4 = ii2
                  IF((ii4 .LT. 0))ii4 = ii4 + 65536
                  dum1 = ii4
                  dum1 = dum1*tmp_4/65535
                  spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)
     *            + tmp*dum1
12821           CONTINUE
12822           CONTINUE
12811         CONTINUE
12812         CONTINUE
12801       CONTINUE
12802       CONTINUE
12791     CONTINUE
12792     CONTINUE
12781   CONTINUE
12782   CONTINUE
        DO 12831 iq=0,1
          DO 12841 i=0, 31
            DO 12851 j=0,15
              fmax = 0
              DO 12861 k=0,31
                IF (( spin_rej(medium,iq,i,j,k) .GT. fmax )) THEN
                  fmax = spin_rej(medium,iq,i,j,k)
                END IF
12861         CONTINUE
12862         CONTINUE
              DO 12871 k=0,31
                spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fm
     *          ax
12871         CONTINUE
12872         CONTINUE
12851       CONTINUE
12852       CONTINUE
12841     CONTINUE
12842     CONTINUE
12831   CONTINUE
12832   CONTINUE
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Spin corrections as read in from file'
        END IF
        DO 12881 i=0, 31
          tau = earray(i)/prm*0.001
          beta2 = tau*(tau+2)/(tau+1)**2
          DO 12891 iq=0,1
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium)
            eta = aux_o/4/tau/(tau+2)
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/ (Log(1+1/eta)*
     *      (1+eta)-1)
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta)
     *      )
12891     CONTINUE
12892     CONTINUE
          IF (( fool_intel_optimizer )) THEN
            write(25,*) i,earray(i),eta_array(0,i),eta_array(1,i), c_arr
     *      ay(0,i),c_array(1,i),g_array(0,i),g_array(1,i)
          END IF
12881   CONTINUE
12882   CONTINUE
        eil = (1 - eke0(medium))/eke1(medium)
        e = Exp(eil)
        IF (( e .LE. espin_min )) THEN
          si1e = eta_array(0,0)
          si1p = eta_array(1,0)
        ELSE
          IF (( e .LE. espin_max )) THEN
            aae = (eil-espml)*dleneri
            je = aae
            aae = aae - je
          ELSE
            tau = e/prm
            beta2 = tau*(tau+2)/(tau+1)**2
            aae = (beta2 - b2spin_min)*dbeta2i
            je = aae
            aae = aae - je
            je = je + 15 + 1
          END IF
          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
        END IF
        neke = meke(medium)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for eta correction'
        END IF
        DO 12901 i=1,neke - 1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          IF (( e .LE. espin_min )) THEN
            si2e = eta_array(0,0)
            si2p = eta_array(1,0)
          ELSE
            IF (( e .LE. espin_max )) THEN
              aae = (eil-espml)*dleneri
              je = aae
              aae = aae - je
            ELSE
              tau = e/prm
              beta2 = tau*(tau+2)/(tau+1)**2
              aae = (beta2 - b2spin_min)*dbeta2i
              je = aae
              aae = aae - je
              je = je + 15 + 1
            END IF
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
          END IF
          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil
          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium)
          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) i,e,si2e,si2p,etae_ms1(i,medium), etae_ms0(i,med
     *      ium),etap_ms1(i,medium),etap_ms0(i,medium)
          END IF
          si1e = si2e
          si1p = si2p
12901   CONTINUE
12902   CONTINUE
        etae_ms1(neke,medium) = etae_ms1(neke-1,medium)
        etae_ms0(neke,medium) = etae_ms0(neke-1,medium)
        etap_ms1(neke,medium) = etap_ms1(neke-1,medium)
        etap_ms0(neke,medium) = etap_ms0(neke-1,medium)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'elarray:'
        END IF
        DO 12911 i=0,15
          elarray(i) = Log(earray(i)/1000)
          farray(i) = c_array(0,i)
          IF (( fool_intel_optimizer )) THEN
            write(25,*) elarray(i),earray(i)
          END IF
12911   CONTINUE
12912   CONTINUE
        DO 12921 i=15+1, 31-1
          elarray(i) = Log(earray(i+1)/1000)
          farray(i) = c_array(0,i+1)
          IF (( fool_intel_optimizer )) THEN
            write(25,*) elarray(i),earray(i+1)
          END IF
12921   CONTINUE
12922   CONTINUE
        ndata =  31+1
        IF (( ue(medium) .GT. 1e5 )) THEN
          elarray(ndata-1) = Log(ue(medium))
        ELSE
          elarray(ndata-1) = Log(1e5)
        END IF
        farray(ndata-1) = 1
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q1 correction (e-)'
        END IF
        DO 12931 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q1ce_ms1(i,medium), q1ce_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
12931   CONTINUE
12932   CONTINUE
        q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium)
        q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Postrons:'
        END IF
        DO 12941 i=0,15
          farray(i) = c_array(1,i)
12941   CONTINUE
12942   CONTINUE
        DO 12951 i=15+1, 31-1
          farray(i) = c_array(1,i+1)
12951   CONTINUE
12952   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q1 correction (e+)'
        END IF
        DO 12961 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q1cp_ms1(i,medium), q1cp_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
12961   CONTINUE
12962   CONTINUE
        q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium)
        q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium)
        DO 12971 i=0,15
          farray(i) = g_array(0,i)
12971   CONTINUE
12972   CONTINUE
        DO 12981 i=15+1, 31-1
          farray(i) = g_array(0,i+1)
12981   CONTINUE
12982   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q2 correction (e-)'
        END IF
        DO 12991 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q2ce_ms1(i,medium), q2ce_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
12991   CONTINUE
12992   CONTINUE
        q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium)
        q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium)
        DO 13001 i=0,15
          farray(i) = g_array(1,i)
13001   CONTINUE
13002   CONTINUE
        DO 13011 i=15+1, 31-1
          farray(i) = g_array(1,i+1)
13011   CONTINUE
13012   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q2 correction (e+)'
        END IF
        DO 13021 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q2cp_ms1(i,medium), q2cp_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
13021   CONTINUE
13022   CONTINUE
        q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium)
        q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium)
        tauc = te(medium)/prm
        si1e = 1
        DO 13031 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          leil=i+1
          tau=e/prm
          IF (( tau .GT. 2*tauc )) THEN
            sig=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
            dedx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
            sig = sig/dedx
            IF (( sig .GT. 1e-6 )) THEN
              etap=etae_ms1(Leil,MEDIUM)*eil+etae_ms0(Leil,MEDIUM)
              eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2)
              g_r = (1+2*eta)*Log(1+1/eta)-2
              g_m = Log(0.5*tau/tauc)+ (1+((tau+2)/(tau+1))**2)*Log(2*(t
     *        au-tauc+2)/(tau+4))- 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+
     *        1)**2)* Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+ 0.5*(tau
     *        -2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2)
              IF (( g_m .LT. g_r )) THEN
                g_m = g_m/g_r
              ELSE
                g_m = 1
              END IF
              si2e = 1 - g_m*sum_Z/sum_Z2
            ELSE
              si2e = 1
            END IF
          ELSE
            si2e = 1
          END IF
          blcce1(i,medium) = (si2e - si1e)*eke1(medium)
          blcce0(i,medium) = si2e - blcce1(i,medium)*eil
          si1e = si2e
13031   CONTINUE
13032   CONTINUE
        blcce1(neke,medium) = blcce1(neke-1,medium)
        blcce0(neke,medium) = blcce0(neke-1,medium)
        write(i_log,'(a)') ' done'
12731 CONTINUE
12732 CONTINUE
      close(spin_unit)
      return
12690 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,a)') 'Failed to open spin data file ',spin_file(:l
     *nblnk1(spin_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
12700 write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Error while reading spin data file for element',iZ
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine init_spin_old
      implicit none
      common/spin_data/ spin_rej(10,0:1,0: 31,0:15,0:31), espin_min,espi
     *n_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dleneri,d
     *qq1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 eta_array(0:1,0: 31), c_array(0:1,0: 31),g_array(0:1,0: 31)
     *, earray(0: 31),tmp_array(0: 31), sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,
     *Z23,g_m,g_r,sig,dedx, dum1,dum2,dum3,aux_o,tau,tauc,beta2,eta,gamm
     *a,fmax, eil,e,si1e,si2e,si1p,si2p,aae,etap, elarray(0: 31),farray(
     *0: 31), af(0: 31),bf(0: 31),cf(0: 31), df(0: 31),spline
      integer*4 iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke, nd
     *ata,leil,length,want_spin_unit,spin_unit,egs_get_unit
      character spin_file*256
      character*6 string
      integer*4 lnblnk1
      real*8 fine,TF_constant
      parameter (fine=137.03604,TF_constant=0.88534138)
      DO 13041 i=1,len(spin_file)
        spin_file(i:i) = ' '
13041 CONTINUE
13042 CONTINUE
      spin_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'sp
     *inms' // '/' // 'z000'
      length = lnblnk1(spin_file)
      DO 13051 medium=1,NMED
        write(i_log,'(a,i4,a,$)') '  Initializing spin data for medium '
     *  ,medium, ' ..................... '
        DO 13061 iq=0,1
          DO 13071 i=0, 31
            eta_array(iq,i)=0
            c_array(iq,i)=0
            g_array(iq,i)=0
            DO 13081 j=0,15
              DO 13091 k=0,31
                spin_rej(medium,iq,i,j,k) = 0
13091         CONTINUE
13092         CONTINUE
13081       CONTINUE
13082       CONTINUE
13071     CONTINUE
13072     CONTINUE
13061   CONTINUE
13062   CONTINUE
        sum_Z2=0
        sum_A=0
        sum_pz=0
        sum_Z=0
        DO 13101 i_ele=1,NNE(medium)
          Z = ZELEM(medium,i_ele)
          iZ = int(Z+0.5)
          tmp = PZ(medium,i_ele)*Z*(Z+1)
          iii = iZ/100
          spin_file(length-2:length-2) = char(iii+48)
          iiZ = iZ - iii*100
          iii = iiZ/10
          spin_file(length-1:length-1) = char(iii+48)
          iiZ = iiZ - 10*iii
          spin_file(length:length) = char(iiZ+48)
          want_spin_unit = 61
          spin_unit = egs_get_unit(want_spin_unit)
          IF (( spin_unit .LT. 1 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'init_spin: failed to get a free fortran unit
     *'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(spin_unit,file=spin_file,status='old',err=13110)
          read(spin_unit,*) espin_min,espin_max,b2spin_min,b2spin_max
          read(spin_unit,*) n_ener,n_q,n_point
          IF (( n_ener .NE. 15 .OR. n_q .NE. 15 .OR. n_point .NE. 31)) T
     *    HEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) ' Wrong spin file for Z = ',iZ
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          sum_Z2 = sum_Z2 + tmp
          sum_Z = sum_Z + PZ(medium,i_ele)*Z
          sum_A = sum_A + PZ(medium,i_ele)*WA(medium,i_ele)
          sum_pz = sum_pz + PZ(medium,i_ele)
          Z23 = Z**0.6666667
          DO 13121 iq=0,1
            read(spin_unit,*)
            read(spin_unit,*)
            DO 13131 i=0, 31
              read(spin_unit,'(a,g14.6)') string,earray(i)
              read(spin_unit,*) dum1,dum2,dum3,aux_o
              eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o)
              tau = earray(i)/prm*0.001
              beta2 = tau*(tau+2)/(tau+1)**2
              eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2)
              c_array(iq,i)=c_array(iq,i)+ tmp*(Log(1+1/eta)-1/(1+eta))*
     *        dum1*dum3
              g_array(iq,i)=g_array(iq,i)+tmp*dum2
              DO 13141 j=0,15
                read(spin_unit,*) tmp_array
                DO 13151 k=0,31
                  spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)
     *            + tmp*tmp_array(k)
13151           CONTINUE
13152           CONTINUE
13141         CONTINUE
13142         CONTINUE
13131       CONTINUE
13132       CONTINUE
13121     CONTINUE
13122     CONTINUE
          close(spin_unit)
13101   CONTINUE
13102   CONTINUE
        DO 13161 iq=0,1
          DO 13171 i=0, 31
            DO 13181 j=0,15
              fmax = 0
              DO 13191 k=0,31
                IF (( spin_rej(medium,iq,i,j,k) .GT. fmax )) THEN
                  fmax = spin_rej(medium,iq,i,j,k)
                END IF
13191         CONTINUE
13192         CONTINUE
              DO 13201 k=0,31
                spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fm
     *          ax
13201         CONTINUE
13202         CONTINUE
13181       CONTINUE
13182       CONTINUE
13171     CONTINUE
13172     CONTINUE
13161   CONTINUE
13162   CONTINUE
        DO 13211 i=0, 31
          tau = earray(i)/prm*0.001
          beta2 = tau*(tau+2)/(tau+1)**2
          DO 13221 iq=0,1
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium)
            eta = aux_o/4/tau/(tau+2)
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/ (Log(1+1/eta)*
     *      (1+eta)-1)
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta)
     *      )
13221     CONTINUE
13222     CONTINUE
13211   CONTINUE
13212   CONTINUE
        espin_min = espin_min/1000
        espin_max = espin_max/1000
        dlener = Log(espin_max/espin_min)/15
        dleneri = 1/dlener
        espml = Log(espin_min)
        dbeta2 = (b2spin_max-b2spin_min)/15
        dbeta2i = 1/dbeta2
        dqq1 = 0.5/15
        dqq1i = 1/dqq1
        eil = (1 - eke0(medium))/eke1(medium)
        e = Exp(eil)
        IF (( e .LE. espin_min )) THEN
          si1e = eta_array(0,0)
          si1p = eta_array(1,0)
        ELSE
          IF (( e .LE. espin_max )) THEN
            aae = (eil-espml)*dleneri
            je = aae
            aae = aae - je
          ELSE
            tau = e/prm
            beta2 = tau*(tau+2)/(tau+1)**2
            aae = (beta2 - b2spin_min)*dbeta2i
            je = aae
            aae = aae - je
            je = je + 15 + 1
          END IF
          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
        END IF
        neke = meke(medium)
        DO 13231 i=1,neke - 1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          IF (( e .LE. espin_min )) THEN
            si2e = eta_array(0,0)
            si2p = eta_array(1,0)
          ELSE
            IF (( e .LE. espin_max )) THEN
              aae = (eil-espml)*dleneri
              je = aae
              aae = aae - je
            ELSE
              tau = e/prm
              beta2 = tau*(tau+2)/(tau+1)**2
              aae = (beta2 - b2spin_min)*dbeta2i
              je = aae
              aae = aae - je
              je = je + 15 + 1
            END IF
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
          END IF
          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil
          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium)
          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil
          si1e = si2e
          si1p = si2p
13231   CONTINUE
13232   CONTINUE
        etae_ms1(neke,medium) = etae_ms1(neke-1,medium)
        etae_ms0(neke,medium) = etae_ms0(neke-1,medium)
        etap_ms1(neke,medium) = etap_ms1(neke-1,medium)
        etap_ms0(neke,medium) = etap_ms0(neke-1,medium)
        DO 13241 i=0,15
          elarray(i) = Log(earray(i)/1000)
          farray(i) = c_array(0,i)
13241   CONTINUE
13242   CONTINUE
        DO 13251 i=15+1, 31-1
          elarray(i) = Log(earray(i+1)/1000)
          farray(i) = c_array(0,i+1)
13251   CONTINUE
13252   CONTINUE
        ndata =  31+1
        IF (( ue(medium) .GT. 1e5 )) THEN
          elarray(ndata-1) = Log(ue(medium))
        ELSE
          elarray(ndata-1) = Log(1e5)
        END IF
        farray(ndata-1) = 1
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 13261 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil
          si1e = si2e
13261   CONTINUE
13262   CONTINUE
        q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium)
        q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium)
        DO 13271 i=0,15
          farray(i) = c_array(1,i)
13271   CONTINUE
13272   CONTINUE
        DO 13281 i=15+1, 31-1
          farray(i) = c_array(1,i+1)
13281   CONTINUE
13282   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 13291 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil
          si1e = si2e
13291   CONTINUE
13292   CONTINUE
        q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium)
        q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium)
        DO 13301 i=0,15
          farray(i) = g_array(0,i)
13301   CONTINUE
13302   CONTINUE
        DO 13311 i=15+1, 31-1
          farray(i) = g_array(0,i+1)
13311   CONTINUE
13312   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 13321 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil
          si1e = si2e
13321   CONTINUE
13322   CONTINUE
        q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium)
        q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium)
        DO 13331 i=0,15
          farray(i) = g_array(1,i)
13331   CONTINUE
13332   CONTINUE
        DO 13341 i=15+1, 31-1
          farray(i) = g_array(1,i+1)
13341   CONTINUE
13342   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 13351 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil
13351   CONTINUE
13352   CONTINUE
        q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium)
        q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium)
        tauc = te(medium)/prm
        si1e = 1
        DO 13361 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          leil=i+1
          tau=e/prm
          IF (( tau .GT. 2*tauc )) THEN
            sig=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
            dedx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
            sig = sig/dedx
            IF (( sig .GT. 1e-6 )) THEN
              etap=etae_ms1(Leil,MEDIUM)*eil+etae_ms0(Leil,MEDIUM)
              eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2)
              g_r = (1+2*eta)*Log(1+1/eta)-2
              g_m = Log(0.5*tau/tauc)+ (1+((tau+2)/(tau+1))**2)*Log(2*(t
     *        au-tauc+2)/(tau+4))- 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+
     *        1)**2)* Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+ 0.5*(tau
     *        -2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2)
              IF (( g_m .LT. g_r )) THEN
                g_m = g_m/g_r
              ELSE
                g_m = 1
              END IF
              si2e = 1 - g_m*sum_Z/sum_Z2
            ELSE
              si2e = 1
            END IF
          ELSE
            si2e = 1
          END IF
          blcce1(i,medium) = (si2e - si1e)*eke1(medium)
          blcce0(i,medium) = si2e - blcce1(i,medium)*eil
          si1e = si2e
13361   CONTINUE
13362   CONTINUE
        blcce1(neke,medium) = blcce1(neke-1,medium)
        blcce0(neke,medium) = blcce0(neke-1,medium)
        write(i_log,'(a)') ' done'
13051 CONTINUE
13052 CONTINUE
      return
13110 write(i_log,*) ' ******************** Error in init_spin *********
     *********** '
      write(i_log,'(a,a)') '  could not open file ',spin_file
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' terminating execution '
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      subroutine msdist_pII ( e0,eloss,tustep,rhof,med,qel,spin_effects,
     *u0,v0,w0,x0,y0,z0,  us,vs,ws,xf,yf,zf,ustep )
      implicit none
      real*8 e0,  eloss,  rhof,  tustep,  u0,  v0,  w0,  x0,  y0,  z0
      integer*4 med, qel
      logical spin_effects
      real*8 us,  vs,  ws,  xf,  yf,  zf,  ustep
      real*8 b,  blccc,  xcccc,  c,  eta,eta1,  chia2,  chilog,  cphi0,
     *  cphi1,  cphi2,  w1,  w2,  w1v2,  delta,  e,  elke,  beta2,  etap
     *,  xi_corr,  ms_corr, tau,  tau2,  epsilon,  epsilonp,  temp,temp1
     *, temp2,  factor,  gamma,  lambda,   p2,  p2i,  q1,  rhophi2,  sin
     *t0,  sint02,  sint0i,  sint1,  sint2,  sphi0,   sphi1,  sphi2,  u2
     *p,  u2,  v2,  ut,  vt,  wt,  xi,  xphi,  xphi2,  yphi,  yphi2
      logical find_index,  spin_index
      integer*4 lelke
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      medium = med
      count_pII_steps = count_pII_steps + 1
      blccc = blcc(medium)
      xcccc = xcc(medium)
      e = e0 - 0.5*eloss
      tau = e/prm
      tau2 = tau*tau
      epsilon = eloss/e0
      epsilonp= eloss/e
      e = e * (1 - epsilonp*epsilonp*(6+10*tau+5*tau2)/(24*tau2+72*tau+4
     *8))
      p2 = e*(e + rmt2)
      beta2 = p2/(p2 + rmsq)
      chia2 = xcccc/(4*p2*blccc)
      lambda = 0.5*tustep*rhof*blccc/beta2
      temp2 = 0.166666*(4+tau*(6+tau*(7+tau*(4+tau))))* (epsilonp/((tau+
     *1)*(tau+2)))**2
      lambda = lambda*(1 - temp2)
      IF (( spin_effects )) THEN
        elke = Log(e)
        Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
        IF (( lelke .LT. 1 )) THEN
          lelke = 1
          elke = (1 - eke0(medium))/eke1(medium)
        END IF
        IF (( qel .EQ. 0 )) THEN
          etap=etae_ms1(Lelke,MEDIUM)*elke+etae_ms0(Lelke,MEDIUM)
          xi_corr=q1ce_ms1(Lelke,MEDIUM)*elke+q1ce_ms0(Lelke,MEDIUM)
          gamma=q2ce_ms1(Lelke,MEDIUM)*elke+q2ce_ms0(Lelke,MEDIUM)
        ELSE
          etap=etap_ms1(Lelke,MEDIUM)*elke+etap_ms0(Lelke,MEDIUM)
          xi_corr=q1cp_ms1(Lelke,MEDIUM)*elke+q1cp_ms0(Lelke,MEDIUM)
          gamma=q2cp_ms1(Lelke,MEDIUM)*elke+q2cp_ms0(Lelke,MEDIUM)
        END IF
        ms_corr=blcce1(Lelke,MEDIUM)*elke+blcce0(Lelke,MEDIUM)
      ELSE
        etap = 1
        xi_corr = 1
        gamma = 1
        ms_corr = 1
      END IF
      chia2 = chia2*etap
      lambda = lambda/(etap*(1+chia2))*ms_corr
      chilog = Log(1 + 1/chia2)
      q1 = 2*chia2*(chilog*(1 + chia2) - 1)
      gamma = 6*chia2*(1 + chia2)*(chilog*(1 + 2*chia2) - 2)/q1*gamma
      xi = q1*lambda
      find_index = .true.
      spin_index = .true.
      call mscat(lambda,chia2,xi,elke,beta2,qel,medium, spin_effects,fin
     *d_index,spin_index, w1,sint1)
13371 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        xphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF((rng_seed .GT. 128))call ranmar_get
        yphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO13372
      GO TO 13371
13372 CONTINUE
      rhophi2 = 1/rhophi2
      cphi1 = (xphi2 - yphi2)*rhophi2
      sphi1 = 2*xphi*yphi*rhophi2
      call mscat(lambda,chia2,xi,elke,beta2,qel,medium, spin_effects,fin
     *d_index,spin_index, w2,sint2)
13381 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        xphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF((rng_seed .GT. 128))call ranmar_get
        yphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO13382
      GO TO 13381
13382 CONTINUE
      rhophi2 = 1/rhophi2
      cphi2 = (xphi2 - yphi2)*rhophi2
      sphi2 = 2*xphi*yphi*rhophi2
      u2 = sint2*cphi2
      v2 = sint2*sphi2
      u2p = w1*u2 + sint1*w2
      us = u2p*cphi1 - v2*sphi1
      vs = u2p*sphi1 + v2*cphi1
      ws = w1*w2 - sint1*u2
      xi = 2*xi*xi_corr
      IF((rng_seed .GT. 128))call ranmar_get
      eta = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      eta = Sqrt(eta)
      eta1 = 0.5*(1 - eta)
      delta = 0.9082483-(0.1020621-0.0263747*gamma)*xi
      temp1 = 2 + tau
      temp = (2+tau*temp1)/((tau+1)*temp1)
      temp = temp - (tau+1)/((tau+2)*(chilog*(1+chia2)-1))
      temp = temp * epsilonp
      temp1 = 1 - temp
      delta = delta + 0.40824829*(epsilon*(tau+1)/((tau+2)* (chilog*(1+c
     *hia2)-1)*(chilog*(1+2*chia2)-2)) - 0.25*temp*temp)
      b = eta*delta
      c = eta*(1-delta)
      w1v2 = w1*v2
      ut = b*sint1*cphi1 + c*(cphi1*u2 - sphi1*w1v2) + eta1*us*temp1
      vt = b*sint1*sphi1 + c*(sphi1*u2 + cphi1*w1v2) + eta1*vs*temp1
      wt = eta1*(1+temp) + b*w1 + c*w2 + eta1*ws*temp1
      ustep = tustep*sqrt(ut*ut + vt*vt + wt*wt)
      sint02 = u0**2 + v0**2
      IF ((sint02 .GT. 1e-20)) THEN
        sint0 = sqrt(sint02)
        sint0i = 1/sint0
        cphi0 = sint0i*u0
        sphi0 = sint0i*v0
        u2p = w0*us + sint0*ws
        ws = w0*ws - sint0*us
        us = u2p*cphi0 - vs*sphi0
        vs = u2p*sphi0 + vs*cphi0
        u2p = w0*ut + sint0*wt
        wt = w0*wt - sint0*ut
        ut = u2p*cphi0 - vt*sphi0
        vt = u2p*sphi0 + vt*cphi0
      ELSE
        wt = w0*wt
        ws = w0*ws
      END IF
      xf = x0 + tustep*ut
      yf = y0 + tustep*vt
      zf = z0 + tustep*wt
      return
      end
      subroutine msdist_pI ( e0,eloss,tustep,rhof,medium,qel,spin_effect
     *s,u0,v0,w0,x0,y0,z0,  us,vs,ws,xf,yf,zf,ustep )
      implicit none
      real*8 e0,  eloss,  rhof,  tustep,  u0,  v0,  w0,  x0,  y0,  z0
      integer*4 medium, qel
      logical spin_effects
      real*8 us,  vs,  ws,  xf,  yf,  zf,  ustep
      real*8 blccc,  xcccc,  z,r,z2,r2,  r2max, chia2,  chilog,  cphi0,
     *  cphi,  sphi,  e,  elke,  beta2,  etap,  xi_corr,  ms_corr, epsil
     *on,  temp,  factor,  lambda,  p2,  p2i,  q1,  rhophi2,  sint,  sin
     *t0,  sint02,  sint0i,  sphi0,   u2p,  ut,  vt,  wt,  xi,  xphi,  x
     *phi2,  yphi,  yphi2
      logical find_index,  spin_index
      integer*4 lelke
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      blccc = blcc(medium)
      xcccc = xcc(medium)
      e = e0 - 0.5*eloss
      p2 = e*(e + rmt2)
      p2i = 1/p2
      chia2 = xcccc*p2i/(4*blccc)
      beta2 = p2/(p2 + rmsq)
      lambda = tustep*rhof*blccc/beta2
      factor = 1/(1 + 0.9784671*e)
      epsilon= eloss/e0
      epsilon= epsilon/(1-0.5*epsilon)
      temp = 0.25*(1 - factor*(1 - 0.333333*factor))*epsilon**2
      lambda = lambda*(1 + temp)
      IF (( spin_effects )) THEN
        elke = Log(e)
        Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
        IF (( lelke .LT. 1 )) THEN
          lelke = 1
          elke = (1 - eke0(medium))/eke1(medium)
        END IF
        IF (( qel .EQ. 0 )) THEN
          etap=etae_ms1(Lelke,MEDIUM)*elke+etae_ms0(Lelke,MEDIUM)
          xi_corr=q1ce_ms1(Lelke,MEDIUM)*elke+q1ce_ms0(Lelke,MEDIUM)
        ELSE
          etap=etap_ms1(Lelke,MEDIUM)*elke+etap_ms0(Lelke,MEDIUM)
          xi_corr=q1cp_ms1(Lelke,MEDIUM)*elke+q1cp_ms0(Lelke,MEDIUM)
        END IF
        ms_corr=blcce1(Lelke,MEDIUM)*elke+blcce0(Lelke,MEDIUM)
      ELSE
        etap = 1
        xi_corr = 1
        ms_corr = 1
      END IF
      chia2 = xcccc*p2i/(4*blccc)*etap
      lambda = lambda/etap/(1+chia2)*ms_corr
      chilog = Log(1 + 1/chia2)
      q1 = 2*chia2*(chilog*(1 + chia2) - 1)
      xi = q1*lambda
      find_index = .true.
      spin_index = .true.
      call mscat(lambda,chia2,xi,elke,beta2,qel,medium, spin_effects,fin
     *d_index,spin_index, ws,sint)
13391 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        xphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF((rng_seed .GT. 128))call ranmar_get
        yphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO13392
      GO TO 13391
13392 CONTINUE
      rhophi2 = 1/rhophi2
      cphi = (xphi2 - yphi2)*rhophi2
      sphi = 2*xphi*yphi*rhophi2
      us = sint*cphi
      vs = sint*sphi
      xi = xi*xi_corr
      IF (( xi .LT. 0.1 )) THEN
        z = 1 - xi*(0.5 - xi*(0.166666667 - 0.041666667*xi))
      ELSE
        z = (1 - Exp(-xi))/xi
      END IF
      r = 0.5*sint
      r2 = r*r
      z2 = z*z
      r2max = 1 - z2
      IF (( r2max .LT. r2 )) THEN
        r2 = r2max
        r = Sqrt(r2)
      END IF
      ut = r*cphi
      vt = r*sphi
      wt = z
      ustep = Sqrt(z2 + r2)*tustep
      sint02 = u0**2 + v0**2
      IF ((sint02 .GT. 1e-20)) THEN
        sint0 = sqrt(sint02)
        sint0i = 1/sint0
        cphi0 = sint0i*u0
        sphi0 = sint0i*v0
        u2p = w0*us + sint0*ws
        ws = w0*ws - sint0*us
        us = u2p*cphi0 - vs*sphi0
        vs = u2p*sphi0 + vs*cphi0
        u2p = w0*ut + sint0*wt
        wt = w0*wt - sint0*ut
        ut = u2p*cphi0 - vt*sphi0
        vt = u2p*sphi0 + vt*cphi0
      ELSE
        wt = w0*wt
        ws = w0*ws
      END IF
      xf = x0 + tustep*ut
      yf = y0 + tustep*vt
      zf = z0 + tustep*wt
      return
      end
      SUBROUTINE PAIR
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      common/nrc_pair/ nrcp_fdata(65,84,10), nrcp_wdata(65,84,10), nrcp_
     *idata(65,84,10), nrcp_xdata(65), nrcp_emin, nrcp_emax, nrcp_dle, n
     *rcp_dlei
      real*8 nrcp_fdata,nrcp_wdata,nrcp_xdata, nrcp_emin, nrcp_emax, nrc
     *p_dle, nrcp_dlei
      integer*4 nrcp_idata
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/triplet_data/ a_triplet(250,10), b_triplet(250,10), dl_trip
     *let, dli_triplet, bli_triplet, log_4rm
      real*8 a_triplet,b_triplet,dl_triplet, dli_triplet, bli_triplet, l
     *og_4rm
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DOUBLE PRECISION PEIG,  PESE1,  PESE2
      real*8 EIG,  ESE2,  RNNO30,RNNO31,rnno32,rnno33,rnno34,  DELTA,  R
     *EJF,  rejmax,  aux1,aux2,  Amax,  Bmax,  del0,  br,
     *                               Eminus,Eplus,Eavail,rnno_RR
      integer*4
     *                     L,L1
      real*8 ESE,  PSE,  ZTARG,  TTEIG,  TTESE,  TTPSE,  ESEDEI, ESEDER,
     * XIMIN,  XIMID,  REJMIN, REJMID, REJTOP, YA,XITRY,GALPHA,GBETA,  X
     *ITST,  REJTST_on_REJTOP ,  REJTST, RTEST
      integer*4 ICHRG
      real*8 k,xx,abin,rbin,alias_sample1
      integer*4 ibin, iq1, iq2, iprdst_use
      logical do_nrc_pair
      integer*4 itrip
      real*8 ftrip
      NPold = NP
      IF (( i_play_RR .EQ. 1 )) THEN
        i_survived_RR = 0
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,'(a,g14.6)') 'Attempt to play Russian Roulette w
     *ith prob_RR<0! '
          END IF
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          rnno_RR = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF (( rnno_RR .GT. prob_RR )) THEN
            i_survived_RR =2
            IF (( np .GT. 1 )) THEN
              np = np-1
            ELSE
              wt(np) = 0
              e(np) = 0
            END IF
            return
          ELSE
            wt(np) = wt(np)/prob_RR
          END IF
        END IF
      END IF
      IF (( np+1 .GT. 500 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','PAIR', ' sta
     *ck size exceeded! ',' $MAXSTACK = ',500,' np = ',np+1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      PEIG=E(NP)
      EIG=PEIG
      do_nrc_pair = .false.
      IF (( itriplet .GT. 0 .AND. eig .GT. 4*rm )) THEN
        itrip = dli_triplet*gle + bli_triplet
        ftrip = a_triplet(itrip,medium)*gle + b_triplet(itrip,medium)
        IF((rng_seed .GT. 128))call ranmar_get
        rnno34 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( rnno34 .LT. ftrip )) THEN
          call sample_triplet
          return
        END IF
      END IF
      IF (( pair_nrc .EQ. 1 )) THEN
        k = eig/rm
        IF (( k .LT. nrcp_emax )) THEN
          do_nrc_pair = .true.
          IF (( k .LE. nrcp_emin )) THEN
            ibin = 1
          ELSE
            abin = 1 + log((k-2)/(nrcp_emin-2))*nrcp_dlei
            ibin = abin
            abin = abin - ibin
            IF((rng_seed .GT. 128))call ranmar_get
            rbin = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rbin .LT. abin))ibin = ibin + 1
          END IF
          xx = alias_sample1(64,nrcp_xdata, nrcp_fdata(1,ibin,medium),nr
     *    cp_wdata(1,ibin,medium), nrcp_idata(1,ibin,medium))
          IF (( xx .GT. 0.5 )) THEN
            pese1 = prm*(1 + xx*(k-2))
            iq1 = 1
            pese2 = peig - pese1
            iq2 = -1
          ELSE
            pese2 = prm*(1 + xx*(k-2))
            iq2 = 1
            pese1 = peig - pese2
            iq1 = -1
          END IF
        END IF
      END IF
      IF (( .NOT.do_nrc_pair )) THEN
        IF ((EIG.LE.2.1)) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO30 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          rnno34 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          PESE2 = PRM + 0.5*RNNO30*(PEIG-2*PRM)
          PESE1 = PEIG - PESE2
          IF (( rnno34 .LT. 0.5 )) THEN
            iq1 = -1
            iq2 = 1
          ELSE
            iq1 = 1
            iq2 = -1
          END IF
        ELSE
          IF ((EIG.LT.50.)) THEN
            L = 5
            L1 = L + 1
            delta = 4*delcm(medium)/eig
            IF (( delta .LT. 1 )) THEN
              Amax = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medi
     *        um))
              Bmax = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,m
     *        edium))
            ELSE
              aux2 = log(delta+dl6(l,medium))
              Amax = dl4(l,medium)+dl5(l,medium)*aux2
              Bmax = dl4(l1,medium)+dl5(l1,medium)*aux2
            END IF
            aux1 = 1 - rmt2/eig
            aux1 = aux1*aux1
            aux1 = aux1*Amax/3
            aux1 = aux1/(Bmax+aux1)
          ELSE
            L = 7
            Amax = dl1(l,medium)
            Bmax = dl1(l+1,medium)
            aux1 = bpar(2,medium)*(1-bpar(1,medium)*rm/eig)
          END IF
          del0 = eig*delcm(medium)
          Eavail = eig - rmt2
13401     CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            RNNO30 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rng_seed .GT. 128))call ranmar_get
            RNNO31 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rng_seed .GT. 128))call ranmar_get
            RNNO34 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF (( rnno30 .GT. aux1 )) THEN
              br = 0.5*rnno31
              rejmax = Bmax
              l1 = l+1
            ELSE
              IF((rng_seed .GT. 128))call ranmar_get
              rnno32 = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF((rng_seed .GT. 128))call ranmar_get
              rnno33 = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              br = 0.5*(1-max(rnno31,rnno32,rnno33))
              rejmax = Amax
              l1 = l
            END IF
            Eminus = br*Eavail + rm
            Eplus = eig - Eminus
            delta = del0/(Eminus*Eplus)
            IF (( delta .LT. 1 )) THEN
              rejf = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,m
     *        edium))
            ELSE
              rejf = dl4(l1,medium)+dl5(l1,medium)*log(delta+dl6(l1,medi
     *        um))
            END IF
            IF((( rnno34*rejmax .LE. rejf )))GO TO13402
          GO TO 13401
13402     CONTINUE
          pese2 = Eminus
          pese1 = peig - pese2
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO34 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF (( rnno34 .LT. 0.5 )) THEN
            iq1 = -1
            iq2 = 1
          ELSE
            iq1 = 1
            iq2 = -1
          END IF
        END IF
      END IF
      ESE2=PESE2
      E(NP)=PESE1
      E(NP+1)=PESE2
      IF (( iprdst .GT. 0 )) THEN
        IF (( iprdst .EQ. 4 )) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          rtest = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          gbeta = PESE1/(PESE1+10)
          IF (( rtest .LT. gbeta )) THEN
            iprdst_use = 1
          ELSE
            iprdst_use = 4
          END IF
        ELSE IF(( iprdst .EQ. 2 .AND. eig .LT. 4.14 )) THEN
          iprdst_use = 1
        ELSE
          iprdst_use = iprdst
        END IF
        DO 13411 ichrg=1,2
          IF ((ICHRG.EQ.1)) THEN
            ESE=PESE1
          ELSE
            ESE=ESE2
            IF (( iprdst .EQ. 4 )) THEN
              gbeta = ESE/(ESE+10)
              IF((rng_seed .GT. 128))call ranmar_get
              rtest = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rtest .LT. gbeta )) THEN
                iprdst_use = 1
              ELSE
                iprdst_use = 4
              END IF
            END IF
          END IF
          IF (( iprdst_use .EQ. 1 )) THEN
            PSE=SQRT(MAX(0.0,(ESE-RM)*(ESE+RM)))
            IF((rng_seed .GT. 128))call ranmar_get
            COSTHE = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            COSTHE=1.0-2.0*COSTHE
            SINTHE=RM*SQRT((1.0-COSTHE)*(1.0+COSTHE))/(PSE*COSTHE+ESE)
            COSTHE=(ESE*COSTHE+PSE)/(PSE*COSTHE+ESE)
          ELSE IF(( iprdst_use .EQ. 2 )) THEN
            ZTARG=ZBRANG(MEDIUM)
            TTEIG=EIG/RM
            TTESE=ESE/RM
            TTPSE=SQRT((TTESE-1.0)*(TTESE+1.0))
            ESEDEI=TTESE/(TTEIG-TTESE)
            ESEDER=1.0/ESEDEI
            XIMIN=1.0/(1.0+(3.141593*TTESE)**2)
            REJMIN = 2.0+3.0*(ESEDEI+ESEDER) - 4.00*(ESEDEI+ESEDER+1.0-4
     *      .0*(XIMIN-0.5)**2)*( 1.0+0.25*LOG( ((1.0+ESEDER)*(1.0+ESEDEI
     *      )/(2.*TTEIG))**2+ZTARG*XIMIN**2 ) )
            YA=(2.0/TTEIG)**2
            XITRY=MAX(0.01,MAX(XIMIN,MIN(0.5,SQRT(YA/ZTARG))))
            GALPHA=1.0+0.25*LOG(YA+ZTARG*XITRY**2)
            GBETA=0.5*ZTARG*XITRY/(YA+ZTARG*XITRY**2)
            GALPHA=GALPHA-GBETA*(XITRY-0.5)
            XIMID=GALPHA/(3.0*GBETA)
            IF ((GALPHA.GE.0.0)) THEN
              XIMID=0.5-XIMID+SQRT(XIMID**2+0.25)
            ELSE
              XIMID=0.5-XIMID-SQRT(XIMID**2+0.25)
            END IF
            XIMID=MAX(0.01,MAX(XIMIN,MIN(0.5,XIMID)))
            REJMID = 2.0+3.0*(ESEDEI+ESEDER) - 4.00*(ESEDEI+ESEDER+1.0-4
     *      .0*(XIMID-0.5)**2)*( 1.0+0.25*LOG( ((1.0+ESEDER)*(1.0+ESEDEI
     *      )/(2.*TTEIG))**2+ZTARG*XIMID**2 ) )
            REJTOP=1.02*MAX(REJMIN,REJMID)
13421       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              XITST = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              REJTST = 2.0+3.0*(ESEDEI+ESEDER) - 4.00*(ESEDEI+ESEDER+1.0
     *        -4.0*(XITST-0.5)**2)*( 1.0+0.25*LOG( ((1.0+ESEDER)*(1.0+ES
     *        EDEI)/(2.*TTEIG))**2+ZTARG*XITST**2 ) )
              IF((rng_seed .GT. 128))call ranmar_get
              RTEST = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              THETA=SQRT(1.0/XITST-1.0)/TTESE
              REJTST_on_REJTOP = REJTST/REJTOP
              IF((((RTEST .LE. REJTST_on_REJTOP) .AND. (THETA .LT. PI) )
     *        ))GO TO13422
            GO TO 13421
13422       CONTINUE
            SINTHE=SIN(THETA)
            COSTHE=COS(THETA)
          ELSE IF(( iprdst_use .EQ. 3 )) THEN
            IF((rng_seed .GT. 128))call ranmar_get
            COSTHE = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            COSTHE=1.0-2.0*COSTHE
            sinthe=(1-costhe)*(1+costhe)
            IF (( sinthe .GT. 0 )) THEN
              sinthe = sqrt(sinthe)
            ELSE
              sinthe = 0
            END IF
          ELSE
            IF((rng_seed .GT. 128))call ranmar_get
            costhe = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            costhe=1-2*sqrt(costhe)
            sinthe=(1-costhe)*(1+costhe)
            IF (( sinthe .GT. 0 )) THEN
              sinthe=sqrt(sinthe)
            ELSE
              sinthe=0
            END IF
          END IF
          IF (( ichrg .EQ. 1 )) THEN
            CALL UPHI(2,1)
          ELSE
            sinthe=-sinthe
            NP=NP+1
            CALL UPHI(3,2)
          END IF
13411   CONTINUE
13412   CONTINUE
        iq(np) = iq2
        iq(np-1) = iq1
        return
      ELSE
        THETA=0
      END IF
      CALL UPHI(1,1)
      NP=NP+1
      SINTHE=-SINTHE
      CALL UPHI(3,2)
      IQ(NP)=iq2
      IQ(NP-1)=iq1
      RETURN
      END
      subroutine sample_triplet
      implicit none
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/USERRR/ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN, MINZ,MAXZ,MINR,MAXR
     *,IREJCT
      real*8 ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN
      integer*4 MINZ,MAXZ,MINR,MAXR,IREJCT
      COMMON/USERMI/EXPMFP,GWTOLD,ICSDA
      integer*4 ICSDA
      real*8 EXPMFP,GWTOLD
      COMMON/USERVR/ CEXPTR,GWAIT,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,
     *IQINC,MONOEN, cs_enhance,cs_enhance_current,ienhance,iefl( 12001),
     *ics_enhance, do_fast_step
      integer*4 ienhance,iefl,ics_enhance, IFORCE,NFMIN,NFMAX,NFTIME,ISO
     *URC,IFPB,IQINC,MONOEN
      real*8 CEXPTR,GWAIT,cs_enhance,cs_enhance_current
      logical do_fast_step
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 fmax_array(250), eta_p_array(250), eta_Ep_array(250), eta_c
     *ostp_array(250), eta_costm_array(250), ebin_array(250), wp_array(2
     *50), qmin_array(250)
      real*8 kmin, kmax, dlogki, alogkm, prmi, tiny_eta
      real*8 ai,rnno,k,qmin,qmax,aux,a1,a2,a3,D,px1,px2,pp_min,pp_max, E
     *p_min,Ep_max,k2p2,k2p2x,peig,b,aux1,aux12,D1,aux3,xmin,xmax, aux6,
     *aux7,uu,cphi,sphi,cphi_factor,aux5,phi,tmp
      real*8 Er,pr,pr2,eta_pr
      real*8 Ep,pp,pp2,wEp,cost_p,sint_p,eta_Ep,mup_min,wmup, eta_costp,
     *Epp,pp_sintp,pp_sntp2
      real*8 Em,pm,pm2,cost_m,sint_m,Emm,wmum,pm_sintm, eta_costm
      real*8 k2,k3,s2,s3,k2k3i,k22,k32,q2,aux4,S_1,S_2,sigma
      real*8 ppx, ppy, ppz, pmx, pmy, pmz, prx, pry, prz, a,c,sindel,cos
     *del,sinpsi
      integer*4 i
      logical use_it
      integer*4 iscore
      logical is_initialized
      data is_initialized/.false./
      save is_initialized,fmax_array,eta_p_array,eta_Ep_array,eta_costp_
     *array, eta_costm_array,ebin_array,wp_array,qmin_array, kmin,kmax,d
     *logki,alogkm,prmi,tiny_eta
      IF (( .NOT.is_initialized )) THEN
        is_initialized = .true.
        tiny_eta = 1e-6
        DO 13431 i=1,250
          fmax_array(i) = -1
13431   CONTINUE
13432   CONTINUE
        kmax = 0
        kmin = 4.1*prm
        DO 13441 i=1,nmed
          IF((up(i) .GT. kmax))kmax = UP(i)
13441   CONTINUE
13442   CONTINUE
        IF((kmax .LE. kmin))return
        dlogki = 250 - 1
        dlogki = dlogki/log(kmax/kmin)
        alogkm = 1 - dlogki*log(kmin)
        prmi = 1/prm
        DO 13451 i=1,250
          k = 4.1*exp((i-1.)/dlogki)
          ebin_array(i) = k
          qmin = 4*k/(k*(k-1)+(k+1)*sqrt(k*(k-4)))
          qmax = (k*(k-1) + (k+1)*sqrt(k*(k-4)))/(2*k+1)
          qmin_array(i) = qmin
          wp_array(i) = log(qmax/qmin)
13451   CONTINUE
13452   CONTINUE
      END IF
      peig = e(np)
      IF((peig .LE. 4*prm))return
      IF (( np+2 .GT. 500 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','sample_tripl
     *et', ' stack size exceeded! ',' $MAXSTACK = ',500,' np = ',np+2
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( peig .LE. kmin )) THEN
        i = 1
      ELSE IF(( peig .GE. kmax )) THEN
        i = 250
      ELSE
        ai = alogkm + dlogki*gle
        i = ai
        ai = ai - i
        IF((rng_seed .GT. 128))call ranmar_get
        rnno = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( rnno .LT. ai )) THEN
          i = i+1
        END IF
      END IF
      k = ebin_array(i)
13460 CONTINUE
      IF((rng_seed .GT. 128))call ranmar_get
      eta_pr = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((eta_pr .LT. tiny_eta))eta_pr = tiny_eta
      pr = qmin_array(i)*exp(eta_pr*wp_array(i))
      pr2 = pr*pr
      Er = sqrt(1+pr2)
      aux = Er-pr-1
      a1=(k-pr)*(1-Er-k*aux)
      a2=1+k-Er
      a3=1/(aux*(pr+Er-2*k-1))
      D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2))
      px1 = (a1 + D)*a3
      px2 = (a1 - D)*a3
      IF (( px1 .LT. px2 )) THEN
        pp_min = px1
        pp_max = px2
      ELSE
        pp_min = px2
        pp_max = px1
      END IF
      Ep_min = sqrt(1 + pp_min*pp_min)
      Ep_max = sqrt(1 + pp_max*pp_max)
      IF((rng_seed .GT. 128))call ranmar_get
      eta_Ep = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((eta_Ep .LT. tiny_eta))eta_Ep = tiny_eta
      wEp = Ep_max - Ep_min
      Ep = Ep_min + eta_Ep*wEp
      pp2 = Ep*Ep - 1
      pp = sqrt(pp2)
      k2p2 = k*k + pp2
      Em = k + 1 - Er - Ep
      pm2 = Em*Em-1
      pm = sqrt(pm2)
      mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp)
      IF((rng_seed .GT. 128))call ranmar_get
      eta_costp = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((eta_costp .LT. tiny_eta))eta_costp = tiny_eta
      Epp = Ep/pp
      wmup = log((Epp-1)/(Epp-mup_min))
      cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp)
      wmup = wmup*(cost_p - Epp)
      sint_p = 1-cost_p*cost_p
      IF (( sint_p .GT. 1e-20 )) THEN
        sint_p = sqrt(sint_p)
      ELSE
        sint_p = 1e-10
      END IF
      k2p2x = k2p2 - 2*k*pp*cost_p
      b = pr2-k2p2x-pm2
      aux1 = k - pp*cost_p
      aux12 = aux1*aux1
      pp_sintp = pp*sint_p
      pp_sntp2 = pp_sintp*pp_sintp
      D1 = pm2*(aux12+pp_sntp2)-b*b/4
      IF (( D1 .LE. 0 )) THEN
        goto 13460
      END IF
      D = 2*pp_sintp*sqrt(D1)
      aux3 = 0.5/(aux12+pp_sntp2)
      xmin = (-b*aux1-D)*aux3
      xmax = (-b*aux1+D)*aux3
      IF((rng_seed .GT. 128))call ranmar_get
      eta_costm = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((eta_costm .LT. tiny_eta))eta_costm = tiny_eta
      aux6 = sqrt((Em-xmin)/(Em-xmax))
      aux7 = aux6*tan(1.570796326794897*eta_costm)
      uu = (aux7-1)/(aux7+1)
      cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))
      wmum = sqrt((xmax-cost_m)*(cost_m-xmin))
      wmum = wmum*aux6*(Em-cost_m)/(Em-xmin)
      cost_m = cost_m/pm
      sint_m = sqrt(1-cost_m*cost_m)
      pm_sintm = pm*sint_m
      cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm)
      IF (( abs(cphi) .GE. 1 )) THEN
        goto 13460
      END IF
      sphi = sqrt(1-cphi*cphi)
      k3 = k*(pp*cost_p - Ep)
      k2 = k*(pm*cost_m - Em)
      k22 = k2*k2
      k32 = k3*k3
      k2k3i = 1/(k2*k3)
      s2 = pp*pm*(cost_p*cost_m + sint_p*sint_m*cphi) - Ep*Em
      s3 = k2 - Em + 1 - s2
      q2 = 2*(Er-1)
      S_1 = k32+k22+(q2-2)*s2-(1-q2/2)*(k32+k22)*k2k3i
      aux4 = k3*Ep-k2*Em
      S_2 = -q2*(Ep*Ep+Em*Em) + 2*s2 - (2*aux4*aux4 - k22 - k32)*k2k3i
      sigma = abs(pp*pm2*pm*k2k3i/(q2*q2*(Em*s3+Er))*(S_1*(1-q2/4)+S_2*(
     *1+q2/4)))
      cphi_factor = abs(2*Er*pm2-Em*(k2p2x-pr2-pm2))/(2*pp_sintp*pm_sint
     *m*pm2*sphi)
      sigma = sigma*cphi_factor*wEp*wmup*wmum*wp_array(i)*pr2/Er
      IF (( sigma .LT. 0 )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) 'In triplet sigma < 0 ? ',sigma
      END IF
      use_it = .true.
      IF (( sigma .LT. fmax_array(i) )) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        rnno = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( sigma .LT. fmax_array(i)*rnno )) THEN
          use_it = .false.
        END IF
      END IF
      IF (( use_it )) THEN
        fmax_array(i) = sigma
        eta_p_array(i) = eta_pr
        eta_Ep_array(i) = eta_Ep
        eta_costp_array(i) = eta_costp
        eta_costm_array(i) = eta_costm
      ELSE
        eta_pr = eta_p_array(i)
        eta_Ep = eta_Ep_array(i)
        eta_costp = eta_costp_array(i)
        eta_costm = eta_costm_array(i)
      END IF
      k = peig*prmi
      aux5 = k*(k-1)+(k+1)*sqrt(k*(k-4))
      qmin = 4*k/aux5
      qmax = aux5/(2*k+1)
      pr = qmin*exp(eta_pr*log(qmax/qmin))
      pr2 = pr*pr
      Er = sqrt(1+pr2)
      aux = Er-pr-1
      a1=(k-pr)*(1-Er-k*aux)
      a2=1+k-Er
      a3=1/(aux*(pr+Er-2*k-1))
      D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2))
      px1 = (a1 + D)*a3
      px2 = (a1 - D)*a3
      IF (( px1 .LT. px2 )) THEN
        pp_min = px1
        pp_max = px2
      ELSE
        pp_min = px2
        pp_max = px1
      END IF
      Ep_min = sqrt(1 + pp_min*pp_min)
      Ep_max = sqrt(1 + pp_max*pp_max)
      wEp = Ep_max - Ep_min
      Ep = Ep_min + eta_Ep*wEp
      pp2 = Ep*Ep - 1
      pp = sqrt(pp2)
      k2p2 = k*k + pp2
      Em = k + 1 - Er - Ep
      pm2 = Em*Em-1
      pm = sqrt(pm2)
      mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp)
      Epp = Ep/pp
      wmup = log((Epp-1)/(Epp-mup_min))
      cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp)
      sint_p = sqrt(1-cost_p*cost_p)
      k2p2x = k2p2 - 2*k*pp*cost_p
      b = pr2-k2p2x-pm2
      aux1 = k - pp*cost_p
      aux12 = aux1*aux1
      pp_sintp = pp*sint_p
      pp_sntp2 = pp_sintp*pp_sintp
      D1 = pm2*(aux12+pp_sntp2)-b*b/4
      IF (( D1 .LE. 0 )) THEN
        goto 13460
      END IF
      D = 2*pp_sintp*sqrt(D1)
      aux3 = 0.5/(aux12+pp_sntp2)
      xmin = (-b*aux1-D)*aux3
      xmax = (-b*aux1+D)*aux3
      aux6 = sqrt((Em-xmin)/(Em-xmax))
      aux7 = aux6*tan(1.570796326794897*eta_costm)
      uu = (aux7-1)/(aux7+1)
      cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))/pm
      sint_m = sqrt(1-cost_m*cost_m)
      pm_sintm = pm*sint_m
      cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm)
      IF (( abs(cphi) .GE. 1 )) THEN
        goto 13460
      END IF
      sphi = sqrt(1-cphi*cphi)
      IF((rng_seed .GT. 128))call ranmar_get
      phi = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      phi = phi*6.283185307179586
      ppx = pp*sint_p
      ppy = 0
      pmx = pm*sint_m*cphi
      pmy = pm*sint_m*sphi
      cphi = cos(phi)
      sphi = sin(phi)
      tmp = ppx*sphi
      ppx = ppx*cphi - ppy*sphi
      ppy = tmp + ppy*cphi
      tmp = pmx*sphi
      pmx = pmx*cphi - pmy*sphi
      pmy = tmp + pmy*cphi
      ppz = pp*cost_p
      pmz = pm*cost_m
      prx = -ppx-pmx
      pry = -ppy-pmy
      prz = k - ppz - pmz
      NPold = np
      X(np)=X(np)
      Y(np)=Y(np)
      Z(np)=Z(np)
      IR(np)=IR(np)
      WT(np)=WT(np)
      DNEAR(np)=DNEAR(np)
      LATCH(np)=LATCH(np)
      X(np+1)=X(np)
      Y(np+1)=Y(np)
      Z(np+1)=Z(np)
      IR(np+1)=IR(np)
      WT(np+1)=WT(np)
      DNEAR(np+1)=DNEAR(np)
      LATCH(np+1)=LATCH(np)
      X(np+2)=X(np+1)
      Y(np+2)=Y(np+1)
      Z(np+2)=Z(np+1)
      IR(np+2)=IR(np+1)
      WT(np+2)=WT(np+1)
      DNEAR(np+2)=DNEAR(np+1)
      LATCH(np+2)=LATCH(np+1)
      pp = 1/pp
      pm = 1/pm
      pr = 1/pr
      a = u(np)
      b = v(np)
      c = w(np)
      sinpsi = a*a + b*b
      IF (( sinpsi .GT. 1e-20 )) THEN
        sinpsi = sqrt(sinpsi)
        sindel = b/sinpsi
        cosdel = a/sinpsi
        IF (( Ep .GT. Em )) THEN
          u(np) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz)
          v(np) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz)
          w(np) = pp*(c*ppz - sinpsi*ppx)
          iq(np) = 1
          E(np) = Ep*prm
          u(np+1) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz)
          v(np+1) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz)
          w(np+1) = pm*(c*pmz - sinpsi*pmx)
          iq(np+1) = -1
          E(np+1) = Em*prm
        ELSE
          u(np+1) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz)
          v(np+1) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz)
          w(np+1) = pp*(c*ppz - sinpsi*ppx)
          iq(np+1) = 1
          E(np+1) = Ep*prm
          u(np) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz)
          v(np) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz)
          w(np) = pm*(c*pmz - sinpsi*pmx)
          iq(np) = -1
          E(np) = Em*prm
        END IF
        np = np + 2
        u(np) = pr*(c*cosdel*prx - sindel*pry + a*prz)
        v(np) = pr*(c*sindel*prx + cosdel*pry + b*prz)
        w(np) = pr*(c*prz - sinpsi*prx)
        iq(np) = -1
        E(np) = Er*prm
      ELSE
        IF (( Ep .GT. Em )) THEN
          u(np) = pp*ppx
          v(np) = pp*ppy
          w(np) = c*pp*ppz
          iq(np) = 1
          E(np) = Ep*prm
          u(np+1) = pm*pmx
          v(np+1) = pm*pmy
          w(np+1) = c*pm*pmz
          iq(np+1) = -1
          E(np+1) = Em*prm
        ELSE
          u(np+1) = pp*ppx
          v(np+1) = pp*ppy
          w(np+1) = c*pp*ppz
          iq(np+1) = 1
          E(np+1) = Ep*prm
          u(np) = pm*pmx
          v(np) = pm*pmy
          w(np) = c*pm*pmz
          iq(np) = -1
          E(np) = Em*prm
        END IF
        np = np + 2
        u(np) = pr*prx
        v(np) = pr*pry
        w(np) = c*pr*prz
        iq(np) = -1
        E(np) = Er*prm
      END IF
      return
      end
      SUBROUTINE PHOTO
      implicit none
      COMMON/BOUNDS/ECUT( 12001),PCUT( 12001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(10), GE0(10),GE1(10), GMFP0(2000,10),GMFP1(2
     *000,10),GBR10(2000,10),GBR11(2000,10),GBR20(2000,10),GBR21(2000,10
     *), RCO0(10),RCO1(10), RSCT0(100,10),RSCT1(100,10), COHE0(2000,10),
     *COHE1(2000,10),  PHOTONUC0(2000,10),PHOTONUC1(2000,10), DPMFP, MPG
     *EM(1,10), NGR(10)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      real*8 EELEC,  BETA,  GAMMA,  ALPHA,  RATIO,  RNPHT,  FKAPPA, XI,
     * SINTH2, RNPHT2
      DOUBLE PRECISION PEIG
      real*8 BR,  sigma,  aux,aux1,  probs(50),  sigtot,  e_vac,  rnno_R
     *R
      integer*4 IARG,  iZ,   irl,  ints(50),  j,ip,  n_warning,  k
      logical do_relax
      save n_warning
      data n_warning/0/
      IF (( mcdf_pe_xsections )) THEN
        call egs_shellwise_photo()
        return
      END IF
      NPold = NP
      PEIG=E(NP)
      irl = ir(np)
      IF (( peig .LT. edge_energies(2,1) )) THEN
        IF (( n_warning .LT. 100 )) THEN
          n_warning = n_warning + 1
          write(i_log,*) ' Subroutine PHOTO called with E = ',peig, ' wh
     *ich is below the current min. energy of 1 keV! '
          write(i_log,*) ' Converting now this photon to an electron, '
          write(i_log,*) ' but you should check your code! '
        END IF
        iq(np) = -1
        e(np) = peig + prm
        return
      END IF
      iZ = iedgfl(irl)
      do_relax = .false.
      edep = pzero
      IF (( iedgfl(irl) .NE. 0 )) THEN
        IF (( nne(medium) .EQ. 1 )) THEN
          iZ = int( zelem(medium,1) + 0.5 )
          DO 13471 j=1,edge_number(iZ)
            IF((peig .GE. edge_energies(j,iZ)))GO TO13472
13471     CONTINUE
13472     CONTINUE
        ELSE
          aux = peig*peig
          aux1 = aux*peig
          aux = aux*Sqrt(peig)
          sigtot = 0
          DO 13481 k=1,nne(medium)
            iZ = int( zelem(medium,k) + 0.5 )
            IF (( iZ .LT. 1 .OR. iZ .GT. 100 )) THEN
              write(i_log,*) ' Error in PHOTO: '
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) '   Atomic number of element ',k, ' in medi
     *um ',medium,' is not between 1 and ',100
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            IF (( peig .GT. edge_energies(1,iZ) )) THEN
              j = 1
              sigma = (edge_a(1,iZ) + edge_b(1,iZ)/peig + edge_c(1,iZ)/a
     *        ux + edge_d(1,iZ)/aux1)/peig
            ELSE
              DO 13491 j=2,edge_number(iZ)
                IF((peig .GE. edge_energies(j,iZ)))GO TO13492
13491         CONTINUE
13492         CONTINUE
              sigma = edge_a(j,iZ) + gle*(edge_b(j,iZ) + gle*(edge_c(j,i
     *        Z) + gle*edge_d(j,iZ) ))
              sigma = Exp(sigma)
            END IF
            sigma = sigma * pz(medium,k)
            sigtot = sigtot + sigma
            probs(k) = sigma
            ints(k) = j
13481     CONTINUE
13482     CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          br = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          br = br*sigtot
          DO 13501 k=1,nne(medium)
            br = br - probs(k)
            IF((br .LE. 0))GO TO13502
13501     CONTINUE
13502     CONTINUE
          iZ = int( zelem(medium,k) + 0.5 )
          j = ints(k)
        END IF
        IF (( peig .LE. binding_energies(6,iZ) )) THEN
          iq(np) = -1
          e(np) = peig + prm
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          br = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          DO 13511 k=1,5
            IF (( peig .GT. binding_energies(k,iZ) )) THEN
              IF((br .LT. interaction_prob(k,iZ)))GO TO13512
              br = (br - interaction_prob(k,iZ))/(1-interaction_prob(k,i
     *        Z))
            END IF
13511     CONTINUE
13512     CONTINUE
          IF ((eadl_relax .AND. k .GT. 4)) THEN
            iq(np) = -1
            e(np) = peig + prm
          ELSE
            e_vac = binding_energies(k,iZ)
            e(np) = peig - e_vac + prm
            do_relax = .true.
            iq(np) = -1
          END IF
        END IF
      ELSE
        e(np) = peig + prm
        iq(np) = -1
      END IF
      IF (( iq(np) .EQ. -1 )) THEN
        IF ((IPHTER(IR(NP)).EQ.1)) THEN
          EELEC=E(NP)
          IF ((EELEC.GT.ECUT(IR(NP)))) THEN
            BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC
            GAMMA=EELEC/RM
            ALPHA=0.5*GAMMA-0.5+1./GAMMA
            RATIO=BETA/ALPHA
13521       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              RNPHT = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              RNPHT=2.*RNPHT-1.
              IF ((RATIO.LE.0.2)) THEN
                FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT)
                IF (( gamma .LT. 100 )) THEN
                  COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                ELSE
                  IF (( fkappa .GT. 0 )) THEN
                    costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gam
     *              ma-1)**3)
                  ELSE
                    COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                  END IF
                END IF
                xi = (1+beta*fkappa)*gamma*gamma
              ELSE
                XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO)
     *          )-1.))
                COSTHE=(1.-1./XI)/BETA
              END IF
              SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE))
              IF((rng_seed .GT. 128))call ranmar_get
              RNPHT2 = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF(RNPHT2.LE.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA)GO TO13522
            GO TO 13521
13522       CONTINUE
            SINTHE=SQRT(SINTH2)
            CALL UPHI(2,1)
          END IF
        END IF
      END IF
      IF (( do_relax )) THEN
        call relax(e_vac,k,iZ)
      END IF
      IF (( EDEP .GT. 0 )) THEN
        IARG=4
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,13530)prob_RR
13530       FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold
13541     CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF((rng_seed .GT. 128))call ranmar_get
              rnno_RR = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO13542
          GO TO 13541
13542     CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
      end
      subroutine egs_shellwise_photo
      implicit none
      COMMON/BOUNDS/ECUT( 12001),PCUT( 12001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(10), GE0(10),GE1(10), GMFP0(2000,10),GMFP1(2
     *000,10),GBR10(2000,10),GBR11(2000,10),GBR20(2000,10),GBR21(2000,10
     *), RCO0(10),RCO1(10), RSCT0(100,10),RSCT1(100,10), COHE0(2000,10),
     *COHE1(2000,10),  PHOTONUC0(2000,10),PHOTONUC1(2000,10), DPMFP, MPG
     *EM(1,10), NGR(10)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,10),   pe_energy(500,100),  pe_zsorted(100,10), pe_be(100,16)
     *,  pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      real*8 pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      real*8 EELEC,  BETA,  GAMMA,  ALPHA,  RATIO,  RNPHT,  FKAPPA, XI,
     * SINTH2, RNPHT2
      DOUBLE PRECISION PEIG
      real*8 BR,  sigma,  aux,aux1,  probs(50),  sigtot,  e_vac,  rnno_R
     *R
      integer*4 IARG,  iZ,   irl,  ints(50),  j,ip,  n_warning,  k
      logical do_relax
      save n_warning
      real*8 slope, logE, int_prob
      integer*4 zpos, ibsearch
      data n_warning/0/
      NPold = NP
      PEIG=E(NP)
      irl = ir(np)
      do_relax = .false.
      IF (( peig .LT. 0.001 )) THEN
        IF (( n_warning .LT. 100 )) THEN
          n_warning = n_warning + 1
          write(i_log,*) ' Subroutine egs_shellwise_photo called with E
     *= ', peig,' which is below the current min. energy of ', 0.001,' k
     *eV! '
          write(i_log,*) ' Converting now this photon to an electron, '
          write(i_log,*) ' but you should check your code! '
        END IF
        iq(np) = -1
        e(np) = peig + prm
        return
      END IF
      edep = pzero
      IF (( iedgfl(irl) .NE. 0 )) THEN
        j = -1
        IF (( nne(medium) .EQ. 1 )) THEN
          iZ = int( zelem(medium,1) + 0.5 )
          zpos = pe_zpos(iZ)
          IF (( pe_nshell(zpos) .GT. 0)) THEN
            logE = log(peig)
            j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos))
          END IF
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          br = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          logE = log(peig)
          DO 13551 k=nne(medium),1,-1
            iZ = int( zelem(medium,k) + 0.5 )
            zpos = pe_zpos(iZ)
            IF (( iZ .LT. 1 .OR. iZ .GT. 100 )) THEN
              write(i_log,*) ' Error in egs_shellwise_photo: '
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) '   Atomic number of element ',k, ' in medi
     *um ',medium,' is not between 1 and ',100
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos))
            slope = pe_elem_prob(j+1,k,medium) - pe_elem_prob(j,k,medium
     *      )
            slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos))
            int_prob = pe_elem_prob(j,k,medium)+slope*(logE-pe_energy(j,
     *      zpos))
            br = br - exp(int_prob)
            IF((br .LE. 0))GO TO13552
13551     CONTINUE
13552     CONTINUE
        END IF
        IF (( peig .LT. pe_be(zpos,pe_nshell(zpos)) .OR. pe_nshell(zpos)
     *   .EQ. 0 )) THEN
          iq(np) = -1
          e(np) = peig + prm
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          br = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          sigtot = 0
          DO 13561 k=1,pe_nshell(zpos)
            IF (( peig .GT. pe_be(zpos,k) )) THEN
              slope = pe_xsection(j+1,zpos,k) - pe_xsection(j,zpos,k)
              slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos))
              int_prob=pe_xsection(j,zpos,k)+slope*(logE-pe_energy(j,zpo
     *        s))
              br = br - exp(int_prob)
              sigtot = sigtot + exp(int_prob)
              IF((br .LE. 0))GO TO13562
            END IF
13561     CONTINUE
13562     CONTINUE
          IF ((k .GT. pe_nshell(zpos))) THEN
            iq(np) = -1
            e(np) = peig + prm
          ELSE
            e_vac = pe_be(zpos,k)
            e(np) = peig - e_vac + prm
            do_relax = .true.
            iq(np) = -1
          END IF
        END IF
      ELSE
        e(np) = peig + prm
        iq(np) = -1
      END IF
      IF (( iq(np) .EQ. -1 )) THEN
        IF ((IPHTER(IR(NP)).EQ.1)) THEN
          EELEC=E(NP)
          IF ((EELEC.GT.ECUT(IR(NP)))) THEN
            BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC
            GAMMA=EELEC/RM
            ALPHA=0.5*GAMMA-0.5+1./GAMMA
            RATIO=BETA/ALPHA
13571       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              RNPHT = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              RNPHT=2.*RNPHT-1.
              IF ((RATIO.LE.0.2)) THEN
                FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT)
                IF (( gamma .LT. 100 )) THEN
                  COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                ELSE
                  IF (( fkappa .GT. 0 )) THEN
                    costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gam
     *              ma-1)**3)
                  ELSE
                    COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                  END IF
                END IF
                xi = (1+beta*fkappa)*gamma*gamma
              ELSE
                XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO)
     *          )-1.))
                COSTHE=(1.-1./XI)/BETA
              END IF
              SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE))
              IF((rng_seed .GT. 128))call ranmar_get
              RNPHT2 = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF(RNPHT2.LE.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA)GO TO13572
            GO TO 13571
13572       CONTINUE
            SINTHE=SQRT(SINTH2)
            CALL UPHI(2,1)
          END IF
        END IF
      END IF
      IF (( do_relax )) THEN
        call egs_eadl_relax(iZ,k)
      END IF
      IF (( EDEP .GT. 0 )) THEN
        IARG=4
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,13580)prob_RR
13580       FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold
13591     CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF((rng_seed .GT. 128))call ranmar_get
              rnno_RR = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO13592
          GO TO 13591
13592     CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
      end
      subroutine egs_read_shellwise_pe
      implicit none
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(10), GE0(10),GE1(10), GMFP0(2000,10),GMFP1(2
     *000,10),GBR10(2000,10),GBR11(2000,10),GBR20(2000,10),GBR21(2000,10
     *), RCO0(10),RCO1(10), RSCT0(100,10),RSCT1(100,10), COHE0(2000,10),
     *COHE1(2000,10),  PHOTONUC0(2000,10),PHOTONUC1(2000,10), DPMFP, MPG
     *EM(1,10), NGR(10)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,10),   pe_energy(500,100),  pe_zsorted(100,10), pe_be(100,16)
     *,  pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      real*8 pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      integer*4 lnblnk1,egs_get_unit,pe_sw_unit,ounit,egs_open_file
      integer*4 sorted(100),i,j,k,l,m
      real*8 z_sorted(100),pz_sorted(100)
      real*8 rest_xs(500,100)
      real*8 tmp_e(500,16), tmp_xs(500,16)
      real*8 new_e(500),deltaEb,slope
      integer*4 zread(100),ib(16),ibsearch
      character data_dir*128,pe_sw_file*144
      integer*4 medio,iZ,iZpos,egs_read_int,pos,curr_rec
      real*4 egs_read_real,e_r, e_old,sigma_r
      integer*2 nz, egs_read_short,ish, i_nshell,i_nge
      logical is_open, is_there, shift_required
      character*3 labels(16)
      data labels/'  K',' L1',' L2',' L3', ' M1',' M2',' M3',' M4',' M5'
     *, ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/
      write(i_log,'(/a$)') ' Reading renormalized photoelectric cross se
     *ctions ......'
      data_dir = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      pe_sw_file = data_dir(:lnblnk1(data_dir)) // 'photo_shellwise.data
     *'
      pe_sw_unit = egs_get_unit(0)
      IF (( pe_sw_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_shellwise_pe: failed to get a free Fort
     *ran I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(pe_sw_unit,file=pe_sw_file,status='old', form='UNFORMATTED',A
     *CCESS='direct',recl=1, err=13600)
      GOTO 13610
13600 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(2a)') 'egs_init_shellwise_pe: failed to open ', pe_s
     *w_file
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
13610 is_open = .true.
      DO 13621 medio=1,nmed
        DO 13631 i=1,nne(medio)
          pe_nshell(i*medio) = 0
          pe_nge(i*medio) = 0
          pe_zsorted(i,medio) = 0
13631   CONTINUE
13632   CONTINUE
13621 CONTINUE
13622 CONTINUE
      DO 13641 l=1,100
        pe_zpos(l) = -1
        DO 13651 k=1,500
          pe_energy(k,l) = 0.0
          DO 13661 m=1,16
            pe_xsection(k,l,m) = 0.0
13661     CONTINUE
13662     CONTINUE
13651   CONTINUE
13652   CONTINUE
        DO 13671 k=1,16
          pe_be(l,k) = -99
13671   CONTINUE
13672   CONTINUE
13641 CONTINUE
13642 CONTINUE
      curr_rec = 1
      iZpos = 0
      nz = egs_read_short(pe_sw_unit,curr_rec)
      DO 13681 medio=1,nmed
        DO 13691 i=1,nne(medio)
          z_sorted(i) = zelem(medio,i)
13691   CONTINUE
13692   CONTINUE
        call egs_heap_sort(nne(medio),z_sorted,sorted)
        DO 13701 i=1,nne(medio)
          pe_zsorted(i,medio) = z_sorted(i)
13701   CONTINUE
13702   CONTINUE
        DO 13711 i=1,nne(medio)
          iZ = z_sorted(i)
          is_there = .false.
          DO 13721 j=1,medio-1
            DO 13731 k=1,nne(j)
              IF (( iZ .EQ. pe_zsorted(k,j) )) THEN
                is_there = .true.
                GO TO13732
              END IF
13731       CONTINUE
13732       CONTINUE
13721     CONTINUE
13722     CONTINUE
          IF((is_there))GO TO13711
          iZpos = iZpos + 1
          zread(iZpos) = iZ
          pe_zpos(iZ) = iZpos
          pos = 3 + (iZ-1)*4
          curr_rec = egs_read_int(pe_sw_unit,pos) + 1
          i_nge = egs_read_short(pe_sw_unit,curr_rec)
          i_nshell = egs_read_short(pe_sw_unit,curr_rec)
          pe_nge(iZpos) = i_nge
          pe_nshell(iZpos) = i_nshell
          e_old = -1.0
          ish = 0
          DO 13741 j=1,i_nge
            e_r = egs_read_real(pe_sw_unit,curr_rec)
            sigma_r = egs_read_real(pe_sw_unit,curr_rec)
            pe_energy(j,iZpos) = e_r
            pe_xsection(j,iZpos,0) = sigma_r
            rest_xs(j,iZpos) = sigma_r
            DO 13751 k=1,i_nshell
              sigma_r = egs_read_real(pe_sw_unit,curr_rec)
              pe_xsection(j,iZpos,k) = sigma_r
              rest_xs(j,iZpos) = rest_xs(j,iZpos) - sigma_r
13751       CONTINUE
13752       CONTINUE
            IF ((e_r - e_old .LT. 1e-15)) THEN
              pe_be(iZpos,i_nshell-ish) = e_r
              ish = ish + 1
            END IF
            e_old = e_r
13741     CONTINUE
13742     CONTINUE
13711   CONTINUE
13712   CONTINUE
13681 CONTINUE
13682 CONTINUE
      pe_ne = iZpos
      DO 13761 i=1,pe_ne
        iZ = zread(i)
        IF ((pe_nshell(i) .EQ. 0)) THEN
          DO 13771 j=1,pe_nge(i)
            pe_energy(j,i) = log(pe_energy(j,i))
13771     CONTINUE
13772     CONTINUE
          GO TO13761
        END IF
        DO 13781 l=1,pe_nshell(i)
          IF (( pe_be(i,l) .NE. binding_energies(l,iZ))) THEN
            shift_required = .true.
            deltaEb = binding_energies(l,iZ)-pe_be(i,l)
          ELSE
            shift_required =.false.
          END IF
          is_there = .false.
          DO 13791 j=1,pe_nge(i)
            tmp_e(j,l) = pe_energy(j,i)
            tmp_xs(j,l) = pe_xsection(j,i,l)
            IF (( shift_required .AND. pe_energy(j,i) .GE. pe_be(i,l) ))
     *       THEN
              tmp_e(j,l) = tmp_e(j,l) + deltaEb
              IF ((pe_energy(j,i) .EQ. pe_be(i,l) .AND. .NOT.is_there))
     *        THEN
                ib(l) = j
                is_there = .true.
              END IF
              IF ((l .EQ. 1)) THEN
                new_e(j) = tmp_e(j,l)
              ELSE IF((j .LT. ib(l-1))) THEN
                new_e(j) = tmp_e(j,l)
              END IF
            END IF
13791     CONTINUE
13792     CONTINUE
          pe_be(i,l) = binding_energies(l,iZ)
13781   CONTINUE
13782   CONTINUE
        DO 13801 l=2,pe_nshell(i)
          DO 13811 j=1,pe_nge(i)
            IF (( new_e(j) .GE. pe_be(i,l-1) )) THEN
              m = ibsearch(new_e(j),pe_nge(i),tmp_e(1,l))
              slope = log(tmp_xs(m+1,l)/tmp_xs(m,l))
              slope = slope/log(tmp_e(m+1,l)/tmp_e(m,l))
              pe_xsection(j,i,l) = log(tmp_xs(m,l))
              pe_xsection(j,i,l) = pe_xsection(j,i,l) + slope*log(new_e(
     *        j)/tmp_e(m,l))
              pe_xsection(j,i,l) = exp(pe_xsection(j,i,l))
            END IF
13811     CONTINUE
13812     CONTINUE
13801   CONTINUE
13802   CONTINUE
        DO 13821 j=1,pe_nge(i)
          IF (( j .LT. ib(pe_nshell(i)))) THEN
            new_e(j) = pe_energy(j,i)
          END IF
          m = ibsearch(new_e(j),pe_nge(i),pe_energy(1,i))
          slope = log(rest_xs(m+1,i)/rest_xs(m,i))
          slope = slope/log(pe_energy(m+1,i)/pe_energy(m,i))
          pe_xsection(j,i,0) = log(rest_xs(m,i))
          pe_xsection(j,i,0) = pe_xsection(j,i,0) + slope*log(new_e(j)/p
     *    e_energy(m,i))
          pe_xsection(j,i,0) = exp(pe_xsection(j,i,0))
          DO 13831 l=1,pe_nshell(i)
            pe_xsection(j,i,0) = pe_xsection(j,i,0) + pe_xsection(j,i,l)
13831     CONTINUE
13832     CONTINUE
13821   CONTINUE
13822   CONTINUE
        DO 13841 j=1,pe_nge(i)
          pe_energy(j,i) = log(new_e(j))
          DO 13851 l=1,pe_nshell(i)
            pe_xsection(j,i,l) = log(pe_xsection(j,i,l)/pe_xsection(j,i,
     *      0))
13851     CONTINUE
13852     CONTINUE
13841   CONTINUE
13842   CONTINUE
13761 CONTINUE
13762 CONTINUE
      write(i_log,'(a/)') ' done'
      IF((is_open))close(pe_sw_unit)
      return
      end
      SUBROUTINE RELAX(energy,n,iZ)
      implicit none
      integer*4 n,iZ
      real*8 energy
      integer*4 vac_array(50),  n_vac,  shell
      integer*4 final,finala,  final1,final2,   iql,  irl
      integer*4 first_transition(5), last_transition(5)
      integer*4 final_state(39)
      integer*4 k, np_old, ip, iarg
      real*8 e_array(50),  Ei,Ef,  Ex,  eta,  e_check,  min_E,ekcut,pkcu
     *t,elcut
      real*8 xphi,yphi,xphi2,yphi2,rhophi2, cphi,sphi
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/BOUNDS/ECUT( 12001),PCUT( 12001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common/user_relax/ u_relax,ish_relax,iZ_relax
      real*8 u_relax
      integer*4 ish_relax, iZ_relax
      data first_transition/1,20,27,33,38/
      data last_transition/19,26,32,37,39/
      data final_state/  4,3,5,6,  202,302,402,404,403,303,  502,503,504
     *,602,603,604,  505,605,606,  13,14,  5,6,  505,605,606,  14,  5,6,
     *  505,605,606,  5,6,  505,605,606,  6,  606/
      save first_transition,last_transition,final_state
      IF ((eadl_relax)) THEN
        call egs_eadl_relax(iZ,n)
        return
      END IF
      IF (( n .LT. 1 .OR. n .GT. 6 )) THEN
        return
      END IF
      iz_relax = iZ
      irl = ir(np)
      ekcut = ecut(irl)-rm
      pkcut = pcut(irl)
      min_E = 0.001
      IF (( energy .LE. min_E )) THEN
        edep = edep + energy
        edep_local = energy
        IARG=34
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
        return
      END IF
      n_vac = 1
      vac_array(n_vac) = n
      np_old = np
      e_check = 0
      e_array(n_vac) = energy
13860 CONTINUE
13861   CONTINUE
        shell = vac_array(n_vac)
        Ei = e_array(n_vac)
        n_vac = n_vac - 1
        IF (( Ei .LE. min_E )) THEN
          edep = edep + Ei
          edep_local = Ei
          IARG=34
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          IF((n_vac .GT. 0))goto 13860
          GO TO13862
        END IF
        ish_relax = shell
        u_relax = Ei
        IF (( shell .EQ. 6 )) THEN
          IF (( Ei .GT. ekcut )) THEN
            np = np + 1
            IF (( np .GT. 500 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','RELAX'
     *        , ' stack size exceeded! ',' $MAXSTACK = ',500,' np = ',np
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            e(np) = Ei + prm
            iq(np) = -1
            X(np)=X(np-1)
            Y(np)=Y(np-1)
            Z(np)=Z(np-1)
            IR(np)=IR(np-1)
            WT(np)=WT(np-1)
            DNEAR(np)=DNEAR(np-1)
            LATCH(np)=LATCH(np-1)
            IF((rng_seed .GT. 128))call ranmar_get
            eta = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            eta = 2*eta - 1
            w(np) = eta
            eta = (1-eta)*(1+eta)
            IF (( eta .GT. 1e-20 )) THEN
              eta = Sqrt(eta)
13871         CONTINUE
                IF((rng_seed .GT. 128))call ranmar_get
                xphi = rng_array(rng_seed)*twom24
                rng_seed = rng_seed + 1
                xphi = 2*xphi - 1
                xphi2 = xphi*xphi
                IF((rng_seed .GT. 128))call ranmar_get
                yphi = rng_array(rng_seed)*twom24
                rng_seed = rng_seed + 1
                yphi2 = yphi*yphi
                rhophi2 = xphi2 + yphi2
                IF(rhophi2.LE.1)GO TO13872
              GO TO 13871
13872         CONTINUE
              rhophi2 = 1/rhophi2
              cphi = (xphi2 - yphi2)*rhophi2
              sphi = 2*xphi*yphi*rhophi2
              u(np) = eta*cphi
              v(np) = eta*sphi
            ELSE
              u(np) = 0
              v(np) = 0
              w(np) = 1
            END IF
            IARG=27
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE
            edep = edep + Ei
            edep_local = Ei
            IARG=34
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          END IF
          IF((n_vac .GT. 0))goto 13860
          GO TO13862
        END IF
        IF((rng_seed .GT. 128))call ranmar_get
        eta = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        DO 13881 k=first_transition(shell),last_transition(shell)-1
          eta = eta - relaxation_prob(k,iZ)
          IF((eta .LE. 0))GO TO13882
13881   CONTINUE
13882   CONTINUE
        final = final_state(k)
        finala = final
        IF (( final .LT. 100 )) THEN
          IF (( final .LT. 10 )) THEN
            iql = 0
            elcut = pkcut
          ELSE
            final = final - 10
            iql = -1
            elcut = ekcut
          END IF
          Ef = binding_energies(final,iZ)
          Ex = Ei - Ef
          n_vac = n_vac + 1
          vac_array(n_vac) = final
          e_array(n_vac) = Ef
        ELSE
          final1 = final/100
          final2 = final - final1*100
          n_vac = n_vac + 1
          vac_array(n_vac) = final1
          e_array(n_vac) = binding_energies(final1,iZ)
          n_vac = n_vac + 1
          vac_array(n_vac) = final2
          e_array(n_vac) = binding_energies(final2,iZ)
          iql = -1
          Ex = Ei - e_array(n_vac) - e_array(n_vac-1)
          elcut = ekcut
        END IF
        IF (( Ex .LE. elcut )) THEN
          edep = edep + Ex
          IF (( finala .LT. 10 )) THEN
            edep_local = Ex
            IARG=33
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE
            edep_local = Ex
            IARG=34
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          END IF
        ELSE
          np = np + 1
          IF (( np .GT. 500 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','RELAX',
     *      ' stack size exceeded! ',' $MAXSTACK = ',500,' np = ',np
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          iq(np) = iql
          IF (( iql .EQ. 0 )) THEN
            e(np) = Ex
          ELSE
            e(np) = Ex + rm
          END IF
          X(np)=X(np-1)
          Y(np)=Y(np-1)
          Z(np)=Z(np-1)
          IR(np)=IR(np-1)
          WT(np)=WT(np-1)
          DNEAR(np)=DNEAR(np-1)
          LATCH(np)=LATCH(np-1)
          IF((rng_seed .GT. 128))call ranmar_get
          eta = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          eta = 2*eta - 1
          w(np) = eta
          eta = (1-eta)*(1+eta)
          IF (( eta .GT. 1e-20 )) THEN
            eta = Sqrt(eta)
13891       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              xphi = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              xphi = 2*xphi - 1
              xphi2 = xphi*xphi
              IF((rng_seed .GT. 128))call ranmar_get
              yphi = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              yphi2 = yphi*yphi
              rhophi2 = xphi2 + yphi2
              IF(rhophi2.LE.1)GO TO13892
            GO TO 13891
13892       CONTINUE
            rhophi2 = 1/rhophi2
            cphi = (xphi2 - yphi2)*rhophi2
            sphi = 2*xphi*yphi*rhophi2
            u(np) = eta*cphi
            v(np) = eta*sphi
          ELSE
            u(np) = 0
            v(np) = 0
            w(np) = 1
          END IF
          IF (( finala .LT. 10 )) THEN
            IARG=25
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE IF(( finala .LT. 100 )) THEN
            IARG=26
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE
            IARG=27
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          END IF
        END IF
      GO TO 13861
13862 CONTINUE
      return
      end
      subroutine egs_init_relax
      implicit none
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(10), GE0(10),GE1(10), GMFP0(2000,10),GMFP1(2
     *000,10),GBR10(2000,10),GBR11(2000,10),GBR20(2000,10),GBR21(2000,10
     *), RCO0(10),RCO1(10), RSCT0(100,10),RSCT1(100,10), COHE0(2000,10),
     *COHE1(2000,10),  PHOTONUC0(2000,10),PHOTONUC1(2000,10), DPMFP, MPG
     *EM(1,10), NGR(10)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/shell_data/ shell_be(3000),  shell_type(3000),  shell_num(3
     *000),  shell_Z(3000),  shell_eadl(100,30),  shell_ntot
      real*8 shell_be
      integer*4 shell_type,shell_Z,shell_ntot,shell_num,shell_eadl
      integer*4 lnblnk1,egs_get_unit,relax_unit,ounit,egs_open_file
      integer*4 sorted(100),i,j,k,k1,k2,m
      real*8 z_sorted(100),pz_sorted(100)
      character data_dir*128,relax_file*144
      integer*4 ish,medio,iZ,ntran
      real*8 Ec, Pc, tmp, min_be, sumw,Ex
      logical is_open, is_there
      real*8 wtmp(300)
      integer*4 itmp(300)
      integer*4 pos, curr_rec, sh_eadl
      integer*4 nz, nshell, tr_type
      integer*4 ttype
      real*4 be_r, prob_r
      DO 13901 iZ=1,100
        DO 13911 k=1,30
          shell_eadl(iZ,k) = -1
13911   CONTINUE
13912   CONTINUE
13901 CONTINUE
13902 CONTINUE
      min_be = 0.001
      write(i_log,'(/a)') ' Reading EADL relaxation data ......'
      data_dir = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      relax_file = data_dir(:lnblnk1(data_dir)) // 'relax.data'
      relax_unit = egs_get_unit(0)
      IF (( relax_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_relax: failed to get a free Fortran I/O
     * unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(relax_unit,file=relax_file,status='old', form='UNFORMATTED',A
     *CCESS='direct',recl=4, err=13920)
      GOTO 13930
13920 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(2a)') 'egs_init_relax: failed to open ', relax_file
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
13930 is_open = .true.
      curr_rec = 1
      read(relax_unit,rec=curr_rec) nz
      shell_ntot = 0
      relax_ntot = 0
      DO 13941 medio=1,nmed
        DO 13951 i=1,nne(medio)
          z_sorted(i) = zelem(medio,i)
13951   CONTINUE
13952   CONTINUE
        call egs_heap_sort(nne(medio),z_sorted,sorted)
        DO 13961 i=1,nne(medio)
          iZ = z_sorted(i)
          is_there = .false.
          DO 13971 j=1,shell_ntot
            IF (( iZ .EQ. shell_Z(j) )) THEN
              is_there = .true.
              GO TO13972
            END IF
13971     CONTINUE
13972     CONTINUE
          IF((is_there))GO TO13961
          pos = iZ + 1
          read(relax_unit,rec=pos) curr_rec
          read(relax_unit,rec=curr_rec) nshell
          IF (( shell_ntot + nshell .GT. 3000 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a,i5,a/,a//)') ' Too many shells to fit in the
     * list: ', shell_ntot + nshell,' (at least).', ' Increase the param
     *eter $MAXSHELL and retry '
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          write(i_log,'(a,i3,a,i2,a)') '  Z = ',iZ,' has ',nshell,' shel
     *ls'
          DO 13981 ish=shell_ntot+1,shell_ntot+nshell
            curr_rec = curr_rec+1
            read(relax_unit,rec=curr_rec) shell_type(ish)
            curr_rec = curr_rec+1
            read(relax_unit,rec=curr_rec) ntran
            curr_rec = curr_rec+1
            read(relax_unit,rec=curr_rec) be_r
            shell_be(ish) = be_r
            shell_Z(ish) = iZ
            shell_num(ish) = ish - shell_ntot
            shell_eadl(iZ,shell_num(ish)) = ish
            IF ((binding_energies(shell_num(ish),iZ) .GT. 0)) THEN
              shell_be(ish) = binding_energies(shell_num(ish),iZ)
            ELSE IF(( photon_xsections .EQ. 'epdl' )) THEN
              binding_energies(shell_num(ish),iZ) = shell_be(ish)
            END IF
            DO 13991 k=1,ntran
              curr_rec = curr_rec+1
              read(relax_unit,rec=curr_rec) itmp(k)
              curr_rec = curr_rec+1
              read(relax_unit,rec=curr_rec) prob_r
              wtmp(k)=prob_r
              IF ((itmp(k).LT.64)) THEN
                itmp(k) = itmp(k) + 1
              ELSE
                itmp(k) = itmp(k) + 65
              END IF
13991       CONTINUE
13992       CONTINUE
            IF (( shell_be(ish) .LT. min_be )) THEN
              relax_first(ish) = -1
              relax_ntran(ish) = -1
            ELSE
              sumw = 0
              DO 14001 k=1,ntran
                sumw = sumw + wtmp(k)
14001         CONTINUE
14002         CONTINUE
              IF (( sumw .GT. 1 )) THEN
                DO 14011 k=1,ntran
                  wtmp(k) = wtmp(k)/sumw
14011           CONTINUE
14012           CONTINUE
              ELSE IF(( sumw .LT. 1 )) THEN
                ntran = ntran + 1
                itmp(ntran) = -1
                wtmp(ntran) = 1-sumw
              END IF
              IF (( relax_ntot + ntran .GT. 10000 )) THEN
                write(i_log,'(/a)') '***************** Error: '
                write(i_log,'(a,i5,a/,a/)') ' Too many relaxation transi
     *tions: ', relax_ntot + ntran,' (at least).', ' Increase $MAXRELAX
     *and retry '
                write(i_log,'(/a)') '***************** Quiting now.'
                call exit(1)
              END IF
              relax_first(ish) = relax_ntot+1
              relax_ntran(ish) = ntran
              call prepare_alias_histogram(ntran,wtmp, relax_atbin(relax
     *        _ntot+1))
              DO 14021 k=1,ntran
                j = relax_ntot + k
                relax_state(j) = itmp(k)
                relax_prob(j) = wtmp(k)
14021         CONTINUE
14022         CONTINUE
              relax_ntot = relax_ntot + ntran
            END IF
13981     CONTINUE
13982     CONTINUE
          shell_ntot = shell_ntot + nshell
13961   CONTINUE
13962   CONTINUE
13941 CONTINUE
13942 CONTINUE
      write(i_log,'(a/)') ' ...... Done.'
      IF((is_open))close(relax_unit)
      return
      stop
      end
      subroutine egs_eadl_relax(iZ, shell_egs)
      implicit none
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/relax_for_user/ rfu_E0,  rfu_E,  rfu_Z,  rfu_j0,  rfu_n0,
     *rfu_t0,  rfu_j,  rfu_n,  rfu_t
      integer*4 rfu_Z,rfu_j0,rfu_n0,rfu_t0,rfu_j,rfu_n,rfu_t
      real*8 rfu_E0,rfu_E
      common/shell_data/ shell_be(3000),  shell_type(3000),  shell_num(3
     *000),  shell_Z(3000),  shell_eadl(100,30),  shell_ntot
      real*8 shell_be
      integer*4 shell_type,shell_Z,shell_ntot,shell_num,shell_eadl
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/BOUNDS/ECUT( 12001),PCUT( 12001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common/user_relax/ u_relax,ish_relax,iZ_relax
      real*8 u_relax
      integer*4 ish_relax, iZ_relax
      real*8 Ec,Pc,min_E,rnno,Evac,Ef,Ef1,Ef2,Ex,Ecc, cost,sint,cphi,sph
     *i
      integer*4 shell, shell_egs, iZ, iarg
      integer*4 irl,vacs(100),nvac,vac,new_state,iqf,np_save,new1,new2
      integer*4 sample_alias_histogram
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      shell = shell_eadl(iZ,shell_egs)
      IF (( shell .LT. 1 .OR. shell .GT. 3000 )) THEN
        return
      END IF
      irl = ir(np)
      Ec = ecut(irl) - rm
      Pc = pcut(irl)
      min_E = 0.001
      Evac = shell_be(shell)
      rfu_Z = shell_Z(shell)
      rfu_j0 = shell
      rfu_n0 = shell_num(shell)
      rfu_t0 = shell_type(shell)
      rfu_E0 = Evac
      IF ((shell_egs .GT. 4 .AND. .NOT.mcdf_pe_xsections)) THEN
        edep = Evac
        edep_local = Evac
        IARG=34
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
        return
      END IF
      vac = shell
      Nvac = 0
      np_save = np
14031 CONTINUE
        IF (( Evac .LT. min_E .OR. relax_ntran(vac) .LT. 1 )) THEN
          edep = edep + Evac
          edep_local = Evac
          IARG=34
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          go to 14040
        END IF
        new_state = sample_alias_histogram(relax_ntran(vac), relax_prob(
     *  relax_first(vac)), relax_atbin(relax_first(vac)))
        IF (( new_state .LT. 0 )) THEN
          Ef = 0
          iqf = -1
          Ecc = Ec
        ELSE
          new_state = relax_state(relax_first(vac)+new_state-1)
          IF (( new_state .LE. 64 )) THEN
            iqf = 0
            new_state = new_state + vac - shell_num(vac)
            Ef = shell_be(new_state)
            Nvac = Nvac + 1
            vacs(Nvac) = new_state
            Ecc = Pc
          ELSE
            iqf = -1
            new1 = new_state/64
            new2 = new_state - 64*new1
            new1 = new1 + vac - shell_num(vac)
            new2 = new2 + vac - shell_num(vac)
            Ef1 = shell_be(new1)
            Ef2 = shell_be(new2)
            Nvac = Nvac + 1
            vacs(Nvac) = new1
            Nvac = Nvac + 1
            vacs(Nvac) = new2
            Ef = Ef1 + Ef2
            Ecc = Ec
          END IF
        END IF
        Ex = Evac - Ef
        edep_local = 0
        IF (( Ex .GT. Ecc )) THEN
          np = np + 1
          IF (( np .GT. 500 )) THEN
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,'(3(a,f10.6),a,i2)') 'Evac = ',Evac, ' Ef = ',Ef
     *      ,  ' min_E = ', min_E,' iq = ',iqf
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(//,3a,/,2(a,i9),/,a)') ' In subroutine ','new_
     *relax', ' stack size exceeded! ',' $MXSTACK = ',500,' np = ',np, '
     * Increase $MXSTACK and try again '
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          iq(np) = iqf
          X(np)=X(np_save)
          Y(np)=Y(np_save)
          Z(np)=Z(np_save)
          IR(np)=IR(np_save)
          WT(np)=WT(np_save)
          DNEAR(np)=DNEAR(np_save)
          LATCH(np)=LATCH(np_save)
          IF((rng_seed .GT. 128))call ranmar_get
          rnno = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          cost = 2*rnno-1
          sint = 1-cost*cost
          IF (( sint .GT. 0 )) THEN
            sint = sqrt(sint)
14051       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              xphi = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              xphi = 2*xphi - 1
              xphi2 = xphi*xphi
              IF((rng_seed .GT. 128))call ranmar_get
              yphi = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              yphi2 = yphi*yphi
              rhophi2 = xphi2 + yphi2
              IF(rhophi2.LE.1)GO TO14052
            GO TO 14051
14052       CONTINUE
            rhophi2 = 1/rhophi2
            cphi = (xphi2 - yphi2)*rhophi2
            sphi = 2*xphi*yphi*rhophi2
            u(np) = sint*cphi
            v(np) = sint*sphi
            w(np) = cost
          ELSE
            u(np) = 0
            v(np) = 0
            w(np) = cost
          END IF
          rfu_j = vac
          rfu_n = shell_num(vac)
          rfu_t = shell_type(vac)
          rfu_E = shell_be(vac)
          IF (( iqf .EQ. 0 )) THEN
            e(np) = Ex
            IARG=25
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE
            e(np) = Ex + rm
            IARG=27
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          END IF
        ELSE
          edep = edep + Ex
          IF (( iqf .EQ. 0 )) THEN
            edep_local = Ex
            IARG=33
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE
            edep_local = Ex
            IARG=34
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          END IF
        END IF
14040   CONTINUE
        IF((Nvac .EQ. 0))GO TO14032
        vac = vacs(Nvac)
        Evac = shell_be(vac)
        Nvac = Nvac - 1
      GO TO 14031
14032 CONTINUE
      return
      end
      subroutine init_triplet
      implicit none
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/triplet_data/ a_triplet(250,10), b_triplet(250,10), dl_trip
     *let, dli_triplet, bli_triplet, log_4rm
      real*8 a_triplet,b_triplet,dl_triplet, dli_triplet, bli_triplet, l
     *og_4rm
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      real*8 energies(55), sig_pair(100,55), sig_triplet(100,55), f_trip
     *let(55), sigp(55), sigt(55), as(55), bs(55), cs(55), ds(55)
      character*128 triplet_data_file
      integer*4 want_triplet_unit, triplet_unit, triplet_out
      integer*4 i, iel, imed, lnblnk1, egs_get_unit, ntrip, iz1, izi, if
     *irst
      real*8 logE, f_new, f_old, spline
      IF((itriplet .EQ. 0))return
      DO 14061 i=1,len(triplet_data_file)
        triplet_data_file(i:i) = ' '
14061 CONTINUE
14062 CONTINUE
      triplet_data_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/
     *' // 'triplet.data'
      want_triplet_unit = 63
      triplet_unit = egs_get_unit(want_triplet_unit)
      IF (( triplet_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'init_triplet: failed to get a free Fortran I/O u
     *nit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(triplet_unit,file=triplet_data_file,err=14070)
      write(i_log,'(a,$)') ' init_triplet: reading triplet data ... '
      read(triplet_unit,*) ntrip
      IF (( ntrip .GT. 55 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Max. number of data points per element is ',55
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      read(triplet_unit,*,err=14080) (energies(i),i=1,ntrip)
      DO 14091 iel=1,100
        read(triplet_unit,*)
        read(triplet_unit,*,err=14080) (sig_pair(iel,i),i=1,ntrip)
        read(triplet_unit,*,err=14080) (sig_triplet(iel,i),i=1,ntrip)
14091 CONTINUE
14092 CONTINUE
      write(i_log,*) 'OK'
      ifirst = 0
      DO 14101 i=1,ntrip
        IF((ifirst .EQ. 0 .AND. energies(i) .GT. 4.01*rm))ifirst = i
        energies(i) = log(energies(i))
14101 CONTINUE
14102 CONTINUE
      log_4rm = log(4*rm)
      energies(ifirst-1) = log_4rm
      dl_triplet = (energies(ntrip) - log_4rm)/250
      dli_triplet = 1/dl_triplet
      bli_triplet = 1 - log_4rm/dl_triplet
      DO 14111 imed=1,nmed
        write(i_log,'(a,i3,a,$)') '   Preparing triplet fraction data fo
     *r medium ',imed,' ... '
        iz1 = zelem(imed,1) + 0.1
        DO 14121 i=1,ntrip
          sigp(i) = pz(imed,1)*sig_pair(iz1,i)
          sigt(i) = pz(imed,1)*sig_triplet(iz1,i)
          DO 14131 iel=2,nne(imed)
            izi = zelem(imed,iel) + 0.1
            sigp(i) = sigp(i) + pz(imed,iel)*sig_pair(izi,i)
            sigt(i) = sigt(i) + pz(imed,iel)*sig_triplet(izi,i)
14131     CONTINUE
14132     CONTINUE
14121   CONTINUE
14122   CONTINUE
        DO 14141 i=ifirst,ntrip
          f_triplet(i-ifirst+2) = sigt(i)/(sigp(i) + sigt(i))
14141   CONTINUE
14142   CONTINUE
        f_triplet(1) = 0
        call set_spline(energies(ifirst-1),f_triplet,as,bs,cs,ds,ntrip-i
     *  first+2)
        logE = log_4rm
        f_old = 0
        DO 14151 i=1,250-1
          logE = logE + dl_triplet
          f_new = spline(logE,energies(ifirst-1),as,bs,cs,ds,ntrip-ifirs
     *    t+2)
          a_triplet(i,imed) = (f_new - f_old)*dli_triplet
          b_triplet(i,imed) = f_new - a_triplet(i,imed)*logE
          f_old = f_new
14151   CONTINUE
14152   CONTINUE
        write(i_log,*) 'OK'
14111 CONTINUE
14112 CONTINUE
      close(triplet_unit)
      return
14070 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,a)') ' init_triplet: failed to open the data file
     *', triplet_data_file(:lnblnk1(triplet_data_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
14080 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' init_triplet: error while reading triplet data '
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      SUBROUTINE EDGSET(NREGLO,NREGHI)
      implicit none
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer NREGLO,NREGHI
      integer*4 i,j,k,jj,iz
      logical do_relax
      logical got_data
      save got_data
      data got_data/.false./
      IF((got_data))return
      write(i_log,'(a/,a)') 'Output from subroutine EDGSET:', '=========
     *====================='
      do_relax = .false.
      DO 14161 j=1, 12001
        IF (( iedgfl(j) .GT. 0 .AND. iedgfl(j) .LE. 100 )) THEN
          do_relax = .true.
          GO TO14162
        END IF
14161 CONTINUE
14162 CONTINUE
      IF (( .NOT.do_relax )) THEN
        IF ((eadl_relax)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,/a)') 'You must turn ON atomic relaxations whe
     *n requesting', 'detailed atomic relaxation (eadl_relax=true)!'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        write(i_log,'(a/)') ' Atomic relaxations not requested! '
        return
      END IF
      write(i_log,'(a/)') ' Atomic relaxations requested! '
      write(i_log,'(a$)') ' Reading simplified photo-absorption data ...
     *..'
      got_data = .true.
      rewind(i_photo_relax)
      DO 14171 i=1,100
        IF ((eadl_relax)) THEN
          read(i_photo_relax,*)
        ELSE
          read(i_photo_relax,*) j,(binding_energies(k,i),k=1,6)
          DO 14181 k=1,6
            binding_energies(k,i) = binding_energies(k,i)*1e-6
14181     CONTINUE
14182     CONTINUE
        END IF
14171 CONTINUE
14172 CONTINUE
      read(i_photo_relax,*)
      DO 14191 i=1,100
        read(i_photo_relax,*) j,(interaction_prob(k,i),k=1,5)
        interaction_prob(6,i)=1.01
14191 CONTINUE
14192 CONTINUE
      write(i_log,'(a)') ' Done'
      write(i_log,'(/a$)') ' Reading simplified relaxation data .....'
      read(i_photo_relax,*)
      DO 14201 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=1,19)
14201 CONTINUE
14202 CONTINUE
      read(i_photo_relax,*)
      DO 14211 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=20,26)
14211 CONTINUE
14212 CONTINUE
      read(i_photo_relax,*)
      DO 14221 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=27,32)
14221 CONTINUE
14222 CONTINUE
      read(i_photo_relax,*)
      DO 14231 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=33,37)
14231 CONTINUE
14232 CONTINUE
      read(i_photo_relax,*)
      DO 14241 i=1,100
        read(i_photo_relax,*) j,relaxation_prob(38,i)
14241 CONTINUE
14242 CONTINUE
      write(i_log,'(a)') ' Done'
      write(i_log,'(/a$)') ' Reading parametrized XCOM photo cross secti
     *on data .....'
      rewind(i_photo_cs)
      DO 14251 i=1,100
        read(i_photo_cs,*) j,edge_number(i)
        DO 14261 j=1,edge_number(i)
          read(i_photo_cs,*) edge_a(j,i),edge_b(j,i),edge_c(j,i), edge_d
     *    (j,i),edge_energies(j,i)
14261   CONTINUE
14262   CONTINUE
14251 CONTINUE
14252 CONTINUE
      write(i_log,'(a)') ' Done'
      IF ((eadl_relax)) THEN
        call egs_init_relax
      END IF
      RETURN
      END
      SUBROUTINE PHOTON(IRCODE)
      implicit none
      integer*4 IRCODE
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/BOUNDS/ECUT( 12001),PCUT( 12001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/PHOTIN/ EBINDA(10), GE0(10),GE1(10), GMFP0(2000,10),GMFP1(2
     *000,10),GBR10(2000,10),GBR11(2000,10),GBR20(2000,10),GBR21(2000,10
     *), RCO0(10),RCO1(10), RSCT0(100,10),RSCT1(100,10), COHE0(2000,10),
     *COHE1(2000,10),  PHOTONUC0(2000,10),PHOTONUC1(2000,10), DPMFP, MPG
     *EM(1,10), NGR(10)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERRR/ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN, MINZ,MAXZ,MINR,MAXR
     *,IREJCT
      real*8 ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN
      integer*4 MINZ,MAXZ,MINR,MAXR,IREJCT
      COMMON/USERMI/EXPMFP,GWTOLD,ICSDA
      integer*4 ICSDA
      real*8 EXPMFP,GWTOLD
      COMMON/USERVR/ CEXPTR,GWAIT,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,
     *IQINC,MONOEN, cs_enhance,cs_enhance_current,ienhance,iefl( 12001),
     *ics_enhance, do_fast_step
      integer*4 ienhance,iefl,ics_enhance, IFORCE,NFMIN,NFMAX,NFTIME,ISO
     *URC,IFPB,IQINC,MONOEN
      real*8 CEXPTR,GWAIT,cs_enhance,cs_enhance_current
      logical do_fast_step
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/NRCNEW/NEWNRC,DECISION
      integer*4 NEWNRC,DECISION
      DOUBLE PRECISION PEIG
      real*8 EIG,  RNNO35,  GMFPR0,  GMFP,  COHFAC,  RNNO37,  XXX,  X2,
     * Q2,  CSQTHE,  REJF,  RNNORJ,  RNNO36,  GBR1,  GBR2,  T,   PHOTONU
     *CFAC,  RNNO39
      integer*4 IARG,  IDR,  IRL,  LGLE,  LXXX
      real*8 SPMFP,TEMP,TEMP1,PATHLT
      real*8 DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,EPSLON,ARG
      integer*4 IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,NRCDUM
      IRCODE=1
      PEIG=E(NP)
      EIG=PEIG
      IRL=IR(NP)
      medium = med(irl)
      IF ((EIG .LE. PCUT(IRL))) THEN
        GO TO 14270
      END IF
14280 CONTINUE
14281   CONTINUE
        IF ((WT(NP) .EQ. 0.0)) THEN
          go to 14290
        END IF
        GLE=LOG(EIG)
        NFTIME=NFTIME+1
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO35 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((RNNO35 .EQ. 0.0))RNNO35=1.E-30
        IF (((IFORCE.EQ.0).OR.(NFTIME.GT.NFMAX).OR.(NFTIME.LT.NFMIN))) T
     *  HEN
          SPMFP=-LOG(RNNO35)
          IF (( (CEXPTR.LT.1.0) .AND.(NFTIME.GE.NFMIN) .AND.(NFTIME.LE.N
     *    FMAX) .AND.( ((W(NP).GT.0.0).AND.(CEXPTR.GT.0.0)).OR.(CEXPTR.L
     *    T.0.0)) )) THEN
            TEMP=CEXPTR*W(NP)
            TEMP1=1.0-TEMP
            SPMFP=SPMFP/TEMP1
            WT(NP)=WT(NP)*EXP(-SPMFP*TEMP)/TEMP1
          END IF
          DPMFP=SPMFP
        ELSE
          IF(((do_fast_step).AND.(NFTIME.EQ.1).AND.(CEXPTR.EQ.0.0)))GOTO
     *     14300
          DUMU=USTEP
          DUMX=X(NP)
          DUMY=Y(NP)
          DUMZ=Z(NP)
          IRODUM=IROLD
          IRNDUM=IRNEW
          IRDUM=IR(NP)
          MEDDUM=MEDIUM
          IDUM=IDISC
          NRCDUM=NEWNRC
          PATHL=0.0
          MEDTMP=0
14311     CONTINUE
            USTEP=VACDST
            IROLD=IR(NP)
            MEDIUM=MED(IROLD)
            IF ((MEDIUM.EQ.0)) THEN
              DELTAP=0.
            ELSE
              IF ((MEDTMP.NE.MEDIUM)) THEN
                MEDTMP=MEDIUM
                LGLE=GE1(MEDIUM)*GLE+GE0(MEDIUM)
                DELTAP=GMFP1(LGLE,MEDIUM)*GLE+GMFP0(LGLE,MEDIUM)
              END IF
              IF ((IRAYLR(IROLD).EQ.1)) THEN
                COHFAC=COHE1(LGLE,MEDIUM)*GLE+COHE0(LGLE,MEDIUM)
              ELSE
                COHFAC=1.0
              END IF
            END IF
            IRNEW=IROLD
            CALL HOWFAR
            IF((DELTAP.NE.0))PATHL=PATHL+USTEP/(DELTAP*COHFAC)
            IF((IRNEW.EQ.1))GO TO14312
            IR(NP)=IRNEW
            X(NP)=X(NP)+USTEP*U(NP)
            Y(NP)=Y(NP)+USTEP*V(NP)
            Z(NP)=Z(NP)+USTEP*W(NP)
          GO TO 14311
14312     CONTINUE
          USTEP=DUMU
          X(NP)=DUMX
          Y(NP)=DUMY
          Z(NP)=DUMZ
          IROLD=IRODUM
          IRNEW=IRNDUM
          IR(NP)=IRDUM
          MEDIUM=MEDDUM
          IDISC=IDUM
          NEWNRC=NRCDUM
          IF ((CEXPTR.EQ.0)) THEN
            IF ((PATHL.LE.1.0E-3)) THEN
              GWAIT=PATHL*(1.-0.5*PATHL)
            ELSE
              GWAIT=1.-EXP(-PATHL)
            END IF
          END IF
          GWTOLD=WT(NP)
          WT(NP)=GWTOLD*GWAIT
14300     CONTINUE
          IF ((CEXPTR.EQ.0)) THEN
            EPSLON=RNNO35*GWAIT
            IF ((EPSLON.LE.1.0E-3)) THEN
              IF((NFTIME.EQ.1))EXPMFP=EPSLON*(1.+EPSLON)
              DPMFP=EPSLON*(1.+0.5*EPSLON)
            ELSE
              ARG=1./(1.-EPSLON)
              DPMFP=LOG(ARG)
              IF((NFTIME.EQ.1))EXPMFP=EPSLON*ARG
            END IF
          ELSE
            TEMP=CEXPTR*W(NP)
            TEMP1=1.0-TEMP
            PATHLT=PATHL*TEMP1
            IF ((ABS(PATHLT).LE.1.0E-3)) THEN
              SPMFP=PATHL*RNNO35*(1.0-0.5*PATHLT*(1.0-RNNO35))
              GWAIT=PATHL*(1.0-0.5*PATHLT)*EXP(-SPMFP*TEMP)
              DPMFP=SPMFP
            ELSE
              GWAIT=1.-EXP(-PATHLT)
              SPMFP=-LOG(1.0-RNNO35*GWAIT)/TEMP1
              GWAIT=GWAIT*EXP(-SPMFP*TEMP)/TEMP1
              DPMFP=SPMFP
            END IF
          END IF
        END IF
        IROLD=IR(NP)
14320   CONTINUE
14321     CONTINUE
          IF ((MEDIUM.NE.0)) THEN
            LGLE=GE1(MEDIUM)*GLE+GE0(MEDIUM)
            GMFPR0=GMFP1(LGLE,MEDIUM)*GLE+GMFP0(LGLE,MEDIUM)
          END IF
14330     CONTINUE
14331       CONTINUE
            IF ((MEDIUM.EQ.0)) THEN
              TSTEP=VACDST
            ELSE
              RHOF=RHOR(IRL)/RHO(MEDIUM)
              GMFP=GMFPR0/RHOF
              IF ((IRAYLR(IRL).EQ.1)) THEN
                COHFAC=COHE1(LGLE,MEDIUM)*GLE+COHE0(LGLE,MEDIUM)
                GMFP=GMFP*COHFAC
              END IF
              IF ((iefl(IRL) .EQ. 1)) THEN
                cs_enhance_current = cs_enhance*rho(medium)*gmfp
                IF (( cs_enhance_current .GT. 1 )) THEN
                  GMFP=GMFP/cs_enhance_current
                  ienhance=1
                ELSE
                  cs_enhance_current = 1
                  ienhance = 0
                END IF
              ELSE
                cs_enhance_current = 1
                ienhance=0
              END IF
              IF ((IPHOTONUCR(IRL).EQ.1)) THEN
                PHOTONUCFAC=PHOTONUC1(LGLE,MEDIUM)*GLE+PHOTONUC0(LGLE,ME
     *          DIUM)
                GMFP=GMFP*PHOTONUCFAC
              END IF
              TSTEP=GMFP*DPMFP
            END IF
            IRNEW=IR(NP)
            IDISC=0
            USTEP=TSTEP
            TUSTEP=USTEP
            IF (( ustep .GT. dnear(np) .OR. wt(np) .LE. 0 )) THEN
              call howfar
            END IF
            IF ((IDISC.GT.0)) THEN
              GO TO 14290
            END IF
            VSTEP=USTEP
            TVSTEP=VSTEP
            EDEP=PZERO
            x_final = x(np) + u(np)*vstep
            y_final = y(np) + v(np)*vstep
            z_final = z(np) + w(np)*vstep
            IARG=0
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            x(np) = x_final
            y(np) = y_final
            z(np) = z_final
            DNEAR(NP)=DNEAR(NP)-USTEP
            IF ((MEDIUM.NE.0)) THEN
              DPMFP=MAX(0.,DPMFP-USTEP/GMFP)
            END IF
            IROLD=IR(NP)
            MEDOLD=MEDIUM
            IF ((IRNEW.NE.IROLD)) THEN
              ir(np) = irnew
              irl = irnew
              medium = med(irl)
            END IF
            IARG=5
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            IF ((EIG.LE.PCUT(IRL))) THEN
              GO TO 14270
            END IF
            IF((IDISC.LT.0))GO TO 14290
            IF((MEDIUM.NE.MEDOLD))GO TO 14332
            IF ((MEDIUM.NE.0.AND.DPMFP.LE.1.E-8)) THEN
              GO TO 14322
            END IF
          GO TO 14331
14332     CONTINUE
        GO TO 14321
14322   CONTINUE
        IF ((IRAYLR(IRL).EQ.1)) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO37 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF ((RNNO37.LE.(1.0-COHFAC))) THEN
            IARG=23
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            NPold = NP
            call egs_rayleigh_sampling(MEDIUM,E(NP),GLE,LGLE,COSTHE,SINT
     *      HE)
            CALL UPHI(2,1)
            IARG=24
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            GOTO 14280
          END IF
        END IF
        IF ((IPHOTONUCR(IRL).EQ.1)) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO39 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF ((RNNO39.LE.(1.0-PHOTONUCFAC))) THEN
            IARG=29
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            call PHOTONUC
            IARG=30
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            GOTO 14280
          END IF
        END IF
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO36 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        GBR1=GBR11(LGLE,MEDIUM)*GLE+GBR10(LGLE,MEDIUM)
        IF (((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )) THEN
          IARG=15
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          CALL PAIR
          IARG=16
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          IF (( iq(np) .NE. 0 )) THEN
            GO TO 14282
          ELSE
            goto 14340
          END IF
        END IF
        GBR2=GBR21(LGLE,MEDIUM)*GLE+GBR20(LGLE,MEDIUM)
        IF ((RNNO36.LT.GBR2)) THEN
          IARG=17
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          CALL COMPT
          IARG=18
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          IF((IQ(NP).NE.0))GO TO 14282
        ELSE
          IARG=19
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          CALL PHOTO
          IF ((NP .EQ. 0 .OR. NP .LT. NPOLD )) THEN
            RETURN
          END IF
          IARG=20
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          IF((IQ(NP) .NE. 0))GO TO 14282
        END IF
14340   PEIG=E(NP)
        EIG=PEIG
        IF((EIG.LT.PCUT(IRL)))GO TO 14270
      GO TO 14281
14282 CONTINUE
      RETURN
14270 IF (( medium .GT. 0 )) THEN
        IF ((EIG.GT.AP(MEDIUM))) THEN
          IDR=1
        ELSE
          IDR=2
        END IF
      ELSE
        IDR=1
      END IF
      EDEP=PEIG
      IARG=IDR
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      IRCODE=2
      NP=NP-1
      RETURN
14290 EDEP=PEIG
      IARG=3
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      IRCODE=2
      NP=NP-1
      RETURN
      END
      SUBROUTINE SHOWER(IQI,EI,XI,YI,ZI,UI,VI,WI,IRI,WTI)
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 EI,  XI,YI,ZI, UI,VI,WI, WTI
      integer*4 IQI,  IRI
      DOUBLE PRECISION DEG,  DPGL,  DEI,  DPI,  DCSTH,  DCOSTH,  PI0MSQ
      real*8 DNEARI,  CSTH
      integer*4 IRCODE
      DATA PI0MSQ/1.8215416D4/
      NP=1
      NPold = NP
      DNEARI=0.0
      IQ(1)=IQI
      E(1)=EI
      U(1)=UI
      V(1)=VI
      W(1)=WI
      X(1)=XI
      Y(1)=YI
      Z(1)=ZI
      IR(1)=IRI
      WT(1)=WTI
      DNEAR(1)=DNEARI
      LATCH(1)=LATCHI
      IF ((IQI .EQ. 2)) THEN
        IF ((EI**2 .LE. PI0MSQ)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//a/,a,g15.5,a)') ' Stopped in subroutine SHOWER
     *---PI-ZERO option invoked', ' but the total energy was too small (
     *EI=',EI,' MeV)'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF((rng_seed .GT. 128))call ranmar_get
        CSTH = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        DCSTH=CSTH
        DEI=EI
        DPI=DSQRT(DEI*DEI-PI0MSQ)
        DEG=DEI+DPI*DCSTH
        DPGL=DPI+DEI*DCSTH
        DCOSTH=DPGL/DEG
        COSTHE=DCOSTH
        SINTHE=DSQRT(1.D0-DCOSTH*DCOSTH)
        IQ(1)=0
        E(1)=DEG/2.
        CALL UPHI(2,1)
        NP=2
        DEG=DEI-DPI*DCSTH
        DPGL=DPI-DEI*DCSTH
        DCOSTH=DPGL/DEG
        COSTHE=DCOSTH
        SINTHE=-DSQRT(1.D0-DCOSTH*DCOSTH)
        IQ(2)=0
        E(2)=DEG/2.
        CALL UPHI(3,2)
      END IF
14351 CONTINUE
        IF((np .LE. 0))GO TO14352
        IF (( iq(np) .EQ. 0 )) THEN
          call photon(ircode)
        ELSE
          call electr(ircode)
        END IF
      GO TO 14351
14352 CONTINUE
      RETURN
      END
      SUBROUTINE UPHI(IENTRY,LVL)
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      real*8 SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer IENTRY,LVL
      real*8 CTHET,  RNNO38,  PHI,  CPHI,  A,B,C,  SINPS2,  SINPSI,  US,
     *VS,  SINDEL,COSDEL
      integer*4 IARG,  LPHI,LTHETA,LCTHET,LCPHI
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      save CTHET,PHI,CPHI,A,B,C,SINPS2,SINPSI,US,VS,SINDEL,COSDEL
      IARG=21
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      GO TO (14360,14370,14380),IENTRY
      GO TO 14390
14360 CONTINUE
      SINTHE=sin(THETA)
      CTHET=PI5D2-THETA
      COSTHE=sin(CTHET)
14370 CONTINUE
14401 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        xphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF((rng_seed .GT. 128))call ranmar_get
        yphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO14402
      GO TO 14401
14402 CONTINUE
      rhophi2 = 1/rhophi2
      cosphi = (xphi2 - yphi2)*rhophi2
      sinphi = 2*xphi*yphi*rhophi2
14380 GO TO (14410,14420,14430),LVL
      GO TO 14390
14410 A=U(NP)
      B=V(NP)
      C=W(NP)
      GO TO 14440
14430 A=U(NP-1)
      B=V(NP-1)
      C=W(NP-1)
14420 X(NP)=X(NP-1)
      Y(NP)=Y(NP-1)
      Z(NP)=Z(NP-1)
      IR(NP)=IR(NP-1)
      WT(NP)=WT(NP-1)
      DNEAR(NP)=DNEAR(NP-1)
      LATCH(NP)=LATCH(NP-1)
14440 SINPS2=A*A+B*B
      IF ((SINPS2.LT.1.0E-20)) THEN
        U(NP)=SINTHE*COSPHI
        V(NP)=SINTHE*SINPHI
        W(NP)=C*COSTHE
      ELSE
        SINPSI=SQRT(SINPS2)
        US=SINTHE*COSPHI
        VS=SINTHE*SINPHI
        SINDEL=B/SINPSI
        COSDEL=A/SINPSI
        U(NP)=C*COSDEL*US-SINDEL*VS+A*COSTHE
        V(NP)=C*SINDEL*US+COSDEL*VS+B*COSTHE
        W(NP)=-SINPSI*US+C*COSTHE
      END IF
      IARG=22
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      RETURN
14390 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,2i6)') ' STOPPED IN UPHI WITH IENTRY,LVL=',IENTRY,
     *LVL
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      END
      subroutine init_nist_brems
      implicit none
      real*8 energy_array(57),x_array(54), cs_array(57,54,100)
      real*8 xi_array(54)
      real*8 x_gauss(64),w_gauss(64)
      integer*4 nmix,kmix,i,n,k,j,ii
      integer*4 ngauss,i_gauss
      integer*4 lnblnk1,egs_get_unit
      integer*4 ifirst,ilast,nener,neke,leil
      real*8 cs(57,54),ee(57),ele(57)
      real*8 csx(54),afx(54),bfx(54),cfx(54),dfx(54)
      real*8 cse(57),afe(57),bfe(57),cfe(57),dfe(57)
      real*8 Z,sumA
      real*8 emin,xi,res,spline,eil,ei,beta2,aux,sigb,sigt,ebr1,ebr2
      real*8 sigee,sigep,sige,si_esig,si1_esig,si_ebr1,si1_ebr1,ededx, s
     *ig_bhabha,si_psig,si1_psig,si_pbr1,si1_pbr1,si_pbr2,si1_pbr2
      integer*4 iz
      real*8 ple,qle,x,f,error,max_error,x_max_error,f_max_error
      integer*4 ndat,k_max_error
      character tmp_string*512, tmp1_string*512
      integer itmp
      real*8 amu
      parameter (amu = 1660.5655)
      logical ex,is_opened
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/nist_brems/ nb_fdata(0:50,100,10), nb_xdata(0:50,100,10), n
     *b_wdata(50,100,10), nb_idata(50,100,10), nb_emin(10),nb_emax(10),
     *nb_lemin(10),nb_lemax(10), nb_dle(10),nb_dlei(10), log_ap(10)
      real*8 nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lema
     *x, nb_dle,nb_dlei,log_ap
      integer*4 nb_idata
      common/spin_data/ spin_rej(10,0:1,0: 31,0:15,0:31), espin_min,espi
     *n_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dleneri,d
     *qq1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DO 14451 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
14451 CONTINUE
14452 CONTINUE
      tmp_string = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      IF (( ibr_nist .EQ. 1 )) THEN
        DO 14461 i=1,len(tmp1_string)
          tmp1_string(i:i) = ' '
14461   CONTINUE
14462   CONTINUE
        tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'nist_brems.da
     *ta'
        inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
        IF (( .NOT.ex )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'EGSnrc data file ','nist_brems.data',' does no
     *t exist'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF (( .NOT.is_opened )) THEN
          i_nist_data=egs_get_unit(i_nist_data)
          IF ((i_nist_data.LT.0)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'failed to get a free Fortran I/O unit for da
     *ta file ', tmp1_string(:lnblnk1(tmp1_string))
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(i_nist_data,file=tmp1_string,status='old',err=9510)
        ELSE
          i_nist_data = itmp
        END IF
      ELSE IF((ibr_nist .EQ. 2)) THEN
        DO 14471 i=1,len(tmp1_string)
          tmp1_string(i:i) = ' '
14471   CONTINUE
14472   CONTINUE
        tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'nrc_brems.dat
     *a'
        inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
        IF (( .NOT.ex )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'EGSnrc data file ','nrc_brems.data',' does not
     * exist'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF (( .NOT.is_opened )) THEN
          i_nist_data=egs_get_unit(i_nist_data)
          IF ((i_nist_data.LT.0)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'failed to get a free Fortran I/O unit for da
     *ta file ', tmp1_string(:lnblnk1(tmp1_string))
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(i_nist_data,file=tmp1_string,status='old',err=9510)
        ELSE
          i_nist_data = itmp
        END IF
      ELSE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' init_nist_brems: unknown value of ibr_nist!
     *                  ibr_nist = ', ibr_nist
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      rewind(i_nist_data)
      read(i_nist_data,*)
      read(i_nist_data,*) nmix,kmix
      IF ((kmix .GT. 54)) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' init_nist_brems: to many k values in data file!
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF ((nmix .GT. 57)) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' init_nist_brems: to many T values in data file!
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      read(i_nist_data,*) (energy_array(n),n=1,nmix)
      DO 14481 n=1,nmix
        energy_array(n) = 1.0*energy_array(n)
14481 CONTINUE
14482 CONTINUE
      read(i_nist_data,*) (x_array(k),k=1,kmix)
      read(i_nist_data,*)
      DO 14491 i=1,100
        read(i_nist_data,*) ((cs_array(n,k,i),n=1,nmix),k=1,kmix)
14491 CONTINUE
14492 CONTINUE
      close(i_nist_data)
      DO 14501 k=1,kmix
        xi_array(k)=Log(1-x_array(k)+1e-6)
        IF (( fool_intel_optimizer )) THEN
          write(i_log,*) 'xi_array(k): ',xi_array(k)
        END IF
14501 CONTINUE
14502 CONTINUE
      ngauss = 64
      call gauss_legendre(0d0,1d0,x_gauss,w_gauss,ngauss)
      write(i_log,*) ' '
      IF ((ibr_nist .EQ. 1)) THEN
        write(i_log,*) 'Using NIST brems cross sections! '
      ELSE IF((ibr_nist .EQ. 2)) THEN
        write(i_log,*) 'Using NRC brems cross sections! '
      END IF
      write(i_log,*) ' '
      DO 14511 medium=1,nmed
        log_ap(medium) = log(ap(medium))
        write(i_log,*) ' Initializing brems data for medium ',medium,'..
     *.'
        emin = max(ae(medium) - rm, ap(medium))
        DO 14521 i=1,nmix
          IF((energy_array(i) .GE. emin))GO TO14522
14521   CONTINUE
14522   CONTINUE
        ifirst = i
        DO 14531 i=nmix,1,-1
          IF((energy_array(i) .LT. ue(medium) - rm))GO TO14532
14531   CONTINUE
14532   CONTINUE
        ilast = i+1
        IF (( ifirst .LT. 1 .OR. ilast .GT. nmix )) THEN
          write(i_log,*) ' init_nist_brems: data available only for '
          write(i_log,*) energy_array(1),' <= E <= ',energy_array(nmix)
          write(i_log,*) ' will use spline interpolations to get cross '
          write(i_log,*) ' sections beyond the available data but this m
     *ay'
          write(i_log,*) ' produce nonsense!'
          IF((ifirst .LT. 1))ifirst=1
          IF((ilast .GT. nmix))ilast = nmix
        END IF
        DO 14541 i=ifirst,ilast
          ii = i+1 - ifirst
          ee(ii) = energy_array(i)
          ele(ii) = log(ee(ii))
          sumA = 0
          DO 14551 j=1,NNE(medium)
            sumA = sumA + pz(medium,j)*wa(medium,j)
14551     CONTINUE
14552     CONTINUE
          sumA = sumA*amu
          DO 14561 k=1,kmix
            cs(ii,k) = 0
            DO 14571 j=1,NNE(medium)
              Z = zelem(medium,j)
              iz = int(Z+0.1)
              Z = Z*Z/sumA
              cs(ii,k) = cs(ii,k) + pz(medium,j)*Z*cs_array(i,k,iz)
14571       CONTINUE
14572       CONTINUE
            csx(k) = Log(cs(ii,k))
14561     CONTINUE
14562     CONTINUE
          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix)
          cse(ii) = 0
          aux = Log(ee(ii)/ap(medium))
          DO 14581 i_gauss=1,ngauss
            xi = log(1 - ap(medium)/ee(ii)*exp(x_gauss(i_gauss)*aux)+1e-
     *      6)
            res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix)
            cse(ii) = cse(ii) + w_gauss(i_gauss)*exp(res)
14581     CONTINUE
14582     CONTINUE
14541   CONTINUE
14542   CONTINUE
        nener = ilast - ifirst + 1
        call set_spline(ele,cse,afe,bfe,cfe,dfe,nener)
        neke = meke(medium)
        sigee = 1E-15
        sigep = 1E-15
        DO 14591 i=1,neke
          eil = (float(i) - eke0(medium))/eke1(medium)
          ei = exp(eil)
          leil = i
          beta2 = ei*(ei+2*rm)/(ei+rm)**2
          IF (( ei .LE. ap(medium) )) THEN
            sigb = 1e-30
          ELSE
            sigb = spline(eil,ele,afe,bfe,cfe,dfe,nener)
            sigb = sigb*log(ei/ap(medium))/beta2*rho(medium)
          END IF
          sigt=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
          ebr1=ebr11(Leil,MEDIUM)*eil+ebr10(Leil,MEDIUM)
          IF((sigt .LT. 0))sigt = 0
          IF((ebr1 .GT. 1))ebr1 = 1
          IF((ebr1 .LT. 0))ebr1 = 0
          IF (( i .GT. 1 )) THEN
            si_esig = si1_esig
            si_ebr1 = si1_ebr1
            si1_esig = sigt*(1 - ebr1) + sigb
            si1_ebr1 = sigb/si1_esig
            esig1(i-1,medium) = (si1_esig - si_esig)*eke1(medium)
            esig0(i-1,medium) = si1_esig - esig1(i-1,medium)*eil
            ebr11(i-1,medium) = (si1_ebr1 - si_ebr1)*eke1(medium)
            ebr10(i-1,medium) = si1_ebr1 - ebr11(i-1,medium)*eil
          ELSE
            si1_esig = sigt*(1 - ebr1) + sigb
            si1_ebr1 = sigb/si1_esig
          END IF
          sigt=psig1(Leil,MEDIUM)*eil+psig0(Leil,MEDIUM)
          ebr1=pbr11(Leil,MEDIUM)*eil+pbr10(Leil,MEDIUM)
          ebr2=pbr21(Leil,MEDIUM)*eil+pbr20(Leil,MEDIUM)
          IF((sigt .LT. 0))sigt = 0
          IF((ebr1 .GT. 1))ebr1 = 1
          IF((ebr1 .LT. 0))ebr1 = 0
          IF((ebr2 .GT. 1))ebr2 = 1
          IF((ebr2 .LT. 0))ebr2 = 0
          sig_bhabha = sigt*(ebr2 - ebr1)
          IF((sig_bhabha .LT. 0))sig_bhabha = 0
          IF (( i .GT. 1 )) THEN
            si_psig = si1_psig
            si_pbr1 = si1_pbr1
            si_pbr2 = si1_pbr2
            si1_psig = sigt*(1 - ebr1) + sigb
            si1_pbr1 = sigb/si1_psig
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig
            psig1(i-1,medium) = (si1_psig - si_psig)*eke1(medium)
            psig0(i-1,medium) = si1_psig - psig1(i-1,medium)*eil
            pbr11(i-1,medium) = (si1_pbr1 - si_pbr1)*eke1(medium)
            pbr10(i-1,medium) = si1_pbr1 - pbr11(i-1,medium)*eil
            pbr21(i-1,medium) = (si1_pbr2 - si_pbr2)*eke1(medium)
            pbr20(i-1,medium) = si1_pbr2 - pbr21(i-1,medium)*eil
          ELSE
            si1_psig = sigt*(1 - ebr1) + sigb
            si1_pbr1 = sigb/si1_psig
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig
          END IF
          ededx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
          sige = si1_esig/ededx
          IF((sige .GT. sigee))sigee = sige
          ededx=pdedx1(Leil,MEDIUM)*eil+pdedx0(Leil,MEDIUM)
          sige = si1_psig/ededx
          IF((sige .GT. sigep))sigep = sige
14591   CONTINUE
14592   CONTINUE
        esig1(neke,medium) = esig1(neke-1,medium)
        esig0(neke,medium) = esig0(neke-1,medium)
        ebr11(neke,medium) = ebr11(neke-1,medium)
        ebr10(neke,medium) = ebr10(neke-1,medium)
        psig1(neke,medium) = psig1(neke-1,medium)
        psig0(neke,medium) = psig0(neke-1,medium)
        pbr11(neke,medium) = pbr11(neke-1,medium)
        pbr10(neke,medium) = pbr10(neke-1,medium)
        pbr21(neke,medium) = pbr21(neke-1,medium)
        pbr20(neke,medium) = pbr20(neke-1,medium)
        write(i_log,*) ' Max. new cross sections per energy loss: ',sige
     *  e,sigep
        esig_e(medium) = sigee
        psig_e(medium) = sigep
        IF((sigee .GT. esige_max))esige_max = sigee
        IF((sigep .GT. psige_max))psige_max = sigep
        nb_emin(medium) = energy_array(ifirst)
        IF (( nb_emin(medium) .LE. ap(medium) )) THEN
          nb_emin(medium) = energy_array(ifirst+1)
        END IF
        nb_emax(medium) = energy_array(ilast)
        nb_lemin(medium) = log(nb_emin(medium))
        nb_lemax(medium) = log(nb_emax(medium))
        nb_dle(medium) = (nb_lemax(medium) - nb_lemin(medium))/(100-1)
        nb_dlei(medium) = 1/nb_dle(medium)
        eil = nb_lemin(medium) - nb_dle(medium)
        DO 14601 i=1,100
          eil = eil + nb_dle(medium)
          ei = exp(eil)
          DO 14611 ii=1,nener
            IF((ei .LT. ee(ii)))GO TO14612
14611     CONTINUE
14612     CONTINUE
          ii = ii-1
          IF((ii .LT. 1))ii = 1
          IF((ii .GT. nener-1))ii = nener-1
          ple = (eil - ele(ii))/(ele(ii+1)-ele(ii))
          qle = 1 - ple
          DO 14621 k=1,kmix
            csx(k) = log(qle*cs(ii,k) + ple*cs(ii+1,k))
14621     CONTINUE
14622     CONTINUE
          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix)
          x = ap(medium)/ei
          aux = -log(x)
          xi = log(1 - x+1e-6)
          res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix)
          nb_xdata(0,i,medium) = 0
          nb_fdata(0,i,medium) = exp(res)
          DO 14631 k=1,kmix
            IF((x_array(k) .GT. x))GO TO14632
14631     CONTINUE
14632     CONTINUE
          IF((k .GT. kmix))k = kmix
          ndat = 0
          DO 14641 j=k+1,kmix-1
            ndat = ndat+1
            nb_xdata(ndat,i,medium) = log(x_array(j)/x)/aux
            nb_fdata(ndat,i,medium) = exp(csx(j))
            IF (( fool_intel_optimizer )) THEN
              write(i_log,*) 'nb_xdata(ndat,i,medium): ', nb_xdata(ndat,
     *        i,medium)
            END IF
14641     CONTINUE
14642     CONTINUE
          ndat = ndat+1
          nb_xdata(ndat,i,medium) = 1
          nb_fdata(ndat,i,medium) = exp(csx(kmix))
          IF((ndat .GE. 50))goto 14650
14661     CONTINUE
            x_max_error = 0
            f_max_error = 0
            k_max_error = 0
            max_error = 0
            DO 14671 k=0,ndat-1
              x = 0.5*(nb_xdata(k,i,medium) + nb_xdata(k+1,i,medium))
              f = 0.5*(nb_fdata(k,i,medium) + nb_fdata(k+1,i,medium))
              xi = log(1 - ap(medium)/ei*exp(x*aux)+1e-6)
              res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix)
              res = exp(res)
              error = abs(1-f/res)
              IF (( error .GT. max_error )) THEN
                x_max_error = x
                f_max_error = res
                max_error = error
                k_max_error = k
              END IF
14671       CONTINUE
14672       CONTINUE
            ndat = ndat+1
            DO 14681 k=ndat,k_max_error+2,-1
              nb_xdata(k,i,medium) = nb_xdata(k-1,i,medium)
              nb_fdata(k,i,medium) = nb_fdata(k-1,i,medium)
14681       CONTINUE
14682       CONTINUE
            nb_xdata(k_max_error+1,i,medium) = x_max_error
            nb_fdata(k_max_error+1,i,medium) = f_max_error
            IF(((ndat .EQ. 50)))GO TO14662
          GO TO 14661
14662     CONTINUE
14650     call prepare_alias_table(50,nb_xdata(0,i,medium), nb_fdata(0,i
     *    ,medium),nb_wdata(1,i,medium),nb_idata(1,i,medium))
14601   CONTINUE
14602   CONTINUE
14511 CONTINUE
14512 CONTINUE
      write(i_log,*) ' '
      write(i_log,*) ' '
      return
9510  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open EGSnrc data file ',tmp1_string(:lnb
     *lnk1(tmp1_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine init_nrc_pair
      implicit none
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      common/nrc_pair/ nrcp_fdata(65,84,10), nrcp_wdata(65,84,10), nrcp_
     *idata(65,84,10), nrcp_xdata(65), nrcp_emin, nrcp_emax, nrcp_dle, n
     *rcp_dlei
      real*8 nrcp_fdata,nrcp_wdata,nrcp_xdata, nrcp_emin, nrcp_emax, nrc
     *p_dle, nrcp_dlei
      integer*4 nrcp_idata
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character nrcp_file*256, endianess*4
      integer egs_get_unit
      integer*4 nrcp_unit, want_nrcp_unit, rec_length
      integer*4 i, lnblnk1
      real*8 tmp, ddx, xx, Z
      real*4 emin, emax
      integer*4 ne, nb, ix, ie, irec, i_ele, nbb, iz
      character endian, cdum( 243)
      logical swap
      real*4 tmp_4, tarray(65)
      integer*4 itmp_4
      character c_4(4), ic_4(4)
      equivalence (tmp_4,c_4), (itmp_4, ic_4)
      DO 14691 i=1,len(nrcp_file)
        nrcp_file(i:i) = ' '
14691 CONTINUE
14692 CONTINUE
      nrcp_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'pa
     *ir_nrc1.data'
      want_nrcp_unit = 62
      nrcp_unit = egs_get_unit(want_nrcp_unit)
      IF (( nrcp_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'init_nrc_pair: failed to get a free fortran unit
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      rec_length = 65*4
      open(nrcp_unit,file=nrcp_file,form='unformatted',access='direct',
     *status='old',recl=rec_length,err=14700)
      read(nrcp_unit,rec=1,err=14710) emin, emax, ne, nb, endian, cdum
      IF (( ichar(endian) .EQ. 0 )) THEN
        endianess = '1234'
      ELSE
        endianess = '4321'
      END IF
      swap = endianess.ne.'1234'
      IF (( swap )) THEN
        tmp_4 = emin
        call egs_swap_4(c_4)
        emin = tmp_4
        tmp_4 = emax
        call egs_swap_4(c_4)
        emax = tmp_4
        itmp_4 = ne
        call egs_swap_4(ic_4)
        ne = itmp_4
        itmp_4 = nb
        call egs_swap_4(ic_4)
        nb = itmp_4
      END IF
      write(i_log,'(//a,a)') 'Reading NRC pair data base from ',nrcp_fil
     *e(:lnblnk1(nrcp_file))
      write(i_log,'(a,a,a)') 'Data generated on a machine with ',endiane
     *ss,' endianess'
      write(i_log,'(a,a)') 'The endianess of this CPU is ','1234'
      IF (( swap )) THEN
        write(i_log,'(a)') '=> will need to do byte swaping'
      END IF
      write(i_log,'(a,2f9.3)') 'Energy range of the data: ',emin,emax
      IF (( nb .NE. 65 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Inconsistent x-grid size'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( ne .NE. 84 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Inconsistent energy grid size'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      nrcp_emin = emin
      nrcp_emax = emax
      nrcp_dle = log((emax-2)/(emin-2))/(ne-1)
      nrcp_dlei = 1/nrcp_dle
      nbb = nb/2
      ddx = sqrt(0.5)/nbb
      DO 14721 ix=0,nbb
        xx = ddx*ix
        nrcp_xdata(ix+1) = xx*xx
14721 CONTINUE
14722 CONTINUE
      do ix=nbb-1,0,-1
        xx = ddx*ix
        nrcp_xdata(nb-ix) = 1 - xx*xx
      end do
      DO 14741 medium=1,NMED
        write(i_log,'(a,i4,a,$)') '  medium ',medium,' .................
     *.... '
        DO 14751 ie=1,84
          DO 14761 ix=1,65
            nrcp_fdata(ix,ie,medium) = 0
14761     CONTINUE
14762     CONTINUE
14751   CONTINUE
14752   CONTINUE
        DO 14771 i_ele=1,NNE(medium)
          Z = ZELEM(medium,i_ele)
          iz = int(Z+0.5)
          tmp = PZ(medium,i_ele)*Z*Z
          irec = (iz-1)*ne + 2
          DO 14781 ie=1,84
            read(nrcp_unit,rec=irec,err=14710) tarray
            DO 14791 ix=1,65
              tmp_4 = tarray(ix)
              IF (( swap )) THEN
                call egs_swap_4(c_4)
              END IF
              nrcp_fdata(ix,ie,medium)=nrcp_fdata(ix,ie,medium)+tmp*tmp_
     *        4
14791       CONTINUE
14792       CONTINUE
            irec = irec + 1
14781     CONTINUE
14782     CONTINUE
14771   CONTINUE
14772   CONTINUE
        DO 14801 ie=1,84
          call prepare_alias_table(nb-1,nrcp_xdata,nrcp_fdata(1,ie,mediu
     *    m), nrcp_wdata(1,ie,medium),nrcp_idata(1,ie,medium))
14801   CONTINUE
14802   CONTINUE
        write(i_log,'(a)') ' done'
14741 CONTINUE
14742 CONTINUE
      write(i_log,*) ' '
      close(nrcp_unit)
      return
14700 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Failed to open NRC pair data file'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
14710 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'I/O error while reading NRC pair data file'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      subroutine vmc_electron(ircode)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 ircode
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(//a//)') ' ********* VMC Transport option not in thi
     *s distribution ****** '
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      subroutine egs_init_default_rng
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      ixx=0
      jxx=0
      call init_ranmar
      return
      end
      subroutine egs_init_rng(arg1,arg2)
      integer*4 arg1,arg2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      ixx = arg1
      jxx = arg2
      call init_ranmar
      return
      end
      subroutine egs_get_rndm(ran)
      real*8 ran
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      IF((rng_seed .GT. 128))call ranmar_get
      ran = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      return
      end
      subroutine egs_get_rndm_array(n,rarray)
      integer*4 n
      real*8 rarray(*)
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      real*8 rtmp
      integer*4 i
      IF((n .LT. 1))return
      DO 14811 i=1,n
        IF((rng_seed .GT. 128))call ranmar_get
        rtmp = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        rarray(i) = rtmp
14811 CONTINUE
14812 CONTINUE
      return
      end
      subroutine eii_init
      implicit none
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(10), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),
     *eii_sh(40),  eii_nshells(100),  eii_nsh(10),  eii_first(10,50),  e
     *ii_no(10,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      COMMON/ELECIN/ esig_e(10),psig_e(10), esige_max, psige_max, range_
     *ep(0:1,500,10), E_array(500,10), etae_ms0(500,10),etae_ms1(500,10)
     *,etap_ms0(500,10),etap_ms1(500,10),q1ce_ms0(500,10),q1ce_ms1(500,1
     *0),q1cp_ms0(500,10),q1cp_ms1(500,10),q2ce_ms0(500,10),q2ce_ms1(500
     *,10),q2cp_ms0(500,10),q2cp_ms1(500,10),blcce0(500,10),blcce1(500,1
     *0), EKE0(10),EKE1(10), XR0(10),TEFF0(10),BLCC(10),XCC(10), ESIG0(5
     *00,10),ESIG1(500,10),PSIG0(500,10),PSIG1(500,10),EDEDX0(500,10),ED
     *EDX1(500,10),PDEDX0(500,10),PDEDX1(500,10),EBR10(500,10),EBR11(500
     *,10),PBR10(500,10),PBR11(500,10),PBR20(500,10),PBR21(500,10),TMXS0
     *(500,10),TMXS1(500,10), expeke1(10), IUNRST(10),EPSTFL(10),IAPRIM(
     *10), sig_ismonotone(0:1,10)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      integer*4 imed,iele,ish,nsh,iZ,j,i,itmp,nskip,nbin,ii,nsh_tot,iii,
     *k
      integer*4 jj,jjj
      integer*4 lnblnk1
      integer*4 tmp_array(100)
      integer*4 want_eii_unit,eii_unit,eii_out,egs_open_file
      integer egs_get_unit
      real*8 e_eii_min,emax,fmax,aux_array(250)
      real*8 sigo,loge,tau,beta2,p2,uwm,Wmax
      real*8 ss_0, ss_1, sh_0, sh_1, aux, av_e, con_med, dedx_old, sigm_
     *old
      real*8 dedx,e,sig,sigm,wbrem,sum_a,sum_z,sum_pz,sum_wa,Ec,Ecc
      real*8 sum_sh,sum_occn,U,sum_sigma,sum_dedx
      real*8 sigma,sigma_old,wbrem_old,sig_j,de
      integer*4 lloge
      logical check_it,is_monotone,getd
      real*8 sigma_max
      character eii_file*128
      character*512 toUpper
      integer*4 occn_numbers(4)
      real*8 cons
      parameter (cons = 0.153536)
      data occn_numbers/2,2,2,4/
      DO 14821 j=1,100
        eii_nshells(j) = 0
14821 CONTINUE
14822 CONTINUE
      DO 14831 j=1,10
        eii_nsh(j) = 0
14831 CONTINUE
14832 CONTINUE
      IF (( eii_flag .EQ. 0 )) THEN
        return
      END IF
      getd = .false.
      DO 14841 j=1, 12001
        IF (( iedgfl(j) .GT. 0 .AND. iedgfl(j) .LE. 100 )) THEN
          getd = .true.
          GO TO14842
        END IF
14841 CONTINUE
14842 CONTINUE
      IF (( .NOT.getd )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(/a,/a,/a,/a)') ' In subroutine eii_init: ', '   Sc
     *attering off bound electrons creates atomic vacancies,', '   poten
     *tially starting an atomic relaxation cascade. ', '   Please turn O
     *N atomic relaxations.'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      e_eii_min = 1e30
      DO 14851 imed=1,nmed
        IF((ae(imed)-rm .LT. e_eii_min))e_eii_min = ae(imed) - rm
        IF((ap(imed) .LT. e_eii_min))e_eii_min = ap(imed)
14851 CONTINUE
14852 CONTINUE
      write(i_log,*) ' '
      write(i_log,*) 'eii_init: minimum threshold energy found: ',e_eii_
     *min
      DO 14861 imed=1,nmed
        DO 14871 iele=1,nne(imed)
          iZ = int(zelem(imed,iele)+0.5)
          IF (( eii_nshells(iZ) .EQ. 0 )) THEN
            nsh = 0
            DO 14881 ish=1,4
              IF((binding_energies(ish,iZ) .GT. e_eii_min))nsh = nsh+1
14881       CONTINUE
14882       CONTINUE
            eii_nshells(iZ) = nsh
          END IF
14871   CONTINUE
14872   CONTINUE
14861 CONTINUE
14862 CONTINUE
      nsh = 0
      DO 14891 iZ=1,100
        nsh = nsh + eii_nshells(iZ)
14891 CONTINUE
14892 CONTINUE
      IF (( nsh .EQ. 0 )) THEN
        write(i_log,*) '*** EII requested but no shells with binding ene
     *rgies '
        write(i_log,*) '    above the specified threshold found'
        write(i_log,*) '    => turning off EII'
        eii_flag = 0
      END IF
      IF (( nsh .GT. 40 )) THEN
        write(i_log,*) '*** Number of shells with binding energies great
     *er than '
        write(i_log,*) '    the specified thresholds is ',nsh
        write(i_log,*) '    This is more than the allocated arrays can h
     *old'
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) '    Increase the macro $MAX_EII_SHELLS and retry
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      write(i_log,*) 'eii_init: number of shells to simulate EII: ',nsh
      nsh_tot = nsh
      tmp_array(1) = 0
      DO 14901 j=2,100
        tmp_array(j) = tmp_array(j-1) + eii_nshells(j-1)
14901 CONTINUE
14902 CONTINUE
      DO 14911 imed=1,nmed
        nsh = 0
        DO 14921 iele=1,nne(imed)
          iZ = int(zelem(imed,iele)+0.5)
          eii_no(imed,iele) = eii_nshells(iZ)
          nsh = nsh + eii_nshells(iZ)
          IF (( eii_nshells(iZ) .GT. 0 )) THEN
            eii_first(imed,iele) = tmp_array(iZ) + 1
          ELSE
            eii_first(imed,iele) = 0
          END IF
14921   CONTINUE
14922   CONTINUE
        eii_nsh(imed) = nsh
14911 CONTINUE
14912 CONTINUE
      DO 14931 i=1,len(eii_file)
        eii_file(i:i) = ' '
14931 CONTINUE
14932 CONTINUE
      eii_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'eii
     *_'// eii_xfile(:lnblnk1(eii_xfile)) //'.data'
      want_eii_unit = 62
      eii_unit = egs_get_unit(want_eii_unit)
      IF (( eii_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'eii_init: failed to get a free Fortran I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(eii_unit,file=eii_file(:lnblnk1(eii_file)),status='old',err=1
     *4940)
      write(i_log,'(//a,a)') 'Opened EII data file ',eii_file(:lnblnk1(e
     *ii_file))
      write(i_log,'(a,$)') ' eii_init: reading EII data ... '
      read(eii_unit,*,err=14950,end=14950) nskip
      DO 14961 j=1,nskip
        read(eii_unit,*,err=14950,end=14950)
14961 CONTINUE
14962 CONTINUE
      read(eii_unit,*,err=14950,end=14950) emax,nbin
      IF (( nbin .NE. 250 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Inconsistent EII data file'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF ((xsec_out .EQ. 1)) THEN
        eii_out = egs_open_file(93,0,1,'.eiixsec')
      END IF
      ii = 0
      DO 14971 j=1,100
        read(eii_unit,*,err=14950,end=14950) iZ,nsh
        IF ((xsec_out .EQ. 1 .AND. eii_nshells(iZ) .GT. 0)) THEN
          write(eii_out,*) '================================='
          write(eii_out,'(a,i3)') 'EII xsections for element Z = ',iZ
          write(eii_out,*) '================================='
        END IF
        IF (( nsh .LT. eii_nshells(iZ) )) THEN
          write(i_log,*) 'EII data file has data for ',nsh,' shells for
     *element '
          write(i_log,*) iZ,' but according'
          write(i_log,*) 'to binding energies and thresholds ',eii_nshel
     *    ls(iZ)
          write(i_log,*) 'shells are required'
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'This is a fatal error.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        DO 14981 ish=1,nsh
          read(eii_unit,*,err=14950,end=14950) fmax
          read(eii_unit,*,err=14950,end=14950) aux_array
          IF ((ish.GT.1 .AND. ish .LT. 5)) THEN
            fmax = fmax*eii_L_factor
          END IF
          IF (( ish .LE. eii_nshells(iZ) )) THEN
            IF ((xsec_out .EQ. 1)) THEN
              IF ((ish .EQ. 1)) THEN
                write(eii_out,'(a,f10.2,a)') 'K-shell sigma_max = ',fmax
     *          ,' b/atom'
              ELSE IF((ish .EQ. 2)) THEN
                write(eii_out,'(a,f9.2,a)') '=> LI-shell sigma_max = ',f
     *          max,' b/atom'
              ELSE IF((ish .EQ. 3)) THEN
                write(eii_out,'(a,f8.2,a)') '=> LII-shell sigma_max = ',
     *          fmax,' b/atom'
              ELSE IF((ish .EQ. 4)) THEN
                write(eii_out,'(a,f8.2,a)') '=> LIII-shell sigma_max = '
     *          ,fmax,' b/atom'
              ELSE
                write(eii_out,*) '=> Wrong number of shells!'
              END IF
              write(eii_out,*) '   E/keV     sigma/(b/atom)'
              write(eii_out,*) '---------------------------'
            END IF
            ii = ii+1
            eii_z(ii) = iZ
            eii_sh(ii) = ish
            eii_a(ii) = nbin
            eii_a(ii) = eii_a(ii)/log(emax/binding_energies(ish,iZ))
            eii_b(ii) = 1 - eii_a(ii)*log(binding_energies(ish,iZ))
            DO 14991 k=1,nbin
              IF (( k .GT. 1 )) THEN
                sigo = fmax*aux_array(k-1)
              ELSE
                sigo = 0
              END IF
              loge = (k - eii_b(ii))/eii_a(ii)
              iii = nbin*(ii-1)+k
              eii_xsection_a(iii) = (fmax*aux_array(k)-sigo)*eii_a(ii)
              eii_xsection_b(iii) = sigo - eii_xsection_a(iii)*loge
              IF ((xsec_out .EQ. 1)) THEN
                write(eii_out,'(f12.2,2X,10f9.2)') Exp((k+1-eii_b(ii))/e
     *          ii_a(ii))*1000.0,fmax*aux_array(k)
              END IF
14991       CONTINUE
14992       CONTINUE
          END IF
14981   CONTINUE
14982   CONTINUE
        IF (( ii .EQ. nsh_tot )) THEN
          GO TO14972
        END IF
14971 CONTINUE
14972 CONTINUE
      close(eii_unit)
      IF ((xsec_out .EQ. 1)) THEN
        close(eii_out)
      END IF
      write(i_log,*) ' OK '
      write(i_log,*) ' '
      DO 15001 imed=1,nmed
        Ec = ae(imed) - rm
        Ecc = min(Ec,ap(imed))
        sum_z=0
        sum_pz=0
        sum_a=0
        sum_wa=0
        DO 15011 iele=1,nne(imed)
          sum_z = sum_z + pz(imed,iele)*zelem(imed,iele)
          sum_pz = sum_pz + pz(imed,iele)
          sum_wa = sum_wa + rhoz(imed,iele)
          sum_a = sum_a + pz(imed,iele)*wa(imed,iele)
15011   CONTINUE
15012   CONTINUE
        con_med = rho(imed)/1.6605655/sum_a
        eii_cons(imed) = con_med
        IF (( eii_nsh(imed) .GT. 0 )) THEN
          is_monotone = .true.
          sigma_max = 0
          DO 15021 j=1,meke(imed)
            loge = (j - eke0(imed))/eke1(imed)
            e = Exp(loge)
            tau = e/rm
            beta2 = tau*(tau+2)/(tau+1)**2
            p2 = 2*rm*tau*(tau+2)
            lloge = j
            medium = imed
            dedx=ededx1(Lloge,MEDIUM)*loge+ededx0(Lloge,MEDIUM)
            IF (( e .GT. ap(medium) .OR. e .GT. 2*Ec )) THEN
              sig=esig1(Lloge,MEDIUM)*loge+esig0(Lloge,MEDIUM)
            ELSE
              sig = 0
            END IF
            IF (( e .GT. 2*Ec )) THEN
              wbrem=ebr11(Lloge,MEDIUM)*loge+ebr10(Lloge,MEDIUM)
              sigm = sig*(1-wbrem)
            ELSE
              sigm = 0
              wbrem = 1
            END IF
            sum_occn=0
            sum_sigma=0
            sum_dedx=0
            DO 15031 iele=1,nne(imed)
              iZ = int(zelem(imed,iele)+0.5)
              sum_sh = 0
              DO 15041 ish=1,eii_no(imed,iele)
                jj = eii_first(imed,iele) + ish - 1
                jjj = eii_sh(jj)
                U = binding_energies(jjj,iZ)
                Wmax = (e+U)/2
                uwm = U/Wmax
                IF (( U .LT. e .AND. U .GT. Ecc )) THEN
                  sum_sh = sum_sh + occn_numbers(jjj)
                  ss_0 = 2*(log(p2/U)-uwm**3*log(p2/Wmax)- (beta2+0.8333
     *            33)*(1-uwm**3))/3/U
                  sh_0 = ((1-uwm)*(1+uwm/(2-uwm))+U*(Wmax-U)/(e+rm)**2 -
     *             (2*tau+1)/(tau+1)**2*uwm/2*log((2-uwm)/uwm))/U
                  ss_1 = log(p2/U)-uwm**2*log(p2/Wmax)- (beta2+1)*(1-uwm
     *            **2)
                  sh_1 = log(Wmax/U/(2-uwm))+2*(Wmax-U)/(2*Wmax-U) +(Wma
     *            x**2-U**2)/(e+rm)**2/2 -(2*tau+1)/(tau+1)**2*log((2*Wm
     *            ax-U)/Wmax)
                  av_E = (ss_1 + sh_1)/(ss_0 + sh_0)
                  i = eii_a(jjj)*loge + eii_b(jjj)
                  i = (jj-1)*250 + i
                  sig_j = eii_xsection_a(i)*loge + eii_xsection_b(i)
                  sig_j = sig_j*pz(imed,iele)*con_med
                  sum_sigma = sum_sigma + sig_j
                  sum_dedx = sum_dedx + sig_j*av_E
                END IF
15041         CONTINUE
15042         CONTINUE
              sum_occn = sum_occn + sum_sh*pz(imed,iele)
15031       CONTINUE
15032       CONTINUE
            sigm = sigm + sum_sigma
            dedx = dedx - sum_dedx
            aux = Ec/e
            IF (( e .GT. 2*Ec )) THEN
              sigo = cons*sum_occn*rho(imed)/(beta2*Ec)*( (1-2*aux)*(1+a
     *        ux/(1-aux)+(tau/(tau+1))**2*aux/2)- (2*tau+1)/(tau+1)**2*a
     *        ux*log((1-aux)/aux))/sum_a
              de = cons*sum_occn*rho(imed)/beta2*( log(0.25/aux/(1-aux))
     *        +(1-2*aux)/(1-aux)+ (tau/(tau+1))**2*(1-4*aux*aux)/8- (2*t
     *        au+1)/(tau+1)**2*log(2*(1-aux)))/sum_a
              sigm = sigm - sigo
              dedx = dedx + de
            END IF
            sigma = sigm + wbrem*sig
            IF((sigma/dedx .GT. sigma_max))sigma_max = sigma/dedx
            IF (( sigma .GT. 0 )) THEN
              wbrem = wbrem*sig/sigma
            ELSE
              wbrem = 1
            END IF
            IF (( j .GT. 1 )) THEN
              ededx1(j-1,imed) = (dedx - dedx_old)*eke1(imed)
              ededx0(j-1,imed) = dedx - ededx1(j-1,imed)*loge
              esig1(j-1,imed) = (sigma - sigma_old)*eke1(imed)
              esig0(j-1,imed) = sigma - esig1(j-1,imed)*loge
              ebr11(j-1,imed) = (wbrem - wbrem_old)*eke1(imed)
              ebr10(j-1,imed) = wbrem - ebr11(j-1,imed)*loge
              IF((sigma/dedx .LT. sigma_old/dedx_old))is_monotone = .fal
     *        se.
            END IF
            dedx_old = dedx
            sigm_old = sigm
            sigma_old = sigma
            wbrem_old = wbrem
15021     CONTINUE
15022     CONTINUE
          ededx1(meke(imed),imed) = ededx1(meke(imed)-1,imed)
          ededx0(meke(imed),imed) = ededx0(meke(imed)-1,imed)
          esig1(meke(imed),imed) = esig1(meke(imed)-1,imed)
          esig0(meke(imed),imed) = esig0(meke(imed)-1,imed)
          ebr11(meke(imed),imed) = ebr11(meke(imed)-1,imed)
          ebr10(meke(imed),imed) = ebr10(meke(imed)-1,imed)
          write(i_log,*) 'eii_init: for medium ',imed,' adjusted sige =
     *', sigma_max,' monotone = ',is_monotone
          sig_ismonotone(0,imed) = is_monotone
          esig_e(imed) = sigma_max
        END IF
15001 CONTINUE
15002 CONTINUE
      return
14950 write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'I/O error while reading EII data'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
14940 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(//a,a,/a,/a/)') 'Failed to open EII data file ',eii_
     *file(:lnblnk1(eii_file)), 'Make sure file exists in your $HEN_HOUS
     *E/data directory!', '****BEWARE of case sensitive file names!!!'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine eii_sample(ish,iZ,Uj)
      implicit none
      integer*4 ish,iZ
      real*8 Uj
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(10), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),
     *eii_sh(40),  eii_nshells(100),  eii_nsh(10),  eii_first(10,50),  e
     *ii_no(10,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      common/egs_vr/ e_max_rr( 12001),  prob_RR,  nbr_split,  i_play_RR,
     *      i_survived_RR,
     *          n_RR_warning,                                        i_d
     *o_rr( 12001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      real*8 T,tau,tau1,tau12,tau2,p2,beta2,c1,c2,Wmax,xmax,fm_s,fm_h,pr
     *ob_s,prob
      real*8 r1,r2,r3,wx,wxx,aux,frej
      real*8 peie,pese1,pese2,dcosth,h1
      integer*4 iarg
      real*8 eta,cphi,sphi
      integer*4 np_save,ip,j
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      peie = e(np)
      T = peie - rm
      tau = T/rm
      tau1 = tau+1
      tau12 = tau1*tau1
      tau2 = tau*tau
      p2 = tau2 + 2*tau
      beta2 = p2/tau12
      Wmax = 0.5*(T+Uj)
      xmax = Uj/Wmax
      c1 = (Wmax/peie)**2
      c2 = (2*tau+1)/tau12
      fm_s = log(rmt2*p2/Uj) - beta2 - 0.5
      prob_s = 0.66666667*fm_s*(1+xmax+xmax*xmax)
      fm_h = 2 + c1 - c2
      IF((fm_h .LT. 1))fm_h = 1
      prob = fm_h + prob_s
15051 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        r1 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((rng_seed .GT. 128))call ranmar_get
        r2 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((rng_seed .GT. 128))call ranmar_get
        r3 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( r1*prob .LT. fm_h )) THEN
          wx = 1/(r2*xmax+1-r2)
          wxx = wx*xmax
          aux = wxx/(2-wxx)
          frej = (1 + aux*(aux-c2)+c1*wxx*wxx)/fm_h
        ELSE
          wx = 1/(r2*xmax**3+1-r2)**0.333333333
          frej = 1 - log(wx)/fm_s
        END IF
        IF((( r3 .LT. frej )))GO TO15052
      GO TO 15051
15052 CONTINUE
      wx = wx*Uj
      h1 = (peie + prm)/T
      pese1 = peie - wx
      e(np) = pese1
      dcosth = h1*(pese1-prm)/(pese1+prm)
      sinthe = dsqrt(1-dcosth)
      costhe = dsqrt(dcosth)
      call uphi(2,1)
      pese2 = wx - Uj + prm
      edep_local = 0
      IF (( pese2 .GT. ae(medium) )) THEN
        IF (( np+1 .GT. 500 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','eii_sample
     *', ' stack size exceeded! ',' $MAXSTACK = ',500,' np = ',np+1
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        np = np+1
        e(np) = pese2
        dcosth = h1*(pese2-prm)/(pese2+prm)
        sinthe = -dsqrt(1-dcosth)
        costhe = dsqrt(dcosth)
        iq(np) = -1
        call uphi(3,2)
        edep = 0
      ELSE
        edep = wx - Uj
        edep_local = edep
        IARG=34
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
      END IF
      call relax(Uj,ish,iZ)
      IF (( edep .GT. 0 )) THEN
        IARG=4
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
      END IF
      return
      end
      subroutine egs_scale_photon_xsection(imed,fac,which)
      implicit none
      integer*4 imed,which
      real*8 fac
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(10), GE0(10),GE1(10), GMFP0(2000,10),GMFP1(2
     *000,10),GBR10(2000,10),GBR11(2000,10),GBR20(2000,10),GBR21(2000,10
     *), RCO0(10),RCO1(10), RSCT0(100,10),RSCT1(100,10), COHE0(2000,10),
     *COHE1(2000,10),  PHOTONUC0(2000,10),PHOTONUC1(2000,10), DPMFP, MPG
     *EM(1,10), NGR(10)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 ifirst,ilast,medium,j
      logical has_r
      real*8 gle,gmfp,gbr1,gbr2,cohfac,aux,gmfp_old,gbr1_old,gbr2_old,co
     *hfac_old
      character*8 strings(5)
      data strings/'photon','Rayleigh','Compton','pair','photo'/
      IF (( which .LT. 0 .OR. which .GT. 4 )) THEN
        return
      END IF
      IF (( imed .GT. 0 .AND. imed .LE. nmed )) THEN
        ifirst = imed
        ilast = imed
      ELSE
        ifirst = 1
        ilast = nmed
      END IF
      IF (( which .EQ. 1 )) THEN
        has_r = .false.
        DO 15061 medium=ifirst,ilast
          IF (( iraylm(medium) .EQ. 1 )) THEN
            has_r = .true.
          END IF
15061   CONTINUE
15062   CONTINUE
        IF((.NOT.has_r))return
      END IF
      write(i_log,*) ' '
      DO 15071 medium=ifirst,ilast
        write(i_log,'(a,a,a,i3,a,f9.5)') 'Scaling ',strings(which+1),' x
     *-section data for medium', medium,' with ',fac
        DO 15081 j=1,mge(medium)
          gle = (j - ge0(medium))/ge1(medium)
          gmfp = gmfp0(j,medium) + gmfp1(j,medium)*gle
          gbr1 = gbr10(j,medium) + gbr11(j,medium)*gle
          gbr2 = gbr20(j,medium) + gbr21(j,medium)*gle
          IF (( iraylm(medium) .EQ. 1 )) THEN
            cohfac = cohe0(j,medium) + cohe1(j,medium)*gle
          ELSE
            cohfac = 1
          END IF
          IF (( which .EQ. 0 )) THEN
            gmfp = gmfp/fac
          ELSE IF(( which .EQ. 1 )) THEN
            cohfac = cohfac/(fac*(1-cohfac)+cohfac)
          ELSE
            IF (( which .EQ. 2 )) THEN
              aux = fac*(gbr2-gbr1) + gbr1 + 1 - gbr2
              gbr2 = (gbr1 + fac*(gbr2-gbr1))/aux
              gbr1 = gbr1/aux
            ELSE IF(( which .EQ. 3 )) THEN
              aux = fac*gbr1 + 1 - gbr1
              gbr2 = (fac*gbr1 + gbr2-gbr1)/aux
              gbr1 = fac*gbr1/aux
            ELSE
              aux = gbr2 + fac*(1-gbr2)
              gbr1 = gbr1/aux
              gbr2 = gbr2/aux
            END IF
            gmfp = gmfp/aux
            cohfac = cohfac*aux/(aux*cohfac + 1 - cohfac)
          END IF
          IF (( j .GT. 1 )) THEN
            gmfp1(j-1,medium) = (gmfp - gmfp_old)*ge1(medium)
            gmfp0(j-1,medium) = gmfp - gmfp1(j-1,medium)*gle
            gbr11(j-1,medium) = (gbr1 - gbr1_old)*ge1(medium)
            gbr10(j-1,medium) = gbr1 - gbr11(j-1,medium)*gle
            gbr21(j-1,medium) = (gbr2 - gbr2_old)*ge1(medium)
            gbr20(j-1,medium) = gbr2 - gbr21(j-1,medium)*gle
            cohe1(j-1,medium) = (cohfac - cohfac_old)*ge1(medium)
            cohe0(j-1,medium) = cohfac - cohe1(j-1,medium)*gle
          END IF
          gmfp_old = gmfp
          gbr1_old = gbr1
          gbr2_old = gbr2
          cohfac_old = cohfac
15081   CONTINUE
15082   CONTINUE
        gmfp1(mge(medium),medium) = gmfp1(mge(medium)-1,medium)
        gmfp0(mge(medium),medium) = gmfp0(mge(medium)-1,medium)
        gbr11(mge(medium),medium) = gbr11(mge(medium)-1,medium)
        gbr10(mge(medium),medium) = gbr10(mge(medium)-1,medium)
        gbr21(mge(medium),medium) = gbr21(mge(medium)-1,medium)
        gbr20(mge(medium),medium) = gbr20(mge(medium)-1,medium)
        cohe1(mge(medium),medium) = cohe1(mge(medium)-1,medium)
        cohe0(mge(medium),medium) = cohe0(mge(medium)-1,medium)
15071 CONTINUE
15072 CONTINUE
      return
      end
      subroutine egs_init_user_photon(prefix,comp_prefix,photonuc_prefix
     *,out)
      implicit none
      character*(*) prefix, comp_prefix,  photonuc_prefix
      integer*4 out
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 12001),IPHTER( 12001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(10), GE0(10),GE1(10), GMFP0(2000,10),GMFP1(2
     *000,10),GBR10(2000,10),GBR11(2000,10),GBR20(2000,10),GBR21(2000,10
     *), RCO0(10),RCO1(10), RSCT0(100,10),RSCT1(100,10), COHE0(2000,10),
     *COHE1(2000,10),  PHOTONUC0(2000,10),PHOTONUC1(2000,10), DPMFP, MPG
     *EM(1,10), NGR(10)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,10), eno_array(200,10), eno_atbin_array(200,10), n
     *_shell(10), radc_flag,  ibcmp( 12001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      integer*4 lnblnk1,egs_get_unit,medium, photo_unit,pair_unit,raylei
     *gh_unit,triplet_unit, ounit,egs_open_file,compton_unit,  photonuc_
     *unit
      integer*4 nge,sorted(50),i,j,k,iz,iz_old,ndat
      real*8 z_sorted(50),pz_sorted(50)
      real*8 sig_photo(2000),sig_pair(2000),sig_triplet(2000), sig_rayle
     *igh(2000),sig_compton(2000)
      real*8 sigma,cohe,gmfp,gbr1,gbr2,sig_KN,gle,e,sig_p
      real*8 cohe_old,gmfp_old,gbr1_old,gbr2_old,  sig_photonuc(2000), p
     *hotonuc, photonuc_old
      real*8 etmp(2000),ftmp(2000)
      real*8 sumZ,sumA,con1,con2,egs_KN_sigma0
      real*8 bc_emin,bc_emax,bc_dle,bc_data(183),bc_tmp(183),bcf,aj
      integer*4 bc_ne
      logical input_compton_data,  input_photonuc_data
      character data_dir*128,photo_file*140,pair_file*140,rayleigh_file*
     *144, triplet_file*142,tmp_string*144,compton_file*144,  photonuc_f
     *ile*144
      write(i_log,'(/a$)') '(Re)-initializing photon cross sections'
      write(i_log,'(a,a/)') ' with files from the series: ', prefix(:lnb
     *lnk1(prefix))
      write(i_log,'(a,a)') ' Compton cross sections: ',comp_prefix(:lnbl
     *nk1(comp_prefix))
      IF ((iphotonuc .EQ. 1)) THEN
        write(i_log,'(a,a)') ' Photonuclear cross sections: ', photonuc_
     *  prefix(:lnblnk1(photonuc_prefix))
        input_photonuc_data = .false.
        IF ((lnblnk1(photonuc_prefix) .GT. 0 .AND. photonuc_prefix(1:7)
     *  .NE. 'default')) THEN
          input_photonuc_data = .true.
        END IF
      END IF
      input_compton_data = .false.
      IF (( ibcmp(1) .GT. 1 .AND. lnblnk1(comp_prefix) .GT. 0 )) THEN
        IF((comp_prefix(1:7) .NE. 'default'))input_compton_data = .true.
      END IF
      data_dir = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      photo_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(prefi
     *x)) // '_photo.data'
      pair_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(prefix
     *)) // '_pair.data'
      triplet_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(pre
     *fix)) // '_triplet.data'
      rayleigh_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(pr
     *efix)) // '_rayleigh.data'
      IF (( input_compton_data )) THEN
        compton_file = data_dir(:lnblnk1(data_dir)) // comp_prefix(:lnbl
     *  nk1(comp_prefix)) // '_compton.data'
      ELSE
        compton_file = data_dir(:lnblnk1(data_dir)) // 'compton_sigma.da
     *ta'
      END IF
      write(i_log,'(a,a)') ' Using Compton cross sections from ', compto
     *n_file(:lnblnk1(compton_file))
      IF ((iphotonuc .EQ. 1)) THEN
        IF (( input_photonuc_data )) THEN
          photonuc_file = data_dir(:lnblnk1(data_dir)) // photonuc_prefi
     *    x(:lnblnk1(photonuc_prefix)) // '_photonuc.data'
        ELSE
          photonuc_file = data_dir(:lnblnk1(data_dir)) // 'iaea_photonuc
     *.data'
        END IF
        write(i_log,'(a,a)') ' Using photonuclear cross sections from ',
     *   photonuc_file(:lnblnk1(photonuc_file))
      END IF
      photo_unit = 83
      photo_unit = egs_get_unit(photo_unit)
      IF (( photo_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = photo_file
      open(photo_unit,file=photo_file,status='old',err=15090)
      pair_unit = 84
      pair_unit = egs_get_unit(pair_unit)
      IF (( pair_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = pair_file
      open(pair_unit,file=pair_file,status='old',err=15090)
      triplet_unit = 85
      triplet_unit = egs_get_unit(triplet_unit)
      IF (( triplet_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = triplet_file
      open(triplet_unit,file=triplet_file,status='old',err=15090)
      rayleigh_unit = 86
      rayleigh_unit = egs_get_unit(rayleigh_unit)
      IF (( rayleigh_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = rayleigh_file
      open(rayleigh_unit,file=rayleigh_file,status='old',err=15090)
      IF (( ibcmp(1) .GT. 1 )) THEN
        compton_unit = 88
        compton_unit = egs_get_unit(compton_unit)
        IF (( compton_unit .LT. 1 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'egs_init_user_photon: failed to get a free For
     *tran I/O unit'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        tmp_string = compton_file
        open(compton_unit,file=compton_file,status='old',err=15090)
      END IF
      IF (( iphotonuc .EQ. 1 )) THEN
        photonuc_unit = 89
        photonuc_unit = egs_get_unit(photonuc_unit)
        IF (( photonuc_unit .LT. 1 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'egs_init_user_photon: failed to get a free For
     *tran I/O unit'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        tmp_string = photonuc_file
        open(photonuc_unit,file=photonuc_file,status='old',err=15090)
      END IF
      IF (( out .EQ. 1 )) THEN
        ounit = egs_open_file(87,0,1,'.xsections')
        write(ounit,'(/a,a,a)') 'Photon cross sections initialized from
     *', prefix(:lnblnk1(prefix)),' data files'
        write(ounit,'(a,/)') '==========================================
     *=================================='
        write(ounit,'(a,/)') 'Grid energies and cross sections are outpu
     *t'
        IF ((iphotonuc .EQ. 1)) THEN
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a)') 'Energy','
     * GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ', ' GMFP(cm) '
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a/)') '(MeV)','
     *no Rayleigh','(fraction)','(fraction)','with Rayleigh', 'w/ Ray +
     *photnuc'
        ELSE
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a)') 'Energy',' GMFP(
     *cm) ',' Pair ','Compton',' GMFP(cm) '
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a/)') '(MeV)','no Ray
     *leigh','(fraction)','(fraction)','with Rayleigh'
        END IF
      END IF
      DO 15101 iz=1,100
        read(photo_unit,*) ndat
        read(photo_unit,*) (etmp(k),ftmp(k),k=1,ndat)
        k = 0
        DO 15111 j=ndat,2,-1
          IF (( etmp(j)-etmp(j-1) .LT. 1e-5 )) THEN
            k = k+1
            IF (( k .LE. 30 )) THEN
              binding_energies(k,iz) = exp(etmp(j))
            ELSE
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,'(i3,a,i3,//a)') k,' binding energies read exc
     *eeding array size of', 30,'Increase $MXSHXSEC in egsnrc.macros!'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            IF((.NOT.eadl_relax .AND. k .GE. 4))GO TO15112
          END IF
15111   CONTINUE
15112   CONTINUE
15101 CONTINUE
15102 CONTINUE
      IF ((mcdf_pe_xsections)) THEN
        call egs_read_shellwise_pe()
      END IF
      DO 15121 medium=1,nmed
        mge(medium) = 2000
        nge = 2000
        ge1(medium) = nge-1
        ge1(medium) = ge1(medium)/log(up(medium)/ap(medium))
        ge0(medium) = 1 - ge1(medium)*log(ap(medium))
        write(i_log,'(a,i3,a,$)') ' Working on medium ',medium,' ... '
        IF (( out .EQ. 1 )) THEN
          write(ounit,'(/,2x,a,i3,a,24a1/)') 'Medium ',medium,': ', (med
     *    ia(k,medium),k=1,24)
        END IF
        sumZ=0
        sumA=0
        DO 15131 i=1,nne(medium)
          z_sorted(i) = zelem(medium,i)
          sumZ = sumZ + pz(medium,i)*zelem(medium,i)
          sumA = sumA + pz(medium,i)*wa(medium,i)
15131   CONTINUE
15132   CONTINUE
        con1 = sumZ*rho(medium)/(sumA*1.6605655)
        con2 = rho(medium)/(sumA*1.6605655)
        call egs_heap_sort(nne(medium),z_sorted,sorted)
        DO 15141 i=1,nne(medium)
          pz_sorted(i) = pz(medium,sorted(i))
15141   CONTINUE
15142   CONTINUE
        IF ((mcdf_pe_xsections)) THEN
          call egsi_get_shell_data(medium,nge,nne(medium),z_sorted,pz_so
     *    rted, ge1(medium),ge0(medium),sig_photo)
        ELSE
          call egsi_get_data(0,photo_unit,nge,nne(medium),z_sorted,pz_so
     *    rted, ge1(medium),ge0(medium),sig_photo)
        END IF
        call egsi_get_data(0,rayleigh_unit,nge,nne(medium),z_sorted,pz_s
     *  orted, ge1(medium),ge0(medium),sig_rayleigh)
        call egsi_get_data(1,pair_unit,nge,nne(medium),z_sorted,pz_sorte
     *  d, ge1(medium),ge0(medium),sig_pair)
        call egsi_get_data(2,triplet_unit,nge,nne(medium),z_sorted,pz_so
     *  rted, ge1(medium),ge0(medium),sig_triplet)
        IF (( iphotonuc .EQ. 1 )) THEN
          call egsi_get_data(3,photonuc_unit,nge,nne(medium),z_sorted,pz
     *    _sorted, ge1(medium),ge0(medium),sig_photonuc)
        END IF
        IF (( ibcmp(1) .GT. 1 )) THEN
          IF (( input_compton_data )) THEN
            call egsi_get_data(0,compton_unit,nge,nne(medium), z_sorted,
     *      pz_sorted,ge1(medium),ge0(medium), sig_compton)
          ELSE
            rewind(compton_unit)
            read(compton_unit,*) bc_emin,bc_emax,bc_ne
            IF (( bc_ne .GT. 183 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'Number of input Compton data exceeds array
     * size'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            bc_dle = log(bc_emax/bc_emin)/(bc_ne-1)
            DO 15151 j=1,bc_ne
              bc_data(j) = 0
15151       CONTINUE
15152       CONTINUE
            iz_old = 1
            DO 15161 i=1,nne(medium)
              iz = int(z_sorted(i)+0.5)
              DO 15171 j=iz_old,iz
                read(compton_unit,*) (bc_tmp(k),k=1,bc_ne)
15171         CONTINUE
15172         CONTINUE
              DO 15181 j=1,bc_ne
                bc_data(j)=bc_data(j)+pz_sorted(i)*z_sorted(i)*bc_tmp(j)
15181         CONTINUE
15182         CONTINUE
              iz_old = iz+1
15161       CONTINUE
15162       CONTINUE
            DO 15191 j=1,bc_ne
              bc_data(j)=log(bc_data(j)/sumZ)
15191       CONTINUE
15192       CONTINUE
          END IF
        END IF
        call egs_init_rayleigh(medium,sig_rayleigh)
        DO 15201 i=1,nge
          gle = (i - ge0(medium))/ge1(medium)
          e = exp(gle)
          sig_KN = sumZ*egs_KN_sigma0(e)
          IF (( ibcmp(1) .GT. 1 )) THEN
            IF (( input_compton_data )) THEN
              sig_KN = sig_compton(i)
            ELSE
              IF (( e .LE. bc_emin )) THEN
                bcf = exp(bc_data(1))
              ELSE IF(( e .LT. bc_emax )) THEN
                aj = 1 + log(e/bc_emin)/bc_dle
                j = int(aj)
                aj = aj - j
                bcf = exp(bc_data(j)*(1-aj) + bc_data(j+1)*aj)
              ELSE
                bcf = 1
              END IF
              sig_KN = sig_KN*bcf
            END IF
          END IF
          sig_p = sig_pair(i) + sig_triplet(i)
          sigma = sig_KN + sig_p + sig_photo(i)
          gmfp = 1/(sigma*con2)
          gbr1 = sig_p/sigma
          gbr2 = gbr1 + sig_KN/sigma
          cohe = sigma/(sig_rayleigh(i) + sigma)
          photonuc = sigma/(sig_photonuc(i) + sigma)
          IF (( out .EQ. 1 )) THEN
            IF ((iphotonucm(medium) .EQ. 1)) THEN
              write(ounit,'(6(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1, gmfp*co
     *        he,gmfp*cohe*photonuc
            ELSE
              write(ounit,'(5(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,gmfp*coh
     *        e
            END IF
          END IF
          IF (( i .GT. 1 )) THEN
            gmfp1(i-1,medium) = (gmfp - gmfp_old)*ge1(medium)
            gmfp0(i-1,medium) = gmfp - gmfp1(i-1,medium)*gle
            gbr11(i-1,medium) = (gbr1 - gbr1_old)*ge1(medium)
            gbr10(i-1,medium) = gbr1 - gbr11(i-1,medium)*gle
            gbr21(i-1,medium) = (gbr2 - gbr2_old)*ge1(medium)
            gbr20(i-1,medium) = gbr2 - gbr21(i-1,medium)*gle
            cohe1(i-1,medium) = (cohe - cohe_old)*ge1(medium)
            cohe0(i-1,medium) = cohe - cohe1(i-1,medium)*gle
            photonuc1(i-1,medium) = (photonuc - photonuc_old)*ge1(medium
     *      )
            photonuc0(i-1,medium) = photonuc - photonuc1(i-1,medium)*gle
          END IF
          gmfp_old = gmfp
          gbr1_old = gbr1
          gbr2_old = gbr2
          cohe_old = cohe
          photonuc_old = photonuc
15201   CONTINUE
15202   CONTINUE
        gmfp1(nge,medium) = gmfp1(nge-1,medium)
        gmfp0(nge,medium) = gmfp - gmfp1(nge,medium)*gle
        gbr11(nge,medium) = gbr11(nge-1,medium)
        gbr10(nge,medium) = gbr1 - gbr11(nge,medium)*gle
        gbr21(nge,medium) = gbr21(nge-1,medium)
        gbr20(nge,medium) = gbr2 - gbr21(nge,medium)*gle
        cohe1(nge,medium) = cohe1(nge-1,medium)
        cohe0(nge,medium) = cohe - cohe1(nge,medium)*gle
        photonuc1(nge,medium) = photonuc1(nge-1,medium)
        photonuc0(nge,medium) = photonuc - photonuc1(nge,medium)*gle
        write(i_log,'(a)') 'OK'
15121 CONTINUE
15122 CONTINUE
      close(photo_unit)
      close(pair_unit)
      close(triplet_unit)
      close(rayleigh_unit)
      IF (( iphotonuc .EQ. 1 )) THEN
        close(photonuc_unit)
      END IF
      IF (( ibcmp(1) .GT. 1 )) THEN
        close(compton_unit)
      END IF
      IF (( out .EQ. 1 )) THEN
        close(ounit)
      END IF
      return
15090 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(//a,a)') 'Failed to open data file ',tmp_string(:lnb
     *lnk1(tmp_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_init_rayleigh(medium,sig_rayleigh)
      implicit none
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PHOTIN/ EBINDA(10), GE0(10),GE1(10), GMFP0(2000,10),GMFP1(2
     *000,10),GBR10(2000,10),GBR11(2000,10),GBR20(2000,10),GBR21(2000,10
     *), RCO0(10),RCO1(10), RSCT0(100,10),RSCT1(100,10), COHE0(2000,10),
     *COHE1(2000,10),  PHOTONUC0(2000,10),PHOTONUC1(2000,10), DPMFP, MPG
     *EM(1,10), NGR(10)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/rayleigh_inputs/iray_ff_media(10),iray_ff_file(10)
      character*24 iray_ff_media
      character*128 iray_ff_file
      COMMON/rayleigh_sampling/xgrid(100,10), fcum(100,10), b_array(100,
     *10), c_array(100,10), i_array(100,10), pmax0(2000,10),pmax1(2000,1
     *0)
      real*8 xgrid, fcum, b_array, c_array,pmax0, pmax1
      integer*4 i_array
      real*8 xval(100),aff(100,100),ff(100,10)
      real*8 xsc, fsc
      real*8 sig_rayleigh(2000), pe_array(2000,10)
      real*8 e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA
      real*8 totRayleigh2,pzmin
      real*8 emin, emax
      integer*4 i,j,k,ff_unit, egs_get_unit, ne
      integer*4 lnblnk1, EOF, nff, medium, ncustom
      character dummy*24, afac_file*128, ff_file*128
      IF ((iraylm(medium).EQ.0)) THEN
        return
      END IF
      ncustom=0
      write(dummy,'(24a1)')(media(j,medium),j=1,24)
      ff_file=' '
      DO 15211 i=1,10
        IF ((lnblnk1(iray_ff_file(i)).NE.0)) THEN
          ncustom = ncustom + 1
        END IF
15211 CONTINUE
15212 CONTINUE
      DO 15221 i=1,ncustom
        IF ((dummy(:lnblnk1(dummy)) .EQ. iray_ff_media(i))) THEN
          ff_file = iray_ff_file(i)
        END IF
15221 CONTINUE
15222 CONTINUE
      ff_unit = egs_get_unit(0)
      IF (( ff_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_rayleigh: failed to get a free Fortran
     *I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( lnblnk1(ff_file) .GT. 0)) THEN
        open(ff_unit,file=ff_file(:lnblnk1(ff_file)), status='old',err=1
     *  5230)
        GOTO 15240
15230   write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(2a)') 'egs_init_rayleigh: failed to open custom ff
     * file ', ff_file(:lnblnk1(ff_file))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
15240   write(i_log,'(/2a)') 'Opened custom ff file ',ff_file(:lnblnk1(f
     *  f_file))
        j = 0
15251   CONTINUE
          j = j + 1
          read(ff_unit,*,IOSTAT=EOF) xsc, fsc
          IF((EOF .LT. 0))GO TO15252
          IF ((j .LE. 100)) THEN
            xgrid(j,medium)=xsc
            ff(j,medium)=fsc
          END IF
        GO TO 15251
15252   CONTINUE
        nff = j-1
        IF ((nff .GT. 100)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,/,a,i5,a,i5,/,a)') 'subroutine egs_init_raylei
     *gh: form factors size too small!!', '$XRAYFF =  ', 100,', and need
     * to be ',nff, ' and try again!!!'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF((xgrid(1,medium) .LT. 1e-6))xgrid(1,medium) = 1e-4
        write(*,*) '\n  -> ', nff, ' values of mol. ff read!'
        sumA = 0.0
        DO 15261 j=1,nne(medium)
          sumA=sumA+PZ(medium,j)*WA(medium,j)
15261   CONTINUE
15262   CONTINUE
        DO 15271 j=1,MGE(medium)
          gle=(j-GE0(medium))/GE1(medium)
          e=exp(gle)
          sig_rayleigh(j)=egs_rayleigh_sigma(medium,e,nff, xgrid(1,mediu
     *    m),ff(1,medium))*sumA
15271   CONTINUE
15272   CONTINUE
      ELSE
        DO 15281 i=1,len(afac_file)
          afac_file(i:i) = ' '
15281   CONTINUE
15282   CONTINUE
        afac_file = hen_house(:lnblnk1(hen_house))//'pegs4'//'/'//'pgs4f
     *orm.dat'
        open(ff_unit,file=afac_file(:lnblnk1(afac_file)), status='old',e
     *  rr=15290)
        GOTO 15300
15290   write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(2a)') 'egs_init_rayleigh: failed to open atomic ff
     * file', afac_file(:lnblnk1(afac_file))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
15300   read(ff_unit,*) xval, aff
        DO 15311 i=1,100
          ff(i,medium) = 0.0
          xgrid(i,medium)=xval(i)
          DO 15321 j=1,nne(medium)
            ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(mediu
     *      m,j)))**2
15321     CONTINUE
15322     CONTINUE
          ff(i,medium) = sqrt(ff(i,medium))
15311   CONTINUE
15312   CONTINUE
        nff = 100
        IF((xgrid(1,medium) .LT. 1e-6))xgrid(1,medium) = 1e-4
        write(i_log,'(/a,i4,a)') '  -> ', nff, ' atomic ff values comput
     *ed!'
      END IF
      close(ff_unit)
      emin = exp((1 - ge0(medium))/ge1(medium))
      emax = exp((mge(medium) - ge0(medium))/ge1(medium))
      call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium), mge(m
     *edium),emin,emax, pe_array(1,medium),100, fcum(1,medium),i_array(1
     *,medium), b_array(1,medium),c_array(1,medium))
      ne=MGE(medium)
      dle=log(up(medium)/ap(medium))/(ne-1)
      dlei=1/dle
      DO 15331 i=1,ne-1
        gle = (i - ge0(medium))/ge1(medium)
        pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(me
     *  dium)
        pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle
15331 CONTINUE
15332 CONTINUE
      pmax0(ne,medium)=pmax0(ne-1,medium)
      pmax1(ne,medium)=pmax1(ne-1,medium)
      return
      end
      subroutine egs_init_rayleigh_sampling(medium)
      implicit none
      COMMON/THRESH/RMT2,RMSQ, AP(10),AE(10),UP(10),UE(10),TE(10),THMOLL
     *(10)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 12001),MED( 12001),IRAYLR( 120
     *01),IPHOTONUCR( 12001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PHOTIN/ EBINDA(10), GE0(10),GE1(10), GMFP0(2000,10),GMFP1(2
     *000,10),GBR10(2000,10),GBR11(2000,10),GBR20(2000,10),GBR21(2000,10
     *), RCO0(10),RCO1(10), RSCT0(100,10),RSCT1(100,10), COHE0(2000,10),
     *COHE1(2000,10),  PHOTONUC0(2000,10),PHOTONUC1(2000,10), DPMFP, MPG
     *EM(1,10), NGR(10)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/rayleigh_inputs/iray_ff_media(10),iray_ff_file(10)
      character*24 iray_ff_media
      character*128 iray_ff_file
      COMMON/rayleigh_sampling/xgrid(100,10), fcum(100,10), b_array(100,
     *10), c_array(100,10), i_array(100,10), pmax0(2000,10),pmax1(2000,1
     *0)
      real*8 xgrid, fcum, b_array, c_array,pmax0, pmax1
      integer*4 i_array
      real*8 xval(100),aff(100,100),ff(100,10)
      real*8 xsc, fsc
      real*8 sig_rayleigh(2000), pe_array(2000,10)
      real*8 e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA
      real*8 totRayleigh2,pzmin
      real*8 emin, emax
      integer*4 i,j,k,ff_unit, egs_get_unit, ne
      integer*4 lnblnk1, EOF, nff, medium, ncustom
      character dummy*24, afac_file*128, ff_file*128
      IF ((iraylm(medium).EQ.0)) THEN
        return
      END IF
      ff_unit = egs_get_unit(0)
      IF (( ff_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_rayleigh: failed to get a free Fortran
     *I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      DO 15341 i=1,len(afac_file)
        afac_file(i:i) = ' '
15341 CONTINUE
15342 CONTINUE
      afac_file = hen_house(:lnblnk1(hen_house))//'pegs4'//'/'//'pgs4for
     *m.dat'
      open(ff_unit,file=afac_file(:lnblnk1(afac_file)),status='old',err=
     *15290)
      GOTO 15300
15290 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(2a)') 'egs_init_rayleigh_sampling: failed to open at
     *omic ff file ', afac_file(:lnblnk1(afac_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
15300 read(ff_unit,*) xval, aff
      DO 15351 i=1,100
        ff(i,medium) = 0.0
        xgrid(i,medium)=xval(i)
        DO 15361 j=1,nne(medium)
          ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,
     *    j)))**2
15361   CONTINUE
15362   CONTINUE
        ff(i,medium) = sqrt(ff(i,medium))
15351 CONTINUE
15352 CONTINUE
      nff = 100
      IF((xgrid(1,medium) .LT. 1e-6))xgrid(1,medium) = 1e-4
      write(i_log,'(/a,i4,a)') '  -> ', nff, ' atomic ff values computed
     *!'
      close(ff_unit)
      emin = exp((1 - ge0(medium))/ge1(medium))
      emax = exp((mge(medium) - ge0(medium))/ge1(medium))
      call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium), mge(m
     *edium),emin,emax, pe_array(1,medium),100, fcum(1,medium),i_array(1
     *,medium), b_array(1,medium),c_array(1,medium))
      ne=MGE(medium)
      DO 15371 i=1,ne-1
        gle = (i - ge0(medium))/ge1(medium)
        pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(me
     *  dium)
        pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle
15371 CONTINUE
15372 CONTINUE
      pmax0(ne,medium)=pmax0(ne-1,medium)
      pmax1(ne,medium)=pmax1(ne-1,medium)
      return
      end
      real*8 function egs_rayleigh_sigma(imed,E,ndat,x,f)
      implicit none
      integer*4 i, j, k,imed, ndat
      real*8 hc2,conv,b,hc
      parameter (hc = 0.0123984768438,hc2=0.0001537222280)
      real*8 x(100), f(100), zero, E, xmax
      real*8 x1,x2,pow_x1,pow_x2,raysig,C,C2,f1,f2
      C=2.*hc2/(E*E)
      C2=C*C
      xmax=E/hc
      egs_rayleigh_sigma = 0.0
      DO 15381 i=1,ndat-1
        IF((x(i) .EQ. 0.0))x(i) = zero()
        IF((x(i+1) .EQ. 0.0))x(i+1) = zero()
        IF((f(i) .EQ. 0.0))f(i) = zero()
        IF((f(i+1) .EQ. 0.0))f(i+1) = zero()
        b = log(f(i+1)/f(i))/log(x(i+1)/x(i))
        x1=x(i)
        x2=x(i+1)
        IF ((x2 .GT. xmax)) THEN
          x2=xmax
        END IF
        pow_x1=x1**(2*b)
        pow_x2=x2**(2*b)
        raysig = pow_x2*(x2**2/(b+1)-(C*x2**4)/(b+2)+(C2*x2**6)/(2*b+6))
        raysig = raysig - pow_x1*(x1**2/(b+1)-(C*x1**4)/(b+2)+(C2*x1**6)
     *  /(2*b+6))
        raysig = raysig*f(i)*f(i)/pow_x1
        egs_rayleigh_sigma = egs_rayleigh_sigma + raysig
        IF ((x(i+1).GT.xmax)) THEN
          GO TO15382
        END IF
15381 CONTINUE
15382 CONTINUE
      egs_rayleigh_sigma = 0.49893439187842413747*C*egs_rayleigh_sigma
      return
      end
      subroutine egs_rayleigh_sampling(medium,e,gle,lgle,costhe,sinthe)
      implicit none
      real*8 e
      real*8 gle,costhe,sinthe,pmax,xv,xmax,csqthe
      real*8 rnnray1,rnnray0,hc_i,twice_hc2,dwi
      parameter(hc_i=80.65506856998,twice_hc2=0.000307444456)
      integer*4 lgle,ib,ibin,medium, trials
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/rayleigh_sampling/xgrid(100,10), fcum(100,10), b_array(100,
     *10), c_array(100,10), i_array(100,10), pmax0(2000,10),pmax1(2000,1
     *0)
      real*8 xgrid, fcum, b_array, c_array,pmax0, pmax1
      integer*4 i_array
      dwi = 100-1
      pmax=pmax1(Lgle,MEDIUM)*gle+pmax0(Lgle,MEDIUM)
      xmax = hc_i*e
15391 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        rnnray1 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
15401   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          rnnray0 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          rnnray0 = rnnray0*pmax
          ibin = 1 + rnnray0*dwi
          ib = i_array(ibin,medium)
          IF (( i_array(ibin+1,medium) .GT. ib )) THEN
15411       CONTINUE
              IF((rnnray0.LT.fcum(ib+1,medium)))GO TO15412
              ib=ib+1
            GO TO 15411
15412       CONTINUE
          END IF
          rnnray0 = (rnnray0 - fcum(ib,medium))*c_array(ib,medium)
          xv = xgrid(ib,medium)*exp(log(1+rnnray0)*b_array(ib,medium))
          IF(((xv .LT. xmax)))GO TO15402
        GO TO 15401
15402   CONTINUE
        xv = xv/e
        costhe = 1 - twice_hc2*xv*xv
        csqthe=costhe*costhe
        IF((( 2*rnnray1 .LT. 1 + csqthe )))GO TO15392
      GO TO 15391
15392 CONTINUE
      sinthe=sqrt(1.0-csqthe)
      return
      end
      subroutine prepare_rayleigh_data(ndat,x,f, ne,emin,emax,pe_array,
     *ncbin,fcum,i_array, b_array,c_array)
      implicit none
      integer*4 ndat
      real*8 x(ndat),  f(ndat)
      integer*4 ne
      real*8 emin,  emax,  pe_array(ne)
      integer*4 ncbin
      real*8 fcum(ndat)
      integer*4 i_array(ncbin)
      real*8 b_array(ndat),  c_array(ndat)
      real*8 zero
      real*8 sum0,a,b,x1,x2,pow_x1,pow_x2,dle,e,xmax, anorm,anorm1,anorm
     *2,w,dw,xold,t,aux
      integer*4 i,j,k,ibin
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      write(*,'(a$)') '      preparing data for Rayleigh sampling ... '
      DO 15421 i=1,ndat
        IF((f(i) .EQ. 0.0))f(i) = zero()
15421 CONTINUE
15422 CONTINUE
      sum0=0
      fcum(1)=0
      DO 15431 i=1,ndat-1
        b = log(f(i+1)/f(i))/log(x(i+1)/x(i))
        b_array(i) = b
        x1 = x(i)
        x2 = x(i+1)
        pow_x1 = x1**(2*b)
        pow_x2 = x2**(2*b)
        sum0=sum0+f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1)
        fcum(i+1) = sum0
15431 CONTINUE
15432 CONTINUE
      dle = log(emax/emin)/(ne-1)
      i = 1
      DO 15441 j=1,ne
        e = emin*exp(dle*(j-1))
        xmax = 20.607544d0*2*e/prm
        DO 15451 k=i,ndat-1
          IF((xmax .GE. x(k) .AND. xmax .LT. x(k+1)))GO TO15452
15451   CONTINUE
15452   CONTINUE
        i = k
        b = b_array(i)
        x1 = x(i)
        x2 = xmax
        pow_x1 = x1**(2*b)
        pow_x2 = x2**(2*b)
        pe_array(j) = fcum(i) + f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((
     *  1+b)*pow_x1)
15441 CONTINUE
15442 CONTINUE
      i_array(ncbin) = i
      anorm = 1d0/sqrt(pe_array(ne))
      anorm1 = 1.005d0/pe_array(ne)
      anorm2 = 1d0/pe_array(ne)
      DO 15461 j=1,ne
        pe_array(j) = pe_array(j)*anorm1
        IF((pe_array(j) .GT. 1))pe_array(j) = 1
15461 CONTINUE
15462 CONTINUE
      DO 15471 j=1,ndat
        f(j) = f(j)*anorm
        fcum(j) = fcum(j)*anorm2
        c_array(j) = (1+b_array(j))/(x(j)*f(j))**2
15471 CONTINUE
15472 CONTINUE
      dw = 1d0/(ncbin-1)
      xold = x(1)
      ibin = 1
      b = b_array(1)
      pow_x1 = x(1)**(2*b)
      i_array(1) = 1
      DO 15481 i=2,ncbin-1
        w = dw
15491   CONTINUE
          x1 = xold
          x2 = x(ibin+1)
          t = x1*x1*x1**(2*b)
          pow_x2 = x2**(2*b)
          aux=f(ibin)*f(ibin)*(x2*x2*pow_x2-t)/((1+b)*pow_x1)
          IF (( aux .GT. w )) THEN
            xold = exp(log(t+w*(1+b)*pow_x1/f(ibin)/f(ibin))/(2+2*b))
            i_array(i) = ibin
            GO TO15492
          END IF
          w = w - aux
          xold = x2
          ibin = ibin+1
          b = b_array(ibin)
          pow_x1 = xold**(2*b)
        GO TO 15491
15492   CONTINUE
15481 CONTINUE
15482 CONTINUE
      DO 15501 j=1,ndat
        b_array(j) = 0.5/(1 + b_array(j))
15501 CONTINUE
15502 CONTINUE
      write(*,'(a /)') 'done'
      return
      end
      real*8 function egs_KN_sigma0(e)
      implicit none
      real*8 e
      real*8 con,ko,c1,c2,c3,eps1,eps2
      data con/0.1274783851/
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      ko = e/prm
      IF (( ko .LT. 0.01 )) THEN
        egs_KN_sigma0 = 8.*con/3.*(1-ko*(2-ko*(5.2-13.3*ko)))/prm
        return
      END IF
      c1 = 1./(ko*ko)
      c2 = 1. - 2*(1+ko)*c1
      c3 = (1+2*ko)*c1
      eps2 = 1
      eps1 = 1./(1+2*ko)
      egs_KN_sigma0 = (c1*(1./eps1-1./eps2)+c2*log(eps2/eps1)+eps2*(c3+0
     *.5*eps2)- eps1*(c3+0.5*eps1))/e*con
      return
      end
      real*8 function egs_KN_sigma1(e)
      implicit none
      real*8 e
      real*8 con,ko,c1,c2,c3,eps1,eps2
      data con/0.1274783851/
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      ko = e/prm
      c1 = 1./(ko*ko)
      c2 = 1. - 2*(1+ko)*c1
      c3 = (1+2*ko)*c1
      eps2 = 1
      eps1 = 1./(1+2*ko)
      egs_KN_sigma1 = c1*(1./eps1-1./eps2)
      egs_KN_sigma1 = egs_KN_sigma1 + log(eps2/eps1)*(c2 - c1) - c2*(eps
     *2-eps1)
      egs_KN_sigma1 = egs_KN_sigma1 + c3*(eps2-eps1)*(1-0.5*(eps1+eps2))
      egs_KN_sigma1 = egs_KN_sigma1 + (eps2-eps1)*(0.5*(eps1+eps2)-(eps1
     **eps1+eps2*eps2+eps1*eps2)/3)
      egs_KN_sigma1 = egs_KN_sigma1*con
      return
      end
      subroutine egsi_get_data(flag,iunit,n,ne,zsorted,pz_sorted,ge1,ge0
     *,data)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 eth
      integer*4 flag,iunit,n,ne
      real*8 ge1,ge0,zsorted(*),pz_sorted(*),data(*)
      real*8 etmp(2000),ftmp(2000)
      real*8 gle,sig,p,e
      integer*4 i,j,k,kk,iz,iz_old,ndat,iiz
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      rewind(iunit)
      iz_old = 0
      DO 15511 k=1,n
        data(k) = 0
15511 CONTINUE
15512 CONTINUE
      DO 15521 i=1,ne
        iiz = int(zsorted(i)+0.5)
        DO 15531 iz=iz_old+1,iiz
          read(iunit,*,err=15540) ndat
          IF (( ndat .GT. 2000 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'Too many input data points. Max. is ',2000
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          IF (( flag .EQ. 0 .OR. flag .EQ. 3)) THEN
            read(iunit,*,err=15540) (etmp(k),ftmp(k),k=1,ndat)
          ELSE
            read(iunit,*,err=15540) (etmp(k+1),ftmp(k+1), k=1,ndat)
            IF (( flag .EQ. 1 )) THEN
              eth = 2*rm
            ELSE
              eth = 4*rm
            END IF
            ndat = ndat + 1
            DO 15551 k=2,ndat
              ftmp(k) = ftmp(k) - 3*log(1-eth/exp(etmp(k)))
15551       CONTINUE
15552       CONTINUE
            ftmp(1) = ftmp(2)
            etmp(1) = log(eth)
          END IF
15531   CONTINUE
15532   CONTINUE
        iz_old = iiz
        DO 15561 k=1,n
          gle = (k - ge0)/ge1
          e = exp(gle)
          IF (( gle .LT. etmp(1) .OR. gle .GE. etmp(ndat) )) THEN
            IF (( flag .EQ. 0 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'Energy ',exp(gle), ' is outside the availa
     *ble data range of ', exp(etmp(1)),exp(etmp(ndat))
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            ELSE IF((flag .EQ. 1 .OR. flag .EQ. 2)) THEN
              IF (( gle .LT. etmp(1) )) THEN
                sig = 0
              ELSE
                sig = exp(ftmp(ndat))
              END IF
            ELSE
              sig = 0
            END IF
          ELSE
            DO 15571 kk=1,ndat-1
              IF((gle .GE. etmp(kk) .AND. gle .LT. etmp(kk+1)))GO TO1557
     *        2
15571       CONTINUE
15572       CONTINUE
            IF (( flag .NE. 3)) THEN
              p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk))
              sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk))
            ELSE
              p = (e - exp(etmp(kk)))/(exp(etmp(kk+1)) - exp(etmp(kk)))
              sig = p*exp(ftmp(kk+1)) + (1-p)*exp(ftmp(kk))
            END IF
          END IF
          IF(((flag .EQ. 1 .OR. flag .EQ. 2) .AND. e .GT. eth))sig = sig
     *    *(1-eth/e)**3
          data(k) = data(k) + pz_sorted(i)*sig
15561   CONTINUE
15562   CONTINUE
15521 CONTINUE
15522 CONTINUE
      return
15540 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Error while reading user photon cross sections fro
     *m unit ', iunit
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egsi_get_shell_data(imed,n,ne,zsorted,pz_sorted,ge1,ge0
     *,data)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/MEDIA/  RLC(10),RLDU(10),RHO(10),MSGE(10),MGE(10),MSEKE(10)
     *,MEKE(10),MLEKE(10),MCMFP(10),MRANGE(10),IRAYLM(10),IPHOTONUCM(10)
     *, MEDIA(24,10), photon_xsections, comp_xsections, photonuc_xsectio
     *ns,eii_xfile,IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,10),   pe_energy(500,100),  pe_zsorted(100,10), pe_be(100,16)
     *,  pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      real*8 pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      integer*4 n,  ne,  ndat
      real*8 ge1,ge0,zsorted(*),pz_sorted(*),data(*)
      real*8 sigma(500),sigmaMedium
      real*4 etmp(2000),ftmp(2000)
      real*4 gle,sig,p
      integer*4 i,j,k,kk,iz,zpos,imed
      DO 15581 k=1,n
        data(k) = 0
15581 CONTINUE
15582 CONTINUE
      DO 15591 k=1,ne
        sigma(k) = 0
15591 CONTINUE
15592 CONTINUE
      DO 15601 i=1,ne
        iz = int(zsorted(i)+0.5)
        zpos = pe_zpos(iz)
        ndat = pe_nge(zpos)
        DO 15611 k=1,ndat
          pe_elem_prob(k,i,imed) = pz_sorted(i)*pe_xsection(k,zpos,0)
          etmp(k) = pe_energy(k,zpos)
          ftmp(k) = log(pe_xsection(k,zpos,0))
15611   CONTINUE
15612   CONTINUE
        DO 15621 k=1,n
          gle = (k - ge0)/ge1
          IF (( gle .LT. etmp(1) .OR. gle .GE. etmp(ndat) )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'egsi_get_shell_data: Energy ',exp(gle), ' is
     * outside the available data range of ', exp(etmp(1)),exp(etmp(ndat
     *      ))
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          ELSE
            DO 15631 kk=1,ndat-1
              IF((gle .GE. etmp(kk) .AND. gle .LT. etmp(kk+1)))GO TO1563
     *        2
15631       CONTINUE
15632       CONTINUE
            p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk))
            sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk))
          END IF
          data(k) = data(k) + pz_sorted(i)*sig
15621   CONTINUE
15622   CONTINUE
15601 CONTINUE
15602 CONTINUE
      DO 15641 i=1,ne
        iz = int(zsorted(i)+0.5)
        zpos = pe_zpos(iz)
        ndat = pe_nge(zpos)
        DO 15651 k=1,ndat
          sig = sigmaMedium(imed,pe_energy(k,zpos))
          pe_elem_prob(k,i,imed) = log(pe_elem_prob(k,i,imed)/sig)
15651   CONTINUE
15652   CONTINUE
15641 CONTINUE
15642 CONTINUE
      return
      end
      real*8 function sigmaMedium(imed, logE)
      implicit none
      COMMON/BREMPR/ DL1(8,10),DL2(8,10),DL3(8,10),DL4(8,10),DL5(8,10),D
     *L6(8,10), ALPHI(2,10),BPAR(2,10),DELPOS(2,10), WA(10,50),PZ(10,50)
     *,ZELEM(10,50),RHOZ(10,50), PWR2I(50), DELCM(10),ZBRANG(10),LZBRANG
     *(10),NNE(10), IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(10,50
     *,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in DOSRZnrc.mortran
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,10),   pe_energy(500,100),  pe_zsorted(100,10), pe_be(100,16)
     *,  pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      real*8 pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      real*8 logE, slope, sigma
      integer*4 k,imed,Z,zpos,m,ibsearch
      sigmaMedium = 0
      DO 15661 k=1,nne(imed)
        Z = int( zelem(imed,k) + 0.5 )
        zpos = pe_zpos(Z)
        m = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos))
        slope = log(pe_xsection(m+1,zpos,0)/pe_xsection(m,zpos,0))
        slope = slope/(pe_energy(m+1,zpos)-pe_energy(m,zpos))
        sigma = log(pe_xsection(m,zpos,0))
        sigma = sigma + slope*(logE - pe_energy(m,zpos))
        sigma = exp(sigma)
        sigmaMedium = sigmaMedium + pz(imed,k)*sigma
15661 CONTINUE
15662 CONTINUE
      return
      end
      subroutine egs_heap_sort(n,rarray,jarray)
      implicit none
      integer*4 n,jarray(*)
      real*8 rarray(*)
      integer*4 i,ir,j,l,ira
      real*8 rra
      DO 15671 i=1,n
        jarray(i)=i
15671 CONTINUE
15672 CONTINUE
      IF((n .LT. 2))return
      l=n/2+1
      ir=n
15681 CONTINUE
        IF ((l .GT. 1)) THEN
          l=l-1
          rra=rarray(l)
          ira=l
        ELSE
          rra=rarray(ir)
          ira=jarray(ir)
          rarray(ir)=rarray(1)
          jarray(ir)=jarray(1)
          ir=ir-1
          IF ((ir .EQ. 1)) THEN
            rarray(1)=rra
            jarray(1)=ira
            return
          END IF
        END IF
        i=l
        j=l+l
15691   CONTINUE
          IF((j .GT. ir))GO TO15692
          IF ((j .LT. ir)) THEN
            IF((rarray(j) .LT. rarray(j+1)))j=j+1
          END IF
          IF ((rra .LT. rarray(j))) THEN
            rarray(i)=rarray(j)
            jarray(i)=jarray(j)
            i=j
            j=j+j
          ELSE
            j=ir+1
          END IF
        GO TO 15691
15692   CONTINUE
        rarray(i)=rra
        jarray(i)=ira
      GO TO 15681
15682 CONTINUE
      return
      end
      SUBROUTINE PHOTONUC
      implicit none
      COMMON/STACK/ E(500),X(500),Y(500),Z(500),U(500),V(500),W(500),DNE
     *AR(500),WT(500),IQ(500),IR(500),LATCH(500), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      npold = np
      edep = pzero
      e(np) = pzero
      wt(np) = 0
      return
      end
