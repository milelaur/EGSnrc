%L
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc macros                                                              "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2000                                       "
"                   Dave Rogers, 2000                                         "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                   Ernesto Mainegra-Hing                                     "
"                   Frederic Tessier                                          "
"                   Reid Townson                                              "
"                   Victor Malkov                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"


"Compiler directives"
"==================="
%Q1         "Automatically close comments at end of line
            "but this DOES NOT apply withing macro definitions!!
%C80        "Allow 80 columns of source/line (default is 72)
%L          "Turn on listing


"=================================================================="
" Macros to implement implicit data types                          "
"=================================================================="

REPLACE {$LOGICAL} WITH {;logical}
REPLACE {$REAL}    WITH {;real*8}
REPLACE {$INTEGER} WITH {;integer*4}
REPLACE {$LONG_INT} WITH {;integer*8} "change this to integer*4 for compilers"
                                      "that do not support integer*8"
REPLACE {$SHORT_INT} WITH {;integer*2} "change this to integer*4 for compilers"
                                      "that do not support integer*2"
"the above is not used in EGSnrc but is used in the NRC user codes,
"especially related to number of histories"
"Note that the HP compiler does not support *8 integers so the above"
" should be changed for HP"

REPLACE {$IMPLICIT-NONE;} WITH {;}
REPLACE {$IMPLICIT-NONE;} WITH {implicit none;}

"=================================================================="
"SELECT THE FORTRAN STANDARD TO BE USED (1966 OR 1977)             "
REPLACE {$FORTVER} WITH {1977}
"=================================================================="

"******************************************************************"
REPLACE {$TYPE} WITH {
  {SETR F=$FORTVER}
   [IF] {COPY F}=1977 [CHARACTER*4] [ELSE] [INTEGER*4]
  }
"******************************************************************"

"******************************************************************"
SPECIFY ALPHA    AS (0...$);
SPECIFY SYMBOL   AS (0...?);
SPECIFY NAME     AS LETTER(0,5)[ALPHA];
SPECIFY <COMMA>  AS [','|''];
SPECIFY <NAME>   AS [NAME|''];
SPECIFY LABEL    AS ':'NAME':';
SPECIFY <LABEL>  AS [LABEL|''];
SPECIFY <*>      AS ['*'|''];
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {NEWLABEL} WITH {@LG}
REPLACE {%'{ARB}'={<*>}'{ARB}'}
   WITH {[IF] '{P2}'='*' [APPEND'{P3}'TO'{P1}']
            [ELSE] [ REPLACE {{P1}}WITH{{P3}}]}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

    "RULES TO GENERALIZE MORTRAN'S INPUT AND OUTPUT"
REPLACE {;$UINPUT(#)#;}
   WITH {;{SETR A=NEWLABEL}
            READ({P1},{COPY A}){P2};{COPY A}FORMAT}

REPLACE {;$UOUTPUT(#)#;}
   WITH {;{SETR A=NEWLABEL}
            WRITE({P1},{COPY A}){P2};{COPY A}FORMAT}

REPLACE {;$ECHO#({NAME}{<COMMA>}#)#;}
 WITH {;{SETR X=NEWLABEL}
 WRITE(IUECHO,{COPY X});{COPY X}FORMAT(' ECHO {P1}:{P5}');
 [IF] {EXIST 3} [{P1}({P2},{P4}){P5};
 WRITE(IUECHO,{P4}){P5};]
 [ELSE] [{SETR Y=NEWLABEL}{P1}({P2},{COPY Y}){P4};
 WRITE(IUECHO,{COPY Y}){P5};{COPY Y}FORMAT]
 }
;  "---------- BUFFER FLUSH SEMICOLON ----------"
REPLACE {;IUECHO=#;} WITH { REPLACE {IUECHO} WITH {{P1}};}
"INITALIZE" ;IUECHO=6;

"MACRO TO SPLIT STRING INTO A LIST SEPARATED BY COMMAS"
REPLACE {$S'{SYMBOL}#'}
  WITH {'{P1}'[IF]{EXIST 2}[,$S'{P2}']}

"SOME DEBUGGING MACROS"
REPLACE {$LIST#/#/#;} WITH
   {;OUTPUT {P3};('LIST/{P2}/{P3}:'/(1X,{P1}));}
APPEND{;COMMON/QDEBUG/QDEBUG;LOGICAL QDEBUG;} TO {;COMIN/DEBUG/;}

REPLACE {$TRACE#;} WITH
  {REPLACE {;{P1}={WAIT {ARB}};}  WITH
  {{EMIT;{P1}}={WAIT {P1}};
  IF QDEBUG [OUTPUT{P1};
  (' {P1} ASSIGNED {WAIT {P1}} ',G25.18);] }; }
REPLACE {$S1TRACE#;} WITH
  {{SETR A=NEWLABEL}
    REPLACE {;{P1}({WAIT {ARB}})={WAIT {ARB}};}
       WITH {{EMIT ;{P1}({WAIT {P1}})}={WAIT {P2}};
           IF QDEBUG [I{COPY A}={WAIT {P1}};
                OUTPUT I{COPY A},{P1}(I{COPY A});
                    (' {P1}(',I6,') ASSIGNED {WAIT {P2}} ' ,
                       G25.18);] } ;}

REPLACE {$TRACE#,#;} WITH {$TRACE{P1};$TRACE{P2};}
REPLACE {$S1TRACE#,#;} WITH {$S1TRACE{P1};$S1TRACE{P2};}

SPECIFY DELIM AS ['('|';'];
REPLACE {$CALLTRACE;} WITH
  {REPLACE {;CALL{NAME}{DELIM}} WITH
  {;IF (QDEBUG)[OUTPUT;
    (' SUBROUTINE {WAIT {P1}} CALLED.');]
         {WAIT {EMIT CALL} {P1}{P2}} };}

REPLACE {$DUMP#,#;} WITH
    {;{SETR A=NEWLABEL}
         V{COPY A}={P1};OUTPUT V{COPY A};(' {P1}=',1PG15.7);
         [IF] {EXIST 2} [$DUMP{P2};] ;}
   "NOTICE: THE LIST OF VARIABLES MUST BE FOLLOWED BY A COMMA"
   "FOR EXAMPLE $DUMP S,T(U,V),W,; OR $DUMP A,;"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MORTRAN MACRO DEFINITIONS FOR EGS."

"FIRST SOME PARAMETERS"
REPLACE {PARAMETER #=#;} WITH
   { REPLACE {{P1}} WITH {{P2}}}

PARAMETER $MXMED=10;      "MAX. NO. OF DIFFERENT MEDIA (EXCL. VAC.)"
PARAMETER $MXREG=2000;    "MAXIMUM NO. OF REGIONS ALLOCATED"
PARAMETER $MXSTACK=40;    "STACK SIZE"
PARAMETER $MXVRT1=1000;   "NO. OF REPRESENTATIVE ANGLES IN VERT1"
PARAMETER $FMXVRT1=1000.; "FLOATING $MXVRT1"
PARAMETER $MXPWR2I=50;    "SIZE OF TABLE OF INVERSE POWERS OF TWO"
PARAMETER $MXJREFF=200;   "SIZE OF MULTIPLE SCATTERING JREFF MAP"
PARAMETER $MSSTEPS=16;    "NO. OF MULTIPLE SCATTERING STEP SIZES"
PARAMETER $MXVRT2=100;    "DISTRBTN OF NONOVERLAPPING PARTS OF VERT"

;
"FOLLOWING DEFINE MAX. NO. OF INTERVALS FOR FIT TO FUNCTIONS"
PARAMETER $MXSGE=400;     "GAMMA SMALL ENERGY INTERVALS"
PARAMETER $MXGE=2000;     "GAMMA MAPPED ENERGY INTERVALS"
PARAMETER $MXSEKE=300;    "ELECTRON SMALL ENERGY INTERVALS"
PARAMETER $MXEKE=500;     "ELECTRON MAPPED ENERGY INTERVALS"
PARAMETER $MXEL=50;       "MAXIMUM # OF ELEMENTS IN A MEDIUM"
PARAMETER $MXLEKE=100;    "ELECTRON ENERGY INTERVALS BELOW EKELIM"
PARAMETER $MXCMFP=100;    "CUMULATIVE ELECTRON MEAN-FREE-PATH"
PARAMETER $MXRANGE=100;   "ELECTRON RANGE"
PARAMETER $MXBLC=20;      "MOLIERE'S LOWER CASE B"
PARAMETER $MXRNTH=20;     "RANDOM NUMBER FOR SUBMEDIAN ANGLES"
PARAMETER $MXRNTHI=20;    "RANDOM NUMBER FOR SUPERMEDIAN ANGLES"
PARAMETER $MXRAYFF=100;   "RAYLEIGH ATOMIC FORM FACTOR"
PARAMETER $RAYCDFSIZE=100;"CDF from RAYLEIGH FORM FACTOR SQUARED"
PARAMETER $MXSINC=1002;   "ANGLE INTERVALS IN (0,5*PI/2) FOR SINE"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"THE FOLLOWING ARE PARAMETERS FOR AUSGAB CALLS:"
PARAMETER $MXAUS=35;       "CHANGE IF MORE AUSGAB CALLS ARE ADDED"
PARAMETER $MXAUSM5=30;     "SET THIS TO $MXAUS VALUE LESS 5"

"FIRST FIVE AUSGAB CALLS BELOW TURNED ON IN BLOCK DATA (DEFAULT)"
PARAMETER $TRANAUSB=0;    "BEFORE TRANSPORT"
PARAMETER $EGSCUTAUS=1;   "ENERGY BELOW ECUT OR PCUT"
PARAMETER $PEGSCUTAUS=2;  "ENERGY BELOW AE OR AP"
PARAMETER $USERDAUS=3;    "USER REQUESTED DISCARD"
PARAMETER $PHOTXAUS=4;    "FLUORESCENT PHOTON DISCARD"

"THE REMAINING 23 ARE TURNED OFF IN BLOCK DATA (DEFAULT)"
PARAMETER $TRANAUSA=5;    "AFTER TRANSPORT"
PARAMETER $BREMAUSB=6;    "BEFORE BREMS CALL"
PARAMETER $BREMAUSA=7;    "AFTER BREMS CALL"
PARAMETER $MOLLAUSB=8;    "BEFORE MOLLER CALL"
PARAMETER $MOLLAUSA=9;    "AFTER MOLLER CALL"
PARAMETER $BHABAUSB=10;   "BEFORE BHABHA CALL"
PARAMETER $BHABAUSA=11;   "AFTER BHABHA CALL"
PARAMETER $ANNIHFAUSB=12; "BEFORE ANNIH CALL"
PARAMETER $ANNIHFAUSA=13; "AFTER ANNIH CALL"
PARAMETER $ANNIHRAUSB=28; "BEFORE POSITRON ANNIH AT REST"
PARAMETER $ANNIHRAUSA=14; "POSITRON ANNIHILATED AT REST"
PARAMETER $PAIRAUSB=15;   "BEFORE PAIR CALL"
PARAMETER $PAIRAUSA=16;   "AFTER PAIR CALL"
PARAMETER $COMPAUSB=17;   "BEFORE COMPT CALL"
PARAMETER $COMPAUSA=18;   "AFTER COMPT CALL"
PARAMETER $PHOTOAUSB=19;  "BEFORE PHOTO CALL"
PARAMETER $PHOTOAUSA=20;  "AFTER PHOTO CALL"
PARAMETER $UPHIAUSB=21;   "ENTERED UPHI"
PARAMETER $UPHIAUSA=22;   "LEFT UPHI"
PARAMETER $RAYLAUSB=23;   "BEFORE RAYLEIGH EVENT"
PARAMETER $RAYLAUSA=24;   "AFTER RAYLEIGH EVENT"
PARAMETER $FLUORTRA=25;   "A fluorescent transition just occurred"
PARAMETER $COSKROTRA=26;  "A Coster-Kronig transition just occurred"
PARAMETER $AUGERTRA=27;   "An Auger transition just occurred"
"Ali:photonuc, 2 lines"
" note that 28 is already used for positron annih at rest - see above"
PARAMETER $PHOTONUCAUSB=29; "BEFORE PHOTONUCLEAR EVENT"
PARAMETER $PHOTONUCAUSA=30; "AFTER PHOTONUCLEAR EVENT"
PARAMETER $EIIB=31;   "Before EII"
PARAMETER $EIIA=32;   "After EII"
PARAMETER $SPHOTONA=33;   "After sub-threshold photon energy deposition"
PARAMETER $SELECTRONA=34;   "After sub-threshold electron energy deposition"

;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {$AUSCALL(#);} WITH
   {IARG={P1} ;  IF (IAUSFL(IARG+1).NE.0) [CALL AUSGAB(IARG);]} ;
;  "---------- BUFFER FLUSH SEMICOLON ----------"
"TEMPORARY OVER-RIDES FOR SOME OF THE ABOVE"
PARAMETER $MXSGE=1;
PARAMETER $MXSEKE=1;
PARAMETER $MXLEKE=1;
PARAMETER $MXCMFP=1;
PARAMETER $MXRANGE=1;
PARAMETER $MXBLC=1;
PARAMETER $MXRNTH=1;
PARAMETER $MXRNTHI=1;
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"THE FOLLOWING DEFINE PRECISION USED IN ENERGY COMPUTATIONS"
"THE LATTER OF THE TWO WILL BE IN EFFECT"
REPLACE {$ENERGYPRECISION} WITH {;REAL }"SINGLE PRECISION"
REPLACE {$ENERGYPRECISION} WITH {;DOUBLE PRECISION }
REPLACE {$MAX_INT} WITH {2147483647} "2^31-1"
"^--- limits number of particles and hence phase space file size"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MACROS TO MAKE CHANGES IN THE DEGREE OF FIT EASIER"
"ALSO USEFUL FOR ABBREVIATING LISTS OF SUBSCRIPTED VARIABLES"
"$LGN STANDS FOR 'LIST GENERATOR'"
"$RSC MEANS THAT THE EXPANDED LIST SHOULD RESCANNED FOR FURTHER"
"OPERATIONS.  MACROS EXPECTING TO DO RESCANS SHOULD BE"
"DEFINED AFTER THE FOLLOWING MACRO"
REPLACE {$RSC(#)} WITH {{P1}}
"IF NOT MATCHED BY ANYTHING ELSE, REMOVE $RSC()"
REPLACE {$RSC(#),#$LSCALEBY#;} WITH
   {{P1}={P1}*{P3};{P2}$LSCALEBY{P3};}
REPLACE {$RSC(#)$LSCALEBY#;} WITH {{P1}={P1}*{P2};}
REPLACE {$LGN(#/#/)} WITH {$RSC({P1}{P2})}
REPLACE {$LGN(#(#)/#/)} WITH {$RSC({P1}{P3}({P2}))}
REPLACE {$LGN(#(#))} WITH {$RSC({P1}({P2}))}
REPLACE {$LGN(#/#,#/)} WITH
    {$LGN({P1}/{P2}/),$LGN({P1}/{P3}/)}
REPLACE {$LGN(#,#/#/)} WITH
    {$LGN({P1}/{P3}/),$LGN({P2}/{P3}/)}
REPLACE {$LGN(#(#)/#,#/)} WITH
    {$LGN({P1}({P2})/{P3}/),$LGN({P1}({P2})/{P4}/)}
REPLACE {$LGN(#,#(#)#)} WITH
    {$LGN({P1}({P3}){P4}),$LGN({P2}({P3}){P4})}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MACROS FOR SCALING REQUIRED BY CHANGE IN DISTANCE UNIT"
REPLACE {$SCALE# BY #;} WITH {{P1}={P1}*{P2};}
REPLACE {$SCALE#,# BY #;} WITH
    {{P1}={P1}*{P3};$SCALE{P2} BY {P3};}
REPLACE {$SCALE$LGN(#) BY #;} WITH
    {$LGN({P1})$LSCALE BY {P2};}
REPLACE {$SCALE$LGN(#),# BY #;} WITH
            {$LGN({P1})$LSCALE BY {P3};$SCALE{P2} BY {P3};}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"------------------------------------------------------------------
" Macros related to bit setting
"------------------------------------------------------------------
""
"Macro to set bit {P2} in {P1}  to 1
REPLACE {$IBSET(#,#);} WITH {ibset({P1},{P2});}

"Macro to set test bit {P2} in {P1}
"Note this may require a LOGICAL declaration wherever used
REPLACE {$BTEST(#,#)} WITH {btest({P1}, {P2})}

"Macro to set bit {P2} in {P1}  to 0
REPLACE {$IBCLR(#,#);} WITH {ibclr({P1},{P2});}
"Above used by RW_PH_SP routine - (read_write_phase_space for BEAM)


"COMMON BLOCK INSERTION MACROS"
REPLACE {;COMIN/#,#/;} WITH {;COMIN/{P1}/;COMIN/{P2}/;}

"NOW FOR SOME SPECIFIC COMMON BLOCKS"

"------------------------------------------------------------------"
"*** BOUNDS--CUTOFF ENERGIES & VACUUM TRANSPORT DISTANCE           "
"------------------------------------------------------------------"
REPLACE {;COMIN/BOUNDS/;} WITH
{
    ;COMMON/BOUNDS/ECUT($MXREG),PCUT($MXREG),VACDST;
     $REAL         ECUT,   "Minimum electron transport energy"
                   PCUT,   "Minimum photon transport energy"
                   VACDST; "Infinity (1E8)"
}

"------------------------------------------------------------------"
"*** BREMPR--BREMSSTRAHLUNG AND PAIR PRODUCTION DATA               "
"------------------------------------------------------------------"

;
REPLACE {$MXBREN} WITH {57}
REPLACE {$MXBRXX} WITH {54}
REPLACE {$MXBREL} WITH {100}
REPLACE {$MXGAUSS} WITH {64}
REPLACE {$MXBRES} WITH {100}
REPLACE {$MXBRXS} WITH {50}
REPLACE {$NIST-ENERGY-SCALE} WITH {1.0}

REPLACE {$NIST-DATA-UNIT} WITH {i_nist_data}
;

REPLACE {$COMIN-INIT-NIST-BREMS;} WITH {;
    ;COMIN/MEDIA,BREMPR,ELECIN,THRESH,USEFUL,NIST-BREMS,Spin-Data,EGS-IO/;
};

REPLACE {;COMIN/BREMPR/;} WITH
{
  ;COMMON/BREMPR/
             $LGN(DL(8,$MXMED)/1,2,3,4,5,6/),
             $LGN(ALPHI,BPAR,DELPOS(2,$MXMED)),
             $LGN(WA,PZ,ZELEM,RHOZ($MXMED,$MXEL)),
             PWR2I($MXPWR2I),
             $LGN(DELCM,ZBRANG,LZBRANG,NNE($MXMED)),
             IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet,
             ASYM($MXMED,$MXEL,2);
   $TYPE     ASYM;
   $REAL     $LGN(DL/1,2,3,4,5,6/), "Parameter for the fit of the screening"
                                    "rejection function, eq. (2.7.14 and 15)"
             ALPHI,  "Prob. for the (1-BR)/BR part in BREMS, eq. (2.7.64)"
             BPAR,   "Prob. for the 12*(BR-1/2)**2 part in PAIR, eq. (2.7.105)"
             DELPOS, "maximum delta, eq. (2.7.31)"
             WA,     "atomic weight"
             PZ,     "atomic fraction of an element in a compound"
             ZELEM,  "Z for a given component"
             RHOZ,   "density of an element in a compound"
             PWR2I,  "powers of 1/2 (used for sampling (1-BR)/BR"
             DELCM,  "136*m*exp(Zg), eq. (2.7.51)"
             ZBRANG, "composite factor for angular distributions"
             LZBRANG;"-Log(ZBRANG)"
   $INTEGER  NNE,    "number of elements/compound"
             IBRDST, "flag to switch on bremsstrahlung angular distributions"
             IPRDST, "flag to switch on pair angular distributions"
             ibr_nist,  "use the NIST bremsstrahlung cross sections"
             itriplet,  "if set to 1, explicitely simulate triplet events"
             pair_nrc;  "=0 => use Bethe-Heitler pair cross sections"
                        "=1 => use the NRC pair cross sections"
};

REPLACE {;COMIN/NIST-BREMS/;} WITH {;

  common/nist_brems/ nb_fdata(0:$MXBRXS,$MXBRES,$MXMED),
                     nb_xdata(0:$MXBRXS,$MXBRES,$MXMED),
                     nb_wdata($MXBRXS,$MXBRES,$MXMED),
                     nb_idata($MXBRXS,$MXBRES,$MXMED),
                     nb_emin($MXMED),nb_emax($MXMED),
                     nb_lemin($MXMED),nb_lemax($MXMED),
                     nb_dle($MXMED),nb_dlei($MXMED),
                     log_ap($MXMED);
  $REAL    nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lemax,
           nb_dle,nb_dlei,log_ap;
  $INTEGER nb_idata;
};

REPLACE {$NRC-PAIR-NXX} WITH {65};
REPLACE {$NRC-PAIR-NEE} WITH {84};
REPLACE {$NRC-PAIR-NX-1} WITH {64};
REPLACE {$NRC-PAIR-NE-1} WITH {83};

REPLACE {;COMIN/NRC-PAIR-DATA/;} WITH {;
    common/nrc_pair/ nrcp_fdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
                     nrcp_wdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
                     nrcp_idata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
                     nrcp_xdata($NRC-PAIR-NXX),
                     nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
    $REAL            nrcp_fdata,nrcp_wdata,nrcp_xdata,
                     nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
    $INTEGER         nrcp_idata;
};

"------------------------------------------------------------------------"
"*** TRIPLET DATA                                                        "
"------------------------------------------------------------------------"
REPLACE {$MAX_TRIPLET} WITH {250}
REPLACE {;COMIN/TRIPLET-DATA/;} WITH {;
        common/triplet_data/ a_triplet($MAX_TRIPLET,$MXMED),
                             b_triplet($MAX_TRIPLET,$MXMED),
                             dl_triplet, dli_triplet, bli_triplet, log_4rm;
        $REAL                a_triplet,b_triplet,dl_triplet, dli_triplet,
                             bli_triplet, log_4rm;
};

"------------------------------------------------------------------------"
"*** COMPTON-DATA -- Incoherent scattering data                          "
"------------------------------------------------------------------------"
REPLACE {$MXTOTSH}   WITH {1538} "Total number of shells for Z=1..100    "
REPLACE {$MXMDSH}    WITH {200}   "Max. number of shells per medium       "
REPLACE {$INCOHUNIT} WITH {i_incoh}   "Unit number for compton data           "

REPLACE {;COMIN/COMPTON-DATA/;} WITH
{
  ;common/compton_data/ iz_array($MXTOTSH), "Atomic number for each shell"
                        be_array($MXTOTSH), "Shell binding energies      "
                        Jo_array($MXTOTSH), "Compton profile parameter   "
                        erfJo_array($MXTOTSH),"needed for the calculation"
                                            "of the incoherent scattering"
                                            "function                    "
                        ne_array($MXTOTSH), "Occupation number           "
                        shn_array($MXTOTSH),"shell type                  "
                                            "(=1     for K,              "
                                            " =2,3,4 for L1,L2,L3        "
                                            " =5     for M               "
                                            " =6     for N               "
                                            " =7     for all others      "
                        shell_array($MXMDSH,$MXMED),
                        eno_array($MXMDSH,$MXMED),
                        eno_atbin_array($MXMDSH,$MXMED),
                        n_shell($MXMED),
                        radc_flag,          "flag for radiative corrections"
                        ibcmp($MXREG);      "flag to turn on binding effects"
   $INTEGER             iz_array,ne_array,shn_array,eno_atbin_array,
                        shell_array,n_shell,radc_flag;
   $REAL                be_array,Jo_array,erfJo_array,eno_array;
   $SHORT_INT           ibcmp;
}


"------------------------------------------------------------------ "
"*** EDGE -- Containes binding energies for K,L1,L2,L3,             "
"             'average' M and 'average' N shells; photo-absorption  "
"             interaction probabilities with these shells;          "
"             + fluorescence, Auger, Coster-Kronig transition       "
"             probabilities                                         "
"             IEDGFL is a flag for turning on/off atomic relaxations"
"             IPHTER is a flag for turning on/off photo-lectron     "
"                    angular distribution                           "
"             both are left-overs from the previous coding          "
"             Have put now also data to calculate elemental PE      "
"             cross sections needed to sample the element the photon"
"             is interacting with.
"------------------------------------------------------------------ "
REPLACE {$MXELEMENT} WITH {100}  " Number of elements               "
REPLACE {$MXSHXSEC}  WITH {30}   " Number of shells available       "
REPLACE {$MXSHELL}   WITH {6}    " Number of shells treated         "
REPLACE {$MXINTER}   WITH {5}    " $MXSHELL-1                       "
REPLACE {$MXTRANS}   WITH {39}   " Number of possible transitions   "
REPLACE {$MXEDGE}    WITH {16}   " max. number of edges above 1 keV "
REPLACE {$PHOTOUNIT} WITH {i_photo_relax} " unit number for photo_relax.data "
REPLACE {$PHOCSUNIT} WITH {i_photo_cs}   " unit number for photo_cs.data    "

REPLACE {;COMIN/EDGE/;} WITH
{;
   COMMON/EDGE/binding_energies($MXSHXSEC,$MXELEMENT),
               interaction_prob($MXSHELL,$MXELEMENT),
               relaxation_prob($MXTRANS,$MXELEMENT),
               edge_energies($MXEDGE,$MXELEMENT),
               edge_number($MXELEMENT),
               edge_a($MXEDGE,$MXELEMENT),
               edge_b($MXEDGE,$MXELEMENT),
               edge_c($MXEDGE,$MXELEMENT),
               edge_d($MXEDGE,$MXELEMENT),
               IEDGFL($MXREG),IPHTER($MXREG);
   $REAL       binding_energies, " K,L1,L2,L3,M,N binding energies  "
               interaction_prob, " prob. for interaction with one of"
                                 " the above shells (provided photon"
                                 " energy is above be)              "
               relaxation_prob,  " relaxation probabilities         "
               edge_energies,    " photo-absorption edge energies   "
               edge_a,edge_b,edge_c,edge_d;
                                 " photo cross section fit parameters "
   $SHORT_INT  IEDGFL,  "flag for switching on fluorscent emission"
               IPHTER;  "flag for switching on photo-electron angular distr."
   $INTEGER    edge_number; " number of `edges' for each element"
}

"------------------------------------------------------------------"
"*** ELECIN--ELECTRON TRANSPORT INPUT                              "
"        MODIFIED 1989/12/19 TO INCLUDE IUNRST,EPSTFL AND IAPRIM   "
"        NRC DWOR                                                  "
"------------------------------------------------------------------"
REPLACE {;COMIN/ELECIN/;} WITH
{;
   COMMON/ELECIN/
   esig_e($MXMED),psig_e($MXMED),
   esige_max, psige_max,
   range_ep(0:1,$MXEKE,$MXMED),
   E_array($MXEKE,$MXMED),
   $LGN(etae_ms,etap_ms,q1ce_ms,q1cp_ms,q2ce_ms,q2cp_ms,
        blcce($MXEKE,$MXMED)/0,1/),
   $LGN(EKE($MXMED)/0,1/),
   $LGN(XR0,TEFF0,BLCC,XCC($MXMED)),
   $LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,TMXS($MXEKE,$MXMED)/0,1/),
   expeke1($MXMED),
   IUNRST($MXMED),EPSTFL($MXMED),IAPRIM($MXMED),
   sig_ismonotone(0:1,$MXMED);
   $REAL    esig_e,        "maximum electron cross section per energy loss"
                           "for each medium"
            psig_e,        "maximum positron cross section per energy loss"
                           "for each medium"
            esige_max,     "maximum electron cross section per energy loss"
            psige_max,     "maximum electron cross section per energy loss"
            range_ep,      "electron (0) or positron (1) range"
            E_array,       "table energies"
            etae_ms0,etae_ms1,
                           "for interpolation of screening parameter (e-)"
            etap_ms0,etap_ms1,
                           "for interpolation of screening parameter (e+)"
            q1ce_ms0,q1ce_ms1,
                          "for interpolation of q1 correction due to spin (e-)"
            q1cp_ms0,q1cp_ms1,
                          "for interpolation of q1 correction due to spin (e+)"
            q2ce_ms0,q2ce_ms1,
                          "for interpolation of q2 correction due to spin (e-)"
            q2cp_ms0,q2cp_ms1,
                          "for interpolation of q2 correction due to spin (e+)"
            blcce0,blcce1,"for interpolation of scattering power correction   "
                          "necessary to account for scattering already taken  "
                          "into account in discrete Moller/Bhabha             "
            expeke1,       "Exp(1/eke1)-1"
            $LGN(EKE/0,1/),"table for kinetic energy indexing"
            XR0,           "unused, but read in HATCH"
            TEFF0,         "unused, but read in HATCH"
            BLCC,          "b lower case sub c"
            XCC,           "chi sub-c-c"
            ESIG0,ESIG1,   "used for electron cross section interpolation"
            PSIG0,PSIG1,   "used for positron cross section interpolation"
            EDEDX0,EDEDX1, "used for electron dE/dx interpolation"
            PDEDX0,PDEDX1, "used for positron dE/dx interpolation"
            EBR10,EBR11,   "used for e- branching into brems interpolation"
            PBR10,PBR11,   "used for e+ branching into brems interpolation"
            PBR20,PBR21,   "used for e+ branching into Bhabha interpolation"
            TMXS0,TMXS1;   "used for maximum step-size interpolation"
   $INTEGER IUNRST,        "flag for type of stopping power (see PEGS4)"
            EPSTFL,        "flag for ICRU37 collision stopping powers"
            IAPRIM;        "flag for ICRU37 radiative stopping powers"
   $LOGICAL sig_ismonotone;"true, if cross section is an increasing function"
                           "of energy, false otherwise"
}

"***************************************************************************"
"                                                                           "
" ------------ common block for EII data -----------------                  "
"
" Added by Iwan Kawrakow, March 20 2004.
"                                                                           "
"****************************************************************************

REPLACE {$MAX_EII_SHELLS} WITH {40};  "Maximum number of shells participating"
                                      "in EII in a simulation                "
REPLACE {$N_EII_BINS} WITH {250};     "Number of bins for EII x-section      "
                                      "interpolations                        "
REPLACE {$MAX_EII_BINS} WITH {{COMPUTE $N_EII_BINS*$MAX_EII_SHELLS}};
"We store the EII x-section interpolation coefficients in 1D arrays  "
"The above is the dimension of these arrays required to hold the data"
REPLACE {;COMIN/EII-DATA/;} WITH {;
    common/eii_data/
        eii_xsection_a($MAX_EII_BINS), "EII x-section interpolation coeff."
        eii_xsection_b($MAX_EII_BINS), "EII x-section interpolation coeff."
        eii_cons($MXMED),
        eii_a($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
        eii_b($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
        eii_L_factor,                  "L-shell EII xsection scaling factor"
        eii_z($MAX_EII_SHELLS),        "Z of each shell                   "
        eii_sh($MAX_EII_SHELLS),       "shell type (1=K, 2=LI, eyc.)      "
        eii_nshells($MXELEMENT),       "No. of EII shells for each element"
        eii_nsh($MXMED),               "No. of EII shells for each medium "
        eii_first($MXMED,$MXEL),       "First EII shell in the list of shells"
        eii_no($MXMED,$MXEL),          "N. of EII shells                  "
        eii_flag;                      "EII flag                          "
                                       "         = 0 => no EII            "
                                       "         = 1 => simple EII        "
                                       "         > 1 => future use        "
    $REAL     eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_factor;
    $INTEGER  eii_z,eii_sh,eii_nshells;
    $INTEGER  eii_first,eii_no;
    $INTEGER  eii_elements,eii_flag,eii_nsh;
};

REPLACE {$COMIN-EII-SAMPLE;} WITH {
    ;COMIN/EPCONT,EII-DATA,EGS-VARIANCE-REDUCTION,RANDOM,STACK,THRESH,
           UPHIOT,USEFUL,EGS-IO,RELAX-DATA/;
};
REPLACE {$COMIN-EII-INIT;} WITH {
    ;COMIN/BREMPR,EDGE,EGS-IO,EII-DATA,ELECIN,MEDIA,THRESH,USEFUL/;
};

REPLACE {;COMIN/EMF-INPUTS/;} WITH {;
    common/emf_inputs/ExIN,EyIN,EzIN, "E field"
                     EMLMTIN,         "Ekin, u, E fractional maximum change"
                     BxIN, ByIN, BzIN,       "B field: initial region"
                     Bx, By, Bz,             "B field: current region"
                     Bx_new, By_new, Bz_new, "B field: in new region"
                     emfield_on;             "true if EM fields not null"

   $REAL    ExIN,EyIN,EzIN,
            EMLMTIN,
            BxIN,ByIN,BzIN,
            Bx,By,Bz,
            Bx_new,By_new,Bz_new;
   $LOGICAL emfield_on;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"
" The following common block is made available to the user so that  "
" he/she knows which shell was being relaxed when the call to ausgab"
" occured                                                           "
" Added by Iwan Kawrakow, March 22 2004.                            "

REPLACE {;COMIN/RELAX-USER/;} WITH {;
   common/user_relax/ u_relax,ish_relax,iZ_relax;
   $REAL              u_relax;
   $INTEGER           ish_relax, iZ_relax;
};


;  "---------- BUFFER FLUSH SEMICOLON ----------"
"***************************************************************************"
"                                                                           "
" ------------ common blocks for EADL relaxation data -----------------     "
"
" Added by Ernesto Mainegra, June 1st 2011.                                 "
"                                                                           "
"***************************************************************************"
"shell in one long list, avoiding repetition (i.e. if an element is present"
"in different materials, its shell structure and information will be stored"
"only once in the list). The array shell_eadl(Z,i) tells us the position of"
"the i'th shell of element Z in the long shell list.                       "
"***************************************************************************"

REPLACE {$MXESHLL} WITH {30}     "max. number of shells for an element"
REPLACE {$MAXSHELL} WITH {3000}  "max. number of shells"
REPLACE {$MAXRELAX} WITH {10000} "max. number of relaxations channels"
REPLACE {$MAXVAC} WITH {100}     "max. number of vacancies"
REPLACE {$MAXTRANS} WITH {300}   "max. number of transitions per element"
"============================================================"
" Set input key 'Atomic relaxations' to 'simple' to recover original
" implementation which allows photoelectric interactions with <M> and
" <N> shells. See below for details on the shells considered by different
" interactions depending on the value of eadl_relax:
"
"      Interaction        .false.             .true.
"      -----------------------------------------
"      Compton                all available shells
"      EII                K,L1..L3            K,L1..L3
"      Photoeffect        K,L1..L3,<M>,<N>    K,L1..L3
"      Shellwise
"      Photoeffect             N/A      All shells > $RELAX-CUTOFF
"      Relaxation
"        initial vacancy  K,L1..L3,<M>        K,L1..L3
"        (for new photoeffect)                K, L1..L3, M1..M5, N1..N4
"        final vacancy    L1..L3,<M>,<N>      L1..L3,M1..M5,N1..N7...
"
"============================================================"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {;COMIN/SHELL-DATA/;} WITH {;

  common/shell_data/
    shell_be($MAXSHELL),      "binding energies"
    shell_type($MAXSHELL),    "shell type according to EADL notation"
    shell_num($MAXSHELL),     "the shell position in the element"
    shell_Z($MAXSHELL),       "Z of the element the shell belongs to"
    shell_eadl($MXELEMENT,$MXESHLL), "global index for a shell of element Z"
    shell_ntot;               "total number of shells in the list"
  $REAL    shell_be;
  $INTEGER shell_type,shell_Z,shell_ntot,shell_num,shell_eadl;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {;COMIN/RELAX-DATA/;} WITH {;

  common/relax_data/
    relax_first($MAXSHELL),    "first transition"
    relax_ntran($MAXSHELL),    "number of transitions"
    relax_state($MAXRELAX),    "final state of the transition"
    relax_prob($MAXRELAX),     "probability"
    relax_atbin($MAXRELAX),    "used for alias sampling"
    relax_ntot;                "total number of transitions in the list"
  $REAL     relax_prob;
  $INTEGER  relax_first, relax_ntran, relax_state, relax_atbin, relax_ntot;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {;COMIN/RELAX-FOR-USER/;} WITH {;
    common/relax_for_user/
     rfu_E0, "binding energy of vacancy that initiated cascade"
     rfu_E,  "binding energy of current vacancy"
     rfu_Z,  "Atomic number of the element the relaxing shell belongs to"
     rfu_j0, "shell numb. of vacancy that initiated cascade in the list"
     rfu_n0, "same but number is shell number in the element"
     rfu_t0, "same but number is shell type according to EADL notation"
     rfu_j,  "shell number of current vacancy"
     rfu_n,  "same but number is shell number in the element"
     rfu_t;  "same but number is shell type according to EADL notation"
    $INTEGER rfu_Z,rfu_j0,rfu_n0,rfu_t0,rfu_j,rfu_n,rfu_t;
    $REAL    rfu_E0,rfu_E;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {$COMIN-RELAX-INIT;} WITH {
;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
RELAX-DATA,SHELL-DATA/;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {$COMIN-RELAX-EADL;} WITH {
;COMIN/RELAX-DATA,RELAX-FOR-USER,SHELL-DATA,
STACK,THRESH,EPCONT,USEFUL,UPHIOT,RANDOM,BOUNDS,EGS-IO,MISC,MEDIA,
X-OPTIONS/;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"***************************************************************************"
"                                                                           "
" -------------- shell-wise photoelectric cross section data ------------   "
"
" Cross sections taken from Sabbatucci and Salvat,                          "
" Theory and calculation of the atomic photoeffect                          "
" Radiat. Phys. and Chem., Volume 121, April 2016, Pages 122-140            "
"                                                                           "
"***************************************************************************"
" Shell-wise photoelectric cross sections from 50 eV up to 1 GeV for elements
" from Z=1 up to Z=99. All K, L, M, and N shells are included. One can define
" a threshold energy separating inner from outer shells. By default this
" energy is set to 1 keV, but for accurate calculation of quantities that  "
" require knowledge of which particle deposited the energy, one might need to
" use the a lower threshold.
"***************************************************************************"
"============================================================"
REPLACE {$RELAX-CUTOFF} WITH {0.001"threshold energy for outer shells"}
REPLACE {$MXPESHELL} WITH {16} "K,L1..L3,M1..M5,N1..N7 + outer shell"
REPLACE {$MXNE} WITH {500}     "number of energy points per shell "
"============================================================"
REPLACE {;COMIN/PE-SHELL-DATA/;} WITH {;

  common/pe_shell_data/
    pe_xsection($MXNE,$MXELEMENT,0:$MXPESHELL),  "shellwise cross sections"
    pe_elem_prob($MXNE,$MXELEMENT,$MXMED), "prob. of interaction with an"
                                           "element of a medium"
    pe_energy($MXNE,$MXELEMENT),    "energy grid"
    pe_zsorted($MXELEMENT,$MXMED),"sorted array of Z for each medium"
    pe_be($MXELEMENT,$MXPESHELL),      "binding energies"
    pe_nshell($MXELEMENT),       "number of shells for each element"
    pe_zpos($MXELEMENT),       "position of each Z element"
    pe_nge($MXELEMENT),       "number of energy points for each element"
    pe_ne;                    "number of elements in the simulation"
  $REAL    pe_be, pe_energy, pe_xsection, pe_elem_prob;
  $INTEGER pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {$COMIN-SHELLWISE-PE-INIT;} WITH {
;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
    PE-SHELL-DATA/;
};


;  "---------- BUFFER FLUSH SEMICOLON ----------"
" Some macros for C-style syntax in mortran "
" Unfortunately, /= doesn't work because of /v1,v2,...,vn/=value;"

REPLACE {;#+=#;} WITH { ;{P1} = {P1} + {P2}; }
REPLACE {[#+=#;} WITH { {P1} = {P1} + {P2}; }

REPLACE {;#-=#;} WITH { ;{P1} = {P1} - {P2}; }
REPLACE {[#-=#;} WITH { {P1} = {P1} - {P2}; }

REPLACE {;#*=#;} WITH { ;{P1} = {P1}*{P2}; }
REPLACE {[#*=#;} WITH { {P1} = {P1}*{P2}; }

;  "---------- BUFFER FLUSH SEMICOLON ----------"
"***************************************************************************"

REPLACE {;COMIN/ET-Control/;} WITH  "ET stands for Electron Transport"
{
  ;common/ET_control/
              smaxir($MXREG),estepe,ximax,
              "ximin_for_bca,"
              skindepth_for_bca,transport_algorithm,
              bca_algorithm,exact_bca,spin_effects;
    $REAL     smaxir,             "geom. step-size constrain for each region"
              estepe,             "global energy loss constrain"
              ximax,              "max. first GS moment per step"
                                  "(roughly half the average MS angle squared"
              "ximin_for_bca,"
                                  "min. first GS moment per step for boundary"
                                  "crossing in VMC mode"
              skindepth_for_bca;  "distance from a boundary (in elastic MFP)"
                                  "to switch to one of the BCAs "
    $INTEGER  transport_algorithm,"=$PRESTA-II or $PRESTA--I"
              bca_algorithm;      "will be used if other inexact BCAs"
                                  "implemented in the future"
    $LOGICAL  exact_bca,          "if .true. => BCA in single scattering mode"
              spin_effects;       "if .true. electron/positron spin effects"
                                  "are taken into account in the single and"
                                  "multiple elasting scattering routines"
}
;

" ======================== multiple scattering commons ================= "

" Screened Rutherford MS data "

REPLACE {$MAXL_MS}    WITH {63}
REPLACE {$MAXQ_MS}    WITH {7}
REPLACE {$MAXU_MS}    WITH {31}
REPLACE {$0-MAXL_MS}  WITH {0:63}
REPLACE {$0-MAXQ_MS}  WITH {0:7}
REPLACE {$0-MAXU_MS}  WITH {0:31}
REPLACE {$LAMBMIN_MS} WITH {1.}
REPLACE {$LAMBMAX_MS} WITH {1e5}
REPLACE {$QMIN_MS}    WITH {1e-3}
REPLACE {$QMAX_MS}    WITH {0.5}

REPLACE {COMIN/MS-Data/;} WITH {
  common/ms_data/
              ums_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
              fms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
              wms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
              ims_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
              llammin,llammax,dllamb,dllambi,dqms,dqmsi;
  real*4      ums_array,fms_array,wms_array,
              llammin,llammax,dllamb,dllambi,dqms,dqmsi;
  $SHORT_INT  ims_array;
}
;

" spin effect data used in an additional rejection loop "

REPLACE {$MAXE_SPIN}   WITH {15}
REPLACE {$MAXE_SPI1}   WITH {{COMPUTE 2*$MAXE_SPIN+1}}
REPLACE {$MAXQ_SPIN}   WITH {15}
REPLACE {$MAXU_SPIN}   WITH {31}
REPLACE {$0-MAXE_SPI1} WITH {0:$MAXE_SPI1}
REPLACE {$0-MAXQ_SPIN} WITH {0:$MAXQ_SPIN}
REPLACE {$0-MAXU_SPIN} WITH {0:$MAXU_SPIN}

REPLACE {COMIN/Spin-Data/;} WITH {
  common/spin_data/
              spin_rej($MXMED,0:1,$0-MAXE_SPI1,$0-MAXQ_SPIN,$0-MAXU_SPIN),
              espin_min,espin_max,espml,b2spin_min,b2spin_max,
              dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i,
              fool_intel_optimizer;
  real*4      spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max,
              dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i;
  $LOGICAL    fool_intel_optimizer;
}
;

REPLACE {COMIN/CH-Steps/;} WITH
{
  common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step;
  real*8           count_pII_steps,count_all_steps;
  $LOGICAL         is_ch_step;
}
;
"------------------------------------------------------------------"
"*** EPCONT--ELECTRON-PHOTON CONTROL VARIABLES                     "
"------------------------------------------------------------------"
REPLACE {;COMIN/EPCONT/;} WITH
{;
  COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP,
                RHOF,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE,
                x_final,y_final,z_final,
                u_final,v_final,w_final,
                IDISC,IROLD,IRNEW,IAUSFL($MXAUS);
    $ENERGY PRECISION EDEP,   "energy deposition in MeV"
                      EDEP_LOCAL; "local energy deposition in MeV"
    $REAL             TSTEP,  "distance to a discrete interaction"
                      TUSTEP, "intended step length, befor check with geometry"
                      USTEP,  "transport distance calculated from TUSTEP"
                      VSTEP,  "transport distance after truncation by HOWFAR"
                      TVSTEP, "curved path-length calculated from TVSTEP"
                      RHOF,   "mass density ratio"
                      EOLD,   "energy before deduction of energy loss"
                      ENEW,   "energy after  deduction of energy loss"
                      EKE,    "kinetic energy"
                      ELKE,   "Log(EKE)"
                      GLE,    "Log(energy) in PHOTON"
                      E_RANGE,"range of electron before an iarg=0 ausgab call"
                      x_final,y_final,z_final, "position at end of step"
                      u_final,v_final,w_final; "direction at end of step"
                                               "only set (and relevant) "
                                               "for electrons"
    $INTEGER          IDISC,  "flag indicating user discard"
                      IROLD,  "region before transport"
                      IRNEW,  "region after transport"
                      IAUSFL; "flags for AUSGAB calls"
}

"------------------------------------------------------------------"
"*** MEDIA--NAMES OF MEDIA CURRENTLY BEING USED                    "
"------------------------------------------------------------------"
REPLACE {;COMIN/MEDIA/;} WITH
{;
   COMMON/MEDIA/
"Ali:photonuc, 4 lines (order matters because of padding issues)"
       $LGN(RLC,RLDU,RHO,MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,
            IRAYLM,IPHOTONUCM($MXMED)),
            MEDIA(24,$MXMED), photon_xsections, comp_xsections,
            photonuc_xsections,eii_xfile,IPHOTONUC,NMED;
   $TYPE    MEDIA;"media names"
   $REAL    RLC,  "radiation length in centimeters for a given medium"
            RLDU, "radiation length after user scaling over-ride"
            RHO,  "mass density of a given medium"
            apx, upx;"new photon xsection data thresholds"
   $INTEGER MSGE, "??? "
            MGE,  "number of photon mapped energy intervals for a given medium"
            MSEKE,"??? "
            MEKE, "number of e mapped energy intervals for a given medium"
            MLEKE,"??? "
            MCMFP,"??? "
            MRANGE,"??? "
            IRAYLM,"Rayleigh switch for a given medium"
"Ali:photonuc, 2 lines"
            IPHOTONUCM,"photonuclear switch for a given medium"
            IPHOTONUC,"set to 1 if any IPHOTONUCM is set to 1"
            NMED;  "number of media"
   character*16 eii_xfile;
            "Defaults to eii_ik.data if On or Off options selected"
            "which is the EII implemented by Iwan for EGSnrc"
            "else, following options available: "
            "  eii_'casnati'.data    "
            "  eii_'kolbenstvedt'.data "
            "  eii_'gryzinski'.data"
            "these must be in $HEN_HOUSE/data"
   character*16 photon_xsections;
            "If photon_xsections is not empty, photon cross sections will be"
            "re-initialized using data files  "
            "  'photon_xsection'_photo.data   "
            "  'photon_xsection'_pair.data    "
            "  'photon_xsection'_triplet.data "
            "  'photon_xsection'_rayleigh.data"
            "that must be placed in $HEN_HOUSE/data"
   character*16 comp_xsections;
            "If comp_xsections is not empty or not set to 'default' and"
            "bound Compton scattering is On, then total Compton cross sections"
            "will be taken from 'comp_xsections'_compton.data"
            "instead of being computed from the theoretical expressions"
"Ali:photonuc, 5 lines"
   character*16 photonuc_xsections;
            "If photonuc_xsections is not empty or not set to 'default',"
            "the photonuclear cross sections will be taken from"
            "'photonuc_xsections'_photonuc.data instead of using the data"
            "in the default file iaea_photonuc.data."
}

"------------------------------------------------------------------"
"*** MISC--MISCELLANEOUS COMMON                                    "
"------------------------------------------------------------------"
REPLACE {;COMIN/MISC/;} WITH
{;
  COMMON/MISC/
"Ali:photonuc, 1 line"
           DUNIT,KMPI,KMPO,$LGN(RHOR,MED,IRAYLR,IPHOTONUCR($MXREG));
  $REAL    DUNIT,   "unit scaling factor"
           RHOR;    "density of a given region"
  $INTEGER KMPI,    "fortran unit number of the pegs4 datafile"
           KMPO;    "fortran unit number of pegs4 echo file"
  $SHORT_INT MED,   "medium number for a given region"
             IRAYLR,"Rayleigh switch for a given region"
"Ali:photonuc, 1 line"
             IPHOTONUCR;"photonuclear switch for a given region"
}
;

"------------------------------------------------------------------"
"*** PHOTIN--PHOTON TRANSPORT DATA                                 "
"------------------------------------------------------------------"
REPLACE {;COMIN/PHOTIN/;} WITH
{;
    COMMON/PHOTIN/
       EBINDA($MXMED),
       $LGN(GE($MXMED)/0,1/),
       $LGN(GMFP,GBR1,GBR2($MXGE,$MXMED)/0,1/),
       $LGN(RCO($MXMED)/0,1/),
       $LGN(RSCT($MXRAYFF,$MXMED)/0,1/),
       $LGN(COHE($MXGE,$MXMED)/0,1/),
"Ali:photonuc, 1 line"
       $LGN(PHOTONUC($MXGE,$MXMED)/0,1/),
       DPMFP,
       MPGEM($MXSGE,$MXMED),
       NGR($MXMED);
    $REAL
       EBINDA,      "energy of the K-edge for a given medium"
       GE0,GE1,     "used for indexing in logarithmic interpolations"
       GMFP0,GMFP1, "used for gamma MFP interpolation"
       GBR10,GBR11, "used for branching into pair interpolation"
       GBR20,GBR21, "used for branching into Compton interpolation"
       RCO0,RCO1,   "used for indexing in momentum trans. sampling in Rayleigh"
       RSCT0,RSCT1, "used for interpolation of momentum trans. func. in R"
       COHE0,COHE1, "used for Rayleigh modification interpolation"
"Ali:photonuc, 1 line"
       PHOTONUC0,PHOTONUC1, "used for photonuclear modification interpolation"
       DPMFP;       "number of MFP's to go to the next interaction"
    $INTEGER
       MPGEM,       "??? "
       NGR;         "array size for Rayleigh scattering data"
}
;

"------------------------------------------------------------------"
"*** RANDOM - DECLARATIONS FOR RANDOM NUMBER GENERATOR             "
"------------------------------------------------------------------"

" Note that the definition of the COMIN/RANDOM/ was taken out of   "
" the egsnrc.macros file. The current philosophy is that the user  "
" has to provide a random number generator in a separate file.     "
" Two commonly used RNGs are provided in separate files:           "
"  RANLUX: ranlux.macros and ranlux.mortran                        "
"  RANMAR: ranmar.macros and ranmar.mortran                        "


"------------------------------------------------------------------"
"*** STACK--INFORMATION KEPT ABOUT CURRENT PARTICLES               "
"------------------------------------------------------------------"
REPLACE {;COMIN/STACK/;} WITH
{;
   COMMON/STACK/
       $LGN(E,X,Y,Z,U,V,W,DNEAR,WT,IQ,IR,LATCH($MXSTACK)),
       LATCHI,NP,NPold;
   $ENERGY PRECISION
       E;     "total particle energy"
   $REAL
       X,Y,Z, "particle co-ordinates"
       U,V,W, "particle direction cosines"
       DNEAR, "perpendicular distance to nearest boundary"
       WT;    "particle weight"
   $INTEGER
       IQ,    "charge, -1 for electrons, 0 for photons, 1 for positrons"
       IR,    "current region"
       LATCH, "extra phase space variable"
       LATCHI,"needed because shower does not pass latch-BLOCK DATA sets 0"
       NP,    "stack pointer"
       NPold; "stack pointer before an interaction"
}

"------------------------------------------------------------------"
"*** THRESH--THRESHOLD (AND OTHER) ENERGIES                        "
"------------------------------------------------------------------"
REPLACE {;COMIN/THRESH/;} WITH
{;
   COMMON/THRESH/RMT2,RMSQ,
                 $LGN(AP,AE,UP,UE,TE,THMOLL($MXMED));
   $REAL         RMT2,  "2*electron mass in MeV"
                 RMSQ,  "electron mass squared in MeV**2"
                 AP,    "photon creation threshold energy"
                 AE,    "electron creation threshold energy (total)"
                 UP,    "upper photon energy in PEGS4 data set"
                 UE,    "upper electron energy in PEGS4 data set"
                 TE,    "electron creation threshold energy (kinetic)"
                 THMOLL;"Moller threshold = AE + TE"
}

"------------------------------------------------------------------"
"*** UPHIIN--SINE TABLES FOR UPHI                                  "
"------------------------------------------------------------------"
REPLACE {;COMIN/UPHIIN/;} WITH
{;
   COMMON/UPHIIN/SINC0,SINC1,$LGN(SIN($MXSINC)/0,1/);
   $REAL         SINC0,SINC1,SIN0,SIN1;
}

"------------------------------------------------------------------"
"*** UPHIOT--UPHI'S INPUT/OUTPUT WITH ITS USERS                    "
"------------------------------------------------------------------"
REPLACE {;COMIN/UPHIOT/;} WITH
{;
   COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI,
                 COSPHI,PI,TWOPI,PI5D2;
   $REAL         THETA,  "polar scattering angle"
                 SINTHE, "sin(THETA)"
                 COSTHE, "cos(THETA)"
                 SINPHI, "sine of the azimuthal scattering angle"
                 COSPHI, "cosine of the azimuthal scattering angle"
                 PI,TWOPI,PI5D2;
}

"------------------------------------------------------------------"
"*** USEFUL--HEAVILY USED VARIABLES                                "
"------------------------------------------------------------------"
REPLACE {;COMIN/USEFUL/;} WITH
{;
   COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD;
   $ENERGY PRECISION PZERO,   "precise zero"
                     PRM,     "precise electron mass in MeV"
                     PRMT2;   "2*PRM"
   $REAL             RM;      "electron mass in MeV"
   $INTEGER          MEDIUM,  "medium index of current region"
                     MEDOLD;  "medium index of previous region"
   " The rest mass value is as recommended by CODATA 2014"
   " http://physics.nist.gov/cgi-bin/cuu/Value?mec2mev"
   DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D0/;
}

"------------------------------------------------------------------"
"*** USER--A COMMON FOR THE 'USER' TO 'USE'                        "
"------------------------------------------------------------------"
REPLACE {;COMIN/USER/;} WITH {
         ;}  "DEFAULT IS NULL"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {;COMIN/X-OPTIONS/;} WITH {
    ;
  common/x_options/eadl_relax,       "Use EADL relaxation"
                   mcdf_pe_xsections;"Use Sabbatucci and Salvat PE xsections"
  $LOGICAL  eadl_relax, mcdf_pe_xsections;
};

"------------------------------------------------------------------"
"*** MACROS TO DEFINE THE COMMONS USED IN EACH SUBPROGRAM.         "
"------------------------------------------------------------------"
REPLACE {$COMIN-ANNIH;} WITH {
     ;COMIN/DEBUG,STACK, UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
REPLACE {$COMIN-ANNIH-ATREST;} WITH {
    ;COMIN/DEBUG,STACK,RANDOM,USEFUL,EGS-VARIANCE-REDUCTION,EGS-IO/;}
REPLACE {$COMIN-BHABHA;} WITH {
    ;COMIN/DEBUG,STACK, THRESH,UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,
           EGS-IO/;}
REPLACE {$COMIN-BREMS;} WITH {
    ;COMIN/DEBUG,BREMPR,EPCONT,NIST-BREMS,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
           EGS-VARIANCE-REDUCTION,EGS-IO/;}
REPLACE {$COMIN-COMPT;} WITH {
   ;COMIN/COMPTON-DATA,DEBUG,EPCONT,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
          EGS-VARIANCE-REDUCTION,EGS-IO,RELAX-DATA/;}
REPLACE {$COMIN-ELECTR;} WITH {
;COMIN/DEBUG,BOUNDS,ELECIN,EPCONT,MEDIA,MISC,STACK,THRESH,
UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,CH-Steps,EGS-IO,
          EGS-VARIANCE-REDUCTION,EMF-INPUTS/;}
REPLACE {$COMIN-HATCH;} WITH {
;COMIN/DEBUG,BOUNDS,BREMPR,ELECIN,MEDIA,MISC,PHOTIN,STACK,THRESH,
UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,EGS-IO,X-OPTIONS,
          EGS-VARIANCE-REDUCTION/;}
REPLACE {$COMIN-MOLLER;} WITH {
   ;COMIN/DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM,EGS-IO,
          EGS-VARIANCE-REDUCTION/;}
REPLACE {$COMIN-PAIR;} WITH {
   ;COMIN/DEBUG,BREMPR,NRC-PAIR-DATA,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
          EPCONT,TRIPLET-DATA,EGS-VARIANCE-REDUCTION,EGS-IO/;}
REPLACE {$COMIN-PHOTO;} WITH {
   ;COMIN/BOUNDS,BREMPR,DEBUG,EDGE,EPCONT,MEDIA,PHOTIN,RANDOM,
          STACK,UPHIOT,USEFUL,EGS-IO,X-OPTIONS,
          EGS-VARIANCE-REDUCTION,RELAX-DATA/;}
REPLACE {$COMIN-PHOTON;} WITH {
;COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,UPHIOT,
USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
REPLACE {$COMIN-SHOWER;} WITH {
  ;COMIN/DEBUG,STACK,UPHIOT,RANDOM,EGS-IO/;}
REPLACE {$COMIN-UPHI;} WITH {
  ;COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM,EGS-IO/;}
REPLACE {$COMIN-BLOCK;} WITH {
  ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,
  EPCONT,CH-Steps,ET-Control,MEDIA,MISC,PHOTIN,RANDOM,STACK,
  THRESH, UPHIIN,UPHIOT,USEFUL,EGS-VARIANCE-REDUCTION/;}
REPLACE {$COMIN-RELAX;} WITH {
  ;COMIN/EPCONT,STACK,BOUNDS,USEFUL,RANDOM,EDGE,EGS-IO,RELAX-DATA,X-OPTIONS/;}
REPLACE {$COMIN-SET-DEFAULTS;} WITH {
  ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,EPCONT,CH-Steps,ET-Control,
       MEDIA,MISC,PHOTIN,RANDOM,STACK,THRESH, UPHIIN,UPHIOT,USEFUL,
       EGS-VARIANCE-REDUCTION,EGS-IO,Spin-Data,EII-DATA,rayleigh_inputs,
       EMF-INPUTS,X-OPTIONS/;};
REPLACE {$COMIN-INIT-COMPT;} WITH {
  ;COMIN/COMPTON-DATA,BREMPR,EDGE,MEDIA,MISC,USEFUL,EGS-IO,X-OPTIONS/;};
REPLACE {$COMIN-MSCATI;} WITH {
  ;COMIN/BOUNDS,ELECIN,MEDIA,MISC,RANDOM,ET-Control,USEFUL,EGS-IO/;};
REPLACE {$COMIN-INIT-TRIPLET;} WITH {
  ;COMIN/BREMPR,EGS-IO,MEDIA,TRIPLET-DATA,USEFUL/;};
REPLACE {$COMIN-GET-TRANSPORTP;} WITH {
  ;COMIN/GetInput,BOUNDS,ET-Control,EDGE,COMPTON-DATA,MEDIA,MISC,
         BREMPR,EII-DATA,EGS-IO,rayleigh_inputs,EMF-INPUTS,X-OPTIONS/;};
"Ali:photonuc, 1 block"
REPLACE {$COMIN-PHOTONUC;} WITH {;COMIN/STACK,EPCONT,USEFUL/;};

;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {ILOG2(#)} WITH {
    IFIX(1.44269*LOG({P1}))} "1.44269=1/LN(2)"

REPLACE {$SETINTERVAL#,#;} WITH {
    [IF] '{P2}'=SNAME  [L{P1}={P2}1*{P1}+{P2}0;]
    [ELSE]  [L{P1}={P2}1(MEDIUM)*{P1}+{P2}0(MEDIUM);]}
"TWO ARGUMENT SET INTERVAL CALL (ABOVE) CURRENTLY MEANS"
"INTERVAL INDEX IS LINEAR FUNCTION OF THE LINEAR VARIABLE,"
"WITH NO MAPPING.  {P1} IS THE LINEAR VARIABLE AND {P2} IS"
"THE NAME OF THE INTERVAL(WHICH IS USED TO CONSTRUCT THE"
"COEFFICIENTS USED IN COMPUTING THE INTERVAL INDEX)."
"BUT, IF {P2} IS SINC OR BLC OR RTHR OR RTHRI, IT DOES"
"NOT DEPEND ON MEDIUM"

REPLACE {$EVALUATE#USING#(#);} WITH {
  [IF] '{P2}'=SNAME1
  [{P1}={P2}1(L{P3})*{P3}+{P2}0(L{P3});] [ELSE]
  [{P1}={P2}1(L{P3},MEDIUM)*{P3}+{P2}0(L{P3},MEDIUM);]}
"{P1} IS VARIABLE TO BE ASSIGNED VALUE."
"{P2} IS THE FUNCTION BEING APPROXIMATED."
"{P3} IS THE ARGUMENT OF THE FUNCTION. IN THE CURRENT"
"PWLF METHOD, THE ARGUMENT DETERMINES AN INTERVAL USING THE"
"$SET INTERVAL MACROS.   WITH IN THIS INTERVAL THE"
"FUNCTION IS APPROXIMATED AS A LINEAR FUNCTION OF"
"THE ARGUMENT. BUT"
"IF {P2}=SIN IT DOES NOT DEPEND ON MEDIUM"

REPLACE {$EVALUATE#USING#(#,#);} WITH {
  {P1}={P2}0(L{P3},L{P4})+{P2}1(L{P3},L{P4})*{P3}+
  {P2}2(L{P3},L{P4})*
  {P4};}"2-D APPROXIMATION INDEPENDENT OF MEDIUM"
SPECIFY SNAME AS ['sinc'|'blc'|'rthr'|'rthri'|'SINC'|'BLC'|'RTHR'|'RTHRI'];
SPECIFY SNAME1 AS ['sin'|'SIN'];

"The following circumvent the above table look up method for sin"
"functions.  Modern machines do sines very quickly so the large saving"
"in time from the above no longer exists for sines (was 40% on some"
"machines for the overall computing time! (for example it makes a
"20% effect on an SGI R4400)"
"To recover the use of tables, just comment out the following two"
"macros"

REPLACE {$EVALUATE#USING SIN(#);} WITH {{P1}=sin({P2});}
REPLACE {$SET INTERVAL#,SINC;} WITH {;}


"MACRO TO ALLOW USER TO ADD TO PROPERTIES THAT ARE"
"PASSED TO NEW PARTICLES"
REPLACE {$TRANSFERPROPERTIESTO#FROM#;} WITH {
    X{P1}=X{P2};Y{P1}=Y{P2};Z{P1}=Z{P2};IR{P1}=IR{P2};
    WT{P1}=WT{P2};DNEAR{P1}=DNEAR{P2};LATCH{P1}=LATCH{P2};}
   "IN THE USAGE OF THE ABOVE MACRO, '(IP)' WILL REFER TO THE"
   "PARTICLE WHOSE STACK INDEX IS 'IP'. 'NP' IS THE TOP OF THE STACK."
   "JUST PLAIN 'I' WILL REFER TO THE INITIAL VALUES SUPPLIED"
   "AS ARGUMENTS TO SHOWER, OR SUPPLIED IN COMMON BLOCKS OR"
   "DATA STATEMENTS IN SHOWER."

"Macro to check that the stack size is not exceeded"
REPLACE {$CHECK-STACK(#,#);} WITH {;
  IF( {P1} > $MXSTACK ) [
;  "---------- BUFFER FLUSH SEMICOLON ----------"
      $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
          ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
          ' Increase $MXSTACK and try again ');
  ]
};

/*
   Redefined to be able to use huge stack in C++ application after
   implementing new relaxation.
 */
REPLACE {$CHECK-STACK(#,#);} WITH {;
  IF( {P1} > $MXSTACK ) [
      $egs_fatal('(//,3a,/,2(a,i9))',' In subroutine ',{P2},
          ' stack size exceeded! ',' $MAXSTACK = ',$MXSTACK,' np = ',{P1});
  ]
};

"MACRO FOR RE-EVALUATING DEDX IN SUBROUTINE ELECTR"
REPLACE {$DEDX-RE-EVALUATION;} WITH {
;}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"THE FOLLOWING MACROS ARE USED IN SUBROUTINE ELECTR IN ORDER TO MAKE"
"PATH LENGTH CORRECTIONS AND RESTRICTIONS:"
REPLACE {$SET-USTEP;} WITH
{
  ekems = eke - 0.5*tustep*dedx; "Use mid-point energy to calculate"
                                  "energy dependent quantities"
  $CALCULATE-XI(tustep);
  IF ( xi < 0.1 )
    [
      ustep = tustep*(1 - xi*(0.5 - xi*0.166667));
    ]
    ELSE
    [
      ustep = tustep*(1 - Exp(-xi))/xi;
    ]
}
;

REPLACE {$CALCULATE-XI(#);} WITH
{
  p2 = ekems*(ekems+rmt2); beta2 = p2/(p2 + rmsq);
  chia2 = xccl/(4*blccl*p2);
                                "Note that our chia2 is Moliere chia2/4"
                                "Note also that xcc is now old egs xcc**2"
  xi = 0.5*xccl/p2/beta2*{P1};
  IF( spin_effects ) [
      elkems = Log(ekems);
      $SET INTERVAL elkems,eke;
      IF(lelec < 0) [
          $EVALUATE etap USING etae_ms(elkems);
          $EVALUATE xi_corr USING q1ce_ms(elkems);
      ]
      ELSE          [
          $EVALUATE etap USING etap_ms(elkems);
          $EVALUATE xi_corr USING q1cp_ms(elkems);
      ]
      chia2 = chia2*etap; xi = xi*xi_corr;
      $EVALUATE ms_corr USING blcce(elkems);
      blccl = blccl*ms_corr;
  ]
  ELSE [ xi_corr = 1; etap = 1; ]
  xi = xi*(Log(1+1./chia2)-1/(1+chia2));
}

REPLACE {$SET-TVSTEP;} WITH
"        ===========                 "
{
    ;IF ( vstep < ustep0 )
    [
      ekems = eke - 0.5*tustep*vstep/ustep0*dedx;
         "This estimates the energy loss to the boundary."
         "tustep was the intended curved path-length,"
         "ustep0 is the average transport distance in the initial direction"
         "       resulting from tustep"
         "vstep = ustep is the reduced average transport distance in the "
         "              initial direction due to boundary crossing"
      $CALCULATE-XI(vstep);
      IF ( xi < 0.1 )
      [
        tvstep = vstep*(1 + xi*(0.5 + xi*0.333333));
      ]
      ELSE
      [

        IF ( xi < 0.999999 )
        [
           tvstep = -vstep*Log(1 - xi)/xi;
        ]
        ELSE
        [
           "This is an error condition because the average transition "
           "in the initial direction of motion is always smaller than 1/Q1"
           $egs_info(*,' Stoped in SET-TVSTEP because xi > 1! ');
           $egs_info(*,' Medium: ',medium);
           $egs_info(*,' Initial energy: ',eke);
           $egs_info(*,' Average step energy: ',ekems);
           $egs_info(*,' tustep: ',tustep);
           $egs_info(*,' ustep0: ',ustep0);
           $egs_info(*,' vstep:  ',vstep);
           $egs_info(*,' ==> xi = ',xi);
           $egs_fatal(*,'This is a fatal error condition');
        ]
      ]
    ]
    ELSE
    [
      tvstep = tustep;
    ]
}
;

REPLACE {$ENEPS} WITH {0.0001}
            "DIFFERENCE BETWEEN ECUT AND END POINT ENERGY FOR"
            "RANGE CALCULATION"

REPLACE {$EPSEMFP} WITH {1.E-8}  "SMALLEST ELECTRON MFP VALUE"
REPLACE {$EPSGMFP} WITH {1.E-8}  "SMALLEST GAMMA MFP VALUE"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"THE FOLLOWING ARE UTILITY AND OTHER MACROS FOR THE USER"

"ETALY1---COMMON BLOCK FOR ENERGY CONSERVATION PURPOSES"
REPLACE {;COMIN/ETALY1/;} WITH {
    ;COMMON/ETALY1/ESUM(4,$MXREG,5);
    $ENERGY PRECISION ESUM;}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"NTALY1---COMMON BLOCK FOR KEEPING COUNT OF ETALY1-EVENTS"
REPLACE {;COMIN/NTALY1/;} WITH {
   ;COMMON/NTALY1/NSUM(4,$MXREG,5);
   $INTEGER NSUM;
}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MACRO TO ALLOW USER TO INITIALIZE IN SUBROUTINE HATCH"
REPLACE {$HATCH-USER-INPUT-INIT;} WITH {;
" $RNG-INITIALIZATION; "
" Have taken this out, (IK, Jan 2000). If the user does not initilize the"
" rng before the first call to shower, the rng will initialize itself    "
" using the default seed and the default luxury level (which is defined  "
" via $DEFAULT-LL).                                                      "

DO J=1,$MXREG [
  IF(SMAXIR(J)<=0.0) [SMAXIR(J)=1E10;]
]
;}

REPLACE {$KERMA-INSERT;} WITH {;}
            "USED IN KERMA CALCULATIONS---DEFAULT IS NULL"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MACRO FOR CONTROLLING NEGATIVE USTEP"
REPLACE {$USER-CONTROLS-NEGATIVE-USTEP;} WITH {
"         ============================"
   ;IF(USTEP<-1.E-4)[ IERUST=IERUST+1;OUTPUT IERUST,USTEP,IR(NP),IRNEW,
   IROLD,X(NP),Y(NP),Z(NP),SQRT(X(NP)**2+Y(NP)**2);
   (I6,' NEGATIVE USTEP=',E14.6,' IR,IRNEW,IROLD=',3I4,' X,Y,Z,R=',
   4E14.6);
   IF(IERUST>10)[OUTPUT;(///'0STOP, TOO MANY USTEP ERRORS'///); STOP;]]
   USTEP=0.0;}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {$CHECK-NEGATIVE-USTEP;} WITH {;
    IF(ustep <= 0) [
        "Negative ustep---probable truncation problem at a"
        "boundary, which means we are not in the region we think"
        "we are in.  The default macro assumes that user has set"
        "irnew to the region we are really most likely to be"
        "in.  A message is written out whenever ustep is less than -1.e-4"
        IF(ustep < -1e-4) [
            ierust = ierust + 1;
            OUTPUT ierust,ustep,dedx,e(np)-prm,
                   ir(np),irnew,irold,x(np),y(np),z(np);
            (i4,' Negative ustep = ',e12.5,' dedx=',F8.4,' ke=',F8.4,
             ' ir,irnew,irold =',3i4,' x,y,z =',4e10.3);
            IF(ierust > 1000) [
                OUTPUT;(////' Called exit---too many ustep errors'///);
                $CALL_EXIT(1);
            ]
        ]
        ustep = 0;
    ]
};

"MACRO FOR INTRODUCING FLUCTUATIONS IN THE ENERGY LOSS BY"
"CHARGED PARTICLES (E.G., 'LANDAU FLUCTUATIONS')---DEFAULT IS NULL"
REPLACE {$DE-FLUCTUATION;} WITH {;}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"Macro for production of annihilation quanta whenever"
"the energy is greater than AE but less than or equal to ECUT."
"photons are always produced in EGSnrc."

REPLACE {$POSITRON-ECUT-DISCARD;} WITH {EDEP=PEIE-PRM;}
"NOTE: TO GET THE EGS3 VERSION SIMPLY USE EDEP=PEIE+PRM"
"      AS THE REPLACEMENT PART OF THE MACRO."
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MACROS FOR PARTICLE SELECTION (E.G., LEADING PARTICLE,"
"SPLITTING, ETC.).  DEFAULT IS ULTIMATELY 'NULL'"
"     -----IN SUBROUTINE ELECTR-----                 "
REPLACE {$PARTICLE-SELECTION-ELECTR;} WITH {;}
REPLACE {$PARTICLE-SELECTION-ANNIH;} WITH {
         $PARTICLE-SELECTION-ELECTR;}
REPLACE {$PARTICLE-SELECTION-ANNIHREST;} WITH {
        $PARTICLE-SELECTION-ELECTR;}
REPLACE {$PARTICLE-SELECTION-BHABHA;} WITH {
        $PARTICLE-SELECTION-ELECTR;}
REPLACE {$PARTICLE-SELECTION-BREMS;} WITH {
        $PARTICLE-SELECTION-ELECTR;}
REPLACE {$PARTICLE-SELECTION-MOLLER;}
   WITH {$PARTICLE-SELECTION-ELECTR;}
"     -----IN SUBROUTINE PHOTON-----                 "
REPLACE {$PARTICLE-SELECTION-PHOTON;} WITH {;}
REPLACE {$PARTICLE-SELECTION-COMPT;} WITH {
        $PARTICLE-SELECTION-PHOTON;}
REPLACE {$PARTICLE-SELECTION-PAIR;} WITH {
        $PARTICLE-SELECTION-PHOTON;}
REPLACE {$PARTICLE-SELECTION-PHOTO;} WITH {
        $PARTICLE-SELECTION-PHOTON;}

"MACRO FOR SELECTION OF THE ELECTRON MEAN-FREE-PATH"
REPLACE {$SELECT-ELECTRON-MFP;} WITH {
        $RANDOMSET RNNE1; IF(RNNE1.EQ.0.0) [RNNE1=1.E-30;]
         DEMFP=MAX(-LOG(RNNE1),$EPSEMFP);}

"MACRO FOR SELECTION OF THE PHOTON MEAN-FREE-PATH"
REPLACE {$SELECT-PHOTON-MFP;} WITH {
       $RANDOMSET RNNO35; IF(RNNO35.EQ.0.0) [RNNO35=1.E-30;]
         DPMFP=-LOG(RNNO35);}

"MACRO to do range rejection on a region by region basis"
"      if the user requests it.  The variables e_max_rr and i_do_rr"
"      are in COMIN ET-CONTROL.  This macro is called immediately"
"      after $USER-RANGE-DISCARD in ELECTR and everytime called"
"      the electrons current range has been computed and stored in"
"      range and the distance to the nearest boundary has just been"
"      computed and is in tperp.  e_max_rr and i_do_rr are initialized"
"      to zero in BLOCK DATA so range rejection is not done unless"
"      Since option must be turned on by the user, it is considered a"
"      USER-ELECTRON-DISCARD."
"      Note this technique implies an approximation because the particle"
"      is not allowed to create a brem particle which might escape"
"      the region.  This is why  e_max_rr is used, to allow high"
"      energy electrons to be tracked in case they give off brem."

REPLACE {$RANGE-DISCARD;} WITH {
  ;IF( i_do_rr(irl) = 1 & e(np) < e_max_rr(irl) ) [
      IF(tperp >= range) ["particle cannot escape local region"
          idisc = 50 + 49*iq(np); "1 for electrons, 99 for positrons"
          go to :USER-ELECTRON-DISCARD: ;
      ]
  ]
};


"MACRO TO ALLOW USER TO DISCARD IF AT OR NEAR END OF RANGE"
REPLACE {$USER-RANGE-DISCARD;} WITH {;}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"RAYLEIGH (COHERENT) SCATTERING MACROS"

"custom form factor file names"
/*********************************************************
   For simplicity, molecular form factors are assumed to
   ALWAYS be given as FF/SQRT(MW). Current available mol.
   FF are given this way.

   One could devise a more complex scheme, where the user
   enters by input in which form the FF are given and then,
   depending on whether the medium is defined as compound or
   mixture, egsnrc must or not multiplicate the Rayleigh
   xsection with the molecular weight.

   In the current scheme, this is done automatically
   without needing input from the user.
**********************************************************/
REPLACE {COMIN/rayleigh_inputs/;} WITH
"        ================"
{
;COMMON/rayleigh_inputs/iray_ff_media($MXMED),iray_ff_file($MXMED);
;character*24 iray_ff_media;
;character*128 iray_ff_file;
}

REPLACE {COMIN/rayleigh_sampling/;} WITH
"        ================"
{;COMMON/rayleigh_sampling/xgrid($MXRAYFF,$MXMED),
                            fcum($MXRAYFF,$MXMED),
                           b_array($MXRAYFF,$MXMED),
                           c_array($MXRAYFF,$MXMED),
                           i_array($RAYCDFSIZE,$MXMED),
                           $LGN(pmax($MXGE,$MXMED)/0,1/);
$REAL xgrid, fcum, b_array, c_array,pmax0, pmax1;
$INTEGER i_array;
}

REPLACE {$RAYLEIGH-CORRECTION;} WITH {
     ;IF(IRAYLR(IRL).EQ.1) [$EVALUATE COHFAC USING COHE(GLE);
    GMFP=GMFP*COHFAC];}

REPLACE {$OLD_RAYLEIGH-SCATTERING;} WITH {
      ;IF(IRAYLR(IRL).EQ.1) [
   $RANDOMSET RNNO37;
   IF (RNNO37.LE.(1.0-COHFAC)) [
   $AUSCALL($RAYLAUSB);
   NPold = NP;
   :SAMPLING-LOOP: LOOP [$RANDOMSET XXX;
   $SET INTERVAL XXX,RCO; $EVALUATE X2 USING RSCT(XXX);
   Q2=X2*RMSQ/(20.60744*20.60744);
   COSTHE=1.-Q2/(2.*E(NP)*E(NP));
   IF (ABS(COSTHE).GT.1.0) GO TO :SAMPLING-LOOP:;
   CSQTHE=COSTHE*COSTHE;
   REJF=(1.0+CSQTHE)/2.0;
   $RANDOMSET RNNORJ;
   ] UNTIL (RNNORJ <= REJF);
   SINTHE=SQRT(1.0-CSQTHE); CALL UPHI(2,1);
   $AUSCALL($RAYLAUSA);
   GOTO :PNEWENERGY:;]]
  }
REPLACE {$RAYLEIGH-SCATTERING;} WITH {
   ;IF(IRAYLR(IRL).EQ.1) [
   $RANDOMSET RNNO37;
   IF (RNNO37.LE.(1.0-COHFAC)) [
   $AUSCALL($RAYLAUSB);
   NPold = NP;
   call egs_rayleigh_sampling(MEDIUM,E(NP),GLE,LGLE,COSTHE,SINTHE);
   CALL UPHI(2,1);
   $AUSCALL($RAYLAUSA);
   GOTO :PNEWENERGY:;]]
}

"Ali:photonuc, 2 blocks"
REPLACE {$PHOTONUC-CORRECTION;} WITH {
     ;IF(IPHOTONUCR(IRL).EQ.1) [$EVALUATE PHOTONUCFAC USING PHOTONUC(GLE);
    GMFP=GMFP*PHOTONUCFAC];}

REPLACE {$PHOTONUCLEAR;} WITH {
   ;IF(IPHOTONUCR(IRL).EQ.1) [
      $RANDOMSET RNNO39;
      IF (RNNO39.LE.(1.0-PHOTONUCFAC)) [
        $AUSCALL($PHOTONUCAUSB);
        call PHOTONUC;
        $AUSCALL($PHOTONUCAUSA);
        GOTO :PNEWENERGY:;
      ]
    ]
}

"DENSITY RATIO SCALING MACRO (TO OVER-RIDE DENSITY IN A PARTICULAR"
"REGION)  NOTE: THIS MACRO REPLACES SUBROUTINE RHOSET OF EGS3"

REPLACE {$SET-RHOF;} WITH {RHOF=RHOR(IRL)/RHO(MEDIUM);}  "DEFAULT"

"TEMPLATES FOR PERFORMING CHARGED PARTICLE TRANSPORT IN EM FIELD"
REPLACE {$SET-TUSTEP-EM-FIELD;} WITH {;}
REPLACE {$SET-USTEP-EM-FIELD;} WITH {;}
REPLACE {$VACUUM-ADD-WORK-EM-FIELD;} WITH {;}
REPLACE {$SET-ANGLES-EM-FIELD;} WITH {;}
REPLACE {$SET-TVSTEP-EM-FIELD;} WITH {;}
REPLACE {$ADD-WORK-EM-FIELD;} WITH {;}
REPLACE {$EMFIELD_INITIATE_SET_TUSTEP;} WITH {;}
REPLACE {;COMIN/EM/;} WITH {;}
REPLACE {$EMFIELD_PII;} WITH {;}
REPLACE{$EMFIELD_PI;}WITH{;}
REPLACE{$EM_FIELD_SS;}WITH{;}
REPLACE{$ADD_WORK_EM_FIELD;}WITH{;}
REPLACE{$EMFieldInVacuum;}WITH{;}
REPLACE{$EM_MACROS_ACTIVE}WITH{.false.}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"------------------------------------------------------------------"
"        EGS4/EGSnrc GEOMETRY MACROS: AN EXTENSION TO EGS MACROS   "
"------------------------------------------------------------------"

"   NOTE1: CYLNDR IS A NEW MACRO BY G.R.STEVENSON OF CERN"
"          (SEE HS-RP/TM/80-78, 25 NOV. 1980)"

"   NOTE2: CONE IS A NEW MACRO BY H.HIRAYAMA OF KEK. "
"          MACRO REPLACEMENT OF CERN VERSION SUBROUTINE CONE"
"          (SEE HS-RP/TM/81-30, 5 MAY 1981)"

"   NOTE3: SPHERE IS A NEW MACRO BY G.R.STEVENSON OF CERN"
"          (SEE HS-RP/TM/81-30, 5 MAY 1981)"

"   NOTE4: $PLAN2X AND $PLAN2P ARE TWO NEW MACROS BY W.R.NELSON."
"          $PLAN2P WAS FORMERLY CALLED $PLANE2 AND IS STILL THE"
"          SAME (CALLS TO $PLANE2 WILL AUTOMATICALLY DEFAULT TO"
"          TO $PLAN2P).  $PLAN2X, HOWEVER, WILL CORRECTLY HANDLE"
"          THE CASE OF TWO, NON-PARALLEL PLANES."

"------------------------------------------------------------------"
"        MACRO-ROUTINES FOR PLANE GEOMETRY  (SLAC VERSION)         "
"------------------------------------------------------------------"
;
PARAMETER $MXPLNS=100;     "MAX. NO. OF PLANES"

"PLADTA---COMMON BLOCK FOR $PLANE1 AND $PLANE2 MACROS"
REPLACE {;COMIN/PLADTA/;} WITH {
      ;COMMON/PLADTA/PCOORD(3,$MXPLNS),PNORM(3,$MXPLNS);
      $REAL PCOORD, PNORM;
}

"$PLANE1---MACRO REPLACEMENT FOR SUBROUTINE PLANE1"
REPLACE {$PLANE1(#,#,#,#);} WITH {
 UDOTA=PNORM(1,{P1})*U(NP)+PNORM(2,{P1})*
 V(NP)+PNORM(3,{P1})*W(NP); UDOTAP={P2}*UDOTA;
 IF(UDOTA.EQ.0.0)[{P3}=2;]ELSEIF(UDOTAP.LT.0.0)
 [{P3}=0;] ELSE [{P3}=1;{P4}=(PNORM(1,{P1})*
 (PCOORD(1,{P1})-X(NP))+ PNORM(2,{P1})*
 (PCOORD(2,{P1})-Y(NP))+PNORM(3,{P1})*
 (PCOORD(3,{P1})-Z(NP)))/UDOTA;]}
"NOTE:   EVERYWHERE $PLANE1 IS USED ONE MUST"
"        INCLUDE COMIN/PLADTA,STACK/"

"------------------------------------------------------------------"

"$PLANE2---MACRO REPLACEMENT FOR SUBROUTINE PLANE2"
"          NOTE: $PLANE2 HAS BEEN SUPERCEDED BY $PLAN2P (BELOW),"
"                WHICH IS AUTOMATICALLY TAKEN CARE OF BY THE"
"                FOLLOWING MACRO STATEMENT."
REPLACE {$PLANE2} WITH {$PLAN2P}

"------------------------------------------------------------------"

"$PLAN2P---MACRO REPLACEMENT FOR SUBROUTINE PLAN2P (OR $PLANE2)"
"          (I.E., TWO PARALLEL PLANES)"
REPLACE {$PLAN2P(#,#,#,#,#,#);} WITH {
  $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1)
 [ $CHGTR(TVAL,{P2});] ELSEIF(IHIT.EQ.0)
 [$PLANE1({P4},{P6},IHIT,TVAL);$CHGTR(TVAL,{P5});]}
"NOTE:   EVERYWHERE $PLAN2P ($PLANE2) IS USED ONE MUST"
"        INCLUDE COMIN/EPCONT,PLADTA,STACK/"

"------------------------------------------------------------------"

"$PLAN2X---MACRO REPLACEMENT FOR SUBROUTINE PLAN2X"
"          (I.E., TWO, NON-PARALLEL (CROSSING) PLANES)"
REPLACE {$PLAN2X(#,#,#,#,#,#);} WITH {
    $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1) [
   $CHGTR(TVAL,{P2});]   $PLANE1({P4},{P6},IHIT,TVAL);
   IF(IHIT.EQ.1) [$CHGTR(TVAL,{P5});]}
"NOTE:   EVERYWHERE $PLAN2X IS USED ONE MUST"
"        INCLUDE COMIN/EPCONT,PLADTA,STACK/"

"------------------------------------------------------------------"
"      MACRO-ROUTINE FOR CYLINRICAL GEOMETRY  (CERN VERSION)       "
"------------------------------------------------------------------"

PARAMETER $MXCYLS=75;      "MAX. NO. OF CYLINDERS"
PARAMETER $DELCYL=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"

"CYLDTA---COMMON BLOCK FOR $CYLNDR MACRO"
REPLACE {;COMIN/CYLDTA/;} WITH {
   ;COMMON/CYLDTA/CYRAD2($MXCYLS);
   $REAL CYRAD2;
}

"$CYLNDR---MACRO REPLACEMENT FOR SUB CYLNDR GRS VERSION 14 11 80"
REPLACE {$CYLNDR(#,#,#,#);} WITH {
   {P3}=1;{P4}=0.0;ACYL=SQRT(U(NP)*U(NP)+V(NP)*V(NP));
   IF(ACYL.EQ.0.0)[{P3}=0;]  ELSE [
   BCYL=(X(NP)*U(NP)+Y(NP)*V(NP))/ACYL;CCYL=X(NP)*X(NP)+Y(NP)*Y(NP)
   -CYRAD2({P1});  ARGCY=BCYL*BCYL-CCYL;
   IF(ARGCY.LT.0.0) [{P3}=0;]   ELSE [
   IF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.0.AND.BCYL.GE.0.0)[{P3}=0;]
   ELSEIF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.1.AND.BCYL.LT.0.0)[
   {P4}=-2.0*BCYL/ACYL;]
   ELSE [ IF({P2}.EQ.1.AND.CCYL.GE.0.0)[{P3}=1;{P4}=$DELCYL;]
   ELSEIF({P2}.EQ.0.AND.CCYL.LE.0.0)[{P3}=1;{P4}=$DELCYL;]
   ELSE  [  ROOTCY=SQRT(ARGCY); IF(CCYL.LT.0.0)
   [{P4}=(-BCYL+ROOTCY)/ACYL;]
   ELSEIF(BCYL.LT.0.0) [{P4}=(-BCYL-ROOTCY)/ACYL;]
   ELSE [{P3}=0;]]]]]}
"NOTE:   EVERYWHERE $CYLNDR IS USED ONE MUST"
"         INCLUDE COMIN/CYLDTA,STACK/"

"$CYL2--MACRO EQUIVALENT FOR CYLNDR OF $PLANE2  GRS 17.11.80"
REPLACE {$CYL2(#,#,#,#);} WITH {
 $CYLNDR({P1},0,IHIT,TCYL);IF(IHIT.EQ.1)[
 $CHGTR(TCYL,{P2});]ELSE[$CYLNDR({P3},1,IHIT,TCYL);
 IF(IHIT.EQ.1)[ $CHGTR(TCYL,{P4});]]}
"NOTE:   EVERYWHERE $CYL2 IS USED ONE MUST
"         INCLUDE COMIN/CYLDTA,STACK/"

;  "---------- BUFFER FLUSH SEMICOLON ----------"

"------------------------------------------------------------------"
"     MACRO-ROUTINE FOR CERN CONICAL GEOMETRY  (SLAC VERSION)      "
"------------------------------------------------------------------"

PARAMETER $MXCONES=75;     "MAXIMUM NUMBER OF CONES"
PARAMETER $DELCON=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"

"CONDTA---COMMON BLOCK FOR $CONE MACRO"
REPLACE {;COMIN/CONDTA/;} WITH {
   ;COMMON/CONDTA/COTAL2($MXCONES),SMALLL($MXCONES);
   $REAL COTAL2, SMALLL;
}

"$CONE---MACRO REPLACEMENT FOR CERN VERSION SUBROUTINE CONE"
REPLACE {$CONE(#,#,#,#);} WITH {
   {P3}=0;ITWOPR=0;CPCON=COTAL2({P1});SGNCON=SIGN(1.0,CPCON);
   CPCON=ABS(CPCON);ZNP=SGNCON*(Z(NP)-SMALLL({P1}));
   WNP=SGNCON*W(NP);CPCON1=1.0+CPCON;
   CPCON2=SQRT(CPCON1);DCON1=X(NP)*X(NP)+Y(NP)*Y(NP);
   DCON2=SQRT(DCON1); IF((ZNP.GE.0.0).OR.(WNP.GE.0.0)) [
   ACON=(U(NP)*U(NP)+V(NP)*V(NP))*CPCON-WNP*WNP;
   BCON1=(X(NP)*U(NP)+Y(NP)*V(NP))*CPCON;BCON=BCON1-ZNP*WNP;
   CCON=DCON1*CPCON-ZNP*ZNP;
   IF(ACON.EQ.0.0)[IF(BCON.NE.0.0)
   [IF(ABS(CCON).LT.$DELCON.AND.ZNP.GE.0.0)[
   IF(({P2}.EQ.1.AND.BCON.GE.0.0).OR.({P2}.EQ.0.AND.BCON.LE.0.0))[
   TCON1=-CCON/(2*BCON);IF(TCON1.GE.0.0)[IF((ZNP+TCON1*WNP).GE.0.0)
   [{P4}=TCON1;{P3}=1;]]]]]
   ELSE[TCON1=CPCON2*ZNP*SIGN(1.0,-WNP);
   IF(TCON1.GE.0.0)[{P4}=TCON1;{P3}=1;]]]
   ELSEIF((ABS(CCON).LT.$DELCON).AND.(ZNP.GE.0.0))
   [BPRIM=BCON1-WNP*DCON2;
   IF({P2}.EQ.1.AND.BPRIM.LT.0.0)[TCON1=-2*BCON/ACON;
   IF(TCON1.GE.0.0) [{P4}=TCON1;{P3}=1;]]]
   ELSEIF({P2}.EQ.1.AND.CCON.GT.0.0) [{P4}=$DELCON;{P3}=1;]
   ELSEIF({P2}.EQ.0.AND.CCON.LT.0.0.AND.ZNP.GE.0.0)
   [{P4}=$DELCON;{P3}=1;] ELSE[CCON1=BCON*BCON-ACON*CCON;
   IF(CCON1.GE.0.0)[ROOT=SQRT(CCON1);
   IF(BCON.GT.0.0)[TCON11=-(BCON+ROOT)/ACON;]
   ELSE[TCON11=-CCON/(BCON-ROOT);]
   IF(BCON.LT.0.0)[TCON22=-(BCON-ROOT)/ACON;]
   ELSE[TCON22=-CCON/(BCON+ROOT);]
   IF((TCON11.GE.0.0).OR.(TCON22.GE.0.0))[
   IF(TCON11.LT.0.0)[TCON1=TCON22;]
   ELSE[IF(TCON22.LT.0.0)[TCON1=TCON11;] ELSE[ITWOPR=1;
   TCON1=min(TCON11,TCON22);TCON2=max(TCON11,TCON22);]]
   IF((ZNP+TCON1*WNP).GE.0.0)[{P4}=TCON1;{P3}=1;]
   ELSEIF((ITWOPR.EQ.1).AND.((ZNP+TCON2*WNP).GE.0.0))
   [{P4}=TCON2;{P3}=1;]]]]]}
"NOTE:   EVERYWHERE $CONE IS USED ONE MUST
"         INCLUDE COMIN/CONDTA,STACK/"

"$CON2--MACRO EQUIVALENT FOR CONE OF $PLANE2            "
REPLACE {$CON2(#,#,#,#);} WITH {
   $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
   $CHGTR(TCON,{P2});]ELSE[$CONE({P3},1,IHIT,TCON);IF(IHIT.EQ.1)[
   $CHGTR(TCON,{P4});]]}

"$CON21--MACRO EQUIVALENT FOR CONE OF $PLANE2 (IN THE CASE  "
"OF OUTSIDE TWO CONE SURFACE)                               "
REPLACE {$CON21(#,#,#,#);} WITH {
   $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
   $CHGTR(TCON,{P2});]ELSE[$CONE({P3},0,IHIT,TCON);IF(IHIT.EQ.1)[
   $CHGTR(TCON,{P4});]]}

;  "---------- BUFFER FLUSH SEMICOLON ----------"

"------------------------------------------------------------------"
"        MACRO-ROUTINE FOR SPHERICAL GEOMETRY  (CERN VERSION)      "
"------------------------------------------------------------------"

PARAMETER $MXSPHE=75;      "MAX. NO. OF SPHERES"
PARAMETER $DELSPH=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"

"SPHDTA------COMMON BLOCK FOR $SPHERE MACRO"
REPLACE {;COMIN/SPHDTA/;} WITH {
   ;COMMON/SPHDTA/SPRAD2($MXSPHE);
   $REAL SPRAD2;
}

"$SPHERE---MACRO REPLACEMENT FOR SUB SPHERE GRS VERSION 08 12 80"
REPLACE {$SPHERE(#,#,#,#);} WITH {
   {P3}=1;{P4}=0.0;ASPH=1.0;
   BSPH=(X(NP)*U(NP)+Y(NP)*V(NP)+Z(NP)*W(NP))/ASPH;CSPH=X(NP)*X(NP)
   +Y(NP)*Y(NP)+Z(NP)*Z(NP)  -SPRAD2({P1});  ARGSP=BSPH*BSPH-CSPH;
   IF(ARGSP.LT.0.0) [{P3}=0;]   ELSE [
   IF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.0.AND.BSPH.GE.0.0)[{P3}=0;]
   ELSEIF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.1.AND.BSPH.LT.0.0)[
   {P4}=-2.0*BSPH/ASPH;]
   ELSE [ IF({P2}.EQ.1.AND.CSPH.GE.0.0)[{P3}=1;{P4}=$DELSPH;]
   ELSEIF({P2}.EQ.0.AND.CSPH.LE.0.0)[{P3}=1;{P4}=$DELSPH;]
   ELSE [ROOTSP=SQRT(ARGSP); IF(CSPH.LT.0.0)
   [{P4}=(-BSPH+ROOTSP)/ASPH;] ELSEIF(BSPH.LT.0.0)
   [{P4}=(-BSPH-ROOTSP)/ASPH;] ELSE [{P3}=0;]]]]}
"NOTE:   EVERYWHERE $SPHERE IS USED ONE MUST
"         INCLUDE COMIN/SPHDTA,STACK/"

"$SPH2--MACRO EQUIVALENT FOR SPHERE OF $PLANE2  GRS 08.12.80"
REPLACE {$SPH2(#,#,#,#);} WITH {
 $SPHERE({P1},0,IHIT,TSPH);IF(IHIT.EQ.1)[
 $CHGTR(TSPH,{P2});]ELSE[$SPHERE({P3},1,IHIT,TSPH);
 IF(IHIT.EQ.1)[ $CHGTR(TSPH,{P4});]]}
"NOTE:   EVERYWHERE $SPH2 IS USED ONE MUST
"         INCLUDE COMIN/SPHDTA,STACK/"

;  "---------- BUFFER FLUSH SEMICOLON ----------"

"------------------------------------------------------------------"
"        MACRO-ROUTINE FOR CHANGING REGIONS  (SLAC VERSION)        "
"------------------------------------------------------------------"

"$CHGTR---MACRO REPLACEMENT FOR SUBROUTINE CHGTR"
REPLACE {$CHGTR(#,#);} WITH {
    ;IF({P1}.LE.USTEP) [USTEP={P1}; IRNEW={P2};]}
"NOTE:   EVERYWHERE $CHGTR IS USED ONE MUST
"         INCLUDE COMIN/EPCONT/"

"------------------------------------------------------------------"
"     MACRO-ROUTINE TO OBTAIN FINAL COORDINATES (SLAC VERSION)     "
"------------------------------------------------------------------"

"$FINVAL---MACRO REPLACEMENT FOR SUBROUTINE FINVAL"
REPLACE {$FINVAL(#,#,#,#);} WITH {
   {P2}=X(NP)+{P1}*U(NP); {P3}=Y(NP)+{P1}*V(NP);
   {P4}=Z(NP)+{P1}*W(NP);}
"NOTE:   EVERYWHERE $FINVAL IS USED ONE MUST
"         INCLUDE COMIN/STACK/"

"------------------------------------------------------------------"
"                 END OF GEMOETRY MACRO EXTENSION                  "
"------------------------------------------------------------------"

"******************************************************************"
"                                                                  "
"                    NRC EXTENSIONS                                "
"                                                                  "
"******************************************************************"

; "BUFFER FLUSH"
"--------------------------------------------------------------"
"                                                              "
"           PHOTOELECTRON ANGLE SELECTION                      "
"           =============================                      "
"                                                              "
"--------------------------------------------------------------"
"This macro can be used to select the photoelectron direction  "

REPLACE {$SELECT-PHOTOELECTRON-DIRECTION;} WITH {
"        ================================"
;IF(IPHTER(IR(NP)).EQ.1)[
  EELEC=E(NP);
  IF(EELEC.GT.ECUT(IR(NP)))[
    BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC;
    GAMMA=EELEC/RM;
    ALPHA=0.5*GAMMA-0.5+1./GAMMA;
    RATIO=BETA/ALPHA;
    LOOP[
      $RANDOMSET RNPHT;RNPHT=2.*RNPHT-1.;
      IF(RATIO.LE.0.2)[
        FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT);
        IF( gamma < 100 ) [
            COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA);
        ]
        ELSE [
            IF( fkappa > 0 ) [
                costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gamma-1)**3);
            ]
            ELSE [ COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA); ]
        ]
        "XI=1./(1.-BETA*COSTHE); <-- this numerically problematic "
        "                            at high energies, IK"
        xi = (1+beta*fkappa)*gamma*gamma;
      ]
      ELSE[
        XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO))-1.));
        COSTHE=(1.-1./XI)/BETA;
      ]
      SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE));
      $RANDOMSET RNPHT2;
      ]WHILE(RNPHT2.GT.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA);
    SINTHE=SQRT(SINTH2);
    CALL UPHI(2,1);]]
}

; "BUFFER FLUSH"

"--------------------------------------------------------------"
"                                                              "
"           TSTEP RECURSION IN ELECTR                          "
"           =========================                          "
"                                                              "
"--------------------------------------------------------------"
"This macro can be used to control TSTEP recursion in ELECTR   "

REPLACE {$USER_CONTROLS_TSTEP_RECURSION;} WITH {;}

; "BUFFER FLUSH"

%C80
"------------------------------------------------------------------"
"  BREMSSTRAHLUNG ANGLE SELECTION MACROS                           "
"------------------------------------------------------------------"


"These macros are explained in NRCC REPORT #PIRS0203"
"by Bielajew, Mohan and Chui                        "

"Macro to initialize data for bremsstrahlung production               "
"The quantity ZBRANG is ( (1/111)*Zeff**(1/3) )**2                    "
"where Zeff is defined in equation (7) OF PIRS0203                    "
"This macro goes in SUBROUTINE HATCH                                  "
"                                                                     "
REPLACE {$INITIALIZE-BREMS-ANGLE;} WITH {
; IF(IBRDST.EQ.1)[
        DO IM=1,NMED[
            ZBRANG(IM)=0.0;PZNORM=0.0;
            DO IE=1,NNE(IM)[
                ZBRANG(IM)=
                  ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
                PZNORM=PZNORM+PZ(IM,IE);
                ]
                ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
                LZBRANG(IM)=-log(ZBRANG(IM));
            ]
        ]
}
;

;

" Following is associated with the selection of bremsstrahlung photon"
" angle.  This has been implemented directly into the BREMS subroutine"
" and changed slightly. Nonetheless, this macro is still used."

"This is the function G(X) of PIRS0203               "
"The result is returned in {P1} as a function of {P2}"
"i.e. {P1}=G({P2}) where {P2}=X                      "
"                                                    "
REPLACE {$SET-BREM-REJECTION-FUNCTION(#,#);} WITH {
; Y2TST1=(1.+{P2})**2;
{P1}= (4.+LOG(RJARG3+ZTARG/Y2TST1))*(4.*ESEDEI*{P2}/Y2TST1-RJARG1)+RJARG2;
}
;

"------------------------------------------------------------------"
"  PAIR ANGLE SELECTION MACROS                                     "
"------------------------------------------------------------------"

"These macros are explained in NRCC REPORT # PIRS0287 by Bielajew     "

;
"Macro to initialize data for PAIR PRODUCTION                         "
"THE QUANTITY ZBRANG IS ( (1/111)*Zeff**(1/3) )**2                    "
"WHERE Zeff IS DEFINED IN EQUATION (7) OF PIRS0287                    "
"THIS MACRO GOES IN SUBROUTINE HATCH                                  "
"THIS MACRO IS IDENTICAL TO THE $INITIALIZE-BREMS-ANGLE DEFINED ABOVE "
"                                                                     "
REPLACE {$INITIALIZE-PAIR-ANGLE;} WITH {
;    IF(IPRDST.GT.0)[
        DO IM=1,NMED[
            ZBRANG(IM)=0.0;PZNORM=0.0;
            DO IE=1,NNE(IM)[
                ZBRANG(IM)=
                  ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
                PZNORM=PZNORM+PZ(IM,IE);
                ]
                ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
            ]
        ]
}
;
"THRESHOLD BELOW WHICH ONLY LOWEST ORDER ANGULAR DISTRIBUTION OF THE  "
"PAIR ANGLE IS EMPLOYED. SCALE IS ENERGY (MeV).                       "
"USERS MAY OVERRIDE THIS WITH A HIGHER VALUE BUT A LOWER VALUE WILL   "
"CAUSE NON-PHYSICAL SAMPLING                                          "
"                                                                     "
REPLACE {$BHPAIR} WITH {4.14}
;
"THIS MACRO ENABLES VERY SMALL ANGLE SAMPLING TO BE     "
"ACCUMULATED. THE LIMIT OF 1.0E-10 BREAKS DOWN AROUND   "
"50 GEV OR SO (THETA=RM/E, FOR BOTH PAIR AND BREM).     "
"THIS MACRO REPLACES CODE IN UPHI AND IN THE PRESTA     "
"MACROS FOR THE LATERAL CORRELATION PART $PRESTA-LCDV.  "
;
REPLACE {(SINPS2.LT.1.0E-10)} WITH {(SINPS2.LT.1.0E-20)}
;
"THE FOLLOWING REPLACES THE EGS4 DEFAULT $SET-PAIR-ANGLE MACRO    "
"IT'S USE REQUIRES AN ASSOCIATE MACRO $SET-PAIR-REJECTION-FUNCTION"
"DEFINED BELOW                                                    "
"                                                                 "
"USAGE: IPRDST=0 => EGS4 DEFAULT ANGLE SELECTION                  "
"       IPRDST=1 => LOWEST ORDER ANGULAR DISTRIBUTION             "
"                                                                 "
"              d(Probability)            sin(theta)               "
"              -------------- = -------------------------------   "
"                 d(theta)      2*P*[E_total - P*cos(theta)]**2   "
"                                                                 "
"       IPRDST=2 => MOTZ, OLSEN AND KOCH (1969) EQ. 3D-2003       "
"                   IF IPRDST IS NON-ZERO AND E_PHOTON < $BHPAIR  "
"                   THE IPRDST=1 DISTRIBUTION IS USED             "
"                                                                 "
REPLACE {$SET-PAIR-ANGLE;} WITH {;
    IF( iprdst > 0 ) [
        IF( iprdst = 4 ) [
            $RANDOMSET rtest;
            "gbeta = (1-rmt2/eig)**8;"
            gbeta = PESE1/(PESE1+10);
            IF( rtest < gbeta ) [ iprdst_use = 1; ]
            ELSE [ iprdst_use = 4; ]
        ]
        ELSEIF ( iprdst = 2 & eig < $BHPAIR ) [ iprdst_use = 1; ]
        ELSE [ iprdst_use = iprdst; ]
        DO ichrg = 1,2 [
            IF(ICHRG.EQ.1)[ESE=PESE1;]ELSE[
                ESE=ESE2;
                IF( iprdst = 4 ) [
                    gbeta = ESE/(ESE+10);
                    $RANDOMSET rtest;
                    IF( rtest < gbeta ) [ iprdst_use = 1; ]
                    ELSE [ iprdst_use = 4; ]
                ]
            ]
            IF( iprdst_use = 1 ) [
                PSE=SQRT(MAX(0.0,(ESE-RM)*(ESE+RM)));
                $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
                SINTHE=RM*SQRT((1.0-COSTHE)*(1.0+COSTHE))/(PSE*COSTHE+ESE);
                COSTHE=(ESE*COSTHE+PSE)/(PSE*COSTHE+ESE);
            ]
            ELSE IF( iprdst_use = 2 ) [
                "ZBRANG=( (1/111)*Zeff**(1/3) )**2"
                ZTARG=ZBRANG(MEDIUM);
                "TTEIG=TOTAL INITIAL PHOTON ENERGY IN ELECTRON REST MASS UNITS"
                TTEIG=EIG/RM;
                "TTESE=TOTAL FINAL ELECTRON ENERGY IN ELECTRON REST MASS UNITS"
                TTESE=ESE/RM;
                "TTPSE=TOTAL FINAL ELECTRON MOMENTUM IN rm UNITS"
                TTPSE=SQRT((TTESE-1.0)*(TTESE+1.0));
                "THIS IS THE RATIO (r IN PIRS0287)"
                ESEDEI=TTESE/(TTEIG-TTESE);
                ESEDER=1.0/ESEDEI;
                "DETERMINE THE NORMALIZATION "
                XIMIN=1.0/(1.0+(3.141593*TTESE)**2);
                $SET-PAIR-REJECTION-FUNCTION(REJMIN,XIMIN);
                YA=(2.0/TTEIG)**2;
                XITRY=MAX(0.01,MAX(XIMIN,MIN(0.5,SQRT(YA/ZTARG))));
                GALPHA=1.0+0.25*LOG(YA+ZTARG*XITRY**2);
                GBETA=0.5*ZTARG*XITRY/(YA+ZTARG*XITRY**2);
                GALPHA=GALPHA-GBETA*(XITRY-0.5);
                XIMID=GALPHA/(3.0*GBETA);
                IF(GALPHA.GE.0.0)[
                    XIMID=0.5-XIMID+SQRT(XIMID**2+0.25);
                ]
                ELSE[
                    XIMID=0.5-XIMID-SQRT(XIMID**2+0.25);
                ]
                XIMID=MAX(0.01,MAX(XIMIN,MIN(0.5,XIMID)));
                $SET-PAIR-REJECTION-FUNCTION(REJMID,XIMID);
                "ESTIMATE MAXIMUM OF THE REJECTION FUNCTION"
                "FOR LATER USE BY THE REJECTION TECHNIQUE  "
                REJTOP=1.02*MAX(REJMIN,REJMID);
                LOOP[
                    $RANDOMSET XITST;
                    $SET-PAIR-REJECTION-FUNCTION(REJTST,XITST);
                    $RANDOMSET RTEST;
                    "CONVERT THE SUCCESSFUL CANDIDATE XITST TO AN ANGLE"
                    THETA=SQRT(1.0/XITST-1.0)/TTESE;
                    "LOOP UNTIL REJECTION TECHNIQUE ACCEPTS XITST"
                    REJTST_on_REJTOP   = REJTST/REJTOP;
                ]UNTIL((RTEST <= REJTST_on_REJTOP) & (THETA < PI) );
                SINTHE=SIN(THETA);COSTHE=COS(THETA);
            ]
            ELSE IF( iprdst_use = 3 ) [
                $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
                sinthe=(1-costhe)*(1+costhe);
                IF( sinthe > 0 ) [ sinthe = sqrt(sinthe); ] ELSE [ sinthe = 0; ]
            ]
            ELSE [
                "PSE=SQRT(MAX(1e-10,(ESE-RM)*(ESE+RM)));"
                "$RANDOMSET costhe;"
                "costhe=(ese-(ese+pse)*exp(-2*costhe*log((ese+pse)/rm)))/pse;"
                $RANDOMSET costhe;
                costhe=1-2*sqrt(costhe);
                sinthe=(1-costhe)*(1+costhe);
                IF( sinthe > 0 ) [ sinthe=sqrt(sinthe); ] ELSE [ sinthe=0; ]
            ]
            IF( ichrg = 1 ) [CALL UPHI(2,1);]
            ELSE [ sinthe=-sinthe; NP=NP+1; CALL UPHI(3,2); ]
        ]
        iq(np) = iq2; iq(np-1) = iq1; return;
    ]
    ELSE[
        THETA=0; "THETA=RM/EIG; "
    ]
}
;
"THIS IS THE FUNCTION d[G(XI)]/(d XI) OF PIRS0287    "
"THE RESULT IS RETURNED IN {P1} AS A FUNCTION OF {P2}"
"I.E. {P1}=G({P2}) WHERE {P2}=XI                     "
"                                                    "
REPLACE {$SET-PAIR-REJECTION-FUNCTION(#,#);} WITH {
; {P1} = 2.0+3.0*(ESEDEI+ESEDER) -
        4.00*(ESEDEI+ESEDER+1.0-4.0*({P2}-0.5)**2)*(
            1.0+0.25*LOG(
                ((1.0+ESEDER)*(1.0+ESEDEI)/(2.*TTEIG))**2+ZTARG*{P2}**2
                )
            )
        ;
}
;

REPLACE {$SELECT-LOW-ENERGY-PAIR-PRODICTION;} WITH
{
  $RANDOMSET RNNO30; $RANDOMSET rnno34;
  PESE2 = PRM + 0.5*RNNO30*(PEIG-2*PRM); PESE1 = PEIG - PESE2;
  IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]
}
" IK introduced this macro because uniform energy distribution"
" is probably a better approximation than a zero energy 'electron'"
" for low energy pair production"

;

"THIS MACRO EXCHANGES TWO POSITIONS ON THE STACK"
"NB: LATCH IS A NON-STANDARD STACK VARIABLE     "
"    REMOVE IT IF IT CAUSES PROBLEMS            "
"                                               "
REPLACE {$EXCHANGE-STACK(#,#);} WITH {
;
FDUMMY = U({P2});     U({P2})     = U({P1});     U({P1})     = FDUMMY;
FDUMMY = V({P2});     V({P2})     = V({P1});     V({P1})     = FDUMMY;
FDUMMY = W({P2});     W({P2})     = W({P1});     W({P1})     = FDUMMY;
FDUMMY = E({P2});     E({P2})     = E({P1});     E({P1})     = FDUMMY;
FDUMMY = WT({P2});    WT({P2})    = WT({P1});    WT({P1})    = FDUMMY;
IDUMMY = IQ({P2});    IQ({P2})    = IQ({P1});    IQ({P1})    = IDUMMY;
"LATCH IS NOW STANDARD"
IDUMMY = LATCH({P2}); LATCH({P2}) = LATCH({P1}); LATCH({P1}) = IDUMMY;
}
;

REPLACE {;OUTPUT61#;#;} WITH {
"       ==============="
;{SETR A=@LG}
WRITE(6,{COPY A}){P1};WRITE(1,{COPY A}){P1};{COPY A}FORMAT{P2};}
;

" The following macro provides a second order evaluation of the   "
" stopping power. The parameter is half of the initial estimate of"
" the energy loss fraction. IK Oct 97                             "
REPLACE {$RE-EVALUATE-DEDX(#);} WITH
{
;
  elktmp = elke + Log(1 - {P1});
  $SET INTERVAL elktmp,eke;
  lelktmp = max(1,lelktmp);
  IF(lelec < 0)[$EVALUATE dedxmid USING ededx(elktmp);]
  ELSE         [$EVALUATE dedxmid USING pdedx(elktmp);]
  dedx = rhof*dedxmid*(1+0.17408298*({P1}/(1-{P1})/(eke+PRM))**2);
                   "0.17408298 is 2/3*m**2"
  {P1} = 2*{P1};
}

; "BUFFER FLUSH"


%E    "egsnrc.macros"
"******************************************************************"
"                                                                  "
"       transport algorithm related stuff                          "
"                                                                  "
"******************************************************************"

"Macros to denote the various transport algorithms"
"These numbers just have to be distinct"
"Note that the distributed version of EGSnrc does not include the VMC option"
REPLACE {$PRESTA-II} WITH {0}
REPLACE {$PRESTA--I} WITH {1}
REPLACE {$VMC}       WITH {2}

REPLACE {$CALL-USER-ELECTRON} WITH {;}

;
REPLACE {$MSCAT-DATAFILE} WITH {i_mscat}
  "Fortran unit number used to read in new MS"
;
REPLACE {$RANDOMIZE-TUSTEP} WITH {.false.}
  "Switches tustep randomization off"
;
REPLACE {$SKIN-DEPTH-FOR-BCA} WITH {3}
;
REPLACE {$PRESTA-DEBUG} WITH {.false.}
;
REPLACE {$EXACT-BCA-XIMAX} WITH {0.5}
;
REPLACE {$INEXACT-BCA-XIMAX} WITH {0.5} "this is not realy neccessary, "
                                        "it remained from Alex's coding"
;
REPLACE {$MAX-ELOSS} WITH {0.25}
;
REPLACE {$SUBSTEP-ELOSS-EVALUATION} WITH {.false.}
;
REPLACE {$MAX-SMAX} WITH {1e10}
;
REPLACE {$GLOBAL-ECUT} WITH {0.}
;
REPLACE {$GLOBAL-PCUT} WITH {0.}
;
REPLACE {$IBRDST-DEFAULT} WITH {1}
;
REPLACE {$IBR-NIST-DEFAULT} WITH {0}
;
REPLACE {$PAIR-NRC-DEFAULT} WITH {0}
;
REPLACE {$TRIPLET-DEFAULT} WITH {0}
;
REPLACE {$IPRDST-DEFAULT} WITH {1}
;
REPLACE {$IBCMP-DEFAULT} WITH {3} "set to norej"
;
REPLACE {$IEDGFL-DEFAULT} WITH {1}
;
REPLACE {$IPHTER-DEFAULT} WITH {1}
;
REPLACE {$TRANSPORT-ALGORITHM-DEFAULT} WITH {$PRESTA-II}
;
REPLACE {$BCA-ALGORITHM-DEFAULT} WITH {0}
;
REPLACE {$EXACT-BCA-DEFAULT} WITH {.true.}
;
REPLACE {$SPIN-EFFECTS-DEFAULT} WITH {.true.}
;
REPLACE {$IRAYLR-DEFAULT} WITH {1}
;
REPLACE {$AP-DEFAULT} WITH {-1}
;
REPLACE {$UP-DEFAULT} WITH {-1}
;
REPLACE {$XSEC-DEFAULT} WITH {0}
;
REPLACE {$XDATA-DEFAULT} WITH {'xcom'}
;
REPLACE {$COMP-XDATA-DEFAULT} WITH {'default'}
;
"EADL relaxation is now the default"
REPLACE {$EADL-RELAX-DEFAULT} WITH {.true.}
;
"Sabbatucci and Salvat PE xsections not the default yet"
REPLACE {$MCDF-PE-DEFAULT} WITH {.false.}
;
"Ali:photonuc, 2 lines"
REPLACE {$IPHOTONUCR-DEFAULT} WITH {0}
;
REPLACE {$PHOTONUC-XDATA-DEFAULT} WITH {'default'}
;
"EMH:emf, 7 lines"
REPLACE {$ExDEF} WITH {0}
;
REPLACE {$EyDEF} WITH {0}
;
REPLACE {$EzDEF} WITH {0}
;
REPLACE {$BxDEF} WITH {0}
;
REPLACE {$ByDEF} WITH {0}
;
REPLACE {$BzDEF} WITH {0}
;
REPLACE {$EMLMTDEF} WITH {0.02}
;

            "This macro sets the minimum step size for a condensed"
            "history (CH) step. When the exact BCA is used, the minimum"
            "CH step is determined by efficiency considerations only"
            "At about 3 elastic MFP's single scattering becomes more"
            "efficient than CH and so the algorithm switches off CH"
            "If one of the various inexact BCA's is invoked, this macro"
            "provides a simple way to include more sophisticated"
            "decisions about the maximum acceptable approximated CH step"

"The parameters passed to the macro in ELECTR are  eke and elke "

REPLACE {$SET-SKINDEPTH(#,#);} WITH
"        =================                  "
{
   $CALCULATE-ELASTIC-SCATTERING-MFP(ssmfp,{P1},{P2});
   skindepth = skindepth_for_bca*ssmfp;
}
;

"This macro calculates the elastic scattering MFP"
"If spin_effects is .false., the screened Rutherford cross section"
"is used, else the the elastic MFP is based on PWA cross sections"

REPLACE {$CALCULATE-ELASTIC-SCATTERING-MFP(#,#,#);} WITH
"        =======================================           "
{
    blccl = rhof*blcc(medium);
    xccl  = rhof*xcc(medium);
    p2 = {P2}*({P2}+rmt2); beta2 = p2/(p2 + rmsq);
    IF ( spin_effects ) [
      IF(lelec < 0) [ $EVALUATE etap USING etae_ms({P3}); ]
      ELSE          [ $EVALUATE etap USING etap_ms({P3}); ]
      $EVALUATE ms_corr USING blcce({P3});
      blccl = blccl/etap/(1+0.25*etap*xccl/blccl/p2)*ms_corr;
    ]
    {P1}=beta2/blccl;
}
;

REPLACE {$SINGLE-SCATTERING(#);} WITH
"        ======================                     "
{
    $SET-SCREENING-ANGLE({P1});
    call sscat(chia2,costhe,sinthe);
}
;

"The following macro will allow the use of better single scattering"
"cross sections (PWA) and/or to take into account double counting  "
"of the contribution of atomic electrons to the scattering power   "

REPLACE {$SET-SCREENING-ANGLE(#);} WITH
"        ========================                   "
{
    chia2   = xcc(medium)/(4*{P1}*({P1} + rmt2)*blcc(medium));
}
;

REPLACE {$HARD-SCATTERING;} WITH {;}
;

REPLACE {$TURN_OFF_SCATTERING} WITH {;}
;
"If the above is redefined in a user code or uncommented here                 "
"REPLACE {$TURN_OFF_SCATTERING} WITH {;cost = 1.000; sint = 0.000; return;}   "
"this will turn off all single and multiple scattering                        "
"DR April 2012   see corresponding 2 additions to egsnrc,mortran in           "
"                subroutines sscat and mscat

%E "egsnrc.macros"

REPLACE {$CALL-HOWFAR-IN-ELECTR;} WITH {;
  IF(callhowfar | wt(np) <= 0) [ call howfar; ]
};

REPLACE {$CALL-HOWFAR-IN-PHOTON;} WITH {;
  IF( ustep > dnear(np) | wt(np) <= 0 ) [ call howfar; ]
};

REPLACE {$CALL-HOWNEAR(#);} WITH
{
    OUTPUT 35; "35 in decimal is ascii code for the pound sign"
    (
        ' '/
        ' '/
        ' ***************************************************************'/
        ' ***************************************************************'/
        ' '/
        ' PRESTA-II is aborting execution because you have not defined   '/
        ' the HOWNEAR macro for your geometry.                           '/
        ' '/
        ' You MUST either do so or employ a limited form of PRESTA-II    '/
        ' which does not attempt the refined boundary crossing or lateral'/
        ' correlation features of the algorithm.                         '/
        ' '/
        ' If you include the following macro in your usercode:           '/
        ' '/
        ' REPLACE {$CALL-HOWNEAR(',a,');} WITH {;}                       '/
        ' '/
        ' you can choose between single scattering mode (very slow) and  '/
        ' standard EGS4 mode (no PRESTA enhancments) by the appropriate  '/
        ' choice of the parameters in your input file (see the PRESTA-II '/
        ' manual)                                                        '/
        ' '/
        ' ***************************************************************'/
        ' ***************************************************************'/
        ' '/
        ' '/
    );
    stop;
}

"For compability with user codes with PRESTA-I implemented"
REPLACE {$PRESTA-INPUT-SUMMARY;} WITH {;}
REPLACE {$PRESTA-INPUTS;}        WITH {;}

"If you want to read P-II inputs using the get_input() routine by "
"A. Merovitz and D.W.O.R. you need to either place the following  "
"three macros at the top of your user code, or after the default"
"definitions given below"

;

REPLACE {$USE-GET-INPUTS} WITH {.true.} "To not use get_input replace this "
                                        "with .false.                      "

"The following are the ones used by default"


REPLACE {$USE-GET-INPUTS} WITH {.false.}


;
%E    "egsnrc.macros"

"Macro for azimuthal angle selection
"using a sampling within a box method
"Choose a point randomly within a box such that
"-1 <= x <= 1 and 0 <= y < = 1
"Reject the set if it lies without the inscribed unit semicircle centered
"at (x,y) = (0,0)
"once out of the loop, use the trigonimetric relations (TeX notation)
"\cos 2\phi = (x^2 - y^2)/(x^2 + y^2)
"\sin 2\phi = 2xy/(x^2 + y^2)
REPLACE {$SELECT-AZIMUTHAL-ANGLE(#,#);} WITH
{
;
LOOP
[
    $RANDOMSET xphi;
    xphi  = 2*xphi - 1;
    xphi2 = xphi*xphi;
    $RANDOMSET yphi;
    yphi2  = yphi*yphi;
    rhophi2 = xphi2 + yphi2;
]WHILE(rhophi2 > 1);
rhophi2 = 1/rhophi2;
{P1}  = (xphi2 - yphi2)*rhophi2;
{P2}  = 2*xphi*yphi*rhophi2;
}
;

REPLACE {$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;} WITH {;
  $REAL xphi,xphi2,yphi,yphi2,rhophi2;
};

%E     "egsnrc.macros"
"************************************************************************"
"                                                                        "
"                 Definitions of local variables                         "
"                                                                        "
"************************************************************************"

REPLACE {$DEFINE-LOCAL-VARIABLES-ANNIH;} WITH
{;
"Local variables in order of appearance"
$ENERGY PRECISION
      PAVIP,    "precise total energy in the laboratory frame"
      PESG1,    "precise energy of 1st annihilation photon"
      PESG2;    "precise energy of 2nd annihilation photon"
$REAL AVIP,     "total energy in the laboratory frame"
      A,        "total energy in units of the electron's rest energy"
      G,T,P,    "energy, kinetic energy and momentum in units of RM"
      POT,      "P/T"
      EP0,      "minimum fractional energy"
      WSAMP,    "to avoid un-necessary calc. of Log((1-ep0)/ep0)"
      RNNO01,   "random numbers"
      RNNO02,
      EP,       "fractional energy of the more energetic photon"
      REJF,     "rejection function"
      ESG1,     "energy of the more energetic photon"
      ESG2,     "energy of the less energetic photon"
      aa,bb,cc,sinpsi,sindel,cosdel,us,vs,cphi,sphi;
                "for inline rotations"
$INTEGER
      ibr;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-BHABHA;} WITH
{;
"Local variables in order of appearance"
$ENERGY PRECISION
      PEIP,     "precise total energy of incident positron"
      PEKIN,    "precise kinetic energy of incident positron"
      PEKSE2,   "precise kinetic energy of second 'electron'"
      PESE1,    "precise total energy of first 'electron'"
      PESE2,    "precise total energy of second 'electron'"
      H1,       "used in direction cosine calculations"
      DCOSTH;   "polar scattering angle for more energetic 'electron'"
$REAL EIP,      "total energy of incident positron"
      EKIN,     "kinetic energy of incident positron"
      T0,       "kinetic energy of incident positron in units of RM"
      E0,       "total energy of incident positron in units of RM"
      E02,      "E0**2"
      YY,       "1/(T0+2)"
      Y2,YP,YP2,"various functions of YY"
      BETA2,    "incident positron velocity in units of c"
      EP0,      "minimum fractional energy of a secondary 'electron'"
      EP0C,     "1-EP0"
      B1,B2,B3,B4,  "used in rejection function calculation"
      RNNO03,RNNO04,"random numbers"
      BR,       "kinetic energy fraction of the 2nd 'electron'"
      REJF2,    "rejection function"
      ESE1,     "total energy of 1st 'electron'"
      ESE2;     "total energy of 2nd 'electron'"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-BREMS;} WITH
{;
"Local variables in order of appearance"
$ENERGY PRECISION
  PEIE,   "precise incident electron energy"
  PESG,   "presice energy of emitted photon"
  PESE;   "precise total energy of scattered electron"
$REAL
  EIE,    "total incident electron energy"
  EKIN,   "kinetic incident energy"
  brmin,  " ap(medium)/ekin"
  waux,   "for faster sampling of 1/br"
  aux,    "ese/eie"
  r1,     "a random number"
  ajj,    "for energy bin determination if alias sampling is employed"
  alias_sample1,
  RNNO06, "random number"
  RNNO07, "random number"
  BR,     "energy fraction of secondary photon"
  ESG,    "energy of secondary photon"
  ESE,    "total energy of secondary electron"
  DELTA,  "scaled momentum transfer"
  phi1,   "screening function"
  phi2,   "screening function"
  REJF;   "screening rejection function"

"Brems angle selection variables"
$REAL
  a,b,c,  "direction cosines of incident `electron'"
  sinpsi, sindel, cosdel, us, vs,
          "all used for rotations"
  ztarg,  "(Zeff**1/3/111)**2, used for 2BS angle sampling"
  tteie,  "total energy in units of rest energy"
  beta,   "electron velocity in units of speed of light"
  y2max,  "maximum possible scaled angle"
  y2maxi, "inverse of the above"
  ttese,  "new electron energy in units of rm"
  rjarg1,rjarg2,rjarg3,rejmin,rejmid,rejmax,rejtop,rejtst,
          "all of them used for angle rejection function calcs"
  esedei, "new total energy over old total energy"
  y2tst,  "scaled angle, costhe = 1 - 2*y2tst/y2max"
  y2tst1,
  rtest,  "random number for rejection"
  xphi,yphi,xphi2,yphi2,rhophi2,cphi,sphi;
          "all of the above is for azimuthal angle sampling"

$INTEGER
  L,L1,ibr,jj,j;

}
;

REPLACE {$DEFINE-VARIABLES-FOR-SET-BREMS-ANGLE;} WITH
{;
"Local variables for photon angle selection"
$REAL ZTARG,  "( (1/111)*Zeff**(1/3) )**2"
      TTEIE,  "total incident electron energy in units of RM"
      TTESE,  "total scattered electron energy in units of RM"
      ESEDEI, "TTESE/TTEIE"
      beta,   "electron speed in units of c"
      Y2MAX,  "maximum value of the scaled angle"
      RJARG1,RJARG2,RJARG3,
              "arguments for which the rejection function is calculated"
      REJMIN,REJMID,REJMAX,
              "corresponding values of the rejection function"
      REJTOP, "max(REJMIN,REJMID,REJMAX)"
      Y2TST,  "random number and candidate for a scaled angle"
      REJTST, "rejection function at Y2TST"
      Y2TST1, "aux. variable for rejection function calculation"
      REJTST_on_REJTOP  ,  "ratio for rejection test"
      RTEST;  "random number for rejection"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT;} WITH
{;
"Local COMPT variables in order of appearance"
$ENERGY PRECISION
      PEIG,   "precise energy of incident photon"
      PESG,   "precise energy of scattered photon"
      PESE;   "precise total energy of compton electron"
$REAL ko,     "energy of incident photon in units of RM"
      broi,   "1+2*ko"
      broi2,  "broi*broi"
      bro,    "1/broi"
      bro1,   "1-bro"
      alph1,  "probability for the 1/BR part"
      alph2,  "probability for the BR part"
      alpha,  "alpha1/(alph1+alph2)"
      rnno15,rnno16,rnno17,rnno18,rnno19,
              "random numbers"
      br,     "scattered photon energy fraction"
      temp,   "aux. variable for polar angle calculation"
      rejf3,  "rejection function"
      rejmax, "max. of rejf3 in thge case of uniform sampling"
      Uj,     "binding energy of the selected shell"
      Jo,     "the Compton profile parameter"
      br2,    "br*br"
      fpz,fpz1,"used for limited pz-range rejection"
      qc,     "momentum transfer corresponding to the Compton line energy"
      qc2,    "qc squared"
      af,     "for calculating F"
      Fmax,   "maximum of F"
      frej,   "used for F-rejection"
      eta_incoh, eta, "random numbers"
      aux,aux1,aux2,aux3,aux4, "aux. variables"
      pzmax,  "max. possible z-component of the initial electron momentum"
      pz,     "initial electron momentum projection"
      pz2,    "pz*pz"
      rnno_RR;"for playing Russian Roulette"
$INTEGER
      irl,    "local region number"
      i,      "loop variable for shell sampling (and then shell sampled)"
      j,      "pointer to the shell in the shell data list"
      iarg,   "argument for ausgab call"
      ip;     "a loop variable"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT-old;} WITH
{;
"Local COMPT variables in order of appearance"
$ENERGY PRECISION
      PEIG,   "precise energy of incident photon"
      PESG,   "precise energy of scattered photon"
      PESE;   "precise total energy of compton electron"
$REAL ko,     "energy of incident photon in units of RM"
      broi,   "1+2*ko"
      broi2,  "broi*broi"
      bro,    "1/broi"
      bro1,   "1-bro"
      alph1,  "probability for the 1/BR part"
      alph2,  "probability for the BR part"
      alpha,  "alpha1/(alph1+alph2)"
      rnno15,rnno16,rnno17,rnno18,rnno19,
              "random numbers"
      br,     "scattered photon energy fraction"
      temp,   "aux. variable for polar angle calculation"
      rejf3,  "rejection function"
      rejmax, "max. of rejf3 in thge case of uniform sampling"
      Uj,     "binding energy of the selected shell"
      br2,    "br*br"
      aux,aux1,aux2,"aux. variables"
      pzmax2, "max. possible momentum transfer squared"
      pz,     "momentum transfer prejection"
      pz2,    "pz*pz"
      rnno_RR;"for playing Russian Roulette"
$INTEGER
      irl,    "local region number"
      i,      "loop variable for shell sampling (and then shell sampled)"
      j,      "pointer to the shell in the shell data list"
      iarg,   "argument for ausgab call"
      ip;     "a loop variable"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-ELECTR;} WITH
{;
" Local ELECTR variables"
$ENERGY PRECISION "($ENERGY PRECISION means double precision)"
    demfp,        "differential electron mean free path"
    peie,         "precise energy of incident electron"
    total_tstep,  "total path-length to next discrete interaction"
    total_de      "total energy loss to next discrete interaction"
;
$REAL
    ekems,      "kinetic energy used to sample MS angle (normally midpoint)"
    elkems,     "Log(ekems)"
    chia2,      "Multiple scattering screening angle"
    etap,       "correction to Moliere screening angle from PWA cross sections"
    lambda,     "number of mean free paths (elastic scattering cross section)"
    blccl,      "blcc(medium)*rhof"
    xccl,       "xcc(medium)*rhof"
    xi,         "used for PLC calculations (first GS moment times path-length)"
    xi_corr,    "correction to xi due to spin effects"
    ms_corr,
    p2,         "electron momentum times c, squared"
    beta2,      "electron speed in units of c, squared"
    de,         "energy loss to dedx"
    save_de,    "de saved before $DE-FLUCTUATION"
    dedx,       "stopping power after density scaling"
    dedx0,      "stopping power before density scaling"
    dedxmid,    "stopping power at mid-step before density scaling"
    ekei,       "used in $CALCULATE-TSTEP-FROM-DEMFP;"
    elkei,      "Log(ekei), used in $CALCULATE-TSTEP-FROM-DEMFP;"
    aux,        "aux. variable"
    ebr1,       "e- branching ratio into brem"
    eie,        "energy of incident electron"
    ekef,       "kinetic energy after a step"
    elkef,      "Log(ekef)"
    ekeold,     "kinetic energy before a step"
    eketmp,     "used to evaluate average kinetic energy of a step"
    elktmp,     "log(eketmp)"
    fedep,      "fractional energy loss used in stopping power calculation"
    tuss,       "sampled path-length to a single scattering event"
    pbr1,       "e+ branching ratio into brem"
    pbr2,       "e+ branching ratio into brem or Bhabha"
    range,      "electron range"
    rfict,      "rejection function for fictitious cross section"
    rnne1,      "random number"
    rnno24,     "random number"
    rnno25,     "random number"
    rnnotu,     "random number"
    rnnoss,     "random number"
    sig,        "cross section after density scaling but before a step"
    sig0,       "cross section before density scaling but before a step"
    sigf,       "cross section before density scaling but after a step"
    skindepth,  "skin depth employed for PRESTA-II boundary crossing"
    ssmfp,      "distance of one single elastic scattering mean free path"
    tmxs,       "electron step-size restriction"
    tperp,      "perpendicular distance to the closest boundary"
    ustep0,     "temporary storage for ustep"
    uscat,      "x-axis direction cosine for scattering"
    vscat,      "y-axis direction cosine for scattering"
    wscat,      "z-axis direction cosine for scattering"
    xtrans,     "final x-axis position after transport"
    ytrans,     "final y-axis position after transport"
    ztrans,     "final z-axis position after transport"
    cphi,sphi;  "for azimuthal angle selection for annih at rest"

$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;

$INTEGER
    iarg,      "calling code for ausgab"
    idr,       "calling code for ausgab"
    ierust,    "error counter for negative ustep errors"
    irl,       "region number"
    lelec,     "charge of electron"
    qel,       " = 0 for electrons, = 1 for positrons "
    lelke,     "index into the energy grid of tabulated functions"
    lelkems,   "index into the energy grid of tabulated functions"
    lelkef,    "index into the energy grid of tabulated functions"
    lelktmp,   "index into the energy grid of tabulated functions"
    ibr;       "a loop variable"

$LOGICAL
    "BCA = boundary crossing algorithm"
    callhowfar, "= .true.  => BCA requires a call to howfar"
                "= .false. => BCA does not require a call to howfar"
    domultiple, "= .true.  => inexact BCA requires multiple scattering"
    dosingle,   "= .true.  => exact BCA requires single scattering"
                "= .false. => exact BCA requires no single scattering"
    callmsdist, "= .true.  => normal condensed-history transport"
                "= .false. => one of the BCA's will be invoked"
    findindex,  "used for mscat"
    spin_index, "used for mscat with spin effects"
    compute_tstep
;
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-HATCH;} WITH
{;
"Local HATCH variables in alphabetical order"

$TYPE MBUF(72),MDLABL(8);

$REAL
    ACD   , "used to test goodness of sine-table look-up"
    ADEV  , "absolute deviation in sine-table look-up"
    ASD   , "used to test goodness of sine-table look-up"
    COST  , "cos(theta) from instrinsic library function"
    CTHET , "use to calculate cos(theta) according to look-up tables"
    DEL   , "leat squares delta for sine-table look-up"
    DFACT , "converts rl to dunits"
    DFACTI, "converts rl**-1 to dunits**-1"
    DUNITO, "units scaling varable"
    DUNITR, "saved value of dunit"
    FNSSS , "real form of integer nsinss"
    P     , "counter used in the pwr2i(i) = 1/2**(i - 1) construction"
    PZNORM, "used in $INITIALIZE-BREMS-ANGLE"
    RDEV  , "relative deviation in sine-table look-up"
    S2C2  , "sinthe**2 + costhe**2, used to test look-up table"
    S2C2MN, "min(s2c2)"
    S2C2MX, "max(s2c2)"
    SINT  , "sin(theta) from instrinsic library function"
    SX    , "sum of angles for least squared analysis of look-up table errors"
    SXX   , "sum**2 of angles for least square analysis of look-up table errors"
    SXY   , "sum of angle*sin(angle) for least squared analysis of look-up"
            "table errors"
    SY    , "sum of sin(angle) for least squared analysis of look-up table "
            "errors"
    WID   , "width of sine-table mesh sub-interval (sine-table algorithm)"
    XS    , "angle value in a sub-sub-interval (sine-table algorithm)"
    XS0   , "lower limit of a sub-sub-interval (sine-table algorithm)"
    XS1   , "upwer limit of a sub-sub-interval (sine-table algorithm)"
    XSI   , "beginning angle of a sun-interval (sine-table algorithm)"
    WSS   , "width of a sub-sub-interval (sine-table algorithm)"
    YS    , "sin(angle) for least squared analysis of look-up table errors"
    ZEROS(3); "zeros of sine, 0,pi,twopi"

$INTEGER
    I     , "generic do-loop variable"
    I1ST  , "flag = 0 on first pass"
    IB    , "do-loop variable used for reading the medium type"
    ID    , "integer value of -dunit, when dunit is negative"
    IE    , "do-loop variable for reading over elements in a compound/mixture"
    IL    , "do-loop variable used for reading the medium type"
    IM    , "do-loop variable looping over nmed, number of media"
    IRAYL , "Rayleigh switch read in from PEGS"
    IRN   , "do-loop variable over random set of sine-table look-ups"
    ISTEST, "flag that switches on test of sine function fit"
    ISUB  , "do-loop variable over sub-intervals of the sine look-up table"
    ISS   , "do-loop variable over sub-sub-intervals of the sine look-up table"
    IZ    , "used to locate an exact zero of a sun-interval mesh point in the"
            "sine-table look-up"
    IZZ   , "do-loop variable over the exact zeros of the sine-table look-up"
    J     , "do-loop variable looping over nmed, number of media"
    JR    , "do-loop variable looping over number of regions"
    LCTHET, "$SET INTERVAL index for cos(theta) from look-up table"
    LMDL  , "character width of medium header ' MEDIUM='"
    LMDN  , "character width of medium description"
    LTHETA, "$SET INTERVAL index for sin(theta) from look-up table"
    MD    , "temporary storage for the medium number"
    MXSINC, "number of intervals approximating the sine function"
    NCMFP , "array size input from PEGS. Currently 0, but probably intended"
            "to be cumulative electron mean free path. Presently unused."
    NEKE  , "array size input from PEGS."
            "Number of electron mapped energy intervals."
    NGE   , "array size input from PEGS."
            "Number of photon mapped energy intervals."
    NGRIM , "Rayleigh cross section array size."
    NISUB , "mxsinc - 2. Size of array with endpoints removed."
    NLEKE , "array size input from PEGS. Currently 0, but probably intended"
            "to be number of electron energy intervals below threshold."
            "Presently unused."
    NM    , "number of media found in the "
    NRANGE, "array size input from PEGS. Currently 0, but probably intended"
            "to be number of intervals in an array giving the electron range."
            "Presently unused."
    NRNA  , "number of random angles testing sine function fit"
    NSEKE , "array size input from PEGS. Currently 0, but probably intended"
            "to be number of electron small energy intervals. Presently unused."
    NSGE  , "array size input from PEGS. Currently 0, but probably intended"
            "to be number of gamma small energy intervals. Presently unused."
    NSINSS, "number of sub-intervals for each sine function interval"
    LOK($MXMED); "flag indicating that medium has been found in the PEGS "
                 "datafile"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-MOLLER;} WITH
{;
"Local MOLLER variables in order of their appearance"

$ENERGY PRECISION
     PEIE,   "precise total energy of incident electron"
     PEKSE2, "precise kinetic energy of 2nd secondary electron"
     PESE1,  "precise total energy of 1st secondary electron"
     PESE2,  "precise total energy of 2nd secondary electron"
     PEKIN,  "precise kinetic energy of incident electron"
     H1,     "used for polar scattering angle calculation"
     DCOSTH; "polar scattering angle squared"
$REAL EIE,    "total energy of incident electron"
     EKIN,   "kinetic energy of incident electron"
     T0,     "kinetic energy of incident electron in units of RM"
     E0,     "total energy of incident electron in units of RM"
     EXTRAE, "energy above the Moller threshold"
     E02,    "E0**2"
     EP0,    "minimum alowed kinetic energy fraction"
     G2,G3,  "used for rejection function calculation"
     GMAX,   "maximum value of the rejection function"
     BR,     "kinetic energy fraction to lowew energy electron"
     R,      "(1-BR)/BR"
     REJF4,  "rejection function"
     RNNO27, "random number for BR sampling"
     RNNO28, "random number for rejection"
     ESE1,   "energy of 1st secondary electron"
     ESE2;   "energy of 2nd secondary electron"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-PAIR;} WITH
{;
"Local PAIR variables in order of their appearance"
$ENERGY PRECISION
      PEIG,      "precise energy of incident photon"
      PESE1,     "precise energy of 1st 'electron'"
      PESE2;     "precise energy of 2nd 'electron'"

$REAL EIG,       "energy of incident photon"
      ESE2,      "total energy of lower energy 'electron'"
      RNNO30,RNNO31,rnno32,rnno33,rnno34,
                 "random numbers"
      DELTA,     "scaled momentum transfer"
      REJF,      "screening rejection function"
      rejmax,    "the maximum of rejf"
      aux1,aux2, "auxilary variables"
      Amax,      "Maximum of the screening function used with (br-1/2)**2"
      Bmax,      "Maximum of the screening function used with the uniform part"
      del0,      "delcm*eig"
      br,        "fraction of the available energy (eig-rmt2) going to the"
                 "lower energy `electron'"
      Eminus,Eplus,Eavail,rnno_RR;

$INTEGER
      L,L1;  "flags for high/low energy distributions"
}
;

REPLACE {$DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;} WITH
{;
$REAL ESE,   "total energy of one of the 'electrons'"
      PSE,   "momentum corresponding to ESE"
      ZTARG, "( (1/111)*Zeff**(1/3) )**2"
      TTEIG, "incident photon energy in units of RM"
      TTESE, "energy of one of the 'electrons' in units of RM"
      TTPSE, "momentum of one of the 'electrons' in units of RM"
      ESEDEI,"TTESE/(TTEIG-TTESE) = ratio of secondary electron energies"
      ESEDER,"1/ESEDEI"
      XIMIN, "1st argument where rejection function might have a maximum"
      XIMID, "2nd argument where rejection function might have a maximum"
      REJMIN,"rejection function at XIMIN"
      REJMID,"rejection function at XIMID"
      REJTOP,"max(REJMIN,REJMID)"
      YA,XITRY,GALPHA,GBETA,
             "aux. variables for XIMID calculation"
      XITST, "random number for pair angle sampling"
      REJTST_on_REJTOP  ,  "ratio for rejection test"
      REJTST,"rejection function at XITST"
      RTEST; "random number for rejection"
$INTEGER
      ICHRG; "loop variable"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTO;} WITH
{;
"Local PHOTO variables in order of their appearance"

$ENERGY PRECISION
      PEIG;         "precise energy of incident photon"
$REAL BR,           "random number"
      sigma,        "elemental cross section"
      aux,aux1,     "aux. variables"
      probs($MXEL), "probability for an interaction with a given element"
      sigtot,       "total cross section"
      e_vac,        "shell binding energy"
      rnno_RR;      "for playing Russian Roulette"
$INTEGER
      IARG,         "AUSGAB calling switch"
      iZ,           "Atomic number of the element the photon is "
                    "interactiong with"
      irl,          "local region number"
      ints($MXEL),  "energy interval number for a given element"
      j,ip,         "loop variables"
      n_warning,    "a warning counter"
      k;            "shell number"

$LOGICAL
      do_relax;
save  n_warning;
}
;

REPLACE {$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;} WITH
{;
"Photo-electron angle selection variables"
$REAL EELEC, "total energy of photo-electron"
      BETA,  "velocity of electron in units of c"
      GAMMA, "total energy of photo-electron in units of RM"
      ALPHA, "kinematic factor"
      RATIO, "=BETA/ALPHA"
      RNPHT, "random number"
      FKAPPA,"aux. variable for COSTHE calculation"
      XI,    "used in rejection function calculation"
      SINTH2,"SINTHE**2"
      RNPHT2;"random number for rejection"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-EDGSET;} WITH
{;
"Local EDGSET variables in order of their appearance"
$REAL EALF(100),EBET(100),OMEG(100),PHOTOK(100),PKA(100);
      "see the data statements in EDGSETfor definition of these arrays"
$INTEGER JJ,IZ,IMED,I;
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTON;} WITH
{;
"Local PHOTON variables in order of their appearance"
$ENERGY PRECISION
    PEIG;   "precise photon energy"
;
$REAL
    EIG,    "photon energy"
    RNNO35, "random number for default MFP selection"
    GMFPR0, "photon MFP before density scaling and coherent correction"
    GMFP,   "photon MFP after density scaling"
    COHFAC, "Rayleigh scattering correction"
    RNNO37, "random number for Rayleigh scattering selection"
    XXX,    "random number for momentum transfer sampling in Rayleigh"
    X2,     "scaled momentum transfer in Rayleigh scattering event"
    Q2,     "momentum transfer squared in Rayleigh scattering event"
    CSQTHE, "COSTHE**2"
    REJF,   "Rayleigh scattering rejection function"
    RNNORJ, "random number for rejection in Rayleigh scattering"
    RNNO36, "random number for interaction branching"
    GBR1,   "probability for pair production"
    GBR2,   "probability for pair + compton"
    T,      "used for particle exchange on the stack"
"Ali:photonuc, 2 lines"
    PHOTONUCFAC, "photonuclear correction"
    RNNO39; "random number for photonuclear selection (RNNO38 is taken)"
;
$INTEGER
    IARG,   "parameter for AUSGAB"
    IDR,    "parameter for AUSGAB"
    IRL,    "region number"
    LGLE,   "index for GMFP interpolation"
    LXXX;   "index for Rayleigh scattering cummulative distribution int."
}
;

"Ali:photonuc, 1 block"
REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTONUC;} WITH {;}
;

" Handling track-ends "
" By default, just call AUSGAB and drop energy on the spot"

REPLACE {$ELECTRON-TRACK-END;} WITH {; $AUSCALL(idr); }
REPLACE {$PHOTON-TRACK-END;}   WITH {; $AUSCALL(IDR); }
;

" Macros for the fictitious method  "
"==================================="

" The following version uses sub-threshold energy loss "
" as a measure of path-length => cross section is actual "
" cross section divided by restricted stopping power "
" The global maximum of this quantity called esig_e (electrons) or "
" psig_e (positrons) and is determined in HATCH "

REPLACE {$EVALUATE-SIG0;} WITH
"        ==============="
{;
   IF( sig_ismonotone(qel,medium) ) [
       $EVALUATE-SIGF; sig0 = sigf;
   ]
   ELSE [
       IF( lelec < 0 ) [sig0 = esig_e(medium);]
       ELSE            [sig0 = psig_e(medium);]
   ]
}

REPLACE {$EVALUATE-SIGF;} WITH
"        ==============="
{;
  IF(lelec < 0)
  [
      $EVALUATE sigf USING esig(elke);
      $EVALUATE dedx0 USING ededx(elke);
      sigf = sigf/dedx0;
  ]
  ELSE
  [
      $EVALUATE sigf USING psig(elke);
      $EVALUATE dedx0 USING pdedx(elke);
      sigf = sigf/dedx0;
  ]
}
;

REPLACE {$EVALUATE-EBREM-FRACTION;} WITH {
    $EVALUATE ebr1 USING ebr1(elke);
};
REPLACE {$EVALUATE-PBREM-FRACTION;} WITH {
    $EVALUATE pbr1 USING pbr1(elke);
};
REPLACE {$EVALUATE-BHABHA-FRACTION;} WITH {
    $EVALUATE pbr2 USING pbr2(elke);
};


" Because the cross section is interactions per energy loss, no "
" rhof-scaling is required "
REPLACE {$SCALE-SIG0;} WITH
"        ============"
{
   sig = sig0;
}
;

" Once the sub-threshold processes energy loss to the next discrete "
" interaction is determined, the corresponding path-length has to be"
" calculated. This is done by the macro below. This macro           "
" assumes the energy at the begining to be eke, the logarithm of it "
" elke, lelke - the corresponding interpolation index and makes     "
" use of $COMPUTE-DRANGE(#,#,#,#,#,#)                               "

REPLACE {$CALCULATE-TSTEP-FROM-DEMFP;} WITH
"        ============================"
{;
  IF( compute_tstep ) [
    total_de = demfp/sig; fedep = total_de;
    ekef  = eke - fedep;
    IF( ekef <= E_array(1,medium) ) [ tstep = vacdst; ]
    ELSE
    [
      elkef = Log(ekef);
      $SET INTERVAL elkef,eke;
      IF( lelkef = lelke )
      [       " initial and final energy are in the same interpolation bin "
          $COMPUTE-DRANGE(eke,ekef,lelke,elke,elkef,tstep);
      ]
      ELSE
      [   " initial and final energy are in different interpolation bins, "
          " calc range from ekef to E(lelkef+1) and from E(lelke) to eke  "
          " and add the pre-calculated range from E(lelkef+1) to E(lelke) "
          ekei = E_array(lelke,medium);
          elkei = (lelke - eke0(medium))/eke1(medium);
          $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,tuss);
          ekei = E_array(lelkef+1,medium);
          elkei = (lelkef + 1 - eke0(medium))/eke1(medium);
          $COMPUTE-DRANGE(ekei,ekef,lelkef,elkei,elkef,tstep);
          tstep=tstep+tuss+
                  range_ep(qel,lelke,medium)-range_ep(qel,lelkef+1,medium);
      ]
    ]
    total_tstep = tstep;
    compute_tstep = .false.;
  ]
  tstep = total_tstep/rhof;  " non-default density scaling "
}
;

" The following macro computes the path-length traveled while going from  "
" energy {P1} to energy {P2}, both energies being in the same             "
" interpolation bin, given by {P3}. {P4} and {P5} are the logarithms of   "
" {P1} and {P2}. The expression is based on logarithmic interpolation as  "
" used in EGSnrc (i.e. dedx = a + b*Log(E) ) and a power series expansion "
" of the ExpIntegralEi function that is the result of the integration.    "
" The result is returned in {P6}.                                         "

REPLACE {$COMPUTE-DRANGE(#,#,#,#,#,#);} WITH
"        ============================="
{
  fedep = 1 - {P2}/{P1};
  elktmp = 0.5*({P4}+{P5}+0.25*fedep*fedep*(1+fedep*(1+0.875*fedep)));
           " the above evaluates the logarithm of the midpoint energy"
  lelktmp = {P3};
  IF(lelec < 0) [
      $EVALUATE dedxmid USING ededx(elktmp);
      dedxmid = 1/dedxmid;
      aux = ededx1(lelktmp,medium)*dedxmid;
      "aux = ededx1(lelktmp,medium)/dedxmid;"
  ]
  ELSE [
      $EVALUATE dedxmid USING pdedx(elktmp);
      dedxmid = 1/dedxmid;
      aux = pdedx1(lelktmp,medium)*dedxmid;
      "aux = pdedx1(lelktmp,medium)/dedxmid;"
  ]
  aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6;
  "{P6} = fedep*{P1}/dedxmid*(1+aux);"
  {P6} = fedep*{P1}*dedxmid*(1+aux);
}
;

" The following macro computes the range to the minimum table energy "
" It uses $COMPUTE-DRANGE                                            "
" Note that range_ep array is precomputed in subroutine mscati and   "
" gives the range from the energy interval end points to AE for each "
" medium.

REPLACE {$COMPUTE-RANGE;} WITH
"        ==============="
{
;
  ekei = E_array(lelke,medium);
  elkei = (lelke - eke0(medium))/eke1(medium);
  $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,range);
  range = (range + range_ep(qel,lelke,medium))/rhof;
}
;

/******* trying to save evaluation of range.
REPLACE {$COMPUTE-RANGE;} WITH {;
"        ==============="
  IF( do_range ) [
      ekei = E_array(lelke,medium);
      elkei = (lelke - eke0(medium))/eke1(medium);
      $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,range);
      the_range = range + range_ep(qel,lelke,medium);
      do_range = .false.;
  ]
  range = the_range/rhof;
};
******************/

" The following macro updates demfp. As energy loss is used as the  "
" 'path-length' variable (see above), it just substracts the energy "
" loss for the step.                                                "
REPLACE {$UPDATE-DEMFP;} WITH
"        =============="
{
  demfp = demfp - save_de*sig;
  total_de = total_de - save_de;
  total_tstep = total_tstep - tvstep*rhof;
  IF( total_tstep < 1e-9 ) [ demfp = 0; ]
}
;

" The following macro computes the energy loss due to sub-threshold "
" processes for a path-length {P1}. The energy at the beginning of  "
" the step is {P2}, {P3}=Log({P2}), {P4} is the interpolation index "
" The formulae are based on the logarithmic interpolation for dedx  "
" used in EGSnrc. The result is returned in {P5}. Assumes that      "
" initial and final energy are in the same interpolation bin.       "

REPLACE {$COMPUTE-ELOSS(#,#,#,#,#);} WITH
"        =========================="
{;
  IF( lelec < 0 ) [
      $EVALUATE dedxmid USING ededx({P3});
      aux = ededx1({P4},medium)/dedxmid;
  ]
  ELSE [
      $EVALUATE dedxmid USING pdedx({P3});
      aux = pdedx1({P4},medium)/dedxmid;
  ]
  /*
  {P5} = dedxmid*{P1};  " Energy loss using stopping power at the beginning "
  */
  {P5} = dedxmid*{P1}*rhof; "IK: rhof scaling bug, June 9 2006"
                            "rhof scaling must be done here and NOT in "
                            "$COMPUTE-ELOSS-G below!"
  fedep = {P5}/{P2};
  {P5} = {P5}*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1-
             0.25*fedep*(2-aux*(4-aux)))));
}
;

" The following is a generalized version of $COMPUTE-ELOSS.        "

REPLACE {$COMPUTE-ELOSS-G(#,#,#,#,#);} WITH
"        ============================"
{
  tuss = range - range_ep(qel,{P4},medium)/rhof;
    " here tuss is the range between the initial energy and the next lower "
    " energy on the interpolation grid "
  IF( tuss >= {P1} ) [  " Final energy is in the same interpolation bin "
      $COMPUTE-ELOSS({P1},{P2},{P3},{P4},{P5});
      /* {P5} = {P5}*rhof; "IK, rhof bug"  */
      "IK: rhof scaling bug, June 9 2006. rhof scaling is done in "
      "    $COMPUTE-ELOSS above!                                  "
  ]
  ELSE [ " Must find first the table index where the step ends using "
         " pre-calculated ranges                                     "
      lelktmp = {P4};
      tuss = (range - {P1})*rhof;
         " now tuss is the range of the final energy electron "
         " scaled to the default mass density from PEGS4      "
      IF( tuss <= 0 ) [ {P5} = {P2} - TE(medium)*0.99; ]
        " i.e., if the step we intend to take is longer than the particle "
        " range, the particle energy goes down to the threshold "
        "({P2} is the initial particle energy)  "
        "originally the entire energy was lost, but msdist_xxx is not prepared"
        "to deal with such large eloss fractions => changed July 2005."
      ELSE [
          WHILE ( tuss < range_ep(qel,lelktmp,medium) ) [
              lelktmp = lelktmp - 1; ]
          elktmp = (lelktmp+1-eke0(medium))/eke1(medium);
          eketmp = E_array(lelktmp+1,medium);
          "tuss = range_ep(qel,lelktmp+1,medium) - tuss;"
          "IK: rhof scaling bug, June 9 2006: because of the change in "
          "    $COMPUTE-ELOSS above, we must scale tuss by rhof        "
          tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof;
          $COMPUTE-ELOSS(tuss,eketmp,elktmp,lelktmp,{P5});
          {P5} = {P5} + {P2} - eketmp;
      ]
  ]
}
;
%E  "egsnrc.macros"
"============================================================================"
"
"   The following is related to use of the NRC auxilliary get_inputs
"   routine which is part of the standard NRC user-codes.
"
"   It is not an essential part of EGSnrc but is most easily defined here.
"
"============================================================================"
"
" Input stuff for the get_inputs() routine.                                  "
" As the expirience has shown that get_inputs() is frequently used in several"
" subroutines, I changed the parameter passed to get_inputs() to a common    "
" block. Otherwise, the parameters have to be defined in each subroutine using"
" get_inputs() and, with static variables, this lead to a memory use         "
" explosion (e.g. 8 MB for CAVRZ vs. 0.8 MB without get_inputs()!)           "
" IK, Dec. 1998                                                              "

REPLACE {$NMAX} WITH {100};
REPLACE {$NVALUE} WITH {100};
REPLACE {$STRING80} WITH {80};
REPLACE {$STRING32} WITH {64};
REPLACE {$STRING40} WITH {40};
REPLACE {$STRING256} WITH {256};
REPLACE {$MXALINP} WITH {5};

REPLACE {COMIN/GetInput/;} WITH
"        ================"
{
  ;COMMON/GetInput/
        ALLOWED_INPUTS($NMAX,0:$MXALINP), "Associates a name with each second "
                                   "array index(0:4) for a value sought"
        VALUES_SOUGHT($NMAX),      "Name of each input                 "
        CHAR_VALUE($NMAX,$NVALUE), "For returning character inputs     "
        VALUE($NMAX,$NVALUE),      "For returning int. or real inputs  "
        DEFAULT($NMAX),            "Default value, only for type 0 & 1 "
        VALUE_MIN($NMAX),          "Min and max value defining         "
        VALUE_MAX($NMAX),          "the acceptable input range         "
        NVALUE($NMAX),             "Number of values per value sought  "
        TYPE($NMAX),               "Type of the value sought           "
                                   "0 for integer                      "
                                   "1 for real                         "
                                   "2 for character                    "
                                   "3 for character with allowed_inputs"
        ERROR_FLAGS($NMAX),        "An error flag for each of the      "
                                   "attempted inputs                   "
        i_errors,                  "Unit no. for .errors output file   "
        NMIN, NMAX,                "Minimum and maximum index number of"
                                   "the values sought                  "
        ERROR_FLAG,                "0 for no errors, 1 for errors      "
        DELIMETER;                 "Name of the delimeter              "
   character ALLOWED_INPUTS*$STRING32,VALUES_SOUGHT*$STRING32,
             CHAR_VALUE*$STRING256,DELIMETER*$STRING32;
   $REAL     VALUE,DEFAULT,VALUE_MIN,VALUE_MAX;
   $INTEGER  NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors;
}
;

REPLACE {$GET_INPUT(#);} WITH { NMIN = {P1}; NMAX = {P1}; CALL GET_INPUT; }
;

REPLACE {$GET_INPUTS(#,#);} WITH { NMIN = {P1}; NMAX = {P2}; CALL GET_INPUT; }
;

"The following macro is used in the egs_init1 subroutine (in the file
"egs_utilities.mortran.  Here it is replaced by null so that we insist that
"the .egsinp file be opened with unit=5 (standard input) and the .egslog
"file (if required) be opened with unit=6 (standard output).  This is
"replaced by a search for available units in beamnrc_lib.mortran to avoid
"unit collisions with BEAM shared library sources

REPLACE {$AVAILABLE_UNIT(#,#)} WITH {;}

" The following two macros are defined so that if the nrcaux.mortran file
" is included in the configuration file these are defined at least.
" If the NRC statistics routine  SIGMA is to be used these must have realistic
" definitions in the user-code.

REPLACE {$MXDATA} WITH {1};
REPLACE {$STAT} WITH {2};

%E  "egsnrc.macros"
"============================================================================"
"   The following is related to use of the NRC auxilliary
"   routine xvgrplot which is called from some of the standard
"   NRC user-codes.
"
"   It is not an essential part of EGSnrc but is most easily defined here.
"============================================================================"
REPLACE{$PLTDIM} WITH {300};"Unique array dimension for XVGRPLOT and PLOTSN"
                        "Suppresses warnings from Intel compiler on Windows"
                   "when arrays have different dimensions in diff. routines"

%E   "egsnrc.macros"
"***************************************************************************"
"                                                                           "
"         EGSnrc internal Variance Reduction Macros                         "
"                                                                           "
"***************************************************************************"

REPLACE {;COMIN/EGS-VARIANCE-REDUCTION/;} WITH {;

  common/egs_vr/
    e_max_rr($MXREG), "max energy at which to do range rejection (RR)"
    prob_RR,          "probability for survival in R. Roulette"
    nbr_split,        "do brems splitting if > 1"
    i_play_RR,        "0=>don't play Russian Roulette,1=>play Russian Roulette"
    i_survived_RR,    "0=> all particles survive RR, n=> n partilces were"
                      "eliminated by RR in this interaction"
    n_RR_warning,     "a counter for user errors"
    i_do_rr($MXREG);  "0=>no RR, region by region, 1=>there is RR"
  $REAL          e_max_rr,prob_RR;
  $INTEGER       nbr_split,i_play_RR,i_survived_RR,n_RR_warning;
  $SHORT_INT     i_do_rr;
};

REPLACE {$MAX-RR-WARNING} WITH {50}

"This macro implements Russian Roulette (most useful  with brems splitting)"
"It is more efficient than having the user do it via AUSGAB since it avoids"
"considerable handling of the particles by ELECTR"
"The user must set i_play_RR (defaults to 0) and prob_RR"
"Both are in COMIN EGS-VARIANCE-REDUCTION"
""
"Note that this macro is called as $PLAY RUSSIAN ROULETTE WITH ELECTRONS..."
"Note also that subroutine pair has its own, internal version"

REPLACE {$PLAYRUSSIANROULETTEWITHELECTRONSFROM#;} WITH {;

  i_survived_RR = 0;   "flag all survive"
  ;IF( i_play_RR = 1 ) [
      IF( prob_RR <= 0 ) [
          IF( n_RR_warning < $MAX-RR-WARNING ) [
            n_RR_warning = n_RR_warning + 1;
            OUTPUT prob_RR;
  ('**** Warning, attempt to play Roussian Roulette with prob_RR<=0! ',g14.6);
          ]
      ]
      ELSE [
          ip = {P1};
          LOOP [     "handle all particles from p1 to np"
              IF( iq(ip) ~= 0 ) [   "i.e. charged particles"
                  $RANDOMSET rnno_RR;
                  IF( rnno_RR < prob_RR ) [ "particle survives"
                      wt(ip) = wt(ip)/prob_RR;
                      ip = ip + 1; "increase local pointer"
                  ]
                  ELSE [                    "particle killed"
                      ;i_survived_RR = i_survived_RR + 1;
                      ;IF(ip < np) [
                          "=>replace it with last particle on stack"
                          e(ip) = e(np); iq(ip) = iq(np); wt(ip) = wt(np);
                          u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
                      ]
                      np = np-1; "reduce stack by one=> particle gone"
                  ] "end of kill particle block"
              ] ELSE [ "this is a photon, leave it. Change pointer" ip = ip+1; ]
          ] UNTIL (ip > np);
          "loops until either np is decreased to ip, or ip increased to np"
          IF( np = 0 ) [ " we need at least one particle on the stack "
                         " so that the transport routines can exit properly"
              np = 1; e(np) = 0; iq(np) = 0; wt(np) = 0;
          ]
      ] "end of russian roulette block"
  ] "end of flag set block"
};

"*********************************************************************"
"  Stuff related to radiative corrections for Compton scattering      "
"                                                                     "
"  For now we exclude such corrections by default. They can be        "
"  included by adding the file rad_compton.mortran to the list of     "
"  files used to build EGSnrc just before egsnrc.mortran              "
"  The reason is that there is a fairly large amount of data needed   "
"  and this would be wasteful if the effect turns out to be small     "
"*********************************************************************"

REPLACE {$RADC_CHECK;} WITH {;}
REPLACE {$RADC_REJECTION;} WITH {;}
REPLACE {$RADC_WARNING;} WITH {;
    IF( radc_flag = 1 ) [
        $egs_warning(*,'You are trying to use radiative Compton corrections');
        $egs_info(*,'without having included rad_compton1.mortran');
        $egs_info('(a//)','Turning radiative Compton corrections OFF ...');
        radc_flag = 0;
    ]
};
REPLACE {$RADC_HATCH;} WITH {$RADC_WARNING;}
REPLACE {$COMIN-RADC-INIT;} WITH {
        ;COMIN/RAD_COMPTON,EGS-IO,COMPTON-DATA,MEDIA,PHOTIN,USEFUL/;
};
REPLACE {$COMIN-RADC-SAMPLE;} WITH {
        ;COMIN/RAD_COMPTON,RANDOM,STACK,USEFUL,EGS-IO/;
};


"*********************************************************************"
"  I/O, parallel processing, string manipulations, etc.
"*********************************************************************"

"how many chunks do we want to split the parallel run into
REPLACE {$N_CHUNKS} WITH {10};

" String manipulations, error messages, etc. "
REPLACE {$cstring(#)} WITH {{P1}(:lnblnk1({P1}))};
REPLACE {$set_string(#,#);} WITH {;
  DO i=1,len({P1}) [ {P1}(i:i) = {P2}; ] ;
};

REPLACE {$egs_debug(#,#);} WITH { write(i_log,{P1}) {P2}; };
REPLACE {$egs_fatal(#,#,#);} WITH {
  $warning('(/a)','***************** Error: ');
  $warning({P1},{P2});
  $warning('(/a)','***************** Quiting now.');
  $CALL_EXIT({P3});
};
REPLACE {$egs_fatal(#,#);} WITH {
  $warning('(/a)','***************** Error: ');
  $warning({P1},{P2});
  $warning('(/a)','***************** Quiting now.');
  $CALL_EXIT(1);
};
REPLACE {$egs_warning(#,#);} WITH {
  $warning('(/a)','***************** Warning: ');
  $warning({P1},{P2});
};
REPLACE {$warning(#,#);} WITH { write(i_log,{P1}) {P2}; };
REPLACE {$egs_info(#,#);} WITH { write(i_log,{P1}) {P2}; };
REPLACE {$declare_write_buffer;} WITH {;};


" Common block containing various directories, file names, etc. "
REPLACE {$mx_units} WITH {20};
REPLACE {$max_extension_length} WITH {10};
REPLACE {;COMIN/EGS-IO/;} WITH {;
  common /egs_io/ file_extensions($mx_units),
                  file_units($mx_units),
                  user_code,  "The name of the user code"
                  input_file, "The input file name with path but no extension"
                  output_file,"Same as above but for output"
                  pegs_file,  "The pegs file name with path and extension"
                  hen_house,  "The HEN_HOUSE directory"
                  egs_home,   "The EGS_HOME directory"
                  work_dir,   "The working directory within the user code dir."
                  host_name,  "The name of the host"
                  n_parallel, "if >0, number of parallel jobs"
                  i_parallel, "if >0, parallel job number"
                  first_parallel,"first parallel job (default is 1)"
                  n_max_parallel,"if parallel run, max. number of running jobs"
                  n_chunk,    "Histories per calculation chunk"
                  n_files,
                  i_input,    "unit no. for .egsinp if required"
                  i_log,      "unit no. for .egslog if required"
                  i_incoh,    "unit no. for Compton data"
                  i_nist_data, "unit no. for NIST data"
                  i_mscat,     "unit no. for multiple scattering data"
                  i_photo_cs,  "unit no. for photon cross-section data"
                  i_photo_relax, "unit no. for photon relaxation data"
                  xsec_out,     "switches on/off xsection file output"
                  is_batch,   "True for batch mode"
                  is_pegsless; "true if you are running without pegs file"
  character input_file*256, output_file*256, pegs_file*256,
            file_extensions*$max_extension_length,
            hen_house*128, egs_home*128, work_dir*128, user_code*64,
            host_name*64;
  $INTEGER  n_parallel, i_parallel, first_parallel,n_max_parallel,
            n_chunk, file_units, n_files,i_input,i_log,i_incoh,
            i_nist_data,i_mscat,i_photo_cs,i_photo_relax, xsec_out;
  $LOGICAL  is_batch,is_pegsless;
};

"The following macro sets the EGS_HOME directory               "
"The defualt implementation is to use the environment variable "
"EGS_HOME. But at the NRC EGS_HOME is set using the macro      "
"$EGS_HOME defined in machine.macros.                          "
REPLACE {$set_egs_home;} WITH {;
  $set_string(egs_home,' ');
  call getenv('EGS_HOME',egs_home);
};


" Initialization of various variables on a region-by-region basis "
" This is made a macro so that it can be replaced with a different "
" version for the C/C++ interface                                 "
REPLACE {$set-region-by-region-defaults;} WITH {;
DO i=1,$MXREG [
    ecut(i) = $GLOBAL-ECUT; pcut(i) = $GLOBAL-PCUT; "cut-off energies"
    ibcmp(i) = $IBCMP-DEFAULT;    "Compton "
    iedgfl(i) = $IEDGFL-DEFAULT;  "Relaxations"
    iphter(i) = $IPHTER-DEFAULT;  "photo-electron angular distribution"
    smaxir(i) = $MAX-SMAX;        "maximum step size"
    i_do_rr(i) = 0;               "range rejection flag"
    e_max_rr(i) = 0;              "`save' energy for range rejection"
    med(i) = 1;                   "default medium"
    rhor(i) = 0;                  "default mass density"
    iraylr(i) = $IRAYLR-DEFAULT;  "Rayleigh flag"
"Ali:photonuc, 1 line"
    iphotonucr(i) = $IPHOTONUCR-DEFAULT;  "photonuclear flag per region"]
};

" Make sure ecut and pcut are at least ae/ap and set default densities "
" This is made a macro so that it can be replaced with a different "
" version for the C/C++ interface                                 "
REPLACE {$adjust_rhor_ecut_pcut;} WITH {;
DO JR=1,$MXREG [
    MD=MED(JR);
    IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
        ECUT(JR)=max(ECUT(JR),AE(MD));
        PCUT(JR)=max(PCUT(JR),AP(MD));
        "   USE STANDARD DENSITY FOR REGIONS NOT SPECIALLY SET UP"
        IF (RHOR(JR).EQ.0.0)[RHOR(JR)=RHO(MD);]
    ]
]
};

REPLACE {$adjust_pcut;} WITH {;
DO JR=1,$MXREG [
    MD=MED(JR);
    IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
        PCUT(JR)=max(PCUT(JR),AP(MD));
    ]
]
};

REPLACE {$start_new_particle;} WITH { medium = med(irl); };

REPLACE {$electron_region_change;} WITH {
    ir(np) = irnew; irl = irnew; medium = med(irl);
};
REPLACE {$photon_region_change;} WITH { $electron_region_change; }

REPLACE {$declare_max_medium;} WITH {;};

REPLACE {$need_bound_compton_data(#);} WITH {
  {P1} = .false.;
  DO j=1,$MXREG [
      medium = med(j);
      IF( medium > 0 & medium <= nmed) [
          IF( ibcmp(j) > 0 ) [ {P1} = .true.; EXIT; ]
      ]
  ]
};

REPLACE {$need_relaxation_data(#);} WITH {
  {P1} = .false.;
  DO j=1,$MXREG [
      IF( iedgfl(j) > 0 & iedgfl(j) <= $MXELEMENT ) [ {P1} = .true.; EXIT; ]
  ]
};

REPLACE {$need_rayleigh_data;} WITH {;
DO J=1,NMED [
:LOOP-OVER-REGIONS:  DO I=1,$MXREG [
IF(IRAYLR(I).EQ.1.AND.MED(I).EQ.J) [
"REGION I = MEDIUM J AND WE WANT RAYLEIGH SCATTERING, SO"
"SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
IRAYLM(J)=1; EXIT :LOOP-OVER-REGIONS:;]
"END OF REGION-LOOP"]
"END OF MEDIA-LOOP"]
};

"Ali:photonuc, 1 block"
REPLACE {$need_photonuc_data;} WITH {;
IPHOTONUC=0;
DO J=1,NMED [
:LOOP-OVER-REGIONS-PHOTONUC: DO I=1,$MXREG [
IF(IPHOTONUCR(I).EQ.1.AND.MED(I).EQ.J) [
"REGION I = MEDIUM J AND WE WANT PHOTONUCLEAR, SO"
"SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
IPHOTONUCM(J)=1; IPHOTONUC=1; EXIT :LOOP-OVER-REGIONS-PHOTONUC:;]
"END OF REGION-LOOP"]
"END OF MEDIA-LOOP"]
};

REPLACE {$set_ecutmn;} WITH {
  ecutmn = 1e30;
  DO i=1,$MXREG [
      IF( med(i) > 0 & med(i) <= nmed ) [
                ecutmn = Min(ecutmn,ecut(i));
      ]
  ]
};

" default numer of media. "
REPLACE {$default_nmed} WITH {1}

REPLACE {$GET-PEGSLESS-XSECTIONS;} WITH {;
$egs_fatal('(a/a)',' Code cannot be run in pegsless mode.',
' Compile with required files and try again.');
;
}

REPLACE {$INIT-PEGS4-VARIABLES;} WITH {;}

REPLACE {$DECLARE-PEGS4-COMMON-BLOCKS;} WITH {;}

" The following macro is defined to fool the Intel Fortran compiler "
" version 8.0, which miscompiles init_spin when certain optimizations"
" are turned on and the code is run on an Athlon CPU. "
REPLACE {$FOOL-INTEL-OPTIMIZER(#) #;} WITH {;
    IF( fool_intel_optimizer ) [ write({P1},*) {P2}; ]
}
;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc timing macros                                                       "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2003                                       "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                                                                             "
"#############################################################################"


REPLACE {$DECLARE_TIMING_VARIABLES;} WITH {;
  real  CPUT0,CPUT1,CPUT2,TDUM;
  real egs_tot_time, egs_etime;}
;
REPLACE {$INITIALIZE_ELAPSED_CPU_TIME;} WITH {;}
;
REPLACE {$SET_ELAPSED_CPUTIME(#);} WITH { {P1}=egs_etime(); }
;
REPLACE {$INITIALIZE_ELAPSED_TOTAL_TIME;} WITH
  { tdum = egs_tot_time(1); }
;
REPLACE {$SET_ELAPSED_TOTAL_TIME(#);} WITH
  { {P1} = egs_tot_time(0); }
;
REPLACE {$CONVERSION_TO_SECONDS} WITH {1.0}
;
REPLACE {$TIME_RESOLUTION} WITH {0.01}
;
%E
%I4
!INDENT F2;
%C80
%Q1
"#############################################################################"
"                                                                             "
" EGSnrc machine dependent macro file for linux                               "
"                                                                             "
" Created by configure version 2.0 on ti 22.9.2020 12.43.13 +0300             "
"                                                                             "
" You may add your own machine dependent macros to this file,                 "
" but be carefull to not overwrite it if you re-run configure.                "
"                                                                             "
"#############################################################################"

REPLACE {$MACHINE} WITH
  {,'linux',};
REPLACE {$HEN_HOUSE} WITH
  {'/home/miia/EGSnrc/HEN_HOUSE/'};
REPLACE {$CANONICAL_SYSTEM} WITH
  {'x86_64-unknown-linux-gnu'};
REPLACE {$CONFIGURATION_NAME} WITH
  {'linux'};
REPLACE {$EGS_CONFIG} WITH
  {'/home/miia/EGSnrc/HEN_HOUSE/specs/linux.conf'};

" System dependent stuff "
"========================================"
" Unfortunately, there appears to be no reliable way of copying files "
" under Fortran => we use a system call for this"
REPLACE {$copy_file} WITH {'cp '};

" Although one can move files using Fortran's intrinsic rename, "
" we don't know whether the user has not created additional files in "
" the temporary working directory => it is easiest to use a system call "
" to move all files from the temporary working directory to the user-code "
" directory. "
REPLACE {$move_file} WITH {'mv -f '};

" There appears to be no way of removing a directory from Fortran "
" => we use a system call for this. "
REPLACE {$remove_directory} WITH {'rm -rf '};

" The directory separator "
REPLACE {$file_sep} WITH {'/'};

REPLACE {$LONG_INT} WITH { integer*8 };
REPLACE {$SHORT_INT} WITH { integer*2 };
"$MAX_INT SET TO 2^63-1 in egsnrc.macros"
"The machine byte order"
REPLACE {$BYTE_ORDER} WITH {'1234'};
;
REPLACE {$RECL-FACTOR} WITH {4};
;
REPLACE {$FLUSH_UNIT(#);} WITH {call flush({P1});}
;
" If you want your user-code to return an exit status, use the "
" following macro to terminate execution"
REPLACE {$CALL_EXIT(#);} WITH {call exit({P1});}
;
" mortran3 gets confused by the # char => we need to pass it as an "
" argument to the macro. "
REPLACE {$HAVE_C_COMPILER(#);} WITH {{EMIT;{P1}define HAVE_C_COMPILER};}
;
REPLACE {$HAVE_LOAD_DSO(#);} WITH {{EMIT;{P1}define HAVE_LOAD_DSO};}
;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc macros for ranmar random number generator                           "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2000                                       "
"                   Dave Rogers, 2000                                         "
"                                                                             "
"  Contributors:                                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Implementation for EGSnrc of the RANMAR random number generator (RNG),     "
"  proposed by Marsaglia and Zaman.                                           "
"                                                                             "
"  Note that this implementation uses integers to store the state of the RNG  "
"  and to generate the next number in the sequence. Only at the end are the   "
"  random numbers are converted to reals by a multiplication with 2**(-24)    "
"  (there are only 24 significant bits). I found the integer implementation   "
"  to be about 30% faster then using reals on Pentium III machines, and       "
"  nearly 70% faster on older SGI workstations.                               "
"                                                                             "
"  To use this set of macros, you need to initialize the RNG by a call to     "
"  init_ranmar (in ranmar.mortran) or read-in a valid RNG state using the     "
"  macro $RETRIEVE RNG STATE FROM UNIT #;                                     "
"                                                                             "
"#############################################################################"


REPLACE {$NRANMAR} WITH {128}
REPLACE {;COMIN/RANDOM/;} WITH
{;
   common/randomm/ rng_array($NRANMAR), urndm(97), crndm, cdrndm, cmrndm,
                   i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed;
   integer*4       urndm, crndm, cdrndm, cmrndm, i4opt,
                   ixx, jxx, fool_optimizer,rng_seed,rng_array;
   real*4          twom24;
}
"in the above, rng_seed is typed and part of common because it is"
" initialized in BLOCK DATA for the ranlux rng.                  "
" It is not actually used by ranmar."

" The following is the $RANDOMSET macro for EGSnrc."
" Found that using integers it is faster by about 30% on a PIII CPU"
" (which is the NRC computer environment                           "

" Found that when the RNG is not inlined, code runs faster "
" Presumambly because the executable shrinks by a significant amount "
" Iwan Kawrakow, May 2003 "

REPLACE {$RANDOMSET#;} WITH {;
  IF( rng_seed > $NRANMAR ) call ranmar_get;
  {P1} = rng_array(rng_seed)*twom24; rng_seed = rng_seed + 1;
};

"REPLACE {$RANDOMSET#;} WITH
"{
"    i4opt = urndm(ixx) - urndm(jxx);
"    IF(i4opt < 0) i4opt = i4opt + 16777216;
"    urndm(ixx) = i4opt;
"    ixx = ixx - 1; jxx = jxx - 1;
"    IF(ixx = 0)        [ ixx = 97; ]
"    ELSE IF( jxx = 0 ) [ jxx = 97; ]
"    crndm = crndm - cdrndm;
"    IF(crndm < 0) crndm = crndm + cmrndm;
"    i4opt = i4opt - crndm;
"    IF(i4opt < 0) i4opt = i4opt + 16777216;
"    {P1} = twom24*i4opt;
"}
;

REPLACE {$RNG-INITIALIZATION;} WITH { ;call init_ranmar; }

REPLACE {$RNG-DEFAULT-INITIALIZATION;} WITH {;
    ixx=0; jxx=0; call init_ranmar;
};

REPLACE {$INITIALIZE RNG USING # AND #; } WITH {;
  ixx = {P1}; jxx = {P2};
  call init_ranmar;
};

"**************************************************************************"
" The macros below are not essential for the operation of the RNG,         "
" they are defined for convinience in our NRC user codes                   "
"**************************************************************************"

REPLACE {$STORE RNG STATE ON UNIT #;} WITH
{
    rewind({P1});
    write({P1},*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
                  rng_array;
}

REPLACE {$PUT RNG STATE ON UNIT #;} WITH
{
    write({P1},*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
                  rng_array;
}

REPLACE {$RETRIEVE RNG STATE FROM UNIT #;} WITH {;
    read({P1},*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
                 rng_array;
    twom24 = 1./16777216.;  "just in case it is not initialized in rmarin"
};

REPLACE {$SHOW-RNG-STATE(#);} WITH {;
   write({P1},'(a,2i4,$)') ' ixx jxx = ',ixx,jxx;
};

REPLACE {$PRINT-RNG-STATE(#,#);} WITH {;
   write({P1},{P2}) ixx,jxx;
};

REPLACE {$RNG-INPUTS(#,#,#,#);} WITH {;
   ival = ival + 1;
   VALUES_SOUGHT(IVAL)={P1};
   nvalue(ival) = 2;
   type(ival)   = 0;
   value_min(ival) = 1;
   value_max(ival) = 30081;
   default(ival)   = 9373;
   delimeter = {P2};
   nmin = ival; nmax = ival;
   call get_input;
   IF( error_flags(ival) = 0 ) [
       {P3} = value(ival,1);
       {P4} = value(ival,2);
   ]
   ELSE [ {P3} = 0; {P4} = 0; ]
};

REPLACE {$RNG-STRING-1} WITH {' 1st initial random number seed: '}
REPLACE {$RNG-STRING-2} WITH {' 2nd initial random number seed: '}

"            end of ranmar.macros         "
%E
"#############################################################################"
"                                                                             "
"  EGSnrc macros for ranmar correlated sampling                               "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2000                                       "
"                   Dave Rogers, 2000                                         "
"                                                                             "
"  Contributors:                                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The following macros can be used for correlated sampling, together with    "
"  the RANMAR random number generator (rng).                                  "
"                                                                             "
"  $MXRNGDIM      gives the maximum number of different rng states that       "
"                 can be simultaneously held in the memory.                   "
"                                                                             "
"  $STORE-RNG(#)  is used to store the current rng state into dimension {P1}  "
"                                                                             "
"  $RESET-RNG(#)  is used to re-set the rng state from a previous state       "
"                                                                             "
"  In order to use these macros, include this file before your user code via  "
"  the configuration file.                                                    "
"                                                                             "
"#############################################################################"


REPLACE {$MXRNGDIM} WITH {5};  "to store up to five rng states"

APPEND {;

  common/random_extra/ extra_urndm(97,$MXRNGDIM), extra_crndm($MXRNGDIM),
                       extra_cdrndm($MXRNGDIM), extra_cmrndm($MXRNGDIM),
                       extra_ixx($MXRNGDIM), extra_jxx($MXRNGDIM),
                       extra_rng_seed($MXRNGDIM),
                       extra_rng_array($NRANMAR,$MXRNGDIM);
  integer*4            extra_urndm,extra_crndm,extra_cdrndm,extra_cmrndm,
                       extra_ixx,extra_jxx,extra_rng_seed,extra_rng_array;

} TO { ;COMIN/RANDOM/; }

REPLACE {$STORE-RNG(#);} WITH {;

  IF( {P1} < 1 | {P1} > $MXRNGDIM ) [
      OUTPUT {P1};
      (//' ******* Attempt to store rng state into an illegal dimension: ',
      i4//);
      stop;
  ]
  DO i4opt = 1, 97 [ extra_urndm(i4opt,{P1}) = urndm(i4opt); ]
  extra_crndm({P1})  = crndm;
  extra_cdrndm({P1}) = cdrndm;
  extra_cmrndm({P1}) = cmrndm;
  extra_ixx({P1}) = ixx; extra_jxx({P1}) = jxx;
  extra_rng_seed({P1}) = rng_seed;
  DO i4opt = 1,$NRANMAR [ extra_rng_array(i4opt,{P1}) = rng_array(i4opt); ]
};

REPLACE {$RESET-RNG(#);} WITH {;

  IF( {P1} < 1 | {P1} > $MXRNGDIM ) [
      OUTPUT {P1};
      (//' ******* Attempt to reset rng state from an illegal dimension: ',
      i4//);
      stop;
  ]
  DO i4opt = 1, 97 [ urndm(i4opt) = extra_urndm(i4opt,{P1}); ]
  crndm  = extra_crndm({P1});
  cdrndm = extra_cdrndm({P1});
  cmrndm = extra_cmrndm({P1});
  ixx = extra_ixx({P1}); jxx = extra_jxx({P1});
  rng_seed = extra_rng_seed({P1});
  DO i4opt = 1,$NRANMAR [ rng_array(i4opt) = extra_rng_array(i4opt,{P1}); ]
};
"       end of ranmar.correlations   "
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc transport parameter macros                                          "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Iwan Kawrakow, 2003                                       "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                   Ernesto Mainegra-Hing                                     "
"                                                                             "
"#############################################################################"
"                                                                             "
"  These macros are used in conjunction with the get_inputs.mortran routines  "
"  to read in EGSnrc transport physics parameters. Specifically with          "
"  subroutine get_transport_parameter.                                        "
"                                                                             "
"  The following are definitions of code words (values sought) for the        "
"  various transport parameters that can be set. I hope they are              "
"  self-explanatory. If you don't like them:                                  "
"                                                                             "
"  - include this file via the configuration file BEFORE your user code.      "
"                                                                             "
"  - Replace the macros in your user code with code words that you prefer.    "
"                                                                             "
"#############################################################################"


REPLACE {$GLOBAL_ELECTRON_CUTOFF} WITH {'Global ECUT'}
REPLACE {$GLOBAL_PHOTON_CUTOFF}   WITH {'Global PCUT'}
REPLACE {$GLOBAL_SMAX}            WITH {'Global SMAX'}
REPLACE {$INCOHERENT_SCATTERING}  WITH {'Bound Compton scattering'}
REPLACE {$RADC_COMPTON}           WITH {'Radiative Compton corrections'}
REPLACE {$COHERENT_SCATTERING}    WITH {'Rayleigh scattering'}
REPLACE {$ATOMIC_RELAXATIONS}     WITH {'Atomic relaxations'}
REPLACE {$PE_ANGULAR_SAMPLING}    WITH {'Photoelectron angular sampling'}
REPLACE {$BREMS_ANGULAR_SAMPLING} WITH {'Brems angular sampling'}
REPLACE {$BREMS_CROSS_SECTIONS}   WITH {'Brems cross sections'}
REPLACE {$PAIR_ANGULAR_SAMPLING}  WITH {'Pair angular sampling'}
REPLACE {$PAIR_CROSS_SECTIONS}    WITH {'Pair cross sections'}
REPLACE {$TRIPLET_PRODUCTION}     WITH {'Triplet production'}
REPLACE {$ELECTRON_IMPACT_IONI}   WITH {'Electron Impact Ionization'}
REPLACE {$SPIN_EFFECTS}           WITH {'Spin effects'}
REPLACE {$MAXIMUM_ESTEPE}         WITH {'ESTEPE'}
REPLACE {$MAXIMUM_XIMAX}          WITH {'XImax'}
REPLACE {$SKIN_FOR_BCA}           WITH {'Skin depth for BCA'}
REPLACE {$BOUNDARY_ALGORITHM}     WITH {'Boundary crossing algorithm'}
REPLACE {$ELECTRON_STEP_ALG}      WITH {'Electron-step algorithm'}
REPLACE {$ON_IN_REGIONS}          WITH {'On in Regions'}
REPLACE {$OFF_IN_REGIONS}         WITH {'Off in Regions'}
REPLACE {$IN_REGIONS}             WITH {'Regions'}
REPLACE {$THE_DELIMETER}          WITH {'MC TRANSPORT PARAMETER'}
REPLACE {$PHOTON_XSECTIONS}       WITH {'Photon cross sections'}
REPLACE {$COMPTON_XSECTIONS}      WITH {'Compton cross sections'}
REPLACE {$PHOTON_XSECTIONS_OUT}   WITH {'Photon cross-sections output'}
REPLACE {$SCALE_L_EII_XSECTIONS}  WITH {'scale L EII cross-sections'}
"Ali:photonuc, 2 lines"
"Cannot use $PHOTONUC; it clashes with other variables"
REPLACE {$PHOTO_NUCLEAR}          WITH {'Photonuclear attenuation'}
REPLACE {$PHOTONUC_XSECTIONS}     WITH {'Photonuclear cross sections'}
REPLACE {$B_FIELD} WITH {'Magnetic Field'}
REPLACE {$E_FIELD} WITH {'Electric Field'}
REPLACE {$EM_LMT} WITH {'EM ESTEPE'}
;

REPLACE {$TURN-ON/OFF-IN-REGIONS(#,#,#,#);} WITH
{;
aux_inregions = .false.;
IF( error_flags({P1}) = 0 ) [
    write(i_log,*) {P2};
    itmp = value({P1},1);
    IF( itmp = 2 | itmp = 3 ) [
        ival                = ival + 1;
        values_sought(ival) = {P2};
        nvalue(ival)        = 0;
        type(ival)          = 0;
        value_min(ival)     = 1;
        value_max(ival)     = $MXREG;
        default(ival)       = 1;
        ival                = ival + 1;
        values_sought(ival) = {P3};
        nvalue(ival)        = 0;
        type(ival)          = 0;
        value_min(ival)     = 1;
        value_max(ival)     = $MXREG;
        default(ival)       = 1;
        Nmin = ival-1; Nmax = ival;
        CALL GET_INPUT;
        IF( error_flags(ival-1) = 0 & error_flags(ival) = 0 ) [
            IF( nvalue(ival) = nvalue(ival-1) ) [
                iitmp = itmp-2;
                DO j=1,$MXREG [ {P4}(j) = iitmp; ]
                 "i.e. set everywhere to 0 (if turn on) or 1 (if turn off)"
                iitmp = 1 - iitmp;
                 "and then re-set in the specified regions"
                DO k=1,nvalue(ival) [
                    istart = value(ival-1,k);
                    iend = value(ival,k);
"Ali:photonuc, 2 lines to crudely print start/stop regions"
                    write(i_log,*) {P2},istart;
                    write(i_log,*) {P3},iend;
                    IF( istart <= iend ) [
                        DO j=istart,iend [ {P4}(j) = iitmp; ]
                        aux_inregions = .true.;
                    ]
                ]
            ]
            ELSE [ value({P1},1) = {P4}(1); ]
        ]
        ELSE [ value({P1},1) = {P4}(1); ]
    ]
    ELSE [
        IF( itmp > 3 ) itmp = itmp-2;
        write(i_log,*) ' Setting all to ',itmp;
        DO j=1,$MXREG [ {P4}(j) = itmp; ]
    ]
]
ELSE ["Use default value"
  "Check if default is other than ON or Off"
  "and shift as no input by regions requested"
  IF({P4}(1) = 2 | {P4}(1) = 3)[
    value({P1},1) = {P4}(1)+2;
  ]
  ELSE[
    value({P1},1) = {P4}(1);
  ]
]

};

REPLACE{$SET # IN REGIONS(#,#,#,#,#,#,#);} WITH
{;

aux_inregions = .false.;
ival                = ival + 1;
{P2}                = ival;
values_sought(ival) = {P6};
nvalue(ival)        = 0;
type(ival)          = 1;
value_min(ival)     = {P3};
value_max(ival)     = {P4};
default(ival)       = {P5};

ival                = ival + 1;
values_sought(ival) = {P7};
nvalue(ival)        = 0;
type(ival)          = 0;
value_min(ival)     = 1;
value_max(ival)     = $MXREG;
default(ival)       = 1;

ival                = ival + 1;
values_sought(ival) = {P8};
nvalue(ival)        = 0;
type(ival)          = 0;
value_min(ival)     = 1;
value_max(ival)     = $MXREG;
default(ival)       = 1;

Nmin = {P2}; Nmax = {P2}+2; error_flag = 0;
CALL GET_INPUT;

IF( error_flag = 0 ) [
    IF( nvalue({P2}) = nvalue(ival) & nvalue(ival-1) = nvalue(ival) ) [
        DO k=1,nvalue(ival) [
            istart = value(ival-1,k);
            iend = value(ival,k);
            IF( istart <= iend ) [
                DO j=istart,iend [ {P1}(j) = value({P2},k); ]
                aux_inregions = .true.;
            ]
        ]
    ]
]
};
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc edknrc application                                                  "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Ernesto Mainegra-Hing, 2003                               "
"                                                                             "
"  Contributors:    Alex Bielajew                                             "
"                   Iwan Kawrakow                                             "
"                   Blake Walters                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code was originally adapted from EGS4 user code SCASPH by Ernesto     "
"  Mainegra-Hing in 2003. The EGS4 user code SCASPH was itself adapted from   "
"  SCARZ.mor.v01 by Alex Bielajew in 1984.                                    "
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Simulates the passage of an electron or photon beam in a finite,           "
"  spherical-conical geometry, for the calcucalculation of energy deposition  "
"  kernels for photons and electrons.                                         "
                                                                              "
"  A new algorithm for forcing the first photon at the origin has been        "
"  implemented to avoid possible round-off errors and unrealistic energy      "
"  deposition of sub-threshold particles in the first region. All the         "
"  EGSnrc improvements are included, i.e., history-by-history statistics,     "
"  processing of parallel runs and variance reduction techniques.             "
"                                                                             "
"  So far particles are emitted from origin either uniformly in 4*pi or       "
"  parallel to the z-axis (for energy deposition kernels).                    "
"                                                                             "
"#############################################################################"


%L TURN ON LISTING IN CASE IT WAS OFF FOR EGS
%I4
!INDENT F2;
%C80
%Q1
%E     "edknrc.mortran"
;
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
"******************************************************************************
"
"
"                               ********************
"                               *                  *
"                               * edknrc.mortran   *
"                               *                  *
"                               ********************
"
"
"       INTRODUCTION:
"       This code simulates the passage of an electron or photon beam in a
"       finite, spherical-conical geometry. It was developed for the calcu-
"       calculation of energy deposition kernels for photons and electrons.
"       Starting point was the EGS4 user code SCASPH (see detailed description
"       in Phys. Med. Biol. 33 No 1 (Jan. 1988) 1-20 by TR Mackie, AF Bielajew,
"       D W O Rogers and J J Battista).
"       A new algorithm for forcing the first photon at the origin has been
"       implemented to avoid possible round-off errors and unrealistic energy
"       dumping of sub-threshold particles in the first region (see PIRS-###).
"       All the improvements from the NRC User Codes have been included, i.e.
"       history by history statistics, processing of parallel runs and
"       variance reduction techniques.
"
"       So far particles are emitted from origin either uniformly in 4 Pi or
"       parallel to the Z-axis (for energy deposition kernels).
"
"
"
"                                        Ernesto Mainegra-Hing June, 2004,
"                                  (C) 2004  National Research Council Canada
"
"*****************************************************************************"
;
"*******************************************************************************
"*******************************************************************************
"                                TITLE
"                                *****
"*******************************************************************************
"
"CARD TI1
"
"       TITLE          (C)  TITLE OF THE INPUT FILE (FORMAT= '80A1')
;
"*******************************************************************************
"
" I/O DELIMETERS:    :start I/O control:
"                    :stop I/O control:
"
"*******************************************************************************
"                       INPUT/OUTPUT CONTROL INPUT
"                       **************************
"*******************************************************************************
"
"  IRESTART
"       = first    (0) First run for this data set
"       = restart  (1) Restart a previous run
"       = analyze  (3) Just read in the raw data and do the statistical analysis
"       = parallel (5) Combine results from previous parallel runs
"  STORE DATA ARRAYS
"       = yes             (0) Store data arrays for re-use
"       = no              (1) don't store them
"  PRINT OUT EDK FILE
"       = yes             (0) EDK stored in old format files
"       = no              (1) don't produce EDK files in old format
;
"*******************************************************************************
"
" MONTE CARLO DELIMETERS:    :start Monte Carlo inputs:
"                            :stop Monte Carlo inputs:
"
"*******************************************************************************
"                       MONTE CARLO CONTROL INPUT
"                       *************************
"*******************************************************************************
"
"CARD MC1
"
"  NUMBER OF HISTORIES         (I)  # HISTORIES TO RUN
"                                   (MIN:100, DEFAULTS TO 20 000)
"
"  INITIAL RANDOM NO. SEEDS    (M2) IXX, JXX
"               IXX   RANDOM NUMBER INITIAL SEED, MUST BE AN ODD INTEGER
"               JXX   0 OR EVEN INTEGER
"  IFULL
"         = cavity calculation        (0) calculate dose in cavity regions
"         = energy deposition kernels (1)
"         = dose calculation          (2)
"         = dose and edk              (3)
"*******************************************************************************
"*******************************************************************************
"
" GEOMSPH DELIMETERS:    :start geometrical inputs:
"                       :stop geometrical inputs:
"
"*******************************************************************************
"                  SPHERICAL GEOMETRY & MATERIAL INPUT
"                  *************************************
"
"CARD CGM1
"
"  NUMBER OF CONES        (M)   number of cones (individual or by group)
"                               If omitted or ZERO, pure spherical geometry
"                               assumed.
"
"  ANGLES                 (M)   ANGLES defining the geometry (reals)
"                               No needed in pure spherical geometries.
"
"                               For group input there must be as many entries
"                               as for the NUMBER OF CONES, i.e. :
"                               NCON1,NCON2,...,NCONn
"                               DANG1,DANG2,...,DANGn
"
"                               For individual input, ncones must be equal
"                               to the number of entries, i.e.:
"                               ncones
"                               DANG1, DANG2,...,DANGncones
"
"  NUMBER OF SPHERES      (M)   number of spheres (individual or by group)
"
"                               For individual inputs, number of spheres
"                               can be omitted
"
"
"  RADII                  (M)   radii of spheres defining the geometry (reals)
"
"                               For group input there must be as many entries
"                               as for the NUMBER OF SPHERES, i.e. :
"                               NSPH1,NSPH2,...,NSPHn
"                               DRAD1,DRAD2,...,DRADn
"
"  CAVITY ZONES           (M)   geometrical zone numbers in the cavity (reals)
"
"*******************************************************************************
"                                MATERIAL INPUT
"                                **************
"*******************************************************************************
"
"CARD M1
"
"  MEDIA                  (M)   TYPE OF MATERIAL (FMT='24A1')
"                               BY CONVENTION THE PRIMARY WALL
"                               MATERIAL IS FIRST, THE CAVITY MATERIAL
"                               IS SECOND AND THE REST FOLLOWS
"
"*******************************************************************************
"
"CARD M3-A  (CHOICE OF CARD M3-A AND CARD M3-B)
"
"  MEDNUM                 (M)   THE MATERIAL NUMBER (INTEGERS)
"                               (MEDNUM=0 TO SKIP)
"  START REGION           (M)   INITIAL GEOMETRICAL ZONE(IRL) (INTEGERS)
"  STOP REGION            (M)   FINAL GEOMETRICAL ZONE(IRL) (INTEGERS)
"                               ( >NREGLO TO INPUT MORE THAN ONE ZONE)
"                               DEFAULTS:   MEDNUM=0 FOR REGION=1 (i.e. VACUUM)
"                                           MEDNUM=1 FOR REGION=2,NREG
"
;
"*******************************************************************************
"
" SOURCE DELIMETERS:    :start source inputs:
"                       :stop source inputs:
"
"*******************************************************************************
"                             SOURCE INPUT
"                            **************
"*******************************************************************************
"CARD SC1       FOR ALL SOURCES
"                                      CHARGE OF THE INCIDENT BEAM
"  INCIDENT PARTICLE= electron   (-1)  ELECTRONS
"                     photon     (0)   PHOTONS
"                     positron   (1)   POSITRONS
"
"  (IF SOURCE 21)     all        (2)   INCLUDE ALL OF THE PARTICLES
"                                      IN THE PHASE SPACE FILE
"
"  SOURCE NUMBER                 (I)   NUMBER OF THE SOURCE
"
" SOURCE DELIMETERS:    :start source inputs:
"                       :stop source inputs:
"
"FOR ALL SOURCES
"                                      Charge of the incident beam
"  INCIDENT PARTICLE= electron   (-1)  electrons
"                     photon     (0)   photons
"                     positron   (1)   positrons
"
"  SOURCE NUMBER                 (I)   number of the source
"                                      [ISOURC]
"
;
"------------------------------------------------------------------------------
"
" SOURCE 0:    Point source AT origin, emission along Z-axis
;
"------------------------------------------------------------------------------
"
" SOURCE 1:   Point source AT origin, isotropically radiating in 4 Pi
;
"------------------------------------------------------------------------------
"
" SOURCE 2:   Point source NEAR origin, emission along Z-axis
"
" ZIN      -> source offset on Z-axis
"             Option used to emulate old way of calculating EDK
"
;
"------------------------------------------------------------------------------
"*******************************************************************************
"
"                         MC TRANSPORT PARAMETER
"                         **********************
"
"  All input associated with selection of various transport parameter
"  is not crucial for the execution as there are default values set.
"  Therefore, if some of the input options in this section are
"  missing/misspelled, this will be ignored and default parameters assumed
"  As the transport parameter input routine uses get_inputs, a lot
"  of error/warning messages may be produced on UNIT 15, though.
"  If you don't have the intention of changing default settings,
"  simply ignore the error messages.
"
"  The delimeters are
"
"               :start mc transport parameter:
"               :stop mc transport parameter:
"
"  You can change this by including the statement
"
"  REPLACE {$THE_DELIMETER} WITH {'WHATEVER-YOU-LIKE-THE-DELIMETER-TO-BE'}
"
"  in your input file.
"
"  Currently, the following options are available (except for a few entries,
"  case does not matter):
"
"       Global ECUT=     Set a global (in all regions) electron transport
"                        cut off energy (in MeV). If this imput is missing,
"                        AE(medium) will be used.
"                        [ ECUT ]
"       Global PCUT=     Set a global (in all regions) photon transport
"                        cut off energy (in MeV). If this imput is missing,
"                        AP(medium) will be used.
"                        [ PCUT ]
"       Global SMAX=     Set a global (in all regions) maximum step-size
"                        restriction for electron transport (in cm).
"                        If missing, no geometrical step-size restrictions will
"                        be employed. Note that if you use the default
"                        EGSnrc electron-step algorithm, no SMAX-restriction
"                        is necessary. Option is useful for transport in low
"                        density materials (air) when PRESTA behaviour is
"                        turned on (see below)
"                        [ SMAXIR ]
"       ESTEPE=          Set the maximum fractional energy loss per step.
"                        Note that this is a global option only, no
"                        region-by-region setting is possible. If missing,
"                        the defualt is 0.25 (25%)
"                        [ ESTEPE ]
"       XImax=           Maximum first elastic scattering moment per step.
"                        Default is 0.5, NEVER use value greater than 1 as
"                        this is beyond the range of MS data available.
"                        [ XIMAX ]
"       Boundary crossing algorithm=
"                        There are two selections possible: EXACT, means
"                        the algorithm will cross boundaries in a single
"                        scattering (SS) mode, the distance from a boundary
"                        at which the transition to SS mode is made is
"                        determined by 'Skin depth for BCA' (see below).
"                        The second option is PRESTA-I, if selected boundaries
"                        will be crossed a la PRESTA, i.e. with lateral
"                        correlations turned off and MS forced at boundaries.
"                        Default is EXACT.
"                        [ bca_algorithm, exact_bca ]
"       Skin depth for BCA=
"                        Determines the distance from a boundary (in elastic
"                        MFP) at which the algorithm will go into single
"                        scattering mode (if EXACT boundary crossing) or
"                        swith off lateral correlations (if PRESTA-I boundary
"                        crossing). Default value is 3 for EXACT or
"                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
"                        for a definition of BLCMIN). Note that if you choose
"                        EXACT boundary crossing and set Skin depth for BCA
"                        to a very large number (e.g. 1e10), the entire
"                        calculation will be in SS mode. If you choose
"                        PRESTA-I boundary crossing and make Skin depth for BCA
"                        large, you will get default EGS4 behavious (no PRESTA)
"                        [ skindepth_for_bca ]
"       Electron-step algorithm=
"                        PRESTA-II (the default), the name is
"                        used for historical reasons
"                        or PRESTA-I
"                        Determines the algorithm used to take into account
"                        lateral and longitudinal correlations in a
"                        condensed history step.
"                        [ transport_algorithm ]
"       Spin effects=    Off, On, default is On
"                        Turns off/on spin effects for electron elastic
"                        scattering. Spin On is ABSOLUTELY necessary for
"                        good backscattering calculations. Will make a
"                        even in `well conditioned' situations (e.g. depth
"                        dose curves for RTP energy range electrons).
"                        [ spin_effects ]
"       Brems angular sampling= Simple, KM, default is KM
"                        If Simple, use only the leading term of the Koch-Motz
"                        distribution to determine the emission angle of
"                        bremsstrahlung photons. If On, complete
"                        modified Koch-Motz 2BS is used (modifications
"                        concern proper handling of kinematics at low energies,
"                        makes 2BS almost the same as 2BN at low energies).
"                        [ IBRDST ]
"       Brems cross sections= BH, NIST, default is BH
"                        If BH is selected, the Bethe-Heitler bremsstrahlung
"                        cross sections (Coulomb corrected above 50 MeV)
"                        will be used. If NIST is selected, the NIST brems
"                        cross section data base (which is the basis for
"                        the ICRU radiative stopping powers) will be employed.
"                        Differences are negligible for E > ,say, 10 MeV,
"                        but signifficant in the keV energy range.
"       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
"                        gryzinski or penelope.  If set to On or ik, then
"                        use Kawrakow's theory to derive EII cross-sections.
"                        If set to casnati, then use the cross-sections of
"                        Casnati (from file ($HEN_HOUSE/data/eii_casnati.data).
"                        Similar for kolbenstvedt, gryzinski and penelope.
"                        This is only of interest in kV X-ray calculations.
"                        Note that the user can supply their own EII
"                        cross-section data as well. The requirement is that
"                        the file eii_suffix.data exists in the $HEN_HOUSE/data
"                        directory, where suffix is the name specified.
"                        Entry case-sensitive except for Off, On or ik.
"                        [ eii_flag ]
"       Bound Compton scattering=  On, Off, Simple or norej
"                        If Off, Compton scattering will be treated with
"                        Klein-Nishina, with On Compton scattering is
"                        treated in the Impuls approximation. Default is On.
"                        With Simple, the impulse approximation incoherent
"                        scattering function will be used (i.e., no Doppler
"                        broadenning). With norej the actual total bound
"                        Compton cross section is used and there are no
"                        rejections at run time.
"                        Make sure to turn on for low energy applications,
"                        not necessary above, say, 1 MeV.
"                        [ IBCMP ]
"       Pair angular sampling= Off, Simple or KM
"                        If off, pairs are set in motion at an angle m/E
"                        relative to the photon direction (m is electron rest
"                        energy, E the photon energy). Simple turns on
"                        the leading term of the angular distribution
"                        (this is sufficient for most applications),
"                        KM (comes from Koch and Motz) turns on using 2BS
"                        from the article by Koch and Motz.
"                        Default is Simple, make sure you always use Simple or
"                        KM
"                        [ IPRDST ]
"       Pair cross sections= BH (default) or NRC.  If set to BH, then use
"                        Bethe-Heitler pair production cross-sections.  If set
"                        to NRC, then use NRC pair production cross-sections
"                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
"                        of interest at low energies, where the NRC cross-
"                        sections take into account the assymmetry in the
"                        positron-electron energy distribution.
"                        [ pair_nrc ]
"       Photon cross sections= Photon cross-section data.  Current options are
"                        si (Storm-Israel--the default), epdl (Evaluated Photon
"                        Data Library), xcom and pegs4.  Allows the use of
"                        photon cross-sections other than from the PEGS4 file
"                        unless the pegs4 option is specified.
"                        Note that the user can supply their own cross-section
"                        data as well. The requirement is that the files
"                        photon_xsections_photo.data,
"                        photon_xsections_pair.data,
"                        photon_xsections_triplet.data, and
"                        photon_xsections_rayleigh.data exist in the
"                        $HEN_HOUSE/data directory, where photon_xsections
"                        is the name specified.
"                        Hence this entry is case-sensitive.
"                        [ photon_xsections ]
"       Photon cross-sections output= Off (default) or On.  If On, then
"                        a file $EGS_HOME/user_code/inputfile.xsections is
"                        output containing photon cross-section data used.
"                        [ xsec_out ]
"       Compton cross sections= Bound Compton cross-section data.  User-
"                        supplied bound Compton cross-sections in the file
"                        $HEN_HOUSE/data/comp_xsections_compton.data, where
"                        comp_xsections is the name supplied for this input.
"                        This is only used if Bound Compton scattering= Simple
"                        and is not available on a region-by-region basis
"                        (see below).  The default file (ie in the absence
"                        of any user-supplied data) is compton_sigma.data.
"                        [ comp_xsections ]
"       Photoelectron angular sampling= Off or On
"                        If Off, photo-electrons get the direction of the
"                        `mother' photon, with On, Sauter's furmula is
"                        used (which is, striktly speaking, valid only for
"                        K-shell photo-absorption).
"                        If the user has a better approach, replace the macro
"                            $SELECT-PHOTOELECTRON-DIRECTION;
"                        The only application that
"                        I encountered until now where this option made a
"                        small difference was a big ion chamber (cavity size
"                        comparable with electron range) with high-Z walls
"                        in a low energy photon beam.
"                        Default is On
"                        [ IPHTER ]
"       Rayleigh scattering= Off, On, custom
"                        If On, turn on coherent (Rayleigh) scattering,
"                        even if no Rayleigh data in PEGS4 file.
"                        Default is Off. Should be turned on for low energy
"                        applications. If custom, user must provide media names
"                        and form factor files for each medium.
"                        [ IRAYLR ]
"       ff media names = A list of media names (must match media found in
"                        PEGS4 data file) for which the user is going to
"                        provide custom Rayleigh form factor data.
"                        [ iray_ff_media($MXMED) ]
"       ff file names = A list of names of files containing the Rayleigh
"                       form factor data for the media specified by
"                       the ff media names = input above.  Full directory
"                       paths must be given for all files, and for each medium
"                       specified, iray_ff_media(i), there must be a
"                       corresponding file name, iray_ff_file(i).  For
"                       example files, see the directory
"                       $HEN_HOUSE/data/molecular_form_factors.
"                       [ iray_ff_file($MXMED) ]
"       Atomic relaxations= Off, On
"                        Default is On. The effect of using On is twofold:
"                        - In photo-electric absorption events, the element
"                          (if material is mixture) and the shell the photon
"                          is interacting with are sampled from the appropriate
"                          cross seections
"                        - Shell vacancies created in photo-absorption events
"                          are relaxed via emission of fluorescent X-Rays,
"                          Auger and Koster-Cronig electrons.
"                         Make sure to turn this option on for low energy
"                         applications.
"                         [ IEDGFL ]
"
"       Atomic relaxations, Rayleigh scattering,
"       Photoelectron angular sampling and Bound Compton scattering
"                         can also be turned On/Off on a region-by-region
"                         basis. To do so, put e.g.
"
"       Atomic relaxations= On in Regions   or
"       Atomic relaxations= Off in regions
"
"                         in your input file. Then use
"
"       Bound Compton start region=
"       Bound Compton stop region=
"                or
"       Rayleigh start region=
"       Rayleigh stop region=
"                or
"       Relaxations start region=
"       Relaxations stop region=
"                or
"       PE sampling start region=
"       PE sampling stop region=
"
"                         each followed by a lost of of one or more
"                         start and stop regions separated by commas.
"                         Example:
"        Atomic relaxations= On in Regions
"        Relaxations start region=  1, 40
"        Relaxations stop region=  10, 99
"                         will first turn off relaxations everywhere and
"                         then turn off in regions 1-10 and 40-99.
"                         Note that input is checked against min. and max.
"                         region number and ignored if
"                         start region < 1 or stop_region > $MXREG or
"                         start region > stop region.
"
"                         ECUT, PCUT and SMAX can also be set on a
"                         region-by-region basis. To do so, iclude
"                         in your input file
"
"         Set XXXX=              f_value1, f_value2, ...
"         Set XXXX start region= i_value1, i_value2, ...
"         Set XXXX stop region=  j_value1, j_value2, ...
"
"                         where XXXX is ECUT, PCUT or SMAX ,
"                         f_value1, f_value2,... are the desired values for XXXX
"                         and i_value_i and j_value_i are the start and
"                         stop regions.
"
"*******************************************************************************
"
"                    VARIANCE REDUCTION
"                    ******************
"
"  Delimeter:       :start variance reduction:
"                   :stop variance reduction:
"
"  ELECTRON RANGE REJECTION
"         = off        (0)  No electron range rejection
"         = on         (1)  Do electron range rejection.
"                           There are 2 components to range rejection.
"                           One uses the EGSnrc range rejection below ESAVEIN
"                           and terminates any charged particle which cannot get
"                           out of its local region.
"                           The second component terminates any charged particle
"                           which cannot reach the cylinder which encloses the
"                           cavity region and any other region of the same
"                           material as the cavity.  This cylinder is determined
"                           automatically.
"                           The parameter ESAVEIN also plays a role (see below)
"                           [IREJCT]
"
"  ESAVEIN             (R)  If ELECTRON RANGE REJECTION is on, discard an
"                           electron  when E< ESAVEIN and RANGE < CDIST
"                           where CDIST is closest distance to region of
"                           interest specified below. This ignores brem
"                           losses below ESAVEIN.
"                           This parameter must be input even if not used.
"                           Note - ESAVEIN is total energy (with 511 keV)
"
"  EXPONENTIAL TRANSFORM C     (R)
"                           PARAMETER FOR PATHLENGTH BIASING <0 FOR SHORTENING
"                           IF 0.0, NO BIASING DONE
;
"
"  PHOTON FORCING
"        = Off         (0)    NORMAL PHOTON TRANSPORT (NO FORCING)
"        = On          (1)    FORCE PHOTON INTERACTIONS EXPLICITLY
"                             MUST SET START AND STOP FORCING IN THIS CASE
"
"  START FORCING       (I)    NUMBER OF PHOTON INTERACTION/HISTORY AT WHICH
"                             TO START FORCING PHOTON INTERACTIONS
"
"  STOP FORCING AFTER  (I)    NUMBER OF PHOTON INTERACTION/HISTORY AFTER WHICH
"                             TO STOP FORCING PHOTON INTERACTIONS
"
"                             STOP FORCING AFTER > OR = START FORCING
"
;
"*******************************************************************************
"
"                             PLOT CONTROL INPUTS
"                             *******************
"*******************************************************************************
"
"  PLOT CONTROL DELIMETERS:   :start plot control:
"                             :stop plot control:
"
"
"   PLOTTING
"          = Off         (0)   no plots or plot files to be prepared
"          = Histogram   (1)   histogram plotting
"          = Point       (2)   xy graph
"
"
"  ONLY IF not PLOTTING= Off
"
"   PLOT RADIAL REGION IX  (M)  radial regions to plot vs angle
"                               (= 0 for no plots)
"
"   PLOT CONICAL REGION IC  (M)  angular intervals to plot vs radius
"                               (= 0 for no plots)
"
"*****************************************************************************"
"
"                       USER DEFINED MACROS
"                       *******************
;
"******************************************************************************
;
REPLACE {$VERSION} WITH {,' ',};
REPLACE {$ONE-EPS} WITH {0.9999} "USED TO KEEP THE BEAM INSIDE THE TARGET"
REPLACE {$NSWTCH} WITH     {8}   "# OF NRC SWITCHES FOR CONTROLLING SCATTERING"
REPLACE {$MXMED} WITH      {3}    "MAX # OF MEDIA"
REPLACE {$MXREG} WITH      {1153}"#REGIONS, $MAXRADII*$MAXCDOSE+1(VAC)"
REPLACE {$MXSTACK} WITH    {100}"MAXIMUM STACK"
REPLACE {$MAXCDOSE} WITH   {48} "MAX # OF DOSE SCORING CONICAL ZONES"
REPLACE {$MAXCANGLE} WITH  {48} "MAX # OF CONICAL BOUNDARIES (includes 180o )"
REPLACE {$MAXRADII} WITH   {65} "MAX # OF DOSE SCORING RADIAL ZONES"
REPLACE {$MAXRADII+1} WITH {66} "MAX # OF DOSE SCORING RADIAL ZONES + 1"
REPLACE {$MAXRC} WITH      {65} "MAX(MAXRADII,MAXCDOSE)"
REPLACE {$MXRDIST} WITH {1000}   "# OF POINTS IN RADIAL DISTRIBUTION FIT"
REPLACE {$MAXIT} WITH {5}         "max # of parameters to be scored
                                  "(1) dose from incident photon and its
                                  "    non-photon secondaries
                                  "(2) dose from first photon secondary and
                                  "    its non-photon secondaries
                                  "(3) dose from second photon secondary and
                                  "    its non-photon secondaries
                                  "(4) dose from third or greater photon
                                  "    secondary and its non-photon secondaries
                                  "(5) dose from brem annih photons and their
                                  "    secondaries

REPLACE {$CAVITY}   WITH {0}  "CAVITY CALCULATION"
REPLACE {$EDK}      WITH {1}  "ENERGY DEPOSITION KERNEL CALCULATION"
REPLACE {$DOSE}     WITH {2}  "DOSE DISTRIBUTION ONLY"
REPLACE {$DOSE-EDK} WITH {3}  "BOTH DOSE AND EDK CALCULATION"
;

REPLACE {$tot}  WITH {0}  "total energy"
REPLACE {$pri}  WITH {1}  "primary energy"
REPLACE {$sc1}  WITH {2}  "first scatter energy"
REPLACE {$sc2}  WITH {3}  "2nd scatter energy"
REPLACE {$msc}  WITH {4}  "multiple scatter energy"
REPLACE {$rad}  WITH {5}  "bremsstrahlung energy"
;

REPLACE {$EPSILON} WITH {1.E-6} "in HOWFAR particles closer than $EPSILON"
                                "are assumed at origin"
;

" We want the output of the subroutines egs_init and egs_finished "
" to be echoed to the list file => we replace the default $egs_info macro "
" Taken from cavrznrc.mortran. Sneaky!"
REPLACE {$egs_info(#,#);} WITH {
    write(6,{P1}) {P2}; write(1,{P1}) {P2};
};

REPLACE {$MY-OLD-RAYLEIGH-SCATTERING;} WITH {
   ;IF(IRAYLR(irin).EQ.1) [
     $AUSCALL($RAYLAUSB);
     NPold = NP;
     :SAMPLING-LOOP: LOOP [$RANDOMSET mXXX;
      $SET INTERVAL mXXX,RCO; $EVALUATE mX2 USING RSCT(mXXX);
      mQ2=mX2*RMSQ/(20.60744*20.60744);
      COSTHE=1.-mQ2/(2.*E(NP)*E(NP));
      IF (ABS(COSTHE).GT.1.0) GO TO :SAMPLING-LOOP:;
      mCSQTHE=COSTHE*COSTHE;
      mREJF=(1.0+mCSQTHE)/2.0;
      $RANDOMSET mRNNORJ;
     ] UNTIL (mRNNORJ <= mREJF);
     SINTHE=SQRT(1.0-mCSQTHE); CALL UPHI(2,1);
     IR(NP) = ibsearchrev(W(NP),nc,cosalp)+1;
     $AUSCALL($RAYLAUSA);
   ]
}
REPLACE {$MY-RAYLEIGH-SCATTERING;} WITH {
   ;IF(IRAYLR(irin).EQ.1) [
     $AUSCALL($RAYLAUSB);
     NPold = NP;
     call egs_rayleigh_sampling(MEDIUM,E(NP),MGLE,LMGLE,COSTHE,SINTHE);
     CALL UPHI(2,1);
     IR(NP) = ibsearchrev(W(NP),nc,cosalp)+1;
     $AUSCALL($RAYLAUSA);
   ]
}


APPEND
{;
$REAL SPMFP,TEMP,TEMP1,PATHLT;
$REAL DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,EPSLON,ARG;
$INTEGER IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,NRCDUM;
;} TO
{$DEFINE-LOCAL-VARIABLES-PHOTON;}

"MACRO USED FOR FORCING FIRST PHOTON INTERACTION ON THE SPOT"
REPLACE {$SELECT-PHOTON-MFP;} WITH {;
nftime = nftime + 1;
IF ( interact_now ) [
    interact_now = .false.;
    nftime = nftime-1;"reset to zero since no actual forcing"
    DPMFP=0.0;
]
ELSEIF ((IFORCE = 0)|(NFTIME > NFMAX)|(NFTIME < NFMIN)) [
"IF ((IFORCE = 0)|(NFTIME > NFMAX)|(NFTIME < NFMIN)) ["
    $RANDOMSET RNNO35;IF(RNNO35 = 0.0)[RNNO35=1.E-30;]
    "DPMFP=-LOG(RNNO35);"
    SPMFP=-LOG(RNNO35);
    IF( (CEXPTR.LT.1.0) .AND.(NFTIME.GE.NFMIN) .AND.(NFTIME.LE.NFMAX)
        .AND.( ((W(NP).GT.0.0).AND.(CEXPTR.GT.0.0)).OR.(CEXPTR.LT.0.0))
        )[
        TEMP=CEXPTR*W(NP);TEMP1=1.0-TEMP;
        SPMFP=SPMFP/TEMP1;WT(NP)=WT(NP)*EXP(-SPMFP*TEMP)/TEMP1;
    ]
    DPMFP=SPMFP;
]
ELSE[
    $RANDOMSET RNNO35;IF(RNNO35 = 0.0)RNNO35=1.E-30;
    nftime = nftime + 1;    DUMU=USTEP;
    DUMX=X(NP);DUMY=Y(NP);DUMZ=Z(NP);
    IRODUM=IROLD;IRNDUM=IRNEW;IRDUM=IR(NP);MEDDUM=MEDIUM;
    IDUM=IDISC;
    PATHL=0.0;MEDTMP=0;
    LOOP[
        USTEP=VACDST;
        IROLD=IR(NP);MEDIUM=MED(IROLD);
        IF(MEDIUM=0)["vacuum"
            DELTAP=0.;
        ]
        ELSE[
            IF(MEDTMP.NE.MEDIUM)[
               MEDTMP=MEDIUM;
               $SET INTERVAL GLE,GE;
               $EVALUATE DELTAP USING GMFP(GLE);
            ]
            IF(IRAYLR(IROLD).EQ.1)[ $EVALUATE COHFAC USING COHE(GLE); ]
            ELSE[ COHFAC=1.0; ]
        ]
        CALL HOWFAR;
        IF(DELTAP~=0) PATHL=PATHL+USTEP/(DELTAP*COHFAC);
        "only add to pathl if not going through vacuum"
        IF(IRNEW.EQ.1) EXIT;
        IR(NP)=IRNEW;
        X(NP)=X(NP)+USTEP*U(NP);
        Y(NP)=Y(NP)+USTEP*V(NP);
        Z(NP)=Z(NP)+USTEP*W(NP);
    ]
    USTEP=DUMU;
    X(NP)=DUMX;Y(NP)=DUMY;Z(NP)=DUMZ;
    IROLD=IRODUM;IRNEW=IRNDUM;IR(NP)=IRDUM;MEDIUM=MEDDUM;
    IDISC=IDUM;
    IF(CEXPTR.EQ.0)[
        IF(PATHL.LE.1.0E-3)[GWAIT=PATHL*(1.-0.5*PATHL);]
        ELSE[GWAIT=1.-EXP(-PATHL);]
    ]
    GWTOLD=WT(NP);
    WT(NP)=GWTOLD*GWAIT;

    IF(CEXPTR.EQ.0)[
        EPSLON=RNNO35*GWAIT;
        IF(EPSLON.LE.1.0E-3)[
            IF(NFTIME.EQ.1)EXPMFP=EPSLON*(1.+EPSLON);
            DPMFP=EPSLON*(1.+0.5*EPSLON);
        ]
        ELSE[
            ARG=1./(1.-EPSLON);
            DPMFP=LOG(ARG);
            IF(NFTIME.EQ.1)EXPMFP=EPSLON*ARG;
        ]
    ]
    ELSE[
        TEMP=CEXPTR*W(NP);TEMP1=1.0-TEMP;
        PATHLT=PATHL*TEMP1;
        IF(ABS(PATHLT).LE.1.0E-3)[
            SPMFP=PATHL*RNNO35*(1.0-0.5*PATHLT*(1.0-RNNO35));
            GWAIT=PATHL*(1.0-0.5*PATHLT)*EXP(-SPMFP*TEMP);
            DPMFP=SPMFP;
        ]
        ELSE[
            GWAIT=1.-EXP(-PATHLT);
            SPMFP=-LOG(1.0-RNNO35*GWAIT)/TEMP1;
            GWAIT=GWAIT*EXP(-SPMFP*TEMP)/TEMP1;
            DPMFP=SPMFP;
        ]
    ]
]

};

"Macro that gets cone and radius numbers from the region number
REPLACE {$GET-IX-IC(#);} WITH {
;
ix = ({P1} - 2)/nc + 1;
ic = {P1} - 1 - nc*(ix - 1);
}
;
"Macro that gets the geometry number from the conical and radial zones
REPLACE {$GET-IRL(#,#);} WITH {;irl = {P1} + nc*({P2} - 1) + 1;}
;

"------------------------------------------------------------------------------"
"Macro to force the initial photon interaction at the origin. It finds second- "
"ary particles' starting regions according to their direction from this first "
"interaction using a binary search algorithm.This scheme has been used to avoid"
" round-off errors when the particle is at the origin .                        "
"------------------------------------------------------------------------------"
"To implement this, one has to:                                                "
"   - set flag interact_now = .FALSE.                                          "
"   - for edk-source call this macro instead of shower                        "
"                                                                 EMH Jan,2003"
"-----------------------------------------------------------------------------"
REPLACE {$DO_PHOTON_SHOWER} WITH {
NP=1; NPold = NP;      "Set the old stack counter"
EDEP = 0.0;            "initially no energy deposition"
DNEARIN=0.0;LATCHIN = 0;
IQ(1)=IQIN; E(1)=EI; U(1)=UIN; V(1)=VIN; W(1)=WIN;
$TRANSFER PROPERTIES TO (1) FROM IN;
Mgle=LOG(ei);
MEDIUM= MED(irin);"uses medium from region irin, set to 2 in INPUTS"
IF(EI<=PCUT(irin))[
   IF(medium>0)[
    IF(EI>AP(medium))[ IDR=$EGSCUTAUS;]ELSE[IDR=$PEGSCUTAUS;]
   ] ELSE [IDR=$EGSCUTAUS; ]
   EDEP=EI;
   $AUSCALL(IDR);
]
ELSE[
$SET INTERVAL Mgle,GE;
$EVALUATE GMFPR0 USING GMFP(Mgle);

Mcohfac = 1.0;
IF (IRAYLR(irin).EQ.1)[
   $EVALUATE Mcohfac USING COHE(Mgle);
]

$RANDOMSET RNNO36;
"   GBR1=PAIR/(PAIR+COMPTON+PHOTO)=PAIR/GTOTAL"
$EVALUATE GBR1 USING GBR1(Mgle);
IF((RNNO36.LE.GBR1*Mcohfac).AND.(E(NP).GT.RMT2) )["IT WAS A PAIR PRODUCTION"
    CALL PAIR;
    "There should be NPold ... NP particles in the stack"
     DO i = NPold,NP[
       IR(i) = ibsearchrev(W(i),nc,cosalp)+1;
     ]
    $AUSCALL($PAIRAUSA);
]
ELSE["GBR2=(PAIR+COMPTON)/GTOTAL"
  $EVALUATE GBR2 USING GBR2(Mgle);
  IF (RNNO36.LT.GBR2*Mcohfac)[
     IF (idopp.gt.0)[CALL COMPT_NO_DOPP;]
     ELSE           [CALL COMPT;]
    "There should be NPold ... NP particles in the stack"
     DO i = NPold,NP[
       IR(i) = ibsearchrev(W(i),nc,cosalp)+1;
     ]
     $AUSCALL($COMPAUSA);
  ]
  ELSE[
     IF (RNNO36.LT.Mcohfac)[
       CALL PHOTO;
       "There should be NPold ... NP particles in the stack"
       DO i = NPold,NP[
          IR(i) = ibsearchrev(W(i),nc,cosalp)+1;
       ]
       $AUSCALL($PHOTOAUSA);
     ]
     ELSE[
       $MY-RAYLEIGH-SCATTERING;
     ]
  ]
]
;
WHILE (np > 0) [
    ;
    IF( iq(np) = 0 ) [ call photon(ircode); ]
    ELSE             [ call electr(ircode); ]
]
]
;
}
;
"select direction isotropically in 4 Pi"

REPLACE{$SELECT-4PI-DIRECTION} WITH {;
    $RANDOMSET COSTHE;   COSTHE=2.*COSTHE-1;
    SINTHE=SQRT(1.0-COSTHE**2);
    $RANDOMSET PHI;PHI=TWOPI*PHI;
    uin = SINTHE*COS(PHI); vin = SINTHE*SIN(PHI); win = COSTHE;
};

"-----------------------------"
"This is only used if IDAT = 0"
"-----------------------------"
REPLACE {$UPDATE_BATCH_LAST_HISTORY} WITH {;
"update deposited energy in cavity with last history"
"aux      = cavdose_tmp; aux2 = aux*aux;"
cavdose  = cavdose  + cavdose_tmp;
cavdose2 = cavdose2 + cavdose_tmp*cavdose_tmp;
cavdose_tmp = 0.0;
"update deposited energy in each region"
DO i = 0,$MAXIT[
 DO irl = 2,NREG[
   "aux = dose_tmp(irl,i); aux2 = aux*aux;"
   dose(irl,i)  = dose(irl,i)  + dose_tmp(irl,i);
   dose2(irl,i) = dose2(irl,i) + dose_tmp(irl,i)*dose_tmp(irl,i);
   dose_tmp(irl,i) = 0.0;
 ]
]
};

"-----------------------------"
"    This is always used      "
"-----------------------------"
REPLACE {$UPDATE_LAST_HISTORY} WITH {;
"update deposited energy in cavity with last history"
"aux      = cavdose_tmp; aux2 = aux*aux;"
cavdose  = cavdose  + cavdose_tmp;
cavdose2 = cavdose2 + cavdose_tmp*cavdose_tmp;
"update deposited energy in each region"
DO i = 0,$MAXIT[
 DO irl = 2,NREG[
   "aux = dose_tmp(irl,i); aux2 = aux*aux;"
   dose(irl,i)  = dose(irl,i)  + dose_tmp(irl,i);
   dose2(irl,i) = dose2(irl,i) + dose_tmp(irl,i)*dose_tmp(irl,i);
 ]
]
};

"------------------------------"
"To be used in conjunction with"
"$UPDATE_BATCH_LAST_HISTORY    "
"------------------------------"
REPLACE {$STORE_RAW_DATA} WITH {;
rewind(data_unit);
write(data_unit,*) cavdose, cavdose2;
DO irl = 2,NREG[write(data_unit,*) (dose(irl,i),dose2(irl,i),i=0,$MAXIT);]
$PUT RNG STATE ON UNIT data_unit;
write(data_unit,*) IHSTRY,TIMCPU+TMCPUO;
write(data_unit,*) NCOMPT,NCREJ;
write(data_unit,*) EDEPRELAX;
write(data_unit,*) anorm;
}
;
REPLACE {$READ_OLD_DATA} WITH {;
OUTPUT;(' About to read the previous .egsdat file');
data_unit = egs_open_datfile(4,0,1,'.egsdat');
read(data_unit,*,err=:NO_FILE:,end=:NO_FILE:) cavdose, cavdose2;
DO irl = 2,NREG[
    read(data_unit,*,err=:NO_FILE:,end=:NO_FILE:)
        (dose(irl,i),dose2(irl,i),i=0,$MAXIT);
]
$RETRIEVE RNG STATE FROM UNIT data_unit;
read(data_unit,*,err=:NO_FILE:,end=:NO_FILE:) NCASEO,TMCPUO;
read(data_unit,*,err=:NO_FILE:,end=:NO_FILE:) NCOMPT,NCREJ;
read(data_unit,*,err=:NO_FILE:,end=:NO_FILE:) EDEPRELAX;
read(data_unit,*,err=:NO_FILE:,end=:NO_FILE:) anorm;
close(data_unit);
GO TO :FILE_READ:;
:NO_FILE:;
OUTPUT61;('NO egsdat file found or end of file reached, aborting ...');
STOP;
:FILE_READ:;
}
;

REPLACE {$PROCESS#COMPONENT;} WITH {;

F{P1}   = 0;
F{P1}Un = 0;
DO ic =1,nc [
  DO ix=1,nr[
    $GET-IRL(ic,ix);
;
    aux = dose(irl,${P1})/ncaset;
    aux2 = dose2(irl,${P1})/ncaset;
    aux2 = (aux2 - aux*aux)/(ncaset-1);
;
    F{P1}   = F{P1}   + aux;
    F{P1}Un = F{P1}Un + aux2;
;
    IF( aux2 > 0 ) aux2 = sqrt(aux2);

    edk(irl,${P1})   = aux*anorm;
    edk2(irl,${P1}) = aux2*anorm;

    energy2dose = 1.602E-10/amass(ic,ix);
    dose(irl,${P1})  = aux  * energy2dose;
    dose2(irl,${P1}) = aux2 * energy2dose;
  ]
]
;
F{P1}   =      F{P1}    * anorm;
F{P1}Un = sqrt(F{P1}Un) * anorm;
;
OUTPUT61 F{P1},F{P1}Un,100.0*F{P1}Un/F{P1};
('  energy fraction F{P1} = ',f10.6,' +/- ',f10.6,' [',f8.4,' %]'/);
;

};



%E     "edknrc.mortran"
"                       COMMON BLOCK DEFINITIONS
"
"CHARACTERS BLANK,*,A,B,C,D,I,M,R,S,T,U,V IN I*4(F4) OR CHARACTER(F77) FORM"
REPLACE {;COMIN/CHARS/;} WITH
"       ================
{;
$TYPE BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,SCHAR,
      TCHAR,UCHAR,VCHAR;
COMMON/CHARS/
BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,SCHAR,TCHAR,UCHAR,VCHAR;
}

"------------------------------------------------------------------"
"*** USER--A COMMON FOR THE 'USER' TO 'USE'                        "
"------------------------------------------------------------------"
REPLACE {;COMIN/USER/;} WITH
{;
COMMON/USER/interact_now;
$LOGICAL interact_now;

COMMON/USERRR/ESAVEIN,IREJCT;
$REAL ESAVEIN;
$INTEGER IREJCT;
"                                                                            "
"COMMON USED FOR RANGE REJECTION                                             "
"ESAVEIN        UPPER ENERGY FOR ZONAL RANGE REJECTION                       "
"IREJCT        = 0 => NO ELECTRON RANGE REJECTION                            "
"              = 1 => DO ELECTRON RANGE REJECTION                            "

COMMON/USERMI/EXPMFP,GWTOLD,ICSDA;
$INTEGER ICSDA;
$REAL    EXPMFP,GWTOLD;
"                                                                       "
"COMIN/USER-MISC/USERMI  EXTRA USER COMMON FOR DOSRZnrc                 "
"EXPMFP   EXPONENTIAL MEAN-FREE-PATH USED FOR INTERACTION FORCING       "
"GWTOLD   OLD WEIGHT                                                    "
"ICSDA    CSDA CALCULATION ON(1) OR OFF(0)                              "
;

;COMMON/USERVR/
CEXPTR,GWAIT,cs_enhance,cs_enhance_current,
IFORCE,NFMIN,NFMAX,NFTIME,IFPB,IQINC,MONOEN,
ienhance,iefl($MXREG),ics_enhance,
do_fast_step;
$INTEGER ienhance,iefl,ics_enhance,
         IFORCE,NFMIN,NFMAX,NFTIME,IFPB,IQINC,MONOEN;
$REAL    CEXPTR,GWAIT,cs_enhance,cs_enhance_current;
$LOGICAL do_fast_step;

"COMIN/USER-VARIANCE-REDUCTION"
"       CEXPTR       C VARIABLE FOR EXPONENTIAL PATHLENGTH TRANSFORMATION"
"       GWAIT        WEIGHT ADJUSTMENT IN FORCING INTERACTIONS MACRO     "
"       IFORCE       ONLY FORCE PHOTON INTERACTIONS IF THIS IS NON-ZERO  "
"       NFMIN,NFMAX,NFTIME  FOR FORCE PHOTON INTERACTIONS MACRO          "
"       IFPB         FLAGS IF ISOURC = 0,2 OR 4                          "
"       IQINC        INCIDENT CHARGE                                     "
"       MONOEN = 0 IF MONOENERGETIC BEAM, = ELSE IF SOURCE DIST'N INPUT  "
"       ics_enhance  flag to indicate if both some regions are asked     "
"                    and the enhancement factor is > 1.001               "
"       cs_enhance   cross section enhancement factor as input by user   "
"       ienhance     flag indicating whether an interaction in enhanced  "
"                    region occurred                                     "
"       iefl(ir)     flag indicating whether in a specific region        "
"                    enhancing should occur, set to 1 if yes 0 if no     "
"       do_fast_step If iforce is set to 1 and the source is a front     "
"                    parallel beam, the photon forcing macro uses        "
"                    pre-calculated path-lengths and mfp's to sample the "
"                    photon interaction distance for the first forced    "
"                    photon. This is a bug if the incident particle is   "
"                    an electron! To avoid this problem, do_fast_step    "
"                    is set to .false. in this case. IK, April 2000      "
}
;
APPEND
{;
COMMON/GMFPDATA/GMFPR0;
} TO {$COMIN-PHOTON;}
;

"PRINTER CONTROLS"
REPLACE {;COMIN/PRINTC/;} WITH {
 ;COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE;
 $INTEGER ICHPIN,ILPIN,IOUT,IPAGE;
"Added type declarations, IK January 10 2000"
};

"       =================
"ICHPIN  NUMBER OF CHARACTERS PER INCH
"ILPIN   NUMBER OF LINES PER INCH
"IOUT    OUTPUT UNIT (IOUT=1, FORTRAN UNIT 1)
"IPAGE   =1 => PAGE THROW

;
REPLACE {;COMIN/GEOM/;} WITH
"       ===============          "
{;
COMMON/GEOM/
TANALP(0:$MAXCANGLE),TANAL2(0:$MAXCANGLE),
COSALP(0:$MAXCANGLE),SINALP(0:$MAXCANGLE),
ALPHA(0:$MAXCANGLE),RSPH(0:$MAXRADII),RSPH2($MAXRADII+1),
COSWT($MAXCANGLE),
NC,NR,NREG,NPLAN1,NPLAN2,IDNEAR;
$REAL TANALP, TANAL2, COSALP, SINALP, ALPHA, RSPH, RSPH2, COSWT;
$INTEGER NC,NR,NREG,NPLAN1,NPLAN2,IDNEAR;
}
"
"GEOMETRICAL INFORMATION"
"TANALP(IC)    TANGENT OF THE OPENING ANGLE OF THE IC'TH CONE
"TANAL2(IC)    TANALP(IC)**2
"COSALP(IC)    COSINE OF THE OPENING ANGLE OF THE IC'TH CONE
"SINALP(IC)    SINE   OF THE OPENING ANGLE OF THE IC'TH CONE
"ALPHA(IC)     CONTAINS THE REAL VALUED COORDINATE OF THE IC'TH CONE
"RSPH(IX)      CONTAINS THE REAL VALUED COORDINATE OF THE IX'TH SPHERE
"RSPH2(IX)     =RSPH(IX)**2
"NC/NR         NUMBER OF CONICAL SLABS/SPHERICAL REGIONS DEFINING THE TARGET
"NREG          =NC*NR+1 (+1 FOR THE SURROUNDING VACUUM)
"NPLAN1        CONE REGION THAT HAS THE 90 DEGREE CONE AS THE GREATER CONE
"NPLAN2        NPLAN1+1

;
"FOUR COMMONS FOR INPUT AND OUTPUT"
REPLACE {;COMIN/IODAT1/;} WITH
"       =================
{;
CHARACTER*1 TITLE(80);
COMMON/IODAT1/TITLE;
}
"
"TITLE       : 80 CHARACTER MAX, INPUT BY USER FOR DESCRIPTIVE PURPOSES
"DATEN,TIMEN : MACHINE VARIABLES FOR TIME AND DATE

;
REPLACE {;COMIN/IODAT2/;} WITH
"       ================
{;
COMMON/IODAT2/
NCASEO, NCASET, AMASS($MAXCDOSE,$MAXRADII),TMCPUO,ECUTIN,PCUTIN,
EDKF, IDAT,IRESTART,IDORAY,IDOPES,IVAL,datcount;
$LONG_INT NCASEO, NCASET;
$REAL    AMASS,TMCPUO,ECUTIN,PCUTIN;
$INTEGER IDAT,IDORAY,IDOPES,IVAL,IRESTART,EDKF,datcount;
"Added type declarations, IK January 10 2000"
}
"
"AMASS(IC,IX)  MASS OF ZONE WITH COORDINATES (IC,IX)
"TMCPUO        CPU TIME USED IN PREVIOUS SESSIONS
"ECUTIN        GLOBAL ECUT FOR THIS SIMULATION
"PCUTIN        GLOBAL PCUT FOR THIS SIMULATION
"IDAT          = 0 STORE DATA ARRAYS FOR RE-USE
"              = 1 DON'T STORE THEM
"IDORAY        = 1 INCLUDES RAYLEIGH SCATTERING
"              = 0 DOES NOT INCLUDE RAYLEIGH SCATTERING
"IDOPES        = 1 INCLUDES PHOTOELECTRON ANGLE SELECTION
"              = 0 DOES NOT INCLUDE PHOTOELECTRON ANGLE SELECTION


"Define a common for scoring"
REPLACE {;COMIN/SCORE/;} WITH {;
  common/score/ dose($MXREG,0:$MAXIT),dose2($MXREG,0:$MAXIT),
                dose_tmp($MXREG,0:$MAXIT),
                edk($MXREG,0:$MAXIT) ,edk2($MXREG,0:$MAXIT),
                cavdose, cavdose2, cavdose_tmp,
                muro,NCREJ, NCOMPT,EDEPRELAX, anorm,
                sc_last($MXREG),icase, ifull,itrad,IOUTSP,
                cavreg($MXREG), iscavreg($MXREG), numcavreg;

real*8 dose, "for scoring energy deposited in all regions"
       dose2,"for scoring energy squared on a history-by-history basis"
       dose_tmp,
       cavdose,      "dose in the cavity"
       cavdose2,     "squared of the cavity dose"
       cavdose_tmp,  "temporary cavity dose scoring quantity"
       muro,         "mass attenuation coeff. for primary photon"
     "-----------------------------------------"
     "Energy Deposition Kernels edk = Edep/Etot"
     "-----------------------------------------"
       edk,edk2,
       EDEPRELAX,
       anorm;

$LONG_INT sc_last,icase;

$LONG_INT NCREJ,NCOMPT;

$INTEGER ifull,     "type of calculation"
         cavreg,    "regions comprising cavity"
         iscavreg,  "flag to identify cavity regions"
         numcavreg, "number of cavity regions"
         itrad,     "flag for radiative energy"
         IOUTSP;    "flag for spectrum output"

};

"Define a common with a flag to turn off Doppler broadening"
REPLACE {;COMIN/DODOPP/;} WITH {;
common/DODOPP/idopp;
$INTEGER idopp; "if > 0 Doppler broadening neglected"
};


"Define a common for holding the source information"
REPLACE {;COMIN/SOURCE/;} WITH {;
  common/source/ein,uin,vin,win,xin,yin,zin,wtin,iqin,irin,ncase,ISOURC,ENFLAG;
  $INTEGER       iqin,irin,ISOURC,ENFLAG;
  $LONG_INT      ncase;
  $REAL          ein,uin,vin,win,wtin,xin,yin,zin;
};
;

"COMMONS USED FOR NON-MONOENERGETIC BEAM DATA                             "
"       NOTE MONOEN IS PASSED IN USER                                     "
"                                                                         "
REPLACE {$NENSRC} WITH {500}     "MAX # OF POINTS IN ENERGY DISTRIBUTION  "
"        =======                                                          "
REPLACE {$INVDIM} WITH {1000}    "DIMENSION CONTROLS GRID SIZE FOR INVERSE"
"        =======                                                          "
;
REPLACE {;COMIN/SPECTR/;} WITH
"       ================="
{;
COMMON/SPECTR/
CDFINV($INVDIM,2),ENSRCD(0:$NENSRC),SRCPDF($NENSRC),SRCCDF($NENSRC),
NENSRC;
$INTEGER NENSRC;
$REAL    CDFINV,ENSRCD,SRCPDF,SRCCDF;
"Added type declarations, IK January 10 2000"
}
"CDFINV   INVERSE OF THE CUMULATIVE ENERGY PROBABILITY DISTRIBUTION FUNCTION
"ENSRCD   ENERGY MESH POINTS FOR THE ENERGY PROBABILITY FUNCTION
"SRCPDF   ENERGY PROBABILITY DISTRIBUTION FUNCTION
"SRCCDF   CUMULATIVE ENERGY PROBABILITY DISTRIBUTION FUNCTION
"NENSRC   # OF ENERGY BINS USED TO DEFINE THE DISTRIBUTION
;
"COMMON USED FOR PLOTTING ROUTINE
REPLACE {;COMIN/PLOTC/;} WITH
"       ================
{;
COMMON/PLOTC/
IPLOTR($MAXRADII),IPLOTZ($MAXCANGLE),IOPLOT,IPLTLP,IPLTPL,IPLPHB,NPLOTR,NPLOTZ;
$INTEGER IPLOTR,IPLOTZ,IOPLOT,IPLTLP,IPLTPL,IPLPHB,NPLOTR,NPLOTZ;
"Added type declaration, IK, Jan 5 2000"
}
"IPLOTR(IX) = 0 NO PLOTS FOR CYLINDRICAL DOSE REGION IX
"           = 1 PLOTS FOR CYLINDRICAL DOSE REGION IX
"IPLOTZ(IX) = 0 NO PLOTS FOR PLANAR DOSE SLAB IZ
"           = 1 PLOTS FOR PLANAR DOSE SLAB IZ
"IOPLOT     = 0  NO PLOTS OR PLOT FILES TO BE PREPARED
"           = 1  plotting a histogram
"           = 2  plotting a point graph
"IPLTLP     = 0  DON'T PLOT IN EXECUTION OUTPUT
"           = 1  DO PLOT IN EXECUTION OUTPUT
"IPLTPL     = 0  DON'T PREPARE PLOT FILES FOR AN EXTERNAL PLOTTER
"           = 1  PREPARE PLOT FILES FOR AN EXTERNAL PLOTTER
"IPLPHB     = 1  POINT PLOT ON EXTERNAL PLOTTER
"           = 2  HISTOGRAM ON EXTERNAL PLOTTER
"           = 3  BOTH POINT PLOT AND HISTOGRAM ON EXTERNAL PLOTTER
"NPLOTR     NUMBER OF RADIAL PLOTS
"NPLOTZ     NUMBER OF Z-AXIS PLOTS

;

program edknrc;

implicit none;

;COMIN/
    BOUNDS,EDGE,ELECIN,EPCONT,GEOM,IODAT1,IODAT2,
    MEDIA,MISC,PHOTIN,SCORE,SOURCE,SPECTR,GetInput, STACK,
    THRESH,UPHIOT,USEFUL,USER,RANDOM,ET-Control,
    EGS-VARIANCE-REDUCTION,COMPTON-DATA,PLOTC,EGS-IO,
    DODOPP,PRINTC/;
"                                                  ^    "
"                                                  |    "
"   EGSnrc opens units explicitly, i.e.,___________|    "
"   this COMMON block  contains information             "
"   like extensions, unit numbers, file na-             "
"   mes, etc.                                           "

$DECLARE_TIMING_VARIABLES;

"***************************************************************************"
"$REAL     Em($MXSTACK);"
"$REAL     Um($MXSTACK),Vm($MXSTACK),Wm($MXSTACK),WTm($MXSTACK);"
$REAL     DNEARIN,RNNO36,GBR1,GBR2;
"integer*4 IQm($MXSTACK),LATCHm($MXSTACK),IRm($MXSTACK),NPm;"
integer*4 LATCHIN,IARG;

"***************************************************************************"
character*10  ch_var;
INTEGER       sini, sfin, ini, fin;
character*256 edkname;

"$INTEGER iout, ihstry, ibsearch, ibsearchrev;"
$INTEGER ihstry, ibsearch, ibsearchrev;

$INTEGER nbatch,        "$INTEGER and $REAL are defined in egsnrc.macros"
         nperbatch,     "they can be used (if employed consistently throughout"
         ibatch,        "the user code) e.g. to switch to double precision"
         i,j,ic,ix,
         irl,mednum,
         ircode,idr;

$REAL    ei,            "total energy"
         volume,        "volume subtended by concentric spheres and cones"
         cavitymass,    "mass of the air cavity"
         delcos,
         energy2dose;   "converts energy deposited to dose"

$REAL    EKMAX;

real*8   aux,aux2,error(0:$MAXIT);
real*8   Ftot,FtotUn,
         Fpri,FpriUn,
         Fsc1,Fsc1Un,
         Fsc2,Fsc2Un,
         Fmsc,FmscUn,
         Frad,FradUn,
         EDEPDUMMY;

$REAL     PHI;
$REAL     TIMCPU,TOTCPU;
real*8    terma,Mgle, Mcohfac;
$INTEGER  LMgle; "index for GMFP interpolation"
$LONG_INT jcase;
real*8   edk90, X90, X90scale;

COMMON/GMFPDATA/GMFPR0;
$REAL           GMFPR0;

$REAL mXXX, mQ2, mX2, mCSQTHE, mREJF, mRNNORJ;
$INTEGER LmXXX;

real*4 speed;

"********************************************************************"
"* Variables for storing quantities after a batch is completed      *"
"********************************************************************"
REAL*8     tdose($MXREG,0:$MAXIT),
           tdose2($MXREG,0:$MAXIT);
real*8     tcavdose,tcavdose2;
"********************************************************************"
"                EGSnrcMP variables and macros                       "
"********************************************************************"
" I/O units "
$INTEGER egs_open_file, egs_open_datfile, rng_unit, data_unit, edk_unit;
$INTEGER egs_get_unit;

external combine_results;

"IK: New parallel processing implementation. Only used if there is a
"    working C compiler. The macro $HAVE_C_COMPILER is defined in
"    machine.macros and is either #define HAVE_C_COMPILER;, if a working
"    C compiler was found, or NULL if no working C compiler was found.
"
$HAVE_C_COMPILER(#);

#ifdef HAVE_C_COMPILER;

real*8  last_dose, last2_dose, tmpf;
$REAL   part_dose, part2_dose, current_result, current_uncertainty;
$LONG_INT n_run,n_tot,n_last,n_left;
$INTEGER  n_job;
$LOGICAL first_time;

#endif;

$LOGICAL is_finished;

"******************************************************************************

"                       START OF EXECUTABLE CODE
"                       ************************


IOUT = 1;

"**********************************************************************"
"            STEP 0 : Initialize the EGSnrc system                     "
"**********************************************************************"
call egs_init;
is_finished = .true.;
"**********************************************************************"


$SET_ELAPSED_CPUTIME(CPUT0); "OBTAIN THE INITIAL STARTING TIME"

"******************************************************************************
"
"                       *** SECTION 1 ***
"
"------------------------------------------------------------------------------
"
"READ INPUTS AND CALCULATE ONE-TIME ONLY CONSTANTS
"
"------------------------------------------------------------------------------

call inputs;

" THE IRESTART=5 CASE, POST-PROCESSING FOR DISTRIBUTED RUNS, GOES HERE
" ADDED BY JT, NOV.98
IF(IRESTART.EQ.5)[

    call egs_combine_runs(combine_results,'.egsdat');

    jcase = 0;
    NBATCH= 0;      "DON'T WANT IT TO RUN ANY HISTORIES"
    NCASET= NCASEO; "To prevent a wrong normalization if some of the "
                    "parallel runs not available, IK, Jan 21 1999"
] "end of IRESTART = 5, DISTRIBUTED POST-PROCESSING"
ELSE[

    jcase = ncase;
    nbatch = 10; nperbatch = ncase/nbatch;
    IF(nperbatch = 0) nperbatch = 1;
      "Note that nbatch and nperbatch are not used for statistical analysis"
      "They are merely for printing information about the progress of the"
      "simulation"

]

IHSTRY=NCASEO; "reset the number of histories counter"

"---------------------------------------------------------------------"
"STEP 5  INITIALIZATION-FOR-AUSGAB                                    "
"---------------------------------------------------------------------"
itrad = $MAXIT-1;
"------------------------------------"
" dose component    index     latch  "
"------------------------------------"
"    total            0        All   "
"    primary          1         0    "
"    1st scat         2         1    "
"    2st scat         3         2    "
"    3rd +            4         3    "
"    radiative        5         4    "
"------------------------------------"


DO i=1,5[iausfl(i)=1;]DO i=6,25[iausfl(i)=0;] "normal execution"

"THESE FLAGS ARE THE MINIMUM SET NEEDED TO IDENTIFY PRIMARY AND SECONDARY"
iausfl(8) =1; "After BREMSSTRAHLUNG"
iausfl(14)=1; "After ANNIHILATION IN FLIGHT"
iausfl(15)=1; "After ANNIHILATION AT REST"
iausfl(19)=1; "After COMPTON"
iausfl(21)=1; "After Photo"
iausfl(25)=1; "After Rayleigh"

"-------------------------------------
"HATCH CALL PREPARATION AND EXECUTION"
"-------------------------------------

DUNIT=1; "SET LENGTH UNITS TO CMS"

OUTPUT; (//'CALL TO HATCH AT  ',$); call egs_time(6); write(6,*);


CALL HATCH; "INPUT THE PEGS GENERATED DATA"

OUTPUT; (//'HATCH COMPLETED AT ',$); call egs_time(6); write(6,*);

call isumry(iout);

$FLUSH_UNIT(IOUT);

IF(MONOEN.EQ.0) ["MONOENERGETIC INPUT BEAM"
    IF(IQIN.EQ.0)[EI=EIN;]ELSE[EI=EIN+RM;]
    EKMAX=EIN; "MAXIMUM KINETIC ENERGY"
]
ELSEIF(MONOEN.EQ.1)[ "ENERGY SPECTRUM"
    CALL ENSRC1; "NORMALIZE THE ENERGY DISTRIBUTION"
    EKMAX=ENSRCD(NENSRC); "MAXIMUM KINETIC ENERGY IN THE SPECTRUM"
    CALL ENSRCO;
]


"--------------------------------------------"
"GET TERMA T(E) FOR MONOENERGETIC PHOTON BEAM"
"--------------------------------------------"
IF(IQIN=0 & MONOEN=0 & (IFULL=$EDK | IFULL=$DOSE-EDK))["PSF calculation"
   MEDIUM= MED(2);
   Mgle=LOG(ein);"Mgle IS GAMMA LOG ENERGY"
   OUTPUT61;
   ('TERMA PER FLUENCE FOR MONOENERGETIC PHOTONS ON MATERIAL ',$);
   OUTPUT61 (MEDIA(I,MEDIUM),I=1,24);(24A1);
   OUTPUT61;
   ('--------------------------------------------------------'/);
   $SET INTERVAL Mgle,GE;"SET PWLF INTERVAL"
   Mcohfac = 1;       "If Rayleigh data available, Mcohfac"
   IF (IRAYLR(2) = 1)["equals SIG[Compt]+SIG[PHOT]/SIG[TOT]"
     $EVALUATE Mcohfac USING COHE(Mgle);
   ]
   $EVALUATE muro USING GMFP(Mgle);
   terma = 1./muro/rho(1)/Mcohfac;
   IF (IRAYLR(2) = 1)[
     OUTPUT61 ein,terma;
     ('T(',0PF8.3,')/Eo/Flu= (mu/rho) = ', 1PE11.4,' cm2/g <= with Rayleigh'/);
   ]
   OUTPUT61 ein,terma*Mcohfac;
   ('T(',0PF8.3,')/Eo/Flu= (mu/rho) = ', 1PE11.4,' cm2/g <= no Rayleigh'/);

]

"CHECK THAT THE DATA FILE HAD DATA OVER THE ENERGY RANGE REQUIRED"
DO I=1,NMED[
    IF((EKMAX.GT.UP(I)).OR.(EKMAX.GT.UE(I)-RM))[
        OUTPUT61 I,EKMAX,UP(I),UE(I);
        (//1X,50('*')//
         ' FOR MEDIUM',I3,' INCIDENT ENERGY=',F10.1,' MEV'/
         ' IS GREATER THAN COVERED BY DATA FILE WHERE UP,UE=',2F10.1,' MEV'/
         '     EXECUTION WILL TERMINATE AFTER COMPLETION OF INPUT FILE'//
         1X,50('*')//);
         GOTO :END-OF-RUN:;
    ]
] "END OF LOOP OVER MEDIA"

cavitymass = 0.0;
"Calculate the mass of each zone
DO ic = 1,nc[
   delcos = cosalp(ic - 1) - cosalp(ic);
   DO ix = 1,nr[
      $GET-IRL(ic,ix);
      mednum=med(irl);
      IF(mednum ~= 0)[
        volume = (twopi/3)*delcos*(rsph(ix)**3 - rsph(ix-1)**3);
        amass(ic,ix) = rho(mednum)*volume;
      ]
      ELSE [amass(ic,ix)=0;]
      "get cavity mass"
      IF (iscavreg(irl).eq.1)[
          cavitymass = cavitymass + amass(ic,ix);
      ]

   ] "end of ix loop
] "end of ic loop

"******************************************************************************
"
"                       *** SECTION 2 ***
"
"------------------------------------------------------------------------------
"
"WRITE THE HEADER"
WRITE(IOUT,100) TITLE; call egs_fdate(iout); write(iout,*);
WRITE(IOUT,200);WRITE(6,200); "PRINT HEADER FOR EXECUTION MESSAGES"
OUTPUT61;(' ');

"PRINT EXECUTION MODE"
IF(IRESTART.EQ.0)[WRITE(6,201);WRITE(IOUT,201);]
ELSEIF(IRESTART.EQ.1)[
    WRITE(6,202) NCASE,NCASEO;
    write(6,'(21x,a,$)') 'New RNG state: ';
    $SHOW-RNG-STATE(6); write(6,*);
    write(iout,'(21x,a,$)') 'New RNG state: ';
    $SHOW-RNG-STATE(iout); write(iout,*);
]
ELSEIF(IRESTART.EQ.3)[WRITE(6,204);WRITE(IOUT,204);GO TO :END-SIM:;]
ELSEIF(IRESTART.EQ.5)[WRITE(6,206);WRITE(IOUT,206);GO TO :END-SIM:;]

"SET CLOCK AT THE BEGINNING OF SIMULATIONS"
$INITIALIZE_ELAPSED_CPU_TIME;
$SET_ELAPSED_CPUTIME(CPUT1);
$INITIALIZE_ELAPSED_TOTAL_TIME;

"LOOP THROUGH THE NUMBER OF HISTORIES.
"initiate the shower ncase times"
;OUTPUT61;(' Starting shower simulation ...'/);

NCREJ=0; NCOMPT=0;
EDEPRELAX = 0.0;
anorm = 0;

"Open file for data storage, if requested "
"The file is opened in the temporary working directory"
IF( idat = 0 ) data_unit = egs_open_file(4,0,1,'.egsdat');


$FLUSH_UNIT(6);
$FLUSH_UNIT(IOUT);

"*******************************************************************"
"IK: New parallel processing implementation. Only used if there is a
"    working C compiler.
"*******************************************************************"
#ifdef HAVE_C_COMPILER;
;
/last_dose,last2_dose/ = 0;  n_tot = ncaseo;
first_time = .true.; is_finished = .false.;

:start_parallel_loop:;

IF( n_parallel > 0 ) [  "Job is part of a parallel run "

    part_dose = 0; part2_dose = 0;
    call egs_pjob_control(ncase,n_run,n_left,n_tot,part_dose,part2_dose,
                          current_result, current_uncertainty);
    IF( n_run = 0 ) [
        write(6,'(//a,a//)') '****** No histories left in job control file',
                      '       => end simulation';
        goto :END-SIM:;
    ]

    jcase     = n_run;
    nperbatch = jcase/nbatch;
    IF(nperbatch = 0) nperbatch = 1;


    IF( first_time ) [
        first_time = .false.; n_last = n_run;
        write(6,'(//a,i12,a//)') '****** Running ',n_run,' histories';
    ]
    ELSE [
        write(6,'(//a,i12,a)') '***** Finished ',n_last,' histories';
        write(6,'(/a/,20x,1pe11.4,a,0pf5.2,a/,a,i12,a//)')
  '      current result including previous runs and other parallel jobs: ',
         current_result, ' +/- ',current_uncertainty,' %',
  '      will run another ',n_run,' histories';
    ]
]
#endif;
"*******************************************************************"

DO icase=1,jcase[

   IHSTRY = IHSTRY + 1;

   interact_now = .true.;"force original photon to interact"
   NFTIME = 0;"RESET THE PHOTON FORCED INTERACTION COUNTER"

   "calculate the initial energy if a distribution is to be used"
   IF(MONOEN ~= 0)["if equal to 0, it is monoenergetic"
     CALL ENSRCH(EIN);   "returns K.E. from distribution"
     IF(IQIN.EQ.0)[EI = EIN;]ELSE[EI = EIN+RM;]  "total energy"
      " there was a check that the data file had data over the energy
      "range required, the location of it will eventually be in
      "ESRCIN.MOR
   ]

   IF ( ISOURC = 1 )["select direction isotropically in 4 Pi"
      interact_now = .false.;"don't force original particle to interact"
      $SELECT-4PI-DIRECTION;
      irin = ibsearchrev(win,nc,cosalp)+1;"binary search"
      "OUTPUT irin, 180.0/PI*acos(win);('initial region : ',I5,' at ', f8.3);"
      call shower(iqin, ei, xin, yin, zin, uin, vin, win, irin, wtin);
   ]
   ELSE IF (ISOURC = 0)[     "first photon interaction right at origin"
      interact_now = .false.;"handled outside shower allowing for "
      $DO_PHOTON_SHOWER;     "sorting outcoming particles according to "
                             "their angles into the correct region."
   ]
   ELSE IF (ISOURC = 2)[
      interact_now = .true.;
      /*
      write(81,*) '**************** new shower ';
      */
      call shower(iqin, ei, xin, yin, zin, uin, vin, win, irin, wtin);
   ]

   IF (MONOEN = 1 & iqin = 0)[     "polyenergetic photon beam"
      anorm = anorm + ein/GMFPR0; "<= score total terma"
   ]
   ELSE IF (MONOEN = 1 & iqin ~=0)["polyenergetic electron beam"
      anorm = anorm + ein;         "<= score kinetic energy"
   ]
   ELSE[                           "monoenergetic case handled below"
   ]

   ibatch = icase/nperbatch;
   IF ( mod(icase,nperbatch) = 0 ) ["print every batch end"
      $SET_ELAPSED_CPUTIME(CPUT2);
      TIMCPU = (CPUT2-CPUT1)*$CONVERSION_TO_SECONDS+$TIME_RESOLUTION;
      OUTPUT61 dble(100*icase)/dble(jcase), TIMCPU;
      (' Finished ',F7.1,'% of cases ', F8.1, ' secs elapsed');
      IF (IDAT = 0 )["Store data arrays for re-use"
         "Update scoring quantities with tmp's from last history"
         $UPDATE_BATCH_LAST_HISTORY;"this is done only if idat=0"
         $STORE_RAW_DATA;           "$UPDATE_LAST_HISTORY is done"
      ]                             "always."
      $FLUSH_UNIT(6);
      $FLUSH_UNIT(IOUT);
   ]

]
#ifdef HAVE_C_COMPILER;
;
IF( n_parallel > 0 ) [ goto :start_parallel_loop:; ]
#endif;
:END-SIM:;
$SET_ELAPSED_CPUTIME(CPUT2);
TIMCPU = (CPUT2-CPUT1)*$CONVERSION_TO_SECONDS+$TIME_RESOLUTION;
TOTCPU = (CPUT2-CPUT0)*$CONVERSION_TO_SECONDS+$TIME_RESOLUTION;

speed = 3600.*dble(ihstry)/(TIMCPU+TMCPUO);

OUTPUT61 TOTCPU, TIMCPU+TMCPUO, speed;
(//' time elapsed: ',F7.1,' secs cputime =  ',F7.1,
' secs hist/hour = ',F15.1/);

OUTPUT61 ihstry,TIMCPU+TMCPUO;(//I15,' histories run in ',f7.1);

"Update scoring quantities with tmp's from last history"
$UPDATE_LAST_HISTORY;"This is done always, $UPDATE_BATCH_LAST_HISTORY"
                     "is done only if idat = 0"

IF(IRESTART=3)["just analyzing data--no elapsed time"
  WRITE(IOUT,250)TMCPUO,TMCPUO/3600;
  WRITE(6,250)TMCPUO,TMCPUO/3600;
  WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
  WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
]
ELSEIF(IRESTART=5)["output time results for parallel runs"
  WRITE(IOUT,255)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT);
  WRITE(6,255)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT);
  WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
  WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
]


:STATS-ANAL:;

"-----------------------------------------------------------------"
"    Adjust total number of histories in case of an early exit    "
"-----------------------------------------------------------------"
"BUG: was not removing rejected histories from counter, 31/05/2004"
"ncaset = ihstry;"
ncaset = ihstry - NCREJ;

"-----------------------------------------------------------------"
"         PROCESSING-RESULTS                                      "
"-----------------------------------------------------------------"

IF (numcavreg > 0 & IFULL = $CAVITY)["cavity calculation"

"update deposited energy in cavity with last history"
"   aux      = cavdose_tmp; aux2 = aux*aux;"
"   cavdose  = cavdose  + aux;"
"   cavdose2 = cavdose2 + aux2;"
;
"get the variance estimate for the energy deposited in the cavity"
   aux = cavdose/ncaset;             "E(x)"
   aux2 = cavdose2/ncaset;           "E(x^2)"
"estimate variance of the mean as (E(x^2)-E(x)^2)/(ncase-1)<=unbiased estimator"
   aux2 = (aux2 - aux*aux)/(ncaset-1);

   IF( aux2 > 0 ) aux2 = sqrt(aux2);

   energy2dose = 1.602E-10/cavitymass;

   cavdose  = aux  * energy2dose;"cavity dose"
   cavdose2 = aux2 * energy2dose;"uncertainty estimate of cavity dose"

]

IF (MONOEN = 1)[           "polyenergetic beam"
  anorm = ncaset/anorm;
  OUTPUT61;(//'Sampled average kinetic energy:'/,
            '-------------------------------'/);
  OUTPUT61 1/anorm;('Eave = ',f11.6,' MeV'/);
  OUTPUT61;('-------------------------------'/);
]
ELSE                       "monoenergetic beam"
   [anorm  = 1/ein;]


"process as many components as scored"

$PROCESS tot COMPONENT;
$PROCESS pri COMPONENT;
IF (IQIN = 0 )[
 $PROCESS sc1 COMPONENT;
 $PROCESS sc2 COMPONENT;
 $PROCESS msc COMPONENT;
]
$PROCESS rad COMPONENT;

IF (IQIN = 0 )[
 EDEPDUMMY = 0;
 "Total energy fraction in first sphere"
 DO i=2,nc+1[EDEPDUMMY = EDEPDUMMY + edk(i,0);]
 EDEPRELAX = 100*EDEPRELAX/(NCASET*EIN*EDEPDUMMY);
 OUTPUT61;
 ('-----------------------------------');
 OUTPUT61 Fpri+Fsc1+Fsc2+Fmsc+Frad;
 ('=> SUM OF ALL COMPONENTS ',f10.6/);
 OUTPUT61 100.*(Fpri+Fsc1+Fsc2+Fmsc+Frad)/Ftot;
 (f8.3,'% of the photons were classified !!!'/);
 OUTPUT61 100.*NCREJ/NCOMPT;
 (f8.3,'% of the Compton interactions rejected !!!'/);
 OUTPUT61 EDEPRELAX;
 (f8.3,'% of dep. energy in 1st sphere due to primary sub-threshold events'/);

 IF (IRAYLR(2) = 1)[
  write(   *,'(f8.3,A)') 100.*(1-Mcohfac),'% Rayleigh fraction RAY/TOT';
  write(iout,'(f8.3,A)') 100.*(1-Mcohfac),'% Rayleigh fraction RAY/TOT';
 ]

 OUTPUT61;
 ('-----------------------------------');
]

write(*,'(A)') '   radius/cm     angle/deg   region #';
write(*,'(A)') '------------------------------------------';
DO ix=1,3[
   DO ic =1,MIN(10,nc) [
      $GET-IRL(ic,ix);
      write(*,'(f11.5,4x,f11.5,1x,I6)') rsph(ix), alpha(ic), irl;
   ]
]


"-----------------------------------------------------------------"
"                OUTPUT  -  RESULTS                               "
"-----------------------------------------------------------------"

write(1,*)'                                                          ';
write(1,*)'**********************************************************';
write(1,*)'                                                          ';
write(1,*)'                   OUTPUT RESULTS                         ';
write(1,*)'                                                          ';
write(1,*)'**********************************************************';
write(1,*)'                                                          ';

IF (numcavreg.gt.0)["cavity calculation"
   OUTPUT61 cavdose,cavdose2,100.0*cavdose2/cavdose;
   (//'  cavity dose = ',1PE15.6,' +/- ',1PE15.6,' [ ',0PF8.4,' % ]'/);

   OUTPUT61 cavitymass;('  whole cavity mass is :',f15.4,'g' );

   IF (numcavreg.gt.1)["more than one cavity region"
    OUTPUT61;(' cavity zone       mass/g     dose[uncert.]     ');
    OUTPUT61;(' -----------------------------------------------');
    DO ic =1,nc [
     DO ix=1,nr[
       $GET-IRL(ic,ix);
       IF (iscavreg(irl).eq.1) [
          OUTPUT61 irl, amass(ic,ix), dose(irl,0),
                     100*dose2(irl,0)/dose(irl,0);
          ('     ',I3,'  ',f15.4,' ',1PE11.4,' [',0PF8.4,'%]' );
       ]
     ]
    ]
   ]
]

IF (NC > 1)[

 IF (IFULL = $DOSE | IFULL = $DOSE-EDK)[
  write(1,'(/20X,A)') 'DOSE SUMMARY';
  write(1,'(20X,A/)') '------------' ;
  write(1,'(A)')
  ' angle/deg.  radius/cm    total dose[uncert]       primary dose[uncert]';
  write(1,'(1X,71("-"))');
  DO ic =1,nc [
   DO ix=1,nr[
    $GET-IRL(ic,ix);
     DO i=0,1[
      error(i) = 0.0;
      IF (dose(irl,i)> 0.0)
       error(i) = 100.*dose2(irl,i)/dose(irl,i);
     ]
    write(1,'(f9.2,f12.4,3X,2(1PE11.4,A2,0PF8.4,A4))')
            alpha(ic),rsph(ix),
            dose(irl,0),' [',error(0),'% ] ',
            dose(irl,1),' [',error(1),'% ] ';
   ]
  ]
 ]


 IF (IFULL = $EDK | IFULL = $DOSE-EDK)[
  write(1,'(//20X,A)') 'ENERGY DEPOSITION KERNEL';
  write(1,'(20X,A/)')  '------------------------';
  write(1,'(A)')
  ' angle/deg.  radius/cm    total [uncert]           primary [uncert]';
  write(1,'(1X,72("-"))');
  DO ic =1,nc [
   DO ix=1,nr[
    $GET-IRL(ic,ix);
     DO i=0,1[
      error(i) = 0.0;
      IF (edk(irl,i)> 0.0)
       error(i) = 100.*edk2(irl,i)/edk(irl,i);
     ]
    write(1,'(f9.2,f12.4,3X,2(1PE11.4,A2,0PF8.4,A4))')
            alpha(ic),rsph(ix),
            edk(irl,0),' [',error(0),'% ] ',
            edk(irl,1),' [',error(1),'% ] ';
    "(f9.2,f12.4,'   ',2(1PE11.4,' [',0PF8.4,'% ] '));"
   ]
  ]
 ]

]
ELSEIF(NC=1)["PURE SPHERICAL GEOMETRY"
 IF (IFULL = $DOSE | IFULL = $DOSE-EDK)[
  write(1,'(/20X,A)') 'DOSE SUMMARY';
  write(1,'(20X,A/)') '------------';
  write(1,'(A)')
  ' radius/cm    total dose[uncert]       primary dose[uncert] ';
  write(1,'(A)')
  ' -----------------------------------------------------------';
  DO ic =1,nc [
   DO ix=1,nr[
    $GET-IRL(ic,ix);
     DO i=0,1[
      error(i) = 0.0;
      IF (dose(irl,i)> 0.0)
       error(i) = 100.*dose2(irl,i)/dose(irl,i);
     ]
    write(1,'(f12.6,3X,2(1PE11.4,A2,0PF8.4,A4))')
       rsph(ix),
       dose(irl,0),' [',error(0),'% ] ',
       dose(irl,1),' [',error(1),'% ]';
   ]
  ]
 ]


 IF (IFULL = $EDK | IFULL = $DOSE-EDK)[


    IF (MONOEN = 1 & IQIN ~= 0)[
      edk90 = 0;
      DO ix=1,nr[
         irl = ix + 1;
         edk90 = edk90 + edk(irl,0);
         IF (edk90 => 0.9)[     "<=== 90% of total energy emitted"
            X90 = rsph(ix);
            write(1,'(//A10,0Pf15.5,A3)') ' X(90%) = ', X90, ' cm';
            write(6,'(//A10,0Pf15.5,A3)') ' X(90%) = ', X90, ' cm';
            write(6,'(A14,0Pf15.5,A2)') ' 90% of EDK = ', 100*edk90, ' %';
            EXIT;
         ]
      ]
    ]

    write(1,'(//20X,A)') 'ENERGY DEPOSITION KERNEL';
    write(1,'(20X, A/)') '------------------------';
    write(1,'(4X, A)')
    ' radius/cm    total [uncert]           primary [uncert] ';
    write(1,'(1X,59("-"))');
    DO ic =1,nc [
    DO ix=1,nr[
     $GET-IRL(ic,ix);
     DO i=0,2[
      error(i) = 0.0;
      IF (edk(irl,i)> 0.0)
       error(i) = 100.*edk2(irl,i)/edk(irl,i);
     ]
     IF (MONOEN = 1 & IQIN ~= 0)[X90scale = X90/(rsph(ix)-rsph(ix-1));]
     ELSE                       [X90scale = 1;]
    "using r^2 = 1/3*(r1^2+r2^2+r1*r2) instead of arithmetic mean"
    "since the volume of the spherical shells are calculated with"
    "the exact expression for the volume.                        "
     write(1,'(f12.6,3X,2(1PE11.4,A2,0PF8.4,A4))')
         sqrt(1.0/3.0*(rsph(ix)**2+rsph(ix-1)**2+rsph(ix)*rsph(ix-1))),
         edk(irl,0)*X90scale,' [',error(0),'% ] ',
         edk(irl,1)*X90scale,' [',error(1),'% ]';
   ]
  ]
 ]

]

IF (EDKF = 0 )["user requests energy dep. kernels in old format"
               "name convention: edk + EIN[keV]"
/*
  IF (MONOEN = 0)[
     write(ch_var,'(f10.0)') ein*1000.;
     ini = sini(ch_var);
     fin = sfin(ch_var,len(ch_var));
     edkname = 'edk' // ch_var(ini:fin) // 'keV';
     edk_unit = egs_get_unit(20);
     OPEN(UNIT=edk_unit,file=edkname,STATUS='unknown');
     edk_unit = egs_open_file(20,0,1,'.keV');
  ]
  ELSE[edk_unit = egs_open_file(20,0,1,'.keV');]
  edk_unit = egs_open_file(20,0,1,'.keV');
*/
  edk_unit = 20;

  DO ic=1,nc[
   DO ix=1,nr[
    $GET-IRL(ic,ix);
    DO i=1,$MAXIT[
     error(i) = 100.0;
     IF (edk(irl,i)> 0.0)
      error(i) = 100.*edk2(irl,i)/edk(irl,i);
    ]
    write(edk_unit,'(3x,e13.8,4x,e13.8)') (edk(irl,i),error(i),i=1,$MAXIT);
   ]
  ]
  CLOSE(edk_unit);
]

"-----------------------------------------------------------------"
"                  PLOTTING  -  SECTION                               "
"-----------------------------------------------------------------"

IF (IOPLOT > 0)"plotting requested"
   CALL PLOT;



:END-OF-RUN:;
;"******************************************************************************
"
"                       *** SECTION 4 ***
"
"------------------------------------------------------------------------------
"
"THE CONCLUSION"
"
"------------------------------------------------------------------------------

:END:;
OUTPUT; (//'END OF RUN',9X,' ',$); call egs_fdate(6);
OUTPUT; (//);
write(iout,'(/a,$)') 'END OF RUN          '; call egs_fdate(iout);
write(iout,'(////)');

call egs_finish;

#ifdef HAVE_C_COMPILER;
;
IF( n_parallel > 0 & ~is_finished ) [
    call egs_pjob_finish(n_job);
    IF( n_job = 0 ) [
        is_finished = .true.;
        call egs_combine_runs(combine_results,'.egsdat');
        NCASET=NCASEO;  IHSTRY=NCASET;
        call isumry(iout);
        $FLUSH_UNIT(IOUT);

        IF(IQIN=0 & MONOEN=0 & (IFULL=$EDK | IFULL=$DOSE-EDK))[
          MEDIUM= MED(2);
          OUTPUT61;
          ('--------------------------------------------------------'/);
          OUTPUT61;
          ('TERMA PER FLUENCE FOR MONOENERGETIC PHOTONS ON MATERIAL ',$);
          OUTPUT61 (MEDIA(I,MEDIUM),I=1,24);(24A1);
          OUTPUT61;
          ('--------------------------------------------------------'/);
          IF (IRAYLR(2) = 1)[
            OUTPUT61 ein,terma;
('T(',0PF8.3,')/Eo/Flu= (mu/rho) = ', 1PE11.4,' cm2/g <= with Rayleigh'/);
          ]
          OUTPUT61 ein,terma*Mcohfac;
('T(',0PF8.3,')/Eo/Flu= (mu/rho) = ', 1PE11.4,' cm2/g <= no Rayleigh'/);
        ]

        write(iout,'(A)')
        '-----------------------------------------------------------------';
        write(iout,'(A)')
        '                OUTPUT  -  RESULTS                               ';
        write(iout,'(A)')
        '-----------------------------------------------------------------';

        goto :STATS-ANAL:;
    ]
]
#endif;

$CALL_EXIT(0);


"FORTRAN FORMAT STATEMENTS. FORMAT STATEMENT N## IS FIRST USED IN SECTION N."
%I0
100  FORMAT(' ',80A1//'NRCC CALCULATION USING EDKnrc(EGSnrc) '$VERSION' ',
             /' ON '$MACHINE' ',T55,' ',$);

200  FORMAT(//,79('*')/
            // ,T20,'EXECUTION INFORMATION AND WARNING MESSAGES'/
            // ,79('*')/
            //'USING EDKnrc(EGSnrc) '$VERSION' ON '$MACHINE' ');
201  FORMAT(/'********* NEW INPUT FILE *********'/);
202  FORMAT(/'********* RESTARTED INPUT FILE ********* '/
             ' ',10X,I12,' NEW + ',I12,' OLD HISTORIES');
204  FORMAT(/'********* DATA ANALYSIS ONLY *********'/);
206  FORMAT(/' ********* ANALYZING RESULTS FROM PARALLEL RUNS *******'/);
250  FORMAT(/' FOR OLD RUN:'/
             ' ----------- '/
             ' Total cputime =',F8.1,'s (=',F5.2,' hr)');
255  FORMAT(/' FOR PARALLEL RUNS:'/
             ' ----------------- '/
             ' On ',I5,' machines '/
             ' Total cputime =',F8.1,'s (=',F8.2,' hr), cputime/machine =',
              F8.1,'s');
280  FORMAT(/'    CPUtime/history=',F10.5,'  sec.  Histories/hour=',F12.0);

end;

%E     "taken from cavrznrc.mortran"
"******************************************************************************
"
"
"                               **********
"                               *        *
"                               * INPUTS *
"                               *        *
"                               **********
"
"
"       AN INPUT FILE USED WITH CAVRZnrc. THE INPUTS ARE DEFINED AS THEY ARE
"       INPUT. CONSIDERABLE DEFAULTING AND ERROR CHECKING IS DONE.
"
"       VERSION 1       AFB    10/87            ADAPTED FROM CAVITY(EGS3)
"       VERSION 2       A.M.   04/98            New input routine (get_inputs)
;
"******************************************************************************
"
SUBROUTINE INPUTS;

$IMPLICIT-NONE;

;COMIN/
    BOUNDS,EDGE,ELECIN,EPCONT,GEOM,IODAT1,IODAT2,
    MEDIA,MISC,PHOTIN,SCORE,SOURCE,SPECTR,GetInput, STACK,
    THRESH,UPHIOT,USEFUL,USER,RANDOM,ET-Control,
    EGS-VARIANCE-REDUCTION,COMPTON-DATA,PLOTC,DODOPP,PRINTC,EGS-IO/;

"***************************************************************************"
"*                         User defined MACROS                             *"
"***************************************************************************"
REPLACE {$SKIP-LINE;} WITH {;OUTPUT;(' ');}  "Line skip"
"REPLACE {$NMAX} WITH {120}"
"REPLACE {$NVALUE} WITH {120}"
REPLACE {$GET_INPUT(#);} WITH  "Used to get only one input"
{
"{P1}=Array index of the value_sought"
NMIN = {P1}; NMAX = {P1}; CALL GET_INPUT;
}
;
REPLACE {$GET_INPUTS(#,#);} WITH  "Used to get many inputs"
{
NMIN = {P1}; NMAX = {P2}; CALL GET_INPUT;
}
;
"***************************************************************************"
"*                   Variables used to declare inputs                      *"
"***************************************************************************"
INTEGER INEXT;

INTEGER ITERSE;

INTEGER IFLUOR;                                     "transport control"
INTEGER IZ, IREGLO, IREGHI;                         "transport control"
INTEGER IESTEP;                                     "transport control"
REAL SMAX;                                          "transport control"
REAL FESTEP;                                        "transport control"

"INTEGER MONOEN;"

REAL ADDING;
$INTEGER I, J, K, PLN, COUNT, SLENGHT, REGNUM;

$INTEGER irl;

$INTEGER jrng1,jrng2,ISSAME,ITMAX,IT,IX,LNBLNK1;

$INTEGER data_unit, egs_get_unit, egs_open_datfile;

"***************************************************************************"
"*                Variables used to point to the inputs                    *"
"***************************************************************************"
INTEGER NUM_TITLE,

"I/O Contol"
        NUM_IRESTART,
        NUM_STORE,
        NUM_EDKF,
"M-C Input"
        NUM_HIST,
        NUM_IFULL,
        NUM_SEEDS,
        NUM_PFLAG,
        NUM_DODOPP,
"Source inputs"
        NUM_IPART,
        NUM_SOURCE,
        NUM_KIEN,
        NUM_ZIN,
"Tranport Control"
        NUM_ECUT,
        NUM_PCUT,
        NUM_RAYLEIGH,
        NUM_IREJCT,
        NUM_HOWFAR,
        NUM_ESAVEIN,
        NUM_IDOPES,
        NUM_IFLUOR,
        NUM_FLUIZ,
        NUM_FREGSTART,
        NUM_FREGSTOP,
        NUM_RRPARAM,
        NUM_RRMINPL,
        NUM_RRMAXPL,
        NUM_RRMINRA,
        NUM_RRMAXRA,
        NUM_RUSROU,
        NUM_RUSFRAC,
        NUM_FORCE,
        NUM_STRTFRC,
        NUM_STPFRC,
        NUM_XTRANSF,
        NUM_NESTEP,
        NUM_NSMAX,
        NUM_ADJEREG,
        NUM_FRAKESTEP,
        num_compton,i_bound_compton,
        num_spin,i_spin,
"Plot Control"
        NUM_IOPLOT,
        NUM_IPLTLP,
        NUM_IPLTPL,
        NUM_IPLPHB,
        NUM_IPLTRAD,
        NUM_IPLTC;



"---------------------------------------------------------------------------"
IVAL=0;  "number of the value_sought"

ERROR_FLAG=0;   "Initialization of bad input flag"
DO J=1, $NMAX [NVALUE(J)=0;]  "Initialization of Nvalue Array"

OUTPUT61 $MAXRADII,$MAXCDOSE;
(//' EDKnrc '$VERSION' ON '$MACHINE' WITH EGSnrcMP.'/
T20,'MAXIMUM NUMBER OF RADIAL AND DEPTH ZONES=',2I4);

"*********************************************************"
"* set up the values_sought(i) and echo inputs to screen *"
"*********************************************************"
                     "*********"
                     "* TITLE *"
                     "*********"
IVAL=IVAL+1;
NUM_TITLE=IVAL;
VALUES_SOUGHT(IVAL)='TITLE';
TYPE(IVAL)=2;
NVALUE(IVAL)=1;

DELIMETER='NONE';
$GET_INPUT(NUM_TITLE);

$SKIP-LINE;$SKIP-LINE;
OUTPUT;(' *** INPUT CARD I01 ***');
READ (CHAR_VALUE(NUM_TITLE,1),FMT='(80A1)') (TITLE(I),I=1,80);
WRITE (*,:FMT:) (TITLE(I),I=1,79);
:FMT: FORMAT ('TITLE: ',79A1);
$SKIP-LINE;

"************************"
"* INPUT/OUTPUT CONTROL *"
"************************"
DELIMETER='I/O CONTROL';

IVAL=IVAL+1;
NUM_IRESTART =IVAL;
VALUES_SOUGHT(IVAL)='IRESTART';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='FIRST';
ALLOWED_INPUTS(IVAL,1)='RESTART';
ALLOWED_INPUTS(IVAL,3)='ANALYZE';
ALLOWED_INPUTS(IVAL,5)='PARALLEL';

IVAL=IVAL+1;
NUM_STORE=IVAL;
VALUES_SOUGHT(IVAL)='STORE DATA ARRAYS';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='YES';
ALLOWED_INPUTS(IVAL,1)='NO';

IVAL=IVAL+1;
NUM_EDKF=IVAL;
VALUES_SOUGHT(IVAL)='PRINT OUT EDK FILE';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='YES';
ALLOWED_INPUTS(IVAL,1)='NO';

"********************************"
$GET_INPUTS(NUM_IRESTART,NUM_EDKF);
"********************************"
IRESTART =VALUE(NUM_IRESTART ,1);
IDAT=VALUE(NUM_STORE,1);
EDKF=VALUE(NUM_EDKF,1);
OUTPUT IRESTART,IDAT;
  ( /
' FIRST RUN(0),RESTARTED(1),ANALYZE(3),parallel(5):',
    T72,I4/
' STORE DATA(0) OR NOT(1):',T72,I4/);
IF (EDKF = 0)[
   OUTPUT;('==> Energy deposition kernels stored in old format');
]

"                       MONTE CARLO CONTROL INPUT
"                       *************************
IVAL=IVAL+1;
NUM_HIST=IVAL;
VALUES_SOUGHT(IVAL)='NUMBER OF HISTORIES';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=100;
VALUE_MAX(IVAL)=999999999;
DEFAULT(IVAL)=20000;

IVAL=IVAL+1;
NUM_IFULL=IVAL;
VALUES_SOUGHT(IVAL)='IFULL';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,$CAVITY)='CAVITY CALCULATION';
ALLOWED_INPUTS(IVAL,$EDK)='ENERGY DEPOSITION KERNEL';
ALLOWED_INPUTS(IVAL,$DOSE)='DOSE CALCULATION';
ALLOWED_INPUTS(IVAL,$DOSE-EDK)='DOSE AND EDK';
"DEFAULT(IVAL)=$DOSE-EDK;  <=== type 3 inputs have 0 as default"

IVAL=IVAL+1;
NUM_DODOPP=IVAL;
VALUES_SOUGHT(IVAL)='DOPPLER BROADENING';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='ON';
ALLOWED_INPUTS(IVAL,1)='OFF';


DELIMETER='MONTE CARLO INPUTS';
$GET_INPUTS(NUM_HIST,NUM_DODOPP);

"************"
"* CARD MC1 *"
"************"
OUTPUT;(/,' *** INPUT CARD MC1 ***');
NCASE=VALUE(NUM_HIST,1);
IFULL=VALUE(NUM_IFULL,1);
idopp=VALUE(NUM_DODOPP,1);

"Random number initializations"
IF( i_parallel > 0 ) jrng2 = jrng2 - 1 + i_parallel;
$RNG-INPUTS('INITIAL RANDOM NO. SEEDS','MONTE CARLO INPUTS',jrng1,jrng2);
$INITIALIZE RNG USING jrng1 AND jrng2;

OUTPUT NCASE,jrng1,jrng2,IFULL;
    (/' # OF HISTORIES:',T60,I12/
     $RNG-STRING-1,T60,I12/,$RNG-STRING-2,T60,I12/,
    ' SCORING OPTION IFULL (0,1,2,3):',T60,I12);
OUTPUT ALLOWED_INPUTS(NUM_IFULL,IFULL);
(/'CALCULATION TYPE :',T60,A32);

"                SPHERICAL GEOMETRY AND MATERIAL INPUT
"                ***************************************
CALL GEOMSPH;

"Weights for regions around origin according to their solid angle"
DO I=1,NC[COSWT(I) = 0.5*( COSALP(I-1)-COSALP(I) );]

IF (ERROR_FLAG=1) [
   WRITE(15,*) '***********ERROR IN SUBROUTINE GEOMSPH************';
   GOTO :FINISHED:;
]

"SET THE GEOMETRY FLAG FOR THE CAVITY"
DO J=1,NREG [iscavreg(J)=0;]  "ASSUME IT IS NON-CAVITY EVERYWHERE"
"SET THE CAVITY FLAG FOR THE CAVITY REGIONS"
IF (numcavreg > 0)[
    DO J=1, numcavreg [
       iscavreg(cavreg(J))=1;
       write(6,*) j, ' cavity region is ', cavreg(j);
    ]
]

"                SOURCE INPUT
"                ************

DELIMETER='SOURCE INPUTS';
IVAL = IVAL + 1;
"IVAL is passed in IODAT2"
NUM_IPART = IVAL;
VALUES_SOUGHT(IVAL)='INCIDENT PARTICLE';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
DEFAULT(IVAL)=0;
ALLOWED_INPUTS(IVAL,3)='ELECTRON';
ALLOWED_INPUTS(IVAL,0)='PHOTON';
ALLOWED_INPUTS(IVAL,1)='POSITRON';
ALLOWED_INPUTS(IVAL,2)='ALL';

IVAL = IVAL + 1;
NUM_SOURCE = IVAL;
VALUES_SOUGHT(IVAL)='SOURCE NUMBER';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=2;
DEFAULT(IVAL)=0;
"$GET_INPUT(NUM_SOURCE);"
"ISOURC=VALUE(NUM_SOURCE,1);"
"OUTPUT ISOURC;('SOURCE NUMBER = ', I3);"


OUTPUT;(' About to read source inputs...', I3);

$GET_INPUTS(NUM_IPART, NUM_SOURCE);


ISOURC=VALUE(NUM_SOURCE,1);
OUTPUT ISOURC;('SOURCE NUMBER = ', I3);

iqin=VALUE(NUM_IPART,1);
"this is done because VALUE(I,IVAL) cannot have negative array indices"
IF (iqin=3) [iqin=-1;]

"ein=VALUE(NUM_KIEN,1);"

IF     ( ISOURC = 0 )["point source at origin emission along z-axis"

  /uin, vin, win/ = 0; win = 1.0; "particle incident parallel to z-axis"
  /xin, yin, zin/ = 0.0; "zin = 1e-06;"
  irin = 2;
  wtin = 1.;
  OUTPUT;('point source at origin, emission along z-axis'/);

]
ELSEIF ( ISOURC = 1 )["isotropically radiating point source at origin"

  /xin, yin, zin/ = 0.0; "zin = 0.001; "
  irin = 2;
  wtin = 1.;
  OUTPUT;('isotropically radiating point source at origin'/);
]
ELSEIF ( ISOURC = 2 )["point source shifted in positive z-direction"
  /uin, vin, win/ = 0; win = 1.0; "particle incident parallel to z-axis"
  /xin, yin, zin/ = 0.0; zin = 1e-06;
  irin = 2;
  wtin = 1.;

  IVAL = IVAL +1;
  NUM_ZIN = IVAL;
  VALUES_SOUGHT(IVAL)='ZIN';
  TYPE(IVAL)=1;
  NVALUE(IVAL)=1;
  VALUE_MIN(IVAL)=  0.0;
  VALUE_MAX(IVAL)=  1.e20;
  DEFAULT(IVAL)=1.e-6;

  $GET_INPUT(NUM_ZIN);

  zin = VALUE(NUM_ZIN,1);

  OUTPUT zin;
  ('point source near origin (zin=',e20.5,') emission along z-axis'/);


]
ELSE[

  OUTPUT;(/'*********************************************'/
            '* CURRENTLY ONLY SOURCE 0,1 AND 2 AVAILABLE *'/
            '* ABORTING EXECUTION.                       *'/
            '*********************************************');
  RETURN;
]

"************"
"* CARD TC1 *"
"************"
"EXECUTED FROM SUBROUTINE ENSRC(ERROR_FLAG)"
CALL ENSRC; "Get data re-source energies"
IF (ERROR_FLAG=1) [
   WRITE(15,*) '***********ERROR IN SUBROUTINE ENSRC************';
   GOTO :FINISHED:;
]

IF (MONOEN = 0)[
  OUTPUT iqin;(' INCIDENT PARTICLE CHARGE: ',T60,I3);
]
ELSE[
  OUTPUT iqin,ein;(/' INCIDENT PARTICLE CHARGE: ',T60,I3/
                    ' MAXIMUM KINETIC ENERGY OF THE SPECTRUM: ',T60,F10.4);
]

IQINC = iqin; "To be used in AUSGAB for identifying the initial shower particle"


"                       TRANSPORT CONTROL INPUT
"************           ***********************
"* CARD TC1 *"
"************"

$SKIP-LINE;

CALL get_transport_parameter(6); " This will scan the input file for
                                 " transport parameter input and then
                                 " output all settings to unit 6



ECUTIN=ecut(1);
PCUTIN=pcut(1);
SMAX=smaxir(1);

"*************************************************************************"
"                variance reduction section                               "
"*************************************************************************"

IVAL=IVAL+1;
NUM_IREJCT=IVAL;
VALUES_SOUGHT(IVAL)='ELECTRON RANGE REJECTION';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';

IVAL=IVAL+1;
NUM_ESAVEIN=IVAL;
VALUES_SOUGHT(IVAL)='ESAVEIN';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=0.0;
VALUE_MAX(IVAL)=1.e30;
DEFAULT(IVAL)=0.0;

DELIMETER='VARIANCE REDUCTION';
$GET_INPUTS(NUM_IREJCT,NUM_ESAVEIN);


"************"
"* CARD TC2 *"
"************"
OUTPUT;(' *** INPUT CARD TC2 ***');
IREJCT=VALUE(NUM_IREJCT,1);
ESAVEIN=VALUE(NUM_ESAVEIN,1);

OUTPUT IREJCT; ( / ' Range rejection is On(1) or Off(0):',T60,I12);
IF(IREJCT > 0) [
    OUTPUT ESAVEIN;
    (' ESAVEIN cutoff value(total) for range rejection:', T60,F10.4,' MeV'/);
    IF (ESAVEIN = 0.0 ) [
        OUTPUT;(/'**********************************************************'/
                 '   Have asked for range rejection but left ESAVEIN=0.0    '/
                 '        There will be no range rejection'/
                 '**********************************************************'/);
    ]
    DO i=1,NREG [i_do_rr(i) = 1; e_max_rr(i) = ESAVEIN;]
   "note  e_max_r is total energy"
   "above two arrays needed for each region for EGSnrc RANGE-DISCARD macro"
]

$SKIP-LINE;

IVAL=IVAL+1;
NUM_FORCE=IVAL;
VALUES_SOUGHT(IVAL)='PHOTON FORCING';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
DEFAULT(IVAL)=0;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';

IVAL=IVAL+1;
NUM_STRTFRC=IVAL;
VALUES_SOUGHT(IVAL)='START FORCING';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=NREG;
DEFAULT(IVAL)=1;

IVAL=IVAL+1;
NUM_STPFRC=IVAL;
VALUES_SOUGHT(IVAL)='STOP FORCING AFTER';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(NUM_STPFRC)=0;
VALUE_MAX(NUM_STPFRC)=NREG+1;
DEFAULT(NUM_STPFRC)=1;

"********************************************************************"
DELIMETER='VARIANCE REDUCTION';
$GET_INPUTS(NUM_FORCE,NUM_STPFRC);
"********************************************************************"

"************"
"* CARD TC3 *"
"************"
OUTPUT;(' *** INPUT CARD TC3 ***');
IFORCE=VALUE(NUM_FORCE,1);
NFMIN=VALUE(NUM_STRTFRC,1);
NFMAX=VALUE(NUM_STPFRC,1);
IF(IFORCE.EQ.0) [
    NFMIN=0;NFMAX=0;
    OUTPUT;(/' NO INTERACTION FORCING IS IN EFFECT'/);
]
ELSE [
    IF (NFMAX.LT.NFMIN) NFMAX=NFMIN;
    OUTPUT NFMIN,NFMAX;
    (/' FORCED PHOTON INTERACTIONS IN EFFECT FROM',I3,' TO',I3,
    ' # INTERACTIONS'/);
]

IVAL=IVAL+1;
NUM_XTRANSF=IVAL;
VALUES_SOUGHT(IVAL)='EXPONENTIAL TRANSFORM C';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=-1.e10;
VALUE_MAX(IVAL)=1.e10;
DEFAULT(IVAL)=0.0;

"********************************************************************"
DELIMETER='VARIANCE REDUCTION';
$GET_INPUT(NUM_XTRANSF);
"********************************************************************"

"*************"
"* CARD TC2C *"
"*************"
OUTPUT;(' *** INPUT CARD TC2C ***');
CEXPTR=VALUE(NUM_XTRANSF,1);

IF (CEXPTR.EQ.0) [OUTPUT;(' NO PATHLENGTH BIASING TO BE DONE');]
ELSE [OUTPUT CEXPTR;(' CEXPTR PARAMATER:',T30,E14.7);]


$SKIP-LINE;

"*************************************************************************"
"                     plot control section                                "
"*************************************************************************"

DELIMETER='PLOT CONTROL';

IVAL=0;
IVAL=IVAL+1;
NUM_IOPLOT=IVAL;
VALUES_SOUGHT(IVAL)='PLOTTING';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='HISTOGRAM';
ALLOWED_INPUTS(IVAL,2)='POINT';
$GET_INPUT(NUM_IOPLOT);
IOPLOT=VALUE(NUM_IOPLOT,1);

OUTPUT;(/' *** INPUT for plotting ***');
IF (IOPLOT.EQ.0) [OUTPUT;(/'NO PLOTTING REQUESTED');]
ELSE [
   IF (IOPLOT.EQ.1)[
    OUTPUT;(/'HISTOGRAM PLOTTING WILL BE DONE');
   ]
   ELSE IF (IOPLOT.EQ.2)[
    OUTPUT;(/'POINT GRAPH PLOTTING WILL BE DONE');
   ]

   OUTPUT;(/' *** INPUT which plots to do ***');

   IVAL=IVAL+1;
   NUM_IPLTRAD=IVAL;
   VALUES_SOUGHT(IVAL)='PLOT RADIAL REGION IX';
   TYPE(IVAL)=0;
   VALUE_MIN(IVAL)=0;
   VALUE_MAX(IVAL)=NR;
   DEFAULT(IVAL)=0;
   "DEFAULT(IVAL)=NR;"
   NVALUE(IVAL)=0;

   $GET_INPUT(NUM_IPLTRAD);
   NPLOTR=NVALUE(NUM_IPLTRAD);
   IF (VALUE(NUM_IPLTRAD,1) > 0) [
      DO J=1, NPLOTR [
         IPLOTR(J)=VALUE(NUM_IPLTRAD,J);
         OUTPUT IPLOTR(J);('PLOTTING RADIAL ZONE ', I3);
      ]
      $SKIP-LINE;
   ]
   ELSE [NPLOTR=0;]

   IVAL=IVAL+1;
   NUM_IPLTC=IVAL;
   VALUES_SOUGHT(IVAL)='PLOT CONICAL REGION IC';
   TYPE(IVAL)=0;
   VALUE_MIN(IVAL)=0;
   VALUE_MAX(IVAL)=NC;
   DEFAULT(IVAL)=0;
   "DEFAULT(IVAL)=NC;"
   NVALUE(IVAL)=0;

   $GET_INPUT(NUM_IPLTC);
   NPLOTZ=NVALUE(NUM_IPLTC);
   IF (VALUE(NUM_IPLTC,1) > 0) [
      DO J=1, NPLOTZ [
         IPLOTZ(J)=VALUE(NUM_IPLTC,J);
         OUTPUT IPLOTZ(J);('PLOTTING CONICAL ZONE ', I3);
      ]
      $SKIP-LINE;
   ]
   ELSE [NPLOTZ=0;]
]


"---------------------------------------------------------------------"
"STEP 5  INITIALIZATION-FOR-AUSGAB                                    "
"---------------------------------------------------------------------"

NCASEO=0;NCASET=0;TMCPUO=0; "SET PREVIOUS RUN COUNTERS"
"Set all scoring arrays to zero."
DO j=1,$MXREG[
   DO i=1,$MAXIT [
    /
     dose(j,i),dose2(j,i), "total dose"
     dose_tmp(j,i)         "temp arrays for total and primary components"
    / = 0;
   ]
   sc_last(j) = 0;            "pointer to last history"
]
cavdose = 0.0; cavdose2 = 0.0; cavdose_tmp = 0.0;

IF(IRESTART > 0 & IRESTART < 5)[ "Analize or restart run"
 $READ_OLD_DATA;
]

IF(IRESTART = 3)[NCASE=0;]

NCASET=NCASE+NCASEO;

:FINISHED: CONTINUE;
"************************"
"* Check for any errors *"
"************************"
IF(ERROR_FLAG =  0) [
   OUTPUT;(/' ********* SUCCESSFUL INPUT ACCOMPLISHED *********');
   WRITE (15,*) ' ';
   WRITE (15,*) ' ';
   WRITE (15,*) ' *************************************************';
   WRITE (15,*) ' ********* SUCCESSFUL INPUT ACCOMPLISHED *********';
   WRITE (15,*) ' *************************************************';
   WRITE (15,*) ' ';
   WRITE (15,*) ' ';
   DO J=1,5[$SKIP-LINE;]
   RETURN; "normal return"
]

IF (ERROR_FLAG = 1) [
   WRITE(15,*) ' ';
   WRITE(15,*) ' ';
   WRITE(15,*) '************************************************';
   WRITE(15,*) '********UNSUCCESSFUL INPUTS ACCOMPLISHED********';
   WRITE(15,*) '************************************************';
   WRITE(15,*) ' ';
   WRITE(15,*) ' ';
   OUTPUT;(/' EDKnrc input file is not correct! - look for error message');
   RETURN; "error return"
]
"Bad data file, stop and print message"
:EOFA:;OUTPUT;(/' End of  file before all of egsdat file read in');

ERROR_FLAG=1;



RETURN; "END OF DAT FILE RETURN"

END; "END OF SUBROUTINE INPUTS

subroutine isumry(ounit);
$IMPLICIT-NONE;
$INTEGER ounit, I, J, K;
;COMIN/
    BOUNDS,EDGE,ELECIN,EPCONT,GEOM,IODAT1,IODAT2,
    MEDIA,MISC,PHOTIN,SCORE,SOURCE,SPECTR,GetInput, STACK,
    THRESH,UPHIOT,USEFUL,USER,RANDOM,ET-Control,
    EGS-VARIANCE-REDUCTION,COMPTON-DATA,DODOPP/;

"WRITE THE HEADER"
write(ounit,110) title;
call egs_fdate(ounit);
110  FORMAT(' ',80A1,/1X,79('*')/ ' *',T80, '*'/
  ' *',T80, '*'/
  ' *',T34,'************',T80,'*'/
  ' *',T34,'*          *',T80,'*'/
  ' *',T34,'*  EDKnrc  *',T80,'*'/
  ' *',T34,'*          *',T80,'*'/
  ' *',T34,'************',T80,'*'/
  ' *',T80, '*'/
  ' *   Spherical-geometry EGSnrc user-code for scoring EDK and dose',
   T80,'*'/
  ' *',T80, '*'/
  ' *    EDKnrc was developed by the National Research Council of Canada ',
                                                                      T80,'*'/
  ' *',T80, '*'/
  ' *    It uses the EGSnrc Monte Carlo System developed at NRC ',T80,'*'/
  ' *    (based on the EGS4 Code System developed by SLAC and NRC)',
                                                                       T80,'*'/
  ' *             running on '$MACHINE' ',T80,'*'/
  ' *',T80, '*'/
  ' *',  T53,' ',$);
write(ounit,111);
111 FORMAT('  *'/1X,79('*'));

"MONTE CARLO, TRANSPORT, AND SCATTER CONTROLS"

"Print info about transport parameter settings"
call show_transport_parameter(ounit);
$FLUSH_UNIT(ounit);

write(ounit,*);
IF (idopp > 0)[
 write(ounit,*) ' ==> Neglecting Doppler Broadening per user request';
]
ELSE[
 write(ounit,*) ' ==> Doppler Broadening considered as implemented in EGSnrc';
]
write(ounit,*);

WRITE(ounit,200) NCASE,NCASET;
IF(IQIN = 0 ) WRITE(ounit,'(T20,''Incident Charge'',T65,''photons''/)');
IF(IQIN = -1) WRITE(ounit,'(T20,''Incident Charge'',T65,''electrons''/)');
IF(IQIN = 1 ) WRITE(ounit,'(T20,''Incident Charge'',T65,''positrons''/)');
IF(IQIN = 2 ) WRITE(ounit,'(T20,''Incident Charge'',T65,''all''/)');
IF(IQIN = 3 ) WRITE(ounit,'(T20,''Incident Charge'',T65,''e- & e+''/)');

IF (MONOEN = 0)[
  write(ounit,'(a,T60,F10.4,a)')
  ' KINETIC ENERGY OF THE INCIDENT BEAM: ',ein,' MeV';
]
ELSE[
  write(ounit,'(a,T60,F10.4,a)')
  ' MAXIMUM SPECTRUM KINETIC ENERGY: ',ein,' MeV';
]

"Now we check to see if ECUT(i) is the same for all regions"
"If so, we print the value"
"Note that this is a fudge for the RZ codes so that even if we "
"SET ECUT(1) = 0.0 to avoid warning messages, there is still a fixed ECUT"
DO I=2,NREG [
   IF( (ECUT(I) ~= ECUT(2)) |(PCUT(I) ~= PCUT(2)) ) [

      write(ounit,'(A,F15.3,A,I4,A,F15.3)')
      'ECUT(2)=',ECUT(2),'     ECUT(',I,')=',ECUT(I);
      write(ounit,'(A,F15.3,A,I4,A,F15.3)')
      'PCUT(2)=',PCUT(2),'     PCUT(',I,')=',PCUT(I);

     "we failed at least one test, so this means there really are"
     "varying ECUTs and these will be printed in the grid if we want them"
     "print the first 12 ECUT & PCUT just to be sure"
     j = MIN(12,NREG);
     WRITE(ounit,'( ''First ECUTs:''/(6(F12.3)))') (ECUT(K),K=2,j);
     WRITE(ounit,'( ''First PCUTs:''/(6(F12.3)))') (PCUT(K),K=2,j);
     GO TO :past:
   ]
]
"if we get here, they were all the same"
WRITE(ounit,220) ECUT(2),PCUT(2);
:past:



"MATERIAL INPUT SUMMARY"
"====================="

WRITE(ounit,300) NMED;
DO I=1,NMED[
    WRITE(ounit,310) I,(MEDIA(J,I),J=1,6),RHO(I),AE(I),AP(I),UE(I),UP(I);
]
WRITE(ounit,*) ;

$FLUSH_UNIT(ounit);



RETURN;
%I0
"FORMATS"
200    FORMAT(80('=')/
             /,T20,'MONTE CARLO, TRANSPORT, AND SCATTER CONTROLS'/
             /80('=')/
             //T20,'max # of histories to RUN',T58,I12/
             ' ',T20,'Max # of histories to ANALYZE',T58,I12/);
220    FORMAT(' ',T20,'GLOBAL ELECTRON TRANSPORT CUT-OFF',
                     T61,0PF9.3,' (MeV)'/
             ' ',T20,'GLOBAL PHOTON TRANSPORT CUT-OFF',
                     T61,F9.3,' (MeV)'/);
300    FORMAT(80('=')/
             // ,T20,'MATERIAL SUMMARY   ',I1,' MATERIALS USED'/
             //80('=')/
             //'# MATERIAL  DENSITY(g/cm**3)',6X,'AE(MeV)',4X,'AP(MeV)',
                 9X,'UE(MeV)',4X,'UP(MeV)'/
             ' - --------  ----------------',6X,'-------',4X,'-------',
                 9X,'-------',4X,'-------');

310    FORMAT(' ',I1,3X,6A1,4X,1PE10.3,2(7X,0PF9.3,2X,F9.3));

END;

%C80
%Q1
%I4
%E     "edknrc.mortran"


" taken from tutor6nrc.mortran"
"************************************************************"
"                                                           *"
"                                                           *"
"                               **********                  *"
"                               *        *                  *"
"                               * AUSGAB *                  *"
"                               *        *                  *"
"                               **********                  *"
"                                                           *"
subroutine ausgab( iarg );"                                 *"
"                                                           *"
"************************************************************"
$IMPLICIT-NONE;
$INTEGER iarg,irl,i,ic,
         ip,latchl,
         IDUMMY;
$REAL    FDUMMY;

COMMON/GMFPDATA/GMFPR0;
$REAL    GMFPR0;

real*8   aux,
         edepc,
         ftmp;

$REAL teta0, teta;
save teta0;

;COMIN/SCORE,   "to get the scoring arrays and iscore"
       EPCONT,  "to get EDEP"
       STACK,   "to get the region number"
       GEOM,
       SOURCE,
       USER,    "to get GMFPR0 from photon routine"
       UPHIOT,
       DODOPP
      /;

"Check if particle is leaving the transport geometry
irl = ir(np);  "local region number
IF(irl = 1) return; "outside the geometry, CHECK IF BEFORE PUTTING THIS"
                                  "YOU WERE GETTING THE SEG FAULT ERROR"
                                  "ERNST"
/*
IF (idopp > 0 )[
    IF      ( iarg = 17)["Compton interaction about to occur"
     teta0 = acos(W(NP));
   ]
   ELSE IF (iarg = 18) ["Compton interaction ocurred"
     teta  = acos(W(NP));
     IF (icase < 10)[
       write(6,'(A,F10.4,A)')
       'Polar scatering angle from UPHIOT = ', acos(COSTHE),' rad';
       write(6,'(A,F10.4,A)')
       'Change in Z direction cosine = ', teta - teta0,' rad';
       write(6,'(A,I3)') 'IQ(NP)  =', IQ(NP);
       write(6,'(A,I3)') 'IQ(NP-1)=', IQ(NP-1);
     ]
   ]

]
*/

"======================================"
"Check whether energy will be deposited locally by the primary photon due to "
"relaxation events and since at origin, distribute it uniformly among the re-"
"gions surrounding the origin."
"========================================="
"ONLY for ISOURC = 0, i.e., for photon EDK"
"added check for ISOURC=0 on June 6th,2007"
"========================================="
IF((iarg = 4) & (edep ~= 0) & (latch(np) = 0) &
   (IFULL=$EDK|IFULL=$DOSE-EDK) & (ISOURC= 0) )
[
    "check that primary is actually at origin"
    IF ( (x(np)**2+y(np)**2+z(np)**2 > 0.0 ) )[
     write(*,'(A,I3)') 'Primary outside origin, IQ = ',iq(np);
    ]
    EDEPRELAX = EDEPRELAX + edep;

    IF(MONOEN = 1 & IQINC = 0) "Photon spectrum, score Terma rather that energy"
          [ftmp=edep*wt(np)/GMFPR0;]
    ELSE  [ftmp=edep*wt(np);]

    DO irl = 2,nc+1 [
      ic = irl-1;
      edepc = COSWT(ic)*ftmp;
      IF( icase = sc_last(irl) ) [ "still the same shower that deposited energy"
                                   "last time in this region"
        dose_tmp(irl,0) = dose_tmp(irl,0) + edepc;"total dep. energy"
        dose_tmp(irl,1) = dose_tmp(irl,1) + edepc;"primary energy deposition"
      ]
      ELSE[
        DO i=0,1["update all scoring categories"
          aux         = dose_tmp(irl,i);
          dose(irl,i) = dose(irl,i) + aux;     "score dep. ener"
          dose2(irl,i)= dose2(irl,i)+ aux*aux;"score energy squared"
        ]
        dose_tmp(irl,0) = edepc;"any scoring category included in total"
        dose_tmp(irl,1) = edepc;"update primary scoring categ"
        sc_last(irl) = icase;
      ]
    ]
    return;
]

"Do some basic checks to see if scoring is needed
IF( (iarg < 5) & (edep ~= 0) ) ["energy is being deposited"

    IF(MONOEN = 1 & IQINC = 0) "Photon spectrum, score Terma rather that energy"
          [ftmp=edep*wt(np)/GMFPR0;]
    ELSE  [ftmp=edep*wt(np);]

    latchl = latch(np);" 0 for primaries, 1 for scattered photons"

    IF( icase = sc_last(irl) ) [ "still the same shower that deposited energy"
                                   "last time in this region"
        dose_tmp(irl,0) = dose_tmp(irl,0) + ftmp;"total dep. energy"

        IF (iscavreg(irl) = 1)["cavity region"
           cavdose_tmp = cavdose_tmp + ftmp;
        ]

        dose_tmp(irl,latchl+1) = dose_tmp(irl,latchl+1) + ftmp;
    ]
    ELSE [ "we have the next shower depositing energy into region irl"
           "or the particle just crossed a boundary, so :"
           " => put tmp arrays into the scoring arrays, reset them"
           "    and set sc_last"
        "----------------------------------------------------------"
        " update scoring arrays with the content of the tmp arrays "
        "----------------------------------------------------------"
        IF (iscavreg(irl) = 1)["cavity region"
           aux      = cavdose_tmp;
           cavdose  = cavdose + aux;
           cavdose2 = cavdose2 + aux*aux;
           cavdose_tmp = ftmp;
        ]

        DO i=0,$MAXIT["update all scoring categories"
          aux = dose_tmp(irl,i);
          dose(irl,i) = dose(irl,i)+aux;     "score dep. ener"
          dose2(irl,i)= dose2(irl,i)+aux*aux;"score energy squared"
        ]

        "----------------------------------------------------------"
        "reset scoring arrays "
        "we ain't going here after starting the last history NCASE"
        "that's why we need to keep these tmp arrays :-("
        dose_tmp(irl,0) = ftmp;"any scoring category included in total"
        DO i=1,$MAXIT[dose_tmp(irl,i) = 0.0;]
        dose_tmp(irl,latchl+1) = ftmp;"update scoring categ"

       "---------------------------------------"
       "update sc_last at start of each history"
       "---------------------------------------"
        sc_last(irl) = icase;
    ]
]
ELSE["set flag for secondary interactions"

    IF( iarg = 7 ) [  "brem has occured"

        IF( iq(np) = 0 ) [ $EXCHANGE-STACK(NP,NP-1); ]
        latch(np-1) = itrad; " Flag the photon as a secondary"

    ]
    ELSE IF( iarg = 18 ) [ "Compton has occured, with binding effects"
                           "taken into account, 0, 1, or more particles"
                           "may have resulted"

      IF (latch(NPold) = 0)[NCOMPT=NCOMPT+1;]"primary Compton interaction"
                                             "count it"

      IF (NP > NPold)[                      "Compton interaction accepted"
             DO ip=NPold,NP [               "flag photon as secondary"
                IF( iq(ip) = 0 & latch(ip) < itrad-1)[
                  latch(ip) = latch(ip)+1;
                ]
             ]
      ]
      ELSE IF (latch(NP) = 0)[       "primary Compton interaction rejected"
              E(NP) = 0.0; WT(NP) = 0.0;
              NCREJ = NCREJ + 1;
      ]

    ]
    ELSE IF( iarg = 13 | iarg = 14 ) ["Annihilation, flag the photons"
            latch(np)   = itrad;
            latch(np-1) = itrad;
    ]
    ELSE IF (iarg = 20) ["Photoeffect has occurred, flag the photons"
             DO ip=NPold,NP [
               IF(iq(ip) = 0 & latch(ip) < itrad-1)[
                 latch(ip) = latch(ip)+1;
               ]
             ]
    ]
    ELSE IF( iarg = 24 ) ["Rayleigh scattering"
        IF (latch(np) < itrad-1) [ latch(np) = latch(np)+1; ]
    ]
]

return;
end;

%Q1
%C80
%I2
%E     "taken from cavsphnrc.mortran"
;"******************************************************************************
"
"                               **********
"                               *        *
"                               * HOWFAR *
"                               *        *
"                               **********
"
"       A GENERAL PURPOSE SPHERICAL GEOMETRY ROUTINE FOR USE WITH THE EGS3
"       CODE SYSTEM ADAPTED FOR USE WITH CAVSPHnrc.
"
"       FOR PARTICLE NP ON THE STACK IN REGION IR(NP), THIS ROUTINE
"       DETERMINES IF THE PARTICLE CAN GO A DISTANCE USTEP WITHOUT CHANGING
"       ZONES. IF USTEP CAUSES A ZONE CROSSING, IT IS REDUCED TO PLACE IT ON
"       THE BOUNDRY AND IRNEW IS SET TO THE ZONE NUMBER ON THE FAR SIDE OF
"       THE BOUNDARY. IF IR(NP) IS 1 THEN THE PARTICLE HAS ESCAPED THE REGION
"       OF INTEREST AND THE HISTORY IS TERMINATED.(IDISC IS SET TO 1.)
"
"
"
"
"       SOME VARIABLES
"       ==============
;"
"OUTEND =       .TRUE.  =>      PARTICLE MAY TRANSMIT OR BACKSCATTER OUT ENDS
"       =       .FALSE. =>      PARTICLE STAYS WITHIN THE END BOUNDARIES
"OUTSID =       .TRUE.  =>      PARTICLE MAY TRANSMIT OUT THE SIDES
"       =       .FALSE. =>      PARTICLE STAYS WITHIN THE SIDE BOUNDARY
"IRL    =       STARTING REGION NUMBER THE PARTICLE IS IN
"IC     =       STARTING CONICAL ZONE NUMBER THE PARTICLE IS IN.
"               THE PARTICLE IS BETWEEN ALPHA(IC) AND ALPHA(IC+1).
"IX     =       STARTING SPHERICAL ZONE NUMBER THE PARTICLE IS IN.
"               THE PARTICLE IS BETWEEN RSPH(IX-1) AND RSPH(IX).
"
"       COMMON/GEOM/
"               ALPHA(IC)       Z VALUES OF CONES
"                               1<=IC<=NC+1
"               RSPH(IRR)       RADII OF SPHERES
"                               1<=IRR<=NR
"               RSPH2(IRR)      =RSPH(IRR)**2
"               NC              # CONICAL GEOMETRICAL ZONES (NCONE+1)
"                               ZONE(I) IS BETWEEN ALPHA(I) AND ALPHA(I+1)
"               NR              # SPHERICAL GEOMETRICAL ZONES
"                               ZONE(I) IS BETWEEN RSPH(I-1) AND RSPH(I)
"               NREG            TOTAL # GEOMETRICAL ZONES =NR*NC +1
"                                       +1 FOR VACUUM ENVELOPE
%E     "cavsphnrc.mortran"
"       DEFINITIONS OF REGION NUMBER, CONICAL ZONE, SPHERICAL ZONE
"       ===========================================================
"               Z AXIS RUNS ACROSS PAGE SHOWN AS .......
"
"
"                                       1
"
"
"       --------------------------------------------------------- RSPH(NR)
"       |(NR-1) |(NR-1) |(NR-1) |    . . . .    | NR*NC | NR*NC |    IX=NR
"       | *NC+2 | *NC+3 | *NC+4 |               |       |   +1  |
"       --------------------------------------------------------- RSPH(NR-1)
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       --------------------------------------------------------- RSPH(2)
"       |  NC+2 |  NC+3 |  NC+4 |    . . . .    |  2NC  | 2NC+1 |    IX=2
"       --------------------------------------------------------- RSPH(1)
"..1....|...2...|...3...|...4...|...............|...NC..|..NC+1.|....IX=1..1..
;"      ---------------------------------------------------------
"       |       |       |       |    . . . .    |       |       |
"       ---------------------------------------------------------
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       ---------------------------------------------------------
"       |       |       |       |    . . . .    |       |       |
"       |       |       |       |               |       |       |
"       ---------------------------------------------------------
"         IC=1    IC=2    IC=3                   IC=NC-1  IC=NC
"
"                                       1
"
"
"
"       VERSION 1       ADAPTED FROM CAVITY(EGS3) HOWFAR      10/87  AFB
"                       THE SUBROUTINE CALLS TO CONES AND
"                       SPHERE HAVE BEEN REPLACED BY MACROS
"                       TO SPEED THINGS UP
"
"
"******************************************************************************
"
;
%E     "taken from cavsphnrc.mortran"
"THE MACRO REPLACING THE CALL TO SPHERE
"*****************************************************************************
"
"                               ***********
"                               *         *
"                               * $SPHERE *
"                               *         *
"                               ***********
"
"MACRO TO BE CALLED BY SUBROUTINE HOWFAR IN THE EGS CODE SYSTEM
"
"FOR A PARTICLE TRAVELLING INSIDE TWO CONCENTRIC, INFINITE, RIGHT SPHERES,
"THIS SUBROUTINE DETERMINES THE MINIMUM DISTANCE IT MUST GO TO HIT A SPHERE.
"THE SPHERES ARE ASSUMED TO BE CENTERED AT THE ORIGIN.
"
"       SOME VARIABLES
"       ==============
"
"{P1} = IX    = THE NUMBER OF THE OUTER SPHERE
"{P2} = IHITS = 1 => PARTICLE HITS THE OUTER SURFACE
"             = 0 => PARTICLE MISSES THE SURFACES
"             =-1 => PARTICLE HITS THE INNER SURFACE
"{P3} = TSPH  = DISTANCE TO SURFACE IF IT HITS
"RSPH2(IX)    = RADIUS**2 OF SPHERE
"
"FOR PARTICLES NEAR THE SURFACE, A FIRST ORDER APPROXIMATION IS MADE
"FOR EXPRESSIONS LIKE X-SQRT(X**2+EPSILON), WHICH SOMETIMES SETS TSPH=0.
"
"MACRO VERSION 1             A.F.BIELAJEW NRCC             88/03
"                                ADAPTED FROM SCASPH (EGS3)
"
"******************************************************************************
"
;
REPLACE {$SPHERE(#,#,#);} WITH {
B=UL*XL+VL*YL+WL*ZL;C=XL*XL+YL*YL+ZL*ZL;B2=B*B;
:START-SPHERE:;
IF({P1}.NE.1)[
    CIN=C-RSPH2({P1}-1);
    IF(CIN.LT.0.0)[
        IRL=IRL-NC;
        IR(NP)=IRL;
        {P1}={P1}-1;
        GEOBUG=1;
        GOTO :START-SPHERE:;
        ]
    IF(B2.LT.CIN)  [{P2}=0;]
    ELSEIF(B.GE.0.)[{P2}=0;]
    ELSE[
        {P2}=-1;
        TEST=CIN/B2;
        IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST); ]
        ELSEIF(TEST.GE.1.)    [BS=B;                   ]
        ELSE                  [BS=B*(1.+SQRT(1.-TEST));]
        {P3}=-CIN/BS;
        GOTO :END-SPHERE:;
        ]
    ]
COUT=C-RSPH2({P1});
IF(COUT.GT.0.0)[
    IRL=IRL+NC;
    IR(NP)=IRL;
    {P1}={P1}+1;
    GEOBUG=1;
    GOTO :START-SPHERE:;
    ]
{P2}=1;
IF(B.EQ.0.)[{P3}=SQRT(-COUT);]
ELSE[
    TEST=COUT/B2;
    IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST); ]
    ELSEIF(TEST.GE.1.)    [BS=B;                   ]
    ELSE                  [BS=B*(1.+SQRT(1.-TEST));]
    IF(B.LE.0.)[{P3}=-BS;]ELSE[{P3}=-COUT/BS;]
    ]
:END-SPHERE:;
}

;
"THE MACRO REPLACING THE CALL TO CONES
"******************************************************************************
"
"                               **********
"                               *        *
"                               * $CONES *
"                               *        *
"                               **********
"
"PROGRAM TO BE CALLED BY HOWFAR IN THE EGS CODE SYSTEM
"
"FOR A PARTICLE TRAVELLING INSIDE TWO CONES WITH AXES
"ALIGNED ALONG THE Z-AXIS, THIS ROUTINE CALCULATES THE STRAIGHT LINES DISTANCE
"IT MUST GO TO HIT ONE OF THE CONES
"
"       SOME VARIABLES
"       ==============
"
"{P1} = IC    = THE CONE NUMBER OF THE REGION THE PARTICLE IS IN
"{P2} = IHITC = 1  => PARTICLE HITS THE OUTER CONE
"             = 0  => PARTICLE MISSES BOTH CONES
"             = -1 => PARTICLE HITS THE INNER CONE
"{P3} = TCONE = DISTANCE TO THE CONE THAT IT HITS
"TANAL2(IX)   = TANGENT**2 OF CONE OPENING ANGLE
"
"MACRO VERSION 1             A.F.BIELAJEW NRCC             88/03
"                                ADAPTED FROM SCASPH (EGS3)
"
"******************************************************************************
"
"------------------------------------------------------------------------------"
"                                                                              "
"   macro below replaces GOTO statements between IF-BLOCKS avoiding compiler   "
"   warnings.                                                                  "
"                                                                              "
" {P1} => as above, cone number of the region the particle is in               "
" {P2} => +/- depending whether region number is to be increased or decreased  "
"                                                          EMH, June 5, 2002   "
"------------------------------------------------------------------------------"
;
REPLACE {$RESET REGION # #;} WITH {;
IRL = IRL {P2} 1;
IR(NP) = IRL;
{P1} = {P1} {P2} 1;
GEOBUG = 1;
GOTO :START-CONE:;
}
;
REPLACE {$CONES(#,#,#);} WITH {;
:START-CONE:;
IHITCI=0;IHITCO=0;
IF({P1}.EQ.NPLAN2)[
    IF(ZL.GT.0.)[$RESET REGION {P1} -;] "GOTO :BUG1:;"
    ELSEIF(WL.LE.0.)[;]
    ELSE[IHITCI=-1;TCONEI=-ZL/WL;]
]
ELSEIF({P1}.NE.1)[
    TANA2=TANAL2({P1}-1);
    A=UL*UL+VL*VL-TANA2*WL*WL;
    B=UL*XL+VL*YL-TANA2*WL*ZL;
    C=XL*XL+YL*YL-TANA2*ZL*ZL;
    AC=A*C;B2=B*B;
    IF(C.GE.0)[
        IF(ZL.LT.0.0)[
            IF({P1}.LT.NPLAN2)[$RESET REGION {P1} +;]"GOTO :BUG4:;"
            $RESET REGION {P1} -;
            ":BUG1:;"
        ]
        IF(B2.LT.AC)[;]
        ELSEIF((A.GE.0.).AND.(B.GE.0.))[;]
        ELSE[
            IF(B.EQ.0.)[TCONEI=SQRT(-C/A);]
            ELSE[TEST=AC/B2;
                IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
                ELSEIF(TEST.GE.1.)[BS=B;]
                ELSE[BS=B*(1.+SQRT(1.-TEST));]
                IF(B.GT.0.)[TCONEI=-BS/A;]ELSE[TCONEI=-C/BS;]
            ]
            TEST=TANALP({P1}-1)*(ZL+WL*TCONEI);
            IF(TEST.LT.0.)[;]ELSE[IHITCI=-1;]
        ]
    ]
    ELSEIF(TANALP({P1}-1)*ZL.GE.0.)[
        IF(ZL.GT.0.0)[$RESET REGION {P1} -;]"GOTO :BUG1:"
        IF((A.LE.0.).AND.(B.LE.0.))[;]
        ELSE[
            IF(B.EQ.0.)[TCONEI=SQRT(-C/A);]
            ELSE[TEST=AC/B2;
                IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
                ELSEIF(TEST.GE.1.)[BS=B;]
                ELSE[BS=B*(1.+SQRT(1.-TEST));]
                IF(B.LE.0.)[TCONEI=-BS/A;]ELSE[TCONEI=-C/BS;]
            ]
            IHITCI=-1;
        ]
    ]
    ELSE[
        GOTO :SKIP-THIS:;
        IF((A.LT.0.).AND.(B.GT.0.))[
            TEST=AC/B2;
            IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
            ELSEIF(TEST.GE.1.)[BS=B;]
            ELSE[BS=B*(1.+SQRT(1.-TEST));]
            TCONEI=-BS/A;
            IHITCI=-1;
        ]
        ELSE[;]
:SKIP-THIS:;
    ]
]
IF({P1}.EQ.NPLAN1)[
    IF(ZL.LT.0.)[$RESET REGION {P1} +;]"GOTO :BUG4:;"
    ELSEIF(WL.GE.0.)[;]
    ELSE[IHITCO=1;TCONEO=-ZL/WL;]
]
ELSEIF({P1}.NE.NC)[
    TANA2=TANAL2({P1});
    A=UL*UL+VL*VL-TANA2*WL*WL;
    B=UL*XL+VL*YL-TANA2*WL*ZL;
    C=XL*XL+YL*YL-TANA2*ZL*ZL;
    AC=A*C;B2=B*B;
    IF(C.GE.0)[
        IF(ZL.GT.0.0)[
           IF({P1}.GT.NPLAN1)[$RESET REGION {P1} -;]"GOTO :BUG1:"
           $RESET REGION {P1} +;"GOTO :BUG4:;"
        ]
        IF(B2.LT.AC)[;]
        ELSEIF((A.GE.0.).AND.(B.GE.0.))[;]
        ELSE[
            IF(B.EQ.0.)[TCONEO=SQRT(-C/A);]
            ELSE[TEST=AC/B2;
                IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
                ELSEIF(TEST.GE.1.)[BS=B;]
                ELSE[BS=B*(1.+SQRT(1.-TEST));]
                IF(B.GT.0.)[TCONEO=-BS/A;]ELSE[TCONEO=-C/BS;]
            ]
            TEST=TANALP({P1})*(ZL+WL*TCONEO);
            IF(TEST.LT.0.)[;]ELSE[IHITCO=1;]
        ]
    ]
    ELSEIF(TANALP({P1})*ZL.GE.0.)[
        IF(ZL.LT.0.0)[
            $RESET REGION {P1} +;
            ":BUG4:;"
            ]
        IF((A.LE.0.).AND.(B.LE.0.))[;]
        ELSE[
            IF(B.EQ.0.)[TCONEO=SQRT(-C/A);]
            ELSE[TEST=AC/B2;
                IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
                ELSEIF(TEST.GE.1.)[BS=B;]
                ELSE[BS=B*(1.+SQRT(1.-TEST));]
                IF(B.LE.0.)[TCONEO=-BS/A;]ELSE[TCONEO=-C/BS;]
            ]
            IHITCO=1;
        ]
    ]
    ELSE[
        GOTO :END-CONE:;
        IF((A.LT.0.).AND.(B.GT.0.))[
            TEST=AC/B2;
            IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
            ELSEIF(TEST.GE.1.)[BS=B;]
            ELSE[BS=B*(1.+SQRT(1.-TEST));]
            TCONEO=-BS/A;
            IHITCO=1;
        ]
        ELSE[;]
    ]
]
:END-CONE:;
IF((IHITCI.EQ.-1).AND.(IHITCO.EQ.1))[
    IF(TCONEI.LE.TCONEO)[{P2}=IHITCI;{P3}=TCONEI;]
    ELSE[{P2}=IHITCO;{P3}=TCONEO;]
]
ELSEIF(IHITCI.EQ.-1)[{P2}=IHITCI;{P3}=TCONEI;]
ELSEIF(IHITCO.EQ.1)[{P2}=IHITCO;{P3}=TCONEO;]
ELSE[{P2}=0;]
}
;
"******************************************************************************
"
REPLACE {$CALL-HOWNEAR(#);} WITH {
  call hownear({P1},x(np),y(np),z(np),ir(np));
}
;
subroutine hownear(tperp,x,y,z,ir);

$IMPLICIT-NONE;

COMIN/GEOM,SCORE/;   "SCORE needed for IHSTRY"

"Subroutine arguments
$REAL
     tperp, "nearest distance to any boundary (output)
     x,     "x-position of the particle (input)
     y,     "y-position of the particle (input)
     z;     "z-position of the particle (input)
;
$INTEGER
     ir     "region number of the particle
;

"Local variables

$REAL
     r,     "spherical radius"
     rhol,  "x-y radius"
     rhol2  "x-y radius squared"
;
$INTEGER
     ix, "current cylindrical radius number
     ic  "current planar slab number
;

ix = (ir - 2)/nc + 1;
ic =  ir - 1 - nc*(ix - 1);

rhol2 = x*x + y*y;
r     = sqrt( rhol2 + z*z );

tperp = rsph(ix) - r;
IF(ix.NE.1)[tperp = min( tperp, r - rsph(ix-1) );]
IF(nc.NE.1)[
   rhol = sqrt( rhol2 );
   IF(ic.NE.nc)[
      tperp = min( tperp, abs(cosalp(ic)*(rhol - tanalp(ic)*z )));
   ]
   IF(ic.NE.1)[
      tperp = min(tperp, abs(cosalp(ic-1)*(rhol-tanalp(ic-1)*z )));
   ]
]
return;
end;

%E     "taken from cavsphnrc.mortran"
%Q0
SUBROUTINE HOWFAR;

$IMPLICIT-NONE;

;
"MACRO USED LOCALLY TO CHANGE REGIONS, ADJUST USTEP, AND EXIT"
REPLACE {$SET NEW REGION(#,#);} WITH {;
  IF({P1}.LE.USTEP)[USTEP={P1};IRNEW={P2};]
  RETURN;
}

;COMIN/EPCONT,STACK,GEOM,SCORE,MISC/;

COMMON/IBUG/ICBUG;

LOGICAL OUTSID;INTEGER GEOBUG, ICBUG;

$INTEGER IRL,IX,IC,IHITS,IHITC,IHITCO,IHITCI;
$REAL    UL,VL,WL,XL,YL,ZL,A,B,B2,C,COUT,CIN;
$REAL    TCONE,TSPH,RL,RHOL,RHOL2,DNTMP;
$REAL    TCONEI,TCONEO,TEST,AC,BS,TANA2;
$INTEGER ibsearchrev;

"DISCARD ZERO WEIGHT PARTICLES"
IF(WT(NP).EQ.0.0)[IDISC=1;RETURN;]

OUTSID=.FALSE.;"INITIALLY ASSUME PARTICLE STAYS IN THE TARGET"

GEOBUG=0; "SET THE GEOMETRY BUG INDICATOR FLAG TO OFF"

IRL=IR(NP); "LOCAL REGION NUMBER"

"DISCARD IF PARTICLE WANTS TO LEAVE THE GEOMETRY"
IF(IRL.EQ.1)[IDISC=1;RETURN;]

$GET-IX-IC(IRL); "GET CONICAL AND SPHERICAL ZONES NUMBERS"

UL=U(NP);VL=V(NP);WL=W(NP);XL=X(NP);YL=Y(NP);ZL=Z(NP); "LOCAL VARIABLES"

IF(NC.GT.1)[
    "SEARCH ONLY IF CONES ARE DEFINED"
    $CONES(IC,IHITC,TCONE);"GET DISTANCE TO CONE"
        "IHITC  =  1 => HITS OUTER CONE"
        "       =  0 => MISSES BOTH CONES"
        "       = -1 => HITS INNER CONE"
    ]
ELSE[
    "NO CONES IN THE PROBLEM"
    IHITC=0;
    ]

$SPHERE(IX,IHITS,TSPH);"GET DISTANCE TO SPHERE"
"       IHITS   =  1 => HITS OUTER SPHERE"
"               =  0 => MISSES BOTH SPHERES"
"               = -1 => HITS INNER SPHERE"

"QUICK EXIT TO ELECTR IF A GEOMETRY ERROR WAS FOUND"
IF(GEOBUG.EQ.1) [
    USTEP=0.0;
    IF(IRL.GT.NREG) IRL=1;
    IRNEW=IRL;
    DNEAR(NP)=0.0;
    RETURN;
    ]

IF(IX+IHITS.GT.NR) OUTSID=.TRUE.; "FLAG IF LEAVES THE GEOMETRY"

"THIS CODING CAUSES THE DISTANCE TO THE SURFACE TO BE SLIGHTLY INCREASED"
"TO ALLOW SOME PENETRATION INTO THE NEXT REGION. THE AMOUNT OF INCREASE"
"IS SCALED TO E-6 OF THE DISTANCE FROM THE ORIGIN TO MAKE IT EFFECTIVE"
"EVERYWHERE IN THE GEOMETRY. ."
IF(IHITC.NE.0)[TCONE=TCONE*1.000005+0.000005;]
IF(IHITS.NE.0)[TSPH= TSPH *1.000005+0.000005;]
/*
IF( iq(np) = -1 & w(np) < 0 ) [
write(81,*) 'howfar: x = ',x(np),y(np),z(np),' u = ',u(np),v(np),w(np);
write(81,*) 'howfar: irl= ',irl,' tcone = ',tcone,' tsph = ',tsph,
    ' ustep = ',ustep;
]
*/

"DO MOST PROBABLE CASE FIRST WHERE A CONE AND A SPHERE CAN BE HIT"

IF((IHITC.NE.0).AND.(IHITS.NE.0))[
    IF(TCONE.LT.TSPH)[
        "HITS CONE FIRST"
        $SET NEW REGION(TCONE,IRL+IHITC);
        ]
    ELSEIF(TSPH.LT.TCONE)[
        "HITS SPHERE FIRST"
        IF(OUTSID)[$SET NEW REGION(TSPH,1);]
        ELSE[$SET NEW REGION(TSPH,IRL+NC*IHITS);]
        ]
    ELSE[
        "ODD CASE TSPH=TCONE:HITS CONE AND SPHERE TOGETHER"
        IF(OUTSID)[$SET NEW REGION(TSPH,1);]
        ELSE[$SET NEW REGION(TSPH,IRL+IHITC+NC*IHITS);]
        ]
    ]

"DO ODD OR NO CONE CASE-PARTICLE CAN HIT SPHERE BUT NOT CONE"

ELSE[
    IF(OUTSID)[$SET NEW REGION(TSPH,1);]
    ELSE[$SET NEW REGION(TSPH,IRL+NC*IHITS);]
    ]

"AT THIS STAGE ALL GEOMETRICAL POSSIBILITIES HAVE BEEN CHECKED AND CONTROL"
"HAS ALREADY BEEN TRANSFERRED TO EGS"

RETURN;
END; "END OF SUBROUTINE HOWFAR"
;    "NEED TO ADD SEMICOLON HERE"
%F

C************************************************************
C
C     returns the initial non-blank position in the string
C
C************************************************************
      integer function sini( string )
C************************************************************
      implicit none
      character*10 string
      integer i
      sini = 1
      do i = 1, len(string)
        if (string(i:i).ne.' ') then
          sini = i
          return
        end if
      end do
      sini = len(string)

      return
      end
C************************************************************
C
C  returns the first non-blank position on the end the string
C
C************************************************************
      integer function sfin( string, length )
C************************************************************
      implicit none
      character*10 string
      integer i, length
      sfin = length
      do i = length, 1, -1
        if (string(i:i).ne.' ') then
          sfin = i
          return
        end if
      end do
      sfin = 1
      return
      end
C************************************************************
C
C     returns the length of the string defined by the first
C     blank space encountered in the string.
C
C************************************************************
      integer function slength( string )
C************************************************************
      implicit none
      character*256 string
      integer i

       do i = 1, len(string)
        if (string(i:i).eq.' ') then
          slength = i-1
          return
        end if
       end do
       slength = len(string)

      return
      end

C*******************************************************************************
C*                                                                             *
C*                        Function ibsearchrev(a, nsh, b)                      *
C*                                                                             *
C*              binary search for an element l of array b such that            *
C*          b[l] => a > b[l+1],                                                *
C*                                                                             *
C*  Note: array must be decreasingly monotone                                  *
C*                                                                             *
C*******************************************************************************
      integer function ibsearchrev(a, nsh, b)
      real*8 a, b(*)
      integer min,max,help,nsh
      real*8 x
c     array b represents array of energy or of angle distribution
      min = 1
      max = nsh
      x = a
      do while ( min.lt.max-1 )
         help = (max+min) / 2  !bitweise ganzzahlige Division durch 2
         if ( b(help).ge.x) then
            min = help
         else
           max = help
         endif
      enddo
      ibsearchrev = min
      end


%M
%I4
!INDENT F2;
%C80
%Q1
%E
;SUBROUTINE PLOT;

$IMPLICIT-NONE;

COMIN/GetInput/;
COMIN/GEOM,IODAT1,IODAT2,PLOTC,SCORE,USER/;
character *24 time_and_date;
character*10  ch_var;
CHARACTER*60  SERIESTITLE, XTITLE, YTITLE, SUBTITLE;
CHARACTER*80  TEMPTITLE;
INTEGER       sini, sfin, ini, fin;
INTEGER       I,J,IX,IC,irl;
INTEGER       ICOL1,ICOL2,NPTS,PLTYPE,IAXISTYPE,UNITNUM,CURVENUM,int,CHECK;
$INTEGER      IPLTUNX,IPLTUNC,IZD,IXD,NPPAGE,ICOUNT,IXR,IZZ;
$REAL         XCOORD($MXREG), YCOORD($MXREG), UNCERT($MXREG),rvol2;
$REAL         HISTXMIN;

IPLTUNX = 23;
IPLTUNC = 24;
call egs_get_fdate(time_and_date);
IF (IOPLOT > 0)["plotting requested"
    DO I=1,80[TEMPTITLE(I:I)=TITLE(I);]
    CURVENUM=0;  "counter for the curve # of the graph"
    IF(NPLOTR.NE.0) [
        "DEPTH-DOSE PLOTS ON PLOTTER"
        DO IXR=1,NPLOTR [
          IX=IPLOTR(IXR);
          IF( IX > 0 )[
                DO IC = 1, NC [
                    $GET-IRL(ic,ix);
                    IF (IOPLOT = 1)["histogram plot"
                       XCOORD(IC) = ALPHA(IC);
                       PLTYPE = 1;
                    ]
                    ELSE IF (IOPLOT = 2)["point graph"
                       XCOORD(IC) = 0.5*(ALPHA(IC)+ALPHA(IC-1));
                       PLTYPE = 0;
                    ]
                    YCOORD(IC) = dose(irl,0);
                    UNCERT(IC) = dose2(irl,0);
                ]

                "Plot of dose zone results to file [-.plotdat]"
                "OPEN(UNIT=24, file='fort.24', STATUS='UNKNOWN');"
                "No needed, opened in egs_init since defined via"
                "an *.io file"

                "Convert radial zone number(IX) to a character string"
                write(ch_var,'(f8.2)') rsph(IX);
                ini = sini(ch_var);
                fin = sfin(ch_var,len(ch_var));

                "For complete summary of the following variables see"
                "XVGRPLOT.MORTRAN"

                NPTS=NC;            "number of points per graph"
                SERIESTITLE='r=' // ch_var(ini:fin) // ' cm';
                XTITLE='angle \\8q\\0 /deg';
                YTITLE='dose per incident particle / Gy';
                SUBTITLE='Dose vs. angle on '// time_and_date;
                UNITNUM=IPLTUNC;        "Output file"
                "PLTYPE=1;               histogram=1, XY-plot=0"
                HISTXMIN=0.0;     "value of lower X-bin(for HIST. only)"
                IAXISTYPE=0;             "0 for no logs"

                "plot graph"
                CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                               NPTS, CURVENUM, SERIESTITLE,
                               XTITLE, YTITLE, TEMPTITLE, SUBTITLE,
                               UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);

                CURVENUM=CURVENUM+1;
          ]
        ]
    ]
    CURVENUM=0;  "counter for the curve # of the graph"
    IF(NPLOTZ.NE.0) ["RADIAL PLOTS FOR PLOTTER"
      DO IZZ=1,NPLOTZ [
 IC=IPLOTZ(IZZ);
 IF( IC > 0 )[
     DO IX = 1, NR [
      $GET-IRL(ic,ix);
      "XCOORD(IX) = 0.5*(rsph(ix)+rsph(ix-1));"
      "added here since volume calculated exactly."
      "see Janicki&Seuntjens Med.Phys paper.        "
      rvol2 = 1.0/3.0*(rsph(ix)**2+rsph(ix-1)**2+rsph(ix)*rsph(ix-1));
      XCOORD(IX) = sqrt(rvol2);
      YCOORD(IX) = dose(irl,0)*rvol2;
      PLTYPE = 0;
      IF (IOPLOT = 1)["histogram plot"
        XCOORD(IX) = rsph(IX);
        PLTYPE = 1;
      ]
      UNCERT(IX) = dose2(irl,0)*XCOORD(IX)**2;
     ]

     "Plot of dose zone results to file [-.plotdat]"
     "OPEN(UNIT=23, file='fort.23', STATUS='UNKNOWN');"
     "No needed, opened in egs_init since defined via"
     "an *.io file"

     "Convert radial zone number(IX) to a character string"
     write(ch_var,'(f8.2)') alpha(IC);
     ini = sini(ch_var);
     fin = sfin(ch_var,len(ch_var));

     "For complete summary of the following variables see"
     "XVGRPLOT.MORTRAN"

     NPTS=NR;      "number of points per graph"
     SERIESTITLE='\\8q\\0 =' // ch_var(ini:fin) // '\\So';
     XTITLE='radius r /cm';
     YTITLE='dose per particle D(r)*r\\S2 \\N / Gy*cm\\S2\\N';
     SUBTITLE='energy fraction vs. radius on '// time_and_date;
     UNITNUM=IPLTUNX;  "Output file"
     "PLTYPE=1;      histogram=1, XY-plot=0"
     HISTXMIN=0.0;     "value of lower X-bin(for HIST. only)"
     IAXISTYPE=0;    "0 for no logs"

     "plot graph"
     CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
      NPTS, CURVENUM, SERIESTITLE,
      XTITLE, YTITLE, TEMPTITLE, SUBTITLE,
      UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);

     CURVENUM=CURVENUM+1;
   ]
      ]
    ]


]

RETURN;
END;
;
"****************************************************************************"

subroutine combine_results(file_name);

"****************************************************************************"
implicit none;
character*(*) file_name;

;COMIN/SCORE,RANDOM,IODAT2,GEOM,SOURCE/;
"******************************************************* ADDED BY JT, DEC.98"
"*                Variables for post-processing parallel run               *"
"***************************************************************************"
$LONG_INT  TMPNCASE;          "T>temp variable for NCASE
$INTEGER   IORSTRT;
$REAL      TMPTMCPU;          "T>dummy variable for TIMCPU

REAL*8     tdose($MXREG,0:$MAXIT),
           tdose2($MXREG,0:$MAXIT);
real*8     tcavdose,tcavdose2;

real*8     tedeprelax,tanorm;

$LONG_INT  tncrej, tncompt;
"***************************************************************************"

$INTEGER my_unit,egs_get_unit,iout,ic,ix,it,lnblnk1,irl,j;
$LOGICAL first_time;
data first_time/.true./, iout/1/;
save first_time,iout;

IF( first_time ) [

      OUTPUT ;(/1X,'Summing the following .egsdat files');
      OUTPUT ; (1X,'------------------------------------'/);
      WRITE(IOUT,'(/1X,''Summing the following .egsdat files'')');
      WRITE(IOUT,'(1X,''------------------------------------''/)');

      /TMCPUO,NCASEO,NCOMPT,NCREJ,EDEPRELAX/=0;
      /cavdose, cavdose2,anorm,datcount/    =0;
      DO irl = 2, NREG[
        DO j = 0, $MAXIT[
          /dose(irl,j),dose2(irl,j)/        =0;
        ]
      ]
      first_time                            = .false.;
]

my_unit = egs_get_unit(4);
WRITE(IOUT,'(A)') $cstring(file_name);
WRITE(6,'(A)') $cstring(file_name);
open(my_unit,file=file_name,status='old',err=:EOF_RS1:);

read(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) tcavdose, tcavdose2;

cavdose =cavdose +tcavdose;
cavdose2=cavdose2+tcavdose2;

DO irl = 2,NREG[
   read(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:)
       (tdose(irl,j),tdose2(irl,j),j=0,$MAXIT);
   DO j = 0, $MAXIT[
      dose(irl,j)  = dose(irl,j)  + tdose(irl,j);
      dose2(irl,j) = dose2(irl,j) + tdose2(irl,j);
   ]
]
$RETRIEVE RNG STATE FROM UNIT my_unit;
READ(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) TMPNCASE,TMPTMCPU;

write(6   ,*) '   ncase = ',TMPNCASE,' cpu time = ',TMPTMCPU;
write(iout,*) '   ncase = ',TMPNCASE,' cpu time = ',TMPTMCPU;

TMCPUO=TMCPUO+TMPTMCPU; NCASEO=NCASEO+TMPNCASE;

READ(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) TNCOMPT,TNCREJ;
NCOMPT = NCOMPT + TNCOMPT;
NCREJ  = NCREJ  + TNCREJ;

READ(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) TEDEPRELAX;
EDEPRELAX = EDEPRELAX + TEDEPRELAX;

READ(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) tanorm;
anorm = anorm + tanorm;

datcount=datcount+1;

CLOSE(UNIT=my_unit);
return;

:EOF_RS1:;
WRITE(6,*) 'failed to open file';
return;

:EOF_RS3:;
write(6,*) 'failed to read file';
close(my_unit); return; end;


"******************************************************************"
"                                                          NRCC    "
SUBROUTINE COMPT_NO_DOPP;
"                                VERSION 1.00  --  12 JAN 1999     "
"******************************************************************"
"                                                                  "
"   Subroutine for sampling incoherent (Compton) scattering        "
"   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
"   Otherwise scattering is modelled in the impuls approximation   "
"    (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325) "
"   As the total cross section from PEGS4 is not modified (and thus"
"   calculated using Klein-Nishina), all rejections leed to an     "
"   unscattered photon and a zero energy electron.                 "
"   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
"   atomic relaxation is treated in RELAX. This has as a           "
"   consequence that more than one particle can be created as a    "
"   result of an incoherent scattering. The user should therefore  "
"   check their user codes for possible inconsistencies.           "
"                                                                  "
"   I.Kawrakow, January 1999                                       "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/COMPTON-DATA,DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM/;

$DEFINE-LOCAL-VARIABLES-COMPT;

NPold = NP;       "Set the old stack counter"
peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
ko = peig/rm;     "Gamma energy in units of electron rest energy"
broi = 1 + 2*ko;  "Needed for scattering angle sampling"

irl = ir(np);
IF( ibcmp(irl) = 1 ) [ "User wants to take into account binding effects"
                       "=>first sample the shell and see whether an    "
                       "  interaction is possible                      "
    $RANDOMSET rnno17;
    DO i=1,n_shell(medium) [
        rnno17 = rnno17 - eno_array(i,medium);
        IF( rnno17 <= 0 ) EXIT;
    ]
    j = shell_array(i,medium); "j is the shell number in the data list"
    Uj = be_array(j);          "Uj is the binding energy in units of rm"

    " Binding energy rejection "
    IF( ko <= Uj ) [ goto :INTERACTION-REJECTED:; ]
    Jo = Jo_array(j);          "Jo is the Compton profile parameter"

]

" We always sample the scattering angle from Klein-Nishina"
:RESAMPLE:
;
IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
    broi2 = broi*broi;
    alph1 = Log(broi);
    alph2 = ko*(broi+1)/broi2;
    alpha = alph1/(alph1+alph2);
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        IF( rnno15 < alpha ) [ "Use 1/br part"
            br = Exp(alph1*rnno16)/broi;
        ]
        ELSE [  "Use the br part."
            br = Sqrt(rnno16 + (1-rnno16)/broi2);
        ]
        temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
        rejf3 = 1 - br*sinthe/(1+br*br);
        $RANDOMSET rnno19;
    ] UNTIL rnno19.le.rejf3;
]
ELSE [ "At low energies it is faster to sample br uniformely"
    bro = 1./broi; bro1 = 1 - bro;
    rejmax = broi + bro;
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        br = bro + bro1*rnno15;
        temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
        rejf3 = (br + 1./br - sinthe)/rejmax;
    ] UNTIL rnno16.le.rejf3;
]

IF(br < 1./broi | br > 1)  [
    IF( br < 0.99999/broi | br > 1.00001 ) [
    write(6,*) ' sampled br outside of allowed range! ',ko,1./broi,br;
    ]
    goto :RESAMPLE: ;
]

costhe = 1 - temp;
IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
    Uj = 0;
    goto :FINISHED-COMPTON-SAMPLING:;
]


" Check for rejection due to the limited range of pzmax "
br2 = br*br;
aux = ko*(ko-Uj)*temp;
pzmax = (aux - Uj)/sqrt(2*aux + Uj*Uj);
IF( pzmax <= -1 ) goto :INTERACTION-REJECTED:;
qc2 = 1 + br*br - 2*br*costhe;
qc  = sqrt(qc2);

IF( pzmax > 1 ) [
    pzmax = 1; af = 0; Fmax = 1; fpz = 1;
    goto :RETRY-PZ:;
]

aux3 = 1 + 2*Jo*abs(pzmax);
aux4 = 0.5*(1-aux3*aux3);
fpz  = 0.5*exp(aux4);
af   = qc*(1+br*(br-costhe)/qc2);

IF( af < 0 ) [
    IF( pzmax > 0 ) fpz = 1 - fpz;
    $RANDOMSET eta_incoh;
    IF( eta_incoh > fpz ) goto :INTERACTION-REJECTED:;
    af = 0; Fmax = 1; goto :RETRY-PZ:;
]

IF( pzmax < -0.15 ) [
    Fmax = 1-af*0.15;
    fpz1 = fpz*Fmax;
]
ELSE IF( pzmax < 0.15 ) [
    Fmax = 1 + af*pzmax;
    aux3 = 1/(1+0.33267252734*aux3);
            "0.33267252734 is p/sqrt(2), p is the parameter from Eq. 7.1.25"
            "of Abramowitz and Stegun, needed for approximating Erf        "
    aux4 = fpz*aux3*(0.3480242+aux3*(-0.0958798+aux3*0.7478556)) +
           erfJo_array(j);
    IF( pzmax > 0 ) [
        "fpz1 = 1 - Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
          "missing factor 1/2 in the above found by Cerneliu Costescu"
          "0.62665706866 is sqrt(Pi/8)"
        fpz1 = 1 - Fmax*fpz - 0.62665706866*af/Jo_array(j)*aux4;
        fpz = 1 - fpz;
    ]
    ELSE [
        "fpz1 = Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
          "missing factor 1/2 in the above found by Cerneliu Costescu"
          "0.62665706866 is sqrt(Pi/8)"
        fpz1 = Fmax*fpz - 0.62665706866*af/Jo_array(j)*aux4;
    ]
]
ELSE [
    Fmax = 1 + af*0.15;
    fpz1 = 1 - Fmax*fpz;
    fpz = 1 - fpz;
]
$RANDOMSET eta_incoh;
IF(eta_incoh > fpz1 ) goto :INTERACTION-REJECTED:;

"At this point, all rejections are handled, now we need to sample pz "
"between -1 and pzmax using the Compton profile of the selected shell"
"and F(pz,cos(theta)) as a rejection function                        "

:RETRY-PZ:;

:FINISHED-COMPTON-SAMPLING:

br = 1. + ko*(1-costhe);
br = 1./br;

"pesg = br*peig; pese = peig - pesg - Uj + prm;"
pesg = br*peig; pese = peig - pesg + prm;

sinthe = Sqrt(sinthe);
call uphi(2,1); e(np) = pesg;
aux = 1 + br*br - 2*br*costhe;
IF( aux > 1e-8 ) [
    costhe = (1-br*costhe)/Sqrt(aux);
    sinthe = (1-costhe)*(1+costhe);
    IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
    ELSE [ sinthe = 0; ]
] ELSE [ costhe = 0; sinthe = -1; ]
np = np + 1;
$CHECK-STACK(np,'COMPT');
call uphi(3,2);
e(np) = pese; iq(np) = -1;

/*
IF( ibcmp(irl) = 1 ) [

    " Shell vacancy "
    IF( Uj > 1e-3 ) [
        edep = 0;
        call relax(Uj,shn_array(j),iz_array(j));
          "relax will put all particles with energies above ecut,pcut on the "
          "stack, the remaining energy will be scored in edep and deposited  "
          "localy (via the call to ausgab below)                             "
    ]
    ELSE [ edep = Uj; ]
    $AUSCALL($PHOTXAUS);     "generates IARG = 4 call"

]
*/


" Now play Russian Roulette with resulting electrons if the user asked for it"
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"

return;

:INTERACTION-REJECTED:
" Create here a zero energy electron if required (check user codes) "
return;
end;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc ranmar random number generator                                      "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2000                                       "
"                   Dave Rogers, 2000                                         "
"                                                                             "
"  Contributors:                                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The following is the initialization routine for the RANMAR random number   "
"  generator (RNG) proposed by Marsaglia and Zaman and designed to be used    "
"  with the EGSnrc system.                                                    "
"                                                                             "
"  Note that this implementation uses integers to store the state of the RNG  "
"  and to generate the next number in the sequence. Only at the end are the   "
"  random numbers are converted to reals by a multiplication with 2**(-24)    "
"  (there are only 24 significant bits). I found the integer implementation   "
"  to be about 30% faster then using reals on Pentium III machines, and       "
"  nearly 70% faster on older SGI workstations.                               "
"                                                                             "
"  The use of RANMAR requires the file ranmar.macros (which defines the       "
"  actual random number generation as a macro).                               "
"                                                                             "
"#############################################################################"


subroutine init_ranmar;

implicit none;

;COMIN/RANDOM/;

integer*4 s,t;
integer*4 i,j,k,l,m,ii,jj;

IF( ixx <= 0 | ixx > 31328 ) ixx = 1802; "Sets Marsaglia default"
IF( jxx <= 0 | jxx > 30081 ) jxx = 9373; "sets Marsaglia default"

i = mod(ixx/177,177) + 2;
j = mod(ixx,    177) + 2;
k = mod(jxx/169,178) + 1;
l = mod(jxx,    169)    ;

DO ii = 1,97 [

    s = 0; t = 8388608;  "t is 2**23 i.e. half of the maximum allowed"
                         "(note that only 24 bits are used)          "

    DO jj = 1,24 [

                         "The if( fool_optimizer ...) statements below are"
                         "to prevent re-arangement of statements for high "
                         "level optimizations and thus different sequences"
                         "on different architectures                      "

        m = mod(mod(i*j,179)*k,179);
        IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
        i = j;
        IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
        j = k;
        IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
        k = m;
        IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
        l = mod(53*l+1,169);
        IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
        IF(mod(l*m,64) >= 32) s = s + t;
        IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
        t = t/2;
        IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
    ]
    urndm(ii) = s;
]

crndm  =   362436;
cdrndm =  7654321;
cmrndm = 16777213;

twom24 = 1./16777216.;

ixx = 97;
jxx = 33;

rng_seed = $NRANMAR + 1;

return;
end; "End of init_ranmar for EGSnrc"

subroutine ranmar_get;
implicit none;
;COMIN/RANDOM/;
$INTEGER i,iopt;
IF( rng_seed = 999999 ) call init_ranmar;
DO i=1,$NRANMAR [
    iopt = urndm(ixx) - urndm(jxx);
    IF(iopt < 0) iopt = iopt + 16777216;
    urndm(ixx) = iopt;
    ixx = ixx - 1; jxx = jxx - 1;
    IF(ixx = 0)        [ ixx = 97; ]
    ELSE IF( jxx = 0 ) [ jxx = 97; ]
    crndm = crndm - cdrndm;
    IF(crndm < 0) crndm = crndm + cmrndm;
    iopt = iopt - crndm;
    IF(iopt < 0) iopt = iopt + 16777216;
    rng_array(i) = iopt;
]
rng_seed = 1; return; end;

;"       end of ranmar.mortran    "

%C80
"#############################################################################"
"                                                                             "
"  EGSnrc input source spectrum subroutine                                    "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Iwan Kawrakow, 2000                                       "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This subroutine is used to do all the work associated with having an input "
"  source spectrum for the NRC user codes.                                    "
"                                                                             "
"  This implementation of ENSRC uses the alias sampling technique to sample   "
"  the source energy from a histogrammed input energy spectrum (and thus      "
"  needs nrcaux.mortran). To avoid confusions with multiple definitions of    "
"  the spectrum common block, this common block should not be used any longer "
"  and all data needed stored in the static arrays ensrcd, srcpdf, srcpdf_at  "
"  and srcbin_at. For now, to assure compatibility with current versions of   "
"  NRC user codes, ensrcd and srcpdf are left in the common/source/.          "
"                                                                             "
"  Input is based on the input routine adapted by Aaron Merowitz from the     "
"  original ENSRC implementation that uses get_input.                         "
"                                                                             "
"                                                                             "
"  ENTRY POINTS                                                               "
"  ------------                                                               "
"                                                                             "
"   NSRC                    call from anywhere in your user code (but before  "
"                           the first SHOWER call) to get                     "
"                           input data as defined below                       "
"                                                                             "
"   NSRC1:                  initialization routine. To be called after        "
"                           ENSRC and before the first SHOWER call            "
"                                                                             "
"   NSRCO:                  produces a summary of the input data.             "
"                                                                             "
"   NSRCH(ENIN):            called from main for each history to sample the   "
"                           spectrum (MONOEN=1) or return the source energy   "
"                           if mono-energetic beam                            "
"                           COMMON/SOURCE/ (EINSRC) (MONOEN=2).               "
"                                                                             "
"   NSRC_EMAX(EK_MAX):      Puts maximum spectrum energy (source energy       "
"                           for mono-energetic beams) into EK_MAX             "
"                                                                             "
"   INPUTS                                                                    "
"   ------                                                                    "
"                                                                             "
"   NENSRC                  number of energy bins used to define the          "
"                           distribution                                      "
"                                                                             "
"   SRCPDF(I=1,NENSRC)      the source probability distribution not           "
"                           necessarily normalized                            "
"                           probability of particle in this bin or /MeV       "
"                                                                             "
"   ENSRCD(I=0,NENSRC)      ensrcd(i-1) is the bottom energy in bin i,        "
"                           ensrcd(i) the top energy                          "
"                           Note the definition as $REAL ensrcd(0:$NENSRC)    "
"                                                                             "
"   ENMIN                   equal ensrcd(0), still there for compatibility    "
"                                                                             "
"   IWATCH                  diagnostic printout if IWATCH is not 0            "
"                                                                             "
"   MONOEN                  passed in COMIN USER  = 0 if monoenergetic        "
"                                            = 2 if ISOURC=21                 "
"   EIN                     passed in IODAT2-K.E. of monoenergetic source     "
"                                                                             "
"                                                                             "
"   OTHER ARRAYS                                                              "
"   ------------                                                              "
"                                                                             "
"   srcpdf_at, srcbin_at    arrays necessary for the alias sampling           "
"                           technique, they are initialized via a call to     "
"                           prepare_alias_sampling and used in                "
"                           the function alias_sample to do the actual        "
"                           sampling                                          "
"                                                                             "
"                                                                             "
"   NOTES                                                                     "
"   -----                                                                     "
"                                                                             "
"   This routine DOES NOT need the COMIN SPECTR                               "
"                                                                             "
"   If ENFLAG=1 (variable in COMMON/SOURCE/) then the energy has been         "
"   previously set and stored in EINSRC (variable in COMMON/SOURCE/)          "
"                                                                             "
"#############################################################################"


%I4
%C80
%Q1


SUBROUTINE ENSRC;

$IMPLICIT-NONE;

;"LINE SKIP"

"***************************************************************************"
"*               Variables passed to the subroutine GET_INPUTS             *"
"***************************************************************************"
COMIN/GetInput/;

"These variables point to the index of their values_sought"
INTEGER NUM_EITYPE,
        NUM_KIEN,
        NUM_SPFIL,
        NUM_SPIOUSP;

"COMMIN BLOCK DEFINITIONS
"************************
;COMIN/PRINTC,IODAT2,SCORE,SPECTR,USER,RANDOM,SOURCE/;
"                           ^
" We want to make the energy spectrum sampling self contained ->
" no need to put required data in a common block that is defined in the
" main user code. The only dependence on the user code should be $NENSRC which
" is used to define array dimensions.

$INTEGER "nensrc,"
         srcbin_at($NENSRC),
         mode;
$REAL    "ensrcd(0:$NENSRC),"
         "srcpdf($NENSRC),"
         srcpdf_at($NENSRC),
         enmin,enmax,sume1,sume,
         Ek_max,Emono;
$LOGICAL is_mono;
character*256 filnam,spec_title;
integer*4 lnblnk1; "use our own in-house lnblnk routine because some"
                   "compilers do not have lnblnk"

save enmin,enmax,"nensrc," srcbin_at,"ensrcd,srcpdf," srcpdf_at,Emono,
     is_mono,mode,filnam,spec_title;

$INTEGER ib;
$REAL    enin,alias_sample;

"******************************************************************************
"            NOT REQUIRED IF ISOURC=21 (FULL PHASE SPACE OF READ)
"
" ENSRC DELIMETERS:  :start source inputs:
"                    :stop source inputs:
"
"
"  INCIDENT ENERGY
"        = monoenergetic  (0)  if monoenergetic beam
"        = spectrum       (1)  if energy spectrum to be used
"
"           ---------------------------------------
"
"  If INCIDENT ENERGY= Monoenergetic:
"
"     INCIDENT KINETIC ENERGY(MEV)   (I)
"                                   kinetic energy of the incident beam in MeV
"                                   (defaults to 1.25)
"
"           ---------------------------------------
"
"  If INCIDENT ENERGY= Spectrum:
"
"                   SPEC FILENAME   (C)  filename (with ext)
"                                   contains spectrum information
"
"                                   FILE FORMAT:
"                                   TITLE      spectrum title  (80 char)
"                                   NENSRC, ENMIN, MODE
"                                   NENSRC     # energy bins in spec.  histogram
"                                   ENMIN      lower energy of first bin
"                                   MODE       =0, assumes cts/bin
"                                              =1  assumes cts/MeV
"                                   ENSRCD(I),SRCPDF(I)  I=1,NENSRC
"                                   top of energy bin and probability of
"                                   initial particle being in this bin.
"                                   probability does not need to be normalized
"
"                   SPEC IOUTSP
"                        = none     (0)  no spectrum data in output summary
"                        = include  (1)  include spectrum data in output summary
;
"
"*******************************************************************************
;"------------------------------------------------------------------------------
DELIMETER='SOURCE INPUTS';

IF(ENFLAG.EQ.1)["FULL PHASE-SPACE INFORMATION READ PREVIOUSLY"
    MONOEN = 2;
    RETURN;
]
OUTPUT;(' *** INPUT CARD TC1 ***');
IVAL = IVAL +1;
NUM_EITYPE = IVAL;
VALUES_SOUGHT(IVAL)='INCIDENT ENERGY';
TYPE(IVAL)=3;
NVALUE(IVAL)=1;
ALLOWED_INPUTS(IVAL,0)='MONOENERGETIC';
ALLOWED_INPUTS(IVAL,1)='SPECTRUM';
$GET_INPUT(NUM_EITYPE);
MONOEN=VALUE(NUM_EITYPE,1);

IF(MONOEN = 0)[
    OUTPUT ;(' MONOENERGETIC BEAM:');
    IVAL = IVAL +1;
    NUM_KIEN = IVAL;
    VALUES_SOUGHT(IVAL)='INCIDENT KINETIC ENERGY(MEV)';
    TYPE(IVAL)=1;
    NVALUE(IVAL)=1;
    VALUE_MIN(IVAL)=0.001;    "databases for EGSnrc stop at 1 keV"
    VALUE_MAX(IVAL)=200000;   "not sure what real upper limit is"
    DEFAULT(IVAL)=1.25;
    $GET_INPUT(NUM_KIEN);
    EIN=VALUE(NUM_KIEN,1);
    OUTPUT EIN;(/' KINETIC ENERGY OF THE INCIDENT BEAM: ',T60,F10.4);
    is_mono = .true.; Emono = EIN;
]
ELSE[
    OUTPUT;(' ENERGY SPECTRUM:');

    is_mono = .false.;

    IVAL = IVAL +1;
    NUM_SPFIL = IVAL;
    VALUES_SOUGHT(IVAL)='SPEC FILENAME';
    TYPE(IVAL)=2;
    $GET_INPUT(NUM_SPFIL);
    READ (CHAR_VALUE(NUM_SPFIL,1),FMT='(A)') filnam;

    OUTPUT filnam;(/'   READ INPUT ENERGY SPECTRUM FROM: ',A);
    call replace_env(filnam);
    OPEN(9,file=filnam,STATUS='OLD');
    READ(9,'(A)') spec_title;
    READ(9,*) nensrc,ensrcd(0),mode;
    enmin = ensrcd(0);
    IF(NENSRC > $NENSRC) [
       OUTPUT NENSRC,$NENSRC;
       (//' ********** Asked for too many energy bins******'/
       ' NENSRC =',I4, ' reduced to max allowed =',I4/1x,30('*')//);
       NENSRC = $NENSRC;
    ]
    READ(9,*)(ENSRCD(IB),SRCPDF(IB),IB=1,NENSRC);
    CLOSE(UNIT=9);
    OUTPUT NENSRC; ('    HAVE READ',I5,' INPUT ENERGY BINS FROM FILE');
    IF(MODE=0)[OUTPUT;('      Counts/bin assumed');]
    ELSEIF(MODE = 1) [
        OUTPUT;('      Counts/MeV assumed');
        DO IB=1,NENSRC[SRCPDF(IB) = SRCPDF(IB)*(ENSRCD(IB)-ENSRCD(IB-1));]
    ] "end mode = 1 block"
    ELSE [OUTPUT MODE;(///'*****MODE not 0 or 1 in spectrum file? **'
         /80('*') //);]

    EIN=ENSRCD(NENSRC);"SET TO MAX ENERGY FOR SOME CHECKS"
    OUTPUT ENMIN,EIN;('    ENERGY RANGES FROM',F10.3,' MeV TO',F12.3,' MeV');
    enmax = ein;

    IVAL = IVAL +1;
    NUM_SPIOUSP = IVAL;
    VALUES_SOUGHT(IVAL)='SPEC IOUTSP';
    TYPE(IVAL)=3;
    DEFAULT(IVAL)=0;
    ALLOWED_INPUTS(IVAL,0)='NONE';
    ALLOWED_INPUTS(IVAL,1)='INCLUDE';
    $GET_INPUT(NUM_SPIOUSP);
    IOUTSP=VALUE(NUM_SPIOUSP,1);
]
OUTPUT;(' ');
RETURN;   "NORMAL RETURN"

ENTRY ENSRC1;
"==========="

IF( is_mono ) return;

" Rewritten by IK: to guarantee that the input spectrum is exactly sampled,"
"                  The alias sampling technique is employed
"                  needs prepare_alias_sampling which is in nrcaux.mortran

" Check that enmin < ensrcd(1) "
IF( enmin >= ensrcd(1) ) [
    write(6,*) ' Bad spectrum: minimum energy is > top of first bin! ';
    stop;
]

call prepare_alias_sampling(nensrc,srcpdf,srcpdf_at,srcbin_at);

RETURN;

ENTRY ENSRCO;
"==========="

IF( is_mono ) [
  write(iout,'(18x,a,f9.3,a)') 'Mono-energy: ',Emono,' MeV';
  return;
]
IF(enflag = 1) [ "this is a phase space input, print nothing here" return;]
   WRITE(IOUT,105) FILNAM(:lnblnk1(FILNAM)),SPEC_TITLE(:lnblnk1(SPEC_TITLE));
105 FORMAT(18x,' Spectrum file and title:'/18x,A/18x,A);
sume1 = 0; sume = 0;
DO ib=1,nensrc[
  sume = sume + srcpdf(ib);
  sume1 = sume1 + srcpdf(ib)*(ensrcd(ib)+ensrcd(ib-1))/2;
]
WRITE(IOUT,'(20x,a,f10.4)') ' Average spectrum energy is ',sume1/sume;
IF(IOUTSP.EQ.1)[
   IF(MODE=0)[WRITE(IOUT,'(20x,'' Counts/bin assumed'')');]
   ELSE   [WRITE(IOUT,'(20x,'' Counts/MeV assumed'')');]
   WRITE(IOUT,110)NENSRC,enmin;
   DO IB=1,NENSRC[
     WRITE(IOUT,120)IB,ensrcd(ib),srcpdf(ib),srcpdf_at(ib),srcbin_at(ib);
   ]
]
RETURN;


ENTRY ENSRCH(ENIN);
"================"

IF( is_mono ) [ enin = Emono; return; ]

enin = alias_sample(nensrc,ensrcd,srcpdf_at,srcbin_at);
RETURN;

ENTRY ENSRC_EMAX(Ek_max);

IF( is_mono ) [ Ek_max = Emono; ]
ELSE [ Ek_max = ensrcd(nensrc); ]
return;


100   FORMAT(' ',I1);
102   FORMAT(' ',G14.7);
110   FORMAT(' ',T20,'Energy dist''n, # of incident energy bins:',T60,I3/
             T20,' Lower energy of first bin:',T60,F7.3,' (MeV)'/
             ' ',T20,'bin    kinetic energy     probability  at prob   at bin');
120   FORMAT(' ',T20,I3,T28,F7.3,T45,1PE10.3,T60,0PF7.4,T70,i4);

END; "end subroutine ensrc"


%C80
"#############################################################################"
"                                                                             "
"  EGSnrc spherical geometry input subroutine                                 "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Joanne Treurniet, 1999                                    "
"                                                                             "
"  Contributors:    Iwan Kawrakow                                             "
"                   Ernesto Mainegra-Hing                                     "
"                                                                             "
"#############################################################################"


%I4
%C80
%Q1
;"******************************************************************************
"
"                              *******************
"                              *                 *
"                              * geomsph.mortran *
"                              *                 *
"                              *******************
"
"
"   THIS SUBROUTINE IS USED TO DO ALL THE WORK ASSOCIATED WITH HAVING
"   A SPHERICAL GEOMETRY INPUT.
"
"       VERSION 1.1       J. Treurniet               05/99
"
"
"===============================================================================
"
"   CONES NOW SUPPORTED. SINCE 90 DEGREES CONE IS NEEDED BY THE CONE GEOMETRY
"   CHECKING MACRO, IF THE USER DOES NOT INCLUDE THE 90 DEGREES CONE, THE NEXT
"   ANGLE GREATER THAN 90 IS AUTOMATICALLY FORCED TO BE 90.
"
"   ANGLES AND RADII CAN BE ENTERED INDIVIDUALLY OR IN GROUPS.
"
"
"       VERSION 2.0      E. Mainegra-Hing           10/10/2003
"
"*******************************************************************************
"*******************************************************************************
"* (1)  *  Integers between parentheses show the value of the internal         *
"*      *  variable corresponding to this input. These are for reference only. *
"*      *                                                                      *
"* (M)  *  The 'M' indicates that the variable at hand has multiple            *
"*      *  input capability.  One may assign an arbitrary number of            *
"*      *  values to that input.                                               *
"*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
"*      *                                                                      *
"* (M2) *  The 'M' with an integer beside it means that the variable           *
"*      *  has that number of inputs.                                          *
"*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
"*      *                                                                      *
"* (I)  *  Regular (one number) integer input value.                           *
"*      *  E.g.:  SOURCE NUMBER= 0                                             *
"*      *                                                                      *
"* (R)  *  Regular (one number) real input value.                              *
"*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
"*      *                                                                      *
"* (C)  *  Regular (one string) character input value(no ; or #).              *
"*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
"*      *                                                                      *
"*******************************************************************************
;
"*******************************************************************************
"                       SPHERICAL GEOMETRY INPUT
"                       **************************
"*******************************************************************************
"
" GEOMSPH DELIMETERS:   :start geometrical inputs:
"                       :stop geometrical inputs:
"
"
"  NUMBER OF CONES        (M)   number of cones (individual or by group)
"                               If omitted or ZERO, pure spherical geometry
"                               assumed.
"
"  ANGLES                 (M)   ANGLES defining the geometry (reals)
"                               No needed in pure spherical geometries.
"
"                               For group input there must be as many entries
"                               as for the NUMBER OF CONES, i.e. :
"                               NCON1,NCON2,...,NCONn
"                               DANG1,DANG2,...,DANGn
"
"                               For individual input, ncones must be equal
"                               to the number of entries, i.e.:
"                               ncones
"                               DANG1, DANG2,...,DANGncones
"
"  NUMBER OF SPHERES      (M)   number of spheres (individual or by group)
"
"                               For individual inputs, number of spheres
"                               can be omitted
"
"
"  RADII                  (M)   radii of spheres defining the geometry (reals)
"
"                               For group input there must be as many entries
"                               as for the NUMBER OF SPHERES, i.e. :
"                               NSPH1,NSPH2,...,NSPHn
"                               DRAD1,DRAD2,...,DRADn
"
"  CAVITY ZONES           (M)   geometrical zone numbers in the cavity (reals)
"
"-------------------------------------------------------------------------------
"  MATERIAL INPUT
"  **************
"
"  MEDIA              (M)   material name which must match that in the
"                           pegs4 data set EXACTLY, including case.
"                           24 characters max per medium, ended by , or ;
"
"  MEDNUM                 (M)   the material number (integers)
"                               (MEDNUM=0 => vacuum)
"  START REGION           (M)   initial geometrical zone(irl) (integers) for
"                               this medium [NREGLO]
"  STOP REGION            (M)   final geometrical zone(irl) (integers) for
"                               this medium.[NREGHI]
"                               ( >NREGLO to input more than one zone)
"                               DEFAULTS:   MEDNUM=0 FOR REGION=1 (i.e. VACUUM)
"                                           MEDNUM=1 FOR REGION=2,NREG
"
"                         These inputs should be thought of as triplets of
"                         MEDNUM,START and STOP REGIONs     which are used
"                         to specify the medium numbers for all regions where
"                         the medium is not the default (medium 1).
"
"***************************************************************************"
"
;
SUBROUTINE GEOMSPH;
                                "ERROR_FLAG is now in common block"

"DECLARATION OF COMIN BLOCKS
"***************************
;COMIN/GEOM,IODAT2,MEDIA,MISC,SCORE,SOURCE,USER,RANDOM,UPHIOT,GetInput/;

"***************************************************************************"
"*                   Variables used to declare inputs                      *"
"***************************************************************************"

INTEGER "NMED, "MEDNUM, NREGLO, NREGHI;               "material input"

"***************************************************************************"
"*                Variables used to point to the inputs                    *"
"***************************************************************************"
"Spherical geometry input"
INTEGER NUM_CONES,
        NUM_SPHERES,
        NUM_ANGLES,  "missing in original geomsph.mortran"
        NUM_RADII,
        NUM_RSPH,
        NUM_CAVREG;

"Material Input"
INTEGER NUM_MEDIA,
        NUM_MEDNUM,
        NUM_NREGLO,
        NUM_NREGHI;
"---------------------------------------------------------------------------"
INTEGER ERR;  "$inputfile.errors file"
INTEGER LNBLNK,SLENGHT;
INTEGER I,J,K,PLN,COUNT;
INTEGER IX, IZ, REGNUM;
REAL    ADDING;

"---------------------------------------------------------------------------"
$INTEGER NCONE, NCONES(0:$MAXCANGLE), IC;
$INTEGER NRADIUS(0:$MAXRADII);
$REAL    ANGRAD;
logical  NoNinety;
                                    "LOCAL VARIABLE DECLARATION"
                                                  "EMH,01/11/19"
"---------------------------------------------------------------------------"
" This must stay I and not be changed to IVAL.  Doing that means that
" the previous NVALUE(IVAL) will be used so multiple inputs aren't read.
I=0;  "initialize index number of the value_sought"
ERR=15;  "output errors to unit # 15"

ERROR_FLAG=0;   "Initialization of bad input flag"

"                      SPHERICAL GEOMETRY INPUT"
"                      **************************"

DELIMETER = 'GEOMETRICAL INPUTS';

IVAL=IVAL+1;
NUM_CONES = IVAL;
VALUES_SOUGHT(IVAL)='NUMBER OF CONES';
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
"VALUE_MAX(IVAL)=$MAXCDOSE;"
VALUE_MAX(IVAL)=1000000000;
DEFAULT(IVAL)=1;
$GET_INPUT(IVAL);
                           "it's more natural to enter the number of cones"
                           "and get the subtended regions afterwards.     "
                           "                              EMH, 01/11/19   "

ALPHA(0) = 0.0;
NCONE = 0;"get total number of cones"
DO I = 1, NVALUE(NUM_CONES)[
   NCONES(I) = VALUE(NUM_CONES,I);
   NCONE     = NCONE + NCONES(I);
   IF( NCONE > $MAXCANGLE) [
    OUTPUT NCONE, $MAXCANGLE;
    (///' Number of cones,',I10,' is greater than $MAXCANGLE=',I10/
        '  You must change the definition of $MAXCANGLE in the user code'/
        '      and recompile'///);
    STOP;
   ]
]
OUTPUT NCONE;(/'NUMBER OF ANGLES TO BE INPUT NCONE = ',I5);
NC = NCONE + 1;"number of conical sections = total number of cones + 1"




IF(NC = 1)["PURE SPHERICAL GEOMETRY"
    ALPHA(1)=180.0; "NONE CONES"
    NPLAN1=1;NPLAN2=2;
]
ELSEIF(NC = 2)["HEMISPHERICAL GEOMETRY"
    ALPHA(1)=90.0; "ONE CONE ONLY AT 90 DEGREES"
    NPLAN1=1;NPLAN2=2;
]
ELSEIF(NC > 2)["USER DEFINES NC-2 CONES"
    IVAL = IVAL + 1;
    NUM_ANGLE = IVAL;
    VALUES_SOUGHT(IVAL)='ANGLES';
    TYPE(IVAL)=1;
    VALUE_MIN(IVAL)=0.0;
    VALUE_MAX(IVAL)=180.0;
    $GET_INPUT(NUM_ANGLE);
    IF ( NVALUE(NUM_ANGLE).EQ.NVALUE(NUM_CONES) )
    [                                   "group input: NCON1,NCON2,...,NCONn"
      NCONES(0) = 0; K = 0;                          "DANG1,DANG2,...,DANGn"
      DO I = 1, NVALUE(NUM_CONES)[
         K = K + NCONES(I-1);
         DO J = 1,NCONES(I)[
            ALPHA(K+J) = ALPHA(K+J-1) + VALUE(NUM_ANGLE,I);
            "OUTPUT K+J, ALPHA(K+J);     "
            "(' CONE OPENING ANGLE # ',I3,': ',F8.4);   "
         ]
      ]
    ]
    ELSEIF ( NVALUE(NUM_ANGLE).EQ.NCONE)
    [                               "individual input: NCONE"
      DO I=1,NCONE [                "                  ANG1,ANG2,...,ANGncone"
         ALPHA(I)=VALUE(NUM_ANGLE,I);
         "OUTPUT I, ALPHA(I);     "
         "(' CONE OPENING ANGLE # ',I3,': ',F8.4);   "
      ]
    ]
    ELSE [ "input error for cones"
      OUTPUT;
      (/' ***** ERROR IN GEOMETRICAL INPUT FOR CONES *****'/
        ' MISMATCH BETWEEN NUMBER OF CONES AND NUMBER OF ANGULAR ENTRIES'/
        ' CHECK THIS AND TRY AGAIN !!!'//
        ' PROGRAM STOPPED.');
      STOP;
    ]

    NoNinety = .true.;"assume initially 90 degree not included"
    IC=0; "LOOP INDEX"
    LOOP[ "CHECK IF USER PUT IN 90 DEGREE CONE"
        IC=IC+1;
        IF(ALPHA(IC) = 90.0)["user included 90 degree, great!!!"
            NPLAN1=IC;NPLAN2=NPLAN1+1;
            NoNinety = .false.;
            OUTPUT;
            (/' *** WARNING ***. 90 DEGREE CONE INPUT',
              ' BY USER. JUST MAKING THE POINT.'/);
            EXIT;
        ]
    ]UNTIL (IC = NCONE);

    IF ( NoNinety )[
       IF ( NC > $MAXCANGLE )["remeber NC = NCONE + 1"
            OUTPUT;
            (/' ***** ERROR IN GEOMETRICAL INPUT FOR CONES *****'/
              ' ABOUT TO ADD 90 DEGREES, BUT DIMENSIONS EXCEEDED'/
              ' MAXIMUM NUMBER OF ANGLES.'//
              ' PROGRAM STOPPED.');
              STOP;
       ]
       IC=NCONE; "LOOP INDEX"
       LOOP[ "PUT IN THE 90 DEGREE CONE"
           IF(ALPHA(IC) > 90.0)["SHIFT UPWARDS
              ALPHA(IC+1)=ALPHA(IC);
           ]
           ELSE[ "PUT IN THE 90 DEGREE CONE RIGHT HERE"
              ALPHA(IC+1)=90.0;
              NPLAN1=IC+1;NPLAN2=NPLAN1+1;
              NCONE = NCONE + 1; NC = NCONE + 1;
              OUTPUT NPLAN1;(' FORCING ANGLE #',I3,' TO BE 90 DEGREES');
              EXIT;
           ]
           IC=IC-1;
       ]UNTIL (IC = 0);

       IF(IC = 0)[ "FELL THROUGH THE LOOP => ALL INPUT CONES > 90"
          ALPHA(1)=90.0;
          NPLAN1=1;NPLAN2=2;
          OUTPUT NPLAN1;(' FORCING ANGLE #',I3,' TO BE 90 DEGREES');
       ];
    ];
] "END OF ANGLE INPUT FOR NC>2"
$SKIP-LINE;

DO IC=1,NCONE[
 IF ( ALPHA(IC) > 180.0 )[
    OUTPUT;
    (/' ***** ERROR IN GEOMETRICAL INPUT FOR CONES *****'/
      ' POLAR ANGLES CAN NOT BE GREATER THAN 180 DEGREES'//
      ' PROGRAM STOPPED.');
    STOP;
 ]
]

"0 and 180 degrees are the boundaries(i.e. 0th and NCth), "
"if those values are entered by input let's use them."
"ALPHA(0) =   0.0; set above"
IF ( ALPHA(1) = 0.0 )["shift down angle array since 0 degree is 0th element"
   DO IC=1,NCONE-1[ ALPHA(IC) = ALPHA(IC+1); ]
   NC = NCONE; NCONE = NCONE - 1;
]
IF ( ALPHA(NCONE) = 180.0 )["user did the work, let's use it !!!"
   NC = NCONE; NCONE = NCONE - 1;
]
"should put here a check whether NC > $MAXCANGLE!!!!!!!!!!!"
ALPHA(NC)= 180.0;"just in case it didn't fall in the IF"


IF(NC = 1)["PURE SPHERICAL GEOMETRY"
  OUTPUT;(' ==> This is a pure spherical geometry !');
  DO IC=0,NC["O and 180 degree included"
       ANGRAD=(PI/180.)*ALPHA(IC);
       COSALP(IC)=COS(ANGRAD);
       SINALP(IC)=SIN(ANGRAD);
       TANALP(IC)=TAN(ANGRAD);
       TANAL2(IC)=TANALP(IC)**2;
  ]
]
ELSEIF(NC > 1)[
    OUTPUT;(' CONE OPENING ANGLES:');
    OUTPUT (ALPHA(IC),IC=1,NC);(8F10.4);
    NPLAN2=NPLAN1+1;
    DO IC=0,NC["O and 180 degree included"
       ANGRAD=(PI/180.)*ALPHA(IC);
       COSALP(IC)=COS(ANGRAD);
       SINALP(IC)=SIN(ANGRAD);
       TANALP(IC)=TAN(ANGRAD);
       TANAL2(IC)=TANALP(IC)**2;
    ]
    $SKIP-LINE;
]
OUTPUT NC;(/'NUMBER OF CONICAL REGIONS NC = ',I5);
OUTPUT NPLAN1;(/'REGION WHERE 90 deg IS UPPER CONE :',I5);


IVAL=IVAL+1;
NUM_RADII = IVAL;
VALUES_SOUGHT(IVAL)='NUMBER OF SPHERES';
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=1000000000;
"VALUE_MAX(IVAL)=$MAXRADII;"
DEFAULT(IVAL)=$MAXRADII;
$GET_INPUT(NUM_RADII);

NR = 0;"get total number of spheres"
DO I = 1, NVALUE(NUM_RADII)[
   NRADIUS(I) = VALUE(NUM_RADII,I);
   NR         = NR + NRADIUS(I);
   IF( NR > $MAXRADII) [
     OUTPUT NR, $MAXRADII;
     (///' Number of spheres,',I10,' is greater than $MAXRADII=',I10/
         '  You must change the definition of $MAXRADII in the user code'/
         '      and recompile'///);
     STOP;
   ]
]
OUTPUT NR;(I6,' spheres in the problem ...');

IVAL = IVAL + 1;
NUM_RSPH = IVAL;
VALUES_SOUGHT(IVAL)='RADII';
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=0.0000001;
VALUE_MAX(IVAL)=999999.9;
DEFAULT(IVAL)=1.0;
$GET_INPUT(NUM_RSPH);
IF (NR = 0) [
 NR = NVALUE(NUM_RSPH);
 OUTPUT NR;(I6,' spheres in the problem ...');
]


RSPH(0) = 0.0;

IF ( NVALUE(NUM_RADII).EQ.NVALUE(NUM_RSPH) )
[                                   "group input: NRAD1,NCON2,...,NCONn"
      NRADIUS(0) = 0; K = 0;                     "DRAD1,DRAD2,...,DRADn"
      DO I = 1, NVALUE(NUM_RADII)[
         K = K + NRADIUS(I-1);
         DO J = 1,NRADIUS(I)[
            RSPH(K+J) = RSPH(K+J-1) + VALUE(NUM_RSPH,I);
            RSPH2(K+J)= RSPH(K+J)**2;
         ]
      ]
]
ELSEIF ( NVALUE(NUM_RSPH).EQ.NR)
[                               "individual input: NR"
      DO I=1,NR [                "              RAD1,RAD2,...,RADnr"
         RSPH(I) = VALUE(NUM_RSPH,I);
         RSPH2(I)= RSPH(I)**2;
      ]
]
ELSE [ "input error for spheres"
      OUTPUT;
      (/' ***** ERROR IN GEOMETRICAL INPUT FOR SPHERES *****'/
        ' MISMATCH BETWEEN NUMBER OF SPHERES AND NUMBER OF RADIAL ENTRIES'/
        ' CHECK THIS AND TRY AGAIN !!!'//
        ' PROGRAM STOPPED.');
      STOP;
]

$SKIP-LINE;
I = MIN(100,NR);
DO IX=1,I [
    "RSPH(IX)=VALUE(NUM_RSPH,IX);"
    "RSPH2(IX)=RSPH(IX)**2;"
    IF(RSPH(IX)=0.0)[
        OUTPUT;(' IMPROPER INPUT. RADIUS OF 0.0 NOT ALLOWED'/);
    ]
    OUTPUT IX,RSPH(IX);(' RING RADIUS #',I6,':',T60,F12.6,' cms');
]

NREG=NR*NC+1;

"define cavity zones"

IVAL = IVAL + 1;
NUM_CAVREG = IVAL;
VALUES_SOUGHT(IVAL)='CAVITY ZONES';
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=999999;
DEFAULT(IVAL)=1;
$GET_INPUT(IVAL);
numcavreg = NVALUE(IVAL);
OUTPUT numcavreg;(' number of cavity regions: ', I4 );

DO IX=1,numcavreg [ cavreg(IX) = VALUE(IVAL,IX); ]

"CHECK THAT THE NUMBER OF CAVITY ZONES DOES NOT EXCEED ITS BOUNDS"
IF(numcavreg.LE.0)["no cavity defined, just dose in all the regions desired"
    DO I=1,NREG[cavreg(I)=0;]
    OUTPUT; (' **** no cavity regions defined ****');
]
ELSEIF(numcavreg.GE.NREG)[
    "IF IT DOES, REVERT TO THE STANDARD CHAMBER CONFIGURATION"
    numcavreg=1;cavreg(1)=3;DO I=2,NREG[cavreg(I)=0;]
    OUTPUT;
    (' TOO MANY CAVITY ZONES, REVERTING TO STANDARD CHAMBER');
]
ELSEIF(numcavreg.EQ.(NREG-1))[
    "WHOLE GEOMETRY IS A CAVITY ZONE, SCORE EVERYWHERE"
    OUTPUT; (' WHOLE GEOMETRY IS A CAVITY ZONE, SCORING EVERYWHERE');
    numcavreg=NREG-1;DO I=2,NREG[cavreg(I-1)=I;]
]
ELSE[ "check cavity regions are within the right limits"
    I=0;
    LOOP[
        I=I+1;
        IF((cavreg(I).LE.1).OR.(cavreg(I).GT.NREG))["wrong cavity region number"
            OUTPUT cavreg(i);
            (' wrong cavity region number: ', I5 /
             ' INAPPROPRIATE CAVITY ZONES, REVERTING TO STANDARD CHAMBER');
            "CHECK FOR INAPPROPRIATE INPUT"
            "REVERT TO THE STANDARD CHAMBER IF THIS HAPPENS"
            numcavreg=1;cavreg(1)=3;DO I=2,NREG[cavreg(I)=0;]
            EXIT; "THEN EXIT THE LOOP"
        ]
        ELSE[
           OUTPUT i,cavreg(i);
           ('    ===> cavity region # ', I5, ' is region # ', I5);
        ]

    ]WHILE(I.LT.numcavreg);
] "CAVITY ZONES ARE DEFINED"


"                               MATERIAL INPUT
"                               **************
IVAL = IVAL + 1;
NUM_MEDIA = IVAL;
VALUES_SOUGHT(IVAL)='MEDIA';
TYPE(IVAL)=2;
$GET_INPUT(IVAL); "get the number of media"
NMED=NVALUE(IVAL);
DO I=1,NMED [
   SLENGHT=LNBLNK(CHAR_VALUE(NUM_MEDIA,I));
   READ (CHAR_VALUE(NUM_MEDIA,I),FMT='(24A1)') (MEDIA(J,I),J=1,SLENGHT);
   IF (SLENGHT<24) [DO J=SLENGHT+1, 24 [MEDIA(J,I)=' ';]]
   OUTPUT I,(MEDIA(J,I),J=1,24);(' MEDIUM #',I1,':',T55,24A1);
]

IF((NMED.LT.1).OR.(NMED.GT.$MXMED)) [
    NMED=1;
    OUTPUT;
    (' ***** NO MEDIUM OR TOO MANY MEDIA. RESET TO ONE MEDIUM INPUT. *****'/);
]

$SKIP-LINE;

IVAL = IVAL + 1;
NUM_MEDNUM = IVAL;
VALUES_SOUGHT(IVAL)='MEDNUM';
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=NMED;
DEFAULT(IVAL)=1;
$GET_INPUT(NUM_MEDNUM);

IVAL = IVAL + 1;
NUM_NREGLO = IVAL;
VALUES_SOUGHT(IVAL)='START REGION';
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=NREG;
DEFAULT(IVAL)=1;
$GET_INPUT(NUM_NREGLO);

IVAL = IVAL + 1;
NUM_NREGHI = IVAL;
VALUES_SOUGHT(IVAL)='STOP REGION';
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=NREG;
DEFAULT(IVAL)=1;
$GET_INPUT(NUM_NREGHI);


OUTPUT;(/' *** INPUT CARD M3 ***');
MED(1)=0;
DO I=2,NREG [MED(I)=1;]  "defaults"
OUTPUT NREG;(/' # OF GEOMETRICAL ZONES = ',T60,I12);
WRITE (*,*) 'REGION(  1) = MATERIAL( 0) (VACUUM)';

IF ((NVALUE(NUM_NREGLO)~=NVALUE(NUM_MEDNUM))|
    (NVALUE(NUM_NREGHI)~=NVALUE(NUM_MEDNUM))) [
   WRITE(ERR,*)'**************ERROR**************';
   WRITE(ERR,*)'MEDNUM HAS      ',NVALUE(NUM_MEDNUM),' VALUES';
   WRITE(ERR,*)'START REGION HAS',NVALUE(NUM_NREGLO),' VALUES';
   WRITE(ERR,*)'STOP REGION HAS ',NVALUE(NUM_NREGHI),' VALUES';
   WRITE(ERR,*)'>>>> THEY MUST ALL HAVE THE SAME NUMBER OF VALUES';
   ERROR_FLAG=1;
   RETURN;
]
"In the following, we allow for vacuum input"
IF (VALUE(NUM_MEDNUM,1) >= 0) [
   DO I=1, NVALUE(NUM_MEDNUM) [
      MEDNUM=VALUE(NUM_MEDNUM,I);
      NREGLO=VALUE(NUM_NREGLO,I);
      NREGHI=VALUE(NUM_NREGHI,I);
      IF (NREGHI<=NREGLO) [
         MED(NREGLO)=MEDNUM;
         OUTPUT NREGLO,MEDNUM;(' REGION(',I3,') = MATERIAL(',I2,')');
      ]
      ELSE [
         DO K=NREGLO,NREGHI [MED(K)=MEDNUM;]
         OUTPUT NREGLO,NREGHI,MEDNUM;
         (' REGION(',I3,') TO REGION(',I3,') = MATERIAL(',I2,')');
      ]
   ] "end do I"
] "end IF ~=0"


"For error checking, get all geomsph inputs"
"$GET_INPUTS(NUM_CONES,NUM_NREGHI);"

$SKIP-LINE;

END;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc parameter input functions                                           "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Aaron Merovitz, 1998                                      "
"                   Dave Rogers, 1998                                         "
"                   Iwan Kawrakow, 1998                                       "
"                                                                             "
"  Contributors:    Ernesto Mainegra-Hing                                     "
"                   Blake Walters                                             "
"                   Frederic Tessier                                          "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Iwan Kawrakow, 1998, version 2.0, major rework:                            "
"                                                                             "
"  - Input values taken only if between specified delimiters (prior this      "
"    change, the first VALUES_SOUGHT found was taken, even if it was not      "
"    between the specified delimiters).                                       "
"                                                                             "
"  - Changed argument list to a common block GetInput defined in egs4.macros  "
"    to avoid memory use explosion.                                           "
"                                                                             "
"  - Eliminated initial loop checking for presence of values sought as it is  "
"    not necessary.                                                           "
"                                                                             "
"  - Introduced macros for handling strings (skipping blanks and comments,    "
"    changing to upper case, etc.)                                            "
"                                                                             "
"  - Eliminated string input bug: strings were always converted to upper case "
"                                                                             "
"  - Changed definition of strings to character*$MACRO where $MACRO has a     "
"    certain value that can be be defined in the user code if longer strings  "
"    are required.                                                            "
"                                                                             "
"                                                                             "
"  Iwan Kawrakow, 1999, version 2.1, major rework:                            "
"                                                                             "
"  - Missing or misspelled end delimiter together with a missing value sought  "
"    caused the routine to terminate. It now prints an error message and      "
"    continues to look for additional input.                                  "
"                                                                             "
"  - Introduced an array ERROR_FLAGS where the input status of each of the    "
"    attempted inputs is stored.                                              "
"                                                                             "
"#############################################################################"


SUBROUTINE GET_INPUT;
"                                                                           "
"                                                                           "
" FUNCTION: Extracts the requested values_sought from input file and        "
"           returns it to the caller.                                       "
"                                                                           "
" USAGE   :      Inputs must have the general form:                         "
"              ***************************************                      "
"              * Value_sought=  Value(s)             *                      "
"              ***************************************                      "
"         e.g.:        MEDNUM= 0, 1, 2                                      "
"                      MEDIA= AIR700ICRU                                    "
"                      RAYLEIGH SCATTERING= on                              "
"                                                                           "
"***************************************************************************"
"           >>>>>>>>>>>     BASIC RULES AND FEATURES    <<<<<<<<<<<         "
"***************************************************************************"
"
"   Inputs are all in the format: name of value_sought= value
"   where the name of value_sought must match that expected by the
"   program and the = sign must have no blanks between it and value_sought.
"
"   The value_sought must be the first thing on a line but blanks are
"     allowed before it.
"
"   Various inputs are only sought between certain delimeter strings
"     which are defined below (eg :start I/O control: :stop I/O control:)
"     If not specified, the whole file is searched for a requested value_sought.
"     Delimeter strings are enclosed by colons.
"     Note that within delimeter strings, order of inputs does not matter.
"
"   If a requested quantity is not found, this is noted in $input.errors
"     and this file is printed at the end of the log file.
"
"   A semi-colon implies the end of input for this quantity but is
"     not mandatory.  However, this means they cannot be used in titles.
"   A # sign indicated everything else on the line is a comment (and
"     cannot be used in titles.
"   Case is not important in the names of the quantites.
"
"   Commas separate multiple values for a given quantity and a comma
"     at the end of a line implies there is more input on the next line.
"   Values can extend over as many lines as needed. Use commas to imply
"     there are more values on the next line.
"
"   Blank lines and blanks in general are ignored.
"
"   The maximum record length is 256 characters.
"
"
"*******************************************************************************
"* (1)  *  Integers between parentheses show the value of the internal         *
"*      *  variable corresponding to this input. These are for reference only. *
"*      *                                                                      *
"* (M)  *  The 'M' indicates that the variable at hand has multiple            *
"*      *  input capability.  One may assign an arbitrary number of            *
"*      *  values to that input.                                               *
"*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
"*      *                                                                      *
"* (M2) *  The 'M' with an integer beside it means that the variable           *
"*      *  has that number of inputs.                                          *
"*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
"*      *                                                                      *
"* (I)  *  Regular (one number) integer input value.                           *
"*      *  E.g.:  SOURCE NUMBER= 0                                             *
"*      *                                                                      *
"* (R)  *  Regular (one number) real input value.                              *
"*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
"*      *                                                                      *
"* (C)  *  Regular (one string) character input value(no ; or #).              *
"*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
"*      *                                                                      *
"*******************************************************************************
"                                                                           "
"                                                                           "
" FEATURES: If the amount of values needed for a particular values_sought   "
"           is known and passed throught NVALUE(I), the subroutine will     "
"           check that the number of inputs correspond.  Otherwise,         "
"           NVALUE(I) will return the # of inputs found.                    "
"                                                                           "
"           For any integer or real (TYPE=0 or 1), get_inputs will check    "
"           that the numerical value input is between VALUE_MIN and         "
"           VALUE_MAX.  If not, it sets this value to the DEFAULT.          "
"                                                                           "
"           Writing in the input file can be upper case or lower case.      "
"           However, all FORTRAN >MUST< be programmed in upper case.        "
"              Changed the above: Can now be upper or lower case            "
"                                 IK, Dec. 1998                             "
"                                                                           "
"           For clarity, inputs can be terminated with a semicolon(;).      "
"           This is by no means necessary.                                  "
"                                                                           "
"***************************************************************************"
"          >>>>>>>>>>> IMPLEMENTING INTO NEW USER CODES <<<<<<<<<<<         "
"***************************************************************************"
"                                                                           "
"                   **** DECLARE YOUR INPUTS ****                           "
"                                                                           "
"    REALS AND INTEGERS (TYPE 0 AND 1)                                      "
"                                                                           "
"  I=I+1;                              <--index counter                     "
"  NUM_DRMIN=I;                        <--named pointer to the index num.   "
"  VALUES_SOUGHT(I)='DOSE RBOUND MIN'; <--name of variable                  "
"  NVALUE(I)=1;                        <--# of inputs(left out if not known)"
"  TYPE(I)=0;                          <--Type (0-3)                        "
"  VALUE_MIN(I)=0;                     <--Minimum value                     "
"  VALUE_MAX(I)=$MAXRADII-1;           <--Maximum value                     "
"  DEFAULT(I)=0;                       <--Default value                     "
"                                                                           "
"    CHARACTER INPUTS (TYPE 2)                                              "
"                                                                           "
"  I=I+1;
"  NUM_TITLE=I;
"  VALUES_SOUGHT(I)='TITLE';
"  TYPE(I)=2;
"  NVALUE(I)=1;                        <--left out if not known
"
"    ALLOWED INPTUS (TYPE 3)
"
"  I=I+1;
"  NUM_IWATCH=I;
"  VALUES_SOUGHT(I)='IWATCH';
"  NVALUE(I)=1;                        <--left out if not known
"  TYPE(I)=3;
"  ALLOWED_INPUTS(I,0)='OFF';
"  ALLOWED_INPUTS(I,1)='INTERACTIONS';
"  ALLOWED_INPUTS(I,2)='STEPS';
"  ALLOWED_INPUTS(I,3)='DEPOSITED';
"  ALLOWED_INPUTS(I,4)='GRAPH';
"                                                                           "
"                      **** STATE THE DELIMETER ****                        "
"                                                                           "
"            DELIMETER='TRANSPORT CONTROL'                                  "
"     OR     DELIMETER='NONE';                                              "
"                                                                           "
"  **** CALL THE SUBROUTINE WITH THE APPROPRIATE INDEX NUMBER OF THE ****   "
"                **** VALUES_SOUGHT(use NMIN and NMAX) ****                 "
"                                                                           "
"   The inputs are returned through CHAR_VALUE for character inputs         "
"   or VALUE for integers, reals and allowed inputs                         "
"                                                                           "
"---------------------------------------------------------------------------"


;IMPLICIT NONE;

COMIN/GetInput,EGS-IO/;

"***************************************************************************"
"*                   Variables used by the subroutine                      *"
"***************************************************************************"
CHARACTER*$STRING256 TEXT;      "Used to read in each line of the input file   "
CHARACTER*$STRING256 KEEPTEXT;  "Used to keep an old line of TEXT              "
CHARACTER*$STRING256 ORIGTEXT;  "The text without conversion to upper case     "
CHARACTER*$STRING256 TEXTPIECE;  "Used to read a piece of TEXT                 "
CHARACTER*$STRING80  DELIM_START;"Start of the delimeter                       "
CHARACTER*$STRING80  DELIM_END;  "End of the delimeter                         "
CHARACTER*$STRING32  VNAME;      "The name of the variable being extracted.    "
CHARACTER*$STRING32  VNAME1;     "The name of the variable being extracted.    "
$INTEGER       CURSOR;          "Used to read one of the TEXT letters          "
$INTEGER       IINDEX;          "Integer index for clipping string excess.     "
$INTEGER       iVNAME;          "Length of variable name string.               "
$INTEGER       IVAL;            "Value number of the value_sought              "
$INTEGER       UNITNUM;         "Unit number of the input file                 "
$INTEGER       ERR;             "Unit number of the error file                 "
$INTEGER       I,J,K,CHECK;     "Counters and checkers                         "
$INTEGER       LINE;            "Counts the eumber of lines                    "
$INTEGER       INT_VALUE;       "For printing integers                         "
$INTEGER       INT_VALUE_MIN;   "For printing integers                         "
$INTEGER       INT_VALUE_MAX;   "For printing integers                         "
$LOGICAL       ALLOWED;         "For evaluating an allowed_input               "
$LOGICAL       START_FOUND;     "Start of delimeter switch                     "
$INTEGER       ifound,length,lll,Kconvert;
$INTEGER       lnblnk1;"in house lnblnk function becuase not all compilers     "
                       "support this"
logical IDEBUG;
character*1 blank;
$INTEGER    error_level;
$INTEGER    the_level;
data blank/' '/;
data        error_level/1/;
save        error_level;
"---------------------------------------------------------------------------"

"Macro changing text string to upper case"
"REPLACE {$CONVERT-STRING-TO-UPPER-CASE(#);} WITH"
REPLACE {$CONVERT # TO UPPER CASE;} WITH
{;
   DO Kconvert=1, lnblnk1({P1}) [
         CURSOR=ICHAR({P1}(Kconvert:Kconvert));
         IF ((CURSOR.GE.97).AND.(CURSOR.LE.122)) [
            CURSOR=CURSOR-32;
            {P1}(Kconvert:Kconvert)=CHAR(CURSOR);
         ]
   ]
}
;

"Macro to skip leading blanks "
REPLACE {$SKIP LEADING BLANKS IN #;} WITH
{;
  length = len({P1});
  WHILE ( index({P1},blank) = 1 ) [
    IF( length >= 2 ) [ {P1}={P1}(2:); ] ELSE [ EXIT; ]
    length = length - 1;
  ]
}

"Macro that removes everything after comments "
REPLACE {$REMOVE EVERYTHING AFTER # IN #;} WITH
{
  ifound = INDEX({P2},{P1});
  IF( ifound > 1 ) [ {P2} = {P2}(1:ifound-1); ]
  ELSE [ IF( ifound = 1 ) [ {P2} = blank; ] ]
}

REPLACE {$STRING-OUTPUT(#);} WITH
{;
  length = lnblnk1({P1});
  IF( length > 0 ) [
    DO lll=1,length [ write(i_log,'(a1,$)') {P1}(lll:lll); ]
    write(i_log,*); "For a new line"
  ]
}

IDEBUG = .false.;   "set to .true. for debug outputs"
ERROR_FLAG = 0;
IF(IDEBUG) [OUTPUT NMIN,NMAX, $NMAX;(' Entering get_inputs seeking values',
   I5,' to', I5, '  with a max allowed of',I5);
]
IF (NMAX < NMIN | NMAX > $NMAX)[
  OUTPUT NMAX, NMIN, $NMAX;
  (//' Error entering get_inputs: Asked for values from',I5,' to',I5,
  '    with a max of',I5//' This implies a bug in the calling routine'/
  ' Fix it up and try again.  Stopping now.');
  STOP;
]
ERR=i_errors;    "inputfile.errors"
UNITNUM=i_input; "inputfile.egs4inp"
DELIM_START=':START '//DELIMETER(:lnblnk1(DELIMETER))//':';
DELIM_END=':STOP '//DELIMETER(:lnblnk1(DELIMETER))//':';
$CONVERT DELIM_START TO UPPER CASE; "This allows use of lower case letters"
$CONVERT DELIM_END TO UPPER CASE; "This allows use of lower case letters"

IF(IDEBUG) [OUTPUT DELIM_START,DELIM_END;(' start and stop delimeters are:'/
   A/A/);
]
"===================check that each value_sought is there===================="

DO I = NMIN, NMAX  [ "for each value_sought"
   REWIND (UNITNUM);   "Rewind the input file"
   LINE=0;             "reset line counter"
   CHECK=0;            "reset error checker"
   ERROR_FLAGS(I)=0;
   " Set to default for the case the input is not found "
   IF(TYPE(I) = 0 | TYPE(I) = 1) [ VALUE(I,1) = DEFAULT(I); ]
   IF(TYPE(I) = 3) [ VALUE(I,1) = 0; ]
   VNAME=VALUES_SOUGHT(I);
   iVNAME=lnblnk1(VNAME);
   IF( ivname < 1 )
   [
     IF( error_level > 0 ) [
       write(ERR,*) ' ======================= Warning ===================== ';
       write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!         ';
       write(ERR,*) ' ===================================================== ';
     ]
     ERROR_FLAG=1;
     ERROR_FLAGS(I)=1;
     goto :END-NMIN-NMAX-LOOP:;
   ]

   $CONVERT vname TO UPPER CASE; "This allows use of lower case letters"
   iindex = 0;
   IF (DELIMETER = 'NONE') [ start_found = .true.; ]
   ELSE                    [ start_found = .false.; ]
   WHILE ( iindex = 0 )  "Until the value sought is found"
   [
:GI25:
       CONTINUE;
       LINE=LINE+1;
       IF( start_found ) [
         READ(UNITNUM,END=:GI1003:,ERR=:GI1001:,FMT='(A256)') TEXT;
       ]
       ELSE [
         READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;
       ]
       "READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;"
       $SKIP LEADING BLANKS IN text;
       $REMOVE EVERYTHING AFTER '#' IN text;
       $REMOVE EVERYTHING AFTER ';' IN text;
       length = lnblnk1(TEXT);
       TEXT=TEXT(:length);
       origtext = text(:length);
       $CONVERT text TO UPPER CASE;
       IF( ~start_found ) [
         IF (INDEX(TEXT,DELIM_START) ~= 0 ) [ start_found = .true.; ]
         goto :GI25:;
       ]

       iindex=INDEX(TEXT,VNAME(:iVNAME));

       " Check for end delimeter "
       IF( DELIMETER~='NONE' )
       [
         IF (INDEX(TEXT,DELIM_END)~=0)
         [
             IF( error_level > 0 ) [
             WRITE (ERR,*) '***************ERROR***************';
             WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
                           '<<',' NOT FOUND';
             WRITE (ERR,*) 'END OF DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
             ]
             ERROR_FLAG=1;
             ERROR_FLAGS(I)=1;
             GOTO :END-NMIN-NMAX-LOOP:;
         ]
       ]
   ] "end while loop. If we pass this loop, we have the values_sought string "
     "in text"

   CHECK=0; "reset error checker"
   IF( idebug ) [
       write(i_log,*) ' ******* Found: ';
       write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
       write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
   ]

   " Set string pointer to position after vname string and/or "
   " leadinf equals                                           "
   IINDEX=IINDEX+iVNAME;
   TEXT=TEXT(IINDEX:); origtext=origtext(iindex:);
   IF( idebug ) [
       write(i_log,*) ' After removing vname: ';
       write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
       write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
   ]
   IINDEX=INDEX(TEXT,'=');
   IF (IINDEX.NE.0) [
      TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
   ]
   ELSE [
       IINDEX=INDEX(TEXT,':');
       IF (IINDEX.NE.0) [
          TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
       ]
   ]
   IF( idebug ) [
       write(i_log,*) ' After removing leading equals: ';
       write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
       write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
   ]

   "===============read the value(i)======================="
   IF ( (lnblnk1(TEXT)=0) | (lnblnk1(TEXT)=1) )
   [
        IF (vname(:ivname)='TITLE')
        [
           READ (UNITNUM,FMT='(A256)') TEXTPIECE;
           IF (lnblnk1(TEXTPIECE)~=0) [
              TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE));
              $SKIP LEADING BLANKS IN text;
              $SKIP LEADING BLANKS IN origtext;
              GOTO :TITLE-THERE:;
           ]
        ]
        IF( error_level > 0 ) [
        WRITE (ERR,*) '*************ERROR*************';
        WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
        WRITE (ERR,*) 'VALUE NOT THERE!!';
        ]
        ERROR_FLAG=1;
        ERROR_FLAGS(I)=1;
        RETURN;
   ]
:TITLE-THERE:
   CONTINUE;

   " Always check for default. The following sets the value to "
   " default(i) for a numeric input (type=1 or 2) and to 0 for "
   " an 'allowed input' => use only if one input is expected!  "
   iindex = index(text,'DEFAULT');
   IF( iindex ~= 0 )
   [                  "User requested a default value"
       IF( type(i) ~= 2 )
       [
           IF( type(i) ~= 3 ) [ VALUE(I,1)=DEFAULT(I); ]
           ELSE               [ VALUE(I,1)=0;          ]
           goto :END-NMIN-NMAX-LOOP:;
       ]
   ]

   IF ((TYPE(I) = 0)|(TYPE(I) = 1))
   [                                 "Read the number"
       IVAL=1;  "nvalue counter"
       IF( idebug )[write(i_log,*) ' *** Reading an integer or a real value! ';]
       LOOP
       [
           IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
           IF (lnblnk1(TEXT)=0) [
                 IF( error_level > 0 ) [
                 WRITE(ERR,*) '*************ERROR*************';
                 WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                 WRITE (ERR,*) 'VALUE NOT THERE!!';
                 ]
                 ERROR_FLAG=1;
                 ERROR_FLAGS(I)=1;
                 RETURN;
           ]
           READ(TEXT,END=:GI1010:,ERR=:GI1007:,FMT=*) VALUE(I,IVAL);
           IF( idebug ) [write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL);]
"==========================================================================="
"=================================Defaults=================================="

           IF ((VALUE(I,IVAL)>VALUE_MAX(I))|(VALUE(I,IVAL)<VALUE_MIN(I)))
           [
               IF (TYPE(I)=0)
               [
                    INT_VALUE=DEFAULT(I);
                    IF( error_level > 0 ) [
                    WRITE(ERR,*) '************WARNING************';
                    WRITE(ERR,:FMTA:) INT_VALUE,
                                 VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
                    ]
                    :FMTA: FORMAT ( 'Default= ',I9,' used for: ', A );
                    INT_VALUE=VALUE(I,IVAL);
                    INT_VALUE_MIN=VALUE_MIN(I);
                    INT_VALUE_MAX=VALUE_MAX(I);
                    IF( error_level > 0 ) [
                    WRITE(ERR,:FMTB:)
                        VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
                        INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX;
                    ]
                    :FMTB: FORMAT (A,'=', I9,' should be between ',
                                   I9,' and ', I9);
               ]
               IF (TYPE(I)=1)
               [
                    IF( error_level > 0 ) [
                    WRITE(ERR,*) '************WARNING************';
                    WRITE(ERR,:FMTC:) DEFAULT(I),
                                 VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
                    :FMTC: FORMAT ( 'Default= ',F12.6,' used for: ', A );
                    WRITE(ERR,:FMTD:)
                        VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
                        VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I);
                    :FMTD: FORMAT (A,'=', F12.6,' should be between ',
                                   G14.6,' and ', G14.6);
                    ]
               ]
               VALUE(I,IVAL)=DEFAULT(I);
           ] "end IF default"

           IF ( IVAL = NVALUE(I) ) EXIT; "Required inputs found"
"==========================================================================="
"=======================Move to next value, else exit======================="

           IF ((INDEX(TEXT,',')~=0)|(lnblnk1(TEXT)=0))
           [
               IF ( idebug ) [
                   write(i_log,*) ' A comma or a blank text found -> ';
                   write(i_log,*) ' searching for further input';
               ]
               TEXT=TEXT(INDEX(TEXT,',')+1:);
               WHILE (lnblnk1(TEXT)=0)
               [
                   IF ( idebug ) [
                     write(i_log,*) ' Empty text -> reading next line! ';
                   ]
                   LINE=LINE+1;
                   READ (UNITNUM,END=:GI1010:,ERR=:GI1007:,FMT='(A256)') TEXT;
                   $SKIP LEADING BLANKS IN text;
                   $REMOVE EVERYTHING AFTER '#' IN text;
                   $REMOVE EVERYTHING AFTER ';' IN text;
                   length = lnblnk1(TEXT);
                   TEXT=TEXT(:length);
                   origtext = text(:length);
                   $CONVERT text TO UPPER CASE;

                   "Check whether this line containes one of the strings sought"
                   DO K = 1 , NMAX
                   [
                       vname1 = VALUES_SOUGHT(K);
                       length = lnblnk1(vname1);
                       IF( length > 0 )
                       [
                           $SKIP LEADING BLANKS IN vname1;
                           $CONVERT vname1 TO UPPER CASE;
                           IF (INDEX(TEXT,vname1(:length))~=0)
                           [
                             IF( error_level > 0 ) [
                             WRITE(ERR,*) '************ERROR************';
                             WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                             WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
                                      '<--COMMA INDICATES ANOTHER INPUT';
                             WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
                                             TEXT(:lnblnk1(TEXT));
                             WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
                             ]
                             ERROR_FLAG=1;
                             ERROR_FLAGS(I)=1;
                           ]
                       ]
                   ]
                   IF( idebug ) [
                     write(i_log,*) ' Next line: ';
                     write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
                     write(i_log,'(a,$)') ' origtext: ';
                                          $STRING-OUTPUT(origtext);
                   ]
               ]
           ] "end if ~=0"
           ELSE [EXIT;]
           IVAL=IVAL+1;
       ] "end loop"
       IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
           IF( error_level > 0 ) [
           WRITE (ERR,*) '**************ERROR**************';
           WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
           WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)';
           WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
           ]
           ERROR_FLAG=1;
           ERROR_FLAGS(I)=1;
       ]
       ELSE [NVALUE(I)=IVAL;]
:GI1010:
       CONTINUE;
   ] "end IF TYPE"

"============================read the char_value(i)========================="

   IF ((TYPE(I) = 2) | (TYPE(I) = 3))
   [                                   "Read the string"
       IVAL=1;     "nvalue counter"
       IF( idebug ) [write(i_log,*) ' Trying to read a string! ';]
       LOOP
       [
           IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
           IF (lnblnk1(TEXT)=0) [
              IF( error_level > 0 ) [
              WRITE(ERR,*) '*************ERROR*************';
              WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
              WRITE (ERR,*) 'VALUE NOT THERE!!';
              ]
              ERROR_FLAG=1;
              ERROR_FLAGS(I)=1;
              RETURN;
           ]
           IF (vname(:ivname)='TITLE') [
              TEXTPIECE=origtext;
              GOTO :READ-IT:
           ]
           iindex = INDEX(origtext,',');
           IF ( iindex ~= 0 ) [ TEXTPIECE=origtext(:iindex-1); ]
           ELSE               [ TEXTPIECE=origtext;            ]
                      "The above is to avoid conversion to upper case"
                      "for e.g. media names                          "
           :READ-IT:
           CONTINUE;
           READ(TEXTPIECE,ERR=:GI1008:,FMT='(A256)') CHAR_VALUE(I,IVAL);
           $SKIP LEADING BLANKS IN CHAR_VALUE(I,IVAL);
           IF( idebug ) [
             write(i_log,*) ' Read the following char string: ';
             $STRING-OUTPUT(CHAR_VALUE(I,IVAL));
           ]
"===============================Allowed inputs=============================="
           IF (TYPE(I) = 3)
           [
              $CONVERT CHAR_VALUE(I,IVAL) TO UPPER CASE;
              ALLOWED=.FALSE.;
              DO K=0, $MXALINP [
                 vname1 = ALLOWED_INPUTS(I,K);
                 $SKIP LEADING BLANKS IN ALLOWED_INPUTS(I,K);
                 $CONVERT ALLOWED_INPUTS(I,K) TO UPPER CASE;
                 IF (ALLOWED_INPUTS(I,K)=CHAR_VALUE(I,IVAL)) [
                    ALLOWED=.TRUE.;
                    VALUE(I,IVAL)=K;
                    IF( idebug ) [
                      write(i_log,*) ' Found a allowed_value match ',k;
                    ]
                 ]
              ]
              IF (.NOT.ALLOWED) [
                 WRITE(ERR,*) '*************ERROR*************';
                 IF (IVAL~=1) [
                    WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                    WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY';
                 WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND VALUE';
                 ]
                 ELSE [
                    WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                    WRITE(ERR,*) 'INPUT-->',
                               CHAR_VALUE(I,IVAL)(:lnblnk1(CHAR_VALUE(I,IVAL))),
                               '<--NOT ALLOWED';
                    WRITE(ERR,*) 'OPTIONS ARE:';
                    WRITE(ERR,:FMT:)
                    (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_INPUTS(I,K))),
                     K=0,$MXALINP);
                 ]
                 :FMT: FORMAT(A40);
                 ERROR_FLAG=1;
                 ERROR_FLAGS(I)=1;
              ]
           ]
"=======================Move to next value, else exit======================="

           IF (vname(:ivname)='TITLE') [ EXIT; ]
           DO K=1,LEN(KEEPTEXT) [KEEPTEXT(K:K)=' ';]  "erase previous KEEPTEXT"
           KEEPTEXT(:lnblnk1(TEXT))=TEXT;
           iindex = INDEX(TEXT,',');
           IF ( iindex ~= 0 | lnblnk1(TEXT)=0 )
           [
               TEXT=TEXT(INDEX(TEXT,',')+1:);
               origtext=origtext(iindex+1:);
               WHILE (lnblnk1(TEXT)=0)
               [
                   LINE=LINE+1;
                   READ (UNITNUM,ERR=:GI1008:,FMT='(A256)') TEXT;
                   $SKIP LEADING BLANKS IN text;
                   $REMOVE EVERYTHING AFTER '#' IN text;
                   $REMOVE EVERYTHING AFTER ';' IN text;
                   length = lnblnk1(TEXT);
                   TEXT=TEXT(:length);
                   origtext = text(:length);
                   $CONVERT text TO UPPER CASE;

                   "Check whether this line containes one of the strings sought"
                   DO K = 1 , NMAX
                   [
                       vname1 = VALUES_SOUGHT(K);
                       length = lnblnk1(vname1);
                       IF( length > 0 )
                       [
                           $SKIP LEADING BLANKS IN vname1;
                           $CONVERT vname1 TO UPPER CASE;
                           IF (INDEX(TEXT,vname1(:length))~=0)
                           [
                             WRITE(ERR,*) '************ERROR************';
                             WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                             WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
                                      '<--COMMA INDICATES ANOTHER INPUT';
                             WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
                                             TEXT(:lnblnk1(TEXT));
                             WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
                             ERROR_FLAG=1;
                             ERROR_FLAGS(I)=1;
                           ]
                       ]
                   ]
               ]
           ] "end if ~=0"
           ELSE [EXIT;]
           IVAL=IVAL+1;
        ] "end loop"
        IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
           IF( error_level > 0 ) [
           WRITE (ERR,*) '*******************ERROR*******************';
           WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
           WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)';
           WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
           ]
           ERROR_FLAG=1;
           ERROR_FLAGS(I)=1;
        ]
        ELSE [NVALUE(I)=IVAL;]
   ]
"==========================================================================="
"==========================================================================="
   goto :END-NMIN-NMAX-LOOP:;

:GI1003:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '******************ERROR***********************';
        WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
        WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER';
        WRITE (ERR,*) 'VALUE SOUGHT: >>',
          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
        WRITE (ERR,*) 'END DELIMETER: >>',
          DELIM_END(:lnblnk1(DELIM_END)),'<<';
        ]
        ERROR_FLAG=1;
        ERROR_FLAGS(I)=1;
        goto :END-NMIN-NMAX-LOOP:;

:GI1004:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '******************ERROR***********************';
        WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
        WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER';
        WRITE (ERR,*) 'VALUE SOUGHT: >>',
          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
        WRITE (ERR,*) 'START DELIMETER: >>',
          DELIM_START(:lnblnk1(DELIM_START)),'<<';
        ]
        ERROR_FLAG=1;
        ERROR_FLAGS(I)=1;
        goto :END-NMIN-NMAX-LOOP:;

:GI1007:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '***************ERROR***************';
        IF (IVAL>1) [J=IVAL;] ELSE [J=1;]
        WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
        WRITE (ERR,*) 'LINE #',LINE;
        WRITE (ERR,*) 'COULD NOT READ THE VALUE!!';
        WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...';
        WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPUT?';
        ]
        ERROR_FLAG=1; "turn on the error flag"
        ERROR_FLAGS(I)=1; "turn on the error flag"
        GOTO :END-NMIN-NMAX-LOOP:;
:GI1008:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '***************ERROR***************';
        WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
        WRITE (ERR,*) 'LINE #',LINE;
        WRITE (ERR,*) 'COULD NOT READ THE STRING !!';
        ]
        ERROR_FLAG=1; "turn on the error flag"
        ERROR_FLAGS(I)=1; "turn on the error flag"

:END-NMIN-NMAX-LOOP:
    CONTINUE;
] "end do NMAX loop"
RETURN;

"**************if any errors**************"
:GI1001:
      WRITE (ERR,*) '***************ERROR***************';
      WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE;
      goto :GI1009:;
"the following is no longer used so comment it out"
":GI1002:
"      WRITE (ERR,*) '***************ERROR***************';
"      IF (CHECK=100) [
"         WRITE (ERR,*) 'DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
"         WRITE (ERR,*) 'WAS NOT FOUND';
"      ]
"      ELSE [
"         WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
"                       '<<',' NOT FOUND';
"      ]
"      WRITE (ERR,*) 'END OF FILE REACHED';
:GI1009:
      CONTINUE;  "exit if there is an error"
      ERROR_FLAG=1; "turn on the error flag"
      ERROR_FLAGS(I)=1; "turn on the error flag"
      RETURN;

entry get_input_set_error_level(the_level);
error_level = the_level;
return;
END;



%E   "get_inputs.mortran"
"*****************************************************************************
"
subroutine get_transport_parameter(ounit);
"
" is provided for use with the EGSnrc system. It reads all physics
" related parameters from the input file using the get_input routine.
" For a description for the format/conventions used in get_input,
" see the description at the beginning of this file.
" In order to use this routine, include transportp.macros BEFORE
" get_inputs.mortran via the configuration file.
" If the routine is called with ounit > 0, the transport parameter
" settings will be printid on unit ounit.
"
" Version 0.1           Iwan Kawrakow, January 1999
"
"******************************************************************************
"*******************************************************************************
"
"                         MC TRANSPORT PARAMETER
"                         **********************
"
"  All input associated with selection of various transport parameter
"  is not crucial for the execution as there are default values set.
"  Therefore, if some of the input options in this section are
"  missing/misspelled, this will be ignored and defualt parameter assumed
"  As the transport parameter input routine uses get_inputs, a lot
"  of error/warning messages may be produced on UNIT 15, though.
"  If you don't have the intention of changing default settings,
"  simply ignore the error messages.
"
"  The delimeters are
"
"               :start mc transport parameter:
"               :stop mc transport parameter:
"
"  You can change this by including the statement
"
"  REPLACE {$THE_DELIMETER} WITH {'WHATEVER-YOU-LIKE-THE-DELIMETER-TO-BE'}
"
"  in your input file.
"
"  Currently, the following options are available (case does not matter and
"             the internal variables are shown in [ ] brackets):
"
"       Global ECUT=     Global (in all regions) electron transport cut
"                        off energy (in MeV). If this imput is missing,
"                        AE(medium) will be used.
"                        [ ECUT ]
"       Global PCUT=     Global (in all regions) photon transport cut
"                        off energy (in MeV). If this imput is missing,
"                        AP(medium) will be used.
"                        [ PCUT ]
"       Global SMAX=     Global (in all regions) maximum step-size
"                        restriction for electron transport (in cm).
"                        If missing, no geometrical step-size restrictions
"                        will be employed. Note that if you use the default
"                        EGSnrc electron-step algorithm, no SMAX-restriction
"                        is necessary. Option is useful for transport in low
"                        density materials (air) when PRESTA behaviour is
"                        turned on (see below)
"                        [ SMAXIR ]
"       ESTEPE=          Maximum fractional energy loss per step.
"                        Note that this is a global option only, no
"                        region-by-region setting is possible. If missing,
"                        the defualt is 0.25 (25%).
"                        [ ESTEPE ]
"       XImax=           Maximum first elastic scattering moment per step.
"                        Default is 0.5, NEVER use value greater than 1 as
"                        this is beyond the range of MS data available.
"                        [ XIMAX ]
"       Boundary crossing algorithm=
"                        There are two selections possible: EXACT, means
"                        the algorithm will cross boundaries in a single
"                        scattering (SS) mode, the distance from a boundary
"                        at which the transition to SS mode is made is
"                        determined by 'Skin depth for BCA' (see below).
"                        The second option is PRESTA-I, if selected boundaries
"                        will be crossed a la PRESTA, i.e. with lateral
"                        correlations turned off and MS forced at boundaries.
"                        Default is EXACT.
"                        [ bca_algorithm, exact_bca ]
"       Skin depth for BCA=
"                        Determines the distance from a boundary (in elastic
"                        MFP) at which the algorithm will go into single
"                        scattering mode (if EXACT boundary crossing) or
"                        swith off lateral correlations (if PRESTA-I boundary
"                        crossing). Default value is 3 for EXACT or
"                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
"                        for a definition of BLCMIN). Note that if you choose
"                        EXACT boundary crossing and set Skin depth for BCA
"                        to a very large number (e.g. 1e10), the entire
"                        calculation will be in SS mode. If you choose
"                        PRESTA-I boundary crossing and make Skin depth for BCA
"                        large, you will get default EGS4 behavious (no PRESTA)
"                        [ skindepth_for_bca ]
"       Electron-step algorithm=
"                        PRESTA-II (the default), the name is
"                        used for historical reasons
"                        or PRESTA-I
"                        Determines the algorithm used to take into account
"                        lateral and longitudinal correlations in a
"                        condensed history step.
"                        [ transport_algorithm ]
"       Spin effects=    Off, On, default is On
"                        Turns off/on spin effects for electron elastic
"                        scattering. Spin On is ABSOLUTELY necessary for
"                        good backscattering calculations. Will make a
"                        difference even in `well conditioned' situations
"                        (e.g. depth dose curves for RTP energy range
"                        electrons).
"                        [ spin_effects ]
"       Brems angular sampling= Simple, KM, default is KM
"                        If Simple, use only the leading term of the Koch-Motz
"                        distribution to determine the emission angle of
"                        bremsstrahlung photons. If KM, complete
"                        modified Koch-Motz 2BS is used (modifications
"                        concern proper handling of kinematics at low energies,
"                        makes 2BS almost the same as 2BN at low energies).
"                        [ IBRDST ]
"       Brems cross sections= BH, NIST, NRC default is BH
"                        If BH is selected, the Bethe-Heitler bremsstrahlung
"                        cross sections (Coulomb corrected above 50 MeV)
"                        will be used. If NIST is selected, the NIST brems
"                        cross section data base (which is the basis for
"                        the ICRU radiative stopping powers) will be employed.
"                        Differences are negligible for E > ,say, 10 MeV,
"                        but significant in the keV energy range. If NRC is
"                        selected, the NRC brems cross-section data base will
"                        be used, which is a version of the NIST data base
"                        with corrected electron-electron brems contributions
"                        (corrections to the NIST data is typically only
"                        significant for low values of the atomic number Z
"                        and for k/T < 0.005).
"       Triplet production= On or Off (default).  Turns on/off simulation
"                        of triplet production.  If On, then Borsellino's
"                        first Born approximation is used to sample triplet
"                        events based on the triplet cross-section data.
"                        [ itriplet ]
"       Bound Compton scattering=  On, Off, Simple or norej (default)
"                        If Off, Compton scattering will be treated with
"                        Klein-Nishina, with On Compton scattering is
"                        treated in the Impulse approximation.
"                        With Simple, the impulse approximation incoherent
"                        scattering function will be used (i.e., no Doppler
"                        broadenning). With norej the actual total bound
"                        Compton cross section is used and there are no
"                        rejections at run time.
"                        Make sure to use for low energy applications,
"                        not necessary above, say, 1 MeV.
"                        [ IBCMP ]
"       Radiative Compton corrections= On or Off (default). If on, then
"                        include radiative corrections for Compton scattering.
"                        Equations are based on original Brown & Feynman
"                        equations (Phys. Rev. 85, p 231--1952).  Requires
"                        a change to the user codes Makefile to include
"                        $(EGS_SOURCEDIR)rad_compton1.mortran in the
"                        SOURCES (just before
"                        $(EGS_SOURCEDIR)get_inputs.mortran).
"                        [ radc_flag ]
"       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
"                        gryzinski, penelope.  If set to On or ik, then use
"                        Kawrakow's theory to derive EII cross-sections.
"                        If set to casnati, then
"                        use the cross-sections of Casnati (contained in the
"                        file ($HEN_HOUSE/data/eii_casnati.data).  Similar for
"                        kolbenstvedt, gryzinski and penelope. This is only of
"                        interest in kV X-ray calculations.
"                        Case-sensitive except for Off, On or ik options.
"                        [ eii_flag ]
"       Pair angular sampling= Off, Simple, KM.
"                        If off, pairs are set in motion at an angle m/E
"                        relative to the photon direction (m is electron rest
"                        energy, E the photon energy). Simple turns on
"                        the leading term of the angular distribution
"                        (this is sufficient for most applications),
"                        KM (comes from Koch and Motz) turns on using 2BS
"                        from the article by Koch and Motz.  Uniform
"                        Default is Simple, make sure you always use
"                        Simple or KM
"                        [ IPRDST ]
"       Pair cross sections= BH (default) or NRC.  If set to BH, then use
"                        Bethe-Heitler pair production cross-sections.  If set
"                        to NRC, then use NRC pair production cross-sections
"                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
"                        of interest at low energies, where the NRC cross-
"                        sections take into account the assymmetry in the
"                        positron-electron energy distribution.
"                        [ pair_nrc ]
"       Photon cross sections= Photon cross-section data.  Current options are
"                        si (Storm-Israel), epdl (Evaluated Photon Data
"                        Library), xcom (the default), pegs4, mcdf-xcom and
"                        mcdf-epdl:
"                        Allows the use of photon cross-sections other than
"                        from the PEGS4 file (unless the pegs4 option is
"                        specified).  Options mcdf-xcom and mcdf-epdl use
"                        Sabbatucci and Salvat's renormalized photoelectric
"                        cross sections with either xcom or epdl for all other
"                        cross sections.  These are more accurate but can
"                        increase CPU time by up to 6 %.
"                        Note that the user can supply their own cross-section
"                        data as well. The requirement is that the files
"                        photon_xsections_photo.data,
"                        photon_xsections_pair.data,
"                        photon_xsections_triplet.data, and
"                        photon_xsections_rayleigh.data exist in the
"                        $HEN_HOUSE/data directory, where photon_xsections
"                        is the name specified.
"                        Hence this entry is case-sensitive.
"                        [ photon_xsections ]
"       Photon cross-sections output= Off (default) or On.  If On, then
"                        a file $EGS_HOME/user_code/inputfile.xsections is
"                        output containing photon cross-section data used.
"                        [ xsec_out ]
"       Compton cross sections= Bound Compton cross-section data.  User-
"                        supplied bound Compton cross-sections in the file
"                        $HEN_HOUSE/data/comp_xsections_compton.data, where
"                        comp_xsections is the name supplied for this input.
"                        This is only used if Bound Compton scattering= Simple
"                        and is not available on a region-by-region basis
"                        (see below).  The default file (ie in the absence
"                        of any user-supplied data) is compton_sigma.data.
"                        [ comp_xsections ]
"       Rayleigh scattering= Off, On, custom
"                        If On, turn on coherent (Rayleigh) scattering.
"                        Default is On. Should be turned on for low energy
"                        applications.
"                        If custom, user must provide media names and form
"                        factor files for each desired medium. For the rest
"                        of the media, default atomic FF are used.
"                        [ IRAYLR ]
"       ff media names = A list of media names (must match media found in
"                        PEGS4 data file) for which the user is going to
"                        provide custom Rayleigh form factor data.
"                        [ iray_ff_media($MXMED) ]
"       ff file names = A list of names of files containing the Rayleigh
"                       form factor data for the media specified by
"                       the ff media names = input above.  Full directory
"                       paths must be given for all files, and for each medium
"                       specified, iray_ff_media(i), there must be a
"                       corresponding file name, iray_ff_file(i).  For
"                       example files, see the directory
"                       $HEN_HOUSE/data/molecular_form_factors.
"                       [ iray_ff_file($MXMED) ]
"Ali:photonuc, 2 blocks of comments"
"       Photonuclear attenuation= Off (default) or On
"                        If On, models the photonuclear effect. Current
"                        implementation is crude. Available on a
"                        region-by-region basis (see below)
"                        [ IPHOTONUCR ]
"       Photonuclear cross sections= Total photonuclear cross sections. User-
"                        supplied total photonuclear cross-sections in
"                        $HEN_HOUSE/data/photonuc_xsections_photonuc.data,
"                        where photonuc_xsections is the name supplied for
"                        this input (case sensitive). In the absence of
"                        any user-supplied data, or if photonuc_xsections
"                        is set to 'default', the default file is
"                        iaea_photonuc.data.
"                        [ photonuc_xsections ]
"       Photoelectron angular sampling= Off or On
"                        If Off, photo-electrons get the direction of the
"                        `mother' photon, with On, Sauter's furmula is
"                        used (which is, striktly speaking, valid only for
"                        K-shell photo-absorption).
"                        If the user has a better approach, replace the macro
"                            $SELECT-PHOTOELECTRON-DIRECTION;
"                        The only application that
"                        I encountered until now where this option made a
"                        small difference was a big ion chamber (cavity size
"                        comparable with electron range) with high-Z walls
"                        in a low energy photon beam.
"                        Default is On
"                        [ IPHTER ]
"       Atomic relaxations= Off, On, eadl, simple
"                        Default is eadl.  On defaults to eadl.
"                        When simulating atomic relaxations:
"                        - In photo-electric absorption events, the element
"                          (if material is mixture) and the shell the photon
"                          is interacting with are sampled from the appropriate
"                          cross sections
"                        - Shell vacancies created in photoelectric,
"                          compton and electron impact ionization events
"                          are relaxed via emission of fluorescent X-Rays,
"                          Auger and Koster-Cronig electrons.
"                         The eadl option features a more accurate treatment
"                         of relaxation events and uses binding energies
"                         consistent with those in of the photon cross sections
"                         used in the simulation.  If using mcdf-xcom or
"                         mcdf-epdl photon cross sections, you cannot use
"                         the simple option and this will automatically get
"                         reset to eadl.
"                         Make sure to use eadl or simple for low energy
"                         applications.
"                         [ IEDGFL ]
"
"       Atomic relaxations, Rayleigh scattering,
"       Photoelectron angular sampling and Bound Compton scattering
"       and photonuclear effect(Ali:photonuc)
"       can also be turned On/Off on a region-by-region
"       basis. To do so, put e.g.
"
"       Atomic relaxations= On in Regions   or
"       Atomic relaxations= Off in regions
"
"                         in your input file. Then use
"
"       Bound Compton start region=
"       Bound Compton stop region=
"                or
"       Rayleigh start region=
"       Rayleigh stop region=
"                or
"       Relaxations start region=
"       Relaxations stop region=
"                or
"       PE sampling start region=
"       PE sampling stop region=
"                or                  Ali:photonuc
"       Photonuclear start region=
"       Photonuclear stop region=
"
"                         each followed by a lost of of one or more
"                         start and stop regions separated by commas.
"                         Example:
"        Atomic relaxations= On in Regions
"        Relaxations start region=  1, 40
"        Relaxations stop region=  10, 99
"                         will first turn off relaxations everywhere and
"                         then turn on in regions 1-10 and 40-99.
"                         Note that input is checked against min. and max.
"                         region number and ignored if
"                         start region < 1 or stop_region > $MXREG or
"                         start region > stop region.
"
"                         ECUT, PCUT and SMAX can also be set on a
"                         region-by-region basis. To do so, iclude
"                         in your input file
"
"         Set XXXX=              f_value1, f_value2, ...
"         Set XXXX start region= i_value1, i_value2, ...
"         Set XXXX stop region=  j_value1, j_value2, ...
"
"                         where XXXX is ECUT, PCUT or SMAX ,
"                         f_value1, f_value2,... are the desired values for XXXX
"                         and i_value_i and j_value_i are the start and
"                         stop regions.
"
"*******************************************************************************

implicit none;  "Hard coded to catch possible user replacements of the "
                "following common blocks"

character*80 line;
character*512 toUpper;

$INTEGER ounit;
$declare_max_medium;

$COMIN-GET-TRANSPORTP;

$INTEGER  ival,num_ecut,num_pcut,num_smax,num_incoh,num_radc,num_coh,num_relax,
          num_pe_ang,num_brems_ang,num_brems_cs,num_pair_cs,
          num_ffmed,num_ffiles,
          num_pair_ang,num_eii,num_eii_L,num_estepe,num_ximax,num_triplet,
          num_pxsec,num_pxsec_out, num_cxsec,
          num_photonuc, num_photonuc_xsec,"Ali:photonuc, 1 line"
          num_efield, num_bfield, num_emlmt,"EMH: EM fields"
          num_spin,num_bca,num_alg,num_skin,itmp,iitmp,i,j,k,istart,iend,
          egs_open_file,lnblnk1;

$LOGICAL  ecut_inregions,pcut_inregions,smax_inregions,
          incoh_inregions,coh_inregions,relax_inregions,
          pe_inregions,aux_inregions,photonuc_inregions;"Ali:photonuc"

character*15 output_strings(14);"Ali:photonuc, increased by 1"
save         output_strings,line;
save         ecut_inregions,pcut_inregions,smax_inregions,
             incoh_inregions,coh_inregions,relax_inregions,
             pe_inregions,aux_inregions,photonuc_inregions,
             num_photonuc;"Ali:photonuc"


DO k=1,80 [ line(k:k) = '='; ]
delimeter = $THE_DELIMETER;
ival = 0;

;
/ecut_inregions,pcut_inregions,smax_inregions,
 incoh_inregions,coh_inregions,relax_inregions,
 pe_inregions,aux_inregions,
 "Ali:photonuc, 1 line"
 photonuc_inregions/ = .false.;

"open a .errors file exclusively for output from this subroutine"
i_errors=15;
i_errors=egs_open_file(i_errors,0,1,'.errors');

write(i_errors,*)
' If you are not trying to reset transport parameters, ';
write(i_errors,*)
' ignore all the output until the message ';
write(i_errors,*)
' ******************** end input transport parameter *********************** ';
write(i_errors,*);

" ECUT "
ival                = ival + 1;
num_ecut            = ival;                     "Set the variable pointer"
values_sought(ival) = $GLOBAL_ELECTRON_CUTOFF;  "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $GLOBAL-ECUT;

" PCUT "
ival                = ival + 1;
num_pcut            = ival;                     "Set the variable pointer"
values_sought(ival) = $GLOBAL_PHOTON_CUTOFF;    "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $GLOBAL-PCUT;

" SMAX "
ival                = ival + 1;
num_smax            = ival;                     "Set the variable pointer"
values_sought(ival) = $GLOBAL_SMAX;             "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $MAX-SMAX;

" Incoherent (Compton) scattering "
ival                = ival + 1;
num_incoh           = ival;                     "Set the variable pointer"
values_sought(ival) = $INCOHERENT_SCATTERING;   "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;
allowed_inputs(ival,4) = 'Simple';
allowed_inputs(ival,5) = 'norej';

" Radiative corrections for Compton scattering "
ival                = ival + 1;
num_radc            = ival;
values_sought(ival) = $RADC_COMPTON;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';

" Coherent (Rayleigh) scattering "
ival                = ival + 1;
num_coh             = ival;                     "Set the variable pointer"
values_sought(ival) = $COHERENT_SCATTERING;     "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;
allowed_inputs(ival,4) = 'custom';

" Atomic Relaxations "
ival                = ival + 1;
num_relax           = ival;                     "Set the variable pointer"
values_sought(ival) = $ATOMIC_RELAXATIONS;      "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;
allowed_inputs(ival,4) = 'eadl';
allowed_inputs(ival,5) = 'simple';

" Photoelectron angular sampling "
ival                = ival + 1;
num_pe_ang          = ival;                     "Set the variable pointer"
values_sought(ival) = $PE_ANGULAR_SAMPLING;     "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;

" Bremsstrahlung angular sampling "
ival                = ival + 1;
num_brems_ang       = ival;                     "Set the variable pointer"
values_sought(ival) = $BREMS_ANGULAR_SAMPLING;  "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Simple';
allowed_inputs(ival,1) = 'KM';   "means Koch-Motz, Simple turns on just the"
                                 "leading term of the distribution which is"
                                 "probably sufficiently accurate for most"
                                 "applications"

" Bremsstrahlung cross sections "
ival                = ival + 1;
num_brems_cs        = ival;                     "Set the variable pointer"
values_sought(ival) = $BREMS_CROSS_SECTIONS;    "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'BH';
allowed_inputs(ival,1) = 'NIST';                "Only global on/off available"
allowed_inputs(ival,2) = 'NRC';                 "Only global on/off available"


" Pair angular sampling "
ival                = ival + 1;
num_pair_ang        = ival;                     "Set the variable pointer"
values_sought(ival) = $PAIR_ANGULAR_SAMPLING;   "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'Simple';             "Only global on/off available"
allowed_inputs(ival,2) = 'KM';   "means Koch-Motz, Simple turns on just the"
                                 "leading term of the distribution which is"
                                 "probably sufficiently accurate for most"
                                 "applications"
allowed_inputs(ival,3) = 'Uniform';
allowed_inputs(ival,4) = 'Blend';

" Pair cross sections "
ival                = ival + 1;
num_pair_cs         = ival;
values_sought(ival) = $PAIR_CROSS_SECTIONS;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'BH';
allowed_inputs(ival,1) = 'NRC';

" Triplet production "
ival                = ival + 1;
num_triplet         = ival;
values_sought(ival) = $TRIPLET_PRODUCTION;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';

" Spin effects          "
ival                = ival + 1;
num_spin            = ival;                     "Set the variable pointer"
values_sought(ival) = $SPIN_EFFECTS;            "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';                 "Only global on/off available"

" Electron impact ionization "
ival                = ival + 1;
num_eii             = ival;
values_sought(ival) = $ELECTRON_IMPACT_IONI;
nvalue(ival)        = 1;
type(ival)          = 2;
"type(ival)          = 3;"
"allowed_inputs(ival,0) = 'Off';"
"allowed_inputs(ival,1) = 'On';"
"allowed_inputs(ival,2) = 'casnati';"
"allowed_inputs(ival,3) = 'kolbenstvedt';"
"allowed_inputs(ival,4) = 'gryzinski';"

" L-shell EII xsection scaling"
ival                = ival + 1;
num_eii_L= ival;                                "Set the variable pointer"
values_sought(ival) = $SCALE_L_EII_XSECTIONS;   "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0.0;                      "Define the allowed range"
value_max(ival)     = 1.0e+9;
default(ival)       = 1.0;

" ESTEPE "
ival                = ival + 1;
num_estepe          = ival;                     "Set the variable pointer"
values_sought(ival) = $MAXIMUM_ESTEPE;          "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 1e-5;                     "Define the allowed range"
value_max(ival)     = 1;
default(ival)       = $MAX-ELOSS;

" XIMAX "
ival                = ival + 1;
num_ximax           = ival;                     "Set the variable pointer"
values_sought(ival) = $MAXIMUM_XIMAX;           "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1;
default(ival)       = $EXACT-BCA-XIMAX;

" BCA "
ival                = ival + 1;
num_bca             = ival;                     "Set the variable pointer"
values_sought(ival) = $BOUNDARY_ALGORITHM;      "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Exact';
allowed_inputs(ival,1) = 'PRESTA-I';

" Skindepth "
ival                = ival + 1;
num_skin            = ival;                     "Set the variable pointer"
values_sought(ival) = $SKIN_FOR_BCA;            "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = -1;                       "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $SKIN-DEPTH-FOR-BCA;

" Electron-step algorithm "
ival                = ival + 1;
num_alg             = ival;                     "Set the variable pointer"
values_sought(ival) = $ELECTRON_STEP_ALG;       "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'PRESTA-II'; "Better EGSnrc ???"
allowed_inputs(ival,1) = 'PRESTA-I';

" Photon cross sections "
ival                = ival + 1;
num_pxsec           = ival;
values_sought(ival) = $PHOTON_XSECTIONS;
nvalue(ival)        = 1;
type(ival)          = 2;

" Photon cross sections output "
ival                = ival + 1;
num_pxsec_out       = ival;
values_sought(ival) = $PHOTON_XSECTIONS_OUT;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';

" Compton cross sections "
ival                = ival + 1;
num_cxsec           = ival;
values_sought(ival) = $COMPTON_XSECTIONS;
nvalue(ival)        = 1;
type(ival)          = 2;

" E-Field "
ival                = ival + 1;
num_efield          = ival;                     "Set the variable pointer"
values_sought(ival) = $E_FIELD;                 "The code word"
nvalue(ival)        = 3;                        "3 inputs"
type(ival)          = 1;                        "A real number"
value_min(ival)     = -1e15;                    "Define the allowed range"
value_max(ival)     =  1e15;
default(ival)       =  0;

" B-Field "
ival                = ival + 1;
num_bfield          = ival;                     "Set the variable pointer"
values_sought(ival) = $B_FIELD;                 "The code word"
nvalue(ival)        = 3;                        "3 inputs"
type(ival)          = 1;                        "A real number"
value_min(ival)     = -1e10;                    "Define the allowed range"
value_max(ival)     =  1e10;
default(ival)       =  0;

" EM-field step and eloss restriction "
ival                = ival + 1;
num_emlmt           = ival;                     "Set the variable pointer"
values_sought(ival) = $EM_LMT;                 "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0.0;                      "Define the allowed range"
value_max(ival)     = 1.0;
default(ival)       = 0.02;

"Ali:photonuc, 2 blocks"
" Photonuclear "
ival                = ival + 1;
num_photonuc        = ival;           "set the variable pointer"
values_sought(ival) = $PHOTO_NUCLEAR; "the code word"
nvalue(ival)        = 1;              "1 input"
type(ival)          = 3;              "an `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;

" Photonuclear cross sections "
ival                = ival + 1;
num_photonuc_xsec   = ival;
values_sought(ival) = $PHOTONUC_XSECTIONS;
nvalue(ival)        = 1;
type(ival)          = 2;

"Ali:photonuc, 1 line"
Nmin = num_ecut; Nmax = num_photonuc_xsec;
"Nmin = num_ecut; Nmax = num_cxsec;"

CALL GET_INPUT;

IF( error_flags(num_ecut) = 0 ) [
    DO j=1,$MXREG [ ecut(j) = value(num_ecut,1); ]
]
IF( error_flags(num_pcut) = 0 ) [
    DO j=1,$MXREG [ pcut(j) = value(num_pcut,1); ]
]
IF( error_flags(num_smax) = 0 ) [
    DO j=1,$MXREG [ smaxir(j) = value(num_smax,1); ]
]
IF( error_flags(num_brems_ang) = 0 ) [
    ibrdst = value(num_brems_ang,1);
]
IF( error_flags(num_brems_cs) = 0 ) [
    ibr_nist = value(num_brems_cs,1);
]
IF( error_flags(num_radc) = 0 ) [
    radc_flag = value(num_radc,1);
]
IF( error_flags(num_pair_ang) = 0 ) [
    iprdst = value(num_pair_ang,1);
]
IF( error_flags(num_pair_cs) = 0 ) [
    pair_nrc = value(num_pair_cs,1);
]
IF( error_flags(num_triplet) = 0 ) [
    itriplet = value(num_triplet,1);
]
IF( error_flags(num_eii_L) = 0 ) [ eii_L_factor = value(num_eii_L,1); ]
IF( error_flags(num_estepe) = 0 ) [ estepe = value(num_estepe,1); ]
IF( error_flags(num_ximax) = 0 ) [ ximax = value(num_ximax,1); ]
IF( error_flags(num_bca) = 0 ) [
    bca_algorithm = value(num_bca,1);
    IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
]
IF( error_flags(num_alg) = 0 ) [ transport_algorithm = value(num_alg,1); ]
IF( error_flags(num_skin) = 0 ) [ skindepth_for_bca = value(num_skin,1); ]
IF( error_flags(num_spin) = 0 ) [
   itmp = value(num_spin,1);
   IF( itmp = 1 ) [ spin_effects = .true.; ]
   ELSE           [ spin_effects = .false.; ]
]
/******************************************************
   Mantaining compatibility with previous versions
   allowing ON(IK) and OFF besides custom EII data
   compilation files of the form eii_prefix.data.
 ******************************************************/
IF( error_flags(num_eii) = 0 ) [
   eii_xfile = char_value(num_eii,1);eii_flag=1;
   IF (toUpper($cstring(eii_xfile)).eq.'ON' |
       toUpper($cstring(eii_xfile)).eq.'IK' )[
       eii_xfile = 'ik';
    $egs_info(*,'==> Using default EII data compilation ',
              $cstring(eii_xfile));
   ]
   ELSEIF (toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'OFF')[
       eii_xfile='Off';eii_flag=0;
   ]
   ELSE["Using non-default EII data compilation"
    $egs_warning(*,'==> Using non-default EII data compilation ',
                 $cstring(eii_xfile));
   ]
]
/******************************************************
   Use Sabbatucci and Salvat shellwise photoelectric
   cross sections together with XCOM or EPDL cross sections
   for pair production.
 ******************************************************/
IF( error_flags(num_pxsec) = 0 ) [
    photon_xsections = char_value(num_pxsec,1);
    IF ( toUpper( $cstring(photon_xsections) ) = 'MCDF-XCOM' )[
        mcdf_pe_xsections = .true.; photon_xsections = 'xcom';
    ]
    ELSEIF ( toUpper( $cstring(photon_xsections) ) = 'MCDF-EPDL' )[
        mcdf_pe_xsections = .true.; photon_xsections = 'epdl';
    ]
    ELSE[
        mcdf_pe_xsections = .false.;
    ]
]
/**********************************************************/
IF( error_flags(num_pxsec_out) = 0 ) [
    xsec_out = value(num_pxsec_out,1);
]
IF( error_flags(num_cxsec) = 0 ) [
    comp_xsections = char_value(num_cxsec,1);
]
"Ali:photonuc, 3 lines"
IF( error_flags(num_photonuc_xsec) = 0 ) [
    photonuc_xsections = char_value(num_photonuc_xsec,1);
]

IF( error_flags(num_efield) = 0 ) [
    ExIN = value(num_efield,1);
    EyIN = value(num_efield,2);
    EzIN = value(num_efield,3);
    IF( error_flags(num_emlmt) = 0 )[
       EMLMTIN=value(num_emlmt,1);
    ]
    IF( ExIN**2+EyIN**2+EzIN**2 > 0 ) [
        emfield_on=.true.
    ]
]
" Initially set to input values, could change with regions"
" by converting it to an array over all regions. This is  "
" currently implemented only for the C++ applications     "
IF( error_flags(num_bfield) = 0 ) [
    BxIN = value(num_bfield,1);
    ByIN = value(num_bfield,2);
    BzIN = value(num_bfield,3);
    Bx=BxIN;By=ByIN;Bz=BzIN;
    Bx_new=BxIN;By_new=ByIN;Bz_new=BzIN;
    IF( error_flags(num_emlmt) = 0 )[
       EMLMTIN=value(num_emlmt,1);
    ]
    IF( BxIN**2+ByIN**2+BzIN**2 > 0 ) [
        emfield_on=.true.
    ]
]


/***************************************************************/
/* Get media for which to read custom ff and the ff file names */
/***************************************************************/
IF( error_flags(num_coh) = 0 ) [
  IF(value(num_coh,1) = 4)[
   write(*,'(/a/)') ' ===> custom ff requested!';
   ival                = ival + 1;
   num_ffmed           = ival;
   values_sought(ival) = 'ff media names';
   type(ival)          = 2;  "i.e.  character input"
   nvalue(ival)        = 0;
   ival                = ival + 1;
   num_ffiles          = ival;
   values_sought(ival) = 'ff file names';
   type(ival)          = 2;  "i.e.  character input"
   nvalue(ival)        = 0;
   Nmin = num_ffmed; Nmax = num_ffiles;
   CALL GET_INPUT;
   IF( error_flags(num_ffmed) > 0 ) [
    $egs_fatal('(a/,a,I3)','Error reading custom ff! Terminating ...',
               ' error_flag = ', error_flags(num_ffmed));
   ]
   IF( error_flags(num_ffiles) > 0 ) [
    $egs_fatal('(a/,a,I3)','Error reading ff file names! Terminating ...',
               ' error_flag = ', error_flags(num_ffiles));
   ]
   IF (nvalue(num_ffmed)>$MXMED)[
      $egs_fatal('(a,a,i3,a)',
              '***** Number of media with custom ff larger ',
              'than maximum number of media $MXMED = ',$MXMED,
              ' increase $MXMED and try again!!!');
   ]
   DO i=1,nvalue(num_ffmed) [
    iray_ff_media(i) = char_value(num_ffmed,i);
    iray_ff_file(i)  = char_value(num_ffiles,i);
   ]
   value(num_coh,1) = 1; "reset to 1 since custom info in iray_ff_files"
  ]
  write(*,'(/)');
]
/***************************************************************/
/*
 Inputs allowing setting by region are checked with the macro
 $TURN-ON/OFF-IN-REGIONS. For this type of input, the second
 and third entries correspond to turning ON or OFF the interaction
 in specific regions. If no input is found, the default value is
 used.
 */
/***************************************************************/
$TURN-ON/OFF-IN-REGIONS(num_incoh,
                    'Bound Compton start region',
                    'Bound Compton stop region',
                    ibcmp); incoh_inregions = aux_inregions;
$TURN-ON/OFF-IN-REGIONS(num_coh,
                    'Rayleigh start region',
                    'Rayleigh stop region',
                    iraylr); coh_inregions = aux_inregions;
$TURN-ON/OFF-IN-REGIONS(num_relax,
                    'Relaxations start region',
                    'Relaxations stop region',
                    iedgfl); relax_inregions = aux_inregions;
$TURN-ON/OFF-IN-REGIONS(num_pe_ang,
                    'PE sampling start region',
                    'PE sampling stop region',
                    iphter); pe_inregions = aux_inregions;
"Ali:photonuc, 1 block"
$TURN-ON/OFF-IN-REGIONS(num_photonuc,
                    'Photonuclear start region',
                    'Photonuclear stop region',
                    iphotonucr); photonuc_inregions = aux_inregions;
$SET ecut IN REGIONS(num_ecut,0.,1e15,0.,'Set ECUT','Set ECUT start region',
                                         'Set ECUT stop region');
ecut_inregions = aux_inregions;

$SET pcut IN REGIONS(num_pcut,0.,1e15,0.,'Set PCUT','Set PCUT start region',
                                         'Set PCUT stop region');
pcut_inregions = aux_inregions;

$SET smaxir IN REGIONS(num_smax,0.,1e15,0.,'Set SMAX','Set SMAX start region',
                                         'Set SMAX stop region');
smax_inregions = aux_inregions;

write(i_errors,*);
write(i_errors,*)
' ******************** end input transport parameter *********************** ';
write(i_errors,*);

"Check if EADL relaxation requested. Note that original relaxation"
"algorithm using <M> and <N> is only turned ON for all regions."
"Moved past the $TURN-ON/OFF-IN-REGIONS statement to catch the"
"default case."
IF(value(num_relax,1) > 0 & value(num_relax,1) < 5)[
   eadl_relax = .true.;
   "Default relaxation is EADL"
   IF (value(num_relax,1) = 1)[value(num_relax,1)=4;]
]
ELSE [
    IF (mcdf_pe_xsections & value(num_relax,1) = 5)[
       eadl_relax = .true.; value(num_relax,1)=4;
       $egs_warning('(a/,a/,a/)',
                    '    Simplified atomic relaxation not allowed',
                    '    with shellwise PE cross sections. Resetting',
                    '    to detailed EADL atomic relaxation!!!');
    ]
    ELSE [
       eadl_relax = .false.;
    ]
]

" we put the information stored in allowed_inputs into "
" output_strings just in case the user over-rides it "
" before printing out the settings "

output_strings(1) = allowed_inputs(num_pair_ang,iprdst);
itmp = value(num_incoh,1);
output_strings(2) = allowed_inputs(num_incoh,itmp);
$RADC_WARNING;
output_strings(12) = allowed_inputs(num_radc,radc_flag);
itmp = value(num_coh,1);
output_strings(3) = allowed_inputs(num_coh,itmp);
itmp = value(num_relax,1);
output_strings(4) = allowed_inputs(num_relax,itmp);
itmp = value(num_pe_ang,1);
output_strings(5) = allowed_inputs(num_pe_ang,itmp);
output_strings(6) = allowed_inputs(num_brems_ang,ibrdst);
output_strings(7) = allowed_inputs(num_bca,bca_algorithm);
output_strings(8) = allowed_inputs(num_alg,transport_algorithm);
output_strings(9) = allowed_inputs(num_brems_cs,ibr_nist);
output_strings(10) = allowed_inputs(num_pair_cs,pair_nrc);
output_strings(11) = allowed_inputs(num_triplet,itriplet);
"output_strings(13) = allowed_inputs(num_eii,eii_flag);"
"Ali:photonuc, 2 lines"
itmp = value(num_photonuc,1);
output_strings(14) = allowed_inputs(num_photonuc,itmp);

entry show_transport_parameter(ounit);

IF ( ounit <= 0 ) return;

write(ounit,*);
write(ounit,'(a)') line;
write(ounit,*);
write(ounit,'(a,/)')
'                   Electron/Photon transport parameter';
write(ounit,'(a,/)') line;

/* initialized in egs_set_defaults */
write(ounit,'(a,38x,a)') ' Photon cross sections',
      $cstring(photon_xsections);
write(ounit,'(a,37x,a)') ' Compton cross sections', $cstring(comp_xsections);

write(ounit,'(a,$)') ' Photon transport cutoff(MeV)';
IF( pcut_inregions ) [ write(ounit,'(32x,a)') 'Set in regions'; ]
ELSE [
    IF( pcut(1) > 1e-4 ) [ write(ounit,'(32x,g14.4)') pcut(1); ]
    ELSE [ write(ounit,'(32x,a)') 'AP(medium)'; ]
]
write(ounit,'(a,39x,a3)')  ' Pair angular sampling',output_strings(1);
write(ounit,'(a,41x,a3)')  ' Pair cross sections',output_strings(10);
write(ounit,'(a,42x,a3)')  ' Triplet production',output_strings(11);
write(ounit,'(a,36x,a14)') ' Bound Compton scattering',output_strings(2);
write(ounit,'(a,31x,a14)') ' Radiative Compton corrections',output_strings(12);
write(ounit,'(a,41x,a14)') ' Rayleigh scattering',output_strings(3);
write(ounit,'(a,42x,a14)') ' Atomic relaxations',output_strings(4);
write(ounit,'(a,30x,a14)') ' Photoelectron angular sampling',output_strings(5);
"Ali:photonuc, 3 lines. EMH added IF statement"
IF ( value(num_photonuc,1) > 0 )[
 write(ounit,'(a,36x,a14)') ' Photonuclear attenuation',output_strings(14);
 write(ounit,'(a,33x,a)') ' Photonuclear cross sections',
 $cstring(photonuc_xsections);
]

write(ounit,*);

write(ounit,'(a,$)') ' Electron transport cutoff(MeV)';
IF( ecut_inregions ) [ write(ounit,'(30x,a)') 'Set in regions'; ]
ELSE [
    IF( ecut(1) > 1e-4 ) [ write(ounit,'(30x,f7.4)') ecut(1); ]
    ELSE [ write(ounit,'(30x,a)') 'AE(medium)'; ]
]
write(ounit,'(a,30x,a4)') ' Bremsstrahlung cross sections',output_strings(9);
write(ounit,'(a,29x,a3)') ' Bremsstrahlung angular sampling',output_strings(6);
IF( spin_effects ) [ write(ounit,'(a,48x,a)') ' Spin effects','On'; ]
ELSE [ write(ounit,'(a,48x,a)') ' Spin effects','Off'; ]
write(ounit,'(a,34x,a)') ' Electron Impact Ionization',$cstring(eii_xfile);
IF (eii_L_factor ~= 1.0) [
   write(ounit,'(a,25x,f6.4)')
   ' L-shell EII xsections scaling factor',eii_L_factor;
]
write(ounit,'(a,$)') ' Maxium electron step in cm (SMAX)';
IF( smax_inregions ) [ write(ounit,'(27x,a)') 'Set in regions'; ]
ELSE [
    IF( smaxir(1) > 1e-4 ) [ write(ounit,'(27x,g14.4)') smaxir(1); ]
    ELSE [ write(ounit,'(27x,a)') 'Restriction is off'; ]
]
write(ounit,'(a,16x,f6.4)')
 ' Maximum fractional energy loss/step (ESTEPE)',estepe;
write(ounit,'(a,21x,f6.4)')
 ' Maximum 1st elastic moment/step (XIMAX)',ximax;
write(ounit,'(a,33x,a10)')
 ' Boundary crossing algorithm',output_strings(7);
write(ounit,'(a,22x,g9.4)')
 ' Skin-depth for boundary crossing (MFP)',skindepth_for_bca;
write(ounit,'(a,37x,a10)')
 ' Electron-step algorithm',output_strings(8);
IF( ExIN~=0 | EyIN~=0 | EzIN~=0 )[
  write(ounit,'(a,38x,3f10.2)') ' Electric Field [V/cm]',
                  ExIN,EyIN,EzIN;
]
IF( Bx~=0 | By~=0 | Bz~=0 )[
  write(ounit,'(a,41x,3f10.2)') ' Magnetic Field [T]',
                  Bx,By,Bz;
]
IF( ExIN~=0 | EyIN~=0 | EzIN~=0 |
    Bx~=0 | By~=0 | Bz~=0 )[
  write(ounit,'(a,50x,f10.2)') ' EM ESTEPE',EMLMTIN;
]
write(ounit,*);
write(ounit,'(a)') line;
write(ounit,*);

return;
end;
;
/************************************************************************
 *
 * The following subroutine can be used to modify the elastic
 * scattering power in one or more media.
 * To do so, the user includes one or more lines in
 * the transport parameter section of the input file
 *
 *     scale elastic scattering in SOME_MEDIUM= 1.05
 *
 * where SOME_MEDIUM is the name of a medium.
 *
 * The effect of this will be that both, xcc and blcc will
 * get multiplied with the provided factor, leaving the
 * screening angle unchanged but increasing the number of collisions
 * per unit length.
 *
 ************************************************************************/

subroutine set_elastic_parameter;

implicit none;
$INTEGER ounit;
$declare_max_medium;
;COMIN/GetInput,ELECIN,MEDIA,EGS-IO/;
$INTEGER imed,ival,lnblnk1,nchanged;
character*24 medname;

ounit = i_log;
ounit = i_log;
delimeter = $THE_DELIMETER;
call get_input_set_error_level(0);
ival = 0;
DO imed=1,nmed [
    call egs_get_medium_name(imed,medname);
    ival                = ival + 1;
    values_sought(ival) = 'scale elastic scattering in '//
                           medname(:lnblnk1(medname));
    nvalue(ival)        = 1;
    type(ival)          = 1;
    value_min(ival)     = 1e-3;
    value_max(ival)     = 1e3;
    default(ival)       = 1;
]
Nmin = 1; Nmax = nmed;
CALL GET_INPUT;
nchanged = 0;
DO imed=1,nmed [
    IF( error_flags(imed) = 0 ) nchanged = nchanged + 1;
]
IF( nchanged > 0 ) [
    write(ounit,'(//a)')
'================ Elastic scattering scaled as follows ==================';
    DO imed=1,nmed [
        IF( error_flags(imed) = 0 ) [
            call egs_get_medium_name(imed,medname);
            xcc(imed)  = xcc(imed)*value(imed,1);
            blcc(imed) = blcc(imed)*value(imed,1);
            write(ounit,'(a,t30,f10.6)') medname(:lnblnk1(medname)),
              value(imed,1);
        ]
    ]
    write(ounit,'(a//)')
'========================================================================';
]
return; end;
;

"==========================end of get_inputs.mortran=================="
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc auxiliary routines for NRC user codes                               "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2000                                       "
"                   Dave Rogers, 2000                                         "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"
"                                                                             "
"  These are auxiliary routines used in many NRC user codes.                  "
"                                                                             "
"  If you include them via your configuration file, your user code will need  "
"  to define $MXDATA and $STAT. For example, if you are not using the         "
"  statistical analysis package:                                              "
"                                                                             "
"  REPLACE {$MXDATA} WITH {1}; REPLACE{$STAT} WITH {1};                       "
"                                                                             "
"#############################################################################"


%C80
"*****************************************************************************"
"                                                                             "
"                        WATCH                                                "
"                                                                             "
SUBROUTINE WATCH(IARG,IWATCH);

"============================================================================="
"                                                                             "
"     A general purpose auxiliary routine for use with the EGSnrc system
"
"     It prints out information about the particle transport                  "
"                                                                             "
"       For IWATCH = 1 it prints information about each discrete interaction  "
"       For IWATCH = 2 or 3 it prints information about each step as well     "
"       For IWATCH = 4 it prints graphing data for use with EGS_Windows       "
"                                                                             "
"                                                                             "
"    Routine is used via two mandatory and 1 optional call from the user's    "
"          code                                                               "
"                                                                             "
"   1)The routine must be initialized by a call with IARG=-99 before the first"
"          call to SHOWER. It should be after all inputs are in place.        "
"   2)The routine must be called near the beginning of the AUSGAB subroutine  "
"          IF (IWATCH > 0 ) CALL WATCH(IARG,IWATCH);                          "
"   3)The routine may be called at the end of each history with IARG = - 1 so "
"          a message will get printed stated history is complete              "
"                                                                             "
"    Since WATCH cannot output values related to the initial values in a      "
"    shower call, it is useful to also put something like the following       "
"    immediately prior to the CALL SHOWER stmt                                "
"           IF((IWATCH ~= 0) & (IWATCH ~= 4))[                                "
"              OUTPUT 1,EIN,IQI,IRI,XI,YI,ZI,UI,VI,WI,LATCHI,WTI;              "
"               (/' INITIAL SHOWER VALUES',T36,':',                           "
"               I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);                         "
"           ]                                                                 "
"    Note EIN is the kinetic energy of the incident particle                  "
"                                                                             "
"                                                                             "
"   The routine uses up to 132 columns for output.                            "
"                                                                             "
"     JAN 1984  GENERALIZED VERSION WITH INITIALIZATION                       "
"                              DAVE ROGERS NRCC                               "
"     JUN 1987  PUT IN IWATCH = 4 OPTION     AFB                              "
"     JUL 1988  COMPATIBLE WITH X-RAY FLUORESCENCE  DWOR                      "
"     SEP 1990  ADDED ENERGY OUTPUT TO IWATCH = 4 OPTION     AFB              "
"     OCT 1990  UNIX compatible carriage control   DWOR                       "
"     JAN 2000  Rewritten to output relaxation particles and also             "
"               so some of the output makes more sense BW                     "
"                                                                             "
"*****************************************************************************"

"define a local macro"
REPLACE {$CNTOUT(#);(#);} WITH {
   ICOUNT=ICOUNT+1;
   OUTPUT {P1},KE,IQ({P1}),IR({P1}),X({P1}),Y({P1}),Z({P1}),U({P1}),V({P1}),
   W({P1}),LATCH({P1}),WT({P1});  ({P2},I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
}

$IMPLICIT-NONE;
$INTEGER iarg,iwatch,IP,ICOUNT,JHSTRY,J,N;
$REAL KE;
$INTEGER graph_unit;
integer  egs_open_file;
$INTEGER ku,kr,ka;

;COMIN/BOUNDS, STACK,EPCONT,EGS-VARIANCE-REDUCTION,USEFUL,EGS-IO/;

DATA ICOUNT/0/,JHSTRY/1/ graph_unit/-1/;
save     ICOUNT,JHSTRY,graph_unit;

ku = 13; kr = 0; ka = 1;
IF(IARG = -99) [ "Initialize flags so we will get calls thru AUSGAB"
  DO J=1,29[IAUSFL(J)=1;];
  /IAUSFL(22),IAUSFL(23),IAUSFL(24)/=0;
]

IF(IARG = -1) ["main is assumed to call AUSGAB with IARG=-1 at end of history"
  IF(IWATCH = 4) [
    IF( graph_unit < 0 ) [
        graph_unit = egs_open_file(ku,kr,ka,'.egsgph');
    ]
    WRITE(graph_unit,:GRAPHICS_FORMAT:) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY;
    JHSTRY=JHSTRY+1;
  ]
  ELSE[
    OUTPUT JHSTRY;(' END OF HISTORY',I8,3X,40('*')/);
    JHSTRY=JHSTRY+1;ICOUNT=ICOUNT+2;RETURN;
  ]
]

IF( (IWATCH ~= 4) & ((ICOUNT >= 50) | (ICOUNT = 0) | (IARG = -99)) )[
   "PRINT HEADER"
   ICOUNT=1;
   OUTPUT;(//T39,' NP',3X,'ENERGY  Q REGION    X',7X,
   'Y',7X,'Z',6X,'U',6X,'V',6X,'W',6X,'LATCH',2X,'WEIGHT'/);
]

IF((IWATCH = 4) & (IARG >= 0) & (IARG ~= 5)) [ "GRAPHICS OUTPUT"
   IF( graph_unit < 0 ) graph_unit = egs_open_file(ku,kr,ka,'.egsgph');
   WRITE(graph_unit,:GRAPHICS_FORMAT:) NP,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),E(NP);
   :GRAPHICS_FORMAT:FORMAT(2I4,1X,I6,4G15.8,I12);
]

IF(IARG = 5  |  IARG < 0) RETURN;
IF(IWATCH = 4) RETURN; "NONE OF THE REST NEEDED FOR GRAPHICS OUTPUT"

KE=E(NP);IF(IQ(NP).NE.0)[KE=E(NP)-PRM;]

IF(IARG = 0 & IWATCH = 2)[
  $CNTOUT(NP);(T11,'STEP ABOUT TO OCCUR', T36,':');
]
ELSEIF(IARG = 0)[RETURN;]
IF(    IARG = 1)[
   $CNTOUT(NP);(' Discard  AE,AP<E<ECUT',T36,':');]
ELSEIF(IARG = 2)[
   $CNTOUT(NP);(' Discard  E<AE,AP',T36,':');]
ELSEIF(IARG = 3)[
   $CNTOUT(NP);(' Discard -user request',T36,':');]
ELSEIF(IARG = 4)[OUTPUT EDEP,IR(NP);
  (T10,'Local energy deposition',T36,':',F12.5,' MeV in region ',I6);]

ELSEIF(IARG = 6)[
   $CNTOUT(NP);(' bremsstrahlung  about to occur',T36,':');]
ELSEIF(IARG = 7)[
    IF(nbr_split =1) ["no splitting or SBS is on in BEAMnrc"
       DO IP=NPold,NP[
         IF(IQ(IP)=-1)[
           KE = E(IP) - RM;
           $CNTOUT(IP);(T10,'Resulting electron',T36,':');
         ]
         ELSE[
           KE = E(IP);
           $CNTOUT(IP);(T10,'Resulting photon',T36,':');
         ]
       ]
    ]
    ELSE ["splitting case--e- is always at NPold"
      KE = E(NPold) - RM;
      $CNTOUT(NPold);(T10,'Resulting electron',T36,':');
      DO IP=NPold+1,NP[
        KE= E(IP);
        IF(IP = NPold+1)["print info for first one only"
           $CNTOUT(IP);(T10,'Split photons',T36,':');
        ]
        ELSE[ $CNTOUT(IP);(T36,':'); ]
      ]
    ]" end of splitting block"
]

ELSEIF(IARG = 8)[$CNTOUT(NP);(' Moller   about to occur',T36,':');]
ELSEIF(IARG = 9)[
  "surely this logic not needed?"
  IF(NP=NPold)[
     $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
  ]
  ELSE[
     DO IP=NPold,NP[
        KE = E(IP) - ABS(IQ(NP))*RM;
        IF(IP=NPold)[$CNTOUT(IP);(T11,'Resulting electrons',T36,':');]
        ELSE[$CNTOUT(IP);(T36,':');]
     ]
  ]
]

ELSEIF(IARG = 10)[
   $CNTOUT(NP);(' Bhabba   about to occur',T36,':');
]
ELSEIF(IARG = 11)[
  IF(NP=NPold)[
     $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
  ]
  ELSE[
     DO IP=NPold,NP[
        KE = E(IP) - ABS(IQ(IP))*RM;
        IF(IP=NPold)[ $CNTOUT(IP);(T11,'Resulting e- or e+',T36,':'); ]
        ELSE[$CNTOUT(IP);(T36,':');]
     ]
  ]
]

ELSEIF(IARG = 12)[
   $CNTOUT(NP);(' Positron about to decay in flight',T36,':');
]
ELSEIF(IARG = 13)[
  IF(NP=NPold)[
     $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
  ]
  ELSE[
     DO IP=NPold,NP[
        KE = E(IP) - ABS(IQ(IP))*RM;
        IF(IP=NPold)[$CNTOUT(IP);(T11,'Resulting photons',T36,':');]
        ELSE[$CNTOUT(IP);(T36,':');]
     ]
  ]
]

ELSEIF(IARG = 28)[
   $CNTOUT(NP);(' Positron will annihilate at rest',T36,':');
]
ELSEIF(IARG = 14)[
  IF(NP=NPold)[
       $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
  ]
  ELSE[
     DO IP=NPold,NP[
        KE = E(IP) - ABS(IQ(IP))*RM;
        IF(IP=NPold)[$CNTOUT(IP);(' Positron annihilates at rest',T36,':');]
        ELSE[$CNTOUT(IP);(T36,':');]
     ]
  ]
]

ELSEIF(IARG = 15)[
    $CNTOUT(NP);(' Pair production about to occur',T36,':');
]
ELSEIF(IARG = 16)["after pair production"
  IF(NP=NPold & i_survived_rr = 0)[
       $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
  ]
  ELSEIF(NP=NPold & i_survived_rr > 0)["we have cleared the stack"
      OUTPUT i_survived_rr,prob_rr;
       (T10,'Russian Roulette eliminated ',I2,
                    ' particle(s) with probability ',F8.5)
      $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
  ]
  ELSE[
     DO IP=NPold,NP[
        KE = E(IP) - ABS(IQ(IP))*RM;
        IF(IP=NPold)[$CNTOUT(IP);(T11,'Resulting pair',T36,':');]
        ELSE[$CNTOUT(IP);(T36,':');]
     ]
     IF(i_survived_rr > 0)[
        OUTPUT i_survived_rr,prob_rr;
       (T10,'Russian Roulette eliminated ',I2,'
             particle(s) with probability ',F8.5);
       $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
     ]
  ]
]

ELSEIF(IARG = 17)[$CNTOUT(NP);(' Compton  about to occur',T36,':');]
ELSEIF(IARG = 18)["after call to COMPT"
  IF(NP = NPold & i_survived_rr = 0)[
      $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
  ]
  ELSEIF(NP > NPold)["have not cleared the stack with rus rou"
     DO IP=NPold,NPold+1[
        KE = E(IP) - ABS(IQ(IP))*RM;
        IF(IQ(IP).NE.0)[$CNTOUT(IP);(T11,'compton electron created',T36,':');]
        ELSE[$CNTOUT(IP);(T11,'compton scattered photon',T36,':');]
     ]
  ]
  IF(i_survived_rr > 0)["whether the stack has been cleared or not"
       OUTPUT i_survived_rr,prob_rr;
       (T10,'Russian Roulette eliminated ',I2,
                    ' particle(s) with probability ',F8.5)
      $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
  ]
]

ELSEIF(IARG = 19)[
    $CNTOUT(NP);(' Photoelectric about to occur',T36,':');
]
ELSEIF(IARG = 20)[
    IF(NPold=NP & IQ(NP)=0 & i_survived_rr = 0)[
      $CNTOUT(NP);(T11,'Photon energy below N-shell',/,
                   T11,'Photon discarded',T36,':');
    ]
    ELSEIF(IQ(NPold) = -1 & i_survived_rr = 0)[
      KE= E(NPold)-RM;
      $CNTOUT(NPold);(T10,'Resulting photoelectron',T36,':');
    ]
    ELSEIF(i_survived_rr > 0)["done some russian roulette"
       IF(NP=NPold-1 | IQ(NPold) ~= -1)[
          IF(i_survived_rr > 1)["eliminated more than the photoelectron"
              OUTPUT i_survived_rr-1,prob_rr;
              (T10,'Russian Roulette eliminated ',I4,
                    ' particle(s) with probability ',F8.5,' plus');
          ]
          OUTPUT prob_rr;
                 (T10,'Russian Roulette eliminated resulting photoelectron',
                      ' with probability ',F8.5);
       ]
       ELSE["NPold could hold the photoelectron"
           KE = E(NPold) - RM;
           $CNTOUT(NPold);(T10,'Resulting photoelectron?',T36,':');
           OUTPUT i_survived_rr,prob_rr;
           (T10,'Russian Roulette eliminated ',I4,
                    ' particle(s) with probability ',F8.5);
       ]
       $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
    ]
]

ELSEIF(IARG = 24)[$CNTOUT(NP);(' Rayleigh scattering occured',T36,':');]

ELSEIF(IARG = 25)[$CNTOUT(NP);(T10,'Fluorescent X-ray created',T36,':');]

ELSEIF(IARG = 26)[$CNTOUT(NP);(T10,'Coster-Kronig e- created',T36,':');]

ELSEIF(IARG = 27)[$CNTOUT(NP);(T10,'Auger electron created',T36,':');]

IF(IARG = 0  &  IWATCH = 2)[OUTPUT  USTEP,TUSTEP,VSTEP,TVSTEP,EDEP;
(T5,'USTEP,TUSTEP,VSTEP,TVSTEP,EDEP',T36,':    ',5(1PE13.4));ICOUNT=ICOUNT+1;]

IF(NP = 1  |  IARG = 0) RETURN;
IF( IARG <= 3)[
       N=NP-1;
       KE = E(N) - ABS(IQ(N))*RM;
       $CNTOUT(N);(T10,'Now on top of stack',T36,':');
]
RETURN;END;
%I4
%C80
%Q1
%E
"*******************************************************************************
"
"
"                       *****************
"                       *               *
"                       * SIGMA.MORTRAN *
"                       *               *
"                       *****************
"
"
"       SIGMA IS A STATISTICAL ANALYSIS ROUTINE DESIGNED TO BE USED BY EGS
"       USER PROGRAMS TO GIVE THE TOTALS OR AVERAGES AND THEIR UNCERTAINTIES
"       OF THE DATA CALCULATED BY THE MONTE CARLO CODE.
"       THE UNCERTAINTIES ARE RETURNED AS PERCENTS.
"
"       VARIABLES
"       =========
"
"       DATA(NDATA,ISTAT)       THE TWO DIMENSIONAL ARRAY OF DATA TO BE
"                               ANALYZED. ISTAT IS THE NUMBER OF STATISTICAL
"                               BATCHES AND NDATA IS THE NUMBER OF ERRORS TO
"                               BE CALCULATED. AFTER THE END OF THE CALCULATION,
"                               DATA(N,1) CONTAINS THE TOTAL OR AVERAGE AND
"                               DATA(N,2) CONTAINS THE ERROR. NDATA SHOULD
"                               BE < OR = $MAXDATA AND ISTAT SHOULD BE < OR =
"                               $STAT WHCH MUST BE DEFINED IN THE MAIN ROUTINE.
"                               Note $STAT must be 2 or greater, even if istat=1
"
"       MODE    =  0 =>         ANALYSIS ON MEAN VALUES WHERE ZERO DATA IS
"                               IGNORED. (eg. STOPPING POWER RATIO)
"               =  1 =>         ANALYSIS ON MEAN VALUES WHERE ZERO DATA IS NOT
"                               IGNORED. (e.g. DOSE)
"               =  2 =>         ANALYSIS ON TOTAL VALUES (eg. TOTAL EDEP)
"
"       IERR    =  0 =>         NORMAL COMPLETION.
"               =  1 =>         WARNING: MODE OUT OF RANGE, DEFAULTED TO 0
"               = 10 =>         ERROR: ONLY ONE BATCH INPUT, QUICK CALCULATION
"                                      DONE. ERROR=99.9%
"               = 11 =>         ERROR: NO NON-ZERO DATA FOUND IN A GIVEN SET,
"                                       ERROR=99.9%
"               = -1 =>         FATAL ERROR: NDATA OR ISTAT OUT OF RANGE, NO
"                                            CALCULATION DONE.
"
"
"               VERSION  1      A.F.B.  83/7/22
"               Version  2      IK      Jan 6 6000 implemented implicit none
"
"*******************************************************************************
%E
SUBROUTINE SIGMA(NDATA,ISTAT,MODE,IERR);

$IMPLICIT-NONE;

$INTEGER NDATA,ISTAT,MODE,IERR;

REPLACE {;COMIN/ERROR/;} WITH {
 ;COMMON/ERROR/DATA($MXDATA,$STAT);
 $REAL data;
}
;COMIN/ERROR,EGS-IO/;

$INTEGER n,non0,i;
$REAL    stat,sdenom;
real*8   emax,avg,error,datum,argmnt;
                                 "It is a good idea to use double precision"
                                 "in cases with very low stat. uncertainties"

DATA EMAX/99.9/;

IERR=0; "ASSUME NORMAL COMPLETION"

"TEST INPUTS AND SET ERROR CODES AND RETURN IF NEEDED."

IF((MODE < 0) | (MODE > 2)) [MODE=2;IERR=1;]

IF((NDATA.LE.0).OR.(NDATA.GT.$MXDATA).OR.(ISTAT.LE.0).OR.(ISTAT.GT.$STAT)) [
  IERR=-1;RETURN;"FATAL INPUT ERROR, RETURN IMMEDIATELY"
]
IF(ISTAT = 1)[
    IERR=10;"ONLY ONE STATISTICAL BATCH, QUICK CALCULATION"
    DO N=1,NDATA[DATA(N,2)=EMAX;]
    RETURN;
]

"MOST ANOMALIES HAVE BEEN HANDLED. NOW DO THE ANALYSIS"

IF(MODE.NE.0)[STAT=FLOAT(ISTAT);SDENOM=STAT*(STAT-1.);]
DO N=1,NDATA[
   NON0=0;             "NON-ZERO COUNTER"
   AVG=0.0;ERROR=0.0;
   DO I=1,ISTAT[
      DATUM=DATA(N,I);
      IF(DATUM.NE.0.0)[NON0=NON0+1;AVG=AVG+DATUM;ERROR=ERROR+DATUM**2;]
   ]
   IF(NON0 = 0)[IERR=11;ERROR=EMAX;GOTO :TRANSFER:;"NO NON-ZERO DATA "]

   ELSEIF((NON0 = 1) & (MODE = 0))[ERROR=EMAX;GOTO:TRANSFER:;"ONLY ONE DATUM"]

   ELSE[
      IF(MODE = 0)[STAT=FLOAT(NON0);SDENOM=STAT*(STAT-1.);]
   ]

   AVG=AVG/STAT;ARGMNT=ERROR-STAT*AVG**2;
   "FLAG -VE SQUARE ROOTS THAT CAN ONLY OCCUR DUE TO ROUND-OFF ERRORS"
   IF(ARGMNT.LT.0.0)[
      OUTPUT ARGMNT,ERROR,STAT,AVG,SDENOM;
      (' ***** - SQ RT IN SIGMA. ARGMNT,ERROR,STAT,AVG,SDENOM='/' ',5E12.4);
      ARGMNT=0.0;
   ]
   ERROR=SQRT(ARGMNT/SDENOM);

   IF(AVG = 0.)[ERROR=EMAX;]ELSE[ERROR=100.*ERROR/ABS(AVG);]

   IF(MODE =  2)AVG=AVG*STAT;

   :TRANSFER:;
   DATA(N,1)=AVG;DATA(N,2)=MIN(EMAX,ERROR);
] "END OF NDATA LOOP"
RETURN;
END; "END OF SIGMA"
;

"*****************************************************************************
" The following are routines that implement
" the alias sampling technique for sampling from a histogram
" distribution coded for use with EGSnrc
"
" subroutine prepare_alias_sampling
" function   alias_sample
"
" I. Kawrakow, January 2000
"
"*****************************************************************************

subroutine prepare_alias_sampling(nsbin,fs_array,ws_array,ibin_array);
"====================================================================
"
" inputs:  nsbin:    number of bins in the histogram
"          fs_array: bin probabilities
"
" Note that we don't need the bin limits at this point, they
" are needed for the actual sampling (in alias_sample)
"
" outputs: ws_array, ibin_array: alias table ready for sampling
"
"====================================================================

implicit none;

$INTEGER  nsbin,ibin_array(nsbin);
$REAL     fs_array(nsbin),ws_array(nsbin);

$INTEGER  i,j_l,j_h;
$REAL     sum,aux;

sum = 0;
DO i=1,nsbin [
  IF( fs_array(i) < 1e-30 ) fs_array(i) = 1e-30;
  ws_array(i) = -fs_array(i); ibin_array(i) = 1;
  sum = sum + fs_array(i);
]
sum = sum/nsbin;

DO i=1,nsbin-1 [

    DO j_h = 1,nsbin [
        IF( ws_array(j_h) < 0 ) [
            IF( abs(ws_array(j_h)) > sum ) GOTO :AT_EXIT1:;
        ]
    ]
    j_h = nsbin;
    :AT_EXIT1:

    DO j_l = 1,nsbin [
        IF( ws_array(j_l) < 0 ) [
            IF( abs(ws_array(j_l)) < sum ) GOTO :AT_EXIT2:;
        ]
    ]
    j_l = nsbin;
    :AT_EXIT2:

    aux = sum - abs(ws_array(j_l));
    ws_array(j_h) = ws_array(j_h) + aux;
    ws_array(j_l) = -ws_array(j_l)/sum;
    ibin_array(j_l) = j_h;
    IF( i = nsbin-1 ) ws_array(j_h) = 1;

]

return;
end;


$REAL function alias_sample(nsbin,xs_array,ws_array,ibin_array);
"===============================================================
"
" samples from an alias table which must have been prepared
" using prepare_alias_table
"
"===============================================================

implicit none;

$INTEGER nsbin,ibin_array(nsbin);
$REAL    xs_array(0:nsbin),ws_array(nsbin);

;COMIN/RANDOM/;

$REAL    v1,v2,aj;
$INTEGER j;

$RANDOMSET v1; $RANDOMSET v2;
aj = 1 + v1*nsbin; j = aj;
IF( j > nsbin ) j = nsbin; " this happens only if $RANDOMSET produces
                           " numbers in (0,1]
aj = aj - j;
IF( aj > ws_array(j) ) [ j = ibin_array(j); ]
alias_sample = (1-v2)*xs_array(j-1) + v2*xs_array(j);
return;
end;
;
%E
;
"==========================end of nrcaux.mortran======================"



%F
C##############################################################################
C
C   This file was automatically generated by configure version 2.0
C   It contains various subroutines and functions for date, time,
C   CPU time, host name, etc.
C
C   Attention: all changes will be lost the next time you run configure!
C
C##############################################################################


C##############################################################################
C
C  EGSnrc egs_system subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C egs_system(command)  runs a system command and returns the status
C                      command must be null-terminated
C*****************************************************************************
      integer function egs_system(command)
      character*(*) command
      integer system, istat
      istat = system(command)
      egs_system = istat
      return
      end

C##############################################################################
C
C  EGSnrc egs_isdir subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C  egs_isdir(file_name)  Returns .true., if the string file_name points to
C                        an existing directory. This version uses the lstat
C                        intrinsic and then tests for bit 14 being set in
C                        the mode element. This works on all Unix systems
C                        that I have access to (Linux, Aix, HP-UX, OSF1,
C                        Solaris, IRIX)
C
C*****************************************************************************

      logical function egs_isdir(file_name)
      implicit none
      character*(*) file_name
      integer*4 lnblnk1, res, array(13), l, lstat
      logical btest
      egs_isdir = .false.
      l = lnblnk1(file_name)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = char(0)
         ! On some systems lstat only works if the string is 0-terminated
      res = lstat(file_name,array)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = ' '
      if( res.eq.0 ) then
            ! Amost all compilers that have the lstat intrinsic return the
            ! file mode in the 3rd array element. But the PGI compiler has
            ! its own opinion on the subject and returns it in the 5th element
            ! That's why the relevant element is written as 3
            ! here, 3 gets replaced by the appropriate element
            ! by the configure script.
          if( btest(array(3),14) ) egs_isdir = .true.
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C***************************************************************************
C
C   egs_fdate(out):  print a 24 char date and time string in the form
C                         'Tue Mar 18 08:16:42 2003'
C                    to the unit specified by out without end of line
C                    i.e. the sequence
C                    write(6,'(a,$)') 'Today is '
C                    call egs_fdate(6)
C                    write(6,'(a)') '. Have a nice date'
C                    should result in something like
C                    Today is Tue Mar 18 08:16:42 2003. Have a nice date
C                    printed to unit 6.
C
C***************************************************************************

      subroutine egs_fdate(ounit)
      integer ounit
      character*24 string
      call fdate(string)
      write(ounit,'(a,$)') string
      end

C***************************************************************************
C
C   egs_get_fdate(string) assignes a 24 char date and time string to string
C                         string must be at least 24 chars long, otherwise
C                         this subroutine has no effect.
C
C***************************************************************************

      subroutine egs_get_fdate(string)
      character*(*) string
      if( len(string).ge.24 ) call fdate(string)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date_and_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


      subroutine egs_date_and_time(vnow)
      integer vnow(8)
      character dat*8,tim*10,zon*5
      call date_and_time(dat,tim,zon,vnow)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*************************************************************************
C
C egs_date(ounit): print a 11 char string in the form
C                     '18-Mar-2003'
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_date(ounit)
      integer ounit
      character string*24, dat*11
      call fdate(string)
      dat(1:2) = string(9:10)
      dat(3:3) = '-'
      dat(4:6) = string(5:7)
      dat(7:7) = '-'
      dat(8:11) = string(21:24)
      write(ounit,'(a,$)') dat
      return
      end

C##############################################################################
C
C  EGSnrc egs_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C $Id: egs_time_v1.f,v 1.1 2003/07/11 19:17:08 iwan Exp $
C*************************************************************************
C
C egs_time(ounit): print a 8 char string in the form hh:mm:ss
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_time(ounit)
      integer ounit
      character string*24
      call fdate(string)
      write(ounit,'(a,$)') string(12:19)
      return
      end

C##############################################################################
C
C  EGSnrc seconds timing subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_secnds(t0): returns seconds passed since midnight minus t0
C
C*****************************************************************************

      real function egs_secnds(t0)
      real t0,t1
      character dat*8,tim*10,zon*5
      integer values(8)
      call date_and_time(dat,tim,zon,values)
      t1 = 3600.*values(5) + 60.*values(6) + values(7) + 0.001*values(8)
      egs_secnds = t1 - t0
      return
      end

C*****************************************************************************
C
C real function egs_tot_time()
C
C   On first call returns seconds passed since 1/1/1970
C   On subsequent calls returns
C     - seconds since last call, if flag = 0
C     - seconds since first call, else
C
C*****************************************************************************

      real function egs_tot_time(flag)
      integer flag
      character dat*8,tim*10,zon*5
      integer vnow(8), vlast(8),i
      real t,egs_time_diff,t0
      data vlast/1970,1,1,5*0/,t0/-1/
      save vlast,t0
      call date_and_time(dat,tim,zon,vnow)
      t = egs_time_diff(vlast,vnow)
      do i=1,8
        vlast(i)=vnow(i)
      end do
      if( t0.lt.0 ) then
        t0 = 0
        egs_tot_time = t
      else
        t0 = t0 + t
        if(flag.eq.0) then
          egs_tot_time = t
        else
          egs_tot_time = t0
        end if
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date and time subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C****************************************************************************
C
C Returns the time difference between vstart and vend
C vstart and vend are integer arrays of dimension 8 with elements
C corresponding to the specification of the data_and_time routine, i.e.
C   array(1) = year
C   array(2) = month of the year   (1...12)
C   array(3) = day of the month    (1...31)
C   array(4) = difference in minutes from UTC
C   array(5) = hour of the day     (1...23)
C   array(6) = minute of the hour  (1...59)
C   array(7) = seconds of the minute (1...59)
C   array(8) = miliseconds of the second (1...999)
C
C Note: this implementation ignores the time difference from UTC field
C
C*****************************************************************************
      real function egs_time_diff(vstart,vend)
      integer    vstart(8),vend(8)
      real       egs_time_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_time_diff = -egs_time_diff_o(vend,vstart)
      else
        egs_time_diff = egs_time_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C day difference between the dates specified by the integer arrays vstart and
C vend. The arrays are v(1)=year, v(2)=month, v(3)=day
C
C******************************************************************************
      integer function egs_day_diff(vstart,vend)
      integer vstart(3),vend(3),egs_day_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_day_diff = -egs_day_diff_o(vend,vstart)
      else
        egs_day_diff = egs_day_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C Returns a 3-letter abreviation of the day of the week in the string day,
C given a day specified by the integer array values
C   values(1)=year, values(2)=month, values(3)=day
C
C******************************************************************************
      subroutine egs_weekday(values,day)
      character*(*) day
      integer       values(3)
      integer       days,vtmp(3),egs_day_diff,aux
      character*3   wdays(7)
      data wdays/'Mon','Tue','Wed','Thu','Fri','Sat','Sun'/
      vtmp(1) = 1970
      vtmp(2) = 1
      vtmp(3) = 1
      days = egs_day_diff(vtmp,values)
      aux = mod(days,7)
      days = 4 + aux
      if( days.gt.7 ) days = days - 7
      day(:len(day)) = ' '
      aux = min(len(day),3)
      day(:aux) = wdays(days)(:aux)
      return
      end

C*****************************************************************************
C
C Same as egs_day_diff above, but assumes that vend specifies a later date
C than vstart.
C
C*****************************************************************************
      integer function egs_day_diff_o(vstart,vend)
      integer vstart(3),vend(3)
      integer    days
      logical    next_month
      integer    tm,m,ty,y
      integer    mdays(12)
      data       mdays/31,28,31,30,31,30,31,31,30,31,30,31/
      days = 0
      ty = vstart(1)
      y  = vend(1)
      tm = vstart(2)
      m  = vend(2)
      next_month = .true.
      do while(next_month)
        if( tm.eq.m.and.ty.eq.y ) then
          next_month = .false.
        else
          days = days + mdays(tm)
          if( tm.eq.2.and.mod(ty,4).eq.0 ) days = days + 1
          tm = tm + 1
          if( tm.gt.12 ) then
            ty = ty + 1
            tm = 1
          end if
        end if
      end do
      days = days + vend(3) - vstart(3)
      egs_day_diff_o = days
      return
      end

C******************************************************************************
C
C Same as egs_time_diff above, but assumes that vend specifies a later date
C than vstart.
C
C******************************************************************************
      real function egs_time_diff_o(vstart,vend)
      integer    vstart(8),vend(8)
      integer    days,hours,minutes,secs,msecs
      integer    egs_day_diff_o
      days = egs_day_diff_o(vstart,vend)
      hours = vend(5) - vstart(5)
      minutes = vend(6) - vstart(6)
      secs = vend(7) - vstart(7)
      msecs = vend(8) - vstart(8)
      egs_time_diff_o = 3600.*(24.*days+hours)+60.*minutes+secs+
     &                  0.001*msecs
      return
      end

C******************************************************************************
C
C Returns in month a 3-letter abreviation of the month specified by mo, if
C mo is between 1 and 12, or an empty string otherwise.
C
C******************************************************************************
      subroutine egs_month(mo,month)
      integer mo
      character*(*) month
      integer iaux
      character*3   months(12)
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      iaux = min(len(month),3)
      month(:len(month)) = ' '
      if( mo.ge.1.and.mo.le.12 ) month(:iaux) = months(mo)(:iaux)
      return
      end

C******************************************************************************
C
C Converts a 3-letter abreviation of a month to its corresponding integer
C value, if the string month is a valid month, or -1 otherwise.
C
C******************************************************************************
      integer function egs_conver_month(month)
      character*3 month
      character*3 months(12)
      integer i
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      do i=1,12
        if( month.eq.months(i) ) then
          egs_conver_month = i
          return
        end if
      end do
      egs_conver_month = -1
      return
      end


C##############################################################################
C
C  EGSnrc egs_etime subroutine
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_etime(): returns CPU time consumed since the start of
C                            the program
C
C*****************************************************************************

      real function egs_etime()
      real tarray(2),etime
      egs_etime = etime(tarray)
      return
      end

C##############################################################################
C
C  EGSnrc canonical system name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the canonical system name as determined by the config.guess script
C or the Windows installation program to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_canonical_system(ounit)
      integer ounit
      write(6,'(a,$)') 'x86_64-unknown-linux-gnu'
      return
      end

C******************************************************************************
C
C Assign the canonical system name as determined by the config.guess script
C or the Windows installation program to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_canonical_system(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('x86_64-unknown-linux-gnu')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'x86_64-unknown-linux-gnu'
      else
        res(:l2) = 'x86_64-unknown-linux-gnu'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc configuration name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the configuration name as specified suring the configuration
C process to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_configuration_name(ounit)
      integer ounit
      write(6,'(a,$)') 'linux'
      return
      end

C******************************************************************************
C
C Assign the configuration name as specified suring the configuration
C process to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_configuration_name(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('linux')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'linux'
      else
        res(:l2) = 'linux'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc hostname subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C Print the host name to the unit specified by ounit without inserting
C a new line character.
C
C*****************************************************************************

      subroutine egs_print_hostnm(ounit)
      integer ounit
      character*256 string
      integer res,hostnm,lnblnk1
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      write(ounit,'(a,$)') string(:lnblnk1(string))
      return
      end

C*****************************************************************************
C
C Assign the host name to the string pointed to be hname.
C
C*****************************************************************************

      subroutine egs_get_hostnm(hname)
      character*(*) hname
      character*256 string
      integer res,hostnm,lnblnk1,l1,l2,l
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      l1 = lnblnk1(string)
      l2 = len(hname)
      hname(:l2) = ' '
      l = min(l1,l2)
      hname(:l) = string(:l)
      return
      end

%M
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc I/O functions                                                       "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Iwan Kawrakow, 2003                                       "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Ernesto Mainegra-Hing                                     "
"                   Blake Walters                                             "
"                   Frederic Tessier                                          "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
" Iwan Kawrakow, 2004:                                                        "
"                                                                             "
" re-factored egs_init so that it is easy to program a corresponding egs_init "
" when one loads a EGSnrc user code as a library and therefore no command     "
" line arguments are available. (see beam library).                           "
"                                                                             "
"#############################################################################"


%I4
%C80
%Q1
!INDENT F2;
REPLACE {$max_unit} WITH {99}

REPLACE {$egs_debug(#,#);} WITH {;} " no need for debug info "

REPLACE {;COMIN/my_times/;} WITH {;
  common/my_times/ t_elapsed, t_cpu, t_first;
  $REAL            t_elapsed, t_cpu;
  integer          t_first(8);
  real             egs_tot_time,egs_etime;
};

"******************************************************************************
" subroutine egs_init;
"******************************************************************************
" A call to this subroutine becomes Step 0 in every EGSnrc user code.
" Its purpose is to:
"   - initialize arrays and default values for various transport options
"     (this was previously done in block data, but due to the GNU Fortran
"     compiler complaints and extremely slow compilation when the number of
"     regions is large, we decided to remove block data from the source)
"   - Process command line arguments specifying input file, pegs4 data file,etc.
"     In the current version the following command line options are supported:
"
"       -i or --input ifile          Input file is ifile.egsinp
"
"       -p or --pegs-file file_name  The pegs4 data file is file_name.pegs4dat
"                                    The system will look for it in the
"                                    HEN_HOUSE and the user's pegs4 data areas
"
"       -o or --output ofile         Output data will be writtent to
"                                    ofile.egslog, ofile.egslst, etc., instead
"                                    of ifile.egslog, etc.
"
"       -H or --hen-house dir        Change the HEN_HOUSE to be dir instead
"                                    of the directory specified in the
"                                    machine.macros file.
"
"       -e or --egs-home dir         Change EGS_HOME to be dir instead of
"                                    the directory specified by the EGS_HOME
"                                    environment variable
"
"       -h or --help                 Print a help message and exit
"                                    ignoring all other arguments
"
"       -b or --batch                Specify a 'batch' run. The difference
"                                    between a 'batch' run and an interactive
"                                    run is that in 'batch' mode unit 6 is
"                                    connected to a file, whereas in intarctive
"                                    mode unit 6 goes to the standard output.
"                                    The file name in batch run is determined
"                                    as follows:
"                                     - ofile.egslog, if ofile was specified
"                                       with the -o option
"                                     - ifile.egslog, if there was no -o option
"                                       used but an input file was specified
"                                       with -i
"                                     - test.egslog, if neither -i nor -o was
"                                       used.
"
"       -P or --parallel n           Tell the system that this run is part of
"                                    a parallel run and that this is job number
"                                    n (so that the random number sequence
"                                    can be initialized differently)
"
"       -c or --chunk N              Tell the system to use N histories per
"                                    calculation 'chunk' in parallel runs.
"
"   - open default EGSnrc data file units thus avoiding the necessity for
"     symbolik links
"   - open user code specific I/O units if a .io file is found in
"     the user code area. The format of this file is an integer
"     followed by a string on every line.
"     The string specifies the file extension
"     and the integer the unit number this file should connect to, e.g.
"       4   .egsdat
"       15  .egserr
"       1   .egslst
"     will result in connecting unit 4 to the file ifile.egsdat
"     (or ofile.egsdat, see above) to unit 4, [i|o]file.egserr to unit 15, etc.
"  -  Outputs a summary to standard output about configuration etc
"  -  Creates a temporary working directory in the user code area
"
"  The files always opened (appart from the ones specified in the .io file)
"  are the following:
"
"  1. The PEGS data file (and so, for now, the -p pegs_file command line
"     option must be always given)
"     The algorithm for looking for a PEGS data file is:
"       - The file name passed with -p. In this way, PEGS files can be located
"         everywhere on the file system (not just in $HEN_HOUSE/pegs4/data
"         and $EGS_HOME/pegs4/data) if the absolute path name is given after
"         the -p option.
"       - $EGS_HOME/pegs4/data/pegs_file or
"         $EGS_HOME/pegs4/data/pegs_file.pegs4dat
"       - $HEN_HOUSE/pegs4/data/pegs_file or
"         $HEN_HOUSE/pegs4/data/pegs_file.pegs4dat
"     See note below on how $HEN_HOUSE and $EGS_HOME are determined
"
"  2. If a -i ifile option was given as argument, ifile.egsinp is
"     opened as fortran unit 5.
"     The input file MUST be in the user code directory on $EGS_HOME
"
"  3. If the run is a batch run (the -b option was present on the command
"     line), fortran unit 6 is connected to an output file with a .egslog
"     extension instead of going to standard output.
"     The algorithm for determining the .egslog file name is the following:
"       - If the -o ofile option was present, the output to unit 6 will go
"         to ofile.egslog
"       - If there was no -o option, but there is an inpuit file specified
"         with -i ifile, output to unit 6 will go to ifile.egslog
"       - If neither of the above is true, the output will go to
"         test.egslog.
"
"  Note on determining EGS_HOME:
"  EGS_HOME is normally taken from the environment variable EGS_HOME.
"  However, one can overwrite the environment by giving the
"    -e | --egs-home  new_egs_home_location
"  option on the command line.
"  EGS_HOME must be set, either via the environment or via the command line,
"  otherwise the job will abort.
"
"  Note on determining HEN_HOUSE:
"  HEN_HOUSE is set to the value defined in machine.macros, which is
"  created by the configure script or the configuration wizard in the GUI
"  This value can be overwritten by giving the
"    -H | --hen-house new_hen_house_location
"  option on the command line.
"  HEN_HOUSE is NOT taken from the environment.
"
"  The name of the temporary working directory is created using
"    egsrun_getpid_ifile_hostname, if there was an input file, or
"    egsrun_getpid_noinput_hostname, if there was no input file specified.
"  In the above, getpid is the process id returned bt the getpid() intrinsic
"  and hostname is the host name as determined by egs_get_hostnm().
"  During run time, all output from the program (the .egslog file and
"  all other files specified in the .io file) is kept in the
"  temporary working directory. After succesful completion, egs_finish
"  moves all output back to the user code area and removes the
"  temporary working directory. This implies that if for whatever reason
"  the job terminates prematurely, the temporary working directory
"  with all output will be left behind.
"
"
"
"******************************************************************************
subroutine egs_init;
"******************************************************************************
implicit none;
;COMIN/my_times/;
$REAL dum;

/*
t_elapsed = 0; t_cpu = egs_etime(); dum = egs_tot_time(1);
call egs_date_and_time(t_first);
*/
call egs_set_defaults;
call egs_check_arguments;
call egs_init1;
return; end;

"******************************************************************************
subroutine egs_init1;
"******************************************************************************

implicit none;
;COMIN/EGS-IO,MISC,my_times/;
integer   l, lnblnk1, l1, l2;
integer   i;
character arg*256,tmp_string*512, tmp1_string*512, ucode_dir*512,
          line*80,
          line1*80,dattim*24;
$LOGICAL  have_input,egs_isdir,egs_strip_extension,ex,
          on_egs_home,is_opened;
$INTEGER  mypid;
integer   getpid;
integer   istat, egs_system, u, pos1, pos2,egs_get_unit,itmp;
$REAL     dum;
$declare_write_buffer;

t_elapsed = 0; t_cpu = egs_etime(); dum = egs_tot_time(1);
call egs_date_and_time(t_first);

$set_string(line,'=');
$set_string(line1,'.');

" Handy macros for checking command line arguments "
REPLACE {$check_get_argument(#,#,#);} WITH {
  have_arg = .false.;
  DO i=1,narg-1 [
      call getarg(i,{P3}); l = lnblnk1({P3});
      IF( ( l = lnblnk1({P1}) & {P3}(:l) = {P1} ) |
          ( l = lnblnk1({P2}) & {P3}(:l) = {P2} ) ) [
          have_arg = .true.; call getarg(i+1,{P3}); EXIT;
      ]
  ]
};

REPLACE {$check_argument(#,#,#);} WITH {
  have_arg = .false.;
  DO i=1,narg [
      call getarg(i,{P3}); l = lnblnk1({P3});
      IF( ( l = lnblnk1({P1}) & {P3}(:l) = {P1} ) |
          ( l = lnblnk1({P2}) & {P3}(:l) = {P2} ) ) [
          have_arg = .true.; EXIT;
      ]
  ]
};

IF(~is_pegsless)[
" Get the pegs4 data file "
on_egs_home = .false.;
inquire(file=pegs_file,exist=ex);
IF( ex ) [
    kmpi=egs_get_unit(kmpi);
    IF(kmpi<0)[
      $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
    ]
    open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
    $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
    goto :found_pegs_file:;
]
arg = $cstring(pegs_file);
ex = egs_strip_extension(arg,'.pegs4dat');
l = lnblnk1(egs_home); l1 = lnblnk1('pegs4data') + 2*lnblnk1($file_sep);
l2 = lnblnk1(arg) + lnblnk1('.pegs4dat');
IF( l + l1 + l2 > 256 ) [
    $egs_warning(*,'pegs4 data file name (including absolute path)');
    $warning('(a,i4,a)','is too long (',l+l1+l2,') characters');
]
ELSE [
    pegs_file = $cstring(egs_home) // 'pegs4' // $file_sep // 'data' //
      $file_sep // $cstring(arg) // '.pegs4dat';
    $egs_debug('(a,a)','checking for pegs file ',$cstring(pegs_file));
    inquire(file=pegs_file,exist=ex);
    IF( ex ) [
        kmpi=egs_get_unit(kmpi);
        IF(kmpi<0)[
          $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
        ]
        open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
        $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
        on_egs_home = .true.;
        goto :found_pegs_file:;
    ]
]
l = lnblnk1(hen_house);
IF( l + l1 + l2 > 256 ) [
    $egs_warning(*,'pegs4 data file name (including absolute path)');
    $warning('(a,i4,a)','is too long (',l+l1+l2,') characters');
]
ELSE [
    pegs_file = $cstring(hen_house) // 'pegs4' // $file_sep // 'data' //
       $file_sep // $cstring(arg) // '.pegs4dat';
    $egs_debug('(a,a)','checking for pegs file ',$cstring(pegs_file));
    inquire(file=pegs_file,exist=ex);
    IF( ex ) [
        kmpi=egs_get_unit(kmpi);
        IF(kmpi<0)[
          $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
        ]
        open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
        $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
        goto :found_pegs_file:;
    ]
]

$egs_fatal(*,'could not find pegs4 file named ',$cstring(arg));

]

:found_pegs_file:
;
" Open egsnrc data files "
$set_string(tmp_string,' ');
tmp_string = $cstring(hen_house) // 'data' // $file_sep;

"set proposed unit numbers"
i_nist_data=76;
i_incoh=78;
i_photo_relax=77;
i_photo_cs=79;
i_mscat=11;

REPLACE {$open_data_file(#,#,#,#);} WITH {;
    $set_string({P2},' ');
    {P2} = $cstring({P1}) // {P3};
    inquire(file={P2},exist=ex,opened=is_opened,number=itmp);
    IF( ~ex ) [
        $egs_fatal(*,'EGSnrc data file ',{P3},' does not exist');
    ]
    IF( ~is_opened ) [
        {P4}=egs_get_unit({P4});
        IF({P4}<0)[
          $egs_fatal(*,'failed to get a free Fortran I/O unit for data file ',
                       $cstring({P2}));
        ]
        open({P4},file={P2},status='old',err=:data_file_error:);
    ]
    ELSE [ {P4} = itmp; ]
    $egs_debug('(a,a)','opened data file ',$cstring({P2}));
};
$open_data_file(tmp_string,tmp1_string,'photo_cs.data',$PHOCSUNIT);
$open_data_file(tmp_string,tmp1_string,'msnew.data',$MSCAT-DATAFILE);
$open_data_file(tmp_string,tmp1_string,'incoh.data',$INCOHUNIT);
$open_data_file(tmp_string,tmp1_string,'photo_relax.data',$PHOTOUNIT);

$set_string(ucode_dir,' ');
ucode_dir = $cstring(egs_home) // $cstring(user_code) // $file_sep;

have_input = .false.;
i_input=5;
IF( lnblnk1(input_file) > 0 ) [
    have_input = .true.;
    l = lnblnk1(egs_home); l1 = lnblnk1(user_code)+1;
    l2 = lnblnk1(input_file) + lnblnk1('.egsinp');
    IF( l + l1 + l2 > 1024 ) [
        $egs_fatal(*,'input file name (including path) is too long ',l+l1+l2);
    ]
    ex = egs_strip_extension(input_file,'.egsinp');
    tmp_string = $cstring(ucode_dir) // $cstring(input_file) // '.egsinp';
    inquire(file=tmp_string,exist=ex);
    IF( ~ex ) [
        $egs_fatal(*,'Input file ',$cstring(tmp_string),' does not exist.');
    ]
    $AVAILABLE_UNIT(i_input,tmp_string);
    open(i_input,file=tmp_string,status='old',err=:open_input_error:);
]

" Construct a temporary directory name to run from "
$set_string(work_dir,' ');
work_dir = 'egsrun_'; mypid = getpid();
call egs_itostring(work_dir,mypid,.false.);
call egs_get_hostnm(host_name);
IF( lnblnk1(host_name) < 1 ) host_name = 'unknown';
IF( have_input ) [
    work_dir = $cstring(work_dir) // '_' // $cstring(input_file) //
               '_' // $cstring(host_name) // $file_sep;
]
ELSE [
    work_dir = $cstring(work_dir) // '_noinput_' // $cstring(host_name) //
               $file_sep;
]
$set_string(tmp_string,' ');
tmp_string = $cstring(ucode_dir) // $cstring(work_dir);
DO i=1,lnblnk1(tmp_string) [
    IF( tmp_string(i:i) = '/' ) [
        tmp_string(i:i) = $file_sep;
    ]
]
ex = egs_isdir(tmp_string);
IF( ex ) [
 $egs_fatal(*,'a directory named ',$cstring(tmp_string),' already exists?');
]
tmp1_string = 'mkdir ' // $cstring(tmp_string);
l = lnblnk1(tmp1_string); tmp1_string(l+1:l+1) = char(0);
                 " some systems need the command string to be 0 terminated"
istat = egs_system(tmp1_string);
IF( istat ~= 0 ) [
    $egs_fatal(*,'failed to create working directory ',$cstring(tmp1_string));
]

call egs_open_units(.true.);

" Now print a summary of what happened "
$egs_info('(a)',line);
$egs_info('(a,a,t55,a,$)','EGSnrc version 4 for ',$CANONICAL_SYSTEM,' ');
call egs_get_fdate(dattim);
$egs_info('(a,/,a)',dattim,line);

REPLACE {$write_description(#);} WITH {;
  $egs_info('(a,$)',{P1}); l = pos2 - lnblnk1({P1});
  $egs_info('(a,$)',line1(:l));
};
pos1 = lnblnk1('output file(s)');
pos2 = 80 - lnblnk1($CONFIGURATION_NAME);
pos2 = min(pos2,80-lnblnk1(user_code));
$set_string(tmp_string,' '); tmp_string = pegs_file;
call egs_strip_path(tmp_string);
ex = egs_strip_extension(tmp_string,'.pegs4dat');
IF( on_egs_home ) [ tmp_string = $cstring(tmp_string) // ' on EGS_HOME'; ]
ELSE [ tmp_string = $cstring(tmp_string) // ' on HEN_HOUSE'; ]
IF( lnblnk1(tmp_string) > lnblnk1(pegs_file) ) [
    $set_string(tmp_string,' '); tmp_string = pegs_file;
]
pos2 = min(pos2,80-lnblnk1(tmp_string));
pos2 = min(pos2,80-lnblnk1(host_name));
IF( have_input ) pos2 = min(pos2,80-lnblnk1(input_file));
pos2 = min(pos2,80-lnblnk1(output_file));
IF( pos2 < pos1+2 ) pos2 = pos1 + 2;

$write_description('configuration'); $egs_info('(a)',$CONFIGURATION_NAME);
$write_description('user code'); $egs_info('(a)',$cstring(user_code));
$write_description('pegs file'); $egs_info('(a)',$cstring(tmp_string));
$write_description('using host'); $egs_info('(a)',$cstring(host_name));
IF( have_input ) [
    $write_description('input file'); $egs_info('(a)',$cstring(input_file));
]
$write_description('output file(s)'); $egs_info('(a)',$cstring(output_file));
IF( n_parallel > 0 ) [
    $write_description('number of parallel jobs');
    $egs_info('(i2)',n_parallel);
    $write_description('job number'); $egs_info('(i2)',i_parallel);
]
$egs_info('(a)',line);

return;

" Errors "
:open_input_error:
$egs_fatal(*,'failed to open input file ',$cstring(tmp_string));

:open_pegs_error:
$egs_fatal(*,'failed to open existing pegs file ',$cstring(pegs_file));

:data_file_error:
$egs_fatal(*,'failed to open EGSnrc data file ',$cstring(tmp1_string));

return; end;

"*****************************************************************************
subroutine egs_check_arguments;
"*****************************************************************************
implicit none;

;COMIN/EGS-IO/;

character arg*256,tmp_string*512, line1*80;
$LOGICAL  have_arg,egs_isdir,egs_strip_extension,ex,
          on_egs_home;
integer   narg, iargc, i, lnblnk1, l, l2,i_help,egs_get_unit;
$declare_write_buffer;

narg = iargc();
IF( narg < 1 ) return;

" Check for hen_house "
$check_get_argument('-H','--hen-house',arg);
IF( have_arg ) [
    l = lnblnk1(arg); $set_string(hen_house,' ');
    IF( l > 0 ) [
        IF( l > 254 ) [
            $egs_fatal('(a,i5)',' HEN_HOUSE argument is too long',l);
        ]
        hen_house(:l) = $cstring(arg);
        IF( hen_house(l:l) ~= $file_sep ) hen_house(l+1:l+1) = $file_sep;
    ]
    ELSE [
        $egs_fatal('(a)',' empty argument after -H');
    ]
    DO i=1,lnblnk1(hen_house) [
        IF( hen_house(i:i) = '/' ) [
            hen_house(i:i) = $file_sep;
        ]
    ]
]
IF( ~egs_isdir(hen_house) ) [
    $egs_warning('(a,a)',' HEN_HOUSE directory ',$cstring(hen_house));
    $warning('(a)','does not exist. Hope you know what you are doing.');
]

" Check if the user requested help "
$check_argument('-h','--help',arg);
IF( have_arg ) [
  call getarg(0,arg); call egs_strip_path(arg);
  $egs_info('(//,a,a,a,//)','Usage: ',$cstring(arg),' [args] ');
  tmp_string = $cstring(hen_house) // 'pieces/help_message';
  i_help=98;
  i_help=egs_get_unit(i_help);
  IF(i_help<0)[
     $egs_fatal(*,'failed to get a free Fortran I/O unit for help file');
  ]
  open(i_help,file=tmp_string,status='old',err=:no_help_file:);
  LOOP [
      read(i_help,'(a)',err=:end_of_help:,end=:end_of_help:) line1;
      $egs_info('(a)',line1);
  ]
  :end_of_help:;
  $CALL_EXIT(0);
  :no_help_file:;
  $egs_fatal(*,'Did not find the help_message file!');
]

" Check for batch option "
$check_argument('-b','--batch',arg);
IF( have_arg ) is_batch = .true.;

" Check for parallel run option"
$check_get_argument('-P','--parallel',arg);
IF( have_arg ) [
    read(arg,*,err=:wrong_parallel_arg:) n_parallel;
    IF( n_parallel < 0 ) goto :wrong_parallel_arg:;
    goto :ok_parallel_arg:;
    :wrong_parallel_arg:;
    $egs_warning(*,
     ' Wrong/missing parallel job number argument, -P option ignored');
    n_parallel = 0;
    :ok_parallel_arg:;
]

$check_get_argument('-j','--job',arg);
IF( have_arg ) [
    read(arg,*,err=:wrong_job_arg:) i_parallel;
    IF( i_parallel < 0 ) goto :wrong_job_arg:;
    goto :ok_job_arg:;
    :wrong_job_arg:;
    $egs_warning(*,' Wrong/missing job argument, -j option ognored');
    i_parallel = 0;
    :ok_job_arg:;
]

$check_get_argument('-f','--first-job',arg);
IF( have_arg ) [
    read(arg,*,err=:wrong_first_job_arg:) first_parallel;
    IF( first_parallel < 1 ) goto :wrong_first_job_arg:;
    goto :ok_first_job_arg:;
    :wrong_first_job_arg:;
    $egs_warning(*,' Wrong/missing first job argument, -f option ognored');
    first_parallel = 1;
    :ok_first_job_arg:;
]

IF( n_parallel > 0 | i_parallel > 0 ) [
    IF( n_parallel*i_parallel = 0 ) [
        $egs_warning(*,'You need to specify number of jobs AND job number ',
          '=> will not use parallel run ');
        n_parallel = 0; i_parallel = 0;
    ]
    IF( first_parallel > i_parallel ) [
        $egs_warning(*,'i_parallel (',i_parallel,
          ') can not be smaller than first_parallel (',first_parallel,')');
        first_parallel = i_parallel;
    ]
]

$egs_debug('(a,a)','HEN_HOUSE is ',$cstring(hen_house));

" Check for egs_home "
$check_get_argument('-e','--egs-home',arg);
IF( have_arg ) [
    l = lnblnk1(arg); $set_string(egs_home,' ');
    IF( l = 0 ) [
        $egs_fatal('(a)',' empty argument after -e');
    ]
    IF( l > 254 ) [
        $egs_fatal('(a,i5)',' EGS_HOME argument is too long ',l);
    ]
    egs_home(:l) = $cstring(arg);
    IF( egs_home(l:l) ~= $file_sep ) egs_home(l+1:l+1) = $file_sep;
    DO i=1,lnblnk1(egs_home) [
        IF( egs_home(i:i) = '/' ) [
            egs_home(i:i) = $file_sep;
        ]
    ]
]
IF( ~egs_isdir(egs_home) ) [
  $egs_fatal(*,' EGS_HOME directory ',$cstring(egs_home),' does not exist.');
]
$egs_debug('(a,a)','EGS_HOME is ',$cstring(egs_home));

" Get the pegs4 data file "
on_egs_home = .false.;
is_pegsless=.false.;
$check_get_argument('-p','--pegs-file',arg);
IF( ~have_arg ) [
    $egs_warning(*,'No pegs4 file name supplied.  Will assume you are running
 in pegs-less mode with media details specified in input file.');
    is_pegsless=.true.;
]
ELSE[
    pegs_file = $cstring(arg);
]

" Deduct the user code name from the executable name "
call egs_get_usercode(user_code);

" Check for an input file "
$check_get_argument('-i','--input',arg);
IF( have_arg ) [
    ex = egs_strip_extension(arg,'.egsinp');
    l2 = lnblnk1(arg) + lnblnk1('.egsinp');
    IF( l2 > 256 ) [
        $egs_fatal(*,'input file name is too long ',l2);
    ]
    input_file = $cstring(arg);
]

" Check for an output file option "
$check_get_argument('-o','--output',arg);
IF( have_arg ) [
    l = lnblnk1(arg);
    IF( l > 256 ) [
        $egs_fatal(*,'output file name is too long ',l);
    ]
    output_file(:l) = $cstring(arg);
]
ELSE [
    IF( lnblnk1(input_file) > 0 ) [
        output_file(:lnblnk1(input_file)) = $cstring(input_file);
    ]
    ELSE [
        output_file = 'test';
    ]
]

return; end;

"******************************************************************************
subroutine egs_open_units(flag);
"******************************************************************************
" Open output files.
" Looks for output file definition in user_code.io.
" In addition, if it is a batch run connects a .egslog file to unit 6.
" If flag is .true., open the files in the temporary working directory,
" else open them in the user code directory.
"******************************************************************************
implicit none;
$LOGICAL flag;

;COMIN/EGS-IO/;

character tmp_string*1024, tmp1_string*1024, tmp2_string*1024, ucode_dir*1024,
          input_line*100, arg*20;
integer   i,lnblnk1,u,l,istart,egs_get_unit,i_iofile;
$LOGICAL  ex,is_open;
$declare_write_buffer;

$set_string(tmp_string,' '); $set_string(ucode_dir,' ');
ucode_dir = $cstring(egs_home) // $cstring(user_code) // $file_sep;
IF( flag ) [
    tmp_string = $cstring(ucode_dir) // $cstring(work_dir);
]
ELSE [
    tmp_string = $cstring(ucode_dir);
]

tmp_string = $cstring(tmp_string) // $cstring(output_file);
IF( i_parallel > 0 ) [
    tmp_string = $cstring(tmp_string) // '_w';
    call egs_itostring(tmp_string,i_parallel,.false.);
]
$set_string(tmp1_string,' ');
i_log=6;
IF( is_batch ) [
    tmp1_string = $cstring(tmp_string) // '.egslog';
    $AVAILABLE_UNIT(i_log,tmp1_string);
    open(i_log,file=tmp1_string,status='unknown',err=:output_file_error:);
]
$set_string(tmp2_string,' ');
tmp2_string = $cstring(ucode_dir) // $cstring(user_code) // '.io';
inquire(file=tmp2_string,exist=ex);
n_files = 0;
IF( ex ) [
    i_iofile=99;
    i_iofile=egs_get_unit(i_iofile);
    IF (i_iofile<1)[
      $egs_fatal(*,'failed to get a free Fortran I/O unit for .io file');
    ]
    open(i_iofile,file=tmp2_string,status='old',err=:io_file_error:);
    LOOP [
        read(i_iofile,'(a)',err=:end_of_iofile:,end=:end_of_iofile:) input_line;
        IF( input_line(1:1) = '#' ) NEXT;
        "The DEC and SGI compilers fail at the following statement!"
        "read(input_line,*,err=:end_of_iofile:,end=:end_of_iofile:) u,arg;"
        read(input_line,*,err=:end_of_ioline:,end=:end_of_ioline:) u;
        istart = 1;
        DO i=lnblnk1(input_line),1,-1 [
            IF( input_line(i:i) = ' ' ) [ istart = i+1; EXIT; ]
        ]
        DO i=1,len(arg) [ arg(i:i) = ' '; ]
        DO i=istart,lnblnk1(input_line) [
            arg(i+1-istart:i+1-istart) = input_line(i:i);
        ]
        inquire(unit=u,opened=is_open);
        IF( is_open ) [
            $egs_warning('(a,i3,a,a,a,/,a,/,a,/)',
              'Unit ',u,' which you want to connect to a ',
              $cstring(arg),' file ',
           'is already in use. Will assume this code is being used as',
           'a shared library source and this file will be opened explicitly.');
        ]
        ELSE[
            n_files = n_files + 1;
            IF( n_files > $mx_units ) [
               $egs_fatal(*,'Too many units requested in .io.',
                ' Increas $mx_units and retry');
            ]
            file_units(n_files) = u;
            $set_string(file_extensions(n_files),' ');
            l = lnblnk1(arg);
            IF( l > $max_extension_length ) [
                $egs_fatal(*,'extension ',$cstring(arg),' is longer than ',
                  $max_extension_length,' chars. ',
                  'Increase $max_extension_length and retry ');
            ]
            file_extensions(n_files) = $cstring(arg);
            tmp1_string = $cstring(tmp_string) // $cstring(arg);
            open(u,file=tmp1_string,status='unknown');
            $egs_debug('(a,a,a,i3)','connected ',$cstring(tmp1_string),
              ' to unit ',u);
        ]
        :end_of_ioline:
    ]
    :end_of_iofile:
    close(i_iofile);
]
return;

:output_file_error:
$egs_fatal(*,'failed to open output file ',$cstring(tmp1_string));

:io_file_error:
$egs_fatal(*,'failed to open existing .io file',$cstring(tmp2_string));
return; end;


"******************************************************************************
subroutine egs_finish;
"******************************************************************************
" This subroutine becomes the last step in every EGSnrc user code.
" It's purpose is to move the all output files from the temporary working
" directory to the user code directory and to remove the working dir.
" This was previously done by the egs_run script.
" This routine also prints a summary to standard output.
"******************************************************************************
implicit none;
;COMIN/EGS-IO,my_times/;
character line*80,base*512,base1*512,tmp_string*512,junk_file*128,fname*512;
character dattim*24;
integer  i,l,lnblnk1,istat,egs_system,n_open,unlink,i_junk,egs_get_unit;
$LOGICAL is_open,egs_isdir;
$REAL    t1,t2,tt_cpu;
$declare_write_buffer;

$set_string(line,'=');
IF( n_parallel = 0 | i_parallel > 0 ) [
 "i.e. we want that info if this is not a parallel run (n_parallel = 0)"
 "or if it is parallel but it is not the final egs_finish (after combining"
 "results from parallel runs)"
t_elapsed = egs_tot_time(1); tt_cpu = egs_etime() - t_cpu;
t1 = t_elapsed; t2 = t1/3600;
$egs_info('(//a,/,a,/)',line,'Finished simulation');
$egs_info('(2x,a,t30,f9.1,a,f7.3,a)','Elapsed time: ',t1,' s (',t2,' h)');
t1 = tt_cpu; t2 = t1/3600;
$egs_info('(2x,a,t30,f9.1,a,f7.3,a)','CPU time:',t1,' s (',t2,' h)');
$egs_info('(2x,a,t30,f10.3)','Ratio:',t_elapsed/tt_cpu);
]
call egs_get_fdate(dattim);
$egs_info('(//a,t56,a,/,a)','End of run ',dattim,line);

" Close all I/O units "
n_open=0;
$set_string(base,' ');
base = $cstring(egs_home) // $cstring(user_code);
DO i=1,$max_unit [
    IF( is_batch | i ~= i_log ) [
      inquire(i,opened=is_open);
      IF( is_open ) [
         inquire(i,name=fname);
         IF(index($cstring(fname),$cstring(base))>0)[
              close(i); n_open = n_open+1; ]
      ]
    ]
]

"If work_dir is empty, this is a second call to egs_finish for the last"
"job in a parallel run. This implies that the temporary working "
"directory has been already removed => just return"

IF( lnblnk1(work_dir) = 0 ) [ return; ]

" Now generate a junk file in the working directory so that the move "
" command does not fail in case there are no files "
$set_string(base,' ');
base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
        $cstring(work_dir);
DO i=1,lnblnk1(base) [
    IF( base(i:i) = '/' ) [
        base(i:i) = $file_sep;
    ]
]
IF( egs_isdir(base) ) [
    $set_string(tmp_string,' '); $set_string(junk_file,' ');
    junk_file = $cstring(work_dir);
    l = lnblnk1(junk_file); junk_file(l:l) = ' ';
    junk_file = $cstring(junk_file) // '_junk';
    tmp_string = $cstring(base) // $cstring(junk_file);
    i_junk=99;
    i_junk=egs_get_unit(i_junk);
    IF(i_junk<0)[
      $egs_fatal(*,'failed to get a free Fortran I/O unit for junk file');
    ]
    open(i_junk,file=tmp_string,status='unknown');
    write(i_junk,*) 'junk';
    close(i_junk);

    " Move all files from the working directory to the user code directory "
    $set_string(base1,' ');
    base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
            $cstring(work_dir);
    base1 = $cstring(egs_home) // $cstring(user_code);
    $set_string(tmp_string,' ');
    tmp_string = $move_file // $cstring(base) // '*  ' // $cstring(base1);
    l = lnblnk1(tmp_string)+1;
    tmp_string(l:l) = char(0);
    istat = egs_system(tmp_string);
    IF( istat ~= 0 ) [
        $egs_warning(*,'Moving files from working directory failed ?');
        $warning(*,'=> will not remove working directory');
    ]
    ELSE [
        " Remove the working directory "
        $set_string(tmp_string,' ');
        tmp_string = $remove_directory // $cstring(base);
        l = lnblnk1(tmp_string)+1; tmp_string(l:l) = char(0);
        istat = egs_system(tmp_string);
        IF( istat ~= 0 ) [
            $egs_warning(*,'Failed to remove working directory ',
              $cstring(work_dir));
        ]
        " Remove the junk file "
        $set_string(tmp_string,' ');
        tmp_string = $cstring(base1) // $file_sep // $cstring(junk_file);
        l = lnblnk1(tmp_string)+1; tmp_string(l:l) = char(0);
        istat = unlink(tmp_string);
    ]
]

" Now set work_dir to blank so that all I/O stuff after egs_finish ends up"
" in the user code directory "
$set_string(work_dir,' ');

return; end;

"******************************************************************************
subroutine egs_set_defaults;
"******************************************************************************
" Replaces BLOCK DATA "
implicit none;
$COMIN-SET-DEFAULTS;

integer  i,j,lnblnk1;
$TYPE MEDIA1(24); EQUIVALENCE(MEDIA1(1),MEDIA(1,1));
character fool_dec;
data MEDIA1/$S'NAI                     '/;
data fool_dec/'/'/;
data fool_intel_optimizer/.false./;

vacdst = 1e8;
$set-region-by-region-defaults;

eii_flag = 0; "No EII by default. "
eii_xfile = 'Off';
eii_L_factor = 1.0; "No L-shell EII xsection scaling by default"
"========================================="
"See egsnrc.macros for defaults used below"
"========================================="
xsec_out = $XSEC-DEFAULT;
photon_xsections = $XDATA-DEFAULT;"default photon xsection"
comp_xsections = $COMP-XDATA-DEFAULT;
eadl_relax = $EADL-RELAX-DEFAULT;
mcdf_pe_xsections = $MCDF-PE-DEFAULT;
"Ali:photonuc, 2 lines"
photonuc_xsections = $PHOTONUC-XDATA-DEFAULT;
"EMH:emf"
ExIN=$ExDEF;EyIN=$EyDEF;EzIN=$EzDEF;
" Initially set to input values, could change with regions"
" by converting it to an array over all regions. This is  "
" currently implemented ONLY for the C++ applications     "
BxIN=$BxDEF;ByIN=$ByDEF;BzIN=$BzDEF; EMLMTIN=$EMLMTDEF;
Bx=BxIN;    By=ByIN;    Bz=BzIN;
Bx_new=Bx;  By_new=By;  Bz_new=Bz;
emfield_on=.false.;
IF( ExIN**2+EyIN**2+EzIN**2 + BxIN**2+ByIN**2+BzIN**2 > 0 ) [
    emfield_on=.true.
]

DO i=1,$MXMED [
    iraylm(i) = 0; "Rayleigh data available?"
    DO j=1,len(iray_ff_file(i)) [ iray_ff_file(i)(j:j) = ' ';]
    DO j=1,len(iray_ff_media(i)) [ iray_ff_media(i)(j:j) = ' ';]
      " set all thresholds to zero "
    /ae(i),ap(i),ue(i),up(i),te(i),thmoll(i)/=0;
]
DO i=1,$MXSHXSEC [
  DO j=1,$MXELEMENT [ binding_energies(i,j) = 0; ]
]
ibrdst = $IBRDST-DEFAULT;      " brems angular sampling"
ibr_nist = $IBR-NIST-DEFAULT;  " flag for brems from NIST data base "
pair_nrc = $PAIR-NRC-DEFAULT;  " flag for pair from the NRC data base "
itriplet = $TRIPLET-DEFAULT;   " flag for triplet production "
iprdst = $IPRDST-DEFAULT;      " pair angular sampling "
rhof = 1;
DO i=1,5 [ iausfl(i) = 1; ]
"Ali:photonuc, line below already includes iarg=29,30"
DO i=6,$MXAUS [ iausfl(i) = 0; ]
ximax = $EXACT-BCA-XIMAX; estepe = $MAX-ELOSS;
skindepth_for_bca = $SKIN-DEPTH-FOR-BCA;
transport_algorithm = $TRANSPORT-ALGORITHM-DEFAULT;
bca_algorithm = $BCA-ALGORITHM-DEFAULT;
exact_bca = $EXACT-BCA-DEFAULT;
spin_effects = $SPIN-EFFECTS-DEFAULT;
count_pII_steps = 0; count_all_steps = 0;
radc_flag = 0;
nmed = $default_nmed;
kmpi = 12; kmpo = 8; dunit = 1;
rng_seed = 999999;
latchi = 0;

rmt2 = 2*rm; rmsq = rm*rm;

pi = 4*datan(1d0); twopi = 2*pi; pi5d2 = 2.5*pi;
nbr_split = 1;
i_play_RR = 0; i_survived_RR = 0; prob_RR = -1; n_RR_warning = 0;

$set_string(hen_house,' ');
i = lnblnk1($HEN_HOUSE);
hen_house(:i) = $HEN_HOUSE;
IF( $file_sep ~= fool_dec ) [
    DO j=1,i [
        IF( hen_house(j:j) = '/' ) hen_house(j:j) = $file_sep;
    ]
]
IF( hen_house(i:i) ~= $file_sep ) hen_house(i+1:i+1) = $file_sep;

n_files = 0;
$set_egs_home;
i = lnblnk1(egs_home);
IF( $file_sep ~= fool_dec ) [
    DO j=1,i [
        IF( egs_home(j:j) = '/' ) egs_home(j:j) = $file_sep;
    ]
]
IF( i > 0 & egs_home(i:i) ~= $file_sep ) egs_home(i+1:i+1) = $file_sep;
$set_string(input_file,' ');
$set_string(output_file,' ');
$set_string(work_dir,' ');
$set_string(pegs_file,' ');
$set_string(host_name,' ');
n_parallel = 0; i_parallel = 0; n_chunk = 0; is_batch = .false.;
first_parallel = 1;
return; end;

"*****************************************************************************
subroutine egs_combine_runs(combine_routine,extension);
"*****************************************************************************
" This subroutine loops over job number i from 1 to $max_unit,
" checks if the file output_file_wi.extension exists, and if yes,
" calls the external subroutine combine_routine with that file name.
"*****************************************************************************
implicit none;
external combine_routine;
character*(*) extension;
;COMIN/EGS-IO/;
character*1024 tmp_string,base,command,outfile,parfile_name,base1,
           text_string;
integer  lnblnk1,istat,ipar,egs_system,egs_open_file;
$INTEGER i,k,j,numparfiles,textindex;
$LOGICAL ex,iwin;

iwin=.false.; "start off assuming a non-Windows system"

$set_string(base,' ');
base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
       $cstring(output_file) // '_w';

"the following is to count the number of output files from"
"a parallel run"
$set_string(base1,' ');
base1 = $cstring(egs_home) // $cstring(user_code) // $file_sep //
       $cstring(output_file) // '_w*' // $cstring(extension);
$set_string(outfile,' ');
outfile = $cstring(egs_home) // $cstring(user_code) // $file_sep //
       'parfiles_tmp';
"try Unix/Linux first"
$set_string(command,' ');
command = 'ls ' // $cstring(base1) // ' | wc -l > ' // $cstring(outfile);
istat = egs_system($cstring(command));
IF(istat~=0)["now assume a Windows system"
   command = 'dir ' // $cstring(base1) // ' | find "File(s)" > ' //
   $cstring(outfile);
   istat = egs_system($cstring(command));
   IF(istat~=0)[
$egs_fatal(*,' Failed to write number of output files from parallel runs.');
   ]
   ELSE [
     iwin=.true.;
   ]
]

"now open parfiles_tmp and read the number of files"
ipar=1;
ipar=egs_open_file(ipar,0,1,$cstring(outfile));
IF(iwin)[
"need to do a bit of manipulation of a text string to get the number of files
  read(ipar,'(a)',err=:end_of_parfile:,end=:end_of_parfile:) text_string;
  text_string = $cstring(text_string);
  textindex = index(text_string,'File(s)');
  text_string = text_string(:textindex-1);
  read(text_string,'(i256)',err=:end_of_parfile:) numparfiles;
]
ELSE[
  read(ipar,'(i256)',err=:end_of_parfile:,end=:end_of_parfile:) numparfiles;
]
close(ipar);

"now remove parfiles_tmp"
$set_string(command,' ');

IF(iwin)[
   command = 'del /Q ' // $cstring(outfile);
]
ELSE[
   command = 'rm -f ' // $cstring(outfile);
]
istat = egs_system($cstring(command));
IF(istat~=0)[
   $egs_warning(*,' Failed to delete list of output files from parallel runs.');
]

k=1;
j=1;
WHILE(j<=numparfiles) [
     $set_string(tmp_string,' ');
     tmp_string = $cstring(base);
     call egs_itostring(tmp_string,k,.false.);
     tmp_string = $cstring(tmp_string) // $cstring(extension);
     inquire(file=tmp_string,exist=ex);
     IF( ex ) [
        call combine_routine(tmp_string);
        j=j+1;
     ]
     k=k+1;
]
return;

:end_of_parfile:
$egs_fatal(*,' Failed to read number of output files from parallel runs.');
end;

"******************************************************************************
$LOGICAL function egs_strip_extension(filen,fext);
"******************************************************************************
" Check if the string pointed to by filen ends with the string pointed to by
" fext and if yes, replace with blanks and return .true., otherwise return
" false.
"******************************************************************************
implicit none;
character*(*) filen,fext;
integer  l1,l2,lnblnk1,i;

l1 = lnblnk1(filen); l2 = lnblnk1(fext);
IF( l1 >= l2 & filen(l1-l2+1:l1) = fext(:l2) ) [
    egs_strip_extension = .true.;
    DO i=l1-l2+1,len(filen) [ filen(i:i) = ' '; ]
]
ELSE [ egs_strip_extension = .false.; ]
return; end;

"******************************************************************************
$LOGICAL function egs_is_absolute_path(fn);
"******************************************************************************
" Returns .true., if the string pointed to by fn is an absolute file name,
" .fale. otherwise.
"******************************************************************************
implicit none;
character*(*) fn;
integer  i,lnblnk1;
DO i=1,lnblnk1(fn) [
    IF( fn(i:i) = $file_sep ) [ egs_is_absolute_path = .true.; return; ]
]
egs_is_absolute_path = .false.; return; end;

"******************************************************************************
integer  function egs_get_unit(iunit);
"******************************************************************************
" Returns iunit, if the Fortran I/O unit iunit is not currently in use.
" Otherwise return the first free I/O unit found or -1 if none is available.
"******************************************************************************
implicit none;
$INTEGER iunit, i;
$LOGICAL is_open;

IF( iunit > 0 ) [
    inquire(iunit,opened=is_open);
    IF( ~is_open ) [ egs_get_unit = iunit; return; ]
]
DO i=1,$max_unit [
    inquire(i,opened=is_open);
    IF( ~is_open ) [ egs_get_unit = i; return; ]
]
egs_get_unit = -1; return; end;

"******************************************************************************
integer function egs_open_file(iunit,rl,action,extension);
"******************************************************************************
" Open a file trying to connect to Fortran I/O unit iunit.
" If iunit is already in use, connect to the first free I/O unit found.
" If no free I/O unit is found, then
"   - if action = 0, return -1.
"   - if action ~= 0, call the $egs_fatal macro.
" If extension is an absolute file name (including path), use extension
" as a file name, otherwise use output_file.extension in the temporary
" working directory as name. In both cases use status='unknown' to open the
" file. If rl = 0, open the file for formatted sequential access, otherwise
" open for unformatted direct access with record length = rl.
"******************************************************************************
implicit none;
$INTEGER iunit, rl, action;
character*(*) extension;
;COMIN/EGS-IO/;
$LOGICAL egs_is_absolute_path,is_open;
integer  egs_get_unit;
integer  i,lnblnk1;
character*1024 tmp_string,error_string;
$INTEGER the_unit;
$declare_write_buffer;

egs_open_file = -1; "so that the DEC compiler does not complain that"
                    "the function has an undefined values in some of"
                    "the excution paths (where exit(1) is called."
the_unit = egs_get_unit(iunit);
IF( the_unit < 0 ) [
    IF( action = 0 ) [ egs_open_file = -1; return; ]
    $egs_fatal(*,'No free Fortran I/O units left');
]

IF( egs_is_absolute_path(extension) ) [
    inquire(file=extension,opened=is_open);
    IF(is_open)[
        inquire(file=extension,number=the_unit);
        $egs_warning('(a,a,/,a,i3,/,a,/,a)',
             'File ',$cstring(extension),
             ' is already opened and connected to unit ',the_unit,
             ' Will not try to re-open this file, assuming it has been opened',
             ' by the .io file.');
    ]
    ELSE IF( rl = 0 ) [
        open(the_unit,file=extension,status='unknown');
    ]
    ELSE [
        open(the_unit,file=extension,status='unknown',form='unformatted',
             access='direct', recl=rl);
    ]
    egs_open_file = the_unit; return;
]

$set_string(tmp_string,' ');
tmp_string = $cstring(egs_home) // $cstring(user_code) // $file_sep //
             $cstring(work_dir) // $cstring(output_file);
IF( i_parallel > 0 ) [
    tmp_string = $cstring(tmp_string) // '_w';
    call egs_itostring(tmp_string,i_parallel,.false.);
]
tmp_string = $cstring(tmp_string) // $cstring(extension);

inquire(file=tmp_string,opened=is_open);
IF(is_open)[
    inquire(file=tmp_string,number=the_unit);
    $egs_warning('(a,a,/,a,i3,/,a,/,a,/)',
             'File ',$cstring(tmp_string),
             ' is already opened and connected to unit ',the_unit,
             ' Will not try to re-open this file, assuming it has been opened',
             ' by specifying it in the .io file.');
]
ELSE IF( rl = 0 ) [
    open(the_unit,file=tmp_string,status='unknown',err=:open_error:);
]
ELSE [
    open(the_unit,file=tmp_string,status='unknown',form='unformatted',
         access='direct', recl=rl,err=:open_error:);
]
egs_open_file = the_unit; return;

:open_error:
error_string = 'In egs_open_file: failed to open file ' // $cstring(tmp_string)
      // char(10) // 'iunit = ';
call egs_itostring(error_string,iunit,.false.);
error_string = $cstring(error_string) // ' the_unit = ';
call egs_itostring(error_string,the_unit,.false.);
$egs_fatal('(a)',$cstring(error_string));
end;


"******************************************************************************
integer  function egs_open_datfile(iunit,rl,action,extension);
"******************************************************************************
"
" Open an existing 'data' file.
" First try to connect the file to Fortran unit iunit, but if iunit is
" already in use, use the first free unit instead.
" extension is the datafile extension (e.g. '.egsdat') .
" The algorithm for searching for the file is as follows:
"  1. If extension is an absolute file name (including path),
"     try opening this file, else
"  2. Try output_file.extension in the user code directory.
"  3. Try input_file.extension in the user code directory (if input_file is
"     different from output_file).
" If the file is found, open it using status='old' for
"   a) formatted sequential access, if rl=0
"   b) unformatted direct access with record length = rl, if rl > 0.
"
" Return value:
"   - if all is OK, return the opened unit number
"   - if something fails, then
"       * if action = 0, return error code less than 0.
"       * if action != 0, call the $egs_fatal macro with an error message.
"
"******************************************************************************
implicit none;
$INTEGER iunit,rl,action;
character*(*) extension;

;COMIN/EGS-IO/;

integer  i,the_unit,lnblnk1,egs_get_unit;
$LOGICAL egs_is_absolute_path;
character base*1024, fn*1024;
$declare_write_buffer;

egs_open_datfile = -1; "so that the DEC compiler does not complain that"
                    "the function has an undefined values in some of"
                    "the excution paths (where exit(1) is called."
the_unit = egs_get_unit(iunit);
IF( the_unit < 0 ) [
    IF( action = 0 ) [ egs_open_datfile = -1; return; ]
    $egs_fatal(*,'No free Fortran I/O units left');
]

IF( egs_is_absolute_path(extension) ) [
    IF( rl = 0 ) [
        open(the_unit,file=extension,status='old',err=:no_datfile_0:);
    ]
    ELSE [
        open(the_unit,file=extension,status='old',form='unformatted',
              access='direct',recl=rl,err=:no_datfile_0:);
    ]
    egs_open_datfile = the_unit; return;

    :no_datfile_0:;
    IF( action = 0 ) [ egs_open_datfile = -2; return; ]
    $egs_fatal(*,'Failed to open file ',$cstring(extension));
]

$set_string(base,' '); $set_string(fn,' ');
base = $cstring(egs_home) // $cstring(user_code) // $file_sep;
"fn = $cstring(base) // $cstring(output_file) // $cstring(extension);"
IF( i_parallel > 0 ) [
    fn = $cstring(base) // $cstring(output_file) // '_w';
    call egs_itostring(fn,i_parallel,.false.);
    fn = $cstring(fn) // $cstring(extension);
]
ELSE [
    fn = $cstring(base) // $cstring(output_file) // $cstring(extension);
]
IF( rl = 0 ) [
    open(the_unit,file=fn,status='old',err=:no_datfile_1:);
]
ELSE [
    open(the_unit,file=fn,status='old',form='unformatted',access='direct',
         recl=rl,err=:no_datfile_1:);
]
egs_open_datfile = the_unit; return;

:no_datfile_1:;
$egs_warning('(a,a)','Failed to open ',$cstring(fn));
$set_string(fn,' ');
"fn = $cstring(base) // $cstring(input_file) // $cstring(extension);"
IF( i_parallel > 0 ) [
    fn = $cstring(base) // $cstring(input_file) // '_w';
    call egs_itostring(fn,i_parallel,.false.);
    fn = $cstring(fn) // $cstring(extension);
]
ELSE [
    fn = $cstring(base) // $cstring(input_file) // $cstring(extension);
]
IF( rl = 0 ) [
    open(the_unit,file=fn,status='old',err=:no_datfile_2:);
]
ELSE [
    open(the_unit,file=fn,status='old',form='unformatted',access='direct',
         recl=rl,err=:no_datfile_2:);
]
egs_open_datfile = the_unit; return;

:no_datfile_2:;
$egs_fatal(*,'Failed to open data file');
end;

"******************************************************************************
integer  function egs_open_file_junk(iunit,do_it_anyway,filen);
"******************************************************************************
" Open the file filen for sequential formatted I/O and return the unit
" number it was connected to.
" If iunit ~= 0, try to connect to unit |iuniti|, otherwise
" use the first unconnected unit found.
" If iunit > 0
"    open the unit even if it was already open, if do_it_anyway is .true.,
"    otherwise return -4.
" If iunit < 0
"    if the unit |iunit| is already in use and do_it_anyway is .true.,
"    search for the first available unit, otherwise return -4.
" Return values:
"   unit number, if the file was succesfully opened.
"   -1, if there was no free unit numer to connect to.
"   -2, if the file does not exist.
"   -3, if the file exist, but could not be opened.
"   -4, if |iunit|>0 & do_it_anyway=.false. and |iunit| is already in use.
"******************************************************************************
implicit none;
$INTEGER iunit;
$LOGICAL do_it_anyway;
character*(*) filen;

$LOGICAL aux;
$INTEGER the_unit,i;

inquire(file=filen,exist=aux);
IF( ~aux ) [ egs_open_file_junk = -2; return; ]
IF( iunit < 0 ) [ the_unit = -iunit; ] ELSE [ the_unit = iunit; ]
IF( the_unit ~= 0 ) [
    inquire(unit=the_unit,opened=aux);
    IF( aux ) [
        IF( ~do_it_anyway ) [ egs_open_file_junk = -4; return; ]
        IF( iunit < 0 ) the_unit = 0;
    ]
]
IF( the_unit = 0 ) [
    DO i=1,$max_unit [
        inquire(unit=i,opened=aux);
        IF( ~aux ) [ the_unit = i; EXIT; ]
    ]
    IF( the_unit = 0 ) [ egs_open_file_junk = -1; return; ]
]
open(the_unit,file=filen,status='old',err=:failed_to_open:);
egs_open_file_junk = the_unit; return;
:failed_to_open:
egs_open_file_junk = -3; return; end;

"==============================================================================
subroutine egs_strip_path(fname);
"==============================================================================
" Strip the path name from fname (if any)
implicit none;
character*(*) fname;
integer  i,l,l1,lnblnk1,j;
character slash;
slash = '/';
l = lnblnk1(fname);
DO i=1,l [
    IF( fname(i:i) = slash ) [ fname(i:i) = $file_sep; ]
]
DO i=l,1,-1 [
    IF( fname(i:i) = $file_sep | fname(i:i) = slash ) [
        l1 = l-i;
        fname(:l1) = fname(i+1:l);
        DO j=l1+1,len(fname) [ fname(j:j) = ' '; ]
        return;
    ]
]
return; end;

"==============================================================================
subroutine replace_env(fname);
"==============================================================================
"subroutine to replace environment variables (beginning with $) with their"
"full names or ~ with the full name of $HOME"
"Assumes environment variable or ~ appears only at the beginning of the"
"file name"

;COMIN/EGS-IO/;

character*(*) fname;
character*256 dirname;
integer indsep,ind1,ind2;

indsep = index(fname,$file_sep);
IF(indsep <= 0) return;
"hope that the user has just supplied the file name"
"and it is in the current directory"

ind1=index(fname,'$');
ind2=index(fname,'~');

"examine first character of name"
IF(ind1=1)[
    "get the environment variable"
    call getenv(fname(2:indsep-1),dirname);
    IF(dirname=' ')[
      $egs_fatal('(a,a/,a)',' Error in file name: ',$cstring(fname),
  ' First element in name does not specify a defined environment variable.');
   ]
   fname=$cstring(dirname)//fname(indsep:);
   $egs_info('(//a,a/)',' Retrieving file: ',$cstring(fname));
]
ELSEIF(ind2=1)[
    call getenv('HOME',dirname);
    IF(dirname=' ')[
      $egs_fatal('(a,a/,a)',' Error in file name: ',$cstring(fname),
  ' HOME is undefined.');
   ]
   fname=$cstring(dirname)//fname(indsep:);
   $egs_info('(//a,a/)',' Retrieving file: ',$cstring(fname));
]
return;
end;

"=============================================================================
subroutine egs_get_usercode(ucode);
"=============================================================================
" Deduct the user code name from the executable name
" The algorithm assumes that the executable is called
"   xxx[_debug|noopt][.exe]
" and it will fail if this is not the case.
"=============================================================================
implicit none;
COMIN/EGS-IO/;
character*(*) ucode;
character*512 arg;
integer  l,l1,lnblnk1,i;
$declare_write_buffer;

call getarg(0,arg); call egs_strip_path(arg);
l = lnblnk1(arg);
IF( arg(l-3:l) = '.exe' ) [
    arg(l-3:l) = ' '; l = l - 4;
]
IF( arg(l-5:l) = '_debug' ) [
    arg(l-5:l) = ' '; l = l-5;
]
IF( arg(l-5:l) = '_noopt' ) [
    arg(l-5:l) = ' '; l = l-5;
]
l1 = len(ucode);
IF( l > l1 ) [
    $egs_fatal(*,' user code name is too long (',l,' chars)');
]
$set_string(ucode,' '); ucode(:l) = arg(:l);
return; end;

subroutine egs_itostring(string,i,leave_space);
implicit none;
character*(*) string;
$INTEGER i;
integer  l,lnblnk1,idiv,itmp,iaux;
$LOGICAL first,leave_space;
l = lnblnk1(string)+1; IF( l > 1 & leave_space ) l=l+1;
idiv = 1000000000; itmp = i; first = .false.;
do while(idiv.gt.0) ;
    iaux = itmp/idiv;
    IF( (iaux > 0 | first ) & l <= len(string) ) [
        string(l:l) = char(iaux+48); first = .true.; l = l+1;
    ]
    itmp = itmp - iaux*idiv; idiv = idiv/10;
end do;
return; end;

"=============================================================================
$REAL function egs_rndm();
"=============================================================================
implicit none;
;COMIN/RANDOM/;
$RANDOMSET egs_rndm;
return; end;

"=============================================================================
integer  function egs_add_medium(medname);
implicit none;
character*(*) medname;
$declare_max_medium;
;COMIN/MEDIA,EGS-IO/;
$INTEGER i,l,imed,medname_len;
character c;
$LOGICAL  same;
$declare_write_buffer;

l = min(len(medname),24); medname_len = l;
DO i=1,l [
    c = medname(i:i);
    IF( ichar(c) = 0 ) [ medname_len = i-1; EXIT; ]
]
DO imed=1,nmed [
    l = 24;
    DO i=1,24 [
        IF( media(i,imed)(1:1) = ' ' ) [ l = i-1; EXIT; ]
    ]
    IF( l = medname_len ) [
        same = .true.;
        DO i=1,l [
            c = medname(i:i);
            IF( c ~= media(i,imed)(1:1) ) [ same = .false.; EXIT; ]
        ]
        IF( same ) [
            egs_add_medium = imed; return;
        ]
    ]
]
nmed = nmed + 1;
IF( nmed > $MXMED ) [
  $egs_fatal('(a,/,a,i3,a)',
    'In egs_add_medium: maximum number of media exceeded ',
    'Increase the macro $MXMED (currently ',$MXMED,') and retry');
]
l = min(len(medname),24);
DO i=1,l [
    c = medname(i:i);
    IF( ichar(c) = 0 ) [ l = i-1; EXIT; ]
    media(i,nmed) = ' ';
    media(i,nmed)(1:1) = c;
]
IF( l < 24 ) [
    DO i=l+1,24 [ media(i,nmed) = ' '; ]
]
egs_add_medium = nmed;
return; end;

subroutine egs_get_medium_name(imed,medname);
implicit none;
character*(*) medname;
$declare_max_medium;
;COMIN/MEDIA,EGS-IO/;
$INTEGER i,l,imed;
DO i=1,len(medname) [ medname(i:i) = ' '; ]
IF( imed < 1 | imed > nmed ) [ return; ]
l = 24;
DO l=24,1,-1 [
    IF( media(l,imed)(1:1) ~= ' ' ) EXIT;
]
l = min(l,len(medname));
DO i=1,l [ medname(i:i) = media(i,imed)(1:1); ]
return; end;
;

"============================================================================"
"  Pass pointers to the cross section interpolation coefficients to          "
"  an external subroutine                                                    "
"============================================================================"
subroutine egs_get_electron_data(func,imed,which);
implicit none;
$INTEGER imed,which;
external func;
$declare_max_medium;
;COMIN/ELECIN,MEDIA,EGS-IO/;
$REAL    lemin,lemax;

lemin = (1 - eke0(imed))/eke1(imed);
lemax = (meke(imed) - eke0(imed))/eke1(imed);
    IF( which = 1 ) [
    call func(meke(imed),lemin,lemax,esig0(1,imed),esig1(1,imed));
] ELSE IF( which = 2 ) [
    call func(meke(imed),lemin,lemax,psig0(1,imed),psig1(1,imed));
] ELSE IF( which = 3 ) [
    call func(meke(imed),lemin,lemax,ededx0(1,imed),ededx1(1,imed));
] ELSE IF( which = 4 ) [
    call func(meke(imed),lemin,lemax,pdedx0(1,imed),pdedx1(1,imed));
] ELSE IF( which = 5 ) [
    call func(meke(imed),lemin,lemax,ebr10(1,imed),ebr11(1,imed));
] ELSE IF( which = 6 ) [
    call func(meke(imed),lemin,lemax,pbr10(1,imed),pbr11(1,imed));
] ELSE IF( which = 7 ) [
    call func(meke(imed),lemin,lemax,pbr20(1,imed),pbr21(1,imed));
] ELSE IF( which = 8 ) [
    call func(meke(imed),lemin,lemax,tmxs0(1,imed),tmxs1(1,imed));
] ELSE IF( which = 9 ) [
    call func(meke(imed),lemin,lemax,range_ep(0,1,imed),range_ep(1,1,imed));
] ELSE [
    $egs_fatal(*,'Unknown electron data type ',which);
]
return; end;

subroutine egs_get_photon_data(func,imed,which);
implicit none;
$INTEGER imed,which;
external func;
$declare_max_medium;
;COMIN/PHOTIN,MEDIA,EGS-IO/;
$REAL    lemin,lemax;

lemin = (1 - ge0(imed))/ge1(imed);
lemax = (mge(imed) - ge0(imed))/ge1(imed);
IF( which = 1 ) [
    call func(mge(imed),lemin,lemax,gmfp0(1,imed),gmfp1(1,imed));
] ELSE IF( which = 2 ) [
    call func(mge(imed),lemin,lemax,gbr10(1,imed),gbr11(1,imed));
] ELSE IF( which = 3 ) [
    call func(mge(imed),lemin,lemax,gbr20(1,imed),gbr21(1,imed));
] ELSE IF( which = 4 ) [
    call func(mge(imed),lemin,lemax,cohe0(1,imed),cohe1(1,imed));
] ELSE IF( which = 5 ) [
    call func(mge(imed),lemin,lemax,PHOTONUC0(1,imed),PHOTONUC1(1,imed));
] ELSE [
    $egs_fatal(*,'Unknown photon data type ',which);
]
return; end;

/* Print binding energies: In the case of the EPDL library
   only energies above 1 keV are output for elements not part
   of the current simlation. This is due to the fact that energies
   below 1 keV are taken from the relaxation database only for
   elements requested in the input when EPDL is used. This is not
   an issue when using XCOM.
 */
subroutine egs_print_binding_energies;
implicit none;
$declare_max_medium;
;COMIN/EDGE,MEDIA,EGS-IO/;
$INTEGER    i,j;
integer*4   lnblnk1;
character*3 labels(16);
data labels/'  K',' L1',' L2',' L3',
            ' M1',' M2',' M3',' M4',' M5',
            ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/;

$egs_info('(a,a,a)',
        'Binding energies from ',$cstring(photon_xsections),
        ' photon cross section library');
DO j = 1,$MXELEMENT [
   DO i = 1,$MXPESHELL [
      IF ( binding_energies(i,j) > 0 ) [
         $egs_info('(a,i3,a,a,a,1pe12.4,a)',
         ' Eb(',j,',',labels(i),') = ',binding_energies(i,j),' MeV');
      ]
   ]
]

return;end;


"============================================================================="
"  scale elastic scattering strength by a given factor                        "
"============================================================================="
subroutine egs_scale_xcc(imed,factor);
implicit none;
$INTEGER imed;
$REAL    factor;
$declare_max_medium;
;COMIN/ELECIN,MEDIA/;
IF( imed > 0 & imed <= nmed ) [ xcc(imed) = xcc(imed)*factor; ]
return; end;


"============================================================================"
subroutine egs_write_string(ounit,string);
implicit none;
$INTEGER ounit;
character*(*) string;
write(ounit,'(a,$)') string;
$FLUSH_UNIT(ounit);
return; end;


"============================================================================"
subroutine egs_swap_2(c);
"============================================================================"
" Convert a 2 byte object from little endian to big endian byte order        "
" or vice versa                                                              "
character  c(2),tmp;
tmp=c(2); c(2)=c(1); c(1)=tmp;
return; end;

"============================================================================"
subroutine egs_swap_4(c);
"============================================================================"
" Convert a 2 byte object from little endian to big endian byte order        "
" or vice versa                                                              "
character  c(4),tmp;
tmp=c(4); c(4)=c(1); c(1)=tmp;
tmp=c(3); c(3)=c(2); c(2)=tmp;
return; end;


"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
" Utility subroutines and functions previously in egsnrc.mortran
"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

%E
subroutine set_spline(x,f,a,b,c,d,n);
"======================================================================"
"
" Sets cubic spline interpolation coefficients for the data contained  "
" in the array f(n) at the abscissas x(n)                              "
"                                                                      "
" I.Kawrakow, NRC                                                      "
"======================================================================"

implicit none;

$INTEGER n;
$REAL    x(n),f(n),a(n),b(n),c(n),d(n);

$INTEGER m1,m2,m,mr;
$REAL    s,r;

m1 = 2; m2 = n-1; s = 0;
DO m=1,m2 [
    d(m) = x(m+1) - x(m); r = (f(m+1) - f(m))/d(m);
    c(m) = r - s; s = r;
]
/s,r,c(1),c(n)/=0;
DO m=m1,m2 [
    c(m) = c(m) + r*c(m-1);
    b(m) = 2*(x(m-1) - x(m+1)) - r*s;
    s = d(m); r = s/b(m);
]
mr = m2;
DO m=m1,m2 [
    c(mr) = (d(mr)*c(mr+1) - c(mr))/b(mr);
    mr = mr - 1;
]
DO m=1,m2 [
    s = d(m); r = c(m+1) - c(m); d(m) = r/s;
    c(m) = 3*c(m);
    b(m) = (f(m+1)-f(m))/s - (c(m)+r)*s;
    a(m) = f(m);
]
return; end;
;

$REAL function spline(s,x,a,b,c,d,n);
"======================================================================"
"                                                                      "
" Returns the value of the function at s using the spline coefficients "
" a,b,c,d, which must have been set using set_spline                   "
"                                                                      "
" I.Kawrakow, NRC                                                      "
"======================================================================"

implicit none;

$INTEGER n;
$REAL    s,x(n),a(n),b(n),c(n),d(n);

integer  m_lower,m_upper,direction,m,ml,mu,mav;
$REAL    q;

IF( x(1) > x(n) ) [ direction = 1; m_lower = n; m_upper = 0; ]
ELSE              [ direction = 0; m_lower = 0; m_upper = n; ]
IF ( s >= x(m_upper + direction) ) [
    m = m_upper + 2*direction - 1;
]
ELSE IF( s <= x(m_lower+1-direction) ) [
    m = m_lower - 2*direction + 1;
]
ELSE [   " Perform a binary search to find the interval s is in "
    ml = m_lower; mu = m_upper;
    WHILE ( iabs(mu-ml) > 1 ) [
        mav = (ml+mu)/2;
        IF( s < x(mav) ) [ mu = mav; ]
        ELSE             [ ml = mav; ]
    ]
    m = mu + direction - 1;
]
q = s - x(m);
spline = a(m) + q*(b(m) + q*(c(m) + q*d(m)));
return; end;
;

%E "start of prepare_alias_table subroutine"
"****************************************************************************

subroutine prepare_alias_table(nsbin,xs_array,fs_array,ws_array,ibin_array);

" Prepare an alias sampling table, given the histogram probabilities
" xs_array,fs_array.
"*****************************************************************************
implicit none;

integer   nsbin;
$INTEGER  ibin_array(nsbin);
$REAL     xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin);

$INTEGER  i,j_l,j_h;
$REAL     sum,aux;

sum = 0;
DO i=1,nsbin [
    aux = 0.5*(fs_array(i)+fs_array(i-1))*(xs_array(i)-xs_array(i-1));
    IF( aux < 1e-30 ) aux = 1e-30;
    ws_array(i) = -aux; ibin_array(i) = 1;
    sum = sum + aux;
]
sum = sum/nsbin;

DO i=1,nsbin-1 [

    DO j_h = 1,nsbin [
        IF( ws_array(j_h) < 0 ) [
            IF( abs(ws_array(j_h)) > sum ) GOTO :AT_EXIT_1:;
        ]
    ]
    j_h = nsbin;
    :AT_EXIT_1:

    DO j_l = 1,nsbin [
        IF( ws_array(j_l) < 0 ) [
            IF( abs(ws_array(j_l)) < sum ) GOTO :AT_EXIT_2:;
        ]
    ]
    j_l = nsbin;
    :AT_EXIT_2:

    aux = sum - abs(ws_array(j_l));
    ws_array(j_h) = ws_array(j_h) + aux;
    ws_array(j_l) = -ws_array(j_l)/sum;
    ibin_array(j_l) = j_h;
    IF( i = nsbin-1 ) ws_array(j_h) = 1;

]

return; end;
;

%E   " start of alias_sample1 function "
"******************************************************************************

$REAL function alias_sample1(nsbin,xs_array,fs_array,ws_array,ibin_array);

" Sample a random variable from the alias table
"    xs_array,fs_array,ws_array,ibin_array
" which must have been prepared with prepare_alias_table
"
"******************************************************************************
implicit none;

integer   nsbin;
$INTEGER  ibin_array(nsbin);
$REAL     xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin);

;COMIN/RANDOM/;

$INTEGER j;
$REAL    r1,r2,aj,x,dx,a,rnno1;

$RANDOMSET r1; $RANDOMSET r2;
aj = 1 + r1*nsbin; j = aj; aj = aj - j;
IF( aj > ws_array(j) ) j = ibin_array(j);
x = xs_array(j-1); dx = xs_array(j)-x;
IF( fs_array(j-1) > 0 ) [
    a = fs_array(j)/fs_array(j-1)-1;
    IF( abs(a) < 0.2 ) [
        rnno1 = 0.5*(1-r2)*a;
        alias_sample1 = x + r2*dx*(1+rnno1*(1-r2*a));
    ]
    ELSE [
        alias_sample1 = x - dx/a*(1-sqrt(1+r2*a*(2+a)));
    ]
]
ELSE [
    alias_sample1 = x + dx*sqrt(r2);
]
return; end;
;

%E   " start of prepare_alias_histogram routine "
subroutine prepare_alias_histogram(nsbin,ws_array,ibin_array);
"*************************************************************
"                                                                           "
" Prepares an alias histogram for the probability array ws_array of         "
" dimension nsbin.                                                          "
" On return, the ws_array is modified and contains the alias weights,       "
" ibin_array holds the alias indices.                                       "
" To be used with the integer function sample_alias_histogram, which        "
" returns a bin index j with probability ws_array(j)                        "
"                                                                           "
" Iwan Kawrakow, November 2001
"***************************************************************************"

implicit none;

$INTEGER  nsbin,ibin_array(nsbin);
$REAL     ws_array(nsbin);

$INTEGER  i,j_l,j_h;
$REAL     sum,aux;

sum = 0;
DO i=1,nsbin [
    sum = sum + ws_array(i); ibin_array(i) = -1;
]
sum = sum/nsbin;

DO i=1,nsbin-1 [

    DO j_h = 1,nsbin [
        IF( ibin_array(j_h) < 0 & ws_array(j_h) > sum ) EXIT;
    ]

    DO j_l = 1,nsbin [
        IF( ibin_array(j_l) < 0 & ws_array(j_l) < sum ) EXIT;
    ]

    aux = sum - ws_array(j_l);
    ws_array(j_h) = ws_array(j_h) - aux;
    ws_array(j_l) = ws_array(j_l)/sum;
    ibin_array(j_l) = j_h;

]

DO i=1,nsbin [
    IF( ibin_array(i) < 0 ) [
        ibin_array(i) = i; ws_array(i) = 1;
    ]
]

return;
end;

%E   " start of sample_alias_histogram function "
$INTEGER function sample_alias_histogram(nsbin,ws_array,ibin_array);
"***********************************************************************
"
" This function samples a bin index using the alias sampling technique.
" The arrays ws_array and ibin_array of dimension nsbin must have been
" prepared with the subroutine prepare_alias_histogram.
"
" Iwan Kawrakow, November 2001.
"***********************************************************************

implicit none;

$INTEGER  nsbin,ibin_array(*);
$REAL     ws_array(*);

;COMIN/RANDOM/;

$REAL    r1,r2;
$INTEGER ibin;

$RANDOMSET r1; $RANDOMSET r2;
ibin = 1 + nsbin*r1;
IF( r2 > ws_array(ibin) ) ibin = ibin_array(ibin);
sample_alias_histogram = ibin;
return;
end;

%E   " start of gauss_legendre subroutine "
"******************************************************************************

subroutine gauss_legendre(x1,x2,x,w,n);

"     Given the lower and upper limit of integration, x1 and x2,
"     and given n, this routine returns arrays x and w,
"     containing the abscissas and weights of the Gauss-Legendre
"     n - point quadrature formula
"
"******************************************************************************
$IMPLICIT-NONE;

$INTEGER n;
real*8   x1,x2,x(n),w(n);

real*8     eps,Pi;
parameter (eps = 3.D-14, Pi = 3.141592654D0);

$INTEGER i,m,j;
real*8   xm,xl,z,z1,p1,p2,p3,pp;

m = (n + 1)/2;
xm=0.5d0*(x2+x1); xl=0.5d0*(x2-x1);
DO i=1,m [
    z=cos(Pi*(i-.25d0)/(n+.5d0));
    LOOP [
        p1=1.d0; p2=0.d0;
        DO j=1,n [
            p3 = p2; p2 = p1;
            p1=((2.d0*j-1.d0)*z*p2-(j-1.d0)*p3)/j;
        ]
        pp=n*(z*p1-p2)/(z*z-1.d0);
        z1=z; z=z1-p1/pp;
    ] UNTIL (abs(z-z1) < eps);
    x(i)=xm-xl*z; x(n+1-i)=xm+xl*z;
    w(i)=2.d0*xl/((1.d0-z*z)*pp*pp); w(n+1-i)=w(i);
]
return; end;
;

%E   " start of lnblnk1 function"
"******************************************************************************

integer  function lnblnk1(string);

"Function to return index of last non-blank character in a string"
"We use this instead of lnblnk because there are compilers"
"that do not have lnblnk"

"******************************************************************************
character*(*) string;
integer i;
DO i=len(string),1,-1 [
    j = ichar(string(i:i));
    IF( j = 0 ) [ lnblnk1 = i-1; return; ] "i.e. the same as strlen for "
                                           "0-terminated C-strings"
    IF( j ~= 9 & j ~= 10 & j ~= 11 & j ~= 12 & j ~= 13 & j ~= 32 ) [
        lnblnk1 = i; return;
    ]
]
lnblnk1 = 0; return; end;

%E   " start of erf1 function "
"************************************************************************
"       an error function routine which is needed since some of
"       the compiler don't have it as an intrinsic
"
"       Originally came from some library somewhere (Harwell I think)
"       recoded in mortran
"************************************************************************

$REAL FUNCTION ERF1(X);

$IMPLICIT-NONE;

$REAL x;

double precision A(0:22,2);     " Coefficients in expansion for erf(x) if x<3
                                " (K=1) and for erfc(x) x>3 (K=2)
double precision
       CONST,                   " 2/sqrt(pi)
       BN,BN1,BN2,              " Recursion coefficients B(n),B(n+1),B(n+2)
       Y,FAC;                   " y=x/3 or 3/x and FAC = 2(2y**2-1)
$INTEGER N,                     " recursion index n
         K,                     " K=1,2 for x <= 3 or x > 3
         NLIM(2);               " Maximum value of n in sum for K=1,2

DATA A/  1.0954712997776232 , -0.2891754011269890 ,  0.1104563986337951 ,
        -0.0412531882278565 ,  0.0140828380706516 , -0.0043292954474314 ,
         0.0011982719015923 , -0.0002999729623532 ,  0.0000683258603789 ,
        -0.0000142469884549 ,  0.0000027354087728 , -0.0000004861912872 ,
         0.0000000803872762 , -0.0000000124184183 ,  0.0000000017995326 ,
        -0.0000000002454795 ,  0.0000000000316251 , -0.0000000000038590 ,
         0.0000000000004472 , -0.0000000000000493 ,  0.0000000000000052 ,
        -0.0000000000000005 ,  0.0000000000000001 ,
         0.9750834237085559 , -0.0240493938504146 ,  0.0008204522408804 ,
        -0.0000434293081303 ,  0.0000030184470340 , -0.0000002544733193 ,
         0.0000000248583530 , -0.0000000027317201 ,  0.0000000003308472 ,
         0.0000000000001464 , -0.0000000000000244 ,  0.0000000000000042 ,
        -0.0000000000000008 ,  0.0000000000000001 ,  9*0.0              /;

DATA NLIM/ 22,16 /;
DATA CONST/ 1.128379167095513 /;

IF( x > 3 ) [ y = 3/x; k = 2; ]
ELSE        [ y = x/3; k = 1; ]

" Calculate sum of Chebyshev polynomials by backwards recursion
"
"       sum { A(n)*T(2n+1;y) : n=0,N } = y * ( B(0) - B(1) )
"       sum { A(n)*T(2n;y)   : n=0,N } = ( B(0) - (2*y**2-1) * B(1) ) / 2
"                                      = ( B(0) - B(2) + A(0) ) / 2
"
"       where B(N+2) = B(N+1) = 0
"       and B(n) = 2*(2*y**2-1)*B(n+1) - B(n+2) + A(n) for n=N,(N-1),...,1,0
"
FAC = 2.0 * ( 2.0 * Y*Y - 1.0 );
BN1 = 0.0;                       " Initialise B(N+2) = 0
BN  = 0.0;                       " Initialise B(N+1) = 0

DO n = NLIM(K),0,-1 [
   BN2 = BN1; BN1 = BN;
   BN = FAC * BN1 - BN2 + A(N,K)
]

IF ( k = 1 ) [ erf1 = CONST * Y * ( BN - BN1 ); ]
ELSE       [ erf1 = 1 - CONST * EXP(-X**2) * ( BN - BN2 + A(0,K) )/(4.0 * X); ]

RETURN;
end;

%E   " start of zero function "
"********************************************************"
"   Finds minimum non-zero value which can be used for   "
"   evaluating logarithms without getting a NAN.         "
"                                                        "
" Starting with 10^-20 and decreasing it by 5 orders of  "
" magnitud at a time, a check is made until the compiler "
" recognizes the number as zero and the previous number  "
" used. The same procedure is applied to this number but "
" decreasing it by one order of magnitud. Finally it is  "
" divided by 2..10 until the zero-check is successful.   "
"********************************************************"
$REAL FUNCTION ZERO();
$IMPLICIT-NONE;

$INTEGER i;
$REAL    x, xtemp;

x = 1.E-20;
"jump over 5 orders of magnitude"
DO i=1,100[
   IF (x = 0.0) [EXIT;]
   ELSE[xtemp = x;]
   x = x/1.E5;
]
x = xtemp;
"jump over 1 order of magnitude"
DO i=1,5[
   IF (x ~= 0.0)[xtemp = x;]
   ELSE[EXIT;]
   x = x/10;
]
x = xtemp;
"divide it up by 2...10"
DO i=2,10[
   IF (x ~= 0.0)[xtemp = x;]
   ELSE[EXIT;]
   x = x/i;
]
zero = xtemp;
return;end;
;

%E   " start of toUpper function "
"**************************************"
                                       "
"   Converts a string to upper case.   "
"                                      "
"**************************************"
character*512 function toUpper(a_string);
character*(*) a_string;
character*512 the_string;
$INTEGER cursor, i, lnblnk1;
toUpper = a_string; the_string = a_string;
DO i=1, lnblnk1(the_string) [
   cursor=ICHAR(the_string(i:i));
   IF ((cursor.GE.97).AND.(cursor.LE.122)) [
        cursor=cursor-32;toUpper(i:i)=CHAR(cursor);
   ]
]
return; end;
;

/***********************************************************************
   Tools for reading C/C++ binary files (byte-oriented) in Fortran.
   Note that with gfortran one could use access=stream, but this is not
   available in GNU g77. So, to preserve backwards compatibility we have
   created these tools.
 ************************************************************************/

"================================================================="
 integer*1 function egs_read_byte(iunit, jrec);
"================================================================="
" Reads one byte from a C/C++ binary file at jrec position        "
 implicit none;
 integer iunit, jrec, i, j, ierr;
 integer*1 i_1;
 character c_1;
 equivalence (i_1,c_1);
;COMIN/EGS-IO/;
 read(iunit,rec=jrec,IOSTAT=ierr) c_1;
 IF (ierr.ne.0) [
    $egs_warning(*,' *** egs_read_byte: ERROR READING A byte *** ');
    $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
    egs_read_byte = -1; return;
 ]
 jrec = jrec + 1; egs_read_byte = i_1;
 return; end;

"================================================================="
 integer*2 function egs_read_short(iunit, jrec);
"================================================================="
" Reads short int from a C/C++ binary file at jrec position        "
 implicit none;
 integer iunit, jrec, i, j, ierr;
 integer*2 i_2;
 character c_2(2);
 equivalence (i_2,c_2);
;COMIN/EGS-IO/;
 j = 0;
 DO i=jrec,jrec+1[
  j = j + 1;
  read(iunit,rec=i,IOSTAT=ierr) c_2(j);
  IF (ierr.ne.0) [
    $egs_warning(*,' *** egs_read_short: ERROR READING short integer *** ');
    $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
    egs_read_short = -1; return;
  ]
 ]
 jrec = jrec + 2; egs_read_short = i_2;
 return; end;

"================================================================="
 integer*4 function egs_read_int(iunit, jrec);
"================================================================="
" Reads integer from a C/C++ binary file at jrec position        "
 implicit none;
 integer iunit, jrec, i, j, ierr;
 integer*4 i_4;
 character c_4(4);
 equivalence (i_4,c_4);
;COMIN/EGS-IO/;
 j = 0;
 DO i=jrec,jrec+3[
  j = j + 1;
  read(iunit,rec=i,IOSTAT=ierr) c_4(j);
  IF (ierr.ne.0) [
    $egs_warning(*,' *** egs_read_int: ERROR READING integer *** ');
    $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
    egs_read_int = -1; return;
  ]
 ]
 jrec = jrec + 4; egs_read_int = i_4;
 return; end;


"================================================================="
 real*4 function egs_read_real(iunit, jrec);
"================================================================="
" Reads float from a C/C++ binary file at jrec position        "
 implicit none;
 integer iunit, jrec, i, j, ierr;
 real*4 r_4;
 character c_4(4);
 equivalence (r_4,c_4);
;COMIN/EGS-IO/;
 j = 0;
 DO i=jrec,jrec+3[
  j = j + 1;
  read(iunit,rec=i,IOSTAT=ierr) c_4(j);
  IF (ierr.ne.0) [
    $egs_warning(*,' *** egs_read_real: ERROR READING float *** ');
    $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
    egs_read_real = -1; return;
  ]
 ]
 jrec = jrec + 4; egs_read_real = r_4;
 return; end;

"****************************************************************
"*                                                              *
"*                 Function ibsearch(a, nsh, b)                 *
"*                                                              *
"*       binary search for an element l of array b such that    *
"*   b[l] =< a < b[l+1], array must be monotonically increasing *
"*                                                              *
"****************************************************************
$INTEGER function ibsearch(a, nsh, b);
 implicit none;
 $REAL a, b(*);
 $INTEGER min,max,help,nsh;
 $REAL x;
 min = 1; max = nsh; x = a;
 WHILE ( min < max-1 )[
       help = (max+min)/2;
       IF ( b(help).le.x)[min = help;]
       ELSE[max = help;]
 ]
 ibsearch = min;
 return;end;

%C80
"#############################################################################"
"                                                                             "
"  EGSnrc parallel processing functions                                       "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Iwan Kawrakow, 2003                                       "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                   Frederic Tessier                                          "
"                                                                             "
"#############################################################################"
"                                                                             "
" The following set of functions only gets included if we found a working     "
" C compiler that can compile egs_c_utils.c                                   "
"                                                                             "
"#############################################################################"


%I4
%C80
%Q1
!INDENT F2;
#ifdef HAVE_C_COMPILER;

"*****************************************************************************
$INTEGER function egs_create_lockfile(flag);
"*****************************************************************************
" Create a lock file in the user code directory to store parallel processing
" information. To be called from job #1.
"*****************************************************************************
$INTEGER flag;
;COMIN/EGS-IO/;
character*512 fname;
$INTEGER i,lnblnk1,l,istat;

$set_string(fname,' ');
fname = $cstring(egs_home) // $cstring(user_code) // $file_sep //
        $cstring(output_file) // '.lock';
l = lnblnk1(fname)+1;
fname(l:l) = char(0); " String must be null terminated "
call egs_create_control_file(fname,istat);
IF( istat ~= 0 & flag = 1 ) [
    $egs_fatal(*,'Failed to create a lock file named ',$cstring(fname));
]
egs_create_lockfile = istat;
return; end;

"*****************************************************************************
$INTEGER function egs_open_lockfile(flag);
"*****************************************************************************
" Open a lock file in the user code directory to read/write parallel
" processing info. To be called from all jobs except 1.
"*****************************************************************************
$INTEGER flag;
;COMIN/EGS-IO/;
character*512 fname;
$INTEGER i,lnblnk1,l,istat;
$set_string(fname,' ');
fname = $cstring(egs_home) // $cstring(user_code) // $file_sep //
        $cstring(output_file) // '.lock';
l = lnblnk1(fname)+1;
fname(l:l) = char(0); " String must be null terminated "
call egs_open_control_file(fname,istat);
IF( istat ~= 0 & flag = 1 ) [
    $egs_fatal(*,'Failed to open the lock file named ',$cstring(fname));
]
egs_open_lockfile = istat;
return; end;

"*****************************************************************************
subroutine egs_remove_lockfile(istat);
"*****************************************************************************
$INTEGER istat;
;COMIN/EGS-IO/;
character*512 fname;
$INTEGER i,lnblnk1,l;
$set_string(fname,' ');
fname = $cstring(egs_home) // $cstring(user_code) // $file_sep //
        $cstring(output_file) // '.lock';
l = lnblnk1(fname)+1;
fname(l:l) = char(0); " String must be null terminated "
call egs_remove_file(fname,istat);
return; end;

"*****************************************************************************
subroutine egs_pjob_control(ncase,n_run,n_left,n_tot,sum,sum2,res,dres);
"*****************************************************************************
"
" This subroutine controls a parallel run. It only works if the EGS_HOME
" directory is the same for all machines participating in the parallel
" processing (e.g. EGS_HOME is on a NFS for *nix or on a network share on
" Windows).
" n_case: number of histories to be run (all jobs, not just the current
"         job)  (input)
" n_run:  number of histories the user code should run (output). If n_run = 0,
"         then finish simulation, clean up, call egs_finish and
"         egs_pjob_finish (in that order) and exit.
" n_left  no. of histories left to run after current job has been submitted
" n_tot:  should be set to number of histories from previous runs (if any)
"         for first call from job number 1. For all other jobs and for all
"         other calls from job 1, it is set by egs_pjob_control to the the
"         number of histories run so far (including previous runs and other
"         parallel jobs).
"         Note: n_case, n_run and n_tot are $LONG_INT
" sum,    input. for first call and job 1, score and score squared for quantity
" sum2:   of interest, should be zero for first call from jobs other than 1.
"         score for quantity of interest since last call to this subroutine
"         for all other calls.
" res:    combined result for the quantity of interest from previous runs
"         and other parallel jobs, output
" dres:   relative uncertainty of res in %
"
" The shower loop of a user code that wants to use the new parallel processing
" implementation should look something like this:
"
" /sum,sum2/=0; (or result from a previous run, if i_parallel=1)
" /last_sum,last_sum2/=0;
" :start_simulation:
" x=sum-last_sum; x2=sum2-last_sum2; last_sum=sum; last_sum2=sum2;
" call egs_pjob_control(ncase,n_run,n_tot,x,x2,res,dres);
" IF( n_run = 0 ) goto :end_simulation:
" write(6,*) ' running ',n_run,' histories,' n_tot so far: ',n_tot;
" write(6,*) ' result so far: ',res,' +/- ',dres,' %';
" DO icase=1,n_run [
"    get source particle, call shower. sum and sum2 are updated
" ]
" goto :start_simulation:;
" :end_simulation:
" analyze and output results for this job.
" call egs_finish;
"   (after egs_finish all output files are closed and moved to the user code
"    directory from the temporary working directory).
" call egs_pjob_finish(combine_results,'.egsdat');
" output combined results.
" end;
"
" In the above, combine_results is a user supplied subroutine that
" combines parallel runs and takes a file name as an argument.
" egs_pjob_finish  decreases the number of running job, n_job, in the
" job control file by one. If n_job > 0, it simply returns.
" If n_job = 0 (i.e. this job is the last job), it checks for
" data files output_file_wj.egsdat, j=1,99. For each file found, it calls
" combine_results with that file name.
"

implicit none;
$LONG_INT ncase,n_run,n_tot;
$REAL    sum,sum2,res,dres;
;COMIN/EGS-IO,my_times/;

$LONG_INT n_last,n_left,nn_tot;
integer   t_dum(8);
$INTEGER  i,lnblnk1,n_write,n_read,istat,n_job;
$INTEGER  egs_create_lockfile, egs_open_lockfile;
$REAL     tmp,tmp2;
$LOGICAL first_time;
character control_string*256;
data first_time/.true./;
save first_time,n_last;

IF( n_parallel <= 0 ) [
    n_run = ncase; return;
]

IF( first_time ) n_last = 0;

$set_string(control_string,' ');
n_run = ncase/n_parallel/$N_CHUNKS;
n_left = ncase;

REPLACE {$control_format} WITH {
  '(2i15,i4,2(1pe16.8),1pe13.5,0pf7.2,2x,8i5)'};

IF( first_time ) [
   IF( n_run > n_left ) n_run = n_left;
   n_left = ncase - n_run;

   IF( i_parallel = first_parallel ) [ "I'm first job => "
                                       "create the job control file"
       istat = egs_create_lockfile(1); "The 1 tells egs_create_lockfile to "
                                       "print an error message and exit if"
                                       "it fails."
       IF( n_tot > 1 ) [ "=> a continuation from a previous run "
          res = sum/n_tot; dres = sum2/n_tot - res*res;
          IF( res > 0 & dres > 0 ) [ dres = sqrt(dres/(n_tot-1))/res*100; ]
          ELSE [ dres = 99.9 ]
       ] ELSE [ res = 0; dres = 99.9; ]

       /*
       write(control_string,$control_format)
         n_left,n_tot,i_parallel,sum,sum2,res,dres,(t_first(i),i=1,8);
       */
       write(control_string,$control_format)
         n_left,n_tot,1,sum,sum2,res,dres,(t_first(i),i=1,8);
       n_write = lnblnk1(control_string) + 1;
       call egs_write_control_file(control_string,n_write,istat);
       IF( istat ~= n_write ) [
           $egs_fatal(*,'job 1: failed to write to lock file ',n_write,istat);
       ]
       call egs_unlock_control_file(istat);
       IF( istat ~= 0 ) [
           $egs_fatal(*,'job 1: failed to unlock the file ',istat);
       ]
       first_time = .false.;
       n_max_parallel = 1; n_last = n_run;
       return;
   ]
   istat = egs_open_lockfile(1);
]

" Here for all calls except first call from job 1. "

" Lock and rewind the job control file "
call egs_rewind_control_file(istat);
IF( istat ~= 0 ) [
    $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the control ',
      'file', istat);
]

" Read the job control string string "
n_read = len(control_string);
call egs_read_control_file(control_string,n_read,istat);

" Read from the job control string string "
read(control_string,*,err=:error_lockfile_read:) n_left,nn_tot,n_job,tmp,tmp2,
     res,dres,(t_dum(i),i=1,8);

" Update the number of histories finished so far "
nn_tot = nn_tot + n_last;

" Update the score for the quantity of interest "
tmp = tmp + sum; tmp2 = tmp2 + sum2;

" First call => increase number of running jobs "
IF( first_time ) [
    first_time = .false.; n_job = n_job + 1;
    nn_tot = nn_tot + n_tot;
]
n_tot = nn_tot;

" If n_tot > 1, do stat. analysis and put result is res, dres "
IF( n_tot > 1 ) [
    res = tmp/n_tot; dres = tmp2/n_tot - res*res;
    IF( res > 0 & dres > 0 ) [ dres = sqrt(dres/(n_tot-1))/res*100; ]
    ELSE [ dres = 99.9 ]
] ELSE [ res = 0; dres = 99.9; ]

" Take another chunk of histories to run "
IF( n_run > n_left ) [
    n_run = n_left; n_left = 0;
] ELSE [ n_left = n_left - n_run; ]

n_last = n_run;

" Write new job control info into job control string "
$set_string(control_string,' ');
write(control_string,$control_format)
  n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_dum(i),i=1,8);

" Rewind again the job control file "
call egs_rewind_control_file(istat);
IF( istat ~= 0 ) [
    $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the control ',
      'file', istat);

]

" Write the new job control string "
n_write = lnblnk1(control_string) + 1;
call egs_write_control_file(control_string,n_write,istat);
IF( istat ~= n_write ) [
    $egs_fatal(*,'job ',i_parallel,': failed to write to lock file ',
       n_write,istat);
]

" Finally unlock the job control file so that other jobs can access it. "
call egs_unlock_control_file(istat);
IF( istat ~= 0 ) [
    $egs_fatal(*,'job ',i_parallel,': failed to unlock the file ',istat);
]
IF( n_job > n_max_parallel ) n_max_parallel = n_job;
return;

:error_lockfile_read:
$egs_fatal('(a,/a)','Failed to read from job control file: got ',
     $cstring(control_string));
return; end;

"******************************************************************************
subroutine egs_pjob_finish(n_job);
"******************************************************************************
implicit none;
$INTEGER n_job;

;COMIN/EGS-IO,my_times/;

$INTEGER  istat,i,lnblnk1,n_read,n_write;
$LONG_INT n_left,n_tot;
integer   t_start(8),t_end(8);
$REAL     tmp,tmp2,res,dres,t_run;
real      egs_time_diff;
character control_string*256;

" Lock and rewind the job control file "
call egs_rewind_control_file(istat);
IF( istat ~= 0 ) [
    $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the control ',
      'file', istat);
]

" Read the job control string string "
n_read = len(control_string);
call egs_read_control_file(control_string,n_read,istat);

" Read from the job control string string "
read(control_string,*,end=:error2_lockfile_read:,err=:error2_lockfile_read:)
  n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_start(i),i=1,8);

n_job = n_job - 1;
IF( n_job > 0 ) [  " Other jobs still running "
    $set_string(control_string,' ');
    write(control_string,$control_format)
      n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_start(i),i=1,8);
    call egs_rewind_control_file(istat);
    IF( istat ~= 0 ) [
        $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the ',
          'control file, error was:', istat);
    ]
    n_write = lnblnk1(control_string) + 1;
    call egs_write_control_file(control_string,n_write,istat);
    IF( istat ~= n_write ) [
        $egs_fatal(*,'job ',i_parallel,': failed to write to lock file ',
           n_write,istat);
    ]
    call egs_unlock_control_file(istat);
    call egs_close_control_file(istat);
    return;
]

" If here, I'm the last job => remove job control file
/* call egs_unlock_control_file(istat); */
call egs_close_control_file(istat);
call egs_remove_lockfile(istat);
i_parallel = 0; call egs_open_units(.false.);
call egs_date_and_time(t_end);
t_run = egs_time_diff(t_start,t_end);
$egs_info('(/a/,a,t55,i3/,a,t55,i3/,a,f9.1,a,f9.4,a/,a//)',
'**************** finished parallel execution ******************',
' number of parallel jobs requested: ',n_parallel,
' max. number of jobs executing simultaneously: ',n_max_parallel,
' elapsed time since first job started: ',t_run,' s (',t_run/3600,' h)',
'***************************************************************');
return;

:error2_lockfile_read:;
$egs_fatal('(a,/a)',
  'In egs_pjob_finish: failed to read from control string ',
  $cstring(control_string));

return; end;


#endif;
;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc xvgr plotting subroutines                                           "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Andrew Booth, 1995                                        "
"                                                                             "
"  Contributors:    Charlie Ma                                                "
"                   Aaron Merovitz                                            "
"                   Dave Rogers                                               "
"                   Blake Walters                                             "
"                   Iwan Kawrakow                                             "
"                   Ernesto Mainegra-Hing                                     "
"                   Frederic Tessier                                          "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


!INDENT F2;
%I4
%Q1
"************************************************************************"

SUBROUTINE XVGRPLOT (X, Y, ERRY, NPTS, CURVENUM, SERIESTITLE,
                        XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                        UNITNUM, TYPE, HISTXMIN, AXISTYPE);

"************************************************************************"
"                                                                        "
"  This subroutine is used to create an xvgr plot file that will plot    "
"  Y as a function of X and include all of the pertinent information for "
"  the graph.  Each time the subroutine is called it writes one series   "
"  worth of data points to the unit specified.  For graphs that use      "
"  several series, multiple subroutine calls are required.               "
"                                                                        "
"  Written  by:  Andrew Booth, August 1995                               "
"  Modified by:  C-M Ma, Sept. 1995                                      "
"  Modified by:  Andrew Booth, July 1996                                 "
"                - introduced AXISTYPE argument to handle lin and log    "
"                  axis combinations.                                    "
"   Jan 98 A Merovitz/DR added xview xmin value so y axis label displayed"
"   Feb 98 A Merovitz/DR if non-negative, makes zeros fudge*smalest      "
"   Jun 99 BW/DWOR in Y>0 and ERRY crosses/touches 0, adjusted>0.0       "
"   Jul 99 DWOR made grace/xmgr compatible and added timestamp           "
"                                                                        "
"  The arguments of the subroutine are described in detail below:        "
"                                                                        "
"     1) X - array of x values to be plotted.  Top of bin if histogram.  "
"     2) Y - corresponding array of y values to be plotted.              "
"     3) ERRY - array containing uncertainties in Y for the plot.        "
"            If the first entry of this array is 0, it is                "
"            assumed that the graph is of type XY.  If it is             "
"            not 0, the graph is of type XY-DY.                          "
"     4) NPTS - the number (integer) of points to be plotted. This       "
"            should be the number of data points that exist in the       "
"            X, Y, and ERRY arrays.                                      "
"     5) CURVENUM - the number (integer) of the curve that is to be      "
"            plotted. The first curve number should be 0.  If this       "
"            number is not 0, then it is assumed that the plot file      "
"            already exists and the subroutine call is to add an         "
"            additional series to the existing graph.                    "
"     6) SERIESTITLE - string (max of 60 characters) giving the          "
"            series title (legend) for the data in the X and Y arrays.   "
"     7) XTITLE - string (max of 60 characters) giving the x axis        "
"            title.                                                      "
"     8) YTITLE - string (max of 60 characters) giving the y axis        "
"            title.                                                      "
"     9) GRAPHTITLE - string (max of 60 characters) giving the           "
"            graph title.                                                "
"    10) SUBTITLE - string (max of 60 characters) giving the subtitle    "
"            for the graph.                                              "
"    11) UNITNUM - number (integer) specifying where the data is to      "
"            be written.                                                 "
"            this unit must be opened by the calling routine             "
"    12) TYPE - 0 if data is to be written as normal point plot.         "
"               1 if data is to be written as a histogram plot.          "
"    13) HISTXMIN - used for histogram plots only.  This is a real       "
"                   number with the value of lower xbin for the plot.    "
"    14) AXISTYPE - 0 if linear-linear plot                              "
"                   1 if log-linear plot (y = log; x = lin)              "
"                   2 if linear-log plot (y = lin; x = log)              "
"                   3 if log-log plot                                    "
"                                                                        "
"                                                                        "
"************************************************************************"
  REPLACE{$SMALLFACTOR} WITH {1.E-5}
  REPLACE{$LARGEFACTOR} WITH {1.E5}

  IMPLICIT NONE;

  $INTEGER MAX, IDEBUG;
  PARAMETER (MAX = 400);  "---MAX used in defining the maximum number of---"
                          "---points that can be plotted in one series. ---"
  $INTEGER NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE;
  $REAL X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,HISTXMIN,ERRYOLD,SMALLESTX,
    SMALLESTY,FUDGE;
  $INTEGER TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENGTH;
  $INTEGER LOGX, LOGY, LOGDY,ZEROYCOUNT;

  "CHARACTER*80 SUBTITLE;"
  "CHARACTER*60 GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;"
  " IK changed the above to avoid complains from the compiler about"
  " inconsistent argument lists"
  CHARACTER*(*) SUBTITLE;
  CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;
  CHARACTER*10 INDEX;
  CHARACTER*3  INDEXNUM;

  $LOGICAL TESTFILE, ALLPOS;
  $REAL    one;
  parameter (one = 1);

  FUDGE = 1.e-10;              "If a number in the gaph is zero, it is replaced"
                             "by the (smallest number in the gaph)*(FUDGE)"
  IDEBUG = 0;  "set to 1 to get debug stmts active"
  IF (IDEBUG = 1) [
        write(6,'(//'' Entering xvgrplot ''/)');
        write(6,'('' Curve'',I3,'' to go to unit'',I3)')CURVENUM,UNITNUM;
        write(6,'(''SERIESTITLE: '',a60)') SERIESTITLE;
        write(6,'(''XTITLE:      '',a60)') XTITLE;
        write(6,'(''YTITLE       '',a60)') YTITLE;
        write(6,'(''GRAPHTILE:   '',a60)') graphtitle;
        write(6,'(''SUBTITLE:    '',a80)') subtitle;
  ]
  IF ( NPTS .gt. MAX) [ "Asked for too many points"
        OUTPUT NPTS, MAX;(//' **************************'/
        ' Number of points asked for =', I5,
        ' is greater than max allowed of', I4/
        ' Setting NPTS to MAX, you could adjust MAX in xvgrplot.mortran'/
        ' **************************'//);
        NPTS1 = MAX;
  ] ELSE [NPTS1 = NPTS;]

  "---Check to make sure that speicified unit is open for---"
  "---writing to.---"
  INQUIRE(UNIT = UNITNUM, OPENED = TESTFILE);

  IF (~TESTFILE) [ "---File has not been opened - print message.---"
    WRITE(6,:125:) UNITNUM;
    :125: FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------'
                 ,/'   Unit specified (',I2,') is not open.'
                 ,/'   Unit must be opened before using subroutine.'
                 ,/'   Data not written to file.'
                 ,/'  ----------------------------------------------'//);
    RETURN;
  ] "---End of error message for unopened file---"

  "---Set defaults if arguments are left blank.---"
  IF (GRAPHTITLE = ' ') [
    GRAPHTITLE = 'Untitled Graph - No title specified in subroutine';
  ]
  IF (XTITLE = ' ') [ XTITLE = 'X-axis not titled in subroutine';  ]

  IF (YTITLE = ' ') [ YTITLE = 'Y-axis not titled in subroutine'; ]

  IF (SERIESTITLE = ' ') [
    SERIESTITLE = 'series # ';
    INDEX = '0123456789';
    INDEXNUM = INDEX(CURVENUM+1:CURVENUM+1);
    SERIESTITLE(9:9) = INDEXNUM;
  ]

  "---Find lengths of stings for formatting purposes---"
  "---Initialize variable lengths---"

  TITLELENGTH = 61;    SUBLENGTH = 61;       XAXISLENGTH = 61;
  YAXISLENGTH = 61;    SERIESLENGTH = 61;

  "---Find title string length---"
  LOOP [
    TITLELENGTH = TITLELENGTH - 1;
  ] UNTIL (GRAPHTITLE(TITLELENGTH:TITLELENGTH) ~= ' ');

  "---Find subtitle string length---"
  LOOP [
    SUBLENGTH = SUBLENGTH - 1;
  ] UNTIL (SUBTITLE(SUBLENGTH:SUBLENGTH) ~= ' ');

  "---Find x-axis string length---"
  LOOP [
    XAXISLENGTH = XAXISLENGTH - 1;
  ] UNTIL (XTITLE(XAXISLENGTH:XAXISLENGTH) ~= ' ');

  "---Find y-axis string length---"
  LOOP [
    YAXISLENGTH = YAXISLENGTH - 1;
  ] UNTIL (YTITLE(YAXISLENGTH:YAXISLENGTH) ~= ' ');

  "---Find series title length---"
  LOOP [
    SERIESLENGTH = SERIESLENGTH - 1;
  ] UNTIL (SERIESTITLE(SERIESLENGTH:SERIESLENGTH) ~= ' ');
  IF( IDEBUG = 1) [
    OUTPUT SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELENGTH;
    (' SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELENGTH'/
     5I10)
  ]

  "---Small bit of error checking here done for the purpose of warning the---"
  "---user if there is a problem when using a 'log' type graph.           ---"
  "---Possible problems are:                                              ---"
  "---    1.)  value on log scale < or = 0.                               ---"
  "---    2.)  value of error bar for xydy plot extends into the region   ---"
  "---                    where y < or = 0.                               ---"
  "---                                                                    ---"
  "---To keep track of these problems the flags LOGX, LOGY, and LOGDY will---"
  "---be set if there is the respective error.                            ---"
  "---(ie.  if LOGX set (=1) then there exist an X value that is <= 0 AND ---"
  "--- the xaxis is set to be a log scale.)                               ---"
  "--------------------------------------------------------------------------"

  "---Initialize LOGX, LOGY, and LOGDY to be not set (0)---"
  LOGX = 0;          LOGY = 0;          LOGDY = 0;

  "---Initialize ZEROYCOUNT to 0---"
  ZEROYCOUNT=0;

  "In all cases where no negatives are concerned, fix points that are"
  "equal to 0.0"
  "Aaron Merovitz, Jan 1998"
  ALLPOS=.TRUE.;
  IF ( X(1)=0.0 ) [SMALLESTX = 0.1;] ELSE [SMALLESTX=X(1);]
  IF ( Y(1)=0.0 ) [SMALLESTY = 0.1;] ELSE [SMALLESTY=Y(1);]
  DO COUNT = 1, NPTS1 [
       IF ((X(COUNT) < SMALLESTX) & (X(COUNT)~=0.)) [SMALLESTX=X(COUNT);]
       IF ((Y(COUNT) < SMALLESTY) & (Y(COUNT)~=0.)) [SMALLESTY=Y(COUNT);]
       IF ((X(COUNT) < 0.)|(Y(COUNT) < 0.)) [ALLPOS=.FALSE.;]
  ]
  IF (ALLPOS) [
     DO COUNT = 1, NPTS1 [
          IF (X(COUNT)=0.) [X(COUNT)=SMALLESTX*FUDGE;]
          IF (Y(COUNT)=0.) [Y(COUNT)=SMALLESTY*FUDGE;]
     ]
  ]
  "---Loop through data points (if any log scales set) to see if there are---"
  "---any  <= 0 problems that might not have been fixed---"

  IF (AXISTYPE > 0) [  "---At least one axis is of log type---"
    DO COUNT = 1, NPTS1 [
      IF (X(COUNT) <= 0.) [ LOGX = 1; ]
      IF (Y(COUNT) <= 0.) [ LOGY = 1; ]
      IF ((Y(COUNT)-ERRY(COUNT)) <= 0.) [ LOGDY = 1; ]
    ]
  ]
  ELSE[ "--fix error bars that just hit Y axis in case user wants"
        "to switch to linlog plot while in xmgr--"
    DO COUNT = 1, NPTS1 [
       IF(Y(COUNT)-ERRY(COUNT) < Y(COUNT)-0.9999*Y(COUNT) & Y(COUNT)>0.)[
           ZEROYCOUNT=ZEROYCOUNT+1;
           IF(ZEROYCOUNT=1)[
             WRITE(6,:105:);
 :105: FORMAT (/' ------------WARNING from Subroutine XVGRPLOT-----------'
              ,/'  Some errors give 0 value and so are adjusted so       '
              ,/'  that you can switch to a log Y scale while in xmgr.   '
              ,/' -------------------------------------------------------'/);
           ]
           ERRYOLD=ERRY(COUNT);
           ERRY(COUNT) = 0.9999*Y(COUNT);
           "WRITE(6,:106:) COUNT,ERRYOLD,ERRY(COUNT);"
 ":106: FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, ' to'"
               "       /'        ',1PE11.4,'.');"
       ]
    ]
  ]

  "---Use this info later when writing to file---"

  "---Now begin writing information to unit---"
  IF (CURVENUM = 0) [ "---Case where plot file must start from scratch---"
    "---Insert xvgr graph header in file.---"

    "---Start with type of graph.  (lin-lin, log-lin, lin-log, or log-log)---"
    IF (AXISTYPE = 0) [ "---Graph is of type lin-lin---"
      WRITE(UNITNUM,:90:) 'xy';
    ] ELSEIF (AXISTYPE = 1) [ "---Graph is of type log-lin---"
      WRITE(UNITNUM,:90:) 'logy';
      WRITE(UNITNUM,:1080:);
    ] ELSEIF (AXISTYPE = 2) [ "---Graph is of type lin-log---"
      WRITE(UNITNUM,:90:) 'logx';
      WRITE(UNITNUM,:1080:);
    ] ELSEIF (AXISTYPE = 3) [ "---Graph is of type log-log---"
      WRITE(UNITNUM,:90:) 'logxy';
      WRITE(UNITNUM,:1080:);
      WRITE(UNITNUM,:1090:);
    ] ELSE [ "--anything else specified is in error--"
      WRITE(6,:91:) AXISTYPE;
      :91: FORMAT (//'  ------------Error in Subroutine XVGRPLOT-----------'
                 ,/'   AXISTYPE specified (',I2,') is not a valid option.'
                 ,/'  ----------------------------------------------'//);
      RETURN;
    ]

    :90: FORMAT ('@g0 type ',A,' ');
    :1080: FORMAT ('@    xaxis  ticklabel format exponential');
    :1090: FORMAT ('@    yaxis  ticklabel format exponential');

    "---Titles and things---"
    WRITE(UNITNUM,:100:) GRAPHTITLE(1:TITLELENGTH)
                        ,SUBTITLE(1:SUBLENGTH)
                        ,XTITLE(1:XAXISLENGTH)
                        ,YTITLE(1:YAXISLENGTH);
    :100: FORMAT ('@    title "',A,'"'/
                 ,'@    subtitle "',A,'"'/
                 ,'@    legend on'/
                 ,'@    legend box linestyle 0'/
                 ,'@    legend x1 0.6'/
                 ,'@    legend y1 0.75'/
                 ,'@    view xmin 0.250000'/
                 ,'@    xaxis  label "',A,'"'/
                 ,'@    timestamp on'/
                 ,'@    yaxis  label "',A,'"');
  ]  "---End CURVENUM = 0---"

"--XVGR has the characteristic that if the same input command is issued more---"
"--than once, the last one to be read is the one that is executed.  For this---"
"--situation, this is perfect.  Say the first series written to a file is of---"
"--a log scale, and the second is also of log scale, but has a data point   ---"
"--on the log scale that is < or = 0, then we can write the '@g0 type xy'   ---"
"--to the file AFTER the previous '@g0 type logxy' and the xy type will     ---"
"--prevail.  This will prevent errors when executing XVGR.  Of course the   ---"
"--alteration will also be written to the display.                          ---"


  IF (AXISTYPE = 1 & LOGY = 1) [  "--LOGY error--"
    WRITE(UNITNUM,:90:) 'xy';
    WRITE(6,:95:);
    :95: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
                ,/'  Log scale requested for Y axis when one or more   '
                ,/'  Y data points are 0 or negative.                  '
               ,//'  Y axis scale changed to linear.                   '
                ,/' ---------------------------------------------------'/);
  ]

  IF (AXISTYPE = 2 & LOGX = 1) [  "--LOGX error--"
    WRITE(UNITNUM,:90:) 'xy';
    WRITE(6,:96:);
    :96: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
                ,/'  Log scale requested for X axis when one or more   '
                ,/'  X data points are 0 or negative.                  '
               ,//'  X axis scale changed to linear.                   '
                ,/' ---------------------------------------------------'/);
  ]

  IF (AXISTYPE = 3 & (LOGX = 1 | LOGY = 1)) [  "--LOGX or LOGY error--"
    IF (LOGX = 1 & LOGY = 1) [
      WRITE(UNITNUM,:90:) 'xy';
      WRITE(6,:97:);
      :97: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
                  ,/'  Log scale requested for X axis and Y axis when    '
                  ,/'  one or more X and Y data points are 0 or negative.'
                 ,//'  X and Y axes scales changed to linear.            '
                  ,/' ---------------------------------------------------'/);
    ]
    ELSEIF (LOGX = 1) [ WRITE(UNITNUM,:90:) 'logy'; WRITE(6,:96:); ]
    ELSE              [ WRITE(UNITNUM,:90:) 'logx'; WRITE(6,:95:); ]
  ]

  "---now make a fix for those error bars that 'dip' beneath the x-axis on---"
  "---log plots.                                                          ---"

  IF (LOGDY = 1 & LOGY ~= 1 & (AXISTYPE = 3 | AXISTYPE = 1)) [
    "--if LOGDY problem and log scale not been already reset to linear--"
    "--do fudge to correct the problem--"

    WRITE(6,:101:);
    :101: FORMAT (/' ------------WARNING from Subroutine XVGRPLOT-----------'
              ,/'  Log scale requested for Y axis, and Y value less      '
              ,/'  error gives 0 or negative value.                      '
             ,//'  Error adjusted to aviod negavite values on log scale. '
              ,/' -------------------------------------------------------'/);

    DO COUNT = 1,NPTS1[
      IF(Y(COUNT)-ERRY(COUNT) < Y(COUNT)-0.9999*Y(COUNT)) [
        ERRYOLD = ERRY(COUNT);
        ERRY(COUNT) = 0.9999*Y(COUNT);
        WRITE(6,:103:) COUNT,ERRYOLD,ERRY(COUNT);
        :103: FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, ' to'
                      /'        ',1PE11.4,'.');
      ]
    ]

    WRITE(6,:104:);
    :104: FORMAT (/' -------------------------------------------------------'/);

  ]

  "---Include data about series for legend purposes.---"
  "first line needed to make it work with grace"
  IF (CURVENUM < 10 ) [
    WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM;
  ]
  ELSE [
    WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM;
  ]
  WRITE(UNITNUM,:150:)  CURVENUM,SERIESTITLE(1:SERIESLENGTH);
  :150: FORMAT ('@    legend string ',I2,' "',A,'"');


  "---Do normal plot.  ie. NOT histogram plot.---"
  IF (TYPE = 0) [ "---Normal point plot.---"

    "---Check all ERRYs.  If even one is nonzero, then series is type xydy---"
    DO COUNT = 1, NPTS1 [
      IF (ERRY(COUNT) ~= 0) [ "---Data set is not of type XY---"
        GOTO :X-Y-DY1:;
      ]
    ]

    "---Data set is of type XY---"
    WRITE(UNITNUM,:200:);
    :200: FORMAT ('@TYPE xy');
    IF (CURVENUM < 10) [
       WRITE(UNITNUM,:151:) CURVENUM;
       IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
       ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
    ]
    ELSE [
       WRITE(UNITNUM,:152:) CURVENUM;
       WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
    ]
    :151: FORMAT ('@    s',I1,' errorbar length 0.000000');
    :152: FORMAT ('@    s',I2,' errorbar length 0.000000');
    :197: FORMAT ('@    s',I1,' symbol color ',I2);
    :198: FORMAT ('@    s',I1,' symbol color ',I1);
    :199: FORMAT ('@    s',I2,' symbol color ',I2);

    "---Then write the data to the file.---"
    DO COUNT = 1, NPTS1 [ WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT); ]
    :250: FORMAT (1PE15.4,1PE15.4);
    GOTO  :END-X-Y-DY1:;

    "---Data set is of type XY-DY---"
    :X-Y-DY1:;
    WRITE(UNITNUM,:300:);
    :300: FORMAT ('@TYPE xydy');
    IF (CURVENUM < 10) [
    WRITE(UNITNUM,:151:) CURVENUM;
       IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
       ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
    ]
    ELSE [
       WRITE(UNITNUM,:152:) CURVENUM;
       WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
    ]

    "---Then write the data to the file.---"
    DO COUNT = 1, NPTS1 [WRITE(UNITNUM,:350:) X(COUNT),Y(COUNT),ERRY(COUNT);]
    :350: FORMAT (1PE15.4,1PE15.4,1PE15.4);
    :END-X-Y-DY1:;

  ]  "--end of point plot block--"
  ELSE [ "---Histogram plot---"

    "---Must find minimum y value in the y array to    ---"
    "---use as scale factor for establishing y-min on  ---"
    "---histogram plot.  We don't use 0 here as with 0 ---"
    "---plot can not be made into log plot in xvgr.    ---"

    YMIN = ABS($LARGEFACTOR * Y(1));

    DO COUNT = 1, NPTS1 [
       IF (ABS(Y(COUNT)) < YMIN) [ YMIN = ABS(Y(COUNT)); ]
    ]  "---End loop to find smalled Y---"

   "---Now smallest value of Y has been found.  Want to make sure that the---"
   "---first point used is even smaller than this and that it is of the same---"
   "---sign as the first Y data point in the plot.---"

    "---Now set YMIN to even smaller value for plot and set sign.---"
    YMIN = SIGN(one,Y(1)) * $SMALLFACTOR * YMIN ;

    "---Set this value in y-array as element after the---"
    "---element in index npts.---"
    Y(NPTS1+1) = YMIN;

    IF ((AXISTYPE = 2 | AXISTYPE = 3) & HISTXMIN = 0) [
      IF (X(1) = (X(2)-X(1))) [ HISTXMIN = X(1)-0.5*(X(2)-X(1)); ]
      ELSE                    [ HISTXMIN = X(1)-(X(2)-X(1)); ]

      WRITE(6,:306:) HISTXMIN;
      :306: FORMAT (/' ---------WARNING from Subroutine XVGRPLOT--------'
              ,/'  Minimum bin for X specified as 0 with log scale  '
              ,/'  on X axis.  Minimum X bin set to ',1PE10.3,'.'
              ,/' -------------------------------------------------'/);
    ]

    DO COUNT = 1, NPTS1 [
      IF (ERRY(COUNT) ~= 0.) [ "---Data set is not of type XY---"
        GOTO :X-Y-DY:;
      ]
    ]

"---Data set is of type XY---"
    IF (CURVENUM < 10) [
    WRITE(UNITNUM,:151:) CURVENUM;
       IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
       ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
    ]
    ELSE [
       WRITE(UNITNUM,:152:) CURVENUM;
       WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
    ]
    WRITE(UNITNUM,:200:);

    "---Plot the first histogram points.---"
    WRITE(UNITNUM,:250:) HISTXMIN,YMIN;
    WRITE(UNITNUM,:250:) HISTXMIN,Y(1);

    "--Then write the data to the file.---"
    DO COUNT = 1, NPTS1 [
      WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT);
      WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT+1);
    ]
    GOTO :END-X-Y-DY:;

"---Data set is of type XY-DY---"
    :X-Y-DY:;
    "---Put error of 0 on last *made-up* point in error array.---"
    ERRY(NPTS1+1) = 0.0;

    IF (CURVENUM < 10) [
    WRITE(UNITNUM,:151:) CURVENUM;
       IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
       ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
    ]
    ELSE [
       WRITE(UNITNUM,:152:) CURVENUM;
       WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
    ]
    WRITE(UNITNUM,:300:);

    "---Plot the first histogram points.---"
    IF (HISTXMIN = 0.0) [ "Aaron Meroivtz, Feb. 1998"
       HISTXMIN = SMALLESTX*FUDGE;
    ]
    WRITE(UNITNUM,:350:) HISTXMIN, YMIN, 0.;
    WRITE(UNITNUM,:350:) HISTXMIN, Y(1), 0.;
    WRITE(UNITNUM,:350:) (X(1)+HISTXMIN)/2., Y(1), ERRY(1);

    "---Then write the data to the file.---"
    DO COUNT = 1, NPTS1 [
      WRITE (UNITNUM,:350:) X(COUNT),Y(COUNT),0.;
      WRITE (UNITNUM,:350:) X(COUNT),Y(COUNT+1),0.;
      IF(COUNT < NPTS1)[
       WRITE (UNITNUM,:350:) (X(COUNT)+X(COUNT+1))/2.,Y(COUNT+1),ERRY(COUNT+1);
      ]
    ]
    :END-X-Y-DY:;
  ] "---End HIST=0 loop---"

  "---Insert end of series indicator to file.---"
  WRITE(UNITNUM,'(''&'')');

  RETURN;
  END; "---End of subroutine.---"
;

%C80
"#############################################################################"
"                                                                             "
"  EGSnrc core source code                                                    "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2000                                       "
"                   Dave Rogers, 2000                                         "
"                                                                             "
"  Contributors:    Ernesto Mainegra-Hing                                     "
"                   Blake Walters                                             "
"                   Frederic Tessier                                          "
"                   Reid Townson                                              "
"                   Victor Malkov                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"


"Compiler directives"
"==================="
%Q1         "Automatically close comments at end of line
            "but NOTE, this doesn't happen inside a REPLACE macro
            "you must open and close within a REPLACE macro.
%C80        "Allow 80 columns of source/line (default is 72)
!INDENT M2; "Indent Mortran compile listing 2 spaces each nesting level
!INDENT F2; "Indent fortran output 2 spaces each nesting level
%L          "Turn on listing

%I4 "INDENT FOUR SPACES EACH LEVEL"

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE ANNIH;
"                                                                  "
"******************************************************************"
"   GAMMA SPECTRUM FOR TWO GAMMA IN-FLIGHT POSITRON ANNIHILATION.  "
"   USING SCHEME BASED ON HEITLER'S P269-27O FORMULAE.             "
"                                                                  "
"   If the user requests radiative splitting (via nbr_split > 1),  "
"   this routine produces 2*nbr_split annihilation photons at once,"
"   each carying the fraction 1/nbr_split of the weight of the     "
"   incident positron.                                             "
"                                                                  "
"   Except for taking out the calculation of                       "
"   LOG((1.0-EP0)/EP0) out of the sampling loop and using a        "
"   rejection function normalized to its maximum, the sampling     "
"   technique is the same as the original EGS4 implementation.     "
"                                                                  "
"   I. Kawrakow, January 2000                                      "
"                                                                  "
"******************************************************************"
$IMPLICIT-NONE;

$COMIN-ANNIH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
                 "COMIN/DEBUG,STACK,UPHIOT,USEFUL,RANDOM,          "
                 "EGS-VARIANCE-REDUCTION/;                         "

$DEFINE-LOCAL-VARIABLES-ANNIH;
$INTEGER ip;

NPold = NP; "Set the old stack counter"
IF( nbr_split <= 0 ) [ return; ]
PAVIP=E(NP)+PRM; "PRECISE AVAILABLE ENERGY OF INCIDENT POSITRON,
                 "i.e. electron assumed to be at rest
AVIP=PAVIP;      "AVAILABLE ENERGY OF INCIDENT POSITRON"
A=AVIP/RM;
"AI=1.0/A;  AI not necessary, IK Oct 97"
G=A-1.0;
T=G-1.0;
P=SQRT(A*T);
POT=P/T;
EP0=1.0/(A+P);
"   SAMPLE 1/EP FROM EP=EP0 TO 1.0-EP0"
"Take the calculation of the logarithm out of the loop, IK Oct 97"
WSAMP=LOG((1.0-EP0)/EP0);

aa = u(np); bb = v(np); cc = w(np);
sinpsi = aa*aa + bb*bb;
IF( sinpsi > 1e-20 ) [
   sinpsi = sqrt(sinpsi);
   sindel = bb/sinpsi; cosdel = aa/sinpsi;
]

IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]

DO ibr = 1,nbr_split [  "nbr_split > 1 means we want splitting for any"
                        "radiative event                              "

    IF( np+1 > $MXSTACK ) [
        $egs_fatal('(//a,i6,a//)',' Stack overflow in ANNIH! np = ',np+1,
                   ' Increase $MXSTACK and try again' );
    ]

    LOOP[
        $RANDOMSET RNNO01;
        EP=EP0*EXP(RNNO01*WSAMP);
        "   NOW DECIDE WHETHER TO ACCEPT"
        $RANDOMSET RNNO02;
        "REJF=1.0-EP+AI*AI*(2.0*G-1.0/EP);"
        "The above rejection function has a maximum = 1 - 2/A**2"
        "For efficiency, it is better to divide by the maximum value, IK Oct 97"
        REJF = 1 - (EP*A-1)**2/(EP*(A*A-2));
    ] UNTIL (RNNO02 <= REJF);


    "   SET UP ENERGIES"
    ESG1=AVIP*EP; "ENERGY OF SECONDARY GAMMA 1"
    PESG1=ESG1; "PRECISE ENERGY OF SECONDARY GAMMA 1"
    E(NP)=PESG1; IQ(NP)=0;
    IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
    $TRANSFER PROPERTIES TO (np) FROM (ip);
    COSTHE=MAX(-1.0,MIN(1.0,(ESG1-RM)*POT/ESG1));
    SINTHE=SQRT(1.0-COSTHE*COSTHE);
    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
    IF( sinpsi >= 1e-10 ) [
        us = sinthe*cphi; vs = sinthe*sphi;
        u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
        v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
        w(np) = cc*costhe - sinpsi*us;
    ]
    ELSE [
        u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
    ]
    np = np + 1;
    PESG2=PAVIP-PESG1; esg2 = pesg2;
    e(np) = pesg2; iq(np) = 0;
    $TRANSFER PROPERTIES TO (np) FROM (np-1);
    COSTHE=MAX(-1.0,MIN(1.0,(ESG2-RM)*POT/ESG2));
    SINTHE=-SQRT(1.0-COSTHE*COSTHE);
    IF( sinpsi >= 1e-10 ) [
        us = sinthe*cphi; vs = sinthe*sphi;
        u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
        v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
        w(np) = cc*costhe - sinpsi*us;
    ]
    ELSE [
        u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
    ]
    np = np + 1;

]
np = np-1;

RETURN;
"END OF SUBROUTINE ANNIH"   END;

"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE ANNIH_AT_REST;
"                                                                  "
" It is handy to be able to initiate annihilation at rest from     "
" places other than the electron discard section (e.g. AUSGAB)     "
" Annihilation at rest takes a sufficent amount of time to not     "
" have any real benefit from this code being inline in the         "
" ELECTR subroutine.                                               "
" I. Kawrakow, June 2005.                                          "
"******************************************************************"
$IMPLICIT-NONE;
$COMIN-ANNIH-ATREST;
$REAL costhe,sinthe,cphi,sphi;
$INTEGER ibr,ip;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;

NPold = NP;
$CHECK-STACK(np+2*nbr_split-1,'ANNIH_AT_REST');
IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]
    " nbr_split > 1 means user wants to use radiative "
    " splitting => produce 2*nbr_split annihilation   "
    " photons at once                                 "
DO ibr = 1, nbr_split [
    "Pick random direction for first gamma
    $RANDOMSET costhe; costhe = 2*costhe-1;
    sinthe = sqrt(max(0.0,(1-costhe)*(1+costhe)));
    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
    e(np) = prm; iq(np) = 0;
    IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
    $TRANSFER PROPERTIES TO (np) FROM (ip);
    u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = costhe;
    np = np+1;
    e(np) = prm; iq(np) = 0;
    $TRANSFER PROPERTIES TO (np) FROM (np-1);
    u(np) = -u(np-1); v(np) = -v(np-1); w(np) = -w(np-1);
    np = np+1;
]
np = np-1;
return; end;


%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE BHABHA;
"                                                                  "
"******************************************************************"
"   DISCRETE BHABHA SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
"   ARBITRARILY DEFINED AND CALCULATED TO MEAN BHABHA SCATTERINGS  "
"   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
"   IT BE TRANSPORTED DISCRETELY, I.E. E=AE OR T=TE.  IT IS NOT    "
"   GUARANTEED THAT THE FINAL POSITRON WILL HAVE THIS MUCH ENERGY  "
"   HOWEVER.  THE EXACT BHABHA DIFFERENTIAL CROSS SECTION IS USED. "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-BHABHA;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
                   "COMIN/DEBUG,EGS-VARIANCE-REDUCTION,STACK,"
                                "THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-BHABHA;

NPold = NP;      "Set the old stack counter"
PEIP=E(NP); "PRECISE ENERGY OF INCIDENT POSITRON"
EIP=PEIP; "ENERGY OF INCIDENT POSITRON"
PEKIN=PEIP-PRM;  "PRECISE K.E. OF INCIDENT POSITRON"
EKIN=PEKIN;
T0=EKIN/RM;
E0=T0+1.;
YY=1./(T0+2.);
E02=E0*E0;
"BETAI2=E02/(E02-1.);" "BLIF 96/2/1 -- not needed for Bhabha fix-up"
BETA2=(E02-1.)/E02;    "BLIF 96/2/1 -- needed for Bhabha fix-up"
EP0=TE(MEDIUM)/EKIN;
EP0C=1.-EP0;
Y2=YY*YY;
YP=1.-2.*YY;
YP2=YP*YP;
B4=YP2*YP;
B3=B4+YP2;
B2=YP*(3.+Y2);
B1=2.-Y2;
"   SAMPLE BR FROM MINIMUM(EP0) TO 1."
LOOP[$RANDOMSET RNNO03;
BR=EP0/(1.-EP0C*RNNO03);
"   APPLY REJECTION FUNCTION"
$RANDOMSET RNNO04;
"REJF2=EP0C*(BETAI2-BR*(B1-BR*(B2-BR*(B3-BR*B4))));BLIF 96/2/1 -- Bhabha fix-up"
REJF2=(1.0-BETA2*BR*(B1-BR*(B2-BR*(B3-BR*B4)))); "BLIF 96/2/1 -- Bhabha fix-up"
]UNTIL RNNO04.LE.REJF2 ;
"   IF E- GOT MORE THAN E+, MOVE THE E+ POINTER AND REFLECT B"
$CHECK-STACK(np+1,'BHABHA');
IF (BR.LT.0.5)[IQ(NP+1)=-1;]ELSE[IQ(NP)=-1;IQ(NP+1)=1;BR=1.-BR;]
"THE ABOVE PUTS E+ ON TOP OF STACK IF IT HAS LESS ENERGY"
"   DIVIDE UP THE ENERGY"
BR=max(BR,0.0); "AVOIDS POSSIBLE NEGATIVE NUMBER DUE TO ROUND-OFF"
PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY 'ELECTRON' 2"
PESE1=PEIP-PEKSE2; "PRECISE ENERGY OF SECONDARY 'ELECTRON' 1"
PESE2=PEKSE2+PRM;  "PRECISE ENERGY OF SECONDARY 'ELECTRON' 2"
ESE1=PESE1;
ESE2=PESE2;
E(NP)=PESE1;
E(NP+1)=PESE2;
"   BHABHA ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS"
H1=(PEIP+PRM)/PEKIN;
"   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON"

"AFB modified the following statement 92/10/28 to avoid"
"numerical difficulties"
"DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);"
DCOSTH=MIN(1.0D0,H1*(PESE1-PRM)/(PESE1+PRM));

SINTHE=DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);
CALL UPHI(2,1);
NP=NP+1;
DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
SINTHE=-DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);
CALL UPHI(3,2);
RETURN;
"END OF SUBROUTINE BHABHA"  END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE BREMS;
"                                                                  "
"******************************************************************"
"   Samples bremsstrahlung energy using                            "
"    - Coulomb corrected Bethe-Heitler above 50 MeV                "
"    - Bethe-Heitler below 50 MeV                                  "
"   if ibr_nist = 0, or                                            "
"    - the NIST bremsstrahlung cross section data base             "
"      (prepared in a form of an alias table for rapid sampling)   "
"   if ibr_nist = 1  or                                            "
"    - the NRC bremsstrahlung cross section data base, which is    "
"      the same as the NIST database, but with corrections to      "
"      the electron-electron contribution, which are mostly        "
"      important for low Z and low k                               "
"   if ibr_nist = 2                                                "
"   and direction using                                            "
"    - formula 2BS from from Koch and Motz if IBRDST=1             "
"    - leading term of the brems angular dsstr. if IBRDST=0        "
"    - photon direction = electron direction if IBRDST<0           "
"                                                                  "
"   This version replaces the original EGS4 implementation         "
"   because of a bug discovered in the EGS4 brems routine          "
"   In order to work properly, the parameter DL1,..,DL6            "
"   are re-calculated in subroutine fix_brems which is called      "
"   from HATCH                                                     "
"   In addition, this version has the internal capability of       "
"   bremsstrahlung splitting.                                      "
"   To use bremsstrahlung splitting, set nbr_split (COMON/BREMPR/) "
"   to the desired number > 1 (1 is the default)                   "
"   Be aware that event-by-event energy conservation is NOT        "
"   guaranteed, so don't use for calculations where this is        "
"   important (e.g. calculation of detector response functions)    "
"   The result will be nbr_split photons, all with the weight      "
"   wt(npold)/nbr_split, and an electron with the original weight  "
"   and energy given by the incident energy - energy of last photon"
"                                                                  "
" I. Kawrakow, January 2000                                        "
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-BREMS;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,   "
                           "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-BREMS;
$REAL z2max,z2maxi,aux1,aux3,aux4,aux5,aux2,weight;

IF( nbr_split < 1 ) return;  "i.e. the user can turn off brems production"
                             "by setting nbr_split to zero!"

NPold = NP;      "Set the old stack counter"
PEIE=E(NP);      "PRECISE ENERGY OF INCIDENT 'ELECTRON'"
EIE=PEIE;        "ENERGY OF INCIDENT 'ELECTRON'"
weight = wt(np)/nbr_split;

"   DECIDE WHICH DISTRIBUTION TO USE (B-H COULOMB CORRECTED IS     "
"   USED FROM 50 TO 20000 MEV, B-H IS USED 1.5 TO 50 MEV)          "
IF (EIE.LT.50.0)[ L=1; ] ELSE [ L=3; ]
L1 = L+1;

ekin = peie-prm;
brmin = ap(medium)/ekin;
"waux = -log(brmin);"
waux = elke - log_ap(medium); "this saves the time consuming log evaluation"
                              "log_ap = log(ap(medium)) is calculated in   "
                              "fix_brems for each medium, elke is needed   "
                              "in electr to calculate the branching ratios "
                              "and therefore it must be known at this point"

IF( ibrdst >= 0 ) [ "inrdst >=0 means we will sample the photon emmision"
                    "angle from KM-2BS (ibrdst=1) or from the leading"
                    "term (ibrdst=0). If nbr_split > 1, we can re-use"
                    "the following quantities several time"

    a = u(np); b = v(np); c = w(np);
    sinpsi = a*a + b*b;
    IF( sinpsi > 1e-20 ) [
       sinpsi = sqrt(sinpsi);
       sindel = b/sinpsi; cosdel = a/sinpsi;
    ]

    ztarg = zbrang(medium);
    tteie = eie/rm;
    beta = sqrt((tteie-1)*(tteie+1))/tteie;
    y2max = 2*beta*(1+beta)*tteie*tteie;
    y2maxi = 1/y2max;
    IF( ibrdst = 1 ) [ z2max = y2max+1; z2maxi = sqrt(z2max); ]

]

IF( ibr_nist >= 1 ) [
    ajj = 1 + (waux + log_ap(medium) - nb_lemin(medium))*nb_dlei(medium);
    jj = ajj; ajj = ajj - jj;
    IF( jj >  $MXBRES ) [ jj = $MXBRES; ajj = -1; ]
]

DO ibr = 1,nbr_split [

    IF( ibr_nist >= 1 ) [ "use the NIST or NRC bremsstrahlung cross section"
                         "data base"
        IF( ekin > nb_emin(medium) ) [
            $RANDOMSET r1;
            IF( r1 < ajj ) [ j = jj+1; ] ELSE [ j = jj; ]
            br = alias_sample1($MXBRXS,nb_xdata(0,j,medium),
                               nb_fdata(0,j,medium),
                               nb_wdata(1,j,medium),nb_idata(1,j,medium));
        ]
        ELSE [ $RANDOMSET br; ]
        esg = ap(medium)*exp(br*waux); pesg = esg;
        pese = peie - pesg; ese = pese;
    ]
    ELSE [

        LOOP [ "User wants to use Bethe-Heitler"

            $RANDOMSET rnno06; $RANDOMSET rnno07;
            br = brmin*exp(rnno06*waux);
            esg = ekin*br; pesg = esg;
            pese = peie - pesg; ese = pese;
            delta = esg/eie/ese*delcm(medium); aux = ese/eie;
            IF( delta < 1 ) [
                phi1 = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
                phi2 = dl1(l1,medium)+delta*(dl2(l1,medium)+
                        delta*dl3(l1,medium));
            ]
            ELSE [
                phi1 = dl4(l,medium)+dl5(l,medium)*log(delta+dl6(l,medium));
                phi2 = phi1;
            ]
            rejf = (1+aux*aux)*phi1 - 2*aux*phi2/3;

        ] UNTIL (rnno07 < rejf);
    ]

    "   SET UP THE NEW PHOTON                                          "
    np=np+1;
    IF( np > $MXSTACK ) [
        $egs_fatal('(//a,i6,a//)',' Stack overflow in BREMS! np = ',np+1,
                   ' Increase $MXSTACK and try again' );
    ]
    e(np) = pesg; iq(np) = 0;
    $TRANSFER PROPERTIES TO (np) FROM (np-1);
    wt(np) = weight;
    IF( ibrdst < 0 ) [  "The photon will inherit the direction from "
                        "the electron. This option is given so that "
                        "the user can implement their own brems angle "
                        "schemes via a call to ausgab"
        u(np) = u(npold); v(np) = v(npold); w(np) = w(npold);
    ]
    ELSE [
       IF( ibrdst = 1 ) [
           /*
              This is the original implementation
              suggested by Alex Bielajew. Commented out as
              the implementation below is way more efficient.
              IK, Sep. 2004.
           ttese = ese/rm; esedei = ttese/tteie;
           rjarg1 = 1+esedei*esedei;
           rjarg2 = 3*rjarg1 - 2*esedei;
           rjarg3 = ((1-esedei)/(2*tteie*esedei))**2;
           $SET-BREM-REJECTION-FUNCTION(REJMIN,0.0);
           $SET-BREM-REJECTION-FUNCTION(REJMID,1.0);
           $SET-BREM-REJECTION-FUNCTION(REJMAX,y2max);
           rejtop = max(rejmin,rejmid,rejmax);
           LOOP [
              $RANDOMSET y2tst; y2tst = y2tst/(1-y2tst+y2maxi);
              $SET-BREM-REJECTION-FUNCTION(REJTST,Y2TST);
              $RANDOMSET rtest;
           ] UNTIL (rtest*rejtop <= REJTST);
           */
           ttese = ese/rm; esedei = ttese/tteie;
           rjarg1 = 1+esedei*esedei;
           rjarg2 = rjarg1 + 2*esedei;
           aux = 2*ese*tteie/esg; aux = aux*aux; aux1 = aux*ztarg;
           IF( aux1 > 10 ) [ rjarg3 = lzbrang(medium) + (1-aux1)/aux1**2; ]
           ELSE [ rjarg3 = log(aux/(1+aux1)); ]
           rejmax = rjarg1*rjarg3-rjarg2;
           LOOP [
               $RANDOMSET y2tst; $RANDOMSET rtest;
               aux3 = z2maxi/(y2tst+(1-y2tst)*z2maxi);
               rtest = rtest*aux3*rejmax;
               y2tst = aux3**2-1; y2tst1 = esedei*y2tst/aux3**4;
               aux4 = 16*y2tst1-rjarg2; aux5 = rjarg1-4*y2tst1;
               IF( rtest < aux4 + aux5*rjarg3 ) EXIT;
               aux2 = log(aux/(1+aux1/aux3**4));
               rejtst = aux4+aux5*aux2;
           ] UNTIL (rtest < rejtst );

       ]
       ELSE [
           $RANDOMSET y2tst; y2tst = y2tst/(1-y2tst+y2maxi);
       ]
       costhe = 1 - 2*y2tst*y2maxi;
       sinthe = sqrt(max((1-costhe)*(1+costhe),0.0));
       $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
       IF( sinpsi >= 1e-10 ) [
           us = sinthe*cphi; vs = sinthe*sphi;
           u(np) = c*cosdel*us - sindel*vs + a*costhe;
           v(np) = c*sindel*us + cosdel*vs + b*costhe;
           w(np) = c*costhe - sinpsi*us;
       ]
       ELSE [
           u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = c*costhe;
       ]
    ]
]

e(npold) = pese;

RETURN;
"END OF SUBROUTINE BREMS"   END;

"******************************************************************"
"                                                          NRCC    "
SUBROUTINE COMPT;
"                                VERSION 1.00  --  12 JAN 1999     "
"******************************************************************"
"                                                                  "
"   Subroutine for sampling incoherent (Compton) scattering        "
"   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
"   Otherwise scattering is modelled in the impulse approximation  "
"   (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325)  "
"   As the total cross section from PEGS4 is not modified (and thus"
"   calculated using Klein-Nishina), all rejections lead to an     "
"   unscattered photon and a zero energy electron.                 "
"   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
"   atomic relaxation is treated in RELAX. This has as a           "
"   consequence that more than one particle can be created as a    "
"   result of an incoherent scattering. The user should therefore  "
"   check their user codes for possible inconsistencies.           "
"                                                                  "
"   I.Kawrakow, January 1999                                       "
"                                                                  "
"   I.Kawrakow, March 2008:                                        "
"      If ibcmp = 2 or 3, the actual bound Compton scattering      "
"      cross section is used and rejections lead to resampling     "
"      instead of rejecting the entire interactions as stated above"
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/COMPTON-DATA,DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM/;

$DEFINE-LOCAL-VARIABLES-COMPT;
$LOGICAL first_time;
$INTEGER ibcmpl;

NPold = NP;       "Set the old stack counter"
peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
ko = peig/rm;     "Gamma energy in units of electron rest energy"
broi = 1 + 2*ko;  "Needed for scattering angle sampling"

$RADC_CHECK;

irl = ir(np); first_time = .true.; ibcmpl = ibcmp(irl);

:resample-compton:;
IF( ibcmpl > 0 ) [ "User wants to take into account binding effects"
                   "=>first sample the shell and see whether an    "
                   "  interaction is possible                      "
    $RANDOMSET rnno17; rnno17 = 1 + rnno17*n_shell(medium);
    i = int(rnno17); "rnno17 = rnno17 - i;
    IF( rnno17 > eno_array(i,medium) ) i = eno_atbin_array(i,medium);
    j = shell_array(i,medium); "j is the shell number in the data list"
    Uj = be_array(j);          "Uj is the binding energy in units of rm"

    " Binding energy rejection "
    IF( ko <= Uj ) [
        IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
        ELSE             [ goto :resample-compton:;     ]
    ]
    Jo = Jo_array(j);          "Jo is the Compton profile parameter"

]

" We always sample the scattering angle from Klein-Nishina"
:RESAMPLE:
;
IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
    IF( first_time ) [
        broi2 = broi*broi;
        alph1 = Log(broi);
        bro   = 1/broi;
        alph2 = ko*(broi+1)*bro*bro;
        alpha = alph1+alph2;
    ]
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        IF( rnno15*alpha < alph1 ) [ "Use 1/br part"
            br = Exp(alph1*rnno16)*bro;
        ]
        ELSE [  "Use the br part."
            br = Sqrt(rnno16*broi2 + (1-rnno16))*bro;
        ]
        temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
        aux = 1+br*br;
        rejf3 = aux - br*sinthe;
        $RANDOMSET rnno19;
    ] UNTIL rnno19*aux.le.rejf3;
]
ELSE [ "At low energies it is faster to sample br uniformely"
    IF( first_time ) [
        bro = 1./broi; bro1 = 1 - bro;
        rejmax = broi + bro;
    ]
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        br = bro + bro1*rnno15;
        temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
        rejf3 = 1 + br*br - br*sinthe;
    ] UNTIL rnno16*br*rejmax.le.rejf3;
]
first_time = .false.;

IF(br < bro | br > 1)  [
    IF( br < 0.99999/broi | br > 1.00001 ) [
        $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
    ]
    goto :RESAMPLE: ;
]

$RADC_REJECTION;

costhe = 1 - temp;
IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
    Uj = 0;
    goto :FINISHED-COMPTON-SAMPLING:;
]

" Check for rejection due to the limited range of pzmax "
br2 = br*br;
aux = ko*(ko-Uj)*temp;
aux1 = 2*aux + Uj*Uj;
pzmax = aux - Uj;
IF( pzmax < 0 & pzmax*pzmax >= aux1 ) [
    IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
    ELSE             [ goto :resample-compton:; ]
]
pzmax = pzmax/sqrt(aux1);
/*
pzmax = (aux - Uj)/sqrt(2*aux + Uj*Uj);
IF( pzmax <= -1 ) [
    IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
    ELSE             [ goto :resample-compton:; ]
]
*/
qc2 = 1 + br*br - 2*br*costhe;
qc  = sqrt(qc2);

IF( pzmax > 1 ) [
    pzmax = 1; af = 0; Fmax = 1; fpz = 1;
    goto :RETRY-PZ:;
]

aux3 = 1 + 2*Jo*abs(pzmax);
aux4 = 0.5*(1-aux3*aux3);
fpz  = 0.5*exp(aux4);
af   = qc*(1+br*(br-costhe)/qc2);

IF( af < 0 ) [
    IF( pzmax > 0 ) fpz = 1 - fpz;
    $RANDOMSET eta_incoh;
    IF( eta_incoh > fpz ) [
        IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
        ELSE             [ goto :resample-compton:; ]
    ]
    af = 0; Fmax = 1; goto :RETRY-PZ:;
]

IF( pzmax < -0.15 ) [
    Fmax = 1-af*0.15;
    fpz1 = fpz*Fmax*Jo;
]
ELSE IF( pzmax < 0.15 ) [
    Fmax = 1 + af*pzmax;
    aux3 = 1/(1+0.33267252734*aux3);
            "0.33267252734 is p/sqrt(2), p is the parameter from Eq. 7.1.25"
            "of Abramowitz and Stegun, needed for approximating Erf        "
    aux4 = fpz*aux3*(0.3480242+aux3*(-0.0958798+aux3*0.7478556)) +
           erfJo_array(j);
    IF( pzmax > 0 ) [
        "fpz1 = 1 - Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
          "missing factor 1/2 in the above found by Cerneliu Costescu"
          "0.62665706866 is sqrt(Pi/8)"
        fpz1 = (1 - Fmax*fpz)*Jo - 0.62665706866*af*aux4;
        fpz = 1 - fpz;
    ]
    ELSE [
        "fpz1 = Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
          "missing factor 1/2 in the above found by Cerneliu Costescu"
          "0.62665706866 is sqrt(Pi/8)"
        fpz1 = Fmax*fpz*Jo - 0.62665706866*af*aux4;
    ]
]
ELSE [
    Fmax = 1 + af*0.15;
    fpz1 = (1 - Fmax*fpz)*Jo;
    fpz = 1 - fpz;
]
$RANDOMSET eta_incoh;
IF(eta_incoh*Jo > fpz1 ) [
    IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
    ELSE             [ goto :resample-compton:; ]
]

"At this point, all rejections are handled, now we need to sample pz "
"between -1 and pzmax using the Compton profile of the selected shell"
"and F(pz,cos(theta)) as a rejection function                        "

:RETRY-PZ:;
IF( ibcmpl ~= 2 ) [
  $RANDOMSET rnno18; rnno18 = rnno18*fpz;
  IF( rnno18 < 0.5 ) [
    rnno18 = Max(1e-30,2*rnno18);
    pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo;
  ]
  ELSE [
    rnno18 = 2*(1-rnno18);
    pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo;
  ]
  IF( abs(pz) > 1 ) goto :RETRY-PZ:;
      "Due to the non-relativistic approximation"
      "for pz, it has to be between -1 and 1    "
  IF( pz < 0.15  ) [
    IF( pz < -0.15 ) [ frej = 1 - af*0.15; ]
    ELSE             [ frej = 1 + af*pz;   ]
    $RANDOMSET eta;
    IF( eta*Fmax > frej ) goto :RETRY-PZ:;
  ]
  "If pz > 0.15, F is always 1 => no need for rejection"
]
ELSE [ pz = 0; Uj = 0; "i.e., no Doppler broadenning and no binding energy" ]

" Calculate energy of scattered photon "
pz2 = pz*pz;
IF( abs(pz) < 0.01 ) [
    br = br*(1 + pz*(qc + (br2-costhe)*pz));
]
ELSE [
    aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
    aux2 = qc2 - br2*pz2*sinthe;
    IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
]
Uj = Uj*prm;

:FINISHED-COMPTON-SAMPLING:
pesg = br*peig; pese = peig - pesg - Uj + prm;
sinthe = Sqrt(sinthe);
call uphi(2,1); e(np) = pesg;
aux = 1 + br*br - 2*br*costhe;
IF( aux > 1e-8 ) [
    costhe = (1-br*costhe)/Sqrt(aux);
    sinthe = (1-costhe)*(1+costhe);
    IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
    ELSE [ sinthe = 0; ]
] ELSE [ costhe = 0; sinthe = -1; ]
np = np + 1;
$CHECK-STACK(np,'COMPT');
call uphi(3,2);
e(np) = pese; iq(np) = -1;

IF( ibcmpl = 1 | ibcmpl = 3 ) [

    " Shell vacancy "
    IF( Uj > 1e-3 ) [
        edep = pzero;

        call relax(Uj,shn_array(j),iz_array(j));
        "relax will put all particles with energies above ecut,pcut on the "
        "stack, the remaining energy will be scored in edep and deposited  "
        "locally (via the call to ausgab below)                            "
    ]
    ELSE [
        edep = Uj;
        edep_local = edep;
        $AUSCALL($SPHOTONA);
    ]
    IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]

]

" Now play Russian Roulette with resulting electrons if the user asked for it"
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"

return;

:INTERACTION-REJECTED:
" Create here a zero energy electron if required (check user codes) "
return;
end;

"******************************************************************"
"                                                          NRCC    "
SUBROUTINE old_COMPT;
"                                VERSION 1.00  --  12 JAN 1999     "
"******************************************************************"
"                                                                  "
"   Subroutine for sampling incoherent (Compton) scattering        "
"   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
"   Otherwise scattering is modelled in the impuls approximation   "
"    (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325) "
"   As the total cross section from PEGS4 is not modified (and thus"
"   calculated using Klein-Nishina), all rejections leed to an     "
"   unscattered photon and a zero energy electron.                 "
"   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
"   atomic relaxation is treated in RELAX. This has as a           "
"   consequence that more than one particle can be created as a    "
"   result of an incoherent scattering. The user should therefore  "
"   check their user codes for possible inconsistencies.           "
"   This version ignores the function F(cos(theta),pz).            "
"   This leads to a small error (at least compared to the cross    "
"   section we want to sample) at low energies (say, below Z keV)  "
"   The advantage is that it is substantially faster then the      "
"   version with F taken into account.                             "
"                                                                  "
"                                                                  "
"   I.Kawrakow, January 1999                                       "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/COMPTON-DATA,EGS-VARIANCE-REDUCTION,DEBUG, "
                               "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-COMPT-old;

i_survived_RR = 0;"0=> all survived russian roulette if played"
                  "must set here since, if bound compton and event is"
                  "rejected, this wouldn't be set to the new 0 value"
NPold = NP;       "Set the old stack counter"
peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
ko = peig/rm;     "Gamma energy in units of electron rest energy"
broi = 1 + 2*ko;  "Needed for scattering angle sampling"

irl = ir(np);
IF( ibcmp(irl) = 1 ) [ "User wants to take into account binding effects"
                       "=>first sample the shell and see whether an    "
                       "  interaction is possible                      "
    $RANDOMSET rnno17;
    DO i=1,n_shell(medium) [
        rnno17 = rnno17 - eno_array(i,medium);
        IF( rnno17 <= 0 ) EXIT;
    ]
    j = shell_array(i,medium); "j is the shell number in the data list"
    Uj = be_array(j);          "Uj is the binding energy in units of rm"

    " Binding energy rejection "
    IF( ko <= Uj ) [ goto :INTERACTION-REJECTED-old:; ]

]

" We always sample the scattering angle from Klein-Nishina"
:RESAMPLE-old:
;
IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
    broi2 = broi*broi;
    alph1 = Log(broi);
    alph2 = ko*(broi+1)/broi2;
    alpha = alph1/(alph1+alph2);
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        IF( rnno15 < alpha ) [ "Use 1/br part"
            br = Exp(alph1*rnno16)/broi;
        ]
        ELSE [  "Use the br part."
            br = Sqrt(rnno16 + (1-rnno16)/broi2);
        ]
        temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
        rejf3 = 1 - br*sinthe/(1+br*br);
        $RANDOMSET rnno19;
    ] UNTIL rnno19.le.rejf3;
]
ELSE [ "At low energies it is faster to sample br uniformely"
    bro = 1./broi; bro1 = 1 - bro;
    rejmax = broi + bro;
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        br = bro + bro1*rnno15;
        temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
        rejf3 = (br + 1./br - sinthe)/rejmax;
    ] UNTIL rnno16.le.rejf3;
]

IF(br < 1./broi | br > 1)  [
    IF( br < 0.99999/broi | br > 1.00001 ) [
    $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
    ]
    goto :RESAMPLE-old: ;
]

IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
    Uj = 0; costhe = 1 - temp;
    goto :FINISHED-COMPTON-SAMPLING-old:;
]

" Sample Doppler broadening using the Compton profile of the selected shell"
br2 = br*br;
costhe = 1 - temp;
aux = ko*(ko-Uj)*temp; aux1 = aux-Uj;
pzmax2 = aux1*aux1/(2*aux+Uj*Uj);
:RETRY-PZ-old:;
$RANDOMSET rnno18;
IF( rnno18 < 0.5 ) [
    rnno18 = Max(1e-30,2*rnno18);
    pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo_array(j);
    pz2 = pz*pz;
    IF( (pz2 <= pzmax2) & (aux1 < 0) ) [goto :INTERACTION-REJECTED-old:; ]
]
ELSE [
    IF( aux1 < 0 ) [goto :INTERACTION-REJECTED-old:; ]
    rnno18 = 2*(1-rnno18);
    pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo_array(j);
    pz2 = pz*pz;
    IF( pz2 >= pzmax2 ) [goto :INTERACTION-REJECTED-old:; ]
]
IF( abs(pz) > 1 ) goto :RETRY-PZ-old:;

" Calculate energy of scattered photon "
aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
aux2 = 1-2*br*costhe+br2*(1-pz2*sinthe);
IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
Uj = Uj*prm;

:FINISHED-COMPTON-SAMPLING-old:
pesg = br*peig; pese = peig - pesg - Uj + prm;
sinthe = Sqrt(sinthe);
call uphi(2,1); e(np) = pesg;
aux = 1 + br*br - 2*br*costhe;
IF( aux > 1e-8 ) [
    costhe = (1-br*costhe)/Sqrt(aux);
    sinthe = (1-costhe)*(1+costhe);
    IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
    ELSE [ sinthe = 0; ]
] ELSE [ costhe = 0; sinthe = -1; ]
np = np + 1;
$CHECK-STACK(np,'COMPT');
call uphi(3,2);
e(np) = pese; iq(np) = -1;

IF( ibcmp(irl) = 1 ) [

    " Shell vacancy "
    IF( Uj > 1e-3 ) [
        edep = 0;

        call relax(Uj,shn_array(j),iz_array(j));
          "relax will put all particles with energies above ecut,pcut on the "
          "stack, the remaining energy will be scored in edep and deposited  "
          "localy (via the call to ausgab below)                             "
    ]
    ELSE [ edep = Uj; ]
    IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]

]

" Now play Russian Roulette with resulting electrons if the user asked for it"
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"

return;

:INTERACTION-REJECTED-old:
" Create here a zero energy electron if required (check user codes) "
return;
end;

%E
"******************************************************************"
"                               NATIONAL RESEARCH COUNCIL OF CANADA"
SUBROUTINE ELECTR(IRCODE);
"******************************************************************"
"   This subroutine has been almost completely recoded to include  "
"   the EGSnrc enhancements.                                       "
"                                                                  "
"   Version 1.0   Iwan Kawrakow       Complete recoding            "
"   Version 1.1   Iwan Kawrakow       Corrected implementation of  "
"                                     fictitious method (important "
"                                     for low energy transport     "
"******************************************************************"

$IMPLICIT-NONE;

$INTEGER IRCODE;

$COMIN-ELECTR; "default replacement produces the following:
               "COMIN/DEBUG,BOUNDS,EGS-VARIANCE-REDUCTION, ELECIN,EPCONT,"
                        "ET-Control,MEDIA,MISC,STACK,THRESH,UPHIIN,"
                        "UPHIOT,USEFUL,USER,RANDOM/;"
;COMIN/EII-DATA/;
;COMIN/EM/;
$REAL lambda_max, sigratio, u_tmp, v_tmp, w_tmp;
LOGICAL random_tustep;

$DEFINE-LOCAL-VARIABLES-ELECTR;
/******* trying to save evaluation of range.
$LOGICAL  do_range;
$REAL     the_range;
*/

data ierust/0/;         "To count negative ustep's"

save ierust;

$CALL-USER-ELECTRON;

ircode = 1; "Set up normal return-which means there is a photon
            "with less available energy than the lowest energy electron,
            "so return to shower so it can call photon to follow it.
            "(For efficiency's sake, we like to stay in this routine
            " as long as there are electrons to process. That's why this
            " apparently convoluted scheme of STACK contro is effected.)

irold = ir(np);    "Initialize previous region
                   "(ir() is an integer that is attached to the particle's
                   " phase space. It contains the region
                   " number that the current particle is in.
                   " Np is the stack pointer, it points to where on the
                   " stack the current particle is.)
irl    = irold;    "region number in local variable


$start_new_particle;
" Default replacement for the above is medium = med(irl); "
" This is made a macro so that it can be replaced with a call to a "
" user provided function start_new_particle(); for the C/C++ interface "

:NEWELECTRON:LOOP
[
    "Go once through this loop for each 'new' electron whose charge and
    "energy has not been checked

    lelec = iq(np); "Save charge in local variable
                    "(iq = -1 for electrons, 0 for photons and 1 for positrons)
    qel   = (1+lelec)/2; " = 0 for electrons, = 1 for positrons "
    peie  = e(np);  "precise energy of incident electron (double precision)
    eie   = peie;   "energy incident electron (conversion to single)

    IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
        "(Ecut is the lower transport threshold.)

    "medium = med(irl);" "(This renders the above assignment redundant!)
    "The above assignment is unnecessary, IK, June 2003"

    IF(WT(NP) = 0.0) [go to :USER-ELECTRON-DISCARD:;] "added May 01"

    :TSTEP:LOOP
    [
        "Go through this loop each time we recompute distance to an interaction
        /******* trying to save evaluation of range.
        do_range = .true.; "compute the range in $COMPUTE-RANGE below"
        ********/
        compute_tstep = .true.; "MFP resampled => calculate distance to the
                                "interaction in the USTEP loop
        eke = eie - rm; "moved here so that kinetic energy will be known"
                        "to user even for a vacuum step, IK January 2000"
        IF(medium ~= 0)
        [
            "Not vacuum. Must sample to see how far to next interaction.

            $SELECT-ELECTRON-MFP;
                " Default FOR $SELECT-ELECTRON-MFP; is: $RANDOMSET rnne1;
                "                                       demfp = -log(rnne1);
                "($RANDOMSET is a macro'ed random number generator)
                "(demfp = differential electron mean free path)

            elke = log(eke);
            "(eke = kinetic energy, rm = rest mass, all in units of MeV)
            $SET INTERVAL elke,eke; "Prepare to approximate cross section

            $EVALUATE-SIG0;
               "The fix up of the fictitious method uses cross section per"
               "energy loss. Therefore, demfp/sig is sub-threshold energy loss"
               "until the next discrete interaction occures (see below)"
               "As this quantity is a single constant for a material,"
               "$SET INTERVAL is not necessary at this point. However, to not"
               "completely alter the logic of the TSTEP and USTEP loops,"
               "this is left for now"

        ] "end non-vacuum test

        :USTEP:LOOP
        [
            "Here for each check with user geometry.
            "Compute size of maximum acceptable step, which is limited
            "by multiple scattering or other approximations.
            IF(medium = 0)
            [
                    "vacuum
                    $EMFIELD_INITIATE_SET_TUSTEP;
                    tstep = vacdst; ustep = tstep; tustep = ustep;
                    callhowfar = .true.; "Always call HOWFAR for vacuum steps!"

                    "(Important definitions:
                    " tstep  = total pathlength to the next discrete interaction
                    " vacdst = infinity (actually 10^8)
                    " tustep = total pathlength of the electron step
                    " ustep  = projected transport distance in the
                    "          direction of motion at the start of the step
                    " Note that tustep and ustep are modified below.
                    " The above provide defaults.)

                    " EM field step size restriction in vacuum
                    $SET-TUSTEP-EM-FIELD;
                    ustep = tustep;
            ]
            ELSE
            [
                "non-vacuum
                $SET-RHOF;    "density ratio scaling template
                              "EGS allows the density to vary
                              "continuously (user option)

                $SCALE-SIG0;
                IF(sig <= 0)
                [
                    "This can happen if the threshold for brems,
                    "(ap + rm), is greater than ae.  Moller threshold is
                    "2*ae - rm. If sig is zero, we are below the
                    "thresholds for both bremsstrahlung and Moller.
                    "In this case we will just lose energy by
                    "ionization loss until we go below cut-off. Do not
                    "assume range is available, so just ask for step
                    "same as vacuum.  Electron transport will reduce
                    "into little steps.
                    "(Note: ae is the lower threshold for creation of a
                    "       secondary Moller electron, ap is the lower
                    "       threshold for creation of a brem.)
                    tstep = vacdst;
                    sig0 = 1.E-15;
                ]
                ELSE
                [
                    $CALCULATE-TSTEP-FROM-DEMFP;
                ] "end sig if-else

                "calculate stopping power"
                IF(lelec < 0) [$EVALUATE dedx0 USING ededx(elke);] "e-"
                ELSE          [$EVALUATE dedx0 USING pdedx(elke);] "e+"
                dedx  = rhof*dedx0;

                "Determine maximum step-size (Formerly $SET-TUSTEP)
                $EVALUATE tmxs USING tmxs(elke);
                tmxs = tmxs/rhof;

                "Compute the range to E_min(medium) (e_min is the first
                "energy in the table). Do not go more than range.
                "Don't replace this macro and don't override range, because
                "the energy loss evaluation below relies on the accurate
                "(and self-consistent) evaluation of range!
                $COMPUTE-RANGE;

                "The RANDOMIZE-TUSTEP option as coded by AFB forced the
                "electrons to approach discrete events (Moller,brems etc.)
                "only in a single scattering mode => waste of CPU time.
                "Moved here and changed by IK Oct 22 1997
                random_tustep = $RANDOMIZE-TUSTEP;
                IF(random_tustep)
                [
                    $RANDOMSET rnnotu;
                    tmxs = rnnotu*min(tmxs,smaxir(irl));
                ]
                ELSE
                [
                    tmxs = min(tmxs,smaxir(irl));
                ]
                tustep = min(tstep,tmxs,range);
                $SET-TUSTEP-EM-FIELD; "optional tustep restriction in EM field

                $CALL-HOWNEAR(tperp);
                dnear(np) = tperp;
                $RANGE-DISCARD;       "optional regional range rejection for"
                                      "particles below e_max_rr if i_do_rr set"

                $USER-RANGE-DISCARD;  "default is ;, but user may implement"

                $SET-SKINDEPTH(eke,elke);
                  "This macro sets the minimum step size for a condensed"
                  "history (CH) step. When the exact BCA is used, the minimum"
                  "CH step is determined by efficiency considerations only"
                  "At about 3 elastic MFP's single scattering becomes more"
                  "efficient than CH and so the algorithm switches off CH"
                  "If one of the various inexact BCA's is invoked, this macro"
                  "provides a simple way to include more sophisticated"
                  "decisions about the maximum acceptable approximated CH step"

                tustep = min(tustep,max(tperp,skindepth));
                $EMFIELD_INITIATE_SET_TUSTEP;
                "The transport logic below is determined by the logical
                "variables callhhowfar, domultiple and dosingle
                "
                "There are the following possibilities:
                "
                "   callhowfar = .false.  This indicates that the
                "   ====================  intended step is shorter than tperp
                "                         independent of BCA used
                "  - domultiple = .false. dosingle = .false. and
                "                         callmsdist = .true.
                "       ==> everything has been done in msdist
                "  - domultiple = .true. and dosingle = .false.
                "       ==> should happen only if exact_bca = .false.
                "           indicates that MS remains to be done
                "  - domultiple = .false. and dosingle = .true.
                "       ==> should happen only if exact_bca = .true.
                "           sampled distance to a single scattering event is
                "           shorter than tperp ==> do single scattering at the
                "           end of the step
                "  - domultiple = .true. and dosingle = .true.
                "       ==> error condition, something with the logic is wrong!
                "
                "   callhowfar = .true. This indicates that the intended step
                "   =================== is longer than tperp and forces a
                "                       call to hawfar which returns the
                "                       straight line distance to the boundary
                "                       in the initial direction of motion
                "                       (via a modification of ustep)
                "  - domultiple = .false. and dosingle = .false.
                "       ==> should happen only of exact_bca=.true.
                "           simply put the particle on the boundary
                "  - domultiple = .false. and dosingle = .true.
                "       ==> should happen only of exact_bca=.true.
                "           single elastic scattering has to be done
                "  - domultiple = .true. and dosingle = .false.
                "       ==> should happen only of exact_bca=.false.
                "           indicates that MS remains to be done
                "  - domultiple = .true. and dosingle = .true.
                "       ==> error condition, something with the logic is wrong!

                "IF(tustep <= tperp & tustep > skindepth)"
                "This statement changed to be consistent with PRESTA-I"
                count_all_steps = count_all_steps + 1;
                is_ch_step = .false.;
                IF((tustep <= tperp) & ((~exact_bca) | (tustep > skindepth)))
                [
                    "We are further way from a boundary than a skindepth, so
                    "perform a normal condensed-history step
                    callhowfar = .false.; "Do not call HAWFAR
                    domultiple = .false.; "Multiple scattering done here
                    dosingle   = .false.; "MS => no single scattering
                    callmsdist = .true.;  "Remember that msdist has been called

                    "Fourth order technique for de
                    $COMPUTE-ELOSS-G(tustep,eke,elke,lelke,de);

                    tvstep = tustep; is_ch_step = .true.;

                    IF (transport_algorithm = $PRESTA-II)
                    [
                      call msdist_pII
                      (
                        "Inputs
                        eke,de,tustep,rhof,medium,qel,spin_effects,
                        u(np),v(np),w(np),x(np),y(np),z(np),
                        "Outputs
                        uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
                      );
                    ]
                    ELSE
                    [
                      call msdist_pI
                      (
                        "Inputs
                        eke,de,tustep,rhof,medium,qel,spin_effects,
                        u(np),v(np),w(np),x(np),y(np),z(np),
                        "Outputs
                        uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
                      );
                    ]
                ]
                ELSE
                [
                    "We are within a skindepth from a boundary, invoke
                    "one of the various boundary-crossing algorithms
                    callmsdist = .false.;
                         "Remember that msdist has not been called
                    IF (exact_bca)
                    [
                        "Cross the boundary in a single scattering mode
                        domultiple = .false.; "Do not do multiple scattering
                        "Sample the distance to a single scattering event
                        $RANDOMSET rnnoss;
                        IF( rnnoss < 1.e-30 ) [
                            rnnoss = 1.e-30;
                        ]
                        lambda = - Log(1 - rnnoss);
                        lambda_max = 0.5*blccl*rm/dedx*(eke/rm+1)**3;
                        IF( lambda >= 0 & lambda_max > 0 ) [
                            IF( lambda < lambda_max ) [
                                tuss=lambda*ssmfp*(1-0.5*lambda/lambda_max);
                            ]
                            ELSE [
                              tuss = 0.5 * lambda * ssmfp;
                            ]
                            IF (tuss < tustep) [
                                tustep = tuss;
                                dosingle = .true.;
                            ]
                            ELSE [
                                dosingle = .false.;
                            ]
                        ]
                        ELSE [
                          $egs_warning(*,' lambda > lambda_max: ',
                             lambda,lambda_max,' eke dedx: ',eke,dedx,
                             ' ir medium blcc: ',ir(np),medium,blcc(medium),
                             ' position = ',x(np),y(np),z(np));
                          dosingle = .false.;
                          np=np-1; return;
                        ]
                        ustep = tustep;
                    ]
                    ELSE
                    [
                        "Boundary crossing a la EGS4/PRESTA-I but using
                        "exact PLC
                        dosingle = .false.;
                        domultiple = .true.;
                        $SET-USTEP;
                    ]
                    IF(ustep < tperp)
                    [
                        callhowfar = .false.;
                    ]
                    ELSE
                    [
                        callhowfar = .true.;
                    ]
                ]
            ] "end non-vacuum test

            $SET-USTEP-EM-FIELD;  "additional ustep restriction in em field
                                  "default for $SET-USTEP-EM-FIELD; is ;(null)
            irold  = ir(np); "save current region
            irnew  = ir(np); "default new region is current region
            idisc  = 0; "default is no discard (this flag is initialized here)
            ustep0 = ustep; "Save the intended ustep."

            "IF(callhowfar) [ call howfar; ]"
            $CALL-HOWFAR-IN-ELECTR; "The above is the default replacement"

            "Now see if user requested discard
            IF(idisc > 0) "(idisc is returned by howfar)
            [
                "User requested immediate discard
                go to :USER-ELECTRON-DISCARD:;
            ]

            $CHECK-NEGATIVE-USTEP;

            IF(ustep = 0 | medium = 0)
            [
                "Do fast step in vacuum
                IF(ustep ~= 0)
                [
                    IF $EM_MACROS_ACTIVE
                    [
                        edep = pzero; "no energy loss in vacuum
                        "transport in EMF in vacuum:"
                        "only a B or and E field can be active"
                        "(not both at the same time)"
                        $EMFieldInVacuum;
                    ]
                    ELSE
                    [
                        "Step in vacuum
                        vstep  = ustep;
                        tvstep = vstep;
                        "( vstep is ustep truncated (possibly) by howfar
                        " tvstep is the total curved path associated with vstep)
                        edep = pzero; "no energy loss in vacuum
                        $VACUUM-ADD-WORK-EM-FIELD;
                            "additional vacuum transport in em field
                        e_range = vacdst;
                        $AUSCALL($TRANAUSB);
                        "Transport the particle
                        x(np) = x(np) + u(np)*vstep;
                        y(np) = y(np) + v(np)*vstep;
                        z(np) = z(np) + w(np)*vstep;
                        dnear(np) = dnear(np) - vstep;
                            "(dnear is distance to the nearest boundary
                            " that goes along with particle stack and
                            " which the user's howfar can supply (option)
                        $SET-ANGLES-EM-FIELD;
                            "default for $SET-ANGLES-EM-FIELD; is ; (null)
                             "(allows for EM field deflection
                    ] "end of EM_MACROS_ACTIVE block"
                ] "end of vacuum step

                IF(irnew ~= irold) [ $electron_region_change; ];

                IF(ustep ~= 0) [$AUSCALL($TRANAUSA);]
                IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
                IF(ustep ~= 0 & idisc < 0) [go to :USER-ELECTRON-DISCARD:;]
                NEXT :TSTEP: ; "(Start again at :TSTEP:)

            ] "Go try another big step in (possibly) new medium

            vstep = ustep;
            $EM_FIELD_SS;
            IF(callhowfar)
            [
                IF(exact_bca)
                [
                    "If callhowfar=.true. and exact_bca=.true. we are"
                    "in a single scattering mode"
                    tvstep = vstep;
                    IF(tvstep ~= tustep)
                    [
                       "Boundary was crossed. Shut off single scattering"
                        dosingle = .false.;
                    ]
                ]
                ELSE
                [
                    "callhowfar=.true. and exact_bca=.false."
                    "=>we are doing an approximate CH step"
                    "calculate the average curved path-length corresponding"
                    "to vstep"
                    $SET-TVSTEP;
                ]
                "Fourth order technique for dedx
                "Must be done for an approx. CH step or a
                "single scattering step.
                $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
            ]
            ELSE
            [
               "callhowfar=.false. => step has not been reduced due to
               "                      boundaries
               tvstep = tustep;
               IF ( ~callmsdist )
               [
                  "Second order technique for dedx
                  "Already done in a normal CH step with call to msdist
                  $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
               ]
            ]

            $SET-TVSTEP-EM-FIELD; "additional path length correction in em field
                "( Calculates tvstep given vstep
                " default for $SET-TVSTEP-EM-FIELD; is ; (null)

            save_de = de;     "the energy loss is used to calculate the number
                              "of MFP gone up to now. If energy loss
                              "fluctuations are implemented, de will be
                              "changed in $DE-FLUCTUATION; => save

            "The following macro template allows the user to change the
            "ionization loss.
            "(Provides a user hook for Landau/Vavilov processes)
            $DE-FLUCTUATION;
                "default for $DE-FLUCTUATION; is ; (null)
            edep = de; "energy deposition variable for user
            $ADD-WORK-EM-FIELD;  "e-loss or gain in em field
            $ADD_WORK_EM_FIELD;  "EEMF implementation"
                "Default for $ADD-WORK-EM-FIELD; is ; (null)
            ekef = eke - de;  "(final kinetic energy)
            eold = eie;       "save old value
            enew = eold - de; "energy at end of transport

            "Now do multiple scattering
            IF ( ~callmsdist )   "everything done if callmsdist = .true.
            [
                IF ( domultiple )
                [
                    "Approximated CH step => do multiple scattering
                    "
                    "ekems, elkems, beta2 have been set in either $SET-TUSTEP
                    "or $SET-TVSTEP if spin_effects is .true., they are
                    "not needed if spin_effects is .false.
                    "
                    "chia2,etap,xi,xi_corr are also set in the above macros
                    "
                    "qel (0 for e-, 1 for e+) and medium are now also required
                    "(for the spin rejection loop)
                    "
                    lambda = blccl*tvstep/beta2/etap/(1+chia2);
                    xi = xi/xi_corr;
                    findindex = .true.; spin_index = .true.;
                    call mscat(lambda,chia2,xi,elkems,beta2,qel,medium,
                               spin_effects,findindex,spin_index,
                               costhe,sinthe);
                ]
                ELSE
                [
                    IF(dosingle)
                    [
                       "Single scattering

                       ekems = Max(ekef,ecut(irl)-rm);
                       p2 = ekems*(ekems + rmt2);
                       beta2 = p2/(p2 + rmsq);
                       chia2 = xcc(medium)/(4*blcc(medium)*p2);
                       IF( spin_effects ) [
                         elkems = Log(ekems);
                         $SET INTERVAL elkems,eke;
                         IF(lelec < 0) [$EVALUATE etap USING etae_ms(elkems);]
                         ELSE          [$EVALUATE etap USING etap_ms(elkems);]
                         chia2 = chia2*etap;
                       ]
                       call sscat(chia2,elkems,beta2,qel,medium,
                                  spin_effects,costhe,sinthe);
                    ]
                    ELSE
                    [
                       theta  = 0; "No deflection in single scattering model
                       sinthe = 0;
                       costhe = 1;
                    ]
                ]
            ]

            "We now know distance and amount of energy loss for this step,
            "and the angle by which the electron will be scattered. Hence,
            "it is time to call the user and inform him of this transport,
            "after which we will do it.

            "Now transport, deduct energy loss, and do multiple scatter.
            e_range = range;
            /******* trying to save evaluation of range.
            the_range = the_range - tvstep*rhof;
            ********/

            /*
               Put expected final position and direction in common
               block variables so that they are available to the
               user for things such as scoring on a grid that is
               different from the geometry grid
            */
            IF( callmsdist ) [
               "Deflection and scattering have been calculated/sampled in msdist
                u_final = uscat;
                v_final = vscat;
                w_final = wscat;
                x_final = xtrans;
                y_final = ytrans;
                z_final = ztrans;
            ]
            ELSE
            [
                IF ~($EM_MACROS_ACTIVE)
                [
                    x_final = x(np) + u(np)*vstep;
                    y_final = y(np) + v(np)*vstep;
                    z_final = z(np) + w(np)*vstep;
                ]

                IF ( domultiple | dosingle )
                [
                    u_tmp = u(np); v_tmp = v(np); w_tmp = w(np);
                    call uphi(2,1); "Apply the deflection, save call to uphi if
                                    "no deflection in a single scattering mode
                    u_final = u(np); v_final = v(np); w_final = w(np);
                    u(np) = u_tmp; v(np) = v_tmp; w(np) = w_tmp;
                ]
                ELSE [ u_final = u(np); v_final = v(np); w_final = w(np); ]
            ]

            $AUSCALL($TRANAUSB);

            "Transport the particle

            x(np) = x_final; y(np) = y_final; z(np) = z_final;
            u(np) = u_final; v(np) = v_final; w(np) = w_final;

            dnear(np) = dnear(np) - vstep;
            irold = ir(np); "save previous region
            $SET-ANGLES-EM-FIELD;
            "Default for $SET-ANGLES-EM-FIELD; is ; (null)


            "Now done with multiple scattering,
            "update energy and see if below cut
            "below subtracts only energy deposited"
            peie  = peie - edep;
            "below subtracts energy deposited + work due to E field"
            "peie = peie - de;"
            eie   = peie;
            e(np) = peie;

            "IF( irnew ~= irl & eie <= ecut(irl)) [
            "IK: the above is clearly a bug. If the particle energy falls "
            "    below ecut, but the particle is actually entering a new "
            "    region, the discard will happen in the current region "
            "    instead the next. If the particle is a positron, all "
            "    resulting annihilation photons will have the new position "
            "    but the old region => confusion in the geometry routine "
            "    is very likely.      Jan 27 2004 "
            IF( irnew = irl & eie <= ecut(irl)) [
               go to :ECUT-DISCARD:;
            ]

            medold = medium;
            IF(medium ~= 0)
            [
                ekeold = eke; eke = eie - rm; "update kinetic energy
                elke   = log(eke);
                $SET INTERVAL elke,eke; "Get updated interval
            ]

            IF(irnew ~= irold) [ $electron_region_change; ]

            "After transport call to user scoring routine
            $AUSCALL($TRANAUSA);

            IF(eie <= ecut(irl)) [
               go to :ECUT-DISCARD:;
            ]

            "Now check for deferred discard request.  May have been set
            "by either howfar, or one of the transport ausgab calls
            IF(idisc < 0) [
              go to :USER-ELECTRON-DISCARD:;
            ]

            IF(medium ~= medold) NEXT :TSTEP:;

            $USER_CONTROLS_TSTEP_RECURSION;
                "NRCC update 87/12/08--default is null

            $UPDATE-DEMFP;

        ] UNTIL(demfp < $EPSEMFP); "end ustep loop

        "Compute final sigma to see if resample is needed.
        "this will take the energy variation of the sigma into
        "account using the fictitious sigma method.

        $EVALUATE-SIGF;

        sigratio = sigf/sig0;

        $RANDOMSET rfict;

    ] UNTIL (rfict <= sigratio) ; "end tstep loop

    " Now sample electron interaction

    IF(lelec < 0)
    [
        "e-,check branching ratio
        $EVALUATE-EBREM-FRACTION;
          "Default is $EVALUATE ebr1 USING ebr1(elke);"
        $RANDOMSET rnno24;
        IF(rnno24 <= ebr1)
        [
            "It was bremsstrahlung
            go to :EBREMS:;
        ]
        ELSE
        [
            "It was Moller, but first check the kinematics.
            "However, if EII is on, we should still permit an interaction
            "even if E<moller threshold as EII interactions go down to
            "the ionization threshold which may be less than thmoll.
            IF(e(np) <= thmoll(medium) & eii_flag = 0)
                 "(thmoll = lower Moller threshold)
            [
                "Not enough energy for Moller, so
                "force it to be a bremsstrahlung---provided ok kinematically.
                IF(ebr1 <= 0) [go to :NEWELECTRON:;]
                    "Brems not allowed either.
                go to :EBREMS:;
            ]
            $AUSCALL($MOLLAUSB);
            call moller;
            "The following macro template allows the user to change the
            "particle selection scheme (e.g., adding importance sampling
            "such as splitting, leading particle selection, etc.).
            "(Default macro is template '$PARTICLE-SELECTION-ELECTR'
            "which in turn has the 'null' replacement ';')
            $PARTICLE-SELECTION-MOLLER;
            $AUSCALL($MOLLAUSA);
            IF( iq(np) = 0 ) return;
        ]

        go to :NEWELECTRON:; "Electron is lowest energy-follow it
    ]

    "e+ interaction. pbr1 = brems/(brems + bhabha + annih
    $EVALUATE-PBREM-FRACTION;
       "Default is $EVALUATE pbr1 USING pbr1(elke);"
    $RANDOMSET rnno25;
    IF(rnno25 < pbr1) [go to :EBREMS:;] "It was bremsstrahlung
    "Decide between bhabha and annihilation
    "pbr2 is (brems + bhabha)/(brems + bhabha + annih)
    $EVALUATE-BHABHA-FRACTION;
       "Default is $EVALUATE pbr2 USING pbr2(elke);"
    IF(rnno25 < pbr2)
    [
        "It is bhabha
        $AUSCALL($BHABAUSB);
        call bhabha;
        "The following macro template allows the user to change the
        "particle selection scheme (e.g., adding importance sampling
        "such as splitting, leading particle selection, etc.).  (default
        "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
        "has the 'null' replacement ';')
        $PARTICLE-SELECTION-BHABHA;
        $AUSCALL($BHABAUSA);
        IF( iq(np) = 0 ) return;
    ]
    ELSE
    [
        "It is in-flight annihilation
        $AUSCALL($ANNIHFAUSB);
        call annih;
        "The following macro template allows the user to change the
        "particle selection scheme (e.g., adding importance sampling
        "such as splitting, leading particle selection, etc.).  (default
        "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
        "has the 'null' replacement ';')
        $PARTICLE-SELECTION-ANNIH;
        $AUSCALL($ANNIHFAUSA);
        EXIT :NEWELECTRON:; "i.e., in order to return to shower
        "After annihilation the gammas are bound to be the lowest energy
        "particles, so return and follow them.
    ] "end pbr2 else

] REPEAT "newelectron

return; "i.e., return to shower


"---------------------------------------------
"Bremsstrahlung-call section
"---------------------------------------------
:EBREMS:
$AUSCALL($BREMAUSB);
call brems;
"The following macro template allows the user to change the particle
"selection scheme (e.g., adding importance sampling such as splitting,
"leading particle selection, etc.).  (default macro is template
"'$PARTICLE-SELECTION-ELECTR' which in turn has the 'null' replacement ';')
$PARTICLE-SELECTION-BREMS;
$AUSCALL($BREMAUSA);
IF(iq(np) = 0)
[
    "Photon was selected.
    return;
    "i.e., return to shower
]
ELSE
[
    "Electron was selected
    go to :NEWELECTRON:;
]

"---------------------------------------------
"Electron cutoff energy discard section
"---------------------------------------------
:ECUT-DISCARD:
IF( medium > 0 ) [
    IF(eie > ae(medium)) [
        idr = $EGSCUTAUS;
        IF(lelec < 0) [edep = e(np) - prm;] ELSE[$POSITRON-ECUT-DISCARD;]
    ]
    ELSE [ idr = $PEGSCUTAUS; edep = e(np) - prm; ]
] ELSE [idr = $EGSCUTAUS; edep = e(np) - prm; ]


$ELECTRON-TRACK-END; "The default replacement for this macros is "
                     "          $AUSCALL(idr);                   "
                     "Use this macro if you wish to modify the   "
                     "treatment of track ends                    "

:POSITRON-ANNIHILATION:; "NRCC extension 86/9/12

IF(lelec > 0) [
    "It's a positron. Produce annihilation gammas if edep < peie
    IF(edep < peie) [
        $AUSCALL($ANNIHRAUSB);
        call annih_at_rest;
        $PARTICLE-SELECTION-ANNIHREST;
        $AUSCALL($ANNIHRAUSA);
        "Now discard the positron and take normal return to follow
        "the annihilation gammas.
        return; "i.e., return to shower
    ]
] "end of positron block

np = np - 1;
ircode = 2; "tell shower an e- or un-annihilated
            "e+ has been discarded

return; "i.e., return to shower"

"---------------------------------------------
"User requested electron discard section
"---------------------------------------------
:USER-ELECTRON-DISCARD:

idisc = abs(idisc);

IF((lelec < 0) | (idisc = 99))[edep = e(np) - prm;]
ELSE                          [edep = e(np) + prm;]

$AUSCALL($USERDAUS);

IF(idisc = 99) goto :POSITRON-ANNIHILATION:;

np = np - 1; ircode = 2;

return; "i.e., return to shower
end;    "End of subroutine electr
"*******************************************************************************


%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE HATCH;
"                                                                  "
"******************************************************************"
"   Setup which the user is expected to do before calling HATCH is:"
"     1. SET 'NMED' TO THE NUMBER OF MEDIA TO BE USED."
"     2. SET THE ARRAY 'MEDIA', WHICH CONTAINS THE NAMES OF THE"
"        MEDIA THAT ARE DESIRED.  THE CHARACTER FORMAT IS A1, SO"
"        THAT MEDIA(IB,IM) CONTAINS THE IB'TH BYTE OF THE NAME OF"
"        THE IM'TH MEDIUM IN A1 FORMAT."
"     3. SET 'DUNIT', THE DISTANCE UNIT TO BE USED."
"        DUNIT.GT.0 MEANS VALUE OF DUNIT IS LENGTH OF DISTANCE UNIT"
"        CENTIMETERS.  DUNIT.LT.0 MEANS USE THE RADIATION LENGTH OF"
"        THE ABS(DUNIT)'TH MEDIUM FOR THE DISTANCE UNIT."
"     4. FILL THE ARRAY 'MED' WITH THE MEDIUM INDICES FOR THE"
"        REGIONS."
"     5. FILL ARRAYS 'ECUT' AND 'PCUT' WITH THE ELECTRON AND PHOTON"
"        CUT-OFF ENERGIES FOR EACH REGION RESPECTIVELY.  SETUP WILL"
"        RAISE THESE IF NECESSARY TO MAKE THEM AT LEAST AS LARGE AS"
"        THE REGION'S MEDIUM'S AE AND AP RESPECTIVELY."
"     6. FILL 'MED' ARRAY.  MED(IR) IS THE MEDIUM INDEX FOR REGION"
"        IR.  A ZERO MEDIUM INDEX MEANS THE REGION IS IN A VACUUM."
"     7. FILL THE ARRAY 'IRAYLR' WITH 1 FOR EACH REGION IN WHICH"
"        RAYLEIGH (COHERENT) SCATTERING IS TO BE INCLUDED."
"
"   KMPO = 8 and KMPI = 12 are set in BLOCK DATA"
"   The echo to unit 8 has been removed since it is sent"
"                                          to /dev/null anyway!"
"           To put it back search $UOUTPUT  and $ECHO and uncomment"
"******************************************************************"

$IMPLICIT-NONE;

character*512 toUpper;
$COMIN-HATCH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,BOUNDS,BREMPR,EGS-VARIANCE-REDUCTION,"
                      "ELECIN,MEDIA,MISC,PHOTIN,STACK,
                      "THRESH,UPHIIN,UPHIOT,USEFUL,USER,RANDOM/;

$DECLARE-PEGS4-COMMON-BLOCKS;

$DEFINE-LOCAL-VARIABLES-HATCH;

character*256 tmp_string;
$INTEGER      lnblnk1;" in house lnblnk function becuase not all compilers"
                      " support this"

DATA MDLABL/$S' MEDIUM='/,LMDL/8/,LMDN/24/,DUNITO/1./;
DATA I1ST/1/,NSINSS/37/,MXSINC/$MXSINC/,ISTEST/0/,NRNA/1000/;

$INIT-PEGS4-VARIABLES;

"   FORMAT STATEMENTS USED MULTIPLE TIMES IN SETUP"
:INT:FORMAT(1X,14I5);
:FLT:FORMAT(1X,1PE14.5,4E14.5);
:BYTE:FORMAT(72A1);

IF (I1ST.NE.0)[ I1ST=0;"RESET FIRST TIME FLAG"
"   DO FIRST TIME INITIALIZATION"

$HATCH-USER-INPUT-INIT;

"   NOW CONSTRUCT PIECEWISE LINEAR FIT TO SINE FUNCTION OVER THE"
"   INTERVAL (0,5*PI/2).  DIVIDE THIS INTERVAL INTO MXSINC SUB-"
"   INTERVALS.  EACH OF THESE SUBINTERVALS IS THEN SUBDIVIDED INTO"
"   NSINSS SUB-SUB-INTERVALS.  THE ANGLES AT THE BOUNDARIES OF"
"   THESE SUB-SUB-INTERVALS AND THEIR SINES ARE USED TO COMPUTE"
"   LEAST SQUARES COEFFICIENTS FOR THE SUBINTERVAL.  AN EXTRA"
"   SUBINTERVAL ON EACH SIDE OF THE INTERVAL (0,5*PI/2) IS INCLUDED"
"   FOR GOOD MEASURE."
NISUB=MXSINC-2;FNSSS=NSINSS;
WID=PI5D2/FLOAT(NISUB);
WSS=WID/(FNSSS-1.0);
ZEROS(1)=0.;ZEROS(2)=PI; ZEROS(3)=TWOPI;

DO ISUB=1,MXSINC ["LOOP OVER SUBINTERVALS"
SX=0.;SY=0.;SXX=0.;SXY=0.;"ZERO SUMS"

XS0=WID*FLOAT(ISUB-2);XS1=XS0+WID;"LOWER & UPPER LIMITS"
"   NOW CHECK TO SEE IF ANY ZEROS ARE IN THE INTERVAL"
IZ=0; DO IZZ=1,3 [
IF ((XS0.LE.ZEROS(IZZ)).AND.(ZEROS(IZZ).LE.XS1))[IZ=IZZ;EXIT;]
] "END OF LOOP OVER ZEROS"
IF (IZ.EQ.0)[XSI=XS0;]ELSE[XSI=ZEROS(IZ);]
DO ISS=1,NSINSS ["LOOP OVER SUB-SUBINTERVALS"
XS=WID*FLOAT(ISUB-2)+WSS*FLOAT(ISS-1)-XSI; "ANGLE VALUE"
YS=SIN(XS+XSI); "SINE OF ANGLE"
SX=SX+XS; "ACCUMULATE SUMS"
SY=SY+YS;
SXX=SXX+XS*XS;
SXY=SXY+XS*YS;
] "END SUB-SUBINTERVAL LOOP"

"   NOW COMPUTE LEAST SQUARES COEFFICIENTS"
IF (IZ.NE.0)["FORCE FIT THROUGH SINES' ZEROS,"
"             FOR SMALL REL.ERR.&GOOD"
"   VALUES OF SINTHE/THETA NEAR ZERO"
SIN1(ISUB)=SXY/SXX;
SIN0(ISUB)=-SIN1(ISUB)*XSI;]
ELSE["DO FULL LEAST SQUARES"
DEL=FNSSS*SXX-SX*SX;
SIN1(ISUB)=(FNSSS*SXY-SY*SX)/DEL;
SIN0(ISUB)=(SY*SXX-SX*SXY)/DEL - SIN1(ISUB)*XSI ; ]
] "END SUB-INTERVAL LOOP"

SINC0=2.0 ;"SET COEFFICIENTS WHICH DETERMINE INTERVAL"
SINC1=1.0/WID;

"   NOW TEST FIT, IF REQUESTED"
IF (ISTEST.NE.0)[
"   FIRST TEST AT POINTS PREVIOUSLY COMPUTED, EXCLUDING"
"   END SUBINTERVALS"
ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
DO ISUB=1,NISUB [ DO ISS=1,NSINSS [
THETA=WID*FLOAT(ISUB-1)+WSS*FLOAT(ISS-1);
CTHET=PI5D2-THETA;
$SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
$EVALUATE SINTHE USING SIN(THETA);
$EVALUATE COSTHE USING SIN(CTHET);
SINT=SIN(THETA); COST=COS(THETA);
ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
ADEV=max(ADEV,ASD,ACD);
IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
S2C2=SINTHE**2+COSTHE**2;
S2C2MN=min(S2C2MN,S2C2);
S2C2MX=max(S2C2MX,S2C2);
IF (ISUB.LT.11)[$egs_info('(1PE20.7,4E20.7)',THETA,SINTHE,SINT,COSTHE,COST);]
] ] "END OF FIXED INTERVAL TEST-OUTPUT RESULTS"
$egs_info('(a,2i5)',' SINE TESTS,MXSINC,NSINSS=',MXSINC,NSINSS);
$egs_info('(a,1PE16.8,3e16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
                                 ADEV,RDEV,S2C2MN,S2C2MX);
"   NOW DO RANDOM TEST"
ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
DO IRN=1,NRNA[ $RANDOMSET THETA;THETA=THETA*PI5D2;
CTHET=PI5D2-THETA;
$SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
$EVALUATE SINTHE USING SIN(THETA);
$EVALUATE COSTHE USING SIN(CTHET);
SINT=SIN(THETA); COST=COS(THETA);
ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
ADEV=max(ADEV,ASD,ACD);
IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
S2C2=SINTHE**2+COSTHE**2;
S2C2MN=min(S2C2MN,S2C2);
S2C2MX=max(S2C2MX,S2C2);
] "END RANDOM ANGLE LOOP"
$egs_info('(a,i7,a)', ' TEST AT ',NRNA,' RANDOM ANGLES IN (0,5*PI/2)');
$egs_info('(1PE16.8,3E16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
                               ADEV,RDEV,S2C2MN,S2C2MX);
] "END OF SINE TABLE TEST"

"   NOW FILL IN POWER OF TWO TABLE.  PWR2I(I)=1/2**(I-1)"
P=1.; DO I=1,$MXPWR2I [PWR2I(I)=P; P=P/2.;]

] "END OF FIRST TIME INITIALIZATION"

"FILL IRAYLM ARRAY BASED ON IRAYLR INPUTS"
$need_rayleigh_data;

"Ali:photonuc, 2 lines"
"FILL IPHOTONUCM ARRAY BASED ON IPHOTONUCR INPUTS"
$need_photonuc_data;
$egs_info('(a,i3)',' ===> Photonuclear flag: ', iphotonuc);

"   NOW SEARCH FILE FOR DATA FOR REQUESTED MATERIALS"
IF(~is_pegsless) REWIND KMPI;
"explicit file name for HP compiler  Nov 23, 1996   DR"
IUECHO=KMPO;
NM=0; "NUMBER OF MEDIA FOUND"
DO IM=1,NMED [LOK(IM)=0;"SET FLAG TELLING WHICH MEDIA ARE OK"
  "NOW TELL USER IF RAYLEIGH OPTION HAS BEEN REQUESTED"
  IF(IRAYLM(IM).EQ.1) [
     $egs_info('(a,i3/)', ' RAYLEIGH OPTION REQUESTED FOR MEDIUM NUMBER',IM);
  ]
]

"Ali:photonuc, 1 block"
DO IM=1,NMED [
  "TELL USER IF PHOTONUC HAS BEEN REQUESTED"
  IF(IPHOTONUCM(IM).EQ.1) [
     $egs_info('(a,i3/)', ' PHOTONUCLEAR REQUESTED FOR MEDIUM NUMBER',IM);
  ]
]

IF(~is_pegsless)[
:MEDIUM:
LOOP["MEDIUM SEARCH LOOP"

:MDLOOK:
LOOP["MEDIUM HEADER SEARCH LOOP"
  "   FIRST LOOK FOR MEDIUM HEADER"
  READ(KMPI,:BYTE:,END=:MDNOMORE:)MBUF;
  DO IB=1,LMDL [IF (MBUF(IB).NE.MDLABL(IB))NEXT:MDLOOK:;]
  "   HEADER MATCHES. NOW SEE IF IT IS ONE OF REQUESTED MEDIA"
  :MDNAME:
  DO IM=1,NMED [
    DO IB=1,LMDN [IL=LMDL+IB; IF (MBUF(IL).NE.MEDIA(IB,IM))NEXT:MDNAME:;
    IF (IB.EQ.LMDN)EXIT:MDLOOK:; ]
  ] "END :MDNAME: DO"
  "   NOT IN NAME TABLE, SO IGNORE IT"
]REPEAT "MDLOOK"

"   'IM' IS THE INDEX OF THE MEDIUM READY TO BE READ"
IF (LOK(IM).NE.0)GO TO :MDLOOK:;"WE ALREADY HAVE THIS ONE"
LOK(IM)=1;NM=NM+1;"SET FOUND FLAG AND STEP MEDIUM COUNTER"

"   NOW READY TO READ IN DATA FOR THIS MEDIUM"
"$UOUTPUT(KMPO)IM,MBUF;(' DATA FOR MEDIUM #',I3,', WHICH IS:',72A1);"

"   NOW PUT OUT LINES SHOWING COMPOSITION OF MEDIUM"
"THE FOLLOWING LINE WAS CHANGED TO STORE THE ELEMENTAL COMPOSITION AFB 88/05/31"
"$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NE;"
"The next two lines were line prior to Dec 89 mods to get IUNRST"
"$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
"(5A1,5X,F11.0,4X,I2);"
"following used to pick up IUNRST, IAPRIM and EPSTFL"
"Problem is that GASP may or may not be printed, so we make"
"a kludge which will work with all old data files"
"FIRST WE ASSUME THERE IS NO GASP VALUE IN THE LINE"
"Note that this reading scheme counts on there being an"
"error when GASP does exist on the line--an error does"
"occur on most compilers, however, we have found that on"
"the rs6000 an error does not occur.  Instead, a warning"
"is printed out and IUNRST,EPSTFL and IAPRIM are set to 0."
"This will make no difference in simulations but will cause"
"a problem when running EXAMIN"

" IK: backspace(kmpi) fails under windows using g77 with I/O error"
"     therefore we read the line in a temporary string and then "
"     use memoty I/O to try to read with and without gasp there. "

read(kmpi,'(a)',err=:hatch_read_error1:) tmp_string;
goto :no_hatch_read_error1:;
:hatch_read_error1:
$egs_fatal(*,'Error while reading pegs4 file');

:no_hatch_read_error1:;
read(tmp_string,1,ERR=:GASP-THERE:)
"READ(KMPI,1,ERR=:GASP-THERE:)"
(MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),IAPRIM(IM);
1   FORMAT(5A1,5X,F11.0,4X,I2,9X,I1,9X,I1,9X,I1);
"IUNRST, EPSTFL AND IAPRIM ARE STORED IN COMIN ELECIN"
GO TO :GASP-NOT-THERE:;

:GASP-THERE:;
"WE MUST REREAD THE LINE WITH THE CORRECT FORMAT"
"BACKSPACE(KMPI);""THIS BACKS UP ONE RECORD TO RE-READ IT"
"READ(KMPI,2)"

"The following output is only there because without it"
"code compiled with the new gfortran GNU compiler "
"fails with run time error. Another bug in their "
"pre-alpha quality I/O system ----IK, Oct 26 2005 "
"write(6,*) 'Found medium with gas pressure';"
$egs_info(*,'Found medium with gas pressure');
read(tmp_string,2)
(MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),
IAPRIM(IM);
2     FORMAT(5A1,5X,F11.0,4X,I2,26X,I1,9X,I1,9X,I1);

:GASP-NOT-THERE:

"THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
"$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NE;"
";$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
"(5A1,',RHO=',1PG11.4,',NE=',I2,',COMPOSITION IS :');"
"THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
"DO IE=1,NE["
DO IE=1,NNE(IM)[
    "THE FOLLOWING LINE, COMMENTED OUT, WAS THE OLD WAY OF READING IN "
    "THE ELEMENTAL COMPOSITION OF EACH MEDIUM. THE INFORMATION WAS NOT"
    "PASSED ON TO EGS. IN THE PRESENT VERSION IT IS READ IN AND STORED"
    "IN COMMON BREMPR. AFB 88/05/31.                                  "
    "READ(KMPI,:BYTE:)MBUF;WRITE(KMPO,:BYTE:)MBUF;"
    $UINPUT(KMPI)
    (MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),
    ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);
    (6A1,2A1,3X,F3.0,3X,F9.0,4X,F12.0,6X,F12.0);
    "$UOUTPUT(KMPO)"
    "(MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),"
    "ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);"
    "(6A1,2A1,',Z=',F3.0,',A=',F9.3,',PZ=',1PE12.5,',RHOZ=',1PE12.5);"
    ]

"   MEDIA AND THRESH"
"$ECHO" READ(KMPI,:FLT:) $LGN(RLC,AE,AP,UE,UP(IM));
TE(IM)=AE(IM)-RM; THMOLL(IM)=TE(IM)*2. + RM ;

"   ACTUAL ARRAY SIZES FROM PEGS"
"$ECHO" READ(KMPI,:INT:)
$LGN(MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE(IM)),IRAYL;
NSGE=MSGE(IM);NGE=MGE(IM);NSEKE=MSEKE(IM);NEKE=MEKE(IM);
NLEKE=MLEKE(IM);NCMFP=MCMFP(IM);NRANGE=MRANGE(IM);

"   BREMPR"
"$ECHO" READ(KMPI,:FLT:)($LGN(DL(I,IM)/1,2,3,4,5,6/),I=1,6);
"$ECHO" READ(KMPI,:FLT:)DELCM(IM),($LGN(ALPHI,BPAR,
   DELPOS(I,IM)),I=1,2);

"   ELECIN"
"$ECHO" READ(KMPI,:FLT:)$LGN(XR0,TEFF0,BLCC,XCC(IM));
"$ECHO" READ(KMPI,:FLT:)$LGN(EKE(IM)/0,1/);
"$ECHO" READ(KMPI,:FLT:)
($LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,
   TMXS(I,IM)/0,1/),I=1,NEKE);

"   PHOTIN"
"$ECHO" READ(KMPI,:FLT:)EBINDA(IM),$LGN(GE(IM)/0,1/);
"$ECHO" READ(KMPI,:FLT:)($LGN(GMFP,GBR1,GBR2(I,IM)/0,1/),I=1,NGE);

"   PHOTIN (CONTINUED)---OPTIONAL RAYLEIGH SCATTERING INPUT"

/* Leave this for compatibility with existing pegs4 data sets.  */
IF (IRAYL.EQ.1) [
"$ECHO" READ(KMPI,:INT:) NGR(IM);
NGRIM=NGR(IM);
"$ECHO" READ(KMPI,:FLT:)$LGN(RCO(IM)/0,1/);
"$ECHO" READ(KMPI,:FLT:)($LGN(RSCT(I,IM)/0,1/),I=1,NGRIM);
"$ECHO" READ(KMPI,:FLT:)($LGN(COHE(I,IM)/0,1/),I=1,NGE);
 "IF(IRAYLM(IM).NE.1) ["
 $egs_info('(a,i3,a)', ' Rayleigh data available for medium',
          IM, ' in PEGS4 data set.');
 "]"
]

/*******************************************************************
 Rayleigh data picked up directly from pgs4form.data or user-supplied
 ff file in egs_init_rayleigh unless user wants to use PEGS4 data.
*********************************************************************/
IF(IRAYLM(IM).EQ.1) ["Rayleigh data requested for medium IM"
  IF(IRAYL.NE.1) ["No data in PEGS4"
    IF(toUpper($cstring(photon_xsections))='PEGS4')
    ["Rayleigh not possible"
     $egs_fatal('(a,i3 /,a /,a)',
     ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
     IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.',
     ' YOU WILL NOT BE ABLE TO USE THE PEGS4 DATA WITH RAYLEIGH ON!');
    ]
    ELSE["Data will be taken from elsewhere (si,epdl,xcom,custom)"
     $egs_warning('(a,i3 /,a)',
     ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
     IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.');
    ]
  ]
 ELSE["Rayleigh data in PEGS4"
    IF(toUpper($cstring(photon_xsections))='PEGS4')
    ["PEGS4 data selected"
      "***********************************************************"
      "Preparing data for new Rayleigh angular sampling when using"
      "the pegs4 data set,                                        "
      "***********************************************************"
       call egs_init_rayleigh_sampling(IM);
    ]
    "ELSE[Taking photon data from either si,epdl,xcom or user]"
  ]
]
/*******************************************************************/

"   THAT'S ALL FOR THIS MEDIUM"
]UNTIL NM.GE.NMED; "LOOP UNTIL WE HAVE ENOUGH.  END :MEDIUM: LOOP"

CLOSE (UNIT=KMPI);

"   WE NOW HAVE DATA FOR ALL MEDIA REQUESTED.  NOW DO DISTANCE UNIT"
"   CHANGE.  DATA FROM PEGS IS IN UNITS OF RADIATION LENGTHS."
"   EGS IS RUN IN UNITS OF 'DUNIT' CENTIMETERS, IF DUNIT.GT.0 "
"   OR IN UNITS OF RLC(-DUNIT) CENTIMETERS IF DUNIT.LT.0."
"   THAT IS, A NEGATIVE DUNIT MEANS UNIT IS TO BE THE RADIATION"
"   LENGTH OF THE MEDIUM WHOSE INDEX IS -DUNIT"
DUNITR=DUNIT; "SAVE REQUESTED"
IF(DUNIT.LT.0.0)[ID=MAX0(1,MIN0($MXMED,int(-DUNIT)));
   DUNIT=RLC(ID);]
IF(DUNIT.NE.1.0) [
$egs_info('(a,1PE14.5,E14.5,a)',' DUNIT REQUESTED&USED ARE: ',
         DUNITR,DUNIT,'(CM.)' );
]
DO IM=1,NMED [
DFACT=RLC(IM)/DUNIT; "CONVERTS RL TO DUNITS"
DFACTI=1.0/DFACT;    "CONVERT RL**-1 TO DUNITS**-1"

FOR I=1 TO MEKE(IM) [
$SCALE $LGN(ESIG,PSIG,EDEDX,PDEDX(I,IM)/0,1/) BY DFACTI;
$SCALE $LGN(TMXS(I,IM)/0,1/) BY DFACT;]
$SCALE TEFF0(IM) BY DFACT;
$SCALE BLCC(IM) BY DFACTI;
$SCALE XCC(IM) BY SQRT(DFACTI);
RLDU(IM)=RLC(IM)/DUNIT;
FOR I=1 TO MGE(IM) [$SCALE $LGN(GMFP(I,IM)/0,1/) BY DFACT; ]
] "END IM DO"

"   SCALE VACDST.  UNDO PREVIOUS SCALE, THEN DO NEW."
VACDST=VACDST*DUNITO/DUNIT;
DUNITO=DUNIT; "SAVE OLD DUNIT"

]"end regular pegs4 intake"
ELSE["pegsless intake of medium data"

$egs_info(*,' PEGSLESS INPUT.  CALCULATING ELECTRON CROSS-SECTIONS.');

$GET-PEGSLESS-XSECTIONS;

]

"   NOW MAKE SURE ECUT AND PCUT ARE NOT LOWER THAN ANY AE OR AP"
"   ALSO SET DEFAULT DENSITIES"
$adjust_rhor_ecut_pcut;

"BREMSSTRAHLUNG ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
"NEXT LINE ADDED AFB 88/05/31"
$INITIALIZE-BREMS-ANGLE;

"PAIR ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
"NEXT LINE ADDED AFB 91/05/29"
$INITIALIZE-PAIR-ANGLE;

" See if user has requested PEGS4 photon cross section data "
IF(toUpper($cstring(photon_xsections)) = 'PEGS4')[
  $egs_warning('(6(a/))','Using photon data from PEGS4 file!!!',
  'However, the new Rayleigh angular sampling will be used.',
  'The original EGS4 angular sampling undersamples large scattering ',
  'angles. This may have little impact as Rayleigh scattering ',
  'is forward peaked.',
  '*********************************************************');

]
ELSE["re-calculates photon xsections using available or user data"
"Ali:photonuc, 2 lines"
    call egs_init_user_photon(photon_xsections,comp_xsections,
    photonuc_xsections,xsec_out);
"    call egs_init_user_photon(photon_xsections,comp_xsections,xsec_out);"
]

call mscati;       "Initialize new MS, step-sizes, etc, IK Oct 97"

"Calling order of the subroutines below is important when using"
"detailed atomic relaxation in order to use the binding energies"
"corresponding to the requested photon cross section library"
IF ( eadl_relax & photon_xsections = 'xcom' )[
   call init_compton; "Initialize bound Compton scattering"
   call EDGSET(1,1);  "Initialize relaxations and photo-absorption data"
]
ELSE[
   call EDGSET(1,1);  "Initialize relaxations and photo-absorption data,"
                      "if requested
   call init_compton; "Initialize bound compton scattering, IK, Jan 99"
                      "if requested
]

IF( xsec_out = 1 & eadl_relax) [
  call egs_print_binding_energies;
]

call fix_brems;    "Re-calculate dl1,... for the different technique"
                   "employed in BREMS. Note that the old EGS sampling"
                   "technique for BREMS had a bug that shows up only"
                   "if AP is not much smaller than electron kinetic energy"

IF( ibr_nist >= 1 ) [ call init_nist_brems; ]
                   "initializes the sampling tables and modifies the total"
                   "brems cross sections if the NIST brems data base is to"
                   "be used                                               "

IF( pair_nrc = 1 ) [ call init_nrc_pair; ]

" Load and initialize EII data if needed. "
call eii_init;

" Load and initialize the triplet data if needed "
call init_triplet;

"   SETUP IS NOW COMPLETE"
IF (NMED.EQ.1)[
   $egs_info(*,'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ONE MEDIUM.');
]
ELSE[
   $egs_info('(a,i5,a)',
             'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ',NMED,' MEDIA.');
]

RETURN;

:MDNOMORE:
$egs_info('(a,i2//,a/,a/)', ' END OF FILE ON UNIT ',KMPI,
  ' PROGRAM STOPPED IN HATCH BECAUSE THE',
  ' FOLLOWING NAMES WERE NOT RECOGNIZED:');
DO IM=1,NMED [
   IF(LOK(IM).NE.1) [
      $egs_info('(40x,a,24a1,a)','''',(MEDIA(I,IM),I=1,LMDN),'''');
   ]
]
STOP;
"END OF SUBROUTINE HATCH"   END;

subroutine fix_brems;
"******************************************************************"
"
" Calculates the parameter for the rejection function used in
" the current implementation of bremsstrahlung sampling
"
" I Kawrakow, January 2000
"
"*******************************************************************"

$IMPLICIT-NONE;
$declare_max_medium;
;COMIN/BREMPR,MEDIA,NIST-BREMS,THRESH/;

$INTEGER medium,i;
$REAL    Zt,Zb,Zf,Zg,Zv,fmax1,fmax2,Zi,pi,fc,xi,aux,
         XSIF,FCOULC;

DO medium = 1,nmed [

    log_ap(medium) = log(ap(medium));
    Zt = 0; Zb = 0; Zf = 0;
    DO i=1, NNE(medium) [
        Zi = ZELEM(medium,i); pi = PZ(medium,i);
        fc = FCOULC(Zi); xi = XSIF(Zi);
        aux = pi*Zi*(Zi + xi);
        Zt = Zt + aux;
        Zb = Zb - aux*Log(Zi)/3;
        Zf = Zf + aux*fc;
    ]
    Zv = (Zb - Zf)/Zt; Zg = Zb/Zt;
    fmax1 = 2*(20.863 + 4*Zg) - 2*(20.029 + 4*Zg)/3;
    fmax2 = 2*(20.863 + 4*Zv) - 2*(20.029 + 4*Zv)/3;

    "These are used in BREMS"
    dl1(1,medium) = (20.863 + 4*Zg)/fmax1;
    dl2(1,medium) = -3.242/fmax1;
    dl3(1,medium) = 0.625/fmax1;
    dl4(1,medium) = (21.12+4*Zg)/fmax1;
    dl5(1,medium) = -4.184/fmax1;
    dl6(1,medium) = 0.952;
    dl1(2,medium) = (20.029+4*Zg)/fmax1;
    dl2(2,medium) = -1.93/fmax1;
    dl3(2,medium) = -0.086/fmax1;
    dl4(2,medium) = (21.12+4*Zg)/fmax1;
    dl5(2,medium) = -4.184/fmax1;
    dl6(2,medium) = 0.952;
    dl1(3,medium) = (20.863 + 4*Zv)/fmax2;
    dl2(3,medium) = -3.242/fmax2;
    dl3(3,medium) = 0.625/fmax2;
    dl4(3,medium) = (21.12+4*Zv)/fmax2;
    dl5(3,medium) = -4.184/fmax2;
    dl6(3,medium) = 0.952;
    dl1(4,medium) = (20.029+4*Zv)/fmax2;
    dl2(4,medium) = -1.93/fmax2;
    dl3(4,medium) = -0.086/fmax2;
    dl4(4,medium) = (21.12+4*Zv)/fmax2;
    dl5(4,medium) = -4.184/fmax2;
    dl6(4,medium) = 0.952;

    "and these in PAIR"
    dl1(5,medium) = (3*(20.863 + 4*Zg) - (20.029 + 4*Zg));
    dl2(5,medium) = (3*(-3.242) - (-1.930));
    dl3(5,medium) = (3*(0.625)-(-0.086));
    dl4(5,medium) = (2*21.12+8*Zg);
    dl5(5,medium) = (2*(-4.184));
    dl6(5,medium) = 0.952;
    dl1(6,medium) = (3*(20.863 + 4*Zg) + (20.029 + 4*Zg));
    dl2(6,medium) = (3*(-3.242) + (-1.930));
    dl3(6,medium) = (3*0.625+(-0.086));
    dl4(6,medium) = (4*21.12+16*Zg);
    dl5(6,medium) = (4*(-4.184));
    dl6(6,medium) = 0.952;
    dl1(7,medium) = (3*(20.863 + 4*Zv) - (20.029 + 4*Zv));
    dl2(7,medium) = (3*(-3.242) - (-1.930));
    dl3(7,medium) = (3*(0.625)-(-0.086));
    dl4(7,medium) = (2*21.12+8*Zv);
    dl5(7,medium) = (2*(-4.184));
    dl6(7,medium) = 0.952;
    dl1(8,medium) = (3*(20.863 + 4*Zv) + (20.029 + 4*Zv));
    dl2(8,medium) = (3*(-3.242) + (-1.930));
    dl3(8,medium) = (3*0.625+(-0.086));
    dl4(8,medium) = (4*21.12+16*Zv);
    dl5(8,medium) = (4*(-4.184));
    dl6(8,medium) = 0.952;

    bpar(2,medium) = dl1(7,medium)/(3*dl1(8,medium) + dl1(7,medium));
    bpar(1,medium) = 12*dl1(8,medium)/(3*dl1(8,medium) + dl1(7,medium));

]
return;
end;


$REAL function FCOULC(Z);
"************************"
$IMPLICIT-NONE;
$REAL Z;
$REAL fine,asq;
data fine/137.03604/;
asq = Z/fine; asq = asq*asq;
FCOULC = asq*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+ASQ*(0.0083+ASQ*(-0.002))));
return;
end;

$REAL function XSIF(Z);
"**********************"
$IMPLICIT-NONE;
$REAL    Z;
$INTEGER iZ;
$REAL    alrad(4),alradp(4),a1440,a183,FCOULC;
data     alrad/5.31,4.79,4.74,4.71/;
data     alradp/6.144,5.621,5.805,5.924/;
data     a1440/1194.0/,A183/184.15/;
IF( Z <= 4 ) [ iZ = Z; xsif = alradp(iZ)/(alrad(iZ) - FCOULC(Z)); ]
ELSE [ xsif = Log(A1440*Z**(-0.666667))/(Log(A183*Z**(-0.33333))-FCOULC(Z)); ]
return;
end;

"******************************************************************"
subroutine init_compton;
"
"  Reads in bound Compton scattering data from unit $INCOHUNIT
"  and performs necessary initializations
"
"  See definitions of variables in egsnrc.macros with definition
"  of COMIN/COMPTON-DATA/
"
"  I.Kawrakow, January 99
"******************************************************************"

implicit none;

$COMIN-INIT-COMPT;

$INTEGER i,j,iz,nsh,j_l,j_h;
$REAL    aux,pztot,atav;
$REAL    aux_erf,erf1;  "using erf1, provided with EGSnrc, because some"
                        "compiler don't have an intrinsic error function"
$LOGICAL getd;

" Initialize radiative Compton corrections, if needed "
$RADC_HATCH;

$need_bound_compton_data(getd);
IF( ~getd ) [
    IF( eadl_relax & photon_xsections = 'xcom' )[
        $egs_fatal('(a,/a,/a)',
                   'You must turn ON Compton binding corrections when using',
                   'a detailed atomic relaxation (eadl_relax=true) since ',
                   'binding energies taken from incoh.data below 1 keV!');
    ]
    $egs_info('(a/)',' Bound Compton scattering not requested! ');
    return;
]

$egs_info('(/a$)','Bound Compton scattering requested, reading data ......');
rewind($INCOHUNIT);
DO j=1,18 [ read($INCOHUNIT,*); ]  "skip 1st 18 lines of comments"
iz = 0;
DO j=1,$MXTOTSH [
    read($INCOHUNIT,*) iz_array(j),shn_array(j),ne_array(j),
                       Jo_array(j),be_array(j);
    Jo_array(j) = Jo_array(j)*137.;
    be_array(j) = be_array(j)*1e-6/PRM;
    aux_erf = 0.70710678119*(1+0.3*Jo_array(j));
    erfJo_array(j) = 0.82436063535*(erf1(aux_erf)-1);
                    "0.82436063535 is exp(0.5)/2"

    "For detailed atomic relaxations set shell type
    "to actual shell number and update binding energies
    "with values from the photo-electric cross sections
    IF (eadl_relax)[
       IF (iz_array(j) ~= iz)[
          shn_array(j) = 1; iz = iz_array(j);
       ]
       ELSE[
          shn_array(j) = shn_array(j-1)+1;
       ]
       IF(binding_energies(shn_array(j),iz_array(j)) > 0)[
         be_array(j) = binding_energies(shn_array(j),iz_array(j))/PRM;
       ]
       ELSE IF(photon_xsections = 'xcom') [
         "Use binding energies from incoh.data below 1 keV"
         binding_energies(shn_array(j),iz_array(j)) = be_array(j)*PRM;
       ]
    ]

]
$egs_info(*,' Done');
$egs_info('(/a)',' Initializing Bound Compton scattering ......');
DO medium = 1,nmed [
    pztot = 0; nsh = 0;
    DO i = 1, nne(medium) [
        iz = int(zelem(medium,i));
        DO j = 1, $MXTOTSH [
            IF( iz = iz_array(j) ) [
                nsh = nsh + 1;
                IF( nsh > $MXMDSH ) [
                    $egs_fatal('(/a,i3,a,i4,a/,a)',' For medium ',medium,
                              ' the number of shells is > ',$MXMDSH,'!',
                              ' Increase the parameter $MXMDSH! ');
                ]
                shell_array(nsh,medium) = j;
                aux = pz(medium,i)*ne_array(j);
                eno_array(nsh,medium) = aux;
                pztot = pztot + aux;
            ]
        ]
    ]
    IF( nsh = 0 ) [
        $egs_fatal('(a,i3,a)', ' Medium ',medium,' has zero shells! ');
    ]
    n_shell(medium) = nsh;
    $egs_info('(a,i3,a,i3,a)', ' Medium ',medium,' has ',nsh,' shells: ');
    DO i=1,nsh [
        j = shell_array(i,medium);
        eno_array(i,medium) = eno_array(i,medium)/pztot;
        $egs_info('(i4,i5,i4,f9.5,e10.3,f10.3)',
                  i,j,shn_array(j),eno_array(i,medium),
                  Jo_array(j),be_array(j)*PRM*1000.);
        eno_array(i,medium) = -eno_array(i,medium);
        eno_atbin_array(i,medium) = i;
    ]
    atav = 1./nsh;
    DO i=1,nsh-1 [
        DO j_h = 1,nsh-1 [
            IF( eno_array(j_h,medium) < 0 ) [
                IF( abs(eno_array(j_h,medium)) > atav ) EXIT;
            ]
        ]
        DO j_l = 1,nsh-1 [
            IF( eno_array(j_l,medium) < 0 ) [
                IF( abs(eno_array(j_l,medium)) < atav ) EXIT;
            ]
        ]
        aux = atav - abs(eno_array(j_l,medium));
        eno_array(j_h,medium) = eno_array(j_h,medium) + aux;
        eno_array(j_l,medium) = -eno_array(j_l,medium)/atav + j_l;
        eno_atbin_array(j_l,medium) = j_h;
        IF( i = nsh-1 ) eno_array(j_h,medium) = 1 + j_h;
    ]
    DO i=1,nsh [
        IF( eno_array(i,medium) < 0 ) [ eno_array(i,medium) = 1 + i; ]
    ]
]

$egs_info('(a/)',' ...... Done.');

$need_relaxation_data(getd);
IF( getd ) return;
$egs_fatal('(/a,/a,/a,/a)',
' In subroutine init_compton: ',
'   Scattering off bound electrons creates atomic vacancies,',
'   potentially starting an atomic relaxation cascade. ',
'   Please turn ON atomic relaxations.');
/*
Turning ON relaxations to setup relaxations for bound Compton
and then turning it back OFF seems inconsistent. One should have
relaxations for all interactions with atomic electrons.

$egs_info('(a/,a/,a/,a//)',
' In subroutine init_compton: ',
'   fluorescence not set but relaxation data are required for ',
'   bound Compton scattering. ',
'   calling EDGSET. ');
iedgfl(1) = 1;              "This was (2) originally  DR"
eadl_relax = .true.;
call edgset(1,1);
iedgfl(1) = 0;              "This was (2) originally  DR"
*/
return;
end;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE MOLLER;
"                                                                  "
"******************************************************************"
"   DISCRETE MOLLER SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
"   ARBITRARILY DEFINED AND CALCULATED TO MEAN MOLLER SCATTERINGS  "
"   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
"   IT BE TRANSPORTED DISCRETELY.  THE THRESHOLD TO TRANSPORT AN   "
"   ELECTRON DISCRETELY IS A TOTAL ENERGY OF AE OR A KINETIC ENERGY"
"   OF TE=AE-RM.  SINCE THE KINETIC ENERGY TRANSFER IS ALWAYS, BY  "
"   DEFINITION, LESS THAN HALF OF THE INCIDENT KINETIC ENERGY, THIS"
"   IMPLIES THAT THE INCIDENT ENERGY, EIE, MUST BE LARGER THAN     "
"   THMOLL=TE*2+RM.  THE REST OF THE COLLISION CONTRIBUTION IS     "
"   SUBTRACTED CONTINUOUSLY FROM THE ELECTRON AS IONIZATION        "
"   LOSS DURING TRANSPORT.                                         "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-MOLLER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "  COMIN/EGS-VARIANCE-REDUCTION, DEBUG,STACK,THRESH,"
                                          "UPHIOT,USEFUL,RANDOM/;"
;COMIN/EII-DATA,ELECIN,EPCONT,EDGE,BREMPR/;

$DEFINE-LOCAL-VARIABLES-MOLLER;

$REAL sigm,pbrem,rsh,Uj,sig_j;
$INTEGER lelke,iele,ish,nsh,ifirst,i,jj,iZ,iarg;

"IRCODE=1;  appears to be unused, IK Oct 97"
NPold = NP;      "Set the old stack counter"
PEIE=E(NP);"PRECISE ENERGY OF INCIDENT ELECTRON"
EIE=PEIE; "ENERGY OF INCIDENT ELECTRON"
PEKIN=PEIE-PRM;  "PRECISE K.E. OF INCIDENT ELECTRON"
EKIN=PEKIN;

IF( eii_flag > 0 & eii_nsh(medium) > 0 ) [
    "The EII flag is set and this medium has shells for which we want to"
    "simulate EII => sample if the interaction is with a EII shell"
    $SET INTERVAL elke,eke;
    $EVALUATE sigm USING esig(elke);
    $EVALUATE pbrem USING ebr1(elke);
    sigm = sigm*(1 - pbrem);
    $RANDOMSET rsh; rsh = sigm*rsh;
    DO iele=1,nne(medium) [
        iZ = int(zelem(medium,iele)+0.5);
        nsh = eii_no(medium,iele);
        IF( nsh > 0 ) [
            ifirst = eii_first(medium,iele);
            DO ish = 1,nsh [
                Uj = binding_energies(ish,iZ);
                IF( ekin > Uj & (Uj > te(medium) | Uj > ap(medium)) ) [
                    jj = ifirst + ish - 1;
                    i = eii_a(jj)*elke + eii_b(jj) + (jj-1)*$N_EII_BINS;
                    sig_j = eii_xsection_a(i)*elke + eii_xsection_b(i);
                    sig_j = sig_j*pz(medium,iele)*eii_cons(medium);
                    rsh = rsh - sig_j;
                    IF( rsh < 0 ) [
                        $AUSCALL($EIIB);
                        call eii_sample(ish,iZ,Uj);
                        $AUSCALL($EIIA);
                        return;
                    ]
                ]
            ]
        ]
    ]
]
IF( ekin <= 2*te(medium) ) return;
T0=EKIN/RM;
E0=T0+1.0;
EXTRAE = EIE - THMOLL(MEDIUM);
E02=E0*E0;
"BETAI2=E02/(E02-1.0); " "BLIF 96/2/1 -- not needed for Moller fix-up"
EP0=TE(MEDIUM)/EKIN;
"G1=(1.-2.*EP0)*BETAI2;" "BLIF 96/2/1 -- not needed for Moller fix-up"
G2=T0*T0/E02;
G3=(2.*T0+1.)/E02;
"   H.H.NAGEL HAS CONSTRUCTED A FACTORIZATION OF THE FREQUENCY"
"   DISTRIBUTION FUNCTION FOR THE MOLLER DIFFERENTIAL CROSS"
"   SECTION USED AS SUGGESTED BY BUTCHER AND MESSEL."
"   (H.H.NAGEL, OP.CIT., P. 53-55)                                 "
"   HOWEVER, A MUCH SIMPLER SAMPLING METHOD WHICH DOES NOT BECOME  "
"   VERY INEFFICIENT NEAR THMOLL IS THE FOLLOWING. . .             "
"   LET BR=EKS/EKIN,  WHERE EKS IS KINETIC ENERGY TRANSFERED TO THE"
"   SECONDARY ELECTRON AND EKIN IS THE INCIDENT KINETIC ENERGY.    "

"   MODIFIED (7 FEB 1974) TO USE THE TRUE MOLLER CROSS SECTION."
"   THAT IS, INSTEAD OF THE E+ E- AVERAGE GIVEN IN THE ROSSI"
"   FORMULA USED BY NAGEL.  THE SAMPLING SCHEME IS THAT"
"   USED BY MESSEL AND CRAWFORD (EPSDF 1970 P.13)"
"   FIRST SAMPLE (1/BR**2) OVER (TE/EKIN,1/2) . . .            "

GMAX=(1.+1.25*G2); "BLIF 96/2/1 -- Moller fix-up"
LOOP[" TO RETRY IF REJECTED"
$RANDOMSET RNNO27;
BR = TE(MEDIUM)/(EKIN-EXTRAE*RNNO27);

"   USE MESSEL AND CRAWFORDS REJECTION FUNCTION."
R=BR/(1.-BR);
$RANDOMSET RNNO28;
REJF4="G1*"(1.+G2*BR*BR+R*(R-G3)); "BLIF 96/2/1 -- Moller fix-up"
RNNO28=GMAX*RNNO28; "BLIF 96/2/1 -- Moller fix-up"
]UNTIL RNNO28.LE.REJF4; "TRY UNTIL ACCEPTED. END REJECTION LOOP"

PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY ELECTRON #2"
PESE1=PEIE-PEKSE2; "PRECISE ENERGY OF SECONDARY ELECTRON #1"
PESE2=PEKSE2+PRM; "PRECISE ENERGY OF SECONDARY ELECTRON #2"
ESE1=PESE1; "ENERGY OF SECONDARY ELECTRON 1"
ESE2=PESE2; "ENERGY OF SECONDARY ELECTRON 2"
E(NP)=PESE1;
$CHECK-STACK(np+1,'MOLLER');
E(NP+1)=PESE2;
"   SINCE BR.LE.0.5, E(NP+1) MUST BE .LE. E(NP). "
"   MOLLER ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS            "

" One possible way of dealing with double counting of angular      "
" deflections in inelastic scattering would be to                  "
" not deflect the 'old' electron as these deflections are          "
" already taken into account in the multiple elastic scattering    "
" This approach has the disadvantage of loosing correlations       "
" between big energy losses and strong angular deflections         "
" The advantage of such an approach is its simplicity.             "
" If spin effects for multiple elastic scattering are turned on,   "
" the double counting is taken into account by the appropriate     "
" modification of the scattering power (which depends on AE)       "
"                                                                  "
"                                                                  "
" IK, June 1999                                                    "

H1=(PEIE+PRM)/PEKIN;
"   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON                     "
DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);
SINTHE=DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);

"sinthe = 0; costhe = 1; <- this will turn off the Moller ang. deflections"

CALL UPHI(2,1);

"   RELATED CHANGE AND (X,Y,Z) SETUP FOR 'NEW' ELECTRON            "
NP=NP+1;
IQ(NP)=-1;
DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
SINTHE=-DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);
CALL UPHI(3,2);
RETURN;
"END OF SUBROUTINE MOLLER"  END;

%E

subroutine mscati;
"**********************************************************************"

" Subroutine to read the pre-calculated q^(2+)-surface, prepare data
" required by the mscat and msdist subroutines, initialize spin effect
" corrections
"
" I.Kawrakow, NRC
"**********************************************************************"

implicit none;

$REAL ededx,ei,eil,eip1,eip1l,si,sip1,eke,elke,aux,ecutmn,tstbm,tstbmn;
$REAL p2,beta2,dedx0,ekef,elkef,estepx,ektmp,elktmp,chi_a2;
$INTEGER
    i,leil,leip1l,neke,lelke,lelkef,lelktmp;
$LOGICAL  ise_monoton, isp_monoton;

$declare_write_buffer;

"cross section per energy loss"
$REAL sigee,sigep,sig,sige_old,sigp_old;

"entry mscat variables
"======================

$COMIN-MSCATI;

" moved the following from prestaII_inputs, "
" if transport_algorithm = presta-I, exact_bca = .false. and
" skin_depth_for_bca <= 1  ==> calculate default presta-I tmin for bca"

IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
ELSE                    [ exact_bca = .false.; ]
IF( estepe <= 0 | estepe >= 1) [ estepe = $MAX-ELOSS; ]
IF( ximax <= 0  | ximax >= 1 ) [
    IF( exact_bca ) [ ximax = $EXACT-BCA-XIMAX;   ]
    ELSE            [ ximax = $INEXACT-BCA-XIMAX; ]
]
IF (transport_algorithm ~= $PRESTA-II &
    transport_algorithm ~= $PRESTA--I &
    transport_algorithm ~= $VMC ) [transport_algorithm = $PRESTA-II;]
IF( skindepth_for_bca <= 1e-4 ) [
    "IF( transport_algorithm = $PRESTA--I & ~exact_bca ) ["
    IF( ~exact_bca ) [
        $egs_info(*,' old PRESTA calculates default min. step-size for BCA: ');
        $set_ecutmn;
        $egs_info(*,'     minimum ECUT found: ',ecutmn);
        tstbmn = 1e30;
        DO medium = 1,nmed [
            tstbm = (ecutmn-prm)*(ecutmn+prm)/ecutmn**2;
            tstbm = blcc(medium)*tstbm*(ecutmn/xcc(medium))**2;
            aux = Log(tstbm);
            IF( aux > 300 ) $egs_info(*,'aux > 300 ? ',aux);
            tstbm = Log(tstbm/aux);
            "Changed the following to the above so that the Intel compiler"
            " does not vectorize the loop with -xK. Vectorizing this loop"
            " on an Athlon CPU results in segmentation fault."
            " IK, Jan 29 2004."
            "tstbm = Log(tstbm/Log(tstbm));"
            tstbmn = Min(tstbmn,tstbm);
        ]
        $egs_info(*,'     default BLCMIN is: ',tstbmn);
        skindepth_for_bca = Exp(tstbmn);
        $egs_info(*,'     this corresponds to ',skindepth_for_bca,
         ' elastic MFPs ');
    ]
    ELSE [ skindepth_for_bca = $SKIN-DEPTH-FOR-BCA; ]
]

" read MS data for screened Rutherford scattering "
call init_ms_SR;

DO medium = 1,nmed
[
    "Absorb Euler constant into the multiple scattering parameter
    "1.16699413758864573 = Exp[2 EulerGamma - 1]
    blcc(medium) = 1.16699413758864573*blcc(medium);

    "Take its square as this is employed throughout
    xcc(medium)  = xcc(medium)**2;
]

IF( spin_effects ) [ call init_spin; ]

"Determine maximum cross section per energy loss for every medium
$egs_info(*,' ');
esige_max = 0;
psige_max = 0;
DO medium = 1,nmed
[

  sigee = 1E-15; sigep = 1E-15;
  neke = meke(medium); "Number of elements in storage array
  ise_monoton = .true.; isp_monoton = .true.;
  sige_old = -1; sigp_old = -1;
  DO i = 1,neke
  [

    ei   = exp((float(i) - eke0(medium))/eke1(medium));
    eil  = log(ei);
    leil = i;
    $EVALUATE ededx USING ededx(eil);
    $EVALUATE sig USING esig(eil);
    sig = sig/ededx;
    IF (sig > sigee) sigee = sig;
    IF( sig < sige_old ) ise_monoton = .false.;
    sige_old = sig;
    $EVALUATE ededx USING pdedx(eil);
    $EVALUATE sig USING psig(eil);
    sig = sig/ededx;
    IF (sig > sigep) sigep = sig;
    IF( sig < sigp_old ) isp_monoton = .false.;
    sigp_old = sig;

  ]
  $egs_info(*,' Medium ',medium,' sige = ',sigee,sigep,' monotone = ',
          ise_monoton,isp_monoton);
  sig_ismonotone(0,medium) = ise_monoton;
  sig_ismonotone(1,medium) = isp_monoton;
  esig_e(medium) = sigee; psig_e(medium) = sigep;
  IF( sigee > esige_max ) esige_max = sigee;
  IF( sigep > psige_max ) psige_max = sigep;
]
$egs_info(*,' ');

$egs_info(*,' Initializing tmxs for estepe = ',estepe,' and ximax = ',ximax);
$egs_info(*,' ');

"Determine upper limit in step size for multiple scattering
DO medium = 1,nmed
[
    " Calculate range array first "
    " =========================== "
    ei   = exp((1 - eke0(medium))/eke1(medium)); "Energy of first table entry
    eil  = log(ei);
    leil = 1;
    E_array(1,medium) = ei;
    expeke1(medium) = Exp(1./eke1(medium))-1;
    range_ep(0,1,medium) = 0; range_ep(1,1,medium) = 0;
    neke = meke(medium); "Number of elements in storage array
    DO i = 1,neke - 1
    [
        eip1   = exp((float(i + 1) - eke0(medium))/eke1(medium)); "Energy at i+1
        E_array(i+1,medium) = eip1;
        " Calculate range. The following expressions result from the"
        " logarithmic interpolation for the (restricted) stopping power "
        " and a power power series expansion of the integral "
        eke = 0.5*(eip1+ei); elke = Log(eke);
        $SET INTERVAL elke,eke;
        $EVALUATE ededx USING pdedx(elke);
        aux = pdedx1(i,medium)/ededx;
        range_ep(1,i+1,medium) = range_ep(1,i,medium) +
          (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
        $EVALUATE ededx USING ededx(elke);
        aux = ededx1(i,medium)/ededx;
        range_ep(0,i+1,medium) = range_ep(0,i,medium) +
          (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
        ei = eip1;
    ]

    " Now tmxs "
    " ======== "

    eil = (1 - eke0(medium))/eke1(medium);
    ei  = Exp(eil); leil = 1; " As in $SET INTERVAL but avoids roundoff
    p2  = ei*(ei+2*rm); beta2 = p2/(p2+rm*rm);
    chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
    $EVALUATE dedx0 USING ededx(eil);
    estepx = 2*p2*beta2*dedx0/ei/Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
    estepx = estepx*ximax;
    IF( estepx > estepe ) [ estepx = estepe; ]
    si = estepx*ei/dedx0;

    DO i = 1,neke - 1
    [

        elke = (i + 1 - eke0(medium))/eke1(medium);
        eke  = Exp(elke); lelke = i+1;
        p2  = eke*(eke+2*rm); beta2 = p2/(p2+rm*rm);
        chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
        $EVALUATE ededx USING ededx(elke);
        estepx = 2*p2*beta2*ededx/eke/
                  Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
        estepx = estepx*ximax;
        IF( estepx > estepe ) [ estepx = estepe; ]
        ekef = (1-estepx)*eke;
        IF( ekef <= E_array(1,medium) )
        [
            sip1 = (E_array(1,medium) - ekef)/dedx0;
            ekef = E_array(1,medium);
            elkef = (1 - eke0(medium))/eke1(medium);
            lelkef = 1;
        ]
        ELSE
        [
            elkef = Log(ekef);
            $SET INTERVAL elkef,eke;
            leip1l = lelkef + 1;
            eip1l  = (leip1l - eke0(medium))/eke1(medium);
            eip1   = E_array(leip1l,medium);
            aux    = (eip1 - ekef)/eip1;
            elktmp = 0.5*(elkef+eip1l+0.25*aux*aux*(1+aux*(1+0.875*aux)));
            ektmp  = 0.5*(ekef+eip1);
            lelktmp = lelkef;
            $EVALUATE ededx USING ededx(elktmp);
            aux = ededx1(lelktmp,medium)/ededx;
            sip1 = (eip1 - ekef)/ededx*(
                     1+aux*(1+2*aux)*((eip1-ekef)/ektmp)**2/24);
        ]
        sip1 = sip1 + range_ep(0,lelke,medium) - range_ep(0,lelkef+1,medium);

        "Now solve these equations
        "  si   = tmxs1 * eil   + tmxs0
        "  sip1 = tmxs1 * eip1l + tmxs0

        tmxs1(i,medium) = (sip1 - si)*eke1(medium);
        tmxs0(i,medium) = sip1 - tmxs1(i,medium)*elke;

        si  = sip1;
    ]

    "Now pick up last table entry which applies only to last energy
    tmxs0(neke,medium) = tmxs0(neke - 1,medium);
    tmxs1(neke,medium) = tmxs1(neke - 1,medium);

]

return;
end;

%E
; "buffer flush

subroutine mscat(lambda,chia2,q1,elke,beta2,qel,medium,
                 spin_effects,find_index,spin_index,
                 cost,sint);
"========================================================================="
"                                                                         "
" Subroutine to sample multiple electron scattering angles from the exact "
" distribution resulting from elastic scattering described by the screened"
" Rutherford cross section (spin_effects=.false.) or by the screened      "
" Rutherford cross times Mott correction (spin_effects=.true.)            "
"                                                                         "
" I.Kawrakow, NRC                                                         "
"========================================================================="

implicit none;

$REAL    lambda, chia2,q1,elke,beta2,cost,sint;
$INTEGER qel,medium;
$LOGICAL spin_effects,find_index,spin_index;

COMIN/MS-Data,RANDOM,EGS-IO/;

$declare_write_buffer;

$REAL    sprob,explambda,wsum,wprob,xi,rejf,spin_rejection,
         cosz,sinz,phi,omega2,llmbda,ai,aj,ak,a,u,du,x1,rnno;
$INTEGER icount,i,j,k;

save     i,j,omega2;

$TURN_OFF_SCATTERING;
" default of above is ';' See definition in egsnrc.macros for example"
" of how to turn off all scattering    DR April 2012"

IF(lambda <= 13.8)
[
    "Test only for lambda = 13.8 implies a 1e-6 error, ie large-lambda cases
    "that contribute to the forward no-scattering amplitude.
    $RANDOMSET sprob;
    explambda = Exp(-lambda);
    IF (sprob < explambda)
    [
        "It was a no scattering event
        cost = 1; sint = 0;
        return;
    ]
    wsum = (1+lambda)*explambda;
    IF ( sprob < wsum )
    [
      :RETRY_1:;
      $RANDOMSET xi;
      xi  = 2*chia2*xi/(1 - xi + chia2);
      cost = 1 - xi;
      IF( spin_effects ) [
          rejf = spin_rejection(qel,medium,elke,beta2,q1,cost,
                                spin_index,.false.);
          $RANDOMSET rnno;
          IF( rnno > rejf ) [ GOTO :RETRY_1:; ]
      ]
      sint = sqrt(xi*(2 - xi));
      return;
    ]
    IF ( lambda <= 1 )      "IK introduced this portion because with
                            "alternative BCAs mscat can be called with
                            " lambda < 1 where there are no pre-calculated
                            "data
    [
        wprob = explambda; wsum = explambda;
        cost = 1; sint = 0;
        icount = 0;
        LOOP
        [
            icount = icount + 1;
            IF (icount > 20) EXIT; "To avoid underflow if sprob very close to 1
            wprob = wprob*lambda/icount;
            wsum = wsum + wprob;
            :RETRY_2:;
            $RANDOMSET xi;
            xi  = 2*chia2*xi/(1 - xi + chia2);
            cosz = 1 - xi;
            IF( spin_effects ) [
                rejf = spin_rejection(qel,medium,elke,beta2,q1,cosz,
                                      spin_index,.false.);
                $RANDOMSET rnno;
                IF( rnno > rejf ) [ GOTO :RETRY_2:; ]
            ]
            sinz = xi*(2 - xi);
            IF ( sinz > 1.e-20 )
            [
               sinz = Sqrt(sinz);
               $RANDOMSET xi;
               phi = xi*6.2831853;
               cost = cost*cosz - sint*sinz*Cos(phi);
               sint = Sqrt(Max(0.0,(1-cost)*(1+cost)));
             ]
        ] UNTIL ( wsum > sprob);
        return;
    ]
]

"It was a multiple scattering event
"Sample the angle from the q^(2+) surface

IF (lambda <= $LAMBMAX_MS ) [

    IF (find_index)
    [
        llmbda = log(lambda);

        " First fix lambda bin
        ai = llmbda*dllambi; i = ai; ai = ai - i;
        $RANDOMSET xi;
        IF(xi < ai) i = i + 1;

        " fix now q1 bin
        IF( q1 < $QMIN_MS ) [ j = 0; ]
        ELSE IF( q1 < $QMAX_MS ) [
            aj = q1*dqmsi; j = aj; aj = aj - j;
            $RANDOMSET xi;
            IF( xi < aj ) j = j + 1;
        ]
        ELSE [ j = $MAXQ_MS; ]

        " Calculate omega2 "
        IF(llmbda < 2.2299) [
          omega2 = chia2*(lambda + 4)*(1.347006 + llmbda*(
            0.209364 - llmbda*(0.45525 - llmbda*(0.50142 - 0.081234*llmbda))));
        ]
        ELSE [
          omega2 = chia2*(lambda + 4)*(-2.77164 + llmbda*(2.94874 -
                   llmbda*(0.1535754 - llmbda*0.00552888)));
        ]

        find_index = .false.;
    ]
    "If this is a re-iteration with the same lambda, then omega2, i, and k
    "should have been defined in the previous iteration

:RETRY_3:;
    $RANDOMSET xi;
    ak = xi*$MAXU_MS; k = ak; ak = ak - k;
    IF( ak > wms_array(i,j,k) ) k = ims_array(i,j,k);
    a = fms_array(i,j,k); u = ums_array(i,j,k);
    du = ums_array(i,j,k+1) - u;
    $RANDOMSET xi;
    IF( abs(a) < 0.2 ) [
        x1 = 0.5*(1-xi)*a;
        u  = u + xi*du*(1+x1*(1-xi*a));
    ]
    ELSE [ u = u - du/a*(1-Sqrt(1+xi*a*(2+a))); ]

    xi      = omega2*u/(1 + 0.5*omega2 - u);
    IF( xi > 1.99999 ) [ xi = 1.99999; ]
      "some machines have trouble when xi is very close to 2 in subsequent"
      "calculations. IK, April 25 2002"
    cost    = 1 - xi;
    IF( spin_effects ) [
        rejf=spin_rejection(qel,medium,elke,beta2,q1,cost,spin_index,.false.);
        $RANDOMSET rnno;
        IF( rnno > rejf ) [ GOTO :RETRY_3:; ]
    ]
    sint    = sqrt(xi*(2-xi));
    return;
]

"This is an error condition

$egs_info(*,' ');
$egs_info(*,' *************************************');
$egs_info(*,' Maximum step size in mscat exceeded! ');
$egs_info(*,' Maximum step size initialized: 100000');
$egs_info(*,' Present lambda: ',lambda);
$egs_info(*,' chia2: ',chia2);
$egs_info(*,' q1 elke beta2: ',q1,elke,beta2);
$egs_info(*,' medium: ',medium);
$egs_fatal(*,' Stopping execution');

end;

%E
; "buffer flush

$REAL function spin_rejection(qel,medium,elke,beta2,q1,cost,
                              spin_index,is_single);
"============================================================================="
"                                                                             "
" Determines the rejection function due to spin effects for                   "
"   charge        qel (=0 for e-, =1 for e+)                                  "
"   log(energy)   elke                                                        "
"   speed         beta2                                                       "
"   1. MS moment  q1                                                          "
"   cos(theta)    cost                                                        "
"                                                                             "
" I.Kawrakow, NRC                                                             "
"============================================================================="

implicit none;

$REAL      elke,beta2,q1,cost;
$INTEGER   qel,medium;
$LOGICAL   spin_index,is_single;
$declare_max_medium;
COMIN/Spin-Data,RANDOM/;

$REAL      rnno,ai,qq1,aj,xi,ak;
$INTEGER   i,j,k;

save       i,j;

IF( spin_index ) [  "Determine the energy and q1 index
    spin_index = .false.;
    IF( beta2 >= b2spin_min ) [
        ai = (beta2 - b2spin_min)*dbeta2i;
        i = ai; ai = ai - i; i = i + $MAXE_SPIN + 1;
    ]
    ELSE IF( elke > espml ) [
        ai = (elke - espml)*dleneri; i = ai; ai = ai - i;
    ]
    ELSE [ i = 0; ai = -1; ]
    $RANDOMSET rnno;
    IF( rnno < ai ) i = i + 1;
    IF( is_single ) [ j = 0; ]
    ELSE [
        qq1 = 2*q1; qq1 = qq1/(1 + qq1);
        aj = qq1*dqq1i; j = aj;
        IF( j >= $MAXQ_SPIN ) [ j = $MAXQ_SPIN; ]
        ELSE [  aj = aj - j;
                $RANDOMSET rnno;
                IF( rnno < aj ) j = j + 1;
        ]
    ]
]
xi = Sqrt(0.5*(1-cost));
ak = xi*$MAXU_SPIN; k = ak; ak = ak - k;
spin_rejection = (1-ak)*spin_rej(medium,qel,i,j,k) +
                     ak*spin_rej(medium,qel,i,j,k+1);
return;
end;

%E
; "buffer flush


subroutine sscat(chia2,elke,beta2,qel,medium,spin_effects,cost,sint);
"============================================================================"
"                                                                            "
" single elastic scattering                                                  "
"                                                                            "
" I.Kawrakow, NRC                                                            "
"============================================================================"

implicit none;

$REAL    chia2,elke,beta2,cost,sint;
$INTEGER qel,medium;
$LOGICAL spin_effects;

COMIN/RANDOM/;

$REAL    xi,rnno,rejf,spin_rejection,qzero;
$LOGICAL spin_index;

$TURN_OFF_SCATTERING;
" default of above is ';' See definition in egsnrc.macros for example"
" of how to turn off all scattering    DR April 2012"

spin_index = .true.;
:RETRY-SPIN:;
$RANDOMSET xi;
xi  = 2*chia2*xi/(1 - xi + chia2);
cost = 1 - xi;
IF( spin_effects ) [
    qzero=0;
    rejf = spin_rejection(qel,medium,elke,beta2,qzero,cost,spin_index,.true.);
    $RANDOMSET rnno;
    IF( rnno > rejf ) goto :RETRY-SPIN:;
]
sint = sqrt(xi*(2 - xi));
return;
end;

%E
; "buffer flush

subroutine init_ms_SR;
"================================================================"
"                                                                "
" Reads in pre-calculated screened Rutherford multiple elastic   "
" scattering data                                                "
"                                                                "
" I. Kawrakow, NRC                                               "
"================================================================"

implicit none;

COMIN/MS-Data,EGS-IO/;
$declare_write_buffer;

integer*4 i,j,k;

$egs_info('(/a,$)','Reading screened Rutherford MS data ............... ');
rewind($MSCAT-DATAFILE);
DO i=0,$MAXL_MS [
    DO j=0,$MAXQ_MS [
        read($MSCAT-DATAFILE,*) (ums_array(i,j,k),k=0,$MAXU_MS);
        read($MSCAT-DATAFILE,*) (fms_array(i,j,k),k=0,$MAXU_MS);
        read($MSCAT-DATAFILE,*) (wms_array(i,j,k),k=0,$MAXU_MS-1);
        read($MSCAT-DATAFILE,*) (ims_array(i,j,k),k=0,$MAXU_MS-1);
        DO k=0,$MAXU_MS-1 [
           fms_array(i,j,k) = fms_array(i,j,k+1)/fms_array(i,j,k)-1;
           ims_array(i,j,k) = ims_array(i,j,k)-1;
        ]
        fms_array(i,j,$MAXU_MS)=fms_array(i,j,$MAXU_MS-1);
    ]
]
$egs_info('(a)',' done ');

llammin = Log($LAMBMIN_MS); llammax = Log($LAMBMAX_MS);
dllamb  = (llammax-llammin)/$MAXL_MS; dllambi = 1./dllamb;
dqms    = $QMAX_MS/$MAXQ_MS; dqmsi = 1./dqms;

return;
end;

%E
; "buffer flush

subroutine init_spin;
"======================================================================="
"                                                                       "
" Reads in spin rejection data for multiple elastic scattering and      "
" initializes interpolation arrays for the screening parameter,         "
" elastic cross section, first and second MS moments                    "
"                                                                       "
" I. Kawrakow, NRC                                                      "
"======================================================================="

implicit none;
$declare_max_medium;
COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
                            "BREMPR is needed for the elemental composition"

$REAL         eta_array(0:1,$0-MAXE_SPI1),
              c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
              earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
              sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
              tau,tauc,beta2,eta,gamma,fmax,
              eil,e,si1e,si2e,si1p,si2p,aae,etap,
              elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
              af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
              df($0-MAXE_SPI1),spline,dloge,eloge;

real*4        dum1,dum2,dum3,aux_o; " These must be 32 bit floats!!!!!"

real*4        fmax_array(0:$MAXQ_SPIN);
integer*2     i2_array(512),ii2;

$INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
              ndata,leil,length,ii4,irec;

character     spin_file*256;
character*6   string;
integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
                       "do not have lnblnk, we supply lnblnk1 in this file

$INTEGER      spin_unit, rec_length, want_spin_unit;
integer       egs_get_unit;
character     data_version*32,endianess*4;
$LOGICAL      swap;

$declare_write_buffer;

$REAL        fine,TF_constant;
parameter    (fine=137.03604, TF_constant=0.88534138);

" stupid GNU compiler complains that the arguments to egs_swap_ are of "
" one kind here, but of some other kind there => need character arrays and "
" equivalence statements"
real*4        tmp_4;
character     c_2(2), c_4(4);
equivalence   (ii2,c_2), (tmp_4,c_4);

" First construct the path to the spin dbase directory "
$set_string(spin_file,' ');
spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms.data';
want_spin_unit = 61;
spin_unit = egs_get_unit(want_spin_unit);
IF( spin_unit < 1 ) [
    $egs_fatal(*,'init_spin: failed to get a free fortran unit');
]
rec_length = 276*$RECL-FACTOR;
open(spin_unit,file=spin_file,form='unformatted',access='direct',
     status='old',recl=rec_length,err=:spin-open-error:);
read(spin_unit,rec=1,err=:spin-read-error:) data_version,endianess,
                      espin_min,espin_max,b2spin_min,b2spin_max;
swap = endianess.ne.$BYTE_ORDER;
IF( swap ) [
    tmp_4 = espin_min; call egs_swap_4(c_4); espin_min = tmp_4;
    tmp_4 = espin_max; call egs_swap_4(c_4); espin_max = tmp_4;
    tmp_4 = b2spin_min; call egs_swap_4(c_4); b2spin_min = tmp_4;
    tmp_4 = b2spin_max; call egs_swap_4(c_4); b2spin_max = tmp_4;
]
$egs_info('(//a,a)','Reading spin data base from ',$cstring(spin_file));
$egs_info('(a)',data_version);
$egs_info('(a,a,a)','Data generated on a machine with ',endianess,
        ' endianess');
$egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
IF( swap ) $egs_info('(a)','=> will need to do byte swaping');
$egs_info('(a,2f9.2,2f9.5,//)','Ranges: ',espin_min,espin_max,
        b2spin_min,b2spin_max);
n_ener = $MAXE_SPIN; n_q = $MAXQ_SPIN; n_point = $MAXU_SPIN;
dloge = log(espin_max/espin_min)/n_ener;
eloge = log(espin_min); earray(0) = espin_min;
$FOOL-INTEL-OPTIMIZER(25) 'Energy grid:';
DO i=1,n_ener [
    eloge = eloge + dloge; earray(i) = exp(eloge);
    $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
]
dbeta2 = (b2spin_max - b2spin_min)/n_ener;
beta2 = b2spin_min; earray(n_ener+1) = espin_max;
DO i=n_ener+2,2*n_ener+1 [
    beta2 = beta2 + dbeta2;
    IF( beta2 < 0.999 ) [ earray(i) = prm*1000.0*(1/sqrt(1-beta2)-1); ]
    ELSE [ earray(i) = 50585.1; ]
    $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
]

" Convert to MeV and set interpolation interavals"
/*
 * IK: Moved here Feb 4 2004.
 *     Bug found and reported by Dr Helmut Schlattl.
 */
espin_min = espin_min/1000; espin_max = espin_max/1000;
dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
espml = Log(espin_min);
dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;

DO medium = 1,NMED [
    $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
            DO j=0,$MAXQ_SPIN [
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = 0;
                ]
            ]
        ]
    ]
    /sum_Z2,sum_A,sum_pz,sum_Z/=0;
    DO i_ele=1,NNE(medium) [
        Z = ZELEM(medium,i_ele);
        iZ = int(Z+0.5);
        $FOOL-INTEL-OPTIMIZER(25) ' Z = ',iZ;
        tmp = PZ(medium,i_ele)*Z*(Z+1);
              "For now, we take into account the contribution of atomic"
              "electrons to elastic scattering by replacing Z**2 with  "
              "Z*(Z+1). The part of the scattering power that is taken "
              "into account by discrete Moller/Bhabha events is        "
              "substracted below => bc is energy dependent. We will    "
              "worry about better approaches in the future (a realistic"
              "inelastic scattering model is needed first)             "
        sum_Z2 = sum_Z2 + tmp;
        sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
        sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
        sum_pz = sum_pz + PZ(medium,i_ele);
        Z23    = Z**0.6666667;
        DO iq=0,1 [
            DO i=0,$MAXE_SPI1 [
                irec = 1 + (iz-1)*4*(n_ener+1) + 2*iq*(n_ener+1) + i+1;
                $FOOL-INTEL-OPTIMIZER(25) '**** energy ',i,earray(i),irec;
                read(spin_unit,rec=irec,err=:spin-read-error:)
                  dum1,dum2,dum3,aux_o,fmax_array,i2_array;
                IF( swap ) [
                  tmp_4 = dum1; call egs_swap_4(c_4); dum1 = tmp_4;
                  tmp_4 = dum2; call egs_swap_4(c_4); dum2 = tmp_4;
                  tmp_4 = dum3; call egs_swap_4(c_4); dum3 = tmp_4;
                  tmp_4 = aux_o; call egs_swap_4(c_4); aux_o = tmp_4;
                ]
                eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
                tau = earray(i)/prm*0.001;  "energy in the file is in keV"
                beta2 = tau*(tau+2)/(tau+1)**2;
                eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
                c_array(iq,i)=c_array(iq,i)+
                  tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
                g_array(iq,i)=g_array(iq,i)+tmp*dum2;
                DO j=0,$MAXQ_SPIN [
                    tmp_4 = fmax_array(j);
                    IF( swap ) call egs_swap_4(c_4);
                    DO k=0,$MAXU_SPIN [
                        ii2 = i2_array((n_point+1)*j + k+1);
                        IF( swap ) call egs_swap_2(c_2);
                        ii4 = ii2;
                        IF( ii4 < 0 ) ii4 = ii4 + 65536;
                        dum1 = ii4; dum1 = dum1*tmp_4/65535;
                        spin_rej(medium,iq,i,j,k) =
                          spin_rej(medium,iq,i,j,k) + tmp*dum1;
                    ]
                ]
            ]
        ]
    ]

    " spin_rej will be used as a rejection function in MS sampling, "
    " so scale maximum to unity"
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            DO j=0,$MAXQ_SPIN [
                fmax = 0;
                DO k=0,$MAXU_SPIN [
                    IF( spin_rej(medium,iq,i,j,k) > fmax )
                       [ fmax = spin_rej(medium,iq,i,j,k); ]
                ]
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
                ]
            ]
        ]
    ]

    " Process eta_array, c_array and g_array to their final form "
    $FOOL-INTEL-OPTIMIZER(25) 'Spin corrections as read in from file';
    DO i=0,$MAXE_SPI1 [
        tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
        DO iq=0,1 [
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
            eta = aux_o/4/tau/(tau+2);
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
                      (Log(1+1/eta)*(1+eta)-1);
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
        ]
        $FOOL-INTEL-OPTIMIZER(25) i,earray(i),eta_array(0,i),eta_array(1,i),
          c_array(0,i),c_array(1,i),g_array(0,i),g_array(1,i);
    ]

    " Prepare interpolation table for the screening parameter "
    eil = (1 - eke0(medium))/eke1(medium);
    e = Exp(eil);
    IF( e <= espin_min ) [
        si1e = eta_array(0,0); si1p = eta_array(1,0);
    ]
    ELSE [
        IF( e <= espin_max ) [
            aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
        ]
        ELSE [
            tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
            aae = (beta2 - b2spin_min)*dbeta2i;
            je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
        ]
        si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
        si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
    ]
    neke = meke(medium);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for eta correction';
    DO i = 1,neke - 1 [
        eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
        IF( e <= espin_min ) [
            si2e = eta_array(0,0); si2p = eta_array(1,0);
        ]
        ELSE [
            IF( e <= espin_max ) [
                aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
            ]
            ELSE [
                tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
                aae = (beta2 - b2spin_min)*dbeta2i;
                je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
            ]
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
        ]
        etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
        etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
        etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) i,e,si2e,si2p,etae_ms1(i,medium),
         etae_ms0(i,medium),etap_ms1(i,medium),etap_ms0(i,medium);
        si1e = si2e; si1p = si2p;
    ]
    etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
    etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
    etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
    etap_ms0(neke,medium) = etap_ms0(neke-1,medium);

    "Prepare correction to the first MS moment due to spin effects"
    "first electrons"
    $FOOL-INTEL-OPTIMIZER(25) 'elarray:';
    DO i=0,$MAXE_SPIN [
        elarray(i) = Log(earray(i)/1000);
        farray(i) = c_array(0,i);
        $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i);
    ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
        elarray(i) = Log(earray(i+1)/1000);
        farray(i) = c_array(0,i+1);
        $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i+1);
    ]
    ndata = $MAXE_SPI1+1;
    IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
    ELSE [ elarray(ndata-1) = Log(1e5); ]
    farray(ndata-1) = 1;
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e-)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1ce_ms1(i,medium),
          q1ce_ms0(i,medium);
        si1e = si2e;
    ]
    q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
    q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
    "now positrons"
    $FOOL-INTEL-OPTIMIZER(25) 'Postrons:';
    DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e+)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1cp_ms1(i,medium),
          q1cp_ms0(i,medium);
        si1e = si2e;
    ]
    q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
    q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);

    "prepare interpolation table for the second MS moment correction"
    "e-"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e-)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2ce_ms1(i,medium),
          q2ce_ms0(i,medium);
        si1e = si2e;
    ]
    q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
    q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
    "e+"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e+)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2cp_ms1(i,medium),
          q2cp_ms0(i,medium);
        si1e = si2e;
    ]
    q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
    q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);

    "Now substract scattering power that is already taken into account in"
    "discrete Moller/Bhabha events"
    tauc = te(medium)/prm;
    si1e = 1;
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        e = Exp(eil); leil=i+1; tau=e/prm;
        IF( tau > 2*tauc ) [
            $EVALUATE sig USING esig(eil);
            $EVALUATE dedx USING ededx(eil);
            sig = sig/dedx;
            IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
                $EVALUATE etap USING etae_ms(eil);
                eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
                g_r = (1+2*eta)*Log(1+1/eta)-2;
                g_m = Log(0.5*tau/tauc)+
                 (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
                 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
                    Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
                 0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
                IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
                si2e = 1 - g_m*sum_Z/sum_Z2;
            ] ELSE [ si2e = 1; ]
        ] ELSE [ si2e = 1; ]
        blcce1(i,medium) = (si2e - si1e)*eke1(medium);
        blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
        si1e = si2e;
    ]
    blcce1(neke,medium) = blcce1(neke-1,medium);
    blcce0(neke,medium) = blcce0(neke-1,medium);

    "We will not bother to do the same for positrons at this time"

    $egs_info('(a)',' done');
]
close(spin_unit);
return;

:spin-open-error:
$egs_fatal('(a,a)','Failed to open spin data file ',$cstring(spin_file));

:spin-read-error:
$egs_fatal(*,'Error while reading spin data file for element',iZ);

return; end;
%E

subroutine init_spin_old;
"======================================================================="
"                                                                       "
" Reads in spin rejection data for multiple elastic scattering and      "
" initializes interpolation arrays for the screening parameter,         "
" elastic cross section, first and second MS moments                    "
"                                                                       "
" This version uses the old EGSnrc ASCII spin data format.              "
" If the installation failed to figure out the byte order of your       "
" machine, rename this subroutine to init_spin, the current init_spin   "
" to init_spin_new (or whatever) and download the old spinms data       "
" directory.
"                                                                       "
" I. Kawrakow, NRC                                                      "
"======================================================================="

implicit none;
$declare_max_medium;
COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
                            "BREMPR is needed for the elemental composition"

$REAL         eta_array(0:1,$0-MAXE_SPI1),
              c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
              earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
              sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
              dum1,dum2,dum3,aux_o,tau,tauc,beta2,eta,gamma,fmax,
              eil,e,si1e,si2e,si1p,si2p,aae,etap,
              elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
              af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
              df($0-MAXE_SPI1),spline;

$INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
              ndata,leil,length,want_spin_unit,spin_unit,egs_get_unit;

character     spin_file*256;
character*6   string;
integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
                       "do not have lnblnk, we supply lnblnk1 in this file
$declare_write_buffer;

$REAL        fine,TF_constant;
parameter    (fine=137.03604, TF_constant=0.88534138);

" First construct the path to the spin dbase directory "
$set_string(spin_file,' ');
spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms' //
             $file_sep // 'z000';
length = lnblnk1(spin_file);

DO medium = 1,NMED [
    $egs_info('(a,i4,a,$)','  Initializing spin data for medium ',medium,
                          ' ..................... ');
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
            DO j=0,$MAXQ_SPIN [
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = 0;
                ]
            ]
        ]
    ]
    /sum_Z2,sum_A,sum_pz,sum_Z/=0;
    DO i_ele=1,NNE(medium) [
        Z = ZELEM(medium,i_ele);
        iZ = int(Z+0.5);
        tmp = PZ(medium,i_ele)*Z*(Z+1);
              "For now, we take into account the contribution of atomic"
              "electrons to elastic scattering by replacing Z**2 with  "
              "Z*(Z+1). The part of the scattering power that is taken "
              "into account by discrete Moller/Bhabha events is        "
              "substracted below => bc is energy dependent. We will    "
              "worry about better approaches in the future (a realistic"
              "inelastic scattering model is needed first)             "
        iii = iZ/100; spin_file(length-2:length-2) = char(iii+48);
        iiZ = iZ - iii*100;
        iii = iiZ/10; spin_file(length-1:length-1) = char(iii+48);
        iiZ = iiZ - 10*iii;
        spin_file(length:length) = char(iiZ+48);
        want_spin_unit = 61;
        spin_unit = egs_get_unit(want_spin_unit);
        IF( spin_unit < 1 ) [
            $egs_fatal(*,'init_spin: failed to get a free fortran unit');
        ]
        open(spin_unit,file=spin_file,status='old',err=:SPIN-DBASE-ERROR:);
        read(spin_unit,*) espin_min,espin_max,b2spin_min,b2spin_max;
        read(spin_unit,*) n_ener,n_q,n_point;
        IF( n_ener ~= $MAXE_SPIN | n_q ~= $MAXQ_SPIN | n_point ~= $MAXU_SPIN) [
            $egs_fatal(*,' Wrong spin file for Z = ',iZ);
        ]
        sum_Z2 = sum_Z2 + tmp;
        sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
        sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
        sum_pz = sum_pz + PZ(medium,i_ele);
        Z23    = Z**0.6666667;
        DO iq=0,1 [
            read(spin_unit,*); read(spin_unit,*);
            DO i=0,$MAXE_SPI1 [
                read(spin_unit,'(a,g14.6)') string,earray(i);
                read(spin_unit,*) dum1,dum2,dum3,aux_o;
                eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
                tau = earray(i)/prm*0.001;  "energy in the file is in keV"
                beta2 = tau*(tau+2)/(tau+1)**2;
                eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
                c_array(iq,i)=c_array(iq,i)+
                  tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
                g_array(iq,i)=g_array(iq,i)+tmp*dum2;
                DO j=0,$MAXQ_SPIN [
                    read(spin_unit,*) tmp_array;
                    DO k=0,$MAXU_SPIN [
                        spin_rej(medium,iq,i,j,k) =
                          spin_rej(medium,iq,i,j,k) + tmp*tmp_array(k);
                    ]
                ]
            ]
        ]
        close(spin_unit);
    ]

    " spin_rej will be used as a rejection function in MS sampling, "
    " so scale maximum to unity"
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            DO j=0,$MAXQ_SPIN [
                fmax = 0;
                DO k=0,$MAXU_SPIN [
                    IF( spin_rej(medium,iq,i,j,k) > fmax )
                       [ fmax = spin_rej(medium,iq,i,j,k); ]
                ]
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
                ]
            ]
        ]
    ]

    " Process eta_array, c_array and g_array to their final form "
    DO i=0,$MAXE_SPI1 [
        tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
        DO iq=0,1 [
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
            eta = aux_o/4/tau/(tau+2);
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
                      (Log(1+1/eta)*(1+eta)-1);
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
        ]
    ]

    " Convert to MeV and set interpolation interavals"
    espin_min = espin_min/1000; espin_max = espin_max/1000;
    dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
    espml = Log(espin_min);
    dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
    dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;

    " Prepare interpolation table for the screening parameter "
    eil = (1 - eke0(medium))/eke1(medium);
    e = Exp(eil);
    IF( e <= espin_min ) [
        si1e = eta_array(0,0); si1p = eta_array(1,0);
    ]
    ELSE [
        IF( e <= espin_max ) [
            aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
        ]
        ELSE [
            tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
            aae = (beta2 - b2spin_min)*dbeta2i;
            je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
        ]
        si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
        si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
    ]
    neke = meke(medium);
    DO i = 1,neke - 1 [
        eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
        IF( e <= espin_min ) [
            si2e = eta_array(0,0); si2p = eta_array(1,0);
        ]
        ELSE [
            IF( e <= espin_max ) [
                aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
            ]
            ELSE [
                tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
                aae = (beta2 - b2spin_min)*dbeta2i;
                je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
            ]
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
        ]
        etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
        etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
        etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
        si1e = si2e; si1p = si2p;
    ]
    etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
    etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
    etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
    etap_ms0(neke,medium) = etap_ms0(neke-1,medium);

    "Prepare correction to the first MS moment due to spin effects"
    "first electrons"
    DO i=0,$MAXE_SPIN [
        elarray(i) = Log(earray(i)/1000);
        farray(i) = c_array(0,i);
    ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
        elarray(i) = Log(earray(i+1)/1000);
        farray(i) = c_array(0,i+1);
    ]
    ndata = $MAXE_SPI1+1;
    IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
    ELSE [ elarray(ndata-1) = Log(1e5); ]
    farray(ndata-1) = 1;
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
        si1e = si2e;
    ]
    q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
    q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
    "now positrons"
    DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
        si1e = si2e;
    ]
    q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
    q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);

    "prepare interpolation table for the second MS moment correction"
    "e-"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
        si1e = si2e;
    ]
    q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
    q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
    "e+"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
    ]
    q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
    q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);

    "Now substract scattering power that is already taken into account in"
    "discrete Moller/Bhabha events"
    tauc = te(medium)/prm;
    si1e = 1;
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        e = Exp(eil); leil=i+1; tau=e/prm;
        IF( tau > 2*tauc ) [
            $EVALUATE sig USING esig(eil);
            $EVALUATE dedx USING ededx(eil);
            sig = sig/dedx;
            IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
                $EVALUATE etap USING etae_ms(eil);
                eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
                g_r = (1+2*eta)*Log(1+1/eta)-2;
                g_m = Log(0.5*tau/tauc)+
                 (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
                 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
                    Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
                 0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
                IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
                si2e = 1 - g_m*sum_Z/sum_Z2;
            ] ELSE [ si2e = 1; ]
        ] ELSE [ si2e = 1; ]
        blcce1(i,medium) = (si2e - si1e)*eke1(medium);
        blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
        si1e = si2e;
    ]
    blcce1(neke,medium) = blcce1(neke-1,medium);
    blcce0(neke,medium) = blcce0(neke-1,medium);

    "We will not bother to do the same for positrons at this time"

    $egs_info('(a)',' done');
]
return;

:SPIN-DBASE-ERROR:
$egs_info(*,' ******************** Error in init_spin ******************* ');
$egs_info('(a,a)','  could not open file ',spin_file);
$egs_fatal(*,' terminating execution ');

end;
%E
; "buffer flush

"======================================================================"
"                 subroutine msdist_pII                                "
"                 =====================                                "
"                                                                      "
"  This subroutine models multiple elastic scattering and spatial      "
"  deflections for a given path-length tustep.                         "
"  For description of input and output variables see below             "
"                                                                      "
"  September 1996      Iwan Kawrakow        Initial coding (in fortran)"
"  March 1997          Alex Bielajew        Adaption for EGS4          "
"  April/Mai 1997      Iwan Kawrakow        Debuging of the EGS4       "
"                                           mortran version by Bielajew"
"  June 1997           Iwan Kawrakow        Improved energy loss       "
"                                           corrections                "
"  June 1999           Iwan Kawrakow        spin effects, removed      "
"                                           $SUBSTEP-ELOSS-EVALUATION  "
"                                                                      "
"======================================================================"
"                                                                      "
subroutine msdist_pII
(
    e0,eloss,tustep,rhof,med,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
    us,vs,ws,xf,yf,zf,ustep                                         "Outputs
);

$IMPLICIT-NONE;

" Input variables
" ===============
$REAL
    e0,     "electron kinetic energy at the beginning of step
    eloss,  "energy loss for this step
    rhof,   "density scaling template (as in EGS)
    tustep, "total pathlength of the step,
    u0,     "x-direction cosine before scattering
    v0,     "y-direction cosine before scattering
    w0,     "z-direction cosine before scattering
    x0,     "initial x-position
    y0,     "initial y-position
    z0      "initial z-position
;
$INTEGER
    med,"medium number
    qel    "=0 for e-, =1 for e+, needed for spin effects
;
$LOGICAL
    spin_effects;
;

" Output variables
" ================
$REAL
    us,    "x-direction cosine after scattering
    vs,    "y-direction cosine after scattering
    ws,    "z-direction cosine after scattering
    xf,    "final x-position after transport
    yf,    "final y-position after transport
    zf,    "final z-position after transport
    ustep  "straight line distance between the initial and final position
;

" Local variables
" ===============
$REAL
    b,         "substep transport distance,
    blccc,     "multiple scattering parameter
    xcccc,     "multiple scattering parameter
    c,         "substep transport distance,
    eta,eta1,  "randomization of the substep transport distances
    chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
    chilog,    "log(1+1/chia2)
    cphi0,     "cosine of the azimuthal angle of the initial particle relative
               "to its coordinates
    cphi1,     "cosine of the first azimuthal angle
    cphi2,     "cosine of the second azimuthal angle
    w1,        "cosine of the first substep polar scattering angle
    w2,        "cosine of the second substep polar scattering angle
    w1v2,      "w1*v2;
    delta,     "transport parameter (see paper)
    e,         "average kinetic energy over the step
    elke,      "Log(e)"
    beta2,     "speed at e in units of c, squared"
    etap,      "correction to the screening parameter derived from PWA
    xi_corr,   "correction to the first MS moments due to spin
    ms_corr,
    tau,       "average kinetic energy over the step divided by electron mass
    tau2,      "tau squared
    epsilon,   "fractional energy loss
    epsilonp,  "fractional energy loss
    temp,temp1,"auxilarity variables for energy loss corrections
    temp2,     "
    factor,    "intermediate factor employed in the energy-loss calculations
    gamma,     "q2/q1
    lambda,    "distance in number of elastic scattering mean free paths
               "for each sample of the multiple scattering angle
    p2,        "average momentum over the step
    p2i,       "inverse of ap2
    q1,        "first moment of the single scattering cross section
    rhophi2,   "xphi**2 + yphi**2 or its inverse
    sint0,     "sine of the initial particle relative to its coordinates
    sint02,    "sint0**2
    sint0i,    "1/sint0
    sint1,     "sine   of the first substep polar scattering angle
    sint2,     "sine   of the second substep polar scattering angle
    sphi0,     "sine of the azimuthal angle of the initial particle relative
               "to its coordinates
    sphi1,     "sine   of the first azimuthal angle
    sphi2,     "sine   of the second azimuthal angle
    u2p,       "intermediate scatter or transport direction cosine
    u2,        "sint2*cphi2;
    v2,        "sint2*sphi2;
    ut,        "x-direction cosine for transport
    vt,        "y-direction cosine for transport
    wt,        "z-direction cosine for transport
    xi,        "first GS - moment
    xphi,      "x - used to calculated azimuthal angles
    xphi2,     "xphi**2
    yphi,      "y - used to calculated azimuthal angles
    yphi2      "yphi**2
;
$LOGICAL
   find_index,  "needed to save locating the q2 index in the 2. call to mscat"
   spin_index   "saves locating the spin rejection index in 2. call to mscat"
;
$INTEGER
   lelke
;
$declare_max_medium;
;COMIN/ELECIN,THRESH,UPHIOT,RANDOM,CH-Steps,USEFUL,EMF-INPUTS/;
;COMIN/EM/;
medium  = med;

count_pII_steps = count_pII_steps + 1;
blccc   = blcc(medium);
xcccc   = xcc(medium);

"Commonly used factors
e       = e0 - 0.5*eloss;
tau     = e/prm;
tau2    = tau*tau;
epsilon = eloss/e0;
epsilonp= eloss/e;
"e       = e * (1 - epsilonp*epsilonp*((6+tau*(10+5*tau))/(tau+1)/(tau+2))/24);
e       = e * (1 - epsilonp*epsilonp*(6+10*tau+5*tau2)/(24*tau2+72*tau+48));
p2      = e*(e + rmt2);
"p2i     = 1/p2;
beta2   = p2/(p2 + rmsq);
"chia2   = xcccc*p2i/(4*blccc);
chia2   = xcccc/(4*p2*blccc);
lambda  = 0.5*tustep*rhof*blccc/beta2; "The 0.5 implies a half-step

temp2  = 0.166666*(4+tau*(6+tau*(7+tau*(4+tau))))*
             (epsilonp/((tau+1)*(tau+2)))**2;
lambda = lambda*(1 - temp2);

IF ( spin_effects ) [
   elke = Log(e);
   $SET INTERVAL elke,eke;
   IF ( lelke < 1 ) [ "This should normally not happen"
       lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
   ]
   IF( qel = 0 ) [
       $EVALUATE etap USING etae_ms(elke);
       $EVALUATE xi_corr USING q1ce_ms(elke);
       $EVALUATE gamma USING q2ce_ms(elke);
   ]
   ELSE [
       $EVALUATE etap USING etap_ms(elke);
       $EVALUATE xi_corr USING q1cp_ms(elke);
       $EVALUATE gamma USING q2cp_ms(elke);
   ]
   $EVALUATE ms_corr USING blcce(elke);
]
ELSE [ etap = 1; xi_corr = 1; gamma = 1; ms_corr = 1; ]

chia2  = chia2*etap;
lambda = lambda/(etap*(1+chia2))*ms_corr;
chilog = Log(1 + 1/chia2);
q1     = 2*chia2*(chilog*(1 + chia2) - 1);
gamma  = 6*chia2*(1 + chia2)*(chilog*(1 + 2*chia2) - 2)/q1*gamma;
xi     = q1*lambda;

"Sample first substep scattering angle
find_index = .true.; spin_index = .true.;
call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
           spin_effects,find_index,spin_index,
           w1,sint1);
$SELECT-AZIMUTHAL-ANGLE(cphi1,sphi1);

"Sample second substep scattering angle
call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
           spin_effects,find_index,spin_index,
           w2,sint2);
$SELECT-AZIMUTHAL-ANGLE(cphi2,sphi2);

"Final direction of motion, relative to z-axis motion
u2  = sint2*cphi2;
v2  = sint2*sphi2;
u2p = w1*u2 + sint1*w2;
us  = u2p*cphi1 - v2*sphi1;
vs  = u2p*sphi1 + v2*cphi1;
ws  = w1*w2 - sint1*u2;

"Calculate delta, b, c

xi = 2*xi*xi_corr;  "xi was for half step, xi_corr corrects for spin effects

$RANDOMSET eta; eta = Sqrt(eta); eta1 = 0.5*(1 - eta);
delta  = 0.9082483-(0.1020621-0.0263747*gamma)*xi;

"Correct the coefficients for energy loss
temp1 = 2 + tau;
temp = (2+tau*temp1)/((tau+1)*temp1);
"Take logarithmic dependence into account as well
temp = temp - (tau+1)/((tau+2)*(chilog*(1+chia2)-1));
temp = temp * epsilonp;
temp1 = 1 - temp;
delta = delta + 0.40824829*(epsilon*(tau+1)/((tau+2)*
          (chilog*(1+chia2)-1)*(chilog*(1+2*chia2)-2)) - 0.25*temp*temp);
           "0.40824829 is 1/Sqrt(6)"
b      = eta*delta;
c      = eta*(1-delta);

"Calculate transport direction cosines
w1v2 = w1*v2;
ut   = b*sint1*cphi1 + c*(cphi1*u2 - sphi1*w1v2) + eta1*us*temp1;
vt   = b*sint1*sphi1 + c*(sphi1*u2 + cphi1*w1v2) + eta1*vs*temp1;
wt   = eta1*(1+temp) +        b*w1 +  c*w2       + eta1*ws*temp1;

"Calculate transport distance
ustep  = tustep*sqrt(ut*ut + vt*vt + wt*wt);

"Rotate into the final direction of motion and transport
"relative to original direction of motion
sint02 = u0**2 + v0**2;
IF (sint02 > 1e-20)
[
    sint0  = sqrt(sint02);
    sint0i = 1/sint0;
    cphi0  = sint0i*u0;
    sphi0  = sint0i*v0;

    "Scattering angles
    u2p    = w0*us + sint0*ws;
    ws     = w0*ws - sint0*us;
    us     = u2p*cphi0 - vs*sphi0;
    vs     = u2p*sphi0 + vs*cphi0;

    "Transport angles
    u2p    = w0*ut + sint0*wt;
    wt     = w0*wt - sint0*ut;
    ut     = u2p*cphi0 - vt*sphi0;
    vt     = u2p*sphi0 + vt*cphi0;
]
ELSE [ wt = w0*wt; ws = w0*ws; ]

$EMFIELD_PII;
"Transport
xf = x0 + tustep*ut;
yf = y0 + tustep*vt;
zf = z0 + tustep*wt;

return;
end;

;

"                 subroutine msdist_pI                                 "
"                 ====================                                 "
"                                                                      "
"  This subroutine models multiple elastic scattering and spatial      "
"  deflections for a given path-length tustep                          "
"  resampling PRESTA-I behaviour.                                      "
"                                                                      "
"  October 1997        Iwan Kawrakow        Initial coding             "
"  June    1999        Iwan Kawrakow        spin effects               "
"                                                                      "
"======================================================================"
"                                                                      "
subroutine msdist_pI
(
    e0,eloss,tustep,rhof,medium,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
    us,vs,ws,xf,yf,zf,ustep                                         "Outputs
);

$IMPLICIT-NONE;

" Input variables
" ===============
$REAL
    e0,     "electron kinetic energy at the beginning of step
    eloss,  "energy loss for this step
    rhof,   "density scaling template (as in EGS)
    tustep, "total pathlength of the step,
    u0,     "x-direction cosine before scattering
    v0,     "y-direction cosine before scattering
    w0,     "z-direction cosine before scattering
    x0,     "initial x-position
    y0,     "initial y-position
    z0      "initial z-position
;
$INTEGER
    medium,"medium number
    qel    "=0 for e-, =1 for e+, needed for spin effects
;
$LOGICAL
    spin_effects
;

" Output variables
" ================
$REAL
    us,    "x-direction cosine after scattering
    vs,    "y-direction cosine after scattering
    ws,    "z-direction cosine after scattering
    xf,    "final x-position after transport
    yf,    "final y-position after transport
    zf,    "final z-position after transport
    ustep  "straight line distance between the initial and final position
;

" Local variables
" ===============
$REAL
    blccc,     "multiple scattering parameter
    xcccc,     "multiple scattering parameter
    z,r,z2,r2, "used to calculate PLC and lateral deflection a la PRESTA-I
    r2max,
    chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
    chilog,    "log(1+1/chia2)
    cphi0,     "cosine of the azimuthal angle of the initial particle relative
               "to its coordinates
    cphi,      "cosine of the azimuthal scattering angle
    sphi,      "sine of the  azimuthal scattering angle
    e,         "average kinetic energy over the step
    elke,      "Log(e)
    beta2,     "speed at e in units of c, squared
    etap,      "correction to the screening angle derived from PWA
    xi_corr,   "correction to the first MS moment due to spin
    ms_corr,
    epsilon,   "fractional energy loss
    temp,      "auxilarity variable for energy loss corrections
    factor,    "intermediate factor employed in the energy-loss calculations
    lambda,    "distance in number of elastic scattering mean free paths
    p2,        "average momentum over the step
    p2i,       "inverse of p2
    q1,        "first moment of the single scattering cross section
    rhophi2,   "xphi**2 + yphi**2 or its inverse
    sint,      "sine of the MS angle
    sint0,     "sine of the initial particle relative to its coordinates
    sint02,    "sint0**2
    sint0i,    "1/sint0
    sphi0,     "sine of the azimuthal angle of the initial particle relative
               "to its coordinates
    u2p,       "intermediate scatter or transport direction cosine
    ut,        "x-direction cosine for transport
    vt,        "y-direction cosine for transport
    wt,        "z-direction cosine for transport
    xi,        "first GS - moment
    xphi,      "x - used to calculated azimuthal angles
    xphi2,     "xphi**2
    yphi,      "y - used to calculated azimuthal angles
    yphi2      "yphi**2
;
$LOGICAL
   find_index, "needed to save locating the q2 index in the 2. call to mscat"
   spin_index
;
$INTEGER
   lelke
;
$declare_max_medium;
;COMIN/ELECIN,THRESH,UPHIOT,RANDOM,EMF-INPUTS/;
;COMIN/EM/;
blccc   = blcc(medium);
xcccc   = xcc(medium);

e       = e0 - 0.5*eloss;
p2      = e*(e + rmt2);
p2i     = 1/p2;
chia2   = xcccc*p2i/(4*blccc);
beta2   = p2/(p2 + rmsq);
lambda  = tustep*rhof*blccc/beta2;

"Account for energy loss in the MS distribution
factor = 1/(1 + 0.9784671*e); "0.9784671 = 1/(2*rm)
epsilon= eloss/e0;
epsilon= epsilon/(1-0.5*epsilon);
temp   = 0.25*(1 - factor*(1 - 0.333333*factor))*epsilon**2;
lambda = lambda*(1 + temp);

IF ( spin_effects ) [
   elke = Log(e);
   $SET INTERVAL elke,eke;
   IF ( lelke < 1 ) [ "This should normally not happen"
       lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
   ]
   IF( qel = 0 ) [
       $EVALUATE etap USING etae_ms(elke);
       $EVALUATE xi_corr USING q1ce_ms(elke);
   ]
   ELSE [
       $EVALUATE etap USING etap_ms(elke);
       $EVALUATE xi_corr USING q1cp_ms(elke);
   ]
   $EVALUATE ms_corr USING blcce(elke);
]
ELSE [ etap = 1; xi_corr = 1; ms_corr = 1; ]

chia2   = xcccc*p2i/(4*blccc)*etap;
lambda = lambda/etap/(1+chia2)*ms_corr;
chilog = Log(1 + 1/chia2);
q1     = 2*chia2*(chilog*(1 + chia2) - 1);
xi     = q1*lambda;

"Sample multiple scattering angle
find_index = .true.; spin_index = .true.;
call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
           spin_effects,find_index,spin_index,
           ws,sint);
$SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
us  = sint*cphi;
vs  = sint*sphi;

"Correct xi used for the PLC calc. for spin effects
xi     = xi*xi_corr;

"Calculate PLC and lateral transport a la PRESTA-I
"Note that we use here the exact expression for <z>
"because it is much simpler and faster than the original PRESTA-I formulas
"(which are also second order approximations)
IF ( xi < 0.1 )
[
   z = 1 - xi*(0.5 - xi*(0.166666667 - 0.041666667*xi));
]
ELSE
[
   z = (1 - Exp(-xi))/xi;
]
r  = 0.5*sint;
r2 = r*r; z2 = z*z;
r2max = 1 - z2;
IF ( r2max < r2 ) [ r2 = r2max; r = Sqrt(r2); ]

"Calculate final position vector
ut   = r*cphi; vt = r*sphi; wt = z;

"Calculate transport distance
ustep = Sqrt(z2 + r2)*tustep;

"Rotate into the final direction of motion and transport
"relative to original direction of motion
sint02 = u0**2 + v0**2;
IF (sint02 > 1e-20)
[
    sint0  = sqrt(sint02);
    sint0i = 1/sint0;
    cphi0  = sint0i*u0;
    sphi0  = sint0i*v0;

    "Scattering angles
    u2p    = w0*us + sint0*ws;
    ws     = w0*ws - sint0*us;
    us     = u2p*cphi0 - vs*sphi0;
    vs     = u2p*sphi0 + vs*cphi0;

    "Transport angles
    u2p    = w0*ut + sint0*wt;
    wt     = w0*wt - sint0*ut;
    ut     = u2p*cphi0 - vt*sphi0;
    vt     = u2p*sphi0 + vt*cphi0;
]
ELSE [ wt = w0*wt; ws = w0*ws; ]

$EMFIELD_PI;
"Transport
xf = x0 + tustep*ut;
yf = y0 + tustep*vt;
zf = z0 + tustep*wt;

return;
end;

;
%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE PAIR;
"                                                                  "
"******************************************************************"
"   For a photon energy below 2.1 MeV, the energies of the pair    "
"   particles are uniformly distributed in the allowed range via   "
"   the default replacement for $SELECT-LOW-ENERGY-PAIR-PRODICTION;"
"   If the user has a better approach, modify this macro.          "
"   For a photon energy between 2.1 and 50 MeV the Bethe-Heitler   "
"   cross section is employed, above 50 MeV the Coulomb-corrected  "
"   Bethe-Heitler is used.                                         "
"   Modified from its original version to make compatible with the "
"   changes made in BREMS.                                         "
"                                                                  "
"   I. Kawrakow                                                    "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-PAIR;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,STACK,"
                                 "THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-PAIR;

$DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;

$REAL    k,xx,abin,rbin,alias_sample1;
$INTEGER ibin, iq1, iq2, iprdst_use;
$LOGICAL do_nrc_pair;
$INTEGER itrip;
$REAL    ftrip;

NPold = NP;      "Set the old stack counter"

IF( i_play_RR = 1 ) [ " The user wants to play Russian Roulette. For pair "
                      " it is much more efficient to do it BEFORE the "
                      " actual sampling "
    i_survived_RR = 0;  "flag they all survive inititally"
    IF( prob_RR <= 0 ) [
        IF( n_RR_warning < $MAX-RR-WARNING ) [
          n_RR_warning = n_RR_warning + 1;
          $egs_warning('(a,g14.6)',
                      'Attempt to play Russian Roulette with prob_RR<0! ');
        ]
    ]
    ELSE [
        $RANDOMSET rnno_RR;
        IF( rnno_RR > prob_RR ) [  "The pair was killed "
            i_survived_RR =2; "flag both particles eliminated"
            IF( np > 1 ) [ np = np-1; ]
            ELSE [ " We have just one photon left on the stack. In order to  "
                   " get a proper exit from PHOTO, we have to leave at least "
                   " one particle on the stack                               "
                wt(np) = 0; e(np) = 0;
            ]
            return;
        ]
        ELSE [ "The pair survived, increase the weight"
            wt(np) = wt(np)/prob_RR;
        ]
    ]
]

$CHECK-STACK(np+1,'PAIR');
PEIG=E(NP); "PRECISE ENERGY OF INCIDENT GAMMA"
EIG=PEIG;   "ENERGY OF INCIDENT GAMMA"
do_nrc_pair = .false.;

IF( itriplet > 0 & eig > 4*rm ) [
    itrip = dli_triplet*gle + bli_triplet;
    ftrip = a_triplet(itrip,medium)*gle + b_triplet(itrip,medium);
    $RANDOMSET rnno34;
    IF( rnno34 < ftrip ) [  " Triplet production "
        call sample_triplet;
        return;
    ]
]

IF( pair_nrc = 1 ) [  "Sample from the NRC pair cross section data base"
                      "(privided the energy is within the available range)"
    k = eig/rm;
    IF( k < nrcp_emax ) [
        do_nrc_pair = .true.;
        IF( k <= nrcp_emin ) [ ibin = 1; ]
        ELSE [
            abin = 1 + log((k-2)/(nrcp_emin-2))*nrcp_dlei;
            ibin = abin; abin = abin - ibin;
            $RANDOMSET rbin;
            IF( rbin < abin ) ibin = ibin + 1;
        ]
        xx = alias_sample1($NRC-PAIR-NX-1,nrcp_xdata,
                nrcp_fdata(1,ibin,medium),nrcp_wdata(1,ibin,medium),
                nrcp_idata(1,ibin,medium));
           " The above returns the energy fraction of the positron "
        IF( xx > 0.5 ) [
            pese1 = prm*(1 + xx*(k-2)); iq1 = 1;
            pese2 = peig - pese1; iq2 = -1;
        ]
        ELSE [
            pese2 = prm*(1 + xx*(k-2)); iq2 = 1;
            pese1 = peig - pese2; iq1 = -1;
        ]
    ]
]


IF( ~do_nrc_pair ) [
IF (EIG.LE.2.1) [
    "   BELOW 2.1,USE APPROXIMATION"
    $SELECT-LOW-ENERGY-PAIR-PRODICTION;
]
ELSE[   "ABOVE 2.1, MUST SAMPLE"

    "   DECIDE WHETHER TO USE BETHE-HEITLER or BH
    "   COULOMB CORRECTED

    IF (EIG.LT.50.) [ "Use BH without Coulomb correction"

        L = 5;
        L1 = L + 1;

        "Find the actual rejection maximum for this photon energy"
        delta = 4*delcm(medium)/eig;
        IF( delta < 1 ) [
           Amax = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
           Bmax = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
        ]
        ELSE [
           aux2 = log(delta+dl6(l,medium));
           Amax = dl4(l,medium)+dl5(l,medium)*aux2;
           Bmax = dl4(l1,medium)+dl5(l1,medium)*aux2;
        ]
        "and then calculate the probability for sampling from (br-1/2)**2"
        aux1 = 1 - rmt2/eig; aux1 = aux1*aux1;
        aux1 = aux1*Amax/3; aux1 = aux1/(Bmax+aux1);
    ]
    ELSE [
        "Use BH Coulomb-corrected"
        L = 7;
        "The absolute maxima are close to the actual maxima at high energies"
        "=>use the absolute maxima to save time"
        Amax = dl1(l,medium); Bmax = dl1(l+1,medium);
        aux1 = bpar(2,medium)*(1-bpar(1,medium)*rm/eig);
    ]

    del0 = eig*delcm(medium);
    Eavail = eig - rmt2;

    LOOP [

        $RANDOMSET RNNO30; $RANDOMSET RNNO31; $RANDOMSET RNNO34;
        IF( rnno30 > aux1 ) [ "use the uniform part"
            br = 0.5*rnno31;  rejmax = Bmax; l1 = l+1;
        ]
        ELSE [  "use the (br-1/2)**2 part of the distribution"
            $RANDOMSET rnno32; $RANDOMSET rnno33;
            br = 0.5*(1-max(rnno31,rnno32,rnno33));
            rejmax = Amax; l1 = l;
        ]
        Eminus = br*Eavail + rm;
        Eplus  = eig - Eminus;
        delta = del0/(Eminus*Eplus);
        IF( delta < 1 ) [
           rejf = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
        ]
        ELSE [
          rejf = dl4(l1,medium)+dl5(l1,medium)*log(delta+dl6(l1,medium));
        ]

    ] UNTIL ( rnno34*rejmax <= rejf );

    pese2 = Eminus; pese1 = peig - pese2;
    $RANDOMSET RNNO34;
    IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]

]
]

"   ENERGY GOING TO LOWER SECONDARY HAS NOW BEEN DETERMINED"
ESE2=PESE2;
E(NP)=PESE1; E(NP+1)=PESE2;
"   THIS AVERAGE ANGLE OF EMISSION FOR BOTH PAIR PRODUCTION AND"
"   BREMSSTRAHLUNG IS MUCH SMALLER THAN THE AVERAGE ANGLE OF"
"   MULTIPLE SCATTERING FOR DELTA T TRANSPORT=0.01 R.L."
"   THE INITIAL AND FINAL MOMENTA ARE COPLANAR "
"   SET UP A NEW 'ELECTRON'  "
$SET-PAIR-ANGLE;
" DEFAULT FOR $SET-PAIR-ANGLE; is to select the angle from the leading term"
" of the angular distribution "
CALL UPHI(1,1);
"   SET UP A NEW 'ELECTRON' "
NP=NP+1;
SINTHE=-SINTHE;
CALL UPHI(3,2);

IQ(NP)=iq2; IQ(NP-1)=iq1;
RETURN;
"END OF SUBROUTINE PAIR"    END;

"***************************************************************************"
"                                                                           "
" Sampling of triplet production events.                                    "
"                                                                           "
" The treatment is based on Borsellino's first Born approximation           "
" result (see Eq. 4B-3002 in the pair article of Motz, Olsen & Koch)        "
" As the kinematic of the process is already complicated enough and the     "
" cross section itself is not simple either, a Markov-chain method is used  "
" to sample triplet events from the Borsellino equation without any         "
" additional approximations (other then the use of the first Born           "
" approximation and the assumption of free electrons implied by             "
" Borsellino's derivation)                                                  "
"                                                                           "
" Iwan Kawrakow, April 2005.                                                "
"***************************************************************************"

subroutine sample_triplet;

"***************************************************************************"
implicit none;
$declare_max_medium;
;COMIN/EPCONT,STACK,MEDIA,THRESH,USEFUL,RANDOM,USER,EGS-IO/;
$declare_write_buffer;

" We use double precision throughout as in many cases the kinematically "
" permitted angular interval is too small to be resolved accurately enough "
" in single precision "

real*8 fmax_array($MAX_TRIPLET), eta_p_array($MAX_TRIPLET),
       eta_Ep_array($MAX_TRIPLET), eta_costp_array($MAX_TRIPLET),
       eta_costm_array($MAX_TRIPLET), ebin_array($MAX_TRIPLET),
       wp_array($MAX_TRIPLET), qmin_array($MAX_TRIPLET);

real*8 kmin, kmax, dlogki, alogkm, prmi, tiny_eta;

real*8 ai,rnno,k,qmin,qmax,aux,a1,a2,a3,D,px1,px2,pp_min,pp_max,
       Ep_min,Ep_max,k2p2,k2p2x,peig,b,aux1,aux12,D1,aux3,xmin,xmax,
       aux6,aux7,uu,cphi,sphi,cphi_factor,aux5,phi,tmp;
real*8 Er,pr,pr2,eta_pr;
real*8 Ep,pp,pp2,wEp,cost_p,sint_p,eta_Ep,mup_min,wmup,
       eta_costp,Epp,pp_sintp,pp_sntp2;
real*8 Em,pm,pm2,cost_m,sint_m,Emm,wmum,pm_sintm,
       eta_costm;
real*8 k2,k3,s2,s3,k2k3i,k22,k32,q2,aux4,S_1,S_2,sigma;
real*8 ppx, ppy, ppz, pmx, pmy, pmz, prx, pry, prz,
       a,c,sindel,cosdel,sinpsi;

$INTEGER i;
$LOGICAL use_it;
$INTEGER iscore; " needed for BEAM "

$LOGICAL is_initialized;
data is_initialized/.false./;
save is_initialized,fmax_array,eta_p_array,eta_Ep_array,eta_costp_array,
     eta_costm_array,ebin_array,wp_array,qmin_array,
     kmin,kmax,dlogki,alogkm,prmi,tiny_eta;

IF( ~is_initialized ) [
    is_initialized = .true.;
    tiny_eta = 1e-6;
    " Set current cross section value to -1 in each energy bin "
    DO i=1,$MAX_TRIPLET [ fmax_array(i) = -1; ]
    " Find the maximum energy of the cross section data "
    kmax = 0; kmin = 4.1*prm;
    DO i=1,nmed [ IF( up(i) > kmax ) kmax = UP(i); ]
    IF( kmax <= kmin ) return;
    dlogki = $MAX_TRIPLET - 1; dlogki = dlogki/log(kmax/kmin);
    alogkm = 1 - dlogki*log(kmin);
    prmi = 1/prm;
    DO i=1,$MAX_TRIPLET [
        k = 4.1*exp((i-1.)/dlogki); ebin_array(i) = k;
        qmin = 4*k/(k*(k-1)+(k+1)*sqrt(k*(k-4)));
        qmax = (k*(k-1) + (k+1)*sqrt(k*(k-4)))/(2*k+1);
        qmin_array(i) = qmin; wp_array(i) = log(qmax/qmin);
    ]
]

peig = e(np);
IF( peig <= 4*prm ) return;
$CHECK-STACK(np+2,'sample_triplet');

" Determine energy bin "
IF( peig <= kmin ) [ i = 1; ]
ELSE IF( peig >= kmax ) [ i = $MAX_TRIPLET; ]
ELSE [
    ai = alogkm + dlogki*gle; i = ai; ai = ai - i;
    $RANDOMSET rnno;
    IF( rnno < ai ) [ i = i+1; ]
]

" First use the bin energy to sample the random numbers "
" that determine recoil momentum and electron/postron angles "
k = ebin_array(i);

/*
   In the following:  k is incident photon energy in units of m*c^2
                      (all energies are in units of m*c^2, momenta in
                       units of m*c)
                      Er,pr is energy, momentum of the recoil electron
                      Ep,pp is energy, momentum of the pair positron
                      Em,pm is energy, momentum of the pair electron
                      cost_p, sint_p is cos, sin of the positron angle
                                     with respect to k
                      cost_m, sint_m same but for the electron
                      cphi is cos of azimuthal angle between positron
                              and pair electron directions.
*/

:retry_triplet:;

" Pick the recoil electron momentum from 1/p.
$RANDOMSET eta_pr; IF( eta_pr < tiny_eta ) eta_pr = tiny_eta;
pr = qmin_array(i)*exp(eta_pr*wp_array(i));
pr2 = pr*pr; Er = sqrt(1+pr2);

" Determine min./max. kinematically permitted postron energy for "
" this k and p "
aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
ELSE            [ pp_min = px2; pp_max = px1; ]
Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);

" Pick the positron energy "
$RANDOMSET eta_Ep; IF( eta_Ep < tiny_eta ) eta_Ep = tiny_eta;
wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;

" Now we can determine the pair electron energy from energy conservation "
Em = k + 1 - Er - Ep;
pm2 = Em*Em-1; pm = sqrt(pm2);

" The minimum cosine of the positron angle follows from the kinematics. "
mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);

" Now pick the positron direction from 1/(Ep-pp*cost_p) "
$RANDOMSET eta_costp; IF( eta_costp < tiny_eta ) eta_costp = tiny_eta;
Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
wmup = wmup*(cost_p - Epp);
sint_p = 1-cost_p*cost_p;
IF( sint_p > 1e-20 ) [ sint_p = sqrt(sint_p); ] ELSE [ sint_p = 1e-10; ]
k2p2x = k2p2 - 2*k*pp*cost_p;

" The minimum amd maximum cosine of the pair electron angle follows from "
" the kinematics "
b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
D1 = pm2*(aux12+pp_sntp2)-b*b/4;
if( D1 <= 0 ) [ goto :retry_triplet:; ]
D = 2*pp_sintp*sqrt(D1);
aux3 = 0.5/(aux12+pp_sntp2);
xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;

" Now pick the electron direction from "
"  1/(Em-pm*cost_m)/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) "
" We have to take into account the "
" 1/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) factor in the sampling "
" otherwise we end up with 1/sqrt() singularities near the ends of the "
" allowed cost_m range                                                 "
$RANDOMSET eta_costm; IF( eta_costm < tiny_eta ) eta_costm = tiny_eta;
aux6 = sqrt((Em-xmin)/(Em-xmax));
aux7 = aux6*tan(1.570796326794897*eta_costm);
uu = (aux7-1)/(aux7+1);
cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu));
wmum = sqrt((xmax-cost_m)*(cost_m-xmin));
wmum = wmum*aux6*(Em-cost_m)/(Em-xmin);
cost_m = cost_m/pm;
sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;

" Now we have selected all independent kinematic variables. "
" Determine the azimuthal angle between the pair electrons "
cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
sphi = sqrt(1-cphi*cphi);

" And now evaluate the Borsellino cross section "
k3 = k*(pp*cost_p - Ep); k2 = k*(pm*cost_m - Em);
k22 = k2*k2; k32 = k3*k3; k2k3i = 1/(k2*k3);
s2 = pp*pm*(cost_p*cost_m + sint_p*sint_m*cphi) - Ep*Em;
s3 = k2 - Em + 1 - s2; q2 = 2*(Er-1);
S_1 = k32+k22+(q2-2)*s2-(1-q2/2)*(k32+k22)*k2k3i;
aux4 = k3*Ep-k2*Em;
S_2 = -q2*(Ep*Ep+Em*Em) + 2*s2 - (2*aux4*aux4 - k22 - k32)*k2k3i;
sigma = abs(pp*pm2*pm*k2k3i/(q2*q2*(Em*s3+Er))*(S_1*(1-q2/4)+S_2*(1+q2/4)));

" We get the following factor due to the transformation from phi to "
" the recoil momentum pr "
cphi_factor = abs(2*Er*pm2-Em*(k2p2x-pr2-pm2))/(2*pp_sintp*pm_sintm*pm2*sphi);

" We have to also multiply by the various factors from the sampling of "
" pr, Ep, cost_p and cost_m "
sigma = sigma*cphi_factor*wEp*wmup*wmum*wp_array(i)*pr2/Er;
IF( sigma < 0 ) [
    $egs_warning(*,'In triplet sigma < 0 ? ',sigma);
]

" Now determine if we accept this new event "
use_it = .true.;
IF( sigma < fmax_array(i) ) [
    $RANDOMSET rnno;
    IF( sigma < fmax_array(i)*rnno ) [ use_it = .false. ]
]
IF( use_it ) [       " Yes, event accepted "
    fmax_array(i) = sigma;
    eta_p_array(i) = eta_pr; eta_Ep_array(i) = eta_Ep;
    eta_costp_array(i) = eta_costp; eta_costm_array(i) = eta_costm;
] ELSE [             " Nop, event rejected => use last accepted "
    eta_pr = eta_p_array(i); eta_Ep = eta_Ep_array(i);
    eta_costp = eta_costp_array(i); eta_costm = eta_costm_array(i);
]

" We now have a set of random number accepted for sampling around "
" the i'th bin energy. We need to recalculate all variables using "
" the actual photon energy "

k = peig*prmi;
aux5 = k*(k-1)+(k+1)*sqrt(k*(k-4));
qmin = 4*k/aux5; qmax = aux5/(2*k+1);
pr = qmin*exp(eta_pr*log(qmax/qmin));
pr2 = pr*pr; Er = sqrt(1+pr2);

aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
ELSE            [ pp_min = px2; pp_max = px1; ]
Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);

wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;
Em = k + 1 - Er - Ep;
pm2 = Em*Em-1; pm = sqrt(pm2);

mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);
Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
sint_p = sqrt(1-cost_p*cost_p);
k2p2x = k2p2 - 2*k*pp*cost_p;

b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
D1 = pm2*(aux12+pp_sntp2)-b*b/4;
if( D1 <= 0 ) [ goto :retry_triplet:; ]
D = 2*pp_sintp*sqrt(D1);
aux3 = 0.5/(aux12+pp_sntp2);
xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;
aux6 = sqrt((Em-xmin)/(Em-xmax));
aux7 = aux6*tan(1.570796326794897*eta_costm);
uu = (aux7-1)/(aux7+1);
cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))/pm;
sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;

cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
sphi = sqrt(1-cphi*cphi);

/*
   OK, now the final momenta are
     Positron:     (pp*sint_p,      0,             pp*cost_p)
     Electron:     (pm*sint_m*cphi,pm*sint_m*sphi, pm*cost_m)
 Recoil electron:  k - pp - pm
   This is in a frame where the photon is moving along the z axis.
   We have to pick another azimuthal angle randomly, rotate the
   x- and y- components of pp and pm by that, determine the recoil
   momentum from momentum conservation and then rotate all three
   momenta back into the lab frame.
*/
$RANDOMSET phi; phi = phi*6.283185307179586;
ppx = pp*sint_p; ppy = 0;
pmx = pm*sint_m*cphi; pmy = pm*sint_m*sphi;
cphi = cos(phi); sphi = sin(phi);
tmp = ppx*sphi; ppx = ppx*cphi - ppy*sphi; ppy = tmp + ppy*cphi;
tmp = pmx*sphi; pmx = pmx*cphi - pmy*sphi; pmy = tmp + pmy*cphi;
ppz = pp*cost_p; pmz = pm*cost_m;
prx = -ppx-pmx; pry = -ppy-pmy; prz = k - ppz - pmz;
" Set up particles on the stack ";
" We always put the recoil electron on top (even if its energy is higher "
" then the energies of the pair particles) because                       "
"   - that way, we know which particle is the recoil  electron in case   "
"     we want to score some quantity related to it                       "
"   - its energy is, on average, lower than the pair particle energies   "
NPold = np;
$TRANSFER PROPERTIES TO (np)   FROM (np);
$TRANSFER PROPERTIES TO (np+1) FROM (np);
$TRANSFER PROPERTIES TO (np+2) FROM (np+1);
pp = 1/pp; pm = 1/pm; pr = 1/pr;
a = u(np); b = v(np); c = w(np); sinpsi = a*a + b*b;
IF( sinpsi > 1e-20 ) [
    sinpsi = sqrt(sinpsi); sindel = b/sinpsi; cosdel = a/sinpsi;
    IF( Ep > Em ) [
        u(np)   = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
        v(np)   = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
        w(np)   = pp*(c*ppz - sinpsi*ppx); iq(np) = 1; E(np) = Ep*prm;
        u(np+1) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
        v(np+1) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
        w(np+1) = pm*(c*pmz - sinpsi*pmx); iq(np+1) = -1; E(np+1) = Em*prm;
    ]
    ELSE [
        u(np+1) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
        v(np+1) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
        w(np+1) = pp*(c*ppz - sinpsi*ppx); iq(np+1) = 1; E(np+1) = Ep*prm;
        u(np)   = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
        v(np)   = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
        w(np)   = pm*(c*pmz - sinpsi*pmx); iq(np) = -1; E(np) = Em*prm;
    ]
    np = np + 2;
    u(np)   = pr*(c*cosdel*prx - sindel*pry + a*prz);
    v(np)   = pr*(c*sindel*prx + cosdel*pry + b*prz);
    w(np)   = pr*(c*prz - sinpsi*prx); iq(np) = -1; E(np) = Er*prm;
] ELSE [
    IF( Ep > Em ) [
        u(np) = pp*ppx; v(np) = pp*ppy; w(np) = c*pp*ppz;
        iq(np) = 1; E(np) = Ep*prm;
        u(np+1) = pm*pmx; v(np+1) = pm*pmy; w(np+1) = c*pm*pmz;
        iq(np+1) = -1; E(np+1) = Em*prm;
    ]
    ELSE [
        u(np+1) = pp*ppx; v(np+1) = pp*ppy; w(np+1) = c*pp*ppz;
        iq(np+1) = 1; E(np+1) = Ep*prm;
        u(np) = pm*pmx; v(np) = pm*pmy; w(np) = c*pm*pmz;
        iq(np) = -1; E(np) = Em*prm;
    ]
    np = np + 2;
    u(np) = pr*prx; v(np) = pr*pry; w(np) = c*pr*prz;
    iq(np) = -1; E(np) = Er*prm;
]

return; end;

%E
"******************************************************************"
SUBROUTINE PHOTO;
"******************************************************************"
" Programmers:  I. Kawrakow, complete recoding,                    "
"                            Fluorescent X-rays, Auger,            "
"                            Coster-Kronig treated in RELAX        "
"               A.F. Bielajew (NRC) photoelectric angular distn    "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-PHOTO; "default replacement is:
              "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
                  "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"

$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
$DEFINE-LOCAL-VARIABLES-PHOTO;
/* $REAL ftot,iprob; */
data n_warning/0/;

IF ( mcdf_pe_xsections )[call egs_shellwise_photo();return;]

NPold = NP;      "Set the old stack counter"
PEIG=E(NP); irl = ir(np);
IF( peig < edge_energies(2,1) ) [
    IF( n_warning < 100 ) [
        n_warning = n_warning + 1;
        $egs_info(*,' Subroutine PHOTO called with E = ',peig,
                   ' which is below the current min. energy of 1 keV! ');
        $egs_info(*,' Converting now this photon to an electron, ');
        $egs_info(*,' but you should check your code! ');
    ]
    iq(np) = -1;
    e(np) = peig + prm;
    return;
]

iZ = iedgfl(irl);
do_relax = .false.;
edep = pzero;
IF( iedgfl(irl) ~= 0 ) [   " User requested atomic relaxations "
                           " first sample the element "
    IF( nne(medium) = 1 ) [
        iZ = int( zelem(medium,1) + 0.5 );
        DO j=1,edge_number(iZ) [
            IF( peig >= edge_energies(j,iZ) ) EXIT;
        ]
    ]
    ELSE [
        aux = peig*peig; aux1 = aux*peig; aux = aux*Sqrt(peig);
        sigtot = 0;
        DO k=1,nne(medium) [
            iZ = int( zelem(medium,k) + 0.5 );
            IF( iZ < 1 | iZ > $MXELEMENT ) [
                $egs_info(*,' Error in PHOTO: ');
                $egs_fatal(*,'   Atomic number of element ',k,
                   ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
            ]
            IF( peig > edge_energies(1,iZ) ) [
                j = 1;
                sigma = (edge_a(1,iZ) + edge_b(1,iZ)/peig +
                     edge_c(1,iZ)/aux + edge_d(1,iZ)/aux1)/peig;
            ]
            ELSE [
                DO j=2,edge_number(iZ) [
                    IF( peig >= edge_energies(j,iZ) ) EXIT;
                ]
                sigma = edge_a(j,iZ) + gle*(edge_b(j,iZ) + gle*(edge_c(j,iZ) +
                        gle*edge_d(j,iZ) ));
                sigma = Exp(sigma);
            ]
            sigma = sigma * pz(medium,k);
            sigtot = sigtot + sigma;
            probs(k) = sigma;
            ints(k) = j;
        ]
        $RANDOMSET br; br = br*sigtot;
        DO k=1,nne(medium) [
            br = br - probs(k);
            IF( br <= 0 ) EXIT;
        ]
        iZ = int( zelem(medium,k) + 0.5 );
        j  = ints(k);
    ]
    " Now we know the atomic number (iZ) and the energy interval the "
    " photon energy is in (j). It is time to sample the shell the photon "
    " is interacting with. "
    " left for now as before, to be changed!!! "
    IF( peig <= binding_energies($MXSHELL,iZ) )
    [   "Outer shells, no atomic relaxation"
           "EADL relax: Below  M2-shell -> just emit e- "
           iq(np) = -1;
           e(np) = peig + prm;
    ]
    ELSE ["Above  N-shell -> sample the shell the photon is interacting with"
        $RANDOMSET br; /* ftot = 1;  */
        DO k=1,$MXINTER [
            IF( peig > binding_energies(k,iZ) ) [
                IF( br < interaction_prob(k,iZ) ) EXIT;
                br = (br - interaction_prob(k,iZ))/(1-interaction_prob(k,iZ));
            ]
        ]
        "Interaction possible with any shell from k=1 to $MXSHELL"
        "Defaults to $MXSHELL interaction if DO loop completes"
        "****************"
        "EADL APPROACH 1: Do not allow interaction below L3. Deviates"
        "**************** from previous EGSnrc approach as it doesn't"
        "                 generate e- nor x-rays from <M> and <N> shells."
        IF (eadl_relax & k > 4)[
           "No initial vacancy below L3 for now, just emit e-"
           iq(np) = -1;
           e(np) = peig + prm;
        ]
        ELSE["EADL:    Interacts with K,L1..L3 shells"
             "default: Interacts with K,L1..L3,<M>, and <N> shells"
           e_vac = binding_energies(k,iZ);
           e(np) = peig - e_vac + prm; do_relax = .true.;
           iq(np) = -1;
        ]
    ]
]
ELSE [
    e(np) = peig + prm; iq(np) = -1;
]

IF( iq(np) = -1 ) [
    $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
]

"****************"
"EADL APPROACH 2: PE interactions with K, L1...L3,<M> and <N> shells,"
"**************** but vacancies below L3 deposit energy locally. It wont"
"                 produce x-rays from <M> and <N> shells."
"IF ($EADL_RELAX & k > 4)[
"   edep = e_vac; do_relax = .false.;
"]
IF( do_relax ) [
    call relax(e_vac,k,iZ);
]

IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"

;
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"

return;
end;

%E
"******************************************************************"
subroutine egs_shellwise_photo;
"******************************************************************"
" Derived from PHOTO by I. Kawrakow and A.F. Bielajew              "
" Shellwise implementation and      "
"                                sampling optimizations            "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-PHOTO; "default replacement is:
              "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
                  "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"
;COMIN/PE-SHELL-DATA/;

$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
$DEFINE-LOCAL-VARIABLES-PHOTO;
$REAL slope, logE, int_prob;
$INTEGER zpos, ibsearch;
data n_warning/0/;

NPold = NP;      "Set the old stack counter"
PEIG=E(NP); irl = ir(np);
do_relax = .false.;
IF( peig < $RELAX-CUTOFF ) [
    IF( n_warning < 100 ) [
        n_warning = n_warning + 1;
        $egs_info(*,' Subroutine egs_shellwise_photo called with E = ',
                    peig,' which is below the current min. energy of ',
                   $RELAX-CUTOFF,' keV! ');
        $egs_info(*,' Converting now this photon to an electron, ');
        $egs_info(*,' but you should check your code! ');
    ]
    iq(np) = -1;
    e(np) = peig + prm;
    return;
]

edep = pzero;

IF( iedgfl(irl) ~= 0 ) [" User requested atomic relaxations "
                        " sample element and atomic shell for"
   j = -1;              " the interaction."
   IF( nne(medium) = 1 ) [
    iZ = int( zelem(medium,1) + 0.5 ); zpos = pe_zpos(iZ);
    IF( pe_nshell(zpos) > 0) [
      logE = log(peig);
      j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
    ]
   ]
   ELSE [
      $RANDOMSET br; logE = log(peig);
      "DO k=1,nne(medium) ["
      DO k=nne(medium),1,-1 [
          iZ = int( zelem(medium,k) + 0.5 );zpos = pe_zpos(iZ);
          IF( iZ < 1 | iZ > $MXELEMENT ) [
              $egs_info(*,' Error in egs_shellwise_photo: ');
              $egs_fatal(*,'   Atomic number of element ',k,
                 ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
          ]
          j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
          slope    = pe_elem_prob(j+1,k,medium) - pe_elem_prob(j,k,medium);
          slope    = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
          int_prob = pe_elem_prob(j,k,medium)+slope*(logE-pe_energy(j,zpos));
          br -= exp(int_prob);
          IF ( br <= 0 ) EXIT;
      ]
   ]
   " Now we know the atomic number (iZ) and the energy interval the "
   " photon energy is in (j). It is time to sample the shell the photon "
   " is interacting with. "
   IF( peig < pe_be(zpos,pe_nshell(zpos)) | pe_nshell(zpos) = 0 )
   [   "no atomic relaxation, create photo-electron"
         iq(np) = -1;
         e(np) = peig + prm;
   ]
   ELSE ["sample the shell the photon is interacting with"
      $RANDOMSET br; sigtot = 0;
      DO k=1,pe_nshell(zpos) [
          IF( peig > pe_be(zpos,k) ) [
            slope = pe_xsection(j+1,zpos,k) - pe_xsection(j,zpos,k);
            slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
            int_prob=pe_xsection(j,zpos,k)+slope*(logE-pe_energy(j,zpos));
            br -= exp(int_prob); sigtot += exp(int_prob);
            IF ( br <= 0 ) EXIT;
          ]
      ]
      IF (k > pe_nshell(zpos))["outer shell, create photo-electron"
         iq(np) = -1;
         e(np) = peig + prm;
      ]
      ELSE[
         e_vac = pe_be(zpos,k);
         e(np) = peig - e_vac + prm; do_relax = .true.;
         iq(np) = -1;
      ]
   ]
]
ELSE ["No atomic relaxations, just create photo-electron"
    e(np) = peig + prm; iq(np) = -1;
]

IF( iq(np) = -1 ) [
    $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
]

IF( do_relax ) [
    call egs_eadl_relax(iZ,k);
]

IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"

;
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"

return;
end;

"*************************************************************************"
subroutine egs_read_shellwise_pe;
"*************************************************************************"

$IMPLICIT-NONE;

$declare_max_medium;
$COMIN-SHELLWISE-PE-INIT;

$INTEGER   lnblnk1,egs_get_unit,pe_sw_unit,ounit,egs_open_file;
$INTEGER   sorted($MXELEMENT),i,j,k,l,m;
$REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
$REAL      rest_xs($MXNE,$MXELEMENT);
$REAL      tmp_e($MXNE,$MXPESHELL), tmp_xs($MXNE,$MXPESHELL);
$REAL      new_e($MXNE),deltaEb,slope;
$INTEGER   zread($MXELEMENT),ib($MXPESHELL),ibsearch;
character  data_dir*128,pe_sw_file*144;

$INTEGER  medio,iZ,iZpos,egs_read_int,pos,curr_rec;
real*4    egs_read_real,e_r, e_old,sigma_r;
integer*2 nz, egs_read_short,ish, i_nshell,i_nge;
$LOGICAL  is_open, is_there, shift_required;

character*3 labels(16);
data labels/'  K',' L1',' L2',' L3',
            ' M1',' M2',' M3',' M4',' M5',
            ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/;

/*********************************************
   Open PE shellwise data file photo_shellwise.data
 **********************************************/
$egs_info('(/a$)',
' Reading renormalized photoelectric cross sections ......');
data_dir = $cstring(hen_house) // 'data' // $file_sep;
pe_sw_file = $cstring(data_dir) // 'photo_shellwise.data';

/* Open a fortran unit for reading data */
pe_sw_unit = egs_get_unit(0);
IF( pe_sw_unit < 1 ) [
  $egs_fatal(*,'egs_init_shellwise_pe: failed to get a free Fortran I/O unit');
]
open(pe_sw_unit,file=pe_sw_file,status='old',
     form='UNFORMATTED',ACCESS='direct',recl=1,
     err=:no-pe-sw-file:);
GOTO :read-pe-sw:;
:no-pe-sw-file:
$egs_fatal('(2a)','egs_init_shellwise_pe: failed to open ',
           pe_sw_file);
:read-pe-sw:
is_open = .true.;
/******************************
   Array initialization
 ******************************/
DO medio = 1,nmed [
   DO i=1,nne(medio) [
      pe_nshell(i*medio) = 0;
      pe_nge(i*medio) = 0;
      pe_zsorted(i,medio) = 0;
   ]
]
DO l = 1,$MXELEMENT [
   pe_zpos(l) = -1;
   DO k = 1,$MXNE [
      pe_energy(k,l) = 0.0;
      DO m = 1,$MXPESHELL [
         pe_xsection(k,l,m) = 0.0;
      ]
   ]
   DO k = 1,$MXPESHELL [
      pe_be(l,k) = -99;
   ]
]

/******************************
   Get shellwise PE xsections
 ******************************/
curr_rec = 1; iZpos = 0;
nz = egs_read_short(pe_sw_unit,curr_rec);
"$egs_info('(a,i2,a)','PE shellwise data available for ',nz,' elements....');"
DO medio = 1,nmed [
   DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
   call egs_heap_sort(nne(medio),z_sorted,sorted);
   DO i=1,nne(medio) [pe_zsorted(i,medio) = z_sorted(i);]
   DO i=1,nne(medio) [
      iZ = z_sorted(i);
      "Now check whether we have already loaded the data for"
      "this atomic number"
      is_there = .false.;
      DO j = 1,medio-1 [
         DO k = 1, nne(j)[
           IF( iZ = pe_zsorted(k,j) ) [
               is_there = .true.; EXIT;
           ]
         ]
      ]
      IF (is_there) NEXT;
      "Read data for this element"
      iZpos += 1; zread(iZpos) = iZ;
      pe_zpos(iZ) = iZpos;
      pos         = 3 + (iZ-1)*4;
      curr_rec    = egs_read_int(pe_sw_unit,pos) + 1;
      i_nge       = egs_read_short(pe_sw_unit,curr_rec);
      i_nshell    = egs_read_short(pe_sw_unit,curr_rec);
      "$egs_info('(a,i2,a,i3,a,i2,a)','Element ',iZ,' has ',i_nge,
      "  ' energy points and ',i_nshell,' shells');
      pe_nge(iZpos) = i_nge; pe_nshell(iZpos) = i_nshell;
      e_old = -1.0; ish = 0;
      DO j = 1,i_nge[
         e_r = egs_read_real(pe_sw_unit,curr_rec);
         sigma_r = egs_read_real(pe_sw_unit,curr_rec);
         pe_energy(j,iZpos) = e_r;
         pe_xsection(j,iZpos,0) = sigma_r;
         rest_xs(j,iZpos) = sigma_r;
         DO k = 1, i_nshell[
            sigma_r =  egs_read_real(pe_sw_unit,curr_rec);
            pe_xsection(j,iZpos,k) = sigma_r;
            rest_xs(j,iZpos) = rest_xs(j,iZpos) - sigma_r;

         ]
         "Extract binding energies from the data base"
         IF (e_r - e_old < 1e-15)[
            pe_be(iZpos,i_nshell-ish) = e_r;
            ish += 1;
         ]
         e_old = e_r;

      ]
      "DO k = 1, i_nshell[
      "   $egs_info('(a2,a3,a2,1pe12.4,a4)',
      "             'E(',labels(k),')=',pe_be(iZpos,k),' MeV');
      "]

   ]
]
pe_ne = iZpos;
"$egs_info('(a,i2,a/)','Finished processing ',iZpos,' elements!');

/*********************************************
 Adjust xsections to current binding energies
 Shift energy scale for each subshell when
 required.
 *********************************************/
"$egs_info(*,' Adjusting cross sections to new binding energies ...');
DO i=1,pe_ne[
   iZ = zread(i);
   IF (pe_nshell(i) = 0)[
      DO j=1,pe_nge(i)[
         pe_energy(j,i) =  log(pe_energy(j,i));
      ]
      NEXT;
   ]
   "Shift energy scale for different binding energy sets"
   DO l=1,pe_nshell(i)[
      IF ( pe_be(i,l) ~= binding_energies(l,iZ))[
           shift_required = .true.;
           deltaEb = binding_energies(l,iZ)-pe_be(i,l);
           "$egs_info('(2(a,a,a,1pe12.4),a,1pe12.4,a,e12.4)',
           "           'Eb_p_',labels(l),' = ',pe_be(i,l),
           "          ' Eb_e_',labels(l),' = ',binding_energies(l,iZ),
           "          ' diff = ',pe_be(i,l)-binding_energies(l,iZ),
           "          ' -> ', 100*(1.0 - binding_energies(l,iZ) / pe_be(i,l))
           "          );
      ]
      ELSE[shift_required =.false.;]
      is_there = .false.;
      DO j=1,pe_nge(i)[
         tmp_e(j,l)  = pe_energy(j,i);
         tmp_xs(j,l) = pe_xsection(j,i,l);
         IF ( shift_required &
              pe_energy(j,i) => pe_be(i,l) )[
            tmp_e(j,l) += deltaEb;
            "$egs_info(*,'Shifting ',pe_energy(j,i),' to ',tmp_e(j,l));
            "Determine edge position in energy array"
            IF (pe_energy(j,i) = pe_be(i,l) & ~is_there)[
               ib(l) = j; is_there = .true.;
            ]
            "Update new energy grid"
            IF (l = 1)[
               new_e(j) = tmp_e(j,l);
            ]
            "ELSE IF(tmp_e(j,l) < binding_energies(l-1,iZ))[
            ELSE IF(j < ib(l-1))[
               new_e(j) = tmp_e(j,l);
            ]
         ]
      ]
      pe_be(i,l) = binding_energies(l,iZ);
   ]
   "Re-compute sub-shell xsections for new energy grid new_e"
   "Not needed for K shell"
   DO l=2,pe_nshell(i)[
      DO j=1,pe_nge(i)[
         IF ( new_e(j) >= pe_be(i,l-1) )[
            m = ibsearch(new_e(j),pe_nge(i),tmp_e(1,l));
            slope = log(tmp_xs(m+1,l)/tmp_xs(m,l));
            slope = slope/log(tmp_e(m+1,l)/tmp_e(m,l));
            pe_xsection(j,i,l) = log(tmp_xs(m,l));
            pe_xsection(j,i,l) += slope*log(new_e(j)/tmp_e(m,l));
            pe_xsection(j,i,l) = exp(pe_xsection(j,i,l));
         ]
      ]
   ]
   "Re-compute total xsections for new energy grid new_e"
   "$egs_info(*,'-> Z = ',iZ);"
   DO j=1,pe_nge(i)[
      IF ( j < ib(pe_nshell(i)))[
         new_e(j) = pe_energy(j,i);
      ]
      m = ibsearch(new_e(j),pe_nge(i),pe_energy(1,i));
      slope = log(rest_xs(m+1,i)/rest_xs(m,i));
      slope = slope/log(pe_energy(m+1,i)/pe_energy(m,i));
      pe_xsection(j,i,0)  = log(rest_xs(m,i));
      pe_xsection(j,i,0) += slope*log(new_e(j)/pe_energy(m,i));
      pe_xsection(j,i,0) = exp(pe_xsection(j,i,0));
      "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4,1x,1pe12.4)',
      "         new_e(j),pe_xsection(j,i,0),pe_energy(j,i),rest_xs(j,i));
      DO l=1,pe_nshell(i)[
         pe_xsection(j,i,0) += pe_xsection(j,i,l);
      ]
      "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4)',
      "         new_e(j),pe_xsection(j,i,0));
   ]
   "Normalize shell cross sections to total for sampling"
   "and update energy grid of ith element."
   " Prepare for log/log interpolation."
   DO j=1,pe_nge(i)[
      pe_energy(j,i) =  log(new_e(j));
      DO l=1,pe_nshell(i)[
         pe_xsection(j,i,l) = log(pe_xsection(j,i,l)/pe_xsection(j,i,0));
      ]
   ]
]

$egs_info('(a/)',' done');

IF( is_open ) close(pe_sw_unit);
return;
end;


"******************************************************************"
SUBROUTINE RELAX(energy,n,iZ);
"******************************************************************"
" Subroutine to fill a vacancy in shell n, element iZ              "
" by emitting fluorescent X-rays, Auger and Coster-Kronig electrons"
" Transitions between K,L1,L2,L3,average M,average N are taken into"
" account. Particles with energies above the transport cut-offs    "
" (ECUT and PCUT) are placed on the stack, energy of sub-threshold "
" particles is stored in EDEP.                                     "
" In this version a global cut-off of 1 keV applies                "
"  i.e. if ECUT-RM or PCUT is below 1 keV, binding energies below  "
"  1 keV will still be absorbed locally (due to lack of data)      "
"                                                                  "
" Version 1:  I. Kawrakow, December 1998                           "
"******************************************************************"
implicit none;

" Input variables "
"================="
$INTEGER n,iZ;
$REAL    energy;  "

$declare_write_buffer;

" Local variables "
"================="
REPLACE {$MXVAC} WITH {50}  "Maximum number of vacancies during the"
                            "relaxation cascade                    "

$INTEGER vac_array($MXVAC), "array with shell vacancies            "
         n_vac,             "current number of vacancies           "
         shell;             "current shell                         "
$INTEGER final,finala,      "code of final state                   "
         final1,final2,     "two vacancies in the final state in   "
                            "the case of Auger transitions         "
         iql,               "particle charge                       "
         irl;               "present region"
$INTEGER first_transition($MXINTER),
         last_transition($MXINTER);
                            "first and last transition for a given "
                            "shell in the list of all possible     "
                            "transitions                           "
$INTEGER final_state($MXTRANS);
           " final_state(i) is the final atomic state                "
           " after transition i coded as follows:                    "
           "   * fluorescence - final_state is the shell number      "
           "                    of the new vacancy                   "
           "   * Coster-Kronig - final_state is the shell number     "
           "                     of the new vacancy + 10             "
           "   * Auger - final_state is n1 + 100*n2 where n1 and n2  "
           "             are the shell numbers of the 2 new vacancies"

$INTEGER k, np_old, ip, iarg;
$REAL    e_array($MXVAC),   "array with vacancy energies           "
         Ei,Ef,             "initial,final binding energies        "
         Ex,                "kinetic energy of emitted particle    "
         eta,               "a random number                       "
         e_check,           "energy conservation check             "
         min_E,ekcut,pkcut,elcut; "cut-off energies  "

$REAL    xphi,yphi,xphi2,yphi2,rhophi2,
         cphi,sphi;         "for azimuthal angle selection"

" Global EGS4 variables "
"======================="
$COMIN-RELAX;
;COMIN/RELAX-USER/;

data first_transition/1,20,27,33,38/;
data last_transition/19,26,32,37,39/;
data final_state/ "See the final_state definition above"
         4,3,5,6,                           " K-shell fluorescence    "
         202,302,402,404,403,303,           " K-shell Auger           "
         502,503,504,602,603,604,           " K-shell Auger           "
         505,605,606,                       " K-shell Auger           "
         13,14,                             " L1 Coster-Kronig        "
         5,6,                               " L1 fluorescence         "
         505,605,606,                       " L1 Auger                "
         14,                                " L2 Coster-Kronig        "
         5,6,                               " L2 fluorescence         "
         505,605,606,                       " L2 Auger                "
         5,6,                               " L3 fluorescence         "
         505,605,606,                       " L3 Auger                "
         6,                                 " M  fluorescence         "
         606/;                              " M  Auger                "

save first_transition,last_transition,final_state; "to avoid problems with "
                                                   "non-static compiler options"

IF (eadl_relax)[
   call egs_eadl_relax(iZ,n);
   return;
]

IF( n < 1 | n > $MXSHELL ) [ return; ] "unknown vacancy"

iz_relax = iZ;
irl = ir(np);
ekcut = ecut(irl)-rm; pkcut = pcut(irl);
min_E = $RELAX-CUTOFF;

IF( energy <= min_E ) [
    edep = edep + energy;  "We assume that edep is zeroed "
                        "(or set to the appropriate value) in the routine "
                        "calling RELAX "
    edep_local = energy;

    "Assign this energy deposition to an electron."
    "Note that this should NOT be treated as though it came from a photon,"
    "even if a photon initiated the relaxations. Rather, energy remaining"
    "in vacancies should be given to an electron or absorbed locally."
    $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

    return;
]

" Set-up the array of vacancies for the relaxation cascade "
n_vac = 1; vac_array(n_vac) = n; np_old = np;
e_check = 0; e_array(n_vac) = energy;

:START: LOOP[     "Until no  >N-shell vacancies"

    shell = vac_array(n_vac); Ei = e_array(n_vac); n_vac = n_vac - 1;

    IF( Ei <= min_E ) [  " Below cut-off -> local absorption "
        edep = edep + Ei;

        edep_local = Ei;

        "Assign this energy deposition to an electron."
        "Note that this should NOT be treated as though it came from a photon,"
        "even if a photon initiated the relaxations. Rather, energy remaining"
        "in vacancies should be given to an electron or absorbed locally."
        $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

        IF( n_vac > 0 ) goto :START: ;
        EXIT;
    ]

    "Set the relax_user common block variables, IK March 22 2004"
    ish_relax = shell; u_relax = Ei;
    IF( shell = $MXSHELL ) [ "This is N-shell vacancy -> just produce Auger"
        IF( Ei > ekcut ) [
            np = np + 1;
            $CHECK-STACK(np,'RELAX');
            e(np) = Ei + prm; iq(np) = -1;
            $TRANSFER PROPERTIES TO (np) FROM (np-1);
            $RANDOMSET eta; eta = 2*eta - 1; w(np) = eta;
            eta = (1-eta)*(1+eta);
            IF( eta > 1e-20 ) [
                eta = Sqrt(eta);
                $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
                u(np) = eta*cphi; v(np) = eta*sphi;
            ]
            ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
            $AUSCALL($AUGERTRA);
        ]
        ELSE             [
            edep = edep + Ei;

            edep_local = Ei;
            $AUSCALL($SELECTRONA);
        ]
        IF( n_vac > 0 ) goto :START: ;
        EXIT;
    ]
    " Sample transition number for this vacancy "
    $RANDOMSET eta;
    DO k=first_transition(shell),last_transition(shell)-1 [
        eta = eta - relaxation_prob(k,iZ);
        IF( eta <= 0 ) EXIT;
    ]
    final = final_state(k); finala = final;
    IF( final < 100 ) [
        IF( final < 10 ) [ "fuorescence"
            iql = 0; elcut = pkcut;
        ]
        ELSE             [ "Coster-Kronig"
            final = final - 10;
            iql = -1; elcut = ekcut;
        ]
        Ef = binding_energies(final,iZ);
        Ex = Ei - Ef;
        n_vac = n_vac + 1;
        vac_array(n_vac) = final;
        e_array(n_vac) = Ef
    ]
    ELSE [  "Auger"
        final1 = final/100; final2 = final - final1*100;
        n_vac  = n_vac + 1;
        vac_array(n_vac) = final1;
        e_array(n_vac) = binding_energies(final1,iZ);
        n_vac  = n_vac + 1;
        vac_array(n_vac) = final2;
        e_array(n_vac) = binding_energies(final2,iZ);
        iql = -1;
        Ex = Ei - e_array(n_vac) - e_array(n_vac-1);
        elcut = ekcut;
    ]
    IF( Ex <= elcut ) [ "Below cut-off"
        edep = edep + Ex;

        IF( finala <  10 ) [
            edep_local = Ex;
            $AUSCALL($SPHOTONA);
        ]
        ELSE [
            edep_local = Ex;
            $AUSCALL($SELECTRONA);
        ]
    ]
    ELSE [
        np = np + 1;
        $CHECK-STACK(np,'RELAX');
        iq(np) = iql;
        IF( iql = 0 ) [ e(np) = Ex; ] ELSE [ e(np) = Ex + rm;]
        $TRANSFER PROPERTIES TO (np) FROM (np-1);
        $RANDOMSET eta;
        eta = 2*eta - 1;
        w(np) = eta;
        eta = (1-eta)*(1+eta);
        IF( eta > 1e-20 ) [
            eta = Sqrt(eta);
            $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
            u(np) = eta*cphi;
            v(np) = eta*sphi;
        ]
        ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
        IF     ( finala <  10 ) [ $AUSCALL($FLUORTRA);  ]
        ELSE IF( finala < 100 ) [ $AUSCALL($COSKROTRA); ]
        ELSE                    [ $AUSCALL($AUGERTRA);  ]
    ]
]

return;
end;

"*************************************************************************"
subroutine egs_init_relax;
"*************************************************************************"
" Reads EADL atomic relaxation data from $HEN_HOUSE/data/relax.data. This "
" data base was originally created by I. Kawrakow to be used with C++ user"
" codes. It has been re-created using 4 bytes integers instead of using   "
" optimized integer sizes to save space. It is now about 34% larger (760K)"
" than before (557K). Reason for this was that some compilers need a switch"
" to get it to read binary files on byte at a time. This would have been a"
" nuisance for users when configuring the already complex system.         "
"                                                                        "
" The final relaxation state from radiative transitions assumes C-style  "
" array indexing and hence needs to be increased by 1.                   "
" Similarly, for non-radiative transitions, there is need to increase the"
" codified value of the two electron states by 65. The reason is that the"
" two transition states are encoded as 64*state1+state2. Because of the C"
" style indexing, state1 and state2 must be increased by 1, increasing the"
" above codified value by 65.                                            "
"                                                                        "
"Shell information for all media elements stored in one-dimensional arrays:"
"                                                                        "
" ish              => absolute shell index (1...shell_ntot)              "
" shell_be(ish)    => shell binding energy                               "
" shell_type(ish)  => shell type according to EADL notation              "
" shell_Z(ish)     => Z of shell element                                 "
" shell_num(ish)   =>  relative shell position within one element        "
" shell_ntot       => total number of shells for all media elements      "
" relax_first(ish) => initial absolute relaxation position               "
" relax_ntran(ish) => number of transitions                              "
" shell_eadl(Z,shell_num(ish)) => absolute shell position for element Z  "
"                                                                        "
"Transition information for all shells also stored in one-dimensional arrays:"
"                                                                         "
" transition index itran runs from 1...relax_ntot                         "
" relax_prob(itran)  => transition probabilities                          "
" relax_atbin(itran) => holds the alias indices                           "
" relax_state(itran) => final relaxation state:                           "
"                       radiative: relative shell position                "
"                   non-radiative: relative position of shells(64*sh1+sh2)"
"                                                                         "
"                              Originally coded by IK in a standalone code"
"                          Modified for use with EGSnrc by EMH, June 2011 "
"                          Corrected bugs and commented by EMH, April 2012"
"*************************************************************************"
$IMPLICIT-NONE;

$declare_max_medium;
$COMIN-RELAX-INIT;

$INTEGER   lnblnk1,egs_get_unit,relax_unit,ounit,egs_open_file;
$INTEGER   sorted($MXELEMENT),i,j,k,k1,k2,m;
$REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
character  data_dir*128,relax_file*144;

$INTEGER  ish,medio,iZ,ntran;
$REAL     Ec, Pc, tmp, min_be, sumw,Ex;
$LOGICAL  is_open, is_there;
$REAL     wtmp($MAXTRANS);
$INTEGER  itmp($MAXTRANS);

integer*4 pos, curr_rec, sh_eadl;
integer*4 nz, nshell, tr_type;
integer*4 ttype;
real*4    be_r, prob_r;


DO iZ=1,$MXELEMENT[
 DO k=1,$MXESHLL[
   shell_eadl(iZ,k) = -1;
 ]
]

/*********************************************
   Determine minimum energy
 **********************************************/
/*Pc = 1e30; Ec = 1e30;
DO medio = 1,nmed [
    tmp = AE(medio) - rm; Ec = min(Ec,tmp); Pc = min(Pc,ap(medio));
]
min_be = min(Ec,Pc);  "This is the minimum binding energy for which we need"
                      "relaxation data"
*/
min_be = $RELAX-CUTOFF;
$egs_debug('(a)',' ************ relax_init **************** ');
$egs_debug('(a,f10.7)',
        ' Minimum binding energy requiring relaxation data: ',min_be);

/*********************************************
   Open EADL relaxation data file relax.data
 **********************************************/
$egs_info('(/a)',' Reading EADL relaxation data ......');
data_dir = $cstring(hen_house) // 'data' // $file_sep;
relax_file = $cstring(data_dir) // 'relax.data';

/* Open a fortran unit for reading relaxation data */
relax_unit = egs_get_unit(0);
IF( relax_unit < 1 ) [
   $egs_fatal(*,'egs_init_relax: failed to get a free Fortran I/O unit');
]
open(relax_unit,file=relax_file,status='old',
     form='UNFORMATTED',ACCESS='direct',recl=$RECL-FACTOR,
     err=:no-relax-file:);
GOTO :read-relax:;
:no-relax-file:
$egs_fatal('(2a)','egs_init_relax: failed to open ',
           relax_file);
:read-relax:
is_open = .true.;
/*********************************************
   Get EADL relaxation data from relax.data
 **********************************************/
curr_rec = 1;
read(relax_unit,rec=curr_rec) nz;
"$egs_info('(a,i2,a)','Relaxation data for ',nz,' elements....');"
shell_ntot = 0;relax_ntot = 0;
DO medio = 1,nmed [
   DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
   call egs_heap_sort(nne(medio),z_sorted,sorted);
   DO i=1,nne(medio) [
      iZ = z_sorted(i);
      "Now check whether we have already loaded the data for"
      "this atomic number"
      is_there = .false.;
      DO j = 1,shell_ntot [
         IF( iZ = shell_Z(j) ) [ is_there = .true.; EXIT; ]
      ]
      IF (is_there) NEXT;
      pos = iZ + 1;
      read(relax_unit,rec=pos) curr_rec;
      read(relax_unit,rec=curr_rec) nshell;
      IF( shell_ntot + nshell > $MAXSHELL ) [
         $egs_fatal('(a,i5,a/,a//)',' Too many shells to fit in the list: ',
                shell_ntot + nshell,' (at least).',
                ' Increase the parameter $MAXSHELL and retry ');
      ]
      $egs_info('(a,i3,a,i2,a)',
      '  Z = ',iZ,' has ',nshell,' shells');
      DO ish=shell_ntot+1,shell_ntot+nshell[
        curr_rec  = curr_rec+1;
        read(relax_unit, rec=curr_rec) shell_type(ish);
        curr_rec  = curr_rec+1;
        read(relax_unit, rec=curr_rec) ntran;
        curr_rec  = curr_rec+1;
        read(relax_unit, rec=curr_rec) be_r; shell_be(ish) = be_r;

        shell_Z(ish) = iZ;
        shell_num(ish) = ish - shell_ntot;
        shell_eadl(iZ,shell_num(ish)) = ish;
        IF (binding_energies(shell_num(ish),iZ) > 0)[
           shell_be(ish) = binding_energies(shell_num(ish),iZ);
        ]
        ELSE IF( photon_xsections = 'epdl' )[
          "Use binding energies from relax.data below 1 keV"
           binding_energies(shell_num(ish),iZ) = shell_be(ish);
        ]
        DO k=1,ntran[
            curr_rec  = curr_rec+1;
            read(relax_unit,rec=curr_rec) itmp(k);
            curr_rec  = curr_rec+1;
            read(relax_unit,rec=curr_rec) prob_r;wtmp(k)=prob_r;
            /*Relaxation data uses C-style array indexing.
              Hence final relaxation state increased by 1  for
              radiative and by 65 for non-radiative transitions*/
            IF (itmp(k)<64) [itmp(k) +=1;]
            ELSE            [itmp(k) += 65;]
        ]
        IF( shell_be(ish) < min_be ) [
            relax_first(ish) = -1;
            relax_ntran(ish) = -1;
        ]
        ELSE [
            sumw = 0;
            DO k=1,ntran [  sumw = sumw + wtmp(k); ]
            IF( sumw > 1 ) [
                DO k=1,ntran [  wtmp(k) = wtmp(k)/sumw; ]
            ]
            ELSE IF( sumw < 1 ) [
                ntran = ntran + 1; itmp(ntran) = -1; wtmp(ntran) = 1-sumw;
            ]
            IF( relax_ntot + ntran > $MAXRELAX ) [
               $egs_fatal('(a,i5,a/,a/)',' Too many relaxation transitions: ',
                 relax_ntot + ntran,' (at least).',
                 ' Increase $MAXRELAX and retry ');
            ]
            relax_first(ish) = relax_ntot+1; relax_ntran(ish) = ntran;
            call prepare_alias_histogram(ntran,wtmp,
                                 relax_atbin(relax_ntot+1));
            DO k=1,ntran [
               j = relax_ntot + k;
               relax_state(j) = itmp(k); relax_prob(j) = wtmp(k);
            ]
            relax_ntot = relax_ntot + ntran;
        ]
      ]

      shell_ntot = shell_ntot + nshell;

   ]

]
$egs_debug('(a,i4,a)',' There are ',
        shell_ntot,' shells in the list of shells ');
$egs_info('(a/)',' ...... Done.');
/***********************************************/

IF( is_open ) close(relax_unit);
return;

stop;
end;

"Macro to check that the stack size is not exceeded"
REPLACE {$CHECK-RELAX-STACK(#,#);} WITH {;
  IF( {P1} > $MXSTACK ) [
      $egs_warning('(3(a,f10.6),a,i2)',
       'Evac = ',Evac, ' Ef = ',Ef,
       "' Z = ',iZ,' Nvac = ',Nvac,"
       ' min_E = ', min_E,' iq = ',iqf);
;  "---------- BUFFER FLUSH SEMICOLON ----------"
      $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
          ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
          ' Increase $MXSTACK and try again ');
  ]
};

"***********************************************************************"
  subroutine egs_eadl_relax(iZ, shell_egs);
"************************************************************************"
" Subroutine, called from subroutine relax, to fill a vacancy in         "
" shell shell_egs in element iZ by emitting fluorescent X-rays, Auger    "
" and Coster-Kronig electrons.  Uses EADL data.                          "
" Results passed via variables in comins.                                "
"   edep                                                                 "
"   edep_local                                                           "
"   e(np)                                                                "
"                                                                        "
" There are calls to ausgab with IARG values                             "
"   24  A fluorescent transition just occurred                           "
"   26  An Auger transition just occurred                                "
"   32  Sub-threshold fluorescent transition just occurred               "
"   33  Sub-threshold Auger transition just occurred                     "
"                                                                        "
" There is an inconsistency in the binding energies (BE) as COMPT uses   "
" different BE (incoh.data)                                              "
"                                                                        "
" Explain need to reduce new_state by 1 below as alias sampling provides "
" bin number from 1...nbin and not 0...nbin-1                            "
"                                                                        "
"                             Originally coded by IK in a standalone code"
"                         Modified for use with EGSnrc by EMH, June 2011 "
"                         Corrected bugs and commented by EMH, April 2012"
"************************************************************************"

$IMPLICIT-NONE;

$declare_max_medium;
$COMIN-RELAX-EADL;
;COMIN/RELAX-USER/;

$REAL    Ec,Pc,min_E,rnno,Evac,Ef,Ef1,Ef2,Ex,Ecc,
         cost,sint,cphi,sphi;
"Ec      ecut as k.e. for current region"
"Pc      pcut for current region"
"min_E   the minimum energy for transitions to continue"
"rnno    a random number"
"Evac    binding energy of current vacancy"
"Ef      the sum of the binding energies of the new vacancies"
"Ef1     the first new binding energy of for non-radiative transitions"
"Ef2     the second new binding energy of for non-radiative transitions"
"Ex      the change in total binding energy"
"Ecc     the cutoff energy (Ec or Pc)"
"cost,sint,cphi,sphi variables for calculating particle direction"

$INTEGER  shell, shell_egs, iZ, iarg;
"shell       number in master eadl list"
"shell_egs   shell number in current element"
"iZ          atomic number of element"

$INTEGER  irl,vacs($MAXVAC),nvac,vac,new_state,iqf,np_save,new1,new2;
"irl           current region"
"vacs($MAXVAC) array of vacancy shell numbers"
"nvac          current number of vacancies in vacs"
"vac           shell number of current vacancy"
"new_state     the state number that represents the new vacancy"
"iqf           the charge of the emitted relaxation particle"
"np_save       the stack index of the particle inducing in relaxations"
"new1          the first new vacancy for non-radiative transitions"
"new2          the second new vacancy for non-radiative transitions"

$INTEGER sample_alias_histogram;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;

shell = shell_eadl(iZ,shell_egs);
IF( shell < 1 | shell > $MAXSHELL ) [ return; ] "unknown vacancy"

irl = ir(np);
Ec = ecut(irl) - rm;
Pc = pcut(irl);
min_E = $RELAX-CUTOFF;

Evac = shell_be(shell); "provides relevant binding energy for this vacancy"
"store some information in comin RELAX-FOR-USER.  This just duplicates"
"various pieces of info so the user can access them."
rfu_Z  = shell_Z(shell); "Z of element the relaxing shell belongs to"
rfu_j0 = shell;         "shell # of vacancy that initiated cascade in long list"
rfu_n0 = shell_num(shell); "same but number is shell number in element iZ"
rfu_t0 = shell_type(shell); "the shell type (encodes the type of relaxation)"
rfu_E0 = Evac;          "B.E. of vacancy that initiated cascade"
"
"Local energy deposition for vacancies below L3 shell."
"Added here for consistency in algorithm for as long as"
"<M> and <N> shells considered instead of proper shells."
"AUSGAB call should be updated when charge of particle"
"creating vacancy becomes available."
IF (shell_egs > 4 & ~mcdf_pe_xsections) [
    edep = Evac;        "add energy of vacancy to edep"
    edep_local = Evac;  "set value of edep_local to energy of vacancy"

    "Assign this energy deposition to an electron."
    "Note that this should NOT be treated as though it came from a photon,"
    "even if a photon initiated the relaxations. Rather, energy remaining"
    "in vacancies should be given to an electron or absorbed locally."
    $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

    return; "invokes $AUSCALL($PHOTXAUS) in COMPT;"
]

vac = shell; Nvac = 0; np_save = np;
LOOP [ "from here to end of routine over all vacancies created"

    "check if energy of vacancy < cutoff OR no transitions from this shell"
    IF( Evac < min_E | relax_ntran(vac) < 1 ) [
        edep += Evac;         "add energy of vacancy to edep"
        edep_local = Evac;    "set value of edep_local to energy of vacancy"

        "Assign this energy deposition to an electron."
        "Note that this should NOT be treated as though it came from a photon,"
        "even if a photon initiated the relaxations. Rather, energy remaining"
        "in vacancies should be given to an electron or absorbed locally."
        $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

        go to :VACANCY:;      "exit loop and if Nvac still 0, exit routine"
    ]

    "prepare_alias_histogram is called from subroutine egs_init_relax and"
    "sample_alias_histogram uses the array of bin probabilities and bin"
    "numbers relax_prob(relax_first(vac) and relax_atbin(relax_first(vac))"
    "to return the bin which has been sampled, i.e. new_state"
    "relax_ntran(vac) tells how many transitions are available"
    new_state = sample_alias_histogram(relax_ntran(vac),
                  relax_prob(relax_first(vac)),
                  relax_atbin(relax_first(vac)));
    IF( new_state < 0 ) [ "this may happen if the sum of probabilities from"
                          "EADL was < 1. In this case the entire energy is"
                          "given to an electron and no new vacancy is created"
        Ef = 0;
        iqf = -1;
        Ecc = Ec;
    ]
    ELSE[
        new_state = relax_state(relax_first(vac)+new_state-1);
        IF( new_state <= 64 ) [ "It was a radiative transition (fluorescence)"
          iqf = 0;
          new_state += vac - shell_num(vac);
          Ef = shell_be(new_state);
          Nvac += 1;
          vacs(Nvac) = new_state;
          Ecc = Pc;
        ] "end of fluorescence block"
        ELSE [ "It was a non-radiative transition (Auger or Coster-Kronig)"
          iqf = -1; new1 = new_state/64; new2 = new_state - 64*new1;
          new1 += vac - shell_num(vac); new2 += vac - shell_num(vac);
          Ef1 = shell_be(new1); Ef2 = shell_be(new2);
          Nvac += 1; vacs(Nvac) = new1;
          Nvac += 1; vacs(Nvac) = new2;
          Ef = Ef1 + Ef2; Ecc = Ec;
        ] "end Auger or Coster-Kronig block"
    ]
    Ex = Evac - Ef;
    edep_local = 0;
    IF( Ex > Ecc ) [
        np += 1; $CHECK-RELAX-STACK(np,'new_relax');
        iq(np) = iqf;
        $TRANSFER PROPERTIES TO (np) FROM (np_save);
        $RANDOMSET rnno; cost = 2*rnno-1; sint = 1-cost*cost;
        IF( sint > 0 ) [
            sint = sqrt(sint);
            $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
            u(np) = sint*cphi; v(np) = sint*sphi; w(np) = cost;
        ] ELSE [ u(np) = 0; v(np) = 0; w(np) = cost; ]
        rfu_j = vac; rfu_n = shell_num(vac); rfu_t = shell_type(vac);
        rfu_E = shell_be(vac);
        IF( iqf = 0 ) [
            e(np) = Ex; $AUSCALL($FLUORTRA);
        ]
        ELSE [
            e(np) = Ex + rm; $AUSCALL($AUGERTRA);
        ]
    ] ELSE [ "Ex <= Ecc"
        edep += Ex;

        IF( iqf = 0 ) [
            edep_local = Ex;
            $AUSCALL($SPHOTONA);
        ] ELSE [
            edep_local = Ex;
            $AUSCALL($SELECTRONA);
        ]
    ] "end Ex <= Ecc block"
    :VACANCY:;
    IF( Nvac = 0 ) EXIT;
    "get next vacancy to process"
    vac = vacs(Nvac); Evac = shell_be(vac); Nvac -= 1;
] "end of main loop"
return;
end;
;

"***************************************************************************"
"     Triplet production stuff                                              "
"***************************************************************************"

REPLACE {$N_TRIPLET_DATA} WITH {55}
REPLACE {$N_ELEMENT} WITH {100}
;
subroutine init_triplet;
implicit none;
$declare_max_medium;
$COMIN-INIT-TRIPLET;
$REAL  energies($N_TRIPLET_DATA), sig_pair($N_ELEMENT,$N_TRIPLET_DATA),
       sig_triplet($N_ELEMENT,$N_TRIPLET_DATA), f_triplet($N_TRIPLET_DATA),
       sigp($N_TRIPLET_DATA), sigt($N_TRIPLET_DATA),
       as($N_TRIPLET_DATA), bs($N_TRIPLET_DATA), cs($N_TRIPLET_DATA),
       ds($N_TRIPLET_DATA);
character*128  triplet_data_file;
$INTEGER want_triplet_unit, triplet_unit, triplet_out;
$INTEGER i, iel, imed, lnblnk1, egs_get_unit, ntrip, iz1, izi, ifirst;
$REAL    logE, f_new, f_old, spline;

IF( itriplet = 0 ) return;
$set_string(triplet_data_file,' ');
triplet_data_file = $cstring(hen_house) // 'data' // $file_sep //
                    'triplet.data';
want_triplet_unit = 63;
triplet_unit = egs_get_unit(want_triplet_unit);
IF( triplet_unit < 1 ) [
    $egs_fatal(*,'init_triplet: failed to get a free Fortran I/O unit');
]
open(triplet_unit,file=triplet_data_file,err=:no-triplet-file:);
$egs_info('(a,$)',' init_triplet: reading triplet data ... ');
read(triplet_unit,*) ntrip;
IF( ntrip > $N_TRIPLET_DATA ) [
    $egs_fatal(*,'Max. number of data points per element is ',$N_TRIPLET_DATA);
]
read(triplet_unit,*,err=:error_triplet_data:) (energies(i),i=1,ntrip);
DO iel=1,$N_ELEMENT [
    read(triplet_unit,*);
    read(triplet_unit,*,err=:error_triplet_data:)
        (sig_pair(iel,i),i=1,ntrip);
    read(triplet_unit,*,err=:error_triplet_data:)
        (sig_triplet(iel,i),i=1,ntrip);
]
$egs_info(*,'OK');
ifirst = 0;
DO i=1,ntrip [
    IF( ifirst = 0 & energies(i) > 4.01*rm ) ifirst = i;
    energies(i) = log(energies(i));
]
log_4rm = log(4*rm);
energies(ifirst-1) = log_4rm;
dl_triplet = (energies(ntrip) - log_4rm)/$MAX_TRIPLET;
dli_triplet = 1/dl_triplet;
bli_triplet = 1 - log_4rm/dl_triplet;

DO imed = 1, nmed [

    $egs_info('(a,i3,a,$)',
      '   Preparing triplet fraction data for medium ',imed,' ... ');
    iz1 = zelem(imed,1) + 0.1;
    DO i=1,ntrip [
        sigp(i) = pz(imed,1)*sig_pair(iz1,i);
        sigt(i) = pz(imed,1)*sig_triplet(iz1,i);
        DO iel=2,nne(imed) [
            izi = zelem(imed,iel) + 0.1;
            sigp(i) = sigp(i) + pz(imed,iel)*sig_pair(izi,i);
            sigt(i) = sigt(i) + pz(imed,iel)*sig_triplet(izi,i);
        ]
    ]

    DO i=ifirst,ntrip [ f_triplet(i-ifirst+2) = sigt(i)/(sigp(i) + sigt(i)); ]
    f_triplet(1) = 0;
    call set_spline(energies(ifirst-1),f_triplet,as,bs,cs,ds,ntrip-ifirst+2);

    logE = log_4rm; f_old = 0;
    DO i=1, $MAX_TRIPLET-1 [
        logE = logE + dl_triplet;
        f_new = spline(logE,energies(ifirst-1),as,bs,cs,ds,ntrip-ifirst+2);
        a_triplet(i,imed) = (f_new - f_old)*dli_triplet;
        b_triplet(i,imed) = f_new - a_triplet(i,imed)*logE;
        f_old = f_new;
    ]
    $egs_info(*,'OK');

]
close(triplet_unit);
return;

:no-triplet-file:;
$egs_fatal('(a,a)',' init_triplet: failed to open the data file ',
             triplet_data_file(:lnblnk1(triplet_data_file)));

:error_triplet_data:;
$egs_fatal(*,' init_triplet: error while reading triplet data ');

return; end;

%E
"******************************************************************"
SUBROUTINE EDGSET(NREGLO,NREGHI);
"******************************************************************"
" SUBPROGRAM TO SET UP PARAMETERS FOR ATOMIC RELAXATIONS           "
" and proper handling of photo-electric absorption
"******************************************************************"
" Programmer:   I. Kawrakow, (NRC)                                 "
"******************************************************************"
"                                                                  "
"  Input:  NREGLO and NREGHI, not needed but left there for        "
"                             compatibility with older user codes  "
"
"  This routine is called from HATCH, it checks whether one of the "
"  elements of IEDGFL has been set to an integer number between    "
"  1 and 100 and if so reads in photo-absorption and relaxation    "
"  data. Note that the array IEDGFL, which used to be the          "
"  `effecvtive' atomic number of a medium is not used for any      "
"  purpose other than to indicate that relaxations are requested   "
"  (if non-zero).
"******************************************************************"
"                                                                  "

$IMPLICIT-NONE;

;COMIN/EDGE,X-OPTIONS,EGS-IO/;

"Input variables"
integer  NREGLO,NREGHI;

$INTEGER i,j,k,jj,iz;
logical  do_relax;
logical  got_data;
save     got_data;
data     got_data/.false./;

IF( got_data ) return;
   "EDGSET is now called from HATCH. In older user codes it was called
   "from within the user code. If this happens, and the data is already
   "available, we don't need to read it again. That's why the above
   "statement.

$egs_info('(a/,a)',
          'Output from subroutine EDGSET:',
          '==============================');

$need_relaxation_data(do_relax);
IF( ~do_relax ) [

    IF(eadl_relax)[
        $egs_fatal('(a,/a)',
                   'You must turn ON atomic relaxations when requesting',
                   'detailed atomic relaxation (eadl_relax=true)!');
    ]
    $egs_info('(a/)',' Atomic relaxations not requested! ');
    return;
]

$egs_info('(a/)',' Atomic relaxations requested! ');

$egs_info('(a$)',' Reading simplified photo-absorption data .....');

got_data = .true.;
rewind($PHOTOUNIT);

DO i=1,$MXELEMENT
[
    IF (eadl_relax)[
       "Skip, using binding_energies from *_photo.data file
       read($PHOTOUNIT,*);
    ]
    ELSE[
       read($PHOTOUNIT,*) j,(binding_energies(k,i),k=1,$MXSHELL);
       DO k=1,$MXSHELL [
          binding_energies(k,i) = binding_energies(k,i)*1e-6; "Convert to MeV"
       ]
    ]
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT
[
    read($PHOTOUNIT,*) j,(interaction_prob(k,i),k=1,$MXINTER);
    interaction_prob($MXSHELL,i)=1.01;
]
$egs_info('(a)',' Done');

$egs_info('(/a$)',' Reading simplified relaxation data .....');
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=1,19);   "K-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=20,26);   "L1-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=27,32);   "L2-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=33,37);   "L3-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,relaxation_prob(38,i);   "M-shell"
]
$egs_info('(a)',' Done');
$egs_info('(/a$)',' Reading parametrized XCOM photo cross section data .....');
rewind($PHOCSUNIT);
DO i=1,$MXELEMENT [
    read($PHOCSUNIT,*) j,edge_number(i);
    DO j=1,edge_number(i) [
        read($PHOCSUNIT,*) edge_a(j,i),edge_b(j,i),edge_c(j,i),
                           edge_d(j,i),edge_energies(j,i);
    ]
]
$egs_info('(a)',' Done');

IF (eadl_relax)[
 call egs_init_relax;
]

RETURN;
END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE PHOTON(IRCODE);
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$INTEGER IRCODE; "1 => normal return"

$COMIN-PHOTON;   "default replacement produces the following:
                 "COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,"
                 "  UPHIOT,USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION/;"

$DEFINE-LOCAL-VARIABLES-PHOTON;


IRCODE=1;"set up normal return"
PEIG=E(NP);
EIG=PEIG; "energy of incident gamma"
IRL=IR(NP);
$start_new_particle;

IF(EIG <= PCUT(IRL)) [GO TO :PCUT-DISCARD:;]

:PNEWENERGY:
LOOP["enter this loop for each photon with new energy"

IF(WT(NP) = 0.0) [go to :USER-PHOTON-DISCARD:;] "added May 01"

GLE=LOG(EIG);"GLE IS GAMMA LOG ENERGY"

"   here to sample no. mfp to transport before interacting"

$SELECT-PHOTON-MFP;
" DEFAULT FOR $SELECT-PHOTON-MFP; IS:  $RANDOMSET RNNO35;"
"                                      DPMFP=-LOG(RNNO35);"
"NOTE:  THIS TEMPLATE CAN ALSO BE OVER-RIDDEN BY OTHER SCHEMES,"
"       SUCH AS THE 'EXPONENTIAL TRANSFORM' TECHNIQUE."

IROLD=IR(NP);"INITIALIZE PREVIOUS REGION"

:PNEWMEDIUM:
LOOP["HERE EACH TIME WE CHANGE MEDIUM DURING PHOTON TRANSPORT"
IF (MEDIUM.NE.0)[$SET INTERVAL GLE,GE;"SET PWLF INTERVAL"
$EVALUATE GMFPR0 USING GMFP(GLE);]

:PTRANS:
LOOP["PHOTON TRANSPORT LOOP"
IF (MEDIUM.EQ.0)[TSTEP=VACDST;]
ELSE [$SET-RHOF;    "DENSITY RATIO SCALING TEMPLATE"
GMFP=GMFPR0/RHOF;
$RAYLEIGH-CORRECTION;  "A RAYLEIGH SCATTERING TEMPLATE"
"Ali:photonuc, 1 line"
$PHOTONUC-CORRECTION;  "A PHOTONUCLEAR TEMPLATE"
TSTEP=GMFP*DPMFP;]
"   SET DEFAULT VALUES FOR FLAGS SENT BACK FROM USER"
IRNEW=IR(NP);"SET DEFAULT NEW REGION NUMBER"
IDISC=0;"ASSUME PHOTON NOT DISCARDED"
USTEP=TSTEP;"TRANSFER TRANSPORT DISTANCE TO USER VARIABLE"
TUSTEP=USTEP;

"IF (USTEP.GT.DNEAR(NP)) [;CALL HOWFAR;]"
$CALL-HOWFAR-IN-PHOTON; "The above is the default replacement"


"   NOW CHECK FOR USER DISCARD REQUEST"
IF (IDISC.GT.0)["USER REQUESTED IMMEDIATE DISCARD"
GO TO :USER-PHOTON-DISCARD:;]

VSTEP=USTEP; "SET VARIABLE FOR OUTPUT CODE"
TVSTEP=VSTEP;
EDEP=PZERO; "NO ENERGY DEPOSITION ON PHOTON TRANSPORT"

x_final = x(np) + u(np)*vstep;
y_final = y(np) + v(np)*vstep;
z_final = z(np) + w(np)*vstep;

$AUSCALL($TRANAUSB);

"   TRANSPORT THE PHOTON"
x(np) = x_final; y(np) = y_final; z(np) = z_final;
DNEAR(NP)=DNEAR(NP)-USTEP;"DEDUCT FROM DISTANCE TO NEAREST BOUNDARY"
IF (MEDIUM.NE.0)[DPMFP=MAX(0.,DPMFP-USTEP/GMFP);] "DEDUCT MFP'S"
IROLD=IR(NP); "SAVE PREVIOUS REGION"

MEDOLD=MEDIUM;
IF (IRNEW.NE.IROLD) ["REGION CHANGE"
  $photon_region_change;
]

"   AFTER TRANSPORT CALL TO USER"
$AUSCALL($TRANAUSA);
"oct 31 bug found by C Ma. PCUT discard now after AUSGAB call"
IF(EIG.LE.PCUT(IRL)) [GO TO :PCUT-DISCARD:;]

"   NOW CHECK FOR DEFERRED DISCARD REQUEST.  MAY HAVE BEEN SET"
"   BY EITHER HOWFAR, OR ONE OF THE TRANSPORT AUSGAB CALLS"
IF (IDISC.LT.0) GO TO :USER-PHOTON-DISCARD:;

IF (MEDIUM.NE.MEDOLD) EXIT :PTRANS:;

IF (MEDIUM.NE.0.AND.DPMFP.LE.$EPSGMFP)["TIME FOR AN INTERACTION"
EXIT :PNEWMEDIUM:;]
]REPEAT ":PTRANS: LOOP"

]REPEAT ":PNEWMEDIUM: LOOP"


"   IT IS FINALLY TIME TO INTERACT."
"   THE FOLLOWING MACRO ALLOWS ONE TO INTRODUCE RAYLEIGH SCATTERING"
$RAYLEIGH-SCATTERING;
"Ali:photonuclear, 1 line"
$PHOTONUCLEAR;
$RANDOMSET RNNO36; "THIS RANDOM NUMBER DETERMINES WHICH INTERACTION"
"   GBR1=PAIR/(PAIR+COMPTON+PHOTO)=PAIR/GTOTAL"
$EVALUATE GBR1 USING GBR1(GLE);
IF((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )["IT WAS A PAIR PRODUCTION"
    $AUSCALL($PAIRAUSB);
    CALL PAIR;
    "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
    "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
    "   LEADING PARTICLE SELECTION, ETC.))."
    "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
    "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
    $PARTICLE-SELECTION-PAIR;
    $AUSCALL($PAIRAUSA);
    IF( iq(np) ~= 0 ) [ EXIT :PNEWENERGY:; ]
    ELSE [ "this may happen if pair electrons killed via Russian Roulette"
        goto :PAIR-ELECTRONS-KILLED:;
    ]
]
"GBR2=(PAIR+COMPTON)/GTOTAL"
$EVALUATE GBR2 USING GBR2(GLE);
IF (RNNO36.LT.GBR2)["IT WAS A COMPTON"
    $AUSCALL($COMPAUSB);
    CALL COMPT;
    "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
    "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
    "   LEADING PARTICLE SELECTION, ETC.))."
    "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
    "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
    $PARTICLE-SELECTION-COMPT;
    $AUSCALL($COMPAUSA);
    IF (IQ(NP).NE.0"NOT PHOTON")EXIT:PNEWENERGY:;
]
ELSE["IT WAS PHOTOELECTRIC EFFECT"
    $AUSCALL($PHOTOAUSB);
    CALL PHOTO;
    "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
    "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
    "   LEADING PARTICLE SELECTION, ETC.))."
    "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
    "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
    $PARTICLE-SELECTION-PHOTO;
    IF (NP = 0 | NP < NPOLD ) [RETURN;]
      "The above may happen if Russian Roulette is on"
      "NP<NPOLD means that only electrons were created in the interaction"
      "and that all of them were killed. Hence, the top particle on the "
      "stack is from a previous interaction and may be in another region"
      "To avoid problems with the :PNEWENERGY: loop logic, we simply force"
      "a return to shower so that ELECTR or PHOTON are properly re-entered."
      "Changed by IK Dec. 21 2006 after D. Rogers and R. Taylor found a"
      "wrong dose with brems splitting and Russian Roulette on in a low "
      "energy calculation."

    $AUSCALL($PHOTOAUSA);
    IF (IQ(NP) ~= 0 ) EXIT :PNEWENERGY:;
] "END OF PHOTO ELECTRIC BLOCK"

:PAIR-ELECTRONS-KILLED:

"   IF HERE, THEN GAMMA IS LOWEST ENERGY PARTICLE."
PEIG=E(NP);
EIG=PEIG;
IF(EIG.LT.PCUT(IRL)) GO TO :PCUT-DISCARD:;
]REPEAT ":PNEWENERGY: LOOP"

"   IF HERE, MEANS ELECTRON TO BE TRANSPORTED NEXT"
RETURN;

"---------------------------------------------"
"PHOTON CUTOFF ENERGY DISCARD SECTION         "
"---------------------------------------------"
:PCUT-DISCARD:
IF( medium > 0 ) [
    IF(EIG.GT.AP(MEDIUM)) [IDR=$EGSCUTAUS;]ELSE[IDR=$PEGSCUTAUS;]
] ELSE [ IDR=$EGSCUTAUS; ]
EDEP=PEIG;"GET ENERGY DEPOSITION FOR USER"
$PHOTON-TRACK-END;
IRCODE=2;
NP=NP-1;
RETURN;

"---------------------------------------------"
"User requested photon discard section        "
"---------------------------------------------"
:USER-PHOTON-DISCARD:
EDEP=PEIG;
$AUSCALL($USERDAUS);
IRCODE=2;
NP=NP-1;
RETURN;

"END OF SUBROUTINE PHOTON"  END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE SHOWER(IQI,EI,XI,YI,ZI,UI,VI,WI,IRI,WTI);
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-SHOWER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,STACK,UPHIOT,RANDOM/;

"Input variables"
$REAL EI,      "initial shower energy"
      XI,YI,ZI,"initial co-ordinates"
      UI,VI,WI,"initial direction cosines"
      WTI;     "initial weight"

$INTEGER
      IQI,     "initial particle charge"
      IRI;     "initial region number"

"Local variables"
DOUBLE PRECISION
      DEG,    "energy for pi-zero option"
      DPGL,   "angle factor for pi-zero option"
      DEI,    "incident energy for pi-zero option"
      DPI,    "intermediate factor for pi-zero option"
      DCSTH,  "random number for pi-zero option"
      DCOSTH, "cos(theta) for pi-zero option"
      PI0MSQ; "pi-zero mass squared (in MeV**2)"

$REAL DNEARI, "initial distance to closest boundary"
      CSTH;   "random number for pi-zero option"

$INTEGER
      IRCODE; "status returned by ELECTR or PHOTON"

DATA PI0MSQ/1.8215416D4/;  "PI-ZERO MASS (MEV) SQUARED"

NP=1; NPold = NP;      "Set the old stack counter"
DNEARI=0.0;
IQ(1)=IQI; E(1)=EI; U(1)=UI; V(1)=VI; W(1)=WI;
$TRANSFER PROPERTIES TO (1) FROM I;

IF (IQI = 2) ["PI-ZERO OPTION"
  "IF(EI <= PI0MSQ) [OUTPUT EI;    corrected Oct 24 1995 e-mail Hideo H "
  "                  noted by      Dr.  Muroyama at Nagoya University
  IF(EI**2 <= PI0MSQ) [
     $egs_fatal('(//a/,a,g15.5,a)',
     ' Stopped in subroutine SHOWER---PI-ZERO option invoked',
     ' but the total energy was too small (EI=',EI,' MeV)');
  ]
  $RANDOMSET CSTH;
  DCSTH=CSTH; DEI=EI; DPI=DSQRT(DEI*DEI-PI0MSQ);
  DEG=DEI+DPI*DCSTH; DPGL=DPI+DEI*DCSTH; DCOSTH=DPGL/DEG;
  COSTHE=DCOSTH; SINTHE=DSQRT(1.D0-DCOSTH*DCOSTH);
  IQ(1)=0; E(1)=DEG/2.;
  CALL UPHI(2,1);
  NP=2;
  DEG=DEI-DPI*DCSTH; DPGL=DPI-DEI*DCSTH; DCOSTH=DPGL/DEG;
  COSTHE=DCOSTH; SINTHE=-DSQRT(1.D0-DCOSTH*DCOSTH);
  IQ(2)=0; E(2)=DEG/2.;
  CALL UPHI(3,2);
]"end of pi-zero option"

"The following convoluted logic is difficult to follow"
"when one modifies the outcome of certain interactions"
"using nbr_split, Russian Roulette, or one of the     "
"particle selection macros. I'm simplifying it        "
"so that ircode becomes irrelevant. IK, August 2002   "
":TOPSTACK:"
"LOOP["
"   $KERMA-INSERT;"
"   IF(IQ(NP) = 0) GO TO :PHOTON:;"
"   LOOP ["
"      :ELECTRON:"
"      CALL ELECTR(IRCODE);"
"      IF(IRCODE.EQ.2) EXIT; "
"      :PHOTON:"
"      CALL PHOTON(IRCODE);"
"      IF(IRCODE.EQ.2) EXIT;"
"   ]REPEAT"
"   IF(NP <= 0) EXIT;"
"]REPEAT "

LOOP [
    ;
    IF( np <= 0 ) EXIT;
    $KERMA-INSERT;  " DEFAULT FOR $KERMA-INSERT; IS ; (NULL)"
    IF( iq(np) = 0 ) [ call photon(ircode); ]
    ELSE             [ call electr(ircode); ]

]

RETURN;
"end of subroutine shower"  END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE UPHI(IENTRY,LVL);
"                                                                  "
"******************************************************************"
"   UPHI STANDS FOR 'UNIFORM PHI DISTRIBUTION'.                    "
"   SET COORDINATES FOR NEW PARTICLE OR RESET DIRECTION COSINES OF "
"   OLD ONE.  GENERATE RANDOM AZIMUTH SELECTION AND REPLACE THE    "
"   DIRECTION COSINES WITH THEIR NEW VALUES.                       "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-UPHI;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM/;

"Input variables"
integer  IENTRY,LVL; "entry switches"

"Local variables"
$REAL CTHET,  "5/2*pi-THETA, used to evaluate cos(THETA) using the sine table"
      RNNO38, "random number for azimuthal angle selection"
      PHI,    "azimuthal scattering angle"
      CPHI,   "5/2*pi-PHI"
      A,B,C,  "direction cosines before rotation"
      SINPS2, "SINPS2=A*A+B*B"
      SINPSI, "Sqrt(SINPS2)"
      US,VS,  "x- and y- component of scattering vector"
      SINDEL,COSDEL;
              "aux. variables for the rotation algorithm"

$INTEGER
      IARG,   "index for AUSGAB"
      LPHI,LTHETA,LCTHET,LCPHI;
              "indeces for sine table"

$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
save CTHET,PHI,CPHI,A,B,C,SINPS2,SINPSI,US,VS,SINDEL,COSDEL;

$AUSCALL($UPHIAUSB);
GO TO (:UPHI:,:UPHI2:,:NRK:),IENTRY;
"   IENTRY OUT-OF-BOUNDS IF HERE"  GO TO :ERROR:;

:UPHI:; "NOTE: AFB 88/12/12 ADDED SEMI-COLON, ELSE BUG WHEN OVERRIDING SIN"
        "TABLE LOOK-UP"
$SET INTERVAL THETA,SINC;
$EVALUATE SINTHE USING SIN(THETA);
CTHET=PI5D2-THETA;$SET INTERVAL CTHET,SINC;
$EVALUATE COSTHE USING SIN(CTHET);

"   USE THE FOLLOWING ENTRY IF SINTHE AND COSTHE ARE ALREADY KNOWN."
"   SELECT PHI UNIFORMLY OVER THE INTERVAL (0,TWO PI). THEN USE    "
"   PWLF OF SIN FUNCTION TO GET SIN(PHI) AND COS(PHI).  THE COSINE "
"   IS GOTTEN BY COS(PHI)=SIN(9*PI/4 - PHI).                       "

:UPHI2:;

" It is much faster to use the box method for azimuthal angle selection"
" than the following                                                   "
" $RANDOMSET RNNO38;
" PHI=RNNO38*TWOPI;$SET INTERVAL PHI,SINC;
" $EVALUATE SINPHI USING SIN(PHI);
" CPHI=PI5D2-PHI;$SET INTERVAL CPHI,SINC;
" $EVALUATE COSPHI USING SIN(CPHI);
$SELECT-AZIMUTHAL-ANGLE(cosphi,sinphi);

"   USE THE FOLLOWING ENTRY FOR THE SECOND OF TWO PARTICLES WHEN WE"
"   KNOW TWO PARTICLES HAVE A RELATIONSHIP IN THEIR CORRECTIONS.   "
"   NOTE: SINTHE AND COSTHE CAN BE CHANGED OUTSIDE THROUGH COMMON. "
"   LVL IS A PARAMETER TELLING WHICH PARTICLES TO WORK WITH.       "
"   THETA (SINTHE AND COSTHE) ARE ALWAYS RELATIVE TO THE DIRECTION "
"   OF THE INCIDENT PARTICLE BEFORE ITS DIRECTION WAS ADJUSTED.    "
"   THUS WHEN TWO PARTICLES NEED TO HAVE THEIR DIRECTIONS COMPUTED,"
"   THE ORIGINAL INCIDENT DIRECTION IS SAVED IN THE VARIABLE A,B,C "
"   SO THAT IT CAN BE USED ON BOTH CALLS."

"   LVL=1 -- OLD PARTICLE, SAVE ITS DIRECTION AND ADJUST IT"
"   LVL=2 -- NEW PARTICLE. ADJUST DIRECTION USING SAVED A,B,C"
"   LVL=3 -- BREMSSTRAHLUNG GAMMA.  SAVE ELECTRON DIRECTION (NEXT  "
"   TO TOP OF STACK), AND THEN ADJUST GAMMA DIRECTION."

:NRK:
GO TO (:OLD-PARTICLE:,:NEW-PARTICLE:,:BREMS-GAMMA:),LVL;
"   LVL OUT-OF-BOUNDS IF HERE"   GO TO :ERROR:;

:OLD-PARTICLE:
A=U(NP);B=V(NP);C=W(NP);
GO TO :ADJUST:;

:BREMS-GAMMA:
A=U(NP-1);B=V(NP-1);C=W(NP-1);

:NEW-PARTICLE:
$TRANSFER PROPERTIES TO (NP) FROM (NP-1);

"   SEE H.H. NAGEL DISSERTATION FOR COORDINATE SYSTEM DESCRIPTION. "
"   A ROTATION IS PERFORMED TO TRANSFORM DIRECTION COSINES OF THE  "
"   PARTICLE BACK TO THE PHYSICAL FRAME (FROM THE TRANSPORT FRAME) "

:ADJUST:
SINPS2=A*A+B*B;
"   If SINPS2 is small, no rotation is needed    "
IF (SINPS2.LT.1.0E-20)["small polar angle case"
   U(NP)=SINTHE*COSPHI;
   V(NP)=SINTHE*SINPHI;
   W(NP)=C*COSTHE;    "fixed March 2001 from =COSTHE"
] "end small polar angle case"
ELSE["large polar angle case"
   SINPSI=SQRT(SINPS2);
   US=SINTHE*COSPHI;
   VS=SINTHE*SINPHI;
   SINDEL=B/SINPSI;
   COSDEL=A/SINPSI;
   U(NP)=C*COSDEL*US-SINDEL*VS+A*COSTHE;
   V(NP)=C*SINDEL*US+COSDEL*VS+B*COSTHE;
   W(NP)=-SINPSI*US+C*COSTHE;
]"end large polar angle case"

$AUSCALL($UPHIAUSA);

RETURN;

:ERROR: "REACH THIS POINT IF EITHER IENTRY OR LVL NE 1,2, OR 3"
$egs_fatal('(a,2i6)',' STOPPED IN UPHI WITH IENTRY,LVL=',IENTRY,LVL);

"END OF SUBROUTINE UPHI"    END;

;
%E
"*************************************************************************
"
" The following is a set of macros and subroutines that implement
" bremsstrahlung sampling from the S. Seltzer (NIST) cross sections
" (which are the basis for ICRU radiative stopping powers, into the
" EGSnrc environment) or the NRC cross sections, which are essentially
" the same as NIST, but with corrections to the electron-electron
" contribution (corrections are only significant for low values of
" atomic number Z and low values of the emitted photon energy k.
"
" In order to use it, you have to `turn on' this option by
" setting ibr_nist (which is in COMON/BREMPR/) to ibr_nist=1 for the
" original NIST data (nist_brems.data) or ibr_nist=2 for the NRC
" data (nrc_brems.data).
"
" If this option is turned on, subroutine HATCH will call
" subroutine init_nist_brems.
" In init_nist_brems the NIST cross sections are read in,
" total bremsstrahlung cross sections are calculated using
" 64 point Gauss-Legendre quadrature, the interpolation arrays
" that are used for total cross sections and brems fraction interpolations
" (esig0, esig1, ebr10, ebr11               for electrons)
" (psig0, psig1, pbr10, pbr11, pbr20, pbr21 for positrons)
" are updated and alias sampling tables for rapid sampling of brems
" energies are created. These alias sampling tables are then used
" during the simulation in subroutine BREMS.
" Be aware that there is a slight inconsistency when using this option
" as resttricted radiative stopping powers used are the ones coming
" from PEGS and so, they are calculated using Bethe-Heitler.
" This will not matter at all if
"   - AP is much smaller than the electron energy
"       and/or
"   - the restricted radiative stopping power is much smaller
"     then the restricted collision stopping power
" Both conditions are usually satisfied.
"
" I. Kawrakow, NRC, January 2000.
"
" Added NRC brems cross-sections
" F. Tessier, NRC, August 2007.
"
"****************************************************************************

subroutine init_nist_brems;
"**************************"

$IMPLICIT-NONE;

$REAL    energy_array($MXBREN),x_array($MXBRXX),
         cs_array($MXBREN,$MXBRXX,$MXBREL);
$REAL    xi_array($MXBRXX);
real*8   x_gauss($MXGAUSS),w_gauss($MXGAUSS);

$INTEGER nmix,kmix,i,n,k,j,ii;
$INTEGER ngauss,i_gauss;
$INTEGER lnblnk1,egs_get_unit;
$INTEGER ifirst,ilast,nener,neke,leil;

$REAL    cs($MXBREN,$MXBRXX),ee($MXBREN),ele($MXBREN);
$REAL    csx($MXBRXX),afx($MXBRXX),bfx($MXBRXX),cfx($MXBRXX),dfx($MXBRXX);
$REAL    cse($MXBREN),afe($MXBREN),bfe($MXBREN),cfe($MXBREN),dfe($MXBREN);
$REAL    Z,sumA;
$REAL    emin,xi,res,spline,eil,ei,beta2,aux,sigb,sigt,ebr1,ebr2;
$REAL    sigee,sigep,sige,si_esig,si1_esig,si_ebr1,si1_ebr1,ededx,
         sig_bhabha,si_psig,si1_psig,si_pbr1,si1_pbr1,si_pbr2,si1_pbr2;
$INTEGER iz;
$REAL    ple,qle,x,f,error,max_error,x_max_error,f_max_error;
$INTEGER ndat,k_max_error;
character tmp_string*512, tmp1_string*512;
integer  itmp;

$declare_write_buffer;

$REAL amu;
parameter (amu = 1660.5655);  "converts the cross sections from mB/per atom"
                              "to cm^2/g"
$LOGICAL ex,is_opened;
$declare_max_medium;
$COMIN-INIT-NIST-BREMS;

$set_string(tmp_string,' ');
tmp_string = $cstring(hen_house) // 'data' // $file_sep;

IF( ibr_nist = 1 ) [
    $open_data_file(tmp_string,tmp1_string,'nist_brems.data',$NIST-DATA-UNIT);
]
ELSE IF (ibr_nist = 2) [
    $open_data_file(tmp_string,tmp1_string,'nrc_brems.data',$NIST-DATA-UNIT);
]
ELSE [
    $egs_fatal(*,' init_nist_brems: unknown value of ibr_nist!
    ibr_nist = ', ibr_nist);
]

"Get the S. Seltzer (ibr_nist=1) or NRC's (ibr_nist=2) brems cross sections"
"
rewind($NIST-DATA-UNIT);
read($NIST-DATA-UNIT,*);
read($NIST-DATA-UNIT,*) nmix,kmix;
IF (kmix > $MXBRXX) [
    $egs_fatal(*,' init_nist_brems: to many k values in data file!');
]
IF (nmix > $MXBREN) [
    $egs_fatal(*,' init_nist_brems: to many T values in data file!');
]

read($NIST-DATA-UNIT,*) (energy_array(n),n=1,nmix);
DO n=1,nmix [ energy_array(n) = $NIST-ENERGY-SCALE*energy_array(n); ]
read($NIST-DATA-UNIT,*) (x_array(k),k=1,kmix);
read($NIST-DATA-UNIT,*);
DO i=1,$MXBREL [
    read($NIST-DATA-UNIT,*) ((cs_array(n,k,i),n=1,nmix),k=1,kmix);
]
close($NIST-DATA-UNIT);

DO k=1,kmix [
    xi_array(k)=Log(1-x_array(k)+1e-6);
    IF( fool_intel_optimizer ) [
        $egs_info(*,'xi_array(k): ',xi_array(k));
    ]
]

"Get abscissas and weights for Gauss-Legendre quadrature"
"
ngauss = $MXGAUSS;
call gauss_legendre(0d0,1d0,x_gauss,w_gauss,ngauss);

"Calculate total brems cross sections and sampling tables"
"for all media                                           "

$egs_info(*,' ');
IF (ibr_nist = 1) [
$egs_info(*,'Using NIST brems cross sections! ');
]
ELSE IF (ibr_nist = 2) [
    $egs_info(*,'Using NRC brems cross sections! ');
]
$egs_info(*,' ');
DO medium=1,nmed [

    log_ap(medium) = log(ap(medium));
    $egs_info(*,' Initializing brems data for medium ',medium,'...');
    emin = max(ae(medium) - rm, ap(medium));
    DO i=1,nmix [
        IF( energy_array(i) >= emin ) EXIT;
    ]
    ifirst = i;
    DO i=nmix,1,-1 [
        IF( energy_array(i) < ue(medium) - rm ) EXIT;
    ]
    ilast = i+1;
    IF( ifirst < 1 | ilast > nmix ) [
        $egs_info(*,' init_nist_brems: data available only for ');
        $egs_info(*,energy_array(1),' <= E <= ',energy_array(nmix));
        $egs_info(*,' will use spline interpolations to get cross ');
        $egs_info(*,' sections beyond the available data but this may');
        $egs_info(*,' produce nonsense!');
        IF( ifirst < 1 ) ifirst=1;
        IF( ilast > nmix ) ilast = nmix;
    ]
    DO i=ifirst,ilast [
        ii = i+1 - ifirst;
        ee(ii) = energy_array(i); ele(ii) = log(ee(ii));
        sumA = 0;
        DO j=1,NNE(medium) [ sumA = sumA + pz(medium,j)*wa(medium,j); ]
        sumA = sumA*amu;
        DO k=1,kmix [
            cs(ii,k) = 0;
            DO j=1,NNE(medium) [
                Z = zelem(medium,j); iz = int(Z+0.1); Z = Z*Z/sumA;
                cs(ii,k) = cs(ii,k) + pz(medium,j)*Z*cs_array(i,k,iz);
            ]
            csx(k) = Log(cs(ii,k));
        ]
        call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
        "
        " Integrate
        "
        cse(ii) = 0; aux = Log(ee(ii)/ap(medium));
        DO i_gauss = 1,ngauss [
            xi = log(1 - ap(medium)/ee(ii)*exp(x_gauss(i_gauss)*aux)+1e-6);
            res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
            cse(ii) = cse(ii) + w_gauss(i_gauss)*exp(res);
        ]
    ]
    nener = ilast - ifirst + 1;
    call set_spline(ele,cse,afe,bfe,cfe,dfe,nener);
    "
    " Now replace the PEGS cross sections "
    "
    neke = meke(medium);
    sigee = 1E-15; sigep = 1E-15;
    DO i = 1,neke [
        eil = (float(i) - eke0(medium))/eke1(medium); ei = exp(eil);
        leil = i;
        beta2 = ei*(ei+2*rm)/(ei+rm)**2;
        IF( ei <= ap(medium) ) [ sigb = 1e-30; ]
        ELSE [
            sigb = spline(eil,ele,afe,bfe,cfe,dfe,nener);
            sigb = sigb*log(ei/ap(medium))/beta2*rho(medium);
        ]
        $EVALUATE sigt USING esig(eil);  " sigt is the total cross section "
        $EVALUATE ebr1 USING ebr1(eil);  " coming from PEGS, ebr1*sigt is "
                                         " then the brems cross section "
        IF( sigt < 0 ) sigt = 0;
        IF( ebr1 > 1 ) ebr1 = 1;
        IF( ebr1 < 0 ) ebr1 = 0;
        IF( i > 1 ) [
            si_esig = si1_esig;
            si_ebr1 = si1_ebr1;
            si1_esig = sigt*(1 - ebr1) + sigb;
            si1_ebr1 = sigb/si1_esig;
            esig1(i-1,medium) = (si1_esig - si_esig)*eke1(medium);
            esig0(i-1,medium) = si1_esig - esig1(i-1,medium)*eil;
            ebr11(i-1,medium) = (si1_ebr1 - si_ebr1)*eke1(medium);
            ebr10(i-1,medium) = si1_ebr1 - ebr11(i-1,medium)*eil;
        ]
        ELSE [
            si1_esig = sigt*(1 - ebr1) + sigb;
            si1_ebr1 = sigb/si1_esig;
        ]

        "
        " Positrons "
        "
        $EVALUATE sigt USING psig(eil);
        $EVALUATE ebr1 USING pbr1(eil);
        $EVALUATE ebr2 USING pbr2(eil);
        IF( sigt < 0 ) sigt = 0;
        IF( ebr1 > 1 ) ebr1 = 1;
        IF( ebr1 < 0 ) ebr1 = 0;
        IF( ebr2 > 1 ) ebr2 = 1;
        IF( ebr2 < 0 ) ebr2 = 0;
        sig_bhabha = sigt*(ebr2 - ebr1);
        IF( sig_bhabha < 0 ) sig_bhabha = 0;
        IF( i > 1 ) [
            si_psig = si1_psig;
            si_pbr1 = si1_pbr1;
            si_pbr2 = si1_pbr2;
            si1_psig = sigt*(1 - ebr1) + sigb;
            si1_pbr1 = sigb/si1_psig;
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
            psig1(i-1,medium) = (si1_psig - si_psig)*eke1(medium);
            psig0(i-1,medium) = si1_psig - psig1(i-1,medium)*eil;
            pbr11(i-1,medium) = (si1_pbr1 - si_pbr1)*eke1(medium);
            pbr10(i-1,medium) = si1_pbr1 - pbr11(i-1,medium)*eil;
            pbr21(i-1,medium) = (si1_pbr2 - si_pbr2)*eke1(medium);
            pbr20(i-1,medium) = si1_pbr2 - pbr21(i-1,medium)*eil;
        ]
        ELSE [
            si1_psig = sigt*(1 - ebr1) + sigb;
            si1_pbr1 = sigb/si1_psig;
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
        ]
        $EVALUATE ededx USING ededx(eil);
        sige = si1_esig/ededx;
        IF( sige > sigee ) sigee = sige;
        $EVALUATE ededx USING pdedx(eil);
        sige = si1_psig/ededx;
        IF( sige > sigep ) sigep = sige;
    ]
    esig1(neke,medium) = esig1(neke-1,medium);
    esig0(neke,medium) = esig0(neke-1,medium);
    ebr11(neke,medium) = ebr11(neke-1,medium);
    ebr10(neke,medium) = ebr10(neke-1,medium);
    psig1(neke,medium) = psig1(neke-1,medium);
    psig0(neke,medium) = psig0(neke-1,medium);
    pbr11(neke,medium) = pbr11(neke-1,medium);
    pbr10(neke,medium) = pbr10(neke-1,medium);
    pbr21(neke,medium) = pbr21(neke-1,medium);
    pbr20(neke,medium) = pbr20(neke-1,medium);
    $egs_info(*,' Max. new cross sections per energy loss: ',sigee,sigep);
    esig_e(medium) = sigee; psig_e(medium) = sigep;
    IF( sigee > esige_max ) esige_max = sigee;
    IF( sigep > psige_max ) psige_max = sigep;

    "
    " Now prepare the arrays for brems sampling
    "
    nb_emin(medium) = energy_array(ifirst);
    IF( nb_emin(medium) <= ap(medium) ) [
        nb_emin(medium) = energy_array(ifirst+1);
    ]
    nb_emax(medium) = energy_array(ilast);
    nb_lemin(medium) = log(nb_emin(medium));
    nb_lemax(medium) = log(nb_emax(medium));
    nb_dle(medium) = (nb_lemax(medium) - nb_lemin(medium))/($MXBRES-1);
    nb_dlei(medium) = 1/nb_dle(medium);
    "
    eil = nb_lemin(medium) - nb_dle(medium);
    DO i=1,$MXBRES [
        eil = eil + nb_dle(medium); ei = exp(eil);
        DO ii=1,nener [
            IF( ei < ee(ii) ) EXIT;
        ]
        ii = ii-1;
        IF( ii < 1) ii = 1;
        IF( ii > nener-1 ) ii = nener-1;
        "
        " ple and qle are energy interpolation coefficients
        "
        ple = (eil - ele(ii))/(ele(ii+1)-ele(ii)); qle = 1 - ple;
        DO k=1,kmix [
            csx(k) = log(qle*cs(ii,k) + ple*cs(ii+1,k));
        ]
        call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
        "
        " fill the abscissas for this energy
        "
        x = ap(medium)/ei; aux = -log(x);
        xi = log(1 - x+1e-6);
        res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
        nb_xdata(0,i,medium) = 0;
        nb_fdata(0,i,medium) = exp(res);

        DO k=1,kmix [
            IF( x_array(k) > x ) EXIT;
        ]
        IF( k > kmix ) k = kmix;
        ndat = 0;
        DO j=k+1,kmix-1 [
            ndat = ndat+1;
            nb_xdata(ndat,i,medium) = log(x_array(j)/x)/aux;
            nb_fdata(ndat,i,medium) = exp(csx(j));
            IF( fool_intel_optimizer ) [
                $egs_info(*,'nb_xdata(ndat,i,medium): ',
                        nb_xdata(ndat,i,medium));
            ]
        ]
        ndat = ndat+1;
        nb_xdata(ndat,i,medium) = 1;
        nb_fdata(ndat,i,medium) = exp(csx(kmix));
        "
        " Now expand the arrays by filling intermediate points
        " at the positions that show the maxium relative error
        " when using linear interpolation in x.
        " If arrays were allocated dynamically one could use
        " a certain condition to stop the iteration but in our case
        " memory is allocated anyway and so we use the maximum
        " space provided
        "
        IF( ndat >= $MXBRXS ) goto :SKIP-LOOP:;
        LOOP [
            x_max_error = 0; f_max_error = 0; k_max_error = 0;
            max_error = 0;
            DO k=0,ndat-1 [
                x = 0.5*(nb_xdata(k,i,medium) + nb_xdata(k+1,i,medium));
                f = 0.5*(nb_fdata(k,i,medium) + nb_fdata(k+1,i,medium));
                xi = log(1 - ap(medium)/ei*exp(x*aux)+1e-6);
                res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
                res = exp(res);
                error = abs(1-f/res);
                IF( error > max_error ) [
                    x_max_error = x;
                    f_max_error = res;
                    max_error = error;
                    k_max_error = k;
                ]
            ]
            ndat = ndat+1;
            DO k=ndat,k_max_error+2,-1 [
                nb_xdata(k,i,medium) = nb_xdata(k-1,i,medium);
                nb_fdata(k,i,medium) = nb_fdata(k-1,i,medium);
            ]
            nb_xdata(k_max_error+1,i,medium) = x_max_error;
            nb_fdata(k_max_error+1,i,medium) = f_max_error;
        ] UNTIL (ndat = $MXBRXS);

        :SKIP-LOOP:
        "
        " Now generate the alias tables for rapid brems sampling
        " during run time
        "
        call prepare_alias_table($MXBRXS,nb_xdata(0,i,medium),
               nb_fdata(0,i,medium),nb_wdata(1,i,medium),nb_idata(1,i,medium));

    ]
]
$egs_info(*,' ');
$egs_info(*,' ');
return;
" Errors "
:data_file_error:
$egs_fatal(*,'failed to open EGSnrc data file ',$cstring(tmp1_string));
return;
end;

%E
/***************************************************************************
 *
 * A subroutine to initialize pair energy sampling from the NRC
 * cross sections differential in the positron energy.
 * These cross sections are calculated as the product of the
 * exact cross section without screening times the ratio
 * of the first Born approximation with screening to the first
 * Born approximation without screening.
 * At high energies (above, say, 50 MeV) the NRC cross sections are
 * are very close to the Bethe-Heitler cross sections but
 * there are significant differences at low energies. In particular,
 * the asymetrie in the energy distribution between the positron
 * and the electron is properly taken into account.
 *
 * I. Kawrakow, April 2005.
 *
 ***************************************************************************/

subroutine init_nrc_pair;
implicit none;
$declare_max_medium;
;COMIN/MEDIA,BREMPR,ELECIN,NRC-PAIR-DATA,THRESH,USEFUL,EGS-IO/;
$declare_write_buffer;

character     nrcp_file*256, endianess*4;
integer       egs_get_unit;
$INTEGER      nrcp_unit, want_nrcp_unit, rec_length;
$INTEGER      i, lnblnk1;
$REAL         tmp, ddx, xx, Z;
real*4        emin, emax;
integer*4     ne, nb, ix, ie, irec, i_ele, nbb, iz;
REPLACE {$cdum_size} WITH {{COMPUTE 4*($NRC-PAIR-NXX-4)-1}};
character     endian, cdum($cdum_size);
$LOGICAL      swap;
real*4        tmp_4, tarray($NRC-PAIR-NXX);
integer*4     itmp_4;
character     c_4(4), ic_4(4);
equivalence   (tmp_4,c_4), (itmp_4, ic_4);

$set_string(nrcp_file,' ');
nrcp_file = $cstring(hen_house) // 'data' // $file_sep // 'pair_nrc1.data';
want_nrcp_unit = 62;
nrcp_unit = egs_get_unit(want_nrcp_unit);
IF( nrcp_unit < 1 ) [
    $egs_fatal(*,'init_nrc_pair: failed to get a free fortran unit');
]

rec_length = $NRC-PAIR-NXX*$RECL-FACTOR;
open(nrcp_unit,file=nrcp_file,form='unformatted',access='direct',
        status='old',recl=rec_length,err=:nrcp-open-error:);
read(nrcp_unit,rec=1,err=:nrcp-read-error:) emin, emax, ne, nb, endian, cdum;
IF( ichar(endian) = 0 ) [ endianess = '1234'; ] ELSE [ endianess = '4321'; ]
swap = endianess.ne.$BYTE_ORDER;
IF( swap ) [
    tmp_4 = emin; call egs_swap_4(c_4); emin = tmp_4;
    tmp_4 = emax; call egs_swap_4(c_4); emax = tmp_4;
    itmp_4 = ne; call egs_swap_4(ic_4); ne = itmp_4;
    itmp_4 = nb; call egs_swap_4(ic_4); nb = itmp_4;
]
$egs_info('(//a,a)','Reading NRC pair data base from ',$cstring(nrcp_file));
$egs_info('(a,a,a)','Data generated on a machine with ',endianess,' endianess');
$egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
IF( swap ) [ $egs_info('(a)','=> will need to do byte swaping'); ]
$egs_info('(a,2f9.3)','Energy range of the data: ',emin,emax);
IF( nb ~= $NRC-PAIR-NXX ) [
    $egs_fatal(*,'Inconsistent x-grid size');
]
IF( ne ~= $NRC-PAIR-NEE ) [
    $egs_fatal(*,'Inconsistent energy grid size');
]
nrcp_emin = emin; nrcp_emax = emax;
nrcp_dle = log((emax-2)/(emin-2))/(ne-1); nrcp_dlei = 1/nrcp_dle;

nbb = nb/2; ddx = sqrt(0.5)/nbb;
DO ix=0,nbb [ xx = ddx*ix; nrcp_xdata(ix+1) = xx*xx; ]
do ix=nbb-1,0,-1 [ xx = ddx*ix; nrcp_xdata(nb-ix) = 1 - xx*xx; ]

DO medium = 1,NMED [
    $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
    DO ie=1,$NRC-PAIR-NEE [
        DO ix=1,$NRC-PAIR-NXX [ nrcp_fdata(ix,ie,medium) = 0; ]
    ]
    DO i_ele=1,NNE(medium) [
        Z = ZELEM(medium,i_ele); iz = int(Z+0.5);
        tmp = PZ(medium,i_ele)*Z*Z;
        irec = (iz-1)*ne + 2;
        DO ie=1,$NRC-PAIR-NEE [
            read(nrcp_unit,rec=irec,err=:nrcp-read-error:) tarray;
            DO ix=1,$NRC-PAIR-NXX [
                tmp_4 = tarray(ix);
                IF( swap ) [ call egs_swap_4(c_4); ]
                nrcp_fdata(ix,ie,medium)=nrcp_fdata(ix,ie,medium)+tmp*tmp_4;
            ]
            irec = irec + 1;
        ]
    ]
    DO ie=1,$NRC-PAIR-NEE [
        call prepare_alias_table(nb-1,nrcp_xdata,nrcp_fdata(1,ie,medium),
                nrcp_wdata(1,ie,medium),nrcp_idata(1,ie,medium));
    ]

    $egs_info('(a)',' done');

]
$egs_info(*,' ');
close(nrcp_unit);
return;

:nrcp-open-error:;
$egs_fatal(*,'Failed to open NRC pair data file');

:nrcp-read-error:;
$egs_fatal(*,'I/O error while reading NRC pair data file');

end;

%E
"******************************************************************"
"                               NATIONAL RESEARCH COUNCIL OF CANADA"
"                                                                  "
subroutine vmc_electron(ircode);
"                                                                  "
"******************************************************************"
"   This subroutine performs condensed history simulation of       "
"   electron/positron transport according to VMC                   "
"                                                                  "
"   Version 1.0   Iwan Kawrakow       Initial coding               "
"                                     coding is in EGSnrc style    "
"                                     for maximum compatibility    "
"                                     with EGSnrc user codes       "
"******************************************************************"

$IMPLICIT-NONE;

;COMIN/EGS-IO/;

$INTEGER ircode;
$egs_fatal('(//a//)',
' ********* VMC Transport option not in this distribution ****** ');
end;

" Subroutine versions of the random number generator "
" Included here because it makes life easier for using the EGSnrc RNG"
" from within the C-interface. "
subroutine egs_init_default_rng;
;COMIN/RANDOM/;
$RNG-DEFAULT-INITIALIZATION;
return; end;

subroutine egs_init_rng(arg1,arg2);
$INTEGER arg1,arg2;
;COMIN/RANDOM/;
$declare_write_buffer;
$INITIALIZE RNG USING arg1 AND arg2;
return; end;

subroutine egs_get_rndm(ran);
$REAL ran;
;COMIN/RANDOM/;
$RANDOMSET ran;
return; end;

subroutine egs_get_rndm_array(n,rarray);
$INTEGER n;
$REAL    rarray(*);
;COMIN/RANDOM/;
$REAL    rtmp;
$INTEGER i;
IF( n < 1 ) return;
DO i=1,n [
    $RANDOMSET rtmp; rarray(i) = rtmp;
]
return; end;

/****************************************************************************
 *
 * Subroutines for modelling Electron Impact Ionization (EII) in EGSnrc.
 * This implementation uses EII cross section derived from a GOS
 * approach using photo-ionization cross sections from EPDL97 for the
 * OOS. It is called "simple" because
 *   - Ionizations of only K-, LI-, LII- and LIII-shell with binding
 *     energies above 1 keV are taken into account
 *   - Simplified versions of the differential cross sections are used
 *     (but it is made sure that the total energy loss is still
 *      correctly reproduced).
 *
 * EII is turned on by setting the flag eii_flag in COMIN/EII-DATA/ to 1.
 *
 * Iwan Kawrakow, March 2004.
 *
 *****************************************************************************/

"**************************************************************************"
"Init EII. This subroutine is called from HATCH after all media are known, "
"threshold energies and interpolation data have been initialized.          "
"**************************************************************************"
subroutine eii_init;
"**************************************************************************"
implicit none;
$COMIN-EII-INIT;
$INTEGER imed,iele,ish,nsh,iZ,j,i,itmp,nskip,nbin,ii,nsh_tot,iii,k;
$INTEGER jj,jjj;
integer*4 lnblnk1;
$INTEGER tmp_array($MXELEMENT);
$INTEGER want_eii_unit,eii_unit,eii_out,egs_open_file;
integer  egs_get_unit;
$REAL    e_eii_min,emax,fmax,aux_array($N_EII_BINS);
$REAL    sigo,loge,tau,beta2,p2,uwm,Wmax;
$REAL    ss_0, ss_1, sh_0, sh_1, aux, av_e, con_med, dedx_old, sigm_old;
$REAL    dedx,e,sig,sigm,wbrem,sum_a,sum_z,sum_pz,sum_wa,Ec,Ecc;
$REAL    sum_sh,sum_occn,U,sum_sigma,sum_dedx;
$REAL    sigma,sigma_old,wbrem_old,sig_j,de;
$INTEGER lloge;
$LOGICAL check_it,is_monotone,getd;
$REAL    sigma_max;
character eii_file*128;
character*512 toUpper;
$INTEGER occn_numbers(4);
$declare_write_buffer;
$REAL    cons;
parameter (cons = 0.153536); " 2*Pi*Re^2*rm/u "
data     occn_numbers/2,2,2,4/;

DO j=1,$MXELEMENT [ eii_nshells(j) = 0; ]
DO j=1,$MXMED [ eii_nsh(j) = 0; ]
IF( eii_flag = 0 ) [ return; ]

$need_relaxation_data(getd);
IF( ~getd )[
  $egs_fatal('(/a,/a,/a,/a)',
          ' In subroutine eii_init: ',
          '   Scattering off bound electrons creates atomic vacancies,',
          '   potentially starting an atomic relaxation cascade. ',
          '   Please turn ON atomic relaxations.');
]

/*
  find minimum of all threshold energies
 */
e_eii_min = 1e30;
DO imed = 1,nmed [
    IF( ae(imed)-rm < e_eii_min ) e_eii_min = ae(imed) - rm;
    IF( ap(imed) < e_eii_min ) e_eii_min = ap(imed);
]
$egs_info(*,' ');
$egs_info(*,'eii_init: minimum threshold energy found: ',e_eii_min);

/*
  determine elements that need to load EII data
 */
DO imed = 1,nmed [
    DO iele = 1,nne(imed) [
        iZ = int(zelem(imed,iele)+0.5);
        IF( eii_nshells(iZ) = 0 ) [
            nsh = 0;
            DO ish=1,4 [
                IF( binding_energies(ish,iZ) > e_eii_min ) nsh = nsh+1;
            ]
            eii_nshells(iZ) = nsh;
        ]
    ]
]

/* total number of shells that need to be loaded */
nsh = 0;
DO iZ=1,$MXELEMENT [
    nsh = nsh + eii_nshells(iZ);
]
IF( nsh = 0 ) [
    $egs_info(*,'*** EII requested but no shells with binding energies ');
    $egs_info(*,'    above the specified threshold found');
    $egs_info(*,'    => turning off EII');
    eii_flag = 0;
]
IF( nsh > $MAX_EII_SHELLS ) [
    $egs_info(*,'*** Number of shells with binding energies greater than ');
    $egs_info(*,'    the specified thresholds is ',nsh);
    $egs_info(*,'    This is more than the allocated arrays can hold');
    $egs_fatal(*,'    Increase the macro $MAX_EII_SHELLS and retry');
]
$egs_info(*,'eii_init: number of shells to simulate EII: ',nsh);
nsh_tot = nsh;
tmp_array(1) = 0;
DO j=2,$MXELEMENT [ tmp_array(j) = tmp_array(j-1) + eii_nshells(j-1); ]

/* set EII active shells per medium and for each element */
DO imed=1,nmed [
    nsh = 0;
    DO iele=1,nne(imed) [
        iZ = int(zelem(imed,iele)+0.5);
        eii_no(imed,iele) = eii_nshells(iZ);
        nsh = nsh + eii_nshells(iZ);
        IF( eii_nshells(iZ) > 0 ) [ eii_first(imed,iele) = tmp_array(iZ) + 1; ]
        ELSE [ eii_first(imed,iele) = 0; ]
    ]
    eii_nsh(imed) = nsh;
]

/* read EII data */
$set_string(eii_file,' ');
eii_file = $cstring(hen_house) // 'data' // $file_sep // 'eii_'//
           $cstring(eii_xfile) //'.data';
want_eii_unit = 62;
eii_unit = egs_get_unit(want_eii_unit);
IF( eii_unit < 1 ) [
    $egs_fatal(*,'eii_init: failed to get a free Fortran I/O unit');
]
open(eii_unit,file=$cstring(eii_file),status='old',err=:no-eii-file:);
$egs_info('(//a,a)','Opened EII data file ',$cstring(eii_file));
$egs_info('(a,$)',' eii_init: reading EII data ... ');
read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) nskip;
DO j=1,nskip [
    read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:);
]
read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) emax,nbin;
IF( nbin ~= $N_EII_BINS ) [
    $egs_fatal(*,'Inconsistent EII data file');
]
IF (xsec_out = 1)[
   eii_out = egs_open_file(93,0,1,'.eiixsec');
]
ii = 0;
DO j=1,$MXELEMENT [
    read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) iZ,nsh;
    IF (xsec_out = 1 & eii_nshells(iZ) > 0)[
     write(eii_out,*) '=================================';
     write(eii_out,'(a,i3)') 'EII xsections for element Z = ',iZ;
     write(eii_out,*) '=================================';
    ]
    IF( nsh < eii_nshells(iZ) ) [
        $egs_info(*,'EII data file has data for ',nsh,' shells for element ');
        $egs_info(*,iZ,' but according');
        $egs_info(*,'to binding energies and thresholds ',eii_nshells(iZ));
        $egs_info(*,'shells are required');
        $egs_fatal(*,'This is a fatal error.');
    ]
    DO ish=1,nsh [
        read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) fmax;
        read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:)
           aux_array;
        "Scale L-shell EII xsections by eii_L_factor. Defaults to 1."
        IF (ish>1 & ish < 5) [fmax = fmax*eii_L_factor;]
        IF( ish <= eii_nshells(iZ) ) [
            IF (xsec_out = 1)[
              IF(ish = 1)[
               write(eii_out,'(a,f10.2,a)')
               'K-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSEIF (ish = 2)[
               write(eii_out,'(a,f9.2,a)')
               '=> LI-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSEIF (ish = 3)[
               write(eii_out,'(a,f8.2,a)')
               '=> LII-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSEIF (ish = 4)[
               write(eii_out,'(a,f8.2,a)')
               '=> LIII-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSE[ write(eii_out,*) '=> Wrong number of shells!';]
              write(eii_out,*) '   E/keV     sigma/(b/atom)';
              write(eii_out,*) '---------------------------';
            ]
            ii = ii+1; eii_z(ii) = iZ; eii_sh(ii) = ish;
            eii_a(ii) = nbin;
            eii_a(ii) = eii_a(ii)/log(emax/binding_energies(ish,iZ));
            eii_b(ii) = 1 - eii_a(ii)*log(binding_energies(ish,iZ));
            DO k=1,nbin [
                IF( k > 1 ) [ sigo = fmax*aux_array(k-1); ]
                ELSE [ sigo = 0; ]
                loge = (k - eii_b(ii))/eii_a(ii); iii = nbin*(ii-1)+k;
                eii_xsection_a(iii) = (fmax*aux_array(k)-sigo)*eii_a(ii);
                eii_xsection_b(iii) = sigo - eii_xsection_a(iii)*loge;
                IF (xsec_out = 1)[
                   write(eii_out,'(f12.2,2X,10f9.2)')
                   Exp((k+1-eii_b(ii))/eii_a(ii))*1000.0,fmax*aux_array(k);
                ]
            ]
        ]
    ]
    IF( ii = nsh_tot ) [ EXIT; ]
]
close(eii_unit);
IF (xsec_out = 1)[ close(eii_out); ]
$egs_info(*,' OK '); $egs_info(*,' ');

/*
   Adjust restricted stopping power and discrete inelastic cross sections

   Discrete interaction cross sections for all shells that come from PEGS4
   are calculated using the Moller cross section
     => we must subtract the Moller cross section for the shells that will
        have EII and then add the EII cross sections for these shells
   The restricted stopping power that comes from PEGS4 is calculated assuming
   that all shells will be producing secondaries according to Moller
     => we must add the energy lost in Moller events in EII shells to the
        restricted stopping power and then subtract the average energy lost
        in EII events.
 */
DO imed = 1,nmed [
    Ec = ae(imed) - rm; Ecc = min(Ec,ap(imed));
    /sum_z,sum_pz,sum_a,sum_wa/=0;
    DO iele=1,nne(imed) [
        sum_z = sum_z + pz(imed,iele)*zelem(imed,iele);
        sum_pz = sum_pz + pz(imed,iele);
        sum_wa = sum_wa + rhoz(imed,iele);
        sum_a = sum_a + pz(imed,iele)*wa(imed,iele);
    ]
    con_med = rho(imed)/1.6605655/sum_a;
    eii_cons(imed) = con_med;
    IF( eii_nsh(imed) > 0 ) [
        is_monotone = .true.;
        sigma_max = 0;
        DO j=1,meke(imed) [
            loge = (j - eke0(imed))/eke1(imed); e = Exp(loge);
            tau = e/rm; beta2 = tau*(tau+2)/(tau+1)**2;
            p2 = 2*rm*tau*(tau+2);
            lloge = j;
            medium = imed;
            $EVALUATE dedx USING ededx(loge);
            IF( e > ap(medium) | e > 2*Ec ) [
                $EVALUATE sig USING esig(loge);
            ] ELSE [ sig = 0; ]
            IF( e > 2*Ec ) [
                $EVALUATE wbrem USING ebr1(loge);
                sigm = sig*(1-wbrem);
            ] ELSE [ sigm = 0; wbrem = 1; ]
            /sum_occn,sum_sigma,sum_dedx/=0;
            DO iele=1,nne(imed) [
                iZ = int(zelem(imed,iele)+0.5);
                sum_sh = 0;
                DO ish = 1,eii_no(imed,iele) [
                    "jj is the shell index in the list of EII shells "
                    jj = eii_first(imed,iele) + ish - 1;
                    "jjj is shell type (1 = K, 2 = LI, 3 = LII, etc.)
                    jjj = eii_sh(jj); U = binding_energies(jjj,iZ);
                    Wmax = (e+U)/2; uwm = U/Wmax;
                    "IF( Uj >= Ecc ) sum_sh = sum_sh + occn_numbers(jjj);
                    IF( U < e & U > Ecc ) [
                        " At this energy interactions with this shell will "
                        " be done using the EII differential x-section "
                        sum_sh = sum_sh + occn_numbers(jjj);
                        ss_0 = 2*(log(p2/U)-uwm**3*log(p2/Wmax)-
                          (beta2+0.833333)*(1-uwm**3))/3/U;
                        sh_0 = ((1-uwm)*(1+uwm/(2-uwm))+U*(Wmax-U)/(e+rm)**2
                          - (2*tau+1)/(tau+1)**2*uwm/2*log((2-uwm)/uwm))/U;
                        ss_1 = log(p2/U)-uwm**2*log(p2/Wmax)-
                          (beta2+1)*(1-uwm**2);
                        sh_1 = log(Wmax/U/(2-uwm))+2*(Wmax-U)/(2*Wmax-U)
                          +(Wmax**2-U**2)/(e+rm)**2/2
                          -(2*tau+1)/(tau+1)**2*log((2*Wmax-U)/Wmax);
                        av_E = (ss_1 + sh_1)/(ss_0 + sh_0);
                          "av_E is the average energy lost in a collision"
                          "with this shell"
                        i = eii_a(jjj)*loge + eii_b(jjj);
                        i = (jj-1)*$N_EII_BINS + i;
                        sig_j = eii_xsection_a(i)*loge + eii_xsection_b(i);
                        sig_j = sig_j*pz(imed,iele)*con_med;
                        sum_sigma = sum_sigma + sig_j;
                        sum_dedx = sum_dedx + sig_j*av_E;
                    ]
                ]
                sum_occn = sum_occn + sum_sh*pz(imed,iele);
            ]
            sigm = sigm + sum_sigma;
            dedx = dedx - sum_dedx;
            aux = Ec/e;
            IF( e > 2*Ec ) [
                sigo = cons*sum_occn*rho(imed)/(beta2*Ec)*(
                        (1-2*aux)*(1+aux/(1-aux)+(tau/(tau+1))**2*aux/2)-
                        (2*tau+1)/(tau+1)**2*aux*log((1-aux)/aux))/sum_a;
                de = cons*sum_occn*rho(imed)/beta2*(
                  log(0.25/aux/(1-aux))+(1-2*aux)/(1-aux)+
                  (tau/(tau+1))**2*(1-4*aux*aux)/8-
                  (2*tau+1)/(tau+1)**2*log(2*(1-aux)))/sum_a;
                sigm = sigm - sigo;
                "sigm = sig*(1-wbrem)*(1-sum_occn/sum_z);
                dedx = dedx + de;
            ]
            sigma = sigm + wbrem*sig;
            IF( sigma/dedx > sigma_max ) sigma_max = sigma/dedx;
            IF( sigma > 0 ) [ wbrem = wbrem*sig/sigma; ]
            ELSE [ wbrem = 1; ]
            IF( j > 1 ) [
                ededx1(j-1,imed) = (dedx - dedx_old)*eke1(imed);
                ededx0(j-1,imed) = dedx - ededx1(j-1,imed)*loge;
                esig1(j-1,imed) = (sigma - sigma_old)*eke1(imed);
                esig0(j-1,imed) = sigma - esig1(j-1,imed)*loge;
                ebr11(j-1,imed) = (wbrem - wbrem_old)*eke1(imed);
                ebr10(j-1,imed) = wbrem - ebr11(j-1,imed)*loge;
                IF( sigma/dedx < sigma_old/dedx_old ) is_monotone = .false.;
            ]
            dedx_old = dedx; sigm_old = sigm;
            sigma_old = sigma; wbrem_old = wbrem;
        ]
        ededx1(meke(imed),imed) = ededx1(meke(imed)-1,imed);
        ededx0(meke(imed),imed) = ededx0(meke(imed)-1,imed);
        esig1(meke(imed),imed) = esig1(meke(imed)-1,imed);
        esig0(meke(imed),imed) = esig0(meke(imed)-1,imed);
        ebr11(meke(imed),imed) = ebr11(meke(imed)-1,imed);
        ebr10(meke(imed),imed) = ebr10(meke(imed)-1,imed);
        $egs_info(*,'eii_init: for medium ',imed,' adjusted sige = ',
                sigma_max,' monotone = ',is_monotone);
        sig_ismonotone(0,imed) = is_monotone;
        esig_e(imed) = sigma_max;
    ]
]
return;

:eii-reading-error:
$egs_fatal(*,'I/O error while reading EII data');

:no-eii-file:
$egs_fatal('(//a,a,/a,/a/)','Failed to open EII data file ',$cstring(eii_file),
          'Make sure file exists in your $HEN_HOUSE/data directory!',
          '****BEWARE of case sensitive file names!!!');

return; end;

"*****************************************************************************"

subroutine eii_sample(ish,iZ,Uj);
implicit none;
$INTEGER ish,iZ;
$REAL    Uj;

$COMIN-EII-SAMPLE;

$REAL T,tau,tau1,tau12,tau2,p2,beta2,c1,c2,Wmax,xmax,fm_s,fm_h,prob_s,prob;
$REAL r1,r2,r3,wx,wxx,aux,frej;
real*8 peie,pese1,pese2,dcosth,h1;
$INTEGER iarg;
$REAL    eta,cphi,sphi;
$INTEGER np_save,ip,j;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;

/* calculate some useful constants */
peie = e(np);
T = peie - rm; tau = T/rm; tau1 = tau+1;
tau12 = tau1*tau1; tau2 = tau*tau; p2 = tau2 + 2*tau;
beta2 = p2/tau12;
"c1 = tau2/tau12; "
Wmax = 0.5*(T+Uj); xmax = Uj/Wmax;
c1 = (Wmax/peie)**2;
c2 = (2*tau+1)/tau12;
fm_s = log(rmt2*p2/Uj) - beta2 - 0.5;
prob_s = 0.66666667*fm_s*(1+xmax+xmax*xmax);
"fm_h = 1 + c1 - c2;"
fm_h = 2 + c1 - c2;
IF( fm_h < 1 ) fm_h = 1;
prob = fm_h + prob_s;

LOOP [
    $RANDOMSET r1; $RANDOMSET r2; $RANDOMSET r3;
    IF( r1*prob < fm_h ) [ "Use the hard collision cross section "
        wx = 1/(r2*xmax+1-r2); wxx = wx*xmax; aux = wxx/(2-wxx);
        frej = (1 + aux*(aux-c2)+c1*wxx*wxx)/fm_h;
    ] ELSE [               "Use the soft collision cross section "
        wx = 1/(r2*xmax**3+1-r2)**0.333333333;
        frej = 1 - log(wx)/fm_s;
    ]
] UNTIL ( r3 < frej );

wx = wx*Uj;

/* set-up new particles */
h1 = (peie + prm)/T; pese1 = peie - wx;
e(np) = pese1;
dcosth = h1*(pese1-prm)/(pese1+prm);
sinthe = dsqrt(1-dcosth); costhe = dsqrt(dcosth);
call uphi(2,1);

pese2 = wx - Uj + prm;
edep_local = 0;
IF( pese2 > ae(medium) ) [
    $CHECK-STACK(np+1,'eii_sample');
    np = np+1; e(np) = pese2;
    dcosth = h1*(pese2-prm)/(pese2+prm);
    sinthe = -dsqrt(1-dcosth); costhe = dsqrt(dcosth);
    iq(np) = -1; call uphi(3,2);
    edep = 0;
] ELSE [
    edep = wx - Uj;
    edep_local = edep;
    $AUSCALL($SELECTRONA);
]
"ish ranges from 1 to 4 for K,L1,L2,L3 shells"
call relax(Uj,ish,iZ);

IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); ]

/*
IF( nbr_split > 1 ) [
    np_save = np;
    DO ip=NPold+1,np_save [
        IF( iq(ip) = 0 ) [
            wt(ip) = wt(ip)/nbr_split;
            DO j = 1,nbr_split-1 [
                np = np + 1; $CHECK-STACK(np,'eii_sample');
                iq(np) = 0; e(np) = e(ip);
                $TRANSFER PROPERTIES TO (np) FROM (ip);
                $RANDOMSET eta; eta = 2*eta - 1; w(np) = eta;
                eta = (1-eta)*(1+eta);
                IF( eta > 1e-20 ) [
                    eta = Sqrt(eta);
                    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
                    u(np) = eta*cphi; v(np) = eta*sphi;
                ] ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
            ]
        ]
    ]
]
*/


return; end;

"============================================================================"
subroutine egs_scale_photon_xsection(imed,fac,which);
"============================================================================"
"
"  Scale the photon cross section 'which' by factor fac for medium imed.
"  which = 0 for all cross sections
"        = 1 for Rayleigh scattering
"        = 2 for Compton scattering
"        = 3 for Pair production
"        = 4 for photo-absorption
"  If imed = 0, scaling is done for all media.
"============================================================================"
implicit none;
$INTEGER imed,which;
$REAL    fac;
$declare_max_medium;
;COMIN/MEDIA,PHOTIN,EGS-IO/;
$INTEGER ifirst,ilast,medium,j;
$LOGICAL has_r;
$REAL    gle,gmfp,gbr1,gbr2,cohfac,aux,gmfp_old,gbr1_old,gbr2_old,cohfac_old;
character*8 strings(5);
data       strings/'photon','Rayleigh','Compton','pair','photo'/;

IF( which < 0 | which > 4 ) [ return; ]
IF( imed > 0 & imed <= nmed ) [ ifirst = imed; ilast = imed; ]
ELSE [ ifirst = 1; ilast = nmed; ]
IF( which = 1 ) [
    has_r = .false.;
    DO medium = ifirst, ilast [
        IF( iraylm(medium) = 1 ) [ has_r = .true.; ]
    ]
    IF( ~has_r ) return;
]
$egs_info(*,' ');
DO medium = ifirst,ilast [

    $egs_info('(a,a,a,i3,a,f9.5)',
            'Scaling ',strings(which+1),' x-section data for medium',
            medium,' with ',fac);

    DO j = 1,mge(medium) [

        gle = (j - ge0(medium))/ge1(medium);
        gmfp = gmfp0(j,medium) + gmfp1(j,medium)*gle;
        gbr1 = gbr10(j,medium) + gbr11(j,medium)*gle;
        gbr2 = gbr20(j,medium) + gbr21(j,medium)*gle;
        IF( iraylm(medium) = 1 ) [
            cohfac = cohe0(j,medium) + cohe1(j,medium)*gle;
        ] ELSE [ cohfac = 1; ]
        IF( which = 0 ) [ gmfp = gmfp/fac; ]
        ELSE IF( which = 1 ) [ cohfac = cohfac/(fac*(1-cohfac)+cohfac); ]
        ELSE [
            IF( which = 2 ) [
                aux = fac*(gbr2-gbr1) + gbr1 + 1 - gbr2;
                gbr2 = (gbr1 + fac*(gbr2-gbr1))/aux; gbr1 = gbr1/aux;
            ]
            ELSE IF( which = 3 ) [
                aux = fac*gbr1 + 1 - gbr1;
                gbr2 = (fac*gbr1 + gbr2-gbr1)/aux; gbr1 = fac*gbr1/aux;
            ]
            ELSE [
                aux = gbr2 + fac*(1-gbr2);
                gbr1 = gbr1/aux; gbr2 = gbr2/aux;
            ]
            gmfp = gmfp/aux;
            cohfac = cohfac*aux/(aux*cohfac + 1 - cohfac);
        ]
        IF( j > 1 ) [
            gmfp1(j-1,medium) = (gmfp - gmfp_old)*ge1(medium);
            gmfp0(j-1,medium) = gmfp - gmfp1(j-1,medium)*gle;
            gbr11(j-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
            gbr10(j-1,medium) = gbr1 - gbr11(j-1,medium)*gle;
            gbr21(j-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
            gbr20(j-1,medium) = gbr2 - gbr21(j-1,medium)*gle;
            cohe1(j-1,medium) = (cohfac - cohfac_old)*ge1(medium);
            cohe0(j-1,medium) = cohfac - cohe1(j-1,medium)*gle;
        ]
        gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohfac_old = cohfac;

    ]
    gmfp1(mge(medium),medium) = gmfp1(mge(medium)-1,medium);
    gmfp0(mge(medium),medium) = gmfp0(mge(medium)-1,medium);
    gbr11(mge(medium),medium) = gbr11(mge(medium)-1,medium);
    gbr10(mge(medium),medium) = gbr10(mge(medium)-1,medium);
    gbr21(mge(medium),medium) = gbr21(mge(medium)-1,medium);
    gbr20(mge(medium),medium) = gbr20(mge(medium)-1,medium);
    cohe1(mge(medium),medium) = cohe1(mge(medium)-1,medium);
    cohe0(mge(medium),medium) = cohe0(mge(medium)-1,medium);
]

return; end;

/*============================================================================

 Subroutines to initialize photon cross section data.
 The data is read from string_photo.data, string_pair.data,
 string_triplet.data, and string_rayleigh.data, where string is the argument
 passed to the subroutine.

============================================================================*/

REPLACE {$OPEN-UNIT(#,#,#);} WITH {
    {P1} = {P2};
    {P1} = egs_get_unit({P1});
    IF( {P1} < 1 ) [
        $egs_fatal(*,
         'egs_init_user_photon: failed to get a free Fortran I/O unit');
    ]
    tmp_string = {P3};
    open({P1},file={P3},status='old',err=:no-user-data-file:);
};

REPLACE {$MXINPUT} WITH {2000};
REPLACE {$MXBCINP} WITH {183};

"============================================================================="
"Ali:photonuc, 1 line"
 subroutine egs_init_user_photon(prefix,comp_prefix,photonuc_prefix,out);
"subroutine egs_init_user_photon(prefix,comp_prefix,out);"
"============================================================================="
implicit none;
$declare_max_medium;
character*(*) prefix, comp_prefix,
"Ali:photonuc, 1 line"
              photonuc_prefix;
$INTEGER      out;
;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,COMPTON-DATA,X-OPTIONS/;
$INTEGER   lnblnk1,egs_get_unit,medium,
           photo_unit,pair_unit,rayleigh_unit,triplet_unit,
           ounit,egs_open_file,compton_unit,
"Ali:photonuc, 1 line"
           photonuc_unit;
$INTEGER   nge,sorted($MXEL),i,j,k,iz,iz_old,ndat;
$REAL      z_sorted($MXEL),pz_sorted($MXEL);
$REAL      sig_photo($MXGE),sig_pair($MXGE),sig_triplet($MXGE),
           sig_rayleigh($MXGE),sig_compton($MXGE);
$REAL      sigma,cohe,gmfp,gbr1,gbr2,sig_KN,gle,e,sig_p;
$REAL      cohe_old,gmfp_old,gbr1_old,gbr2_old,
"Ali:photonuc, 3 lines"
           sig_photonuc($MXGE),
           photonuc,
           photonuc_old;

$REAL      etmp($MXINPUT),ftmp($MXINPUT);
$REAL      sumZ,sumA,con1,con2,egs_KN_sigma0;
$REAL      bc_emin,bc_emax,bc_dle,bc_data($MXBCINP),bc_tmp($MXBCINP),bcf,aj;
$INTEGER   bc_ne;
$LOGICAL   input_compton_data,
"Ali:photonuc, 1 line"
           input_photonuc_data;
character  data_dir*128,photo_file*140,pair_file*140,rayleigh_file*144,
           triplet_file*142,tmp_string*144,compton_file*144,
"Ali:photonuc, 1 line"
           photonuc_file*144;

$egs_info('(/a$)','(Re)-initializing photon cross sections');
$egs_info('(a,a/)',' with files from the series: ',
      prefix(:lnblnk1(prefix)));

$egs_info('(a,a)',' Compton cross sections: ',$cstring(comp_prefix));

"Ali:photonuc, 1 block"
IF(iphotonuc = 1) [
 $egs_info('(a,a)',' Photonuclear cross sections: ',
 $cstring(photonuc_prefix));
 input_photonuc_data = .false.;
 IF(lnblnk1(photonuc_prefix) > 0 & photonuc_prefix(1:7) ~= 'default') [
   input_photonuc_data = .true.;
 ]
]

input_compton_data = .false.;
IF( ibcmp(1) > 1 & lnblnk1(comp_prefix) > 0 ) [
    IF( comp_prefix(1:7) ~= 'default' ) input_compton_data = .true.;
]
data_dir = $cstring(hen_house) // 'data' // $file_sep;
photo_file = $cstring(data_dir) // $cstring(prefix) // '_photo.data';
pair_file = $cstring(data_dir) // $cstring(prefix) // '_pair.data';
triplet_file = $cstring(data_dir) // $cstring(prefix) // '_triplet.data';
rayleigh_file = $cstring(data_dir) // $cstring(prefix) // '_rayleigh.data';
IF( input_compton_data ) [
    compton_file = $cstring(data_dir) // $cstring(comp_prefix) //
                   '_compton.data';
]
ELSE [
    compton_file = $cstring(data_dir) // 'compton_sigma.data';
]
"Ali: I moved this info line from inside the IF statement
" because it's useful to print the cross section file either way
$egs_info('(a,a)',' Using Compton cross sections from ',
          $cstring(compton_file));

"Ali:photonuc, 1 block"
IF(iphotonuc = 1) [
 IF( input_photonuc_data ) [
    photonuc_file = $cstring(data_dir) // $cstring(photonuc_prefix) //
                    '_photonuc.data';
 ]
 ELSE [
    photonuc_file = $cstring(data_dir) // 'iaea_photonuc.data';
 ]
 $egs_info('(a,a)',' Using photonuclear cross sections from ',
  $cstring(photonuc_file));
]

$OPEN-UNIT(photo_unit,83,photo_file);
$OPEN-UNIT(pair_unit,84,pair_file);
$OPEN-UNIT(triplet_unit,85,triplet_file);
$OPEN-UNIT(rayleigh_unit,86,rayleigh_file);
IF( ibcmp(1) > 1 ) [ $OPEN-UNIT(compton_unit,88,compton_file); ]
" Note: ibcmp > 1 means the user wants to use Bound Compton scattering "
"       without rejections. For this we have to use the actual bound   "
"       Compton scattering cross section, which is now available in a  "
"       file called bound_compton.data (the file actually contains the "
"       ratio of the Bound Compton to the KN cross section).           "
"       Because this option is not available on a region by region     "
"       basis, we just need to check ibcmp(1)                          "
"Ali:photonuc, 1 line"
IF( iphotonuc = 1 ) [ $OPEN-UNIT(photonuc_unit,89,photonuc_file); ]

IF( out = 1 ) [
    ounit = egs_open_file(87,0,1,'.xsections');
    write(ounit,'(/a,a,a)') 'Photon cross sections initialized from ',
       $cstring(prefix),' data files';
    write(ounit,'(a,/)')
'============================================================================';
    write(ounit,'(a,/)') 'Grid energies and cross sections are output';
"Ali:photonuc, 1 block"
    IF(iphotonuc = 1) [
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a)')
         'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ',
         ' GMFP(cm) ';
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a/)')
         '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh',
         'w/ Ray + photnuc';
    ]
    ELSE[
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a)')
            'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ';
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a/)')
            '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh';
   ]
]
/* Replace binding energies with the edges in the photo-absorption file */
DO iz=1,100 [
    read(photo_unit,*) ndat;
    read(photo_unit,*) (etmp(k),ftmp(k),k=1,ndat);
    k = 0;
    DO j=ndat,2,-1 [
        IF( etmp(j)-etmp(j-1) < 1e-5 ) [
            k = k+1;
            IF ( k <= $MXSHXSEC )[
               binding_energies(k,iz) = exp(etmp(j));
            ]
            ELSE[
              $egs_fatal('(i3,a,i3,//a)',
                         k,' binding energies read exceeding array size of',
                         $MXSHXSEC,'Increase $MXSHXSEC in egsnrc.macros!');
            ]
            IF( ~eadl_relax & k >= 4 ) EXIT;
        ]
    ]
]

IF (mcdf_pe_xsections)[call egs_read_shellwise_pe();]

DO medium = 1,nmed [

    mge(medium) = $MXGE; nge = $MXGE;
    ge1(medium) = nge-1; ge1(medium) = ge1(medium)/log(up(medium)/ap(medium));
    ge0(medium) = 1 - ge1(medium)*log(ap(medium));

    $egs_info('(a,i3,a,$)',' Working on medium ',medium,' ... ');
    IF( out = 1 ) [
        write(ounit,'(/,2x,a,i3,a,24a1/)') 'Medium ',medium,': ',
          (media(k,medium),k=1,24);
    ]
    /sumZ,sumA/ = 0;
    DO i=1,nne(medium) [
        z_sorted(i) = zelem(medium,i);
        sumZ = sumZ + pz(medium,i)*zelem(medium,i);
        sumA = sumA + pz(medium,i)*wa(medium,i);
    ]
    con1 = sumZ*rho(medium)/(sumA*1.6605655);
    con2 = rho(medium)/(sumA*1.6605655);
    call egs_heap_sort(nne(medium),z_sorted,sorted);
    DO i=1,nne(medium) [ pz_sorted(i) = pz(medium,sorted(i)); ]

    IF (mcdf_pe_xsections)[
       call egsi_get_shell_data(medium,nge,nne(medium),z_sorted,pz_sorted,
                                ge1(medium),ge0(medium),sig_photo);
    ]
    ELSE[
       call egsi_get_data(0,photo_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_photo);
    ]
    call egsi_get_data(0,rayleigh_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_rayleigh);
    call egsi_get_data(1,pair_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_pair);
    call egsi_get_data(2,triplet_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_triplet);
"Ali:photonuc, 1 block"
    IF( iphotonuc = 1 ) [
      call egsi_get_data(3,photonuc_unit,nge,nne(medium),z_sorted,pz_sorted,
                        ge1(medium),ge0(medium),sig_photonuc);
    ]

    IF( ibcmp(1) > 1 ) [
        "Get the bound compton cross section data"
        IF( input_compton_data ) [
            call egsi_get_data(0,compton_unit,nge,nne(medium),
                    z_sorted,pz_sorted,ge1(medium),ge0(medium),
                    sig_compton);
        ]
        ELSE [
            rewind(compton_unit);
            read(compton_unit,*) bc_emin,bc_emax,bc_ne;
            IF( bc_ne > $MXBCINP ) [
              $egs_fatal(*,'Number of input Compton data exceeds array size');
            ]
            "write(6,*) 'bc emin,emax,ne = ',bc_emin,bc_emax,bc_ne;
            bc_dle = log(bc_emax/bc_emin)/(bc_ne-1);
            DO j=1,bc_ne [ bc_data(j) = 0; ]
            iz_old = 1;
            DO i=1,nne(medium) [
                iz = int(z_sorted(i)+0.5);
                "write(6,*) ' reading bc data for ',iz;
                DO j=iz_old,iz [ read(compton_unit,*) (bc_tmp(k),k=1,bc_ne); ]
                DO j=1,bc_ne [
                    bc_data(j)=bc_data(j)+pz_sorted(i)*z_sorted(i)*bc_tmp(j);
                ]
                iz_old = iz+1;
            ]
            DO j=1,bc_ne [ bc_data(j)=log(bc_data(j)/sumZ); ]
        ]
    ]

    /* prepare data needed for Rayleigh scattering sampling */
    call egs_init_rayleigh(medium,sig_rayleigh);

    DO i=1,nge [

        gle = (i - ge0(medium))/ge1(medium); e = exp(gle);
        sig_KN = sumZ*egs_KN_sigma0(e);
        IF( ibcmp(1) > 1 ) [
            IF( input_compton_data ) [
                sig_KN = sig_compton(i);
            ]
            ELSE [
                "Apply the bound Compton correction to sig_KN"
                IF( e <= bc_emin ) [ bcf = exp(bc_data(1)); ]
                ELSE IF( e < bc_emax ) [
                    aj = 1 + log(e/bc_emin)/bc_dle;
                    j = int(aj); aj = aj - j;
                    bcf = exp(bc_data(j)*(1-aj) + bc_data(j+1)*aj);
                ]
                ELSE [ bcf = 1; ]
                sig_KN = sig_KN*bcf;
                "write(6,*) 'e = ',e,' bcf = ',bcf;
            ]
        ]
        sig_p  = sig_pair(i) + sig_triplet(i);
        sigma  = sig_KN + sig_p + sig_photo(i);
        gmfp   = 1/(sigma*con2);
        gbr1   = sig_p/sigma;
        gbr2   = gbr1 + sig_KN/sigma;
        cohe   = sigma/(sig_rayleigh(i) + sigma);
"Ali:photonuc, 1 line"
        photonuc = sigma/(sig_photonuc(i) + sigma);

        IF( out = 1 ) [
"Ali:photonuc, 1 block"
           IF(iphotonucm(medium) = 1) [
              write(ounit,'(6(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,
              gmfp*cohe,gmfp*cohe*photonuc;
           ]
           ELSE[
              write(ounit,'(5(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,gmfp*cohe;
           ]
        ]
        IF( i > 1 ) [
            gmfp1(i-1,medium) = (gmfp - gmfp_old)*ge1(medium);
            gmfp0(i-1,medium) =  gmfp - gmfp1(i-1,medium)*gle;
            gbr11(i-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
            gbr10(i-1,medium) =  gbr1 - gbr11(i-1,medium)*gle;
            gbr21(i-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
            gbr20(i-1,medium) =  gbr2 - gbr21(i-1,medium)*gle;
            cohe1(i-1,medium) = (cohe - cohe_old)*ge1(medium);
            cohe0(i-1,medium) =  cohe - cohe1(i-1,medium)*gle;
"Ali:photonuc, 2 lines"
            photonuc1(i-1,medium) = (photonuc - photonuc_old)*ge1(medium);
            photonuc0(i-1,medium) =  photonuc - photonuc1(i-1,medium)*gle;
        ]
        gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohe_old = cohe;
"Ali:photonuc, 1 line"
        photonuc_old = photonuc;
    ]

    gmfp1(nge,medium) = gmfp1(nge-1,medium);
    gmfp0(nge,medium) = gmfp - gmfp1(nge,medium)*gle;
    gbr11(nge,medium) = gbr11(nge-1,medium);
    gbr10(nge,medium) = gbr1 - gbr11(nge,medium)*gle;
    gbr21(nge,medium) = gbr21(nge-1,medium);
    gbr20(nge,medium) = gbr2 - gbr21(nge,medium)*gle;
    cohe1(nge,medium) = cohe1(nge-1,medium);
    cohe0(nge,medium) = cohe - cohe1(nge,medium)*gle;
"Ali:photonuc, 2 lines"
    photonuc1(nge,medium) = photonuc1(nge-1,medium);
    photonuc0(nge,medium) = photonuc - photonuc1(nge,medium)*gle;

    $egs_info('(a)','OK');
]

close(photo_unit); close(pair_unit);
close(triplet_unit); close(rayleigh_unit);
"Ali:photonuc, 1 line"
IF( iphotonuc = 1 ) [ close(photonuc_unit);]
IF( ibcmp(1) > 1 ) [ close(compton_unit);]
IF( out = 1 )      [ close(ounit); ]
return;

:no-user-data-file:;
$egs_fatal('(//a,a)','Failed to open data file ',$cstring(tmp_string));

return; end;

/*********************************************************************/
subroutine egs_init_rayleigh(medium,sig_rayleigh);
/*********************************************************************
 This routine is called after Rayleigh data has been read from one of
 the available data bases (si, xcom, epdl). Therefore total Rayleigh
 xsections are already available. Here one reads in either custom FF
 for a medium or builds the FF using the atomic FF (default) and the
 IAM (Independent Atom Model). The total Rayleigh xsection must also
 be calculated for the media with user-supplied FF.
 *********************************************************************/
$IMPLICIT-NONE;
$declare_max_medium;
;COMIN/THRESH,          "for threshold energies"
       EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
       rayleigh_inputs,rayleigh_sampling/;

$REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
$REAL xsc, fsc;
$REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
$REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
$REAL totRayleigh2,pzmin;
$REAL emin, emax;
$INTEGER i,j,k,ff_unit, egs_get_unit, ne;
$INTEGER lnblnk1, EOF, nff, medium, ncustom;
character dummy*24, afac_file*128, ff_file*128;

IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"

/*****************************************************************
   Figure out if custom ff needed for medium: check that medium
   is in the list iray_ff_media, else the default atomic ff used.
   This used to be done in subroutine get_transport_parameter
   but was moved here, since it is up to the the user-code to
   read in the information and it is not ensured that the media
   information will be read before getting the transport parameters.
****************************************************************/
ncustom=0;write(dummy,'(24a1)')(media(j,medium),j=1,24);ff_file=' ';
DO i=1,$MXMED[IF(lnblnk1(iray_ff_file(i))~=0)[ncustom = ncustom + 1;]]
DO i=1,ncustom[IF (dummy(:lnblnk1(dummy)) = iray_ff_media(i))[
   ff_file = iray_ff_file(i);
];]

/* Open a fortran unit for reading form factors */
ff_unit = egs_get_unit(0);
IF( ff_unit < 1 ) [
   $egs_fatal(*,
   'egs_init_rayleigh: failed to get a free Fortran I/O unit');
]

/***********************************************************
   Read the FF and calculate the xsections for the custom FF
   or calculate the FF for a molecule using the IAM in the
   atomic case.
 ***********************************************************/
IF ( lnblnk1(ff_file) > 0) ["custom FF requested"
     open(ff_unit,file=$cstring(ff_file),
          status='old',err=:no-ff-file:);
     GOTO :read-ff:;
     :no-ff-file:
     $egs_fatal('(2a)','egs_init_rayleigh: failed to open custom ff file ',
             $cstring(ff_file));
     :read-ff:
     $egs_info('(/2a)','Opened custom ff file ',$cstring(ff_file));
     " read Rayleigh molecular form factor data from a file"
     " which is given as Fmol/sqrt(MW) hence no need to compute"
     " MW to get the xsections in cm-1. See conv variable below"
     j = 0;
     LOOP [
       j = j + 1;
       read(ff_unit,*,IOSTAT = EOF) xsc, fsc;
       IF (EOF < 0) EXIT;
       IF (j <= $MXRAYFF)[xgrid(j,medium)=xsc;ff(j,medium)=fsc;]
     ] REPEAT
     nff = j-1;
     IF (nff > $MXRAYFF)[
        $egs_fatal('(a,/,a,i5,a,i5,/,a)',
        'subroutine egs_init_rayleigh: form factors size too small!!',
        '$XRAYFF =  ', $MXRAYFF,', and need to be ',nff,
        ' and try again!!!');
     ]
     "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
     "and much less for higher energies"
     IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
     write(*,*) '\n  -> ', nff, ' values of mol. ff read!';
     /* Now calculate Rayleigh xsections */
     "Since MW already included in the molecular FF,"
     "must multiply by sumA which is MW for compound"
     "or unity for mixtures."
     sumA = 0.0;
     DO j=1,nne(medium)[sumA=sumA+PZ(medium,j)*WA(medium,j);]
     DO j=1,MGE(medium) [
       gle=(j-GE0(medium))/GE1(medium);e=exp(gle);
       sig_rayleigh(j)=egs_rayleigh_sigma(medium,e,nff,
                       xgrid(1,medium),ff(1,medium))*sumA;
     ]
]
ELSE[
     $set_string(afac_file,' ');
     afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
     open(ff_unit,file=$cstring(afac_file),
       status='old',err=:no-afac-file:);
     GOTO :read-afac:;
     :no-afac-file:
     $egs_fatal('(2a)','egs_init_rayleigh: failed to open atomic ff file',
             $cstring(afac_file));
     :read-afac:
     " read Rayleigh atomic form factor data from a file"
     read(ff_unit,*) xval, aff;
     "calculate form factor using independent atom model"
     DO i=1,$MXRAYFF[
       ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
       DO j=1,nne(medium)[
        ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
       ]
       ff(i,medium) = sqrt(ff(i,medium));
     ]
     nff = $MXRAYFF;
     "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
     "and much less for higher energies"
     IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
     $egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');
]
close(ff_unit);
/* call routine for preparing sampling data */
/* The following is inconsistent with the $SET INTERVAL macro. IK, July 21 2009
   This is because the actual min/max energy of the interpolation
   grid coming from PEGS might be lower/higher than ap/up.
   The medium specific constants ge0(medium) and ge1(medium) come
   from PEGS => one has to use those to find the actual emin/emax.
   If not done that way, the tabulated data will be inconsistent
   with the $SET INTERVAL macro.
call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
                             mge(medium),ap(medium),up(medium),
                             pe_array(1,medium),$RAYCDFSIZE,
                             fcum(1,medium),i_array(1,medium),
                             b_array(1,medium),c_array(1,medium));
*/
emin = exp((1 - ge0(medium))/ge1(medium));
emax = exp((mge(medium) - ge0(medium))/ge1(medium));
call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
                             mge(medium),emin,emax,
                             pe_array(1,medium),$RAYCDFSIZE,
                             fcum(1,medium),i_array(1,medium),
                             b_array(1,medium),c_array(1,medium));

/* prepare coefficients for pmax interpolation */
ne=MGE(medium);dle=log(up(medium)/ap(medium))/(ne-1);
dlei=1/dle;
DO i=1,ne-1 [
   /*  The stuff below is inconsistent with the
       $SET INTERVAL macro (see above) IK, July 21 2009
   gle = log(ap(medium)) + dle*(i-1);
   pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*dlei;
   pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
   */
   gle = (i - ge0(medium))/ge1(medium);
   pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
   pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
]
pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);

return; end;

/*********************************************************************/
subroutine egs_init_rayleigh_sampling(medium);
/*********************************************************************
 This routine is called from HATCH if user requested to use the photon
 xsection data from the pegs4 file. Here one reads in atomic FF and
 builds the FF using the IAM (Independent Atom Model).
 *********************************************************************/
$IMPLICIT-NONE;
$declare_max_medium;
;COMIN/THRESH,          "for threshold energies"
       EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
       rayleigh_inputs,rayleigh_sampling/;

$REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
$REAL xsc, fsc;
$REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
$REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
$REAL totRayleigh2,pzmin;
$REAL emin, emax;
$INTEGER i,j,k,ff_unit, egs_get_unit, ne;
$INTEGER lnblnk1, EOF, nff, medium, ncustom;
character dummy*24, afac_file*128, ff_file*128;

IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"

/* Open a fortran unit for reading form factors */
ff_unit = egs_get_unit(0);
IF( ff_unit < 1 ) [
   $egs_fatal(*,
   'egs_init_rayleigh: failed to get a free Fortran I/O unit');
]

$set_string(afac_file,' ');
afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
open(ff_unit,file=$cstring(afac_file),status='old',err=:no-afac-file:);
GOTO :read-afac:;
:no-afac-file:
$egs_fatal('(2a)',
        'egs_init_rayleigh_sampling: failed to open atomic ff file ',
        $cstring(afac_file));
:read-afac:
" read Rayleigh atomic form factor data from a file"
read(ff_unit,*) xval, aff;
"calculate form factor using independent atom model"
DO i=1,$MXRAYFF[
  ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
  DO j=1,nne(medium)[
   ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
  ]
  ff(i,medium) = sqrt(ff(i,medium));
]
nff = $MXRAYFF;
"To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
"and much less for higher energies"
IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
"write(*,*) '\n  -> ', nff, ' atomic ff values computed!';
$egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');

close(ff_unit);
/* call routine for preparing sampling data */
emin = exp((1 - ge0(medium))/ge1(medium));
emax = exp((mge(medium) - ge0(medium))/ge1(medium));
call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
                             mge(medium),emin,emax,
                             pe_array(1,medium),$RAYCDFSIZE,
                             fcum(1,medium),i_array(1,medium),
                             b_array(1,medium),c_array(1,medium));

/* prepare coefficients for pmax interpolation */
ne=MGE(medium);
DO i=1,ne-1 [
   gle = (i - ge0(medium))/ge1(medium);
   pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
   pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
]
pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);

return; end;

/**********************************************************
   Analytic expression of the Rayleigh xsection in barns.
 **********************************************************/
$REAL function egs_rayleigh_sigma(imed,E,ndat,x,f);
$IMPLICIT-NONE;
$INTEGER i, j, k,imed, ndat;
$REAL hc2,conv,b,hc;
parameter (hc  = 0.0123984768438,  "[Armstrong]*[MeV]"
           hc2 = 0.0001537222280); "h*c squared"
$REAL x($MXRAYFF), f($MXRAYFF), zero, E, xmax;
real*8 x1,x2,pow_x1,pow_x2,raysig,C,C2,f1,f2;
C=2.*hc2/(E*E);C2=C*C;xmax=E/hc;
egs_rayleigh_sigma = 0.0;
DO i=1,ndat-1[
   IF (x(i) = 0.0) x(i) = zero();IF (x(i+1) = 0.0) x(i+1) = zero();
   IF (f(i) = 0.0) f(i) = zero(); IF (f(i+1) = 0.0) f(i+1) = zero();
   b = log(f(i+1)/f(i))/log(x(i+1)/x(i));
   x1=x(i);x2=x(i+1);IF(x2 > xmax) [x2=xmax;]
   pow_x1=x1**(2*b);pow_x2=x2**(2*b);
   raysig = pow_x2*(x2**2/(b+1)-(C*x2**4)/(b+2)+(C2*x2**6)/(2*b+6));
   raysig = raysig - pow_x1*(x1**2/(b+1)-(C*x1**4)/(b+2)+(C2*x1**6)/(2*b+6));
   raysig = raysig*f(i)*f(i)/pow_x1;
   egs_rayleigh_sigma = egs_rayleigh_sigma + raysig;
   IF(x(i+1)>xmax)[EXIT;]"exit loop"
]
/*totRayleigh = 2.*Pi*R02*1E24*C*totRayleigh;"in barns"
 2*Pi*Ro^2*1E24 = 0.49893439187842413747
 */
egs_rayleigh_sigma = 0.49893439187842413747*C*egs_rayleigh_sigma;"in barns"
return;
end;
/******************************************************
   Rayleigh run time sampling routine
 *******************************************************/
subroutine egs_rayleigh_sampling(medium,e,gle,lgle,costhe,sinthe);
$IMPLICIT-NONE;
$declare_max_medium;
real*8 e;
$REAL gle,costhe,sinthe,pmax,xv,xmax,csqthe;
$REAL rnnray1,rnnray0,hc_i,twice_hc2,dwi;
parameter(hc_i=80.65506856998,      "h*c inverse"
          twice_hc2=0.000307444456);"2*(hc)^2"
          "h*c=0.0123984768438 [Armstrong]*[MeV]"
$INTEGER lgle,ib,ibin,medium, trials;
;COMIN/RANDOM,rayleigh_sampling/;
dwi = $RAYCDFSIZE-1;
$EVALUATE pmax USING pmax(gle);xmax = hc_i*e;
LOOP [
    $RANDOMSET rnnray1;
    LOOP [
        $RANDOMSET rnnray0; rnnray0 = rnnray0*pmax;
        ibin = 1 + rnnray0*dwi; /* rnno = rnno + 1 - ibin; */
        ib = i_array(ibin,medium);
        IF( i_array(ibin+1,medium) > ib ) [
          LOOP [IF(rnnray0<fcum(ib+1,medium)) EXIT; ib=ib+1;]
        ]
        rnnray0 = (rnnray0 - fcum(ib,medium))*c_array(ib,medium);
        xv = xgrid(ib,medium)*exp(log(1+rnnray0)*b_array(ib,medium));
    ] UNTIL (xv < xmax);
    xv = xv/e;
    costhe = 1 - twice_hc2*xv*xv;csqthe=costhe*costhe;
] UNTIL ( 2*rnnray1 < 1 + csqthe );
sinthe=sqrt(1.0-csqthe);
return;
end;
/******************************************************
   Prepares Rayleigh run time sampling data
 *******************************************************/
subroutine prepare_rayleigh_data(ndat,x,f,
                                 ne,emin,emax,pe_array,
                                 ncbin,fcum,i_array,
                                 b_array,c_array);
$IMPLICIT-NONE;

/******* input F (form factor) data ********************************/
$INTEGER    ndat;         " number of F data points "
$REAL       x(ndat),      " x values of F data "
            f(ndat);      " F data "

/******* energy range to initialize ********************************/
$INTEGER    ne;           " number of energy bins "
$REAL       emin,         " minimum photon energy (i.e. AP(medium))"
            emax,         " maximum photon energy (i.e. UP(medium))"
            pe_array(ne); " integral over F^2 from 0 to xmax(E)    "
                          " i.e., pe_array(E) = fcum(xmax(E))      "


/******* cumulative distribution **********************************/
$INTEGER    ncbin;          " number of cumulative bins (input)"
$REAL       fcum(ndat);     " cumulative distribution (output)"
$INTEGER    i_array(ncbin); " original data bin in which the i'th "
                            " cumulative bin edge falls.          "

/******* sampling data ********************************************/
$REAL       b_array(ndat),  " F interpolation coefficient "
            c_array(ndat);  " needed for sampling at run time "

$REAL zero;

real*8 sum0,a,b,x1,x2,pow_x1,pow_x2,dle,e,xmax,
       anorm,anorm1,anorm2,w,dw,xold,t,aux;
$INTEGER i,j,k,ibin;

;COMIN/USEFUL/;

write(*,'(a$)') '      preparing data for Rayleigh sampling ... ';

/* this to avoid NAN in the log(f(i)) below */
DO i=1,ndat [IF (f(i) = 0.0) f(i) = zero();]

/**********************************************************
 *
 * Calculate the cumulative distribution
 *
 *********************************************************/
sum0=0; fcum(1)=0;
DO i=1,ndat-1 [
    b = log(f(i+1)/f(i))/log(x(i+1)/x(i)); b_array(i) = b;
    x1 = x(i); x2 = x(i+1);
    pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
    sum0=sum0+f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
    fcum(i+1) = sum0;
]

/*************************************************************
 *
 * Now the maximum cumulative probability as a function of
 * incident photon energy. We have xmax = 2*E*20.60744/m, so
 * pe_array(E) = fcum(xmax)
 *
 **************************************************************/
dle = log(emax/emin)/(ne-1); i = 1;
DO j=1,ne [
    e = emin*exp(dle*(j-1)); xmax = 20.607544d0*2*e/prm;
    DO k=i,ndat-1 [
        IF( xmax >= x(k) & xmax < x(k+1) ) EXIT;
    ]
    i = k; b = b_array(i);
    x1 = x(i); x2 = xmax;
    pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
    pe_array(j) = fcum(i) +
      f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
]
i_array(ncbin) = i;

/***********************************************************************
 *
 * Now renormalize data so that pe_array(emax)=1
 * Note that we make pe_array(j) slightly larger so that fcum(xmax) is
 * never underestimated when interpolating
 *
 ***********************************************************************/
anorm = 1d0/sqrt(pe_array(ne));
anorm1 = 1.005d0/pe_array(ne);
anorm2 = 1d0/pe_array(ne);
DO j=1,ne [
    pe_array(j) = pe_array(j)*anorm1;
    IF( pe_array(j) > 1 ) pe_array(j) = 1;
]
DO j=1,ndat [
    f(j) = f(j)*anorm; fcum(j) = fcum(j)*anorm2;
    c_array(j) = (1+b_array(j))/(x(j)*f(j))**2;
]

/***********************************************************************
 *
 * Now prepare uniform cumulative bins
 *
 ***********************************************************************/
dw = 1d0/(ncbin-1);
xold = x(1); ibin = 1;
b = b_array(1);
pow_x1 = x(1)**(2*b);
i_array(1) = 1;
DO i=2,ncbin-1 [
    w = dw;
    LOOP [
        x1 = xold; x2 = x(ibin+1);
        t = x1*x1*x1**(2*b);
        pow_x2 = x2**(2*b);
        aux=f(ibin)*f(ibin)*(x2*x2*pow_x2-t)/((1+b)*pow_x1);
        IF( aux > w ) [
            xold = exp(log(t+w*(1+b)*pow_x1/f(ibin)/f(ibin))/(2+2*b));
            i_array(i) = ibin;
            EXIT;
        ]
        w = w - aux; xold = x2; ibin = ibin+1;
        b = b_array(ibin); pow_x1 = xold**(2*b);
    ]
]

/*************************************************************************
 *
 * Change definition of b_array because that's what is needed at run time
 *
 **************************************************************************/
DO j=1,ndat [ b_array(j) = 0.5/(1 + b_array(j)); ]


write(*,'(a /)') 'done';

return; end;

"============================================================================="
$REAL function egs_KN_sigma0(e);
"=========================================================================="
implicit none;
$REAL    e;
$REAL    con,ko,c1,c2,c3,eps1,eps2;
data     con/0.1274783851/;
;COMIN/USEFUL/;
ko = e/prm;
IF( ko < 0.01 ) [
    egs_KN_sigma0 = 8.*con/3.*(1-ko*(2-ko*(5.2-13.3*ko)))/prm;
    return;
]
c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
eps2 = 1; eps1 = 1./(1+2*ko);
egs_KN_sigma0 = (c1*(1./eps1-1./eps2)+c2*log(eps2/eps1)+eps2*(c3+0.5*eps2)-
                eps1*(c3+0.5*eps1))/e*con;
return; end;

"============================================================================="
$REAL function egs_KN_sigma1(e);
"=========================================================================="
implicit none;
$REAL    e;
$REAL    con,ko,c1,c2,c3,eps1,eps2;
data     con/0.1274783851/;
;COMIN/USEFUL/;
ko = e/prm; c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
eps2 = 1; eps1 = 1./(1+2*ko);
egs_KN_sigma1 = c1*(1./eps1-1./eps2);
egs_KN_sigma1 = egs_KN_sigma1 + log(eps2/eps1)*(c2 - c1) - c2*(eps2-eps1);
egs_KN_sigma1 = egs_KN_sigma1 + c3*(eps2-eps1)*(1-0.5*(eps1+eps2));
egs_KN_sigma1 = egs_KN_sigma1 +
         (eps2-eps1)*(0.5*(eps1+eps2)-(eps1*eps1+eps2*eps2+eps1*eps2)/3);
egs_KN_sigma1 = egs_KN_sigma1*con;
return; end;

"============================================================================="
subroutine egsi_get_data(flag,iunit,n,ne,zsorted,pz_sorted,ge1,ge0,data);
"=========================================================================="
implicit none;
COMIN/EGS-IO/;
$REAL    eth;
$INTEGER flag,iunit,n,ne;
$REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
$REAL    etmp($MXINPUT),ftmp($MXINPUT);
$REAL    gle,sig,p,e;
$INTEGER i,j,k,kk,iz,iz_old,ndat,iiz;

;COMIN/USEFUL/;

"Ali:photonuc. The whole routine is commented out and re-written
"to accommodate reading photonuclear cross sections. A copy of the
"commented original routine is at the bottom.
" flag = 0: photoelectric, Rayleigh, Compton
" flag = 1: pair
" flag = 2: triplet
" flag = 3: photonuclear

rewind(iunit);
iz_old = 0;
DO k=1,n [ data(k) = 0; ]
DO i=1,ne [
    iiz = int(zsorted(i)+0.5);
    DO iz=iz_old+1,iiz [
        read(iunit,*,err=:user-data-failure:) ndat;
        IF( ndat > $MXINPUT ) [
            $egs_fatal(*,'Too many input data points. Max. is ',$MXINPUT);
        ]
        IF( flag = 0 | flag = 3) [
            read(iunit,*,err=:user-data-failure:) (etmp(k),ftmp(k),k=1,ndat);
        ]
        ELSE [
            read(iunit,*,err=:user-data-failure:) (etmp(k+1),ftmp(k+1),
                k=1,ndat);
            IF( flag = 1 ) [ eth = 2*rm; ] ELSE [ eth = 4*rm; ]
            ndat = ndat + 1;
            DO k=2,ndat [
                ftmp(k) = ftmp(k) - 3*log(1-eth/exp(etmp(k)));
            ]
            ftmp(1) = ftmp(2); etmp(1) = log(eth);
        ]
    ]
    iz_old = iiz;
    DO k=1,n [
        gle = (k - ge0)/ge1; e = exp(gle);
        IF( gle < etmp(1) | gle >= etmp(ndat) ) [
            IF( flag = 0 ) [
                $egs_fatal(*,'Energy ',exp(gle),
                   ' is outside the available data range of ',
                   exp(etmp(1)),exp(etmp(ndat)));
            ]
            ELSEIF (flag = 1 | flag = 2) [
                IF( gle < etmp(1) ) [ sig = 0; ]
                ELSE [ sig = exp(ftmp(ndat)); ]
            ]
            ELSE [ "photonuclear, zero it before and after
             sig = 0;
            ]
        ] ELSE [
            DO kk=1,ndat-1 [
                IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
            ]
            IF( flag ~= 3) ["log/log interpolation"
               p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
               sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
            ]
            ELSE["lin/lin interpolation for photonuc"
               p = (e - exp(etmp(kk)))/(exp(etmp(kk+1)) - exp(etmp(kk)));
               sig = p*exp(ftmp(kk+1)) + (1-p)*exp(ftmp(kk));
            ]
        ]
        IF( (flag = 1 | flag = 2) & e > eth ) sig = sig*(1-eth/e)**3;
        data(k) = data(k) + pz_sorted(i)*sig;
    ]
]

return;

:user-data-failure:;
$egs_fatal(*,'Error while reading user photon cross sections from unit ',
     iunit);

return; end;

/*****************************************************************
   Prepare photoelectric cross section data base for medium imed
   on same energy grid as for the other photon interactions.
   Normalize elemental PE cross sections to medium cross section
   to use for selecting element the photon interacts with.
 *****************************************************************/
"============================================================================="
subroutine egsi_get_shell_data(imed,n,ne,zsorted,pz_sorted,ge1,ge0,data);
"=========================================================================="
implicit none;
$declare_max_medium;
;COMIN/EGS-IO,BREMPR,USEFUL,MEDIA,PE-SHELL-DATA/;
$INTEGER n,   "number of data points requested"
         ne,  "number of elements in medium"
         ndat;"number of data points from original grid"
$REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
$REAL    sigma($MXNE),sigmaMedium;
"$INTEGER sorted(*);
real*4    etmp($MXINPUT),ftmp($MXINPUT);
real*4    gle,sig,p;
$INTEGER i,j,k,kk,iz,zpos,imed;

DO k=1,n  [ data(k)  = 0;]
DO k=1,ne [ sigma(k) = 0;]
DO i=1,ne [
    iz = int(zsorted(i)+0.5);
    zpos = pe_zpos(iz); ndat = pe_nge(zpos);
    "Total cross sections for a given element"
    "on initial energy grid"
    DO k=1,ndat[
       pe_elem_prob(k,i,imed) = pz_sorted(i)*pe_xsection(k,zpos,0);
       "etmp(k) = log(pe_energy(k,zpos)); Done in egs_read_shellwise_pe
       etmp(k) = pe_energy(k,zpos);
       ftmp(k) = log(pe_xsection(k,zpos,0));
    ]
    "Total cross sections for a given element"
    "on requested energy grid"
    DO k=1,n [
        gle = (k - ge0)/ge1;
        IF( gle < etmp(1) | gle >= etmp(ndat) ) [
            $egs_fatal(*,'egsi_get_shell_data: Energy ',exp(gle),
                         ' is outside the available data range of ',
                         exp(etmp(1)),exp(etmp(ndat)));
        ] ELSE [
            "Find energy interval gle falls in"
            DO kk=1,ndat-1 [
                IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
            ]
            "log/log interpolation"
            p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
            sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
        ]
        data(k) = data(k) + pz_sorted(i)*sig;
        "data(k) = data(k) + pz(imed,sorted(i))*sig;
    ]
]
"Normalize elemental cross section to medium cross section"
"Prepare for log/log interpolation"
DO i=1,ne [
   iz = int(zsorted(i)+0.5);
   zpos = pe_zpos(iz); ndat = pe_nge(zpos);
   DO k=1,ndat[
      sig = sigmaMedium(imed,pe_energy(k,zpos));
      pe_elem_prob(k,i,imed) = log(pe_elem_prob(k,i,imed)/sig);
   ]
]

return; end;

/***************************************************************
   Calculate photoelectric cross section for medium imed using
   log/log linear interpolation and binary search to find energy
   interval
 ***************************************************************/
$REAL function sigmaMedium(imed, logE);

implicit none;
$declare_max_medium;
;COMIN/BREMPR,PE-SHELL-DATA/;
$REAL logE, slope, sigma;
$INTEGER k,imed,Z,zpos,m,ibsearch;

sigmaMedium = 0;
DO k=1,nne(imed) [
   Z = int( zelem(imed,k) + 0.5 );zpos = pe_zpos(Z);
   m = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
   slope = log(pe_xsection(m+1,zpos,0)/pe_xsection(m,zpos,0));
   slope = slope/(pe_energy(m+1,zpos)-pe_energy(m,zpos));
   sigma = log(pe_xsection(m,zpos,0));
   sigma += slope*(logE - pe_energy(m,zpos));
   sigma = exp(sigma);
   sigmaMedium += pz(imed,k)*sigma;
]
return; end;

"============================================================================="
subroutine egs_heap_sort(n,rarray,jarray);
"************************************************************************
"  egs_heap_sort will sort the real array rarray of dimension n in
"  ascending order and at the same time put into the integer array
"  jarray the original position of the elements, e.g.
"  if rarray was on input (5,14,8,2), it will be after completion
"  of heap_sort (2,5,8,14) and jarray will be (4,1,3,2).
"  heap_sort uses the heap sort algorithm, the implementation is
"  based  on hpsort from Numerical Recipies with a couple of
"  modifications.
"
"  Iwan Kawrakow, NRC, July 2001
"*************************************************************************

implicit none;

$INTEGER n,jarray(*);
$REAL    rarray(*);
$INTEGER i,ir,j,l,ira;
$REAL    rra;

DO i=1,n [ jarray(i)=i; ]
IF (n < 2) return;
l=n/2+1; ir=n;

LOOP [
   IF (l > 1)  [
       l=l-1; rra=rarray(l); ira=l;
   ]
   ELSE [
       rra=rarray(ir); ira=jarray(ir);
       rarray(ir)=rarray(1); jarray(ir)=jarray(1);
       ir=ir-1;
       IF (ir = 1) [
           rarray(1)=rra; jarray(1)=ira; return;
       ]
   ]
   i=l; j=l+l;
   LOOP [
       IF( j > ir ) EXIT;
       IF (j < ir) [ IF (rarray(j) < rarray(j+1) ) j=j+1; ]
       IF (rra < rarray(j)) [
           rarray(i)=rarray(j); jarray(i)=jarray(j);
           i=j; j=j+j;
       ] ELSE [ j=ir+1; ]
   ]
   rarray(i)=rra; jarray(i)=ira;
]
return; end;

%E
"Ali:photonuc, 1 subroutine"
"******************************************************************"
SUBROUTINE PHOTONUC;
"******************************************************************"
" Placeholder for photonuclear modelling. Currently the photon is
" discarded and its energy is thrown away (i.e. not deposited).
"******************************************************************"
$IMPLICIT-NONE;
$COMIN-PHOTONUC; "current default replacement is:
                 "COMIN/STACK,EPCONT,USEFUL/"
$DEFINE-LOCAL-VARIABLES-PHOTONUC; "currently empty"

npold = np; "set the old stack counter"
edep = pzero; e(np) = pzero; wt(np) = 0;

return;
end;
"******************************************************************"

%%
