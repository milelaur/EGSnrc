      implicit none
      INTEGER MAKE_IT_AN_INT
      CHARACTER*80 TEXT
      real CPUT0,CPUT1,CPUT2,TDUM
      real egs_tot_time, egs_etime
      integer*8 ITEMP,JCASE
      integer*4 NETADJ,I,ITMAX,IB, IZ,IX,IQL,IT,NBATCH,IRL,J,LGLE,ISUMX,
     *JJ,I1,I2,I3,I4,I5, IBATCH,IBTCH,NOSCAT,ICASE,IFLDIF,NDATA, IERR
      real*8 ELEPIS( 501,4,2,2), FLEPIS(1000, 501,4,2,2), TFLUIS( 501,4,
     *3,2,2), TLEPIS( 501,4,2,2), GWATE(4),FMSIS(2),FDIS(2),FNIS(2), TIM
     *EB,TIMCPU,ETIMETOT,EKMAX,DEPTH, RLOW2,COHFAC,ECUTMN,EK0,BATCHT,RAT
     *IO,TEMP1,TEMP2,FNORM
      real*8 EI,XIN,YIN,ZIN,UIN,VIN,WIN,WEIGHT
      integer*4 IRIN,NRCFLG
      CHARACTER*1 CONTINU
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/GEOM/ZPLANE( 501),RCYL(0:4), CYRAD2(4),NTRACK( 2001),NZ,NR,
     *NREG,NPLANE
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NTRACK,NZ,NR,NREG,NPLANE
      CHARACTER*1 TITLE(80)
      COMMON/IODAT1/TITLE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET,TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
     *, IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP( 2001),IVAL,DATCOUNT
      real*8 TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
      integer*4 IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP,IVAL,DATCOUN
     *T
      integer*8 NCASE,NCASEO,NCASET
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE
      integer*4 ICHPIN,ILPIN,IOUT,IPAGE
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PHOTIN/ EBINDA(6), GE0(6),GE1(6), GMFP0(2000,6),GMFP1(2000,
     *6),GBR10(2000,6),GBR11(2000,6),GBR20(2000,6),GBR21(2000,6), RCO0(6
     *),RCO1(6), RSCT0(100,6),RSCT1(100,6), COHE0(2000,6),COHE1(2000,6),
     *  PHOTONUC0(2000,6),PHOTONUC1(2000,6), DPMFP, MPGEM(1,6), NGR(6)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/PLOTC/IPLOT( 2001),IPLOTR(4),IPLOTZ( 501), IPLTIQ(4),IPLTTP
     *(2),IPLT ,IPLTPL,IPLPHB
      integer*4 IPLOT,IPLOTR,IPLOTZ,IPLTIQ,IPLTTP,IPLT,IPLTPL,IPLPHB
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/SCORE/ SCFLU(1000, 501,4,3,2), SCFLU2(1000, 501,4,3,2), SCE
     *AVE( 501,4,3,2), SCEAVE2( 501,4,3,2), SCEAVE_COV( 501,4,3,2),SCSTP
     *,SCSTP2,PIISTP, SCELEP( 501,4,2), SCELEP2( 501,4,2), SCELEP_COV( 5
     *01,4,2), SCFLEP(1000, 501,4,2), SCFLEP2(1000, 501,4,2), SCTFLU( 50
     *1,4,3,2), SCTFLU2( 501,4,3,2), SCTLEP( 501,4,2), SCTLEP2( 501,4,2)
     *, SCSTP_LAST,SCFLU_LAST(1000, 501,4,3,2), SCFLEP_LAST(1000, 501,4,
     *2), SCTFLU_LAST( 501,4,3,2), SCTLEP_LAST( 501,4,2), IHSTRY,SCFLU_T
     *MP(1000, 501,4,3,2), SCEAVE_TMP( 501,4,3,2), SCSTP_TMP,SCELEP_TMP(
     * 501,4,2), SCFLEP_TMP(1000, 501,4,2), SCTFLU_TMP( 501,4,3,2), SCTL
     *EP_TMP( 501,4,2), BINTOP(1000),SLOTE,ECUTMX,PCUTMX,EBINW(1000,3),
     *VOLUME(500,4),MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      REAL*8 SCFLU,SCFLU2,SCEAVE,SCEAVE2,SCEAVE_COV,SCSTP,SCSTP2, SCELEP
     *,SCELEP2,SCELEP_COV,SCFLEP,SCFLEP2,SCTFLU,SCTFLU2,SCTLEP, SCTLEP2,
     *PIISTP
      integer*8 SCSTP_LAST,SCFLU_LAST,SCFLEP_LAST,SCTFLU_LAST,SCTLEP_LAS
     *T,IHSTRY
      real*8 SCFLU_TMP,SCEAVE_TMP,SCSTP_TMP,SCELEP_TMP,SCFLEP_TMP, SCTFL
     *U_TMP,SCTLEP_TMP,BINTOP,SLOTE, ECUTMX,PCUTMX,EBINW,VOLUME
      integer*4 MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(4,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBEAM
     *,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DI
     *STZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PRO
     *BSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,ZS
     *OFST,                                                      SVTMP1,
     *SVTMP2,SVTMP3,SVTMP4,
     *       RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                     XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,WEI
     *GHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/SPECTR/ CDFINV(1000,2),ENSRCD(0:500),SRCPDF(500),SRCCDF(500
     *), NENSRC
      real*8 CDFINV,ENSRCD,SRCPDF,SRCCDF
      integer*4 NENSRC
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERVR/ CEXPTR,GWAIT(150),DUMU,NP_INC(150),MAFORC,IFORCE,NF
     *MIN,NFMAX,NFTIME, ISOURC,IFPB,IQINC,MONOEN,IRODUM,IRNDUM,MEDDUM,ID
     *UM,MEDTMP, PATHL,DELTAP,GWTOLD,EPSLON,ARG
      real*8 CEXPTR,GWAIT,DUMU,PATHL,DELTAP,GWTOLD,EPSLON,ARG
      integer*4 NP_INC,MAFORC,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQIN
     *C, MONOEN,IRODUM,IRNDUM,MEDDUM,IDUM,MEDTMP
      COMMON/USERRR/
     *              CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,
     *                            EKETST,ELKETS,ZL,RL,CDIST,IGEOM,IRANGE
     *,MINZ,MAXZ,MINR,MAXR,IREJCT
      real*8 CRANGE,ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,EKETST,ELKETS
     *,ZL,RL,CDIST
      integer*4 MINZ,MAXZ,MINR,MAXR
      integer*4 IREJCT,IRANGE,IGEOM
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      COMMON/RWPHSP/ STRING_TEMP_ZLAST_OUT,  STRING_TEMP_OUT,  IHSTRY_PH
     *SP,   iaea_dummy_long,  NHSTRY_DOS,   ESHORT,  WEIGHTTMP,  WT_PHSP
     *_SHORT,  X_PHSP_SHORT,  Y_PHSP_SHORT,  Z_PHSP_SHORT,  U_PHSP_SHORT
     *,  V_PHSP_SHORT,  W_PHSP_SHORT,  ZLAST_PHSP_SHORT,  MUIDX_PHSP_SHO
     *RT,  EKMAX_PHSP_SHORT,  EKMINE_PHSP_SHORT,  NINC_PHSP_SHORT,  dosx
     *yz2beam_index,  iaea_extra_floats,  NUM_PHSP_TOT,  PHOT_PHSP_TOT,
     *iaea_result,   iaea_n_stat,  iaea_q_typ,  iaea_typ_q,  iaea_q_inde
     *x,  I_PHSP,  IERR_PHSP,  LATCHTMP,  WRITE_PHSP_COUNTER,  WRITE_PHS
     *P_SOFAR,  PHSP_RESTART,  PHSP_RECL,  PHSP_RECL_OLD,  iaea_extra_in
     *ts,  iaea_extra_int_types,iaea_extra_float_types,   iaea_i_zlast,
     * iaea_i_latch,  iaea_i_muidx,  iaea_n_extra_ints,  iaea_n_extra_fl
     *oats,  i_iaea_open_for_write,   iaea_i_zlast_out,  iaea_i_latch_ou
     *t,  iaea_i_muidx_out,  dosxyz2beam_izscore,  MODE_RW
      CHARACTER*32000 STRING_TEMP_ZLAST_OUT(1)
      CHARACTER*28000 STRING_TEMP_OUT(1)
      integer*8 IHSTRY_PHSP(1),iaea_dummy_long,NHSTRY_DOS
      REAL*4 ESHORT,WEIGHTTMP,WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT, Z
     *_PHSP_SHORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,ZLAST_PHSP_SHO
     *RT, MUIDX_PHSP_SHORT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP
     *_SHORT,dosxyz2beam_index, iaea_extra_floats(10)
      INTEGER NUM_PHSP_TOT,PHOT_PHSP_TOT, iaea_result,iaea_n_stat,iaea_q
     *_typ(3),iaea_typ_q(3),iaea_q_index,I_PHSP, IERR_PHSP,LATCHTMP, WRI
     *TE_PHSP_COUNTER(1),WRITE_PHSP_SOFAR(1), PHSP_RESTART,PHSP_RECL,PHS
     *P_RECL_OLD,iaea_extra_ints(10), iaea_extra_int_types(10),iaea_extr
     *a_float_types(10),iaea_i_zlast, iaea_i_latch,iaea_i_muidx,iaea_n_e
     *xtra_ints,iaea_n_extra_floats, i_iaea_open_for_write,iaea_i_zlast_
     *out,iaea_i_latch_out, iaea_i_muidx_out,dosxyz2beam_izscore
      CHARACTER*5 MODE_RW
      INTEGER LATCH_TEMP_OUT,NUM_PHSP_TOFLUSH,TEMP_PHSP_COUNTER,REM_PHSP
      REAL*4 REAL_TEMP_OUT(7)
      CHARACTER*32 REC_TEMP_OUT
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      REAL*8 TSCSTP,TSCSTP2,TSCFLU,TSCFLU2,TSCEAVE,TSCEAVE2,TSCEAVE_COV,
     *TSCTFLU, TSCTFLU2, TSCFLEP,TSCFLEP2,TSCELEP,TSCELEP2,TSCELEP_COV,T
     *SCTLEP, TSCTLEP2
      real*8 SCORE_NORM_NUM,SCORE_TEMP
      external combine_results
      integer*4 egs_open_file, egs_open_datfile, rng_unit, data_unit
#define HAVE_C_COMPILER
#ifdef HAVE_C_COMPILER
      real*8 part_flu, part2_flu, current_result, current_uncertainty
      integer*8 n_run,n_tot,n_last
      integer*4 n_job
      logical first_time
#endif
      logical is_finished
      call egs_init
      IVAL = 0
      CPUT0=egs_etime()
      WRITE(6,1010)500,  501,4, 1000, 6
1010  FORMAT(/' FLURZnrc, $MAXRZ=',I3,' $MAXZPLANE=',I3,' $MAXRADII=',I3
     *, ' $EBIN=',I4,'  $MXMED=',I3//)
      IF ((500 .LT. MAX(500,4))) THEN
        WRITE(6,1020)
1020    FORMAT(//'   ***ERROR***')
        WRITE(6,1030)
1030    FORMAT('The macro defining $MAXRZ must make it >=', ' MAX($MAXZR
     *EG,$MAXRADII)'/ ' It  does not do this so you must change and reco
     *mpile'//)
        STOP
      END IF
1040  CALL INPUTS
      IF((ERROR_FLAG.EQ.1))GO TO 1050
      IOUT=1
      IF ((IPRIM .EQ. 0)) THEN
        ITMAX=1
      ELSE
        ITMAX=2
      END IF
      IF ((ISTORE .GT. 0)) THEN
        rng_unit = egs_open_file(2,0,1,'.egsrns')
      ELSE IF((IRSTRT.EQ.4)) THEN
        rng_unit = egs_open_datfile(2,0,1,'.egsrns')
      END IF
      IF ((IRSTRT.EQ.5)) THEN
        call egs_combine_runs(combine_results,'.egsdat')
        NBATCH=0
        NCASET=NCASEO
      ELSE
        IF ((NCASE/10.EQ.0)) THEN
          NCASE=10
        END IF
        JCASE=NCASE/10
        NCASE=JCASE*10
      END IF
      MXNP=0
      IHSTRY=NCASEO
      NPLANE=NZ+1
      IF ((IQIN .EQ. 0)) THEN
        EI=EIN
      ELSE
        EI=EIN+RM
      END IF
      ZMINR=ZPLANE(MINZ)
      ZMAXR=ZPLANE(MAXZ)
      RMAXR=RCYL(MAXR)
      IF ((MINR .EQ. 0)) THEN
        RMINR=0.0
      ELSE
        RMINR=RCYL(MINR)
      END IF
      IF ((IREJCT .EQ. 1)) THEN
        DO 1061 IZ=1,NZ
          DO 1071 IX=1,NR
            IRL=IZ+NZ*(IX-1)+1
            IF ((IZ .LT. MINZ)) THEN
              IF ((IX.LE.MINR)) THEN
                NTRACK(IRL)=70
              ELSE IF((IX.LE.MAXR)) THEN
                NTRACK(IRL)=10
              ELSE
                NTRACK(IRL)=50
              END IF
            ELSE IF((IZ .GE.MAXZ)) THEN
              IF ((IX.LE.MINR)) THEN
                NTRACK(IRL)=80
              ELSE IF((IX.LE.MAXR)) THEN
                NTRACK(IRL)=30
              ELSE
                NTRACK(IRL)=60
              END IF
            ELSE
              IF ((IX.LE.MINR)) THEN
                NTRACK(IRL)=40
              ELSE IF((IX.LE.MAXR)) THEN
                NTRACK(IRL)=0
              ELSE
                NTRACK(IRL)=20
              END IF
            END IF
1071      CONTINUE
1072      CONTINUE
1061    CONTINUE
1062    CONTINUE
      ELSE
        DO 1081 IZ=1,NZ
          DO 1091 IX=1,NR
            IRL=IZ+NZ*(IX-1)+1
            NTRACK(IRL)=0
1091      CONTINUE
1092      CONTINUE
1081    CONTINUE
1082    CONTINUE
      END IF
      IAUSFL(1)=1
      DO 1101 J=2,35
        IAUSFL(J)=0
1101  CONTINUE
1102  CONTINUE
      IF ((IPRIM.EQ.1 .OR. IPRIM.EQ.2 .OR. IPRIM.EQ.4)) THEN
        IAUSFL(10)=1
        IAUSFL(12)=1
        IF ((IQIN .GE. 1)) THEN
          IAUSFL(14)=1
          IAUSFL(15)=1
        END IF
      END IF
      IF ((IPRIM .EQ. 2)) THEN
        IAUSFL(8)=1
        IAUSFL(14)=1
        IAUSFL(15)=1
      END IF
      IF ((IPRIM.EQ.3)) THEN
        IAUSFL(17)=1
        IAUSFL(19)=1
        IAUSFL(21)=1
        IAUSFL(25)=1
      END IF
      write(6,'(/a)') '************************ IAUSFL values **********
     ***************** '
      DO 1111 j=1,28
        IF((iausfl(j).ne.0))write(6,'(i3,$)') j
1111  CONTINUE
1112  CONTINUE
      write(6,'(/a//)') '***********************************************
     ******************* '
      DUNIT=1
      WRITE(6,1120)
1120  FORMAT(/' CALL TO HATCH AT  ',$)
      call egs_time(6)
      write(6,*)
      CALL HATCH
      WRITE(6,1130)
1130  FORMAT(/' HATCH COMPLETED AT ',$)
      call egs_time(6)
      write(6,*)
      IF ((MONOEN .EQ. 0 .AND. ISOURC.NE.21 .AND. ISOURC.NE.22 .AND. ISO
     *URC.NE.23)) THEN
        IF ((IQIN .EQ. 0)) THEN
          EI=EIN
        ELSE
          EI=EIN+RM
        END IF
        EKMAX=EIN
      ELSE IF((MONOEN .EQ. 1)) THEN
        CALL ENSRC1
        EKMAX=ENSRCD(NENSRC)
      ELSE IF((ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOURC.EQ.23)) THEN
        EKMAX=EKSRCM
      END IF
      DO 1141 I=1,NMED
        IF (((EKMAX .GT. UP(I)) .OR. (EKMAX .GT. UE(I)-RM))) THEN
          WRITE(6,1150)I,EKMAX,UP(I),UE(I)
1150      FORMAT(//1X,50('*')// ' FOR MEDIUM',I3,' INCIDENT ENERGY=',F10
     *.1,' MEV'/ ' IS GREATER THAN COVERED BY DATA FILE WHERE UP,UE=',2F
     *10.1,' MEV'// 1X,50('*')//)
          GOTO 1040
        END IF
1141  CONTINUE
1142  CONTINUE
      DO 1161 IZ=1,NZ
        DEPTH=ZPLANE(IZ+1)-ZPLANE(IZ)
        DO 1171 IX=1,NR
          IF ((ISOURC .EQ. 2 .OR. ISOURC .EQ. 4)) THEN
            VOLUME(IZ,IX)=DEPTH
          ELSE
            IF ((IX .EQ. 1)) THEN
              RLOW2=0.0
            ELSE
              RLOW2=CYRAD2(IX-1)
            END IF
            VOLUME(IZ,IX)=PI*DEPTH*(CYRAD2(IX)-RLOW2)
          END IF
1171    CONTINUE
1172    CONTINUE
1161  CONTINUE
1162  CONTINUE
      CALL SRCOTO(WEIGHT)
      IF ((IFPB .EQ. 0 .AND. IFORCE .NE. 0 .AND. IQIN .EQ. 0 .AND. MONOE
     *N .EQ. 0)) THEN
        IF (((IFPB .EQ. 0) .AND. (IFORCE .EQ. 1))) THEN
          GLE=LOG(EIN)
          DO 1181 IX=1,NR
            PATHL=0.0
            DO 1191 IZ=1,NZ
              IRL=IZ+NZ*(IX-1)+1
              MEDIUM=MED(IRL)
              IF ((MEDIUM.EQ.0)) THEN
                DELTAP=0.
              ELSE
                LGLE=GE1(MEDIUM)*GLE+GE0(MEDIUM)
                DELTAP=GMFP1(LGLE,MEDIUM)*GLE+GMFP0(LGLE,MEDIUM)
                IF ((IRAYLR(IRL) .EQ. 1)) THEN
                  COHFAC=COHE1(LGLE,MEDIUM)*GLE+COHE0(LGLE,MEDIUM)
                ELSE
                  COHFAC=1.0
                END IF
              END IF
              IF ((DELTAP.NE.0)) THEN
                DELTAP=(ZPLANE(IZ+1)-ZPLANE(IZ))/(COHFAC*DELTAP)
                PATHL=PATHL+DELTAP
              END IF
1191        CONTINUE
1192        CONTINUE
            IF ((PATHL.LE.1.0E-3)) THEN
              GWATE(IX)=PATHL*(1.-0.5*PATHL)
            ELSE
              GWATE(IX)=1.-EXP(-PATHL)
            END IF
1181      CONTINUE
1182      CONTINUE
        END IF
      END IF
      ECUTMN = 1.E10
      DO 1201 I=2,NREG
        IF ((MED(I).NE. 0)) THEN
          ECUTMN=MIN(ECUTMN,ECUT(I))
        END IF
1201  CONTINUE
1202  CONTINUE
      EK0=EIN
      ISUMX=0
      DO 1211 JJ=1,NREG
        ISUMX=ISUMX+IEDGFL(JJ)
1211  CONTINUE
1212  CONTINUE
      IF ((ISUMX .NE. 0)) THEN
        CALL EDGSET(2,NREG)
      END IF
      CALL ISUMRY
      CPUT1=egs_etime()
      tdum = egs_tot_time(1)
      ETIMETOT=0
      TIMEB=0
      NETADJ=0
      WRITE(IOUT,200)
      IF ((IRSTRT .EQ. 0)) THEN
        WRITE(6,201)
        WRITE(IOUT,201)
      ELSE IF((IRSTRT .EQ. 1)) THEN
        WRITE(6,202) NCASE,NCASEO
        write(6,'(21x,a,$)') 'New RNG state: '
        write(6,'(a,2i4,$)') ' ixx jxx = ',ixx,jxx
        write(6,*)
        WRITE(IOUT,202) NCASE,NCASEO
        write(iout,'(21x,a,$)') 'New RNG state: '
        write(iout,'(a,2i4,$)') ' ixx jxx = ',ixx,jxx
        write(iout,*)
      ELSE IF((IRSTRT .EQ. 3)) THEN
        WRITE(6,204)
        WRITE(IOUT,204)
        GO TO 1220
      ELSE IF((IRSTRT .EQ. 4)) THEN
        WRITE(6,206)
        WRITE(IOUT,206)
      ELSE IF((IRSTRT .EQ. 5)) THEN
        WRITE(6,205)
        WRITE(IOUT,205)
        GO TO 1220
      END IF
      IF((idat .EQ. 0))data_unit = egs_open_file(4,0,1,'.egsdat')
      IF((IWATCH .NE. 0))CALL WATCH(-99,IWATCH)
      DO 1231 I1=1,150
        NP_INC(I1)=0
1231  CONTINUE
1232  CONTINUE
#ifdef HAVE_C_COMPILER
      n_tot = ncaseo
      first_time = .true.
      is_finished = .false.
      part_flu=0
      part2_flu=0
1240  CONTINUE
      IF (( n_parallel .GT. 0 )) THEN
        call egs_pjob_control(ncase,n_run,n_left,n_tot,part_flu,part2_fl
     *  u, current_result, current_uncertainty)
        IF (( n_run .EQ. 0 )) THEN
          write(6,'(//a,a//)') '****** No histories left in job control
     *file', '       => end simulation'
          goto 1220
        END IF
        jcase = n_run/10
        IF (( jcase .LT. 1 )) THEN
          jcase = 1
          n_run = jcase*10
        END IF
        IF (( first_time )) THEN
          first_time = .false.
          n_last = n_run
          write(6,'(//a,i12,a//)') '****** Running ',n_run,' histories'
        ELSE
          write(6,'(//a,i12,a)') '***** Finished ',n_last,' histories'
          write(6,'(/a/,20x,1pe11.4,a,0pf5.2,a/,a,i12,a//)') '      curr
     *ent result including previous runs and other parallel jobs: ', cur
     *    rent_result, ' +/- ',current_uncertainty,' %', '      will run
     * another ',n_run,' histories'
        END IF
      END IF
#endif
      DO 1251 IBATCH=1,10
        IBTCH=IBATCH
        IF ((IBATCH .EQ. 1)) THEN
          WRITE(6,1260)
1260      FORMAT(' BATCH #',2X,'TIME-ELAPSED',2X,'TOTAL CPUTIME',2X,'RAT
     *IO',2X,' RNG STATE')
          WRITE(6,1270)
1270      FORMAT(' ',4X,'1',11X,'0.0',10X,'0.0',6X,'0.00',2X,$)
          write(6,'(i4,2i3,i2)') ixx,jxx
          call flush(6)
        ELSE
          CPUT2=egs_etime()
          TIMEB = egs_tot_time(0)
          ETIMETOT=ETIMETOT+TIMEB
          CPUT2=egs_etime()
          TIMCPU=CPUT2-CPUT1
          WRITE(6,1280)IBATCH,ETIMETOT,TIMCPU,ETIMETOT/TIMCPU
1280      FORMAT(' ',3X,I2,3X,F11.1,2X,F11.1,2X,F8.2,2X,$)
          write(6,'(i4,2i3,i2)') ixx,jxx
          call flush(6)
          BATCHT=TIMCPU/dble(IBATCH-1)
          IF ((TIMCPU+1.1*BATCHT .GT. TIMMAX*3600.)) THEN
            WRITE(IOUT,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY
            WRITE(6,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY
            GO TO 1220
          END IF
        END IF
        DO 1291 ICASE=1,JCASE
          IF((ISOURC .NE. 23))IHSTRY=IHSTRY+1
          NFTIME=0
          IF ((IRSTRT.EQ.4)) THEN
            read(rng_unit,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_s
     *      eed, rng_array
            twom24 = 1./16777216.
          END IF
          IF ((ISTORE .EQ. 1)) THEN
            rewind(rng_unit)
            write(rng_unit,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_
     *      seed, rng_array
          ELSE IF((ISTORE.EQ.2)) THEN
            write(rng_unit,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_
     *      seed, rng_array
          END IF
          CALL SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
          IF ((MONOEN .NE. 0 .AND. ISOURC .NE. 21 .AND. ISOURC.NE.22 .AN
     *    D. ISOURC.NE.23)) THEN
            CALL ENSRCH(EIN)
            IF ((IQIN .EQ. 0)) THEN
              EI=EIN
            ELSE
              EI=EIN+RM
            END IF
          ELSE IF((ISOURC .EQ. 21.OR.ISOURC .EQ. 22.OR.ISOURC .EQ. 23))
     *    THEN
            EI=EIN
          END IF
          IF ((IFORCE .EQ. 1 .AND. IFPB .EQ. 0 .AND. MONOEN .EQ. 0 .AND.
     *     IQIN .EQ. 0)) THEN
            MAFORC=1
            GWAIT(1)=GWATE((IRIN-2)/NZ+1)
            WEIGHT=GWAIT(1)
          ELSE
            MAFORC=0
          END IF
          LATCHI =0
          IF (((IWATCH .NE. 0) .AND. (IWATCH .NE. 4))) THEN
            WRITE(6,1300)1,EIN,IQIN,IRIN,XIN,YIN,ZIN,UIN,VIN,WIN,LATCHI,
     *      WEIGHT
1300        FORMAT(' INITIAL SHOWER VALUES',T36,':',I3,F9.3,2I4,3F8.3, 3
     *F7.3,I10,1PE10.3)
          END IF
          CALL SHOWER(IQIN,EI,XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT)
          IF((IWATCH .GT. 0))CALL WATCH(-1,IWATCH)
1291    CONTINUE
1292    CONTINUE
        IF ((IDAT .EQ. 0)) THEN
          rewind(data_unit)
          TSCSTP=SCSTP+SCSTP_TMP
          TSCSTP2=SCSTP2+SCSTP_TMP*SCSTP_TMP
          WRITE(data_unit,*) TSCSTP,TSCSTP2
          DO 1311 IX=1,NR
            DO 1321 IZ=1,NZ
              DO 1331 IT=1,ITMAX
                DO 1341 IQL=1,3
                  DO 1351 IB=1,MAXIB
                    TSCFLU=SCFLU(IB,IZ,IX,IQL,IT)+ SCFLU_TMP(IB,IZ,IX,IQ
     *              L,IT)
                    TSCFLU2=SCFLU2(IB,IZ,IX,IQL,IT)+ SCFLU_TMP(IB,IZ,IX,
     *              IQL,IT)* SCFLU_TMP(IB,IZ,IX,IQL,IT)
                    WRITE(data_unit,*)TSCFLU,TSCFLU2
1351              CONTINUE
1352              CONTINUE
                  TSCEAVE=SCEAVE(IZ,IX,IQL,IT)+ SCEAVE_TMP(IZ,IX,IQL,IT)
                  TSCEAVE2=SCEAVE2(IZ,IX,IQL,IT)+ SCEAVE_TMP(IZ,IX,IQL,I
     *            T)* SCEAVE_TMP(IZ,IX,IQL,IT)
                  TSCEAVE_COV=SCEAVE_COV(IZ,IX,IQL,IT)+ SCEAVE_TMP(IZ,IX
     *            ,IQL,IT)*SCTFLU_TMP(IZ,IX,IQL,IT)
                  TSCTFLU=SCTFLU(IZ,IX,IQL,IT)+ SCTFLU_TMP(IZ,IX,IQL,IT)
                  TSCTFLU2=SCTFLU2(IZ,IX,IQL,IT)+ SCTFLU_TMP(IZ,IX,IQL,I
     *            T)* SCTFLU_TMP(IZ,IX,IQL,IT)
                  WRITE(data_unit,*)TSCEAVE,TSCEAVE2,TSCEAVE_COV,TSCTFLU
     *            ,TSCTFLU2
1341            CONTINUE
1342            CONTINUE
                DO 1361 IB=1,MAXIB
                  TSCFLEP=SCFLEP(IB,IZ,IX,IT)+ SCFLEP_TMP(IB,IZ,IX,IT)
                  TSCFLEP2=SCFLEP2(IB,IZ,IX,IT)+ SCFLEP_TMP(IB,IZ,IX,IT)
     *            * SCFLEP_TMP(IB,IZ,IX,IT)
                  WRITE(data_unit,*)TSCFLEP,TSCFLEP2
1361            CONTINUE
1362            CONTINUE
                TSCELEP=SCELEP(IZ,IX,IT)+SCELEP_TMP(IZ,IX,IT)
                TSCELEP2=SCELEP2(IZ,IX,IT)+SCELEP_TMP(IZ,IX,IT)* SCELEP_
     *          TMP(IZ,IX,IT)
                TSCELEP_COV=SCELEP_COV(IZ,IX,IT)+SCELEP_TMP(IZ,IX,IT)* S
     *          CTLEP_TMP(IZ,IX,IT)
                TSCTLEP=SCTLEP(IZ,IX,IT)+SCTLEP_TMP(IZ,IX,IT)
                TSCTLEP2=SCTLEP2(IZ,IX,IT)+SCTLEP_TMP(IZ,IX,IT)* SCTLEP_
     *          TMP(IZ,IX,IT)
                WRITE(data_unit,*)TSCELEP,TSCELEP2,TSCELEP_COV,TSCTLEP,T
     *          SCTLEP2
1331          CONTINUE
1332          CONTINUE
1321        CONTINUE
1322        CONTINUE
1311      CONTINUE
1312      CONTINUE
        END IF
        CPUT2=egs_etime()
        TIMCPU=CPUT2-CPUT1+TMCPUO
        IF ((IDAT .EQ. 0)) THEN
          write(data_unit,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_s
     *    eed, rng_array
          WRITE(data_unit,*) IHSTRY,TIMCPU,NNREAD,PIISTP+count_pII_steps
        END IF
1251  CONTINUE
1252  CONTINUE
#ifdef HAVE_C_COMPILER
      IF (( n_parallel .GT. 0 )) THEN
        goto 1240
      END IF
#endif
1220  CONTINUE
      SCSTP=SCSTP+SCSTP_TMP
      SCSTP2=SCSTP2+SCSTP_TMP*SCSTP_TMP
      DO 1371 IX=1,NR
        DO 1381 IZ=1,NZ
          DO 1391 IT=1,ITMAX
            DO 1401 IQL=1,3
              DO 1411 IB=1,MAXIB
                SCFLU(IB,IZ,IX,IQL,IT)=SCFLU(IB,IZ,IX,IQL,IT)+ SCFLU_TMP
     *          (IB,IZ,IX,IQL,IT)
                SCFLU2(IB,IZ,IX,IQL,IT)=SCFLU2(IB,IZ,IX,IQL,IT)+ SCFLU_T
     *          MP(IB,IZ,IX,IQL,IT)* SCFLU_TMP(IB,IZ,IX,IQL,IT)
1411          CONTINUE
1412          CONTINUE
              SCEAVE(IZ,IX,IQL,IT)=SCEAVE(IZ,IX,IQL,IT)+ SCEAVE_TMP(IZ,I
     *        X,IQL,IT)
              SCEAVE2(IZ,IX,IQL,IT)=SCEAVE2(IZ,IX,IQL,IT)+ SCEAVE_TMP(IZ
     *        ,IX,IQL,IT)* SCEAVE_TMP(IZ,IX,IQL,IT)
              SCEAVE_COV(IZ,IX,IQL,IT)=SCEAVE_COV(IZ,IX,IQL,IT)+ SCEAVE_
     *        TMP(IZ,IX,IQL,IT)* SCTFLU_TMP(IZ,IX,IQL,IT)
              SCTFLU(IZ,IX,IQL,IT)=SCTFLU(IZ,IX,IQL,IT)+ SCTFLU_TMP(IZ,I
     *        X,IQL,IT)
              SCTFLU2(IZ,IX,IQL,IT)=SCTFLU2(IZ,IX,IQL,IT)+ SCTFLU_TMP(IZ
     *        ,IX,IQL,IT)* SCTFLU_TMP(IZ,IX,IQL,IT)
1401        CONTINUE
1402        CONTINUE
            DO 1421 IB=1,MAXIB
              SCFLEP(IB,IZ,IX,IT)=SCFLEP(IB,IZ,IX,IT)+ SCFLEP_TMP(IB,IZ,
     *        IX,IT)
              SCFLEP2(IB,IZ,IX,IT)=SCFLEP2(IB,IZ,IX,IT)+ SCFLEP_TMP(IB,I
     *        Z,IX,IT)* SCFLEP_TMP(IB,IZ,IX,IT)
1421        CONTINUE
1422        CONTINUE
            SCELEP(IZ,IX,IT)=SCELEP(IZ,IX,IT)+SCELEP_TMP(IZ,IX,IT)
            SCELEP2(IZ,IX,IT)=SCELEP2(IZ,IX,IT)+SCELEP_TMP(IZ,IX,IT)* SC
     *      ELEP_TMP(IZ,IX,IT)
            SCELEP_COV(IZ,IX,IT)=SCELEP_COV(IZ,IX,IT)+SCELEP_TMP(IZ,IX,I
     *      T)* SCTLEP_TMP(IZ,IX,IT)
            SCTLEP(IZ,IX,IT)=SCTLEP(IZ,IX,IT)+SCTLEP_TMP(IZ,IX,IT)
            SCTLEP2(IZ,IX,IT)=SCTLEP2(IZ,IX,IT)+SCTLEP_TMP(IZ,IX,IT)* SC
     *      TLEP_TMP(IZ,IX,IT)
1391      CONTINUE
1392      CONTINUE
1381    CONTINUE
1382    CONTINUE
1371  CONTINUE
1372  CONTINUE
      write(6,'(/a,$)') '********* FINAL RANDOM NUMBER STATE:'
      write(6,'(a,2i4,$)') ' ixx jxx = ',ixx,jxx
      write(6,'(a)') '  *********'
      write(iout,'(/a,$)') '********* FINAL RANDOM NUMBER STATE:'
      write(iout,'(a,2i4,$)') ' ixx jxx = ',ixx,jxx
      write(iout,'(a)') '  *********'
      TIMEB = egs_tot_time(0)
      ETIMETOT=ETIMETOT+TIMEB
      CPUT2=egs_etime()
      TIMCPU=CPUT2-CPUT1+TMCPUO
      RATIO=ETIMETOT/TIMCPU
      IF ((IRSTRT.EQ.3)) THEN
        WRITE(IOUT,255)TMCPUO,TMCPUO/3600
        WRITE(6,255)TMCPUO,TMCPUO/3600
        WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO
        WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO
      ELSE IF((IRSTRT.EQ.5)) THEN
        WRITE(IOUT,256)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT
     *  )
        WRITE(6,256)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT)
        WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO
        WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO
      ELSE
        IF ((RATIO .NE. 0.0)) THEN
          WRITE(IOUT,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO
          WRITE(6,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO
        ELSE
          WRITE(IOUT,270) TIMCPU,TIMCPU/3600.
          WRITE(6,270) TIMCPU,TIMCPU/3600.
        END IF
        IF ((IHSTRY .NE. 0 .AND. TIMCPU .NE. 0.0)) THEN
          WRITE(IOUT,280)TIMCPU/dble(IHSTRY),3600.*dble(IHSTRY)/TIMCPU
          WRITE(6,280)TIMCPU/dble(IHSTRY),3600.*dble(IHSTRY)/TIMCPU
        END IF
      END IF
1430  CONTINUE
      IF ((ISOURC.EQ.21.OR.ISOURC.EQ.22)) THEN
        AINFLU=dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*NINC
     *  SRC
        SCORE_NORM_NUM=AINFLU
      ELSE IF((ISOURC.EQ.23)) THEN
        AINFLU=dble(IHSTRY)
        SCORE_NORM_NUM=AINFLU
      ELSE
        SCORE_NORM_NUM=dble(IHSTRY)
        AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET)
      END IF
      IF ((ISOURC .EQ. 4 .AND. NR .GT. 1)) THEN
        DO 1441 IX=2,NR
          DO 1451 IZ=1,NZ
            DO 1461 IT=1,ITMAX
              DO 1471 IQL=1,3
                DO 1481 IB=1,MAXIB
                  SCFLU(IB,IZ,IX,IQL,IT)=SCFLU(IB,IZ,IX,IQL,IT)+ SCFLU(I
     *            B,IZ,IX-1,IQL,IT)
                  SCFLU2(IB,IZ,IX,IQL,IT)=SCFLU2(IB,IZ,IX,IQL,IT)+ SCFLU
     *            2(IB,IZ,IX-1,IQL,IT)
1481            CONTINUE
1482            CONTINUE
                SCEAVE(IZ,IX,IQL,IT)=SCEAVE(IZ,IX,IQL,IT)+ SCEAVE(IZ,IX-
     *          1,IQL,IT)
                SCEAVE2(IZ,IX,IQL,IT)=SCEAVE2(IZ,IX,IQL,IT)+ SCEAVE2(IZ,
     *          IX-1,IQL,IT)
                SCEAVE_COV(IZ,IX,IQL,IT)=SCEAVE_COV(IZ,IX,IQL,IT)+ SCEAV
     *          E_COV(IZ,IX-1,IQL,IT)
                SCTFLU(IZ,IX,IQL,IT)=SCTFLU(IZ,IX,IQL,IT)+ SCTFLU(IZ,IX-
     *          1,IQL,IT)
                SCTFLU2(IZ,IX,IQL,IT)=SCTFLU2(IZ,IX,IQL,IT)+ SCTFLU2(IZ,
     *          IX-1,IQL,IT)
1471          CONTINUE
1472          CONTINUE
              DO 1491 IB=1,MAXIB
                SCFLEP(IB,IZ,IX,IT)=SCFLEP(IB,IZ,IX,IT)+ SCFLEP(IB,IZ,IX
     *          -1,IT)
                SCFLEP2(IB,IZ,IX,IT)=SCFLEP2(IB,IZ,IX,IT)+ SCFLEP2(IB,IZ
     *          ,IX-1,IT)
1491          CONTINUE
1492          CONTINUE
              SCELEP(IZ,IX,IT)=SCELEP(IZ,IX,IT)+SCELEP(IZ,IX-1,IT)
              SCELEP2(IZ,IX,IT)=SCELEP2(IZ,IX,IT)+SCELEP2(IZ,IX-1,IT)
              SCELEP_COV(IZ,IX,IT)=SCELEP_COV(IZ,IX,IT)+ SCELEP_COV(IZ,I
     *        X-1,IT)
              SCTLEP(IZ,IX,IT)=SCTLEP(IZ,IX,IT)+SCTLEP(IZ,IX-1,IT)
              SCTLEP2(IZ,IX,IT)=SCTLEP2(IZ,IX,IT)+SCTLEP2(IZ,IX-1,IT)
1461        CONTINUE
1462        CONTINUE
1451      CONTINUE
1452      CONTINUE
1441    CONTINUE
1442    CONTINUE
      END IF
      ECUTMX=0.0
      PCUTMX = 0.0
      IFLDIF = 0
      DO 1501 I=1,NREG
        IF ((ECUT(I) .NE. 0.0 .AND. ECUT(I) .NE. ECUTMX .AND. ECUTMX .NE
     *  .0.0)) THEN
          IFLDIF=1
        END IF
        ECUTMX = MAX (ECUT(I),ECUTMX)
        PCUTMX = MAX (PCUT(I),PCUTMX)
1501  CONTINUE
1502  CONTINUE
      IF ((IFLDIF .EQ. 1)) THEN
        WRITE(6,1510)
1510    FORMAT(/' *** NORMALIZATION PROBLEMS IN FIRST BIN(/MeV)', ' SINC
     *E DIFFERENT ECUTS USED - HAVE USED MAXIMUM EVERYWHERE**'/)
        WRITE(IOUT,500)ECUTMX
      END IF
      IF ((SLOTE .GT. 0.0)) THEN
        EBINW(1,1)=SLOTE - (ECUTMX-PRM)
        EBINW(1,3)=SLOTE - (ECUTMX-PRM)
        IF ((EBINW(1,1) .LE. 0.0)) THEN
          EBINW(1,1)=1.E10
          EBINW(1,3)=1.E10
        END IF
        EBINW(1,2) = SLOTE - PCUTMX
        IF ((EBINW(1,2) .LE. 0.0)) THEN
          EBINW(1,2)=1.E10
        END IF
        DO 1521 IB=2,MAXIB
          EBINW(IB,1)=SLOTE
          EBINW(IB,2)=SLOTE
          EBINW(IB,3)=SLOTE
1521    CONTINUE
1522    CONTINUE
      ELSE
        EBINW(1,1)=BINTOP(1) - (ECUTMX-PRM)
        EBINW(1,3)=BINTOP(1) - (ECUTMX-PRM)
        EBINW(1,2) = BINTOP(1) - PCUTMX
        DO 1531 IB=2,MAXIB
          DO 1541 IQL=1,3
            EBINW(IB,IQL) = BINTOP(IB)-BINTOP(IB-1)
            IF ((EBINW(IB,IQL) .LE. 0.0)) THEN
              EBINW(IB,IQL)=1.E10
            END IF
1541      CONTINUE
1542      CONTINUE
1531    CONTINUE
1532    CONTINUE
      END IF
      SCORE_TEMP=SCSTP/SCORE_NORM_NUM
      SCSTP2=SCSTP2/SCORE_NORM_NUM
      SCSTP2=(SCSTP2-SCORE_TEMP*SCORE_TEMP)/(SCORE_NORM_NUM-1)
      IF((SCSTP2.GE.0.))SCSTP2= SQRT(SCSTP2)
      IF ((SCORE_TEMP.NE.0.)) THEN
        SCSTP2=100*SCSTP2/SCORE_TEMP
        IF (( SCSTP2 .GT. 99.9 )) THEN
          SCSTP2 = 99.9
        END IF
      ELSE
        SCSTP2=99.9
      END IF
      DO 1551 IX=1,NR
        DO 1561 IZ=1,NZ
          DO 1571 IT=1,ITMAX
            DO 1581 IQL=1,3
              DO 1591 IB=1,MAXIB
                SCORE_TEMP=SCFLU(IB,IZ,IX,IQL,IT)/SCORE_NORM_NUM
                SCFLU2(IB,IZ,IX,IQL,IT)=SCFLU2(IB,IZ,IX,IQL,IT)/SCORE_NO
     *          RM_NUM
                SCFLU2(IB,IZ,IX,IQL,IT)=(SCFLU2(IB,IZ,IX,IQL,IT)-SCORE_T
     *          EMP*SCORE_TEMP)/(SCORE_NORM_NUM-1)
                IF((SCFLU2(IB,IZ,IX,IQL,IT).GE.0.))SCFLU2(IB,IZ,IX,IQL,I
     *          T)= SQRT(SCFLU2(IB,IZ,IX,IQL,IT))
                IF ((SCORE_TEMP.NE.0.)) THEN
                  SCFLU2(IB,IZ,IX,IQL,IT)=100*SCFLU2(IB,IZ,IX,IQL,IT)/SC
     *            ORE_TEMP
                  IF (( SCFLU2(IB,IZ,IX,IQL,IT) .GT. 99.9 )) THEN
                    SCFLU2(IB,IZ,IX,IQL,IT) = 99.9
                  END IF
                ELSE
                  SCFLU2(IB,IZ,IX,IQL,IT)=99.9
                END IF
                SCFLU(IB,IZ,IX,IQL,IT)=SCFLU(IB,IZ,IX,IQL,IT)/ (AINFLU*V
     *          OLUME(IZ,IX)*EBINW(IB,IQL))
1591          CONTINUE
1592          CONTINUE
              SCORE_TEMP=SCTFLU(IZ,IX,IQL,IT)/SCORE_NORM_NUM
              SCTFLU2(IZ,IX,IQL,IT)=SCTFLU2(IZ,IX,IQL,IT)/SCORE_NORM_NUM
              SCTFLU2(IZ,IX,IQL,IT)=(SCTFLU2(IZ,IX,IQL,IT)-SCORE_TEMP*SC
     *        ORE_TEMP)/(SCORE_NORM_NUM-1)
              IF((SCTFLU2(IZ,IX,IQL,IT).GE.0.))SCTFLU2(IZ,IX,IQL,IT)= SQ
     *        RT(SCTFLU2(IZ,IX,IQL,IT))
              IF ((SCORE_TEMP.NE.0.)) THEN
                SCTFLU2(IZ,IX,IQL,IT)=100*SCTFLU2(IZ,IX,IQL,IT)/SCORE_TE
     *          MP
                IF (( SCTFLU2(IZ,IX,IQL,IT) .GT. 99.9 )) THEN
                  SCTFLU2(IZ,IX,IQL,IT) = 99.9
                END IF
              ELSE
                SCTFLU2(IZ,IX,IQL,IT)=99.9
              END IF
              SCORE_TEMP=SCEAVE(IZ,IX,IQL,IT)/SCORE_NORM_NUM
              SCEAVE2(IZ,IX,IQL,IT)=SCEAVE2(IZ,IX,IQL,IT)/SCORE_NORM_NUM
              SCEAVE2(IZ,IX,IQL,IT)=(SCEAVE2(IZ,IX,IQL,IT)-SCORE_TEMP*SC
     *        ORE_TEMP)/(SCORE_NORM_NUM-1)
              IF((SCEAVE2(IZ,IX,IQL,IT).GE.0.))SCEAVE2(IZ,IX,IQL,IT)= SQ
     *        RT(SCEAVE2(IZ,IX,IQL,IT))
              IF ((SCORE_TEMP.NE.0.)) THEN
                SCEAVE2(IZ,IX,IQL,IT)=100*SCEAVE2(IZ,IX,IQL,IT)/SCORE_TE
     *          MP
                IF (( SCEAVE2(IZ,IX,IQL,IT) .GT. 99.9 )) THEN
                  SCEAVE2(IZ,IX,IQL,IT) = 99.9
                END IF
              ELSE
                SCEAVE2(IZ,IX,IQL,IT)=99.9
              END IF
              SCEAVE_COV(IZ,IX,IQL,IT)=SCEAVE_COV(IZ,IX,IQL,IT)/SCORE_NO
     *        RM_NUM- SCTFLU(IZ,IX,IQL,IT)*SCEAVE(IZ,IX,IQL,IT)/ (SCORE_
     *        NORM_NUM**2)
              SCEAVE_COV(IZ,IX,IQL,IT)=SCEAVE_COV(IZ,IX,IQL,IT)/ (SCTFLU
     *        (IZ,IX,IQL,IT)*SCEAVE(IZ,IX,IQL,IT)/ (SCORE_NORM_NUM**2)*(
     *        SCORE_NORM_NUM-1))
              SCEAVE2(IZ,IX,IQL,IT)=(SCEAVE2(IZ,IX,IQL,IT)/100.)**2+ (SC
     *        TFLU2(IZ,IX,IQL,IT)/100.)**2- 2*SCEAVE_COV(IZ,IX,IQL,IT)
              IF((SCEAVE2(IZ,IX,IQL,IT).GT.0.))SCEAVE2(IZ,IX,IQL,IT)= SQ
     *        RT(SCEAVE2(IZ,IX,IQL,IT))*100
              IF((SCEAVE2(IZ,IX,IQL,IT).GT.99.9))SCEAVE2(IZ,IX,IQL,IT)=9
     *        9.9
              IF ((SCTFLU(IZ,IX,IQL,IT).NE.0.)) THEN
                SCEAVE(IZ,IX,IQL,IT)=SCEAVE(IZ,IX,IQL,IT)/ SCTFLU(IZ,IX,
     *          IQL,IT)
              END IF
              SCTFLU(IZ,IX,IQL,IT)=SCTFLU(IZ,IX,IQL,IT)/(AINFLU*VOLUME(I
     *        Z,IX))
1581        CONTINUE
1582        CONTINUE
            DO 1601 IB=1,MAXIB
              SCORE_TEMP=SCFLEP(IB,IZ,IX,IT)/SCORE_NORM_NUM
              SCFLEP2(IB,IZ,IX,IT)=SCFLEP2(IB,IZ,IX,IT)/SCORE_NORM_NUM
              SCFLEP2(IB,IZ,IX,IT)=(SCFLEP2(IB,IZ,IX,IT)-SCORE_TEMP*SCOR
     *        E_TEMP)/(SCORE_NORM_NUM-1)
              IF((SCFLEP2(IB,IZ,IX,IT).GE.0.))SCFLEP2(IB,IZ,IX,IT)= SQRT
     *        (SCFLEP2(IB,IZ,IX,IT))
              IF ((SCORE_TEMP.NE.0.)) THEN
                SCFLEP2(IB,IZ,IX,IT)=100*SCFLEP2(IB,IZ,IX,IT)/SCORE_TEMP
                IF (( SCFLEP2(IB,IZ,IX,IT) .GT. 99.9 )) THEN
                  SCFLEP2(IB,IZ,IX,IT) = 99.9
                END IF
              ELSE
                SCFLEP2(IB,IZ,IX,IT)=99.9
              END IF
              SCFLEP(IB,IZ,IX,IT)=SCFLEP(IB,IZ,IX,IT)/ (AINFLU*VOLUME(IZ
     *        ,IX)*EBINW(IB,1))
1601        CONTINUE
1602        CONTINUE
            SCORE_TEMP=SCELEP(IZ,IX,IT)/SCORE_NORM_NUM
            SCELEP2(IZ,IX,IT)=SCELEP2(IZ,IX,IT)/SCORE_NORM_NUM
            SCELEP2(IZ,IX,IT)=(SCELEP2(IZ,IX,IT)-SCORE_TEMP*SCORE_TEMP)/
     *      (SCORE_NORM_NUM-1)
            IF((SCELEP2(IZ,IX,IT).GE.0.))SCELEP2(IZ,IX,IT)= SQRT(SCELEP2
     *      (IZ,IX,IT))
            IF ((SCORE_TEMP.NE.0.)) THEN
              SCELEP2(IZ,IX,IT)=100*SCELEP2(IZ,IX,IT)/SCORE_TEMP
              IF (( SCELEP2(IZ,IX,IT) .GT. 99.9 )) THEN
                SCELEP2(IZ,IX,IT) = 99.9
              END IF
            ELSE
              SCELEP2(IZ,IX,IT)=99.9
            END IF
            SCORE_TEMP=SCTLEP(IZ,IX,IT)/SCORE_NORM_NUM
            SCTLEP2(IZ,IX,IT)=SCTLEP2(IZ,IX,IT)/SCORE_NORM_NUM
            SCTLEP2(IZ,IX,IT)=(SCTLEP2(IZ,IX,IT)-SCORE_TEMP*SCORE_TEMP)/
     *      (SCORE_NORM_NUM-1)
            IF((SCTLEP2(IZ,IX,IT).GE.0.))SCTLEP2(IZ,IX,IT)= SQRT(SCTLEP2
     *      (IZ,IX,IT))
            IF ((SCORE_TEMP.NE.0.)) THEN
              SCTLEP2(IZ,IX,IT)=100*SCTLEP2(IZ,IX,IT)/SCORE_TEMP
              IF (( SCTLEP2(IZ,IX,IT) .GT. 99.9 )) THEN
                SCTLEP2(IZ,IX,IT) = 99.9
              END IF
            ELSE
              SCTLEP2(IZ,IX,IT)=99.9
            END IF
            SCELEP_COV(IZ,IX,IT)=SCELEP_COV(IZ,IX,IT)/SCORE_NORM_NUM- SC
     *      ELEP(IZ,IX,IT)*SCTLEP(IZ,IX,IT)/ (SCORE_NORM_NUM**2)
            SCELEP_COV(IZ,IX,IT)=SCELEP_COV(IZ,IX,IT)/ (SCELEP(IZ,IX,IT)
     *      *SCTLEP(IZ,IX,IT)/ (SCORE_NORM_NUM**2)*(SCORE_NORM_NUM-1))
            SCELEP2(IZ,IX,IT)=(SCELEP2(IZ,IX,IT)/100.)**2+ (SCTLEP2(IZ,I
     *      X,IT)/100.)**2- 2*SCELEP_COV(IZ,IX,IT)
            IF((SCELEP2(IZ,IX,IT).GT.0.))SCELEP2(IZ,IX,IT)=SQRT(SCELEP2(
     *      IZ,IX,IT))*100
            IF((SCELEP2(IZ,IX,IT).GT.99.9))SCELEP2(IZ,IX,IT)=99.9
            IF ((SCTLEP(IZ,IX,IT).NE.0.)) THEN
              SCELEP(IZ,IX,IT)=SCELEP(IZ,IX,IT)/SCTLEP(IZ,IX,IT)
            END IF
            SCTLEP(IZ,IX,IT)=SCTLEP(IZ,IX,IT)/(AINFLU*VOLUME(IZ,IX))
1571      CONTINUE
1572      CONTINUE
1561    CONTINUE
1562    CONTINUE
1551  CONTINUE
1552  CONTINUE
      CALL OSUMRY
1610  CONTINUE
1050  CONTINUE
      WRITE(6,1620)
1620  FORMAT(/' END OF RUN',9X,' ',$)
      call egs_fdate(6)
      write(6,'(//)')
      IF ((ERROR_FLAG.EQ.1)) THEN
        WRITE(6,1630)
1630    FORMAT(//' **********  ERRORS AND WARNING MESSAGES  ********** '
     *//)
      END IF
      rewind (i_errors)
9998  CONTINUE
      READ (i_errors,END=9999, FMT='(A80)') TEXT
      WRITE (*,'(A79)') TEXT
      GOTO 9998
9999  CONTINUE
      backspace(i_errors)
      write(i_errors,400)
      call egs_fdate(i_errors)
      write(i_errors,*)
      write(iout,400)
      call egs_fdate(iout)
      write(iout,*)
      call egs_finish
#ifdef HAVE_C_COMPILER
      IF (( n_parallel .GT. 0 .AND. .NOT.is_finished )) THEN
        call egs_pjob_finish(n_job)
        IF (( n_job .EQ. 0 )) THEN
          is_finished = .true.
          call egs_combine_runs(combine_results,'.egsdat')
          NCASET=NCASEO
          IHSTRY=NCASET
          CALL SRCOTO(WEIGHT)
          goto 1430
        END IF
      END IF
#endif
      call SRCEND
      call exit(0)
200   FORMAT(' ',79('*')// T20,'EXECUTION INFORMATION AND WARNING MESSAG
     *ES'// 1x,79('*')//' Using FLURZnrc(EGSnrc) ',' ',' ')
201   FORMAT(/' ********* NEW INPUT FILE *********'/)
202   FORMAT(/' ********* RESTARTED INPUT FILE ********* '/' ',10X,I12,'
     * NEW + ',I12,' OLD HISTORIES'/' ',20X,'NEW RN SEEDS=',$)
204   FORMAT(/' ********* DATA ANALYSIS ONLY *********'/)
205   FORMAT(/' ********* POST-PROCESSING PARALLEL RUNS **********'/)
206   FORMAT(/'********* RANDOM NUMBERS READ FROM UNIT 2 *********'/)
210   FORMAT(/' ********* NOT ENOUGH TIME to finish within',' limit of',
     *F8.2,' hours',I5,' batches used********',/10X,' ',I12,' Histories 
     *run, ',I12,' Histories analyzed'//)
220   FORMAT(I12,' ',I12)
250   FORMAT(/' ********* FINAL RANDOM NUMBER SEED: ',2I12,' *********')
255   FORMAT(/' FOR OLD RUN:'/' ----------- '/' TOTAL CPUTIME =',F8.1,'s
     * (=',F5.2,' hr)')
256   FORMAT(/' FOR PARALLEL RUNS:'/' ----------------- '/' ON ',I5,' MA
     *CHINES '/' TOTAL CPUTIME =',F8.1,'s (=',F8.2,' hr), CPUTIME/MACHIN
     *E =',F8.1,'s')
260   FORMAT(/'FINISHED:  TIME ELAPSED, CPUTIME',',RATIO= ',2F8.1,'(=',F
     *5.2,'hr)',F8.2)
270   FORMAT(/' FINISHED SIMULATIONS: CPUTIME=',F8.1,'(=',F5.2,' hr)')
280   FORMAT(/' CPUTIME / history =',F10.5,' sec.          # histories',
     *' / hour =',F12.0/)
500   FORMAT(//' NORMALIZATION PROBLEMS IN FIRST BIN(/MeV) SINCE',' DIFF
     *ERENT ECUTS ARE USED IN DIFFERENT REGIONS '/'   MAXIMUM ECUT=',F10
     *.3,' USED EVERYWHERE***'//)
400   FORMAT(/' End of run',10X,$)
      END
      SUBROUTINE AUSGAB(IARG)
      implicit none
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/GEOM/ZPLANE( 501),RCYL(0:4), CYRAD2(4),NTRACK( 2001),NZ,NR,
     *NREG,NPLANE
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NTRACK,NZ,NR,NREG,NPLANE
      COMMON/SCORE/ SCFLU(1000, 501,4,3,2), SCFLU2(1000, 501,4,3,2), SCE
     *AVE( 501,4,3,2), SCEAVE2( 501,4,3,2), SCEAVE_COV( 501,4,3,2),SCSTP
     *,SCSTP2,PIISTP, SCELEP( 501,4,2), SCELEP2( 501,4,2), SCELEP_COV( 5
     *01,4,2), SCFLEP(1000, 501,4,2), SCFLEP2(1000, 501,4,2), SCTFLU( 50
     *1,4,3,2), SCTFLU2( 501,4,3,2), SCTLEP( 501,4,2), SCTLEP2( 501,4,2)
     *, SCSTP_LAST,SCFLU_LAST(1000, 501,4,3,2), SCFLEP_LAST(1000, 501,4,
     *2), SCTFLU_LAST( 501,4,3,2), SCTLEP_LAST( 501,4,2), IHSTRY,SCFLU_T
     *MP(1000, 501,4,3,2), SCEAVE_TMP( 501,4,3,2), SCSTP_TMP,SCELEP_TMP(
     * 501,4,2), SCFLEP_TMP(1000, 501,4,2), SCTFLU_TMP( 501,4,3,2), SCTL
     *EP_TMP( 501,4,2), BINTOP(1000),SLOTE,ECUTMX,PCUTMX,EBINW(1000,3),
     *VOLUME(500,4),MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      REAL*8 SCFLU,SCFLU2,SCEAVE,SCEAVE2,SCEAVE_COV,SCSTP,SCSTP2, SCELEP
     *,SCELEP2,SCELEP_COV,SCFLEP,SCFLEP2,SCTFLU,SCTFLU2,SCTLEP, SCTLEP2,
     *PIISTP
      integer*8 SCSTP_LAST,SCFLU_LAST,SCFLEP_LAST,SCTFLU_LAST,SCTLEP_LAS
     *T,IHSTRY
      real*8 SCFLU_TMP,SCEAVE_TMP,SCSTP_TMP,SCELEP_TMP,SCFLEP_TMP, SCTFL
     *U_TMP,SCTLEP_TMP,BINTOP,SLOTE, ECUTMX,PCUTMX,EBINW,VOLUME
      integer*4 MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(4,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBEAM
     *,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DI
     *STZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PRO
     *BSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,ZS
     *OFST,                                                      SVTMP1,
     *SVTMP2,SVTMP3,SVTMP4,
     *       RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                     XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,WEI
     *GHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      integer*4 IARG,IQL,IRL,IB,IBTOP,NBIN,IBDOWN,IBB,I,IX,IZ
      real*8 BINFR(1000),  WEIGHT,WTTVST,EKEMID,EKIN,WTEKIN,FRSUM,BINBOT
      MXNP=MAX(MXNP,NP)
      IQL=IQ(NP)
      IF ((IPRIM.EQ.1 .OR. IPRIM.EQ.2 .OR. IPRIM.EQ.4)) THEN
        IF ((IARG .EQ. 7)) THEN
          DO 1641 I=NPold+1,NP
            LATCH(I)=1
1641      CONTINUE
1642      CONTINUE
        ELSE IF((IARG .EQ. 9)) THEN
          IF ((NP .EQ. NPold)) THEN
            continue
          ELSE
            DO 1651 I=NPold+1,NP
              LATCH(I)=1
1651        CONTINUE
1652        CONTINUE
          END IF
        ELSE IF((IARG .EQ. 11)) THEN
          IF ((IQ(NP) .EQ. -1)) THEN
            LATCH(NP)=1
          ELSE
            LATCH(NP-1)=1
          END IF
        ELSE IF((IARG .EQ. 13 .OR. IARG .EQ. 14)) THEN
          DO 1661 I=NPold,NP
            LATCH(I) = 1
1661      CONTINUE
1662      CONTINUE
        END IF
      ELSE IF((IPRIM.EQ.3)) THEN
        IF ((IARG.EQ.16)) THEN
          IF ((NP.GT.NPold .OR. (NP.EQ.NPold .AND. i_survived_rr .GT. 0)
     *    )) THEN
            DO 1671 I=NPold,NP
              LATCH(I)=1
1671        CONTINUE
1672        CONTINUE
          END IF
        ELSE IF((IARG.EQ.18)) THEN
          IF ((NP.GT.NPold .OR. (NP.EQ.NPold .AND. i_survived_rr .GT. 0)
     *    )) THEN
            DO 1681 I=NPold,NP
              LATCH(I)=1
1681        CONTINUE
1682        CONTINUE
          END IF
        ELSE IF((IARG.EQ.20)) THEN
          IF ((NP .GE. NPold .AND. (IQ(NPold).EQ.-1 .OR. i_survived_rr .
     *    GT. 0))) THEN
            DO 1691 I=NPold,NP
              LATCH(I)=1
1691        CONTINUE
1692        CONTINUE
          END IF
        ELSE IF((IARG.EQ.24)) THEN
          LATCH(NP)=1
        END IF
      END IF
      IF((IWATCH .GT. 0))CALL WATCH(IARG,IWATCH)
      IRL=IR(NP)
      IF((IRL .EQ. 1))RETURN
      IX=(IRL-2)/NZ+1
      IZ=IRL-1-NZ*(IX-1)
      IF ((IARG .EQ. 0)) THEN
        IQL=IQL+2
        WEIGHT=WT(NP)
        WTTVST=WEIGHT*TVSTEP
        IF ((IQL .NE. 2)) THEN
          EKIN=E(NP)-RM
          EKEMID=EKIN - 0.5*EDEP
          IF ((NHSTRY.EQ.SCSTP_LAST)) THEN
            SCSTP_TMP=SCSTP_TMP + 1
          ELSE
            SCSTP=SCSTP+SCSTP_TMP
            SCSTP2=SCSTP2 + SCSTP_TMP*SCSTP_TMP
            SCSTP_TMP=1
            SCSTP_LAST=NHSTRY
          END IF
        ELSE
          EKIN=E(NP)
          EKEMID=EKIN
        END IF
        WTEKIN=WTTVST*EKEMID
        IF ((SLOTE .GT. 0.0)) THEN
          IB=MIN0(int(EKIN/SLOTE+0.999),MAXIB)
          IF(((IB .GE.1) .OR. (IB .LE. MAXIB)))GO TO 1700
        ELSE
          DO 1711 IB=1,MAXIB
            IF((EKIN .LE. BINTOP(IB)))GO TO 1700
1711      CONTINUE
1712      CONTINUE
          IF ((EKIN-BINTOP(MAXIB) .LT. 1.E-5*BINTOP(MAXIB))) THEN
            IB=MAXIB
            GO TO 1700
          END IF
        END IF
        WRITE(6,1720)IB,EKIN,BINTOP(MAXIB),SLOTE
1720    FORMAT(/' ********* IB out of range, IB=',I12,'*********'/'  EKI
     *N=',F15.6, '     BINTOP(MAXIB)=',F15.6,'    SLOTE=',F10.5//)
        STOP
1700    CONTINUE
        IBTOP = IB
        IF ((EDEP .EQ. 0.0)) THEN
          NBIN = 1
          BINFR(1) = 1.0
        ELSE
          FRSUM=0.0
          DO 1731 IB=1,IBTOP
            IBDOWN = IBTOP - IB +1
            IF ((IBDOWN.EQ.1)) THEN
              BINBOT=ECUT(IRL)-PRM
            ELSE
              BINBOT=BINTOP(IBDOWN-1)
            END IF
            IF ((IB.EQ.1)) THEN
              BINFR(IB)=(EKIN-BINBOT)/EDEP
            ELSE
              BINFR(IB) = (BINTOP(IBDOWN) - BINBOT)/EDEP
            END IF
            IF (( (BINFR(IB) .GE. 1.0 - FRSUM) .OR. IBDOWN.EQ.1 .OR. (BI
     *      NBOT.LE.ECUT(IRL)-PRM) )) THEN
              IF (( (BINFR(IB) .GE. 1.0-FRSUM) .OR. (BINBOT .LE. ECUT(IR
     *        L)-PRM ) )) THEN
                BINBOT = max(ECUT(IRL)-PRM,EKIN-EDEP)
                IF ((IB.GT.1)) THEN
                  BINFR(IB) =(BINTOP(IBDOWN) - BINBOT)/EDEP
                ELSE
                  BINFR(IB) =(EKIN - BINBOT)/EDEP
                END IF
              END IF
              NBIN = IB
              GO TO 1740
            ELSE
              FRSUM = FRSUM + BINFR(IB)
            END IF
1731      CONTINUE
1732      CONTINUE
1740      CONTINUE
        END IF
        IF ((IWATCH.EQ.2)) THEN
          WRITE(6,1750)NBIN,((IBTOP-IBB+1),BINTOP(IBTOP-IBB+1),BINFR(IBB
     *    ), IBB=1,NBIN)
1750      FORMAT(' AUSGAB: pathlength spread over', I3,' bins'/ (' BINTO
     *P(',I3,')=',F12.3,'  BINFR=',F8.4))
        END IF
        FRSUM=0.
        DO 1761 IB=1,NBIN
          IBDOWN= IBTOP - IB + 1
          IF ((NHSTRY.EQ.SCFLU_LAST(IBDOWN,IZ,IX,IQL,1))) THEN
            SCFLU_TMP(IBDOWN,IZ,IX,IQL,1)=SCFLU_TMP(IBDOWN,IZ,IX,IQL,1)
     *      + BINFR(IB)*WTTVST
          ELSE
            SCFLU(IBDOWN,IZ,IX,IQL,1)=SCFLU(IBDOWN,IZ,IX,IQL,1)+SCFLU_TM
     *      P(IBDOWN,IZ,IX,IQL,1)
            SCFLU2(IBDOWN,IZ,IX,IQL,1)=SCFLU2(IBDOWN,IZ,IX,IQL,1) + SCFL
     *      U_TMP(IBDOWN,IZ,IX,IQL,1)*SCFLU_TMP(IBDOWN,IZ,IX,IQL,1)
            SCFLU_TMP(IBDOWN,IZ,IX,IQL,1)=BINFR(IB)*WTTVST
            SCFLU_LAST(IBDOWN,IZ,IX,IQL,1)=NHSTRY
          END IF
          IF ((IQL.NE.2)) THEN
            IF ((NHSTRY.EQ.SCFLEP_LAST(IBDOWN,IZ,IX,1))) THEN
              SCFLEP_TMP(IBDOWN,IZ,IX,1)=SCFLEP_TMP(IBDOWN,IZ,IX,1) + BI
     *        NFR(IB)*WTTVST
            ELSE
              SCFLEP(IBDOWN,IZ,IX,1)=SCFLEP(IBDOWN,IZ,IX,1)+SCFLEP_TMP(I
     *        BDOWN,IZ,IX,1)
              SCFLEP2(IBDOWN,IZ,IX,1)=SCFLEP2(IBDOWN,IZ,IX,1) + SCFLEP_T
     *        MP(IBDOWN,IZ,IX,1)*SCFLEP_TMP(IBDOWN,IZ,IX,1)
              SCFLEP_TMP(IBDOWN,IZ,IX,1)=BINFR(IB)*WTTVST
              SCFLEP_LAST(IBDOWN,IZ,IX,1)=NHSTRY
            END IF
          END IF
          IF (( (IPRIM.EQ.1.OR.IPRIM.EQ.2.OR.IPRIM.EQ.3) .AND. (LATCH(NP
     *    ).EQ.0))) THEN
            IF ((NHSTRY.EQ.SCFLU_LAST(IBDOWN,IZ,IX,IQL,2))) THEN
              SCFLU_TMP(IBDOWN,IZ,IX,IQL,2)=SCFLU_TMP(IBDOWN,IZ,IX,IQL,2
     *        ) + BINFR(IB)*WTTVST
            ELSE
              SCFLU(IBDOWN,IZ,IX,IQL,2)=SCFLU(IBDOWN,IZ,IX,IQL,2)+SCFLU_
     *        TMP(IBDOWN,IZ,IX,IQL,2)
              SCFLU2(IBDOWN,IZ,IX,IQL,2)=SCFLU2(IBDOWN,IZ,IX,IQL,2) + SC
     *        FLU_TMP(IBDOWN,IZ,IX,IQL,2)*SCFLU_TMP(IBDOWN,IZ,IX,IQL,2)
              SCFLU_TMP(IBDOWN,IZ,IX,IQL,2)=BINFR(IB)*WTTVST
              SCFLU_LAST(IBDOWN,IZ,IX,IQL,2)=NHSTRY
            END IF
            IF ((IQL.NE.2)) THEN
              IF ((NHSTRY.EQ.SCFLEP_LAST(IBDOWN,IZ,IX,2))) THEN
                SCFLEP_TMP(IBDOWN,IZ,IX,2)=SCFLEP_TMP(IBDOWN,IZ,IX,2) +
     *          BINFR(IB)*WTTVST
              ELSE
                SCFLEP(IBDOWN,IZ,IX,2)=SCFLEP(IBDOWN,IZ,IX,2)+SCFLEP_TMP
     *          (IBDOWN,IZ,IX,2)
                SCFLEP2(IBDOWN,IZ,IX,2)=SCFLEP2(IBDOWN,IZ,IX,2) + SCFLEP
     *          _TMP(IBDOWN,IZ,IX,2)*SCFLEP_TMP(IBDOWN,IZ,IX,2)
                SCFLEP_TMP(IBDOWN,IZ,IX,2)=BINFR(IB)*WTTVST
                SCFLEP_LAST(IBDOWN,IZ,IX,2)=NHSTRY
              END IF
            END IF
          END IF
          IF ((IPRIM .EQ. 4 .AND. LATCH(NP) .NE. 0)) THEN
            IF ((NHSTRY.EQ.SCFLU_LAST(IBDOWN,IZ,IX,IQL,2))) THEN
              SCFLU_TMP(IBDOWN,IZ,IX,IQL,2)=SCFLU_TMP(IBDOWN,IZ,IX,IQL,2
     *        ) + BINFR(IB)*WTTVST
            ELSE
              SCFLU(IBDOWN,IZ,IX,IQL,2)=SCFLU(IBDOWN,IZ,IX,IQL,2)+SCFLU_
     *        TMP(IBDOWN,IZ,IX,IQL,2)
              SCFLU2(IBDOWN,IZ,IX,IQL,2)=SCFLU2(IBDOWN,IZ,IX,IQL,2) + SC
     *        FLU_TMP(IBDOWN,IZ,IX,IQL,2)*SCFLU_TMP(IBDOWN,IZ,IX,IQL,2)
              SCFLU_TMP(IBDOWN,IZ,IX,IQL,2)=BINFR(IB)*WTTVST
              SCFLU_LAST(IBDOWN,IZ,IX,IQL,2)=NHSTRY
            END IF
            IF ((IQL.NE.2)) THEN
              IF ((NHSTRY.EQ.SCFLEP_LAST(IBDOWN,IZ,IX,2))) THEN
                SCFLEP_TMP(IBDOWN,IZ,IX,2)=SCFLEP_TMP(IBDOWN,IZ,IX,2) +
     *          BINFR(IB)*WTTVST
              ELSE
                SCFLEP(IBDOWN,IZ,IX,2)=SCFLEP(IBDOWN,IZ,IX,2)+SCFLEP_TMP
     *          (IBDOWN,IZ,IX,2)
                SCFLEP2(IBDOWN,IZ,IX,2)=SCFLEP2(IBDOWN,IZ,IX,2) + SCFLEP
     *          _TMP(IBDOWN,IZ,IX,2)*SCFLEP_TMP(IBDOWN,IZ,IX,2)
                SCFLEP_TMP(IBDOWN,IZ,IX,2)=BINFR(IB)*WTTVST
                SCFLEP_LAST(IBDOWN,IZ,IX,2)=NHSTRY
              END IF
            END IF
          END IF
          FRSUM=FRSUM+BINFR(IB)
1761    CONTINUE
1762    CONTINUE
        IF ((NHSTRY.EQ.SCTFLU_LAST(IZ,IX,IQL,1))) THEN
          SCTFLU_TMP(IZ,IX,IQL,1)=SCTFLU_TMP(IZ,IX,IQL,1) + FRSUM*WTTVST
          SCEAVE_TMP(IZ,IX,IQL,1)=SCEAVE_TMP(IZ,IX,IQL,1) + WTEKIN
        ELSE
          SCTFLU(IZ,IX,IQL,1)=SCTFLU(IZ,IX,IQL,1)+SCTFLU_TMP(IZ,IX,IQL,1
     *    )
          SCTFLU2(IZ,IX,IQL,1)=SCTFLU2(IZ,IX,IQL,1) + SCTFLU_TMP(IZ,IX,I
     *    QL,1)*SCTFLU_TMP(IZ,IX,IQL,1)
          SCEAVE(IZ,IX,IQL,1)=SCEAVE(IZ,IX,IQL,1)+SCEAVE_TMP(IZ,IX,IQL,1
     *    )
          SCEAVE2(IZ,IX,IQL,1)=SCEAVE2(IZ,IX,IQL,1) + SCEAVE_TMP(IZ,IX,I
     *    QL,1)*SCEAVE_TMP(IZ,IX,IQL,1)
          SCEAVE_COV(IZ,IX,IQL,1)=SCEAVE_COV(IZ,IX,IQL,1)+SCTFLU_TMP(IZ,
     *    IX,IQL,1)*SCEAVE_TMP(IZ,IX,IQL,1)
          SCTFLU_TMP(IZ,IX,IQL,1)=FRSUM*WTTVST
          SCEAVE_TMP(IZ,IX,IQL,1)=WTEKIN
          SCTFLU_LAST(IZ,IX,IQL,1)=NHSTRY
        END IF
        IF ((IQL.NE.2)) THEN
          IF ((NHSTRY.EQ.SCTLEP_LAST(IZ,IX,1))) THEN
            SCTLEP_TMP(IZ,IX,1)=SCTLEP_TMP(IZ,IX,1) + FRSUM*WTTVST
            SCELEP_TMP(IZ,IX,1)=SCELEP_TMP(IZ,IX,1) + WTEKIN
          ELSE
            SCTLEP(IZ,IX,1)=SCTLEP(IZ,IX,1)+SCTLEP_TMP(IZ,IX,1)
            SCTLEP2(IZ,IX,1)=SCTLEP2(IZ,IX,1) + SCTLEP_TMP(IZ,IX,1)*SCTL
     *      EP_TMP(IZ,IX,1)
            SCELEP(IZ,IX,1)=SCELEP(IZ,IX,1)+SCELEP_TMP(IZ,IX,1)
            SCELEP2(IZ,IX,1)=SCELEP2(IZ,IX,1) + SCELEP_TMP(IZ,IX,1)*SCEL
     *      EP_TMP(IZ,IX,1)
            SCELEP_COV(IZ,IX,1)=SCELEP_COV(IZ,IX,1)+SCTLEP_TMP(IZ,IX,1)*
     *      SCELEP_TMP(IZ,IX,1)
            SCTLEP_TMP(IZ,IX,1)=FRSUM*WTTVST
            SCELEP_TMP(IZ,IX,1)=WTEKIN
            SCTLEP_LAST(IZ,IX,1)=NHSTRY
          END IF
        END IF
        IF (( (IPRIM.EQ.1.OR.IPRIM.EQ.2.OR.IPRIM.EQ.3) .AND. (LATCH(NP).
     *  EQ.0))) THEN
          IF ((NHSTRY.EQ.SCTFLU_LAST(IZ,IX,IQL,2))) THEN
            SCTFLU_TMP(IZ,IX,IQL,2)=SCTFLU_TMP(IZ,IX,IQL,2) + FRSUM*WTTV
     *      ST
            SCEAVE_TMP(IZ,IX,IQL,2)=SCEAVE_TMP(IZ,IX,IQL,2) + WTEKIN
          ELSE
            SCTFLU(IZ,IX,IQL,2)=SCTFLU(IZ,IX,IQL,2)+SCTFLU_TMP(IZ,IX,IQL
     *      ,2)
            SCTFLU2(IZ,IX,IQL,2)=SCTFLU2(IZ,IX,IQL,2) + SCTFLU_TMP(IZ,IX
     *      ,IQL,2)*SCTFLU_TMP(IZ,IX,IQL,2)
            SCEAVE(IZ,IX,IQL,2)=SCEAVE(IZ,IX,IQL,2)+SCEAVE_TMP(IZ,IX,IQL
     *      ,2)
            SCEAVE2(IZ,IX,IQL,2)=SCEAVE2(IZ,IX,IQL,2) + SCEAVE_TMP(IZ,IX
     *      ,IQL,2)*SCEAVE_TMP(IZ,IX,IQL,2)
            SCEAVE_COV(IZ,IX,IQL,2)=SCEAVE_COV(IZ,IX,IQL,2)+SCTFLU_TMP(I
     *      Z,IX,IQL,2)*SCEAVE_TMP(IZ,IX,IQL,2)
            SCTFLU_TMP(IZ,IX,IQL,2)=FRSUM*WTTVST
            SCEAVE_TMP(IZ,IX,IQL,2)=WTEKIN
            SCTFLU_LAST(IZ,IX,IQL,2)=NHSTRY
          END IF
          IF ((IQL.NE.2)) THEN
            IF ((NHSTRY.EQ.SCTLEP_LAST(IZ,IX,2))) THEN
              SCTLEP_TMP(IZ,IX,2)=SCTLEP_TMP(IZ,IX,2) + FRSUM*WTTVST
              SCELEP_TMP(IZ,IX,2)=SCELEP_TMP(IZ,IX,2) + WTEKIN
            ELSE
              SCTLEP(IZ,IX,2)=SCTLEP(IZ,IX,2)+SCTLEP_TMP(IZ,IX,2)
              SCTLEP2(IZ,IX,2)=SCTLEP2(IZ,IX,2) + SCTLEP_TMP(IZ,IX,2)*SC
     *        TLEP_TMP(IZ,IX,2)
              SCELEP(IZ,IX,2)=SCELEP(IZ,IX,2)+SCELEP_TMP(IZ,IX,2)
              SCELEP2(IZ,IX,2)=SCELEP2(IZ,IX,2) + SCELEP_TMP(IZ,IX,2)*SC
     *        ELEP_TMP(IZ,IX,2)
              SCELEP_COV(IZ,IX,2)=SCELEP_COV(IZ,IX,2)+SCTLEP_TMP(IZ,IX,2
     *        )*SCELEP_TMP(IZ,IX,2)
              SCTLEP_TMP(IZ,IX,2)=FRSUM*WTTVST
              SCELEP_TMP(IZ,IX,2)=WTEKIN
              SCTLEP_LAST(IZ,IX,2)=NHSTRY
            END IF
          END IF
        END IF
        IF ((IPRIM .EQ. 4 .AND. LATCH(NP) .NE. 0)) THEN
          IF ((NHSTRY.EQ.SCTFLU_LAST(IZ,IX,IQL,2))) THEN
            SCTFLU_TMP(IZ,IX,IQL,2)=SCTFLU_TMP(IZ,IX,IQL,2) + FRSUM*WTTV
     *      ST
            SCEAVE_TMP(IZ,IX,IQL,2)=SCEAVE_TMP(IZ,IX,IQL,2) + WTEKIN
          ELSE
            SCTFLU(IZ,IX,IQL,2)=SCTFLU(IZ,IX,IQL,2)+SCTFLU_TMP(IZ,IX,IQL
     *      ,2)
            SCTFLU2(IZ,IX,IQL,2)=SCTFLU2(IZ,IX,IQL,2) + SCTFLU_TMP(IZ,IX
     *      ,IQL,2)*SCTFLU_TMP(IZ,IX,IQL,2)
            SCEAVE(IZ,IX,IQL,2)=SCEAVE(IZ,IX,IQL,2)+SCEAVE_TMP(IZ,IX,IQL
     *      ,2)
            SCEAVE2(IZ,IX,IQL,2)=SCEAVE2(IZ,IX,IQL,2) + SCEAVE_TMP(IZ,IX
     *      ,IQL,2)*SCEAVE_TMP(IZ,IX,IQL,2)
            SCEAVE_COV(IZ,IX,IQL,2)=SCEAVE_COV(IZ,IX,IQL,2)+SCTFLU_TMP(I
     *      Z,IX,IQL,2)*SCEAVE_TMP(IZ,IX,IQL,2)
            SCTFLU_TMP(IZ,IX,IQL,2)=FRSUM*WTTVST
            SCEAVE_TMP(IZ,IX,IQL,2)=WTEKIN
            SCTFLU_LAST(IZ,IX,IQL,2)=NHSTRY
          END IF
          IF ((IQL.NE.2)) THEN
            IF ((NHSTRY.EQ.SCTLEP_LAST(IZ,IX,2))) THEN
              SCTLEP_TMP(IZ,IX,2)=SCTLEP_TMP(IZ,IX,2) + FRSUM*WTTVST
              SCELEP_TMP(IZ,IX,2)=SCELEP_TMP(IZ,IX,2) + WTEKIN
            ELSE
              SCTLEP(IZ,IX,2)=SCTLEP(IZ,IX,2)+SCTLEP_TMP(IZ,IX,2)
              SCTLEP2(IZ,IX,2)=SCTLEP2(IZ,IX,2) + SCTLEP_TMP(IZ,IX,2)*SC
     *        TLEP_TMP(IZ,IX,2)
              SCELEP(IZ,IX,2)=SCELEP(IZ,IX,2)+SCELEP_TMP(IZ,IX,2)
              SCELEP2(IZ,IX,2)=SCELEP2(IZ,IX,2) + SCELEP_TMP(IZ,IX,2)*SC
     *        ELEP_TMP(IZ,IX,2)
              SCELEP_COV(IZ,IX,2)=SCELEP_COV(IZ,IX,2)+SCTLEP_TMP(IZ,IX,2
     *        )*SCELEP_TMP(IZ,IX,2)
              SCTLEP_TMP(IZ,IX,2)=FRSUM*WTTVST
              SCELEP_TMP(IZ,IX,2)=WTEKIN
              SCTLEP_LAST(IZ,IX,2)=NHSTRY
            END IF
          END IF
        END IF
      END IF
      RETURN
      END
      SUBROUTINE HOWFAR
      implicit none
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/GEOM/ZPLANE( 501),RCYL(0:4), CYRAD2(4),NTRACK( 2001),NZ,NR,
     *NREG,NPLANE
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NTRACK,NZ,NR,NREG,NPLANE
      COMMON/SCORE/ SCFLU(1000, 501,4,3,2), SCFLU2(1000, 501,4,3,2), SCE
     *AVE( 501,4,3,2), SCEAVE2( 501,4,3,2), SCEAVE_COV( 501,4,3,2),SCSTP
     *,SCSTP2,PIISTP, SCELEP( 501,4,2), SCELEP2( 501,4,2), SCELEP_COV( 5
     *01,4,2), SCFLEP(1000, 501,4,2), SCFLEP2(1000, 501,4,2), SCTFLU( 50
     *1,4,3,2), SCTFLU2( 501,4,3,2), SCTLEP( 501,4,2), SCTLEP2( 501,4,2)
     *, SCSTP_LAST,SCFLU_LAST(1000, 501,4,3,2), SCFLEP_LAST(1000, 501,4,
     *2), SCTFLU_LAST( 501,4,3,2), SCTLEP_LAST( 501,4,2), IHSTRY,SCFLU_T
     *MP(1000, 501,4,3,2), SCEAVE_TMP( 501,4,3,2), SCSTP_TMP,SCELEP_TMP(
     * 501,4,2), SCFLEP_TMP(1000, 501,4,2), SCTFLU_TMP( 501,4,3,2), SCTL
     *EP_TMP( 501,4,2), BINTOP(1000),SLOTE,ECUTMX,PCUTMX,EBINW(1000,3),
     *VOLUME(500,4),MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      REAL*8 SCFLU,SCFLU2,SCEAVE,SCEAVE2,SCEAVE_COV,SCSTP,SCSTP2, SCELEP
     *,SCELEP2,SCELEP_COV,SCFLEP,SCFLEP2,SCTFLU,SCTFLU2,SCTLEP, SCTLEP2,
     *PIISTP
      integer*8 SCSTP_LAST,SCFLU_LAST,SCFLEP_LAST,SCTFLU_LAST,SCTLEP_LAS
     *T,IHSTRY
      real*8 SCFLU_TMP,SCEAVE_TMP,SCSTP_TMP,SCELEP_TMP,SCFLEP_TMP, SCTFL
     *U_TMP,SCTLEP_TMP,BINTOP,SLOTE, ECUTMX,PCUTMX,EBINW,VOLUME
      integer*4 MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      integer*4 IQL,IRL,IX,IZ,IHITP,IHITC,IZNEW,IXNEW
      real*8 WL,TPLANE,U1,V1,A,TCYL,X1,Y1,B,B2,C,COUT,CIN,RAD
      LOGICAL OUTEND,OUTSID
      IF ((WT(NP) .EQ. 0.0)) THEN
        IDISC=1
        RETURN
      END IF
      OUTEND=.FALSE.
      OUTSID=.FALSE.
      IQL=IQ(NP)
      IRL=IR(NP)
      IF ((IRL .EQ. 1)) THEN
        IDISC=1
        RETURN
      END IF
      IX=(IRL-2)/NZ+1
      IZ=IRL-1-NZ*(IX-1)
      WL=W(NP)
      IF ((WL .GT. 0.0)) THEN
        IHITP=1
        TPLANE=(ZPLANE(IZ+1)-Z(NP))/WL
      ELSE IF((WL .LT. 0.0)) THEN
        IHITP=-1
        TPLANE=(ZPLANE(IZ)-Z(NP))/WL
      ELSE
        IHITP=0
        TPLANE=1.0E30
      END IF
      U1=U(NP)
      V1=V(NP)
      A=U1*U1+V1*V1
      IF ((A .EQ. 0.0)) THEN
        IHITC=0
        TCYL=1.0E30
      ELSE
        X1=X(NP)
        Y1=Y(NP)
        B=X1*U1+Y1*V1
        B2=B*B
        C=X1*X1+Y1*Y1
        COUT=C-CYRAD2(IX)
        IF ((COUT .GT. 0.0)) THEN
          IF ((IWATCH .GT. 0)) THEN
            WRITE(6,1770)COUT
1770        FORMAT(' COUT=',E11.3)
          END IF
          COUT=0.0
        END IF
        IF ((B .GT. 0.0)) THEN
          IHITC=1
          IF ((COUT/B2 .GT. -1.0E-3)) THEN
            TCYL=-0.5*COUT/B
          ELSE
            TCYL=-COUT/(SQRT(B2-A*COUT)+B)
          END IF
        ELSE IF((B .LT. 0.0)) THEN
          IHITC=1
          IF ((COUT/B2 .GT. -1.0E-3)) THEN
            TCYL=-2.*B/A*(1.-0.25*A*COUT/B2)
          ELSE
            TCYL=(SQRT(B2-A*COUT)-B)/A
          END IF
          IF ((IX .NE. 1)) THEN
            CIN=C-CYRAD2(IX-1)
            IF ((CIN .LT. 0.0)) THEN
              IF ((IWATCH .GT. 0)) THEN
                WRITE(6,1780)CIN
1780            FORMAT(' CIN=',E11.3)
              END IF
              CIN=0.0
            END IF
            RAD=B2-A*CIN
            IF ((RAD .GE.0.0)) THEN
              IHITC=-1
              IF ((CIN/B2 .LT. 1.0E-3)) THEN
                TCYL=-0.5*CIN/B
              ELSE
                TCYL=CIN/(SQRT(RAD)-B)
              END IF
            END IF
          END IF
        ELSE
          IHITC=1
          TCYL=SQRT(-COUT/A)
        END IF
      END IF
      IZNEW=IZ+IHITP
      IF(((IZNEW .LT. 1) .OR. (IZNEW .GT. NZ)))OUTEND=.TRUE.
      IXNEW=IX+IHITC
      IF((IXNEW .GT. NR))OUTSID=.TRUE.
      IF (((IHITP .NE. 0) .AND. (IHITC .NE. 0))) THEN
        IF ((TPLANE .LT. TCYL)) THEN
          IF ((OUTEND)) THEN
            IF ((TPLANE.LE.USTEP)) THEN
              USTEP=TPLANE
              IRNEW=1
              RETURN
            END IF
          ELSE
            IF ((TPLANE.LE.USTEP)) THEN
              USTEP=TPLANE
              IRNEW=IRL+IHITP
              RETURN
            END IF
          END IF
        ELSE IF((TCYL .LT. TPLANE)) THEN
          IF ((OUTSID)) THEN
            IF ((TCYL.LE.USTEP)) THEN
              USTEP=TCYL
              IRNEW=1
              RETURN
            END IF
          ELSE
            IF ((TCYL.LE.USTEP)) THEN
              USTEP=TCYL
              IRNEW=IRL+NZ*IHITC
              RETURN
            END IF
          END IF
        ELSE
          IF ((OUTEND .OR. OUTSID)) THEN
            IF ((TCYL.LE.USTEP)) THEN
              USTEP=TCYL
              IRNEW=1
              RETURN
            END IF
          ELSE
            IF ((TCYL.LE.USTEP)) THEN
              USTEP=TCYL
              IRNEW=IRL+IHITP+NZ*IHITC
              RETURN
            END IF
          END IF
        END IF
      ELSE IF((IHITP .NE. 0)) THEN
        IF ((OUTEND)) THEN
          IF ((TPLANE.LE.USTEP)) THEN
            USTEP=TPLANE
            IRNEW=1
            RETURN
          END IF
        ELSE
          IF ((TPLANE.LE.USTEP)) THEN
            USTEP=TPLANE
            IRNEW=IRL+IHITP
            RETURN
          END IF
        END IF
      ELSE
        IF ((OUTSID)) THEN
          IF ((TCYL.LE.USTEP)) THEN
            USTEP=TCYL
            IRNEW=1
            RETURN
          END IF
        ELSE
          IF ((TCYL.LE.USTEP)) THEN
            USTEP=TCYL
            IRNEW=IRL+NZ*IHITC
            RETURN
          END IF
        END IF
      END IF
      END
      SUBROUTINE INPUTS
      implicit none
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/GEOM/ZPLANE( 501),RCYL(0:4), CYRAD2(4),NTRACK( 2001),NZ,NR,
     *NREG,NPLANE
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NTRACK,NZ,NR,NREG,NPLANE
      CHARACTER*1 TITLE(80)
      COMMON/IODAT1/TITLE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET,TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
     *, IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP( 2001),IVAL,DATCOUNT
      real*8 TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
      integer*4 IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP,IVAL,DATCOUN
     *T
      integer*8 NCASE,NCASEO,NCASET
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PLOTC/IPLOT( 2001),IPLOTR(4),IPLOTZ( 501), IPLTIQ(4),IPLTTP
     *(2),IPLT ,IPLTPL,IPLPHB
      integer*4 IPLOT,IPLOTR,IPLOTZ,IPLTIQ,IPLTTP,IPLT,IPLTPL,IPLPHB
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/SCORE/ SCFLU(1000, 501,4,3,2), SCFLU2(1000, 501,4,3,2), SCE
     *AVE( 501,4,3,2), SCEAVE2( 501,4,3,2), SCEAVE_COV( 501,4,3,2),SCSTP
     *,SCSTP2,PIISTP, SCELEP( 501,4,2), SCELEP2( 501,4,2), SCELEP_COV( 5
     *01,4,2), SCFLEP(1000, 501,4,2), SCFLEP2(1000, 501,4,2), SCTFLU( 50
     *1,4,3,2), SCTFLU2( 501,4,3,2), SCTLEP( 501,4,2), SCTLEP2( 501,4,2)
     *, SCSTP_LAST,SCFLU_LAST(1000, 501,4,3,2), SCFLEP_LAST(1000, 501,4,
     *2), SCTFLU_LAST( 501,4,3,2), SCTLEP_LAST( 501,4,2), IHSTRY,SCFLU_T
     *MP(1000, 501,4,3,2), SCEAVE_TMP( 501,4,3,2), SCSTP_TMP,SCELEP_TMP(
     * 501,4,2), SCFLEP_TMP(1000, 501,4,2), SCTFLU_TMP( 501,4,3,2), SCTL
     *EP_TMP( 501,4,2), BINTOP(1000),SLOTE,ECUTMX,PCUTMX,EBINW(1000,3),
     *VOLUME(500,4),MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      REAL*8 SCFLU,SCFLU2,SCEAVE,SCEAVE2,SCEAVE_COV,SCSTP,SCSTP2, SCELEP
     *,SCELEP2,SCELEP_COV,SCFLEP,SCFLEP2,SCTFLU,SCTFLU2,SCTLEP, SCTLEP2,
     *PIISTP
      integer*8 SCSTP_LAST,SCFLU_LAST,SCFLEP_LAST,SCTFLU_LAST,SCTLEP_LAS
     *T,IHSTRY
      real*8 SCFLU_TMP,SCEAVE_TMP,SCSTP_TMP,SCELEP_TMP,SCFLEP_TMP, SCTFL
     *U_TMP,SCTLEP_TMP,BINTOP,SLOTE, ECUTMX,PCUTMX,EBINW,VOLUME
      integer*4 MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(4,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBEAM
     *,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DI
     *STZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PRO
     *BSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,ZS
     *OFST,                                                      SVTMP1,
     *SVTMP2,SVTMP3,SVTMP4,
     *       RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                     XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,WEI
     *GHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/SPECTR/ CDFINV(1000,2),ENSRCD(0:500),SRCPDF(500),SRCCDF(500
     *), NENSRC
      real*8 CDFINV,ENSRCD,SRCPDF,SRCCDF
      integer*4 NENSRC
      COMMON/USERVR/ CEXPTR,GWAIT(150),DUMU,NP_INC(150),MAFORC,IFORCE,NF
     *MIN,NFMAX,NFTIME, ISOURC,IFPB,IQINC,MONOEN,IRODUM,IRNDUM,MEDDUM,ID
     *UM,MEDTMP, PATHL,DELTAP,GWTOLD,EPSLON,ARG
      real*8 CEXPTR,GWAIT,DUMU,PATHL,DELTAP,GWTOLD,EPSLON,ARG
      integer*4 NP_INC,MAFORC,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQIN
     *C, MONOEN,IRODUM,IRNDUM,MEDDUM,IDUM,MEDTMP
      COMMON/USERRR/
     *              CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,
     *                            EKETST,ELKETS,ZL,RL,CDIST,IGEOM,IRANGE
     *,MINZ,MAXZ,MINR,MAXR,IREJCT
      real*8 CRANGE,ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,EKETST,ELKETS
     *,ZL,RL,CDIST
      integer*4 MINZ,MAXZ,MINR,MAXR
      integer*4 IREJCT,IRANGE,IGEOM
      common/ET_control/ smaxir( 2001),estepe,ximax,  skindepth_for_bca,
     *transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,6), eno_array(200,6), eno_atbin_array(200,6), n_sh
     *ell(6), radc_flag,  ibcmp( 2001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 jrng1,jrng2,IRL,ILOW,IHIGH,IB,LINBIN,VAL,ITMAX,IT,IQL,IX
      real*8 DELLIN,RATIO,GAP,SMAX
      INTEGER INEXT
      REAL STATLM
      INTEGER MODEIN
      REAL TEMP1,TEMP2,TEMP3,TEMP4
      INTEGER IDNEAR
      INTEGER IFLUOR
      INTEGER IZ, IREGLO, IREGHI
      INTEGER IESTEP
      REAL FESTEP
      REAL ADDING
      INTEGER I, J, K, PLN, COUNT, SLENGHT, REGNUM
      INTEGER NUM_TITLE,  NUM_IWATCH, NUM_STRAND, NUM_IRSTRT, NUM_PLSTF,
     * NUM_STORE, NUM_STARTR, NUM_STOPR, NUM_SLOTE, NUM_TOPEBIN,  NUM_HI
     *ST, NUM_SEEDS, NUM_MXTIME, NUM_IPRIM, NUM_BREMDIST, NUM_BREMSPLIT,
     * NUM_BREMPEVEN, NUM_I_PLAY_RR, NUM_ESAVEIN,  NUM_ESTEPE, NUM_SMAX,
     * NUM_RAYLEIGH, NUM_IREJCT, NUM_HOWFAR, NUM_SAVELE, NUM_IFLUOR, NUM
     *_FLUIZ, NUM_FREGSTART, NUM_FREGSTOP, NUM_RRPARAM, NUM_RRMINPL, NUM
     *_RRMAXPL, NUM_RRMINRA, NUM_RRMAXRA, NUM_FORCE, NUM_STRTFRC, NUM_ST
     *PFRC, NUM_NESTEP, NUM_NSMAX, NUM_ADJEREG, NUM_FRAKESTEP
      integer*4 my_unit, egs_open_datfile
      I=0
      ERROR_FLAG=0
      DO 1791 J=1,100
        NVALUE(J)=0
1791  CONTINUE
1792  CONTINUE
      WRITE(6,1800)4, 501
1800  FORMAT(//' FLURZnrc ',' ',' ON ','linux',' '/ T20,'Maximum numbero
     *f radial and depth zones=',2I4)
      IVAL = IVAL + 1
      NUM_TITLE = IVAL
      VALUES_SOUGHT(IVAL)='TITLE'
      TYPE(IVAL)=2
      NVALUE(IVAL)=1
      DELIMETER='NONE'
      NMIN = NUM_TITLE
      NMAX = NUM_TITLE
      CALL GET_INPUT
      WRITE(6,1810)
1810  FORMAT(//' *** INPUT CARD I01 ***')
      READ (CHAR_VALUE(NUM_TITLE,1),FMT='(80A1)') (TITLE(I),I=1,80)
      WRITE (*,1820) (TITLE(I),I=1,79)
1820  FORMAT ('TITLE: ',79A1/)
      IVAL = IVAL + 1
      NUM_IWATCH = IVAL
      VALUES_SOUGHT(IVAL)='IWATCH'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='OFF'
      ALLOWED_INPUTS(IVAL,1)='INTERACTIONS'
      ALLOWED_INPUTS(IVAL,2)='STEPS'
      ALLOWED_INPUTS(IVAL,4)='GRAPH'
      IVAL = IVAL + 1
      NUM_STRAND = IVAL
      VALUES_SOUGHT(IVAL)='STORE INITIAL RANDOM NUMBERS'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='NO'
      ALLOWED_INPUTS(IVAL,1)='LAST'
      ALLOWED_INPUTS(IVAL,2)='ALL'
      IVAL = IVAL + 1
      NUM_IRSTRT = IVAL
      VALUES_SOUGHT(IVAL)='IRESTART'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='FIRST'
      ALLOWED_INPUTS(IVAL,1)='RESTART'
      ALLOWED_INPUTS(IVAL,3)='ANALYZE'
      ALLOWED_INPUTS(IVAL,4)='START-RNS'
      ALLOWED_INPUTS(IVAL,5)='PARALLEL'
      IVAL = IVAL + 1
      NUM_PLSTF = IVAL
      VALUES_SOUGHT(IVAL)='PRINT FLUENCE SPECTRA'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='ALL'
      ALLOWED_INPUTS(IVAL,1)='CONDENSED'
      ALLOWED_INPUTS(IVAL,2)='SPECIFIED'
      ALLOWED_INPUTS(IVAL,3)='NONE'
      IVAL = IVAL + 1
      NUM_STORE = IVAL
      VALUES_SOUGHT(IVAL)='STORE DATA ARRAYS'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='YES'
      ALLOWED_INPUTS(IVAL,1)='NO'
      IVAL = IVAL + 1
      NUM_IPRIM = IVAL
      VALUES_SOUGHT(IVAL)='IPRIMARY'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='TOTAL FLUENCE'
      ALLOWED_INPUTS(IVAL,1)='ELECTRON PRIMARIES'
      ALLOWED_INPUTS(IVAL,2)='INCLUDE BREM SECONDARIES'
      ALLOWED_INPUTS(IVAL,3)='PHOTON PRIMARIES'
      ALLOWED_INPUTS(IVAL,4)='ELECTRON SECONDARIES'
      DELIMETER='I/O CONTROL'
      NMIN = NUM_IWATCH
      NMAX = NUM_IPRIM
      CALL GET_INPUT
      IPRNTP=VALUE(NUM_PLSTF,1)
      IF ((IPRNTP.EQ.2)) THEN
        IVAL = IVAL + 1
        NUM_STARTR = IVAL
        VALUES_SOUGHT(IVAL)='LIST FLUENCE START REGION'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=2
        VALUE_MAX(IVAL)= 2001
        DEFAULT(IVAL)=1
        IVAL = IVAL + 1
        NUM_STOPR = IVAL
        VALUES_SOUGHT(IVAL)='LIST FLUENCE STOP REGION'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=2
        VALUE_MAX(IVAL)= 2001
        DEFAULT(IVAL)= 2001
        NMIN = NUM_STARTR
        NMAX = NUM_STOPR
        CALL GET_INPUT
      END IF
      WRITE(6,1830)
1830  FORMAT(' *** INPUT CARD IO2 ***')
      IWATCH=VALUE(NUM_IWATCH,1)
      ISTORE=VALUE(NUM_STRAND,1)
      IRSTRT=VALUE(NUM_IRSTRT,1)
      IDAT=VALUE(NUM_STORE,1)
      IPRIM=VALUE(NUM_IPRIM,1)
      WRITE(6,1840)IWATCH,ISTORE,IRSTRT,IPRNTP,IDAT,IPRIM
1840  FORMAT(/' DO NOT TRACK(0) OR TRACK(>0) EVERY INTERACTION:',T60,I12
     */ ' DO NOT STORE(0) OR STORE(1,2) INITIAL RANDOM #s:',T60,I12/ ' F
     *IRST RUN(0),RESTARTED(1),ANALYZE(3),READ RNS(4),'/ '   PARALLEL(5)
     *:',T60,I12/ ' LIST ALL(0), SHORT PHOT(1),SPECIFIED REGIONS(2), NON
     *E(>2):',T60,I12/ ' STORE DATA(0) OR NOT(1):',T60,I12/ ' OUTPUT TOT
     *AL(0),PRIMARIES(1(brem),2(no brem),3(unscattered)),SEC(4):' ,T70,I
     *2/)
      IF ((IDAT .EQ. 1)) THEN
        INEXT=0
      ELSE
        INEXT=1
      END IF
      IF ((IRSTRT.EQ.4)) THEN
        IDAT=1
        ISTORE=0
      END IF
      DO 1851 J=1, 2001
        IPRTSP(J)=0
1851  CONTINUE
1852  CONTINUE
      IVAL = IVAL + 1
      NUM_HIST = IVAL
      VALUES_SOUGHT(IVAL)='NUMBER OF HISTORIES'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=100
      VALUE_MAX(IVAL)=4.611686e18
      DEFAULT(IVAL)=20000
      IVAL = IVAL + 1
      NUM_MXTIME = IVAL
      VALUES_SOUGHT(IVAL)='MAX CPU HOURS ALLOWED'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=1000
      DEFAULT(IVAL)=999.0
      DELIMETER='MONTE CARLO INPUTS'
      NMIN = NUM_HIST
      NMAX = NUM_MXTIME
      CALL GET_INPUT
      ival = ival + 1
      VALUES_SOUGHT(IVAL)='INITIAL RANDOM NO. SEEDS'
      nvalue(ival) = 2
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) = 30081
      default(ival) = 9373
      delimeter = 'MONTE CARLO INPUTS'
      nmin = ival
      nmax = ival
      call get_input
      IF (( error_flags(ival) .EQ. 0 )) THEN
        jrng1 = value(ival,1)
        jrng2 = value(ival,2)
      ELSE
        jrng1 = 0
        jrng2 = 0
      END IF
      IF((i_parallel .GT. 0))jrng2 = jrng2 - 1 + i_parallel
      ixx = jrng1
      jxx = jrng2
      call init_ranmar
      WRITE(6,1860)
1860  FORMAT(/,' *** INPUT CARD MC1 ***')
      NCASE=VALUE(NUM_HIST,1)
      TIMMAX=VALUE(NUM_MXTIME,1)
      IF ((IWATCH.EQ.0 .AND. NCASE.LT.10)) THEN
        NCASE=10
      END IF
      WRITE(6,1870)NCASE,jrng1,jrng2,TIMMAX
1870  FORMAT(/' # of histories:',T60,I12/ ' 1st initial random number se
     *ed: ',T60,I12/,' 2nd initial random number seed: ',T60,I12/, ' max
     *imum cpu time allowed:',T60,F10.2,'HRS'/)
      IF ((ERROR_FLAG.EQ.1)) THEN
        GOTO 1880
      END IF
      CALL GEOMRZ
      IF ((ERROR_FLAG.EQ.1)) THEN
        WRITE(15,*) '***********ERROR IN SUBROUTINE GEOMRZ************'
        GOTO 1880
      END IF
      IF ((IPRNTP.EQ.2)) THEN
        WRITE(6,1890)
1890    FORMAT(/'***** SPECTRUM OUTPUT IN LISTING FILE *****')
        DO 1901 IRL=2,NREG
          IPRTSP(IRL)=1
1901    CONTINUE
1902    CONTINUE
        DO 1911 J=1,NVALUE(NUM_STARTR)
          ILOW=VALUE(NUM_STARTR,J)
          IHIGH=VALUE(NUM_STOPR,J)
          IF ((ILOW.GT.NREG)) THEN
            ILOW=NREG
          END IF
          IF ((IHIGH.GT.NREG)) THEN
            IHIGH=NREG
          END IF
          IF ((ILOW.GT.IHIGH)) THEN
            IHIGH=ILOW
          END IF
          IF ((ILOW.EQ.IHIGH)) THEN
            WRITE(6,1920)ILOW
1920        FORMAT(' Print spectrum in region',I3)
            IPRTSP(ILOW) = 0
          ELSE
            DO 1931 IRL=ILOW,IHIGH
              IPRTSP(IRL)=0
1931        CONTINUE
1932        CONTINUE
            WRITE(6,1940)ILOW,IHIGH
1940        FORMAT(' Print spectra in regions',I4,' TO',I4)
          END IF
1911    CONTINUE
1912    CONTINUE
      END IF
      CALL SRCRZ
      IF ((ERROR_FLAG.EQ.1)) THEN
        WRITE(15,*) '***********ERROR IN SUBROUTINE SRCRZ************'
        GOTO 1880
      END IF
      CALL SRCINI (SVTMP1,SVTMP2,SVTMP3,SVTMP4,0)
      IF ((ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOURC.EQ.23)) THEN
        MONOEN=0
      ELSE
        CALL ENSRC
      END IF
      IF ((ERROR_FLAG.EQ.1)) THEN
        WRITE(15,*) '***********ERROR IN SUBROUTINE ENSRC************'
        GOTO 1880
      END IF
      call get_transport_parameter(6)
      ecutin = ecut(2)
      pcutin = pcut(2)
      smax = smaxir(2)
      IVAL = IVAL + 1
      NUM_SLOTE = IVAL
      VALUES_SOUGHT(IVAL)='SLOTE'
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=-10000.0
      VALUE_MAX(IVAL)=10000.0
      DEFAULT(IVAL)=1.25
      DELIMETER='I/O CONTROL'
      NMIN = NUM_SLOTE
      NMAX = NUM_SLOTE
      CALL GET_INPUT
      SLOTE=VALUE(NUM_SLOTE,1)
      IF ((SLOTE .GT. 0.)) THEN
1950    MAXIB=int(EIN/SLOTE+0.999)
        IF ((MAXIB .GT. 1000)) THEN
          WRITE(6,1960)SLOTE, EIN, MAXIB, 1000
1960      FORMAT(/' **************************************************'/
     *' For SLOTE =', F10.4,' MeV and maximum energy', F10.3,' MeV'/ ' o
     *ne needs', I5,' bins and the max available is',I5/ ' So increase b
     *in width by 2')
          SLOTE=2.*SLOTE
          GOTO 1950
        END IF
        WRITE(6,1970)MAXIB,SLOTE
1970    FORMAT(' ',I3,' energy bins of width',1PE10.3, ' MeV granted for
     * spectral outputs'/)
        DO 1981 IB=1,MAXIB
          BINTOP(IB) =SLOTE*dble(IB)
1981    CONTINUE
1982    CONTINUE
      ELSE IF((SLOTE .EQ. -999)) THEN
        LINBIN = int(float(1000)/10. + 0.5)
        DELLIN = (EIN - (ECUTIN-PRM))*0.10/dble(LINBIN)
        WRITE(6,1990)LINBIN,DELLIN
1990    FORMAT(/' ***SLOTE=-999***', I4,' BINS OF',F10.4,' MEV'/)
        MAXIB = 1000
        BINTOP(MAXIB) = EIN
        DO 2001 I=1,linbin
          BINTOP(MAXIB-I) = EIN-(dble(I)*DELLIN)
2001    CONTINUE
2002    CONTINUE
        RATIO=(BINTOP(MAXIB-LINBIN)/(ECUTIN-PRM))**(1./dble(MAXIB-LINBIN
     *  ))
        BINTOP(1) = (ECUTIN - PRM)*RATIO
        DO 2011 IB=2,MAXIB-LINBIN
          BINTOP(IB) = BINTOP(IB-1)*RATIO
2011    CONTINUE
2012    CONTINUE
        WRITE(6,2020)MAXIB,ECUTIN,(BINTOP(IB),IB=1,MAXIB)
2020    FORMAT(/I4,' SPR ENERGY ', 'BINS STARTING AT',F10.4,' MeV'/(3X,5
     *F12.4))
      ELSE IF((SLOTE .LT. 0.0)) THEN
        MAXIB = -SLOTE
        IF ((MAXIB .GT. 1000)) THEN
          MAXIB = 1000
          WRITE(6,2030)MAXIB
2030      FORMAT(/' ****NUMBER OF BINS', ' ASKED FOR REDUCED TO MAX OF '
     *, I4,' ****')
        END IF
        RATIO = (EIN /(ECUTIN-PRM))**(1./dble(MAXIB))
        BINTOP(1) = (ECUTIN-PRM)*RATIO
        DO 2041 IB=2,MAXIB-1
          BINTOP(IB) = RATIO * BINTOP(IB-1)
2041    CONTINUE
2042    CONTINUE
        BINTOP(MAXIB) = EIN
        WRITE(6,2050)MAXIB,ECUTIN,(BINTOP(IB),IB=1,MAXIB)
2050    FORMAT(/I4,' LOGARITHMIC ENERGY ', 'BINS STARTING AT',F10.4,' Me
     *V'/(3X,5F12.4))
      END IF
      IF ((SLOTE .EQ. 0.0)) THEN
        IVAL = IVAL + 1
        NUM_TOPEBIN = IVAL
        VALUES_SOUGHT(IVAL)='TOPS OF ENERGY BINS'
        NVALUE(IVAL)=0
        TYPE(IVAL)=1
        VALUE_MIN(IVAL)=1.e-20
        VALUE_MAX(IVAL)=100000.0
        DEFAULT(IVAL)=1.25
        NMIN = NUM_TOPEBIN
        NMAX = NUM_TOPEBIN
        CALL GET_INPUT
        MAXIB = NVALUE(NUM_TOPEBIN)
        DO 2061 J=1,NVALUE(NUM_TOPEBIN)
          BINTOP(J)=VALUE(NUM_TOPEBIN,J)
2061    CONTINUE
2062    CONTINUE
        GAP = (BINTOP( NVALUE(NUM_TOPEBIN) ) - EIN)/EIN
        IF (( GAP .LT. 0.0 .AND. GAP .GT.-0.1)) THEN
          BINTOP(NVALUE(NUM_TOPEBIN)) = EIN
          WRITE(6,2070)EIN
2070      FORMAT(T30,'TOP BIN ADJUSTED TO COVER:', F10.1)
        ELSE IF((GAP .LT. -0.1)) THEN
          WRITE(6,2080)
2080      FORMAT(//' *******MAXIMUM ENERGY BIN IS LESS THAN 90%', ' OF M
     *AXIMUM INPUT ENERGY -ASSUMED INTENTIONAL*****'//)
        END IF
        WRITE(6,2090)NVALUE(NUM_TOPEBIN),(BINTOP(J),J=1,NVALUE(NUM_TOPEB
     *  IN))
2090    FORMAT(/' Read a total of',I4,' energy bin tops'/ (5F15.4))
      END IF
      WRITE(6,2100)
2100  FORMAT(' ')
      IVAL = IVAL + 1
      NUM_BREMSPLIT = IVAL
      VALUES_SOUGHT(IVAL)='BREM SPLITTING'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='OFF'
      ALLOWED_INPUTS(IVAL,1)='ON'
      IVAL = IVAL + 1
      NUM_BREMPEVEN = IVAL
      VALUES_SOUGHT(IVAL)='NUMBER OF BREMS PER EVENT'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=200
      DEFAULT(IVAL)=200
      IVAL = IVAL + 1
      NUM_I_PLAY_RR = IVAL
      VALUES_SOUGHT(IVAL)='CHARGED PARTICLE RUSSIAN ROULETTE'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='OFF'
      ALLOWED_INPUTS(IVAL,1)='ON'
      IVAL = IVAL + 1
      NUM_IREJCT = IVAL
      VALUES_SOUGHT(IVAL)='ELECTRON RANGE REJECTION'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='OFF'
      ALLOWED_INPUTS(IVAL,1)='ON'
      IVAL=IVAL+1
      NUM_ESAVEIN=IVAL
      VALUES_SOUGHT(IVAL)='ESAVEIN'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=0.
      VALUE_MAX(IVAL)=EIN+PRM
      DEFAULT(IVAL)=EIN+PRM
      DELIMETER='VARIANCE REDUCTION'
      NMIN = NUM_BREMSPLIT
      NMAX = NUM_ESAVEIN
      CALL GET_INPUT
      IBRSPL=VALUE(NUM_BREMSPLIT,1)
      nbr_split =VALUE(NUM_BREMPEVEN,1)
      IF ((IBRSPL .EQ. 1)) THEN
        IF(((nbr_split .LE. 0) .OR. (nbr_split .GT. 200)))nbr_split =200
      ELSE
        nbr_split = 1
      END IF
      I_PLAY_RR=VALUE(NUM_I_PLAY_RR,1)
      IF ((I_PLAY_RR .EQ. 1)) THEN
        PROB_RR=1./dble(nbr_split)
      ELSE
        PROB_RR=1.
      END IF
      IREJCT=VALUE(NUM_IREJCT,1)
      ESAVEIN=VALUE(NUM_ESAVEIN,1)
      WRITE(6,2110)IBRSPL,nbr_split,I_PLAY_RR,PROB_RR,IREJCT,ESAVEIN
2110  FORMAT(/ ' Bremsstrahlung splitting OFF(0) or ON(1):' ,T60,I12/ 'E
     *ach bremsstrahlung split into:' ,T60,I12// ' Charged particle Russ
     *ian Roulette OFF(0) or ON(1):' ,T60,I12/ ' Probability of survival
     *:' ,T60,F10.4// ' Without(0) or with(1) range rejection:' ,T60,I12
     */ ' ESAVE cutoff value for range rejection with dnear:' ,T60,F10.4
     *,' MeV'/)
      IVAL = IVAL + 1
      NUM_FORCE = IVAL
      VALUES_SOUGHT(IVAL)='PHOTON FORCING'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      DEFAULT(IVAL)=0
      ALLOWED_INPUTS(IVAL,0)='OFF'
      ALLOWED_INPUTS(IVAL,1)='ON'
      IVAL = IVAL + 1
      NUM_STRTFRC = IVAL
      VALUES_SOUGHT(IVAL)='START FORCING'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=NREG
      DEFAULT(IVAL)=1
      IVAL = IVAL + 1
      NUM_STPFRC = IVAL
      VALUES_SOUGHT(IVAL)='STOP FORCING AFTER'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(NUM_STPFRC)=0
      VALUE_MAX(NUM_STPFRC)=NREG+1
      DEFAULT(NUM_STPFRC)=1
      DELIMETER='VARIANCE REDUCTION'
      NMIN = NUM_FORCE
      NMAX = NUM_STPFRC
      CALL GET_INPUT
      WRITE(6,2120)
2120  FORMAT(' *** INPUT CARD TC3 ***')
      IFORCE=VALUE(NUM_FORCE,1)
      NFMIN=VALUE(NUM_STRTFRC,1)
      NFMAX=VALUE(NUM_STPFRC,1)
      IF ((IFORCE .EQ. 0)) THEN
        NFMIN=0
        NFMAX=0
        WRITE(6,2130)
2130    FORMAT(/' NO INTERACTION FORCING IS IN EFFECT'/)
      ELSE
        IF((NFMAX .LT. NFMIN))NFMAX=NFMIN
        WRITE(6,2140)NFMIN,NFMAX
2140    FORMAT(/' FORCED PHOTON INTERACTIONS IN EFFECT FROM',I3,' TO',I3
     *, ' # INTERACTIONS'/)
      END IF
      WRITE(6,2150)
2150  FORMAT(' ')
      CALL PLOTSN
      IF ((ERROR_FLAG.EQ.1)) THEN
        GOTO 1880
      END IF
      IF ((IPRIM .EQ. 0)) THEN
        ITMAX=1
      ELSE
        ITMAX=2
      END IF
      NCASEO=0
      NCASET=0
      IF ((IRSTRT .EQ. 0 .OR. IRSTRT .EQ. 5)) THEN
        NNREAD=0
        PIISTP=0.
        SCSTP=0.
        SCSTP2=0.
        SCSTP_LAST=0
        DO 2161 IX=1,NR
          DO 2171 IZ=1,NZ
            DO 2181 IT=1,ITMAX
              DO 2191 IQL=1,3
                DO 2201 IB=1,MAXIB
                  SCFLU(IB,IZ,IX,IQL,IT)=0.
                  SCFLU2(IB,IZ,IX,IQL,IT)=0.
                  SCFLU_LAST(IB,IZ,IX,IQL,IT)=0
2201            CONTINUE
2202            CONTINUE
                SCEAVE(IZ,IX,IQL,IT)=0.
                SCEAVE2(IZ,IX,IQL,IT)=0.
                SCEAVE_COV(IZ,IX,IQL,IT)=0.
                SCTFLU(IZ,IX,IQL,IT)=0.
                SCTFLU2(IZ,IX,IQL,IT)=0.
                SCTFLU_LAST(IZ,IX,IQL,IT)=0
2191          CONTINUE
2192          CONTINUE
              DO 2211 IB=1,MAXIB
                SCFLEP(IB,IZ,IX,IT)=0.
                SCFLEP2(IB,IZ,IX,IT)=0.
                SCFLEP_LAST(IB,IZ,IX,IT)=0
2211          CONTINUE
2212          CONTINUE
              SCELEP(IZ,IX,IT)=0.
              SCELEP2(IZ,IX,IT)=0.
              SCELEP_COV(IZ,IX,IT)=0.
              SCTLEP(IZ,IX,IT)=0.
              SCTLEP2(IZ,IX,IT)=0.
              SCTLEP_LAST(IZ,IX,IT)=0
2181        CONTINUE
2182        CONTINUE
2171      CONTINUE
2172      CONTINUE
2161    CONTINUE
2162    CONTINUE
      ELSE IF((IRSTRT .NE. 4)) THEN
        WRITE(6,2220)
2220    FORMAT(/'   START READING OLD DATA FILE')
        my_unit = egs_open_datfile(4,0,1,'.egsdat')
        READ(my_unit,*,END=2230) SCSTP,SCSTP2
        DO 2241 IX=1,NR
          DO 2251 IZ=1,NZ
            DO 2261 IT=1,ITMAX
              DO 2271 IQL=1,3
                DO 2281 IB=1,MAXIB
                  READ(my_unit,*)SCFLU(IB,IZ,IX,IQL,IT), SCFLU2(IB,IZ,IX
     *            ,IQL,IT)
2281            CONTINUE
2282            CONTINUE
                READ(my_unit,*)SCEAVE(IZ,IX,IQL,IT),SCEAVE2(IZ,IX,IQL,IT
     *          ), SCEAVE_COV(IZ,IX,IQL,IT),SCTFLU(IZ,IX,IQL,IT), SCTFLU
     *          2(IZ,IX,IQL,IT)
2271          CONTINUE
2272          CONTINUE
              DO 2291 IB=1,MAXIB
                READ(my_unit,*)SCFLEP(IB,IZ,IX,IT),SCFLEP2(IB,IZ,IX,IT)
2291          CONTINUE
2292          CONTINUE
              READ(my_unit,*)SCELEP(IZ,IX,IT),SCELEP2(IZ,IX,IT), SCELEP_
     *        COV(IZ,IX,IT),SCTLEP(IZ,IX,IT), SCTLEP2(IZ,IX,IT)
2261        CONTINUE
2262        CONTINUE
2251      CONTINUE
2252      CONTINUE
2241    CONTINUE
2242    CONTINUE
        read(my_unit,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
     *  rng_array
        twom24 = 1./16777216.
        READ(my_unit,*,END=2230) NCASEO,TMCPUO,NNREAD,PIISTP
        CLOSE(UNIT=my_unit)
      END IF
      IF ((IRSTRT .EQ. 3)) THEN
        NCASE=0
      END IF
      NCASET=NCASE+NCASEO
1880  CONTINUE
      IF ((ERROR_FLAG .EQ. 0)) THEN
        WRITE(6,2300)
2300    FORMAT(/' ********* SUCCESSFUL INPUT ACCOMPLISHED *********')
        WRITE (15,*) ' '
        WRITE (15,*) ' '
        WRITE (15,*) ' *************************************************
     *'
        WRITE (15,*) ' ********* SUCCESSFUL INPUT ACCOMPLISHED *********
     *'
        WRITE (15,*) ' *************************************************
     *'
        WRITE (15,*) ' '
        WRITE (15,*) ' '
        DO 2311 J=1,5
          WRITE(6,2320)
2320      FORMAT(' ')
2311    CONTINUE
2312    CONTINUE
        RETURN
      END IF
      IF ((ERROR_FLAG.EQ.1)) THEN
        WRITE(15,*) ' '
        WRITE(15,*) ' '
        WRITE(15,*) '************************************************'
        WRITE(15,*) '********UNSUCCESSFUL INPUTS ACCOMPLISHED********'
        WRITE(15,*) '************************************************'
        WRITE(15,*) ' '
        WRITE(15,*) ' '
        WRITE(6,2330)
2330    FORMAT(/' FLURZnrc input file is not correct! - look for error m
     *essage')
        RETURN
      END IF
2340  CONTINUE
      WRITE(6,2350)
2350  FORMAT(/' END OF USER DATA FILE READ BEFORE DAT FILE IN')
      ERROR_FLAG=1
      RETURN
2230  CONTINUE
      WRITE(6,2360)
2360  FORMAT(' UNEXPECTED EOF ON SAVED DATA FILE- TAKE CARE OF PRESTA IN
     *PUT')
      ERROR_FLAG=1
      RETURN
2370  WRITE(6,2380)
2380  FORMAT(' Error trying to open the egsdat file: Is it there?'//)
      ERROR_FLAG=1
      RETURN
      END
      SUBROUTINE ISUMRY
      implicit none
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      common/ET_control/ smaxir( 2001),estepe,ximax,  skindepth_for_bca,
     *transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      COMMON/GEOM/ZPLANE( 501),RCYL(0:4), CYRAD2(4),NTRACK( 2001),NZ,NR,
     *NREG,NPLANE
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NTRACK,NZ,NR,NREG,NPLANE
      CHARACTER*1 TITLE(80)
      COMMON/IODAT1/TITLE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET,TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
     *, IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP( 2001),IVAL,DATCOUNT
      real*8 TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
      integer*4 IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP,IVAL,DATCOUN
     *T
      integer*8 NCASE,NCASEO,NCASET
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/SCORE/ SCFLU(1000, 501,4,3,2), SCFLU2(1000, 501,4,3,2), SCE
     *AVE( 501,4,3,2), SCEAVE2( 501,4,3,2), SCEAVE_COV( 501,4,3,2),SCSTP
     *,SCSTP2,PIISTP, SCELEP( 501,4,2), SCELEP2( 501,4,2), SCELEP_COV( 5
     *01,4,2), SCFLEP(1000, 501,4,2), SCFLEP2(1000, 501,4,2), SCTFLU( 50
     *1,4,3,2), SCTFLU2( 501,4,3,2), SCTLEP( 501,4,2), SCTLEP2( 501,4,2)
     *, SCSTP_LAST,SCFLU_LAST(1000, 501,4,3,2), SCFLEP_LAST(1000, 501,4,
     *2), SCTFLU_LAST( 501,4,3,2), SCTLEP_LAST( 501,4,2), IHSTRY,SCFLU_T
     *MP(1000, 501,4,3,2), SCEAVE_TMP( 501,4,3,2), SCSTP_TMP,SCELEP_TMP(
     * 501,4,2), SCFLEP_TMP(1000, 501,4,2), SCTFLU_TMP( 501,4,3,2), SCTL
     *EP_TMP( 501,4,2), BINTOP(1000),SLOTE,ECUTMX,PCUTMX,EBINW(1000,3),
     *VOLUME(500,4),MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      REAL*8 SCFLU,SCFLU2,SCEAVE,SCEAVE2,SCEAVE_COV,SCSTP,SCSTP2, SCELEP
     *,SCELEP2,SCELEP_COV,SCFLEP,SCFLEP2,SCTFLU,SCTFLU2,SCTLEP, SCTLEP2,
     *PIISTP
      integer*8 SCSTP_LAST,SCFLU_LAST,SCFLEP_LAST,SCTFLU_LAST,SCTLEP_LAS
     *T,IHSTRY
      real*8 SCFLU_TMP,SCEAVE_TMP,SCSTP_TMP,SCELEP_TMP,SCFLEP_TMP, SCTFL
     *U_TMP,SCTLEP_TMP,BINTOP,SLOTE, ECUTMX,PCUTMX,EBINW,VOLUME
      integer*4 MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(4,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBEAM
     *,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DI
     *STZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PRO
     *BSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,ZS
     *OFST,                                                      SVTMP1,
     *SVTMP2,SVTMP3,SVTMP4,
     *       RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                     XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,WEI
     *GHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/SPECTR/ CDFINV(1000,2),ENSRCD(0:500),SRCPDF(500),SRCCDF(500
     *), NENSRC
      real*8 CDFINV,ENSRCD,SRCPDF,SRCCDF
      integer*4 NENSRC
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERVR/ CEXPTR,GWAIT(150),DUMU,NP_INC(150),MAFORC,IFORCE,NF
     *MIN,NFMAX,NFTIME, ISOURC,IFPB,IQINC,MONOEN,IRODUM,IRNDUM,MEDDUM,ID
     *UM,MEDTMP, PATHL,DELTAP,GWTOLD,EPSLON,ARG
      real*8 CEXPTR,GWAIT,DUMU,PATHL,DELTAP,GWTOLD,EPSLON,ARG
      integer*4 NP_INC,MAFORC,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQIN
     *C, MONOEN,IRODUM,IRNDUM,MEDDUM,IDUM,MEDTMP
      COMMON/USERRR/
     *              CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,
     *                            EKETST,ELKETS,ZL,RL,CDIST,IGEOM,IRANGE
     *,MINZ,MAXZ,MINR,MAXR,IREJCT
      real*8 CRANGE,ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,EKETST,ELKETS
     *,ZL,RL,CDIST
      integer*4 MINZ,MAXZ,MINR,MAXR
      integer*4 IREJCT,IRANGE,IGEOM
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      integer*4 IOUT,J,MXREG,I
      real*8 SMAX,EK0
      CHARACTER*4 CDSTBL( 2001),CTRTBL( 2001),CABSRB( 2001)
      IOUT=1
      WRITE (IOUT, *) '\f'
      write(iout,100) title
      call egs_fdate(iout)
      write(iout,'(T80,"*"/1X,79("*"))')
100   FORMAT(' ',80A1,/1X,79('*')/ ' *',T80, '*'/ ' *',T80, '*'/ ' *',T3
     *4,'************',T80,'*'/ ' *',T34,'*          *',T80,'*'/ ' *',T3
     *4,'* FLURZnrc *',T80,'*'/ ' *',T34,'*          *',T80,'*'/ ' *',T3
     *4,'************',T80,'*'/ ' *',T80, '*'/ ' *            Cylindrica
     *l-geometry fluence-scoring EGSnrc user-code ', T80,'*'/ ' *',T80,'
     **'/ ' *   FLURZnrc was developed by the National Research Council 
     *of Canada', T80,'*'/ ' *',T80, '*'/ ' *     It uses the EGSnrc Cod
     *e System developed at NRC ',T80,'*'/ ' *     (based on the EGS4 Co
     *de System Carlo developed by SLAC and NRC)', T80,'*'/ ' *     runn
     *ing on ','linux',' ',T80,'*'/ ' *',T80, '*'/ ' *', T56,$)
      call show_transport_parameter(iout)
      WRITE(IOUT,200) NCASE,NCASET,IQIN
      IF ((MONOEN .EQ. 0 .AND. (ISOURC.LT.21 .OR. ISOURC.GT.23))) THEN
        WRITE (IOUT,201) EIN
      ELSE IF((MONOEN.EQ.1)) THEN
        CALL ENSRCO
      ELSE IF((ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOURC.EQ.23)) THEN
        WRITE (IOUT,202) EIN
      END IF
      IF ((ESTEPE .EQ. 0.0)) THEN
        WRITE(IOUT,210)
      ELSE
        WRITE(IOUT,211)ESTEPE
      END IF
      WRITE(IOUT,220) SMAX,ECUTIN,PCUTIN
      IF ((IFORCE .NE. 0)) THEN
        WRITE(IOUT,230)NFMIN,NFMAX
      ELSE
        WRITE(IOUT,231)
      END IF
      IF ((IPRIM.EQ.0)) THEN
        WRITE(IOUT,235)
      ELSE
        WRITE(IOUT,236) IPRIM
      END IF
      IF ((IREJCT .EQ. 1)) THEN
        WRITE(IOUT,242)
        WRITE(IOUT,250) ECUTIN-RM,ERANGE,(CRANGE(J,1),J=1,2),ERANGE,EIN,
     *  (CRANGE(J,2),J=1,2)
        WRITE(IOUT,255) MINZ,MAXZ,MINR,MAXR
      ELSE
        WRITE(IOUT,243)
      END IF
      MXREG= 2001
      WRITE(IOUT,260) TIMMAX
      write(iout,'(21x,a,$)') 'Initial RNG state:           '
      write(iout,'(a,2i4,$)') ' ixx jxx = ',ixx,jxx
      write(iout,*)
      DO 2391 I=1,NREG
        IF ((IRAYLR(I).EQ.1)) THEN
          WRITE(IOUT,270)
          GO TO2392
        END IF
        IF ((I.EQ.NREG)) THEN
          WRITE(IOUT,275)
        END IF
2391  CONTINUE
2392  CONTINUE
      IF ((IBRDST .EQ. 0)) THEN
        WRITE(IOUT,277)
      ELSE
        WRITE(IOUT,278)
      END IF
      IF ((IBRSPL .EQ. 0)) THEN
        WRITE(IOUT,279)
      ELSE
        WRITE(IOUT,281) nbr_split
      END IF
      IF ((I_PLAY_RR .EQ. 0)) THEN
        WRITE(IOUT,314)
      ELSE
        WRITE(IOUT,315) PROB_RR
      END IF
      IF ((NESTEP .EQ. 0)) THEN
        WRITE(IOUT,282)
      ELSE IF((NESTEP .EQ. NREG)) THEN
        WRITE(IOUT,283)
      ELSE
        WRITE(IOUT,284)NESTEP
      END IF
      IF ((NSMAX .EQ. 0)) THEN
        WRITE(IOUT,285)
      ELSE IF((NSMAX .EQ. NREG)) THEN
        WRITE(IOUT,286)
      ELSE
        WRITE(IOUT,287)NSMAX
      END IF
      EK0=EIN
      WRITE(IOUT,300) NMED
      DO 2401 I=1,NMED
        WRITE(IOUT,310) I,(MEDIA(J,I),J=1,18),RHO(I),AE(I),AP(I)
2401  CONTINUE
2402  CONTINUE
      CALL GEOMRZ_ISUMRY(IOUT)
      CALL SRCOUT
      CDSTBL(1)='0'
      CTRTBL(1)='0'
      CABSRB(1)='0'
      CALL MATERIALGRID(NR, NZ, VOLUME, 2, ECUT, PCUT, RCYL, ZPLANE, MED
     *, MEDIA, CDSTBL, CTRTBL, CABSRB)
200   FORMAT(/' ',79('*')//,T20,'MONTE CARLO TRANSPORT  AND SCATTER CONT
     *ROLS'//' ',79('-')//' ',T20,'Max # of histories to run',T53,I12/' 
     *',T20,'Max # of histories to analyze',T53,I12/' ',T20,'Incident ch
     *arge',T63,I2)
201   FORMAT(' ',T20,'Incident kinetic energy',T57,F9.3,' (MeV)')
202   FORMAT(' ',T20,'Max. incident kinetic energy',T57,F9.3,' (MeV)')
210   FORMAT(' ',T20,'Fractional electron energy/step',T60,'default')
211   FORMAT(' ',T20,'Fractional electron energy/step',T60,F5.3)
220   FORMAT(' ',T20,'Maximum global electron step size',T60,1PE10.3,' (
     *cm)'/' ',T20,'Global electron transport cut-off',T56,0PF9.4,' (MeV
     *)'/' ',T20,'Global photon transport cut-off',T56,F9.4,' (MeV)')
230   FORMAT(' ',T20,'Min/max photon step forced',T60,I6,'/',I6)
235   FORMAT(T20,'Total fluence only scored')
236   FORMAT(T20,'Score secondary fluence, IPRIM=',I2)
231   FORMAT(' ',T20,'Photon interaction forcing switch',T60,'Off')
242   FORMAT(' ',T20,'Range rejection switch',T60,'On')
243   FORMAT(' ',T20,'Range rejection switch',T60,'Off')
250   FORMAT(' ',T20,'Range rejection parameters:'/' ',T20,F9.3,' (MeV) 
     *TO ',F9.3,' (MeV)',T59,E14.7,'/',E14.7/' ',T20,F9.3,' (MeV) TO ',F
     *9.3,' (MeV)',T59,E14.7,'/',E14.7)
255   FORMAT(T20,'DISCARDS e- EXTERIOR TO PLANES',T58,I3,' and',I3/' ',T
     *30,'AND CYLINDERS',T58,I3,' and',I3)
260   FORMAT(' ',T20,'MAXIMUM CPUTIME ALLOWED',T59,F5.2,' (hrs)'/' ',T20
     *,'Initial RNG seeds: ',5x,$)
270   FORMAT(T20,'Rayleigh(coherent) scattering included')
275   FORMAT(T20,'Rayleigh scattering not included')
277   FORMAT(T20,'EGS4 default bremsstrahlung angular sampling')
278   FORMAT(T20,'Koch and Motz bremsstrahlung angular sampling')
279   FORMAT(T20,'Bremsstrahlung splitting',T60,'OFF')
281   FORMAT(T20,'Bremsstrahlung splitting',T60,'ON'/T20,'Initially, eac
     *h bremsstrahlung photon split into ',I4,' photons')
282   FORMAT(' ',T20,'# ZONES ELEC ENERGY LOSS/STEP ALTERED',T60,'NONE')
283   FORMAT(' ',T20,'# ZONES ELEC ENERGY LOSS/STEP ALTERED',T60,'ALL')
284   FORMAT(' ',T20,'# ZONES ELEC ENERGY LOSS/STEP ALTERED',T60,I2)
285   FORMAT(' ',T20,'# ZONES MAX ELEC STEP SIZE ALTERED',T60,'NONE')
286   FORMAT(' ',T20,'# ZONES MAX ELEC STEP SIZE ALTERED',T60,'ALL')
287   FORMAT(' ',T20,'# ZONES MAX ELEC STEP SIZE ALTERED',T60,I2)
300   FORMAT(/' ',79('*')//' ',T20,'Material summary:   ',I2,' material(
     *s) used'//' ',79('-')//' ',4X,'#',7X,'Material',20X,'density(g/cm*
     **3)',3X,'AE(MeV)',4X,'AP(MeV)'/)
305   FORMAT(T22,'REGION(',I4,') HAS FLUORESCENT X-RAYS FOR Z=',I3)
306   FORMAT(T20,'REGIONS WITH FLUORESCENT X-RAYS FOLLOW: ')
307   FORMAT(T20,'FLUORESCENT X-RAYS ARE DISCARDED')
310   FORMAT(' ',4X,I1,8X,18A1,11X,1PE10.3,5X,0PF9.3,2X,F9.3)
314   FORMAT(T20,'Charged particle Russian Roulette',T60,'OFF')
315   FORMAT(T20,'Charged particle Russian Roulette',T60,'ON'/T20,'With 
     *probability of survival =',T60,F9.3)
      RETURN
      END
      SUBROUTINE OSUMRY
      implicit none
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/GEOM/ZPLANE( 501),RCYL(0:4), CYRAD2(4),NTRACK( 2001),NZ,NR,
     *NREG,NPLANE
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NTRACK,NZ,NR,NREG,NPLANE
      CHARACTER*1 TITLE(80)
      COMMON/IODAT1/TITLE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET,TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
     *, IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP( 2001),IVAL,DATCOUNT
      real*8 TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
      integer*4 IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP,IVAL,DATCOUN
     *T
      integer*8 NCASE,NCASEO,NCASET
      COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE
      integer*4 ICHPIN,ILPIN,IOUT,IPAGE
      COMMON/PLOTC/IPLOT( 2001),IPLOTR(4),IPLOTZ( 501), IPLTIQ(4),IPLTTP
     *(2),IPLT ,IPLTPL,IPLPHB
      integer*4 IPLOT,IPLOTR,IPLOTZ,IPLTIQ,IPLTTP,IPLT,IPLTPL,IPLPHB
      COMMON/SCORE/ SCFLU(1000, 501,4,3,2), SCFLU2(1000, 501,4,3,2), SCE
     *AVE( 501,4,3,2), SCEAVE2( 501,4,3,2), SCEAVE_COV( 501,4,3,2),SCSTP
     *,SCSTP2,PIISTP, SCELEP( 501,4,2), SCELEP2( 501,4,2), SCELEP_COV( 5
     *01,4,2), SCFLEP(1000, 501,4,2), SCFLEP2(1000, 501,4,2), SCTFLU( 50
     *1,4,3,2), SCTFLU2( 501,4,3,2), SCTLEP( 501,4,2), SCTLEP2( 501,4,2)
     *, SCSTP_LAST,SCFLU_LAST(1000, 501,4,3,2), SCFLEP_LAST(1000, 501,4,
     *2), SCTFLU_LAST( 501,4,3,2), SCTLEP_LAST( 501,4,2), IHSTRY,SCFLU_T
     *MP(1000, 501,4,3,2), SCEAVE_TMP( 501,4,3,2), SCSTP_TMP,SCELEP_TMP(
     * 501,4,2), SCFLEP_TMP(1000, 501,4,2), SCTFLU_TMP( 501,4,3,2), SCTL
     *EP_TMP( 501,4,2), BINTOP(1000),SLOTE,ECUTMX,PCUTMX,EBINW(1000,3),
     *VOLUME(500,4),MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      REAL*8 SCFLU,SCFLU2,SCEAVE,SCEAVE2,SCEAVE_COV,SCSTP,SCSTP2, SCELEP
     *,SCELEP2,SCELEP_COV,SCFLEP,SCFLEP2,SCTFLU,SCTFLU2,SCTLEP, SCTLEP2,
     *PIISTP
      integer*8 SCSTP_LAST,SCFLU_LAST,SCFLEP_LAST,SCTFLU_LAST,SCTLEP_LAS
     *T,IHSTRY
      real*8 SCFLU_TMP,SCEAVE_TMP,SCSTP_TMP,SCELEP_TMP,SCFLEP_TMP, SCTFL
     *U_TMP,SCTLEP_TMP,BINTOP,SLOTE, ECUTMX,PCUTMX,EBINW,VOLUME
      integer*4 MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(4,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBEAM
     *,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DI
     *STZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PRO
     *BSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,ZS
     *OFST,                                                      SVTMP1,
     *SVTMP2,SVTMP3,SVTMP4,
     *       RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                     XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,WEI
     *GHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/USERVR/ CEXPTR,GWAIT(150),DUMU,NP_INC(150),MAFORC,IFORCE,NF
     *MIN,NFMAX,NFTIME, ISOURC,IFPB,IQINC,MONOEN,IRODUM,IRNDUM,MEDDUM,ID
     *UM,MEDTMP, PATHL,DELTAP,GWTOLD,EPSLON,ARG
      real*8 CEXPTR,GWAIT,DUMU,PATHL,DELTAP,GWTOLD,EPSLON,ARG
      integer*4 NP_INC,MAFORC,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQIN
     *C, MONOEN,IRODUM,IRNDUM,MEDDUM,IDUM,MEDTMP
      COMMON/USERRR/
     *              CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,
     *                            EKETST,ELKETS,ZL,RL,CDIST,IGEOM,IRANGE
     *,MINZ,MAXZ,MINR,MAXR,IREJCT
      real*8 CRANGE,ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,EKETST,ELKETS
     *,ZL,RL,CDIST
      integer*4 MINZ,MAXZ,MINR,MAXR
      integer*4 IREJCT,IRANGE,IGEOM
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      integer*8 IMS
      integer*4 IX,IZ,IQL,IPRIM1,NPERPG,IPERPG,IP,ILINE,IB
      real*8 ZLOW,ZHIGH,RLOW,ETOP
      INTEGER NCOMP
      real*8 RESULTS(500, 4, 12), UNCRTY(500, 4, 12), RADIAL_BINS(4),DEP
     *TH_BINS( 501)
      CHARACTER*60 EXPLANATIONS(12)
      CHARACTER*4 LABELS(12)
      IF ((IBRSPL .EQ. 1)) THEN
        WRITE(IOUT,90) nbr_split
      END IF
      IF ((ISOURC.EQ.21.OR.ISOURC.EQ.22)) THEN
        WRITE(IOUT,1001) SCSTP,SCSTP2, SCSTP/(dble(NNREAD+NRCYCL*(NNREAD
     *  -IHSTRY))/dble(NCASE_PHSP)*NINCSRC),SCSTP2, (count_pII_steps+PII
     *  STP)/SCSTP,SCSTP2
      ELSE
        WRITE(IOUT,1001) SCSTP,SCSTP2,SCSTP/dble(IHSTRY),SCSTP2, (count_
     *  pII_steps+PIISTP)/SCSTP,SCSTP2
      END IF
      IF ((NREG .GT. 2)) THEN
        DO 2411 IX=1,NR
          DO 2421 IZ=1,NZ
            RESULTS(IZ,IX,1)=SCTFLU(IZ,IX,1,1)
            RESULTS(IZ,IX,2)=SCEAVE(IZ,IX,1,1)
            RESULTS(IZ,IX,3)=SCTFLU(IZ,IX,2,1)
            RESULTS(IZ,IX,4)=SCEAVE(IZ,IX,2,1)
            RESULTS(IZ,IX,5)=SCTFLU(IZ,IX,3,1)
            RESULTS(IZ,IX,6)=SCEAVE(IZ,IX,3,1)
            RESULTS(IZ,IX,7)=SCTFLU(IZ,IX,1,2)
            RESULTS(IZ,IX,8)=SCEAVE(IZ,IX,1,2)
            RESULTS(IZ,IX,9)=SCTFLU(IZ,IX,2,2)
            RESULTS(IZ,IX,10)=SCEAVE(IZ,IX,2,2)
            RESULTS(IZ,IX,11)=SCTFLU(IZ,IX,3,2)
            RESULTS(IZ,IX,12)=SCEAVE(IZ,IX,3,2)
            UNCRTY(IZ,IX,1)=SCTFLU2(IZ,IX,1,1)
            UNCRTY(IZ,IX,2)=SCEAVE2(IZ,IX,1,1)
            UNCRTY(IZ,IX,3)=SCTFLU2(IZ,IX,2,1)
            UNCRTY(IZ,IX,4)=SCEAVE2(IZ,IX,2,1)
            UNCRTY(IZ,IX,5)=SCTFLU2(IZ,IX,3,1)
            UNCRTY(IZ,IX,6)=SCEAVE2(IZ,IX,3,1)
            UNCRTY(IZ,IX,7)=SCTFLU2(IZ,IX,1,2)
            UNCRTY(IZ,IX,8)=SCEAVE2(IZ,IX,1,2)
            UNCRTY(IZ,IX,9)=SCTFLU2(IZ,IX,2,2)
            UNCRTY(IZ,IX,10)=SCEAVE2(IZ,IX,2,2)
            UNCRTY(IZ,IX,11)=SCTFLU2(IZ,IX,3,2)
            UNCRTY(IZ,IX,12)=SCEAVE2(IZ,IX,3,2)
2421      CONTINUE
2422      CONTINUE
2411    CONTINUE
2412    CONTINUE
        IF ((IPRIM .NE. 0)) THEN
          NCOMP = 12
        ELSE
          NCOMP = 6
        END IF
        DO 2431 IX=1,NR+1
          RADIAL_BINS(IX)=RCYL(IX-1)
2431    CONTINUE
2432    CONTINUE
        DO 2441 IZ=1,NZ+1
          DEPTH_BINS(IZ)=ZPLANE(IZ)
2441    CONTINUE
2442    CONTINUE
        IF (((ISOURC .NE.3).AND.(ISOURC .NE.21).AND.(ISOURC .NE.22).AND.
     *  (ISOURC .NE.23))) THEN
          EXPLANATIONS(1)='total electron fluence/incident fluence(incl.
     * secondaries)'
          EXPLANATIONS(3)='total photon fluence/incident fluence(incl. s
     *econdaries)'
          EXPLANATIONS(5)='total positron fluence/incident fluence(incl.
     * secondaries)'
        ELSE
          EXPLANATIONS(1)='total electron fluence/source particle(incl.
     *secondaries)'
          EXPLANATIONS(3)='total photon fluence/source particle(incl. se
     *condaries)'
          EXPLANATIONS(5)='total positron fluence/source particle(incl.
     *secondaries)'
        END IF
        EXPLANATIONS(2)='average total electron energy'
        EXPLANATIONS(4)='average total photon energy'
        EXPLANATIONS(6)='average total positron energy'
        LABELS(1)='Te-:'
        LABELS(2)='E1 :'
        LABELS(3)='Tph:'
        LABELS(4)='E2 :'
        LABELS(5)='Te+:'
        LABELS(6)='E3 :'
        IF ((IPRIM .NE.4)) THEN
          EXPLANATIONS(7)='primary electron fluence'
          EXPLANATIONS(8)='average primary electron energy'
          EXPLANATIONS(9)='primary photon fluence'
          EXPLANATIONS(10)='average primary photon energy'
          EXPLANATIONS(11)='primary positron fluence'
          EXPLANATIONS(12)='average primary positron energy'
          LABELS(7)='Pe-:'
          LABELS(8)='E4 :'
          LABELS(9)='Pph:'
          LABELS(10)='E5 :'
          LABELS(11)='Pe+:'
          LABELS(12)='E6 :'
        ELSE
          EXPLANATIONS(7)='secondary electron fluence'
          EXPLANATIONS(8)='average secondary electron energy'
          EXPLANATIONS(9)='secondary photon fluence'
          EXPLANATIONS(10)='average secondary photon energy'
          EXPLANATIONS(11)='secondary positron fluence'
          EXPLANATIONS(12)='average secondary positron energy'
          LABELS(7)='Se-:'
          LABELS(8)='E4 :'
          LABELS(9)='Sph:'
          LABELS(10)='E5 :'
          LABELS(11)='Se+:'
          LABELS(12)='E6 :'
        END IF
        CALL ZONEGRID(NR, NZ, 0, 1, NZ, RESULTS, UNCRTY, NCOMP, RADIAL_B
     *  INS, DEPTH_BINS, LABELS, EXPLANATIONS)
      END IF
      IF ((IPRNTP .EQ. 0 .OR. IPRNTP .EQ. 2)) THEN
        write(iout,'(''\f'')')
        IF ((IPRIM .EQ. 0)) THEN
          IPRIM1=1
        ELSE
          IPRIM1 = 2
        END IF
        NPERPG = MAX(1, 66/(MAXIB+15))
        IPERPG=-1
        DO 2451 IP=1,IPRIM1
          write(iout,205) title
          call egs_fdate(iout)
          write(iout,*)
          DO 2461 IZ=1,NZ
            ZLOW=ZPLANE(IZ)
            ZHIGH=ZPLANE(IZ+1)
            DO 2471 IX=1,NR
              IF ((IPRTSP(IZ+1+NZ*(IX-1)).EQ.0)) THEN
                IF ((IX .EQ. 1)) THEN
                  RLOW=0.
                ELSE
                  RLOW=RCYL(IX-1)
                END IF
                IPERPG=IPERPG+1
                IF ((IPERPG .EQ. NPERPG)) THEN
                  write(iout,'(''\f'')')
                  write(iout,205) title
                  call egs_fdate(iout)
                  write(iout,*)
                  IPERPG=0
                END IF
                WRITE(IOUT,200) ZLOW,ZHIGH,IZ+1+NZ*(IX-1)
                IF ((ISOURC .NE. 2 .AND. ISOURC .NE. 4)) THEN
                  WRITE(IOUT,201) RLOW,RCYL(IX)
                ELSE IF((ISOURC .EQ. 2)) THEN
                  WRITE(IOUT,202)
                ELSE IF((ISOURC .EQ. 4)) THEN
                  WRITE(IOUT,203) RBEAM,RCYL(IX)
                END IF
                IF ((ISOURC .NE. 3 .AND. ISOURC .NE. 21 .AND. ISOURC.NE.
     *          22 .AND. ISOURC.NE.23)) THEN
                  IF ((IP .EQ. 1)) THEN
                    WRITE(IOUT,210)
                  ELSE
                    IF ((IPRIM .NE.4)) THEN
                      WRITE(IOUT,211)
                    ELSE
                      WRITE(IOUT,2115)
                    END IF
                  END IF
                ELSE
                  IF ((IP .EQ. 1)) THEN
                    WRITE(IOUT,208)
                  ELSE
                    IF ((IPRIM .NE.4)) THEN
                      WRITE(IOUT,209)
                    ELSE
                      WRITE(IOUT,2095)
                    END IF
                  END IF
                END IF
                WRITE(IOUT,212)
                ILINE=0
                DO 2481 IB=1,MAXIB
                  ILINE=ILINE+1
                  IF ((SLOTE .LE. 0.0)) THEN
                    ETOP=BINTOP(IB)
                  ELSE
                    ETOP=SLOTE*dble(IB)
                  END IF
                  IF ((MOD(ILINE,5) .NE. 0)) THEN
                    WRITE(IOUT,220) ETOP,(SCFLU(IB,IZ,IX,IQL,IP),SCFLU2(
     *              IB,IZ,IX,IQL,IP),IQL=1,3), SCFLEP(IB,IZ,IX,IP),SCFLE
     *              P2(IB,IZ,IX,IP)
                  ELSE
                    WRITE(IOUT,221) ETOP,(SCFLU(IB,IZ,IX,IQL,IP),SCFLU2(
     *              IB,IZ,IX,IQL,IP),IQL=1,3), SCFLEP(IB,IZ,IX,IP),SCFLE
     *              P2(IB,IZ,IX,IP)
                  END IF
2481            CONTINUE
2482            CONTINUE
                WRITE(IOUT,230) (SCTFLU(IZ,IX,IQL,IP),SCTFLU2(IZ,IX,IQL,
     *          IP),IQL=1,3), SCTLEP(IZ,IX,IP),SCTLEP2(IZ,IX,IP), (SCEAV
     *          E(IZ,IX,IQL,IP),SCEAVE2(IZ,IX,IQL,IP),IQL=1,3), SCELEP(I
     *          Z,IX,IP),SCELEP2(IZ,IX,IP)
              END IF
2471        CONTINUE
2472        CONTINUE
2461      CONTINUE
2462      CONTINUE
2451    CONTINUE
2452    CONTINUE
      ELSE IF((IPRNTP .EQ. 1)) THEN
      END IF
      IF((IPLT .EQ. 1))CALL PLOTEN
90    FORMAT(/' Final brem photons split into ',I3,' photons'/)
1001  FORMAT(/' ',T18,'Total # charged particle steps',T55,1PE10.3,' +/-
     *',0PF4.1,'%'/' ',T2,'Total # charged particle steps/initial histor
     *y',T55,1PE10.3,' +/-',0PF4.1,'%'/' ',T6,'# PRESTA-II steps/# charg
     *ed particle steps',T58,F7.3,' +/-',0PF4.1,'%')
200   FORMAT(/T10,' Depth coordinates:',T30,F9.4,' TO',F9.4,' cm','  REG
     *ION =',I3/)
201   FORMAT(T17,'Radial coordinates:',T37,F9.4,' TO',F9.4,' cm')
202   FORMAT(T25,'Broad parallel beam results')
203   FORMAT(T5,'In central radial region of',F10.3,' cm,beam radius=',F
     *10.3,' cm')
208   FORMAT(/T18,' Total fluence/(MeV)/source particle')
209   FORMAT(/T18,' Primary fluence/(MeV)/source particle')
2095  FORMAT(/T18,' Secondary fluence/(MeV)/source particle')
210   FORMAT(/T18,' Total fluence/(MeV)/unit incident fluence')
211   FORMAT(/T18,' Primary fluence/(MeV)/unit incident fluence')
2115  FORMAT(/T18,' Secondary fluence/(MeV)/unit incident fluence')
212   FORMAT(/'    Bintop',T17,'electrons',T34,'photons',T50,'positrons'
     *,T67,'e(-) + e(+)'/'    ------',T17,'---------',T34,'-------',T50,
     *'---------',T67,'-----------')
220   FORMAT(' ',F9.4,2X,4(1PE9.3,'+-',0PF4.1,'%',1X))
221   FORMAT(' ',F9.4,2('-'),3(1PE9.3,'+-',0PF4.1,'%',1('-')),1PE9.3,'+-
     *',0PF4.1,'%')
230   FORMAT(' ',9('-'),T13,4(16('-'),1X)/'    Totals',T13,4(1PE9.3,'+-'
     *,0PF4.1,'%',1X)/'     Avg E',T13,4(1PE9.3,'+-',0PF4.1,'%',1X)//)
      RETURN
205   FORMAT(80A1/T56,$)
      END
      SUBROUTINE PLOTSN
      implicit none
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      COMMON/USERVR/ CEXPTR,GWAIT(150),DUMU,NP_INC(150),MAFORC,IFORCE,NF
     *MIN,NFMAX,NFTIME, ISOURC,IFPB,IQINC,MONOEN,IRODUM,IRNDUM,MEDDUM,ID
     *UM,MEDTMP, PATHL,DELTAP,GWTOLD,EPSLON,ARG
      real*8 CEXPTR,GWAIT,DUMU,PATHL,DELTAP,GWTOLD,EPSLON,ARG
      integer*4 NP_INC,MAFORC,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQIN
     *C, MONOEN,IRODUM,IRNDUM,MEDDUM,IDUM,MEDTMP
      COMMON/USERRR/
     *              CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,
     *                            EKETST,ELKETS,ZL,RL,CDIST,IGEOM,IRANGE
     *,MINZ,MAXZ,MINR,MAXR,IREJCT
      real*8 CRANGE,ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,EKETST,ELKETS
     *,ZL,RL,CDIST
      integer*4 MINZ,MAXZ,MINR,MAXR
      integer*4 IREJCT,IRANGE,IGEOM
      integer*4 I,IPLTUNX,IPLTUN,IPRIMS,J,IRL,ILOW,IHIGH,ILA120, IZ,IX,I
     *PRIM1,IP,IQ,IB,IRLR,IQR,IPR
      real*8 FLUMX,TFLUMX,FLUMIN,HISTXMIN,BIN_CUT,FMAX
      INTEGER NPLOTR, NPLOTZ
      INTEGER NUM_IOPLOT, NUM_IPLTPL, NUM_IPLPHB, NUM_DFLUP, NUM_PLOTE,
     *NUM_PLOTPH, NUM_PLOTPO, NUM_PLOTBO, NUM_PLSPKRL, NUM_PLSPKRH, NUM_
     *IPLTRAD, NUM_IPLTPLN
      real*8 XCOORD(1000), YCOORD(1000), UNCERT(1000)
      INTEGER NPTS, PLTYPE, AXISTYPE, CURVENUM, inte, CHECK
      INTEGER IZR, IXR
      INTEGER UNITNUM, IPLTSPEC
      CHARACTER*80 GRAPHTITLE
      CHARACTER*60 SERIESTITLE, XTITLE, YTITLE,SUBTITLE
      CHARACTER*4 CH_IZ, CH_IX, CH_IQ, CH_IP, CH_IRL
      CHARACTER*1 a(3)
      character backslash
      LOGICAL NEGVAL
      COMMON/GEOM/ZPLANE( 501),RCYL(0:4), CYRAD2(4),NTRACK( 2001),NZ,NR,
     *NREG,NPLANE
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NTRACK,NZ,NR,NREG,NPLANE
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      CHARACTER*1 TITLE(80)
      COMMON/IODAT1/TITLE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET,TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
     *, IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP( 2001),IVAL,DATCOUNT
      real*8 TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
      integer*4 IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP,IVAL,DATCOUN
     *T
      integer*8 NCASE,NCASEO,NCASET
      COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE
      integer*4 ICHPIN,ILPIN,IOUT,IPAGE
      COMMON/PLOTC/IPLOT( 2001),IPLOTR(4),IPLOTZ( 501), IPLTIQ(4),IPLTTP
     *(2),IPLT ,IPLTPL,IPLPHB
      integer*4 IPLOT,IPLOTR,IPLOTZ,IPLTIQ,IPLTTP,IPLT,IPLTPL,IPLPHB
      COMMON/SCORE/ SCFLU(1000, 501,4,3,2), SCFLU2(1000, 501,4,3,2), SCE
     *AVE( 501,4,3,2), SCEAVE2( 501,4,3,2), SCEAVE_COV( 501,4,3,2),SCSTP
     *,SCSTP2,PIISTP, SCELEP( 501,4,2), SCELEP2( 501,4,2), SCELEP_COV( 5
     *01,4,2), SCFLEP(1000, 501,4,2), SCFLEP2(1000, 501,4,2), SCTFLU( 50
     *1,4,3,2), SCTFLU2( 501,4,3,2), SCTLEP( 501,4,2), SCTLEP2( 501,4,2)
     *, SCSTP_LAST,SCFLU_LAST(1000, 501,4,3,2), SCFLEP_LAST(1000, 501,4,
     *2), SCTFLU_LAST( 501,4,3,2), SCTLEP_LAST( 501,4,2), IHSTRY,SCFLU_T
     *MP(1000, 501,4,3,2), SCEAVE_TMP( 501,4,3,2), SCSTP_TMP,SCELEP_TMP(
     * 501,4,2), SCFLEP_TMP(1000, 501,4,2), SCTFLU_TMP( 501,4,3,2), SCTL
     *EP_TMP( 501,4,2), BINTOP(1000),SLOTE,ECUTMX,PCUTMX,EBINW(1000,3),
     *VOLUME(500,4),MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      REAL*8 SCFLU,SCFLU2,SCEAVE,SCEAVE2,SCEAVE_COV,SCSTP,SCSTP2, SCELEP
     *,SCELEP2,SCELEP_COV,SCFLEP,SCFLEP2,SCTFLU,SCTFLU2,SCTLEP, SCTLEP2,
     *PIISTP
      integer*8 SCSTP_LAST,SCFLU_LAST,SCFLEP_LAST,SCTFLU_LAST,SCTLEP_LAS
     *T,IHSTRY
      real*8 SCFLU_TMP,SCEAVE_TMP,SCSTP_TMP,SCELEP_TMP,SCFLEP_TMP, SCTFL
     *U_TMP,SCTLEP_TMP,BINTOP,SLOTE, ECUTMX,PCUTMX,EBINW,VOLUME
      integer*4 MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      I=0
      IVAL = IVAL + 1
      NUM_IOPLOT = IVAL
      VALUES_SOUGHT(IVAL)='PLOTTING'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='OFF'
      ALLOWED_INPUTS(IVAL,1)='ON'
      DELIMETER='PLOT CONTROL'
      NMIN = NUM_IOPLOT
      NMAX = NUM_IOPLOT
      CALL GET_INPUT
      IPLT=VALUE(NUM_IOPLOT,1)
      WRITE(6,2490)
2490  FORMAT(' *** INPUT CARD PL1 ***')
      IF ((IPLT .EQ. 1)) THEN
        WRITE(6,2500)
2500    FORMAT(' Plotting files will be created'/)
      END IF
      IF ((IPLT .EQ. 0)) THEN
        WRITE(6,2510)
2510    FORMAT(' Plotting files will not be created'/)
        IPLTPL=0
      ELSE
        WRITE(6,2520)
2520    FORMAT(' *** INPUT CARD PL2 no longer used ***')
        WRITE(6,2530)
2530    FORMAT(/' *** INPUT CARD PL3 ***')
        IPLTPL = 1
        WRITE(6,2540)
2540    FORMAT(' FILES WILL BE PREPARED FOR EXTERNAL PLOTTER')
        IPLTUNX=23
        IPLTUN=3
        WRITE(6,2550)
2550    FORMAT(' ')
        WRITE(6,2560)
2560    FORMAT(/' *** INPUT CARD PL4 ***')
        IVAL = IVAL + 1
        NUM_IPLPHB = IVAL
        VALUES_SOUGHT(IVAL)='EXTERNAL PLOT TYPE'
        NVALUE(IVAL)=1
        TYPE(IVAL)=3
        ALLOWED_INPUTS(IVAL,1)='POINT'
        ALLOWED_INPUTS(IVAL,2)='HISTOGRAM'
        ALLOWED_INPUTS(IVAL,3)='BOTH'
        NMIN = NUM_IPLPHB
        NMAX = NUM_IPLPHB
        CALL GET_INPUT
        IPLPHB=VALUE(NUM_IPLPHB,1)
        WRITE(6,2570)IPLPHB
2570    FORMAT(' Point plot(1)/Histogram(2)/Both(3) will be prepared:',I
     *2)
        WRITE(6,2580)
2580    FORMAT(' ')
        WRITE(6,2590)
2590    FORMAT(' *** INPUT CARD PL5 ***')
        IF ((IPRIM .NE.0)) THEN
          IVAL = IVAL + 1
          NUM_DFLUP = IVAL
          VALUES_SOUGHT(IVAL)='DRAW FLUENCE PLOTS'
          NVALUE(IVAL)=1
          TYPE(IVAL)=3
          ALLOWED_INPUTS(IVAL,1)='NONE'
          ALLOWED_INPUTS(IVAL,2)='ALL'
          ALLOWED_INPUTS(IVAL,3)='PRIMARIES'
          ALLOWED_INPUTS(IVAL,4)='TOTAL'
          NMIN = NUM_DFLUP
          NMAX = NUM_DFLUP
          CALL GET_INPUT
          IPRIMS=int(VALUE(NUM_DFLUP,1))
          IF ((IPRIMS.EQ.1).OR.(IPRIMS.EQ.4)) THEN
            IPLTTP(1)=1
            IPLTTP(2)=0
            WRITE(6,2600)
2600        FORMAT('Will plot only total fluence plots')
          END IF
          IF ((IPRIMS.EQ.2)) THEN
            IPLTTP(1)=1
            IPLTTP(2)=1
            WRITE(6,2610)
2610        FORMAT('Will plot total and primary/secondary plots')
          END IF
          IF ((IPRIMS.EQ.3)) THEN
            IPLTTP(1)=0
            IPLTTP(2)=1
            WRITE(6,2620)
2620        FORMAT('Will plot only primary/secondary plots ')
          END IF
        ELSE
          IPLTTP(1)=1
          IPLTTP(2)=0
          WRITE(6,2630)
2630      FORMAT('Will plot only total since that is all scored'/)
        END IF
        IVAL = IVAL + 1
        NUM_PLOTE = IVAL
        VALUES_SOUGHT(IVAL)='PLOTS FOR ELECTRONS'
        NVALUE(IVAL)=1
        TYPE(IVAL)=3
        ALLOWED_INPUTS(IVAL,1)='OFF'
        ALLOWED_INPUTS(IVAL,2)='ON'
        IVAL = IVAL + 1
        NUM_PLOTPH = IVAL
        VALUES_SOUGHT(IVAL)='PLOTS FOR PHOTONS'
        NVALUE(IVAL)=1
        TYPE(IVAL)=3
        ALLOWED_INPUTS(IVAL,1)='OFF'
        ALLOWED_INPUTS(IVAL,2)='ON'
        IVAL = IVAL + 1
        NUM_PLOTPO = IVAL
        VALUES_SOUGHT(IVAL)='PLOTS FOR POSITRONS'
        NVALUE(IVAL)=1
        TYPE(IVAL)=3
        ALLOWED_INPUTS(IVAL,1)='OFF'
        ALLOWED_INPUTS(IVAL,2)='ON'
        IVAL = IVAL + 1
        NUM_PLOTBO = IVAL
        VALUES_SOUGHT(IVAL)='PLOTS FOR E- AND E+'
        NVALUE(IVAL)=1
        TYPE(IVAL)=3
        ALLOWED_INPUTS(IVAL,1)='OFF'
        ALLOWED_INPUTS(IVAL,2)='ON'
        NMIN = NUM_PLOTE
        NMAX = NUM_PLOTBO
        CALL GET_INPUT
        WRITE(6,2640)
2640    FORMAT(/' *** INPUT CARD PL6 ***')
        IF ((VALUE(NUM_PLOTE,1).EQ.2)) THEN
          IPLTIQ(1)=1
          WRITE(6,2650)
2650      FORMAT('     PLOT FOR ELECTRONS')
        ELSE
          IPLTIQ(1)=0
          WRITE(6,2660)
2660      FORMAT('     NO PLOTS FOR ELECTRONS')
        END IF
        IF ((VALUE(NUM_PLOTPH,1).EQ.2)) THEN
          IPLTIQ(2)=1
          WRITE(6,2670)
2670      FORMAT('     PLOT FOR PHOTONS')
        ELSE
          IPLTIQ(2)=0
          WRITE(6,2680)
2680      FORMAT('     NO PLOTS FOR PHOTONS')
        END IF
        IF ((VALUE(NUM_PLOTPO,1).EQ.2)) THEN
          IPLTIQ(3)=1
          WRITE(6,2690)
2690      FORMAT('     PLOT FOR POSITRONS')
        ELSE
          IPLTIQ(3)=0
          WRITE(6,2700)
2700      FORMAT('     NO PLOTS FOR POSITRONS')
        END IF
        IF ((VALUE(NUM_PLOTBO,1).EQ.2)) THEN
          IPLTIQ(4)=1
          WRITE(6,2710)
2710      FORMAT('     PLOT FOR ELECTRONS AND POSITRONS')
        ELSE
          IPLTIQ(4)=0
          WRITE(6,2720)
2720      FORMAT('     NO PLOTS FOR ELECTRONS AND POSITRONS')
        END IF
        WRITE(6,2730)
2730    FORMAT(' ')
        IVAL = IVAL + 1
        NUM_PLSPKRL = IVAL
        VALUES_SOUGHT(IVAL)='START SPECTRAL PLOT IN REGION'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=2
        VALUE_MAX(IVAL)=NREG
        DEFAULT(IVAL)=2
        IVAL = IVAL + 1
        NUM_PLSPKRH = IVAL
        VALUES_SOUGHT(IVAL)='STOP SPECTRAL PLOT IN REGION'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=2
        VALUE_MAX(IVAL)=NREG
        DEFAULT(IVAL)=NREG
        NMIN = NUM_PLSPKRL
        NMAX = NUM_PLSPKRH
        CALL GET_INPUT
        WRITE(6,2740)
2740    FORMAT(' *** INPUT CARD PL7 ***')
        DO 2751 IRL=2,NREG
          IPLOT(IRL)=0
2751    CONTINUE
2752    CONTINUE
        DO 2761 J=1,NVALUE(NUM_PLSPKRL)
          ILOW=VALUE(NUM_PLSPKRL,J)
          IHIGH=VALUE(NUM_PLSPKRH,J)
          IF ((ILOW.EQ.0)) THEN
            WRITE(6,2770)
2770        FORMAT('NO SPECTRAL PLOTS')
            GO TO2762
          END IF
          IF ((ILOW.GT.IHIGH)) THEN
            IHIGH=ILOW
          END IF
          IF ((ILOW.EQ.IHIGH)) THEN
            WRITE(6,2780)ILOW
2780        FORMAT(' Will plot spectrum in region #',I3)
            IPLOT(ILOW)= 1
          ELSE
            DO 2791 IRL=ILOW,IHIGH
              IPLOT(IRL)= 1
2791        CONTINUE
2792        CONTINUE
            WRITE(6,2800)ILOW,IHIGH
2800        FORMAT('  Will plot spectra from zones #',I3,' to  #',I3)
          END IF
2761    CONTINUE
2762    CONTINUE
        WRITE(6,2810)
2810    FORMAT(/' *** INPUT CARD PL8 ***')
        IVAL = IVAL + 1
        NUM_IPLTRAD = IVAL
        VALUES_SOUGHT(IVAL)='PLOT RADIAL REGION IX'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=0
        VALUE_MAX(IVAL)=NR
        DEFAULT(IVAL)=NR
        NMIN = NUM_IPLTRAD
        NMAX = NUM_IPLTRAD
        CALL GET_INPUT
        DO 2821 J=1,NR
          IPLOTR(J) = 0
2821    CONTINUE
2822    CONTINUE
        NPLOTR=NVALUE(NUM_IPLTRAD)
        IF ((int(VALUE(NUM_IPLTRAD,1)) .GT. 0)) THEN
          DO 2831 J=1,NPLOTR
            IPLOTR(int(VALUE(NUM_IPLTRAD,J))) = 1
            WRITE(6,2840)int(VALUE(NUM_IPLTRAD,J))
2840        FORMAT('Will plot fluence vs depth in radial zone ', I3)
2831      CONTINUE
2832      CONTINUE
        ELSE
          WRITE(6,2850)
2850      FORMAT(' No plot of fluence vs depth for radial zones')
        END IF
        WRITE(6,2860)
2860    FORMAT(/' *** INPUT CARD PL9 ***')
        IVAL = IVAL + 1
        NUM_IPLTPLN = IVAL
        VALUES_SOUGHT(IVAL)='PLOT PLANAR REGION IZ'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=0
        VALUE_MAX(IVAL)=NZ
        DEFAULT(IVAL)=NZ
        DO 2871 J=1,NZ
          IPLOTZ(J) = 0
2871    CONTINUE
2872    CONTINUE
        NMIN = NUM_IPLTPLN
        NMAX = NUM_IPLTPLN
        CALL GET_INPUT
        NPLOTZ=NVALUE(NUM_IPLTPLN)
        IF ((VALUE(NUM_IPLTPLN,1) .GT. 0)) THEN
          DO 2881 J=1,NPLOTZ
            IPLOTZ(int(VALUE(NUM_IPLTPLN,J))) = 1
            WRITE(6,2890)int(VALUE(NUM_IPLTPLN,J))
2890        FORMAT('Will plot fluence vs radius in planar slab ', I3)
2881      CONTINUE
2882      CONTINUE
        ELSE
          WRITE(6,2900)
2900      FORMAT(' No fluence vs radius plots')
        END IF
      END IF
      RETURN
      ENTRY PLOTEN
      backslash=char(92)
      IPLTSPEC=17
      IPLTUNX=23
      write(iout,'(''\f'')')
      ILA120=1
      FLUMX=0.0
      TFLUMX=0.0
      FLUMIN=100000
      DO 2911 IZ=1,NZ
        DO 2921 IX=1,NR
          IF ((IPRIM .EQ. 0)) THEN
            IPRIM1=1
          ELSE
            IPRIM1=2
          END IF
          DO 2931 IP=1,IPRIM1
            DO 2941 IQ=1,3
              IF ((TFLUMX .LT. SCTFLU(IZ,IX,IQ,IP))) THEN
                TFLUMX=SCTFLU(IZ,IX,IQ,IP)
              END IF
              DO 2951 IB=1,MAXIB
                IF ((FLUMX .LT. SCFLU(IB,IZ,IX,IQ,IP))) THEN
                  FLUMX=SCFLU(IB,IZ,IX,IQ,IP)
                END IF
                IF ((SCFLU(IB,IZ,IX,IQ,IP) .GT. 0.0)) THEN
                  IF ((FLUMIN .GT. SCFLU(IB,IZ,IX,IQ,IP))) THEN
                    FLUMIN=SCFLU(IB,IZ,IX,IQ,IP)
                  END IF
                END IF
2951          CONTINUE
2952          CONTINUE
2941        CONTINUE
2942        CONTINUE
2931      CONTINUE
2932      CONTINUE
2921    CONTINUE
2922    CONTINUE
2911  CONTINUE
2912  CONTINUE
      DO 2961 I=1,80
        GRAPHTITLE(I:I)=TITLE(I)
2961  CONTINUE
2962  CONTINUE
      UNITNUM=IPLTSPEC
      CURVENUM=0
      DO 2971 IQ=1,4
        IF ((IPLTIQ(IQ) .EQ. 1)) THEN
          IF ((IPRIM .EQ. 0)) THEN
            IPRIM1=1
          ELSE
            IPRIM1=2
          END IF
          DO 2981 IP=1,IPRIM1
            IF ((IPLTTP(IP) .EQ. 1)) THEN
              DO 2991 IRL=2,NREG
                IX=(IRL-2)/NZ+1
                IZ=IRL-1-NZ*(IX-1)
                IF ((IPLOT(IRL) .EQ. 1)) THEN
                  IF ((IPLTPL .EQ. 1)) THEN
                    NPTS=MAXIB
                    XTITLE='energy/MeV'
                    IF ((ISOURC.EQ.3.OR.ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.
     *              ISOURC.EQ.23)) THEN
                      YTITLE='(fluence/MeV)/incident particle /cm'//back
     *                slash//'S-2' //backslash//'NMeV'//backslash//'S-1'
     *                //backslash//'N'
                    ELSE
                      YTITLE='(fluence/MeV)/incident fluence /MeV'//back
     *                slash//'S-1' //backslash//'N'
                    END IF
                    call egs_get_fdate(SUBTITLE)
                    SUBTITLE='fluence vs. energy on '//SUBTITLE(1:24)
                    HISTXMIN=BIN_CUT
                    AXISTYPE=0
                    IF ((IPLPHB .EQ. 1 .OR. IPLPHB .EQ. 3)) THEN
                      DO 3001 IB=1,MAXIB
                        IF ((IB .EQ. 1)) THEN
                          WRITE(6,3010)PCUT(2),ECUT(2)
3010                      FORMAT(' PLOTSN: PCUT(2),ECUT(2)=',2F10.4,' Me
     *V')
                          WRITE(6,3020)
3020                      FORMAT(' Plot routines assume constant ECUT/PC
     *UT')
                          IF ((IQ .EQ. 2)) THEN
                            XCOORD(IB) = (BINTOP(IB) + PCUT(2))/2.
                          ELSE
                            XCOORD(IB) = (BINTOP(IB) + (ECUT(2)-PRM))/2.
     *
                          END IF
                        ELSE
                          XCOORD(IB) = (BINTOP(IB)+BINTOP(IB-1))/2
                        END IF
                        IF ((IQ .LT. 4)) THEN
                          YCOORD(IB) = SCFLU(IB,IZ,IX,IQ,IP)
                          UNCERT(IB) = SCFLU(IB,IZ,IX,IQ,IP)*SCFLU2(IB,I
     *                    Z,IX,IQ,IP)/100.
                        END IF
                        IF ((IQ.EQ.4)) THEN
                          YCOORD(IB) = SCFLU(IB,IZ,IX,1,IP)+SCFLU(IB,IZ,
     *                    IX,3,IP)
                          UNCERT(IB) = ((SCFLU(IB,IZ,IX,1,IP)*SCFLU2(IB,
     *                    IZ,IX,1,IP))+ (SCFLU(IB,IZ,IX,3,IP)* SCFLU2(IB
     *                    ,IZ,IX,3,IP)))/100.
                        END IF
3001                  CONTINUE
3002                  CONTINUE
                      IRLR=IRL
                      NEGVAL=.FALSE.
                      IF ((IRLR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IRLR = ABS(IRLR)
                      END IF
                      IF (((IRLR .EQ. MOD(IRLR,1000)))) THEN
                        CHECK=1
                        IF ((IRLR .EQ. MOD(IRLR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IRL='-'//CHAR(IRLR+48)
                          ELSE
                            CH_IRL=CHAR(IRLR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IRLR .EQ. MOD(IRLR,10
     *                  0)))) THEN
                          a(1)=CHAR((IRLR/10)+48)
                          inte=(MOD(IRLR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IRL='-'//a(1)//a(2)
                          ELSE
                            CH_IRL=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IRLR/100)+48)
                          inte=(MOD(IRLR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IRLR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IRL='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IRL=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IRL='3max'
                      END IF
                      IQR=IQ-2
                      NEGVAL=.FALSE.
                      IF ((IQR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IQR = ABS(IQR)
                      END IF
                      IF (((IQR .EQ. MOD(IQR,1000)))) THEN
                        CHECK=1
                        IF ((IQR .EQ. MOD(IQR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//CHAR(IQR+48)
                          ELSE
                            CH_IQ=CHAR(IQR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IQR .EQ. MOD(IQR,100)
     *                  ))) THEN
                          a(1)=CHAR((IQR/10)+48)
                          inte=(MOD(IQR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//a(1)//a(2)
                          ELSE
                            CH_IQ=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IQR/100)+48)
                          inte=(MOD(IQR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IQR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IQ=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IQ='3max'
                      END IF
                      IPR=IP
                      NEGVAL=.FALSE.
                      IF ((IPR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IPR = ABS(IPR)
                      END IF
                      IF (((IPR .EQ. MOD(IPR,1000)))) THEN
                        CHECK=1
                        IF ((IPR .EQ. MOD(IPR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//CHAR(IPR+48)
                          ELSE
                            CH_IP=CHAR(IPR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IPR .EQ. MOD(IPR,100)
     *                  ))) THEN
                          a(1)=CHAR((IPR/10)+48)
                          inte=(MOD(IPR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//a(1)//a(2)
                          ELSE
                            CH_IP=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IPR/100)+48)
                          inte=(MOD(IPR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IPR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IP=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IP='3max'
                      END IF
                      SERIESTITLE='IRL='//CH_IRL//'IQ='//CH_IQ//'IP='//C
     *                H_IP
                      PLTYPE=0
                      HISTXMIN=BIN_CUT
                      CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVE
     *                NUM, SERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBT
     *                ITLE, UNITNUM, PLTYPE, HISTXMIN, AXISTYPE)
                      CURVENUM=CURVENUM+1
                    END IF
                    IF ((IPLPHB .EQ. 2 .OR. IPLPHB .EQ. 3)) THEN
                      WRITE(6,3030)BINTOP(1)
3030                  FORMAT(' PLOTSN: BINTOP(1) =',F10.4,' MeV')
                      DO 3041 IB=1,MAXIB
                        XCOORD(IB) = BINTOP(IB)
                        IF ((IQ .LT. 4)) THEN
                          YCOORD(IB) = SCFLU(IB,IZ,IX,IQ,IP)
                          UNCERT(IB) = SCFLU(IB,IZ,IX,IQ,IP)*SCFLU2(IB,I
     *                    Z,IX,IQ,IP)/100.
                        END IF
                        IF ((IQ.EQ.4)) THEN
                          YCOORD(IB) = SCFLU(IB,IZ,IX,1,IP)+SCFLU(IB,IZ,
     *                    IX,3,IP)
                          UNCERT(IB) = ((SCFLU(IB,IZ,IX,1,IP)*SCFLU2(IB,
     *                    IZ,IX,1,IP))+ (SCFLU(IB,IZ,IX,3,IP)* SCFLU2(IB
     *                    ,IZ,IX,3,IP)))/100.
                        END IF
3041                  CONTINUE
3042                  CONTINUE
                      IF ((IQ.EQ.2)) THEN
                        BIN_CUT=PCUT(2)
                      ELSE
                        BIN_CUT=ECUT(2)-PRM
                      END IF
                      IRLR=IRL
                      NEGVAL=.FALSE.
                      IF ((IRLR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IRLR = ABS(IRLR)
                      END IF
                      IF (((IRLR .EQ. MOD(IRLR,1000)))) THEN
                        CHECK=1
                        IF ((IRLR .EQ. MOD(IRLR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IRL='-'//CHAR(IRLR+48)
                          ELSE
                            CH_IRL=CHAR(IRLR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IRLR .EQ. MOD(IRLR,10
     *                  0)))) THEN
                          a(1)=CHAR((IRLR/10)+48)
                          inte=(MOD(IRLR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IRL='-'//a(1)//a(2)
                          ELSE
                            CH_IRL=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IRLR/100)+48)
                          inte=(MOD(IRLR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IRLR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IRL='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IRL=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IRL='3max'
                      END IF
                      IPR=IP
                      NEGVAL=.FALSE.
                      IF ((IPR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IPR = ABS(IPR)
                      END IF
                      IF (((IPR .EQ. MOD(IPR,1000)))) THEN
                        CHECK=1
                        IF ((IPR .EQ. MOD(IPR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//CHAR(IPR+48)
                          ELSE
                            CH_IP=CHAR(IPR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IPR .EQ. MOD(IPR,100)
     *                  ))) THEN
                          a(1)=CHAR((IPR/10)+48)
                          inte=(MOD(IPR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//a(1)//a(2)
                          ELSE
                            CH_IP=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IPR/100)+48)
                          inte=(MOD(IPR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IPR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IP=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IP='3max'
                      END IF
                      IQR=IQ-2
                      NEGVAL=.FALSE.
                      IF ((IQR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IQR = ABS(IQR)
                      END IF
                      IF (((IQR .EQ. MOD(IQR,1000)))) THEN
                        CHECK=1
                        IF ((IQR .EQ. MOD(IQR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//CHAR(IQR+48)
                          ELSE
                            CH_IQ=CHAR(IQR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IQR .EQ. MOD(IQR,100)
     *                  ))) THEN
                          a(1)=CHAR((IQR/10)+48)
                          inte=(MOD(IQR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//a(1)//a(2)
                          ELSE
                            CH_IQ=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IQR/100)+48)
                          inte=(MOD(IQR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IQR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IQ=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IQ='3max'
                      END IF
                      NPTS=MAXIB
                      SERIESTITLE='IRL='//CH_IRL//'IQ='//CH_IQ//'IP='//C
     *                H_IP
                      PLTYPE=1
                      HISTXMIN=BIN_CUT
                      CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVE
     *                NUM, SERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBT
     *                ITLE, UNITNUM, PLTYPE, HISTXMIN, AXISTYPE)
                      CURVENUM=CURVENUM+1
                    END IF
                  END IF
                END IF
2991          CONTINUE
2992          CONTINUE
            END IF
2981      CONTINUE
2982      CONTINUE
        END IF
2971  CONTINUE
2972  CONTINUE
      FMAX=0.0
      DO 3051 IZ=1,NZ
        IF((SCTFLU(IZ,IX,IQ,IP).GT.FMAX))FMAX=SCTFLU(IZ,IX,IQ,IP)
3051  CONTINUE
3052  CONTINUE
      IF ((FMAX .NE.0.0)) THEN
        WRITE(IOUT,*) 'LINEPRINTER OUTPUT NO LONGER AVAILABLE- see xmgr
     *data files'
      END IF
      UNITNUM=IPLTUNX
      CURVENUM=0
      DO 3061 IQ=1,3
        IF ((IPLTIQ(IQ) .EQ. 1)) THEN
          DO 3071 IP=1,IPRIM1
            IF ((IPLTTP(IP) .EQ. 1)) THEN
              DO 3081 IX=1,NR
                IF ((IPLOTR(IX) .EQ. 1)) THEN
                  IF ((IPLTPL .EQ. 1)) THEN
                    NPTS=NZ
                    IF ((NPTS .GT. 1000)) THEN
                      WRITE(6,3090)NPTS,1000
3090                  FORMAT('*** WARNING: SUBROUTINE PLOTSN ********'/,
     *'Number of plotting points NPTS=',i5/, 'larger than max. allowed $
     *PLTDIM=',i5/, 'Setting NPTS to $PLTDIM.'/, 'You can reset $PLTDIM 
     *in your user-code!'/, '****************************************'/)
                      NPTS=1000
                    END IF
                    call egs_get_fdate(SUBTITLE)
                    SUBTITLE='fluence vs. depth on '//SUBTITLE(1:24)
                    XTITLE='depth/cm'
                    IF ((ISOURC.EQ.3.OR.ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.
     *              ISOURC.EQ.23)) THEN
                      YTITLE='fluence/incident particle /cm'//backslash/
     *                /'S-2' //backslash//'N'
                    ELSE
                      YTITLE='fluence/incident fluence'
                    END IF
                    AXISTYPE=0
                    IF ((IPLPHB .EQ. 1 .OR. IPLPHB .EQ. 3)) THEN
                      DO 3101 IZ=1,NPTS
                        XCOORD(IZ) = (ZPLANE(IZ)+ZPLANE(IZ+1))/2.
                        YCOORD(IZ) = SCTFLU(IZ,IX,IQ,IP)
                        UNCERT(IZ) = SCTFLU(IZ,IX,IQ,IP)*SCTFLU2(IZ,IX,I
     *                  Q,IP)/100.
3101                  CONTINUE
3102                  CONTINUE
                      IPR=IP
                      NEGVAL=.FALSE.
                      IF ((IPR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IPR = ABS(IPR)
                      END IF
                      IF (((IPR .EQ. MOD(IPR,1000)))) THEN
                        CHECK=1
                        IF ((IPR .EQ. MOD(IPR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//CHAR(IPR+48)
                          ELSE
                            CH_IP=CHAR(IPR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IPR .EQ. MOD(IPR,100)
     *                  ))) THEN
                          a(1)=CHAR((IPR/10)+48)
                          inte=(MOD(IPR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//a(1)//a(2)
                          ELSE
                            CH_IP=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IPR/100)+48)
                          inte=(MOD(IPR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IPR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IP=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IP='3max'
                      END IF
                      IXR=IX
                      NEGVAL=.FALSE.
                      IF ((IXR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IXR = ABS(IXR)
                      END IF
                      IF (((IXR .EQ. MOD(IXR,1000)))) THEN
                        CHECK=1
                        IF ((IXR .EQ. MOD(IXR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IX='-'//CHAR(IXR+48)
                          ELSE
                            CH_IX=CHAR(IXR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IXR .EQ. MOD(IXR,100)
     *                  ))) THEN
                          a(1)=CHAR((IXR/10)+48)
                          inte=(MOD(IXR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IX='-'//a(1)//a(2)
                          ELSE
                            CH_IX=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IXR/100)+48)
                          inte=(MOD(IXR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IXR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IX='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IX=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IX='3max'
                      END IF
                      IQR=IQ-2
                      NEGVAL=.FALSE.
                      IF ((IQR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IQR = ABS(IQR)
                      END IF
                      IF (((IQR .EQ. MOD(IQR,1000)))) THEN
                        CHECK=1
                        IF ((IQR .EQ. MOD(IQR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//CHAR(IQR+48)
                          ELSE
                            CH_IQ=CHAR(IQR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IQR .EQ. MOD(IQR,100)
     *                  ))) THEN
                          a(1)=CHAR((IQR/10)+48)
                          inte=(MOD(IQR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//a(1)//a(2)
                          ELSE
                            CH_IQ=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IQR/100)+48)
                          inte=(MOD(IQR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IQR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IQ=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IQ='3max'
                      END IF
                      SERIESTITLE='radial zone='//CH_IX//' IQ='//CH_IQ//
     *                ' IP='//CH_IP
                      PLTYPE=0
                      HISTXMIN=ZPLANE(1)
                      CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVE
     *                NUM, SERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBT
     *                ITLE, UNITNUM, PLTYPE, HISTXMIN, AXISTYPE)
                      CURVENUM=CURVENUM+1
                    END IF
                    IF ((IPLPHB .EQ. 2 .OR. IPLPHB .EQ. 3)) THEN
                      DO 3111 IZ=1,NPTS
                        XCOORD(IZ) = ZPLANE(IZ+1)
                        YCOORD(IZ) = SCTFLU(IZ,IX,IQ,IP)
                        UNCERT(IZ) = SCTFLU(IZ,IX,IQ,IP)*SCTFLU2(IZ,IX,I
     *                  Q,IP)/100.
3111                  CONTINUE
3112                  CONTINUE
                      IPR=IP
                      NEGVAL=.FALSE.
                      IF ((IPR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IPR = ABS(IPR)
                      END IF
                      IF (((IPR .EQ. MOD(IPR,1000)))) THEN
                        CHECK=1
                        IF ((IPR .EQ. MOD(IPR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//CHAR(IPR+48)
                          ELSE
                            CH_IP=CHAR(IPR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IPR .EQ. MOD(IPR,100)
     *                  ))) THEN
                          a(1)=CHAR((IPR/10)+48)
                          inte=(MOD(IPR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//a(1)//a(2)
                          ELSE
                            CH_IP=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IPR/100)+48)
                          inte=(MOD(IPR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IPR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IP=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IP='3max'
                      END IF
                      IXR=IX
                      NEGVAL=.FALSE.
                      IF ((IXR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IXR = ABS(IXR)
                      END IF
                      IF (((IXR .EQ. MOD(IXR,1000)))) THEN
                        CHECK=1
                        IF ((IXR .EQ. MOD(IXR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IX='-'//CHAR(IXR+48)
                          ELSE
                            CH_IX=CHAR(IXR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IXR .EQ. MOD(IXR,100)
     *                  ))) THEN
                          a(1)=CHAR((IXR/10)+48)
                          inte=(MOD(IXR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IX='-'//a(1)//a(2)
                          ELSE
                            CH_IX=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IXR/100)+48)
                          inte=(MOD(IXR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IXR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IX='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IX=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IX='3max'
                      END IF
                      IQR=IQ-2
                      NEGVAL=.FALSE.
                      IF ((IQR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IQR = ABS(IQR)
                      END IF
                      IF (((IQR .EQ. MOD(IQR,1000)))) THEN
                        CHECK=1
                        IF ((IQR .EQ. MOD(IQR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//CHAR(IQR+48)
                          ELSE
                            CH_IQ=CHAR(IQR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IQR .EQ. MOD(IQR,100)
     *                  ))) THEN
                          a(1)=CHAR((IQR/10)+48)
                          inte=(MOD(IQR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//a(1)//a(2)
                          ELSE
                            CH_IQ=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IQR/100)+48)
                          inte=(MOD(IQR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IQR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IQ=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IQ='3max'
                      END IF
                      SERIESTITLE='radial zone='//CH_IX//' IQ='//CH_IQ//
     *                ' IP='//CH_IP
                      PLTYPE=1
                      HISTXMIN=ZPLANE(1)
                      CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVE
     *                NUM, SERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBT
     *                ITLE, UNITNUM, PLTYPE, HISTXMIN, AXISTYPE)
                      CURVENUM=CURVENUM+1
                    END IF
                  END IF
                END IF
3081          CONTINUE
3082          CONTINUE
              DO 3121 IZ=1,NZ
                IF ((IPLOTZ(IZ) .EQ. 1)) THEN
                  IF ((IPLTPL .EQ. 1)) THEN
                    NPTS=NR
                    XTITLE='radius/cm'
                    IF ((ISOURC.EQ.3.OR.ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.
     *              ISOURC.EQ.23)) THEN
                      YTITLE='fluence/incident particle /cm'//backslash/
     *                /'S-2' //backslash//'N'
                    ELSE
                      YTITLE='fluence/incident fluence'
                    END IF
                    call egs_get_fdate(SUBTITLE)
                    SUBTITLE='fluence vs. radius on '//SUBTITLE(1:24)
                    AXISTYPE=0
                    IF ((IPLPHB .EQ. 1 .OR. IPLPHB .EQ. 3)) THEN
                      DO 3131 IX=1,NR
                        XCOORD(IX) = (RCYL(IX)+RCYL(IX-1))/2
                        IF ((IQ .LT. 4)) THEN
                          YCOORD(IX) = SCTFLU(IZ,IX,IQ,IP)
                          UNCERT(IX) = SCTFLU(IZ,IX,IQ,IP)* SCTFLU2(IZ,I
     *                    X,IQ,IP)/100.
                        END IF
                        IF ((IQ.EQ.4)) THEN
                          YCOORD(IX) = SCTFLU(IZ,IX,1,IP)+SCTFLU(IZ,IX,3
     *                    ,IP)
                          UNCERT(IX) = ((SCTFLU(IZ,IX,1,IP)*SCTFLU2(IZ,I
     *                    X,1,IP))+ (SCTFLU(IZ,IX,3,IP)*SCTFLU2(IZ,IX,3,
     *                    IP)))/100.
                        END IF
3131                  CONTINUE
3132                  CONTINUE
                      IZR=IZ
                      NEGVAL=.FALSE.
                      IF ((IZR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IZR = ABS(IZR)
                      END IF
                      IF (((IZR .EQ. MOD(IZR,1000)))) THEN
                        CHECK=1
                        IF ((IZR .EQ. MOD(IZR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IZ='-'//CHAR(IZR+48)
                          ELSE
                            CH_IZ=CHAR(IZR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IZR .EQ. MOD(IZR,100)
     *                  ))) THEN
                          a(1)=CHAR((IZR/10)+48)
                          inte=(MOD(IZR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IZ='-'//a(1)//a(2)
                          ELSE
                            CH_IZ=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IZR/100)+48)
                          inte=(MOD(IZR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IZR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IZ='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IZ=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IZ='3max'
                      END IF
                      IPR=IP
                      NEGVAL=.FALSE.
                      IF ((IPR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IPR = ABS(IPR)
                      END IF
                      IF (((IPR .EQ. MOD(IPR,1000)))) THEN
                        CHECK=1
                        IF ((IPR .EQ. MOD(IPR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//CHAR(IPR+48)
                          ELSE
                            CH_IP=CHAR(IPR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IPR .EQ. MOD(IPR,100)
     *                  ))) THEN
                          a(1)=CHAR((IPR/10)+48)
                          inte=(MOD(IPR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//a(1)//a(2)
                          ELSE
                            CH_IP=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IPR/100)+48)
                          inte=(MOD(IPR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IPR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IP=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IP='3max'
                      END IF
                      IQR=IQ-2
                      NEGVAL=.FALSE.
                      IF ((IQR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IQR = ABS(IQR)
                      END IF
                      IF (((IQR .EQ. MOD(IQR,1000)))) THEN
                        CHECK=1
                        IF ((IQR .EQ. MOD(IQR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//CHAR(IQR+48)
                          ELSE
                            CH_IQ=CHAR(IQR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IQR .EQ. MOD(IQR,100)
     *                  ))) THEN
                          a(1)=CHAR((IQR/10)+48)
                          inte=(MOD(IQR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//a(1)//a(2)
                          ELSE
                            CH_IQ=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IQR/100)+48)
                          inte=(MOD(IQR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IQR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IQ=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IQ='3max'
                      END IF
                      SERIESTITLE='planar zone='//CH_IZ//' IQ='//CH_IQ//
     *                ' IP='//CH_IP
                      PLTYPE=0
                      HISTXMIN=0.0
                      CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVE
     *                NUM, SERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBT
     *                ITLE, UNITNUM, PLTYPE, HISTXMIN, AXISTYPE)
                      CURVENUM=CURVENUM+1
                    END IF
                    IF ((IPLPHB .EQ. 2 .OR. IPLPHB .EQ. 3)) THEN
                      DO 3141 IX=1,NR
                        XCOORD(IX) = RCYL(IX)
                        IF ((IQ .LT. 4)) THEN
                          YCOORD(IX) = SCTFLU(IZ,IX,IQ,IP)
                          UNCERT(IX) = SCTFLU(IZ,IX,IQ,IP)* SCTFLU2(IZ,I
     *                    X,IQ,IP)/100.
                        END IF
                        IF ((IQ.EQ.4)) THEN
                          YCOORD(IX) = SCTFLU(IZ,IX,1,IP)+SCTFLU(IZ,IX,3
     *                    ,IP)
                          UNCERT(IX) = ((SCTFLU(IZ,IX,1,IP)*SCTFLU2(IZ,I
     *                    X,1,IP))+ (SCTFLU(IZ,IX,3,IP)*SCTFLU2(IZ,IX,3,
     *                    IP)))/100.
                        END IF
3141                  CONTINUE
3142                  CONTINUE
                      IZR=IZ
                      NEGVAL=.FALSE.
                      IF ((IZR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IZR = ABS(IZR)
                      END IF
                      IF (((IZR .EQ. MOD(IZR,1000)))) THEN
                        CHECK=1
                        IF ((IZR .EQ. MOD(IZR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IZ='-'//CHAR(IZR+48)
                          ELSE
                            CH_IZ=CHAR(IZR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IZR .EQ. MOD(IZR,100)
     *                  ))) THEN
                          a(1)=CHAR((IZR/10)+48)
                          inte=(MOD(IZR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IZ='-'//a(1)//a(2)
                          ELSE
                            CH_IZ=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IZR/100)+48)
                          inte=(MOD(IZR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IZR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IZ='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IZ=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IZ='3max'
                      END IF
                      IPR=IP
                      NEGVAL=.FALSE.
                      IF ((IPR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IPR = ABS(IPR)
                      END IF
                      IF (((IPR .EQ. MOD(IPR,1000)))) THEN
                        CHECK=1
                        IF ((IPR .EQ. MOD(IPR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//CHAR(IPR+48)
                          ELSE
                            CH_IP=CHAR(IPR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IPR .EQ. MOD(IPR,100)
     *                  ))) THEN
                          a(1)=CHAR((IPR/10)+48)
                          inte=(MOD(IPR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//a(1)//a(2)
                          ELSE
                            CH_IP=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IPR/100)+48)
                          inte=(MOD(IPR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IPR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IP='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IP=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IP='3max'
                      END IF
                      IQR=IQ-2
                      NEGVAL=.FALSE.
                      IF ((IQR .LT. 0)) THEN
                        NEGVAL=.TRUE.
                        IQR = ABS(IQR)
                      END IF
                      IF (((IQR .EQ. MOD(IQR,1000)))) THEN
                        CHECK=1
                        IF ((IQR .EQ. MOD(IQR,10))) THEN
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//CHAR(IQR+48)
                          ELSE
                            CH_IQ=CHAR(IQR+48)
                          END IF
                          CHECK=0
                        END IF
                        IF (((CHECK .NE. 0) .AND. (IQR .EQ. MOD(IQR,100)
     *                  ))) THEN
                          a(1)=CHAR((IQR/10)+48)
                          inte=(MOD(IQR,10)+48)
                          a(2)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//a(1)//a(2)
                          ELSE
                            CH_IQ=a(1)//a(2)
                          END IF
                          CHECK=0
                        END IF
                        IF ((CHECK .NE. 0)) THEN
                          a(1)=CHAR((IQR/100)+48)
                          inte=(MOD(IQR,100)/10+48)
                          a(2)=CHAR(inte)
                          inte=MOD(IQR,10)+48
                          a(3)=CHAR(inte)
                          IF ((NEGVAL)) THEN
                            CH_IQ='-'//a(1)//a(2)//a(3)
                          ELSE
                            CH_IQ=a(1)//a(2)//a(3)
                          END IF
                        END IF
                      ELSE
                        CH_IQ='3max'
                      END IF
                      SERIESTITLE='planar zone='//CH_IZ//' IQ='//CH_IQ//
     *                ' IP='//CH_IP
                      PLTYPE=1
                      HISTXMIN=0.0
                      CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVE
     *                NUM, SERIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBT
     *                ITLE, UNITNUM, PLTYPE, HISTXMIN, AXISTYPE)
                      CURVENUM=CURVENUM+1
                    END IF
                  END IF
                END IF
3121          CONTINUE
3122          CONTINUE
            END IF
3071      CONTINUE
3072      CONTINUE
        END IF
3061  CONTINUE
3062  CONTINUE
      RETURN
101   FORMAT('1'/)
102   FORMAT(' '//11X,'Fluence vs depth plot for radial zone #',I2,'   n
     *ormalized to',1PE13.3/' FROM',F5.1)
103   FORMAT(' '//11X,'Fluence vs radius plot for planar region #',I2,' 
     *  normalized to',1PE13.3)
104   FORMAT(' '//11X,'Fluence spectrum for region #',I4,'  radial zone=
     *',I2, '  depth zone=',I3,'  normalized to',1PE13.3)
130   FORMAT(' Maximum fluence = 0.000, no plotting will be done')
2001  FORMAT('P    ',I2,'     ****start of another plot*****   '/'L     
     *      1'/T11,'-1',T23,'40',T36,'6',T46,'150',T60, '0'/'energy / Me
     *V'/'L           2'/T11,'50',T23,'-1',T36,'6',T46,'100',T60, '1'/'f
     *luence/MeV /incident fluence'/'L           3'/T10,' -1',T22,'720',
     *T36,'6',T46,'100',T60, '0'/40A1,'IZ=',I2,'  IX=',I2)
2002  FORMAT('P    ',I2,'     ****start of another plot*****   '/'L     
     *      1'/T11,'-1',T23,'40',T36,'6',T46,'150',T60, '0'/'depth / cm 
     *'/'L           2'/T11,'50',T23,'-1',T36,'6',T46,'100',T60, '1'/'to
     *tal fluence / incident fluence'/'L           3'/T10,' -1',T22,'720
     *',T36,'6',T46,'100',T60, '0'/40A1,'IZ=',I2,'  IX=',I2)
2003  FORMAT('P    ',I2,'     ****start of another plot*****   '/'L     
     *      1'/T11,'-1',T23,'40',T36,'6',T46,'150',T60, '0'/'radius / cm
     * '/'L           2'/T11,'50',T23,'-1',T36,'6',T46,'100',T60, '1'/'t
     *otal fluence / incident fluence'/'L           3'/T10,' -1',T22,'72
     *0',T36,'6',T46,'100',T60, '0'/40A1,'IZ=',I2,'  IX=',I2)
2009  FORMAT('@    legend string',I2,' "fluence/MeV IZ,IX,IQ=',I2,I3,I3,
     *'"')
100   FORMAT('1',80A1//' Calculation using FLURZnrc(EGSnrc) ',' ',' ', T
     *56,$)
      END
      subroutine hownear(tperp,x,y,z,ir)
      implicit none
      COMMON/GEOM/ZPLANE( 501),RCYL(0:4), CYRAD2(4),NTRACK( 2001),NZ,NR,
     *NREG,NPLANE
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NTRACK,NZ,NR,NREG,NPLANE
      real*8 tperp,  x,  y,  z
      integer*4 ir
      real*8 r
      integer*4 ix,  iz
      r = sqrt(x**2 + y**2)
      IX=(ir-2)/NZ+1
      IZ=ir-1-NZ*(IX-1)
      tperp = min(z - zplane(iz),zplane(iz + 1) - z,rcyl(ix) - r)
      IF ((ix .NE. 1)) THEN
        tperp = min(tperp,r - rcyl(ix - 1))
      END IF
      return
      end
      subroutine combine_results(file_name)
      implicit none
      character*(*) file_name
      COMMON/SCORE/ SCFLU(1000, 501,4,3,2), SCFLU2(1000, 501,4,3,2), SCE
     *AVE( 501,4,3,2), SCEAVE2( 501,4,3,2), SCEAVE_COV( 501,4,3,2),SCSTP
     *,SCSTP2,PIISTP, SCELEP( 501,4,2), SCELEP2( 501,4,2), SCELEP_COV( 5
     *01,4,2), SCFLEP(1000, 501,4,2), SCFLEP2(1000, 501,4,2), SCTFLU( 50
     *1,4,3,2), SCTFLU2( 501,4,3,2), SCTLEP( 501,4,2), SCTLEP2( 501,4,2)
     *, SCSTP_LAST,SCFLU_LAST(1000, 501,4,3,2), SCFLEP_LAST(1000, 501,4,
     *2), SCTFLU_LAST( 501,4,3,2), SCTLEP_LAST( 501,4,2), IHSTRY,SCFLU_T
     *MP(1000, 501,4,3,2), SCEAVE_TMP( 501,4,3,2), SCSTP_TMP,SCELEP_TMP(
     * 501,4,2), SCFLEP_TMP(1000, 501,4,2), SCTFLU_TMP( 501,4,3,2), SCTL
     *EP_TMP( 501,4,2), BINTOP(1000),SLOTE,ECUTMX,PCUTMX,EBINW(1000,3),
     *VOLUME(500,4),MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      REAL*8 SCFLU,SCFLU2,SCEAVE,SCEAVE2,SCEAVE_COV,SCSTP,SCSTP2, SCELEP
     *,SCELEP2,SCELEP_COV,SCFLEP,SCFLEP2,SCTFLU,SCTFLU2,SCTLEP, SCTLEP2,
     *PIISTP
      integer*8 SCSTP_LAST,SCFLU_LAST,SCFLEP_LAST,SCTFLU_LAST,SCTLEP_LAS
     *T,IHSTRY
      real*8 SCFLU_TMP,SCEAVE_TMP,SCSTP_TMP,SCELEP_TMP,SCFLEP_TMP, SCTFL
     *U_TMP,SCTLEP_TMP,BINTOP,SLOTE, ECUTMX,PCUTMX,EBINW,VOLUME
      integer*4 MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/IODAT2/ NCASE,NCASEO,NCASET,TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
     *, IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP( 2001),IVAL,DATCOUNT
      real*8 TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
      integer*4 IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP,IVAL,DATCOUN
     *T
      integer*8 NCASE,NCASEO,NCASET
      COMMON/GEOM/ZPLANE( 501),RCYL(0:4), CYRAD2(4),NTRACK( 2001),NZ,NR,
     *NREG,NPLANE
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NTRACK,NZ,NR,NREG,NPLANE
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(4,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBEAM
     *,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DI
     *STZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PRO
     *BSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,ZS
     *OFST,                                                      SVTMP1,
     *SVTMP2,SVTMP3,SVTMP4,
     *       RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                     XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,WEI
     *GHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      integer*4 egs_get_unit,lnblnk1
      integer*4 iout,itmax,ix,iz,it,iql,ib,iorstrt
      REAL*8 TSCSTP,TSCSTP2,TSCFLU,TSCFLU2,TSCEAVE,TSCEAVE2,TSCEAVE_COV,
     *TSCTFLU, TSCTFLU2,TSCFLEP,TSCFLEP2,TSCELEP,TSCELEP2,TSCELEP_COV,TS
     *CTLEP, TSCTLEP2,TMPPIISTP
      integer*8 TMPNCASE,TMPNNREAD
      real*8 TMPTMCPU
      logical first_time
      data first_time/.true./
      save first_time
      iout=1
      IF ((IPRIM .EQ. 0)) THEN
        ITMAX=1
      ELSE
        ITMAX=2
      END IF
      IF (( first_time )) THEN
        DATCOUNT=0
        first_time = .false.
        WRITE(6,3150)
3150    FORMAT(/1X,'Summing the following .egsdat files')
        WRITE(6,3160)
3160    FORMAT(1X,'------------------------------------'/)
        WRITE(IOUT,'(/1X,''Summing .egsdat files'')')
        WRITE(IOUT,'(1X,''---------------------''/)')
        TMCPUO=0
        NCASEO=0
        NNREAD=0
        PIISTP=0
        SCSTP=0
        SCSTP2=0
        DO 3171 IX=1,NR
          DO 3181 IZ=1,NZ
            DO 3191 IT=1,ITMAX
              DO 3201 IQL=1,3
                DO 3211 IB=1,MAXIB
                  SCFLU(IB,IZ,IX,IQL,IT)=0.
                  SCFLU2(IB,IZ,IX,IQL,IT)=0.
3211            CONTINUE
3212            CONTINUE
                SCEAVE(IZ,IX,IQL,IT)=0.
                SCEAVE2(IZ,IX,IQL,IT)=0.
                SCEAVE_COV(IZ,IX,IQL,IT)=0.
                SCTFLU(IZ,IX,IQL,IT)=0.
                SCTFLU2(IZ,IX,IQL,IT)=0.
3201          CONTINUE
3202          CONTINUE
              DO 3221 IB=1,MAXIB
                SCFLEP(IB,IZ,IX,IT)=0.
                SCFLEP2(IB,IZ,IX,IT)=0.
3221          CONTINUE
3222          CONTINUE
              SCELEP(IZ,IX,IT)=0.
              SCELEP2(IZ,IX,IT)=0.
              SCELEP_COV(IZ,IX,IT)=0.
              SCTLEP(IZ,IX,IT)=0.
              SCTLEP2(IZ,IX,IT)=0.
3191        CONTINUE
3192        CONTINUE
3181      CONTINUE
3182      CONTINUE
3171    CONTINUE
3172    CONTINUE
      END IF
      IORSTRT=egs_get_unit(4)
      WRITE(IOUT,'(A)') file_name(:lnblnk1(file_name))
      WRITE(6,'(A)') file_name(:lnblnk1(file_name))
      open(IORSTRT,file=file_name,status='old',err=3230)
      DATCOUNT=DATCOUNT+1
      READ(IORSTRT,*) TSCSTP,TSCSTP2
      SCSTP=SCSTP+TSCSTP
      SCSTP2=SCSTP2+TSCSTP2
      DO 3241 IX=1,NR
        DO 3251 IZ=1,NZ
          DO 3261 IT=1,ITMAX
            DO 3271 IQL=1,3
              DO 3281 IB=1,MAXIB
                READ(IORSTRT,*)TSCFLU,TSCFLU2
                SCFLU(IB,IZ,IX,IQL,IT)=SCFLU(IB,IZ,IX,IQL,IT)+ TSCFLU
                SCFLU2(IB,IZ,IX,IQL,IT)=SCFLU2(IB,IZ,IX,IQL,IT)+ TSCFLU2
3281          CONTINUE
3282          CONTINUE
              READ(IORSTRT,*)TSCEAVE,TSCEAVE2,TSCEAVE_COV, TSCTFLU,TSCTF
     *        LU2
              SCEAVE(IZ,IX,IQL,IT)=SCEAVE(IZ,IX,IQL,IT)+TSCEAVE
              SCEAVE2(IZ,IX,IQL,IT)=SCEAVE2(IZ,IX,IQL,IT)+TSCEAVE2
              SCEAVE_COV(IZ,IX,IQL,IT)=SCEAVE_COV(IZ,IX,IQL,IT)+ TSCEAVE
     *        _COV
              SCTFLU(IZ,IX,IQL,IT)=SCTFLU(IZ,IX,IQL,IT)+TSCTFLU
              SCTFLU2(IZ,IX,IQL,IT)=SCTFLU2(IZ,IX,IQL,IT)+TSCTFLU2
3271        CONTINUE
3272        CONTINUE
            DO 3291 IB=1,MAXIB
              READ(IORSTRT,*)TSCFLEP,TSCFLEP2
              SCFLEP(IB,IZ,IX,IT)=SCFLEP(IB,IZ,IX,IT)+TSCFLEP
              SCFLEP2(IB,IZ,IX,IT)=SCFLEP2(IB,IZ,IX,IT)+TSCFLEP2
3291        CONTINUE
3292        CONTINUE
            READ(IORSTRT,*)TSCELEP,TSCELEP2,TSCELEP_COV,TSCTLEP,TSCTLEP2
            SCELEP(IZ,IX,IT)=SCELEP(IZ,IX,IT)+TSCELEP
            SCELEP2(IZ,IX,IT)=SCELEP2(IZ,IX,IT)+TSCELEP2
            SCELEP_COV(IZ,IX,IT)=SCELEP_COV(IZ,IX,IT)+ TSCELEP_COV
            SCTLEP(IZ,IX,IT)=SCTLEP(IZ,IX,IT)+TSCTLEP
            SCTLEP2(IZ,IX,IT)=SCTLEP2(IZ,IX,IT)+TSCTLEP2
3261      CONTINUE
3262      CONTINUE
3251    CONTINUE
3252    CONTINUE
3241  CONTINUE
3242  CONTINUE
      read(IORSTRT,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed, rn
     *g_array
      twom24 = 1./16777216.
      READ(IORSTRT,*) TMPNCASE,TMPTMCPU,TMPNNREAD,TMPPIISTP
      TMCPUO=TMCPUO+TMPTMCPU
      NCASEO=NCASEO+TMPNCASE
      PIISTP=PIISTP+TMPPIISTP
      NNREAD=NNREAD+TMPNNREAD
      write(6,*) '  ncase = ',TMPNCASE,' cpu = ',TMPTMCPU,' total cpu =
     *', TMCPUO
      write(iout,*) '  ncase = ',TMPNCASE,' cpu = ',TMPTMCPU,' total cpu
     * = ', TMCPUO
      CLOSE(UNIT=IORSTRT)
      return
3230  CONTINUE
      WRITE(6,*) 'Error opening file', file_name(:lnblnk1(file_name))
      return
      end
      subroutine init_ranmar
      implicit none
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      integer*4 s,t
      integer*4 i,j,k,l,m,ii,jj
      IF((ixx .LE. 0 .OR. ixx .GT. 31328))ixx = 1802
      IF((jxx .LE. 0 .OR. jxx .GT. 30081))jxx = 9373
      i = mod(ixx/177,177) + 2
      j = mod(ixx, 177) + 2
      k = mod(jxx/169,178) + 1
      l = mod(jxx, 169)
      DO 3301 ii=1,97
        s = 0
        t = 8388608
        DO 3311 jj=1,24
          m = mod(mod(i*j,179)*k,179)
          IF (( fool_optimizer .EQ. 999 )) THEN
            write(6,*) i,j,k,m,s,t
          END IF
          i = j
          IF (( fool_optimizer .EQ. 999 )) THEN
            write(6,*) i,j,k,m,s,t
          END IF
          j = k
          IF (( fool_optimizer .EQ. 999 )) THEN
            write(6,*) i,j,k,m,s,t
          END IF
          k = m
          IF (( fool_optimizer .EQ. 999 )) THEN
            write(6,*) i,j,k,m,s,t
          END IF
          l = mod(53*l+1,169)
          IF (( fool_optimizer .EQ. 999 )) THEN
            write(6,*) i,j,k,m,s,t
          END IF
          IF((mod(l*m,64) .GE. 32))s = s + t
          IF (( fool_optimizer .EQ. 999 )) THEN
            write(6,*) i,j,k,m,s,t
          END IF
          t = t/2
          IF (( fool_optimizer .EQ. 999 )) THEN
            write(6,*) i,j,k,m,s,t
          END IF
3311    CONTINUE
3312    CONTINUE
        urndm(ii) = s
3301  CONTINUE
3302  CONTINUE
      crndm = 362436
      cdrndm = 7654321
      cmrndm = 16777213
      twom24 = 1./16777216.
      ixx = 97
      jxx = 33
      rng_seed = 128 + 1
      return
      end
      subroutine ranmar_get
      implicit none
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      integer*4 i,iopt
      IF((rng_seed .EQ. 999999))call init_ranmar
      DO 3321 i=1,128
        iopt = urndm(ixx) - urndm(jxx)
        IF((iopt .LT. 0))iopt = iopt + 16777216
        urndm(ixx) = iopt
        ixx = ixx - 1
        jxx = jxx - 1
        IF ((ixx .EQ. 0)) THEN
          ixx = 97
        ELSE IF(( jxx .EQ. 0 )) THEN
          jxx = 97
        END IF
        crndm = crndm - cdrndm
        IF((crndm .LT. 0))crndm = crndm + cmrndm
        iopt = iopt - crndm
        IF((iopt .LT. 0))iopt = iopt + 16777216
        rng_array(i) = iopt
3321  CONTINUE
3322  CONTINUE
      rng_seed = 1
      return
      end
      SUBROUTINE SRCRZ
      implicit none
      integer*4 LATCHM,NHSTRYM
      real*8 ZLASTM,EINM,WEIGHTM,XINM,YINM,UINM,VINM
      CHARACTER*5 LINE1
      integer*4 K,IB
      real*8 TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,TEMP6,TEMP7,TEMP8,TEMP9,FNORM
      character*80 filnam
      integer*4 ICORRL
      integer*8 TEMPDIV
      real*8 SCARG1,SCARG2,SCARG3,SCARG4
      integer*4 ICOUNT,IERROR
      real*8 RLAST
      real*8 WEIGHT
      integer*4 IBNSOK,I,IRDIST
      real*8 COTANG,FACTOR,GRIDSZ,AK
      integer*4 IRIN,NRCFLG
      real*8 XIN,YIN,ZIN,UIN,VIN,WIN
      integer*4 IX,IXIN,IZ,IZ1,LATCHI
      real*8 R2,D,PHI,WHICH,RNNO1,RNNO2,ZLAST
      integer*4 IZIN
      real*8 YTEMP,VTEMP,ZINC
      real*8 dist_phsp, theta_phsp, cost_phsp, sint_phsp, chamber_c, xof
     *fset, yoffset
      logical check
      integer*4 count_phsp
      real*8 tf,xtmp,ytmp,phbb,pha,phb,phd,radp
      integer*4 N_RUN_CHUNK
      character*80 the_beam_code, the_pegs_file, the_input_file
      integer*4 lnblnk1
      integer*8 tmp_mod
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      INTEGER NUM_IPART, NUM_SOURCE, NUM_SOPTS, NUM_MODEIN, NUM_RDFIL, N
     *UM_NRDIST, NUM_RDISTF, NUM_RPDF, NUM_RDIOUTSP, NUM_FILSPC, NUM_BEA
     *M_CODE, NUM_PEGS_FILE, NUM_IFILE, NUM_WW23, error_flag_save
      integer*4 MODEIN
      COMMON/GEOM/ZPLANE( 501),RCYL(0:4), CYRAD2(4),NTRACK( 2001),NZ,NR,
     *NREG,NPLANE
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NTRACK,NZ,NR,NREG,NPLANE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET,TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
     *, IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP( 2001),IVAL,DATCOUNT
      real*8 TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
      integer*4 IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP,IVAL,DATCOUN
     *T
      integer*8 NCASE,NCASEO,NCASET
      COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE
      integer*4 ICHPIN,ILPIN,IOUT,IPAGE
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/SCORE/ SCFLU(1000, 501,4,3,2), SCFLU2(1000, 501,4,3,2), SCE
     *AVE( 501,4,3,2), SCEAVE2( 501,4,3,2), SCEAVE_COV( 501,4,3,2),SCSTP
     *,SCSTP2,PIISTP, SCELEP( 501,4,2), SCELEP2( 501,4,2), SCELEP_COV( 5
     *01,4,2), SCFLEP(1000, 501,4,2), SCFLEP2(1000, 501,4,2), SCTFLU( 50
     *1,4,3,2), SCTFLU2( 501,4,3,2), SCTLEP( 501,4,2), SCTLEP2( 501,4,2)
     *, SCSTP_LAST,SCFLU_LAST(1000, 501,4,3,2), SCFLEP_LAST(1000, 501,4,
     *2), SCTFLU_LAST( 501,4,3,2), SCTLEP_LAST( 501,4,2), IHSTRY,SCFLU_T
     *MP(1000, 501,4,3,2), SCEAVE_TMP( 501,4,3,2), SCSTP_TMP,SCELEP_TMP(
     * 501,4,2), SCFLEP_TMP(1000, 501,4,2), SCTFLU_TMP( 501,4,3,2), SCTL
     *EP_TMP( 501,4,2), BINTOP(1000),SLOTE,ECUTMX,PCUTMX,EBINW(1000,3),
     *VOLUME(500,4),MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      REAL*8 SCFLU,SCFLU2,SCEAVE,SCEAVE2,SCEAVE_COV,SCSTP,SCSTP2, SCELEP
     *,SCELEP2,SCELEP_COV,SCFLEP,SCFLEP2,SCTFLU,SCTFLU2,SCTLEP, SCTLEP2,
     *PIISTP
      integer*8 SCSTP_LAST,SCFLU_LAST,SCFLEP_LAST,SCTFLU_LAST,SCTLEP_LAS
     *T,IHSTRY
      real*8 SCFLU_TMP,SCEAVE_TMP,SCSTP_TMP,SCELEP_TMP,SCFLEP_TMP, SCTFL
     *U_TMP,SCTLEP_TMP,BINTOP,SLOTE, ECUTMX,PCUTMX,EBINW,VOLUME
      integer*4 MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(4,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBEAM
     *,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DI
     *STZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PRO
     *BSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,ZS
     *OFST,                                                      SVTMP1,
     *SVTMP2,SVTMP3,SVTMP4,
     *       RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                     XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,WEI
     *GHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USERVR/ CEXPTR,GWAIT(150),DUMU,NP_INC(150),MAFORC,IFORCE,NF
     *MIN,NFMAX,NFTIME, ISOURC,IFPB,IQINC,MONOEN,IRODUM,IRNDUM,MEDDUM,ID
     *UM,MEDTMP, PATHL,DELTAP,GWTOLD,EPSLON,ARG
      real*8 CEXPTR,GWAIT,DUMU,PATHL,DELTAP,GWTOLD,EPSLON,ARG
      integer*4 NP_INC,MAFORC,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQIN
     *C, MONOEN,IRODUM,IRNDUM,MEDDUM,IDUM,MEDTMP
      COMMON/USERRR/
     *              CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,
     *                            EKETST,ELKETS,ZL,RL,CDIST,IGEOM,IRANGE
     *,MINZ,MAXZ,MINR,MAXR,IREJCT
      real*8 CRANGE,ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,EKETST,ELKETS
     *,ZL,RL,CDIST
      integer*4 MINZ,MAXZ,MINR,MAXR
      integer*4 IREJCT,IRANGE,IGEOM
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/RWPHSP/ STRING_TEMP_ZLAST_OUT,  STRING_TEMP_OUT,  IHSTRY_PH
     *SP,   iaea_dummy_long,  NHSTRY_DOS,   ESHORT,  WEIGHTTMP,  WT_PHSP
     *_SHORT,  X_PHSP_SHORT,  Y_PHSP_SHORT,  Z_PHSP_SHORT,  U_PHSP_SHORT
     *,  V_PHSP_SHORT,  W_PHSP_SHORT,  ZLAST_PHSP_SHORT,  MUIDX_PHSP_SHO
     *RT,  EKMAX_PHSP_SHORT,  EKMINE_PHSP_SHORT,  NINC_PHSP_SHORT,  dosx
     *yz2beam_index,  iaea_extra_floats,  NUM_PHSP_TOT,  PHOT_PHSP_TOT,
     *iaea_result,   iaea_n_stat,  iaea_q_typ,  iaea_typ_q,  iaea_q_inde
     *x,  I_PHSP,  IERR_PHSP,  LATCHTMP,  WRITE_PHSP_COUNTER,  WRITE_PHS
     *P_SOFAR,  PHSP_RESTART,  PHSP_RECL,  PHSP_RECL_OLD,  iaea_extra_in
     *ts,  iaea_extra_int_types,iaea_extra_float_types,   iaea_i_zlast,
     * iaea_i_latch,  iaea_i_muidx,  iaea_n_extra_ints,  iaea_n_extra_fl
     *oats,  i_iaea_open_for_write,   iaea_i_zlast_out,  iaea_i_latch_ou
     *t,  iaea_i_muidx_out,  dosxyz2beam_izscore,  MODE_RW
      CHARACTER*32000 STRING_TEMP_ZLAST_OUT(1)
      CHARACTER*28000 STRING_TEMP_OUT(1)
      integer*8 IHSTRY_PHSP(1),iaea_dummy_long,NHSTRY_DOS
      REAL*4 ESHORT,WEIGHTTMP,WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT, Z
     *_PHSP_SHORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,ZLAST_PHSP_SHO
     *RT, MUIDX_PHSP_SHORT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP
     *_SHORT,dosxyz2beam_index, iaea_extra_floats(10)
      INTEGER NUM_PHSP_TOT,PHOT_PHSP_TOT, iaea_result,iaea_n_stat,iaea_q
     *_typ(3),iaea_typ_q(3),iaea_q_index,I_PHSP, IERR_PHSP,LATCHTMP, WRI
     *TE_PHSP_COUNTER(1),WRITE_PHSP_SOFAR(1), PHSP_RESTART,PHSP_RECL,PHS
     *P_RECL_OLD,iaea_extra_ints(10), iaea_extra_int_types(10),iaea_extr
     *a_float_types(10),iaea_i_zlast, iaea_i_latch,iaea_i_muidx,iaea_n_e
     *xtra_ints,iaea_n_extra_floats, i_iaea_open_for_write,iaea_i_zlast_
     *out,iaea_i_latch_out, iaea_i_muidx_out,dosxyz2beam_izscore
      CHARACTER*5 MODE_RW
      INTEGER LATCH_TEMP_OUT,NUM_PHSP_TOFLUSH,TEMP_PHSP_COUNTER,REM_PHSP
      REAL*4 REAL_TEMP_OUT(7)
      CHARACTER*32 REC_TEMP_OUT
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*8 last_nhstry
      real*8 min_weight_23, max_weight_23, xin_tmp, yin_tmp, zin_tmp,Z_S
     *OURCE,MUIDX
      integer*4 secret_option_23,ilen,ismode,IMUPHSP,IZSCORE
      save TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,TEMP6,TEMP7,TEMP8,TEMP9,FNORM,I
     *BNSOK,MODEIN, dist_phsp, theta_phsp, cost_phsp, sint_phsp, chamber
     *_c,count_phsp, xoffset, yoffset, the_beam_code, the_pegs_file, the
     *_input_file, last_nhstry,min_weight_23, max_weight_23, secret_opti
     *on_23
      ENFLAG = 0
      WRITE(6,3330)
3330  FORMAT(/' *** Source inputs read by srcrz ***'/)
      WRITE(6,3340)
3340  FORMAT(' charge of the incident beam (-1,0,1 [& 2 with source 21])
     *,'/ ' source configuration'/ '      (0) parallel beam incident fro
     *m the front:(0),radius(cm)'/ '                      incident direc
     *tion cosines (U,V,W)'/ '   or (1) point source on axis incident fr
     *om the front(1)'/ '                      source to front face dist
     *ance,radius(cm)'/ '   or (2) broad parallel beam incident from the
     * front(2)'/ '                      no configuration input necessar
     *y,unit area beam'/ '   or (3) uniform isotropically radiating disk
     *(3)'/ '                      min,max radius, min,max Z'/ '   or (4
     *) axial fluence for various beam radii'/ '                      ra
     *dius of central axis region')
      WRITE(6,3350)
3350  FORMAT('   or (10) parallel beam incident from the side(10)'/ '   
     *                half-width,half-height of beam at center(cm)'/'   
     *or (11) point source incident from the side(11)'/ '           sour
     *ce to center distance(cm)'/ 'half-width,half-height of beam at cen
     *ter(cm)'/ '   or (12) point source incident from off axis(12)'/ ' 
     *                      perpendicular distance off central axis(cm)'
     */ '                       perpendicular distance from front face(c
     *m)'/ '   or (13) broad parallel beam incident from any angle:(13)'
     */ '                      incident direction cosines (U,V,W)'/ '   
     *or (14) point source on axisfrom front but restricted:(14),'/ '   
     *                   source to front face dist, outer,inner radius(c
     *m)'/ '   or (20) parallel beam incident from the front with radial
     * distribution'/ '   or (21)full phase-space on front: each particl
     *e read from unit 42'/ '                  file MODE (0. = default, 
     *2. with ZLAST as well),'/ '                      NRCYCL, IPARALLEL
     *, PARNUM'/ '   or (22)full phase-space from any angle: each partic
     *le read from unit 42'/'                      file MODE (0. = defau
     *lt, 2. with ZLAST aswell),'/ '                      distance from 
     *centre of source plane to point of'/ '                      rotati
     *on, angle of rotation about Z axis, Z offset'/ '                  
     *    of point of rotation, NRCYCL, IPARALLEL, PARNUM,'/ '          
     *            X offset of source, Y offset of source.'/ '   or (23) 
     *BEAM treatment headsimulation from any angle: name of BEAM'/ '    
     *                  simulation (eg BEAM_accelname), name of BEAM inp
     *ut'/ '         file (no .egsinp extension), name of BEAM pegs data
     *'/ '                    (no .pegs4dat extension), min. and max. we
     *ights of'/ '                      particles to use (defaults to -1
     *e30- 1e30),'/ '                      distance from centre of BEAM 
     *scoring plane to point of'/ '                      rotation, angle
     * of rotation about Z axis, Z offset'/ '                      of po
     *int of rotation, X offset of source, Y offset'/ '  of source.'//)
      DELIMETER='SOURCE INPUTS'
      IVAL = IVAL + 1
      NUM_IPART = IVAL
      VALUES_SOUGHT(IVAL)='INCIDENT PARTICLE'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      DEFAULT(IVAL)=0
      ALLOWED_INPUTS(IVAL,4)='ELECTRON'
      ALLOWED_INPUTS(IVAL,0)='PHOTON'
      ALLOWED_INPUTS(IVAL,1)='POSITRON'
      ALLOWED_INPUTS(IVAL,2)='ALL'
      ALLOWED_INPUTS(IVAL,3)='CHARGED'
      NMIN = NUM_IPART
      NMAX = NUM_IPART
      CALL GET_INPUT
      IVAL = IVAL + 1
      NUM_SOURCE = IVAL
      VALUES_SOUGHT(IVAL)='SOURCE NUMBER'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=23
      DEFAULT(IVAL)=0
      NMIN = NUM_SOURCE
      NMAX = NUM_SOURCE
      CALL GET_INPUT
      ISOURC=VALUE(NUM_SOURCE,1)
      IF ((ISOURC.NE.20)) THEN
        IVAL = IVAL + 1
        NUM_SOPTS = IVAL
        VALUES_SOUGHT(IVAL)='SOURCE OPTIONS'
        IF ((ISOURC.EQ.22)) THEN
          NVALUE(IVAL)=9
        ELSE IF(( ISOURC.EQ.23 )) THEN
          NVALUE(IVAL)=5
        ELSE
          NVALUE(IVAL)=4
        END IF
        TYPE(IVAL)=1
        VALUE_MIN(IVAL)=-999999
        VALUE_MAX(IVAL)=999999
        DEFAULT(IVAL)=1
        NMIN = NUM_SOPTS
        NMAX = NUM_SOPTS
        CALL GET_INPUT
        TEMP1=VALUE(NUM_SOPTS,1)
        TEMP2=VALUE(NUM_SOPTS,2)
        TEMP3=VALUE(NUM_SOPTS,3)
        TEMP4=VALUE(NUM_SOPTS,4)
        IF ((ISOURC.EQ.22)) THEN
          TEMP5=VALUE(NUM_SOPTS,5)
          TEMP6=VALUE(NUM_SOPTS,6)
          TEMP7=VALUE(NUM_SOPTS,7)
          TEMP8=VALUE(NUM_SOPTS,8)
          TEMP9=VALUE(NUM_SOPTS,9)
        END IF
        IF((ISOURC.EQ.23))TEMP5=VALUE(NUM_SOPTS,5)
      END IF
      IQIN=VALUE(NUM_IPART,1)
      IF ((IQIN.EQ.4)) THEN
        IQIN=-1
      END IF
      WRITE(*,*)' IQIN ',IQIN
      IF ((ISOURC.EQ.20)) THEN
        IVAL = IVAL + 1
        NUM_MODEIN = IVAL
        VALUES_SOUGHT(IVAL)='MODEIN'
        NVALUE(IVAL)=1
        TYPE(IVAL)=3
        DEFAULT(IVAL)=1
        ALLOWED_INPUTS(IVAL,0)='LOCAL'
        ALLOWED_INPUTS(IVAL,1)='EXTERNAL'
        NMIN = NUM_MODEIN
        NMAX = NUM_MODEIN
        CALL GET_INPUT
        MODEIN=VALUE(NUM_MODEIN,1)
        IF ((MODEIN.EQ.1)) THEN
          IVAL = IVAL + 1
          NUM_RDFIL = IVAL
          VALUES_SOUGHT(IVAL)='RDIST FILENAME'
          NVALUE(IVAL)=1
          TYPE(IVAL)=2
          NMIN = NUM_RDFIL
          NMAX = NUM_RDFIL
          CALL GET_INPUT
        ELSE
          IVAL = IVAL + 1
          NUM_NRDIST = IVAL
          VALUES_SOUGHT(IVAL)='NRDIST'
          NVALUE(IVAL)=1
          TYPE(IVAL)=0
          VALUE_MIN(IVAL)=1
          VALUE_MAX(IVAL)=100
          DEFAULT(IVAL)=1
          NMIN = NUM_NRDIST
          NMAX = NUM_NRDIST
          CALL GET_INPUT
          NRDIST=VALUE(NUM_NRDIST,1)
          IVAL = IVAL + 1
          NUM_RDISTF = IVAL
          VALUES_SOUGHT(IVAL)='RDISTF'
          NVALUE(IVAL)=NRDIST
          TYPE(IVAL)=1
          VALUE_MIN(IVAL)=0
          VALUE_MAX(IVAL)=999999
          DEFAULT(IVAL)=1.0
          IVAL = IVAL + 1
          NUM_RPDF = IVAL
          VALUES_SOUGHT(IVAL)='RPDF'
          NVALUE(IVAL)=NRDIST
          TYPE(IVAL)=1
          VALUE_MIN(IVAL)=0
          VALUE_MAX(IVAL)=999999
          DEFAULT(IVAL)=1.0
          NMIN=NUM_NRDIST
          NMAX=NUM_RPDF
          NMIN = NMIN
          NMAX = NMAX
          CALL GET_INPUT
        END IF
        IVAL = IVAL + 1
        NUM_RDIOUTSP = IVAL
        VALUES_SOUGHT(IVAL)='RDIST IOUTSP'
        NVALUE(IVAL)=1
        TYPE(IVAL)=3
        DEFAULT(IVAL)=0
        ALLOWED_INPUTS(IVAL,0)='NONE'
        ALLOWED_INPUTS(IVAL,1)='INCLUDE'
        NMIN = NUM_RDIOUTSP
        NMAX = NUM_RDIOUTSP
        CALL GET_INPUT
      END IF
      IF (((ISOURC.EQ.21).OR.(ISOURC.EQ.22))) THEN
        IVAL = IVAL + 1
        NUM_FILSPC = IVAL
        VALUES_SOUGHT(IVAL)='FILSPC'
        TYPE(IVAL)=2
        NMIN = NUM_FILSPC
        NMAX = NUM_FILSPC
        CALL GET_INPUT
      END IF
      IF (( ISOURC .EQ. 23 )) THEN
        IVAL = IVAL + 1
        NUM_BEAM_CODE = IVAL
        VALUES_SOUGHT(IVAL)='BEAM CODE'
        TYPE(IVAL)=2
        IVAL = IVAL + 1
        NUM_PEGS_FILE = IVAL
        VALUES_SOUGHT(IVAL)='PEGS FILE'
        TYPE(IVAL)=2
        IVAL = IVAL + 1
        NUM_IFILE = IVAL
        VALUES_SOUGHT(IVAL)='INPUT FILE'
        TYPE(IVAL)=2
        NMIN = NUM_BEAM_CODE
        NMAX = NUM_IFILE
        CALL GET_INPUT
        IVAL = IVAL + 1
        VALUES_SOUGHT(IVAL)='SECRET'
        nvalue(ival) = 1
        type(ival) = 3
        allowed_inputs(ival,0) = 'no'
        allowed_inputs(ival,1) = 'yes'
        IVAL = IVAL + 1
        NUM_WW23 = IVAL
        VALUES_SOUGHT(IVAL)='WEIGHT WINDOW'
        NVALUE(IVAL)=2
        TYPE(IVAL)=1
        VALUE_MIN(IVAL)=-1e30
        VALUE_MAX(IVAL)= 1e30
        error_flag_save = error_flag
        NMIN = NUM_WW23-1
        NMAX = NUM_WW23
        CALL GET_INPUT
        error_flag = error_flag_save
        IF (( error_flags(NUM_BEAM_CODE) .EQ. 0 )) THEN
          READ (CHAR_VALUE(NUM_BEAM_CODE,1),FMT='(A)') the_beam_code
        ELSE
          error_flag = 1
        END IF
        IF (( error_flags(NUM_PEGS_FILE) .EQ. 0 )) THEN
          READ (CHAR_VALUE(NUM_PEGS_FILE,1),FMT='(A)') the_pegs_file
        ELSE
          error_flag = 1
        END IF
        IF (( error_flags(NUM_IFILE) .EQ. 0 )) THEN
          READ (CHAR_VALUE(NUM_IFILE,1),FMT='(A)') the_input_file
        ELSE
          error_flag = 1
        END IF
        min_weight_23 = -1e30
        max_weight_23 = 1e30
        secret_option_23 = 0
        IF (( error_flags(NUM_WW23) .EQ. 0 )) THEN
          min_weight_23 = value(num_ww23,1)
          max_weight_23 = value(num_ww23,2)
        END IF
        IF (( error_flags(NUM_WW23-1) .EQ. 0 )) THEN
          secret_option_23 = value(NUM_WW23-1,1)
        END IF
      END IF
      IF ((ISOURC.EQ.20)) THEN
        IF ((MODEIN.EQ.1)) THEN
          READ (CHAR_VALUE(NUM_RDFIL,1),FMT='(A)') FILNAM
        ELSE
          NRDIST=VALUE(NUM_NRDIST,1)
          DO 3361 K=1,NRDIST
            RDISTF(K)=VALUE(NUM_RDISTF,K)
            RPDF(K)=VALUE(NUM_RPDF,K)
3361      CONTINUE
3362      CONTINUE
        END IF
        IOUTSP=VALUE(NUM_RDIOUTSP,1)
      END IF
      IF (((ISOURC .EQ. 21) .OR. (ISOURC .EQ. 22))) THEN
        READ (CHAR_VALUE(NUM_FILSPC,1),FMT='(256A1)') FILSPC
      END IF
      WRITE(6,3370)IQIN,ISOURC,TEMP1,TEMP2,TEMP3,TEMP4
3370  FORMAT(T10,'SRCRZ read:', 2I5,4F12.5)
      IF((ISOURC.EQ.22))WRITE(6,3380)TEMP5,TEMP6,TEMP7,TEMP8,TEMP9
3380  FORMAT(T10,'           ',5F12.5)
      IF(((IQIN .LT. -1) .OR. (IQIN .GT. 1 .AND. (ISOURC .LT. 21 .OR. IS
     *OURC .GT. 23)) .OR. (IQIN .GT. 3 .AND. (ISOURC .LT. 21 .OR. ISOURC
     * .GT. 23))))IQIN = 0
      SVTMP1=TEMP1
      SVTMP2=TEMP2
      SVTMP3=TEMP3
      SVTMP4=TEMP4
      RETURN
      ENTRY SRCINI(SCARG1,SCARG2,SCARG3,SCARG4,ICORRL)
      NHSTRY=0
      last_nhstry = 0
      IF ((ISOURC .EQ. 0)) THEN
        RBEAM=TEMP1
        FNORM=TEMP2**2+TEMP3**2+TEMP4**2
        IF ((FNORM.EQ.0.0)) THEN
          UINC=0.0
          VINC=0.0
          WINC=1.0
        ELSE
          FNORM=SQRT(FNORM)
          UINC=TEMP2/FNORM
          VINC=TEMP3/FNORM
          WINC=TEMP4/FNORM
        END IF
        TEMP5=RCYL(NR)
        IF(((RBEAM.LE.0.0).OR.(RBEAM.GT.TEMP5)))RBEAM=TEMP5
        WRITE(6,3390)IQIN,RBEAM,UINC,VINC,WINC
3390    FORMAT(/' Electric charge of the source:',T60,I12/ ' Parallel be
     *am incident from the front(+ve Z-axis)'/ ' Radius of beam at the f
     *ront face of the target:',T60,F10.4,' cm'/ ' X-axis direction cosi
     *ne:',T60,F10.4/ ' Y-axis direction cosine:',T60,F10.4/ ' Z-axis di
     *rection cosine:',T60,F10.4/)
      ELSE IF((ISOURC.EQ.1)) THEN
        DISTZ=TEMP1
        RBEAM=TEMP2
        TEMP3=RCYL(NR)
        IF((DISTZ.LE.0.0))DISTZ=100.
        IF(((RBEAM.LE.0.0).OR.(RBEAM.GT.TEMP3)))RBEAM=TEMP3
        WRITE(6,3400)IQIN,DISTZ,RBEAM
3400    FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' POINT SOURC
     *E ON AXIS INCIDENT FROM THE FRONT(+VE Z-AXIS)'/ ' SOURCE DISTANCET
     *O THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/ ' RADIUS OF THE 
     *BEAM ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/)
      ELSE IF((ISOURC.EQ.2)) THEN
        RBEAM=0.0
        NR=1
        NREG=NPLANE
        RCYL(1)=1000.0
        CYRAD2(1)=1.0E6
        WRITE(6,3410)IQIN,RBEAM
3410    FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' BROAD PARAL
     *LEL BEAM INCIDENT FROM THE FRONT (+VE Z-AXIS)'/ ' RADIUS OF THE BE
     *AM ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/)
        IF ((NMED.NE.1)) THEN
          WRITE(6,3420)
3420      FORMAT(/' **** ALL REGIONS IN A SLAB MUST BE SAME MATERIAL****
     ***'/)
        END IF
      ELSE IF((ISOURC .EQ. 3)) THEN
        RBEAM=TEMP2
        IF ((RBEAM .GT. RCYL(NR))) THEN
          WRITE(6,3430)RBEAM, RCYL(NR)
3430      FORMAT(//' ***  Source radius too big at',F10.3,' Reduced to',
     *F10.3,' cm')
          RBEAM = RCYL(NR)
        END IF
        RBEAM2 = RBEAM**2
        RMINBM = TEMP1
        IF ((RMINBM .GT. RBEAM)) THEN
          RMINBM=RBEAM
        END IF
        RMINSQ = RMINBM**2
        ZSMIN=TEMP3
        ZSMAX=TEMP4
        IF ((ZSMIN .LT. ZPLANE(1))) THEN
          ZSMIN= ZPLANE(1)
        END IF
        IF ((ZSMAX .GT. ZPLANE(NPLANE))) THEN
          ZSMAX = ZPLANE(NPLANE)
        END IF
        WRITE(6,3440)IQIN,RMINBM,RBEAM,ZSMIN,ZSMAX
3440    FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' UNIFORM ISO
     *TROPICALLY RADIATING RING: INNER,OUTER Radius',2F10.3 / '  FRONT,B
     *ack DEPTH:',T50,2F10.3 /)
      ELSE IF((ISOURC .EQ. 4)) THEN
        RBEAM=TEMP1
        IF ((RCYL(NR).LT.650.)) THEN
          IF ((NR.LT.4)) THEN
            NR=NR+1
            NREG=NZ*NR+1
          ELSE
            WRITE(6,3450)
3450        FORMAT(/' ***WARNING***  LAST RADIAL BIN INCREASED TO 1000cm
     *'/)
          END IF
          RCYL(NR)=1000.0
          CYRAD2(NR)=1.0E6
        END IF
        IF(((RBEAM.LE.0.0).OR.(RBEAM.GT.RCYL(NR))))RBEAM=RCYL(NR)
        WRITE(6,3460)IQIN,RBEAM
3460    FORMAT(/' ELECTRIC CHARGE OF BEAM:',T60,I12/ ' CENTRAL AXIS FLUE
     *NCE VS BEAM RADIUS'/ ' RADII INPUT ABOVE WILL BE CONSIDERED AS BEA
     *M RADII'/ ' RADIUS OF CENTRAL AXIS ZONE: ',T60,F10.4,' cm'/)
        IF ((NMED.NE.1)) THEN
          WRITE(6,3470)
3470      FORMAT(/' **** ALL REGIONS IN A SLAB MUST BE SAME MATERIAL****
     ***'/)
        END IF
      ELSE IF((ISOURC .EQ. 10)) THEN
        XBEAM=TEMP1
        ZBEAM=TEMP2
        TEMP3=RCYL(NR)
        IF(((XBEAM.LE.0.0).OR.(XBEAM.GT.TEMP3)))XBEAM=TEMP3
        TEMP3=0.5*(ZPLANE(NPLANE)-ZPLANE(1))
        IF(((ZBEAM.LE.0.0).OR.(ZBEAM.GT.TEMP3)))ZBEAM=TEMP3
        WRITE(6,3480)IQIN,XBEAM,ZBEAM
3480    FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' PARALLEL BE
     *AM INCIDENT FROM THE SIDE'/ ' HALF-WIDTH(X-AXIS) OF THE BEAM AT TH
     *E TARGET MIDPOINT',T60,F10.4,' cm'/ ' HALF-HEIGHT(Z-AXIS/) OF THEB
     *EAM AT THE TARGET MIDPOINT', T60,F10.4,' cm'/)
      ELSE IF((ISOURC .EQ. 11)) THEN
        DISTRH = TEMP1
        IF((DISTRH .LT. 0.0))DISTRH=-DISTRH
        IF((DISTRH .EQ. 0.0))DISTRH=100.0
        XBEAM = TEMP2
        ZBEAM = TEMP3
        TEMP4 = RCYL(NR)
        IF ((DISTRH .LE. TEMP4)) THEN
          WRITE(6,3490)
3490      FORMAT(' SOURCE FROM WITHIN TARGET, INPUT IGNORED')
          ERROR_FLAG=1
        END IF
        TEMP4=TEMP4*SQRT((DISTRH+TEMP4)*(DISTRH-TEMP4))/DISTRH
        IF(((XBEAM .LE. 0.0) .OR. (XBEAM .GT. TEMP4)))XBEAM=TEMP4
        TEMP4=0.5*(ZPLANE(NPLANE)-ZPLANE(1))
        IF(((ZBEAM .LE. 0.0) .OR. (ZBEAM .GT. TEMP4)))ZBEAM=TEMP4
        IF ((ICORRL .EQ. 0)) THEN
          WRITE(6,3500)IQIN,DISTRH,XBEAM,ZBEAM
3500      FORMAT(/' Electric charge of the source:',T60,I12/ ' Point sou
     *rce on axis incident from the side(Y-axis)'/ ' Source distance tot
     *arget midpoint:',T60,F10.4,' cm'/ ' Half-width(X-axis) of the beam
     * at the target midpoint',T60,F10.4,' cm'/ ' Half-height(Z-axis/)of
     * the beam at the target midpoint', T60,F10.4,' cm'/)
        END IF
      ELSE IF((ISOURC .EQ. 12)) THEN
        DISTRH=TEMP1
        IF((DISTRH .LT. 0.0))DISTRH=-DISTRH
        DISTZ=TEMP2
        RBEAM=RCYL(NR)
        IF ((DISTRH .GT. RBEAM)) THEN
          XBEAM=RBEAM*SQRT((DISTRH-RBEAM)*(DISTRH+RBEAM))/DISTRH
          ZBEAM=0.5*(ZPLANE(NPLANE)-ZPLANE(1))
        ELSE
          XBEAM=0.0
          ZBEAM=0.0
        END IF
        IF (((DISTRH .LE. RBEAM) .AND. DISTZ .GE. ZPLANE(1)-ZPLANE(NPLAN
     *  E) .AND. DISTZ.LE.0.0)) THEN
          WRITE(6,3510)
3510      FORMAT(' Source from within target, input ignored')
          ERROR_FLAG=1
        END IF
        WRITE(6,3520)IQIN,DISTRH,DISTZ,RBEAM,XBEAM,ZBEAM
3520    FORMAT(/' Electric charge of the source:',T60,I12/ ' Point sourc
     *e off axis'/ ' Distance of source off the central axis',T60,F10.4,
     *' cm'/ ' Perpendicular distance of source from front plane',T60,F1
     *0.4,' cm'/ ' Radius of the beam on the front face of the target:',
     *T60,F10.4,' cm'/ ' Half-width(X-axis) of the beam between thetange
     *nt points', T60,F10.4,' cm'/ ' Half-height(z-axis) of the beam bet
     *ween the tangent points', T60,F10.4,' cm'/)
      ELSE IF((ISOURC .EQ. 13)) THEN
        FNORM=TEMP1**2+TEMP2**2+TEMP3**2
        IF ((FNORM .EQ. 0.0)) THEN
          UINC=0.0
          VINC=0.0
          WINC=1.0
        ELSE
          FNORM=SQRT(FNORM)
          WINC=TEMP3/FNORM
          VINC=-SQRT((1.0-WINC)*(1.0+WINC))
          UINC=0.0
        END IF
        RBEAM=RCYL(NR)
        IF ((ABS(WINC).NE.1.0)) THEN
          XBEAM=RBEAM
          ZBEAM=0.5*(ZPLANE(NPLANE)-ZPLANE(1))
        ELSE
          XBEAM=0.0
          ZBEAM=0.0
        END IF
        WRITE(6,3530)IQIN,UINC,VINC,WINC,RBEAM,XBEAM,ZBEAM
3530    FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' PARALLEL BE
     *AM AT ANY ANGLE WITH RESPECT TO THE TARGET'/ ' X-AXIS DIRECTION CO
     *SINE:',T60,F10.4/ ' Y-AXIS DIRECTION COSINE:',T60,F10.4/ ' Z-AXISD
     *IRECTION COSINE:',T60,F10.4/ ' RADIUS OF THE BEAM ON THE FRONT FAC
     *E OF THE TARGET:',T60,F10.4,' cm'/ ' HALF-WIDTH(X-AXIS) OF THE BEA
     *M BETWEEN THE TANGENT POINTS', T60,F10.4,' cm'/ ' HALF-HEIGHT(Z-AX
     *IS) OF THE BEAM BETWEEN THE TANGENT POINTS', T60,F10.4,' cm'/)
      ELSE IF((ISOURC .EQ. 14)) THEN
        DISTZ=TEMP1
        RBEAM=TEMP2
        RMINBM=TEMP3
        IF((DISTZ.LE.0.0))DISTZ=100.
        IF(((RBEAM.LE.0.0).OR.(RBEAM.GT.RCYL(NR))))RBEAM=RCYL(NR)
        IF ((RMINBM.EQ.0.0)) THEN
          WRITE(6,3540)
3540      FORMAT(/' ***WHY USE ISOURC=14 WITH RMINB=0.0?***')
        END IF
        WRITE(6,3550)IQIN,DISTZ,RBEAM,RMINBM
3550    FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' POINT SOURC
     *E ON AXIS INCIDENT FROM THE FRONT(+VE Z-AXIS)'/ ' SOURCE DISTANCET
     *O THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/ ' RADIUS OF THE 
     *BEAM ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/ ' INNER RA
     *DIUS OF BEAM ON FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/)
      ELSE IF((ISOURC .EQ. 15)) THEN
        call src15_ini(temp1,temp2,temp3,temp4,ERROR_FLAG)
      ELSE IF((ISOURC .EQ. 16)) THEN
        call src16_ini(temp1,temp2,temp3,temp4,ERROR_FLAG)
      ELSE IF((ISOURC .EQ. 17)) THEN
        DISTZ=TEMP1
        XBEAM=TEMP2
        YBEAM=TEMP3
        TEMP4=RCYL(NR)
        IF((DISTZ.LE.0.0))DISTZ=100.
        IF(((RBEAM.LE.0.0).OR.(RBEAM.GT.TEMP4)))RBEAM=TEMP4
        WRITE(6,3560)IQIN,DISTZ,XBEAM,YBEAM
3560    FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' POINT SOURC
     *E ON AXIS INCIDENT FROM THE FRONT(+VE Z-AXIS)'/ ' SOURCE DISTANCET
     *O THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/ ' X-AXIS HALF-WI
     *DTH ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/ ' Y-AXIS HA
     *LF-WIDTH ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/)
      ELSE IF((ISOURC .EQ. 20)) THEN
        WRITE(6,3570)
3570    FORMAT(' Local input(0) or external file(1): ',$)
        WRITE(6,3580)
3580    FORMAT(/' RADIAL DISTRIBUTION:')
        IF ((MODEIN.EQ.0)) THEN
          WRITE(6,3590)
3590      FORMAT(' Number of radial bins: ',$)
          IF (((NRDIST.LT.1).OR.(NRDIST.GT.100))) THEN
            WRITE(6,3600)
3600        FORMAT(/' *** NUMBER RADIAL BINS OUT OF RANGE (<1 OR >100),'
     *, ' RESET TO 100 ***')
            NRDIST=100
          END IF
          WRITE(6,3610)NRDIST
3610      FORMAT(' INPUT',I4,' SETS OF RDISTF,RPDF IN 2F20.0 FORMAT')
          WRITE(6,3620)
3620      FORMAT('   RDISTF INCREASING IN SIZE, RPDF NON-NEGATIVE')
          DO 3631 IB=1,NRDIST
3631      CONTINUE
3632      CONTINUE
        ELSE
          WRITE(6,3640)
3640      FORMAT(' Input name of file with spectrum (up to 80 char with.
     *ext): '/)
          WRITE(6,3650)FILNAM
3650      FORMAT(/' Read input radial distribution from: '/80A1)
          call replace_env(FILNAM)
          OPEN(UNIT=9,file=filnam,STATUS='OLD')
          READ(9,*)NRDIST
          IF (((NRDIST.LT.1).OR.(NRDIST.GT.100))) THEN
            WRITE(6,3660)
3660        FORMAT(' *** Number radial bins out of range (<1 OR >100),',
     *' RESET TO 100 ***')
            NRDIST=100
          END IF
          DO 3671 IB=1,NRDIST
            READ(9,*)RDISTF(IB),RPDF(IB)
3671      CONTINUE
3672      CONTINUE
          CLOSE(UNIT=9)
          WRITE(6,3680)NRDIST
3680      FORMAT('    HAVE READ',I5,' INPUT RADIAL BINS FROM FILE')
        END IF
        ICOUNT=0
        RLAST=0
        IERROR=0
3690    CONTINUE
3691      CONTINUE
          ICOUNT=ICOUNT+1
          IF ((ICOUNT.GT.NRDIST)) THEN
            GO TO 3692
          END IF
          IF ((RDISTF(ICOUNT).LE.RLAST)) THEN
            IERROR=1
            WRITE(6,3700)
3700        FORMAT(' *** RDISTF>=LAST ONE. NOT ALLOWED,', ' TERMINATINGR
     *ADIAL DISTRIBUTION INPUT.')
          ELSE IF((RDISTF(ICOUNT).GT.RCYL(NR))) THEN
            IERROR=1
            WRITE(6,3710)RCYL(NR)
3710        FORMAT(' *** RDISTF>',G14.7,', GEOMETRY SIZE.', ' TERMINATIN
     *G RADIAL DISTRIBUTION INPUT')
          ELSE IF((RPDF(ICOUNT).LT.0.0)) THEN
            IERROR=1
            WRITE(6,3720)
3720        FORMAT(' PDF < 0 NOT ALLOWED,', ' TERMINATING RADIAL DISTRIB
     *UTION INPUT')
          END IF
          IF ((IERROR.EQ.1)) THEN
            ICOUNT=ICOUNT-1
            IF ((ICOUNT.EQ.0)) THEN
              WRITE(6,3730)
3730          FORMAT(' *** NO RADIAL DISTRIBUTION DEFINED,', ' STOPPINGE
     *XECUTION ***')
              STOP
            END IF
            WRITE(6,3740)ICOUNT
3740        FORMAT(' RADIAL DITRIBUTION INPUT APPEARS TO BE INCOMPLETE,'
     *, ' NRDIST RESET TO ',I12)
            NRDIST=ICOUNT
            GO TO 3692
          END IF
          RLAST=RDISTF(ICOUNT)
        GO TO 3691
3692    CONTINUE
        WRITE(6,3750)RDISTF(NRDIST)
3750    FORMAT('    RADIAL DISTRIBUTION RANGES FROM 0 TO',F12.3,' cm')
        WRITE(6,3760)
3760    FORMAT(' PRINT DISTRIBUTION DATA IN OUTPUT SUMMARY, YES(1) OF NO
     *(0): ',$)
        IF((IOUTSP.NE.1))IOUTSP=0
        WRITE(6,'('' '')')
      ELSE IF(( ISOURC .EQ. 23 )) THEN
        dist_phsp = temp1
        theta_phsp = temp2
        cost_phsp = cos(theta_phsp*0.017453292222)
        sint_phsp = sin(theta_phsp*0.017453292222)
        chamber_c = temp3
        xoffset = temp4
        yoffset = temp5
        ENFLAG=1
        iqinc = iqin
        WRITE(6,3770)iqinc,min_weight_23,max_weight_23, the_beam_code(:l
     *  nblnk1(the_beam_code)),the_pegs_file(:lnblnk1(the_pegs_file)), t
     *  he_input_file(:lnblnk1(the_input_file)), dist_phsp,theta_phsp,ch
     *  amber_c,xoffset,yoffset
3770    FORMAT(/' Full treatment head simulation from an angle'/, '    P
     *article charge                               : ',i3,/ '    Weightw
     *indow                                 : ',2g15.6,/ '    BEAMnrc us
     *er code                             : ',a,/ '    PEGS data file   
     *                           : ',a,/ '    Input file                
     *       : ',a,/ '    Rotation point to phsp-plane midpoint distance
     *: ',f10.4,/ '    Incident angle (degrees)             : ',f10.4,/ 
     *'    Rotation point (will be set to chamber center'/, '      if gr
     *eater than 1e4 or less than -1e4):     :',g14.4, ' cm.'/ '    X of
     *fset of phsp plane (before rotation)  : ',f10.4,' cm'/ '    Y offs
     *et of phsp plane (before rotation)    : ',f10.4,' cm')
        write(6,'(//a)') 'About to call init_beamsource'
        call init_beamsource(i_parallel,n_parallel,i_log,'linux', hen_ho
     *  use,egs_home,the_beam_code, the_pegs_file,the_input_file)
        call maxenergy_beamsource(EKSRCM)
        EIN=EKSRCM
        WRITE(6,3780)EKSRCM
3780    FORMAT('    Max. kinetic energy of simulation             : ',f1
     *0.4,' MeV'/)
      ELSE IF(((ISOURC .EQ. 21) .OR. (ISOURC .EQ. 22))) THEN
        IQINC=IQIN
        IF ((ISOURC .EQ. 22)) THEN
          dist_phsp=TEMP2
          theta_phsp = temp3
          cost_phsp = cos(theta_phsp*0.017453292222)
          sint_phsp = sin(theta_phsp*0.017453292222)
          chamber_c = temp4
          count_phsp = 0
          xoffset = TEMP8
          yoffset = TEMP9
        END IF
        IMODE=TEMP1
        IF ((ISOURC.EQ.21)) THEN
          NRCYCL=TEMP2
          IPARALLEL=TEMP3
          PARNUM=TEMP4
        ELSE IF((ISOURC.EQ.22)) THEN
          NRCYCL=TEMP5
          IPARALLEL=TEMP6
          PARNUM=TEMP7
        END IF
        IF((IMODE.NE.2))IMODE=0
        WRITE(6,3790)IMODE
3790    FORMAT(/' MODE',I2,' Phase-space file to be read from unit 42...
     *'/ ' Input name of file with phase space data (1 - 80 CHARS,', 'wi
     *th .EXT): ')
        WRITE(6,3800)FILSPC
3800    FORMAT(/' Reading phase space information from: '/10x,256A1)
        call replace_env(SPCNAM)
        i_iaea_in=0
        ilen=lnblnk1(SPCNAM)
        IF ((SPCNAM(ilen-8:ilen).EQ.'.IAEAphsp')) THEN
          i_iaea_in=1
          SPCNAM=SPCNAM(:ilen-9)
        END IF
        IF ((i_iaea_in.EQ.1)) THEN
          i_unit_in=42
          call iaea_new_source(i_unit_in,SPCNAM,1,iaea_result)
          IF ((iaea_result.LT.0)) THEN
            WRITE(i_log,*)' Error opening IAEA phase space source.'
          END IF
          call iaea_get_max_particles(i_unit_in,-1,iaea_dummy_long)
          NCASE_PHSP=iaea_dummy_long
          call iaea_get_max_particles(i_unit_in,1,iaea_dummy_long)
          NPHOTPHSP=iaea_dummy_long
          call iaea_get_total_original_particles(i_unit_in,iaea_dummy_lo
     *    ng)
          NINCSRC=iaea_dummy_long
          call iaea_get_maximum_energy(i_unit_in,EKMAX_PHSP_SHORT)
          TEMP2=EKMAX_PHSP_SHORT
          call iaea_get_constant_variable(i_unit_in,2,Z_PHSP_SHORT,iaea_
     *    result)
          IF ((iaea_result.EQ.-3)) THEN
            write(i_log,*) ' Z positions of each particle will be read f
     *rom phase space data.'
            Z_SOURCE=999.
            IZSCORE=1
          ELSE IF((iaea_result.LT.0)) THEN
            write(i_log,*)' Error reading Z position where IAEA phsp was
     * scored.'
            IZSCORE=0
          ELSE
            Z_SOURCE=Z_PHSP_SHORT
            IZSCORE=0
          END IF
          call iaea_get_extra_numbers(i_unit_in,iaea_n_extra_floats,iaea
     *    _n_extra_ints)
          IF ((iaea_n_extra_floats .EQ. -1 .OR. iaea_n_extra_ints .EQ. -
     *    1)) THEN
            write(i_log,*)' Error reading number of extra variables stor
     *ed in IAEA phsp'
          END IF
          call iaea_get_type_extra_variables(i_unit_in,iaea_result,iaea_
     *    extra_int_types, iaea_extra_float_types)
          IF ((iaea_result.EQ.-1)) THEN
            write(i_log,*)' Error getting types of extra variables store
     *d in IAEA phsp'
          END IF
          DO 3811 I_PHSP=1,iaea_n_extra_ints
            IF ((iaea_extra_int_types(I_PHSP).EQ.2)) THEN
              iaea_i_latch=I_PHSP
              GO TO3812
            END IF
3811      CONTINUE
3812      CONTINUE
          IF ((iaea_i_latch.EQ.-99)) THEN
            write(i_log,*)' Warning: IAEA format phsp file does not stor
     *e LATCH'
          END IF
          DO 3821 I_PHSP=1,iaea_n_extra_floats
            IF ((iaea_extra_float_types(I_PHSP).EQ.3)) THEN
              iaea_i_zlast=I_PHSP
              GO TO3822
            END IF
3821      CONTINUE
3822      CONTINUE
          IF ((iaea_i_zlast.EQ.-99)) THEN
            ismode=0
          ELSE
            ismode=1
          END IF
          iaea_i_muidx=MAX(1,iaea_i_zlast+1)
          IF ((iaea_i_muidx.GT.iaea_n_extra_floats .OR. iaea_extra_float
     *    _types(iaea_i_muidx).NE.0)) THEN
            iaea_i_muidx=-99
            IMUPHSP=0
          ELSE
            IMUPHSP=1
          END IF
          WRITE(6,3830)NCASE_PHSP,NPHOTPHSP,TEMP2,NINCSRC
3830      FORMAT(T10,' IAEA format Phase space source with:'/ T5,'      
     *        Total number of particles =',I13/ T5,'              Number
     * of photons =',I13/ T5,'              Maximumparticle kinetic ener
     *gy =',F13.3,' MeV'/ T5,' # of particles incident from original sou
     *rce =',F13.1/)
          IF ((IZSCORE.EQ.0)) THEN
            WRITE(6,3840)Z_SOURCE
3840        FORMAT(T5,'                        Z where source scored =',
     *F13.3,' cm'/)
          END IF
          call iaea_check_file_size_byte_order(i_unit_in,iaea_result)
          IF ((iaea_result.EQ.-3)) THEN
            WRITE(i_log,*)' ERROR: Size of phase space file does not mat
     *ch'
            WRITE(i_log,*)' the value of checksum in the header.  Someth
     *ing may be'
            WRITE(i_log,*)' wrong.  Check your file.'
            call exit(1)
          ELSE IF((iaea_result.EQ.-4)) THEN
            WRITE(i_log,*)' ERROR: Byte order in the phase space file do
     *es not'
            WRITE(i_log,*)' match the machine you are running on.'
            call exit(1)
          ELSE IF((iaea_result.EQ.-5)) THEN
            WRITE(i_log,*)' ERROR: Size of file does not match the value
     * of checksum'
            WRITE(i_log,*)' in the header AND there is a byte order mism
     *atch between'
            WRITE(i_log,*)' the file and the machine you are running on.
     *'
            call exit(1)
          ELSE IF((iaea_result.EQ.-1)) THEN
            WRITE(i_log,*)' ERROR: Cannot open phase space header.'
            call exit(1)
          ELSE IF((iaea_result.EQ.-2)) THEN
            WRITE(i_log,*)' ERROR: Something is wrong with the phase spa
     *ce file.'
            call exit(1)
          END IF
        ELSE
          IF ((IMODE.GT.0)) THEN
            PHSP_RECL=4*8
            OPEN(UNIT=42,FILE=SPCNAM,FORM='UNFORMATTED',ACCESS='DIRECT',
     *       RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP)
            IF ((IERR_PHSP.NE.0)) THEN
              WRITE(6,3850)
3850          FORMAT(/' ***error opening file as MODE2 ****' /' *** THEF
     *ILE FORMAT MAY BE WRONG (I.E., NOT A MODE2 FILE) ***'/ /' *** WENO
     *W TRY TO OPEN IT AS A MODE3 FILE ***'//)
              OPEN(UNIT=42,STATUS='OLD',FILE=SPCNAM, FORM='UNFORMATTED',
     *         IOSTAT=IERR_PHSP)
              IF ((IERR_PHSP.NE.0)) THEN
                WRITE(6,3860)
3860            FORMAT(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***')
                STOP
              END IF
              READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT_PHS
     *        P_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT
              NCASE_PHSP=NUM_PHSP_TOT
              NPHOTPHSP=PHOT_PHSP_TOT
              TEMP2=EKMAX_PHSP_SHORT
              TEMP3=EKMINE_PHSP_SHORT
              NINCSRC=NINC_PHSP_SHORT
              IF ((IERR_PHSP.NE.0)) THEN
                WRITE(6,3870)
3870            FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FILE**
     ** '//)
                STOP
              END IF
              IF ((LINE1 .NE. 'MODE3')) THEN
                WRITE(6,3880)
3880            FORMAT(//' That file does not start with MODE3,', ' as a
     *ll old compressed files (with ZLAST) must'/ '  Check it out and tr
     *y again!'///)
                IERR_PHSP=1
                STOP
              ELSE
                WRITE(6,3890)
3890            FORMAT(//' This is a MODE3 file! '/ ' Please convert iti
     *nto a MODE2 file using [readphsp] ', ' and try again!'///)
                IERR_PHSP=1
                STOP
              END IF
            END IF
            READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT_PHSP_
     *      TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT
            NCASE_PHSP=NUM_PHSP_TOT
            NPHOTPHSP=PHOT_PHSP_TOT
            TEMP2=EKMAX_PHSP_SHORT
            TEMP3=EKMINE_PHSP_SHORT
            NINCSRC=NINC_PHSP_SHORT
            IF ((IERR_PHSP.NE.0)) THEN
              WRITE(6,3900)
3900          FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FILE***'
     *//)
              STOP
            END IF
            IF ((LINE1 .NE. 'MODE2')) THEN
              WRITE(6,3910)
3910          FORMAT(//' That file does not start with MODE2,', ' as sta
     *ndard compressed files with ZLAST must'/ '  Check it out and try a
     *gain!'///)
              IERR_PHSP=1
              STOP
            END IF
          ELSE IF((IMODE.EQ.0)) THEN
            PHSP_RECL=4*7
            OPEN(UNIT=42,FILE=SPCNAM,FORM='UNFORMATTED',ACCESS='DIRECT',
     *       RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP)
            IF ((IERR_PHSP.NE.0)) THEN
              WRITE(6,3920)
3920          FORMAT(/' ***ERROR opening file as MODE0****' /' *** THE F
     *ILE FORMAT MAY BE WRONG (I.E., NOT A MODE0 FILE) ***'/ /' *** WE N
     *OW TRY TO OPEN IT AS A MODE1 FILE ***'//)
              OPEN(UNIT=42,STATUS='OLD',FILE=SPCNAM, FORM='UNFORMATTED',
     *         IOSTAT=IERR_PHSP)
              IF ((IERR_PHSP.NE.0)) THEN
                WRITE(6,3930)
3930            FORMAT(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***')
                STOP
              END IF
              READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT_PHS
     *        P_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT
              NCASE_PHSP=NUM_PHSP_TOT
              NPHOTPHSP=PHOT_PHSP_TOT
              TEMP2=EKMAX_PHSP_SHORT
              TEMP3=EKMINE_PHSP_SHORT
              NINCSRC=NINC_PHSP_SHORT
              IF ((IERR_PHSP.NE.0)) THEN
                WRITE(6,3940)
3940            FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FILE**
     ** '//)
                STOP
              END IF
              IF ((LINE1 .NE. 'MODE1')) THEN
                WRITE(6,3950)
3950            FORMAT(//' That file does not start with MODE1,', ' as a
     *ll old compressed files must'/ '  Check it out and try again!'///)
                IERR_PHSP=1
                STOP
              ELSE
                WRITE(6,3960)
3960            FORMAT(//' This is a MODE1 file! '/ ' Please convert iti
     *nto a MODE0 file using [readphsp] ', 'and try again!'///)
                IERR_PHSP=1
                STOP
              END IF
            END IF
            READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT_PHSP_
     *      TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT
            NCASE_PHSP=NUM_PHSP_TOT
            NPHOTPHSP=PHOT_PHSP_TOT
            TEMP2=EKMAX_PHSP_SHORT
            TEMP3=EKMINE_PHSP_SHORT
            NINCSRC=NINC_PHSP_SHORT
            IF ((IERR_PHSP.NE.0)) THEN
              WRITE(6,3970)
3970          FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FILE***'
     *//)
              STOP
            END IF
            IF ((LINE1 .NE. 'MODE0')) THEN
              WRITE(6,3980)
3980          FORMAT(/' Does not start with MODE0 as files without ZLAST
     * must'/ '  Try again!'//)
              IERR_PHSP=1
              STOP
            END IF
          ELSE IF((IMODE.LT.0)) THEN
            WRITE(6,3990)
3990        FORMAT(/' First, try to open it as a MODE0 file')
            PHSP_RECL=4*7
            OPEN(UNIT=42,FILE=SPCNAM,FORM='UNFORMATTED',ACCESS='DIRECT',
     *       RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP)
            IF ((IERR_PHSP.NE.0)) THEN
              WRITE(6,4000)
4000          FORMAT(/' Now try to open it as a MODE2 file')
              IMODE=1
              PHSP_RECL=4*8
              OPEN(UNIT=42,FILE=SPCNAM,FORM='UNFORMATTED',ACCESS='DIRECT
     *', RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP)
              IF ((IERR_PHSP.NE.0)) THEN
                WRITE(6,4010)
4010            FORMAT(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***')
              ELSE
                READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT_P
     *          HSP_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SH
     *          ORT
                NCASE_PHSP=NUM_PHSP_TOT
                NPHOTPHSP=PHOT_PHSP_TOT
                TEMP2=EKMAX_PHSP_SHORT
                TEMP3=EKMINE_PHSP_SHORT
                NINCSRC=NINC_PHSP_SHORT
                IF ((IERR_PHSP.NE.0)) THEN
                  WRITE(6,4020)
4020              FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FILE
     **** '//)
                  STOP
                END IF
                IF ((LINE1.NE.'MODE2')) THEN
                  WRITE(6,4030)
4030              FORMAT(//' That file does not start with MODE2,', ' as
     * standard compressed files with ZLAST must'/ '  Check it out and t
     *ry again!'///)
                  CLOSE(42)
                  STOP
                END IF
              END IF
            ELSE
              READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT_PHS
     *        P_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT
              NCASE_PHSP=NUM_PHSP_TOT
              NPHOTPHSP=PHOT_PHSP_TOT
              TEMP2=EKMAX_PHSP_SHORT
              TEMP3=EKMINE_PHSP_SHORT
              NINCSRC=NINC_PHSP_SHORT
              IF ((IERR_PHSP.NE.0)) THEN
                WRITE(6,4040)
4040            FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FILE**
     ** '//)
                STOP
              END IF
              IMODE=0
              IF ((LINE1.NE.'MODE0')) THEN
                WRITE(6,4050)
4050            FORMAT(/' The file does not start with MODE0 as it suppo
     *sed to')
                CLOSE(42)
                WRITE(6,4060)
4060            FORMAT(/' Now try to open it as a MODE2 file')
                IMODE=1
                PHSP_RECL=4*8
                OPEN(UNIT=42,FILE=SPCNAM,FORM='UNFORMATTED',ACCESS='DIRE
     *CT', RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP)
                IF ((IERR_PHSP.NE.0)) THEN
                  WRITE(6,4070)
4070              FORMAT(//' *** PHASE SPACE FILE CANNOT BE OPENED. ***'
     *)
                ELSE
                  READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT
     *            _PHSP_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHS
     *            P_SHORT
                  NCASE_PHSP=NUM_PHSP_TOT
                  NPHOTPHSP=PHOT_PHSP_TOT
                  TEMP2=EKMAX_PHSP_SHORT
                  TEMP3=EKMINE_PHSP_SHORT
                  NINCSRC=NINC_PHSP_SHORT
                  IF ((IERR_PHSP.NE.0)) THEN
                    WRITE(6,4080)
4080                FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FI
     *LE*** '//)
                    STOP
                  END IF
                  IF ((LINE1.NE.'MODE2')) THEN
                    WRITE(6,4090)
4090                FORMAT(//' That file does not start with MODE2,', 'a
     *s standard compressed files with ZLAST must'/ '  Check it out and 
     *try again!'///)
                    CLOSE(42)
                    STOP
                  END IF
                END IF
              END IF
            END IF
          END IF
          WRITE(6,4100)NCASE_PHSP,NPHOTPHSP,TEMP2,TEMP3,NINCSRC
4100      FORMAT(' Total number of particles in file      :',I10/ ' Tota
     *l number of photons                :',I10/ ' (the rest are electro
     *ns and positrons)'// ' Maximum kinetic energy of the particles:',F
     *10.3,' MeV'/ ' Minimum kinetic energy of the electrons:',F10.3,' M
     *eV'/ ' # particles incident when phase space created :',F15.0/)
          EKSRCM=TEMP2
          EIN=TEMP2
          IF ((NCASE_PHSP .LT. 0 .OR. NPHOTPHSP .LT. 0 .OR. TEMP2 .LE. 0
     *     .OR. TEMP3 .LT.0 .OR. NINCSRC .LE.0.0)) THEN
            WRITE(6,4110)
4110        FORMAT(3(1x,79('*')/)/' Something is wrong in the above' /'L
     *ikely the file is the wrong format (need to swap bytes)'/ 3(1x,79(
     *'*')/))
            STOP
          END IF
          NHSTRYM=0
          IF ((IMODE.NE.0)) THEN
            READ(42,REC=2,IOSTAT=IERR_PHSP) LATCHM,ESHORT,X_PHSP_SHORT,Y
     *      _PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT,ZLAST_P
     *      HSP_SHORT
          ELSE
            READ(42,REC=2,IOSTAT=IERR_PHSP) LATCHM,ESHORT,X_PHSP_SHORT,Y
     *      _PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT
          END IF
          IF ((2.EQ.76695869)) THEN
            write(*,*)' x,y,u,v,wt,eshort,latch', X_PHSP_SHORT,Y_PHSP_SH
     *      ORT,U_PHSP_SHORT,V_PHSP_SHORT, WT_PHSP_SHORT,ESHORT,LATCHM
          END IF
          IF ((ESHORT.LT.0.0)) THEN
            NHSTRYM=NHSTRYM+1
            ESHORT=ABS(ESHORT)
          END IF
          EINM=ESHORT
          WEIGHTM=WT_PHSP_SHORT
          XINM=X_PHSP_SHORT
          YINM=Y_PHSP_SHORT
          UINM=U_PHSP_SHORT
          VINM=V_PHSP_SHORT
          IF((IMODE.NE.0))ZLASTM=ZLAST_PHSP_SHORT
          IF ((NHSTRYM.NE.1)) THEN
            DOSE_STAT=1
            WRITE(6,4120)
4120        FORMAT(//' ***WARNING***'/ ' Cannot read no. of primary (non
     *-phsp) histories from ph-sp source.'/ ' Dose and fluence will be a
     *nalyzed assuming each particle read from'/ ' the ph-sp file is ani
     *ndependent history.  May result in an'/ ' underestimate of uncerta
     *inties.'//)
          END IF
        END IF
        IF (( isourc .EQ. 22 )) THEN
          WRITE(6,4130)dist_phsp,theta_phsp,chamber_c,xoffset,yoffset
4130      FORMAT(/' Phase space file from an angle'/, '    Rotation poin
     *t to phsp-plane midpoint distance: ',f10.4,/ '    Incident angle (
     *degrees)                      : ',f10.4,/ '    Rotation point (wil
     *l be set to chamber center'/, '      if greater than 1e4 or less t
     *han -1e4):     : ',g14.4, ' cm.'/ '    X offset of phsp plane (bef
     *ore rotation)      : ',f10.4,' cm'/ '    Y offset of phsp plane (b
     *efore rotation)      : ',f10.4,' cm'/)
        END IF
        IF ((IPARALLEL.GT.1 .AND. n_parallel.GT.0)) THEN
          WRITE(6,4140)IPARALLEL, n_parallel
4140      FORMAT(/' You have set IPARALLEL in the input file to ',I4,/ '
     * But you are also running a C compiled code with n_parallel=',I4,/
     *' IPARALLEL will be reset to 1, and control of the parallel run '/
     * ' will be from the code.'/)
          IPARALLEL=1
        END IF
        IF((IPARALLEL.LE.0))IPARALLEL=1
        IF((PARNUM.LT.0))PARNUM=0
        IF ((IPARALLEL.GT.1)) THEN
          IF ((PARNUM.GE.1 .AND. PARNUM.LE.IPARALLEL)) THEN
            WRITE(6,4150)IPARALLEL,INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+
     *      1, INT(PARNUM*NCASE_PHSP/IPARALLEL)
4150        FORMAT(/' This is one of ',I4,' parallel jobs.'/ ' It will u
     *se from particle ',I12,' to particle ',I12,/ ' from the phase spac
     *e source in the simulation.'/)
          ELSE
            WRITE(6,4160)IPARALLEL
4160        FORMAT(/' IPARALLEL input indicates that this is one of ',I4
     *,' parallel jobs.'/ ' But PARNUM is out of range (<1 or >IPARALLEL
     *).  Therefore, phsp '/ ' source will not be partitioned.'/)
            PARNUM=0
            IPARALLEL=1
          END IF
        END IF
        IF ((NRCYCL.LE.0)) THEN
          IF ((IQIN.EQ.1)) THEN
            WRITE(6,4170)
4170        FORMAT(/' NRCYCL cannot be calculated automatically because'
     */ ' INCIDENT PARTICLE= positrons '/)
            NRCYCL=0
          ELSE
            WRITE(6,4180)
4180        FORMAT(/' NRCYCL will be calculated automatically'/)
            IF ((IQIN.EQ.-1 .OR. IQIN.EQ.3)) THEN
              TEMPDIV=NCASE_PHSP-NPHOTPHSP
            ELSE IF((IQIN.EQ.0)) THEN
              TEMPDIV=NPHOTPHSP
            ELSE IF((IQIN.EQ.2)) THEN
              TEMPDIV=NCASE_PHSP
            END IF
            IF ((NINT(dble(IPARALLEL*NCASE)/dble(TEMPDIV)).LE.1)) THEN
              NRCYCL=0
            ELSE IF((MOD(IPARALLEL*NCASE,TEMPDIV).EQ.0)) THEN
              NRCYCL=(IPARALLEL*NCASE)/TEMPDIV-1
            ELSE
              NRCYCL=(IPARALLEL*NCASE)/TEMPDIV
            END IF
          END IF
        END IF
        WRITE(6,4190)NRCYCL
4190    FORMAT(/' Particles will be recycled ',I4,' times before movingo
     *n to next one.'/)
        CYCLNUM=0
        ENFLAG=1
        N_RUN_CHUNK_OLD=0
      ELSE
        ISOURC=0
        RBEAM=RCYL(NR)
        WRITE(6,4200)IQIN,RBEAM
4200    FORMAT(/ ' Electric charge of the source:',T60,I12/ ' Parallel b
     *eam incident from the front(+ve Z-axis)'/ ' Radius of beam at thef
     *ront face of the target:',T60,F10.4,' cm'/)
      END IF
      RETURN
4210  CONTINUE
      ERROR_FLAG=1
      RETURN
      ENTRY SRCOTO(WEIGHT)
      IFPB=1
      IF (((ISOURC.EQ.0).OR.(ISOURC.EQ.2).OR.(ISOURC.EQ.4))) THEN
        IFPB=0
        IF(((ISOURC.EQ.0).AND.(WINC.NE.1.)))IFPB=1
        RBEAM=RBEAM*0.9999
        RBEAM2=RBEAM**2
        WEIGHT=1.0
        AFACE=PI*RBEAM2
        IF ((ISOURC .EQ. 0)) THEN
          AINFLU=dble(NCASET)/AFACE
        ELSE
          AINFLU=dble(NCASET)
        END IF
      ELSE IF((ISOURC .EQ. 1)) THEN
        RBEAM=RBEAM*0.9999
        RBEAM2=RBEAM**2
        DISTZ2=DISTZ**2
        DISTRH=0.0
        ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1))
        ZSOFST=ZPLANE(1)-DISTZ
        AFACE=PI*RBEAM**2
        PROBFC=1.0
        AINFLU=dble(NCASET)/DISTZ2
      ELSE IF((ISOURC .EQ. 3)) THEN
        WEIGHT=1.0
        AINFLU=dble(NCASET)
        ZSOFST=0.5*(ZSMAX - ZSMIN)+ ZSMIN
        ZBEAM=0.5*(ZSMAX - ZSMIN)
      ELSE IF((ISOURC .EQ. 10)) THEN
        XBEAM=XBEAM*0.9999
        ZBEAM=ZBEAM*0.9999
        ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1))
        RCYL1=RCYL(NR)
        RCYL2=RCYL1**2
        ASIDE=4.0*XBEAM*ZBEAM
        WEIGHT=1.
        AINFLU=dble(NCASET)/ASIDE
      ELSE IF((ISOURC .EQ. 11)) THEN
        XBEAM=XBEAM*0.9999
        ZBEAM=ZBEAM*0.9999
        ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1))
        ZSOFST=ZCOFST
        RCYL1=RCYL(NR)
        RCYL2=RCYL1**2
        DSTRH2=DISTRH**2
        ASIDE=4.0*XBEAM*ZBEAM
        PROBSD=1.0
        AINFLU = dble(NCASET)/DSTRH2
      ELSE IF((ISOURC .EQ. 12)) THEN
        RBEAM = RBEAM*0.9999
        XBEAM = XBEAM*0.9999
        ZBEAM = ZBEAM*0.9999
        ZCOFST = 0.5*(ZPLANE(NPLANE)+ZPLANE(1))
        ZSOFST = ZPLANE(1)-DISTZ
        RBEAM2 = RBEAM**2
        RCYL1 = RCYL(NR)
        RCYL2 = RCYL1**2
        DSTRH2 = DISTRH**2
        DISTZ2 = DISTZ**2
        DISTB = DISTZ-(ZPLANE(NPLANE)-ZPLANE(1))
        DISTB2 = DISTB**2
        AFACE = PI*RBEAM2
        ASIDE = 4.0*XBEAM*ZBEAM
        AINFLU = NCASET/(DSTRH2+(ZCOFST-ZSOFST)**2)
        IF ((DISTRH .LE. RCYL(NR))) THEN
          PROBSD = 0
          IF ((DISTZ .GE. 0.0)) THEN
            PROBFC = 1.0
            PROBBK = 0.0
          ELSE IF((DISTZ .LE. (ZPLANE(1)-ZPLANE(NPLANE)))) THEN
            PROBFC = 0.0
            PROBBK = 1.0
          END IF
        ELSE IF(((DISTZ .GE. (ZPLANE(1)-ZPLANE(NPLANE)) .AND. (DISTZ .LE
     *  . 0.0)))) THEN
          PROBFC = 0.0
          PROBBK = 0.0
          PROBSD = 1.0
        ELSE
          COTANG = ZSOFST/DISTRH
          IF ((COTANG .LT. 0.0)) THEN
            FACTOR = AFACE*ABS(COTANG)/ASIDE
            PROBSD = 1.0/(1.0+FACTOR)
            PROBFC = FACTOR/(1.0+FACTOR)
            PROBBK = 0.0
          ELSE
            FACTOR = AFACE*COTANG/ASIDE
            PROBSD = 1.0/(1.0+FACTOR)
            PROBBK = FACTOR/(1.0+FACTOR)
            PROBFC = 0.0
          END IF
        END IF
      ELSE IF((ISOURC .EQ. 15)) THEN
        call src15_oto(iout)
      ELSE IF((ISOURC .EQ. 16)) THEN
        call src16_oto(iout)
      ELSE IF((ISOURC .EQ. 17)) THEN
        XBEAM=XBEAM*0.9999
        YBEAM=YBEAM*0.9999
        DISTZ2=DISTZ**2
        DISTRH=0.0
        ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1))
        ZSOFST=ZPLANE(1)-DISTZ
        AFACE=4.0*XBEAM*YBEAM
        PROBFC=1.0
        AINFLU=FLOAT(NCASET)/DISTZ2
      ELSE IF((ISOURC .EQ. 13)) THEN
        RBEAM=RBEAM*0.9999
        XBEAM=XBEAM*0.9999
        ZBEAM=ZBEAM*0.9999
        RBEAM2=RBEAM**2
        RCYL1=RCYL(NR)
        RCYL2=RCYL1**2
        ZCOFST=0.5*(ZPLANE(1)+ZPLANE(NPLANE))
        AFACE=PI*RBEAM2
        ASIDE=4.0*XBEAM*ZBEAM
        WEIGHT=1.0
        AINFLU=NCASET/(ABS(WINC)*AFACE+SQRT(UINC**2+VINC**2)*ASIDE)
        IF ((WINC.EQ.1.0)) THEN
          PROBFC=1.0
          PROBSD=0.0
          PROBBK=0.0
        ELSE IF((WINC.EQ.0.0)) THEN
          PROBFC=0.0
          PROBSD=1.0
          PROBBK=0.0
        ELSE IF((WINC.EQ.-1.0)) THEN
          PROBFC=0.0
          PROBSD=0.0
          PROBBK=1.0
        ELSE
          IF ((WINC.LT.0.0)) THEN
            FACTOR=AFACE*ABS(WINC)/(ASIDE*SQRT(UINC**2+VINC**2))
            PROBFC=0.0
            PROBSD=1.0/(1.0+FACTOR)
            PROBBK=FACTOR/(1.0+FACTOR)
          ELSE
            FACTOR=AFACE*WINC/(ASIDE*SQRT(UINC**2+VINC**2))
            PROBFC=FACTOR/(1.0+FACTOR)
            PROBSD=1.0/(1.0+FACTOR)
            PROBBK=0.0
          END IF
        END IF
      ELSE IF((ISOURC .EQ. 14)) THEN
        RBEAM=RBEAM*0.9999
        RBEAM2=RBEAM**2
        RMINSQ=RMINBM**2
        DISTZ2=DISTZ**2
        DISTRH=0.0
        ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1))
        ZSOFST=ZPLANE(1)-DISTZ
        AFACE=PI*RBEAM**2
        PROBFC=1.0
        AINFLU=dble(NCASET)/DISTZ2
      ELSE IF((ISOURC .EQ. 20)) THEN
        RCDF(1)=0.5*RDISTF(1)**2*RPDF(1)
        DO 4221 IB=2,NRDIST
          RCDF(IB)=RCDF(IB-1)+0.5*(RDISTF(IB)**2-RDISTF(IB-1)**2)*RPDF(I
     *    B)
4221    CONTINUE
4222    CONTINUE
        FNORM=1./RCDF(NRDIST)
        IBNSOK=0
        GRIDSZ=1./dble(4)
        DO 4231 IB=1,NRDIST
          RCDF(IB)=FNORM*RCDF(IB)
          IF ((IB.EQ.1)) THEN
            IF((RCDF(1).LT.GRIDSZ))IBNSOK=1
          ELSE IF(((RCDF(IB)-RCDF(IB-1)).LT.GRIDSZ)) THEN
            IBNSOK=1.0
          END IF
4231    CONTINUE
4232    CONTINUE
        IF ((IBNSOK.NE.0)) THEN
          WRITE(6,4240)
4240      FORMAT(///' *******WARNING******'/ T15,'SOME OF NORMALIZED BIN
     * PROBABILITIES SO SMALL BINS MAY BE MISSED'/)
        END IF
        DO 4251 K=1,4
          AK=dble(K)*GRIDSZ
          DO 4261 I=1,NRDIST
            IRDIST=I
            IF ((AK.LE.RCDF(I))) THEN
              GOTO 4270
            END IF
4261      CONTINUE
4262      CONTINUE
          WRITE(6,4280)
4280      FORMAT(' *** FELL THROUGH RADIAL SAMPLING ROUTINE *** ')
4270      IF ((IRDIST.NE.1)) THEN
            RCDFIN(K,1)=RDISTF(IRDIST-1)**2
          ELSE
            RCDFIN(K,1)=0.0
          END IF
          RCDFIN(K,2)=RDISTF(IRDIST)**2-RCDFIN(K,1)
4251    CONTINUE
4252    CONTINUE
        IF ((IWATCH.NE.0)) THEN
          WRITE(6,4290)
4290      FORMAT(/' RDISTF,   RPDF,   RCDF:'//)
          WRITE(6,4300)(RDISTF(IB),RPDF(IB),RCDF(IB),IB=1,NRDIST)
4300      FORMAT(3E17.7)
          WRITE(6,4310)
4310      FORMAT(//)
        END IF
        WEIGHT=1.0
        AINFLU=dble(NCASET)/(PI*RDISTF(NRDIST)**2)
      ELSE IF(( ISOURC .EQ. 23 )) THEN
        AINFLU=dble(NCASET)
        WEIGHT=1.0
        IF (( chamber_c .GT. 1e4 .OR. chamber_c .LT. -1e4 )) THEN
          chamber_c = 0.5*(zplane(1) + zplane(nplane))
        END IF
      ELSE IF(((ISOURC .EQ. 21) .OR. (ISOURC .EQ. 22))) THEN
        AINFLU=dble(NCASET)
        WEIGHT=1.0
        IF (( chamber_c .GT. 1e4 .OR. chamber_c .LT. -1e4 )) THEN
          chamber_c = 0.5*(zplane(1) + zplane(nplane))
        END IF
        IF ((IPARALLEL.GT.1 .AND. PARNUM .GT. 0)) THEN
          IF ((IHSTRY.LT.NCASE_PHSP/IPARALLEL)) THEN
            NPHSPN=INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+IHSTRY
          ELSE
            tmp_mod = NCASE_PHSP
            NPHSPN=tmp_mod*(PARNUM-1)/IPARALLEL+ MOD(IHSTRY,tmp_mod/IPAR
     *      ALLEL)
          END IF
        ELSE
          IF ((IHSTRY.LT.NCASE_PHSP)) THEN
            NPHSPN = IHSTRY
          ELSE
            tmp_mod = NCASE_PHSP
            NPHSPN=MOD(IHSTRY,tmp_mod)
          END IF
        END IF
        IF ((i_iaea_in.EQ.1)) THEN
          iaea_dummy_long=NPHSPN+1
          call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result)
          IF ((iaea_result.LT.0)) THEN
            WRITE(i_log,*)' Error going to record ',NPHSPN+1,' in IAEA p
     *hsp file.'
            call exit(1)
          END IF
        END IF
      END IF
      RETURN
      ENTRY SRCOUT
      WRITE(IOUT,500)
      IF ((ISOURC .EQ. 0)) THEN
        WRITE(IOUT,510) RBEAM,UINC,VINC,WINC,AINFLU
      ELSE IF((ISOURC .EQ. 1)) THEN
        WRITE(IOUT,520) DISTZ,RBEAM,AINFLU
      ELSE IF((ISOURC .EQ. 2)) THEN
        WRITE(IOUT,560)
      ELSE IF((ISOURC .EQ. 3)) THEN
        WRITE(IOUT,570)RMINBM,RBEAM,ZSMIN,ZSMAX
      ELSE IF((ISOURC .EQ. 4)) THEN
        WRITE(IOUT,590) RBEAM
      ELSE IF((ISOURC .EQ. 10)) THEN
        WRITE(IOUT,530)XBEAM,ZBEAM
        IF((((XBEAM/0.9999).LT.RCYL(NR)).OR. ((ZBEAM/0.9999).LT.(0.5*(ZP
     *  LANE(NPLANE)-ZPLANE(1))))))WRITE(IOUT,550)
      ELSE IF((ISOURC .EQ. 11)) THEN
        WRITE(IOUT,540)DISTRH,XBEAM,ZBEAM
        IF(((XBEAM/0.9999.LT.(RCYL(NR)*SQRT(DISTRH**2-RCYL(NR)**2)/DISTR
     *  H)).OR. (ZBEAM/0.9999.LT.(0.5*(ZPLANE(NPLANE)-ZPLANE(1))))))WRIT
     *  E(IOUT,550)
      ELSE IF((ISOURC .EQ. 12)) THEN
        WRITE(IOUT,580)DISTRH,DISTZ
      ELSE IF((ISOURC .EQ. 15)) THEN
        call src15_describe(iout)
      ELSE IF((ISOURC .EQ. 16)) THEN
        call src16_describe(iout)
      ELSE IF((ISOURC .EQ. 17)) THEN
        WRITE(IOUT,535) DISTZ,XBEAM,YBEAM,AINFLU
      ELSE IF((ISOURC .EQ. 13)) THEN
        WRITE(IOUT,585) UINC,VINC,WINC,AINFLU
      ELSE IF((ISOURC .EQ. 14)) THEN
        WRITE(IOUT,525) DISTZ,RMINBM,RBEAM,AINFLU
      ELSE IF((ISOURC .EQ. 20)) THEN
        WRITE(IOUT,595)
        IF ((IOUTSP.EQ.1)) THEN
          WRITE(IOUT,610)NRDIST
          DO 4321 IB=1,NRDIST
            WRITE(IOUT,620)IB,RDISTF(IB),RPDF(IB),RCDF(IB)
4321      CONTINUE
4322      CONTINUE
        END IF
        IF((IBNSOK.NE.0.0))WRITE(IOUT,630)
      ELSE IF((ISOURC .EQ. 21)) THEN
        WRITE(IOUT,640) FILSPC,ZPLANE(1),AINFLU
      ELSE IF((ISOURC .EQ. 22)) THEN
        WRITE(IOUT,677) FILSPC,dist_phsp,theta_phsp,chamber_c, xoffset,y
     *  offset,AINFLU
      ELSE IF((ISOURC.EQ.23)) THEN
        WRITE(IOUT,679) iqinc,min_weight_23,max_weight_23, the_beam_code
     *  (:lnblnk1(the_beam_code)),the_pegs_file(:lnblnk1(the_pegs_file))
     *  , the_input_file(:lnblnk1(the_input_file)), dist_phsp,theta_phsp
     *  ,chamber_c,xoffset,yoffset,EKSRCM
      END IF
      IF ((ISOURC .EQ. 21 .OR. ISOURC .EQ. 22)) THEN
        WRITE(IOUT,4330) NCASE_PHSP,NPHOTPHSP,TEMP2,TEMP3,NINCSRC
4330    FORMAT(T15, ' Total number of particles in file      :',I10/ T15
     *, ' Total number of photons                :',I10/ T15, ' (the res
     *t are electrons and positrons)'// T15, ' Maximum kinetic energyof 
     *the particles:',F10.3,' MeV'/ T15, ' Minimum kinetic energy ofthe 
     *electrons:',F10.3,' MeV'/ T15, ' # particles incident when phase s
     *pace created :',F12.0/)
        IF ((DOSE_STAT.EQ.1)) THEN
          WRITE(IOUT,'(//'' ***WARNING***''/
     *                   '' Cannot read no. of primary (non-phsp) histor
     *ies from ph-sp source.''/        '' Dose and fluence will be analy
     *zed assuming each particle read from''/        '' the ph-sp file i
     *s an independent history.  May result in an''/               '' un
     *derestimate of uncertainties.''//)')
        END IF
        IF ((IPARALLEL.GT.1)) THEN
          IF ((PARNUM.GE.1 .AND. PARNUM.LE.IPARALLEL)) THEN
            WRITE(IOUT,'(/'' This is one of '',I4,'' parallel jobs.''/
     *                               '' It will use from particle '',I12
     *,'' to particle '',I12,/                     '' from the phase spa
     *ce source in the simulation.''/)') IPARALLEL,INT((PARNUM-1)*NCASE_
     *      PHSP/IPARALLEL)+1, INT(PARNUM*NCASE_PHSP/IPARALLEL)
          END IF
        END IF
        IF ((NRCYCL.GT.0)) THEN
          WRITE(IOUT,'(/'' Particles will be recycled '',
     *                              I4,'' times before moving on to next
     * one.''/)') NRCYCL
        END IF
      END IF
      RETURN
      ENTRY SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
      IF ((n_parallel.GT.0 .AND. (ISOURC.EQ.21 .OR. ISOURC.EQ.22))) THEN
        IF((N_RUN_CHUNK_OLD.EQ.0))P_PER_PHSP_CHUNK=NCASE_PHSP/(n_paralle
     *  l*10)
        N_RUN_CHUNK=(NCASE-N_LEFT)*n_parallel*10/NCASE
        other_num_1=N_RUN_CHUNK*NCASE
        other_num_2=(NCASE-N_LEFT)*n_parallel*10
        IF ((other_num_1.LT.other_num_2)) THEN
          N_RUN_CHUNK=N_RUN_CHUNK+1
        END IF
        IF ((N_RUN_CHUNK .NE. N_RUN_CHUNK_OLD)) THEN
          N_RUN_CHUNK_OLD=N_RUN_CHUNK
          NPHSPN_MIN=(N_RUN_CHUNK-1)*P_PER_PHSP_CHUNK+1
          IF ((N_LEFT.EQ.0)) THEN
            NPHSPN_MAX=NCASE_PHSP
          ELSE
            NPHSPN_MAX=NPHSPN_MIN+P_PER_PHSP_CHUNK-1
          END IF
          NPHSPN=NPHSPN_MIN-1
          IF ((i_iaea_in.EQ.1)) THEN
            iaea_dummy_long=NPHSPN+1
            call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result)
            IF ((iaea_result.LT.0)) THEN
              WRITE(i_log,*)' Error going to record ',NPHSPN+1,' in IAEA
     * phsp file.'
              call exit(1)
            END IF
          END IF
          CYCLNUM=0
          write(6,'(/a/,a,i12,a,i12/,a//)') '      This simulation uses
     *a phase space source.', '      This run will use from particle',NP
     *    HSPN_MIN,' to particle ', NPHSPN_MAX, '      in the source fil
     *e.'
        END IF
      END IF
      IF (((ISOURC .EQ. 0) .OR. (ISOURC .EQ. 2) .OR.(ISOURC .EQ. 4))) TH
     *EN
        IF ((RBEAM .EQ. 0.0)) THEN
          XIN=0.0
          YIN=0.0
          IRIN=2
        ELSE
4341      CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*RBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            YIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            YIN=(2.0*YIN-1.0)*RBEAM
            R2=XIN**2+YIN**2
            IF((R2.LE.RBEAM2))GO TO4342
          GO TO 4341
4342      CONTINUE
          DO 4351 IX=1,NR
            IXIN=IX
            IF((R2.LE.CYRAD2(IX)))GO TO4352
4351      CONTINUE
4352      CONTINUE
          IRIN=2+(IXIN-1)*NZ
        END IF
        ZIN=ZPLANE(1)
        IF ((IFPB .EQ. 0)) THEN
          UIN=0.0
          VIN=0.0
          WIN=1.0
        ELSE
          UIN=UINC
          VIN=VINC
          WIN=WINC
        END IF
        NRCFLG=10
        WEIGHT=1.0
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 1 .OR. ISOURC .EQ. 14)) THEN
4361    CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          XIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          XIN=(2.0*XIN-1.0)*RBEAM
          IF((rng_seed .GT. 128))call ranmar_get
          YIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          YIN=(2.0*YIN-1.0)*RBEAM
          R2=XIN**2+YIN**2
          IF((R2.LE.RBEAM2))GO TO4362
        GO TO 4361
4362    CONTINUE
        DO 4371 IX=1,NR
          IXIN=IX
          IF((R2.LE.CYRAD2(IX)))GO TO4372
4371    CONTINUE
4372    CONTINUE
        IRIN=2+(IXIN-1)*NZ
        ZIN=ZPLANE(1)
        IF ((ISOURC.EQ.14 .AND. R2.LE.RMINSQ)) THEN
          WEIGHT=0.0
        ELSE
          IF ((DISTRH.EQ.0.0)) THEN
            D=SQRT(R2+DISTZ**2)
          ELSE
            D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTZ**2)
          END IF
          UIN=XIN/D
          VIN=(YIN-DISTRH)/D
          WIN=DISTZ/D
          NRCFLG=10
          WEIGHT=AFACE*DISTZ/(D**3)/PROBFC
          SCOMEG=SCOMEG+WEIGHT
          SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
        END IF
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 3)) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        ZIN = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        ZIN=ZSOFST+(2.0*ZIN-1.0)*ZBEAM
        DO 4381 IZ=1,NPLANE-1
          IF((ZIN .LE. ZPLANE(IZ+1) .AND. ZIN .GE. ZPLANE(IZ)))GO TO4382
4381    CONTINUE
4382    CONTINUE
4391    CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          XIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          XIN=(2.0*XIN-1.0)*RBEAM
          IF((rng_seed .GT. 128))call ranmar_get
          YIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          YIN=(2.0*YIN-1.0)*RBEAM
          R2=XIN**2+YIN**2
          IF(((R2 .LE. RBEAM2 .AND. R2 .GE. RMINSQ)))GO TO4392
        GO TO 4391
4392    CONTINUE
        DO 4401 IX=1,NR
          IF((R2 .LE. CYRAD2(IX)))GO TO4402
4401    CONTINUE
4402    CONTINUE
        IRIN = IZ + NZ*(IX-1)+1
        IF((rng_seed .GT. 128))call ranmar_get
        COSTHE = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        COSTHE=2.*COSTHE-1
        SINTHE=SQRT(1.0-COSTHE**2)
        IF((rng_seed .GT. 128))call ranmar_get
        PHI = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        PHI=TWOPI*PHI
        UIN=SINTHE*COS(PHI)
        VIN=SINTHE*SIN(PHI)
        WIN=COSTHE
        NRCFLG=50
        WEIGHT=1.0
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 10)) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        XIN = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        XIN=(2.0*XIN-1.0)*XBEAM
        IF((rng_seed .GT. 128))call ranmar_get
        ZIN = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
        YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
        DO 4411 IZ=2,NPLANE
          IZ1=IZ
          IF((ZIN.LE.ZPLANE(IZ)))GO TO4412
4411    CONTINUE
4412    CONTINUE
        IRIN=(NR-1)*NZ+IZ1
        UIN=0.0
        VIN=-1.0
        WIN=0.0
        NRCFLG=20
        WEIGHT=1.0
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 11)) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        XIN = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        XIN=(2.0*XIN-1.0)*XBEAM
        IF((rng_seed .GT. 128))call ranmar_get
        ZIN = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
        YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
        DO 4421 IZ=2,NPLANE
          IZ1=IZ
          IF((ZIN.LE.ZPLANE(IZ)))GO TO4422
4421    CONTINUE
4422    CONTINUE
        IRIN=(NR-1)*NZ+IZ1
        D=SQRT(RCYL2+DSTRH2-2.0*DISTRH*YIN+(ZIN-ZSOFST)**2)
        UIN=XIN/D
        VIN=(YIN-DISTRH)/D
        WIN=(ZIN-ZSOFST)/D
        WEIGHT=ASIDE*(DISTRH-RCYL2/YIN)/(D**3)/PROBSD
        SCOMEG=SCOMEG+WEIGHT
        SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
        NRCFLG=20
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 12)) THEN
        IF ((PROBFC.EQ.1.0)) THEN
4431      CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*RBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            YIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            YIN=(2.0*YIN-1.0)*RBEAM
            R2=XIN**2+YIN**2
            IF((R2.LE.RBEAM2))GO TO4432
          GO TO 4431
4432      CONTINUE
          DO 4441 IX=1,NR
            IXIN=IX
            IF((R2.LE.CYRAD2(IX)))GO TO4442
4441      CONTINUE
4442      CONTINUE
          IRIN=2+(IXIN-1)*NZ
          ZIN=ZPLANE(1)
          IF ((ISOURC.EQ.14 .AND. R2.LE.RMINSQ)) THEN
            WEIGHT=0.0
          ELSE
            IF ((DISTRH.EQ.0.0)) THEN
              D=SQRT(R2+DISTZ**2)
            ELSE
              D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTZ**2)
            END IF
            UIN=XIN/D
            VIN=(YIN-DISTRH)/D
            WIN=DISTZ/D
            NRCFLG=10
            WEIGHT=AFACE*DISTZ/(D**3)/PROBFC
            SCOMEG=SCOMEG+WEIGHT
            SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
          END IF
        ELSE IF((PROBBK.EQ.1.0)) THEN
4451      CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*RBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            YIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            YIN=(2.0*YIN-1.0)*RBEAM
            R2=XIN**2+YIN**2
            IF((R2.LE.RBEAM2))GO TO4452
          GO TO 4451
4452      CONTINUE
          DO 4461 IX=1,NR
            IXIN=IX
            IF((R2.LE.CYRAD2(IX)))GO TO4462
4461      CONTINUE
4462      CONTINUE
          IRIN=1+IXIN*NZ
          ZIN=ZPLANE(NPLANE)
          IF ((DISTRH.EQ.0.0)) THEN
            D=SQRT(R2+DISTB2)
          ELSE
            D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTB2)
          END IF
          UIN=XIN/D
          VIN=(YIN-DISTRH)/D
          WIN=-DISTB/D
          NRCFLG=30
          WEIGHT=AFACE*DISTB/(D**3)/PROBBK
          SCOMEG=SCOMEG+WEIGHT
          SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
        ELSE IF((PROBSD.EQ.1.0)) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          XIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          XIN=(2.0*XIN-1.0)*XBEAM
          IF((rng_seed .GT. 128))call ranmar_get
          ZIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
          YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
          DO 4471 IZ=2,NPLANE
            IZ1=IZ
            IF((ZIN.LE.ZPLANE(IZ)))GO TO4472
4471      CONTINUE
4472      CONTINUE
          IRIN=(NR-1)*NZ+IZ1
          D=SQRT(RCYL2+DSTRH2-2.0*DISTRH*YIN+(ZIN-ZSOFST)**2)
          UIN=XIN/D
          VIN=(YIN-DISTRH)/D
          WIN=(ZIN-ZSOFST)/D
          WEIGHT=ASIDE*(DISTRH-RCYL2/YIN)/(D**3)/PROBSD
          SCOMEG=SCOMEG+WEIGHT
          SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
          NRCFLG=20
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          WHICH = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF ((WHICH.LE.PROBSD)) THEN
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*XBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            ZIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
            YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
            DO 4481 IZ=2,NPLANE
              IZ1=IZ
              IF((ZIN.LE.ZPLANE(IZ)))GO TO4482
4481        CONTINUE
4482        CONTINUE
            IRIN=(NR-1)*NZ+IZ1
            D=SQRT(RCYL2+DSTRH2-2.0*DISTRH*YIN+(ZIN-ZSOFST)**2)
            UIN=XIN/D
            VIN=(YIN-DISTRH)/D
            WIN=(ZIN-ZSOFST)/D
            WEIGHT=ASIDE*(DISTRH-RCYL2/YIN)/(D**3)/PROBSD
            SCOMEG=SCOMEG+WEIGHT
            SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
            NRCFLG=20
          ELSE IF((WHICH.LE.(PROBSD+PROBFC))) THEN
4491        CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              XIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              XIN=(2.0*XIN-1.0)*RBEAM
              IF((rng_seed .GT. 128))call ranmar_get
              YIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              YIN=(2.0*YIN-1.0)*RBEAM
              R2=XIN**2+YIN**2
              IF((R2.LE.RBEAM2))GO TO4492
            GO TO 4491
4492        CONTINUE
            DO 4501 IX=1,NR
              IXIN=IX
              IF((R2.LE.CYRAD2(IX)))GO TO4502
4501        CONTINUE
4502        CONTINUE
            IRIN=2+(IXIN-1)*NZ
            ZIN=ZPLANE(1)
            IF ((ISOURC.EQ.14 .AND. R2.LE.RMINSQ)) THEN
              WEIGHT=0.0
            ELSE
              IF ((DISTRH.EQ.0.0)) THEN
                D=SQRT(R2+DISTZ**2)
              ELSE
                D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTZ**2)
              END IF
              UIN=XIN/D
              VIN=(YIN-DISTRH)/D
              WIN=DISTZ/D
              NRCFLG=10
              WEIGHT=AFACE*DISTZ/(D**3)/PROBFC
              SCOMEG=SCOMEG+WEIGHT
              SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
            END IF
          ELSE
4511        CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              XIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              XIN=(2.0*XIN-1.0)*RBEAM
              IF((rng_seed .GT. 128))call ranmar_get
              YIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              YIN=(2.0*YIN-1.0)*RBEAM
              R2=XIN**2+YIN**2
              IF((R2.LE.RBEAM2))GO TO4512
            GO TO 4511
4512        CONTINUE
            DO 4521 IX=1,NR
              IXIN=IX
              IF((R2.LE.CYRAD2(IX)))GO TO4522
4521        CONTINUE
4522        CONTINUE
            IRIN=1+IXIN*NZ
            ZIN=ZPLANE(NPLANE)
            IF ((DISTRH.EQ.0.0)) THEN
              D=SQRT(R2+DISTB2)
            ELSE
              D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTB2)
            END IF
            UIN=XIN/D
            VIN=(YIN-DISTRH)/D
            WIN=-DISTB/D
            NRCFLG=30
            WEIGHT=AFACE*DISTB/(D**3)/PROBBK
            SCOMEG=SCOMEG+WEIGHT
            SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
          END IF
        END IF
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 15)) THEN
        call src15_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 16)) THEN
        call src16_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 17)) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        XIN = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        XIN=(2.0*XIN-1.0)*XBEAM
        IF((rng_seed .GT. 128))call ranmar_get
        YIN = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        YIN=(2.0*YIN-1.0)*YBEAM
        R2=XIN**2+YIN**2
        DO 4531 IX=1,NR
          IXIN=IX
          IF((R2.LE.CYRAD2(IX)))GO TO4532
4531    CONTINUE
4532    CONTINUE
        IRIN=2+(IXIN-1)*NZ
        ZIN=ZPLANE(1)
        IF ((DISTRH.EQ.0.0)) THEN
          D=SQRT(R2+DISTZ**2)
        ELSE
          D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTZ**2)
        END IF
        UIN=XIN/D
        VIN=(YIN-DISTRH)/D
        WIN=DISTZ/D
        NRCFLG=10
        WEIGHT=AFACE*DISTZ/(D**3)/PROBFC
        SCOMEG=SCOMEG+WEIGHT
        SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 13)) THEN
        UIN=UINC
        VIN=VINC
        WIN=WINC
        IF ((PROBFC.EQ.1.0)) THEN
4541      CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*RBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            YIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            YIN=(2.0*YIN-1.0)*RBEAM
            R2=XIN**2+YIN**2
            IF((R2.LE.RBEAM2))GO TO4542
          GO TO 4541
4542      CONTINUE
          DO 4551 IX=1,NR
            IXIN=IX
            IF((R2.LE.CYRAD2(IX)))GO TO4552
4551      CONTINUE
4552      CONTINUE
          IRIN=2+(IXIN-1)*NZ
          ZIN=ZPLANE(1)
          NRCFLG=10
        ELSE IF((PROBBK.EQ.1.0)) THEN
4561      CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*RBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            YIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            YIN=(2.0*YIN-1.0)*RBEAM
            R2=XIN**2+YIN**2
            IF((R2.LE.RBEAM2))GO TO4562
          GO TO 4561
4562      CONTINUE
          DO 4571 IX=1,NR
            IXIN=IX
            IF((R2.LE.CYRAD2(IX)))GO TO4572
4571      CONTINUE
4572      CONTINUE
          IRIN=1+IXIN*NZ
          ZIN=ZPLANE(NPLANE)
          NRCFLG=30
        ELSE IF((PROBSD.EQ.1.0)) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          XIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          XIN=(2.0*XIN-1.0)*XBEAM
          IF((rng_seed .GT. 128))call ranmar_get
          ZIN = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
          YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
          DO 4581 IZ=2,NPLANE
            IZ1=IZ
            IF((ZIN.LE.ZPLANE(IZ)))GO TO4582
4581      CONTINUE
4582      CONTINUE
          IRIN=(NR-1)*NZ+IZ1
          NRCFLG=20
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          WHICH = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF ((WHICH.LE.PROBSD)) THEN
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*XBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            ZIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
            YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
            DO 4591 IZ=2,NPLANE
              IZ1=IZ
              IF((ZIN.LE.ZPLANE(IZ)))GO TO4592
4591        CONTINUE
4592        CONTINUE
            IRIN=(NR-1)*NZ+IZ1
            NRCFLG=20
          ELSE IF((WHICH.LE.(PROBSD+PROBFC))) THEN
4601        CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              XIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              XIN=(2.0*XIN-1.0)*RBEAM
              IF((rng_seed .GT. 128))call ranmar_get
              YIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              YIN=(2.0*YIN-1.0)*RBEAM
              R2=XIN**2+YIN**2
              IF((R2.LE.RBEAM2))GO TO4602
            GO TO 4601
4602        CONTINUE
            DO 4611 IX=1,NR
              IXIN=IX
              IF((R2.LE.CYRAD2(IX)))GO TO4612
4611        CONTINUE
4612        CONTINUE
            IRIN=2+(IXIN-1)*NZ
            ZIN=ZPLANE(1)
            NRCFLG=10
          ELSE
4621        CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              XIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              XIN=(2.0*XIN-1.0)*RBEAM
              IF((rng_seed .GT. 128))call ranmar_get
              YIN = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              YIN=(2.0*YIN-1.0)*RBEAM
              R2=XIN**2+YIN**2
              IF((R2.LE.RBEAM2))GO TO4622
            GO TO 4621
4622        CONTINUE
            DO 4631 IX=1,NR
              IXIN=IX
              IF((R2.LE.CYRAD2(IX)))GO TO4632
4631        CONTINUE
4632        CONTINUE
            IRIN=1+IXIN*NZ
            ZIN=ZPLANE(NPLANE)
            NRCFLG=30
          END IF
        END IF
        WEIGHT=1.0
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 20)) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO1 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO2 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        K=MIN(dble(4)*RNNO1+1.,dble(4))
        XIN=SQRT(RCDFIN(K,1)+RNNO2*RCDFIN(K,2))
        YIN=0.0
        ZIN=ZPLANE(1)
        DO 4641 IX=1,NR
          IXIN=IX
          IF((XIN.LE.RCYL(IX)))GO TO4642
4641    CONTINUE
4642    CONTINUE
        IRIN=2+(IXIN-1)*NZ
        WIN=1.0
        UIN=0.0
        VIN=0.0
        NRCFLG=10
        WEIGHT=1.0
        NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 21)) THEN
        IF ((NRCYCL.GT.0 .AND. CYCLNUM.GT.0 .AND. CYCLNUM.LE.NRCYCL)) TH
     *  EN
          CYCLNUM=CYCLNUM+1
          XIN=XINOLD
          YIN=YINOLD
          ZIN=ZINOLD
          UIN=UINOLD
          VIN=VINOLD
          WIN=WINOLD
          IRIN=IRINOLD
          NRCFLG=NRCFLGOLD
          WEIGHT=WEIGHTOLD
          NNREAD=NNREAD+1
        ELSE
4650      CONTINUE
          NPHSPN=NPHSPN+1
          IF ((IPARALLEL.GT.1 .AND. PARNUM.GT.0 .AND. NPHSPN .GT. INT(PA
     *    RNUM*NCASE_PHSP/IPARALLEL))) THEN
            NPHSPN=INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+1
            OUTCNT=OUTCNT+1
            WRITE(6,4660)
4660        FORMAT(' ***WARNING*** Used all particles from partition ins
     *ource file.'/ '               Restarting from first particle in pa
     *rtition.')
            WRITE(IOUT, '('' ***WARNING*** Used all particles from parti
     *tion in source file.''/           ''               Restarting from
     * first particle in partition.'')')
            IF ((i_iaea_in.EQ.1)) THEN
              NHSTRY=OUTCNT*NINCSRC/IPARALLEL
              iaea_dummy_long=NPHSPN
              call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result
     *        )
              IF ((iaea_result.LT.0)) THEN
                WRITE(i_log,*)' Error going to record ',NPHSPN,' in IAEA
     * phsp file.'
                call exit(1)
              END IF
            END IF
          ELSE IF((n_parallel.GT.0 .AND. NPHSPN.GT.NPHSPN_MAX)) THEN
            NPHSPN=NPHSPN_MIN
            OUTCNT=OUTCNT+1
            WRITE(6,4670)
4670        FORMAT(///' ***WARNING*** USED ALL PARTICLES FROM CHUNK IN S
     *OURCE FILE!'/ '               RESTARTING FROM FIRST PARTICLE IN TH
     *IS CHUNK.'// /1x,79('*')//)
            IF ((i_iaea_in.EQ.1)) THEN
              NHSTRY=OUTCNT*NINCSRC/(n_parallel*10)
              iaea_dummy_long=NPHSPN
              call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result
     *        )
              IF ((iaea_result.LT.0)) THEN
                WRITE(i_log,*)' Error going to record ',NPHSPN,' in IAEA
     * phsp file.'
                call exit(1)
              END IF
            END IF
          ELSE IF((NPHSPN.GT.NCASE_PHSP)) THEN
            NPHSPN=1
            OUTCNT=OUTCNT+1
            WRITE(6,4680)
4680        FORMAT(' ***WARNING*** Used all particles from source file.'
     */ '               Restarting from first particle.')
            WRITE(IOUT, '('' ***WARNING*** Used all particles from sourc
     *e file.''/                        ''               Restarting from
     * first particle.'')')
            IF ((i_iaea_in.EQ.1)) THEN
              NHSTRY=OUTCNT*NINCSRC
              iaea_dummy_long=NPHSPN
              call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result
     *        )
              IF ((iaea_result.LT.0)) THEN
                WRITE(i_log,*)' Error going to record ',NPHSPN,' in IAEA
     * phsp file.'
                call exit(1)
              END IF
            END IF
          END IF
          IF ((OUTCNT.GT.1000)) THEN
            WRITE(6,4690)
4690        FORMAT(' ***ERROR*** >1000 restart warnings.')
            WRITE(IOUT, '('' ***ERROR*** >1000 restart warnings.'')')
            STOP
          END IF
          IF ((i_iaea_in.EQ.1)) THEN
            NPASS=0
            call iaea_get_particle(i_unit_in,iaea_n_stat,iaea_q_index,ES
     *      HORT,WT_PHSP_SHORT, X_PHSP_SHORT,Y_PHSP_SHORT,Z_PHSP_SHORT,U
     *      _PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,iaea_extra_floats,iae
     *      a_extra_ints)
            IF ((iaea_n_stat.EQ.-1)) THEN
              WRITE(i_log,*)' Error getting particle data from IAEA phsp
     * file.'
              call exit(1)
            ELSE IF((iaea_n_stat.EQ.-2)) THEN
              WRITE(i_log,*)' WARNING: Reached end of IAEA phsp file.  F
     *ile restarted.'
            ELSE IF((iaea_n_stat.GE.0)) THEN
              NHSTRY=NHSTRY+iaea_n_stat
              IF ((iaea_i_latch.EQ.-99)) THEN
                LATCHI=0
              ELSE
                LATCHI=iaea_extra_ints(iaea_i_latch)
              END IF
              IQIN=iaea_typ_q(iaea_q_index)
              IF (( (IQIN.EQ.1) .OR. (IQIN.EQ.-1) )) THEN
                ESHORT = ESHORT + 0.5109989461
              END IF
              EIN=ESHORT
              IF ((iaea_i_zlast.EQ.-99)) THEN
                ZLAST_PHSP_SHORT=0
              ELSE
                ZLAST_PHSP_SHORT= iaea_extra_floats(iaea_i_zlast)
              END IF
              IF ((iaea_i_muidx.EQ.-99)) THEN
                MUIDX_PHSP_SHORT=0
              ELSE
                MUIDX_PHSP_SHORT= iaea_extra_floats(iaea_i_muidx)
              END IF
              WEIGHT=WT_PHSP_SHORT
              XIN=X_PHSP_SHORT
              YIN=Y_PHSP_SHORT
              ZIN=Z_PHSP_SHORT
              UIN=U_PHSP_SHORT
              VIN=V_PHSP_SHORT
              WIN=W_PHSP_SHORT
              ZLAST=ZLAST_PHSP_SHORT
              MUIDX=MUIDX_PHSP_SHORT
            END IF
          ELSE
            IF ((IMODE.NE.0)) THEN
              READ(42,REC=NPHSPN+1,IOSTAT=IERR_PHSP) LATCHI,ESHORT,X_PHS
     *        P_SHORT,Y_PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SH
     *        ORT,ZLAST_PHSP_SHORT
            ELSE
              READ(42,REC=NPHSPN+1,IOSTAT=IERR_PHSP) LATCHI,ESHORT,X_PHS
     *        P_SHORT,Y_PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SH
     *        ORT
            END IF
            IF ((NPHSPN+1.EQ.76695869)) THEN
              write(*,*)' x,y,u,v,wt,eshort,latch', X_PHSP_SHORT,Y_PHSP_
     *        SHORT,U_PHSP_SHORT,V_PHSP_SHORT, WT_PHSP_SHORT,ESHORT,LATC
     *        HI
            END IF
            IF ((ESHORT.LT.0.0)) THEN
              NHSTRY=NHSTRY+1
              ESHORT=ABS(ESHORT)
            END IF
            EIN=ESHORT
            WEIGHT=WT_PHSP_SHORT
            XIN=X_PHSP_SHORT
            YIN=Y_PHSP_SHORT
            UIN=U_PHSP_SHORT
            VIN=V_PHSP_SHORT
            IF((IMODE.NE.0))ZLAST=ZLAST_PHSP_SHORT
            IF ((IERR_PHSP.EQ.0)) THEN
              EIN=ESHORT
              IF ((btest(LATCHI, 31))) THEN
                NPASS = 1
                LATCHI = ibclr(LATCHI,31)
              ELSE
                NPASS = 0
              END IF
              IF ((btest(LATCHI, 30))) THEN
                IQIN = -1
                LATCHI = ibclr(LATCHI,30)
                LATCHI = ibclr(LATCHI,29)
              ELSE
                IF ((btest(LATCHI, 29))) THEN
                  IQIN = 1
                  LATCHI = ibclr(LATCHI,29)
                ELSE
                  IQIN = 0
                END IF
              END IF
              WIN = min( 1., UIN**2 + VIN**2)
              WIN = sqrt(1. - WIN)
              WIN = SIGN(WIN,WEIGHT)
              WEIGHT=ABS(WEIGHT)
            END IF
          END IF
          NNREAD=NNREAD+1
          IF((DOSE_STAT.EQ.1 .OR. NHSTRY.EQ.0))NHSTRY=NHSTRY+1
          IF((NPASS.EQ.1))GOTO 4650
          IF ((IQIN .EQ.-1 .AND. IQINC.NE.-1 .AND. IQINC.NE.2 .AND. IQIN
     *    C .NE.3)) THEN
            GOTO 4650
          END IF
          IF ((IQIN .EQ. 1 .AND. IQINC.NE. 1 .AND. IQINC.NE.2 .AND. IQIN
     *    C .NE.3)) THEN
            GOTO 4650
          END IF
          IF ((IQIN .EQ. 0 .AND. IQINC.NE. 0 .AND. IQINC.NE.2)) THEN
            GOTO 4650
          END IF
          R2 = XIN**2 +YIN**2
          IF ((R2 .GT. CYRAD2(NR))) THEN
            GOTO 4650
          END IF
          DO 4701 IX=1,NR
            IXIN=IX
            IF((R2 .LE. CYRAD2(IX)))GO TO4702
4701      CONTINUE
4702      CONTINUE
          IRIN=2+(IXIN-1)*NZ
          ZIN=ZPLANE(1)
          NRCFLG = 10
          IF ((NRCYCL.GT.0)) THEN
            CYCLNUM=1
            XINOLD=XIN
            YINOLD=YIN
            ZINOLD=ZIN
            UINOLD=UIN
            VINOLD=VIN
            WINOLD=WIN
            IRINOLD=IRIN
            NRCFLGOLD=NRCFLG
            WEIGHTOLD=WEIGHT
          END IF
        END IF
      ELSE IF(( ISOURC .EQ. 23 )) THEN
4711    CONTINUE
4720      CONTINUE
          call sample_beamsource(ein,xin,yin,zin,uin,vin,win,weight,iqin
     *    ,latchi, nhstry,iphatin)
          IF((iqinc .LT. 2 .AND. iqin .NE. iqinc))goto 4720
          IF((iqinc .EQ. 3 .AND. iqin .EQ. 0))goto 4720
          IF (( weight .LT. min_weight_23 .OR. weight .GT. max_weight_23
     *     )) THEN
            goto 4720
          END IF
          IF (( secret_option_23 .EQ. 1 )) THEN
            IF (( xin .GT. 0 )) THEN
              xin = -xin
              uin = -uin
            END IF
          END IF
          xin_tmp = xin
          yin_tmp = yin
          zin_tmp = zin
          xin=xin+xoffset
          yin=yin+yoffset
          zin = -dist_phsp*cost_phsp + yin*sint_phsp + chamber_c
          yin = dist_phsp*sint_phsp + yin*cost_phsp
          vtemp = vin
          vin = -win*sint_phsp + vin*cost_phsp
          win = win*cost_phsp + vtemp*sint_phsp
          radp = xin*xin + yin*yin
          IF (( radp .GT. CYRAD2(nr) .OR. zin .LT. zplane(1) .OR. zin .G
     *    T. zplane(nz+1) )) THEN
            check = .true.
            IF (( zin .LT. zplane(1) .AND. win .GT. 0 )) THEN
              tf = (zplane(1)-zin)/win
            ELSE IF(( zin .GT. zplane(nz+1) .AND. win .LT. 0 )) THEN
              tf = (zplane(nz+1) - zin)/win
            ELSE
              check = .false.
            END IF
            IF (( check )) THEN
              xtmp = xin + uin*tf
              ytmp = yin + vin*tf
              radp = xtmp*xtmp + ytmp*ytmp
              IF (( radp .LE. CYRAD2(nr) )) THEN
                xin = xtmp
                yin = ytmp
                IF (( zin .LT. zplane(1) )) THEN
                  zin = zplane(1)
                  iz = 1
                ELSE
                  zin = zplane(nz+1)
                  iz = nz
                END IF
                DO 4731 ix=1,nr
                  IF((radp .LE. CYRAD2(ix)))GO TO4732
4731            CONTINUE
4732            CONTINUE
                GO TO4712
              END IF
              radp = xin*xin + yin*yin
            END IF
            IF((radp .LT. CYRAD2(nr)))GO TO4711
            phbb = uin*uin + vin*vin
            IF((phbb .LT. 1e-15))GO TO4711
            pha = (xin*uin + yin*vin)/phbb
            IF((pha .GT. 0))GO TO4711
            phb = (radp - CYRAD2(nr))/phbb
            phd = pha*pha - phb
            IF((phd .LT. 0))GO TO4711
            tf = -pha-sqrt(phd)
            IF((tf .LT. 0))GO TO4711
            zin = zin + tf*win
            IF((zin .LT. zplane(1) .OR. zin .GT. zplane(nz+1)))GO TO4711
            ix = nr
            xin = xin + uin*tf
            yin = yin + vin*tf
            DO 4741 iz=2,nplane
              IF((zin .LE. zplane(iz)))GO TO4742
4741        CONTINUE
4742        CONTINUE
            iz = iz-1
            GO TO4712
          ELSE
            DO 4751 iz=2,nplane
              IF((zin .LE. zplane(iz)))GO TO4752
4751        CONTINUE
4752        CONTINUE
            iz = iz-1
            DO 4761 ix=1,nr
              IF((radp .LE. CYRAD2(ix)))GO TO4762
4761        CONTINUE
4762        CONTINUE
            GO TO4712
          END IF
        GO TO 4711
4712    CONTINUE
        irin = 1 + (ix-1)*nz + iz
        ihstry = ihstry + nhstry - last_nhstry
        last_nhstry = nhstry
      ELSE IF((ISOURC .EQ. 22)) THEN
        IF ((NRCYCL.GT.0 .AND. CYCLNUM.GT.0 .AND. CYCLNUM.LE.NRCYCL)) TH
     *  EN
          CYCLNUM=CYCLNUM+1
          XIN=XINOLD
          YIN=YINOLD
          ZIN=ZINOLD
          UIN=UINOLD
          VIN=VINOLD
          WIN=WINOLD
          IRIN=IRINOLD
          NRCFLG=NRCFLGOLD
          WEIGHT=WEIGHTOLD
          NNREAD=NNREAD+1
        ELSE
4770      CONTINUE
          NPHSPN=NPHSPN+1
          IF ((IPARALLEL.GT.1 .AND. PARNUM.GT.0 .AND. NPHSPN .GT. INT(PA
     *    RNUM*NCASE_PHSP/IPARALLEL))) THEN
            NPHSPN=INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+1
            OUTCNT=OUTCNT+1
            WRITE(6,4780)
4780        FORMAT(' ***WARNING*** Used all particles from partition ins
     *ource file.'/ '               Restarting from first particle in pa
     *rtition.')
            WRITE(IOUT, '('' ***WARNING*** Used all particles from parti
     *tion in source file.''/           ''               Restarting from
     * first particle in partition.'')')
            IF ((i_iaea_in.EQ.1)) THEN
              NHSTRY=OUTCNT*NINCSRC/IPARALLEL
              iaea_dummy_long=NPHSPN
              call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result
     *        )
              IF ((iaea_result.LT.0)) THEN
                WRITE(i_log,*)' Error going to record ',NPHSPN,' in IAEA
     * phsp file.'
                call exit(1)
              END IF
            END IF
          ELSE IF((n_parallel.GT.0 .AND. NPHSPN.GT.NPHSPN_MAX)) THEN
            NPHSPN=NPHSPN_MIN
            OUTCNT=OUTCNT+1
            WRITE(6,4790)
4790        FORMAT(///' ***WARNING*** USED ALL PARTICLES FROM CHUNK IN S
     *OURCE FILE!'/ '               RESTARTING FROM FIRST PARTICLE IN TH
     *IS CHUNK.'// /1x,79('*')//)
            IF ((i_iaea_in.EQ.1)) THEN
              NHSTRY=OUTCNT*NINCSRC/(n_parallel*10)
              iaea_dummy_long=NPHSPN
              call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result
     *        )
              IF ((iaea_result.LT.0)) THEN
                WRITE(i_log,*)' Error going to record ',NPHSPN,' in IAEA
     * phsp file.'
                call exit(1)
              END IF
            END IF
          ELSE IF((NPHSPN.GT.NCASE_PHSP)) THEN
            NPHSPN=1
            OUTCNT=OUTCNT+1
            WRITE(6,4800)
4800        FORMAT(' ***WARNING*** Used all particles from source file.'
     */ '               Restarting from first particle.')
            WRITE(IOUT, '('' ***WARNING*** Used all particles from sourc
     *e file.''/                        ''               Restarting from
     * first particle.'')')
            IF ((i_iaea_in.EQ.1)) THEN
              NHSTRY=OUTCNT*NINCSRC
              iaea_dummy_long=NPHSPN
              call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result
     *        )
              IF ((iaea_result.LT.0)) THEN
                WRITE(i_log,*)' Error going to record ',NPHSPN,' in IAEA
     * phsp file.'
                call exit(1)
              END IF
            END IF
          END IF
          IF ((OUTCNT.GT.1000)) THEN
            WRITE(6,4810)
4810        FORMAT(' ***ERROR*** >1000 restart warnings.')
            WRITE(IOUT, '('' ***ERROR*** >1000 restart warnings.'')')
            STOP
          END IF
          IF ((i_iaea_in.EQ.1)) THEN
            NPASS=0
            call iaea_get_particle(i_unit_in,iaea_n_stat,iaea_q_index,ES
     *      HORT,WT_PHSP_SHORT, X_PHSP_SHORT,Y_PHSP_SHORT,Z_PHSP_SHORT,U
     *      _PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,iaea_extra_floats,iae
     *      a_extra_ints)
            IF ((iaea_n_stat.EQ.-1)) THEN
              WRITE(i_log,*)' Error getting particle data from IAEA phsp
     * file.'
              call exit(1)
            ELSE IF((iaea_n_stat.EQ.-2)) THEN
              WRITE(i_log,*)' WARNING: Reached end of IAEA phsp file.  F
     *ile restarted.'
            ELSE IF((iaea_n_stat.GE.0)) THEN
              NHSTRY=NHSTRY+iaea_n_stat
              IF ((iaea_i_latch.EQ.-99)) THEN
                LATCHI=0
              ELSE
                LATCHI=iaea_extra_ints(iaea_i_latch)
              END IF
              IQIN=iaea_typ_q(iaea_q_index)
              IF (( (IQIN.EQ.1) .OR. (IQIN.EQ.-1) )) THEN
                ESHORT = ESHORT + 0.5109989461
              END IF
              EIN=ESHORT
              IF ((iaea_i_zlast.EQ.-99)) THEN
                ZLAST_PHSP_SHORT=0
              ELSE
                ZLAST_PHSP_SHORT= iaea_extra_floats(iaea_i_zlast)
              END IF
              IF ((iaea_i_muidx.EQ.-99)) THEN
                MUIDX_PHSP_SHORT=0
              ELSE
                MUIDX_PHSP_SHORT= iaea_extra_floats(iaea_i_muidx)
              END IF
              WEIGHT=WT_PHSP_SHORT
              XIN=X_PHSP_SHORT
              YIN=Y_PHSP_SHORT
              ZIN=Z_PHSP_SHORT
              UIN=U_PHSP_SHORT
              VIN=V_PHSP_SHORT
              WIN=W_PHSP_SHORT
              ZLAST=ZLAST_PHSP_SHORT
              MUIDX=MUIDX_PHSP_SHORT
            END IF
          ELSE
            IF ((IMODE.NE.0)) THEN
              READ(42,REC=NPHSPN+1,IOSTAT=IERR_PHSP) LATCHI,ESHORT,X_PHS
     *        P_SHORT,Y_PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SH
     *        ORT,ZLAST_PHSP_SHORT
            ELSE
              READ(42,REC=NPHSPN+1,IOSTAT=IERR_PHSP) LATCHI,ESHORT,X_PHS
     *        P_SHORT,Y_PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SH
     *        ORT
            END IF
            IF ((NPHSPN+1.EQ.76695869)) THEN
              write(*,*)' x,y,u,v,wt,eshort,latch', X_PHSP_SHORT,Y_PHSP_
     *        SHORT,U_PHSP_SHORT,V_PHSP_SHORT, WT_PHSP_SHORT,ESHORT,LATC
     *        HI
            END IF
            IF ((ESHORT.LT.0.0)) THEN
              NHSTRY=NHSTRY+1
              ESHORT=ABS(ESHORT)
            END IF
            EIN=ESHORT
            WEIGHT=WT_PHSP_SHORT
            XIN=X_PHSP_SHORT
            YIN=Y_PHSP_SHORT
            UIN=U_PHSP_SHORT
            VIN=V_PHSP_SHORT
            IF((IMODE.NE.0))ZLAST=ZLAST_PHSP_SHORT
            IF ((IERR_PHSP.EQ.0)) THEN
              EIN=ESHORT
              IF ((btest(LATCHI, 31))) THEN
                NPASS = 1
                LATCHI = ibclr(LATCHI,31)
              ELSE
                NPASS = 0
              END IF
              IF ((btest(LATCHI, 30))) THEN
                IQIN = -1
                LATCHI = ibclr(LATCHI,30)
                LATCHI = ibclr(LATCHI,29)
              ELSE
                IF ((btest(LATCHI, 29))) THEN
                  IQIN = 1
                  LATCHI = ibclr(LATCHI,29)
                ELSE
                  IQIN = 0
                END IF
              END IF
              WIN = min( 1., UIN**2 + VIN**2)
              WIN = sqrt(1. - WIN)
              WIN = SIGN(WIN,WEIGHT)
              WEIGHT=ABS(WEIGHT)
            END IF
          END IF
          NNREAD=NNREAD+1
          IF((DOSE_STAT.EQ.1 .OR. NHSTRY.EQ.0))NHSTRY=NHSTRY+1
          IF((NPASS.EQ.1))GOTO 4770
          IF ((IQIN.EQ.-1 .AND. IQINC.NE.-1 .AND. IQINC.NE.2 .AND. IQINC
     *     .NE.3)) THEN
            GOTO 4770
          END IF
          IF ((IQIN.EQ. 1 .AND. IQINC.NE. 1 .AND. IQINC.NE.2 .AND. IQINC
     *     .NE.3)) THEN
            GOTO 4770
          END IF
          IF ((IQIN.EQ. 0 .AND. IQINC.NE. 0 .AND. IQINC.NE.2)) THEN
            GOTO 4770
          END IF
          xin=xin+xoffset
          yin=yin+yoffset
          zin = -dist_phsp*cost_phsp + yin*sint_phsp + chamber_c
          yin = dist_phsp*sint_phsp + yin*cost_phsp
          vtemp = vin
          vin = -win*sint_phsp + vin*cost_phsp
          win = win*cost_phsp + vtemp*sint_phsp
          radp = xin*xin + yin*yin
          IF (( radp .GT. CYRAD2(nr) .OR. zin .LT. zplane(1) .OR. zin .G
     *    T. zplane(nz+1) )) THEN
            check = .true.
            IF (( zin .LT. zplane(1) .AND. win .GT. 0 )) THEN
              tf = (zplane(1)-zin)/win
            ELSE IF(( zin .GT. zplane(nz+1) .AND. win .LT. 0 )) THEN
              tf = (zplane(nz+1) - zin)/win
            ELSE
              check = .false.
            END IF
            IF (( check )) THEN
              xtmp = xin + uin*tf
              ytmp = yin + vin*tf
              radp = xtmp*xtmp + ytmp*ytmp
              IF (( radp .LE. CYRAD2(nr) )) THEN
                xin = xtmp
                yin = ytmp
                IF (( zin .LT. zplane(1) )) THEN
                  zin = zplane(1)
                  iz = 1
                ELSE
                  zin = zplane(nz+1)
                  iz = nz
                END IF
                DO 4821 ix=1,nr
                  IF((radp .LE. CYRAD2(ix)))GO TO4822
4821            CONTINUE
4822            CONTINUE
                goto 4830
              END IF
              radp = xin*xin + yin*yin
            END IF
            IF((radp .LT. CYRAD2(nr)))goto 4770
            phbb = uin*uin + vin*vin
            IF((phbb .LT. 1e-15))goto 4770
            pha = (xin*uin + yin*vin)/phbb
            IF((pha .GT. 0))goto 4770
            phb = (radp - CYRAD2(nr))/phbb
            phd = pha*pha - phb
            IF((phd .LT. 0))goto 4770
            tf = -pha-sqrt(phd)
            IF((tf .LT. 0))goto 4770
            zin = zin + tf*win
            IF((zin .LT. zplane(1) .OR. zin .GT. zplane(nz+1)))goto 4770
            ix = nr
            xin = xin + uin*tf
            yin = yin + vin*tf
            DO 4841 iz=2,nplane
              IF((zin .LE. zplane(iz)))GO TO4842
4841        CONTINUE
4842        CONTINUE
            iz = iz-1
            goto 4830
          END IF
          DO 4851 iz=2,nplane
            IF((zin .LE. zplane(iz)))GO TO4852
4851      CONTINUE
4852      CONTINUE
          iz = iz-1
          DO 4861 ix=1,nr
            IF((radp .LE. CYRAD2(ix)))GO TO4862
4861      CONTINUE
4862      CONTINUE
4830      count_phsp = count_phsp + 1
          irin = 1 + (ix-1)*nz + iz
          NRCFLG = 20
          IF ((NRCYCL.GT.0)) THEN
            CYCLNUM=1
            XINOLD=XIN
            YINOLD=YIN
            ZINOLD=ZIN
            UINOLD=UIN
            VINOLD=VIN
            WINOLD=WIN
            IRINOLD=IRIN
            NRCFLGOLD=NRCFLG
            WEIGHTOLD=WEIGHT
          END IF
        END IF
      END IF
      RETURN
      ENTRY SRCEND
      IF (( ISOURC .EQ. 23 )) THEN
        call finish_beamsource
      END IF
      return
100   FORMAT(' ',2(I2,' '),4(G14.7,' '))
200   FORMAT(' ',I1)
300   FORMAT(' ',I3)
400   FORMAT(' ',2(G14.7,' '))
500   FORMAT(/' ',79('*')//T30,'SOURCE PARAMETERS'//' ',79('*')/)
510   FORMAT(T20,'Parallel beam on front face, radius=',F8.3,'cm'/T30,' 
     *X-axis direction cosine=',F10.4/T30,' Y-axis direction cosine=',F1
     *0.4/T30,' Z-axis direction cosine=',F10.4/T30,' Incident fluence='
     *, 1PE13.3,'/cm**2')
520   FORMAT(T5,'Point source on cyl axis',F8.1,' cm away, collimated to
     * R =',F8.3,' cm',/T5,'Incident fluence(at front face on axis) * ',
     *'Solid angle=',1PE14.3)
525   FORMAT(T5,'Point source on cyl axis',F8.1,' cm away'/T10,'Collimat
     *ed to radii =',F8.3,' cm to ',F8.3,' cm',/T5,'Incident fluence(at 
     *front face on axis) * ','SOLID ANGLE=',1PE14.3)
530   FORMAT(T20,'PARALLEL BEAM INCIDENT ON CYLINDRICAL WALL',/T21,'RADI
     *AL DIMENSION=',F8.3,' cm, HALF-LENGTH=',F8.3,' cm')
535   FORMAT(T5,'Point source on cyl axis',F8.1,' cm away'/T10,'Collimat
     *ed to x =',F8.3,' cm, y = ',F8.3,' cm',/T5,'Incident fluence(at fr
     *ont face on axis) * ','SOLID ANGLE=',1PE14.3)
540   FORMAT(T20,'POINT SOURCE INCIDENT FROM SIDE',F8.1,' cm',' FROM MID
     *-POINT'/T25,'RADIAL DIMENSION=',F8.3,' cm',' HALF-LENGTH=',F8.3,' 
     *cm')
550   FORMAT(/T30,'NOTE BEAM DOES NOT COVER THE DETECTOR'/T30,37('*') )
560   FORMAT(' ',T20,'BROAD PARALLEL BEAM ON CYLINDRICAL AXIS')
570   FORMAT(T10,'ISOTROPICALLY RADIATING, UNIFORM SOURCE LOCATED'/'    
     *  between radii',2F10.3,' and DEPTHS', 2F10.3)
580   FORMAT(' ',T20,'POINT SOURCE OFF AXIS, RADIAL COORDINATE ',F8.3,' 
     *cm'/' ',T20,'PERPENDICULAR DISTANCE OF SOURCE FROM FRONT FACE ',F8
     *.3,' cm')
585   FORMAT(T20,'BROAD PARALLEL BEAM FROM ANY ANGLE'/T30,' X-AXIS DIREC
     *TION COSINE=',F10.4/T30,' Y-AXIS DIRECTION COSINE=',F10.4/T30,' Z-
     *AXIS DIRECTION COSINE=',F10.4/T30,' INCIDENT FLUENCE=', 1PE13.3,'/
     *cm**2')
590   FORMAT(' ',T23,'CENTRAL AXIS FLUENCE VS BEAM RADIUS'/T25,'CENTRAL 
     *AXIS RADIUS=',F9.4,' cm'//12X,'  TREAT RADIAL BINS AS BEAM RADIUS,
     * NOT SCORING REGION RADIUS'/)
595   FORMAT(' ',T20,'RADIAL DISTRIBUTION, FRONTAL PARELLEL BEAM'/)
605   FORMAT(80A1)
600   FORMAT(27A1)
610   FORMAT(' ',T20,'RADIAL DISTBN, # OF INCIDENT RADIAL BINS:',T60,I5/
     *' ',T20,'BIN    KINETIC RADIAL     PROBABILITY  CUMULATIVE PROB')
620   FORMAT(' ',T20,I3,T28,F7.3,T45,1PE10.3,T60,0PF7.4)
630   FORMAT(/' *******WARNING******'/T20,'SOME OF NORMALIZED BIN',' PRO
     *BABILITIES SO SMALL BINS MAY BE MISSED'/)
640   FORMAT(T20,'Full phase space input for each incident particle. '/T
     *5,' Source data file: ',256A1/T25,' Source incident on front face,
     * Z =',F14.4,' cm.'/T25,' # of particles read from ph-sp file =', 1
     *PE13.3,'.')
642   FORMAT(T20,'Full phase space input for each incident particle. '/T
     *5,' Source data file: ',80A1/T25,' Source incident on plane, Y =',
     *F14.4,' cm.'/T25,' Centre of source plane at Z =',F14.4,' cm.'/T25
     *,' # of particles read from ph-sp file =', 1PE13.3,'.')
650   FORMAT(I1,1X,I7,1X,F5.0,1X,2(F4.0,1X),F1.0,1X,2(F10.8,1X),E10.4)
660   FORMAT(40A1/22A1/80A1/I10,3X,3F6.0/)
670   FORMAT(40A1/22A1/80A1/I10,3X,3F6.0//)
677   FORMAT(T20,'Full phase space input for each incident particle. '/T
     *5,' Source data file: ',256A1/T25,' Source incident on plane ',F14
     *.4,' cm from the point of rotation'/T25,' Angle with respect to z-
     *axis ',F14.4,' degrees.'/T25,' z-position of point of rotation ',f
     *14.4,/T25,' X offset of phsp (before rotation)',F14.4,' cm'/T25,' 
     *Y offset of phsp (before rotation)',F14.4,' cm'/T25,' # of particl
     *es read from ph-sp file =', 1PE13.3,'.')
679   FORMAT(T20,' Full treatment head simulation from an angle'/,T10,' 
     *   Particle charge                               : ',i3,/T10,'    
     *Weight window                                 : ',2g15.6,/T10,'   
     * BEAMnrc user code                             : ',a,/T10,'    PEG
     *S data file                                : ',a,/T10,'    Input f
     *ile                                    : ',a,/T10,'    Rotation po
     *int to phsp-plane midpoint distance: ',f10.4,/T10,'    Incident an
     *gle (degrees)                      : ',f10.4,/T10,'    Rotation po
     *int (will be set to chamber center'/,T10,'      if greater than 1e
     *4 or less than -1e4):     : ',g14.4,' cm'/T10,'    X offset of phs
     *p plane (before rotation)      : ',f10.4,' cm'/T10,'    Y offset o
     *f phsp plane (before rotation)      : ',f10.4,' cm'/T10,'    Max. 
     *kinetic energy of simulation             : ',f10.4,' MeV')
      END
      subroutine src15
      implicit none
      COMMON/GEOM/ZPLANE( 501),RCYL(0:4), CYRAD2(4),NTRACK( 2001),NZ,NR,
     *NREG,NPLANE
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NTRACK,NZ,NR,NREG,NPLANE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET,TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
     *, IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP( 2001),IVAL,DATCOUNT
      real*8 TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
      integer*4 IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP,IVAL,DATCOUN
     *T
      integer*8 NCASE,NCASEO,NCASET
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(4,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBEAM
     *,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DI
     *STZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PRO
     *BSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,ZS
     *OFST,                                                      SVTMP1,
     *SVTMP2,SVTMP3,SVTMP4,
     *       RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                     XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,WEI
     *GHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      real*8 temp1,temp2,temp3,temp4
      real*8 XIN,YIN,ZIN,UIN,VIN,WIN,WEIGHT
      integer*4 NRCFLG,IRIN,iout,error_flag
      real*8 theta,cost,sint,d,d2,yo,zo,dz,R,R2,area,w0,pi,zc,ro2
      real*8 fak,x1,y1,x2,y2,x3,y3,xmin,xmax,delx,ymin,ymax,dely
      real*8 count,sumw,sumw2
      logical just_fb,just_side,enter_fb,enter_side
      real*8 eta1,eta2,xx,yy,zz,dist2,dist,uli,vli,wli, xli,yli,zli,rad2
     *,ts,tf,ur2,ux,ux2,rr2,del,error
      integer*4 ix,iz
      save cost,sint,d,d2,yo,zo,dz,R,R2,xmin,delx,ymin,dely, zc,area,w0,
     *count,sumw,sumw2,just_fb,just_side,pi,ro2
      entry src15_ini(temp1,temp2,temp3,temp4,error_flag)
      pi = 4*datan(1d0)
      theta = temp2
      IF (( theta .GT. 180 )) THEN
        theta = 360 - theta
      END IF
      theta = theta*pi/180
      cost = cos(theta)
      sint = sin(theta)
      d = temp1
      d2 = d*d
      yo = d*sint
      zo = -d*cost
      R = RCYL(NR)
      R2 = R*R
      dz = 0.5*(ZPLANE(NPLANE)-ZPLANE(1))
      zc = 0.5*(ZPLANE(NPLANE)+ZPLANE(1))
      IF (( yo .GT. -R .AND. yo .LT. R .AND. zo .GT. -dz .AND. zo .LT. d
     *z )) THEN
        error_flag = 1
      END IF
      just_fb = .false.
      just_side = .false.
      IF (( yo .GE. -R .AND. yo .LE. R )) THEN
        just_fb = .true.
      END IF
      IF (( zo .GE. -dz .AND. zo .LE. dz )) THEN
        just_side = .true.
      END IF
      IF (( just_fb )) THEN
        IF (( zo .LT. -dz )) THEN
          fak = 1./(1-(-R*sint + dz*cost)/d)
          x1 = R*fak
          y1 = (-R*cost-dz*sint)*fak
          fak = 1./(1-(R*sint + dz*cost)/d)
          x2 = R*fak
          y2 = (R*cost-dz*sint)*fak
        ELSE
          fak = 1./(1-(-R*sint - dz*cost)/d)
          x1 = R*fak
          y1 = (-R*cost+dz*sint)*fak
          fak = 1./(1-(R*sint - dz*cost)/d)
          x2 = R*fak
          y2 = (R*cost+dz*sint)*fak
        END IF
        ymin = MIN(y1,y2)
        ymax = MAX(y1,y2)
        xmax = MAX(x1,x2)
        xmin = -xmax
      ELSE IF(( just_side )) THEN
        fak = 1./(1-(R*sint + dz*cost)/d)
        x1 = R*fak
        y1 = (R*cost-dz*sint)*fak
        fak = 1./(1-(R*sint - dz*cost)/d)
        x2 = R*fak
        y2 = (R*cost+dz*sint)*fak
        ymin = MIN(y1,y2)
        ymax = MAX(y1,y2)
        xmax = MAX(x1,x2)
        xmin = -xmax
      ELSE
        IF (( zo .LT. -dz )) THEN
          fak = 1./(1-(-R*sint + dz*cost)/d)
          x1 = R*fak
          y1 = (-R*cost-dz*sint)*fak
        ELSE
          fak = 1./(1-(-R*sint - dz*cost)/d)
          x1 = R*fak
          y1 = (-R*cost+dz*sint)*fak
        END IF
        fak = 1./(1-(R*sint + dz*cost)/d)
        x2 = R*fak
        y2 = (R*cost-dz*sint)*fak
        fak = 1./(1-(R*sint - dz*cost)/d)
        x3 = R*fak
        y3 = (R*cost+dz*sint)*fak
        xmax = max(x1,x2,x3)
        xmin = -xmax
        ymin = min(y1,y2,y3)
        ymax = max(y1,y2,y3)
      END IF
      delx = xmax - xmin
      dely = ymax - ymin
      area = delx*dely
      w0 = area/d2
      ro2 = yo*yo
      WRITE(6,4870)IQIN,d,temp2,xmin,xmax,ymin,ymax
4870  FORMAT(/' Electric charge of the source:',T60,I12/ ' Point sourceo
     *ff axis'/ ' Distance of source from centre of chamber: ',T60,f10.4
     *,/ ' Angle to z-axis (degrees): ',T60,f10.4,/, ' Rectangle in the 
     *plane perpendicular to the source-chamber'/ ' axis seen from theso
     *urce: ',/,T40,4f10.4/)
      return
      entry src15_oto(iout)
      ainflu = NCASET/d2
      return
      entry src15_describe(iout)
      write(iout,580) d,theta,yo,zo
580   format(' ',t20,'POINT SOURCE OFF AXIS',/,' ',t20, 'distance to cha
     *mber centre: ',f8.3,' cm',/,' ',t20, 'angle: ',f8.3,' degrees ',/,
     *' ',t20, 'source position: y = ',f8.3,' z = ',f8.3)
      return
      entry src15_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
      count = count + 1
      IF((rng_seed .GT. 128))call ranmar_get
      eta1 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((rng_seed .GT. 128))call ranmar_get
      eta2 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      xx = xmin + delx*eta1
      yy = ymin + dely*eta2
      dist2 = d2 + xx*xx + yy*yy
      dist = sqrt(dist2)
      w0 = d/dist
      zz = yy*sint
      yy = yy*cost
      uli = xx/dist
      vli = (yy-yo)/dist
      wli = (zz-zo)/dist
      tf = 1e15
      ts = 1e15
      enter_fb = .false.
      enter_side = .false.
      IF (( .NOT.just_side )) THEN
        IF (( zo .LT. -dz )) THEN
          tf = (-dz-zo)/wli
        ELSE
          tf = (dz - zo)/wli
        END IF
        xli = uli*tf
        yli = vli*tf + yo
        IF (( xli*xli + yli*yli .LT. R2 )) THEN
          enter_fb = .true.
        ELSE
          tf = 1e15
        END IF
      END IF
      IF (( .NOT.just_fb )) THEN
        ur2 = uli*uli + vli*vli
        ux = -yo*vli/ur2
        ux2 = ux*ux
        rr2 = ro2/ur2
        del = ux2 - rr2 + R2/ur2
        IF (( del .GE. 0 )) THEN
          ts = ux - sqrt(del)
          IF (( ts .GT. 0 )) THEN
            zli = zo + wli*ts
            IF (( zli .GE. -dz .AND. zli .LE. dz )) THEN
              enter_side = .true.
            END IF
          END IF
          IF (( .NOT.enter_side )) THEN
            ts = 1e15
          END IF
        END IF
      END IF
      IF (( .NOT.enter_fb .AND. .NOT.enter_side )) THEN
        weight = 0
        xin = 0
        yin = 0
        zin = zplane(1)
        uin = 0
        vin = 0
        win = 1
        irin = 2
        return
      END IF
      uin = uli
      vin = vli
      win = wli
      weight = w0*area/dist2
      sumw = sumw + weight
      sumw2 = sumw2 + weight*weight
      IF (( tf .LT. ts )) THEN
        xin = xli
        yin = yli
        IF (( zo .LT. -dz )) THEN
          zin = zplane(1)
          iz = 1
        ELSE
          zin = zplane(nplane)
          iz = nplane-1
        END IF
        rad2 = xli*xli+yli*yli
        DO 4881 ix=1,nr
          IF((rad2 .LE. CYRAD2(IX)))GO TO4882
4881    CONTINUE
4882    CONTINUE
      ELSE
        zin = zli + zc
        xin = ts*uli
        yin = yo + vli*ts
        ix = nr
        DO 4891 iz=1,nz
          IF((zin .GE. zplane(iz) .AND. zin .LT. zplane(iz+1)))GO TO4892
4891    CONTINUE
4892    CONTINUE
      END IF
      irin = 1 + (ix-1)*nz + iz
      return
      entry src15_out(iout)
      sumw = sumw/count
      sumw2 = sumw2/count
      error = (sumw2 - sumw*sumw)/(count-1)
      IF (( error .GT. 0 )) THEN
        error = sqrt(error)
      END IF
      write(iout,600) sumw,sumw2
600   format(//'  Source 15: solid angle for detector: ',g14.5,' +/- ',g
     *14.5,//)
      return
      end
      subroutine src16
      implicit none
      COMMON/GEOM/ZPLANE( 501),RCYL(0:4), CYRAD2(4),NTRACK( 2001),NZ,NR,
     *NREG,NPLANE
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NTRACK,NZ,NR,NREG,NPLANE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET,TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
     *, IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP( 2001),IVAL,DATCOUNT
      real*8 TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
      integer*4 IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP,IVAL,DATCOUN
     *T
      integer*8 NCASE,NCASEO,NCASET
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(4,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBEAM
     *,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DI
     *STZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PRO
     *BSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,ZS
     *OFST,                                                      SVTMP1,
     *SVTMP2,SVTMP3,SVTMP4,
     *       RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                     XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,WEI
     *GHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      real*8 temp1,temp2,temp3,temp4
      real*8 XIN,YIN,ZIN,UIN,VIN,WIN,WEIGHT
      integer*4 NRCFLG,IRIN,iout,error_flag
      real*8 pi,theta,cost,sint,d0,d02,R,R2,dz,dr,zc,u,aux,u2, xo,yo,zo,
     *a_side,a_fb,atot,wfb,dist,dist2,rs, delxs,delys,rs2,rad2,eta,sumw,
     *sumw2,count,zz
      logical point_source,do_fb,do_side,do_both,is_circle
      integer*4 ix,iz
      save pi,cost,sint,d0,d02,R,R2,dz,dr,zc,theta, xo,yo,zo,a_side,a_fb
     *,atot,wfb,rs,delxs,delys,rs2, sumw,sumw2,count,point_source,do_fb,
     *do_side,is_circle
      entry src16_ini(temp1,temp2,temp3,temp4,error_flag)
      pi = 4*datan(1d0)
      count = 0
      theta = temp2
      theta = theta*pi/180
      cost = cos(theta)
      sint = sin(theta)
      d0 = temp1
      d02 = d0*d0
      R = RCYL(NR)
      R2 = R*R
      dz = 0.5*(ZPLANE(NPLANE)-ZPLANE(1))
      zc = 0.5*(ZPLANE(NPLANE)+ZPLANE(1))
      IF (( temp3 .LE. 0 .AND. temp4 .LE. 0 )) THEN
        point_source = .true.
        zo = -d0*cost
        yo = d0*sint
        xo = 0
        do_fb = .false.
        do_side = .false.
        do_both = .false.
        a_side = 0
        a_fb = 0
        IF (( abs(yo) .GT. R )) THEN
          u = R/yo
          aux = sqrt(1-u*u)
          dr = R*aux
          do_side = .true.
          a_side = 4*dz*R*yo*(aux-u*atan(aux/u))
        END IF
        IF (( abs(zo) .GT. dz )) THEN
          a_fb = pi*R2*(abs(zo)-dz)
          do_fb = .true.
        END IF
        atot = a_fb + a_side
        wfb = a_fb/atot
        IF (( do_side .AND. do_fb )) THEN
          do_both = .true.
        END IF
      ELSE
        point_source = .false.
        is_circle = .false.
        IF (( temp4 .LE. 0 .OR. temp3 .LE. 0 )) THEN
          IF (( temp4 .LE. 0 )) THEN
            rs = temp3
          ELSE
            rs = temp4
          END IF
          rs = temp3
          rs2 = rs*rs
          delxs = rs
          delys = rs
          is_circle = .true.
        ELSE
          delxs = temp3
          delys = temp4
          rs2 = 1.1*(delxs*delxs+delys*delys)
        END IF
      END IF
      WRITE(6,4900)IQIN
4900  FORMAT(/' Electric charge of the source:',T60,I12)
      IF (( point_source )) THEN
        WRITE(6,4910)d0,temp2,wfb,1-wfb
4910    FORMAT(' Point source off axis (source 16 implementation)'/ ' Di
     *stance of source from centre of chamber: ',T60,f10.4,/ ' Angle toz
     *-axis (degrees): ',T60,f10.4,/, ' Estimated probability to strike 
     *front/back face: ',T60,f12.6,/ ' Estimated probability to strikesi
     *de face: ',T60,f12.6)
      ELSE
        IF (( is_circle )) THEN
          WRITE(6,4920)d0,temp2,rs
4920      FORMAT(' Disk irradiating the chamber (source 16 implementatio
     *n)'/ ' Distance of source centre to chamber centre: ',T60,f10.4,/'
     * Angle to z-axis (degrees): ',T60,f10.4,/, ' Radius of the source:
     * ',T60,f10.4)
        ELSE
          WRITE(6,4930)d0,temp2,delxs,delys
4930      FORMAT(' Rectangle irradiating the chamber (source 16 implemen
     *tation)'/ ' Distance of source centre to chamber centre: ',T60,f10
     *.4,/ ' Angle to z-axis (degrees): ',T60,f10.4,/, ' Rectangle half-
     *sizes: ',T60,2f10.4)
        END IF
      END IF
      return
      entry src16_oto(iout)
      ainflu = NCASET/d02
      return
      entry src16_describe(iout)
      IF (( point_source )) THEN
        write(iout,'(t20,a)') 'POINT SOURCE OFF AXIS (source 16)'
      ELSE
        IF (( is_circle )) THEN
          write(iout,'(t20,a)') 'Radiating circle off axis (source 16)'
          write(iout,'(t20,a,f10.4)') 'Source radius: ',rs
        ELSE
          write(iout,'(t20,a)') 'Radiating rectangle off axis (source 16
     *)'
          write(iout,'(t20,a,2f10.4)') 'Source half-sizes: ',delxs,delys
        END IF
      END IF
      write(iout,'(t20,a,f10.4)') 'Distance between source and chamber c
     *entres: ',d0
      write(iout,'(t20,a,f10.4,a)') 'Angle to z-axis (degrees): ',theta*
     *180/pi,' degrees'
      return
      entry src16_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
      count = count + 1
      IF (( .NOT.point_source )) THEN
4941    CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          xo = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          xo = delxs*(2*xo-1)
          IF((rng_seed .GT. 128))call ranmar_get
          yo = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          yo = delys*(2*yo-1)
          IF((( xo*xo + yo*yo .LT. rs2 )))GO TO4942
        GO TO 4941
4942    CONTINUE
        zo = yo*sint - d0*cost
        yo = d0*sint + yo*cost
        yo = sqrt(yo*yo+xo*xo)
        do_fb = .false.
        do_side = .false.
        do_both = .false.
        a_side = 0
        a_fb = 0
        IF (( abs(yo) .GT. R )) THEN
          u = R/yo
          do_side = .true.
          IF (( u .LT. 0.1 )) THEN
            u2 = u*u
            aux = 1 - u2/2 - u2*u2/8
            a_side = 4*dz*R*yo*(aux-pi*u/2+u2+u2*u2/6)
          ELSE
            aux = sqrt(1-u*u)
            a_side = 4*dz*R*yo*(aux-u*atan(aux/u))
          END IF
          dr = R*aux
        END IF
        IF (( abs(zo) .GT. dz )) THEN
          a_fb = pi*R2*(abs(zo)-dz)
          do_fb = .true.
        END IF
        atot = a_fb + a_side
        IF (( do_side .AND. do_fb )) THEN
          wfb = a_fb/atot
          do_both = .true.
        END IF
      END IF
      IF (( do_both )) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        eta = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( eta .LT. wfb )) THEN
          do_fb = .true.
          do_side = .false.
        ELSE
          do_fb = .false.
          do_side = .true.
        END IF
      END IF
      IF (( do_fb )) THEN
4951    CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          xin = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          xin = R*(2*xin-1)
          IF((rng_seed .GT. 128))call ranmar_get
          yin = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          yin = R*(2*yin-1)
          rad2 = xin*xin + yin*yin
          IF(((rad2 .LE. R2 )))GO TO4952
        GO TO 4951
4952    CONTINUE
        DO 4961 ix=1,nr
          IF((rad2 .LE. CYRAD2(ix)))GO TO4962
4961    CONTINUE
4962    CONTINUE
        IF (( zo .LT. -dz )) THEN
          zin = -dz
          iz = 1
        ELSE
          zin = dz
          iz = nz
        END IF
      ELSE
        IF((rng_seed .GT. 128))call ranmar_get
        zin = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        zin = dz*(2*zin-1)
4971    CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          xin = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          eta = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          xin = dr*(2*xin-1)
          yin = sqrt(R2 - xin*xin)
          IF((( eta .LT. (yo-R2/yin)/(yo-R) )))GO TO4972
        GO TO 4971
4972    CONTINUE
        ix = nr
        zz = zin + zc
        DO 4981 iz=1,nz
          IF((zz .GE. zplane(iz) .AND. zz .LT. zplane(iz+1)))GO TO4982
4981    CONTINUE
4982    CONTINUE
      END IF
      uin = xin
      vin = yin - yo
      win = zin - zo
      dist2 = uin*uin + vin*vin + win*win
      dist = sqrt(dist2)
      uin = uin/dist
      vin = vin/dist
      win = win/dist
      weight = atot/dist2/dist
      sumw = sumw + weight
      sumw2 = sumw2 + weight*weight
      irin = 1 + (ix-1)*nz + iz
      zin = zin + zc
      return
      end
#define HAVE_LOAD_DSO
#ifndef HAVE_LOAD_DSO
      subroutine init_beamsource(i_parallel,n_parallel,i_log,conf_name,
     *hen_house,egs_home,the_beam_code, the_pegs_file,the_input_file)
      integer*4 i_parallel,n_parallel
      character*(*) conf_name
      character*(*) hen_house,egs_home,the_beam_code,the_pegs_file,the_i
     *nput_file
      write(6,*) 'You need a working C compiler to use source 23!'
      call exit(1)
      end
      subroutine sample_beamsource(ein,xin,yin,zin,uin,vin,win,weight,iq
     *in,latchi, nhstry,iphatin)
      return
      end
      subroutine finish_beamsource
      return
      end
#endif
      SUBROUTINE ENSRC
      implicit none
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      INTEGER NUM_EITYPE, NUM_KIEN, NUM_SPFIL, NUM_SPIOUSP
      COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE
      integer*4 ICHPIN,ILPIN,IOUT,IPAGE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET,TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
     *, IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP( 2001),IVAL,DATCOUNT
      real*8 TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
      integer*4 IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP,IVAL,DATCOUN
     *T
      integer*8 NCASE,NCASEO,NCASET
      COMMON/SCORE/ SCFLU(1000, 501,4,3,2), SCFLU2(1000, 501,4,3,2), SCE
     *AVE( 501,4,3,2), SCEAVE2( 501,4,3,2), SCEAVE_COV( 501,4,3,2),SCSTP
     *,SCSTP2,PIISTP, SCELEP( 501,4,2), SCELEP2( 501,4,2), SCELEP_COV( 5
     *01,4,2), SCFLEP(1000, 501,4,2), SCFLEP2(1000, 501,4,2), SCTFLU( 50
     *1,4,3,2), SCTFLU2( 501,4,3,2), SCTLEP( 501,4,2), SCTLEP2( 501,4,2)
     *, SCSTP_LAST,SCFLU_LAST(1000, 501,4,3,2), SCFLEP_LAST(1000, 501,4,
     *2), SCTFLU_LAST( 501,4,3,2), SCTLEP_LAST( 501,4,2), IHSTRY,SCFLU_T
     *MP(1000, 501,4,3,2), SCEAVE_TMP( 501,4,3,2), SCSTP_TMP,SCELEP_TMP(
     * 501,4,2), SCFLEP_TMP(1000, 501,4,2), SCTFLU_TMP( 501,4,3,2), SCTL
     *EP_TMP( 501,4,2), BINTOP(1000),SLOTE,ECUTMX,PCUTMX,EBINW(1000,3),
     *VOLUME(500,4),MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      REAL*8 SCFLU,SCFLU2,SCEAVE,SCEAVE2,SCEAVE_COV,SCSTP,SCSTP2, SCELEP
     *,SCELEP2,SCELEP_COV,SCFLEP,SCFLEP2,SCTFLU,SCTFLU2,SCTLEP, SCTLEP2,
     *PIISTP
      integer*8 SCSTP_LAST,SCFLU_LAST,SCFLEP_LAST,SCTFLU_LAST,SCTLEP_LAS
     *T,IHSTRY
      real*8 SCFLU_TMP,SCEAVE_TMP,SCSTP_TMP,SCELEP_TMP,SCFLEP_TMP, SCTFL
     *U_TMP,SCTLEP_TMP,BINTOP,SLOTE, ECUTMX,PCUTMX,EBINW,VOLUME
      integer*4 MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      COMMON/SPECTR/ CDFINV(1000,2),ENSRCD(0:500),SRCPDF(500),SRCCDF(500
     *), NENSRC
      real*8 CDFINV,ENSRCD,SRCPDF,SRCCDF
      integer*4 NENSRC
      COMMON/USERVR/ CEXPTR,GWAIT(150),DUMU,NP_INC(150),MAFORC,IFORCE,NF
     *MIN,NFMAX,NFTIME, ISOURC,IFPB,IQINC,MONOEN,IRODUM,IRNDUM,MEDDUM,ID
     *UM,MEDTMP, PATHL,DELTAP,GWTOLD,EPSLON,ARG
      real*8 CEXPTR,GWAIT,DUMU,PATHL,DELTAP,GWTOLD,EPSLON,ARG
      integer*4 NP_INC,MAFORC,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQIN
     *C, MONOEN,IRODUM,IRNDUM,MEDDUM,IDUM,MEDTMP
      COMMON/USERRR/
     *              CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,
     *                            EKETST,ELKETS,ZL,RL,CDIST,IGEOM,IRANGE
     *,MINZ,MAXZ,MINR,MAXR,IREJCT
      real*8 CRANGE,ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,EKETST,ELKETS
     *,ZL,RL,CDIST
      integer*4 MINZ,MAXZ,MINR,MAXR
      integer*4 IREJCT,IRANGE,IGEOM
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(4,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBEAM
     *,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DI
     *STZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PRO
     *BSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,ZS
     *OFST,                                                      SVTMP1,
     *SVTMP2,SVTMP3,SVTMP4,
     *       RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                     XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,WEI
     *GHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      integer*4  srcbin_at(500), mode
      real*8   srcpdf_at(500), enmin,enmax,sume1,sume, Ek_max,Emono
      logical is_mono
      character*256 filnam,spec_title
      integer*4 lnblnk1
      save enmin,enmax, srcbin_at, srcpdf_at,Emono, is_mono,mode,filnam,
     *spec_title
      integer*4 ib
      real*8 enin,alias_sample
      DELIMETER='SOURCE INPUTS'
      IF ((ENFLAG.EQ.1)) THEN
        MONOEN = 2
        RETURN
      END IF
      WRITE(6,4990)
4990  FORMAT(' *** INPUT CARD TC1 ***')
      IVAL = IVAL +1
      NUM_EITYPE = IVAL
      VALUES_SOUGHT(IVAL)='INCIDENT ENERGY'
      TYPE(IVAL)=3
      NVALUE(IVAL)=1
      ALLOWED_INPUTS(IVAL,0)='MONOENERGETIC'
      ALLOWED_INPUTS(IVAL,1)='SPECTRUM'
      NMIN = NUM_EITYPE
      NMAX = NUM_EITYPE
      CALL GET_INPUT
      MONOEN=VALUE(NUM_EITYPE,1)
      IF ((MONOEN .EQ. 0)) THEN
        WRITE(6,5000)
5000    FORMAT(' MONOENERGETIC BEAM:')
        IVAL = IVAL +1
        NUM_KIEN = IVAL
        VALUES_SOUGHT(IVAL)='INCIDENT KINETIC ENERGY(MEV)'
        TYPE(IVAL)=1
        NVALUE(IVAL)=1
        VALUE_MIN(IVAL)=0.001
        VALUE_MAX(IVAL)=200000
        DEFAULT(IVAL)=1.25
        NMIN = NUM_KIEN
        NMAX = NUM_KIEN
        CALL GET_INPUT
        EIN=VALUE(NUM_KIEN,1)
        WRITE(6,5010)EIN
5010    FORMAT(/' KINETIC ENERGY OF THE INCIDENT BEAM: ',T60,F10.4)
        is_mono = .true.
        Emono = EIN
      ELSE
        WRITE(6,5020)
5020    FORMAT(' ENERGY SPECTRUM:')
        is_mono = .false.
        IVAL = IVAL +1
        NUM_SPFIL = IVAL
        VALUES_SOUGHT(IVAL)='SPEC FILENAME'
        TYPE(IVAL)=2
        NMIN = NUM_SPFIL
        NMAX = NUM_SPFIL
        CALL GET_INPUT
        READ (CHAR_VALUE(NUM_SPFIL,1),FMT='(A)') filnam
        WRITE(6,5030)filnam
5030    FORMAT(/'   READ INPUT ENERGY SPECTRUM FROM: ',A)
        call replace_env(filnam)
        OPEN(9,file=filnam,STATUS='OLD')
        READ(9,'(A)') spec_title
        READ(9,*) nensrc,ensrcd(0),mode
        enmin = ensrcd(0)
        IF ((NENSRC .GT. 500)) THEN
          WRITE(6,5040)NENSRC,500
5040      FORMAT(//' ********** Asked for too many energy bins******'/ '
     * NENSRC =',I4, ' reduced to max allowed =',I4/1x,30('*')//)
          NENSRC = 500
        END IF
        READ(9,*)(ENSRCD(IB),SRCPDF(IB),IB=1,NENSRC)
        CLOSE(UNIT=9)
        WRITE(6,5050)NENSRC
5050    FORMAT('    HAVE READ',I5,' INPUT ENERGY BINS FROM FILE')
        IF ((MODE.EQ.0)) THEN
          WRITE(6,5060)
5060      FORMAT('      Counts/bin assumed')
        ELSE IF((MODE .EQ. 1)) THEN
          WRITE(6,5070)
5070      FORMAT('      Counts/MeV assumed')
          DO 5081 IB=1,NENSRC
            SRCPDF(IB) = SRCPDF(IB)*(ENSRCD(IB)-ENSRCD(IB-1))
5081      CONTINUE
5082      CONTINUE
        ELSE
          WRITE(6,5090)MODE
5090      FORMAT(///'*****MODE not 0 or 1 in spectrum file? **' /80('*')
     *//)
        END IF
        EIN=ENSRCD(NENSRC)
        WRITE(6,5100)ENMIN,EIN
5100    FORMAT('    ENERGY RANGES FROM',F10.3,' MeV TO',F12.3,' MeV')
        enmax = ein
        IVAL = IVAL +1
        NUM_SPIOUSP = IVAL
        VALUES_SOUGHT(IVAL)='SPEC IOUTSP'
        TYPE(IVAL)=3
        DEFAULT(IVAL)=0
        ALLOWED_INPUTS(IVAL,0)='NONE'
        ALLOWED_INPUTS(IVAL,1)='INCLUDE'
        NMIN = NUM_SPIOUSP
        NMAX = NUM_SPIOUSP
        CALL GET_INPUT
        IOUTSP=VALUE(NUM_SPIOUSP,1)
      END IF
      WRITE(6,5110)
5110  FORMAT(' ')
      RETURN
      ENTRY ENSRC1
      IF((is_mono))return
      IF (( enmin .GE. ensrcd(1) )) THEN
        write(6,*) ' Bad spectrum: minimum energy is > top of first bin!
     * '
        stop
      END IF
      call prepare_alias_sampling(nensrc,srcpdf,srcpdf_at,srcbin_at)
      RETURN
      ENTRY ENSRCO
      IF (( is_mono )) THEN
        write(iout,'(18x,a,f9.3,a)') 'Mono-energy: ',Emono,' MeV'
        return
      END IF
      IF ((enflag .EQ. 1)) THEN
        return
      END IF
      WRITE(IOUT,105) FILNAM(:lnblnk1(FILNAM)),SPEC_TITLE(:lnblnk1(SPEC_
     *TITLE))
105   FORMAT(18x,' Spectrum file and title:'/18x,A/18x,A)
      sume1 = 0
      sume = 0
      DO 5121 ib=1,nensrc
        sume = sume + srcpdf(ib)
        sume1 = sume1 + srcpdf(ib)*(ensrcd(ib)+ensrcd(ib-1))/2
5121  CONTINUE
5122  CONTINUE
      WRITE(IOUT,'(20x,a,f10.4)') ' Average spectrum energy is ',sume1/s
     *ume
      IF ((IOUTSP.EQ.1)) THEN
        IF ((MODE.EQ.0)) THEN
          WRITE(IOUT,'(20x,'' Counts/bin assumed'')')
        ELSE
          WRITE(IOUT,'(20x,'' Counts/MeV assumed'')')
        END IF
        WRITE(IOUT,110)NENSRC,enmin
        DO 5131 IB=1,NENSRC
          WRITE(IOUT,120)IB,ensrcd(ib),srcpdf(ib),srcpdf_at(ib),srcbin_a
     *    t(ib)
5131    CONTINUE
5132    CONTINUE
      END IF
      RETURN
      ENTRY ENSRCH(ENIN)
      IF (( is_mono )) THEN
        enin = Emono
        return
      END IF
      enin = alias_sample(nensrc,ensrcd,srcpdf_at,srcbin_at)
      RETURN
      ENTRY ENSRC_EMAX(Ek_max)
      IF (( is_mono )) THEN
        Ek_max = Emono
      ELSE
        Ek_max = ensrcd(nensrc)
      END IF
      return
100   FORMAT(' ',I1)
102   FORMAT(' ',G14.7)
110   FORMAT(' ',T20,'Energy dist''n, # of incident energy bins:',T60,I3
     */ T20,' Lower energy of first bin:',T60,F7.3,' (MeV)'/ ' ',T20,'bi
     *n    kinetic energy     probability  at prob   at bin')
120   FORMAT(' ',T20,I3,T28,F7.3,T45,1PE10.3,T60,0PF7.4,T70,i4)
      END
      SUBROUTINE GEOMRZ
      implicit none
      COMMON/GEOM/ZPLANE( 501),RCYL(0:4), CYRAD2(4),NTRACK( 2001),NZ,NR,
     *NREG,NPLANE
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NTRACK,NZ,NR,NREG,NPLANE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET,TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
     *, IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP( 2001),IVAL,DATCOUNT
      real*8 TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN
      integer*4 IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP,IVAL,DATCOUN
     *T
      integer*8 NCASE,NCASEO,NCASET
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/SCORE/ SCFLU(1000, 501,4,3,2), SCFLU2(1000, 501,4,3,2), SCE
     *AVE( 501,4,3,2), SCEAVE2( 501,4,3,2), SCEAVE_COV( 501,4,3,2),SCSTP
     *,SCSTP2,PIISTP, SCELEP( 501,4,2), SCELEP2( 501,4,2), SCELEP_COV( 5
     *01,4,2), SCFLEP(1000, 501,4,2), SCFLEP2(1000, 501,4,2), SCTFLU( 50
     *1,4,3,2), SCTFLU2( 501,4,3,2), SCTLEP( 501,4,2), SCTLEP2( 501,4,2)
     *, SCSTP_LAST,SCFLU_LAST(1000, 501,4,3,2), SCFLEP_LAST(1000, 501,4,
     *2), SCTFLU_LAST( 501,4,3,2), SCTLEP_LAST( 501,4,2), IHSTRY,SCFLU_T
     *MP(1000, 501,4,3,2), SCEAVE_TMP( 501,4,3,2), SCSTP_TMP,SCELEP_TMP(
     * 501,4,2), SCFLEP_TMP(1000, 501,4,2), SCTFLU_TMP( 501,4,3,2), SCTL
     *EP_TMP( 501,4,2), BINTOP(1000),SLOTE,ECUTMX,PCUTMX,EBINW(1000,3),
     *VOLUME(500,4),MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
      REAL*8 SCFLU,SCFLU2,SCEAVE,SCEAVE2,SCEAVE_COV,SCSTP,SCSTP2, SCELEP
     *,SCELEP2,SCELEP_COV,SCFLEP,SCFLEP2,SCTFLU,SCTFLU2,SCTLEP, SCTLEP2,
     *PIISTP
      integer*8 SCSTP_LAST,SCFLU_LAST,SCFLEP_LAST,SCTFLU_LAST,SCTLEP_LAS
     *T,IHSTRY
      real*8 SCFLU_TMP,SCEAVE_TMP,SCSTP_TMP,SCELEP_TMP,SCFLEP_TMP, SCTFL
     *U_TMP,SCTLEP_TMP,BINTOP,SLOTE, ECUTMX,PCUTMX,EBINW,VOLUME
      integer*4 MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(4,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBEAM
     *,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DI
     *STZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PRO
     *BSD,PROBBK,                                  AFACE,ASIDE,ZCOFST,ZS
     *OFST,                                                      SVTMP1,
     *SVTMP2,SVTMP3,SVTMP4,
     *       RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                     XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,WEI
     *GHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/USERVR/ CEXPTR,GWAIT(150),DUMU,NP_INC(150),MAFORC,IFORCE,NF
     *MIN,NFMAX,NFTIME, ISOURC,IFPB,IQINC,MONOEN,IRODUM,IRNDUM,MEDDUM,ID
     *UM,MEDTMP, PATHL,DELTAP,GWTOLD,EPSLON,ARG
      real*8 CEXPTR,GWAIT,DUMU,PATHL,DELTAP,GWTOLD,EPSLON,ARG
      integer*4 NP_INC,MAFORC,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQIN
     *C, MONOEN,IRODUM,IRNDUM,MEDDUM,IDUM,MEDTMP
      COMMON/USERRR/
     *              CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,
     *                            EKETST,ELKETS,ZL,RL,CDIST,IGEOM,IRANGE
     *,MINZ,MAXZ,MINR,MAXR,IREJCT
      real*8 CRANGE,ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,EKETST,ELKETS
     *,ZL,RL,CDIST
      integer*4 MINZ,MAXZ,MINR,MAXR
      integer*4 IREJCT,IRANGE,IGEOM
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      integer*4 MEDNUM, NREGLO, NREGHI
      integer*4 NZHI, NZLO, NRHI, NRLO
      integer*4 ITERSE,NSLAB(100), DESCRIBE
      real*8 DELTAZ(100),RHORI
      integer*4 NUM_ITERSE, NUM_FTFACE, NUM_NSLAB, NUM_DELTAZ, NUM_ZPLAN
     *ES, NUM_RCYL
      integer*4 NUM_MEDIA, NUM_RHOR, NUM_DESCRIB, NUM_MEDNUM, NUM_NREGLO
     *, NUM_NREGHI, NUM_NPLANLO, NUM_NPLANHI, NUM_NRADLO, NUM_NRADHI
      integer*4 ERR
      integer*4 IOUT
      integer*4 lnblnk1
      integer*4 I,J,K,PLN,COUNT
      integer*4 IX, IZ, REGNUM, SLENGHT
      real*8 ADDING
      save describe
      I=0
      ERR=15
      ERROR_FLAG=0
      DELIMETER = 'GEOMETRICAL INPUTS'
      NUM_ITERSE = IVAL
      VALUES_SOUGHT(IVAL)='METHOD OF INPUT'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='GROUPS'
      ALLOWED_INPUTS(IVAL,1)='INDIVIDUAL'
      NMIN = IVAL
      NMAX = IVAL
      CALL GET_INPUT
      ITERSE=VALUE(IVAL,1)
      IVAL = IVAL + 1
      NUM_FTFACE = IVAL
      VALUES_SOUGHT(IVAL)='Z OF FRONT FACE'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=-999999
      VALUE_MAX(IVAL)=999999
      DEFAULT(IVAL)=0.0
      NMIN = IVAL
      NMAX = IVAL
      CALL GET_INPUT
      ZPLANE(1)=VALUE(IVAL,1)
      IF ((ITERSE.EQ.0)) THEN
        IVAL = IVAL + 1
        NUM_NSLAB = IVAL
        VALUES_SOUGHT(IVAL)='NSLAB'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=0
        VALUE_MAX(IVAL)=999999
        DEFAULT(IVAL)=1
        NMIN = IVAL
        NMAX = IVAL
        CALL GET_INPUT
        IVAL = IVAL + 1
        NUM_DELTAZ = IVAL
        VALUES_SOUGHT(IVAL)='SLAB THICKNESS'
        TYPE(IVAL)=1
        VALUE_MIN(IVAL)=0
        VALUE_MAX(IVAL)=999999
        DEFAULT(IVAL)=1.0
        NMIN = IVAL
        NMAX = IVAL
        CALL GET_INPUT
        DO 5141 K=1,NVALUE(NUM_NSLAB)
          NSLAB(K)=VALUE(NUM_NSLAB,K)
5141    CONTINUE
5142    CONTINUE
        DO 5151 K=1,NVALUE(NUM_DELTAZ)
          DELTAZ(K)=VALUE(NUM_DELTAZ,K)
5151    CONTINUE
5152    CONTINUE
        COUNT=1
        DO 5161 PLN=1,NVALUE(NUM_NSLAB)
          IF ((PLN.EQ.1)) THEN
            ADDING=0
          ELSE
            ADDING=ADDING+DELTAZ(PLN-1)*NSLAB(PLN-1)
          END IF
          DO 5171 K=1,NSLAB(PLN)
            COUNT=COUNT+1
            ZPLANE(COUNT)=ZPLANE(1)+ADDING+DELTAZ(PLN)*K
5171      CONTINUE
5172      CONTINUE
5161    CONTINUE
5162    CONTINUE
        NZ=COUNT-1
        IF (( NZ-1 .GT. 500)) THEN
          WRITE(6,5180)NZ-1, 500
5180      FORMAT(///' Number of depth regions,',I3,' is greater than $MA
     *XZREG=',I3/ '  You must change the definition of $MAXZREG in the u
     *ser code'/ '      and recompile'///)
          STOP
        END IF
      END IF
      IF ((ITERSE.EQ.1)) THEN
        IVAL = IVAL + 1
        NUM_ZPLANES = IVAL
        VALUES_SOUGHT(IVAL)='DEPTH BOUNDARIES'
        TYPE(IVAL)=1
        VALUE_MIN(IVAL)=-999999
        VALUE_MAX(IVAL)=999999
        DEFAULT(IVAL)=1.0
        NMIN = IVAL
        NMAX = IVAL
        CALL GET_INPUT
        NZ=NVALUE(IVAL)
        IF (( NZ-1 .GT. 500)) THEN
          WRITE(6,5190)NZ-1, 500
5190      FORMAT(///' Number of depth regions,',I3,' is greater than $MA
     *XZREG=',I3/ '  You must change the definition of $MAXZREG in the u
     *ser code'/ '      and recompile'///)
          STOP
        END IF
      END IF
      IVAL = IVAL + 1
      NUM_RCYL = IVAL
      VALUES_SOUGHT(IVAL)='RADII'
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=0.0000001
      VALUE_MAX(IVAL)=999999.9
      DEFAULT(IVAL)=1000.0
      NMIN = NUM_RCYL
      NMAX = NUM_RCYL
      CALL GET_INPUT
      NR=NVALUE(NUM_RCYL)
      IF (( NR .GT. 4 )) THEN
        WRITE(6,5200)NR, 4
5200    FORMAT(///' Number of radial regions,',I3,' is greater than $MAX
     *RADII',I3,/ '  You must change the definition of $MAXRADII in theu
     *ser code'/ '      and recompile'///)
        STOP
      END IF
      NREG=NR*NZ+1
      IF (( NREG .GT.  2001 )) THEN
        WRITE(6,5210)NREG,  2001
5210    FORMAT(///' Total number of regions,',I6,' is greater than $MXRE
     *G=',I6,/ '  You must change the definition of $MXREG in the user c
     *ode'/ '      and recompile'///)
        STOP
      END IF
      IVAL = IVAL + 1
      NUM_MEDIA = IVAL
      VALUES_SOUGHT(IVAL)='MEDIA'
      TYPE(IVAL)=2
      NMIN = IVAL
      NMAX = IVAL
      CALL GET_INPUT
      NMED=NVALUE(IVAL)
      IVAL = IVAL + 1
      NUM_DESCRIB = IVAL
      VALUES_SOUGHT(IVAL)='DESCRIPTION BY'
      TYPE(IVAL)=3
      NVALUE(IVAL)=1
      ALLOWED_INPUTS(IVAL,0)='REGIONS'
      ALLOWED_INPUTS(IVAL,1)='PLANES'
      ALLOWED_INPUTS(IVAL,2)='REGIONS + DENSITY'
      ALLOWED_INPUTS(IVAL,3)='PLANES + DENSITY'
      NMIN = NUM_DESCRIB
      NMAX = NUM_DESCRIB
      CALL GET_INPUT
      DESCRIBE=VALUE(NUM_DESCRIB,1)
      IVAL = IVAL + 1
      NUM_MEDNUM = IVAL
      VALUES_SOUGHT(IVAL)='MEDNUM'
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=NMED
      DEFAULT(IVAL)=1
      IF ((DESCRIBE.EQ.2 .OR. DESCRIBE.EQ.3)) THEN
        IVAL = IVAL + 1
        NUM_RHOR = IVAL
        VALUES_SOUGHT(IVAL)='RHOR'
        TYPE(IVAL)=1
        VALUE_MIN(IVAL)=0.0
        VALUE_MAX(IVAL)=999999.0
        DEFAULT(IVAL)=0.0
      END IF
      IF ((DESCRIBE.EQ.0 .OR. DESCRIBE.EQ.2)) THEN
        IVAL = IVAL + 1
        NUM_NREGLO = IVAL
        VALUES_SOUGHT(IVAL)='START REGION'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=0
        VALUE_MAX(IVAL)=NREG
        DEFAULT(IVAL)=1
        IVAL = IVAL + 1
        NUM_NREGHI = IVAL
        VALUES_SOUGHT(IVAL)='STOP REGION'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=0
        VALUE_MAX(IVAL)=NREG
        DEFAULT(IVAL)=1
        NMIN = NUM_ITERSE
        NMAX = NUM_NREGHI
        CALL GET_INPUT
      END IF
      IF ((DESCRIBE.EQ.1 .OR. DESCRIBE.EQ.3)) THEN
        IVAL = IVAL + 1
        NUM_NPLANLO = IVAL
        VALUES_SOUGHT(IVAL)='START ZSLAB'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=1
        VALUE_MAX(IVAL)=NZ
        DEFAULT(IVAL)=1
        IVAL = IVAL + 1
        NUM_NPLANHI = IVAL
        VALUES_SOUGHT(IVAL)='STOP ZSLAB'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=1
        VALUE_MAX(IVAL)=NZ
        DEFAULT(IVAL)=1
        IVAL = IVAL + 1
        NUM_NRADLO = IVAL
        VALUES_SOUGHT(IVAL)='START RING'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=1
        VALUE_MAX(IVAL)=NR
        DEFAULT(IVAL)=1
        IVAL = IVAL + 1
        NUM_NRADHI = IVAL
        VALUES_SOUGHT(IVAL)='STOP RING'
        TYPE(IVAL)=0
        VALUE_MIN(IVAL)=1
        VALUE_MAX(IVAL)=NR
        DEFAULT(IVAL)=1
        NMIN = NUM_ITERSE
        NMAX = NUM_NRADHI
        CALL GET_INPUT
      END IF
      WRITE(6,5220)
5220  FORMAT(' *** INPUT CARD CGM1 ***')
      ITERSE=VALUE(NUM_ITERSE,1)
      WRITE(6,5230)ITERSE
5230  FORMAT(' TERSE(0), RAPID(1) OR DETAILED(2) INPUT:',T60,I12/)
      IF ((ITERSE.EQ.0)) THEN
        WRITE(6,5240)
5240    FORMAT(' *** CARD CGM2A *** (Input groups of slabs) ')
        WRITE(6,5250)NZ
5250    FORMAT(' Number of planar slabs: ',T60,I12)
        NPLANE=NZ+1
        WRITE(6,5260)
5260    FORMAT(' Geometrical Z-plane coordinates:')
        WRITE(6,5270)(ZPLANE(I),I=1,NZ+1)
5270    FORMAT(6F10.4)
        WRITE(6,5280)
5280    FORMAT(' ')
      END IF
      IF ((ITERSE.EQ.1)) THEN
        WRITE(6,5290)
5290    FORMAT(' *** INPUT CARD CGM2B *** (DETAILED INPUT)')
        DO 5301 I=1,NZ
          ZPLANE(I+1)=VALUE(NUM_ZPLANES,I)
5301    CONTINUE
5302    CONTINUE
        WRITE(6,5310)NZ
5310    FORMAT(' NUMBER OF PLANAR SLABS: ',T60,I12)
        NPLANE=NZ+1
        WRITE(6,5320)
5320    FORMAT(' GEOMETRICAL Z-PLANE COORDINATES:')
        WRITE(6,5330)(ZPLANE(I),I=1,NPLANE)
5330    FORMAT(6F10.4)
        WRITE(6,5340)
5340    FORMAT(' ')
      END IF
      WRITE(6,5350)
5350  FORMAT(' *** INPUT CARD CG3 ***')
      WRITE(6,5360)NR
5360  FORMAT(' Number of concentric rings: ', T60, I12)
      RCYL(0)=0.0
      DO 5371 I=1,NR
        RCYL(I)=VALUE(NUM_RCYL,I)
        CYRAD2(I)=VALUE(NUM_RCYL,I)**2
5371  CONTINUE
5372  CONTINUE
      DO 5381 I=1,NR
        WRITE(6,5390)I,RCYL(I)
5390    FORMAT(' Ring radius #',I2,':',T60,F10.4,' cm')
5381  CONTINUE
5382  CONTINUE
      WRITE(6,5400)
5400  FORMAT(/' *** INPUT CARD M1 ***')
      WRITE(6,5410)6, NMED
5410  FORMAT(' Number of media(<=',I3,'):',T60,I12/)
      IF ((NMED .GT. 6 )) THEN
        WRITE(6,5420)
5420    FORMAT(' ************************ERROR************************')
        WRITE(6,5430)
5430    FORMAT(' Number of media exceeds $MXMED - increase value and rec
     *ompile')
        WRITE(6,5440)
5440    FORMAT(' ************************ERROR************************'/
     */)
        WRITE(ERR,'('' Asked for'',I3,'' media and $MXMED is'',I3//)') N
     *  MED, 6
        ERROR_FLAG = 1
      END IF
      WRITE(6,5450)
5450  FORMAT(' *** INPUT CARD M2 ***')
      DO 5461 I=1,NMED
        SLENGHT=lnblnk1(CHAR_VALUE(NUM_MEDIA,I))
        READ (CHAR_VALUE(NUM_MEDIA,I),FMT='(24A1)') (MEDIA(J,I),J=1,SLEN
     *  GHT)
        IF ((SLENGHT.LT.24)) THEN
          DO 5471 J=SLENGHT+1,24
            MEDIA(J,I)=' '
5471      CONTINUE
5472      CONTINUE
        END IF
        WRITE(6,5480)I,(MEDIA(J,I),J=1,24)
5480    FORMAT(' MEDIUM #',I1,':',T55,24A1)
5461  CONTINUE
5462  CONTINUE
      WRITE(6,5490)
5490  FORMAT(/' *** INPUT CARD M3 ***')
      MED(1)=0
      DO 5501 I=2,NREG
        MED(I)=1
5501  CONTINUE
5502  CONTINUE
      WRITE(6,5510)NREG
5510  FORMAT(/' # of geometrical zones = ',T60,I12)
      WRITE (*,*) 'REGION(  1) = MATERIAL( 0) (VACUUM)'
      IF ((DESCRIBE.EQ.0 .OR. DESCRIBE.EQ.2)) THEN
        IF (((NVALUE(NUM_NREGLO).NE.NVALUE(NUM_MEDNUM)).OR. (NVALUE(NUM_
     *  NREGHI).NE.NVALUE(NUM_MEDNUM)))) THEN
          WRITE(ERR,*)'**************ERROR**************'
          WRITE(ERR,*)'MEDNUM HAS      ',NVALUE(NUM_MEDNUM),' VALUES'
          WRITE(ERR,*)'START REGION HAS',NVALUE(NUM_NREGLO),' VALUES'
          WRITE(ERR,*)'STOP REGION HAS ',NVALUE(NUM_NREGHI),' VALUES'
          WRITE(ERR,*)'>>>> THEY MUST ALL HAVE THE SAME NUMBER OF VALUES
     *'
          ERROR_FLAG=1
        END IF
        IF (( DESCRIBE .EQ. 2 )) THEN
          IF (( NVALUE(NUM_RHOR).NE.NVALUE(NUM_MEDNUM))) THEN
            WRITE(ERR,*)'**************ERROR**************'
            WRITE(ERR,*)'MEDNUM HAS      ',NVALUE(NUM_MEDNUM),' VALUES'
            WRITE(ERR,*)'RHOR HAS        ',NVALUE(NUM_RHOR),' VALUES'
            WRITE(ERR,*)'>>>> THEY MUST BOTH HAVE THE SAME NUMBER OF VAL
     *UES'
            ERROR_FLAG=1
          END IF
        END IF
        IF ((VALUE(NUM_MEDNUM,1) .GE. 0)) THEN
          DO 5521 I=1,NVALUE(NUM_MEDNUM)
            RHORI=0.0
            MEDNUM=VALUE(NUM_MEDNUM,I)
            IF((DESCRIBE.EQ.2))RHORI=VALUE(NUM_RHOR,I)
            NREGLO=VALUE(NUM_NREGLO,I)
            NREGHI=VALUE(NUM_NREGHI,I)
            IF ((NREGHI.LE.NREGLO)) THEN
              IF (( NREGLO .GT. 0 .AND. NREGLO .LE.  2001 )) THEN
                MED(NREGLO)=MEDNUM
                IF((RHORI.GT.0.0))RHOR(NREGLO)=RHORI
                IF ((DESCRIBE.EQ.2)) THEN
                  IF ((RHORI.GT.0.0)) THEN
                    WRITE(6,5530)NREGLO,MEDNUM,RHORI
5530                FORMAT(' REGION(',I3,') = MATERIAL(',I2,'), RHOR =',
     *F8.5)
                  ELSE
                    WRITE(6,5540)NREGLO,MEDNUM
5540                FORMAT(' REGION(',I3,') = MATERIAL(',I2,'), RHOR = D
     *EFAULT')
                  END IF
                ELSE
                  WRITE(6,5550)NREGLO,MEDNUM
5550              FORMAT(' REGION(',I3,') = MATERIAL(',I2,')')
                END IF
              END IF
            ELSE
              DO 5561 K=NREGLO,NREGHI
                IF (( K .GT. 0 .AND. K .LE.  2001 )) THEN
                  MED(K)=MEDNUM
                  IF((RHORI.GT.0.0))RHOR(K)=RHORI
                END IF
5561          CONTINUE
5562          CONTINUE
              IF ((DESCRIBE.EQ.2)) THEN
                IF ((RHORI.GT.0.0)) THEN
                  WRITE(6,5570)NREGLO,NREGHI,MEDNUM,RHORI
5570              FORMAT(' REGION(',I3,') TO REGION(',I3,') = MATERIAL('
     *,I2,'), RHOR =',F8.5)
                ELSE
                  WRITE(6,5580)NREGLO,NREGHI,MEDNUM
5580              FORMAT(' REGION(',I3,') TO REGION(',I3,') = MATERIAL('
     *,I2,'), RHOR = DEFAULT')
                END IF
              ELSE
                WRITE(6,5590)NREGLO,NREGHI,MEDNUM
5590            FORMAT(' REGION(',I3,') TO REGION(',I3,') = MATERIAL(',I
     *2,')')
              END IF
            END IF
5521      CONTINUE
5522      CONTINUE
        END IF
      END IF
      IF ((DESCRIBE.EQ.1 .OR. DESCRIBE.EQ.3)) THEN
        IF (((NVALUE(NUM_NPLANLO).NE.NVALUE(NUM_MEDNUM)).OR. (NVALUE(NUM
     *  _NPLANLO).NE.NVALUE(NUM_MEDNUM)).OR. (NVALUE(NUM_NRADLO).NE.NVAL
     *  UE(NUM_MEDNUM)).OR. (NVALUE(NUM_NRADHI).NE.NVALUE(NUM_MEDNUM))))
     *   THEN
          WRITE(ERR,*)'**************ERROR**************'
          WRITE(ERR,*)'MEDNUM has      ',NVALUE(NUM_MEDNUM),' values'
          WRITE(ERR,*)'START PLANE has ',NVALUE(NUM_NPLANLO),' values'
          WRITE(ERR,*)'STOP PLANE has  ',NVALUE(NUM_NPLANHI),' values'
          WRITE(ERR,*)'START RING has  ',NVALUE(NUM_NRADLO),' values'
          WRITE(ERR,*)'STOP RING has   ',NVALUE(NUM_NRADHI),' values'
          WRITE(ERR,*)'>>>> They must all have the same number of values
     *'
          ERROR_FLAG=1
        END IF
        IF ((DESCRIBE.EQ.3 .AND. NVALUE(NUM_RHOR).NE.NVALUE(NUM_MEDNUM))
     *  ) THEN
          WRITE(ERR,*)'**************ERROR**************'
          WRITE(ERR,*)'MEDNUM HAS      ',NVALUE(NUM_MEDNUM),' VALUES'
          WRITE(ERR,*)'RHOR HAS        ',NVALUE(NUM_RHOR),' VALUES'
          WRITE(ERR,*)'>>>> THEY MUST BOTH HAVE THE SAME NUMBER OF VALUE
     *S'
          ERROR_FLAG=1
        END IF
        IF ((VALUE(NUM_MEDNUM,1) .GE. 0)) THEN
          DO 5601 I=1,NVALUE(NUM_MEDNUM)
            RHORI=0.0
            MEDNUM=VALUE(NUM_MEDNUM,I)
            IF((DESCRIBE.EQ.3))RHORI=VALUE(NUM_RHOR,I)
            NZLO=VALUE(NUM_NPLANLO,I)
            NZHI=VALUE(NUM_NPLANHI,I)
            NRLO=VALUE(NUM_NRADLO,I)
            NRHI=VALUE(NUM_NRADHI,I)
            IF ((NZLO.GT.NZHI)) THEN
              NZHI=NZLO
            END IF
            IF ((NRLO.GT.NRHI)) THEN
              NRHI=NRLO
            END IF
            DO 5611 IZ=NZLO,NZHI
              DO 5621 IX=NRLO,NRHI
                REGNUM=IZ+NZ*(IX-1)+1
                IF (( regnum .GT. 0 .AND. regnum .LE.  2001 )) THEN
                  MED(REGNUM)=MEDNUM
                  IF((RHORI.GT.0.0))RHOR(REGNUM)=RHORI
                  IF ((DESCRIBE.EQ.3)) THEN
                    IF ((RHORI.GT.0.0)) THEN
                      WRITE(6,5630)IZ,IX,MEDNUM,RHORI
5630                  FORMAT(' ZPLANE(',I3,'),RADIUS(',I3,') = MATERIAL(
     *',I2,') RHOR =',F8.5)
                    ELSE
                      WRITE(6,5640)IZ,IX,MEDNUM
5640                  FORMAT(' ZPLANE(',I3,'),RADIUS(',I3,') = MATERIAL(
     *',I2,') RHOR = DEFAULT')
                    END IF
                  ELSE
                    WRITE(6,5650)IZ,IX,MEDNUM
5650                FORMAT(' ZPLANE(',I3,'),RADIUS(',I3,') = MATERIAL(',
     *I2,')')
                  END IF
                END IF
5621          CONTINUE
5622          CONTINUE
5611        CONTINUE
5612        CONTINUE
5601      CONTINUE
5602      CONTINUE
        END IF
      END IF
      WRITE(6,5660)
5660  FORMAT(' ')
      RETURN
      ENTRY GEOMRZ_ISUMRY(IOUT)
      IF ((DESCRIBE.EQ.2.OR.DESCRIBE.EQ.3)) THEN
        WRITE(IOUT,100)
        RHORI=0.0
        DO 5671 I=2,NREG
          IF ((RHORI.GT.0.0 .AND. (RHOR(I).NE.RHORI .OR. MED(I).NE.MED(I
     *    -1)))) THEN
            NREGHI=I-1
            WRITE(IOUT,200)NREGLO,NREGHI,MED(NREGLO),RHORI
            RHORI=0.0
          END IF
          IF ((RHOR(I).GT.0.0 .AND. RHOR(I).NE.RHO(MED(I)) .AND. RHORI.E
     *    Q.0.0)) THEN
            NREGLO=I
            RHORI=RHOR(I)
          END IF
          IF ((I.EQ.NREG .AND. RHORI.GT.0.0)) THEN
            NREGHI=I
            WRITE(IOUT,200)NREGLO,NREGHI,MED(NREGLO),RHORI
          END IF
5671    CONTINUE
5672    CONTINUE
      END IF
100   FORMAT(/' ',T25,'NON-DEFAULT DENSITIES'// ' ',T10,'    Region #   
     *   Medium             Rhor  '/ ' ',T10,'from        to #          
     *   (g/cm**3)'/)
200   FORMAT(' ',T10,I3,2I11,F20.5)
      RETURN
      END
      SUBROUTINE GET_INPUT
      IMPLICIT NONE
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      CHARACTER*256 TEXT
      CHARACTER*256 KEEPTEXT
      CHARACTER*256 ORIGTEXT
      CHARACTER*256 TEXTPIECE
      CHARACTER*80 DELIM_START
      CHARACTER*80 DELIM_END
      CHARACTER*64 VNAME
      CHARACTER*64 VNAME1
      integer*4 CURSOR
      integer*4 IINDEX
      integer*4 iVNAME
      integer*4 IVAL
      integer*4 UNITNUM
      integer*4 ERR
      integer*4 I,J,K,CHECK
      integer*4 LINE
      integer*4 INT_VALUE
      integer*4 INT_VALUE_MIN
      integer*4 INT_VALUE_MAX
      logical ALLOWED
      logical START_FOUND
      integer*4 ifound,length,lll,Kconvert
      integer*4 lnblnk1
      logical IDEBUG
      character*1 blank
      integer*4 error_level
      integer*4 the_level
      data blank/' '/
      data error_level/1/
      save error_level
      IDEBUG = .false.
      ERROR_FLAG = 0
      IF ((IDEBUG)) THEN
        WRITE(6,5680)NMIN,NMAX, 100
5680    FORMAT(' Entering get_inputs seeking values', I5,' to', I5, '  w
     *ith a max allowed of',I5)
      END IF
      IF ((NMAX .LT. NMIN .OR. NMAX .GT. 100)) THEN
        WRITE(6,5690)NMAX, NMIN, 100
5690    FORMAT(//' Error entering get_inputs: Asked for values from',I5,
     *' to',I5, '    with a max of',I5//' This implies a bug in the call
     *ing routine'/ ' Fix it up and try again.  Stopping now.')
        STOP
      END IF
      ERR=i_errors
      UNITNUM=i_input
      DELIM_START=':START '//DELIMETER(:lnblnk1(DELIMETER))//':'
      DELIM_END=':STOP '//DELIMETER(:lnblnk1(DELIMETER))//':'
      DO 5701 Kconvert=1,lnblnk1(DELIM_START)
        CURSOR=ICHAR(DELIM_START(Kconvert:Kconvert))
        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
          CURSOR=CURSOR-32
          DELIM_START(Kconvert:Kconvert)=CHAR(CURSOR)
        END IF
5701  CONTINUE
5702  CONTINUE
      DO 5711 Kconvert=1,lnblnk1(DELIM_END)
        CURSOR=ICHAR(DELIM_END(Kconvert:Kconvert))
        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
          CURSOR=CURSOR-32
          DELIM_END(Kconvert:Kconvert)=CHAR(CURSOR)
        END IF
5711  CONTINUE
5712  CONTINUE
      IF ((IDEBUG)) THEN
        WRITE(6,5720)DELIM_START,DELIM_END
5720    FORMAT(' start and stop delimeters are:'/ A/A/)
      END IF
      DO 5731 I=NMIN,NMAX
        REWIND (UNITNUM)
        LINE=0
        CHECK=0
        ERROR_FLAGS(I)=0
        IF ((TYPE(I) .EQ. 0 .OR. TYPE(I) .EQ. 1)) THEN
          VALUE(I,1) = DEFAULT(I)
        END IF
        IF ((TYPE(I) .EQ. 3)) THEN
          VALUE(I,1) = 0
        END IF
        VNAME=VALUES_SOUGHT(I)
        iVNAME=lnblnk1(VNAME)
        IF (( ivname .LT. 1 )) THEN
          IF (( error_level .GT. 0 )) THEN
            write(ERR,*) ' ======================= Warning =============
     *======== '
            write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!
     *         '
            write(ERR,*) ' =============================================
     *======== '
          END IF
          ERROR_FLAG=1
          ERROR_FLAGS(I)=1
          goto 5740
        END IF
        DO 5751 Kconvert=1,lnblnk1(vname)
          CURSOR=ICHAR(vname(Kconvert:Kconvert))
          IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
            CURSOR=CURSOR-32
            vname(Kconvert:Kconvert)=CHAR(CURSOR)
          END IF
5751    CONTINUE
5752    CONTINUE
        iindex = 0
        IF ((DELIMETER .EQ. 'NONE')) THEN
          start_found = .true.
        ELSE
          start_found = .false.
        END IF
5761    IF(iindex.NE.0)GO TO 5762
5770      CONTINUE
          LINE=LINE+1
          IF (( start_found )) THEN
            READ(UNITNUM,END=5780,ERR=5790,FMT='(A256)') TEXT
          ELSE
            READ(UNITNUM,END=5800,ERR=5790,FMT='(A256)') TEXT
          END IF
          length = len(text)
5811      IF(index(text,blank).NE.1)GO TO 5812
            IF (( length .GE. 2 )) THEN
              text=text(2:)
            ELSE
              GO TO5812
            END IF
            length = length - 1
          GO TO 5811
5812      CONTINUE
          ifound = INDEX(text,'#')
          IF (( ifound .GT. 1 )) THEN
            text = text(1:ifound-1)
          ELSE
            IF (( ifound .EQ. 1 )) THEN
              text = blank
            END IF
          END IF
          ifound = INDEX(text,';')
          IF (( ifound .GT. 1 )) THEN
            text = text(1:ifound-1)
          ELSE
            IF (( ifound .EQ. 1 )) THEN
              text = blank
            END IF
          END IF
          length = lnblnk1(TEXT)
          TEXT=TEXT(:length)
          origtext = text(:length)
          DO 5821 Kconvert=1,lnblnk1(text)
            CURSOR=ICHAR(text(Kconvert:Kconvert))
            IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
              CURSOR=CURSOR-32
              text(Kconvert:Kconvert)=CHAR(CURSOR)
            END IF
5821      CONTINUE
5822      CONTINUE
          IF (( .NOT.start_found )) THEN
            IF ((INDEX(TEXT,DELIM_START) .NE. 0 )) THEN
              start_found = .true.
            END IF
            goto 5770
          END IF
          iindex=INDEX(TEXT,VNAME(:iVNAME))
          IF (( DELIMETER.NE.'NONE' )) THEN
            IF ((INDEX(TEXT,DELIM_END).NE.0)) THEN
              IF (( error_level .GT. 0 )) THEN
                WRITE (ERR,*) '***************ERROR***************'
                WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUG
     *          HT(I))), '<<',' NOT FOUND'
                WRITE (ERR,*) 'END OF DELIMETER: ',DELIMETER(:lnblnk1(DE
     *          LIMETER))
              END IF
              ERROR_FLAG=1
              ERROR_FLAGS(I)=1
              GOTO 5740
            END IF
          END IF
        GO TO 5761
5762    CONTINUE
        CHECK=0
        IF (( idebug )) THEN
          write(i_log,*) ' ******* Found: '
          write(i_log,'(a,$)') ' text:     '
          length = lnblnk1(text)
          IF (( length .GT. 0 )) THEN
            DO 5831 lll=1,length
              write(i_log,'(a1,$)') text(lll:lll)
5831        CONTINUE
5832        CONTINUE
            write(i_log,*)
          END IF
          write(i_log,'(a,$)') ' origtext: '
          length = lnblnk1(origtext)
          IF (( length .GT. 0 )) THEN
            DO 5841 lll=1,length
              write(i_log,'(a1,$)') origtext(lll:lll)
5841        CONTINUE
5842        CONTINUE
            write(i_log,*)
          END IF
        END IF
        IINDEX=IINDEX+iVNAME
        TEXT=TEXT(IINDEX:)
        origtext=origtext(iindex:)
        IF (( idebug )) THEN
          write(i_log,*) ' After removing vname: '
          write(i_log,'(a,$)') ' text:     '
          length = lnblnk1(text)
          IF (( length .GT. 0 )) THEN
            DO 5851 lll=1,length
              write(i_log,'(a1,$)') text(lll:lll)
5851        CONTINUE
5852        CONTINUE
            write(i_log,*)
          END IF
          write(i_log,'(a,$)') ' origtext: '
          length = lnblnk1(origtext)
          IF (( length .GT. 0 )) THEN
            DO 5861 lll=1,length
              write(i_log,'(a1,$)') origtext(lll:lll)
5861        CONTINUE
5862        CONTINUE
            write(i_log,*)
          END IF
        END IF
        IINDEX=INDEX(TEXT,'=')
        IF ((IINDEX.NE.0)) THEN
          TEXT=TEXT(IINDEX+1:)
          origtext=origtext(iindex+1:)
        ELSE
          IINDEX=INDEX(TEXT,':')
          IF ((IINDEX.NE.0)) THEN
            TEXT=TEXT(IINDEX+1:)
            origtext=origtext(iindex+1:)
          END IF
        END IF
        IF (( idebug )) THEN
          write(i_log,*) ' After removing leading equals: '
          write(i_log,'(a,$)') ' text:     '
          length = lnblnk1(text)
          IF (( length .GT. 0 )) THEN
            DO 5871 lll=1,length
              write(i_log,'(a1,$)') text(lll:lll)
5871        CONTINUE
5872        CONTINUE
            write(i_log,*)
          END IF
          write(i_log,'(a,$)') ' origtext: '
          length = lnblnk1(origtext)
          IF (( length .GT. 0 )) THEN
            DO 5881 lll=1,length
              write(i_log,'(a1,$)') origtext(lll:lll)
5881        CONTINUE
5882        CONTINUE
            write(i_log,*)
          END IF
        END IF
        IF (( (lnblnk1(TEXT).EQ.0) .OR. (lnblnk1(TEXT).EQ.1) )) THEN
          IF ((vname(:ivname).EQ.'TITLE')) THEN
            READ (UNITNUM,FMT='(A256)') TEXTPIECE
            IF ((lnblnk1(TEXTPIECE).NE.0)) THEN
              TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE))
              length = len(text)
5891          IF(index(text,blank).NE.1)GO TO 5892
                IF (( length .GE. 2 )) THEN
                  text=text(2:)
                ELSE
                  GO TO5892
                END IF
                length = length - 1
              GO TO 5891
5892          CONTINUE
              length = len(origtext)
5901          IF(index(origtext,blank).NE.1)GO TO 5902
                IF (( length .GE. 2 )) THEN
                  origtext=origtext(2:)
                ELSE
                  GO TO5902
                END IF
                length = length - 1
              GO TO 5901
5902          CONTINUE
              GOTO 5910
            END IF
          END IF
          IF (( error_level .GT. 0 )) THEN
            WRITE (ERR,*) '*************ERROR*************'
            WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
            WRITE (ERR,*) 'VALUE NOT THERE!!'
          END IF
          ERROR_FLAG=1
          ERROR_FLAGS(I)=1
          RETURN
        END IF
5910    CONTINUE
        iindex = index(text,'DEFAULT')
        IF (( iindex .NE. 0 )) THEN
          IF (( type(i) .NE. 2 )) THEN
            IF (( type(i) .NE. 3 )) THEN
              VALUE(I,1)=DEFAULT(I)
            ELSE
              VALUE(I,1)=0
            END IF
            goto 5740
          END IF
        END IF
        IF (((TYPE(I) .EQ. 0).OR.(TYPE(I) .EQ. 1))) THEN
          IVAL=1
          IF (( idebug )) THEN
            write(i_log,*) ' *** Reading an integer or a real value! '
          END IF
5921      CONTINUE
            IF (( idebug )) THEN
              write(i_log,*) ' In LOOP, ival = ',ival
            END IF
            IF ((lnblnk1(TEXT).EQ.0)) THEN
              IF (( error_level .GT. 0 )) THEN
                WRITE(ERR,*) '*************ERROR*************'
                WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                WRITE (ERR,*) 'VALUE NOT THERE!!'
              END IF
              ERROR_FLAG=1
              ERROR_FLAGS(I)=1
              RETURN
            END IF
            READ(TEXT,END=5930,ERR=5940,FMT=*) VALUE(I,IVAL)
            IF (( idebug )) THEN
              write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL)
            END IF
            IF (((VALUE(I,IVAL).GT.VALUE_MAX(I)).OR.(VALUE(I,IVAL).LT.VA
     *      LUE_MIN(I)))) THEN
              IF ((TYPE(I).EQ.0)) THEN
                INT_VALUE=DEFAULT(I)
                IF (( error_level .GT. 0 )) THEN
                  WRITE(ERR,*) '************WARNING************'
                  WRITE(ERR,5950) INT_VALUE, VALUES_SOUGHT(I)(:lnblnk1(V
     *            ALUES_SOUGHT(I)))
                END IF
5950            FORMAT ( 'Default= ',I9,' used for: ', A )
                INT_VALUE=VALUE(I,IVAL)
                INT_VALUE_MIN=VALUE_MIN(I)
                INT_VALUE_MAX=VALUE_MAX(I)
                IF (( error_level .GT. 0 )) THEN
                  WRITE(ERR,5960) VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGH
     *            T(I))), INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX
                END IF
5960            FORMAT (A,'=', I9,' should be between ', I9,' and ', I9)
              END IF
              IF ((TYPE(I).EQ.1)) THEN
                IF (( error_level .GT. 0 )) THEN
                  WRITE(ERR,*) '************WARNING************'
                  WRITE(ERR,5970) DEFAULT(I), VALUES_SOUGHT(I)(:lnblnk1(
     *            VALUES_SOUGHT(I)))
5970              FORMAT ( 'Default= ',F12.6,' used for: ', A )
                  WRITE(ERR,5980) VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGH
     *            T(I))), VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I)
5980              FORMAT (A,'=', F12.6,' should be between ', G14.6,' an
     *d ', G14.6)
                END IF
              END IF
              VALUE(I,IVAL)=DEFAULT(I)
            END IF
            IF((IVAL .EQ. NVALUE(I)))GO TO5922
            IF (((INDEX(TEXT,',').NE.0).OR.(lnblnk1(TEXT).EQ.0))) THEN
              IF (( idebug )) THEN
                write(i_log,*) ' A comma or a blank text found -> '
                write(i_log,*) ' searching for further input'
              END IF
              TEXT=TEXT(INDEX(TEXT,',')+1:)
5991          IF(lnblnk1(TEXT).NE.0)GO TO 5992
                IF (( idebug )) THEN
                  write(i_log,*) ' Empty text -> reading next line! '
                END IF
                LINE=LINE+1
                READ (UNITNUM,END=5930,ERR=5940,FMT='(A256)') TEXT
                length = len(text)
6001            IF(index(text,blank).NE.1)GO TO 6002
                  IF (( length .GE. 2 )) THEN
                    text=text(2:)
                  ELSE
                    GO TO6002
                  END IF
                  length = length - 1
                GO TO 6001
6002            CONTINUE
                ifound = INDEX(text,'#')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                ifound = INDEX(text,';')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                length = lnblnk1(TEXT)
                TEXT=TEXT(:length)
                origtext = text(:length)
                DO 6011 Kconvert=1,lnblnk1(text)
                  CURSOR=ICHAR(text(Kconvert:Kconvert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                    CURSOR=CURSOR-32
                    text(Kconvert:Kconvert)=CHAR(CURSOR)
                  END IF
6011            CONTINUE
6012            CONTINUE
                DO 6021 K=1,NMAX
                  vname1 = VALUES_SOUGHT(K)
                  length = lnblnk1(vname1)
                  IF (( length .GT. 0 )) THEN
                    length = len(vname1)
6031                IF(index(vname1,blank).NE.1)GO TO 6032
                      IF (( length .GE. 2 )) THEN
                        vname1=vname1(2:)
                      ELSE
                        GO TO6032
                      END IF
                      length = length - 1
                    GO TO 6031
6032                CONTINUE
                    DO 6041 Kconvert=1,lnblnk1(vname1)
                      CURSOR=ICHAR(vname1(Kconvert:Kconvert))
                      IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                        CURSOR=CURSOR-32
                        vname1(Kconvert:Kconvert)=CHAR(CURSOR)
                      END IF
6041                CONTINUE
6042                CONTINUE
                    IF ((INDEX(TEXT,vname1(:length)).NE.0)) THEN
                      IF (( error_level .GT. 0 )) THEN
                        WRITE(ERR,*) '************ERROR************'
                        WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                        WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)), '<--C
     *OMMA INDICATES ANOTHER INPUT'
                        WRITE(ERR,*) 'SEARCHED NEXT LINE: ', TEXT(:lnbln
     *                  k1(TEXT))
                        WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED'
                      END IF
                      ERROR_FLAG=1
                      ERROR_FLAGS(I)=1
                    END IF
                  END IF
6021            CONTINUE
6022            CONTINUE
                IF (( idebug )) THEN
                  write(i_log,*) ' Next line: '
                  write(i_log,'(a,$)') ' text:     '
                  length = lnblnk1(text)
                  IF (( length .GT. 0 )) THEN
                    DO 6051 lll=1,length
                      write(i_log,'(a1,$)') text(lll:lll)
6051                CONTINUE
6052                CONTINUE
                    write(i_log,*)
                  END IF
                  write(i_log,'(a,$)') ' origtext: '
                  length = lnblnk1(origtext)
                  IF (( length .GT. 0 )) THEN
                    DO 6061 lll=1,length
                      write(i_log,'(a1,$)') origtext(lll:lll)
6061                CONTINUE
6062                CONTINUE
                    write(i_log,*)
                  END IF
                END IF
              GO TO 5991
5992          CONTINUE
            ELSE
              GO TO5922
            END IF
            IVAL=IVAL+1
          GO TO 5921
5922      CONTINUE
          IF (((NVALUE(I).NE.0).AND.(NVALUE(I).NE.IVAL))) THEN
            IF (( error_level .GT. 0 )) THEN
              WRITE (ERR,*) '**************ERROR**************'
              WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I)
              WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)'
              WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED'
            END IF
            ERROR_FLAG=1
            ERROR_FLAGS(I)=1
          ELSE
            NVALUE(I)=IVAL
          END IF
5930      CONTINUE
        END IF
        IF (((TYPE(I) .EQ. 2) .OR. (TYPE(I) .EQ. 3))) THEN
          IVAL=1
          IF (( idebug )) THEN
            write(i_log,*) ' Trying to read a string! '
          END IF
6071      CONTINUE
            IF (( idebug )) THEN
              write(i_log,*) ' In LOOP, ival = ',ival
            END IF
            IF ((lnblnk1(TEXT).EQ.0)) THEN
              IF (( error_level .GT. 0 )) THEN
                WRITE(ERR,*) '*************ERROR*************'
                WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                WRITE (ERR,*) 'VALUE NOT THERE!!'
              END IF
              ERROR_FLAG=1
              ERROR_FLAGS(I)=1
              RETURN
            END IF
            IF ((vname(:ivname).EQ.'TITLE')) THEN
              TEXTPIECE=origtext
              GOTO 6080
            END IF
            iindex = INDEX(origtext,',')
            IF (( iindex .NE. 0 )) THEN
              TEXTPIECE=origtext(:iindex-1)
            ELSE
              TEXTPIECE=origtext
            END IF
6080        CONTINUE
            READ(TEXTPIECE,ERR=6090,FMT='(A256)') CHAR_VALUE(I,IVAL)
            length = len(CHAR_VALUE(I,IVAL))
6101        IF(index(CHAR_VALUE(I,IVAL),blank).NE.1)GO TO 6102
              IF (( length .GE. 2 )) THEN
                CHAR_VALUE(I,IVAL)=CHAR_VALUE(I,IVAL)(2:)
              ELSE
                GO TO6102
              END IF
              length = length - 1
            GO TO 6101
6102        CONTINUE
            IF (( idebug )) THEN
              write(i_log,*) ' Read the following char string: '
              length = lnblnk1(CHAR_VALUE(I,IVAL))
              IF (( length .GT. 0 )) THEN
                DO 6111 lll=1,length
                  write(i_log,'(a1,$)') CHAR_VALUE(I,IVAL)(lll:lll)
6111            CONTINUE
6112            CONTINUE
                write(i_log,*)
              END IF
            END IF
            IF ((TYPE(I) .EQ. 3)) THEN
              DO 6121 Kconvert=1,lnblnk1(CHAR_VALUE(I,IVAL))
                CURSOR=ICHAR(CHAR_VALUE(I,IVAL)(Kconvert:Kconvert))
                IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                  CURSOR=CURSOR-32
                  CHAR_VALUE(I,IVAL)(Kconvert:Kconvert)=CHAR(CURSOR)
                END IF
6121          CONTINUE
6122          CONTINUE
              ALLOWED=.FALSE.
              DO 6131 K=0,5
                vname1 = ALLOWED_INPUTS(I,K)
                length = len(ALLOWED_INPUTS(I,K))
6141            IF(index(ALLOWED_INPUTS(I,K),blank).NE.1)GO TO 6142
                  IF (( length .GE. 2 )) THEN
                    ALLOWED_INPUTS(I,K)=ALLOWED_INPUTS(I,K)(2:)
                  ELSE
                    GO TO6142
                  END IF
                  length = length - 1
                GO TO 6141
6142            CONTINUE
                DO 6151 Kconvert=1,lnblnk1(ALLOWED_INPUTS(I,K))
                  CURSOR=ICHAR(ALLOWED_INPUTS(I,K)(Kconvert:Kconvert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                    CURSOR=CURSOR-32
                    ALLOWED_INPUTS(I,K)(Kconvert:Kconvert)=CHAR(CURSOR)
                  END IF
6151            CONTINUE
6152            CONTINUE
                IF ((ALLOWED_INPUTS(I,K).EQ.CHAR_VALUE(I,IVAL))) THEN
                  ALLOWED=.TRUE.
                  VALUE(I,IVAL)=K
                  IF (( idebug )) THEN
                    write(i_log,*) ' Found a allowed_value match ',k
                  END IF
                END IF
6131          CONTINUE
6132          CONTINUE
              IF ((.NOT.ALLOWED)) THEN
                WRITE(ERR,*) '*************ERROR*************'
                IF ((IVAL.NE.1)) THEN
                  WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                  WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY'
                  WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND
     * VALUE'
                ELSE
                  WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                  WRITE(ERR,*) 'INPUT-->', CHAR_VALUE(I,IVAL)(:lnblnk1(C
     *            HAR_VALUE(I,IVAL))), '<--NOT ALLOWED'
                  WRITE(ERR,*) 'OPTIONS ARE:'
                  WRITE(ERR,1820) (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_
     *            INPUTS(I,K))),K=0,5)
                END IF
1820            FORMAT(A40)
                ERROR_FLAG=1
                ERROR_FLAGS(I)=1
              END IF
            END IF
            IF ((vname(:ivname).EQ.'TITLE')) THEN
              GO TO6072
            END IF
            DO 6161 K=1,LEN(KEEPTEXT)
              KEEPTEXT(K:K)=' '
6161        CONTINUE
6162        CONTINUE
            KEEPTEXT(:lnblnk1(TEXT))=TEXT
            iindex = INDEX(TEXT,',')
            IF (( iindex .NE. 0 .OR. lnblnk1(TEXT).EQ.0 )) THEN
              TEXT=TEXT(INDEX(TEXT,',')+1:)
              origtext=origtext(iindex+1:)
6171          IF(lnblnk1(TEXT).NE.0)GO TO 6172
                LINE=LINE+1
                READ (UNITNUM,ERR=6090,FMT='(A256)') TEXT
                length = len(text)
6181            IF(index(text,blank).NE.1)GO TO 6182
                  IF (( length .GE. 2 )) THEN
                    text=text(2:)
                  ELSE
                    GO TO6182
                  END IF
                  length = length - 1
                GO TO 6181
6182            CONTINUE
                ifound = INDEX(text,'#')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                ifound = INDEX(text,';')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                length = lnblnk1(TEXT)
                TEXT=TEXT(:length)
                origtext = text(:length)
                DO 6191 Kconvert=1,lnblnk1(text)
                  CURSOR=ICHAR(text(Kconvert:Kconvert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                    CURSOR=CURSOR-32
                    text(Kconvert:Kconvert)=CHAR(CURSOR)
                  END IF
6191            CONTINUE
6192            CONTINUE
                DO 6201 K=1,NMAX
                  vname1 = VALUES_SOUGHT(K)
                  length = lnblnk1(vname1)
                  IF (( length .GT. 0 )) THEN
                    length = len(vname1)
6211                IF(index(vname1,blank).NE.1)GO TO 6212
                      IF (( length .GE. 2 )) THEN
                        vname1=vname1(2:)
                      ELSE
                        GO TO6212
                      END IF
                      length = length - 1
                    GO TO 6211
6212                CONTINUE
                    DO 6221 Kconvert=1,lnblnk1(vname1)
                      CURSOR=ICHAR(vname1(Kconvert:Kconvert))
                      IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                        CURSOR=CURSOR-32
                        vname1(Kconvert:Kconvert)=CHAR(CURSOR)
                      END IF
6221                CONTINUE
6222                CONTINUE
                    IF ((INDEX(TEXT,vname1(:length)).NE.0)) THEN
                      WRITE(ERR,*) '************ERROR************'
                      WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                      WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)), '<--COM
     *MA INDICATES ANOTHER INPUT'
                      WRITE(ERR,*) 'SEARCHED NEXT LINE: ', TEXT(:lnblnk1
     *                (TEXT))
                      WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED'
                      ERROR_FLAG=1
                      ERROR_FLAGS(I)=1
                    END IF
                  END IF
6201            CONTINUE
6202            CONTINUE
              GO TO 6171
6172          CONTINUE
            ELSE
              GO TO6072
            END IF
            IVAL=IVAL+1
          GO TO 6071
6072      CONTINUE
          IF (((NVALUE(I).NE.0).AND.(NVALUE(I).NE.IVAL))) THEN
            IF (( error_level .GT. 0 )) THEN
              WRITE (ERR,*) '*******************ERROR*******************
     *'
              WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I)
              WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)'
              WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED'
            END IF
            ERROR_FLAG=1
            ERROR_FLAGS(I)=1
          ELSE
            NVALUE(I)=IVAL
          END IF
        END IF
        goto 5740
5780    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '******************ERROR***********************'
          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND'
          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER'
          WRITE (ERR,*) 'VALUE SOUGHT: >>', VALUES_SOUGHT(I)(:lnblnk1(VA
     *    LUES_SOUGHT(I))),'<<'
          WRITE (ERR,*) 'END DELIMETER: >>', DELIM_END(:lnblnk1(DELIM_EN
     *    D)),'<<'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
        goto 5740
5800    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '******************ERROR***********************'
          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND'
          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER'
          WRITE (ERR,*) 'VALUE SOUGHT: >>', VALUES_SOUGHT(I)(:lnblnk1(VA
     *    LUES_SOUGHT(I))),'<<'
          WRITE (ERR,*) 'START DELIMETER: >>', DELIM_START(:lnblnk1(DELI
     *    M_START)),'<<'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
        goto 5740
5940    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '***************ERROR***************'
          IF ((IVAL.GT.1)) THEN
            J=IVAL
          ELSE
            J=1
          END IF
          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I)
          WRITE (ERR,*) 'LINE #',LINE
          WRITE (ERR,*) 'COULD NOT READ THE VALUE!!'
          WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...'
          WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPU
     *T?'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
        GOTO 5740
6090    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '***************ERROR***************'
          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I)
          WRITE (ERR,*) 'LINE #',LINE
          WRITE (ERR,*) 'COULD NOT READ THE STRING !!'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
5740    CONTINUE
5731  CONTINUE
5732  CONTINUE
      RETURN
5790  WRITE (ERR,*) '***************ERROR***************'
      WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE
      goto 6230
6230  CONTINUE
      ERROR_FLAG=1
      ERROR_FLAGS(I)=1
      RETURN
      entry get_input_set_error_level(the_level)
      error_level = the_level
      return
      END
      subroutine get_transport_parameter(ounit)
      implicit none
      character*80 line
      character*512 toUpper
      integer*4 ounit
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      common/ET_control/ smaxir( 2001),estepe,ximax,  skindepth_for_bca,
     *transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,6), eno_array(200,6), eno_atbin_array(200,6), n_sh
     *ell(6), radc_flag,  ibcmp( 2001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(6), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),  e
     *ii_sh(40),  eii_nshells(100),  eii_nsh(6),  eii_first(6,50),  eii_
     *no(6,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/rayleigh_inputs/iray_ff_media(6),iray_ff_file(6)
      character*24 iray_ff_media
      character*128 iray_ff_file
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      integer*4 ival,num_ecut,num_pcut,num_smax,num_incoh,num_radc,num_c
     *oh,num_relax, num_pe_ang,num_brems_ang,num_brems_cs,num_pair_cs, n
     *um_ffmed,num_ffiles, num_pair_ang,num_eii,num_eii_L,num_estepe,num
     *_ximax,num_triplet, num_pxsec,num_pxsec_out, num_cxsec, num_photon
     *uc, num_photonuc_xsec, num_efield, num_bfield, num_emlmt, num_spin
     *,num_bca,num_alg,num_skin,itmp,iitmp,i,j,k,istart,iend, egs_open_f
     *ile,lnblnk1
      logical ecut_inregions,pcut_inregions,smax_inregions, incoh_inregi
     *ons,coh_inregions,relax_inregions, pe_inregions,aux_inregions,phot
     *onuc_inregions
      character*15 output_strings(14)
      save output_strings,line
      save ecut_inregions,pcut_inregions,smax_inregions, incoh_inregions
     *,coh_inregions,relax_inregions, pe_inregions,aux_inregions,photonu
     *c_inregions, num_photonuc
      DO 6241 k=1,80
        line(k:k) = '='
6241  CONTINUE
6242  CONTINUE
      delimeter = 'MC TRANSPORT PARAMETER'
      ival = 0
      ecut_inregions=.false.
      pcut_inregions=.false.
      smax_inregions=.false.
      incoh_inregions=.false.
      coh_inregions=.false.
      relax_inregions=.false.
      pe_inregions=.false.
      aux_inregions=.false.
      photonuc_inregions=.false.
      i_errors=15
      i_errors=egs_open_file(i_errors,0,1,'.errors')
      write(i_errors,*) ' If you are not trying to reset transport param
     *eters, '
      write(i_errors,*) ' ignore all the output until the message '
      write(i_errors,*) ' ******************** end input transport param
     *eter *********************** '
      write(i_errors,*)
      ival = ival + 1
      num_ecut = ival
      values_sought(ival) = 'Global ECUT'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      num_pcut = ival
      values_sought(ival) = 'Global PCUT'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      num_smax = ival
      values_sought(ival) = 'Global SMAX'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1e15
      default(ival) = 1e10
      ival = ival + 1
      num_incoh = ival
      values_sought(ival) = 'Bound Compton scattering'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      allowed_inputs(ival,4) = 'Simple'
      allowed_inputs(ival,5) = 'norej'
      ival = ival + 1
      num_radc = ival
      values_sought(ival) = 'Radiative Compton corrections'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_coh = ival
      values_sought(ival) = 'Rayleigh scattering'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      allowed_inputs(ival,4) = 'custom'
      ival = ival + 1
      num_relax = ival
      values_sought(ival) = 'Atomic relaxations'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      allowed_inputs(ival,4) = 'eadl'
      allowed_inputs(ival,5) = 'simple'
      ival = ival + 1
      num_pe_ang = ival
      values_sought(ival) = 'Photoelectron angular sampling'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      ival = ival + 1
      num_brems_ang = ival
      values_sought(ival) = 'Brems angular sampling'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Simple'
      allowed_inputs(ival,1) = 'KM'
      ival = ival + 1
      num_brems_cs = ival
      values_sought(ival) = 'Brems cross sections'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'BH'
      allowed_inputs(ival,1) = 'NIST'
      allowed_inputs(ival,2) = 'NRC'
      ival = ival + 1
      num_pair_ang = ival
      values_sought(ival) = 'Pair angular sampling'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'Simple'
      allowed_inputs(ival,2) = 'KM'
      allowed_inputs(ival,3) = 'Uniform'
      allowed_inputs(ival,4) = 'Blend'
      ival = ival + 1
      num_pair_cs = ival
      values_sought(ival) = 'Pair cross sections'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'BH'
      allowed_inputs(ival,1) = 'NRC'
      ival = ival + 1
      num_triplet = ival
      values_sought(ival) = 'Triplet production'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_spin = ival
      values_sought(ival) = 'Spin effects'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_eii = ival
      values_sought(ival) = 'Electron Impact Ionization'
      nvalue(ival) = 1
      type(ival) = 2
      ival = ival + 1
      num_eii_L= ival
      values_sought(ival) = 'scale L EII cross-sections'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0.0
      value_max(ival) = 1.0e+9
      default(ival) = 1.0
      ival = ival + 1
      num_estepe = ival
      values_sought(ival) = 'ESTEPE'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 1e-5
      value_max(ival) = 1
      default(ival) = 0.25
      ival = ival + 1
      num_ximax = ival
      values_sought(ival) = 'XImax'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1
      default(ival) = 0.5
      ival = ival + 1
      num_bca = ival
      values_sought(ival) = 'Boundary crossing algorithm'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Exact'
      allowed_inputs(ival,1) = 'PRESTA-I'
      ival = ival + 1
      num_skin = ival
      values_sought(ival) = 'Skin depth for BCA'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = -1
      value_max(ival) = 1e15
      default(ival) = 3
      ival = ival + 1
      num_alg = ival
      values_sought(ival) = 'Electron-step algorithm'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'PRESTA-II'
      allowed_inputs(ival,1) = 'PRESTA-I'
      ival = ival + 1
      num_pxsec = ival
      values_sought(ival) = 'Photon cross sections'
      nvalue(ival) = 1
      type(ival) = 2
      ival = ival + 1
      num_pxsec_out = ival
      values_sought(ival) = 'Photon cross-sections output'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_cxsec = ival
      values_sought(ival) = 'Compton cross sections'
      nvalue(ival) = 1
      type(ival) = 2
      ival = ival + 1
      num_efield = ival
      values_sought(ival) = 'Electric Field'
      nvalue(ival) = 3
      type(ival) = 1
      value_min(ival) = -1e15
      value_max(ival) = 1e15
      default(ival) = 0
      ival = ival + 1
      num_bfield = ival
      values_sought(ival) = 'Magnetic Field'
      nvalue(ival) = 3
      type(ival) = 1
      value_min(ival) = -1e10
      value_max(ival) = 1e10
      default(ival) = 0
      ival = ival + 1
      num_emlmt = ival
      values_sought(ival) = 'EM ESTEPE'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0.0
      value_max(ival) = 1.0
      default(ival) = 0.02
      ival = ival + 1
      num_photonuc = ival
      values_sought(ival) = 'Photonuclear attenuation'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      ival = ival + 1
      num_photonuc_xsec = ival
      values_sought(ival) = 'Photonuclear cross sections'
      nvalue(ival) = 1
      type(ival) = 2
      Nmin = num_ecut
      Nmax = num_photonuc_xsec
      CALL GET_INPUT
      IF (( error_flags(num_ecut) .EQ. 0 )) THEN
        DO 6251 j=1, 2001
          ecut(j) = value(num_ecut,1)
6251    CONTINUE
6252    CONTINUE
      END IF
      IF (( error_flags(num_pcut) .EQ. 0 )) THEN
        DO 6261 j=1, 2001
          pcut(j) = value(num_pcut,1)
6261    CONTINUE
6262    CONTINUE
      END IF
      IF (( error_flags(num_smax) .EQ. 0 )) THEN
        DO 6271 j=1, 2001
          smaxir(j) = value(num_smax,1)
6271    CONTINUE
6272    CONTINUE
      END IF
      IF (( error_flags(num_brems_ang) .EQ. 0 )) THEN
        ibrdst = value(num_brems_ang,1)
      END IF
      IF (( error_flags(num_brems_cs) .EQ. 0 )) THEN
        ibr_nist = value(num_brems_cs,1)
      END IF
      IF (( error_flags(num_radc) .EQ. 0 )) THEN
        radc_flag = value(num_radc,1)
      END IF
      IF (( error_flags(num_pair_ang) .EQ. 0 )) THEN
        iprdst = value(num_pair_ang,1)
      END IF
      IF (( error_flags(num_pair_cs) .EQ. 0 )) THEN
        pair_nrc = value(num_pair_cs,1)
      END IF
      IF (( error_flags(num_triplet) .EQ. 0 )) THEN
        itriplet = value(num_triplet,1)
      END IF
      IF (( error_flags(num_eii_L) .EQ. 0 )) THEN
        eii_L_factor = value(num_eii_L,1)
      END IF
      IF (( error_flags(num_estepe) .EQ. 0 )) THEN
        estepe = value(num_estepe,1)
      END IF
      IF (( error_flags(num_ximax) .EQ. 0 )) THEN
        ximax = value(num_ximax,1)
      END IF
      IF (( error_flags(num_bca) .EQ. 0 )) THEN
        bca_algorithm = value(num_bca,1)
        IF (( bca_algorithm .EQ. 0 )) THEN
          exact_bca = .true.
        END IF
      END IF
      IF (( error_flags(num_alg) .EQ. 0 )) THEN
        transport_algorithm = value(num_alg,1)
      END IF
      IF (( error_flags(num_skin) .EQ. 0 )) THEN
        skindepth_for_bca = value(num_skin,1)
      END IF
      IF (( error_flags(num_spin) .EQ. 0 )) THEN
        itmp = value(num_spin,1)
        IF (( itmp .EQ. 1 )) THEN
          spin_effects = .true.
        ELSE
          spin_effects = .false.
        END IF
      END IF
      IF (( error_flags(num_eii) .EQ. 0 )) THEN
        eii_xfile = char_value(num_eii,1)
        eii_flag=1
        IF ((toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'ON' .OR. toUppe
     *  r(eii_xfile(:lnblnk1(eii_xfile))).eq.'IK' )) THEN
          eii_xfile = 'ik'
          write(i_log,*) '==> Using default EII data compilation ', eii_
     *    xfile(:lnblnk1(eii_xfile))
        ELSE IF((toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'OFF')) THEN
          eii_xfile='Off'
          eii_flag=0
        ELSE
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) '==> Using non-default EII data compilation ',
     *    eii_xfile(:lnblnk1(eii_xfile))
        END IF
      END IF
      IF (( error_flags(num_pxsec) .EQ. 0 )) THEN
        photon_xsections = char_value(num_pxsec,1)
        IF (( toUpper( photon_xsections(:lnblnk1(photon_xsections)) ) .E
     *  Q. 'MCDF-XCOM' )) THEN
          mcdf_pe_xsections = .true.
          photon_xsections = 'xcom'
        ELSE IF(( toUpper( photon_xsections(:lnblnk1(photon_xsections))
     *  ) .EQ. 'MCDF-EPDL' )) THEN
          mcdf_pe_xsections = .true.
          photon_xsections = 'epdl'
        ELSE
          mcdf_pe_xsections = .false.
        END IF
      END IF
      IF (( error_flags(num_pxsec_out) .EQ. 0 )) THEN
        xsec_out = value(num_pxsec_out,1)
      END IF
      IF (( error_flags(num_cxsec) .EQ. 0 )) THEN
        comp_xsections = char_value(num_cxsec,1)
      END IF
      IF (( error_flags(num_photonuc_xsec) .EQ. 0 )) THEN
        photonuc_xsections = char_value(num_photonuc_xsec,1)
      END IF
      IF (( error_flags(num_efield) .EQ. 0 )) THEN
        ExIN = value(num_efield,1)
        EyIN = value(num_efield,2)
        EzIN = value(num_efield,3)
        IF (( error_flags(num_emlmt) .EQ. 0 )) THEN
          EMLMTIN=value(num_emlmt,1)
        END IF
        IF (( ExIN**2+EyIN**2+EzIN**2 .GT. 0 )) THEN
          emfield_on=.true.
        END IF
      END IF
      IF (( error_flags(num_bfield) .EQ. 0 )) THEN
        BxIN = value(num_bfield,1)
        ByIN = value(num_bfield,2)
        BzIN = value(num_bfield,3)
        Bx=BxIN
        By=ByIN
        Bz=BzIN
        Bx_new=BxIN
        By_new=ByIN
        Bz_new=BzIN
        IF (( error_flags(num_emlmt) .EQ. 0 )) THEN
          EMLMTIN=value(num_emlmt,1)
        END IF
        IF (( BxIN**2+ByIN**2+BzIN**2 .GT. 0 )) THEN
          emfield_on=.true.
        END IF
      END IF
      IF (( error_flags(num_coh) .EQ. 0 )) THEN
        IF ((value(num_coh,1) .EQ. 4)) THEN
          write(*,'(/a/)') ' ===> custom ff requested!'
          ival = ival + 1
          num_ffmed = ival
          values_sought(ival) = 'ff media names'
          type(ival) = 2
          nvalue(ival) = 0
          ival = ival + 1
          num_ffiles = ival
          values_sought(ival) = 'ff file names'
          type(ival) = 2
          nvalue(ival) = 0
          Nmin = num_ffmed
          Nmax = num_ffiles
          CALL GET_INPUT
          IF (( error_flags(num_ffmed) .GT. 0 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a/,a,I3)') 'Error reading custom ff! Terminati
     *ng ...', ' error_flag = ', error_flags(num_ffmed)
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          IF (( error_flags(num_ffiles) .GT. 0 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a/,a,I3)') 'Error reading ff file names! Termi
     *nating ...', ' error_flag = ', error_flags(num_ffiles)
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          IF ((nvalue(num_ffmed).GT.6)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a,a,i3,a)') '***** Number of media with custom
     * ff larger ', 'than maximum number of media $MXMED = ',6, ' increa
     *se $MXMED and try again!!!'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          DO 6281 i=1,nvalue(num_ffmed)
            iray_ff_media(i) = char_value(num_ffmed,i)
            iray_ff_file(i) = char_value(num_ffiles,i)
6281      CONTINUE
6282      CONTINUE
          value(num_coh,1) = 1
        END IF
        write(*,'(/)')
      END IF
      aux_inregions = .false.
      IF (( error_flags(num_incoh) .EQ. 0 )) THEN
        write(i_log,*) 'Bound Compton start region'
        itmp = value(num_incoh,1)
        IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
          ival = ival + 1
          values_sought(ival) = 'Bound Compton start region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  2001
          default(ival) = 1
          ival = ival + 1
          values_sought(ival) = 'Bound Compton stop region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  2001
          default(ival) = 1
          Nmin = ival-1
          Nmax = ival
          CALL GET_INPUT
          IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ.
     *    0 )) THEN
            IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
              iitmp = itmp-2
              DO 6291 j=1, 2001
                ibcmp(j) = iitmp
6291          CONTINUE
6292          CONTINUE
              iitmp = 1 - iitmp
              DO 6301 k=1,nvalue(ival)
                istart = value(ival-1,k)
                iend = value(ival,k)
                write(i_log,*) 'Bound Compton start region',istart
                write(i_log,*) 'Bound Compton stop region',iend
                IF (( istart .LE. iend )) THEN
                  DO 6311 j=istart,iend
                    ibcmp(j) = iitmp
6311              CONTINUE
6312              CONTINUE
                  aux_inregions = .true.
                END IF
6301          CONTINUE
6302          CONTINUE
            ELSE
              value(num_incoh,1) = ibcmp(1)
            END IF
          ELSE
            value(num_incoh,1) = ibcmp(1)
          END IF
        ELSE
          IF((itmp .GT. 3))itmp = itmp-2
          write(i_log,*) ' Setting all to ',itmp
          DO 6321 j=1, 2001
            ibcmp(j) = itmp
6321      CONTINUE
6322      CONTINUE
        END IF
      ELSE
        IF ((ibcmp(1) .EQ. 2 .OR. ibcmp(1) .EQ. 3)) THEN
          value(num_incoh,1) = ibcmp(1)+2
        ELSE
          value(num_incoh,1) = ibcmp(1)
        END IF
      END IF
      incoh_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_coh) .EQ. 0 )) THEN
        write(i_log,*) 'Rayleigh start region'
        itmp = value(num_coh,1)
        IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
          ival = ival + 1
          values_sought(ival) = 'Rayleigh start region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  2001
          default(ival) = 1
          ival = ival + 1
          values_sought(ival) = 'Rayleigh stop region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  2001
          default(ival) = 1
          Nmin = ival-1
          Nmax = ival
          CALL GET_INPUT
          IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ.
     *    0 )) THEN
            IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
              iitmp = itmp-2
              DO 6331 j=1, 2001
                iraylr(j) = iitmp
6331          CONTINUE
6332          CONTINUE
              iitmp = 1 - iitmp
              DO 6341 k=1,nvalue(ival)
                istart = value(ival-1,k)
                iend = value(ival,k)
                write(i_log,*) 'Rayleigh start region',istart
                write(i_log,*) 'Rayleigh stop region',iend
                IF (( istart .LE. iend )) THEN
                  DO 6351 j=istart,iend
                    iraylr(j) = iitmp
6351              CONTINUE
6352              CONTINUE
                  aux_inregions = .true.
                END IF
6341          CONTINUE
6342          CONTINUE
            ELSE
              value(num_coh,1) = iraylr(1)
            END IF
          ELSE
            value(num_coh,1) = iraylr(1)
          END IF
        ELSE
          IF((itmp .GT. 3))itmp = itmp-2
          write(i_log,*) ' Setting all to ',itmp
          DO 6361 j=1, 2001
            iraylr(j) = itmp
6361      CONTINUE
6362      CONTINUE
        END IF
      ELSE
        IF ((iraylr(1) .EQ. 2 .OR. iraylr(1) .EQ. 3)) THEN
          value(num_coh,1) = iraylr(1)+2
        ELSE
          value(num_coh,1) = iraylr(1)
        END IF
      END IF
      coh_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_relax) .EQ. 0 )) THEN
        write(i_log,*) 'Relaxations start region'
        itmp = value(num_relax,1)
        IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
          ival = ival + 1
          values_sought(ival) = 'Relaxations start region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  2001
          default(ival) = 1
          ival = ival + 1
          values_sought(ival) = 'Relaxations stop region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  2001
          default(ival) = 1
          Nmin = ival-1
          Nmax = ival
          CALL GET_INPUT
          IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ.
     *    0 )) THEN
            IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
              iitmp = itmp-2
              DO 6371 j=1, 2001
                iedgfl(j) = iitmp
6371          CONTINUE
6372          CONTINUE
              iitmp = 1 - iitmp
              DO 6381 k=1,nvalue(ival)
                istart = value(ival-1,k)
                iend = value(ival,k)
                write(i_log,*) 'Relaxations start region',istart
                write(i_log,*) 'Relaxations stop region',iend
                IF (( istart .LE. iend )) THEN
                  DO 6391 j=istart,iend
                    iedgfl(j) = iitmp
6391              CONTINUE
6392              CONTINUE
                  aux_inregions = .true.
                END IF
6381          CONTINUE
6382          CONTINUE
            ELSE
              value(num_relax,1) = iedgfl(1)
            END IF
          ELSE
            value(num_relax,1) = iedgfl(1)
          END IF
        ELSE
          IF((itmp .GT. 3))itmp = itmp-2
          write(i_log,*) ' Setting all to ',itmp
          DO 6401 j=1, 2001
            iedgfl(j) = itmp
6401      CONTINUE
6402      CONTINUE
        END IF
      ELSE
        IF ((iedgfl(1) .EQ. 2 .OR. iedgfl(1) .EQ. 3)) THEN
          value(num_relax,1) = iedgfl(1)+2
        ELSE
          value(num_relax,1) = iedgfl(1)
        END IF
      END IF
      relax_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_pe_ang) .EQ. 0 )) THEN
        write(i_log,*) 'PE sampling start region'
        itmp = value(num_pe_ang,1)
        IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
          ival = ival + 1
          values_sought(ival) = 'PE sampling start region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  2001
          default(ival) = 1
          ival = ival + 1
          values_sought(ival) = 'PE sampling stop region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  2001
          default(ival) = 1
          Nmin = ival-1
          Nmax = ival
          CALL GET_INPUT
          IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ.
     *    0 )) THEN
            IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
              iitmp = itmp-2
              DO 6411 j=1, 2001
                iphter(j) = iitmp
6411          CONTINUE
6412          CONTINUE
              iitmp = 1 - iitmp
              DO 6421 k=1,nvalue(ival)
                istart = value(ival-1,k)
                iend = value(ival,k)
                write(i_log,*) 'PE sampling start region',istart
                write(i_log,*) 'PE sampling stop region',iend
                IF (( istart .LE. iend )) THEN
                  DO 6431 j=istart,iend
                    iphter(j) = iitmp
6431              CONTINUE
6432              CONTINUE
                  aux_inregions = .true.
                END IF
6421          CONTINUE
6422          CONTINUE
            ELSE
              value(num_pe_ang,1) = iphter(1)
            END IF
          ELSE
            value(num_pe_ang,1) = iphter(1)
          END IF
        ELSE
          IF((itmp .GT. 3))itmp = itmp-2
          write(i_log,*) ' Setting all to ',itmp
          DO 6441 j=1, 2001
            iphter(j) = itmp
6441      CONTINUE
6442      CONTINUE
        END IF
      ELSE
        IF ((iphter(1) .EQ. 2 .OR. iphter(1) .EQ. 3)) THEN
          value(num_pe_ang,1) = iphter(1)+2
        ELSE
          value(num_pe_ang,1) = iphter(1)
        END IF
      END IF
      pe_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_photonuc) .EQ. 0 )) THEN
        write(i_log,*) 'Photonuclear start region'
        itmp = value(num_photonuc,1)
        IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
          ival = ival + 1
          values_sought(ival) = 'Photonuclear start region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  2001
          default(ival) = 1
          ival = ival + 1
          values_sought(ival) = 'Photonuclear stop region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) =  2001
          default(ival) = 1
          Nmin = ival-1
          Nmax = ival
          CALL GET_INPUT
          IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ.
     *    0 )) THEN
            IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
              iitmp = itmp-2
              DO 6451 j=1, 2001
                iphotonucr(j) = iitmp
6451          CONTINUE
6452          CONTINUE
              iitmp = 1 - iitmp
              DO 6461 k=1,nvalue(ival)
                istart = value(ival-1,k)
                iend = value(ival,k)
                write(i_log,*) 'Photonuclear start region',istart
                write(i_log,*) 'Photonuclear stop region',iend
                IF (( istart .LE. iend )) THEN
                  DO 6471 j=istart,iend
                    iphotonucr(j) = iitmp
6471              CONTINUE
6472              CONTINUE
                  aux_inregions = .true.
                END IF
6461          CONTINUE
6462          CONTINUE
            ELSE
              value(num_photonuc,1) = iphotonucr(1)
            END IF
          ELSE
            value(num_photonuc,1) = iphotonucr(1)
          END IF
        ELSE
          IF((itmp .GT. 3))itmp = itmp-2
          write(i_log,*) ' Setting all to ',itmp
          DO 6481 j=1, 2001
            iphotonucr(j) = itmp
6481      CONTINUE
6482      CONTINUE
        END IF
      ELSE
        IF ((iphotonucr(1) .EQ. 2 .OR. iphotonucr(1) .EQ. 3)) THEN
          value(num_photonuc,1) = iphotonucr(1)+2
        ELSE
          value(num_photonuc,1) = iphotonucr(1)
        END IF
      END IF
      photonuc_inregions = aux_inregions
      aux_inregions = .false.
      ival = ival + 1
      num_ecut = ival
      values_sought(ival) = 'Set ECUT'
      nvalue(ival) = 0
      type(ival) = 1
      value_min(ival) = 0.
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      values_sought(ival) = 'Set ECUT start region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  2001
      default(ival) = 1
      ival = ival + 1
      values_sought(ival) = 'Set ECUT stop region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  2001
      default(ival) = 1
      Nmin = num_ecut
      Nmax = num_ecut+2
      error_flag = 0
      CALL GET_INPUT
      IF (( error_flag .EQ. 0 )) THEN
        IF (( nvalue(num_ecut) .EQ. nvalue(ival) .AND. nvalue(ival-1) .E
     *  Q. nvalue(ival) )) THEN
          DO 6491 k=1,nvalue(ival)
            istart = value(ival-1,k)
            iend = value(ival,k)
            IF (( istart .LE. iend )) THEN
              DO 6501 j=istart,iend
                ecut(j) = value(num_ecut,k)
6501          CONTINUE
6502          CONTINUE
              aux_inregions = .true.
            END IF
6491      CONTINUE
6492      CONTINUE
        END IF
      END IF
      ecut_inregions = aux_inregions
      aux_inregions = .false.
      ival = ival + 1
      num_pcut = ival
      values_sought(ival) = 'Set PCUT'
      nvalue(ival) = 0
      type(ival) = 1
      value_min(ival) = 0.
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      values_sought(ival) = 'Set PCUT start region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  2001
      default(ival) = 1
      ival = ival + 1
      values_sought(ival) = 'Set PCUT stop region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  2001
      default(ival) = 1
      Nmin = num_pcut
      Nmax = num_pcut+2
      error_flag = 0
      CALL GET_INPUT
      IF (( error_flag .EQ. 0 )) THEN
        IF (( nvalue(num_pcut) .EQ. nvalue(ival) .AND. nvalue(ival-1) .E
     *  Q. nvalue(ival) )) THEN
          DO 6511 k=1,nvalue(ival)
            istart = value(ival-1,k)
            iend = value(ival,k)
            IF (( istart .LE. iend )) THEN
              DO 6521 j=istart,iend
                pcut(j) = value(num_pcut,k)
6521          CONTINUE
6522          CONTINUE
              aux_inregions = .true.
            END IF
6511      CONTINUE
6512      CONTINUE
        END IF
      END IF
      pcut_inregions = aux_inregions
      aux_inregions = .false.
      ival = ival + 1
      num_smax = ival
      values_sought(ival) = 'Set SMAX'
      nvalue(ival) = 0
      type(ival) = 1
      value_min(ival) = 0.
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      values_sought(ival) = 'Set SMAX start region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  2001
      default(ival) = 1
      ival = ival + 1
      values_sought(ival) = 'Set SMAX stop region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  2001
      default(ival) = 1
      Nmin = num_smax
      Nmax = num_smax+2
      error_flag = 0
      CALL GET_INPUT
      IF (( error_flag .EQ. 0 )) THEN
        IF (( nvalue(num_smax) .EQ. nvalue(ival) .AND. nvalue(ival-1) .E
     *  Q. nvalue(ival) )) THEN
          DO 6531 k=1,nvalue(ival)
            istart = value(ival-1,k)
            iend = value(ival,k)
            IF (( istart .LE. iend )) THEN
              DO 6541 j=istart,iend
                smaxir(j) = value(num_smax,k)
6541          CONTINUE
6542          CONTINUE
              aux_inregions = .true.
            END IF
6531      CONTINUE
6532      CONTINUE
        END IF
      END IF
      smax_inregions = aux_inregions
      write(i_errors,*)
      write(i_errors,*) ' ******************** end input transport param
     *eter *********************** '
      write(i_errors,*)
      IF ((value(num_relax,1) .GT. 0 .AND. value(num_relax,1) .LT. 5)) T
     *HEN
        eadl_relax = .true.
        IF ((value(num_relax,1) .EQ. 1)) THEN
          value(num_relax,1)=4
        END IF
      ELSE
        IF ((mcdf_pe_xsections .AND. value(num_relax,1) .EQ. 5)) THEN
          eadl_relax = .true.
          value(num_relax,1)=4
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,'(a/,a/,a/)') '    Simplified atomic relaxation no
     *t allowed', '    with shellwise PE cross sections. Resetting', '
     *  to detailed EADL atomic relaxation!!!'
        ELSE
          eadl_relax = .false.
        END IF
      END IF
      output_strings(1) = allowed_inputs(num_pair_ang,iprdst)
      itmp = value(num_incoh,1)
      output_strings(2) = allowed_inputs(num_incoh,itmp)
      IF (( radc_flag .EQ. 1 )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) 'You are trying to use radiative Compton correcti
     *ons'
        write(i_log,*) 'without having included rad_compton1.mortran'
        write(i_log,'(a//)') 'Turning radiative Compton corrections OFF
     *...'
        radc_flag = 0
      END IF
      output_strings(12) = allowed_inputs(num_radc,radc_flag)
      itmp = value(num_coh,1)
      output_strings(3) = allowed_inputs(num_coh,itmp)
      itmp = value(num_relax,1)
      output_strings(4) = allowed_inputs(num_relax,itmp)
      itmp = value(num_pe_ang,1)
      output_strings(5) = allowed_inputs(num_pe_ang,itmp)
      output_strings(6) = allowed_inputs(num_brems_ang,ibrdst)
      output_strings(7) = allowed_inputs(num_bca,bca_algorithm)
      output_strings(8) = allowed_inputs(num_alg,transport_algorithm)
      output_strings(9) = allowed_inputs(num_brems_cs,ibr_nist)
      output_strings(10) = allowed_inputs(num_pair_cs,pair_nrc)
      output_strings(11) = allowed_inputs(num_triplet,itriplet)
      itmp = value(num_photonuc,1)
      output_strings(14) = allowed_inputs(num_photonuc,itmp)
      entry show_transport_parameter(ounit)
      IF((ounit .LE. 0))return
      write(ounit,*)
      write(ounit,'(a)') line
      write(ounit,*)
      write(ounit,'(a,/)') '                   Electron/Photon transport
     * parameter'
      write(ounit,'(a,/)') line
      write(ounit,'(a,38x,a)') ' Photon cross sections', photon_xsection
     *s(:lnblnk1(photon_xsections))
      write(ounit,'(a,37x,a)') ' Compton cross sections', comp_xsections
     *(:lnblnk1(comp_xsections))
      write(ounit,'(a,$)') ' Photon transport cutoff(MeV)'
      IF (( pcut_inregions )) THEN
        write(ounit,'(32x,a)') 'Set in regions'
      ELSE
        IF (( pcut(1) .GT. 1e-4 )) THEN
          write(ounit,'(32x,g14.4)') pcut(1)
        ELSE
          write(ounit,'(32x,a)') 'AP(medium)'
        END IF
      END IF
      write(ounit,'(a,39x,a3)') ' Pair angular sampling',output_strings(
     *1)
      write(ounit,'(a,41x,a3)') ' Pair cross sections',output_strings(10
     *)
      write(ounit,'(a,42x,a3)') ' Triplet production',output_strings(11)
      write(ounit,'(a,36x,a14)') ' Bound Compton scattering',output_stri
     *ngs(2)
      write(ounit,'(a,31x,a14)') ' Radiative Compton corrections',output
     *_strings(12)
      write(ounit,'(a,41x,a14)') ' Rayleigh scattering',output_strings(3
     *)
      write(ounit,'(a,42x,a14)') ' Atomic relaxations',output_strings(4)
      write(ounit,'(a,30x,a14)') ' Photoelectron angular sampling',outpu
     *t_strings(5)
      IF (( value(num_photonuc,1) .GT. 0 )) THEN
        write(ounit,'(a,36x,a14)') ' Photonuclear attenuation',output_st
     *  rings(14)
        write(ounit,'(a,33x,a)') ' Photonuclear cross sections', photonu
     *  c_xsections(:lnblnk1(photonuc_xsections))
      END IF
      write(ounit,*)
      write(ounit,'(a,$)') ' Electron transport cutoff(MeV)'
      IF (( ecut_inregions )) THEN
        write(ounit,'(30x,a)') 'Set in regions'
      ELSE
        IF (( ecut(1) .GT. 1e-4 )) THEN
          write(ounit,'(30x,f7.4)') ecut(1)
        ELSE
          write(ounit,'(30x,a)') 'AE(medium)'
        END IF
      END IF
      write(ounit,'(a,30x,a4)') ' Bremsstrahlung cross sections',output_
     *strings(9)
      write(ounit,'(a,29x,a3)') ' Bremsstrahlung angular sampling',outpu
     *t_strings(6)
      IF (( spin_effects )) THEN
        write(ounit,'(a,48x,a)') ' Spin effects','On'
      ELSE
        write(ounit,'(a,48x,a)') ' Spin effects','Off'
      END IF
      write(ounit,'(a,34x,a)') ' Electron Impact Ionization',eii_xfile(:
     *lnblnk1(eii_xfile))
      IF ((eii_L_factor .NE. 1.0)) THEN
        write(ounit,'(a,25x,f6.4)') ' L-shell EII xsections scaling fact
     *or',eii_L_factor
      END IF
      write(ounit,'(a,$)') ' Maxium electron step in cm (SMAX)'
      IF (( smax_inregions )) THEN
        write(ounit,'(27x,a)') 'Set in regions'
      ELSE
        IF (( smaxir(1) .GT. 1e-4 )) THEN
          write(ounit,'(27x,g14.4)') smaxir(1)
        ELSE
          write(ounit,'(27x,a)') 'Restriction is off'
        END IF
      END IF
      write(ounit,'(a,16x,f6.4)') ' Maximum fractional energy loss/step
     *(ESTEPE)',estepe
      write(ounit,'(a,21x,f6.4)') ' Maximum 1st elastic moment/step (XIM
     *AX)',ximax
      write(ounit,'(a,33x,a10)') ' Boundary crossing algorithm',output_s
     *trings(7)
      write(ounit,'(a,22x,g9.4)') ' Skin-depth for boundary crossing (MF
     *P)',skindepth_for_bca
      write(ounit,'(a,37x,a10)') ' Electron-step algorithm',output_strin
     *gs(8)
      IF (( ExIN.NE.0 .OR. EyIN.NE.0 .OR. EzIN.NE.0 )) THEN
        write(ounit,'(a,38x,3f10.2)') ' Electric Field [V/cm]', ExIN,EyI
     *  N,EzIN
      END IF
      IF (( Bx.NE.0 .OR. By.NE.0 .OR. Bz.NE.0 )) THEN
        write(ounit,'(a,41x,3f10.2)') ' Magnetic Field [T]', Bx,By,Bz
      END IF
      IF (( ExIN.NE.0 .OR. EyIN.NE.0 .OR. EzIN.NE.0 .OR. Bx.NE.0 .OR. By
     *.NE.0 .OR. Bz.NE.0 )) THEN
        write(ounit,'(a,50x,f10.2)') ' EM ESTEPE',EMLMTIN
      END IF
      write(ounit,*)
      write(ounit,'(a)') line
      write(ounit,*)
      return
      end
      subroutine set_elastic_parameter
      implicit none
      integer*4 ounit
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 imed,ival,lnblnk1,nchanged
      character*24 medname
      ounit = i_log
      ounit = i_log
      delimeter = 'MC TRANSPORT PARAMETER'
      call get_input_set_error_level(0)
      ival = 0
      DO 6551 imed=1,nmed
        call egs_get_medium_name(imed,medname)
        ival = ival + 1
        values_sought(ival) = 'scale elastic scattering in '// medname(:
     *  lnblnk1(medname))
        nvalue(ival) = 1
        type(ival) = 1
        value_min(ival) = 1e-3
        value_max(ival) = 1e3
        default(ival) = 1
6551  CONTINUE
6552  CONTINUE
      Nmin = 1
      Nmax = nmed
      CALL GET_INPUT
      nchanged = 0
      DO 6561 imed=1,nmed
        IF((error_flags(imed) .EQ. 0))nchanged = nchanged + 1
6561  CONTINUE
6562  CONTINUE
      IF (( nchanged .GT. 0 )) THEN
        write(ounit,'(//a)') '================ Elastic scattering scaled
     * as follows =================='
        DO 6571 imed=1,nmed
          IF (( error_flags(imed) .EQ. 0 )) THEN
            call egs_get_medium_name(imed,medname)
            xcc(imed) = xcc(imed)*value(imed,1)
            blcc(imed) = blcc(imed)*value(imed,1)
            write(ounit,'(a,t30,f10.6)') medname(:lnblnk1(medname)), val
     *      ue(imed,1)
          END IF
6571    CONTINUE
6572    CONTINUE
        write(ounit,'(a//)') '==========================================
     *=============================='
      END IF
      return
      end
      SUBROUTINE GET_INPUT_PLUS(UNITNUM,DELIM_START,DELIM_END)
      IMPLICIT NONE
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      CHARACTER*256 TEXT
      CHARACTER*256 KEEPTEXT
      CHARACTER*256 ORIGTEXT
      CHARACTER*256 TEXTPIECE
      CHARACTER*80 DELIM_START
      CHARACTER*80 DELIM_END
      CHARACTER*80 ENDSTRING
      CHARACTER*64 VNAME
      CHARACTER*64 VNAME1
      integer*4 CURSOR
      integer*4 IINDEX
      integer*4 iVNAME
      integer*4 IVAL
      integer*4 UNITNUM
      integer*4 ERR
      integer*4 I,J,K,CHECK
      integer*4 LINE
      integer*4 INT_VALUE
      integer*4 INT_VALUE_MIN
      integer*4 INT_VALUE_MAX
      logical ALLOWED
      logical START_FOUND
      integer*4 ifound,length,lll,Kconvert
      integer*4 lnblnk1
      logical IDEBUG,end_string
      character*1 blank
      integer*4 error_level
      integer*4 the_level
      data blank/' '/
      data error_level/1/
      save error_level
      IDEBUG = .false.
      ERROR_FLAG = 0
      IF ((IDEBUG)) THEN
        WRITE(6,6580)NMIN,NMAX, 100
6580    FORMAT(' Entering get_inputs seeking values', I5,' to', I5, '  w
     *ith a max allowed of',I5)
      END IF
      IF ((NMAX .LT. NMIN .OR. NMAX .GT. 100)) THEN
        WRITE(6,6590)NMAX, NMIN, 100
6590    FORMAT(//' Error entering get_inputs: Asked for values from',I5,
     *' to',I5, '    with a max of',I5//' This implies a bug in the call
     *ing routine'/ ' Fix it up and try again.  Stopping now.')
        STOP
      END IF
      ERR=i_errors
      DELIM_START=DELIM_START(:lnblnk1(DELIM_START))
      DELIM_END=DELIM_END(:lnblnk1(DELIM_END))
      length = len(DELIM_START)
6601  IF(index(DELIM_START,blank).NE.1)GO TO 6602
        IF (( length .GE. 2 )) THEN
          DELIM_START=DELIM_START(2:)
        ELSE
          GO TO6602
        END IF
        length = length - 1
      GO TO 6601
6602  CONTINUE
      length = len(DELIM_END)
6611  IF(index(DELIM_END,blank).NE.1)GO TO 6612
        IF (( length .GE. 2 )) THEN
          DELIM_END=DELIM_END(2:)
        ELSE
          GO TO6612
        END IF
        length = length - 1
      GO TO 6611
6612  CONTINUE
      DO 6621 Kconvert=1,lnblnk1(DELIM_START)
        CURSOR=ICHAR(DELIM_START(Kconvert:Kconvert))
        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
          CURSOR=CURSOR-32
          DELIM_START(Kconvert:Kconvert)=CHAR(CURSOR)
        END IF
6621  CONTINUE
6622  CONTINUE
      DO 6631 Kconvert=1,lnblnk1(DELIM_END)
        CURSOR=ICHAR(DELIM_END(Kconvert:Kconvert))
        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
          CURSOR=CURSOR-32
          DELIM_END(Kconvert:Kconvert)=CHAR(CURSOR)
        END IF
6631  CONTINUE
6632  CONTINUE
      length = len(ENDSTRING)
6641  IF(index(ENDSTRING,blank).NE.1)GO TO 6642
        IF (( length .GE. 2 )) THEN
          ENDSTRING=ENDSTRING(2:)
        ELSE
          GO TO6642
        END IF
        length = length - 1
      GO TO 6641
6642  CONTINUE
      IF ((ENDSTRING.EQ.blank)) THEN
        end_string=.false.
      ELSE
        DO 6651 Kconvert=1,lnblnk1(ENDSTRING)
          CURSOR=ICHAR(ENDSTRING(Kconvert:Kconvert))
          IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
            CURSOR=CURSOR-32
            ENDSTRING(Kconvert:Kconvert)=CHAR(CURSOR)
          END IF
6651    CONTINUE
6652    CONTINUE
        end_string=.false.
      END IF
      IF ((IDEBUG)) THEN
        WRITE(6,6660)DELIM_START,DELIM_END
6660    FORMAT(' start and stop delimeters are:'/ A/A/)
      END IF
      DO 6671 I=NMIN,NMAX
        REWIND (UNITNUM)
        LINE=0
        CHECK=0
        ERROR_FLAGS(I)=0
        IF ((TYPE(I) .EQ. 0 .OR. TYPE(I) .EQ. 1)) THEN
          VALUE(I,1) = DEFAULT(I)
        END IF
        IF ((TYPE(I) .EQ. 3)) THEN
          VALUE(I,1) = 0
        END IF
        VNAME=VALUES_SOUGHT(I)
        iVNAME=lnblnk1(VNAME)
        IF (( ivname .LT. 1 )) THEN
          IF (( error_level .GT. 0 )) THEN
            write(ERR,*) ' ======================= Warning =============
     *======== '
            write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!
     *         '
            write(ERR,*) ' =============================================
     *======== '
          END IF
          ERROR_FLAG=1
          ERROR_FLAGS(I)=1
          goto 5740
        END IF
        DO 6681 Kconvert=1,lnblnk1(vname)
          CURSOR=ICHAR(vname(Kconvert:Kconvert))
          IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
            CURSOR=CURSOR-32
            vname(Kconvert:Kconvert)=CHAR(CURSOR)
          END IF
6681    CONTINUE
6682    CONTINUE
        iindex = 0
        IF ((DELIM_START .EQ. 'NONE')) THEN
          start_found = .true.
        ELSE
          start_found = .false.
        END IF
6691    IF(iindex.NE.0)GO TO 6692
5770      CONTINUE
          LINE=LINE+1
          IF (( start_found )) THEN
            READ(UNITNUM,END=5780,ERR=5790,FMT='(A256)') TEXT
          ELSE
            READ(UNITNUM,END=5800,ERR=5790,FMT='(A256)') TEXT
          END IF
          length = len(text)
6701      IF(index(text,blank).NE.1)GO TO 6702
            IF (( length .GE. 2 )) THEN
              text=text(2:)
            ELSE
              GO TO6702
            END IF
            length = length - 1
          GO TO 6701
6702      CONTINUE
          ifound = INDEX(text,'#')
          IF (( ifound .GT. 1 )) THEN
            text = text(1:ifound-1)
          ELSE
            IF (( ifound .EQ. 1 )) THEN
              text = blank
            END IF
          END IF
          ifound = INDEX(text,';')
          IF (( ifound .GT. 1 )) THEN
            text = text(1:ifound-1)
          ELSE
            IF (( ifound .EQ. 1 )) THEN
              text = blank
            END IF
          END IF
          length = lnblnk1(TEXT)
          TEXT=TEXT(:length)
          origtext = text(:length)
          DO 6711 Kconvert=1,lnblnk1(text)
            CURSOR=ICHAR(text(Kconvert:Kconvert))
            IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
              CURSOR=CURSOR-32
              text(Kconvert:Kconvert)=CHAR(CURSOR)
            END IF
6711      CONTINUE
6712      CONTINUE
          IF (( .NOT.start_found )) THEN
            IF ((INDEX(TEXT,DELIM_START) .NE. 0 )) THEN
              start_found = .true.
            END IF
            goto 5770
          END IF
          iindex=INDEX(TEXT,VNAME(:iVNAME))
          IF (( DELIM_END.NE.'NONE' )) THEN
            IF ((INDEX(TEXT,DELIM_END).NE.0)) THEN
              IF (( error_level .GT. 0 )) THEN
                WRITE (ERR,*) '***************ERROR***************'
                WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUG
     *          HT(I))), '<<',' NOT FOUND'
                WRITE (ERR,*) 'END OF DELIMETER: ',DELIM_END
              END IF
              ERROR_FLAG=1
              ERROR_FLAGS(I)=1
              GOTO 5740
            END IF
          END IF
        GO TO 6691
6692    CONTINUE
        CHECK=0
        IF (( idebug )) THEN
          write(i_log,*) ' ******* Found: '
          write(i_log,'(a,$)') ' text:     '
          length = lnblnk1(text)
          IF (( length .GT. 0 )) THEN
            DO 6721 lll=1,length
              write(i_log,'(a1,$)') text(lll:lll)
6721        CONTINUE
6722        CONTINUE
            write(i_log,*)
          END IF
          write(i_log,'(a,$)') ' origtext: '
          length = lnblnk1(origtext)
          IF (( length .GT. 0 )) THEN
            DO 6731 lll=1,length
              write(i_log,'(a1,$)') origtext(lll:lll)
6731        CONTINUE
6732        CONTINUE
            write(i_log,*)
          END IF
        END IF
        IINDEX=IINDEX+iVNAME
        TEXT=TEXT(IINDEX:)
        origtext=origtext(iindex:)
        IF (( idebug )) THEN
          write(i_log,*) ' After removing vname: '
          write(i_log,'(a,$)') ' text:     '
          length = lnblnk1(text)
          IF (( length .GT. 0 )) THEN
            DO 6741 lll=1,length
              write(i_log,'(a1,$)') text(lll:lll)
6741        CONTINUE
6742        CONTINUE
            write(i_log,*)
          END IF
          write(i_log,'(a,$)') ' origtext: '
          length = lnblnk1(origtext)
          IF (( length .GT. 0 )) THEN
            DO 6751 lll=1,length
              write(i_log,'(a1,$)') origtext(lll:lll)
6751        CONTINUE
6752        CONTINUE
            write(i_log,*)
          END IF
        END IF
        IINDEX=INDEX(TEXT,'=')
        IF ((IINDEX.NE.0)) THEN
          TEXT=TEXT(IINDEX+1:)
          origtext=origtext(iindex+1:)
        ELSE
          IINDEX=INDEX(TEXT,':')
          IF ((IINDEX.NE.0)) THEN
            TEXT=TEXT(IINDEX+1:)
            origtext=origtext(iindex+1:)
          END IF
        END IF
        IF (( idebug )) THEN
          write(i_log,*) ' After removing leading equals: '
          write(i_log,'(a,$)') ' text:     '
          length = lnblnk1(text)
          IF (( length .GT. 0 )) THEN
            DO 6761 lll=1,length
              write(i_log,'(a1,$)') text(lll:lll)
6761        CONTINUE
6762        CONTINUE
            write(i_log,*)
          END IF
          write(i_log,'(a,$)') ' origtext: '
          length = lnblnk1(origtext)
          IF (( length .GT. 0 )) THEN
            DO 6771 lll=1,length
              write(i_log,'(a1,$)') origtext(lll:lll)
6771        CONTINUE
6772        CONTINUE
            write(i_log,*)
          END IF
        END IF
        IF (( (lnblnk1(TEXT).EQ.0) .OR. (lnblnk1(TEXT).EQ.1) )) THEN
          IF ((vname(:ivname).EQ.'TITLE')) THEN
            READ (UNITNUM,FMT='(A256)') TEXTPIECE
            IF ((lnblnk1(TEXTPIECE).NE.0)) THEN
              TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE))
              length = len(text)
6781          IF(index(text,blank).NE.1)GO TO 6782
                IF (( length .GE. 2 )) THEN
                  text=text(2:)
                ELSE
                  GO TO6782
                END IF
                length = length - 1
              GO TO 6781
6782          CONTINUE
              length = len(origtext)
6791          IF(index(origtext,blank).NE.1)GO TO 6792
                IF (( length .GE. 2 )) THEN
                  origtext=origtext(2:)
                ELSE
                  GO TO6792
                END IF
                length = length - 1
              GO TO 6791
6792          CONTINUE
              GOTO 5910
            END IF
          END IF
          IF (( error_level .GT. 0 )) THEN
            WRITE (ERR,*) '*************ERROR*************'
            WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
            WRITE (ERR,*) 'VALUE NOT THERE!!'
          END IF
          ERROR_FLAG=1
          ERROR_FLAGS(I)=1
          RETURN
        END IF
5910    CONTINUE
        iindex = index(text,'DEFAULT')
        IF (( iindex .NE. 0 )) THEN
          IF (( type(i) .NE. 2 )) THEN
            IF (( type(i) .NE. 3 )) THEN
              VALUE(I,1)=DEFAULT(I)
            ELSE
              VALUE(I,1)=0
            END IF
            goto 5740
          END IF
        END IF
        IF (((TYPE(I) .EQ. 0).OR.(TYPE(I) .EQ. 1))) THEN
          IVAL=1
          IF (( idebug )) THEN
            write(i_log,*) ' *** Reading an integer or a real value! '
          END IF
6801      CONTINUE
            IF (( idebug )) THEN
              write(i_log,*) ' In LOOP, ival = ',ival
            END IF
            IF ((lnblnk1(TEXT).EQ.0)) THEN
              IF (( error_level .GT. 0 )) THEN
                WRITE(ERR,*) '*************ERROR*************'
                WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                WRITE (ERR,*) 'VALUE NOT THERE!!'
              END IF
              ERROR_FLAG=1
              ERROR_FLAGS(I)=1
              RETURN
            END IF
            READ(TEXT,END=5930,ERR=5940,FMT=*) VALUE(I,IVAL)
            IF (( idebug )) THEN
              write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL)
            END IF
            IF (((VALUE(I,IVAL).GT.VALUE_MAX(I)).OR.(VALUE(I,IVAL).LT.VA
     *      LUE_MIN(I)))) THEN
              IF ((TYPE(I).EQ.0)) THEN
                INT_VALUE=DEFAULT(I)
                IF (( error_level .GT. 0 )) THEN
                  WRITE(ERR,*) '************WARNING************'
                  WRITE(ERR,5950) INT_VALUE, VALUES_SOUGHT(I)(:lnblnk1(V
     *            ALUES_SOUGHT(I)))
                END IF
5950            FORMAT ( 'Default= ',I9,' used for: ', A )
                INT_VALUE=VALUE(I,IVAL)
                INT_VALUE_MIN=VALUE_MIN(I)
                INT_VALUE_MAX=VALUE_MAX(I)
                IF (( error_level .GT. 0 )) THEN
                  WRITE(ERR,5960) VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGH
     *            T(I))), INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX
                END IF
5960            FORMAT (A,'=', I9,' should be between ', I9,' and ', I9)
              END IF
              IF ((TYPE(I).EQ.1)) THEN
                IF (( error_level .GT. 0 )) THEN
                  WRITE(ERR,*) '************WARNING************'
                  WRITE(ERR,5970) DEFAULT(I), VALUES_SOUGHT(I)(:lnblnk1(
     *            VALUES_SOUGHT(I)))
5970              FORMAT ( 'Default= ',F12.6,' used for: ', A )
                  WRITE(ERR,5980) VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGH
     *            T(I))), VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I)
5980              FORMAT (A,'=', F12.6,' should be between ', G14.6,' an
     *d ', G14.6)
                END IF
              END IF
              VALUE(I,IVAL)=DEFAULT(I)
            END IF
            IF((IVAL .EQ. NVALUE(I)))GO TO6802
            IF (((INDEX(TEXT,',').NE.0).OR.(lnblnk1(TEXT).EQ.0))) THEN
              IF (( idebug )) THEN
                write(i_log,*) ' A comma or a blank text found -> '
                write(i_log,*) ' searching for further input'
              END IF
              TEXT=TEXT(INDEX(TEXT,',')+1:)
6811          IF(lnblnk1(TEXT).NE.0)GO TO 6812
                IF (( idebug )) THEN
                  write(i_log,*) ' Empty text -> reading next line! '
                END IF
                LINE=LINE+1
                READ (UNITNUM,END=5930,ERR=5940,FMT='(A256)') TEXT
                length = len(text)
6821            IF(index(text,blank).NE.1)GO TO 6822
                  IF (( length .GE. 2 )) THEN
                    text=text(2:)
                  ELSE
                    GO TO6822
                  END IF
                  length = length - 1
                GO TO 6821
6822            CONTINUE
                ifound = INDEX(text,'#')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                ifound = INDEX(text,';')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                length = lnblnk1(TEXT)
                TEXT=TEXT(:length)
                origtext = text(:length)
                DO 6831 Kconvert=1,lnblnk1(text)
                  CURSOR=ICHAR(text(Kconvert:Kconvert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                    CURSOR=CURSOR-32
                    text(Kconvert:Kconvert)=CHAR(CURSOR)
                  END IF
6831            CONTINUE
6832            CONTINUE
                DO 6841 K=1,NMAX
                  vname1 = VALUES_SOUGHT(K)
                  length = lnblnk1(vname1)
                  IF (( length .GT. 0 )) THEN
                    length = len(vname1)
6851                IF(index(vname1,blank).NE.1)GO TO 6852
                      IF (( length .GE. 2 )) THEN
                        vname1=vname1(2:)
                      ELSE
                        GO TO6852
                      END IF
                      length = length - 1
                    GO TO 6851
6852                CONTINUE
                    DO 6861 Kconvert=1,lnblnk1(vname1)
                      CURSOR=ICHAR(vname1(Kconvert:Kconvert))
                      IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                        CURSOR=CURSOR-32
                        vname1(Kconvert:Kconvert)=CHAR(CURSOR)
                      END IF
6861                CONTINUE
6862                CONTINUE
                    IF ((INDEX(TEXT,vname1(:length)).NE.0)) THEN
                      IF (( error_level .GT. 0 )) THEN
                        WRITE(ERR,*) '************ERROR************'
                        WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                        WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)), '<--C
     *OMMA INDICATES ANOTHER INPUT'
                        WRITE(ERR,*) 'SEARCHED NEXT LINE: ', TEXT(:lnbln
     *                  k1(TEXT))
                        WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED'
                      END IF
                      ERROR_FLAG=1
                      ERROR_FLAGS(I)=1
                    END IF
                  END IF
6841            CONTINUE
6842            CONTINUE
                IF (( idebug )) THEN
                  write(i_log,*) ' Next line: '
                  write(i_log,'(a,$)') ' text:     '
                  length = lnblnk1(text)
                  IF (( length .GT. 0 )) THEN
                    DO 6871 lll=1,length
                      write(i_log,'(a1,$)') text(lll:lll)
6871                CONTINUE
6872                CONTINUE
                    write(i_log,*)
                  END IF
                  write(i_log,'(a,$)') ' origtext: '
                  length = lnblnk1(origtext)
                  IF (( length .GT. 0 )) THEN
                    DO 6881 lll=1,length
                      write(i_log,'(a1,$)') origtext(lll:lll)
6881                CONTINUE
6882                CONTINUE
                    write(i_log,*)
                  END IF
                END IF
              GO TO 6811
6812          CONTINUE
            ELSE
              GO TO6802
            END IF
            IVAL=IVAL+1
          GO TO 6801
6802      CONTINUE
          IF (((NVALUE(I).NE.0).AND.(NVALUE(I).NE.IVAL))) THEN
            IF (( error_level .GT. 0 )) THEN
              WRITE (ERR,*) '**************ERROR**************'
              WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I)
              WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)'
              WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED'
            END IF
            ERROR_FLAG=1
            ERROR_FLAGS(I)=1
          ELSE
            NVALUE(I)=IVAL
          END IF
5930      CONTINUE
        END IF
        IF (((TYPE(I) .EQ. 2) .OR. (TYPE(I) .EQ. 3))) THEN
          IVAL=1
          IF (( idebug )) THEN
            write(i_log,*) ' Trying to read a string! '
          END IF
6891      CONTINUE
            IF (( idebug )) THEN
              write(i_log,*) ' In LOOP, ival = ',ival
            END IF
            IF ((lnblnk1(TEXT).EQ.0)) THEN
              IF (( error_level .GT. 0 )) THEN
                WRITE(ERR,*) '*************ERROR*************'
                WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                WRITE (ERR,*) 'VALUE NOT THERE!!'
              END IF
              ERROR_FLAG=1
              ERROR_FLAGS(I)=1
              RETURN
            END IF
            IF ((vname(:ivname).EQ.'TITLE')) THEN
              TEXTPIECE=origtext
              GOTO 6080
            END IF
            iindex = INDEX(origtext,',')
            IF (( iindex .NE. 0 )) THEN
              TEXTPIECE=origtext(:iindex-1)
            ELSE
              TEXTPIECE=origtext
            END IF
6080        CONTINUE
            READ(TEXTPIECE,ERR=6090,FMT='(A256)') CHAR_VALUE(I,IVAL)
            length = len(CHAR_VALUE(I,IVAL))
6901        IF(index(CHAR_VALUE(I,IVAL),blank).NE.1)GO TO 6902
              IF (( length .GE. 2 )) THEN
                CHAR_VALUE(I,IVAL)=CHAR_VALUE(I,IVAL)(2:)
              ELSE
                GO TO6902
              END IF
              length = length - 1
            GO TO 6901
6902        CONTINUE
            IF (( idebug )) THEN
              write(i_log,*) ' Read the following char string: '
              length = lnblnk1(CHAR_VALUE(I,IVAL))
              IF (( length .GT. 0 )) THEN
                DO 6911 lll=1,length
                  write(i_log,'(a1,$)') CHAR_VALUE(I,IVAL)(lll:lll)
6911            CONTINUE
6912            CONTINUE
                write(i_log,*)
              END IF
            END IF
            IF ((TYPE(I) .EQ. 3)) THEN
              DO 6921 Kconvert=1,lnblnk1(CHAR_VALUE(I,IVAL))
                CURSOR=ICHAR(CHAR_VALUE(I,IVAL)(Kconvert:Kconvert))
                IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                  CURSOR=CURSOR-32
                  CHAR_VALUE(I,IVAL)(Kconvert:Kconvert)=CHAR(CURSOR)
                END IF
6921          CONTINUE
6922          CONTINUE
              ALLOWED=.FALSE.
              DO 6931 K=0,5
                vname1 = ALLOWED_INPUTS(I,K)
                length = len(ALLOWED_INPUTS(I,K))
6941            IF(index(ALLOWED_INPUTS(I,K),blank).NE.1)GO TO 6942
                  IF (( length .GE. 2 )) THEN
                    ALLOWED_INPUTS(I,K)=ALLOWED_INPUTS(I,K)(2:)
                  ELSE
                    GO TO6942
                  END IF
                  length = length - 1
                GO TO 6941
6942            CONTINUE
                DO 6951 Kconvert=1,lnblnk1(ALLOWED_INPUTS(I,K))
                  CURSOR=ICHAR(ALLOWED_INPUTS(I,K)(Kconvert:Kconvert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                    CURSOR=CURSOR-32
                    ALLOWED_INPUTS(I,K)(Kconvert:Kconvert)=CHAR(CURSOR)
                  END IF
6951            CONTINUE
6952            CONTINUE
                IF ((ALLOWED_INPUTS(I,K).EQ.CHAR_VALUE(I,IVAL))) THEN
                  ALLOWED=.TRUE.
                  VALUE(I,IVAL)=K
                  IF (( idebug )) THEN
                    write(i_log,*) ' Found a allowed_value match ',k
                  END IF
                END IF
6931          CONTINUE
6932          CONTINUE
              IF ((.NOT.ALLOWED)) THEN
                WRITE(ERR,*) '*************ERROR*************'
                IF ((IVAL.NE.1)) THEN
                  WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                  WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY'
                  WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND
     * VALUE'
                ELSE
                  WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                  WRITE(ERR,*) 'INPUT-->', CHAR_VALUE(I,IVAL)(:lnblnk1(C
     *            HAR_VALUE(I,IVAL))), '<--NOT ALLOWED'
                  WRITE(ERR,*) 'OPTIONS ARE:'
                  WRITE(ERR,1820) (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_
     *            INPUTS(I,K))),K=0,5)
                END IF
1820            FORMAT(A40)
                ERROR_FLAG=1
                ERROR_FLAGS(I)=1
              END IF
            END IF
            IF ((vname(:ivname).EQ.'TITLE')) THEN
              GO TO6892
            END IF
            DO 6961 K=1,LEN(KEEPTEXT)
              KEEPTEXT(K:K)=' '
6961        CONTINUE
6962        CONTINUE
            KEEPTEXT(:lnblnk1(TEXT))=TEXT
            iindex = INDEX(TEXT,',')
            IF (( iindex .NE. 0 .OR. lnblnk1(TEXT).EQ.0 )) THEN
              TEXT=TEXT(INDEX(TEXT,',')+1:)
              origtext=origtext(iindex+1:)
6971          IF(lnblnk1(TEXT).NE.0)GO TO 6972
                LINE=LINE+1
                READ (UNITNUM,ERR=6090,FMT='(A256)') TEXT
                length = len(text)
6981            IF(index(text,blank).NE.1)GO TO 6982
                  IF (( length .GE. 2 )) THEN
                    text=text(2:)
                  ELSE
                    GO TO6982
                  END IF
                  length = length - 1
                GO TO 6981
6982            CONTINUE
                ifound = INDEX(text,'#')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                ifound = INDEX(text,';')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                length = lnblnk1(TEXT)
                TEXT=TEXT(:length)
                origtext = text(:length)
                DO 6991 Kconvert=1,lnblnk1(text)
                  CURSOR=ICHAR(text(Kconvert:Kconvert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                    CURSOR=CURSOR-32
                    text(Kconvert:Kconvert)=CHAR(CURSOR)
                  END IF
6991            CONTINUE
6992            CONTINUE
                DO 7001 K=1,NMAX
                  vname1 = VALUES_SOUGHT(K)
                  length = lnblnk1(vname1)
                  IF (( length .GT. 0 )) THEN
                    length = len(vname1)
7011                IF(index(vname1,blank).NE.1)GO TO 7012
                      IF (( length .GE. 2 )) THEN
                        vname1=vname1(2:)
                      ELSE
                        GO TO7012
                      END IF
                      length = length - 1
                    GO TO 7011
7012                CONTINUE
                    DO 7021 Kconvert=1,lnblnk1(vname1)
                      CURSOR=ICHAR(vname1(Kconvert:Kconvert))
                      IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                        CURSOR=CURSOR-32
                        vname1(Kconvert:Kconvert)=CHAR(CURSOR)
                      END IF
7021                CONTINUE
7022                CONTINUE
                    IF ((INDEX(TEXT,vname1(:length)).NE.0)) THEN
                      WRITE(ERR,*) '************ERROR************'
                      WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                      WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)), '<--COM
     *MA INDICATES ANOTHER INPUT'
                      WRITE(ERR,*) 'SEARCHED NEXT LINE: ', TEXT(:lnblnk1
     *                (TEXT))
                      WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED'
                      ERROR_FLAG=1
                      ERROR_FLAGS(I)=1
                    END IF
                  END IF
7001            CONTINUE
7002            CONTINUE
              GO TO 6971
6972          CONTINUE
            ELSE
              GO TO6892
            END IF
            IVAL=IVAL+1
          GO TO 6891
6892      CONTINUE
          IF (((NVALUE(I).NE.0).AND.(NVALUE(I).NE.IVAL))) THEN
            IF (( error_level .GT. 0 )) THEN
              WRITE (ERR,*) '*******************ERROR*******************
     *'
              WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I)
              WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)'
              WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED'
            END IF
            ERROR_FLAG=1
            ERROR_FLAGS(I)=1
          ELSE
            NVALUE(I)=IVAL
          END IF
        END IF
        goto 5740
5780    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '******************ERROR***********************'
          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND'
          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER'
          WRITE (ERR,*) 'VALUE SOUGHT: >>', VALUES_SOUGHT(I)(:lnblnk1(VA
     *    LUES_SOUGHT(I))),'<<'
          WRITE (ERR,*) 'END DELIMETER: >>', DELIM_END(:lnblnk1(DELIM_EN
     *    D)),'<<'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
        goto 5740
5800    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '******************ERROR***********************'
          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND'
          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER'
          WRITE (ERR,*) 'VALUE SOUGHT: >>', VALUES_SOUGHT(I)(:lnblnk1(VA
     *    LUES_SOUGHT(I))),'<<'
          WRITE (ERR,*) 'START DELIMETER: >>', DELIM_START(:lnblnk1(DELI
     *    M_START)),'<<'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
        goto 5740
5940    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '***************ERROR***************'
          IF ((IVAL.GT.1)) THEN
            J=IVAL
          ELSE
            J=1
          END IF
          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I)
          WRITE (ERR,*) 'LINE #',LINE
          WRITE (ERR,*) 'COULD NOT READ THE VALUE!!'
          WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...'
          WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPU
     *T?'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
        GOTO 5740
6090    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '***************ERROR***************'
          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I)
          WRITE (ERR,*) 'LINE #',LINE
          WRITE (ERR,*) 'COULD NOT READ THE STRING !!'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
5740    CONTINUE
6671  CONTINUE
6672  CONTINUE
      RETURN
5790  WRITE (ERR,*) '***************ERROR***************'
      WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE
      goto 6230
6230  CONTINUE
      ERROR_FLAG=1
      ERROR_FLAGS(I)=1
      RETURN
      entry get_input_plus_set_error_level(the_level)
      error_level = the_level
      return
      END
      subroutine get_media_inputs(ounit)
      implicit none
      integer*4 ounit
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      common/ET_control/ smaxir( 2001),estepe,ximax,  skindepth_for_bca,
     *transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,6), eno_array(200,6), eno_atbin_array(200,6), n_sh
     *ell(6), radc_flag,  ibcmp( 2001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(6), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),  e
     *ii_sh(40),  eii_nshells(100),  eii_nsh(6),  eii_first(6,50),  eii_
     *no(6,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/rayleigh_inputs/iray_ff_media(6),iray_ff_file(6)
      character*24 iray_ff_media
      character*128 iray_ff_file
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      COMMON/MEDINP/inpdensity_file(6),inpasym(6,50), inpstrn(24,6),pz4(
     *6,50), rhoz4(6,50),wa4(6,50),inpgasp(6)
      character*256 inpdensity_file
      CHARACTER*4 inpasym,inpstrn
      real*4 pz4,rhoz4,wa4,inpgasp
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100)
      integer*4 NET
      real*4 ITBL,WATBL,RHOTBL
      CHARACTER*4 ASYMT
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      integer*4 ival,ival_media,ival_medfile,i,j,k,ival_ae,ival_ue,ival_
     *ap,ival_up, ival_rho,ival_elements,ival_rhoz,ival_iunrst,ival_iapr
     *im,ival_gasp, ival_pz,ival_sterncid, ival_densityfile,medfile_erro
     *r,ival_outfile, egs_open_file,lnblnk1,i_medfile,egs_get_unit,i_med
     *err,mindex,eindex, i_density,i01,length,i_outfile
      real*8 ecut_min, pcut_min
      logical medfile_specified,densityfile_specified,elements_specified
     *, outfile_specified(6)
      logical iunrst_specified,stern_specified,iaprim_specified, gasp_sp
     *ecified,rho_specified,start_delim_found,end_delim_found, spec_by_p
     *z,spec_by_rhoz,df_if_elem_mismatch(6), df_if_rho_mismatch(6)
      logical ex
      integer*4 CURSOR,Kconvert
      real*4 ZTBL
      real*8 EKE,ELKE,TMXSO,DEDXE,DEDXP,EFRACT,SIGE,SIGP,BREME,BREMP,ETA
     *B(16), EIE,PLOTE(300),PLOTEM(300),PLOTEEN(300), PLOTEMP(300), PLOT
     *EMS(300)
      integer*4 IPLOTE,IFLAG1,IFLAG2,LELKE
      CHARACTER*60 GRAPHTITLE,XAXIS,YAXISPcom,YAXISPmfp,YAXISE,YAXISEmfp
     *, SUBTITLE,SERIES
      DATA ETAB/1.,1.25,1.5,1.75,2.,2.5,3.,3.5,4.,4.5,5.,5.5,6.,7.,8.,9.
     */
      character*24 medium_name,med_tmp,sterncid_tmp
      character*256 density_file,material_file,tmp_string, spoutput_file
     *(6)
      character*80 text_string, text_save, title
      character*80 delim_start,delim_end
      character*1 blank
      character*512 toUpper
      integer*4 nne_tmp,iaprim_tmp,epstfl_tmp,iunrst_tmp
      real*8 rho_tmp,rhoz_tmp(50),z_tmp(50),pz_tmp(50),ae_tmp,ap_tmp, ue
     *_tmp,up_tmp,gasp_tmp
      CHARACTER*4 asym_tmp(50)
      integer*4 nepst_df,nne_df
      real*8 iev_df,rho_df,z_df(50),rhoz_df(50),rhoz_tot
      CHARACTER*4 asym_df(50)
      data blank/' '/
      save medfile_specified,material_file,df_if_elem_mismatch,df_if_rho
     *_mismatch, spoutput_file,outfile_specified
      call get_input_set_error_level(0)
      call get_input_plus_set_error_level(0)
      IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
        i_mederr=17
        i_mederr=egs_open_file(i_mederr,0,1,'.mederr')
      END IF
      ecut_min=999.
      pcut_min=999.
      DO 7031 i=1, 2001
        IF((ecut(i).LT.ecut_min))ecut_min=ecut(i)
        IF((pcut(i).LT.pcut_min))pcut_min=pcut(i)
7031  CONTINUE
7032  CONTINUE
      delimeter = 'MEDIA DEFINITION'
      ival = 0
      ival = ival + 1
      ival_medfile = ival
      values_sought(ival) = 'material data file'
      nvalue(ival) = 1
      type(ival) = 2
      Nmin = ival_medfile
      Nmax = ival_medfile
      CALL GET_INPUT
      IF ((error_flags(ival_medfile).EQ.0)) THEN
        material_file=char_value(ival_medfile,1)
        medfile_specified=.true.
        i_medfile=17
        i_medfile=egs_get_unit(i_medfile)
        IF ((i_medfile .LT. 1)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a)') 'Error: Failed to get available fortran uni
     *t for', ' medium data file.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_medfile,file=material_file,status='old',err=7040)
        medfile_specified=.true.
      ELSE
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Warning: material data file not supplied.'
        END IF
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Thus, you must define media explicitly in i
     *nput file'
        END IF
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' or via density correction file.'
        END IF
        medfile_specified=.false.
      END IF
      ival = ival + 1
      ival_ae = ival
      values_sought(ival) = 'ae'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 999.
      default(ival) = ecut_min
      ival = ival + 1
      ival_ap = ival
      values_sought(ival) = 'ap'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 999.
      default(ival) = pcut_min
      ival = ival + 1
      ival_ue = ival
      values_sought(ival) = 'ue'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 999.
      default(ival) = 50 + prm
      ival = ival + 1
      ival_up = ival
      values_sought(ival) = 'up'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 999.
      default(ival) = 50.0
      Nmin=ival_ae
      Nmax=ival_up
      CALL GET_INPUT
      IF ((error_flags(ival_ae).EQ.0)) THEN
        ae_tmp=value(ival_ae,1)
      ELSE
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Warning: AE for media not supplied.  Will u
     *se min. ECUT.'
        END IF
        ae_tmp=ecut_min
      END IF
      IF ((error_flags(ival_ap).EQ.0)) THEN
        ap_tmp=value(ival_ap,1)
      ELSE
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Warning: AP for media not supplied.  Will u
     *se min. PCUT.'
        END IF
        ap_tmp=pcut_min
      END IF
      IF ((error_flags(ival_ue).EQ.0)) THEN
        ue_tmp=value(ival_ue,1)
      ELSE
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Warning: UE for media not supplied.  Will u
     *se                     50.5109989461 MeV'
        END IF
        ue_tmp=50 + prm
      END IF
      IF ((error_flags(ival_up).EQ.0)) THEN
        up_tmp=value(ival_up,1)
      ELSE
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Warning: UP for media not supplied.  Will u
     *se 50.0 MeV'
        END IF
        up_tmp=50.
      END IF
      IF ((ue_tmp.LE.ae_tmp)) THEN
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Error: UE <= AE.  Adjust value(s) and try a
     *gain.'
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(a)') ' Error: UE <= AE.  Adjust value(s) and try a
     *gain.'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF ((up_tmp.LE.ap_tmp)) THEN
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' Error: UP <= AP.  Adjust value(s) and try a
     *gain.'
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(a)') ' Error: UP <= AP.  Adjust value(s) and try a
     *gain.'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      DO 7051 i=1,NMED
        DO 7061 j=1,24
          medium_name(j:j)=media(j,i)
7061    CONTINUE
7062    CONTINUE
        elements_specified=.false.
        rho_specified=.false.
        densityfile_specified=.false.
        stern_specified=.false.
        iunrst_specified=.false.
        iaprim_specified=.false.
        gasp_specified=.false.
        spec_by_rhoz=.false.
        spec_by_pz=.false.
        df_if_elem_mismatch(i)=.false.
        df_if_rho_mismatch(i)=.false.
        sterncid_tmp=medium_name
        gasp_tmp=0.0
        iunrst_tmp=0
        iaprim_tmp=0
        epstfl_tmp=0
        density_file=' '
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' '
        END IF
        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
          write(i_mederr,*)' For medium: ',medium_name
        END IF
        delimeter=medium_name(:lnblnk1(medium_name))
        ival=0
        ival=ival+1
        ival_elements=ival
        values_sought(ival) = 'elements'
        type(ival) = 2
        nvalue(ival) = 0
        nmin=ival_elements
        nmax=ival_elements
        CALL GET_INPUT
        IF ((error_flags(ival_elements).EQ.0)) THEN
          DO 7071 j=1,nvalue(ival_elements)
            DO 7081 Kconvert=1,lnblnk1(char_value(ival_elements,j))
              CURSOR=ICHAR(char_value(ival_elements,j)(Kconvert:Kconvert
     *        ))
              IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                CURSOR=CURSOR-32
                char_value(ival_elements,j)(Kconvert:Kconvert)=CHAR(CURS
     *          OR)
              END IF
7081        CONTINUE
7082        CONTINUE
7071      CONTINUE
7072      CONTINUE
          ival=ival+1
          ival_pz=ival
          nne_tmp=nvalue(ival_elements)
          values_sought(ival)='number of atoms'
          type(ival)=0
          nvalue(ival)=nne_tmp
          nmin=ival_pz
          nmax=ival_pz
          CALL GET_INPUT
          IF ((nne_tmp.GT.1 .AND. error_flags(ival_pz).EQ.0)) THEN
            DO 7091 j=1,nne_tmp
              asym_tmp(j)=char_value(ival_elements,j)
              pz_tmp(j)=value(ival_pz,j)
7091        CONTINUE
7092        CONTINUE
            elements_specified=.true.
            spec_by_pz=.true.
          ELSE
            ival=ival+1
            ival_rhoz=ival
            values_sought(ival)='mass fractions'
            type(ival)=1
            nvalue(ival)=nne_tmp
            nmin=ival_rhoz
            nmax=ival_rhoz
            IF ((nne_tmp.EQ.1)) THEN
              value_min(ival)=0.0
              value_max(ival)=1.e15
              default(ival)=1.
            END IF
            CALL GET_INPUT
            IF ((error_flags(ival_rhoz).EQ.0)) THEN
              DO 7101 j=1,nne_tmp
                asym_tmp(j)=char_value(ival_elements,j)
                rhoz_tmp(j)=value(ival_rhoz,j)
7101          CONTINUE
7102          CONTINUE
              elements_specified=.true.
              spec_by_rhoz=.true.
            END IF
          END IF
          IF ((nne_tmp.EQ.1 .AND. .NOT.elements_specified)) THEN
            asym_tmp(1)=char_value(ival_elements,1)
            pz_tmp(1)=1
            elements_specified=.true.
            spec_by_pz=.true.
          END IF
          IF ((elements_specified)) THEN
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' Composition specified in .egsinp file.'
            END IF
          END IF
        END IF
        ival=ival+1
        ival_rho=ival
        values_sought(ival) = 'rho'
        type(ival)=1
        nvalue(ival)=1
        value_min(ival)=0.
        value_max(ival)=1e15
        default(ival)=1.0
        nmin=ival_rho
        nmax=ival_rho
        CALL GET_INPUT
        IF ((error_flags(ival_rho).EQ.0)) THEN
          rho_tmp=value(ival_rho,1)
          rho_specified=.true.
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' Rho specified in .egsinp file.'
          END IF
        END IF
        ival=ival+1
        ival_sterncid=ival
        values_sought(ival)='sterncid'
        type(ival)=2
        nvalue(ival)=1
        nmin=ival_sterncid
        nmax=ival_sterncid
        CALL GET_INPUT
        IF ((error_flags(ival_sterncid).EQ.0)) THEN
          sterncid_tmp=char_value(ival_sterncid,1)
          stern_specified=.true.
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' STERNCID specified in .egsinp file.'
          END IF
        END IF
        ival=ival+1
        ival_iunrst=ival
        values_sought(ival)='stopping powers'
        type(ival)=3
        nvalue(ival)=1
        allowed_inputs(ival,0)='restricted total'
        allowed_inputs(ival,1)='unrestricted collision'
        allowed_inputs(ival,2)='unrestricted collision and radiative'
        allowed_inputs(ival,3)='unrestricted collision and restricted ra
     *diative'
        allowed_inputs(ival,4)='restricted collision and unrestricted ra
     *diative'
        allowed_inputs(ival,5)='unrestricted radiative'
        nmin=ival_iunrst
        nmax=ival_iunrst
        CALL GET_INPUT
        IF ((error_flags(ival_iunrst).EQ.0)) THEN
          iunrst_tmp=value(ival_iunrst,1)
          iunrst_specified=.true.
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' IUNRST specified in .egsinp file.'
          END IF
        END IF
        ival=ival+1
        ival_iaprim=ival
        values_sought(ival)='bremsstrahlung correction'
        type(ival)=3
        nvalue(ival)=1
        allowed_inputs(ival,0)='KM'
        allowed_inputs(ival,1)='NRC'
        allowed_inputs(ival,2)='none'
        nmin=ival_iaprim
        nmax=ival_iaprim
        CALL GET_INPUT
        IF ((error_flags(ival_iaprim).EQ.0)) THEN
          iaprim_tmp=value(ival_iaprim,1)
          iaprim_specified=.true.
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' IAPRIM specified in .egsinp file.'
          END IF
        END IF
        ival=ival+1
        ival_gasp=ival
        values_sought(ival)='gas pressure'
        type(ival)=1
        nvalue(ival)=1
        value_min(ival)=0.
        value_max(ival)=1e15
        default(ival)=0.0
        nmin=ival_gasp
        nmax=ival_gasp
        CALL GET_INPUT
        IF ((error_flags(ival_gasp).EQ.0)) THEN
          gasp_tmp=value(ival_gasp,1)
          gasp_specified=.true.
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' GASP specified in .egsinp file.'
          END IF
        END IF
        ival=ival+1
        ival_densityfile=ival
        values_sought(ival)='density correction file'
        type(ival) = 2
        nvalue(ival)=1
        nmin=ival_densityfile
        nmax=ival_densityfile
        CALL GET_INPUT
        IF ((error_flags(ival_densityfile).EQ.0)) THEN
          density_file=char_value(ival_densityfile,1)
          densityfile_specified=.true.
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' Density correction file specified in .egs
     *inp file.'
          END IF
        END IF
        ival = ival+1
        ival_outfile = ival
        values_sought(ival) = 'e- stopping power output file'
        type(ival) = 2
        nvalue(ival) =1
        nmin=ival_outfile
        nmax=ival_outfile
        CALL GET_INPUT
        IF ((error_flags(ival_outfile).EQ.0)) THEN
          spoutput_file(i)=char_value(ival_outfile,1)
          outfile_specified(i)=.true.
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' e- stopping powers will be output to ', s
     *      poutput_file(i)
          END IF
        ELSE
          outfile_specified(i)=.false.
        END IF
        IF ((medfile_specified .AND. (.NOT.elements_specified .OR. .NOT.
     *  rho_specified .OR. .NOT.iunrst_specified .OR. .NOT.iaprim_specif
     *  ied .OR. .NOT.gasp_specified .OR. .NOT.stern_specified .OR. .NOT
     *  .densityfile_specified))) THEN
          rewind(i_medfile)
          start_delim_found=.false.
          end_delim_found=.false.
7111      IF((.NOT.(.NOT.start_delim_found)).AND.(.NOT.(.NOT.end_delim_f
     *    ound)))GO TO 7112
            read(i_medfile,'(a)',end=7120)text_string
            text_save=text_string
            text_string=toUpper(text_string(:lnblnk1(text_string)))
            mindex=index(text_string,'MEDIUM')
            eindex=index(text_string,'=')
            IF ((mindex.GT.0 .AND. eindex.GT.mindex)) THEN
              text_string=text_save(eindex+1:)
              text_string=text_string(:lnblnk1(text_string))
              length = len(text_string)
7131          IF(index(text_string,blank).NE.1)GO TO 7132
                IF (( length .GE. 2 )) THEN
                  text_string=text_string(2:)
                ELSE
                  GO TO7132
                END IF
                length = length - 1
              GO TO 7131
7132          CONTINUE
              IF ((text_string.EQ.medium_name)) THEN
                delim_start=text_save
                start_delim_found=.true.
              ELSE IF((start_delim_found)) THEN
                delim_end=text_save
                end_delim_found=.true.
              END IF
            END IF
          GO TO 7111
7112      CONTINUE
7120      IF ((.NOT.start_delim_found)) THEN
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' Warning: Data for ',medium_name,' not f
     *ound'
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' in material data file.'
            END IF
          ELSE
            IF ((.NOT.end_delim_found)) THEN
              delim_end='NONE'
            END IF
            ival=0
            IF ((.NOT.elements_specified)) THEN
              ival=ival+1
              ival_elements=ival
              values_sought(ival) = 'elements'
              type(ival) = 2
              nvalue(ival) = 0
              nmin=ival_elements
              nmax=ival_elements
              CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
              IF ((error_flags(ival_elements).EQ.0)) THEN
                ival=ival+1
                ival_pz=ival
                nne_tmp=nvalue(ival_elements)
                values_sought(ival)='number of atoms'
                type(ival)=0
                nvalue(ival)=nne_tmp
                nmin=ival_pz
                nmax=ival_pz
                CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
                IF ((nne_tmp.GT.1 .AND. error_flags(ival_pz).EQ.0)) THEN
                  DO 7141 j=1,nne_tmp
                    asym_tmp(j)=char_value(ival_elements,j)
                    pz_tmp(j)=value(ival_pz,j)
7141              CONTINUE
7142              CONTINUE
                  elements_specified=.true.
                  spec_by_pz=.true.
                ELSE
                  ival=ival+1
                  ival_rhoz=ival
                  values_sought(ival)='mass fractions'
                  type(ival)=1
                  nvalue(ival)=nne_tmp
                  nmin=ival_rhoz
                  nmax=ival_rhoz
                  IF ((nne_tmp.EQ.1)) THEN
                    value_min(ival)=0.0
                    value_max(ival)=1.e15
                    default(ival)=1.
                  END IF
                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
                  IF ((error_flags(ival_rhoz).EQ.0)) THEN
                    DO 7151 j=1,nne_tmp
                      asym_tmp(j)=char_value(ival_elements,j)
                      rhoz_tmp(j)=value(ival_rhoz,j)
7151                CONTINUE
7152                CONTINUE
                    elements_specified=.true.
                    spec_by_rhoz=.true.
                  END IF
                END IF
                IF ((nne_tmp.EQ.1 .AND. .NOT.elements_specified)) THEN
                  asym_tmp(1)=char_value(ival_elements,1)
                  pz_tmp(1)=1
                  elements_specified=.true.
                  spec_by_pz=.true.
                END IF
                IF ((elements_specified)) THEN
                  IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel
     *            )) THEN
                    write(i_mederr,*)' Composition specified in material
     * data file'
                  END IF
                END IF
              END IF
            END IF
            IF ((.NOT.rho_specified)) THEN
              ival=ival+1
              ival_rho=ival
              values_sought(ival) = 'rho'
              type(ival)=1
              nvalue(ival)=1
              value_min(ival)=0.
              value_max(ival)=1e15
              default(ival)=1.0
              nmin=ival_rho
              nmax=ival_rho
              CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
              IF ((error_flags(ival_rho).EQ.0)) THEN
                rho_tmp=value(ival_rho,1)
                rho_specified=.true.
                IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *           THEN
                  write(i_mederr,*)' Rho specified in material data file
     *'
                END IF
              END IF
            END IF
            IF ((.NOT.stern_specified)) THEN
              ival=ival+1
              ival_sterncid=ival
              values_sought(ival)='sterncid'
              type(ival)=2
              nvalue(ival)=1
              nmin=ival_sterncid
              nmax=ival_sterncid
              CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
              IF ((error_flags(ival_sterncid).EQ.0)) THEN
                sterncid_tmp=char_value(ival_sterncid,1)
                stern_specified=.true.
                IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *           THEN
                  write(i_mederr,*)' STERNCID specified in material data
     * file'
                END IF
              END IF
            END IF
            IF ((.NOT.iunrst_specified)) THEN
              ival=ival+1
              ival_iunrst=ival
              values_sought(ival)='stopping powers'
              type(ival)=3
              nvalue(ival)=1
              allowed_inputs(ival,0)='restricted total'
              allowed_inputs(ival,1)='unrestricted collision'
              allowed_inputs(ival,2)='unrestricted collision and radiati
     *ve'
              allowed_inputs(ival,3)= 'unrestricted collision and restri
     *cted radiative'
              allowed_inputs(ival,4)= 'restricted collision and unrestri
     *cted radiative'
              allowed_inputs(ival,5)='unrestricted radiative'
              nmin=ival_iunrst
              nmax=ival_iunrst
              CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
              IF ((error_flags(ival_iunrst).EQ.0)) THEN
                iunrst_tmp=value(ival_iunrst,1)
                iunrst_specified=.true.
                IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *           THEN
                  write(i_mederr,*)' IUNRST specified in material data f
     *ile'
                END IF
              END IF
            END IF
            IF ((.NOT.iaprim_specified)) THEN
              ival=ival+1
              ival_iaprim=ival
              values_sought(ival)='bremsstrahlung correction'
              type(ival)=3
              nvalue(ival)=1
              allowed_inputs(ival,0)='KM'
              allowed_inputs(ival,1)='NRC'
              allowed_inputs(ival,2)='none'
              nmin=ival_iaprim
              nmax=ival_iaprim
              CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
              IF ((error_flags(ival_iaprim).EQ.0)) THEN
                iaprim_tmp=value(ival_iaprim,1)
                iaprim_specified=.true.
                IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *           THEN
                  write(i_mederr,*)' IAPRIM specified in material data f
     *ile'
                END IF
              END IF
            END IF
            IF ((.NOT.gasp_specified)) THEN
              ival=ival+1
              ival_gasp=ival
              values_sought(ival)='gas pressure'
              type(ival)=1
              nvalue(ival)=1
              value_min(ival)=0.
              value_max(ival)=1.e15
              default(ival)=0.
              nmin=ival_gasp
              nmax=ival_gasp
              CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
              IF ((error_flags(ival_gasp).EQ.0)) THEN
                gasp_tmp=value(ival_gasp,1)
                gasp_specified=.true.
                IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *           THEN
                  write(i_mederr,*)' GASP specified in material data fil
     *e'
                END IF
              END IF
            END IF
            IF ((.NOT.densityfile_specified)) THEN
              ival=ival+1
              ival_densityfile=ival
              values_sought(ival)='density correction file'
              type(ival) = 2
              nvalue(ival)=1
              nmin=ival_densityfile
              nmax=ival_densityfile
              CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
              IF ((error_flags(ival_densityfile).EQ.0)) THEN
                density_file=char_value(ival_densityfile,1)
                densityfile_specified=.true.
                IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *           THEN
                  write(i_mederr,*)' Density correction file specified i
     *n material data file.'
                END IF
              END IF
            END IF
          END IF
        END IF
        IF ((densityfile_specified)) THEN
          write(*,*)' density_file ',density_file
          IF ((index(density_file,'/').GT.0)) THEN
            tmp_string=density_file(:lnblnk1(density_file))
            inquire(file=tmp_string,exist=ex)
            IF ((.NOT.ex)) THEN
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' Error: Density correction file ',tmp_
     *          string
              END IF
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' cannot be found.'
              END IF
            END IF
          ELSE
            density_file=density_file(:lnblnk1(density_file))//'.density
     *'
            tmp_string=egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/' //
     *       'density_corrections' // '/' // density_file
            inquire(file=tmp_string,exist=ex)
            IF((ex))goto 7160
            tmp_string=egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/' //
     *       'density_corrections' // '/' // 'elements' // '/' // densit
     *      y_file
            inquire(file=tmp_string,exist=ex)
            IF((ex))goto 7160
            tmp_string=egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/' //
     *       'density_corrections' // '/' // 'compounds' // '/' // densi
     *      ty_file
            inquire(file=tmp_string,exist=ex)
            IF((ex))goto 7160
            tmp_string=egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/' //
     *       'density' // '/' // density_file
            inquire(file=tmp_string,exist=ex)
            IF((ex))goto 7160
            tmp_string=hen_house(:lnblnk1(hen_house)) // 'pegs4' // '/'
     *      // 'density_corrections' // '/' // 'elements' // '/' // dens
     *      ity_file
            inquire(file=tmp_string,exist=ex)
            IF((ex))goto 7160
            tmp_string=hen_house(:lnblnk1(hen_house)) // 'pegs4' // '/'
     *      // 'density_corrections' // '/' // 'compounds' // '/' // den
     *      sity_file
            inquire(file=tmp_string,exist=ex)
            IF((ex))goto 7160
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' Error: Density correction file', densit
     *        y_file
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' does not exist in'
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' $EGS_HOME/pegs4/density_corrections, '
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' $EGS_HOME/pegs4/density_corrections/ele
     *ments, '
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' $EGS_HOME/pegs4/density_corrections/com
     *pounds, '
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' $EGS_HOME/pegs4/density, '
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' $HEN_HOUSE/pegs4/density_corrections/el
     *ements or '
            END IF
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' $HEN_HOUSE/pegs4/density_corrections/co
     *mpounds.'
            END IF
7160        CONTINUE
          END IF
        END IF
        IF ((densityfile_specified)) THEN
          i_density=19
          i_density=egs_get_unit(i_density)
          IF ((i_density .LT. 1)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a)') 'Error: Failed to get available fortran u
     *nit for', ' density correction file.'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(i_density,file=tmp_string,status='old',err=7170)
          density_file=tmp_string
          densityfile_specified=.true.
          epstfl_tmp=1
          read(i_density,'(a)')title
          read(i_density,*)nepst_df,iev_df,rho_df,nne_df
          read(i_density,*)(z_df(j),rhoz_df(j),j=1,nne_df)
          DO 7181 j=1,nne_df
            i01=z_df(j)
            asym_df(j)=ASYMT(i01)
7181      CONTINUE
7182      CONTINUE
          IF ((elements_specified)) THEN
            IF ((nne_tmp.NE.nne_df)) THEN
              df_if_elem_mismatch(i)=.true.
            ELSE
              rhoz_tot=0.
              DO 7191 j=1,nne_tmp
                IF ((spec_by_pz)) THEN
                  i01=ZTBL(asym_tmp(j))
                  rhoz_tmp(j)=pz_tmp(j)*WATBL(i01)
                END IF
                rhoz_tot=rhoz_tot+rhoz_tmp(j)
7191          CONTINUE
7192          CONTINUE
              DO 7201 j=1,nne_df
                DO 7211 k=1,nne_tmp
                  IF ((asym_df(j).EQ.asym_tmp(k))) THEN
                    IF ((rhoz_df(j).GT.(1+0.01)*rhoz_tmp(k)/rhoz_tot .OR
     *              . rhoz_df(j).LT.(1-0.01)*rhoz_tmp(k)/rhoz_tot)) THEN
                      df_if_elem_mismatch(i)=.true.
                    END IF
                    exit
                  END IF
7211            CONTINUE
7212            CONTINUE
                IF((k.GT.nne_tmp))df_if_elem_mismatch(i)=.true.
                IF ((df_if_elem_mismatch(i))) THEN
                  exit
                END IF
7201          CONTINUE
7202          CONTINUE
            END IF
            IF ((df_if_elem_mismatch(i))) THEN
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' Warning: composition specified in den
     *sity correction', ' file is not the same as that'
              END IF
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' specified in input or material data f
     *ile.'
              END IF
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' Will use the composition specified in
     * the density correction file.'
              END IF
              nne_tmp=nne_df
              DO 7221 j=1,nne_tmp
                z_tmp(j)=z_df(j)
                rhoz_tmp(j)=rhoz_df(j)
                asym_tmp(j)=asym_df(j)
7221          CONTINUE
7222          CONTINUE
              spec_by_rhoz=.true.
            END IF
          ELSE
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' Composition specified in density correc
     *tion file'
            END IF
            nne_tmp=nne_df
            DO 7231 j=1,nne_tmp
              z_tmp(j)=z_df(j)
              rhoz_tmp(j)=rhoz_df(j)
              asym_tmp(j)=asym_df(j)
7231        CONTINUE
7232        CONTINUE
            spec_by_rhoz=.true.
            elements_specified=.true.
          END IF
          IF ((rho_specified)) THEN
            IF ((rho_df.GT.(1+0.01)*rho_tmp .OR. rho_df.LT.(1-0.01)*rho_
     *      tmp)) THEN
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' Warning: rho specified in density cor
     *rection', ' file is not the same as that'
              END IF
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' specified in input or material data f
     *ile.'
              END IF
              IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) T
     *        HEN
                write(i_mederr,*)' Will use rho as specified in the dens
     *ity correction file.'
              END IF
              rho_tmp=rho_df
              df_if_rho_mismatch(i)=.true.
            END IF
          ELSE
            rho_tmp=rho_df
            rho_specified=.true.
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' Rho specified in density correction fil
     *e'
            END IF
          END IF
          IF ((gasp_specified)) THEN
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
              write(i_mederr,*)' Warning: gas pressure input not require
     *d', ' when using density correction file.  Will set GASP=0.'
            END IF
            gasp_specified=.false.
            gasp_tmp=0.
          END IF
          close(i_density)
        END IF
        IF ((elements_specified .AND. rho_specified)) THEN
          ae(i)=ae_tmp
          ue(i)=ue_tmp
          ap(i)=ap_tmp
          up(i)=up_tmp
          DO 7241 j=1,24
            inpstrn(j,i) = sterncid_tmp(j:j)
7241      CONTINUE
7242      CONTINUE
          nne(i)=nne_tmp
          rho(i)=rho_tmp
          DO 7251 j=1,nne_tmp
            inpasym(i,j)=asym_tmp(j)
            zelem(i,j)=ZTBL(asym_tmp(j))
            i01=zelem(i,j)
            wa(i,j)=WATBL(i01)
            wa4(i,j)=WATBL(i01)
            IF ((spec_by_rhoz)) THEN
              rhoz(i,j)=rhoz_tmp(j)
              rhoz4(i,j)=rhoz_tmp(j)
              pz(i,j)=rhoz(i,j)/wa(i,j)
              pz4(i,j)=rhoz4(i,j)/wa4(i,j)
            ELSE IF((spec_by_pz)) THEN
              pz(i,j)=pz_tmp(j)
              pz4(i,j)=pz_tmp(j)
              rhoz(i,j)=pz(i,j)*wa(i,j)
              rhoz4(i,j)=pz4(i,j)*wa4(i,j)
            END IF
7251      CONTINUE
7252      CONTINUE
          iunrst(i)=iunrst_tmp
          iaprim(i)=iaprim_tmp
          epstfl(i)=epstfl_tmp
          inpgasp(i)=gasp_tmp
          inpdensity_file(i)=density_file
        ELSE
          IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' Error: Medium ',medium_name,' not correct
     *ly defined.'
          END IF
        END IF
7051  CONTINUE
7052  CONTINUE
      IF((medfile_specified))close(i_medfile)
      IF((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))close(i_med
     *err)
      entry show_media_parameters(ounit)
      IF((ounit .LE. 0))return
      IF ((is_pegsless)) THEN
        write(ounit,*)
        write(ounit,*)' Medium data: '
        write(ounit,*)
        write(ounit,'(a,1p,e14.5,a,e14.5,a)')' AE = ',ae(1),' MeV,  UE =
     * ',ue(1),' MeV'
        write(ounit,'(a,1p,e14.5,a,e14.5,a)')' AP = ',ap(1),' MeV,  UP =
     * ',up(1),' MeV'
        write(ounit,*)
        IF ((medfile_specified)) THEN
          write(ounit,*)' Material data file: ',material_file
        ELSE
          write(ounit,*)' No material data file supplied.  Material data
     * obtained from'
          write(ounit,*)' .egsinp file or density correction file.'
        END IF
        write(ounit,*)
        DO 7261 i=1,nmed
          write(ounit,'(a,24a1)')'   Medium: ',(media(j,i),j=1,24)
          write(ounit,'(a,24a1)')' Sterncid: ',(inpstrn(j,i),j=1,24)
          write(ounit,'(a,1p,e14.5,a)')'     rho: ',rho(i),' g/cm^3'
          write(ounit,'(a,24a4)')' Elements: ',(inpasym(i,j),j=1,nne(i))
          write(ounit,'(a,1p,12e14.5)')'    rhoz: ',(rhoz(i,j),j=1,nne(i
     *    ))
          write(ounit,'(a,1p,12e14.5)')'      pz: ',(pz(i,j),j=1,nne(i))
          write(ounit,'(a,i5)')'  iunrst: ',iunrst(i)
          write(ounit,'(a,i5)')'  iaprim: ',iaprim(i)
          write(ounit,'(a,1p,e14.5,a)')'    gasp: ',inpgasp(i),' atm.'
          IF ((epstfl(i).EQ.1)) THEN
            write(ounit,*)' density correction file: ', inpdensity_file(
     *      i)(:lnblnk1(inpdensity_file(i)))
            IF ((df_if_elem_mismatch(i))) THEN
              write(ounit,*)' ****Warning: composition specified in dens
     *ity correction', ' file is not the same as that'
              write(ounit,*)' specified in input or material data file.'
              write(ounit,*) ' Will use the composition specified in the
     * density correction file.'
            END IF
            IF ((df_if_rho_mismatch(i))) THEN
              write(ounit,*)' ****Warning: rho specified in density corr
     *ection', ' file is not the same as that'
              write(ounit,*)' specified in input or material data file.'
              write(ounit,*) ' Will use rho as specified in the density
     *correction file.'
            END IF
          END IF
          write(ounit,*)
          IF ((outfile_specified(i) .AND. (n_parallel.EQ.0 .OR. i_parall
     *    el.EQ.first_parallel))) THEN
            inquire(file=spoutput_file(i),exist=ex)
            IF ((ex)) THEN
              write(i_log,'(/a)') '***************** Warning: '
              write(i_log,'(a)') 'Warning: stopping power output file ',
     *         spoutput_file(i),'already exists.  Will overwrite.'
            END IF
            i_outfile=20
            i_outfile=egs_get_unit(i_outfile)
            IF ((i_outfile .LT. 1)) THEN
              write(i_log,'(/a)') '***************** Warning: '
              write(i_log,'(a)') 'Warning: Failed to get available fortr
     *an unit for', ' stopping power output file.'
            END IF
            open(i_outfile,file=spoutput_file(i),status='unknown',err=72
     *      70)
            goto 7280
7270        write(i_log,'(/a)') '***************** Warning: '
            write(i_log,'(a)') 'Warning: Failed to open stopping power o
     *utput file ', spoutput_file(i)
            goto 7290
7280        IFLAG1=0
            IFLAG2=0
            IPLOTE=0
            MEDIUM=i
            XAXIS = 'kinetic energy / MeV'
            YAXISE = 'dE/drhoX MeV/g/cm\\S2\\N'
            YAXISEmfp = 'mean free path / cm'
            YAXISPmfp = 'mean free path / cm'
            write(GRAPHTITLE,'(24a1)')(media(j,i),j=1,24)
            SUBTITLE = 'Electron data'
            DO 7301 j=1,8
              DO 7311 k=1,16
                EKE=ETAB(k)*10.**(j-4)
                IF ((EKE .LE. AE(1)-PRM)) THEN
                  IF ((IFLAG1 .EQ. 0)) THEN
                    IFLAG1=1
                    EKE=AE(1)-PRM
                  ELSE
                    EKE=0.0
                  END IF
                END IF
                IF ((EKE .GT. UE(1)-PRM)) THEN
                  IF ((IFLAG2 .EQ. 0)) THEN
                    IFLAG2=1
                    EKE=UE(1)-PRM
                  ELSE
                    EKE=1.E30
                  END IF
                END IF
                EIE=EKE+PRM
                TMXSO=0.0
                DEDXE=0.0
                DEDXP=0.0
                EFRACT=0.0
                IF ((EIE .GE. AE(1)-0.0001 .AND. EIE .LE. UE(1)+0.001))
     *          THEN
                  ELKE=LOG(EKE)
                  LELKE=EKE1(MEDIUM)*ELKE+EKE0(MEDIUM)
                  DEDXE=EDEDX1(LELKE,MEDIUM)*ELKE+EDEDX0(LELKE,MEDIUM)
                  IPLOTE=IPLOTE+1
                  PLOTEEN(IPLOTE)=EKE
                  PLOTE(IPLOTE)=DEDXE/RHO(MEDIUM)
                END IF
7311          CONTINUE
7312          CONTINUE
7301        CONTINUE
7302        CONTINUE
            IF ((IPLOTE.GT.0)) THEN
              IF ((iunrst(i).EQ.0)) THEN
                SERIES='restricted total stopping power'
              ELSE IF((iunrst(i).EQ.1)) THEN
                SERIES='unrestricted collision stopping power'
              ELSE IF((iunrst(i).EQ.2)) THEN
                SERIES='unrestricted collision + radiative stopping powe
     *r'
              ELSE IF((iunrst(i).EQ.3)) THEN
                SERIES='unrestricted collision + restricted radiative st
     *opping power'
              ELSE IF((iunrst(i).EQ.4)) THEN
                SERIES='restricted collision + unrestricted radiative st
     *opping power'
              ELSE IF((iunrst(i).EQ.5)) THEN
                SERIES='unrestricted radiative stopping power'
              END IF
              CALL MEDXVGRPLOT(PLOTEEN,PLOTE,IPLOTE,0,SERIES, XAXIS,YAXI
     *        SE,GRAPHTITLE,SUBTITLE,i_outfile,2)
            END IF
            close(i_outfile)
7290        CONTINUE
          END IF
7261    CONTINUE
7262    CONTINUE
      END IF
      return
7040  write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a)') 'Error: Cannot open material data file',materia
     *l_file
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
7170  write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a)') 'Error: Cannot open density correction file: ',
     * density_file(:lnblnk1(density_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      SUBROUTINE MEDXVGRPLOT (X, Y, NPTS, CURVENUM, SERIESTITLE, XTITLE,
     * YTITLE, GRAPHTITLE, SUBTITLE, UNITNUM, AXISTYPE)
      IMPLICIT NONE
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 MAX
      PARAMETER (MAX = 400)
      integer*4 NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE
      real*8 X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,SMALLESTX, SMALLESTY,FUDGE
      integer*4 TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENG
     *TH
      integer*4 LOGX, LOGY
      CHARACTER*(*) SUBTITLE
      CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE
      logical TESTFILE, ALLPOS
      FUDGE = 1.e-10
      IF (( NPTS .gt. MAX)) THEN
        WRITE(6,7320)NPTS, MAX
7320    FORMAT(//' **************************'/ ' Number of points asked
     * for =', I5, ' is greater than max allowed of', I4/ ' Setting NPTS
     * to MAX, you could adjust MAX in xvgrplot.mortran'/ ' ************
     ***************'//)
        NPTS1 = MAX
      ELSE
        NPTS1 = NPTS
      END IF
      INQUIRE(UNIT = UNITNUM,OPENED=TESTFILE)
      IF ((.NOT.TESTFILE)) THEN
        WRITE(6,7330) UNITNUM
7330    FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------' ,/'
     *   Unit specified (',I2,') is not open.' ,/'   Unit must be opened
     * before using subroutine.' ,/'   Data not written to file.' ,/'  -
     *---------------------------------------------'//)
        RETURN
      END IF
      TITLELENGTH = 61
      SUBLENGTH = 61
      XAXISLENGTH = 61
      YAXISLENGTH = 61
      SERIESLENGTH = 61
7341  CONTINUE
        TITLELENGTH = TITLELENGTH - 1
        IF(((GRAPHTITLE(TITLELENGTH:TITLELENGTH) .NE. ' ')))GO TO7342
      GO TO 7341
7342  CONTINUE
7351  CONTINUE
        SUBLENGTH = SUBLENGTH - 1
        IF(((SUBTITLE(SUBLENGTH:SUBLENGTH) .NE. ' ')))GO TO7352
      GO TO 7351
7352  CONTINUE
7361  CONTINUE
        XAXISLENGTH = XAXISLENGTH - 1
        IF(((XTITLE(XAXISLENGTH:XAXISLENGTH) .NE. ' ')))GO TO7362
      GO TO 7361
7362  CONTINUE
7371  CONTINUE
        YAXISLENGTH = YAXISLENGTH - 1
        IF(((YTITLE(YAXISLENGTH:YAXISLENGTH) .NE. ' ')))GO TO7372
      GO TO 7371
7372  CONTINUE
7381  CONTINUE
        SERIESLENGTH = SERIESLENGTH - 1
        IF(((SERIESTITLE(SERIESLENGTH:SERIESLENGTH) .NE. ' ')))GO TO7382
      GO TO 7381
7382  CONTINUE
      LOGX = 0
      LOGY = 0
      ALLPOS=.TRUE.
      IF (( X(1).EQ.0.0 )) THEN
        SMALLESTX = 0.1
      ELSE
        SMALLESTX=X(1)
      END IF
      IF (( Y(1).EQ.0.0 )) THEN
        SMALLESTY = 0.1
      ELSE
        SMALLESTY=Y(1)
      END IF
      DO 7391 COUNT=1,NPTS1
        IF (((X(COUNT) .LT. SMALLESTX) .AND. (X(COUNT).NE.0.))) THEN
          SMALLESTX=X(COUNT)
        END IF
        IF (((Y(COUNT) .LT. SMALLESTY) .AND. (Y(COUNT).NE.0.))) THEN
          SMALLESTY=Y(COUNT)
        END IF
        IF (((X(COUNT) .LT. 0.).OR.(Y(COUNT) .LT. 0.))) THEN
          ALLPOS=.FALSE.
        END IF
7391  CONTINUE
7392  CONTINUE
      IF ((ALLPOS)) THEN
        DO 7401 COUNT=1,NPTS1
          IF ((X(COUNT).EQ.0.)) THEN
            X(COUNT)=SMALLESTX*FUDGE
          END IF
          IF ((Y(COUNT).EQ.0.)) THEN
            Y(COUNT)=SMALLESTY*FUDGE
          END IF
7401    CONTINUE
7402    CONTINUE
      END IF
      IF ((AXISTYPE .GT. 0)) THEN
        DO 7411 COUNT=1,NPTS1
          IF ((X(COUNT) .LE. 0.)) THEN
            LOGX = 1
          END IF
          IF ((Y(COUNT) .LE. 0.)) THEN
            LOGY = 1
          END IF
7411    CONTINUE
7412    CONTINUE
      END IF
      IF ((CURVENUM .EQ. 0)) THEN
        IF ((AXISTYPE .EQ. 0)) THEN
          WRITE(UNITNUM,7420) 'xy'
        ELSE IF((AXISTYPE .EQ. 1)) THEN
          WRITE(UNITNUM,7420) 'logy'
          WRITE(UNITNUM,7430)
        ELSE IF((AXISTYPE .EQ. 2)) THEN
          WRITE(UNITNUM,7420) 'logx'
          WRITE(UNITNUM,7430)
        ELSE IF((AXISTYPE .EQ. 3)) THEN
          WRITE(UNITNUM,7420) 'logxy'
          WRITE(UNITNUM,7430)
          WRITE(UNITNUM,7440)
        ELSE
          WRITE(6,7450) AXISTYPE
7450      FORMAT (//'  ------------Error in Subroutine XVGRPLOT---------
     *--' ,/'   AXISTYPE specified (',I2,') is not a valid option.' ,/' 
     *----------------------------------------------'//)
          RETURN
        END IF
7420    FORMAT ('@g0 type ',A,' ')
7430    FORMAT ('@    xaxis  ticklabel format exponential')
7440    FORMAT ('@    yaxis  ticklabel format exponential')
        WRITE(UNITNUM,7460) GRAPHTITLE(1:TITLELENGTH) ,SUBTITLE(1:SUBLEN
     *  GTH) ,XTITLE(1:XAXISLENGTH) ,YTITLE(1:YAXISLENGTH)
7460    FORMAT ('@    title "',A,'"'/ ,'@    subtitle "',A,'"'/ ,'@    l
     *egend on'/ ,'@    legend box linestyle 0'/ ,'@    legend x1 0.6'/,
     *'@    legend y1 0.75'/ ,'@    view xmin 0.250000'/ ,'@    xaxis  l
     *abel "',A,'"'/ ,'@    timestamp on'/ ,'@    yaxis  label "',A,'"')
      END IF
      IF ((AXISTYPE .EQ. 1 .AND. LOGY .EQ. 1)) THEN
        WRITE(UNITNUM,7420) 'xy'
        WRITE(6,7470)
7470    FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------',
     */'  Log scale requested for Y axis when one or more   ' ,/'  Ydata
     * points are 0 or negative.                  ' ,//'  Y axis scale c
     *hanged to linear.                   ' ,/' ------------------------
     *---------------------------'/)
      END IF
      IF ((AXISTYPE .EQ. 2 .AND. LOGX .EQ. 1)) THEN
        WRITE(UNITNUM,7420) 'xy'
        WRITE(6,7480)
7480    FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------',
     */'  Log scale requested for X axis when one or more   ' ,/'  Xdata
     * points are 0 or negative.                  ' ,//'  X axis scale c
     *hanged to linear.                   ' ,/' ------------------------
     *---------------------------'/)
      END IF
      IF ((AXISTYPE .EQ. 3 .AND. (LOGX .EQ. 1 .OR. LOGY .EQ. 1))) THEN
        IF ((LOGX .EQ. 1 .AND. LOGY .EQ. 1)) THEN
          WRITE(UNITNUM,7420) 'xy'
          WRITE(6,7490)
7490      FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------
     *' ,/'  Log scale requested for X axis and Y axis when    ' ,/'  on
     *e or more X and Y data points are 0 or negative.' ,//'  X and Y ax
     *es scales changed to linear.            ' ,/' --------------------
     *-------------------------------'/)
        ELSE IF((LOGX .EQ. 1)) THEN
          WRITE(UNITNUM,7420) 'logy'
          WRITE(6,7480)
        ELSE
          WRITE(UNITNUM,7420) 'logx'
          WRITE(6,7470)
        END IF
      END IF
      IF ((CURVENUM .LT. 10 )) THEN
        WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM
      ELSE
        WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM
      END IF
      WRITE(UNITNUM,7500) CURVENUM,SERIESTITLE(1:SERIESLENGTH)
7500  FORMAT ('@    legend string ',I2,' "',A,'"')
      WRITE(UNITNUM,7510)
7510  FORMAT ('@TYPE xy')
      IF ((CURVENUM .LT. 10)) THEN
        WRITE(UNITNUM,7520) CURVENUM
        IF ((CURVENUM .EQ. 9)) THEN
          WRITE(UNITNUM,7530) CURVENUM, CURVENUM+1
        ELSE
          WRITE(UNITNUM,7540) CURVENUM, CURVENUM+1
        END IF
      ELSE
        WRITE(UNITNUM,7550) CURVENUM
        WRITE(UNITNUM,7560) CURVENUM, CURVENUM+1
      END IF
7520  FORMAT ('@    s',I1,' errorbar length 0.000000')
7550  FORMAT ('@    s',I2,' errorbar length 0.000000')
7530  FORMAT ('@    s',I1,' symbol color ',I2)
7540  FORMAT ('@    s',I1,' symbol color ',I1)
7560  FORMAT ('@    s',I2,' symbol color ',I2)
      DO 7571 COUNT=1,NPTS1
        WRITE(UNITNUM,7580) X(COUNT),Y(COUNT)
7571  CONTINUE
7572  CONTINUE
7580  FORMAT (1PE15.4,1PE15.4)
      WRITE(UNITNUM,'(''&'')')
      RETURN
      END
      SUBROUTINE ZONEGRID(NRADIAL, NDEPTH, NRMIN, NZMIN, NZ, RESULTS, UN
     *CRT, NCOMP, RADIAL_BINS, DEPTH_BINS, LABELS, EXPLANATIONS)
      IMPLICIT NONE
      CHARACTER*1 TITLE(80)
      COMMON/IODAT1/TITLE
      integer*4 RADNUM, DEEPNUM, NRADIAL, NDEPTH, NCOMP, REGNUM, FMT, TM
     *P1
      logical SFIG
      logical ROT
      real*8 RESULTS(500,4,12), UNCRT(500,4,12), RADIAL_BINS(4),DEPTH_BI
     *NS( 501), TMP2,TMP3
      CHARACTER*60 EXPLANATIONS(12)
      CHARACTER*4 LABELS(12)
      integer*4 IOUT, ICOMP, IX, IZ, HSET, PGTHROW, DLYPT, COUNT,NZMIN,N
     *RMIN,NZ
      ROT=.FALSE.
      SFIG=.TRUE.
      IF ((NCOMP.GT.4)) THEN
        PGTHROW=20
      ELSE
        PGTHROW=17
      END IF
      IOUT=1
      RADNUM=NRADIAL
      DEEPNUM=NDEPTH
      COUNT = 0
      DO 7591 IX=1,RADNUM
        DO 7601 IZ=1,DEEPNUM
          DO 7611 ICOMP=1,NCOMP
            IF ((UNCRT(IZ, IX, ICOMP) .LT. 0.3)) THEN
              COUNT = COUNT + 1
            END IF
7611      CONTINUE
7612      CONTINUE
7601    CONTINUE
7602    CONTINUE
7591  CONTINUE
7592  CONTINUE
      IF ((COUNT/(RADNUM*DEEPNUM*NCOMP) .GT. 0.1)) THEN
        SFIG=.FALSE.
      END IF
      IF (((DEEPNUM.LE.3).AND.(RADNUM.GT.3))) THEN
        ROT=.TRUE.
        DO 7621 IX=1,RADNUM
          IF ((IX .LE. DEEPNUM+1)) THEN
            TMP3=RADIAL_BINS(IX)
            RADIAL_BINS(IX)=DEPTH_BINS(IX)
            DEPTH_BINS(IX)=TMP3
          ELSE
            DEPTH_BINS(IX)=RADIAL_BINS(IX)
          END IF
          IF ((IX .LE. DEEPNUM)) THEN
            DO 7631 IZ=IX+1,DEEPNUM
              DO 7641 ICOMP=1,NCOMP
                TMP2=RESULTS(IZ,IX,ICOMP)
                RESULTS(IZ,IX,ICOMP)=RESULTS(IX,IZ,ICOMP)
                RESULTS(IX,IZ,ICOMP)=TMP2
                TMP2=UNCRT(IZ,IX,ICOMP)
                UNCRT(IZ,IX,ICOMP)=UNCRT(IX,IZ,ICOMP)
                UNCRT(IX,IZ,ICOMP)=TMP2
7641          CONTINUE
7642          CONTINUE
7631        CONTINUE
7632        CONTINUE
          ELSE
            DO 7651 IZ=1,DEEPNUM
              DO 7661 ICOMP=1,NCOMP
                RESULTS(IX,IZ,ICOMP)=RESULTS(IZ,IX,ICOMP)
                UNCRT(IX,IZ,ICOMP)=UNCRT(IZ,IX,ICOMP)
7661          CONTINUE
7662          CONTINUE
7651        CONTINUE
7652        CONTINUE
          END IF
7621    CONTINUE
7622    CONTINUE
        DEPTH_BINS(RADNUM+1)=RADIAL_BINS(RADNUM+1)
        TMP1=RADNUM
        RADNUM=DEEPNUM
        DEEPNUM=TMP1
      END IF
      WRITE (IOUT, *) '\f'
      WRITE(IOUT, 400) ' '
      call egs_fdate(iout)
      write(iout,'(//)')
      IF ((ROT)) THEN
        WRITE(IOUT, 93) TITLE
      ELSE
        WRITE(IOUT, 94) TITLE
      END IF
      DO 7671 ICOMP=1,NCOMP
        WRITE(IOUT, 95) LABELS(ICOMP), EXPLANATIONS(ICOMP)
7671  CONTINUE
7672  CONTINUE
      DO 7681 HSET=1,RADNUM,3
        IF ((RADNUM-HSET.GT.1)) THEN
          FMT=3
        ELSE
          IF ((MOD(RADNUM,3) .EQ. 1)) THEN
            FMT=1
          END IF
          IF ((MOD(RADNUM,3) .EQ. 2)) THEN
            FMT=2
          END IF
        END IF
        WRITE (IOUT, 91) (RADIAL_BINS(IX),IX=HSET,HSET+FMT)
        PGTHROW=PGTHROW+1
        DO 7691 IZ=1,DEEPNUM
          IF ((ROT)) THEN
            REGNUM= (IZ+NRMIN-1)*NZ + HSET+NZMIN
          ELSE
            REGNUM= (HSET+NRMIN-1)*NZ + IZ+NZMIN
          END IF
          IF ((FMT.EQ.1)) THEN
            WRITE (IOUT, 10) DEPTH_BINS(IZ)
            IF ((SFIG)) THEN
              IF ((ROT)) THEN
                WRITE (IOUT, 15) REGNUM,HSET+NZMIN-1,IZ+NRMIN
              ELSE
                WRITE (IOUT, 15) REGNUM,IZ+NZMIN-1,HSET+NRMIN
              END IF
            ELSE
              IF ((ROT)) THEN
                WRITE (IOUT, 18) REGNUM,HSET+NZMIN-1,IZ+NRMIN
              ELSE
                WRITE (IOUT, 18) REGNUM,IZ+NZMIN-1,HSET+NRMIN
              END IF
            END IF
          END IF
          IF ((FMT.EQ.2)) THEN
            WRITE (IOUT, 11) DEPTH_BINS(IZ)
            IF ((SFIG)) THEN
              IF ((ROT)) THEN
                WRITE(IOUT,14) REGNUM,HSET+NZMIN-1,IZ+NRMIN, REGNUM+1,HS
     *          ET+NZMIN,IZ+NRMIN
              ELSE
                WRITE(IOUT,14) REGNUM,IZ+NZMIN-1,HSET+NRMIN, REGNUM+NZ,I
     *          Z+NZMIN-1,HSET+NRMIN+1
              END IF
            ELSE
              IF ((ROT)) THEN
                WRITE(IOUT,17) REGNUM,HSET+NZMIN-1,IZ+NRMIN, REGNUM+1,HS
     *          ET+NZMIN, IZ+NRMIN
              ELSE
                WRITE(IOUT,17) REGNUM,IZ+NZMIN-1,HSET+NRMIN, REGNUM+NZ,I
     *          Z+NZMIN-1,HSET+NRMIN+1
              END IF
            END IF
          END IF
          IF ((FMT.EQ.3)) THEN
            WRITE (IOUT, 12) DEPTH_BINS(IZ)
            IF ((SFIG)) THEN
              IF ((ROT)) THEN
                WRITE (IOUT,13)REGNUM,HSET+NZMIN-1,IZ+NRMIN, REGNUM+1,HS
     *          ET+NZMIN,IZ+NRMIN, REGNUM+2,HSET+NZMIN+1,IZ+NRMIN
              ELSE
                WRITE (IOUT, 13) REGNUM,IZ+NZMIN-1,HSET+NRMIN, REGNUM+NZ
     *          ,IZ+NZMIN-1,HSET+NRMIN+1, REGNUM+NZ*2,IZ+NZMIN-1,HSET+NR
     *          MIN+2
              END IF
            ELSE
              IF ((ROT)) THEN
                WRITE (IOUT,16)REGNUM,HSET+NZMIN-1,IZ+NRMIN, REGNUM+1,HS
     *          ET+NZMIN,IZ+NRMIN, REGNUM+2,HSET+NZMIN+1,IZ+NRMIN
              ELSE
                WRITE (IOUT, 16)REGNUM,IZ+NZMIN-1,HSET+NRMIN, REGNUM+NZ,
     *          IZ+NZMIN-1,HSET+NRMIN+1, REGNUM+NZ*2,IZ+NZMIN-1,HSET+NRM
     *          IN+2
              END IF
            END IF
          END IF
          PGTHROW=PGTHROW+2
          DO 7701 ICOMP=1,NCOMP
            IF ((SFIG)) THEN
              IF ((FMT.EQ.3)) THEN
                WRITE(IOUT, 3) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP), UNC
     *          RT(IZ,HSET,ICOMP),LABELS(ICOMP), RESULTS(IZ,HSET+1,ICOMP
     *          ),UNCRT(IZ,HSET+1,ICOMP), LABELS(ICOMP),RESULTS(IZ,HSET+
     *          2,ICOMP), UNCRT(IZ,HSET+2,ICOMP)
              END IF
              IF ((FMT.EQ.2)) THEN
                WRITE(IOUT, 2) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP), UNC
     *          RT(IZ,HSET,ICOMP),LABELS(ICOMP), RESULTS(IZ,HSET+1,ICOMP
     *          ),UNCRT(IZ,HSET+1,ICOMP)
              END IF
              IF ((FMT.EQ.1)) THEN
                WRITE(IOUT, 1) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP), UNC
     *          RT(IZ,HSET,ICOMP)
              END IF
            ELSE
              IF ((FMT.EQ.3)) THEN
                WRITE(IOUT, 6) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP), UNC
     *          RT(IZ,HSET,ICOMP),LABELS(ICOMP), RESULTS(IZ,HSET+1,ICOMP
     *          ),UNCRT(IZ,HSET+1,ICOMP), LABELS(ICOMP),RESULTS(IZ,HSET+
     *          2,ICOMP), UNCRT(IZ,HSET+2,ICOMP)
              END IF
              IF ((FMT.EQ.2)) THEN
                WRITE(IOUT, 5) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP), UNC
     *          RT(IZ,HSET,ICOMP),LABELS(ICOMP), RESULTS(IZ,HSET+1,ICOMP
     *          ),UNCRT(IZ,HSET+1,ICOMP)
              END IF
              IF ((FMT.EQ.1)) THEN
                WRITE(IOUT, 4) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP), UNC
     *          RT(IZ,HSET,ICOMP)
              END IF
            END IF
            PGTHROW=PGTHROW+1
7701      CONTINUE
7702      CONTINUE
          IF ((MOD(PGTHROW,65).GT.(61-NCOMP))) THEN
            IF ((IZ.NE.DEEPNUM)) THEN
              IF ((FMT.EQ.1)) THEN
                WRITE (IOUT, 10) DEPTH_BINS(IZ+1)
              END IF
              IF ((FMT.EQ.2)) THEN
                WRITE (IOUT, 11) DEPTH_BINS(IZ+1)
              END IF
              IF ((FMT.EQ.3)) THEN
                WRITE (IOUT, 12) DEPTH_BINS(IZ+1)
              END IF
              WRITE (IOUT, *) '\f'
              PGTHROW=10
              WRITE(IOUT, 400) ' '
              call egs_fdate(iout)
              write(iout,'(//)')
              IF ((ROT)) THEN
                WRITE(IOUT, 93) TITLE
              ELSE
                WRITE(IOUT, 94) TITLE
              END IF
              WRITE (IOUT, 91) (RADIAL_BINS(IX),IX=HSET,HSET+FMT)
            ELSE
              DLYPT = HSET
            END IF
          END IF
7691    CONTINUE
7692    CONTINUE
        IF ((FMT.EQ.1)) THEN
          WRITE (IOUT, 10) DEPTH_BINS(DEEPNUM+1)
        END IF
        IF ((FMT.EQ.2)) THEN
          WRITE (IOUT, 11) DEPTH_BINS(DEEPNUM+1)
        END IF
        IF ((FMT.EQ.3)) THEN
          WRITE (IOUT, 12) DEPTH_BINS(DEEPNUM+1)
        END IF
        IF (((DLYPT.EQ.HSET).AND.(RADNUM-HSET.GT.2))) THEN
          WRITE (IOUT, *) '\f'
          PGTHROW=10
          WRITE(IOUT, 400) ' '
          call egs_fdate(iout)
          write(iout,'(//)')
          IF ((ROT)) THEN
            WRITE(IOUT, 93) TITLE
          ELSE
            WRITE(IOUT, 94) TITLE
          END IF
        END IF
        PGTHROW=PGTHROW+1
7681  CONTINUE
7682  CONTINUE
1     FORMAT (T11, '|', A4, 1PE10.3, '+-', 0PF4.1, '%', '|')
2     FORMAT (T11, '|', 1 (A4, 1PE10.3, '+-', 0PF4.1, '%', ' |'), A4, 1P
     *E10.3, '+-', 0PF4.1, '%', '|')
3     FORMAT (T11, '|', 2 (A4, 1PE10.3, '+-', 0PF4.1, '%', ' |'), A4, 1P
     *E10.3, '+-', 0PF4.1, '%', '|')
4     FORMAT (T11, '|', A4, 1PE10.3, '+-', 0PF5.2, '%', '|')
5     FORMAT (T11, '|', 1 (A4, 1PE10.3, '+-', 0PF5.2, '%', ' |'), A4, 1P
     *E10.3, '+-', 0PF5.2, '%', '|')
6     FORMAT (T10, '|', 2 (A4, 1PE10.3, '+-', 0PF5.2, '%', '|'), A4, 1PE
     *10.3, '+-', 0PF5.2, '%', '|')
10    FORMAT (1X, F9.4, T11, 1 (23 ('-')))
11    FORMAT (1X, F9.4, T11, 2 (23 ('-')))
12    FORMAT (1X, F9.4, T11, 3 (23 ('-')))
13    FORMAT (T11, '|', 2 ('IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |'), 'I
     *RL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'|')
14    FORMAT (T11, '|', 'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |', 'IRL',
     *I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'|')
15    FORMAT (T11, '|', 'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'|')
16    FORMAT (T10, '|', 2 ('IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |'), 'I
     *RL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |')
17    FORMAT (T11, '|', 1 ('IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'  |'), '
     *IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |')
18    FORMAT (T11, '|', 'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |')
91    FORMAT (/ T7,F9.4,T30,F9.4,T53,F9.4,T70,F9.4)
93    FORMAT (' ',79A1 // T19, 27H ZONAL OUTPUT GRID: ROTATED / T20, '**
     *************************')
94    FORMAT (' ',79A1 // T19, 31H ZONAL OUTPUT GRID: NON-ROTATED / T20,
     *'******************************')
95    FORMAT (T14, A4, T19, A60)
400   FORMAT (T54,a1,$)
      RETURN
      END
      SUBROUTINE MATERIALGRID(NRADIAL, NDEPTH, MASSVOL, MORV, ECUTS, PCU
     *TS, RCYL, ZPLANE, MED, MEDIA, CDSTBL, CTRTBL, CABSRB)
      IMPLICIT NONE
      CHARACTER*1 TITLE(80)
      COMMON/IODAT1/TITLE
      integer*4 RADNUM, DEEPNUM, NRADIAL, NDEPTH, NCOMP, REGNUM, FMT, TM
     *P1
      logical ESTEPSON, ECUTON, PCUTON, ROT
      real*8 VALUES(500,4,12), RCYL(4),ZPLANE(500), RADIAL_BINS(500),DEP
     *TH_BINS(500), MASSVOL(500,4), ECUTS( 2001), PCUTS( 2001), TMP2(500
     *,4,12),TMP3(500),CHINDEX(500)
      CHARACTER*60 EXPLANATIONS(12)
      CHARACTER*4 LABELS(12)
      CHARACTER*4 MED_NAME1(11),MED_NAME2(11),MED_NAME3(11)
      CHARACTER*4 MEDIA(24, 6)
      CHARACTER*4 CDSTBL( 2001), CTRTBL( 2001),CABSRB( 2001)
      integer*2 MED( 2001)
      integer*4 MNUM1, MNUM2, MNUM3, MORV
      integer*4 IOUT, ICOMP, IZ, IX, IRL, HSET, PGTHROW, DLYPT, J, COUNT
      ROT=.FALSE.
      ESTEPSON=.FALSE.
      ECUTON=.FALSE.
      PCUTON=.FALSE.
      NCOMP=1
      PGTHROW=14+NCOMP
      IOUT=1
      DEEPNUM=NDEPTH
      RADNUM=NRADIAL
      IF ((RCYL(1).EQ.0.)) THEN
        DO 7711 IX=1,RADNUM+1
          RADIAL_BINS(IX)=RCYL(IX)
7711    CONTINUE
7712    CONTINUE
      ELSE
        DO 7721 IX=1,RADNUM+1
          RADIAL_BINS(IX+1)=RCYL(IX)
7721    CONTINUE
7722    CONTINUE
      END IF
      DO 7731 IZ=1,DEEPNUM+1
        DEPTH_BINS(IZ)=ZPLANE(IZ)
7731  CONTINUE
7732  CONTINUE
      IF ((MORV.EQ.1)) THEN
        LABELS(NCOMP)='MASS'
        EXPLANATIONS(NCOMP)='MASS OF EACH REGION IN GRAMS'
      END IF
      IF ((MORV.EQ.2)) THEN
        LABELS(NCOMP)='VOL '
        EXPLANATIONS(NCOMP)='VOLUME OF EACH REGION IN cm^3'
      END IF
      DO 7741 IX=1,RADNUM
        DO 7751 IZ=1,DEEPNUM
          VALUES(IZ, IX, NCOMP)=MASSVOL(IZ, IX)
          IRL=IZ+DEEPNUM*(IX-1)+1
          IF ((CDSTBL(1).EQ.'0')) THEN
            CDSTBL(IRL)=' '
          END IF
          IF ((CTRTBL(1).EQ.'0')) THEN
            CTRTBL(IRL)=' '
          END IF
          IF ((CABSRB(1).EQ.'0')) THEN
            CABSRB(IRL)=' '
          END IF
          IF ((ECUTS(IRL).NE.ECUTS(2))) THEN
            ECUTON=.TRUE.
          END IF
          IF ((PCUTS(IRL).NE.PCUTS(2))) THEN
            PCUTON=.TRUE.
          END IF
7751    CONTINUE
7752    CONTINUE
7741  CONTINUE
7742  CONTINUE
      IF ((ECUTON)) THEN
        NCOMP=NCOMP+1
        LABELS(NCOMP)='ECUT'
        EXPLANATIONS(NCOMP)='ECUT (PRINTED BECAUSE DIFFERENT FROM GLOBAL
     *)'
        DO 7761 IX=1,RADNUM
          DO 7771 IZ=1,DEEPNUM
            IRL=IZ+DEEPNUM*(IX-1)+1
            VALUES(IZ, IX, NCOMP)=ECUTS(IRL)
7771      CONTINUE
7772      CONTINUE
7761    CONTINUE
7762    CONTINUE
      END IF
      IF ((PCUTON)) THEN
        NCOMP=NCOMP+1
        LABELS(NCOMP)='PCUT'
        EXPLANATIONS(NCOMP)='PCUT (PRINTED BECAUSE DIFFERENT FROM GLOBAL
     *)'
        DO 7781 IX=1,RADNUM
          DO 7791 IZ=1,DEEPNUM
            IRL=IZ+DEEPNUM*(IX-1)+1
            VALUES(IZ, IX, NCOMP)=PCUTS(IRL)
7791      CONTINUE
7792      CONTINUE
7781    CONTINUE
7782    CONTINUE
      END IF
      PGTHROW=14+NCOMP
      IF (((DEEPNUM.LE.3).AND.(RADNUM.GT.3))) THEN
        ROT=.TRUE.
        CHINDEX(RADNUM+1)=RADIAL_BINS(RADNUM+1)
        DO 7801 IX=1,RADNUM
          TMP3(IX)=DEPTH_BINS(IX)
          CHINDEX(IX)=RADIAL_BINS(IX)
          DEPTH_BINS(IX)=CHINDEX(IX)
          RADIAL_BINS(IX)=TMP3(IX)
          DO 7811 IZ=1,DEEPNUM
            DO 7821 ICOMP=1,NCOMP
              TMP2(IZ, IX, ICOMP)=VALUES(IZ, IX, ICOMP)
7821        CONTINUE
7822        CONTINUE
7811      CONTINUE
7812      CONTINUE
7801    CONTINUE
7802    CONTINUE
        DO 7831 IX=1,RADNUM
          DO 7841 IZ=1,DEEPNUM
            DO 7851 ICOMP=1,NCOMP
              VALUES(IX, IZ, ICOMP)=TMP2(IZ, IX, ICOMP)
7851        CONTINUE
7852        CONTINUE
7841      CONTINUE
7842      CONTINUE
7831    CONTINUE
7832    CONTINUE
        DEPTH_BINS(RADNUM+1)=CHINDEX(RADNUM+1)
        TMP1=RADNUM
        RADNUM=DEEPNUM
        DEEPNUM=TMP1
      END IF
      WRITE (IOUT, *) '\f'
      WRITE(IOUT, 400) ' '
      call egs_fdate(iout)
      write(iout,'(//)')
      IF ((ROT)) THEN
        WRITE(IOUT, 93) TITLE
      ELSE
        WRITE(IOUT, 94) TITLE
      END IF
      WRITE(IOUT, 95) (LABELS(ICOMP),EXPLANATIONS(ICOMP), ICOMP=1, NCOMP
     *)
      DO 7861 HSET=1,RADNUM,3
        IF ((RADNUM-HSET.GT.1)) THEN
          FMT=3
        ELSE
          IF ((MOD(RADNUM,3) .EQ. 1)) THEN
            FMT=1
          END IF
          IF ((MOD(RADNUM,3) .EQ. 2)) THEN
            FMT=2
          END IF
        END IF
        WRITE (IOUT, 91) (RADIAL_BINS(IX),IX=HSET,HSET+FMT)
        PGTHROW=PGTHROW+1
        DO 7871 IZ=1,DEEPNUM
          IF ((ROT)) THEN
            REGNUM=2+(IZ-1)*FMT+(HSET-1)*RADNUM
          ELSE
            REGNUM=( IZ+1+((HSET-1)*DEEPNUM) )
          END IF
          IF ((ROT)) THEN
            MNUM1=MED(REGNUM)
            MNUM2=MED(REGNUM+1)
            MNUM3=MED(REGNUM+2)
          ELSE
            MNUM1=MED(REGNUM)
            MNUM2=MED(REGNUM+DEEPNUM)
            MNUM3=MED(REGNUM+DEEPNUM*2)
          END IF
          IF ((MNUM1.EQ.0)) THEN
            MED_NAME1(1)='V'
            MED_NAME1(2)='A'
            MED_NAME1(3)='C'
            MED_NAME1(4)='U'
            MED_NAME1(5)='U'
            MED_NAME1(6)='M'
            DO 7881 J=7,11
              MED_NAME1(J)=' '
7881        CONTINUE
7882        CONTINUE
          ELSE
            DO 7891 COUNT=1,11
              MED_NAME1(COUNT) = MEDIA(COUNT, MNUM1)
7891        CONTINUE
7892        CONTINUE
          END IF
          IF ((MNUM2.EQ.0)) THEN
            MED_NAME2(1)='V'
            MED_NAME2(2)='A'
            MED_NAME2(3)='C'
            MED_NAME2(4)='U'
            MED_NAME2(5)='U'
            MED_NAME2(6)='M'
            DO 7901 J=7,11
              MED_NAME2(J)=' '
7901        CONTINUE
7902        CONTINUE
          ELSE
            DO 7911 COUNT=1,11
              MED_NAME2(COUNT) = MEDIA(COUNT,MNUM2)
7911        CONTINUE
7912        CONTINUE
          END IF
          IF ((MNUM3.EQ.0)) THEN
            MED_NAME3(1)='V'
            MED_NAME3(2)='A'
            MED_NAME3(3)='C'
            MED_NAME3(4)='U'
            MED_NAME3(5)='U'
            MED_NAME3(6)='M'
            DO 7921 J=7,11
              MED_NAME3(J)=' '
7921        CONTINUE
7922        CONTINUE
          ELSE
            DO 7931 COUNT=1,11
              MED_NAME3(COUNT) = MEDIA(COUNT,MNUM3)
7931        CONTINUE
7932        CONTINUE
          END IF
          IF ((FMT.EQ.1)) THEN
            WRITE (IOUT, 10) DEPTH_BINS(IZ)
            IF ((ROT)) THEN
              WRITE (IOUT, 15) REGNUM,HSET,IZ
            ELSE
              WRITE (IOUT, 15) REGNUM,IZ,HSET
            END IF
            WRITE (IOUT, 4) CDSTBL(REGNUM),CTRTBL(REGNUM), CABSRB(REGNUM
     *      ), (MED_NAME1(J),J=1,11)
          END IF
          IF ((FMT.EQ.2)) THEN
            WRITE (IOUT, 11) DEPTH_BINS(IZ)
            IF ((ROT)) THEN
              WRITE(IOUT,14) REGNUM,HSET,IZ, REGNUM+1,HSET+1,IZ
              WRITE(IOUT, 5) CDSTBL(REGNUM),CTRTBL(REGNUM), CABSRB(REGNU
     *        M), (MED_NAME1(J),J=1,11), CDSTBL(REGNUM+1),CTRTBL(REGNUM+
     *        1), CABSRB(REGNUM+1), (MED_NAME2(J),J=1,11)
            ELSE
              WRITE(IOUT,14) REGNUM,IZ,HSET, REGNUM+DEEPNUM,IZ,HSET+1
              WRITE(IOUT, 5) CDSTBL(REGNUM),CTRTBL(REGNUM), CABSRB(REGNU
     *        M), (MED_NAME1(J),J=1,11), CDSTBL(REGNUM+DEEPNUM),CTRTBL(R
     *        EGNUM+DEEPNUM), CABSRB(REGNUM+DEEPNUM),(MED_NAME2(J),J=1,1
     *        1)
            END IF
          END IF
          IF ((FMT.EQ.3)) THEN
            WRITE (IOUT, 12) DEPTH_BINS(IZ)
            IF ((ROT)) THEN
              WRITE (IOUT, 13) REGNUM,HSET,IZ,REGNUM+1, HSET+1,IZ,REGNUM
     *        +2,HSET+2,IZ
              WRITE (IOUT, 6) CDSTBL(REGNUM),CTRTBL(REGNUM), CABSRB(REGN
     *        UM), (MED_NAME1(J),J=1,11), CDSTBL(REGNUM+1),CTRTBL(REGNUM
     *        +1), CABSRB(REGNUM+1), (MED_NAME2(J),J=1,11), CDSTBL(REGNU
     *        M+2),CTRTBL(REGNUM+2), CABSRB(REGNUM+2), (MED_NAME3(J),J=1
     *        ,11)
            ELSE
              WRITE (IOUT, 13) REGNUM,IZ,HSET,REGNUM+DEEPNUM, IZ,HSET+1,
     *        REGNUM+DEEPNUM*2,IZ,HSET+2
              WRITE (IOUT, 6) CDSTBL(REGNUM),CTRTBL(REGNUM), CABSRB(REGN
     *        UM), (MED_NAME1(J),J=1,11), CDSTBL(REGNUM+DEEPNUM),CTRTBL(
     *        REGNUM+DEEPNUM), CABSRB(REGNUM+DEEPNUM), (MED_NAME2(J),J=1
     *        ,11), CDSTBL(REGNUM+DEEPNUM*2),CTRTBL(REGNUM+DEEPNUM*2), C
     *        ABSRB(REGNUM+DEEPNUM*2), (MED_NAME3(J),J=1,11)
            END IF
          END IF
          PGTHROW=PGTHROW+3
          DO 7941 ICOMP=1,NCOMP
            IF ((FMT.EQ.3)) THEN
              WRITE(IOUT, 3) LABELS(ICOMP),VALUES(IZ,HSET,ICOMP), LABELS
     *        (ICOMP),VALUES(IZ,HSET+1,ICOMP), LABELS(ICOMP),VALUES(IZ,H
     *        SET+2,ICOMP)
            END IF
            IF ((FMT.EQ.2)) THEN
              WRITE(IOUT, 2) LABELS(ICOMP),VALUES(IZ,HSET,ICOMP), LABELS
     *        (ICOMP),VALUES(IZ,HSET+1,ICOMP)
            END IF
            IF ((FMT.EQ.1)) THEN
              WRITE(IOUT, 1) LABELS(ICOMP),VALUES(IZ,HSET,ICOMP)
            END IF
            PGTHROW=PGTHROW+1
7941      CONTINUE
7942      CONTINUE
          IF ((MOD(PGTHROW,65).GT.(60-NCOMP))) THEN
            IF ((IZ.NE.DEEPNUM)) THEN
              IF ((FMT.EQ.1)) THEN
                WRITE (IOUT, 10) DEPTH_BINS(IZ+1)
              END IF
              IF ((FMT.EQ.2)) THEN
                WRITE (IOUT, 11) DEPTH_BINS(IZ+1)
              END IF
              IF ((FMT.EQ.3)) THEN
                WRITE (IOUT, 12) DEPTH_BINS(IZ+1)
              END IF
              WRITE (IOUT, *) '\f'
              PGTHROW=15
              WRITE(IOUT, 400) ' '
              call egs_fdate(iout)
              write(iout,'(//)')
              IF ((ROT)) THEN
                WRITE(IOUT, 93) TITLE
              ELSE
                WRITE(IOUT, 94) TITLE
              END IF
              WRITE (IOUT, 91) (RADIAL_BINS(IX),IX=HSET,HSET+FMT)
            ELSE
              DLYPT = HSET
            END IF
          END IF
7871    CONTINUE
7872    CONTINUE
        IF ((FMT.EQ.1)) THEN
          WRITE (IOUT, 10) DEPTH_BINS(DEEPNUM+1)
        END IF
        IF ((FMT.EQ.2)) THEN
          WRITE (IOUT, 11) DEPTH_BINS(DEEPNUM+1)
        END IF
        IF ((FMT.EQ.3)) THEN
          WRITE (IOUT, 12) DEPTH_BINS(DEEPNUM+1)
        END IF
        IF (((DLYPT.EQ.HSET).AND.(RADNUM-HSET.GT.2))) THEN
          WRITE (IOUT, *) '\f'
          PGTHROW=17
          WRITE(IOUT, 400) ' '
          call egs_fdate(iout)
          write(iout,'(//)')
          IF ((ROT)) THEN
            WRITE(IOUT, 93) TITLE
          ELSE
            WRITE(IOUT, 94) TITLE
          END IF
        END IF
        PGTHROW=PGTHROW+1
7861  CONTINUE
7862  CONTINUE
1     FORMAT (T11, '|', 2X, A4, 2X, 1PE10.3, 2X, ' |')
2     FORMAT (T11, '|', 2 (2X, A4, 2X, 1PE10.3, 2X, ' |'))
3     FORMAT (T11, '|', 3 (2X, A4, 2X, 1PE10.3, 2X, ' |'))
4     FORMAT (T11, '|', 1X, '/', 3 (A1, '/'), 11A1, '  |')
5     FORMAT (T11, '|', 2 (1X, '/', 3 (A1, '/'), 11A1, '  |'))
6     FORMAT (T11, '|', 3 (1X, '/', 3 (A1, '/'), 11A1, '  |'))
10    FORMAT (1X, F9.4, T11, 23 ('-'))
11    FORMAT (1X, F9.4, T11, 45 ('-'))
12    FORMAT (1X, F9.4, T11, 67 ('-'))
13    FORMAT (T11, '|', 3 ('IRL', I3, 1X, 'IZ ', I3, 1X, 'IX ', I3, 1X,'
     *|'))
14    FORMAT (T11, '|', 2 ('IRL', I3, 1X, 'IZ ', I3, 1X, 'IX ', I3, 1X,'
     *|'))
15    FORMAT (T11, '|', 'IRL', I3, 1X, 'IZ ', I3, 1X, 'IX ', I3, 1X, '|'
     *)
91    FORMAT (/ T7, F9.4, T30, F9.4, T53, F9.4, T70, F9.4)
93    FORMAT (' ',79A1 // T19, 29H ZONAL MATERIAL GRID: ROTATED / T21, '
     ***************************'/, /T4 , '/X/Y/Z/MED :  X = " " IS DEFA
     *ULT: OPTION NOT USED'/, T18, '  = "D" IF DOSE SCORING REGION'/, T1
     *8, 'X = "C" IF CAVITY REGION'/, T18, 'X = "S" IF SPR SCORING REGIO
     *N'/, T18, 'Y = "T" IF TRACKING REGION'/, T18, 'Z = "A" IF TOTALLYA
     *BSORBING REGION'/, T16, 'MED = MEDIUM NAME, 11 CHARACTER ABREVIATI
     *ON')
94    FORMAT (' ',79A1 // T19, 33H ZONAL MATERIAL GRID: NON-ROTATED / T2
     *1, '******************************'/ /T4 , '/X/Y/Z/MED :  X = " "I
     *S DEFAULT: OPTION NOT USED'/, T18, '  = "D" IF DOSE SCORING REGION
     *'/, T18, '  = "C" IF CAVITY REGION'/, T18, '  = "S" IF SPR SCORING
     * REGION'/, T18, 'Y = "T" IF TRACKING REGION'/, T18, 'Z = "A" IF TO
     *TALLY ABSORBING REGION'/, T16, 'MED = MEDIUM NAME, 11 CHARACTER AB
     *REVIATION')
95    FORMAT (T10, A4, ' = ', A60)
400   FORMAT (/T54,a1,$)
      RETURN
      END
      SUBROUTINE WATCH(IARG,IWATCH)
      implicit none
      integer*4 iarg,iwatch,IP,ICOUNT,JHSTRY,J,N
      real*8 KE
      integer*4 graph_unit
      integer egs_open_file
      integer*4 ku,kr,ka
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DATA ICOUNT/0/,JHSTRY/1/ graph_unit/-1/
      save ICOUNT,JHSTRY,graph_unit
      ku = 13
      kr = 0
      ka = 1
      IF ((IARG .EQ. -99)) THEN
        DO 7951 J=1,29
          IAUSFL(J)=1
7951    CONTINUE
7952    CONTINUE
        IAUSFL(22)=0
        IAUSFL(23)=0
        IAUSFL(24)=0
      END IF
      IF ((IARG .EQ. -1)) THEN
        IF ((IWATCH .EQ. 4)) THEN
          IF (( graph_unit .LT. 0 )) THEN
            graph_unit = egs_open_file(ku,kr,ka,'.egsgph')
          END IF
          WRITE(graph_unit,7960) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY
          JHSTRY=JHSTRY+1
        ELSE
          WRITE(6,7970)JHSTRY
7970      FORMAT(' END OF HISTORY',I8,3X,40('*')/)
          JHSTRY=JHSTRY+1
          ICOUNT=ICOUNT+2
          RETURN
        END IF
      END IF
      IF (( (IWATCH .NE. 4) .AND. ((ICOUNT .GE. 50) .OR. (ICOUNT .EQ. 0)
     * .OR. (IARG .EQ. -99)) )) THEN
        ICOUNT=1
        WRITE(6,7980)
7980    FORMAT(//T39,' NP',3X,'ENERGY  Q REGION    X',7X, 'Y',7X,'Z',6X,
     *'U',6X,'V',6X,'W',6X,'LATCH',2X,'WEIGHT'/)
      END IF
      IF (((IWATCH .EQ. 4) .AND. (IARG .GE. 0) .AND. (IARG .NE. 5))) THE
     *N
        IF((graph_unit .LT. 0))graph_unit = egs_open_file(ku,kr,ka,'.egs
     *gph')
        WRITE(graph_unit,7960) NP,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),E(NP)
7960    FORMAT(2I4,1X,I6,4G15.8,I12)
      END IF
      IF((IARG .EQ. 5 .OR. IARG .LT. 0))RETURN
      IF((IWATCH .EQ. 4))RETURN
      KE=E(NP)
      IF ((IQ(NP).NE.0)) THEN
        KE=E(NP)-PRM
      END IF
      IF ((IARG .EQ. 0 .AND. IWATCH .EQ. 2)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,7990)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
7990    FORMAT(T11,'STEP ABOUT TO OCCUR', T36,':',I5,F9.3,2I4,3F8.3,3F7.
     *3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 0)) THEN
        RETURN
      END IF
      IF (( IARG .EQ. 1)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8000)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8000    FORMAT(' Discard  AE,AP<E<ECUT',T36,':',I5,F9.3,2I4,3F8.3,3F7.3,
     *I10,1PE10.3)
      ELSE IF((IARG .EQ. 2)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8010)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8010    FORMAT(' Discard  E<AE,AP',T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1
     *PE10.3)
      ELSE IF((IARG .EQ. 3)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8020)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8020    FORMAT(' Discard -user request',T36,':',I5,F9.3,2I4,3F8.3,3F7.3,
     *I10,1PE10.3)
      ELSE IF((IARG .EQ. 4)) THEN
        WRITE(6,8030)EDEP,IR(NP)
8030    FORMAT(T10,'Local energy deposition',T36,':',F12.5,' MeV in regi
     *on ',I6)
      ELSE IF((IARG .EQ. 6)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8040)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8040    FORMAT(' bremsstrahlung  about to occur',T36,':',I5,F9.3,2I4,3F8
     *.3,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 7)) THEN
        IF ((nbr_split .EQ.1)) THEN
          DO 8051 IP=NPold,NP
            IF ((IQ(IP).EQ.-1)) THEN
              KE = E(IP) - RM
              ICOUNT=ICOUNT+1
              WRITE(6,8060)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8060          FORMAT(T10,'Resulting electron',T36,':',I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
            ELSE
              KE = E(IP)
              ICOUNT=ICOUNT+1
              WRITE(6,8070)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8070          FORMAT(T10,'Resulting photon',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
            END IF
8051      CONTINUE
8052      CONTINUE
        ELSE
          KE = E(NPold) - RM
          ICOUNT=ICOUNT+1
          WRITE(6,8080)NPold,KE,IQ(NPold),IR(NPold),X(NPold),Y(NPold),Z(
     *    NPold),U(NPold),V(NPold), W(NPold),LATCH(NPold),WT(NPold)
8080      FORMAT(T10,'Resulting electron',T36,':',I5,F9.3,2I4,3F8.3,3F7.
     *3,I10,1PE10.3)
          DO 8091 IP=NPold+1,NP
            KE= E(IP)
            IF ((IP .EQ. NPold+1)) THEN
              ICOUNT=ICOUNT+1
              WRITE(6,8100)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8100          FORMAT(T10,'Split photons',T36,':',I5,F9.3,2I4,3F8.3,3F7.3
     *,I10,1PE10.3)
            ELSE
              ICOUNT=ICOUNT+1
              WRITE(6,8110)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8110          FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
            END IF
8091      CONTINUE
8092      CONTINUE
        END IF
      ELSE IF((IARG .EQ. 8)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8120)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8120    FORMAT(' Moller   about to occur',T36,':',I5,F9.3,2I4,3F8.3,3F7.
     *3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 9)) THEN
        IF ((NP.EQ.NPold)) THEN
          ICOUNT=ICOUNT+1
          WRITE(6,8130)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8130      FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
        ELSE
          DO 8141 IP=NPold,NP
            KE = E(IP) - ABS(IQ(NP))*RM
            IF ((IP.EQ.NPold)) THEN
              ICOUNT=ICOUNT+1
              WRITE(6,8150)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8150          FORMAT(T11,'Resulting electrons',T36,':',I5,F9.3,2I4,3F8.3
     *,3F7.3,I10,1PE10.3)
            ELSE
              ICOUNT=ICOUNT+1
              WRITE(6,8160)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8160          FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
            END IF
8141      CONTINUE
8142      CONTINUE
        END IF
      ELSE IF((IARG .EQ. 10)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8170)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8170    FORMAT(' Bhabba   about to occur',T36,':',I5,F9.3,2I4,3F8.3,3F7.
     *3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 11)) THEN
        IF ((NP.EQ.NPold)) THEN
          ICOUNT=ICOUNT+1
          WRITE(6,8180)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8180      FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
        ELSE
          DO 8191 IP=NPold,NP
            KE = E(IP) - ABS(IQ(IP))*RM
            IF ((IP.EQ.NPold)) THEN
              ICOUNT=ICOUNT+1
              WRITE(6,8200)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8200          FORMAT(T11,'Resulting e- or e+',T36,':',I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
            ELSE
              ICOUNT=ICOUNT+1
              WRITE(6,8210)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8210          FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
            END IF
8191      CONTINUE
8192      CONTINUE
        END IF
      ELSE IF((IARG .EQ. 12)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8220)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8220    FORMAT(' Positron about to decay in flight',T36,':',I5,F9.3,2I4,
     *3F8.3,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 13)) THEN
        IF ((NP.EQ.NPold)) THEN
          ICOUNT=ICOUNT+1
          WRITE(6,8230)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8230      FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
        ELSE
          DO 8241 IP=NPold,NP
            KE = E(IP) - ABS(IQ(IP))*RM
            IF ((IP.EQ.NPold)) THEN
              ICOUNT=ICOUNT+1
              WRITE(6,8250)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8250          FORMAT(T11,'Resulting photons',T36,':',I5,F9.3,2I4,3F8.3,3
     *F7.3,I10,1PE10.3)
            ELSE
              ICOUNT=ICOUNT+1
              WRITE(6,8260)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8260          FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
            END IF
8241      CONTINUE
8242      CONTINUE
        END IF
      ELSE IF((IARG .EQ. 28)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8270)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8270    FORMAT(' Positron will annihilate at rest',T36,':',I5,F9.3,2I4,3
     *F8.3,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 14)) THEN
        IF ((NP.EQ.NPold)) THEN
          ICOUNT=ICOUNT+1
          WRITE(6,8280)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8280      FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
        ELSE
          DO 8291 IP=NPold,NP
            KE = E(IP) - ABS(IQ(IP))*RM
            IF ((IP.EQ.NPold)) THEN
              ICOUNT=ICOUNT+1
              WRITE(6,8300)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8300          FORMAT(' Positron annihilates at rest',T36,':',I5,F9.3,2I4
     *,3F8.3,3F7.3,I10,1PE10.3)
            ELSE
              ICOUNT=ICOUNT+1
              WRITE(6,8310)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8310          FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
            END IF
8291      CONTINUE
8292      CONTINUE
        END IF
      ELSE IF((IARG .EQ. 15)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8320)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8320    FORMAT(' Pair production about to occur',T36,':',I5,F9.3,2I4,3F8
     *.3,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 16)) THEN
        IF ((NP.EQ.NPold .AND. i_survived_rr .EQ. 0)) THEN
          ICOUNT=ICOUNT+1
          WRITE(6,8330)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8330      FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
        ELSE IF((NP.EQ.NPold .AND. i_survived_rr .GT. 0)) THEN
          WRITE(6,8340)i_survived_rr,prob_rr
8340      FORMAT(T10,'Russian Roulette eliminated ',I2, ' particle(s) wi
     *th probability ',F8.5)
          ICOUNT=ICOUNT+1
          WRITE(6,8350)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8350      FORMAT(T10,'Now on top of stack',T36,':',I5,F9.3,2I4,3F8.3,3F7
     *.3,I10,1PE10.3)
        ELSE
          DO 8361 IP=NPold,NP
            KE = E(IP) - ABS(IQ(IP))*RM
            IF ((IP.EQ.NPold)) THEN
              ICOUNT=ICOUNT+1
              WRITE(6,8370)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8370          FORMAT(T11,'Resulting pair',T36,':',I5,F9.3,2I4,3F8.3,3F7.
     *3,I10,1PE10.3)
            ELSE
              ICOUNT=ICOUNT+1
              WRITE(6,8380)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8380          FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
            END IF
8361      CONTINUE
8362      CONTINUE
          IF ((i_survived_rr .GT. 0)) THEN
            WRITE(6,8390)i_survived_rr,prob_rr
8390        FORMAT(T10,'Russian Roulette eliminated ',I2,'              
     *                  particle(s) with probability ',F8.5)
            ICOUNT=ICOUNT+1
            WRITE(6,8400)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(N
     *      P), W(NP),LATCH(NP),WT(NP)
8400        FORMAT(T10,'Now on top of stack',T36,':',I5,F9.3,2I4,3F8.3,3
     *F7.3,I10,1PE10.3)
          END IF
        END IF
      ELSE IF((IARG .EQ. 17)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8410)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8410    FORMAT(' Compton  about to occur',T36,':',I5,F9.3,2I4,3F8.3,3F7.
     *3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 18)) THEN
        IF ((NP .EQ. NPold .AND. i_survived_rr .EQ. 0)) THEN
          ICOUNT=ICOUNT+1
          WRITE(6,8420)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8420      FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
        ELSE IF((NP .GT. NPold)) THEN
          DO 8431 IP=NPold,NPold+1
            KE = E(IP) - ABS(IQ(IP))*RM
            IF ((IQ(IP).NE.0)) THEN
              ICOUNT=ICOUNT+1
              WRITE(6,8440)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8440          FORMAT(T11,'compton electron created',T36,':',I5,F9.3,2I4,
     *3F8.3,3F7.3,I10,1PE10.3)
            ELSE
              ICOUNT=ICOUNT+1
              WRITE(6,8450)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(IP),V
     *        (IP), W(IP),LATCH(IP),WT(IP)
8450          FORMAT(T11,'compton scattered photon',T36,':',I5,F9.3,2I4,
     *3F8.3,3F7.3,I10,1PE10.3)
            END IF
8431      CONTINUE
8432      CONTINUE
        END IF
        IF ((i_survived_rr .GT. 0)) THEN
          WRITE(6,8460)i_survived_rr,prob_rr
8460      FORMAT(T10,'Russian Roulette eliminated ',I2, ' particle(s) wi
     *th probability ',F8.5)
          ICOUNT=ICOUNT+1
          WRITE(6,8470)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8470      FORMAT(T10,'Now on top of stack',T36,':',I5,F9.3,2I4,3F8.3,3F7
     *.3,I10,1PE10.3)
        END IF
      ELSE IF((IARG .EQ. 19)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8480)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8480    FORMAT(' Photoelectric about to occur',T36,':',I5,F9.3,2I4,3F8.3
     *,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 20)) THEN
        IF ((NPold.EQ.NP .AND. IQ(NP).EQ.0 .AND. i_survived_rr .EQ. 0))
     *  THEN
          ICOUNT=ICOUNT+1
          WRITE(6,8490)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8490      FORMAT(T11,'Photon energy below N-shell',/, T11,'Photon discar
     *ded',T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
        ELSE IF((IQ(NPold) .EQ. -1 .AND. i_survived_rr .EQ. 0)) THEN
          KE= E(NPold)-RM
          ICOUNT=ICOUNT+1
          WRITE(6,8500)NPold,KE,IQ(NPold),IR(NPold),X(NPold),Y(NPold),Z(
     *    NPold),U(NPold),V(NPold), W(NPold),LATCH(NPold),WT(NPold)
8500      FORMAT(T10,'Resulting photoelectron',T36,':',I5,F9.3,2I4,3F8.3
     *,3F7.3,I10,1PE10.3)
        ELSE IF((i_survived_rr .GT. 0)) THEN
          IF ((NP.EQ.NPold-1 .OR. IQ(NPold) .NE. -1)) THEN
            IF ((i_survived_rr .GT. 1)) THEN
              WRITE(6,8510)i_survived_rr-1,prob_rr
8510          FORMAT(T10,'Russian Roulette eliminated ',I4, ' particle(s
     *) with probability ',F8.5,' plus')
            END IF
            WRITE(6,8520)prob_rr
8520        FORMAT(T10,'Russian Roulette eliminated resulting photoelect
     *ron', ' with probability ',F8.5)
          ELSE
            KE = E(NPold) - RM
            ICOUNT=ICOUNT+1
            WRITE(6,8530)NPold,KE,IQ(NPold),IR(NPold),X(NPold),Y(NPold),
     *      Z(NPold),U(NPold),V(NPold), W(NPold),LATCH(NPold),WT(NPold)
8530        FORMAT(T10,'Resulting photoelectron?',T36,':',I5,F9.3,2I4,3F
     *8.3,3F7.3,I10,1PE10.3)
            WRITE(6,8540)i_survived_rr,prob_rr
8540        FORMAT(T10,'Russian Roulette eliminated ',I4, ' particle(s)w
     *ith probability ',F8.5)
          END IF
          ICOUNT=ICOUNT+1
          WRITE(6,8550)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP)
     *    , W(NP),LATCH(NP),WT(NP)
8550      FORMAT(T10,'Now on top of stack',T36,':',I5,F9.3,2I4,3F8.3,3F7
     *.3,I10,1PE10.3)
        END IF
      ELSE IF((IARG .EQ. 24)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8560)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8560    FORMAT(' Rayleigh scattering occured',T36,':',I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 25)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8570)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8570    FORMAT(T10,'Fluorescent X-ray created',T36,':',I5,F9.3,2I4,3F8.3
     *,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 26)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8580)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8580    FORMAT(T10,'Coster-Kronig e- created',T36,':',I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 27)) THEN
        ICOUNT=ICOUNT+1
        WRITE(6,8590)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *  W(NP),LATCH(NP),WT(NP)
8590    FORMAT(T10,'Auger electron created',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
      END IF
      IF ((IARG .EQ. 0 .AND. IWATCH .EQ. 2)) THEN
        WRITE(6,8600)USTEP,TUSTEP,VSTEP,TVSTEP,EDEP
8600    FORMAT(T5,'USTEP,TUSTEP,VSTEP,TVSTEP,EDEP',T36,':    ',5(1PE13.4
     *))
        ICOUNT=ICOUNT+1
      END IF
      IF((NP .EQ. 1 .OR. IARG .EQ. 0))RETURN
      IF (( IARG .LE. 3)) THEN
        N=NP-1
        KE = E(N) - ABS(IQ(N))*RM
        ICOUNT=ICOUNT+1
        WRITE(6,8610)N,KE,IQ(N),IR(N),X(N),Y(N),Z(N),U(N),V(N), W(N),LAT
     *  CH(N),WT(N)
8610    FORMAT(T10,'Now on top of stack',T36,':',I5,F9.3,2I4,3F8.3,3F7.3
     *,I10,1PE10.3)
      END IF
      RETURN
      END
      SUBROUTINE SIGMA(NDATA,ISTAT,MODE,IERR)
      implicit none
      integer*4 NDATA,ISTAT,MODE,IERR
      COMMON/ERROR/DATA( 4000000,2)
      real*8 data
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 n,non0,i
      real*8 stat,sdenom
      real*8 emax,avg,error,datum,argmnt
      DATA EMAX/99.9/
      IERR=0
      IF (((MODE .LT. 0) .OR. (MODE .GT. 2))) THEN
        MODE=2
        IERR=1
      END IF
      IF (((NDATA.LE.0).OR.(NDATA.GT. 4000000).OR.(ISTAT.LE.0).OR.(ISTAT
     *.GT.2))) THEN
        IERR=-1
        RETURN
      END IF
      IF ((ISTAT .EQ. 1)) THEN
        IERR=10
        DO 8621 N=1,NDATA
          DATA(N,2)=EMAX
8621    CONTINUE
8622    CONTINUE
        RETURN
      END IF
      IF ((MODE.NE.0)) THEN
        STAT=FLOAT(ISTAT)
        SDENOM=STAT*(STAT-1.)
      END IF
      DO 8631 N=1,NDATA
        NON0=0
        AVG=0.0
        ERROR=0.0
        DO 8641 I=1,ISTAT
          DATUM=DATA(N,I)
          IF ((DATUM.NE.0.0)) THEN
            NON0=NON0+1
            AVG=AVG+DATUM
            ERROR=ERROR+DATUM**2
          END IF
8641    CONTINUE
8642    CONTINUE
        IF ((NON0 .EQ. 0)) THEN
          IERR=11
          ERROR=EMAX
          GOTO 8650
        ELSE IF(((NON0 .EQ. 1) .AND. (MODE .EQ. 0))) THEN
          ERROR=EMAX
          GOTO8650
        ELSE
          IF ((MODE .EQ. 0)) THEN
            STAT=FLOAT(NON0)
            SDENOM=STAT*(STAT-1.)
          END IF
        END IF
        AVG=AVG/STAT
        ARGMNT=ERROR-STAT*AVG**2
        IF ((ARGMNT.LT.0.0)) THEN
          WRITE(6,8660)ARGMNT,ERROR,STAT,AVG,SDENOM
8660      FORMAT(' ***** - SQ RT IN SIGMA. ARGMNT,ERROR,STAT,AVG,SDENOM=
     *'/' ',5E12.4)
          ARGMNT=0.0
        END IF
        ERROR=SQRT(ARGMNT/SDENOM)
        IF ((AVG .EQ. 0.)) THEN
          ERROR=EMAX
        ELSE
          ERROR=100.*ERROR/ABS(AVG)
        END IF
        IF((MODE .EQ. 2))AVG=AVG*STAT
8650    CONTINUE
        DATA(N,1)=AVG
        DATA(N,2)=MIN(EMAX,ERROR)
8631  CONTINUE
8632  CONTINUE
      RETURN
      END
      subroutine prepare_alias_sampling(nsbin,fs_array,ws_array,ibin_arr
     *ay)
      implicit none
      integer*4 nsbin,ibin_array(nsbin)
      real*8 fs_array(nsbin),ws_array(nsbin)
      integer*4 i,j_l,j_h
      real*8 sum,aux
      sum = 0
      DO 8671 i=1,nsbin
        IF((fs_array(i) .LT. 1e-30))fs_array(i) = 1e-30
        ws_array(i) = -fs_array(i)
        ibin_array(i) = 1
        sum = sum + fs_array(i)
8671  CONTINUE
8672  CONTINUE
      sum = sum/nsbin
      DO 8681 i=1,nsbin-1
        DO 8691 j_h=1,nsbin
          IF (( ws_array(j_h) .LT. 0 )) THEN
            IF((abs(ws_array(j_h)) .GT. sum))GOTO 8700
          END IF
8691    CONTINUE
8692    CONTINUE
        j_h = nsbin
8700    CONTINUE
          DO 8701 j_l=1,nsbin
          IF (( ws_array(j_l) .LT. 0 )) THEN
            IF((abs(ws_array(j_l)) .LT. sum))GOTO 8710
          END IF
8701    CONTINUE
8702    CONTINUE
        j_l = nsbin
8710    aux = sum - abs(ws_array(j_l))
        ws_array(j_h) = ws_array(j_h) + aux
        ws_array(j_l) = -ws_array(j_l)/sum
        ibin_array(j_l) = j_h
        IF((i .EQ. nsbin-1))ws_array(j_h) = 1
8681  CONTINUE
8682  CONTINUE
      return
      end
      real*8 function alias_sample(nsbin,xs_array,ws_array,ibin_array)
      implicit none
      integer*4 nsbin,ibin_array(nsbin)
      real*8 xs_array(0:nsbin),ws_array(nsbin)
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      real*8 v1,v2,aj
      integer*4 j
      IF((rng_seed .GT. 128))call ranmar_get
      v1 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((rng_seed .GT. 128))call ranmar_get
      v2 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      aj = 1 + v1*nsbin
      j = aj
      IF((j .GT. nsbin))j = nsbin
      aj = aj - j
      IF (( aj .GT. ws_array(j) )) THEN
        j = ibin_array(j)
      END IF
      alias_sample = (1-v2)*xs_array(j-1) + v2*xs_array(j)
      return
      end
      SUBROUTINE XVGRPLOT (X, Y, ERRY, NPTS, CURVENUM, SERIESTITLE, XTIT
     *LE, YTITLE, GRAPHTITLE, SUBTITLE, UNITNUM, TYPE, HISTXMIN, AXISTYP
     *E)
      IMPLICIT NONE
      integer*4 MAX, IDEBUG
      PARAMETER (MAX = 400)
      integer*4 NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE
      real*8 X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,HISTXMIN,ERRYOLD,SMALLESTX,
     * SMALLESTY,FUDGE
      integer*4 TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENG
     *TH
      integer*4 LOGX, LOGY, LOGDY,ZEROYCOUNT
      CHARACTER*(*) SUBTITLE
      CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE
      CHARACTER*10 INDEX
      CHARACTER*3 INDEXNUM
      logical TESTFILE, ALLPOS
      real*8 one
      parameter (one = 1)
      FUDGE = 1.e-10
      IDEBUG = 0
      IF ((IDEBUG .EQ. 1)) THEN
        write(6,'(//'' Entering xvgrplot ''/)')
        write(6,'('' Curve'',I3,'' to go to unit'',I3)')CURVENUM,UNITNUM
        write(6,'(''SERIESTITLE: '',a60)') SERIESTITLE
        write(6,'(''XTITLE:      '',a60)') XTITLE
        write(6,'(''YTITLE       '',a60)') YTITLE
        write(6,'(''GRAPHTILE:   '',a60)') graphtitle
        write(6,'(''SUBTITLE:    '',a80)') subtitle
      END IF
      IF (( NPTS .gt. MAX)) THEN
        WRITE(6,8720)NPTS, MAX
8720    FORMAT(//' **************************'/ ' Number of points asked
     * for =', I5, ' is greater than max allowed of', I4/ ' Setting NPTS
     * to MAX, you could adjust MAX in xvgrplot.mortran'/ ' ************
     ***************'//)
        NPTS1 = MAX
      ELSE
        NPTS1 = NPTS
      END IF
      INQUIRE(UNIT = UNITNUM,OPENED=TESTFILE)
      IF ((.NOT.TESTFILE)) THEN
        WRITE(6,7330) UNITNUM
7330    FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------' ,/'
     *   Unit specified (',I2,') is not open.' ,/'   Unit must be opened
     * before using subroutine.' ,/'   Data not written to file.' ,/'  -
     *---------------------------------------------'//)
        RETURN
      END IF
      IF ((GRAPHTITLE .EQ. ' ')) THEN
        GRAPHTITLE = 'Untitled Graph - No title specified in subroutine'
      END IF
      IF ((XTITLE .EQ. ' ')) THEN
        XTITLE = 'X-axis not titled in subroutine'
      END IF
      IF ((YTITLE .EQ. ' ')) THEN
        YTITLE = 'Y-axis not titled in subroutine'
      END IF
      IF ((SERIESTITLE .EQ. ' ')) THEN
        SERIESTITLE = 'series # '
        INDEX = '0123456789'
        INDEXNUM = INDEX(CURVENUM+1:CURVENUM+1)
        SERIESTITLE(9:9) = INDEXNUM
      END IF
      TITLELENGTH = 61
      SUBLENGTH = 61
      XAXISLENGTH = 61
      YAXISLENGTH = 61
      SERIESLENGTH = 61
8731  CONTINUE
        TITLELENGTH = TITLELENGTH - 1
        IF(((GRAPHTITLE(TITLELENGTH:TITLELENGTH) .NE. ' ')))GO TO8732
      GO TO 8731
8732  CONTINUE
8741  CONTINUE
        SUBLENGTH = SUBLENGTH - 1
        IF(((SUBTITLE(SUBLENGTH:SUBLENGTH) .NE. ' ')))GO TO8742
      GO TO 8741
8742  CONTINUE
8751  CONTINUE
        XAXISLENGTH = XAXISLENGTH - 1
        IF(((XTITLE(XAXISLENGTH:XAXISLENGTH) .NE. ' ')))GO TO8752
      GO TO 8751
8752  CONTINUE
8761  CONTINUE
        YAXISLENGTH = YAXISLENGTH - 1
        IF(((YTITLE(YAXISLENGTH:YAXISLENGTH) .NE. ' ')))GO TO8762
      GO TO 8761
8762  CONTINUE
8771  CONTINUE
        SERIESLENGTH = SERIESLENGTH - 1
        IF(((SERIESTITLE(SERIESLENGTH:SERIESLENGTH) .NE. ' ')))GO TO8772
      GO TO 8771
8772  CONTINUE
      IF (( IDEBUG .EQ. 1)) THEN
        WRITE(6,8780)SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITL
     *  ELENGTH
8780    FORMAT(' SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELEN
     *GTH'/ 5I10)
      END IF
      LOGX = 0
      LOGY = 0
      LOGDY = 0
      ZEROYCOUNT=0
      ALLPOS=.TRUE.
      IF (( X(1).EQ.0.0 )) THEN
        SMALLESTX = 0.1
      ELSE
        SMALLESTX=X(1)
      END IF
      IF (( Y(1).EQ.0.0 )) THEN
        SMALLESTY = 0.1
      ELSE
        SMALLESTY=Y(1)
      END IF
      DO 8791 COUNT=1,NPTS1
        IF (((X(COUNT) .LT. SMALLESTX) .AND. (X(COUNT).NE.0.))) THEN
          SMALLESTX=X(COUNT)
        END IF
        IF (((Y(COUNT) .LT. SMALLESTY) .AND. (Y(COUNT).NE.0.))) THEN
          SMALLESTY=Y(COUNT)
        END IF
        IF (((X(COUNT) .LT. 0.).OR.(Y(COUNT) .LT. 0.))) THEN
          ALLPOS=.FALSE.
        END IF
8791  CONTINUE
8792  CONTINUE
      IF ((ALLPOS)) THEN
        DO 8801 COUNT=1,NPTS1
          IF ((X(COUNT).EQ.0.)) THEN
            X(COUNT)=SMALLESTX*FUDGE
          END IF
          IF ((Y(COUNT).EQ.0.)) THEN
            Y(COUNT)=SMALLESTY*FUDGE
          END IF
8801    CONTINUE
8802    CONTINUE
      END IF
      IF ((AXISTYPE .GT. 0)) THEN
        DO 8811 COUNT=1,NPTS1
          IF ((X(COUNT) .LE. 0.)) THEN
            LOGX = 1
          END IF
          IF ((Y(COUNT) .LE. 0.)) THEN
            LOGY = 1
          END IF
          IF (((Y(COUNT)-ERRY(COUNT)) .LE. 0.)) THEN
            LOGDY = 1
          END IF
8811    CONTINUE
8812    CONTINUE
      ELSE
        DO 8821 COUNT=1,NPTS1
          IF ((Y(COUNT)-ERRY(COUNT) .LT. Y(COUNT)-0.9999*Y(COUNT) .AND.
     *    Y(COUNT).GT.0.)) THEN
            ZEROYCOUNT=ZEROYCOUNT+1
            IF ((ZEROYCOUNT.EQ.1)) THEN
              WRITE(6,8830)
8830          FORMAT (/' ------------WARNING from Subroutine XVGRPLOT---
     *--------' ,/'  Some errors give 0 value and so are adjusted so   '
     * ,/'  that you can switch to a log Y scale while in xmgr.   ',/' -
     *------------------------------------------------------'/)
            END IF
            ERRYOLD=ERRY(COUNT)
            ERRY(COUNT) = 0.9999*Y(COUNT)
          END IF
8821    CONTINUE
8822    CONTINUE
      END IF
      IF ((CURVENUM .EQ. 0)) THEN
        IF ((AXISTYPE .EQ. 0)) THEN
          WRITE(UNITNUM,7420) 'xy'
        ELSE IF((AXISTYPE .EQ. 1)) THEN
          WRITE(UNITNUM,7420) 'logy'
          WRITE(UNITNUM,7430)
        ELSE IF((AXISTYPE .EQ. 2)) THEN
          WRITE(UNITNUM,7420) 'logx'
          WRITE(UNITNUM,7430)
        ELSE IF((AXISTYPE .EQ. 3)) THEN
          WRITE(UNITNUM,7420) 'logxy'
          WRITE(UNITNUM,7430)
          WRITE(UNITNUM,7440)
        ELSE
          WRITE(6,7450) AXISTYPE
7450      FORMAT (//'  ------------Error in Subroutine XVGRPLOT---------
     *--' ,/'   AXISTYPE specified (',I2,') is not a valid option.' ,/' 
     *----------------------------------------------'//)
          RETURN
        END IF
7420    FORMAT ('@g0 type ',A,' ')
7430    FORMAT ('@    xaxis  ticklabel format exponential')
7440    FORMAT ('@    yaxis  ticklabel format exponential')
        WRITE(UNITNUM,7460) GRAPHTITLE(1:TITLELENGTH) ,SUBTITLE(1:SUBLEN
     *  GTH) ,XTITLE(1:XAXISLENGTH) ,YTITLE(1:YAXISLENGTH)
7460    FORMAT ('@    title "',A,'"'/ ,'@    subtitle "',A,'"'/ ,'@    l
     *egend on'/ ,'@    legend box linestyle 0'/ ,'@    legend x1 0.6'/,
     *'@    legend y1 0.75'/ ,'@    view xmin 0.250000'/ ,'@    xaxis  l
     *abel "',A,'"'/ ,'@    timestamp on'/ ,'@    yaxis  label "',A,'"')
      END IF
      IF ((AXISTYPE .EQ. 1 .AND. LOGY .EQ. 1)) THEN
        WRITE(UNITNUM,7420) 'xy'
        WRITE(6,7470)
7470    FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------',
     */'  Log scale requested for Y axis when one or more   ' ,/'  Ydata
     * points are 0 or negative.                  ' ,//'  Y axis scale c
     *hanged to linear.                   ' ,/' ------------------------
     *---------------------------'/)
      END IF
      IF ((AXISTYPE .EQ. 2 .AND. LOGX .EQ. 1)) THEN
        WRITE(UNITNUM,7420) 'xy'
        WRITE(6,7480)
7480    FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------',
     */'  Log scale requested for X axis when one or more   ' ,/'  Xdata
     * points are 0 or negative.                  ' ,//'  X axis scale c
     *hanged to linear.                   ' ,/' ------------------------
     *---------------------------'/)
      END IF
      IF ((AXISTYPE .EQ. 3 .AND. (LOGX .EQ. 1 .OR. LOGY .EQ. 1))) THEN
        IF ((LOGX .EQ. 1 .AND. LOGY .EQ. 1)) THEN
          WRITE(UNITNUM,7420) 'xy'
          WRITE(6,7490)
7490      FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------
     *' ,/'  Log scale requested for X axis and Y axis when    ' ,/'  on
     *e or more X and Y data points are 0 or negative.' ,//'  X and Y ax
     *es scales changed to linear.            ' ,/' --------------------
     *-------------------------------'/)
        ELSE IF((LOGX .EQ. 1)) THEN
          WRITE(UNITNUM,7420) 'logy'
          WRITE(6,7480)
        ELSE
          WRITE(UNITNUM,7420) 'logx'
          WRITE(6,7470)
        END IF
      END IF
      IF ((LOGDY .EQ. 1 .AND. LOGY .NE. 1 .AND. (AXISTYPE .EQ. 3 .OR. AX
     *ISTYPE .EQ. 1))) THEN
        WRITE(6,8840)
8840    FORMAT (/' ------------WARNING from Subroutine XVGRPLOT---------
     *--' ,/'  Log scale requested for Y axis, and Y value less      ' ,
     */'  error gives 0 or negative value.                      ' ,//'  
     *Error adjusted to aviod negavite values on log scale. ' ,/' ------
     *-------------------------------------------------'/)
        DO 8851 COUNT=1,NPTS1
          IF ((Y(COUNT)-ERRY(COUNT) .LT. Y(COUNT)-0.9999*Y(COUNT))) THEN
            ERRYOLD = ERRY(COUNT)
            ERRY(COUNT) = 0.9999*Y(COUNT)
            WRITE(6,8860) COUNT,ERRYOLD,ERRY(COUNT)
8860        FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, '
     * to' /'        ',1PE11.4,'.')
          END IF
8851    CONTINUE
8852    CONTINUE
        WRITE(6,8870)
8870    FORMAT (/' -----------------------------------------------------
     *--'/)
      END IF
      IF ((CURVENUM .LT. 10 )) THEN
        WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM
      ELSE
        WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM
      END IF
      WRITE(UNITNUM,7500) CURVENUM,SERIESTITLE(1:SERIESLENGTH)
7500  FORMAT ('@    legend string ',I2,' "',A,'"')
      IF ((TYPE .EQ. 0)) THEN
        DO 8881 COUNT=1,NPTS1
          IF ((ERRY(COUNT) .NE. 0)) THEN
            GOTO 8890
          END IF
8881    CONTINUE
8882    CONTINUE
        WRITE(UNITNUM,7510)
7510    FORMAT ('@TYPE xy')
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,7520) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,7530) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,7540) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,7550) CURVENUM
          WRITE(UNITNUM,7560) CURVENUM, CURVENUM+1
        END IF
7520    FORMAT ('@    s',I1,' errorbar length 0.000000')
7550    FORMAT ('@    s',I2,' errorbar length 0.000000')
7530    FORMAT ('@    s',I1,' symbol color ',I2)
7540    FORMAT ('@    s',I1,' symbol color ',I1)
7560    FORMAT ('@    s',I2,' symbol color ',I2)
        DO 8901 COUNT=1,NPTS1
          WRITE(UNITNUM,7580) X(COUNT),Y(COUNT)
8901    CONTINUE
8902    CONTINUE
7580    FORMAT (1PE15.4,1PE15.4)
        GOTO 8910
8890    CONTINUE
        WRITE(UNITNUM,8920)
8920    FORMAT ('@TYPE xydy')
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,7520) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,7530) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,7540) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,7550) CURVENUM
          WRITE(UNITNUM,7560) CURVENUM, CURVENUM+1
        END IF
        DO 8931 COUNT=1,NPTS1
          WRITE(UNITNUM,8940) X(COUNT),Y(COUNT),ERRY(COUNT)
8931    CONTINUE
8932    CONTINUE
8940    FORMAT (1PE15.4,1PE15.4,1PE15.4)
8910    CONTINUE
      ELSE
        YMIN = ABS(1.E5 * Y(1))
        DO 8951 COUNT=1,NPTS1
          IF ((ABS(Y(COUNT)) .LT. YMIN)) THEN
            YMIN = ABS(Y(COUNT))
          END IF
8951    CONTINUE
8952    CONTINUE
        YMIN = SIGN(one,Y(1)) * 1.E-5 * YMIN
        Y(NPTS1+1) = YMIN
        IF (((AXISTYPE .EQ. 2 .OR. AXISTYPE .EQ. 3) .AND. HISTXMIN .EQ.
     *  0)) THEN
          IF ((X(1) .EQ. (X(2)-X(1)))) THEN
            HISTXMIN = X(1)-0.5*(X(2)-X(1))
          ELSE
            HISTXMIN = X(1)-(X(2)-X(1))
          END IF
          WRITE(6,8960) HISTXMIN
8960      FORMAT (/' ---------WARNING from Subroutine XVGRPLOT--------',
     */'  Minimum bin for X specified as 0 with log scale  ' ,/'  on X a
     *xis.  Minimum X bin set to ',1PE10.3,'.' ,/' ---------------------
     *----------------------------'/)
        END IF
        DO 8971 COUNT=1,NPTS1
          IF ((ERRY(COUNT) .NE. 0.)) THEN
            GOTO 8980
          END IF
8971    CONTINUE
8972    CONTINUE
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,7520) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,7530) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,7540) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,7550) CURVENUM
          WRITE(UNITNUM,7560) CURVENUM, CURVENUM+1
        END IF
        WRITE(UNITNUM,7510)
        WRITE(UNITNUM,7580) HISTXMIN,YMIN
        WRITE(UNITNUM,7580) HISTXMIN,Y(1)
        DO 8991 COUNT=1,NPTS1
          WRITE(UNITNUM,7580) X(COUNT),Y(COUNT)
          WRITE(UNITNUM,7580) X(COUNT),Y(COUNT+1)
8991    CONTINUE
8992    CONTINUE
        GOTO 9000
8980    CONTINUE
        ERRY(NPTS1+1) = 0.0
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,7520) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,7530) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,7540) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,7550) CURVENUM
          WRITE(UNITNUM,7560) CURVENUM, CURVENUM+1
        END IF
        WRITE(UNITNUM,8920)
        IF ((HISTXMIN .EQ. 0.0)) THEN
          HISTXMIN = SMALLESTX*FUDGE
        END IF
        WRITE(UNITNUM,8940) HISTXMIN, YMIN, 0.
        WRITE(UNITNUM,8940) HISTXMIN, Y(1), 0.
        WRITE(UNITNUM,8940) (X(1)+HISTXMIN)/2., Y(1), ERRY(1)
        DO 9011 COUNT=1,NPTS1
          WRITE (UNITNUM,8940) X(COUNT),Y(COUNT),0.
          WRITE (UNITNUM,8940) X(COUNT),Y(COUNT+1),0.
          IF ((COUNT .LT. NPTS1)) THEN
            WRITE (UNITNUM,8940) (X(COUNT)+X(COUNT+1))/2.,Y(COUNT+1),ERR
     *      Y(COUNT+1)
          END IF
9011    CONTINUE
9012    CONTINUE
9000    CONTINUE
      END IF
      WRITE(UNITNUM,'(''&'')')
      RETURN
      END
C##############################################################################
C
C   This file was automatically generated by configure version 2.0
C   It contains various subroutines and functions for date, time,
C   CPU time, host name, etc.
C
C   Attention: all changes will be lost the next time you run configure!
C
C##############################################################################


C##############################################################################
C
C  EGSnrc egs_system subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C egs_system(command)  runs a system command and returns the status
C                      command must be null-terminated
C*****************************************************************************
      integer function egs_system(command)
      character*(*) command
      integer system, istat
      istat = system(command)
      egs_system = istat
      return
      end

C##############################################################################
C
C  EGSnrc egs_isdir subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C  egs_isdir(file_name)  Returns .true., if the string file_name points to
C                        an existing directory. This version uses the lstat
C                        intrinsic and then tests for bit 14 being set in
C                        the mode element. This works on all Unix systems
C                        that I have access to (Linux, Aix, HP-UX, OSF1,
C                        Solaris, IRIX)
C
C*****************************************************************************

      logical function egs_isdir(file_name)
      implicit none
      character*(*) file_name
      integer*4 lnblnk1, res, array(13), l, lstat
      logical btest
      egs_isdir = .false.
      l = lnblnk1(file_name)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = char(0)
         ! On some systems lstat only works if the string is 0-terminated
      res = lstat(file_name,array)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = ' '
      if( res.eq.0 ) then
            ! Amost all compilers that have the lstat intrinsic return the
            ! file mode in the 3rd array element. But the PGI compiler has
            ! its own opinion on the subject and returns it in the 5th element
            ! That's why the relevant element is written as 3
            ! here, 3 gets replaced by the appropriate element
            ! by the configure script.
          if( btest(array(3),14) ) egs_isdir = .true.
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C***************************************************************************
C
C   egs_fdate(out):  print a 24 char date and time string in the form
C                         'Tue Mar 18 08:16:42 2003'
C                    to the unit specified by out without end of line
C                    i.e. the sequence
C                    write(6,'(a,$)') 'Today is '
C                    call egs_fdate(6)
C                    write(6,'(a)') '. Have a nice date'
C                    should result in something like
C                    Today is Tue Mar 18 08:16:42 2003. Have a nice date
C                    printed to unit 6.
C
C***************************************************************************

      subroutine egs_fdate(ounit)
      integer ounit
      character*24 string
      call fdate(string)
      write(ounit,'(a,$)') string
      end

C***************************************************************************
C
C   egs_get_fdate(string) assignes a 24 char date and time string to string
C                         string must be at least 24 chars long, otherwise
C                         this subroutine has no effect.
C
C***************************************************************************

      subroutine egs_get_fdate(string)
      character*(*) string
      if( len(string).ge.24 ) call fdate(string)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date_and_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


      subroutine egs_date_and_time(vnow)
      integer vnow(8)
      character dat*8,tim*10,zon*5
      call date_and_time(dat,tim,zon,vnow)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*************************************************************************
C
C egs_date(ounit): print a 11 char string in the form
C                     '18-Mar-2003'
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_date(ounit)
      integer ounit
      character string*24, dat*11
      call fdate(string)
      dat(1:2) = string(9:10)
      dat(3:3) = '-'
      dat(4:6) = string(5:7)
      dat(7:7) = '-'
      dat(8:11) = string(21:24)
      write(ounit,'(a,$)') dat
      return
      end

C##############################################################################
C
C  EGSnrc egs_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C $Id: egs_time_v1.f,v 1.1 2003/07/11 19:17:08 iwan Exp $
C*************************************************************************
C
C egs_time(ounit): print a 8 char string in the form hh:mm:ss
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_time(ounit)
      integer ounit
      character string*24
      call fdate(string)
      write(ounit,'(a,$)') string(12:19)
      return
      end

C##############################################################################
C
C  EGSnrc seconds timing subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_secnds(t0): returns seconds passed since midnight minus t0
C
C*****************************************************************************

      real function egs_secnds(t0)
      real t0,t1
      character dat*8,tim*10,zon*5
      integer values(8)
      call date_and_time(dat,tim,zon,values)
      t1 = 3600.*values(5) + 60.*values(6) + values(7) + 0.001*values(8)
      egs_secnds = t1 - t0
      return
      end

C*****************************************************************************
C
C real function egs_tot_time()
C
C   On first call returns seconds passed since 1/1/1970
C   On subsequent calls returns
C     - seconds since last call, if flag = 0
C     - seconds since first call, else
C
C*****************************************************************************

      real function egs_tot_time(flag)
      integer flag
      character dat*8,tim*10,zon*5
      integer vnow(8), vlast(8),i
      real t,egs_time_diff,t0
      data vlast/1970,1,1,5*0/,t0/-1/
      save vlast,t0
      call date_and_time(dat,tim,zon,vnow)
      t = egs_time_diff(vlast,vnow)
      do i=1,8
        vlast(i)=vnow(i)
      end do
      if( t0.lt.0 ) then
        t0 = 0
        egs_tot_time = t
      else
        t0 = t0 + t
        if(flag.eq.0) then
          egs_tot_time = t
        else
          egs_tot_time = t0
        end if
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date and time subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C****************************************************************************
C
C Returns the time difference between vstart and vend
C vstart and vend are integer arrays of dimension 8 with elements
C corresponding to the specification of the data_and_time routine, i.e.
C   array(1) = year
C   array(2) = month of the year   (1...12)
C   array(3) = day of the month    (1...31)
C   array(4) = difference in minutes from UTC
C   array(5) = hour of the day     (1...23)
C   array(6) = minute of the hour  (1...59)
C   array(7) = seconds of the minute (1...59)
C   array(8) = miliseconds of the second (1...999)
C
C Note: this implementation ignores the time difference from UTC field
C
C*****************************************************************************
      real function egs_time_diff(vstart,vend)
      integer    vstart(8),vend(8)
      real       egs_time_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_time_diff = -egs_time_diff_o(vend,vstart)
      else
        egs_time_diff = egs_time_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C day difference between the dates specified by the integer arrays vstart and
C vend. The arrays are v(1)=year, v(2)=month, v(3)=day
C
C******************************************************************************
      integer function egs_day_diff(vstart,vend)
      integer vstart(3),vend(3),egs_day_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_day_diff = -egs_day_diff_o(vend,vstart)
      else
        egs_day_diff = egs_day_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C Returns a 3-letter abreviation of the day of the week in the string day,
C given a day specified by the integer array values
C   values(1)=year, values(2)=month, values(3)=day
C
C******************************************************************************
      subroutine egs_weekday(values,day)
      character*(*) day
      integer       values(3)
      integer       days,vtmp(3),egs_day_diff,aux
      character*3   wdays(7)
      data wdays/'Mon','Tue','Wed','Thu','Fri','Sat','Sun'/
      vtmp(1) = 1970
      vtmp(2) = 1
      vtmp(3) = 1
      days = egs_day_diff(vtmp,values)
      aux = mod(days,7)
      days = 4 + aux
      if( days.gt.7 ) days = days - 7
      day(:len(day)) = ' '
      aux = min(len(day),3)
      day(:aux) = wdays(days)(:aux)
      return
      end

C*****************************************************************************
C
C Same as egs_day_diff above, but assumes that vend specifies a later date
C than vstart.
C
C*****************************************************************************
      integer function egs_day_diff_o(vstart,vend)
      integer vstart(3),vend(3)
      integer    days
      logical    next_month
      integer    tm,m,ty,y
      integer    mdays(12)
      data       mdays/31,28,31,30,31,30,31,31,30,31,30,31/
      days = 0
      ty = vstart(1)
      y  = vend(1)
      tm = vstart(2)
      m  = vend(2)
      next_month = .true.
      do while(next_month)
        if( tm.eq.m.and.ty.eq.y ) then
          next_month = .false.
        else
          days = days + mdays(tm)
          if( tm.eq.2.and.mod(ty,4).eq.0 ) days = days + 1
          tm = tm + 1
          if( tm.gt.12 ) then
            ty = ty + 1
            tm = 1
          end if
        end if
      end do
      days = days + vend(3) - vstart(3)
      egs_day_diff_o = days
      return
      end

C******************************************************************************
C
C Same as egs_time_diff above, but assumes that vend specifies a later date
C than vstart.
C
C******************************************************************************
      real function egs_time_diff_o(vstart,vend)
      integer    vstart(8),vend(8)
      integer    days,hours,minutes,secs,msecs
      integer    egs_day_diff_o
      days = egs_day_diff_o(vstart,vend)
      hours = vend(5) - vstart(5)
      minutes = vend(6) - vstart(6)
      secs = vend(7) - vstart(7)
      msecs = vend(8) - vstart(8)
      egs_time_diff_o = 3600.*(24.*days+hours)+60.*minutes+secs+
     &                  0.001*msecs
      return
      end

C******************************************************************************
C
C Returns in month a 3-letter abreviation of the month specified by mo, if
C mo is between 1 and 12, or an empty string otherwise.
C
C******************************************************************************
      subroutine egs_month(mo,month)
      integer mo
      character*(*) month
      integer iaux
      character*3   months(12)
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      iaux = min(len(month),3)
      month(:len(month)) = ' '
      if( mo.ge.1.and.mo.le.12 ) month(:iaux) = months(mo)(:iaux)
      return
      end

C******************************************************************************
C
C Converts a 3-letter abreviation of a month to its corresponding integer
C value, if the string month is a valid month, or -1 otherwise.
C
C******************************************************************************
      integer function egs_conver_month(month)
      character*3 month
      character*3 months(12)
      integer i
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      do i=1,12
        if( month.eq.months(i) ) then
          egs_conver_month = i
          return
        end if
      end do
      egs_conver_month = -1
      return
      end


C##############################################################################
C
C  EGSnrc egs_etime subroutine
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_etime(): returns CPU time consumed since the start of
C                            the program
C
C*****************************************************************************

      real function egs_etime()
      real tarray(2),etime
      egs_etime = etime(tarray)
      return
      end

C##############################################################################
C
C  EGSnrc canonical system name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the canonical system name as determined by the config.guess script
C or the Windows installation program to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_canonical_system(ounit)
      integer ounit
      write(6,'(a,$)') 'x86_64-unknown-linux-gnu'
      return
      end

C******************************************************************************
C
C Assign the canonical system name as determined by the config.guess script
C or the Windows installation program to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_canonical_system(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('x86_64-unknown-linux-gnu')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'x86_64-unknown-linux-gnu'
      else
        res(:l2) = 'x86_64-unknown-linux-gnu'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc configuration name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the configuration name as specified suring the configuration
C process to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_configuration_name(ounit)
      integer ounit
      write(6,'(a,$)') 'linux'
      return
      end

C******************************************************************************
C
C Assign the configuration name as specified suring the configuration
C process to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_configuration_name(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('linux')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'linux'
      else
        res(:l2) = 'linux'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc hostname subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C Print the host name to the unit specified by ounit without inserting
C a new line character.
C
C*****************************************************************************

      subroutine egs_print_hostnm(ounit)
      integer ounit
      character*256 string
      integer res,hostnm,lnblnk1
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      write(ounit,'(a,$)') string(:lnblnk1(string))
      return
      end

C*****************************************************************************
C
C Assign the host name to the string pointed to be hname.
C
C*****************************************************************************

      subroutine egs_get_hostnm(hname)
      character*(*) hname
      character*256 string
      integer res,hostnm,lnblnk1,l1,l2,l
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      l1 = lnblnk1(string)
      l2 = len(hname)
      hname(:l2) = ' '
      l = min(l1,l2)
      hname(:l) = string(:l)
      return
      end

      subroutine egs_init
      implicit none
      common/my_times/ t_elapsed, t_cpu, t_first
      real*8 t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      real*8 dum
      call egs_set_defaults
      call egs_check_arguments
      call egs_init1
      return
      end
      subroutine egs_init1
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      common/my_times/ t_elapsed, t_cpu, t_first
      real*8 t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      integer l, lnblnk1, l1, l2
      integer i
      character arg*256,tmp_string*512, tmp1_string*512, ucode_dir*512,
     *line*80, line1*80,dattim*24
      logical have_input,egs_isdir,egs_strip_extension,ex, on_egs_home,i
     *s_opened
      integer*4 mypid
      integer getpid
      integer istat, egs_system, u, pos1, pos2,egs_get_unit,itmp
      real*8 dum
      t_elapsed = 0
      t_cpu = egs_etime()
      dum = egs_tot_time(1)
      call egs_date_and_time(t_first)
      DO 9021 i=1,len(line)
        line(i:i) = '='
9021  CONTINUE
9022  CONTINUE
      DO 9031 i=1,len(line1)
        line1(i:i) = '.'
9031  CONTINUE
9032  CONTINUE
      IF ((.NOT.is_pegsless)) THEN
        on_egs_home = .false.
        inquire(file=pegs_file,exist=ex)
        IF (( ex )) THEN
          kmpi=egs_get_unit(kmpi)
          IF ((kmpi.LT.0)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'failed to get a free Fortran I/O unit for pe
     *gs file'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(kmpi,file=pegs_file,status='old',err=9040)
          goto 9050
        END IF
        arg = pegs_file(:lnblnk1(pegs_file))
        ex = egs_strip_extension(arg,'.pegs4dat')
        l = lnblnk1(egs_home)
        l1 = lnblnk1('pegs4data') + 2*lnblnk1('/')
        l2 = lnblnk1(arg) + lnblnk1('.pegs4dat')
        IF (( l + l1 + l2 .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'pegs4 data file name (including absolute path)
     *'
          write(i_log,'(a,i4,a)') 'is too long (',l+l1+l2,') characters'
        ELSE
          pegs_file = egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/' //
     *    'data' // '/' // arg(:lnblnk1(arg)) // '.pegs4dat'
          inquire(file=pegs_file,exist=ex)
          IF (( ex )) THEN
            kmpi=egs_get_unit(kmpi)
            IF ((kmpi.LT.0)) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'failed to get a free Fortran I/O unit for
     *pegs file'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            open(kmpi,file=pegs_file,status='old',err=9040)
            on_egs_home = .true.
            goto 9050
          END IF
        END IF
        l = lnblnk1(hen_house)
        IF (( l + l1 + l2 .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'pegs4 data file name (including absolute path)
     *'
          write(i_log,'(a,i4,a)') 'is too long (',l+l1+l2,') characters'
        ELSE
          pegs_file = hen_house(:lnblnk1(hen_house)) // 'pegs4' // '/' /
     *    / 'data' // '/' // arg(:lnblnk1(arg)) // '.pegs4dat'
          inquire(file=pegs_file,exist=ex)
          IF (( ex )) THEN
            kmpi=egs_get_unit(kmpi)
            IF ((kmpi.LT.0)) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'failed to get a free Fortran I/O unit for
     *pegs file'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            open(kmpi,file=pegs_file,status='old',err=9040)
            goto 9050
          END IF
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'could not find pegs4 file named ',arg(:lnblnk1(a
     *  rg))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
9050  CONTINUE
      DO 9061 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
9061  CONTINUE
9062  CONTINUE
      tmp_string = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      i_nist_data=76
      i_incoh=78
      i_photo_relax=77
      i_photo_cs=79
      i_mscat=11
      DO 9071 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
9071  CONTINUE
9072  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'photo_cs.data'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','photo_cs.data',' does not ex
     *ist'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_photo_cs=egs_get_unit(i_photo_cs)
        IF ((i_photo_cs.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_photo_cs,file=tmp1_string,status='old',err=9080)
      ELSE
        i_photo_cs = itmp
      END IF
      DO 9091 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
9091  CONTINUE
9092  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'msnew.data'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','msnew.data',' does not exist
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_mscat=egs_get_unit(i_mscat)
        IF ((i_mscat.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_mscat,file=tmp1_string,status='old',err=9080)
      ELSE
        i_mscat = itmp
      END IF
      DO 9101 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
9101  CONTINUE
9102  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'incoh.data'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','incoh.data',' does not exist
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_incoh=egs_get_unit(i_incoh)
        IF ((i_incoh.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_incoh,file=tmp1_string,status='old',err=9080)
      ELSE
        i_incoh = itmp
      END IF
      DO 9111 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
9111  CONTINUE
9112  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'photo_relax.dat
     *a'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','photo_relax.data',' does not
     * exist'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_photo_relax=egs_get_unit(i_photo_relax)
        IF ((i_photo_relax.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_photo_relax,file=tmp1_string,status='old',err=9080)
      ELSE
        i_photo_relax = itmp
      END IF
      DO 9121 i=1,len(ucode_dir)
        ucode_dir(i:i) = ' '
9121  CONTINUE
9122  CONTINUE
      ucode_dir = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(use
     *r_code)) // '/'
      have_input = .false.
      i_input=5
      IF (( lnblnk1(input_file) .GT. 0 )) THEN
        have_input = .true.
        l = lnblnk1(egs_home)
        l1 = lnblnk1(user_code)+1
        l2 = lnblnk1(input_file) + lnblnk1('.egsinp')
        IF (( l + l1 + l2 .GT. 1024 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'input file name (including path) is too long '
     *    ,l+l1+l2
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        ex = egs_strip_extension(input_file,'.egsinp')
        tmp_string = ucode_dir(:lnblnk1(ucode_dir)) // input_file(:lnbln
     *  k1(input_file)) // '.egsinp'
        inquire(file=tmp_string,exist=ex)
        IF (( .NOT.ex )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'Input file ',tmp_string(:lnblnk1(tmp_string)),
     *    ' does not exist.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_input,file=tmp_string,status='old',err=9130)
      END IF
      DO 9141 i=1,len(work_dir)
        work_dir(i:i) = ' '
9141  CONTINUE
9142  CONTINUE
      work_dir = 'egsrun_'
      mypid = getpid()
      call egs_itostring(work_dir,mypid,.false.)
      call egs_get_hostnm(host_name)
      IF((lnblnk1(host_name) .LT. 1))host_name = 'unknown'
      IF (( have_input )) THEN
        work_dir = work_dir(:lnblnk1(work_dir)) // '_' // input_file(:ln
     *  blnk1(input_file)) // '_' // host_name(:lnblnk1(host_name)) // '
     */'
      ELSE
        work_dir = work_dir(:lnblnk1(work_dir)) // '_noinput_' // host_n
     *  ame(:lnblnk1(host_name)) // '/'
      END IF
      DO 9151 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
9151  CONTINUE
9152  CONTINUE
      tmp_string = ucode_dir(:lnblnk1(ucode_dir)) // work_dir(:lnblnk1(w
     *ork_dir))
      DO 9161 i=1,lnblnk1(tmp_string)
        IF (( tmp_string(i:i) .EQ. '/' )) THEN
          tmp_string(i:i) = '/'
        END IF
9161  CONTINUE
9162  CONTINUE
      ex = egs_isdir(tmp_string)
      IF (( ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'a directory named ',tmp_string(:lnblnk1(tmp_stri
     *  ng)),' already exists?'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp1_string = 'mkdir ' // tmp_string(:lnblnk1(tmp_string))
      l = lnblnk1(tmp1_string)
      tmp1_string(l+1:l+1) = char(0)
      istat = egs_system(tmp1_string)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'failed to create working directory ',tmp1_string
     *  (:lnblnk1(tmp1_string))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      call egs_open_units(.true.)
      write(i_log,'(a)') line
      write(i_log,'(a,a,t55,a,$)') 'EGSnrc version 4 for ','x86_64-unkno
     *wn-linux-gnu',' '
      call egs_get_fdate(dattim)
      write(i_log,'(a,/,a)') dattim,line
      pos1 = lnblnk1('output file(s)')
      pos2 = 80 - lnblnk1('linux')
      pos2 = min(pos2,80-lnblnk1(user_code))
      DO 9171 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
9171  CONTINUE
9172  CONTINUE
      tmp_string = pegs_file
      call egs_strip_path(tmp_string)
      ex = egs_strip_extension(tmp_string,'.pegs4dat')
      IF (( on_egs_home )) THEN
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // ' on EGS_HOME'
      ELSE
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // ' on HEN_HOUSE'
      END IF
      IF (( lnblnk1(tmp_string) .GT. lnblnk1(pegs_file) )) THEN
        DO 9181 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
9181    CONTINUE
9182    CONTINUE
        tmp_string = pegs_file
      END IF
      pos2 = min(pos2,80-lnblnk1(tmp_string))
      pos2 = min(pos2,80-lnblnk1(host_name))
      IF((have_input))pos2 = min(pos2,80-lnblnk1(input_file))
      pos2 = min(pos2,80-lnblnk1(output_file))
      IF((pos2 .LT. pos1+2))pos2 = pos1 + 2
      write(i_log,'(a,$)') 'configuration'
      l = pos2 - lnblnk1('configuration')
      write(i_log,'(a,$)') line1(:l)
      write(i_log,'(a)') 'linux'
      write(i_log,'(a,$)') 'user code'
      l = pos2 - lnblnk1('user code')
      write(i_log,'(a,$)') line1(:l)
      write(i_log,'(a)') user_code(:lnblnk1(user_code))
      write(i_log,'(a,$)') 'pegs file'
      l = pos2 - lnblnk1('pegs file')
      write(i_log,'(a,$)') line1(:l)
      write(i_log,'(a)') tmp_string(:lnblnk1(tmp_string))
      write(i_log,'(a,$)') 'using host'
      l = pos2 - lnblnk1('using host')
      write(i_log,'(a,$)') line1(:l)
      write(i_log,'(a)') host_name(:lnblnk1(host_name))
      IF (( have_input )) THEN
        write(i_log,'(a,$)') 'input file'
        l = pos2 - lnblnk1('input file')
        write(i_log,'(a,$)') line1(:l)
        write(i_log,'(a)') input_file(:lnblnk1(input_file))
      END IF
      write(i_log,'(a,$)') 'output file(s)'
      l = pos2 - lnblnk1('output file(s)')
      write(i_log,'(a,$)') line1(:l)
      write(i_log,'(a)') output_file(:lnblnk1(output_file))
      IF (( n_parallel .GT. 0 )) THEN
        write(i_log,'(a,$)') 'number of parallel jobs'
        l = pos2 - lnblnk1('number of parallel jobs')
        write(i_log,'(a,$)') line1(:l)
        write(i_log,'(i2)') n_parallel
        write(i_log,'(a,$)') 'job number'
        l = pos2 - lnblnk1('job number')
        write(i_log,'(a,$)') line1(:l)
        write(i_log,'(i2)') i_parallel
      END IF
      write(i_log,'(a)') line
      return
9130  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open input file ',tmp_string(:lnblnk1(tm
     *p_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
9040  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open existing pegs file ',pegs_file(:lnb
     *lnk1(pegs_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
9080  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open EGSnrc data file ',tmp1_string(:lnb
     *lnk1(tmp1_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_check_arguments
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character arg*256,tmp_string*512, line1*80
      logical have_arg,egs_isdir,egs_strip_extension,ex, on_egs_home
      integer narg, iargc, i, lnblnk1, l, l2,i_help,egs_get_unit
      narg = iargc()
      IF((narg .LT. 1))return
      have_arg = .false.
      DO 9191 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-H') .AND. arg(:l) .EQ. '-H' ) .OR. ( l
     *  .EQ. lnblnk1('--hen-house') .AND. arg(:l) .EQ. '--hen-house' ) )
     *  ) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9192
        END IF
9191  CONTINUE
9192  CONTINUE
      IF (( have_arg )) THEN
        l = lnblnk1(arg)
        DO 9201 i=1,len(hen_house)
          hen_house(i:i) = ' '
9201    CONTINUE
9202    CONTINUE
        IF (( l .GT. 0 )) THEN
          IF (( l .GT. 254 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a,i5)') ' HEN_HOUSE argument is too long',l
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          hen_house(:l) = arg(:lnblnk1(arg))
          IF((hen_house(l:l) .NE. '/'))hen_house(l+1:l+1) = '/'
        ELSE
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a)') ' empty argument after -H'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        DO 9211 i=1,lnblnk1(hen_house)
          IF (( hen_house(i:i) .EQ. '/' )) THEN
            hen_house(i:i) = '/'
          END IF
9211    CONTINUE
9212    CONTINUE
      END IF
      IF (( .NOT.egs_isdir(hen_house) )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,'(a,a)') ' HEN_HOUSE directory ',hen_house(:lnblnk1(
     *  hen_house))
        write(i_log,'(a)') 'does not exist. Hope you know what you are d
     *oing.'
      END IF
      have_arg = .false.
      DO 9221 i=1,narg
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-h') .AND. arg(:l) .EQ. '-h' ) .OR. ( l
     *  .EQ. lnblnk1('--help') .AND. arg(:l) .EQ. '--help' ) )) THEN
          have_arg = .true.
          GO TO9222
        END IF
9221  CONTINUE
9222  CONTINUE
      IF (( have_arg )) THEN
        call getarg(0,arg)
        call egs_strip_path(arg)
        write(i_log,'(//,a,a,a,//)') 'Usage: ',arg(:lnblnk1(arg)),' [arg
     *s] '
        tmp_string = hen_house(:lnblnk1(hen_house)) // 'pieces/help_mess
     *age'
        i_help=98
        i_help=egs_get_unit(i_help)
        IF ((i_help.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for help
     * file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_help,file=tmp_string,status='old',err=9230)
9241    CONTINUE
          read(i_help,'(a)',err=9250,end=9250) line1
          write(i_log,'(a)') line1
        GO TO 9241
9242    CONTINUE
9250    CONTINUE
        call exit(0)
9230    CONTINUE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Did not find the help_message file!'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      have_arg = .false.
      DO 9261 i=1,narg
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-b') .AND. arg(:l) .EQ. '-b' ) .OR. ( l
     *  .EQ. lnblnk1('--batch') .AND. arg(:l) .EQ. '--batch' ) )) THEN
          have_arg = .true.
          GO TO9262
        END IF
9261  CONTINUE
9262  CONTINUE
      IF((have_arg))is_batch = .true.
      have_arg = .false.
      DO 9271 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-P') .AND. arg(:l) .EQ. '-P' ) .OR. ( l
     *  .EQ. lnblnk1('--parallel') .AND. arg(:l) .EQ. '--parallel' ) ))
     *  THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9272
        END IF
9271  CONTINUE
9272  CONTINUE
      IF (( have_arg )) THEN
        read(arg,*,err=9280) n_parallel
        IF((n_parallel .LT. 0))goto 9280
        goto 9290
9280    CONTINUE
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Wrong/missing parallel job number argument, -P
     *option ignored'
        n_parallel = 0
9290    CONTINUE
      END IF
      have_arg = .false.
      DO 9301 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-j') .AND. arg(:l) .EQ. '-j' ) .OR. ( l
     *  .EQ. lnblnk1('--job') .AND. arg(:l) .EQ. '--job' ) )) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9302
        END IF
9301  CONTINUE
9302  CONTINUE
      IF (( have_arg )) THEN
        read(arg,*,err=9310) i_parallel
        IF((i_parallel .LT. 0))goto 9310
        goto 9320
9310    CONTINUE
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Wrong/missing job argument, -j option ognored'
        i_parallel = 0
9320    CONTINUE
      END IF
      have_arg = .false.
      DO 9331 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-f') .AND. arg(:l) .EQ. '-f' ) .OR. ( l
     *  .EQ. lnblnk1('--first-job') .AND. arg(:l) .EQ. '--first-job' ) )
     *  ) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9332
        END IF
9331  CONTINUE
9332  CONTINUE
      IF (( have_arg )) THEN
        read(arg,*,err=9340) first_parallel
        IF((first_parallel .LT. 1))goto 9340
        goto 9350
9340    CONTINUE
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Wrong/missing first job argument, -f option ogn
     *ored'
        first_parallel = 1
9350    CONTINUE
      END IF
      IF (( n_parallel .GT. 0 .OR. i_parallel .GT. 0 )) THEN
        IF (( n_parallel*i_parallel .EQ. 0 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'You need to specify number of jobs AND job num
     *ber ', '=> will not use parallel run '
          n_parallel = 0
          i_parallel = 0
        END IF
        IF (( first_parallel .GT. i_parallel )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'i_parallel (',i_parallel, ') can not be smalle
     *r than first_parallel (',first_parallel,')'
          first_parallel = i_parallel
        END IF
      END IF
      have_arg = .false.
      DO 9361 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-e') .AND. arg(:l) .EQ. '-e' ) .OR. ( l
     *  .EQ. lnblnk1('--egs-home') .AND. arg(:l) .EQ. '--egs-home' ) ))
     *  THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9362
        END IF
9361  CONTINUE
9362  CONTINUE
      IF (( have_arg )) THEN
        l = lnblnk1(arg)
        DO 9371 i=1,len(egs_home)
          egs_home(i:i) = ' '
9371    CONTINUE
9372    CONTINUE
        IF (( l .EQ. 0 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a)') ' empty argument after -e'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF (( l .GT. 254 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,i5)') ' EGS_HOME argument is too long ',l
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        egs_home(:l) = arg(:lnblnk1(arg))
        IF((egs_home(l:l) .NE. '/'))egs_home(l+1:l+1) = '/'
        DO 9381 i=1,lnblnk1(egs_home)
          IF (( egs_home(i:i) .EQ. '/' )) THEN
            egs_home(i:i) = '/'
          END IF
9381    CONTINUE
9382    CONTINUE
      END IF
      IF (( .NOT.egs_isdir(egs_home) )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' EGS_HOME directory ',egs_home(:lnblnk1(egs_home
     *  )),' does not exist.'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      on_egs_home = .false.
      is_pegsless=.false.
      have_arg = .false.
      DO 9391 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-p') .AND. arg(:l) .EQ. '-p' ) .OR. ( l
     *  .EQ. lnblnk1('--pegs-file') .AND. arg(:l) .EQ. '--pegs-file' ) )
     *  ) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9392
        END IF
9391  CONTINUE
9392  CONTINUE
      IF (( .NOT.have_arg )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) 'No pegs4 file name supplied.  Will assume you ar
     *e running    in pegs-less mode with media details specified in inp
     *ut file.'
        is_pegsless=.true.
      ELSE
        pegs_file = arg(:lnblnk1(arg))
      END IF
      call egs_get_usercode(user_code)
      have_arg = .false.
      DO 9401 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-i') .AND. arg(:l) .EQ. '-i' ) .OR. ( l
     *  .EQ. lnblnk1('--input') .AND. arg(:l) .EQ. '--input' ) )) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9402
        END IF
9401  CONTINUE
9402  CONTINUE
      IF (( have_arg )) THEN
        ex = egs_strip_extension(arg,'.egsinp')
        l2 = lnblnk1(arg) + lnblnk1('.egsinp')
        IF (( l2 .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'input file name is too long ',l2
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        input_file = arg(:lnblnk1(arg))
      END IF
      have_arg = .false.
      DO 9411 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-o') .AND. arg(:l) .EQ. '-o' ) .OR. ( l
     *  .EQ. lnblnk1('--output') .AND. arg(:l) .EQ. '--output' ) )) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO9412
        END IF
9411  CONTINUE
9412  CONTINUE
      IF (( have_arg )) THEN
        l = lnblnk1(arg)
        IF (( l .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'output file name is too long ',l
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        output_file(:l) = arg(:lnblnk1(arg))
      ELSE
        IF (( lnblnk1(input_file) .GT. 0 )) THEN
          output_file(:lnblnk1(input_file)) = input_file(:lnblnk1(input_
     *    file))
        ELSE
          output_file = 'test'
        END IF
      END IF
      return
      end
      subroutine egs_open_units(flag)
      implicit none
      logical flag
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character tmp_string*1024, tmp1_string*1024, tmp2_string*1024, uco
     *de_dir*1024, input_line*100, arg*20
      integer i,lnblnk1,u,l,istart,egs_get_unit,i_iofile
      logical ex,is_open
      DO 9421 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
9421  CONTINUE
9422  CONTINUE
      DO 9431 i=1,len(ucode_dir)
        ucode_dir(i:i) = ' '
9431  CONTINUE
9432  CONTINUE
      ucode_dir = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(use
     *r_code)) // '/'
      IF (( flag )) THEN
        tmp_string = ucode_dir(:lnblnk1(ucode_dir)) // work_dir(:lnblnk1
     *  (work_dir))
      ELSE
        tmp_string = ucode_dir(:lnblnk1(ucode_dir))
      END IF
      tmp_string = tmp_string(:lnblnk1(tmp_string)) // output_file(:lnbl
     *nk1(output_file))
      IF (( i_parallel .GT. 0 )) THEN
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // '_w'
        call egs_itostring(tmp_string,i_parallel,.false.)
      END IF
      DO 9441 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
9441  CONTINUE
9442  CONTINUE
      i_log=6
      IF (( is_batch )) THEN
        tmp1_string = tmp_string(:lnblnk1(tmp_string)) // '.egslog'
        open(i_log,file=tmp1_string,status='unknown',err=9450)
      END IF
      DO 9461 i=1,len(tmp2_string)
        tmp2_string(i:i) = ' '
9461  CONTINUE
9462  CONTINUE
      tmp2_string = ucode_dir(:lnblnk1(ucode_dir)) // user_code(:lnblnk1
     *(user_code)) // '.io'
      inquire(file=tmp2_string,exist=ex)
      n_files = 0
      IF (( ex )) THEN
        i_iofile=99
        i_iofile=egs_get_unit(i_iofile)
        IF ((i_iofile.LT.1)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for .io
     *file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_iofile,file=tmp2_string,status='old',err=9470)
9481    CONTINUE
          read(i_iofile,'(a)',err=9490,end=9490) input_line
          IF((input_line(1:1) .EQ. '#'))GO TO9481
          read(input_line,*,err=9500,end=9500) u
          istart = 1
          DO 9511 i=lnblnk1(input_line),1,-1
            IF (( input_line(i:i) .EQ. ' ' )) THEN
              istart = i+1
              GO TO9512
            END IF
9511      CONTINUE
9512      CONTINUE
          DO 9521 i=1,len(arg)
            arg(i:i) = ' '
9521      CONTINUE
9522      CONTINUE
          DO 9531 i=istart,lnblnk1(input_line)
            arg(i+1-istart:i+1-istart) = input_line(i:i)
9531      CONTINUE
9532      CONTINUE
          inquire(unit=u,opened=is_open)
          IF (( is_open )) THEN
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,'(a,i3,a,a,a,/,a,/,a,/)') 'Unit ',u,' which you
     *want to connect to a ', arg(:lnblnk1(arg)),' file ', 'is already i
     *n use. Will assume this code is being used as', 'a shared library
     *source and this file will be opened explicitly.'
          ELSE
            n_files = n_files + 1
            IF (( n_files .GT. 20 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'Too many units requested in .io.', ' Incre
     *as $mx_units and retry'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            file_units(n_files) = u
            DO 9541 i=1,len(file_extensions(n_files))
              file_extensions(n_files)(i:i) = ' '
9541        CONTINUE
9542        CONTINUE
            l = lnblnk1(arg)
            IF (( l .GT. 10 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'extension ',arg(:lnblnk1(arg)),' is longer
     * than ', 10,' chars. ', 'Increase $max_extension_length and retry
     *'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            file_extensions(n_files) = arg(:lnblnk1(arg))
            tmp1_string = tmp_string(:lnblnk1(tmp_string)) // arg(:lnbln
     *      k1(arg))
            open(u,file=tmp1_string,status='unknown')
          END IF
9500      CONTINUE
        GO TO 9481
9482    CONTINUE
9490    close(i_iofile)
      END IF
      return
9450  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open output file ',tmp1_string(:lnblnk1(
     *tmp1_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
9470  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open existing .io file',tmp2_string(:lnb
     *lnk1(tmp2_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_finish
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/my_times/ t_elapsed, t_cpu, t_first
      real*8 t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      character line*80,base*512,base1*512,tmp_string*512,junk_file*128,
     *fname*512
      character dattim*24
      integer i,l,lnblnk1,istat,egs_system,n_open,unlink,i_junk,egs_get_
     *unit
      logical is_open,egs_isdir
      real*8 t1,t2,tt_cpu
      DO 9551 i=1,len(line)
        line(i:i) = '='
9551  CONTINUE
9552  CONTINUE
      IF (( n_parallel .EQ. 0 .OR. i_parallel .GT. 0 )) THEN
        t_elapsed = egs_tot_time(1)
        tt_cpu = egs_etime() - t_cpu
        t1 = t_elapsed
        t2 = t1/3600
        write(i_log,'(//a,/,a,/)') line,'Finished simulation'
        write(i_log,'(2x,a,t30,f9.1,a,f7.3,a)') 'Elapsed time: ',t1,' s
     *(',t2,' h)'
        t1 = tt_cpu
        t2 = t1/3600
        write(i_log,'(2x,a,t30,f9.1,a,f7.3,a)') 'CPU time:',t1,' s (',t2
     *  ,' h)'
        write(i_log,'(2x,a,t30,f10.3)') 'Ratio:',t_elapsed/tt_cpu
      END IF
      call egs_get_fdate(dattim)
      write(i_log,'(//a,t56,a,/,a)') 'End of run ',dattim,line
      n_open=0
      DO 9561 i=1,len(base)
        base(i:i) = ' '
9561  CONTINUE
9562  CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e))
      DO 9571 i=1,99
        IF (( is_batch .OR. i .NE. i_log )) THEN
          inquire(i,opened=is_open)
          IF (( is_open )) THEN
            inquire(i,name=fname)
            IF ((index(fname(:lnblnk1(fname)),base(:lnblnk1(base))).GT.0
     *      )) THEN
              close(i)
              n_open = n_open+1
            END IF
          END IF
        END IF
9571  CONTINUE
9572  CONTINUE
      IF (( lnblnk1(work_dir) .EQ. 0 )) THEN
        return
      END IF
      DO 9581 i=1,len(base)
        base(i:i) = ' '
9581  CONTINUE
9582  CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e)) // '/' // work_dir(:lnblnk1(work_dir))
      DO 9591 i=1,lnblnk1(base)
        IF (( base(i:i) .EQ. '/' )) THEN
          base(i:i) = '/'
        END IF
9591  CONTINUE
9592  CONTINUE
      IF (( egs_isdir(base) )) THEN
        DO 9601 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
9601    CONTINUE
9602    CONTINUE
        DO 9611 i=1,len(junk_file)
          junk_file(i:i) = ' '
9611    CONTINUE
9612    CONTINUE
        junk_file = work_dir(:lnblnk1(work_dir))
        l = lnblnk1(junk_file)
        junk_file(l:l) = ' '
        junk_file = junk_file(:lnblnk1(junk_file)) // '_junk'
        tmp_string = base(:lnblnk1(base)) // junk_file(:lnblnk1(junk_fil
     *  e))
        i_junk=99
        i_junk=egs_get_unit(i_junk)
        IF ((i_junk.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for junk
     * file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_junk,file=tmp_string,status='unknown')
        write(i_junk,*) 'junk'
        close(i_junk)
        DO 9621 i=1,len(base1)
          base1(i:i) = ' '
9621    CONTINUE
9622    CONTINUE
        base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_c
     *  ode)) // '/' // work_dir(:lnblnk1(work_dir))
        base1 = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_
     *  code))
        DO 9631 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
9631    CONTINUE
9632    CONTINUE
        tmp_string = 'mv -f ' // base(:lnblnk1(base)) // '*  ' // base1(
     *  :lnblnk1(base1))
        l = lnblnk1(tmp_string)+1
        tmp_string(l:l) = char(0)
        istat = egs_system(tmp_string)
        IF (( istat .NE. 0 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'Moving files from working directory failed ?'
          write(i_log,*) '=> will not remove working directory'
        ELSE
          DO 9641 i=1,len(tmp_string)
            tmp_string(i:i) = ' '
9641      CONTINUE
9642      CONTINUE
          tmp_string = 'rm -rf ' // base(:lnblnk1(base))
          l = lnblnk1(tmp_string)+1
          tmp_string(l:l) = char(0)
          istat = egs_system(tmp_string)
          IF (( istat .NE. 0 )) THEN
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,*) 'Failed to remove working directory ', work_d
     *      ir(:lnblnk1(work_dir))
          END IF
          DO 9651 i=1,len(tmp_string)
            tmp_string(i:i) = ' '
9651      CONTINUE
9652      CONTINUE
          tmp_string = base1(:lnblnk1(base1)) // '/' // junk_file(:lnbln
     *    k1(junk_file))
          l = lnblnk1(tmp_string)+1
          tmp_string(l:l) = char(0)
          istat = unlink(tmp_string)
        END IF
      END IF
      DO 9661 i=1,len(work_dir)
        work_dir(i:i) = ' '
9661  CONTINUE
9662  CONTINUE
      return
      end
      subroutine egs_set_defaults
      implicit none
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,6), eno_array(200,6), eno_atbin_array(200,6), n_sh
     *ell(6), radc_flag,  ibcmp( 2001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      common/ET_control/ smaxir( 2001),estepe,ximax,  skindepth_for_bca,
     *transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PHOTIN/ EBINDA(6), GE0(6),GE1(6), GMFP0(2000,6),GMFP1(2000,
     *6),GBR10(2000,6),GBR11(2000,6),GBR20(2000,6),GBR21(2000,6), RCO0(6
     *),RCO1(6), RSCT0(100,6),RSCT1(100,6), COHE0(2000,6),COHE1(2000,6),
     *  PHOTONUC0(2000,6),PHOTONUC1(2000,6), DPMFP, MPGEM(1,6), NGR(6)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      real*8 SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/spin_data/ spin_rej(6,0:1,0: 31,0:15,0:31), espin_min,espin
     *_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dleneri,dq
     *q1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(6), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),  e
     *ii_sh(40),  eii_nshells(100),  eii_nsh(6),  eii_first(6,50),  eii_
     *no(6,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      COMMON/rayleigh_inputs/iray_ff_media(6),iray_ff_file(6)
      character*24 iray_ff_media
      character*128 iray_ff_file
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      integer i,j,lnblnk1
      CHARACTER*4 MEDIA1(24)
      EQUIVALENCE(MEDIA1(1),MEDIA(1,1))
      character fool_dec
      data MEDIA1/'N','A','I',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','
     *',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '/
      data fool_dec/'/'/
      data fool_intel_optimizer/.false./
      vacdst = 1e8
      DO 9671 i=1, 2001
        ecut(i) = 0.
        pcut(i) = 0.
        ibcmp(i) = 3
        iedgfl(i) = 1
        iphter(i) = 1
        smaxir(i) = 1e10
        i_do_rr(i) = 0
        e_max_rr(i) = 0
        med(i) = 1
        rhor(i) = 0
        iraylr(i) = 1
        iphotonucr(i) = 0
9671  CONTINUE
9672  CONTINUE
      eii_flag = 0
      eii_xfile = 'Off'
      eii_L_factor = 1.0
      xsec_out = 0
      photon_xsections = 'xcom'
      comp_xsections = 'default'
      eadl_relax = .true.
      mcdf_pe_xsections = .false.
      photonuc_xsections = 'default'
      ExIN=0
      EyIN=0
      EzIN=0
      BxIN=0
      ByIN=0
      BzIN=0
      EMLMTIN=0.02
      Bx=BxIN
      By=ByIN
      Bz=BzIN
      Bx_new=Bx
      By_new=By
      Bz_new=Bz
      emfield_on=.false.
      IF (( ExIN**2+EyIN**2+EzIN**2 + BxIN**2+ByIN**2+BzIN**2 .GT. 0 ))
     *THEN
        emfield_on=.true.
      END IF
      DO 9681 i=1,6
        iraylm(i) = 0
        DO 9691 j=1,len(iray_ff_file(i))
          iray_ff_file(i)(j:j) = ' '
9691    CONTINUE
9692    CONTINUE
        DO 9701 j=1,len(iray_ff_media(i))
          iray_ff_media(i)(j:j) = ' '
9701    CONTINUE
9702    CONTINUE
        ae(i)=0
        ap(i)=0
        ue(i)=0
        up(i)=0
        te(i)=0
        thmoll(i)=0
9681  CONTINUE
9682  CONTINUE
      DO 9711 i=1,30
        DO 9721 j=1,100
          binding_energies(i,j) = 0
9721    CONTINUE
9722    CONTINUE
9711  CONTINUE
9712  CONTINUE
      ibrdst = 1
      ibr_nist = 0
      pair_nrc = 0
      itriplet = 0
      iprdst = 1
      rhof = 1
      DO 9731 i=1,5
        iausfl(i) = 1
9731  CONTINUE
9732  CONTINUE
      DO 9741 i=6,35
        iausfl(i) = 0
9741  CONTINUE
9742  CONTINUE
      ximax = 0.5
      estepe = 0.25
      skindepth_for_bca = 3
      transport_algorithm = 0
      bca_algorithm = 0
      exact_bca = .true.
      spin_effects = .true.
      count_pII_steps = 0
      count_all_steps = 0
      radc_flag = 0
      nmed = 1
      kmpi = 12
      kmpo = 8
      dunit = 1
      rng_seed = 999999
      latchi = 0
      rmt2 = 2*rm
      rmsq = rm*rm
      pi = 4*datan(1d0)
      twopi = 2*pi
      pi5d2 = 2.5*pi
      nbr_split = 1
      i_play_RR = 0
      i_survived_RR = 0
      prob_RR = -1
      n_RR_warning = 0
      DO 9751 i=1,len(hen_house)
        hen_house(i:i) = ' '
9751  CONTINUE
9752  CONTINUE
      i = lnblnk1('/home/miia/EGSnrc/HEN_HOUSE/')
      hen_house(:i) = '/home/miia/EGSnrc/HEN_HOUSE/'
      IF (( '/' .NE. fool_dec )) THEN
        DO 9761 j=1,i
          IF((hen_house(j:j) .EQ. '/'))hen_house(j:j) = '/'
9761    CONTINUE
9762    CONTINUE
      END IF
      IF((hen_house(i:i) .NE. '/'))hen_house(i+1:i+1) = '/'
      n_files = 0
      DO 9771 i=1,len(egs_home)
        egs_home(i:i) = ' '
9771  CONTINUE
9772  CONTINUE
      call getenv('EGS_HOME',egs_home)
      i = lnblnk1(egs_home)
      IF (( '/' .NE. fool_dec )) THEN
        DO 9781 j=1,i
          IF((egs_home(j:j) .EQ. '/'))egs_home(j:j) = '/'
9781    CONTINUE
9782    CONTINUE
      END IF
      IF((i .GT. 0 .AND. egs_home(i:i) .NE. '/'))egs_home(i+1:i+1) = '/'
      DO 9791 i=1,len(input_file)
        input_file(i:i) = ' '
9791  CONTINUE
9792  CONTINUE
      DO 9801 i=1,len(output_file)
        output_file(i:i) = ' '
9801  CONTINUE
9802  CONTINUE
      DO 9811 i=1,len(work_dir)
        work_dir(i:i) = ' '
9811  CONTINUE
9812  CONTINUE
      DO 9821 i=1,len(pegs_file)
        pegs_file(i:i) = ' '
9821  CONTINUE
9822  CONTINUE
      DO 9831 i=1,len(host_name)
        host_name(i:i) = ' '
9831  CONTINUE
9832  CONTINUE
      n_parallel = 0
      i_parallel = 0
      n_chunk = 0
      is_batch = .false.
      first_parallel = 1
      return
      end
      subroutine egs_combine_runs(combine_routine,extension)
      implicit none
      external combine_routine
      character*(*) extension
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*1024 tmp_string,base,command,outfile,parfile_name,base1,
     * text_string
      integer lnblnk1,istat,ipar,egs_system,egs_open_file
      integer*4 i,k,j,numparfiles,textindex
      logical ex,iwin
      iwin=.false.
      DO 9841 i=1,len(base)
        base(i:i) = ' '
9841  CONTINUE
9842  CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e)) // '/' // output_file(:lnblnk1(output_file)) // '_w'
      DO 9851 i=1,len(base1)
        base1(i:i) = ' '
9851  CONTINUE
9852  CONTINUE
      base1 = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_co
     *de)) // '/' // output_file(:lnblnk1(output_file)) // '_w*' // exte
     *nsion(:lnblnk1(extension))
      DO 9861 i=1,len(outfile)
        outfile(i:i) = ' '
9861  CONTINUE
9862  CONTINUE
      outfile = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_
     *code)) // '/' // 'parfiles_tmp'
      DO 9871 i=1,len(command)
        command(i:i) = ' '
9871  CONTINUE
9872  CONTINUE
      command = 'ls ' // base1(:lnblnk1(base1)) // ' | wc -l > ' // outf
     *ile(:lnblnk1(outfile))
      istat = egs_system(command(:lnblnk1(command)))
      IF ((istat.NE.0)) THEN
        command = 'dir ' // base1(:lnblnk1(base1)) // ' | find "File(s)"
     * > ' // outfile(:lnblnk1(outfile))
        istat = egs_system(command(:lnblnk1(command)))
        IF ((istat.NE.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) ' Failed to write number of output files from p
     *arallel runs.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        ELSE
          iwin=.true.
        END IF
      END IF
      ipar=1
      ipar=egs_open_file(ipar,0,1,outfile(:lnblnk1(outfile)))
      IF ((iwin)) THEN
        read(ipar,'(a)',err=9880,end=9880) text_string
        text_string = text_string(:lnblnk1(text_string))
        textindex = index(text_string,'File(s)')
        text_string = text_string(:textindex-1)
        read(text_string,'(i256)',err=9880) numparfiles
      ELSE
        read(ipar,'(i256)',err=9880,end=9880) numparfiles
      END IF
      close(ipar)
      DO 9891 i=1,len(command)
        command(i:i) = ' '
9891  CONTINUE
9892  CONTINUE
      IF ((iwin)) THEN
        command = 'del /Q ' // outfile(:lnblnk1(outfile))
      ELSE
        command = 'rm -f ' // outfile(:lnblnk1(outfile))
      END IF
      istat = egs_system(command(:lnblnk1(command)))
      IF ((istat.NE.0)) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Failed to delete list of output files from para
     *llel runs.'
      END IF
      k=1
      j=1
9901  IF(j.GT.numparfiles)GO TO 9902
        DO 9911 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
9911    CONTINUE
9912    CONTINUE
        tmp_string = base(:lnblnk1(base))
        call egs_itostring(tmp_string,k,.false.)
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // extension(:lnbl
     *  nk1(extension))
        inquire(file=tmp_string,exist=ex)
        IF (( ex )) THEN
          call combine_routine(tmp_string)
          j=j+1
        END IF
        k=k+1
      GO TO 9901
9902  CONTINUE
      return
9880  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' Failed to read number of output files from parall
     *el runs.'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      logical function egs_strip_extension(filen,fext)
      implicit none
      character*(*) filen,fext
      integer l1,l2,lnblnk1,i
      l1 = lnblnk1(filen)
      l2 = lnblnk1(fext)
      IF (( l1 .GE. l2 .AND. filen(l1-l2+1:l1) .EQ. fext(:l2) )) THEN
        egs_strip_extension = .true.
        DO 9921 i=l1-l2+1,len(filen)
          filen(i:i) = ' '
9921    CONTINUE
9922    CONTINUE
      ELSE
        egs_strip_extension = .false.
      END IF
      return
      end
      logical function egs_is_absolute_path(fn)
      implicit none
      character*(*) fn
      integer i,lnblnk1
      DO 9931 i=1,lnblnk1(fn)
        IF (( fn(i:i) .EQ. '/' )) THEN
          egs_is_absolute_path = .true.
          return
        END IF
9931  CONTINUE
9932  CONTINUE
      egs_is_absolute_path = .false.
      return
      end
      integer function egs_get_unit(iunit)
      implicit none
      integer*4 iunit, i
      logical is_open
      IF (( iunit .GT. 0 )) THEN
        inquire(iunit,opened=is_open)
        IF (( .NOT.is_open )) THEN
          egs_get_unit = iunit
          return
        END IF
      END IF
      DO 9941 i=1,99
        inquire(i,opened=is_open)
        IF (( .NOT.is_open )) THEN
          egs_get_unit = i
          return
        END IF
9941  CONTINUE
9942  CONTINUE
      egs_get_unit = -1
      return
      end
      integer function egs_open_file(iunit,rl,action,extension)
      implicit none
      integer*4 iunit, rl, action
      character*(*) extension
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      logical egs_is_absolute_path,is_open
      integer egs_get_unit
      integer i,lnblnk1
      character*1024 tmp_string,error_string
      integer*4 the_unit
      egs_open_file = -1
      the_unit = egs_get_unit(iunit)
      IF (( the_unit .LT. 0 )) THEN
        IF (( action .EQ. 0 )) THEN
          egs_open_file = -1
          return
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'No free Fortran I/O units left'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( egs_is_absolute_path(extension) )) THEN
        inquire(file=extension,opened=is_open)
        IF ((is_open)) THEN
          inquire(file=extension,number=the_unit)
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,'(a,a,/,a,i3,/,a,/,a)') 'File ',extension(:lnblnk1
     *    (extension)), ' is already opened and connected to unit ',the_
     *    unit, ' Will not try to re-open this file, assuming it has bee
     *n opened', ' by the .io file.'
        ELSE IF(( rl .EQ. 0 )) THEN
          open(the_unit,file=extension,status='unknown')
        ELSE
          open(the_unit,file=extension,status='unknown',form='unformatte
     *d', access='direct', recl=rl)
        END IF
        egs_open_file = the_unit
        return
      END IF
      DO 9951 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
9951  CONTINUE
9952  CONTINUE
      tmp_string = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(us
     *er_code)) // '/' // work_dir(:lnblnk1(work_dir)) // output_file(:l
     *nblnk1(output_file))
      IF (( i_parallel .GT. 0 )) THEN
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // '_w'
        call egs_itostring(tmp_string,i_parallel,.false.)
      END IF
      tmp_string = tmp_string(:lnblnk1(tmp_string)) // extension(:lnblnk
     *1(extension))
      inquire(file=tmp_string,opened=is_open)
      IF ((is_open)) THEN
        inquire(file=tmp_string,number=the_unit)
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,'(a,a,/,a,i3,/,a,/,a,/)') 'File ',tmp_string(:lnblnk
     *  1(tmp_string)), ' is already opened and connected to unit ',the_
     *  unit, ' Will not try to re-open this file, assuming it has been
     *opened', ' by specifying it in the .io file.'
      ELSE IF(( rl .EQ. 0 )) THEN
        open(the_unit,file=tmp_string,status='unknown',err=9960)
      ELSE
        open(the_unit,file=tmp_string,status='unknown',form='unformatted
     *', access='direct', recl=rl,err=9960)
      END IF
      egs_open_file = the_unit
      return
9960  error_string = 'In egs_open_file: failed to open file ' // tmp_str
     *ing(:lnblnk1(tmp_string)) // char(10) // 'iunit = '
      call egs_itostring(error_string,iunit,.false.)
      error_string = error_string(:lnblnk1(error_string)) // ' the_unit
     *= '
      call egs_itostring(error_string,the_unit,.false.)
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a)') error_string(:lnblnk1(error_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      integer function egs_open_datfile(iunit,rl,action,extension)
      implicit none
      integer*4 iunit,rl,action
      character*(*) extension
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer i,the_unit,lnblnk1,egs_get_unit
      logical egs_is_absolute_path
      character base*1024, fn*1024
      egs_open_datfile = -1
      the_unit = egs_get_unit(iunit)
      IF (( the_unit .LT. 0 )) THEN
        IF (( action .EQ. 0 )) THEN
          egs_open_datfile = -1
          return
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'No free Fortran I/O units left'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( egs_is_absolute_path(extension) )) THEN
        IF (( rl .EQ. 0 )) THEN
          open(the_unit,file=extension,status='old',err=9970)
        ELSE
          open(the_unit,file=extension,status='old',form='unformatted',
     *    access='direct',recl=rl,err=9970)
        END IF
        egs_open_datfile = the_unit
        return
9970    CONTINUE
        IF (( action .EQ. 0 )) THEN
          egs_open_datfile = -2
          return
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Failed to open file ',extension(:lnblnk1(extensi
     *  on))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      DO 9981 i=1,len(base)
        base(i:i) = ' '
9981  CONTINUE
9982  CONTINUE
      DO 9991 i=1,len(fn)
        fn(i:i) = ' '
9991  CONTINUE
9992  CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e)) // '/'
      IF (( i_parallel .GT. 0 )) THEN
        fn = base(:lnblnk1(base)) // output_file(:lnblnk1(output_file))
     *  // '_w'
        call egs_itostring(fn,i_parallel,.false.)
        fn = fn(:lnblnk1(fn)) // extension(:lnblnk1(extension))
      ELSE
        fn = base(:lnblnk1(base)) // output_file(:lnblnk1(output_file))
     *  // extension(:lnblnk1(extension))
      END IF
      IF (( rl .EQ. 0 )) THEN
        open(the_unit,file=fn,status='old',err=10000)
      ELSE
        open(the_unit,file=fn,status='old',form='unformatted',access='di
     *rect', recl=rl,err=10000)
      END IF
      egs_open_datfile = the_unit
      return
10000 CONTINUE
      write(i_log,'(/a)') '***************** Warning: '
      write(i_log,'(a,a)') 'Failed to open ',fn(:lnblnk1(fn))
      DO 10011 i=1,len(fn)
        fn(i:i) = ' '
10011 CONTINUE
10012 CONTINUE
      IF (( i_parallel .GT. 0 )) THEN
        fn = base(:lnblnk1(base)) // input_file(:lnblnk1(input_file)) //
     *   '_w'
        call egs_itostring(fn,i_parallel,.false.)
        fn = fn(:lnblnk1(fn)) // extension(:lnblnk1(extension))
      ELSE
        fn = base(:lnblnk1(base)) // input_file(:lnblnk1(input_file)) //
     *   extension(:lnblnk1(extension))
      END IF
      IF (( rl .EQ. 0 )) THEN
        open(the_unit,file=fn,status='old',err=10020)
      ELSE
        open(the_unit,file=fn,status='old',form='unformatted',access='di
     *rect', recl=rl,err=10020)
      END IF
      egs_open_datfile = the_unit
      return
10020 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Failed to open data file'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      integer function egs_open_file_junk(iunit,do_it_anyway,filen)
      implicit none
      integer*4 iunit
      logical do_it_anyway
      character*(*) filen
      logical aux
      integer*4 the_unit,i
      inquire(file=filen,exist=aux)
      IF (( .NOT.aux )) THEN
        egs_open_file_junk = -2
        return
      END IF
      IF (( iunit .LT. 0 )) THEN
        the_unit = -iunit
      ELSE
        the_unit = iunit
      END IF
      IF (( the_unit .NE. 0 )) THEN
        inquire(unit=the_unit,opened=aux)
        IF (( aux )) THEN
          IF (( .NOT.do_it_anyway )) THEN
            egs_open_file_junk = -4
            return
          END IF
          IF((iunit .LT. 0))the_unit = 0
        END IF
      END IF
      IF (( the_unit .EQ. 0 )) THEN
        DO 10031 i=1,99
          inquire(unit=i,opened=aux)
          IF (( .NOT.aux )) THEN
            the_unit = i
            GO TO10032
          END IF
10031   CONTINUE
10032   CONTINUE
        IF (( the_unit .EQ. 0 )) THEN
          egs_open_file_junk = -1
          return
        END IF
      END IF
      open(the_unit,file=filen,status='old',err=10040)
      egs_open_file_junk = the_unit
      return
10040 egs_open_file_junk = -3
      return
      end
      subroutine egs_strip_path(fname)
      implicit none
      character*(*) fname
      integer i,l,l1,lnblnk1,j
      character slash
      slash = '/'
      l = lnblnk1(fname)
      DO 10051 i=1,l
        IF (( fname(i:i) .EQ. slash )) THEN
          fname(i:i) = '/'
        END IF
10051 CONTINUE
10052 CONTINUE
      DO 10061 i=l,1,-1
        IF (( fname(i:i) .EQ. '/' .OR. fname(i:i) .EQ. slash )) THEN
          l1 = l-i
          fname(:l1) = fname(i+1:l)
          DO 10071 j=l1+1,len(fname)
            fname(j:j) = ' '
10071     CONTINUE
10072     CONTINUE
          return
        END IF
10061 CONTINUE
10062 CONTINUE
      return
      end
      subroutine replace_env(fname)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*(*) fname
      character*256 dirname
      integer indsep,ind1,ind2
      indsep = index(fname,'/')
      IF((indsep .LE. 0))return
      ind1=index(fname,'$')
      ind2=index(fname,'~')
      IF ((ind1.EQ.1)) THEN
        call getenv(fname(2:indsep-1),dirname)
        IF ((dirname.EQ.' ')) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,a/,a)') ' Error in file name: ',fname(:lnblnk1
     *    (fname)), ' First element in name does not specify a defined e
     *nvironment variable.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        fname=dirname(:lnblnk1(dirname))//fname(indsep:)
        write(i_log,'(//a,a/)') ' Retrieving file: ',fname(:lnblnk1(fnam
     *  e))
      ELSE IF((ind2.EQ.1)) THEN
        call getenv('HOME',dirname)
        IF ((dirname.EQ.' ')) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,a/,a)') ' Error in file name: ',fname(:lnblnk1
     *    (fname)), ' HOME is undefined.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        fname=dirname(:lnblnk1(dirname))//fname(indsep:)
        write(i_log,'(//a,a/)') ' Retrieving file: ',fname(:lnblnk1(fnam
     *  e))
      END IF
      return
      end
      subroutine egs_get_usercode(ucode)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*(*) ucode
      character*512 arg
      integer l,l1,lnblnk1,i
      call getarg(0,arg)
      call egs_strip_path(arg)
      l = lnblnk1(arg)
      IF (( arg(l-3:l) .EQ. '.exe' )) THEN
        arg(l-3:l) = ' '
        l = l - 4
      END IF
      IF (( arg(l-5:l) .EQ. '_debug' )) THEN
        arg(l-5:l) = ' '
        l = l-5
      END IF
      IF (( arg(l-5:l) .EQ. '_noopt' )) THEN
        arg(l-5:l) = ' '
        l = l-5
      END IF
      l1 = len(ucode)
      IF (( l .GT. l1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' user code name is too long (',l,' chars)'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      DO 10081 i=1,len(ucode)
        ucode(i:i) = ' '
10081 CONTINUE
10082 CONTINUE
      ucode(:l) = arg(:l)
      return
      end
      subroutine egs_itostring(string,i,leave_space)
      implicit none
      character*(*) string
      integer*4 i
      integer l,lnblnk1,idiv,itmp,iaux
      logical first,leave_space
      l = lnblnk1(string)+1
      IF((l .GT. 1 .AND. leave_space))l=l+1
      idiv = 1000000000
      itmp = i
      first = .false.
      do while(idiv.gt.0)
      iaux = itmp/idiv
      IF (( (iaux .GT. 0 .OR. first ) .AND. l .LE. len(string) )) THEN
        string(l:l) = char(iaux+48)
        first = .true.
        l = l+1
      END IF
      itmp = itmp - iaux*idiv
      idiv = idiv/10
      end do
      return
      end
      real*8 function egs_rndm()
      implicit none
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      IF((rng_seed .GT. 128))call ranmar_get
      egs_rndm = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      return
      end
      integer function egs_add_medium(medname)
      implicit none
      character*(*) medname
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,l,imed,medname_len
      character c
      logical same
      l = min(len(medname),24)
      medname_len = l
      DO 10091 i=1,l
        c = medname(i:i)
        IF (( ichar(c) .EQ. 0 )) THEN
          medname_len = i-1
          GO TO10092
        END IF
10091 CONTINUE
10092 CONTINUE
      DO 10101 imed=1,nmed
        l = 24
        DO 10111 i=1,24
          IF (( media(i,imed)(1:1) .EQ. ' ' )) THEN
            l = i-1
            GO TO10112
          END IF
10111   CONTINUE
10112   CONTINUE
        IF (( l .EQ. medname_len )) THEN
          same = .true.
          DO 10121 i=1,l
            c = medname(i:i)
            IF (( c .NE. media(i,imed)(1:1) )) THEN
              same = .false.
              GO TO10122
            END IF
10121     CONTINUE
10122     CONTINUE
          IF (( same )) THEN
            egs_add_medium = imed
            return
          END IF
        END IF
10101 CONTINUE
10102 CONTINUE
      nmed = nmed + 1
      IF (( nmed .GT. 6 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(a,/,a,i3,a)') 'In egs_add_medium: maximum number o
     *f media exceeded ', 'Increase the macro $MXMED (currently ',6,') a
     *nd retry'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      l = min(len(medname),24)
      DO 10131 i=1,l
        c = medname(i:i)
        IF (( ichar(c) .EQ. 0 )) THEN
          l = i-1
          GO TO10132
        END IF
        media(i,nmed) = ' '
        media(i,nmed)(1:1) = c
10131 CONTINUE
10132 CONTINUE
      IF (( l .LT. 24 )) THEN
        DO 10141 i=l+1,24
          media(i,nmed) = ' '
10141   CONTINUE
10142   CONTINUE
      END IF
      egs_add_medium = nmed
      return
      end
      subroutine egs_get_medium_name(imed,medname)
      implicit none
      character*(*) medname
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,l,imed
      DO 10151 i=1,len(medname)
        medname(i:i) = ' '
10151 CONTINUE
10152 CONTINUE
      IF (( imed .LT. 1 .OR. imed .GT. nmed )) THEN
        return
      END IF
      l = 24
      DO 10161 l=24,1,-1
        IF((media(l,imed)(1:1) .NE. ' '))GO TO10162
10161 CONTINUE
10162 CONTINUE
      l = min(l,len(medname))
      DO 10171 i=1,l
        medname(i:i) = media(i,imed)(1:1)
10171 CONTINUE
10172 CONTINUE
      return
      end
      subroutine egs_get_electron_data(func,imed,which)
      implicit none
      integer*4 imed,which
      external func
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 lemin,lemax
      lemin = (1 - eke0(imed))/eke1(imed)
      lemax = (meke(imed) - eke0(imed))/eke1(imed)
      IF (( which .EQ. 1 )) THEN
        call func(meke(imed),lemin,lemax,esig0(1,imed),esig1(1,imed))
      ELSE IF(( which .EQ. 2 )) THEN
        call func(meke(imed),lemin,lemax,psig0(1,imed),psig1(1,imed))
      ELSE IF(( which .EQ. 3 )) THEN
        call func(meke(imed),lemin,lemax,ededx0(1,imed),ededx1(1,imed))
      ELSE IF(( which .EQ. 4 )) THEN
        call func(meke(imed),lemin,lemax,pdedx0(1,imed),pdedx1(1,imed))
      ELSE IF(( which .EQ. 5 )) THEN
        call func(meke(imed),lemin,lemax,ebr10(1,imed),ebr11(1,imed))
      ELSE IF(( which .EQ. 6 )) THEN
        call func(meke(imed),lemin,lemax,pbr10(1,imed),pbr11(1,imed))
      ELSE IF(( which .EQ. 7 )) THEN
        call func(meke(imed),lemin,lemax,pbr20(1,imed),pbr21(1,imed))
      ELSE IF(( which .EQ. 8 )) THEN
        call func(meke(imed),lemin,lemax,tmxs0(1,imed),tmxs1(1,imed))
      ELSE IF(( which .EQ. 9 )) THEN
        call func(meke(imed),lemin,lemax,range_ep(0,1,imed),range_ep(1,1
     *  ,imed))
      ELSE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Unknown electron data type ',which
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      return
      end
      subroutine egs_get_photon_data(func,imed,which)
      implicit none
      integer*4 imed,which
      external func
      COMMON/PHOTIN/ EBINDA(6), GE0(6),GE1(6), GMFP0(2000,6),GMFP1(2000,
     *6),GBR10(2000,6),GBR11(2000,6),GBR20(2000,6),GBR21(2000,6), RCO0(6
     *),RCO1(6), RSCT0(100,6),RSCT1(100,6), COHE0(2000,6),COHE1(2000,6),
     *  PHOTONUC0(2000,6),PHOTONUC1(2000,6), DPMFP, MPGEM(1,6), NGR(6)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 lemin,lemax
      lemin = (1 - ge0(imed))/ge1(imed)
      lemax = (mge(imed) - ge0(imed))/ge1(imed)
      IF (( which .EQ. 1 )) THEN
        call func(mge(imed),lemin,lemax,gmfp0(1,imed),gmfp1(1,imed))
      ELSE IF(( which .EQ. 2 )) THEN
        call func(mge(imed),lemin,lemax,gbr10(1,imed),gbr11(1,imed))
      ELSE IF(( which .EQ. 3 )) THEN
        call func(mge(imed),lemin,lemax,gbr20(1,imed),gbr21(1,imed))
      ELSE IF(( which .EQ. 4 )) THEN
        call func(mge(imed),lemin,lemax,cohe0(1,imed),cohe1(1,imed))
      ELSE IF(( which .EQ. 5 )) THEN
        call func(mge(imed),lemin,lemax,PHOTONUC0(1,imed),PHOTONUC1(1,im
     *  ed))
      ELSE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Unknown photon data type ',which
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      return
      end
      subroutine egs_print_binding_energies
      implicit none
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,j
      integer*4 lnblnk1
      character*3 labels(16)
      data labels/'  K',' L1',' L2',' L3', ' M1',' M2',' M3',' M4',' M5'
     *, ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/
      write(i_log,'(a,a,a)') 'Binding energies from ',photon_xsections(:
     *lnblnk1(photon_xsections)), ' photon cross section library'
      DO 10181 j=1,100
        DO 10191 i=1,16
          IF (( binding_energies(i,j) .GT. 0 )) THEN
            write(i_log,'(a,i3,a,a,a,1pe12.4,a)') ' Eb(',j,',',labels(i)
     *      ,') = ',binding_energies(i,j),' MeV'
          END IF
10191   CONTINUE
10192   CONTINUE
10181 CONTINUE
10182 CONTINUE
      return
      end
      subroutine egs_scale_xcc(imed,factor)
      implicit none
      integer*4 imed
      real*8 factor
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      IF (( imed .GT. 0 .AND. imed .LE. nmed )) THEN
        xcc(imed) = xcc(imed)*factor
      END IF
      return
      end
      subroutine egs_write_string(ounit,string)
      implicit none
      integer*4 ounit
      character*(*) string
      write(ounit,'(a,$)') string
      call flush(ounit)
      return
      end
      subroutine egs_swap_2(c)
      character c(2),tmp
      tmp=c(2)
      c(2)=c(1)
      c(1)=tmp
      return
      end
      subroutine egs_swap_4(c)
      character c(4),tmp
      tmp=c(4)
      c(4)=c(1)
      c(1)=tmp
      tmp=c(3)
      c(3)=c(2)
      c(2)=tmp
      return
      end
      subroutine set_spline(x,f,a,b,c,d,n)
      implicit none
      integer*4 n
      real*8 x(n),f(n),a(n),b(n),c(n),d(n)
      integer*4 m1,m2,m,mr
      real*8 s,r
      m1 = 2
      m2 = n-1
      s = 0
      DO 10201 m=1,m2
        d(m) = x(m+1) - x(m)
        r = (f(m+1) - f(m))/d(m)
        c(m) = r - s
        s = r
10201 CONTINUE
10202 CONTINUE
      s=0
      r=0
      c(1)=0
      c(n)=0
      DO 10211 m=m1,m2
        c(m) = c(m) + r*c(m-1)
        b(m) = 2*(x(m-1) - x(m+1)) - r*s
        s = d(m)
        r = s/b(m)
10211 CONTINUE
10212 CONTINUE
      mr = m2
      DO 10221 m=m1,m2
        c(mr) = (d(mr)*c(mr+1) - c(mr))/b(mr)
        mr = mr - 1
10221 CONTINUE
10222 CONTINUE
      DO 10231 m=1,m2
        s = d(m)
        r = c(m+1) - c(m)
        d(m) = r/s
        c(m) = 3*c(m)
        b(m) = (f(m+1)-f(m))/s - (c(m)+r)*s
        a(m) = f(m)
10231 CONTINUE
10232 CONTINUE
      return
      end
      real*8 function spline(s,x,a,b,c,d,n)
      implicit none
      integer*4 n
      real*8 s,x(n),a(n),b(n),c(n),d(n)
      integer m_lower,m_upper,direction,m,ml,mu,mav
      real*8 q
      IF (( x(1) .GT. x(n) )) THEN
        direction = 1
        m_lower = n
        m_upper = 0
      ELSE
        direction = 0
        m_lower = 0
        m_upper = n
      END IF
      IF (( s .GE. x(m_upper + direction) )) THEN
        m = m_upper + 2*direction - 1
      ELSE IF(( s .LE. x(m_lower+1-direction) )) THEN
        m = m_lower - 2*direction + 1
      ELSE
        ml = m_lower
        mu = m_upper
10241   IF(iabs(mu-ml).LE.1)GO TO 10242
          mav = (ml+mu)/2
          IF (( s .LT. x(mav) )) THEN
            mu = mav
          ELSE
            ml = mav
          END IF
        GO TO 10241
10242   CONTINUE
        m = mu + direction - 1
      END IF
      q = s - x(m)
      spline = a(m) + q*(b(m) + q*(c(m) + q*d(m)))
      return
      end
      subroutine prepare_alias_table(nsbin,xs_array,fs_array,ws_array,ib
     *in_array)
      implicit none
      integer nsbin
      integer*4 ibin_array(nsbin)
      real*8 xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin)
      integer*4 i,j_l,j_h
      real*8 sum,aux
      sum = 0
      DO 10251 i=1,nsbin
        aux = 0.5*(fs_array(i)+fs_array(i-1))*(xs_array(i)-xs_array(i-1)
     *  )
        IF((aux .LT. 1e-30))aux = 1e-30
        ws_array(i) = -aux
        ibin_array(i) = 1
        sum = sum + aux
10251 CONTINUE
10252 CONTINUE
      sum = sum/nsbin
      DO 10261 i=1,nsbin-1
        DO 10271 j_h=1,nsbin
          IF (( ws_array(j_h) .LT. 0 )) THEN
            IF((abs(ws_array(j_h)) .GT. sum))GOTO 10280
          END IF
10271   CONTINUE
10272   CONTINUE
        j_h = nsbin
10280   CONTINUE
          DO 10281 j_l=1,nsbin
          IF (( ws_array(j_l) .LT. 0 )) THEN
            IF((abs(ws_array(j_l)) .LT. sum))GOTO 10290
          END IF
10281   CONTINUE
10282   CONTINUE
        j_l = nsbin
10290   aux = sum - abs(ws_array(j_l))
        ws_array(j_h) = ws_array(j_h) + aux
        ws_array(j_l) = -ws_array(j_l)/sum
        ibin_array(j_l) = j_h
        IF((i .EQ. nsbin-1))ws_array(j_h) = 1
10261 CONTINUE
10262 CONTINUE
      return
      end
      real*8 function alias_sample1(nsbin,xs_array,fs_array,ws_array,ibi
     *n_array)
      implicit none
      integer nsbin
      integer*4 ibin_array(nsbin)
      real*8 xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin)
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      integer*4 j
      real*8 r1,r2,aj,x,dx,a,rnno1
      IF((rng_seed .GT. 128))call ranmar_get
      r1 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((rng_seed .GT. 128))call ranmar_get
      r2 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      aj = 1 + r1*nsbin
      j = aj
      aj = aj - j
      IF((aj .GT. ws_array(j)))j = ibin_array(j)
      x = xs_array(j-1)
      dx = xs_array(j)-x
      IF (( fs_array(j-1) .GT. 0 )) THEN
        a = fs_array(j)/fs_array(j-1)-1
        IF (( abs(a) .LT. 0.2 )) THEN
          rnno1 = 0.5*(1-r2)*a
          alias_sample1 = x + r2*dx*(1+rnno1*(1-r2*a))
        ELSE
          alias_sample1 = x - dx/a*(1-sqrt(1+r2*a*(2+a)))
        END IF
      ELSE
        alias_sample1 = x + dx*sqrt(r2)
      END IF
      return
      end
      subroutine prepare_alias_histogram(nsbin,ws_array,ibin_array)
      implicit none
      integer*4 nsbin,ibin_array(nsbin)
      real*8 ws_array(nsbin)
      integer*4 i,j_l,j_h
      real*8 sum,aux
      sum = 0
      DO 10301 i=1,nsbin
        sum = sum + ws_array(i)
        ibin_array(i) = -1
10301 CONTINUE
10302 CONTINUE
      sum = sum/nsbin
      DO 10311 i=1,nsbin-1
        DO 10321 j_h=1,nsbin
          IF((ibin_array(j_h) .LT. 0 .AND. ws_array(j_h) .GT. sum))GO TO
     *    10322
10321   CONTINUE
10322   CONTINUE
        DO 10331 j_l=1,nsbin
          IF((ibin_array(j_l) .LT. 0 .AND. ws_array(j_l) .LT. sum))GO TO
     *    10332
10331   CONTINUE
10332   CONTINUE
        aux = sum - ws_array(j_l)
        ws_array(j_h) = ws_array(j_h) - aux
        ws_array(j_l) = ws_array(j_l)/sum
        ibin_array(j_l) = j_h
10311 CONTINUE
10312 CONTINUE
      DO 10341 i=1,nsbin
        IF (( ibin_array(i) .LT. 0 )) THEN
          ibin_array(i) = i
          ws_array(i) = 1
        END IF
10341 CONTINUE
10342 CONTINUE
      return
      end
      integer*4 function sample_alias_histogram(nsbin,ws_array,ibin_arra
     *y)
      implicit none
      integer*4 nsbin,ibin_array(*)
      real*8 ws_array(*)
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      real*8 r1,r2
      integer*4 ibin
      IF((rng_seed .GT. 128))call ranmar_get
      r1 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((rng_seed .GT. 128))call ranmar_get
      r2 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      ibin = 1 + nsbin*r1
      IF((r2 .GT. ws_array(ibin)))ibin = ibin_array(ibin)
      sample_alias_histogram = ibin
      return
      end
      subroutine gauss_legendre(x1,x2,x,w,n)
      implicit none
      integer*4 n
      real*8 x1,x2,x(n),w(n)
      real*8 eps,Pi
      parameter (eps = 3.D-14,Pi=3.141592654D0)
      integer*4 i,m,j
      real*8 xm,xl,z,z1,p1,p2,p3,pp
      m = (n + 1)/2
      xm=0.5d0*(x2+x1)
      xl=0.5d0*(x2-x1)
      DO 10351 i=1,m
        z=cos(Pi*(i-.25d0)/(n+.5d0))
10361   CONTINUE
          p1=1.d0
          p2=0.d0
          DO 10371 j=1,n
            p3 = p2
            p2 = p1
            p1=((2.d0*j-1.d0)*z*p2-(j-1.d0)*p3)/j
10371     CONTINUE
10372     CONTINUE
          pp=n*(z*p1-p2)/(z*z-1.d0)
          z1=z
          z=z1-p1/pp
          IF(((abs(z-z1) .LT. eps)))GO TO10362
        GO TO 10361
10362   CONTINUE
        x(i)=xm-xl*z
        x(n+1-i)=xm+xl*z
        w(i)=2.d0*xl/((1.d0-z*z)*pp*pp)
        w(n+1-i)=w(i)
10351 CONTINUE
10352 CONTINUE
      return
      end
      integer function lnblnk1(string)
      character*(*) string
      integer i
      DO 10381 i=len(string),1,-1
        j = ichar(string(i:i))
        IF (( j .EQ. 0 )) THEN
          lnblnk1 = i-1
          return
        END IF
        IF (( j .NE. 9 .AND. j .NE. 10 .AND. j .NE. 11 .AND. j .NE. 12 .
     *  AND. j .NE. 13 .AND. j .NE. 32 )) THEN
          lnblnk1 = i
          return
        END IF
10381 CONTINUE
10382 CONTINUE
      lnblnk1 = 0
      return
      end
      real*8 FUNCTION ERF1(X)
      implicit none
      real*8 x
      double precision A(0:22,2)
      double precision CONST,  BN,BN1,BN2,  Y,FAC
      integer*4 N,  K,  NLIM(2)
      DATA A/ 1.0954712997776232 , -0.2891754011269890 , 0.1104563986337
     *951 , -0.0412531882278565 , 0.0140828380706516 , -0.00432929544743
     *14 , 0.0011982719015923 , -0.0002999729623532 , 0.0000683258603789
     * , -0.0000142469884549 , 0.0000027354087728 , -0.0000004861912872
     *, 0.0000000803872762 , -0.0000000124184183 , 0.0000000017995326 ,
     *-0.0000000002454795 , 0.0000000000316251 , -0.0000000000038590 , 0
     *.0000000000004472 , -0.0000000000000493 , 0.0000000000000052 , -0.
     *0000000000000005 , 0.0000000000000001 , 0.9750834237085559 , -0.02
     *40493938504146 , 0.0008204522408804 , -0.0000434293081303 , 0.0000
     *030184470340 , -0.0000002544733193 , 0.0000000248583530 , -0.00000
     *00027317201 , 0.0000000003308472 , 0.0000000000001464 , -0.0000000
     *000000244 , 0.0000000000000042 , -0.0000000000000008 , 0.000000000
     *0000001 , 9*0.0 /
      DATA NLIM/ 22,16 /
      DATA CONST/ 1.128379167095513 /
      IF (( x .GT. 3 )) THEN
        y = 3/x
        k = 2
      ELSE
        y = x/3
        k = 1
      END IF
      FAC = 2.0 * ( 2.0 * Y*Y - 1.0 )
      BN1 = 0.0
      BN = 0.0
      DO 10391 n=NLIM(K),0,-1
        BN2 = BN1
        BN1 = BN
        BN = FAC * BN1 - BN2 + A(N,K)
10391 CONTINUE
10392 CONTINUE
      IF (( k .EQ. 1 )) THEN
        erf1 = CONST * Y * ( BN - BN1 )
      ELSE
        erf1 = 1 - CONST * EXP(-X**2) * ( BN - BN2 + A(0,K) )/(4.0 * X)
      END IF
      RETURN
      end
      real*8 FUNCTION ZERO()
      implicit none
      integer*4 i
      real*8 x, xtemp
      x = 1.E-20
      DO 10401 i=1,100
        IF ((x .EQ. 0.0)) THEN
          GO TO10402
        ELSE
          xtemp = x
        END IF
        x = x/1.E5
10401 CONTINUE
10402 CONTINUE
      x = xtemp
      DO 10411 i=1,5
        IF ((x .NE. 0.0)) THEN
          xtemp = x
        ELSE
          GO TO10412
        END IF
        x = x/10
10411 CONTINUE
10412 CONTINUE
      x = xtemp
      DO 10421 i=2,10
        IF ((x .NE. 0.0)) THEN
          xtemp = x
        ELSE
          GO TO10422
        END IF
        x = x/i
10421 CONTINUE
10422 CONTINUE
      zero = xtemp
      return
      end
      character*512 function toUpper(a_string)
      character*(*) a_string
      character*512 the_string
      integer*4 cursor, i, lnblnk1
      toUpper = a_string
      the_string = a_string
      DO 10431 i=1,lnblnk1(the_string)
        cursor=ICHAR(the_string(i:i))
        IF (((cursor.GE.97).AND.(cursor.LE.122))) THEN
          cursor=cursor-32
          toUpper(i:i)=CHAR(cursor)
        END IF
10431 CONTINUE
10432 CONTINUE
      return
      end
      integer*1 function egs_read_byte(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      integer*1 i_1
      character c_1
      equivalence (i_1,c_1)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      read(iunit,rec=jrec,IOSTAT=ierr) c_1
      IF ((ierr.ne.0)) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' *** egs_read_byte: ERROR READING A byte *** '
        write(i_log,*) ' From unit ',iunit,' position ',jrec,' bytes'
        egs_read_byte = -1
        return
      END IF
      jrec = jrec + 1
      egs_read_byte = i_1
      return
      end
      integer*2 function egs_read_short(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      integer*2 i_2
      character c_2(2)
      equivalence (i_2,c_2)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      j = 0
      DO 10441 i=jrec,jrec+1
        j = j + 1
        read(iunit,rec=i,IOSTAT=ierr) c_2(j)
        IF ((ierr.ne.0)) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' *** egs_read_short: ERROR READING short integ
     *er *** '
          write(i_log,*) ' From unit ',iunit,' position ',jrec,' bytes'
          egs_read_short = -1
          return
        END IF
10441 CONTINUE
10442 CONTINUE
      jrec = jrec + 2
      egs_read_short = i_2
      return
      end
      integer*4 function egs_read_int(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      integer*4 i_4
      character c_4(4)
      equivalence (i_4,c_4)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      j = 0
      DO 10451 i=jrec,jrec+3
        j = j + 1
        read(iunit,rec=i,IOSTAT=ierr) c_4(j)
        IF ((ierr.ne.0)) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' *** egs_read_int: ERROR READING integer *** '
          write(i_log,*) ' From unit ',iunit,' position ',jrec,' bytes'
          egs_read_int = -1
          return
        END IF
10451 CONTINUE
10452 CONTINUE
      jrec = jrec + 4
      egs_read_int = i_4
      return
      end
      real*4 function egs_read_real(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      real*4 r_4
      character c_4(4)
      equivalence (r_4,c_4)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      j = 0
      DO 10461 i=jrec,jrec+3
        j = j + 1
        read(iunit,rec=i,IOSTAT=ierr) c_4(j)
        IF ((ierr.ne.0)) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' *** egs_read_real: ERROR READING float *** '
          write(i_log,*) ' From unit ',iunit,' position ',jrec,' bytes'
          egs_read_real = -1
          return
        END IF
10461 CONTINUE
10462 CONTINUE
      jrec = jrec + 4
      egs_read_real = r_4
      return
      end
      integer*4 function ibsearch(a, nsh, b)
      implicit none
      real*8 a, b(*)
      integer*4 min,max,help,nsh
      real*8 x
      min = 1
      max = nsh
      x = a
10471 IF(min.GE.max-1)GO TO 10472
        help = (max+min)/2
        IF (( b(help).le.x)) THEN
          min = help
        ELSE
          max = help
        END IF
      GO TO 10471
10472 CONTINUE
      ibsearch = min
      return
      end
#ifdef HAVE_C_COMPILER
      integer*4 function egs_create_lockfile(flag)
      integer*4 flag
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*512 fname
      integer*4 i,lnblnk1,l,istat
      DO 10481 i=1,len(fname)
        fname(i:i) = ' '
10481 CONTINUE
10482 CONTINUE
      fname = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_co
     *de)) // '/' // output_file(:lnblnk1(output_file)) // '.lock'
      l = lnblnk1(fname)+1
      fname(l:l) = char(0)
      call egs_create_control_file(fname,istat)
      IF (( istat .NE. 0 .AND. flag .EQ. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Failed to create a lock file named ',fname(:lnbl
     *  nk1(fname))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      egs_create_lockfile = istat
      return
      end
      integer*4 function egs_open_lockfile(flag)
      integer*4 flag
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*512 fname
      integer*4 i,lnblnk1,l,istat
      DO 10491 i=1,len(fname)
        fname(i:i) = ' '
10491 CONTINUE
10492 CONTINUE
      fname = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_co
     *de)) // '/' // output_file(:lnblnk1(output_file)) // '.lock'
      l = lnblnk1(fname)+1
      fname(l:l) = char(0)
      call egs_open_control_file(fname,istat)
      IF (( istat .NE. 0 .AND. flag .EQ. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Failed to open the lock file named ',fname(:lnbl
     *  nk1(fname))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      egs_open_lockfile = istat
      return
      end
      subroutine egs_remove_lockfile(istat)
      integer*4 istat
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*512 fname
      integer*4 i,lnblnk1,l
      DO 10501 i=1,len(fname)
        fname(i:i) = ' '
10501 CONTINUE
10502 CONTINUE
      fname = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_co
     *de)) // '/' // output_file(:lnblnk1(output_file)) // '.lock'
      l = lnblnk1(fname)+1
      fname(l:l) = char(0)
      call egs_remove_file(fname,istat)
      return
      end
      subroutine egs_pjob_control(ncase,n_run,n_left,n_tot,sum,sum2,res,
     *dres)
      implicit none
      integer*8 ncase,n_run,n_tot
      real*8 sum,sum2,res,dres
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/my_times/ t_elapsed, t_cpu, t_first
      real*8 t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      integer*8 n_last,n_left,nn_tot
      integer t_dum(8)
      integer*4 i,lnblnk1,n_write,n_read,istat,n_job
      integer*4 egs_create_lockfile, egs_open_lockfile
      real*8 tmp,tmp2
      logical first_time
      character control_string*256
      data first_time/.true./
      save first_time,n_last
      IF (( n_parallel .LE. 0 )) THEN
        n_run = ncase
        return
      END IF
      IF((first_time))n_last = 0
      DO 10511 i=1,len(control_string)
        control_string(i:i) = ' '
10511 CONTINUE
10512 CONTINUE
      n_run = ncase/n_parallel/10
      n_left = ncase
      IF (( first_time )) THEN
        IF((n_run .GT. n_left))n_run = n_left
        n_left = ncase - n_run
        IF (( i_parallel .EQ. first_parallel )) THEN
          istat = egs_create_lockfile(1)
          IF (( n_tot .GT. 1 )) THEN
            res = sum/n_tot
            dres = sum2/n_tot - res*res
            IF (( res .GT. 0 .AND. dres .GT. 0 )) THEN
              dres = sqrt(dres/(n_tot-1))/res*100
            ELSE
              dres = 99.9
            END IF
          ELSE
            res = 0
            dres = 99.9
          END IF
          write(control_string,'(2i15,i4,2(1pe16.8),1pe13.5,0pf7.2,2x,8i
     *5)') n_left,n_tot,1,sum,sum2,res,dres,(t_first(i),i=1,8)
          n_write = lnblnk1(control_string) + 1
          call egs_write_control_file(control_string,n_write,istat)
          IF (( istat .NE. n_write )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'job 1: failed to write to lock file ',n_writ
     *      e,istat
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          call egs_unlock_control_file(istat)
          IF (( istat .NE. 0 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'job 1: failed to unlock the file ',istat
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          first_time = .false.
          n_max_parallel = 1
          n_last = n_run
          return
        END IF
        istat = egs_open_lockfile(1)
      END IF
      call egs_rewind_control_file(istat)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'job ',i_parallel,': failed to rewind or lock the
     * control ', 'file', istat
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      n_read = len(control_string)
      call egs_read_control_file(control_string,n_read,istat)
      read(control_string,*,err=10520) n_left,nn_tot,n_job,tmp,tmp2, res
     *,dres,(t_dum(i),i=1,8)
      nn_tot = nn_tot + n_last
      tmp = tmp + sum
      tmp2 = tmp2 + sum2
      IF (( first_time )) THEN
        first_time = .false.
        n_job = n_job + 1
        nn_tot = nn_tot + n_tot
      END IF
      n_tot = nn_tot
      IF (( n_tot .GT. 1 )) THEN
        res = tmp/n_tot
        dres = tmp2/n_tot - res*res
        IF (( res .GT. 0 .AND. dres .GT. 0 )) THEN
          dres = sqrt(dres/(n_tot-1))/res*100
        ELSE
          dres = 99.9
        END IF
      ELSE
        res = 0
        dres = 99.9
      END IF
      IF (( n_run .GT. n_left )) THEN
        n_run = n_left
        n_left = 0
      ELSE
        n_left = n_left - n_run
      END IF
      n_last = n_run
      DO 10531 i=1,len(control_string)
        control_string(i:i) = ' '
10531 CONTINUE
10532 CONTINUE
      write(control_string,'(2i15,i4,2(1pe16.8),1pe13.5,0pf7.2,2x,8i5)')
     * n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_dum(i),i=1,8)
      call egs_rewind_control_file(istat)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'job ',i_parallel,': failed to rewind or lock the
     * control ', 'file', istat
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      n_write = lnblnk1(control_string) + 1
      call egs_write_control_file(control_string,n_write,istat)
      IF (( istat .NE. n_write )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'job ',i_parallel,': failed to write to lock file
     * ', n_write,istat
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      call egs_unlock_control_file(istat)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'job ',i_parallel,': failed to unlock the file ',
     *  istat
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF((n_job .GT. n_max_parallel))n_max_parallel = n_job
      return
10520 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,/a)') 'Failed to read from job control file: got '
     *, control_string(:lnblnk1(control_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_pjob_finish(n_job)
      implicit none
      integer*4 n_job
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/my_times/ t_elapsed, t_cpu, t_first
      real*8 t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      integer*4 istat,i,lnblnk1,n_read,n_write
      integer*8 n_left,n_tot
      integer t_start(8),t_end(8)
      real*8 tmp,tmp2,res,dres,t_run
      real egs_time_diff
      character control_string*256
      call egs_rewind_control_file(istat)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'job ',i_parallel,': failed to rewind or lock the
     * control ', 'file', istat
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      n_read = len(control_string)
      call egs_read_control_file(control_string,n_read,istat)
      read(control_string,*,end=10540,err=10540) n_left,n_tot,n_job,tmp,
     *tmp2,res,dres,(t_start(i),i=1,8)
      n_job = n_job - 1
      IF (( n_job .GT. 0 )) THEN
        DO 10551 i=1,len(control_string)
          control_string(i:i) = ' '
10551   CONTINUE
10552   CONTINUE
        write(control_string,'(2i15,i4,2(1pe16.8),1pe13.5,0pf7.2,2x,8i5)
     *') n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_start(i),i=1,8)
        call egs_rewind_control_file(istat)
        IF (( istat .NE. 0 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'job ',i_parallel,': failed to rewind or lock t
     *he ', 'control file, error was:', istat
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        n_write = lnblnk1(control_string) + 1
        call egs_write_control_file(control_string,n_write,istat)
        IF (( istat .NE. n_write )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'job ',i_parallel,': failed to write to lock fi
     *le ', n_write,istat
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        call egs_unlock_control_file(istat)
        call egs_close_control_file(istat)
        return
      END IF
      call egs_close_control_file(istat)
      call egs_remove_lockfile(istat)
      i_parallel = 0
      call egs_open_units(.false.)
      call egs_date_and_time(t_end)
      t_run = egs_time_diff(t_start,t_end)
      write(i_log,'(/a/,a,t55,i3/,a,t55,i3/,a,f9.1,a,f9.4,a/,a//)') '***
     ************** finished parallel execution ******************', ' n
     *umber of parallel jobs requested: ',n_parallel, ' max. number of j
     *obs executing simultaneously: ',n_max_parallel, ' elapsed time sin
     *ce first job started: ',t_run,' s (',t_run/3600,' h)', '**********
     ******************************************************'
      return
10540 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,/a)') 'In egs_pjob_finish: failed to read from con
     *trol string ', control_string(:lnblnk1(control_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
#endif
      SUBROUTINE EFUNS(E,V)
      implicit none
      real*4 E,V(8)
      real*4 BREM,AMOLL,BHAB,ANNIH,ESIG,PSIG
      real*4 BREMTM,AMOLTM,BHABTM,ANIHTM,SPTOTE,SPTOTP,TMXS,THBREM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      THBREM=RMP+APP
      IF ((IUNRSTP.EQ.0 .OR. IUNRSTP.EQ.1 .OR. IUNRSTP.EQ.5)) THEN
        BREM=BREMTM(E)
        AMOLL=AMOLTM(E)
        BHAB=BHABTM(E)
        ANNIH=ANIHTM(E)
        ESIG=BREM+AMOLL
        V(1)=ESIG
        PSIG=BREM+BHAB+ANNIH
        V(2)=PSIG
        V(3)=SPTOTE(E,AEP,APP)
        V(4)=SPTOTP(E,AEP,APP)
        IF ((ESIG.GT.0.0)) THEN
          V(5)=BREM/ESIG
        ELSE
          IF ((THBREM.LE.THMOLLP)) THEN
            V(5)=1.0
          ELSE
            V(5)=0.0
          END IF
        END IF
        V(6)=BREM/PSIG
        V(7)=(BREM+BHAB)/PSIG
        V(8)=TMXS(E)
      ELSE IF((IUNRSTP.EQ.2)) THEN
        V(1)=0.0
        V(2)=0.0
        V(5)=0.0
        V(6)=0.0
        V(7)=0.0
        V(3) = SPTOTE(E,E,E)
        V(4) = SPTOTP(E,E,E)
        V(8) = TMXS(E)
      ELSE IF((IUNRSTP.EQ.3)) THEN
        BREM=BREMTM(E)
        ANNIH=ANIHTM(E)
        V(1)=BREM
        V(2)=BREM + ANNIH
        V(3)=SPTOTE(E,E,APP)
        V(4)=SPTOTP(E,E,APP)
        V(5)=1.0
        V(6)=BREM/V(2)
        V(7)=V(6)
        V(8)=TMXS(E)
      ELSE IF((IUNRSTP.EQ.4)) THEN
        V(1)=AMOLTM(E)
        V(2)=BHABTM(E)
        V(3)=SPTOTE(E,AEP,E)
        V(4)=SPTOTP(E,AEP,E)
        V(5)=0.0
        V(6)=0.0
        V(7)=1.0
        V(8)=TMXS(E)
      ELSE
        WRITE(6,10560)IUNRSTP
10560   FORMAT(//'*********IUNRST=',I4,' NOT ALLOWED BY EFUNS*****'/ ' I
     *UNRST=6 OR 7 ONLY ALLOWED WITH CALL OR PLTN OPTIONS'//)
        call exit(20)
      END IF
      RETURN
      END
      real*4 FUNCTION BREMTM(E0)
      implicit none
      real*4 E0,BREMRM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      IF ((E0.LE.APP+RMP)) THEN
        BREMTM=0.
      ELSE
        BREMTM=BREMRM(E0,APP,E0-RMP)
      END IF
      RETURN
      END
      real*4 FUNCTION BREMRM(E,K1,K2)
      implicit none
      real*4 E,K1,K2
      integer*4 I
      real*4 BREMRZ
      COMMON/MIXDAT/NEP,LMED,PZP(50),ZELEMP(50),WAP(50),RHOZP(50), GASPP
     *,EZ,TPZ,IDSTRN(24)
      integer*4 NEP,LMED
      real*4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ
      CHARACTER*4 IDSTRN
      BREMRM=0.
      DO 10571 I=1,NEP
        BREMRM=BREMRM+PZP(I)*BREMRZ(ZELEMP(I),E,K1,K2)
10571 CONTINUE
10572 CONTINUE
      RETURN
      END
      real*4 FUNCTION BREMRZ(Z,E,K1,K2)
      implicit none
      real*4 Z,E,K1,K2
      EXTERNAL BREMFZ
      real*4 DUMMY,BREMDZ,QD,BREMFZ
      DUMMY=BREMDZ(Z,E,K1)
      BREMRZ=QD(BREMFZ,K1,K2,'BREMFZ')
      RETURN
      END
      real*4 FUNCTION BREMDZ(Z,E,K)
      implicit none
      real*4 Z,E,K,BRMSDZ
      BREMDZ=BRMSDZ(Z,E,K)/K
      RETURN
      END
      real*4 FUNCTION BREMFZ(K)
      implicit none
      real*4 K,BRMSFZ
      BREMFZ=BRMSFZ(K)/K
      RETURN
      END
      real*4 FUNCTION BRMSFZ(K)
      implicit none
      real*4 K
      real*4 EMKLOC,DELTA,SB1,SB2,EE
      COMMON/LBREMZ/CONST,DELC,EBREMZ,DELTAM,XLNZ
      real*4 CONST,DELC,EBREMZ,DELTAM,XLNZ
      EMKLOC=EBREMZ-K
      IF ((EMKLOC.EQ.0.0)) THEN
        EMKLOC=1.E-25
      END IF
      DELTA=DELC*K/EMKLOC
      IF ((DELTA.GE.DELTAM)) THEN
        BRMSFZ=0.0
      ELSE
        IF ((DELTA.LE.1.)) THEN
          SB1=20.867+DELTA*(-3.242+DELTA*0.625)-XLNZ
          SB2=20.209+DELTA*(-1.930+DELTA*(-0.086))-XLNZ
        ELSE
          SB1=21.12-4.184*LOG(DELTA+0.952)-XLNZ
          SB2=SB1
        END IF
        EE=EMKLOC/EBREMZ
        BRMSFZ=CONST*((1.+EE*EE)*SB1-0.666667*EE*SB2)
      END IF
      RETURN
      END
      real*4 FUNCTION AMOLTM(E0)
      implicit none
      real*4 E0
      real*4 T0,AMOLRM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      IF ((E0.LE.THMOLLP)) THEN
        AMOLTM=0.
      ELSE
        T0=E0-RMP
        AMOLTM=AMOLRM(E0,AEP,T0*0.5+RMP)
      END IF
      RETURN
      END
      real*4 FUNCTION AMOLRM(EN0,EN1,EN2)
      implicit none
      real*4 EN0,EN1,EN2
      real*4 T0,T1,T2,TM,EM,C1,C2,BETASQ,CMOLL2,EPS1,EPSP1,EPS2,EPSP2
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      T0=EN0-RMP
      T1=EN1-RMP
      T2=EN2-RMP
      TM=T0/RMP
      EM=TM+1.
      C1=(TM/EM)**2
      C2=(2.*TM+1.)/EM**2
      BETASQ=1.-1./EM**2
      CMOLL2=RLCP*EDEN*2.*PIP*R0**2/(BETASQ*TM)
      EPS1=T1/T0
      EPSP1=1.-EPS1
      EPS2=T2/T0
      EPSP2=1.-EPS2
      AMOLRM=CMOLL2*(C1*(EPS2-EPS1)+1./EPS1-1./EPS2+1./EPSP2-1./EPSP1 -C
     *2*LOG(EPS2*EPSP1/(EPS1*EPSP2)))
      RETURN
      END
      real*4 FUNCTION BHABTM(E0)
      implicit none
      real*4 E0,BHABRM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      IF ((E0.LE.AEP)) THEN
        BHABTM=0.
      ELSE
        BHABTM=BHABRM(E0,AEP,E0)
      END IF
      RETURN
      END
      real*4 FUNCTION BHABRM(EN0,EN1,EN2)
      implicit none
      real*4 EN0,EN1,EN2
      real*4 T0,T1,T2,TM,EM,Y,BETASI,CBHAB2,B1,B2,B3,B4,EPS1,EPS2
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      T0=EN0-RMP
      T1=EN1-RMP
      T2=EN2-RMP
      TM=T0/RMP
      EM=TM+1.
      Y=1./(TM+2.)
      BETASI=1./(1.-1./EM**2)
      CBHAB2=RLCP*EDEN*2.*PIP*R0**2/TM
      B1=2.-Y**2
      B2=3.-Y*(6.-Y*(1.-Y*2.))
      B3=2.-Y*(10.-Y*(16.-Y*8.))
      B4=1.-Y*(6.-Y*(12.-Y*8.))
      EPS1=T1/T0
      EPS2=T2/T0
      BHABRM=CBHAB2*(BETASI*(1./EPS1-1./EPS2)-B1*LOG(EPS2/EPS1) +B2*(EPS
     *2-EPS1)+EPS2*EPS2*(EPS2*B4/3.-0.5*B3) - EPS1*EPS1*(EPS1*B4/3.-0.5*
     *B3))
      RETURN
      END
      real*4 FUNCTION ANIHTM(E0)
      implicit none
      real*4 E0
      real*4 GAM,P0P2,P0P,CANIH
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      GAM=E0/RMP
      P0P2=GAM*GAM-1.0
      P0P=SQRT(P0P2)
      CANIH=RLCP*EDEN*PIP*R0**2/(GAM+1.)
      ANIHTM=CANIH*((GAM*GAM+4.*GAM+1.)/P0P2*LOG(GAM+P0P) -(GAM+3.)/P0P)
      RETURN
      END
      real*4 FUNCTION SPTOTP(E0,EE,EG)
      implicit none
      real*4 E0,EE,EG
      real*4 SPIONP,BRMSTM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      IF ((IUNRSTP.EQ.0)) THEN
        SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.1)) THEN
        SPTOTP=SPIONP(E0,E0)
      ELSE IF((IUNRSTP.EQ.2)) THEN
        SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.3)) THEN
        SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.4)) THEN
        SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.5)) THEN
        SPTOTP=BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.6)) THEN
        SPTOTP=BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.7)) THEN
        SPTOTP=SPIONP(E0,EE)
      END IF
      RETURN
      END
      real*4 FUNCTION SPTOTE(E0,EE,EG)
      implicit none
      real*4 E0,EE,EG
      real*4 SPIONE,BRMSTM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      IF ((IUNRSTP.EQ.0)) THEN
        SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.1)) THEN
        SPTOTE=SPIONE(E0,E0)
      ELSE IF((IUNRSTP.EQ.2)) THEN
        SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.3)) THEN
        SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.4)) THEN
        SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.5)) THEN
        SPTOTE=BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.6)) THEN
        SPTOTE=BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.7)) THEN
        SPTOTE=SPIONE(E0,EE)
      END IF
      RETURN
      END
      real*4 FUNCTION SPIONE(E0,EE)
      implicit none
      real*4 E0,EE,SPIONB
      SPIONE=SPIONB(E0,EE,.FALSE.)
      RETURN
      END
      real*4 FUNCTION SPIONB(E0,EE,POSITR)
      implicit none
      real*4 E0,EE
      LOGICAL POSITR
      real*4 G,EEM,T,ETA2,BETA2,ALETA2,X,D,FTERM,TP2,D2,D3,D4,DELTA
      integer*4 I
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/LSPION/CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      real*4 CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20), EPSTTL,NEPST,IEPST
     *,EPSTFLP, NELEPS,ZEPST(20),IAPRFL,IAPRIMP
      integer*4 ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP
      CHARACTER EPSTTL*80
      real*4 EPSTEN,EPSTD,WEPST
      G=E0/RMP
      EEM=EE/RMP-1.
      T=G-1
      ETA2=T*(G+1.)
      BETA2=ETA2/G**2
      ALETA2=LOG(ETA2)
      X=0.21715*ALETA2
      IF ((.NOT.POSITR)) THEN
        D=AMIN1(EEM,0.5*T)
        FTERM=-1.-BETA2+LOG((T-D)*D)+T/(T-D) +(D*D/2.+(2.*T+1.)*LOG(1.-D
     *  /T))/(G*G)
      ELSE
        D=AMIN1(EEM,T)
        TP2=T+2.
        D2=D*D
        D3=D*D2
        D4=D*D3
        FTERM=LOG(T*D)-(BETA2/T)*( T + 2.*D - (3.*D2/2.)/TP2 -(D-D3/3.)/
     *  (TP2*TP2)-(D2/2.-T*D3/3.+D4/4.)/TP2**3)
      END IF
      IF ((EPSTFLP .EQ. 0)) THEN
        IF ((X.LE.X0)) THEN
          DELTA=0.0
        ELSE IF((X.LT.X1)) THEN
          DELTA=TOLN10*X - CBAR + AFACT*(X1 - X)**SK
        ELSE
          DELTA=TOLN10*X - CBAR
        END IF
      ELSE
        IF ((E0 .GE. EPSTEN(IEPST))) THEN
          IF ((E0 .EQ. EPSTEN(IEPST))) THEN
            GO TO 10580
          END IF
          DO 10591 I=IEPST,NEPST-1
            IF ((E0.LT.EPSTEN(I+1))) THEN
              IEPST = I
              GO TO 10580
            END IF
10591     CONTINUE
10592     CONTINUE
          IEPST = NEPST
          GO TO 10580
        ELSE
          DO 10601 I=IEPST,2,-1
            IF ((E0 .GE. EPSTEN(I-1))) THEN
              IEPST = I-1
              GO TO 10580
            END IF
10601     CONTINUE
10602     CONTINUE
          IEPST = 1
        END IF
10580   IF ((IEPST .LT. NEPST)) THEN
          DELTA = EPSTD(IEPST) + (E0 - EPSTEN(IEPST))/ (EPSTEN(IEPST+1)
     *    - EPSTEN(IEPST)) * (EPSTD(IEPST+1) - EPSTD(IEPST))
        ELSE
          DELTA = EPSTD(NEPST)
        END IF
      END IF
      SPIONB=(SPC1/BETA2)*(LOG(T + 2.) - SPC2 + FTERM - DELTA)
      RETURN
      END
      real*4 FUNCTION SPIONP(E0,EE)
      implicit none
      real*4 E0,EE,SPIONB
      SPIONP=SPIONB(E0,EE,.TRUE.)
      RETURN
      END
      real*4 FUNCTION BRMSTM(E0,EG)
      implicit none
      real*4 E0,EG,BRMSRM,AU,zero
      parameter (zero=0)
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      IF ((E0.LE.RMP)) THEN
        BRMSTM=0.
      ELSE
        AU=AMIN1(EG,E0-RMP)
        BRMSTM=BRMSRM(E0,zero,AU)
      END IF
      RETURN
      END
      real*4 FUNCTION BRMSRM(E,K1,K2)
      implicit none
      real*4 E,K1,K2,BRMSRZ
      integer*4 I
      COMMON/MIXDAT/NEP,LMED,PZP(50),ZELEMP(50),WAP(50),RHOZP(50), GASPP
     *,EZ,TPZ,IDSTRN(24)
      integer*4 NEP,LMED
      real*4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ
      CHARACTER*4 IDSTRN
      BRMSRM=0.
      DO 10611 I=1,NEP
        BRMSRM=BRMSRM+PZP(I)*BRMSRZ(ZELEMP(I),E,K1,K2)
10611 CONTINUE
10612 CONTINUE
      RETURN
      END
      real*4 FUNCTION BRMSRZ(Z,E,K1,K2)
      implicit none
      real*4 Z,E,K1,K2
      EXTERNAL BRMSFZ
      real*4 DUMMY,BRMSDZ,QD,BRMSFZ
      DUMMY=BRMSDZ(Z,E,K1)
      BRMSRZ=QD(BRMSFZ,K1,K2,'BRMSFZ')
      RETURN
      END
      real*4 FUNCTION BRMSDZ(Z,EA,K)
      implicit none
      real*4 Z,EA,K
      real*4 APRIM,XSIFP,FCOULCP,BRMSFZ
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/LBREMZ/CONST,DELC,EBREMZ,DELTAM,XLNZ
      real*4 CONST,DELC,EBREMZ,DELTAM,XLNZ
      EBREMZ=EA
      DELC=136.*Z**(-1./3.)*RMP/EBREMZ
      CONST=APRIM(Z,EBREMZ)*(AN*RHOP/WM)*R0**2*FSC*Z*(Z+XSIFP(Z))*RLCP
      XLNZ=4./3.*LOG(Z)
      IF((EBREMZ.GE.50))XLNZ=XLNZ+4.*FCOULCP(Z)
      DELTAM=EXP((21.12-XLNZ)/4.184)-0.952
      BRMSDZ=BRMSFZ(K)
      RETURN
      END
      real*4 FUNCTION APRIM(Z,E)
      implicit none
      real*4 Z,E
      integer*4 napre,naprz,ie,iz,aprim_unit,egs_get_unit,lnblnk1
      real*4 EM,AINTP
      character aprim_file*256
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20), EPSTTL,NEPST,IEPST
     *,EPSTFLP, NELEPS,ZEPST(20),IAPRFL,IAPRIMP
      integer*4 ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP
      CHARACTER EPSTTL*80
      real*4 EPSTEN,EPSTD,WEPST
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*4 APRIMD(115,14),EPRIM(115),ZPRIM(14),APRIMZ(115)
      DATA APRIMD/ 1.32,1.26,1.18,1.13,1.09,1.07,1.05,1.04,1.03, 1.02,8*
     *1.0, 97*0.0, 1.34,1.27,1.19,1.13,1.09,1.07,1.05,1.04,1.03,1.02, 8*
     *1.0, 97*0.0, 1.39,1.30,1.21,1.14,1.10,1.07,1.05,1.04,1.03,1.02,0.9
     *94, 2*0.991,0.990,2*0.989,2*0.988, 97*0.0, 1.46,1.34,1.23,1.15,1.1
     *1,1.08, 1.06,1.05,1.03,1.02,0.989, 0.973,0.971,0.969,0.967,0.965,2
     **0.963, 97*0.0, 1.55,1.40,1.26,1.17,1.12,1.09,1.07,1.05,1.03,1.02,
     *0.955,0.935, 0.930,0.925,0.920,0.915,2*0.911, 97*0.0,  1035*0.0/,
     *EPRIM / 2.,3.,4.,5.,6.,7.,8.,9.,10.,11.,21.,31.,41.,51.,61.,71.,81
     *.,91.,  97*0.0/, ZPRIM /6.,13.,29.,50.,79., 9*0.0/
      save APRIMD,EPRIM,ZPRIM,APRIMZ,napre,naprz
      IF ((IAPRIMP.EQ.0)) THEN
        IF ((IAPRFL .EQ. 0)) THEN
          IAPRFL=1
        END IF
        IF ((E.GE.50)) THEN
          APRIM=1.
        ELSE
          EM=E/RMP
          DO 10621 IE=1,18
            APRIMZ(IE)= AINTP(Z,ZPRIM,5,APRIMD(IE,1),115,.FALSE.,.FALSE.
     *      )
10621     CONTINUE
10622     CONTINUE
          APRIM=AINTP(EM,EPRIM,18,APRIMZ,1,.FALSE.,.FALSE.)
        END IF
      ELSE IF((IAPRIMP.EQ.1)) THEN
        IF ((IAPRFL.EQ.0)) THEN
          aprim_file = hen_house(:lnblnk1(hen_house)) // 'pegs4' // '/'
     *    // 'aprime.data'
          aprim_unit=22
          aprim_unit=egs_get_unit(aprim_unit)
          IF (( aprim_unit .LT. 1 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'APRIM: failed to get a free fortran unit'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(aprim_unit,file=aprim_file,status='old',err=10630)
          READ(aprim_unit,*) NAPRZ, NAPRE
          IF ((NAPRZ.GT.14)) THEN
            WRITE(6,10640)
10640       FORMAT(//,' TOO MANY ELEMENTS FOR APRIME INTERPOLATION:', /,
     *'   CHANGE $NAPRZ AND RECOMPILE PEGS')
            call exit(24)
          END IF
          IF ((NAPRE.GT.115)) THEN
            WRITE(6,10650)
10650       FORMAT(//,' TOO MANY ENERGIES FOR APRIME INTERPOLATION:', /,
     *'   CHANGE $NAPRE AND RECOMPILE PEGS')
            call exit(24)
          END IF
          READ(aprim_unit,*) (EPRIM(IE),IE=1,NAPRE)
          DO 10661 IE=1,NAPRE
            EPRIM(IE)=1.+EPRIM(IE)/RMP
10661     CONTINUE
10662     CONTINUE
          DO 10671 IZ=1,NAPRZ
            READ(aprim_unit,*)ZPRIM(IZ),(APRIMD(IE,IZ),IE=1,NAPRE)
10671     CONTINUE
10672     CONTINUE
          IAPRFL=1
          close(aprim_unit)
        END IF
        EM=E/RMP
        DO 10681 IE=1,NAPRE
          APRIMZ(IE)= AINTP(Z,ZPRIM,NAPRZ,APRIMD(IE,1),115,.TRUE.,.FALSE
     *    .)
10681   CONTINUE
10682   CONTINUE
        APRIM=AINTP(EM,EPRIM,NAPRE,APRIMZ,1,.FALSE.,.FALSE.)
      ELSE IF((IAPRIMP.EQ.2)) THEN
        IF ((IAPRFL .EQ. 0)) THEN
          IAPRFL=1
        END IF
        APRIM=1.0
      ELSE
        WRITE(6,10690)IAPRIMP
10690   FORMAT(//,' ILLEGAL VALUE FOR IAPRIM: ',I4)
        call exit(24)
      END IF
      RETURN
10630 write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Cannot open file $HEN_HOUSE/pegs4/aprime.data'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      RETURN
      END
      real*4 FUNCTION AINTP(X,XA,NX,YA,ISK,XLOG,YLOG)
      implicit none
      integer*4 NX,ISK
      real*4 X
      real*4 XA(NX),YA(ISK,NX)
      LOGICAL XLOG,YLOG,XLOGL
      integer*4 I,J
      real*4 XI,XJ,XV,YI,YJ
      XLOGL=XLOG
      DO 10701 J=2,NX
        IF((X.LT.XA(J)))GO TO 10710
10701 CONTINUE
10702 CONTINUE
      J=NX
10710 I=J-1
      IF ((XA(I).LE.0.0)) THEN
        XLOGL=.FALSE.
      END IF
      IF ((.NOT.XLOGL)) THEN
        XI=XA(I)
        XJ=XA(J)
        XV=X
      ELSE
        XI=LOG(XA(I))
        XJ=LOG(XA(J))
        XV=LOG(X)
      END IF
      IF ((YLOG.AND.(YA(1,I).EQ.0.0.OR.YA(1,J).EQ.0.0))) THEN
        AINTP=0.0
      ELSE
        IF ((YLOG)) THEN
          YI=LOG(YA(1,I))
          YJ=LOG(YA(1,J))
          IF ((XJ.EQ.XI)) THEN
            AINTP=YI
          ELSE
            AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI)
          END IF
          AINTP=EXP(AINTP)
        ELSE
          YI=YA(1,I)
          YJ=YA(1,J)
          IF ((XJ.EQ.XI)) THEN
            AINTP=YI
          ELSE
            AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI)
          END IF
        END IF
      END IF
      RETURN
      END
      real*4 FUNCTION TMXS(E)
      implicit none
      real*4 E,TMXB
      real*4 SAFETY,TABSMX
      DATA SAFETY/0.8/,TABSMX/10.0/
      save SAFETY,TABSMX
      TMXS=AMIN1(TMXB(E)*SAFETY,TABSMX)
      RETURN
      END
      real*4 FUNCTION TMXB(E)
      implicit none
      real*4 E
      real*4 ESQ,BETA2,PX2
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      ESQ=E**2
      BETA2=1.0-RMPSQ/ESQ
      PX2=ESQ*BETA2/XCCP**2
      TMXB=PX2*BETA2/LOG(BLCCP*PX2)
      RETURN
      END
      real*4 FUNCTION ALKE(E)
      implicit none
      real*4 E
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      ALKE=LOG(E-RMP)
      RETURN
      END
      real*4 FUNCTION ALKEI(X)
      implicit none
      real*4 x
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      ALKEI=EXP(X) + RMP
      RETURN
      END
      SUBROUTINE PWLF1(NI,NIMX,XL,XU,XR,EP,ZTHR,ZEP,NIP,XFUN,XFI, AX,BX,
     *NALM,NFUN,AF,BF,VFUNS)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 NI,NIMX,NIP,NALM,NFUN
      real*4 XL,XU,XR,EP,AX,BX,XFUN,XFI
      EXTERNAL XFI,VFUNS,XFUN
      real*4 AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN)
      LOGICAL QFIT
      integer*4 NL,NU,IPRN,NJ,NK
      real*4 REM
      NL=0
      NU=1
      IPRN=0
10721 CONTINUE
        NJ=MIN0(NU,NIMX)
        IF((QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI, AX,BX,NALM,NF
     *  UN,AF,BF,VFUNS,0)))GO TO10722
        IF ((NU.GE.NIMX)) THEN
          NI=NJ
          RETURN
        END IF
        NL=NU
        NU=NU*2
      GO TO 10721
10722 CONTINUE
      NU=NJ
10731 IF(NU.LE.NL+1)GO TO 10732
        NJ=(NL+NU)/2
        NK=NJ
        IF ((QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI, AX,BX,NALM,N
     *  FUN,AF,BF,VFUNS,0))) THEN
          NU=NJ
        ELSE
          NL=NK
        END IF
      GO TO 10731
10732 CONTINUE
      NI=NU
      IF((NI.EQ.NJ))RETURN
      IF((.NOT.QFIT(NI,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI, AX,BX,NALM
     *,NFUN,AF,BF,VFUNS,0)))WRITE(6,10740)NI
10740 FORMAT(' CATASTROPHE---DOES NOT FIT WHEN IT SHOULD,NI=',I5)
      RETURN
      END
      LOGICAL FUNCTION QFIT(NJ,XL,XH,XR,EP,ZTHR,ZEP,REM,NJP,XFUN,XFI, AX
     *,BX,NALM,NFUN,AF,BF,VFUNS,IPRN)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      EXTERNAL VFUNS
      real*4 XFUN,XFI
      integer*4 NJ,NALM,NFUN,NJP,IPRN
      real*4 XL,XH,XR,AX,BX,REM,EP
      real*4 FSXL(10),FSXH(10),FIP(10),FFIP(10),AFIP(10),RE(10),AER(10)
      real*4 AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN)
      real*4 XS,XFL,XFH,XFS,XM,DX,W,XLL,SXFL,XSXF,SXFH,DSXF,WIP, SXFIP,X
     *IP
      integer*4 NI,NIP,ISUB,IFUN,JSUB,IP
      integer*4 nkp
      DATA NKP/3/
      save nkp
      IF ((XH.LE.XL)) THEN
        WRITE(6,10750)XL,XH
10750   FORMAT(' QFIT ERROR:XL SHOULD BE < XH. XL,XH=',2G14.6)
        QFIT=.FALSE.
        RETURN
      END IF
      XS=AMAX1(XL,AMIN1(XH,XR))
      NI=NJ-2
      IF ((((XS.EQ.XL.OR.XS.EQ.XH).AND.NI.GE.1).OR.NI.GE.2)) THEN
        XFL=XFUN(XL)
      ELSE
        QFIT=.FALSE.
        RETURN
      END IF
      XFH=XFUN(XH)
      XFS=XFUN(XS)
      XM=AMAX1(XFH-XFS,XFS-XFL)
      DX=XFH-XFL
      W=XM/AMAX1(1.,AINT(NI*XM/DX))
      NI=NI-AINT(NI-DX/W)
      NIP=MAX0(NKP,(NJP+NI-1)/NI)
      NIP=(NIP/2)*2+1
      IF ((XFH-XFS.LE.XFS-XFL)) THEN
        XLL=XFL
      ELSE
        XLL=XFH-NI*W
      END IF
      AX=1./W
      BX=2.-XLL*AX
      REM=0.0
      QFIT=.TRUE.
      SXFL=AMAX1(XLL,XFL)
      ISUB=0
      XSXF=XFI(SXFL)
      CALL VFUNS(XSXF,FSXL)
      IF((IPRN.NE.0))WRITE(6,1820) ISUB,SXFL,XSXF,(FSXL(IFUN),IFUN=1,NFU
     *N)
1820  FORMAT(' QFIT:ISUB,SXF,XSXF,FSX()=',I4,1P,9G11.4/(1X,12G11.4))
      DO 10761 ISUB=1,NI
        JSUB=ISUB+1
        SXFH=AMIN1(XLL+W*ISUB,XH)
        XSXF=XFI(SXFH)
        CALL VFUNS(XSXF,FSXH)
        IF((IPRN.NE.0))WRITE(6,1820)ISUB,SXFH,XSXF,(FSXH(IFUN),IFUN=1,NF
     *  UN)
        DSXF=SXFH-SXFL
        DO 10771 IFUN=1,NFUN
          AF(JSUB,IFUN)=(FSXH(IFUN)-FSXL(IFUN))/DSXF
          BF(JSUB,IFUN)=(FSXL(IFUN)*SXFH-FSXH(IFUN)*SXFL)/DSXF
10771   CONTINUE
10772   CONTINUE
        WIP=DSXF/(NIP+1)
        DO 10781 IP=1,NIP
          SXFIP=SXFL+IP*WIP
          XIP=XFI(SXFIP)
          CALL VFUNS(XIP,FIP)
          DO 10791 IFUN=1,NFUN
            FFIP(IFUN)=AF(JSUB,IFUN)*SXFIP+BF(JSUB,IFUN)
            AFIP(IFUN)=ABS(FIP(IFUN))
            AER(IFUN)=ABS(FFIP(IFUN)-FIP(IFUN))
            RE(IFUN)=0.0
            IF ((FIP(IFUN).NE.0.0)) THEN
              RE(IFUN)=AER(IFUN)/AFIP(IFUN)
            END IF
            IF ((AFIP(IFUN).GE.ZTHR(IFUN))) THEN
              REM=AMAX1(REM,RE(IFUN))
            ELSE IF((AER(IFUN).GT.ZEP(IFUN))) THEN
              QFIT=.FALSE.
            END IF
10791     CONTINUE
10792     CONTINUE
          IF ((IPRN.NE.0)) THEN
            WRITE(6,10800)ISUB,IP,SXFIP,XIP,REM,QFIT,(FIP(IFUN),FFIP(IFU
     *      N), RE(IFUN),AER(IFUN),IFUN=1,NFUN)
10800       FORMAT(1X,2I4,1P,2G12.5,6P,F12.0,L2,1P,2G11.4,6P,F11.0,1P,G1
     *1.4/ (1X,3(1P,2G11.4,6P,F11.0,1P,G11.4)))
          END IF
10781   CONTINUE
10782   CONTINUE
        SXFL=SXFH
        DO 10811 IFUN=1,NFUN
          FSXL(IFUN)=FSXH(IFUN)
10811   CONTINUE
10812   CONTINUE
10761 CONTINUE
10762 CONTINUE
      DO 10821 IFUN=1,NFUN
        AF(1,IFUN)=AF(2,IFUN)
        BF(1,IFUN)=BF(2,IFUN)
        AF(NI+2,IFUN)=AF(NI+1,IFUN)
        BF(NI+2,IFUN)=BF(NI+1,IFUN)
10821 CONTINUE
10822 CONTINUE
      QFIT=QFIT.AND.REM.LE.EP
      NJ=NI+2
      RETURN
      END
      real*4 FUNCTION QD(F,A,B,MSG)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*4 A,B,F
      EXTERNAL F
      CHARACTER*6 MSG
      logical first_time
      data first_time/.true./
      save first_time
      real*4 DCADRE,ADUM,BDUM,ERRDUM
      integer*4 IER
      ADUM=A
      BDUM=B
      QD=DCADRE(F,ADUM,BDUM,1.E-16,1.E-5,ERRDUM,IER)
      IF ((IER.GT.66)) THEN
        WRITE(6,10830)IER,MSG,A,B,QD,ERRDUM
10830   FORMAT(' DCADRE CODE=',I4,' FOR INTEGRAL ',A6,' FROM ',1P,G14.6,
     *' TO ',G14.6, ',QD=',G14.6,'+-',G14.6)
      END IF
      RETURN
      END
      real*4 FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER)
      implicit none
      DIMENSION T(10,10),R(10),AIT(10),DIF(10),RN(4),TS(2049)
      DIMENSION IBEGS(30),BEGIN(30),FINIS(30),EST(30)
      DIMENSION REGLSV(30)
      LOGICAL H2CONV,AITKEN,RIGHT,REGLAR,REGLSV
      real*4 T,R,AIT,DIF,RN,TS,BEGIN,FINIS,EST,AITLOW
      real*4 H2TOL,AITTOL,LENGTH,JUMPTL,ZERO,P1,HALF,ONE
      real*4 TWO,FOUR,FOURP5,TEN,HUN,CADRE,ERROR,A,B
      real*4 AERR,RERR,STEPMN,STEPNM,STAGE,CUREST,FNSIZE
      real*4 PREVER,BEG,FBEG,END,FEND,STEP,ASTEP,TABS,HOVN
      real*4 FN,SUM,SUMABS,ABSI,VINT,TABTLM,ERGL,ERGOAL
      real*4 ERRA,ERRR,FEXTRP,ERRER,DIFF,SING,FEXTM1,ALG4O2
      real*4 H2NXT,SINGNX,SLOPE,FBEG2,ALPHA
      real*4 ERRET,H2TFEX,FI
      real*4 RVAL,F
      integer*4 IBEGS,IER,ISTAGE,IBEG,IEND,L,N,LM1,N2,ISTEP,II,III,I,IST
     *EP2,IT,NNLEFT
      integer*4 MAXTS,MAXTBL,MXSTGE
      DATA AITLOW,H2TOL,AITTOL,JUMPTL,MAXTS,MAXTBL,MXSTGE/1.1D0,.15D0, .
     *1D0,.01D0,2049,10,30/
      DATA RN(1),RN(2),RN(3),RN(4)/.7142005D0,.3466282D0,.843751D0, .126
     *3305D0/
      DATA ZERO,P1,HALF,ONE,TWO,FOUR,FOURP5,TEN,HUN/0.0D0,0.1D0,0.5D0, 1
     *.0D0,2.0D0,4.0D0,4.5D0,10.0D0,100.0D0/
      save MAXTS,MAXTBL,MXSTGE
      ALG4O2=LOG10(TWO)
      CADRE=ZERO
      ERROR=ZERO
      CUREST=ZERO
      VINT=ZERO
      IER=0
      LENGTH=ABS(B-A)
      IF((LENGTH.EQ.ZERO))GO TO 215
      IF((RERR.GT.P1.OR.RERR.LT.ZERO))GO TO 210
      IF((AERR.EQ.ZERO.AND.(RERR+HUN).LE.HUN))GO TO 210
      ERRR=RERR
      ERRA=ABS(AERR)
      STEPMN=(LENGTH/FLOAT(2**MXSTGE))
      STEPNM=DMAX1(LENGTH,ABS(A),ABS(B))*TEN
      STAGE=HALF
      ISTAGE=1
      FNSIZE=ZERO
      PREVER=ZERO
      REGLAR=.FALSE.
      BEG=A
      RVAL=BEG
      FBEG=F(RVAL)*HALF
      TS(1)=FBEG
      IBEG=1
      END=B
      RVAL=END
      FEND=F(RVAL)*HALF
      TS(2)=FEND
      IEND=2
5     RIGHT=.FALSE.
10    STEP=END - BEG
      ASTEP=ABS(STEP)
      IF((ASTEP.LT.STEPMN))GO TO 205
      IF((STEPNM+ASTEP.EQ.STEPNM))GO TO 205
      T(1,1)=FBEG + FEND
      TABS=ABS(FBEG) + ABS(FEND)
      L=1
      N=1
      H2CONV=.FALSE.
      AITKEN=.FALSE.
15    LM1=L
      L=L + 1
      N2=N + N
      FN=N2
      ISTEP=(IEND - IBEG)/N
      IF((ISTEP.GT.1))GO TO 25
      II=IEND
      IEND=IEND + N
      IF((IEND.GT.MAXTS))GO TO 200
      HOVN=STEP/FN
      III=IEND
      FI=ONE
      DO 10841 I=1,N2,2
        TS(III)=TS(II)
        RVAL=END-FI*HOVN
        TS(III-1)=F(RVAL)
        FI=FI+TWO
        III=III-2
        II=II-1
10841 CONTINUE
10842 CONTINUE
      ISTEP=2
25    ISTEP2=IBEG + ISTEP/2
      SUM=ZERO
      SUMABS=ZERO
      DO 10851 I=ISTEP2,IEND,ISTEP
        SUM=SUM + TS(I)
        SUMABS=SUMABS + ABS(TS(I))
10851 CONTINUE
10852 CONTINUE
      T(L,1)=T(L-1,1)*HALF+SUM/FN
      TABS=TABS*HALF+SUMABS/FN
      ABSI=ASTEP*TABS
      N=N2
      IT=1
      VINT=STEP*T(L,1)
      TABTLM=TABS*TEN
      FNSIZE=DMAX1(FNSIZE,ABS(T(L,1)))
      ERGL=ASTEP*FNSIZE*TEN
      ERGOAL=STAGE*DMAX1(ERRA,ERRR*ABS(CUREST+VINT))
      FEXTRP=ONE
      DO 10861 I=1,LM1
        FEXTRP=FEXTRP*FOUR
        T(I,L)=T(L,I) - T(L-1,I)
        T(L,I+1)=T(L,I) + T(I,L)/(FEXTRP-ONE)
10861 CONTINUE
10862 CONTINUE
      ERRER=ASTEP*ABS(T(1,L))
      IF((L.GT.2))GO TO 40
      IF((TABS+P1*ABS(T(1,2)).EQ.TABS))GO TO 135
      GO TO 15
40    DO 45 I=2,LM1
      DIFF=ZERO
      IF((TABTLM+ABS(T(I-1,L)).NE.TABTLM))DIFF=T(I-1,LM1)/T(I-1,L)
      T(I-1,LM1)=DIFF
45    CONTINUE
      IF((ABS(FOUR-T(1,LM1)).LE.H2TOL))GO TO 60
      IF((T(1,LM1).EQ.ZERO))GO TO 55
      IF((ABS(TWO-ABS(T(1,LM1))).LT.JUMPTL))GO TO 130
      IF((L.EQ.3))GO TO 15
      H2CONV=.FALSE.
      IF((ABS((T(1,LM1)-T(1,L-2))/T(1,LM1)).LE.AITTOL))GO TO 75
50    IF(REGLAR) GO TO 55
      IF((L.EQ.4))GO TO 15
55    IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 175
      GO TO 145
60    IF(H2CONV) GO TO 65
      AITKEN=.FALSE.
      H2CONV=.TRUE.
65    FEXTRP=FOUR
70    IT=IT + 1
      VINT=STEP*T(L,IT)
      ERRER=ABS(STEP/(FEXTRP-ONE)*T(IT-1,L))
      IF((ERRER.LE.ERGOAL))GO TO 160
      IF((ERGL+ERRER.EQ.ERGL))GO TO 160
      IF((IT.EQ.LM1))GO TO 125
      IF((T(IT,LM1).EQ.ZERO))GO TO 70
      IF((T(IT,LM1).LE.FEXTRP))GO TO 125
      IF((ABS(T(IT,LM1)/FOUR-FEXTRP)/FEXTRP.LT.AITTOL))FEXTRP=FEXTRP*FOU
     *R
      GO TO 70
75    IF(T(1,LM1).LT.AITLOW) GO TO 175
      IF((AITKEN))GO TO 80
      H2CONV=.FALSE.
      AITKEN=.TRUE.
80    FEXTRP=T(L-2,LM1)
      IF((FEXTRP.GT.FOURP5))GO TO 65
      IF((FEXTRP.LT.AITLOW))GO TO 175
      IF((ABS(FEXTRP-T(L-3,LM1))/T(1,LM1).GT.H2TOL))GO TO 175
      SING=FEXTRP
      FEXTM1=ONE/(FEXTRP - ONE)
      AIT(1)=ZERO
      DO 85 I=2,L
      AIT(I)=T(I,1) + (T(I,1)-T(I-1,1))*FEXTM1
      R(I)=T(1,I-1)
      DIF(I)=AIT(I) - AIT(I-1)
85    CONTINUE
      IT=2
90    VINT=STEP*AIT(L)
      ERRER=ERRER*FEXTM1
      IF((ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL))GO TO 95
      ALPHA=LOG10(SING)/ALG4O2 - ONE
      IER=MAX0(IER,65)
      GO TO 160
95    IT=IT + 1
      IF((IT.EQ.LM1))GO TO 125
      IF((IT.GT.3))GO TO 100
      H2NXT=FOUR
      SINGNX=SING+SING
100   IF(H2NXT.LT.SINGNX) GO TO 105
      FEXTRP=SINGNX
      SINGNX=SINGNX+SINGNX
      GO TO 110
105   FEXTRP=H2NXT
      H2NXT=FOUR*H2NXT
110   DO 115 I=IT,LM1
      R(I+1)=ZERO
      IF((TABTLM+ABS(DIF(I+1)).NE.TABTLM))R(I+1)=DIF(I)/DIF(I+1)
115   CONTINUE
      H2TFEX=-H2TOL*FEXTRP
      IF((R(L)-FEXTRP.LT.H2TFEX))GO TO 125
      IF((R(L-1)-FEXTRP.LT.H2TFEX))GO TO 125
      ERRER=ASTEP*ABS(DIF(L))
      FEXTM1=ONE/(FEXTRP - ONE)
      DO 120 I=IT,L
      AIT(I)=AIT(I) + DIF(I)*FEXTM1
      DIF(I)=AIT(I) - AIT(I-1)
120   CONTINUE
      GO TO 90
125   FEXTRP=DMAX1(PREVER/ERRER,AITLOW)
      PREVER=ERRER
      IF((L.LT.5))GO TO 15
      IF((L-IT.GT.2.AND.ISTAGE.LT.MXSTGE))GO TO 170
      ERRET=ERRER/(FEXTRP**(MAXTBL-L))
      IF((ERRET.GT.ERGOAL.AND.(ERGL+ERRET).NE.ERGL))GO TO 170
      GO TO 15
130   IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 170
      DIFF=ABS(T(1,L))*(FN+FN)
      GO TO 160
135   SLOPE=(FEND-FBEG)*TWO
      FBEG2=FBEG+FBEG
      DO 140 I=1,4
      RVAL=BEG+RN(I)*STEP
      DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE)
      IF((TABTLM+DIFF.NE.TABTLM))GO TO 155
140   CONTINUE
      GO TO 160
145   SLOPE=(FEND-FBEG)*TWO
      FBEG2=FBEG+FBEG
      I=1
150   RVAL=BEG+RN(I)*STEP
      DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE)
155   ERRER=DMAX1(ERRER,ASTEP*DIFF)
      IF((ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL))GO TO 175
      I=I+1
      IF((I.LE.4))GO TO 150
      IER=66
160   CADRE=CADRE + VINT
      ERROR=ERROR + ERRER
      IF((RIGHT))GO TO 165
      ISTAGE=ISTAGE - 1
      IF((ISTAGE.EQ.0))GO TO 220
      REGLAR=REGLSV(ISTAGE)
      BEG=BEGIN(ISTAGE)
      END=FINIS(ISTAGE)
      CUREST=CUREST - EST(ISTAGE+1) + VINT
      IEND=IBEG - 1
      FEND=TS(IEND)
      IBEG=IBEGS(ISTAGE)
      GO TO 180
165   CUREST=CUREST + VINT
      STAGE=STAGE+STAGE
      IEND=IBEG
      IBEG=IBEGS(ISTAGE)
      END=BEG
      BEG=BEGIN(ISTAGE)
      FEND=FBEG
      FBEG=TS(IBEG)
      GO TO 5
170   REGLAR=.TRUE.
175   IF(ISTAGE.EQ.MXSTGE) GO TO 205
      IF((RIGHT))GO TO 185
      REGLSV(ISTAGE+1)=REGLAR
      BEGIN(ISTAGE)=BEG
      IBEGS(ISTAGE)=IBEG
      STAGE=STAGE*HALF
180   RIGHT=.TRUE.
      BEG=(BEG+END)*HALF
      IBEG=(IBEG+IEND)/2
      TS(IBEG)=TS(IBEG)*HALF
      FBEG=TS(IBEG)
      GO TO 10
185   NNLEFT=IBEG - IBEGS(ISTAGE)
      IF((IEND+NNLEFT.GE.MAXTS))GO TO 200
      III=IBEGS(ISTAGE)
      II=IEND
      DO 190 I=III,IBEG
      II=II + 1
      TS(II)=TS(I)
190   CONTINUE
      DO 195 I=IBEG,II
      TS(III)=TS(I)
      III=III + 1
195   CONTINUE
      IEND=IEND + 1
      IBEG=IEND - NNLEFT
      FEND=FBEG
      FBEG=TS(IBEG)
      FINIS(ISTAGE)=END
      END=BEG
      BEG=BEGIN(ISTAGE)
      BEGIN(ISTAGE)=END
      REGLSV(ISTAGE)=REGLAR
      ISTAGE=ISTAGE + 1
      REGLAR=REGLSV(ISTAGE)
      EST(ISTAGE)=VINT
      CUREST=CUREST + EST(ISTAGE)
      GO TO 5
200   IER=131
      GO TO 215
205   IER=132
      GO TO 215
210   IER=133
215   CADRE=CUREST + VINT
220   DCADRE=CADRE
9000  CONTINUE
9005  RETURN
      END
      SUBROUTINE SPINIT(density_file)
      implicit none
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/SPCOMM/MEDTBL(24,73), NUMSTMED,STDATA(6,73)
      CHARACTER*4 MEDTBL
      integer*4 NUMSTMED
      real*4 STDATA
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6), DE
     *LCMP,ALPHIP(2),BPARP(2),DELPOSP(2)
      real*4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP
      COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100)
      integer*4 NET
      real*4 ITBL,WATBL,RHOTBL
      CHARACTER*4 ASYMT
      COMMON/LSPION/CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      real*4 CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20), EPSTTL,NEPST,IEPST
     *,EPSTFLP, NELEPS,ZEPST(20),IAPRFL,IAPRIMP
      integer*4 ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP
      CHARACTER EPSTTL*80
      real*4 EPSTEN,EPSTD,WEPST
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MIXDAT/NEP,LMED,PZP(50),ZELEMP(50),WAP(50),RHOZP(50), GASPP
     *,EZ,TPZ,IDSTRN(24)
      integer*4 NEP,LMED
      real*4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ
      CHARACTER*4 IDSTRN
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      real*4 IMEV
      integer*4 IM,J,IZ,IE,I,ICHECK,IESPEL,IPEGEL,density_unit,lnblnk1,e
     *gs_get_unit
      real*4 VPLASM,ALIADG,EDENL,ALGASP,EPSTRH, TLRNCE,EPSTWT
      CHARACTER*256 density_file
      TOLN10=2.0*LOG(10.0)
      IM=-100
      IF ((EPSTFLP .LT. 0 .OR. EPSTFLP .GT. 1)) THEN
        EPSTFLP = 0
      END IF
      IF ((EPSTFLP.EQ.0)) THEN
10870   CONTINUE
          DO 10871 IM=1,NUMSTMED
          DO 10881 J=1,LMED
            IF((IDSTRN(J).NE.MEDTBL(J,IM)))GO TO 10871
10881     CONTINUE
10882     CONTINUE
          AFACT=STDATA(1,IM)
          SK=STDATA(2,IM)
          X0=STDATA(3,IM)
          X1=STDATA(4,IM)
          IEV=STDATA(5,IM)
          CBAR=STDATA(6,IM)
          IMEV=IEV*1.0E-6
          VPLASM=SQRT(EDEN*R0*C**2/PIP)
          GO TO 10890
10871   CONTINUE
10872   CONTINUE
        IM=0
        IF ((NEP.EQ.1)) THEN
          IZ=ZELEMP(1)
          IF ((IZ.EQ.1.OR.IZ.EQ.7.OR.IZ.EQ.8)) THEN
            WRITE(6,10900)
10900       FORMAT(' STOPPED IN SUBROUTINE SPINIT BECAUSE THIS',/, ' ELE
     *MENT (H, N, OR O) CAN ONLY EXIST AS A DIATOMIC MOLECULE.',/, ' REM
     *EDY:  USE COMP OPTION FOR H2, N2, OR O2 WITH NE=2,PZ=1,1'/, '     
     *AND, IN THE CASE OF A GAS, DEFINE STERNHEIMER ID',/, '   (I.E., ID
     *STRN) LIKE H2-GAS')
            call exit(21)
          END IF
          IEV=ITBL(IZ)
        ELSE
          ALIADG=0.0
          DO 10911 IE=1,NEP
            IZ=ZELEMP(IE)
            IF ((IZ.EQ.1)) THEN
              IEV=19.2
            ELSE IF((IZ.EQ.6)) THEN
              IF ((GASPP.EQ.0.0)) THEN
                IEV=81.0
              ELSE
                IEV=70.0
              END IF
            ELSE IF((IZ.EQ.7)) THEN
              IEV=82.0
            ELSE IF((IZ.EQ.8)) THEN
              IF ((GASPP.EQ.0.0)) THEN
                IEV=106.0
              ELSE
                IEV=97.0
              END IF
            ELSE IF((IZ.EQ.9)) THEN
              IEV=112.0
            ELSE IF((IZ.EQ.17)) THEN
              IEV=180.0
            ELSE
              IEV=1.13*ITBL(IZ)
            END IF
            ALIADG=ALIADG + PZP(IE)*ZELEMP(IE)*LOG(IEV)
10911     CONTINUE
10912     CONTINUE
          ALIADG=ALIADG/ZC
          IEV=EXP(ALIADG)
        END IF
        IMEV=IEV*1.0E-6
        IF ((GASPP.EQ.0.0)) THEN
          EDENL=EDEN
        ELSE
          EDENL=EDEN/GASPP
        END IF
        VPLASM = SQRT(EDENL*R0*C**2/PIP)
        CBAR=1. + 2.*LOG(IMEV/(HBAR*2*PIP*VPLASM/ERGMEV))
        IF ((NEP.EQ.1.AND.INT(ZELEMP(1)).EQ.2.AND.GASPP.NE.0.0)) THEN
          X0=2.191
          X1=3.0
          SK=3.297
        ELSE IF((NEP.EQ.2.AND.INT(ZELEMP(1)).EQ.1 .AND.INT(ZELEMP(2)).EQ
     *  .1)) THEN
          IF ((GASPP.EQ.0.0)) THEN
            X0=0.425
            X1=2.0
            SK=5.949
          ELSE
            X0=1.837
            X1=3.0
            SK=4.754
          END IF
        ELSE
          SK=3.0
          IF ((GASPP.EQ.0.0)) THEN
            IF ((IEV.LT.100.0)) THEN
              IF ((CBAR.LT.3.681)) THEN
                X0=0.2
                X1=2.0
              ELSE
                X0=0.326*CBAR - 1.0
                X1=2.0
              END IF
            ELSE
              IF ((CBAR.LT.5.215)) THEN
                X0=0.2
                X1=3.0
              ELSE
                X0=0.326*CBAR - 1.5
                X1=3.0
              END IF
            END IF
            IF ((X0.GE.X1)) THEN
              WRITE(6,10920)X0,X1,CBAR
10920         FORMAT(' STOPPED IN SPINIT DUE TO X0.GE.X1 , X0,X1,CBAR=',
     *3G15.5,/ ,' IF THIS IS GAS, YOU MUST DEFINE GASP(ATM)')
              call exit(21)
            END IF
          ELSE
            IF ((CBAR.LT.10.0)) THEN
              X0=1.6
              X1=4.0
            ELSE IF((CBAR.LT.10.5)) THEN
              X0=1.7
              X1=4.0
            ELSE IF((CBAR.LT.11.0)) THEN
              X0=1.8
              X1=4.0
            ELSE IF((CBAR.LT.11.5)) THEN
              X0=1.9
              X1=4.0
            ELSE IF((CBAR.LT.12.25)) THEN
              X0=2.0
              X1=4.0
            ELSE IF((CBAR.LT.13.804)) THEN
              X0=2.0
              X1=5.0
            ELSE
              X0=0.326*CBAR - 2.5
              X1=5.0
            END IF
          END IF
        END IF
10890   IF ((GASPP.NE.0.0)) THEN
          ALGASP=LOG(GASPP)
          CBAR=CBAR - ALGASP
          X0=X0 - ALGASP/TOLN10
          X1=X1 - ALGASP/TOLN10
        END IF
        IF ((IM.EQ.0)) THEN
          AFACT=(CBAR - TOLN10*X0)/(X1 - X0)**SK
        END IF
      ELSE
        density_file=density_file(:lnblnk1(density_file))
        density_unit=20
        density_unit=egs_get_unit(density_unit)
        IF (( density_unit .LT. 1 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'SPINIT: failed to get a free fortran unit'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(density_unit,file=density_file,status='old',err=7170)
        READ(density_unit,10930)EPSTTL
10930   FORMAT(A)
        READ(density_unit,*) NEPST,IEV,EPSTRH,NELEPS
        READ(density_unit,*) (ZEPST(I),WEPST(I),I=1,NELEPS)
        READ(density_unit,*) (EPSTEN(I),EPSTD(I),I=1,NEPST)
        close(density_unit)
        IF ((NEPST.GT.150)) THEN
          WRITE(6,10940)NEPST
10940     FORMAT(//' *****NEPST=',I4,' IS GREATER THAN THE 150 ALLOWED')
          call exit(22)
        END IF
        DO 10951 I=1,NEPST
          EPSTEN(I) = EPSTEN(I) + RMP
10951   CONTINUE
10952   CONTINUE
        IMEV = IEV*1.E-06
        IF (( AEP .LT. EPSTEN(1))) THEN
          WRITE(6,10960)EPSTEN(1),AEP
10960     FORMAT(//' ****LOWEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,E
     *10.3/ T20,'WHICH IS HIGHER THAN THE VALUE OF AE=',1P,E10.3,' MEV'/
     * ' ***IT HAS BEEN SET TO AE***'//)
          EPSTEN(1) = AEP
        END IF
        IF (( UEP .GT. EPSTEN(NEPST))) THEN
          WRITE(6,10970)EPSTEN(NEPST),UEP
10970     FORMAT(//' ****HIGHEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,
     *E10.3/ T20,'WHICH IS LOWER THAN THE VALUE OF UE=',1P,E10.3,' MEV'/
     * ' ***IT HAS BEEN SET TO UE***'//)
          EPSTEN(NEPST) = UEP
        END IF
        ICHECK=0
        TLRNCE=0.01
        IF((NELEPS.NE.NEP))ICHECK=1
        IF(((ICHECK.EQ.0) .AND. ( (EPSTRH.LT.((1.0-TLRNCE)*RHOP)) .OR. (
     *  EPSTRH.GT.((1.0+TLRNCE)*RHOP)) )))ICHECK=1
        EPSTWT = 0.0
        DO 10981 I=1,NEP
          EPSTWT = EPSTWT + RHOZP(I)
10981   CONTINUE
10982   CONTINUE
        IF ((EPSTWT.EQ.0.0)) THEN
          WRITE(6,10990)
10990     FORMAT(//' *****IN SPINIT***SOMETHING WRONG, MOLECULAR WEIGHTO
     *F', 'MOLECULE IS ZERO (I.E. SUM OF RHOZ)***'//)
        END IF
        IF ((ICHECK.EQ.0)) THEN
          IESPEL=0
          ICHECK=1
11001     CONTINUE
            IESPEL=IESPEL+1
            IPEGEL=0
11011       CONTINUE
              IPEGEL=IPEGEL+1
              IF ((INT(ZELEMP(IPEGEL)).EQ.ZEPST(IESPEL))) THEN
                ICHECK=0
                GO TO11012
              END IF
              IF(IPEGEL.GE.NEP)GO TO11012
            GO TO 11011
11012       CONTINUE
            IF(((ICHECK.EQ.0)  .AND. ( (WEPST(IESPEL).LT.((1.0-TLRNCE)*R
     *      HOZP(IPEGEL)/EPSTWT)) .OR. (WEPST(IESPEL).GT.((1.0+TLRNCE)*R
     *      HOZP(IPEGEL)/EPSTWT)) )))ICHECK=1
            IF(IESPEL.GE.NELEPS)GO TO11002
          GO TO 11001
11002     CONTINUE
        END IF
        IF ((ICHECK.EQ.1)) THEN
          WRITE(6,11020)
11020     FORMAT(////'0*** COMPOSITION IN INPUT DENSITY FILE DOES NOT MA
     *TCH ', ' THAT BEING USED BY PEGS'//' ***** QUITTING EARLY***'////)
          call exit(23)
        END IF
      END IF
      SPC1=2.*PIP*R0**2*RMP*EDEN*RLCP
      SPC2=LOG((IMEV/RMP)**2/2.0)
      RETURN
7170  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' Failed to open density file ',density_file
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      RETURN
      END
      SUBROUTINE MIX
      implicit none
      integer*4 I,IZZ
      real*4 AL183,ZAB,V2000
      real*4 FCOULCP,XSIFP
      COMMON/MIMSD/BMIN
      real*4 BMIN
      COMMON/MIXDAT/NEP,LMED,PZP(50),ZELEMP(50),WAP(50),RHOZP(50), GASPP
     *,EZ,TPZ,IDSTRN(24)
      integer*4 NEP,LMED
      real*4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ
      CHARACTER*4 IDSTRN
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183
      real*4 ALRAD,ALRADP,A1440,A183
      COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6), DE
     *LCMP,ALPHIP(2),BPARP(2),DELPOSP(2)
      real*4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP
      real*4 XSI(20),ZZX(20),FZC(20),FCOUL(20),ZZ(20)
      IF ((GASPP.NE.0.0)) THEN
        RHOP=GASPP*RHOP
      END IF
      AL183 = LOG(A183)
      TPZ=0.0
      WM=0.0
      ZC=0.0
      ZT=0.0
      ZB=0.0
      ZF=0.0
      ZS=0.0
      ZE=0.0
      ZX=0.0
      ZAB=0.0
      DO 11031 I=1,NEP
        TPZ = TPZ + PZP(I)
        WM = WM + PZP(I)*WAP(I)
        ZC = ZC + PZP(I)*ZELEMP(I)
        FZC(I) =(FSC*ZELEMP(I))**2
        FCOUL(I) = FCOULCP(ZELEMP(I))
        XSI(I) = XSIFP (ZELEMP(I))
        ZZX(I) = PZP(I)*ZELEMP(I)*(ZELEMP(I)+XSI(I))
        IF ((ZELEMP(I).LE.4.0)) THEN
          IZZ=ZELEMP(I)
          ZAB=ZAB+ZZX(I)*ALRAD(IZZ)
        ELSE
          ZAB=ZAB+ZZX(I)*(AL183+LOG(ZELEMP(I)**(-1./3.)))
        END IF
        ZT = ZT + ZZX(I)
        ZB = ZB + ZZX(I)*LOG(ZELEMP(I)**(-1./3.))
        ZF = ZF + ZZX(I)*FCOUL(I)
        ZZ(I) = PZP(I)*ZELEMP(I)*(ZELEMP(I)+1.0)
        ZS = ZS + ZZ(I)
        ZE = ZE + ZZ(I)*((-2./3.)*LOG(ZELEMP(I)))
        ZX = ZX + ZZ(I)*LOG(1.+3.34*FZC(I))
11031 CONTINUE
11032 CONTINUE
      EZ = ZC/TPZ
      ZA = AL183*ZT
      ZG = ZB/ZT
      ZP = ZB/ZA
      ZV = (ZB-ZF)/ZT
      ZU = (ZB-ZF)/ZA
      EDEN=AN*RHOP/WM*ZC
      RLCP = 1./( (AN*RHOP/WM)*4.0*FSC*R0**2*(ZAB-ZF) )
      BLCCP= A6680*RHOP*ZS*EXP(ZE/ZS)*RLCP/(WM*EXP(ZX/ZS))
      TEFF0P = ( EXP(BMIN)/BMIN )/BLCCP
      XCCP= (A22P9/RADDEG) * SQRT( ZS*RHOP*RLCP/WM )
      XR0P = XCCP*SQRT(TEFF0P*BMIN)
      RETURN
      END
      SUBROUTINE DIFFER
      implicit none
      real*4 AL183,F10,F20,A1DEN,A2DEN,B1DEN,B2DEN,C1DEN,C2DEN
      INTEGER I
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6), DE
     *LCMP,ALPHIP(2),BPARP(2),DELPOSP(2)
      real*4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP
      COMMON/DBRPR/ALFP1(2),ALFP2(2),AL2
      real*4 ALFP1,ALFP2,al2
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183
      real*4 ALRAD,ALRADP,A1440,A183
      AL2 = LOG(2.)
      AL183= LOG(A183)
      ALPHIP(1)= AL2*(4./3. + 1./(9.*AL183*(1.+ZP)))
      ALPHIP(2)= AL2*(4./3. + 1./(9.*AL183*(1.+ZU)))
      ALFP1(1)= 2./3. - 1./(36.*AL183*(1.+ZP))
      ALFP1(2)= 2./3. - 1./(36.*AL183*(1.+ZU))
      ALFP2(1)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZP)))
      ALFP2(2)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZU)))
      BPARP(1)= ALFP1(1)/(ALFP1(1)+ALFP2(1))
      BPARP(2)= ALFP1(2)/(ALFP1(2)+ALFP2(2))
      DELCMP= 136.0*EXP(ZG)*RMP
      DELPOSP(1)= (EXP((21.12+4.*ZG)/4.184)-0.952)/DELCMP
      DELPOSP(2)= (EXP((21.12+4.*ZV)/4.184)-0.952)/DELCMP
      F10=4.*AL183
      F20=F10 - 2./3.
      A1DEN =3.0*F10- F20 + 8.0*ZG
      A2DEN =3.0*F10- F20 + 8.0*ZV
      B1DEN = F10 + 4.0*ZG
      B2DEN = F10 + 4.0*ZV
      C1DEN = 3.0*F10+ F20 + 16.0*ZG
      C2DEN = 3.0*F10+ F20 + 16.0*ZV
      DLP1(1)= (3.0*20.867-20.209+8.0*ZG)/A1DEN
      DLP2(1)= (3.0*(-3.242)-(-1.930))/A1DEN
      DLP3(1)= (3.0*(0.625)-(0.086))/A1DEN
      DLP4(1)= (2.0*21.12+8.0*ZG)/A1DEN
      DLP5(1)= 2.0*(-4.184)/A1DEN
      DLP6(1)= 0.952
      DLP1(4)= (3.0*20.867-20.209+8.0*ZV)/A2DEN
      DLP2(4)= (3.0*(-3.242)-(-1.930))/A2DEN
      DLP3(4)= (3.0*(0.625)-(0.086))/A2DEN
      DLP4(4)= (2.0*21.12+8.0*ZV)/A2DEN
      DLP5(4)= 2.0*(-4.184)/A2DEN
      DLP6(4)= 0.952
      DLP1(2)= (20.867+4.0*ZG)/B1DEN
      DLP2(2)= -3.242/B1DEN
      DLP3(2)= 0.625/B1DEN
      DLP4(2)= (21.12+4.0*ZG)/B1DEN
      DLP5(2)= -4.184/B1DEN
      DLP6(2)= 0.952
      DLP1(5)= (20.867+4.0*ZV)/B2DEN
      DLP2(5)= -3.242/B2DEN
      DLP3(5)= 0.625/B2DEN
      DLP4(5)= (21.12+4.0*ZV)/B2DEN
      DLP5(5)= -4.184/B2DEN
      DLP6(5)= 0.952
      DLP1(3)= (3.0*20.867+20.209+16.0*ZG)/C1DEN
      DLP2(3)= (3.0*(-3.242)+(-1.930))/C1DEN
      DLP3(3)= (3.0*0.625+(-0.086))/C1DEN
      DLP4(3)= (4.0*21.12+16.0*ZG)/C1DEN
      DLP5(3)= 4.0*(-4.184)/C1DEN
      DLP6(3)= 0.952
      DLP1(6)= (3.0*20.867+20.209+16.0*ZV)/C2DEN
      DLP2(6)= (3.0*(-3.242)+(-1.930))/C2DEN
      DLP3(6)= (3.0*0.625+(-0.086))/C2DEN
      DLP4(6)= (4.0*21.12+16.0*ZV)/C2DEN
      DLP5(6)= 4.0*(-4.184)/C2DEN
      DLP6(6)= 0.952
      RETURN
      END
      real*4 function FCOULCP(Z)
      implicit none
      real*4 Z,ASQ
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      ASQ=(FSC*Z)**2
      FCOULCP = ASQ*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+ ASQ*(0.0083+ASQ
     **(-0.002))))
      RETURN
      END
      real*4 function XSIFP(Z)
      implicit none
      real*4 Z,FCOULCP
      integer*4 IZ
      COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183
      real*4 ALRAD,ALRADP,A1440,A183
      IF ((Z.LE.4.0)) THEN
        IZ=Z
        XSIFP=ALRADP(IZ)/(ALRAD(IZ)-FCOULCP(Z))
      ELSE
        XSIFP=ALOG(A1440*Z**(-2./3.))/(ALOG(A183*Z**(-1./3.))-FCOULCP(Z)
     *  )
      END IF
      RETURN
      END
      real*4 FUNCTION ZTBL(IASYM)
      implicit none
      COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100)
      integer*4 NET
      real*4 ITBL,WATBL,RHOTBL
      CHARACTER*4 ASYMT
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      CHARACTER*4 IASYM,IA
      integer*4 ie
      DATA IA/'A'/
      save ia
      IF ((IASYM.EQ.IA)) THEN
        ZTBL=18.0
        RETURN
      END IF
      DO 11041 IE=1,NET
        IF ((IASYM.EQ.ASYMT(IE))) THEN
          ZTBL=IE
          RETURN
        END IF
11041 CONTINUE
11042 CONTINUE
      WRITE(6,11050)IASYM,NET
11050 FORMAT(1X,A2,' NOT AN ATOMIC SYMBOL FOR AN ELEMENT WITH Z LE ',I3)
      ZTBL=0.0
      RETURN
      END
      SUBROUTINE ANNIH
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DOUBLE PRECISION PAVIP,  PESG1,  PESG2
      real*8 AVIP,  A,                  G,T,P,                      POT,
     *
     *     EP0,                                                 WSAMP,
     *                       RNNO01,
     *                     RNNO02,
     *                                   EP,
     * REJF,                                                       ESG1,
     *                                      ESG2,
     *               aa,bb,cc,sinpsi,sindel,cosdel,us,vs,cphi,sphi
      integer*4
     *                     ibr
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      integer*4 ip
      NPold = NP
      IF (( nbr_split .LE. 0 )) THEN
        return
      END IF
      PAVIP=E(NP)+PRM
      AVIP=PAVIP
      A=AVIP/RM
      G=A-1.0
      T=G-1.0
      P=SQRT(A*T)
      POT=P/T
      EP0=1.0/(A+P)
      WSAMP=LOG((1.0-EP0)/EP0)
      aa = u(np)
      bb = v(np)
      cc = w(np)
      sinpsi = aa*aa + bb*bb
      IF (( sinpsi .GT. 1e-20 )) THEN
        sinpsi = sqrt(sinpsi)
        sindel = bb/sinpsi
        cosdel = aa/sinpsi
      END IF
      IF (( nbr_split .GT. 1 )) THEN
        wt(np) = wt(np)/nbr_split
      END IF
      DO 11061 ibr=1,nbr_split
        IF (( np+1 .GT. 150 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//a,i6,a//)') ' Stack overflow in ANNIH! np = ',
     *    np+1, ' Increase $MXSTACK and try again'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
11071   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO01 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          EP=EP0*EXP(RNNO01*WSAMP)
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO02 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          REJF = 1 - (EP*A-1)**2/(EP*(A*A-2))
          IF(((RNNO02 .LE. REJF)))GO TO11072
        GO TO 11071
11072   CONTINUE
        ESG1=AVIP*EP
        PESG1=ESG1
        E(NP)=PESG1
        IQ(NP)=0
        IF (( ibr .EQ. 1 )) THEN
          ip = npold
        ELSE
          ip = np-1
        END IF
        X(np)=X(ip)
        Y(np)=Y(ip)
        Z(np)=Z(ip)
        IR(np)=IR(ip)
        WT(np)=WT(ip)
        DNEAR(np)=DNEAR(ip)
        LATCH(np)=LATCH(ip)
        COSTHE=MAX(-1.0,MIN(1.0,(ESG1-RM)*POT/ESG1))
        SINTHE=SQRT(1.0-COSTHE*COSTHE)
11081   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          xphi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          xphi = 2*xphi - 1
          xphi2 = xphi*xphi
          IF((rng_seed .GT. 128))call ranmar_get
          yphi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          yphi2 = yphi*yphi
          rhophi2 = xphi2 + yphi2
          IF(rhophi2.LE.1)GO TO11082
        GO TO 11081
11082   CONTINUE
        rhophi2 = 1/rhophi2
        cphi = (xphi2 - yphi2)*rhophi2
        sphi = 2*xphi*yphi*rhophi2
        IF (( sinpsi .GE. 1e-10 )) THEN
          us = sinthe*cphi
          vs = sinthe*sphi
          u(np) = cc*cosdel*us - sindel*vs + aa*costhe
          v(np) = cc*sindel*us + cosdel*vs + bb*costhe
          w(np) = cc*costhe - sinpsi*us
        ELSE
          u(np) = sinthe*cphi
          v(np) = sinthe*sphi
          w(np) = cc*costhe
        END IF
        np = np + 1
        PESG2=PAVIP-PESG1
        esg2 = pesg2
        e(np) = pesg2
        iq(np) = 0
        X(np)=X(np-1)
        Y(np)=Y(np-1)
        Z(np)=Z(np-1)
        IR(np)=IR(np-1)
        WT(np)=WT(np-1)
        DNEAR(np)=DNEAR(np-1)
        LATCH(np)=LATCH(np-1)
        COSTHE=MAX(-1.0,MIN(1.0,(ESG2-RM)*POT/ESG2))
        SINTHE=-SQRT(1.0-COSTHE*COSTHE)
        IF (( sinpsi .GE. 1e-10 )) THEN
          us = sinthe*cphi
          vs = sinthe*sphi
          u(np) = cc*cosdel*us - sindel*vs + aa*costhe
          v(np) = cc*sindel*us + cosdel*vs + bb*costhe
          w(np) = cc*costhe - sinpsi*us
        ELSE
          u(np) = sinthe*cphi
          v(np) = sinthe*sphi
          w(np) = cc*costhe
        END IF
        np = np + 1
11061 CONTINUE
11062 CONTINUE
      np = np-1
      RETURN
      END
      SUBROUTINE ANNIH_AT_REST
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 costhe,sinthe,cphi,sphi
      integer*4 ibr,ip
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      NPold = NP
      IF (( np+2*nbr_split-1 .GT. 150 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','ANNIH_AT_RES
     *T', ' stack size exceeded! ',' $MAXSTACK = ',150,' np = ',np+2*nbr
     *  _split-1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( nbr_split .GT. 1 )) THEN
        wt(np) = wt(np)/nbr_split
      END IF
      DO 11091 ibr=1,nbr_split
        IF((rng_seed .GT. 128))call ranmar_get
        costhe = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        costhe = 2*costhe-1
        sinthe = sqrt(max(0.0,(1-costhe)*(1+costhe)))
11101   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          xphi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          xphi = 2*xphi - 1
          xphi2 = xphi*xphi
          IF((rng_seed .GT. 128))call ranmar_get
          yphi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          yphi2 = yphi*yphi
          rhophi2 = xphi2 + yphi2
          IF(rhophi2.LE.1)GO TO11102
        GO TO 11101
11102   CONTINUE
        rhophi2 = 1/rhophi2
        cphi = (xphi2 - yphi2)*rhophi2
        sphi = 2*xphi*yphi*rhophi2
        e(np) = prm
        iq(np) = 0
        IF (( ibr .EQ. 1 )) THEN
          ip = npold
        ELSE
          ip = np-1
        END IF
        X(np)=X(ip)
        Y(np)=Y(ip)
        Z(np)=Z(ip)
        IR(np)=IR(ip)
        WT(np)=WT(ip)
        DNEAR(np)=DNEAR(ip)
        LATCH(np)=LATCH(ip)
        u(np) = sinthe*cphi
        v(np) = sinthe*sphi
        w(np) = costhe
        np = np+1
        e(np) = prm
        iq(np) = 0
        X(np)=X(np-1)
        Y(np)=Y(np-1)
        Z(np)=Z(np-1)
        IR(np)=IR(np-1)
        WT(np)=WT(np-1)
        DNEAR(np)=DNEAR(np-1)
        LATCH(np)=LATCH(np-1)
        u(np) = -u(np-1)
        v(np) = -v(np-1)
        w(np) = -w(np-1)
        np = np+1
11091 CONTINUE
11092 CONTINUE
      np = np-1
      return
      end
      SUBROUTINE BHABHA
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DOUBLE PRECISION PEIP,  PEKIN,  PEKSE2,  PESE1,  PESE2,  H1,  DCOS
     *TH
      real*8 EIP,  EKIN,  T0,  E0,  E02,  YY,  Y2,YP,YP2, BETA2,  EP0,
     *EP0C,  B1,B2,B3,B4,  RNNO03,RNNO04, BR,  REJF2,  ESE1,  ESE2
      NPold = NP
      PEIP=E(NP)
      EIP=PEIP
      PEKIN=PEIP-PRM
      EKIN=PEKIN
      T0=EKIN/RM
      E0=T0+1.
      YY=1./(T0+2.)
      E02=E0*E0
      BETA2=(E02-1.)/E02
      EP0=TE(MEDIUM)/EKIN
      EP0C=1.-EP0
      Y2=YY*YY
      YP=1.-2.*YY
      YP2=YP*YP
      B4=YP2*YP
      B3=B4+YP2
      B2=YP*(3.+Y2)
      B1=2.-Y2
11111 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO03 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        BR=EP0/(1.-EP0C*RNNO03)
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO04 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        REJF2=(1.0-BETA2*BR*(B1-BR*(B2-BR*(B3-BR*B4))))
        IF((RNNO04.LE.REJF2))GO TO11112
      GO TO 11111
11112 CONTINUE
      IF (( np+1 .GT. 150 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','BHABHA', ' s
     *tack size exceeded! ',' $MAXSTACK = ',150,' np = ',np+1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF ((BR.LT.0.5)) THEN
        IQ(NP+1)=-1
      ELSE
        IQ(NP)=-1
        IQ(NP+1)=1
        BR=1.-BR
      END IF
      BR=max(BR,0.0)
      PEKSE2=BR*EKIN
      PESE1=PEIP-PEKSE2
      PESE2=PEKSE2+PRM
      ESE1=PESE1
      ESE2=PESE2
      E(NP)=PESE1
      E(NP+1)=PESE2
      H1=(PEIP+PRM)/PEKIN
      DCOSTH=MIN(1.0D0,H1*(PESE1-PRM)/(PESE1+PRM))
      SINTHE=DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(2,1)
      NP=NP+1
      DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM)
      SINTHE=-DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(3,2)
      RETURN
      END
      SUBROUTINE BREMS
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/nist_brems/ nb_fdata(0:50,100,6), nb_xdata(0:50,100,6), nb_
     *wdata(50,100,6), nb_idata(50,100,6), nb_emin(6),nb_emax(6), nb_lem
     *in(6),nb_lemax(6), nb_dle(6),nb_dlei(6), log_ap(6)
      real*8 nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lema
     *x, nb_dle,nb_dlei,log_ap
      integer*4 nb_idata
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DOUBLE PRECISION PEIE,  PESG,  PESE
      real*8 EIE,  EKIN,  brmin,  waux,  aux,  r1,  ajj,  alias_sample1,
     * RNNO06,  RNNO07,  BR,  ESG,  ESE,  DELTA,  phi1,  phi2,  REJF
      real*8 a,b,c,                               sinpsi, sindel, cosdel
     *, us, vs,
     *                                                ztarg,
     *             tteie,                                    beta,
     *                       y2max,
     *      y2maxi,                                                   tt
     *ese,                                      rjarg1,rjarg2,rjarg3,rej
     *min,rejmid,rejmax,rejtop,rejtst,
     *                 esedei,                                 y2tst,
     *                             y2tst1,
     *                                           rtest,
     *                            xphi,yphi,xphi2,yphi2,rhophi2,cphi,sph
     *i
      integer*4
     *                 L,L1,ibr,jj,j
      real*8 z2max,z2maxi,aux1,aux3,aux4,aux5,aux2,weight
      IF((nbr_split .LT. 1))return
      NPold = NP
      PEIE=E(NP)
      EIE=PEIE
      weight = wt(np)/nbr_split
      IF ((EIE.LT.50.0)) THEN
        L=1
      ELSE
        L=3
      END IF
      L1 = L+1
      ekin = peie-prm
      brmin = ap(medium)/ekin
      waux = elke - log_ap(medium)
      IF (( ibrdst .GE. 0 )) THEN
        a = u(np)
        b = v(np)
        c = w(np)
        sinpsi = a*a + b*b
        IF (( sinpsi .GT. 1e-20 )) THEN
          sinpsi = sqrt(sinpsi)
          sindel = b/sinpsi
          cosdel = a/sinpsi
        END IF
        ztarg = zbrang(medium)
        tteie = eie/rm
        beta = sqrt((tteie-1)*(tteie+1))/tteie
        y2max = 2*beta*(1+beta)*tteie*tteie
        y2maxi = 1/y2max
        IF (( ibrdst .EQ. 1 )) THEN
          z2max = y2max+1
          z2maxi = sqrt(z2max)
        END IF
      END IF
      IF (( ibr_nist .GE. 1 )) THEN
        ajj = 1 + (waux + log_ap(medium) - nb_lemin(medium))*nb_dlei(med
     *  ium)
        jj = ajj
        ajj = ajj - jj
        IF (( jj .GT. 100 )) THEN
          jj = 100
          ajj = -1
        END IF
      END IF
      DO 11121 ibr=1,nbr_split
        IF (( ibr_nist .GE. 1 )) THEN
          IF (( ekin .GT. nb_emin(medium) )) THEN
            IF((rng_seed .GT. 128))call ranmar_get
            r1 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF (( r1 .LT. ajj )) THEN
              j = jj+1
            ELSE
              j = jj
            END IF
            br = alias_sample1(50,nb_xdata(0,j,medium), nb_fdata(0,j,med
     *      ium), nb_wdata(1,j,medium),nb_idata(1,j,medium))
          ELSE
            IF((rng_seed .GT. 128))call ranmar_get
            br = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
          END IF
          esg = ap(medium)*exp(br*waux)
          pesg = esg
          pese = peie - pesg
          ese = pese
        ELSE
11131     CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            rnno06 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rng_seed .GT. 128))call ranmar_get
            rnno07 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            br = brmin*exp(rnno06*waux)
            esg = ekin*br
            pesg = esg
            pese = peie - pesg
            ese = pese
            delta = esg/eie/ese*delcm(medium)
            aux = ese/eie
            IF (( delta .LT. 1 )) THEN
              phi1 = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medi
     *        um))
              phi2 = dl1(l1,medium)+delta*(dl2(l1,medium)+ delta*dl3(l1,
     *        medium))
            ELSE
              phi1 = dl4(l,medium)+dl5(l,medium)*log(delta+dl6(l,medium)
     *        )
              phi2 = phi1
            END IF
            rejf = (1+aux*aux)*phi1 - 2*aux*phi2/3
            IF(((rnno07 .LT. rejf)))GO TO11132
          GO TO 11131
11132     CONTINUE
        END IF
        np=np+1
        IF (( np .GT. 150 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//a,i6,a//)') ' Stack overflow in BREMS! np = ',
     *    np+1, ' Increase $MXSTACK and try again'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        e(np) = pesg
        iq(np) = 0
        X(np)=X(np-1)
        Y(np)=Y(np-1)
        Z(np)=Z(np-1)
        IR(np)=IR(np-1)
        WT(np)=WT(np-1)
        DNEAR(np)=DNEAR(np-1)
        LATCH(np)=LATCH(np-1)
        wt(np) = weight
        IF (( ibrdst .LT. 0 )) THEN
          u(np) = u(npold)
          v(np) = v(npold)
          w(np) = w(npold)
        ELSE
          IF (( ibrdst .EQ. 1 )) THEN
            ttese = ese/rm
            esedei = ttese/tteie
            rjarg1 = 1+esedei*esedei
            rjarg2 = rjarg1 + 2*esedei
            aux = 2*ese*tteie/esg
            aux = aux*aux
            aux1 = aux*ztarg
            IF (( aux1 .GT. 10 )) THEN
              rjarg3 = lzbrang(medium) + (1-aux1)/aux1**2
            ELSE
              rjarg3 = log(aux/(1+aux1))
            END IF
            rejmax = rjarg1*rjarg3-rjarg2
11141       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              y2tst = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF((rng_seed .GT. 128))call ranmar_get
              rtest = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              aux3 = z2maxi/(y2tst+(1-y2tst)*z2maxi)
              rtest = rtest*aux3*rejmax
              y2tst = aux3**2-1
              y2tst1 = esedei*y2tst/aux3**4
              aux4 = 16*y2tst1-rjarg2
              aux5 = rjarg1-4*y2tst1
              IF((rtest .LT. aux4 + aux5*rjarg3))GO TO11142
              aux2 = log(aux/(1+aux1/aux3**4))
              rejtst = aux4+aux5*aux2
              IF(((rtest .LT. rejtst )))GO TO11142
            GO TO 11141
11142       CONTINUE
          ELSE
            IF((rng_seed .GT. 128))call ranmar_get
            y2tst = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            y2tst = y2tst/(1-y2tst+y2maxi)
          END IF
          costhe = 1 - 2*y2tst*y2maxi
          sinthe = sqrt(max((1-costhe)*(1+costhe),0.0))
11151     CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            xphi = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            xphi = 2*xphi - 1
            xphi2 = xphi*xphi
            IF((rng_seed .GT. 128))call ranmar_get
            yphi = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            yphi2 = yphi*yphi
            rhophi2 = xphi2 + yphi2
            IF(rhophi2.LE.1)GO TO11152
          GO TO 11151
11152     CONTINUE
          rhophi2 = 1/rhophi2
          cphi = (xphi2 - yphi2)*rhophi2
          sphi = 2*xphi*yphi*rhophi2
          IF (( sinpsi .GE. 1e-10 )) THEN
            us = sinthe*cphi
            vs = sinthe*sphi
            u(np) = c*cosdel*us - sindel*vs + a*costhe
            v(np) = c*sindel*us + cosdel*vs + b*costhe
            w(np) = c*costhe - sinpsi*us
          ELSE
            u(np) = sinthe*cphi
            v(np) = sinthe*sphi
            w(np) = c*costhe
          END IF
        END IF
11121 CONTINUE
11122 CONTINUE
      e(npold) = pese
      RETURN
      END
      SUBROUTINE COMPT
      implicit none
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,6), eno_array(200,6), eno_atbin_array(200,6), n_sh
     *ell(6), radc_flag,  ibcmp( 2001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      DOUBLE PRECISION PEIG,  PESG,  PESE
      real*8 ko,  broi,  broi2,  bro,  bro1,  alph1,  alph2,  alpha,  rn
     *no15,rnno16,rnno17,rnno18,rnno19,  br,  temp,  rejf3,  rejmax,  Uj
     *,  Jo,  br2,  fpz,fpz1, qc,  qc2,  af,  Fmax,  frej,  eta_incoh, e
     *ta,  aux,aux1,aux2,aux3,aux4,  pzmax,  pz,  pz2,  rnno_RR
      integer*4 irl,  i,  j,  iarg,  ip
      logical first_time
      integer*4 ibcmpl
      NPold = NP
      peig=E(NP)
      ko = peig/rm
      broi = 1 + 2*ko
      irl = ir(np)
      first_time = .true.
      ibcmpl = ibcmp(irl)
11160 CONTINUE
      IF (( ibcmpl .GT. 0 )) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        rnno17 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        rnno17 = 1 + rnno17*n_shell(medium)
        i = int(rnno17)
        IF((rnno17 .GT. eno_array(i,medium)))i = eno_atbin_array(i,mediu
     *  m)
        j = shell_array(i,medium)
        Uj = be_array(j)
        IF (( ko .LE. Uj )) THEN
          IF (( ibcmpl .EQ. 1 )) THEN
            goto 11170
          ELSE
            goto 11160
          END IF
        END IF
        Jo = Jo_array(j)
      END IF
11180 CONTINUE
      IF (( ko .GT. 2 )) THEN
        IF (( first_time )) THEN
          broi2 = broi*broi
          alph1 = Log(broi)
          bro = 1/broi
          alph2 = ko*(broi+1)*bro*bro
          alpha = alph1+alph2
        END IF
11191   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          rnno15 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          rnno16 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF (( rnno15*alpha .LT. alph1 )) THEN
            br = Exp(alph1*rnno16)*bro
          ELSE
            br = Sqrt(rnno16*broi2 + (1-rnno16))*bro
          END IF
          temp = (1-br)/(ko*br)
          sinthe = Max(0.,temp*(2-temp))
          aux = 1+br*br
          rejf3 = aux - br*sinthe
          IF((rng_seed .GT. 128))call ranmar_get
          rnno19 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rnno19*aux.le.rejf3))GO TO11192
        GO TO 11191
11192   CONTINUE
      ELSE
        IF (( first_time )) THEN
          bro = 1./broi
          bro1 = 1 - bro
          rejmax = broi + bro
        END IF
11201   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          rnno15 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          rnno16 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          br = bro + bro1*rnno15
          temp = (1-br)/(ko*br)
          sinthe = Max(0.,temp*(2-temp))
          rejf3 = 1 + br*br - br*sinthe
          IF((rnno16*br*rejmax.le.rejf3))GO TO11202
        GO TO 11201
11202   CONTINUE
      END IF
      first_time = .false.
      IF ((br .LT. bro .OR. br .GT. 1)) THEN
        IF (( br .LT. 0.99999/broi .OR. br .GT. 1.00001 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' sampled br outside of allowed range! ',ko,1./
     *    broi,br
        END IF
        goto 11180
      END IF
      costhe = 1 - temp
      IF (( ibcmp(irl) .EQ. 0 )) THEN
        Uj = 0
        goto 11210
      END IF
      br2 = br*br
      aux = ko*(ko-Uj)*temp
      aux1 = 2*aux + Uj*Uj
      pzmax = aux - Uj
      IF (( pzmax .LT. 0 .AND. pzmax*pzmax .GE. aux1 )) THEN
        IF (( ibcmpl .EQ. 1 )) THEN
          goto 11170
        ELSE
          goto 11160
        END IF
      END IF
      pzmax = pzmax/sqrt(aux1)
      qc2 = 1 + br*br - 2*br*costhe
      qc = sqrt(qc2)
      IF (( pzmax .GT. 1 )) THEN
        pzmax = 1
        af = 0
        Fmax = 1
        fpz = 1
        goto 11220
      END IF
      aux3 = 1 + 2*Jo*abs(pzmax)
      aux4 = 0.5*(1-aux3*aux3)
      fpz = 0.5*exp(aux4)
      af = qc*(1+br*(br-costhe)/qc2)
      IF (( af .LT. 0 )) THEN
        IF((pzmax .GT. 0))fpz = 1 - fpz
        IF((rng_seed .GT. 128))call ranmar_get
        eta_incoh = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( eta_incoh .GT. fpz )) THEN
          IF (( ibcmpl .EQ. 1 )) THEN
            goto 11170
          ELSE
            goto 11160
          END IF
        END IF
        af = 0
        Fmax = 1
        goto 11220
      END IF
      IF (( pzmax .LT. -0.15 )) THEN
        Fmax = 1-af*0.15
        fpz1 = fpz*Fmax*Jo
      ELSE IF(( pzmax .LT. 0.15 )) THEN
        Fmax = 1 + af*pzmax
        aux3 = 1/(1+0.33267252734*aux3)
        aux4 = fpz*aux3*(0.3480242+aux3*(-0.0958798+aux3*0.7478556)) + e
     *  rfJo_array(j)
        IF (( pzmax .GT. 0 )) THEN
          fpz1 = (1 - Fmax*fpz)*Jo - 0.62665706866*af*aux4
          fpz = 1 - fpz
        ELSE
          fpz1 = Fmax*fpz*Jo - 0.62665706866*af*aux4
        END IF
      ELSE
        Fmax = 1 + af*0.15
        fpz1 = (1 - Fmax*fpz)*Jo
        fpz = 1 - fpz
      END IF
      IF((rng_seed .GT. 128))call ranmar_get
      eta_incoh = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF ((eta_incoh*Jo .GT. fpz1 )) THEN
        IF (( ibcmpl .EQ. 1 )) THEN
          goto 11170
        ELSE
          goto 11160
        END IF
      END IF
11220 CONTINUE
      IF (( ibcmpl .NE. 2 )) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        rnno18 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        rnno18 = rnno18*fpz
        IF (( rnno18 .LT. 0.5 )) THEN
          rnno18 = Max(1e-30,2*rnno18)
          pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo
        ELSE
          rnno18 = 2*(1-rnno18)
          pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo
        END IF
        IF((abs(pz) .GT. 1))goto 11220
        IF (( pz .LT. 0.15 )) THEN
          IF (( pz .LT. -0.15 )) THEN
            frej = 1 - af*0.15
          ELSE
            frej = 1 + af*pz
          END IF
          IF((rng_seed .GT. 128))call ranmar_get
          eta = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((eta*Fmax .GT. frej))goto 11220
        END IF
      ELSE
        pz = 0
        Uj = 0
      END IF
      pz2 = pz*pz
      IF (( abs(pz) .LT. 0.01 )) THEN
        br = br*(1 + pz*(qc + (br2-costhe)*pz))
      ELSE
        aux = 1 - pz2*br*costhe
        aux1 = 1 - pz2*br2
        aux2 = qc2 - br2*pz2*sinthe
        IF (( aux2 .GT. 1e-10 )) THEN
          br = br/aux1*(aux+pz*Sqrt(aux2))
        END IF
      END IF
      Uj = Uj*prm
11210 pesg = br*peig
      pese = peig - pesg - Uj + prm
      sinthe = Sqrt(sinthe)
      call uphi(2,1)
      e(np) = pesg
      aux = 1 + br*br - 2*br*costhe
      IF (( aux .GT. 1e-8 )) THEN
        costhe = (1-br*costhe)/Sqrt(aux)
        sinthe = (1-costhe)*(1+costhe)
        IF (( sinthe .GT. 0 )) THEN
          sinthe = -Sqrt(sinthe)
        ELSE
          sinthe = 0
        END IF
      ELSE
        costhe = 0
        sinthe = -1
      END IF
      np = np + 1
      IF (( np .GT. 150 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','COMPT', ' st
     *ack size exceeded! ',' $MAXSTACK = ',150,' np = ',np
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      call uphi(3,2)
      e(np) = pese
      iq(np) = -1
      IF (( ibcmpl .EQ. 1 .OR. ibcmpl .EQ. 3 )) THEN
        IF (( Uj .GT. 1e-3 )) THEN
          edep = pzero
          call relax(Uj,shn_array(j),iz_array(j))
        ELSE
          edep = Uj
          edep_local = edep
          IARG=33
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
        END IF
        IF (( edep .GT. 0 )) THEN
          IARG=4
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,11230)prob_RR
11230       FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold+1
11241     CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF((rng_seed .GT. 128))call ranmar_get
              rnno_RR = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO11242
          GO TO 11241
11242     CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
11170 return
      end
      SUBROUTINE old_COMPT
      implicit none
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,6), eno_array(200,6), eno_atbin_array(200,6), n_sh
     *ell(6), radc_flag,  ibcmp( 2001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      DOUBLE PRECISION PEIG,  PESG,  PESE
      real*8 ko,  broi,  broi2,  bro,  bro1,  alph1,  alph2,  alpha,  rn
     *no15,rnno16,rnno17,rnno18,rnno19,  br,  temp,  rejf3,  rejmax,  Uj
     *,  br2,  aux,aux1,aux2, pzmax2,  pz,  pz2,  rnno_RR
      integer*4 irl,  i,  j,  iarg,  ip
      i_survived_RR = 0
      NPold = NP
      peig=E(NP)
      ko = peig/rm
      broi = 1 + 2*ko
      irl = ir(np)
      IF (( ibcmp(irl) .EQ. 1 )) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        rnno17 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        DO 11251 i=1,n_shell(medium)
          rnno17 = rnno17 - eno_array(i,medium)
          IF((rnno17 .LE. 0))GO TO11252
11251   CONTINUE
11252   CONTINUE
        j = shell_array(i,medium)
        Uj = be_array(j)
        IF (( ko .LE. Uj )) THEN
          goto 11260
        END IF
      END IF
11270 CONTINUE
      IF (( ko .GT. 2 )) THEN
        broi2 = broi*broi
        alph1 = Log(broi)
        alph2 = ko*(broi+1)/broi2
        alpha = alph1/(alph1+alph2)
11281   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          rnno15 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          rnno16 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF (( rnno15 .LT. alpha )) THEN
            br = Exp(alph1*rnno16)/broi
          ELSE
            br = Sqrt(rnno16 + (1-rnno16)/broi2)
          END IF
          temp = (1-br)/ko/br
          sinthe = Max(0.,temp*(2-temp))
          rejf3 = 1 - br*sinthe/(1+br*br)
          IF((rng_seed .GT. 128))call ranmar_get
          rnno19 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rnno19.le.rejf3))GO TO11282
        GO TO 11281
11282   CONTINUE
      ELSE
        bro = 1./broi
        bro1 = 1 - bro
        rejmax = broi + bro
11291   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          rnno15 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          rnno16 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          br = bro + bro1*rnno15
          temp = (1-br)/ko/br
          sinthe = Max(0.,temp*(2-temp))
          rejf3 = (br + 1./br - sinthe)/rejmax
          IF((rnno16.le.rejf3))GO TO11292
        GO TO 11291
11292   CONTINUE
      END IF
      IF ((br .LT. 1./broi .OR. br .GT. 1)) THEN
        IF (( br .LT. 0.99999/broi .OR. br .GT. 1.00001 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' sampled br outside of allowed range! ',ko,1./
     *    broi,br
        END IF
        goto 11270
      END IF
      IF (( ibcmp(irl) .EQ. 0 )) THEN
        Uj = 0
        costhe = 1 - temp
        goto 11300
      END IF
      br2 = br*br
      costhe = 1 - temp
      aux = ko*(ko-Uj)*temp
      aux1 = aux-Uj
      pzmax2 = aux1*aux1/(2*aux+Uj*Uj)
11310 CONTINUE
      IF((rng_seed .GT. 128))call ranmar_get
      rnno18 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF (( rnno18 .LT. 0.5 )) THEN
        rnno18 = Max(1e-30,2*rnno18)
        pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo_array(j)
        pz2 = pz*pz
        IF (( (pz2 .LE. pzmax2) .AND. (aux1 .LT. 0) )) THEN
          goto 11260
        END IF
      ELSE
        IF (( aux1 .LT. 0 )) THEN
          goto 11260
        END IF
        rnno18 = 2*(1-rnno18)
        pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo_array(j)
        pz2 = pz*pz
        IF (( pz2 .GE. pzmax2 )) THEN
          goto 11260
        END IF
      END IF
      IF((abs(pz) .GT. 1))goto 11310
      aux = 1 - pz2*br*costhe
      aux1 = 1 - pz2*br2
      aux2 = 1-2*br*costhe+br2*(1-pz2*sinthe)
      IF (( aux2 .GT. 1e-10 )) THEN
        br = br/aux1*(aux+pz*Sqrt(aux2))
      END IF
      Uj = Uj*prm
11300 pesg = br*peig
      pese = peig - pesg - Uj + prm
      sinthe = Sqrt(sinthe)
      call uphi(2,1)
      e(np) = pesg
      aux = 1 + br*br - 2*br*costhe
      IF (( aux .GT. 1e-8 )) THEN
        costhe = (1-br*costhe)/Sqrt(aux)
        sinthe = (1-costhe)*(1+costhe)
        IF (( sinthe .GT. 0 )) THEN
          sinthe = -Sqrt(sinthe)
        ELSE
          sinthe = 0
        END IF
      ELSE
        costhe = 0
        sinthe = -1
      END IF
      np = np + 1
      IF (( np .GT. 150 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','COMPT', ' st
     *ack size exceeded! ',' $MAXSTACK = ',150,' np = ',np
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      call uphi(3,2)
      e(np) = pese
      iq(np) = -1
      IF (( ibcmp(irl) .EQ. 1 )) THEN
        IF (( Uj .GT. 1e-3 )) THEN
          edep = 0
          call relax(Uj,shn_array(j),iz_array(j))
        ELSE
          edep = Uj
        END IF
        IF (( edep .GT. 0 )) THEN
          IARG=4
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,11320)prob_RR
11320       FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold+1
11331     CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF((rng_seed .GT. 128))call ranmar_get
              rnno_RR = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO11332
          GO TO 11331
11332     CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
11260 return
      end
      SUBROUTINE ELECTR(IRCODE)
      implicit none
      integer*4 IRCODE
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      real*8 SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERVR/ CEXPTR,GWAIT(150),DUMU,NP_INC(150),MAFORC,IFORCE,NF
     *MIN,NFMAX,NFTIME, ISOURC,IFPB,IQINC,MONOEN,IRODUM,IRNDUM,MEDDUM,ID
     *UM,MEDTMP, PATHL,DELTAP,GWTOLD,EPSLON,ARG
      real*8 CEXPTR,GWAIT,DUMU,PATHL,DELTAP,GWTOLD,EPSLON,ARG
      integer*4 NP_INC,MAFORC,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQIN
     *C, MONOEN,IRODUM,IRNDUM,MEDDUM,IDUM,MEDTMP
      COMMON/USERRR/
     *              CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,
     *                            EKETST,ELKETS,ZL,RL,CDIST,IGEOM,IRANGE
     *,MINZ,MAXZ,MINR,MAXR,IREJCT
      real*8 CRANGE,ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,EKETST,ELKETS
     *,ZL,RL,CDIST
      integer*4 MINZ,MAXZ,MINR,MAXR
      integer*4 IREJCT,IRANGE,IGEOM
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/ET_control/ smaxir( 2001),estepe,ximax,  skindepth_for_bca,
     *transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      COMMON/GEOM/ZPLANE( 501),RCYL(0:4), CYRAD2(4),NTRACK( 2001),NZ,NR,
     *NREG,NPLANE
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NTRACK,NZ,NR,NREG,NPLANE
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(6), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),  e
     *ii_sh(40),  eii_nshells(100),  eii_nsh(6),  eii_first(6,50),  eii_
     *no(6,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      real*8 lambda_max, sigratio, u_tmp, v_tmp, w_tmp
      LOGICAL random_tustep
      DOUBLE PRECISION  demfp,  peie,  total_tstep,  total_de
      real*8 ekems,  elkems,  chia2,  etap,  lambda,  blccl,  xccl,  xi,
     *  xi_corr,  ms_corr, p2,  beta2,  de,  save_de,  dedx,  dedx0,  de
     *dxmid,  ekei,  elkei,  aux,  ebr1,  eie,  ekef,  elkef,  ekeold,
     *eketmp,  elktmp,  fedep,  tuss,  pbr1,  pbr2,  range,  rfict,  rnn
     *e1,  rnno24,  rnno25,  rnnotu,  rnnoss,  sig,  sig0,  sigf,  skind
     *epth,  ssmfp,  tmxs,  tperp,  ustep0,  uscat,  vscat,  wscat,  xtr
     *ans,  ytrans,  ztrans,  cphi,sphi
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      integer*4 iarg,  idr,  ierust,  irl,  lelec,  qel,  lelke,  lelkem
     *s,  lelkef,  lelktmp,  ibr
      logical  callhowfar,   domultiple,  dosingle,   callmsdist,
     *                findindex,
     *              spin_index,                                   comput
     *e_tstep
     *
      data ierust/0/
      save ierust
      ircode = 1
      irold = ir(np)
      irl = irold
      medium = med(irl)
11340 CONTINUE
11341   CONTINUE
        lelec = iq(np)
        qel = (1+lelec)/2
        peie = e(np)
        eie = peie
        IF ((eie .LE. ecut(irl))) THEN
          go to 11350
        END IF
        IF ((WT(NP) .EQ. 0.0)) THEN
          go to 11360
        END IF
11370   CONTINUE
11371     CONTINUE
          compute_tstep = .true.
          eke = eie - rm
          IF ((medium .NE. 0)) THEN
            IF((rng_seed .GT. 128))call ranmar_get
            RNNE1 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF ((RNNE1.EQ.0.0)) THEN
              RNNE1=1.E-30
            END IF
            DEMFP=MAX(-LOG(RNNE1),1.E-8)
            elke = log(eke)
            Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
            IF (( sig_ismonotone(qel,medium) )) THEN
              IF ((lelec .LT. 0)) THEN
                sigf=esig1(Lelke,MEDIUM)*elke+esig0(Lelke,MEDIUM)
                dedx0=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
                sigf = sigf/dedx0
              ELSE
                sigf=psig1(Lelke,MEDIUM)*elke+psig0(Lelke,MEDIUM)
                dedx0=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
                sigf = sigf/dedx0
              END IF
              sig0 = sigf
            ELSE
              IF (( lelec .LT. 0 )) THEN
                sig0 = esig_e(medium)
              ELSE
                sig0 = psig_e(medium)
              END IF
            END IF
          END IF
11380     CONTINUE
11381       CONTINUE
            IF ((medium .EQ. 0)) THEN
              tstep = vacdst
              ustep = tstep
              tustep = ustep
              callhowfar = .true.
              ustep = tustep
            ELSE
              RHOF=RHOR(IRL)/RHO(MEDIUM)
              sig = sig0
              IF ((sig .LE. 0)) THEN
                tstep = vacdst
                sig0 = 1.E-15
              ELSE
                IF (( compute_tstep )) THEN
                  total_de = demfp/sig
                  fedep = total_de
                  ekef = eke - fedep
                  IF (( ekef .LE. E_array(1,medium) )) THEN
                    tstep = vacdst
                  ELSE
                    elkef = Log(ekef)
                    Lelkef=eke1(MEDIUM)*elkef+eke0(MEDIUM)
                    IF (( lelkef .EQ. lelke )) THEN
                      fedep = 1 - ekef/eke
                      elktmp = 0.5*(elke+elkef+0.25*fedep*fedep*(1+fedep
     *                *(1+0.875*fedep)))
                      lelktmp = lelke
                      IF ((lelec .LT. 0)) THEN
                        dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = ededx1(lelktmp,medium)*dedxmid
                      ELSE
                        dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = pdedx1(lelktmp,medium)*dedxmid
                      END IF
                      aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
                      tstep = fedep*eke*dedxmid*(1+aux)
                    ELSE
                      ekei = E_array(lelke,medium)
                      elkei = (lelke - eke0(medium))/eke1(medium)
                      fedep = 1 - ekei/eke
                      elktmp = 0.5*(elke+elkei+0.25*fedep*fedep*(1+fedep
     *                *(1+0.875*fedep)))
                      lelktmp = lelke
                      IF ((lelec .LT. 0)) THEN
                        dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = ededx1(lelktmp,medium)*dedxmid
                      ELSE
                        dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = pdedx1(lelktmp,medium)*dedxmid
                      END IF
                      aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
                      tuss = fedep*eke*dedxmid*(1+aux)
                      ekei = E_array(lelkef+1,medium)
                      elkei = (lelkef + 1 - eke0(medium))/eke1(medium)
                      fedep = 1 - ekef/ekei
                      elktmp = 0.5*(elkei+elkef+0.25*fedep*fedep*(1+fede
     *                p*(1+0.875*fedep)))
                      lelktmp = lelkef
                      IF ((lelec .LT. 0)) THEN
                        dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = ededx1(lelktmp,medium)*dedxmid
                      ELSE
                        dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = pdedx1(lelktmp,medium)*dedxmid
                      END IF
                      aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
                      tstep = fedep*ekei*dedxmid*(1+aux)
                      tstep=tstep+tuss+ range_ep(qel,lelke,medium)-range
     *                _ep(qel,lelkef+1,medium)
                    END IF
                  END IF
                  total_tstep = tstep
                  compute_tstep = .false.
                END IF
                tstep = total_tstep/rhof
              END IF
              IF ((lelec .LT. 0)) THEN
                dedx0=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
              ELSE
                dedx0=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
              END IF
              dedx = rhof*dedx0
              tmxs=tmxs1(Lelke,MEDIUM)*elke+tmxs0(Lelke,MEDIUM)
              tmxs = tmxs/rhof
              ekei = E_array(lelke,medium)
              elkei = (lelke - eke0(medium))/eke1(medium)
              fedep = 1 - ekei/eke
              elktmp = 0.5*(elke+elkei+0.25*fedep*fedep*(1+fedep*(1+0.87
     *        5*fedep)))
              lelktmp = lelke
              IF ((lelec .LT. 0)) THEN
                dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelktmp,MED
     *          IUM)
                dedxmid = 1/dedxmid
                aux = ededx1(lelktmp,medium)*dedxmid
              ELSE
                dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelktmp,MED
     *          IUM)
                dedxmid = 1/dedxmid
                aux = pdedx1(lelktmp,medium)*dedxmid
              END IF
              aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
              range = fedep*eke*dedxmid*(1+aux)
              range = (range + range_ep(qel,lelke,medium))/rhof
              random_tustep = .false.
              IF ((random_tustep)) THEN
                IF((rng_seed .GT. 128))call ranmar_get
                rnnotu = rng_array(rng_seed)*twom24
                rng_seed = rng_seed + 1
                tmxs = rnnotu*min(tmxs,smaxir(irl))
              ELSE
                tmxs = min(tmxs,smaxir(irl))
              END IF
              tustep = min(tstep,tmxs,range)
              call hownear(tperp,x(np),y(np),z(np),ir(np))
              dnear(np) = tperp
              IF (( i_do_rr(irl) .EQ. 1 .AND. e(np) .LT. e_max_rr(irl) )
     *        ) THEN
                IF ((tperp .GE. range)) THEN
                  idisc = 50 + 49*iq(np)
                  go to 11360
                END IF
              END IF
              IF (((IREJCT .GT. 0) .AND. (MED(IRL) .GT. 0) .AND. (IQ(NP)
     *         .NE. 0))) THEN
                ZL=Z(NP)
                RL=SQRT(X(NP)**2+Y(NP)**2)
                IGEOM=NTRACK(IRL)
                CDIST = 0.0
                IF ((IGEOM .EQ. 10)) THEN
                  CDIST=ZMINR-ZL
                ELSE IF((IGEOM .EQ. 20)) THEN
                  CDIST=RL-RMAXR
                ELSE IF((IGEOM .EQ. 30)) THEN
                  CDIST=ZL-ZMAXR
                ELSE IF((IGEOM .EQ. 40)) THEN
                  CDIST=MIN(ZL-ZMINR,ZMAXR-ZL,RMINR-RL)
                ELSE IF((IGEOM .EQ. 50)) THEN
                  CDIST=SQRT((RL-RMAXR)**2+(ZMINR-ZL)**2)
                ELSE IF((IGEOM .EQ. 60)) THEN
                  CDIST=SQRT((RL-RMAXR)**2+(ZL-ZMAXR)**2)
                ELSE IF((IGEOM .EQ. 70)) THEN
                  CDIST=SQRT((RL-RMINR)**2+(ZMINR-ZL)**2)
                ELSE IF((IGEOM .EQ. 80)) THEN
                  CDIST=SQRT((RL-RMINR)**2+(ZL-ZMAXR)**2)
                END IF
                IF ((CDIST .GE.RANGE)) THEN
                  IDISC=1
                  go to 11360
                END IF
              END IF
              blccl = rhof*blcc(medium)
              xccl = rhof*xcc(medium)
              p2 = eke*(eke+rmt2)
              beta2 = p2/(p2 + rmsq)
              IF (( spin_effects )) THEN
                IF ((lelec .LT. 0)) THEN
                  etap=etae_ms1(Lelke,MEDIUM)*elke+etae_ms0(Lelke,MEDIUM
     *            )
                ELSE
                  etap=etap_ms1(Lelke,MEDIUM)*elke+etap_ms0(Lelke,MEDIUM
     *            )
                END IF
                ms_corr=blcce1(Lelke,MEDIUM)*elke+blcce0(Lelke,MEDIUM)
                blccl = blccl/etap/(1+0.25*etap*xccl/blccl/p2)*ms_corr
              END IF
              ssmfp=beta2/blccl
              skindepth = skindepth_for_bca*ssmfp
              tustep = min(tustep,max(tperp,skindepth))
              count_all_steps = count_all_steps + 1
              is_ch_step = .false.
              IF (((tustep .LE. tperp) .AND. ((.NOT.exact_bca) .OR. (tus
     *        tep .GT. skindepth)))) THEN
                callhowfar = .false.
                domultiple = .false.
                dosingle = .false.
                callmsdist = .true.
                tuss = range - range_ep(qel,lelke,medium)/rhof
                IF (( tuss .GE. tustep )) THEN
                  IF (( lelec .LT. 0 )) THEN
                    dedxmid=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIU
     *              M)
                    aux = ededx1(lelke,medium)/dedxmid
                  ELSE
                    dedxmid=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIU
     *              M)
                    aux = pdedx1(lelke,medium)/dedxmid
                  END IF
                  de = dedxmid*tustep*rhof
                  fedep = de/eke
                  de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.2
     *            5*fedep*(2-aux*(4-aux)))))
                ELSE
                  lelktmp = lelke
                  tuss = (range - tustep)*rhof
                  IF (( tuss .LE. 0 )) THEN
                    de = eke - TE(medium)*0.99
                  ELSE
11391               IF(tuss.GE.range_ep(qel,lelktmp,medium))GO TO 11392
                      lelktmp = lelktmp - 1
                    GO TO 11391
11392               CONTINUE
                    elktmp = (lelktmp+1-eke0(medium))/eke1(medium)
                    eketmp = E_array(lelktmp+1,medium)
                    tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof
                    IF (( lelec .LT. 0 )) THEN
                      dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelkt
     *                mp,MEDIUM)
                      aux = ededx1(lelktmp,medium)/dedxmid
                    ELSE
                      dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelkt
     *                mp,MEDIUM)
                      aux = pdedx1(lelktmp,medium)/dedxmid
                    END IF
                    de = dedxmid*tuss*rhof
                    fedep = de/eketmp
                    de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0
     *              .25*fedep*(2-aux*(4-aux)))))
                    de = de + eke - eketmp
                  END IF
                END IF
                tvstep = tustep
                is_ch_step = .true.
                IF ((transport_algorithm .EQ. 0)) THEN
                  call msdist_pII (  eke,de,tustep,rhof,medium,qel,spin_
     *            effects, u(np),v(np),w(np),x(np),y(np),z(np),  uscat,v
     *            scat,wscat,xtrans,ytrans,ztrans,ustep )
                ELSE
                  call msdist_pI (  eke,de,tustep,rhof,medium,qel,spin_e
     *            ffects, u(np),v(np),w(np),x(np),y(np),z(np),  uscat,vs
     *            cat,wscat,xtrans,ytrans,ztrans,ustep )
                END IF
              ELSE
                callmsdist = .false.
                IF ((exact_bca)) THEN
                  domultiple = .false.
                  IF((rng_seed .GT. 128))call ranmar_get
                  rnnoss = rng_array(rng_seed)*twom24
                  rng_seed = rng_seed + 1
                  IF (( rnnoss .LT. 1.e-30 )) THEN
                    rnnoss = 1.e-30
                  END IF
                  lambda = - Log(1 - rnnoss)
                  lambda_max = 0.5*blccl*rm/dedx*(eke/rm+1)**3
                  IF (( lambda .GE. 0 .AND. lambda_max .GT. 0 )) THEN
                    IF (( lambda .LT. lambda_max )) THEN
                      tuss=lambda*ssmfp*(1-0.5*lambda/lambda_max)
                    ELSE
                      tuss = 0.5 * lambda * ssmfp
                    END IF
                    IF ((tuss .LT. tustep)) THEN
                      tustep = tuss
                      dosingle = .true.
                    ELSE
                      dosingle = .false.
                    END IF
                  ELSE
                    write(i_log,'(/a)') '***************** Warning: '
                    write(i_log,*) ' lambda > lambda_max: ', lambda,lamb
     *              da_max,' eke dedx: ',eke,dedx, ' ir medium blcc: ',i
     *              r(np),medium,blcc(medium), ' position = ',x(np),y(np
     *              ),z(np)
                    dosingle = .false.
                    np=np-1
                    return
                  END IF
                  ustep = tustep
                ELSE
                  dosingle = .false.
                  domultiple = .true.
                  ekems = eke - 0.5*tustep*dedx
                  p2 = ekems*(ekems+rmt2)
                  beta2 = p2/(p2 + rmsq)
                  chia2 = xccl/(4*blccl*p2)
                  xi = 0.5*xccl/p2/beta2*tustep
                  IF (( spin_effects )) THEN
                    elkems = Log(ekems)
                    Lelkems=eke1(MEDIUM)*elkems+eke0(MEDIUM)
                    IF ((lelec .LT. 0)) THEN
                      etap=etae_ms1(Lelkems,MEDIUM)*elkems+etae_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1ce_ms1(Lelkems,MEDIUM)*elkems+q1ce_ms0(L
     *                elkems,MEDIUM)
                    ELSE
                      etap=etap_ms1(Lelkems,MEDIUM)*elkems+etap_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1cp_ms1(Lelkems,MEDIUM)*elkems+q1cp_ms0(L
     *                elkems,MEDIUM)
                    END IF
                    chia2 = chia2*etap
                    xi = xi*xi_corr
                    ms_corr=blcce1(Lelkems,MEDIUM)*elkems+blcce0(Lelkems
     *              ,MEDIUM)
                    blccl = blccl*ms_corr
                  ELSE
                    xi_corr = 1
                    etap = 1
                  END IF
                  xi = xi*(Log(1+1./chia2)-1/(1+chia2))
                  IF (( xi .LT. 0.1 )) THEN
                    ustep = tustep*(1 - xi*(0.5 - xi*0.166667))
                  ELSE
                    ustep = tustep*(1 - Exp(-xi))/xi
                  END IF
                END IF
                IF ((ustep .LT. tperp)) THEN
                  callhowfar = .false.
                ELSE
                  callhowfar = .true.
                END IF
              END IF
            END IF
            irold = ir(np)
            irnew = ir(np)
            idisc = 0
            ustep0 = ustep
            IF ((callhowfar .OR. wt(np) .LE. 0)) THEN
              call howfar
            END IF
            IF ((idisc .GT. 0)) THEN
              go to 11360
            END IF
            IF ((ustep .LE. 0)) THEN
              IF ((ustep .LT. -1e-4)) THEN
                ierust = ierust + 1
                WRITE(6,11400)ierust,ustep,dedx,e(np)-prm, ir(np),irnew,
     *          irold,x(np),y(np),z(np)
11400           FORMAT(i4,' Negative ustep = ',e12.5,' dedx=',F8.4,' ke=
     *',F8.4, ' ir,irnew,irold =',3i4,' x,y,z =',4e10.3)
                IF ((ierust .GT. 1000)) THEN
                  WRITE(6,11410)
11410             FORMAT(////' Called exit---too many ustep errors'///)
                  call exit(1)
                END IF
              END IF
              ustep = 0
            END IF
            IF ((ustep .EQ. 0 .OR. medium .EQ. 0)) THEN
              IF ((ustep .NE. 0)) THEN
                IF (.false.) THEN
                  edep = pzero
                ELSE
                  vstep = ustep
                  tvstep = vstep
                  edep = pzero
                  e_range = vacdst
                  IARG=0
                  IF ((IAUSFL(IARG+1).NE.0)) THEN
                    CALL AUSGAB(IARG)
                  END IF
                  x(np) = x(np) + u(np)*vstep
                  y(np) = y(np) + v(np)*vstep
                  z(np) = z(np) + w(np)*vstep
                  dnear(np) = dnear(np) - vstep
                END IF
              END IF
              IF ((irnew .NE. irold)) THEN
                ir(np) = irnew
                irl = irnew
                medium = med(irl)
              END IF
              IF ((ustep .NE. 0)) THEN
                IARG=5
                IF ((IAUSFL(IARG+1).NE.0)) THEN
                  CALL AUSGAB(IARG)
                END IF
              END IF
              IF ((eie .LE. ecut(irl))) THEN
                go to 11350
              END IF
              IF ((ustep .NE. 0 .AND. idisc .LT. 0)) THEN
                go to 11360
              END IF
              GO TO 11371
            END IF
            vstep = ustep
            IF ((callhowfar)) THEN
              IF ((exact_bca)) THEN
                tvstep = vstep
                IF ((tvstep .NE. tustep)) THEN
                  dosingle = .false.
                END IF
              ELSE
                IF (( vstep .LT. ustep0 )) THEN
                  ekems = eke - 0.5*tustep*vstep/ustep0*dedx
                  p2 = ekems*(ekems+rmt2)
                  beta2 = p2/(p2 + rmsq)
                  chia2 = xccl/(4*blccl*p2)
                  xi = 0.5*xccl/p2/beta2*vstep
                  IF (( spin_effects )) THEN
                    elkems = Log(ekems)
                    Lelkems=eke1(MEDIUM)*elkems+eke0(MEDIUM)
                    IF ((lelec .LT. 0)) THEN
                      etap=etae_ms1(Lelkems,MEDIUM)*elkems+etae_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1ce_ms1(Lelkems,MEDIUM)*elkems+q1ce_ms0(L
     *                elkems,MEDIUM)
                    ELSE
                      etap=etap_ms1(Lelkems,MEDIUM)*elkems+etap_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1cp_ms1(Lelkems,MEDIUM)*elkems+q1cp_ms0(L
     *                elkems,MEDIUM)
                    END IF
                    chia2 = chia2*etap
                    xi = xi*xi_corr
                    ms_corr=blcce1(Lelkems,MEDIUM)*elkems+blcce0(Lelkems
     *              ,MEDIUM)
                    blccl = blccl*ms_corr
                  ELSE
                    xi_corr = 1
                    etap = 1
                  END IF
                  xi = xi*(Log(1+1./chia2)-1/(1+chia2))
                  IF (( xi .LT. 0.1 )) THEN
                    tvstep = vstep*(1 + xi*(0.5 + xi*0.333333))
                  ELSE
                    IF (( xi .LT. 0.999999 )) THEN
                      tvstep = -vstep*Log(1 - xi)/xi
                    ELSE
                      write(i_log,*) ' Stoped in SET-TVSTEP because xi >
     * 1! '
                      write(i_log,*) ' Medium: ',medium
                      write(i_log,*) ' Initial energy: ',eke
                      write(i_log,*) ' Average step energy: ',ekems
                      write(i_log,*) ' tustep: ',tustep
                      write(i_log,*) ' ustep0: ',ustep0
                      write(i_log,*) ' vstep:  ',vstep
                      write(i_log,*) ' ==> xi = ',xi
                      write(i_log,'(/a)') '***************** Error: '
                      write(i_log,*) 'This is a fatal error condition'
                      write(i_log,'(/a)') '***************** Quiting now
     *.'
                      call exit(1)
                    END IF
                  END IF
                ELSE
                  tvstep = tustep
                END IF
              END IF
              tuss = range - range_ep(qel,lelke,medium)/rhof
              IF (( tuss .GE. tvstep )) THEN
                IF (( lelec .LT. 0 )) THEN
                  dedxmid=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
                  aux = ededx1(lelke,medium)/dedxmid
                ELSE
                  dedxmid=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
                  aux = pdedx1(lelke,medium)/dedxmid
                END IF
                de = dedxmid*tvstep*rhof
                fedep = de/eke
                de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.25*
     *          fedep*(2-aux*(4-aux)))))
              ELSE
                lelktmp = lelke
                tuss = (range - tvstep)*rhof
                IF (( tuss .LE. 0 )) THEN
                  de = eke - TE(medium)*0.99
                ELSE
11421             IF(tuss.GE.range_ep(qel,lelktmp,medium))GO TO 11422
                    lelktmp = lelktmp - 1
                  GO TO 11421
11422             CONTINUE
                  elktmp = (lelktmp+1-eke0(medium))/eke1(medium)
                  eketmp = E_array(lelktmp+1,medium)
                  tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof
                  IF (( lelec .LT. 0 )) THEN
                    dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelktmp
     *              ,MEDIUM)
                    aux = ededx1(lelktmp,medium)/dedxmid
                  ELSE
                    dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelktmp
     *              ,MEDIUM)
                    aux = pdedx1(lelktmp,medium)/dedxmid
                  END IF
                  de = dedxmid*tuss*rhof
                  fedep = de/eketmp
                  de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.2
     *            5*fedep*(2-aux*(4-aux)))))
                  de = de + eke - eketmp
                END IF
              END IF
            ELSE
              tvstep = tustep
              IF (( .NOT.callmsdist )) THEN
                tuss = range - range_ep(qel,lelke,medium)/rhof
                IF (( tuss .GE. tvstep )) THEN
                  IF (( lelec .LT. 0 )) THEN
                    dedxmid=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIU
     *              M)
                    aux = ededx1(lelke,medium)/dedxmid
                  ELSE
                    dedxmid=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIU
     *              M)
                    aux = pdedx1(lelke,medium)/dedxmid
                  END IF
                  de = dedxmid*tvstep*rhof
                  fedep = de/eke
                  de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.2
     *            5*fedep*(2-aux*(4-aux)))))
                ELSE
                  lelktmp = lelke
                  tuss = (range - tvstep)*rhof
                  IF (( tuss .LE. 0 )) THEN
                    de = eke - TE(medium)*0.99
                  ELSE
11431               IF(tuss.GE.range_ep(qel,lelktmp,medium))GO TO 11432
                      lelktmp = lelktmp - 1
                    GO TO 11431
11432               CONTINUE
                    elktmp = (lelktmp+1-eke0(medium))/eke1(medium)
                    eketmp = E_array(lelktmp+1,medium)
                    tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof
                    IF (( lelec .LT. 0 )) THEN
                      dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelkt
     *                mp,MEDIUM)
                      aux = ededx1(lelktmp,medium)/dedxmid
                    ELSE
                      dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelkt
     *                mp,MEDIUM)
                      aux = pdedx1(lelktmp,medium)/dedxmid
                    END IF
                    de = dedxmid*tuss*rhof
                    fedep = de/eketmp
                    de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0
     *              .25*fedep*(2-aux*(4-aux)))))
                    de = de + eke - eketmp
                  END IF
                END IF
              END IF
            END IF
            save_de = de
            edep = de
            ekef = eke - de
            eold = eie
            enew = eold - de
            IF (( .NOT.callmsdist )) THEN
              IF (( domultiple )) THEN
                lambda = blccl*tvstep/beta2/etap/(1+chia2)
                xi = xi/xi_corr
                findindex = .true.
                spin_index = .true.
                call mscat(lambda,chia2,xi,elkems,beta2,qel,medium, spin
     *          _effects,findindex,spin_index, costhe,sinthe)
              ELSE
                IF ((dosingle)) THEN
                  ekems = Max(ekef,ecut(irl)-rm)
                  p2 = ekems*(ekems + rmt2)
                  beta2 = p2/(p2 + rmsq)
                  chia2 = xcc(medium)/(4*blcc(medium)*p2)
                  IF (( spin_effects )) THEN
                    elkems = Log(ekems)
                    Lelkems=eke1(MEDIUM)*elkems+eke0(MEDIUM)
                    IF ((lelec .LT. 0)) THEN
                      etap=etae_ms1(Lelkems,MEDIUM)*elkems+etae_ms0(Lelk
     *                ems,MEDIUM)
                    ELSE
                      etap=etap_ms1(Lelkems,MEDIUM)*elkems+etap_ms0(Lelk
     *                ems,MEDIUM)
                    END IF
                    chia2 = chia2*etap
                  END IF
                  call sscat(chia2,elkems,beta2,qel,medium, spin_effects
     *            ,costhe,sinthe)
                ELSE
                  theta = 0
                  sinthe = 0
                  costhe = 1
                END IF
              END IF
            END IF
            e_range = range
            IF (( callmsdist )) THEN
              u_final = uscat
              v_final = vscat
              w_final = wscat
              x_final = xtrans
              y_final = ytrans
              z_final = ztrans
            ELSE
              IF (.NOT.(.false.)) THEN
                x_final = x(np) + u(np)*vstep
                y_final = y(np) + v(np)*vstep
                z_final = z(np) + w(np)*vstep
              END IF
              IF (( domultiple .OR. dosingle )) THEN
                u_tmp = u(np)
                v_tmp = v(np)
                w_tmp = w(np)
                call uphi(2,1)
                u_final = u(np)
                v_final = v(np)
                w_final = w(np)
                u(np) = u_tmp
                v(np) = v_tmp
                w(np) = w_tmp
              ELSE
                u_final = u(np)
                v_final = v(np)
                w_final = w(np)
              END IF
            END IF
            IARG=0
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            x(np) = x_final
            y(np) = y_final
            z(np) = z_final
            u(np) = u_final
            v(np) = v_final
            w(np) = w_final
            dnear(np) = dnear(np) - vstep
            irold = ir(np)
            peie = peie - edep
            eie = peie
            e(np) = peie
            IF (( irnew .EQ. irl .AND. eie .LE. ecut(irl))) THEN
              go to 11350
            END IF
            medold = medium
            IF ((medium .NE. 0)) THEN
              ekeold = eke
              eke = eie - rm
              elke = log(eke)
              Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
            END IF
            IF ((irnew .NE. irold)) THEN
              ir(np) = irnew
              irl = irnew
              medium = med(irl)
            END IF
            IARG=5
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            IF ((eie .LE. ecut(irl))) THEN
              go to 11350
            END IF
            IF ((idisc .LT. 0)) THEN
              go to 11360
            END IF
            IF((medium .NE. medold))GO TO 11371
            demfp = demfp - save_de*sig
            total_de = total_de - save_de
            total_tstep = total_tstep - tvstep*rhof
            IF (( total_tstep .LT. 1e-9 )) THEN
              demfp = 0
            END IF
            IF(((demfp .LT. 1.E-8)))GO TO11382
          GO TO 11381
11382     CONTINUE
          IF ((lelec .LT. 0)) THEN
            sigf=esig1(Lelke,MEDIUM)*elke+esig0(Lelke,MEDIUM)
            dedx0=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
            sigf = sigf/dedx0
          ELSE
            sigf=psig1(Lelke,MEDIUM)*elke+psig0(Lelke,MEDIUM)
            dedx0=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
            sigf = sigf/dedx0
          END IF
          sigratio = sigf/sig0
          IF((rng_seed .GT. 128))call ranmar_get
          rfict = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF(((rfict .LE. sigratio)))GO TO11372
        GO TO 11371
11372   CONTINUE
        IF ((lelec .LT. 0)) THEN
          ebr1=ebr11(Lelke,MEDIUM)*elke+ebr10(Lelke,MEDIUM)
          IF((rng_seed .GT. 128))call ranmar_get
          rnno24 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF ((rnno24 .LE. ebr1)) THEN
            go to 11440
          ELSE
            IF ((e(np) .LE. thmoll(medium) .AND. eii_flag .EQ. 0)) THEN
              IF ((ebr1 .LE. 0)) THEN
                go to 11340
              END IF
              go to 11440
            END IF
            IARG=8
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            call moller
            IARG=9
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            IF((iq(np) .EQ. 0))return
          END IF
          go to 11340
        END IF
        pbr1=pbr11(Lelke,MEDIUM)*elke+pbr10(Lelke,MEDIUM)
        IF((rng_seed .GT. 128))call ranmar_get
        rnno25 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF ((rnno25 .LT. pbr1)) THEN
          go to 11440
        END IF
        pbr2=pbr21(Lelke,MEDIUM)*elke+pbr20(Lelke,MEDIUM)
        IF ((rnno25 .LT. pbr2)) THEN
          IARG=10
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          call bhabha
          IARG=11
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          IF((iq(np) .EQ. 0))return
        ELSE
          IARG=12
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          call annih
          IARG=13
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          GO TO 11342
        END IF
      GO TO 11341
11342 CONTINUE
      return
11440 IARG=6
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      call brems
      IARG=7
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      IF ((iq(np) .EQ. 0)) THEN
        return
      ELSE
        go to 11340
      END IF
11350 IF (( medium .GT. 0 )) THEN
        IF ((eie .GT. ae(medium))) THEN
          idr = 1
          IF ((lelec .LT. 0)) THEN
            edep = e(np) - prm
          ELSE
            EDEP=PEIE-PRM
          END IF
        ELSE
          idr = 2
          edep = e(np) - prm
        END IF
      ELSE
        idr = 1
        edep = e(np) - prm
      END IF
      IARG=idr
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
11450 CONTINUE
      IF ((lelec .GT. 0)) THEN
        IF ((edep .LT. peie)) THEN
          IARG=28
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          call annih_at_rest
          IARG=14
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          return
        END IF
      END IF
      np = np - 1
      ircode = 2
      return
11360 idisc = abs(idisc)
      IF (((lelec .LT. 0) .OR. (idisc .EQ. 99))) THEN
        edep = e(np) - prm
      ELSE
        edep = e(np) + prm
      END IF
      IARG=3
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      IF((idisc .EQ. 99))goto 11450
      np = np - 1
      ircode = 2
      return
      end
      SUBROUTINE HATCH
      implicit none
      character*512 toUpper
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PHOTIN/ EBINDA(6), GE0(6),GE1(6), GMFP0(2000,6),GMFP1(2000,
     *6),GBR10(2000,6),GBR11(2000,6),GBR20(2000,6),GBR21(2000,6), RCO0(6
     *),RCO1(6), RSCT0(100,6),RSCT1(100,6), COHE0(2000,6),COHE1(2000,6),
     *  PHOTONUC0(2000,6),PHOTONUC1(2000,6), DPMFP, MPGEM(1,6), NGR(6)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      real*8 SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERVR/ CEXPTR,GWAIT(150),DUMU,NP_INC(150),MAFORC,IFORCE,NF
     *MIN,NFMAX,NFTIME, ISOURC,IFPB,IQINC,MONOEN,IRODUM,IRNDUM,MEDDUM,ID
     *UM,MEDTMP, PATHL,DELTAP,GWTOLD,EPSLON,ARG
      real*8 CEXPTR,GWAIT,DUMU,PATHL,DELTAP,GWTOLD,EPSLON,ARG
      integer*4 NP_INC,MAFORC,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQIN
     *C, MONOEN,IRODUM,IRNDUM,MEDDUM,IDUM,MEDTMP
      COMMON/USERRR/
     *              CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,
     *                            EKETST,ELKETS,ZL,RL,CDIST,IGEOM,IRANGE
     *,MINZ,MAXZ,MINR,MAXR,IREJCT
      real*8 CRANGE,ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,EKETST,ELKETS
     *,ZL,RL,CDIST
      integer*4 MINZ,MAXZ,MINR,MAXR
      integer*4 IREJCT,IRANGE,IGEOM
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/ET_control/ smaxir( 2001),estepe,ximax,  skindepth_for_bca,
     *transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      COMMON/LBREMZ/CONST,DELC,EBREMZ,DELTAM,XLNZ
      real*4 CONST,DELC,EBREMZ,DELTAM,XLNZ
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20), EPSTTL,NEPST,IEPST
     *,EPSTFLP, NELEPS,ZEPST(20),IAPRFL,IAPRIMP
      integer*4 ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP
      CHARACTER EPSTTL*80
      real*4 EPSTEN,EPSTD,WEPST
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/LSPION/CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      real*4 CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      COMMON/PWLFIN/EPE,ZTHRE(8),ZEPE(8),NIPE,NALE
      real*4 EPE,ZTHRE,ZEPE
      integer*4 NIPE,NALE
      COMMON/RSLTS/NEL,AXE,BXE,AFE(500,8),BFE(500,8)
      real*4 AXE,BXE,AFE,BFE
      integer*4 NEL
      COMMON/SPCOMM/MEDTBL(24,73), NUMSTMED,STDATA(6,73)
      CHARACTER*4 MEDTBL
      integer*4 NUMSTMED
      real*4 STDATA
      COMMON/MIXDAT/NEP,LMED,PZP(50),ZELEMP(50),WAP(50),RHOZP(50), GASPP
     *,EZ,TPZ,IDSTRN(24)
      integer*4 NEP,LMED
      real*4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ
      CHARACTER*4 IDSTRN
      COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183
      real*4 ALRAD,ALRADP,A1440,A183
      COMMON/MIMSD/BMIN
      real*4 BMIN
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6), DE
     *LCMP,ALPHIP(2),BPARP(2),DELPOSP(2)
      real*4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP
      COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100)
      integer*4 NET
      real*4 ITBL,WATBL,RHOTBL
      CHARACTER*4 ASYMT
      COMMON/MEDINP/inpdensity_file(6),inpasym(6,50), inpstrn(24,6),pz4(
     *6,50), rhoz4(6,50),wa4(6,50),inpgasp(6)
      character*256 inpdensity_file
      CHARACTER*4 inpasym,inpstrn
      real*4 pz4,rhoz4,wa4,inpgasp
      real*4 XSIFP,WADUM,PZDUM,RHOZDUM,RLCDUM,ALKE,ALKEI
      integer*4 I01
      EXTERNAL ALKE,ALKEI,EFUNS
      CHARACTER*4 MEDTB1(24,20),MEDTB2(24,20),MEDTB3(24,20),MEDTB4(24,13
     *)
      EQUIVALENCE (MEDTBL(1,1),MEDTB1(1,1))
      EQUIVALENCE (MEDTBL(1,21),MEDTB2(1,1))
      EQUIVALENCE (MEDTBL(1,41),MEDTB3(1,1))
      EQUIVALENCE (MEDTBL(1,61),MEDTB4(1,1))
      real*4 STDAT1(6,20),STDAT2(6,20),STDAT3(6,20),STDAT4(6,13)
      EQUIVALENCE (STDATA(1,1),STDAT1(1,1))
      EQUIVALENCE (STDATA(1,21),STDAT2(1,1))
      EQUIVALENCE (STDATA(1,41),STDAT3(1,1))
      EQUIVALENCE (STDATA(1,61),STDAT4(1,1))
      CHARACTER*4 MBUF(72),MDLABL(8)
      real*8 ACD ,  ADEV ,  ASD ,  COST ,  CTHET ,  DEL ,  DFACT ,  DFAC
     *TI,  DUNITO,  DUNITR,  FNSSS ,  P ,  PZNORM,  RDEV ,  S2C2 ,  S2C2
     *MN,  S2C2MX,  SINT ,  SX ,  SXX ,  SXY ,   SY ,   WID ,  XS ,  XS0
     * ,  XS1 ,  XSI ,  WSS ,  YS ,  ZEROS(3)
      integer*4 I ,  I1ST ,  IB ,  ID ,  IE ,  IL ,  IM ,  IRAYL ,  IRN
     *,  ISTEST,  ISUB ,  ISS ,  IZ ,   IZZ ,  J ,  JR ,  LCTHET,  LMDL
     *,  LMDN ,  LTHETA,  MD ,  MXSINC,  NCMFP ,   NEKE ,   NGE ,   NGRI
     *M ,  NISUB ,  NLEKE ,    NM ,  NRANGE,    NRNA ,  NSEKE ,   NSGE ,
     *   NSINSS,  LOK(6)
      character*256 tmp_string
      integer*4 lnblnk1
      DATA MDLABL/' ','M','E','D','I','U','M','='/,LMDL/8/,LMDN/24/,DUNI
     *TO/1./
      DATA I1ST/1/,NSINSS/37/,MXSINC/1002/,ISTEST/0/,NRNA/1000/
      PIP=3.1415926536
      C=2.997925E+10
      HBAR=1.05450E-27
      ECGS=4.80298E-10
      EMKS=1.60210E-19
      AN=6.02252E+23
      RADDEG=180./PIP
      FSC = ECGS**2/(HBAR*C)
      ERGMEV = (1.E+6)*(EMKS*1.E+7)
      RME = PRM/C**2*ERGMEV
      RMP = PRM
      R0 = (ECGS**2)/(RME*C**2)
      RMPSQ = RMP*RMP
      A22P9 = RADDEG*SQRT(4.*PIP*AN)*ECGS**2/ERGMEV
      A6680 = 4.0*PIP*AN*(HBAR/(RME*C))**2*(0.885**2/(1.167*1.13))
      DATA AFACT/0.0/,SK/0.0/,X0/0.0/,X1/0.0/,CBAR/0.0/,IEV/0.0/
      DATA LMED/24/,NUMSTMED/73/
      DATA EPE/.01/,ZTHRE,ZEPE/16*0.0/,NIPE/20/,NALE/500/
      DATA BMIN/4.5/
      DATA ALRAD/5.31,4.79,4.74,4.71/,ALRADP/6.144,5.621,5.805,5.924/, A
     *1440/1194.0/,A183/184.15/
      DATA MEDTB1/ 'H','2','-','G','A','S',18*' ','H','2','-','L','I','Q
     *','U','I','D',15*' ','H','E','-','G','A','S',18*' ','L','I',22*' '
     *, 'B','E',22*' ','C','-','2','.','2','6','5',' ','G','/','C','M','
     **','*','3',9*' ','C','-','1','.','7','0',' ','G','/','C','M','*','
     **','3',10*' ', 'N','2','-','G','A','S',18*' ','O','2','-','G','A',
     *'S',18*' ','N','E','-','G','A','S',18*' ','N','A',22*' ', 'M','G',
     *22*' ','A','L',22*' ','S','I',22*' ','A','R','-','G','A','S',18*'
     *', 'K',23*' ','C','A',22*' ','T','I',22*' ','V',23*' ','M','N',22*
     *' ' /
      DATA MEDTB2/ 'F','E',22*' ','C','O',22*' ','N','I',22*' ','C','U',
     *22*' ','Z','N',22*' ', 'G','E',22*' ','S','E',22*' ','K','R','-','
     *G','A','S',18*' ','R','B',22*' ', 'M','O',22*' ','A','G',22*' ','C
     *','D',22*' ','I','N',22*' ','S','N',22*' ', 'X','E','-','G','A','S
     *',18*' ','C','S',22*' ','G','D',22*' ','T','A',22*' ', 'W',23*' ',
     *'P','T',22*' ' /
      DATA MEDTB3/ 'A','U',22*' ','H','G',22*' ','P','B',22*' ','R','N',
     *'-','G','A','S',18*' ', 'U',23*' ', 'A','I','R','-','G','A','S',17
     **' ','C','O','2','-','G','A','S',17*' ','P','O','L','Y','E','T','H
     *','Y','L','E','N','E',12*' ', 'P','O','L','Y','P','R','O','P','Y',
     *'L','E','N','E',11*' ','X','Y','L','E','N','E',18*' ','T','O','L',
     *'U','E','N','E',17*' ', 'N','Y','L','O','N',19*' ','V','I','N','Y'
     *,'L','T','O','L','U','E','N','E',12*' ','A','1','5','0','-','P','L
     *','A','S','T','I','C',12*' ', 'S','T','I','L','B','E','N','E',16*'
     * ','P','O','L','Y','S','T','Y','R','E','N','E',13*' ','A','N','T',
     *'H','R','A','C','E','N','E',14*' ', 'L','E','X','A','N',19*' ','L'
     *,'U','C','I','T','E',18*' ','H','2','O',21*' ' /
      DATA MEDTB4/ 'M','Y','L','A','R',19*' ', 'K','A','P','T','O','N',1
     *8*' ','L','I','F',21*' ','P','O','L','Y','V','I','N','Y','L','-','
     *C','L',12*' ', 'P','Y','R','E','X','-','G','L','A','S','S',13*' ',
     *'S','I','O','2',20*' ','C','A','F','2',20*' ', 'P','H','O','T','O'
     *,'E','M','U','L','S','I','O','N',11*' ','A','G','C','L',20*' ','N'
     *,'A','I',21*' ', 'L','I','I',21*' ','A','G','B','R',20*' ','C','S'
     *,'I',21*' ' /
      DATA STDAT1/ 0.03535,6.790,1.864,3.5,19.2,9.584, 0.09179,5.831,0.4
     *76,2.0,21.8,3.263, 0.0114,7.625,2.202,4.0,41.8,11.139, 0.3492,3.23
     *3,0.0966,2.0,40.0,3.122, 0.3518,3.034,-0.0089,2.0,63.7,2.785, 0.58
     *48,2.360,-0.0089,2.0,78.0,2.868, 0.7154,2.191,-0.0089,2.0,78.0,3.1
     *55, 0.2120,3.041,1.738,4.0,82.0,10.540, 0.2666,2.825,1.754,4.0,95.
     *0,10.700, 0.1202,3.357,2.073,4.5,137.0,11.904, 0.2204,3.103,0.4515
     *,2.8,149.0,5.053, 0.1714,3.223,0.2386,2.8,156.0,4.530, 0.3346,2.79
     *5,0.0966,2.5,166.0,4.239, 0.3755,2.720,0.0966,2.5,173.0,4.435, 0.1
     *902,2.982,1.764,4.5,188.0,11.948, 0.3041,2.674,0.2386,3.0,190.0,5.
     *642, 0.2177,2.874,0.1751,3.0,191.0,5.040, 0.1782,2.946,0.0485,3.0,
     *233.0,4.445, 0.1737,2.935,-0.0089,3.0,245.0,4.266, 0.1996,2.812,-0
     *.0089,3.0,272.0,4.270 /
      DATA STDAT2/ 0.2101,2.771,-0.0089,3.0,286.0,4.291, 0.2229,2.713,-0
     *.0089,3.0,297.0,4.260, 0.2504,2.619,-0.0089,3.0,311.0,4.312, 0.255
     *7,2.613,-0.0089,3.0,322.0,4.419, 0.3163,2.468,0.0485,3.0,330.0,4.6
     *91, 0.2809,2.647,0.2386,3.0,350.0,5.141, 0.2979,2.635,0.2386,3.0,3
     *48.0,5.321, 0.1519,3.030,1.716,4.8,352.0,12.512, 0.1450,3.078,0.45
     *15,3.5,363.0,6.478, 0.2228,2.824,0.1751,3.0,424.0,4.879, 0.3091,2.
     *563,-0.0089,3.0,470.0,5.063, 0.1853,2.819,0.0485,3.3,469.0,5.273,
     *0.2004,2.790,0.1751,3.3,487.0,5.517, 0.1898,2.839,0.2386,3.3,488.0
     *,5.534, 0.1329,3.020,1.563,5.0,482.0,12.728, 0.2214,2.784,0.4515,3
     *.5,488.0,6.914, 0.2068,2.686,0.0485,3.5,591.0,5.874, 0.1663,2.805,
     *0.1751,3.5,718.0,5.526, 0.1499,2.870,0.1751,3.5,727.0,5.406, 0.146
     *5,2.903,0.0966,3.5,790.0,5.473 /
      DATA STDAT3/ 0.1533,2.881,0.0966,3.5,790.0,5.575, 0.1824,2.798,0.2
     *386,3.5,800.0,5.961, 0.1861,2.814,0.2386,3.5,823.0,6.202, 0.1130,3
     *.023,1.537,5.3,794.0,13.284, 0.1362,3.034,0.2386,3.5,890.0,5.869,
     *0.2466,2.879,1.742,4.0,85.7,10.595, 0.1999,3.022,1.648,4.0,88.7,10
     *.239, 0.4875,2.544,0.1379,2.0,57.4,3.002, 0.2493,2.975,0.1537,2.3,
     *59.2,3.126, 0.2755,2.911,0.1695,2.3,61.8,3.270, 0.2830,2.890,0.172
     *2,2.3,62.5,3.303, 0.5345,2.439,0.1336,2.0,63.9,3.063, 0.3495,2.749
     *,0.1467,2.2,64.7,3.201, 0.5462,2.435,0.1329,2.0,65.1,3.110, 0.2989
     *,2.851,0.1731,2.3,67.7,3.367, 0.3670,2.724,0.1647,2.2,68.7,3.300,
     *0.5858,2.364,0.1146,2.0,69.5,3.151, 0.3865,2.664,0.1608,2.2,73.1,3
     *.321, 0.3996,2.606,0.1824,2.2,74.0,3.330, 0.2065,3.007,0.2400,2.5,
     *75.0,3.502 /
      DATA STDAT4/ 0.3124,2.782,0.1561,2.3,78.7,3.326, 0.4061,2.614,0.14
     *92,2.2,79.3,3.342, 0.1308,3.476,0.0171,2.5,94.0,3.167, 0.1873,2.96
     *2,0.1558,2.8,108.2,4.053, 0.2988,2.805,0.1479,2.5,134.0,3.971, 0.1
     *440,3.220,0.1385,2.8,139.2,4.003, 0.3750,2.592,0.0676,2.5,166.0,4.
     *065, 0.3416,2.496,0.1009,3.0,331.0,5.332, 0.1243,3.002,-0.0138,3.5
     *,398.4,5.344, 0.1560,2.926,0.1203,3.5,452.0,6.057, 0.1785,2.845,0.
     *0892,3.5,485.1,6.267, 0.1351,2.976,0.0358,3.5,487.2,5.616, 0.1796,
     *2.840,0.0395,3.5,553.1,6.281 /
      DATA NET/100/
      DATA ITBL/19.2,41.8,40.,63.7,76.0,78.0,82.0,95.0,115.,137., 149.,1
     *56.,166.,173.,173.,180.,174.,188.,190.,191.,216.,233.,245., 257.,2
     *72.,286.,297.,311.,322.,330.,334.,350.,347.,348.,357.,352., 363.,3
     *66.,379.,393.,417.,424.,428.,441.,449.,470.,470.,469.,488., 488.,4
     *87.,485.,491.,482.,488.,491.,501.,523.,535.,546.,560.,574., 580.,5
     *91.,614.,628.,650.,658.,674.,684.,694.,705.,718.,727.,736., 746.,7
     *57.,790.,790.,800.,810.,823.,823.,830.,825.,794.,827.,826., 841.,8
     *47.,878.,890.,902.,921.,934.,939.,952.,966.,980.,994./
      DATA WATBL/1.00797,4.0026,6.939,9.0122,10.811,12.01115,14.0067, 15
     *.9994,18.9984,20.183,22.9898,24.312,26.9815,28.088,30.9738, 32.064
     *,35.453,39.948,39.102,40.08,44.956,47.90,50.942,51.998, 54.9380,55
     *.847,58.9332,58.71,63.54,65.37,69.72,72.59,74.9216, 78.96,79.808,8
     *3.80,85.47,87.62,88.905,91.22,92.906,95.94,99.0, 101.07,102.905,10
     *6.4,107.87,112.4,114.82,118.69,121.75,127.60, 126.9044,131.30,132.
     *905,137.34,138.91, 140.12,140.907,144.24,147.,150.35,151.98,157.25
     *,158.924,162.50, 164.930,167.26,168.934,173.04,174.97,178.49,180.9
     *48,183.85, 186.2,190.2,192.2,195.08,196.987,200.59,204.37,207.19,2
     *08.980, 210.,210.,222.,223.,226.,227.,232.036,231.,238.03,237.,242
     *., 243.,247.,247.,248.,254.,253./
      DATA RHOTBL/0.0808,0.19,0.534,1.85,2.5,2.26,1.14,1.568,1.5,1.0, 0.
     *9712,1.74,2.702,2.4,1.82,2.07,2.2,1.65,0.86,1.55,3.02,4.54, 5.87,7
     *.14,7.3,7.86,8.71,8.90,8.9333,7.140,5.91,5.36,5.73,4.80, 4.2,3.4,1
     *.53,2.6,4.47,6.4,8.57,9.01,11.50,12.20,12.50,12.,10.5, 8.65,7.30,7
     *.31,6.684,6.24,4.93,2.7,1.873,3.5,6.15,6.90,6.769, 7.007, 1. ,7.54
     *,5.17,7.87,8.25,8.56,8.80,9.06,9.32,6.96,9.85, 11.40,16.60,19.30,2
     *0.53,22.48,22.42,21.45,19.30,14.19,11.85, 11.34,9.78,9.30, 1. ,4.,
     * 1. ,5., 1. ,11.0,15.37,18.90, 20.5,19.737,11.7,7.,1. , 1. , 1. ,
     *1. /
      DATA ASYMT/'H','HE','LI','BE','B','C','N','O','F','NE', 'NA','MG',
     *'AL','SI','P','S','CL','AR','K','CA','SC','TI', 'V','CR','MN','FE'
     *,'CO','NI','CU','ZN','GA','GE','AS','SE','BR', 'KR','RB','SR','Y',
     *'ZR','NB','MO','TC','RU','RH','PD','AG','CD', 'IN','SN','SB','TE',
     *'I','XE','CS','BA','LA','CE','PR','ND', 'PM','SM','EU','GD','TB','
     *DY','HO','ER','TM','YB','LU','HF','TA', 'W','RE','OS','IR','PT','A
     *U','HG','TL','PB','BI','PO','AT','RN', 'FR','RA','AC','TH','PA','U
     *','NP','PU','AM','CM','BK','CF','ES', 'FM'/
      DATA EPSTFLP/0/,IEPST/1/,IAPRIMP/1/,IAPRFL/0/
11460 FORMAT(1X,14I5)
11470 FORMAT(1X,1PE14.5,4E14.5)
11480 FORMAT(72A1)
      IF ((I1ST.NE.0)) THEN
        I1ST=0
        DO 11491 J=1, 2001
          IF ((SMAXIR(J).LE.0.0)) THEN
            SMAXIR(J)=1E10
          END IF
11491   CONTINUE
11492   CONTINUE
        NISUB=MXSINC-2
        FNSSS=NSINSS
        WID=PI5D2/FLOAT(NISUB)
        WSS=WID/(FNSSS-1.0)
        ZEROS(1)=0.
        ZEROS(2)=PI
        ZEROS(3)=TWOPI
        DO 11501 ISUB=1,MXSINC
          SX=0.
          SY=0.
          SXX=0.
          SXY=0.
          XS0=WID*FLOAT(ISUB-2)
          XS1=XS0+WID
          IZ=0
          DO 11511 IZZ=1,3
            IF (((XS0.LE.ZEROS(IZZ)).AND.(ZEROS(IZZ).LE.XS1))) THEN
              IZ=IZZ
              GO TO11512
            END IF
11511     CONTINUE
11512     CONTINUE
          IF ((IZ.EQ.0)) THEN
            XSI=XS0
          ELSE
            XSI=ZEROS(IZ)
          END IF
          DO 11521 ISS=1,NSINSS
            XS=WID*FLOAT(ISUB-2)+WSS*FLOAT(ISS-1)-XSI
            YS=SIN(XS+XSI)
            SX=SX+XS
            SY=SY+YS
            SXX=SXX+XS*XS
            SXY=SXY+XS*YS
11521     CONTINUE
11522     CONTINUE
          IF ((IZ.NE.0)) THEN
            SIN1(ISUB)=SXY/SXX
            SIN0(ISUB)=-SIN1(ISUB)*XSI
          ELSE
            DEL=FNSSS*SXX-SX*SX
            SIN1(ISUB)=(FNSSS*SXY-SY*SX)/DEL
            SIN0(ISUB)=(SY*SXX-SX*SXY)/DEL - SIN1(ISUB)*XSI
          END IF
11501   CONTINUE
11502   CONTINUE
        SINC0=2.0
        SINC1=1.0/WID
        IF ((ISTEST.NE.0)) THEN
          ADEV=0.
          RDEV=0.
          S2C2MN=10.
          S2C2MX=0.
          DO 11531 ISUB=1,NISUB
            DO 11541 ISS=1,NSINSS
              THETA=WID*FLOAT(ISUB-1)+WSS*FLOAT(ISS-1)
              CTHET=PI5D2-THETA
              SINTHE=sin(THETA)
              COSTHE=sin(CTHET)
              SINT=SIN(THETA)
              COST=COS(THETA)
              ASD=ABS(SINTHE-SINT)
              ACD=ABS(COSTHE-COST)
              ADEV=max(ADEV,ASD,ACD)
              IF((SINT.NE.0.0))RDEV=max(RDEV,ASD/ABS(SINT))
              IF((COST.NE.0.0))RDEV=max(RDEV,ACD/ABS(COST))
              S2C2=SINTHE**2+COSTHE**2
              S2C2MN=min(S2C2MN,S2C2)
              S2C2MX=max(S2C2MX,S2C2)
              IF ((ISUB.LT.11)) THEN
                write(i_log,'(1PE20.7,4E20.7)') THETA,SINTHE,SINT,COSTHE
     *          ,COST
              END IF
11541       CONTINUE
11542       CONTINUE
11531     CONTINUE
11532     CONTINUE
          write(i_log,'(a,2i5)') ' SINE TESTS,MXSINC,NSINSS=',MXSINC,NSI
     *    NSS
          write(i_log,'(a,1PE16.8,3e16.8)') ' ADEV,RDEV,S2C2(MN,MX) =',
     *    ADEV,RDEV,S2C2MN,S2C2MX
          ADEV=0.
          RDEV=0.
          S2C2MN=10.
          S2C2MX=0.
          DO 11551 IRN=1,NRNA
            IF((rng_seed .GT. 128))call ranmar_get
            THETA = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            THETA=THETA*PI5D2
            CTHET=PI5D2-THETA
            SINTHE=sin(THETA)
            COSTHE=sin(CTHET)
            SINT=SIN(THETA)
            COST=COS(THETA)
            ASD=ABS(SINTHE-SINT)
            ACD=ABS(COSTHE-COST)
            ADEV=max(ADEV,ASD,ACD)
            IF((SINT.NE.0.0))RDEV=max(RDEV,ASD/ABS(SINT))
            IF((COST.NE.0.0))RDEV=max(RDEV,ACD/ABS(COST))
            S2C2=SINTHE**2+COSTHE**2
            S2C2MN=min(S2C2MN,S2C2)
            S2C2MX=max(S2C2MX,S2C2)
11551     CONTINUE
11552     CONTINUE
          write(i_log,'(a,i7,a)') ' TEST AT ',NRNA,' RANDOM ANGLES IN (0
     *,5*PI/2)'
          write(i_log,'(1PE16.8,3E16.8)') ' ADEV,RDEV,S2C2(MN,MX) =', AD
     *    EV,RDEV,S2C2MN,S2C2MX
        END IF
        P=1.
        DO 11561 I=1,50
          PWR2I(I)=P
          P=P/2.
11561   CONTINUE
11562   CONTINUE
      END IF
      DO 11571 J=1,NMED
11580   CONTINUE
          DO 11581 I=1, 2001
          IF ((IRAYLR(I).EQ.1.AND.MED(I).EQ.J)) THEN
            IRAYLM(J)=1
            GO TO 11582
          END IF
11581   CONTINUE
11582   CONTINUE
11571 CONTINUE
11572 CONTINUE
      IPHOTONUC=0
      DO 11591 J=1,NMED
11600   CONTINUE
          DO 11601 I=1, 2001
          IF ((IPHOTONUCR(I).EQ.1.AND.MED(I).EQ.J)) THEN
            IPHOTONUCM(J)=1
            IPHOTONUC=1
            GO TO 11602
          END IF
11601   CONTINUE
11602   CONTINUE
11591 CONTINUE
11592 CONTINUE
      write(i_log,'(a,i3)') ' ===> Photonuclear flag: ', iphotonuc
      IF((.NOT.is_pegsless))REWIND KMPI
      NM=0
      DO 11611 IM=1,NMED
        LOK(IM)=0
        IF ((IRAYLM(IM).EQ.1)) THEN
          write(i_log,'(a,i3/)') ' RAYLEIGH OPTION REQUESTED FOR MEDIUM
     *NUMBER',IM
        END IF
11611 CONTINUE
11612 CONTINUE
      DO 11621 IM=1,NMED
        IF ((IPHOTONUCM(IM).EQ.1)) THEN
          write(i_log,'(a,i3/)') ' PHOTONUCLEAR REQUESTED FOR MEDIUM NUM
     *BER',IM
        END IF
11621 CONTINUE
11622 CONTINUE
      IF ((.NOT.is_pegsless)) THEN
11630   CONTINUE
11631     CONTINUE
11640     CONTINUE
11641       CONTINUE
            READ(KMPI,11480,END=11650)MBUF
            DO 11661 IB=1,LMDL
              IF((MBUF(IB).NE.MDLABL(IB)))GO TO 11641
11661       CONTINUE
11662       CONTINUE
11670       CONTINUE
              DO 11671 IM=1,NMED
              DO 11681 IB=1,LMDN
                IL=LMDL+IB
                IF((MBUF(IL).NE.MEDIA(IB,IM)))GO TO 11671
                IF((IB.EQ.LMDN))GO TO 11642
11681         CONTINUE
11682         CONTINUE
11671       CONTINUE
11672       CONTINUE
          GO TO 11641
11642     CONTINUE
          IF((LOK(IM).NE.0))GO TO 11640
          LOK(IM)=1
          NM=NM+1
          read(kmpi,'(a)',err=11690) tmp_string
          goto 11700
11690     write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'Error while reading pegs4 file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
11700     CONTINUE
          read(tmp_string,1,ERR=11710)  (MBUF(I),I=1,5),RHO(IM),NNE(IM),
     *    IUNRST(IM),EPSTFL(IM),IAPRIM(IM)
1         FORMAT(5A1,5X,F11.0,4X,I2,9X,I1,9X,I1,9X,I1)
          GO TO 11720
11710     CONTINUE
          write(i_log,*) 'Found medium with gas pressure'
          read(tmp_string,2) (MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),
     *    EPSTFL(IM), IAPRIM(IM)
2         FORMAT(5A1,5X,F11.0,4X,I2,26X,I1,9X,I1,9X,I1)
11720     CONTINUE
            DO 11721 IE=1,NNE(IM)
            READ(KMPI,11730)(MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2), ZELEM
     *      (IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE)
11730       FORMAT (6A1,2A1,3X,F3.0,3X,F9.0,4X,F12.0,6X,F12.0)
11721     CONTINUE
11722     CONTINUE
          READ(KMPI,11470) RLC(IM),AE(IM),AP(IM),UE(IM),UP(IM)
          TE(IM)=AE(IM)-RM
          THMOLL(IM)=TE(IM)*2. + RM
          READ(KMPI,11460) MSGE(IM),MGE(IM),MSEKE(IM),MEKE(IM),MLEKE(IM)
     *    ,MCMFP(IM),MRANGE(IM),IRAYL
          NSGE=MSGE(IM)
          NGE=MGE(IM)
          NSEKE=MSEKE(IM)
          NEKE=MEKE(IM)
          NLEKE=MLEKE(IM)
          NCMFP=MCMFP(IM)
          NRANGE=MRANGE(IM)
          READ(KMPI,11470)(DL1(I,IM),DL2(I,IM),DL3(I,IM),DL4(I,IM),DL5(I
     *    ,IM),DL6(I,IM),I=1,6)
          READ(KMPI,11470)DELCM(IM),(ALPHI(I,IM),BPAR(I,IM),DELPOS(I,IM)
     *    ,I=1,2)
          READ(KMPI,11470)XR0(IM),TEFF0(IM),BLCC(IM),XCC(IM)
          READ(KMPI,11470)EKE0(IM),EKE1(IM)
          READ(KMPI,11470) (ESIG0(I,IM),ESIG1(I,IM),PSIG0(I,IM),PSIG1(I,
     *    IM),EDEDX0(I,IM),EDEDX1(I,IM),PDEDX0(I,IM),PDEDX1(I,IM),EBR10(
     *    I,IM),EBR11(I,IM),PBR10(I,IM),PBR11(I,IM),PBR20(I,IM),PBR21(I,
     *    IM),TMXS0(I,IM),TMXS1(I,IM),I=1,NEKE)
          READ(KMPI,11470)EBINDA(IM),GE0(IM),GE1(IM)
          READ(KMPI,11470)(GMFP0(I,IM),GMFP1(I,IM),GBR10(I,IM),GBR11(I,I
     *    M),GBR20(I,IM),GBR21(I,IM),I=1,NGE)
          IF ((IRAYL.EQ.1)) THEN
            READ(KMPI,11460) NGR(IM)
            NGRIM=NGR(IM)
            READ(KMPI,11470)RCO0(IM),RCO1(IM)
            READ(KMPI,11470)(RSCT0(I,IM),RSCT1(I,IM),I=1,NGRIM)
            READ(KMPI,11470)(COHE0(I,IM),COHE1(I,IM),I=1,NGE)
            write(i_log,'(a,i3,a)') ' Rayleigh data available for medium
     *', IM, ' in PEGS4 data set.'
          END IF
          IF ((IRAYLM(IM).EQ.1)) THEN
            IF ((IRAYL.NE.1)) THEN
              IF ((toUpper(photon_xsections(:lnblnk1(photon_xsections)))
     *        .EQ.'PEGS4')) THEN
                write(i_log,'(/a)') '***************** Error: '
                write(i_log,'(a,i3 /,a /,a)') ' IN HATCH: REQUESTED RAYL
     *EIGH OPTION FOR MEDIUM', IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PE
     *GS4 FILE.', ' YOU WILL NOT BE ABLE TO USE THE PEGS4 DATA WITH RAYL
     *EIGH ON!'
                write(i_log,'(/a)') '***************** Quiting now.'
                call exit(1)
              ELSE
                write(i_log,'(/a)') '***************** Warning: '
                write(i_log,'(a,i3 /,a)') ' IN HATCH: REQUESTED RAYLEIGH
     * OPTION FOR MEDIUM', IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4
     *FILE.'
              END IF
            ELSE
              IF ((toUpper(photon_xsections(:lnblnk1(photon_xsections)))
     *        .EQ.'PEGS4')) THEN
                call egs_init_rayleigh_sampling(IM)
              END IF
            END IF
          END IF
          IF((NM.GE.NMED))GO TO11632
        GO TO 11631
11632   CONTINUE
        CLOSE (UNIT=KMPI)
        DUNITR=DUNIT
        IF ((DUNIT.LT.0.0)) THEN
          ID=MAX0(1,MIN0(6,int(-DUNIT)))
          DUNIT=RLC(ID)
        END IF
        IF ((DUNIT.NE.1.0)) THEN
          write(i_log,'(a,1PE14.5,E14.5,a)') ' DUNIT REQUESTED&USED ARE:
     * ', DUNITR,DUNIT,'(CM.)'
        END IF
        DO 11741 IM=1,NMED
          DFACT=RLC(IM)/DUNIT
          DFACTI=1.0/DFACT
          I=1
            GO TO 11753
11751       I=I+1
11753       IF(I-(MEKE(IM)).GT.0)GO TO 11752
            ESIG0(I,IM)=ESIG0(I,IM)*DFACTI
            ESIG1(I,IM)=ESIG1(I,IM)*DFACTI
            PSIG0(I,IM)=PSIG0(I,IM)*DFACTI
            PSIG1(I,IM)=PSIG1(I,IM)*DFACTI
            EDEDX0(I,IM)=EDEDX0(I,IM)*DFACTI
            EDEDX1(I,IM)=EDEDX1(I,IM)*DFACTI
            PDEDX0(I,IM)=PDEDX0(I,IM)*DFACTI
            PDEDX1(I,IM)=PDEDX1(I,IM)*DFACTI
            TMXS0(I,IM)=TMXS0(I,IM)*DFACT
            TMXS1(I,IM)=TMXS1(I,IM)*DFACT
          GO TO 11751
11752     CONTINUE
          TEFF0(IM)=TEFF0(IM)*DFACT
          BLCC(IM)=BLCC(IM)*DFACTI
          XCC(IM)=XCC(IM)*SQRT(DFACTI)
          RLDU(IM)=RLC(IM)/DUNIT
          I=1
            GO TO 11763
11761       I=I+1
11763       IF(I-(MGE(IM)).GT.0)GO TO 11762
            GMFP0(I,IM)=GMFP0(I,IM)*DFACT
            GMFP1(I,IM)=GMFP1(I,IM)*DFACT
          GO TO 11761
11762     CONTINUE
11741   CONTINUE
11742   CONTINUE
        VACDST=VACDST*DUNITO/DUNIT
        DUNITO=DUNIT
      ELSE
        write(i_log,*) ' PEGSLESS INPUT.  CALCULATING ELECTRON CROSS-SEC
     *TIONS.'
        call get_media_inputs(-1)
        DO 11771 IM=1,NMED
          AEP=AE(IM)
          UEP=UE(IM)
          APP=AP(IM)
          UPP=UP(IM)
          NEP=NNE(IM)
          IUNRSTP=IUNRST(IM)
          IAPRIMP=IAPRIM(IM)
          EPSTFLP=EPSTFL(IM)
          GASPP=INPGASP(IM)
          RHOP=RHO(IM)
          DO 11781 J=1,NEP
            ZELEMP(J)=ZELEM(IM,J)
            PZP(J)=PZ4(IM,J)
            RHOZP(J)=RHOZ4(IM,J)
            WAP(J)=WA4(IM,J)
11781     CONTINUE
11782     CONTINUE
          DO 11791 IB=1,LMDN
            IDSTRN(IB)=INPSTRN(IB,IM)
11791     CONTINUE
11792     CONTINUE
          TEP=AEP-RMP
          THMOLLP=AEP+TEP
          IF ((UEP.LE.AEP)) THEN
            write(i_log,'(a,24a1)')'  Error: Material not defined: ', (m
     *      edia(j,IM),j=1,24)
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'Material used in the geometry was not define
     *d in the' ,' material data.'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          CALL MIX
          CALL SPINIT(inpdensity_file(IM))
          CALL DIFFER
          CALL PWLF1(NEL,NALE,AEP,UEP,THMOLLP,EPE,ZTHRE,ZEPE,NIPE,ALKE,
     *    ALKEI,AXE,BXE,500,8,AFE,BFE,EFUNS)
          TE(IM)=AE(IM)-RM
          THMOLL(IM)=TE(IM)*2. + RM
          RLC(IM)=RLCP
          XCC(IM)=XCCP
          BLCC(IM)=BLCCP
          XR0(IM)=XR0P
          TEFF0(IM)=TEFF0P
          DELCM(IM)=DELCMP
          DO 11801 I=1,2
            ALPHI(I,IM)=ALPHIP(I)
            BPAR(I,IM)=BPARP(I)
            DELPOS(I,IM)=DELPOSP(I)
11801     CONTINUE
11802     CONTINUE
          DO 11811 I=1,6
            DL1(I,IM)=DLP1(I)
            DL2(I,IM)=DLP2(I)
            DL3(I,IM)=DLP3(I)
            DL4(I,IM)=DLP4(I)
            DL5(I,IM)=DLP5(I)
            DL6(I,IM)=DLP6(I)
11811     CONTINUE
11812     CONTINUE
          MSGE(IM)=0
          MSEKE(IM)=0
          MLEKE(IM)=0
          MCMFP(IM)=0
          MRANGE(IM)=0
          MGE(IM)=2000
          MEKE(IM)=NEL
          NSGE=MSGE(IM)
          NGE=MGE(IM)
          NSEKE=MSEKE(IM)
          NEKE=MEKE(IM)
          NLEKE=MLEKE(IM)
          NCMFP=MCMFP(IM)
          NRANGE=MRANGE(IM)
          EKE0(IM)=BXE
          EKE1(IM)=AXE
          DO 11821 I=1,NEKE
            ESIG0(I,IM)=BFE(I,1)
            ESIG1(I,IM)=AFE(I,1)
            PSIG0(I,IM)=BFE(I,2)
            PSIG1(I,IM)=AFE(I,2)
            EDEDX0(I,IM)=BFE(I,3)
            EDEDX1(I,IM)=AFE(I,3)
            PDEDX0(I,IM)=BFE(I,4)
            PDEDX1(I,IM)=AFE(I,4)
            EBR10(I,IM)=BFE(I,5)
            EBR11(I,IM)=AFE(I,5)
            PBR10(I,IM)=BFE(I,6)
            PBR11(I,IM)=AFE(I,6)
            PBR20(I,IM)=BFE(I,7)
            PBR21(I,IM)=AFE(I,7)
            TMXS0(I,IM)=BFE(I,8)
            TMXS1(I,IM)=AFE(I,8)
11821     CONTINUE
11822     CONTINUE
11771   CONTINUE
11772   CONTINUE
        DUNITR=DUNIT
        IF ((DUNIT.LT.0.0)) THEN
          ID=MAX0(1,MIN0(6,int(-DUNIT)))
          DUNIT=RLC(ID)
        END IF
        IF ((DUNIT.NE.1.0)) THEN
          write(i_log,'(a,1PE14.5,E14.5,a)') ' DUNIT REQUESTED&USED ARE:
     * ', DUNITR,DUNIT,'(CM.)'
        END IF
        DO 11831 IM=1,NMED
          DFACT=RLC(IM)/DUNIT
          DFACTI=1.0/DFACT
          I=1
            GO TO 11843
11841       I=I+1
11843       IF(I-(MEKE(IM)).GT.0)GO TO 11842
            ESIG0(I,IM)=ESIG0(I,IM)*DFACTI
            ESIG1(I,IM)=ESIG1(I,IM)*DFACTI
            PSIG0(I,IM)=PSIG0(I,IM)*DFACTI
            PSIG1(I,IM)=PSIG1(I,IM)*DFACTI
            EDEDX0(I,IM)=EDEDX0(I,IM)*DFACTI
            EDEDX1(I,IM)=EDEDX1(I,IM)*DFACTI
            PDEDX0(I,IM)=PDEDX0(I,IM)*DFACTI
            PDEDX1(I,IM)=PDEDX1(I,IM)*DFACTI
            TMXS0(I,IM)=TMXS0(I,IM)*DFACT
            TMXS1(I,IM)=TMXS1(I,IM)*DFACT
          GO TO 11841
11842     CONTINUE
          TEFF0(IM)=TEFF0(IM)*DFACT
          BLCC(IM)=BLCC(IM)*DFACTI
          XCC(IM)=XCC(IM)*SQRT(DFACTI)
          RLDU(IM)=RLC(IM)/DUNIT
          I=1
            GO TO 11853
11851       I=I+1
11853       IF(I-(MGE(IM)).GT.0)GO TO 11852
            GMFP0(I,IM)=GMFP0(I,IM)*DFACT
            GMFP1(I,IM)=GMFP1(I,IM)*DFACT
          GO TO 11851
11852     CONTINUE
11831   CONTINUE
11832   CONTINUE
        VACDST=VACDST*DUNITO/DUNIT
        DUNITO=DUNIT
        call show_media_parameters(i_log)
      END IF
      DO 11861 JR=1, 2001
        MD=MED(JR)
        IF (((MD.GE.1).AND.(MD.LE.NMED))) THEN
          ECUT(JR)=max(ECUT(JR),AE(MD))
          PCUT(JR)=max(PCUT(JR),AP(MD))
          IF ((RHOR(JR).EQ.0.0)) THEN
            RHOR(JR)=RHO(MD)
          END IF
        END IF
11861 CONTINUE
11862 CONTINUE
      IF ((IBRDST.EQ.1)) THEN
        DO 11871 IM=1,NMED
          ZBRANG(IM)=0.0
          PZNORM=0.0
          DO 11881 IE=1,NNE(IM)
            ZBRANG(IM)= ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+
     *      1.0)
            PZNORM=PZNORM+PZ(IM,IE)
11881     CONTINUE
11882     CONTINUE
          ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.)
          LZBRANG(IM)=-log(ZBRANG(IM))
11871   CONTINUE
11872   CONTINUE
      END IF
      IF ((IPRDST.GT.0)) THEN
        DO 11891 IM=1,NMED
          ZBRANG(IM)=0.0
          PZNORM=0.0
          DO 11901 IE=1,NNE(IM)
            ZBRANG(IM)= ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+
     *      1.0)
            PZNORM=PZNORM+PZ(IM,IE)
11901     CONTINUE
11902     CONTINUE
          ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.)
11891   CONTINUE
11892   CONTINUE
      END IF
      IF ((toUpper(photon_xsections(:lnblnk1(photon_xsections))) .EQ. 'P
     *EGS4')) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,'(6(a/))') 'Using photon data from PEGS4 file!!!', '
     *However, the new Rayleigh angular sampling will be used.', 'The or
     *iginal EGS4 angular sampling undersamples large scattering ', 'ang
     *les. This may have little impact as Rayleigh scattering ', 'is for
     *ward peaked.', '**************************************************
     ********'
      ELSE
        call egs_init_user_photon(photon_xsections,comp_xsections, photo
     *  nuc_xsections,xsec_out)
      END IF
      call mscati
      IF (( eadl_relax .AND. photon_xsections .EQ. 'xcom' )) THEN
        call init_compton
        call EDGSET(1,1)
      ELSE
        call EDGSET(1,1)
        call init_compton
      END IF
      IF (( xsec_out .EQ. 1 .AND. eadl_relax)) THEN
        call egs_print_binding_energies
      END IF
      call fix_brems
      IF (( ibr_nist .GE. 1 )) THEN
        call init_nist_brems
      END IF
      IF (( pair_nrc .EQ. 1 )) THEN
        call init_nrc_pair
      END IF
      call eii_init
      call init_triplet
      IF ((NMED.EQ.1)) THEN
        write(i_log,*) 'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ONE MEDIUM.'
      ELSE
        write(i_log,'(a,i5,a)') 'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ',N
     *  MED,' MEDIA.'
      END IF
      RETURN
11650 write(i_log,'(a,i2//,a/,a/)') ' END OF FILE ON UNIT ',KMPI, ' PROG
     *RAM STOPPED IN HATCH BECAUSE THE', ' FOLLOWING NAMES WERE NOT RECO
     *GNIZED:'
      DO 11911 IM=1,NMED
        IF ((LOK(IM).NE.1)) THEN
          write(i_log,'(40x,a,24a1,a)') '''',(MEDIA(I,IM),I=1,LMDN),''''
        END IF
11911 CONTINUE
11912 CONTINUE
      STOP
      END
      subroutine fix_brems
      implicit none
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/nist_brems/ nb_fdata(0:50,100,6), nb_xdata(0:50,100,6), nb_
     *wdata(50,100,6), nb_idata(50,100,6), nb_emin(6),nb_emax(6), nb_lem
     *in(6),nb_lemax(6), nb_dle(6),nb_dlei(6), log_ap(6)
      real*8 nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lema
     *x, nb_dle,nb_dlei,log_ap
      integer*4 nb_idata
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      integer*4 medium,i
      real*8 Zt,Zb,Zf,Zg,Zv,fmax1,fmax2,Zi,pi,fc,xi,aux, XSIF,FCOULC
      DO 11921 medium=1,nmed
        log_ap(medium) = log(ap(medium))
        Zt = 0
        Zb = 0
        Zf = 0
        DO 11931 i=1,NNE(medium)
          Zi = ZELEM(medium,i)
          pi = PZ(medium,i)
          fc = FCOULC(Zi)
          xi = XSIF(Zi)
          aux = pi*Zi*(Zi + xi)
          Zt = Zt + aux
          Zb = Zb - aux*Log(Zi)/3
          Zf = Zf + aux*fc
11931   CONTINUE
11932   CONTINUE
        Zv = (Zb - Zf)/Zt
        Zg = Zb/Zt
        fmax1 = 2*(20.863 + 4*Zg) - 2*(20.029 + 4*Zg)/3
        fmax2 = 2*(20.863 + 4*Zv) - 2*(20.029 + 4*Zv)/3
        dl1(1,medium) = (20.863 + 4*Zg)/fmax1
        dl2(1,medium) = -3.242/fmax1
        dl3(1,medium) = 0.625/fmax1
        dl4(1,medium) = (21.12+4*Zg)/fmax1
        dl5(1,medium) = -4.184/fmax1
        dl6(1,medium) = 0.952
        dl1(2,medium) = (20.029+4*Zg)/fmax1
        dl2(2,medium) = -1.93/fmax1
        dl3(2,medium) = -0.086/fmax1
        dl4(2,medium) = (21.12+4*Zg)/fmax1
        dl5(2,medium) = -4.184/fmax1
        dl6(2,medium) = 0.952
        dl1(3,medium) = (20.863 + 4*Zv)/fmax2
        dl2(3,medium) = -3.242/fmax2
        dl3(3,medium) = 0.625/fmax2
        dl4(3,medium) = (21.12+4*Zv)/fmax2
        dl5(3,medium) = -4.184/fmax2
        dl6(3,medium) = 0.952
        dl1(4,medium) = (20.029+4*Zv)/fmax2
        dl2(4,medium) = -1.93/fmax2
        dl3(4,medium) = -0.086/fmax2
        dl4(4,medium) = (21.12+4*Zv)/fmax2
        dl5(4,medium) = -4.184/fmax2
        dl6(4,medium) = 0.952
        dl1(5,medium) = (3*(20.863 + 4*Zg) - (20.029 + 4*Zg))
        dl2(5,medium) = (3*(-3.242) - (-1.930))
        dl3(5,medium) = (3*(0.625)-(-0.086))
        dl4(5,medium) = (2*21.12+8*Zg)
        dl5(5,medium) = (2*(-4.184))
        dl6(5,medium) = 0.952
        dl1(6,medium) = (3*(20.863 + 4*Zg) + (20.029 + 4*Zg))
        dl2(6,medium) = (3*(-3.242) + (-1.930))
        dl3(6,medium) = (3*0.625+(-0.086))
        dl4(6,medium) = (4*21.12+16*Zg)
        dl5(6,medium) = (4*(-4.184))
        dl6(6,medium) = 0.952
        dl1(7,medium) = (3*(20.863 + 4*Zv) - (20.029 + 4*Zv))
        dl2(7,medium) = (3*(-3.242) - (-1.930))
        dl3(7,medium) = (3*(0.625)-(-0.086))
        dl4(7,medium) = (2*21.12+8*Zv)
        dl5(7,medium) = (2*(-4.184))
        dl6(7,medium) = 0.952
        dl1(8,medium) = (3*(20.863 + 4*Zv) + (20.029 + 4*Zv))
        dl2(8,medium) = (3*(-3.242) + (-1.930))
        dl3(8,medium) = (3*0.625+(-0.086))
        dl4(8,medium) = (4*21.12+16*Zv)
        dl5(8,medium) = (4*(-4.184))
        dl6(8,medium) = 0.952
        bpar(2,medium) = dl1(7,medium)/(3*dl1(8,medium) + dl1(7,medium))
        bpar(1,medium) = 12*dl1(8,medium)/(3*dl1(8,medium) + dl1(7,mediu
     *  m))
11921 CONTINUE
11922 CONTINUE
      return
      end
      real*8 function FCOULC(Z)
      implicit none
      real*8 Z
      real*8 fine,asq
      data fine/137.03604/
      asq = Z/fine
      asq = asq*asq
      FCOULC = asq*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+ASQ*(0.0083+ASQ*(
     *-0.002))))
      return
      end
      real*8 function XSIF(Z)
      implicit none
      real*8 Z
      integer*4 iZ
      real*8 alrad(4),alradp(4),a1440,a183,FCOULC
      data alrad/5.31,4.79,4.74,4.71/
      data alradp/6.144,5.621,5.805,5.924/
      data a1440/1194.0/,A183/184.15/
      IF (( Z .LE. 4 )) THEN
        iZ = Z
        xsif = alradp(iZ)/(alrad(iZ) - FCOULC(Z))
      ELSE
        xsif = Log(A1440*Z**(-0.666667))/(Log(A183*Z**(-0.33333))-FCOULC
     *  (Z))
      END IF
      return
      end
      subroutine init_compton
      implicit none
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,6), eno_array(200,6), eno_atbin_array(200,6), n_sh
     *ell(6), radc_flag,  ibcmp( 2001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      integer*4 i,j,iz,nsh,j_l,j_h
      real*8 aux,pztot,atav
      real*8 aux_erf,erf1
      logical getd
      IF (( radc_flag .EQ. 1 )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) 'You are trying to use radiative Compton correcti
     *ons'
        write(i_log,*) 'without having included rad_compton1.mortran'
        write(i_log,'(a//)') 'Turning radiative Compton corrections OFF
     *...'
        radc_flag = 0
      END IF
      getd = .false.
      DO 11941 j=1, 2001
        medium = med(j)
        IF (( medium .GT. 0 .AND. medium .LE. nmed)) THEN
          IF (( ibcmp(j) .GT. 0 )) THEN
            getd = .true.
            GO TO11942
          END IF
        END IF
11941 CONTINUE
11942 CONTINUE
      IF (( .NOT.getd )) THEN
        IF (( eadl_relax .AND. photon_xsections .EQ. 'xcom' )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,/a,/a)') 'You must turn ON Compton binding cor
     *rections when using', 'a detailed atomic relaxation (eadl_relax=tr
     *ue) since ', 'binding energies taken from incoh.data below 1 keV!'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        write(i_log,'(a/)') ' Bound Compton scattering not requested! '
        return
      END IF
      write(i_log,'(/a$)') 'Bound Compton scattering requested, reading
     *data ......'
      rewind(i_incoh)
      DO 11951 j=1,18
        read(i_incoh,*)
11951 CONTINUE
11952 CONTINUE
      iz = 0
      DO 11961 j=1,1538
        read(i_incoh,*) iz_array(j),shn_array(j),ne_array(j), Jo_array(j
     *  ),be_array(j)
        Jo_array(j) = Jo_array(j)*137.
        be_array(j) = be_array(j)*1e-6/PRM
        aux_erf = 0.70710678119*(1+0.3*Jo_array(j))
        erfJo_array(j) = 0.82436063535*(erf1(aux_erf)-1)
        IF ((eadl_relax)) THEN
          IF ((iz_array(j) .NE. iz)) THEN
            shn_array(j) = 1
            iz = iz_array(j)
          ELSE
            shn_array(j) = shn_array(j-1)+1
          END IF
          IF ((binding_energies(shn_array(j),iz_array(j)) .GT. 0)) THEN
            be_array(j) = binding_energies(shn_array(j),iz_array(j))/PRM
          ELSE IF((photon_xsections .EQ. 'xcom')) THEN
            binding_energies(shn_array(j),iz_array(j)) = be_array(j)*PRM
          END IF
        END IF
11961 CONTINUE
11962 CONTINUE
      write(i_log,*) ' Done'
      write(i_log,'(/a)') ' Initializing Bound Compton scattering ......
     *'
      DO 11971 medium=1,nmed
        pztot = 0
        nsh = 0
        DO 11981 i=1,nne(medium)
          iz = int(zelem(medium,i))
          DO 11991 j=1,1538
            IF (( iz .EQ. iz_array(j) )) THEN
              nsh = nsh + 1
              IF (( nsh .GT. 200 )) THEN
                write(i_log,'(/a)') '***************** Error: '
                write(i_log,'(/a,i3,a,i4,a/,a)') ' For medium ',medium,
     *          ' the number of shells is > ',200,'!', ' Increase the pa
     *rameter $MXMDSH! '
                write(i_log,'(/a)') '***************** Quiting now.'
                call exit(1)
              END IF
              shell_array(nsh,medium) = j
              aux = pz(medium,i)*ne_array(j)
              eno_array(nsh,medium) = aux
              pztot = pztot + aux
            END IF
11991     CONTINUE
11992     CONTINUE
11981   CONTINUE
11982   CONTINUE
        IF (( nsh .EQ. 0 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,i3,a)') ' Medium ',medium,' has zero shells! '
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        n_shell(medium) = nsh
        write(i_log,'(a,i3,a,i3,a)') ' Medium ',medium,' has ',nsh,' she
     *lls: '
        DO 12001 i=1,nsh
          j = shell_array(i,medium)
          eno_array(i,medium) = eno_array(i,medium)/pztot
          write(i_log,'(i4,i5,i4,f9.5,e10.3,f10.3)') i,j,shn_array(j),en
     *    o_array(i,medium), Jo_array(j),be_array(j)*PRM*1000.
          eno_array(i,medium) = -eno_array(i,medium)
          eno_atbin_array(i,medium) = i
12001   CONTINUE
12002   CONTINUE
        atav = 1./nsh
        DO 12011 i=1,nsh-1
          DO 12021 j_h=1,nsh-1
            IF (( eno_array(j_h,medium) .LT. 0 )) THEN
              IF((abs(eno_array(j_h,medium)) .GT. atav))GO TO12022
            END IF
12021     CONTINUE
12022     CONTINUE
          DO 12031 j_l=1,nsh-1
            IF (( eno_array(j_l,medium) .LT. 0 )) THEN
              IF((abs(eno_array(j_l,medium)) .LT. atav))GO TO12032
            END IF
12031     CONTINUE
12032     CONTINUE
          aux = atav - abs(eno_array(j_l,medium))
          eno_array(j_h,medium) = eno_array(j_h,medium) + aux
          eno_array(j_l,medium) = -eno_array(j_l,medium)/atav + j_l
          eno_atbin_array(j_l,medium) = j_h
          IF((i .EQ. nsh-1))eno_array(j_h,medium) = 1 + j_h
12011   CONTINUE
12012   CONTINUE
        DO 12041 i=1,nsh
          IF (( eno_array(i,medium) .LT. 0 )) THEN
            eno_array(i,medium) = 1 + i
          END IF
12041   CONTINUE
12042   CONTINUE
11971 CONTINUE
11972 CONTINUE
      write(i_log,'(a/)') ' ...... Done.'
      getd = .false.
      DO 12051 j=1, 2001
        IF (( iedgfl(j) .GT. 0 .AND. iedgfl(j) .LE. 100 )) THEN
          getd = .true.
          GO TO12052
        END IF
12051 CONTINUE
12052 CONTINUE
      IF((getd))return
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(/a,/a,/a,/a)') ' In subroutine init_compton: ', '
     *Scattering off bound electrons creates atomic vacancies,', '   pot
     *entially starting an atomic relaxation cascade. ', '   Please turn
     * ON atomic relaxations.'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      SUBROUTINE MOLLER
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(6), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),  e
     *ii_sh(40),  eii_nshells(100),  eii_nsh(6),  eii_first(6,50),  eii_
     *no(6,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      DOUBLE PRECISION PEIE,  PEKSE2,  PESE1,  PESE2,  PEKIN,  H1,  DCOS
     *TH
      real*8 EIE,  EKIN,  T0,  E0,  EXTRAE,  E02,  EP0,  G2,G3,  GMAX,
     *BR,  R,  REJF4,  RNNO27,  RNNO28,  ESE1,  ESE2
      real*8 sigm,pbrem,rsh,Uj,sig_j
      integer*4 lelke,iele,ish,nsh,ifirst,i,jj,iZ,iarg
      NPold = NP
      PEIE=E(NP)
      EIE=PEIE
      PEKIN=PEIE-PRM
      EKIN=PEKIN
      IF (( eii_flag .GT. 0 .AND. eii_nsh(medium) .GT. 0 )) THEN
        Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
        sigm=esig1(Lelke,MEDIUM)*elke+esig0(Lelke,MEDIUM)
        pbrem=ebr11(Lelke,MEDIUM)*elke+ebr10(Lelke,MEDIUM)
        sigm = sigm*(1 - pbrem)
        IF((rng_seed .GT. 128))call ranmar_get
        rsh = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        rsh = sigm*rsh
        DO 12061 iele=1,nne(medium)
          iZ = int(zelem(medium,iele)+0.5)
          nsh = eii_no(medium,iele)
          IF (( nsh .GT. 0 )) THEN
            ifirst = eii_first(medium,iele)
            DO 12071 ish=1,nsh
              Uj = binding_energies(ish,iZ)
              IF (( ekin .GT. Uj .AND. (Uj .GT. te(medium) .OR. Uj .GT.
     *        ap(medium)) )) THEN
                jj = ifirst + ish - 1
                i = eii_a(jj)*elke + eii_b(jj) + (jj-1)*250
                sig_j = eii_xsection_a(i)*elke + eii_xsection_b(i)
                sig_j = sig_j*pz(medium,iele)*eii_cons(medium)
                rsh = rsh - sig_j
                IF (( rsh .LT. 0 )) THEN
                  IARG=31
                  IF ((IAUSFL(IARG+1).NE.0)) THEN
                    CALL AUSGAB(IARG)
                  END IF
                  call eii_sample(ish,iZ,Uj)
                  IARG=32
                  IF ((IAUSFL(IARG+1).NE.0)) THEN
                    CALL AUSGAB(IARG)
                  END IF
                  return
                END IF
              END IF
12071       CONTINUE
12072       CONTINUE
          END IF
12061   CONTINUE
12062   CONTINUE
      END IF
      IF((ekin .LE. 2*te(medium)))return
      T0=EKIN/RM
      E0=T0+1.0
      EXTRAE = EIE - THMOLL(MEDIUM)
      E02=E0*E0
      EP0=TE(MEDIUM)/EKIN
      G2=T0*T0/E02
      G3=(2.*T0+1.)/E02
      GMAX=(1.+1.25*G2)
12081 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO27 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        BR = TE(MEDIUM)/(EKIN-EXTRAE*RNNO27)
        R=BR/(1.-BR)
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO28 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        REJF4=(1.+G2*BR*BR+R*(R-G3))
        RNNO28=GMAX*RNNO28
        IF((RNNO28.LE.REJF4))GO TO12082
      GO TO 12081
12082 CONTINUE
      PEKSE2=BR*EKIN
      PESE1=PEIE-PEKSE2
      PESE2=PEKSE2+PRM
      ESE1=PESE1
      ESE2=PESE2
      E(NP)=PESE1
      IF (( np+1 .GT. 150 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','MOLLER', ' s
     *tack size exceeded! ',' $MAXSTACK = ',150,' np = ',np+1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      E(NP+1)=PESE2
      H1=(PEIE+PRM)/PEKIN
      DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM)
      SINTHE=DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(2,1)
      NP=NP+1
      IQ(NP)=-1
      DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM)
      SINTHE=-DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(3,2)
      RETURN
      END
      subroutine mscati
      implicit none
      real*8 ededx,ei,eil,eip1,eip1l,si,sip1,eke,elke,aux,ecutmn,tstbm,t
     *stbmn
      real*8 p2,beta2,dedx0,ekef,elkef,estepx,ektmp,elktmp,chi_a2
      integer*4 i,leil,leip1l,neke,lelke,lelkef,lelktmp
      logical ise_monoton, isp_monoton
      real*8 sigee,sigep,sig,sige_old,sigp_old
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/ET_control/ smaxir( 2001),estepe,ximax,  skindepth_for_bca,
     *transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      IF (( bca_algorithm .EQ. 0 )) THEN
        exact_bca = .true.
      ELSE
        exact_bca = .false.
      END IF
      IF (( estepe .LE. 0 .OR. estepe .GE. 1)) THEN
        estepe = 0.25
      END IF
      IF (( ximax .LE. 0 .OR. ximax .GE. 1 )) THEN
        IF (( exact_bca )) THEN
          ximax = 0.5
        ELSE
          ximax = 0.5
        END IF
      END IF
      IF ((transport_algorithm .NE. 0 .AND. transport_algorithm .NE. 1 .
     *AND. transport_algorithm .NE. 2 )) THEN
        transport_algorithm = 0
      END IF
      IF (( skindepth_for_bca .LE. 1e-4 )) THEN
        IF (( .NOT.exact_bca )) THEN
          write(i_log,*) ' old PRESTA calculates default min. step-size
     *for BCA: '
          ecutmn = 1e30
          DO 12091 i=1, 2001
            IF (( med(i) .GT. 0 .AND. med(i) .LE. nmed )) THEN
              ecutmn = Min(ecutmn,ecut(i))
            END IF
12091     CONTINUE
12092     CONTINUE
          write(i_log,*) '     minimum ECUT found: ',ecutmn
          tstbmn = 1e30
          DO 12101 medium=1,nmed
            tstbm = (ecutmn-prm)*(ecutmn+prm)/ecutmn**2
            tstbm = blcc(medium)*tstbm*(ecutmn/xcc(medium))**2
            aux = Log(tstbm)
            IF((aux .GT. 300))write(i_log,*) 'aux > 300 ? ',aux
            tstbm = Log(tstbm/aux)
            tstbmn = Min(tstbmn,tstbm)
12101     CONTINUE
12102     CONTINUE
          write(i_log,*) '     default BLCMIN is: ',tstbmn
          skindepth_for_bca = Exp(tstbmn)
          write(i_log,*) '     this corresponds to ',skindepth_for_bca,
     *    ' elastic MFPs '
        ELSE
          skindepth_for_bca = 3
        END IF
      END IF
      call init_ms_SR
      DO 12111 medium=1,nmed
        blcc(medium) = 1.16699413758864573*blcc(medium)
        xcc(medium) = xcc(medium)**2
12111 CONTINUE
12112 CONTINUE
      IF (( spin_effects )) THEN
        call init_spin
      END IF
      write(i_log,*) ' '
      esige_max = 0
      psige_max = 0
      DO 12121 medium=1,nmed
        sigee = 1E-15
        sigep = 1E-15
        neke = meke(medium)
        ise_monoton = .true.
        isp_monoton = .true.
        sige_old = -1
        sigp_old = -1
        DO 12131 i=1,neke
          ei = exp((float(i) - eke0(medium))/eke1(medium))
          eil = log(ei)
          leil = i
          ededx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
          sig=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
          sig = sig/ededx
          IF((sig .GT. sigee))sigee = sig
          IF((sig .LT. sige_old))ise_monoton = .false.
          sige_old = sig
          ededx=pdedx1(Leil,MEDIUM)*eil+pdedx0(Leil,MEDIUM)
          sig=psig1(Leil,MEDIUM)*eil+psig0(Leil,MEDIUM)
          sig = sig/ededx
          IF((sig .GT. sigep))sigep = sig
          IF((sig .LT. sigp_old))isp_monoton = .false.
          sigp_old = sig
12131   CONTINUE
12132   CONTINUE
        write(i_log,*) ' Medium ',medium,' sige = ',sigee,sigep,' monoto
     *ne = ', ise_monoton,isp_monoton
        sig_ismonotone(0,medium) = ise_monoton
        sig_ismonotone(1,medium) = isp_monoton
        esig_e(medium) = sigee
        psig_e(medium) = sigep
        IF((sigee .GT. esige_max))esige_max = sigee
        IF((sigep .GT. psige_max))psige_max = sigep
12121 CONTINUE
12122 CONTINUE
      write(i_log,*) ' '
      write(i_log,*) ' Initializing tmxs for estepe = ',estepe,' and xim
     *ax = ',ximax
      write(i_log,*) ' '
      DO 12141 medium=1,nmed
        ei = exp((1 - eke0(medium))/eke1(medium))
        eil = log(ei)
        leil = 1
        E_array(1,medium) = ei
        expeke1(medium) = Exp(1./eke1(medium))-1
        range_ep(0,1,medium) = 0
        range_ep(1,1,medium) = 0
        neke = meke(medium)
        DO 12151 i=1,neke - 1
          eip1 = exp((float(i + 1) - eke0(medium))/eke1(medium))
          E_array(i+1,medium) = eip1
          eke = 0.5*(eip1+ei)
          elke = Log(eke)
          Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
          ededx=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
          aux = pdedx1(i,medium)/ededx
          range_ep(1,i+1,medium) = range_ep(1,i,medium) + (eip1-ei)/eded
     *    x*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24)
          ededx=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
          aux = ededx1(i,medium)/ededx
          range_ep(0,i+1,medium) = range_ep(0,i,medium) + (eip1-ei)/eded
     *    x*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24)
          ei = eip1
12151   CONTINUE
12152   CONTINUE
        eil = (1 - eke0(medium))/eke1(medium)
        ei = Exp(eil)
        leil = 1
        p2 = ei*(ei+2*rm)
        beta2 = p2/(p2+rm*rm)
        chi_a2 = Xcc(medium)/(4*p2*blcc(medium))
        dedx0=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
        estepx = 2*p2*beta2*dedx0/ei/Xcc(medium)/(Log(1+1./chi_a2)*(1+ch
     *  i_a2)-1)
        estepx = estepx*ximax
        IF (( estepx .GT. estepe )) THEN
          estepx = estepe
        END IF
        si = estepx*ei/dedx0
        DO 12161 i=1,neke - 1
          elke = (i + 1 - eke0(medium))/eke1(medium)
          eke = Exp(elke)
          lelke = i+1
          p2 = eke*(eke+2*rm)
          beta2 = p2/(p2+rm*rm)
          chi_a2 = Xcc(medium)/(4*p2*blcc(medium))
          ededx=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
          estepx = 2*p2*beta2*ededx/eke/ Xcc(medium)/(Log(1+1./chi_a2)*(
     *    1+chi_a2)-1)
          estepx = estepx*ximax
          IF (( estepx .GT. estepe )) THEN
            estepx = estepe
          END IF
          ekef = (1-estepx)*eke
          IF (( ekef .LE. E_array(1,medium) )) THEN
            sip1 = (E_array(1,medium) - ekef)/dedx0
            ekef = E_array(1,medium)
            elkef = (1 - eke0(medium))/eke1(medium)
            lelkef = 1
          ELSE
            elkef = Log(ekef)
            Lelkef=eke1(MEDIUM)*elkef+eke0(MEDIUM)
            leip1l = lelkef + 1
            eip1l = (leip1l - eke0(medium))/eke1(medium)
            eip1 = E_array(leip1l,medium)
            aux = (eip1 - ekef)/eip1
            elktmp = 0.5*(elkef+eip1l+0.25*aux*aux*(1+aux*(1+0.875*aux))
     *      )
            ektmp = 0.5*(ekef+eip1)
            lelktmp = lelkef
            ededx=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelktmp,MEDIUM)
            aux = ededx1(lelktmp,medium)/ededx
            sip1 = (eip1 - ekef)/ededx*( 1+aux*(1+2*aux)*((eip1-ekef)/ek
     *      tmp)**2/24)
          END IF
          sip1 = sip1 + range_ep(0,lelke,medium) - range_ep(0,lelkef+1,m
     *    edium)
          tmxs1(i,medium) = (sip1 - si)*eke1(medium)
          tmxs0(i,medium) = sip1 - tmxs1(i,medium)*elke
          si = sip1
12161   CONTINUE
12162   CONTINUE
        tmxs0(neke,medium) = tmxs0(neke - 1,medium)
        tmxs1(neke,medium) = tmxs1(neke - 1,medium)
12141 CONTINUE
12142 CONTINUE
      return
      end
      subroutine mscat(lambda,chia2,q1,elke,beta2,qel,medium, spin_effec
     *ts,find_index,spin_index, cost,sint)
      implicit none
      real*8 lambda, chia2,q1,elke,beta2,cost,sint
      integer*4 qel,medium
      logical spin_effects,find_index,spin_index
      common/ms_data/ ums_array(0:63,0:7,0:31), fms_array(0:63,0:7,0:31)
     *, wms_array(0:63,0:7,0:31), ims_array(0:63,0:7,0:31), llammin,llam
     *max,dllamb,dllambi,dqms,dqmsi
      real*4 ums_array,fms_array,wms_array, llammin,llammax,dllamb,dllam
     *bi,dqms,dqmsi
      integer*2 ims_array
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 sprob,explambda,wsum,wprob,xi,rejf,spin_rejection, cosz,sin
     *z,phi,omega2,llmbda,ai,aj,ak,a,u,du,x1,rnno
      integer*4 icount,i,j,k
      save i,j,omega2
      IF ((lambda .LE. 13.8)) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        sprob = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        explambda = Exp(-lambda)
        IF ((sprob .LT. explambda)) THEN
          cost = 1
          sint = 0
          return
        END IF
        wsum = (1+lambda)*explambda
        IF (( sprob .LT. wsum )) THEN
12170     CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          xi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          xi = 2*chia2*xi/(1 - xi + chia2)
          cost = 1 - xi
          IF (( spin_effects )) THEN
            rejf = spin_rejection(qel,medium,elke,beta2,q1,cost, spin_in
     *      dex,.false.)
            IF((rng_seed .GT. 128))call ranmar_get
            rnno = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF (( rnno .GT. rejf )) THEN
              GOTO 12170
            END IF
          END IF
          sint = sqrt(xi*(2 - xi))
          return
        END IF
        IF (( lambda .LE. 1 )) THEN
          wprob = explambda
          wsum = explambda
          cost = 1
          sint = 0
          icount = 0
12181     CONTINUE
            icount = icount + 1
            IF((icount .GT. 20))GO TO12182
            wprob = wprob*lambda/icount
            wsum = wsum + wprob
12190       CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            xi = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            xi = 2*chia2*xi/(1 - xi + chia2)
            cosz = 1 - xi
            IF (( spin_effects )) THEN
              rejf = spin_rejection(qel,medium,elke,beta2,q1,cosz, spin_
     *        index,.false.)
              IF((rng_seed .GT. 128))call ranmar_get
              rnno = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rnno .GT. rejf )) THEN
                GOTO 12190
              END IF
            END IF
            sinz = xi*(2 - xi)
            IF (( sinz .GT. 1.e-20 )) THEN
              sinz = Sqrt(sinz)
              IF((rng_seed .GT. 128))call ranmar_get
              xi = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              phi = xi*6.2831853
              cost = cost*cosz - sint*sinz*Cos(phi)
              sint = Sqrt(Max(0.0,(1-cost)*(1+cost)))
            END IF
            IF((( wsum .GT. sprob)))GO TO12182
          GO TO 12181
12182     CONTINUE
          return
        END IF
      END IF
      IF ((lambda .LE. 1e5 )) THEN
        IF ((find_index)) THEN
          llmbda = log(lambda)
          ai = llmbda*dllambi
          i = ai
          ai = ai - i
          IF((rng_seed .GT. 128))call ranmar_get
          xi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((xi .LT. ai))i = i + 1
          IF (( q1 .LT. 1e-3 )) THEN
            j = 0
          ELSE IF(( q1 .LT. 0.5 )) THEN
            aj = q1*dqmsi
            j = aj
            aj = aj - j
            IF((rng_seed .GT. 128))call ranmar_get
            xi = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((xi .LT. aj))j = j + 1
          ELSE
            j = 7
          END IF
          IF ((llmbda .LT. 2.2299)) THEN
            omega2 = chia2*(lambda + 4)*(1.347006 + llmbda*( 0.209364 -
     *      llmbda*(0.45525 - llmbda*(0.50142 - 0.081234*llmbda))))
          ELSE
            omega2 = chia2*(lambda + 4)*(-2.77164 + llmbda*(2.94874 - ll
     *      mbda*(0.1535754 - llmbda*0.00552888)))
          END IF
          find_index = .false.
        END IF
12200   CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        xi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        ak = xi*31
        k = ak
        ak = ak - k
        IF((ak .GT. wms_array(i,j,k)))k = ims_array(i,j,k)
        a = fms_array(i,j,k)
        u = ums_array(i,j,k)
        du = ums_array(i,j,k+1) - u
        IF((rng_seed .GT. 128))call ranmar_get
        xi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( abs(a) .LT. 0.2 )) THEN
          x1 = 0.5*(1-xi)*a
          u = u + xi*du*(1+x1*(1-xi*a))
        ELSE
          u = u - du/a*(1-Sqrt(1+xi*a*(2+a)))
        END IF
        xi = omega2*u/(1 + 0.5*omega2 - u)
        IF (( xi .GT. 1.99999 )) THEN
          xi = 1.99999
        END IF
        cost = 1 - xi
        IF (( spin_effects )) THEN
          rejf=spin_rejection(qel,medium,elke,beta2,q1,cost,spin_index,.
     *    false.)
          IF((rng_seed .GT. 128))call ranmar_get
          rnno = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF (( rnno .GT. rejf )) THEN
            GOTO 12200
          END IF
        END IF
        sint = sqrt(xi*(2-xi))
        return
      END IF
      write(i_log,*) ' '
      write(i_log,*) ' *************************************'
      write(i_log,*) ' Maximum step size in mscat exceeded! '
      write(i_log,*) ' Maximum step size initialized: 100000'
      write(i_log,*) ' Present lambda: ',lambda
      write(i_log,*) ' chia2: ',chia2
      write(i_log,*) ' q1 elke beta2: ',q1,elke,beta2
      write(i_log,*) ' medium: ',medium
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' Stopping execution'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      real*8 function spin_rejection(qel,medium,elke,beta2,q1,cost, spin
     *_index,is_single)
      implicit none
      real*8 elke,beta2,q1,cost
      integer*4 qel,medium
      logical spin_index,is_single
      common/spin_data/ spin_rej(6,0:1,0: 31,0:15,0:31), espin_min,espin
     *_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dleneri,dq
     *q1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      real*8 rnno,ai,qq1,aj,xi,ak
      integer*4 i,j,k
      save i,j
      IF (( spin_index )) THEN
        spin_index = .false.
        IF (( beta2 .GE. b2spin_min )) THEN
          ai = (beta2 - b2spin_min)*dbeta2i
          i = ai
          ai = ai - i
          i = i + 15 + 1
        ELSE IF(( elke .GT. espml )) THEN
          ai = (elke - espml)*dleneri
          i = ai
          ai = ai - i
        ELSE
          i = 0
          ai = -1
        END IF
        IF((rng_seed .GT. 128))call ranmar_get
        rnno = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((rnno .LT. ai))i = i + 1
        IF (( is_single )) THEN
          j = 0
        ELSE
          qq1 = 2*q1
          qq1 = qq1/(1 + qq1)
          aj = qq1*dqq1i
          j = aj
          IF (( j .GE. 15 )) THEN
            j = 15
          ELSE
            aj = aj - j
            IF((rng_seed .GT. 128))call ranmar_get
            rnno = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rnno .LT. aj))j = j + 1
          END IF
        END IF
      END IF
      xi = Sqrt(0.5*(1-cost))
      ak = xi*31
      k = ak
      ak = ak - k
      spin_rejection = (1-ak)*spin_rej(medium,qel,i,j,k) + ak*spin_rej(m
     *edium,qel,i,j,k+1)
      return
      end
      subroutine sscat(chia2,elke,beta2,qel,medium,spin_effects,cost,sin
     *t)
      implicit none
      real*8 chia2,elke,beta2,cost,sint
      integer*4 qel,medium
      logical spin_effects
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      real*8 xi,rnno,rejf,spin_rejection,qzero
      logical spin_index
      spin_index = .true.
12210 CONTINUE
      IF((rng_seed .GT. 128))call ranmar_get
      xi = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      xi = 2*chia2*xi/(1 - xi + chia2)
      cost = 1 - xi
      IF (( spin_effects )) THEN
        qzero=0
        rejf = spin_rejection(qel,medium,elke,beta2,qzero,cost,spin_inde
     *  x,.true.)
        IF((rng_seed .GT. 128))call ranmar_get
        rnno = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((rnno .GT. rejf))goto 12210
      END IF
      sint = sqrt(xi*(2 - xi))
      return
      end
      subroutine init_ms_SR
      implicit none
      common/ms_data/ ums_array(0:63,0:7,0:31), fms_array(0:63,0:7,0:31)
     *, wms_array(0:63,0:7,0:31), ims_array(0:63,0:7,0:31), llammin,llam
     *max,dllamb,dllambi,dqms,dqmsi
      real*4 ums_array,fms_array,wms_array, llammin,llammax,dllamb,dllam
     *bi,dqms,dqmsi
      integer*2 ims_array
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,j,k
      write(i_log,'(/a,$)') 'Reading screened Rutherford MS data .......
     *........ '
      rewind(i_mscat)
      DO 12221 i=0,63
        DO 12231 j=0,7
          read(i_mscat,*) (ums_array(i,j,k),k=0,31)
          read(i_mscat,*) (fms_array(i,j,k),k=0,31)
          read(i_mscat,*) (wms_array(i,j,k),k=0,31-1)
          read(i_mscat,*) (ims_array(i,j,k),k=0,31-1)
          DO 12241 k=0,31-1
            fms_array(i,j,k) = fms_array(i,j,k+1)/fms_array(i,j,k)-1
            ims_array(i,j,k) = ims_array(i,j,k)-1
12241     CONTINUE
12242     CONTINUE
          fms_array(i,j,31)=fms_array(i,j,31-1)
12231   CONTINUE
12232   CONTINUE
12221 CONTINUE
12222 CONTINUE
      write(i_log,'(a)') ' done '
      llammin = Log(1.)
      llammax = Log(1e5)
      dllamb = (llammax-llammin)/63
      dllambi = 1./dllamb
      dqms = 0.5/7
      dqmsi = 1./dqms
      return
      end
      subroutine init_spin
      implicit none
      common/spin_data/ spin_rej(6,0:1,0: 31,0:15,0:31), espin_min,espin
     *_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dleneri,dq
     *q1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 eta_array(0:1,0: 31), c_array(0:1,0: 31),g_array(0:1,0: 31)
     *, earray(0: 31),tmp_array(0: 31), sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,
     *Z23,g_m,g_r,sig,dedx, tau,tauc,beta2,eta,gamma,fmax, eil,e,si1e,si
     *2e,si1p,si2p,aae,etap, elarray(0: 31),farray(0: 31), af(0: 31),bf(
     *0: 31),cf(0: 31), df(0: 31),spline,dloge,eloge
      real*4 dum1,dum2,dum3,aux_o
      real*4 fmax_array(0:15)
      integer*2 i2_array(512),ii2
      integer*4 iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke, nd
     *ata,leil,length,ii4,irec
      character spin_file*256
      character*6 string
      integer*4 lnblnk1
      integer*4 spin_unit, rec_length, want_spin_unit
      integer egs_get_unit
      character data_version*32,endianess*4
      logical swap
      real*8 fine,TF_constant
      parameter (fine=137.03604,TF_constant=0.88534138)
      real*4 tmp_4
      character c_2(2), c_4(4)
      equivalence (ii2,c_2), (tmp_4,c_4)
      DO 12251 i=1,len(spin_file)
        spin_file(i:i) = ' '
12251 CONTINUE
12252 CONTINUE
      spin_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'sp
     *inms.data'
      want_spin_unit = 61
      spin_unit = egs_get_unit(want_spin_unit)
      IF (( spin_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'init_spin: failed to get a free fortran unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      rec_length = 276*4
      open(spin_unit,file=spin_file,form='unformatted',access='direct',
     *status='old',recl=rec_length,err=12260)
      read(spin_unit,rec=1,err=12270) data_version,endianess, espin_min,
     *espin_max,b2spin_min,b2spin_max
      swap = endianess.ne.'1234'
      IF (( swap )) THEN
        tmp_4 = espin_min
        call egs_swap_4(c_4)
        espin_min = tmp_4
        tmp_4 = espin_max
        call egs_swap_4(c_4)
        espin_max = tmp_4
        tmp_4 = b2spin_min
        call egs_swap_4(c_4)
        b2spin_min = tmp_4
        tmp_4 = b2spin_max
        call egs_swap_4(c_4)
        b2spin_max = tmp_4
      END IF
      write(i_log,'(//a,a)') 'Reading spin data base from ',spin_file(:l
     *nblnk1(spin_file))
      write(i_log,'(a)') data_version
      write(i_log,'(a,a,a)') 'Data generated on a machine with ',endiane
     *ss, ' endianess'
      write(i_log,'(a,a)') 'The endianess of this CPU is ','1234'
      IF((swap))write(i_log,'(a)') '=> will need to do byte swaping'
      write(i_log,'(a,2f9.2,2f9.5,//)') 'Ranges: ',espin_min,espin_max,
     *b2spin_min,b2spin_max
      n_ener = 15
      n_q = 15
      n_point = 31
      dloge = log(espin_max/espin_min)/n_ener
      eloge = log(espin_min)
      earray(0) = espin_min
      IF (( fool_intel_optimizer )) THEN
        write(25,*) 'Energy grid:'
      END IF
      DO 12281 i=1,n_ener
        eloge = eloge + dloge
        earray(i) = exp(eloge)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) i,earray(i)
        END IF
12281 CONTINUE
12282 CONTINUE
      dbeta2 = (b2spin_max - b2spin_min)/n_ener
      beta2 = b2spin_min
      earray(n_ener+1) = espin_max
      DO 12291 i=n_ener+2,2*n_ener+1
        beta2 = beta2 + dbeta2
        IF (( beta2 .LT. 0.999 )) THEN
          earray(i) = prm*1000.0*(1/sqrt(1-beta2)-1)
        ELSE
          earray(i) = 50585.1
        END IF
        IF (( fool_intel_optimizer )) THEN
          write(25,*) i,earray(i)
        END IF
12291 CONTINUE
12292 CONTINUE
      espin_min = espin_min/1000
      espin_max = espin_max/1000
      dlener = Log(espin_max/espin_min)/15
      dleneri = 1/dlener
      espml = Log(espin_min)
      dbeta2 = (b2spin_max-b2spin_min)/15
      dbeta2i = 1/dbeta2
      dqq1 = 0.5/15
      dqq1i = 1/dqq1
      DO 12301 medium=1,NMED
        write(i_log,'(a,i4,a,$)') '  medium ',medium,' .................
     *.... '
        DO 12311 iq=0,1
          DO 12321 i=0, 31
            eta_array(iq,i)=0
            c_array(iq,i)=0
            g_array(iq,i)=0
            DO 12331 j=0,15
              DO 12341 k=0,31
                spin_rej(medium,iq,i,j,k) = 0
12341         CONTINUE
12342         CONTINUE
12331       CONTINUE
12332       CONTINUE
12321     CONTINUE
12322     CONTINUE
12311   CONTINUE
12312   CONTINUE
        sum_Z2=0
        sum_A=0
        sum_pz=0
        sum_Z=0
        DO 12351 i_ele=1,NNE(medium)
          Z = ZELEM(medium,i_ele)
          iZ = int(Z+0.5)
          IF (( fool_intel_optimizer )) THEN
            write(25,*) ' Z = ',iZ
          END IF
          tmp = PZ(medium,i_ele)*Z*(Z+1)
          sum_Z2 = sum_Z2 + tmp
          sum_Z = sum_Z + PZ(medium,i_ele)*Z
          sum_A = sum_A + PZ(medium,i_ele)*WA(medium,i_ele)
          sum_pz = sum_pz + PZ(medium,i_ele)
          Z23 = Z**0.6666667
          DO 12361 iq=0,1
            DO 12371 i=0, 31
              irec = 1 + (iz-1)*4*(n_ener+1) + 2*iq*(n_ener+1) + i+1
              IF (( fool_intel_optimizer )) THEN
                write(25,*) '**** energy ',i,earray(i),irec
              END IF
              read(spin_unit,rec=irec,err=12270) dum1,dum2,dum3,aux_o,fm
     *        ax_array,i2_array
              IF (( swap )) THEN
                tmp_4 = dum1
                call egs_swap_4(c_4)
                dum1 = tmp_4
                tmp_4 = dum2
                call egs_swap_4(c_4)
                dum2 = tmp_4
                tmp_4 = dum3
                call egs_swap_4(c_4)
                dum3 = tmp_4
                tmp_4 = aux_o
                call egs_swap_4(c_4)
                aux_o = tmp_4
              END IF
              eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o)
              tau = earray(i)/prm*0.001
              beta2 = tau*(tau+2)/(tau+1)**2
              eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2)
              c_array(iq,i)=c_array(iq,i)+ tmp*(Log(1+1/eta)-1/(1+eta))*
     *        dum1*dum3
              g_array(iq,i)=g_array(iq,i)+tmp*dum2
              DO 12381 j=0,15
                tmp_4 = fmax_array(j)
                IF((swap))call egs_swap_4(c_4)
                DO 12391 k=0,31
                  ii2 = i2_array((n_point+1)*j + k+1)
                  IF((swap))call egs_swap_2(c_2)
                  ii4 = ii2
                  IF((ii4 .LT. 0))ii4 = ii4 + 65536
                  dum1 = ii4
                  dum1 = dum1*tmp_4/65535
                  spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)
     *            + tmp*dum1
12391           CONTINUE
12392           CONTINUE
12381         CONTINUE
12382         CONTINUE
12371       CONTINUE
12372       CONTINUE
12361     CONTINUE
12362     CONTINUE
12351   CONTINUE
12352   CONTINUE
        DO 12401 iq=0,1
          DO 12411 i=0, 31
            DO 12421 j=0,15
              fmax = 0
              DO 12431 k=0,31
                IF (( spin_rej(medium,iq,i,j,k) .GT. fmax )) THEN
                  fmax = spin_rej(medium,iq,i,j,k)
                END IF
12431         CONTINUE
12432         CONTINUE
              DO 12441 k=0,31
                spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fm
     *          ax
12441         CONTINUE
12442         CONTINUE
12421       CONTINUE
12422       CONTINUE
12411     CONTINUE
12412     CONTINUE
12401   CONTINUE
12402   CONTINUE
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Spin corrections as read in from file'
        END IF
        DO 12451 i=0, 31
          tau = earray(i)/prm*0.001
          beta2 = tau*(tau+2)/(tau+1)**2
          DO 12461 iq=0,1
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium)
            eta = aux_o/4/tau/(tau+2)
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/ (Log(1+1/eta)*
     *      (1+eta)-1)
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta)
     *      )
12461     CONTINUE
12462     CONTINUE
          IF (( fool_intel_optimizer )) THEN
            write(25,*) i,earray(i),eta_array(0,i),eta_array(1,i), c_arr
     *      ay(0,i),c_array(1,i),g_array(0,i),g_array(1,i)
          END IF
12451   CONTINUE
12452   CONTINUE
        eil = (1 - eke0(medium))/eke1(medium)
        e = Exp(eil)
        IF (( e .LE. espin_min )) THEN
          si1e = eta_array(0,0)
          si1p = eta_array(1,0)
        ELSE
          IF (( e .LE. espin_max )) THEN
            aae = (eil-espml)*dleneri
            je = aae
            aae = aae - je
          ELSE
            tau = e/prm
            beta2 = tau*(tau+2)/(tau+1)**2
            aae = (beta2 - b2spin_min)*dbeta2i
            je = aae
            aae = aae - je
            je = je + 15 + 1
          END IF
          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
        END IF
        neke = meke(medium)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for eta correction'
        END IF
        DO 12471 i=1,neke - 1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          IF (( e .LE. espin_min )) THEN
            si2e = eta_array(0,0)
            si2p = eta_array(1,0)
          ELSE
            IF (( e .LE. espin_max )) THEN
              aae = (eil-espml)*dleneri
              je = aae
              aae = aae - je
            ELSE
              tau = e/prm
              beta2 = tau*(tau+2)/(tau+1)**2
              aae = (beta2 - b2spin_min)*dbeta2i
              je = aae
              aae = aae - je
              je = je + 15 + 1
            END IF
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
          END IF
          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil
          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium)
          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) i,e,si2e,si2p,etae_ms1(i,medium), etae_ms0(i,med
     *      ium),etap_ms1(i,medium),etap_ms0(i,medium)
          END IF
          si1e = si2e
          si1p = si2p
12471   CONTINUE
12472   CONTINUE
        etae_ms1(neke,medium) = etae_ms1(neke-1,medium)
        etae_ms0(neke,medium) = etae_ms0(neke-1,medium)
        etap_ms1(neke,medium) = etap_ms1(neke-1,medium)
        etap_ms0(neke,medium) = etap_ms0(neke-1,medium)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'elarray:'
        END IF
        DO 12481 i=0,15
          elarray(i) = Log(earray(i)/1000)
          farray(i) = c_array(0,i)
          IF (( fool_intel_optimizer )) THEN
            write(25,*) elarray(i),earray(i)
          END IF
12481   CONTINUE
12482   CONTINUE
        DO 12491 i=15+1, 31-1
          elarray(i) = Log(earray(i+1)/1000)
          farray(i) = c_array(0,i+1)
          IF (( fool_intel_optimizer )) THEN
            write(25,*) elarray(i),earray(i+1)
          END IF
12491   CONTINUE
12492   CONTINUE
        ndata =  31+1
        IF (( ue(medium) .GT. 1e5 )) THEN
          elarray(ndata-1) = Log(ue(medium))
        ELSE
          elarray(ndata-1) = Log(1e5)
        END IF
        farray(ndata-1) = 1
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q1 correction (e-)'
        END IF
        DO 12501 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q1ce_ms1(i,medium), q1ce_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
12501   CONTINUE
12502   CONTINUE
        q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium)
        q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Postrons:'
        END IF
        DO 12511 i=0,15
          farray(i) = c_array(1,i)
12511   CONTINUE
12512   CONTINUE
        DO 12521 i=15+1, 31-1
          farray(i) = c_array(1,i+1)
12521   CONTINUE
12522   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q1 correction (e+)'
        END IF
        DO 12531 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q1cp_ms1(i,medium), q1cp_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
12531   CONTINUE
12532   CONTINUE
        q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium)
        q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium)
        DO 12541 i=0,15
          farray(i) = g_array(0,i)
12541   CONTINUE
12542   CONTINUE
        DO 12551 i=15+1, 31-1
          farray(i) = g_array(0,i+1)
12551   CONTINUE
12552   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q2 correction (e-)'
        END IF
        DO 12561 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q2ce_ms1(i,medium), q2ce_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
12561   CONTINUE
12562   CONTINUE
        q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium)
        q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium)
        DO 12571 i=0,15
          farray(i) = g_array(1,i)
12571   CONTINUE
12572   CONTINUE
        DO 12581 i=15+1, 31-1
          farray(i) = g_array(1,i+1)
12581   CONTINUE
12582   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q2 correction (e+)'
        END IF
        DO 12591 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q2cp_ms1(i,medium), q2cp_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
12591   CONTINUE
12592   CONTINUE
        q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium)
        q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium)
        tauc = te(medium)/prm
        si1e = 1
        DO 12601 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          leil=i+1
          tau=e/prm
          IF (( tau .GT. 2*tauc )) THEN
            sig=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
            dedx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
            sig = sig/dedx
            IF (( sig .GT. 1e-6 )) THEN
              etap=etae_ms1(Leil,MEDIUM)*eil+etae_ms0(Leil,MEDIUM)
              eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2)
              g_r = (1+2*eta)*Log(1+1/eta)-2
              g_m = Log(0.5*tau/tauc)+ (1+((tau+2)/(tau+1))**2)*Log(2*(t
     *        au-tauc+2)/(tau+4))- 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+
     *        1)**2)* Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+ 0.5*(tau
     *        -2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2)
              IF (( g_m .LT. g_r )) THEN
                g_m = g_m/g_r
              ELSE
                g_m = 1
              END IF
              si2e = 1 - g_m*sum_Z/sum_Z2
            ELSE
              si2e = 1
            END IF
          ELSE
            si2e = 1
          END IF
          blcce1(i,medium) = (si2e - si1e)*eke1(medium)
          blcce0(i,medium) = si2e - blcce1(i,medium)*eil
          si1e = si2e
12601   CONTINUE
12602   CONTINUE
        blcce1(neke,medium) = blcce1(neke-1,medium)
        blcce0(neke,medium) = blcce0(neke-1,medium)
        write(i_log,'(a)') ' done'
12301 CONTINUE
12302 CONTINUE
      close(spin_unit)
      return
12260 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,a)') 'Failed to open spin data file ',spin_file(:l
     *nblnk1(spin_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
12270 write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Error while reading spin data file for element',iZ
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine init_spin_old
      implicit none
      common/spin_data/ spin_rej(6,0:1,0: 31,0:15,0:31), espin_min,espin
     *_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dleneri,dq
     *q1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 eta_array(0:1,0: 31), c_array(0:1,0: 31),g_array(0:1,0: 31)
     *, earray(0: 31),tmp_array(0: 31), sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,
     *Z23,g_m,g_r,sig,dedx, dum1,dum2,dum3,aux_o,tau,tauc,beta2,eta,gamm
     *a,fmax, eil,e,si1e,si2e,si1p,si2p,aae,etap, elarray(0: 31),farray(
     *0: 31), af(0: 31),bf(0: 31),cf(0: 31), df(0: 31),spline
      integer*4 iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke, nd
     *ata,leil,length,want_spin_unit,spin_unit,egs_get_unit
      character spin_file*256
      character*6 string
      integer*4 lnblnk1
      real*8 fine,TF_constant
      parameter (fine=137.03604,TF_constant=0.88534138)
      DO 12611 i=1,len(spin_file)
        spin_file(i:i) = ' '
12611 CONTINUE
12612 CONTINUE
      spin_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'sp
     *inms' // '/' // 'z000'
      length = lnblnk1(spin_file)
      DO 12621 medium=1,NMED
        write(i_log,'(a,i4,a,$)') '  Initializing spin data for medium '
     *  ,medium, ' ..................... '
        DO 12631 iq=0,1
          DO 12641 i=0, 31
            eta_array(iq,i)=0
            c_array(iq,i)=0
            g_array(iq,i)=0
            DO 12651 j=0,15
              DO 12661 k=0,31
                spin_rej(medium,iq,i,j,k) = 0
12661         CONTINUE
12662         CONTINUE
12651       CONTINUE
12652       CONTINUE
12641     CONTINUE
12642     CONTINUE
12631   CONTINUE
12632   CONTINUE
        sum_Z2=0
        sum_A=0
        sum_pz=0
        sum_Z=0
        DO 12671 i_ele=1,NNE(medium)
          Z = ZELEM(medium,i_ele)
          iZ = int(Z+0.5)
          tmp = PZ(medium,i_ele)*Z*(Z+1)
          iii = iZ/100
          spin_file(length-2:length-2) = char(iii+48)
          iiZ = iZ - iii*100
          iii = iiZ/10
          spin_file(length-1:length-1) = char(iii+48)
          iiZ = iiZ - 10*iii
          spin_file(length:length) = char(iiZ+48)
          want_spin_unit = 61
          spin_unit = egs_get_unit(want_spin_unit)
          IF (( spin_unit .LT. 1 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'init_spin: failed to get a free fortran unit
     *'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(spin_unit,file=spin_file,status='old',err=12680)
          read(spin_unit,*) espin_min,espin_max,b2spin_min,b2spin_max
          read(spin_unit,*) n_ener,n_q,n_point
          IF (( n_ener .NE. 15 .OR. n_q .NE. 15 .OR. n_point .NE. 31)) T
     *    HEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) ' Wrong spin file for Z = ',iZ
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          sum_Z2 = sum_Z2 + tmp
          sum_Z = sum_Z + PZ(medium,i_ele)*Z
          sum_A = sum_A + PZ(medium,i_ele)*WA(medium,i_ele)
          sum_pz = sum_pz + PZ(medium,i_ele)
          Z23 = Z**0.6666667
          DO 12691 iq=0,1
            read(spin_unit,*)
            read(spin_unit,*)
            DO 12701 i=0, 31
              read(spin_unit,'(a,g14.6)') string,earray(i)
              read(spin_unit,*) dum1,dum2,dum3,aux_o
              eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o)
              tau = earray(i)/prm*0.001
              beta2 = tau*(tau+2)/(tau+1)**2
              eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2)
              c_array(iq,i)=c_array(iq,i)+ tmp*(Log(1+1/eta)-1/(1+eta))*
     *        dum1*dum3
              g_array(iq,i)=g_array(iq,i)+tmp*dum2
              DO 12711 j=0,15
                read(spin_unit,*) tmp_array
                DO 12721 k=0,31
                  spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)
     *            + tmp*tmp_array(k)
12721           CONTINUE
12722           CONTINUE
12711         CONTINUE
12712         CONTINUE
12701       CONTINUE
12702       CONTINUE
12691     CONTINUE
12692     CONTINUE
          close(spin_unit)
12671   CONTINUE
12672   CONTINUE
        DO 12731 iq=0,1
          DO 12741 i=0, 31
            DO 12751 j=0,15
              fmax = 0
              DO 12761 k=0,31
                IF (( spin_rej(medium,iq,i,j,k) .GT. fmax )) THEN
                  fmax = spin_rej(medium,iq,i,j,k)
                END IF
12761         CONTINUE
12762         CONTINUE
              DO 12771 k=0,31
                spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fm
     *          ax
12771         CONTINUE
12772         CONTINUE
12751       CONTINUE
12752       CONTINUE
12741     CONTINUE
12742     CONTINUE
12731   CONTINUE
12732   CONTINUE
        DO 12781 i=0, 31
          tau = earray(i)/prm*0.001
          beta2 = tau*(tau+2)/(tau+1)**2
          DO 12791 iq=0,1
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium)
            eta = aux_o/4/tau/(tau+2)
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/ (Log(1+1/eta)*
     *      (1+eta)-1)
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta)
     *      )
12791     CONTINUE
12792     CONTINUE
12781   CONTINUE
12782   CONTINUE
        espin_min = espin_min/1000
        espin_max = espin_max/1000
        dlener = Log(espin_max/espin_min)/15
        dleneri = 1/dlener
        espml = Log(espin_min)
        dbeta2 = (b2spin_max-b2spin_min)/15
        dbeta2i = 1/dbeta2
        dqq1 = 0.5/15
        dqq1i = 1/dqq1
        eil = (1 - eke0(medium))/eke1(medium)
        e = Exp(eil)
        IF (( e .LE. espin_min )) THEN
          si1e = eta_array(0,0)
          si1p = eta_array(1,0)
        ELSE
          IF (( e .LE. espin_max )) THEN
            aae = (eil-espml)*dleneri
            je = aae
            aae = aae - je
          ELSE
            tau = e/prm
            beta2 = tau*(tau+2)/(tau+1)**2
            aae = (beta2 - b2spin_min)*dbeta2i
            je = aae
            aae = aae - je
            je = je + 15 + 1
          END IF
          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
        END IF
        neke = meke(medium)
        DO 12801 i=1,neke - 1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          IF (( e .LE. espin_min )) THEN
            si2e = eta_array(0,0)
            si2p = eta_array(1,0)
          ELSE
            IF (( e .LE. espin_max )) THEN
              aae = (eil-espml)*dleneri
              je = aae
              aae = aae - je
            ELSE
              tau = e/prm
              beta2 = tau*(tau+2)/(tau+1)**2
              aae = (beta2 - b2spin_min)*dbeta2i
              je = aae
              aae = aae - je
              je = je + 15 + 1
            END IF
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
          END IF
          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil
          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium)
          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil
          si1e = si2e
          si1p = si2p
12801   CONTINUE
12802   CONTINUE
        etae_ms1(neke,medium) = etae_ms1(neke-1,medium)
        etae_ms0(neke,medium) = etae_ms0(neke-1,medium)
        etap_ms1(neke,medium) = etap_ms1(neke-1,medium)
        etap_ms0(neke,medium) = etap_ms0(neke-1,medium)
        DO 12811 i=0,15
          elarray(i) = Log(earray(i)/1000)
          farray(i) = c_array(0,i)
12811   CONTINUE
12812   CONTINUE
        DO 12821 i=15+1, 31-1
          elarray(i) = Log(earray(i+1)/1000)
          farray(i) = c_array(0,i+1)
12821   CONTINUE
12822   CONTINUE
        ndata =  31+1
        IF (( ue(medium) .GT. 1e5 )) THEN
          elarray(ndata-1) = Log(ue(medium))
        ELSE
          elarray(ndata-1) = Log(1e5)
        END IF
        farray(ndata-1) = 1
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 12831 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil
          si1e = si2e
12831   CONTINUE
12832   CONTINUE
        q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium)
        q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium)
        DO 12841 i=0,15
          farray(i) = c_array(1,i)
12841   CONTINUE
12842   CONTINUE
        DO 12851 i=15+1, 31-1
          farray(i) = c_array(1,i+1)
12851   CONTINUE
12852   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 12861 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil
          si1e = si2e
12861   CONTINUE
12862   CONTINUE
        q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium)
        q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium)
        DO 12871 i=0,15
          farray(i) = g_array(0,i)
12871   CONTINUE
12872   CONTINUE
        DO 12881 i=15+1, 31-1
          farray(i) = g_array(0,i+1)
12881   CONTINUE
12882   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 12891 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil
          si1e = si2e
12891   CONTINUE
12892   CONTINUE
        q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium)
        q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium)
        DO 12901 i=0,15
          farray(i) = g_array(1,i)
12901   CONTINUE
12902   CONTINUE
        DO 12911 i=15+1, 31-1
          farray(i) = g_array(1,i+1)
12911   CONTINUE
12912   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 12921 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil
12921   CONTINUE
12922   CONTINUE
        q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium)
        q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium)
        tauc = te(medium)/prm
        si1e = 1
        DO 12931 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          leil=i+1
          tau=e/prm
          IF (( tau .GT. 2*tauc )) THEN
            sig=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
            dedx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
            sig = sig/dedx
            IF (( sig .GT. 1e-6 )) THEN
              etap=etae_ms1(Leil,MEDIUM)*eil+etae_ms0(Leil,MEDIUM)
              eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2)
              g_r = (1+2*eta)*Log(1+1/eta)-2
              g_m = Log(0.5*tau/tauc)+ (1+((tau+2)/(tau+1))**2)*Log(2*(t
     *        au-tauc+2)/(tau+4))- 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+
     *        1)**2)* Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+ 0.5*(tau
     *        -2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2)
              IF (( g_m .LT. g_r )) THEN
                g_m = g_m/g_r
              ELSE
                g_m = 1
              END IF
              si2e = 1 - g_m*sum_Z/sum_Z2
            ELSE
              si2e = 1
            END IF
          ELSE
            si2e = 1
          END IF
          blcce1(i,medium) = (si2e - si1e)*eke1(medium)
          blcce0(i,medium) = si2e - blcce1(i,medium)*eil
          si1e = si2e
12931   CONTINUE
12932   CONTINUE
        blcce1(neke,medium) = blcce1(neke-1,medium)
        blcce0(neke,medium) = blcce0(neke-1,medium)
        write(i_log,'(a)') ' done'
12621 CONTINUE
12622 CONTINUE
      return
12680 write(i_log,*) ' ******************** Error in init_spin *********
     *********** '
      write(i_log,'(a,a)') '  could not open file ',spin_file
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' terminating execution '
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      subroutine msdist_pII ( e0,eloss,tustep,rhof,med,qel,spin_effects,
     *u0,v0,w0,x0,y0,z0,  us,vs,ws,xf,yf,zf,ustep )
      implicit none
      real*8 e0,  eloss,  rhof,  tustep,  u0,  v0,  w0,  x0,  y0,  z0
      integer*4 med, qel
      logical spin_effects
      real*8 us,  vs,  ws,  xf,  yf,  zf,  ustep
      real*8 b,  blccc,  xcccc,  c,  eta,eta1,  chia2,  chilog,  cphi0,
     *  cphi1,  cphi2,  w1,  w2,  w1v2,  delta,  e,  elke,  beta2,  etap
     *,  xi_corr,  ms_corr, tau,  tau2,  epsilon,  epsilonp,  temp,temp1
     *, temp2,  factor,  gamma,  lambda,   p2,  p2i,  q1,  rhophi2,  sin
     *t0,  sint02,  sint0i,  sint1,  sint2,  sphi0,   sphi1,  sphi2,  u2
     *p,  u2,  v2,  ut,  vt,  wt,  xi,  xphi,  xphi2,  yphi,  yphi2
      logical find_index,  spin_index
      integer*4 lelke
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      medium = med
      count_pII_steps = count_pII_steps + 1
      blccc = blcc(medium)
      xcccc = xcc(medium)
      e = e0 - 0.5*eloss
      tau = e/prm
      tau2 = tau*tau
      epsilon = eloss/e0
      epsilonp= eloss/e
      e = e * (1 - epsilonp*epsilonp*(6+10*tau+5*tau2)/(24*tau2+72*tau+4
     *8))
      p2 = e*(e + rmt2)
      beta2 = p2/(p2 + rmsq)
      chia2 = xcccc/(4*p2*blccc)
      lambda = 0.5*tustep*rhof*blccc/beta2
      temp2 = 0.166666*(4+tau*(6+tau*(7+tau*(4+tau))))* (epsilonp/((tau+
     *1)*(tau+2)))**2
      lambda = lambda*(1 - temp2)
      IF (( spin_effects )) THEN
        elke = Log(e)
        Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
        IF (( lelke .LT. 1 )) THEN
          lelke = 1
          elke = (1 - eke0(medium))/eke1(medium)
        END IF
        IF (( qel .EQ. 0 )) THEN
          etap=etae_ms1(Lelke,MEDIUM)*elke+etae_ms0(Lelke,MEDIUM)
          xi_corr=q1ce_ms1(Lelke,MEDIUM)*elke+q1ce_ms0(Lelke,MEDIUM)
          gamma=q2ce_ms1(Lelke,MEDIUM)*elke+q2ce_ms0(Lelke,MEDIUM)
        ELSE
          etap=etap_ms1(Lelke,MEDIUM)*elke+etap_ms0(Lelke,MEDIUM)
          xi_corr=q1cp_ms1(Lelke,MEDIUM)*elke+q1cp_ms0(Lelke,MEDIUM)
          gamma=q2cp_ms1(Lelke,MEDIUM)*elke+q2cp_ms0(Lelke,MEDIUM)
        END IF
        ms_corr=blcce1(Lelke,MEDIUM)*elke+blcce0(Lelke,MEDIUM)
      ELSE
        etap = 1
        xi_corr = 1
        gamma = 1
        ms_corr = 1
      END IF
      chia2 = chia2*etap
      lambda = lambda/(etap*(1+chia2))*ms_corr
      chilog = Log(1 + 1/chia2)
      q1 = 2*chia2*(chilog*(1 + chia2) - 1)
      gamma = 6*chia2*(1 + chia2)*(chilog*(1 + 2*chia2) - 2)/q1*gamma
      xi = q1*lambda
      find_index = .true.
      spin_index = .true.
      call mscat(lambda,chia2,xi,elke,beta2,qel,medium, spin_effects,fin
     *d_index,spin_index, w1,sint1)
12941 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        xphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF((rng_seed .GT. 128))call ranmar_get
        yphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO12942
      GO TO 12941
12942 CONTINUE
      rhophi2 = 1/rhophi2
      cphi1 = (xphi2 - yphi2)*rhophi2
      sphi1 = 2*xphi*yphi*rhophi2
      call mscat(lambda,chia2,xi,elke,beta2,qel,medium, spin_effects,fin
     *d_index,spin_index, w2,sint2)
12951 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        xphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF((rng_seed .GT. 128))call ranmar_get
        yphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO12952
      GO TO 12951
12952 CONTINUE
      rhophi2 = 1/rhophi2
      cphi2 = (xphi2 - yphi2)*rhophi2
      sphi2 = 2*xphi*yphi*rhophi2
      u2 = sint2*cphi2
      v2 = sint2*sphi2
      u2p = w1*u2 + sint1*w2
      us = u2p*cphi1 - v2*sphi1
      vs = u2p*sphi1 + v2*cphi1
      ws = w1*w2 - sint1*u2
      xi = 2*xi*xi_corr
      IF((rng_seed .GT. 128))call ranmar_get
      eta = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      eta = Sqrt(eta)
      eta1 = 0.5*(1 - eta)
      delta = 0.9082483-(0.1020621-0.0263747*gamma)*xi
      temp1 = 2 + tau
      temp = (2+tau*temp1)/((tau+1)*temp1)
      temp = temp - (tau+1)/((tau+2)*(chilog*(1+chia2)-1))
      temp = temp * epsilonp
      temp1 = 1 - temp
      delta = delta + 0.40824829*(epsilon*(tau+1)/((tau+2)* (chilog*(1+c
     *hia2)-1)*(chilog*(1+2*chia2)-2)) - 0.25*temp*temp)
      b = eta*delta
      c = eta*(1-delta)
      w1v2 = w1*v2
      ut = b*sint1*cphi1 + c*(cphi1*u2 - sphi1*w1v2) + eta1*us*temp1
      vt = b*sint1*sphi1 + c*(sphi1*u2 + cphi1*w1v2) + eta1*vs*temp1
      wt = eta1*(1+temp) + b*w1 + c*w2 + eta1*ws*temp1
      ustep = tustep*sqrt(ut*ut + vt*vt + wt*wt)
      sint02 = u0**2 + v0**2
      IF ((sint02 .GT. 1e-20)) THEN
        sint0 = sqrt(sint02)
        sint0i = 1/sint0
        cphi0 = sint0i*u0
        sphi0 = sint0i*v0
        u2p = w0*us + sint0*ws
        ws = w0*ws - sint0*us
        us = u2p*cphi0 - vs*sphi0
        vs = u2p*sphi0 + vs*cphi0
        u2p = w0*ut + sint0*wt
        wt = w0*wt - sint0*ut
        ut = u2p*cphi0 - vt*sphi0
        vt = u2p*sphi0 + vt*cphi0
      ELSE
        wt = w0*wt
        ws = w0*ws
      END IF
      xf = x0 + tustep*ut
      yf = y0 + tustep*vt
      zf = z0 + tustep*wt
      return
      end
      subroutine msdist_pI ( e0,eloss,tustep,rhof,medium,qel,spin_effect
     *s,u0,v0,w0,x0,y0,z0,  us,vs,ws,xf,yf,zf,ustep )
      implicit none
      real*8 e0,  eloss,  rhof,  tustep,  u0,  v0,  w0,  x0,  y0,  z0
      integer*4 medium, qel
      logical spin_effects
      real*8 us,  vs,  ws,  xf,  yf,  zf,  ustep
      real*8 blccc,  xcccc,  z,r,z2,r2,  r2max, chia2,  chilog,  cphi0,
     *  cphi,  sphi,  e,  elke,  beta2,  etap,  xi_corr,  ms_corr, epsil
     *on,  temp,  factor,  lambda,  p2,  p2i,  q1,  rhophi2,  sint,  sin
     *t0,  sint02,  sint0i,  sphi0,   u2p,  ut,  vt,  wt,  xi,  xphi,  x
     *phi2,  yphi,  yphi2
      logical find_index,  spin_index
      integer*4 lelke
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      blccc = blcc(medium)
      xcccc = xcc(medium)
      e = e0 - 0.5*eloss
      p2 = e*(e + rmt2)
      p2i = 1/p2
      chia2 = xcccc*p2i/(4*blccc)
      beta2 = p2/(p2 + rmsq)
      lambda = tustep*rhof*blccc/beta2
      factor = 1/(1 + 0.9784671*e)
      epsilon= eloss/e0
      epsilon= epsilon/(1-0.5*epsilon)
      temp = 0.25*(1 - factor*(1 - 0.333333*factor))*epsilon**2
      lambda = lambda*(1 + temp)
      IF (( spin_effects )) THEN
        elke = Log(e)
        Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
        IF (( lelke .LT. 1 )) THEN
          lelke = 1
          elke = (1 - eke0(medium))/eke1(medium)
        END IF
        IF (( qel .EQ. 0 )) THEN
          etap=etae_ms1(Lelke,MEDIUM)*elke+etae_ms0(Lelke,MEDIUM)
          xi_corr=q1ce_ms1(Lelke,MEDIUM)*elke+q1ce_ms0(Lelke,MEDIUM)
        ELSE
          etap=etap_ms1(Lelke,MEDIUM)*elke+etap_ms0(Lelke,MEDIUM)
          xi_corr=q1cp_ms1(Lelke,MEDIUM)*elke+q1cp_ms0(Lelke,MEDIUM)
        END IF
        ms_corr=blcce1(Lelke,MEDIUM)*elke+blcce0(Lelke,MEDIUM)
      ELSE
        etap = 1
        xi_corr = 1
        ms_corr = 1
      END IF
      chia2 = xcccc*p2i/(4*blccc)*etap
      lambda = lambda/etap/(1+chia2)*ms_corr
      chilog = Log(1 + 1/chia2)
      q1 = 2*chia2*(chilog*(1 + chia2) - 1)
      xi = q1*lambda
      find_index = .true.
      spin_index = .true.
      call mscat(lambda,chia2,xi,elke,beta2,qel,medium, spin_effects,fin
     *d_index,spin_index, ws,sint)
12961 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        xphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF((rng_seed .GT. 128))call ranmar_get
        yphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO12962
      GO TO 12961
12962 CONTINUE
      rhophi2 = 1/rhophi2
      cphi = (xphi2 - yphi2)*rhophi2
      sphi = 2*xphi*yphi*rhophi2
      us = sint*cphi
      vs = sint*sphi
      xi = xi*xi_corr
      IF (( xi .LT. 0.1 )) THEN
        z = 1 - xi*(0.5 - xi*(0.166666667 - 0.041666667*xi))
      ELSE
        z = (1 - Exp(-xi))/xi
      END IF
      r = 0.5*sint
      r2 = r*r
      z2 = z*z
      r2max = 1 - z2
      IF (( r2max .LT. r2 )) THEN
        r2 = r2max
        r = Sqrt(r2)
      END IF
      ut = r*cphi
      vt = r*sphi
      wt = z
      ustep = Sqrt(z2 + r2)*tustep
      sint02 = u0**2 + v0**2
      IF ((sint02 .GT. 1e-20)) THEN
        sint0 = sqrt(sint02)
        sint0i = 1/sint0
        cphi0 = sint0i*u0
        sphi0 = sint0i*v0
        u2p = w0*us + sint0*ws
        ws = w0*ws - sint0*us
        us = u2p*cphi0 - vs*sphi0
        vs = u2p*sphi0 + vs*cphi0
        u2p = w0*ut + sint0*wt
        wt = w0*wt - sint0*ut
        ut = u2p*cphi0 - vt*sphi0
        vt = u2p*sphi0 + vt*cphi0
      ELSE
        wt = w0*wt
        ws = w0*ws
      END IF
      xf = x0 + tustep*ut
      yf = y0 + tustep*vt
      zf = z0 + tustep*wt
      return
      end
      SUBROUTINE PAIR
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      common/nrc_pair/ nrcp_fdata(65,84,6), nrcp_wdata(65,84,6), nrcp_id
     *ata(65,84,6), nrcp_xdata(65), nrcp_emin, nrcp_emax, nrcp_dle, nrcp
     *_dlei
      real*8 nrcp_fdata,nrcp_wdata,nrcp_xdata, nrcp_emin, nrcp_emax, nrc
     *p_dle, nrcp_dlei
      integer*4 nrcp_idata
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/triplet_data/ a_triplet(250,6), b_triplet(250,6), dl_triple
     *t, dli_triplet, bli_triplet, log_4rm
      real*8 a_triplet,b_triplet,dl_triplet, dli_triplet, bli_triplet, l
     *og_4rm
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DOUBLE PRECISION PEIG,  PESE1,  PESE2
      real*8 EIG,  ESE2,  RNNO30,RNNO31,rnno32,rnno33,rnno34,  DELTA,  R
     *EJF,  rejmax,  aux1,aux2,  Amax,  Bmax,  del0,  br,
     *                               Eminus,Eplus,Eavail,rnno_RR
      integer*4
     *                     L,L1
      real*8 ESE,  PSE,  ZTARG,  TTEIG,  TTESE,  TTPSE,  ESEDEI, ESEDER,
     * XIMIN,  XIMID,  REJMIN, REJMID, REJTOP, YA,XITRY,GALPHA,GBETA,  X
     *ITST,  REJTST_on_REJTOP ,  REJTST, RTEST
      integer*4 ICHRG
      real*8 k,xx,abin,rbin,alias_sample1
      integer*4 ibin, iq1, iq2, iprdst_use
      logical do_nrc_pair
      integer*4 itrip
      real*8 ftrip
      NPold = NP
      IF (( i_play_RR .EQ. 1 )) THEN
        i_survived_RR = 0
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,'(a,g14.6)') 'Attempt to play Russian Roulette w
     *ith prob_RR<0! '
          END IF
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          rnno_RR = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF (( rnno_RR .GT. prob_RR )) THEN
            i_survived_RR =2
            IF (( np .GT. 1 )) THEN
              np = np-1
            ELSE
              wt(np) = 0
              e(np) = 0
            END IF
            return
          ELSE
            wt(np) = wt(np)/prob_RR
          END IF
        END IF
      END IF
      IF (( np+1 .GT. 150 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','PAIR', ' sta
     *ck size exceeded! ',' $MAXSTACK = ',150,' np = ',np+1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      PEIG=E(NP)
      EIG=PEIG
      do_nrc_pair = .false.
      IF (( itriplet .GT. 0 .AND. eig .GT. 4*rm )) THEN
        itrip = dli_triplet*gle + bli_triplet
        ftrip = a_triplet(itrip,medium)*gle + b_triplet(itrip,medium)
        IF((rng_seed .GT. 128))call ranmar_get
        rnno34 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( rnno34 .LT. ftrip )) THEN
          call sample_triplet
          return
        END IF
      END IF
      IF (( pair_nrc .EQ. 1 )) THEN
        k = eig/rm
        IF (( k .LT. nrcp_emax )) THEN
          do_nrc_pair = .true.
          IF (( k .LE. nrcp_emin )) THEN
            ibin = 1
          ELSE
            abin = 1 + log((k-2)/(nrcp_emin-2))*nrcp_dlei
            ibin = abin
            abin = abin - ibin
            IF((rng_seed .GT. 128))call ranmar_get
            rbin = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rbin .LT. abin))ibin = ibin + 1
          END IF
          xx = alias_sample1(64,nrcp_xdata, nrcp_fdata(1,ibin,medium),nr
     *    cp_wdata(1,ibin,medium), nrcp_idata(1,ibin,medium))
          IF (( xx .GT. 0.5 )) THEN
            pese1 = prm*(1 + xx*(k-2))
            iq1 = 1
            pese2 = peig - pese1
            iq2 = -1
          ELSE
            pese2 = prm*(1 + xx*(k-2))
            iq2 = 1
            pese1 = peig - pese2
            iq1 = -1
          END IF
        END IF
      END IF
      IF (( .NOT.do_nrc_pair )) THEN
        IF ((EIG.LE.2.1)) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO30 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          rnno34 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          PESE2 = PRM + 0.5*RNNO30*(PEIG-2*PRM)
          PESE1 = PEIG - PESE2
          IF (( rnno34 .LT. 0.5 )) THEN
            iq1 = -1
            iq2 = 1
          ELSE
            iq1 = 1
            iq2 = -1
          END IF
        ELSE
          IF ((EIG.LT.50.)) THEN
            L = 5
            L1 = L + 1
            delta = 4*delcm(medium)/eig
            IF (( delta .LT. 1 )) THEN
              Amax = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medi
     *        um))
              Bmax = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,m
     *        edium))
            ELSE
              aux2 = log(delta+dl6(l,medium))
              Amax = dl4(l,medium)+dl5(l,medium)*aux2
              Bmax = dl4(l1,medium)+dl5(l1,medium)*aux2
            END IF
            aux1 = 1 - rmt2/eig
            aux1 = aux1*aux1
            aux1 = aux1*Amax/3
            aux1 = aux1/(Bmax+aux1)
          ELSE
            L = 7
            Amax = dl1(l,medium)
            Bmax = dl1(l+1,medium)
            aux1 = bpar(2,medium)*(1-bpar(1,medium)*rm/eig)
          END IF
          del0 = eig*delcm(medium)
          Eavail = eig - rmt2
12971     CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            RNNO30 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rng_seed .GT. 128))call ranmar_get
            RNNO31 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rng_seed .GT. 128))call ranmar_get
            RNNO34 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF (( rnno30 .GT. aux1 )) THEN
              br = 0.5*rnno31
              rejmax = Bmax
              l1 = l+1
            ELSE
              IF((rng_seed .GT. 128))call ranmar_get
              rnno32 = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF((rng_seed .GT. 128))call ranmar_get
              rnno33 = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              br = 0.5*(1-max(rnno31,rnno32,rnno33))
              rejmax = Amax
              l1 = l
            END IF
            Eminus = br*Eavail + rm
            Eplus = eig - Eminus
            delta = del0/(Eminus*Eplus)
            IF (( delta .LT. 1 )) THEN
              rejf = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,m
     *        edium))
            ELSE
              rejf = dl4(l1,medium)+dl5(l1,medium)*log(delta+dl6(l1,medi
     *        um))
            END IF
            IF((( rnno34*rejmax .LE. rejf )))GO TO12972
          GO TO 12971
12972     CONTINUE
          pese2 = Eminus
          pese1 = peig - pese2
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO34 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF (( rnno34 .LT. 0.5 )) THEN
            iq1 = -1
            iq2 = 1
          ELSE
            iq1 = 1
            iq2 = -1
          END IF
        END IF
      END IF
      ESE2=PESE2
      E(NP)=PESE1
      E(NP+1)=PESE2
      IF (( iprdst .GT. 0 )) THEN
        IF (( iprdst .EQ. 4 )) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          rtest = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          gbeta = PESE1/(PESE1+10)
          IF (( rtest .LT. gbeta )) THEN
            iprdst_use = 1
          ELSE
            iprdst_use = 4
          END IF
        ELSE IF(( iprdst .EQ. 2 .AND. eig .LT. 4.14 )) THEN
          iprdst_use = 1
        ELSE
          iprdst_use = iprdst
        END IF
        DO 12981 ichrg=1,2
          IF ((ICHRG.EQ.1)) THEN
            ESE=PESE1
          ELSE
            ESE=ESE2
            IF (( iprdst .EQ. 4 )) THEN
              gbeta = ESE/(ESE+10)
              IF((rng_seed .GT. 128))call ranmar_get
              rtest = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rtest .LT. gbeta )) THEN
                iprdst_use = 1
              ELSE
                iprdst_use = 4
              END IF
            END IF
          END IF
          IF (( iprdst_use .EQ. 1 )) THEN
            PSE=SQRT(MAX(0.0,(ESE-RM)*(ESE+RM)))
            IF((rng_seed .GT. 128))call ranmar_get
            COSTHE = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            COSTHE=1.0-2.0*COSTHE
            SINTHE=RM*SQRT((1.0-COSTHE)*(1.0+COSTHE))/(PSE*COSTHE+ESE)
            COSTHE=(ESE*COSTHE+PSE)/(PSE*COSTHE+ESE)
          ELSE IF(( iprdst_use .EQ. 2 )) THEN
            ZTARG=ZBRANG(MEDIUM)
            TTEIG=EIG/RM
            TTESE=ESE/RM
            TTPSE=SQRT((TTESE-1.0)*(TTESE+1.0))
            ESEDEI=TTESE/(TTEIG-TTESE)
            ESEDER=1.0/ESEDEI
            XIMIN=1.0/(1.0+(3.141593*TTESE)**2)
            REJMIN = 2.0+3.0*(ESEDEI+ESEDER) - 4.00*(ESEDEI+ESEDER+1.0-4
     *      .0*(XIMIN-0.5)**2)*( 1.0+0.25*LOG( ((1.0+ESEDER)*(1.0+ESEDEI
     *      )/(2.*TTEIG))**2+ZTARG*XIMIN**2 ) )
            YA=(2.0/TTEIG)**2
            XITRY=MAX(0.01,MAX(XIMIN,MIN(0.5,SQRT(YA/ZTARG))))
            GALPHA=1.0+0.25*LOG(YA+ZTARG*XITRY**2)
            GBETA=0.5*ZTARG*XITRY/(YA+ZTARG*XITRY**2)
            GALPHA=GALPHA-GBETA*(XITRY-0.5)
            XIMID=GALPHA/(3.0*GBETA)
            IF ((GALPHA.GE.0.0)) THEN
              XIMID=0.5-XIMID+SQRT(XIMID**2+0.25)
            ELSE
              XIMID=0.5-XIMID-SQRT(XIMID**2+0.25)
            END IF
            XIMID=MAX(0.01,MAX(XIMIN,MIN(0.5,XIMID)))
            REJMID = 2.0+3.0*(ESEDEI+ESEDER) - 4.00*(ESEDEI+ESEDER+1.0-4
     *      .0*(XIMID-0.5)**2)*( 1.0+0.25*LOG( ((1.0+ESEDER)*(1.0+ESEDEI
     *      )/(2.*TTEIG))**2+ZTARG*XIMID**2 ) )
            REJTOP=1.02*MAX(REJMIN,REJMID)
12991       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              XITST = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              REJTST = 2.0+3.0*(ESEDEI+ESEDER) - 4.00*(ESEDEI+ESEDER+1.0
     *        -4.0*(XITST-0.5)**2)*( 1.0+0.25*LOG( ((1.0+ESEDER)*(1.0+ES
     *        EDEI)/(2.*TTEIG))**2+ZTARG*XITST**2 ) )
              IF((rng_seed .GT. 128))call ranmar_get
              RTEST = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              THETA=SQRT(1.0/XITST-1.0)/TTESE
              REJTST_on_REJTOP = REJTST/REJTOP
              IF((((RTEST .LE. REJTST_on_REJTOP) .AND. (THETA .LT. PI) )
     *        ))GO TO12992
            GO TO 12991
12992       CONTINUE
            SINTHE=SIN(THETA)
            COSTHE=COS(THETA)
          ELSE IF(( iprdst_use .EQ. 3 )) THEN
            IF((rng_seed .GT. 128))call ranmar_get
            COSTHE = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            COSTHE=1.0-2.0*COSTHE
            sinthe=(1-costhe)*(1+costhe)
            IF (( sinthe .GT. 0 )) THEN
              sinthe = sqrt(sinthe)
            ELSE
              sinthe = 0
            END IF
          ELSE
            IF((rng_seed .GT. 128))call ranmar_get
            costhe = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            costhe=1-2*sqrt(costhe)
            sinthe=(1-costhe)*(1+costhe)
            IF (( sinthe .GT. 0 )) THEN
              sinthe=sqrt(sinthe)
            ELSE
              sinthe=0
            END IF
          END IF
          IF (( ichrg .EQ. 1 )) THEN
            CALL UPHI(2,1)
          ELSE
            sinthe=-sinthe
            NP=NP+1
            CALL UPHI(3,2)
          END IF
12981   CONTINUE
12982   CONTINUE
        iq(np) = iq2
        iq(np-1) = iq1
        return
      ELSE
        THETA=0
      END IF
      CALL UPHI(1,1)
      NP=NP+1
      SINTHE=-SINTHE
      CALL UPHI(3,2)
      IQ(NP)=iq2
      IQ(NP-1)=iq1
      RETURN
      END
      subroutine sample_triplet
      implicit none
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/USERVR/ CEXPTR,GWAIT(150),DUMU,NP_INC(150),MAFORC,IFORCE,NF
     *MIN,NFMAX,NFTIME, ISOURC,IFPB,IQINC,MONOEN,IRODUM,IRNDUM,MEDDUM,ID
     *UM,MEDTMP, PATHL,DELTAP,GWTOLD,EPSLON,ARG
      real*8 CEXPTR,GWAIT,DUMU,PATHL,DELTAP,GWTOLD,EPSLON,ARG
      integer*4 NP_INC,MAFORC,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQIN
     *C, MONOEN,IRODUM,IRNDUM,MEDDUM,IDUM,MEDTMP
      COMMON/USERRR/
     *              CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,
     *                            EKETST,ELKETS,ZL,RL,CDIST,IGEOM,IRANGE
     *,MINZ,MAXZ,MINR,MAXR,IREJCT
      real*8 CRANGE,ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,EKETST,ELKETS
     *,ZL,RL,CDIST
      integer*4 MINZ,MAXZ,MINR,MAXR
      integer*4 IREJCT,IRANGE,IGEOM
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 fmax_array(250), eta_p_array(250), eta_Ep_array(250), eta_c
     *ostp_array(250), eta_costm_array(250), ebin_array(250), wp_array(2
     *50), qmin_array(250)
      real*8 kmin, kmax, dlogki, alogkm, prmi, tiny_eta
      real*8 ai,rnno,k,qmin,qmax,aux,a1,a2,a3,D,px1,px2,pp_min,pp_max, E
     *p_min,Ep_max,k2p2,k2p2x,peig,b,aux1,aux12,D1,aux3,xmin,xmax, aux6,
     *aux7,uu,cphi,sphi,cphi_factor,aux5,phi,tmp
      real*8 Er,pr,pr2,eta_pr
      real*8 Ep,pp,pp2,wEp,cost_p,sint_p,eta_Ep,mup_min,wmup, eta_costp,
     *Epp,pp_sintp,pp_sntp2
      real*8 Em,pm,pm2,cost_m,sint_m,Emm,wmum,pm_sintm, eta_costm
      real*8 k2,k3,s2,s3,k2k3i,k22,k32,q2,aux4,S_1,S_2,sigma
      real*8 ppx, ppy, ppz, pmx, pmy, pmz, prx, pry, prz, a,c,sindel,cos
     *del,sinpsi
      integer*4 i
      logical use_it
      integer*4 iscore
      logical is_initialized
      data is_initialized/.false./
      save is_initialized,fmax_array,eta_p_array,eta_Ep_array,eta_costp_
     *array, eta_costm_array,ebin_array,wp_array,qmin_array, kmin,kmax,d
     *logki,alogkm,prmi,tiny_eta
      IF (( .NOT.is_initialized )) THEN
        is_initialized = .true.
        tiny_eta = 1e-6
        DO 13001 i=1,250
          fmax_array(i) = -1
13001   CONTINUE
13002   CONTINUE
        kmax = 0
        kmin = 4.1*prm
        DO 13011 i=1,nmed
          IF((up(i) .GT. kmax))kmax = UP(i)
13011   CONTINUE
13012   CONTINUE
        IF((kmax .LE. kmin))return
        dlogki = 250 - 1
        dlogki = dlogki/log(kmax/kmin)
        alogkm = 1 - dlogki*log(kmin)
        prmi = 1/prm
        DO 13021 i=1,250
          k = 4.1*exp((i-1.)/dlogki)
          ebin_array(i) = k
          qmin = 4*k/(k*(k-1)+(k+1)*sqrt(k*(k-4)))
          qmax = (k*(k-1) + (k+1)*sqrt(k*(k-4)))/(2*k+1)
          qmin_array(i) = qmin
          wp_array(i) = log(qmax/qmin)
13021   CONTINUE
13022   CONTINUE
      END IF
      peig = e(np)
      IF((peig .LE. 4*prm))return
      IF (( np+2 .GT. 150 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','sample_tripl
     *et', ' stack size exceeded! ',' $MAXSTACK = ',150,' np = ',np+2
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( peig .LE. kmin )) THEN
        i = 1
      ELSE IF(( peig .GE. kmax )) THEN
        i = 250
      ELSE
        ai = alogkm + dlogki*gle
        i = ai
        ai = ai - i
        IF((rng_seed .GT. 128))call ranmar_get
        rnno = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( rnno .LT. ai )) THEN
          i = i+1
        END IF
      END IF
      k = ebin_array(i)
13030 CONTINUE
      IF((rng_seed .GT. 128))call ranmar_get
      eta_pr = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((eta_pr .LT. tiny_eta))eta_pr = tiny_eta
      pr = qmin_array(i)*exp(eta_pr*wp_array(i))
      pr2 = pr*pr
      Er = sqrt(1+pr2)
      aux = Er-pr-1
      a1=(k-pr)*(1-Er-k*aux)
      a2=1+k-Er
      a3=1/(aux*(pr+Er-2*k-1))
      D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2))
      px1 = (a1 + D)*a3
      px2 = (a1 - D)*a3
      IF (( px1 .LT. px2 )) THEN
        pp_min = px1
        pp_max = px2
      ELSE
        pp_min = px2
        pp_max = px1
      END IF
      Ep_min = sqrt(1 + pp_min*pp_min)
      Ep_max = sqrt(1 + pp_max*pp_max)
      IF((rng_seed .GT. 128))call ranmar_get
      eta_Ep = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((eta_Ep .LT. tiny_eta))eta_Ep = tiny_eta
      wEp = Ep_max - Ep_min
      Ep = Ep_min + eta_Ep*wEp
      pp2 = Ep*Ep - 1
      pp = sqrt(pp2)
      k2p2 = k*k + pp2
      Em = k + 1 - Er - Ep
      pm2 = Em*Em-1
      pm = sqrt(pm2)
      mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp)
      IF((rng_seed .GT. 128))call ranmar_get
      eta_costp = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((eta_costp .LT. tiny_eta))eta_costp = tiny_eta
      Epp = Ep/pp
      wmup = log((Epp-1)/(Epp-mup_min))
      cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp)
      wmup = wmup*(cost_p - Epp)
      sint_p = 1-cost_p*cost_p
      IF (( sint_p .GT. 1e-20 )) THEN
        sint_p = sqrt(sint_p)
      ELSE
        sint_p = 1e-10
      END IF
      k2p2x = k2p2 - 2*k*pp*cost_p
      b = pr2-k2p2x-pm2
      aux1 = k - pp*cost_p
      aux12 = aux1*aux1
      pp_sintp = pp*sint_p
      pp_sntp2 = pp_sintp*pp_sintp
      D1 = pm2*(aux12+pp_sntp2)-b*b/4
      IF (( D1 .LE. 0 )) THEN
        goto 13030
      END IF
      D = 2*pp_sintp*sqrt(D1)
      aux3 = 0.5/(aux12+pp_sntp2)
      xmin = (-b*aux1-D)*aux3
      xmax = (-b*aux1+D)*aux3
      IF((rng_seed .GT. 128))call ranmar_get
      eta_costm = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((eta_costm .LT. tiny_eta))eta_costm = tiny_eta
      aux6 = sqrt((Em-xmin)/(Em-xmax))
      aux7 = aux6*tan(1.570796326794897*eta_costm)
      uu = (aux7-1)/(aux7+1)
      cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))
      wmum = sqrt((xmax-cost_m)*(cost_m-xmin))
      wmum = wmum*aux6*(Em-cost_m)/(Em-xmin)
      cost_m = cost_m/pm
      sint_m = sqrt(1-cost_m*cost_m)
      pm_sintm = pm*sint_m
      cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm)
      IF (( abs(cphi) .GE. 1 )) THEN
        goto 13030
      END IF
      sphi = sqrt(1-cphi*cphi)
      k3 = k*(pp*cost_p - Ep)
      k2 = k*(pm*cost_m - Em)
      k22 = k2*k2
      k32 = k3*k3
      k2k3i = 1/(k2*k3)
      s2 = pp*pm*(cost_p*cost_m + sint_p*sint_m*cphi) - Ep*Em
      s3 = k2 - Em + 1 - s2
      q2 = 2*(Er-1)
      S_1 = k32+k22+(q2-2)*s2-(1-q2/2)*(k32+k22)*k2k3i
      aux4 = k3*Ep-k2*Em
      S_2 = -q2*(Ep*Ep+Em*Em) + 2*s2 - (2*aux4*aux4 - k22 - k32)*k2k3i
      sigma = abs(pp*pm2*pm*k2k3i/(q2*q2*(Em*s3+Er))*(S_1*(1-q2/4)+S_2*(
     *1+q2/4)))
      cphi_factor = abs(2*Er*pm2-Em*(k2p2x-pr2-pm2))/(2*pp_sintp*pm_sint
     *m*pm2*sphi)
      sigma = sigma*cphi_factor*wEp*wmup*wmum*wp_array(i)*pr2/Er
      IF (( sigma .LT. 0 )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) 'In triplet sigma < 0 ? ',sigma
      END IF
      use_it = .true.
      IF (( sigma .LT. fmax_array(i) )) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        rnno = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( sigma .LT. fmax_array(i)*rnno )) THEN
          use_it = .false.
        END IF
      END IF
      IF (( use_it )) THEN
        fmax_array(i) = sigma
        eta_p_array(i) = eta_pr
        eta_Ep_array(i) = eta_Ep
        eta_costp_array(i) = eta_costp
        eta_costm_array(i) = eta_costm
      ELSE
        eta_pr = eta_p_array(i)
        eta_Ep = eta_Ep_array(i)
        eta_costp = eta_costp_array(i)
        eta_costm = eta_costm_array(i)
      END IF
      k = peig*prmi
      aux5 = k*(k-1)+(k+1)*sqrt(k*(k-4))
      qmin = 4*k/aux5
      qmax = aux5/(2*k+1)
      pr = qmin*exp(eta_pr*log(qmax/qmin))
      pr2 = pr*pr
      Er = sqrt(1+pr2)
      aux = Er-pr-1
      a1=(k-pr)*(1-Er-k*aux)
      a2=1+k-Er
      a3=1/(aux*(pr+Er-2*k-1))
      D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2))
      px1 = (a1 + D)*a3
      px2 = (a1 - D)*a3
      IF (( px1 .LT. px2 )) THEN
        pp_min = px1
        pp_max = px2
      ELSE
        pp_min = px2
        pp_max = px1
      END IF
      Ep_min = sqrt(1 + pp_min*pp_min)
      Ep_max = sqrt(1 + pp_max*pp_max)
      wEp = Ep_max - Ep_min
      Ep = Ep_min + eta_Ep*wEp
      pp2 = Ep*Ep - 1
      pp = sqrt(pp2)
      k2p2 = k*k + pp2
      Em = k + 1 - Er - Ep
      pm2 = Em*Em-1
      pm = sqrt(pm2)
      mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp)
      Epp = Ep/pp
      wmup = log((Epp-1)/(Epp-mup_min))
      cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp)
      sint_p = sqrt(1-cost_p*cost_p)
      k2p2x = k2p2 - 2*k*pp*cost_p
      b = pr2-k2p2x-pm2
      aux1 = k - pp*cost_p
      aux12 = aux1*aux1
      pp_sintp = pp*sint_p
      pp_sntp2 = pp_sintp*pp_sintp
      D1 = pm2*(aux12+pp_sntp2)-b*b/4
      IF (( D1 .LE. 0 )) THEN
        goto 13030
      END IF
      D = 2*pp_sintp*sqrt(D1)
      aux3 = 0.5/(aux12+pp_sntp2)
      xmin = (-b*aux1-D)*aux3
      xmax = (-b*aux1+D)*aux3
      aux6 = sqrt((Em-xmin)/(Em-xmax))
      aux7 = aux6*tan(1.570796326794897*eta_costm)
      uu = (aux7-1)/(aux7+1)
      cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))/pm
      sint_m = sqrt(1-cost_m*cost_m)
      pm_sintm = pm*sint_m
      cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm)
      IF (( abs(cphi) .GE. 1 )) THEN
        goto 13030
      END IF
      sphi = sqrt(1-cphi*cphi)
      IF((rng_seed .GT. 128))call ranmar_get
      phi = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      phi = phi*6.283185307179586
      ppx = pp*sint_p
      ppy = 0
      pmx = pm*sint_m*cphi
      pmy = pm*sint_m*sphi
      cphi = cos(phi)
      sphi = sin(phi)
      tmp = ppx*sphi
      ppx = ppx*cphi - ppy*sphi
      ppy = tmp + ppy*cphi
      tmp = pmx*sphi
      pmx = pmx*cphi - pmy*sphi
      pmy = tmp + pmy*cphi
      ppz = pp*cost_p
      pmz = pm*cost_m
      prx = -ppx-pmx
      pry = -ppy-pmy
      prz = k - ppz - pmz
      NPold = np
      X(np)=X(np)
      Y(np)=Y(np)
      Z(np)=Z(np)
      IR(np)=IR(np)
      WT(np)=WT(np)
      DNEAR(np)=DNEAR(np)
      LATCH(np)=LATCH(np)
      X(np+1)=X(np)
      Y(np+1)=Y(np)
      Z(np+1)=Z(np)
      IR(np+1)=IR(np)
      WT(np+1)=WT(np)
      DNEAR(np+1)=DNEAR(np)
      LATCH(np+1)=LATCH(np)
      X(np+2)=X(np+1)
      Y(np+2)=Y(np+1)
      Z(np+2)=Z(np+1)
      IR(np+2)=IR(np+1)
      WT(np+2)=WT(np+1)
      DNEAR(np+2)=DNEAR(np+1)
      LATCH(np+2)=LATCH(np+1)
      pp = 1/pp
      pm = 1/pm
      pr = 1/pr
      a = u(np)
      b = v(np)
      c = w(np)
      sinpsi = a*a + b*b
      IF (( sinpsi .GT. 1e-20 )) THEN
        sinpsi = sqrt(sinpsi)
        sindel = b/sinpsi
        cosdel = a/sinpsi
        IF (( Ep .GT. Em )) THEN
          u(np) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz)
          v(np) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz)
          w(np) = pp*(c*ppz - sinpsi*ppx)
          iq(np) = 1
          E(np) = Ep*prm
          u(np+1) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz)
          v(np+1) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz)
          w(np+1) = pm*(c*pmz - sinpsi*pmx)
          iq(np+1) = -1
          E(np+1) = Em*prm
        ELSE
          u(np+1) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz)
          v(np+1) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz)
          w(np+1) = pp*(c*ppz - sinpsi*ppx)
          iq(np+1) = 1
          E(np+1) = Ep*prm
          u(np) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz)
          v(np) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz)
          w(np) = pm*(c*pmz - sinpsi*pmx)
          iq(np) = -1
          E(np) = Em*prm
        END IF
        np = np + 2
        u(np) = pr*(c*cosdel*prx - sindel*pry + a*prz)
        v(np) = pr*(c*sindel*prx + cosdel*pry + b*prz)
        w(np) = pr*(c*prz - sinpsi*prx)
        iq(np) = -1
        E(np) = Er*prm
      ELSE
        IF (( Ep .GT. Em )) THEN
          u(np) = pp*ppx
          v(np) = pp*ppy
          w(np) = c*pp*ppz
          iq(np) = 1
          E(np) = Ep*prm
          u(np+1) = pm*pmx
          v(np+1) = pm*pmy
          w(np+1) = c*pm*pmz
          iq(np+1) = -1
          E(np+1) = Em*prm
        ELSE
          u(np+1) = pp*ppx
          v(np+1) = pp*ppy
          w(np+1) = c*pp*ppz
          iq(np+1) = 1
          E(np+1) = Ep*prm
          u(np) = pm*pmx
          v(np) = pm*pmy
          w(np) = c*pm*pmz
          iq(np) = -1
          E(np) = Em*prm
        END IF
        np = np + 2
        u(np) = pr*prx
        v(np) = pr*pry
        w(np) = c*pr*prz
        iq(np) = -1
        E(np) = Er*prm
      END IF
      return
      end
      SUBROUTINE PHOTO
      implicit none
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(6), GE0(6),GE1(6), GMFP0(2000,6),GMFP1(2000,
     *6),GBR10(2000,6),GBR11(2000,6),GBR20(2000,6),GBR21(2000,6), RCO0(6
     *),RCO1(6), RSCT0(100,6),RSCT1(100,6), COHE0(2000,6),COHE1(2000,6),
     *  PHOTONUC0(2000,6),PHOTONUC1(2000,6), DPMFP, MPGEM(1,6), NGR(6)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      real*8 EELEC,  BETA,  GAMMA,  ALPHA,  RATIO,  RNPHT,  FKAPPA, XI,
     * SINTH2, RNPHT2
      DOUBLE PRECISION PEIG
      real*8 BR,  sigma,  aux,aux1,  probs(50),  sigtot,  e_vac,  rnno_R
     *R
      integer*4 IARG,  iZ,   irl,  ints(50),  j,ip,  n_warning,  k
      logical do_relax
      save n_warning
      data n_warning/0/
      IF (( mcdf_pe_xsections )) THEN
        call egs_shellwise_photo()
        return
      END IF
      NPold = NP
      PEIG=E(NP)
      irl = ir(np)
      IF (( peig .LT. edge_energies(2,1) )) THEN
        IF (( n_warning .LT. 100 )) THEN
          n_warning = n_warning + 1
          write(i_log,*) ' Subroutine PHOTO called with E = ',peig, ' wh
     *ich is below the current min. energy of 1 keV! '
          write(i_log,*) ' Converting now this photon to an electron, '
          write(i_log,*) ' but you should check your code! '
        END IF
        iq(np) = -1
        e(np) = peig + prm
        return
      END IF
      iZ = iedgfl(irl)
      do_relax = .false.
      edep = pzero
      IF (( iedgfl(irl) .NE. 0 )) THEN
        IF (( nne(medium) .EQ. 1 )) THEN
          iZ = int( zelem(medium,1) + 0.5 )
          DO 13041 j=1,edge_number(iZ)
            IF((peig .GE. edge_energies(j,iZ)))GO TO13042
13041     CONTINUE
13042     CONTINUE
        ELSE
          aux = peig*peig
          aux1 = aux*peig
          aux = aux*Sqrt(peig)
          sigtot = 0
          DO 13051 k=1,nne(medium)
            iZ = int( zelem(medium,k) + 0.5 )
            IF (( iZ .LT. 1 .OR. iZ .GT. 100 )) THEN
              write(i_log,*) ' Error in PHOTO: '
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) '   Atomic number of element ',k, ' in medi
     *um ',medium,' is not between 1 and ',100
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            IF (( peig .GT. edge_energies(1,iZ) )) THEN
              j = 1
              sigma = (edge_a(1,iZ) + edge_b(1,iZ)/peig + edge_c(1,iZ)/a
     *        ux + edge_d(1,iZ)/aux1)/peig
            ELSE
              DO 13061 j=2,edge_number(iZ)
                IF((peig .GE. edge_energies(j,iZ)))GO TO13062
13061         CONTINUE
13062         CONTINUE
              sigma = edge_a(j,iZ) + gle*(edge_b(j,iZ) + gle*(edge_c(j,i
     *        Z) + gle*edge_d(j,iZ) ))
              sigma = Exp(sigma)
            END IF
            sigma = sigma * pz(medium,k)
            sigtot = sigtot + sigma
            probs(k) = sigma
            ints(k) = j
13051     CONTINUE
13052     CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          br = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          br = br*sigtot
          DO 13071 k=1,nne(medium)
            br = br - probs(k)
            IF((br .LE. 0))GO TO13072
13071     CONTINUE
13072     CONTINUE
          iZ = int( zelem(medium,k) + 0.5 )
          j = ints(k)
        END IF
        IF (( peig .LE. binding_energies(6,iZ) )) THEN
          iq(np) = -1
          e(np) = peig + prm
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          br = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          DO 13081 k=1,5
            IF (( peig .GT. binding_energies(k,iZ) )) THEN
              IF((br .LT. interaction_prob(k,iZ)))GO TO13082
              br = (br - interaction_prob(k,iZ))/(1-interaction_prob(k,i
     *        Z))
            END IF
13081     CONTINUE
13082     CONTINUE
          IF ((eadl_relax .AND. k .GT. 4)) THEN
            iq(np) = -1
            e(np) = peig + prm
          ELSE
            e_vac = binding_energies(k,iZ)
            e(np) = peig - e_vac + prm
            do_relax = .true.
            iq(np) = -1
          END IF
        END IF
      ELSE
        e(np) = peig + prm
        iq(np) = -1
      END IF
      IF (( iq(np) .EQ. -1 )) THEN
        IF ((IPHTER(IR(NP)).EQ.1)) THEN
          EELEC=E(NP)
          IF ((EELEC.GT.ECUT(IR(NP)))) THEN
            BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC
            GAMMA=EELEC/RM
            ALPHA=0.5*GAMMA-0.5+1./GAMMA
            RATIO=BETA/ALPHA
13091       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              RNPHT = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              RNPHT=2.*RNPHT-1.
              IF ((RATIO.LE.0.2)) THEN
                FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT)
                IF (( gamma .LT. 100 )) THEN
                  COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                ELSE
                  IF (( fkappa .GT. 0 )) THEN
                    costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gam
     *              ma-1)**3)
                  ELSE
                    COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                  END IF
                END IF
                xi = (1+beta*fkappa)*gamma*gamma
              ELSE
                XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO)
     *          )-1.))
                COSTHE=(1.-1./XI)/BETA
              END IF
              SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE))
              IF((rng_seed .GT. 128))call ranmar_get
              RNPHT2 = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF(RNPHT2.LE.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA)GO TO13092
            GO TO 13091
13092       CONTINUE
            SINTHE=SQRT(SINTH2)
            CALL UPHI(2,1)
          END IF
        END IF
      END IF
      IF (( do_relax )) THEN
        call relax(e_vac,k,iZ)
      END IF
      IF (( EDEP .GT. 0 )) THEN
        IARG=4
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,13100)prob_RR
13100       FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold
13111     CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF((rng_seed .GT. 128))call ranmar_get
              rnno_RR = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO13112
          GO TO 13111
13112     CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
      end
      subroutine egs_shellwise_photo
      implicit none
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(6), GE0(6),GE1(6), GMFP0(2000,6),GMFP1(2000,
     *6),GBR10(2000,6),GBR11(2000,6),GBR20(2000,6),GBR21(2000,6), RCO0(6
     *),RCO1(6), RSCT0(100,6),RSCT1(100,6), COHE0(2000,6),COHE1(2000,6),
     *  PHOTONUC0(2000,6),PHOTONUC1(2000,6), DPMFP, MPGEM(1,6), NGR(6)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,6),   pe_energy(500,100),  pe_zsorted(100,6), pe_be(100,16),
     * pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      real*8 pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      real*8 EELEC,  BETA,  GAMMA,  ALPHA,  RATIO,  RNPHT,  FKAPPA, XI,
     * SINTH2, RNPHT2
      DOUBLE PRECISION PEIG
      real*8 BR,  sigma,  aux,aux1,  probs(50),  sigtot,  e_vac,  rnno_R
     *R
      integer*4 IARG,  iZ,   irl,  ints(50),  j,ip,  n_warning,  k
      logical do_relax
      save n_warning
      real*8 slope, logE, int_prob
      integer*4 zpos, ibsearch
      data n_warning/0/
      NPold = NP
      PEIG=E(NP)
      irl = ir(np)
      do_relax = .false.
      IF (( peig .LT. 0.001 )) THEN
        IF (( n_warning .LT. 100 )) THEN
          n_warning = n_warning + 1
          write(i_log,*) ' Subroutine egs_shellwise_photo called with E
     *= ', peig,' which is below the current min. energy of ', 0.001,' k
     *eV! '
          write(i_log,*) ' Converting now this photon to an electron, '
          write(i_log,*) ' but you should check your code! '
        END IF
        iq(np) = -1
        e(np) = peig + prm
        return
      END IF
      edep = pzero
      IF (( iedgfl(irl) .NE. 0 )) THEN
        j = -1
        IF (( nne(medium) .EQ. 1 )) THEN
          iZ = int( zelem(medium,1) + 0.5 )
          zpos = pe_zpos(iZ)
          IF (( pe_nshell(zpos) .GT. 0)) THEN
            logE = log(peig)
            j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos))
          END IF
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          br = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          logE = log(peig)
          DO 13121 k=nne(medium),1,-1
            iZ = int( zelem(medium,k) + 0.5 )
            zpos = pe_zpos(iZ)
            IF (( iZ .LT. 1 .OR. iZ .GT. 100 )) THEN
              write(i_log,*) ' Error in egs_shellwise_photo: '
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) '   Atomic number of element ',k, ' in medi
     *um ',medium,' is not between 1 and ',100
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos))
            slope = pe_elem_prob(j+1,k,medium) - pe_elem_prob(j,k,medium
     *      )
            slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos))
            int_prob = pe_elem_prob(j,k,medium)+slope*(logE-pe_energy(j,
     *      zpos))
            br = br - exp(int_prob)
            IF((br .LE. 0))GO TO13122
13121     CONTINUE
13122     CONTINUE
        END IF
        IF (( peig .LT. pe_be(zpos,pe_nshell(zpos)) .OR. pe_nshell(zpos)
     *   .EQ. 0 )) THEN
          iq(np) = -1
          e(np) = peig + prm
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          br = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          sigtot = 0
          DO 13131 k=1,pe_nshell(zpos)
            IF (( peig .GT. pe_be(zpos,k) )) THEN
              slope = pe_xsection(j+1,zpos,k) - pe_xsection(j,zpos,k)
              slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos))
              int_prob=pe_xsection(j,zpos,k)+slope*(logE-pe_energy(j,zpo
     *        s))
              br = br - exp(int_prob)
              sigtot = sigtot + exp(int_prob)
              IF((br .LE. 0))GO TO13132
            END IF
13131     CONTINUE
13132     CONTINUE
          IF ((k .GT. pe_nshell(zpos))) THEN
            iq(np) = -1
            e(np) = peig + prm
          ELSE
            e_vac = pe_be(zpos,k)
            e(np) = peig - e_vac + prm
            do_relax = .true.
            iq(np) = -1
          END IF
        END IF
      ELSE
        e(np) = peig + prm
        iq(np) = -1
      END IF
      IF (( iq(np) .EQ. -1 )) THEN
        IF ((IPHTER(IR(NP)).EQ.1)) THEN
          EELEC=E(NP)
          IF ((EELEC.GT.ECUT(IR(NP)))) THEN
            BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC
            GAMMA=EELEC/RM
            ALPHA=0.5*GAMMA-0.5+1./GAMMA
            RATIO=BETA/ALPHA
13141       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              RNPHT = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              RNPHT=2.*RNPHT-1.
              IF ((RATIO.LE.0.2)) THEN
                FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT)
                IF (( gamma .LT. 100 )) THEN
                  COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                ELSE
                  IF (( fkappa .GT. 0 )) THEN
                    costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gam
     *              ma-1)**3)
                  ELSE
                    COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                  END IF
                END IF
                xi = (1+beta*fkappa)*gamma*gamma
              ELSE
                XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO)
     *          )-1.))
                COSTHE=(1.-1./XI)/BETA
              END IF
              SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE))
              IF((rng_seed .GT. 128))call ranmar_get
              RNPHT2 = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF(RNPHT2.LE.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA)GO TO13142
            GO TO 13141
13142       CONTINUE
            SINTHE=SQRT(SINTH2)
            CALL UPHI(2,1)
          END IF
        END IF
      END IF
      IF (( do_relax )) THEN
        call egs_eadl_relax(iZ,k)
      END IF
      IF (( EDEP .GT. 0 )) THEN
        IARG=4
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,13150)prob_RR
13150       FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold
13161     CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF((rng_seed .GT. 128))call ranmar_get
              rnno_RR = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO13162
          GO TO 13161
13162     CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
      end
      subroutine egs_read_shellwise_pe
      implicit none
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(6), GE0(6),GE1(6), GMFP0(2000,6),GMFP1(2000,
     *6),GBR10(2000,6),GBR11(2000,6),GBR20(2000,6),GBR21(2000,6), RCO0(6
     *),RCO1(6), RSCT0(100,6),RSCT1(100,6), COHE0(2000,6),COHE1(2000,6),
     *  PHOTONUC0(2000,6),PHOTONUC1(2000,6), DPMFP, MPGEM(1,6), NGR(6)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,6),   pe_energy(500,100),  pe_zsorted(100,6), pe_be(100,16),
     * pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      real*8 pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      integer*4 lnblnk1,egs_get_unit,pe_sw_unit,ounit,egs_open_file
      integer*4 sorted(100),i,j,k,l,m
      real*8 z_sorted(100),pz_sorted(100)
      real*8 rest_xs(500,100)
      real*8 tmp_e(500,16), tmp_xs(500,16)
      real*8 new_e(500),deltaEb,slope
      integer*4 zread(100),ib(16),ibsearch
      character data_dir*128,pe_sw_file*144
      integer*4 medio,iZ,iZpos,egs_read_int,pos,curr_rec
      real*4 egs_read_real,e_r, e_old,sigma_r
      integer*2 nz, egs_read_short,ish, i_nshell,i_nge
      logical is_open, is_there, shift_required
      character*3 labels(16)
      data labels/'  K',' L1',' L2',' L3', ' M1',' M2',' M3',' M4',' M5'
     *, ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/
      write(i_log,'(/a$)') ' Reading renormalized photoelectric cross se
     *ctions ......'
      data_dir = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      pe_sw_file = data_dir(:lnblnk1(data_dir)) // 'photo_shellwise.data
     *'
      pe_sw_unit = egs_get_unit(0)
      IF (( pe_sw_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_shellwise_pe: failed to get a free Fort
     *ran I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(pe_sw_unit,file=pe_sw_file,status='old', form='UNFORMATTED',A
     *CCESS='direct',recl=1, err=13170)
      GOTO 13180
13170 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(2a)') 'egs_init_shellwise_pe: failed to open ', pe_s
     *w_file
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
13180 is_open = .true.
      DO 13191 medio=1,nmed
        DO 13201 i=1,nne(medio)
          pe_nshell(i*medio) = 0
          pe_nge(i*medio) = 0
          pe_zsorted(i,medio) = 0
13201   CONTINUE
13202   CONTINUE
13191 CONTINUE
13192 CONTINUE
      DO 13211 l=1,100
        pe_zpos(l) = -1
        DO 13221 k=1,500
          pe_energy(k,l) = 0.0
          DO 13231 m=1,16
            pe_xsection(k,l,m) = 0.0
13231     CONTINUE
13232     CONTINUE
13221   CONTINUE
13222   CONTINUE
        DO 13241 k=1,16
          pe_be(l,k) = -99
13241   CONTINUE
13242   CONTINUE
13211 CONTINUE
13212 CONTINUE
      curr_rec = 1
      iZpos = 0
      nz = egs_read_short(pe_sw_unit,curr_rec)
      DO 13251 medio=1,nmed
        DO 13261 i=1,nne(medio)
          z_sorted(i) = zelem(medio,i)
13261   CONTINUE
13262   CONTINUE
        call egs_heap_sort(nne(medio),z_sorted,sorted)
        DO 13271 i=1,nne(medio)
          pe_zsorted(i,medio) = z_sorted(i)
13271   CONTINUE
13272   CONTINUE
        DO 13281 i=1,nne(medio)
          iZ = z_sorted(i)
          is_there = .false.
          DO 13291 j=1,medio-1
            DO 13301 k=1,nne(j)
              IF (( iZ .EQ. pe_zsorted(k,j) )) THEN
                is_there = .true.
                GO TO13302
              END IF
13301       CONTINUE
13302       CONTINUE
13291     CONTINUE
13292     CONTINUE
          IF((is_there))GO TO13281
          iZpos = iZpos + 1
          zread(iZpos) = iZ
          pe_zpos(iZ) = iZpos
          pos = 3 + (iZ-1)*4
          curr_rec = egs_read_int(pe_sw_unit,pos) + 1
          i_nge = egs_read_short(pe_sw_unit,curr_rec)
          i_nshell = egs_read_short(pe_sw_unit,curr_rec)
          pe_nge(iZpos) = i_nge
          pe_nshell(iZpos) = i_nshell
          e_old = -1.0
          ish = 0
          DO 13311 j=1,i_nge
            e_r = egs_read_real(pe_sw_unit,curr_rec)
            sigma_r = egs_read_real(pe_sw_unit,curr_rec)
            pe_energy(j,iZpos) = e_r
            pe_xsection(j,iZpos,0) = sigma_r
            rest_xs(j,iZpos) = sigma_r
            DO 13321 k=1,i_nshell
              sigma_r = egs_read_real(pe_sw_unit,curr_rec)
              pe_xsection(j,iZpos,k) = sigma_r
              rest_xs(j,iZpos) = rest_xs(j,iZpos) - sigma_r
13321       CONTINUE
13322       CONTINUE
            IF ((e_r - e_old .LT. 1e-15)) THEN
              pe_be(iZpos,i_nshell-ish) = e_r
              ish = ish + 1
            END IF
            e_old = e_r
13311     CONTINUE
13312     CONTINUE
13281   CONTINUE
13282   CONTINUE
13251 CONTINUE
13252 CONTINUE
      pe_ne = iZpos
      DO 13331 i=1,pe_ne
        iZ = zread(i)
        IF ((pe_nshell(i) .EQ. 0)) THEN
          DO 13341 j=1,pe_nge(i)
            pe_energy(j,i) = log(pe_energy(j,i))
13341     CONTINUE
13342     CONTINUE
          GO TO13331
        END IF
        DO 13351 l=1,pe_nshell(i)
          IF (( pe_be(i,l) .NE. binding_energies(l,iZ))) THEN
            shift_required = .true.
            deltaEb = binding_energies(l,iZ)-pe_be(i,l)
          ELSE
            shift_required =.false.
          END IF
          is_there = .false.
          DO 13361 j=1,pe_nge(i)
            tmp_e(j,l) = pe_energy(j,i)
            tmp_xs(j,l) = pe_xsection(j,i,l)
            IF (( shift_required .AND. pe_energy(j,i) .GE. pe_be(i,l) ))
     *       THEN
              tmp_e(j,l) = tmp_e(j,l) + deltaEb
              IF ((pe_energy(j,i) .EQ. pe_be(i,l) .AND. .NOT.is_there))
     *        THEN
                ib(l) = j
                is_there = .true.
              END IF
              IF ((l .EQ. 1)) THEN
                new_e(j) = tmp_e(j,l)
              ELSE IF((j .LT. ib(l-1))) THEN
                new_e(j) = tmp_e(j,l)
              END IF
            END IF
13361     CONTINUE
13362     CONTINUE
          pe_be(i,l) = binding_energies(l,iZ)
13351   CONTINUE
13352   CONTINUE
        DO 13371 l=2,pe_nshell(i)
          DO 13381 j=1,pe_nge(i)
            IF (( new_e(j) .GE. pe_be(i,l-1) )) THEN
              m = ibsearch(new_e(j),pe_nge(i),tmp_e(1,l))
              slope = log(tmp_xs(m+1,l)/tmp_xs(m,l))
              slope = slope/log(tmp_e(m+1,l)/tmp_e(m,l))
              pe_xsection(j,i,l) = log(tmp_xs(m,l))
              pe_xsection(j,i,l) = pe_xsection(j,i,l) + slope*log(new_e(
     *        j)/tmp_e(m,l))
              pe_xsection(j,i,l) = exp(pe_xsection(j,i,l))
            END IF
13381     CONTINUE
13382     CONTINUE
13371   CONTINUE
13372   CONTINUE
        DO 13391 j=1,pe_nge(i)
          IF (( j .LT. ib(pe_nshell(i)))) THEN
            new_e(j) = pe_energy(j,i)
          END IF
          m = ibsearch(new_e(j),pe_nge(i),pe_energy(1,i))
          slope = log(rest_xs(m+1,i)/rest_xs(m,i))
          slope = slope/log(pe_energy(m+1,i)/pe_energy(m,i))
          pe_xsection(j,i,0) = log(rest_xs(m,i))
          pe_xsection(j,i,0) = pe_xsection(j,i,0) + slope*log(new_e(j)/p
     *    e_energy(m,i))
          pe_xsection(j,i,0) = exp(pe_xsection(j,i,0))
          DO 13401 l=1,pe_nshell(i)
            pe_xsection(j,i,0) = pe_xsection(j,i,0) + pe_xsection(j,i,l)
13401     CONTINUE
13402     CONTINUE
13391   CONTINUE
13392   CONTINUE
        DO 13411 j=1,pe_nge(i)
          pe_energy(j,i) = log(new_e(j))
          DO 13421 l=1,pe_nshell(i)
            pe_xsection(j,i,l) = log(pe_xsection(j,i,l)/pe_xsection(j,i,
     *      0))
13421     CONTINUE
13422     CONTINUE
13411   CONTINUE
13412   CONTINUE
13331 CONTINUE
13332 CONTINUE
      write(i_log,'(a/)') ' done'
      IF((is_open))close(pe_sw_unit)
      return
      end
      SUBROUTINE RELAX(energy,n,iZ)
      implicit none
      integer*4 n,iZ
      real*8 energy
      integer*4 vac_array(50),  n_vac,  shell
      integer*4 final,finala,  final1,final2,   iql,  irl
      integer*4 first_transition(5), last_transition(5)
      integer*4 final_state(39)
      integer*4 k, np_old, ip, iarg
      real*8 e_array(50),  Ei,Ef,  Ex,  eta,  e_check,  min_E,ekcut,pkcu
     *t,elcut
      real*8 xphi,yphi,xphi2,yphi2,rhophi2, cphi,sphi
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common/user_relax/ u_relax,ish_relax,iZ_relax
      real*8 u_relax
      integer*4 ish_relax, iZ_relax
      data first_transition/1,20,27,33,38/
      data last_transition/19,26,32,37,39/
      data final_state/  4,3,5,6,  202,302,402,404,403,303,  502,503,504
     *,602,603,604,  505,605,606,  13,14,  5,6,  505,605,606,  14,  5,6,
     *  505,605,606,  5,6,  505,605,606,  6,  606/
      save first_transition,last_transition,final_state
      IF ((eadl_relax)) THEN
        call egs_eadl_relax(iZ,n)
        return
      END IF
      IF (( n .LT. 1 .OR. n .GT. 6 )) THEN
        return
      END IF
      iz_relax = iZ
      irl = ir(np)
      ekcut = ecut(irl)-rm
      pkcut = pcut(irl)
      min_E = 0.001
      IF (( energy .LE. min_E )) THEN
        edep = edep + energy
        edep_local = energy
        IARG=34
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
        return
      END IF
      n_vac = 1
      vac_array(n_vac) = n
      np_old = np
      e_check = 0
      e_array(n_vac) = energy
1950  CONTINUE
1951    CONTINUE
        shell = vac_array(n_vac)
        Ei = e_array(n_vac)
        n_vac = n_vac - 1
        IF (( Ei .LE. min_E )) THEN
          edep = edep + Ei
          edep_local = Ei
          IARG=34
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          IF((n_vac .GT. 0))goto 1950
          GO TO1952
        END IF
        ish_relax = shell
        u_relax = Ei
        IF (( shell .EQ. 6 )) THEN
          IF (( Ei .GT. ekcut )) THEN
            np = np + 1
            IF (( np .GT. 150 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','RELAX'
     *        , ' stack size exceeded! ',' $MAXSTACK = ',150,' np = ',np
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            e(np) = Ei + prm
            iq(np) = -1
            X(np)=X(np-1)
            Y(np)=Y(np-1)
            Z(np)=Z(np-1)
            IR(np)=IR(np-1)
            WT(np)=WT(np-1)
            DNEAR(np)=DNEAR(np-1)
            LATCH(np)=LATCH(np-1)
            IF((rng_seed .GT. 128))call ranmar_get
            eta = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            eta = 2*eta - 1
            w(np) = eta
            eta = (1-eta)*(1+eta)
            IF (( eta .GT. 1e-20 )) THEN
              eta = Sqrt(eta)
13431         CONTINUE
                IF((rng_seed .GT. 128))call ranmar_get
                xphi = rng_array(rng_seed)*twom24
                rng_seed = rng_seed + 1
                xphi = 2*xphi - 1
                xphi2 = xphi*xphi
                IF((rng_seed .GT. 128))call ranmar_get
                yphi = rng_array(rng_seed)*twom24
                rng_seed = rng_seed + 1
                yphi2 = yphi*yphi
                rhophi2 = xphi2 + yphi2
                IF(rhophi2.LE.1)GO TO13432
              GO TO 13431
13432         CONTINUE
              rhophi2 = 1/rhophi2
              cphi = (xphi2 - yphi2)*rhophi2
              sphi = 2*xphi*yphi*rhophi2
              u(np) = eta*cphi
              v(np) = eta*sphi
            ELSE
              u(np) = 0
              v(np) = 0
              w(np) = 1
            END IF
            IARG=27
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE
            edep = edep + Ei
            edep_local = Ei
            IARG=34
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          END IF
          IF((n_vac .GT. 0))goto 1950
          GO TO1952
        END IF
        IF((rng_seed .GT. 128))call ranmar_get
        eta = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        DO 13441 k=first_transition(shell),last_transition(shell)-1
          eta = eta - relaxation_prob(k,iZ)
          IF((eta .LE. 0))GO TO13442
13441   CONTINUE
13442   CONTINUE
        final = final_state(k)
        finala = final
        IF (( final .LT. 100 )) THEN
          IF (( final .LT. 10 )) THEN
            iql = 0
            elcut = pkcut
          ELSE
            final = final - 10
            iql = -1
            elcut = ekcut
          END IF
          Ef = binding_energies(final,iZ)
          Ex = Ei - Ef
          n_vac = n_vac + 1
          vac_array(n_vac) = final
          e_array(n_vac) = Ef
        ELSE
          final1 = final/100
          final2 = final - final1*100
          n_vac = n_vac + 1
          vac_array(n_vac) = final1
          e_array(n_vac) = binding_energies(final1,iZ)
          n_vac = n_vac + 1
          vac_array(n_vac) = final2
          e_array(n_vac) = binding_energies(final2,iZ)
          iql = -1
          Ex = Ei - e_array(n_vac) - e_array(n_vac-1)
          elcut = ekcut
        END IF
        IF (( Ex .LE. elcut )) THEN
          edep = edep + Ex
          IF (( finala .LT. 10 )) THEN
            edep_local = Ex
            IARG=33
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE
            edep_local = Ex
            IARG=34
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          END IF
        ELSE
          np = np + 1
          IF (( np .GT. 150 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','RELAX',
     *      ' stack size exceeded! ',' $MAXSTACK = ',150,' np = ',np
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          iq(np) = iql
          IF (( iql .EQ. 0 )) THEN
            e(np) = Ex
          ELSE
            e(np) = Ex + rm
          END IF
          X(np)=X(np-1)
          Y(np)=Y(np-1)
          Z(np)=Z(np-1)
          IR(np)=IR(np-1)
          WT(np)=WT(np-1)
          DNEAR(np)=DNEAR(np-1)
          LATCH(np)=LATCH(np-1)
          IF((rng_seed .GT. 128))call ranmar_get
          eta = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          eta = 2*eta - 1
          w(np) = eta
          eta = (1-eta)*(1+eta)
          IF (( eta .GT. 1e-20 )) THEN
            eta = Sqrt(eta)
13451       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              xphi = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              xphi = 2*xphi - 1
              xphi2 = xphi*xphi
              IF((rng_seed .GT. 128))call ranmar_get
              yphi = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              yphi2 = yphi*yphi
              rhophi2 = xphi2 + yphi2
              IF(rhophi2.LE.1)GO TO13452
            GO TO 13451
13452       CONTINUE
            rhophi2 = 1/rhophi2
            cphi = (xphi2 - yphi2)*rhophi2
            sphi = 2*xphi*yphi*rhophi2
            u(np) = eta*cphi
            v(np) = eta*sphi
          ELSE
            u(np) = 0
            v(np) = 0
            w(np) = 1
          END IF
          IF (( finala .LT. 10 )) THEN
            IARG=25
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE IF(( finala .LT. 100 )) THEN
            IARG=26
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE
            IARG=27
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          END IF
        END IF
      GO TO 1951
1952  CONTINUE
      return
      end
      subroutine egs_init_relax
      implicit none
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(6), GE0(6),GE1(6), GMFP0(2000,6),GMFP1(2000,
     *6),GBR10(2000,6),GBR11(2000,6),GBR20(2000,6),GBR21(2000,6), RCO0(6
     *),RCO1(6), RSCT0(100,6),RSCT1(100,6), COHE0(2000,6),COHE1(2000,6),
     *  PHOTONUC0(2000,6),PHOTONUC1(2000,6), DPMFP, MPGEM(1,6), NGR(6)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/shell_data/ shell_be(3000),  shell_type(3000),  shell_num(3
     *000),  shell_Z(3000),  shell_eadl(100,30),  shell_ntot
      real*8 shell_be
      integer*4 shell_type,shell_Z,shell_ntot,shell_num,shell_eadl
      integer*4 lnblnk1,egs_get_unit,relax_unit,ounit,egs_open_file
      integer*4 sorted(100),i,j,k,k1,k2,m
      real*8 z_sorted(100),pz_sorted(100)
      character data_dir*128,relax_file*144
      integer*4 ish,medio,iZ,ntran
      real*8 Ec, Pc, tmp, min_be, sumw,Ex
      logical is_open, is_there
      real*8 wtmp(300)
      integer*4 itmp(300)
      integer*4 pos, curr_rec, sh_eadl
      integer*4 nz, nshell, tr_type
      integer*4 ttype
      real*4 be_r, prob_r
      DO 13461 iZ=1,100
        DO 13471 k=1,30
          shell_eadl(iZ,k) = -1
13471   CONTINUE
13472   CONTINUE
13461 CONTINUE
13462 CONTINUE
      min_be = 0.001
      write(i_log,'(/a)') ' Reading EADL relaxation data ......'
      data_dir = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      relax_file = data_dir(:lnblnk1(data_dir)) // 'relax.data'
      relax_unit = egs_get_unit(0)
      IF (( relax_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_relax: failed to get a free Fortran I/O
     * unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(relax_unit,file=relax_file,status='old', form='UNFORMATTED',A
     *CCESS='direct',recl=4, err=13480)
      GOTO 13490
13480 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(2a)') 'egs_init_relax: failed to open ', relax_file
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
13490 is_open = .true.
      curr_rec = 1
      read(relax_unit,rec=curr_rec) nz
      shell_ntot = 0
      relax_ntot = 0
      DO 13501 medio=1,nmed
        DO 13511 i=1,nne(medio)
          z_sorted(i) = zelem(medio,i)
13511   CONTINUE
13512   CONTINUE
        call egs_heap_sort(nne(medio),z_sorted,sorted)
        DO 13521 i=1,nne(medio)
          iZ = z_sorted(i)
          is_there = .false.
          DO 13531 j=1,shell_ntot
            IF (( iZ .EQ. shell_Z(j) )) THEN
              is_there = .true.
              GO TO13532
            END IF
13531     CONTINUE
13532     CONTINUE
          IF((is_there))GO TO13521
          pos = iZ + 1
          read(relax_unit,rec=pos) curr_rec
          read(relax_unit,rec=curr_rec) nshell
          IF (( shell_ntot + nshell .GT. 3000 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a,i5,a/,a//)') ' Too many shells to fit in the
     * list: ', shell_ntot + nshell,' (at least).', ' Increase the param
     *eter $MAXSHELL and retry '
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          write(i_log,'(a,i3,a,i2,a)') '  Z = ',iZ,' has ',nshell,' shel
     *ls'
          DO 13541 ish=shell_ntot+1,shell_ntot+nshell
            curr_rec = curr_rec+1
            read(relax_unit,rec=curr_rec) shell_type(ish)
            curr_rec = curr_rec+1
            read(relax_unit,rec=curr_rec) ntran
            curr_rec = curr_rec+1
            read(relax_unit,rec=curr_rec) be_r
            shell_be(ish) = be_r
            shell_Z(ish) = iZ
            shell_num(ish) = ish - shell_ntot
            shell_eadl(iZ,shell_num(ish)) = ish
            IF ((binding_energies(shell_num(ish),iZ) .GT. 0)) THEN
              shell_be(ish) = binding_energies(shell_num(ish),iZ)
            ELSE IF(( photon_xsections .EQ. 'epdl' )) THEN
              binding_energies(shell_num(ish),iZ) = shell_be(ish)
            END IF
            DO 13551 k=1,ntran
              curr_rec = curr_rec+1
              read(relax_unit,rec=curr_rec) itmp(k)
              curr_rec = curr_rec+1
              read(relax_unit,rec=curr_rec) prob_r
              wtmp(k)=prob_r
              IF ((itmp(k).LT.64)) THEN
                itmp(k) = itmp(k) + 1
              ELSE
                itmp(k) = itmp(k) + 65
              END IF
13551       CONTINUE
13552       CONTINUE
            IF (( shell_be(ish) .LT. min_be )) THEN
              relax_first(ish) = -1
              relax_ntran(ish) = -1
            ELSE
              sumw = 0
              DO 13561 k=1,ntran
                sumw = sumw + wtmp(k)
13561         CONTINUE
13562         CONTINUE
              IF (( sumw .GT. 1 )) THEN
                DO 13571 k=1,ntran
                  wtmp(k) = wtmp(k)/sumw
13571           CONTINUE
13572           CONTINUE
              ELSE IF(( sumw .LT. 1 )) THEN
                ntran = ntran + 1
                itmp(ntran) = -1
                wtmp(ntran) = 1-sumw
              END IF
              IF (( relax_ntot + ntran .GT. 10000 )) THEN
                write(i_log,'(/a)') '***************** Error: '
                write(i_log,'(a,i5,a/,a/)') ' Too many relaxation transi
     *tions: ', relax_ntot + ntran,' (at least).', ' Increase $MAXRELAX
     *and retry '
                write(i_log,'(/a)') '***************** Quiting now.'
                call exit(1)
              END IF
              relax_first(ish) = relax_ntot+1
              relax_ntran(ish) = ntran
              call prepare_alias_histogram(ntran,wtmp, relax_atbin(relax
     *        _ntot+1))
              DO 13581 k=1,ntran
                j = relax_ntot + k
                relax_state(j) = itmp(k)
                relax_prob(j) = wtmp(k)
13581         CONTINUE
13582         CONTINUE
              relax_ntot = relax_ntot + ntran
            END IF
13541     CONTINUE
13542     CONTINUE
          shell_ntot = shell_ntot + nshell
13521   CONTINUE
13522   CONTINUE
13501 CONTINUE
13502 CONTINUE
      write(i_log,'(a/)') ' ...... Done.'
      IF((is_open))close(relax_unit)
      return
      stop
      end
      subroutine egs_eadl_relax(iZ, shell_egs)
      implicit none
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/relax_for_user/ rfu_E0,  rfu_E,  rfu_Z,  rfu_j0,  rfu_n0,
     *rfu_t0,  rfu_j,  rfu_n,  rfu_t
      integer*4 rfu_Z,rfu_j0,rfu_n0,rfu_t0,rfu_j,rfu_n,rfu_t
      real*8 rfu_E0,rfu_E
      common/shell_data/ shell_be(3000),  shell_type(3000),  shell_num(3
     *000),  shell_Z(3000),  shell_eadl(100,30),  shell_ntot
      real*8 shell_be
      integer*4 shell_type,shell_Z,shell_ntot,shell_num,shell_eadl
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common/user_relax/ u_relax,ish_relax,iZ_relax
      real*8 u_relax
      integer*4 ish_relax, iZ_relax
      real*8 Ec,Pc,min_E,rnno,Evac,Ef,Ef1,Ef2,Ex,Ecc, cost,sint,cphi,sph
     *i
      integer*4 shell, shell_egs, iZ, iarg
      integer*4 irl,vacs(100),nvac,vac,new_state,iqf,np_save,new1,new2
      integer*4 sample_alias_histogram
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      shell = shell_eadl(iZ,shell_egs)
      IF (( shell .LT. 1 .OR. shell .GT. 3000 )) THEN
        return
      END IF
      irl = ir(np)
      Ec = ecut(irl) - rm
      Pc = pcut(irl)
      min_E = 0.001
      Evac = shell_be(shell)
      rfu_Z = shell_Z(shell)
      rfu_j0 = shell
      rfu_n0 = shell_num(shell)
      rfu_t0 = shell_type(shell)
      rfu_E0 = Evac
      IF ((shell_egs .GT. 4 .AND. .NOT.mcdf_pe_xsections)) THEN
        edep = Evac
        edep_local = Evac
        IARG=34
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
        return
      END IF
      vac = shell
      Nvac = 0
      np_save = np
13591 CONTINUE
        IF (( Evac .LT. min_E .OR. relax_ntran(vac) .LT. 1 )) THEN
          edep = edep + Evac
          edep_local = Evac
          IARG=34
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          go to 13600
        END IF
        new_state = sample_alias_histogram(relax_ntran(vac), relax_prob(
     *  relax_first(vac)), relax_atbin(relax_first(vac)))
        IF (( new_state .LT. 0 )) THEN
          Ef = 0
          iqf = -1
          Ecc = Ec
        ELSE
          new_state = relax_state(relax_first(vac)+new_state-1)
          IF (( new_state .LE. 64 )) THEN
            iqf = 0
            new_state = new_state + vac - shell_num(vac)
            Ef = shell_be(new_state)
            Nvac = Nvac + 1
            vacs(Nvac) = new_state
            Ecc = Pc
          ELSE
            iqf = -1
            new1 = new_state/64
            new2 = new_state - 64*new1
            new1 = new1 + vac - shell_num(vac)
            new2 = new2 + vac - shell_num(vac)
            Ef1 = shell_be(new1)
            Ef2 = shell_be(new2)
            Nvac = Nvac + 1
            vacs(Nvac) = new1
            Nvac = Nvac + 1
            vacs(Nvac) = new2
            Ef = Ef1 + Ef2
            Ecc = Ec
          END IF
        END IF
        Ex = Evac - Ef
        edep_local = 0
        IF (( Ex .GT. Ecc )) THEN
          np = np + 1
          IF (( np .GT. 150 )) THEN
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,'(3(a,f10.6),a,i2)') 'Evac = ',Evac, ' Ef = ',Ef
     *      ,  ' min_E = ', min_E,' iq = ',iqf
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(//,3a,/,2(a,i9),/,a)') ' In subroutine ','new_
     *relax', ' stack size exceeded! ',' $MXSTACK = ',150,' np = ',np, '
     * Increase $MXSTACK and try again '
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          iq(np) = iqf
          X(np)=X(np_save)
          Y(np)=Y(np_save)
          Z(np)=Z(np_save)
          IR(np)=IR(np_save)
          WT(np)=WT(np_save)
          DNEAR(np)=DNEAR(np_save)
          LATCH(np)=LATCH(np_save)
          IF((rng_seed .GT. 128))call ranmar_get
          rnno = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          cost = 2*rnno-1
          sint = 1-cost*cost
          IF (( sint .GT. 0 )) THEN
            sint = sqrt(sint)
13611       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              xphi = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              xphi = 2*xphi - 1
              xphi2 = xphi*xphi
              IF((rng_seed .GT. 128))call ranmar_get
              yphi = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              yphi2 = yphi*yphi
              rhophi2 = xphi2 + yphi2
              IF(rhophi2.LE.1)GO TO13612
            GO TO 13611
13612       CONTINUE
            rhophi2 = 1/rhophi2
            cphi = (xphi2 - yphi2)*rhophi2
            sphi = 2*xphi*yphi*rhophi2
            u(np) = sint*cphi
            v(np) = sint*sphi
            w(np) = cost
          ELSE
            u(np) = 0
            v(np) = 0
            w(np) = cost
          END IF
          rfu_j = vac
          rfu_n = shell_num(vac)
          rfu_t = shell_type(vac)
          rfu_E = shell_be(vac)
          IF (( iqf .EQ. 0 )) THEN
            e(np) = Ex
            IARG=25
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE
            e(np) = Ex + rm
            IARG=27
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          END IF
        ELSE
          edep = edep + Ex
          IF (( iqf .EQ. 0 )) THEN
            edep_local = Ex
            IARG=33
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE
            edep_local = Ex
            IARG=34
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          END IF
        END IF
13600   CONTINUE
        IF((Nvac .EQ. 0))GO TO13592
        vac = vacs(Nvac)
        Evac = shell_be(vac)
        Nvac = Nvac - 1
      GO TO 13591
13592 CONTINUE
      return
      end
      subroutine init_triplet
      implicit none
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/triplet_data/ a_triplet(250,6), b_triplet(250,6), dl_triple
     *t, dli_triplet, bli_triplet, log_4rm
      real*8 a_triplet,b_triplet,dl_triplet, dli_triplet, bli_triplet, l
     *og_4rm
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      real*8 energies(55), sig_pair(100,55), sig_triplet(100,55), f_trip
     *let(55), sigp(55), sigt(55), as(55), bs(55), cs(55), ds(55)
      character*128 triplet_data_file
      integer*4 want_triplet_unit, triplet_unit, triplet_out
      integer*4 i, iel, imed, lnblnk1, egs_get_unit, ntrip, iz1, izi, if
     *irst
      real*8 logE, f_new, f_old, spline
      IF((itriplet .EQ. 0))return
      DO 13621 i=1,len(triplet_data_file)
        triplet_data_file(i:i) = ' '
13621 CONTINUE
13622 CONTINUE
      triplet_data_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/
     *' // 'triplet.data'
      want_triplet_unit = 63
      triplet_unit = egs_get_unit(want_triplet_unit)
      IF (( triplet_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'init_triplet: failed to get a free Fortran I/O u
     *nit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(triplet_unit,file=triplet_data_file,err=13630)
      write(i_log,'(a,$)') ' init_triplet: reading triplet data ... '
      read(triplet_unit,*) ntrip
      IF (( ntrip .GT. 55 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Max. number of data points per element is ',55
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      read(triplet_unit,*,err=13640) (energies(i),i=1,ntrip)
      DO 13651 iel=1,100
        read(triplet_unit,*)
        read(triplet_unit,*,err=13640) (sig_pair(iel,i),i=1,ntrip)
        read(triplet_unit,*,err=13640) (sig_triplet(iel,i),i=1,ntrip)
13651 CONTINUE
13652 CONTINUE
      write(i_log,*) 'OK'
      ifirst = 0
      DO 13661 i=1,ntrip
        IF((ifirst .EQ. 0 .AND. energies(i) .GT. 4.01*rm))ifirst = i
        energies(i) = log(energies(i))
13661 CONTINUE
13662 CONTINUE
      log_4rm = log(4*rm)
      energies(ifirst-1) = log_4rm
      dl_triplet = (energies(ntrip) - log_4rm)/250
      dli_triplet = 1/dl_triplet
      bli_triplet = 1 - log_4rm/dl_triplet
      DO 13671 imed=1,nmed
        write(i_log,'(a,i3,a,$)') '   Preparing triplet fraction data fo
     *r medium ',imed,' ... '
        iz1 = zelem(imed,1) + 0.1
        DO 13681 i=1,ntrip
          sigp(i) = pz(imed,1)*sig_pair(iz1,i)
          sigt(i) = pz(imed,1)*sig_triplet(iz1,i)
          DO 13691 iel=2,nne(imed)
            izi = zelem(imed,iel) + 0.1
            sigp(i) = sigp(i) + pz(imed,iel)*sig_pair(izi,i)
            sigt(i) = sigt(i) + pz(imed,iel)*sig_triplet(izi,i)
13691     CONTINUE
13692     CONTINUE
13681   CONTINUE
13682   CONTINUE
        DO 13701 i=ifirst,ntrip
          f_triplet(i-ifirst+2) = sigt(i)/(sigp(i) + sigt(i))
13701   CONTINUE
13702   CONTINUE
        f_triplet(1) = 0
        call set_spline(energies(ifirst-1),f_triplet,as,bs,cs,ds,ntrip-i
     *  first+2)
        logE = log_4rm
        f_old = 0
        DO 13711 i=1,250-1
          logE = logE + dl_triplet
          f_new = spline(logE,energies(ifirst-1),as,bs,cs,ds,ntrip-ifirs
     *    t+2)
          a_triplet(i,imed) = (f_new - f_old)*dli_triplet
          b_triplet(i,imed) = f_new - a_triplet(i,imed)*logE
          f_old = f_new
13711   CONTINUE
13712   CONTINUE
        write(i_log,*) 'OK'
13671 CONTINUE
13672 CONTINUE
      close(triplet_unit)
      return
13630 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,a)') ' init_triplet: failed to open the data file
     *', triplet_data_file(:lnblnk1(triplet_data_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
13640 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' init_triplet: error while reading triplet data '
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      SUBROUTINE EDGSET(NREGLO,NREGHI)
      implicit none
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer NREGLO,NREGHI
      integer*4 i,j,k,jj,iz
      logical do_relax
      logical got_data
      save got_data
      data got_data/.false./
      IF((got_data))return
      write(i_log,'(a/,a)') 'Output from subroutine EDGSET:', '=========
     *====================='
      do_relax = .false.
      DO 13721 j=1, 2001
        IF (( iedgfl(j) .GT. 0 .AND. iedgfl(j) .LE. 100 )) THEN
          do_relax = .true.
          GO TO13722
        END IF
13721 CONTINUE
13722 CONTINUE
      IF (( .NOT.do_relax )) THEN
        IF ((eadl_relax)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,/a)') 'You must turn ON atomic relaxations whe
     *n requesting', 'detailed atomic relaxation (eadl_relax=true)!'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        write(i_log,'(a/)') ' Atomic relaxations not requested! '
        return
      END IF
      write(i_log,'(a/)') ' Atomic relaxations requested! '
      write(i_log,'(a$)') ' Reading simplified photo-absorption data ...
     *..'
      got_data = .true.
      rewind(i_photo_relax)
      DO 13731 i=1,100
        IF ((eadl_relax)) THEN
          read(i_photo_relax,*)
        ELSE
          read(i_photo_relax,*) j,(binding_energies(k,i),k=1,6)
          DO 13741 k=1,6
            binding_energies(k,i) = binding_energies(k,i)*1e-6
13741     CONTINUE
13742     CONTINUE
        END IF
13731 CONTINUE
13732 CONTINUE
      read(i_photo_relax,*)
      DO 13751 i=1,100
        read(i_photo_relax,*) j,(interaction_prob(k,i),k=1,5)
        interaction_prob(6,i)=1.01
13751 CONTINUE
13752 CONTINUE
      write(i_log,'(a)') ' Done'
      write(i_log,'(/a$)') ' Reading simplified relaxation data .....'
      read(i_photo_relax,*)
      DO 13761 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=1,19)
13761 CONTINUE
13762 CONTINUE
      read(i_photo_relax,*)
      DO 13771 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=20,26)
13771 CONTINUE
13772 CONTINUE
      read(i_photo_relax,*)
      DO 13781 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=27,32)
13781 CONTINUE
13782 CONTINUE
      read(i_photo_relax,*)
      DO 13791 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=33,37)
13791 CONTINUE
13792 CONTINUE
      read(i_photo_relax,*)
      DO 13801 i=1,100
        read(i_photo_relax,*) j,relaxation_prob(38,i)
13801 CONTINUE
13802 CONTINUE
      write(i_log,'(a)') ' Done'
      write(i_log,'(/a$)') ' Reading parametrized XCOM photo cross secti
     *on data .....'
      rewind(i_photo_cs)
      DO 13811 i=1,100
        read(i_photo_cs,*) j,edge_number(i)
        DO 13821 j=1,edge_number(i)
          read(i_photo_cs,*) edge_a(j,i),edge_b(j,i),edge_c(j,i), edge_d
     *    (j,i),edge_energies(j,i)
13821   CONTINUE
13822   CONTINUE
13811 CONTINUE
13812 CONTINUE
      write(i_log,'(a)') ' Done'
      IF ((eadl_relax)) THEN
        call egs_init_relax
      END IF
      RETURN
      END
      SUBROUTINE PHOTON(IRCODE)
      implicit none
      integer*4 IRCODE
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/BOUNDS/ECUT( 2001),PCUT( 2001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/PHOTIN/ EBINDA(6), GE0(6),GE1(6), GMFP0(2000,6),GMFP1(2000,
     *6),GBR10(2000,6),GBR11(2000,6),GBR20(2000,6),GBR21(2000,6), RCO0(6
     *),RCO1(6), RSCT0(100,6),RSCT1(100,6), COHE0(2000,6),COHE1(2000,6),
     *  PHOTONUC0(2000,6),PHOTONUC1(2000,6), DPMFP, MPGEM(1,6), NGR(6)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERVR/ CEXPTR,GWAIT(150),DUMU,NP_INC(150),MAFORC,IFORCE,NF
     *MIN,NFMAX,NFTIME, ISOURC,IFPB,IQINC,MONOEN,IRODUM,IRNDUM,MEDDUM,ID
     *UM,MEDTMP, PATHL,DELTAP,GWTOLD,EPSLON,ARG
      real*8 CEXPTR,GWAIT,DUMU,PATHL,DELTAP,GWTOLD,EPSLON,ARG
      integer*4 NP_INC,MAFORC,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQIN
     *C, MONOEN,IRODUM,IRNDUM,MEDDUM,IDUM,MEDTMP
      COMMON/USERRR/
     *              CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,
     *                            EKETST,ELKETS,ZL,RL,CDIST,IGEOM,IRANGE
     *,MINZ,MAXZ,MINR,MAXR,IREJCT
      real*8 CRANGE,ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,EKETST,ELKETS
     *,ZL,RL,CDIST
      integer*4 MINZ,MAXZ,MINR,MAXR
      integer*4 IREJCT,IRANGE,IGEOM
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DOUBLE PRECISION PEIG
      real*8 EIG,  RNNO35,  GMFPR0,  GMFP,  COHFAC,  RNNO37,  XXX,  X2,
     * Q2,  CSQTHE,  REJF,  RNNORJ,  RNNO36,  GBR1,  GBR2,  T,   PHOTONU
     *CFAC,  RNNO39
      integer*4 IARG,  IDR,  IRL,  LGLE,  LXXX
      IRCODE=1
      PEIG=E(NP)
      EIG=PEIG
      IRL=IR(NP)
      medium = med(irl)
      IF ((EIG .LE. PCUT(IRL))) THEN
        GO TO 13830
      END IF
13840 CONTINUE
13841   CONTINUE
        IF ((WT(NP) .EQ. 0.0)) THEN
          go to 13850
        END IF
        GLE=LOG(EIG)
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO35 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((RNNO35 .EQ. 0.0))RNNO35=1.E-30
        IF ((IFORCE .EQ. 0)) THEN
          DPMFP=-LOG(RNNO35)
        ELSE
          IF ((NP_INC(NP) .EQ. 0)) THEN
            NFTIME=NFTIME+1
            IF (((NFTIME .GT. NFMAX) .OR. (NFTIME .LT. NFMIN))) THEN
              DPMFP=-LOG(RNNO35)
            ELSE
              NP_INC(NP)=1
              NP=NP+1
              U(NP)=U(NP-1)
              V(NP)=V(NP-1)
              W(NP)=W(NP-1)
              WT(NP)=WT(NP-1)
              E(NP)=E(NP-1)
              X(NP)=X(NP-1)
              Y(NP)=Y(NP-1)
              Z(NP)=Z(NP-1)
              IQ(NP)=IQ(NP-1)
              IR(NP)=IR(NP-1)
              LATCH(NP)=LATCH(NP-1)
              IF ((MAFORC .EQ. 1)) THEN
                MAFORC=0
                WT(NP)=1.-WT(NP-1)
                GOTO 13860
              END IF
              DUMU=USTEP
              IRODUM=IROLD
              IRNDUM=IRNEW
              MEDDUM=MEDIUM
              IDUM=IDISC
              PATHL=0.0
              MEDTMP=0
13871         CONTINUE
                USTEP=VACDST
                IROLD=IR(NP)
                MEDIUM=MED(IROLD)
                IF ((MEDIUM.EQ.0)) THEN
                  DELTAP=0.
                ELSE
                  IF ((MEDTMP .NE. MEDIUM)) THEN
                    MEDTMP=MEDIUM
                    LGLE=GE1(MEDIUM)*GLE+GE0(MEDIUM)
                    DELTAP=GMFP1(LGLE,MEDIUM)*GLE+GMFP0(LGLE,MEDIUM)
                  END IF
                  IF ((IRAYLR(IROLD) .EQ. 1)) THEN
                    COHFAC=COHE1(LGLE,MEDIUM)*GLE+COHE0(LGLE,MEDIUM)
                  ELSE
                    COHFAC=1.0
                  END IF
                END IF
                CALL HOWFAR
                IF((DELTAP.NE.0))PATHL=PATHL+USTEP/(DELTAP*COHFAC)
                IF((IRNEW .EQ. 1))GO TO13872
                IR(NP)=IRNEW
                X(NP)=X(NP)+USTEP*U(NP)
                Y(NP)=Y(NP)+USTEP*V(NP)
                Z(NP)=Z(NP)+USTEP*W(NP)
              GO TO 13871
13872         CONTINUE
              U(NP)=U(NP-1)
              V(NP)=V(NP-1)
              W(NP)=W(NP-1)
              E(NP)=E(NP-1)
              X(NP)=X(NP-1)
              Y(NP)=Y(NP-1)
              Z(NP)=Z(NP-1)
              IQ(NP)=IQ(NP-1)
              IR(NP)=IR(NP-1)
              LATCH(NP)=LATCH(NP-1)
              USTEP=DUMU
              IROLD=IRODUM
              IRNEW=IRNDUM
              MEDIUM=MEDDUM
              IDISC=IDUM
              IF ((PATHL.LE.1.0E-3)) THEN
                GWAIT(NP-1)=PATHL*(1.-0.5*PATHL)
              ELSE
                GWAIT(NP-1)=1.-EXP(-PATHL)
              END IF
              GWTOLD=WT(NP-1)
              WT(NP-1)=GWTOLD*GWAIT(NP-1)
              GWAIT(NP)=1.-GWAIT(NP-1)
              WT(NP)=GWTOLD*GWAIT(NP)
13860         CONTINUE
              DPMFP=1.0E30
            END IF
          ELSE
            NP_INC(NP)=0
            EPSLON=RNNO35*GWAIT(NP)
            IF ((EPSLON.LE.1.0E-3)) THEN
              DPMFP=EPSLON*(1.+0.5*EPSLON)
            ELSE
              ARG=1./(1.-EPSLON)
              DPMFP=LOG(ARG)
            END IF
          END IF
        END IF
        IROLD=IR(NP)
13880   CONTINUE
13881     CONTINUE
          IF ((MEDIUM.NE.0)) THEN
            LGLE=GE1(MEDIUM)*GLE+GE0(MEDIUM)
            GMFPR0=GMFP1(LGLE,MEDIUM)*GLE+GMFP0(LGLE,MEDIUM)
          END IF
13890     CONTINUE
13891       CONTINUE
            IF ((MEDIUM.EQ.0)) THEN
              TSTEP=VACDST
            ELSE
              RHOF=RHOR(IRL)/RHO(MEDIUM)
              GMFP=GMFPR0/RHOF
              IF ((IRAYLR(IRL).EQ.1)) THEN
                COHFAC=COHE1(LGLE,MEDIUM)*GLE+COHE0(LGLE,MEDIUM)
                GMFP=GMFP*COHFAC
              END IF
              IF ((IPHOTONUCR(IRL).EQ.1)) THEN
                PHOTONUCFAC=PHOTONUC1(LGLE,MEDIUM)*GLE+PHOTONUC0(LGLE,ME
     *          DIUM)
                GMFP=GMFP*PHOTONUCFAC
              END IF
              TSTEP=GMFP*DPMFP
            END IF
            IRNEW=IR(NP)
            IDISC=0
            USTEP=TSTEP
            TUSTEP=USTEP
            IF (( ustep .GT. dnear(np) .OR. wt(np) .LE. 0 )) THEN
              call howfar
            END IF
            IF ((IDISC.GT.0)) THEN
              GO TO 13850
            END IF
            VSTEP=USTEP
            TVSTEP=VSTEP
            EDEP=PZERO
            x_final = x(np) + u(np)*vstep
            y_final = y(np) + v(np)*vstep
            z_final = z(np) + w(np)*vstep
            IARG=0
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            x(np) = x_final
            y(np) = y_final
            z(np) = z_final
            DNEAR(NP)=DNEAR(NP)-USTEP
            IF ((MEDIUM.NE.0)) THEN
              DPMFP=MAX(0.,DPMFP-USTEP/GMFP)
            END IF
            IROLD=IR(NP)
            MEDOLD=MEDIUM
            IF ((IRNEW.NE.IROLD)) THEN
              ir(np) = irnew
              irl = irnew
              medium = med(irl)
            END IF
            IARG=5
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            IF ((EIG.LE.PCUT(IRL))) THEN
              GO TO 13830
            END IF
            IF((IDISC.LT.0))GO TO 13850
            IF((MEDIUM.NE.MEDOLD))GO TO 13892
            IF ((MEDIUM.NE.0.AND.DPMFP.LE.1.E-8)) THEN
              GO TO 13882
            END IF
          GO TO 13891
13892     CONTINUE
        GO TO 13881
13882   CONTINUE
        IF ((IRAYLR(IRL).EQ.1)) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO37 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF ((RNNO37.LE.(1.0-COHFAC))) THEN
            IARG=23
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            NPold = NP
            call egs_rayleigh_sampling(MEDIUM,E(NP),GLE,LGLE,COSTHE,SINT
     *      HE)
            CALL UPHI(2,1)
            IARG=24
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            GOTO 13840
          END IF
        END IF
        IF ((IPHOTONUCR(IRL).EQ.1)) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO39 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF ((RNNO39.LE.(1.0-PHOTONUCFAC))) THEN
            IARG=29
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            call PHOTONUC
            IARG=30
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            GOTO 13840
          END IF
        END IF
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO36 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        GBR1=GBR11(LGLE,MEDIUM)*GLE+GBR10(LGLE,MEDIUM)
        IF (((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )) THEN
          IARG=15
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          CALL PAIR
          IARG=16
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          IF (( iq(np) .NE. 0 )) THEN
            GO TO 13842
          ELSE
            goto 13900
          END IF
        END IF
        GBR2=GBR21(LGLE,MEDIUM)*GLE+GBR20(LGLE,MEDIUM)
        IF ((RNNO36.LT.GBR2)) THEN
          IARG=17
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          CALL COMPT
          IARG=18
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          IF((IQ(NP).NE.0))GO TO 13842
        ELSE
          IARG=19
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          CALL PHOTO
          IF ((NP .EQ. 0 .OR. NP .LT. NPOLD )) THEN
            RETURN
          END IF
          IARG=20
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          IF((IQ(NP) .NE. 0))GO TO 13842
        END IF
13900   PEIG=E(NP)
        EIG=PEIG
        IF((EIG.LT.PCUT(IRL)))GO TO 13830
      GO TO 13841
13842 CONTINUE
      RETURN
13830 IF (( medium .GT. 0 )) THEN
        IF ((EIG.GT.AP(MEDIUM))) THEN
          IDR=1
        ELSE
          IDR=2
        END IF
      ELSE
        IDR=1
      END IF
      EDEP=PEIG
      IARG=IDR
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      IRCODE=2
      NP=NP-1
      RETURN
13850 EDEP=PEIG
      IARG=3
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      IRCODE=2
      NP=NP-1
      RETURN
      END
      SUBROUTINE SHOWER(IQI,EI,XI,YI,ZI,UI,VI,WI,IRI,WTI)
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 EI,  XI,YI,ZI, UI,VI,WI, WTI
      integer*4 IQI,  IRI
      DOUBLE PRECISION DEG,  DPGL,  DEI,  DPI,  DCSTH,  DCOSTH,  PI0MSQ
      real*8 DNEARI,  CSTH
      integer*4 IRCODE
      DATA PI0MSQ/1.8215416D4/
      NP=1
      NPold = NP
      DNEARI=0.0
      IQ(1)=IQI
      E(1)=EI
      U(1)=UI
      V(1)=VI
      W(1)=WI
      X(1)=XI
      Y(1)=YI
      Z(1)=ZI
      IR(1)=IRI
      WT(1)=WTI
      DNEAR(1)=DNEARI
      LATCH(1)=LATCHI
      IF ((IQI .EQ. 2)) THEN
        IF ((EI**2 .LE. PI0MSQ)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//a/,a,g15.5,a)') ' Stopped in subroutine SHOWER
     *---PI-ZERO option invoked', ' but the total energy was too small (
     *EI=',EI,' MeV)'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF((rng_seed .GT. 128))call ranmar_get
        CSTH = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        DCSTH=CSTH
        DEI=EI
        DPI=DSQRT(DEI*DEI-PI0MSQ)
        DEG=DEI+DPI*DCSTH
        DPGL=DPI+DEI*DCSTH
        DCOSTH=DPGL/DEG
        COSTHE=DCOSTH
        SINTHE=DSQRT(1.D0-DCOSTH*DCOSTH)
        IQ(1)=0
        E(1)=DEG/2.
        CALL UPHI(2,1)
        NP=2
        DEG=DEI-DPI*DCSTH
        DPGL=DPI-DEI*DCSTH
        DCOSTH=DPGL/DEG
        COSTHE=DCOSTH
        SINTHE=-DSQRT(1.D0-DCOSTH*DCOSTH)
        IQ(2)=0
        E(2)=DEG/2.
        CALL UPHI(3,2)
      END IF
13911 CONTINUE
        IF((np .LE. 0))GO TO13912
        IF (( iq(np) .EQ. 0 )) THEN
          call photon(ircode)
        ELSE
          call electr(ircode)
        END IF
      GO TO 13911
13912 CONTINUE
      RETURN
      END
      SUBROUTINE UPHI(IENTRY,LVL)
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      real*8 SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer IENTRY,LVL
      real*8 CTHET,  RNNO38,  PHI,  CPHI,  A,B,C,  SINPS2,  SINPSI,  US,
     *VS,  SINDEL,COSDEL
      integer*4 IARG,  LPHI,LTHETA,LCTHET,LCPHI
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      save CTHET,PHI,CPHI,A,B,C,SINPS2,SINPSI,US,VS,SINDEL,COSDEL
      IARG=21
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      GO TO (13920,13930,13940),IENTRY
      GO TO 13950
13920 CONTINUE
      SINTHE=sin(THETA)
      CTHET=PI5D2-THETA
      COSTHE=sin(CTHET)
13930 CONTINUE
13961 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        xphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF((rng_seed .GT. 128))call ranmar_get
        yphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO13962
      GO TO 13961
13962 CONTINUE
      rhophi2 = 1/rhophi2
      cosphi = (xphi2 - yphi2)*rhophi2
      sinphi = 2*xphi*yphi*rhophi2
13940 GO TO (13970,13980,13990),LVL
      GO TO 13950
13970 A=U(NP)
      B=V(NP)
      C=W(NP)
      GO TO 14000
13990 A=U(NP-1)
      B=V(NP-1)
      C=W(NP-1)
13980 X(NP)=X(NP-1)
      Y(NP)=Y(NP-1)
      Z(NP)=Z(NP-1)
      IR(NP)=IR(NP-1)
      WT(NP)=WT(NP-1)
      DNEAR(NP)=DNEAR(NP-1)
      LATCH(NP)=LATCH(NP-1)
14000 SINPS2=A*A+B*B
      IF ((SINPS2.LT.1.0E-20)) THEN
        U(NP)=SINTHE*COSPHI
        V(NP)=SINTHE*SINPHI
        W(NP)=C*COSTHE
      ELSE
        SINPSI=SQRT(SINPS2)
        US=SINTHE*COSPHI
        VS=SINTHE*SINPHI
        SINDEL=B/SINPSI
        COSDEL=A/SINPSI
        U(NP)=C*COSDEL*US-SINDEL*VS+A*COSTHE
        V(NP)=C*SINDEL*US+COSDEL*VS+B*COSTHE
        W(NP)=-SINPSI*US+C*COSTHE
      END IF
      IARG=22
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      RETURN
13950 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,2i6)') ' STOPPED IN UPHI WITH IENTRY,LVL=',IENTRY,
     *LVL
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      END
      subroutine init_nist_brems
      implicit none
      real*8 energy_array(57),x_array(54), cs_array(57,54,100)
      real*8 xi_array(54)
      real*8 x_gauss(64),w_gauss(64)
      integer*4 nmix,kmix,i,n,k,j,ii
      integer*4 ngauss,i_gauss
      integer*4 lnblnk1,egs_get_unit
      integer*4 ifirst,ilast,nener,neke,leil
      real*8 cs(57,54),ee(57),ele(57)
      real*8 csx(54),afx(54),bfx(54),cfx(54),dfx(54)
      real*8 cse(57),afe(57),bfe(57),cfe(57),dfe(57)
      real*8 Z,sumA
      real*8 emin,xi,res,spline,eil,ei,beta2,aux,sigb,sigt,ebr1,ebr2
      real*8 sigee,sigep,sige,si_esig,si1_esig,si_ebr1,si1_ebr1,ededx, s
     *ig_bhabha,si_psig,si1_psig,si_pbr1,si1_pbr1,si_pbr2,si1_pbr2
      integer*4 iz
      real*8 ple,qle,x,f,error,max_error,x_max_error,f_max_error
      integer*4 ndat,k_max_error
      character tmp_string*512, tmp1_string*512
      integer itmp
      real*8 amu
      parameter (amu = 1660.5655)
      logical ex,is_opened
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/nist_brems/ nb_fdata(0:50,100,6), nb_xdata(0:50,100,6), nb_
     *wdata(50,100,6), nb_idata(50,100,6), nb_emin(6),nb_emax(6), nb_lem
     *in(6),nb_lemax(6), nb_dle(6),nb_dlei(6), log_ap(6)
      real*8 nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lema
     *x, nb_dle,nb_dlei,log_ap
      integer*4 nb_idata
      common/spin_data/ spin_rej(6,0:1,0: 31,0:15,0:31), espin_min,espin
     *_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dleneri,dq
     *q1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DO 14011 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
14011 CONTINUE
14012 CONTINUE
      tmp_string = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      IF (( ibr_nist .EQ. 1 )) THEN
        DO 14021 i=1,len(tmp1_string)
          tmp1_string(i:i) = ' '
14021   CONTINUE
14022   CONTINUE
        tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'nist_brems.da
     *ta'
        inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
        IF (( .NOT.ex )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'EGSnrc data file ','nist_brems.data',' does no
     *t exist'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF (( .NOT.is_opened )) THEN
          i_nist_data=egs_get_unit(i_nist_data)
          IF ((i_nist_data.LT.0)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'failed to get a free Fortran I/O unit for da
     *ta file ', tmp1_string(:lnblnk1(tmp1_string))
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(i_nist_data,file=tmp1_string,status='old',err=9080)
        ELSE
          i_nist_data = itmp
        END IF
      ELSE IF((ibr_nist .EQ. 2)) THEN
        DO 14031 i=1,len(tmp1_string)
          tmp1_string(i:i) = ' '
14031   CONTINUE
14032   CONTINUE
        tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'nrc_brems.dat
     *a'
        inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
        IF (( .NOT.ex )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'EGSnrc data file ','nrc_brems.data',' does not
     * exist'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF (( .NOT.is_opened )) THEN
          i_nist_data=egs_get_unit(i_nist_data)
          IF ((i_nist_data.LT.0)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'failed to get a free Fortran I/O unit for da
     *ta file ', tmp1_string(:lnblnk1(tmp1_string))
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(i_nist_data,file=tmp1_string,status='old',err=9080)
        ELSE
          i_nist_data = itmp
        END IF
      ELSE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' init_nist_brems: unknown value of ibr_nist!
     *                  ibr_nist = ', ibr_nist
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      rewind(i_nist_data)
      read(i_nist_data,*)
      read(i_nist_data,*) nmix,kmix
      IF ((kmix .GT. 54)) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' init_nist_brems: to many k values in data file!
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF ((nmix .GT. 57)) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' init_nist_brems: to many T values in data file!
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      read(i_nist_data,*) (energy_array(n),n=1,nmix)
      DO 14041 n=1,nmix
        energy_array(n) = 1.0*energy_array(n)
14041 CONTINUE
14042 CONTINUE
      read(i_nist_data,*) (x_array(k),k=1,kmix)
      read(i_nist_data,*)
      DO 14051 i=1,100
        read(i_nist_data,*) ((cs_array(n,k,i),n=1,nmix),k=1,kmix)
14051 CONTINUE
14052 CONTINUE
      close(i_nist_data)
      DO 14061 k=1,kmix
        xi_array(k)=Log(1-x_array(k)+1e-6)
        IF (( fool_intel_optimizer )) THEN
          write(i_log,*) 'xi_array(k): ',xi_array(k)
        END IF
14061 CONTINUE
14062 CONTINUE
      ngauss = 64
      call gauss_legendre(0d0,1d0,x_gauss,w_gauss,ngauss)
      write(i_log,*) ' '
      IF ((ibr_nist .EQ. 1)) THEN
        write(i_log,*) 'Using NIST brems cross sections! '
      ELSE IF((ibr_nist .EQ. 2)) THEN
        write(i_log,*) 'Using NRC brems cross sections! '
      END IF
      write(i_log,*) ' '
      DO 14071 medium=1,nmed
        log_ap(medium) = log(ap(medium))
        write(i_log,*) ' Initializing brems data for medium ',medium,'..
     *.'
        emin = max(ae(medium) - rm, ap(medium))
        DO 14081 i=1,nmix
          IF((energy_array(i) .GE. emin))GO TO14082
14081   CONTINUE
14082   CONTINUE
        ifirst = i
        DO 14091 i=nmix,1,-1
          IF((energy_array(i) .LT. ue(medium) - rm))GO TO14092
14091   CONTINUE
14092   CONTINUE
        ilast = i+1
        IF (( ifirst .LT. 1 .OR. ilast .GT. nmix )) THEN
          write(i_log,*) ' init_nist_brems: data available only for '
          write(i_log,*) energy_array(1),' <= E <= ',energy_array(nmix)
          write(i_log,*) ' will use spline interpolations to get cross '
          write(i_log,*) ' sections beyond the available data but this m
     *ay'
          write(i_log,*) ' produce nonsense!'
          IF((ifirst .LT. 1))ifirst=1
          IF((ilast .GT. nmix))ilast = nmix
        END IF
        DO 14101 i=ifirst,ilast
          ii = i+1 - ifirst
          ee(ii) = energy_array(i)
          ele(ii) = log(ee(ii))
          sumA = 0
          DO 14111 j=1,NNE(medium)
            sumA = sumA + pz(medium,j)*wa(medium,j)
14111     CONTINUE
14112     CONTINUE
          sumA = sumA*amu
          DO 14121 k=1,kmix
            cs(ii,k) = 0
            DO 14131 j=1,NNE(medium)
              Z = zelem(medium,j)
              iz = int(Z+0.1)
              Z = Z*Z/sumA
              cs(ii,k) = cs(ii,k) + pz(medium,j)*Z*cs_array(i,k,iz)
14131       CONTINUE
14132       CONTINUE
            csx(k) = Log(cs(ii,k))
14121     CONTINUE
14122     CONTINUE
          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix)
          cse(ii) = 0
          aux = Log(ee(ii)/ap(medium))
          DO 14141 i_gauss=1,ngauss
            xi = log(1 - ap(medium)/ee(ii)*exp(x_gauss(i_gauss)*aux)+1e-
     *      6)
            res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix)
            cse(ii) = cse(ii) + w_gauss(i_gauss)*exp(res)
14141     CONTINUE
14142     CONTINUE
14101   CONTINUE
14102   CONTINUE
        nener = ilast - ifirst + 1
        call set_spline(ele,cse,afe,bfe,cfe,dfe,nener)
        neke = meke(medium)
        sigee = 1E-15
        sigep = 1E-15
        DO 14151 i=1,neke
          eil = (float(i) - eke0(medium))/eke1(medium)
          ei = exp(eil)
          leil = i
          beta2 = ei*(ei+2*rm)/(ei+rm)**2
          IF (( ei .LE. ap(medium) )) THEN
            sigb = 1e-30
          ELSE
            sigb = spline(eil,ele,afe,bfe,cfe,dfe,nener)
            sigb = sigb*log(ei/ap(medium))/beta2*rho(medium)
          END IF
          sigt=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
          ebr1=ebr11(Leil,MEDIUM)*eil+ebr10(Leil,MEDIUM)
          IF((sigt .LT. 0))sigt = 0
          IF((ebr1 .GT. 1))ebr1 = 1
          IF((ebr1 .LT. 0))ebr1 = 0
          IF (( i .GT. 1 )) THEN
            si_esig = si1_esig
            si_ebr1 = si1_ebr1
            si1_esig = sigt*(1 - ebr1) + sigb
            si1_ebr1 = sigb/si1_esig
            esig1(i-1,medium) = (si1_esig - si_esig)*eke1(medium)
            esig0(i-1,medium) = si1_esig - esig1(i-1,medium)*eil
            ebr11(i-1,medium) = (si1_ebr1 - si_ebr1)*eke1(medium)
            ebr10(i-1,medium) = si1_ebr1 - ebr11(i-1,medium)*eil
          ELSE
            si1_esig = sigt*(1 - ebr1) + sigb
            si1_ebr1 = sigb/si1_esig
          END IF
          sigt=psig1(Leil,MEDIUM)*eil+psig0(Leil,MEDIUM)
          ebr1=pbr11(Leil,MEDIUM)*eil+pbr10(Leil,MEDIUM)
          ebr2=pbr21(Leil,MEDIUM)*eil+pbr20(Leil,MEDIUM)
          IF((sigt .LT. 0))sigt = 0
          IF((ebr1 .GT. 1))ebr1 = 1
          IF((ebr1 .LT. 0))ebr1 = 0
          IF((ebr2 .GT. 1))ebr2 = 1
          IF((ebr2 .LT. 0))ebr2 = 0
          sig_bhabha = sigt*(ebr2 - ebr1)
          IF((sig_bhabha .LT. 0))sig_bhabha = 0
          IF (( i .GT. 1 )) THEN
            si_psig = si1_psig
            si_pbr1 = si1_pbr1
            si_pbr2 = si1_pbr2
            si1_psig = sigt*(1 - ebr1) + sigb
            si1_pbr1 = sigb/si1_psig
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig
            psig1(i-1,medium) = (si1_psig - si_psig)*eke1(medium)
            psig0(i-1,medium) = si1_psig - psig1(i-1,medium)*eil
            pbr11(i-1,medium) = (si1_pbr1 - si_pbr1)*eke1(medium)
            pbr10(i-1,medium) = si1_pbr1 - pbr11(i-1,medium)*eil
            pbr21(i-1,medium) = (si1_pbr2 - si_pbr2)*eke1(medium)
            pbr20(i-1,medium) = si1_pbr2 - pbr21(i-1,medium)*eil
          ELSE
            si1_psig = sigt*(1 - ebr1) + sigb
            si1_pbr1 = sigb/si1_psig
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig
          END IF
          ededx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
          sige = si1_esig/ededx
          IF((sige .GT. sigee))sigee = sige
          ededx=pdedx1(Leil,MEDIUM)*eil+pdedx0(Leil,MEDIUM)
          sige = si1_psig/ededx
          IF((sige .GT. sigep))sigep = sige
14151   CONTINUE
14152   CONTINUE
        esig1(neke,medium) = esig1(neke-1,medium)
        esig0(neke,medium) = esig0(neke-1,medium)
        ebr11(neke,medium) = ebr11(neke-1,medium)
        ebr10(neke,medium) = ebr10(neke-1,medium)
        psig1(neke,medium) = psig1(neke-1,medium)
        psig0(neke,medium) = psig0(neke-1,medium)
        pbr11(neke,medium) = pbr11(neke-1,medium)
        pbr10(neke,medium) = pbr10(neke-1,medium)
        pbr21(neke,medium) = pbr21(neke-1,medium)
        pbr20(neke,medium) = pbr20(neke-1,medium)
        write(i_log,*) ' Max. new cross sections per energy loss: ',sige
     *  e,sigep
        esig_e(medium) = sigee
        psig_e(medium) = sigep
        IF((sigee .GT. esige_max))esige_max = sigee
        IF((sigep .GT. psige_max))psige_max = sigep
        nb_emin(medium) = energy_array(ifirst)
        IF (( nb_emin(medium) .LE. ap(medium) )) THEN
          nb_emin(medium) = energy_array(ifirst+1)
        END IF
        nb_emax(medium) = energy_array(ilast)
        nb_lemin(medium) = log(nb_emin(medium))
        nb_lemax(medium) = log(nb_emax(medium))
        nb_dle(medium) = (nb_lemax(medium) - nb_lemin(medium))/(100-1)
        nb_dlei(medium) = 1/nb_dle(medium)
        eil = nb_lemin(medium) - nb_dle(medium)
        DO 14161 i=1,100
          eil = eil + nb_dle(medium)
          ei = exp(eil)
          DO 14171 ii=1,nener
            IF((ei .LT. ee(ii)))GO TO14172
14171     CONTINUE
14172     CONTINUE
          ii = ii-1
          IF((ii .LT. 1))ii = 1
          IF((ii .GT. nener-1))ii = nener-1
          ple = (eil - ele(ii))/(ele(ii+1)-ele(ii))
          qle = 1 - ple
          DO 14181 k=1,kmix
            csx(k) = log(qle*cs(ii,k) + ple*cs(ii+1,k))
14181     CONTINUE
14182     CONTINUE
          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix)
          x = ap(medium)/ei
          aux = -log(x)
          xi = log(1 - x+1e-6)
          res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix)
          nb_xdata(0,i,medium) = 0
          nb_fdata(0,i,medium) = exp(res)
          DO 14191 k=1,kmix
            IF((x_array(k) .GT. x))GO TO14192
14191     CONTINUE
14192     CONTINUE
          IF((k .GT. kmix))k = kmix
          ndat = 0
          DO 14201 j=k+1,kmix-1
            ndat = ndat+1
            nb_xdata(ndat,i,medium) = log(x_array(j)/x)/aux
            nb_fdata(ndat,i,medium) = exp(csx(j))
            IF (( fool_intel_optimizer )) THEN
              write(i_log,*) 'nb_xdata(ndat,i,medium): ', nb_xdata(ndat,
     *        i,medium)
            END IF
14201     CONTINUE
14202     CONTINUE
          ndat = ndat+1
          nb_xdata(ndat,i,medium) = 1
          nb_fdata(ndat,i,medium) = exp(csx(kmix))
          IF((ndat .GE. 50))goto 14210
14221     CONTINUE
            x_max_error = 0
            f_max_error = 0
            k_max_error = 0
            max_error = 0
            DO 14231 k=0,ndat-1
              x = 0.5*(nb_xdata(k,i,medium) + nb_xdata(k+1,i,medium))
              f = 0.5*(nb_fdata(k,i,medium) + nb_fdata(k+1,i,medium))
              xi = log(1 - ap(medium)/ei*exp(x*aux)+1e-6)
              res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix)
              res = exp(res)
              error = abs(1-f/res)
              IF (( error .GT. max_error )) THEN
                x_max_error = x
                f_max_error = res
                max_error = error
                k_max_error = k
              END IF
14231       CONTINUE
14232       CONTINUE
            ndat = ndat+1
            DO 14241 k=ndat,k_max_error+2,-1
              nb_xdata(k,i,medium) = nb_xdata(k-1,i,medium)
              nb_fdata(k,i,medium) = nb_fdata(k-1,i,medium)
14241       CONTINUE
14242       CONTINUE
            nb_xdata(k_max_error+1,i,medium) = x_max_error
            nb_fdata(k_max_error+1,i,medium) = f_max_error
            IF(((ndat .EQ. 50)))GO TO14222
          GO TO 14221
14222     CONTINUE
14210     call prepare_alias_table(50,nb_xdata(0,i,medium), nb_fdata(0,i
     *    ,medium),nb_wdata(1,i,medium),nb_idata(1,i,medium))
14161   CONTINUE
14162   CONTINUE
14071 CONTINUE
14072 CONTINUE
      write(i_log,*) ' '
      write(i_log,*) ' '
      return
9080  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open EGSnrc data file ',tmp1_string(:lnb
     *lnk1(tmp1_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine init_nrc_pair
      implicit none
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      common/nrc_pair/ nrcp_fdata(65,84,6), nrcp_wdata(65,84,6), nrcp_id
     *ata(65,84,6), nrcp_xdata(65), nrcp_emin, nrcp_emax, nrcp_dle, nrcp
     *_dlei
      real*8 nrcp_fdata,nrcp_wdata,nrcp_xdata, nrcp_emin, nrcp_emax, nrc
     *p_dle, nrcp_dlei
      integer*4 nrcp_idata
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character nrcp_file*256, endianess*4
      integer egs_get_unit
      integer*4 nrcp_unit, want_nrcp_unit, rec_length
      integer*4 i, lnblnk1
      real*8 tmp, ddx, xx, Z
      real*4 emin, emax
      integer*4 ne, nb, ix, ie, irec, i_ele, nbb, iz
      character endian, cdum( 243)
      logical swap
      real*4 tmp_4, tarray(65)
      integer*4 itmp_4
      character c_4(4), ic_4(4)
      equivalence (tmp_4,c_4), (itmp_4, ic_4)
      DO 14251 i=1,len(nrcp_file)
        nrcp_file(i:i) = ' '
14251 CONTINUE
14252 CONTINUE
      nrcp_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'pa
     *ir_nrc1.data'
      want_nrcp_unit = 62
      nrcp_unit = egs_get_unit(want_nrcp_unit)
      IF (( nrcp_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'init_nrc_pair: failed to get a free fortran unit
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      rec_length = 65*4
      open(nrcp_unit,file=nrcp_file,form='unformatted',access='direct',
     *status='old',recl=rec_length,err=14260)
      read(nrcp_unit,rec=1,err=14270) emin, emax, ne, nb, endian, cdum
      IF (( ichar(endian) .EQ. 0 )) THEN
        endianess = '1234'
      ELSE
        endianess = '4321'
      END IF
      swap = endianess.ne.'1234'
      IF (( swap )) THEN
        tmp_4 = emin
        call egs_swap_4(c_4)
        emin = tmp_4
        tmp_4 = emax
        call egs_swap_4(c_4)
        emax = tmp_4
        itmp_4 = ne
        call egs_swap_4(ic_4)
        ne = itmp_4
        itmp_4 = nb
        call egs_swap_4(ic_4)
        nb = itmp_4
      END IF
      write(i_log,'(//a,a)') 'Reading NRC pair data base from ',nrcp_fil
     *e(:lnblnk1(nrcp_file))
      write(i_log,'(a,a,a)') 'Data generated on a machine with ',endiane
     *ss,' endianess'
      write(i_log,'(a,a)') 'The endianess of this CPU is ','1234'
      IF (( swap )) THEN
        write(i_log,'(a)') '=> will need to do byte swaping'
      END IF
      write(i_log,'(a,2f9.3)') 'Energy range of the data: ',emin,emax
      IF (( nb .NE. 65 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Inconsistent x-grid size'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( ne .NE. 84 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Inconsistent energy grid size'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      nrcp_emin = emin
      nrcp_emax = emax
      nrcp_dle = log((emax-2)/(emin-2))/(ne-1)
      nrcp_dlei = 1/nrcp_dle
      nbb = nb/2
      ddx = sqrt(0.5)/nbb
      DO 14281 ix=0,nbb
        xx = ddx*ix
        nrcp_xdata(ix+1) = xx*xx
14281 CONTINUE
14282 CONTINUE
      do ix=nbb-1,0,-1
        xx = ddx*ix
        nrcp_xdata(nb-ix) = 1 - xx*xx
      end do
      DO 14301 medium=1,NMED
        write(i_log,'(a,i4,a,$)') '  medium ',medium,' .................
     *.... '
        DO 14311 ie=1,84
          DO 14321 ix=1,65
            nrcp_fdata(ix,ie,medium) = 0
14321     CONTINUE
14322     CONTINUE
14311   CONTINUE
14312   CONTINUE
        DO 14331 i_ele=1,NNE(medium)
          Z = ZELEM(medium,i_ele)
          iz = int(Z+0.5)
          tmp = PZ(medium,i_ele)*Z*Z
          irec = (iz-1)*ne + 2
          DO 14341 ie=1,84
            read(nrcp_unit,rec=irec,err=14270) tarray
            DO 14351 ix=1,65
              tmp_4 = tarray(ix)
              IF (( swap )) THEN
                call egs_swap_4(c_4)
              END IF
              nrcp_fdata(ix,ie,medium)=nrcp_fdata(ix,ie,medium)+tmp*tmp_
     *        4
14351       CONTINUE
14352       CONTINUE
            irec = irec + 1
14341     CONTINUE
14342     CONTINUE
14331   CONTINUE
14332   CONTINUE
        DO 14361 ie=1,84
          call prepare_alias_table(nb-1,nrcp_xdata,nrcp_fdata(1,ie,mediu
     *    m), nrcp_wdata(1,ie,medium),nrcp_idata(1,ie,medium))
14361   CONTINUE
14362   CONTINUE
        write(i_log,'(a)') ' done'
14301 CONTINUE
14302 CONTINUE
      write(i_log,*) ' '
      close(nrcp_unit)
      return
14260 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Failed to open NRC pair data file'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
14270 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'I/O error while reading NRC pair data file'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      subroutine vmc_electron(ircode)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 ircode
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(//a//)') ' ********* VMC Transport option not in thi
     *s distribution ****** '
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      subroutine egs_init_default_rng
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      ixx=0
      jxx=0
      call init_ranmar
      return
      end
      subroutine egs_init_rng(arg1,arg2)
      integer*4 arg1,arg2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      ixx = arg1
      jxx = arg2
      call init_ranmar
      return
      end
      subroutine egs_get_rndm(ran)
      real*8 ran
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      IF((rng_seed .GT. 128))call ranmar_get
      ran = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      return
      end
      subroutine egs_get_rndm_array(n,rarray)
      integer*4 n
      real*8 rarray(*)
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      real*8 rtmp
      integer*4 i
      IF((n .LT. 1))return
      DO 14371 i=1,n
        IF((rng_seed .GT. 128))call ranmar_get
        rtmp = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        rarray(i) = rtmp
14371 CONTINUE
14372 CONTINUE
      return
      end
      subroutine eii_init
      implicit none
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(6), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),  e
     *ii_sh(40),  eii_nshells(100),  eii_nsh(6),  eii_first(6,50),  eii_
     *no(6,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      COMMON/ELECIN/ esig_e(6),psig_e(6), esige_max, psige_max, range_ep
     *(0:1,500,6), E_array(500,6), etae_ms0(500,6),etae_ms1(500,6),etap_
     *ms0(500,6),etap_ms1(500,6),q1ce_ms0(500,6),q1ce_ms1(500,6),q1cp_ms
     *0(500,6),q1cp_ms1(500,6),q2ce_ms0(500,6),q2ce_ms1(500,6),q2cp_ms0(
     *500,6),q2cp_ms1(500,6),blcce0(500,6),blcce1(500,6), EKE0(6),EKE1(6
     *), XR0(6),TEFF0(6),BLCC(6),XCC(6), ESIG0(500,6),ESIG1(500,6),PSIG0
     *(500,6),PSIG1(500,6),EDEDX0(500,6),EDEDX1(500,6),PDEDX0(500,6),PDE
     *DX1(500,6),EBR10(500,6),EBR11(500,6),PBR10(500,6),PBR11(500,6),PBR
     *20(500,6),PBR21(500,6),TMXS0(500,6),TMXS1(500,6), expeke1(6), IUNR
     *ST(6),EPSTFL(6),IAPRIM(6), sig_ismonotone(0:1,6)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      integer*4 imed,iele,ish,nsh,iZ,j,i,itmp,nskip,nbin,ii,nsh_tot,iii,
     *k
      integer*4 jj,jjj
      integer*4 lnblnk1
      integer*4 tmp_array(100)
      integer*4 want_eii_unit,eii_unit,eii_out,egs_open_file
      integer egs_get_unit
      real*8 e_eii_min,emax,fmax,aux_array(250)
      real*8 sigo,loge,tau,beta2,p2,uwm,Wmax
      real*8 ss_0, ss_1, sh_0, sh_1, aux, av_e, con_med, dedx_old, sigm_
     *old
      real*8 dedx,e,sig,sigm,wbrem,sum_a,sum_z,sum_pz,sum_wa,Ec,Ecc
      real*8 sum_sh,sum_occn,U,sum_sigma,sum_dedx
      real*8 sigma,sigma_old,wbrem_old,sig_j,de
      integer*4 lloge
      logical check_it,is_monotone,getd
      real*8 sigma_max
      character eii_file*128
      character*512 toUpper
      integer*4 occn_numbers(4)
      real*8 cons
      parameter (cons = 0.153536)
      data occn_numbers/2,2,2,4/
      DO 14381 j=1,100
        eii_nshells(j) = 0
14381 CONTINUE
14382 CONTINUE
      DO 14391 j=1,6
        eii_nsh(j) = 0
14391 CONTINUE
14392 CONTINUE
      IF (( eii_flag .EQ. 0 )) THEN
        return
      END IF
      getd = .false.
      DO 14401 j=1, 2001
        IF (( iedgfl(j) .GT. 0 .AND. iedgfl(j) .LE. 100 )) THEN
          getd = .true.
          GO TO14402
        END IF
14401 CONTINUE
14402 CONTINUE
      IF (( .NOT.getd )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(/a,/a,/a,/a)') ' In subroutine eii_init: ', '   Sc
     *attering off bound electrons creates atomic vacancies,', '   poten
     *tially starting an atomic relaxation cascade. ', '   Please turn O
     *N atomic relaxations.'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      e_eii_min = 1e30
      DO 14411 imed=1,nmed
        IF((ae(imed)-rm .LT. e_eii_min))e_eii_min = ae(imed) - rm
        IF((ap(imed) .LT. e_eii_min))e_eii_min = ap(imed)
14411 CONTINUE
14412 CONTINUE
      write(i_log,*) ' '
      write(i_log,*) 'eii_init: minimum threshold energy found: ',e_eii_
     *min
      DO 14421 imed=1,nmed
        DO 14431 iele=1,nne(imed)
          iZ = int(zelem(imed,iele)+0.5)
          IF (( eii_nshells(iZ) .EQ. 0 )) THEN
            nsh = 0
            DO 14441 ish=1,4
              IF((binding_energies(ish,iZ) .GT. e_eii_min))nsh = nsh+1
14441       CONTINUE
14442       CONTINUE
            eii_nshells(iZ) = nsh
          END IF
14431   CONTINUE
14432   CONTINUE
14421 CONTINUE
14422 CONTINUE
      nsh = 0
      DO 14451 iZ=1,100
        nsh = nsh + eii_nshells(iZ)
14451 CONTINUE
14452 CONTINUE
      IF (( nsh .EQ. 0 )) THEN
        write(i_log,*) '*** EII requested but no shells with binding ene
     *rgies '
        write(i_log,*) '    above the specified threshold found'
        write(i_log,*) '    => turning off EII'
        eii_flag = 0
      END IF
      IF (( nsh .GT. 40 )) THEN
        write(i_log,*) '*** Number of shells with binding energies great
     *er than '
        write(i_log,*) '    the specified thresholds is ',nsh
        write(i_log,*) '    This is more than the allocated arrays can h
     *old'
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) '    Increase the macro $MAX_EII_SHELLS and retry
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      write(i_log,*) 'eii_init: number of shells to simulate EII: ',nsh
      nsh_tot = nsh
      tmp_array(1) = 0
      DO 14461 j=2,100
        tmp_array(j) = tmp_array(j-1) + eii_nshells(j-1)
14461 CONTINUE
14462 CONTINUE
      DO 14471 imed=1,nmed
        nsh = 0
        DO 14481 iele=1,nne(imed)
          iZ = int(zelem(imed,iele)+0.5)
          eii_no(imed,iele) = eii_nshells(iZ)
          nsh = nsh + eii_nshells(iZ)
          IF (( eii_nshells(iZ) .GT. 0 )) THEN
            eii_first(imed,iele) = tmp_array(iZ) + 1
          ELSE
            eii_first(imed,iele) = 0
          END IF
14481   CONTINUE
14482   CONTINUE
        eii_nsh(imed) = nsh
14471 CONTINUE
14472 CONTINUE
      DO 14491 i=1,len(eii_file)
        eii_file(i:i) = ' '
14491 CONTINUE
14492 CONTINUE
      eii_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'eii
     *_'// eii_xfile(:lnblnk1(eii_xfile)) //'.data'
      want_eii_unit = 62
      eii_unit = egs_get_unit(want_eii_unit)
      IF (( eii_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'eii_init: failed to get a free Fortran I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(eii_unit,file=eii_file(:lnblnk1(eii_file)),status='old',err=1
     *4500)
      write(i_log,'(//a,a)') 'Opened EII data file ',eii_file(:lnblnk1(e
     *ii_file))
      write(i_log,'(a,$)') ' eii_init: reading EII data ... '
      read(eii_unit,*,err=14510,end=14510) nskip
      DO 14521 j=1,nskip
        read(eii_unit,*,err=14510,end=14510)
14521 CONTINUE
14522 CONTINUE
      read(eii_unit,*,err=14510,end=14510) emax,nbin
      IF (( nbin .NE. 250 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Inconsistent EII data file'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF ((xsec_out .EQ. 1)) THEN
        eii_out = egs_open_file(93,0,1,'.eiixsec')
      END IF
      ii = 0
      DO 14531 j=1,100
        read(eii_unit,*,err=14510,end=14510) iZ,nsh
        IF ((xsec_out .EQ. 1 .AND. eii_nshells(iZ) .GT. 0)) THEN
          write(eii_out,*) '================================='
          write(eii_out,'(a,i3)') 'EII xsections for element Z = ',iZ
          write(eii_out,*) '================================='
        END IF
        IF (( nsh .LT. eii_nshells(iZ) )) THEN
          write(i_log,*) 'EII data file has data for ',nsh,' shells for
     *element '
          write(i_log,*) iZ,' but according'
          write(i_log,*) 'to binding energies and thresholds ',eii_nshel
     *    ls(iZ)
          write(i_log,*) 'shells are required'
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'This is a fatal error.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        DO 14541 ish=1,nsh
          read(eii_unit,*,err=14510,end=14510) fmax
          read(eii_unit,*,err=14510,end=14510) aux_array
          IF ((ish.GT.1 .AND. ish .LT. 5)) THEN
            fmax = fmax*eii_L_factor
          END IF
          IF (( ish .LE. eii_nshells(iZ) )) THEN
            IF ((xsec_out .EQ. 1)) THEN
              IF ((ish .EQ. 1)) THEN
                write(eii_out,'(a,f10.2,a)') 'K-shell sigma_max = ',fmax
     *          ,' b/atom'
              ELSE IF((ish .EQ. 2)) THEN
                write(eii_out,'(a,f9.2,a)') '=> LI-shell sigma_max = ',f
     *          max,' b/atom'
              ELSE IF((ish .EQ. 3)) THEN
                write(eii_out,'(a,f8.2,a)') '=> LII-shell sigma_max = ',
     *          fmax,' b/atom'
              ELSE IF((ish .EQ. 4)) THEN
                write(eii_out,'(a,f8.2,a)') '=> LIII-shell sigma_max = '
     *          ,fmax,' b/atom'
              ELSE
                write(eii_out,*) '=> Wrong number of shells!'
              END IF
              write(eii_out,*) '   E/keV     sigma/(b/atom)'
              write(eii_out,*) '---------------------------'
            END IF
            ii = ii+1
            eii_z(ii) = iZ
            eii_sh(ii) = ish
            eii_a(ii) = nbin
            eii_a(ii) = eii_a(ii)/log(emax/binding_energies(ish,iZ))
            eii_b(ii) = 1 - eii_a(ii)*log(binding_energies(ish,iZ))
            DO 14551 k=1,nbin
              IF (( k .GT. 1 )) THEN
                sigo = fmax*aux_array(k-1)
              ELSE
                sigo = 0
              END IF
              loge = (k - eii_b(ii))/eii_a(ii)
              iii = nbin*(ii-1)+k
              eii_xsection_a(iii) = (fmax*aux_array(k)-sigo)*eii_a(ii)
              eii_xsection_b(iii) = sigo - eii_xsection_a(iii)*loge
              IF ((xsec_out .EQ. 1)) THEN
                write(eii_out,'(f12.2,2X,10f9.2)') Exp((k+1-eii_b(ii))/e
     *          ii_a(ii))*1000.0,fmax*aux_array(k)
              END IF
14551       CONTINUE
14552       CONTINUE
          END IF
14541   CONTINUE
14542   CONTINUE
        IF (( ii .EQ. nsh_tot )) THEN
          GO TO14532
        END IF
14531 CONTINUE
14532 CONTINUE
      close(eii_unit)
      IF ((xsec_out .EQ. 1)) THEN
        close(eii_out)
      END IF
      write(i_log,*) ' OK '
      write(i_log,*) ' '
      DO 14561 imed=1,nmed
        Ec = ae(imed) - rm
        Ecc = min(Ec,ap(imed))
        sum_z=0
        sum_pz=0
        sum_a=0
        sum_wa=0
        DO 14571 iele=1,nne(imed)
          sum_z = sum_z + pz(imed,iele)*zelem(imed,iele)
          sum_pz = sum_pz + pz(imed,iele)
          sum_wa = sum_wa + rhoz(imed,iele)
          sum_a = sum_a + pz(imed,iele)*wa(imed,iele)
14571   CONTINUE
14572   CONTINUE
        con_med = rho(imed)/1.6605655/sum_a
        eii_cons(imed) = con_med
        IF (( eii_nsh(imed) .GT. 0 )) THEN
          is_monotone = .true.
          sigma_max = 0
          DO 14581 j=1,meke(imed)
            loge = (j - eke0(imed))/eke1(imed)
            e = Exp(loge)
            tau = e/rm
            beta2 = tau*(tau+2)/(tau+1)**2
            p2 = 2*rm*tau*(tau+2)
            lloge = j
            medium = imed
            dedx=ededx1(Lloge,MEDIUM)*loge+ededx0(Lloge,MEDIUM)
            IF (( e .GT. ap(medium) .OR. e .GT. 2*Ec )) THEN
              sig=esig1(Lloge,MEDIUM)*loge+esig0(Lloge,MEDIUM)
            ELSE
              sig = 0
            END IF
            IF (( e .GT. 2*Ec )) THEN
              wbrem=ebr11(Lloge,MEDIUM)*loge+ebr10(Lloge,MEDIUM)
              sigm = sig*(1-wbrem)
            ELSE
              sigm = 0
              wbrem = 1
            END IF
            sum_occn=0
            sum_sigma=0
            sum_dedx=0
            DO 14591 iele=1,nne(imed)
              iZ = int(zelem(imed,iele)+0.5)
              sum_sh = 0
              DO 14601 ish=1,eii_no(imed,iele)
                jj = eii_first(imed,iele) + ish - 1
                jjj = eii_sh(jj)
                U = binding_energies(jjj,iZ)
                Wmax = (e+U)/2
                uwm = U/Wmax
                IF (( U .LT. e .AND. U .GT. Ecc )) THEN
                  sum_sh = sum_sh + occn_numbers(jjj)
                  ss_0 = 2*(log(p2/U)-uwm**3*log(p2/Wmax)- (beta2+0.8333
     *            33)*(1-uwm**3))/3/U
                  sh_0 = ((1-uwm)*(1+uwm/(2-uwm))+U*(Wmax-U)/(e+rm)**2 -
     *             (2*tau+1)/(tau+1)**2*uwm/2*log((2-uwm)/uwm))/U
                  ss_1 = log(p2/U)-uwm**2*log(p2/Wmax)- (beta2+1)*(1-uwm
     *            **2)
                  sh_1 = log(Wmax/U/(2-uwm))+2*(Wmax-U)/(2*Wmax-U) +(Wma
     *            x**2-U**2)/(e+rm)**2/2 -(2*tau+1)/(tau+1)**2*log((2*Wm
     *            ax-U)/Wmax)
                  av_E = (ss_1 + sh_1)/(ss_0 + sh_0)
                  i = eii_a(jjj)*loge + eii_b(jjj)
                  i = (jj-1)*250 + i
                  sig_j = eii_xsection_a(i)*loge + eii_xsection_b(i)
                  sig_j = sig_j*pz(imed,iele)*con_med
                  sum_sigma = sum_sigma + sig_j
                  sum_dedx = sum_dedx + sig_j*av_E
                END IF
14601         CONTINUE
14602         CONTINUE
              sum_occn = sum_occn + sum_sh*pz(imed,iele)
14591       CONTINUE
14592       CONTINUE
            sigm = sigm + sum_sigma
            dedx = dedx - sum_dedx
            aux = Ec/e
            IF (( e .GT. 2*Ec )) THEN
              sigo = cons*sum_occn*rho(imed)/(beta2*Ec)*( (1-2*aux)*(1+a
     *        ux/(1-aux)+(tau/(tau+1))**2*aux/2)- (2*tau+1)/(tau+1)**2*a
     *        ux*log((1-aux)/aux))/sum_a
              de = cons*sum_occn*rho(imed)/beta2*( log(0.25/aux/(1-aux))
     *        +(1-2*aux)/(1-aux)+ (tau/(tau+1))**2*(1-4*aux*aux)/8- (2*t
     *        au+1)/(tau+1)**2*log(2*(1-aux)))/sum_a
              sigm = sigm - sigo
              dedx = dedx + de
            END IF
            sigma = sigm + wbrem*sig
            IF((sigma/dedx .GT. sigma_max))sigma_max = sigma/dedx
            IF (( sigma .GT. 0 )) THEN
              wbrem = wbrem*sig/sigma
            ELSE
              wbrem = 1
            END IF
            IF (( j .GT. 1 )) THEN
              ededx1(j-1,imed) = (dedx - dedx_old)*eke1(imed)
              ededx0(j-1,imed) = dedx - ededx1(j-1,imed)*loge
              esig1(j-1,imed) = (sigma - sigma_old)*eke1(imed)
              esig0(j-1,imed) = sigma - esig1(j-1,imed)*loge
              ebr11(j-1,imed) = (wbrem - wbrem_old)*eke1(imed)
              ebr10(j-1,imed) = wbrem - ebr11(j-1,imed)*loge
              IF((sigma/dedx .LT. sigma_old/dedx_old))is_monotone = .fal
     *        se.
            END IF
            dedx_old = dedx
            sigm_old = sigm
            sigma_old = sigma
            wbrem_old = wbrem
14581     CONTINUE
14582     CONTINUE
          ededx1(meke(imed),imed) = ededx1(meke(imed)-1,imed)
          ededx0(meke(imed),imed) = ededx0(meke(imed)-1,imed)
          esig1(meke(imed),imed) = esig1(meke(imed)-1,imed)
          esig0(meke(imed),imed) = esig0(meke(imed)-1,imed)
          ebr11(meke(imed),imed) = ebr11(meke(imed)-1,imed)
          ebr10(meke(imed),imed) = ebr10(meke(imed)-1,imed)
          write(i_log,*) 'eii_init: for medium ',imed,' adjusted sige =
     *', sigma_max,' monotone = ',is_monotone
          sig_ismonotone(0,imed) = is_monotone
          esig_e(imed) = sigma_max
        END IF
14561 CONTINUE
14562 CONTINUE
      return
14510 write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'I/O error while reading EII data'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
14500 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(//a,a,/a,/a/)') 'Failed to open EII data file ',eii_
     *file(:lnblnk1(eii_file)), 'Make sure file exists in your $HEN_HOUS
     *E/data directory!', '****BEWARE of case sensitive file names!!!'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine eii_sample(ish,iZ,Uj)
      implicit none
      integer*4 ish,iZ
      real*8 Uj
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(6), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),  e
     *ii_sh(40),  eii_nshells(100),  eii_nsh(6),  eii_first(6,50),  eii_
     *no(6,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      common/egs_vr/ e_max_rr( 2001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 2001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      real*8 T,tau,tau1,tau12,tau2,p2,beta2,c1,c2,Wmax,xmax,fm_s,fm_h,pr
     *ob_s,prob
      real*8 r1,r2,r3,wx,wxx,aux,frej
      real*8 peie,pese1,pese2,dcosth,h1
      integer*4 iarg
      real*8 eta,cphi,sphi
      integer*4 np_save,ip,j
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      peie = e(np)
      T = peie - rm
      tau = T/rm
      tau1 = tau+1
      tau12 = tau1*tau1
      tau2 = tau*tau
      p2 = tau2 + 2*tau
      beta2 = p2/tau12
      Wmax = 0.5*(T+Uj)
      xmax = Uj/Wmax
      c1 = (Wmax/peie)**2
      c2 = (2*tau+1)/tau12
      fm_s = log(rmt2*p2/Uj) - beta2 - 0.5
      prob_s = 0.66666667*fm_s*(1+xmax+xmax*xmax)
      fm_h = 2 + c1 - c2
      IF((fm_h .LT. 1))fm_h = 1
      prob = fm_h + prob_s
14611 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        r1 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((rng_seed .GT. 128))call ranmar_get
        r2 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((rng_seed .GT. 128))call ranmar_get
        r3 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( r1*prob .LT. fm_h )) THEN
          wx = 1/(r2*xmax+1-r2)
          wxx = wx*xmax
          aux = wxx/(2-wxx)
          frej = (1 + aux*(aux-c2)+c1*wxx*wxx)/fm_h
        ELSE
          wx = 1/(r2*xmax**3+1-r2)**0.333333333
          frej = 1 - log(wx)/fm_s
        END IF
        IF((( r3 .LT. frej )))GO TO14612
      GO TO 14611
14612 CONTINUE
      wx = wx*Uj
      h1 = (peie + prm)/T
      pese1 = peie - wx
      e(np) = pese1
      dcosth = h1*(pese1-prm)/(pese1+prm)
      sinthe = dsqrt(1-dcosth)
      costhe = dsqrt(dcosth)
      call uphi(2,1)
      pese2 = wx - Uj + prm
      edep_local = 0
      IF (( pese2 .GT. ae(medium) )) THEN
        IF (( np+1 .GT. 150 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','eii_sample
     *', ' stack size exceeded! ',' $MAXSTACK = ',150,' np = ',np+1
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        np = np+1
        e(np) = pese2
        dcosth = h1*(pese2-prm)/(pese2+prm)
        sinthe = -dsqrt(1-dcosth)
        costhe = dsqrt(dcosth)
        iq(np) = -1
        call uphi(3,2)
        edep = 0
      ELSE
        edep = wx - Uj
        edep_local = edep
        IARG=34
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
      END IF
      call relax(Uj,ish,iZ)
      IF (( edep .GT. 0 )) THEN
        IARG=4
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
      END IF
      return
      end
      subroutine egs_scale_photon_xsection(imed,fac,which)
      implicit none
      integer*4 imed,which
      real*8 fac
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(6), GE0(6),GE1(6), GMFP0(2000,6),GMFP1(2000,
     *6),GBR10(2000,6),GBR11(2000,6),GBR20(2000,6),GBR21(2000,6), RCO0(6
     *),RCO1(6), RSCT0(100,6),RSCT1(100,6), COHE0(2000,6),COHE1(2000,6),
     *  PHOTONUC0(2000,6),PHOTONUC1(2000,6), DPMFP, MPGEM(1,6), NGR(6)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 ifirst,ilast,medium,j
      logical has_r
      real*8 gle,gmfp,gbr1,gbr2,cohfac,aux,gmfp_old,gbr1_old,gbr2_old,co
     *hfac_old
      character*8 strings(5)
      data strings/'photon','Rayleigh','Compton','pair','photo'/
      IF (( which .LT. 0 .OR. which .GT. 4 )) THEN
        return
      END IF
      IF (( imed .GT. 0 .AND. imed .LE. nmed )) THEN
        ifirst = imed
        ilast = imed
      ELSE
        ifirst = 1
        ilast = nmed
      END IF
      IF (( which .EQ. 1 )) THEN
        has_r = .false.
        DO 14621 medium=ifirst,ilast
          IF (( iraylm(medium) .EQ. 1 )) THEN
            has_r = .true.
          END IF
14621   CONTINUE
14622   CONTINUE
        IF((.NOT.has_r))return
      END IF
      write(i_log,*) ' '
      DO 14631 medium=ifirst,ilast
        write(i_log,'(a,a,a,i3,a,f9.5)') 'Scaling ',strings(which+1),' x
     *-section data for medium', medium,' with ',fac
        DO 14641 j=1,mge(medium)
          gle = (j - ge0(medium))/ge1(medium)
          gmfp = gmfp0(j,medium) + gmfp1(j,medium)*gle
          gbr1 = gbr10(j,medium) + gbr11(j,medium)*gle
          gbr2 = gbr20(j,medium) + gbr21(j,medium)*gle
          IF (( iraylm(medium) .EQ. 1 )) THEN
            cohfac = cohe0(j,medium) + cohe1(j,medium)*gle
          ELSE
            cohfac = 1
          END IF
          IF (( which .EQ. 0 )) THEN
            gmfp = gmfp/fac
          ELSE IF(( which .EQ. 1 )) THEN
            cohfac = cohfac/(fac*(1-cohfac)+cohfac)
          ELSE
            IF (( which .EQ. 2 )) THEN
              aux = fac*(gbr2-gbr1) + gbr1 + 1 - gbr2
              gbr2 = (gbr1 + fac*(gbr2-gbr1))/aux
              gbr1 = gbr1/aux
            ELSE IF(( which .EQ. 3 )) THEN
              aux = fac*gbr1 + 1 - gbr1
              gbr2 = (fac*gbr1 + gbr2-gbr1)/aux
              gbr1 = fac*gbr1/aux
            ELSE
              aux = gbr2 + fac*(1-gbr2)
              gbr1 = gbr1/aux
              gbr2 = gbr2/aux
            END IF
            gmfp = gmfp/aux
            cohfac = cohfac*aux/(aux*cohfac + 1 - cohfac)
          END IF
          IF (( j .GT. 1 )) THEN
            gmfp1(j-1,medium) = (gmfp - gmfp_old)*ge1(medium)
            gmfp0(j-1,medium) = gmfp - gmfp1(j-1,medium)*gle
            gbr11(j-1,medium) = (gbr1 - gbr1_old)*ge1(medium)
            gbr10(j-1,medium) = gbr1 - gbr11(j-1,medium)*gle
            gbr21(j-1,medium) = (gbr2 - gbr2_old)*ge1(medium)
            gbr20(j-1,medium) = gbr2 - gbr21(j-1,medium)*gle
            cohe1(j-1,medium) = (cohfac - cohfac_old)*ge1(medium)
            cohe0(j-1,medium) = cohfac - cohe1(j-1,medium)*gle
          END IF
          gmfp_old = gmfp
          gbr1_old = gbr1
          gbr2_old = gbr2
          cohfac_old = cohfac
14641   CONTINUE
14642   CONTINUE
        gmfp1(mge(medium),medium) = gmfp1(mge(medium)-1,medium)
        gmfp0(mge(medium),medium) = gmfp0(mge(medium)-1,medium)
        gbr11(mge(medium),medium) = gbr11(mge(medium)-1,medium)
        gbr10(mge(medium),medium) = gbr10(mge(medium)-1,medium)
        gbr21(mge(medium),medium) = gbr21(mge(medium)-1,medium)
        gbr20(mge(medium),medium) = gbr20(mge(medium)-1,medium)
        cohe1(mge(medium),medium) = cohe1(mge(medium)-1,medium)
        cohe0(mge(medium),medium) = cohe0(mge(medium)-1,medium)
14631 CONTINUE
14632 CONTINUE
      return
      end
      subroutine egs_init_user_photon(prefix,comp_prefix,photonuc_prefix
     *,out)
      implicit none
      character*(*) prefix, comp_prefix,  photonuc_prefix
      integer*4 out
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 2001),IPHTER( 2001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(6), GE0(6),GE1(6), GMFP0(2000,6),GMFP1(2000,
     *6),GBR10(2000,6),GBR11(2000,6),GBR20(2000,6),GBR21(2000,6), RCO0(6
     *),RCO1(6), RSCT0(100,6),RSCT1(100,6), COHE0(2000,6),COHE1(2000,6),
     *  PHOTONUC0(2000,6),PHOTONUC1(2000,6), DPMFP, MPGEM(1,6), NGR(6)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,6), eno_array(200,6), eno_atbin_array(200,6), n_sh
     *ell(6), radc_flag,  ibcmp( 2001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      integer*4 lnblnk1,egs_get_unit,medium, photo_unit,pair_unit,raylei
     *gh_unit,triplet_unit, ounit,egs_open_file,compton_unit,  photonuc_
     *unit
      integer*4 nge,sorted(50),i,j,k,iz,iz_old,ndat
      real*8 z_sorted(50),pz_sorted(50)
      real*8 sig_photo(2000),sig_pair(2000),sig_triplet(2000), sig_rayle
     *igh(2000),sig_compton(2000)
      real*8 sigma,cohe,gmfp,gbr1,gbr2,sig_KN,gle,e,sig_p
      real*8 cohe_old,gmfp_old,gbr1_old,gbr2_old,  sig_photonuc(2000), p
     *hotonuc, photonuc_old
      real*8 etmp(2000),ftmp(2000)
      real*8 sumZ,sumA,con1,con2,egs_KN_sigma0
      real*8 bc_emin,bc_emax,bc_dle,bc_data(183),bc_tmp(183),bcf,aj
      integer*4 bc_ne
      logical input_compton_data,  input_photonuc_data
      character data_dir*128,photo_file*140,pair_file*140,rayleigh_file*
     *144, triplet_file*142,tmp_string*144,compton_file*144,  photonuc_f
     *ile*144
      write(i_log,'(/a$)') '(Re)-initializing photon cross sections'
      write(i_log,'(a,a/)') ' with files from the series: ', prefix(:lnb
     *lnk1(prefix))
      write(i_log,'(a,a)') ' Compton cross sections: ',comp_prefix(:lnbl
     *nk1(comp_prefix))
      IF ((iphotonuc .EQ. 1)) THEN
        write(i_log,'(a,a)') ' Photonuclear cross sections: ', photonuc_
     *  prefix(:lnblnk1(photonuc_prefix))
        input_photonuc_data = .false.
        IF ((lnblnk1(photonuc_prefix) .GT. 0 .AND. photonuc_prefix(1:7)
     *  .NE. 'default')) THEN
          input_photonuc_data = .true.
        END IF
      END IF
      input_compton_data = .false.
      IF (( ibcmp(1) .GT. 1 .AND. lnblnk1(comp_prefix) .GT. 0 )) THEN
        IF((comp_prefix(1:7) .NE. 'default'))input_compton_data = .true.
      END IF
      data_dir = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      photo_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(prefi
     *x)) // '_photo.data'
      pair_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(prefix
     *)) // '_pair.data'
      triplet_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(pre
     *fix)) // '_triplet.data'
      rayleigh_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(pr
     *efix)) // '_rayleigh.data'
      IF (( input_compton_data )) THEN
        compton_file = data_dir(:lnblnk1(data_dir)) // comp_prefix(:lnbl
     *  nk1(comp_prefix)) // '_compton.data'
      ELSE
        compton_file = data_dir(:lnblnk1(data_dir)) // 'compton_sigma.da
     *ta'
      END IF
      write(i_log,'(a,a)') ' Using Compton cross sections from ', compto
     *n_file(:lnblnk1(compton_file))
      IF ((iphotonuc .EQ. 1)) THEN
        IF (( input_photonuc_data )) THEN
          photonuc_file = data_dir(:lnblnk1(data_dir)) // photonuc_prefi
     *    x(:lnblnk1(photonuc_prefix)) // '_photonuc.data'
        ELSE
          photonuc_file = data_dir(:lnblnk1(data_dir)) // 'iaea_photonuc
     *.data'
        END IF
        write(i_log,'(a,a)') ' Using photonuclear cross sections from ',
     *   photonuc_file(:lnblnk1(photonuc_file))
      END IF
      photo_unit = 83
      photo_unit = egs_get_unit(photo_unit)
      IF (( photo_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = photo_file
      open(photo_unit,file=photo_file,status='old',err=14650)
      pair_unit = 84
      pair_unit = egs_get_unit(pair_unit)
      IF (( pair_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = pair_file
      open(pair_unit,file=pair_file,status='old',err=14650)
      triplet_unit = 85
      triplet_unit = egs_get_unit(triplet_unit)
      IF (( triplet_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = triplet_file
      open(triplet_unit,file=triplet_file,status='old',err=14650)
      rayleigh_unit = 86
      rayleigh_unit = egs_get_unit(rayleigh_unit)
      IF (( rayleigh_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = rayleigh_file
      open(rayleigh_unit,file=rayleigh_file,status='old',err=14650)
      IF (( ibcmp(1) .GT. 1 )) THEN
        compton_unit = 88
        compton_unit = egs_get_unit(compton_unit)
        IF (( compton_unit .LT. 1 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'egs_init_user_photon: failed to get a free For
     *tran I/O unit'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        tmp_string = compton_file
        open(compton_unit,file=compton_file,status='old',err=14650)
      END IF
      IF (( iphotonuc .EQ. 1 )) THEN
        photonuc_unit = 89
        photonuc_unit = egs_get_unit(photonuc_unit)
        IF (( photonuc_unit .LT. 1 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'egs_init_user_photon: failed to get a free For
     *tran I/O unit'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        tmp_string = photonuc_file
        open(photonuc_unit,file=photonuc_file,status='old',err=14650)
      END IF
      IF (( out .EQ. 1 )) THEN
        ounit = egs_open_file(87,0,1,'.xsections')
        write(ounit,'(/a,a,a)') 'Photon cross sections initialized from
     *', prefix(:lnblnk1(prefix)),' data files'
        write(ounit,'(a,/)') '==========================================
     *=================================='
        write(ounit,'(a,/)') 'Grid energies and cross sections are outpu
     *t'
        IF ((iphotonuc .EQ. 1)) THEN
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a)') 'Energy','
     * GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ', ' GMFP(cm) '
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a/)') '(MeV)','
     *no Rayleigh','(fraction)','(fraction)','with Rayleigh', 'w/ Ray +
     *photnuc'
        ELSE
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a)') 'Energy',' GMFP(
     *cm) ',' Pair ','Compton',' GMFP(cm) '
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a/)') '(MeV)','no Ray
     *leigh','(fraction)','(fraction)','with Rayleigh'
        END IF
      END IF
      DO 14661 iz=1,100
        read(photo_unit,*) ndat
        read(photo_unit,*) (etmp(k),ftmp(k),k=1,ndat)
        k = 0
        DO 14671 j=ndat,2,-1
          IF (( etmp(j)-etmp(j-1) .LT. 1e-5 )) THEN
            k = k+1
            IF (( k .LE. 30 )) THEN
              binding_energies(k,iz) = exp(etmp(j))
            ELSE
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,'(i3,a,i3,//a)') k,' binding energies read exc
     *eeding array size of', 30,'Increase $MXSHXSEC in egsnrc.macros!'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            IF((.NOT.eadl_relax .AND. k .GE. 4))GO TO14672
          END IF
14671   CONTINUE
14672   CONTINUE
14661 CONTINUE
14662 CONTINUE
      IF ((mcdf_pe_xsections)) THEN
        call egs_read_shellwise_pe()
      END IF
      DO 14681 medium=1,nmed
        mge(medium) = 2000
        nge = 2000
        ge1(medium) = nge-1
        ge1(medium) = ge1(medium)/log(up(medium)/ap(medium))
        ge0(medium) = 1 - ge1(medium)*log(ap(medium))
        write(i_log,'(a,i3,a,$)') ' Working on medium ',medium,' ... '
        IF (( out .EQ. 1 )) THEN
          write(ounit,'(/,2x,a,i3,a,24a1/)') 'Medium ',medium,': ', (med
     *    ia(k,medium),k=1,24)
        END IF
        sumZ=0
        sumA=0
        DO 14691 i=1,nne(medium)
          z_sorted(i) = zelem(medium,i)
          sumZ = sumZ + pz(medium,i)*zelem(medium,i)
          sumA = sumA + pz(medium,i)*wa(medium,i)
14691   CONTINUE
14692   CONTINUE
        con1 = sumZ*rho(medium)/(sumA*1.6605655)
        con2 = rho(medium)/(sumA*1.6605655)
        call egs_heap_sort(nne(medium),z_sorted,sorted)
        DO 14701 i=1,nne(medium)
          pz_sorted(i) = pz(medium,sorted(i))
14701   CONTINUE
14702   CONTINUE
        IF ((mcdf_pe_xsections)) THEN
          call egsi_get_shell_data(medium,nge,nne(medium),z_sorted,pz_so
     *    rted, ge1(medium),ge0(medium),sig_photo)
        ELSE
          call egsi_get_data(0,photo_unit,nge,nne(medium),z_sorted,pz_so
     *    rted, ge1(medium),ge0(medium),sig_photo)
        END IF
        call egsi_get_data(0,rayleigh_unit,nge,nne(medium),z_sorted,pz_s
     *  orted, ge1(medium),ge0(medium),sig_rayleigh)
        call egsi_get_data(1,pair_unit,nge,nne(medium),z_sorted,pz_sorte
     *  d, ge1(medium),ge0(medium),sig_pair)
        call egsi_get_data(2,triplet_unit,nge,nne(medium),z_sorted,pz_so
     *  rted, ge1(medium),ge0(medium),sig_triplet)
        IF (( iphotonuc .EQ. 1 )) THEN
          call egsi_get_data(3,photonuc_unit,nge,nne(medium),z_sorted,pz
     *    _sorted, ge1(medium),ge0(medium),sig_photonuc)
        END IF
        IF (( ibcmp(1) .GT. 1 )) THEN
          IF (( input_compton_data )) THEN
            call egsi_get_data(0,compton_unit,nge,nne(medium), z_sorted,
     *      pz_sorted,ge1(medium),ge0(medium), sig_compton)
          ELSE
            rewind(compton_unit)
            read(compton_unit,*) bc_emin,bc_emax,bc_ne
            IF (( bc_ne .GT. 183 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'Number of input Compton data exceeds array
     * size'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            bc_dle = log(bc_emax/bc_emin)/(bc_ne-1)
            DO 14711 j=1,bc_ne
              bc_data(j) = 0
14711       CONTINUE
14712       CONTINUE
            iz_old = 1
            DO 14721 i=1,nne(medium)
              iz = int(z_sorted(i)+0.5)
              DO 14731 j=iz_old,iz
                read(compton_unit,*) (bc_tmp(k),k=1,bc_ne)
14731         CONTINUE
14732         CONTINUE
              DO 14741 j=1,bc_ne
                bc_data(j)=bc_data(j)+pz_sorted(i)*z_sorted(i)*bc_tmp(j)
14741         CONTINUE
14742         CONTINUE
              iz_old = iz+1
14721       CONTINUE
14722       CONTINUE
            DO 14751 j=1,bc_ne
              bc_data(j)=log(bc_data(j)/sumZ)
14751       CONTINUE
14752       CONTINUE
          END IF
        END IF
        call egs_init_rayleigh(medium,sig_rayleigh)
        DO 14761 i=1,nge
          gle = (i - ge0(medium))/ge1(medium)
          e = exp(gle)
          sig_KN = sumZ*egs_KN_sigma0(e)
          IF (( ibcmp(1) .GT. 1 )) THEN
            IF (( input_compton_data )) THEN
              sig_KN = sig_compton(i)
            ELSE
              IF (( e .LE. bc_emin )) THEN
                bcf = exp(bc_data(1))
              ELSE IF(( e .LT. bc_emax )) THEN
                aj = 1 + log(e/bc_emin)/bc_dle
                j = int(aj)
                aj = aj - j
                bcf = exp(bc_data(j)*(1-aj) + bc_data(j+1)*aj)
              ELSE
                bcf = 1
              END IF
              sig_KN = sig_KN*bcf
            END IF
          END IF
          sig_p = sig_pair(i) + sig_triplet(i)
          sigma = sig_KN + sig_p + sig_photo(i)
          gmfp = 1/(sigma*con2)
          gbr1 = sig_p/sigma
          gbr2 = gbr1 + sig_KN/sigma
          cohe = sigma/(sig_rayleigh(i) + sigma)
          photonuc = sigma/(sig_photonuc(i) + sigma)
          IF (( out .EQ. 1 )) THEN
            IF ((iphotonucm(medium) .EQ. 1)) THEN
              write(ounit,'(6(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1, gmfp*co
     *        he,gmfp*cohe*photonuc
            ELSE
              write(ounit,'(5(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,gmfp*coh
     *        e
            END IF
          END IF
          IF (( i .GT. 1 )) THEN
            gmfp1(i-1,medium) = (gmfp - gmfp_old)*ge1(medium)
            gmfp0(i-1,medium) = gmfp - gmfp1(i-1,medium)*gle
            gbr11(i-1,medium) = (gbr1 - gbr1_old)*ge1(medium)
            gbr10(i-1,medium) = gbr1 - gbr11(i-1,medium)*gle
            gbr21(i-1,medium) = (gbr2 - gbr2_old)*ge1(medium)
            gbr20(i-1,medium) = gbr2 - gbr21(i-1,medium)*gle
            cohe1(i-1,medium) = (cohe - cohe_old)*ge1(medium)
            cohe0(i-1,medium) = cohe - cohe1(i-1,medium)*gle
            photonuc1(i-1,medium) = (photonuc - photonuc_old)*ge1(medium
     *      )
            photonuc0(i-1,medium) = photonuc - photonuc1(i-1,medium)*gle
          END IF
          gmfp_old = gmfp
          gbr1_old = gbr1
          gbr2_old = gbr2
          cohe_old = cohe
          photonuc_old = photonuc
14761   CONTINUE
14762   CONTINUE
        gmfp1(nge,medium) = gmfp1(nge-1,medium)
        gmfp0(nge,medium) = gmfp - gmfp1(nge,medium)*gle
        gbr11(nge,medium) = gbr11(nge-1,medium)
        gbr10(nge,medium) = gbr1 - gbr11(nge,medium)*gle
        gbr21(nge,medium) = gbr21(nge-1,medium)
        gbr20(nge,medium) = gbr2 - gbr21(nge,medium)*gle
        cohe1(nge,medium) = cohe1(nge-1,medium)
        cohe0(nge,medium) = cohe - cohe1(nge,medium)*gle
        photonuc1(nge,medium) = photonuc1(nge-1,medium)
        photonuc0(nge,medium) = photonuc - photonuc1(nge,medium)*gle
        write(i_log,'(a)') 'OK'
14681 CONTINUE
14682 CONTINUE
      close(photo_unit)
      close(pair_unit)
      close(triplet_unit)
      close(rayleigh_unit)
      IF (( iphotonuc .EQ. 1 )) THEN
        close(photonuc_unit)
      END IF
      IF (( ibcmp(1) .GT. 1 )) THEN
        close(compton_unit)
      END IF
      IF (( out .EQ. 1 )) THEN
        close(ounit)
      END IF
      return
14650 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(//a,a)') 'Failed to open data file ',tmp_string(:lnb
     *lnk1(tmp_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_init_rayleigh(medium,sig_rayleigh)
      implicit none
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PHOTIN/ EBINDA(6), GE0(6),GE1(6), GMFP0(2000,6),GMFP1(2000,
     *6),GBR10(2000,6),GBR11(2000,6),GBR20(2000,6),GBR21(2000,6), RCO0(6
     *),RCO1(6), RSCT0(100,6),RSCT1(100,6), COHE0(2000,6),COHE1(2000,6),
     *  PHOTONUC0(2000,6),PHOTONUC1(2000,6), DPMFP, MPGEM(1,6), NGR(6)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/rayleigh_inputs/iray_ff_media(6),iray_ff_file(6)
      character*24 iray_ff_media
      character*128 iray_ff_file
      COMMON/rayleigh_sampling/xgrid(100,6), fcum(100,6), b_array(100,6)
     *, c_array(100,6), i_array(100,6), pmax0(2000,6),pmax1(2000,6)
      real*8 xgrid, fcum, b_array, c_array,pmax0, pmax1
      integer*4 i_array
      real*8 xval(100),aff(100,100),ff(100,6)
      real*8 xsc, fsc
      real*8 sig_rayleigh(2000), pe_array(2000,6)
      real*8 e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA
      real*8 totRayleigh2,pzmin
      real*8 emin, emax
      integer*4 i,j,k,ff_unit, egs_get_unit, ne
      integer*4 lnblnk1, EOF, nff, medium, ncustom
      character dummy*24, afac_file*128, ff_file*128
      IF ((iraylm(medium).EQ.0)) THEN
        return
      END IF
      ncustom=0
      write(dummy,'(24a1)')(media(j,medium),j=1,24)
      ff_file=' '
      DO 14771 i=1,6
        IF ((lnblnk1(iray_ff_file(i)).NE.0)) THEN
          ncustom = ncustom + 1
        END IF
14771 CONTINUE
14772 CONTINUE
      DO 14781 i=1,ncustom
        IF ((dummy(:lnblnk1(dummy)) .EQ. iray_ff_media(i))) THEN
          ff_file = iray_ff_file(i)
        END IF
14781 CONTINUE
14782 CONTINUE
      ff_unit = egs_get_unit(0)
      IF (( ff_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_rayleigh: failed to get a free Fortran
     *I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( lnblnk1(ff_file) .GT. 0)) THEN
        open(ff_unit,file=ff_file(:lnblnk1(ff_file)), status='old',err=1
     *  4790)
        GOTO 14800
14790   write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(2a)') 'egs_init_rayleigh: failed to open custom ff
     * file ', ff_file(:lnblnk1(ff_file))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
14800   write(i_log,'(/2a)') 'Opened custom ff file ',ff_file(:lnblnk1(f
     *  f_file))
        j = 0
14811   CONTINUE
          j = j + 1
          read(ff_unit,*,IOSTAT=EOF) xsc, fsc
          IF((EOF .LT. 0))GO TO14812
          IF ((j .LE. 100)) THEN
            xgrid(j,medium)=xsc
            ff(j,medium)=fsc
          END IF
        GO TO 14811
14812   CONTINUE
        nff = j-1
        IF ((nff .GT. 100)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,/,a,i5,a,i5,/,a)') 'subroutine egs_init_raylei
     *gh: form factors size too small!!', '$XRAYFF =  ', 100,', and need
     * to be ',nff, ' and try again!!!'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF((xgrid(1,medium) .LT. 1e-6))xgrid(1,medium) = 1e-4
        write(*,*) '\n  -> ', nff, ' values of mol. ff read!'
        sumA = 0.0
        DO 14821 j=1,nne(medium)
          sumA=sumA+PZ(medium,j)*WA(medium,j)
14821   CONTINUE
14822   CONTINUE
        DO 14831 j=1,MGE(medium)
          gle=(j-GE0(medium))/GE1(medium)
          e=exp(gle)
          sig_rayleigh(j)=egs_rayleigh_sigma(medium,e,nff, xgrid(1,mediu
     *    m),ff(1,medium))*sumA
14831   CONTINUE
14832   CONTINUE
      ELSE
        DO 14841 i=1,len(afac_file)
          afac_file(i:i) = ' '
14841   CONTINUE
14842   CONTINUE
        afac_file = hen_house(:lnblnk1(hen_house))//'pegs4'//'/'//'pgs4f
     *orm.dat'
        open(ff_unit,file=afac_file(:lnblnk1(afac_file)), status='old',e
     *  rr=14850)
        GOTO 14860
14850   write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(2a)') 'egs_init_rayleigh: failed to open atomic ff
     * file', afac_file(:lnblnk1(afac_file))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
14860   read(ff_unit,*) xval, aff
        DO 14871 i=1,100
          ff(i,medium) = 0.0
          xgrid(i,medium)=xval(i)
          DO 14881 j=1,nne(medium)
            ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(mediu
     *      m,j)))**2
14881     CONTINUE
14882     CONTINUE
          ff(i,medium) = sqrt(ff(i,medium))
14871   CONTINUE
14872   CONTINUE
        nff = 100
        IF((xgrid(1,medium) .LT. 1e-6))xgrid(1,medium) = 1e-4
        write(i_log,'(/a,i4,a)') '  -> ', nff, ' atomic ff values comput
     *ed!'
      END IF
      close(ff_unit)
      emin = exp((1 - ge0(medium))/ge1(medium))
      emax = exp((mge(medium) - ge0(medium))/ge1(medium))
      call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium), mge(m
     *edium),emin,emax, pe_array(1,medium),100, fcum(1,medium),i_array(1
     *,medium), b_array(1,medium),c_array(1,medium))
      ne=MGE(medium)
      dle=log(up(medium)/ap(medium))/(ne-1)
      dlei=1/dle
      DO 14891 i=1,ne-1
        gle = (i - ge0(medium))/ge1(medium)
        pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(me
     *  dium)
        pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle
14891 CONTINUE
14892 CONTINUE
      pmax0(ne,medium)=pmax0(ne-1,medium)
      pmax1(ne,medium)=pmax1(ne-1,medium)
      return
      end
      subroutine egs_init_rayleigh_sampling(medium)
      implicit none
      COMMON/THRESH/RMT2,RMSQ, AP(6),AE(6),UP(6),UE(6),TE(6),THMOLL(6)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 2001),MED( 2001),IRAYLR( 2001)
     *,IPHOTONUCR( 2001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PHOTIN/ EBINDA(6), GE0(6),GE1(6), GMFP0(2000,6),GMFP1(2000,
     *6),GBR10(2000,6),GBR11(2000,6),GBR20(2000,6),GBR21(2000,6), RCO0(6
     *),RCO1(6), RSCT0(100,6),RSCT1(100,6), COHE0(2000,6),COHE1(2000,6),
     *  PHOTONUC0(2000,6),PHOTONUC1(2000,6), DPMFP, MPGEM(1,6), NGR(6)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/rayleigh_inputs/iray_ff_media(6),iray_ff_file(6)
      character*24 iray_ff_media
      character*128 iray_ff_file
      COMMON/rayleigh_sampling/xgrid(100,6), fcum(100,6), b_array(100,6)
     *, c_array(100,6), i_array(100,6), pmax0(2000,6),pmax1(2000,6)
      real*8 xgrid, fcum, b_array, c_array,pmax0, pmax1
      integer*4 i_array
      real*8 xval(100),aff(100,100),ff(100,6)
      real*8 xsc, fsc
      real*8 sig_rayleigh(2000), pe_array(2000,6)
      real*8 e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA
      real*8 totRayleigh2,pzmin
      real*8 emin, emax
      integer*4 i,j,k,ff_unit, egs_get_unit, ne
      integer*4 lnblnk1, EOF, nff, medium, ncustom
      character dummy*24, afac_file*128, ff_file*128
      IF ((iraylm(medium).EQ.0)) THEN
        return
      END IF
      ff_unit = egs_get_unit(0)
      IF (( ff_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_rayleigh: failed to get a free Fortran
     *I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      DO 14901 i=1,len(afac_file)
        afac_file(i:i) = ' '
14901 CONTINUE
14902 CONTINUE
      afac_file = hen_house(:lnblnk1(hen_house))//'pegs4'//'/'//'pgs4for
     *m.dat'
      open(ff_unit,file=afac_file(:lnblnk1(afac_file)),status='old',err=
     *14850)
      GOTO 14860
14850 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(2a)') 'egs_init_rayleigh_sampling: failed to open at
     *omic ff file ', afac_file(:lnblnk1(afac_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
14860 read(ff_unit,*) xval, aff
      DO 14911 i=1,100
        ff(i,medium) = 0.0
        xgrid(i,medium)=xval(i)
        DO 14921 j=1,nne(medium)
          ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,
     *    j)))**2
14921   CONTINUE
14922   CONTINUE
        ff(i,medium) = sqrt(ff(i,medium))
14911 CONTINUE
14912 CONTINUE
      nff = 100
      IF((xgrid(1,medium) .LT. 1e-6))xgrid(1,medium) = 1e-4
      write(i_log,'(/a,i4,a)') '  -> ', nff, ' atomic ff values computed
     *!'
      close(ff_unit)
      emin = exp((1 - ge0(medium))/ge1(medium))
      emax = exp((mge(medium) - ge0(medium))/ge1(medium))
      call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium), mge(m
     *edium),emin,emax, pe_array(1,medium),100, fcum(1,medium),i_array(1
     *,medium), b_array(1,medium),c_array(1,medium))
      ne=MGE(medium)
      DO 14931 i=1,ne-1
        gle = (i - ge0(medium))/ge1(medium)
        pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(me
     *  dium)
        pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle
14931 CONTINUE
14932 CONTINUE
      pmax0(ne,medium)=pmax0(ne-1,medium)
      pmax1(ne,medium)=pmax1(ne-1,medium)
      return
      end
      real*8 function egs_rayleigh_sigma(imed,E,ndat,x,f)
      implicit none
      integer*4 i, j, k,imed, ndat
      real*8 hc2,conv,b,hc
      parameter (hc = 0.0123984768438,hc2=0.0001537222280)
      real*8 x(100), f(100), zero, E, xmax
      real*8 x1,x2,pow_x1,pow_x2,raysig,C,C2,f1,f2
      C=2.*hc2/(E*E)
      C2=C*C
      xmax=E/hc
      egs_rayleigh_sigma = 0.0
      DO 14941 i=1,ndat-1
        IF((x(i) .EQ. 0.0))x(i) = zero()
        IF((x(i+1) .EQ. 0.0))x(i+1) = zero()
        IF((f(i) .EQ. 0.0))f(i) = zero()
        IF((f(i+1) .EQ. 0.0))f(i+1) = zero()
        b = log(f(i+1)/f(i))/log(x(i+1)/x(i))
        x1=x(i)
        x2=x(i+1)
        IF ((x2 .GT. xmax)) THEN
          x2=xmax
        END IF
        pow_x1=x1**(2*b)
        pow_x2=x2**(2*b)
        raysig = pow_x2*(x2**2/(b+1)-(C*x2**4)/(b+2)+(C2*x2**6)/(2*b+6))
        raysig = raysig - pow_x1*(x1**2/(b+1)-(C*x1**4)/(b+2)+(C2*x1**6)
     *  /(2*b+6))
        raysig = raysig*f(i)*f(i)/pow_x1
        egs_rayleigh_sigma = egs_rayleigh_sigma + raysig
        IF ((x(i+1).GT.xmax)) THEN
          GO TO14942
        END IF
14941 CONTINUE
14942 CONTINUE
      egs_rayleigh_sigma = 0.49893439187842413747*C*egs_rayleigh_sigma
      return
      end
      subroutine egs_rayleigh_sampling(medium,e,gle,lgle,costhe,sinthe)
      implicit none
      real*8 e
      real*8 gle,costhe,sinthe,pmax,xv,xmax,csqthe
      real*8 rnnray1,rnnray0,hc_i,twice_hc2,dwi
      parameter(hc_i=80.65506856998,twice_hc2=0.000307444456)
      integer*4 lgle,ib,ibin,medium, trials
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/rayleigh_sampling/xgrid(100,6), fcum(100,6), b_array(100,6)
     *, c_array(100,6), i_array(100,6), pmax0(2000,6),pmax1(2000,6)
      real*8 xgrid, fcum, b_array, c_array,pmax0, pmax1
      integer*4 i_array
      dwi = 100-1
      pmax=pmax1(Lgle,MEDIUM)*gle+pmax0(Lgle,MEDIUM)
      xmax = hc_i*e
14951 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        rnnray1 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
14961   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          rnnray0 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          rnnray0 = rnnray0*pmax
          ibin = 1 + rnnray0*dwi
          ib = i_array(ibin,medium)
          IF (( i_array(ibin+1,medium) .GT. ib )) THEN
14971       CONTINUE
              IF((rnnray0.LT.fcum(ib+1,medium)))GO TO14972
              ib=ib+1
            GO TO 14971
14972       CONTINUE
          END IF
          rnnray0 = (rnnray0 - fcum(ib,medium))*c_array(ib,medium)
          xv = xgrid(ib,medium)*exp(log(1+rnnray0)*b_array(ib,medium))
          IF(((xv .LT. xmax)))GO TO14962
        GO TO 14961
14962   CONTINUE
        xv = xv/e
        costhe = 1 - twice_hc2*xv*xv
        csqthe=costhe*costhe
        IF((( 2*rnnray1 .LT. 1 + csqthe )))GO TO14952
      GO TO 14951
14952 CONTINUE
      sinthe=sqrt(1.0-csqthe)
      return
      end
      subroutine prepare_rayleigh_data(ndat,x,f, ne,emin,emax,pe_array,
     *ncbin,fcum,i_array, b_array,c_array)
      implicit none
      integer*4 ndat
      real*8 x(ndat),  f(ndat)
      integer*4 ne
      real*8 emin,  emax,  pe_array(ne)
      integer*4 ncbin
      real*8 fcum(ndat)
      integer*4 i_array(ncbin)
      real*8 b_array(ndat),  c_array(ndat)
      real*8 zero
      real*8 sum0,a,b,x1,x2,pow_x1,pow_x2,dle,e,xmax, anorm,anorm1,anorm
     *2,w,dw,xold,t,aux
      integer*4 i,j,k,ibin
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      write(*,'(a$)') '      preparing data for Rayleigh sampling ... '
      DO 14981 i=1,ndat
        IF((f(i) .EQ. 0.0))f(i) = zero()
14981 CONTINUE
14982 CONTINUE
      sum0=0
      fcum(1)=0
      DO 14991 i=1,ndat-1
        b = log(f(i+1)/f(i))/log(x(i+1)/x(i))
        b_array(i) = b
        x1 = x(i)
        x2 = x(i+1)
        pow_x1 = x1**(2*b)
        pow_x2 = x2**(2*b)
        sum0=sum0+f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1)
        fcum(i+1) = sum0
14991 CONTINUE
14992 CONTINUE
      dle = log(emax/emin)/(ne-1)
      i = 1
      DO 15001 j=1,ne
        e = emin*exp(dle*(j-1))
        xmax = 20.607544d0*2*e/prm
        DO 15011 k=i,ndat-1
          IF((xmax .GE. x(k) .AND. xmax .LT. x(k+1)))GO TO15012
15011   CONTINUE
15012   CONTINUE
        i = k
        b = b_array(i)
        x1 = x(i)
        x2 = xmax
        pow_x1 = x1**(2*b)
        pow_x2 = x2**(2*b)
        pe_array(j) = fcum(i) + f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((
     *  1+b)*pow_x1)
15001 CONTINUE
15002 CONTINUE
      i_array(ncbin) = i
      anorm = 1d0/sqrt(pe_array(ne))
      anorm1 = 1.005d0/pe_array(ne)
      anorm2 = 1d0/pe_array(ne)
      DO 15021 j=1,ne
        pe_array(j) = pe_array(j)*anorm1
        IF((pe_array(j) .GT. 1))pe_array(j) = 1
15021 CONTINUE
15022 CONTINUE
      DO 15031 j=1,ndat
        f(j) = f(j)*anorm
        fcum(j) = fcum(j)*anorm2
        c_array(j) = (1+b_array(j))/(x(j)*f(j))**2
15031 CONTINUE
15032 CONTINUE
      dw = 1d0/(ncbin-1)
      xold = x(1)
      ibin = 1
      b = b_array(1)
      pow_x1 = x(1)**(2*b)
      i_array(1) = 1
      DO 15041 i=2,ncbin-1
        w = dw
15051   CONTINUE
          x1 = xold
          x2 = x(ibin+1)
          t = x1*x1*x1**(2*b)
          pow_x2 = x2**(2*b)
          aux=f(ibin)*f(ibin)*(x2*x2*pow_x2-t)/((1+b)*pow_x1)
          IF (( aux .GT. w )) THEN
            xold = exp(log(t+w*(1+b)*pow_x1/f(ibin)/f(ibin))/(2+2*b))
            i_array(i) = ibin
            GO TO15052
          END IF
          w = w - aux
          xold = x2
          ibin = ibin+1
          b = b_array(ibin)
          pow_x1 = xold**(2*b)
        GO TO 15051
15052   CONTINUE
15041 CONTINUE
15042 CONTINUE
      DO 15061 j=1,ndat
        b_array(j) = 0.5/(1 + b_array(j))
15061 CONTINUE
15062 CONTINUE
      write(*,'(a /)') 'done'
      return
      end
      real*8 function egs_KN_sigma0(e)
      implicit none
      real*8 e
      real*8 con,ko,c1,c2,c3,eps1,eps2
      data con/0.1274783851/
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      ko = e/prm
      IF (( ko .LT. 0.01 )) THEN
        egs_KN_sigma0 = 8.*con/3.*(1-ko*(2-ko*(5.2-13.3*ko)))/prm
        return
      END IF
      c1 = 1./(ko*ko)
      c2 = 1. - 2*(1+ko)*c1
      c3 = (1+2*ko)*c1
      eps2 = 1
      eps1 = 1./(1+2*ko)
      egs_KN_sigma0 = (c1*(1./eps1-1./eps2)+c2*log(eps2/eps1)+eps2*(c3+0
     *.5*eps2)- eps1*(c3+0.5*eps1))/e*con
      return
      end
      real*8 function egs_KN_sigma1(e)
      implicit none
      real*8 e
      real*8 con,ko,c1,c2,c3,eps1,eps2
      data con/0.1274783851/
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      ko = e/prm
      c1 = 1./(ko*ko)
      c2 = 1. - 2*(1+ko)*c1
      c3 = (1+2*ko)*c1
      eps2 = 1
      eps1 = 1./(1+2*ko)
      egs_KN_sigma1 = c1*(1./eps1-1./eps2)
      egs_KN_sigma1 = egs_KN_sigma1 + log(eps2/eps1)*(c2 - c1) - c2*(eps
     *2-eps1)
      egs_KN_sigma1 = egs_KN_sigma1 + c3*(eps2-eps1)*(1-0.5*(eps1+eps2))
      egs_KN_sigma1 = egs_KN_sigma1 + (eps2-eps1)*(0.5*(eps1+eps2)-(eps1
     **eps1+eps2*eps2+eps1*eps2)/3)
      egs_KN_sigma1 = egs_KN_sigma1*con
      return
      end
      subroutine egsi_get_data(flag,iunit,n,ne,zsorted,pz_sorted,ge1,ge0
     *,data)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 eth
      integer*4 flag,iunit,n,ne
      real*8 ge1,ge0,zsorted(*),pz_sorted(*),data(*)
      real*8 etmp(2000),ftmp(2000)
      real*8 gle,sig,p,e
      integer*4 i,j,k,kk,iz,iz_old,ndat,iiz
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      rewind(iunit)
      iz_old = 0
      DO 15071 k=1,n
        data(k) = 0
15071 CONTINUE
15072 CONTINUE
      DO 15081 i=1,ne
        iiz = int(zsorted(i)+0.5)
        DO 15091 iz=iz_old+1,iiz
          read(iunit,*,err=15100) ndat
          IF (( ndat .GT. 2000 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'Too many input data points. Max. is ',2000
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          IF (( flag .EQ. 0 .OR. flag .EQ. 3)) THEN
            read(iunit,*,err=15100) (etmp(k),ftmp(k),k=1,ndat)
          ELSE
            read(iunit,*,err=15100) (etmp(k+1),ftmp(k+1), k=1,ndat)
            IF (( flag .EQ. 1 )) THEN
              eth = 2*rm
            ELSE
              eth = 4*rm
            END IF
            ndat = ndat + 1
            DO 15111 k=2,ndat
              ftmp(k) = ftmp(k) - 3*log(1-eth/exp(etmp(k)))
15111       CONTINUE
15112       CONTINUE
            ftmp(1) = ftmp(2)
            etmp(1) = log(eth)
          END IF
15091   CONTINUE
15092   CONTINUE
        iz_old = iiz
        DO 15121 k=1,n
          gle = (k - ge0)/ge1
          e = exp(gle)
          IF (( gle .LT. etmp(1) .OR. gle .GE. etmp(ndat) )) THEN
            IF (( flag .EQ. 0 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'Energy ',exp(gle), ' is outside the availa
     *ble data range of ', exp(etmp(1)),exp(etmp(ndat))
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            ELSE IF((flag .EQ. 1 .OR. flag .EQ. 2)) THEN
              IF (( gle .LT. etmp(1) )) THEN
                sig = 0
              ELSE
                sig = exp(ftmp(ndat))
              END IF
            ELSE
              sig = 0
            END IF
          ELSE
            DO 15131 kk=1,ndat-1
              IF((gle .GE. etmp(kk) .AND. gle .LT. etmp(kk+1)))GO TO1513
     *        2
15131       CONTINUE
15132       CONTINUE
            IF (( flag .NE. 3)) THEN
              p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk))
              sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk))
            ELSE
              p = (e - exp(etmp(kk)))/(exp(etmp(kk+1)) - exp(etmp(kk)))
              sig = p*exp(ftmp(kk+1)) + (1-p)*exp(ftmp(kk))
            END IF
          END IF
          IF(((flag .EQ. 1 .OR. flag .EQ. 2) .AND. e .GT. eth))sig = sig
     *    *(1-eth/e)**3
          data(k) = data(k) + pz_sorted(i)*sig
15121   CONTINUE
15122   CONTINUE
15081 CONTINUE
15082 CONTINUE
      return
15100 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Error while reading user photon cross sections fro
     *m unit ', iunit
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egsi_get_shell_data(imed,n,ne,zsorted,pz_sorted,ge1,ge0
     *,data)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/MEDIA/  RLC(6),RLDU(6),RHO(6),MSGE(6),MGE(6),MSEKE(6),MEKE(
     *6),MLEKE(6),MCMFP(6),MRANGE(6),IRAYLM(6),IPHOTONUCM(6), MEDIA(24,6
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,6),   pe_energy(500,100),  pe_zsorted(100,6), pe_be(100,16),
     * pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      real*8 pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      integer*4 n,  ne,  ndat
      real*8 ge1,ge0,zsorted(*),pz_sorted(*),data(*)
      real*8 sigma(500),sigmaMedium
      real*4 etmp(2000),ftmp(2000)
      real*4 gle,sig,p
      integer*4 i,j,k,kk,iz,zpos,imed
      DO 15141 k=1,n
        data(k) = 0
15141 CONTINUE
15142 CONTINUE
      DO 15151 k=1,ne
        sigma(k) = 0
15151 CONTINUE
15152 CONTINUE
      DO 15161 i=1,ne
        iz = int(zsorted(i)+0.5)
        zpos = pe_zpos(iz)
        ndat = pe_nge(zpos)
        DO 15171 k=1,ndat
          pe_elem_prob(k,i,imed) = pz_sorted(i)*pe_xsection(k,zpos,0)
          etmp(k) = pe_energy(k,zpos)
          ftmp(k) = log(pe_xsection(k,zpos,0))
15171   CONTINUE
15172   CONTINUE
        DO 15181 k=1,n
          gle = (k - ge0)/ge1
          IF (( gle .LT. etmp(1) .OR. gle .GE. etmp(ndat) )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'egsi_get_shell_data: Energy ',exp(gle), ' is
     * outside the available data range of ', exp(etmp(1)),exp(etmp(ndat
     *      ))
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          ELSE
            DO 15191 kk=1,ndat-1
              IF((gle .GE. etmp(kk) .AND. gle .LT. etmp(kk+1)))GO TO1519
     *        2
15191       CONTINUE
15192       CONTINUE
            p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk))
            sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk))
          END IF
          data(k) = data(k) + pz_sorted(i)*sig
15181   CONTINUE
15182   CONTINUE
15161 CONTINUE
15162 CONTINUE
      DO 15201 i=1,ne
        iz = int(zsorted(i)+0.5)
        zpos = pe_zpos(iz)
        ndat = pe_nge(zpos)
        DO 15211 k=1,ndat
          sig = sigmaMedium(imed,pe_energy(k,zpos))
          pe_elem_prob(k,i,imed) = log(pe_elem_prob(k,i,imed)/sig)
15211   CONTINUE
15212   CONTINUE
15201 CONTINUE
15202 CONTINUE
      return
      end
      real*8 function sigmaMedium(imed, logE)
      implicit none
      COMMON/BREMPR/ DL1(8,6),DL2(8,6),DL3(8,6),DL4(8,6),DL5(8,6),DL6(8,
     *6), ALPHI(2,6),BPAR(2,6),DELPOS(2,6), WA(6,50),PZ(6,50),ZELEM(6,50
     *),RHOZ(6,50), PWR2I(50), DELCM(6),ZBRANG(6),LZBRANG(6),NNE(6), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(6,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON /BREMPR_addition/IBRSPL
      integer*4 IBRSPL
      ! COMIN BREMPR_addition is defined in FLURZnrc.mortran
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,6),   pe_energy(500,100),  pe_zsorted(100,6), pe_be(100,16),
     * pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      real*8 pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      real*8 logE, slope, sigma
      integer*4 k,imed,Z,zpos,m,ibsearch
      sigmaMedium = 0
      DO 15221 k=1,nne(imed)
        Z = int( zelem(imed,k) + 0.5 )
        zpos = pe_zpos(Z)
        m = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos))
        slope = log(pe_xsection(m+1,zpos,0)/pe_xsection(m,zpos,0))
        slope = slope/(pe_energy(m+1,zpos)-pe_energy(m,zpos))
        sigma = log(pe_xsection(m,zpos,0))
        sigma = sigma + slope*(logE - pe_energy(m,zpos))
        sigma = exp(sigma)
        sigmaMedium = sigmaMedium + pz(imed,k)*sigma
15221 CONTINUE
15222 CONTINUE
      return
      end
      subroutine egs_heap_sort(n,rarray,jarray)
      implicit none
      integer*4 n,jarray(*)
      real*8 rarray(*)
      integer*4 i,ir,j,l,ira
      real*8 rra
      DO 15231 i=1,n
        jarray(i)=i
15231 CONTINUE
15232 CONTINUE
      IF((n .LT. 2))return
      l=n/2+1
      ir=n
15241 CONTINUE
        IF ((l .GT. 1)) THEN
          l=l-1
          rra=rarray(l)
          ira=l
        ELSE
          rra=rarray(ir)
          ira=jarray(ir)
          rarray(ir)=rarray(1)
          jarray(ir)=jarray(1)
          ir=ir-1
          IF ((ir .EQ. 1)) THEN
            rarray(1)=rra
            jarray(1)=ira
            return
          END IF
        END IF
        i=l
        j=l+l
15251   CONTINUE
          IF((j .GT. ir))GO TO15252
          IF ((j .LT. ir)) THEN
            IF((rarray(j) .LT. rarray(j+1)))j=j+1
          END IF
          IF ((rra .LT. rarray(j))) THEN
            rarray(i)=rarray(j)
            jarray(i)=jarray(j)
            i=j
            j=j+j
          ELSE
            j=ir+1
          END IF
        GO TO 15251
15252   CONTINUE
        rarray(i)=rra
        jarray(i)=ira
      GO TO 15241
15242 CONTINUE
      return
      end
      SUBROUTINE PHOTONUC
      implicit none
      COMMON/STACK/ E(150),X(150),Y(150),Z(150),U(150),V(150),W(150),DNE
     *AR(150),WT(150),IQ(150),IR(150),LATCH(150), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      npold = np
      edep = pzero
      e(np) = pzero
      wt(np) = 0
      return
      end
