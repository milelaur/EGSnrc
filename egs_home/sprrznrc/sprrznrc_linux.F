      implicit none
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      INTEGER MAKE_IT_AN_INT
      CHARACTER*80 TEXT
      real CPUT0,CPUT1,CPUT2,TDUM
      real egs_tot_time, egs_etime
      integer*4 NETADJ
      real*8 TIMCPU,TIMEB,ETIMETOT,RATIO
      REAL*4 GWATE(10)
      COMMON/BOUNDS/ECUT( 1001),PCUT( 1001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      CHARACTER*4 BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,
     *SCHAR, TCHAR,UCHAR,VCHAR
      COMMON/CHARS/ BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHA
     *R,SCHAR,TCHAR,UCHAR,VCHAR
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/GEOM/ ZPLANE( 101),RCYL(0:10),CYRAD2( 11), NZ,NR,NREG,NPLAN
     *E
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NPLANE
      character*1 title(80)
      COMMON/IODAT1/TITLE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(100,10),TMCPUO,TIMMAX,ST
     *ATLM,EIN, IDAT,IRESTART,IQIN,IVAL,ISPRREG,ISPR( 1001)
      integer*8 NCASE,NCASEO,NCASET
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN
      integer*4 IDAT,IRESTART,IQIN,IVAL,ISPR, ISPRREG,DATCOUNT
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE
      integer*4 ICHPIN,ILPIN,IOUT,IPAGE
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PHOTIN/ EBINDA(3), GE0(3),GE1(3), GMFP0(2000,3),GMFP1(2000,
     *3),GBR10(2000,3),GBR11(2000,3),GBR20(2000,3),GBR21(2000,3), RCO0(3
     *),RCO1(3), RSCT0(100,3),RSCT1(100,3), COHE0(2000,3),COHE1(2000,3),
     *  PHOTONUC0(2000,3),PHOTONUC1(2000,3), DPMFP, MPGEM(1,3), NGR(3)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/RUSROU/RRZ,RRCUT,RUSROU
      real*8 RRZ,RRCUT
      LOGICAL RUSROU
      COMMON/SCORE/ SCSTP,SCSTP2,SCEDPN,SCEDPN2,SCDOSE,SCDOSE2,SCDOSE_CO
     *V, SCSPR_COV, DELTA, DELTLG,DELTAT,PIISTP, SCSTP_LAST,SCDOSE_LAST,
     *SCNUM,IHSTRY, SCSTP_TMP,SCEDPN_TMP,SCDOSE_TMP3, ifano,MXNP,ISTORE,
     *IWATCH,IOUTSP, ICROSS,ITRACKE,BSTAT,BDSTAT
      REAL*8 SCSTP,SCSTP2,SCEDPN( 101,10,4), SCEDPN2( 101,10,4), SCDOSE(
     * 101,10,3), SCDOSE2( 101,10,3), SCDOSE_COV( 101,10,3-1), SCSPR_COV
     *( 101,10,2), DELTA, DELTAT,DELTLG,PIISTP
      integer*8 SCSTP_LAST,SCDOSE_LAST( 101,10), SCNUM( 101,10)
      real*8 SCSTP_TMP,SCEDPN_TMP( 101,10,4), SCDOSE_TMP3( 101,10)
      integer*4 IFANO,MXNP,ISTORE,IWATCH,IOUTSP,ICROSS,ITRACKE, BSTAT( 1
     *01,2),BDSTAT( 101)
      integer*8 ihstry
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(1000,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RB
     *EAM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2
     *,DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,
     *PROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST
     *,ZSOFST,                                                      SVTM
     *P1,SVTMP2,SVTMP3,SVTMP4,
     *          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                        XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,
     *WEIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/SPECTR/ CDFINV(1000,2),ENSRCD(0:300),SRCPDF(300),SRCCDF(300
     *), NENSRC
      real*8 CDFINV,ENSRCD,SRCPDF,SRCCDF
      integer*4 NENSRC
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERVR/ CEXPTR,GWAIT,PATHL,DUMU,DUMX,DUMY,DUMZ, DELTAP,GWTO
     *LD,EPSLON,ARG,EXPMFP,ESAVEIN, IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM, IFO
     *RCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN, MEDTMP,IREJCT
      real*8 CEXPTR,GWAIT,DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,GWTOLD,EPSLON
     *,ARG, EXPMFP,ESAVEIN
      integer*4 NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN,IFORCE,IRODU
     *M, IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,IREJCT
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      COMMON/RWPHSP/ STRING_TEMP_ZLAST_OUT,  STRING_TEMP_OUT,  IHSTRY_PH
     *SP,   iaea_dummy_long,  NHSTRY_DOS,   ESHORT,  WEIGHTTMP,  WT_PHSP
     *_SHORT,  X_PHSP_SHORT,  Y_PHSP_SHORT,  Z_PHSP_SHORT,  U_PHSP_SHORT
     *,  V_PHSP_SHORT,  W_PHSP_SHORT,  ZLAST_PHSP_SHORT,  MUIDX_PHSP_SHO
     *RT,  EKMAX_PHSP_SHORT,  EKMINE_PHSP_SHORT,  NINC_PHSP_SHORT,  dosx
     *yz2beam_index,  iaea_extra_floats,  NUM_PHSP_TOT,  PHOT_PHSP_TOT,
     *iaea_result,   iaea_n_stat,  iaea_q_typ,  iaea_typ_q,  iaea_q_inde
     *x,  I_PHSP,  IERR_PHSP,  LATCHTMP,  WRITE_PHSP_COUNTER,  WRITE_PHS
     *P_SOFAR,  PHSP_RESTART,  PHSP_RECL,  PHSP_RECL_OLD,  iaea_extra_in
     *ts,  iaea_extra_int_types,iaea_extra_float_types,   iaea_i_zlast,
     * iaea_i_latch,  iaea_i_muidx,  iaea_n_extra_ints,  iaea_n_extra_fl
     *oats,  i_iaea_open_for_write,   iaea_i_zlast_out,  iaea_i_latch_ou
     *t,  iaea_i_muidx_out,  dosxyz2beam_izscore,  MODE_RW
      CHARACTER*32000 STRING_TEMP_ZLAST_OUT(1)
      CHARACTER*28000 STRING_TEMP_OUT(1)
      integer*8 IHSTRY_PHSP(1),iaea_dummy_long,NHSTRY_DOS
      REAL*4 ESHORT,WEIGHTTMP,WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT, Z
     *_PHSP_SHORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,ZLAST_PHSP_SHO
     *RT, MUIDX_PHSP_SHORT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP
     *_SHORT,dosxyz2beam_index, iaea_extra_floats(10)
      INTEGER NUM_PHSP_TOT,PHOT_PHSP_TOT, iaea_result,iaea_n_stat,iaea_q
     *_typ(3),iaea_typ_q(3),iaea_q_index,I_PHSP, IERR_PHSP,LATCHTMP, WRI
     *TE_PHSP_COUNTER(1),WRITE_PHSP_SOFAR(1), PHSP_RESTART,PHSP_RECL,PHS
     *P_RECL_OLD,iaea_extra_ints(10), iaea_extra_int_types(10),iaea_extr
     *a_float_types(10),iaea_i_zlast, iaea_i_latch,iaea_i_muidx,iaea_n_e
     *xtra_ints,iaea_n_extra_floats, i_iaea_open_for_write,iaea_i_zlast_
     *out,iaea_i_latch_out, iaea_i_muidx_out,dosxyz2beam_izscore
      CHARACTER*5 MODE_RW
      INTEGER LATCH_TEMP_OUT,NUM_PHSP_TOFLUSH,TEMP_PHSP_COUNTER,REM_PHSP
      REAL*4 REAL_TEMP_OUT(7)
      CHARACTER*32 REC_TEMP_OUT
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*8 ITEMP,JCASE
      integer*4 I,J,NBATCH,IZ,IX,MEDNUM,LGLE,IBATCH,IBTCH,NOSCAT,INOCAV,
     * NOSCT2,INOMED,IRL,IT,ICASE,IRIN,NRCFLG, NDATA,I1,I2,I3,IERR
      real*8 EI,EKMAX,DEPTH,VOLUME,RLOW2,WEIGHT,COHFAC,ECUTMN,factor, EK
     *0,BATCHT,XIN,YIN,ZIN,UIN,VIN,WIN,FHPG,FMASS,FHPH,TEMP1,TEMP2
      REAL*8 TSC,TSC2
      REAL SCORE_TEMP,SCORE_NORM_NUM
      integer*4 egs_open_file, egs_open_datfile, rng_unit, data_unit
      external combine_results
#define HAVE_C_COMPILER
#ifdef HAVE_C_COMPILER
      real*8 part_spr, part2_spr, current_result, current_uncertainty
      integer*8 n_run,n_tot,n_last
      integer*4 n_job
      logical first_time
#endif
      logical is_finished
      call egs_init
      BLANK=' '
      ASTER='*'
      ACHAR='A'
      BCHAR='B'
      CCHAR='C'
      DCHAR='D'
      ICHAR='I'
      MCHAR='M'
      RCHAR='R'
      SCHAR='S'
      TCHAR='T'
      UCHAR='U'
      VCHAR='V'
      CPUT0=egs_etime()
      WRITE(6,1010) 101,10
1010  FORMAT(//' SPRRZnrc(EGSnrc) ',' ', / ' on ','linux',' with',I3, 'd
     *epth regions &', I3, ' radial regions'//)
      IOUT=1
      CALL INPUTS
      IF ((ERROR_FLAG.EQ.1)) THEN
         GOTO 1020
      END IF
      IF (( istore .GT. 0 )) THEN
         rng_unit = egs_open_file(2,0,1,'.egsrns')
      ELSE IF(( irestart .EQ. 4 )) THEN
         rng_unit = egs_open_datfile(2,0,1,'.egsrns')
      END IF
      IF ((IRESTART.EQ.5)) THEN
         call egs_combine_runs(combine_results,'.egsdat')
         NBATCH=0
         NCASET=NCASEO
      END IF
      MXNP=0
      IHSTRY=NCASEO
      IF ((ISOURC .EQ. 2)) THEN
         NR=1
         RCYL(1)=1000.
         NREG=NZ+1
         CYRAD2(1)=RCYL(1)**2
      END IF
      IF ((NCASE/10.EQ.0)) THEN
         NCASE=10
      END IF
      JCASE=NCASE/10
      NCASE=JCASE*10
      DO 1031 J=1,5
         IAUSFL(J)=1
1031  CONTINUE
1032  CONTINUE
      DO 1041 J=6,35
         IAUSFL(J)=0
1041  CONTINUE
1042  CONTINUE
      IAUSFL(17)=1
      IAUSFL(19)=1
      IAUSFL(21)=1
      IF ((ifano .EQ. 1)) THEN
         iausfl(16) = 1
         iausfl(17) = 1
         iausfl(18) = 1
         iausfl(19) = 1
         iausfl(20) = 1
         iausfl(21) = 1
         iausfl(24) = 1
         iausfl(25) = 1
         iausfl(8) = 1
         iausfl(14) = 1
         iausfl(15) = 1
      END IF
      DUNIT=1
      WRITE(6,1050)
1050  FORMAT(/' CALL TO HATCH AT  ',$)
      call egs_time(6)
      write(6,*)
      CALL HATCH
      WRITE(6,1060)
1060  FORMAT(/' HATCH COMPLETED AT ',$)
      call egs_time(6)
      write(6,*)
      IF ((MONOEN.EQ.0.AND.ISOURC.NE.21.AND.ISOURC.NE.22.AND.ISOURC.NE.2
     *3)) THEN
         IF ((IQIN .EQ. 0)) THEN
            EI=EIN
         ELSE
            EI=EIN+RM
         END IF
         EKMAX=EIN
      ELSE IF((MONOEN .EQ. 1)) THEN
         CALL ENSRC1
         EKMAX=ENSRCD(NENSRC)
      ELSE IF((ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOURC.EQ.23)) THEN
         EKMAX=EKSRCM
      END IF
      DO 1071 I=1,NMED
         IF (((EKMAX.GT.UP(I)).OR.(EKMAX.GT.UE(I)-RM))) THEN
            WRITE(6,1080)I,EKMAX,UP(I),UE(I)
1080        FORMAT(//1X,50('*')// ' FOR MEDIUM',I3,' INCIDENT ENERGY=',F
     *10.1,' MeV'/ ' IS GREATER THAN COVERED BY DATA FILE WHERE UP,UE=',
     *2F10.1,' MeV'/ '     EXECUTION WILL TERMINATE AFTER COMPLETION OF 
     *INPUT FILE'// 1X,50('*')//)
            GOTO 1090
         END IF
         IF ((ABS(AE(I) - AE(1)) .GT. 0.0001)) THEN
            WRITE(6,1100)I
1100        FORMAT(//' ******AE(',I3,') ~= AE(1)*****'///)
            call egs_finish
            STOP
         END IF
1071  CONTINUE
1072  CONTINUE
      DELTA = AE(1) - PRM+1.D-7
      DELTAT = AE(1)+1.D-7
      DELTLG = LOG(DELTA)
      DO 1111 IZ=1,NZ
         DEPTH=ZPLANE(IZ+1)-ZPLANE(IZ)
         DO 1121 IX=1,NR
            IRL=IZ+NZ*(IX-1)+1
            MEDNUM=MED(IRL)
            IF ((MEDNUM.NE.0)) THEN
               IF (((ISOURC.EQ.2).OR.(ISOURC.EQ.4))) THEN
                  VOLUME=DEPTH
               ELSE
                  IF ((IX .EQ. 1)) THEN
                     RLOW2=0.0
                  ELSE
                     RLOW2=CYRAD2(IX-1)
                  END IF
                  VOLUME=PI*DEPTH*(CYRAD2(IX)-RLOW2)
               END IF
               AMASS(IZ,IX)=RHOR(IRL)*VOLUME
            ELSE
               AMASS(IZ,IX)=0.0
            END IF
1121     CONTINUE
1122     CONTINUE
1111  CONTINUE
1112  CONTINUE
      CALL SRCOTO(WEIGHT)
      IF (((IFPB.EQ.0).AND.(IFORCE.NE.0).AND.(IQIN.EQ.0).AND.(MONOEN.EQ.
     *0))) THEN
         IF (((IFPB.EQ.0).AND.(IQINC.EQ.0).AND.(IFORCE.EQ.1))) THEN
            GLE=LOG(EIN)
            DO 1131 IX=1,NR
               PATHL=0.0
               DO 1141 IZ=1,NZ
                  IRL=IZ+NZ*(IX-1)+1
                  MEDIUM=MED(IRL)
                  IF ((MEDIUM.EQ.0)) THEN
                     DELTAP=0.
                  ELSE
                     LGLE=GE1(MEDIUM)*GLE+GE0(MEDIUM)
                     DELTAP=GMFP1(LGLE,MEDIUM)*GLE+GMFP0(LGLE,MEDIUM)
                     IF ((IRAYLR(IRL) .EQ. 1)) THEN
                        COHFAC=COHE1(LGLE,MEDIUM)*GLE+COHE0(LGLE,MEDIUM)
                     ELSE
                        COHFAC=1.0
                     END IF
                  END IF
                  IF ((DELTAP.NE.0)) THEN
                     DELTAP=(ZPLANE(IZ+1)-ZPLANE(IZ))/(COHFAC*DELTAP)
                     PATHL=PATHL+DELTAP
                  END IF
                  IF ((PATHL.LE.1.0E-3)) THEN
                     GWATE(IX)=PATHL*(1.-0.5*PATHL)
                  ELSE
                     GWATE(IX)=1.-EXP(-PATHL)
                  END IF
1141           CONTINUE
1142           CONTINUE
1131        CONTINUE
1132        CONTINUE
         END IF
      END IF
      ECUTMN=AE(1)
      EK0=EIN
      CALL ISUMRY
      write(iout,100) ' '
      call egs_fdate(iout)
      write(iout,*)
      WRITE(IOUT,200)
      WRITE(6,200)
      IF ((IRESTART .EQ. 0)) THEN
         WRITE(6,201)
         WRITE(IOUT,201)
      ELSE IF((IRESTART .EQ. 1)) THEN
         WRITE(6,202) NCASE,NCASEO
         write(6,'(21x,a,$)') 'New RNG state: '
         write(6,'(a,2i4,$)') ' ixx jxx = ',ixx,jxx
         write(6,*)
         WRITE(IOUT,202) NCASE,NCASEO
         write(iout,'(21x,a,$)') 'New RNG state: '
         write(iout,'(a,2i4,$)') ' ixx jxx = ',ixx,jxx
         write(iout,*)
      ELSE IF((IRESTART .EQ. 3)) THEN
         WRITE(6,204)
         WRITE(IOUT,204)
         GO TO 1150
      ELSE IF((IRESTART .EQ. 4)) THEN
         WRITE(6,205)
         WRITE(IOUT,205)
      ELSE IF((IRESTART .EQ. 5)) THEN
         WRITE(6,206)
         WRITE(IOUT,206)
         GO TO 1150
      END IF
      IF((IWATCH.NE.0))CALL WATCH(-99,IWATCH)
      CPUT1=egs_etime()
      tdum = egs_tot_time(1)
      ETIMETOT=0
      TIMEB=0
      NETADJ=0
      IF((idat .EQ. 0))data_unit = egs_open_file(4,0,1,'.egsdat')
#ifdef HAVE_C_COMPILER
      part_spr=0
      part2_spr=0
      n_tot = ncaseo
      first_time = .true.
      is_finished = .false.
1160  CONTINUE
      IF (( n_parallel .GT. 0 )) THEN
         call egs_pjob_control(ncase,n_run,n_left,n_tot,part_spr,part2_s
     *   pr, current_result, current_uncertainty)
         IF (( n_run .EQ. 0 )) THEN
            write(6,'(//a,a//)') '****** No histories left in job contro
     *l file', '       => end simulation'
            goto 1170
         END IF
         jcase = n_run/10
         IF (( jcase .LT. 1 )) THEN
            jcase = 1
            n_run = jcase*10
         END IF
         IF (( first_time )) THEN
            first_time = .false.
            n_last = n_run
            write(6,'(//a,i12,a//)') '****** Running ',n_run,' histories
     *'
         ELSE
            write(6,'(//a,i12,a)') '***** Finished ',n_last,' histories'
            write(6,'(/a/,20x,1pe11.4,a,0pf5.2,a/,a,i12,a//)') '      cu
     *rrent result including previous runs and other parallel jobs: ', c
     *      urrent_result, ' +/- ',current_uncertainty,' %', '      will
     * run another ',n_run,' histories'
         END IF
      END IF
#endif
      DO 1181 IBATCH=1,10
         IBTCH=IBATCH
         IF ((IBATCH .EQ. 1)) THEN
            WRITE(6,1190)
1190        FORMAT(/' BATCH #',2X,'TIME-ELAPSED',2X,'TOTAL CPUTIME',2X,'
     *RATIO',2X, 'TIME OF DAY'// ' ',4X,'1',10X,'0.0',12X,'0.0',6X,'0.00
     *',3X,' ',$)
            call egs_time(6)
            write(6,*)
            call flush(6)
         ELSE
            TIMEB = egs_tot_time(0)
            ETIMETOT=ETIMETOT+TIMEB
            CPUT2=egs_etime()
            TIMCPU=(CPUT2-CPUT1)*1.0+0.01
            WRITE(6,1200)IBATCH,ETIMETOT,TIMCPU,ETIMETOT/TIMCPU
1200        FORMAT(' ',3X,I2,5X,F8.1,7X,F8.1,2X,F8.2,3X,' ',$)
            call egs_time(6)
            write(6,*)
            call flush(6)
            BATCHT=TIMCPU/dble(IBATCH-1)
            IF ((TIMCPU+1.1*BATCHT.GT.TIMMAX*3600.)) THEN
               WRITE(IOUT,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY
               WRITE(6,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY
               AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET)
               GO TO 1170
            END IF
         END IF
         DO 1211 ICASE=1,JCASE
            IF((ISOURC.NE.23))IHSTRY=IHSTRY+1
1220        CONTINUE
            NFTIME=0
            IF ((IRESTART .EQ. 4)) THEN
               read(2,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
     *          rng_array
               twom24 = 1./16777216.
            END IF
            IF ((ISTORE .EQ. 1)) THEN
               rewind(2)
               write(2,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed
     *         , rng_array
            ELSE IF((ISTORE .EQ. 2)) THEN
               write(2,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed
     *         , rng_array
            END IF
            CALL SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
            IF ((MONOEN .NE. 0 .AND. ISOURC .NE. 21 .AND. ISOURC .NE. 22
     *       .AND. ISOURC.NE.23)) THEN
               CALL ENSRCH(EIN)
               IF ((IQIN .EQ. 0)) THEN
                  EI=EIN
               ELSE
                  EI=EIN+RM
               END IF
            ELSE IF((ISOURC .EQ. 21.OR. ISOURC .EQ. 22.OR.ISOURC.EQ.23))
     *       THEN
               EI=EIN
            END IF
            IF (((MONOEN.EQ.0).AND.(IQIN.EQ.0).AND.(IFORCE.EQ.1).AND.(IF
     *      PB.EQ.0))) THEN
               IX=(IRIN-2)/NZ+1
               GWAIT=GWATE(IX)
               WEIGHT=GWAIT
            END IF
            LATCHI=0
            IF (((IWATCH.NE.0).AND.(IWATCH.NE.4))) THEN
               WRITE(6,1230)1,EIN,IQIN,IRIN,XIN,YIN,ZIN,UIN,VIN,WIN,LATC
     *         HI,WEIGHT
1230           FORMAT(' INITIAL SHOWER VALUES',T36,':', I5,F9.3,2I4,3F8.
     *3,3F7.3,I10,1PE10.3)
            END IF
            CALL SHOWER(IQIN,EI,XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT)
            IF((IWATCH.GT.0))CALL WATCH(-1,IWATCH)
1211     CONTINUE
1212     CONTINUE
         IF ((IDAT .EQ. 0)) THEN
            rewind(data_unit)
            TSC=SCSTP+SCSTP_TMP
            TSC2=SCSTP2+SCSTP_TMP*SCSTP_TMP
            WRITE(data_unit,*) TSC,TSC2
            DO 1241 IZ=1,NZ
               DO 1251 IX=1,NR
                  DO 1261 IT=1,4
                     TSC=SCEDPN(IZ,IX,IT)+SCEDPN_TMP(IZ,IX,IT)
                     TSC2=SCEDPN2(IZ,IX,IT)+SCEDPN_TMP(IZ,IX,IT)* SCEDPN
     *               _TMP(IZ,IX,IT)
                     WRITE(data_unit,*)TSC,TSC2
1261              CONTINUE
1262              CONTINUE
                  TSC=SCDOSE(IZ,IX,1)+SCEDPN_TMP(IZ,IX,1)- SCEDPN_TMP(IZ
     *            ,IX,3)
                  TSC2=SCDOSE2(IZ,IX,1)+(SCEDPN_TMP(IZ,IX,1)- SCEDPN_TMP
     *            (IZ,IX,3))**2
                  WRITE(data_unit,*)TSC,TSC2
                  TSC=SCDOSE(IZ,IX,2)+SCDOSE_TMP3(IZ,IX)- SCEDPN_TMP(IZ,
     *            IX,1)
                  TSC2=SCDOSE2(IZ,IX,2)+(SCDOSE_TMP3(IZ,IX)- SCEDPN_TMP(
     *            IZ,IX,1))**2
                  WRITE(data_unit,*)TSC,TSC2
                  TSC=SCDOSE(IZ,IX,3)+SCDOSE_TMP3(IZ,IX)
                  TSC2=SCDOSE2(IZ,IX,3)+SCDOSE_TMP3(IZ,IX)* SCDOSE_TMP3(
     *            IZ,IX)
                  WRITE(data_unit,*)TSC,TSC2
                  TSC=SCDOSE_COV(IZ,IX,1)+(SCEDPN_TMP(IZ,IX,1)- SCEDPN_T
     *            MP(IZ,IX,3))*SCDOSE_TMP3(IZ,IX)
                  TSC2=SCDOSE_COV(IZ,IX,2)+(SCDOSE_TMP3(IZ,IX)- SCEDPN_T
     *            MP(IZ,IX,1))*SCDOSE_TMP3(IZ,IX)
                  WRITE(data_unit,*)TSC,TSC2
                  TSC=SCSPR_COV(IZ,IX,1)+SCEDPN_TMP(IZ,IX,1)* SCEDPN_TMP
     *            (IZ,IX,2)
                  TSC2=SCSPR_COV(IZ,IX,2)+SCEDPN_TMP(IZ,IX,3)* SCEDPN_TM
     *            P(IZ,IX,4)
                  WRITE(data_unit,*)TSC,TSC2
1251           CONTINUE
1252           CONTINUE
1241        CONTINUE
1242        CONTINUE
         END IF
         CPUT2=egs_etime()
         TIMCPU=1.0*(CPUT2-CPUT1)+TMCPUO
         IF ((IDAT .EQ. 0)) THEN
            write(data_unit,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng
     *      _seed, rng_array
            WRITE(data_unit,*) IHSTRY,TIMCPU,NNREAD,PIISTP+count_pII_ste
     *      ps
            WRITE(data_unit,*) ICROSS,ITRACKE
         END IF
1181  CONTINUE
1182  CONTINUE
#ifdef HAVE_C_COMPILER
      IF (( n_parallel .GT. 0 )) THEN
         goto 1160
      END IF
#endif
1170  CONTINUE
      SCSTP=SCSTP+SCSTP_TMP
      SCSTP2=SCSTP2+SCSTP_TMP*SCSTP_TMP
      DO 1271 IX=1,NR
         DO 1281 IZ=1,NZ
            DO 1291 IT=1,4
               SCEDPN(IZ,IX,IT)=SCEDPN(IZ,IX,IT)+SCEDPN_TMP(IZ,IX,IT)
               SCEDPN2(IZ,IX,IT)=SCEDPN2(IZ,IX,IT)+SCEDPN_TMP(IZ,IX,IT)*
     *          SCEDPN_TMP(IZ,IX,IT)
1291        CONTINUE
1292        CONTINUE
            SCDOSE(IZ,IX,1)=SCDOSE(IZ,IX,1)+SCEDPN_TMP(IZ,IX,1)- SCEDPN_
     *      TMP(IZ,IX,3)
            SCDOSE2(IZ,IX,1)=SCDOSE2(IZ,IX,1)+(SCEDPN_TMP(IZ,IX,1)- SCED
     *      PN_TMP(IZ,IX,3))**2
            SCDOSE_COV(IZ,IX,1)=SCDOSE_COV(IZ,IX,1)+(SCEDPN_TMP(IZ,IX,1)
     *      - SCEDPN_TMP(IZ,IX,3))*SCDOSE_TMP3(IZ,IX)
            SCDOSE(IZ,IX,2)=SCDOSE(IZ,IX,2)+SCDOSE_TMP3(IZ,IX)- SCEDPN_T
     *      MP(IZ,IX,1)
            SCDOSE2(IZ,IX,2)=SCDOSE2(IZ,IX,2)+(SCDOSE_TMP3(IZ,IX)- SCEDP
     *      N_TMP(IZ,IX,1))**2
            SCDOSE_COV(IZ,IX,2)=SCDOSE_COV(IZ,IX,2)+(SCDOSE_TMP3(IZ,IX)-
     *       SCEDPN_TMP(IZ,IX,1))*SCDOSE_TMP3(IZ,IX)
            SCDOSE(IZ,IX,3)=SCDOSE(IZ,IX,3)+SCDOSE_TMP3(IZ,IX)
            SCDOSE2(IZ,IX,3)=SCDOSE2(IZ,IX,3)+SCDOSE_TMP3(IZ,IX)* SCDOSE
     *      _TMP3(IZ,IX)
            SCSPR_COV(IZ,IX,1)=SCSPR_COV(IZ,IX,1)+ SCEDPN_TMP(IZ,IX,1)*S
     *      CEDPN_TMP(IZ,IX,2)
            SCSPR_COV(IZ,IX,2)=SCSPR_COV(IZ,IX,2)+SCEDPN_TMP(IZ,IX,3)* S
     *      CEDPN_TMP(IZ,IX,4)
            IF((SCDOSE_TMP3(IZ,IX).GT.0.))SCNUM(IZ,IX)=SCNUM(IZ,IX)+1
1281     CONTINUE
1282     CONTINUE
1271  CONTINUE
1272  CONTINUE
      write(6,'(/a)') '********* final random number state:'
      write(6,'(a,2i4,$)') ' ixx jxx = ',ixx,jxx
      write(6,'(a)') '  *********'
      write(iout,'(/a,$)') '********* FINAL RANDOM NUMBER STATE:'
      write(iout,'(a,2i4,$)') ' ixx jxx = ',ixx,jxx
      write(iout,'(a)') '  *********'
      TIMEB = egs_tot_time(0)
      ETIMETOT=ETIMETOT+TIMEB
      CPUT2=egs_etime()
      TIMCPU=(CPUT2-CPUT1)*1.0+TMCPUO
      IF ((TMCPUO .EQ. 0)) THEN
         RATIO=ETIMETOT/TIMCPU
      ELSE
         RATIO=0.
      END IF
      IF ((TIMCPU.NE.0.0)) THEN
         FHPH=3600./TIMCPU*dble(IHSTRY)
      END IF
      WRITE(IOUT,261)ETIMETOT,TIMCPU,TIMCPU/3600., RATIO,FHPH
      WRITE(6,261)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO,FHPH
1150  CONTINUE
      IF ((ISOURC.EQ.21.OR.ISOURC.EQ.22)) THEN
         AINFLU=dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*NIN
     *   CSRC
         SCORE_NORM_NUM=AINFLU
      ELSE IF((ISOURC.EQ.23)) THEN
         SCORE_NORM_NUM=dble(IHSTRY)
         AINFLU=SCORE_NORM_NUM
      ELSE
         SCORE_NORM_NUM=dble(IHSTRY)
      END IF
      SCORE_TEMP=SCSTP/SCORE_NORM_NUM
      SCSTP2=SCSTP2/SCORE_NORM_NUM
      SCSTP2=(SCSTP2-SCORE_TEMP*SCORE_TEMP)/(SCORE_NORM_NUM-1)
      IF((SCSTP2.GE.0.))SCSTP2= SQRT(SCSTP2)
      IF ((SCORE_TEMP.NE.0.)) THEN
         SCSTP2=SCSTP2/SCORE_TEMP*100
         IF (( SCSTP2 .GT. 99.9 )) THEN
            SCSTP2 = 99.9
         END IF
      ELSE
         SCSTP2=99.9
      END IF
      IF ((ISOURC.EQ.4)) THEN
         DO 1301 IX=2,NR
            DO 1311 IZ=1,NZ
               DO 1321 IT=1,4
                  SCEDPN(IZ,IX,IT)=SCEDPN(IZ,IX,IT)+SCEDPN(IZ,IX-1,IT)
                  SCEDPN2(IZ,IX,IT)=SCEDPN2(IZ,IX,IT)+SCEDPN2(IZ,IX-1,IT
     *            )
1321           CONTINUE
1322           CONTINUE
               DO 1331 IT=1,3
                  SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+SCDOSE(IZ,IX-1,IT)
                  SCDOSE2(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+SCDOSE2(IZ,IX-1,IT)
                  IF ((IT.LT.3)) THEN
                     SCDOSE_COV(IZ,IX,IT)=SCDOSE_COV(IZ,IX,IT)+SCDOSE_CO
     *               V(IZ,IX-1,IT)
                  END IF
1331           CONTINUE
1332           CONTINUE
               DO 1341 IT=1,2
                  SCSPR_COV(IZ,IX,IT)=SCSPR_COV(IZ,IX,IT)+SCSPR_COV(IZ,I
     *            X-1,IT)
1341           CONTINUE
1342           CONTINUE
1311        CONTINUE
1312        CONTINUE
1301     CONTINUE
1302     CONTINUE
      END IF
      DO 1351 IX=1,NR
         DO 1361 IZ=1,NZ
            IRL=IZ+NZ*(IX-1)+1
            MEDNUM = MED(IRL)
            IF ((SCNUM(IZ,IX).LT.20)) THEN
               BSTAT(IZ,1)=-1
               BSTAT(IZ,2)=-1
            END IF
            IF ((SCEDPN(IZ,IX,2) .EQ. 0.)) THEN
               SCEDPN(IZ,IX,1)=0.
               SCEDPN2(IZ,IX,1)=99.9
               BSTAT(IZ,1)=-1
            ELSE
               SCORE_TEMP=SCEDPN(IZ,IX,1)/SCORE_NORM_NUM
               SCEDPN2(IZ,IX,1)=SCEDPN2(IZ,IX,1)/SCORE_NORM_NUM
               SCEDPN2(IZ,IX,1)=(SCEDPN2(IZ,IX,1)-SCORE_TEMP*SCORE_TEMP)
     *         /(SCORE_NORM_NUM-1)
               IF((SCEDPN2(IZ,IX,1).GE.0.))SCEDPN2(IZ,IX,1)= SQRT(SCEDPN
     *         2(IZ,IX,1))
               IF ((SCORE_TEMP.NE.0.)) THEN
                  SCEDPN2(IZ,IX,1)=SCEDPN2(IZ,IX,1)/SCORE_TEMP*100
                  IF (( SCEDPN2(IZ,IX,1) .GT. 99.9 )) THEN
                     SCEDPN2(IZ,IX,1) = 99.9
                  END IF
               ELSE
                  SCEDPN2(IZ,IX,1)=99.9
               END IF
               SCORE_TEMP=SCEDPN(IZ,IX,2)/SCORE_NORM_NUM
               SCEDPN2(IZ,IX,2)=SCEDPN2(IZ,IX,2)/SCORE_NORM_NUM
               SCEDPN2(IZ,IX,2)=(SCEDPN2(IZ,IX,2)-SCORE_TEMP*SCORE_TEMP)
     *         /(SCORE_NORM_NUM-1)
               IF((SCEDPN2(IZ,IX,2).GE.0.))SCEDPN2(IZ,IX,2)= SQRT(SCEDPN
     *         2(IZ,IX,2))
               IF ((SCORE_TEMP.NE.0.)) THEN
                  SCEDPN2(IZ,IX,2)=SCEDPN2(IZ,IX,2)/SCORE_TEMP*100
                  IF (( SCEDPN2(IZ,IX,2) .GT. 99.9 )) THEN
                     SCEDPN2(IZ,IX,2) = 99.9
                  END IF
               ELSE
                  SCEDPN2(IZ,IX,2)=99.9
               END IF
               IF ((SCEDPN2(IZ,IX,1).EQ.99.9 .OR. SCEDPN2(IZ,IX,2).EQ.99
     *         .9)) THEN
                  BSTAT(IZ,1)=-1
                  SCSPR_COV(IZ,IX,1)=0.
               ELSE
                  SCSPR_COV(IZ,IX,1)=SCSPR_COV(IZ,IX,1)/SCORE_NORM_NUM-
     *            SCEDPN(IZ,IX,1)*SCEDPN(IZ,IX,2)/ (SCORE_NORM_NUM**2)
                  SCSPR_COV(IZ,IX,1)=SCSPR_COV(IZ,IX,1)/(SCEDPN(IZ,IX,1)
     *            * SCEDPN(IZ,IX,2)/(SCORE_NORM_NUM**2)* (SCORE_NORM_NUM
     *            -1))
               END IF
               SCEDPN2(IZ,IX,1)=(SCEDPN2(IZ,IX,1)/100.)**2+ (SCEDPN2(IZ,
     *         IX,2)/100.)**2- 2*SCSPR_COV(IZ,IX,1)
               IF ((SCEDPN2(IZ,IX,1).GT.0.)) THEN
                  SCEDPN2(IZ,IX,1)=SQRT(SCEDPN2(IZ,IX,1))*100
               END IF
               IF((SCEDPN2(IZ,IX,1).GT.99.9))SCEDPN2(IZ,IX,1)=99.9
               SCEDPN(IZ,IX,1)= (SCEDPN(IZ,IX,1)/RHOR(IRL))/(SCEDPN(IZ,I
     *         X,2)/RHO(2))
            END IF
            IF ((SCEDPN(IZ,IX,4) .EQ. 0.)) THEN
               SCEDPN(IZ,IX,3)=0.
               SCEDPN2(IZ,IX,3)=99.9
               BSTAT(IZ,2)=-1
            ELSE
               SCORE_TEMP=SCEDPN(IZ,IX,3)/SCORE_NORM_NUM
               SCEDPN2(IZ,IX,3)=SCEDPN2(IZ,IX,3)/SCORE_NORM_NUM
               SCEDPN2(IZ,IX,3)=(SCEDPN2(IZ,IX,3)-SCORE_TEMP*SCORE_TEMP)
     *         /(SCORE_NORM_NUM-1)
               IF((SCEDPN2(IZ,IX,3).GE.0.))SCEDPN2(IZ,IX,3)= SQRT(SCEDPN
     *         2(IZ,IX,3))
               IF ((SCORE_TEMP.NE.0.)) THEN
                  SCEDPN2(IZ,IX,3)=SCEDPN2(IZ,IX,3)/SCORE_TEMP*100
                  IF (( SCEDPN2(IZ,IX,3) .GT. 99.9 )) THEN
                     SCEDPN2(IZ,IX,3) = 99.9
                  END IF
               ELSE
                  SCEDPN2(IZ,IX,3)=99.9
               END IF
               SCORE_TEMP=SCEDPN(IZ,IX,4)/SCORE_NORM_NUM
               SCEDPN2(IZ,IX,4)=SCEDPN2(IZ,IX,4)/SCORE_NORM_NUM
               SCEDPN2(IZ,IX,4)=(SCEDPN2(IZ,IX,4)-SCORE_TEMP*SCORE_TEMP)
     *         /(SCORE_NORM_NUM-1)
               IF((SCEDPN2(IZ,IX,4).GE.0.))SCEDPN2(IZ,IX,4)= SQRT(SCEDPN
     *         2(IZ,IX,4))
               IF ((SCORE_TEMP.NE.0.)) THEN
                  SCEDPN2(IZ,IX,4)=SCEDPN2(IZ,IX,4)/SCORE_TEMP*100
                  IF (( SCEDPN2(IZ,IX,4) .GT. 99.9 )) THEN
                     SCEDPN2(IZ,IX,4) = 99.9
                  END IF
               ELSE
                  SCEDPN2(IZ,IX,4)=99.9
               END IF
               IF ((SCEDPN2(IZ,IX,3).EQ.99.9 .OR. SCEDPN2(IZ,IX,4).EQ.99
     *         .9)) THEN
                  BSTAT(IZ,2)=-1
                  SCSPR_COV(IZ,IX,2)=0.
               ELSE
                  SCSPR_COV(IZ,IX,2)=SCSPR_COV(IZ,IX,2)/SCORE_NORM_NUM-
     *            SCEDPN(IZ,IX,3)*SCEDPN(IZ,IX,4)/ (SCORE_NORM_NUM**2)
                  SCSPR_COV(IZ,IX,2)=SCSPR_COV(IZ,IX,2)/(SCEDPN(IZ,IX,3)
     *            * SCEDPN(IZ,IX,4)/(SCORE_NORM_NUM**2)* (SCORE_NORM_NUM
     *            -1))
               END IF
               SCEDPN2(IZ,IX,3)=(SCEDPN2(IZ,IX,3)/100.)**2+ (SCEDPN2(IZ,
     *         IX,4)/100.)**2- 2*SCSPR_COV(IZ,IX,2)
               IF ((SCEDPN2(IZ,IX,3).GT.0.)) THEN
                  SCEDPN2(IZ,IX,3)=SQRT(SCEDPN2(IZ,IX,3))*100
               END IF
               IF((SCEDPN2(IZ,IX,3).GT.99.9))SCEDPN2(IZ,IX,3)=99.9
               SCEDPN(IZ,IX,3)= (SCEDPN(IZ,IX,3)/RHOR(IRL))/(SCEDPN(IZ,I
     *         X,4)/RHO(2))
            END IF
            SCORE_TEMP=SCDOSE(IZ,IX,1)/SCORE_NORM_NUM
            SCDOSE2(IZ,IX,1)=SCDOSE2(IZ,IX,1)/SCORE_NORM_NUM
            SCDOSE2(IZ,IX,1)=(SCDOSE2(IZ,IX,1)-SCORE_TEMP*SCORE_TEMP)/(S
     *      CORE_NORM_NUM-1)
            IF((SCDOSE2(IZ,IX,1).GE.0.))SCDOSE2(IZ,IX,1)= SQRT(SCDOSE2(I
     *      Z,IX,1))
            IF ((SCORE_TEMP.NE.0.)) THEN
               SCDOSE2(IZ,IX,1)=SCDOSE2(IZ,IX,1)/SCORE_TEMP*100
               IF (( SCDOSE2(IZ,IX,1) .GT. 99.9 )) THEN
                  SCDOSE2(IZ,IX,1) = 99.9
               END IF
            ELSE
               SCDOSE2(IZ,IX,1)=99.9
            END IF
            SCORE_TEMP=SCDOSE(IZ,IX,2)/SCORE_NORM_NUM
            SCDOSE2(IZ,IX,2)=SCDOSE2(IZ,IX,2)/SCORE_NORM_NUM
            SCDOSE2(IZ,IX,2)=(SCDOSE2(IZ,IX,2)-SCORE_TEMP*SCORE_TEMP)/(S
     *      CORE_NORM_NUM-1)
            IF((SCDOSE2(IZ,IX,2).GE.0.))SCDOSE2(IZ,IX,2)= SQRT(SCDOSE2(I
     *      Z,IX,2))
            IF ((SCORE_TEMP.NE.0.)) THEN
               SCDOSE2(IZ,IX,2)=SCDOSE2(IZ,IX,2)/SCORE_TEMP*100
               IF (( SCDOSE2(IZ,IX,2) .GT. 99.9 )) THEN
                  SCDOSE2(IZ,IX,2) = 99.9
               END IF
            ELSE
               SCDOSE2(IZ,IX,2)=99.9
            END IF
            SCORE_TEMP=SCDOSE(IZ,IX,3)/SCORE_NORM_NUM
            SCDOSE2(IZ,IX,3)=SCDOSE2(IZ,IX,3)/SCORE_NORM_NUM
            SCDOSE2(IZ,IX,3)=(SCDOSE2(IZ,IX,3)-SCORE_TEMP*SCORE_TEMP)/(S
     *      CORE_NORM_NUM-1)
            IF((SCDOSE2(IZ,IX,3).GE.0.))SCDOSE2(IZ,IX,3)= SQRT(SCDOSE2(I
     *      Z,IX,3))
            IF ((SCORE_TEMP.NE.0.)) THEN
               SCDOSE2(IZ,IX,3)=SCDOSE2(IZ,IX,3)/SCORE_TEMP*100
               IF (( SCDOSE2(IZ,IX,3) .GT. 99.9 )) THEN
                  SCDOSE2(IZ,IX,3) = 99.9
               END IF
            ELSE
               SCDOSE2(IZ,IX,3)=99.9
            END IF
            IF ((SCDOSE2(IZ,IX,1).EQ.99.9 .OR. SCDOSE2(IZ,IX,3).EQ.99.9)
     *      ) THEN
               SCDOSE_COV(IZ,IX,1)=0.0
               IF((BSTAT(IZ,1).NE.-1))BDSTAT(IZ)=-1
            ELSE
               SCDOSE_COV(IZ,IX,1)=SCDOSE_COV(IZ,IX,1)/SCORE_NORM_NUM- S
     *         CDOSE(IZ,IX,1)*SCDOSE(IZ,IX,3)/ (SCORE_NORM_NUM**2)
               SCDOSE_COV(IZ,IX,1)=SCDOSE_COV(IZ,IX,1)/(SCDOSE(IZ,IX,1)*
     *          SCDOSE(IZ,IX,3)/(SCORE_NORM_NUM**2)* (SCORE_NORM_NUM-1))
            END IF
            SCDOSE2(IZ,IX,1)=(SCDOSE2(IZ,IX,1)/100.)**2+ (SCDOSE2(IZ,IX,
     *      3)/100.)**2- 2*SCDOSE_COV(IZ,IX,1)
            IF ((SCDOSE2(IZ,IX,1).GT.0.)) THEN
               SCDOSE2(IZ,IX,1)=SQRT(SCDOSE2(IZ,IX,1))*100
            END IF
            IF((SCDOSE2(IZ,IX,1).GT.99.9))SCDOSE2(IZ,IX,1)=99.9
            IF ((SCDOSE(IZ,IX,3).NE.0.)) THEN
               SCDOSE(IZ,IX,1)=SCDOSE(IZ,IX,1)/SCDOSE(IZ,IX,3)
            END IF
            IF ((SCDOSE2(IZ,IX,2).EQ.99.9 .OR. SCDOSE2(IZ,IX,3).EQ.99.9)
     *      ) THEN
               SCDOSE_COV(IZ,IX,2)=0.0
               IF((BSTAT(IZ,1).NE.-1))BDSTAT(IZ)=-1
            ELSE
               SCDOSE_COV(IZ,IX,2)=SCDOSE_COV(IZ,IX,2)/SCORE_NORM_NUM- S
     *         CDOSE(IZ,IX,2)*SCDOSE(IZ,IX,3)/ (SCORE_NORM_NUM**2)
               SCDOSE_COV(IZ,IX,2)=SCDOSE_COV(IZ,IX,2)/(SCDOSE(IZ,IX,2)*
     *          SCDOSE(IZ,IX,3)/(SCORE_NORM_NUM**2)* (SCORE_NORM_NUM-1))
            END IF
            SCDOSE2(IZ,IX,2)=(SCDOSE2(IZ,IX,2)/100.)**2+ (SCDOSE2(IZ,IX,
     *      3)/100.)**2- 2*SCDOSE_COV(IZ,IX,2)
            IF ((SCDOSE2(IZ,IX,2).GT.0.)) THEN
               SCDOSE2(IZ,IX,2)=SQRT(SCDOSE2(IZ,IX,2))*100
            END IF
            IF((SCDOSE2(IZ,IX,2).GT.99.9))SCDOSE2(IZ,IX,2)=99.9
            IF ((SCDOSE(IZ,IX,3).NE.0.)) THEN
               SCDOSE(IZ,IX,2)=SCDOSE(IZ,IX,2)/SCDOSE(IZ,IX,3)
            END IF
            IF ((SCDOSE(IZ,IX,3).NE.0.)) THEN
               FMASS=AMASS(IZ,IX)
               IF((FMASS .EQ. 0.0))FMASS=1.0
               SCDOSE(IZ,IX,3)=SCDOSE(IZ,IX,3)*1.602e-10/(FMASS*AINFLU)
            END IF
1361     CONTINUE
1362     CONTINUE
1351  CONTINUE
1352  CONTINUE
      CALL OSUMRY
      IF ((ITRACKE .NE. 0)) THEN
         WRITE(IOUT,1370) dble(ICROSS)/dble(ITRACKE)
      END IF
1370  FORMAT(///' Fraction of tracks treated as trackends which were', /
     *T20,' really steps crossing DELTA =', F10.3/' Usually close to 0.5
     * because', ' each crosser turns into a stopper'/)
1090  CONTINUE
1020  CONTINUE
      WRITE(6,1380)
1380  FORMAT(/' End of run',9X,' ',$)
      call egs_fdate(6)
      write(6,'(///)')
      IF ((ERROR_FLAG.EQ.1)) THEN
         WRITE(6,1390)
1390     FORMAT(//' **********  ERRORS AND WARNING MESSAGES  **********'
     *//)
      END IF
      rewind (i_errors)
9998  CONTINUE
      READ (i_errors,END=9999, FMT='(A80)') TEXT
      WRITE (*,'(A79)') TEXT
      GOTO 9998
9999  CONTINUE
      backspace(i_errors)
      write(i_errors,400) ' '
      call egs_fdate(i_errors)
      write(i_errors,'(/"1")')
      write(iout,400) ' '
      call egs_fdate(iout)
      write(iout,'(/"1")')
      call egs_finish
#ifdef HAVE_C_COMPILER
      IF (( n_parallel .GT. 0 .AND. .NOT.is_finished )) THEN
         call egs_pjob_finish(n_job)
         IF (( n_job .EQ. 0 )) THEN
            is_finished = .true.
            call egs_combine_runs(combine_results,'.egsdat')
            NCASET=NCASEO
            IHSTRY=NCASET
            CALL SRCOTO(WEIGHT)
            goto 1150
         END IF
      END IF
#endif
      call SRCEND
      call exit(0)
100   FORMAT('1',80A1//' SPRRZnrc(EGSnrc) ',' ',' ', /'     ON ','linux'
     *,' ',T54,a,$)
200   FORMAT(' ',79('*')/ ' ',T20,'EXECUTION INFORMATION AND WARNING MES
     *SAGES'/ ' ',79('*')/ /' SPRRZnrc(EGSnrc) ',' ',/'     on ','linux'
     *,' ')
201   FORMAT(/' ********* NEW INPUT FILE *********'/)
202   FORMAT(/' ********* RESTARTED INPUT FILE ********* '/ ' ',10X,I12,
     *' NEW + ',I12,' OLD HISTORIES'/ ' ',20X,'NEW RN SEEDS=',2(1X,I12)/
     *)
204   FORMAT(/' ********* DATA ANALYSIS ONLY *********'/)
205   FORMAT(/' ********* RANDOM NUMBERS READ FROM FILE *********'/)
206   FORMAT(/' ********* POST-PROCESSING PARALLEL RUNS **********'/)
210   FORMAT(/' ********* NOT ENOUGH TIME TO FINISH WITHIN', ' LIMIT OF'
     *,F8.2,' HOURS',I5,' BATCHES USED********'/ ' ',I12,' HISTORIES RUN
     *, ',I12,' HISTORIES ANALYZED'//)
220   FORMAT(I12,1X,2I1)
250   FORMAT(/' ********* Final random number pointers:',2(1X,I12),' ***
     *******')
261   FORMAT(/' Finished simulations:'/'   Elapsed, CPU times', ',ratio=
     * ',2F8.1,' (',F8.3,' hr)',3X,F8.2/ T30,' Histories per hour=',F15.
     *1)
400   FORMAT(/' END OF RUN',10X,a,$)
      END
      SUBROUTINE AUSGAB(IARG)
      implicit none
      integer*4 IRL,IARG,IX,IZ,IQL,LATCHL,MEDL,LELKE,I,IP,IFLAG,IT
      real*8 WTL,DEDXME,DEDXMP,DEDXMI,DEDXMJ,XSI,FTMP,EKEtmp,ELKEtmp
      REAL*8 DEDXM1,DEDXM2,SRATIO,ERATIO(3),PRATIO(3)
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/GEOM/ ZPLANE( 101),RCYL(0:10),CYRAD2( 11), NZ,NR,NREG,NPLAN
     *E
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NPLANE
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PHOTIN/ EBINDA(3), GE0(3),GE1(3), GMFP0(2000,3),GMFP1(2000,
     *3),GBR10(2000,3),GBR11(2000,3),GBR20(2000,3),GBR21(2000,3), RCO0(3
     *),RCO1(3), RSCT0(100,3),RSCT1(100,3), COHE0(2000,3),COHE1(2000,3),
     *  PHOTONUC0(2000,3),PHOTONUC1(2000,3), DPMFP, MPGEM(1,3), NGR(3)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/RUSROU/RRZ,RRCUT,RUSROU
      real*8 RRZ,RRCUT
      LOGICAL RUSROU
      COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE
      integer*4 ICHPIN,ILPIN,IOUT,IPAGE
      COMMON/SCORE/ SCSTP,SCSTP2,SCEDPN,SCEDPN2,SCDOSE,SCDOSE2,SCDOSE_CO
     *V, SCSPR_COV, DELTA, DELTLG,DELTAT,PIISTP, SCSTP_LAST,SCDOSE_LAST,
     *SCNUM,IHSTRY, SCSTP_TMP,SCEDPN_TMP,SCDOSE_TMP3, ifano,MXNP,ISTORE,
     *IWATCH,IOUTSP, ICROSS,ITRACKE,BSTAT,BDSTAT
      REAL*8 SCSTP,SCSTP2,SCEDPN( 101,10,4), SCEDPN2( 101,10,4), SCDOSE(
     * 101,10,3), SCDOSE2( 101,10,3), SCDOSE_COV( 101,10,3-1), SCSPR_COV
     *( 101,10,2), DELTA, DELTAT,DELTLG,PIISTP
      integer*8 SCSTP_LAST,SCDOSE_LAST( 101,10), SCNUM( 101,10)
      real*8 SCSTP_TMP,SCEDPN_TMP( 101,10,4), SCDOSE_TMP3( 101,10)
      integer*4 IFANO,MXNP,ISTORE,IWATCH,IOUTSP,ICROSS,ITRACKE, BSTAT( 1
     *01,2),BDSTAT( 101)
      integer*8 ihstry
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(1000,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RB
     *EAM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2
     *,DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,
     *PROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST
     *,ZSOFST,                                                      SVTM
     *P1,SVTMP2,SVTMP3,SVTMP4,
     *          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                        XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,
     *WEIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERVR/ CEXPTR,GWAIT,PATHL,DUMU,DUMX,DUMY,DUMZ, DELTAP,GWTO
     *LD,EPSLON,ARG,EXPMFP,ESAVEIN, IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM, IFO
     *RCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN, MEDTMP,IREJCT
      real*8 CEXPTR,GWAIT,DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,GWTOLD,EPSLON
     *,ARG, EXPMFP,ESAVEIN
      integer*4 NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN,IFORCE,IRODU
     *M, IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,IREJCT
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      DATA ERATIO/ 3*0.0D0 /
      save ERATIO, PRATIO
      sratio = 0
      MXNP=MAX(MXNP,NP)
      IRL=IR(NP)
      IF ((IRL .EQ. 1)) THEN
         IF((IWATCH .GT. 0))CALL WATCH(IARG,IWATCH)
         RETURN
      END IF
      IX=(IRL-2)/NZ+1
      IZ=IRL-1-NZ*(IX-1)
      IQL=IQ(NP)
      WTL=WT(NP)
      LATCHL=LATCH(NP)
      MEDL = MED(IRL)
      IF ((ERATIO(2) .EQ. 0.0)) THEN
         EKEtmp=EKE
         ELKEtmp=ELKE
         MEDIUM=2
         EKE=DELTA
         ELKE = DELTLG
         LELKE=EKE1(MEDIUM)*ELKE+EKE0(MEDIUM)
         DEDXME=EDEDX1(LELKE,MEDIUM)*ELKE+EDEDX0(LELKE,MEDIUM)
         DEDXMP=PDEDX1(LELKE,MEDIUM)*ELKE+PDEDX0(LELKE,MEDIUM)
         write(6,*) ' Initializing track end terms ERATIO and PRATIO: '
         DO 1401 I=1,NMED
            IF ((I.EQ.2)) THEN
               ERATIO(2)=1.0
               PRATIO(2)=1.0
            ELSE
               MEDIUM = I
               EKE=DELTA
               ELKE = DELTLG
               LELKE=EKE1(MEDIUM)*ELKE+EKE0(MEDIUM)
               DEDXMI=EDEDX1(LELKE,MEDIUM)*ELKE+EDEDX0(LELKE,MEDIUM)
               DEDXMJ=PDEDX1(LELKE,MEDIUM)*ELKE+PDEDX0(LELKE,MEDIUM)
               ERATIO(I)=DEDXME/DEDXMI
               PRATIO(I)=DEDXMP/DEDXMJ
               write(6,*) ' Medium ',i,' e-: ',ERATIO(I),' e+: ',PRATIO(
     *         I)
            END IF
1401     CONTINUE
1402     CONTINUE
         EKE=EKEtmp
         ELKE=ELKEtmp
      END IF
      IF ((IARG .EQ. 0)) THEN
         IF ((IQL .NE. 0)) THEN
            IF ((NHSTRY.EQ.SCSTP_LAST)) THEN
               SCSTP_TMP=SCSTP_TMP+1
            ELSE
               SCSTP=SCSTP+SCSTP_TMP
               SCSTP2=SCSTP2+SCSTP_TMP*SCSTP_TMP
               SCSTP_TMP=1
               SCSTP_LAST=NHSTRY
            END IF
         ELSE
            IF ((RUSROU.AND.(W(NP).GT.0.0))) THEN
               IF (((Z(NP).LE.RRZ).AND.(Z(NP)+USTEP*W(NP).GE.RRZ))) THEN
                  IF((rng_seed .GT. 128))call ranmar_get
                  XSI = rng_array(rng_seed)*twom24
                  rng_seed = rng_seed + 1
                  IF ((XSI .LT. RRCUT)) THEN
                     WT(NP)=WTL/RRCUT
                  ELSE
                     WT(NP)=0.0
                  END IF
               END IF
            END IF
         END IF
      END IF
      IF ((ifano .EQ. 1)) THEN
         IF ((iarg .EQ. 15 .OR. iarg .EQ. 17 .OR. iarg .EQ. 19 .OR. iarg
     *    .EQ. 23)) THEN
            np = np + 1
            IF ((np + 1 .GT. 40)) THEN
               WRITE(6,1410)
1410           FORMAT(' Fano calculation unable to boost stack.'/ ' Stop
     *ping.'/ 1x,80('*')/)
               stop
            END IF
            X(np)=X(np - 1)
            Y(np)=Y(np - 1)
            Z(np)=Z(np - 1)
            IR(np)=IR(np - 1)
            WT(np)=WT(np - 1)
            DNEAR(np)=DNEAR(np - 1)
            LATCH(np)=LATCH(np - 1)
            e(np) = e(np - 1)
            u(np) = u(np - 1)
            v(np) = v(np - 1)
            w(np) = w(np - 1)
            iq(np) = iq(np - 1)
            return
         END IF
         IF (( iarg .EQ. 18  .OR. iarg .EQ. 20  .OR. iarg .EQ. 24  .OR.
     *   iarg .EQ. 7  .OR. iarg .EQ. 13  .OR. iarg .EQ. 14)) THEN
            DO 1421 ip=NPold,NP
               IF (( iq(ip) .EQ. 0 )) THEN
                  wt(ip) = 0
                  e(ip) = 0
               END IF
1421        CONTINUE
1422        CONTINUE
         END IF
      END IF
      IF ((IARG .EQ. 18 .OR. IARG .EQ. 20)) THEN
         DO 1431 ip=NPold,NP
            IF ((iq(ip) .EQ. -1 .AND. E(NP) .LT. DELTAT )) THEN
               LATCH(ip)= 99
            END IF
1431     CONTINUE
1432     CONTINUE
      ELSE IF((IARG .EQ. 16)) THEN
         IF (( E(NP) .LT. DELTAT )) THEN
            LATCH(NP)= 99
         END IF
      END IF
      IF((IWATCH .GT. 0))CALL WATCH(IARG,IWATCH)
      IFLAG=0
      IF (((EDEP .NE. 0.0) .AND. (WTL .GT. 0.0) .AND. (IARG .LT. 5))) TH
     *EN
         FTMP=WTL*EDEP
         IF ((IQL .NE. 0)) THEN
            EKE = E(NP) - PRM
            IF ((EKE.LE.0.0)) THEN
               EKE = 1.E-5
               ELKE=1E30
            ELSE
               ELKE = LOG(EKE)
            END IF
         END IF
         EKEtmp=EKE
         ELKEtmp=ELKE
         IF ((IARG.EQ.0)) THEN
            EKE = EKEtmp - 0.5*EDEP
            ELKE = LOG(EKE)
         ELSE IF((IQL .NE. 0 .AND. i_do_rr(IRL).EQ.0)) THEN
            IF ((EKE .GE. DELTA .AND. (IARG .NE. 4))) THEN
               WRITE(6,1440)EKE
1440           FORMAT(' AUSGAB: EKE=',F15.9,' is impossible***'/)
               WRITE(6,1450)IARG, IQL, DELTA,E(NP),AE(1),PRM,RM,EDEP
1450           FORMAT('    IARG, IQL, DELTA, E(NP), AE(1), PRM, RM, EDEP
     *:'/ 2I5, 6F11.7)
               STOP
            END IF
         END IF
         IF ((IQL .NE. 0 .AND. IARG .NE.4)) THEN
            IF ((LATCH(NP) .EQ. 99)) THEN
               IFLAG = 1
               IF ((IWATCH .GT. 0 .AND. IWATCH .NE.4 )) THEN
                  WRITE(6,1460)IARG,IRL,EKEtmp
1460              FORMAT(' AUSGAB: discard e- or e+ created below ECUT:I
     *ARG,IRL,' ,'EKEtmp:',2I5,F15.8)
               END IF
               LATCH(NP) = 0
            ELSE IF((EKEtmp - EDEP .GT. DELTA)) THEN
               MEDIUM=2
               LELKE=EKE1(MEDIUM)*ELKE+EKE0(MEDIUM)
               IF ((IQL .EQ. -1)) THEN
                  DEDXM2=EDEDX1(LELKE,MEDIUM)*ELKE+EDEDX0(LELKE,MEDIUM)
               ELSE
                  DEDXM2=PDEDX1(LELKE,MEDIUM)*ELKE+PDEDX0(LELKE,MEDIUM)
               END IF
               MEDIUM = MEDL
               LELKE=EKE1(MEDIUM)*ELKE+EKE0(MEDIUM)
               IF ((IQL .EQ. -1)) THEN
                  DEDXM1=EDEDX1(LELKE,MEDIUM)*ELKE+EDEDX0(LELKE,MEDIUM)
               ELSE
                  DEDXM1=PDEDX1(LELKE,MEDIUM)*ELKE+PDEDX0(LELKE,MEDIUM)
               END IF
               SRATIO=DEDXM2/DEDXM1
            ELSE
               IF (( iarg .NE. 0 )) THEN
                  IF ((IQL.EQ.-1)) THEN
                     SRATIO = ERATIO(MEDL)
                  ELSE
                     SRATIO = PRATIO(MEDL)
                  END IF
               ELSE
                  EKE = 0.5*(EKEtmp+DELTA)
                  ELKE=LOG(EKE)
                  MEDIUM=2
                  LELKE=EKE1(MEDIUM)*ELKE+EKE0(MEDIUM)
                  IF ((IQL .EQ. -1)) THEN
                     DEDXM2=EDEDX1(LELKE,MEDIUM)*ELKE+EDEDX0(LELKE,MEDIU
     *               M)
                  ELSE
                     DEDXM2=PDEDX1(LELKE,MEDIUM)*ELKE+PDEDX0(LELKE,MEDIU
     *               M)
                  END IF
                  MEDIUM = MEDL
                  LELKE=EKE1(MEDIUM)*ELKE+EKE0(MEDIUM)
                  IF ((IQL .EQ. -1)) THEN
                     DEDXM1=EDEDX1(LELKE,MEDIUM)*ELKE+EDEDX0(LELKE,MEDIU
     *               M)
                     SRATIO=DEDXM2/DEDXM1*(EKEtmp-DELTA)+ ERATIO(MEDL)*(
     *               EDEP-EKEtmp+DELTA)
                  ELSE
                     DEDXM1=PDEDX1(LELKE,MEDIUM)*ELKE+PDEDX0(LELKE,MEDIU
     *               M)
                     SRATIO=DEDXM2/DEDXM1*(EKEtmp-DELTA)+ PRATIO(MEDL)*(
     *               EDEP-EKEtmp+DELTA)
                  END IF
                  SRATIO=SRATIO/EDEP
                  ICROSS=ICROSS+1
               END IF
               ITRACKE = ITRACKE + 1
            END IF
         ELSE IF((IQL .EQ. 0 .OR. IARG .EQ. 4)) THEN
            IFLAG = 1
         END IF
         IF ((IARG.EQ.0)) THEN
            EKE=EKEtmp
            ELKE = ELKEtmp
         END IF
         IF ((NHSTRY.EQ.SCDOSE_LAST(IZ,IX))) THEN
            SCDOSE_TMP3(IZ,IX)=SCDOSE_TMP3(IZ,IX)+FTMP
            IF ((IFLAG.EQ.0)) THEN
               SCEDPN_TMP(IZ,IX,1)=SCEDPN_TMP(IZ,IX,1)+FTMP
               SCEDPN_TMP(IZ,IX,2)=SCEDPN_TMP(IZ,IX,2)+FTMP*SRATIO
            END IF
            IF ((IARG.EQ.0)) THEN
               SCEDPN_TMP(IZ,IX,3)=SCEDPN_TMP(IZ,IX,3)+FTMP
               SCEDPN_TMP(IZ,IX,4)=SCEDPN_TMP(IZ,IX,4)+FTMP*SRATIO
            END IF
         ELSE
            SCEDPN(IZ,IX,1)=SCEDPN(IZ,IX,1)+SCEDPN_TMP(IZ,IX,1)
            SCEDPN2(IZ,IX,1)=SCEDPN2(IZ,IX,1)+SCEDPN_TMP(IZ,IX,1)* SCEDP
     *      N_TMP(IZ,IX,1)
            SCEDPN(IZ,IX,2)=SCEDPN(IZ,IX,2)+SCEDPN_TMP(IZ,IX,2)
            SCEDPN2(IZ,IX,2)=SCEDPN2(IZ,IX,2)+SCEDPN_TMP(IZ,IX,2)* SCEDP
     *      N_TMP(IZ,IX,2)
            SCSPR_COV(IZ,IX,1)=SCSPR_COV(IZ,IX,1)+SCEDPN_TMP(IZ,IX,2)* S
     *      CEDPN_TMP(IZ,IX,1)
            SCEDPN(IZ,IX,3)=SCEDPN(IZ,IX,3)+SCEDPN_TMP(IZ,IX,3)
            SCEDPN2(IZ,IX,3)=SCEDPN2(IZ,IX,3)+SCEDPN_TMP(IZ,IX,3)* SCEDP
     *      N_TMP(IZ,IX,3)
            SCEDPN(IZ,IX,4)=SCEDPN(IZ,IX,4)+SCEDPN_TMP(IZ,IX,4)
            SCEDPN2(IZ,IX,4)=SCEDPN2(IZ,IX,4)+SCEDPN_TMP(IZ,IX,4)* SCEDP
     *      N_TMP(IZ,IX,4)
            SCSPR_COV(IZ,IX,2)=SCSPR_COV(IZ,IX,2)+SCEDPN_TMP(IZ,IX,4)* S
     *      CEDPN_TMP(IZ,IX,3)
            SCDOSE(IZ,IX,1)=SCDOSE(IZ,IX,1)+SCEDPN_TMP(IZ,IX,1)- SCEDPN_
     *      TMP(IZ,IX,3)
            SCDOSE2(IZ,IX,1)=SCDOSE2(IZ,IX,1)+(SCEDPN_TMP(IZ,IX,1)- SCED
     *      PN_TMP(IZ,IX,3))**2
            SCDOSE_COV(IZ,IX,1)=SCDOSE_COV(IZ,IX,1)+SCDOSE_TMP3(IZ,IX)*
     *      (SCEDPN_TMP(IZ,IX,1)-SCEDPN_TMP(IZ,IX,3))
            SCDOSE(IZ,IX,2)=SCDOSE(IZ,IX,2)+SCDOSE_TMP3(IZ,IX)- SCEDPN_T
     *      MP(IZ,IX,1)
            SCDOSE2(IZ,IX,2)=SCDOSE2(IZ,IX,2)+(SCDOSE_TMP3(IZ,IX)- SCEDP
     *      N_TMP(IZ,IX,1))**2
            SCDOSE_COV(IZ,IX,2)=SCDOSE_COV(IZ,IX,2)+SCDOSE_TMP3(IZ,IX)*
     *      (SCDOSE_TMP3(IZ,IX)-SCEDPN_TMP(IZ,IX,1))
            SCDOSE(IZ,IX,3)=SCDOSE(IZ,IX,3)+SCDOSE_TMP3(IZ,IX)
            SCDOSE2(IZ,IX,3)=SCDOSE2(IZ,IX,3)+SCDOSE_TMP3(IZ,IX)* SCDOSE
     *      _TMP3(IZ,IX)
            IF ((IFLAG.EQ.0)) THEN
               SCEDPN_TMP(IZ,IX,1)=FTMP
               SCEDPN_TMP(IZ,IX,2)=FTMP*SRATIO
            ELSE
               SCEDPN_TMP(IZ,IX,1)=0.
               SCEDPN_TMP(IZ,IX,2)=0.
            END IF
            IF ((IARG.EQ.0)) THEN
               SCEDPN_TMP(IZ,IX,3)=FTMP
               SCEDPN_TMP(IZ,IX,4)=FTMP*SRATIO
            ELSE
               SCEDPN_TMP(IZ,IX,3)=0.
               SCEDPN_TMP(IZ,IX,4)=0.
            END IF
            SCDOSE_TMP3(IZ,IX)=FTMP
            SCDOSE_LAST(IZ,IX)=NHSTRY
            SCNUM(IZ,IX)=SCNUM(IZ,IX)+1
         END IF
         IF (((IWATCH .GT. 1) .AND. (IWATCH .NE. 4))) THEN
            WRITE(6,1470)FTMP/RHOR(IRL),IRL,IARG
1470        FORMAT(5x,' ***EDEP scored = ',E14.7,' MeV. IRL= ',I3,' IARG
     *= ',I3)
            WRITE(6,1480)FTMP*SRATIO/RHO(2),IRL,IARG
1480        FORMAT(5x,' ***EDEP*SRATIO/RHO(2) scored = ', E14.7,' MeV. I
     *RL= ',I3,' IARG= ',I3)
         END IF
      END IF
      RETURN
      END
      SUBROUTINE OLD_GRID(GRIDWD,GRIDHT,MXLP11,MXLP12,ICHPIN,ILPIN,FITS)
      implicit none
      integer*4 MXLP11,MXLP12
      LOGICAL FITS
      INTEGER GRIDWD,GRIDHT,ICHPIN,ILPIN
      FITS=.TRUE.
      IF ((GRIDWD.LE.96)) THEN
         ICHPIN=12
      ELSE IF((GRIDWD.LE.105)) THEN
         ICHPIN=13
      ELSE IF((GRIDWD.LE.132)) THEN
         ICHPIN=16
      ELSE
         FITS=.FALSE.
      END IF
      IF ((GRIDHT.LE.MXLP11)) THEN
         ILPIN=6
      ELSE IF((GRIDHT.LT.MXLP12)) THEN
         ILPIN=8
      ELSE
         FITS=.FALSE.
      END IF
      RETURN
      END
      SUBROUTINE HOWNEAR(tperp,x,y,z,ir)
      implicit none
      COMMON/GEOM/ ZPLANE( 101),RCYL(0:10),CYRAD2( 11), NZ,NR,NREG,NPLAN
     *E
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NPLANE
      real*8 tperp,  x,  y,  z
      integer*4 ir
      real*8 r
      integer*4 ix,  iz
      r = sqrt(x**2 + y**2)
      ix = (ir -2)/nz + 1
      iz = ir - 1 - nz*(ix - 1)
      tperp = min(z - zplane(iz),zplane(iz + 1) - z,rcyl(ix) - r)
      IF ((ix .NE. 1)) THEN
         tperp = min(tperp,r-rcyl(ix - 1))
      END IF
      return
      end
      SUBROUTINE HOWFAR
      implicit none
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/GEOM/ ZPLANE( 101),RCYL(0:10),CYRAD2( 11), NZ,NR,NREG,NPLAN
     *E
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NPLANE
      COMMON/SCORE/ SCSTP,SCSTP2,SCEDPN,SCEDPN2,SCDOSE,SCDOSE2,SCDOSE_CO
     *V, SCSPR_COV, DELTA, DELTLG,DELTAT,PIISTP, SCSTP_LAST,SCDOSE_LAST,
     *SCNUM,IHSTRY, SCSTP_TMP,SCEDPN_TMP,SCDOSE_TMP3, ifano,MXNP,ISTORE,
     *IWATCH,IOUTSP, ICROSS,ITRACKE,BSTAT,BDSTAT
      REAL*8 SCSTP,SCSTP2,SCEDPN( 101,10,4), SCEDPN2( 101,10,4), SCDOSE(
     * 101,10,3), SCDOSE2( 101,10,3), SCDOSE_COV( 101,10,3-1), SCSPR_COV
     *( 101,10,2), DELTA, DELTAT,DELTLG,PIISTP
      integer*8 SCSTP_LAST,SCDOSE_LAST( 101,10), SCNUM( 101,10)
      real*8 SCSTP_TMP,SCEDPN_TMP( 101,10,4), SCDOSE_TMP3( 101,10)
      integer*4 IFANO,MXNP,ISTORE,IWATCH,IOUTSP,ICROSS,ITRACKE, BSTAT( 1
     *01,2),BDSTAT( 101)
      integer*8 ihstry
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      LOGICAL OUTEND,OUTSID
      integer*4 IRL,IX,IZ,IHITP,IHITC,IZNEW,IXNEW
      real*8 ZL,RL,ZLEFT,ZRIGHT,ROUT,DNTMP,RIN,WL,TPLANE,U1,V1,A,TCYL,X1
     *,Y1,B,B2, C,COUT,CIN,RAD
      IF ((WT(NP) .EQ. 0.0)) THEN
         IDISC=1
         RETURN
      END IF
      OUTEND=.FALSE.
      OUTSID=.FALSE.
      IRL=IR(NP)
      IF ((IRL .EQ. 1)) THEN
         IF ((IWATCH .GT. 0 .AND. IWATCH .NE.4)) THEN
            WRITE(6,1490)
1490        FORMAT(' LEAVING GEOMETRY,IDISC=1')
         END IF
         IDISC=1
         RETURN
      END IF
      IX=(IRL-2)/NZ+1
      IZ=IRL-1-NZ*(IX-1)
      IF (((IQ(NP).NE.0))) THEN
         ZL=Z(NP)
         RL=SQRT(X(NP)**2+Y(NP)**2)
         ZLEFT=ZL-ZPLANE(IZ)
         ZRIGHT=ZPLANE(IZ+1)-ZL
         ROUT=RCYL(IX)-RL
         DNTMP=MIN(ZLEFT,ZRIGHT,ROUT)
         IF ((IX.NE.1)) THEN
            RIN=RL-RCYL(IX-1)
            DNTMP=MIN(DNTMP,RIN)
         END IF
         DNEAR(NP)=DNTMP
      END IF
      WL=W(NP)
      IF ((WL.GT.0.0)) THEN
         IHITP=1
         TPLANE=(ZPLANE(IZ+1)-Z(NP))/WL
      ELSE IF((WL.LT.0.0)) THEN
         IHITP=-1
         TPLANE=(ZPLANE(IZ)-Z(NP))/WL
      ELSE
         IHITP=0
         TPLANE=1.0E30
      END IF
      U1=U(NP)
      V1=V(NP)
      A=U1*U1+V1*V1
      IF ((A .EQ. 0.0)) THEN
         IHITC=0
         TCYL=1.0E30
      ELSE
         X1=X(NP)
         Y1=Y(NP)
         B=X1*U1+Y1*V1
         B2=B*B
         C=X1*X1+Y1*Y1
         COUT=C-CYRAD2(IX)
         IF ((COUT.GT.0.0)) THEN
            IF ((IWATCH.GT.0)) THEN
               WRITE(6,1500)COUT
1500           FORMAT(' COUT=',E11.3)
            END IF
            COUT=0.0
         END IF
         IF ((B.GT.0.0)) THEN
            IHITC=1
            IF ((COUT/B2.GT.-1.0E-3)) THEN
               TCYL=-0.5*COUT/B
            ELSE
               TCYL=-COUT/(SQRT(B2-A*COUT)+B)
            END IF
         ELSE IF((B.LT.0.0)) THEN
            IHITC=1
            IF ((COUT/B2.GT.-1.0E-3)) THEN
               TCYL=-2.*B/A*(1.-0.25*A*COUT/B2)
            ELSE
               TCYL=(SQRT(B2-A*COUT)-B)/A
            END IF
            IF ((IX.NE.1)) THEN
               CIN=C-CYRAD2(IX-1)
               IF ((CIN.LT.0.0)) THEN
                  IF ((IWATCH.GT.0)) THEN
                     WRITE(6,1510)CIN
1510                 FORMAT(' CIN=',E11.3)
                  END IF
                  CIN=0.0
               END IF
               RAD=B2-A*CIN
               IF ((RAD.GE.0.0)) THEN
                  IHITC=-1
                  IF ((CIN/B2.LT.1.0E-3)) THEN
                     TCYL=-0.5*CIN/B
                  ELSE
                     TCYL=CIN/(SQRT(RAD)-B)
                  END IF
               END IF
            END IF
         ELSE
            IHITC=1
            TCYL=SQRT(-COUT/A)
         END IF
      END IF
      IZNEW=IZ+IHITP
      IF(((IZNEW.LT.1).OR.(IZNEW.GT.NZ)))OUTEND=.TRUE.
      IXNEW=IX+IHITC
      IF((IXNEW.GT.NR))OUTSID=.TRUE.
      IF (((IHITP.NE.0).AND.(IHITC.NE.0))) THEN
         IF ((TPLANE.LT.TCYL)) THEN
            IF ((OUTEND)) THEN
               IF ((TPLANE.LE.USTEP)) THEN
                  USTEP=TPLANE
                  IRNEW=1
               END IF
               RETURN
            ELSE
               IF ((TPLANE.LE.USTEP)) THEN
                  USTEP=TPLANE
                  IRNEW=IRL+IHITP
               END IF
               RETURN
            END IF
         ELSE IF((TCYL.LT.TPLANE)) THEN
            IF ((OUTSID)) THEN
               IF ((TCYL.LE.USTEP)) THEN
                  USTEP=TCYL
                  IRNEW=1
               END IF
               RETURN
            ELSE
               IF ((TCYL.LE.USTEP)) THEN
                  USTEP=TCYL
                  IRNEW=IRL+NZ*IHITC
               END IF
               RETURN
            END IF
         ELSE
            IF ((OUTEND.OR.OUTSID)) THEN
               IF ((TCYL.LE.USTEP)) THEN
                  USTEP=TCYL
                  IRNEW=1
               END IF
               RETURN
            ELSE
               IF ((TCYL.LE.USTEP)) THEN
                  USTEP=TCYL
                  IRNEW=IRL+IHITP+NZ*IHITC
               END IF
               RETURN
            END IF
         END IF
      ELSE IF((IHITP.NE.0)) THEN
         IF ((OUTEND)) THEN
            IF ((TPLANE.LE.USTEP)) THEN
               USTEP=TPLANE
               IRNEW=1
            END IF
            RETURN
         ELSE
            IF ((TPLANE.LE.USTEP)) THEN
               USTEP=TPLANE
               IRNEW=IRL+IHITP
            END IF
            RETURN
         END IF
      ELSE
         IF ((OUTSID)) THEN
            IF ((TCYL.LE.USTEP)) THEN
               USTEP=TCYL
               IRNEW=1
            END IF
            RETURN
         ELSE
            IF ((TCYL.LE.USTEP)) THEN
               USTEP=TCYL
               IRNEW=IRL+NZ*IHITC
            END IF
            RETURN
         END IF
      END IF
      END
      SUBROUTINE INPUTS
      implicit none
      CHARACTER*4 BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,
     *SCHAR, TCHAR,UCHAR,VCHAR
      COMMON/CHARS/ BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHA
     *R,SCHAR,TCHAR,UCHAR,VCHAR
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/GEOM/ ZPLANE( 101),RCYL(0:10),CYRAD2( 11), NZ,NR,NREG,NPLAN
     *E
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NPLANE
      character*1 title(80)
      COMMON/IODAT1/TITLE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(100,10),TMCPUO,TIMMAX,ST
     *ATLM,EIN, IDAT,IRESTART,IQIN,IVAL,ISPRREG,ISPR( 1001)
      integer*8 NCASE,NCASEO,NCASET
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN
      integer*4 IDAT,IRESTART,IQIN,IVAL,ISPR, ISPRREG,DATCOUNT
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/RUSROU/RRZ,RRCUT,RUSROU
      real*8 RRZ,RRCUT
      LOGICAL RUSROU
      COMMON/SCORE/ SCSTP,SCSTP2,SCEDPN,SCEDPN2,SCDOSE,SCDOSE2,SCDOSE_CO
     *V, SCSPR_COV, DELTA, DELTLG,DELTAT,PIISTP, SCSTP_LAST,SCDOSE_LAST,
     *SCNUM,IHSTRY, SCSTP_TMP,SCEDPN_TMP,SCDOSE_TMP3, ifano,MXNP,ISTORE,
     *IWATCH,IOUTSP, ICROSS,ITRACKE,BSTAT,BDSTAT
      REAL*8 SCSTP,SCSTP2,SCEDPN( 101,10,4), SCEDPN2( 101,10,4), SCDOSE(
     * 101,10,3), SCDOSE2( 101,10,3), SCDOSE_COV( 101,10,3-1), SCSPR_COV
     *( 101,10,2), DELTA, DELTAT,DELTLG,PIISTP
      integer*8 SCSTP_LAST,SCDOSE_LAST( 101,10), SCNUM( 101,10)
      real*8 SCSTP_TMP,SCEDPN_TMP( 101,10,4), SCDOSE_TMP3( 101,10)
      integer*4 IFANO,MXNP,ISTORE,IWATCH,IOUTSP,ICROSS,ITRACKE, BSTAT( 1
     *01,2),BDSTAT( 101)
      integer*8 ihstry
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(1000,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RB
     *EAM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2
     *,DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,
     *PROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST
     *,ZSOFST,                                                      SVTM
     *P1,SVTMP2,SVTMP3,SVTMP4,
     *          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                        XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,
     *WEIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/SPECTR/ CDFINV(1000,2),ENSRCD(0:300),SRCPDF(300),SRCCDF(300
     *), NENSRC
      real*8 CDFINV,ENSRCD,SRCPDF,SRCCDF
      integer*4 NENSRC
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERVR/ CEXPTR,GWAIT,PATHL,DUMU,DUMX,DUMY,DUMZ, DELTAP,GWTO
     *LD,EPSLON,ARG,EXPMFP,ESAVEIN, IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM, IFO
     *RCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN, MEDTMP,IREJCT
      real*8 CEXPTR,GWAIT,DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,GWTOLD,EPSLON
     *,ARG, EXPMFP,ESAVEIN
      integer*4 NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN,IFORCE,IRODU
     *M, IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,IREJCT
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,3), eno_array(200,3), eno_atbin_array(200,3), n_sh
     *ell(3), radc_flag,  ibcmp( 1001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 ixxin,jxxin,n_ibcmp_warnings,IT,IX,IZ,ICOUNT
      INTEGER INEXT
      INTEGER MODEIN
      REAL TEMP1,TEMP2,TEMP3,TEMP4
      REAL SMAX
      REAL ADDING
      INTEGER I, J, K, PLN, COUNT, SLENGHT,ii,IRL,ILOW,IHIGH,ICYL,ISLAB
      INTEGER n_incoh_warnings,  n_iedgfl_warnings
      INTEGER NUM_TITLE,  NUM_IWATCH, NUM_STRAND, NUM_IRESTART, NUM_STOR
     *E, NUM_SPRREG, NUM_SPR1, NUM_SPR2,  NUM_HIST, NUM_SEEDS, NUM_MXTIM
     *E, num_ifano,  NUM_SMAX, NUM_RAYLEIGH, NUM_HOWFAR, NUM_RUSROU, NUM
     *_RUSFRAC, NUM_XTRANSF, NUM_FORCE, NUM_STRTFRC, NUM_STPFRC,  NUM_IR
     *EJCT, NUM_ESAVEIN
      integer*4 data_unit, egs_open_datfile
      IVAL=0
      ERROR_FLAG=0
      DO 1521 J=1,100
         NVALUE(J)=0
1521  CONTINUE
1522  CONTINUE
      WRITE(6,1530)10, 101
1530  FORMAT(//' SPRRZnrc(EGSnrc) ',' ', /' On ','linux',' .', 4x,'Max n
     *o of radial/ depth zones=',2I4)
      IVAL=IVAL+1
      NUM_TITLE=IVAL
      VALUES_SOUGHT(IVAL)='TITLE'
      TYPE(IVAL)=2
      NVALUE(IVAL)=1
      DELIMETER='NONE'
      NMIN = NUM_TITLE
      NMAX = NUM_TITLE
      CALL GET_INPUT
      WRITE(6,1540)
1540  FORMAT(' ')
      WRITE(6,1550)
1550  FORMAT(' ')
      WRITE(6,1560)
1560  FORMAT(' *** INPUT CARD I01 ***')
      READ (CHAR_VALUE(NUM_TITLE,1),FMT='(80A1)') (TITLE(I),I=1,80)
      WRITE (*,1570) (TITLE(I),I=1,79)
1570  FORMAT ('TITLE: ',79A1)
      WRITE(6,1580)
1580  FORMAT(' ')
      IVAL=IVAL+1
      NUM_IWATCH=IVAL
      VALUES_SOUGHT(IVAL)='IWATCH'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      DEFAULT(IVAL)=0
      ALLOWED_INPUTS(IVAL,0)='OFF'
      ALLOWED_INPUTS(IVAL,1)='INTERACTIONS'
      ALLOWED_INPUTS(IVAL,2)='STEPS'
      ALLOWED_INPUTS(IVAL,3)='DEPOSITED'
      ALLOWED_INPUTS(IVAL,4)='GRAPH'
      IVAL=IVAL+1
      NUM_STRAND=IVAL
      VALUES_SOUGHT(IVAL)='STORE INITIAL RANDOM NUMBERS'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      DEFAULT(IVAL)=0
      ALLOWED_INPUTS(IVAL,0)='NO'
      ALLOWED_INPUTS(IVAL,1)='LAST'
      ALLOWED_INPUTS(IVAL,2)='ALL'
      IVAL=IVAL+1
      NUM_IRESTART=IVAL
      VALUES_SOUGHT(IVAL)='IRESTART'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      DEFAULT(IVAL)=0
      ALLOWED_INPUTS(IVAL,0)='FIRST'
      ALLOWED_INPUTS(IVAL,1)='RESTART'
      ALLOWED_INPUTS(IVAL,3)='ANALYZE'
      ALLOWED_INPUTS(IVAL,4)='START-RNS'
      ALLOWED_INPUTS(IVAL,5)='PARALLEL'
      IVAL=IVAL+1
      NUM_STORE=IVAL
      VALUES_SOUGHT(IVAL)='STORE DATA ARRAYS'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      DEFAULT(IVAL)=1
      ALLOWED_INPUTS(IVAL,0)='YES'
      ALLOWED_INPUTS(IVAL,1)='NO'
      DELIMETER='I/O CONTROL'
      NMIN = NUM_IWATCH
      NMAX = NUM_STORE
      CALL GET_INPUT
      WRITE(6,1590)
1590  FORMAT(' *** INPUT CARD IO2 ***')
      IWATCH=VALUE(NUM_IWATCH,1)
      ISTORE=VALUE(NUM_STRAND,1)
      IRESTART=VALUE(NUM_IRESTART,1)
      IDAT=VALUE(NUM_STORE,1)
      WRITE(6,1600)IWATCH,ISTORE,IRESTART,IDAT
1600  FORMAT(/' DO NOT TRACK(0) OR TRACK(>0) EVERY INTERACTION:',T60,I12
     */ ' DO NOT STORE(0) OR STORE(1,2,3) INITIAL RANDOM #:',T60,I12/ 'F
     *IRST RUN(0),RESTART(1),ANALYZE(3),START RNS(4),PARALLEL(5):', T60,
     *I12/ ' STORE RAW DATA(0) OR NOT(1):',T60,I12)
      IF ((IDAT.EQ.1)) THEN
         INEXT=0
      ELSE
         INEXT=1
      END IF
      IF ((IRESTART .EQ. 4)) THEN
         IDAT=1
         ISTORE=0
      END IF
      IVAL = IVAL + 1
      NUM_SPRREG = IVAL
      VALUES_SOUGHT(IVAL)='SPR OUTPUT'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='REGIONS'
      ALLOWED_INPUTS(IVAL,1)='SLABS/CYLINDERS'
      NMIN = NUM_SPRREG
      NMAX = NUM_SPRREG
      CALL GET_INPUT
      ISPRREG=VALUE(NUM_SPRREG,1)
      IF ((ISPRREG.EQ.0)) THEN
         IVAL=IVAL+1
         NUM_SPR1=IVAL
         VALUES_SOUGHT(IVAL)='SPR START REGION'
         TYPE(IVAL)=0
         VALUE_MIN(IVAL)=2
         VALUE_MAX(IVAL)= 1001
         DEFAULT(IVAL)=1
         IVAL=IVAL+1
         NUM_SPR2=IVAL
         VALUES_SOUGHT(IVAL)='SPR STOP REGION'
         TYPE(IVAL)=0
         VALUE_MIN(IVAL)=2
         VALUE_MAX(IVAL)= 1001
         DEFAULT(IVAL)=1
      ELSE IF((ISPRREG.EQ.1)) THEN
         IVAL=IVAL+1
         NUM_SPR1=IVAL
         VALUES_SOUGHT(IVAL)='SPR IN CYLINDER IX'
         TYPE(IVAL)=0
         VALUE_MIN(IVAL)=0
         VALUE_MAX(IVAL)=10
         DEFAULT(IVAL)=0
         IVAL=IVAL+1
         NUM_SPR2=IVAL
         VALUES_SOUGHT(IVAL)='SPR IN SLAB IZ'
         TYPE(IVAL)=0
         VALUE_MIN(IVAL)=0
         VALUE_MAX(IVAL)=100
         DEFAULT(IVAL)=0
      END IF
      NMIN = NUM_SPR1
      NMAX = NUM_SPR2
      CALL GET_INPUT
      IVAL=IVAL+1
      NUM_HIST=IVAL
      VALUES_SOUGHT(IVAL)='NUMBER OF HISTORIES'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=1
      VALUE_MAX(IVAL)=4.611686e18
      DEFAULT(IVAL)=20000
      IVAL=IVAL+1
      NUM_MXTIME=IVAL
      VALUES_SOUGHT(IVAL)='MAX CPU HOURS ALLOWED'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=1000
      DEFAULT(IVAL)=999.0
      IVAL=IVAL+1
      NUM_IFANO=IVAL
      VALUES_SOUGHT(IVAL)='PHOTON REGENERATION'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='NO'
      ALLOWED_INPUTS(IVAL,1)='YES'
      DELIMETER='MONTE CARLO INPUTS'
      NMIN = NUM_HIST
      NMAX = NUM_IFANO
      CALL GET_INPUT
      ival = ival + 1
      VALUES_SOUGHT(IVAL)='INITIAL RANDOM NO. SEEDS'
      nvalue(ival) = 2
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) = 30081
      default(ival) = 9373
      delimeter = 'MONTE CARLO INPUTS'
      nmin = ival
      nmax = ival
      call get_input
      IF (( error_flags(ival) .EQ. 0 )) THEN
         ixxin = value(ival,1)
         jxxin = value(ival,2)
      ELSE
         ixxin = 0
         jxxin = 0
      END IF
      IF((i_parallel .GT. 0))jxxin = jxxin - 1 + i_parallel
      ixx = ixxin
      jxx = jxxin
      call init_ranmar
      WRITE(6,1610)
1610  FORMAT(/,' *** INPUT CARD MC1 ***')
      NCASE=VALUE(NUM_HIST,1)
      TIMMAX=VALUE(NUM_MXTIME,1)
      ifano = VALUE(num_ifano,1)
      IF ((IWATCH.EQ.0 .AND. NCASE.LT.10)) THEN
         NCASE=10
      END IF
      WRITE(6,1620)NCASE,ixxin,jxxin,TIMMAX
1620  FORMAT(/' # OF HISTORIES:',T60,I12/ ' 1st initial random number se
     *ed: ',T60,I12/,' 2nd initial random number seed: ',T60,I12/, ' MAX
     *IMUM CPU TIME ALLOWED:',T60,F10.2,' HRS'/)
      IF (( ifano .EQ. 1 )) THEN
         WRITE(6,1630)
1630     FORMAT(/' ********* Calculation WITH photon regeneration ******
     *** '/)
      ELSE
         WRITE(6,1640)
1640     FORMAT(/' ********* Calculation WITHOUT photon regeneration ***
     ***** '/)
      END IF
      IF ((ERROR_FLAG.EQ.1)) THEN
         GOTO 1650
      END IF
      CALL GEOMRZ
      IF ((NMED.EQ.1)) THEN
         WRITE(6,1660)
1660     FORMAT(' ')
         WRITE(6,1670)
1670     FORMAT(' *****************WARNING*****************')
         WRITE(6,1680)
1680     FORMAT(' ****SPRRZnrc requires at least two media*****')
         WRITE(6,1690)
1690     FORMAT(' ')
         WRITE(15,*) ' '
         WRITE(15,*) ' *****************WARNING*****************'
         WRITE(15,*) ' ****SPRRZnrc requires at least two media*****'
         WRITE(15,*) ' '
         ERROR_FLAG=1
      END IF
      IF ((NMED.GT.3)) THEN
         WRITE(6,1700)3
1700     FORMAT(//' *****************ERROR******************'/ ' No. ofm
     *edia > max. no. of media allowed (',I4,')'/ ' Increase $MXMED insr
     *crznrc.mortran, recompile'/ ' and try again.'//)
         ERROR_FLAG=1
      END IF
      IF ((ERROR_FLAG.EQ.1)) THEN
         WRITE(15,*) '***********ERROR in SUBROUTINE GEOMRZ************'
         GOTO 1650
      END IF
      DO 1711 J=1,NREG
         ISPR(J)=0
1711  CONTINUE
1712  CONTINUE
      IF ((ISPRREG.EQ.0)) THEN
         DO 1721 J=1,NVALUE(NUM_SPR1)
            ILOW=VALUE(NUM_SPR1,J)
            IHIGH=VALUE(NUM_SPR2,J)
            IF ((ILOW.GT.NREG)) THEN
               ILOW=NREG
               WRITE(6,1730)NREG,NREG
1730           FORMAT(/' ***WARNING: lower region for outputting stoppin
     *g power ratios > max.'/ '             region in geometry (= ',I4,'
     *).  Will be reset to ',I4/)
            END IF
            IF ((IHIGH.GT.NREG)) THEN
               IHIGH=NREG
               WRITE(6,1740)NREG,NREG
1740           FORMAT(/' ***WARNING: upper region for outputting stoppin
     *g power ratios > max.'/ '             region in geometry (= ',I4,'
     *).  Will be reset to ',I4/)
            END IF
            IF ((ILOW.GT.IHIGH)) THEN
               WRITE(6,1750)IHIGH,ILOW,ILOW
1750           FORMAT(/' ***WARNING: upper region for outputting stoppin
     *g power ratios (',I4,') <'/ '             corresponding lower regi
     *on (',I4,').  Will reset upper region'/ '             to ',I4/)
               IHIGH=ILOW
            END IF
            IF ((ILOW.EQ.IHIGH)) THEN
               ISPR(ILOW)=1
            ELSE
               DO 1761 IRL=ILOW,IHIGH
                  ISPR(IRL)=1
1761           CONTINUE
1762           CONTINUE
            END IF
1721     CONTINUE
1722     CONTINUE
      ELSE IF((ISPRREG.EQ.1)) THEN
         IF ((VALUE(NUM_SPR1,1).GT.0)) THEN
            DO 1771 J=1,NVALUE(NUM_SPR1)
               ICYL=VALUE(NUM_SPR1,J)
               IF ((ICYL.GT.NR)) THEN
                  WRITE(6,1780)ICYL,NR,NR
1780              FORMAT(/' ***WARNING: cylinder no. for outputting stop
     *ping-power ratios (',I4,') >'/ '             max. cylinder no. ofg
     *eometry (',I4,').  Will reset output'/ '             cylinder no. 
     *to ',I4/)
                  ICYL=NR
               END IF
               ISPR(ICYL)=1
1771        CONTINUE
1772        CONTINUE
         END IF
         IF ((VALUE(NUM_SPR2,1).GT.0)) THEN
            DO 1791 J=1,NVALUE(NUM_SPR2)
               ISLAB=VALUE(NUM_SPR2,J)
               IF ((ISLAB.GT.NZ)) THEN
                  WRITE(6,1800)ISLAB,NZ,NZ
1800              FORMAT(/' ***WARNING: slab no. for outputting stopping
     *-power ratios (',I4,') >'/ '             max. slab no. of geometry
     * (',I4,').  Will reset output'/ '             slab no. to ',I4/)
                  ISLAB=NZ
               END IF
               ISPR(NR+ISLAB)=1
1791        CONTINUE
1792        CONTINUE
         END IF
      END IF
      CALL SRCRZ
      CALL SRCINI (SVTMP1,SVTMP2,SVTMP3,SVTMP4,0)
      IF ((ERROR_FLAG.EQ.1)) THEN
         WRITE(15,*) '***********ERROR IN SUBROUTINE SRCRZ************'
         GOTO 1650
      END IF
      IF ((ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOURC.EQ.23)) THEN
         MONOEN=0
      ELSE
         CALL ENSRC
      END IF
      IF ((ERROR_FLAG.EQ.1)) THEN
         WRITE(15,*) '***********ERROR IN SUBROUTINE ENSRC************'
         GOTO 1650
      END IF
      call get_transport_parameter(6)
      IVAL=IVAL+1
      NUM_RUSROU=IVAL
      VALUES_SOUGHT(IVAL)='RUSSIAN ROULETTE DEPTH'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=-1.e30
      VALUE_MAX(IVAL)=1.e30
      DEFAULT(IVAL)=0.0
      IVAL=IVAL+1
      NUM_RUSFRAC=IVAL
      VALUES_SOUGHT(IVAL)='RUSSIAN ROULETTE FRACTION'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=-1.e30
      VALUE_MAX(IVAL)=1.e30
      DEFAULT(IVAL)=0.0
      IVAL=IVAL+1
      NUM_XTRANSF=IVAL
      VALUES_SOUGHT(IVAL)='EXPONENTIAL TRANSFORM C'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=-1.e30
      VALUE_MAX(IVAL)=1.e30
      DEFAULT(IVAL)=0.0
      DELIMETER='VARIANCE REDUCTION'
      NMIN = NUM_RUSROU
      NMAX = NUM_XTRANSF
      CALL GET_INPUT
      WRITE(6,1810)
1810  FORMAT(' *** INPUT CARD TC2C ***')
      RRZ=VALUE(NUM_RUSROU,1)
      RRCUT=VALUE(NUM_RUSFRAC,1)
      CEXPTR=VALUE(NUM_XTRANSF,1)
      RUSROU=.FALSE.
      IF((RRZ+RRCUT.NE.0.0))RUSROU=.TRUE.
      IF ((RUSROU)) THEN
         WRITE(6,1820)RRZ,RRCUT
1820     FORMAT(/' Russian roulette will be played'/ ' Russian roulettep
     *lane:',T30,E14.7/ ' Survival probability:',T30,E14.7/)
      ELSE
         WRITE(6,1830)
1830     FORMAT(' Russian roulette will not be played'/)
      END IF
      IF ((CEXPTR .EQ. 0)) THEN
         WRITE(6,1840)
1840     FORMAT(' No pathlength biasing to be done'/)
      ELSE
         WRITE(6,1850)CEXPTR
1850     FORMAT(' CEXPTR paramater:',T30,E14.7/)
      END IF
      IVAL=IVAL+1
      NUM_FORCE=IVAL
      VALUES_SOUGHT(IVAL)='PHOTON FORCING'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      DEFAULT(IVAL)=0
      ALLOWED_INPUTS(IVAL,0)='OFF'
      ALLOWED_INPUTS(IVAL,1)='ON'
      IVAL=IVAL+1
      NUM_STRTFRC=IVAL
      VALUES_SOUGHT(IVAL)='START FORCING'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)= 1001
      DEFAULT(IVAL)=1
      IVAL=IVAL+1
      NUM_STPFRC=IVAL
      VALUES_SOUGHT(IVAL)='STOP FORCING AFTER'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)= 1001
      DEFAULT(IVAL)=NMED
      IVAL=IVAL+1
      NUM_IREJCT=IVAL
      VALUES_SOUGHT(IVAL)='ELECTRON RANGE REJECTION'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='OFF'
      ALLOWED_INPUTS(IVAL,1)='ON'
      IVAL=IVAL+1
      NUM_ESAVEIN=IVAL
      VALUES_SOUGHT(IVAL)='ESAVEIN'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=0.
      VALUE_MAX(IVAL)=EIN+PRM
      DEFAULT(IVAL) =EIN+PRM
      DELIMETER='VARIANCE REDUCTION'
      NMIN = NUM_FORCE
      NMAX = NUM_ESAVEIN
      CALL GET_INPUT
      WRITE(6,1860)
1860  FORMAT(' *** INPUT CARD TC3 ***')
      IFORCE=VALUE(NUM_FORCE,1)
      NFMIN=VALUE(NUM_STRTFRC,1)
      NFMAX=VALUE(NUM_STPFRC,1)
      IF ((IFORCE .EQ. 0)) THEN
         NFMIN=0
         NFMAX=0
         WRITE(6,1870)
1870     FORMAT(/' NO INTERACTION FORCING IS IN EFFECT'/)
      ELSE
         IF((NFMAX.LT.NFMIN))NFMAX=NFMIN
         WRITE(6,1880)NFMIN,NFMAX
1880     FORMAT(/' FORCED PHOTON INTERACTIONS IN EFFECT FROM',I3,' TO',I
     *3, ' # INTERACTIONS'/)
      END IF
      IQINC=IQIN
      IREJCT=VALUE(NUM_IREJCT,1)
      ESAVEIN=VALUE(NUM_ESAVEIN,1)
      IF ((IREJCT .EQ. 1 )) THEN
         WRITE(6,1890)ESAVEIN
1890     FORMAT(/' RANGE REJECTION IS ON WITH ESAVE = ',F10.4,' MeV'/ ' 
     *EXCEPT IN REGIONS WHERE STOPPING POWER RATIOS ARE TO '/ '  BE OUTP
     *UT.'/)
         IF ((ISPRREG.EQ.0)) THEN
            DO 1901 IRL=1,NREG
               IF ((ISPR(IRL).EQ.0)) THEN
                  i_do_rr(IRL)=1
                  e_max_rr(IRL)=ESAVEIN
               END IF
1901        CONTINUE
1902        CONTINUE
            WRITE(6,1910)
1910        FORMAT(/' STOPPING POWER RATIOS WILL BE OUTPUT IN REGIONS:')
            I=2
1921        CONTINUE
               IF ((ISPR(I).EQ.1)) THEN
                  ILOW=I
                  IHIGH=I
                  J=I+1
1931              CONTINUE
                     IF((ISPR(J).EQ.0))GO TO1932
                     IHIGH=J
                     J=J+1
                     IF(((J.GT.NREG)))GO TO1932
                  GO TO 1931
1932              CONTINUE
                  I=J
                  IF ((ILOW.EQ.IHIGH)) THEN
                     WRITE(6,1940)ILOW
1940                 FORMAT(I25)
                  ELSE
                     WRITE(6,1950)ILOW,IHIGH
1950                 FORMAT(I21,' TO ',I3)
                  END IF
               END IF
               I=I+1
               IF(((I.GT.NREG)))GO TO1922
            GO TO 1921
1922        CONTINUE
         ELSE IF((ISPRREG.EQ.1)) THEN
            DO 1961 IX=1,NR
               IF ((ISPR(IX).EQ.0)) THEN
                  DO 1971 IZ=1,NZ
                     IF ((ISPR(NR+IZ).EQ.0)) THEN
                        IRL=IZ+NZ*(IX-1)+1
                        i_do_rr(IRL)=1
                        e_max_rr(IRL) = ESAVEIN
                     END IF
1971              CONTINUE
1972              CONTINUE
               END IF
1961        CONTINUE
1962        CONTINUE
            ICOUNT=0
            DO 1981 IX=1,NR
               IF ((ISPR(IX).EQ.1)) THEN
                  IF((ICOUNT.EQ.0))WRITE(6,1990)
1990              FORMAT(' OUTPUT AND PLOT STOPPING POWER RATIOS IN CYLI
     *NDERS:')
                  WRITE(6,2000)IX
2000              FORMAT(I25)
                  ICOUNT=ICOUNT+1
               END IF
1981        CONTINUE
1982        CONTINUE
            ICOUNT=0
            DO 2011 IZ=1,NZ
               IF ((ISPR(NR+IZ).EQ.1)) THEN
                  IF((ICOUNT.EQ.0))WRITE(6,2020)
2020              FORMAT(' OUTPUT AND PLOT STOPPING POWER RATIOS IN SLAB
     *S:')
                  WRITE(6,2030)IZ
2030              FORMAT(I25)
                  ICOUNT=ICOUNT+1
               END IF
2011        CONTINUE
2012        CONTINUE
         END IF
      ELSE
         WRITE(6,2040)
2040     FORMAT(/' RANGE REJECTION IS OFF'/)
         WRITE(6,2050)
2050     FORMAT(/' STOPPING POWER RATIOS WILL BE OUTPUT FOR ALL REGIONS'
     */)
         IF ((ISPRREG.EQ.1)) THEN
            ICOUNT=0
            DO 2061 IX=1,NR
               IF ((ISPR(IX).EQ.1)) THEN
                  IF((ICOUNT.EQ.0))WRITE(6,2070)
2070              FORMAT(' PLOT STOPPING POWER RATIOS IN CYLINDERS:')
                  WRITE(6,2080)IX
2080              FORMAT(I25)
                  ICOUNT=ICOUNT+1
               END IF
2061        CONTINUE
2062        CONTINUE
            ICOUNT=0
            DO 2091 IZ=1,NZ
               IF ((ISPR(NR+IZ).EQ.1)) THEN
                  IF((ICOUNT.EQ.0))WRITE(6,2100)
2100              FORMAT(' PLOT STOPPING POWER RATIOS IN SLABS:')
                  WRITE(6,2110)IZ
2110              FORMAT(I25)
                  ICOUNT=ICOUNT+1
               END IF
2091        CONTINUE
2092        CONTINUE
         END IF
      END IF
      WRITE(6,2120)
2120  FORMAT(' ')
      IF ((ERROR_FLAG.EQ.1)) THEN
         GOTO 1650
      END IF
      ICROSS=0
      ITRACKE=0
      NCASEO=0
      NCASET=0
      TMCPUO=0
      SCSTP_TMP=0
      IF ((IRESTART .EQ. 0 .OR. IRESTART.EQ.5)) THEN
         NNREAD=0
         SCSTP=0.
         SCSTP2=0.
         SCSTP_LAST=0
         PIISTP=0.
         DO 2131 IX=1,NR
            DO 2141 IZ=1,NZ
               DO 2151 IT=1,4
                  SCEDPN(IZ,IX,IT)=0.
                  SCEDPN2(IZ,IX,IT)=0.
                  SCEDPN_TMP(IZ,IX,IT)=0.
2151           CONTINUE
2152           CONTINUE
               SCDOSE_TMP3(IZ,IX)=0.
               DO 2161 IT=1,3
                  SCDOSE(IZ,IX,IT)=0.
                  SCDOSE2(IZ,IX,IT)=0.
                  IF((IT.LT.3))SCDOSE_COV(IZ,IX,IT)=0.
2161           CONTINUE
2162           CONTINUE
               DO 2171 IT=1,2
                  SCSPR_COV(IZ,IX,IT)=0.
2171           CONTINUE
2172           CONTINUE
               SCDOSE_LAST(IZ,IX)=0
               SCNUM(IZ,IX)=0
2141        CONTINUE
2142        CONTINUE
2131     CONTINUE
2132     CONTINUE
      ELSE IF((IRESTART.NE.4)) THEN
         WRITE(6,2180)
2180     FORMAT(//' ABOUT TO START READING STORED RAW DATA FILE: *.egsda
     *t'/)
         data_unit = egs_open_datfile(4,0,1,'.egsdat')
         READ(data_unit,*,END=2190) SCSTP,SCSTP2
         DO 2201 IZ=1,NZ
            DO 2211 IX=1,NR
               DO 2221 IT=1,4
                  READ(data_unit,*,END=2190)SCEDPN(IZ,IX,IT),SCEDPN2(IZ,
     *            IX,IT)
2221           CONTINUE
2222           CONTINUE
               DO 2231 IT=1,3
                  READ(data_unit,*,END=2190)SCDOSE(IZ,IX,IT),SCDOSE2(IZ,
     *            IX,IT)
2231           CONTINUE
2232           CONTINUE
               READ(data_unit,*,END=2190)SCDOSE_COV(IZ,IX,1),SCDOSE_COV(
     *         IZ,IX,2)
               READ(data_unit,*,END=2190)SCSPR_COV(IZ,IX,1),SCSPR_COV(IZ
     *         ,IX,2)
2211        CONTINUE
2212        CONTINUE
2201     CONTINUE
2202     CONTINUE
         read(data_unit,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_see
     *   d, rng_array
         twom24 = 1./16777216.
         READ(data_unit,*,END=2190) NCASEO,TMCPUO,NNREAD,PIISTP
         READ(data_unit,*,END=2240)ICROSS,ITRACKE
         GO TO 2250
2240     WRITE(6,2260)
2260     FORMAT(/'  ERROR READING IN THE STORED DATA FILE - EOF HIT'/)
2250     WRITE(6,2270)
2270     FORMAT(' FINISHED READING DATA FILE IN')
         CLOSE(UNIT=data_unit)
      END IF
      IF ((IRESTART .EQ. 3)) THEN
         NCASE=0
      END IF
      NCASET=NCASE+NCASEO
1650  CONTINUE
      IF ((ERROR_FLAG .EQ. 0)) THEN
         WRITE(6,2280)
2280     FORMAT(/' ********* SUCCESSFUL INPUT ACCOMPLISHED *********')
         WRITE (15,*) ' '
         WRITE (15,*) ' '
         WRITE (15,*) ' ************************************************
     **'
         WRITE (15,*) ' ********* SUCCESSFUL INPUT ACCOMPLISHED ********
     **'
         WRITE (15,*) ' ************************************************
     **'
         WRITE (15,*) ' '
         WRITE (15,*) ' '
         DO 2291 J=1,5
            WRITE(6,2300)
2300        FORMAT(' ')
2291     CONTINUE
2292     CONTINUE
         RETURN
      END IF
      IF ((ERROR_FLAG.EQ.1)) THEN
         WRITE(15,*) ' '
         WRITE(15,*) ' '
         WRITE(15,*) '*********************************************'
         WRITE(15,*) '********INPUTS  UNSUCCESSFUL  ***************'
         WRITE(15,*) '*********************************************'
         WRITE(15,*) ' '
         WRITE(15,*) ' '
         WRITE(6,2310)
2310     FORMAT(/' SPRRZnrc input file is not correct! - look for errorm
     *essage')
         RETURN
      END IF
2190  CONTINUE
      WRITE(6,2320)
2320  FORMAT(/' END OF FILE FOUND BEFORE .egsdat FILE IN')
      ERROR_FLAG=1
      RETURN
      END
      SUBROUTINE ISUMRY
      implicit none
      COMMON/BOUNDS/ECUT( 1001),PCUT( 1001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/GEOM/ ZPLANE( 101),RCYL(0:10),CYRAD2( 11), NZ,NR,NREG,NPLAN
     *E
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NPLANE
      character*1 title(80)
      COMMON/IODAT1/TITLE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(100,10),TMCPUO,TIMMAX,ST
     *ATLM,EIN, IDAT,IRESTART,IQIN,IVAL,ISPRREG,ISPR( 1001)
      integer*8 NCASE,NCASEO,NCASET
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN
      integer*4 IDAT,IRESTART,IQIN,IVAL,ISPR, ISPRREG,DATCOUNT
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/RUSROU/RRZ,RRCUT,RUSROU
      real*8 RRZ,RRCUT
      LOGICAL RUSROU
      COMMON/SCORE/ SCSTP,SCSTP2,SCEDPN,SCEDPN2,SCDOSE,SCDOSE2,SCDOSE_CO
     *V, SCSPR_COV, DELTA, DELTLG,DELTAT,PIISTP, SCSTP_LAST,SCDOSE_LAST,
     *SCNUM,IHSTRY, SCSTP_TMP,SCEDPN_TMP,SCDOSE_TMP3, ifano,MXNP,ISTORE,
     *IWATCH,IOUTSP, ICROSS,ITRACKE,BSTAT,BDSTAT
      REAL*8 SCSTP,SCSTP2,SCEDPN( 101,10,4), SCEDPN2( 101,10,4), SCDOSE(
     * 101,10,3), SCDOSE2( 101,10,3), SCDOSE_COV( 101,10,3-1), SCSPR_COV
     *( 101,10,2), DELTA, DELTAT,DELTLG,PIISTP
      integer*8 SCSTP_LAST,SCDOSE_LAST( 101,10), SCNUM( 101,10)
      real*8 SCSTP_TMP,SCEDPN_TMP( 101,10,4), SCDOSE_TMP3( 101,10)
      integer*4 IFANO,MXNP,ISTORE,IWATCH,IOUTSP,ICROSS,ITRACKE, BSTAT( 1
     *01,2),BDSTAT( 101)
      integer*8 ihstry
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(1000,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RB
     *EAM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2
     *,DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,
     *PROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST
     *,ZSOFST,                                                      SVTM
     *P1,SVTMP2,SVTMP3,SVTMP4,
     *          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                        XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,
     *WEIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/SPECTR/ CDFINV(1000,2),ENSRCD(0:300),SRCPDF(300),SRCCDF(300
     *), NENSRC
      real*8 CDFINV,ENSRCD,SRCPDF,SRCCDF
      integer*4 NENSRC
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERVR/ CEXPTR,GWAIT,PATHL,DUMU,DUMX,DUMY,DUMZ, DELTAP,GWTO
     *LD,EPSLON,ARG,EXPMFP,ESAVEIN, IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM, IFO
     *RCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN, MEDTMP,IREJCT
      real*8 CEXPTR,GWAIT,DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,GWTOLD,EPSLON
     *,ARG, EXPMFP,ESAVEIN
      integer*4 NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN,IFORCE,IRODU
     *M, IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,IREJCT
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      CHARACTER*4 CDSTBL( 1001),CTRTBL( 1001),CABSRB( 1001)
      integer*4 IOUT,ISUMX,JJ,I,J,IHIGH,ILOW,ICOUNT
      real*8 SMAX,EK0,ESTEPR
      IOUT=1
      write(iout,110) title
      call egs_fdate(iout)
      write(iout,'(" *"/1X,79("*"))')
110   FORMAT(' ',80A1,/1X,79('*')/ ' *',T80, '*'/ ' *',T80, '*'/ ' *',T3
     *4,'************',T80,'*'/ ' *',T34,'*          *',T80,'*'/ ' *',T3
     *4,'* SPRRZnrc *',T80,'*'/ ' *',T34,'*          *',T80,'*'/ ' *',T3
     *4,'************',T80,'*'/ ' *',T80, '*'/ ' * Cylindrical-geometryE
     *GSnrc user-code for scoring stopping power ratios', T80,'*'/ ' *',
     *T80, '*'/ ' *   SPRRZnrc was developed by the National Research Co
     *uncil of Canada', T80,'*'/ ' *',T80, '*'/ ' *     It uses the EGSn
     *rc Code System developed at NRC ',T80,'*'/ ' *     (based on theEG
     *S4 Code System Carlo developed by SLAC and NRC)', T80,'*'/ ' *    
     *       running on ','linux',' ',T80,'*'/ ' *',T80, '*'/ ' *',T54,'
     * ',$)
      call show_transport_parameter(iout)
      WRITE(IOUT,200) NCASE,NCASET,IQIN
      IF ((ISPRREG.EQ.0)) THEN
         IF ((IREJCT.EQ.0)) THEN
            WRITE(IOUT,315)
         ELSE
            WRITE(IOUT,311)
            I=2
2331        CONTINUE
               IF ((ISPR(I).EQ.1)) THEN
                  ILOW=I
                  IHIGH=I
                  J=I+1
2341              CONTINUE
                     IF ((ISPR(J).EQ.0)) THEN
                        GO TO2342
                     END IF
                     IHIGH=J
                     J=J+1
                     IF(((J.GT.NREG)))GO TO2342
                  GO TO 2341
2342              CONTINUE
                  I=J
                  IF ((ILOW.EQ.IHIGH)) THEN
                     WRITE(IOUT,312)ILOW
                  ELSE
                     WRITE(IOUT,313)ILOW,IHIGH
                  END IF
               END IF
               I=I+1
               IF(((I.GT.NREG)))GO TO2332
            GO TO 2331
2332        CONTINUE
         END IF
      ELSE IF((ISPRREG.EQ.1)) THEN
         IF ((IREJCT.EQ.0)) THEN
            WRITE(IOUT,315)
         END IF
         ICOUNT=0
         DO 2351 I=1,NR
            IF ((ISPR(I).EQ.1)) THEN
               IF ((ICOUNT.EQ.0)) THEN
                  IF ((IREJCT.EQ.0)) THEN
                     WRITE(IOUT,257)
                  ELSE
                     WRITE(IOUT,316)
                  END IF
               END IF
               WRITE(IOUT,258)I
               ICOUNT=ICOUNT+1
            END IF
2351     CONTINUE
2352     CONTINUE
         ICOUNT=0
         DO 2361 I=1,NZ
            IF ((ISPR(NR+I).EQ.1)) THEN
               IF ((ICOUNT.EQ.0)) THEN
                  IF ((IREJCT.EQ.0)) THEN
                     WRITE(IOUT,259)
                  ELSE
                     WRITE(IOUT,317)
                  END IF
               END IF
               WRITE(IOUT,258)I
               ICOUNT=ICOUNT+1
            END IF
2361     CONTINUE
2362     CONTINUE
      END IF
      IF ((MONOEN .EQ. 0)) THEN
         WRITE(IOUT,201) EIN
      ELSE
         CALL ENSRCO
      END IF
      WRITE(IOUT,220) SMAX,PCUT(2)
      IF ((IFORCE.NE.0)) THEN
         WRITE(IOUT,230)NFMIN,NFMAX
      ELSE
         WRITE(IOUT,231)
      END IF
      IF ((IREJCT .EQ. 0)) THEN
         WRITE(IOUT,243)
      ELSE IF((IREJCT .EQ. 1)) THEN
         WRITE(IOUT,242)ESAVEIN
      END IF
      DO 2371 I=1,NREG
         IF ((IRAYLR(I).EQ.1)) THEN
            WRITE(IOUT,244)
            GO TO2372
         END IF
2371  CONTINUE
2372  CONTINUE
      WRITE(IOUT,260) TIMMAX,STATLM
      write(iout,'(21x,a,$)') 'Initial RNG state:           '
      write(iout,'(a,2i4,$)') ' ixx jxx = ',ixx,jxx
      write(iout,*)
      IF((RUSROU))WRITE(IOUT,265)RRZ,RRCUT
      IF((CEXPTR.NE.0))WRITE(IOUT,266)CEXPTR
      IF ((ifano .EQ. 0 )) THEN
         WRITE(IOUT,261)
      ELSE IF((ifano .EQ. 1 )) THEN
         WRITE(IOUT,262)
      ELSE
         WRITE(6,2380)ifano
2380     FORMAT(' ifano=',I4, ' not 0 or 1 as it must be ')
         STOP
      END IF
      ISUMX=0
      DO 2391 JJ=1,NREG
         ISUMX=ISUMX+IEDGFL(JJ)
2391  CONTINUE
2392  CONTINUE
      IF ((ISUMX .EQ. 0)) THEN
         WRITE(IOUT,307)
      ELSE
         WRITE(IOUT,306)
      END IF
      EK0=EIN
      WRITE(IOUT,300) NMED
      DO 2401 I=1,NMED
         WRITE(IOUT,310) I,(MEDIA(J,I),J=1,6),RHO(I),AE(I),AP(I),UE(I),U
     *   P(I)
2401  CONTINUE
2402  CONTINUE
      CALL GEOMRZ_ISUMRY(IOUT)
      CALL SRCOUT
      CDSTBL(1)='0'
      CTRTBL(1)='0'
      CABSRB(1)='0'
      CALL MATERIALGRID(NR, NZ, AMASS, 1, ECUT, PCUT, RCYL, ZPLANE, MED,
     * MEDIA, CDSTBL, CTRTBL, CABSRB)
      WRITE (IOUT, *) '\f'
      RETURN
100   FORMAT('1',80A1//' SPRRZnrc(EGSnrc) ',' ',' ', /'     on ','linux'
     *,' ',T54,' ',$)
200   FORMAT(/' ',79('*')/ /' ',T20,'MONTE CARLO, TRANSPORT, AND SCATTER
     * CONTROLS'/ /' ',79('*')/ /' ',T20,'Max # of histories to run',T57
     *,I8/ ' ',T20,'Max # of histories to analyze',T57,I8/ ' ',T20,'inci
     *dent charge',T63,I2)
201   FORMAT(' ',T20,'incident kinetic energy',T57,F9.3,' (MeV)')
220   FORMAT(/' ',T20,'Maximum global electron step size', T60,1PE10.3,'
     * (cm)'/ ' ',T20,'Global electron transport cut-off = AE for each m
     *aterial'/ ' ',T20,'Global photon transport cut-off', T56,0PF9.3,'(
     *MeV)')
230   FORMAT(' ',T20,'Min/max photon step forced',T60,I6,'/',I6)
231   FORMAT(' ',T20,'Photon force interaction switch',T60,'OFF')
242   FORMAT(' ',T20,'Range rejection ON with ESAVE =',T60,F7.3/ ' ',T20
     *,' in regions where stopping power ratios are not'/ ' ',T20,' bein
     *g output')
243   FORMAT(' ',T20,'Range rejection OFF')
244   FORMAT(' ',T20,'Rayleigh scattering included')
257   FORMAT(' ',T20,'spr plotted in cylinders:')
258   FORMAT(' ',T20,I12)
259   FORMAT(' ',T20,'spr plotted in slabs:')
260   FORMAT(' ',T20,'Maximum cputime allowed',T59,F5.2,' (hrs)'/ ' ',T2
     *0,'Stats in peak region objective',T59,F6.2,' %')
261   FORMAT(' ',T20,'Normal transport without photon regeneration')
262   FORMAT(' ',T20,'Photon transport has photon regeneration ON and no
     * ', 'scattered photons')
265   FORMAT(' ',T20,'RUS ROU FOR PHOTONS CROSSING Z = ',T60,F10.3,' cm'
     */ T25,'WITH PROBABILITY OF SURVIVAL:',T60,F7.4)
266   FORMAT(' ',T20,'PATHLENGTH EXPONENTIAL TRANSFORMATION'/ T25,'VARIA
     *BLE FOR FORWARD GOING PHOTNS: ',T60,F10.3)
270   FORMAT(' ',T20,'# ZONES MULT SCATTERING SWITCHED OFF',T60,'NONE')
271   FORMAT(' ',T20,'# ZONES MULT SCATTERING SWITCHED OFF',T60,'ALL')
272   FORMAT(' ',T20,'# ZONES MULT SCATTERING SWITCHED OFF',T60,I2)
273   FORMAT(' ',T20,'# ZONES MOLL SCATTERING SWITCHED OFF',T60,'NONE')
274   FORMAT(' ',T20,'# ZONES MOLL SCATTERING SWITCHED OFF',T60,'ALL')
275   FORMAT(' ',T20,'# ZONES MOLL SCATTERING SWITCHED OFF',T60,I2)
276   FORMAT(' ',T20,'# ZONES BREM SCATTERING SWITCHED OFF',T60,'NONE')
277   FORMAT(' ',T20,'# ZONES BREM SCATTERING SWITCHED OFF',T60,'ALL')
278   FORMAT(' ',T20,'# ZONES BREM SCATTERING SWITCHED OFF',T60,I2)
279   FORMAT(' ',T20,'# ZONES BHAB SCATTERING SWITCHED OFF',T60,'NONE')
280   FORMAT(' ',T20,'# ZONES BHAB SCATTERING SWITCHED OFF',T60,'ALL')
281   FORMAT(' ',T20,'# ZONES BHAB SCATTERING SWITCHED OFF',T60,I2)
300   FORMAT(' ',79('*')/ /' ',T20,'MATERIAL SUMMARY   ',I1,' MATERIALSU
     *SED'/ /' ',79('*')/ /' # MATERIAL  DENSITY(g/cm**3)',6X,'AE(MeV)',
     *4X,'AP(MeV)', 9X,'UE(MeV)',4X,'UP(MeV)'/ ' - --------  -----------
     *-----',6X,'-------',4X,'-------', 9X,'-------',4X,'-------')
306   FORMAT(T20,'Atomic relaxations are modelled ')
307   FORMAT(T20,' Atomic relaxations are ignored')
310   FORMAT(' ',I1,3X,6A1,4X,1PE10.3,2(7X,0PF9.3,2X,F9.3))
311   FORMAT(' ',T20,'spr scored in regions:')
312   FORMAT(' ',T20,I12)
313   FORMAT(' ',T20,I10,' TO ',I4)
315   FORMAT(' ',T20,'spr scored in all regions')
316   FORMAT(' ',T20,'spr scored and plotted in cylinders:')
317   FORMAT(' ',T20,'spr scored and plotted in slabs:')
      END
      SUBROUTINE OSUMRY
      implicit none
      INTEGER NCOMP
      real*8 RESULTS(100, 10, 4), UNCRTY(100, 10, 4), RADIAL_BINS(10),DE
     *PTH_BINS( 101)
      CHARACTER*60 EXPLANATIONS(4)
      CHARACTER*4 LABELS(4)
      integer*8 IMS
      integer*4 IX,IZ,IXD,IZD,IT,I,IRL
      real*8 HISTXMIN,DMAX
      real*8 XCOORD(300), YCOORD(300), UNCERT(300)
      INTEGER NPTS, TYPE, AXISTYPE, UNITNUM, CURVENUM, int, CHECK
      INTEGER IPLTUNX, SPRRZ_COUNT, BIN_CUT, ICOUNT
      CHARACTER*60 SERIESTITLE, XTITLE, YTITLE, SUBTITLE
      CHARACTER*80 GRAPHTITLE
      CHARACTER*4 CH_IZ, CH_IX
      CHARACTER*1 a(3)
      integer*4 egs_open_file
      CHARACTER*4 BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,
     *SCHAR, TCHAR,UCHAR,VCHAR
      COMMON/CHARS/ BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHA
     *R,SCHAR,TCHAR,UCHAR,VCHAR
      COMMON/GEOM/ ZPLANE( 101),RCYL(0:10),CYRAD2( 11), NZ,NR,NREG,NPLAN
     *E
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NPLANE
      character*1 title(80)
      COMMON/IODAT1/TITLE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(100,10),TMCPUO,TIMMAX,ST
     *ATLM,EIN, IDAT,IRESTART,IQIN,IVAL,ISPRREG,ISPR( 1001)
      integer*8 NCASE,NCASEO,NCASET
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN
      integer*4 IDAT,IRESTART,IQIN,IVAL,ISPR, ISPRREG,DATCOUNT
      COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE
      integer*4 ICHPIN,ILPIN,IOUT,IPAGE
      COMMON/SCORE/ SCSTP,SCSTP2,SCEDPN,SCEDPN2,SCDOSE,SCDOSE2,SCDOSE_CO
     *V, SCSPR_COV, DELTA, DELTLG,DELTAT,PIISTP, SCSTP_LAST,SCDOSE_LAST,
     *SCNUM,IHSTRY, SCSTP_TMP,SCEDPN_TMP,SCDOSE_TMP3, ifano,MXNP,ISTORE,
     *IWATCH,IOUTSP, ICROSS,ITRACKE,BSTAT,BDSTAT
      REAL*8 SCSTP,SCSTP2,SCEDPN( 101,10,4), SCEDPN2( 101,10,4), SCDOSE(
     * 101,10,3), SCDOSE2( 101,10,3), SCDOSE_COV( 101,10,3-1), SCSPR_COV
     *( 101,10,2), DELTA, DELTAT,DELTLG,PIISTP
      integer*8 SCSTP_LAST,SCDOSE_LAST( 101,10), SCNUM( 101,10)
      real*8 SCSTP_TMP,SCEDPN_TMP( 101,10,4), SCDOSE_TMP3( 101,10)
      integer*4 IFANO,MXNP,ISTORE,IWATCH,IOUTSP,ICROSS,ITRACKE, BSTAT( 1
     *01,2),BDSTAT( 101)
      integer*8 ihstry
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(1000,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RB
     *EAM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2
     *,DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,
     *PROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST
     *,ZSOFST,                                                      SVTM
     *P1,SVTMP2,SVTMP3,SVTMP4,
     *          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                        XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,
     *WEIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/USERVR/ CEXPTR,GWAIT,PATHL,DUMU,DUMX,DUMY,DUMZ, DELTAP,GWTO
     *LD,EPSLON,ARG,EXPMFP,ESAVEIN, IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM, IFO
     *RCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN, MEDTMP,IREJCT
      real*8 CEXPTR,GWAIT,DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,GWTOLD,EPSLON
     *,ARG, EXPMFP,ESAVEIN
      integer*4 NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN,IFORCE,IRODU
     *M, IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,IREJCT
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      BIN_CUT = 1.e-30
      IPLTUNX = 23
      SPRRZ_COUNT = 0
      write(iout,100) title
      call egs_fdate(iout)
      write(iout,*)
      IF ((ISOURC.EQ.21.OR.ISOURC.EQ.22)) THEN
         WRITE(IOUT,200) SCSTP,SCSTP2, SCSTP/(dble(NNREAD+NRCYCL*(NNREAD
     *   -IHSTRY))/dble(NCASE_PHSP)*NINCSRC), SCSTP2,(count_pII_steps+PI
     *   ISTP)/SCSTP,SCSTP2
      ELSE
         WRITE(IOUT,200) SCSTP,SCSTP2,SCSTP/dble(IHSTRY), SCSTP2,(count_
     *   pII_steps+PIISTP)/SCSTP,SCSTP2
      END IF
      DO 2411 I=1,80
         GRAPHTITLE(I:I)=TITLE(I)
2411  CONTINUE
2412  CONTINUE
      IF ((ISPRREG.EQ.1)) THEN
         SPRRZ_COUNT=0
         ICOUNT=0
         DMAX=0.0
         DO 2421 IZ=1,NZ
            IF((SCDOSE(IZ,1,3).GT.Dmax))Dmax = SCDOSE(IZ,1,3)
2421     CONTINUE
2422     CONTINUE
         IF ((Dmax .EQ. 0.0)) THEN
            Dmax = 1.
         END IF
         DO 2431 IX=1,NR
            IF ((ISPR(IX).EQ.1)) THEN
               IF((ICOUNT.EQ.0))IPLTUNX=egs_open_file(23,0,1,'_dd.plotda
     *t')
               UNITNUM=IPLTUNX
               NPTS=NZ
               XTITLE='depth/cm'
               YTITLE='stopping power ratio'
               SUBTITLE='stopping power ratio vs depth'
               HISTXMIN=BIN_CUT
               AXISTYPE=0
               DO 2441 IZ=1,NZ
                  XCOORD(IZ) = ZPLANE(IZ+1)
                  YCOORD(IZ) = SCEDPN(IZ,IX,1)
                  UNCERT(IZ) = SCEDPN(IZ,IX,1)*SCEDPN2(IZ,IX,1)/100.
2441           CONTINUE
2442           CONTINUE
               IF (((IX .EQ. MOD(IX,1000)))) THEN
                  CHECK=1
                  IF ((IX .EQ. MOD(IX,10))) THEN
                     CH_IX=CHAR(IX+48)
                     CHECK=0
                  END IF
                  IF (((CHECK.NE.0).AND.(IX .EQ. MOD(IX,100)))) THEN
                     a(1)=CHAR((IX/10)+48)
                     int=(MOD(IX,10)+48)
                     a(2)=CHAR(int)
                     CH_IX=a(1)//a(2)
                     CHECK=0
                  END IF
                  IF ((CHECK.NE.0)) THEN
                     a(1)=CHAR((IX/100)+48)
                     int=(MOD(IX,100)/10+48)
                     a(2)=CHAR(int)
                     int=MOD(IX,10)+48
                     a(3)=CHAR(int)
                     CH_IX=a(1)//a(2)//a(3)
                  END IF
               ELSE
                  CH_IX='3max'
               END IF
               CURVENUM=SPRRZ_COUNT
               SERIESTITLE='cylinder='//CH_IX
               TYPE=1
               HISTXMIN=ZPLANE(1)
               CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM, SE
     *         RIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UNITNUM,
     *          TYPE, HISTXMIN, AXISTYPE)
               SPRRZ_COUNT=SPRRZ_COUNT+1
               ICOUNT=ICOUNT+1
               IF ((ISOURC.EQ.3.OR.ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOUR
     *         C.EQ.23)) THEN
                  YTITLE='dose per incident particle/Gy'
               ELSE
                  YTITLE='dose per incident fluence/Gy cm\\S2\\N'
               END IF
               HISTXMIN=BIN_CUT
               AXISTYPE=0
               DO 2451 IZ=1,NZ
                  XCOORD(IZ) = ZPLANE(IZ+1)
                  YCOORD(IZ) = SCDOSE(IZ,IX,3)/Dmax
                  UNCERT(IZ) = SCDOSE(IZ,IX,3)*SCDOSE2(IZ,IX,3)/(Dmax*10
     *            0.)
2451           CONTINUE
2452           CONTINUE
               IF (((IX .EQ. MOD(IX,1000)))) THEN
                  CHECK=1
                  IF ((IX .EQ. MOD(IX,10))) THEN
                     CH_IX=CHAR(IX+48)
                     CHECK=0
                  END IF
                  IF (((CHECK.NE.0).AND.(IX .EQ. MOD(IX,100)))) THEN
                     a(1)=CHAR((IX/10)+48)
                     int=(MOD(IX,10)+48)
                     a(2)=CHAR(int)
                     CH_IX=a(1)//a(2)
                     CHECK=0
                  END IF
                  IF ((CHECK.NE.0)) THEN
                     a(1)=CHAR((IX/100)+48)
                     int=(MOD(IX,100)/10+48)
                     a(2)=CHAR(int)
                     int=MOD(IX,10)+48
                     a(3)=CHAR(int)
                     CH_IX=a(1)//a(2)//a(3)
                  END IF
               ELSE
                  CH_IX='3max'
               END IF
               CURVENUM=SPRRZ_COUNT
               SERIESTITLE='cylinder='//CH_IX
               TYPE=1
               HISTXMIN=ZPLANE(1)
               write(*,*)' dose now '
               CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM, SE
     *         RIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UNITNUM,
     *          TYPE, HISTXMIN, AXISTYPE)
               SPRRZ_COUNT=SPRRZ_COUNT+1
               ICOUNT=ICOUNT+1
            END IF
2431     CONTINUE
2432     CONTINUE
         IF((ICOUNT .GT. 0))close(IPLTUNX)
         SPRRZ_COUNT=0
         ICOUNT=0
         DO 2461 IZ=1,NZ
            IF ((ISPR(NR+IZ).EQ.1)) THEN
               IF((ICOUNT.EQ.0))IPLTUNX=egs_open_file(23,0,1,'_rad.plotd
     *at')
               UNITNUM=IPLTUNX
               NPTS=NR
               XTITLE='radius/cm'
               YTITLE='stopping power ratio'
               SUBTITLE='stopping power ratio vs radius'
               HISTXMIN=BIN_CUT
               AXISTYPE=0
               DO 2471 IX=1,NR
                  XCOORD(IX) = RCYL(IX)
                  YCOORD(IX) = SCEDPN(IZ,IX,1)
                  UNCERT(IX) = SCEDPN(IZ,IX,1)*SCEDPN2(IZ,IX,1)/100.
2471           CONTINUE
2472           CONTINUE
               IF (((IZ .EQ. MOD(IZ,1000)))) THEN
                  CHECK=1
                  IF ((IZ .EQ. MOD(IZ,10))) THEN
                     CH_IZ=CHAR(IZ+48)
                     CHECK=0
                  END IF
                  IF (((CHECK.NE.0).AND.(IZ .EQ. MOD(IZ,100)))) THEN
                     a(1)=CHAR((IZ/10)+48)
                     int=(MOD(IZ,10)+48)
                     a(2)=CHAR(int)
                     CH_IZ=a(1)//a(2)
                     CHECK=0
                  END IF
                  IF ((CHECK.NE.0)) THEN
                     a(1)=CHAR((IZ/100)+48)
                     int=(MOD(IZ,100)/10+48)
                     a(2)=CHAR(int)
                     int=MOD(IZ,10)+48
                     a(3)=CHAR(int)
                     CH_IZ=a(1)//a(2)//a(3)
                  END IF
               ELSE
                  CH_IZ='3max'
               END IF
               CURVENUM=SPRRZ_COUNT
               SERIESTITLE='slab='//CH_IZ
               TYPE=1
               HISTXMIN=0
               CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM, SE
     *         RIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UNITNUM,
     *          TYPE, HISTXMIN, AXISTYPE)
               SPRRZ_COUNT=SPRRZ_COUNT+1
               ICOUNT=ICOUNT+1
               IF ((ISOURC.EQ.3.OR.ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOUR
     *         C.EQ.23)) THEN
                  YTITLE='dose per incident particle/Gy'
               ELSE
                  YTITLE='dose per incident fluence/Gy cm\\S2\\N'
               END IF
               HISTXMIN=BIN_CUT
               AXISTYPE=0
               DO 2481 IX=1,NR
                  XCOORD(IX) = RCYL(IX)
                  YCOORD(IZ) = SCDOSE(IZ,IX,3)/Dmax
                  UNCERT(IZ) = SCDOSE(IZ,IX,3)*SCDOSE2(IZ,IX,3)/(Dmax*10
     *            0.)
2481           CONTINUE
2482           CONTINUE
               IF (((IZ .EQ. MOD(IZ,1000)))) THEN
                  CHECK=1
                  IF ((IZ .EQ. MOD(IZ,10))) THEN
                     CH_IZ=CHAR(IZ+48)
                     CHECK=0
                  END IF
                  IF (((CHECK.NE.0).AND.(IZ .EQ. MOD(IZ,100)))) THEN
                     a(1)=CHAR((IZ/10)+48)
                     int=(MOD(IZ,10)+48)
                     a(2)=CHAR(int)
                     CH_IZ=a(1)//a(2)
                     CHECK=0
                  END IF
                  IF ((CHECK.NE.0)) THEN
                     a(1)=CHAR((IZ/100)+48)
                     int=(MOD(IZ,100)/10+48)
                     a(2)=CHAR(int)
                     int=MOD(IZ,10)+48
                     a(3)=CHAR(int)
                     CH_IZ=a(1)//a(2)//a(3)
                  END IF
               ELSE
                  CH_IZ='3max'
               END IF
               CURVENUM=SPRRZ_COUNT
               SERIESTITLE='slab='//CH_IZ
               TYPE=1
               HISTXMIN=0
               CALL XVGRPLOT (XCOORD, YCOORD, UNCERT, NPTS, CURVENUM, SE
     *         RIESTITLE, XTITLE, YTITLE, GRAPHTITLE, SUBTITLE, UNITNUM,
     *          TYPE, HISTXMIN, AXISTYPE)
               SPRRZ_COUNT=SPRRZ_COUNT+1
               ICOUNT=ICOUNT+1
            END IF
2461     CONTINUE
2462     CONTINUE
         IF((ICOUNT .GT. 0))close(IPLTUNX)
      END IF
      NCOMP=2
      DO 2491 IXD=1,NR
         DO 2501 IZD=1,NZ
            IRL=IZD+NZ*(IXD-1)+1
            IF ((i_do_rr(IRL).EQ.1)) THEN
               SCEDPN(IZD,IXD,1)=0.
               SCEDPN2(IZD,IXD,1)=99.9
               SCEDPN(IZD,IXD,3)=0.
               SCEDPN2(IZD,IXD,3)=99.9
            END IF
            RESULTS(IZD,IXD,1)=SCEDPN(IZD,IXD,1)
            UNCRTY(IZD,IXD,1)=SCEDPN2(IZD,IXD,1)
            RESULTS(IZD,IXD,2)=SCEDPN(IZD,IXD,3)
            UNCRTY(IZD,IXD,2)=SCEDPN2(IZD,IXD,3)
2501     CONTINUE
2502     CONTINUE
2491  CONTINUE
2492  CONTINUE
      DO 2511 IX=1,NR+1
         RADIAL_BINS(IX)=RCYL(IX-1)
2511  CONTINUE
2512  CONTINUE
      DO 2521 IZ=1,NZ+1
         DEPTH_BINS(IZ)=ZPLANE(IZ)
2521  CONTINUE
2522  CONTINUE
      EXPLANATIONS(1)='spr local medium/medium 2 (with TE)'
      LABELS(1)='spr:'
      EXPLANATIONS(2)='spr sans TRACK ENDS'
      LABELS(2)='ste:'
      IF ((IREJCT.EQ.1)) THEN
         WRITE(IOUT,'(//'' ***Range rejection is ON:''/
     *                              '' stopping power ratios in those re
     *gions where the user''/                     '' did not request out
     *put are zeroed below''/)')
      END IF
      CALL ZONEGRID(NR, NZ, 0, 1, NZ, RESULTS, UNCRTY, NCOMP, RADIAL_BIN
     *S, DEPTH_BINS, LABELS, EXPLANATIONS)
      WRITE (IOUT, *) '\f'
      write(iout,100) title
      call egs_fdate(iout)
      write(iout,*)
      WRITE(IOUT,320)
      WRITE(IOUT,305)
      DO 2531 IX=1,NR
         DO 2541 IZ=1,NZ
            WRITE(IOUT,310) IZ,IX,ZPLANE(IZ),ZPLANE(IZ+1), SCEDPN(IZ,IX,
     *      1),(SCEDPN(IZ,IX,1)*SCEDPN2(IZ,IX,1)/100.), SCDOSE(IZ,IX,3),
     *       SCDOSE2(IZ,IX,3)
            IF ((BSTAT(IZ,1) .EQ. -1)) THEN
               WRITE(IOUT,315)
            END IF
2541     CONTINUE
2542     CONTINUE
2531  CONTINUE
2532  CONTINUE
      IF (( (NR*NZ) .GT. 23)) THEN
         write(iout,100) title
         call egs_fdate(iout)
         write(iout,*)
      ELSE
         WRITE(IOUT,'(/)')
      END IF
      WRITE(IOUT,325)
      WRITE(IOUT,305)
      DO 2551 IX=1,NR
         DO 2561 IZ=1,NZ
            WRITE(IOUT,310) IZ,IX,ZPLANE(IZ),ZPLANE(IZ+1), SCEDPN(IZ,IX,
     *      3),(SCEDPN(IZ,IX,3)*SCEDPN2(IZ,IX,3)/100.)
            IF ((BSTAT(IZ,2) .EQ. -1)) THEN
               WRITE(IOUT,315)
            END IF
2561     CONTINUE
2562     CONTINUE
2551  CONTINUE
2552  CONTINUE
      write(iout,100) title
      call egs_fdate(iout)
      write(iout,*)
      WRITE(IOUT,350)
      DO 2571 IX=1,NR
         DO 2581 IZ=1,NZ
            WRITE(IOUT,360) IZ,IX,ZPLANE(IZ),ZPLANE(IZ+1), (100.* SCDOSE
     *      (IZ,IX,I),SCDOSE2(IZ,IX,I)*SCDOSE(IZ,IX,I),I=1,2)
            IF ((BSTAT(IZ,1) .EQ. -1 .OR. BDSTAT(IZ).EQ. -1)) THEN
               WRITE(IOUT,315)
            END IF
2581     CONTINUE
2582     CONTINUE
2571  CONTINUE
2572  CONTINUE
      IF ((ILPIN.NE.6)) THEN
         write(iout,'(a)') '\f'
      END IF
      RETURN
100   FORMAT('1',80A1//' SPRRZnrc(EGSnrc) ',' ',' ', /'     on ','linux'
     *,' ',T54,' ',$)
200   FORMAT(/' ',T26,'Total # charged particle steps',T58, 1PE10.3,' +/
     *-',0PF6.3,'%'/ ' ',T13,'# of charged particle steps/initial histor
     *y',T58, 1PE10.3,' +/-',0PF6.3,'%'/ ' ','# of presta-II steps/total
     * # of charged particle steps', T61,F7.3,' +/-',0PF6.3,'%')
305   FORMAT(/' Region',T19,'depth (cm)',T35, ' spr (medium / med2)',T58
     *,'dose/inc flu. Gy.cm**2'/)
310   FORMAT(' NZ,NR=',I3,',',I3,F8.3,' -',F8.3,T33, F10.5,' (+/-',F8.5,
     *')', T60,1PE10.3,'(+/-',0PF4.1,'%)')
315   FORMAT(14X,' **** WARNING **** BAD STATISTICS!')
320   FORMAT(/' ',14X,'***** spr with track ends *****')
325   FORMAT(/' ',14X,'***** spr without track ends *****')
350   FORMAT(/' ',T10,'**** percentage of dose in local medium from stop
     *pers', '  ****' // ' Included fraction of stoppers includes thoses
     *toppers that come from'/ '                   electrons/positronssl
     *owing down across delta.'/ ' Excluded fraction of stoppers are tho
     *se electrons created below delta'/ '                   and photons
     * created below AP'/ /'   Region',9X,'depth (cm)',11X, ' included  
     *       excluded'/)
360   FORMAT(' NZ,NR=',I3,',',I3,F8.2,' -',F8.2,2X,2(F7.3,' (+/- ',F6.3,
     *' )'))
      END
      subroutine combine_results(file_name)
      implicit none
      character*(*) file_name
      COMMON/SCORE/ SCSTP,SCSTP2,SCEDPN,SCEDPN2,SCDOSE,SCDOSE2,SCDOSE_CO
     *V, SCSPR_COV, DELTA, DELTLG,DELTAT,PIISTP, SCSTP_LAST,SCDOSE_LAST,
     *SCNUM,IHSTRY, SCSTP_TMP,SCEDPN_TMP,SCDOSE_TMP3, ifano,MXNP,ISTORE,
     *IWATCH,IOUTSP, ICROSS,ITRACKE,BSTAT,BDSTAT
      REAL*8 SCSTP,SCSTP2,SCEDPN( 101,10,4), SCEDPN2( 101,10,4), SCDOSE(
     * 101,10,3), SCDOSE2( 101,10,3), SCDOSE_COV( 101,10,3-1), SCSPR_COV
     *( 101,10,2), DELTA, DELTAT,DELTLG,PIISTP
      integer*8 SCSTP_LAST,SCDOSE_LAST( 101,10), SCNUM( 101,10)
      real*8 SCSTP_TMP,SCEDPN_TMP( 101,10,4), SCDOSE_TMP3( 101,10)
      integer*4 IFANO,MXNP,ISTORE,IWATCH,IOUTSP,ICROSS,ITRACKE, BSTAT( 1
     *01,2),BDSTAT( 101)
      integer*8 ihstry
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(100,10),TMCPUO,TIMMAX,ST
     *ATLM,EIN, IDAT,IRESTART,IQIN,IVAL,ISPRREG,ISPR( 1001)
      integer*8 NCASE,NCASEO,NCASET
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN
      integer*4 IDAT,IRESTART,IQIN,IVAL,ISPR, ISPRREG,DATCOUNT
      COMMON/GEOM/ ZPLANE( 101),RCYL(0:10),CYRAD2( 11), NZ,NR,NREG,NPLAN
     *E
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NPLANE
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(1000,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RB
     *EAM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2
     *,DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,
     *PROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST
     *,ZSOFST,                                                      SVTM
     *P1,SVTMP2,SVTMP3,SVTMP4,
     *          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                        XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,
     *WEIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      real*8 TSCEDPN(100,10,4),TSCEDPN2(100,10,4), TSCDOSE(100,10,3),TSC
     *DOSE2(100,10,3), TSCDOSE_COV(100,10,2),TSCSPR_COV(100,10,2), TMPPI
     *ISTP,TSCSTP,TSCSTP2
      real*8 TMPTMCPU
      integer*8 TMPNCASE,TMPNNREAD
      integer*4 TMPICROSS,TMPITRACKE,iorstrt
      integer*4 my_unit,egs_get_unit,iout,iz,ix,it,lnblnk1,irl
      logical first_time
      data first_time/.true./, iout/1/
      save first_time,iout
      IF (( first_time )) THEN
         WRITE(6,2590)
2590     FORMAT(/1X,'Summing the following .egsdat files')
         WRITE(6,2600)
2600     FORMAT(1X,'------------------------------------'/)
         WRITE(IOUT,'(/1X,''Summing the following .egsdat files'')')
         WRITE(IOUT,'(1X,''------------------------------------''/)')
         datcount=0
         TMCPUO=0
         NCASEO=0
         PIISTP=0
         NNREAD=0
         ICROSS=0
         ITRACKE=0
         DO 2611 iz=1,nz
            DO 2621 ix=1,nr
               DO 2631 it=1,4
                  SCEDPN(IZ,IX,IT)=0
                  SCEDPN2(IZ,IX,IT)=0
2631           CONTINUE
2632           CONTINUE
               DO 2641 it=1,3
                  SCDOSE(IZ,IX,IT)=0
                  SCDOSE2(IZ,IX,IT)=0
2641           CONTINUE
2642           CONTINUE
               DO 2651 it=1,2
                  SCDOSE_COV(IZ,IX,IT)=0
                  SCSPR_COV(IZ,IX,IT)=0
2651           CONTINUE
2652           CONTINUE
2621        CONTINUE
2622        CONTINUE
2611     CONTINUE
2612     CONTINUE
         first_time = .false.
      END IF
      IORSTRT=egs_get_unit(4)
      WRITE(IOUT,'(A)') file_name(:lnblnk1(file_name))
      WRITE(6,'(A)') file_name(:lnblnk1(file_name))
      open(IORSTRT,file=file_name,status='old',err=2660)
      READ(IORSTRT,*,END=2670) TSCSTP,TSCSTP2
      DO 2681 IZ=1,NZ
         DO 2691 IX=1,NR
            DO 2701 IT=1,4
               READ(iorstrt,*,END=2670)TSCEDPN(IZ,IX,IT),TSCEDPN2(IZ,IX,
     *         IT)
2701        CONTINUE
2702        CONTINUE
            DO 2711 IT=1,3
               READ(iorstrt,*,END=2670)TSCDOSE(IZ,IX,IT),TSCDOSE2(IZ,IX,
     *         IT)
2711        CONTINUE
2712        CONTINUE
            READ(iorstrt,*,END=2670)TSCDOSE_COV(IZ,IX,1),TSCDOSE_COV(IZ,
     *      IX,2)
            READ(iorstrt,*,END=2670)TSCSPR_COV(IZ,IX,1),TSCSPR_COV(IZ,IX
     *      ,2)
2691     CONTINUE
2692     CONTINUE
2681  CONTINUE
2682  CONTINUE
      read(iorstrt,*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed, rn
     *g_array
      twom24 = 1./16777216.
      READ(iorstrt,*,END=2670) TMPNCASE,TMPTMCPU,TMPNNREAD,TMPPIISTP
      READ(iorstrt,*,END=2670)TMPICROSS,TMPITRACKE
      DATCOUNT=DATCOUNT+1
      SCSTP=SCSTP+TSCSTP
      SCSTP2=SCSTP2+TSCSTP2
      DO 2721 IZ=1,NZ
         DO 2731 IX=1,NR
            DO 2741 IT=1,4
               SCEDPN(IZ,IX,IT)=SCEDPN(IZ,IX,IT)+TSCEDPN(IZ,IX,IT)
               SCEDPN2(IZ,IX,IT)=SCEDPN2(IZ,IX,IT)+TSCEDPN2(IZ,IX,IT)
2741        CONTINUE
2742        CONTINUE
            DO 2751 IT=1,3
               SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+TSCDOSE(IZ,IX,IT)
               SCDOSE2(IZ,IX,IT)=SCDOSE2(IZ,IX,IT)+TSCDOSE2(IZ,IX,IT)
2751        CONTINUE
2752        CONTINUE
            SCDOSE_COV(IZ,IX,1)=SCDOSE_COV(IZ,IX,1)+TSCDOSE_COV(IZ,IX,1)
            SCDOSE_COV(IZ,IX,2)=SCDOSE_COV(IZ,IX,2)+TSCDOSE_COV(IZ,IX,2)
            SCSPR_COV(IZ,IX,1)=SCSPR_COV(IZ,IX,1)+TSCSPR_COV(IZ,IX,1)
            SCSPR_COV(IZ,IX,2)=SCSPR_COV(IZ,IX,2)+TSCSPR_COV(IZ,IX,2)
2731     CONTINUE
2732     CONTINUE
2721  CONTINUE
2722  CONTINUE
      TMCPUO=TMCPUO+TMPTMCPU
      NCASEO=NCASEO+TMPNCASE
      PIISTP=PIISTP+TMPPIISTP
      NNREAD=NNREAD+TMPNNREAD
      ICROSS=ICROSS+TMPICROSS
      ITRACKE=ITRACKE+TMPITRACKE
      write(6,*) '  ncase = ',TMPNCASE,' cpu = ',TMPTMCPU,' total cpu =
     *', TMCPUO
      write(iout,*) '  ncase = ',TMPNCASE,' cpu = ',TMPTMCPU,' total cpu
     * = ', TMCPUO
      CLOSE(UNIT=iorstrt)
      return
2670  CONTINUE
      WRITE(6,*) 'Error reading data from file',file_name(:lnblnk1(file_
     *name))
      CLOSE(UNIT=iorstrt)
      return
2660  CONTINUE
      WRITE(6,*) 'Error opening file', file_name(:lnblnk1(file_name))
      return
      end
      subroutine init_ranmar
      implicit none
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      integer*4 s,t
      integer*4 i,j,k,l,m,ii,jj
      IF((ixx .LE. 0 .OR. ixx .GT. 31328))ixx = 1802
      IF((jxx .LE. 0 .OR. jxx .GT. 30081))jxx = 9373
      i = mod(ixx/177,177) + 2
      j = mod(ixx, 177) + 2
      k = mod(jxx/169,178) + 1
      l = mod(jxx, 169)
      DO 2761 ii=1,97
         s = 0
         t = 8388608
         DO 2771 jj=1,24
            m = mod(mod(i*j,179)*k,179)
            IF (( fool_optimizer .EQ. 999 )) THEN
               write(6,*) i,j,k,m,s,t
            END IF
            i = j
            IF (( fool_optimizer .EQ. 999 )) THEN
               write(6,*) i,j,k,m,s,t
            END IF
            j = k
            IF (( fool_optimizer .EQ. 999 )) THEN
               write(6,*) i,j,k,m,s,t
            END IF
            k = m
            IF (( fool_optimizer .EQ. 999 )) THEN
               write(6,*) i,j,k,m,s,t
            END IF
            l = mod(53*l+1,169)
            IF (( fool_optimizer .EQ. 999 )) THEN
               write(6,*) i,j,k,m,s,t
            END IF
            IF((mod(l*m,64) .GE. 32))s = s + t
            IF (( fool_optimizer .EQ. 999 )) THEN
               write(6,*) i,j,k,m,s,t
            END IF
            t = t/2
            IF (( fool_optimizer .EQ. 999 )) THEN
               write(6,*) i,j,k,m,s,t
            END IF
2771     CONTINUE
2772     CONTINUE
         urndm(ii) = s
2761  CONTINUE
2762  CONTINUE
      crndm = 362436
      cdrndm = 7654321
      cmrndm = 16777213
      twom24 = 1./16777216.
      ixx = 97
      jxx = 33
      rng_seed = 128 + 1
      return
      end
      subroutine ranmar_get
      implicit none
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      integer*4 i,iopt
      IF((rng_seed .EQ. 999999))call init_ranmar
      DO 2781 i=1,128
         iopt = urndm(ixx) - urndm(jxx)
         IF((iopt .LT. 0))iopt = iopt + 16777216
         urndm(ixx) = iopt
         ixx = ixx - 1
         jxx = jxx - 1
         IF ((ixx .EQ. 0)) THEN
            ixx = 97
         ELSE IF(( jxx .EQ. 0 )) THEN
            jxx = 97
         END IF
         crndm = crndm - cdrndm
         IF((crndm .LT. 0))crndm = crndm + cmrndm
         iopt = iopt - crndm
         IF((iopt .LT. 0))iopt = iopt + 16777216
         rng_array(i) = iopt
2781  CONTINUE
2782  CONTINUE
      rng_seed = 1
      return
      end
      SUBROUTINE SRCRZ
      implicit none
      integer*4 LATCHM,NHSTRYM
      real*8 ZLASTM,EINM,WEIGHTM,XINM,YINM,UINM,VINM
      CHARACTER*5 LINE1
      integer*4 K,IB
      real*8 TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,TEMP6,TEMP7,TEMP8,TEMP9,FNORM
      character*80 filnam
      integer*4 ICORRL
      integer*8 TEMPDIV
      real*8 SCARG1,SCARG2,SCARG3,SCARG4
      integer*4 ICOUNT,IERROR
      real*8 RLAST
      real*8 WEIGHT
      integer*4 IBNSOK,I,IRDIST
      real*8 COTANG,FACTOR,GRIDSZ,AK
      integer*4 IRIN,NRCFLG
      real*8 XIN,YIN,ZIN,UIN,VIN,WIN
      integer*4 IX,IXIN,IZ,IZ1,LATCHI
      real*8 R2,D,PHI,WHICH,RNNO1,RNNO2,ZLAST
      integer*4 IZIN
      real*8 YTEMP,VTEMP,ZINC
      real*8 dist_phsp, theta_phsp, cost_phsp, sint_phsp, chamber_c, xof
     *fset, yoffset
      logical check
      integer*4 count_phsp
      real*8 tf,xtmp,ytmp,phbb,pha,phb,phd,radp
      integer*4 N_RUN_CHUNK
      character*80 the_beam_code, the_pegs_file, the_input_file
      integer*4 lnblnk1
      integer*8 tmp_mod
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      INTEGER NUM_IPART, NUM_SOURCE, NUM_SOPTS, NUM_MODEIN, NUM_RDFIL, N
     *UM_NRDIST, NUM_RDISTF, NUM_RPDF, NUM_RDIOUTSP, NUM_FILSPC, NUM_BEA
     *M_CODE, NUM_PEGS_FILE, NUM_IFILE, NUM_WW23, error_flag_save
      integer*4 MODEIN
      COMMON/GEOM/ ZPLANE( 101),RCYL(0:10),CYRAD2( 11), NZ,NR,NREG,NPLAN
     *E
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NPLANE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(100,10),TMCPUO,TIMMAX,ST
     *ATLM,EIN, IDAT,IRESTART,IQIN,IVAL,ISPRREG,ISPR( 1001)
      integer*8 NCASE,NCASEO,NCASET
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN
      integer*4 IDAT,IRESTART,IQIN,IVAL,ISPR, ISPRREG,DATCOUNT
      COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE
      integer*4 ICHPIN,ILPIN,IOUT,IPAGE
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/SCORE/ SCSTP,SCSTP2,SCEDPN,SCEDPN2,SCDOSE,SCDOSE2,SCDOSE_CO
     *V, SCSPR_COV, DELTA, DELTLG,DELTAT,PIISTP, SCSTP_LAST,SCDOSE_LAST,
     *SCNUM,IHSTRY, SCSTP_TMP,SCEDPN_TMP,SCDOSE_TMP3, ifano,MXNP,ISTORE,
     *IWATCH,IOUTSP, ICROSS,ITRACKE,BSTAT,BDSTAT
      REAL*8 SCSTP,SCSTP2,SCEDPN( 101,10,4), SCEDPN2( 101,10,4), SCDOSE(
     * 101,10,3), SCDOSE2( 101,10,3), SCDOSE_COV( 101,10,3-1), SCSPR_COV
     *( 101,10,2), DELTA, DELTAT,DELTLG,PIISTP
      integer*8 SCSTP_LAST,SCDOSE_LAST( 101,10), SCNUM( 101,10)
      real*8 SCSTP_TMP,SCEDPN_TMP( 101,10,4), SCDOSE_TMP3( 101,10)
      integer*4 IFANO,MXNP,ISTORE,IWATCH,IOUTSP,ICROSS,ITRACKE, BSTAT( 1
     *01,2),BDSTAT( 101)
      integer*8 ihstry
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(1000,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RB
     *EAM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2
     *,DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,
     *PROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST
     *,ZSOFST,                                                      SVTM
     *P1,SVTMP2,SVTMP3,SVTMP4,
     *          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                        XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,
     *WEIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USERVR/ CEXPTR,GWAIT,PATHL,DUMU,DUMX,DUMY,DUMZ, DELTAP,GWTO
     *LD,EPSLON,ARG,EXPMFP,ESAVEIN, IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM, IFO
     *RCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN, MEDTMP,IREJCT
      real*8 CEXPTR,GWAIT,DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,GWTOLD,EPSLON
     *,ARG, EXPMFP,ESAVEIN
      integer*4 NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN,IFORCE,IRODU
     *M, IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,IREJCT
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/RWPHSP/ STRING_TEMP_ZLAST_OUT,  STRING_TEMP_OUT,  IHSTRY_PH
     *SP,   iaea_dummy_long,  NHSTRY_DOS,   ESHORT,  WEIGHTTMP,  WT_PHSP
     *_SHORT,  X_PHSP_SHORT,  Y_PHSP_SHORT,  Z_PHSP_SHORT,  U_PHSP_SHORT
     *,  V_PHSP_SHORT,  W_PHSP_SHORT,  ZLAST_PHSP_SHORT,  MUIDX_PHSP_SHO
     *RT,  EKMAX_PHSP_SHORT,  EKMINE_PHSP_SHORT,  NINC_PHSP_SHORT,  dosx
     *yz2beam_index,  iaea_extra_floats,  NUM_PHSP_TOT,  PHOT_PHSP_TOT,
     *iaea_result,   iaea_n_stat,  iaea_q_typ,  iaea_typ_q,  iaea_q_inde
     *x,  I_PHSP,  IERR_PHSP,  LATCHTMP,  WRITE_PHSP_COUNTER,  WRITE_PHS
     *P_SOFAR,  PHSP_RESTART,  PHSP_RECL,  PHSP_RECL_OLD,  iaea_extra_in
     *ts,  iaea_extra_int_types,iaea_extra_float_types,   iaea_i_zlast,
     * iaea_i_latch,  iaea_i_muidx,  iaea_n_extra_ints,  iaea_n_extra_fl
     *oats,  i_iaea_open_for_write,   iaea_i_zlast_out,  iaea_i_latch_ou
     *t,  iaea_i_muidx_out,  dosxyz2beam_izscore,  MODE_RW
      CHARACTER*32000 STRING_TEMP_ZLAST_OUT(1)
      CHARACTER*28000 STRING_TEMP_OUT(1)
      integer*8 IHSTRY_PHSP(1),iaea_dummy_long,NHSTRY_DOS
      REAL*4 ESHORT,WEIGHTTMP,WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT, Z
     *_PHSP_SHORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,ZLAST_PHSP_SHO
     *RT, MUIDX_PHSP_SHORT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP
     *_SHORT,dosxyz2beam_index, iaea_extra_floats(10)
      INTEGER NUM_PHSP_TOT,PHOT_PHSP_TOT, iaea_result,iaea_n_stat,iaea_q
     *_typ(3),iaea_typ_q(3),iaea_q_index,I_PHSP, IERR_PHSP,LATCHTMP, WRI
     *TE_PHSP_COUNTER(1),WRITE_PHSP_SOFAR(1), PHSP_RESTART,PHSP_RECL,PHS
     *P_RECL_OLD,iaea_extra_ints(10), iaea_extra_int_types(10),iaea_extr
     *a_float_types(10),iaea_i_zlast, iaea_i_latch,iaea_i_muidx,iaea_n_e
     *xtra_ints,iaea_n_extra_floats, i_iaea_open_for_write,iaea_i_zlast_
     *out,iaea_i_latch_out, iaea_i_muidx_out,dosxyz2beam_izscore
      CHARACTER*5 MODE_RW
      INTEGER LATCH_TEMP_OUT,NUM_PHSP_TOFLUSH,TEMP_PHSP_COUNTER,REM_PHSP
      REAL*4 REAL_TEMP_OUT(7)
      CHARACTER*32 REC_TEMP_OUT
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*8 last_nhstry
      real*8 min_weight_23, max_weight_23, xin_tmp, yin_tmp, zin_tmp,Z_S
     *OURCE,MUIDX
      integer*4 secret_option_23,ilen,ismode,IMUPHSP,IZSCORE
      save TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,TEMP6,TEMP7,TEMP8,TEMP9,FNORM,I
     *BNSOK,MODEIN, dist_phsp, theta_phsp, cost_phsp, sint_phsp, chamber
     *_c,count_phsp, xoffset, yoffset, the_beam_code, the_pegs_file, the
     *_input_file, last_nhstry,min_weight_23, max_weight_23, secret_opti
     *on_23
      ENFLAG = 0
      WRITE(6,2790)
2790  FORMAT(/' *** Source inputs read by srcrz ***'/)
      WRITE(6,2800)
2800  FORMAT(' charge of the incident beam (-1,0,1 [& 2 with source 21])
     *,'/ ' source configuration'/ '      (0) parallel beam incident fro
     *m the front:(0),radius(cm)'/ '                      incident direc
     *tion cosines (U,V,W)'/ '   or (1) point source on axis incident fr
     *om the front(1)'/ '                      source to front face dist
     *ance,radius(cm)'/ '   or (2) broad parallel beam incident from the
     * front(2)'/ '                      no configuration input necessar
     *y,unit area beam'/ '   or (3) uniform isotropically radiating disk
     *(3)'/ '                      min,max radius, min,max Z'/ '   or (4
     *) axial fluence for various beam radii'/ '                      ra
     *dius of central axis region')
      WRITE(6,2810)
2810  FORMAT('   or (10) parallel beam incident from the side(10)'/ '   
     *                half-width,half-height of beam at center(cm)'/'   
     *or (11) point source incident from the side(11)'/ '           sour
     *ce to center distance(cm)'/ 'half-width,half-height of beam at cen
     *ter(cm)'/ '   or (12) point source incident from off axis(12)'/ ' 
     *                      perpendicular distance off central axis(cm)'
     */ '                       perpendicular distance from front face(c
     *m)'/ '   or (13) broad parallel beam incident from any angle:(13)'
     */ '                      incident direction cosines (U,V,W)'/ '   
     *or (14) point source on axisfrom front but restricted:(14),'/ '   
     *                   source to front face dist, outer,inner radius(c
     *m)'/ '   or (20) parallel beam incident from the front with radial
     * distribution'/ '   or (21)full phase-space on front: each particl
     *e read from unit 42'/ '                  file MODE (0. = default, 
     *2. with ZLAST as well),'/ '                      NRCYCL, IPARALLEL
     *, PARNUM'/ '   or (22)full phase-space from any angle: each partic
     *le read from unit 42'/'                      file MODE (0. = defau
     *lt, 2. with ZLAST aswell),'/ '                      distance from 
     *centre of source plane to point of'/ '                      rotati
     *on, angle of rotation about Z axis, Z offset'/ '                  
     *    of point of rotation, NRCYCL, IPARALLEL, PARNUM,'/ '          
     *            X offset of source, Y offset of source.'/ '   or (23) 
     *BEAM treatment headsimulation from any angle: name of BEAM'/ '    
     *                  simulation (eg BEAM_accelname), name of BEAM inp
     *ut'/ '         file (no .egsinp extension), name of BEAM pegs data
     *'/ '                    (no .pegs4dat extension), min. and max. we
     *ights of'/ '                      particles to use (defaults to -1
     *e30- 1e30),'/ '                      distance from centre of BEAM 
     *scoring plane to point of'/ '                      rotation, angle
     * of rotation about Z axis, Z offset'/ '                      of po
     *int of rotation, X offset of source, Y offset'/ '  of source.'//)
      DELIMETER='SOURCE INPUTS'
      IVAL = IVAL + 1
      NUM_IPART = IVAL
      VALUES_SOUGHT(IVAL)='INCIDENT PARTICLE'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      DEFAULT(IVAL)=0
      ALLOWED_INPUTS(IVAL,4)='ELECTRON'
      ALLOWED_INPUTS(IVAL,0)='PHOTON'
      ALLOWED_INPUTS(IVAL,1)='POSITRON'
      ALLOWED_INPUTS(IVAL,2)='ALL'
      ALLOWED_INPUTS(IVAL,3)='CHARGED'
      NMIN = NUM_IPART
      NMAX = NUM_IPART
      CALL GET_INPUT
      IVAL = IVAL + 1
      NUM_SOURCE = IVAL
      VALUES_SOUGHT(IVAL)='SOURCE NUMBER'
      NVALUE(IVAL)=1
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=23
      DEFAULT(IVAL)=0
      NMIN = NUM_SOURCE
      NMAX = NUM_SOURCE
      CALL GET_INPUT
      ISOURC=VALUE(NUM_SOURCE,1)
      IF ((ISOURC.NE.20)) THEN
         IVAL = IVAL + 1
         NUM_SOPTS = IVAL
         VALUES_SOUGHT(IVAL)='SOURCE OPTIONS'
         IF ((ISOURC.EQ.22)) THEN
            NVALUE(IVAL)=9
         ELSE IF(( ISOURC.EQ.23 )) THEN
            NVALUE(IVAL)=5
         ELSE
            NVALUE(IVAL)=4
         END IF
         TYPE(IVAL)=1
         VALUE_MIN(IVAL)=-999999
         VALUE_MAX(IVAL)=999999
         DEFAULT(IVAL)=1
         NMIN = NUM_SOPTS
         NMAX = NUM_SOPTS
         CALL GET_INPUT
         TEMP1=VALUE(NUM_SOPTS,1)
         TEMP2=VALUE(NUM_SOPTS,2)
         TEMP3=VALUE(NUM_SOPTS,3)
         TEMP4=VALUE(NUM_SOPTS,4)
         IF ((ISOURC.EQ.22)) THEN
            TEMP5=VALUE(NUM_SOPTS,5)
            TEMP6=VALUE(NUM_SOPTS,6)
            TEMP7=VALUE(NUM_SOPTS,7)
            TEMP8=VALUE(NUM_SOPTS,8)
            TEMP9=VALUE(NUM_SOPTS,9)
         END IF
         IF((ISOURC.EQ.23))TEMP5=VALUE(NUM_SOPTS,5)
      END IF
      IQIN=VALUE(NUM_IPART,1)
      IF ((IQIN.EQ.4)) THEN
         IQIN=-1
      END IF
      WRITE(*,*)' IQIN ',IQIN
      IF ((ISOURC.EQ.20)) THEN
         IVAL = IVAL + 1
         NUM_MODEIN = IVAL
         VALUES_SOUGHT(IVAL)='MODEIN'
         NVALUE(IVAL)=1
         TYPE(IVAL)=3
         DEFAULT(IVAL)=1
         ALLOWED_INPUTS(IVAL,0)='LOCAL'
         ALLOWED_INPUTS(IVAL,1)='EXTERNAL'
         NMIN = NUM_MODEIN
         NMAX = NUM_MODEIN
         CALL GET_INPUT
         MODEIN=VALUE(NUM_MODEIN,1)
         IF ((MODEIN.EQ.1)) THEN
            IVAL = IVAL + 1
            NUM_RDFIL = IVAL
            VALUES_SOUGHT(IVAL)='RDIST FILENAME'
            NVALUE(IVAL)=1
            TYPE(IVAL)=2
            NMIN = NUM_RDFIL
            NMAX = NUM_RDFIL
            CALL GET_INPUT
         ELSE
            IVAL = IVAL + 1
            NUM_NRDIST = IVAL
            VALUES_SOUGHT(IVAL)='NRDIST'
            NVALUE(IVAL)=1
            TYPE(IVAL)=0
            VALUE_MIN(IVAL)=1
            VALUE_MAX(IVAL)=100
            DEFAULT(IVAL)=1
            NMIN = NUM_NRDIST
            NMAX = NUM_NRDIST
            CALL GET_INPUT
            NRDIST=VALUE(NUM_NRDIST,1)
            IVAL = IVAL + 1
            NUM_RDISTF = IVAL
            VALUES_SOUGHT(IVAL)='RDISTF'
            NVALUE(IVAL)=NRDIST
            TYPE(IVAL)=1
            VALUE_MIN(IVAL)=0
            VALUE_MAX(IVAL)=999999
            DEFAULT(IVAL)=1.0
            IVAL = IVAL + 1
            NUM_RPDF = IVAL
            VALUES_SOUGHT(IVAL)='RPDF'
            NVALUE(IVAL)=NRDIST
            TYPE(IVAL)=1
            VALUE_MIN(IVAL)=0
            VALUE_MAX(IVAL)=999999
            DEFAULT(IVAL)=1.0
            NMIN=NUM_NRDIST
            NMAX=NUM_RPDF
            NMIN = NMIN
            NMAX = NMAX
            CALL GET_INPUT
         END IF
         IVAL = IVAL + 1
         NUM_RDIOUTSP = IVAL
         VALUES_SOUGHT(IVAL)='RDIST IOUTSP'
         NVALUE(IVAL)=1
         TYPE(IVAL)=3
         DEFAULT(IVAL)=0
         ALLOWED_INPUTS(IVAL,0)='NONE'
         ALLOWED_INPUTS(IVAL,1)='INCLUDE'
         NMIN = NUM_RDIOUTSP
         NMAX = NUM_RDIOUTSP
         CALL GET_INPUT
      END IF
      IF (((ISOURC.EQ.21).OR.(ISOURC.EQ.22))) THEN
         IVAL = IVAL + 1
         NUM_FILSPC = IVAL
         VALUES_SOUGHT(IVAL)='FILSPC'
         TYPE(IVAL)=2
         NMIN = NUM_FILSPC
         NMAX = NUM_FILSPC
         CALL GET_INPUT
      END IF
      IF (( ISOURC .EQ. 23 )) THEN
         IVAL = IVAL + 1
         NUM_BEAM_CODE = IVAL
         VALUES_SOUGHT(IVAL)='BEAM CODE'
         TYPE(IVAL)=2
         IVAL = IVAL + 1
         NUM_PEGS_FILE = IVAL
         VALUES_SOUGHT(IVAL)='PEGS FILE'
         TYPE(IVAL)=2
         IVAL = IVAL + 1
         NUM_IFILE = IVAL
         VALUES_SOUGHT(IVAL)='INPUT FILE'
         TYPE(IVAL)=2
         NMIN = NUM_BEAM_CODE
         NMAX = NUM_IFILE
         CALL GET_INPUT
         IVAL = IVAL + 1
         VALUES_SOUGHT(IVAL)='SECRET'
         nvalue(ival) = 1
         type(ival) = 3
         allowed_inputs(ival,0) = 'no'
         allowed_inputs(ival,1) = 'yes'
         IVAL = IVAL + 1
         NUM_WW23 = IVAL
         VALUES_SOUGHT(IVAL)='WEIGHT WINDOW'
         NVALUE(IVAL)=2
         TYPE(IVAL)=1
         VALUE_MIN(IVAL)=-1e30
         VALUE_MAX(IVAL)= 1e30
         error_flag_save = error_flag
         NMIN = NUM_WW23-1
         NMAX = NUM_WW23
         CALL GET_INPUT
         error_flag = error_flag_save
         IF (( error_flags(NUM_BEAM_CODE) .EQ. 0 )) THEN
            READ (CHAR_VALUE(NUM_BEAM_CODE,1),FMT='(A)') the_beam_code
         ELSE
            error_flag = 1
         END IF
         IF (( error_flags(NUM_PEGS_FILE) .EQ. 0 )) THEN
            READ (CHAR_VALUE(NUM_PEGS_FILE,1),FMT='(A)') the_pegs_file
         ELSE
            error_flag = 1
         END IF
         IF (( error_flags(NUM_IFILE) .EQ. 0 )) THEN
            READ (CHAR_VALUE(NUM_IFILE,1),FMT='(A)') the_input_file
         ELSE
            error_flag = 1
         END IF
         min_weight_23 = -1e30
         max_weight_23 = 1e30
         secret_option_23 = 0
         IF (( error_flags(NUM_WW23) .EQ. 0 )) THEN
            min_weight_23 = value(num_ww23,1)
            max_weight_23 = value(num_ww23,2)
         END IF
         IF (( error_flags(NUM_WW23-1) .EQ. 0 )) THEN
            secret_option_23 = value(NUM_WW23-1,1)
         END IF
      END IF
      IF ((ISOURC.EQ.20)) THEN
         IF ((MODEIN.EQ.1)) THEN
            READ (CHAR_VALUE(NUM_RDFIL,1),FMT='(A)') FILNAM
         ELSE
            NRDIST=VALUE(NUM_NRDIST,1)
            DO 2821 K=1,NRDIST
               RDISTF(K)=VALUE(NUM_RDISTF,K)
               RPDF(K)=VALUE(NUM_RPDF,K)
2821        CONTINUE
2822        CONTINUE
         END IF
         IOUTSP=VALUE(NUM_RDIOUTSP,1)
      END IF
      IF (((ISOURC .EQ. 21) .OR. (ISOURC .EQ. 22))) THEN
         READ (CHAR_VALUE(NUM_FILSPC,1),FMT='(256A1)') FILSPC
      END IF
      WRITE(6,2830)IQIN,ISOURC,TEMP1,TEMP2,TEMP3,TEMP4
2830  FORMAT(T10,'SRCRZ read:', 2I5,4F12.5)
      IF((ISOURC.EQ.22))WRITE(6,2840)TEMP5,TEMP6,TEMP7,TEMP8,TEMP9
2840  FORMAT(T10,'           ',5F12.5)
      IF(((IQIN .LT. -1) .OR. (IQIN .GT. 1 .AND. (ISOURC .LT. 21 .OR. IS
     *OURC .GT. 23)) .OR. (IQIN .GT. 3 .AND. (ISOURC .LT. 21 .OR. ISOURC
     * .GT. 23))))IQIN = 0
      SVTMP1=TEMP1
      SVTMP2=TEMP2
      SVTMP3=TEMP3
      SVTMP4=TEMP4
      RETURN
      ENTRY SRCINI(SCARG1,SCARG2,SCARG3,SCARG4,ICORRL)
      NHSTRY=0
      last_nhstry = 0
      IF ((ISOURC .EQ. 0)) THEN
         RBEAM=TEMP1
         FNORM=TEMP2**2+TEMP3**2+TEMP4**2
         IF ((FNORM.EQ.0.0)) THEN
            UINC=0.0
            VINC=0.0
            WINC=1.0
         ELSE
            FNORM=SQRT(FNORM)
            UINC=TEMP2/FNORM
            VINC=TEMP3/FNORM
            WINC=TEMP4/FNORM
         END IF
         TEMP5=RCYL(NR)
         IF(((RBEAM.LE.0.0).OR.(RBEAM.GT.TEMP5)))RBEAM=TEMP5
         WRITE(6,2850)IQIN,RBEAM,UINC,VINC,WINC
2850     FORMAT(/' Electric charge of the source:',T60,I12/ ' Parallel b
     *eam incident from the front(+ve Z-axis)'/ ' Radius of beam at thef
     *ront face of the target:',T60,F10.4,' cm'/ ' X-axis direction cosi
     *ne:',T60,F10.4/ ' Y-axis direction cosine:',T60,F10.4/ ' Z-axis di
     *rection cosine:',T60,F10.4/)
      ELSE IF((ISOURC.EQ.1)) THEN
         DISTZ=TEMP1
         RBEAM=TEMP2
         TEMP3=RCYL(NR)
         IF((DISTZ.LE.0.0))DISTZ=100.
         IF(((RBEAM.LE.0.0).OR.(RBEAM.GT.TEMP3)))RBEAM=TEMP3
         WRITE(6,2860)IQIN,DISTZ,RBEAM
2860     FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' POINT SOUR
     *CE ON AXIS INCIDENT FROM THE FRONT(+VE Z-AXIS)'/ ' SOURCE DISTANCE
     * TO THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/ ' RADIUS OF TH
     *E BEAM ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/)
      ELSE IF((ISOURC.EQ.2)) THEN
         RBEAM=0.0
         NR=1
         NREG=NPLANE
         RCYL(1)=1000.0
         CYRAD2(1)=1.0E6
         WRITE(6,2870)IQIN,RBEAM
2870     FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' BROAD PARA
     *LLEL BEAM INCIDENT FROM THE FRONT (+VE Z-AXIS)'/ ' RADIUS OF THE B
     *EAM ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/)
         IF ((NMED.NE.1)) THEN
            WRITE(6,2880)
2880        FORMAT(/' **** ALL REGIONS IN A SLAB MUST BE SAME MATERIAL**
     *****'/)
         END IF
      ELSE IF((ISOURC .EQ. 3)) THEN
         RBEAM=TEMP2
         IF ((RBEAM .GT. RCYL(NR))) THEN
            WRITE(6,2890)RBEAM, RCYL(NR)
2890        FORMAT(//' ***  Source radius too big at',F10.3,' Reduced to
     *',F10.3,' cm')
            RBEAM = RCYL(NR)
         END IF
         RBEAM2 = RBEAM**2
         RMINBM = TEMP1
         IF ((RMINBM .GT. RBEAM)) THEN
            RMINBM=RBEAM
         END IF
         RMINSQ = RMINBM**2
         ZSMIN=TEMP3
         ZSMAX=TEMP4
         IF ((ZSMIN .LT. ZPLANE(1))) THEN
            ZSMIN= ZPLANE(1)
         END IF
         IF ((ZSMAX .GT. ZPLANE(NPLANE))) THEN
            ZSMAX = ZPLANE(NPLANE)
         END IF
         WRITE(6,2900)IQIN,RMINBM,RBEAM,ZSMIN,ZSMAX
2900     FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' UNIFORM IS
     *OTROPICALLY RADIATING RING: INNER,OUTER Radius',2F10.3 / '   FRONT
     *,Back DEPTH:',T50,2F10.3 /)
      ELSE IF((ISOURC .EQ. 4)) THEN
         RBEAM=TEMP1
         IF ((RCYL(NR).LT.650.)) THEN
            IF ((NR.LT.10)) THEN
               NR=NR+1
               NREG=NZ*NR+1
            ELSE
               WRITE(6,2910)
2910           FORMAT(/' ***WARNING***  LAST RADIAL BIN INCREASED TO 100
     *0cm'/)
            END IF
            RCYL(NR)=1000.0
            CYRAD2(NR)=1.0E6
         END IF
         IF(((RBEAM.LE.0.0).OR.(RBEAM.GT.RCYL(NR))))RBEAM=RCYL(NR)
         WRITE(6,2920)IQIN,RBEAM
2920     FORMAT(/' ELECTRIC CHARGE OF BEAM:',T60,I12/ ' CENTRAL AXIS FLU
     *ENCE VS BEAM RADIUS'/ ' RADII INPUT ABOVE WILL BE CONSIDERED AS BE
     *AM RADII'/ ' RADIUS OF CENTRAL AXIS ZONE: ',T60,F10.4,' cm'/)
         IF ((NMED.NE.1)) THEN
            WRITE(6,2930)
2930        FORMAT(/' **** ALL REGIONS IN A SLAB MUST BE SAME MATERIAL**
     *****'/)
         END IF
      ELSE IF((ISOURC .EQ. 10)) THEN
         XBEAM=TEMP1
         ZBEAM=TEMP2
         TEMP3=RCYL(NR)
         IF(((XBEAM.LE.0.0).OR.(XBEAM.GT.TEMP3)))XBEAM=TEMP3
         TEMP3=0.5*(ZPLANE(NPLANE)-ZPLANE(1))
         IF(((ZBEAM.LE.0.0).OR.(ZBEAM.GT.TEMP3)))ZBEAM=TEMP3
         WRITE(6,2940)IQIN,XBEAM,ZBEAM
2940     FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' PARALLEL B
     *EAM INCIDENT FROM THE SIDE'/ ' HALF-WIDTH(X-AXIS) OF THE BEAM AT T
     *HE TARGET MIDPOINT',T60,F10.4,' cm'/ ' HALF-HEIGHT(Z-AXIS/) OF THE
     * BEAM AT THE TARGET MIDPOINT', T60,F10.4,' cm'/)
      ELSE IF((ISOURC .EQ. 11)) THEN
         DISTRH = TEMP1
         IF((DISTRH .LT. 0.0))DISTRH=-DISTRH
         IF((DISTRH .EQ. 0.0))DISTRH=100.0
         XBEAM = TEMP2
         ZBEAM = TEMP3
         TEMP4 = RCYL(NR)
         IF ((DISTRH .LE. TEMP4)) THEN
            WRITE(6,2950)
2950        FORMAT(' SOURCE FROM WITHIN TARGET, INPUT IGNORED')
            ERROR_FLAG=1
         END IF
         TEMP4=TEMP4*SQRT((DISTRH+TEMP4)*(DISTRH-TEMP4))/DISTRH
         IF(((XBEAM .LE. 0.0) .OR. (XBEAM .GT. TEMP4)))XBEAM=TEMP4
         TEMP4=0.5*(ZPLANE(NPLANE)-ZPLANE(1))
         IF(((ZBEAM .LE. 0.0) .OR. (ZBEAM .GT. TEMP4)))ZBEAM=TEMP4
         IF ((ICORRL .EQ. 0)) THEN
            WRITE(6,2960)IQIN,DISTRH,XBEAM,ZBEAM
2960        FORMAT(/' Electric charge of the source:',T60,I12/ ' Point s
     *ource on axis incident from the side(Y-axis)'/ ' Source distance t
     *o target midpoint:',T60,F10.4,' cm'/ ' Half-width(X-axis) of the b
     *eam at the target midpoint',T60,F10.4,' cm'/ ' Half-height(Z-axis/
     *) of the beam at the target midpoint', T60,F10.4,' cm'/)
         END IF
      ELSE IF((ISOURC .EQ. 12)) THEN
         DISTRH=TEMP1
         IF((DISTRH .LT. 0.0))DISTRH=-DISTRH
         DISTZ=TEMP2
         RBEAM=RCYL(NR)
         IF ((DISTRH .GT. RBEAM)) THEN
            XBEAM=RBEAM*SQRT((DISTRH-RBEAM)*(DISTRH+RBEAM))/DISTRH
            ZBEAM=0.5*(ZPLANE(NPLANE)-ZPLANE(1))
         ELSE
            XBEAM=0.0
            ZBEAM=0.0
         END IF
         IF (((DISTRH .LE. RBEAM) .AND. DISTZ .GE. ZPLANE(1)-ZPLANE(NPLA
     *   NE) .AND. DISTZ.LE.0.0)) THEN
            WRITE(6,2970)
2970        FORMAT(' Source from within target, input ignored')
            ERROR_FLAG=1
         END IF
         WRITE(6,2980)IQIN,DISTRH,DISTZ,RBEAM,XBEAM,ZBEAM
2980     FORMAT(/' Electric charge of the source:',T60,I12/ ' Point sour
     *ce off axis'/ ' Distance of source off the central axis',T60,F10.4
     *,' cm'/ ' Perpendicular distance of source from front plane',T60,F
     *10.4,' cm'/ ' Radius of the beam on the front face of the target:'
     *,T60,F10.4,' cm'/ ' Half-width(X-axis) of the beam between the tan
     *gent points', T60,F10.4,' cm'/ ' Half-height(z-axis) of thebeam be
     *tween the tangent points', T60,F10.4,' cm'/)
      ELSE IF((ISOURC .EQ. 13)) THEN
         FNORM=TEMP1**2+TEMP2**2+TEMP3**2
         IF ((FNORM .EQ. 0.0)) THEN
            UINC=0.0
            VINC=0.0
            WINC=1.0
         ELSE
            FNORM=SQRT(FNORM)
            WINC=TEMP3/FNORM
            VINC=-SQRT((1.0-WINC)*(1.0+WINC))
            UINC=0.0
         END IF
         RBEAM=RCYL(NR)
         IF ((ABS(WINC).NE.1.0)) THEN
            XBEAM=RBEAM
            ZBEAM=0.5*(ZPLANE(NPLANE)-ZPLANE(1))
         ELSE
            XBEAM=0.0
            ZBEAM=0.0
         END IF
         WRITE(6,2990)IQIN,UINC,VINC,WINC,RBEAM,XBEAM,ZBEAM
2990     FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' PARALLEL B
     *EAM AT ANY ANGLE WITH RESPECT TO THE TARGET'/ ' X-AXIS DIRECTION C
     *OSINE:',T60,F10.4/ ' Y-AXIS DIRECTION COSINE:',T60,F10.4/ ' Z-AXIS
     * DIRECTION COSINE:',T60,F10.4/ ' RADIUS OF THE BEAM ON THE FRONT F
     *ACE OF THE TARGET:',T60,F10.4,' cm'/ ' HALF-WIDTH(X-AXIS) OF THE B
     *EAM BETWEEN THE TANGENT POINTS', T60,F10.4,' cm'/ ' HALF-HEIGHT(Z-
     *AXIS) OF THE BEAM BETWEEN THE TANGENT POINTS', T60,F10.4,' cm'/)
      ELSE IF((ISOURC .EQ. 14)) THEN
         DISTZ=TEMP1
         RBEAM=TEMP2
         RMINBM=TEMP3
         IF((DISTZ.LE.0.0))DISTZ=100.
         IF(((RBEAM.LE.0.0).OR.(RBEAM.GT.RCYL(NR))))RBEAM=RCYL(NR)
         IF ((RMINBM.EQ.0.0)) THEN
            WRITE(6,3000)
3000        FORMAT(/' ***WHY USE ISOURC=14 WITH RMINB=0.0?***')
         END IF
         WRITE(6,3010)IQIN,DISTZ,RBEAM,RMINBM
3010     FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' POINT SOUR
     *CE ON AXIS INCIDENT FROM THE FRONT(+VE Z-AXIS)'/ ' SOURCE DISTANCE
     * TO THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/ ' RADIUS OF TH
     *E BEAM ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/ ' INNERR
     *ADIUS OF BEAM ON FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/)
      ELSE IF((ISOURC .EQ. 15)) THEN
         call src15_ini(temp1,temp2,temp3,temp4,ERROR_FLAG)
      ELSE IF((ISOURC .EQ. 16)) THEN
         call src16_ini(temp1,temp2,temp3,temp4,ERROR_FLAG)
      ELSE IF((ISOURC .EQ. 17)) THEN
         DISTZ=TEMP1
         XBEAM=TEMP2
         YBEAM=TEMP3
         TEMP4=RCYL(NR)
         IF((DISTZ.LE.0.0))DISTZ=100.
         IF(((RBEAM.LE.0.0).OR.(RBEAM.GT.TEMP4)))RBEAM=TEMP4
         WRITE(6,3020)IQIN,DISTZ,XBEAM,YBEAM
3020     FORMAT(/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/ ' POINT SOUR
     *CE ON AXIS INCIDENT FROM THE FRONT(+VE Z-AXIS)'/ ' SOURCE DISTANCE
     * TO THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/ ' X-AXIS HALF-
     *WIDTH ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/ ' Y-AXISH
     *ALF-WIDTH ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/)
      ELSE IF((ISOURC .EQ. 20)) THEN
         WRITE(6,3030)
3030     FORMAT(' Local input(0) or external file(1): ',$)
         WRITE(6,3040)
3040     FORMAT(/' RADIAL DISTRIBUTION:')
         IF ((MODEIN.EQ.0)) THEN
            WRITE(6,3050)
3050        FORMAT(' Number of radial bins: ',$)
            IF (((NRDIST.LT.1).OR.(NRDIST.GT.100))) THEN
               WRITE(6,3060)
3060           FORMAT(/' *** NUMBER RADIAL BINS OUT OF RANGE (<1 OR >100
     *),', ' RESET TO 100 ***')
               NRDIST=100
            END IF
            WRITE(6,3070)NRDIST
3070        FORMAT(' INPUT',I4,' SETS OF RDISTF,RPDF IN 2F20.0 FORMAT')
            WRITE(6,3080)
3080        FORMAT('   RDISTF INCREASING IN SIZE, RPDF NON-NEGATIVE')
            DO 3091 IB=1,NRDIST
3091        CONTINUE
3092        CONTINUE
         ELSE
            WRITE(6,3100)
3100        FORMAT(' Input name of file with spectrum (up to 80 char wit
     *h .ext): '/)
            WRITE(6,3110)FILNAM
3110        FORMAT(/' Read input radial distribution from: '/80A1)
            call replace_env(FILNAM)
            OPEN(UNIT=9,file=filnam,STATUS='OLD')
            READ(9,*)NRDIST
            IF (((NRDIST.LT.1).OR.(NRDIST.GT.100))) THEN
               WRITE(6,3120)
3120           FORMAT(' *** Number radial bins out of range (<1 OR >100)
     *,', ' RESET TO 100 ***')
               NRDIST=100
            END IF
            DO 3131 IB=1,NRDIST
               READ(9,*)RDISTF(IB),RPDF(IB)
3131        CONTINUE
3132        CONTINUE
            CLOSE(UNIT=9)
            WRITE(6,3140)NRDIST
3140        FORMAT('    HAVE READ',I5,' INPUT RADIAL BINS FROM FILE')
         END IF
         ICOUNT=0
         RLAST=0
         IERROR=0
3150     CONTINUE
3151        CONTINUE
            ICOUNT=ICOUNT+1
            IF ((ICOUNT.GT.NRDIST)) THEN
               GO TO 3152
            END IF
            IF ((RDISTF(ICOUNT).LE.RLAST)) THEN
               IERROR=1
               WRITE(6,3160)
3160           FORMAT(' *** RDISTF>=LAST ONE. NOT ALLOWED,', ' TERMINATI
     *NG RADIAL DISTRIBUTION INPUT.')
            ELSE IF((RDISTF(ICOUNT).GT.RCYL(NR))) THEN
               IERROR=1
               WRITE(6,3170)RCYL(NR)
3170           FORMAT(' *** RDISTF>',G14.7,', GEOMETRY SIZE.', ' TERMINA
     *TING RADIAL DISTRIBUTION INPUT')
            ELSE IF((RPDF(ICOUNT).LT.0.0)) THEN
               IERROR=1
               WRITE(6,3180)
3180           FORMAT(' PDF < 0 NOT ALLOWED,', ' TERMINATING RADIAL DIST
     *RIBUTION INPUT')
            END IF
            IF ((IERROR.EQ.1)) THEN
               ICOUNT=ICOUNT-1
               IF ((ICOUNT.EQ.0)) THEN
                  WRITE(6,3190)
3190              FORMAT(' *** NO RADIAL DISTRIBUTION DEFINED,', ' STOPP
     *ING EXECUTION ***')
                  STOP
               END IF
               WRITE(6,3200)ICOUNT
3200           FORMAT(' RADIAL DITRIBUTION INPUT APPEARS TO BE INCOMPLET
     *E,', ' NRDIST RESET TO ',I12)
               NRDIST=ICOUNT
               GO TO 3152
            END IF
            RLAST=RDISTF(ICOUNT)
         GO TO 3151
3152     CONTINUE
         WRITE(6,3210)RDISTF(NRDIST)
3210     FORMAT('    RADIAL DISTRIBUTION RANGES FROM 0 TO',F12.3,' cm')
         WRITE(6,3220)
3220     FORMAT(' PRINT DISTRIBUTION DATA IN OUTPUT SUMMARY, YES(1) OF N
     *O(0): ',$)
         IF((IOUTSP.NE.1))IOUTSP=0
         WRITE(6,'('' '')')
      ELSE IF(( ISOURC .EQ. 23 )) THEN
         dist_phsp = temp1
         theta_phsp = temp2
         cost_phsp = cos(theta_phsp*0.017453292222)
         sint_phsp = sin(theta_phsp*0.017453292222)
         chamber_c = temp3
         xoffset = temp4
         yoffset = temp5
         ENFLAG=1
         iqinc = iqin
         WRITE(6,3230)iqinc,min_weight_23,max_weight_23, the_beam_code(:
     *   lnblnk1(the_beam_code)),the_pegs_file(:lnblnk1(the_pegs_file)),
     *    the_input_file(:lnblnk1(the_input_file)), dist_phsp,theta_phsp
     *   ,chamber_c,xoffset,yoffset
3230     FORMAT(/' Full treatment head simulation from an angle'/, 'Part
     *icle charge                               : ',i3,/ '    Weight win
     *dow                                 : ',2g15.6,/ '    BEAMnrcuser 
     *code                             : ',a,/ '    PEGS data file      
     *                         : ',a,/ '    Input file                  
     *      : ',a,/ '    Rotation point to phsp-planemidpoint distance: 
     *',f10.4,/ '    Incident angle (degrees)              : ',f10.4,/ '
     *    Rotation point (will be set to chamber center'/, '      if gre
     *ater than 1e4 or less than -1e4):     : ',g14.4, ' cm.'/ '    X of
     *fset of phsp plane (before rotation)   : ',f10.4,' cm'/ '    Y off
     *set of phsp plane (before rotation)     : ',f10.4,' cm')
         write(6,'(//a)') 'About to call init_beamsource'
         call init_beamsource(i_parallel,n_parallel,i_log,'linux', hen_h
     *   ouse,egs_home,the_beam_code, the_pegs_file,the_input_file)
         call maxenergy_beamsource(EKSRCM)
         EIN=EKSRCM
         WRITE(6,3240)EKSRCM
3240     FORMAT('    Max. kinetic energy of simulation             : ',f
     *10.4,' MeV'/)
      ELSE IF(((ISOURC .EQ. 21) .OR. (ISOURC .EQ. 22))) THEN
         IQINC=IQIN
         IF ((ISOURC .EQ. 22)) THEN
            dist_phsp=TEMP2
            theta_phsp = temp3
            cost_phsp = cos(theta_phsp*0.017453292222)
            sint_phsp = sin(theta_phsp*0.017453292222)
            chamber_c = temp4
            count_phsp = 0
            xoffset = TEMP8
            yoffset = TEMP9
         END IF
         IMODE=TEMP1
         IF ((ISOURC.EQ.21)) THEN
            NRCYCL=TEMP2
            IPARALLEL=TEMP3
            PARNUM=TEMP4
         ELSE IF((ISOURC.EQ.22)) THEN
            NRCYCL=TEMP5
            IPARALLEL=TEMP6
            PARNUM=TEMP7
         END IF
         IF((IMODE.NE.2))IMODE=0
         WRITE(6,3250)IMODE
3250     FORMAT(/' MODE',I2,' Phase-space file to be read from unit 42..
     *.'/ ' Input name of file with phase space data (1 - 80 CHARS,', 'w
     *ith .EXT): ')
         WRITE(6,3260)FILSPC
3260     FORMAT(/' Reading phase space information from: '/10x,256A1)
         call replace_env(SPCNAM)
         i_iaea_in=0
         ilen=lnblnk1(SPCNAM)
         IF ((SPCNAM(ilen-8:ilen).EQ.'.IAEAphsp')) THEN
            i_iaea_in=1
            SPCNAM=SPCNAM(:ilen-9)
         END IF
         IF ((i_iaea_in.EQ.1)) THEN
            i_unit_in=42
            call iaea_new_source(i_unit_in,SPCNAM,1,iaea_result)
            IF ((iaea_result.LT.0)) THEN
               WRITE(i_log,*)' Error opening IAEA phase space source.'
            END IF
            call iaea_get_max_particles(i_unit_in,-1,iaea_dummy_long)
            NCASE_PHSP=iaea_dummy_long
            call iaea_get_max_particles(i_unit_in,1,iaea_dummy_long)
            NPHOTPHSP=iaea_dummy_long
            call iaea_get_total_original_particles(i_unit_in,iaea_dummy_
     *      long)
            NINCSRC=iaea_dummy_long
            call iaea_get_maximum_energy(i_unit_in,EKMAX_PHSP_SHORT)
            TEMP2=EKMAX_PHSP_SHORT
            call iaea_get_constant_variable(i_unit_in,2,Z_PHSP_SHORT,iae
     *      a_result)
            IF ((iaea_result.EQ.-3)) THEN
               write(i_log,*) ' Z positions of each particle will be rea
     *d from phase space data.'
               Z_SOURCE=999.
               IZSCORE=1
            ELSE IF((iaea_result.LT.0)) THEN
               write(i_log,*)' Error reading Z position where IAEA phsp
     *was scored.'
               IZSCORE=0
            ELSE
               Z_SOURCE=Z_PHSP_SHORT
               IZSCORE=0
            END IF
            call iaea_get_extra_numbers(i_unit_in,iaea_n_extra_floats,ia
     *      ea_n_extra_ints)
            IF ((iaea_n_extra_floats .EQ. -1 .OR. iaea_n_extra_ints .EQ.
     *       -1)) THEN
               write(i_log,*)' Error reading number of extra variables s
     *tored in IAEA phsp'
            END IF
            call iaea_get_type_extra_variables(i_unit_in,iaea_result,iae
     *      a_extra_int_types, iaea_extra_float_types)
            IF ((iaea_result.EQ.-1)) THEN
               write(i_log,*)' Error getting types of extra variables st
     *ored in IAEA phsp'
            END IF
            DO 3271 I_PHSP=1,iaea_n_extra_ints
               IF ((iaea_extra_int_types(I_PHSP).EQ.2)) THEN
                  iaea_i_latch=I_PHSP
                  GO TO3272
               END IF
3271        CONTINUE
3272        CONTINUE
            IF ((iaea_i_latch.EQ.-99)) THEN
               write(i_log,*)' Warning: IAEA format phsp file does not s
     *tore LATCH'
            END IF
            DO 3281 I_PHSP=1,iaea_n_extra_floats
               IF ((iaea_extra_float_types(I_PHSP).EQ.3)) THEN
                  iaea_i_zlast=I_PHSP
                  GO TO3282
               END IF
3281        CONTINUE
3282        CONTINUE
            IF ((iaea_i_zlast.EQ.-99)) THEN
               ismode=0
            ELSE
               ismode=1
            END IF
            iaea_i_muidx=MAX(1,iaea_i_zlast+1)
            IF ((iaea_i_muidx.GT.iaea_n_extra_floats .OR. iaea_extra_flo
     *      at_types(iaea_i_muidx).NE.0)) THEN
               iaea_i_muidx=-99
               IMUPHSP=0
            ELSE
               IMUPHSP=1
            END IF
            WRITE(6,3290)NCASE_PHSP,NPHOTPHSP,TEMP2,NINCSRC
3290        FORMAT(T10,' IAEA format Phase space source with:'/ T5,'    
     *            Total number of particles =',I13/ T5,'                
     *Number of photons =',I13/ T5,'              Maximum particle kinet
     *ic energy =',F13.3,' MeV'/ T5,' # of particles incident from origi
     *nal source =',F13.1/)
            IF ((IZSCORE.EQ.0)) THEN
               WRITE(6,3300)Z_SOURCE
3300           FORMAT(T5,'                        Z where source scored=
     *',F13.3,' cm'/)
            END IF
            call iaea_check_file_size_byte_order(i_unit_in,iaea_result)
            IF ((iaea_result.EQ.-3)) THEN
               WRITE(i_log,*)' ERROR: Size of phase space file does not
     *match'
               WRITE(i_log,*)' the value of checksum in the header.  Som
     *ething may be'
               WRITE(i_log,*)' wrong.  Check your file.'
               call exit(1)
            ELSE IF((iaea_result.EQ.-4)) THEN
               WRITE(i_log,*)' ERROR: Byte order in the phase space file
     * does not'
               WRITE(i_log,*)' match the machine you are running on.'
               call exit(1)
            ELSE IF((iaea_result.EQ.-5)) THEN
               WRITE(i_log,*)' ERROR: Size of file does not match the va
     *lue of checksum'
               WRITE(i_log,*)' in the header AND there is a byte order m
     *ismatch between'
               WRITE(i_log,*)' the file and the machine you are running
     *on.'
               call exit(1)
            ELSE IF((iaea_result.EQ.-1)) THEN
               WRITE(i_log,*)' ERROR: Cannot open phase space header.'
               call exit(1)
            ELSE IF((iaea_result.EQ.-2)) THEN
               WRITE(i_log,*)' ERROR: Something is wrong with the phase
     *space file.'
               call exit(1)
            END IF
         ELSE
            IF ((IMODE.GT.0)) THEN
               PHSP_RECL=4*8
               OPEN(UNIT=42,FILE=SPCNAM,FORM='UNFORMATTED',ACCESS='DIREC
     *T', RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP)
               IF ((IERR_PHSP.NE.0)) THEN
                  WRITE(6,3310)
3310              FORMAT(/' ***error opening file as MODE2 ****' /' ***T
     *HE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE2 FILE) ***'/ /' *** 
     *WE NOW TRY TO OPEN IT AS A MODE3 FILE ***'//)
                  OPEN(UNIT=42,STATUS='OLD',FILE=SPCNAM, FORM='UNFORMATT
     *ED', IOSTAT=IERR_PHSP)
                  IF ((IERR_PHSP.NE.0)) THEN
                     WRITE(6,3320)
3320                 FORMAT(//' *** PHASE SPACE FILE CANNOT BE FOUND. **
     **')
                     STOP
                  END IF
                  READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT
     *            _PHSP_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHS
     *            P_SHORT
                  NCASE_PHSP=NUM_PHSP_TOT
                  NPHOTPHSP=PHOT_PHSP_TOT
                  TEMP2=EKMAX_PHSP_SHORT
                  TEMP3=EKMINE_PHSP_SHORT
                  NINCSRC=NINC_PHSP_SHORT
                  IF ((IERR_PHSP.NE.0)) THEN
                     WRITE(6,3330)
3330                 FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE F
     *ILE*** '//)
                     STOP
                  END IF
                  IF ((LINE1 .NE. 'MODE3')) THEN
                     WRITE(6,3340)
3340                 FORMAT(//' That file does not start with MODE3,', '
     * as all old compressed files (with ZLAST) must'/ '  Check it out a
     *nd try again!'///)
                     IERR_PHSP=1
                     STOP
                  ELSE
                     WRITE(6,3350)
3350                 FORMAT(//' This is a MODE3 file! '/ ' Please conver
     *t it into a MODE2 file using [readphsp] ', ' and try again!'///)
                     IERR_PHSP=1
                     STOP
                  END IF
               END IF
               READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT_PH
     *         SP_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHOR
     *         T
               NCASE_PHSP=NUM_PHSP_TOT
               NPHOTPHSP=PHOT_PHSP_TOT
               TEMP2=EKMAX_PHSP_SHORT
               TEMP3=EKMINE_PHSP_SHORT
               NINCSRC=NINC_PHSP_SHORT
               IF ((IERR_PHSP.NE.0)) THEN
                  WRITE(6,3360)
3360              FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FILE
     **** '//)
                  STOP
               END IF
               IF ((LINE1 .NE. 'MODE2')) THEN
                  WRITE(6,3370)
3370              FORMAT(//' That file does not start with MODE2,', ' as
     * standard compressed files with ZLAST must'/ '  Check it out and t
     *ry again!'///)
                  IERR_PHSP=1
                  STOP
               END IF
            ELSE IF((IMODE.EQ.0)) THEN
               PHSP_RECL=4*7
               OPEN(UNIT=42,FILE=SPCNAM,FORM='UNFORMATTED',ACCESS='DIREC
     *T', RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP)
               IF ((IERR_PHSP.NE.0)) THEN
                  WRITE(6,3380)
3380              FORMAT(/' ***ERROR opening file as MODE0****' /' *** T
     *HE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE0 FILE) ***'/ /' ***W
     *E NOW TRY TO OPEN IT AS A MODE1 FILE ***'//)
                  OPEN(UNIT=42,STATUS='OLD',FILE=SPCNAM, FORM='UNFORMATT
     *ED', IOSTAT=IERR_PHSP)
                  IF ((IERR_PHSP.NE.0)) THEN
                     WRITE(6,3390)
3390                 FORMAT(//' *** PHASE SPACE FILE CANNOT BE FOUND. **
     **')
                     STOP
                  END IF
                  READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT
     *            _PHSP_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHS
     *            P_SHORT
                  NCASE_PHSP=NUM_PHSP_TOT
                  NPHOTPHSP=PHOT_PHSP_TOT
                  TEMP2=EKMAX_PHSP_SHORT
                  TEMP3=EKMINE_PHSP_SHORT
                  NINCSRC=NINC_PHSP_SHORT
                  IF ((IERR_PHSP.NE.0)) THEN
                     WRITE(6,3400)
3400                 FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE F
     *ILE*** '//)
                     STOP
                  END IF
                  IF ((LINE1 .NE. 'MODE1')) THEN
                     WRITE(6,3410)
3410                 FORMAT(//' That file does not start with MODE1,', '
     * as all old compressed files must'/ '  Check it out and try again!
     *'///)
                     IERR_PHSP=1
                     STOP
                  ELSE
                     WRITE(6,3420)
3420                 FORMAT(//' This is a MODE1 file! '/ ' Please conver
     *t it into a MODE0 file using [readphsp] ', 'and try again!'///)
                     IERR_PHSP=1
                     STOP
                  END IF
               END IF
               READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT_PH
     *         SP_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHOR
     *         T
               NCASE_PHSP=NUM_PHSP_TOT
               NPHOTPHSP=PHOT_PHSP_TOT
               TEMP2=EKMAX_PHSP_SHORT
               TEMP3=EKMINE_PHSP_SHORT
               NINCSRC=NINC_PHSP_SHORT
               IF ((IERR_PHSP.NE.0)) THEN
                  WRITE(6,3430)
3430              FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE FILE
     **** '//)
                  STOP
               END IF
               IF ((LINE1 .NE. 'MODE0')) THEN
                  WRITE(6,3440)
3440              FORMAT(/' Does not start with MODE0 as files without Z
     *LAST must'/ '  Try again!'//)
                  IERR_PHSP=1
                  STOP
               END IF
            ELSE IF((IMODE.LT.0)) THEN
               WRITE(6,3450)
3450           FORMAT(/' First, try to open it as a MODE0 file')
               PHSP_RECL=4*7
               OPEN(UNIT=42,FILE=SPCNAM,FORM='UNFORMATTED',ACCESS='DIREC
     *T', RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP)
               IF ((IERR_PHSP.NE.0)) THEN
                  WRITE(6,3460)
3460              FORMAT(/' Now try to open it as a MODE2 file')
                  IMODE=1
                  PHSP_RECL=4*8
                  OPEN(UNIT=42,FILE=SPCNAM,FORM='UNFORMATTED',ACCESS='DI
     *RECT', RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP)
                  IF ((IERR_PHSP.NE.0)) THEN
                     WRITE(6,3470)
3470                 FORMAT(//' *** PHASE SPACE FILE CANNOT BE FOUND. **
     **')
                  ELSE
                     READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,P
     *               HOT_PHSP_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NI
     *               NC_PHSP_SHORT
                     NCASE_PHSP=NUM_PHSP_TOT
                     NPHOTPHSP=PHOT_PHSP_TOT
                     TEMP2=EKMAX_PHSP_SHORT
                     TEMP3=EKMINE_PHSP_SHORT
                     NINCSRC=NINC_PHSP_SHORT
                     IF ((IERR_PHSP.NE.0)) THEN
                        WRITE(6,3480)
3480                    FORMAT(//' ***ERROR READING HEADER OF PHASE SPAC
     *E FILE*** '//)
                        STOP
                     END IF
                     IF ((LINE1.NE.'MODE2')) THEN
                        WRITE(6,3490)
3490                    FORMAT(//' That file does not start with MODE2,'
     *, ' as standard compressed files with ZLAST must'/ '  Check it out
     * and try again!'///)
                        CLOSE(42)
                        STOP
                     END IF
                  END IF
               ELSE
                  READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TOT,PHOT
     *            _PHSP_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHS
     *            P_SHORT
                  NCASE_PHSP=NUM_PHSP_TOT
                  NPHOTPHSP=PHOT_PHSP_TOT
                  TEMP2=EKMAX_PHSP_SHORT
                  TEMP3=EKMINE_PHSP_SHORT
                  NINCSRC=NINC_PHSP_SHORT
                  IF ((IERR_PHSP.NE.0)) THEN
                     WRITE(6,3500)
3500                 FORMAT(//' ***ERROR READING HEADER OF PHASE SPACE F
     *ILE*** '//)
                     STOP
                  END IF
                  IMODE=0
                  IF ((LINE1.NE.'MODE0')) THEN
                     WRITE(6,3510)
3510                 FORMAT(/' The file does not start with MODE0 as its
     *upposed to')
                     CLOSE(42)
                     WRITE(6,3520)
3520                 FORMAT(/' Now try to open it as a MODE2 file')
                     IMODE=1
                     PHSP_RECL=4*8
                     OPEN(UNIT=42,FILE=SPCNAM,FORM='UNFORMATTED',ACCESS=
     *               'DIRECT', RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_P
     *               HSP)
                     IF ((IERR_PHSP.NE.0)) THEN
                        WRITE(6,3530)
3530                    FORMAT(//' *** PHASE SPACE FILE CANNOT BE OPENED
     *. ***')
                     ELSE
                        READ(42,REC=1,IOSTAT=IERR_PHSP)LINE1,NUM_PHSP_TO
     *                  T,PHOT_PHSP_TOT, EKMAX_PHSP_SHORT,EKMINE_PHSP_SH
     *                  ORT,NINC_PHSP_SHORT
                        NCASE_PHSP=NUM_PHSP_TOT
                        NPHOTPHSP=PHOT_PHSP_TOT
                        TEMP2=EKMAX_PHSP_SHORT
                        TEMP3=EKMINE_PHSP_SHORT
                        NINCSRC=NINC_PHSP_SHORT
                        IF ((IERR_PHSP.NE.0)) THEN
                           WRITE(6,3540)
3540                       FORMAT(//' ***ERROR READING HEADER OF PHASE S
     *PACE FILE*** '//)
                           STOP
                        END IF
                        IF ((LINE1.NE.'MODE2')) THEN
                           WRITE(6,3550)
3550                       FORMAT(//' That file does not start with MODE
     *2,', ' as standard compressed files with ZLAST must'/ '  Check ito
     *ut and try again!'///)
                           CLOSE(42)
                           STOP
                        END IF
                     END IF
                  END IF
               END IF
            END IF
            WRITE(6,3560)NCASE_PHSP,NPHOTPHSP,TEMP2,TEMP3,NINCSRC
3560        FORMAT(' Total number of particles in file      :',I10/ ' To
     *tal number of photons                :',I10/ ' (the rest are elect
     *rons and positrons)'// ' Maximum kinetic energy of the particles:'
     *,F10.3,' MeV'/ ' Minimum kinetic energy of the electrons:',F10.3,'
     * MeV'/ ' # particles incident when phase space created :',F15.0/)
            EKSRCM=TEMP2
            EIN=TEMP2
            IF ((NCASE_PHSP .LT. 0 .OR. NPHOTPHSP .LT. 0 .OR. TEMP2 .LE.
     *       0 .OR. TEMP3 .LT.0 .OR. NINCSRC .LE.0.0)) THEN
               WRITE(6,3570)
3570           FORMAT(3(1x,79('*')/)/' Something is wrong in the above'/
     *'Likely the file is the wrong format (need to swap bytes)'/ 3(1x,7
     *9('*')/))
               STOP
            END IF
            NHSTRYM=0
            IF ((IMODE.NE.0)) THEN
               READ(42,REC=2,IOSTAT=IERR_PHSP) LATCHM,ESHORT,X_PHSP_SHOR
     *         T,Y_PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT,Z
     *         LAST_PHSP_SHORT
            ELSE
               READ(42,REC=2,IOSTAT=IERR_PHSP) LATCHM,ESHORT,X_PHSP_SHOR
     *         T,Y_PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT
            END IF
            IF ((2.EQ.76695869)) THEN
               write(*,*)' x,y,u,v,wt,eshort,latch', X_PHSP_SHORT,Y_PHSP
     *         _SHORT,U_PHSP_SHORT,V_PHSP_SHORT, WT_PHSP_SHORT,ESHORT,LA
     *         TCHM
            END IF
            IF ((ESHORT.LT.0.0)) THEN
               NHSTRYM=NHSTRYM+1
               ESHORT=ABS(ESHORT)
            END IF
            EINM=ESHORT
            WEIGHTM=WT_PHSP_SHORT
            XINM=X_PHSP_SHORT
            YINM=Y_PHSP_SHORT
            UINM=U_PHSP_SHORT
            VINM=V_PHSP_SHORT
            IF((IMODE.NE.0))ZLASTM=ZLAST_PHSP_SHORT
            IF ((NHSTRYM.NE.1)) THEN
               DOSE_STAT=1
               WRITE(6,3580)
3580           FORMAT(//' ***WARNING***'/ ' Cannot read no. of primary (
     *non-phsp) histories from ph-sp source.'/ ' Dose and fluence will b
     *e analyzed assuming each particle read from'/ ' the ph-sp file isa
     *n independent history.  May result in an'/ ' underestimate of unce
     *rtainties.'//)
            END IF
         END IF
         IF (( isourc .EQ. 22 )) THEN
            WRITE(6,3590)dist_phsp,theta_phsp,chamber_c,xoffset,yoffset
3590        FORMAT(/' Phase space file from an angle'/, '    Rotation po
     *int to phsp-plane midpoint distance: ',f10.4,/ '    Incident angle
     * (degrees)                      : ',f10.4,/ '    Rotation point (w
     *ill be set to chamber center'/, '      if greater than 1e4 or less
     * than -1e4):     : ',g14.4, ' cm.'/ '    X offset of phsp plane (b
     *efore rotation)      : ',f10.4,' cm'/ '    Y offset of phsp plane(
     *before rotation)      : ',f10.4,' cm'/)
         END IF
         IF ((IPARALLEL.GT.1 .AND. n_parallel.GT.0)) THEN
            WRITE(6,3600)IPARALLEL, n_parallel
3600        FORMAT(/' You have set IPARALLEL in the input file to ',I4,/
     *' But you are also running a C compiled code with n_parallel=',I4,
     */ ' IPARALLEL will be reset to 1, and control of the parallel run 
     *'/ ' will be from the code.'/)
            IPARALLEL=1
         END IF
         IF((IPARALLEL.LE.0))IPARALLEL=1
         IF((PARNUM.LT.0))PARNUM=0
         IF ((IPARALLEL.GT.1)) THEN
            IF ((PARNUM.GE.1 .AND. PARNUM.LE.IPARALLEL)) THEN
               WRITE(6,3610)IPARALLEL,INT((PARNUM-1)*NCASE_PHSP/IPARALLE
     *         L)+1, INT(PARNUM*NCASE_PHSP/IPARALLEL)
3610           FORMAT(/' This is one of ',I4,' parallel jobs.'/ ' It wil
     *l use from particle ',I12,' to particle ',I12,/ ' from the phase s
     *pace source in the simulation.'/)
            ELSE
               WRITE(6,3620)IPARALLEL
3620           FORMAT(/' IPARALLEL input indicates that this is one of '
     *,I4,' parallel jobs.'/ ' But PARNUM is out of range (<1 or >IPARAL
     *LEL).  Therefore, phsp '/ ' source will not be partitioned.'/)
               PARNUM=0
               IPARALLEL=1
            END IF
         END IF
         IF ((NRCYCL.LE.0)) THEN
            IF ((IQIN.EQ.1)) THEN
               WRITE(6,3630)
3630           FORMAT(/' NRCYCL cannot be calculated automatically becau
     *se'/ ' INCIDENT PARTICLE= positrons '/)
               NRCYCL=0
            ELSE
               WRITE(6,3640)
3640           FORMAT(/' NRCYCL will be calculated automatically'/)
               IF ((IQIN.EQ.-1 .OR. IQIN.EQ.3)) THEN
                  TEMPDIV=NCASE_PHSP-NPHOTPHSP
               ELSE IF((IQIN.EQ.0)) THEN
                  TEMPDIV=NPHOTPHSP
               ELSE IF((IQIN.EQ.2)) THEN
                  TEMPDIV=NCASE_PHSP
               END IF
               IF ((NINT(dble(IPARALLEL*NCASE)/dble(TEMPDIV)).LE.1)) THE
     *         N
                  NRCYCL=0
               ELSE IF((MOD(IPARALLEL*NCASE,TEMPDIV).EQ.0)) THEN
                  NRCYCL=(IPARALLEL*NCASE)/TEMPDIV-1
               ELSE
                  NRCYCL=(IPARALLEL*NCASE)/TEMPDIV
               END IF
            END IF
         END IF
         WRITE(6,3650)NRCYCL
3650     FORMAT(/' Particles will be recycled ',I4,' times before moving
     * on to next one.'/)
         CYCLNUM=0
         ENFLAG=1
         N_RUN_CHUNK_OLD=0
      ELSE
         ISOURC=0
         RBEAM=RCYL(NR)
         WRITE(6,3660)IQIN,RBEAM
3660     FORMAT(/ ' Electric charge of the source:',T60,I12/ ' Parallelb
     *eam incident from the front(+ve Z-axis)'/ ' Radius of beam at the 
     *front face of the target:',T60,F10.4,' cm'/)
      END IF
      RETURN
3670  CONTINUE
      ERROR_FLAG=1
      RETURN
      ENTRY SRCOTO(WEIGHT)
      IFPB=1
      IF (((ISOURC.EQ.0).OR.(ISOURC.EQ.2).OR.(ISOURC.EQ.4))) THEN
         IFPB=0
         IF(((ISOURC.EQ.0).AND.(WINC.NE.1.)))IFPB=1
         RBEAM=RBEAM*0.9999
         RBEAM2=RBEAM**2
         WEIGHT=1.0
         AFACE=PI*RBEAM2
         IF ((ISOURC .EQ. 0)) THEN
            AINFLU=dble(NCASET)/AFACE
         ELSE
            AINFLU=dble(NCASET)
         END IF
      ELSE IF((ISOURC .EQ. 1)) THEN
         RBEAM=RBEAM*0.9999
         RBEAM2=RBEAM**2
         DISTZ2=DISTZ**2
         DISTRH=0.0
         ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1))
         ZSOFST=ZPLANE(1)-DISTZ
         AFACE=PI*RBEAM**2
         PROBFC=1.0
         AINFLU=dble(NCASET)/DISTZ2
      ELSE IF((ISOURC .EQ. 3)) THEN
         WEIGHT=1.0
         AINFLU=dble(NCASET)
         ZSOFST=0.5*(ZSMAX - ZSMIN)+ ZSMIN
         ZBEAM=0.5*(ZSMAX - ZSMIN)
      ELSE IF((ISOURC .EQ. 10)) THEN
         XBEAM=XBEAM*0.9999
         ZBEAM=ZBEAM*0.9999
         ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1))
         RCYL1=RCYL(NR)
         RCYL2=RCYL1**2
         ASIDE=4.0*XBEAM*ZBEAM
         WEIGHT=1.
         AINFLU=dble(NCASET)/ASIDE
      ELSE IF((ISOURC .EQ. 11)) THEN
         XBEAM=XBEAM*0.9999
         ZBEAM=ZBEAM*0.9999
         ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1))
         ZSOFST=ZCOFST
         RCYL1=RCYL(NR)
         RCYL2=RCYL1**2
         DSTRH2=DISTRH**2
         ASIDE=4.0*XBEAM*ZBEAM
         PROBSD=1.0
         AINFLU = dble(NCASET)/DSTRH2
      ELSE IF((ISOURC .EQ. 12)) THEN
         RBEAM = RBEAM*0.9999
         XBEAM = XBEAM*0.9999
         ZBEAM = ZBEAM*0.9999
         ZCOFST = 0.5*(ZPLANE(NPLANE)+ZPLANE(1))
         ZSOFST = ZPLANE(1)-DISTZ
         RBEAM2 = RBEAM**2
         RCYL1 = RCYL(NR)
         RCYL2 = RCYL1**2
         DSTRH2 = DISTRH**2
         DISTZ2 = DISTZ**2
         DISTB = DISTZ-(ZPLANE(NPLANE)-ZPLANE(1))
         DISTB2 = DISTB**2
         AFACE = PI*RBEAM2
         ASIDE = 4.0*XBEAM*ZBEAM
         AINFLU = NCASET/(DSTRH2+(ZCOFST-ZSOFST)**2)
         IF ((DISTRH .LE. RCYL(NR))) THEN
            PROBSD = 0
            IF ((DISTZ .GE. 0.0)) THEN
               PROBFC = 1.0
               PROBBK = 0.0
            ELSE IF((DISTZ .LE. (ZPLANE(1)-ZPLANE(NPLANE)))) THEN
               PROBFC = 0.0
               PROBBK = 1.0
            END IF
         ELSE IF(((DISTZ .GE. (ZPLANE(1)-ZPLANE(NPLANE)) .AND. (DISTZ .L
     *   E. 0.0)))) THEN
            PROBFC = 0.0
            PROBBK = 0.0
            PROBSD = 1.0
         ELSE
            COTANG = ZSOFST/DISTRH
            IF ((COTANG .LT. 0.0)) THEN
               FACTOR = AFACE*ABS(COTANG)/ASIDE
               PROBSD = 1.0/(1.0+FACTOR)
               PROBFC = FACTOR/(1.0+FACTOR)
               PROBBK = 0.0
            ELSE
               FACTOR = AFACE*COTANG/ASIDE
               PROBSD = 1.0/(1.0+FACTOR)
               PROBBK = FACTOR/(1.0+FACTOR)
               PROBFC = 0.0
            END IF
         END IF
      ELSE IF((ISOURC .EQ. 15)) THEN
         call src15_oto(iout)
      ELSE IF((ISOURC .EQ. 16)) THEN
         call src16_oto(iout)
      ELSE IF((ISOURC .EQ. 17)) THEN
         XBEAM=XBEAM*0.9999
         YBEAM=YBEAM*0.9999
         DISTZ2=DISTZ**2
         DISTRH=0.0
         ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1))
         ZSOFST=ZPLANE(1)-DISTZ
         AFACE=4.0*XBEAM*YBEAM
         PROBFC=1.0
         AINFLU=FLOAT(NCASET)/DISTZ2
      ELSE IF((ISOURC .EQ. 13)) THEN
         RBEAM=RBEAM*0.9999
         XBEAM=XBEAM*0.9999
         ZBEAM=ZBEAM*0.9999
         RBEAM2=RBEAM**2
         RCYL1=RCYL(NR)
         RCYL2=RCYL1**2
         ZCOFST=0.5*(ZPLANE(1)+ZPLANE(NPLANE))
         AFACE=PI*RBEAM2
         ASIDE=4.0*XBEAM*ZBEAM
         WEIGHT=1.0
         AINFLU=NCASET/(ABS(WINC)*AFACE+SQRT(UINC**2+VINC**2)*ASIDE)
         IF ((WINC.EQ.1.0)) THEN
            PROBFC=1.0
            PROBSD=0.0
            PROBBK=0.0
         ELSE IF((WINC.EQ.0.0)) THEN
            PROBFC=0.0
            PROBSD=1.0
            PROBBK=0.0
         ELSE IF((WINC.EQ.-1.0)) THEN
            PROBFC=0.0
            PROBSD=0.0
            PROBBK=1.0
         ELSE
            IF ((WINC.LT.0.0)) THEN
               FACTOR=AFACE*ABS(WINC)/(ASIDE*SQRT(UINC**2+VINC**2))
               PROBFC=0.0
               PROBSD=1.0/(1.0+FACTOR)
               PROBBK=FACTOR/(1.0+FACTOR)
            ELSE
               FACTOR=AFACE*WINC/(ASIDE*SQRT(UINC**2+VINC**2))
               PROBFC=FACTOR/(1.0+FACTOR)
               PROBSD=1.0/(1.0+FACTOR)
               PROBBK=0.0
            END IF
         END IF
      ELSE IF((ISOURC .EQ. 14)) THEN
         RBEAM=RBEAM*0.9999
         RBEAM2=RBEAM**2
         RMINSQ=RMINBM**2
         DISTZ2=DISTZ**2
         DISTRH=0.0
         ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1))
         ZSOFST=ZPLANE(1)-DISTZ
         AFACE=PI*RBEAM**2
         PROBFC=1.0
         AINFLU=dble(NCASET)/DISTZ2
      ELSE IF((ISOURC .EQ. 20)) THEN
         RCDF(1)=0.5*RDISTF(1)**2*RPDF(1)
         DO 3681 IB=2,NRDIST
            RCDF(IB)=RCDF(IB-1)+0.5*(RDISTF(IB)**2-RDISTF(IB-1)**2)*RPDF
     *      (IB)
3681     CONTINUE
3682     CONTINUE
         FNORM=1./RCDF(NRDIST)
         IBNSOK=0
         GRIDSZ=1./dble(1000)
         DO 3691 IB=1,NRDIST
            RCDF(IB)=FNORM*RCDF(IB)
            IF ((IB.EQ.1)) THEN
               IF((RCDF(1).LT.GRIDSZ))IBNSOK=1
            ELSE IF(((RCDF(IB)-RCDF(IB-1)).LT.GRIDSZ)) THEN
               IBNSOK=1.0
            END IF
3691     CONTINUE
3692     CONTINUE
         IF ((IBNSOK.NE.0)) THEN
            WRITE(6,3700)
3700        FORMAT(///' *******WARNING******'/ T15,'SOME OF NORMALIZED B
     *IN PROBABILITIES SO SMALL BINS MAY BE MISSED'/)
         END IF
         DO 3711 K=1,1000
            AK=dble(K)*GRIDSZ
            DO 3721 I=1,NRDIST
               IRDIST=I
               IF ((AK.LE.RCDF(I))) THEN
                  GOTO 3730
               END IF
3721        CONTINUE
3722        CONTINUE
            WRITE(6,3740)
3740        FORMAT(' *** FELL THROUGH RADIAL SAMPLING ROUTINE *** ')
3730        IF ((IRDIST.NE.1)) THEN
               RCDFIN(K,1)=RDISTF(IRDIST-1)**2
            ELSE
               RCDFIN(K,1)=0.0
            END IF
            RCDFIN(K,2)=RDISTF(IRDIST)**2-RCDFIN(K,1)
3711     CONTINUE
3712     CONTINUE
         IF ((IWATCH.NE.0)) THEN
            WRITE(6,3750)
3750        FORMAT(/' RDISTF,   RPDF,   RCDF:'//)
            WRITE(6,3760)(RDISTF(IB),RPDF(IB),RCDF(IB),IB=1,NRDIST)
3760        FORMAT(3E17.7)
            WRITE(6,3770)
3770        FORMAT(//)
         END IF
         WEIGHT=1.0
         AINFLU=dble(NCASET)/(PI*RDISTF(NRDIST)**2)
      ELSE IF(( ISOURC .EQ. 23 )) THEN
         AINFLU=dble(NCASET)
         WEIGHT=1.0
         IF (( chamber_c .GT. 1e4 .OR. chamber_c .LT. -1e4 )) THEN
            chamber_c = 0.5*(zplane(1) + zplane(nplane))
         END IF
      ELSE IF(((ISOURC .EQ. 21) .OR. (ISOURC .EQ. 22))) THEN
         AINFLU=dble(NCASET)
         WEIGHT=1.0
         IF (( chamber_c .GT. 1e4 .OR. chamber_c .LT. -1e4 )) THEN
            chamber_c = 0.5*(zplane(1) + zplane(nplane))
         END IF
         IF ((IPARALLEL.GT.1 .AND. PARNUM .GT. 0)) THEN
            IF ((IHSTRY.LT.NCASE_PHSP/IPARALLEL)) THEN
               NPHSPN=INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+IHSTRY
            ELSE
               tmp_mod = NCASE_PHSP
               NPHSPN=tmp_mod*(PARNUM-1)/IPARALLEL+ MOD(IHSTRY,tmp_mod/I
     *         PARALLEL)
            END IF
         ELSE
            IF ((IHSTRY.LT.NCASE_PHSP)) THEN
               NPHSPN = IHSTRY
            ELSE
               tmp_mod = NCASE_PHSP
               NPHSPN=MOD(IHSTRY,tmp_mod)
            END IF
         END IF
         IF ((i_iaea_in.EQ.1)) THEN
            iaea_dummy_long=NPHSPN+1
            call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_result)
            IF ((iaea_result.LT.0)) THEN
               WRITE(i_log,*)' Error going to record ',NPHSPN+1,' in IAE
     *A phsp file.'
               call exit(1)
            END IF
         END IF
      END IF
      RETURN
      ENTRY SRCOUT
      WRITE(IOUT,500)
      IF ((ISOURC .EQ. 0)) THEN
         WRITE(IOUT,510) RBEAM,UINC,VINC,WINC,AINFLU
      ELSE IF((ISOURC .EQ. 1)) THEN
         WRITE(IOUT,520) DISTZ,RBEAM,AINFLU
      ELSE IF((ISOURC .EQ. 2)) THEN
         WRITE(IOUT,560)
      ELSE IF((ISOURC .EQ. 3)) THEN
         WRITE(IOUT,570)RMINBM,RBEAM,ZSMIN,ZSMAX
      ELSE IF((ISOURC .EQ. 4)) THEN
         WRITE(IOUT,590) RBEAM
      ELSE IF((ISOURC .EQ. 10)) THEN
         WRITE(IOUT,530)XBEAM,ZBEAM
         IF((((XBEAM/0.9999).LT.RCYL(NR)).OR. ((ZBEAM/0.9999).LT.(0.5*(Z
     *   PLANE(NPLANE)-ZPLANE(1))))))WRITE(IOUT,550)
      ELSE IF((ISOURC .EQ. 11)) THEN
         WRITE(IOUT,540)DISTRH,XBEAM,ZBEAM
         IF(((XBEAM/0.9999.LT.(RCYL(NR)*SQRT(DISTRH**2-RCYL(NR)**2)/DIST
     *   RH)).OR. (ZBEAM/0.9999.LT.(0.5*(ZPLANE(NPLANE)-ZPLANE(1))))))WR
     *   ITE(IOUT,550)
      ELSE IF((ISOURC .EQ. 12)) THEN
         WRITE(IOUT,580)DISTRH,DISTZ
      ELSE IF((ISOURC .EQ. 15)) THEN
         call src15_describe(iout)
      ELSE IF((ISOURC .EQ. 16)) THEN
         call src16_describe(iout)
      ELSE IF((ISOURC .EQ. 17)) THEN
         WRITE(IOUT,535) DISTZ,XBEAM,YBEAM,AINFLU
      ELSE IF((ISOURC .EQ. 13)) THEN
         WRITE(IOUT,585) UINC,VINC,WINC,AINFLU
      ELSE IF((ISOURC .EQ. 14)) THEN
         WRITE(IOUT,525) DISTZ,RMINBM,RBEAM,AINFLU
      ELSE IF((ISOURC .EQ. 20)) THEN
         WRITE(IOUT,595)
         IF ((IOUTSP.EQ.1)) THEN
            WRITE(IOUT,610)NRDIST
            DO 3781 IB=1,NRDIST
               WRITE(IOUT,620)IB,RDISTF(IB),RPDF(IB),RCDF(IB)
3781        CONTINUE
3782        CONTINUE
         END IF
         IF((IBNSOK.NE.0.0))WRITE(IOUT,630)
      ELSE IF((ISOURC .EQ. 21)) THEN
         WRITE(IOUT,640) FILSPC,ZPLANE(1),AINFLU
      ELSE IF((ISOURC .EQ. 22)) THEN
         WRITE(IOUT,677) FILSPC,dist_phsp,theta_phsp,chamber_c, xoffset,
     *   yoffset,AINFLU
      ELSE IF((ISOURC.EQ.23)) THEN
         WRITE(IOUT,679) iqinc,min_weight_23,max_weight_23, the_beam_cod
     *   e(:lnblnk1(the_beam_code)),the_pegs_file(:lnblnk1(the_pegs_file
     *   )), the_input_file(:lnblnk1(the_input_file)), dist_phsp,theta_p
     *   hsp,chamber_c,xoffset,yoffset,EKSRCM
      END IF
      IF ((ISOURC .EQ. 21 .OR. ISOURC .EQ. 22)) THEN
         WRITE(IOUT,3790) NCASE_PHSP,NPHOTPHSP,TEMP2,TEMP3,NINCSRC
3790     FORMAT(T15, ' Total number of particles in file      :',I10/ T1
     *5, ' Total number of photons                :',I10/ T15, ' (the re
     *st are electrons and positrons)'// T15, ' Maximum kinetic energy o
     *f the particles:',F10.3,' MeV'/ T15, ' Minimum kinetic energy of t
     *he electrons:',F10.3,' MeV'/ T15, ' # particles incident when phas
     *e space created :',F12.0/)
         IF ((DOSE_STAT.EQ.1)) THEN
            WRITE(IOUT,'(//'' ***WARNING***''/
     *                     '' Cannot read no. of primary (non-phsp) hist
     *ories from ph-sp source.''/        '' Dose and fluence will be ana
     *lyzed assuming each particle read from''/        '' the ph-sp file
     * is an independent history.  May result in an''/               ''
     *underestimate of uncertainties.''//)')
         END IF
         IF ((IPARALLEL.GT.1)) THEN
            IF ((PARNUM.GE.1 .AND. PARNUM.LE.IPARALLEL)) THEN
               WRITE(IOUT,'(/'' This is one of '',I4,'' parallel jobs.''
     */                                 '' It will use from particle '',
     *I12,'' to particle '',I12,/                     '' from the phase
     *space source in the simulation.''/)') IPARALLEL,INT((PARNUM-1)*NCA
     *         SE_PHSP/IPARALLEL)+1, INT(PARNUM*NCASE_PHSP/IPARALLEL)
            END IF
         END IF
         IF ((NRCYCL.GT.0)) THEN
            WRITE(IOUT,'(/'' Particles will be recycled '',
     *                                I4,'' times before moving on to ne
     *xt one.''/)') NRCYCL
         END IF
      END IF
      RETURN
      ENTRY SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
      IF ((n_parallel.GT.0 .AND. (ISOURC.EQ.21 .OR. ISOURC.EQ.22))) THEN
         IF((N_RUN_CHUNK_OLD.EQ.0))P_PER_PHSP_CHUNK=NCASE_PHSP/(n_parall
     *   el*10)
         N_RUN_CHUNK=(NCASE-N_LEFT)*n_parallel*10/NCASE
         other_num_1=N_RUN_CHUNK*NCASE
         other_num_2=(NCASE-N_LEFT)*n_parallel*10
         IF ((other_num_1.LT.other_num_2)) THEN
            N_RUN_CHUNK=N_RUN_CHUNK+1
         END IF
         IF ((N_RUN_CHUNK .NE. N_RUN_CHUNK_OLD)) THEN
            N_RUN_CHUNK_OLD=N_RUN_CHUNK
            NPHSPN_MIN=(N_RUN_CHUNK-1)*P_PER_PHSP_CHUNK+1
            IF ((N_LEFT.EQ.0)) THEN
               NPHSPN_MAX=NCASE_PHSP
            ELSE
               NPHSPN_MAX=NPHSPN_MIN+P_PER_PHSP_CHUNK-1
            END IF
            NPHSPN=NPHSPN_MIN-1
            IF ((i_iaea_in.EQ.1)) THEN
               iaea_dummy_long=NPHSPN+1
               call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_resul
     *         t)
               IF ((iaea_result.LT.0)) THEN
                  WRITE(i_log,*)' Error going to record ',NPHSPN+1,' in
     *IAEA phsp file.'
                  call exit(1)
               END IF
            END IF
            CYCLNUM=0
            write(6,'(/a/,a,i12,a,i12/,a//)') '      This simulation use
     *s a phase space source.', '      This run will use from particle',
     *      NPHSPN_MIN,' to particle ', NPHSPN_MAX, '      in the source
     * file.'
         END IF
      END IF
      IF (((ISOURC .EQ. 0) .OR. (ISOURC .EQ. 2) .OR.(ISOURC .EQ. 4))) TH
     *EN
         IF ((RBEAM .EQ. 0.0)) THEN
            XIN=0.0
            YIN=0.0
            IRIN=2
         ELSE
3801        CONTINUE
               IF((rng_seed .GT. 128))call ranmar_get
               XIN = rng_array(rng_seed)*twom24
               rng_seed = rng_seed + 1
               XIN=(2.0*XIN-1.0)*RBEAM
               IF((rng_seed .GT. 128))call ranmar_get
               YIN = rng_array(rng_seed)*twom24
               rng_seed = rng_seed + 1
               YIN=(2.0*YIN-1.0)*RBEAM
               R2=XIN**2+YIN**2
               IF((R2.LE.RBEAM2))GO TO3802
            GO TO 3801
3802        CONTINUE
            DO 3811 IX=1,NR
               IXIN=IX
               IF((R2.LE.CYRAD2(IX)))GO TO3812
3811        CONTINUE
3812        CONTINUE
            IRIN=2+(IXIN-1)*NZ
         END IF
         ZIN=ZPLANE(1)
         IF ((IFPB .EQ. 0)) THEN
            UIN=0.0
            VIN=0.0
            WIN=1.0
         ELSE
            UIN=UINC
            VIN=VINC
            WIN=WINC
         END IF
         NRCFLG=10
         WEIGHT=1.0
         NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 1 .OR. ISOURC .EQ. 14)) THEN
3821     CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*RBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            YIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            YIN=(2.0*YIN-1.0)*RBEAM
            R2=XIN**2+YIN**2
            IF((R2.LE.RBEAM2))GO TO3822
         GO TO 3821
3822     CONTINUE
         DO 3831 IX=1,NR
            IXIN=IX
            IF((R2.LE.CYRAD2(IX)))GO TO3832
3831     CONTINUE
3832     CONTINUE
         IRIN=2+(IXIN-1)*NZ
         ZIN=ZPLANE(1)
         IF ((ISOURC.EQ.14 .AND. R2.LE.RMINSQ)) THEN
            WEIGHT=0.0
         ELSE
            IF ((DISTRH.EQ.0.0)) THEN
               D=SQRT(R2+DISTZ**2)
            ELSE
               D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTZ**2)
            END IF
            UIN=XIN/D
            VIN=(YIN-DISTRH)/D
            WIN=DISTZ/D
            NRCFLG=10
            WEIGHT=AFACE*DISTZ/(D**3)/PROBFC
            SCOMEG=SCOMEG+WEIGHT
            SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
         END IF
         NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 3)) THEN
         IF((rng_seed .GT. 128))call ranmar_get
         ZIN = rng_array(rng_seed)*twom24
         rng_seed = rng_seed + 1
         ZIN=ZSOFST+(2.0*ZIN-1.0)*ZBEAM
         DO 3841 IZ=1,NPLANE-1
            IF((ZIN .LE. ZPLANE(IZ+1) .AND. ZIN .GE. ZPLANE(IZ)))GO TO38
     *      42
3841     CONTINUE
3842     CONTINUE
3851     CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*RBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            YIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            YIN=(2.0*YIN-1.0)*RBEAM
            R2=XIN**2+YIN**2
            IF(((R2 .LE. RBEAM2 .AND. R2 .GE. RMINSQ)))GO TO3852
         GO TO 3851
3852     CONTINUE
         DO 3861 IX=1,NR
            IF((R2 .LE. CYRAD2(IX)))GO TO3862
3861     CONTINUE
3862     CONTINUE
         IRIN = IZ + NZ*(IX-1)+1
         IF((rng_seed .GT. 128))call ranmar_get
         COSTHE = rng_array(rng_seed)*twom24
         rng_seed = rng_seed + 1
         COSTHE=2.*COSTHE-1
         SINTHE=SQRT(1.0-COSTHE**2)
         IF((rng_seed .GT. 128))call ranmar_get
         PHI = rng_array(rng_seed)*twom24
         rng_seed = rng_seed + 1
         PHI=TWOPI*PHI
         UIN=SINTHE*COS(PHI)
         VIN=SINTHE*SIN(PHI)
         WIN=COSTHE
         NRCFLG=50
         WEIGHT=1.0
         NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 10)) THEN
         IF((rng_seed .GT. 128))call ranmar_get
         XIN = rng_array(rng_seed)*twom24
         rng_seed = rng_seed + 1
         XIN=(2.0*XIN-1.0)*XBEAM
         IF((rng_seed .GT. 128))call ranmar_get
         ZIN = rng_array(rng_seed)*twom24
         rng_seed = rng_seed + 1
         ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
         YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
         DO 3871 IZ=2,NPLANE
            IZ1=IZ
            IF((ZIN.LE.ZPLANE(IZ)))GO TO3872
3871     CONTINUE
3872     CONTINUE
         IRIN=(NR-1)*NZ+IZ1
         UIN=0.0
         VIN=-1.0
         WIN=0.0
         NRCFLG=20
         WEIGHT=1.0
         NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 11)) THEN
         IF((rng_seed .GT. 128))call ranmar_get
         XIN = rng_array(rng_seed)*twom24
         rng_seed = rng_seed + 1
         XIN=(2.0*XIN-1.0)*XBEAM
         IF((rng_seed .GT. 128))call ranmar_get
         ZIN = rng_array(rng_seed)*twom24
         rng_seed = rng_seed + 1
         ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
         YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
         DO 3881 IZ=2,NPLANE
            IZ1=IZ
            IF((ZIN.LE.ZPLANE(IZ)))GO TO3882
3881     CONTINUE
3882     CONTINUE
         IRIN=(NR-1)*NZ+IZ1
         D=SQRT(RCYL2+DSTRH2-2.0*DISTRH*YIN+(ZIN-ZSOFST)**2)
         UIN=XIN/D
         VIN=(YIN-DISTRH)/D
         WIN=(ZIN-ZSOFST)/D
         WEIGHT=ASIDE*(DISTRH-RCYL2/YIN)/(D**3)/PROBSD
         SCOMEG=SCOMEG+WEIGHT
         SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
         NRCFLG=20
         NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 12)) THEN
         IF ((PROBFC.EQ.1.0)) THEN
3891        CONTINUE
               IF((rng_seed .GT. 128))call ranmar_get
               XIN = rng_array(rng_seed)*twom24
               rng_seed = rng_seed + 1
               XIN=(2.0*XIN-1.0)*RBEAM
               IF((rng_seed .GT. 128))call ranmar_get
               YIN = rng_array(rng_seed)*twom24
               rng_seed = rng_seed + 1
               YIN=(2.0*YIN-1.0)*RBEAM
               R2=XIN**2+YIN**2
               IF((R2.LE.RBEAM2))GO TO3892
            GO TO 3891
3892        CONTINUE
            DO 3901 IX=1,NR
               IXIN=IX
               IF((R2.LE.CYRAD2(IX)))GO TO3902
3901        CONTINUE
3902        CONTINUE
            IRIN=2+(IXIN-1)*NZ
            ZIN=ZPLANE(1)
            IF ((ISOURC.EQ.14 .AND. R2.LE.RMINSQ)) THEN
               WEIGHT=0.0
            ELSE
               IF ((DISTRH.EQ.0.0)) THEN
                  D=SQRT(R2+DISTZ**2)
               ELSE
                  D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTZ**2)
               END IF
               UIN=XIN/D
               VIN=(YIN-DISTRH)/D
               WIN=DISTZ/D
               NRCFLG=10
               WEIGHT=AFACE*DISTZ/(D**3)/PROBFC
               SCOMEG=SCOMEG+WEIGHT
               SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
            END IF
         ELSE IF((PROBBK.EQ.1.0)) THEN
3911        CONTINUE
               IF((rng_seed .GT. 128))call ranmar_get
               XIN = rng_array(rng_seed)*twom24
               rng_seed = rng_seed + 1
               XIN=(2.0*XIN-1.0)*RBEAM
               IF((rng_seed .GT. 128))call ranmar_get
               YIN = rng_array(rng_seed)*twom24
               rng_seed = rng_seed + 1
               YIN=(2.0*YIN-1.0)*RBEAM
               R2=XIN**2+YIN**2
               IF((R2.LE.RBEAM2))GO TO3912
            GO TO 3911
3912        CONTINUE
            DO 3921 IX=1,NR
               IXIN=IX
               IF((R2.LE.CYRAD2(IX)))GO TO3922
3921        CONTINUE
3922        CONTINUE
            IRIN=1+IXIN*NZ
            ZIN=ZPLANE(NPLANE)
            IF ((DISTRH.EQ.0.0)) THEN
               D=SQRT(R2+DISTB2)
            ELSE
               D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTB2)
            END IF
            UIN=XIN/D
            VIN=(YIN-DISTRH)/D
            WIN=-DISTB/D
            NRCFLG=30
            WEIGHT=AFACE*DISTB/(D**3)/PROBBK
            SCOMEG=SCOMEG+WEIGHT
            SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
         ELSE IF((PROBSD.EQ.1.0)) THEN
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*XBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            ZIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
            YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
            DO 3931 IZ=2,NPLANE
               IZ1=IZ
               IF((ZIN.LE.ZPLANE(IZ)))GO TO3932
3931        CONTINUE
3932        CONTINUE
            IRIN=(NR-1)*NZ+IZ1
            D=SQRT(RCYL2+DSTRH2-2.0*DISTRH*YIN+(ZIN-ZSOFST)**2)
            UIN=XIN/D
            VIN=(YIN-DISTRH)/D
            WIN=(ZIN-ZSOFST)/D
            WEIGHT=ASIDE*(DISTRH-RCYL2/YIN)/(D**3)/PROBSD
            SCOMEG=SCOMEG+WEIGHT
            SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
            NRCFLG=20
         ELSE
            IF((rng_seed .GT. 128))call ranmar_get
            WHICH = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF ((WHICH.LE.PROBSD)) THEN
               IF((rng_seed .GT. 128))call ranmar_get
               XIN = rng_array(rng_seed)*twom24
               rng_seed = rng_seed + 1
               XIN=(2.0*XIN-1.0)*XBEAM
               IF((rng_seed .GT. 128))call ranmar_get
               ZIN = rng_array(rng_seed)*twom24
               rng_seed = rng_seed + 1
               ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
               YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
               DO 3941 IZ=2,NPLANE
                  IZ1=IZ
                  IF((ZIN.LE.ZPLANE(IZ)))GO TO3942
3941           CONTINUE
3942           CONTINUE
               IRIN=(NR-1)*NZ+IZ1
               D=SQRT(RCYL2+DSTRH2-2.0*DISTRH*YIN+(ZIN-ZSOFST)**2)
               UIN=XIN/D
               VIN=(YIN-DISTRH)/D
               WIN=(ZIN-ZSOFST)/D
               WEIGHT=ASIDE*(DISTRH-RCYL2/YIN)/(D**3)/PROBSD
               SCOMEG=SCOMEG+WEIGHT
               SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
               NRCFLG=20
            ELSE IF((WHICH.LE.(PROBSD+PROBFC))) THEN
3951           CONTINUE
                  IF((rng_seed .GT. 128))call ranmar_get
                  XIN = rng_array(rng_seed)*twom24
                  rng_seed = rng_seed + 1
                  XIN=(2.0*XIN-1.0)*RBEAM
                  IF((rng_seed .GT. 128))call ranmar_get
                  YIN = rng_array(rng_seed)*twom24
                  rng_seed = rng_seed + 1
                  YIN=(2.0*YIN-1.0)*RBEAM
                  R2=XIN**2+YIN**2
                  IF((R2.LE.RBEAM2))GO TO3952
               GO TO 3951
3952           CONTINUE
               DO 3961 IX=1,NR
                  IXIN=IX
                  IF((R2.LE.CYRAD2(IX)))GO TO3962
3961           CONTINUE
3962           CONTINUE
               IRIN=2+(IXIN-1)*NZ
               ZIN=ZPLANE(1)
               IF ((ISOURC.EQ.14 .AND. R2.LE.RMINSQ)) THEN
                  WEIGHT=0.0
               ELSE
                  IF ((DISTRH.EQ.0.0)) THEN
                     D=SQRT(R2+DISTZ**2)
                  ELSE
                     D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTZ**2)
                  END IF
                  UIN=XIN/D
                  VIN=(YIN-DISTRH)/D
                  WIN=DISTZ/D
                  NRCFLG=10
                  WEIGHT=AFACE*DISTZ/(D**3)/PROBFC
                  SCOMEG=SCOMEG+WEIGHT
                  SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
               END IF
            ELSE
3971           CONTINUE
                  IF((rng_seed .GT. 128))call ranmar_get
                  XIN = rng_array(rng_seed)*twom24
                  rng_seed = rng_seed + 1
                  XIN=(2.0*XIN-1.0)*RBEAM
                  IF((rng_seed .GT. 128))call ranmar_get
                  YIN = rng_array(rng_seed)*twom24
                  rng_seed = rng_seed + 1
                  YIN=(2.0*YIN-1.0)*RBEAM
                  R2=XIN**2+YIN**2
                  IF((R2.LE.RBEAM2))GO TO3972
               GO TO 3971
3972           CONTINUE
               DO 3981 IX=1,NR
                  IXIN=IX
                  IF((R2.LE.CYRAD2(IX)))GO TO3982
3981           CONTINUE
3982           CONTINUE
               IRIN=1+IXIN*NZ
               ZIN=ZPLANE(NPLANE)
               IF ((DISTRH.EQ.0.0)) THEN
                  D=SQRT(R2+DISTB2)
               ELSE
                  D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTB2)
               END IF
               UIN=XIN/D
               VIN=(YIN-DISTRH)/D
               WIN=-DISTB/D
               NRCFLG=30
               WEIGHT=AFACE*DISTB/(D**3)/PROBBK
               SCOMEG=SCOMEG+WEIGHT
               SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
            END IF
         END IF
         NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 15)) THEN
         call src15_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
         NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 16)) THEN
         call src16_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
         NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 17)) THEN
         IF((rng_seed .GT. 128))call ranmar_get
         XIN = rng_array(rng_seed)*twom24
         rng_seed = rng_seed + 1
         XIN=(2.0*XIN-1.0)*XBEAM
         IF((rng_seed .GT. 128))call ranmar_get
         YIN = rng_array(rng_seed)*twom24
         rng_seed = rng_seed + 1
         YIN=(2.0*YIN-1.0)*YBEAM
         R2=XIN**2+YIN**2
         DO 3991 IX=1,NR
            IXIN=IX
            IF((R2.LE.CYRAD2(IX)))GO TO3992
3991     CONTINUE
3992     CONTINUE
         IRIN=2+(IXIN-1)*NZ
         ZIN=ZPLANE(1)
         IF ((DISTRH.EQ.0.0)) THEN
            D=SQRT(R2+DISTZ**2)
         ELSE
            D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTZ**2)
         END IF
         UIN=XIN/D
         VIN=(YIN-DISTRH)/D
         WIN=DISTZ/D
         NRCFLG=10
         WEIGHT=AFACE*DISTZ/(D**3)/PROBFC
         SCOMEG=SCOMEG+WEIGHT
         SCOMEG2=SCOMEG2+WEIGHT*WEIGHT
         NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 13)) THEN
         UIN=UINC
         VIN=VINC
         WIN=WINC
         IF ((PROBFC.EQ.1.0)) THEN
4001        CONTINUE
               IF((rng_seed .GT. 128))call ranmar_get
               XIN = rng_array(rng_seed)*twom24
               rng_seed = rng_seed + 1
               XIN=(2.0*XIN-1.0)*RBEAM
               IF((rng_seed .GT. 128))call ranmar_get
               YIN = rng_array(rng_seed)*twom24
               rng_seed = rng_seed + 1
               YIN=(2.0*YIN-1.0)*RBEAM
               R2=XIN**2+YIN**2
               IF((R2.LE.RBEAM2))GO TO4002
            GO TO 4001
4002        CONTINUE
            DO 4011 IX=1,NR
               IXIN=IX
               IF((R2.LE.CYRAD2(IX)))GO TO4012
4011        CONTINUE
4012        CONTINUE
            IRIN=2+(IXIN-1)*NZ
            ZIN=ZPLANE(1)
            NRCFLG=10
         ELSE IF((PROBBK.EQ.1.0)) THEN
4021        CONTINUE
               IF((rng_seed .GT. 128))call ranmar_get
               XIN = rng_array(rng_seed)*twom24
               rng_seed = rng_seed + 1
               XIN=(2.0*XIN-1.0)*RBEAM
               IF((rng_seed .GT. 128))call ranmar_get
               YIN = rng_array(rng_seed)*twom24
               rng_seed = rng_seed + 1
               YIN=(2.0*YIN-1.0)*RBEAM
               R2=XIN**2+YIN**2
               IF((R2.LE.RBEAM2))GO TO4022
            GO TO 4021
4022        CONTINUE
            DO 4031 IX=1,NR
               IXIN=IX
               IF((R2.LE.CYRAD2(IX)))GO TO4032
4031        CONTINUE
4032        CONTINUE
            IRIN=1+IXIN*NZ
            ZIN=ZPLANE(NPLANE)
            NRCFLG=30
         ELSE IF((PROBSD.EQ.1.0)) THEN
            IF((rng_seed .GT. 128))call ranmar_get
            XIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            XIN=(2.0*XIN-1.0)*XBEAM
            IF((rng_seed .GT. 128))call ranmar_get
            ZIN = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
            YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
            DO 4041 IZ=2,NPLANE
               IZ1=IZ
               IF((ZIN.LE.ZPLANE(IZ)))GO TO4042
4041        CONTINUE
4042        CONTINUE
            IRIN=(NR-1)*NZ+IZ1
            NRCFLG=20
         ELSE
            IF((rng_seed .GT. 128))call ranmar_get
            WHICH = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF ((WHICH.LE.PROBSD)) THEN
               IF((rng_seed .GT. 128))call ranmar_get
               XIN = rng_array(rng_seed)*twom24
               rng_seed = rng_seed + 1
               XIN=(2.0*XIN-1.0)*XBEAM
               IF((rng_seed .GT. 128))call ranmar_get
               ZIN = rng_array(rng_seed)*twom24
               rng_seed = rng_seed + 1
               ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST
               YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN))
               DO 4051 IZ=2,NPLANE
                  IZ1=IZ
                  IF((ZIN.LE.ZPLANE(IZ)))GO TO4052
4051           CONTINUE
4052           CONTINUE
               IRIN=(NR-1)*NZ+IZ1
               NRCFLG=20
            ELSE IF((WHICH.LE.(PROBSD+PROBFC))) THEN
4061           CONTINUE
                  IF((rng_seed .GT. 128))call ranmar_get
                  XIN = rng_array(rng_seed)*twom24
                  rng_seed = rng_seed + 1
                  XIN=(2.0*XIN-1.0)*RBEAM
                  IF((rng_seed .GT. 128))call ranmar_get
                  YIN = rng_array(rng_seed)*twom24
                  rng_seed = rng_seed + 1
                  YIN=(2.0*YIN-1.0)*RBEAM
                  R2=XIN**2+YIN**2
                  IF((R2.LE.RBEAM2))GO TO4062
               GO TO 4061
4062           CONTINUE
               DO 4071 IX=1,NR
                  IXIN=IX
                  IF((R2.LE.CYRAD2(IX)))GO TO4072
4071           CONTINUE
4072           CONTINUE
               IRIN=2+(IXIN-1)*NZ
               ZIN=ZPLANE(1)
               NRCFLG=10
            ELSE
4081           CONTINUE
                  IF((rng_seed .GT. 128))call ranmar_get
                  XIN = rng_array(rng_seed)*twom24
                  rng_seed = rng_seed + 1
                  XIN=(2.0*XIN-1.0)*RBEAM
                  IF((rng_seed .GT. 128))call ranmar_get
                  YIN = rng_array(rng_seed)*twom24
                  rng_seed = rng_seed + 1
                  YIN=(2.0*YIN-1.0)*RBEAM
                  R2=XIN**2+YIN**2
                  IF((R2.LE.RBEAM2))GO TO4082
               GO TO 4081
4082           CONTINUE
               DO 4091 IX=1,NR
                  IXIN=IX
                  IF((R2.LE.CYRAD2(IX)))GO TO4092
4091           CONTINUE
4092           CONTINUE
               IRIN=1+IXIN*NZ
               ZIN=ZPLANE(NPLANE)
               NRCFLG=30
            END IF
         END IF
         WEIGHT=1.0
         NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 20)) THEN
         IF((rng_seed .GT. 128))call ranmar_get
         RNNO1 = rng_array(rng_seed)*twom24
         rng_seed = rng_seed + 1
         IF((rng_seed .GT. 128))call ranmar_get
         RNNO2 = rng_array(rng_seed)*twom24
         rng_seed = rng_seed + 1
         K=MIN(dble(1000)*RNNO1+1.,dble(1000))
         XIN=SQRT(RCDFIN(K,1)+RNNO2*RCDFIN(K,2))
         YIN=0.0
         ZIN=ZPLANE(1)
         DO 4101 IX=1,NR
            IXIN=IX
            IF((XIN.LE.RCYL(IX)))GO TO4102
4101     CONTINUE
4102     CONTINUE
         IRIN=2+(IXIN-1)*NZ
         WIN=1.0
         UIN=0.0
         VIN=0.0
         NRCFLG=10
         WEIGHT=1.0
         NHSTRY=NHSTRY+1
      ELSE IF((ISOURC .EQ. 21)) THEN
         IF ((NRCYCL.GT.0 .AND. CYCLNUM.GT.0 .AND. CYCLNUM.LE.NRCYCL)) T
     *   HEN
            CYCLNUM=CYCLNUM+1
            XIN=XINOLD
            YIN=YINOLD
            ZIN=ZINOLD
            UIN=UINOLD
            VIN=VINOLD
            WIN=WINOLD
            IRIN=IRINOLD
            NRCFLG=NRCFLGOLD
            WEIGHT=WEIGHTOLD
            NNREAD=NNREAD+1
         ELSE
4110        CONTINUE
            NPHSPN=NPHSPN+1
            IF ((IPARALLEL.GT.1 .AND. PARNUM.GT.0 .AND. NPHSPN .GT. INT(
     *      PARNUM*NCASE_PHSP/IPARALLEL))) THEN
               NPHSPN=INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+1
               OUTCNT=OUTCNT+1
               WRITE(6,4120)
4120           FORMAT(' ***WARNING*** Used all particles from partitioni
     *n source file.'/ '               Restarting from first particle in
     * partition.')
               WRITE(IOUT, '('' ***WARNING*** Used all particles from pa
     *rtition in source file.''/           ''               Restarting f
     *rom first particle in partition.'')')
               IF ((i_iaea_in.EQ.1)) THEN
                  NHSTRY=OUTCNT*NINCSRC/IPARALLEL
                  iaea_dummy_long=NPHSPN
                  call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_re
     *            sult)
                  IF ((iaea_result.LT.0)) THEN
                     WRITE(i_log,*)' Error going to record ',NPHSPN,' in
     * IAEA phsp file.'
                     call exit(1)
                  END IF
               END IF
            ELSE IF((n_parallel.GT.0 .AND. NPHSPN.GT.NPHSPN_MAX)) THEN
               NPHSPN=NPHSPN_MIN
               OUTCNT=OUTCNT+1
               WRITE(6,4130)
4130           FORMAT(///' ***WARNING*** USED ALL PARTICLES FROM CHUNK I
     *N SOURCE FILE!'/ '               RESTARTING FROM FIRST PARTICLE IN
     * THIS CHUNK.'// /1x,79('*')//)
               IF ((i_iaea_in.EQ.1)) THEN
                  NHSTRY=OUTCNT*NINCSRC/(n_parallel*10)
                  iaea_dummy_long=NPHSPN
                  call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_re
     *            sult)
                  IF ((iaea_result.LT.0)) THEN
                     WRITE(i_log,*)' Error going to record ',NPHSPN,' in
     * IAEA phsp file.'
                     call exit(1)
                  END IF
               END IF
            ELSE IF((NPHSPN.GT.NCASE_PHSP)) THEN
               NPHSPN=1
               OUTCNT=OUTCNT+1
               WRITE(6,4140)
4140           FORMAT(' ***WARNING*** Used all particles from source fil
     *e.'/ '               Restarting from first particle.')
               WRITE(IOUT, '('' ***WARNING*** Used all particles from so
     *urce file.''/                        ''               Restarting f
     *rom first particle.'')')
               IF ((i_iaea_in.EQ.1)) THEN
                  NHSTRY=OUTCNT*NINCSRC
                  iaea_dummy_long=NPHSPN
                  call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_re
     *            sult)
                  IF ((iaea_result.LT.0)) THEN
                     WRITE(i_log,*)' Error going to record ',NPHSPN,' in
     * IAEA phsp file.'
                     call exit(1)
                  END IF
               END IF
            END IF
            IF ((OUTCNT.GT.1000)) THEN
               WRITE(6,4150)
4150           FORMAT(' ***ERROR*** >1000 restart warnings.')
               WRITE(IOUT, '('' ***ERROR*** >1000 restart warnings.'')')
               STOP
            END IF
            IF ((i_iaea_in.EQ.1)) THEN
               NPASS=0
               call iaea_get_particle(i_unit_in,iaea_n_stat,iaea_q_index
     *         ,ESHORT,WT_PHSP_SHORT, X_PHSP_SHORT,Y_PHSP_SHORT,Z_PHSP_S
     *         HORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,iaea_extra_f
     *         loats,iaea_extra_ints)
               IF ((iaea_n_stat.EQ.-1)) THEN
                  WRITE(i_log,*)' Error getting particle data from IAEA
     *phsp file.'
                  call exit(1)
               ELSE IF((iaea_n_stat.EQ.-2)) THEN
                  WRITE(i_log,*)' WARNING: Reached end of IAEA phsp file
     *.  File restarted.'
               ELSE IF((iaea_n_stat.GE.0)) THEN
                  NHSTRY=NHSTRY+iaea_n_stat
                  IF ((iaea_i_latch.EQ.-99)) THEN
                     LATCHI=0
                  ELSE
                     LATCHI=iaea_extra_ints(iaea_i_latch)
                  END IF
                  IQIN=iaea_typ_q(iaea_q_index)
                  IF (( (IQIN.EQ.1) .OR. (IQIN.EQ.-1) )) THEN
                     ESHORT = ESHORT + 0.5109989461
                  END IF
                  EIN=ESHORT
                  IF ((iaea_i_zlast.EQ.-99)) THEN
                     ZLAST_PHSP_SHORT=0
                  ELSE
                     ZLAST_PHSP_SHORT= iaea_extra_floats(iaea_i_zlast)
                  END IF
                  IF ((iaea_i_muidx.EQ.-99)) THEN
                     MUIDX_PHSP_SHORT=0
                  ELSE
                     MUIDX_PHSP_SHORT= iaea_extra_floats(iaea_i_muidx)
                  END IF
                  WEIGHT=WT_PHSP_SHORT
                  XIN=X_PHSP_SHORT
                  YIN=Y_PHSP_SHORT
                  ZIN=Z_PHSP_SHORT
                  UIN=U_PHSP_SHORT
                  VIN=V_PHSP_SHORT
                  WIN=W_PHSP_SHORT
                  ZLAST=ZLAST_PHSP_SHORT
                  MUIDX=MUIDX_PHSP_SHORT
               END IF
            ELSE
               IF ((IMODE.NE.0)) THEN
                  READ(42,REC=NPHSPN+1,IOSTAT=IERR_PHSP) LATCHI,ESHORT,X
     *            _PHSP_SHORT,Y_PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT
     *            _PHSP_SHORT,ZLAST_PHSP_SHORT
               ELSE
                  READ(42,REC=NPHSPN+1,IOSTAT=IERR_PHSP) LATCHI,ESHORT,X
     *            _PHSP_SHORT,Y_PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT
     *            _PHSP_SHORT
               END IF
               IF ((NPHSPN+1.EQ.76695869)) THEN
                  write(*,*)' x,y,u,v,wt,eshort,latch', X_PHSP_SHORT,Y_P
     *            HSP_SHORT,U_PHSP_SHORT,V_PHSP_SHORT, WT_PHSP_SHORT,ESH
     *            ORT,LATCHI
               END IF
               IF ((ESHORT.LT.0.0)) THEN
                  NHSTRY=NHSTRY+1
                  ESHORT=ABS(ESHORT)
               END IF
               EIN=ESHORT
               WEIGHT=WT_PHSP_SHORT
               XIN=X_PHSP_SHORT
               YIN=Y_PHSP_SHORT
               UIN=U_PHSP_SHORT
               VIN=V_PHSP_SHORT
               IF((IMODE.NE.0))ZLAST=ZLAST_PHSP_SHORT
               IF ((IERR_PHSP.EQ.0)) THEN
                  EIN=ESHORT
                  IF ((btest(LATCHI, 31))) THEN
                     NPASS = 1
                     LATCHI = ibclr(LATCHI,31)
                  ELSE
                     NPASS = 0
                  END IF
                  IF ((btest(LATCHI, 30))) THEN
                     IQIN = -1
                     LATCHI = ibclr(LATCHI,30)
                     LATCHI = ibclr(LATCHI,29)
                  ELSE
                     IF ((btest(LATCHI, 29))) THEN
                        IQIN = 1
                        LATCHI = ibclr(LATCHI,29)
                     ELSE
                        IQIN = 0
                     END IF
                  END IF
                  WIN = min( 1., UIN**2 + VIN**2)
                  WIN = sqrt(1. - WIN)
                  WIN = SIGN(WIN,WEIGHT)
                  WEIGHT=ABS(WEIGHT)
               END IF
            END IF
            NNREAD=NNREAD+1
            IF((DOSE_STAT.EQ.1 .OR. NHSTRY.EQ.0))NHSTRY=NHSTRY+1
            IF((NPASS.EQ.1))GOTO 4110
            IF ((IQIN .EQ.-1 .AND. IQINC.NE.-1 .AND. IQINC.NE.2 .AND. IQ
     *      INC .NE.3)) THEN
               GOTO 4110
            END IF
            IF ((IQIN .EQ. 1 .AND. IQINC.NE. 1 .AND. IQINC.NE.2 .AND. IQ
     *      INC .NE.3)) THEN
               GOTO 4110
            END IF
            IF ((IQIN .EQ. 0 .AND. IQINC.NE. 0 .AND. IQINC.NE.2)) THEN
               GOTO 4110
            END IF
            R2 = XIN**2 +YIN**2
            IF ((R2 .GT. CYRAD2(NR))) THEN
               GOTO 4110
            END IF
            DO 4161 IX=1,NR
               IXIN=IX
               IF((R2 .LE. CYRAD2(IX)))GO TO4162
4161        CONTINUE
4162        CONTINUE
            IRIN=2+(IXIN-1)*NZ
            ZIN=ZPLANE(1)
            NRCFLG = 10
            IF ((NRCYCL.GT.0)) THEN
               CYCLNUM=1
               XINOLD=XIN
               YINOLD=YIN
               ZINOLD=ZIN
               UINOLD=UIN
               VINOLD=VIN
               WINOLD=WIN
               IRINOLD=IRIN
               NRCFLGOLD=NRCFLG
               WEIGHTOLD=WEIGHT
            END IF
         END IF
      ELSE IF(( ISOURC .EQ. 23 )) THEN
4171     CONTINUE
4180        CONTINUE
            call sample_beamsource(ein,xin,yin,zin,uin,vin,win,weight,iq
     *      in,latchi, nhstry,iphatin)
            IF((iqinc .LT. 2 .AND. iqin .NE. iqinc))goto 4180
            IF((iqinc .EQ. 3 .AND. iqin .EQ. 0))goto 4180
            IF (( weight .LT. min_weight_23 .OR. weight .GT. max_weight_
     *      23 )) THEN
               goto 4180
            END IF
            IF (( secret_option_23 .EQ. 1 )) THEN
               IF (( xin .GT. 0 )) THEN
                  xin = -xin
                  uin = -uin
               END IF
            END IF
            xin_tmp = xin
            yin_tmp = yin
            zin_tmp = zin
            xin=xin+xoffset
            yin=yin+yoffset
            zin = -dist_phsp*cost_phsp + yin*sint_phsp + chamber_c
            yin = dist_phsp*sint_phsp + yin*cost_phsp
            vtemp = vin
            vin = -win*sint_phsp + vin*cost_phsp
            win = win*cost_phsp + vtemp*sint_phsp
            radp = xin*xin + yin*yin
            IF (( radp .GT. CYRAD2(nr) .OR. zin .LT. zplane(1) .OR. zin
     *      .GT. zplane(nz+1) )) THEN
               check = .true.
               IF (( zin .LT. zplane(1) .AND. win .GT. 0 )) THEN
                  tf = (zplane(1)-zin)/win
               ELSE IF(( zin .GT. zplane(nz+1) .AND. win .LT. 0 )) THEN
                  tf = (zplane(nz+1) - zin)/win
               ELSE
                  check = .false.
               END IF
               IF (( check )) THEN
                  xtmp = xin + uin*tf
                  ytmp = yin + vin*tf
                  radp = xtmp*xtmp + ytmp*ytmp
                  IF (( radp .LE. CYRAD2(nr) )) THEN
                     xin = xtmp
                     yin = ytmp
                     IF (( zin .LT. zplane(1) )) THEN
                        zin = zplane(1)
                        iz = 1
                     ELSE
                        zin = zplane(nz+1)
                        iz = nz
                     END IF
                     DO 4191 ix=1,nr
                        IF((radp .LE. CYRAD2(ix)))GO TO4192
4191                 CONTINUE
4192                 CONTINUE
                     GO TO4172
                  END IF
                  radp = xin*xin + yin*yin
               END IF
               IF((radp .LT. CYRAD2(nr)))GO TO4171
               phbb = uin*uin + vin*vin
               IF((phbb .LT. 1e-15))GO TO4171
               pha = (xin*uin + yin*vin)/phbb
               IF((pha .GT. 0))GO TO4171
               phb = (radp - CYRAD2(nr))/phbb
               phd = pha*pha - phb
               IF((phd .LT. 0))GO TO4171
               tf = -pha-sqrt(phd)
               IF((tf .LT. 0))GO TO4171
               zin = zin + tf*win
               IF((zin .LT. zplane(1) .OR. zin .GT. zplane(nz+1)))GO TO4
     *         171
               ix = nr
               xin = xin + uin*tf
               yin = yin + vin*tf
               DO 4201 iz=2,nplane
                  IF((zin .LE. zplane(iz)))GO TO4202
4201           CONTINUE
4202           CONTINUE
               iz = iz-1
               GO TO4172
            ELSE
               DO 4211 iz=2,nplane
                  IF((zin .LE. zplane(iz)))GO TO4212
4211           CONTINUE
4212           CONTINUE
               iz = iz-1
               DO 4221 ix=1,nr
                  IF((radp .LE. CYRAD2(ix)))GO TO4222
4221           CONTINUE
4222           CONTINUE
               GO TO4172
            END IF
         GO TO 4171
4172     CONTINUE
         irin = 1 + (ix-1)*nz + iz
         ihstry = ihstry + nhstry - last_nhstry
         last_nhstry = nhstry
      ELSE IF((ISOURC .EQ. 22)) THEN
         IF ((NRCYCL.GT.0 .AND. CYCLNUM.GT.0 .AND. CYCLNUM.LE.NRCYCL)) T
     *   HEN
            CYCLNUM=CYCLNUM+1
            XIN=XINOLD
            YIN=YINOLD
            ZIN=ZINOLD
            UIN=UINOLD
            VIN=VINOLD
            WIN=WINOLD
            IRIN=IRINOLD
            NRCFLG=NRCFLGOLD
            WEIGHT=WEIGHTOLD
            NNREAD=NNREAD+1
         ELSE
4230        CONTINUE
            NPHSPN=NPHSPN+1
            IF ((IPARALLEL.GT.1 .AND. PARNUM.GT.0 .AND. NPHSPN .GT. INT(
     *      PARNUM*NCASE_PHSP/IPARALLEL))) THEN
               NPHSPN=INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+1
               OUTCNT=OUTCNT+1
               WRITE(6,4240)
4240           FORMAT(' ***WARNING*** Used all particles from partitioni
     *n source file.'/ '               Restarting from first particle in
     * partition.')
               WRITE(IOUT, '('' ***WARNING*** Used all particles from pa
     *rtition in source file.''/           ''               Restarting f
     *rom first particle in partition.'')')
               IF ((i_iaea_in.EQ.1)) THEN
                  NHSTRY=OUTCNT*NINCSRC/IPARALLEL
                  iaea_dummy_long=NPHSPN
                  call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_re
     *            sult)
                  IF ((iaea_result.LT.0)) THEN
                     WRITE(i_log,*)' Error going to record ',NPHSPN,' in
     * IAEA phsp file.'
                     call exit(1)
                  END IF
               END IF
            ELSE IF((n_parallel.GT.0 .AND. NPHSPN.GT.NPHSPN_MAX)) THEN
               NPHSPN=NPHSPN_MIN
               OUTCNT=OUTCNT+1
               WRITE(6,4250)
4250           FORMAT(///' ***WARNING*** USED ALL PARTICLES FROM CHUNK I
     *N SOURCE FILE!'/ '               RESTARTING FROM FIRST PARTICLE IN
     * THIS CHUNK.'// /1x,79('*')//)
               IF ((i_iaea_in.EQ.1)) THEN
                  NHSTRY=OUTCNT*NINCSRC/(n_parallel*10)
                  iaea_dummy_long=NPHSPN
                  call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_re
     *            sult)
                  IF ((iaea_result.LT.0)) THEN
                     WRITE(i_log,*)' Error going to record ',NPHSPN,' in
     * IAEA phsp file.'
                     call exit(1)
                  END IF
               END IF
            ELSE IF((NPHSPN.GT.NCASE_PHSP)) THEN
               NPHSPN=1
               OUTCNT=OUTCNT+1
               WRITE(6,4260)
4260           FORMAT(' ***WARNING*** Used all particles from source fil
     *e.'/ '               Restarting from first particle.')
               WRITE(IOUT, '('' ***WARNING*** Used all particles from so
     *urce file.''/                        ''               Restarting f
     *rom first particle.'')')
               IF ((i_iaea_in.EQ.1)) THEN
                  NHSTRY=OUTCNT*NINCSRC
                  iaea_dummy_long=NPHSPN
                  call iaea_set_record(i_unit_in,iaea_dummy_long,iaea_re
     *            sult)
                  IF ((iaea_result.LT.0)) THEN
                     WRITE(i_log,*)' Error going to record ',NPHSPN,' in
     * IAEA phsp file.'
                     call exit(1)
                  END IF
               END IF
            END IF
            IF ((OUTCNT.GT.1000)) THEN
               WRITE(6,4270)
4270           FORMAT(' ***ERROR*** >1000 restart warnings.')
               WRITE(IOUT, '('' ***ERROR*** >1000 restart warnings.'')')
               STOP
            END IF
            IF ((i_iaea_in.EQ.1)) THEN
               NPASS=0
               call iaea_get_particle(i_unit_in,iaea_n_stat,iaea_q_index
     *         ,ESHORT,WT_PHSP_SHORT, X_PHSP_SHORT,Y_PHSP_SHORT,Z_PHSP_S
     *         HORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,iaea_extra_f
     *         loats,iaea_extra_ints)
               IF ((iaea_n_stat.EQ.-1)) THEN
                  WRITE(i_log,*)' Error getting particle data from IAEA
     *phsp file.'
                  call exit(1)
               ELSE IF((iaea_n_stat.EQ.-2)) THEN
                  WRITE(i_log,*)' WARNING: Reached end of IAEA phsp file
     *.  File restarted.'
               ELSE IF((iaea_n_stat.GE.0)) THEN
                  NHSTRY=NHSTRY+iaea_n_stat
                  IF ((iaea_i_latch.EQ.-99)) THEN
                     LATCHI=0
                  ELSE
                     LATCHI=iaea_extra_ints(iaea_i_latch)
                  END IF
                  IQIN=iaea_typ_q(iaea_q_index)
                  IF (( (IQIN.EQ.1) .OR. (IQIN.EQ.-1) )) THEN
                     ESHORT = ESHORT + 0.5109989461
                  END IF
                  EIN=ESHORT
                  IF ((iaea_i_zlast.EQ.-99)) THEN
                     ZLAST_PHSP_SHORT=0
                  ELSE
                     ZLAST_PHSP_SHORT= iaea_extra_floats(iaea_i_zlast)
                  END IF
                  IF ((iaea_i_muidx.EQ.-99)) THEN
                     MUIDX_PHSP_SHORT=0
                  ELSE
                     MUIDX_PHSP_SHORT= iaea_extra_floats(iaea_i_muidx)
                  END IF
                  WEIGHT=WT_PHSP_SHORT
                  XIN=X_PHSP_SHORT
                  YIN=Y_PHSP_SHORT
                  ZIN=Z_PHSP_SHORT
                  UIN=U_PHSP_SHORT
                  VIN=V_PHSP_SHORT
                  WIN=W_PHSP_SHORT
                  ZLAST=ZLAST_PHSP_SHORT
                  MUIDX=MUIDX_PHSP_SHORT
               END IF
            ELSE
               IF ((IMODE.NE.0)) THEN
                  READ(42,REC=NPHSPN+1,IOSTAT=IERR_PHSP) LATCHI,ESHORT,X
     *            _PHSP_SHORT,Y_PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT
     *            _PHSP_SHORT,ZLAST_PHSP_SHORT
               ELSE
                  READ(42,REC=NPHSPN+1,IOSTAT=IERR_PHSP) LATCHI,ESHORT,X
     *            _PHSP_SHORT,Y_PHSP_SHORT, U_PHSP_SHORT,V_PHSP_SHORT,WT
     *            _PHSP_SHORT
               END IF
               IF ((NPHSPN+1.EQ.76695869)) THEN
                  write(*,*)' x,y,u,v,wt,eshort,latch', X_PHSP_SHORT,Y_P
     *            HSP_SHORT,U_PHSP_SHORT,V_PHSP_SHORT, WT_PHSP_SHORT,ESH
     *            ORT,LATCHI
               END IF
               IF ((ESHORT.LT.0.0)) THEN
                  NHSTRY=NHSTRY+1
                  ESHORT=ABS(ESHORT)
               END IF
               EIN=ESHORT
               WEIGHT=WT_PHSP_SHORT
               XIN=X_PHSP_SHORT
               YIN=Y_PHSP_SHORT
               UIN=U_PHSP_SHORT
               VIN=V_PHSP_SHORT
               IF((IMODE.NE.0))ZLAST=ZLAST_PHSP_SHORT
               IF ((IERR_PHSP.EQ.0)) THEN
                  EIN=ESHORT
                  IF ((btest(LATCHI, 31))) THEN
                     NPASS = 1
                     LATCHI = ibclr(LATCHI,31)
                  ELSE
                     NPASS = 0
                  END IF
                  IF ((btest(LATCHI, 30))) THEN
                     IQIN = -1
                     LATCHI = ibclr(LATCHI,30)
                     LATCHI = ibclr(LATCHI,29)
                  ELSE
                     IF ((btest(LATCHI, 29))) THEN
                        IQIN = 1
                        LATCHI = ibclr(LATCHI,29)
                     ELSE
                        IQIN = 0
                     END IF
                  END IF
                  WIN = min( 1., UIN**2 + VIN**2)
                  WIN = sqrt(1. - WIN)
                  WIN = SIGN(WIN,WEIGHT)
                  WEIGHT=ABS(WEIGHT)
               END IF
            END IF
            NNREAD=NNREAD+1
            IF((DOSE_STAT.EQ.1 .OR. NHSTRY.EQ.0))NHSTRY=NHSTRY+1
            IF((NPASS.EQ.1))GOTO 4230
            IF ((IQIN.EQ.-1 .AND. IQINC.NE.-1 .AND. IQINC.NE.2 .AND. IQI
     *      NC .NE.3)) THEN
               GOTO 4230
            END IF
            IF ((IQIN.EQ. 1 .AND. IQINC.NE. 1 .AND. IQINC.NE.2 .AND. IQI
     *      NC .NE.3)) THEN
               GOTO 4230
            END IF
            IF ((IQIN.EQ. 0 .AND. IQINC.NE. 0 .AND. IQINC.NE.2)) THEN
               GOTO 4230
            END IF
            xin=xin+xoffset
            yin=yin+yoffset
            zin = -dist_phsp*cost_phsp + yin*sint_phsp + chamber_c
            yin = dist_phsp*sint_phsp + yin*cost_phsp
            vtemp = vin
            vin = -win*sint_phsp + vin*cost_phsp
            win = win*cost_phsp + vtemp*sint_phsp
            radp = xin*xin + yin*yin
            IF (( radp .GT. CYRAD2(nr) .OR. zin .LT. zplane(1) .OR. zin
     *      .GT. zplane(nz+1) )) THEN
               check = .true.
               IF (( zin .LT. zplane(1) .AND. win .GT. 0 )) THEN
                  tf = (zplane(1)-zin)/win
               ELSE IF(( zin .GT. zplane(nz+1) .AND. win .LT. 0 )) THEN
                  tf = (zplane(nz+1) - zin)/win
               ELSE
                  check = .false.
               END IF
               IF (( check )) THEN
                  xtmp = xin + uin*tf
                  ytmp = yin + vin*tf
                  radp = xtmp*xtmp + ytmp*ytmp
                  IF (( radp .LE. CYRAD2(nr) )) THEN
                     xin = xtmp
                     yin = ytmp
                     IF (( zin .LT. zplane(1) )) THEN
                        zin = zplane(1)
                        iz = 1
                     ELSE
                        zin = zplane(nz+1)
                        iz = nz
                     END IF
                     DO 4281 ix=1,nr
                        IF((radp .LE. CYRAD2(ix)))GO TO4282
4281                 CONTINUE
4282                 CONTINUE
                     goto 4290
                  END IF
                  radp = xin*xin + yin*yin
               END IF
               IF((radp .LT. CYRAD2(nr)))goto 4230
               phbb = uin*uin + vin*vin
               IF((phbb .LT. 1e-15))goto 4230
               pha = (xin*uin + yin*vin)/phbb
               IF((pha .GT. 0))goto 4230
               phb = (radp - CYRAD2(nr))/phbb
               phd = pha*pha - phb
               IF((phd .LT. 0))goto 4230
               tf = -pha-sqrt(phd)
               IF((tf .LT. 0))goto 4230
               zin = zin + tf*win
               IF((zin .LT. zplane(1) .OR. zin .GT. zplane(nz+1)))goto 4
     *         230
               ix = nr
               xin = xin + uin*tf
               yin = yin + vin*tf
               DO 4301 iz=2,nplane
                  IF((zin .LE. zplane(iz)))GO TO4302
4301           CONTINUE
4302           CONTINUE
               iz = iz-1
               goto 4290
            END IF
            DO 4311 iz=2,nplane
               IF((zin .LE. zplane(iz)))GO TO4312
4311        CONTINUE
4312        CONTINUE
            iz = iz-1
            DO 4321 ix=1,nr
               IF((radp .LE. CYRAD2(ix)))GO TO4322
4321        CONTINUE
4322        CONTINUE
4290        count_phsp = count_phsp + 1
            irin = 1 + (ix-1)*nz + iz
            NRCFLG = 20
            IF ((NRCYCL.GT.0)) THEN
               CYCLNUM=1
               XINOLD=XIN
               YINOLD=YIN
               ZINOLD=ZIN
               UINOLD=UIN
               VINOLD=VIN
               WINOLD=WIN
               IRINOLD=IRIN
               NRCFLGOLD=NRCFLG
               WEIGHTOLD=WEIGHT
            END IF
         END IF
      END IF
      RETURN
      ENTRY SRCEND
      IF (( ISOURC .EQ. 23 )) THEN
         call finish_beamsource
      END IF
      return
100   FORMAT(' ',2(I2,' '),4(G14.7,' '))
200   FORMAT(' ',I1)
300   FORMAT(' ',I3)
400   FORMAT(' ',2(G14.7,' '))
500   FORMAT(/' ',79('*')//T30,'SOURCE PARAMETERS'//' ',79('*')/)
510   FORMAT(T20,'Parallel beam on front face, radius=',F8.3,'cm'/T30,' 
     *X-axis direction cosine=',F10.4/T30,' Y-axis direction cosine=',F1
     *0.4/T30,' Z-axis direction cosine=',F10.4/T30,' Incident fluence='
     *, 1PE13.3,'/cm**2')
520   FORMAT(T5,'Point source on cyl axis',F8.1,' cm away, collimated to
     * R =',F8.3,' cm',/T5,'Incident fluence(at front face on axis) * ',
     *'Solid angle=',1PE14.3)
525   FORMAT(T5,'Point source on cyl axis',F8.1,' cm away'/T10,'Collimat
     *ed to radii =',F8.3,' cm to ',F8.3,' cm',/T5,'Incident fluence(at 
     *front face on axis) * ','SOLID ANGLE=',1PE14.3)
530   FORMAT(T20,'PARALLEL BEAM INCIDENT ON CYLINDRICAL WALL',/T21,'RADI
     *AL DIMENSION=',F8.3,' cm, HALF-LENGTH=',F8.3,' cm')
535   FORMAT(T5,'Point source on cyl axis',F8.1,' cm away'/T10,'Collimat
     *ed to x =',F8.3,' cm, y = ',F8.3,' cm',/T5,'Incident fluence(at fr
     *ont face on axis) * ','SOLID ANGLE=',1PE14.3)
540   FORMAT(T20,'POINT SOURCE INCIDENT FROM SIDE',F8.1,' cm',' FROM MID
     *-POINT'/T25,'RADIAL DIMENSION=',F8.3,' cm',' HALF-LENGTH=',F8.3,' 
     *cm')
550   FORMAT(/T30,'NOTE BEAM DOES NOT COVER THE DETECTOR'/T30,37('*') )
560   FORMAT(' ',T20,'BROAD PARALLEL BEAM ON CYLINDRICAL AXIS')
570   FORMAT(T10,'ISOTROPICALLY RADIATING, UNIFORM SOURCE LOCATED'/'    
     *  between radii',2F10.3,' and DEPTHS', 2F10.3)
580   FORMAT(' ',T20,'POINT SOURCE OFF AXIS, RADIAL COORDINATE ',F8.3,' 
     *cm'/' ',T20,'PERPENDICULAR DISTANCE OF SOURCE FROM FRONT FACE ',F8
     *.3,' cm')
585   FORMAT(T20,'BROAD PARALLEL BEAM FROM ANY ANGLE'/T30,' X-AXIS DIREC
     *TION COSINE=',F10.4/T30,' Y-AXIS DIRECTION COSINE=',F10.4/T30,' Z-
     *AXIS DIRECTION COSINE=',F10.4/T30,' INCIDENT FLUENCE=', 1PE13.3,'/
     *cm**2')
590   FORMAT(' ',T23,'CENTRAL AXIS FLUENCE VS BEAM RADIUS'/T25,'CENTRAL 
     *AXIS RADIUS=',F9.4,' cm'//12X,'  TREAT RADIAL BINS AS BEAM RADIUS,
     * NOT SCORING REGION RADIUS'/)
595   FORMAT(' ',T20,'RADIAL DISTRIBUTION, FRONTAL PARELLEL BEAM'/)
605   FORMAT(80A1)
600   FORMAT(27A1)
610   FORMAT(' ',T20,'RADIAL DISTBN, # OF INCIDENT RADIAL BINS:',T60,I5/
     *' ',T20,'BIN    KINETIC RADIAL     PROBABILITY  CUMULATIVE PROB')
620   FORMAT(' ',T20,I3,T28,F7.3,T45,1PE10.3,T60,0PF7.4)
630   FORMAT(/' *******WARNING******'/T20,'SOME OF NORMALIZED BIN',' PRO
     *BABILITIES SO SMALL BINS MAY BE MISSED'/)
640   FORMAT(T20,'Full phase space input for each incident particle. '/T
     *5,' Source data file: ',256A1/T25,' Source incident on front face,
     * Z =',F14.4,' cm.'/T25,' # of particles read from ph-sp file =', 1
     *PE13.3,'.')
642   FORMAT(T20,'Full phase space input for each incident particle. '/T
     *5,' Source data file: ',80A1/T25,' Source incident on plane, Y =',
     *F14.4,' cm.'/T25,' Centre of source plane at Z =',F14.4,' cm.'/T25
     *,' # of particles read from ph-sp file =', 1PE13.3,'.')
650   FORMAT(I1,1X,I7,1X,F5.0,1X,2(F4.0,1X),F1.0,1X,2(F10.8,1X),E10.4)
660   FORMAT(40A1/22A1/80A1/I10,3X,3F6.0/)
670   FORMAT(40A1/22A1/80A1/I10,3X,3F6.0//)
677   FORMAT(T20,'Full phase space input for each incident particle. '/T
     *5,' Source data file: ',256A1/T25,' Source incident on plane ',F14
     *.4,' cm from the point of rotation'/T25,' Angle with respect to z-
     *axis ',F14.4,' degrees.'/T25,' z-position of point of rotation ',f
     *14.4,/T25,' X offset of phsp (before rotation)',F14.4,' cm'/T25,' 
     *Y offset of phsp (before rotation)',F14.4,' cm'/T25,' # of particl
     *es read from ph-sp file =', 1PE13.3,'.')
679   FORMAT(T20,' Full treatment head simulation from an angle'/,T10,' 
     *   Particle charge                               : ',i3,/T10,'    
     *Weight window                                 : ',2g15.6,/T10,'   
     * BEAMnrc user code                             : ',a,/T10,'    PEG
     *S data file                                : ',a,/T10,'    Input f
     *ile                                    : ',a,/T10,'    Rotation po
     *int to phsp-plane midpoint distance: ',f10.4,/T10,'    Incident an
     *gle (degrees)                      : ',f10.4,/T10,'    Rotation po
     *int (will be set to chamber center'/,T10,'      if greater than 1e
     *4 or less than -1e4):     : ',g14.4,' cm'/T10,'    X offset of phs
     *p plane (before rotation)      : ',f10.4,' cm'/T10,'    Y offset o
     *f phsp plane (before rotation)      : ',f10.4,' cm'/T10,'    Max. 
     *kinetic energy of simulation             : ',f10.4,' MeV')
      END
      subroutine src15
      implicit none
      COMMON/GEOM/ ZPLANE( 101),RCYL(0:10),CYRAD2( 11), NZ,NR,NREG,NPLAN
     *E
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NPLANE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(100,10),TMCPUO,TIMMAX,ST
     *ATLM,EIN, IDAT,IRESTART,IQIN,IVAL,ISPRREG,ISPR( 1001)
      integer*8 NCASE,NCASEO,NCASET
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN
      integer*4 IDAT,IRESTART,IQIN,IVAL,ISPR, ISPRREG,DATCOUNT
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(1000,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RB
     *EAM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2
     *,DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,
     *PROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST
     *,ZSOFST,                                                      SVTM
     *P1,SVTMP2,SVTMP3,SVTMP4,
     *          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                        XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,
     *WEIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      real*8 temp1,temp2,temp3,temp4
      real*8 XIN,YIN,ZIN,UIN,VIN,WIN,WEIGHT
      integer*4 NRCFLG,IRIN,iout,error_flag
      real*8 theta,cost,sint,d,d2,yo,zo,dz,R,R2,area,w0,pi,zc,ro2
      real*8 fak,x1,y1,x2,y2,x3,y3,xmin,xmax,delx,ymin,ymax,dely
      real*8 count,sumw,sumw2
      logical just_fb,just_side,enter_fb,enter_side
      real*8 eta1,eta2,xx,yy,zz,dist2,dist,uli,vli,wli, xli,yli,zli,rad2
     *,ts,tf,ur2,ux,ux2,rr2,del,error
      integer*4 ix,iz
      save cost,sint,d,d2,yo,zo,dz,R,R2,xmin,delx,ymin,dely, zc,area,w0,
     *count,sumw,sumw2,just_fb,just_side,pi,ro2
      entry src15_ini(temp1,temp2,temp3,temp4,error_flag)
      pi = 4*datan(1d0)
      theta = temp2
      IF (( theta .GT. 180 )) THEN
         theta = 360 - theta
      END IF
      theta = theta*pi/180
      cost = cos(theta)
      sint = sin(theta)
      d = temp1
      d2 = d*d
      yo = d*sint
      zo = -d*cost
      R = RCYL(NR)
      R2 = R*R
      dz = 0.5*(ZPLANE(NPLANE)-ZPLANE(1))
      zc = 0.5*(ZPLANE(NPLANE)+ZPLANE(1))
      IF (( yo .GT. -R .AND. yo .LT. R .AND. zo .GT. -dz .AND. zo .LT. d
     *z )) THEN
         error_flag = 1
      END IF
      just_fb = .false.
      just_side = .false.
      IF (( yo .GE. -R .AND. yo .LE. R )) THEN
         just_fb = .true.
      END IF
      IF (( zo .GE. -dz .AND. zo .LE. dz )) THEN
         just_side = .true.
      END IF
      IF (( just_fb )) THEN
         IF (( zo .LT. -dz )) THEN
            fak = 1./(1-(-R*sint + dz*cost)/d)
            x1 = R*fak
            y1 = (-R*cost-dz*sint)*fak
            fak = 1./(1-(R*sint + dz*cost)/d)
            x2 = R*fak
            y2 = (R*cost-dz*sint)*fak
         ELSE
            fak = 1./(1-(-R*sint - dz*cost)/d)
            x1 = R*fak
            y1 = (-R*cost+dz*sint)*fak
            fak = 1./(1-(R*sint - dz*cost)/d)
            x2 = R*fak
            y2 = (R*cost+dz*sint)*fak
         END IF
         ymin = MIN(y1,y2)
         ymax = MAX(y1,y2)
         xmax = MAX(x1,x2)
         xmin = -xmax
      ELSE IF(( just_side )) THEN
         fak = 1./(1-(R*sint + dz*cost)/d)
         x1 = R*fak
         y1 = (R*cost-dz*sint)*fak
         fak = 1./(1-(R*sint - dz*cost)/d)
         x2 = R*fak
         y2 = (R*cost+dz*sint)*fak
         ymin = MIN(y1,y2)
         ymax = MAX(y1,y2)
         xmax = MAX(x1,x2)
         xmin = -xmax
      ELSE
         IF (( zo .LT. -dz )) THEN
            fak = 1./(1-(-R*sint + dz*cost)/d)
            x1 = R*fak
            y1 = (-R*cost-dz*sint)*fak
         ELSE
            fak = 1./(1-(-R*sint - dz*cost)/d)
            x1 = R*fak
            y1 = (-R*cost+dz*sint)*fak
         END IF
         fak = 1./(1-(R*sint + dz*cost)/d)
         x2 = R*fak
         y2 = (R*cost-dz*sint)*fak
         fak = 1./(1-(R*sint - dz*cost)/d)
         x3 = R*fak
         y3 = (R*cost+dz*sint)*fak
         xmax = max(x1,x2,x3)
         xmin = -xmax
         ymin = min(y1,y2,y3)
         ymax = max(y1,y2,y3)
      END IF
      delx = xmax - xmin
      dely = ymax - ymin
      area = delx*dely
      w0 = area/d2
      ro2 = yo*yo
      WRITE(6,4330)IQIN,d,temp2,xmin,xmax,ymin,ymax
4330  FORMAT(/' Electric charge of the source:',T60,I12/ ' Point sourceo
     *ff axis'/ ' Distance of source from centre of chamber: ',T60,f10.4
     *,/ ' Angle to z-axis (degrees): ',T60,f10.4,/, ' Rectangle in the 
     *plane perpendicular to the source-chamber'/ ' axis seen from theso
     *urce: ',/,T40,4f10.4/)
      return
      entry src15_oto(iout)
      ainflu = NCASET/d2
      return
      entry src15_describe(iout)
      write(iout,580) d,theta,yo,zo
580   format(' ',t20,'POINT SOURCE OFF AXIS',/,' ',t20, 'distance to cha
     *mber centre: ',f8.3,' cm',/,' ',t20, 'angle: ',f8.3,' degrees ',/,
     *' ',t20, 'source position: y = ',f8.3,' z = ',f8.3)
      return
      entry src15_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
      count = count + 1
      IF((rng_seed .GT. 128))call ranmar_get
      eta1 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((rng_seed .GT. 128))call ranmar_get
      eta2 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      xx = xmin + delx*eta1
      yy = ymin + dely*eta2
      dist2 = d2 + xx*xx + yy*yy
      dist = sqrt(dist2)
      w0 = d/dist
      zz = yy*sint
      yy = yy*cost
      uli = xx/dist
      vli = (yy-yo)/dist
      wli = (zz-zo)/dist
      tf = 1e15
      ts = 1e15
      enter_fb = .false.
      enter_side = .false.
      IF (( .NOT.just_side )) THEN
         IF (( zo .LT. -dz )) THEN
            tf = (-dz-zo)/wli
         ELSE
            tf = (dz - zo)/wli
         END IF
         xli = uli*tf
         yli = vli*tf + yo
         IF (( xli*xli + yli*yli .LT. R2 )) THEN
            enter_fb = .true.
         ELSE
            tf = 1e15
         END IF
      END IF
      IF (( .NOT.just_fb )) THEN
         ur2 = uli*uli + vli*vli
         ux = -yo*vli/ur2
         ux2 = ux*ux
         rr2 = ro2/ur2
         del = ux2 - rr2 + R2/ur2
         IF (( del .GE. 0 )) THEN
            ts = ux - sqrt(del)
            IF (( ts .GT. 0 )) THEN
               zli = zo + wli*ts
               IF (( zli .GE. -dz .AND. zli .LE. dz )) THEN
                  enter_side = .true.
               END IF
            END IF
            IF (( .NOT.enter_side )) THEN
               ts = 1e15
            END IF
         END IF
      END IF
      IF (( .NOT.enter_fb .AND. .NOT.enter_side )) THEN
         weight = 0
         xin = 0
         yin = 0
         zin = zplane(1)
         uin = 0
         vin = 0
         win = 1
         irin = 2
         return
      END IF
      uin = uli
      vin = vli
      win = wli
      weight = w0*area/dist2
      sumw = sumw + weight
      sumw2 = sumw2 + weight*weight
      IF (( tf .LT. ts )) THEN
         xin = xli
         yin = yli
         IF (( zo .LT. -dz )) THEN
            zin = zplane(1)
            iz = 1
         ELSE
            zin = zplane(nplane)
            iz = nplane-1
         END IF
         rad2 = xli*xli+yli*yli
         DO 4341 ix=1,nr
            IF((rad2 .LE. CYRAD2(IX)))GO TO4342
4341     CONTINUE
4342     CONTINUE
      ELSE
         zin = zli + zc
         xin = ts*uli
         yin = yo + vli*ts
         ix = nr
         DO 4351 iz=1,nz
            IF((zin .GE. zplane(iz) .AND. zin .LT. zplane(iz+1)))GO TO43
     *      52
4351     CONTINUE
4352     CONTINUE
      END IF
      irin = 1 + (ix-1)*nz + iz
      return
      entry src15_out(iout)
      sumw = sumw/count
      sumw2 = sumw2/count
      error = (sumw2 - sumw*sumw)/(count-1)
      IF (( error .GT. 0 )) THEN
         error = sqrt(error)
      END IF
      write(iout,600) sumw,sumw2
600   format(//'  Source 15: solid angle for detector: ',g14.5,' +/- ',g
     *14.5,//)
      return
      end
      subroutine src16
      implicit none
      COMMON/GEOM/ ZPLANE( 101),RCYL(0:10),CYRAD2( 11), NZ,NR,NREG,NPLAN
     *E
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NPLANE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(100,10),TMCPUO,TIMMAX,ST
     *ATLM,EIN, IDAT,IRESTART,IQIN,IVAL,ISPRREG,ISPR( 1001)
      integer*8 NCASE,NCASEO,NCASET
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN
      integer*4 IDAT,IRESTART,IQIN,IVAL,ISPR, ISPRREG,DATCOUNT
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(1000,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RB
     *EAM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2
     *,DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,
     *PROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST
     *,ZSOFST,                                                      SVTM
     *P1,SVTMP2,SVTMP3,SVTMP4,
     *          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                        XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,
     *WEIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      real*8 temp1,temp2,temp3,temp4
      real*8 XIN,YIN,ZIN,UIN,VIN,WIN,WEIGHT
      integer*4 NRCFLG,IRIN,iout,error_flag
      real*8 pi,theta,cost,sint,d0,d02,R,R2,dz,dr,zc,u,aux,u2, xo,yo,zo,
     *a_side,a_fb,atot,wfb,dist,dist2,rs, delxs,delys,rs2,rad2,eta,sumw,
     *sumw2,count,zz
      logical point_source,do_fb,do_side,do_both,is_circle
      integer*4 ix,iz
      save pi,cost,sint,d0,d02,R,R2,dz,dr,zc,theta, xo,yo,zo,a_side,a_fb
     *,atot,wfb,rs,delxs,delys,rs2, sumw,sumw2,count,point_source,do_fb,
     *do_side,is_circle
      entry src16_ini(temp1,temp2,temp3,temp4,error_flag)
      pi = 4*datan(1d0)
      count = 0
      theta = temp2
      theta = theta*pi/180
      cost = cos(theta)
      sint = sin(theta)
      d0 = temp1
      d02 = d0*d0
      R = RCYL(NR)
      R2 = R*R
      dz = 0.5*(ZPLANE(NPLANE)-ZPLANE(1))
      zc = 0.5*(ZPLANE(NPLANE)+ZPLANE(1))
      IF (( temp3 .LE. 0 .AND. temp4 .LE. 0 )) THEN
         point_source = .true.
         zo = -d0*cost
         yo = d0*sint
         xo = 0
         do_fb = .false.
         do_side = .false.
         do_both = .false.
         a_side = 0
         a_fb = 0
         IF (( abs(yo) .GT. R )) THEN
            u = R/yo
            aux = sqrt(1-u*u)
            dr = R*aux
            do_side = .true.
            a_side = 4*dz*R*yo*(aux-u*atan(aux/u))
         END IF
         IF (( abs(zo) .GT. dz )) THEN
            a_fb = pi*R2*(abs(zo)-dz)
            do_fb = .true.
         END IF
         atot = a_fb + a_side
         wfb = a_fb/atot
         IF (( do_side .AND. do_fb )) THEN
            do_both = .true.
         END IF
      ELSE
         point_source = .false.
         is_circle = .false.
         IF (( temp4 .LE. 0 .OR. temp3 .LE. 0 )) THEN
            IF (( temp4 .LE. 0 )) THEN
               rs = temp3
            ELSE
               rs = temp4
            END IF
            rs = temp3
            rs2 = rs*rs
            delxs = rs
            delys = rs
            is_circle = .true.
         ELSE
            delxs = temp3
            delys = temp4
            rs2 = 1.1*(delxs*delxs+delys*delys)
         END IF
      END IF
      WRITE(6,4360)IQIN
4360  FORMAT(/' Electric charge of the source:',T60,I12)
      IF (( point_source )) THEN
         WRITE(6,4370)d0,temp2,wfb,1-wfb
4370     FORMAT(' Point source off axis (source 16 implementation)'/ ' D
     *istance of source from centre of chamber: ',T60,f10.4,/ ' Angle to
     * z-axis (degrees): ',T60,f10.4,/, ' Estimated probability to strik
     *e front/back face: ',T60,f12.6,/ ' Estimated probability to strike
     * side face: ',T60,f12.6)
      ELSE
         IF (( is_circle )) THEN
            WRITE(6,4380)d0,temp2,rs
4380        FORMAT(' Disk irradiating the chamber (source 16 implementat
     *ion)'/ ' Distance of source centre to chamber centre: ',T60,f10.4,
     */ ' Angle to z-axis (degrees): ',T60,f10.4,/, ' Radius of the sour
     *ce: ',T60,f10.4)
         ELSE
            WRITE(6,4390)d0,temp2,delxs,delys
4390        FORMAT(' Rectangle irradiating the chamber (source 16 implem
     *entation)'/ ' Distance of source centre to chamber centre: ',T60,f
     *10.4,/ ' Angle to z-axis (degrees): ',T60,f10.4,/, ' Rectangle hal
     *f-sizes: ',T60,2f10.4)
         END IF
      END IF
      return
      entry src16_oto(iout)
      ainflu = NCASET/d02
      return
      entry src16_describe(iout)
      IF (( point_source )) THEN
         write(iout,'(t20,a)') 'POINT SOURCE OFF AXIS (source 16)'
      ELSE
         IF (( is_circle )) THEN
            write(iout,'(t20,a)') 'Radiating circle off axis (source 16)
     *'
            write(iout,'(t20,a,f10.4)') 'Source radius: ',rs
         ELSE
            write(iout,'(t20,a)') 'Radiating rectangle off axis (source
     *16)'
            write(iout,'(t20,a,2f10.4)') 'Source half-sizes: ',delxs,del
     *      ys
         END IF
      END IF
      write(iout,'(t20,a,f10.4)') 'Distance between source and chamber c
     *entres: ',d0
      write(iout,'(t20,a,f10.4,a)') 'Angle to z-axis (degrees): ',theta*
     *180/pi,' degrees'
      return
      entry src16_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG)
      count = count + 1
      IF (( .NOT.point_source )) THEN
4401     CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            xo = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            xo = delxs*(2*xo-1)
            IF((rng_seed .GT. 128))call ranmar_get
            yo = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            yo = delys*(2*yo-1)
            IF((( xo*xo + yo*yo .LT. rs2 )))GO TO4402
         GO TO 4401
4402     CONTINUE
         zo = yo*sint - d0*cost
         yo = d0*sint + yo*cost
         yo = sqrt(yo*yo+xo*xo)
         do_fb = .false.
         do_side = .false.
         do_both = .false.
         a_side = 0
         a_fb = 0
         IF (( abs(yo) .GT. R )) THEN
            u = R/yo
            do_side = .true.
            IF (( u .LT. 0.1 )) THEN
               u2 = u*u
               aux = 1 - u2/2 - u2*u2/8
               a_side = 4*dz*R*yo*(aux-pi*u/2+u2+u2*u2/6)
            ELSE
               aux = sqrt(1-u*u)
               a_side = 4*dz*R*yo*(aux-u*atan(aux/u))
            END IF
            dr = R*aux
         END IF
         IF (( abs(zo) .GT. dz )) THEN
            a_fb = pi*R2*(abs(zo)-dz)
            do_fb = .true.
         END IF
         atot = a_fb + a_side
         IF (( do_side .AND. do_fb )) THEN
            wfb = a_fb/atot
            do_both = .true.
         END IF
      END IF
      IF (( do_both )) THEN
         IF((rng_seed .GT. 128))call ranmar_get
         eta = rng_array(rng_seed)*twom24
         rng_seed = rng_seed + 1
         IF (( eta .LT. wfb )) THEN
            do_fb = .true.
            do_side = .false.
         ELSE
            do_fb = .false.
            do_side = .true.
         END IF
      END IF
      IF (( do_fb )) THEN
4411     CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            xin = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            xin = R*(2*xin-1)
            IF((rng_seed .GT. 128))call ranmar_get
            yin = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            yin = R*(2*yin-1)
            rad2 = xin*xin + yin*yin
            IF(((rad2 .LE. R2 )))GO TO4412
         GO TO 4411
4412     CONTINUE
         DO 4421 ix=1,nr
            IF((rad2 .LE. CYRAD2(ix)))GO TO4422
4421     CONTINUE
4422     CONTINUE
         IF (( zo .LT. -dz )) THEN
            zin = -dz
            iz = 1
         ELSE
            zin = dz
            iz = nz
         END IF
      ELSE
         IF((rng_seed .GT. 128))call ranmar_get
         zin = rng_array(rng_seed)*twom24
         rng_seed = rng_seed + 1
         zin = dz*(2*zin-1)
4431     CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            xin = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rng_seed .GT. 128))call ranmar_get
            eta = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            xin = dr*(2*xin-1)
            yin = sqrt(R2 - xin*xin)
            IF((( eta .LT. (yo-R2/yin)/(yo-R) )))GO TO4432
         GO TO 4431
4432     CONTINUE
         ix = nr
         zz = zin + zc
         DO 4441 iz=1,nz
            IF((zz .GE. zplane(iz) .AND. zz .LT. zplane(iz+1)))GO TO4442
4441     CONTINUE
4442     CONTINUE
      END IF
      uin = xin
      vin = yin - yo
      win = zin - zo
      dist2 = uin*uin + vin*vin + win*win
      dist = sqrt(dist2)
      uin = uin/dist
      vin = vin/dist
      win = win/dist
      weight = atot/dist2/dist
      sumw = sumw + weight
      sumw2 = sumw2 + weight*weight
      irin = 1 + (ix-1)*nz + iz
      zin = zin + zc
      return
      end
#define HAVE_LOAD_DSO
#ifndef HAVE_LOAD_DSO
      subroutine init_beamsource(i_parallel,n_parallel,i_log,conf_name,
     *hen_house,egs_home,the_beam_code, the_pegs_file,the_input_file)
      integer*4 i_parallel,n_parallel
      character*(*) conf_name
      character*(*) hen_house,egs_home,the_beam_code,the_pegs_file,the_i
     *nput_file
      write(6,*) 'You need a working C compiler to use source 23!'
      call exit(1)
      end
      subroutine sample_beamsource(ein,xin,yin,zin,uin,vin,win,weight,iq
     *in,latchi, nhstry,iphatin)
      return
      end
      subroutine finish_beamsource
      return
      end
#endif
      SUBROUTINE ENSRC
      implicit none
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      INTEGER NUM_EITYPE, NUM_KIEN, NUM_SPFIL, NUM_SPIOUSP
      COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE
      integer*4 ICHPIN,ILPIN,IOUT,IPAGE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(100,10),TMCPUO,TIMMAX,ST
     *ATLM,EIN, IDAT,IRESTART,IQIN,IVAL,ISPRREG,ISPR( 1001)
      integer*8 NCASE,NCASEO,NCASET
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN
      integer*4 IDAT,IRESTART,IQIN,IVAL,ISPR, ISPRREG,DATCOUNT
      COMMON/SCORE/ SCSTP,SCSTP2,SCEDPN,SCEDPN2,SCDOSE,SCDOSE2,SCDOSE_CO
     *V, SCSPR_COV, DELTA, DELTLG,DELTAT,PIISTP, SCSTP_LAST,SCDOSE_LAST,
     *SCNUM,IHSTRY, SCSTP_TMP,SCEDPN_TMP,SCDOSE_TMP3, ifano,MXNP,ISTORE,
     *IWATCH,IOUTSP, ICROSS,ITRACKE,BSTAT,BDSTAT
      REAL*8 SCSTP,SCSTP2,SCEDPN( 101,10,4), SCEDPN2( 101,10,4), SCDOSE(
     * 101,10,3), SCDOSE2( 101,10,3), SCDOSE_COV( 101,10,3-1), SCSPR_COV
     *( 101,10,2), DELTA, DELTAT,DELTLG,PIISTP
      integer*8 SCSTP_LAST,SCDOSE_LAST( 101,10), SCNUM( 101,10)
      real*8 SCSTP_TMP,SCEDPN_TMP( 101,10,4), SCDOSE_TMP3( 101,10)
      integer*4 IFANO,MXNP,ISTORE,IWATCH,IOUTSP,ICROSS,ITRACKE, BSTAT( 1
     *01,2),BDSTAT( 101)
      integer*8 ihstry
      COMMON/SPECTR/ CDFINV(1000,2),ENSRCD(0:300),SRCPDF(300),SRCCDF(300
     *), NENSRC
      real*8 CDFINV,ENSRCD,SRCPDF,SRCCDF
      integer*4 NENSRC
      COMMON/USERVR/ CEXPTR,GWAIT,PATHL,DUMU,DUMX,DUMY,DUMZ, DELTAP,GWTO
     *LD,EPSLON,ARG,EXPMFP,ESAVEIN, IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM, IFO
     *RCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN, MEDTMP,IREJCT
      real*8 CEXPTR,GWAIT,DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,GWTOLD,EPSLON
     *,ARG, EXPMFP,ESAVEIN
      integer*4 NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN,IFORCE,IRODU
     *M, IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,IREJCT
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(1000,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RB
     *EAM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2
     *,DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,
     *PROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST
     *,ZSOFST,                                                      SVTM
     *P1,SVTMP2,SVTMP3,SVTMP4,
     *          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                        XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,
     *WEIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      integer*4  srcbin_at(300), mode
      real*8   srcpdf_at(300), enmin,enmax,sume1,sume, Ek_max,Emono
      logical is_mono
      character*256 filnam,spec_title
      integer*4 lnblnk1
      save enmin,enmax, srcbin_at, srcpdf_at,Emono, is_mono,mode,filnam,
     *spec_title
      integer*4 ib
      real*8 enin,alias_sample
      DELIMETER='SOURCE INPUTS'
      IF ((ENFLAG.EQ.1)) THEN
         MONOEN = 2
         RETURN
      END IF
      WRITE(6,4450)
4450  FORMAT(' *** INPUT CARD TC1 ***')
      IVAL = IVAL +1
      NUM_EITYPE = IVAL
      VALUES_SOUGHT(IVAL)='INCIDENT ENERGY'
      TYPE(IVAL)=3
      NVALUE(IVAL)=1
      ALLOWED_INPUTS(IVAL,0)='MONOENERGETIC'
      ALLOWED_INPUTS(IVAL,1)='SPECTRUM'
      NMIN = NUM_EITYPE
      NMAX = NUM_EITYPE
      CALL GET_INPUT
      MONOEN=VALUE(NUM_EITYPE,1)
      IF ((MONOEN .EQ. 0)) THEN
         WRITE(6,4460)
4460     FORMAT(' MONOENERGETIC BEAM:')
         IVAL = IVAL +1
         NUM_KIEN = IVAL
         VALUES_SOUGHT(IVAL)='INCIDENT KINETIC ENERGY(MEV)'
         TYPE(IVAL)=1
         NVALUE(IVAL)=1
         VALUE_MIN(IVAL)=0.001
         VALUE_MAX(IVAL)=200000
         DEFAULT(IVAL)=1.25
         NMIN = NUM_KIEN
         NMAX = NUM_KIEN
         CALL GET_INPUT
         EIN=VALUE(NUM_KIEN,1)
         WRITE(6,4470)EIN
4470     FORMAT(/' KINETIC ENERGY OF THE INCIDENT BEAM: ',T60,F10.4)
         is_mono = .true.
         Emono = EIN
      ELSE
         WRITE(6,4480)
4480     FORMAT(' ENERGY SPECTRUM:')
         is_mono = .false.
         IVAL = IVAL +1
         NUM_SPFIL = IVAL
         VALUES_SOUGHT(IVAL)='SPEC FILENAME'
         TYPE(IVAL)=2
         NMIN = NUM_SPFIL
         NMAX = NUM_SPFIL
         CALL GET_INPUT
         READ (CHAR_VALUE(NUM_SPFIL,1),FMT='(A)') filnam
         WRITE(6,4490)filnam
4490     FORMAT(/'   READ INPUT ENERGY SPECTRUM FROM: ',A)
         call replace_env(filnam)
         OPEN(9,file=filnam,STATUS='OLD')
         READ(9,'(A)') spec_title
         READ(9,*) nensrc,ensrcd(0),mode
         enmin = ensrcd(0)
         IF ((NENSRC .GT. 300)) THEN
            WRITE(6,4500)NENSRC,300
4500        FORMAT(//' ********** Asked for too many energy bins******'/
     *' NENSRC =',I4, ' reduced to max allowed =',I4/1x,30('*')//)
            NENSRC = 300
         END IF
         READ(9,*)(ENSRCD(IB),SRCPDF(IB),IB=1,NENSRC)
         CLOSE(UNIT=9)
         WRITE(6,4510)NENSRC
4510     FORMAT('    HAVE READ',I5,' INPUT ENERGY BINS FROM FILE')
         IF ((MODE.EQ.0)) THEN
            WRITE(6,4520)
4520        FORMAT('      Counts/bin assumed')
         ELSE IF((MODE .EQ. 1)) THEN
            WRITE(6,4530)
4530        FORMAT('      Counts/MeV assumed')
            DO 4541 IB=1,NENSRC
               SRCPDF(IB) = SRCPDF(IB)*(ENSRCD(IB)-ENSRCD(IB-1))
4541        CONTINUE
4542        CONTINUE
         ELSE
            WRITE(6,4550)MODE
4550        FORMAT(///'*****MODE not 0 or 1 in spectrum file? **' /80('*
     *') //)
         END IF
         EIN=ENSRCD(NENSRC)
         WRITE(6,4560)ENMIN,EIN
4560     FORMAT('    ENERGY RANGES FROM',F10.3,' MeV TO',F12.3,' MeV')
         enmax = ein
         IVAL = IVAL +1
         NUM_SPIOUSP = IVAL
         VALUES_SOUGHT(IVAL)='SPEC IOUTSP'
         TYPE(IVAL)=3
         DEFAULT(IVAL)=0
         ALLOWED_INPUTS(IVAL,0)='NONE'
         ALLOWED_INPUTS(IVAL,1)='INCLUDE'
         NMIN = NUM_SPIOUSP
         NMAX = NUM_SPIOUSP
         CALL GET_INPUT
         IOUTSP=VALUE(NUM_SPIOUSP,1)
      END IF
      WRITE(6,4570)
4570  FORMAT(' ')
      RETURN
      ENTRY ENSRC1
      IF((is_mono))return
      IF (( enmin .GE. ensrcd(1) )) THEN
         write(6,*) ' Bad spectrum: minimum energy is > top of first bin
     *! '
         stop
      END IF
      call prepare_alias_sampling(nensrc,srcpdf,srcpdf_at,srcbin_at)
      RETURN
      ENTRY ENSRCO
      IF (( is_mono )) THEN
         write(iout,'(18x,a,f9.3,a)') 'Mono-energy: ',Emono,' MeV'
         return
      END IF
      IF ((enflag .EQ. 1)) THEN
         return
      END IF
      WRITE(IOUT,105) FILNAM(:lnblnk1(FILNAM)),SPEC_TITLE(:lnblnk1(SPEC_
     *TITLE))
105   FORMAT(18x,' Spectrum file and title:'/18x,A/18x,A)
      sume1 = 0
      sume = 0
      DO 4581 ib=1,nensrc
         sume = sume + srcpdf(ib)
         sume1 = sume1 + srcpdf(ib)*(ensrcd(ib)+ensrcd(ib-1))/2
4581  CONTINUE
4582  CONTINUE
      WRITE(IOUT,'(20x,a,f10.4)') ' Average spectrum energy is ',sume1/s
     *ume
      IF ((IOUTSP.EQ.1)) THEN
         IF ((MODE.EQ.0)) THEN
            WRITE(IOUT,'(20x,'' Counts/bin assumed'')')
         ELSE
            WRITE(IOUT,'(20x,'' Counts/MeV assumed'')')
         END IF
         WRITE(IOUT,110)NENSRC,enmin
         DO 4591 IB=1,NENSRC
            WRITE(IOUT,120)IB,ensrcd(ib),srcpdf(ib),srcpdf_at(ib),srcbin
     *      _at(ib)
4591     CONTINUE
4592     CONTINUE
      END IF
      RETURN
      ENTRY ENSRCH(ENIN)
      IF (( is_mono )) THEN
         enin = Emono
         return
      END IF
      enin = alias_sample(nensrc,ensrcd,srcpdf_at,srcbin_at)
      RETURN
      ENTRY ENSRC_EMAX(Ek_max)
      IF (( is_mono )) THEN
         Ek_max = Emono
      ELSE
         Ek_max = ensrcd(nensrc)
      END IF
      return
100   FORMAT(' ',I1)
102   FORMAT(' ',G14.7)
110   FORMAT(' ',T20,'Energy dist''n, # of incident energy bins:',T60,I3
     */ T20,' Lower energy of first bin:',T60,F7.3,' (MeV)'/ ' ',T20,'bi
     *n    kinetic energy     probability  at prob   at bin')
120   FORMAT(' ',T20,I3,T28,F7.3,T45,1PE10.3,T60,0PF7.4,T70,i4)
      END
      SUBROUTINE GEOMRZ
      implicit none
      COMMON/GEOM/ ZPLANE( 101),RCYL(0:10),CYRAD2( 11), NZ,NR,NREG,NPLAN
     *E
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NPLANE
      COMMON/IODAT2/ NCASE,NCASEO,NCASET, AMASS(100,10),TMCPUO,TIMMAX,ST
     *ATLM,EIN, IDAT,IRESTART,IQIN,IVAL,ISPRREG,ISPR( 1001)
      integer*8 NCASE,NCASEO,NCASET
      real*8 AMASS,TMCPUO,TIMMAX,STATLM,EIN
      integer*4 IDAT,IRESTART,IQIN,IVAL,ISPR, ISPRREG,DATCOUNT
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/SCORE/ SCSTP,SCSTP2,SCEDPN,SCEDPN2,SCDOSE,SCDOSE2,SCDOSE_CO
     *V, SCSPR_COV, DELTA, DELTLG,DELTAT,PIISTP, SCSTP_LAST,SCDOSE_LAST,
     *SCNUM,IHSTRY, SCSTP_TMP,SCEDPN_TMP,SCDOSE_TMP3, ifano,MXNP,ISTORE,
     *IWATCH,IOUTSP, ICROSS,ITRACKE,BSTAT,BDSTAT
      REAL*8 SCSTP,SCSTP2,SCEDPN( 101,10,4), SCEDPN2( 101,10,4), SCDOSE(
     * 101,10,3), SCDOSE2( 101,10,3), SCDOSE_COV( 101,10,3-1), SCSPR_COV
     *( 101,10,2), DELTA, DELTAT,DELTLG,PIISTP
      integer*8 SCSTP_LAST,SCDOSE_LAST( 101,10), SCNUM( 101,10)
      real*8 SCSTP_TMP,SCEDPN_TMP( 101,10,4), SCDOSE_TMP3( 101,10)
      integer*4 IFANO,MXNP,ISTORE,IWATCH,IOUTSP,ICROSS,ITRACKE, BSTAT( 1
     *01,2),BDSTAT( 101)
      integer*8 ihstry
     *
     *
      COMMON/SOURCE/
     *            SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_
     *num_2,NNREAD,             NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_
     *MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,        NPHOTPHSP,RCDFIN,RDISTF,RP
     *DF,RCDF,AINFLU,RBEAM,RBEAM2,                          UINC,VINC,WI
     *NC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
     *  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
     *                AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVT
     *MP4,                          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZS
     *MIN,NINCSRC,                                XINOLD,YINOLD,ZINOLD,U
     *INOLD,VINOLD,WINOLD,WEIGHTOLD,                            ENFLAG,I
     *MODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
     *      NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
     *                    N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in
      CHARACTER*256 SPCNAM
      REAL*8 SCOMEG,SCOMEG2
      integer*8 NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
     *                        NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN
     *_MAX,P_PER_PHSP_CHUNK,                NPHOTPHSP
     *
      real*8    RCDFIN(1000,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RB
     *EAM,RBEAM2,         UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2
     *,DISTZ,DISTZ2,                    DISTB,DISTB2,RCYL1,RCYL2,PROBFC,
     *PROBSD,PROBBK,                                  AFACE,ASIDE,ZCOFST
     *,ZSOFST,                                                      SVTM
     *P1,SVTMP2,SVTMP3,SVTMP4,
     *          RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
     *                        XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,
     *WEIGHTOLD
      integer*4 ENFLAG,IMODE,
     *                        NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT
     *,                                     NRCYCL,IPARALLEL,PARNUM,CYCL
     *NUM,OUTCNT,IRINOLD,NRCFLGOLD,                       N_RUN_CHUNK_OL
     *D,IPHATIN,
     *i_iaea_in,i_unit_in
      CHARACTER*1 FILSPC(256)
      EQUIVALENCE (SPCNAM,FILSPC)
      COMMON/USERVR/ CEXPTR,GWAIT,PATHL,DUMU,DUMX,DUMY,DUMZ, DELTAP,GWTO
     *LD,EPSLON,ARG,EXPMFP,ESAVEIN, IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM, IFO
     *RCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN, MEDTMP,IREJCT
      real*8 CEXPTR,GWAIT,DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,GWTOLD,EPSLON
     *,ARG, EXPMFP,ESAVEIN
      integer*4 NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN,IFORCE,IRODU
     *M, IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,IREJCT
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      integer*4 MEDNUM, NREGLO, NREGHI
      integer*4 NZHI, NZLO, NRHI, NRLO
      integer*4 ITERSE,NSLAB(100), DESCRIBE
      real*8 DELTAZ(100),RHORI
      integer*4 NUM_ITERSE, NUM_FTFACE, NUM_NSLAB, NUM_DELTAZ, NUM_ZPLAN
     *ES, NUM_RCYL
      integer*4 NUM_MEDIA, NUM_RHOR, NUM_DESCRIB, NUM_MEDNUM, NUM_NREGLO
     *, NUM_NREGHI, NUM_NPLANLO, NUM_NPLANHI, NUM_NRADLO, NUM_NRADHI
      integer*4 ERR
      integer*4 IOUT
      integer*4 lnblnk1
      integer*4 I,J,K,PLN,COUNT
      integer*4 IX, IZ, REGNUM, SLENGHT
      real*8 ADDING
      save describe
      I=0
      ERR=15
      ERROR_FLAG=0
      DELIMETER = 'GEOMETRICAL INPUTS'
      NUM_ITERSE = IVAL
      VALUES_SOUGHT(IVAL)='METHOD OF INPUT'
      NVALUE(IVAL)=1
      TYPE(IVAL)=3
      ALLOWED_INPUTS(IVAL,0)='GROUPS'
      ALLOWED_INPUTS(IVAL,1)='INDIVIDUAL'
      NMIN = IVAL
      NMAX = IVAL
      CALL GET_INPUT
      ITERSE=VALUE(IVAL,1)
      IVAL = IVAL + 1
      NUM_FTFACE = IVAL
      VALUES_SOUGHT(IVAL)='Z OF FRONT FACE'
      NVALUE(IVAL)=1
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=-999999
      VALUE_MAX(IVAL)=999999
      DEFAULT(IVAL)=0.0
      NMIN = IVAL
      NMAX = IVAL
      CALL GET_INPUT
      ZPLANE(1)=VALUE(IVAL,1)
      IF ((ITERSE.EQ.0)) THEN
         IVAL = IVAL + 1
         NUM_NSLAB = IVAL
         VALUES_SOUGHT(IVAL)='NSLAB'
         TYPE(IVAL)=0
         VALUE_MIN(IVAL)=0
         VALUE_MAX(IVAL)=999999
         DEFAULT(IVAL)=1
         NMIN = IVAL
         NMAX = IVAL
         CALL GET_INPUT
         IVAL = IVAL + 1
         NUM_DELTAZ = IVAL
         VALUES_SOUGHT(IVAL)='SLAB THICKNESS'
         TYPE(IVAL)=1
         VALUE_MIN(IVAL)=0
         VALUE_MAX(IVAL)=999999
         DEFAULT(IVAL)=1.0
         NMIN = IVAL
         NMAX = IVAL
         CALL GET_INPUT
         DO 4601 K=1,NVALUE(NUM_NSLAB)
            NSLAB(K)=VALUE(NUM_NSLAB,K)
4601     CONTINUE
4602     CONTINUE
         DO 4611 K=1,NVALUE(NUM_DELTAZ)
            DELTAZ(K)=VALUE(NUM_DELTAZ,K)
4611     CONTINUE
4612     CONTINUE
         COUNT=1
         DO 4621 PLN=1,NVALUE(NUM_NSLAB)
            IF ((PLN.EQ.1)) THEN
               ADDING=0
            ELSE
               ADDING=ADDING+DELTAZ(PLN-1)*NSLAB(PLN-1)
            END IF
            DO 4631 K=1,NSLAB(PLN)
               COUNT=COUNT+1
               ZPLANE(COUNT)=ZPLANE(1)+ADDING+DELTAZ(PLN)*K
4631        CONTINUE
4632        CONTINUE
4621     CONTINUE
4622     CONTINUE
         NZ=COUNT-1
         IF (( NZ-1 .GT. 100)) THEN
            WRITE(6,4640)NZ-1, 100
4640        FORMAT(///' Number of depth regions,',I3,' is greater than $
     *MAXZREG=',I3/ '  You must change the definition of $MAXZREG in the
     * user code'/ '      and recompile'///)
            STOP
         END IF
      END IF
      IF ((ITERSE.EQ.1)) THEN
         IVAL = IVAL + 1
         NUM_ZPLANES = IVAL
         VALUES_SOUGHT(IVAL)='DEPTH BOUNDARIES'
         TYPE(IVAL)=1
         VALUE_MIN(IVAL)=-999999
         VALUE_MAX(IVAL)=999999
         DEFAULT(IVAL)=1.0
         NMIN = IVAL
         NMAX = IVAL
         CALL GET_INPUT
         NZ=NVALUE(IVAL)
         IF (( NZ-1 .GT. 100)) THEN
            WRITE(6,4650)NZ-1, 100
4650        FORMAT(///' Number of depth regions,',I3,' is greater than $
     *MAXZREG=',I3/ '  You must change the definition of $MAXZREG in the
     * user code'/ '      and recompile'///)
            STOP
         END IF
      END IF
      IVAL = IVAL + 1
      NUM_RCYL = IVAL
      VALUES_SOUGHT(IVAL)='RADII'
      TYPE(IVAL)=1
      VALUE_MIN(IVAL)=0.0000001
      VALUE_MAX(IVAL)=999999.9
      DEFAULT(IVAL)=1000.0
      NMIN = NUM_RCYL
      NMAX = NUM_RCYL
      CALL GET_INPUT
      NR=NVALUE(NUM_RCYL)
      IF (( NR .GT. 10 )) THEN
         WRITE(6,4660)NR, 10
4660     FORMAT(///' Number of radial regions,',I3,' is greater than $MA
     *XRADII',I3,/ '  You must change the definition of $MAXRADII in the
     * user code'/ '      and recompile'///)
         STOP
      END IF
      NREG=NR*NZ+1
      IF (( NREG .GT.  1001 )) THEN
         WRITE(6,4670)NREG,  1001
4670     FORMAT(///' Total number of regions,',I6,' is greater than $MXR
     *EG=',I6,/ '  You must change the definition of $MXREG in the userc
     *ode'/ '      and recompile'///)
         STOP
      END IF
      IVAL = IVAL + 1
      NUM_MEDIA = IVAL
      VALUES_SOUGHT(IVAL)='MEDIA'
      TYPE(IVAL)=2
      NMIN = IVAL
      NMAX = IVAL
      CALL GET_INPUT
      NMED=NVALUE(IVAL)
      IVAL = IVAL + 1
      NUM_DESCRIB = IVAL
      VALUES_SOUGHT(IVAL)='DESCRIPTION BY'
      TYPE(IVAL)=3
      NVALUE(IVAL)=1
      ALLOWED_INPUTS(IVAL,0)='REGIONS'
      ALLOWED_INPUTS(IVAL,1)='PLANES'
      ALLOWED_INPUTS(IVAL,2)='REGIONS + DENSITY'
      ALLOWED_INPUTS(IVAL,3)='PLANES + DENSITY'
      NMIN = NUM_DESCRIB
      NMAX = NUM_DESCRIB
      CALL GET_INPUT
      DESCRIBE=VALUE(NUM_DESCRIB,1)
      IVAL = IVAL + 1
      NUM_MEDNUM = IVAL
      VALUES_SOUGHT(IVAL)='MEDNUM'
      TYPE(IVAL)=0
      VALUE_MIN(IVAL)=0
      VALUE_MAX(IVAL)=NMED
      DEFAULT(IVAL)=1
      IF ((DESCRIBE.EQ.2 .OR. DESCRIBE.EQ.3)) THEN
         IVAL = IVAL + 1
         NUM_RHOR = IVAL
         VALUES_SOUGHT(IVAL)='RHOR'
         TYPE(IVAL)=1
         VALUE_MIN(IVAL)=0.0
         VALUE_MAX(IVAL)=999999.0
         DEFAULT(IVAL)=0.0
      END IF
      IF ((DESCRIBE.EQ.0 .OR. DESCRIBE.EQ.2)) THEN
         IVAL = IVAL + 1
         NUM_NREGLO = IVAL
         VALUES_SOUGHT(IVAL)='START REGION'
         TYPE(IVAL)=0
         VALUE_MIN(IVAL)=0
         VALUE_MAX(IVAL)=NREG
         DEFAULT(IVAL)=1
         IVAL = IVAL + 1
         NUM_NREGHI = IVAL
         VALUES_SOUGHT(IVAL)='STOP REGION'
         TYPE(IVAL)=0
         VALUE_MIN(IVAL)=0
         VALUE_MAX(IVAL)=NREG
         DEFAULT(IVAL)=1
         NMIN = NUM_ITERSE
         NMAX = NUM_NREGHI
         CALL GET_INPUT
      END IF
      IF ((DESCRIBE.EQ.1 .OR. DESCRIBE.EQ.3)) THEN
         IVAL = IVAL + 1
         NUM_NPLANLO = IVAL
         VALUES_SOUGHT(IVAL)='START ZSLAB'
         TYPE(IVAL)=0
         VALUE_MIN(IVAL)=1
         VALUE_MAX(IVAL)=NZ
         DEFAULT(IVAL)=1
         IVAL = IVAL + 1
         NUM_NPLANHI = IVAL
         VALUES_SOUGHT(IVAL)='STOP ZSLAB'
         TYPE(IVAL)=0
         VALUE_MIN(IVAL)=1
         VALUE_MAX(IVAL)=NZ
         DEFAULT(IVAL)=1
         IVAL = IVAL + 1
         NUM_NRADLO = IVAL
         VALUES_SOUGHT(IVAL)='START RING'
         TYPE(IVAL)=0
         VALUE_MIN(IVAL)=1
         VALUE_MAX(IVAL)=NR
         DEFAULT(IVAL)=1
         IVAL = IVAL + 1
         NUM_NRADHI = IVAL
         VALUES_SOUGHT(IVAL)='STOP RING'
         TYPE(IVAL)=0
         VALUE_MIN(IVAL)=1
         VALUE_MAX(IVAL)=NR
         DEFAULT(IVAL)=1
         NMIN = NUM_ITERSE
         NMAX = NUM_NRADHI
         CALL GET_INPUT
      END IF
      WRITE(6,4680)
4680  FORMAT(' *** INPUT CARD CGM1 ***')
      ITERSE=VALUE(NUM_ITERSE,1)
      WRITE(6,4690)ITERSE
4690  FORMAT(' TERSE(0), RAPID(1) OR DETAILED(2) INPUT:',T60,I12/)
      IF ((ITERSE.EQ.0)) THEN
         WRITE(6,4700)
4700     FORMAT(' *** CARD CGM2A *** (Input groups of slabs) ')
         WRITE(6,4710)NZ
4710     FORMAT(' Number of planar slabs: ',T60,I12)
         NPLANE=NZ+1
         WRITE(6,4720)
4720     FORMAT(' Geometrical Z-plane coordinates:')
         WRITE(6,4730)(ZPLANE(I),I=1,NZ+1)
4730     FORMAT(6F10.4)
         WRITE(6,4740)
4740     FORMAT(' ')
      END IF
      IF ((ITERSE.EQ.1)) THEN
         WRITE(6,4750)
4750     FORMAT(' *** INPUT CARD CGM2B *** (DETAILED INPUT)')
         DO 4761 I=1,NZ
            ZPLANE(I+1)=VALUE(NUM_ZPLANES,I)
4761     CONTINUE
4762     CONTINUE
         WRITE(6,4770)NZ
4770     FORMAT(' NUMBER OF PLANAR SLABS: ',T60,I12)
         NPLANE=NZ+1
         WRITE(6,4780)
4780     FORMAT(' GEOMETRICAL Z-PLANE COORDINATES:')
         WRITE(6,4790)(ZPLANE(I),I=1,NPLANE)
4790     FORMAT(6F10.4)
         WRITE(6,4800)
4800     FORMAT(' ')
      END IF
      WRITE(6,4810)
4810  FORMAT(' *** INPUT CARD CG3 ***')
      WRITE(6,4820)NR
4820  FORMAT(' Number of concentric rings: ', T60, I12)
      RCYL(0)=0.0
      DO 4831 I=1,NR
         RCYL(I)=VALUE(NUM_RCYL,I)
         CYRAD2(I)=VALUE(NUM_RCYL,I)**2
4831  CONTINUE
4832  CONTINUE
      DO 4841 I=1,NR
         WRITE(6,4850)I,RCYL(I)
4850     FORMAT(' Ring radius #',I2,':',T60,F10.4,' cm')
4841  CONTINUE
4842  CONTINUE
      WRITE(6,4860)
4860  FORMAT(/' *** INPUT CARD M1 ***')
      WRITE(6,4870)3, NMED
4870  FORMAT(' Number of media(<=',I3,'):',T60,I12/)
      IF ((NMED .GT. 3 )) THEN
         WRITE(6,4880)
4880     FORMAT(' ************************ERROR************************'
     *)
         WRITE(6,4890)
4890     FORMAT(' Number of media exceeds $MXMED - increase value and re
     *compile')
         WRITE(6,4900)
4900     FORMAT(' ************************ERROR************************'
     *//)
         WRITE(ERR,'('' Asked for'',I3,'' media and $MXMED is'',I3//)')
     *   NMED, 3
         ERROR_FLAG = 1
      END IF
      WRITE(6,4910)
4910  FORMAT(' *** INPUT CARD M2 ***')
      DO 4921 I=1,NMED
         SLENGHT=lnblnk1(CHAR_VALUE(NUM_MEDIA,I))
         READ (CHAR_VALUE(NUM_MEDIA,I),FMT='(24A1)') (MEDIA(J,I),J=1,SLE
     *   NGHT)
         IF ((SLENGHT.LT.24)) THEN
            DO 4931 J=SLENGHT+1,24
               MEDIA(J,I)=' '
4931        CONTINUE
4932        CONTINUE
         END IF
         WRITE(6,4940)I,(MEDIA(J,I),J=1,24)
4940     FORMAT(' MEDIUM #',I1,':',T55,24A1)
4921  CONTINUE
4922  CONTINUE
      WRITE(6,4950)
4950  FORMAT(/' *** INPUT CARD M3 ***')
      MED(1)=0
      DO 4961 I=2,NREG
         MED(I)=1
4961  CONTINUE
4962  CONTINUE
      WRITE(6,4970)NREG
4970  FORMAT(/' # of geometrical zones = ',T60,I12)
      WRITE (*,*) 'REGION(  1) = MATERIAL( 0) (VACUUM)'
      IF ((DESCRIBE.EQ.0 .OR. DESCRIBE.EQ.2)) THEN
         IF (((NVALUE(NUM_NREGLO).NE.NVALUE(NUM_MEDNUM)).OR. (NVALUE(NUM
     *   _NREGHI).NE.NVALUE(NUM_MEDNUM)))) THEN
            WRITE(ERR,*)'**************ERROR**************'
            WRITE(ERR,*)'MEDNUM HAS      ',NVALUE(NUM_MEDNUM),' VALUES'
            WRITE(ERR,*)'START REGION HAS',NVALUE(NUM_NREGLO),' VALUES'
            WRITE(ERR,*)'STOP REGION HAS ',NVALUE(NUM_NREGHI),' VALUES'
            WRITE(ERR,*)'>>>> THEY MUST ALL HAVE THE SAME NUMBER OF VALU
     *ES'
            ERROR_FLAG=1
         END IF
         IF (( DESCRIBE .EQ. 2 )) THEN
            IF (( NVALUE(NUM_RHOR).NE.NVALUE(NUM_MEDNUM))) THEN
               WRITE(ERR,*)'**************ERROR**************'
               WRITE(ERR,*)'MEDNUM HAS      ',NVALUE(NUM_MEDNUM),' VALUE
     *S'
               WRITE(ERR,*)'RHOR HAS        ',NVALUE(NUM_RHOR),' VALUES'
               WRITE(ERR,*)'>>>> THEY MUST BOTH HAVE THE SAME NUMBER OF
     *VALUES'
               ERROR_FLAG=1
            END IF
         END IF
         IF ((VALUE(NUM_MEDNUM,1) .GE. 0)) THEN
            DO 4981 I=1,NVALUE(NUM_MEDNUM)
               RHORI=0.0
               MEDNUM=VALUE(NUM_MEDNUM,I)
               IF((DESCRIBE.EQ.2))RHORI=VALUE(NUM_RHOR,I)
               NREGLO=VALUE(NUM_NREGLO,I)
               NREGHI=VALUE(NUM_NREGHI,I)
               IF ((NREGHI.LE.NREGLO)) THEN
                  IF (( NREGLO .GT. 0 .AND. NREGLO .LE.  1001 )) THEN
                     MED(NREGLO)=MEDNUM
                     IF((RHORI.GT.0.0))RHOR(NREGLO)=RHORI
                     IF ((DESCRIBE.EQ.2)) THEN
                        IF ((RHORI.GT.0.0)) THEN
                           WRITE(6,4990)NREGLO,MEDNUM,RHORI
4990                       FORMAT(' REGION(',I3,') = MATERIAL(',I2,'), R
     *HOR =',F8.5)
                        ELSE
                           WRITE(6,5000)NREGLO,MEDNUM
5000                       FORMAT(' REGION(',I3,') = MATERIAL(',I2,'), R
     *HOR = DEFAULT')
                        END IF
                     ELSE
                        WRITE(6,5010)NREGLO,MEDNUM
5010                    FORMAT(' REGION(',I3,') = MATERIAL(',I2,')')
                     END IF
                  END IF
               ELSE
                  DO 5021 K=NREGLO,NREGHI
                     IF (( K .GT. 0 .AND. K .LE.  1001 )) THEN
                        MED(K)=MEDNUM
                        IF((RHORI.GT.0.0))RHOR(K)=RHORI
                     END IF
5021              CONTINUE
5022              CONTINUE
                  IF ((DESCRIBE.EQ.2)) THEN
                     IF ((RHORI.GT.0.0)) THEN
                        WRITE(6,5030)NREGLO,NREGHI,MEDNUM,RHORI
5030                    FORMAT(' REGION(',I3,') TO REGION(',I3,') = MATE
     *RIAL(',I2,'), RHOR =',F8.5)
                     ELSE
                        WRITE(6,5040)NREGLO,NREGHI,MEDNUM
5040                    FORMAT(' REGION(',I3,') TO REGION(',I3,') = MATE
     *RIAL(',I2,'), RHOR = DEFAULT')
                     END IF
                  ELSE
                     WRITE(6,5050)NREGLO,NREGHI,MEDNUM
5050                 FORMAT(' REGION(',I3,') TO REGION(',I3,') = MATERIA
     *L(',I2,')')
                  END IF
               END IF
4981        CONTINUE
4982        CONTINUE
         END IF
      END IF
      IF ((DESCRIBE.EQ.1 .OR. DESCRIBE.EQ.3)) THEN
         IF (((NVALUE(NUM_NPLANLO).NE.NVALUE(NUM_MEDNUM)).OR. (NVALUE(NU
     *   M_NPLANLO).NE.NVALUE(NUM_MEDNUM)).OR. (NVALUE(NUM_NRADLO).NE.NV
     *   ALUE(NUM_MEDNUM)).OR. (NVALUE(NUM_NRADHI).NE.NVALUE(NUM_MEDNUM)
     *   ))) THEN
            WRITE(ERR,*)'**************ERROR**************'
            WRITE(ERR,*)'MEDNUM has      ',NVALUE(NUM_MEDNUM),' values'
            WRITE(ERR,*)'START PLANE has ',NVALUE(NUM_NPLANLO),' values'
            WRITE(ERR,*)'STOP PLANE has  ',NVALUE(NUM_NPLANHI),' values'
            WRITE(ERR,*)'START RING has  ',NVALUE(NUM_NRADLO),' values'
            WRITE(ERR,*)'STOP RING has   ',NVALUE(NUM_NRADHI),' values'
            WRITE(ERR,*)'>>>> They must all have the same number of valu
     *es'
            ERROR_FLAG=1
         END IF
         IF ((DESCRIBE.EQ.3 .AND. NVALUE(NUM_RHOR).NE.NVALUE(NUM_MEDNUM)
     *   )) THEN
            WRITE(ERR,*)'**************ERROR**************'
            WRITE(ERR,*)'MEDNUM HAS      ',NVALUE(NUM_MEDNUM),' VALUES'
            WRITE(ERR,*)'RHOR HAS        ',NVALUE(NUM_RHOR),' VALUES'
            WRITE(ERR,*)'>>>> THEY MUST BOTH HAVE THE SAME NUMBER OF VAL
     *UES'
            ERROR_FLAG=1
         END IF
         IF ((VALUE(NUM_MEDNUM,1) .GE. 0)) THEN
            DO 5061 I=1,NVALUE(NUM_MEDNUM)
               RHORI=0.0
               MEDNUM=VALUE(NUM_MEDNUM,I)
               IF((DESCRIBE.EQ.3))RHORI=VALUE(NUM_RHOR,I)
               NZLO=VALUE(NUM_NPLANLO,I)
               NZHI=VALUE(NUM_NPLANHI,I)
               NRLO=VALUE(NUM_NRADLO,I)
               NRHI=VALUE(NUM_NRADHI,I)
               IF ((NZLO.GT.NZHI)) THEN
                  NZHI=NZLO
               END IF
               IF ((NRLO.GT.NRHI)) THEN
                  NRHI=NRLO
               END IF
               DO 5071 IZ=NZLO,NZHI
                  DO 5081 IX=NRLO,NRHI
                     REGNUM=IZ+NZ*(IX-1)+1
                     IF (( regnum .GT. 0 .AND. regnum .LE.  1001 )) THEN
                        MED(REGNUM)=MEDNUM
                        IF((RHORI.GT.0.0))RHOR(REGNUM)=RHORI
                        IF ((DESCRIBE.EQ.3)) THEN
                           IF ((RHORI.GT.0.0)) THEN
                              WRITE(6,5090)IZ,IX,MEDNUM,RHORI
5090                          FORMAT(' ZPLANE(',I3,'),RADIUS(',I3,') = M
     *ATERIAL(',I2,') RHOR =',F8.5)
                           ELSE
                              WRITE(6,5100)IZ,IX,MEDNUM
5100                          FORMAT(' ZPLANE(',I3,'),RADIUS(',I3,') = M
     *ATERIAL(',I2,') RHOR = DEFAULT')
                           END IF
                        ELSE
                           WRITE(6,5110)IZ,IX,MEDNUM
5110                       FORMAT(' ZPLANE(',I3,'),RADIUS(',I3,') = MATE
     *RIAL(',I2,')')
                        END IF
                     END IF
5081              CONTINUE
5082              CONTINUE
5071           CONTINUE
5072           CONTINUE
5061        CONTINUE
5062        CONTINUE
         END IF
      END IF
      WRITE(6,5120)
5120  FORMAT(' ')
      RETURN
      ENTRY GEOMRZ_ISUMRY(IOUT)
      IF ((DESCRIBE.EQ.2.OR.DESCRIBE.EQ.3)) THEN
         WRITE(IOUT,100)
         RHORI=0.0
         DO 5131 I=2,NREG
            IF ((RHORI.GT.0.0 .AND. (RHOR(I).NE.RHORI .OR. MED(I).NE.MED
     *      (I-1)))) THEN
               NREGHI=I-1
               WRITE(IOUT,200)NREGLO,NREGHI,MED(NREGLO),RHORI
               RHORI=0.0
            END IF
            IF ((RHOR(I).GT.0.0 .AND. RHOR(I).NE.RHO(MED(I)) .AND. RHORI
     *      .EQ.0.0)) THEN
               NREGLO=I
               RHORI=RHOR(I)
            END IF
            IF ((I.EQ.NREG .AND. RHORI.GT.0.0)) THEN
               NREGHI=I
               WRITE(IOUT,200)NREGLO,NREGHI,MED(NREGLO),RHORI
            END IF
5131     CONTINUE
5132     CONTINUE
      END IF
100   FORMAT(/' ',T25,'NON-DEFAULT DENSITIES'// ' ',T10,'    Region #   
     *   Medium             Rhor  '/ ' ',T10,'from        to #          
     *   (g/cm**3)'/)
200   FORMAT(' ',T10,I3,2I11,F20.5)
      RETURN
      END
      SUBROUTINE GET_INPUT
      IMPLICIT NONE
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      CHARACTER*256 TEXT
      CHARACTER*256 KEEPTEXT
      CHARACTER*256 ORIGTEXT
      CHARACTER*256 TEXTPIECE
      CHARACTER*80 DELIM_START
      CHARACTER*80 DELIM_END
      CHARACTER*64 VNAME
      CHARACTER*64 VNAME1
      integer*4 CURSOR
      integer*4 IINDEX
      integer*4 iVNAME
      integer*4 IVAL
      integer*4 UNITNUM
      integer*4 ERR
      integer*4 I,J,K,CHECK
      integer*4 LINE
      integer*4 INT_VALUE
      integer*4 INT_VALUE_MIN
      integer*4 INT_VALUE_MAX
      logical ALLOWED
      logical START_FOUND
      integer*4 ifound,length,lll,Kconvert
      integer*4 lnblnk1
      logical IDEBUG
      character*1 blank
      integer*4 error_level
      integer*4 the_level
      data blank/' '/
      data error_level/1/
      save error_level
      IDEBUG = .false.
      ERROR_FLAG = 0
      IF ((IDEBUG)) THEN
         WRITE(6,5140)NMIN,NMAX, 100
5140     FORMAT(' Entering get_inputs seeking values', I5,' to', I5, 'wi
     *th a max allowed of',I5)
      END IF
      IF ((NMAX .LT. NMIN .OR. NMAX .GT. 100)) THEN
         WRITE(6,5150)NMAX, NMIN, 100
5150     FORMAT(//' Error entering get_inputs: Asked for values from',I5
     *,' to',I5, '    with a max of',I5//' This implies a bug in thecall
     *ing routine'/ ' Fix it up and try again.  Stopping now.')
         STOP
      END IF
      ERR=i_errors
      UNITNUM=i_input
      DELIM_START=':START '//DELIMETER(:lnblnk1(DELIMETER))//':'
      DELIM_END=':STOP '//DELIMETER(:lnblnk1(DELIMETER))//':'
      DO 5161 Kconvert=1,lnblnk1(DELIM_START)
         CURSOR=ICHAR(DELIM_START(Kconvert:Kconvert))
         IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
            CURSOR=CURSOR-32
            DELIM_START(Kconvert:Kconvert)=CHAR(CURSOR)
         END IF
5161  CONTINUE
5162  CONTINUE
      DO 5171 Kconvert=1,lnblnk1(DELIM_END)
         CURSOR=ICHAR(DELIM_END(Kconvert:Kconvert))
         IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
            CURSOR=CURSOR-32
            DELIM_END(Kconvert:Kconvert)=CHAR(CURSOR)
         END IF
5171  CONTINUE
5172  CONTINUE
      IF ((IDEBUG)) THEN
         WRITE(6,5180)DELIM_START,DELIM_END
5180     FORMAT(' start and stop delimeters are:'/ A/A/)
      END IF
      DO 5191 I=NMIN,NMAX
         REWIND (UNITNUM)
         LINE=0
         CHECK=0
         ERROR_FLAGS(I)=0
         IF ((TYPE(I) .EQ. 0 .OR. TYPE(I) .EQ. 1)) THEN
            VALUE(I,1) = DEFAULT(I)
         END IF
         IF ((TYPE(I) .EQ. 3)) THEN
            VALUE(I,1) = 0
         END IF
         VNAME=VALUES_SOUGHT(I)
         iVNAME=lnblnk1(VNAME)
         IF (( ivname .LT. 1 )) THEN
            IF (( error_level .GT. 0 )) THEN
               write(ERR,*) ' ======================= Warning ==========
     *=========== '
               write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs
     *()!         '
               write(ERR,*) ' ==========================================
     *=========== '
            END IF
            ERROR_FLAG=1
            ERROR_FLAGS(I)=1
            goto 5200
         END IF
         DO 5211 Kconvert=1,lnblnk1(vname)
            CURSOR=ICHAR(vname(Kconvert:Kconvert))
            IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
               CURSOR=CURSOR-32
               vname(Kconvert:Kconvert)=CHAR(CURSOR)
            END IF
5211     CONTINUE
5212     CONTINUE
         iindex = 0
         IF ((DELIMETER .EQ. 'NONE')) THEN
            start_found = .true.
         ELSE
            start_found = .false.
         END IF
5221     IF(iindex.NE.0)GO TO 5222
5230        CONTINUE
            LINE=LINE+1
            IF (( start_found )) THEN
               READ(UNITNUM,END=5240,ERR=5250,FMT='(A256)') TEXT
            ELSE
               READ(UNITNUM,END=5260,ERR=5250,FMT='(A256)') TEXT
            END IF
            length = len(text)
5271        IF(index(text,blank).NE.1)GO TO 5272
               IF (( length .GE. 2 )) THEN
                  text=text(2:)
               ELSE
                  GO TO5272
               END IF
               length = length - 1
            GO TO 5271
5272        CONTINUE
            ifound = INDEX(text,'#')
            IF (( ifound .GT. 1 )) THEN
               text = text(1:ifound-1)
            ELSE
               IF (( ifound .EQ. 1 )) THEN
                  text = blank
               END IF
            END IF
            ifound = INDEX(text,';')
            IF (( ifound .GT. 1 )) THEN
               text = text(1:ifound-1)
            ELSE
               IF (( ifound .EQ. 1 )) THEN
                  text = blank
               END IF
            END IF
            length = lnblnk1(TEXT)
            TEXT=TEXT(:length)
            origtext = text(:length)
            DO 5281 Kconvert=1,lnblnk1(text)
               CURSOR=ICHAR(text(Kconvert:Kconvert))
               IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                  CURSOR=CURSOR-32
                  text(Kconvert:Kconvert)=CHAR(CURSOR)
               END IF
5281        CONTINUE
5282        CONTINUE
            IF (( .NOT.start_found )) THEN
               IF ((INDEX(TEXT,DELIM_START) .NE. 0 )) THEN
                  start_found = .true.
               END IF
               goto 5230
            END IF
            iindex=INDEX(TEXT,VNAME(:iVNAME))
            IF (( DELIMETER.NE.'NONE' )) THEN
               IF ((INDEX(TEXT,DELIM_END).NE.0)) THEN
                  IF (( error_level .GT. 0 )) THEN
                     WRITE (ERR,*) '***************ERROR***************'
                     WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES
     *               _SOUGHT(I))), '<<',' NOT FOUND'
                     WRITE (ERR,*) 'END OF DELIMETER: ',DELIMETER(:lnbln
     *               k1(DELIMETER))
                  END IF
                  ERROR_FLAG=1
                  ERROR_FLAGS(I)=1
                  GOTO 5200
               END IF
            END IF
         GO TO 5221
5222     CONTINUE
         CHECK=0
         IF (( idebug )) THEN
            write(i_log,*) ' ******* Found: '
            write(i_log,'(a,$)') ' text:     '
            length = lnblnk1(text)
            IF (( length .GT. 0 )) THEN
               DO 5291 lll=1,length
                  write(i_log,'(a1,$)') text(lll:lll)
5291           CONTINUE
5292           CONTINUE
               write(i_log,*)
            END IF
            write(i_log,'(a,$)') ' origtext: '
            length = lnblnk1(origtext)
            IF (( length .GT. 0 )) THEN
               DO 5301 lll=1,length
                  write(i_log,'(a1,$)') origtext(lll:lll)
5301           CONTINUE
5302           CONTINUE
               write(i_log,*)
            END IF
         END IF
         IINDEX=IINDEX+iVNAME
         TEXT=TEXT(IINDEX:)
         origtext=origtext(iindex:)
         IF (( idebug )) THEN
            write(i_log,*) ' After removing vname: '
            write(i_log,'(a,$)') ' text:     '
            length = lnblnk1(text)
            IF (( length .GT. 0 )) THEN
               DO 5311 lll=1,length
                  write(i_log,'(a1,$)') text(lll:lll)
5311           CONTINUE
5312           CONTINUE
               write(i_log,*)
            END IF
            write(i_log,'(a,$)') ' origtext: '
            length = lnblnk1(origtext)
            IF (( length .GT. 0 )) THEN
               DO 5321 lll=1,length
                  write(i_log,'(a1,$)') origtext(lll:lll)
5321           CONTINUE
5322           CONTINUE
               write(i_log,*)
            END IF
         END IF
         IINDEX=INDEX(TEXT,'=')
         IF ((IINDEX.NE.0)) THEN
            TEXT=TEXT(IINDEX+1:)
            origtext=origtext(iindex+1:)
         ELSE
            IINDEX=INDEX(TEXT,':')
            IF ((IINDEX.NE.0)) THEN
               TEXT=TEXT(IINDEX+1:)
               origtext=origtext(iindex+1:)
            END IF
         END IF
         IF (( idebug )) THEN
            write(i_log,*) ' After removing leading equals: '
            write(i_log,'(a,$)') ' text:     '
            length = lnblnk1(text)
            IF (( length .GT. 0 )) THEN
               DO 5331 lll=1,length
                  write(i_log,'(a1,$)') text(lll:lll)
5331           CONTINUE
5332           CONTINUE
               write(i_log,*)
            END IF
            write(i_log,'(a,$)') ' origtext: '
            length = lnblnk1(origtext)
            IF (( length .GT. 0 )) THEN
               DO 5341 lll=1,length
                  write(i_log,'(a1,$)') origtext(lll:lll)
5341           CONTINUE
5342           CONTINUE
               write(i_log,*)
            END IF
         END IF
         IF (( (lnblnk1(TEXT).EQ.0) .OR. (lnblnk1(TEXT).EQ.1) )) THEN
            IF ((vname(:ivname).EQ.'TITLE')) THEN
               READ (UNITNUM,FMT='(A256)') TEXTPIECE
               IF ((lnblnk1(TEXTPIECE).NE.0)) THEN
                  TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE))
                  length = len(text)
5351              IF(index(text,blank).NE.1)GO TO 5352
                     IF (( length .GE. 2 )) THEN
                        text=text(2:)
                     ELSE
                        GO TO5352
                     END IF
                     length = length - 1
                  GO TO 5351
5352              CONTINUE
                  length = len(origtext)
5361              IF(index(origtext,blank).NE.1)GO TO 5362
                     IF (( length .GE. 2 )) THEN
                        origtext=origtext(2:)
                     ELSE
                        GO TO5362
                     END IF
                     length = length - 1
                  GO TO 5361
5362              CONTINUE
                  GOTO 5370
               END IF
            END IF
            IF (( error_level .GT. 0 )) THEN
               WRITE (ERR,*) '*************ERROR*************'
               WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
               WRITE (ERR,*) 'VALUE NOT THERE!!'
            END IF
            ERROR_FLAG=1
            ERROR_FLAGS(I)=1
            RETURN
         END IF
5370     CONTINUE
         iindex = index(text,'DEFAULT')
         IF (( iindex .NE. 0 )) THEN
            IF (( type(i) .NE. 2 )) THEN
               IF (( type(i) .NE. 3 )) THEN
                  VALUE(I,1)=DEFAULT(I)
               ELSE
                  VALUE(I,1)=0
               END IF
               goto 5200
            END IF
         END IF
         IF (((TYPE(I) .EQ. 0).OR.(TYPE(I) .EQ. 1))) THEN
            IVAL=1
            IF (( idebug )) THEN
               write(i_log,*) ' *** Reading an integer or a real value!
     *'
            END IF
5381        CONTINUE
               IF (( idebug )) THEN
                  write(i_log,*) ' In LOOP, ival = ',ival
               END IF
               IF ((lnblnk1(TEXT).EQ.0)) THEN
                  IF (( error_level .GT. 0 )) THEN
                     WRITE(ERR,*) '*************ERROR*************'
                     WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                     WRITE (ERR,*) 'VALUE NOT THERE!!'
                  END IF
                  ERROR_FLAG=1
                  ERROR_FLAGS(I)=1
                  RETURN
               END IF
               READ(TEXT,END=5390,ERR=5400,FMT=*) VALUE(I,IVAL)
               IF (( idebug )) THEN
                  write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL)
               END IF
               IF (((VALUE(I,IVAL).GT.VALUE_MAX(I)).OR.(VALUE(I,IVAL).LT
     *         .VALUE_MIN(I)))) THEN
                  IF ((TYPE(I).EQ.0)) THEN
                     INT_VALUE=DEFAULT(I)
                     IF (( error_level .GT. 0 )) THEN
                        WRITE(ERR,*) '************WARNING************'
                        WRITE(ERR,5410) INT_VALUE, VALUES_SOUGHT(I)(:lnb
     *                  lnk1(VALUES_SOUGHT(I)))
                     END IF
5410                 FORMAT ( 'Default= ',I9,' used for: ', A )
                     INT_VALUE=VALUE(I,IVAL)
                     INT_VALUE_MIN=VALUE_MIN(I)
                     INT_VALUE_MAX=VALUE_MAX(I)
                     IF (( error_level .GT. 0 )) THEN
                        WRITE(ERR,5420) VALUES_SOUGHT(I)(:lnblnk1(VALUES
     *                  _SOUGHT(I))), INT_VALUE, INT_VALUE_MIN,INT_VALUE
     *                  _MAX
                     END IF
5420                 FORMAT (A,'=', I9,' should be between ', I9,' and '
     *, I9)
                  END IF
                  IF ((TYPE(I).EQ.1)) THEN
                     IF (( error_level .GT. 0 )) THEN
                        WRITE(ERR,*) '************WARNING************'
                        WRITE(ERR,5430) DEFAULT(I), VALUES_SOUGHT(I)(:ln
     *                  blnk1(VALUES_SOUGHT(I)))
5430                    FORMAT ( 'Default= ',F12.6,' used for: ', A )
                        WRITE(ERR,5440) VALUES_SOUGHT(I)(:lnblnk1(VALUES
     *                  _SOUGHT(I))), VALUE(I,IVAL), VALUE_MIN(I),VALUE_
     *                  MAX(I)
5440                    FORMAT (A,'=', F12.6,' should be between ', G14.
     *6,' and ', G14.6)
                     END IF
                  END IF
                  VALUE(I,IVAL)=DEFAULT(I)
               END IF
               IF((IVAL .EQ. NVALUE(I)))GO TO5382
               IF (((INDEX(TEXT,',').NE.0).OR.(lnblnk1(TEXT).EQ.0))) THE
     *         N
                  IF (( idebug )) THEN
                     write(i_log,*) ' A comma or a blank text found -> '
                     write(i_log,*) ' searching for further input'
                  END IF
                  TEXT=TEXT(INDEX(TEXT,',')+1:)
5451              IF(lnblnk1(TEXT).NE.0)GO TO 5452
                     IF (( idebug )) THEN
                        write(i_log,*) ' Empty text -> reading next line
     *! '
                     END IF
                     LINE=LINE+1
                     READ (UNITNUM,END=5390,ERR=5400,FMT='(A256)') TEXT
                     length = len(text)
5461                 IF(index(text,blank).NE.1)GO TO 5462
                        IF (( length .GE. 2 )) THEN
                           text=text(2:)
                        ELSE
                           GO TO5462
                        END IF
                        length = length - 1
                     GO TO 5461
5462                 CONTINUE
                     ifound = INDEX(text,'#')
                     IF (( ifound .GT. 1 )) THEN
                        text = text(1:ifound-1)
                     ELSE
                        IF (( ifound .EQ. 1 )) THEN
                           text = blank
                        END IF
                     END IF
                     ifound = INDEX(text,';')
                     IF (( ifound .GT. 1 )) THEN
                        text = text(1:ifound-1)
                     ELSE
                        IF (( ifound .EQ. 1 )) THEN
                           text = blank
                        END IF
                     END IF
                     length = lnblnk1(TEXT)
                     TEXT=TEXT(:length)
                     origtext = text(:length)
                     DO 5471 Kconvert=1,lnblnk1(text)
                        CURSOR=ICHAR(text(Kconvert:Kconvert))
                        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                           CURSOR=CURSOR-32
                           text(Kconvert:Kconvert)=CHAR(CURSOR)
                        END IF
5471                 CONTINUE
5472                 CONTINUE
                     DO 5481 K=1,NMAX
                        vname1 = VALUES_SOUGHT(K)
                        length = lnblnk1(vname1)
                        IF (( length .GT. 0 )) THEN
                           length = len(vname1)
5491                       IF(index(vname1,blank).NE.1)GO TO 5492
                              IF (( length .GE. 2 )) THEN
                                 vname1=vname1(2:)
                              ELSE
                                 GO TO5492
                              END IF
                              length = length - 1
                           GO TO 5491
5492                       CONTINUE
                           DO 5501 Kconvert=1,lnblnk1(vname1)
                              CURSOR=ICHAR(vname1(Kconvert:Kconvert))
                              IF (((CURSOR.GE.97).AND.(CURSOR.LE.122)))
     *                        THEN
                                 CURSOR=CURSOR-32
                                 vname1(Kconvert:Kconvert)=CHAR(CURSOR)
                              END IF
5501                       CONTINUE
5502                       CONTINUE
                           IF ((INDEX(TEXT,vname1(:length)).NE.0)) THEN
                              IF (( error_level .GT. 0 )) THEN
                                 WRITE(ERR,*) '************ERROR********
     *****'
                                 WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SO
     *                           UGHT(I)
                                 WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT
     *                           )), '<--COMMA INDICATES ANOTHER INPUT'
                                 WRITE(ERR,*) 'SEARCHED NEXT LINE: ', TE
     *                           XT(:lnblnk1(TEXT))
                                 WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DE
     *TECTED'
                              END IF
                              ERROR_FLAG=1
                              ERROR_FLAGS(I)=1
                           END IF
                        END IF
5481                 CONTINUE
5482                 CONTINUE
                     IF (( idebug )) THEN
                        write(i_log,*) ' Next line: '
                        write(i_log,'(a,$)') ' text:     '
                        length = lnblnk1(text)
                        IF (( length .GT. 0 )) THEN
                           DO 5511 lll=1,length
                              write(i_log,'(a1,$)') text(lll:lll)
5511                       CONTINUE
5512                       CONTINUE
                           write(i_log,*)
                        END IF
                        write(i_log,'(a,$)') ' origtext: '
                        length = lnblnk1(origtext)
                        IF (( length .GT. 0 )) THEN
                           DO 5521 lll=1,length
                              write(i_log,'(a1,$)') origtext(lll:lll)
5521                       CONTINUE
5522                       CONTINUE
                           write(i_log,*)
                        END IF
                     END IF
                  GO TO 5451
5452              CONTINUE
               ELSE
                  GO TO5382
               END IF
               IVAL=IVAL+1
            GO TO 5381
5382        CONTINUE
            IF (((NVALUE(I).NE.0).AND.(NVALUE(I).NE.IVAL))) THEN
               IF (( error_level .GT. 0 )) THEN
                  WRITE (ERR,*) '**************ERROR**************'
                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I)
                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT
     *(S)'
                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED'
               END IF
               ERROR_FLAG=1
               ERROR_FLAGS(I)=1
            ELSE
               NVALUE(I)=IVAL
            END IF
5390        CONTINUE
         END IF
         IF (((TYPE(I) .EQ. 2) .OR. (TYPE(I) .EQ. 3))) THEN
            IVAL=1
            IF (( idebug )) THEN
               write(i_log,*) ' Trying to read a string! '
            END IF
5531        CONTINUE
               IF (( idebug )) THEN
                  write(i_log,*) ' In LOOP, ival = ',ival
               END IF
               IF ((lnblnk1(TEXT).EQ.0)) THEN
                  IF (( error_level .GT. 0 )) THEN
                     WRITE(ERR,*) '*************ERROR*************'
                     WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                     WRITE (ERR,*) 'VALUE NOT THERE!!'
                  END IF
                  ERROR_FLAG=1
                  ERROR_FLAGS(I)=1
                  RETURN
               END IF
               IF ((vname(:ivname).EQ.'TITLE')) THEN
                  TEXTPIECE=origtext
                  GOTO 5540
               END IF
               iindex = INDEX(origtext,',')
               IF (( iindex .NE. 0 )) THEN
                  TEXTPIECE=origtext(:iindex-1)
               ELSE
                  TEXTPIECE=origtext
               END IF
5540           CONTINUE
               READ(TEXTPIECE,ERR=5550,FMT='(A256)') CHAR_VALUE(I,IVAL)
               length = len(CHAR_VALUE(I,IVAL))
5561           IF(index(CHAR_VALUE(I,IVAL),blank).NE.1)GO TO 5562
                  IF (( length .GE. 2 )) THEN
                     CHAR_VALUE(I,IVAL)=CHAR_VALUE(I,IVAL)(2:)
                  ELSE
                     GO TO5562
                  END IF
                  length = length - 1
               GO TO 5561
5562           CONTINUE
               IF (( idebug )) THEN
                  write(i_log,*) ' Read the following char string: '
                  length = lnblnk1(CHAR_VALUE(I,IVAL))
                  IF (( length .GT. 0 )) THEN
                     DO 5571 lll=1,length
                        write(i_log,'(a1,$)') CHAR_VALUE(I,IVAL)(lll:lll
     *                  )
5571                 CONTINUE
5572                 CONTINUE
                     write(i_log,*)
                  END IF
               END IF
               IF ((TYPE(I) .EQ. 3)) THEN
                  DO 5581 Kconvert=1,lnblnk1(CHAR_VALUE(I,IVAL))
                     CURSOR=ICHAR(CHAR_VALUE(I,IVAL)(Kconvert:Kconvert))
                     IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                        CURSOR=CURSOR-32
                        CHAR_VALUE(I,IVAL)(Kconvert:Kconvert)=CHAR(CURSO
     *                  R)
                     END IF
5581              CONTINUE
5582              CONTINUE
                  ALLOWED=.FALSE.
                  DO 5591 K=0,5
                     vname1 = ALLOWED_INPUTS(I,K)
                     length = len(ALLOWED_INPUTS(I,K))
5601                 IF(index(ALLOWED_INPUTS(I,K),blank).NE.1)GO TO 5602
                        IF (( length .GE. 2 )) THEN
                           ALLOWED_INPUTS(I,K)=ALLOWED_INPUTS(I,K)(2:)
                        ELSE
                           GO TO5602
                        END IF
                        length = length - 1
                     GO TO 5601
5602                 CONTINUE
                     DO 5611 Kconvert=1,lnblnk1(ALLOWED_INPUTS(I,K))
                        CURSOR=ICHAR(ALLOWED_INPUTS(I,K)(Kconvert:Kconve
     *                  rt))
                        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                           CURSOR=CURSOR-32
                           ALLOWED_INPUTS(I,K)(Kconvert:Kconvert)=CHAR(C
     *                     URSOR)
                        END IF
5611                 CONTINUE
5612                 CONTINUE
                     IF ((ALLOWED_INPUTS(I,K).EQ.CHAR_VALUE(I,IVAL))) TH
     *               EN
                        ALLOWED=.TRUE.
                        VALUE(I,IVAL)=K
                        IF (( idebug )) THEN
                           write(i_log,*) ' Found a allowed_value match
     *',k
                        END IF
                     END IF
5591              CONTINUE
5592              CONTINUE
                  IF ((.NOT.ALLOWED)) THEN
                     WRITE(ERR,*) '*************ERROR*************'
                     IF ((IVAL.NE.1)) THEN
                        WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                        WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY'
                        WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING
     *SECOND VALUE'
                     ELSE
                        WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                        WRITE(ERR,*) 'INPUT-->', CHAR_VALUE(I,IVAL)(:lnb
     *                  lnk1(CHAR_VALUE(I,IVAL))), '<--NOT ALLOWED'
                        WRITE(ERR,*) 'OPTIONS ARE:'
                        WRITE(ERR,1570) (ALLOWED_INPUTS(I,K)(:lnblnk1(AL
     *                  LOWED_INPUTS(I,K))),K=0,5)
                     END IF
1570                 FORMAT(A40)
                     ERROR_FLAG=1
                     ERROR_FLAGS(I)=1
                  END IF
               END IF
               IF ((vname(:ivname).EQ.'TITLE')) THEN
                  GO TO5532
               END IF
               DO 5621 K=1,LEN(KEEPTEXT)
                  KEEPTEXT(K:K)=' '
5621           CONTINUE
5622           CONTINUE
               KEEPTEXT(:lnblnk1(TEXT))=TEXT
               iindex = INDEX(TEXT,',')
               IF (( iindex .NE. 0 .OR. lnblnk1(TEXT).EQ.0 )) THEN
                  TEXT=TEXT(INDEX(TEXT,',')+1:)
                  origtext=origtext(iindex+1:)
5631              IF(lnblnk1(TEXT).NE.0)GO TO 5632
                     LINE=LINE+1
                     READ (UNITNUM,ERR=5550,FMT='(A256)') TEXT
                     length = len(text)
5641                 IF(index(text,blank).NE.1)GO TO 5642
                        IF (( length .GE. 2 )) THEN
                           text=text(2:)
                        ELSE
                           GO TO5642
                        END IF
                        length = length - 1
                     GO TO 5641
5642                 CONTINUE
                     ifound = INDEX(text,'#')
                     IF (( ifound .GT. 1 )) THEN
                        text = text(1:ifound-1)
                     ELSE
                        IF (( ifound .EQ. 1 )) THEN
                           text = blank
                        END IF
                     END IF
                     ifound = INDEX(text,';')
                     IF (( ifound .GT. 1 )) THEN
                        text = text(1:ifound-1)
                     ELSE
                        IF (( ifound .EQ. 1 )) THEN
                           text = blank
                        END IF
                     END IF
                     length = lnblnk1(TEXT)
                     TEXT=TEXT(:length)
                     origtext = text(:length)
                     DO 5651 Kconvert=1,lnblnk1(text)
                        CURSOR=ICHAR(text(Kconvert:Kconvert))
                        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                           CURSOR=CURSOR-32
                           text(Kconvert:Kconvert)=CHAR(CURSOR)
                        END IF
5651                 CONTINUE
5652                 CONTINUE
                     DO 5661 K=1,NMAX
                        vname1 = VALUES_SOUGHT(K)
                        length = lnblnk1(vname1)
                        IF (( length .GT. 0 )) THEN
                           length = len(vname1)
5671                       IF(index(vname1,blank).NE.1)GO TO 5672
                              IF (( length .GE. 2 )) THEN
                                 vname1=vname1(2:)
                              ELSE
                                 GO TO5672
                              END IF
                              length = length - 1
                           GO TO 5671
5672                       CONTINUE
                           DO 5681 Kconvert=1,lnblnk1(vname1)
                              CURSOR=ICHAR(vname1(Kconvert:Kconvert))
                              IF (((CURSOR.GE.97).AND.(CURSOR.LE.122)))
     *                        THEN
                                 CURSOR=CURSOR-32
                                 vname1(Kconvert:Kconvert)=CHAR(CURSOR)
                              END IF
5681                       CONTINUE
5682                       CONTINUE
                           IF ((INDEX(TEXT,vname1(:length)).NE.0)) THEN
                              WRITE(ERR,*) '************ERROR***********
     **'
                              WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGH
     *                        T(I)
                              WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
     *                         '<--COMMA INDICATES ANOTHER INPUT'
                              WRITE(ERR,*) 'SEARCHED NEXT LINE: ', TEXT(
     *                        :lnblnk1(TEXT))
                              WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETEC
     *TED'
                              ERROR_FLAG=1
                              ERROR_FLAGS(I)=1
                           END IF
                        END IF
5661                 CONTINUE
5662                 CONTINUE
                  GO TO 5631
5632              CONTINUE
               ELSE
                  GO TO5532
               END IF
               IVAL=IVAL+1
            GO TO 5531
5532        CONTINUE
            IF (((NVALUE(I).NE.0).AND.(NVALUE(I).NE.IVAL))) THEN
               IF (( error_level .GT. 0 )) THEN
                  WRITE (ERR,*) '*******************ERROR***************
     *****'
                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I)
                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)'
                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED'
               END IF
               ERROR_FLAG=1
               ERROR_FLAGS(I)=1
            ELSE
               NVALUE(I)=IVAL
            END IF
         END IF
         goto 5200
5240     IF (( error_level .GT. 0 )) THEN
            WRITE (ERR,*) '******************ERROR**********************
     **'
            WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUN
     *D'
            WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER'
            WRITE (ERR,*) 'VALUE SOUGHT: >>', VALUES_SOUGHT(I)(:lnblnk1(
     *      VALUES_SOUGHT(I))),'<<'
            WRITE (ERR,*) 'END DELIMETER: >>', DELIM_END(:lnblnk1(DELIM_
     *      END)),'<<'
         END IF
         ERROR_FLAG=1
         ERROR_FLAGS(I)=1
         goto 5200
5260     IF (( error_level .GT. 0 )) THEN
            WRITE (ERR,*) '******************ERROR**********************
     **'
            WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUN
     *D'
            WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER
     *'
            WRITE (ERR,*) 'VALUE SOUGHT: >>', VALUES_SOUGHT(I)(:lnblnk1(
     *      VALUES_SOUGHT(I))),'<<'
            WRITE (ERR,*) 'START DELIMETER: >>', DELIM_START(:lnblnk1(DE
     *      LIM_START)),'<<'
         END IF
         ERROR_FLAG=1
         ERROR_FLAGS(I)=1
         goto 5200
5400     IF (( error_level .GT. 0 )) THEN
            WRITE (ERR,*) '***************ERROR***************'
            IF ((IVAL.GT.1)) THEN
               J=IVAL
            ELSE
               J=1
            END IF
            WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(
     *      I)
            WRITE (ERR,*) 'LINE #',LINE
            WRITE (ERR,*) 'COULD NOT READ THE VALUE!!'
            WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...'
            WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR IN
     *PUT?'
         END IF
         ERROR_FLAG=1
         ERROR_FLAGS(I)=1
         GOTO 5200
5550     IF (( error_level .GT. 0 )) THEN
            WRITE (ERR,*) '***************ERROR***************'
            WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(
     *      I)
            WRITE (ERR,*) 'LINE #',LINE
            WRITE (ERR,*) 'COULD NOT READ THE STRING !!'
         END IF
         ERROR_FLAG=1
         ERROR_FLAGS(I)=1
5200     CONTINUE
5191  CONTINUE
5192  CONTINUE
      RETURN
5250  WRITE (ERR,*) '***************ERROR***************'
      WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE
      goto 5690
5690  CONTINUE
      ERROR_FLAG=1
      ERROR_FLAGS(I)=1
      RETURN
      entry get_input_set_error_level(the_level)
      error_level = the_level
      return
      END
      subroutine get_transport_parameter(ounit)
      implicit none
      character*80 line
      character*512 toUpper
      integer*4 ounit
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      COMMON/BOUNDS/ECUT( 1001),PCUT( 1001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      common/ET_control/ smaxir( 1001),estepe,ximax,  skindepth_for_bca,
     *transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,3), eno_array(200,3), eno_atbin_array(200,3), n_sh
     *ell(3), radc_flag,  ibcmp( 1001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(3), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),  e
     *ii_sh(40),  eii_nshells(100),  eii_nsh(3),  eii_first(3,50),  eii_
     *no(3,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/rayleigh_inputs/iray_ff_media(3),iray_ff_file(3)
      character*24 iray_ff_media
      character*128 iray_ff_file
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      integer*4 ival,num_ecut,num_pcut,num_smax,num_incoh,num_radc,num_c
     *oh,num_relax, num_pe_ang,num_brems_ang,num_brems_cs,num_pair_cs, n
     *um_ffmed,num_ffiles, num_pair_ang,num_eii,num_eii_L,num_estepe,num
     *_ximax,num_triplet, num_pxsec,num_pxsec_out, num_cxsec, num_photon
     *uc, num_photonuc_xsec, num_efield, num_bfield, num_emlmt, num_spin
     *,num_bca,num_alg,num_skin,itmp,iitmp,i,j,k,istart,iend, egs_open_f
     *ile,lnblnk1
      logical ecut_inregions,pcut_inregions,smax_inregions, incoh_inregi
     *ons,coh_inregions,relax_inregions, pe_inregions,aux_inregions,phot
     *onuc_inregions
      character*15 output_strings(14)
      save output_strings,line
      save ecut_inregions,pcut_inregions,smax_inregions, incoh_inregions
     *,coh_inregions,relax_inregions, pe_inregions,aux_inregions,photonu
     *c_inregions, num_photonuc
      DO 5701 k=1,80
         line(k:k) = '='
5701  CONTINUE
5702  CONTINUE
      delimeter = 'MC TRANSPORT PARAMETER'
      ival = 0
      ecut_inregions=.false.
      pcut_inregions=.false.
      smax_inregions=.false.
      incoh_inregions=.false.
      coh_inregions=.false.
      relax_inregions=.false.
      pe_inregions=.false.
      aux_inregions=.false.
      photonuc_inregions=.false.
      i_errors=15
      i_errors=egs_open_file(i_errors,0,1,'.errors')
      write(i_errors,*) ' If you are not trying to reset transport param
     *eters, '
      write(i_errors,*) ' ignore all the output until the message '
      write(i_errors,*) ' ******************** end input transport param
     *eter *********************** '
      write(i_errors,*)
      ival = ival + 1
      num_ecut = ival
      values_sought(ival) = 'Global ECUT'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      num_pcut = ival
      values_sought(ival) = 'Global PCUT'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      num_smax = ival
      values_sought(ival) = 'Global SMAX'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1e15
      default(ival) = 1e10
      ival = ival + 1
      num_incoh = ival
      values_sought(ival) = 'Bound Compton scattering'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      allowed_inputs(ival,4) = 'Simple'
      allowed_inputs(ival,5) = 'norej'
      ival = ival + 1
      num_radc = ival
      values_sought(ival) = 'Radiative Compton corrections'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_coh = ival
      values_sought(ival) = 'Rayleigh scattering'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      allowed_inputs(ival,4) = 'custom'
      ival = ival + 1
      num_relax = ival
      values_sought(ival) = 'Atomic relaxations'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      allowed_inputs(ival,4) = 'eadl'
      allowed_inputs(ival,5) = 'simple'
      ival = ival + 1
      num_pe_ang = ival
      values_sought(ival) = 'Photoelectron angular sampling'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      ival = ival + 1
      num_brems_ang = ival
      values_sought(ival) = 'Brems angular sampling'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Simple'
      allowed_inputs(ival,1) = 'KM'
      ival = ival + 1
      num_brems_cs = ival
      values_sought(ival) = 'Brems cross sections'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'BH'
      allowed_inputs(ival,1) = 'NIST'
      allowed_inputs(ival,2) = 'NRC'
      ival = ival + 1
      num_pair_ang = ival
      values_sought(ival) = 'Pair angular sampling'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'Simple'
      allowed_inputs(ival,2) = 'KM'
      allowed_inputs(ival,3) = 'Uniform'
      allowed_inputs(ival,4) = 'Blend'
      ival = ival + 1
      num_pair_cs = ival
      values_sought(ival) = 'Pair cross sections'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'BH'
      allowed_inputs(ival,1) = 'NRC'
      ival = ival + 1
      num_triplet = ival
      values_sought(ival) = 'Triplet production'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_spin = ival
      values_sought(ival) = 'Spin effects'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_eii = ival
      values_sought(ival) = 'Electron Impact Ionization'
      nvalue(ival) = 1
      type(ival) = 2
      ival = ival + 1
      num_eii_L= ival
      values_sought(ival) = 'scale L EII cross-sections'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0.0
      value_max(ival) = 1.0e+9
      default(ival) = 1.0
      ival = ival + 1
      num_estepe = ival
      values_sought(ival) = 'ESTEPE'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 1e-5
      value_max(ival) = 1
      default(ival) = 0.25
      ival = ival + 1
      num_ximax = ival
      values_sought(ival) = 'XImax'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1
      default(ival) = 0.5
      ival = ival + 1
      num_bca = ival
      values_sought(ival) = 'Boundary crossing algorithm'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Exact'
      allowed_inputs(ival,1) = 'PRESTA-I'
      ival = ival + 1
      num_skin = ival
      values_sought(ival) = 'Skin depth for BCA'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = -1
      value_max(ival) = 1e15
      default(ival) = 3
      ival = ival + 1
      num_alg = ival
      values_sought(ival) = 'Electron-step algorithm'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'PRESTA-II'
      allowed_inputs(ival,1) = 'PRESTA-I'
      ival = ival + 1
      num_pxsec = ival
      values_sought(ival) = 'Photon cross sections'
      nvalue(ival) = 1
      type(ival) = 2
      ival = ival + 1
      num_pxsec_out = ival
      values_sought(ival) = 'Photon cross-sections output'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_cxsec = ival
      values_sought(ival) = 'Compton cross sections'
      nvalue(ival) = 1
      type(ival) = 2
      ival = ival + 1
      num_efield = ival
      values_sought(ival) = 'Electric Field'
      nvalue(ival) = 3
      type(ival) = 1
      value_min(ival) = -1e15
      value_max(ival) = 1e15
      default(ival) = 0
      ival = ival + 1
      num_bfield = ival
      values_sought(ival) = 'Magnetic Field'
      nvalue(ival) = 3
      type(ival) = 1
      value_min(ival) = -1e10
      value_max(ival) = 1e10
      default(ival) = 0
      ival = ival + 1
      num_emlmt = ival
      values_sought(ival) = 'EM ESTEPE'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0.0
      value_max(ival) = 1.0
      default(ival) = 0.02
      ival = ival + 1
      num_photonuc = ival
      values_sought(ival) = 'Photonuclear attenuation'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      ival = ival + 1
      num_photonuc_xsec = ival
      values_sought(ival) = 'Photonuclear cross sections'
      nvalue(ival) = 1
      type(ival) = 2
      Nmin = num_ecut
      Nmax = num_photonuc_xsec
      CALL GET_INPUT
      IF (( error_flags(num_ecut) .EQ. 0 )) THEN
         DO 5711 j=1, 1001
            ecut(j) = value(num_ecut,1)
5711     CONTINUE
5712     CONTINUE
      END IF
      IF (( error_flags(num_pcut) .EQ. 0 )) THEN
         DO 5721 j=1, 1001
            pcut(j) = value(num_pcut,1)
5721     CONTINUE
5722     CONTINUE
      END IF
      IF (( error_flags(num_smax) .EQ. 0 )) THEN
         DO 5731 j=1, 1001
            smaxir(j) = value(num_smax,1)
5731     CONTINUE
5732     CONTINUE
      END IF
      IF (( error_flags(num_brems_ang) .EQ. 0 )) THEN
         ibrdst = value(num_brems_ang,1)
      END IF
      IF (( error_flags(num_brems_cs) .EQ. 0 )) THEN
         ibr_nist = value(num_brems_cs,1)
      END IF
      IF (( error_flags(num_radc) .EQ. 0 )) THEN
         radc_flag = value(num_radc,1)
      END IF
      IF (( error_flags(num_pair_ang) .EQ. 0 )) THEN
         iprdst = value(num_pair_ang,1)
      END IF
      IF (( error_flags(num_pair_cs) .EQ. 0 )) THEN
         pair_nrc = value(num_pair_cs,1)
      END IF
      IF (( error_flags(num_triplet) .EQ. 0 )) THEN
         itriplet = value(num_triplet,1)
      END IF
      IF (( error_flags(num_eii_L) .EQ. 0 )) THEN
         eii_L_factor = value(num_eii_L,1)
      END IF
      IF (( error_flags(num_estepe) .EQ. 0 )) THEN
         estepe = value(num_estepe,1)
      END IF
      IF (( error_flags(num_ximax) .EQ. 0 )) THEN
         ximax = value(num_ximax,1)
      END IF
      IF (( error_flags(num_bca) .EQ. 0 )) THEN
         bca_algorithm = value(num_bca,1)
         IF (( bca_algorithm .EQ. 0 )) THEN
            exact_bca = .true.
         END IF
      END IF
      IF (( error_flags(num_alg) .EQ. 0 )) THEN
         transport_algorithm = value(num_alg,1)
      END IF
      IF (( error_flags(num_skin) .EQ. 0 )) THEN
         skindepth_for_bca = value(num_skin,1)
      END IF
      IF (( error_flags(num_spin) .EQ. 0 )) THEN
         itmp = value(num_spin,1)
         IF (( itmp .EQ. 1 )) THEN
            spin_effects = .true.
         ELSE
            spin_effects = .false.
         END IF
      END IF
      IF (( error_flags(num_eii) .EQ. 0 )) THEN
         eii_xfile = char_value(num_eii,1)
         eii_flag=1
         IF ((toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'ON' .OR. toUpp
     *   er(eii_xfile(:lnblnk1(eii_xfile))).eq.'IK' )) THEN
            eii_xfile = 'ik'
            write(6,*) '==> Using default EII data compilation ', eii_xf
     *      ile(:lnblnk1(eii_xfile))
            write(1,*) '==> Using default EII data compilation ', eii_xf
     *      ile(:lnblnk1(eii_xfile))
         ELSE IF((toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'OFF')) THE
     *   N
            eii_xfile='Off'
            eii_flag=0
         ELSE
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,*) '==> Using non-default EII data compilation '
     *      , eii_xfile(:lnblnk1(eii_xfile))
         END IF
      END IF
      IF (( error_flags(num_pxsec) .EQ. 0 )) THEN
         photon_xsections = char_value(num_pxsec,1)
         IF (( toUpper( photon_xsections(:lnblnk1(photon_xsections)) ) .
     *   EQ. 'MCDF-XCOM' )) THEN
            mcdf_pe_xsections = .true.
            photon_xsections = 'xcom'
         ELSE IF(( toUpper( photon_xsections(:lnblnk1(photon_xsections))
     *    ) .EQ. 'MCDF-EPDL' )) THEN
            mcdf_pe_xsections = .true.
            photon_xsections = 'epdl'
         ELSE
            mcdf_pe_xsections = .false.
         END IF
      END IF
      IF (( error_flags(num_pxsec_out) .EQ. 0 )) THEN
         xsec_out = value(num_pxsec_out,1)
      END IF
      IF (( error_flags(num_cxsec) .EQ. 0 )) THEN
         comp_xsections = char_value(num_cxsec,1)
      END IF
      IF (( error_flags(num_photonuc_xsec) .EQ. 0 )) THEN
         photonuc_xsections = char_value(num_photonuc_xsec,1)
      END IF
      IF (( error_flags(num_efield) .EQ. 0 )) THEN
         ExIN = value(num_efield,1)
         EyIN = value(num_efield,2)
         EzIN = value(num_efield,3)
         IF (( error_flags(num_emlmt) .EQ. 0 )) THEN
            EMLMTIN=value(num_emlmt,1)
         END IF
         IF (( ExIN**2+EyIN**2+EzIN**2 .GT. 0 )) THEN
            emfield_on=.true.
         END IF
      END IF
      IF (( error_flags(num_bfield) .EQ. 0 )) THEN
         BxIN = value(num_bfield,1)
         ByIN = value(num_bfield,2)
         BzIN = value(num_bfield,3)
         Bx=BxIN
         By=ByIN
         Bz=BzIN
         Bx_new=BxIN
         By_new=ByIN
         Bz_new=BzIN
         IF (( error_flags(num_emlmt) .EQ. 0 )) THEN
            EMLMTIN=value(num_emlmt,1)
         END IF
         IF (( BxIN**2+ByIN**2+BzIN**2 .GT. 0 )) THEN
            emfield_on=.true.
         END IF
      END IF
      IF (( error_flags(num_coh) .EQ. 0 )) THEN
         IF ((value(num_coh,1) .EQ. 4)) THEN
            write(*,'(/a/)') ' ===> custom ff requested!'
            ival = ival + 1
            num_ffmed = ival
            values_sought(ival) = 'ff media names'
            type(ival) = 2
            nvalue(ival) = 0
            ival = ival + 1
            num_ffiles = ival
            values_sought(ival) = 'ff file names'
            type(ival) = 2
            nvalue(ival) = 0
            Nmin = num_ffmed
            Nmax = num_ffiles
            CALL GET_INPUT
            IF (( error_flags(num_ffmed) .GT. 0 )) THEN
               write(i_log,'(/a)') '***************** Error: '
               write(i_log,'(a/,a,I3)') 'Error reading custom ff! Termin
     *ating ...', ' error_flag = ', error_flags(num_ffmed)
               write(i_log,'(/a)') '***************** Quiting now.'
               call exit(1)
            END IF
            IF (( error_flags(num_ffiles) .GT. 0 )) THEN
               write(i_log,'(/a)') '***************** Error: '
               write(i_log,'(a/,a,I3)') 'Error reading ff file names! Te
     *rminating ...', ' error_flag = ', error_flags(num_ffiles)
               write(i_log,'(/a)') '***************** Quiting now.'
               call exit(1)
            END IF
            IF ((nvalue(num_ffmed).GT.3)) THEN
               write(i_log,'(/a)') '***************** Error: '
               write(i_log,'(a,a,i3,a)') '***** Number of media with cus
     *tom ff larger ', 'than maximum number of media $MXMED = ',3, ' inc
     *rease $MXMED and try again!!!'
               write(i_log,'(/a)') '***************** Quiting now.'
               call exit(1)
            END IF
            DO 5741 i=1,nvalue(num_ffmed)
               iray_ff_media(i) = char_value(num_ffmed,i)
               iray_ff_file(i) = char_value(num_ffiles,i)
5741        CONTINUE
5742        CONTINUE
            value(num_coh,1) = 1
         END IF
         write(*,'(/)')
      END IF
      aux_inregions = .false.
      IF (( error_flags(num_incoh) .EQ. 0 )) THEN
         write(i_log,*) 'Bound Compton start region'
         itmp = value(num_incoh,1)
         IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
            ival = ival + 1
            values_sought(ival) = 'Bound Compton start region'
            nvalue(ival) = 0
            type(ival) = 0
            value_min(ival) = 1
            value_max(ival) =  1001
            default(ival) = 1
            ival = ival + 1
            values_sought(ival) = 'Bound Compton stop region'
            nvalue(ival) = 0
            type(ival) = 0
            value_min(ival) = 1
            value_max(ival) =  1001
            default(ival) = 1
            Nmin = ival-1
            Nmax = ival
            CALL GET_INPUT
            IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ
     *      . 0 )) THEN
               IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
                  iitmp = itmp-2
                  DO 5751 j=1, 1001
                     ibcmp(j) = iitmp
5751              CONTINUE
5752              CONTINUE
                  iitmp = 1 - iitmp
                  DO 5761 k=1,nvalue(ival)
                     istart = value(ival-1,k)
                     iend = value(ival,k)
                     write(i_log,*) 'Bound Compton start region',istart
                     write(i_log,*) 'Bound Compton stop region',iend
                     IF (( istart .LE. iend )) THEN
                        DO 5771 j=istart,iend
                           ibcmp(j) = iitmp
5771                    CONTINUE
5772                    CONTINUE
                        aux_inregions = .true.
                     END IF
5761              CONTINUE
5762              CONTINUE
               ELSE
                  value(num_incoh,1) = ibcmp(1)
               END IF
            ELSE
               value(num_incoh,1) = ibcmp(1)
            END IF
         ELSE
            IF((itmp .GT. 3))itmp = itmp-2
            write(i_log,*) ' Setting all to ',itmp
            DO 5781 j=1, 1001
               ibcmp(j) = itmp
5781        CONTINUE
5782        CONTINUE
         END IF
      ELSE
         IF ((ibcmp(1) .EQ. 2 .OR. ibcmp(1) .EQ. 3)) THEN
            value(num_incoh,1) = ibcmp(1)+2
         ELSE
            value(num_incoh,1) = ibcmp(1)
         END IF
      END IF
      incoh_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_coh) .EQ. 0 )) THEN
         write(i_log,*) 'Rayleigh start region'
         itmp = value(num_coh,1)
         IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
            ival = ival + 1
            values_sought(ival) = 'Rayleigh start region'
            nvalue(ival) = 0
            type(ival) = 0
            value_min(ival) = 1
            value_max(ival) =  1001
            default(ival) = 1
            ival = ival + 1
            values_sought(ival) = 'Rayleigh stop region'
            nvalue(ival) = 0
            type(ival) = 0
            value_min(ival) = 1
            value_max(ival) =  1001
            default(ival) = 1
            Nmin = ival-1
            Nmax = ival
            CALL GET_INPUT
            IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ
     *      . 0 )) THEN
               IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
                  iitmp = itmp-2
                  DO 5791 j=1, 1001
                     iraylr(j) = iitmp
5791              CONTINUE
5792              CONTINUE
                  iitmp = 1 - iitmp
                  DO 5801 k=1,nvalue(ival)
                     istart = value(ival-1,k)
                     iend = value(ival,k)
                     write(i_log,*) 'Rayleigh start region',istart
                     write(i_log,*) 'Rayleigh stop region',iend
                     IF (( istart .LE. iend )) THEN
                        DO 5811 j=istart,iend
                           iraylr(j) = iitmp
5811                    CONTINUE
5812                    CONTINUE
                        aux_inregions = .true.
                     END IF
5801              CONTINUE
5802              CONTINUE
               ELSE
                  value(num_coh,1) = iraylr(1)
               END IF
            ELSE
               value(num_coh,1) = iraylr(1)
            END IF
         ELSE
            IF((itmp .GT. 3))itmp = itmp-2
            write(i_log,*) ' Setting all to ',itmp
            DO 5821 j=1, 1001
               iraylr(j) = itmp
5821        CONTINUE
5822        CONTINUE
         END IF
      ELSE
         IF ((iraylr(1) .EQ. 2 .OR. iraylr(1) .EQ. 3)) THEN
            value(num_coh,1) = iraylr(1)+2
         ELSE
            value(num_coh,1) = iraylr(1)
         END IF
      END IF
      coh_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_relax) .EQ. 0 )) THEN
         write(i_log,*) 'Relaxations start region'
         itmp = value(num_relax,1)
         IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
            ival = ival + 1
            values_sought(ival) = 'Relaxations start region'
            nvalue(ival) = 0
            type(ival) = 0
            value_min(ival) = 1
            value_max(ival) =  1001
            default(ival) = 1
            ival = ival + 1
            values_sought(ival) = 'Relaxations stop region'
            nvalue(ival) = 0
            type(ival) = 0
            value_min(ival) = 1
            value_max(ival) =  1001
            default(ival) = 1
            Nmin = ival-1
            Nmax = ival
            CALL GET_INPUT
            IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ
     *      . 0 )) THEN
               IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
                  iitmp = itmp-2
                  DO 5831 j=1, 1001
                     iedgfl(j) = iitmp
5831              CONTINUE
5832              CONTINUE
                  iitmp = 1 - iitmp
                  DO 5841 k=1,nvalue(ival)
                     istart = value(ival-1,k)
                     iend = value(ival,k)
                     write(i_log,*) 'Relaxations start region',istart
                     write(i_log,*) 'Relaxations stop region',iend
                     IF (( istart .LE. iend )) THEN
                        DO 5851 j=istart,iend
                           iedgfl(j) = iitmp
5851                    CONTINUE
5852                    CONTINUE
                        aux_inregions = .true.
                     END IF
5841              CONTINUE
5842              CONTINUE
               ELSE
                  value(num_relax,1) = iedgfl(1)
               END IF
            ELSE
               value(num_relax,1) = iedgfl(1)
            END IF
         ELSE
            IF((itmp .GT. 3))itmp = itmp-2
            write(i_log,*) ' Setting all to ',itmp
            DO 5861 j=1, 1001
               iedgfl(j) = itmp
5861        CONTINUE
5862        CONTINUE
         END IF
      ELSE
         IF ((iedgfl(1) .EQ. 2 .OR. iedgfl(1) .EQ. 3)) THEN
            value(num_relax,1) = iedgfl(1)+2
         ELSE
            value(num_relax,1) = iedgfl(1)
         END IF
      END IF
      relax_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_pe_ang) .EQ. 0 )) THEN
         write(i_log,*) 'PE sampling start region'
         itmp = value(num_pe_ang,1)
         IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
            ival = ival + 1
            values_sought(ival) = 'PE sampling start region'
            nvalue(ival) = 0
            type(ival) = 0
            value_min(ival) = 1
            value_max(ival) =  1001
            default(ival) = 1
            ival = ival + 1
            values_sought(ival) = 'PE sampling stop region'
            nvalue(ival) = 0
            type(ival) = 0
            value_min(ival) = 1
            value_max(ival) =  1001
            default(ival) = 1
            Nmin = ival-1
            Nmax = ival
            CALL GET_INPUT
            IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ
     *      . 0 )) THEN
               IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
                  iitmp = itmp-2
                  DO 5871 j=1, 1001
                     iphter(j) = iitmp
5871              CONTINUE
5872              CONTINUE
                  iitmp = 1 - iitmp
                  DO 5881 k=1,nvalue(ival)
                     istart = value(ival-1,k)
                     iend = value(ival,k)
                     write(i_log,*) 'PE sampling start region',istart
                     write(i_log,*) 'PE sampling stop region',iend
                     IF (( istart .LE. iend )) THEN
                        DO 5891 j=istart,iend
                           iphter(j) = iitmp
5891                    CONTINUE
5892                    CONTINUE
                        aux_inregions = .true.
                     END IF
5881              CONTINUE
5882              CONTINUE
               ELSE
                  value(num_pe_ang,1) = iphter(1)
               END IF
            ELSE
               value(num_pe_ang,1) = iphter(1)
            END IF
         ELSE
            IF((itmp .GT. 3))itmp = itmp-2
            write(i_log,*) ' Setting all to ',itmp
            DO 5901 j=1, 1001
               iphter(j) = itmp
5901        CONTINUE
5902        CONTINUE
         END IF
      ELSE
         IF ((iphter(1) .EQ. 2 .OR. iphter(1) .EQ. 3)) THEN
            value(num_pe_ang,1) = iphter(1)+2
         ELSE
            value(num_pe_ang,1) = iphter(1)
         END IF
      END IF
      pe_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_photonuc) .EQ. 0 )) THEN
         write(i_log,*) 'Photonuclear start region'
         itmp = value(num_photonuc,1)
         IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
            ival = ival + 1
            values_sought(ival) = 'Photonuclear start region'
            nvalue(ival) = 0
            type(ival) = 0
            value_min(ival) = 1
            value_max(ival) =  1001
            default(ival) = 1
            ival = ival + 1
            values_sought(ival) = 'Photonuclear stop region'
            nvalue(ival) = 0
            type(ival) = 0
            value_min(ival) = 1
            value_max(ival) =  1001
            default(ival) = 1
            Nmin = ival-1
            Nmax = ival
            CALL GET_INPUT
            IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ
     *      . 0 )) THEN
               IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
                  iitmp = itmp-2
                  DO 5911 j=1, 1001
                     iphotonucr(j) = iitmp
5911              CONTINUE
5912              CONTINUE
                  iitmp = 1 - iitmp
                  DO 5921 k=1,nvalue(ival)
                     istart = value(ival-1,k)
                     iend = value(ival,k)
                     write(i_log,*) 'Photonuclear start region',istart
                     write(i_log,*) 'Photonuclear stop region',iend
                     IF (( istart .LE. iend )) THEN
                        DO 5931 j=istart,iend
                           iphotonucr(j) = iitmp
5931                    CONTINUE
5932                    CONTINUE
                        aux_inregions = .true.
                     END IF
5921              CONTINUE
5922              CONTINUE
               ELSE
                  value(num_photonuc,1) = iphotonucr(1)
               END IF
            ELSE
               value(num_photonuc,1) = iphotonucr(1)
            END IF
         ELSE
            IF((itmp .GT. 3))itmp = itmp-2
            write(i_log,*) ' Setting all to ',itmp
            DO 5941 j=1, 1001
               iphotonucr(j) = itmp
5941        CONTINUE
5942        CONTINUE
         END IF
      ELSE
         IF ((iphotonucr(1) .EQ. 2 .OR. iphotonucr(1) .EQ. 3)) THEN
            value(num_photonuc,1) = iphotonucr(1)+2
         ELSE
            value(num_photonuc,1) = iphotonucr(1)
         END IF
      END IF
      photonuc_inregions = aux_inregions
      aux_inregions = .false.
      ival = ival + 1
      num_ecut = ival
      values_sought(ival) = 'Set ECUT'
      nvalue(ival) = 0
      type(ival) = 1
      value_min(ival) = 0.
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      values_sought(ival) = 'Set ECUT start region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  1001
      default(ival) = 1
      ival = ival + 1
      values_sought(ival) = 'Set ECUT stop region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  1001
      default(ival) = 1
      Nmin = num_ecut
      Nmax = num_ecut+2
      error_flag = 0
      CALL GET_INPUT
      IF (( error_flag .EQ. 0 )) THEN
         IF (( nvalue(num_ecut) .EQ. nvalue(ival) .AND. nvalue(ival-1) .
     *   EQ. nvalue(ival) )) THEN
            DO 5951 k=1,nvalue(ival)
               istart = value(ival-1,k)
               iend = value(ival,k)
               IF (( istart .LE. iend )) THEN
                  DO 5961 j=istart,iend
                     ecut(j) = value(num_ecut,k)
5961              CONTINUE
5962              CONTINUE
                  aux_inregions = .true.
               END IF
5951        CONTINUE
5952        CONTINUE
         END IF
      END IF
      ecut_inregions = aux_inregions
      aux_inregions = .false.
      ival = ival + 1
      num_pcut = ival
      values_sought(ival) = 'Set PCUT'
      nvalue(ival) = 0
      type(ival) = 1
      value_min(ival) = 0.
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      values_sought(ival) = 'Set PCUT start region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  1001
      default(ival) = 1
      ival = ival + 1
      values_sought(ival) = 'Set PCUT stop region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  1001
      default(ival) = 1
      Nmin = num_pcut
      Nmax = num_pcut+2
      error_flag = 0
      CALL GET_INPUT
      IF (( error_flag .EQ. 0 )) THEN
         IF (( nvalue(num_pcut) .EQ. nvalue(ival) .AND. nvalue(ival-1) .
     *   EQ. nvalue(ival) )) THEN
            DO 5971 k=1,nvalue(ival)
               istart = value(ival-1,k)
               iend = value(ival,k)
               IF (( istart .LE. iend )) THEN
                  DO 5981 j=istart,iend
                     pcut(j) = value(num_pcut,k)
5981              CONTINUE
5982              CONTINUE
                  aux_inregions = .true.
               END IF
5971        CONTINUE
5972        CONTINUE
         END IF
      END IF
      pcut_inregions = aux_inregions
      aux_inregions = .false.
      ival = ival + 1
      num_smax = ival
      values_sought(ival) = 'Set SMAX'
      nvalue(ival) = 0
      type(ival) = 1
      value_min(ival) = 0.
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      values_sought(ival) = 'Set SMAX start region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  1001
      default(ival) = 1
      ival = ival + 1
      values_sought(ival) = 'Set SMAX stop region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) =  1001
      default(ival) = 1
      Nmin = num_smax
      Nmax = num_smax+2
      error_flag = 0
      CALL GET_INPUT
      IF (( error_flag .EQ. 0 )) THEN
         IF (( nvalue(num_smax) .EQ. nvalue(ival) .AND. nvalue(ival-1) .
     *   EQ. nvalue(ival) )) THEN
            DO 5991 k=1,nvalue(ival)
               istart = value(ival-1,k)
               iend = value(ival,k)
               IF (( istart .LE. iend )) THEN
                  DO 6001 j=istart,iend
                     smaxir(j) = value(num_smax,k)
6001              CONTINUE
6002              CONTINUE
                  aux_inregions = .true.
               END IF
5991        CONTINUE
5992        CONTINUE
         END IF
      END IF
      smax_inregions = aux_inregions
      write(i_errors,*)
      write(i_errors,*) ' ******************** end input transport param
     *eter *********************** '
      write(i_errors,*)
      IF ((value(num_relax,1) .GT. 0 .AND. value(num_relax,1) .LT. 5)) T
     *HEN
         eadl_relax = .true.
         IF ((value(num_relax,1) .EQ. 1)) THEN
            value(num_relax,1)=4
         END IF
      ELSE
         IF ((mcdf_pe_xsections .AND. value(num_relax,1) .EQ. 5)) THEN
            eadl_relax = .true.
            value(num_relax,1)=4
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,'(a/,a/,a/)') '    Simplified atomic relaxation
     *not allowed', '    with shellwise PE cross sections. Resetting', '
     *    to detailed EADL atomic relaxation!!!'
         ELSE
            eadl_relax = .false.
         END IF
      END IF
      output_strings(1) = allowed_inputs(num_pair_ang,iprdst)
      itmp = value(num_incoh,1)
      output_strings(2) = allowed_inputs(num_incoh,itmp)
      IF (( radc_flag .EQ. 1 )) THEN
         write(i_log,'(/a)') '***************** Warning: '
         write(i_log,*) 'You are trying to use radiative Compton correct
     *ions'
         write(6,*) 'without having included rad_compton1.mortran'
         write(1,*) 'without having included rad_compton1.mortran'
         write(6,'(a//)') 'Turning radiative Compton corrections OFF ...
     *'
         write(1,'(a//)') 'Turning radiative Compton corrections OFF ...
     *'
         radc_flag = 0
      END IF
      output_strings(12) = allowed_inputs(num_radc,radc_flag)
      itmp = value(num_coh,1)
      output_strings(3) = allowed_inputs(num_coh,itmp)
      itmp = value(num_relax,1)
      output_strings(4) = allowed_inputs(num_relax,itmp)
      itmp = value(num_pe_ang,1)
      output_strings(5) = allowed_inputs(num_pe_ang,itmp)
      output_strings(6) = allowed_inputs(num_brems_ang,ibrdst)
      output_strings(7) = allowed_inputs(num_bca,bca_algorithm)
      output_strings(8) = allowed_inputs(num_alg,transport_algorithm)
      output_strings(9) = allowed_inputs(num_brems_cs,ibr_nist)
      output_strings(10) = allowed_inputs(num_pair_cs,pair_nrc)
      output_strings(11) = allowed_inputs(num_triplet,itriplet)
      itmp = value(num_photonuc,1)
      output_strings(14) = allowed_inputs(num_photonuc,itmp)
      entry show_transport_parameter(ounit)
      IF((ounit .LE. 0))return
      write(ounit,*)
      write(ounit,'(a)') line
      write(ounit,*)
      write(ounit,'(a,/)') '                   Electron/Photon transport
     * parameter'
      write(ounit,'(a,/)') line
      write(ounit,'(a,38x,a)') ' Photon cross sections', photon_xsection
     *s(:lnblnk1(photon_xsections))
      write(ounit,'(a,37x,a)') ' Compton cross sections', comp_xsections
     *(:lnblnk1(comp_xsections))
      write(ounit,'(a,$)') ' Photon transport cutoff(MeV)'
      IF (( pcut_inregions )) THEN
         write(ounit,'(32x,a)') 'Set in regions'
      ELSE
         IF (( pcut(1) .GT. 1e-4 )) THEN
            write(ounit,'(32x,g14.4)') pcut(1)
         ELSE
            write(ounit,'(32x,a)') 'AP(medium)'
         END IF
      END IF
      write(ounit,'(a,39x,a3)') ' Pair angular sampling',output_strings(
     *1)
      write(ounit,'(a,41x,a3)') ' Pair cross sections',output_strings(10
     *)
      write(ounit,'(a,42x,a3)') ' Triplet production',output_strings(11)
      write(ounit,'(a,36x,a14)') ' Bound Compton scattering',output_stri
     *ngs(2)
      write(ounit,'(a,31x,a14)') ' Radiative Compton corrections',output
     *_strings(12)
      write(ounit,'(a,41x,a14)') ' Rayleigh scattering',output_strings(3
     *)
      write(ounit,'(a,42x,a14)') ' Atomic relaxations',output_strings(4)
      write(ounit,'(a,30x,a14)') ' Photoelectron angular sampling',outpu
     *t_strings(5)
      IF (( value(num_photonuc,1) .GT. 0 )) THEN
         write(ounit,'(a,36x,a14)') ' Photonuclear attenuation',output_s
     *   trings(14)
         write(ounit,'(a,33x,a)') ' Photonuclear cross sections', photon
     *   uc_xsections(:lnblnk1(photonuc_xsections))
      END IF
      write(ounit,*)
      write(ounit,'(a,$)') ' Electron transport cutoff(MeV)'
      IF (( ecut_inregions )) THEN
         write(ounit,'(30x,a)') 'Set in regions'
      ELSE
         IF (( ecut(1) .GT. 1e-4 )) THEN
            write(ounit,'(30x,f7.4)') ecut(1)
         ELSE
            write(ounit,'(30x,a)') 'AE(medium)'
         END IF
      END IF
      write(ounit,'(a,30x,a4)') ' Bremsstrahlung cross sections',output_
     *strings(9)
      write(ounit,'(a,29x,a3)') ' Bremsstrahlung angular sampling',outpu
     *t_strings(6)
      IF (( spin_effects )) THEN
         write(ounit,'(a,48x,a)') ' Spin effects','On'
      ELSE
         write(ounit,'(a,48x,a)') ' Spin effects','Off'
      END IF
      write(ounit,'(a,34x,a)') ' Electron Impact Ionization',eii_xfile(:
     *lnblnk1(eii_xfile))
      IF ((eii_L_factor .NE. 1.0)) THEN
         write(ounit,'(a,25x,f6.4)') ' L-shell EII xsections scaling fac
     *tor',eii_L_factor
      END IF
      write(ounit,'(a,$)') ' Maxium electron step in cm (SMAX)'
      IF (( smax_inregions )) THEN
         write(ounit,'(27x,a)') 'Set in regions'
      ELSE
         IF (( smaxir(1) .GT. 1e-4 )) THEN
            write(ounit,'(27x,g14.4)') smaxir(1)
         ELSE
            write(ounit,'(27x,a)') 'Restriction is off'
         END IF
      END IF
      write(ounit,'(a,16x,f6.4)') ' Maximum fractional energy loss/step
     *(ESTEPE)',estepe
      write(ounit,'(a,21x,f6.4)') ' Maximum 1st elastic moment/step (XIM
     *AX)',ximax
      write(ounit,'(a,33x,a10)') ' Boundary crossing algorithm',output_s
     *trings(7)
      write(ounit,'(a,22x,g9.4)') ' Skin-depth for boundary crossing (MF
     *P)',skindepth_for_bca
      write(ounit,'(a,37x,a10)') ' Electron-step algorithm',output_strin
     *gs(8)
      IF (( ExIN.NE.0 .OR. EyIN.NE.0 .OR. EzIN.NE.0 )) THEN
         write(ounit,'(a,38x,3f10.2)') ' Electric Field [V/cm]', ExIN,Ey
     *   IN,EzIN
      END IF
      IF (( Bx.NE.0 .OR. By.NE.0 .OR. Bz.NE.0 )) THEN
         write(ounit,'(a,41x,3f10.2)') ' Magnetic Field [T]', Bx,By,Bz
      END IF
      IF (( ExIN.NE.0 .OR. EyIN.NE.0 .OR. EzIN.NE.0 .OR. Bx.NE.0 .OR. By
     *.NE.0 .OR. Bz.NE.0 )) THEN
         write(ounit,'(a,50x,f10.2)') ' EM ESTEPE',EMLMTIN
      END IF
      write(ounit,*)
      write(ounit,'(a)') line
      write(ounit,*)
      return
      end
      subroutine set_elastic_parameter
      implicit none
      integer*4 ounit
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 imed,ival,lnblnk1,nchanged
      character*24 medname
      ounit = i_log
      ounit = i_log
      delimeter = 'MC TRANSPORT PARAMETER'
      call get_input_set_error_level(0)
      ival = 0
      DO 6011 imed=1,nmed
         call egs_get_medium_name(imed,medname)
         ival = ival + 1
         values_sought(ival) = 'scale elastic scattering in '// medname(
     *   :lnblnk1(medname))
         nvalue(ival) = 1
         type(ival) = 1
         value_min(ival) = 1e-3
         value_max(ival) = 1e3
         default(ival) = 1
6011  CONTINUE
6012  CONTINUE
      Nmin = 1
      Nmax = nmed
      CALL GET_INPUT
      nchanged = 0
      DO 6021 imed=1,nmed
         IF((error_flags(imed) .EQ. 0))nchanged = nchanged + 1
6021  CONTINUE
6022  CONTINUE
      IF (( nchanged .GT. 0 )) THEN
         write(ounit,'(//a)') '================ Elastic scattering scale
     *d as follows =================='
         DO 6031 imed=1,nmed
            IF (( error_flags(imed) .EQ. 0 )) THEN
               call egs_get_medium_name(imed,medname)
               xcc(imed) = xcc(imed)*value(imed,1)
               blcc(imed) = blcc(imed)*value(imed,1)
               write(ounit,'(a,t30,f10.6)') medname(:lnblnk1(medname)),
     *         value(imed,1)
            END IF
6031     CONTINUE
6032     CONTINUE
         write(ounit,'(a//)') '=========================================
     *==============================='
      END IF
      return
      end
      SUBROUTINE GET_INPUT_PLUS(UNITNUM,DELIM_START,DELIM_END)
      IMPLICIT NONE
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      CHARACTER*256 TEXT
      CHARACTER*256 KEEPTEXT
      CHARACTER*256 ORIGTEXT
      CHARACTER*256 TEXTPIECE
      CHARACTER*80 DELIM_START
      CHARACTER*80 DELIM_END
      CHARACTER*80 ENDSTRING
      CHARACTER*64 VNAME
      CHARACTER*64 VNAME1
      integer*4 CURSOR
      integer*4 IINDEX
      integer*4 iVNAME
      integer*4 IVAL
      integer*4 UNITNUM
      integer*4 ERR
      integer*4 I,J,K,CHECK
      integer*4 LINE
      integer*4 INT_VALUE
      integer*4 INT_VALUE_MIN
      integer*4 INT_VALUE_MAX
      logical ALLOWED
      logical START_FOUND
      integer*4 ifound,length,lll,Kconvert
      integer*4 lnblnk1
      logical IDEBUG,end_string
      character*1 blank
      integer*4 error_level
      integer*4 the_level
      data blank/' '/
      data error_level/1/
      save error_level
      IDEBUG = .false.
      ERROR_FLAG = 0
      IF ((IDEBUG)) THEN
         WRITE(6,6040)NMIN,NMAX, 100
6040     FORMAT(' Entering get_inputs seeking values', I5,' to', I5, 'wi
     *th a max allowed of',I5)
      END IF
      IF ((NMAX .LT. NMIN .OR. NMAX .GT. 100)) THEN
         WRITE(6,6050)NMAX, NMIN, 100
6050     FORMAT(//' Error entering get_inputs: Asked for values from',I5
     *,' to',I5, '    with a max of',I5//' This implies a bug in thecall
     *ing routine'/ ' Fix it up and try again.  Stopping now.')
         STOP
      END IF
      ERR=i_errors
      DELIM_START=DELIM_START(:lnblnk1(DELIM_START))
      DELIM_END=DELIM_END(:lnblnk1(DELIM_END))
      length = len(DELIM_START)
6061  IF(index(DELIM_START,blank).NE.1)GO TO 6062
         IF (( length .GE. 2 )) THEN
            DELIM_START=DELIM_START(2:)
         ELSE
            GO TO6062
         END IF
         length = length - 1
      GO TO 6061
6062  CONTINUE
      length = len(DELIM_END)
6071  IF(index(DELIM_END,blank).NE.1)GO TO 6072
         IF (( length .GE. 2 )) THEN
            DELIM_END=DELIM_END(2:)
         ELSE
            GO TO6072
         END IF
         length = length - 1
      GO TO 6071
6072  CONTINUE
      DO 6081 Kconvert=1,lnblnk1(DELIM_START)
         CURSOR=ICHAR(DELIM_START(Kconvert:Kconvert))
         IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
            CURSOR=CURSOR-32
            DELIM_START(Kconvert:Kconvert)=CHAR(CURSOR)
         END IF
6081  CONTINUE
6082  CONTINUE
      DO 6091 Kconvert=1,lnblnk1(DELIM_END)
         CURSOR=ICHAR(DELIM_END(Kconvert:Kconvert))
         IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
            CURSOR=CURSOR-32
            DELIM_END(Kconvert:Kconvert)=CHAR(CURSOR)
         END IF
6091  CONTINUE
6092  CONTINUE
      length = len(ENDSTRING)
6101  IF(index(ENDSTRING,blank).NE.1)GO TO 6102
         IF (( length .GE. 2 )) THEN
            ENDSTRING=ENDSTRING(2:)
         ELSE
            GO TO6102
         END IF
         length = length - 1
      GO TO 6101
6102  CONTINUE
      IF ((ENDSTRING.EQ.blank)) THEN
         end_string=.false.
      ELSE
         DO 6111 Kconvert=1,lnblnk1(ENDSTRING)
            CURSOR=ICHAR(ENDSTRING(Kconvert:Kconvert))
            IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
               CURSOR=CURSOR-32
               ENDSTRING(Kconvert:Kconvert)=CHAR(CURSOR)
            END IF
6111     CONTINUE
6112     CONTINUE
         end_string=.false.
      END IF
      IF ((IDEBUG)) THEN
         WRITE(6,6120)DELIM_START,DELIM_END
6120     FORMAT(' start and stop delimeters are:'/ A/A/)
      END IF
      DO 6131 I=NMIN,NMAX
         REWIND (UNITNUM)
         LINE=0
         CHECK=0
         ERROR_FLAGS(I)=0
         IF ((TYPE(I) .EQ. 0 .OR. TYPE(I) .EQ. 1)) THEN
            VALUE(I,1) = DEFAULT(I)
         END IF
         IF ((TYPE(I) .EQ. 3)) THEN
            VALUE(I,1) = 0
         END IF
         VNAME=VALUES_SOUGHT(I)
         iVNAME=lnblnk1(VNAME)
         IF (( ivname .LT. 1 )) THEN
            IF (( error_level .GT. 0 )) THEN
               write(ERR,*) ' ======================= Warning ==========
     *=========== '
               write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs
     *()!         '
               write(ERR,*) ' ==========================================
     *=========== '
            END IF
            ERROR_FLAG=1
            ERROR_FLAGS(I)=1
            goto 5200
         END IF
         DO 6141 Kconvert=1,lnblnk1(vname)
            CURSOR=ICHAR(vname(Kconvert:Kconvert))
            IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
               CURSOR=CURSOR-32
               vname(Kconvert:Kconvert)=CHAR(CURSOR)
            END IF
6141     CONTINUE
6142     CONTINUE
         iindex = 0
         IF ((DELIM_START .EQ. 'NONE')) THEN
            start_found = .true.
         ELSE
            start_found = .false.
         END IF
6151     IF(iindex.NE.0)GO TO 6152
5230        CONTINUE
            LINE=LINE+1
            IF (( start_found )) THEN
               READ(UNITNUM,END=5240,ERR=5250,FMT='(A256)') TEXT
            ELSE
               READ(UNITNUM,END=5260,ERR=5250,FMT='(A256)') TEXT
            END IF
            length = len(text)
6161        IF(index(text,blank).NE.1)GO TO 6162
               IF (( length .GE. 2 )) THEN
                  text=text(2:)
               ELSE
                  GO TO6162
               END IF
               length = length - 1
            GO TO 6161
6162        CONTINUE
            ifound = INDEX(text,'#')
            IF (( ifound .GT. 1 )) THEN
               text = text(1:ifound-1)
            ELSE
               IF (( ifound .EQ. 1 )) THEN
                  text = blank
               END IF
            END IF
            ifound = INDEX(text,';')
            IF (( ifound .GT. 1 )) THEN
               text = text(1:ifound-1)
            ELSE
               IF (( ifound .EQ. 1 )) THEN
                  text = blank
               END IF
            END IF
            length = lnblnk1(TEXT)
            TEXT=TEXT(:length)
            origtext = text(:length)
            DO 6171 Kconvert=1,lnblnk1(text)
               CURSOR=ICHAR(text(Kconvert:Kconvert))
               IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                  CURSOR=CURSOR-32
                  text(Kconvert:Kconvert)=CHAR(CURSOR)
               END IF
6171        CONTINUE
6172        CONTINUE
            IF (( .NOT.start_found )) THEN
               IF ((INDEX(TEXT,DELIM_START) .NE. 0 )) THEN
                  start_found = .true.
               END IF
               goto 5230
            END IF
            iindex=INDEX(TEXT,VNAME(:iVNAME))
            IF (( DELIM_END.NE.'NONE' )) THEN
               IF ((INDEX(TEXT,DELIM_END).NE.0)) THEN
                  IF (( error_level .GT. 0 )) THEN
                     WRITE (ERR,*) '***************ERROR***************'
                     WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES
     *               _SOUGHT(I))), '<<',' NOT FOUND'
                     WRITE (ERR,*) 'END OF DELIMETER: ',DELIM_END
                  END IF
                  ERROR_FLAG=1
                  ERROR_FLAGS(I)=1
                  GOTO 5200
               END IF
            END IF
         GO TO 6151
6152     CONTINUE
         CHECK=0
         IF (( idebug )) THEN
            write(i_log,*) ' ******* Found: '
            write(i_log,'(a,$)') ' text:     '
            length = lnblnk1(text)
            IF (( length .GT. 0 )) THEN
               DO 6181 lll=1,length
                  write(i_log,'(a1,$)') text(lll:lll)
6181           CONTINUE
6182           CONTINUE
               write(i_log,*)
            END IF
            write(i_log,'(a,$)') ' origtext: '
            length = lnblnk1(origtext)
            IF (( length .GT. 0 )) THEN
               DO 6191 lll=1,length
                  write(i_log,'(a1,$)') origtext(lll:lll)
6191           CONTINUE
6192           CONTINUE
               write(i_log,*)
            END IF
         END IF
         IINDEX=IINDEX+iVNAME
         TEXT=TEXT(IINDEX:)
         origtext=origtext(iindex:)
         IF (( idebug )) THEN
            write(i_log,*) ' After removing vname: '
            write(i_log,'(a,$)') ' text:     '
            length = lnblnk1(text)
            IF (( length .GT. 0 )) THEN
               DO 6201 lll=1,length
                  write(i_log,'(a1,$)') text(lll:lll)
6201           CONTINUE
6202           CONTINUE
               write(i_log,*)
            END IF
            write(i_log,'(a,$)') ' origtext: '
            length = lnblnk1(origtext)
            IF (( length .GT. 0 )) THEN
               DO 6211 lll=1,length
                  write(i_log,'(a1,$)') origtext(lll:lll)
6211           CONTINUE
6212           CONTINUE
               write(i_log,*)
            END IF
         END IF
         IINDEX=INDEX(TEXT,'=')
         IF ((IINDEX.NE.0)) THEN
            TEXT=TEXT(IINDEX+1:)
            origtext=origtext(iindex+1:)
         ELSE
            IINDEX=INDEX(TEXT,':')
            IF ((IINDEX.NE.0)) THEN
               TEXT=TEXT(IINDEX+1:)
               origtext=origtext(iindex+1:)
            END IF
         END IF
         IF (( idebug )) THEN
            write(i_log,*) ' After removing leading equals: '
            write(i_log,'(a,$)') ' text:     '
            length = lnblnk1(text)
            IF (( length .GT. 0 )) THEN
               DO 6221 lll=1,length
                  write(i_log,'(a1,$)') text(lll:lll)
6221           CONTINUE
6222           CONTINUE
               write(i_log,*)
            END IF
            write(i_log,'(a,$)') ' origtext: '
            length = lnblnk1(origtext)
            IF (( length .GT. 0 )) THEN
               DO 6231 lll=1,length
                  write(i_log,'(a1,$)') origtext(lll:lll)
6231           CONTINUE
6232           CONTINUE
               write(i_log,*)
            END IF
         END IF
         IF (( (lnblnk1(TEXT).EQ.0) .OR. (lnblnk1(TEXT).EQ.1) )) THEN
            IF ((vname(:ivname).EQ.'TITLE')) THEN
               READ (UNITNUM,FMT='(A256)') TEXTPIECE
               IF ((lnblnk1(TEXTPIECE).NE.0)) THEN
                  TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE))
                  length = len(text)
6241              IF(index(text,blank).NE.1)GO TO 6242
                     IF (( length .GE. 2 )) THEN
                        text=text(2:)
                     ELSE
                        GO TO6242
                     END IF
                     length = length - 1
                  GO TO 6241
6242              CONTINUE
                  length = len(origtext)
6251              IF(index(origtext,blank).NE.1)GO TO 6252
                     IF (( length .GE. 2 )) THEN
                        origtext=origtext(2:)
                     ELSE
                        GO TO6252
                     END IF
                     length = length - 1
                  GO TO 6251
6252              CONTINUE
                  GOTO 5370
               END IF
            END IF
            IF (( error_level .GT. 0 )) THEN
               WRITE (ERR,*) '*************ERROR*************'
               WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
               WRITE (ERR,*) 'VALUE NOT THERE!!'
            END IF
            ERROR_FLAG=1
            ERROR_FLAGS(I)=1
            RETURN
         END IF
5370     CONTINUE
         iindex = index(text,'DEFAULT')
         IF (( iindex .NE. 0 )) THEN
            IF (( type(i) .NE. 2 )) THEN
               IF (( type(i) .NE. 3 )) THEN
                  VALUE(I,1)=DEFAULT(I)
               ELSE
                  VALUE(I,1)=0
               END IF
               goto 5200
            END IF
         END IF
         IF (((TYPE(I) .EQ. 0).OR.(TYPE(I) .EQ. 1))) THEN
            IVAL=1
            IF (( idebug )) THEN
               write(i_log,*) ' *** Reading an integer or a real value!
     *'
            END IF
6261        CONTINUE
               IF (( idebug )) THEN
                  write(i_log,*) ' In LOOP, ival = ',ival
               END IF
               IF ((lnblnk1(TEXT).EQ.0)) THEN
                  IF (( error_level .GT. 0 )) THEN
                     WRITE(ERR,*) '*************ERROR*************'
                     WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                     WRITE (ERR,*) 'VALUE NOT THERE!!'
                  END IF
                  ERROR_FLAG=1
                  ERROR_FLAGS(I)=1
                  RETURN
               END IF
               READ(TEXT,END=5390,ERR=5400,FMT=*) VALUE(I,IVAL)
               IF (( idebug )) THEN
                  write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL)
               END IF
               IF (((VALUE(I,IVAL).GT.VALUE_MAX(I)).OR.(VALUE(I,IVAL).LT
     *         .VALUE_MIN(I)))) THEN
                  IF ((TYPE(I).EQ.0)) THEN
                     INT_VALUE=DEFAULT(I)
                     IF (( error_level .GT. 0 )) THEN
                        WRITE(ERR,*) '************WARNING************'
                        WRITE(ERR,5410) INT_VALUE, VALUES_SOUGHT(I)(:lnb
     *                  lnk1(VALUES_SOUGHT(I)))
                     END IF
5410                 FORMAT ( 'Default= ',I9,' used for: ', A )
                     INT_VALUE=VALUE(I,IVAL)
                     INT_VALUE_MIN=VALUE_MIN(I)
                     INT_VALUE_MAX=VALUE_MAX(I)
                     IF (( error_level .GT. 0 )) THEN
                        WRITE(ERR,5420) VALUES_SOUGHT(I)(:lnblnk1(VALUES
     *                  _SOUGHT(I))), INT_VALUE, INT_VALUE_MIN,INT_VALUE
     *                  _MAX
                     END IF
5420                 FORMAT (A,'=', I9,' should be between ', I9,' and '
     *, I9)
                  END IF
                  IF ((TYPE(I).EQ.1)) THEN
                     IF (( error_level .GT. 0 )) THEN
                        WRITE(ERR,*) '************WARNING************'
                        WRITE(ERR,5430) DEFAULT(I), VALUES_SOUGHT(I)(:ln
     *                  blnk1(VALUES_SOUGHT(I)))
5430                    FORMAT ( 'Default= ',F12.6,' used for: ', A )
                        WRITE(ERR,5440) VALUES_SOUGHT(I)(:lnblnk1(VALUES
     *                  _SOUGHT(I))), VALUE(I,IVAL), VALUE_MIN(I),VALUE_
     *                  MAX(I)
5440                    FORMAT (A,'=', F12.6,' should be between ', G14.
     *6,' and ', G14.6)
                     END IF
                  END IF
                  VALUE(I,IVAL)=DEFAULT(I)
               END IF
               IF((IVAL .EQ. NVALUE(I)))GO TO6262
               IF (((INDEX(TEXT,',').NE.0).OR.(lnblnk1(TEXT).EQ.0))) THE
     *         N
                  IF (( idebug )) THEN
                     write(i_log,*) ' A comma or a blank text found -> '
                     write(i_log,*) ' searching for further input'
                  END IF
                  TEXT=TEXT(INDEX(TEXT,',')+1:)
6271              IF(lnblnk1(TEXT).NE.0)GO TO 6272
                     IF (( idebug )) THEN
                        write(i_log,*) ' Empty text -> reading next line
     *! '
                     END IF
                     LINE=LINE+1
                     READ (UNITNUM,END=5390,ERR=5400,FMT='(A256)') TEXT
                     length = len(text)
6281                 IF(index(text,blank).NE.1)GO TO 6282
                        IF (( length .GE. 2 )) THEN
                           text=text(2:)
                        ELSE
                           GO TO6282
                        END IF
                        length = length - 1
                     GO TO 6281
6282                 CONTINUE
                     ifound = INDEX(text,'#')
                     IF (( ifound .GT. 1 )) THEN
                        text = text(1:ifound-1)
                     ELSE
                        IF (( ifound .EQ. 1 )) THEN
                           text = blank
                        END IF
                     END IF
                     ifound = INDEX(text,';')
                     IF (( ifound .GT. 1 )) THEN
                        text = text(1:ifound-1)
                     ELSE
                        IF (( ifound .EQ. 1 )) THEN
                           text = blank
                        END IF
                     END IF
                     length = lnblnk1(TEXT)
                     TEXT=TEXT(:length)
                     origtext = text(:length)
                     DO 6291 Kconvert=1,lnblnk1(text)
                        CURSOR=ICHAR(text(Kconvert:Kconvert))
                        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                           CURSOR=CURSOR-32
                           text(Kconvert:Kconvert)=CHAR(CURSOR)
                        END IF
6291                 CONTINUE
6292                 CONTINUE
                     DO 6301 K=1,NMAX
                        vname1 = VALUES_SOUGHT(K)
                        length = lnblnk1(vname1)
                        IF (( length .GT. 0 )) THEN
                           length = len(vname1)
6311                       IF(index(vname1,blank).NE.1)GO TO 6312
                              IF (( length .GE. 2 )) THEN
                                 vname1=vname1(2:)
                              ELSE
                                 GO TO6312
                              END IF
                              length = length - 1
                           GO TO 6311
6312                       CONTINUE
                           DO 6321 Kconvert=1,lnblnk1(vname1)
                              CURSOR=ICHAR(vname1(Kconvert:Kconvert))
                              IF (((CURSOR.GE.97).AND.(CURSOR.LE.122)))
     *                        THEN
                                 CURSOR=CURSOR-32
                                 vname1(Kconvert:Kconvert)=CHAR(CURSOR)
                              END IF
6321                       CONTINUE
6322                       CONTINUE
                           IF ((INDEX(TEXT,vname1(:length)).NE.0)) THEN
                              IF (( error_level .GT. 0 )) THEN
                                 WRITE(ERR,*) '************ERROR********
     *****'
                                 WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SO
     *                           UGHT(I)
                                 WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT
     *                           )), '<--COMMA INDICATES ANOTHER INPUT'
                                 WRITE(ERR,*) 'SEARCHED NEXT LINE: ', TE
     *                           XT(:lnblnk1(TEXT))
                                 WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DE
     *TECTED'
                              END IF
                              ERROR_FLAG=1
                              ERROR_FLAGS(I)=1
                           END IF
                        END IF
6301                 CONTINUE
6302                 CONTINUE
                     IF (( idebug )) THEN
                        write(i_log,*) ' Next line: '
                        write(i_log,'(a,$)') ' text:     '
                        length = lnblnk1(text)
                        IF (( length .GT. 0 )) THEN
                           DO 6331 lll=1,length
                              write(i_log,'(a1,$)') text(lll:lll)
6331                       CONTINUE
6332                       CONTINUE
                           write(i_log,*)
                        END IF
                        write(i_log,'(a,$)') ' origtext: '
                        length = lnblnk1(origtext)
                        IF (( length .GT. 0 )) THEN
                           DO 6341 lll=1,length
                              write(i_log,'(a1,$)') origtext(lll:lll)
6341                       CONTINUE
6342                       CONTINUE
                           write(i_log,*)
                        END IF
                     END IF
                  GO TO 6271
6272              CONTINUE
               ELSE
                  GO TO6262
               END IF
               IVAL=IVAL+1
            GO TO 6261
6262        CONTINUE
            IF (((NVALUE(I).NE.0).AND.(NVALUE(I).NE.IVAL))) THEN
               IF (( error_level .GT. 0 )) THEN
                  WRITE (ERR,*) '**************ERROR**************'
                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I)
                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT
     *(S)'
                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED'
               END IF
               ERROR_FLAG=1
               ERROR_FLAGS(I)=1
            ELSE
               NVALUE(I)=IVAL
            END IF
5390        CONTINUE
         END IF
         IF (((TYPE(I) .EQ. 2) .OR. (TYPE(I) .EQ. 3))) THEN
            IVAL=1
            IF (( idebug )) THEN
               write(i_log,*) ' Trying to read a string! '
            END IF
6351        CONTINUE
               IF (( idebug )) THEN
                  write(i_log,*) ' In LOOP, ival = ',ival
               END IF
               IF ((lnblnk1(TEXT).EQ.0)) THEN
                  IF (( error_level .GT. 0 )) THEN
                     WRITE(ERR,*) '*************ERROR*************'
                     WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                     WRITE (ERR,*) 'VALUE NOT THERE!!'
                  END IF
                  ERROR_FLAG=1
                  ERROR_FLAGS(I)=1
                  RETURN
               END IF
               IF ((vname(:ivname).EQ.'TITLE')) THEN
                  TEXTPIECE=origtext
                  GOTO 5540
               END IF
               iindex = INDEX(origtext,',')
               IF (( iindex .NE. 0 )) THEN
                  TEXTPIECE=origtext(:iindex-1)
               ELSE
                  TEXTPIECE=origtext
               END IF
5540           CONTINUE
               READ(TEXTPIECE,ERR=5550,FMT='(A256)') CHAR_VALUE(I,IVAL)
               length = len(CHAR_VALUE(I,IVAL))
6361           IF(index(CHAR_VALUE(I,IVAL),blank).NE.1)GO TO 6362
                  IF (( length .GE. 2 )) THEN
                     CHAR_VALUE(I,IVAL)=CHAR_VALUE(I,IVAL)(2:)
                  ELSE
                     GO TO6362
                  END IF
                  length = length - 1
               GO TO 6361
6362           CONTINUE
               IF (( idebug )) THEN
                  write(i_log,*) ' Read the following char string: '
                  length = lnblnk1(CHAR_VALUE(I,IVAL))
                  IF (( length .GT. 0 )) THEN
                     DO 6371 lll=1,length
                        write(i_log,'(a1,$)') CHAR_VALUE(I,IVAL)(lll:lll
     *                  )
6371                 CONTINUE
6372                 CONTINUE
                     write(i_log,*)
                  END IF
               END IF
               IF ((TYPE(I) .EQ. 3)) THEN
                  DO 6381 Kconvert=1,lnblnk1(CHAR_VALUE(I,IVAL))
                     CURSOR=ICHAR(CHAR_VALUE(I,IVAL)(Kconvert:Kconvert))
                     IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                        CURSOR=CURSOR-32
                        CHAR_VALUE(I,IVAL)(Kconvert:Kconvert)=CHAR(CURSO
     *                  R)
                     END IF
6381              CONTINUE
6382              CONTINUE
                  ALLOWED=.FALSE.
                  DO 6391 K=0,5
                     vname1 = ALLOWED_INPUTS(I,K)
                     length = len(ALLOWED_INPUTS(I,K))
6401                 IF(index(ALLOWED_INPUTS(I,K),blank).NE.1)GO TO 6402
                        IF (( length .GE. 2 )) THEN
                           ALLOWED_INPUTS(I,K)=ALLOWED_INPUTS(I,K)(2:)
                        ELSE
                           GO TO6402
                        END IF
                        length = length - 1
                     GO TO 6401
6402                 CONTINUE
                     DO 6411 Kconvert=1,lnblnk1(ALLOWED_INPUTS(I,K))
                        CURSOR=ICHAR(ALLOWED_INPUTS(I,K)(Kconvert:Kconve
     *                  rt))
                        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                           CURSOR=CURSOR-32
                           ALLOWED_INPUTS(I,K)(Kconvert:Kconvert)=CHAR(C
     *                     URSOR)
                        END IF
6411                 CONTINUE
6412                 CONTINUE
                     IF ((ALLOWED_INPUTS(I,K).EQ.CHAR_VALUE(I,IVAL))) TH
     *               EN
                        ALLOWED=.TRUE.
                        VALUE(I,IVAL)=K
                        IF (( idebug )) THEN
                           write(i_log,*) ' Found a allowed_value match
     *',k
                        END IF
                     END IF
6391              CONTINUE
6392              CONTINUE
                  IF ((.NOT.ALLOWED)) THEN
                     WRITE(ERR,*) '*************ERROR*************'
                     IF ((IVAL.NE.1)) THEN
                        WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                        WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY'
                        WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING
     *SECOND VALUE'
                     ELSE
                        WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                        WRITE(ERR,*) 'INPUT-->', CHAR_VALUE(I,IVAL)(:lnb
     *                  lnk1(CHAR_VALUE(I,IVAL))), '<--NOT ALLOWED'
                        WRITE(ERR,*) 'OPTIONS ARE:'
                        WRITE(ERR,1570) (ALLOWED_INPUTS(I,K)(:lnblnk1(AL
     *                  LOWED_INPUTS(I,K))),K=0,5)
                     END IF
1570                 FORMAT(A40)
                     ERROR_FLAG=1
                     ERROR_FLAGS(I)=1
                  END IF
               END IF
               IF ((vname(:ivname).EQ.'TITLE')) THEN
                  GO TO6352
               END IF
               DO 6421 K=1,LEN(KEEPTEXT)
                  KEEPTEXT(K:K)=' '
6421           CONTINUE
6422           CONTINUE
               KEEPTEXT(:lnblnk1(TEXT))=TEXT
               iindex = INDEX(TEXT,',')
               IF (( iindex .NE. 0 .OR. lnblnk1(TEXT).EQ.0 )) THEN
                  TEXT=TEXT(INDEX(TEXT,',')+1:)
                  origtext=origtext(iindex+1:)
6431              IF(lnblnk1(TEXT).NE.0)GO TO 6432
                     LINE=LINE+1
                     READ (UNITNUM,ERR=5550,FMT='(A256)') TEXT
                     length = len(text)
6441                 IF(index(text,blank).NE.1)GO TO 6442
                        IF (( length .GE. 2 )) THEN
                           text=text(2:)
                        ELSE
                           GO TO6442
                        END IF
                        length = length - 1
                     GO TO 6441
6442                 CONTINUE
                     ifound = INDEX(text,'#')
                     IF (( ifound .GT. 1 )) THEN
                        text = text(1:ifound-1)
                     ELSE
                        IF (( ifound .EQ. 1 )) THEN
                           text = blank
                        END IF
                     END IF
                     ifound = INDEX(text,';')
                     IF (( ifound .GT. 1 )) THEN
                        text = text(1:ifound-1)
                     ELSE
                        IF (( ifound .EQ. 1 )) THEN
                           text = blank
                        END IF
                     END IF
                     length = lnblnk1(TEXT)
                     TEXT=TEXT(:length)
                     origtext = text(:length)
                     DO 6451 Kconvert=1,lnblnk1(text)
                        CURSOR=ICHAR(text(Kconvert:Kconvert))
                        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                           CURSOR=CURSOR-32
                           text(Kconvert:Kconvert)=CHAR(CURSOR)
                        END IF
6451                 CONTINUE
6452                 CONTINUE
                     DO 6461 K=1,NMAX
                        vname1 = VALUES_SOUGHT(K)
                        length = lnblnk1(vname1)
                        IF (( length .GT. 0 )) THEN
                           length = len(vname1)
6471                       IF(index(vname1,blank).NE.1)GO TO 6472
                              IF (( length .GE. 2 )) THEN
                                 vname1=vname1(2:)
                              ELSE
                                 GO TO6472
                              END IF
                              length = length - 1
                           GO TO 6471
6472                       CONTINUE
                           DO 6481 Kconvert=1,lnblnk1(vname1)
                              CURSOR=ICHAR(vname1(Kconvert:Kconvert))
                              IF (((CURSOR.GE.97).AND.(CURSOR.LE.122)))
     *                        THEN
                                 CURSOR=CURSOR-32
                                 vname1(Kconvert:Kconvert)=CHAR(CURSOR)
                              END IF
6481                       CONTINUE
6482                       CONTINUE
                           IF ((INDEX(TEXT,vname1(:length)).NE.0)) THEN
                              WRITE(ERR,*) '************ERROR***********
     **'
                              WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGH
     *                        T(I)
                              WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
     *                         '<--COMMA INDICATES ANOTHER INPUT'
                              WRITE(ERR,*) 'SEARCHED NEXT LINE: ', TEXT(
     *                        :lnblnk1(TEXT))
                              WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETEC
     *TED'
                              ERROR_FLAG=1
                              ERROR_FLAGS(I)=1
                           END IF
                        END IF
6461                 CONTINUE
6462                 CONTINUE
                  GO TO 6431
6432              CONTINUE
               ELSE
                  GO TO6352
               END IF
               IVAL=IVAL+1
            GO TO 6351
6352        CONTINUE
            IF (((NVALUE(I).NE.0).AND.(NVALUE(I).NE.IVAL))) THEN
               IF (( error_level .GT. 0 )) THEN
                  WRITE (ERR,*) '*******************ERROR***************
     *****'
                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I)
                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)'
                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED'
               END IF
               ERROR_FLAG=1
               ERROR_FLAGS(I)=1
            ELSE
               NVALUE(I)=IVAL
            END IF
         END IF
         goto 5200
5240     IF (( error_level .GT. 0 )) THEN
            WRITE (ERR,*) '******************ERROR**********************
     **'
            WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUN
     *D'
            WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER'
            WRITE (ERR,*) 'VALUE SOUGHT: >>', VALUES_SOUGHT(I)(:lnblnk1(
     *      VALUES_SOUGHT(I))),'<<'
            WRITE (ERR,*) 'END DELIMETER: >>', DELIM_END(:lnblnk1(DELIM_
     *      END)),'<<'
         END IF
         ERROR_FLAG=1
         ERROR_FLAGS(I)=1
         goto 5200
5260     IF (( error_level .GT. 0 )) THEN
            WRITE (ERR,*) '******************ERROR**********************
     **'
            WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUN
     *D'
            WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER
     *'
            WRITE (ERR,*) 'VALUE SOUGHT: >>', VALUES_SOUGHT(I)(:lnblnk1(
     *      VALUES_SOUGHT(I))),'<<'
            WRITE (ERR,*) 'START DELIMETER: >>', DELIM_START(:lnblnk1(DE
     *      LIM_START)),'<<'
         END IF
         ERROR_FLAG=1
         ERROR_FLAGS(I)=1
         goto 5200
5400     IF (( error_level .GT. 0 )) THEN
            WRITE (ERR,*) '***************ERROR***************'
            IF ((IVAL.GT.1)) THEN
               J=IVAL
            ELSE
               J=1
            END IF
            WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(
     *      I)
            WRITE (ERR,*) 'LINE #',LINE
            WRITE (ERR,*) 'COULD NOT READ THE VALUE!!'
            WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...'
            WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR IN
     *PUT?'
         END IF
         ERROR_FLAG=1
         ERROR_FLAGS(I)=1
         GOTO 5200
5550     IF (( error_level .GT. 0 )) THEN
            WRITE (ERR,*) '***************ERROR***************'
            WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(
     *      I)
            WRITE (ERR,*) 'LINE #',LINE
            WRITE (ERR,*) 'COULD NOT READ THE STRING !!'
         END IF
         ERROR_FLAG=1
         ERROR_FLAGS(I)=1
5200     CONTINUE
6131  CONTINUE
6132  CONTINUE
      RETURN
5250  WRITE (ERR,*) '***************ERROR***************'
      WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE
      goto 5690
5690  CONTINUE
      ERROR_FLAG=1
      ERROR_FLAGS(I)=1
      RETURN
      entry get_input_plus_set_error_level(the_level)
      error_level = the_level
      return
      END
      subroutine get_media_inputs(ounit)
      implicit none
      integer*4 ounit
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      real*8 VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      COMMON/BOUNDS/ECUT( 1001),PCUT( 1001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      common/ET_control/ smaxir( 1001),estepe,ximax,  skindepth_for_bca,
     *transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,3), eno_array(200,3), eno_atbin_array(200,3), n_sh
     *ell(3), radc_flag,  ibcmp( 1001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(3), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),  e
     *ii_sh(40),  eii_nshells(100),  eii_nsh(3),  eii_first(3,50),  eii_
     *no(3,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/rayleigh_inputs/iray_ff_media(3),iray_ff_file(3)
      character*24 iray_ff_media
      character*128 iray_ff_file
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      COMMON/MEDINP/inpdensity_file(3),inpasym(3,50), inpstrn(24,3),pz4(
     *3,50), rhoz4(3,50),wa4(3,50),inpgasp(3)
      character*256 inpdensity_file
      CHARACTER*4 inpasym,inpstrn
      real*4 pz4,rhoz4,wa4,inpgasp
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100)
      integer*4 NET
      real*4 ITBL,WATBL,RHOTBL
      CHARACTER*4 ASYMT
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      integer*4 ival,ival_media,ival_medfile,i,j,k,ival_ae,ival_ue,ival_
     *ap,ival_up, ival_rho,ival_elements,ival_rhoz,ival_iunrst,ival_iapr
     *im,ival_gasp, ival_pz,ival_sterncid, ival_densityfile,medfile_erro
     *r,ival_outfile, egs_open_file,lnblnk1,i_medfile,egs_get_unit,i_med
     *err,mindex,eindex, i_density,i01,length,i_outfile
      real*8 ecut_min, pcut_min
      logical medfile_specified,densityfile_specified,elements_specified
     *, outfile_specified(3)
      logical iunrst_specified,stern_specified,iaprim_specified, gasp_sp
     *ecified,rho_specified,start_delim_found,end_delim_found, spec_by_p
     *z,spec_by_rhoz,df_if_elem_mismatch(3), df_if_rho_mismatch(3)
      logical ex
      integer*4 CURSOR,Kconvert
      real*4 ZTBL
      real*8 EKE,ELKE,TMXSO,DEDXE,DEDXP,EFRACT,SIGE,SIGP,BREME,BREMP,ETA
     *B(16), EIE,PLOTE(300),PLOTEM(300),PLOTEEN(300), PLOTEMP(300), PLOT
     *EMS(300)
      integer*4 IPLOTE,IFLAG1,IFLAG2,LELKE
      CHARACTER*60 GRAPHTITLE,XAXIS,YAXISPcom,YAXISPmfp,YAXISE,YAXISEmfp
     *, SUBTITLE,SERIES
      DATA ETAB/1.,1.25,1.5,1.75,2.,2.5,3.,3.5,4.,4.5,5.,5.5,6.,7.,8.,9.
     */
      character*24 medium_name,med_tmp,sterncid_tmp
      character*256 density_file,material_file,tmp_string, spoutput_file
     *(3)
      character*80 text_string, text_save, title
      character*80 delim_start,delim_end
      character*1 blank
      character*512 toUpper
      integer*4 nne_tmp,iaprim_tmp,epstfl_tmp,iunrst_tmp
      real*8 rho_tmp,rhoz_tmp(50),z_tmp(50),pz_tmp(50),ae_tmp,ap_tmp, ue
     *_tmp,up_tmp,gasp_tmp
      CHARACTER*4 asym_tmp(50)
      integer*4 nepst_df,nne_df
      real*8 iev_df,rho_df,z_df(50),rhoz_df(50),rhoz_tot
      CHARACTER*4 asym_df(50)
      data blank/' '/
      save medfile_specified,material_file,df_if_elem_mismatch,df_if_rho
     *_mismatch, spoutput_file,outfile_specified
      call get_input_set_error_level(0)
      call get_input_plus_set_error_level(0)
      IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
         i_mederr=17
         i_mederr=egs_open_file(i_mederr,0,1,'.mederr')
      END IF
      ecut_min=999.
      pcut_min=999.
      DO 6491 i=1, 1001
         IF((ecut(i).LT.ecut_min))ecut_min=ecut(i)
         IF((pcut(i).LT.pcut_min))pcut_min=pcut(i)
6491  CONTINUE
6492  CONTINUE
      delimeter = 'MEDIA DEFINITION'
      ival = 0
      ival = ival + 1
      ival_medfile = ival
      values_sought(ival) = 'material data file'
      nvalue(ival) = 1
      type(ival) = 2
      Nmin = ival_medfile
      Nmax = ival_medfile
      CALL GET_INPUT
      IF ((error_flags(ival_medfile).EQ.0)) THEN
         material_file=char_value(ival_medfile,1)
         medfile_specified=.true.
         i_medfile=17
         i_medfile=egs_get_unit(i_medfile)
         IF ((i_medfile .LT. 1)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a)') 'Error: Failed to get available fortran u
     *nit for', ' medium data file.'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
         END IF
         open(i_medfile,file=material_file,status='old',err=6500)
         medfile_specified=.true.
      ELSE
         IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' Warning: material data file not supplied.
     *'
         END IF
         IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' Thus, you must define media explicitly in
     * input file'
         END IF
         IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' or via density correction file.'
         END IF
         medfile_specified=.false.
      END IF
      ival = ival + 1
      ival_ae = ival
      values_sought(ival) = 'ae'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 999.
      default(ival) = ecut_min
      ival = ival + 1
      ival_ap = ival
      values_sought(ival) = 'ap'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 999.
      default(ival) = pcut_min
      ival = ival + 1
      ival_ue = ival
      values_sought(ival) = 'ue'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 999.
      default(ival) = 50 + prm
      ival = ival + 1
      ival_up = ival
      values_sought(ival) = 'up'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 999.
      default(ival) = 50.0
      Nmin=ival_ae
      Nmax=ival_up
      CALL GET_INPUT
      IF ((error_flags(ival_ae).EQ.0)) THEN
         ae_tmp=value(ival_ae,1)
      ELSE
         IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' Warning: AE for media not supplied.  Will
     * use min. ECUT.'
         END IF
         ae_tmp=ecut_min
      END IF
      IF ((error_flags(ival_ap).EQ.0)) THEN
         ap_tmp=value(ival_ap,1)
      ELSE
         IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' Warning: AP for media not supplied.  Will
     * use min. PCUT.'
         END IF
         ap_tmp=pcut_min
      END IF
      IF ((error_flags(ival_ue).EQ.0)) THEN
         ue_tmp=value(ival_ue,1)
      ELSE
         IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' Warning: UE for media not supplied.  Will
     * use                     50.5109989461 MeV'
         END IF
         ue_tmp=50 + prm
      END IF
      IF ((error_flags(ival_up).EQ.0)) THEN
         up_tmp=value(ival_up,1)
      ELSE
         IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' Warning: UP for media not supplied.  Will
     * use 50.0 MeV'
         END IF
         up_tmp=50.
      END IF
      IF ((ue_tmp.LE.ae_tmp)) THEN
         IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' Error: UE <= AE.  Adjust value(s) and try
     * again.'
         END IF
         write(i_log,'(/a)') '***************** Error: '
         write(i_log,'(a)') ' Error: UE <= AE.  Adjust value(s) and try
     *again.'
         write(i_log,'(/a)') '***************** Quiting now.'
         call exit(1)
      END IF
      IF ((up_tmp.LE.ap_tmp)) THEN
         IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' Error: UP <= AP.  Adjust value(s) and try
     * again.'
         END IF
         write(i_log,'(/a)') '***************** Error: '
         write(i_log,'(a)') ' Error: UP <= AP.  Adjust value(s) and try
     *again.'
         write(i_log,'(/a)') '***************** Quiting now.'
         call exit(1)
      END IF
      DO 6511 i=1,NMED
         DO 6521 j=1,24
            medium_name(j:j)=media(j,i)
6521     CONTINUE
6522     CONTINUE
         elements_specified=.false.
         rho_specified=.false.
         densityfile_specified=.false.
         stern_specified=.false.
         iunrst_specified=.false.
         iaprim_specified=.false.
         gasp_specified=.false.
         spec_by_rhoz=.false.
         spec_by_pz=.false.
         df_if_elem_mismatch(i)=.false.
         df_if_rho_mismatch(i)=.false.
         sterncid_tmp=medium_name
         gasp_tmp=0.0
         iunrst_tmp=0
         iaprim_tmp=0
         epstfl_tmp=0
         density_file=' '
         IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' '
         END IF
         IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THEN
            write(i_mederr,*)' For medium: ',medium_name
         END IF
         delimeter=medium_name(:lnblnk1(medium_name))
         ival=0
         ival=ival+1
         ival_elements=ival
         values_sought(ival) = 'elements'
         type(ival) = 2
         nvalue(ival) = 0
         nmin=ival_elements
         nmax=ival_elements
         CALL GET_INPUT
         IF ((error_flags(ival_elements).EQ.0)) THEN
            DO 6531 j=1,nvalue(ival_elements)
               DO 6541 Kconvert=1,lnblnk1(char_value(ival_elements,j))
                  CURSOR=ICHAR(char_value(ival_elements,j)(Kconvert:Kcon
     *            vert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                     CURSOR=CURSOR-32
                     char_value(ival_elements,j)(Kconvert:Kconvert)=CHAR
     *               (CURSOR)
                  END IF
6541           CONTINUE
6542           CONTINUE
6531        CONTINUE
6532        CONTINUE
            ival=ival+1
            ival_pz=ival
            nne_tmp=nvalue(ival_elements)
            values_sought(ival)='number of atoms'
            type(ival)=0
            nvalue(ival)=nne_tmp
            nmin=ival_pz
            nmax=ival_pz
            CALL GET_INPUT
            IF ((nne_tmp.GT.1 .AND. error_flags(ival_pz).EQ.0)) THEN
               DO 6551 j=1,nne_tmp
                  asym_tmp(j)=char_value(ival_elements,j)
                  pz_tmp(j)=value(ival_pz,j)
6551           CONTINUE
6552           CONTINUE
               elements_specified=.true.
               spec_by_pz=.true.
            ELSE
               ival=ival+1
               ival_rhoz=ival
               values_sought(ival)='mass fractions'
               type(ival)=1
               nvalue(ival)=nne_tmp
               nmin=ival_rhoz
               nmax=ival_rhoz
               IF ((nne_tmp.EQ.1)) THEN
                  value_min(ival)=0.0
                  value_max(ival)=1.e15
                  default(ival)=1.
               END IF
               CALL GET_INPUT
               IF ((error_flags(ival_rhoz).EQ.0)) THEN
                  DO 6561 j=1,nne_tmp
                     asym_tmp(j)=char_value(ival_elements,j)
                     rhoz_tmp(j)=value(ival_rhoz,j)
6561              CONTINUE
6562              CONTINUE
                  elements_specified=.true.
                  spec_by_rhoz=.true.
               END IF
            END IF
            IF ((nne_tmp.EQ.1 .AND. .NOT.elements_specified)) THEN
               asym_tmp(1)=char_value(ival_elements,1)
               pz_tmp(1)=1
               elements_specified=.true.
               spec_by_pz=.true.
            END IF
            IF ((elements_specified)) THEN
               IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *         THEN
                  write(i_mederr,*)' Composition specified in .egsinp fi
     *le.'
               END IF
            END IF
         END IF
         ival=ival+1
         ival_rho=ival
         values_sought(ival) = 'rho'
         type(ival)=1
         nvalue(ival)=1
         value_min(ival)=0.
         value_max(ival)=1e15
         default(ival)=1.0
         nmin=ival_rho
         nmax=ival_rho
         CALL GET_INPUT
         IF ((error_flags(ival_rho).EQ.0)) THEN
            rho_tmp=value(ival_rho,1)
            rho_specified=.true.
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
               write(i_mederr,*)' Rho specified in .egsinp file.'
            END IF
         END IF
         ival=ival+1
         ival_sterncid=ival
         values_sought(ival)='sterncid'
         type(ival)=2
         nvalue(ival)=1
         nmin=ival_sterncid
         nmax=ival_sterncid
         CALL GET_INPUT
         IF ((error_flags(ival_sterncid).EQ.0)) THEN
            sterncid_tmp=char_value(ival_sterncid,1)
            stern_specified=.true.
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
               write(i_mederr,*)' STERNCID specified in .egsinp file.'
            END IF
         END IF
         ival=ival+1
         ival_iunrst=ival
         values_sought(ival)='stopping powers'
         type(ival)=3
         nvalue(ival)=1
         allowed_inputs(ival,0)='restricted total'
         allowed_inputs(ival,1)='unrestricted collision'
         allowed_inputs(ival,2)='unrestricted collision and radiative'
         allowed_inputs(ival,3)='unrestricted collision and restricted r
     *adiative'
         allowed_inputs(ival,4)='restricted collision and unrestricted r
     *adiative'
         allowed_inputs(ival,5)='unrestricted radiative'
         nmin=ival_iunrst
         nmax=ival_iunrst
         CALL GET_INPUT
         IF ((error_flags(ival_iunrst).EQ.0)) THEN
            iunrst_tmp=value(ival_iunrst,1)
            iunrst_specified=.true.
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
               write(i_mederr,*)' IUNRST specified in .egsinp file.'
            END IF
         END IF
         ival=ival+1
         ival_iaprim=ival
         values_sought(ival)='bremsstrahlung correction'
         type(ival)=3
         nvalue(ival)=1
         allowed_inputs(ival,0)='KM'
         allowed_inputs(ival,1)='NRC'
         allowed_inputs(ival,2)='none'
         nmin=ival_iaprim
         nmax=ival_iaprim
         CALL GET_INPUT
         IF ((error_flags(ival_iaprim).EQ.0)) THEN
            iaprim_tmp=value(ival_iaprim,1)
            iaprim_specified=.true.
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
               write(i_mederr,*)' IAPRIM specified in .egsinp file.'
            END IF
         END IF
         ival=ival+1
         ival_gasp=ival
         values_sought(ival)='gas pressure'
         type(ival)=1
         nvalue(ival)=1
         value_min(ival)=0.
         value_max(ival)=1e15
         default(ival)=0.0
         nmin=ival_gasp
         nmax=ival_gasp
         CALL GET_INPUT
         IF ((error_flags(ival_gasp).EQ.0)) THEN
            gasp_tmp=value(ival_gasp,1)
            gasp_specified=.true.
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
               write(i_mederr,*)' GASP specified in .egsinp file.'
            END IF
         END IF
         ival=ival+1
         ival_densityfile=ival
         values_sought(ival)='density correction file'
         type(ival) = 2
         nvalue(ival)=1
         nmin=ival_densityfile
         nmax=ival_densityfile
         CALL GET_INPUT
         IF ((error_flags(ival_densityfile).EQ.0)) THEN
            density_file=char_value(ival_densityfile,1)
            densityfile_specified=.true.
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
               write(i_mederr,*)' Density correction file specified in .
     *egsinp file.'
            END IF
         END IF
         ival = ival+1
         ival_outfile = ival
         values_sought(ival) = 'e- stopping power output file'
         type(ival) = 2
         nvalue(ival) =1
         nmin=ival_outfile
         nmax=ival_outfile
         CALL GET_INPUT
         IF ((error_flags(ival_outfile).EQ.0)) THEN
            spoutput_file(i)=char_value(ival_outfile,1)
            outfile_specified(i)=.true.
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
               write(i_mederr,*)' e- stopping powers will be output to '
     *         , spoutput_file(i)
            END IF
         ELSE
            outfile_specified(i)=.false.
         END IF
         IF ((medfile_specified .AND. (.NOT.elements_specified .OR. .NOT
     *   .rho_specified .OR. .NOT.iunrst_specified .OR. .NOT.iaprim_spec
     *   ified .OR. .NOT.gasp_specified .OR. .NOT.stern_specified .OR. .
     *   NOT.densityfile_specified))) THEN
            rewind(i_medfile)
            start_delim_found=.false.
            end_delim_found=.false.
6571        IF((.NOT.(.NOT.start_delim_found)).AND.(.NOT.(.NOT.end_delim
     *      _found)))GO TO 6572
               read(i_medfile,'(a)',end=6580)text_string
               text_save=text_string
               text_string=toUpper(text_string(:lnblnk1(text_string)))
               mindex=index(text_string,'MEDIUM')
               eindex=index(text_string,'=')
               IF ((mindex.GT.0 .AND. eindex.GT.mindex)) THEN
                  text_string=text_save(eindex+1:)
                  text_string=text_string(:lnblnk1(text_string))
                  length = len(text_string)
6591              IF(index(text_string,blank).NE.1)GO TO 6592
                     IF (( length .GE. 2 )) THEN
                        text_string=text_string(2:)
                     ELSE
                        GO TO6592
                     END IF
                     length = length - 1
                  GO TO 6591
6592              CONTINUE
                  IF ((text_string.EQ.medium_name)) THEN
                     delim_start=text_save
                     start_delim_found=.true.
                  ELSE IF((start_delim_found)) THEN
                     delim_end=text_save
                     end_delim_found=.true.
                  END IF
               END IF
            GO TO 6571
6572        CONTINUE
6580        IF ((.NOT.start_delim_found)) THEN
               IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *         THEN
                  write(i_mederr,*)' Warning: Data for ',medium_name,' n
     *ot found'
               END IF
               IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *         THEN
                  write(i_mederr,*)' in material data file.'
               END IF
            ELSE
               IF ((.NOT.end_delim_found)) THEN
                  delim_end='NONE'
               END IF
               ival=0
               IF ((.NOT.elements_specified)) THEN
                  ival=ival+1
                  ival_elements=ival
                  values_sought(ival) = 'elements'
                  type(ival) = 2
                  nvalue(ival) = 0
                  nmin=ival_elements
                  nmax=ival_elements
                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
                  IF ((error_flags(ival_elements).EQ.0)) THEN
                     ival=ival+1
                     ival_pz=ival
                     nne_tmp=nvalue(ival_elements)
                     values_sought(ival)='number of atoms'
                     type(ival)=0
                     nvalue(ival)=nne_tmp
                     nmin=ival_pz
                     nmax=ival_pz
                     CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end
     *               )
                     IF ((nne_tmp.GT.1 .AND. error_flags(ival_pz).EQ.0))
     *                THEN
                        DO 6601 j=1,nne_tmp
                           asym_tmp(j)=char_value(ival_elements,j)
                           pz_tmp(j)=value(ival_pz,j)
6601                    CONTINUE
6602                    CONTINUE
                        elements_specified=.true.
                        spec_by_pz=.true.
                     ELSE
                        ival=ival+1
                        ival_rhoz=ival
                        values_sought(ival)='mass fractions'
                        type(ival)=1
                        nvalue(ival)=nne_tmp
                        nmin=ival_rhoz
                        nmax=ival_rhoz
                        IF ((nne_tmp.EQ.1)) THEN
                           value_min(ival)=0.0
                           value_max(ival)=1.e15
                           default(ival)=1.
                        END IF
                        CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_
     *                  end)
                        IF ((error_flags(ival_rhoz).EQ.0)) THEN
                           DO 6611 j=1,nne_tmp
                              asym_tmp(j)=char_value(ival_elements,j)
                              rhoz_tmp(j)=value(ival_rhoz,j)
6611                       CONTINUE
6612                       CONTINUE
                           elements_specified=.true.
                           spec_by_rhoz=.true.
                        END IF
                     END IF
                     IF ((nne_tmp.EQ.1 .AND. .NOT.elements_specified)) T
     *               HEN
                        asym_tmp(1)=char_value(ival_elements,1)
                        pz_tmp(1)=1
                        elements_specified=.true.
                        spec_by_pz=.true.
                     END IF
                     IF ((elements_specified)) THEN
                        IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_pa
     *                  rallel)) THEN
                           write(i_mederr,*)' Composition specified in m
     *aterial data file'
                        END IF
                     END IF
                  END IF
               END IF
               IF ((.NOT.rho_specified)) THEN
                  ival=ival+1
                  ival_rho=ival
                  values_sought(ival) = 'rho'
                  type(ival)=1
                  nvalue(ival)=1
                  value_min(ival)=0.
                  value_max(ival)=1e15
                  default(ival)=1.0
                  nmin=ival_rho
                  nmax=ival_rho
                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
                  IF ((error_flags(ival_rho).EQ.0)) THEN
                     rho_tmp=value(ival_rho,1)
                     rho_specified=.true.
                     IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_paral
     *               lel)) THEN
                        write(i_mederr,*)' Rho specified in material dat
     *a file'
                     END IF
                  END IF
               END IF
               IF ((.NOT.stern_specified)) THEN
                  ival=ival+1
                  ival_sterncid=ival
                  values_sought(ival)='sterncid'
                  type(ival)=2
                  nvalue(ival)=1
                  nmin=ival_sterncid
                  nmax=ival_sterncid
                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
                  IF ((error_flags(ival_sterncid).EQ.0)) THEN
                     sterncid_tmp=char_value(ival_sterncid,1)
                     stern_specified=.true.
                     IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_paral
     *               lel)) THEN
                        write(i_mederr,*)' STERNCID specified in materia
     *l data file'
                     END IF
                  END IF
               END IF
               IF ((.NOT.iunrst_specified)) THEN
                  ival=ival+1
                  ival_iunrst=ival
                  values_sought(ival)='stopping powers'
                  type(ival)=3
                  nvalue(ival)=1
                  allowed_inputs(ival,0)='restricted total'
                  allowed_inputs(ival,1)='unrestricted collision'
                  allowed_inputs(ival,2)='unrestricted collision and rad
     *iative'
                  allowed_inputs(ival,3)= 'unrestricted collision and re
     *stricted radiative'
                  allowed_inputs(ival,4)= 'restricted collision and unre
     *stricted radiative'
                  allowed_inputs(ival,5)='unrestricted radiative'
                  nmin=ival_iunrst
                  nmax=ival_iunrst
                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
                  IF ((error_flags(ival_iunrst).EQ.0)) THEN
                     iunrst_tmp=value(ival_iunrst,1)
                     iunrst_specified=.true.
                     IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_paral
     *               lel)) THEN
                        write(i_mederr,*)' IUNRST specified in material
     *data file'
                     END IF
                  END IF
               END IF
               IF ((.NOT.iaprim_specified)) THEN
                  ival=ival+1
                  ival_iaprim=ival
                  values_sought(ival)='bremsstrahlung correction'
                  type(ival)=3
                  nvalue(ival)=1
                  allowed_inputs(ival,0)='KM'
                  allowed_inputs(ival,1)='NRC'
                  allowed_inputs(ival,2)='none'
                  nmin=ival_iaprim
                  nmax=ival_iaprim
                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
                  IF ((error_flags(ival_iaprim).EQ.0)) THEN
                     iaprim_tmp=value(ival_iaprim,1)
                     iaprim_specified=.true.
                     IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_paral
     *               lel)) THEN
                        write(i_mederr,*)' IAPRIM specified in material
     *data file'
                     END IF
                  END IF
               END IF
               IF ((.NOT.gasp_specified)) THEN
                  ival=ival+1
                  ival_gasp=ival
                  values_sought(ival)='gas pressure'
                  type(ival)=1
                  nvalue(ival)=1
                  value_min(ival)=0.
                  value_max(ival)=1.e15
                  default(ival)=0.
                  nmin=ival_gasp
                  nmax=ival_gasp
                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
                  IF ((error_flags(ival_gasp).EQ.0)) THEN
                     gasp_tmp=value(ival_gasp,1)
                     gasp_specified=.true.
                     IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_paral
     *               lel)) THEN
                        write(i_mederr,*)' GASP specified in material da
     *ta file'
                     END IF
                  END IF
               END IF
               IF ((.NOT.densityfile_specified)) THEN
                  ival=ival+1
                  ival_densityfile=ival
                  values_sought(ival)='density correction file'
                  type(ival) = 2
                  nvalue(ival)=1
                  nmin=ival_densityfile
                  nmax=ival_densityfile
                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end)
                  IF ((error_flags(ival_densityfile).EQ.0)) THEN
                     density_file=char_value(ival_densityfile,1)
                     densityfile_specified=.true.
                     IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_paral
     *               lel)) THEN
                        write(i_mederr,*)' Density correction file speci
     *fied in material data file.'
                     END IF
                  END IF
               END IF
            END IF
         END IF
         IF ((densityfile_specified)) THEN
            write(*,*)' density_file ',density_file
            IF ((index(density_file,'/').GT.0)) THEN
               tmp_string=density_file(:lnblnk1(density_file))
               inquire(file=tmp_string,exist=ex)
               IF ((.NOT.ex)) THEN
                  IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel
     *            )) THEN
                     write(i_mederr,*)' Error: Density correction file '
     *               ,tmp_string
                  END IF
                  IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel
     *            )) THEN
                     write(i_mederr,*)' cannot be found.'
                  END IF
               END IF
            ELSE
               density_file=density_file(:lnblnk1(density_file))//'.dens
     *ity'
               tmp_string=egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/'
     *          // 'density_corrections' // '/' // density_file
               inquire(file=tmp_string,exist=ex)
               IF((ex))goto 6620
               tmp_string=egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/'
     *          // 'density_corrections' // '/' // 'elements' // '/' //
     *         density_file
               inquire(file=tmp_string,exist=ex)
               IF((ex))goto 6620
               tmp_string=egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/'
     *          // 'density_corrections' // '/' // 'compounds' // '/' //
     *          density_file
               inquire(file=tmp_string,exist=ex)
               IF((ex))goto 6620
               tmp_string=egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/'
     *          // 'density' // '/' // density_file
               inquire(file=tmp_string,exist=ex)
               IF((ex))goto 6620
               tmp_string=hen_house(:lnblnk1(hen_house)) // 'pegs4' // '
     */' // 'density_corrections' // '/' // 'elements' // '/' // density
     *         _file
               inquire(file=tmp_string,exist=ex)
               IF((ex))goto 6620
               tmp_string=hen_house(:lnblnk1(hen_house)) // 'pegs4' // '
     */' // 'density_corrections' // '/' // 'compounds' // '/' // densit
     *         y_file
               inquire(file=tmp_string,exist=ex)
               IF((ex))goto 6620
               IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *         THEN
                  write(i_mederr,*)' Error: Density correction file', de
     *            nsity_file
               END IF
               IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *         THEN
                  write(i_mederr,*)' does not exist in'
               END IF
               IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *         THEN
                  write(i_mederr,*)' $EGS_HOME/pegs4/density_corrections
     *, '
               END IF
               IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *         THEN
                  write(i_mederr,*)' $EGS_HOME/pegs4/density_corrections
     */elements, '
               END IF
               IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *         THEN
                  write(i_mederr,*)' $EGS_HOME/pegs4/density_corrections
     */compounds, '
               END IF
               IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *         THEN
                  write(i_mederr,*)' $EGS_HOME/pegs4/density, '
               END IF
               IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *         THEN
                  write(i_mederr,*)' $HEN_HOUSE/pegs4/density_correction
     *s/elements or '
               END IF
               IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *         THEN
                  write(i_mederr,*)' $HEN_HOUSE/pegs4/density_correction
     *s/compounds.'
               END IF
6620           CONTINUE
            END IF
         END IF
         IF ((densityfile_specified)) THEN
            i_density=19
            i_density=egs_get_unit(i_density)
            IF ((i_density .LT. 1)) THEN
               write(i_log,'(/a)') '***************** Error: '
               write(i_log,'(a)') 'Error: Failed to get available fortra
     *n unit for', ' density correction file.'
               write(i_log,'(/a)') '***************** Quiting now.'
               call exit(1)
            END IF
            open(i_density,file=tmp_string,status='old',err=6630)
            density_file=tmp_string
            densityfile_specified=.true.
            epstfl_tmp=1
            read(i_density,'(a)')title
            read(i_density,*)nepst_df,iev_df,rho_df,nne_df
            read(i_density,*)(z_df(j),rhoz_df(j),j=1,nne_df)
            DO 6641 j=1,nne_df
               i01=z_df(j)
               asym_df(j)=ASYMT(i01)
6641        CONTINUE
6642        CONTINUE
            IF ((elements_specified)) THEN
               IF ((nne_tmp.NE.nne_df)) THEN
                  df_if_elem_mismatch(i)=.true.
               ELSE
                  rhoz_tot=0.
                  DO 6651 j=1,nne_tmp
                     IF ((spec_by_pz)) THEN
                        i01=ZTBL(asym_tmp(j))
                        rhoz_tmp(j)=pz_tmp(j)*WATBL(i01)
                     END IF
                     rhoz_tot=rhoz_tot+rhoz_tmp(j)
6651              CONTINUE
6652              CONTINUE
                  DO 6661 j=1,nne_df
                     DO 6671 k=1,nne_tmp
                        IF ((asym_df(j).EQ.asym_tmp(k))) THEN
                           IF ((rhoz_df(j).GT.(1+0.01)*rhoz_tmp(k)/rhoz_
     *                     tot .OR. rhoz_df(j).LT.(1-0.01)*rhoz_tmp(k)/r
     *                     hoz_tot)) THEN
                              df_if_elem_mismatch(i)=.true.
                           END IF
                           exit
                        END IF
6671                 CONTINUE
6672                 CONTINUE
                     IF((k.GT.nne_tmp))df_if_elem_mismatch(i)=.true.
                     IF ((df_if_elem_mismatch(i))) THEN
                        exit
                     END IF
6661              CONTINUE
6662              CONTINUE
               END IF
               IF ((df_if_elem_mismatch(i))) THEN
                  IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel
     *            )) THEN
                     write(i_mederr,*)' Warning: composition specified i
     *n density correction', ' file is not the same as that'
                  END IF
                  IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel
     *            )) THEN
                     write(i_mederr,*)' specified in input or material d
     *ata file.'
                  END IF
                  IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel
     *            )) THEN
                     write(i_mederr,*)' Will use the composition specifi
     *ed in the density correction file.'
                  END IF
                  nne_tmp=nne_df
                  DO 6681 j=1,nne_tmp
                     z_tmp(j)=z_df(j)
                     rhoz_tmp(j)=rhoz_df(j)
                     asym_tmp(j)=asym_df(j)
6681              CONTINUE
6682              CONTINUE
                  spec_by_rhoz=.true.
               END IF
            ELSE
               IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *         THEN
                  write(i_mederr,*)' Composition specified in density co
     *rrection file'
               END IF
               nne_tmp=nne_df
               DO 6691 j=1,nne_tmp
                  z_tmp(j)=z_df(j)
                  rhoz_tmp(j)=rhoz_df(j)
                  asym_tmp(j)=asym_df(j)
6691           CONTINUE
6692           CONTINUE
               spec_by_rhoz=.true.
               elements_specified=.true.
            END IF
            IF ((rho_specified)) THEN
               IF ((rho_df.GT.(1+0.01)*rho_tmp .OR. rho_df.LT.(1-0.01)*r
     *         ho_tmp)) THEN
                  IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel
     *            )) THEN
                     write(i_mederr,*)' Warning: rho specified in densit
     *y correction', ' file is not the same as that'
                  END IF
                  IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel
     *            )) THEN
                     write(i_mederr,*)' specified in input or material d
     *ata file.'
                  END IF
                  IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel
     *            )) THEN
                     write(i_mederr,*)' Will use rho as specified in the
     * density correction file.'
                  END IF
                  rho_tmp=rho_df
                  df_if_rho_mismatch(i)=.true.
               END IF
            ELSE
               rho_tmp=rho_df
               rho_specified=.true.
               IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *         THEN
                  write(i_mederr,*)' Rho specified in density correction
     * file'
               END IF
            END IF
            IF ((gasp_specified)) THEN
               IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))
     *         THEN
                  write(i_mederr,*)' Warning: gas pressure input not req
     *uired', ' when using density correction file.  Will set GASP=0.'
               END IF
               gasp_specified=.false.
               gasp_tmp=0.
            END IF
            close(i_density)
         END IF
         IF ((elements_specified .AND. rho_specified)) THEN
            ae(i)=ae_tmp
            ue(i)=ue_tmp
            ap(i)=ap_tmp
            up(i)=up_tmp
            DO 6701 j=1,24
               inpstrn(j,i) = sterncid_tmp(j:j)
6701        CONTINUE
6702        CONTINUE
            nne(i)=nne_tmp
            rho(i)=rho_tmp
            DO 6711 j=1,nne_tmp
               inpasym(i,j)=asym_tmp(j)
               zelem(i,j)=ZTBL(asym_tmp(j))
               i01=zelem(i,j)
               wa(i,j)=WATBL(i01)
               wa4(i,j)=WATBL(i01)
               IF ((spec_by_rhoz)) THEN
                  rhoz(i,j)=rhoz_tmp(j)
                  rhoz4(i,j)=rhoz_tmp(j)
                  pz(i,j)=rhoz(i,j)/wa(i,j)
                  pz4(i,j)=rhoz4(i,j)/wa4(i,j)
               ELSE IF((spec_by_pz)) THEN
                  pz(i,j)=pz_tmp(j)
                  pz4(i,j)=pz_tmp(j)
                  rhoz(i,j)=pz(i,j)*wa(i,j)
                  rhoz4(i,j)=pz4(i,j)*wa4(i,j)
               END IF
6711        CONTINUE
6712        CONTINUE
            iunrst(i)=iunrst_tmp
            iaprim(i)=iaprim_tmp
            epstfl(i)=epstfl_tmp
            inpgasp(i)=gasp_tmp
            inpdensity_file(i)=density_file
         ELSE
            IF ((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel)) THE
     *      N
               write(i_mederr,*)' Error: Medium ',medium_name,' not corr
     *ectly defined.'
            END IF
         END IF
6511  CONTINUE
6512  CONTINUE
      IF((medfile_specified))close(i_medfile)
      IF((n_parallel.EQ.0 .OR. i_parallel.EQ.first_parallel))close(i_med
     *err)
      entry show_media_parameters(ounit)
      IF((ounit .LE. 0))return
      IF ((is_pegsless)) THEN
         write(ounit,*)
         write(ounit,*)' Medium data: '
         write(ounit,*)
         write(ounit,'(a,1p,e14.5,a,e14.5,a)')' AE = ',ae(1),' MeV,  UE
     *= ',ue(1),' MeV'
         write(ounit,'(a,1p,e14.5,a,e14.5,a)')' AP = ',ap(1),' MeV,  UP
     *= ',up(1),' MeV'
         write(ounit,*)
         IF ((medfile_specified)) THEN
            write(ounit,*)' Material data file: ',material_file
         ELSE
            write(ounit,*)' No material data file supplied.  Material da
     *ta obtained from'
            write(ounit,*)' .egsinp file or density correction file.'
         END IF
         write(ounit,*)
         DO 6721 i=1,nmed
            write(ounit,'(a,24a1)')'   Medium: ',(media(j,i),j=1,24)
            write(ounit,'(a,24a1)')' Sterncid: ',(inpstrn(j,i),j=1,24)
            write(ounit,'(a,1p,e14.5,a)')'     rho: ',rho(i),' g/cm^3'
            write(ounit,'(a,24a4)')' Elements: ',(inpasym(i,j),j=1,nne(i
     *      ))
            write(ounit,'(a,1p,12e14.5)')'    rhoz: ',(rhoz(i,j),j=1,nne
     *      (i))
            write(ounit,'(a,1p,12e14.5)')'      pz: ',(pz(i,j),j=1,nne(i
     *      ))
            write(ounit,'(a,i5)')'  iunrst: ',iunrst(i)
            write(ounit,'(a,i5)')'  iaprim: ',iaprim(i)
            write(ounit,'(a,1p,e14.5,a)')'    gasp: ',inpgasp(i),' atm.'
            IF ((epstfl(i).EQ.1)) THEN
               write(ounit,*)' density correction file: ', inpdensity_fi
     *         le(i)(:lnblnk1(inpdensity_file(i)))
               IF ((df_if_elem_mismatch(i))) THEN
                  write(ounit,*)' ****Warning: composition specified in
     *density correction', ' file is not the same as that'
                  write(ounit,*)' specified in input or material data fi
     *le.'
                  write(ounit,*) ' Will use the composition specified in
     * the density correction file.'
               END IF
               IF ((df_if_rho_mismatch(i))) THEN
                  write(ounit,*)' ****Warning: rho specified in density
     *correction', ' file is not the same as that'
                  write(ounit,*)' specified in input or material data fi
     *le.'
                  write(ounit,*) ' Will use rho as specified in the dens
     *ity correction file.'
               END IF
            END IF
            write(ounit,*)
            IF ((outfile_specified(i) .AND. (n_parallel.EQ.0 .OR. i_para
     *      llel.EQ.first_parallel))) THEN
               inquire(file=spoutput_file(i),exist=ex)
               IF ((ex)) THEN
                  write(i_log,'(/a)') '***************** Warning: '
                  write(i_log,'(a)') 'Warning: stopping power output fil
     *e ', spoutput_file(i),'already exists.  Will overwrite.'
               END IF
               i_outfile=20
               i_outfile=egs_get_unit(i_outfile)
               IF ((i_outfile .LT. 1)) THEN
                  write(i_log,'(/a)') '***************** Warning: '
                  write(i_log,'(a)') 'Warning: Failed to get available f
     *ortran unit for', ' stopping power output file.'
               END IF
               open(i_outfile,file=spoutput_file(i),status='unknown',err
     *         =6730)
               goto 6740
6730           write(i_log,'(/a)') '***************** Warning: '
               write(i_log,'(a)') 'Warning: Failed to open stopping powe
     *r output file ', spoutput_file(i)
               goto 6750
6740           IFLAG1=0
               IFLAG2=0
               IPLOTE=0
               MEDIUM=i
               XAXIS = 'kinetic energy / MeV'
               YAXISE = 'dE/drhoX MeV/g/cm\\S2\\N'
               YAXISEmfp = 'mean free path / cm'
               YAXISPmfp = 'mean free path / cm'
               write(GRAPHTITLE,'(24a1)')(media(j,i),j=1,24)
               SUBTITLE = 'Electron data'
               DO 6761 j=1,8
                  DO 6771 k=1,16
                     EKE=ETAB(k)*10.**(j-4)
                     IF ((EKE .LE. AE(1)-PRM)) THEN
                        IF ((IFLAG1 .EQ. 0)) THEN
                           IFLAG1=1
                           EKE=AE(1)-PRM
                        ELSE
                           EKE=0.0
                        END IF
                     END IF
                     IF ((EKE .GT. UE(1)-PRM)) THEN
                        IF ((IFLAG2 .EQ. 0)) THEN
                           IFLAG2=1
                           EKE=UE(1)-PRM
                        ELSE
                           EKE=1.E30
                        END IF
                     END IF
                     EIE=EKE+PRM
                     TMXSO=0.0
                     DEDXE=0.0
                     DEDXP=0.0
                     EFRACT=0.0
                     IF ((EIE .GE. AE(1)-0.0001 .AND. EIE .LE. UE(1)+0.0
     *               01)) THEN
                        ELKE=LOG(EKE)
                        LELKE=EKE1(MEDIUM)*ELKE+EKE0(MEDIUM)
                        DEDXE=EDEDX1(LELKE,MEDIUM)*ELKE+EDEDX0(LELKE,MED
     *                  IUM)
                        IPLOTE=IPLOTE+1
                        PLOTEEN(IPLOTE)=EKE
                        PLOTE(IPLOTE)=DEDXE/RHO(MEDIUM)
                     END IF
6771              CONTINUE
6772              CONTINUE
6761           CONTINUE
6762           CONTINUE
               IF ((IPLOTE.GT.0)) THEN
                  IF ((iunrst(i).EQ.0)) THEN
                     SERIES='restricted total stopping power'
                  ELSE IF((iunrst(i).EQ.1)) THEN
                     SERIES='unrestricted collision stopping power'
                  ELSE IF((iunrst(i).EQ.2)) THEN
                     SERIES='unrestricted collision + radiative stopping
     * power'
                  ELSE IF((iunrst(i).EQ.3)) THEN
                     SERIES='unrestricted collision + restricted radiati
     *ve stopping power'
                  ELSE IF((iunrst(i).EQ.4)) THEN
                     SERIES='restricted collision + unrestricted radiati
     *ve stopping power'
                  ELSE IF((iunrst(i).EQ.5)) THEN
                     SERIES='unrestricted radiative stopping power'
                  END IF
                  CALL MEDXVGRPLOT(PLOTEEN,PLOTE,IPLOTE,0,SERIES, XAXIS,
     *            YAXISE,GRAPHTITLE,SUBTITLE,i_outfile,2)
               END IF
               close(i_outfile)
6750           CONTINUE
            END IF
6721     CONTINUE
6722     CONTINUE
      END IF
      return
6500  write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a)') 'Error: Cannot open material data file',materia
     *l_file
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
6630  write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a)') 'Error: Cannot open density correction file: ',
     * density_file(:lnblnk1(density_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      SUBROUTINE MEDXVGRPLOT (X, Y, NPTS, CURVENUM, SERIESTITLE, XTITLE,
     * YTITLE, GRAPHTITLE, SUBTITLE, UNITNUM, AXISTYPE)
      IMPLICIT NONE
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 MAX
      PARAMETER (MAX = 400)
      integer*4 NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE
      real*8 X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,SMALLESTX, SMALLESTY,FUDGE
      integer*4 TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENG
     *TH
      integer*4 LOGX, LOGY
      CHARACTER*(*) SUBTITLE
      CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE
      logical TESTFILE, ALLPOS
      FUDGE = 1.e-10
      IF (( NPTS .gt. MAX)) THEN
         WRITE(6,6780)NPTS, MAX
6780     FORMAT(//' **************************'/ ' Number of points aske
     *d for =', I5, ' is greater than max allowed of', I4/ ' Setting NPT
     *S to MAX, you could adjust MAX in xvgrplot.mortran'/ ' ***********
     ****************'//)
         NPTS1 = MAX
      ELSE
         NPTS1 = NPTS
      END IF
      INQUIRE(UNIT = UNITNUM,OPENED=TESTFILE)
      IF ((.NOT.TESTFILE)) THEN
         WRITE(6,6790) UNITNUM
6790     FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------' ,/
     *'   Unit specified (',I2,') is not open.' ,/'   Unit must be opene
     *d before using subroutine.' ,/'   Data not written to file.' ,/'  
     *----------------------------------------------'//)
         RETURN
      END IF
      TITLELENGTH = 61
      SUBLENGTH = 61
      XAXISLENGTH = 61
      YAXISLENGTH = 61
      SERIESLENGTH = 61
6801  CONTINUE
         TITLELENGTH = TITLELENGTH - 1
         IF(((GRAPHTITLE(TITLELENGTH:TITLELENGTH) .NE. ' ')))GO TO6802
      GO TO 6801
6802  CONTINUE
6811  CONTINUE
         SUBLENGTH = SUBLENGTH - 1
         IF(((SUBTITLE(SUBLENGTH:SUBLENGTH) .NE. ' ')))GO TO6812
      GO TO 6811
6812  CONTINUE
6821  CONTINUE
         XAXISLENGTH = XAXISLENGTH - 1
         IF(((XTITLE(XAXISLENGTH:XAXISLENGTH) .NE. ' ')))GO TO6822
      GO TO 6821
6822  CONTINUE
6831  CONTINUE
         YAXISLENGTH = YAXISLENGTH - 1
         IF(((YTITLE(YAXISLENGTH:YAXISLENGTH) .NE. ' ')))GO TO6832
      GO TO 6831
6832  CONTINUE
6841  CONTINUE
         SERIESLENGTH = SERIESLENGTH - 1
         IF(((SERIESTITLE(SERIESLENGTH:SERIESLENGTH) .NE. ' ')))GO TO684
     *   2
      GO TO 6841
6842  CONTINUE
      LOGX = 0
      LOGY = 0
      ALLPOS=.TRUE.
      IF (( X(1).EQ.0.0 )) THEN
         SMALLESTX = 0.1
      ELSE
         SMALLESTX=X(1)
      END IF
      IF (( Y(1).EQ.0.0 )) THEN
         SMALLESTY = 0.1
      ELSE
         SMALLESTY=Y(1)
      END IF
      DO 6851 COUNT=1,NPTS1
         IF (((X(COUNT) .LT. SMALLESTX) .AND. (X(COUNT).NE.0.))) THEN
            SMALLESTX=X(COUNT)
         END IF
         IF (((Y(COUNT) .LT. SMALLESTY) .AND. (Y(COUNT).NE.0.))) THEN
            SMALLESTY=Y(COUNT)
         END IF
         IF (((X(COUNT) .LT. 0.).OR.(Y(COUNT) .LT. 0.))) THEN
            ALLPOS=.FALSE.
         END IF
6851  CONTINUE
6852  CONTINUE
      IF ((ALLPOS)) THEN
         DO 6861 COUNT=1,NPTS1
            IF ((X(COUNT).EQ.0.)) THEN
               X(COUNT)=SMALLESTX*FUDGE
            END IF
            IF ((Y(COUNT).EQ.0.)) THEN
               Y(COUNT)=SMALLESTY*FUDGE
            END IF
6861     CONTINUE
6862     CONTINUE
      END IF
      IF ((AXISTYPE .GT. 0)) THEN
         DO 6871 COUNT=1,NPTS1
            IF ((X(COUNT) .LE. 0.)) THEN
               LOGX = 1
            END IF
            IF ((Y(COUNT) .LE. 0.)) THEN
               LOGY = 1
            END IF
6871     CONTINUE
6872     CONTINUE
      END IF
      IF ((CURVENUM .EQ. 0)) THEN
         IF ((AXISTYPE .EQ. 0)) THEN
            WRITE(UNITNUM,6880) 'xy'
         ELSE IF((AXISTYPE .EQ. 1)) THEN
            WRITE(UNITNUM,6880) 'logy'
            WRITE(UNITNUM,6890)
         ELSE IF((AXISTYPE .EQ. 2)) THEN
            WRITE(UNITNUM,6880) 'logx'
            WRITE(UNITNUM,6890)
         ELSE IF((AXISTYPE .EQ. 3)) THEN
            WRITE(UNITNUM,6880) 'logxy'
            WRITE(UNITNUM,6890)
            WRITE(UNITNUM,6900)
         ELSE
            WRITE(6,6910) AXISTYPE
6910        FORMAT (//'  ------------Error in Subroutine XVGRPLOT-------
     *----' ,/'   AXISTYPE specified (',I2,') is not a valid option.' ,/
     *'  ----------------------------------------------'//)
            RETURN
         END IF
6880     FORMAT ('@g0 type ',A,' ')
6890     FORMAT ('@    xaxis  ticklabel format exponential')
6900     FORMAT ('@    yaxis  ticklabel format exponential')
         WRITE(UNITNUM,6920) GRAPHTITLE(1:TITLELENGTH) ,SUBTITLE(1:SUBLE
     *   NGTH) ,XTITLE(1:XAXISLENGTH) ,YTITLE(1:YAXISLENGTH)
6920     FORMAT ('@    title "',A,'"'/ ,'@    subtitle "',A,'"'/ ,'@lege
     *nd on'/ ,'@    legend box linestyle 0'/ ,'@    legend x1 0.6'/,'@ 
     *   legend y1 0.75'/ ,'@    view xmin 0.250000'/ ,'@    xaxis  labe
     *l "',A,'"'/ ,'@    timestamp on'/ ,'@    yaxis  label "',A,'"')
      END IF
      IF ((AXISTYPE .EQ. 1 .AND. LOGY .EQ. 1)) THEN
         WRITE(UNITNUM,6880) 'xy'
         WRITE(6,6930)
6930     FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
     *,/'  Log scale requested for Y axis when one or more   ' ,/'Y data
     * points are 0 or negative.                  ' ,//'  Y axis scale c
     *hanged to linear.                   ' ,/' ------------------------
     *---------------------------'/)
      END IF
      IF ((AXISTYPE .EQ. 2 .AND. LOGX .EQ. 1)) THEN
         WRITE(UNITNUM,6880) 'xy'
         WRITE(6,6940)
6940     FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
     *,/'  Log scale requested for X axis when one or more   ' ,/'X data
     * points are 0 or negative.                  ' ,//'  X axis scale c
     *hanged to linear.                   ' ,/' ------------------------
     *---------------------------'/)
      END IF
      IF ((AXISTYPE .EQ. 3 .AND. (LOGX .EQ. 1 .OR. LOGY .EQ. 1))) THEN
         IF ((LOGX .EQ. 1 .AND. LOGY .EQ. 1)) THEN
            WRITE(UNITNUM,6880) 'xy'
            WRITE(6,6950)
6950        FORMAT (/' ----------WARNING from Subroutine XVGRPLOT-------
     *--' ,/'  Log scale requested for X axis and Y axis when    ' ,/'on
     *e or more X and Y data points are 0 or negative.' ,//'  X and Yaxe
     *s scales changed to linear.            ' ,/' ---------------------
     *------------------------------'/)
         ELSE IF((LOGX .EQ. 1)) THEN
            WRITE(UNITNUM,6880) 'logy'
            WRITE(6,6940)
         ELSE
            WRITE(UNITNUM,6880) 'logx'
            WRITE(6,6930)
         END IF
      END IF
      IF ((CURVENUM .LT. 10 )) THEN
         WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM
      ELSE
         WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM
      END IF
      WRITE(UNITNUM,6960) CURVENUM,SERIESTITLE(1:SERIESLENGTH)
6960  FORMAT ('@    legend string ',I2,' "',A,'"')
      WRITE(UNITNUM,6970)
6970  FORMAT ('@TYPE xy')
      IF ((CURVENUM .LT. 10)) THEN
         WRITE(UNITNUM,6980) CURVENUM
         IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,6990) CURVENUM, CURVENUM+1
         ELSE
            WRITE(UNITNUM,7000) CURVENUM, CURVENUM+1
         END IF
      ELSE
         WRITE(UNITNUM,7010) CURVENUM
         WRITE(UNITNUM,7020) CURVENUM, CURVENUM+1
      END IF
6980  FORMAT ('@    s',I1,' errorbar length 0.000000')
7010  FORMAT ('@    s',I2,' errorbar length 0.000000')
6990  FORMAT ('@    s',I1,' symbol color ',I2)
7000  FORMAT ('@    s',I1,' symbol color ',I1)
7020  FORMAT ('@    s',I2,' symbol color ',I2)
      DO 7031 COUNT=1,NPTS1
         WRITE(UNITNUM,7040) X(COUNT),Y(COUNT)
7031  CONTINUE
7032  CONTINUE
7040  FORMAT (1PE15.4,1PE15.4)
      WRITE(UNITNUM,'(''&'')')
      RETURN
      END
      SUBROUTINE ZONEGRID(NRADIAL, NDEPTH, NRMIN, NZMIN, NZ, RESULTS, UN
     *CRT, NCOMP, RADIAL_BINS, DEPTH_BINS, LABELS, EXPLANATIONS)
      IMPLICIT NONE
      character*1 title(80)
      COMMON/IODAT1/TITLE
      integer*4 RADNUM, DEEPNUM, NRADIAL, NDEPTH, NCOMP, REGNUM, FMT, TM
     *P1
      logical SFIG
      logical ROT
      real*8 RESULTS(100,10,4), UNCRT(100,10,4), RADIAL_BINS(10),DEPTH_B
     *INS( 101), TMP2,TMP3
      CHARACTER*60 EXPLANATIONS(4)
      CHARACTER*4 LABELS(4)
      integer*4 IOUT, ICOMP, IX, IZ, HSET, PGTHROW, DLYPT, COUNT,NZMIN,N
     *RMIN,NZ
      ROT=.FALSE.
      SFIG=.TRUE.
      IF ((NCOMP.GT.4)) THEN
         PGTHROW=20
      ELSE
         PGTHROW=17
      END IF
      IOUT=1
      RADNUM=NRADIAL
      DEEPNUM=NDEPTH
      COUNT = 0
      DO 7051 IX=1,RADNUM
         DO 7061 IZ=1,DEEPNUM
            DO 7071 ICOMP=1,NCOMP
               IF ((UNCRT(IZ, IX, ICOMP) .LT. 0.3)) THEN
                  COUNT = COUNT + 1
               END IF
7071        CONTINUE
7072        CONTINUE
7061     CONTINUE
7062     CONTINUE
7051  CONTINUE
7052  CONTINUE
      IF ((COUNT/(RADNUM*DEEPNUM*NCOMP) .GT. 0.1)) THEN
         SFIG=.FALSE.
      END IF
      IF (((DEEPNUM.LE.3).AND.(RADNUM.GT.3))) THEN
         ROT=.TRUE.
         DO 7081 IX=1,RADNUM
            IF ((IX .LE. DEEPNUM+1)) THEN
               TMP3=RADIAL_BINS(IX)
               RADIAL_BINS(IX)=DEPTH_BINS(IX)
               DEPTH_BINS(IX)=TMP3
            ELSE
               DEPTH_BINS(IX)=RADIAL_BINS(IX)
            END IF
            IF ((IX .LE. DEEPNUM)) THEN
               DO 7091 IZ=IX+1,DEEPNUM
                  DO 7101 ICOMP=1,NCOMP
                     TMP2=RESULTS(IZ,IX,ICOMP)
                     RESULTS(IZ,IX,ICOMP)=RESULTS(IX,IZ,ICOMP)
                     RESULTS(IX,IZ,ICOMP)=TMP2
                     TMP2=UNCRT(IZ,IX,ICOMP)
                     UNCRT(IZ,IX,ICOMP)=UNCRT(IX,IZ,ICOMP)
                     UNCRT(IX,IZ,ICOMP)=TMP2
7101              CONTINUE
7102              CONTINUE
7091           CONTINUE
7092           CONTINUE
            ELSE
               DO 7111 IZ=1,DEEPNUM
                  DO 7121 ICOMP=1,NCOMP
                     RESULTS(IX,IZ,ICOMP)=RESULTS(IZ,IX,ICOMP)
                     UNCRT(IX,IZ,ICOMP)=UNCRT(IZ,IX,ICOMP)
7121              CONTINUE
7122              CONTINUE
7111           CONTINUE
7112           CONTINUE
            END IF
7081     CONTINUE
7082     CONTINUE
         DEPTH_BINS(RADNUM+1)=RADIAL_BINS(RADNUM+1)
         TMP1=RADNUM
         RADNUM=DEEPNUM
         DEEPNUM=TMP1
      END IF
      WRITE (IOUT, *) '\f'
      WRITE(IOUT, 400) ' '
      call egs_fdate(iout)
      write(iout,'(//)')
      IF ((ROT)) THEN
         WRITE(IOUT, 93) TITLE
      ELSE
         WRITE(IOUT, 94) TITLE
      END IF
      DO 7131 ICOMP=1,NCOMP
         WRITE(IOUT, 95) LABELS(ICOMP), EXPLANATIONS(ICOMP)
7131  CONTINUE
7132  CONTINUE
      DO 7141 HSET=1,RADNUM,3
         IF ((RADNUM-HSET.GT.1)) THEN
            FMT=3
         ELSE
            IF ((MOD(RADNUM,3) .EQ. 1)) THEN
               FMT=1
            END IF
            IF ((MOD(RADNUM,3) .EQ. 2)) THEN
               FMT=2
            END IF
         END IF
         WRITE (IOUT, 91) (RADIAL_BINS(IX),IX=HSET,HSET+FMT)
         PGTHROW=PGTHROW+1
         DO 7151 IZ=1,DEEPNUM
            IF ((ROT)) THEN
               REGNUM= (IZ+NRMIN-1)*NZ + HSET+NZMIN
            ELSE
               REGNUM= (HSET+NRMIN-1)*NZ + IZ+NZMIN
            END IF
            IF ((FMT.EQ.1)) THEN
               WRITE (IOUT, 10) DEPTH_BINS(IZ)
               IF ((SFIG)) THEN
                  IF ((ROT)) THEN
                     WRITE (IOUT, 15) REGNUM,HSET+NZMIN-1,IZ+NRMIN
                  ELSE
                     WRITE (IOUT, 15) REGNUM,IZ+NZMIN-1,HSET+NRMIN
                  END IF
               ELSE
                  IF ((ROT)) THEN
                     WRITE (IOUT, 18) REGNUM,HSET+NZMIN-1,IZ+NRMIN
                  ELSE
                     WRITE (IOUT, 18) REGNUM,IZ+NZMIN-1,HSET+NRMIN
                  END IF
               END IF
            END IF
            IF ((FMT.EQ.2)) THEN
               WRITE (IOUT, 11) DEPTH_BINS(IZ)
               IF ((SFIG)) THEN
                  IF ((ROT)) THEN
                     WRITE(IOUT,14) REGNUM,HSET+NZMIN-1,IZ+NRMIN, REGNUM
     *               +1,HSET+NZMIN,IZ+NRMIN
                  ELSE
                     WRITE(IOUT,14) REGNUM,IZ+NZMIN-1,HSET+NRMIN, REGNUM
     *               +NZ,IZ+NZMIN-1,HSET+NRMIN+1
                  END IF
               ELSE
                  IF ((ROT)) THEN
                     WRITE(IOUT,17) REGNUM,HSET+NZMIN-1,IZ+NRMIN, REGNUM
     *               +1,HSET+NZMIN, IZ+NRMIN
                  ELSE
                     WRITE(IOUT,17) REGNUM,IZ+NZMIN-1,HSET+NRMIN, REGNUM
     *               +NZ,IZ+NZMIN-1,HSET+NRMIN+1
                  END IF
               END IF
            END IF
            IF ((FMT.EQ.3)) THEN
               WRITE (IOUT, 12) DEPTH_BINS(IZ)
               IF ((SFIG)) THEN
                  IF ((ROT)) THEN
                     WRITE (IOUT,13)REGNUM,HSET+NZMIN-1,IZ+NRMIN, REGNUM
     *               +1,HSET+NZMIN,IZ+NRMIN, REGNUM+2,HSET+NZMIN+1,IZ+NR
     *               MIN
                  ELSE
                     WRITE (IOUT, 13) REGNUM,IZ+NZMIN-1,HSET+NRMIN, REGN
     *               UM+NZ,IZ+NZMIN-1,HSET+NRMIN+1, REGNUM+NZ*2,IZ+NZMIN
     *               -1,HSET+NRMIN+2
                  END IF
               ELSE
                  IF ((ROT)) THEN
                     WRITE (IOUT,16)REGNUM,HSET+NZMIN-1,IZ+NRMIN, REGNUM
     *               +1,HSET+NZMIN,IZ+NRMIN, REGNUM+2,HSET+NZMIN+1,IZ+NR
     *               MIN
                  ELSE
                     WRITE (IOUT, 16)REGNUM,IZ+NZMIN-1,HSET+NRMIN, REGNU
     *               M+NZ,IZ+NZMIN-1,HSET+NRMIN+1, REGNUM+NZ*2,IZ+NZMIN-
     *               1,HSET+NRMIN+2
                  END IF
               END IF
            END IF
            PGTHROW=PGTHROW+2
            DO 7161 ICOMP=1,NCOMP
               IF ((SFIG)) THEN
                  IF ((FMT.EQ.3)) THEN
                     WRITE(IOUT, 3) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP)
     *               , UNCRT(IZ,HSET,ICOMP),LABELS(ICOMP), RESULTS(IZ,HS
     *               ET+1,ICOMP),UNCRT(IZ,HSET+1,ICOMP), LABELS(ICOMP),R
     *               ESULTS(IZ,HSET+2,ICOMP), UNCRT(IZ,HSET+2,ICOMP)
                  END IF
                  IF ((FMT.EQ.2)) THEN
                     WRITE(IOUT, 2) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP)
     *               , UNCRT(IZ,HSET,ICOMP),LABELS(ICOMP), RESULTS(IZ,HS
     *               ET+1,ICOMP),UNCRT(IZ,HSET+1,ICOMP)
                  END IF
                  IF ((FMT.EQ.1)) THEN
                     WRITE(IOUT, 1) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP)
     *               , UNCRT(IZ,HSET,ICOMP)
                  END IF
               ELSE
                  IF ((FMT.EQ.3)) THEN
                     WRITE(IOUT, 6) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP)
     *               , UNCRT(IZ,HSET,ICOMP),LABELS(ICOMP), RESULTS(IZ,HS
     *               ET+1,ICOMP),UNCRT(IZ,HSET+1,ICOMP), LABELS(ICOMP),R
     *               ESULTS(IZ,HSET+2,ICOMP), UNCRT(IZ,HSET+2,ICOMP)
                  END IF
                  IF ((FMT.EQ.2)) THEN
                     WRITE(IOUT, 5) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP)
     *               , UNCRT(IZ,HSET,ICOMP),LABELS(ICOMP), RESULTS(IZ,HS
     *               ET+1,ICOMP),UNCRT(IZ,HSET+1,ICOMP)
                  END IF
                  IF ((FMT.EQ.1)) THEN
                     WRITE(IOUT, 4) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP)
     *               , UNCRT(IZ,HSET,ICOMP)
                  END IF
               END IF
               PGTHROW=PGTHROW+1
7161        CONTINUE
7162        CONTINUE
            IF ((MOD(PGTHROW,65).GT.(61-NCOMP))) THEN
               IF ((IZ.NE.DEEPNUM)) THEN
                  IF ((FMT.EQ.1)) THEN
                     WRITE (IOUT, 10) DEPTH_BINS(IZ+1)
                  END IF
                  IF ((FMT.EQ.2)) THEN
                     WRITE (IOUT, 11) DEPTH_BINS(IZ+1)
                  END IF
                  IF ((FMT.EQ.3)) THEN
                     WRITE (IOUT, 12) DEPTH_BINS(IZ+1)
                  END IF
                  WRITE (IOUT, *) '\f'
                  PGTHROW=10
                  WRITE(IOUT, 400) ' '
                  call egs_fdate(iout)
                  write(iout,'(//)')
                  IF ((ROT)) THEN
                     WRITE(IOUT, 93) TITLE
                  ELSE
                     WRITE(IOUT, 94) TITLE
                  END IF
                  WRITE (IOUT, 91) (RADIAL_BINS(IX),IX=HSET,HSET+FMT)
               ELSE
                  DLYPT = HSET
               END IF
            END IF
7151     CONTINUE
7152     CONTINUE
         IF ((FMT.EQ.1)) THEN
            WRITE (IOUT, 10) DEPTH_BINS(DEEPNUM+1)
         END IF
         IF ((FMT.EQ.2)) THEN
            WRITE (IOUT, 11) DEPTH_BINS(DEEPNUM+1)
         END IF
         IF ((FMT.EQ.3)) THEN
            WRITE (IOUT, 12) DEPTH_BINS(DEEPNUM+1)
         END IF
         IF (((DLYPT.EQ.HSET).AND.(RADNUM-HSET.GT.2))) THEN
            WRITE (IOUT, *) '\f'
            PGTHROW=10
            WRITE(IOUT, 400) ' '
            call egs_fdate(iout)
            write(iout,'(//)')
            IF ((ROT)) THEN
               WRITE(IOUT, 93) TITLE
            ELSE
               WRITE(IOUT, 94) TITLE
            END IF
         END IF
         PGTHROW=PGTHROW+1
7141  CONTINUE
7142  CONTINUE
1     FORMAT (T11, '|', A4, 1PE10.3, '+-', 0PF4.1, '%', '|')
2     FORMAT (T11, '|', 1 (A4, 1PE10.3, '+-', 0PF4.1, '%', ' |'), A4, 1P
     *E10.3, '+-', 0PF4.1, '%', '|')
3     FORMAT (T11, '|', 2 (A4, 1PE10.3, '+-', 0PF4.1, '%', ' |'), A4, 1P
     *E10.3, '+-', 0PF4.1, '%', '|')
4     FORMAT (T11, '|', A4, 1PE10.3, '+-', 0PF5.2, '%', '|')
5     FORMAT (T11, '|', 1 (A4, 1PE10.3, '+-', 0PF5.2, '%', ' |'), A4, 1P
     *E10.3, '+-', 0PF5.2, '%', '|')
6     FORMAT (T10, '|', 2 (A4, 1PE10.3, '+-', 0PF5.2, '%', '|'), A4, 1PE
     *10.3, '+-', 0PF5.2, '%', '|')
10    FORMAT (1X, F9.4, T11, 1 (23 ('-')))
11    FORMAT (1X, F9.4, T11, 2 (23 ('-')))
12    FORMAT (1X, F9.4, T11, 3 (23 ('-')))
13    FORMAT (T11, '|', 2 ('IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |'), 'I
     *RL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'|')
14    FORMAT (T11, '|', 'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |', 'IRL',
     *I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'|')
15    FORMAT (T11, '|', 'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'|')
16    FORMAT (T10, '|', 2 ('IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |'), 'I
     *RL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |')
17    FORMAT (T11, '|', 1 ('IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'  |'), '
     *IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |')
18    FORMAT (T11, '|', 'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |')
91    FORMAT (/ T7,F9.4,T30,F9.4,T53,F9.4,T70,F9.4)
93    FORMAT (' ',79A1 // T19, 27H ZONAL OUTPUT GRID: ROTATED / T20, '**
     *************************')
94    FORMAT (' ',79A1 // T19, 31H ZONAL OUTPUT GRID: NON-ROTATED / T20,
     *'******************************')
95    FORMAT (T14, A4, T19, A60)
400   FORMAT (T54,a1,$)
      RETURN
      END
      SUBROUTINE MATERIALGRID(NRADIAL, NDEPTH, MASSVOL, MORV, ECUTS, PCU
     *TS, RCYL, ZPLANE, MED, MEDIA, CDSTBL, CTRTBL, CABSRB)
      IMPLICIT NONE
      character*1 title(80)
      COMMON/IODAT1/TITLE
      integer*4 RADNUM, DEEPNUM, NRADIAL, NDEPTH, NCOMP, REGNUM, FMT, TM
     *P1
      logical ESTEPSON, ECUTON, PCUTON, ROT
      real*8 VALUES(100,10,4), RCYL(10),ZPLANE(100), RADIAL_BINS(100),DE
     *PTH_BINS(100), MASSVOL(100,10), ECUTS( 1001), PCUTS( 1001), TMP2(1
     *00,10,4),TMP3(100),CHINDEX(100)
      CHARACTER*60 EXPLANATIONS(4)
      CHARACTER*4 LABELS(4)
      CHARACTER*4 MED_NAME1(11),MED_NAME2(11),MED_NAME3(11)
      CHARACTER*4 MEDIA(24, 3)
      CHARACTER*4 CDSTBL( 1001), CTRTBL( 1001),CABSRB( 1001)
      integer*2 MED( 1001)
      integer*4 MNUM1, MNUM2, MNUM3, MORV
      integer*4 IOUT, ICOMP, IZ, IX, IRL, HSET, PGTHROW, DLYPT, J, COUNT
      ROT=.FALSE.
      ESTEPSON=.FALSE.
      ECUTON=.FALSE.
      PCUTON=.FALSE.
      NCOMP=1
      PGTHROW=14+NCOMP
      IOUT=1
      DEEPNUM=NDEPTH
      RADNUM=NRADIAL
      IF ((RCYL(1).EQ.0.)) THEN
         DO 7171 IX=1,RADNUM+1
            RADIAL_BINS(IX)=RCYL(IX)
7171     CONTINUE
7172     CONTINUE
      ELSE
         DO 7181 IX=1,RADNUM+1
            RADIAL_BINS(IX+1)=RCYL(IX)
7181     CONTINUE
7182     CONTINUE
      END IF
      DO 7191 IZ=1,DEEPNUM+1
         DEPTH_BINS(IZ)=ZPLANE(IZ)
7191  CONTINUE
7192  CONTINUE
      IF ((MORV.EQ.1)) THEN
         LABELS(NCOMP)='MASS'
         EXPLANATIONS(NCOMP)='MASS OF EACH REGION IN GRAMS'
      END IF
      IF ((MORV.EQ.2)) THEN
         LABELS(NCOMP)='VOL '
         EXPLANATIONS(NCOMP)='VOLUME OF EACH REGION IN cm^3'
      END IF
      DO 7201 IX=1,RADNUM
         DO 7211 IZ=1,DEEPNUM
            VALUES(IZ, IX, NCOMP)=MASSVOL(IZ, IX)
            IRL=IZ+DEEPNUM*(IX-1)+1
            IF ((CDSTBL(1).EQ.'0')) THEN
               CDSTBL(IRL)=' '
            END IF
            IF ((CTRTBL(1).EQ.'0')) THEN
               CTRTBL(IRL)=' '
            END IF
            IF ((CABSRB(1).EQ.'0')) THEN
               CABSRB(IRL)=' '
            END IF
            IF ((ECUTS(IRL).NE.ECUTS(2))) THEN
               ECUTON=.TRUE.
            END IF
            IF ((PCUTS(IRL).NE.PCUTS(2))) THEN
               PCUTON=.TRUE.
            END IF
7211     CONTINUE
7212     CONTINUE
7201  CONTINUE
7202  CONTINUE
      IF ((ECUTON)) THEN
         NCOMP=NCOMP+1
         LABELS(NCOMP)='ECUT'
         EXPLANATIONS(NCOMP)='ECUT (PRINTED BECAUSE DIFFERENT FROM GLOBA
     *L)'
         DO 7221 IX=1,RADNUM
            DO 7231 IZ=1,DEEPNUM
               IRL=IZ+DEEPNUM*(IX-1)+1
               VALUES(IZ, IX, NCOMP)=ECUTS(IRL)
7231        CONTINUE
7232        CONTINUE
7221     CONTINUE
7222     CONTINUE
      END IF
      IF ((PCUTON)) THEN
         NCOMP=NCOMP+1
         LABELS(NCOMP)='PCUT'
         EXPLANATIONS(NCOMP)='PCUT (PRINTED BECAUSE DIFFERENT FROM GLOBA
     *L)'
         DO 7241 IX=1,RADNUM
            DO 7251 IZ=1,DEEPNUM
               IRL=IZ+DEEPNUM*(IX-1)+1
               VALUES(IZ, IX, NCOMP)=PCUTS(IRL)
7251        CONTINUE
7252        CONTINUE
7241     CONTINUE
7242     CONTINUE
      END IF
      PGTHROW=14+NCOMP
      IF (((DEEPNUM.LE.3).AND.(RADNUM.GT.3))) THEN
         ROT=.TRUE.
         CHINDEX(RADNUM+1)=RADIAL_BINS(RADNUM+1)
         DO 7261 IX=1,RADNUM
            TMP3(IX)=DEPTH_BINS(IX)
            CHINDEX(IX)=RADIAL_BINS(IX)
            DEPTH_BINS(IX)=CHINDEX(IX)
            RADIAL_BINS(IX)=TMP3(IX)
            DO 7271 IZ=1,DEEPNUM
               DO 7281 ICOMP=1,NCOMP
                  TMP2(IZ, IX, ICOMP)=VALUES(IZ, IX, ICOMP)
7281           CONTINUE
7282           CONTINUE
7271        CONTINUE
7272        CONTINUE
7261     CONTINUE
7262     CONTINUE
         DO 7291 IX=1,RADNUM
            DO 7301 IZ=1,DEEPNUM
               DO 7311 ICOMP=1,NCOMP
                  VALUES(IX, IZ, ICOMP)=TMP2(IZ, IX, ICOMP)
7311           CONTINUE
7312           CONTINUE
7301        CONTINUE
7302        CONTINUE
7291     CONTINUE
7292     CONTINUE
         DEPTH_BINS(RADNUM+1)=CHINDEX(RADNUM+1)
         TMP1=RADNUM
         RADNUM=DEEPNUM
         DEEPNUM=TMP1
      END IF
      WRITE (IOUT, *) '\f'
      WRITE(IOUT, 400) ' '
      call egs_fdate(iout)
      write(iout,'(//)')
      IF ((ROT)) THEN
         WRITE(IOUT, 93) TITLE
      ELSE
         WRITE(IOUT, 94) TITLE
      END IF
      WRITE(IOUT, 95) (LABELS(ICOMP),EXPLANATIONS(ICOMP), ICOMP=1, NCOMP
     *)
      DO 7321 HSET=1,RADNUM,3
         IF ((RADNUM-HSET.GT.1)) THEN
            FMT=3
         ELSE
            IF ((MOD(RADNUM,3) .EQ. 1)) THEN
               FMT=1
            END IF
            IF ((MOD(RADNUM,3) .EQ. 2)) THEN
               FMT=2
            END IF
         END IF
         WRITE (IOUT, 91) (RADIAL_BINS(IX),IX=HSET,HSET+FMT)
         PGTHROW=PGTHROW+1
         DO 7331 IZ=1,DEEPNUM
            IF ((ROT)) THEN
               REGNUM=2+(IZ-1)*FMT+(HSET-1)*RADNUM
            ELSE
               REGNUM=( IZ+1+((HSET-1)*DEEPNUM) )
            END IF
            IF ((ROT)) THEN
               MNUM1=MED(REGNUM)
               MNUM2=MED(REGNUM+1)
               MNUM3=MED(REGNUM+2)
            ELSE
               MNUM1=MED(REGNUM)
               MNUM2=MED(REGNUM+DEEPNUM)
               MNUM3=MED(REGNUM+DEEPNUM*2)
            END IF
            IF ((MNUM1.EQ.0)) THEN
               MED_NAME1(1)='V'
               MED_NAME1(2)='A'
               MED_NAME1(3)='C'
               MED_NAME1(4)='U'
               MED_NAME1(5)='U'
               MED_NAME1(6)='M'
               DO 7341 J=7,11
                  MED_NAME1(J)=' '
7341           CONTINUE
7342           CONTINUE
            ELSE
               DO 7351 COUNT=1,11
                  MED_NAME1(COUNT) = MEDIA(COUNT, MNUM1)
7351           CONTINUE
7352           CONTINUE
            END IF
            IF ((MNUM2.EQ.0)) THEN
               MED_NAME2(1)='V'
               MED_NAME2(2)='A'
               MED_NAME2(3)='C'
               MED_NAME2(4)='U'
               MED_NAME2(5)='U'
               MED_NAME2(6)='M'
               DO 7361 J=7,11
                  MED_NAME2(J)=' '
7361           CONTINUE
7362           CONTINUE
            ELSE
               DO 7371 COUNT=1,11
                  MED_NAME2(COUNT) = MEDIA(COUNT,MNUM2)
7371           CONTINUE
7372           CONTINUE
            END IF
            IF ((MNUM3.EQ.0)) THEN
               MED_NAME3(1)='V'
               MED_NAME3(2)='A'
               MED_NAME3(3)='C'
               MED_NAME3(4)='U'
               MED_NAME3(5)='U'
               MED_NAME3(6)='M'
               DO 7381 J=7,11
                  MED_NAME3(J)=' '
7381           CONTINUE
7382           CONTINUE
            ELSE
               DO 7391 COUNT=1,11
                  MED_NAME3(COUNT) = MEDIA(COUNT,MNUM3)
7391           CONTINUE
7392           CONTINUE
            END IF
            IF ((FMT.EQ.1)) THEN
               WRITE (IOUT, 10) DEPTH_BINS(IZ)
               IF ((ROT)) THEN
                  WRITE (IOUT, 15) REGNUM,HSET,IZ
               ELSE
                  WRITE (IOUT, 15) REGNUM,IZ,HSET
               END IF
               WRITE (IOUT, 4) CDSTBL(REGNUM),CTRTBL(REGNUM), CABSRB(REG
     *         NUM), (MED_NAME1(J),J=1,11)
            END IF
            IF ((FMT.EQ.2)) THEN
               WRITE (IOUT, 11) DEPTH_BINS(IZ)
               IF ((ROT)) THEN
                  WRITE(IOUT,14) REGNUM,HSET,IZ, REGNUM+1,HSET+1,IZ
                  WRITE(IOUT, 5) CDSTBL(REGNUM),CTRTBL(REGNUM), CABSRB(R
     *            EGNUM), (MED_NAME1(J),J=1,11), CDSTBL(REGNUM+1),CTRTBL
     *            (REGNUM+1), CABSRB(REGNUM+1), (MED_NAME2(J),J=1,11)
               ELSE
                  WRITE(IOUT,14) REGNUM,IZ,HSET, REGNUM+DEEPNUM,IZ,HSET+
     *            1
                  WRITE(IOUT, 5) CDSTBL(REGNUM),CTRTBL(REGNUM), CABSRB(R
     *            EGNUM), (MED_NAME1(J),J=1,11), CDSTBL(REGNUM+DEEPNUM),
     *            CTRTBL(REGNUM+DEEPNUM), CABSRB(REGNUM+DEEPNUM),(MED_NA
     *            ME2(J),J=1,11)
               END IF
            END IF
            IF ((FMT.EQ.3)) THEN
               WRITE (IOUT, 12) DEPTH_BINS(IZ)
               IF ((ROT)) THEN
                  WRITE (IOUT, 13) REGNUM,HSET,IZ,REGNUM+1, HSET+1,IZ,RE
     *            GNUM+2,HSET+2,IZ
                  WRITE (IOUT, 6) CDSTBL(REGNUM),CTRTBL(REGNUM), CABSRB(
     *            REGNUM), (MED_NAME1(J),J=1,11), CDSTBL(REGNUM+1),CTRTB
     *            L(REGNUM+1), CABSRB(REGNUM+1), (MED_NAME2(J),J=1,11),
     *            CDSTBL(REGNUM+2),CTRTBL(REGNUM+2), CABSRB(REGNUM+2), (
     *            MED_NAME3(J),J=1,11)
               ELSE
                  WRITE (IOUT, 13) REGNUM,IZ,HSET,REGNUM+DEEPNUM, IZ,HSE
     *            T+1,REGNUM+DEEPNUM*2,IZ,HSET+2
                  WRITE (IOUT, 6) CDSTBL(REGNUM),CTRTBL(REGNUM), CABSRB(
     *            REGNUM), (MED_NAME1(J),J=1,11), CDSTBL(REGNUM+DEEPNUM)
     *            ,CTRTBL(REGNUM+DEEPNUM), CABSRB(REGNUM+DEEPNUM), (MED_
     *            NAME2(J),J=1,11), CDSTBL(REGNUM+DEEPNUM*2),CTRTBL(REGN
     *            UM+DEEPNUM*2), CABSRB(REGNUM+DEEPNUM*2), (MED_NAME3(J)
     *            ,J=1,11)
               END IF
            END IF
            PGTHROW=PGTHROW+3
            DO 7401 ICOMP=1,NCOMP
               IF ((FMT.EQ.3)) THEN
                  WRITE(IOUT, 3) LABELS(ICOMP),VALUES(IZ,HSET,ICOMP), LA
     *            BELS(ICOMP),VALUES(IZ,HSET+1,ICOMP), LABELS(ICOMP),VAL
     *            UES(IZ,HSET+2,ICOMP)
               END IF
               IF ((FMT.EQ.2)) THEN
                  WRITE(IOUT, 2) LABELS(ICOMP),VALUES(IZ,HSET,ICOMP), LA
     *            BELS(ICOMP),VALUES(IZ,HSET+1,ICOMP)
               END IF
               IF ((FMT.EQ.1)) THEN
                  WRITE(IOUT, 1) LABELS(ICOMP),VALUES(IZ,HSET,ICOMP)
               END IF
               PGTHROW=PGTHROW+1
7401        CONTINUE
7402        CONTINUE
            IF ((MOD(PGTHROW,65).GT.(60-NCOMP))) THEN
               IF ((IZ.NE.DEEPNUM)) THEN
                  IF ((FMT.EQ.1)) THEN
                     WRITE (IOUT, 10) DEPTH_BINS(IZ+1)
                  END IF
                  IF ((FMT.EQ.2)) THEN
                     WRITE (IOUT, 11) DEPTH_BINS(IZ+1)
                  END IF
                  IF ((FMT.EQ.3)) THEN
                     WRITE (IOUT, 12) DEPTH_BINS(IZ+1)
                  END IF
                  WRITE (IOUT, *) '\f'
                  PGTHROW=15
                  WRITE(IOUT, 400) ' '
                  call egs_fdate(iout)
                  write(iout,'(//)')
                  IF ((ROT)) THEN
                     WRITE(IOUT, 93) TITLE
                  ELSE
                     WRITE(IOUT, 94) TITLE
                  END IF
                  WRITE (IOUT, 91) (RADIAL_BINS(IX),IX=HSET,HSET+FMT)
               ELSE
                  DLYPT = HSET
               END IF
            END IF
7331     CONTINUE
7332     CONTINUE
         IF ((FMT.EQ.1)) THEN
            WRITE (IOUT, 10) DEPTH_BINS(DEEPNUM+1)
         END IF
         IF ((FMT.EQ.2)) THEN
            WRITE (IOUT, 11) DEPTH_BINS(DEEPNUM+1)
         END IF
         IF ((FMT.EQ.3)) THEN
            WRITE (IOUT, 12) DEPTH_BINS(DEEPNUM+1)
         END IF
         IF (((DLYPT.EQ.HSET).AND.(RADNUM-HSET.GT.2))) THEN
            WRITE (IOUT, *) '\f'
            PGTHROW=17
            WRITE(IOUT, 400) ' '
            call egs_fdate(iout)
            write(iout,'(//)')
            IF ((ROT)) THEN
               WRITE(IOUT, 93) TITLE
            ELSE
               WRITE(IOUT, 94) TITLE
            END IF
         END IF
         PGTHROW=PGTHROW+1
7321  CONTINUE
7322  CONTINUE
1     FORMAT (T11, '|', 2X, A4, 2X, 1PE10.3, 2X, ' |')
2     FORMAT (T11, '|', 2 (2X, A4, 2X, 1PE10.3, 2X, ' |'))
3     FORMAT (T11, '|', 3 (2X, A4, 2X, 1PE10.3, 2X, ' |'))
4     FORMAT (T11, '|', 1X, '/', 3 (A1, '/'), 11A1, '  |')
5     FORMAT (T11, '|', 2 (1X, '/', 3 (A1, '/'), 11A1, '  |'))
6     FORMAT (T11, '|', 3 (1X, '/', 3 (A1, '/'), 11A1, '  |'))
10    FORMAT (1X, F9.4, T11, 23 ('-'))
11    FORMAT (1X, F9.4, T11, 45 ('-'))
12    FORMAT (1X, F9.4, T11, 67 ('-'))
13    FORMAT (T11, '|', 3 ('IRL', I3, 1X, 'IZ ', I3, 1X, 'IX ', I3, 1X,'
     *|'))
14    FORMAT (T11, '|', 2 ('IRL', I3, 1X, 'IZ ', I3, 1X, 'IX ', I3, 1X,'
     *|'))
15    FORMAT (T11, '|', 'IRL', I3, 1X, 'IZ ', I3, 1X, 'IX ', I3, 1X, '|'
     *)
91    FORMAT (/ T7, F9.4, T30, F9.4, T53, F9.4, T70, F9.4)
93    FORMAT (' ',79A1 // T19, 29H ZONAL MATERIAL GRID: ROTATED / T21, '
     ***************************'/, /T4 , '/X/Y/Z/MED :  X = " " IS DEFA
     *ULT: OPTION NOT USED'/, T18, '  = "D" IF DOSE SCORING REGION'/, T1
     *8, 'X = "C" IF CAVITY REGION'/, T18, 'X = "S" IF SPR SCORING REGIO
     *N'/, T18, 'Y = "T" IF TRACKING REGION'/, T18, 'Z = "A" IF TOTALLYA
     *BSORBING REGION'/, T16, 'MED = MEDIUM NAME, 11 CHARACTER ABREVIATI
     *ON')
94    FORMAT (' ',79A1 // T19, 33H ZONAL MATERIAL GRID: NON-ROTATED / T2
     *1, '******************************'/ /T4 , '/X/Y/Z/MED :  X = " "I
     *S DEFAULT: OPTION NOT USED'/, T18, '  = "D" IF DOSE SCORING REGION
     *'/, T18, '  = "C" IF CAVITY REGION'/, T18, '  = "S" IF SPR SCORING
     * REGION'/, T18, 'Y = "T" IF TRACKING REGION'/, T18, 'Z = "A" IF TO
     *TALLY ABSORBING REGION'/, T16, 'MED = MEDIUM NAME, 11 CHARACTER AB
     *REVIATION')
95    FORMAT (T10, A4, ' = ', A60)
400   FORMAT (/T54,a1,$)
      RETURN
      END
      SUBROUTINE WATCH(IARG,IWATCH)
      implicit none
      integer*4 iarg,iwatch,IP,ICOUNT,JHSTRY,J,N
      real*8 KE
      integer*4 graph_unit
      integer egs_open_file
      integer*4 ku,kr,ka
      COMMON/BOUNDS/ECUT( 1001),PCUT( 1001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DATA ICOUNT/0/,JHSTRY/1/ graph_unit/-1/
      save ICOUNT,JHSTRY,graph_unit
      ku = 13
      kr = 0
      ka = 1
      IF ((IARG .EQ. -99)) THEN
         DO 7411 J=1,29
            IAUSFL(J)=1
7411     CONTINUE
7412     CONTINUE
         IAUSFL(22)=0
         IAUSFL(23)=0
         IAUSFL(24)=0
      END IF
      IF ((IARG .EQ. -1)) THEN
         IF ((IWATCH .EQ. 4)) THEN
            IF (( graph_unit .LT. 0 )) THEN
               graph_unit = egs_open_file(ku,kr,ka,'.egsgph')
            END IF
            WRITE(graph_unit,7420) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY
            JHSTRY=JHSTRY+1
         ELSE
            WRITE(6,7430)JHSTRY
7430        FORMAT(' END OF HISTORY',I8,3X,40('*')/)
            JHSTRY=JHSTRY+1
            ICOUNT=ICOUNT+2
            RETURN
         END IF
      END IF
      IF (( (IWATCH .NE. 4) .AND. ((ICOUNT .GE. 50) .OR. (ICOUNT .EQ. 0)
     * .OR. (IARG .EQ. -99)) )) THEN
         ICOUNT=1
         WRITE(6,7440)
7440     FORMAT(//T39,' NP',3X,'ENERGY  Q REGION    X',7X, 'Y',7X,'Z',6X
     *,'U',6X,'V',6X,'W',6X,'LATCH',2X,'WEIGHT'/)
      END IF
      IF (((IWATCH .EQ. 4) .AND. (IARG .GE. 0) .AND. (IARG .NE. 5))) THE
     *N
         IF((graph_unit .LT. 0))graph_unit = egs_open_file(ku,kr,ka,'.eg
     *sgph')
         WRITE(graph_unit,7420) NP,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),E(NP)
7420     FORMAT(2I4,1X,I6,4G15.8,I12)
      END IF
      IF((IARG .EQ. 5 .OR. IARG .LT. 0))RETURN
      IF((IWATCH .EQ. 4))RETURN
      KE=E(NP)
      IF ((IQ(NP).NE.0)) THEN
         KE=E(NP)-PRM
      END IF
      IF ((IARG .EQ. 0 .AND. IWATCH .EQ. 2)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,7450)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
7450     FORMAT(T11,'STEP ABOUT TO OCCUR', T36,':',I5,F9.3,2I4,3F8.3,3F7
     *.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 0)) THEN
         RETURN
      END IF
      IF (( IARG .EQ. 1)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,7460)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
7460     FORMAT(' Discard  AE,AP<E<ECUT',T36,':',I5,F9.3,2I4,3F8.3,3F7.3
     *,I10,1PE10.3)
      ELSE IF((IARG .EQ. 2)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,7470)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
7470     FORMAT(' Discard  E<AE,AP',T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,
     *1PE10.3)
      ELSE IF((IARG .EQ. 3)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,7480)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
7480     FORMAT(' Discard -user request',T36,':',I5,F9.3,2I4,3F8.3,3F7.3
     *,I10,1PE10.3)
      ELSE IF((IARG .EQ. 4)) THEN
         WRITE(6,7490)EDEP,IR(NP)
7490     FORMAT(T10,'Local energy deposition',T36,':',F12.5,' MeV in reg
     *ion ',I6)
      ELSE IF((IARG .EQ. 6)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,7500)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
7500     FORMAT(' bremsstrahlung  about to occur',T36,':',I5,F9.3,2I4,3F
     *8.3,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 7)) THEN
         IF ((nbr_split .EQ.1)) THEN
            DO 7511 IP=NPold,NP
               IF ((IQ(IP).EQ.-1)) THEN
                  KE = E(IP) - RM
                  ICOUNT=ICOUNT+1
                  WRITE(6,7520)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7520              FORMAT(T10,'Resulting electron',T36,':',I5,F9.3,2I4,3F
     *8.3,3F7.3,I10,1PE10.3)
               ELSE
                  KE = E(IP)
                  ICOUNT=ICOUNT+1
                  WRITE(6,7530)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7530              FORMAT(T10,'Resulting photon',T36,':',I5,F9.3,2I4,3F8.
     *3,3F7.3,I10,1PE10.3)
               END IF
7511        CONTINUE
7512        CONTINUE
         ELSE
            KE = E(NPold) - RM
            ICOUNT=ICOUNT+1
            WRITE(6,7540)NPold,KE,IQ(NPold),IR(NPold),X(NPold),Y(NPold),
     *      Z(NPold),U(NPold),V(NPold), W(NPold),LATCH(NPold),WT(NPold)
7540        FORMAT(T10,'Resulting electron',T36,':',I5,F9.3,2I4,3F8.3,3F
     *7.3,I10,1PE10.3)
            DO 7551 IP=NPold+1,NP
               KE= E(IP)
               IF ((IP .EQ. NPold+1)) THEN
                  ICOUNT=ICOUNT+1
                  WRITE(6,7560)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7560              FORMAT(T10,'Split photons',T36,':',I5,F9.3,2I4,3F8.3,3
     *F7.3,I10,1PE10.3)
               ELSE
                  ICOUNT=ICOUNT+1
                  WRITE(6,7570)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7570              FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
               END IF
7551        CONTINUE
7552        CONTINUE
         END IF
      ELSE IF((IARG .EQ. 8)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,7580)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
7580     FORMAT(' Moller   about to occur',T36,':',I5,F9.3,2I4,3F8.3,3F7
     *.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 9)) THEN
         IF ((NP.EQ.NPold)) THEN
            ICOUNT=ICOUNT+1
            WRITE(6,7590)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(N
     *      P), W(NP),LATCH(NP),WT(NP)
7590        FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
         ELSE
            DO 7601 IP=NPold,NP
               KE = E(IP) - ABS(IQ(NP))*RM
               IF ((IP.EQ.NPold)) THEN
                  ICOUNT=ICOUNT+1
                  WRITE(6,7610)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7610              FORMAT(T11,'Resulting electrons',T36,':',I5,F9.3,2I4,3
     *F8.3,3F7.3,I10,1PE10.3)
               ELSE
                  ICOUNT=ICOUNT+1
                  WRITE(6,7620)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7620              FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
               END IF
7601        CONTINUE
7602        CONTINUE
         END IF
      ELSE IF((IARG .EQ. 10)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,7630)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
7630     FORMAT(' Bhabba   about to occur',T36,':',I5,F9.3,2I4,3F8.3,3F7
     *.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 11)) THEN
         IF ((NP.EQ.NPold)) THEN
            ICOUNT=ICOUNT+1
            WRITE(6,7640)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(N
     *      P), W(NP),LATCH(NP),WT(NP)
7640        FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
         ELSE
            DO 7651 IP=NPold,NP
               KE = E(IP) - ABS(IQ(IP))*RM
               IF ((IP.EQ.NPold)) THEN
                  ICOUNT=ICOUNT+1
                  WRITE(6,7660)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7660              FORMAT(T11,'Resulting e- or e+',T36,':',I5,F9.3,2I4,3F
     *8.3,3F7.3,I10,1PE10.3)
               ELSE
                  ICOUNT=ICOUNT+1
                  WRITE(6,7670)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7670              FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
               END IF
7651        CONTINUE
7652        CONTINUE
         END IF
      ELSE IF((IARG .EQ. 12)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,7680)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
7680     FORMAT(' Positron about to decay in flight',T36,':',I5,F9.3,2I4
     *,3F8.3,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 13)) THEN
         IF ((NP.EQ.NPold)) THEN
            ICOUNT=ICOUNT+1
            WRITE(6,7690)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(N
     *      P), W(NP),LATCH(NP),WT(NP)
7690        FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
         ELSE
            DO 7701 IP=NPold,NP
               KE = E(IP) - ABS(IQ(IP))*RM
               IF ((IP.EQ.NPold)) THEN
                  ICOUNT=ICOUNT+1
                  WRITE(6,7710)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7710              FORMAT(T11,'Resulting photons',T36,':',I5,F9.3,2I4,3F8
     *.3,3F7.3,I10,1PE10.3)
               ELSE
                  ICOUNT=ICOUNT+1
                  WRITE(6,7720)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7720              FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
               END IF
7701        CONTINUE
7702        CONTINUE
         END IF
      ELSE IF((IARG .EQ. 28)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,7730)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
7730     FORMAT(' Positron will annihilate at rest',T36,':',I5,F9.3,2I4,
     *3F8.3,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 14)) THEN
         IF ((NP.EQ.NPold)) THEN
            ICOUNT=ICOUNT+1
            WRITE(6,7740)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(N
     *      P), W(NP),LATCH(NP),WT(NP)
7740        FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
         ELSE
            DO 7751 IP=NPold,NP
               KE = E(IP) - ABS(IQ(IP))*RM
               IF ((IP.EQ.NPold)) THEN
                  ICOUNT=ICOUNT+1
                  WRITE(6,7760)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7760              FORMAT(' Positron annihilates at rest',T36,':',I5,F9.3
     *,2I4,3F8.3,3F7.3,I10,1PE10.3)
               ELSE
                  ICOUNT=ICOUNT+1
                  WRITE(6,7770)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7770              FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
               END IF
7751        CONTINUE
7752        CONTINUE
         END IF
      ELSE IF((IARG .EQ. 15)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,7780)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
7780     FORMAT(' Pair production about to occur',T36,':',I5,F9.3,2I4,3F
     *8.3,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 16)) THEN
         IF ((NP.EQ.NPold .AND. i_survived_rr .EQ. 0)) THEN
            ICOUNT=ICOUNT+1
            WRITE(6,7790)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(N
     *      P), W(NP),LATCH(NP),WT(NP)
7790        FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
         ELSE IF((NP.EQ.NPold .AND. i_survived_rr .GT. 0)) THEN
            WRITE(6,7800)i_survived_rr,prob_rr
7800        FORMAT(T10,'Russian Roulette eliminated ',I2, ' particle(s)w
     *ith probability ',F8.5)
            ICOUNT=ICOUNT+1
            WRITE(6,7810)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(N
     *      P), W(NP),LATCH(NP),WT(NP)
7810        FORMAT(T10,'Now on top of stack',T36,':',I5,F9.3,2I4,3F8.3,3
     *F7.3,I10,1PE10.3)
         ELSE
            DO 7821 IP=NPold,NP
               KE = E(IP) - ABS(IQ(IP))*RM
               IF ((IP.EQ.NPold)) THEN
                  ICOUNT=ICOUNT+1
                  WRITE(6,7830)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7830              FORMAT(T11,'Resulting pair',T36,':',I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
               ELSE
                  ICOUNT=ICOUNT+1
                  WRITE(6,7840)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7840              FORMAT(T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
               END IF
7821        CONTINUE
7822        CONTINUE
            IF ((i_survived_rr .GT. 0)) THEN
               WRITE(6,7850)i_survived_rr,prob_rr
7850           FORMAT(T10,'Russian Roulette eliminated ',I2,'           
     *                        particle(s) with probability ',F8.5)
               ICOUNT=ICOUNT+1
               WRITE(6,7860)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),
     *         V(NP), W(NP),LATCH(NP),WT(NP)
7860           FORMAT(T10,'Now on top of stack',T36,':',I5,F9.3,2I4,3F8.
     *3,3F7.3,I10,1PE10.3)
            END IF
         END IF
      ELSE IF((IARG .EQ. 17)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,7870)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
7870     FORMAT(' Compton  about to occur',T36,':',I5,F9.3,2I4,3F8.3,3F7
     *.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 18)) THEN
         IF ((NP .EQ. NPold .AND. i_survived_rr .EQ. 0)) THEN
            ICOUNT=ICOUNT+1
            WRITE(6,7880)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(N
     *      P), W(NP),LATCH(NP),WT(NP)
7880        FORMAT(T11,'Interaction rejected',T36,':',I5,F9.3,2I4,3F8.3,
     *3F7.3,I10,1PE10.3)
         ELSE IF((NP .GT. NPold)) THEN
            DO 7891 IP=NPold,NPold+1
               KE = E(IP) - ABS(IQ(IP))*RM
               IF ((IQ(IP).NE.0)) THEN
                  ICOUNT=ICOUNT+1
                  WRITE(6,7900)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7900              FORMAT(T11,'compton electron created',T36,':',I5,F9.3,
     *2I4,3F8.3,3F7.3,I10,1PE10.3)
               ELSE
                  ICOUNT=ICOUNT+1
                  WRITE(6,7910)IP,KE,IQ(IP),IR(IP),X(IP),Y(IP),Z(IP),U(I
     *            P),V(IP), W(IP),LATCH(IP),WT(IP)
7910              FORMAT(T11,'compton scattered photon',T36,':',I5,F9.3,
     *2I4,3F8.3,3F7.3,I10,1PE10.3)
               END IF
7891        CONTINUE
7892        CONTINUE
         END IF
         IF ((i_survived_rr .GT. 0)) THEN
            WRITE(6,7920)i_survived_rr,prob_rr
7920        FORMAT(T10,'Russian Roulette eliminated ',I2, ' particle(s)w
     *ith probability ',F8.5)
            ICOUNT=ICOUNT+1
            WRITE(6,7930)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(N
     *      P), W(NP),LATCH(NP),WT(NP)
7930        FORMAT(T10,'Now on top of stack',T36,':',I5,F9.3,2I4,3F8.3,3
     *F7.3,I10,1PE10.3)
         END IF
      ELSE IF((IARG .EQ. 19)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,7940)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
7940     FORMAT(' Photoelectric about to occur',T36,':',I5,F9.3,2I4,3F8.
     *3,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 20)) THEN
         IF ((NPold.EQ.NP .AND. IQ(NP).EQ.0 .AND. i_survived_rr .EQ. 0))
     *    THEN
            ICOUNT=ICOUNT+1
            WRITE(6,7950)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(N
     *      P), W(NP),LATCH(NP),WT(NP)
7950        FORMAT(T11,'Photon energy below N-shell',/, T11,'Photon disc
     *arded',T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3)
         ELSE IF((IQ(NPold) .EQ. -1 .AND. i_survived_rr .EQ. 0)) THEN
            KE= E(NPold)-RM
            ICOUNT=ICOUNT+1
            WRITE(6,7960)NPold,KE,IQ(NPold),IR(NPold),X(NPold),Y(NPold),
     *      Z(NPold),U(NPold),V(NPold), W(NPold),LATCH(NPold),WT(NPold)
7960        FORMAT(T10,'Resulting photoelectron',T36,':',I5,F9.3,2I4,3F8
     *.3,3F7.3,I10,1PE10.3)
         ELSE IF((i_survived_rr .GT. 0)) THEN
            IF ((NP.EQ.NPold-1 .OR. IQ(NPold) .NE. -1)) THEN
               IF ((i_survived_rr .GT. 1)) THEN
                  WRITE(6,7970)i_survived_rr-1,prob_rr
7970              FORMAT(T10,'Russian Roulette eliminated ',I4, ' partic
     *le(s) with probability ',F8.5,' plus')
               END IF
               WRITE(6,7980)prob_rr
7980           FORMAT(T10,'Russian Roulette eliminated resulting photoel
     *ectron', ' with probability ',F8.5)
            ELSE
               KE = E(NPold) - RM
               ICOUNT=ICOUNT+1
               WRITE(6,7990)NPold,KE,IQ(NPold),IR(NPold),X(NPold),Y(NPol
     *         d),Z(NPold),U(NPold),V(NPold), W(NPold),LATCH(NPold),WT(N
     *         Pold)
7990           FORMAT(T10,'Resulting photoelectron?',T36,':',I5,F9.3,2I4
     *,3F8.3,3F7.3,I10,1PE10.3)
               WRITE(6,8000)i_survived_rr,prob_rr
8000           FORMAT(T10,'Russian Roulette eliminated ',I4, ' particle(
     *s) with probability ',F8.5)
            END IF
            ICOUNT=ICOUNT+1
            WRITE(6,8010)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(N
     *      P), W(NP),LATCH(NP),WT(NP)
8010        FORMAT(T10,'Now on top of stack',T36,':',I5,F9.3,2I4,3F8.3,3
     *F7.3,I10,1PE10.3)
         END IF
      ELSE IF((IARG .EQ. 24)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,8020)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
8020     FORMAT(' Rayleigh scattering occured',T36,':',I5,F9.3,2I4,3F8.3
     *,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 25)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,8030)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
8030     FORMAT(T10,'Fluorescent X-ray created',T36,':',I5,F9.3,2I4,3F8.
     *3,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 26)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,8040)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
8040     FORMAT(T10,'Coster-Kronig e- created',T36,':',I5,F9.3,2I4,3F8.3
     *,3F7.3,I10,1PE10.3)
      ELSE IF((IARG .EQ. 27)) THEN
         ICOUNT=ICOUNT+1
         WRITE(6,8050)NP,KE,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),U(NP),V(NP),
     *    W(NP),LATCH(NP),WT(NP)
8050     FORMAT(T10,'Auger electron created',T36,':',I5,F9.3,2I4,3F8.3,3
     *F7.3,I10,1PE10.3)
      END IF
      IF ((IARG .EQ. 0 .AND. IWATCH .EQ. 2)) THEN
         WRITE(6,8060)USTEP,TUSTEP,VSTEP,TVSTEP,EDEP
8060     FORMAT(T5,'USTEP,TUSTEP,VSTEP,TVSTEP,EDEP',T36,':    ',5(1PE13.
     *4))
         ICOUNT=ICOUNT+1
      END IF
      IF((NP .EQ. 1 .OR. IARG .EQ. 0))RETURN
      IF (( IARG .LE. 3)) THEN
         N=NP-1
         KE = E(N) - ABS(IQ(N))*RM
         ICOUNT=ICOUNT+1
         WRITE(6,8070)N,KE,IQ(N),IR(N),X(N),Y(N),Z(N),U(N),V(N), W(N),LA
     *   TCH(N),WT(N)
8070     FORMAT(T10,'Now on top of stack',T36,':',I5,F9.3,2I4,3F8.3,3F7.
     *3,I10,1PE10.3)
      END IF
      RETURN
      END
      SUBROUTINE SIGMA(NDATA,ISTAT,MODE,IERR)
      implicit none
      integer*4 NDATA,ISTAT,MODE,IERR
      COMMON/ERROR/DATA( 1000,2)
      real*8 data
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 n,non0,i
      real*8 stat,sdenom
      real*8 emax,avg,error,datum,argmnt
      DATA EMAX/99.9/
      IERR=0
      IF (((MODE .LT. 0) .OR. (MODE .GT. 2))) THEN
         MODE=2
         IERR=1
      END IF
      IF (((NDATA.LE.0).OR.(NDATA.GT. 1000).OR.(ISTAT.LE.0).OR.(ISTAT.GT
     *.2))) THEN
         IERR=-1
         RETURN
      END IF
      IF ((ISTAT .EQ. 1)) THEN
         IERR=10
         DO 8081 N=1,NDATA
            DATA(N,2)=EMAX
8081     CONTINUE
8082     CONTINUE
         RETURN
      END IF
      IF ((MODE.NE.0)) THEN
         STAT=FLOAT(ISTAT)
         SDENOM=STAT*(STAT-1.)
      END IF
      DO 8091 N=1,NDATA
         NON0=0
         AVG=0.0
         ERROR=0.0
         DO 8101 I=1,ISTAT
            DATUM=DATA(N,I)
            IF ((DATUM.NE.0.0)) THEN
               NON0=NON0+1
               AVG=AVG+DATUM
               ERROR=ERROR+DATUM**2
            END IF
8101     CONTINUE
8102     CONTINUE
         IF ((NON0 .EQ. 0)) THEN
            IERR=11
            ERROR=EMAX
            GOTO 8110
         ELSE IF(((NON0 .EQ. 1) .AND. (MODE .EQ. 0))) THEN
            ERROR=EMAX
            GOTO8110
         ELSE
            IF ((MODE .EQ. 0)) THEN
               STAT=FLOAT(NON0)
               SDENOM=STAT*(STAT-1.)
            END IF
         END IF
         AVG=AVG/STAT
         ARGMNT=ERROR-STAT*AVG**2
         IF ((ARGMNT.LT.0.0)) THEN
            WRITE(6,8120)ARGMNT,ERROR,STAT,AVG,SDENOM
8120        FORMAT(' ***** - SQ RT IN SIGMA. ARGMNT,ERROR,STAT,AVG,SDENO
     *M='/' ',5E12.4)
            ARGMNT=0.0
         END IF
         ERROR=SQRT(ARGMNT/SDENOM)
         IF ((AVG .EQ. 0.)) THEN
            ERROR=EMAX
         ELSE
            ERROR=100.*ERROR/ABS(AVG)
         END IF
         IF((MODE .EQ. 2))AVG=AVG*STAT
8110     CONTINUE
         DATA(N,1)=AVG
         DATA(N,2)=MIN(EMAX,ERROR)
8091  CONTINUE
8092  CONTINUE
      RETURN
      END
      subroutine prepare_alias_sampling(nsbin,fs_array,ws_array,ibin_arr
     *ay)
      implicit none
      integer*4 nsbin,ibin_array(nsbin)
      real*8 fs_array(nsbin),ws_array(nsbin)
      integer*4 i,j_l,j_h
      real*8 sum,aux
      sum = 0
      DO 8131 i=1,nsbin
         IF((fs_array(i) .LT. 1e-30))fs_array(i) = 1e-30
         ws_array(i) = -fs_array(i)
         ibin_array(i) = 1
         sum = sum + fs_array(i)
8131  CONTINUE
8132  CONTINUE
      sum = sum/nsbin
      DO 8141 i=1,nsbin-1
         DO 8151 j_h=1,nsbin
            IF (( ws_array(j_h) .LT. 0 )) THEN
               IF((abs(ws_array(j_h)) .GT. sum))GOTO 8160
            END IF
8151     CONTINUE
8152     CONTINUE
         j_h = nsbin
8160     CONTINUE
            DO 8161 j_l=1,nsbin
            IF (( ws_array(j_l) .LT. 0 )) THEN
               IF((abs(ws_array(j_l)) .LT. sum))GOTO 8170
            END IF
8161     CONTINUE
8162     CONTINUE
         j_l = nsbin
8170     aux = sum - abs(ws_array(j_l))
         ws_array(j_h) = ws_array(j_h) + aux
         ws_array(j_l) = -ws_array(j_l)/sum
         ibin_array(j_l) = j_h
         IF((i .EQ. nsbin-1))ws_array(j_h) = 1
8141  CONTINUE
8142  CONTINUE
      return
      end
      real*8 function alias_sample(nsbin,xs_array,ws_array,ibin_array)
      implicit none
      integer*4 nsbin,ibin_array(nsbin)
      real*8 xs_array(0:nsbin),ws_array(nsbin)
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      real*8 v1,v2,aj
      integer*4 j
      IF((rng_seed .GT. 128))call ranmar_get
      v1 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((rng_seed .GT. 128))call ranmar_get
      v2 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      aj = 1 + v1*nsbin
      j = aj
      IF((j .GT. nsbin))j = nsbin
      aj = aj - j
      IF (( aj .GT. ws_array(j) )) THEN
         j = ibin_array(j)
      END IF
      alias_sample = (1-v2)*xs_array(j-1) + v2*xs_array(j)
      return
      end
      SUBROUTINE XVGRPLOT (X, Y, ERRY, NPTS, CURVENUM, SERIESTITLE, XTIT
     *LE, YTITLE, GRAPHTITLE, SUBTITLE, UNITNUM, TYPE, HISTXMIN, AXISTYP
     *E)
      IMPLICIT NONE
      integer*4 MAX, IDEBUG
      PARAMETER (MAX = 400)
      integer*4 NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE
      real*8 X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,HISTXMIN,ERRYOLD,SMALLESTX,
     * SMALLESTY,FUDGE
      integer*4 TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENG
     *TH
      integer*4 LOGX, LOGY, LOGDY,ZEROYCOUNT
      CHARACTER*(*) SUBTITLE
      CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE
      CHARACTER*10 INDEX
      CHARACTER*3 INDEXNUM
      logical TESTFILE, ALLPOS
      real*8 one
      parameter (one = 1)
      FUDGE = 1.e-10
      IDEBUG = 0
      IF ((IDEBUG .EQ. 1)) THEN
        write(6,'(//'' Entering xvgrplot ''/)')
        write(6,'('' Curve'',I3,'' to go to unit'',I3)')CURVENUM,UNITNUM
        write(6,'(''SERIESTITLE: '',a60)') SERIESTITLE
        write(6,'(''XTITLE:      '',a60)') XTITLE
        write(6,'(''YTITLE       '',a60)') YTITLE
        write(6,'(''GRAPHTILE:   '',a60)') graphtitle
        write(6,'(''SUBTITLE:    '',a80)') subtitle
      END IF
      IF (( NPTS .gt. MAX)) THEN
        WRITE(6,8180)NPTS, MAX
8180    FORMAT(//' **************************'/ ' Number of points asked
     * for =', I5, ' is greater than max allowed of', I4/ ' Setting NPTS
     * to MAX, you could adjust MAX in xvgrplot.mortran'/ ' ************
     ***************'//)
        NPTS1 = MAX
      ELSE
        NPTS1 = NPTS
      END IF
      INQUIRE(UNIT = UNITNUM,OPENED=TESTFILE)
      IF ((.NOT.TESTFILE)) THEN
        WRITE(6,6790) UNITNUM
6790    FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------' ,/'
     *   Unit specified (',I2,') is not open.' ,/'   Unit must be opened
     * before using subroutine.' ,/'   Data not written to file.' ,/'  -
     *---------------------------------------------'//)
        RETURN
      END IF
      IF ((GRAPHTITLE .EQ. ' ')) THEN
        GRAPHTITLE = 'Untitled Graph - No title specified in subroutine'
      END IF
      IF ((XTITLE .EQ. ' ')) THEN
        XTITLE = 'X-axis not titled in subroutine'
      END IF
      IF ((YTITLE .EQ. ' ')) THEN
        YTITLE = 'Y-axis not titled in subroutine'
      END IF
      IF ((SERIESTITLE .EQ. ' ')) THEN
        SERIESTITLE = 'series # '
        INDEX = '0123456789'
        INDEXNUM = INDEX(CURVENUM+1:CURVENUM+1)
        SERIESTITLE(9:9) = INDEXNUM
      END IF
      TITLELENGTH = 61
      SUBLENGTH = 61
      XAXISLENGTH = 61
      YAXISLENGTH = 61
      SERIESLENGTH = 61
8191  CONTINUE
        TITLELENGTH = TITLELENGTH - 1
        IF(((GRAPHTITLE(TITLELENGTH:TITLELENGTH) .NE. ' ')))GO TO8192
      GO TO 8191
8192  CONTINUE
8201  CONTINUE
        SUBLENGTH = SUBLENGTH - 1
        IF(((SUBTITLE(SUBLENGTH:SUBLENGTH) .NE. ' ')))GO TO8202
      GO TO 8201
8202  CONTINUE
8211  CONTINUE
        XAXISLENGTH = XAXISLENGTH - 1
        IF(((XTITLE(XAXISLENGTH:XAXISLENGTH) .NE. ' ')))GO TO8212
      GO TO 8211
8212  CONTINUE
8221  CONTINUE
        YAXISLENGTH = YAXISLENGTH - 1
        IF(((YTITLE(YAXISLENGTH:YAXISLENGTH) .NE. ' ')))GO TO8222
      GO TO 8221
8222  CONTINUE
8231  CONTINUE
        SERIESLENGTH = SERIESLENGTH - 1
        IF(((SERIESTITLE(SERIESLENGTH:SERIESLENGTH) .NE. ' ')))GO TO8232
      GO TO 8231
8232  CONTINUE
      IF (( IDEBUG .EQ. 1)) THEN
        WRITE(6,8240)SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITL
     *  ELENGTH
8240    FORMAT(' SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELEN
     *GTH'/ 5I10)
      END IF
      LOGX = 0
      LOGY = 0
      LOGDY = 0
      ZEROYCOUNT=0
      ALLPOS=.TRUE.
      IF (( X(1).EQ.0.0 )) THEN
        SMALLESTX = 0.1
      ELSE
        SMALLESTX=X(1)
      END IF
      IF (( Y(1).EQ.0.0 )) THEN
        SMALLESTY = 0.1
      ELSE
        SMALLESTY=Y(1)
      END IF
      DO 8251 COUNT=1,NPTS1
        IF (((X(COUNT) .LT. SMALLESTX) .AND. (X(COUNT).NE.0.))) THEN
          SMALLESTX=X(COUNT)
        END IF
        IF (((Y(COUNT) .LT. SMALLESTY) .AND. (Y(COUNT).NE.0.))) THEN
          SMALLESTY=Y(COUNT)
        END IF
        IF (((X(COUNT) .LT. 0.).OR.(Y(COUNT) .LT. 0.))) THEN
          ALLPOS=.FALSE.
        END IF
8251  CONTINUE
8252  CONTINUE
      IF ((ALLPOS)) THEN
        DO 8261 COUNT=1,NPTS1
          IF ((X(COUNT).EQ.0.)) THEN
            X(COUNT)=SMALLESTX*FUDGE
          END IF
          IF ((Y(COUNT).EQ.0.)) THEN
            Y(COUNT)=SMALLESTY*FUDGE
          END IF
8261    CONTINUE
8262    CONTINUE
      END IF
      IF ((AXISTYPE .GT. 0)) THEN
        DO 8271 COUNT=1,NPTS1
          IF ((X(COUNT) .LE. 0.)) THEN
            LOGX = 1
          END IF
          IF ((Y(COUNT) .LE. 0.)) THEN
            LOGY = 1
          END IF
          IF (((Y(COUNT)-ERRY(COUNT)) .LE. 0.)) THEN
            LOGDY = 1
          END IF
8271    CONTINUE
8272    CONTINUE
      ELSE
        DO 8281 COUNT=1,NPTS1
          IF ((Y(COUNT)-ERRY(COUNT) .LT. Y(COUNT)-0.9999*Y(COUNT) .AND.
     *    Y(COUNT).GT.0.)) THEN
            ZEROYCOUNT=ZEROYCOUNT+1
            IF ((ZEROYCOUNT.EQ.1)) THEN
              WRITE(6,8290)
8290          FORMAT (/' ------------WARNING from Subroutine XVGRPLOT---
     *--------' ,/'  Some errors give 0 value and so are adjusted so   '
     * ,/'  that you can switch to a log Y scale while in xmgr.   ',/' -
     *------------------------------------------------------'/)
            END IF
            ERRYOLD=ERRY(COUNT)
            ERRY(COUNT) = 0.9999*Y(COUNT)
          END IF
8281    CONTINUE
8282    CONTINUE
      END IF
      IF ((CURVENUM .EQ. 0)) THEN
        IF ((AXISTYPE .EQ. 0)) THEN
          WRITE(UNITNUM,6880) 'xy'
        ELSE IF((AXISTYPE .EQ. 1)) THEN
          WRITE(UNITNUM,6880) 'logy'
          WRITE(UNITNUM,6890)
        ELSE IF((AXISTYPE .EQ. 2)) THEN
          WRITE(UNITNUM,6880) 'logx'
          WRITE(UNITNUM,6890)
        ELSE IF((AXISTYPE .EQ. 3)) THEN
          WRITE(UNITNUM,6880) 'logxy'
          WRITE(UNITNUM,6890)
          WRITE(UNITNUM,6900)
        ELSE
          WRITE(6,6910) AXISTYPE
6910      FORMAT (//'  ------------Error in Subroutine XVGRPLOT---------
     *--' ,/'   AXISTYPE specified (',I2,') is not a valid option.' ,/' 
     *----------------------------------------------'//)
          RETURN
        END IF
6880    FORMAT ('@g0 type ',A,' ')
6890    FORMAT ('@    xaxis  ticklabel format exponential')
6900    FORMAT ('@    yaxis  ticklabel format exponential')
        WRITE(UNITNUM,6920) GRAPHTITLE(1:TITLELENGTH) ,SUBTITLE(1:SUBLEN
     *  GTH) ,XTITLE(1:XAXISLENGTH) ,YTITLE(1:YAXISLENGTH)
6920    FORMAT ('@    title "',A,'"'/ ,'@    subtitle "',A,'"'/ ,'@    l
     *egend on'/ ,'@    legend box linestyle 0'/ ,'@    legend x1 0.6'/,
     *'@    legend y1 0.75'/ ,'@    view xmin 0.250000'/ ,'@    xaxis  l
     *abel "',A,'"'/ ,'@    timestamp on'/ ,'@    yaxis  label "',A,'"')
      END IF
      IF ((AXISTYPE .EQ. 1 .AND. LOGY .EQ. 1)) THEN
        WRITE(UNITNUM,6880) 'xy'
        WRITE(6,6930)
6930    FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------',
     */'  Log scale requested for Y axis when one or more   ' ,/'  Ydata
     * points are 0 or negative.                  ' ,//'  Y axis scale c
     *hanged to linear.                   ' ,/' ------------------------
     *---------------------------'/)
      END IF
      IF ((AXISTYPE .EQ. 2 .AND. LOGX .EQ. 1)) THEN
        WRITE(UNITNUM,6880) 'xy'
        WRITE(6,6940)
6940    FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------',
     */'  Log scale requested for X axis when one or more   ' ,/'  Xdata
     * points are 0 or negative.                  ' ,//'  X axis scale c
     *hanged to linear.                   ' ,/' ------------------------
     *---------------------------'/)
      END IF
      IF ((AXISTYPE .EQ. 3 .AND. (LOGX .EQ. 1 .OR. LOGY .EQ. 1))) THEN
        IF ((LOGX .EQ. 1 .AND. LOGY .EQ. 1)) THEN
          WRITE(UNITNUM,6880) 'xy'
          WRITE(6,6950)
6950      FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------
     *' ,/'  Log scale requested for X axis and Y axis when    ' ,/'  on
     *e or more X and Y data points are 0 or negative.' ,//'  X and Y ax
     *es scales changed to linear.            ' ,/' --------------------
     *-------------------------------'/)
        ELSE IF((LOGX .EQ. 1)) THEN
          WRITE(UNITNUM,6880) 'logy'
          WRITE(6,6940)
        ELSE
          WRITE(UNITNUM,6880) 'logx'
          WRITE(6,6930)
        END IF
      END IF
      IF ((LOGDY .EQ. 1 .AND. LOGY .NE. 1 .AND. (AXISTYPE .EQ. 3 .OR. AX
     *ISTYPE .EQ. 1))) THEN
        WRITE(6,8300)
8300    FORMAT (/' ------------WARNING from Subroutine XVGRPLOT---------
     *--' ,/'  Log scale requested for Y axis, and Y value less      ' ,
     */'  error gives 0 or negative value.                      ' ,//'  
     *Error adjusted to aviod negavite values on log scale. ' ,/' ------
     *-------------------------------------------------'/)
        DO 8311 COUNT=1,NPTS1
          IF ((Y(COUNT)-ERRY(COUNT) .LT. Y(COUNT)-0.9999*Y(COUNT))) THEN
            ERRYOLD = ERRY(COUNT)
            ERRY(COUNT) = 0.9999*Y(COUNT)
            WRITE(6,8320) COUNT,ERRYOLD,ERRY(COUNT)
8320        FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, '
     * to' /'        ',1PE11.4,'.')
          END IF
8311    CONTINUE
8312    CONTINUE
        WRITE(6,8330)
8330    FORMAT (/' -----------------------------------------------------
     *--'/)
      END IF
      IF ((CURVENUM .LT. 10 )) THEN
        WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM
      ELSE
        WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM
      END IF
      WRITE(UNITNUM,6960) CURVENUM,SERIESTITLE(1:SERIESLENGTH)
6960  FORMAT ('@    legend string ',I2,' "',A,'"')
      IF ((TYPE .EQ. 0)) THEN
        DO 8341 COUNT=1,NPTS1
          IF ((ERRY(COUNT) .NE. 0)) THEN
            GOTO 8350
          END IF
8341    CONTINUE
8342    CONTINUE
        WRITE(UNITNUM,6970)
6970    FORMAT ('@TYPE xy')
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,6980) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,6990) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,7000) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,7010) CURVENUM
          WRITE(UNITNUM,7020) CURVENUM, CURVENUM+1
        END IF
6980    FORMAT ('@    s',I1,' errorbar length 0.000000')
7010    FORMAT ('@    s',I2,' errorbar length 0.000000')
6990    FORMAT ('@    s',I1,' symbol color ',I2)
7000    FORMAT ('@    s',I1,' symbol color ',I1)
7020    FORMAT ('@    s',I2,' symbol color ',I2)
        DO 8361 COUNT=1,NPTS1
          WRITE(UNITNUM,7040) X(COUNT),Y(COUNT)
8361    CONTINUE
8362    CONTINUE
7040    FORMAT (1PE15.4,1PE15.4)
        GOTO 8370
8350    CONTINUE
        WRITE(UNITNUM,8380)
8380    FORMAT ('@TYPE xydy')
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,6980) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,6990) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,7000) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,7010) CURVENUM
          WRITE(UNITNUM,7020) CURVENUM, CURVENUM+1
        END IF
        DO 8391 COUNT=1,NPTS1
          WRITE(UNITNUM,8400) X(COUNT),Y(COUNT),ERRY(COUNT)
8391    CONTINUE
8392    CONTINUE
8400    FORMAT (1PE15.4,1PE15.4,1PE15.4)
8370    CONTINUE
      ELSE
        YMIN = ABS(1.E5 * Y(1))
        DO 8411 COUNT=1,NPTS1
          IF ((ABS(Y(COUNT)) .LT. YMIN)) THEN
            YMIN = ABS(Y(COUNT))
          END IF
8411    CONTINUE
8412    CONTINUE
        YMIN = SIGN(one,Y(1)) * 1.E-5 * YMIN
        Y(NPTS1+1) = YMIN
        IF (((AXISTYPE .EQ. 2 .OR. AXISTYPE .EQ. 3) .AND. HISTXMIN .EQ.
     *  0)) THEN
          IF ((X(1) .EQ. (X(2)-X(1)))) THEN
            HISTXMIN = X(1)-0.5*(X(2)-X(1))
          ELSE
            HISTXMIN = X(1)-(X(2)-X(1))
          END IF
          WRITE(6,8420) HISTXMIN
8420      FORMAT (/' ---------WARNING from Subroutine XVGRPLOT--------',
     */'  Minimum bin for X specified as 0 with log scale  ' ,/'  on X a
     *xis.  Minimum X bin set to ',1PE10.3,'.' ,/' ---------------------
     *----------------------------'/)
        END IF
        DO 8431 COUNT=1,NPTS1
          IF ((ERRY(COUNT) .NE. 0.)) THEN
            GOTO 8440
          END IF
8431    CONTINUE
8432    CONTINUE
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,6980) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,6990) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,7000) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,7010) CURVENUM
          WRITE(UNITNUM,7020) CURVENUM, CURVENUM+1
        END IF
        WRITE(UNITNUM,6970)
        WRITE(UNITNUM,7040) HISTXMIN,YMIN
        WRITE(UNITNUM,7040) HISTXMIN,Y(1)
        DO 8451 COUNT=1,NPTS1
          WRITE(UNITNUM,7040) X(COUNT),Y(COUNT)
          WRITE(UNITNUM,7040) X(COUNT),Y(COUNT+1)
8451    CONTINUE
8452    CONTINUE
        GOTO 8460
8440    CONTINUE
        ERRY(NPTS1+1) = 0.0
        IF ((CURVENUM .LT. 10)) THEN
          WRITE(UNITNUM,6980) CURVENUM
          IF ((CURVENUM .EQ. 9)) THEN
            WRITE(UNITNUM,6990) CURVENUM, CURVENUM+1
          ELSE
            WRITE(UNITNUM,7000) CURVENUM, CURVENUM+1
          END IF
        ELSE
          WRITE(UNITNUM,7010) CURVENUM
          WRITE(UNITNUM,7020) CURVENUM, CURVENUM+1
        END IF
        WRITE(UNITNUM,8380)
        IF ((HISTXMIN .EQ. 0.0)) THEN
          HISTXMIN = SMALLESTX*FUDGE
        END IF
        WRITE(UNITNUM,8400) HISTXMIN, YMIN, 0.
        WRITE(UNITNUM,8400) HISTXMIN, Y(1), 0.
        WRITE(UNITNUM,8400) (X(1)+HISTXMIN)/2., Y(1), ERRY(1)
        DO 8471 COUNT=1,NPTS1
          WRITE (UNITNUM,8400) X(COUNT),Y(COUNT),0.
          WRITE (UNITNUM,8400) X(COUNT),Y(COUNT+1),0.
          IF ((COUNT .LT. NPTS1)) THEN
            WRITE (UNITNUM,8400) (X(COUNT)+X(COUNT+1))/2.,Y(COUNT+1),ERR
     *      Y(COUNT+1)
          END IF
8471    CONTINUE
8472    CONTINUE
8460    CONTINUE
      END IF
      WRITE(UNITNUM,'(''&'')')
      RETURN
      END
C##############################################################################
C
C   This file was automatically generated by configure version 2.0
C   It contains various subroutines and functions for date, time,
C   CPU time, host name, etc.
C
C   Attention: all changes will be lost the next time you run configure!
C
C##############################################################################


C##############################################################################
C
C  EGSnrc egs_system subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C egs_system(command)  runs a system command and returns the status
C                      command must be null-terminated
C*****************************************************************************
      integer function egs_system(command)
      character*(*) command
      integer system, istat
      istat = system(command)
      egs_system = istat
      return
      end

C##############################################################################
C
C  EGSnrc egs_isdir subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C  egs_isdir(file_name)  Returns .true., if the string file_name points to
C                        an existing directory. This version uses the lstat
C                        intrinsic and then tests for bit 14 being set in
C                        the mode element. This works on all Unix systems
C                        that I have access to (Linux, Aix, HP-UX, OSF1,
C                        Solaris, IRIX)
C
C*****************************************************************************

      logical function egs_isdir(file_name)
      implicit none
      character*(*) file_name
      integer*4 lnblnk1, res, array(13), l, lstat
      logical btest
      egs_isdir = .false.
      l = lnblnk1(file_name)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = char(0)
         ! On some systems lstat only works if the string is 0-terminated
      res = lstat(file_name,array)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = ' '
      if( res.eq.0 ) then
            ! Amost all compilers that have the lstat intrinsic return the
            ! file mode in the 3rd array element. But the PGI compiler has
            ! its own opinion on the subject and returns it in the 5th element
            ! That's why the relevant element is written as 3
            ! here, 3 gets replaced by the appropriate element
            ! by the configure script.
          if( btest(array(3),14) ) egs_isdir = .true.
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C***************************************************************************
C
C   egs_fdate(out):  print a 24 char date and time string in the form
C                         'Tue Mar 18 08:16:42 2003'
C                    to the unit specified by out without end of line
C                    i.e. the sequence
C                    write(6,'(a,$)') 'Today is '
C                    call egs_fdate(6)
C                    write(6,'(a)') '. Have a nice date'
C                    should result in something like
C                    Today is Tue Mar 18 08:16:42 2003. Have a nice date
C                    printed to unit 6.
C
C***************************************************************************

      subroutine egs_fdate(ounit)
      integer ounit
      character*24 string
      call fdate(string)
      write(ounit,'(a,$)') string
      end

C***************************************************************************
C
C   egs_get_fdate(string) assignes a 24 char date and time string to string
C                         string must be at least 24 chars long, otherwise
C                         this subroutine has no effect.
C
C***************************************************************************

      subroutine egs_get_fdate(string)
      character*(*) string
      if( len(string).ge.24 ) call fdate(string)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date_and_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


      subroutine egs_date_and_time(vnow)
      integer vnow(8)
      character dat*8,tim*10,zon*5
      call date_and_time(dat,tim,zon,vnow)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*************************************************************************
C
C egs_date(ounit): print a 11 char string in the form
C                     '18-Mar-2003'
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_date(ounit)
      integer ounit
      character string*24, dat*11
      call fdate(string)
      dat(1:2) = string(9:10)
      dat(3:3) = '-'
      dat(4:6) = string(5:7)
      dat(7:7) = '-'
      dat(8:11) = string(21:24)
      write(ounit,'(a,$)') dat
      return
      end

C##############################################################################
C
C  EGSnrc egs_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C $Id: egs_time_v1.f,v 1.1 2003/07/11 19:17:08 iwan Exp $
C*************************************************************************
C
C egs_time(ounit): print a 8 char string in the form hh:mm:ss
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_time(ounit)
      integer ounit
      character string*24
      call fdate(string)
      write(ounit,'(a,$)') string(12:19)
      return
      end

C##############################################################################
C
C  EGSnrc seconds timing subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_secnds(t0): returns seconds passed since midnight minus t0
C
C*****************************************************************************

      real function egs_secnds(t0)
      real t0,t1
      character dat*8,tim*10,zon*5
      integer values(8)
      call date_and_time(dat,tim,zon,values)
      t1 = 3600.*values(5) + 60.*values(6) + values(7) + 0.001*values(8)
      egs_secnds = t1 - t0
      return
      end

C*****************************************************************************
C
C real function egs_tot_time()
C
C   On first call returns seconds passed since 1/1/1970
C   On subsequent calls returns
C     - seconds since last call, if flag = 0
C     - seconds since first call, else
C
C*****************************************************************************

      real function egs_tot_time(flag)
      integer flag
      character dat*8,tim*10,zon*5
      integer vnow(8), vlast(8),i
      real t,egs_time_diff,t0
      data vlast/1970,1,1,5*0/,t0/-1/
      save vlast,t0
      call date_and_time(dat,tim,zon,vnow)
      t = egs_time_diff(vlast,vnow)
      do i=1,8
        vlast(i)=vnow(i)
      end do
      if( t0.lt.0 ) then
        t0 = 0
        egs_tot_time = t
      else
        t0 = t0 + t
        if(flag.eq.0) then
          egs_tot_time = t
        else
          egs_tot_time = t0
        end if
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date and time subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C****************************************************************************
C
C Returns the time difference between vstart and vend
C vstart and vend are integer arrays of dimension 8 with elements
C corresponding to the specification of the data_and_time routine, i.e.
C   array(1) = year
C   array(2) = month of the year   (1...12)
C   array(3) = day of the month    (1...31)
C   array(4) = difference in minutes from UTC
C   array(5) = hour of the day     (1...23)
C   array(6) = minute of the hour  (1...59)
C   array(7) = seconds of the minute (1...59)
C   array(8) = miliseconds of the second (1...999)
C
C Note: this implementation ignores the time difference from UTC field
C
C*****************************************************************************
      real function egs_time_diff(vstart,vend)
      integer    vstart(8),vend(8)
      real       egs_time_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_time_diff = -egs_time_diff_o(vend,vstart)
      else
        egs_time_diff = egs_time_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C day difference between the dates specified by the integer arrays vstart and
C vend. The arrays are v(1)=year, v(2)=month, v(3)=day
C
C******************************************************************************
      integer function egs_day_diff(vstart,vend)
      integer vstart(3),vend(3),egs_day_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_day_diff = -egs_day_diff_o(vend,vstart)
      else
        egs_day_diff = egs_day_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C Returns a 3-letter abreviation of the day of the week in the string day,
C given a day specified by the integer array values
C   values(1)=year, values(2)=month, values(3)=day
C
C******************************************************************************
      subroutine egs_weekday(values,day)
      character*(*) day
      integer       values(3)
      integer       days,vtmp(3),egs_day_diff,aux
      character*3   wdays(7)
      data wdays/'Mon','Tue','Wed','Thu','Fri','Sat','Sun'/
      vtmp(1) = 1970
      vtmp(2) = 1
      vtmp(3) = 1
      days = egs_day_diff(vtmp,values)
      aux = mod(days,7)
      days = 4 + aux
      if( days.gt.7 ) days = days - 7
      day(:len(day)) = ' '
      aux = min(len(day),3)
      day(:aux) = wdays(days)(:aux)
      return
      end

C*****************************************************************************
C
C Same as egs_day_diff above, but assumes that vend specifies a later date
C than vstart.
C
C*****************************************************************************
      integer function egs_day_diff_o(vstart,vend)
      integer vstart(3),vend(3)
      integer    days
      logical    next_month
      integer    tm,m,ty,y
      integer    mdays(12)
      data       mdays/31,28,31,30,31,30,31,31,30,31,30,31/
      days = 0
      ty = vstart(1)
      y  = vend(1)
      tm = vstart(2)
      m  = vend(2)
      next_month = .true.
      do while(next_month)
        if( tm.eq.m.and.ty.eq.y ) then
          next_month = .false.
        else
          days = days + mdays(tm)
          if( tm.eq.2.and.mod(ty,4).eq.0 ) days = days + 1
          tm = tm + 1
          if( tm.gt.12 ) then
            ty = ty + 1
            tm = 1
          end if
        end if
      end do
      days = days + vend(3) - vstart(3)
      egs_day_diff_o = days
      return
      end

C******************************************************************************
C
C Same as egs_time_diff above, but assumes that vend specifies a later date
C than vstart.
C
C******************************************************************************
      real function egs_time_diff_o(vstart,vend)
      integer    vstart(8),vend(8)
      integer    days,hours,minutes,secs,msecs
      integer    egs_day_diff_o
      days = egs_day_diff_o(vstart,vend)
      hours = vend(5) - vstart(5)
      minutes = vend(6) - vstart(6)
      secs = vend(7) - vstart(7)
      msecs = vend(8) - vstart(8)
      egs_time_diff_o = 3600.*(24.*days+hours)+60.*minutes+secs+
     &                  0.001*msecs
      return
      end

C******************************************************************************
C
C Returns in month a 3-letter abreviation of the month specified by mo, if
C mo is between 1 and 12, or an empty string otherwise.
C
C******************************************************************************
      subroutine egs_month(mo,month)
      integer mo
      character*(*) month
      integer iaux
      character*3   months(12)
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      iaux = min(len(month),3)
      month(:len(month)) = ' '
      if( mo.ge.1.and.mo.le.12 ) month(:iaux) = months(mo)(:iaux)
      return
      end

C******************************************************************************
C
C Converts a 3-letter abreviation of a month to its corresponding integer
C value, if the string month is a valid month, or -1 otherwise.
C
C******************************************************************************
      integer function egs_conver_month(month)
      character*3 month
      character*3 months(12)
      integer i
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      do i=1,12
        if( month.eq.months(i) ) then
          egs_conver_month = i
          return
        end if
      end do
      egs_conver_month = -1
      return
      end


C##############################################################################
C
C  EGSnrc egs_etime subroutine
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_etime(): returns CPU time consumed since the start of
C                            the program
C
C*****************************************************************************

      real function egs_etime()
      real tarray(2),etime
      egs_etime = etime(tarray)
      return
      end

C##############################################################################
C
C  EGSnrc canonical system name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the canonical system name as determined by the config.guess script
C or the Windows installation program to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_canonical_system(ounit)
      integer ounit
      write(6,'(a,$)') 'x86_64-unknown-linux-gnu'
      return
      end

C******************************************************************************
C
C Assign the canonical system name as determined by the config.guess script
C or the Windows installation program to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_canonical_system(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('x86_64-unknown-linux-gnu')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'x86_64-unknown-linux-gnu'
      else
        res(:l2) = 'x86_64-unknown-linux-gnu'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc configuration name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the configuration name as specified suring the configuration
C process to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_configuration_name(ounit)
      integer ounit
      write(6,'(a,$)') 'linux'
      return
      end

C******************************************************************************
C
C Assign the configuration name as specified suring the configuration
C process to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_configuration_name(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('linux')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'linux'
      else
        res(:l2) = 'linux'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc hostname subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C Print the host name to the unit specified by ounit without inserting
C a new line character.
C
C*****************************************************************************

      subroutine egs_print_hostnm(ounit)
      integer ounit
      character*256 string
      integer res,hostnm,lnblnk1
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      write(ounit,'(a,$)') string(:lnblnk1(string))
      return
      end

C*****************************************************************************
C
C Assign the host name to the string pointed to be hname.
C
C*****************************************************************************

      subroutine egs_get_hostnm(hname)
      character*(*) hname
      character*256 string
      integer res,hostnm,lnblnk1,l1,l2,l
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      l1 = lnblnk1(string)
      l2 = len(hname)
      hname(:l2) = ' '
      l = min(l1,l2)
      hname(:l) = string(:l)
      return
      end

      subroutine egs_init
      implicit none
      common/my_times/ t_elapsed, t_cpu, t_first
      real*8 t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      real*8 dum
      call egs_set_defaults
      call egs_check_arguments
      call egs_init1
      return
      end
      subroutine egs_init1
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      common/my_times/ t_elapsed, t_cpu, t_first
      real*8 t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      integer l, lnblnk1, l1, l2
      integer i
      character arg*256,tmp_string*512, tmp1_string*512, ucode_dir*512,
     *line*80, line1*80,dattim*24
      logical have_input,egs_isdir,egs_strip_extension,ex, on_egs_home,i
     *s_opened
      integer*4 mypid
      integer getpid
      integer istat, egs_system, u, pos1, pos2,egs_get_unit,itmp
      real*8 dum
      t_elapsed = 0
      t_cpu = egs_etime()
      dum = egs_tot_time(1)
      call egs_date_and_time(t_first)
      DO 8481 i=1,len(line)
        line(i:i) = '='
8481  CONTINUE
8482  CONTINUE
      DO 8491 i=1,len(line1)
        line1(i:i) = '.'
8491  CONTINUE
8492  CONTINUE
      IF ((.NOT.is_pegsless)) THEN
        on_egs_home = .false.
        inquire(file=pegs_file,exist=ex)
        IF (( ex )) THEN
          kmpi=egs_get_unit(kmpi)
          IF ((kmpi.LT.0)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'failed to get a free Fortran I/O unit for pe
     *gs file'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(kmpi,file=pegs_file,status='old',err=8500)
          goto 8510
        END IF
        arg = pegs_file(:lnblnk1(pegs_file))
        ex = egs_strip_extension(arg,'.pegs4dat')
        l = lnblnk1(egs_home)
        l1 = lnblnk1('pegs4data') + 2*lnblnk1('/')
        l2 = lnblnk1(arg) + lnblnk1('.pegs4dat')
        IF (( l + l1 + l2 .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'pegs4 data file name (including absolute path)
     *'
          write(i_log,'(a,i4,a)') 'is too long (',l+l1+l2,') characters'
        ELSE
          pegs_file = egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/' //
     *    'data' // '/' // arg(:lnblnk1(arg)) // '.pegs4dat'
          inquire(file=pegs_file,exist=ex)
          IF (( ex )) THEN
            kmpi=egs_get_unit(kmpi)
            IF ((kmpi.LT.0)) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'failed to get a free Fortran I/O unit for
     *pegs file'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            open(kmpi,file=pegs_file,status='old',err=8500)
            on_egs_home = .true.
            goto 8510
          END IF
        END IF
        l = lnblnk1(hen_house)
        IF (( l + l1 + l2 .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'pegs4 data file name (including absolute path)
     *'
          write(i_log,'(a,i4,a)') 'is too long (',l+l1+l2,') characters'
        ELSE
          pegs_file = hen_house(:lnblnk1(hen_house)) // 'pegs4' // '/' /
     *    / 'data' // '/' // arg(:lnblnk1(arg)) // '.pegs4dat'
          inquire(file=pegs_file,exist=ex)
          IF (( ex )) THEN
            kmpi=egs_get_unit(kmpi)
            IF ((kmpi.LT.0)) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'failed to get a free Fortran I/O unit for
     *pegs file'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            open(kmpi,file=pegs_file,status='old',err=8500)
            goto 8510
          END IF
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'could not find pegs4 file named ',arg(:lnblnk1(a
     *  rg))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
8510  CONTINUE
      DO 8521 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
8521  CONTINUE
8522  CONTINUE
      tmp_string = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      i_nist_data=76
      i_incoh=78
      i_photo_relax=77
      i_photo_cs=79
      i_mscat=11
      DO 8531 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
8531  CONTINUE
8532  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'photo_cs.data'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','photo_cs.data',' does not ex
     *ist'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_photo_cs=egs_get_unit(i_photo_cs)
        IF ((i_photo_cs.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_photo_cs,file=tmp1_string,status='old',err=8540)
      ELSE
        i_photo_cs = itmp
      END IF
      DO 8551 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
8551  CONTINUE
8552  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'msnew.data'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','msnew.data',' does not exist
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_mscat=egs_get_unit(i_mscat)
        IF ((i_mscat.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_mscat,file=tmp1_string,status='old',err=8540)
      ELSE
        i_mscat = itmp
      END IF
      DO 8561 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
8561  CONTINUE
8562  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'incoh.data'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','incoh.data',' does not exist
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_incoh=egs_get_unit(i_incoh)
        IF ((i_incoh.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_incoh,file=tmp1_string,status='old',err=8540)
      ELSE
        i_incoh = itmp
      END IF
      DO 8571 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
8571  CONTINUE
8572  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'photo_relax.dat
     *a'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','photo_relax.data',' does not
     * exist'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_photo_relax=egs_get_unit(i_photo_relax)
        IF ((i_photo_relax.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_photo_relax,file=tmp1_string,status='old',err=8540)
      ELSE
        i_photo_relax = itmp
      END IF
      DO 8581 i=1,len(ucode_dir)
        ucode_dir(i:i) = ' '
8581  CONTINUE
8582  CONTINUE
      ucode_dir = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(use
     *r_code)) // '/'
      have_input = .false.
      i_input=5
      IF (( lnblnk1(input_file) .GT. 0 )) THEN
        have_input = .true.
        l = lnblnk1(egs_home)
        l1 = lnblnk1(user_code)+1
        l2 = lnblnk1(input_file) + lnblnk1('.egsinp')
        IF (( l + l1 + l2 .GT. 1024 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'input file name (including path) is too long '
     *    ,l+l1+l2
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        ex = egs_strip_extension(input_file,'.egsinp')
        tmp_string = ucode_dir(:lnblnk1(ucode_dir)) // input_file(:lnbln
     *  k1(input_file)) // '.egsinp'
        inquire(file=tmp_string,exist=ex)
        IF (( .NOT.ex )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'Input file ',tmp_string(:lnblnk1(tmp_string)),
     *    ' does not exist.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_input,file=tmp_string,status='old',err=8590)
      END IF
      DO 8601 i=1,len(work_dir)
        work_dir(i:i) = ' '
8601  CONTINUE
8602  CONTINUE
      work_dir = 'egsrun_'
      mypid = getpid()
      call egs_itostring(work_dir,mypid,.false.)
      call egs_get_hostnm(host_name)
      IF((lnblnk1(host_name) .LT. 1))host_name = 'unknown'
      IF (( have_input )) THEN
        work_dir = work_dir(:lnblnk1(work_dir)) // '_' // input_file(:ln
     *  blnk1(input_file)) // '_' // host_name(:lnblnk1(host_name)) // '
     */'
      ELSE
        work_dir = work_dir(:lnblnk1(work_dir)) // '_noinput_' // host_n
     *  ame(:lnblnk1(host_name)) // '/'
      END IF
      DO 8611 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
8611  CONTINUE
8612  CONTINUE
      tmp_string = ucode_dir(:lnblnk1(ucode_dir)) // work_dir(:lnblnk1(w
     *ork_dir))
      DO 8621 i=1,lnblnk1(tmp_string)
        IF (( tmp_string(i:i) .EQ. '/' )) THEN
          tmp_string(i:i) = '/'
        END IF
8621  CONTINUE
8622  CONTINUE
      ex = egs_isdir(tmp_string)
      IF (( ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'a directory named ',tmp_string(:lnblnk1(tmp_stri
     *  ng)),' already exists?'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp1_string = 'mkdir ' // tmp_string(:lnblnk1(tmp_string))
      l = lnblnk1(tmp1_string)
      tmp1_string(l+1:l+1) = char(0)
      istat = egs_system(tmp1_string)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'failed to create working directory ',tmp1_string
     *  (:lnblnk1(tmp1_string))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      call egs_open_units(.true.)
      write(6,'(a)') line
      write(1,'(a)') line
      write(6,'(a,a,t55,a,$)') 'EGSnrc version 4 for ','x86_64-unknown-l
     *inux-gnu',' '
      write(1,'(a,a,t55,a,$)') 'EGSnrc version 4 for ','x86_64-unknown-l
     *inux-gnu',' '
      call egs_get_fdate(dattim)
      write(6,'(a,/,a)') dattim,line
      write(1,'(a,/,a)') dattim,line
      pos1 = lnblnk1('output file(s)')
      pos2 = 80 - lnblnk1('linux')
      pos2 = min(pos2,80-lnblnk1(user_code))
      DO 8631 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
8631  CONTINUE
8632  CONTINUE
      tmp_string = pegs_file
      call egs_strip_path(tmp_string)
      ex = egs_strip_extension(tmp_string,'.pegs4dat')
      IF (( on_egs_home )) THEN
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // ' on EGS_HOME'
      ELSE
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // ' on HEN_HOUSE'
      END IF
      IF (( lnblnk1(tmp_string) .GT. lnblnk1(pegs_file) )) THEN
        DO 8641 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
8641    CONTINUE
8642    CONTINUE
        tmp_string = pegs_file
      END IF
      pos2 = min(pos2,80-lnblnk1(tmp_string))
      pos2 = min(pos2,80-lnblnk1(host_name))
      IF((have_input))pos2 = min(pos2,80-lnblnk1(input_file))
      pos2 = min(pos2,80-lnblnk1(output_file))
      IF((pos2 .LT. pos1+2))pos2 = pos1 + 2
      write(6,'(a,$)') 'configuration'
      write(1,'(a,$)') 'configuration'
      l = pos2 - lnblnk1('configuration')
      write(6,'(a,$)') line1(:l)
      write(1,'(a,$)') line1(:l)
      write(6,'(a)') 'linux'
      write(1,'(a)') 'linux'
      write(6,'(a,$)') 'user code'
      write(1,'(a,$)') 'user code'
      l = pos2 - lnblnk1('user code')
      write(6,'(a,$)') line1(:l)
      write(1,'(a,$)') line1(:l)
      write(6,'(a)') user_code(:lnblnk1(user_code))
      write(1,'(a)') user_code(:lnblnk1(user_code))
      write(6,'(a,$)') 'pegs file'
      write(1,'(a,$)') 'pegs file'
      l = pos2 - lnblnk1('pegs file')
      write(6,'(a,$)') line1(:l)
      write(1,'(a,$)') line1(:l)
      write(6,'(a)') tmp_string(:lnblnk1(tmp_string))
      write(1,'(a)') tmp_string(:lnblnk1(tmp_string))
      write(6,'(a,$)') 'using host'
      write(1,'(a,$)') 'using host'
      l = pos2 - lnblnk1('using host')
      write(6,'(a,$)') line1(:l)
      write(1,'(a,$)') line1(:l)
      write(6,'(a)') host_name(:lnblnk1(host_name))
      write(1,'(a)') host_name(:lnblnk1(host_name))
      IF (( have_input )) THEN
        write(6,'(a,$)') 'input file'
        write(1,'(a,$)') 'input file'
        l = pos2 - lnblnk1('input file')
        write(6,'(a,$)') line1(:l)
        write(1,'(a,$)') line1(:l)
        write(6,'(a)') input_file(:lnblnk1(input_file))
        write(1,'(a)') input_file(:lnblnk1(input_file))
      END IF
      write(6,'(a,$)') 'output file(s)'
      write(1,'(a,$)') 'output file(s)'
      l = pos2 - lnblnk1('output file(s)')
      write(6,'(a,$)') line1(:l)
      write(1,'(a,$)') line1(:l)
      write(6,'(a)') output_file(:lnblnk1(output_file))
      write(1,'(a)') output_file(:lnblnk1(output_file))
      IF (( n_parallel .GT. 0 )) THEN
        write(6,'(a,$)') 'number of parallel jobs'
        write(1,'(a,$)') 'number of parallel jobs'
        l = pos2 - lnblnk1('number of parallel jobs')
        write(6,'(a,$)') line1(:l)
        write(1,'(a,$)') line1(:l)
        write(6,'(i2)') n_parallel
        write(1,'(i2)') n_parallel
        write(6,'(a,$)') 'job number'
        write(1,'(a,$)') 'job number'
        l = pos2 - lnblnk1('job number')
        write(6,'(a,$)') line1(:l)
        write(1,'(a,$)') line1(:l)
        write(6,'(i2)') i_parallel
        write(1,'(i2)') i_parallel
      END IF
      write(6,'(a)') line
      write(1,'(a)') line
      return
8590  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open input file ',tmp_string(:lnblnk1(tm
     *p_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
8500  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open existing pegs file ',pegs_file(:lnb
     *lnk1(pegs_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
8540  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open EGSnrc data file ',tmp1_string(:lnb
     *lnk1(tmp1_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_check_arguments
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character arg*256,tmp_string*512, line1*80
      logical have_arg,egs_isdir,egs_strip_extension,ex, on_egs_home
      integer narg, iargc, i, lnblnk1, l, l2,i_help,egs_get_unit
      narg = iargc()
      IF((narg .LT. 1))return
      have_arg = .false.
      DO 8651 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-H') .AND. arg(:l) .EQ. '-H' ) .OR. ( l
     *  .EQ. lnblnk1('--hen-house') .AND. arg(:l) .EQ. '--hen-house' ) )
     *  ) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO8652
        END IF
8651  CONTINUE
8652  CONTINUE
      IF (( have_arg )) THEN
        l = lnblnk1(arg)
        DO 8661 i=1,len(hen_house)
          hen_house(i:i) = ' '
8661    CONTINUE
8662    CONTINUE
        IF (( l .GT. 0 )) THEN
          IF (( l .GT. 254 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a,i5)') ' HEN_HOUSE argument is too long',l
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          hen_house(:l) = arg(:lnblnk1(arg))
          IF((hen_house(l:l) .NE. '/'))hen_house(l+1:l+1) = '/'
        ELSE
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a)') ' empty argument after -H'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        DO 8671 i=1,lnblnk1(hen_house)
          IF (( hen_house(i:i) .EQ. '/' )) THEN
            hen_house(i:i) = '/'
          END IF
8671    CONTINUE
8672    CONTINUE
      END IF
      IF (( .NOT.egs_isdir(hen_house) )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,'(a,a)') ' HEN_HOUSE directory ',hen_house(:lnblnk1(
     *  hen_house))
        write(i_log,'(a)') 'does not exist. Hope you know what you are d
     *oing.'
      END IF
      have_arg = .false.
      DO 8681 i=1,narg
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-h') .AND. arg(:l) .EQ. '-h' ) .OR. ( l
     *  .EQ. lnblnk1('--help') .AND. arg(:l) .EQ. '--help' ) )) THEN
          have_arg = .true.
          GO TO8682
        END IF
8681  CONTINUE
8682  CONTINUE
      IF (( have_arg )) THEN
        call getarg(0,arg)
        call egs_strip_path(arg)
        write(6,'(//,a,a,a,//)') 'Usage: ',arg(:lnblnk1(arg)),' [args] '
        write(1,'(//,a,a,a,//)') 'Usage: ',arg(:lnblnk1(arg)),' [args] '
        tmp_string = hen_house(:lnblnk1(hen_house)) // 'pieces/help_mess
     *age'
        i_help=98
        i_help=egs_get_unit(i_help)
        IF ((i_help.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for help
     * file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_help,file=tmp_string,status='old',err=8690)
8701    CONTINUE
          read(i_help,'(a)',err=8710,end=8710) line1
          write(6,'(a)') line1
          write(1,'(a)') line1
        GO TO 8701
8702    CONTINUE
8710    CONTINUE
        call exit(0)
8690    CONTINUE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Did not find the help_message file!'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      have_arg = .false.
      DO 8721 i=1,narg
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-b') .AND. arg(:l) .EQ. '-b' ) .OR. ( l
     *  .EQ. lnblnk1('--batch') .AND. arg(:l) .EQ. '--batch' ) )) THEN
          have_arg = .true.
          GO TO8722
        END IF
8721  CONTINUE
8722  CONTINUE
      IF((have_arg))is_batch = .true.
      have_arg = .false.
      DO 8731 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-P') .AND. arg(:l) .EQ. '-P' ) .OR. ( l
     *  .EQ. lnblnk1('--parallel') .AND. arg(:l) .EQ. '--parallel' ) ))
     *  THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO8732
        END IF
8731  CONTINUE
8732  CONTINUE
      IF (( have_arg )) THEN
        read(arg,*,err=8740) n_parallel
        IF((n_parallel .LT. 0))goto 8740
        goto 8750
8740    CONTINUE
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Wrong/missing parallel job number argument, -P
     *option ignored'
        n_parallel = 0
8750    CONTINUE
      END IF
      have_arg = .false.
      DO 8761 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-j') .AND. arg(:l) .EQ. '-j' ) .OR. ( l
     *  .EQ. lnblnk1('--job') .AND. arg(:l) .EQ. '--job' ) )) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO8762
        END IF
8761  CONTINUE
8762  CONTINUE
      IF (( have_arg )) THEN
        read(arg,*,err=8770) i_parallel
        IF((i_parallel .LT. 0))goto 8770
        goto 8780
8770    CONTINUE
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Wrong/missing job argument, -j option ognored'
        i_parallel = 0
8780    CONTINUE
      END IF
      have_arg = .false.
      DO 8791 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-f') .AND. arg(:l) .EQ. '-f' ) .OR. ( l
     *  .EQ. lnblnk1('--first-job') .AND. arg(:l) .EQ. '--first-job' ) )
     *  ) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO8792
        END IF
8791  CONTINUE
8792  CONTINUE
      IF (( have_arg )) THEN
        read(arg,*,err=8800) first_parallel
        IF((first_parallel .LT. 1))goto 8800
        goto 8810
8800    CONTINUE
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Wrong/missing first job argument, -f option ogn
     *ored'
        first_parallel = 1
8810    CONTINUE
      END IF
      IF (( n_parallel .GT. 0 .OR. i_parallel .GT. 0 )) THEN
        IF (( n_parallel*i_parallel .EQ. 0 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'You need to specify number of jobs AND job num
     *ber ', '=> will not use parallel run '
          n_parallel = 0
          i_parallel = 0
        END IF
        IF (( first_parallel .GT. i_parallel )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'i_parallel (',i_parallel, ') can not be smalle
     *r than first_parallel (',first_parallel,')'
          first_parallel = i_parallel
        END IF
      END IF
      have_arg = .false.
      DO 8821 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-e') .AND. arg(:l) .EQ. '-e' ) .OR. ( l
     *  .EQ. lnblnk1('--egs-home') .AND. arg(:l) .EQ. '--egs-home' ) ))
     *  THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO8822
        END IF
8821  CONTINUE
8822  CONTINUE
      IF (( have_arg )) THEN
        l = lnblnk1(arg)
        DO 8831 i=1,len(egs_home)
          egs_home(i:i) = ' '
8831    CONTINUE
8832    CONTINUE
        IF (( l .EQ. 0 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a)') ' empty argument after -e'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF (( l .GT. 254 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,i5)') ' EGS_HOME argument is too long ',l
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        egs_home(:l) = arg(:lnblnk1(arg))
        IF((egs_home(l:l) .NE. '/'))egs_home(l+1:l+1) = '/'
        DO 8841 i=1,lnblnk1(egs_home)
          IF (( egs_home(i:i) .EQ. '/' )) THEN
            egs_home(i:i) = '/'
          END IF
8841    CONTINUE
8842    CONTINUE
      END IF
      IF (( .NOT.egs_isdir(egs_home) )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' EGS_HOME directory ',egs_home(:lnblnk1(egs_home
     *  )),' does not exist.'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      on_egs_home = .false.
      is_pegsless=.false.
      have_arg = .false.
      DO 8851 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-p') .AND. arg(:l) .EQ. '-p' ) .OR. ( l
     *  .EQ. lnblnk1('--pegs-file') .AND. arg(:l) .EQ. '--pegs-file' ) )
     *  ) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO8852
        END IF
8851  CONTINUE
8852  CONTINUE
      IF (( .NOT.have_arg )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) 'No pegs4 file name supplied.  Will assume you ar
     *e running    in pegs-less mode with media details specified in inp
     *ut file.'
        is_pegsless=.true.
      ELSE
        pegs_file = arg(:lnblnk1(arg))
      END IF
      call egs_get_usercode(user_code)
      have_arg = .false.
      DO 8861 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-i') .AND. arg(:l) .EQ. '-i' ) .OR. ( l
     *  .EQ. lnblnk1('--input') .AND. arg(:l) .EQ. '--input' ) )) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO8862
        END IF
8861  CONTINUE
8862  CONTINUE
      IF (( have_arg )) THEN
        ex = egs_strip_extension(arg,'.egsinp')
        l2 = lnblnk1(arg) + lnblnk1('.egsinp')
        IF (( l2 .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'input file name is too long ',l2
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        input_file = arg(:lnblnk1(arg))
      END IF
      have_arg = .false.
      DO 8871 i=1,narg-1
        call getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-o') .AND. arg(:l) .EQ. '-o' ) .OR. ( l
     *  .EQ. lnblnk1('--output') .AND. arg(:l) .EQ. '--output' ) )) THEN
          have_arg = .true.
          call getarg(i+1,arg)
          GO TO8872
        END IF
8871  CONTINUE
8872  CONTINUE
      IF (( have_arg )) THEN
        l = lnblnk1(arg)
        IF (( l .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'output file name is too long ',l
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        output_file(:l) = arg(:lnblnk1(arg))
      ELSE
        IF (( lnblnk1(input_file) .GT. 0 )) THEN
          output_file(:lnblnk1(input_file)) = input_file(:lnblnk1(input_
     *    file))
        ELSE
          output_file = 'test'
        END IF
      END IF
      return
      end
      subroutine egs_open_units(flag)
      implicit none
      logical flag
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character tmp_string*1024, tmp1_string*1024, tmp2_string*1024, uco
     *de_dir*1024, input_line*100, arg*20
      integer i,lnblnk1,u,l,istart,egs_get_unit,i_iofile
      logical ex,is_open
      DO 8881 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
8881  CONTINUE
8882  CONTINUE
      DO 8891 i=1,len(ucode_dir)
        ucode_dir(i:i) = ' '
8891  CONTINUE
8892  CONTINUE
      ucode_dir = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(use
     *r_code)) // '/'
      IF (( flag )) THEN
        tmp_string = ucode_dir(:lnblnk1(ucode_dir)) // work_dir(:lnblnk1
     *  (work_dir))
      ELSE
        tmp_string = ucode_dir(:lnblnk1(ucode_dir))
      END IF
      tmp_string = tmp_string(:lnblnk1(tmp_string)) // output_file(:lnbl
     *nk1(output_file))
      IF (( i_parallel .GT. 0 )) THEN
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // '_w'
        call egs_itostring(tmp_string,i_parallel,.false.)
      END IF
      DO 8901 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
8901  CONTINUE
8902  CONTINUE
      i_log=6
      IF (( is_batch )) THEN
        tmp1_string = tmp_string(:lnblnk1(tmp_string)) // '.egslog'
        open(i_log,file=tmp1_string,status='unknown',err=8910)
      END IF
      DO 8921 i=1,len(tmp2_string)
        tmp2_string(i:i) = ' '
8921  CONTINUE
8922  CONTINUE
      tmp2_string = ucode_dir(:lnblnk1(ucode_dir)) // user_code(:lnblnk1
     *(user_code)) // '.io'
      inquire(file=tmp2_string,exist=ex)
      n_files = 0
      IF (( ex )) THEN
        i_iofile=99
        i_iofile=egs_get_unit(i_iofile)
        IF ((i_iofile.LT.1)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for .io
     *file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_iofile,file=tmp2_string,status='old',err=8930)
8941    CONTINUE
          read(i_iofile,'(a)',err=8950,end=8950) input_line
          IF((input_line(1:1) .EQ. '#'))GO TO8941
          read(input_line,*,err=8960,end=8960) u
          istart = 1
          DO 8971 i=lnblnk1(input_line),1,-1
            IF (( input_line(i:i) .EQ. ' ' )) THEN
              istart = i+1
              GO TO8972
            END IF
8971      CONTINUE
8972      CONTINUE
          DO 8981 i=1,len(arg)
            arg(i:i) = ' '
8981      CONTINUE
8982      CONTINUE
          DO 8991 i=istart,lnblnk1(input_line)
            arg(i+1-istart:i+1-istart) = input_line(i:i)
8991      CONTINUE
8992      CONTINUE
          inquire(unit=u,opened=is_open)
          IF (( is_open )) THEN
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,'(a,i3,a,a,a,/,a,/,a,/)') 'Unit ',u,' which you
     *want to connect to a ', arg(:lnblnk1(arg)),' file ', 'is already i
     *n use. Will assume this code is being used as', 'a shared library
     *source and this file will be opened explicitly.'
          ELSE
            n_files = n_files + 1
            IF (( n_files .GT. 20 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'Too many units requested in .io.', ' Incre
     *as $mx_units and retry'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            file_units(n_files) = u
            DO 9001 i=1,len(file_extensions(n_files))
              file_extensions(n_files)(i:i) = ' '
9001        CONTINUE
9002        CONTINUE
            l = lnblnk1(arg)
            IF (( l .GT. 10 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'extension ',arg(:lnblnk1(arg)),' is longer
     * than ', 10,' chars. ', 'Increase $max_extension_length and retry
     *'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            file_extensions(n_files) = arg(:lnblnk1(arg))
            tmp1_string = tmp_string(:lnblnk1(tmp_string)) // arg(:lnbln
     *      k1(arg))
            open(u,file=tmp1_string,status='unknown')
          END IF
8960      CONTINUE
        GO TO 8941
8942    CONTINUE
8950    close(i_iofile)
      END IF
      return
8910  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open output file ',tmp1_string(:lnblnk1(
     *tmp1_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
8930  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open existing .io file',tmp2_string(:lnb
     *lnk1(tmp2_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_finish
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/my_times/ t_elapsed, t_cpu, t_first
      real*8 t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      character line*80,base*512,base1*512,tmp_string*512,junk_file*128,
     *fname*512
      character dattim*24
      integer i,l,lnblnk1,istat,egs_system,n_open,unlink,i_junk,egs_get_
     *unit
      logical is_open,egs_isdir
      real*8 t1,t2,tt_cpu
      DO 9011 i=1,len(line)
        line(i:i) = '='
9011  CONTINUE
9012  CONTINUE
      IF (( n_parallel .EQ. 0 .OR. i_parallel .GT. 0 )) THEN
        t_elapsed = egs_tot_time(1)
        tt_cpu = egs_etime() - t_cpu
        t1 = t_elapsed
        t2 = t1/3600
        write(6,'(//a,/,a,/)') line,'Finished simulation'
        write(1,'(//a,/,a,/)') line,'Finished simulation'
        write(6,'(2x,a,t30,f9.1,a,f7.3,a)') 'Elapsed time: ',t1,' s (',t
     *  2,' h)'
        write(1,'(2x,a,t30,f9.1,a,f7.3,a)') 'Elapsed time: ',t1,' s (',t
     *  2,' h)'
        t1 = tt_cpu
        t2 = t1/3600
        write(6,'(2x,a,t30,f9.1,a,f7.3,a)') 'CPU time:',t1,' s (',t2,' h
     *)'
        write(1,'(2x,a,t30,f9.1,a,f7.3,a)') 'CPU time:',t1,' s (',t2,' h
     *)'
        write(6,'(2x,a,t30,f10.3)') 'Ratio:',t_elapsed/tt_cpu
        write(1,'(2x,a,t30,f10.3)') 'Ratio:',t_elapsed/tt_cpu
      END IF
      call egs_get_fdate(dattim)
      write(6,'(//a,t56,a,/,a)') 'End of run ',dattim,line
      write(1,'(//a,t56,a,/,a)') 'End of run ',dattim,line
      n_open=0
      DO 9021 i=1,len(base)
        base(i:i) = ' '
9021  CONTINUE
9022  CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e))
      DO 9031 i=1,99
        IF (( is_batch .OR. i .NE. i_log )) THEN
          inquire(i,opened=is_open)
          IF (( is_open )) THEN
            inquire(i,name=fname)
            IF ((index(fname(:lnblnk1(fname)),base(:lnblnk1(base))).GT.0
     *      )) THEN
              close(i)
              n_open = n_open+1
            END IF
          END IF
        END IF
9031  CONTINUE
9032  CONTINUE
      IF (( lnblnk1(work_dir) .EQ. 0 )) THEN
        return
      END IF
      DO 9041 i=1,len(base)
        base(i:i) = ' '
9041  CONTINUE
9042  CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e)) // '/' // work_dir(:lnblnk1(work_dir))
      DO 9051 i=1,lnblnk1(base)
        IF (( base(i:i) .EQ. '/' )) THEN
          base(i:i) = '/'
        END IF
9051  CONTINUE
9052  CONTINUE
      IF (( egs_isdir(base) )) THEN
        DO 9061 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
9061    CONTINUE
9062    CONTINUE
        DO 9071 i=1,len(junk_file)
          junk_file(i:i) = ' '
9071    CONTINUE
9072    CONTINUE
        junk_file = work_dir(:lnblnk1(work_dir))
        l = lnblnk1(junk_file)
        junk_file(l:l) = ' '
        junk_file = junk_file(:lnblnk1(junk_file)) // '_junk'
        tmp_string = base(:lnblnk1(base)) // junk_file(:lnblnk1(junk_fil
     *  e))
        i_junk=99
        i_junk=egs_get_unit(i_junk)
        IF ((i_junk.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for junk
     * file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_junk,file=tmp_string,status='unknown')
        write(i_junk,*) 'junk'
        close(i_junk)
        DO 9081 i=1,len(base1)
          base1(i:i) = ' '
9081    CONTINUE
9082    CONTINUE
        base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_c
     *  ode)) // '/' // work_dir(:lnblnk1(work_dir))
        base1 = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_
     *  code))
        DO 9091 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
9091    CONTINUE
9092    CONTINUE
        tmp_string = 'mv -f ' // base(:lnblnk1(base)) // '*  ' // base1(
     *  :lnblnk1(base1))
        l = lnblnk1(tmp_string)+1
        tmp_string(l:l) = char(0)
        istat = egs_system(tmp_string)
        IF (( istat .NE. 0 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'Moving files from working directory failed ?'
          write(i_log,*) '=> will not remove working directory'
        ELSE
          DO 9101 i=1,len(tmp_string)
            tmp_string(i:i) = ' '
9101      CONTINUE
9102      CONTINUE
          tmp_string = 'rm -rf ' // base(:lnblnk1(base))
          l = lnblnk1(tmp_string)+1
          tmp_string(l:l) = char(0)
          istat = egs_system(tmp_string)
          IF (( istat .NE. 0 )) THEN
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,*) 'Failed to remove working directory ', work_d
     *      ir(:lnblnk1(work_dir))
          END IF
          DO 9111 i=1,len(tmp_string)
            tmp_string(i:i) = ' '
9111      CONTINUE
9112      CONTINUE
          tmp_string = base1(:lnblnk1(base1)) // '/' // junk_file(:lnbln
     *    k1(junk_file))
          l = lnblnk1(tmp_string)+1
          tmp_string(l:l) = char(0)
          istat = unlink(tmp_string)
        END IF
      END IF
      DO 9121 i=1,len(work_dir)
        work_dir(i:i) = ' '
9121  CONTINUE
9122  CONTINUE
      return
      end
      subroutine egs_set_defaults
      implicit none
      COMMON/BOUNDS/ECUT( 1001),PCUT( 1001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,3), eno_array(200,3), eno_atbin_array(200,3), n_sh
     *ell(3), radc_flag,  ibcmp( 1001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      common/ET_control/ smaxir( 1001),estepe,ximax,  skindepth_for_bca,
     *transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PHOTIN/ EBINDA(3), GE0(3),GE1(3), GMFP0(2000,3),GMFP1(2000,
     *3),GBR10(2000,3),GBR11(2000,3),GBR20(2000,3),GBR21(2000,3), RCO0(3
     *),RCO1(3), RSCT0(100,3),RSCT1(100,3), COHE0(2000,3),COHE1(2000,3),
     *  PHOTONUC0(2000,3),PHOTONUC1(2000,3), DPMFP, MPGEM(1,3), NGR(3)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      real*8 SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/spin_data/ spin_rej(3,0:1,0: 31,0:15,0:31), espin_min,espin
     *_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dleneri,dq
     *q1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(3), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),  e
     *ii_sh(40),  eii_nshells(100),  eii_nsh(3),  eii_first(3,50),  eii_
     *no(3,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      COMMON/rayleigh_inputs/iray_ff_media(3),iray_ff_file(3)
      character*24 iray_ff_media
      character*128 iray_ff_file
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      integer i,j,lnblnk1
      CHARACTER*4 MEDIA1(24)
      EQUIVALENCE(MEDIA1(1),MEDIA(1,1))
      character fool_dec
      data MEDIA1/'N','A','I',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','
     *',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '/
      data fool_dec/'/'/
      data fool_intel_optimizer/.false./
      vacdst = 1e8
      DO 9131 i=1, 1001
        ecut(i) = 0.
        pcut(i) = 0.
        ibcmp(i) = 3
        iedgfl(i) = 1
        iphter(i) = 1
        smaxir(i) = 1e10
        i_do_rr(i) = 0
        e_max_rr(i) = 0
        med(i) = 1
        rhor(i) = 0
        iraylr(i) = 1
        iphotonucr(i) = 0
9131  CONTINUE
9132  CONTINUE
      eii_flag = 0
      eii_xfile = 'Off'
      eii_L_factor = 1.0
      xsec_out = 0
      photon_xsections = 'xcom'
      comp_xsections = 'default'
      eadl_relax = .true.
      mcdf_pe_xsections = .false.
      photonuc_xsections = 'default'
      ExIN=0
      EyIN=0
      EzIN=0
      BxIN=0
      ByIN=0
      BzIN=0
      EMLMTIN=0.02
      Bx=BxIN
      By=ByIN
      Bz=BzIN
      Bx_new=Bx
      By_new=By
      Bz_new=Bz
      emfield_on=.false.
      IF (( ExIN**2+EyIN**2+EzIN**2 + BxIN**2+ByIN**2+BzIN**2 .GT. 0 ))
     *THEN
        emfield_on=.true.
      END IF
      DO 9141 i=1,3
        iraylm(i) = 0
        DO 9151 j=1,len(iray_ff_file(i))
          iray_ff_file(i)(j:j) = ' '
9151    CONTINUE
9152    CONTINUE
        DO 9161 j=1,len(iray_ff_media(i))
          iray_ff_media(i)(j:j) = ' '
9161    CONTINUE
9162    CONTINUE
        ae(i)=0
        ap(i)=0
        ue(i)=0
        up(i)=0
        te(i)=0
        thmoll(i)=0
9141  CONTINUE
9142  CONTINUE
      DO 9171 i=1,30
        DO 9181 j=1,100
          binding_energies(i,j) = 0
9181    CONTINUE
9182    CONTINUE
9171  CONTINUE
9172  CONTINUE
      ibrdst = 1
      ibr_nist = 0
      pair_nrc = 0
      itriplet = 0
      iprdst = 1
      rhof = 1
      DO 9191 i=1,5
        iausfl(i) = 1
9191  CONTINUE
9192  CONTINUE
      DO 9201 i=6,35
        iausfl(i) = 0
9201  CONTINUE
9202  CONTINUE
      ximax = 0.5
      estepe = 0.25
      skindepth_for_bca = 3
      transport_algorithm = 0
      bca_algorithm = 0
      exact_bca = .true.
      spin_effects = .true.
      count_pII_steps = 0
      count_all_steps = 0
      radc_flag = 0
      nmed = 1
      kmpi = 12
      kmpo = 8
      dunit = 1
      rng_seed = 999999
      latchi = 0
      rmt2 = 2*rm
      rmsq = rm*rm
      pi = 4*datan(1d0)
      twopi = 2*pi
      pi5d2 = 2.5*pi
      nbr_split = 1
      i_play_RR = 0
      i_survived_RR = 0
      prob_RR = -1
      n_RR_warning = 0
      DO 9211 i=1,len(hen_house)
        hen_house(i:i) = ' '
9211  CONTINUE
9212  CONTINUE
      i = lnblnk1('/home/miia/EGSnrc/HEN_HOUSE/')
      hen_house(:i) = '/home/miia/EGSnrc/HEN_HOUSE/'
      IF (( '/' .NE. fool_dec )) THEN
        DO 9221 j=1,i
          IF((hen_house(j:j) .EQ. '/'))hen_house(j:j) = '/'
9221    CONTINUE
9222    CONTINUE
      END IF
      IF((hen_house(i:i) .NE. '/'))hen_house(i+1:i+1) = '/'
      n_files = 0
      DO 9231 i=1,len(egs_home)
        egs_home(i:i) = ' '
9231  CONTINUE
9232  CONTINUE
      call getenv('EGS_HOME',egs_home)
      i = lnblnk1(egs_home)
      IF (( '/' .NE. fool_dec )) THEN
        DO 9241 j=1,i
          IF((egs_home(j:j) .EQ. '/'))egs_home(j:j) = '/'
9241    CONTINUE
9242    CONTINUE
      END IF
      IF((i .GT. 0 .AND. egs_home(i:i) .NE. '/'))egs_home(i+1:i+1) = '/'
      DO 9251 i=1,len(input_file)
        input_file(i:i) = ' '
9251  CONTINUE
9252  CONTINUE
      DO 9261 i=1,len(output_file)
        output_file(i:i) = ' '
9261  CONTINUE
9262  CONTINUE
      DO 9271 i=1,len(work_dir)
        work_dir(i:i) = ' '
9271  CONTINUE
9272  CONTINUE
      DO 9281 i=1,len(pegs_file)
        pegs_file(i:i) = ' '
9281  CONTINUE
9282  CONTINUE
      DO 9291 i=1,len(host_name)
        host_name(i:i) = ' '
9291  CONTINUE
9292  CONTINUE
      n_parallel = 0
      i_parallel = 0
      n_chunk = 0
      is_batch = .false.
      first_parallel = 1
      return
      end
      subroutine egs_combine_runs(combine_routine,extension)
      implicit none
      external combine_routine
      character*(*) extension
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*1024 tmp_string,base,command,outfile,parfile_name,base1,
     * text_string
      integer lnblnk1,istat,ipar,egs_system,egs_open_file
      integer*4 i,k,j,numparfiles,textindex
      logical ex,iwin
      iwin=.false.
      DO 9301 i=1,len(base)
        base(i:i) = ' '
9301  CONTINUE
9302  CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e)) // '/' // output_file(:lnblnk1(output_file)) // '_w'
      DO 9311 i=1,len(base1)
        base1(i:i) = ' '
9311  CONTINUE
9312  CONTINUE
      base1 = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_co
     *de)) // '/' // output_file(:lnblnk1(output_file)) // '_w*' // exte
     *nsion(:lnblnk1(extension))
      DO 9321 i=1,len(outfile)
        outfile(i:i) = ' '
9321  CONTINUE
9322  CONTINUE
      outfile = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_
     *code)) // '/' // 'parfiles_tmp'
      DO 9331 i=1,len(command)
        command(i:i) = ' '
9331  CONTINUE
9332  CONTINUE
      command = 'ls ' // base1(:lnblnk1(base1)) // ' | wc -l > ' // outf
     *ile(:lnblnk1(outfile))
      istat = egs_system(command(:lnblnk1(command)))
      IF ((istat.NE.0)) THEN
        command = 'dir ' // base1(:lnblnk1(base1)) // ' | find "File(s)"
     * > ' // outfile(:lnblnk1(outfile))
        istat = egs_system(command(:lnblnk1(command)))
        IF ((istat.NE.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) ' Failed to write number of output files from p
     *arallel runs.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        ELSE
          iwin=.true.
        END IF
      END IF
      ipar=1
      ipar=egs_open_file(ipar,0,1,outfile(:lnblnk1(outfile)))
      IF ((iwin)) THEN
        read(ipar,'(a)',err=9340,end=9340) text_string
        text_string = text_string(:lnblnk1(text_string))
        textindex = index(text_string,'File(s)')
        text_string = text_string(:textindex-1)
        read(text_string,'(i256)',err=9340) numparfiles
      ELSE
        read(ipar,'(i256)',err=9340,end=9340) numparfiles
      END IF
      close(ipar)
      DO 9351 i=1,len(command)
        command(i:i) = ' '
9351  CONTINUE
9352  CONTINUE
      IF ((iwin)) THEN
        command = 'del /Q ' // outfile(:lnblnk1(outfile))
      ELSE
        command = 'rm -f ' // outfile(:lnblnk1(outfile))
      END IF
      istat = egs_system(command(:lnblnk1(command)))
      IF ((istat.NE.0)) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Failed to delete list of output files from para
     *llel runs.'
      END IF
      k=1
      j=1
9361  IF(j.GT.numparfiles)GO TO 9362
        DO 9371 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
9371    CONTINUE
9372    CONTINUE
        tmp_string = base(:lnblnk1(base))
        call egs_itostring(tmp_string,k,.false.)
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // extension(:lnbl
     *  nk1(extension))
        inquire(file=tmp_string,exist=ex)
        IF (( ex )) THEN
          call combine_routine(tmp_string)
          j=j+1
        END IF
        k=k+1
      GO TO 9361
9362  CONTINUE
      return
9340  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' Failed to read number of output files from parall
     *el runs.'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      logical function egs_strip_extension(filen,fext)
      implicit none
      character*(*) filen,fext
      integer l1,l2,lnblnk1,i
      l1 = lnblnk1(filen)
      l2 = lnblnk1(fext)
      IF (( l1 .GE. l2 .AND. filen(l1-l2+1:l1) .EQ. fext(:l2) )) THEN
        egs_strip_extension = .true.
        DO 9381 i=l1-l2+1,len(filen)
          filen(i:i) = ' '
9381    CONTINUE
9382    CONTINUE
      ELSE
        egs_strip_extension = .false.
      END IF
      return
      end
      logical function egs_is_absolute_path(fn)
      implicit none
      character*(*) fn
      integer i,lnblnk1
      DO 9391 i=1,lnblnk1(fn)
        IF (( fn(i:i) .EQ. '/' )) THEN
          egs_is_absolute_path = .true.
          return
        END IF
9391  CONTINUE
9392  CONTINUE
      egs_is_absolute_path = .false.
      return
      end
      integer function egs_get_unit(iunit)
      implicit none
      integer*4 iunit, i
      logical is_open
      IF (( iunit .GT. 0 )) THEN
        inquire(iunit,opened=is_open)
        IF (( .NOT.is_open )) THEN
          egs_get_unit = iunit
          return
        END IF
      END IF
      DO 9401 i=1,99
        inquire(i,opened=is_open)
        IF (( .NOT.is_open )) THEN
          egs_get_unit = i
          return
        END IF
9401  CONTINUE
9402  CONTINUE
      egs_get_unit = -1
      return
      end
      integer function egs_open_file(iunit,rl,action,extension)
      implicit none
      integer*4 iunit, rl, action
      character*(*) extension
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      logical egs_is_absolute_path,is_open
      integer egs_get_unit
      integer i,lnblnk1
      character*1024 tmp_string,error_string
      integer*4 the_unit
      egs_open_file = -1
      the_unit = egs_get_unit(iunit)
      IF (( the_unit .LT. 0 )) THEN
        IF (( action .EQ. 0 )) THEN
          egs_open_file = -1
          return
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'No free Fortran I/O units left'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( egs_is_absolute_path(extension) )) THEN
        inquire(file=extension,opened=is_open)
        IF ((is_open)) THEN
          inquire(file=extension,number=the_unit)
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,'(a,a,/,a,i3,/,a,/,a)') 'File ',extension(:lnblnk1
     *    (extension)), ' is already opened and connected to unit ',the_
     *    unit, ' Will not try to re-open this file, assuming it has bee
     *n opened', ' by the .io file.'
        ELSE IF(( rl .EQ. 0 )) THEN
          open(the_unit,file=extension,status='unknown')
        ELSE
          open(the_unit,file=extension,status='unknown',form='unformatte
     *d', access='direct', recl=rl)
        END IF
        egs_open_file = the_unit
        return
      END IF
      DO 9411 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
9411  CONTINUE
9412  CONTINUE
      tmp_string = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(us
     *er_code)) // '/' // work_dir(:lnblnk1(work_dir)) // output_file(:l
     *nblnk1(output_file))
      IF (( i_parallel .GT. 0 )) THEN
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // '_w'
        call egs_itostring(tmp_string,i_parallel,.false.)
      END IF
      tmp_string = tmp_string(:lnblnk1(tmp_string)) // extension(:lnblnk
     *1(extension))
      inquire(file=tmp_string,opened=is_open)
      IF ((is_open)) THEN
        inquire(file=tmp_string,number=the_unit)
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,'(a,a,/,a,i3,/,a,/,a,/)') 'File ',tmp_string(:lnblnk
     *  1(tmp_string)), ' is already opened and connected to unit ',the_
     *  unit, ' Will not try to re-open this file, assuming it has been
     *opened', ' by specifying it in the .io file.'
      ELSE IF(( rl .EQ. 0 )) THEN
        open(the_unit,file=tmp_string,status='unknown',err=9420)
      ELSE
        open(the_unit,file=tmp_string,status='unknown',form='unformatted
     *', access='direct', recl=rl,err=9420)
      END IF
      egs_open_file = the_unit
      return
9420  error_string = 'In egs_open_file: failed to open file ' // tmp_str
     *ing(:lnblnk1(tmp_string)) // char(10) // 'iunit = '
      call egs_itostring(error_string,iunit,.false.)
      error_string = error_string(:lnblnk1(error_string)) // ' the_unit
     *= '
      call egs_itostring(error_string,the_unit,.false.)
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a)') error_string(:lnblnk1(error_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      integer function egs_open_datfile(iunit,rl,action,extension)
      implicit none
      integer*4 iunit,rl,action
      character*(*) extension
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer i,the_unit,lnblnk1,egs_get_unit
      logical egs_is_absolute_path
      character base*1024, fn*1024
      egs_open_datfile = -1
      the_unit = egs_get_unit(iunit)
      IF (( the_unit .LT. 0 )) THEN
        IF (( action .EQ. 0 )) THEN
          egs_open_datfile = -1
          return
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'No free Fortran I/O units left'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( egs_is_absolute_path(extension) )) THEN
        IF (( rl .EQ. 0 )) THEN
          open(the_unit,file=extension,status='old',err=9430)
        ELSE
          open(the_unit,file=extension,status='old',form='unformatted',
     *    access='direct',recl=rl,err=9430)
        END IF
        egs_open_datfile = the_unit
        return
9430    CONTINUE
        IF (( action .EQ. 0 )) THEN
          egs_open_datfile = -2
          return
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Failed to open file ',extension(:lnblnk1(extensi
     *  on))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      DO 9441 i=1,len(base)
        base(i:i) = ' '
9441  CONTINUE
9442  CONTINUE
      DO 9451 i=1,len(fn)
        fn(i:i) = ' '
9451  CONTINUE
9452  CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e)) // '/'
      IF (( i_parallel .GT. 0 )) THEN
        fn = base(:lnblnk1(base)) // output_file(:lnblnk1(output_file))
     *  // '_w'
        call egs_itostring(fn,i_parallel,.false.)
        fn = fn(:lnblnk1(fn)) // extension(:lnblnk1(extension))
      ELSE
        fn = base(:lnblnk1(base)) // output_file(:lnblnk1(output_file))
     *  // extension(:lnblnk1(extension))
      END IF
      IF (( rl .EQ. 0 )) THEN
        open(the_unit,file=fn,status='old',err=9460)
      ELSE
        open(the_unit,file=fn,status='old',form='unformatted',access='di
     *rect', recl=rl,err=9460)
      END IF
      egs_open_datfile = the_unit
      return
9460  CONTINUE
      write(i_log,'(/a)') '***************** Warning: '
      write(i_log,'(a,a)') 'Failed to open ',fn(:lnblnk1(fn))
      DO 9471 i=1,len(fn)
        fn(i:i) = ' '
9471  CONTINUE
9472  CONTINUE
      IF (( i_parallel .GT. 0 )) THEN
        fn = base(:lnblnk1(base)) // input_file(:lnblnk1(input_file)) //
     *   '_w'
        call egs_itostring(fn,i_parallel,.false.)
        fn = fn(:lnblnk1(fn)) // extension(:lnblnk1(extension))
      ELSE
        fn = base(:lnblnk1(base)) // input_file(:lnblnk1(input_file)) //
     *   extension(:lnblnk1(extension))
      END IF
      IF (( rl .EQ. 0 )) THEN
        open(the_unit,file=fn,status='old',err=9480)
      ELSE
        open(the_unit,file=fn,status='old',form='unformatted',access='di
     *rect', recl=rl,err=9480)
      END IF
      egs_open_datfile = the_unit
      return
9480  CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Failed to open data file'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      integer function egs_open_file_junk(iunit,do_it_anyway,filen)
      implicit none
      integer*4 iunit
      logical do_it_anyway
      character*(*) filen
      logical aux
      integer*4 the_unit,i
      inquire(file=filen,exist=aux)
      IF (( .NOT.aux )) THEN
        egs_open_file_junk = -2
        return
      END IF
      IF (( iunit .LT. 0 )) THEN
        the_unit = -iunit
      ELSE
        the_unit = iunit
      END IF
      IF (( the_unit .NE. 0 )) THEN
        inquire(unit=the_unit,opened=aux)
        IF (( aux )) THEN
          IF (( .NOT.do_it_anyway )) THEN
            egs_open_file_junk = -4
            return
          END IF
          IF((iunit .LT. 0))the_unit = 0
        END IF
      END IF
      IF (( the_unit .EQ. 0 )) THEN
        DO 9491 i=1,99
          inquire(unit=i,opened=aux)
          IF (( .NOT.aux )) THEN
            the_unit = i
            GO TO9492
          END IF
9491    CONTINUE
9492    CONTINUE
        IF (( the_unit .EQ. 0 )) THEN
          egs_open_file_junk = -1
          return
        END IF
      END IF
      open(the_unit,file=filen,status='old',err=9500)
      egs_open_file_junk = the_unit
      return
9500  egs_open_file_junk = -3
      return
      end
      subroutine egs_strip_path(fname)
      implicit none
      character*(*) fname
      integer i,l,l1,lnblnk1,j
      character slash
      slash = '/'
      l = lnblnk1(fname)
      DO 9511 i=1,l
        IF (( fname(i:i) .EQ. slash )) THEN
          fname(i:i) = '/'
        END IF
9511  CONTINUE
9512  CONTINUE
      DO 9521 i=l,1,-1
        IF (( fname(i:i) .EQ. '/' .OR. fname(i:i) .EQ. slash )) THEN
          l1 = l-i
          fname(:l1) = fname(i+1:l)
          DO 9531 j=l1+1,len(fname)
            fname(j:j) = ' '
9531      CONTINUE
9532      CONTINUE
          return
        END IF
9521  CONTINUE
9522  CONTINUE
      return
      end
      subroutine replace_env(fname)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*(*) fname
      character*256 dirname
      integer indsep,ind1,ind2
      indsep = index(fname,'/')
      IF((indsep .LE. 0))return
      ind1=index(fname,'$')
      ind2=index(fname,'~')
      IF ((ind1.EQ.1)) THEN
        call getenv(fname(2:indsep-1),dirname)
        IF ((dirname.EQ.' ')) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,a/,a)') ' Error in file name: ',fname(:lnblnk1
     *    (fname)), ' First element in name does not specify a defined e
     *nvironment variable.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        fname=dirname(:lnblnk1(dirname))//fname(indsep:)
        write(6,'(//a,a/)') ' Retrieving file: ',fname(:lnblnk1(fname))
        write(1,'(//a,a/)') ' Retrieving file: ',fname(:lnblnk1(fname))
      ELSE IF((ind2.EQ.1)) THEN
        call getenv('HOME',dirname)
        IF ((dirname.EQ.' ')) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,a/,a)') ' Error in file name: ',fname(:lnblnk1
     *    (fname)), ' HOME is undefined.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        fname=dirname(:lnblnk1(dirname))//fname(indsep:)
        write(6,'(//a,a/)') ' Retrieving file: ',fname(:lnblnk1(fname))
        write(1,'(//a,a/)') ' Retrieving file: ',fname(:lnblnk1(fname))
      END IF
      return
      end
      subroutine egs_get_usercode(ucode)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*(*) ucode
      character*512 arg
      integer l,l1,lnblnk1,i
      call getarg(0,arg)
      call egs_strip_path(arg)
      l = lnblnk1(arg)
      IF (( arg(l-3:l) .EQ. '.exe' )) THEN
        arg(l-3:l) = ' '
        l = l - 4
      END IF
      IF (( arg(l-5:l) .EQ. '_debug' )) THEN
        arg(l-5:l) = ' '
        l = l-5
      END IF
      IF (( arg(l-5:l) .EQ. '_noopt' )) THEN
        arg(l-5:l) = ' '
        l = l-5
      END IF
      l1 = len(ucode)
      IF (( l .GT. l1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' user code name is too long (',l,' chars)'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      DO 9541 i=1,len(ucode)
        ucode(i:i) = ' '
9541  CONTINUE
9542  CONTINUE
      ucode(:l) = arg(:l)
      return
      end
      subroutine egs_itostring(string,i,leave_space)
      implicit none
      character*(*) string
      integer*4 i
      integer l,lnblnk1,idiv,itmp,iaux
      logical first,leave_space
      l = lnblnk1(string)+1
      IF((l .GT. 1 .AND. leave_space))l=l+1
      idiv = 1000000000
      itmp = i
      first = .false.
      do while(idiv.gt.0)
      iaux = itmp/idiv
      IF (( (iaux .GT. 0 .OR. first ) .AND. l .LE. len(string) )) THEN
        string(l:l) = char(iaux+48)
        first = .true.
        l = l+1
      END IF
      itmp = itmp - iaux*idiv
      idiv = idiv/10
      end do
      return
      end
      real*8 function egs_rndm()
      implicit none
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      IF((rng_seed .GT. 128))call ranmar_get
      egs_rndm = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      return
      end
      integer function egs_add_medium(medname)
      implicit none
      character*(*) medname
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,l,imed,medname_len
      character c
      logical same
      l = min(len(medname),24)
      medname_len = l
      DO 9551 i=1,l
        c = medname(i:i)
        IF (( ichar(c) .EQ. 0 )) THEN
          medname_len = i-1
          GO TO9552
        END IF
9551  CONTINUE
9552  CONTINUE
      DO 9561 imed=1,nmed
        l = 24
        DO 9571 i=1,24
          IF (( media(i,imed)(1:1) .EQ. ' ' )) THEN
            l = i-1
            GO TO9572
          END IF
9571    CONTINUE
9572    CONTINUE
        IF (( l .EQ. medname_len )) THEN
          same = .true.
          DO 9581 i=1,l
            c = medname(i:i)
            IF (( c .NE. media(i,imed)(1:1) )) THEN
              same = .false.
              GO TO9582
            END IF
9581      CONTINUE
9582      CONTINUE
          IF (( same )) THEN
            egs_add_medium = imed
            return
          END IF
        END IF
9561  CONTINUE
9562  CONTINUE
      nmed = nmed + 1
      IF (( nmed .GT. 3 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(a,/,a,i3,a)') 'In egs_add_medium: maximum number o
     *f media exceeded ', 'Increase the macro $MXMED (currently ',3,') a
     *nd retry'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      l = min(len(medname),24)
      DO 9591 i=1,l
        c = medname(i:i)
        IF (( ichar(c) .EQ. 0 )) THEN
          l = i-1
          GO TO9592
        END IF
        media(i,nmed) = ' '
        media(i,nmed)(1:1) = c
9591  CONTINUE
9592  CONTINUE
      IF (( l .LT. 24 )) THEN
        DO 9601 i=l+1,24
          media(i,nmed) = ' '
9601    CONTINUE
9602    CONTINUE
      END IF
      egs_add_medium = nmed
      return
      end
      subroutine egs_get_medium_name(imed,medname)
      implicit none
      character*(*) medname
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,l,imed
      DO 9611 i=1,len(medname)
        medname(i:i) = ' '
9611  CONTINUE
9612  CONTINUE
      IF (( imed .LT. 1 .OR. imed .GT. nmed )) THEN
        return
      END IF
      l = 24
      DO 9621 l=24,1,-1
        IF((media(l,imed)(1:1) .NE. ' '))GO TO9622
9621  CONTINUE
9622  CONTINUE
      l = min(l,len(medname))
      DO 9631 i=1,l
        medname(i:i) = media(i,imed)(1:1)
9631  CONTINUE
9632  CONTINUE
      return
      end
      subroutine egs_get_electron_data(func,imed,which)
      implicit none
      integer*4 imed,which
      external func
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 lemin,lemax
      lemin = (1 - eke0(imed))/eke1(imed)
      lemax = (meke(imed) - eke0(imed))/eke1(imed)
      IF (( which .EQ. 1 )) THEN
        call func(meke(imed),lemin,lemax,esig0(1,imed),esig1(1,imed))
      ELSE IF(( which .EQ. 2 )) THEN
        call func(meke(imed),lemin,lemax,psig0(1,imed),psig1(1,imed))
      ELSE IF(( which .EQ. 3 )) THEN
        call func(meke(imed),lemin,lemax,ededx0(1,imed),ededx1(1,imed))
      ELSE IF(( which .EQ. 4 )) THEN
        call func(meke(imed),lemin,lemax,pdedx0(1,imed),pdedx1(1,imed))
      ELSE IF(( which .EQ. 5 )) THEN
        call func(meke(imed),lemin,lemax,ebr10(1,imed),ebr11(1,imed))
      ELSE IF(( which .EQ. 6 )) THEN
        call func(meke(imed),lemin,lemax,pbr10(1,imed),pbr11(1,imed))
      ELSE IF(( which .EQ. 7 )) THEN
        call func(meke(imed),lemin,lemax,pbr20(1,imed),pbr21(1,imed))
      ELSE IF(( which .EQ. 8 )) THEN
        call func(meke(imed),lemin,lemax,tmxs0(1,imed),tmxs1(1,imed))
      ELSE IF(( which .EQ. 9 )) THEN
        call func(meke(imed),lemin,lemax,range_ep(0,1,imed),range_ep(1,1
     *  ,imed))
      ELSE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Unknown electron data type ',which
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      return
      end
      subroutine egs_get_photon_data(func,imed,which)
      implicit none
      integer*4 imed,which
      external func
      COMMON/PHOTIN/ EBINDA(3), GE0(3),GE1(3), GMFP0(2000,3),GMFP1(2000,
     *3),GBR10(2000,3),GBR11(2000,3),GBR20(2000,3),GBR21(2000,3), RCO0(3
     *),RCO1(3), RSCT0(100,3),RSCT1(100,3), COHE0(2000,3),COHE1(2000,3),
     *  PHOTONUC0(2000,3),PHOTONUC1(2000,3), DPMFP, MPGEM(1,3), NGR(3)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 lemin,lemax
      lemin = (1 - ge0(imed))/ge1(imed)
      lemax = (mge(imed) - ge0(imed))/ge1(imed)
      IF (( which .EQ. 1 )) THEN
        call func(mge(imed),lemin,lemax,gmfp0(1,imed),gmfp1(1,imed))
      ELSE IF(( which .EQ. 2 )) THEN
        call func(mge(imed),lemin,lemax,gbr10(1,imed),gbr11(1,imed))
      ELSE IF(( which .EQ. 3 )) THEN
        call func(mge(imed),lemin,lemax,gbr20(1,imed),gbr21(1,imed))
      ELSE IF(( which .EQ. 4 )) THEN
        call func(mge(imed),lemin,lemax,cohe0(1,imed),cohe1(1,imed))
      ELSE IF(( which .EQ. 5 )) THEN
        call func(mge(imed),lemin,lemax,PHOTONUC0(1,imed),PHOTONUC1(1,im
     *  ed))
      ELSE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Unknown photon data type ',which
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      return
      end
      subroutine egs_print_binding_energies
      implicit none
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,j
      integer*4 lnblnk1
      character*3 labels(16)
      data labels/'  K',' L1',' L2',' L3', ' M1',' M2',' M3',' M4',' M5'
     *, ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/
      write(6,'(a,a,a)') 'Binding energies from ',photon_xsections(:lnbl
     *nk1(photon_xsections)), ' photon cross section library'
      write(1,'(a,a,a)') 'Binding energies from ',photon_xsections(:lnbl
     *nk1(photon_xsections)), ' photon cross section library'
      DO 9641 j=1,100
        DO 9651 i=1,16
          IF (( binding_energies(i,j) .GT. 0 )) THEN
            write(6,'(a,i3,a,a,a,1pe12.4,a)') ' Eb(',j,',',labels(i),')
     *= ',binding_energies(i,j),' MeV'
            write(1,'(a,i3,a,a,a,1pe12.4,a)') ' Eb(',j,',',labels(i),')
     *= ',binding_energies(i,j),' MeV'
          END IF
9651    CONTINUE
9652    CONTINUE
9641  CONTINUE
9642  CONTINUE
      return
      end
      subroutine egs_scale_xcc(imed,factor)
      implicit none
      integer*4 imed
      real*8 factor
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      IF (( imed .GT. 0 .AND. imed .LE. nmed )) THEN
        xcc(imed) = xcc(imed)*factor
      END IF
      return
      end
      subroutine egs_write_string(ounit,string)
      implicit none
      integer*4 ounit
      character*(*) string
      write(ounit,'(a,$)') string
      call flush(ounit)
      return
      end
      subroutine egs_swap_2(c)
      character c(2),tmp
      tmp=c(2)
      c(2)=c(1)
      c(1)=tmp
      return
      end
      subroutine egs_swap_4(c)
      character c(4),tmp
      tmp=c(4)
      c(4)=c(1)
      c(1)=tmp
      tmp=c(3)
      c(3)=c(2)
      c(2)=tmp
      return
      end
      subroutine set_spline(x,f,a,b,c,d,n)
      implicit none
      integer*4 n
      real*8 x(n),f(n),a(n),b(n),c(n),d(n)
      integer*4 m1,m2,m,mr
      real*8 s,r
      m1 = 2
      m2 = n-1
      s = 0
      DO 9661 m=1,m2
        d(m) = x(m+1) - x(m)
        r = (f(m+1) - f(m))/d(m)
        c(m) = r - s
        s = r
9661  CONTINUE
9662  CONTINUE
      s=0
      r=0
      c(1)=0
      c(n)=0
      DO 9671 m=m1,m2
        c(m) = c(m) + r*c(m-1)
        b(m) = 2*(x(m-1) - x(m+1)) - r*s
        s = d(m)
        r = s/b(m)
9671  CONTINUE
9672  CONTINUE
      mr = m2
      DO 9681 m=m1,m2
        c(mr) = (d(mr)*c(mr+1) - c(mr))/b(mr)
        mr = mr - 1
9681  CONTINUE
9682  CONTINUE
      DO 9691 m=1,m2
        s = d(m)
        r = c(m+1) - c(m)
        d(m) = r/s
        c(m) = 3*c(m)
        b(m) = (f(m+1)-f(m))/s - (c(m)+r)*s
        a(m) = f(m)
9691  CONTINUE
9692  CONTINUE
      return
      end
      real*8 function spline(s,x,a,b,c,d,n)
      implicit none
      integer*4 n
      real*8 s,x(n),a(n),b(n),c(n),d(n)
      integer m_lower,m_upper,direction,m,ml,mu,mav
      real*8 q
      IF (( x(1) .GT. x(n) )) THEN
        direction = 1
        m_lower = n
        m_upper = 0
      ELSE
        direction = 0
        m_lower = 0
        m_upper = n
      END IF
      IF (( s .GE. x(m_upper + direction) )) THEN
        m = m_upper + 2*direction - 1
      ELSE IF(( s .LE. x(m_lower+1-direction) )) THEN
        m = m_lower - 2*direction + 1
      ELSE
        ml = m_lower
        mu = m_upper
9701    IF(iabs(mu-ml).LE.1)GO TO 9702
          mav = (ml+mu)/2
          IF (( s .LT. x(mav) )) THEN
            mu = mav
          ELSE
            ml = mav
          END IF
        GO TO 9701
9702    CONTINUE
        m = mu + direction - 1
      END IF
      q = s - x(m)
      spline = a(m) + q*(b(m) + q*(c(m) + q*d(m)))
      return
      end
      subroutine prepare_alias_table(nsbin,xs_array,fs_array,ws_array,ib
     *in_array)
      implicit none
      integer nsbin
      integer*4 ibin_array(nsbin)
      real*8 xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin)
      integer*4 i,j_l,j_h
      real*8 sum,aux
      sum = 0
      DO 9711 i=1,nsbin
        aux = 0.5*(fs_array(i)+fs_array(i-1))*(xs_array(i)-xs_array(i-1)
     *  )
        IF((aux .LT. 1e-30))aux = 1e-30
        ws_array(i) = -aux
        ibin_array(i) = 1
        sum = sum + aux
9711  CONTINUE
9712  CONTINUE
      sum = sum/nsbin
      DO 9721 i=1,nsbin-1
        DO 9731 j_h=1,nsbin
          IF (( ws_array(j_h) .LT. 0 )) THEN
            IF((abs(ws_array(j_h)) .GT. sum))GOTO 9740
          END IF
9731    CONTINUE
9732    CONTINUE
        j_h = nsbin
9740    CONTINUE
          DO 9741 j_l=1,nsbin
          IF (( ws_array(j_l) .LT. 0 )) THEN
            IF((abs(ws_array(j_l)) .LT. sum))GOTO 9750
          END IF
9741    CONTINUE
9742    CONTINUE
        j_l = nsbin
9750    aux = sum - abs(ws_array(j_l))
        ws_array(j_h) = ws_array(j_h) + aux
        ws_array(j_l) = -ws_array(j_l)/sum
        ibin_array(j_l) = j_h
        IF((i .EQ. nsbin-1))ws_array(j_h) = 1
9721  CONTINUE
9722  CONTINUE
      return
      end
      real*8 function alias_sample1(nsbin,xs_array,fs_array,ws_array,ibi
     *n_array)
      implicit none
      integer nsbin
      integer*4 ibin_array(nsbin)
      real*8 xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin)
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      integer*4 j
      real*8 r1,r2,aj,x,dx,a,rnno1
      IF((rng_seed .GT. 128))call ranmar_get
      r1 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((rng_seed .GT. 128))call ranmar_get
      r2 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      aj = 1 + r1*nsbin
      j = aj
      aj = aj - j
      IF((aj .GT. ws_array(j)))j = ibin_array(j)
      x = xs_array(j-1)
      dx = xs_array(j)-x
      IF (( fs_array(j-1) .GT. 0 )) THEN
        a = fs_array(j)/fs_array(j-1)-1
        IF (( abs(a) .LT. 0.2 )) THEN
          rnno1 = 0.5*(1-r2)*a
          alias_sample1 = x + r2*dx*(1+rnno1*(1-r2*a))
        ELSE
          alias_sample1 = x - dx/a*(1-sqrt(1+r2*a*(2+a)))
        END IF
      ELSE
        alias_sample1 = x + dx*sqrt(r2)
      END IF
      return
      end
      subroutine prepare_alias_histogram(nsbin,ws_array,ibin_array)
      implicit none
      integer*4 nsbin,ibin_array(nsbin)
      real*8 ws_array(nsbin)
      integer*4 i,j_l,j_h
      real*8 sum,aux
      sum = 0
      DO 9761 i=1,nsbin
        sum = sum + ws_array(i)
        ibin_array(i) = -1
9761  CONTINUE
9762  CONTINUE
      sum = sum/nsbin
      DO 9771 i=1,nsbin-1
        DO 9781 j_h=1,nsbin
          IF((ibin_array(j_h) .LT. 0 .AND. ws_array(j_h) .GT. sum))GO TO
     *    9782
9781    CONTINUE
9782    CONTINUE
        DO 9791 j_l=1,nsbin
          IF((ibin_array(j_l) .LT. 0 .AND. ws_array(j_l) .LT. sum))GO TO
     *    9792
9791    CONTINUE
9792    CONTINUE
        aux = sum - ws_array(j_l)
        ws_array(j_h) = ws_array(j_h) - aux
        ws_array(j_l) = ws_array(j_l)/sum
        ibin_array(j_l) = j_h
9771  CONTINUE
9772  CONTINUE
      DO 9801 i=1,nsbin
        IF (( ibin_array(i) .LT. 0 )) THEN
          ibin_array(i) = i
          ws_array(i) = 1
        END IF
9801  CONTINUE
9802  CONTINUE
      return
      end
      integer*4 function sample_alias_histogram(nsbin,ws_array,ibin_arra
     *y)
      implicit none
      integer*4 nsbin,ibin_array(*)
      real*8 ws_array(*)
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      real*8 r1,r2
      integer*4 ibin
      IF((rng_seed .GT. 128))call ranmar_get
      r1 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((rng_seed .GT. 128))call ranmar_get
      r2 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      ibin = 1 + nsbin*r1
      IF((r2 .GT. ws_array(ibin)))ibin = ibin_array(ibin)
      sample_alias_histogram = ibin
      return
      end
      subroutine gauss_legendre(x1,x2,x,w,n)
      implicit none
      integer*4 n
      real*8 x1,x2,x(n),w(n)
      real*8 eps,Pi
      parameter (eps = 3.D-14,Pi=3.141592654D0)
      integer*4 i,m,j
      real*8 xm,xl,z,z1,p1,p2,p3,pp
      m = (n + 1)/2
      xm=0.5d0*(x2+x1)
      xl=0.5d0*(x2-x1)
      DO 9811 i=1,m
        z=cos(Pi*(i-.25d0)/(n+.5d0))
9821    CONTINUE
          p1=1.d0
          p2=0.d0
          DO 9831 j=1,n
            p3 = p2
            p2 = p1
            p1=((2.d0*j-1.d0)*z*p2-(j-1.d0)*p3)/j
9831      CONTINUE
9832      CONTINUE
          pp=n*(z*p1-p2)/(z*z-1.d0)
          z1=z
          z=z1-p1/pp
          IF(((abs(z-z1) .LT. eps)))GO TO9822
        GO TO 9821
9822    CONTINUE
        x(i)=xm-xl*z
        x(n+1-i)=xm+xl*z
        w(i)=2.d0*xl/((1.d0-z*z)*pp*pp)
        w(n+1-i)=w(i)
9811  CONTINUE
9812  CONTINUE
      return
      end
      integer function lnblnk1(string)
      character*(*) string
      integer i
      DO 9841 i=len(string),1,-1
        j = ichar(string(i:i))
        IF (( j .EQ. 0 )) THEN
          lnblnk1 = i-1
          return
        END IF
        IF (( j .NE. 9 .AND. j .NE. 10 .AND. j .NE. 11 .AND. j .NE. 12 .
     *  AND. j .NE. 13 .AND. j .NE. 32 )) THEN
          lnblnk1 = i
          return
        END IF
9841  CONTINUE
9842  CONTINUE
      lnblnk1 = 0
      return
      end
      real*8 FUNCTION ERF1(X)
      implicit none
      real*8 x
      double precision A(0:22,2)
      double precision CONST,  BN,BN1,BN2,  Y,FAC
      integer*4 N,  K,  NLIM(2)
      DATA A/ 1.0954712997776232 , -0.2891754011269890 , 0.1104563986337
     *951 , -0.0412531882278565 , 0.0140828380706516 , -0.00432929544743
     *14 , 0.0011982719015923 , -0.0002999729623532 , 0.0000683258603789
     * , -0.0000142469884549 , 0.0000027354087728 , -0.0000004861912872
     *, 0.0000000803872762 , -0.0000000124184183 , 0.0000000017995326 ,
     *-0.0000000002454795 , 0.0000000000316251 , -0.0000000000038590 , 0
     *.0000000000004472 , -0.0000000000000493 , 0.0000000000000052 , -0.
     *0000000000000005 , 0.0000000000000001 , 0.9750834237085559 , -0.02
     *40493938504146 , 0.0008204522408804 , -0.0000434293081303 , 0.0000
     *030184470340 , -0.0000002544733193 , 0.0000000248583530 , -0.00000
     *00027317201 , 0.0000000003308472 , 0.0000000000001464 , -0.0000000
     *000000244 , 0.0000000000000042 , -0.0000000000000008 , 0.000000000
     *0000001 , 9*0.0 /
      DATA NLIM/ 22,16 /
      DATA CONST/ 1.128379167095513 /
      IF (( x .GT. 3 )) THEN
        y = 3/x
        k = 2
      ELSE
        y = x/3
        k = 1
      END IF
      FAC = 2.0 * ( 2.0 * Y*Y - 1.0 )
      BN1 = 0.0
      BN = 0.0
      DO 9851 n=NLIM(K),0,-1
        BN2 = BN1
        BN1 = BN
        BN = FAC * BN1 - BN2 + A(N,K)
9851  CONTINUE
9852  CONTINUE
      IF (( k .EQ. 1 )) THEN
        erf1 = CONST * Y * ( BN - BN1 )
      ELSE
        erf1 = 1 - CONST * EXP(-X**2) * ( BN - BN2 + A(0,K) )/(4.0 * X)
      END IF
      RETURN
      end
      real*8 FUNCTION ZERO()
      implicit none
      integer*4 i
      real*8 x, xtemp
      x = 1.E-20
      DO 9861 i=1,100
        IF ((x .EQ. 0.0)) THEN
          GO TO9862
        ELSE
          xtemp = x
        END IF
        x = x/1.E5
9861  CONTINUE
9862  CONTINUE
      x = xtemp
      DO 9871 i=1,5
        IF ((x .NE. 0.0)) THEN
          xtemp = x
        ELSE
          GO TO9872
        END IF
        x = x/10
9871  CONTINUE
9872  CONTINUE
      x = xtemp
      DO 9881 i=2,10
        IF ((x .NE. 0.0)) THEN
          xtemp = x
        ELSE
          GO TO9882
        END IF
        x = x/i
9881  CONTINUE
9882  CONTINUE
      zero = xtemp
      return
      end
      character*512 function toUpper(a_string)
      character*(*) a_string
      character*512 the_string
      integer*4 cursor, i, lnblnk1
      toUpper = a_string
      the_string = a_string
      DO 9891 i=1,lnblnk1(the_string)
        cursor=ICHAR(the_string(i:i))
        IF (((cursor.GE.97).AND.(cursor.LE.122))) THEN
          cursor=cursor-32
          toUpper(i:i)=CHAR(cursor)
        END IF
9891  CONTINUE
9892  CONTINUE
      return
      end
      integer*1 function egs_read_byte(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      integer*1 i_1
      character c_1
      equivalence (i_1,c_1)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      read(iunit,rec=jrec,IOSTAT=ierr) c_1
      IF ((ierr.ne.0)) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' *** egs_read_byte: ERROR READING A byte *** '
        write(6,*) ' From unit ',iunit,' position ',jrec,' bytes'
        write(1,*) ' From unit ',iunit,' position ',jrec,' bytes'
        egs_read_byte = -1
        return
      END IF
      jrec = jrec + 1
      egs_read_byte = i_1
      return
      end
      integer*2 function egs_read_short(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      integer*2 i_2
      character c_2(2)
      equivalence (i_2,c_2)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      j = 0
      DO 9901 i=jrec,jrec+1
        j = j + 1
        read(iunit,rec=i,IOSTAT=ierr) c_2(j)
        IF ((ierr.ne.0)) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' *** egs_read_short: ERROR READING short integ
     *er *** '
          write(6,*) ' From unit ',iunit,' position ',jrec,' bytes'
          write(1,*) ' From unit ',iunit,' position ',jrec,' bytes'
          egs_read_short = -1
          return
        END IF
9901  CONTINUE
9902  CONTINUE
      jrec = jrec + 2
      egs_read_short = i_2
      return
      end
      integer*4 function egs_read_int(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      integer*4 i_4
      character c_4(4)
      equivalence (i_4,c_4)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      j = 0
      DO 9911 i=jrec,jrec+3
        j = j + 1
        read(iunit,rec=i,IOSTAT=ierr) c_4(j)
        IF ((ierr.ne.0)) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' *** egs_read_int: ERROR READING integer *** '
          write(6,*) ' From unit ',iunit,' position ',jrec,' bytes'
          write(1,*) ' From unit ',iunit,' position ',jrec,' bytes'
          egs_read_int = -1
          return
        END IF
9911  CONTINUE
9912  CONTINUE
      jrec = jrec + 4
      egs_read_int = i_4
      return
      end
      real*4 function egs_read_real(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      real*4 r_4
      character c_4(4)
      equivalence (r_4,c_4)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      j = 0
      DO 9921 i=jrec,jrec+3
        j = j + 1
        read(iunit,rec=i,IOSTAT=ierr) c_4(j)
        IF ((ierr.ne.0)) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' *** egs_read_real: ERROR READING float *** '
          write(6,*) ' From unit ',iunit,' position ',jrec,' bytes'
          write(1,*) ' From unit ',iunit,' position ',jrec,' bytes'
          egs_read_real = -1
          return
        END IF
9921  CONTINUE
9922  CONTINUE
      jrec = jrec + 4
      egs_read_real = r_4
      return
      end
      integer*4 function ibsearch(a, nsh, b)
      implicit none
      real*8 a, b(*)
      integer*4 min,max,help,nsh
      real*8 x
      min = 1
      max = nsh
      x = a
9931  IF(min.GE.max-1)GO TO 9932
        help = (max+min)/2
        IF (( b(help).le.x)) THEN
          min = help
        ELSE
          max = help
        END IF
      GO TO 9931
9932  CONTINUE
      ibsearch = min
      return
      end
#ifdef HAVE_C_COMPILER
      integer*4 function egs_create_lockfile(flag)
      integer*4 flag
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*512 fname
      integer*4 i,lnblnk1,l,istat
      DO 9941 i=1,len(fname)
        fname(i:i) = ' '
9941  CONTINUE
9942  CONTINUE
      fname = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_co
     *de)) // '/' // output_file(:lnblnk1(output_file)) // '.lock'
      l = lnblnk1(fname)+1
      fname(l:l) = char(0)
      call egs_create_control_file(fname,istat)
      IF (( istat .NE. 0 .AND. flag .EQ. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Failed to create a lock file named ',fname(:lnbl
     *  nk1(fname))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      egs_create_lockfile = istat
      return
      end
      integer*4 function egs_open_lockfile(flag)
      integer*4 flag
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*512 fname
      integer*4 i,lnblnk1,l,istat
      DO 9951 i=1,len(fname)
        fname(i:i) = ' '
9951  CONTINUE
9952  CONTINUE
      fname = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_co
     *de)) // '/' // output_file(:lnblnk1(output_file)) // '.lock'
      l = lnblnk1(fname)+1
      fname(l:l) = char(0)
      call egs_open_control_file(fname,istat)
      IF (( istat .NE. 0 .AND. flag .EQ. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Failed to open the lock file named ',fname(:lnbl
     *  nk1(fname))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      egs_open_lockfile = istat
      return
      end
      subroutine egs_remove_lockfile(istat)
      integer*4 istat
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*512 fname
      integer*4 i,lnblnk1,l
      DO 9961 i=1,len(fname)
        fname(i:i) = ' '
9961  CONTINUE
9962  CONTINUE
      fname = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_co
     *de)) // '/' // output_file(:lnblnk1(output_file)) // '.lock'
      l = lnblnk1(fname)+1
      fname(l:l) = char(0)
      call egs_remove_file(fname,istat)
      return
      end
      subroutine egs_pjob_control(ncase,n_run,n_left,n_tot,sum,sum2,res,
     *dres)
      implicit none
      integer*8 ncase,n_run,n_tot
      real*8 sum,sum2,res,dres
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/my_times/ t_elapsed, t_cpu, t_first
      real*8 t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      integer*8 n_last,n_left,nn_tot
      integer t_dum(8)
      integer*4 i,lnblnk1,n_write,n_read,istat,n_job
      integer*4 egs_create_lockfile, egs_open_lockfile
      real*8 tmp,tmp2
      logical first_time
      character control_string*256
      data first_time/.true./
      save first_time,n_last
      IF (( n_parallel .LE. 0 )) THEN
        n_run = ncase
        return
      END IF
      IF((first_time))n_last = 0
      DO 9971 i=1,len(control_string)
        control_string(i:i) = ' '
9971  CONTINUE
9972  CONTINUE
      n_run = ncase/n_parallel/10
      n_left = ncase
      IF (( first_time )) THEN
        IF((n_run .GT. n_left))n_run = n_left
        n_left = ncase - n_run
        IF (( i_parallel .EQ. first_parallel )) THEN
          istat = egs_create_lockfile(1)
          IF (( n_tot .GT. 1 )) THEN
            res = sum/n_tot
            dres = sum2/n_tot - res*res
            IF (( res .GT. 0 .AND. dres .GT. 0 )) THEN
              dres = sqrt(dres/(n_tot-1))/res*100
            ELSE
              dres = 99.9
            END IF
          ELSE
            res = 0
            dres = 99.9
          END IF
          write(control_string,'(2i15,i4,2(1pe16.8),1pe13.5,0pf7.2,2x,8i
     *5)') n_left,n_tot,1,sum,sum2,res,dres,(t_first(i),i=1,8)
          n_write = lnblnk1(control_string) + 1
          call egs_write_control_file(control_string,n_write,istat)
          IF (( istat .NE. n_write )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'job 1: failed to write to lock file ',n_writ
     *      e,istat
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          call egs_unlock_control_file(istat)
          IF (( istat .NE. 0 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'job 1: failed to unlock the file ',istat
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          first_time = .false.
          n_max_parallel = 1
          n_last = n_run
          return
        END IF
        istat = egs_open_lockfile(1)
      END IF
      call egs_rewind_control_file(istat)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'job ',i_parallel,': failed to rewind or lock the
     * control ', 'file', istat
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      n_read = len(control_string)
      call egs_read_control_file(control_string,n_read,istat)
      read(control_string,*,err=9980) n_left,nn_tot,n_job,tmp,tmp2, res,
     *dres,(t_dum(i),i=1,8)
      nn_tot = nn_tot + n_last
      tmp = tmp + sum
      tmp2 = tmp2 + sum2
      IF (( first_time )) THEN
        first_time = .false.
        n_job = n_job + 1
        nn_tot = nn_tot + n_tot
      END IF
      n_tot = nn_tot
      IF (( n_tot .GT. 1 )) THEN
        res = tmp/n_tot
        dres = tmp2/n_tot - res*res
        IF (( res .GT. 0 .AND. dres .GT. 0 )) THEN
          dres = sqrt(dres/(n_tot-1))/res*100
        ELSE
          dres = 99.9
        END IF
      ELSE
        res = 0
        dres = 99.9
      END IF
      IF (( n_run .GT. n_left )) THEN
        n_run = n_left
        n_left = 0
      ELSE
        n_left = n_left - n_run
      END IF
      n_last = n_run
      DO 9991 i=1,len(control_string)
        control_string(i:i) = ' '
9991  CONTINUE
9992  CONTINUE
      write(control_string,'(2i15,i4,2(1pe16.8),1pe13.5,0pf7.2,2x,8i5)')
     * n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_dum(i),i=1,8)
      call egs_rewind_control_file(istat)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'job ',i_parallel,': failed to rewind or lock the
     * control ', 'file', istat
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      n_write = lnblnk1(control_string) + 1
      call egs_write_control_file(control_string,n_write,istat)
      IF (( istat .NE. n_write )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'job ',i_parallel,': failed to write to lock file
     * ', n_write,istat
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      call egs_unlock_control_file(istat)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'job ',i_parallel,': failed to unlock the file ',
     *  istat
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF((n_job .GT. n_max_parallel))n_max_parallel = n_job
      return
9980  write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,/a)') 'Failed to read from job control file: got '
     *, control_string(:lnblnk1(control_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_pjob_finish(n_job)
      implicit none
      integer*4 n_job
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/my_times/ t_elapsed, t_cpu, t_first
      real*8 t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      integer*4 istat,i,lnblnk1,n_read,n_write
      integer*8 n_left,n_tot
      integer t_start(8),t_end(8)
      real*8 tmp,tmp2,res,dres,t_run
      real egs_time_diff
      character control_string*256
      call egs_rewind_control_file(istat)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'job ',i_parallel,': failed to rewind or lock the
     * control ', 'file', istat
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      n_read = len(control_string)
      call egs_read_control_file(control_string,n_read,istat)
      read(control_string,*,end=10000,err=10000) n_left,n_tot,n_job,tmp,
     *tmp2,res,dres,(t_start(i),i=1,8)
      n_job = n_job - 1
      IF (( n_job .GT. 0 )) THEN
        DO 10011 i=1,len(control_string)
          control_string(i:i) = ' '
10011   CONTINUE
10012   CONTINUE
        write(control_string,'(2i15,i4,2(1pe16.8),1pe13.5,0pf7.2,2x,8i5)
     *') n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_start(i),i=1,8)
        call egs_rewind_control_file(istat)
        IF (( istat .NE. 0 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'job ',i_parallel,': failed to rewind or lock t
     *he ', 'control file, error was:', istat
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        n_write = lnblnk1(control_string) + 1
        call egs_write_control_file(control_string,n_write,istat)
        IF (( istat .NE. n_write )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'job ',i_parallel,': failed to write to lock fi
     *le ', n_write,istat
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        call egs_unlock_control_file(istat)
        call egs_close_control_file(istat)
        return
      END IF
      call egs_close_control_file(istat)
      call egs_remove_lockfile(istat)
      i_parallel = 0
      call egs_open_units(.false.)
      call egs_date_and_time(t_end)
      t_run = egs_time_diff(t_start,t_end)
      write(6,'(/a/,a,t55,i3/,a,t55,i3/,a,f9.1,a,f9.4,a/,a//)') '*******
     ********** finished parallel execution ******************', ' numbe
     *r of parallel jobs requested: ',n_parallel, ' max. number of jobs
     *executing simultaneously: ',n_max_parallel, ' elapsed time since f
     *irst job started: ',t_run,' s (',t_run/3600,' h)', '**************
     **************************************************'
      write(1,'(/a/,a,t55,i3/,a,t55,i3/,a,f9.1,a,f9.4,a/,a//)') '*******
     ********** finished parallel execution ******************', ' numbe
     *r of parallel jobs requested: ',n_parallel, ' max. number of jobs
     *executing simultaneously: ',n_max_parallel, ' elapsed time since f
     *irst job started: ',t_run,' s (',t_run/3600,' h)', '**************
     **************************************************'
      return
10000 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,/a)') 'In egs_pjob_finish: failed to read from con
     *trol string ', control_string(:lnblnk1(control_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
#endif
      SUBROUTINE EFUNS(E,V)
      implicit none
      real*4 E,V(8)
      real*4 BREM,AMOLL,BHAB,ANNIH,ESIG,PSIG
      real*4 BREMTM,AMOLTM,BHABTM,ANIHTM,SPTOTE,SPTOTP,TMXS,THBREM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      THBREM=RMP+APP
      IF ((IUNRSTP.EQ.0 .OR. IUNRSTP.EQ.1 .OR. IUNRSTP.EQ.5)) THEN
        BREM=BREMTM(E)
        AMOLL=AMOLTM(E)
        BHAB=BHABTM(E)
        ANNIH=ANIHTM(E)
        ESIG=BREM+AMOLL
        V(1)=ESIG
        PSIG=BREM+BHAB+ANNIH
        V(2)=PSIG
        V(3)=SPTOTE(E,AEP,APP)
        V(4)=SPTOTP(E,AEP,APP)
        IF ((ESIG.GT.0.0)) THEN
          V(5)=BREM/ESIG
        ELSE
          IF ((THBREM.LE.THMOLLP)) THEN
            V(5)=1.0
          ELSE
            V(5)=0.0
          END IF
        END IF
        V(6)=BREM/PSIG
        V(7)=(BREM+BHAB)/PSIG
        V(8)=TMXS(E)
      ELSE IF((IUNRSTP.EQ.2)) THEN
        V(1)=0.0
        V(2)=0.0
        V(5)=0.0
        V(6)=0.0
        V(7)=0.0
        V(3) = SPTOTE(E,E,E)
        V(4) = SPTOTP(E,E,E)
        V(8) = TMXS(E)
      ELSE IF((IUNRSTP.EQ.3)) THEN
        BREM=BREMTM(E)
        ANNIH=ANIHTM(E)
        V(1)=BREM
        V(2)=BREM + ANNIH
        V(3)=SPTOTE(E,E,APP)
        V(4)=SPTOTP(E,E,APP)
        V(5)=1.0
        V(6)=BREM/V(2)
        V(7)=V(6)
        V(8)=TMXS(E)
      ELSE IF((IUNRSTP.EQ.4)) THEN
        V(1)=AMOLTM(E)
        V(2)=BHABTM(E)
        V(3)=SPTOTE(E,AEP,E)
        V(4)=SPTOTP(E,AEP,E)
        V(5)=0.0
        V(6)=0.0
        V(7)=1.0
        V(8)=TMXS(E)
      ELSE
        WRITE(6,10020)IUNRSTP
10020   FORMAT(//'*********IUNRST=',I4,' NOT ALLOWED BY EFUNS*****'/ ' I
     *UNRST=6 OR 7 ONLY ALLOWED WITH CALL OR PLTN OPTIONS'//)
        call exit(20)
      END IF
      RETURN
      END
      real*4 FUNCTION BREMTM(E0)
      implicit none
      real*4 E0,BREMRM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      IF ((E0.LE.APP+RMP)) THEN
        BREMTM=0.
      ELSE
        BREMTM=BREMRM(E0,APP,E0-RMP)
      END IF
      RETURN
      END
      real*4 FUNCTION BREMRM(E,K1,K2)
      implicit none
      real*4 E,K1,K2
      integer*4 I
      real*4 BREMRZ
      COMMON/MIXDAT/NEP,LMED,PZP(50),ZELEMP(50),WAP(50),RHOZP(50), GASPP
     *,EZ,TPZ,IDSTRN(24)
      integer*4 NEP,LMED
      real*4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ
      CHARACTER*4 IDSTRN
      BREMRM=0.
      DO 10031 I=1,NEP
        BREMRM=BREMRM+PZP(I)*BREMRZ(ZELEMP(I),E,K1,K2)
10031 CONTINUE
10032 CONTINUE
      RETURN
      END
      real*4 FUNCTION BREMRZ(Z,E,K1,K2)
      implicit none
      real*4 Z,E,K1,K2
      EXTERNAL BREMFZ
      real*4 DUMMY,BREMDZ,QD,BREMFZ
      DUMMY=BREMDZ(Z,E,K1)
      BREMRZ=QD(BREMFZ,K1,K2,'BREMFZ')
      RETURN
      END
      real*4 FUNCTION BREMDZ(Z,E,K)
      implicit none
      real*4 Z,E,K,BRMSDZ
      BREMDZ=BRMSDZ(Z,E,K)/K
      RETURN
      END
      real*4 FUNCTION BREMFZ(K)
      implicit none
      real*4 K,BRMSFZ
      BREMFZ=BRMSFZ(K)/K
      RETURN
      END
      real*4 FUNCTION BRMSFZ(K)
      implicit none
      real*4 K
      real*4 EMKLOC,DELTA,SB1,SB2,EE
      COMMON/LBREMZ/CONST,DELC,EBREMZ,DELTAM,XLNZ
      real*4 CONST,DELC,EBREMZ,DELTAM,XLNZ
      EMKLOC=EBREMZ-K
      IF ((EMKLOC.EQ.0.0)) THEN
        EMKLOC=1.E-25
      END IF
      DELTA=DELC*K/EMKLOC
      IF ((DELTA.GE.DELTAM)) THEN
        BRMSFZ=0.0
      ELSE
        IF ((DELTA.LE.1.)) THEN
          SB1=20.867+DELTA*(-3.242+DELTA*0.625)-XLNZ
          SB2=20.209+DELTA*(-1.930+DELTA*(-0.086))-XLNZ
        ELSE
          SB1=21.12-4.184*LOG(DELTA+0.952)-XLNZ
          SB2=SB1
        END IF
        EE=EMKLOC/EBREMZ
        BRMSFZ=CONST*((1.+EE*EE)*SB1-0.666667*EE*SB2)
      END IF
      RETURN
      END
      real*4 FUNCTION AMOLTM(E0)
      implicit none
      real*4 E0
      real*4 T0,AMOLRM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      IF ((E0.LE.THMOLLP)) THEN
        AMOLTM=0.
      ELSE
        T0=E0-RMP
        AMOLTM=AMOLRM(E0,AEP,T0*0.5+RMP)
      END IF
      RETURN
      END
      real*4 FUNCTION AMOLRM(EN0,EN1,EN2)
      implicit none
      real*4 EN0,EN1,EN2
      real*4 T0,T1,T2,TM,EM,C1,C2,BETASQ,CMOLL2,EPS1,EPSP1,EPS2,EPSP2
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      T0=EN0-RMP
      T1=EN1-RMP
      T2=EN2-RMP
      TM=T0/RMP
      EM=TM+1.
      C1=(TM/EM)**2
      C2=(2.*TM+1.)/EM**2
      BETASQ=1.-1./EM**2
      CMOLL2=RLCP*EDEN*2.*PIP*R0**2/(BETASQ*TM)
      EPS1=T1/T0
      EPSP1=1.-EPS1
      EPS2=T2/T0
      EPSP2=1.-EPS2
      AMOLRM=CMOLL2*(C1*(EPS2-EPS1)+1./EPS1-1./EPS2+1./EPSP2-1./EPSP1 -C
     *2*LOG(EPS2*EPSP1/(EPS1*EPSP2)))
      RETURN
      END
      real*4 FUNCTION BHABTM(E0)
      implicit none
      real*4 E0,BHABRM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      IF ((E0.LE.AEP)) THEN
        BHABTM=0.
      ELSE
        BHABTM=BHABRM(E0,AEP,E0)
      END IF
      RETURN
      END
      real*4 FUNCTION BHABRM(EN0,EN1,EN2)
      implicit none
      real*4 EN0,EN1,EN2
      real*4 T0,T1,T2,TM,EM,Y,BETASI,CBHAB2,B1,B2,B3,B4,EPS1,EPS2
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      T0=EN0-RMP
      T1=EN1-RMP
      T2=EN2-RMP
      TM=T0/RMP
      EM=TM+1.
      Y=1./(TM+2.)
      BETASI=1./(1.-1./EM**2)
      CBHAB2=RLCP*EDEN*2.*PIP*R0**2/TM
      B1=2.-Y**2
      B2=3.-Y*(6.-Y*(1.-Y*2.))
      B3=2.-Y*(10.-Y*(16.-Y*8.))
      B4=1.-Y*(6.-Y*(12.-Y*8.))
      EPS1=T1/T0
      EPS2=T2/T0
      BHABRM=CBHAB2*(BETASI*(1./EPS1-1./EPS2)-B1*LOG(EPS2/EPS1) +B2*(EPS
     *2-EPS1)+EPS2*EPS2*(EPS2*B4/3.-0.5*B3) - EPS1*EPS1*(EPS1*B4/3.-0.5*
     *B3))
      RETURN
      END
      real*4 FUNCTION ANIHTM(E0)
      implicit none
      real*4 E0
      real*4 GAM,P0P2,P0P,CANIH
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      GAM=E0/RMP
      P0P2=GAM*GAM-1.0
      P0P=SQRT(P0P2)
      CANIH=RLCP*EDEN*PIP*R0**2/(GAM+1.)
      ANIHTM=CANIH*((GAM*GAM+4.*GAM+1.)/P0P2*LOG(GAM+P0P) -(GAM+3.)/P0P)
      RETURN
      END
      real*4 FUNCTION SPTOTP(E0,EE,EG)
      implicit none
      real*4 E0,EE,EG
      real*4 SPIONP,BRMSTM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      IF ((IUNRSTP.EQ.0)) THEN
        SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.1)) THEN
        SPTOTP=SPIONP(E0,E0)
      ELSE IF((IUNRSTP.EQ.2)) THEN
        SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.3)) THEN
        SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.4)) THEN
        SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.5)) THEN
        SPTOTP=BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.6)) THEN
        SPTOTP=BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.7)) THEN
        SPTOTP=SPIONP(E0,EE)
      END IF
      RETURN
      END
      real*4 FUNCTION SPTOTE(E0,EE,EG)
      implicit none
      real*4 E0,EE,EG
      real*4 SPIONE,BRMSTM
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      IF ((IUNRSTP.EQ.0)) THEN
        SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.1)) THEN
        SPTOTE=SPIONE(E0,E0)
      ELSE IF((IUNRSTP.EQ.2)) THEN
        SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.3)) THEN
        SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.4)) THEN
        SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.5)) THEN
        SPTOTE=BRMSTM(E0,E0)
      ELSE IF((IUNRSTP.EQ.6)) THEN
        SPTOTE=BRMSTM(E0,EG)
      ELSE IF((IUNRSTP.EQ.7)) THEN
        SPTOTE=SPIONE(E0,EE)
      END IF
      RETURN
      END
      real*4 FUNCTION SPIONE(E0,EE)
      implicit none
      real*4 E0,EE,SPIONB
      SPIONE=SPIONB(E0,EE,.FALSE.)
      RETURN
      END
      real*4 FUNCTION SPIONB(E0,EE,POSITR)
      implicit none
      real*4 E0,EE
      LOGICAL POSITR
      real*4 G,EEM,T,ETA2,BETA2,ALETA2,X,D,FTERM,TP2,D2,D3,D4,DELTA
      integer*4 I
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/LSPION/CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      real*4 CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20), EPSTTL,NEPST,IEPST
     *,EPSTFLP, NELEPS,ZEPST(20),IAPRFL,IAPRIMP
      integer*4 ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP
      CHARACTER EPSTTL*80
      real*4 EPSTEN,EPSTD,WEPST
      G=E0/RMP
      EEM=EE/RMP-1.
      T=G-1
      ETA2=T*(G+1.)
      BETA2=ETA2/G**2
      ALETA2=LOG(ETA2)
      X=0.21715*ALETA2
      IF ((.NOT.POSITR)) THEN
        D=AMIN1(EEM,0.5*T)
        FTERM=-1.-BETA2+LOG((T-D)*D)+T/(T-D) +(D*D/2.+(2.*T+1.)*LOG(1.-D
     *  /T))/(G*G)
      ELSE
        D=AMIN1(EEM,T)
        TP2=T+2.
        D2=D*D
        D3=D*D2
        D4=D*D3
        FTERM=LOG(T*D)-(BETA2/T)*( T + 2.*D - (3.*D2/2.)/TP2 -(D-D3/3.)/
     *  (TP2*TP2)-(D2/2.-T*D3/3.+D4/4.)/TP2**3)
      END IF
      IF ((EPSTFLP .EQ. 0)) THEN
        IF ((X.LE.X0)) THEN
          DELTA=0.0
        ELSE IF((X.LT.X1)) THEN
          DELTA=TOLN10*X - CBAR + AFACT*(X1 - X)**SK
        ELSE
          DELTA=TOLN10*X - CBAR
        END IF
      ELSE
        IF ((E0 .GE. EPSTEN(IEPST))) THEN
          IF ((E0 .EQ. EPSTEN(IEPST))) THEN
            GO TO 10040
          END IF
          DO 10051 I=IEPST,NEPST-1
            IF ((E0.LT.EPSTEN(I+1))) THEN
              IEPST = I
              GO TO 10040
            END IF
10051     CONTINUE
10052     CONTINUE
          IEPST = NEPST
          GO TO 10040
        ELSE
          DO 10061 I=IEPST,2,-1
            IF ((E0 .GE. EPSTEN(I-1))) THEN
              IEPST = I-1
              GO TO 10040
            END IF
10061     CONTINUE
10062     CONTINUE
          IEPST = 1
        END IF
10040   IF ((IEPST .LT. NEPST)) THEN
          DELTA = EPSTD(IEPST) + (E0 - EPSTEN(IEPST))/ (EPSTEN(IEPST+1)
     *    - EPSTEN(IEPST)) * (EPSTD(IEPST+1) - EPSTD(IEPST))
        ELSE
          DELTA = EPSTD(NEPST)
        END IF
      END IF
      SPIONB=(SPC1/BETA2)*(LOG(T + 2.) - SPC2 + FTERM - DELTA)
      RETURN
      END
      real*4 FUNCTION SPIONP(E0,EE)
      implicit none
      real*4 E0,EE,SPIONB
      SPIONP=SPIONB(E0,EE,.TRUE.)
      RETURN
      END
      real*4 FUNCTION BRMSTM(E0,EG)
      implicit none
      real*4 E0,EG,BRMSRM,AU,zero
      parameter (zero=0)
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      IF ((E0.LE.RMP)) THEN
        BRMSTM=0.
      ELSE
        AU=AMIN1(EG,E0-RMP)
        BRMSTM=BRMSRM(E0,zero,AU)
      END IF
      RETURN
      END
      real*4 FUNCTION BRMSRM(E,K1,K2)
      implicit none
      real*4 E,K1,K2,BRMSRZ
      integer*4 I
      COMMON/MIXDAT/NEP,LMED,PZP(50),ZELEMP(50),WAP(50),RHOZP(50), GASPP
     *,EZ,TPZ,IDSTRN(24)
      integer*4 NEP,LMED
      real*4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ
      CHARACTER*4 IDSTRN
      BRMSRM=0.
      DO 10071 I=1,NEP
        BRMSRM=BRMSRM+PZP(I)*BRMSRZ(ZELEMP(I),E,K1,K2)
10071 CONTINUE
10072 CONTINUE
      RETURN
      END
      real*4 FUNCTION BRMSRZ(Z,E,K1,K2)
      implicit none
      real*4 Z,E,K1,K2
      EXTERNAL BRMSFZ
      real*4 DUMMY,BRMSDZ,QD,BRMSFZ
      DUMMY=BRMSDZ(Z,E,K1)
      BRMSRZ=QD(BRMSFZ,K1,K2,'BRMSFZ')
      RETURN
      END
      real*4 FUNCTION BRMSDZ(Z,EA,K)
      implicit none
      real*4 Z,EA,K
      real*4 APRIM,XSIFP,FCOULCP,BRMSFZ
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/LBREMZ/CONST,DELC,EBREMZ,DELTAM,XLNZ
      real*4 CONST,DELC,EBREMZ,DELTAM,XLNZ
      EBREMZ=EA
      DELC=136.*Z**(-1./3.)*RMP/EBREMZ
      CONST=APRIM(Z,EBREMZ)*(AN*RHOP/WM)*R0**2*FSC*Z*(Z+XSIFP(Z))*RLCP
      XLNZ=4./3.*LOG(Z)
      IF((EBREMZ.GE.50))XLNZ=XLNZ+4.*FCOULCP(Z)
      DELTAM=EXP((21.12-XLNZ)/4.184)-0.952
      BRMSDZ=BRMSFZ(K)
      RETURN
      END
      real*4 FUNCTION APRIM(Z,E)
      implicit none
      real*4 Z,E
      integer*4 napre,naprz,ie,iz,aprim_unit,egs_get_unit,lnblnk1
      real*4 EM,AINTP
      character aprim_file*256
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20), EPSTTL,NEPST,IEPST
     *,EPSTFLP, NELEPS,ZEPST(20),IAPRFL,IAPRIMP
      integer*4 ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP
      CHARACTER EPSTTL*80
      real*4 EPSTEN,EPSTD,WEPST
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*4 APRIMD(115,14),EPRIM(115),ZPRIM(14),APRIMZ(115)
      DATA APRIMD/ 1.32,1.26,1.18,1.13,1.09,1.07,1.05,1.04,1.03, 1.02,8*
     *1.0, 97*0.0, 1.34,1.27,1.19,1.13,1.09,1.07,1.05,1.04,1.03,1.02, 8*
     *1.0, 97*0.0, 1.39,1.30,1.21,1.14,1.10,1.07,1.05,1.04,1.03,1.02,0.9
     *94, 2*0.991,0.990,2*0.989,2*0.988, 97*0.0, 1.46,1.34,1.23,1.15,1.1
     *1,1.08, 1.06,1.05,1.03,1.02,0.989, 0.973,0.971,0.969,0.967,0.965,2
     **0.963, 97*0.0, 1.55,1.40,1.26,1.17,1.12,1.09,1.07,1.05,1.03,1.02,
     *0.955,0.935, 0.930,0.925,0.920,0.915,2*0.911, 97*0.0,  1035*0.0/,
     *EPRIM / 2.,3.,4.,5.,6.,7.,8.,9.,10.,11.,21.,31.,41.,51.,61.,71.,81
     *.,91.,  97*0.0/, ZPRIM /6.,13.,29.,50.,79., 9*0.0/
      save APRIMD,EPRIM,ZPRIM,APRIMZ,napre,naprz
      IF ((IAPRIMP.EQ.0)) THEN
        IF ((IAPRFL .EQ. 0)) THEN
          IAPRFL=1
        END IF
        IF ((E.GE.50)) THEN
          APRIM=1.
        ELSE
          EM=E/RMP
          DO 10081 IE=1,18
            APRIMZ(IE)= AINTP(Z,ZPRIM,5,APRIMD(IE,1),115,.FALSE.,.FALSE.
     *      )
10081     CONTINUE
10082     CONTINUE
          APRIM=AINTP(EM,EPRIM,18,APRIMZ,1,.FALSE.,.FALSE.)
        END IF
      ELSE IF((IAPRIMP.EQ.1)) THEN
        IF ((IAPRFL.EQ.0)) THEN
          aprim_file = hen_house(:lnblnk1(hen_house)) // 'pegs4' // '/'
     *    // 'aprime.data'
          aprim_unit=22
          aprim_unit=egs_get_unit(aprim_unit)
          IF (( aprim_unit .LT. 1 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'APRIM: failed to get a free fortran unit'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(aprim_unit,file=aprim_file,status='old',err=10090)
          READ(aprim_unit,*) NAPRZ, NAPRE
          IF ((NAPRZ.GT.14)) THEN
            WRITE(6,10100)
10100       FORMAT(//,' TOO MANY ELEMENTS FOR APRIME INTERPOLATION:', /,
     *'   CHANGE $NAPRZ AND RECOMPILE PEGS')
            call exit(24)
          END IF
          IF ((NAPRE.GT.115)) THEN
            WRITE(6,10110)
10110       FORMAT(//,' TOO MANY ENERGIES FOR APRIME INTERPOLATION:', /,
     *'   CHANGE $NAPRE AND RECOMPILE PEGS')
            call exit(24)
          END IF
          READ(aprim_unit,*) (EPRIM(IE),IE=1,NAPRE)
          DO 10121 IE=1,NAPRE
            EPRIM(IE)=1.+EPRIM(IE)/RMP
10121     CONTINUE
10122     CONTINUE
          DO 10131 IZ=1,NAPRZ
            READ(aprim_unit,*)ZPRIM(IZ),(APRIMD(IE,IZ),IE=1,NAPRE)
10131     CONTINUE
10132     CONTINUE
          IAPRFL=1
          close(aprim_unit)
        END IF
        EM=E/RMP
        DO 10141 IE=1,NAPRE
          APRIMZ(IE)= AINTP(Z,ZPRIM,NAPRZ,APRIMD(IE,1),115,.TRUE.,.FALSE
     *    .)
10141   CONTINUE
10142   CONTINUE
        APRIM=AINTP(EM,EPRIM,NAPRE,APRIMZ,1,.FALSE.,.FALSE.)
      ELSE IF((IAPRIMP.EQ.2)) THEN
        IF ((IAPRFL .EQ. 0)) THEN
          IAPRFL=1
        END IF
        APRIM=1.0
      ELSE
        WRITE(6,10150)IAPRIMP
10150   FORMAT(//,' ILLEGAL VALUE FOR IAPRIM: ',I4)
        call exit(24)
      END IF
      RETURN
10090 write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Cannot open file $HEN_HOUSE/pegs4/aprime.data'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      RETURN
      END
      real*4 FUNCTION AINTP(X,XA,NX,YA,ISK,XLOG,YLOG)
      implicit none
      integer*4 NX,ISK
      real*4 X
      real*4 XA(NX),YA(ISK,NX)
      LOGICAL XLOG,YLOG,XLOGL
      integer*4 I,J
      real*4 XI,XJ,XV,YI,YJ
      XLOGL=XLOG
      DO 10161 J=2,NX
        IF((X.LT.XA(J)))GO TO 10170
10161 CONTINUE
10162 CONTINUE
      J=NX
10170 I=J-1
      IF ((XA(I).LE.0.0)) THEN
        XLOGL=.FALSE.
      END IF
      IF ((.NOT.XLOGL)) THEN
        XI=XA(I)
        XJ=XA(J)
        XV=X
      ELSE
        XI=LOG(XA(I))
        XJ=LOG(XA(J))
        XV=LOG(X)
      END IF
      IF ((YLOG.AND.(YA(1,I).EQ.0.0.OR.YA(1,J).EQ.0.0))) THEN
        AINTP=0.0
      ELSE
        IF ((YLOG)) THEN
          YI=LOG(YA(1,I))
          YJ=LOG(YA(1,J))
          IF ((XJ.EQ.XI)) THEN
            AINTP=YI
          ELSE
            AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI)
          END IF
          AINTP=EXP(AINTP)
        ELSE
          YI=YA(1,I)
          YJ=YA(1,J)
          IF ((XJ.EQ.XI)) THEN
            AINTP=YI
          ELSE
            AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI)
          END IF
        END IF
      END IF
      RETURN
      END
      real*4 FUNCTION TMXS(E)
      implicit none
      real*4 E,TMXB
      real*4 SAFETY,TABSMX
      DATA SAFETY/0.8/,TABSMX/10.0/
      save SAFETY,TABSMX
      TMXS=AMIN1(TMXB(E)*SAFETY,TABSMX)
      RETURN
      END
      real*4 FUNCTION TMXB(E)
      implicit none
      real*4 E
      real*4 ESQ,BETA2,PX2
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      ESQ=E**2
      BETA2=1.0-RMPSQ/ESQ
      PX2=ESQ*BETA2/XCCP**2
      TMXB=PX2*BETA2/LOG(BLCCP*PX2)
      RETURN
      END
      real*4 FUNCTION ALKE(E)
      implicit none
      real*4 E
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      ALKE=LOG(E-RMP)
      RETURN
      END
      real*4 FUNCTION ALKEI(X)
      implicit none
      real*4 x
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      ALKEI=EXP(X) + RMP
      RETURN
      END
      SUBROUTINE PWLF1(NI,NIMX,XL,XU,XR,EP,ZTHR,ZEP,NIP,XFUN,XFI, AX,BX,
     *NALM,NFUN,AF,BF,VFUNS)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 NI,NIMX,NIP,NALM,NFUN
      real*4 XL,XU,XR,EP,AX,BX,XFUN,XFI
      EXTERNAL XFI,VFUNS,XFUN
      real*4 AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN)
      LOGICAL QFIT
      integer*4 NL,NU,IPRN,NJ,NK
      real*4 REM
      NL=0
      NU=1
      IPRN=0
10181 CONTINUE
        NJ=MIN0(NU,NIMX)
        IF((QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI, AX,BX,NALM,NF
     *  UN,AF,BF,VFUNS,0)))GO TO10182
        IF ((NU.GE.NIMX)) THEN
          NI=NJ
          RETURN
        END IF
        NL=NU
        NU=NU*2
      GO TO 10181
10182 CONTINUE
      NU=NJ
10191 IF(NU.LE.NL+1)GO TO 10192
        NJ=(NL+NU)/2
        NK=NJ
        IF ((QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI, AX,BX,NALM,N
     *  FUN,AF,BF,VFUNS,0))) THEN
          NU=NJ
        ELSE
          NL=NK
        END IF
      GO TO 10191
10192 CONTINUE
      NI=NU
      IF((NI.EQ.NJ))RETURN
      IF((.NOT.QFIT(NI,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI, AX,BX,NALM
     *,NFUN,AF,BF,VFUNS,0)))WRITE(6,10200)NI
10200 FORMAT(' CATASTROPHE---DOES NOT FIT WHEN IT SHOULD,NI=',I5)
      RETURN
      END
      LOGICAL FUNCTION QFIT(NJ,XL,XH,XR,EP,ZTHR,ZEP,REM,NJP,XFUN,XFI, AX
     *,BX,NALM,NFUN,AF,BF,VFUNS,IPRN)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      EXTERNAL VFUNS
      real*4 XFUN,XFI
      integer*4 NJ,NALM,NFUN,NJP,IPRN
      real*4 XL,XH,XR,AX,BX,REM,EP
      real*4 FSXL(10),FSXH(10),FIP(10),FFIP(10),AFIP(10),RE(10),AER(10)
      real*4 AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN)
      real*4 XS,XFL,XFH,XFS,XM,DX,W,XLL,SXFL,XSXF,SXFH,DSXF,WIP, SXFIP,X
     *IP
      integer*4 NI,NIP,ISUB,IFUN,JSUB,IP
      integer*4 nkp
      DATA NKP/3/
      save nkp
      IF ((XH.LE.XL)) THEN
        WRITE(6,10210)XL,XH
10210   FORMAT(' QFIT ERROR:XL SHOULD BE < XH. XL,XH=',2G14.6)
        QFIT=.FALSE.
        RETURN
      END IF
      XS=AMAX1(XL,AMIN1(XH,XR))
      NI=NJ-2
      IF ((((XS.EQ.XL.OR.XS.EQ.XH).AND.NI.GE.1).OR.NI.GE.2)) THEN
        XFL=XFUN(XL)
      ELSE
        QFIT=.FALSE.
        RETURN
      END IF
      XFH=XFUN(XH)
      XFS=XFUN(XS)
      XM=AMAX1(XFH-XFS,XFS-XFL)
      DX=XFH-XFL
      W=XM/AMAX1(1.,AINT(NI*XM/DX))
      NI=NI-AINT(NI-DX/W)
      NIP=MAX0(NKP,(NJP+NI-1)/NI)
      NIP=(NIP/2)*2+1
      IF ((XFH-XFS.LE.XFS-XFL)) THEN
        XLL=XFL
      ELSE
        XLL=XFH-NI*W
      END IF
      AX=1./W
      BX=2.-XLL*AX
      REM=0.0
      QFIT=.TRUE.
      SXFL=AMAX1(XLL,XFL)
      ISUB=0
      XSXF=XFI(SXFL)
      CALL VFUNS(XSXF,FSXL)
      IF((IPRN.NE.0))WRITE(6,1570) ISUB,SXFL,XSXF,(FSXL(IFUN),IFUN=1,NFU
     *N)
1570  FORMAT(' QFIT:ISUB,SXF,XSXF,FSX()=',I4,1P,9G11.4/(1X,12G11.4))
      DO 10221 ISUB=1,NI
        JSUB=ISUB+1
        SXFH=AMIN1(XLL+W*ISUB,XH)
        XSXF=XFI(SXFH)
        CALL VFUNS(XSXF,FSXH)
        IF((IPRN.NE.0))WRITE(6,1570)ISUB,SXFH,XSXF,(FSXH(IFUN),IFUN=1,NF
     *  UN)
        DSXF=SXFH-SXFL
        DO 10231 IFUN=1,NFUN
          AF(JSUB,IFUN)=(FSXH(IFUN)-FSXL(IFUN))/DSXF
          BF(JSUB,IFUN)=(FSXL(IFUN)*SXFH-FSXH(IFUN)*SXFL)/DSXF
10231   CONTINUE
10232   CONTINUE
        WIP=DSXF/(NIP+1)
        DO 10241 IP=1,NIP
          SXFIP=SXFL+IP*WIP
          XIP=XFI(SXFIP)
          CALL VFUNS(XIP,FIP)
          DO 10251 IFUN=1,NFUN
            FFIP(IFUN)=AF(JSUB,IFUN)*SXFIP+BF(JSUB,IFUN)
            AFIP(IFUN)=ABS(FIP(IFUN))
            AER(IFUN)=ABS(FFIP(IFUN)-FIP(IFUN))
            RE(IFUN)=0.0
            IF ((FIP(IFUN).NE.0.0)) THEN
              RE(IFUN)=AER(IFUN)/AFIP(IFUN)
            END IF
            IF ((AFIP(IFUN).GE.ZTHR(IFUN))) THEN
              REM=AMAX1(REM,RE(IFUN))
            ELSE IF((AER(IFUN).GT.ZEP(IFUN))) THEN
              QFIT=.FALSE.
            END IF
10251     CONTINUE
10252     CONTINUE
          IF ((IPRN.NE.0)) THEN
            WRITE(6,10260)ISUB,IP,SXFIP,XIP,REM,QFIT,(FIP(IFUN),FFIP(IFU
     *      N), RE(IFUN),AER(IFUN),IFUN=1,NFUN)
10260       FORMAT(1X,2I4,1P,2G12.5,6P,F12.0,L2,1P,2G11.4,6P,F11.0,1P,G1
     *1.4/ (1X,3(1P,2G11.4,6P,F11.0,1P,G11.4)))
          END IF
10241   CONTINUE
10242   CONTINUE
        SXFL=SXFH
        DO 10271 IFUN=1,NFUN
          FSXL(IFUN)=FSXH(IFUN)
10271   CONTINUE
10272   CONTINUE
10221 CONTINUE
10222 CONTINUE
      DO 10281 IFUN=1,NFUN
        AF(1,IFUN)=AF(2,IFUN)
        BF(1,IFUN)=BF(2,IFUN)
        AF(NI+2,IFUN)=AF(NI+1,IFUN)
        BF(NI+2,IFUN)=BF(NI+1,IFUN)
10281 CONTINUE
10282 CONTINUE
      QFIT=QFIT.AND.REM.LE.EP
      NJ=NI+2
      RETURN
      END
      real*4 FUNCTION QD(F,A,B,MSG)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*4 A,B,F
      EXTERNAL F
      CHARACTER*6 MSG
      logical first_time
      data first_time/.true./
      save first_time
      real*4 DCADRE,ADUM,BDUM,ERRDUM
      integer*4 IER
      ADUM=A
      BDUM=B
      QD=DCADRE(F,ADUM,BDUM,1.E-16,1.E-5,ERRDUM,IER)
      IF ((IER.GT.66)) THEN
        WRITE(6,10290)IER,MSG,A,B,QD,ERRDUM
10290   FORMAT(' DCADRE CODE=',I4,' FOR INTEGRAL ',A6,' FROM ',1P,G14.6,
     *' TO ',G14.6, ',QD=',G14.6,'+-',G14.6)
      END IF
      RETURN
      END
      real*4 FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER)
      implicit none
      DIMENSION T(10,10),R(10),AIT(10),DIF(10),RN(4),TS(2049)
      DIMENSION IBEGS(30),BEGIN(30),FINIS(30),EST(30)
      DIMENSION REGLSV(30)
      LOGICAL H2CONV,AITKEN,RIGHT,REGLAR,REGLSV
      real*4 T,R,AIT,DIF,RN,TS,BEGIN,FINIS,EST,AITLOW
      real*4 H2TOL,AITTOL,LENGTH,JUMPTL,ZERO,P1,HALF,ONE
      real*4 TWO,FOUR,FOURP5,TEN,HUN,CADRE,ERROR,A,B
      real*4 AERR,RERR,STEPMN,STEPNM,STAGE,CUREST,FNSIZE
      real*4 PREVER,BEG,FBEG,END,FEND,STEP,ASTEP,TABS,HOVN
      real*4 FN,SUM,SUMABS,ABSI,VINT,TABTLM,ERGL,ERGOAL
      real*4 ERRA,ERRR,FEXTRP,ERRER,DIFF,SING,FEXTM1,ALG4O2
      real*4 H2NXT,SINGNX,SLOPE,FBEG2,ALPHA
      real*4 ERRET,H2TFEX,FI
      real*4 RVAL,F
      integer*4 IBEGS,IER,ISTAGE,IBEG,IEND,L,N,LM1,N2,ISTEP,II,III,I,IST
     *EP2,IT,NNLEFT
      integer*4 MAXTS,MAXTBL,MXSTGE
      DATA AITLOW,H2TOL,AITTOL,JUMPTL,MAXTS,MAXTBL,MXSTGE/1.1D0,.15D0, .
     *1D0,.01D0,2049,10,30/
      DATA RN(1),RN(2),RN(3),RN(4)/.7142005D0,.3466282D0,.843751D0, .126
     *3305D0/
      DATA ZERO,P1,HALF,ONE,TWO,FOUR,FOURP5,TEN,HUN/0.0D0,0.1D0,0.5D0, 1
     *.0D0,2.0D0,4.0D0,4.5D0,10.0D0,100.0D0/
      save MAXTS,MAXTBL,MXSTGE
      ALG4O2=LOG10(TWO)
      CADRE=ZERO
      ERROR=ZERO
      CUREST=ZERO
      VINT=ZERO
      IER=0
      LENGTH=ABS(B-A)
      IF((LENGTH.EQ.ZERO))GO TO 215
      IF((RERR.GT.P1.OR.RERR.LT.ZERO))GO TO 210
      IF((AERR.EQ.ZERO.AND.(RERR+HUN).LE.HUN))GO TO 210
      ERRR=RERR
      ERRA=ABS(AERR)
      STEPMN=(LENGTH/FLOAT(2**MXSTGE))
      STEPNM=DMAX1(LENGTH,ABS(A),ABS(B))*TEN
      STAGE=HALF
      ISTAGE=1
      FNSIZE=ZERO
      PREVER=ZERO
      REGLAR=.FALSE.
      BEG=A
      RVAL=BEG
      FBEG=F(RVAL)*HALF
      TS(1)=FBEG
      IBEG=1
      END=B
      RVAL=END
      FEND=F(RVAL)*HALF
      TS(2)=FEND
      IEND=2
5     RIGHT=.FALSE.
10    STEP=END - BEG
      ASTEP=ABS(STEP)
      IF((ASTEP.LT.STEPMN))GO TO 205
      IF((STEPNM+ASTEP.EQ.STEPNM))GO TO 205
      T(1,1)=FBEG + FEND
      TABS=ABS(FBEG) + ABS(FEND)
      L=1
      N=1
      H2CONV=.FALSE.
      AITKEN=.FALSE.
15    LM1=L
      L=L + 1
      N2=N + N
      FN=N2
      ISTEP=(IEND - IBEG)/N
      IF((ISTEP.GT.1))GO TO 25
      II=IEND
      IEND=IEND + N
      IF((IEND.GT.MAXTS))GO TO 200
      HOVN=STEP/FN
      III=IEND
      FI=ONE
      DO 10301 I=1,N2,2
        TS(III)=TS(II)
        RVAL=END-FI*HOVN
        TS(III-1)=F(RVAL)
        FI=FI+TWO
        III=III-2
        II=II-1
10301 CONTINUE
10302 CONTINUE
      ISTEP=2
25    ISTEP2=IBEG + ISTEP/2
      SUM=ZERO
      SUMABS=ZERO
      DO 10311 I=ISTEP2,IEND,ISTEP
        SUM=SUM + TS(I)
        SUMABS=SUMABS + ABS(TS(I))
10311 CONTINUE
10312 CONTINUE
      T(L,1)=T(L-1,1)*HALF+SUM/FN
      TABS=TABS*HALF+SUMABS/FN
      ABSI=ASTEP*TABS
      N=N2
      IT=1
      VINT=STEP*T(L,1)
      TABTLM=TABS*TEN
      FNSIZE=DMAX1(FNSIZE,ABS(T(L,1)))
      ERGL=ASTEP*FNSIZE*TEN
      ERGOAL=STAGE*DMAX1(ERRA,ERRR*ABS(CUREST+VINT))
      FEXTRP=ONE
      DO 10321 I=1,LM1
        FEXTRP=FEXTRP*FOUR
        T(I,L)=T(L,I) - T(L-1,I)
        T(L,I+1)=T(L,I) + T(I,L)/(FEXTRP-ONE)
10321 CONTINUE
10322 CONTINUE
      ERRER=ASTEP*ABS(T(1,L))
      IF((L.GT.2))GO TO 40
      IF((TABS+P1*ABS(T(1,2)).EQ.TABS))GO TO 135
      GO TO 15
40    DO 45 I=2,LM1
      DIFF=ZERO
      IF((TABTLM+ABS(T(I-1,L)).NE.TABTLM))DIFF=T(I-1,LM1)/T(I-1,L)
      T(I-1,LM1)=DIFF
45    CONTINUE
      IF((ABS(FOUR-T(1,LM1)).LE.H2TOL))GO TO 60
      IF((T(1,LM1).EQ.ZERO))GO TO 55
      IF((ABS(TWO-ABS(T(1,LM1))).LT.JUMPTL))GO TO 130
      IF((L.EQ.3))GO TO 15
      H2CONV=.FALSE.
      IF((ABS((T(1,LM1)-T(1,L-2))/T(1,LM1)).LE.AITTOL))GO TO 75
50    IF(REGLAR) GO TO 55
      IF((L.EQ.4))GO TO 15
55    IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 175
      GO TO 145
60    IF(H2CONV) GO TO 65
      AITKEN=.FALSE.
      H2CONV=.TRUE.
65    FEXTRP=FOUR
70    IT=IT + 1
      VINT=STEP*T(L,IT)
      ERRER=ABS(STEP/(FEXTRP-ONE)*T(IT-1,L))
      IF((ERRER.LE.ERGOAL))GO TO 160
      IF((ERGL+ERRER.EQ.ERGL))GO TO 160
      IF((IT.EQ.LM1))GO TO 125
      IF((T(IT,LM1).EQ.ZERO))GO TO 70
      IF((T(IT,LM1).LE.FEXTRP))GO TO 125
      IF((ABS(T(IT,LM1)/FOUR-FEXTRP)/FEXTRP.LT.AITTOL))FEXTRP=FEXTRP*FOU
     *R
      GO TO 70
75    IF(T(1,LM1).LT.AITLOW) GO TO 175
      IF((AITKEN))GO TO 80
      H2CONV=.FALSE.
      AITKEN=.TRUE.
80    FEXTRP=T(L-2,LM1)
      IF((FEXTRP.GT.FOURP5))GO TO 65
      IF((FEXTRP.LT.AITLOW))GO TO 175
      IF((ABS(FEXTRP-T(L-3,LM1))/T(1,LM1).GT.H2TOL))GO TO 175
      SING=FEXTRP
      FEXTM1=ONE/(FEXTRP - ONE)
      AIT(1)=ZERO
      DO 85 I=2,L
      AIT(I)=T(I,1) + (T(I,1)-T(I-1,1))*FEXTM1
      R(I)=T(1,I-1)
      DIF(I)=AIT(I) - AIT(I-1)
85    CONTINUE
      IT=2
90    VINT=STEP*AIT(L)
      ERRER=ERRER*FEXTM1
      IF((ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL))GO TO 95
      ALPHA=LOG10(SING)/ALG4O2 - ONE
      IER=MAX0(IER,65)
      GO TO 160
95    IT=IT + 1
      IF((IT.EQ.LM1))GO TO 125
      IF((IT.GT.3))GO TO 100
      H2NXT=FOUR
      SINGNX=SING+SING
100   IF(H2NXT.LT.SINGNX) GO TO 105
      FEXTRP=SINGNX
      SINGNX=SINGNX+SINGNX
      GO TO 110
105   FEXTRP=H2NXT
      H2NXT=FOUR*H2NXT
110   DO 115 I=IT,LM1
      R(I+1)=ZERO
      IF((TABTLM+ABS(DIF(I+1)).NE.TABTLM))R(I+1)=DIF(I)/DIF(I+1)
115   CONTINUE
      H2TFEX=-H2TOL*FEXTRP
      IF((R(L)-FEXTRP.LT.H2TFEX))GO TO 125
      IF((R(L-1)-FEXTRP.LT.H2TFEX))GO TO 125
      ERRER=ASTEP*ABS(DIF(L))
      FEXTM1=ONE/(FEXTRP - ONE)
      DO 120 I=IT,L
      AIT(I)=AIT(I) + DIF(I)*FEXTM1
      DIF(I)=AIT(I) - AIT(I-1)
120   CONTINUE
      GO TO 90
125   FEXTRP=DMAX1(PREVER/ERRER,AITLOW)
      PREVER=ERRER
      IF((L.LT.5))GO TO 15
      IF((L-IT.GT.2.AND.ISTAGE.LT.MXSTGE))GO TO 170
      ERRET=ERRER/(FEXTRP**(MAXTBL-L))
      IF((ERRET.GT.ERGOAL.AND.(ERGL+ERRET).NE.ERGL))GO TO 170
      GO TO 15
130   IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 170
      DIFF=ABS(T(1,L))*(FN+FN)
      GO TO 160
135   SLOPE=(FEND-FBEG)*TWO
      FBEG2=FBEG+FBEG
      DO 140 I=1,4
      RVAL=BEG+RN(I)*STEP
      DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE)
      IF((TABTLM+DIFF.NE.TABTLM))GO TO 155
140   CONTINUE
      GO TO 160
145   SLOPE=(FEND-FBEG)*TWO
      FBEG2=FBEG+FBEG
      I=1
150   RVAL=BEG+RN(I)*STEP
      DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE)
155   ERRER=DMAX1(ERRER,ASTEP*DIFF)
      IF((ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL))GO TO 175
      I=I+1
      IF((I.LE.4))GO TO 150
      IER=66
160   CADRE=CADRE + VINT
      ERROR=ERROR + ERRER
      IF((RIGHT))GO TO 165
      ISTAGE=ISTAGE - 1
      IF((ISTAGE.EQ.0))GO TO 220
      REGLAR=REGLSV(ISTAGE)
      BEG=BEGIN(ISTAGE)
      END=FINIS(ISTAGE)
      CUREST=CUREST - EST(ISTAGE+1) + VINT
      IEND=IBEG - 1
      FEND=TS(IEND)
      IBEG=IBEGS(ISTAGE)
      GO TO 180
165   CUREST=CUREST + VINT
      STAGE=STAGE+STAGE
      IEND=IBEG
      IBEG=IBEGS(ISTAGE)
      END=BEG
      BEG=BEGIN(ISTAGE)
      FEND=FBEG
      FBEG=TS(IBEG)
      GO TO 5
170   REGLAR=.TRUE.
175   IF(ISTAGE.EQ.MXSTGE) GO TO 205
      IF((RIGHT))GO TO 185
      REGLSV(ISTAGE+1)=REGLAR
      BEGIN(ISTAGE)=BEG
      IBEGS(ISTAGE)=IBEG
      STAGE=STAGE*HALF
180   RIGHT=.TRUE.
      BEG=(BEG+END)*HALF
      IBEG=(IBEG+IEND)/2
      TS(IBEG)=TS(IBEG)*HALF
      FBEG=TS(IBEG)
      GO TO 10
185   NNLEFT=IBEG - IBEGS(ISTAGE)
      IF((IEND+NNLEFT.GE.MAXTS))GO TO 200
      III=IBEGS(ISTAGE)
      II=IEND
      DO 190 I=III,IBEG
      II=II + 1
      TS(II)=TS(I)
190   CONTINUE
      DO 195 I=IBEG,II
      TS(III)=TS(I)
      III=III + 1
195   CONTINUE
      IEND=IEND + 1
      IBEG=IEND - NNLEFT
      FEND=FBEG
      FBEG=TS(IBEG)
      FINIS(ISTAGE)=END
      END=BEG
      BEG=BEGIN(ISTAGE)
      BEGIN(ISTAGE)=END
      REGLSV(ISTAGE)=REGLAR
      ISTAGE=ISTAGE + 1
      REGLAR=REGLSV(ISTAGE)
      EST(ISTAGE)=VINT
      CUREST=CUREST + EST(ISTAGE)
      GO TO 5
200   IER=131
      GO TO 215
205   IER=132
      GO TO 215
210   IER=133
215   CADRE=CUREST + VINT
220   DCADRE=CADRE
9000  CONTINUE
9005  RETURN
      END
      SUBROUTINE SPINIT(density_file)
      implicit none
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/SPCOMM/MEDTBL(24,73), NUMSTMED,STDATA(6,73)
      CHARACTER*4 MEDTBL
      integer*4 NUMSTMED
      real*4 STDATA
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6), DE
     *LCMP,ALPHIP(2),BPARP(2),DELPOSP(2)
      real*4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP
      COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100)
      integer*4 NET
      real*4 ITBL,WATBL,RHOTBL
      CHARACTER*4 ASYMT
      COMMON/LSPION/CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      real*4 CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20), EPSTTL,NEPST,IEPST
     *,EPSTFLP, NELEPS,ZEPST(20),IAPRFL,IAPRIMP
      integer*4 ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP
      CHARACTER EPSTTL*80
      real*4 EPSTEN,EPSTD,WEPST
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MIXDAT/NEP,LMED,PZP(50),ZELEMP(50),WAP(50),RHOZP(50), GASPP
     *,EZ,TPZ,IDSTRN(24)
      integer*4 NEP,LMED
      real*4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ
      CHARACTER*4 IDSTRN
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      real*4 IMEV
      integer*4 IM,J,IZ,IE,I,ICHECK,IESPEL,IPEGEL,density_unit,lnblnk1,e
     *gs_get_unit
      real*4 VPLASM,ALIADG,EDENL,ALGASP,EPSTRH, TLRNCE,EPSTWT
      CHARACTER*256 density_file
      TOLN10=2.0*LOG(10.0)
      IM=-100
      IF ((EPSTFLP .LT. 0 .OR. EPSTFLP .GT. 1)) THEN
        EPSTFLP = 0
      END IF
      IF ((EPSTFLP.EQ.0)) THEN
10330   CONTINUE
          DO 10331 IM=1,NUMSTMED
          DO 10341 J=1,LMED
            IF((IDSTRN(J).NE.MEDTBL(J,IM)))GO TO 10331
10341     CONTINUE
10342     CONTINUE
          AFACT=STDATA(1,IM)
          SK=STDATA(2,IM)
          X0=STDATA(3,IM)
          X1=STDATA(4,IM)
          IEV=STDATA(5,IM)
          CBAR=STDATA(6,IM)
          IMEV=IEV*1.0E-6
          VPLASM=SQRT(EDEN*R0*C**2/PIP)
          GO TO 10350
10331   CONTINUE
10332   CONTINUE
        IM=0
        IF ((NEP.EQ.1)) THEN
          IZ=ZELEMP(1)
          IF ((IZ.EQ.1.OR.IZ.EQ.7.OR.IZ.EQ.8)) THEN
            WRITE(6,10360)
10360       FORMAT(' STOPPED IN SUBROUTINE SPINIT BECAUSE THIS',/, ' ELE
     *MENT (H, N, OR O) CAN ONLY EXIST AS A DIATOMIC MOLECULE.',/, ' REM
     *EDY:  USE COMP OPTION FOR H2, N2, OR O2 WITH NE=2,PZ=1,1'/, '     
     *AND, IN THE CASE OF A GAS, DEFINE STERNHEIMER ID',/, '   (I.E., ID
     *STRN) LIKE H2-GAS')
            call exit(21)
          END IF
          IEV=ITBL(IZ)
        ELSE
          ALIADG=0.0
          DO 10371 IE=1,NEP
            IZ=ZELEMP(IE)
            IF ((IZ.EQ.1)) THEN
              IEV=19.2
            ELSE IF((IZ.EQ.6)) THEN
              IF ((GASPP.EQ.0.0)) THEN
                IEV=81.0
              ELSE
                IEV=70.0
              END IF
            ELSE IF((IZ.EQ.7)) THEN
              IEV=82.0
            ELSE IF((IZ.EQ.8)) THEN
              IF ((GASPP.EQ.0.0)) THEN
                IEV=106.0
              ELSE
                IEV=97.0
              END IF
            ELSE IF((IZ.EQ.9)) THEN
              IEV=112.0
            ELSE IF((IZ.EQ.17)) THEN
              IEV=180.0
            ELSE
              IEV=1.13*ITBL(IZ)
            END IF
            ALIADG=ALIADG + PZP(IE)*ZELEMP(IE)*LOG(IEV)
10371     CONTINUE
10372     CONTINUE
          ALIADG=ALIADG/ZC
          IEV=EXP(ALIADG)
        END IF
        IMEV=IEV*1.0E-6
        IF ((GASPP.EQ.0.0)) THEN
          EDENL=EDEN
        ELSE
          EDENL=EDEN/GASPP
        END IF
        VPLASM = SQRT(EDENL*R0*C**2/PIP)
        CBAR=1. + 2.*LOG(IMEV/(HBAR*2*PIP*VPLASM/ERGMEV))
        IF ((NEP.EQ.1.AND.INT(ZELEMP(1)).EQ.2.AND.GASPP.NE.0.0)) THEN
          X0=2.191
          X1=3.0
          SK=3.297
        ELSE IF((NEP.EQ.2.AND.INT(ZELEMP(1)).EQ.1 .AND.INT(ZELEMP(2)).EQ
     *  .1)) THEN
          IF ((GASPP.EQ.0.0)) THEN
            X0=0.425
            X1=2.0
            SK=5.949
          ELSE
            X0=1.837
            X1=3.0
            SK=4.754
          END IF
        ELSE
          SK=3.0
          IF ((GASPP.EQ.0.0)) THEN
            IF ((IEV.LT.100.0)) THEN
              IF ((CBAR.LT.3.681)) THEN
                X0=0.2
                X1=2.0
              ELSE
                X0=0.326*CBAR - 1.0
                X1=2.0
              END IF
            ELSE
              IF ((CBAR.LT.5.215)) THEN
                X0=0.2
                X1=3.0
              ELSE
                X0=0.326*CBAR - 1.5
                X1=3.0
              END IF
            END IF
            IF ((X0.GE.X1)) THEN
              WRITE(6,10380)X0,X1,CBAR
10380         FORMAT(' STOPPED IN SPINIT DUE TO X0.GE.X1 , X0,X1,CBAR=',
     *3G15.5,/ ,' IF THIS IS GAS, YOU MUST DEFINE GASP(ATM)')
              call exit(21)
            END IF
          ELSE
            IF ((CBAR.LT.10.0)) THEN
              X0=1.6
              X1=4.0
            ELSE IF((CBAR.LT.10.5)) THEN
              X0=1.7
              X1=4.0
            ELSE IF((CBAR.LT.11.0)) THEN
              X0=1.8
              X1=4.0
            ELSE IF((CBAR.LT.11.5)) THEN
              X0=1.9
              X1=4.0
            ELSE IF((CBAR.LT.12.25)) THEN
              X0=2.0
              X1=4.0
            ELSE IF((CBAR.LT.13.804)) THEN
              X0=2.0
              X1=5.0
            ELSE
              X0=0.326*CBAR - 2.5
              X1=5.0
            END IF
          END IF
        END IF
10350   IF ((GASPP.NE.0.0)) THEN
          ALGASP=LOG(GASPP)
          CBAR=CBAR - ALGASP
          X0=X0 - ALGASP/TOLN10
          X1=X1 - ALGASP/TOLN10
        END IF
        IF ((IM.EQ.0)) THEN
          AFACT=(CBAR - TOLN10*X0)/(X1 - X0)**SK
        END IF
      ELSE
        density_file=density_file(:lnblnk1(density_file))
        density_unit=20
        density_unit=egs_get_unit(density_unit)
        IF (( density_unit .LT. 1 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'SPINIT: failed to get a free fortran unit'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(density_unit,file=density_file,status='old',err=6630)
        READ(density_unit,2250)EPSTTL
2250    FORMAT(A)
        READ(density_unit,*) NEPST,IEV,EPSTRH,NELEPS
        READ(density_unit,*) (ZEPST(I),WEPST(I),I=1,NELEPS)
        READ(density_unit,*) (EPSTEN(I),EPSTD(I),I=1,NEPST)
        close(density_unit)
        IF ((NEPST.GT.150)) THEN
          WRITE(6,10390)NEPST
10390     FORMAT(//' *****NEPST=',I4,' IS GREATER THAN THE 150 ALLOWED')
          call exit(22)
        END IF
        DO 10401 I=1,NEPST
          EPSTEN(I) = EPSTEN(I) + RMP
10401   CONTINUE
10402   CONTINUE
        IMEV = IEV*1.E-06
        IF (( AEP .LT. EPSTEN(1))) THEN
          WRITE(6,10410)EPSTEN(1),AEP
10410     FORMAT(//' ****LOWEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,E
     *10.3/ T20,'WHICH IS HIGHER THAN THE VALUE OF AE=',1P,E10.3,' MEV'/
     * ' ***IT HAS BEEN SET TO AE***'//)
          EPSTEN(1) = AEP
        END IF
        IF (( UEP .GT. EPSTEN(NEPST))) THEN
          WRITE(6,10420)EPSTEN(NEPST),UEP
10420     FORMAT(//' ****HIGHEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,
     *E10.3/ T20,'WHICH IS LOWER THAN THE VALUE OF UE=',1P,E10.3,' MEV'/
     * ' ***IT HAS BEEN SET TO UE***'//)
          EPSTEN(NEPST) = UEP
        END IF
        ICHECK=0
        TLRNCE=0.01
        IF((NELEPS.NE.NEP))ICHECK=1
        IF(((ICHECK.EQ.0) .AND. ( (EPSTRH.LT.((1.0-TLRNCE)*RHOP)) .OR. (
     *  EPSTRH.GT.((1.0+TLRNCE)*RHOP)) )))ICHECK=1
        EPSTWT = 0.0
        DO 10431 I=1,NEP
          EPSTWT = EPSTWT + RHOZP(I)
10431   CONTINUE
10432   CONTINUE
        IF ((EPSTWT.EQ.0.0)) THEN
          WRITE(6,10440)
10440     FORMAT(//' *****IN SPINIT***SOMETHING WRONG, MOLECULAR WEIGHTO
     *F', 'MOLECULE IS ZERO (I.E. SUM OF RHOZ)***'//)
        END IF
        IF ((ICHECK.EQ.0)) THEN
          IESPEL=0
          ICHECK=1
10451     CONTINUE
            IESPEL=IESPEL+1
            IPEGEL=0
10461       CONTINUE
              IPEGEL=IPEGEL+1
              IF ((INT(ZELEMP(IPEGEL)).EQ.ZEPST(IESPEL))) THEN
                ICHECK=0
                GO TO10462
              END IF
              IF(IPEGEL.GE.NEP)GO TO10462
            GO TO 10461
10462       CONTINUE
            IF(((ICHECK.EQ.0)  .AND. ( (WEPST(IESPEL).LT.((1.0-TLRNCE)*R
     *      HOZP(IPEGEL)/EPSTWT)) .OR. (WEPST(IESPEL).GT.((1.0+TLRNCE)*R
     *      HOZP(IPEGEL)/EPSTWT)) )))ICHECK=1
            IF(IESPEL.GE.NELEPS)GO TO10452
          GO TO 10451
10452     CONTINUE
        END IF
        IF ((ICHECK.EQ.1)) THEN
          WRITE(6,10470)
10470     FORMAT(////'0*** COMPOSITION IN INPUT DENSITY FILE DOES NOT MA
     *TCH ', ' THAT BEING USED BY PEGS'//' ***** QUITTING EARLY***'////)
          call exit(23)
        END IF
      END IF
      SPC1=2.*PIP*R0**2*RMP*EDEN*RLCP
      SPC2=LOG((IMEV/RMP)**2/2.0)
      RETURN
6630  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' Failed to open density file ',density_file
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      RETURN
      END
      SUBROUTINE MIX
      implicit none
      integer*4 I,IZZ
      real*4 AL183,ZAB,V2000
      real*4 FCOULCP,XSIFP
      COMMON/MIMSD/BMIN
      real*4 BMIN
      COMMON/MIXDAT/NEP,LMED,PZP(50),ZELEMP(50),WAP(50),RHOZP(50), GASPP
     *,EZ,TPZ,IDSTRN(24)
      integer*4 NEP,LMED
      real*4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ
      CHARACTER*4 IDSTRN
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183
      real*4 ALRAD,ALRADP,A1440,A183
      COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6), DE
     *LCMP,ALPHIP(2),BPARP(2),DELPOSP(2)
      real*4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP
      real*4 XSI(20),ZZX(20),FZC(20),FCOUL(20),ZZ(20)
      IF ((GASPP.NE.0.0)) THEN
        RHOP=GASPP*RHOP
      END IF
      AL183 = LOG(A183)
      TPZ=0.0
      WM=0.0
      ZC=0.0
      ZT=0.0
      ZB=0.0
      ZF=0.0
      ZS=0.0
      ZE=0.0
      ZX=0.0
      ZAB=0.0
      DO 10481 I=1,NEP
        TPZ = TPZ + PZP(I)
        WM = WM + PZP(I)*WAP(I)
        ZC = ZC + PZP(I)*ZELEMP(I)
        FZC(I) =(FSC*ZELEMP(I))**2
        FCOUL(I) = FCOULCP(ZELEMP(I))
        XSI(I) = XSIFP (ZELEMP(I))
        ZZX(I) = PZP(I)*ZELEMP(I)*(ZELEMP(I)+XSI(I))
        IF ((ZELEMP(I).LE.4.0)) THEN
          IZZ=ZELEMP(I)
          ZAB=ZAB+ZZX(I)*ALRAD(IZZ)
        ELSE
          ZAB=ZAB+ZZX(I)*(AL183+LOG(ZELEMP(I)**(-1./3.)))
        END IF
        ZT = ZT + ZZX(I)
        ZB = ZB + ZZX(I)*LOG(ZELEMP(I)**(-1./3.))
        ZF = ZF + ZZX(I)*FCOUL(I)
        ZZ(I) = PZP(I)*ZELEMP(I)*(ZELEMP(I)+1.0)
        ZS = ZS + ZZ(I)
        ZE = ZE + ZZ(I)*((-2./3.)*LOG(ZELEMP(I)))
        ZX = ZX + ZZ(I)*LOG(1.+3.34*FZC(I))
10481 CONTINUE
10482 CONTINUE
      EZ = ZC/TPZ
      ZA = AL183*ZT
      ZG = ZB/ZT
      ZP = ZB/ZA
      ZV = (ZB-ZF)/ZT
      ZU = (ZB-ZF)/ZA
      EDEN=AN*RHOP/WM*ZC
      RLCP = 1./( (AN*RHOP/WM)*4.0*FSC*R0**2*(ZAB-ZF) )
      BLCCP= A6680*RHOP*ZS*EXP(ZE/ZS)*RLCP/(WM*EXP(ZX/ZS))
      TEFF0P = ( EXP(BMIN)/BMIN )/BLCCP
      XCCP= (A22P9/RADDEG) * SQRT( ZS*RHOP*RLCP/WM )
      XR0P = XCCP*SQRT(TEFF0P*BMIN)
      RETURN
      END
      SUBROUTINE DIFFER
      implicit none
      real*4 AL183,F10,F20,A1DEN,A2DEN,B1DEN,B2DEN,C1DEN,C2DEN
      INTEGER I
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6), DE
     *LCMP,ALPHIP(2),BPARP(2),DELPOSP(2)
      real*4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP
      COMMON/DBRPR/ALFP1(2),ALFP2(2),AL2
      real*4 ALFP1,ALFP2,al2
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183
      real*4 ALRAD,ALRADP,A1440,A183
      AL2 = LOG(2.)
      AL183= LOG(A183)
      ALPHIP(1)= AL2*(4./3. + 1./(9.*AL183*(1.+ZP)))
      ALPHIP(2)= AL2*(4./3. + 1./(9.*AL183*(1.+ZU)))
      ALFP1(1)= 2./3. - 1./(36.*AL183*(1.+ZP))
      ALFP1(2)= 2./3. - 1./(36.*AL183*(1.+ZU))
      ALFP2(1)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZP)))
      ALFP2(2)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZU)))
      BPARP(1)= ALFP1(1)/(ALFP1(1)+ALFP2(1))
      BPARP(2)= ALFP1(2)/(ALFP1(2)+ALFP2(2))
      DELCMP= 136.0*EXP(ZG)*RMP
      DELPOSP(1)= (EXP((21.12+4.*ZG)/4.184)-0.952)/DELCMP
      DELPOSP(2)= (EXP((21.12+4.*ZV)/4.184)-0.952)/DELCMP
      F10=4.*AL183
      F20=F10 - 2./3.
      A1DEN =3.0*F10- F20 + 8.0*ZG
      A2DEN =3.0*F10- F20 + 8.0*ZV
      B1DEN = F10 + 4.0*ZG
      B2DEN = F10 + 4.0*ZV
      C1DEN = 3.0*F10+ F20 + 16.0*ZG
      C2DEN = 3.0*F10+ F20 + 16.0*ZV
      DLP1(1)= (3.0*20.867-20.209+8.0*ZG)/A1DEN
      DLP2(1)= (3.0*(-3.242)-(-1.930))/A1DEN
      DLP3(1)= (3.0*(0.625)-(0.086))/A1DEN
      DLP4(1)= (2.0*21.12+8.0*ZG)/A1DEN
      DLP5(1)= 2.0*(-4.184)/A1DEN
      DLP6(1)= 0.952
      DLP1(4)= (3.0*20.867-20.209+8.0*ZV)/A2DEN
      DLP2(4)= (3.0*(-3.242)-(-1.930))/A2DEN
      DLP3(4)= (3.0*(0.625)-(0.086))/A2DEN
      DLP4(4)= (2.0*21.12+8.0*ZV)/A2DEN
      DLP5(4)= 2.0*(-4.184)/A2DEN
      DLP6(4)= 0.952
      DLP1(2)= (20.867+4.0*ZG)/B1DEN
      DLP2(2)= -3.242/B1DEN
      DLP3(2)= 0.625/B1DEN
      DLP4(2)= (21.12+4.0*ZG)/B1DEN
      DLP5(2)= -4.184/B1DEN
      DLP6(2)= 0.952
      DLP1(5)= (20.867+4.0*ZV)/B2DEN
      DLP2(5)= -3.242/B2DEN
      DLP3(5)= 0.625/B2DEN
      DLP4(5)= (21.12+4.0*ZV)/B2DEN
      DLP5(5)= -4.184/B2DEN
      DLP6(5)= 0.952
      DLP1(3)= (3.0*20.867+20.209+16.0*ZG)/C1DEN
      DLP2(3)= (3.0*(-3.242)+(-1.930))/C1DEN
      DLP3(3)= (3.0*0.625+(-0.086))/C1DEN
      DLP4(3)= (4.0*21.12+16.0*ZG)/C1DEN
      DLP5(3)= 4.0*(-4.184)/C1DEN
      DLP6(3)= 0.952
      DLP1(6)= (3.0*20.867+20.209+16.0*ZV)/C2DEN
      DLP2(6)= (3.0*(-3.242)+(-1.930))/C2DEN
      DLP3(6)= (3.0*0.625+(-0.086))/C2DEN
      DLP4(6)= (4.0*21.12+16.0*ZV)/C2DEN
      DLP5(6)= 4.0*(-4.184)/C2DEN
      DLP6(6)= 0.952
      RETURN
      END
      real*4 function FCOULCP(Z)
      implicit none
      real*4 Z,ASQ
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      ASQ=(FSC*Z)**2
      FCOULCP = ASQ*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+ ASQ*(0.0083+ASQ
     **(-0.002))))
      RETURN
      END
      real*4 function XSIFP(Z)
      implicit none
      real*4 Z,FCOULCP
      integer*4 IZ
      COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183
      real*4 ALRAD,ALRADP,A1440,A183
      IF ((Z.LE.4.0)) THEN
        IZ=Z
        XSIFP=ALRADP(IZ)/(ALRAD(IZ)-FCOULCP(Z))
      ELSE
        XSIFP=ALOG(A1440*Z**(-2./3.))/(ALOG(A183*Z**(-1./3.))-FCOULCP(Z)
     *  )
      END IF
      RETURN
      END
      real*4 FUNCTION ZTBL(IASYM)
      implicit none
      COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100)
      integer*4 NET
      real*4 ITBL,WATBL,RHOTBL
      CHARACTER*4 ASYMT
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      CHARACTER*4 IASYM,IA
      integer*4 ie
      DATA IA/'A'/
      save ia
      IF ((IASYM.EQ.IA)) THEN
        ZTBL=18.0
        RETURN
      END IF
      DO 10491 IE=1,NET
        IF ((IASYM.EQ.ASYMT(IE))) THEN
          ZTBL=IE
          RETURN
        END IF
10491 CONTINUE
10492 CONTINUE
      WRITE(6,10500)IASYM,NET
10500 FORMAT(1X,A2,' NOT AN ATOMIC SYMBOL FOR AN ELEMENT WITH Z LE ',I3)
      ZTBL=0.0
      RETURN
      END
      SUBROUTINE ANNIH
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DOUBLE PRECISION PAVIP,  PESG1,  PESG2
      real*8 AVIP,  A,                  G,T,P,                      POT,
     *
     *     EP0,                                                 WSAMP,
     *                       RNNO01,
     *                     RNNO02,
     *                                   EP,
     * REJF,                                                       ESG1,
     *                                      ESG2,
     *               aa,bb,cc,sinpsi,sindel,cosdel,us,vs,cphi,sphi
      integer*4
     *                     ibr
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      integer*4 ip
      NPold = NP
      IF (( nbr_split .LE. 0 )) THEN
        return
      END IF
      PAVIP=E(NP)+PRM
      AVIP=PAVIP
      A=AVIP/RM
      G=A-1.0
      T=G-1.0
      P=SQRT(A*T)
      POT=P/T
      EP0=1.0/(A+P)
      WSAMP=LOG((1.0-EP0)/EP0)
      aa = u(np)
      bb = v(np)
      cc = w(np)
      sinpsi = aa*aa + bb*bb
      IF (( sinpsi .GT. 1e-20 )) THEN
        sinpsi = sqrt(sinpsi)
        sindel = bb/sinpsi
        cosdel = aa/sinpsi
      END IF
      IF (( nbr_split .GT. 1 )) THEN
        wt(np) = wt(np)/nbr_split
      END IF
      DO 10511 ibr=1,nbr_split
        IF (( np+1 .GT. 40 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//a,i6,a//)') ' Stack overflow in ANNIH! np = ',
     *    np+1, ' Increase $MXSTACK and try again'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
10521   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO01 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          EP=EP0*EXP(RNNO01*WSAMP)
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO02 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          REJF = 1 - (EP*A-1)**2/(EP*(A*A-2))
          IF(((RNNO02 .LE. REJF)))GO TO10522
        GO TO 10521
10522   CONTINUE
        ESG1=AVIP*EP
        PESG1=ESG1
        E(NP)=PESG1
        IQ(NP)=0
        IF (( ibr .EQ. 1 )) THEN
          ip = npold
        ELSE
          ip = np-1
        END IF
        X(np)=X(ip)
        Y(np)=Y(ip)
        Z(np)=Z(ip)
        IR(np)=IR(ip)
        WT(np)=WT(ip)
        DNEAR(np)=DNEAR(ip)
        LATCH(np)=LATCH(ip)
        COSTHE=MAX(-1.0,MIN(1.0,(ESG1-RM)*POT/ESG1))
        SINTHE=SQRT(1.0-COSTHE*COSTHE)
10531   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          xphi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          xphi = 2*xphi - 1
          xphi2 = xphi*xphi
          IF((rng_seed .GT. 128))call ranmar_get
          yphi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          yphi2 = yphi*yphi
          rhophi2 = xphi2 + yphi2
          IF(rhophi2.LE.1)GO TO10532
        GO TO 10531
10532   CONTINUE
        rhophi2 = 1/rhophi2
        cphi = (xphi2 - yphi2)*rhophi2
        sphi = 2*xphi*yphi*rhophi2
        IF (( sinpsi .GE. 1e-10 )) THEN
          us = sinthe*cphi
          vs = sinthe*sphi
          u(np) = cc*cosdel*us - sindel*vs + aa*costhe
          v(np) = cc*sindel*us + cosdel*vs + bb*costhe
          w(np) = cc*costhe - sinpsi*us
        ELSE
          u(np) = sinthe*cphi
          v(np) = sinthe*sphi
          w(np) = cc*costhe
        END IF
        np = np + 1
        PESG2=PAVIP-PESG1
        esg2 = pesg2
        e(np) = pesg2
        iq(np) = 0
        X(np)=X(np-1)
        Y(np)=Y(np-1)
        Z(np)=Z(np-1)
        IR(np)=IR(np-1)
        WT(np)=WT(np-1)
        DNEAR(np)=DNEAR(np-1)
        LATCH(np)=LATCH(np-1)
        COSTHE=MAX(-1.0,MIN(1.0,(ESG2-RM)*POT/ESG2))
        SINTHE=-SQRT(1.0-COSTHE*COSTHE)
        IF (( sinpsi .GE. 1e-10 )) THEN
          us = sinthe*cphi
          vs = sinthe*sphi
          u(np) = cc*cosdel*us - sindel*vs + aa*costhe
          v(np) = cc*sindel*us + cosdel*vs + bb*costhe
          w(np) = cc*costhe - sinpsi*us
        ELSE
          u(np) = sinthe*cphi
          v(np) = sinthe*sphi
          w(np) = cc*costhe
        END IF
        np = np + 1
10511 CONTINUE
10512 CONTINUE
      np = np-1
      RETURN
      END
      SUBROUTINE ANNIH_AT_REST
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 costhe,sinthe,cphi,sphi
      integer*4 ibr,ip
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      NPold = NP
      IF (( np+2*nbr_split-1 .GT. 40 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','ANNIH_AT_RES
     *T', ' stack size exceeded! ',' $MAXSTACK = ',40,' np = ',np+2*nbr_
     *  split-1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( nbr_split .GT. 1 )) THEN
        wt(np) = wt(np)/nbr_split
      END IF
      DO 10541 ibr=1,nbr_split
        IF((rng_seed .GT. 128))call ranmar_get
        costhe = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        costhe = 2*costhe-1
        sinthe = sqrt(max(0.0,(1-costhe)*(1+costhe)))
10551   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          xphi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          xphi = 2*xphi - 1
          xphi2 = xphi*xphi
          IF((rng_seed .GT. 128))call ranmar_get
          yphi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          yphi2 = yphi*yphi
          rhophi2 = xphi2 + yphi2
          IF(rhophi2.LE.1)GO TO10552
        GO TO 10551
10552   CONTINUE
        rhophi2 = 1/rhophi2
        cphi = (xphi2 - yphi2)*rhophi2
        sphi = 2*xphi*yphi*rhophi2
        e(np) = prm
        iq(np) = 0
        IF (( ibr .EQ. 1 )) THEN
          ip = npold
        ELSE
          ip = np-1
        END IF
        X(np)=X(ip)
        Y(np)=Y(ip)
        Z(np)=Z(ip)
        IR(np)=IR(ip)
        WT(np)=WT(ip)
        DNEAR(np)=DNEAR(ip)
        LATCH(np)=LATCH(ip)
        u(np) = sinthe*cphi
        v(np) = sinthe*sphi
        w(np) = costhe
        np = np+1
        e(np) = prm
        iq(np) = 0
        X(np)=X(np-1)
        Y(np)=Y(np-1)
        Z(np)=Z(np-1)
        IR(np)=IR(np-1)
        WT(np)=WT(np-1)
        DNEAR(np)=DNEAR(np-1)
        LATCH(np)=LATCH(np-1)
        u(np) = -u(np-1)
        v(np) = -v(np-1)
        w(np) = -w(np-1)
        np = np+1
10541 CONTINUE
10542 CONTINUE
      np = np-1
      return
      end
      SUBROUTINE BHABHA
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DOUBLE PRECISION PEIP,  PEKIN,  PEKSE2,  PESE1,  PESE2,  H1,  DCOS
     *TH
      real*8 EIP,  EKIN,  T0,  E0,  E02,  YY,  Y2,YP,YP2, BETA2,  EP0,
     *EP0C,  B1,B2,B3,B4,  RNNO03,RNNO04, BR,  REJF2,  ESE1,  ESE2
      NPold = NP
      PEIP=E(NP)
      EIP=PEIP
      PEKIN=PEIP-PRM
      EKIN=PEKIN
      T0=EKIN/RM
      E0=T0+1.
      YY=1./(T0+2.)
      E02=E0*E0
      BETA2=(E02-1.)/E02
      EP0=TE(MEDIUM)/EKIN
      EP0C=1.-EP0
      Y2=YY*YY
      YP=1.-2.*YY
      YP2=YP*YP
      B4=YP2*YP
      B3=B4+YP2
      B2=YP*(3.+Y2)
      B1=2.-Y2
10561 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO03 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        BR=EP0/(1.-EP0C*RNNO03)
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO04 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        REJF2=(1.0-BETA2*BR*(B1-BR*(B2-BR*(B3-BR*B4))))
        IF((RNNO04.LE.REJF2))GO TO10562
      GO TO 10561
10562 CONTINUE
      IF (( np+1 .GT. 40 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','BHABHA', ' s
     *tack size exceeded! ',' $MAXSTACK = ',40,' np = ',np+1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF ((BR.LT.0.5)) THEN
        IQ(NP+1)=-1
      ELSE
        IQ(NP)=-1
        IQ(NP+1)=1
        BR=1.-BR
      END IF
      BR=max(BR,0.0)
      PEKSE2=BR*EKIN
      PESE1=PEIP-PEKSE2
      PESE2=PEKSE2+PRM
      ESE1=PESE1
      ESE2=PESE2
      E(NP)=PESE1
      E(NP+1)=PESE2
      H1=(PEIP+PRM)/PEKIN
      DCOSTH=MIN(1.0D0,H1*(PESE1-PRM)/(PESE1+PRM))
      SINTHE=DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(2,1)
      NP=NP+1
      DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM)
      SINTHE=-DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(3,2)
      RETURN
      END
      SUBROUTINE BREMS
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/nist_brems/ nb_fdata(0:50,100,3), nb_xdata(0:50,100,3), nb_
     *wdata(50,100,3), nb_idata(50,100,3), nb_emin(3),nb_emax(3), nb_lem
     *in(3),nb_lemax(3), nb_dle(3),nb_dlei(3), log_ap(3)
      real*8 nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lema
     *x, nb_dle,nb_dlei,log_ap
      integer*4 nb_idata
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DOUBLE PRECISION PEIE,  PESG,  PESE
      real*8 EIE,  EKIN,  brmin,  waux,  aux,  r1,  ajj,  alias_sample1,
     * RNNO06,  RNNO07,  BR,  ESG,  ESE,  DELTA,  phi1,  phi2,  REJF
      real*8 a,b,c,                               sinpsi, sindel, cosdel
     *, us, vs,
     *                                                ztarg,
     *             tteie,                                    beta,
     *                       y2max,
     *      y2maxi,                                                   tt
     *ese,                                      rjarg1,rjarg2,rjarg3,rej
     *min,rejmid,rejmax,rejtop,rejtst,
     *                 esedei,                                 y2tst,
     *                             y2tst1,
     *                                           rtest,
     *                            xphi,yphi,xphi2,yphi2,rhophi2,cphi,sph
     *i
      integer*4
     *                 L,L1,ibr,jj,j
      real*8 z2max,z2maxi,aux1,aux3,aux4,aux5,aux2,weight
      IF((nbr_split .LT. 1))return
      NPold = NP
      PEIE=E(NP)
      EIE=PEIE
      weight = wt(np)/nbr_split
      IF ((EIE.LT.50.0)) THEN
        L=1
      ELSE
        L=3
      END IF
      L1 = L+1
      ekin = peie-prm
      brmin = ap(medium)/ekin
      waux = elke - log_ap(medium)
      IF (( ibrdst .GE. 0 )) THEN
        a = u(np)
        b = v(np)
        c = w(np)
        sinpsi = a*a + b*b
        IF (( sinpsi .GT. 1e-20 )) THEN
          sinpsi = sqrt(sinpsi)
          sindel = b/sinpsi
          cosdel = a/sinpsi
        END IF
        ztarg = zbrang(medium)
        tteie = eie/rm
        beta = sqrt((tteie-1)*(tteie+1))/tteie
        y2max = 2*beta*(1+beta)*tteie*tteie
        y2maxi = 1/y2max
        IF (( ibrdst .EQ. 1 )) THEN
          z2max = y2max+1
          z2maxi = sqrt(z2max)
        END IF
      END IF
      IF (( ibr_nist .GE. 1 )) THEN
        ajj = 1 + (waux + log_ap(medium) - nb_lemin(medium))*nb_dlei(med
     *  ium)
        jj = ajj
        ajj = ajj - jj
        IF (( jj .GT. 100 )) THEN
          jj = 100
          ajj = -1
        END IF
      END IF
      DO 10571 ibr=1,nbr_split
        IF (( ibr_nist .GE. 1 )) THEN
          IF (( ekin .GT. nb_emin(medium) )) THEN
            IF((rng_seed .GT. 128))call ranmar_get
            r1 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF (( r1 .LT. ajj )) THEN
              j = jj+1
            ELSE
              j = jj
            END IF
            br = alias_sample1(50,nb_xdata(0,j,medium), nb_fdata(0,j,med
     *      ium), nb_wdata(1,j,medium),nb_idata(1,j,medium))
          ELSE
            IF((rng_seed .GT. 128))call ranmar_get
            br = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
          END IF
          esg = ap(medium)*exp(br*waux)
          pesg = esg
          pese = peie - pesg
          ese = pese
        ELSE
10581     CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            rnno06 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rng_seed .GT. 128))call ranmar_get
            rnno07 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            br = brmin*exp(rnno06*waux)
            esg = ekin*br
            pesg = esg
            pese = peie - pesg
            ese = pese
            delta = esg/eie/ese*delcm(medium)
            aux = ese/eie
            IF (( delta .LT. 1 )) THEN
              phi1 = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medi
     *        um))
              phi2 = dl1(l1,medium)+delta*(dl2(l1,medium)+ delta*dl3(l1,
     *        medium))
            ELSE
              phi1 = dl4(l,medium)+dl5(l,medium)*log(delta+dl6(l,medium)
     *        )
              phi2 = phi1
            END IF
            rejf = (1+aux*aux)*phi1 - 2*aux*phi2/3
            IF(((rnno07 .LT. rejf)))GO TO10582
          GO TO 10581
10582     CONTINUE
        END IF
        np=np+1
        IF (( np .GT. 40 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//a,i6,a//)') ' Stack overflow in BREMS! np = ',
     *    np+1, ' Increase $MXSTACK and try again'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        e(np) = pesg
        iq(np) = 0
        X(np)=X(np-1)
        Y(np)=Y(np-1)
        Z(np)=Z(np-1)
        IR(np)=IR(np-1)
        WT(np)=WT(np-1)
        DNEAR(np)=DNEAR(np-1)
        LATCH(np)=LATCH(np-1)
        wt(np) = weight
        IF (( ibrdst .LT. 0 )) THEN
          u(np) = u(npold)
          v(np) = v(npold)
          w(np) = w(npold)
        ELSE
          IF (( ibrdst .EQ. 1 )) THEN
            ttese = ese/rm
            esedei = ttese/tteie
            rjarg1 = 1+esedei*esedei
            rjarg2 = rjarg1 + 2*esedei
            aux = 2*ese*tteie/esg
            aux = aux*aux
            aux1 = aux*ztarg
            IF (( aux1 .GT. 10 )) THEN
              rjarg3 = lzbrang(medium) + (1-aux1)/aux1**2
            ELSE
              rjarg3 = log(aux/(1+aux1))
            END IF
            rejmax = rjarg1*rjarg3-rjarg2
10591       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              y2tst = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF((rng_seed .GT. 128))call ranmar_get
              rtest = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              aux3 = z2maxi/(y2tst+(1-y2tst)*z2maxi)
              rtest = rtest*aux3*rejmax
              y2tst = aux3**2-1
              y2tst1 = esedei*y2tst/aux3**4
              aux4 = 16*y2tst1-rjarg2
              aux5 = rjarg1-4*y2tst1
              IF((rtest .LT. aux4 + aux5*rjarg3))GO TO10592
              aux2 = log(aux/(1+aux1/aux3**4))
              rejtst = aux4+aux5*aux2
              IF(((rtest .LT. rejtst )))GO TO10592
            GO TO 10591
10592       CONTINUE
          ELSE
            IF((rng_seed .GT. 128))call ranmar_get
            y2tst = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            y2tst = y2tst/(1-y2tst+y2maxi)
          END IF
          costhe = 1 - 2*y2tst*y2maxi
          sinthe = sqrt(max((1-costhe)*(1+costhe),0.0))
10601     CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            xphi = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            xphi = 2*xphi - 1
            xphi2 = xphi*xphi
            IF((rng_seed .GT. 128))call ranmar_get
            yphi = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            yphi2 = yphi*yphi
            rhophi2 = xphi2 + yphi2
            IF(rhophi2.LE.1)GO TO10602
          GO TO 10601
10602     CONTINUE
          rhophi2 = 1/rhophi2
          cphi = (xphi2 - yphi2)*rhophi2
          sphi = 2*xphi*yphi*rhophi2
          IF (( sinpsi .GE. 1e-10 )) THEN
            us = sinthe*cphi
            vs = sinthe*sphi
            u(np) = c*cosdel*us - sindel*vs + a*costhe
            v(np) = c*sindel*us + cosdel*vs + b*costhe
            w(np) = c*costhe - sinpsi*us
          ELSE
            u(np) = sinthe*cphi
            v(np) = sinthe*sphi
            w(np) = c*costhe
          END IF
        END IF
10571 CONTINUE
10572 CONTINUE
      e(npold) = pese
      RETURN
      END
      SUBROUTINE COMPT
      implicit none
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,3), eno_array(200,3), eno_atbin_array(200,3), n_sh
     *ell(3), radc_flag,  ibcmp( 1001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      DOUBLE PRECISION PEIG,  PESG,  PESE
      real*8 ko,  broi,  broi2,  bro,  bro1,  alph1,  alph2,  alpha,  rn
     *no15,rnno16,rnno17,rnno18,rnno19,  br,  temp,  rejf3,  rejmax,  Uj
     *,  Jo,  br2,  fpz,fpz1, qc,  qc2,  af,  Fmax,  frej,  eta_incoh, e
     *ta,  aux,aux1,aux2,aux3,aux4,  pzmax,  pz,  pz2,  rnno_RR
      integer*4 irl,  i,  j,  iarg,  ip
      logical first_time
      integer*4 ibcmpl
      NPold = NP
      peig=E(NP)
      ko = peig/rm
      broi = 1 + 2*ko
      irl = ir(np)
      first_time = .true.
      ibcmpl = ibcmp(irl)
10610 CONTINUE
      IF (( ibcmpl .GT. 0 )) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        rnno17 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        rnno17 = 1 + rnno17*n_shell(medium)
        i = int(rnno17)
        IF((rnno17 .GT. eno_array(i,medium)))i = eno_atbin_array(i,mediu
     *  m)
        j = shell_array(i,medium)
        Uj = be_array(j)
        IF (( ko .LE. Uj )) THEN
          IF (( ibcmpl .EQ. 1 )) THEN
            goto 10620
          ELSE
            goto 10610
          END IF
        END IF
        Jo = Jo_array(j)
      END IF
10630 CONTINUE
      IF (( ko .GT. 2 )) THEN
        IF (( first_time )) THEN
          broi2 = broi*broi
          alph1 = Log(broi)
          bro = 1/broi
          alph2 = ko*(broi+1)*bro*bro
          alpha = alph1+alph2
        END IF
10641   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          rnno15 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          rnno16 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF (( rnno15*alpha .LT. alph1 )) THEN
            br = Exp(alph1*rnno16)*bro
          ELSE
            br = Sqrt(rnno16*broi2 + (1-rnno16))*bro
          END IF
          temp = (1-br)/(ko*br)
          sinthe = Max(0.,temp*(2-temp))
          aux = 1+br*br
          rejf3 = aux - br*sinthe
          IF((rng_seed .GT. 128))call ranmar_get
          rnno19 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rnno19*aux.le.rejf3))GO TO10642
        GO TO 10641
10642   CONTINUE
      ELSE
        IF (( first_time )) THEN
          bro = 1./broi
          bro1 = 1 - bro
          rejmax = broi + bro
        END IF
10651   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          rnno15 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          rnno16 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          br = bro + bro1*rnno15
          temp = (1-br)/(ko*br)
          sinthe = Max(0.,temp*(2-temp))
          rejf3 = 1 + br*br - br*sinthe
          IF((rnno16*br*rejmax.le.rejf3))GO TO10652
        GO TO 10651
10652   CONTINUE
      END IF
      first_time = .false.
      IF ((br .LT. bro .OR. br .GT. 1)) THEN
        IF (( br .LT. 0.99999/broi .OR. br .GT. 1.00001 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' sampled br outside of allowed range! ',ko,1./
     *    broi,br
        END IF
        goto 10630
      END IF
      costhe = 1 - temp
      IF (( ibcmp(irl) .EQ. 0 )) THEN
        Uj = 0
        goto 10660
      END IF
      br2 = br*br
      aux = ko*(ko-Uj)*temp
      aux1 = 2*aux + Uj*Uj
      pzmax = aux - Uj
      IF (( pzmax .LT. 0 .AND. pzmax*pzmax .GE. aux1 )) THEN
        IF (( ibcmpl .EQ. 1 )) THEN
          goto 10620
        ELSE
          goto 10610
        END IF
      END IF
      pzmax = pzmax/sqrt(aux1)
      qc2 = 1 + br*br - 2*br*costhe
      qc = sqrt(qc2)
      IF (( pzmax .GT. 1 )) THEN
        pzmax = 1
        af = 0
        Fmax = 1
        fpz = 1
        goto 10670
      END IF
      aux3 = 1 + 2*Jo*abs(pzmax)
      aux4 = 0.5*(1-aux3*aux3)
      fpz = 0.5*exp(aux4)
      af = qc*(1+br*(br-costhe)/qc2)
      IF (( af .LT. 0 )) THEN
        IF((pzmax .GT. 0))fpz = 1 - fpz
        IF((rng_seed .GT. 128))call ranmar_get
        eta_incoh = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( eta_incoh .GT. fpz )) THEN
          IF (( ibcmpl .EQ. 1 )) THEN
            goto 10620
          ELSE
            goto 10610
          END IF
        END IF
        af = 0
        Fmax = 1
        goto 10670
      END IF
      IF (( pzmax .LT. -0.15 )) THEN
        Fmax = 1-af*0.15
        fpz1 = fpz*Fmax*Jo
      ELSE IF(( pzmax .LT. 0.15 )) THEN
        Fmax = 1 + af*pzmax
        aux3 = 1/(1+0.33267252734*aux3)
        aux4 = fpz*aux3*(0.3480242+aux3*(-0.0958798+aux3*0.7478556)) + e
     *  rfJo_array(j)
        IF (( pzmax .GT. 0 )) THEN
          fpz1 = (1 - Fmax*fpz)*Jo - 0.62665706866*af*aux4
          fpz = 1 - fpz
        ELSE
          fpz1 = Fmax*fpz*Jo - 0.62665706866*af*aux4
        END IF
      ELSE
        Fmax = 1 + af*0.15
        fpz1 = (1 - Fmax*fpz)*Jo
        fpz = 1 - fpz
      END IF
      IF((rng_seed .GT. 128))call ranmar_get
      eta_incoh = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF ((eta_incoh*Jo .GT. fpz1 )) THEN
        IF (( ibcmpl .EQ. 1 )) THEN
          goto 10620
        ELSE
          goto 10610
        END IF
      END IF
10670 CONTINUE
      IF (( ibcmpl .NE. 2 )) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        rnno18 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        rnno18 = rnno18*fpz
        IF (( rnno18 .LT. 0.5 )) THEN
          rnno18 = Max(1e-30,2*rnno18)
          pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo
        ELSE
          rnno18 = 2*(1-rnno18)
          pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo
        END IF
        IF((abs(pz) .GT. 1))goto 10670
        IF (( pz .LT. 0.15 )) THEN
          IF (( pz .LT. -0.15 )) THEN
            frej = 1 - af*0.15
          ELSE
            frej = 1 + af*pz
          END IF
          IF((rng_seed .GT. 128))call ranmar_get
          eta = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((eta*Fmax .GT. frej))goto 10670
        END IF
      ELSE
        pz = 0
        Uj = 0
      END IF
      pz2 = pz*pz
      IF (( abs(pz) .LT. 0.01 )) THEN
        br = br*(1 + pz*(qc + (br2-costhe)*pz))
      ELSE
        aux = 1 - pz2*br*costhe
        aux1 = 1 - pz2*br2
        aux2 = qc2 - br2*pz2*sinthe
        IF (( aux2 .GT. 1e-10 )) THEN
          br = br/aux1*(aux+pz*Sqrt(aux2))
        END IF
      END IF
      Uj = Uj*prm
10660 pesg = br*peig
      pese = peig - pesg - Uj + prm
      sinthe = Sqrt(sinthe)
      call uphi(2,1)
      e(np) = pesg
      aux = 1 + br*br - 2*br*costhe
      IF (( aux .GT. 1e-8 )) THEN
        costhe = (1-br*costhe)/Sqrt(aux)
        sinthe = (1-costhe)*(1+costhe)
        IF (( sinthe .GT. 0 )) THEN
          sinthe = -Sqrt(sinthe)
        ELSE
          sinthe = 0
        END IF
      ELSE
        costhe = 0
        sinthe = -1
      END IF
      np = np + 1
      IF (( np .GT. 40 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','COMPT', ' st
     *ack size exceeded! ',' $MAXSTACK = ',40,' np = ',np
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      call uphi(3,2)
      e(np) = pese
      iq(np) = -1
      IF (( ibcmpl .EQ. 1 .OR. ibcmpl .EQ. 3 )) THEN
        IF (( Uj .GT. 1e-3 )) THEN
          edep = pzero
          call relax(Uj,shn_array(j),iz_array(j))
        ELSE
          edep = Uj
          edep_local = edep
          IARG=33
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
        END IF
        IF (( edep .GT. 0 )) THEN
          IARG=4
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,10680)prob_RR
10680       FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold+1
10691     CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF((rng_seed .GT. 128))call ranmar_get
              rnno_RR = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO10692
          GO TO 10691
10692     CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
10620 return
      end
      SUBROUTINE old_COMPT
      implicit none
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,3), eno_array(200,3), eno_atbin_array(200,3), n_sh
     *ell(3), radc_flag,  ibcmp( 1001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      DOUBLE PRECISION PEIG,  PESG,  PESE
      real*8 ko,  broi,  broi2,  bro,  bro1,  alph1,  alph2,  alpha,  rn
     *no15,rnno16,rnno17,rnno18,rnno19,  br,  temp,  rejf3,  rejmax,  Uj
     *,  br2,  aux,aux1,aux2, pzmax2,  pz,  pz2,  rnno_RR
      integer*4 irl,  i,  j,  iarg,  ip
      i_survived_RR = 0
      NPold = NP
      peig=E(NP)
      ko = peig/rm
      broi = 1 + 2*ko
      irl = ir(np)
      IF (( ibcmp(irl) .EQ. 1 )) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        rnno17 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        DO 10701 i=1,n_shell(medium)
          rnno17 = rnno17 - eno_array(i,medium)
          IF((rnno17 .LE. 0))GO TO10702
10701   CONTINUE
10702   CONTINUE
        j = shell_array(i,medium)
        Uj = be_array(j)
        IF (( ko .LE. Uj )) THEN
          goto 10710
        END IF
      END IF
10720 CONTINUE
      IF (( ko .GT. 2 )) THEN
        broi2 = broi*broi
        alph1 = Log(broi)
        alph2 = ko*(broi+1)/broi2
        alpha = alph1/(alph1+alph2)
10731   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          rnno15 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          rnno16 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF (( rnno15 .LT. alpha )) THEN
            br = Exp(alph1*rnno16)/broi
          ELSE
            br = Sqrt(rnno16 + (1-rnno16)/broi2)
          END IF
          temp = (1-br)/ko/br
          sinthe = Max(0.,temp*(2-temp))
          rejf3 = 1 - br*sinthe/(1+br*br)
          IF((rng_seed .GT. 128))call ranmar_get
          rnno19 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rnno19.le.rejf3))GO TO10732
        GO TO 10731
10732   CONTINUE
      ELSE
        bro = 1./broi
        bro1 = 1 - bro
        rejmax = broi + bro
10741   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          rnno15 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          rnno16 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          br = bro + bro1*rnno15
          temp = (1-br)/ko/br
          sinthe = Max(0.,temp*(2-temp))
          rejf3 = (br + 1./br - sinthe)/rejmax
          IF((rnno16.le.rejf3))GO TO10742
        GO TO 10741
10742   CONTINUE
      END IF
      IF ((br .LT. 1./broi .OR. br .GT. 1)) THEN
        IF (( br .LT. 0.99999/broi .OR. br .GT. 1.00001 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' sampled br outside of allowed range! ',ko,1./
     *    broi,br
        END IF
        goto 10720
      END IF
      IF (( ibcmp(irl) .EQ. 0 )) THEN
        Uj = 0
        costhe = 1 - temp
        goto 10750
      END IF
      br2 = br*br
      costhe = 1 - temp
      aux = ko*(ko-Uj)*temp
      aux1 = aux-Uj
      pzmax2 = aux1*aux1/(2*aux+Uj*Uj)
10760 CONTINUE
      IF((rng_seed .GT. 128))call ranmar_get
      rnno18 = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF (( rnno18 .LT. 0.5 )) THEN
        rnno18 = Max(1e-30,2*rnno18)
        pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo_array(j)
        pz2 = pz*pz
        IF (( (pz2 .LE. pzmax2) .AND. (aux1 .LT. 0) )) THEN
          goto 10710
        END IF
      ELSE
        IF (( aux1 .LT. 0 )) THEN
          goto 10710
        END IF
        rnno18 = 2*(1-rnno18)
        pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo_array(j)
        pz2 = pz*pz
        IF (( pz2 .GE. pzmax2 )) THEN
          goto 10710
        END IF
      END IF
      IF((abs(pz) .GT. 1))goto 10760
      aux = 1 - pz2*br*costhe
      aux1 = 1 - pz2*br2
      aux2 = 1-2*br*costhe+br2*(1-pz2*sinthe)
      IF (( aux2 .GT. 1e-10 )) THEN
        br = br/aux1*(aux+pz*Sqrt(aux2))
      END IF
      Uj = Uj*prm
10750 pesg = br*peig
      pese = peig - pesg - Uj + prm
      sinthe = Sqrt(sinthe)
      call uphi(2,1)
      e(np) = pesg
      aux = 1 + br*br - 2*br*costhe
      IF (( aux .GT. 1e-8 )) THEN
        costhe = (1-br*costhe)/Sqrt(aux)
        sinthe = (1-costhe)*(1+costhe)
        IF (( sinthe .GT. 0 )) THEN
          sinthe = -Sqrt(sinthe)
        ELSE
          sinthe = 0
        END IF
      ELSE
        costhe = 0
        sinthe = -1
      END IF
      np = np + 1
      IF (( np .GT. 40 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','COMPT', ' st
     *ack size exceeded! ',' $MAXSTACK = ',40,' np = ',np
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      call uphi(3,2)
      e(np) = pese
      iq(np) = -1
      IF (( ibcmp(irl) .EQ. 1 )) THEN
        IF (( Uj .GT. 1e-3 )) THEN
          edep = 0
          call relax(Uj,shn_array(j),iz_array(j))
        ELSE
          edep = Uj
        END IF
        IF (( edep .GT. 0 )) THEN
          IARG=4
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,10770)prob_RR
10770       FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold+1
10781     CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF((rng_seed .GT. 128))call ranmar_get
              rnno_RR = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO10782
          GO TO 10781
10782     CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
10710 return
      end
      SUBROUTINE ELECTR(IRCODE)
      implicit none
      integer*4 IRCODE
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/BOUNDS/ECUT( 1001),PCUT( 1001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      real*8 SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERVR/ CEXPTR,GWAIT,PATHL,DUMU,DUMX,DUMY,DUMZ, DELTAP,GWTO
     *LD,EPSLON,ARG,EXPMFP,ESAVEIN, IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM, IFO
     *RCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN, MEDTMP,IREJCT
      real*8 CEXPTR,GWAIT,DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,GWTOLD,EPSLON
     *,ARG, EXPMFP,ESAVEIN
      integer*4 NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN,IFORCE,IRODU
     *M, IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,IREJCT
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/ET_control/ smaxir( 1001),estepe,ximax,  skindepth_for_bca,
     *transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(3), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),  e
     *ii_sh(40),  eii_nshells(100),  eii_nsh(3),  eii_first(3,50),  eii_
     *no(3,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      real*8 lambda_max, sigratio, u_tmp, v_tmp, w_tmp
      LOGICAL random_tustep
      DOUBLE PRECISION  demfp,  peie,  total_tstep,  total_de
      real*8 ekems,  elkems,  chia2,  etap,  lambda,  blccl,  xccl,  xi,
     *  xi_corr,  ms_corr, p2,  beta2,  de,  save_de,  dedx,  dedx0,  de
     *dxmid,  ekei,  elkei,  aux,  ebr1,  eie,  ekef,  elkef,  ekeold,
     *eketmp,  elktmp,  fedep,  tuss,  pbr1,  pbr2,  range,  rfict,  rnn
     *e1,  rnno24,  rnno25,  rnnotu,  rnnoss,  sig,  sig0,  sigf,  skind
     *epth,  ssmfp,  tmxs,  tperp,  ustep0,  uscat,  vscat,  wscat,  xtr
     *ans,  ytrans,  ztrans,  cphi,sphi
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      integer*4 iarg,  idr,  ierust,  irl,  lelec,  qel,  lelke,  lelkem
     *s,  lelkef,  lelktmp,  ibr
      logical  callhowfar,   domultiple,  dosingle,   callmsdist,
     *                findindex,
     *              spin_index,                                   comput
     *e_tstep
     *
      data ierust/0/
      save ierust
      ircode = 1
      irold = ir(np)
      irl = irold
      medium = med(irl)
10790 CONTINUE
10791   CONTINUE
        lelec = iq(np)
        qel = (1+lelec)/2
        peie = e(np)
        eie = peie
        IF ((eie .LE. ecut(irl))) THEN
          go to 10800
        END IF
        IF ((WT(NP) .EQ. 0.0)) THEN
          go to 10810
        END IF
10820   CONTINUE
10821     CONTINUE
          compute_tstep = .true.
          eke = eie - rm
          IF ((medium .NE. 0)) THEN
            IF((rng_seed .GT. 128))call ranmar_get
            RNNE1 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF ((RNNE1.EQ.0.0)) THEN
              RNNE1=1.E-30
            END IF
            DEMFP=MAX(-LOG(RNNE1),1.E-8)
            elke = log(eke)
            Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
            IF (( sig_ismonotone(qel,medium) )) THEN
              IF ((lelec .LT. 0)) THEN
                sigf=esig1(Lelke,MEDIUM)*elke+esig0(Lelke,MEDIUM)
                dedx0=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
                sigf = sigf/dedx0
              ELSE
                sigf=psig1(Lelke,MEDIUM)*elke+psig0(Lelke,MEDIUM)
                dedx0=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
                sigf = sigf/dedx0
              END IF
              sig0 = sigf
            ELSE
              IF (( lelec .LT. 0 )) THEN
                sig0 = esig_e(medium)
              ELSE
                sig0 = psig_e(medium)
              END IF
            END IF
          END IF
10830     CONTINUE
10831       CONTINUE
            IF ((medium .EQ. 0)) THEN
              tstep = vacdst
              ustep = tstep
              tustep = ustep
              callhowfar = .true.
              ustep = tustep
            ELSE
              RHOF=RHOR(IRL)/RHO(MEDIUM)
              sig = sig0
              IF ((sig .LE. 0)) THEN
                tstep = vacdst
                sig0 = 1.E-15
              ELSE
                IF (( compute_tstep )) THEN
                  total_de = demfp/sig
                  fedep = total_de
                  ekef = eke - fedep
                  IF (( ekef .LE. E_array(1,medium) )) THEN
                    tstep = vacdst
                  ELSE
                    elkef = Log(ekef)
                    Lelkef=eke1(MEDIUM)*elkef+eke0(MEDIUM)
                    IF (( lelkef .EQ. lelke )) THEN
                      fedep = 1 - ekef/eke
                      elktmp = 0.5*(elke+elkef+0.25*fedep*fedep*(1+fedep
     *                *(1+0.875*fedep)))
                      lelktmp = lelke
                      IF ((lelec .LT. 0)) THEN
                        dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = ededx1(lelktmp,medium)*dedxmid
                      ELSE
                        dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = pdedx1(lelktmp,medium)*dedxmid
                      END IF
                      aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
                      tstep = fedep*eke*dedxmid*(1+aux)
                    ELSE
                      ekei = E_array(lelke,medium)
                      elkei = (lelke - eke0(medium))/eke1(medium)
                      fedep = 1 - ekei/eke
                      elktmp = 0.5*(elke+elkei+0.25*fedep*fedep*(1+fedep
     *                *(1+0.875*fedep)))
                      lelktmp = lelke
                      IF ((lelec .LT. 0)) THEN
                        dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = ededx1(lelktmp,medium)*dedxmid
                      ELSE
                        dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = pdedx1(lelktmp,medium)*dedxmid
                      END IF
                      aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
                      tuss = fedep*eke*dedxmid*(1+aux)
                      ekei = E_array(lelkef+1,medium)
                      elkei = (lelkef + 1 - eke0(medium))/eke1(medium)
                      fedep = 1 - ekef/ekei
                      elktmp = 0.5*(elkei+elkef+0.25*fedep*fedep*(1+fede
     *                p*(1+0.875*fedep)))
                      lelktmp = lelkef
                      IF ((lelec .LT. 0)) THEN
                        dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = ededx1(lelktmp,medium)*dedxmid
                      ELSE
                        dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = pdedx1(lelktmp,medium)*dedxmid
                      END IF
                      aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
                      tstep = fedep*ekei*dedxmid*(1+aux)
                      tstep=tstep+tuss+ range_ep(qel,lelke,medium)-range
     *                _ep(qel,lelkef+1,medium)
                    END IF
                  END IF
                  total_tstep = tstep
                  compute_tstep = .false.
                END IF
                tstep = total_tstep/rhof
              END IF
              IF ((lelec .LT. 0)) THEN
                dedx0=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
              ELSE
                dedx0=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
              END IF
              dedx = rhof*dedx0
              tmxs=tmxs1(Lelke,MEDIUM)*elke+tmxs0(Lelke,MEDIUM)
              tmxs = tmxs/rhof
              ekei = E_array(lelke,medium)
              elkei = (lelke - eke0(medium))/eke1(medium)
              fedep = 1 - ekei/eke
              elktmp = 0.5*(elke+elkei+0.25*fedep*fedep*(1+fedep*(1+0.87
     *        5*fedep)))
              lelktmp = lelke
              IF ((lelec .LT. 0)) THEN
                dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelktmp,MED
     *          IUM)
                dedxmid = 1/dedxmid
                aux = ededx1(lelktmp,medium)*dedxmid
              ELSE
                dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelktmp,MED
     *          IUM)
                dedxmid = 1/dedxmid
                aux = pdedx1(lelktmp,medium)*dedxmid
              END IF
              aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
              range = fedep*eke*dedxmid*(1+aux)
              range = (range + range_ep(qel,lelke,medium))/rhof
              random_tustep = .false.
              IF ((random_tustep)) THEN
                IF((rng_seed .GT. 128))call ranmar_get
                rnnotu = rng_array(rng_seed)*twom24
                rng_seed = rng_seed + 1
                tmxs = rnnotu*min(tmxs,smaxir(irl))
              ELSE
                tmxs = min(tmxs,smaxir(irl))
              END IF
              tustep = min(tstep,tmxs,range)
              call hownear(tperp,x(np),y(np),z(np),ir(np))
              dnear(np) = tperp
              IF (( i_do_rr(irl) .EQ. 1 .AND. e(np) .LT. e_max_rr(irl) )
     *        ) THEN
                IF ((tperp .GE. range)) THEN
                  idisc = 50 + 49*iq(np)
                  go to 10810
                END IF
              END IF
              blccl = rhof*blcc(medium)
              xccl = rhof*xcc(medium)
              p2 = eke*(eke+rmt2)
              beta2 = p2/(p2 + rmsq)
              IF (( spin_effects )) THEN
                IF ((lelec .LT. 0)) THEN
                  etap=etae_ms1(Lelke,MEDIUM)*elke+etae_ms0(Lelke,MEDIUM
     *            )
                ELSE
                  etap=etap_ms1(Lelke,MEDIUM)*elke+etap_ms0(Lelke,MEDIUM
     *            )
                END IF
                ms_corr=blcce1(Lelke,MEDIUM)*elke+blcce0(Lelke,MEDIUM)
                blccl = blccl/etap/(1+0.25*etap*xccl/blccl/p2)*ms_corr
              END IF
              ssmfp=beta2/blccl
              skindepth = skindepth_for_bca*ssmfp
              tustep = min(tustep,max(tperp,skindepth))
              count_all_steps = count_all_steps + 1
              is_ch_step = .false.
              IF (((tustep .LE. tperp) .AND. ((.NOT.exact_bca) .OR. (tus
     *        tep .GT. skindepth)))) THEN
                callhowfar = .false.
                domultiple = .false.
                dosingle = .false.
                callmsdist = .true.
                tuss = range - range_ep(qel,lelke,medium)/rhof
                IF (( tuss .GE. tustep )) THEN
                  IF (( lelec .LT. 0 )) THEN
                    dedxmid=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIU
     *              M)
                    aux = ededx1(lelke,medium)/dedxmid
                  ELSE
                    dedxmid=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIU
     *              M)
                    aux = pdedx1(lelke,medium)/dedxmid
                  END IF
                  de = dedxmid*tustep*rhof
                  fedep = de/eke
                  de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.2
     *            5*fedep*(2-aux*(4-aux)))))
                ELSE
                  lelktmp = lelke
                  tuss = (range - tustep)*rhof
                  IF (( tuss .LE. 0 )) THEN
                    de = eke - TE(medium)*0.99
                  ELSE
10841               IF(tuss.GE.range_ep(qel,lelktmp,medium))GO TO 10842
                      lelktmp = lelktmp - 1
                    GO TO 10841
10842               CONTINUE
                    elktmp = (lelktmp+1-eke0(medium))/eke1(medium)
                    eketmp = E_array(lelktmp+1,medium)
                    tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof
                    IF (( lelec .LT. 0 )) THEN
                      dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelkt
     *                mp,MEDIUM)
                      aux = ededx1(lelktmp,medium)/dedxmid
                    ELSE
                      dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelkt
     *                mp,MEDIUM)
                      aux = pdedx1(lelktmp,medium)/dedxmid
                    END IF
                    de = dedxmid*tuss*rhof
                    fedep = de/eketmp
                    de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0
     *              .25*fedep*(2-aux*(4-aux)))))
                    de = de + eke - eketmp
                  END IF
                END IF
                tvstep = tustep
                is_ch_step = .true.
                IF ((transport_algorithm .EQ. 0)) THEN
                  call msdist_pII (  eke,de,tustep,rhof,medium,qel,spin_
     *            effects, u(np),v(np),w(np),x(np),y(np),z(np),  uscat,v
     *            scat,wscat,xtrans,ytrans,ztrans,ustep )
                ELSE
                  call msdist_pI (  eke,de,tustep,rhof,medium,qel,spin_e
     *            ffects, u(np),v(np),w(np),x(np),y(np),z(np),  uscat,vs
     *            cat,wscat,xtrans,ytrans,ztrans,ustep )
                END IF
              ELSE
                callmsdist = .false.
                IF ((exact_bca)) THEN
                  domultiple = .false.
                  IF((rng_seed .GT. 128))call ranmar_get
                  rnnoss = rng_array(rng_seed)*twom24
                  rng_seed = rng_seed + 1
                  IF (( rnnoss .LT. 1.e-30 )) THEN
                    rnnoss = 1.e-30
                  END IF
                  lambda = - Log(1 - rnnoss)
                  lambda_max = 0.5*blccl*rm/dedx*(eke/rm+1)**3
                  IF (( lambda .GE. 0 .AND. lambda_max .GT. 0 )) THEN
                    IF (( lambda .LT. lambda_max )) THEN
                      tuss=lambda*ssmfp*(1-0.5*lambda/lambda_max)
                    ELSE
                      tuss = 0.5 * lambda * ssmfp
                    END IF
                    IF ((tuss .LT. tustep)) THEN
                      tustep = tuss
                      dosingle = .true.
                    ELSE
                      dosingle = .false.
                    END IF
                  ELSE
                    write(i_log,'(/a)') '***************** Warning: '
                    write(i_log,*) ' lambda > lambda_max: ', lambda,lamb
     *              da_max,' eke dedx: ',eke,dedx, ' ir medium blcc: ',i
     *              r(np),medium,blcc(medium), ' position = ',x(np),y(np
     *              ),z(np)
                    dosingle = .false.
                    np=np-1
                    return
                  END IF
                  ustep = tustep
                ELSE
                  dosingle = .false.
                  domultiple = .true.
                  ekems = eke - 0.5*tustep*dedx
                  p2 = ekems*(ekems+rmt2)
                  beta2 = p2/(p2 + rmsq)
                  chia2 = xccl/(4*blccl*p2)
                  xi = 0.5*xccl/p2/beta2*tustep
                  IF (( spin_effects )) THEN
                    elkems = Log(ekems)
                    Lelkems=eke1(MEDIUM)*elkems+eke0(MEDIUM)
                    IF ((lelec .LT. 0)) THEN
                      etap=etae_ms1(Lelkems,MEDIUM)*elkems+etae_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1ce_ms1(Lelkems,MEDIUM)*elkems+q1ce_ms0(L
     *                elkems,MEDIUM)
                    ELSE
                      etap=etap_ms1(Lelkems,MEDIUM)*elkems+etap_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1cp_ms1(Lelkems,MEDIUM)*elkems+q1cp_ms0(L
     *                elkems,MEDIUM)
                    END IF
                    chia2 = chia2*etap
                    xi = xi*xi_corr
                    ms_corr=blcce1(Lelkems,MEDIUM)*elkems+blcce0(Lelkems
     *              ,MEDIUM)
                    blccl = blccl*ms_corr
                  ELSE
                    xi_corr = 1
                    etap = 1
                  END IF
                  xi = xi*(Log(1+1./chia2)-1/(1+chia2))
                  IF (( xi .LT. 0.1 )) THEN
                    ustep = tustep*(1 - xi*(0.5 - xi*0.166667))
                  ELSE
                    ustep = tustep*(1 - Exp(-xi))/xi
                  END IF
                END IF
                IF ((ustep .LT. tperp)) THEN
                  callhowfar = .false.
                ELSE
                  callhowfar = .true.
                END IF
              END IF
            END IF
            irold = ir(np)
            irnew = ir(np)
            idisc = 0
            ustep0 = ustep
            IF ((callhowfar .OR. wt(np) .LE. 0)) THEN
              call howfar
            END IF
            IF ((idisc .GT. 0)) THEN
              go to 10810
            END IF
            IF ((ustep .LE. 0)) THEN
              IF ((ustep .LT. -1e-4)) THEN
                ierust = ierust + 1
                WRITE(6,10850)ierust,ustep,dedx,e(np)-prm, ir(np),irnew,
     *          irold,x(np),y(np),z(np)
10850           FORMAT(i4,' Negative ustep = ',e12.5,' dedx=',F8.4,' ke=
     *',F8.4, ' ir,irnew,irold =',3i4,' x,y,z =',4e10.3)
                IF ((ierust .GT. 1000)) THEN
                  WRITE(6,10860)
10860             FORMAT(////' Called exit---too many ustep errors'///)
                  call exit(1)
                END IF
              END IF
              ustep = 0
            END IF
            IF ((ustep .EQ. 0 .OR. medium .EQ. 0)) THEN
              IF ((ustep .NE. 0)) THEN
                IF (.false.) THEN
                  edep = pzero
                ELSE
                  vstep = ustep
                  tvstep = vstep
                  edep = pzero
                  e_range = vacdst
                  IARG=0
                  IF ((IAUSFL(IARG+1).NE.0)) THEN
                    CALL AUSGAB(IARG)
                  END IF
                  x(np) = x(np) + u(np)*vstep
                  y(np) = y(np) + v(np)*vstep
                  z(np) = z(np) + w(np)*vstep
                  dnear(np) = dnear(np) - vstep
                END IF
              END IF
              IF ((irnew .NE. irold)) THEN
                ir(np) = irnew
                irl = irnew
                medium = med(irl)
              END IF
              IF ((ustep .NE. 0)) THEN
                IARG=5
                IF ((IAUSFL(IARG+1).NE.0)) THEN
                  CALL AUSGAB(IARG)
                END IF
              END IF
              IF ((eie .LE. ecut(irl))) THEN
                go to 10800
              END IF
              IF ((ustep .NE. 0 .AND. idisc .LT. 0)) THEN
                go to 10810
              END IF
              GO TO 10821
            END IF
            vstep = ustep
            IF ((callhowfar)) THEN
              IF ((exact_bca)) THEN
                tvstep = vstep
                IF ((tvstep .NE. tustep)) THEN
                  dosingle = .false.
                END IF
              ELSE
                IF (( vstep .LT. ustep0 )) THEN
                  ekems = eke - 0.5*tustep*vstep/ustep0*dedx
                  p2 = ekems*(ekems+rmt2)
                  beta2 = p2/(p2 + rmsq)
                  chia2 = xccl/(4*blccl*p2)
                  xi = 0.5*xccl/p2/beta2*vstep
                  IF (( spin_effects )) THEN
                    elkems = Log(ekems)
                    Lelkems=eke1(MEDIUM)*elkems+eke0(MEDIUM)
                    IF ((lelec .LT. 0)) THEN
                      etap=etae_ms1(Lelkems,MEDIUM)*elkems+etae_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1ce_ms1(Lelkems,MEDIUM)*elkems+q1ce_ms0(L
     *                elkems,MEDIUM)
                    ELSE
                      etap=etap_ms1(Lelkems,MEDIUM)*elkems+etap_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1cp_ms1(Lelkems,MEDIUM)*elkems+q1cp_ms0(L
     *                elkems,MEDIUM)
                    END IF
                    chia2 = chia2*etap
                    xi = xi*xi_corr
                    ms_corr=blcce1(Lelkems,MEDIUM)*elkems+blcce0(Lelkems
     *              ,MEDIUM)
                    blccl = blccl*ms_corr
                  ELSE
                    xi_corr = 1
                    etap = 1
                  END IF
                  xi = xi*(Log(1+1./chia2)-1/(1+chia2))
                  IF (( xi .LT. 0.1 )) THEN
                    tvstep = vstep*(1 + xi*(0.5 + xi*0.333333))
                  ELSE
                    IF (( xi .LT. 0.999999 )) THEN
                      tvstep = -vstep*Log(1 - xi)/xi
                    ELSE
                      write(6,*) ' Stoped in SET-TVSTEP because xi > 1!
     *'
                      write(1,*) ' Stoped in SET-TVSTEP because xi > 1!
     *'
                      write(6,*) ' Medium: ',medium
                      write(1,*) ' Medium: ',medium
                      write(6,*) ' Initial energy: ',eke
                      write(1,*) ' Initial energy: ',eke
                      write(6,*) ' Average step energy: ',ekems
                      write(1,*) ' Average step energy: ',ekems
                      write(6,*) ' tustep: ',tustep
                      write(1,*) ' tustep: ',tustep
                      write(6,*) ' ustep0: ',ustep0
                      write(1,*) ' ustep0: ',ustep0
                      write(6,*) ' vstep:  ',vstep
                      write(1,*) ' vstep:  ',vstep
                      write(6,*) ' ==> xi = ',xi
                      write(1,*) ' ==> xi = ',xi
                      write(i_log,'(/a)') '***************** Error: '
                      write(i_log,*) 'This is a fatal error condition'
                      write(i_log,'(/a)') '***************** Quiting now
     *.'
                      call exit(1)
                    END IF
                  END IF
                ELSE
                  tvstep = tustep
                END IF
              END IF
              tuss = range - range_ep(qel,lelke,medium)/rhof
              IF (( tuss .GE. tvstep )) THEN
                IF (( lelec .LT. 0 )) THEN
                  dedxmid=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
                  aux = ededx1(lelke,medium)/dedxmid
                ELSE
                  dedxmid=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
                  aux = pdedx1(lelke,medium)/dedxmid
                END IF
                de = dedxmid*tvstep*rhof
                fedep = de/eke
                de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.25*
     *          fedep*(2-aux*(4-aux)))))
              ELSE
                lelktmp = lelke
                tuss = (range - tvstep)*rhof
                IF (( tuss .LE. 0 )) THEN
                  de = eke - TE(medium)*0.99
                ELSE
10871             IF(tuss.GE.range_ep(qel,lelktmp,medium))GO TO 10872
                    lelktmp = lelktmp - 1
                  GO TO 10871
10872             CONTINUE
                  elktmp = (lelktmp+1-eke0(medium))/eke1(medium)
                  eketmp = E_array(lelktmp+1,medium)
                  tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof
                  IF (( lelec .LT. 0 )) THEN
                    dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelktmp
     *              ,MEDIUM)
                    aux = ededx1(lelktmp,medium)/dedxmid
                  ELSE
                    dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelktmp
     *              ,MEDIUM)
                    aux = pdedx1(lelktmp,medium)/dedxmid
                  END IF
                  de = dedxmid*tuss*rhof
                  fedep = de/eketmp
                  de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.2
     *            5*fedep*(2-aux*(4-aux)))))
                  de = de + eke - eketmp
                END IF
              END IF
            ELSE
              tvstep = tustep
              IF (( .NOT.callmsdist )) THEN
                tuss = range - range_ep(qel,lelke,medium)/rhof
                IF (( tuss .GE. tvstep )) THEN
                  IF (( lelec .LT. 0 )) THEN
                    dedxmid=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIU
     *              M)
                    aux = ededx1(lelke,medium)/dedxmid
                  ELSE
                    dedxmid=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIU
     *              M)
                    aux = pdedx1(lelke,medium)/dedxmid
                  END IF
                  de = dedxmid*tvstep*rhof
                  fedep = de/eke
                  de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.2
     *            5*fedep*(2-aux*(4-aux)))))
                ELSE
                  lelktmp = lelke
                  tuss = (range - tvstep)*rhof
                  IF (( tuss .LE. 0 )) THEN
                    de = eke - TE(medium)*0.99
                  ELSE
10881               IF(tuss.GE.range_ep(qel,lelktmp,medium))GO TO 10882
                      lelktmp = lelktmp - 1
                    GO TO 10881
10882               CONTINUE
                    elktmp = (lelktmp+1-eke0(medium))/eke1(medium)
                    eketmp = E_array(lelktmp+1,medium)
                    tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof
                    IF (( lelec .LT. 0 )) THEN
                      dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelkt
     *                mp,MEDIUM)
                      aux = ededx1(lelktmp,medium)/dedxmid
                    ELSE
                      dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelkt
     *                mp,MEDIUM)
                      aux = pdedx1(lelktmp,medium)/dedxmid
                    END IF
                    de = dedxmid*tuss*rhof
                    fedep = de/eketmp
                    de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0
     *              .25*fedep*(2-aux*(4-aux)))))
                    de = de + eke - eketmp
                  END IF
                END IF
              END IF
            END IF
            save_de = de
            edep = de
            ekef = eke - de
            eold = eie
            enew = eold - de
            IF (( .NOT.callmsdist )) THEN
              IF (( domultiple )) THEN
                lambda = blccl*tvstep/beta2/etap/(1+chia2)
                xi = xi/xi_corr
                findindex = .true.
                spin_index = .true.
                call mscat(lambda,chia2,xi,elkems,beta2,qel,medium, spin
     *          _effects,findindex,spin_index, costhe,sinthe)
              ELSE
                IF ((dosingle)) THEN
                  ekems = Max(ekef,ecut(irl)-rm)
                  p2 = ekems*(ekems + rmt2)
                  beta2 = p2/(p2 + rmsq)
                  chia2 = xcc(medium)/(4*blcc(medium)*p2)
                  IF (( spin_effects )) THEN
                    elkems = Log(ekems)
                    Lelkems=eke1(MEDIUM)*elkems+eke0(MEDIUM)
                    IF ((lelec .LT. 0)) THEN
                      etap=etae_ms1(Lelkems,MEDIUM)*elkems+etae_ms0(Lelk
     *                ems,MEDIUM)
                    ELSE
                      etap=etap_ms1(Lelkems,MEDIUM)*elkems+etap_ms0(Lelk
     *                ems,MEDIUM)
                    END IF
                    chia2 = chia2*etap
                  END IF
                  call sscat(chia2,elkems,beta2,qel,medium, spin_effects
     *            ,costhe,sinthe)
                ELSE
                  theta = 0
                  sinthe = 0
                  costhe = 1
                END IF
              END IF
            END IF
            e_range = range
            IF (( callmsdist )) THEN
              u_final = uscat
              v_final = vscat
              w_final = wscat
              x_final = xtrans
              y_final = ytrans
              z_final = ztrans
            ELSE
              IF (.NOT.(.false.)) THEN
                x_final = x(np) + u(np)*vstep
                y_final = y(np) + v(np)*vstep
                z_final = z(np) + w(np)*vstep
              END IF
              IF (( domultiple .OR. dosingle )) THEN
                u_tmp = u(np)
                v_tmp = v(np)
                w_tmp = w(np)
                call uphi(2,1)
                u_final = u(np)
                v_final = v(np)
                w_final = w(np)
                u(np) = u_tmp
                v(np) = v_tmp
                w(np) = w_tmp
              ELSE
                u_final = u(np)
                v_final = v(np)
                w_final = w(np)
              END IF
            END IF
            IARG=0
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            x(np) = x_final
            y(np) = y_final
            z(np) = z_final
            u(np) = u_final
            v(np) = v_final
            w(np) = w_final
            dnear(np) = dnear(np) - vstep
            irold = ir(np)
            peie = peie - edep
            eie = peie
            e(np) = peie
            IF (( irnew .EQ. irl .AND. eie .LE. ecut(irl))) THEN
              go to 10800
            END IF
            medold = medium
            IF ((medium .NE. 0)) THEN
              ekeold = eke
              eke = eie - rm
              elke = log(eke)
              Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
            END IF
            IF ((irnew .NE. irold)) THEN
              ir(np) = irnew
              irl = irnew
              medium = med(irl)
            END IF
            IARG=5
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            IF ((eie .LE. ecut(irl))) THEN
              go to 10800
            END IF
            IF ((idisc .LT. 0)) THEN
              go to 10810
            END IF
            IF((medium .NE. medold))GO TO 10821
            IF(IRNEW.NE.IROLD)GO TO 10821
            demfp = demfp - save_de*sig
            total_de = total_de - save_de
            total_tstep = total_tstep - tvstep*rhof
            IF (( total_tstep .LT. 1e-9 )) THEN
              demfp = 0
            END IF
            IF(((demfp .LT. 1.E-8)))GO TO10832
          GO TO 10831
10832     CONTINUE
          IF ((lelec .LT. 0)) THEN
            sigf=esig1(Lelke,MEDIUM)*elke+esig0(Lelke,MEDIUM)
            dedx0=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
            sigf = sigf/dedx0
          ELSE
            sigf=psig1(Lelke,MEDIUM)*elke+psig0(Lelke,MEDIUM)
            dedx0=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
            sigf = sigf/dedx0
          END IF
          sigratio = sigf/sig0
          IF((rng_seed .GT. 128))call ranmar_get
          rfict = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF(((rfict .LE. sigratio)))GO TO10822
        GO TO 10821
10822   CONTINUE
        IF ((lelec .LT. 0)) THEN
          ebr1=ebr11(Lelke,MEDIUM)*elke+ebr10(Lelke,MEDIUM)
          IF((rng_seed .GT. 128))call ranmar_get
          rnno24 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF ((rnno24 .LE. ebr1)) THEN
            go to 10890
          ELSE
            IF ((e(np) .LE. thmoll(medium) .AND. eii_flag .EQ. 0)) THEN
              IF ((ebr1 .LE. 0)) THEN
                go to 10790
              END IF
              go to 10890
            END IF
            IARG=8
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            call moller
            IARG=9
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            IF((iq(np) .EQ. 0))return
          END IF
          go to 10790
        END IF
        pbr1=pbr11(Lelke,MEDIUM)*elke+pbr10(Lelke,MEDIUM)
        IF((rng_seed .GT. 128))call ranmar_get
        rnno25 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF ((rnno25 .LT. pbr1)) THEN
          go to 10890
        END IF
        pbr2=pbr21(Lelke,MEDIUM)*elke+pbr20(Lelke,MEDIUM)
        IF ((rnno25 .LT. pbr2)) THEN
          IARG=10
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          call bhabha
          IARG=11
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          IF((iq(np) .EQ. 0))return
        ELSE
          IARG=12
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          call annih
          IARG=13
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          GO TO 10792
        END IF
      GO TO 10791
10792 CONTINUE
      return
10890 IARG=6
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      call brems
      IARG=7
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      IF ((iq(np) .EQ. 0)) THEN
        return
      ELSE
        go to 10790
      END IF
10800 IF (( medium .GT. 0 )) THEN
        IF ((eie .GT. ae(medium))) THEN
          idr = 1
          IF ((lelec .LT. 0)) THEN
            edep = e(np) - prm
          ELSE
            EDEP=PEIE-PRM
          END IF
        ELSE
          idr = 2
          edep = e(np) - prm
        END IF
      ELSE
        idr = 1
        edep = e(np) - prm
      END IF
      IARG=idr
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
10900 CONTINUE
      IF ((lelec .GT. 0)) THEN
        IF ((edep .LT. peie)) THEN
          IARG=28
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          call annih_at_rest
          IARG=14
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          return
        END IF
      END IF
      np = np - 1
      ircode = 2
      return
10810 idisc = abs(idisc)
      IF (((lelec .LT. 0) .OR. (idisc .EQ. 99))) THEN
        edep = e(np) - prm
      ELSE
        edep = e(np) + prm
      END IF
      IARG=3
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      IF((idisc .EQ. 99))goto 10900
      np = np - 1
      ircode = 2
      return
      end
      SUBROUTINE HATCH
      implicit none
      character*512 toUpper
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/BOUNDS/ECUT( 1001),PCUT( 1001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PHOTIN/ EBINDA(3), GE0(3),GE1(3), GMFP0(2000,3),GMFP1(2000,
     *3),GBR10(2000,3),GBR11(2000,3),GBR20(2000,3),GBR21(2000,3), RCO0(3
     *),RCO1(3), RSCT0(100,3),RSCT1(100,3), COHE0(2000,3),COHE1(2000,3),
     *  PHOTONUC0(2000,3),PHOTONUC1(2000,3), DPMFP, MPGEM(1,3), NGR(3)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      real*8 SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERVR/ CEXPTR,GWAIT,PATHL,DUMU,DUMX,DUMY,DUMZ, DELTAP,GWTO
     *LD,EPSLON,ARG,EXPMFP,ESAVEIN, IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM, IFO
     *RCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN, MEDTMP,IREJCT
      real*8 CEXPTR,GWAIT,DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,GWTOLD,EPSLON
     *,ARG, EXPMFP,ESAVEIN
      integer*4 NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN,IFORCE,IRODU
     *M, IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,IREJCT
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/ET_control/ smaxir( 1001),estepe,ximax,  skindepth_for_bca,
     *transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      COMMON/LBREMZ/CONST,DELC,EBREMZ,DELTAM,XLNZ
      real*4 CONST,DELC,EBREMZ,DELTAM,XLNZ
      COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN
      real*4 PIP,C,RME,HBAR,ECGS,EMKS,AN
      COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      real*4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680
      COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20), EPSTTL,NEPST,IEPST
     *,EPSTFLP, NELEPS,ZEPST(20),IAPRFL,IAPRIMP
      integer*4 ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP
      CHARACTER EPSTTL*80
      real*4 EPSTEN,EPSTD,WEPST
      COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU, RLCP,EDEN,RH
     *OP,XCCP,BLCCP,TEFF0P,XR0P
      real*4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP, XCCP
     *,BLCCP,TEFF0P,XR0P
      COMMON/LSPION/CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      real*4 CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV
      COMMON/PWLFIN/EPE,ZTHRE(8),ZEPE(8),NIPE,NALE
      real*4 EPE,ZTHRE,ZEPE
      integer*4 NIPE,NALE
      COMMON/RSLTS/NEL,AXE,BXE,AFE(500,8),BFE(500,8)
      real*4 AXE,BXE,AFE,BFE
      integer*4 NEL
      COMMON/SPCOMM/MEDTBL(24,73), NUMSTMED,STDATA(6,73)
      CHARACTER*4 MEDTBL
      integer*4 NUMSTMED
      real*4 STDATA
      COMMON/MIXDAT/NEP,LMED,PZP(50),ZELEMP(50),WAP(50),RHOZP(50), GASPP
     *,EZ,TPZ,IDSTRN(24)
      integer*4 NEP,LMED
      real*4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ
      CHARACTER*4 IDSTRN
      COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183
      real*4 ALRAD,ALRADP,A1440,A183
      COMMON/MIMSD/BMIN
      real*4 BMIN
      COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP
      real*4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP
      integer*4 IUNRSTP
      COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6), DE
     *LCMP,ALPHIP(2),BPARP(2),DELPOSP(2)
      real*4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP
      COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100)
      integer*4 NET
      real*4 ITBL,WATBL,RHOTBL
      CHARACTER*4 ASYMT
      COMMON/MEDINP/inpdensity_file(3),inpasym(3,50), inpstrn(24,3),pz4(
     *3,50), rhoz4(3,50),wa4(3,50),inpgasp(3)
      character*256 inpdensity_file
      CHARACTER*4 inpasym,inpstrn
      real*4 pz4,rhoz4,wa4,inpgasp
      real*4 XSIFP,WADUM,PZDUM,RHOZDUM,RLCDUM,ALKE,ALKEI
      integer*4 I01
      EXTERNAL ALKE,ALKEI,EFUNS
      CHARACTER*4 MEDTB1(24,20),MEDTB2(24,20),MEDTB3(24,20),MEDTB4(24,13
     *)
      EQUIVALENCE (MEDTBL(1,1),MEDTB1(1,1))
      EQUIVALENCE (MEDTBL(1,21),MEDTB2(1,1))
      EQUIVALENCE (MEDTBL(1,41),MEDTB3(1,1))
      EQUIVALENCE (MEDTBL(1,61),MEDTB4(1,1))
      real*4 STDAT1(6,20),STDAT2(6,20),STDAT3(6,20),STDAT4(6,13)
      EQUIVALENCE (STDATA(1,1),STDAT1(1,1))
      EQUIVALENCE (STDATA(1,21),STDAT2(1,1))
      EQUIVALENCE (STDATA(1,41),STDAT3(1,1))
      EQUIVALENCE (STDATA(1,61),STDAT4(1,1))
      CHARACTER*4 MBUF(72),MDLABL(8)
      real*8 ACD ,  ADEV ,  ASD ,  COST ,  CTHET ,  DEL ,  DFACT ,  DFAC
     *TI,  DUNITO,  DUNITR,  FNSSS ,  P ,  PZNORM,  RDEV ,  S2C2 ,  S2C2
     *MN,  S2C2MX,  SINT ,  SX ,  SXX ,  SXY ,   SY ,   WID ,  XS ,  XS0
     * ,  XS1 ,  XSI ,  WSS ,  YS ,  ZEROS(3)
      integer*4 I ,  I1ST ,  IB ,  ID ,  IE ,  IL ,  IM ,  IRAYL ,  IRN
     *,  ISTEST,  ISUB ,  ISS ,  IZ ,   IZZ ,  J ,  JR ,  LCTHET,  LMDL
     *,  LMDN ,  LTHETA,  MD ,  MXSINC,  NCMFP ,   NEKE ,   NGE ,   NGRI
     *M ,  NISUB ,  NLEKE ,    NM ,  NRANGE,    NRNA ,  NSEKE ,   NSGE ,
     *   NSINSS,  LOK(3)
      character*256 tmp_string
      integer*4 lnblnk1
      DATA MDLABL/' ','M','E','D','I','U','M','='/,LMDL/8/,LMDN/24/,DUNI
     *TO/1./
      DATA I1ST/1/,NSINSS/37/,MXSINC/1002/,ISTEST/0/,NRNA/1000/
      PIP=3.1415926536
      C=2.997925E+10
      HBAR=1.05450E-27
      ECGS=4.80298E-10
      EMKS=1.60210E-19
      AN=6.02252E+23
      RADDEG=180./PIP
      FSC = ECGS**2/(HBAR*C)
      ERGMEV = (1.E+6)*(EMKS*1.E+7)
      RME = PRM/C**2*ERGMEV
      RMP = PRM
      R0 = (ECGS**2)/(RME*C**2)
      RMPSQ = RMP*RMP
      A22P9 = RADDEG*SQRT(4.*PIP*AN)*ECGS**2/ERGMEV
      A6680 = 4.0*PIP*AN*(HBAR/(RME*C))**2*(0.885**2/(1.167*1.13))
      DATA AFACT/0.0/,SK/0.0/,X0/0.0/,X1/0.0/,CBAR/0.0/,IEV/0.0/
      DATA LMED/24/,NUMSTMED/73/
      DATA EPE/.01/,ZTHRE,ZEPE/16*0.0/,NIPE/20/,NALE/500/
      DATA BMIN/4.5/
      DATA ALRAD/5.31,4.79,4.74,4.71/,ALRADP/6.144,5.621,5.805,5.924/, A
     *1440/1194.0/,A183/184.15/
      DATA MEDTB1/ 'H','2','-','G','A','S',18*' ','H','2','-','L','I','Q
     *','U','I','D',15*' ','H','E','-','G','A','S',18*' ','L','I',22*' '
     *, 'B','E',22*' ','C','-','2','.','2','6','5',' ','G','/','C','M','
     **','*','3',9*' ','C','-','1','.','7','0',' ','G','/','C','M','*','
     **','3',10*' ', 'N','2','-','G','A','S',18*' ','O','2','-','G','A',
     *'S',18*' ','N','E','-','G','A','S',18*' ','N','A',22*' ', 'M','G',
     *22*' ','A','L',22*' ','S','I',22*' ','A','R','-','G','A','S',18*'
     *', 'K',23*' ','C','A',22*' ','T','I',22*' ','V',23*' ','M','N',22*
     *' ' /
      DATA MEDTB2/ 'F','E',22*' ','C','O',22*' ','N','I',22*' ','C','U',
     *22*' ','Z','N',22*' ', 'G','E',22*' ','S','E',22*' ','K','R','-','
     *G','A','S',18*' ','R','B',22*' ', 'M','O',22*' ','A','G',22*' ','C
     *','D',22*' ','I','N',22*' ','S','N',22*' ', 'X','E','-','G','A','S
     *',18*' ','C','S',22*' ','G','D',22*' ','T','A',22*' ', 'W',23*' ',
     *'P','T',22*' ' /
      DATA MEDTB3/ 'A','U',22*' ','H','G',22*' ','P','B',22*' ','R','N',
     *'-','G','A','S',18*' ', 'U',23*' ', 'A','I','R','-','G','A','S',17
     **' ','C','O','2','-','G','A','S',17*' ','P','O','L','Y','E','T','H
     *','Y','L','E','N','E',12*' ', 'P','O','L','Y','P','R','O','P','Y',
     *'L','E','N','E',11*' ','X','Y','L','E','N','E',18*' ','T','O','L',
     *'U','E','N','E',17*' ', 'N','Y','L','O','N',19*' ','V','I','N','Y'
     *,'L','T','O','L','U','E','N','E',12*' ','A','1','5','0','-','P','L
     *','A','S','T','I','C',12*' ', 'S','T','I','L','B','E','N','E',16*'
     * ','P','O','L','Y','S','T','Y','R','E','N','E',13*' ','A','N','T',
     *'H','R','A','C','E','N','E',14*' ', 'L','E','X','A','N',19*' ','L'
     *,'U','C','I','T','E',18*' ','H','2','O',21*' ' /
      DATA MEDTB4/ 'M','Y','L','A','R',19*' ', 'K','A','P','T','O','N',1
     *8*' ','L','I','F',21*' ','P','O','L','Y','V','I','N','Y','L','-','
     *C','L',12*' ', 'P','Y','R','E','X','-','G','L','A','S','S',13*' ',
     *'S','I','O','2',20*' ','C','A','F','2',20*' ', 'P','H','O','T','O'
     *,'E','M','U','L','S','I','O','N',11*' ','A','G','C','L',20*' ','N'
     *,'A','I',21*' ', 'L','I','I',21*' ','A','G','B','R',20*' ','C','S'
     *,'I',21*' ' /
      DATA STDAT1/ 0.03535,6.790,1.864,3.5,19.2,9.584, 0.09179,5.831,0.4
     *76,2.0,21.8,3.263, 0.0114,7.625,2.202,4.0,41.8,11.139, 0.3492,3.23
     *3,0.0966,2.0,40.0,3.122, 0.3518,3.034,-0.0089,2.0,63.7,2.785, 0.58
     *48,2.360,-0.0089,2.0,78.0,2.868, 0.7154,2.191,-0.0089,2.0,78.0,3.1
     *55, 0.2120,3.041,1.738,4.0,82.0,10.540, 0.2666,2.825,1.754,4.0,95.
     *0,10.700, 0.1202,3.357,2.073,4.5,137.0,11.904, 0.2204,3.103,0.4515
     *,2.8,149.0,5.053, 0.1714,3.223,0.2386,2.8,156.0,4.530, 0.3346,2.79
     *5,0.0966,2.5,166.0,4.239, 0.3755,2.720,0.0966,2.5,173.0,4.435, 0.1
     *902,2.982,1.764,4.5,188.0,11.948, 0.3041,2.674,0.2386,3.0,190.0,5.
     *642, 0.2177,2.874,0.1751,3.0,191.0,5.040, 0.1782,2.946,0.0485,3.0,
     *233.0,4.445, 0.1737,2.935,-0.0089,3.0,245.0,4.266, 0.1996,2.812,-0
     *.0089,3.0,272.0,4.270 /
      DATA STDAT2/ 0.2101,2.771,-0.0089,3.0,286.0,4.291, 0.2229,2.713,-0
     *.0089,3.0,297.0,4.260, 0.2504,2.619,-0.0089,3.0,311.0,4.312, 0.255
     *7,2.613,-0.0089,3.0,322.0,4.419, 0.3163,2.468,0.0485,3.0,330.0,4.6
     *91, 0.2809,2.647,0.2386,3.0,350.0,5.141, 0.2979,2.635,0.2386,3.0,3
     *48.0,5.321, 0.1519,3.030,1.716,4.8,352.0,12.512, 0.1450,3.078,0.45
     *15,3.5,363.0,6.478, 0.2228,2.824,0.1751,3.0,424.0,4.879, 0.3091,2.
     *563,-0.0089,3.0,470.0,5.063, 0.1853,2.819,0.0485,3.3,469.0,5.273,
     *0.2004,2.790,0.1751,3.3,487.0,5.517, 0.1898,2.839,0.2386,3.3,488.0
     *,5.534, 0.1329,3.020,1.563,5.0,482.0,12.728, 0.2214,2.784,0.4515,3
     *.5,488.0,6.914, 0.2068,2.686,0.0485,3.5,591.0,5.874, 0.1663,2.805,
     *0.1751,3.5,718.0,5.526, 0.1499,2.870,0.1751,3.5,727.0,5.406, 0.146
     *5,2.903,0.0966,3.5,790.0,5.473 /
      DATA STDAT3/ 0.1533,2.881,0.0966,3.5,790.0,5.575, 0.1824,2.798,0.2
     *386,3.5,800.0,5.961, 0.1861,2.814,0.2386,3.5,823.0,6.202, 0.1130,3
     *.023,1.537,5.3,794.0,13.284, 0.1362,3.034,0.2386,3.5,890.0,5.869,
     *0.2466,2.879,1.742,4.0,85.7,10.595, 0.1999,3.022,1.648,4.0,88.7,10
     *.239, 0.4875,2.544,0.1379,2.0,57.4,3.002, 0.2493,2.975,0.1537,2.3,
     *59.2,3.126, 0.2755,2.911,0.1695,2.3,61.8,3.270, 0.2830,2.890,0.172
     *2,2.3,62.5,3.303, 0.5345,2.439,0.1336,2.0,63.9,3.063, 0.3495,2.749
     *,0.1467,2.2,64.7,3.201, 0.5462,2.435,0.1329,2.0,65.1,3.110, 0.2989
     *,2.851,0.1731,2.3,67.7,3.367, 0.3670,2.724,0.1647,2.2,68.7,3.300,
     *0.5858,2.364,0.1146,2.0,69.5,3.151, 0.3865,2.664,0.1608,2.2,73.1,3
     *.321, 0.3996,2.606,0.1824,2.2,74.0,3.330, 0.2065,3.007,0.2400,2.5,
     *75.0,3.502 /
      DATA STDAT4/ 0.3124,2.782,0.1561,2.3,78.7,3.326, 0.4061,2.614,0.14
     *92,2.2,79.3,3.342, 0.1308,3.476,0.0171,2.5,94.0,3.167, 0.1873,2.96
     *2,0.1558,2.8,108.2,4.053, 0.2988,2.805,0.1479,2.5,134.0,3.971, 0.1
     *440,3.220,0.1385,2.8,139.2,4.003, 0.3750,2.592,0.0676,2.5,166.0,4.
     *065, 0.3416,2.496,0.1009,3.0,331.0,5.332, 0.1243,3.002,-0.0138,3.5
     *,398.4,5.344, 0.1560,2.926,0.1203,3.5,452.0,6.057, 0.1785,2.845,0.
     *0892,3.5,485.1,6.267, 0.1351,2.976,0.0358,3.5,487.2,5.616, 0.1796,
     *2.840,0.0395,3.5,553.1,6.281 /
      DATA NET/100/
      DATA ITBL/19.2,41.8,40.,63.7,76.0,78.0,82.0,95.0,115.,137., 149.,1
     *56.,166.,173.,173.,180.,174.,188.,190.,191.,216.,233.,245., 257.,2
     *72.,286.,297.,311.,322.,330.,334.,350.,347.,348.,357.,352., 363.,3
     *66.,379.,393.,417.,424.,428.,441.,449.,470.,470.,469.,488., 488.,4
     *87.,485.,491.,482.,488.,491.,501.,523.,535.,546.,560.,574., 580.,5
     *91.,614.,628.,650.,658.,674.,684.,694.,705.,718.,727.,736., 746.,7
     *57.,790.,790.,800.,810.,823.,823.,830.,825.,794.,827.,826., 841.,8
     *47.,878.,890.,902.,921.,934.,939.,952.,966.,980.,994./
      DATA WATBL/1.00797,4.0026,6.939,9.0122,10.811,12.01115,14.0067, 15
     *.9994,18.9984,20.183,22.9898,24.312,26.9815,28.088,30.9738, 32.064
     *,35.453,39.948,39.102,40.08,44.956,47.90,50.942,51.998, 54.9380,55
     *.847,58.9332,58.71,63.54,65.37,69.72,72.59,74.9216, 78.96,79.808,8
     *3.80,85.47,87.62,88.905,91.22,92.906,95.94,99.0, 101.07,102.905,10
     *6.4,107.87,112.4,114.82,118.69,121.75,127.60, 126.9044,131.30,132.
     *905,137.34,138.91, 140.12,140.907,144.24,147.,150.35,151.98,157.25
     *,158.924,162.50, 164.930,167.26,168.934,173.04,174.97,178.49,180.9
     *48,183.85, 186.2,190.2,192.2,195.08,196.987,200.59,204.37,207.19,2
     *08.980, 210.,210.,222.,223.,226.,227.,232.036,231.,238.03,237.,242
     *., 243.,247.,247.,248.,254.,253./
      DATA RHOTBL/0.0808,0.19,0.534,1.85,2.5,2.26,1.14,1.568,1.5,1.0, 0.
     *9712,1.74,2.702,2.4,1.82,2.07,2.2,1.65,0.86,1.55,3.02,4.54, 5.87,7
     *.14,7.3,7.86,8.71,8.90,8.9333,7.140,5.91,5.36,5.73,4.80, 4.2,3.4,1
     *.53,2.6,4.47,6.4,8.57,9.01,11.50,12.20,12.50,12.,10.5, 8.65,7.30,7
     *.31,6.684,6.24,4.93,2.7,1.873,3.5,6.15,6.90,6.769, 7.007, 1. ,7.54
     *,5.17,7.87,8.25,8.56,8.80,9.06,9.32,6.96,9.85, 11.40,16.60,19.30,2
     *0.53,22.48,22.42,21.45,19.30,14.19,11.85, 11.34,9.78,9.30, 1. ,4.,
     * 1. ,5., 1. ,11.0,15.37,18.90, 20.5,19.737,11.7,7.,1. , 1. , 1. ,
     *1. /
      DATA ASYMT/'H','HE','LI','BE','B','C','N','O','F','NE', 'NA','MG',
     *'AL','SI','P','S','CL','AR','K','CA','SC','TI', 'V','CR','MN','FE'
     *,'CO','NI','CU','ZN','GA','GE','AS','SE','BR', 'KR','RB','SR','Y',
     *'ZR','NB','MO','TC','RU','RH','PD','AG','CD', 'IN','SN','SB','TE',
     *'I','XE','CS','BA','LA','CE','PR','ND', 'PM','SM','EU','GD','TB','
     *DY','HO','ER','TM','YB','LU','HF','TA', 'W','RE','OS','IR','PT','A
     *U','HG','TL','PB','BI','PO','AT','RN', 'FR','RA','AC','TH','PA','U
     *','NP','PU','AM','CM','BK','CF','ES', 'FM'/
      DATA EPSTFLP/0/,IEPST/1/,IAPRIMP/1/,IAPRFL/0/
10910 FORMAT(1X,14I5)
10920 FORMAT(1X,1PE14.5,4E14.5)
10930 FORMAT(72A1)
      IF ((I1ST.NE.0)) THEN
        I1ST=0
        DO 10941 J=1, 1001
          IF ((SMAXIR(J).LE.0.0)) THEN
            SMAXIR(J)=1E10
          END IF
10941   CONTINUE
10942   CONTINUE
        NISUB=MXSINC-2
        FNSSS=NSINSS
        WID=PI5D2/FLOAT(NISUB)
        WSS=WID/(FNSSS-1.0)
        ZEROS(1)=0.
        ZEROS(2)=PI
        ZEROS(3)=TWOPI
        DO 10951 ISUB=1,MXSINC
          SX=0.
          SY=0.
          SXX=0.
          SXY=0.
          XS0=WID*FLOAT(ISUB-2)
          XS1=XS0+WID
          IZ=0
          DO 10961 IZZ=1,3
            IF (((XS0.LE.ZEROS(IZZ)).AND.(ZEROS(IZZ).LE.XS1))) THEN
              IZ=IZZ
              GO TO10962
            END IF
10961     CONTINUE
10962     CONTINUE
          IF ((IZ.EQ.0)) THEN
            XSI=XS0
          ELSE
            XSI=ZEROS(IZ)
          END IF
          DO 10971 ISS=1,NSINSS
            XS=WID*FLOAT(ISUB-2)+WSS*FLOAT(ISS-1)-XSI
            YS=SIN(XS+XSI)
            SX=SX+XS
            SY=SY+YS
            SXX=SXX+XS*XS
            SXY=SXY+XS*YS
10971     CONTINUE
10972     CONTINUE
          IF ((IZ.NE.0)) THEN
            SIN1(ISUB)=SXY/SXX
            SIN0(ISUB)=-SIN1(ISUB)*XSI
          ELSE
            DEL=FNSSS*SXX-SX*SX
            SIN1(ISUB)=(FNSSS*SXY-SY*SX)/DEL
            SIN0(ISUB)=(SY*SXX-SX*SXY)/DEL - SIN1(ISUB)*XSI
          END IF
10951   CONTINUE
10952   CONTINUE
        SINC0=2.0
        SINC1=1.0/WID
        IF ((ISTEST.NE.0)) THEN
          ADEV=0.
          RDEV=0.
          S2C2MN=10.
          S2C2MX=0.
          DO 10981 ISUB=1,NISUB
            DO 10991 ISS=1,NSINSS
              THETA=WID*FLOAT(ISUB-1)+WSS*FLOAT(ISS-1)
              CTHET=PI5D2-THETA
              SINTHE=sin(THETA)
              COSTHE=sin(CTHET)
              SINT=SIN(THETA)
              COST=COS(THETA)
              ASD=ABS(SINTHE-SINT)
              ACD=ABS(COSTHE-COST)
              ADEV=max(ADEV,ASD,ACD)
              IF((SINT.NE.0.0))RDEV=max(RDEV,ASD/ABS(SINT))
              IF((COST.NE.0.0))RDEV=max(RDEV,ACD/ABS(COST))
              S2C2=SINTHE**2+COSTHE**2
              S2C2MN=min(S2C2MN,S2C2)
              S2C2MX=max(S2C2MX,S2C2)
              IF ((ISUB.LT.11)) THEN
                write(6,'(1PE20.7,4E20.7)') THETA,SINTHE,SINT,COSTHE,COS
     *          T
                write(1,'(1PE20.7,4E20.7)') THETA,SINTHE,SINT,COSTHE,COS
     *          T
              END IF
10991       CONTINUE
10992       CONTINUE
10981     CONTINUE
10982     CONTINUE
          write(6,'(a,2i5)') ' SINE TESTS,MXSINC,NSINSS=',MXSINC,NSINSS
          write(1,'(a,2i5)') ' SINE TESTS,MXSINC,NSINSS=',MXSINC,NSINSS
          write(6,'(a,1PE16.8,3e16.8)') ' ADEV,RDEV,S2C2(MN,MX) =', ADEV
     *    ,RDEV,S2C2MN,S2C2MX
          write(1,'(a,1PE16.8,3e16.8)') ' ADEV,RDEV,S2C2(MN,MX) =', ADEV
     *    ,RDEV,S2C2MN,S2C2MX
          ADEV=0.
          RDEV=0.
          S2C2MN=10.
          S2C2MX=0.
          DO 11001 IRN=1,NRNA
            IF((rng_seed .GT. 128))call ranmar_get
            THETA = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            THETA=THETA*PI5D2
            CTHET=PI5D2-THETA
            SINTHE=sin(THETA)
            COSTHE=sin(CTHET)
            SINT=SIN(THETA)
            COST=COS(THETA)
            ASD=ABS(SINTHE-SINT)
            ACD=ABS(COSTHE-COST)
            ADEV=max(ADEV,ASD,ACD)
            IF((SINT.NE.0.0))RDEV=max(RDEV,ASD/ABS(SINT))
            IF((COST.NE.0.0))RDEV=max(RDEV,ACD/ABS(COST))
            S2C2=SINTHE**2+COSTHE**2
            S2C2MN=min(S2C2MN,S2C2)
            S2C2MX=max(S2C2MX,S2C2)
11001     CONTINUE
11002     CONTINUE
          write(6,'(a,i7,a)') ' TEST AT ',NRNA,' RANDOM ANGLES IN (0,5*P
     *I/2)'
          write(1,'(a,i7,a)') ' TEST AT ',NRNA,' RANDOM ANGLES IN (0,5*P
     *I/2)'
          write(6,'(1PE16.8,3E16.8)') ' ADEV,RDEV,S2C2(MN,MX) =', ADEV,R
     *    DEV,S2C2MN,S2C2MX
          write(1,'(1PE16.8,3E16.8)') ' ADEV,RDEV,S2C2(MN,MX) =', ADEV,R
     *    DEV,S2C2MN,S2C2MX
        END IF
        P=1.
        DO 11011 I=1,50
          PWR2I(I)=P
          P=P/2.
11011   CONTINUE
11012   CONTINUE
      END IF
      DO 11021 J=1,NMED
11030   CONTINUE
          DO 11031 I=1, 1001
          IF ((IRAYLR(I).EQ.1.AND.MED(I).EQ.J)) THEN
            IRAYLM(J)=1
            GO TO 11032
          END IF
11031   CONTINUE
11032   CONTINUE
11021 CONTINUE
11022 CONTINUE
      IPHOTONUC=0
      DO 11041 J=1,NMED
11050   CONTINUE
          DO 11051 I=1, 1001
          IF ((IPHOTONUCR(I).EQ.1.AND.MED(I).EQ.J)) THEN
            IPHOTONUCM(J)=1
            IPHOTONUC=1
            GO TO 11052
          END IF
11051   CONTINUE
11052   CONTINUE
11041 CONTINUE
11042 CONTINUE
      write(6,'(a,i3)') ' ===> Photonuclear flag: ', iphotonuc
      write(1,'(a,i3)') ' ===> Photonuclear flag: ', iphotonuc
      IF((.NOT.is_pegsless))REWIND KMPI
      NM=0
      DO 11061 IM=1,NMED
        LOK(IM)=0
        IF ((IRAYLM(IM).EQ.1)) THEN
          write(6,'(a,i3/)') ' RAYLEIGH OPTION REQUESTED FOR MEDIUM NUMB
     *ER',IM
          write(1,'(a,i3/)') ' RAYLEIGH OPTION REQUESTED FOR MEDIUM NUMB
     *ER',IM
        END IF
11061 CONTINUE
11062 CONTINUE
      DO 11071 IM=1,NMED
        IF ((IPHOTONUCM(IM).EQ.1)) THEN
          write(6,'(a,i3/)') ' PHOTONUCLEAR REQUESTED FOR MEDIUM NUMBER'
     *    ,IM
          write(1,'(a,i3/)') ' PHOTONUCLEAR REQUESTED FOR MEDIUM NUMBER'
     *    ,IM
        END IF
11071 CONTINUE
11072 CONTINUE
      IF ((.NOT.is_pegsless)) THEN
11080   CONTINUE
11081     CONTINUE
11090     CONTINUE
11091       CONTINUE
            READ(KMPI,10930,END=11100)MBUF
            DO 11111 IB=1,LMDL
              IF((MBUF(IB).NE.MDLABL(IB)))GO TO 11091
11111       CONTINUE
11112       CONTINUE
11120       CONTINUE
              DO 11121 IM=1,NMED
              DO 11131 IB=1,LMDN
                IL=LMDL+IB
                IF((MBUF(IL).NE.MEDIA(IB,IM)))GO TO 11121
                IF((IB.EQ.LMDN))GO TO 11092
11131         CONTINUE
11132         CONTINUE
11121       CONTINUE
11122       CONTINUE
          GO TO 11091
11092     CONTINUE
          IF((LOK(IM).NE.0))GO TO 11090
          LOK(IM)=1
          NM=NM+1
          read(kmpi,'(a)',err=11140) tmp_string
          goto 11150
11140     write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'Error while reading pegs4 file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
11150     CONTINUE
          read(tmp_string,1,ERR=11160)  (MBUF(I),I=1,5),RHO(IM),NNE(IM),
     *    IUNRST(IM),EPSTFL(IM),IAPRIM(IM)
1         FORMAT(5A1,5X,F11.0,4X,I2,9X,I1,9X,I1,9X,I1)
          GO TO 11170
11160     CONTINUE
          write(6,*) 'Found medium with gas pressure'
          write(1,*) 'Found medium with gas pressure'
          read(tmp_string,2) (MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),
     *    EPSTFL(IM), IAPRIM(IM)
2         FORMAT(5A1,5X,F11.0,4X,I2,26X,I1,9X,I1,9X,I1)
11170     CONTINUE
            DO 11171 IE=1,NNE(IM)
            READ(KMPI,11180)(MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2), ZELEM
     *      (IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE)
11180       FORMAT (6A1,2A1,3X,F3.0,3X,F9.0,4X,F12.0,6X,F12.0)
11171     CONTINUE
11172     CONTINUE
          READ(KMPI,10920) RLC(IM),AE(IM),AP(IM),UE(IM),UP(IM)
          TE(IM)=AE(IM)-RM
          THMOLL(IM)=TE(IM)*2. + RM
          READ(KMPI,10910) MSGE(IM),MGE(IM),MSEKE(IM),MEKE(IM),MLEKE(IM)
     *    ,MCMFP(IM),MRANGE(IM),IRAYL
          NSGE=MSGE(IM)
          NGE=MGE(IM)
          NSEKE=MSEKE(IM)
          NEKE=MEKE(IM)
          NLEKE=MLEKE(IM)
          NCMFP=MCMFP(IM)
          NRANGE=MRANGE(IM)
          READ(KMPI,10920)(DL1(I,IM),DL2(I,IM),DL3(I,IM),DL4(I,IM),DL5(I
     *    ,IM),DL6(I,IM),I=1,6)
          READ(KMPI,10920)DELCM(IM),(ALPHI(I,IM),BPAR(I,IM),DELPOS(I,IM)
     *    ,I=1,2)
          READ(KMPI,10920)XR0(IM),TEFF0(IM),BLCC(IM),XCC(IM)
          READ(KMPI,10920)EKE0(IM),EKE1(IM)
          READ(KMPI,10920) (ESIG0(I,IM),ESIG1(I,IM),PSIG0(I,IM),PSIG1(I,
     *    IM),EDEDX0(I,IM),EDEDX1(I,IM),PDEDX0(I,IM),PDEDX1(I,IM),EBR10(
     *    I,IM),EBR11(I,IM),PBR10(I,IM),PBR11(I,IM),PBR20(I,IM),PBR21(I,
     *    IM),TMXS0(I,IM),TMXS1(I,IM),I=1,NEKE)
          READ(KMPI,10920)EBINDA(IM),GE0(IM),GE1(IM)
          READ(KMPI,10920)(GMFP0(I,IM),GMFP1(I,IM),GBR10(I,IM),GBR11(I,I
     *    M),GBR20(I,IM),GBR21(I,IM),I=1,NGE)
          IF ((IRAYL.EQ.1)) THEN
            READ(KMPI,10910) NGR(IM)
            NGRIM=NGR(IM)
            READ(KMPI,10920)RCO0(IM),RCO1(IM)
            READ(KMPI,10920)(RSCT0(I,IM),RSCT1(I,IM),I=1,NGRIM)
            READ(KMPI,10920)(COHE0(I,IM),COHE1(I,IM),I=1,NGE)
            write(6,'(a,i3,a)') ' Rayleigh data available for medium', I
     *      M, ' in PEGS4 data set.'
            write(1,'(a,i3,a)') ' Rayleigh data available for medium', I
     *      M, ' in PEGS4 data set.'
          END IF
          IF ((IRAYLM(IM).EQ.1)) THEN
            IF ((IRAYL.NE.1)) THEN
              IF ((toUpper(photon_xsections(:lnblnk1(photon_xsections)))
     *        .EQ.'PEGS4')) THEN
                write(i_log,'(/a)') '***************** Error: '
                write(i_log,'(a,i3 /,a /,a)') ' IN HATCH: REQUESTED RAYL
     *EIGH OPTION FOR MEDIUM', IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PE
     *GS4 FILE.', ' YOU WILL NOT BE ABLE TO USE THE PEGS4 DATA WITH RAYL
     *EIGH ON!'
                write(i_log,'(/a)') '***************** Quiting now.'
                call exit(1)
              ELSE
                write(i_log,'(/a)') '***************** Warning: '
                write(i_log,'(a,i3 /,a)') ' IN HATCH: REQUESTED RAYLEIGH
     * OPTION FOR MEDIUM', IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4
     *FILE.'
              END IF
            ELSE
              IF ((toUpper(photon_xsections(:lnblnk1(photon_xsections)))
     *        .EQ.'PEGS4')) THEN
                call egs_init_rayleigh_sampling(IM)
              END IF
            END IF
          END IF
          IF((NM.GE.NMED))GO TO11082
        GO TO 11081
11082   CONTINUE
        CLOSE (UNIT=KMPI)
        DUNITR=DUNIT
        IF ((DUNIT.LT.0.0)) THEN
          ID=MAX0(1,MIN0(3,int(-DUNIT)))
          DUNIT=RLC(ID)
        END IF
        IF ((DUNIT.NE.1.0)) THEN
          write(6,'(a,1PE14.5,E14.5,a)') ' DUNIT REQUESTED&USED ARE: ',
     *    DUNITR,DUNIT,'(CM.)'
          write(1,'(a,1PE14.5,E14.5,a)') ' DUNIT REQUESTED&USED ARE: ',
     *    DUNITR,DUNIT,'(CM.)'
        END IF
        DO 11191 IM=1,NMED
          DFACT=RLC(IM)/DUNIT
          DFACTI=1.0/DFACT
          I=1
            GO TO 11203
11201       I=I+1
11203       IF(I-(MEKE(IM)).GT.0)GO TO 11202
            ESIG0(I,IM)=ESIG0(I,IM)*DFACTI
            ESIG1(I,IM)=ESIG1(I,IM)*DFACTI
            PSIG0(I,IM)=PSIG0(I,IM)*DFACTI
            PSIG1(I,IM)=PSIG1(I,IM)*DFACTI
            EDEDX0(I,IM)=EDEDX0(I,IM)*DFACTI
            EDEDX1(I,IM)=EDEDX1(I,IM)*DFACTI
            PDEDX0(I,IM)=PDEDX0(I,IM)*DFACTI
            PDEDX1(I,IM)=PDEDX1(I,IM)*DFACTI
            TMXS0(I,IM)=TMXS0(I,IM)*DFACT
            TMXS1(I,IM)=TMXS1(I,IM)*DFACT
          GO TO 11201
11202     CONTINUE
          TEFF0(IM)=TEFF0(IM)*DFACT
          BLCC(IM)=BLCC(IM)*DFACTI
          XCC(IM)=XCC(IM)*SQRT(DFACTI)
          RLDU(IM)=RLC(IM)/DUNIT
          I=1
            GO TO 11213
11211       I=I+1
11213       IF(I-(MGE(IM)).GT.0)GO TO 11212
            GMFP0(I,IM)=GMFP0(I,IM)*DFACT
            GMFP1(I,IM)=GMFP1(I,IM)*DFACT
          GO TO 11211
11212     CONTINUE
11191   CONTINUE
11192   CONTINUE
        VACDST=VACDST*DUNITO/DUNIT
        DUNITO=DUNIT
      ELSE
        write(6,*) ' PEGSLESS INPUT.  CALCULATING ELECTRON CROSS-SECTION
     *S.'
        write(1,*) ' PEGSLESS INPUT.  CALCULATING ELECTRON CROSS-SECTION
     *S.'
        call get_media_inputs(-1)
        DO 11221 IM=1,NMED
          AEP=AE(IM)
          UEP=UE(IM)
          APP=AP(IM)
          UPP=UP(IM)
          NEP=NNE(IM)
          IUNRSTP=IUNRST(IM)
          IAPRIMP=IAPRIM(IM)
          EPSTFLP=EPSTFL(IM)
          GASPP=INPGASP(IM)
          RHOP=RHO(IM)
          DO 11231 J=1,NEP
            ZELEMP(J)=ZELEM(IM,J)
            PZP(J)=PZ4(IM,J)
            RHOZP(J)=RHOZ4(IM,J)
            WAP(J)=WA4(IM,J)
11231     CONTINUE
11232     CONTINUE
          DO 11241 IB=1,LMDN
            IDSTRN(IB)=INPSTRN(IB,IM)
11241     CONTINUE
11242     CONTINUE
          TEP=AEP-RMP
          THMOLLP=AEP+TEP
          IF ((UEP.LE.AEP)) THEN
            write(i_log,'(a,24a1)')'  Error: Material not defined: ', (m
     *      edia(j,IM),j=1,24)
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'Material used in the geometry was not define
     *d in the' ,' material data.'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          CALL MIX
          CALL SPINIT(inpdensity_file(IM))
          CALL DIFFER
          CALL PWLF1(NEL,NALE,AEP,UEP,THMOLLP,EPE,ZTHRE,ZEPE,NIPE,ALKE,
     *    ALKEI,AXE,BXE,500,8,AFE,BFE,EFUNS)
          TE(IM)=AE(IM)-RM
          THMOLL(IM)=TE(IM)*2. + RM
          RLC(IM)=RLCP
          XCC(IM)=XCCP
          BLCC(IM)=BLCCP
          XR0(IM)=XR0P
          TEFF0(IM)=TEFF0P
          DELCM(IM)=DELCMP
          DO 11251 I=1,2
            ALPHI(I,IM)=ALPHIP(I)
            BPAR(I,IM)=BPARP(I)
            DELPOS(I,IM)=DELPOSP(I)
11251     CONTINUE
11252     CONTINUE
          DO 11261 I=1,6
            DL1(I,IM)=DLP1(I)
            DL2(I,IM)=DLP2(I)
            DL3(I,IM)=DLP3(I)
            DL4(I,IM)=DLP4(I)
            DL5(I,IM)=DLP5(I)
            DL6(I,IM)=DLP6(I)
11261     CONTINUE
11262     CONTINUE
          MSGE(IM)=0
          MSEKE(IM)=0
          MLEKE(IM)=0
          MCMFP(IM)=0
          MRANGE(IM)=0
          MGE(IM)=2000
          MEKE(IM)=NEL
          NSGE=MSGE(IM)
          NGE=MGE(IM)
          NSEKE=MSEKE(IM)
          NEKE=MEKE(IM)
          NLEKE=MLEKE(IM)
          NCMFP=MCMFP(IM)
          NRANGE=MRANGE(IM)
          EKE0(IM)=BXE
          EKE1(IM)=AXE
          DO 11271 I=1,NEKE
            ESIG0(I,IM)=BFE(I,1)
            ESIG1(I,IM)=AFE(I,1)
            PSIG0(I,IM)=BFE(I,2)
            PSIG1(I,IM)=AFE(I,2)
            EDEDX0(I,IM)=BFE(I,3)
            EDEDX1(I,IM)=AFE(I,3)
            PDEDX0(I,IM)=BFE(I,4)
            PDEDX1(I,IM)=AFE(I,4)
            EBR10(I,IM)=BFE(I,5)
            EBR11(I,IM)=AFE(I,5)
            PBR10(I,IM)=BFE(I,6)
            PBR11(I,IM)=AFE(I,6)
            PBR20(I,IM)=BFE(I,7)
            PBR21(I,IM)=AFE(I,7)
            TMXS0(I,IM)=BFE(I,8)
            TMXS1(I,IM)=AFE(I,8)
11271     CONTINUE
11272     CONTINUE
11221   CONTINUE
11222   CONTINUE
        DUNITR=DUNIT
        IF ((DUNIT.LT.0.0)) THEN
          ID=MAX0(1,MIN0(3,int(-DUNIT)))
          DUNIT=RLC(ID)
        END IF
        IF ((DUNIT.NE.1.0)) THEN
          write(6,'(a,1PE14.5,E14.5,a)') ' DUNIT REQUESTED&USED ARE: ',
     *    DUNITR,DUNIT,'(CM.)'
          write(1,'(a,1PE14.5,E14.5,a)') ' DUNIT REQUESTED&USED ARE: ',
     *    DUNITR,DUNIT,'(CM.)'
        END IF
        DO 11281 IM=1,NMED
          DFACT=RLC(IM)/DUNIT
          DFACTI=1.0/DFACT
          I=1
            GO TO 11293
11291       I=I+1
11293       IF(I-(MEKE(IM)).GT.0)GO TO 11292
            ESIG0(I,IM)=ESIG0(I,IM)*DFACTI
            ESIG1(I,IM)=ESIG1(I,IM)*DFACTI
            PSIG0(I,IM)=PSIG0(I,IM)*DFACTI
            PSIG1(I,IM)=PSIG1(I,IM)*DFACTI
            EDEDX0(I,IM)=EDEDX0(I,IM)*DFACTI
            EDEDX1(I,IM)=EDEDX1(I,IM)*DFACTI
            PDEDX0(I,IM)=PDEDX0(I,IM)*DFACTI
            PDEDX1(I,IM)=PDEDX1(I,IM)*DFACTI
            TMXS0(I,IM)=TMXS0(I,IM)*DFACT
            TMXS1(I,IM)=TMXS1(I,IM)*DFACT
          GO TO 11291
11292     CONTINUE
          TEFF0(IM)=TEFF0(IM)*DFACT
          BLCC(IM)=BLCC(IM)*DFACTI
          XCC(IM)=XCC(IM)*SQRT(DFACTI)
          RLDU(IM)=RLC(IM)/DUNIT
          I=1
            GO TO 11303
11301       I=I+1
11303       IF(I-(MGE(IM)).GT.0)GO TO 11302
            GMFP0(I,IM)=GMFP0(I,IM)*DFACT
            GMFP1(I,IM)=GMFP1(I,IM)*DFACT
          GO TO 11301
11302     CONTINUE
11281   CONTINUE
11282   CONTINUE
        VACDST=VACDST*DUNITO/DUNIT
        DUNITO=DUNIT
        call show_media_parameters(i_log)
      END IF
      DO 11311 JR=1, 1001
        MD=MED(JR)
        IF (((MD.GE.1).AND.(MD.LE.NMED))) THEN
          ECUT(JR)=max(ECUT(JR),AE(MD))
          PCUT(JR)=max(PCUT(JR),AP(MD))
          IF ((RHOR(JR).EQ.0.0)) THEN
            RHOR(JR)=RHO(MD)
          END IF
        END IF
11311 CONTINUE
11312 CONTINUE
      IF ((IBRDST.EQ.1)) THEN
        DO 11321 IM=1,NMED
          ZBRANG(IM)=0.0
          PZNORM=0.0
          DO 11331 IE=1,NNE(IM)
            ZBRANG(IM)= ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+
     *      1.0)
            PZNORM=PZNORM+PZ(IM,IE)
11331     CONTINUE
11332     CONTINUE
          ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.)
          LZBRANG(IM)=-log(ZBRANG(IM))
11321   CONTINUE
11322   CONTINUE
      END IF
      IF ((IPRDST.GT.0)) THEN
        DO 11341 IM=1,NMED
          ZBRANG(IM)=0.0
          PZNORM=0.0
          DO 11351 IE=1,NNE(IM)
            ZBRANG(IM)= ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+
     *      1.0)
            PZNORM=PZNORM+PZ(IM,IE)
11351     CONTINUE
11352     CONTINUE
          ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.)
11341   CONTINUE
11342   CONTINUE
      END IF
      IF ((toUpper(photon_xsections(:lnblnk1(photon_xsections))) .EQ. 'P
     *EGS4')) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,'(6(a/))') 'Using photon data from PEGS4 file!!!', '
     *However, the new Rayleigh angular sampling will be used.', 'The or
     *iginal EGS4 angular sampling undersamples large scattering ', 'ang
     *les. This may have little impact as Rayleigh scattering ', 'is for
     *ward peaked.', '**************************************************
     ********'
      ELSE
        call egs_init_user_photon(photon_xsections,comp_xsections, photo
     *  nuc_xsections,xsec_out)
      END IF
      call mscati
      IF (( eadl_relax .AND. photon_xsections .EQ. 'xcom' )) THEN
        call init_compton
        call EDGSET(1,1)
      ELSE
        call EDGSET(1,1)
        call init_compton
      END IF
      IF (( xsec_out .EQ. 1 .AND. eadl_relax)) THEN
        call egs_print_binding_energies
      END IF
      call fix_brems
      IF (( ibr_nist .GE. 1 )) THEN
        call init_nist_brems
      END IF
      IF (( pair_nrc .EQ. 1 )) THEN
        call init_nrc_pair
      END IF
      call eii_init
      call init_triplet
      IF ((NMED.EQ.1)) THEN
        write(6,*) 'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ONE MEDIUM.'
        write(1,*) 'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ONE MEDIUM.'
      ELSE
        write(6,'(a,i5,a)') 'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ',NMED,
     *  ' MEDIA.'
        write(1,'(a,i5,a)') 'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ',NMED,
     *  ' MEDIA.'
      END IF
      RETURN
11100 write(6,'(a,i2//,a/,a/)') ' END OF FILE ON UNIT ',KMPI, ' PROGRAM
     *STOPPED IN HATCH BECAUSE THE', ' FOLLOWING NAMES WERE NOT RECOGNIZ
     *ED:'
      write(1,'(a,i2//,a/,a/)') ' END OF FILE ON UNIT ',KMPI, ' PROGRAM
     *STOPPED IN HATCH BECAUSE THE', ' FOLLOWING NAMES WERE NOT RECOGNIZ
     *ED:'
      DO 11361 IM=1,NMED
        IF ((LOK(IM).NE.1)) THEN
          write(6,'(40x,a,24a1,a)') '''',(MEDIA(I,IM),I=1,LMDN),''''
          write(1,'(40x,a,24a1,a)') '''',(MEDIA(I,IM),I=1,LMDN),''''
        END IF
11361 CONTINUE
11362 CONTINUE
      STOP
      END
      subroutine fix_brems
      implicit none
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/nist_brems/ nb_fdata(0:50,100,3), nb_xdata(0:50,100,3), nb_
     *wdata(50,100,3), nb_idata(50,100,3), nb_emin(3),nb_emax(3), nb_lem
     *in(3),nb_lemax(3), nb_dle(3),nb_dlei(3), log_ap(3)
      real*8 nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lema
     *x, nb_dle,nb_dlei,log_ap
      integer*4 nb_idata
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      integer*4 medium,i
      real*8 Zt,Zb,Zf,Zg,Zv,fmax1,fmax2,Zi,pi,fc,xi,aux, XSIF,FCOULC
      DO 11371 medium=1,nmed
        log_ap(medium) = log(ap(medium))
        Zt = 0
        Zb = 0
        Zf = 0
        DO 11381 i=1,NNE(medium)
          Zi = ZELEM(medium,i)
          pi = PZ(medium,i)
          fc = FCOULC(Zi)
          xi = XSIF(Zi)
          aux = pi*Zi*(Zi + xi)
          Zt = Zt + aux
          Zb = Zb - aux*Log(Zi)/3
          Zf = Zf + aux*fc
11381   CONTINUE
11382   CONTINUE
        Zv = (Zb - Zf)/Zt
        Zg = Zb/Zt
        fmax1 = 2*(20.863 + 4*Zg) - 2*(20.029 + 4*Zg)/3
        fmax2 = 2*(20.863 + 4*Zv) - 2*(20.029 + 4*Zv)/3
        dl1(1,medium) = (20.863 + 4*Zg)/fmax1
        dl2(1,medium) = -3.242/fmax1
        dl3(1,medium) = 0.625/fmax1
        dl4(1,medium) = (21.12+4*Zg)/fmax1
        dl5(1,medium) = -4.184/fmax1
        dl6(1,medium) = 0.952
        dl1(2,medium) = (20.029+4*Zg)/fmax1
        dl2(2,medium) = -1.93/fmax1
        dl3(2,medium) = -0.086/fmax1
        dl4(2,medium) = (21.12+4*Zg)/fmax1
        dl5(2,medium) = -4.184/fmax1
        dl6(2,medium) = 0.952
        dl1(3,medium) = (20.863 + 4*Zv)/fmax2
        dl2(3,medium) = -3.242/fmax2
        dl3(3,medium) = 0.625/fmax2
        dl4(3,medium) = (21.12+4*Zv)/fmax2
        dl5(3,medium) = -4.184/fmax2
        dl6(3,medium) = 0.952
        dl1(4,medium) = (20.029+4*Zv)/fmax2
        dl2(4,medium) = -1.93/fmax2
        dl3(4,medium) = -0.086/fmax2
        dl4(4,medium) = (21.12+4*Zv)/fmax2
        dl5(4,medium) = -4.184/fmax2
        dl6(4,medium) = 0.952
        dl1(5,medium) = (3*(20.863 + 4*Zg) - (20.029 + 4*Zg))
        dl2(5,medium) = (3*(-3.242) - (-1.930))
        dl3(5,medium) = (3*(0.625)-(-0.086))
        dl4(5,medium) = (2*21.12+8*Zg)
        dl5(5,medium) = (2*(-4.184))
        dl6(5,medium) = 0.952
        dl1(6,medium) = (3*(20.863 + 4*Zg) + (20.029 + 4*Zg))
        dl2(6,medium) = (3*(-3.242) + (-1.930))
        dl3(6,medium) = (3*0.625+(-0.086))
        dl4(6,medium) = (4*21.12+16*Zg)
        dl5(6,medium) = (4*(-4.184))
        dl6(6,medium) = 0.952
        dl1(7,medium) = (3*(20.863 + 4*Zv) - (20.029 + 4*Zv))
        dl2(7,medium) = (3*(-3.242) - (-1.930))
        dl3(7,medium) = (3*(0.625)-(-0.086))
        dl4(7,medium) = (2*21.12+8*Zv)
        dl5(7,medium) = (2*(-4.184))
        dl6(7,medium) = 0.952
        dl1(8,medium) = (3*(20.863 + 4*Zv) + (20.029 + 4*Zv))
        dl2(8,medium) = (3*(-3.242) + (-1.930))
        dl3(8,medium) = (3*0.625+(-0.086))
        dl4(8,medium) = (4*21.12+16*Zv)
        dl5(8,medium) = (4*(-4.184))
        dl6(8,medium) = 0.952
        bpar(2,medium) = dl1(7,medium)/(3*dl1(8,medium) + dl1(7,medium))
        bpar(1,medium) = 12*dl1(8,medium)/(3*dl1(8,medium) + dl1(7,mediu
     *  m))
11371 CONTINUE
11372 CONTINUE
      return
      end
      real*8 function FCOULC(Z)
      implicit none
      real*8 Z
      real*8 fine,asq
      data fine/137.03604/
      asq = Z/fine
      asq = asq*asq
      FCOULC = asq*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+ASQ*(0.0083+ASQ*(
     *-0.002))))
      return
      end
      real*8 function XSIF(Z)
      implicit none
      real*8 Z
      integer*4 iZ
      real*8 alrad(4),alradp(4),a1440,a183,FCOULC
      data alrad/5.31,4.79,4.74,4.71/
      data alradp/6.144,5.621,5.805,5.924/
      data a1440/1194.0/,A183/184.15/
      IF (( Z .LE. 4 )) THEN
        iZ = Z
        xsif = alradp(iZ)/(alrad(iZ) - FCOULC(Z))
      ELSE
        xsif = Log(A1440*Z**(-0.666667))/(Log(A183*Z**(-0.33333))-FCOULC
     *  (Z))
      END IF
      return
      end
      subroutine init_compton
      implicit none
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,3), eno_array(200,3), eno_atbin_array(200,3), n_sh
     *ell(3), radc_flag,  ibcmp( 1001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      integer*4 i,j,iz,nsh,j_l,j_h
      real*8 aux,pztot,atav
      real*8 aux_erf,erf1
      logical getd
      IF (( radc_flag .EQ. 1 )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) 'You are trying to use radiative Compton correcti
     *ons'
        write(6,*) 'without having included rad_compton1.mortran'
        write(1,*) 'without having included rad_compton1.mortran'
        write(6,'(a//)') 'Turning radiative Compton corrections OFF ...'
        write(1,'(a//)') 'Turning radiative Compton corrections OFF ...'
        radc_flag = 0
      END IF
      getd = .false.
      DO 11391 j=1, 1001
        medium = med(j)
        IF (( medium .GT. 0 .AND. medium .LE. nmed)) THEN
          IF (( ibcmp(j) .GT. 0 )) THEN
            getd = .true.
            GO TO11392
          END IF
        END IF
11391 CONTINUE
11392 CONTINUE
      IF (( .NOT.getd )) THEN
        IF (( eadl_relax .AND. photon_xsections .EQ. 'xcom' )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,/a,/a)') 'You must turn ON Compton binding cor
     *rections when using', 'a detailed atomic relaxation (eadl_relax=tr
     *ue) since ', 'binding energies taken from incoh.data below 1 keV!'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        write(6,'(a/)') ' Bound Compton scattering not requested! '
        write(1,'(a/)') ' Bound Compton scattering not requested! '
        return
      END IF
      write(6,'(/a$)') 'Bound Compton scattering requested, reading data
     * ......'
      write(1,'(/a$)') 'Bound Compton scattering requested, reading data
     * ......'
      rewind(i_incoh)
      DO 11401 j=1,18
        read(i_incoh,*)
11401 CONTINUE
11402 CONTINUE
      iz = 0
      DO 11411 j=1,1538
        read(i_incoh,*) iz_array(j),shn_array(j),ne_array(j), Jo_array(j
     *  ),be_array(j)
        Jo_array(j) = Jo_array(j)*137.
        be_array(j) = be_array(j)*1e-6/PRM
        aux_erf = 0.70710678119*(1+0.3*Jo_array(j))
        erfJo_array(j) = 0.82436063535*(erf1(aux_erf)-1)
        IF ((eadl_relax)) THEN
          IF ((iz_array(j) .NE. iz)) THEN
            shn_array(j) = 1
            iz = iz_array(j)
          ELSE
            shn_array(j) = shn_array(j-1)+1
          END IF
          IF ((binding_energies(shn_array(j),iz_array(j)) .GT. 0)) THEN
            be_array(j) = binding_energies(shn_array(j),iz_array(j))/PRM
          ELSE IF((photon_xsections .EQ. 'xcom')) THEN
            binding_energies(shn_array(j),iz_array(j)) = be_array(j)*PRM
          END IF
        END IF
11411 CONTINUE
11412 CONTINUE
      write(6,*) ' Done'
      write(1,*) ' Done'
      write(6,'(/a)') ' Initializing Bound Compton scattering ......'
      write(1,'(/a)') ' Initializing Bound Compton scattering ......'
      DO 11421 medium=1,nmed
        pztot = 0
        nsh = 0
        DO 11431 i=1,nne(medium)
          iz = int(zelem(medium,i))
          DO 11441 j=1,1538
            IF (( iz .EQ. iz_array(j) )) THEN
              nsh = nsh + 1
              IF (( nsh .GT. 200 )) THEN
                write(i_log,'(/a)') '***************** Error: '
                write(i_log,'(/a,i3,a,i4,a/,a)') ' For medium ',medium,
     *          ' the number of shells is > ',200,'!', ' Increase the pa
     *rameter $MXMDSH! '
                write(i_log,'(/a)') '***************** Quiting now.'
                call exit(1)
              END IF
              shell_array(nsh,medium) = j
              aux = pz(medium,i)*ne_array(j)
              eno_array(nsh,medium) = aux
              pztot = pztot + aux
            END IF
11441     CONTINUE
11442     CONTINUE
11431   CONTINUE
11432   CONTINUE
        IF (( nsh .EQ. 0 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,i3,a)') ' Medium ',medium,' has zero shells! '
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        n_shell(medium) = nsh
        write(6,'(a,i3,a,i3,a)') ' Medium ',medium,' has ',nsh,' shells:
     * '
        write(1,'(a,i3,a,i3,a)') ' Medium ',medium,' has ',nsh,' shells:
     * '
        DO 11451 i=1,nsh
          j = shell_array(i,medium)
          eno_array(i,medium) = eno_array(i,medium)/pztot
          write(6,'(i4,i5,i4,f9.5,e10.3,f10.3)') i,j,shn_array(j),eno_ar
     *    ray(i,medium), Jo_array(j),be_array(j)*PRM*1000.
          write(1,'(i4,i5,i4,f9.5,e10.3,f10.3)') i,j,shn_array(j),eno_ar
     *    ray(i,medium), Jo_array(j),be_array(j)*PRM*1000.
          eno_array(i,medium) = -eno_array(i,medium)
          eno_atbin_array(i,medium) = i
11451   CONTINUE
11452   CONTINUE
        atav = 1./nsh
        DO 11461 i=1,nsh-1
          DO 11471 j_h=1,nsh-1
            IF (( eno_array(j_h,medium) .LT. 0 )) THEN
              IF((abs(eno_array(j_h,medium)) .GT. atav))GO TO11472
            END IF
11471     CONTINUE
11472     CONTINUE
          DO 11481 j_l=1,nsh-1
            IF (( eno_array(j_l,medium) .LT. 0 )) THEN
              IF((abs(eno_array(j_l,medium)) .LT. atav))GO TO11482
            END IF
11481     CONTINUE
11482     CONTINUE
          aux = atav - abs(eno_array(j_l,medium))
          eno_array(j_h,medium) = eno_array(j_h,medium) + aux
          eno_array(j_l,medium) = -eno_array(j_l,medium)/atav + j_l
          eno_atbin_array(j_l,medium) = j_h
          IF((i .EQ. nsh-1))eno_array(j_h,medium) = 1 + j_h
11461   CONTINUE
11462   CONTINUE
        DO 11491 i=1,nsh
          IF (( eno_array(i,medium) .LT. 0 )) THEN
            eno_array(i,medium) = 1 + i
          END IF
11491   CONTINUE
11492   CONTINUE
11421 CONTINUE
11422 CONTINUE
      write(6,'(a/)') ' ...... Done.'
      write(1,'(a/)') ' ...... Done.'
      getd = .false.
      DO 11501 j=1, 1001
        IF (( iedgfl(j) .GT. 0 .AND. iedgfl(j) .LE. 100 )) THEN
          getd = .true.
          GO TO11502
        END IF
11501 CONTINUE
11502 CONTINUE
      IF((getd))return
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(/a,/a,/a,/a)') ' In subroutine init_compton: ', '
     *Scattering off bound electrons creates atomic vacancies,', '   pot
     *entially starting an atomic relaxation cascade. ', '   Please turn
     * ON atomic relaxations.'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      SUBROUTINE MOLLER
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(3), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),  e
     *ii_sh(40),  eii_nshells(100),  eii_nsh(3),  eii_first(3,50),  eii_
     *no(3,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      DOUBLE PRECISION PEIE,  PEKSE2,  PESE1,  PESE2,  PEKIN,  H1,  DCOS
     *TH
      real*8 EIE,  EKIN,  T0,  E0,  EXTRAE,  E02,  EP0,  G2,G3,  GMAX,
     *BR,  R,  REJF4,  RNNO27,  RNNO28,  ESE1,  ESE2
      real*8 sigm,pbrem,rsh,Uj,sig_j
      integer*4 lelke,iele,ish,nsh,ifirst,i,jj,iZ,iarg
      NPold = NP
      PEIE=E(NP)
      EIE=PEIE
      PEKIN=PEIE-PRM
      EKIN=PEKIN
      IF (( eii_flag .GT. 0 .AND. eii_nsh(medium) .GT. 0 )) THEN
        Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
        sigm=esig1(Lelke,MEDIUM)*elke+esig0(Lelke,MEDIUM)
        pbrem=ebr11(Lelke,MEDIUM)*elke+ebr10(Lelke,MEDIUM)
        sigm = sigm*(1 - pbrem)
        IF((rng_seed .GT. 128))call ranmar_get
        rsh = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        rsh = sigm*rsh
        DO 11511 iele=1,nne(medium)
          iZ = int(zelem(medium,iele)+0.5)
          nsh = eii_no(medium,iele)
          IF (( nsh .GT. 0 )) THEN
            ifirst = eii_first(medium,iele)
            DO 11521 ish=1,nsh
              Uj = binding_energies(ish,iZ)
              IF (( ekin .GT. Uj .AND. (Uj .GT. te(medium) .OR. Uj .GT.
     *        ap(medium)) )) THEN
                jj = ifirst + ish - 1
                i = eii_a(jj)*elke + eii_b(jj) + (jj-1)*250
                sig_j = eii_xsection_a(i)*elke + eii_xsection_b(i)
                sig_j = sig_j*pz(medium,iele)*eii_cons(medium)
                rsh = rsh - sig_j
                IF (( rsh .LT. 0 )) THEN
                  IARG=31
                  IF ((IAUSFL(IARG+1).NE.0)) THEN
                    CALL AUSGAB(IARG)
                  END IF
                  call eii_sample(ish,iZ,Uj)
                  IARG=32
                  IF ((IAUSFL(IARG+1).NE.0)) THEN
                    CALL AUSGAB(IARG)
                  END IF
                  return
                END IF
              END IF
11521       CONTINUE
11522       CONTINUE
          END IF
11511   CONTINUE
11512   CONTINUE
      END IF
      IF((ekin .LE. 2*te(medium)))return
      T0=EKIN/RM
      E0=T0+1.0
      EXTRAE = EIE - THMOLL(MEDIUM)
      E02=E0*E0
      EP0=TE(MEDIUM)/EKIN
      G2=T0*T0/E02
      G3=(2.*T0+1.)/E02
      GMAX=(1.+1.25*G2)
11531 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO27 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        BR = TE(MEDIUM)/(EKIN-EXTRAE*RNNO27)
        R=BR/(1.-BR)
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO28 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        REJF4=(1.+G2*BR*BR+R*(R-G3))
        RNNO28=GMAX*RNNO28
        IF((RNNO28.LE.REJF4))GO TO11532
      GO TO 11531
11532 CONTINUE
      PEKSE2=BR*EKIN
      PESE1=PEIE-PEKSE2
      PESE2=PEKSE2+PRM
      ESE1=PESE1
      ESE2=PESE2
      E(NP)=PESE1
      IF (( np+1 .GT. 40 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','MOLLER', ' s
     *tack size exceeded! ',' $MAXSTACK = ',40,' np = ',np+1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      E(NP+1)=PESE2
      H1=(PEIE+PRM)/PEKIN
      DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM)
      SINTHE=DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(2,1)
      NP=NP+1
      IQ(NP)=-1
      DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM)
      SINTHE=-DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(3,2)
      RETURN
      END
      subroutine mscati
      implicit none
      real*8 ededx,ei,eil,eip1,eip1l,si,sip1,eke,elke,aux,ecutmn,tstbm,t
     *stbmn
      real*8 p2,beta2,dedx0,ekef,elkef,estepx,ektmp,elktmp,chi_a2
      integer*4 i,leil,leip1l,neke,lelke,lelkef,lelktmp
      logical ise_monoton, isp_monoton
      real*8 sigee,sigep,sig,sige_old,sigp_old
      COMMON/BOUNDS/ECUT( 1001),PCUT( 1001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/ET_control/ smaxir( 1001),estepe,ximax,  skindepth_for_bca,
     *transport_algorithm, bca_algorithm,exact_bca,spin_effects
      real*8 smaxir,  estepe,  ximax,      skindepth_for_bca
      integer*4 transport_algorithm, bca_algorithm
      logical exact_bca,  spin_effects
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      IF (( bca_algorithm .EQ. 0 )) THEN
        exact_bca = .true.
      ELSE
        exact_bca = .false.
      END IF
      IF (( estepe .LE. 0 .OR. estepe .GE. 1)) THEN
        estepe = 0.25
      END IF
      IF (( ximax .LE. 0 .OR. ximax .GE. 1 )) THEN
        IF (( exact_bca )) THEN
          ximax = 0.5
        ELSE
          ximax = 0.5
        END IF
      END IF
      IF ((transport_algorithm .NE. 0 .AND. transport_algorithm .NE. 1 .
     *AND. transport_algorithm .NE. 2 )) THEN
        transport_algorithm = 0
      END IF
      IF (( skindepth_for_bca .LE. 1e-4 )) THEN
        IF (( .NOT.exact_bca )) THEN
          write(6,*) ' old PRESTA calculates default min. step-size for
     *BCA: '
          write(1,*) ' old PRESTA calculates default min. step-size for
     *BCA: '
          ecutmn = 1e30
          DO 11541 i=1, 1001
            IF (( med(i) .GT. 0 .AND. med(i) .LE. nmed )) THEN
              ecutmn = Min(ecutmn,ecut(i))
            END IF
11541     CONTINUE
11542     CONTINUE
          write(6,*) '     minimum ECUT found: ',ecutmn
          write(1,*) '     minimum ECUT found: ',ecutmn
          tstbmn = 1e30
          DO 11551 medium=1,nmed
            tstbm = (ecutmn-prm)*(ecutmn+prm)/ecutmn**2
            tstbm = blcc(medium)*tstbm*(ecutmn/xcc(medium))**2
            aux = Log(tstbm)
            IF((aux .GT. 300))write(6,*) 'aux > 300 ? ',aux
            write(1,*) 'aux > 300 ? ',aux
            tstbm = Log(tstbm/aux)
            tstbmn = Min(tstbmn,tstbm)
11551     CONTINUE
11552     CONTINUE
          write(6,*) '     default BLCMIN is: ',tstbmn
          write(1,*) '     default BLCMIN is: ',tstbmn
          skindepth_for_bca = Exp(tstbmn)
          write(6,*) '     this corresponds to ',skindepth_for_bca, ' el
     *astic MFPs '
          write(1,*) '     this corresponds to ',skindepth_for_bca, ' el
     *astic MFPs '
        ELSE
          skindepth_for_bca = 3
        END IF
      END IF
      call init_ms_SR
      DO 11561 medium=1,nmed
        blcc(medium) = 1.16699413758864573*blcc(medium)
        xcc(medium) = xcc(medium)**2
11561 CONTINUE
11562 CONTINUE
      IF (( spin_effects )) THEN
        call init_spin
      END IF
      write(6,*) ' '
      write(1,*) ' '
      esige_max = 0
      psige_max = 0
      DO 11571 medium=1,nmed
        sigee = 1E-15
        sigep = 1E-15
        neke = meke(medium)
        ise_monoton = .true.
        isp_monoton = .true.
        sige_old = -1
        sigp_old = -1
        DO 11581 i=1,neke
          ei = exp((float(i) - eke0(medium))/eke1(medium))
          eil = log(ei)
          leil = i
          ededx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
          sig=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
          sig = sig/ededx
          IF((sig .GT. sigee))sigee = sig
          IF((sig .LT. sige_old))ise_monoton = .false.
          sige_old = sig
          ededx=pdedx1(Leil,MEDIUM)*eil+pdedx0(Leil,MEDIUM)
          sig=psig1(Leil,MEDIUM)*eil+psig0(Leil,MEDIUM)
          sig = sig/ededx
          IF((sig .GT. sigep))sigep = sig
          IF((sig .LT. sigp_old))isp_monoton = .false.
          sigp_old = sig
11581   CONTINUE
11582   CONTINUE
        write(6,*) ' Medium ',medium,' sige = ',sigee,sigep,' monotone =
     * ', ise_monoton,isp_monoton
        write(1,*) ' Medium ',medium,' sige = ',sigee,sigep,' monotone =
     * ', ise_monoton,isp_monoton
        sig_ismonotone(0,medium) = ise_monoton
        sig_ismonotone(1,medium) = isp_monoton
        esig_e(medium) = sigee
        psig_e(medium) = sigep
        IF((sigee .GT. esige_max))esige_max = sigee
        IF((sigep .GT. psige_max))psige_max = sigep
11571 CONTINUE
11572 CONTINUE
      write(6,*) ' '
      write(1,*) ' '
      write(6,*) ' Initializing tmxs for estepe = ',estepe,' and ximax =
     * ',ximax
      write(1,*) ' Initializing tmxs for estepe = ',estepe,' and ximax =
     * ',ximax
      write(6,*) ' '
      write(1,*) ' '
      DO 11591 medium=1,nmed
        ei = exp((1 - eke0(medium))/eke1(medium))
        eil = log(ei)
        leil = 1
        E_array(1,medium) = ei
        expeke1(medium) = Exp(1./eke1(medium))-1
        range_ep(0,1,medium) = 0
        range_ep(1,1,medium) = 0
        neke = meke(medium)
        DO 11601 i=1,neke - 1
          eip1 = exp((float(i + 1) - eke0(medium))/eke1(medium))
          E_array(i+1,medium) = eip1
          eke = 0.5*(eip1+ei)
          elke = Log(eke)
          Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
          ededx=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
          aux = pdedx1(i,medium)/ededx
          range_ep(1,i+1,medium) = range_ep(1,i,medium) + (eip1-ei)/eded
     *    x*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24)
          ededx=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
          aux = ededx1(i,medium)/ededx
          range_ep(0,i+1,medium) = range_ep(0,i,medium) + (eip1-ei)/eded
     *    x*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24)
          ei = eip1
11601   CONTINUE
11602   CONTINUE
        eil = (1 - eke0(medium))/eke1(medium)
        ei = Exp(eil)
        leil = 1
        p2 = ei*(ei+2*rm)
        beta2 = p2/(p2+rm*rm)
        chi_a2 = Xcc(medium)/(4*p2*blcc(medium))
        dedx0=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
        estepx = 2*p2*beta2*dedx0/ei/Xcc(medium)/(Log(1+1./chi_a2)*(1+ch
     *  i_a2)-1)
        estepx = estepx*ximax
        IF (( estepx .GT. estepe )) THEN
          estepx = estepe
        END IF
        si = estepx*ei/dedx0
        DO 11611 i=1,neke - 1
          elke = (i + 1 - eke0(medium))/eke1(medium)
          eke = Exp(elke)
          lelke = i+1
          p2 = eke*(eke+2*rm)
          beta2 = p2/(p2+rm*rm)
          chi_a2 = Xcc(medium)/(4*p2*blcc(medium))
          ededx=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
          estepx = 2*p2*beta2*ededx/eke/ Xcc(medium)/(Log(1+1./chi_a2)*(
     *    1+chi_a2)-1)
          estepx = estepx*ximax
          IF (( estepx .GT. estepe )) THEN
            estepx = estepe
          END IF
          ekef = (1-estepx)*eke
          IF (( ekef .LE. E_array(1,medium) )) THEN
            sip1 = (E_array(1,medium) - ekef)/dedx0
            ekef = E_array(1,medium)
            elkef = (1 - eke0(medium))/eke1(medium)
            lelkef = 1
          ELSE
            elkef = Log(ekef)
            Lelkef=eke1(MEDIUM)*elkef+eke0(MEDIUM)
            leip1l = lelkef + 1
            eip1l = (leip1l - eke0(medium))/eke1(medium)
            eip1 = E_array(leip1l,medium)
            aux = (eip1 - ekef)/eip1
            elktmp = 0.5*(elkef+eip1l+0.25*aux*aux*(1+aux*(1+0.875*aux))
     *      )
            ektmp = 0.5*(ekef+eip1)
            lelktmp = lelkef
            ededx=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelktmp,MEDIUM)
            aux = ededx1(lelktmp,medium)/ededx
            sip1 = (eip1 - ekef)/ededx*( 1+aux*(1+2*aux)*((eip1-ekef)/ek
     *      tmp)**2/24)
          END IF
          sip1 = sip1 + range_ep(0,lelke,medium) - range_ep(0,lelkef+1,m
     *    edium)
          tmxs1(i,medium) = (sip1 - si)*eke1(medium)
          tmxs0(i,medium) = sip1 - tmxs1(i,medium)*elke
          si = sip1
11611   CONTINUE
11612   CONTINUE
        tmxs0(neke,medium) = tmxs0(neke - 1,medium)
        tmxs1(neke,medium) = tmxs1(neke - 1,medium)
11591 CONTINUE
11592 CONTINUE
      return
      end
      subroutine mscat(lambda,chia2,q1,elke,beta2,qel,medium, spin_effec
     *ts,find_index,spin_index, cost,sint)
      implicit none
      real*8 lambda, chia2,q1,elke,beta2,cost,sint
      integer*4 qel,medium
      logical spin_effects,find_index,spin_index
      common/ms_data/ ums_array(0:63,0:7,0:31), fms_array(0:63,0:7,0:31)
     *, wms_array(0:63,0:7,0:31), ims_array(0:63,0:7,0:31), llammin,llam
     *max,dllamb,dllambi,dqms,dqmsi
      real*4 ums_array,fms_array,wms_array, llammin,llammax,dllamb,dllam
     *bi,dqms,dqmsi
      integer*2 ims_array
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 sprob,explambda,wsum,wprob,xi,rejf,spin_rejection, cosz,sin
     *z,phi,omega2,llmbda,ai,aj,ak,a,u,du,x1,rnno
      integer*4 icount,i,j,k
      save i,j,omega2
      IF ((lambda .LE. 13.8)) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        sprob = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        explambda = Exp(-lambda)
        IF ((sprob .LT. explambda)) THEN
          cost = 1
          sint = 0
          return
        END IF
        wsum = (1+lambda)*explambda
        IF (( sprob .LT. wsum )) THEN
11620     CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          xi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          xi = 2*chia2*xi/(1 - xi + chia2)
          cost = 1 - xi
          IF (( spin_effects )) THEN
            rejf = spin_rejection(qel,medium,elke,beta2,q1,cost, spin_in
     *      dex,.false.)
            IF((rng_seed .GT. 128))call ranmar_get
            rnno = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF (( rnno .GT. rejf )) THEN
              GOTO 11620
            END IF
          END IF
          sint = sqrt(xi*(2 - xi))
          return
        END IF
        IF (( lambda .LE. 1 )) THEN
          wprob = explambda
          wsum = explambda
          cost = 1
          sint = 0
          icount = 0
11631     CONTINUE
            icount = icount + 1
            IF((icount .GT. 20))GO TO11632
            wprob = wprob*lambda/icount
            wsum = wsum + wprob
11640       CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            xi = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            xi = 2*chia2*xi/(1 - xi + chia2)
            cosz = 1 - xi
            IF (( spin_effects )) THEN
              rejf = spin_rejection(qel,medium,elke,beta2,q1,cosz, spin_
     *        index,.false.)
              IF((rng_seed .GT. 128))call ranmar_get
              rnno = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rnno .GT. rejf )) THEN
                GOTO 11640
              END IF
            END IF
            sinz = xi*(2 - xi)
            IF (( sinz .GT. 1.e-20 )) THEN
              sinz = Sqrt(sinz)
              IF((rng_seed .GT. 128))call ranmar_get
              xi = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              phi = xi*6.2831853
              cost = cost*cosz - sint*sinz*Cos(phi)
              sint = Sqrt(Max(0.0,(1-cost)*(1+cost)))
            END IF
            IF((( wsum .GT. sprob)))GO TO11632
          GO TO 11631
11632     CONTINUE
          return
        END IF
      END IF
      IF ((lambda .LE. 1e5 )) THEN
        IF ((find_index)) THEN
          llmbda = log(lambda)
          ai = llmbda*dllambi
          i = ai
          ai = ai - i
          IF((rng_seed .GT. 128))call ranmar_get
          xi = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((xi .LT. ai))i = i + 1
          IF (( q1 .LT. 1e-3 )) THEN
            j = 0
          ELSE IF(( q1 .LT. 0.5 )) THEN
            aj = q1*dqmsi
            j = aj
            aj = aj - j
            IF((rng_seed .GT. 128))call ranmar_get
            xi = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((xi .LT. aj))j = j + 1
          ELSE
            j = 7
          END IF
          IF ((llmbda .LT. 2.2299)) THEN
            omega2 = chia2*(lambda + 4)*(1.347006 + llmbda*( 0.209364 -
     *      llmbda*(0.45525 - llmbda*(0.50142 - 0.081234*llmbda))))
          ELSE
            omega2 = chia2*(lambda + 4)*(-2.77164 + llmbda*(2.94874 - ll
     *      mbda*(0.1535754 - llmbda*0.00552888)))
          END IF
          find_index = .false.
        END IF
11650   CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        xi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        ak = xi*31
        k = ak
        ak = ak - k
        IF((ak .GT. wms_array(i,j,k)))k = ims_array(i,j,k)
        a = fms_array(i,j,k)
        u = ums_array(i,j,k)
        du = ums_array(i,j,k+1) - u
        IF((rng_seed .GT. 128))call ranmar_get
        xi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( abs(a) .LT. 0.2 )) THEN
          x1 = 0.5*(1-xi)*a
          u = u + xi*du*(1+x1*(1-xi*a))
        ELSE
          u = u - du/a*(1-Sqrt(1+xi*a*(2+a)))
        END IF
        xi = omega2*u/(1 + 0.5*omega2 - u)
        IF (( xi .GT. 1.99999 )) THEN
          xi = 1.99999
        END IF
        cost = 1 - xi
        IF (( spin_effects )) THEN
          rejf=spin_rejection(qel,medium,elke,beta2,q1,cost,spin_index,.
     *    false.)
          IF((rng_seed .GT. 128))call ranmar_get
          rnno = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF (( rnno .GT. rejf )) THEN
            GOTO 11650
          END IF
        END IF
        sint = sqrt(xi*(2-xi))
        return
      END IF
      write(6,*) ' '
      write(1,*) ' '
      write(6,*) ' *************************************'
      write(1,*) ' *************************************'
      write(6,*) ' Maximum step size in mscat exceeded! '
      write(1,*) ' Maximum step size in mscat exceeded! '
      write(6,*) ' Maximum step size initialized: 100000'
      write(1,*) ' Maximum step size initialized: 100000'
      write(6,*) ' Present lambda: ',lambda
      write(1,*) ' Present lambda: ',lambda
      write(6,*) ' chia2: ',chia2
      write(1,*) ' chia2: ',chia2
      write(6,*) ' q1 elke beta2: ',q1,elke,beta2
      write(1,*) ' q1 elke beta2: ',q1,elke,beta2
      write(6,*) ' medium: ',medium
      write(1,*) ' medium: ',medium
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' Stopping execution'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      real*8 function spin_rejection(qel,medium,elke,beta2,q1,cost, spin
     *_index,is_single)
      implicit none
      real*8 elke,beta2,q1,cost
      integer*4 qel,medium
      logical spin_index,is_single
      common/spin_data/ spin_rej(3,0:1,0: 31,0:15,0:31), espin_min,espin
     *_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dleneri,dq
     *q1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      real*8 rnno,ai,qq1,aj,xi,ak
      integer*4 i,j,k
      save i,j
      IF (( spin_index )) THEN
        spin_index = .false.
        IF (( beta2 .GE. b2spin_min )) THEN
          ai = (beta2 - b2spin_min)*dbeta2i
          i = ai
          ai = ai - i
          i = i + 15 + 1
        ELSE IF(( elke .GT. espml )) THEN
          ai = (elke - espml)*dleneri
          i = ai
          ai = ai - i
        ELSE
          i = 0
          ai = -1
        END IF
        IF((rng_seed .GT. 128))call ranmar_get
        rnno = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((rnno .LT. ai))i = i + 1
        IF (( is_single )) THEN
          j = 0
        ELSE
          qq1 = 2*q1
          qq1 = qq1/(1 + qq1)
          aj = qq1*dqq1i
          j = aj
          IF (( j .GE. 15 )) THEN
            j = 15
          ELSE
            aj = aj - j
            IF((rng_seed .GT. 128))call ranmar_get
            rnno = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rnno .LT. aj))j = j + 1
          END IF
        END IF
      END IF
      xi = Sqrt(0.5*(1-cost))
      ak = xi*31
      k = ak
      ak = ak - k
      spin_rejection = (1-ak)*spin_rej(medium,qel,i,j,k) + ak*spin_rej(m
     *edium,qel,i,j,k+1)
      return
      end
      subroutine sscat(chia2,elke,beta2,qel,medium,spin_effects,cost,sin
     *t)
      implicit none
      real*8 chia2,elke,beta2,cost,sint
      integer*4 qel,medium
      logical spin_effects
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      real*8 xi,rnno,rejf,spin_rejection,qzero
      logical spin_index
      spin_index = .true.
11660 CONTINUE
      IF((rng_seed .GT. 128))call ranmar_get
      xi = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      xi = 2*chia2*xi/(1 - xi + chia2)
      cost = 1 - xi
      IF (( spin_effects )) THEN
        qzero=0
        rejf = spin_rejection(qel,medium,elke,beta2,qzero,cost,spin_inde
     *  x,.true.)
        IF((rng_seed .GT. 128))call ranmar_get
        rnno = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((rnno .GT. rejf))goto 11660
      END IF
      sint = sqrt(xi*(2 - xi))
      return
      end
      subroutine init_ms_SR
      implicit none
      common/ms_data/ ums_array(0:63,0:7,0:31), fms_array(0:63,0:7,0:31)
     *, wms_array(0:63,0:7,0:31), ims_array(0:63,0:7,0:31), llammin,llam
     *max,dllamb,dllambi,dqms,dqmsi
      real*4 ums_array,fms_array,wms_array, llammin,llammax,dllamb,dllam
     *bi,dqms,dqmsi
      integer*2 ims_array
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,j,k
      write(6,'(/a,$)') 'Reading screened Rutherford MS data ...........
     *.... '
      write(1,'(/a,$)') 'Reading screened Rutherford MS data ...........
     *.... '
      rewind(i_mscat)
      DO 11671 i=0,63
        DO 11681 j=0,7
          read(i_mscat,*) (ums_array(i,j,k),k=0,31)
          read(i_mscat,*) (fms_array(i,j,k),k=0,31)
          read(i_mscat,*) (wms_array(i,j,k),k=0,31-1)
          read(i_mscat,*) (ims_array(i,j,k),k=0,31-1)
          DO 11691 k=0,31-1
            fms_array(i,j,k) = fms_array(i,j,k+1)/fms_array(i,j,k)-1
            ims_array(i,j,k) = ims_array(i,j,k)-1
11691     CONTINUE
11692     CONTINUE
          fms_array(i,j,31)=fms_array(i,j,31-1)
11681   CONTINUE
11682   CONTINUE
11671 CONTINUE
11672 CONTINUE
      write(6,'(a)') ' done '
      write(1,'(a)') ' done '
      llammin = Log(1.)
      llammax = Log(1e5)
      dllamb = (llammax-llammin)/63
      dllambi = 1./dllamb
      dqms = 0.5/7
      dqmsi = 1./dqms
      return
      end
      subroutine init_spin
      implicit none
      common/spin_data/ spin_rej(3,0:1,0: 31,0:15,0:31), espin_min,espin
     *_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dleneri,dq
     *q1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 eta_array(0:1,0: 31), c_array(0:1,0: 31),g_array(0:1,0: 31)
     *, earray(0: 31),tmp_array(0: 31), sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,
     *Z23,g_m,g_r,sig,dedx, tau,tauc,beta2,eta,gamma,fmax, eil,e,si1e,si
     *2e,si1p,si2p,aae,etap, elarray(0: 31),farray(0: 31), af(0: 31),bf(
     *0: 31),cf(0: 31), df(0: 31),spline,dloge,eloge
      real*4 dum1,dum2,dum3,aux_o
      real*4 fmax_array(0:15)
      integer*2 i2_array(512),ii2
      integer*4 iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke, nd
     *ata,leil,length,ii4,irec
      character spin_file*256
      character*6 string
      integer*4 lnblnk1
      integer*4 spin_unit, rec_length, want_spin_unit
      integer egs_get_unit
      character data_version*32,endianess*4
      logical swap
      real*8 fine,TF_constant
      parameter (fine=137.03604,TF_constant=0.88534138)
      real*4 tmp_4
      character c_2(2), c_4(4)
      equivalence (ii2,c_2), (tmp_4,c_4)
      DO 11701 i=1,len(spin_file)
        spin_file(i:i) = ' '
11701 CONTINUE
11702 CONTINUE
      spin_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'sp
     *inms.data'
      want_spin_unit = 61
      spin_unit = egs_get_unit(want_spin_unit)
      IF (( spin_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'init_spin: failed to get a free fortran unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      rec_length = 276*4
      open(spin_unit,file=spin_file,form='unformatted',access='direct',
     *status='old',recl=rec_length,err=11710)
      read(spin_unit,rec=1,err=11720) data_version,endianess, espin_min,
     *espin_max,b2spin_min,b2spin_max
      swap = endianess.ne.'1234'
      IF (( swap )) THEN
        tmp_4 = espin_min
        call egs_swap_4(c_4)
        espin_min = tmp_4
        tmp_4 = espin_max
        call egs_swap_4(c_4)
        espin_max = tmp_4
        tmp_4 = b2spin_min
        call egs_swap_4(c_4)
        b2spin_min = tmp_4
        tmp_4 = b2spin_max
        call egs_swap_4(c_4)
        b2spin_max = tmp_4
      END IF
      write(6,'(//a,a)') 'Reading spin data base from ',spin_file(:lnbln
     *k1(spin_file))
      write(1,'(//a,a)') 'Reading spin data base from ',spin_file(:lnbln
     *k1(spin_file))
      write(6,'(a)') data_version
      write(1,'(a)') data_version
      write(6,'(a,a,a)') 'Data generated on a machine with ',endianess,
     *' endianess'
      write(1,'(a,a,a)') 'Data generated on a machine with ',endianess,
     *' endianess'
      write(6,'(a,a)') 'The endianess of this CPU is ','1234'
      write(1,'(a,a)') 'The endianess of this CPU is ','1234'
      IF((swap))write(6,'(a)') '=> will need to do byte swaping'
      write(1,'(a)') '=> will need to do byte swaping'
      write(6,'(a,2f9.2,2f9.5,//)') 'Ranges: ',espin_min,espin_max, b2sp
     *in_min,b2spin_max
      write(1,'(a,2f9.2,2f9.5,//)') 'Ranges: ',espin_min,espin_max, b2sp
     *in_min,b2spin_max
      n_ener = 15
      n_q = 15
      n_point = 31
      dloge = log(espin_max/espin_min)/n_ener
      eloge = log(espin_min)
      earray(0) = espin_min
      IF (( fool_intel_optimizer )) THEN
        write(25,*) 'Energy grid:'
      END IF
      DO 11731 i=1,n_ener
        eloge = eloge + dloge
        earray(i) = exp(eloge)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) i,earray(i)
        END IF
11731 CONTINUE
11732 CONTINUE
      dbeta2 = (b2spin_max - b2spin_min)/n_ener
      beta2 = b2spin_min
      earray(n_ener+1) = espin_max
      DO 11741 i=n_ener+2,2*n_ener+1
        beta2 = beta2 + dbeta2
        IF (( beta2 .LT. 0.999 )) THEN
          earray(i) = prm*1000.0*(1/sqrt(1-beta2)-1)
        ELSE
          earray(i) = 50585.1
        END IF
        IF (( fool_intel_optimizer )) THEN
          write(25,*) i,earray(i)
        END IF
11741 CONTINUE
11742 CONTINUE
      espin_min = espin_min/1000
      espin_max = espin_max/1000
      dlener = Log(espin_max/espin_min)/15
      dleneri = 1/dlener
      espml = Log(espin_min)
      dbeta2 = (b2spin_max-b2spin_min)/15
      dbeta2i = 1/dbeta2
      dqq1 = 0.5/15
      dqq1i = 1/dqq1
      DO 11751 medium=1,NMED
        write(6,'(a,i4,a,$)') '  medium ',medium,' .....................
     * '
        write(1,'(a,i4,a,$)') '  medium ',medium,' .....................
     * '
        DO 11761 iq=0,1
          DO 11771 i=0, 31
            eta_array(iq,i)=0
            c_array(iq,i)=0
            g_array(iq,i)=0
            DO 11781 j=0,15
              DO 11791 k=0,31
                spin_rej(medium,iq,i,j,k) = 0
11791         CONTINUE
11792         CONTINUE
11781       CONTINUE
11782       CONTINUE
11771     CONTINUE
11772     CONTINUE
11761   CONTINUE
11762   CONTINUE
        sum_Z2=0
        sum_A=0
        sum_pz=0
        sum_Z=0
        DO 11801 i_ele=1,NNE(medium)
          Z = ZELEM(medium,i_ele)
          iZ = int(Z+0.5)
          IF (( fool_intel_optimizer )) THEN
            write(25,*) ' Z = ',iZ
          END IF
          tmp = PZ(medium,i_ele)*Z*(Z+1)
          sum_Z2 = sum_Z2 + tmp
          sum_Z = sum_Z + PZ(medium,i_ele)*Z
          sum_A = sum_A + PZ(medium,i_ele)*WA(medium,i_ele)
          sum_pz = sum_pz + PZ(medium,i_ele)
          Z23 = Z**0.6666667
          DO 11811 iq=0,1
            DO 11821 i=0, 31
              irec = 1 + (iz-1)*4*(n_ener+1) + 2*iq*(n_ener+1) + i+1
              IF (( fool_intel_optimizer )) THEN
                write(25,*) '**** energy ',i,earray(i),irec
              END IF
              read(spin_unit,rec=irec,err=11720) dum1,dum2,dum3,aux_o,fm
     *        ax_array,i2_array
              IF (( swap )) THEN
                tmp_4 = dum1
                call egs_swap_4(c_4)
                dum1 = tmp_4
                tmp_4 = dum2
                call egs_swap_4(c_4)
                dum2 = tmp_4
                tmp_4 = dum3
                call egs_swap_4(c_4)
                dum3 = tmp_4
                tmp_4 = aux_o
                call egs_swap_4(c_4)
                aux_o = tmp_4
              END IF
              eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o)
              tau = earray(i)/prm*0.001
              beta2 = tau*(tau+2)/(tau+1)**2
              eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2)
              c_array(iq,i)=c_array(iq,i)+ tmp*(Log(1+1/eta)-1/(1+eta))*
     *        dum1*dum3
              g_array(iq,i)=g_array(iq,i)+tmp*dum2
              DO 11831 j=0,15
                tmp_4 = fmax_array(j)
                IF((swap))call egs_swap_4(c_4)
                DO 11841 k=0,31
                  ii2 = i2_array((n_point+1)*j + k+1)
                  IF((swap))call egs_swap_2(c_2)
                  ii4 = ii2
                  IF((ii4 .LT. 0))ii4 = ii4 + 65536
                  dum1 = ii4
                  dum1 = dum1*tmp_4/65535
                  spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)
     *            + tmp*dum1
11841           CONTINUE
11842           CONTINUE
11831         CONTINUE
11832         CONTINUE
11821       CONTINUE
11822       CONTINUE
11811     CONTINUE
11812     CONTINUE
11801   CONTINUE
11802   CONTINUE
        DO 11851 iq=0,1
          DO 11861 i=0, 31
            DO 11871 j=0,15
              fmax = 0
              DO 11881 k=0,31
                IF (( spin_rej(medium,iq,i,j,k) .GT. fmax )) THEN
                  fmax = spin_rej(medium,iq,i,j,k)
                END IF
11881         CONTINUE
11882         CONTINUE
              DO 11891 k=0,31
                spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fm
     *          ax
11891         CONTINUE
11892         CONTINUE
11871       CONTINUE
11872       CONTINUE
11861     CONTINUE
11862     CONTINUE
11851   CONTINUE
11852   CONTINUE
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Spin corrections as read in from file'
        END IF
        DO 11901 i=0, 31
          tau = earray(i)/prm*0.001
          beta2 = tau*(tau+2)/(tau+1)**2
          DO 11911 iq=0,1
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium)
            eta = aux_o/4/tau/(tau+2)
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/ (Log(1+1/eta)*
     *      (1+eta)-1)
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta)
     *      )
11911     CONTINUE
11912     CONTINUE
          IF (( fool_intel_optimizer )) THEN
            write(25,*) i,earray(i),eta_array(0,i),eta_array(1,i), c_arr
     *      ay(0,i),c_array(1,i),g_array(0,i),g_array(1,i)
          END IF
11901   CONTINUE
11902   CONTINUE
        eil = (1 - eke0(medium))/eke1(medium)
        e = Exp(eil)
        IF (( e .LE. espin_min )) THEN
          si1e = eta_array(0,0)
          si1p = eta_array(1,0)
        ELSE
          IF (( e .LE. espin_max )) THEN
            aae = (eil-espml)*dleneri
            je = aae
            aae = aae - je
          ELSE
            tau = e/prm
            beta2 = tau*(tau+2)/(tau+1)**2
            aae = (beta2 - b2spin_min)*dbeta2i
            je = aae
            aae = aae - je
            je = je + 15 + 1
          END IF
          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
        END IF
        neke = meke(medium)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for eta correction'
        END IF
        DO 11921 i=1,neke - 1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          IF (( e .LE. espin_min )) THEN
            si2e = eta_array(0,0)
            si2p = eta_array(1,0)
          ELSE
            IF (( e .LE. espin_max )) THEN
              aae = (eil-espml)*dleneri
              je = aae
              aae = aae - je
            ELSE
              tau = e/prm
              beta2 = tau*(tau+2)/(tau+1)**2
              aae = (beta2 - b2spin_min)*dbeta2i
              je = aae
              aae = aae - je
              je = je + 15 + 1
            END IF
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
          END IF
          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil
          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium)
          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) i,e,si2e,si2p,etae_ms1(i,medium), etae_ms0(i,med
     *      ium),etap_ms1(i,medium),etap_ms0(i,medium)
          END IF
          si1e = si2e
          si1p = si2p
11921   CONTINUE
11922   CONTINUE
        etae_ms1(neke,medium) = etae_ms1(neke-1,medium)
        etae_ms0(neke,medium) = etae_ms0(neke-1,medium)
        etap_ms1(neke,medium) = etap_ms1(neke-1,medium)
        etap_ms0(neke,medium) = etap_ms0(neke-1,medium)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'elarray:'
        END IF
        DO 11931 i=0,15
          elarray(i) = Log(earray(i)/1000)
          farray(i) = c_array(0,i)
          IF (( fool_intel_optimizer )) THEN
            write(25,*) elarray(i),earray(i)
          END IF
11931   CONTINUE
11932   CONTINUE
        DO 11941 i=15+1, 31-1
          elarray(i) = Log(earray(i+1)/1000)
          farray(i) = c_array(0,i+1)
          IF (( fool_intel_optimizer )) THEN
            write(25,*) elarray(i),earray(i+1)
          END IF
11941   CONTINUE
11942   CONTINUE
        ndata =  31+1
        IF (( ue(medium) .GT. 1e5 )) THEN
          elarray(ndata-1) = Log(ue(medium))
        ELSE
          elarray(ndata-1) = Log(1e5)
        END IF
        farray(ndata-1) = 1
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q1 correction (e-)'
        END IF
        DO 11951 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q1ce_ms1(i,medium), q1ce_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
11951   CONTINUE
11952   CONTINUE
        q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium)
        q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Postrons:'
        END IF
        DO 11961 i=0,15
          farray(i) = c_array(1,i)
11961   CONTINUE
11962   CONTINUE
        DO 11971 i=15+1, 31-1
          farray(i) = c_array(1,i+1)
11971   CONTINUE
11972   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q1 correction (e+)'
        END IF
        DO 11981 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q1cp_ms1(i,medium), q1cp_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
11981   CONTINUE
11982   CONTINUE
        q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium)
        q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium)
        DO 11991 i=0,15
          farray(i) = g_array(0,i)
11991   CONTINUE
11992   CONTINUE
        DO 12001 i=15+1, 31-1
          farray(i) = g_array(0,i+1)
12001   CONTINUE
12002   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q2 correction (e-)'
        END IF
        DO 12011 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q2ce_ms1(i,medium), q2ce_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
12011   CONTINUE
12012   CONTINUE
        q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium)
        q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium)
        DO 12021 i=0,15
          farray(i) = g_array(1,i)
12021   CONTINUE
12022   CONTINUE
        DO 12031 i=15+1, 31-1
          farray(i) = g_array(1,i+1)
12031   CONTINUE
12032   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q2 correction (e+)'
        END IF
        DO 12041 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q2cp_ms1(i,medium), q2cp_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
12041   CONTINUE
12042   CONTINUE
        q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium)
        q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium)
        tauc = te(medium)/prm
        si1e = 1
        DO 12051 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          leil=i+1
          tau=e/prm
          IF (( tau .GT. 2*tauc )) THEN
            sig=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
            dedx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
            sig = sig/dedx
            IF (( sig .GT. 1e-6 )) THEN
              etap=etae_ms1(Leil,MEDIUM)*eil+etae_ms0(Leil,MEDIUM)
              eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2)
              g_r = (1+2*eta)*Log(1+1/eta)-2
              g_m = Log(0.5*tau/tauc)+ (1+((tau+2)/(tau+1))**2)*Log(2*(t
     *        au-tauc+2)/(tau+4))- 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+
     *        1)**2)* Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+ 0.5*(tau
     *        -2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2)
              IF (( g_m .LT. g_r )) THEN
                g_m = g_m/g_r
              ELSE
                g_m = 1
              END IF
              si2e = 1 - g_m*sum_Z/sum_Z2
            ELSE
              si2e = 1
            END IF
          ELSE
            si2e = 1
          END IF
          blcce1(i,medium) = (si2e - si1e)*eke1(medium)
          blcce0(i,medium) = si2e - blcce1(i,medium)*eil
          si1e = si2e
12051   CONTINUE
12052   CONTINUE
        blcce1(neke,medium) = blcce1(neke-1,medium)
        blcce0(neke,medium) = blcce0(neke-1,medium)
        write(6,'(a)') ' done'
        write(1,'(a)') ' done'
11751 CONTINUE
11752 CONTINUE
      close(spin_unit)
      return
11710 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,a)') 'Failed to open spin data file ',spin_file(:l
     *nblnk1(spin_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
11720 write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Error while reading spin data file for element',iZ
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine init_spin_old
      implicit none
      common/spin_data/ spin_rej(3,0:1,0: 31,0:15,0:31), espin_min,espin
     *_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dleneri,dq
     *q1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 eta_array(0:1,0: 31), c_array(0:1,0: 31),g_array(0:1,0: 31)
     *, earray(0: 31),tmp_array(0: 31), sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,
     *Z23,g_m,g_r,sig,dedx, dum1,dum2,dum3,aux_o,tau,tauc,beta2,eta,gamm
     *a,fmax, eil,e,si1e,si2e,si1p,si2p,aae,etap, elarray(0: 31),farray(
     *0: 31), af(0: 31),bf(0: 31),cf(0: 31), df(0: 31),spline
      integer*4 iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke, nd
     *ata,leil,length,want_spin_unit,spin_unit,egs_get_unit
      character spin_file*256
      character*6 string
      integer*4 lnblnk1
      real*8 fine,TF_constant
      parameter (fine=137.03604,TF_constant=0.88534138)
      DO 12061 i=1,len(spin_file)
        spin_file(i:i) = ' '
12061 CONTINUE
12062 CONTINUE
      spin_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'sp
     *inms' // '/' // 'z000'
      length = lnblnk1(spin_file)
      DO 12071 medium=1,NMED
        write(6,'(a,i4,a,$)') '  Initializing spin data for medium ',med
     *  ium, ' ..................... '
        write(1,'(a,i4,a,$)') '  Initializing spin data for medium ',med
     *  ium, ' ..................... '
        DO 12081 iq=0,1
          DO 12091 i=0, 31
            eta_array(iq,i)=0
            c_array(iq,i)=0
            g_array(iq,i)=0
            DO 12101 j=0,15
              DO 12111 k=0,31
                spin_rej(medium,iq,i,j,k) = 0
12111         CONTINUE
12112         CONTINUE
12101       CONTINUE
12102       CONTINUE
12091     CONTINUE
12092     CONTINUE
12081   CONTINUE
12082   CONTINUE
        sum_Z2=0
        sum_A=0
        sum_pz=0
        sum_Z=0
        DO 12121 i_ele=1,NNE(medium)
          Z = ZELEM(medium,i_ele)
          iZ = int(Z+0.5)
          tmp = PZ(medium,i_ele)*Z*(Z+1)
          iii = iZ/100
          spin_file(length-2:length-2) = char(iii+48)
          iiZ = iZ - iii*100
          iii = iiZ/10
          spin_file(length-1:length-1) = char(iii+48)
          iiZ = iiZ - 10*iii
          spin_file(length:length) = char(iiZ+48)
          want_spin_unit = 61
          spin_unit = egs_get_unit(want_spin_unit)
          IF (( spin_unit .LT. 1 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'init_spin: failed to get a free fortran unit
     *'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(spin_unit,file=spin_file,status='old',err=12130)
          read(spin_unit,*) espin_min,espin_max,b2spin_min,b2spin_max
          read(spin_unit,*) n_ener,n_q,n_point
          IF (( n_ener .NE. 15 .OR. n_q .NE. 15 .OR. n_point .NE. 31)) T
     *    HEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) ' Wrong spin file for Z = ',iZ
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          sum_Z2 = sum_Z2 + tmp
          sum_Z = sum_Z + PZ(medium,i_ele)*Z
          sum_A = sum_A + PZ(medium,i_ele)*WA(medium,i_ele)
          sum_pz = sum_pz + PZ(medium,i_ele)
          Z23 = Z**0.6666667
          DO 12141 iq=0,1
            read(spin_unit,*)
            read(spin_unit,*)
            DO 12151 i=0, 31
              read(spin_unit,'(a,g14.6)') string,earray(i)
              read(spin_unit,*) dum1,dum2,dum3,aux_o
              eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o)
              tau = earray(i)/prm*0.001
              beta2 = tau*(tau+2)/(tau+1)**2
              eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2)
              c_array(iq,i)=c_array(iq,i)+ tmp*(Log(1+1/eta)-1/(1+eta))*
     *        dum1*dum3
              g_array(iq,i)=g_array(iq,i)+tmp*dum2
              DO 12161 j=0,15
                read(spin_unit,*) tmp_array
                DO 12171 k=0,31
                  spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)
     *            + tmp*tmp_array(k)
12171           CONTINUE
12172           CONTINUE
12161         CONTINUE
12162         CONTINUE
12151       CONTINUE
12152       CONTINUE
12141     CONTINUE
12142     CONTINUE
          close(spin_unit)
12121   CONTINUE
12122   CONTINUE
        DO 12181 iq=0,1
          DO 12191 i=0, 31
            DO 12201 j=0,15
              fmax = 0
              DO 12211 k=0,31
                IF (( spin_rej(medium,iq,i,j,k) .GT. fmax )) THEN
                  fmax = spin_rej(medium,iq,i,j,k)
                END IF
12211         CONTINUE
12212         CONTINUE
              DO 12221 k=0,31
                spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fm
     *          ax
12221         CONTINUE
12222         CONTINUE
12201       CONTINUE
12202       CONTINUE
12191     CONTINUE
12192     CONTINUE
12181   CONTINUE
12182   CONTINUE
        DO 12231 i=0, 31
          tau = earray(i)/prm*0.001
          beta2 = tau*(tau+2)/(tau+1)**2
          DO 12241 iq=0,1
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium)
            eta = aux_o/4/tau/(tau+2)
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/ (Log(1+1/eta)*
     *      (1+eta)-1)
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta)
     *      )
12241     CONTINUE
12242     CONTINUE
12231   CONTINUE
12232   CONTINUE
        espin_min = espin_min/1000
        espin_max = espin_max/1000
        dlener = Log(espin_max/espin_min)/15
        dleneri = 1/dlener
        espml = Log(espin_min)
        dbeta2 = (b2spin_max-b2spin_min)/15
        dbeta2i = 1/dbeta2
        dqq1 = 0.5/15
        dqq1i = 1/dqq1
        eil = (1 - eke0(medium))/eke1(medium)
        e = Exp(eil)
        IF (( e .LE. espin_min )) THEN
          si1e = eta_array(0,0)
          si1p = eta_array(1,0)
        ELSE
          IF (( e .LE. espin_max )) THEN
            aae = (eil-espml)*dleneri
            je = aae
            aae = aae - je
          ELSE
            tau = e/prm
            beta2 = tau*(tau+2)/(tau+1)**2
            aae = (beta2 - b2spin_min)*dbeta2i
            je = aae
            aae = aae - je
            je = je + 15 + 1
          END IF
          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
        END IF
        neke = meke(medium)
        DO 12251 i=1,neke - 1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          IF (( e .LE. espin_min )) THEN
            si2e = eta_array(0,0)
            si2p = eta_array(1,0)
          ELSE
            IF (( e .LE. espin_max )) THEN
              aae = (eil-espml)*dleneri
              je = aae
              aae = aae - je
            ELSE
              tau = e/prm
              beta2 = tau*(tau+2)/(tau+1)**2
              aae = (beta2 - b2spin_min)*dbeta2i
              je = aae
              aae = aae - je
              je = je + 15 + 1
            END IF
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
          END IF
          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil
          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium)
          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil
          si1e = si2e
          si1p = si2p
12251   CONTINUE
12252   CONTINUE
        etae_ms1(neke,medium) = etae_ms1(neke-1,medium)
        etae_ms0(neke,medium) = etae_ms0(neke-1,medium)
        etap_ms1(neke,medium) = etap_ms1(neke-1,medium)
        etap_ms0(neke,medium) = etap_ms0(neke-1,medium)
        DO 12261 i=0,15
          elarray(i) = Log(earray(i)/1000)
          farray(i) = c_array(0,i)
12261   CONTINUE
12262   CONTINUE
        DO 12271 i=15+1, 31-1
          elarray(i) = Log(earray(i+1)/1000)
          farray(i) = c_array(0,i+1)
12271   CONTINUE
12272   CONTINUE
        ndata =  31+1
        IF (( ue(medium) .GT. 1e5 )) THEN
          elarray(ndata-1) = Log(ue(medium))
        ELSE
          elarray(ndata-1) = Log(1e5)
        END IF
        farray(ndata-1) = 1
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 12281 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil
          si1e = si2e
12281   CONTINUE
12282   CONTINUE
        q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium)
        q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium)
        DO 12291 i=0,15
          farray(i) = c_array(1,i)
12291   CONTINUE
12292   CONTINUE
        DO 12301 i=15+1, 31-1
          farray(i) = c_array(1,i+1)
12301   CONTINUE
12302   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 12311 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil
          si1e = si2e
12311   CONTINUE
12312   CONTINUE
        q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium)
        q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium)
        DO 12321 i=0,15
          farray(i) = g_array(0,i)
12321   CONTINUE
12322   CONTINUE
        DO 12331 i=15+1, 31-1
          farray(i) = g_array(0,i+1)
12331   CONTINUE
12332   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 12341 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil
          si1e = si2e
12341   CONTINUE
12342   CONTINUE
        q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium)
        q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium)
        DO 12351 i=0,15
          farray(i) = g_array(1,i)
12351   CONTINUE
12352   CONTINUE
        DO 12361 i=15+1, 31-1
          farray(i) = g_array(1,i+1)
12361   CONTINUE
12362   CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 12371 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil
12371   CONTINUE
12372   CONTINUE
        q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium)
        q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium)
        tauc = te(medium)/prm
        si1e = 1
        DO 12381 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          leil=i+1
          tau=e/prm
          IF (( tau .GT. 2*tauc )) THEN
            sig=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
            dedx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
            sig = sig/dedx
            IF (( sig .GT. 1e-6 )) THEN
              etap=etae_ms1(Leil,MEDIUM)*eil+etae_ms0(Leil,MEDIUM)
              eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2)
              g_r = (1+2*eta)*Log(1+1/eta)-2
              g_m = Log(0.5*tau/tauc)+ (1+((tau+2)/(tau+1))**2)*Log(2*(t
     *        au-tauc+2)/(tau+4))- 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+
     *        1)**2)* Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+ 0.5*(tau
     *        -2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2)
              IF (( g_m .LT. g_r )) THEN
                g_m = g_m/g_r
              ELSE
                g_m = 1
              END IF
              si2e = 1 - g_m*sum_Z/sum_Z2
            ELSE
              si2e = 1
            END IF
          ELSE
            si2e = 1
          END IF
          blcce1(i,medium) = (si2e - si1e)*eke1(medium)
          blcce0(i,medium) = si2e - blcce1(i,medium)*eil
          si1e = si2e
12381   CONTINUE
12382   CONTINUE
        blcce1(neke,medium) = blcce1(neke-1,medium)
        blcce0(neke,medium) = blcce0(neke-1,medium)
        write(6,'(a)') ' done'
        write(1,'(a)') ' done'
12071 CONTINUE
12072 CONTINUE
      return
12130 write(6,*) ' ******************** Error in init_spin *************
     ******* '
      write(1,*) ' ******************** Error in init_spin *************
     ******* '
      write(6,'(a,a)') '  could not open file ',spin_file
      write(1,'(a,a)') '  could not open file ',spin_file
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' terminating execution '
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      subroutine msdist_pII ( e0,eloss,tustep,rhof,med,qel,spin_effects,
     *u0,v0,w0,x0,y0,z0,  us,vs,ws,xf,yf,zf,ustep )
      implicit none
      real*8 e0,  eloss,  rhof,  tustep,  u0,  v0,  w0,  x0,  y0,  z0
      integer*4 med, qel
      logical spin_effects
      real*8 us,  vs,  ws,  xf,  yf,  zf,  ustep
      real*8 b,  blccc,  xcccc,  c,  eta,eta1,  chia2,  chilog,  cphi0,
     *  cphi1,  cphi2,  w1,  w2,  w1v2,  delta,  e,  elke,  beta2,  etap
     *,  xi_corr,  ms_corr, tau,  tau2,  epsilon,  epsilonp,  temp,temp1
     *, temp2,  factor,  gamma,  lambda,   p2,  p2i,  q1,  rhophi2,  sin
     *t0,  sint02,  sint0i,  sint1,  sint2,  sphi0,   sphi1,  sphi2,  u2
     *p,  u2,  v2,  ut,  vt,  wt,  xi,  xphi,  xphi2,  yphi,  yphi2
      logical find_index,  spin_index
      integer*4 lelke
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      medium = med
      count_pII_steps = count_pII_steps + 1
      blccc = blcc(medium)
      xcccc = xcc(medium)
      e = e0 - 0.5*eloss
      tau = e/prm
      tau2 = tau*tau
      epsilon = eloss/e0
      epsilonp= eloss/e
      e = e * (1 - epsilonp*epsilonp*(6+10*tau+5*tau2)/(24*tau2+72*tau+4
     *8))
      p2 = e*(e + rmt2)
      beta2 = p2/(p2 + rmsq)
      chia2 = xcccc/(4*p2*blccc)
      lambda = 0.5*tustep*rhof*blccc/beta2
      temp2 = 0.166666*(4+tau*(6+tau*(7+tau*(4+tau))))* (epsilonp/((tau+
     *1)*(tau+2)))**2
      lambda = lambda*(1 - temp2)
      IF (( spin_effects )) THEN
        elke = Log(e)
        Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
        IF (( lelke .LT. 1 )) THEN
          lelke = 1
          elke = (1 - eke0(medium))/eke1(medium)
        END IF
        IF (( qel .EQ. 0 )) THEN
          etap=etae_ms1(Lelke,MEDIUM)*elke+etae_ms0(Lelke,MEDIUM)
          xi_corr=q1ce_ms1(Lelke,MEDIUM)*elke+q1ce_ms0(Lelke,MEDIUM)
          gamma=q2ce_ms1(Lelke,MEDIUM)*elke+q2ce_ms0(Lelke,MEDIUM)
        ELSE
          etap=etap_ms1(Lelke,MEDIUM)*elke+etap_ms0(Lelke,MEDIUM)
          xi_corr=q1cp_ms1(Lelke,MEDIUM)*elke+q1cp_ms0(Lelke,MEDIUM)
          gamma=q2cp_ms1(Lelke,MEDIUM)*elke+q2cp_ms0(Lelke,MEDIUM)
        END IF
        ms_corr=blcce1(Lelke,MEDIUM)*elke+blcce0(Lelke,MEDIUM)
      ELSE
        etap = 1
        xi_corr = 1
        gamma = 1
        ms_corr = 1
      END IF
      chia2 = chia2*etap
      lambda = lambda/(etap*(1+chia2))*ms_corr
      chilog = Log(1 + 1/chia2)
      q1 = 2*chia2*(chilog*(1 + chia2) - 1)
      gamma = 6*chia2*(1 + chia2)*(chilog*(1 + 2*chia2) - 2)/q1*gamma
      xi = q1*lambda
      find_index = .true.
      spin_index = .true.
      call mscat(lambda,chia2,xi,elke,beta2,qel,medium, spin_effects,fin
     *d_index,spin_index, w1,sint1)
12391 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        xphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF((rng_seed .GT. 128))call ranmar_get
        yphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO12392
      GO TO 12391
12392 CONTINUE
      rhophi2 = 1/rhophi2
      cphi1 = (xphi2 - yphi2)*rhophi2
      sphi1 = 2*xphi*yphi*rhophi2
      call mscat(lambda,chia2,xi,elke,beta2,qel,medium, spin_effects,fin
     *d_index,spin_index, w2,sint2)
12401 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        xphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF((rng_seed .GT. 128))call ranmar_get
        yphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO12402
      GO TO 12401
12402 CONTINUE
      rhophi2 = 1/rhophi2
      cphi2 = (xphi2 - yphi2)*rhophi2
      sphi2 = 2*xphi*yphi*rhophi2
      u2 = sint2*cphi2
      v2 = sint2*sphi2
      u2p = w1*u2 + sint1*w2
      us = u2p*cphi1 - v2*sphi1
      vs = u2p*sphi1 + v2*cphi1
      ws = w1*w2 - sint1*u2
      xi = 2*xi*xi_corr
      IF((rng_seed .GT. 128))call ranmar_get
      eta = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      eta = Sqrt(eta)
      eta1 = 0.5*(1 - eta)
      delta = 0.9082483-(0.1020621-0.0263747*gamma)*xi
      temp1 = 2 + tau
      temp = (2+tau*temp1)/((tau+1)*temp1)
      temp = temp - (tau+1)/((tau+2)*(chilog*(1+chia2)-1))
      temp = temp * epsilonp
      temp1 = 1 - temp
      delta = delta + 0.40824829*(epsilon*(tau+1)/((tau+2)* (chilog*(1+c
     *hia2)-1)*(chilog*(1+2*chia2)-2)) - 0.25*temp*temp)
      b = eta*delta
      c = eta*(1-delta)
      w1v2 = w1*v2
      ut = b*sint1*cphi1 + c*(cphi1*u2 - sphi1*w1v2) + eta1*us*temp1
      vt = b*sint1*sphi1 + c*(sphi1*u2 + cphi1*w1v2) + eta1*vs*temp1
      wt = eta1*(1+temp) + b*w1 + c*w2 + eta1*ws*temp1
      ustep = tustep*sqrt(ut*ut + vt*vt + wt*wt)
      sint02 = u0**2 + v0**2
      IF ((sint02 .GT. 1e-20)) THEN
        sint0 = sqrt(sint02)
        sint0i = 1/sint0
        cphi0 = sint0i*u0
        sphi0 = sint0i*v0
        u2p = w0*us + sint0*ws
        ws = w0*ws - sint0*us
        us = u2p*cphi0 - vs*sphi0
        vs = u2p*sphi0 + vs*cphi0
        u2p = w0*ut + sint0*wt
        wt = w0*wt - sint0*ut
        ut = u2p*cphi0 - vt*sphi0
        vt = u2p*sphi0 + vt*cphi0
      ELSE
        wt = w0*wt
        ws = w0*ws
      END IF
      xf = x0 + tustep*ut
      yf = y0 + tustep*vt
      zf = z0 + tustep*wt
      return
      end
      subroutine msdist_pI ( e0,eloss,tustep,rhof,medium,qel,spin_effect
     *s,u0,v0,w0,x0,y0,z0,  us,vs,ws,xf,yf,zf,ustep )
      implicit none
      real*8 e0,  eloss,  rhof,  tustep,  u0,  v0,  w0,  x0,  y0,  z0
      integer*4 medium, qel
      logical spin_effects
      real*8 us,  vs,  ws,  xf,  yf,  zf,  ustep
      real*8 blccc,  xcccc,  z,r,z2,r2,  r2max, chia2,  chilog,  cphi0,
     *  cphi,  sphi,  e,  elke,  beta2,  etap,  xi_corr,  ms_corr, epsil
     *on,  temp,  factor,  lambda,  p2,  p2i,  q1,  rhophi2,  sint,  sin
     *t0,  sint02,  sint0i,  sphi0,   u2p,  ut,  vt,  wt,  xi,  xphi,  x
     *phi2,  yphi,  yphi2
      logical find_index,  spin_index
      integer*4 lelke
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      real*8 ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_new,B
     *y_new,Bz_new
      logical emfield_on
      blccc = blcc(medium)
      xcccc = xcc(medium)
      e = e0 - 0.5*eloss
      p2 = e*(e + rmt2)
      p2i = 1/p2
      chia2 = xcccc*p2i/(4*blccc)
      beta2 = p2/(p2 + rmsq)
      lambda = tustep*rhof*blccc/beta2
      factor = 1/(1 + 0.9784671*e)
      epsilon= eloss/e0
      epsilon= epsilon/(1-0.5*epsilon)
      temp = 0.25*(1 - factor*(1 - 0.333333*factor))*epsilon**2
      lambda = lambda*(1 + temp)
      IF (( spin_effects )) THEN
        elke = Log(e)
        Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
        IF (( lelke .LT. 1 )) THEN
          lelke = 1
          elke = (1 - eke0(medium))/eke1(medium)
        END IF
        IF (( qel .EQ. 0 )) THEN
          etap=etae_ms1(Lelke,MEDIUM)*elke+etae_ms0(Lelke,MEDIUM)
          xi_corr=q1ce_ms1(Lelke,MEDIUM)*elke+q1ce_ms0(Lelke,MEDIUM)
        ELSE
          etap=etap_ms1(Lelke,MEDIUM)*elke+etap_ms0(Lelke,MEDIUM)
          xi_corr=q1cp_ms1(Lelke,MEDIUM)*elke+q1cp_ms0(Lelke,MEDIUM)
        END IF
        ms_corr=blcce1(Lelke,MEDIUM)*elke+blcce0(Lelke,MEDIUM)
      ELSE
        etap = 1
        xi_corr = 1
        ms_corr = 1
      END IF
      chia2 = xcccc*p2i/(4*blccc)*etap
      lambda = lambda/etap/(1+chia2)*ms_corr
      chilog = Log(1 + 1/chia2)
      q1 = 2*chia2*(chilog*(1 + chia2) - 1)
      xi = q1*lambda
      find_index = .true.
      spin_index = .true.
      call mscat(lambda,chia2,xi,elke,beta2,qel,medium, spin_effects,fin
     *d_index,spin_index, ws,sint)
12411 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        xphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF((rng_seed .GT. 128))call ranmar_get
        yphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO12412
      GO TO 12411
12412 CONTINUE
      rhophi2 = 1/rhophi2
      cphi = (xphi2 - yphi2)*rhophi2
      sphi = 2*xphi*yphi*rhophi2
      us = sint*cphi
      vs = sint*sphi
      xi = xi*xi_corr
      IF (( xi .LT. 0.1 )) THEN
        z = 1 - xi*(0.5 - xi*(0.166666667 - 0.041666667*xi))
      ELSE
        z = (1 - Exp(-xi))/xi
      END IF
      r = 0.5*sint
      r2 = r*r
      z2 = z*z
      r2max = 1 - z2
      IF (( r2max .LT. r2 )) THEN
        r2 = r2max
        r = Sqrt(r2)
      END IF
      ut = r*cphi
      vt = r*sphi
      wt = z
      ustep = Sqrt(z2 + r2)*tustep
      sint02 = u0**2 + v0**2
      IF ((sint02 .GT. 1e-20)) THEN
        sint0 = sqrt(sint02)
        sint0i = 1/sint0
        cphi0 = sint0i*u0
        sphi0 = sint0i*v0
        u2p = w0*us + sint0*ws
        ws = w0*ws - sint0*us
        us = u2p*cphi0 - vs*sphi0
        vs = u2p*sphi0 + vs*cphi0
        u2p = w0*ut + sint0*wt
        wt = w0*wt - sint0*ut
        ut = u2p*cphi0 - vt*sphi0
        vt = u2p*sphi0 + vt*cphi0
      ELSE
        wt = w0*wt
        ws = w0*ws
      END IF
      xf = x0 + tustep*ut
      yf = y0 + tustep*vt
      zf = z0 + tustep*wt
      return
      end
      SUBROUTINE PAIR
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      common/nrc_pair/ nrcp_fdata(65,84,3), nrcp_wdata(65,84,3), nrcp_id
     *ata(65,84,3), nrcp_xdata(65), nrcp_emin, nrcp_emax, nrcp_dle, nrcp
     *_dlei
      real*8 nrcp_fdata,nrcp_wdata,nrcp_xdata, nrcp_emin, nrcp_emax, nrc
     *p_dle, nrcp_dlei
      integer*4 nrcp_idata
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/triplet_data/ a_triplet(250,3), b_triplet(250,3), dl_triple
     *t, dli_triplet, bli_triplet, log_4rm
      real*8 a_triplet,b_triplet,dl_triplet, dli_triplet, bli_triplet, l
     *og_4rm
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DOUBLE PRECISION PEIG,  PESE1,  PESE2
      real*8 EIG,  ESE2,  RNNO30,RNNO31,rnno32,rnno33,rnno34,  DELTA,  R
     *EJF,  rejmax,  aux1,aux2,  Amax,  Bmax,  del0,  br,
     *                               Eminus,Eplus,Eavail,rnno_RR
      integer*4
     *                     L,L1
      real*8 ESE,  PSE,  ZTARG,  TTEIG,  TTESE,  TTPSE,  ESEDEI, ESEDER,
     * XIMIN,  XIMID,  REJMIN, REJMID, REJTOP, YA,XITRY,GALPHA,GBETA,  X
     *ITST,  REJTST_on_REJTOP ,  REJTST, RTEST
      integer*4 ICHRG
      real*8 k,xx,abin,rbin,alias_sample1
      integer*4 ibin, iq1, iq2, iprdst_use
      logical do_nrc_pair
      integer*4 itrip
      real*8 ftrip
      NPold = NP
      IF (( i_play_RR .EQ. 1 )) THEN
        i_survived_RR = 0
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,'(a,g14.6)') 'Attempt to play Russian Roulette w
     *ith prob_RR<0! '
          END IF
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          rnno_RR = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF (( rnno_RR .GT. prob_RR )) THEN
            i_survived_RR =2
            IF (( np .GT. 1 )) THEN
              np = np-1
            ELSE
              wt(np) = 0
              e(np) = 0
            END IF
            return
          ELSE
            wt(np) = wt(np)/prob_RR
          END IF
        END IF
      END IF
      IF (( np+1 .GT. 40 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','PAIR', ' sta
     *ck size exceeded! ',' $MAXSTACK = ',40,' np = ',np+1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      PEIG=E(NP)
      EIG=PEIG
      do_nrc_pair = .false.
      IF (( itriplet .GT. 0 .AND. eig .GT. 4*rm )) THEN
        itrip = dli_triplet*gle + bli_triplet
        ftrip = a_triplet(itrip,medium)*gle + b_triplet(itrip,medium)
        IF((rng_seed .GT. 128))call ranmar_get
        rnno34 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( rnno34 .LT. ftrip )) THEN
          call sample_triplet
          return
        END IF
      END IF
      IF (( pair_nrc .EQ. 1 )) THEN
        k = eig/rm
        IF (( k .LT. nrcp_emax )) THEN
          do_nrc_pair = .true.
          IF (( k .LE. nrcp_emin )) THEN
            ibin = 1
          ELSE
            abin = 1 + log((k-2)/(nrcp_emin-2))*nrcp_dlei
            ibin = abin
            abin = abin - ibin
            IF((rng_seed .GT. 128))call ranmar_get
            rbin = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rbin .LT. abin))ibin = ibin + 1
          END IF
          xx = alias_sample1(64,nrcp_xdata, nrcp_fdata(1,ibin,medium),nr
     *    cp_wdata(1,ibin,medium), nrcp_idata(1,ibin,medium))
          IF (( xx .GT. 0.5 )) THEN
            pese1 = prm*(1 + xx*(k-2))
            iq1 = 1
            pese2 = peig - pese1
            iq2 = -1
          ELSE
            pese2 = prm*(1 + xx*(k-2))
            iq2 = 1
            pese1 = peig - pese2
            iq1 = -1
          END IF
        END IF
      END IF
      IF (( .NOT.do_nrc_pair )) THEN
        IF ((EIG.LE.2.1)) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO30 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF((rng_seed .GT. 128))call ranmar_get
          rnno34 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          PESE2 = PRM + 0.5*RNNO30*(PEIG-2*PRM)
          PESE1 = PEIG - PESE2
          IF (( rnno34 .LT. 0.5 )) THEN
            iq1 = -1
            iq2 = 1
          ELSE
            iq1 = 1
            iq2 = -1
          END IF
        ELSE
          IF ((EIG.LT.50.)) THEN
            L = 5
            L1 = L + 1
            delta = 4*delcm(medium)/eig
            IF (( delta .LT. 1 )) THEN
              Amax = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medi
     *        um))
              Bmax = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,m
     *        edium))
            ELSE
              aux2 = log(delta+dl6(l,medium))
              Amax = dl4(l,medium)+dl5(l,medium)*aux2
              Bmax = dl4(l1,medium)+dl5(l1,medium)*aux2
            END IF
            aux1 = 1 - rmt2/eig
            aux1 = aux1*aux1
            aux1 = aux1*Amax/3
            aux1 = aux1/(Bmax+aux1)
          ELSE
            L = 7
            Amax = dl1(l,medium)
            Bmax = dl1(l+1,medium)
            aux1 = bpar(2,medium)*(1-bpar(1,medium)*rm/eig)
          END IF
          del0 = eig*delcm(medium)
          Eavail = eig - rmt2
12421     CONTINUE
            IF((rng_seed .GT. 128))call ranmar_get
            RNNO30 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rng_seed .GT. 128))call ranmar_get
            RNNO31 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF((rng_seed .GT. 128))call ranmar_get
            RNNO34 = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            IF (( rnno30 .GT. aux1 )) THEN
              br = 0.5*rnno31
              rejmax = Bmax
              l1 = l+1
            ELSE
              IF((rng_seed .GT. 128))call ranmar_get
              rnno32 = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF((rng_seed .GT. 128))call ranmar_get
              rnno33 = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              br = 0.5*(1-max(rnno31,rnno32,rnno33))
              rejmax = Amax
              l1 = l
            END IF
            Eminus = br*Eavail + rm
            Eplus = eig - Eminus
            delta = del0/(Eminus*Eplus)
            IF (( delta .LT. 1 )) THEN
              rejf = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,m
     *        edium))
            ELSE
              rejf = dl4(l1,medium)+dl5(l1,medium)*log(delta+dl6(l1,medi
     *        um))
            END IF
            IF((( rnno34*rejmax .LE. rejf )))GO TO12422
          GO TO 12421
12422     CONTINUE
          pese2 = Eminus
          pese1 = peig - pese2
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO34 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF (( rnno34 .LT. 0.5 )) THEN
            iq1 = -1
            iq2 = 1
          ELSE
            iq1 = 1
            iq2 = -1
          END IF
        END IF
      END IF
      ESE2=PESE2
      E(NP)=PESE1
      E(NP+1)=PESE2
      IF (( iprdst .GT. 0 )) THEN
        IF (( iprdst .EQ. 4 )) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          rtest = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          gbeta = PESE1/(PESE1+10)
          IF (( rtest .LT. gbeta )) THEN
            iprdst_use = 1
          ELSE
            iprdst_use = 4
          END IF
        ELSE IF(( iprdst .EQ. 2 .AND. eig .LT. 4.14 )) THEN
          iprdst_use = 1
        ELSE
          iprdst_use = iprdst
        END IF
        DO 12431 ichrg=1,2
          IF ((ICHRG.EQ.1)) THEN
            ESE=PESE1
          ELSE
            ESE=ESE2
            IF (( iprdst .EQ. 4 )) THEN
              gbeta = ESE/(ESE+10)
              IF((rng_seed .GT. 128))call ranmar_get
              rtest = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rtest .LT. gbeta )) THEN
                iprdst_use = 1
              ELSE
                iprdst_use = 4
              END IF
            END IF
          END IF
          IF (( iprdst_use .EQ. 1 )) THEN
            PSE=SQRT(MAX(0.0,(ESE-RM)*(ESE+RM)))
            IF((rng_seed .GT. 128))call ranmar_get
            COSTHE = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            COSTHE=1.0-2.0*COSTHE
            SINTHE=RM*SQRT((1.0-COSTHE)*(1.0+COSTHE))/(PSE*COSTHE+ESE)
            COSTHE=(ESE*COSTHE+PSE)/(PSE*COSTHE+ESE)
          ELSE IF(( iprdst_use .EQ. 2 )) THEN
            ZTARG=ZBRANG(MEDIUM)
            TTEIG=EIG/RM
            TTESE=ESE/RM
            TTPSE=SQRT((TTESE-1.0)*(TTESE+1.0))
            ESEDEI=TTESE/(TTEIG-TTESE)
            ESEDER=1.0/ESEDEI
            XIMIN=1.0/(1.0+(3.141593*TTESE)**2)
            REJMIN = 2.0+3.0*(ESEDEI+ESEDER) - 4.00*(ESEDEI+ESEDER+1.0-4
     *      .0*(XIMIN-0.5)**2)*( 1.0+0.25*LOG( ((1.0+ESEDER)*(1.0+ESEDEI
     *      )/(2.*TTEIG))**2+ZTARG*XIMIN**2 ) )
            YA=(2.0/TTEIG)**2
            XITRY=MAX(0.01,MAX(XIMIN,MIN(0.5,SQRT(YA/ZTARG))))
            GALPHA=1.0+0.25*LOG(YA+ZTARG*XITRY**2)
            GBETA=0.5*ZTARG*XITRY/(YA+ZTARG*XITRY**2)
            GALPHA=GALPHA-GBETA*(XITRY-0.5)
            XIMID=GALPHA/(3.0*GBETA)
            IF ((GALPHA.GE.0.0)) THEN
              XIMID=0.5-XIMID+SQRT(XIMID**2+0.25)
            ELSE
              XIMID=0.5-XIMID-SQRT(XIMID**2+0.25)
            END IF
            XIMID=MAX(0.01,MAX(XIMIN,MIN(0.5,XIMID)))
            REJMID = 2.0+3.0*(ESEDEI+ESEDER) - 4.00*(ESEDEI+ESEDER+1.0-4
     *      .0*(XIMID-0.5)**2)*( 1.0+0.25*LOG( ((1.0+ESEDER)*(1.0+ESEDEI
     *      )/(2.*TTEIG))**2+ZTARG*XIMID**2 ) )
            REJTOP=1.02*MAX(REJMIN,REJMID)
12441       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              XITST = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              REJTST = 2.0+3.0*(ESEDEI+ESEDER) - 4.00*(ESEDEI+ESEDER+1.0
     *        -4.0*(XITST-0.5)**2)*( 1.0+0.25*LOG( ((1.0+ESEDER)*(1.0+ES
     *        EDEI)/(2.*TTEIG))**2+ZTARG*XITST**2 ) )
              IF((rng_seed .GT. 128))call ranmar_get
              RTEST = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              THETA=SQRT(1.0/XITST-1.0)/TTESE
              REJTST_on_REJTOP = REJTST/REJTOP
              IF((((RTEST .LE. REJTST_on_REJTOP) .AND. (THETA .LT. PI) )
     *        ))GO TO12442
            GO TO 12441
12442       CONTINUE
            SINTHE=SIN(THETA)
            COSTHE=COS(THETA)
          ELSE IF(( iprdst_use .EQ. 3 )) THEN
            IF((rng_seed .GT. 128))call ranmar_get
            COSTHE = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            COSTHE=1.0-2.0*COSTHE
            sinthe=(1-costhe)*(1+costhe)
            IF (( sinthe .GT. 0 )) THEN
              sinthe = sqrt(sinthe)
            ELSE
              sinthe = 0
            END IF
          ELSE
            IF((rng_seed .GT. 128))call ranmar_get
            costhe = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            costhe=1-2*sqrt(costhe)
            sinthe=(1-costhe)*(1+costhe)
            IF (( sinthe .GT. 0 )) THEN
              sinthe=sqrt(sinthe)
            ELSE
              sinthe=0
            END IF
          END IF
          IF (( ichrg .EQ. 1 )) THEN
            CALL UPHI(2,1)
          ELSE
            sinthe=-sinthe
            NP=NP+1
            CALL UPHI(3,2)
          END IF
12431   CONTINUE
12432   CONTINUE
        iq(np) = iq2
        iq(np-1) = iq1
        return
      ELSE
        THETA=0
      END IF
      CALL UPHI(1,1)
      NP=NP+1
      SINTHE=-SINTHE
      CALL UPHI(3,2)
      IQ(NP)=iq2
      IQ(NP-1)=iq1
      RETURN
      END
      subroutine sample_triplet
      implicit none
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/USERVR/ CEXPTR,GWAIT,PATHL,DUMU,DUMX,DUMY,DUMZ, DELTAP,GWTO
     *LD,EPSLON,ARG,EXPMFP,ESAVEIN, IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM, IFO
     *RCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN, MEDTMP,IREJCT
      real*8 CEXPTR,GWAIT,DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,GWTOLD,EPSLON
     *,ARG, EXPMFP,ESAVEIN
      integer*4 NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN,IFORCE,IRODU
     *M, IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,IREJCT
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 fmax_array(250), eta_p_array(250), eta_Ep_array(250), eta_c
     *ostp_array(250), eta_costm_array(250), ebin_array(250), wp_array(2
     *50), qmin_array(250)
      real*8 kmin, kmax, dlogki, alogkm, prmi, tiny_eta
      real*8 ai,rnno,k,qmin,qmax,aux,a1,a2,a3,D,px1,px2,pp_min,pp_max, E
     *p_min,Ep_max,k2p2,k2p2x,peig,b,aux1,aux12,D1,aux3,xmin,xmax, aux6,
     *aux7,uu,cphi,sphi,cphi_factor,aux5,phi,tmp
      real*8 Er,pr,pr2,eta_pr
      real*8 Ep,pp,pp2,wEp,cost_p,sint_p,eta_Ep,mup_min,wmup, eta_costp,
     *Epp,pp_sintp,pp_sntp2
      real*8 Em,pm,pm2,cost_m,sint_m,Emm,wmum,pm_sintm, eta_costm
      real*8 k2,k3,s2,s3,k2k3i,k22,k32,q2,aux4,S_1,S_2,sigma
      real*8 ppx, ppy, ppz, pmx, pmy, pmz, prx, pry, prz, a,c,sindel,cos
     *del,sinpsi
      integer*4 i
      logical use_it
      integer*4 iscore
      logical is_initialized
      data is_initialized/.false./
      save is_initialized,fmax_array,eta_p_array,eta_Ep_array,eta_costp_
     *array, eta_costm_array,ebin_array,wp_array,qmin_array, kmin,kmax,d
     *logki,alogkm,prmi,tiny_eta
      IF (( .NOT.is_initialized )) THEN
        is_initialized = .true.
        tiny_eta = 1e-6
        DO 12451 i=1,250
          fmax_array(i) = -1
12451   CONTINUE
12452   CONTINUE
        kmax = 0
        kmin = 4.1*prm
        DO 12461 i=1,nmed
          IF((up(i) .GT. kmax))kmax = UP(i)
12461   CONTINUE
12462   CONTINUE
        IF((kmax .LE. kmin))return
        dlogki = 250 - 1
        dlogki = dlogki/log(kmax/kmin)
        alogkm = 1 - dlogki*log(kmin)
        prmi = 1/prm
        DO 12471 i=1,250
          k = 4.1*exp((i-1.)/dlogki)
          ebin_array(i) = k
          qmin = 4*k/(k*(k-1)+(k+1)*sqrt(k*(k-4)))
          qmax = (k*(k-1) + (k+1)*sqrt(k*(k-4)))/(2*k+1)
          qmin_array(i) = qmin
          wp_array(i) = log(qmax/qmin)
12471   CONTINUE
12472   CONTINUE
      END IF
      peig = e(np)
      IF((peig .LE. 4*prm))return
      IF (( np+2 .GT. 40 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','sample_tripl
     *et', ' stack size exceeded! ',' $MAXSTACK = ',40,' np = ',np+2
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( peig .LE. kmin )) THEN
        i = 1
      ELSE IF(( peig .GE. kmax )) THEN
        i = 250
      ELSE
        ai = alogkm + dlogki*gle
        i = ai
        ai = ai - i
        IF((rng_seed .GT. 128))call ranmar_get
        rnno = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( rnno .LT. ai )) THEN
          i = i+1
        END IF
      END IF
      k = ebin_array(i)
12480 CONTINUE
      IF((rng_seed .GT. 128))call ranmar_get
      eta_pr = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((eta_pr .LT. tiny_eta))eta_pr = tiny_eta
      pr = qmin_array(i)*exp(eta_pr*wp_array(i))
      pr2 = pr*pr
      Er = sqrt(1+pr2)
      aux = Er-pr-1
      a1=(k-pr)*(1-Er-k*aux)
      a2=1+k-Er
      a3=1/(aux*(pr+Er-2*k-1))
      D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2))
      px1 = (a1 + D)*a3
      px2 = (a1 - D)*a3
      IF (( px1 .LT. px2 )) THEN
        pp_min = px1
        pp_max = px2
      ELSE
        pp_min = px2
        pp_max = px1
      END IF
      Ep_min = sqrt(1 + pp_min*pp_min)
      Ep_max = sqrt(1 + pp_max*pp_max)
      IF((rng_seed .GT. 128))call ranmar_get
      eta_Ep = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((eta_Ep .LT. tiny_eta))eta_Ep = tiny_eta
      wEp = Ep_max - Ep_min
      Ep = Ep_min + eta_Ep*wEp
      pp2 = Ep*Ep - 1
      pp = sqrt(pp2)
      k2p2 = k*k + pp2
      Em = k + 1 - Er - Ep
      pm2 = Em*Em-1
      pm = sqrt(pm2)
      mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp)
      IF((rng_seed .GT. 128))call ranmar_get
      eta_costp = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((eta_costp .LT. tiny_eta))eta_costp = tiny_eta
      Epp = Ep/pp
      wmup = log((Epp-1)/(Epp-mup_min))
      cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp)
      wmup = wmup*(cost_p - Epp)
      sint_p = 1-cost_p*cost_p
      IF (( sint_p .GT. 1e-20 )) THEN
        sint_p = sqrt(sint_p)
      ELSE
        sint_p = 1e-10
      END IF
      k2p2x = k2p2 - 2*k*pp*cost_p
      b = pr2-k2p2x-pm2
      aux1 = k - pp*cost_p
      aux12 = aux1*aux1
      pp_sintp = pp*sint_p
      pp_sntp2 = pp_sintp*pp_sintp
      D1 = pm2*(aux12+pp_sntp2)-b*b/4
      IF (( D1 .LE. 0 )) THEN
        goto 12480
      END IF
      D = 2*pp_sintp*sqrt(D1)
      aux3 = 0.5/(aux12+pp_sntp2)
      xmin = (-b*aux1-D)*aux3
      xmax = (-b*aux1+D)*aux3
      IF((rng_seed .GT. 128))call ranmar_get
      eta_costm = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      IF((eta_costm .LT. tiny_eta))eta_costm = tiny_eta
      aux6 = sqrt((Em-xmin)/(Em-xmax))
      aux7 = aux6*tan(1.570796326794897*eta_costm)
      uu = (aux7-1)/(aux7+1)
      cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))
      wmum = sqrt((xmax-cost_m)*(cost_m-xmin))
      wmum = wmum*aux6*(Em-cost_m)/(Em-xmin)
      cost_m = cost_m/pm
      sint_m = sqrt(1-cost_m*cost_m)
      pm_sintm = pm*sint_m
      cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm)
      IF (( abs(cphi) .GE. 1 )) THEN
        goto 12480
      END IF
      sphi = sqrt(1-cphi*cphi)
      k3 = k*(pp*cost_p - Ep)
      k2 = k*(pm*cost_m - Em)
      k22 = k2*k2
      k32 = k3*k3
      k2k3i = 1/(k2*k3)
      s2 = pp*pm*(cost_p*cost_m + sint_p*sint_m*cphi) - Ep*Em
      s3 = k2 - Em + 1 - s2
      q2 = 2*(Er-1)
      S_1 = k32+k22+(q2-2)*s2-(1-q2/2)*(k32+k22)*k2k3i
      aux4 = k3*Ep-k2*Em
      S_2 = -q2*(Ep*Ep+Em*Em) + 2*s2 - (2*aux4*aux4 - k22 - k32)*k2k3i
      sigma = abs(pp*pm2*pm*k2k3i/(q2*q2*(Em*s3+Er))*(S_1*(1-q2/4)+S_2*(
     *1+q2/4)))
      cphi_factor = abs(2*Er*pm2-Em*(k2p2x-pr2-pm2))/(2*pp_sintp*pm_sint
     *m*pm2*sphi)
      sigma = sigma*cphi_factor*wEp*wmup*wmum*wp_array(i)*pr2/Er
      IF (( sigma .LT. 0 )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) 'In triplet sigma < 0 ? ',sigma
      END IF
      use_it = .true.
      IF (( sigma .LT. fmax_array(i) )) THEN
        IF((rng_seed .GT. 128))call ranmar_get
        rnno = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( sigma .LT. fmax_array(i)*rnno )) THEN
          use_it = .false.
        END IF
      END IF
      IF (( use_it )) THEN
        fmax_array(i) = sigma
        eta_p_array(i) = eta_pr
        eta_Ep_array(i) = eta_Ep
        eta_costp_array(i) = eta_costp
        eta_costm_array(i) = eta_costm
      ELSE
        eta_pr = eta_p_array(i)
        eta_Ep = eta_Ep_array(i)
        eta_costp = eta_costp_array(i)
        eta_costm = eta_costm_array(i)
      END IF
      k = peig*prmi
      aux5 = k*(k-1)+(k+1)*sqrt(k*(k-4))
      qmin = 4*k/aux5
      qmax = aux5/(2*k+1)
      pr = qmin*exp(eta_pr*log(qmax/qmin))
      pr2 = pr*pr
      Er = sqrt(1+pr2)
      aux = Er-pr-1
      a1=(k-pr)*(1-Er-k*aux)
      a2=1+k-Er
      a3=1/(aux*(pr+Er-2*k-1))
      D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2))
      px1 = (a1 + D)*a3
      px2 = (a1 - D)*a3
      IF (( px1 .LT. px2 )) THEN
        pp_min = px1
        pp_max = px2
      ELSE
        pp_min = px2
        pp_max = px1
      END IF
      Ep_min = sqrt(1 + pp_min*pp_min)
      Ep_max = sqrt(1 + pp_max*pp_max)
      wEp = Ep_max - Ep_min
      Ep = Ep_min + eta_Ep*wEp
      pp2 = Ep*Ep - 1
      pp = sqrt(pp2)
      k2p2 = k*k + pp2
      Em = k + 1 - Er - Ep
      pm2 = Em*Em-1
      pm = sqrt(pm2)
      mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp)
      Epp = Ep/pp
      wmup = log((Epp-1)/(Epp-mup_min))
      cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp)
      sint_p = sqrt(1-cost_p*cost_p)
      k2p2x = k2p2 - 2*k*pp*cost_p
      b = pr2-k2p2x-pm2
      aux1 = k - pp*cost_p
      aux12 = aux1*aux1
      pp_sintp = pp*sint_p
      pp_sntp2 = pp_sintp*pp_sintp
      D1 = pm2*(aux12+pp_sntp2)-b*b/4
      IF (( D1 .LE. 0 )) THEN
        goto 12480
      END IF
      D = 2*pp_sintp*sqrt(D1)
      aux3 = 0.5/(aux12+pp_sntp2)
      xmin = (-b*aux1-D)*aux3
      xmax = (-b*aux1+D)*aux3
      aux6 = sqrt((Em-xmin)/(Em-xmax))
      aux7 = aux6*tan(1.570796326794897*eta_costm)
      uu = (aux7-1)/(aux7+1)
      cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))/pm
      sint_m = sqrt(1-cost_m*cost_m)
      pm_sintm = pm*sint_m
      cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm)
      IF (( abs(cphi) .GE. 1 )) THEN
        goto 12480
      END IF
      sphi = sqrt(1-cphi*cphi)
      IF((rng_seed .GT. 128))call ranmar_get
      phi = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      phi = phi*6.283185307179586
      ppx = pp*sint_p
      ppy = 0
      pmx = pm*sint_m*cphi
      pmy = pm*sint_m*sphi
      cphi = cos(phi)
      sphi = sin(phi)
      tmp = ppx*sphi
      ppx = ppx*cphi - ppy*sphi
      ppy = tmp + ppy*cphi
      tmp = pmx*sphi
      pmx = pmx*cphi - pmy*sphi
      pmy = tmp + pmy*cphi
      ppz = pp*cost_p
      pmz = pm*cost_m
      prx = -ppx-pmx
      pry = -ppy-pmy
      prz = k - ppz - pmz
      NPold = np
      X(np)=X(np)
      Y(np)=Y(np)
      Z(np)=Z(np)
      IR(np)=IR(np)
      WT(np)=WT(np)
      DNEAR(np)=DNEAR(np)
      LATCH(np)=LATCH(np)
      X(np+1)=X(np)
      Y(np+1)=Y(np)
      Z(np+1)=Z(np)
      IR(np+1)=IR(np)
      WT(np+1)=WT(np)
      DNEAR(np+1)=DNEAR(np)
      LATCH(np+1)=LATCH(np)
      X(np+2)=X(np+1)
      Y(np+2)=Y(np+1)
      Z(np+2)=Z(np+1)
      IR(np+2)=IR(np+1)
      WT(np+2)=WT(np+1)
      DNEAR(np+2)=DNEAR(np+1)
      LATCH(np+2)=LATCH(np+1)
      pp = 1/pp
      pm = 1/pm
      pr = 1/pr
      a = u(np)
      b = v(np)
      c = w(np)
      sinpsi = a*a + b*b
      IF (( sinpsi .GT. 1e-20 )) THEN
        sinpsi = sqrt(sinpsi)
        sindel = b/sinpsi
        cosdel = a/sinpsi
        IF (( Ep .GT. Em )) THEN
          u(np) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz)
          v(np) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz)
          w(np) = pp*(c*ppz - sinpsi*ppx)
          iq(np) = 1
          E(np) = Ep*prm
          u(np+1) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz)
          v(np+1) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz)
          w(np+1) = pm*(c*pmz - sinpsi*pmx)
          iq(np+1) = -1
          E(np+1) = Em*prm
        ELSE
          u(np+1) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz)
          v(np+1) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz)
          w(np+1) = pp*(c*ppz - sinpsi*ppx)
          iq(np+1) = 1
          E(np+1) = Ep*prm
          u(np) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz)
          v(np) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz)
          w(np) = pm*(c*pmz - sinpsi*pmx)
          iq(np) = -1
          E(np) = Em*prm
        END IF
        np = np + 2
        u(np) = pr*(c*cosdel*prx - sindel*pry + a*prz)
        v(np) = pr*(c*sindel*prx + cosdel*pry + b*prz)
        w(np) = pr*(c*prz - sinpsi*prx)
        iq(np) = -1
        E(np) = Er*prm
      ELSE
        IF (( Ep .GT. Em )) THEN
          u(np) = pp*ppx
          v(np) = pp*ppy
          w(np) = c*pp*ppz
          iq(np) = 1
          E(np) = Ep*prm
          u(np+1) = pm*pmx
          v(np+1) = pm*pmy
          w(np+1) = c*pm*pmz
          iq(np+1) = -1
          E(np+1) = Em*prm
        ELSE
          u(np+1) = pp*ppx
          v(np+1) = pp*ppy
          w(np+1) = c*pp*ppz
          iq(np+1) = 1
          E(np+1) = Ep*prm
          u(np) = pm*pmx
          v(np) = pm*pmy
          w(np) = c*pm*pmz
          iq(np) = -1
          E(np) = Em*prm
        END IF
        np = np + 2
        u(np) = pr*prx
        v(np) = pr*pry
        w(np) = c*pr*prz
        iq(np) = -1
        E(np) = Er*prm
      END IF
      return
      end
      SUBROUTINE PHOTO
      implicit none
      COMMON/BOUNDS/ECUT( 1001),PCUT( 1001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(3), GE0(3),GE1(3), GMFP0(2000,3),GMFP1(2000,
     *3),GBR10(2000,3),GBR11(2000,3),GBR20(2000,3),GBR21(2000,3), RCO0(3
     *),RCO1(3), RSCT0(100,3),RSCT1(100,3), COHE0(2000,3),COHE1(2000,3),
     *  PHOTONUC0(2000,3),PHOTONUC1(2000,3), DPMFP, MPGEM(1,3), NGR(3)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      real*8 EELEC,  BETA,  GAMMA,  ALPHA,  RATIO,  RNPHT,  FKAPPA, XI,
     * SINTH2, RNPHT2
      DOUBLE PRECISION PEIG
      real*8 BR,  sigma,  aux,aux1,  probs(50),  sigtot,  e_vac,  rnno_R
     *R
      integer*4 IARG,  iZ,   irl,  ints(50),  j,ip,  n_warning,  k
      logical do_relax
      save n_warning
      data n_warning/0/
      IF (( mcdf_pe_xsections )) THEN
        call egs_shellwise_photo()
        return
      END IF
      NPold = NP
      PEIG=E(NP)
      irl = ir(np)
      IF (( peig .LT. edge_energies(2,1) )) THEN
        IF (( n_warning .LT. 100 )) THEN
          n_warning = n_warning + 1
          write(6,*) ' Subroutine PHOTO called with E = ',peig, ' which
     *is below the current min. energy of 1 keV! '
          write(1,*) ' Subroutine PHOTO called with E = ',peig, ' which
     *is below the current min. energy of 1 keV! '
          write(6,*) ' Converting now this photon to an electron, '
          write(1,*) ' Converting now this photon to an electron, '
          write(6,*) ' but you should check your code! '
          write(1,*) ' but you should check your code! '
        END IF
        iq(np) = -1
        e(np) = peig + prm
        return
      END IF
      iZ = iedgfl(irl)
      do_relax = .false.
      edep = pzero
      IF (( iedgfl(irl) .NE. 0 )) THEN
        IF (( nne(medium) .EQ. 1 )) THEN
          iZ = int( zelem(medium,1) + 0.5 )
          DO 12491 j=1,edge_number(iZ)
            IF((peig .GE. edge_energies(j,iZ)))GO TO12492
12491     CONTINUE
12492     CONTINUE
        ELSE
          aux = peig*peig
          aux1 = aux*peig
          aux = aux*Sqrt(peig)
          sigtot = 0
          DO 12501 k=1,nne(medium)
            iZ = int( zelem(medium,k) + 0.5 )
            IF (( iZ .LT. 1 .OR. iZ .GT. 100 )) THEN
              write(6,*) ' Error in PHOTO: '
              write(1,*) ' Error in PHOTO: '
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) '   Atomic number of element ',k, ' in medi
     *um ',medium,' is not between 1 and ',100
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            IF (( peig .GT. edge_energies(1,iZ) )) THEN
              j = 1
              sigma = (edge_a(1,iZ) + edge_b(1,iZ)/peig + edge_c(1,iZ)/a
     *        ux + edge_d(1,iZ)/aux1)/peig
            ELSE
              DO 12511 j=2,edge_number(iZ)
                IF((peig .GE. edge_energies(j,iZ)))GO TO12512
12511         CONTINUE
12512         CONTINUE
              sigma = edge_a(j,iZ) + gle*(edge_b(j,iZ) + gle*(edge_c(j,i
     *        Z) + gle*edge_d(j,iZ) ))
              sigma = Exp(sigma)
            END IF
            sigma = sigma * pz(medium,k)
            sigtot = sigtot + sigma
            probs(k) = sigma
            ints(k) = j
12501     CONTINUE
12502     CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          br = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          br = br*sigtot
          DO 12521 k=1,nne(medium)
            br = br - probs(k)
            IF((br .LE. 0))GO TO12522
12521     CONTINUE
12522     CONTINUE
          iZ = int( zelem(medium,k) + 0.5 )
          j = ints(k)
        END IF
        IF (( peig .LE. binding_energies(6,iZ) )) THEN
          iq(np) = -1
          e(np) = peig + prm
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          br = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          DO 12531 k=1,5
            IF (( peig .GT. binding_energies(k,iZ) )) THEN
              IF((br .LT. interaction_prob(k,iZ)))GO TO12532
              br = (br - interaction_prob(k,iZ))/(1-interaction_prob(k,i
     *        Z))
            END IF
12531     CONTINUE
12532     CONTINUE
          IF ((eadl_relax .AND. k .GT. 4)) THEN
            iq(np) = -1
            e(np) = peig + prm
          ELSE
            e_vac = binding_energies(k,iZ)
            e(np) = peig - e_vac + prm
            do_relax = .true.
            iq(np) = -1
          END IF
        END IF
      ELSE
        e(np) = peig + prm
        iq(np) = -1
      END IF
      IF (( iq(np) .EQ. -1 )) THEN
        IF ((IPHTER(IR(NP)).EQ.1)) THEN
          EELEC=E(NP)
          IF ((EELEC.GT.ECUT(IR(NP)))) THEN
            BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC
            GAMMA=EELEC/RM
            ALPHA=0.5*GAMMA-0.5+1./GAMMA
            RATIO=BETA/ALPHA
12541       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              RNPHT = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              RNPHT=2.*RNPHT-1.
              IF ((RATIO.LE.0.2)) THEN
                FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT)
                IF (( gamma .LT. 100 )) THEN
                  COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                ELSE
                  IF (( fkappa .GT. 0 )) THEN
                    costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gam
     *              ma-1)**3)
                  ELSE
                    COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                  END IF
                END IF
                xi = (1+beta*fkappa)*gamma*gamma
              ELSE
                XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO)
     *          )-1.))
                COSTHE=(1.-1./XI)/BETA
              END IF
              SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE))
              IF((rng_seed .GT. 128))call ranmar_get
              RNPHT2 = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF(RNPHT2.LE.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA)GO TO12542
            GO TO 12541
12542       CONTINUE
            SINTHE=SQRT(SINTH2)
            CALL UPHI(2,1)
          END IF
        END IF
      END IF
      IF (( do_relax )) THEN
        call relax(e_vac,k,iZ)
      END IF
      IF (( EDEP .GT. 0 )) THEN
        IARG=4
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,12550)prob_RR
12550       FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold
12561     CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF((rng_seed .GT. 128))call ranmar_get
              rnno_RR = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO12562
          GO TO 12561
12562     CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
      end
      subroutine egs_shellwise_photo
      implicit none
      COMMON/BOUNDS/ECUT( 1001),PCUT( 1001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(3), GE0(3),GE1(3), GMFP0(2000,3),GMFP1(2000,
     *3),GBR10(2000,3),GBR11(2000,3),GBR20(2000,3),GBR21(2000,3), RCO0(3
     *),RCO1(3), RSCT0(100,3),RSCT1(100,3), COHE0(2000,3),COHE1(2000,3),
     *  PHOTONUC0(2000,3),PHOTONUC1(2000,3), DPMFP, MPGEM(1,3), NGR(3)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,3),   pe_energy(500,100),  pe_zsorted(100,3), pe_be(100,16),
     * pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      real*8 pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      real*8 EELEC,  BETA,  GAMMA,  ALPHA,  RATIO,  RNPHT,  FKAPPA, XI,
     * SINTH2, RNPHT2
      DOUBLE PRECISION PEIG
      real*8 BR,  sigma,  aux,aux1,  probs(50),  sigtot,  e_vac,  rnno_R
     *R
      integer*4 IARG,  iZ,   irl,  ints(50),  j,ip,  n_warning,  k
      logical do_relax
      save n_warning
      real*8 slope, logE, int_prob
      integer*4 zpos, ibsearch
      data n_warning/0/
      NPold = NP
      PEIG=E(NP)
      irl = ir(np)
      do_relax = .false.
      IF (( peig .LT. 0.001 )) THEN
        IF (( n_warning .LT. 100 )) THEN
          n_warning = n_warning + 1
          write(6,*) ' Subroutine egs_shellwise_photo called with E = ',
     *     peig,' which is below the current min. energy of ', 0.001,' k
     *eV! '
          write(1,*) ' Subroutine egs_shellwise_photo called with E = ',
     *     peig,' which is below the current min. energy of ', 0.001,' k
     *eV! '
          write(6,*) ' Converting now this photon to an electron, '
          write(1,*) ' Converting now this photon to an electron, '
          write(6,*) ' but you should check your code! '
          write(1,*) ' but you should check your code! '
        END IF
        iq(np) = -1
        e(np) = peig + prm
        return
      END IF
      edep = pzero
      IF (( iedgfl(irl) .NE. 0 )) THEN
        j = -1
        IF (( nne(medium) .EQ. 1 )) THEN
          iZ = int( zelem(medium,1) + 0.5 )
          zpos = pe_zpos(iZ)
          IF (( pe_nshell(zpos) .GT. 0)) THEN
            logE = log(peig)
            j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos))
          END IF
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          br = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          logE = log(peig)
          DO 12571 k=nne(medium),1,-1
            iZ = int( zelem(medium,k) + 0.5 )
            zpos = pe_zpos(iZ)
            IF (( iZ .LT. 1 .OR. iZ .GT. 100 )) THEN
              write(6,*) ' Error in egs_shellwise_photo: '
              write(1,*) ' Error in egs_shellwise_photo: '
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) '   Atomic number of element ',k, ' in medi
     *um ',medium,' is not between 1 and ',100
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos))
            slope = pe_elem_prob(j+1,k,medium) - pe_elem_prob(j,k,medium
     *      )
            slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos))
            int_prob = pe_elem_prob(j,k,medium)+slope*(logE-pe_energy(j,
     *      zpos))
            br = br - exp(int_prob)
            IF((br .LE. 0))GO TO12572
12571     CONTINUE
12572     CONTINUE
        END IF
        IF (( peig .LT. pe_be(zpos,pe_nshell(zpos)) .OR. pe_nshell(zpos)
     *   .EQ. 0 )) THEN
          iq(np) = -1
          e(np) = peig + prm
        ELSE
          IF((rng_seed .GT. 128))call ranmar_get
          br = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          sigtot = 0
          DO 12581 k=1,pe_nshell(zpos)
            IF (( peig .GT. pe_be(zpos,k) )) THEN
              slope = pe_xsection(j+1,zpos,k) - pe_xsection(j,zpos,k)
              slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos))
              int_prob=pe_xsection(j,zpos,k)+slope*(logE-pe_energy(j,zpo
     *        s))
              br = br - exp(int_prob)
              sigtot = sigtot + exp(int_prob)
              IF((br .LE. 0))GO TO12582
            END IF
12581     CONTINUE
12582     CONTINUE
          IF ((k .GT. pe_nshell(zpos))) THEN
            iq(np) = -1
            e(np) = peig + prm
          ELSE
            e_vac = pe_be(zpos,k)
            e(np) = peig - e_vac + prm
            do_relax = .true.
            iq(np) = -1
          END IF
        END IF
      ELSE
        e(np) = peig + prm
        iq(np) = -1
      END IF
      IF (( iq(np) .EQ. -1 )) THEN
        IF ((IPHTER(IR(NP)).EQ.1)) THEN
          EELEC=E(NP)
          IF ((EELEC.GT.ECUT(IR(NP)))) THEN
            BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC
            GAMMA=EELEC/RM
            ALPHA=0.5*GAMMA-0.5+1./GAMMA
            RATIO=BETA/ALPHA
12591       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              RNPHT = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              RNPHT=2.*RNPHT-1.
              IF ((RATIO.LE.0.2)) THEN
                FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT)
                IF (( gamma .LT. 100 )) THEN
                  COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                ELSE
                  IF (( fkappa .GT. 0 )) THEN
                    costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gam
     *              ma-1)**3)
                  ELSE
                    COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                  END IF
                END IF
                xi = (1+beta*fkappa)*gamma*gamma
              ELSE
                XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO)
     *          )-1.))
                COSTHE=(1.-1./XI)/BETA
              END IF
              SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE))
              IF((rng_seed .GT. 128))call ranmar_get
              RNPHT2 = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF(RNPHT2.LE.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA)GO TO12592
            GO TO 12591
12592       CONTINUE
            SINTHE=SQRT(SINTH2)
            CALL UPHI(2,1)
          END IF
        END IF
      END IF
      IF (( do_relax )) THEN
        call egs_eadl_relax(iZ,k)
      END IF
      IF (( EDEP .GT. 0 )) THEN
        IARG=4
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,12600)prob_RR
12600       FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold
12611     CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF((rng_seed .GT. 128))call ranmar_get
              rnno_RR = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO12612
          GO TO 12611
12612     CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
      end
      subroutine egs_read_shellwise_pe
      implicit none
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(3), GE0(3),GE1(3), GMFP0(2000,3),GMFP1(2000,
     *3),GBR10(2000,3),GBR11(2000,3),GBR20(2000,3),GBR21(2000,3), RCO0(3
     *),RCO1(3), RSCT0(100,3),RSCT1(100,3), COHE0(2000,3),COHE1(2000,3),
     *  PHOTONUC0(2000,3),PHOTONUC1(2000,3), DPMFP, MPGEM(1,3), NGR(3)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,3),   pe_energy(500,100),  pe_zsorted(100,3), pe_be(100,16),
     * pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      real*8 pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      integer*4 lnblnk1,egs_get_unit,pe_sw_unit,ounit,egs_open_file
      integer*4 sorted(100),i,j,k,l,m
      real*8 z_sorted(100),pz_sorted(100)
      real*8 rest_xs(500,100)
      real*8 tmp_e(500,16), tmp_xs(500,16)
      real*8 new_e(500),deltaEb,slope
      integer*4 zread(100),ib(16),ibsearch
      character data_dir*128,pe_sw_file*144
      integer*4 medio,iZ,iZpos,egs_read_int,pos,curr_rec
      real*4 egs_read_real,e_r, e_old,sigma_r
      integer*2 nz, egs_read_short,ish, i_nshell,i_nge
      logical is_open, is_there, shift_required
      character*3 labels(16)
      data labels/'  K',' L1',' L2',' L3', ' M1',' M2',' M3',' M4',' M5'
     *, ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/
      write(6,'(/a$)') ' Reading renormalized photoelectric cross sectio
     *ns ......'
      write(1,'(/a$)') ' Reading renormalized photoelectric cross sectio
     *ns ......'
      data_dir = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      pe_sw_file = data_dir(:lnblnk1(data_dir)) // 'photo_shellwise.data
     *'
      pe_sw_unit = egs_get_unit(0)
      IF (( pe_sw_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_shellwise_pe: failed to get a free Fort
     *ran I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(pe_sw_unit,file=pe_sw_file,status='old', form='UNFORMATTED',A
     *CCESS='direct',recl=1, err=12620)
      GOTO 12630
12620 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(2a)') 'egs_init_shellwise_pe: failed to open ', pe_s
     *w_file
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
12630 is_open = .true.
      DO 12641 medio=1,nmed
        DO 12651 i=1,nne(medio)
          pe_nshell(i*medio) = 0
          pe_nge(i*medio) = 0
          pe_zsorted(i,medio) = 0
12651   CONTINUE
12652   CONTINUE
12641 CONTINUE
12642 CONTINUE
      DO 12661 l=1,100
        pe_zpos(l) = -1
        DO 12671 k=1,500
          pe_energy(k,l) = 0.0
          DO 12681 m=1,16
            pe_xsection(k,l,m) = 0.0
12681     CONTINUE
12682     CONTINUE
12671   CONTINUE
12672   CONTINUE
        DO 12691 k=1,16
          pe_be(l,k) = -99
12691   CONTINUE
12692   CONTINUE
12661 CONTINUE
12662 CONTINUE
      curr_rec = 1
      iZpos = 0
      nz = egs_read_short(pe_sw_unit,curr_rec)
      DO 12701 medio=1,nmed
        DO 12711 i=1,nne(medio)
          z_sorted(i) = zelem(medio,i)
12711   CONTINUE
12712   CONTINUE
        call egs_heap_sort(nne(medio),z_sorted,sorted)
        DO 12721 i=1,nne(medio)
          pe_zsorted(i,medio) = z_sorted(i)
12721   CONTINUE
12722   CONTINUE
        DO 12731 i=1,nne(medio)
          iZ = z_sorted(i)
          is_there = .false.
          DO 12741 j=1,medio-1
            DO 12751 k=1,nne(j)
              IF (( iZ .EQ. pe_zsorted(k,j) )) THEN
                is_there = .true.
                GO TO12752
              END IF
12751       CONTINUE
12752       CONTINUE
12741     CONTINUE
12742     CONTINUE
          IF((is_there))GO TO12731
          iZpos = iZpos + 1
          zread(iZpos) = iZ
          pe_zpos(iZ) = iZpos
          pos = 3 + (iZ-1)*4
          curr_rec = egs_read_int(pe_sw_unit,pos) + 1
          i_nge = egs_read_short(pe_sw_unit,curr_rec)
          i_nshell = egs_read_short(pe_sw_unit,curr_rec)
          pe_nge(iZpos) = i_nge
          pe_nshell(iZpos) = i_nshell
          e_old = -1.0
          ish = 0
          DO 12761 j=1,i_nge
            e_r = egs_read_real(pe_sw_unit,curr_rec)
            sigma_r = egs_read_real(pe_sw_unit,curr_rec)
            pe_energy(j,iZpos) = e_r
            pe_xsection(j,iZpos,0) = sigma_r
            rest_xs(j,iZpos) = sigma_r
            DO 12771 k=1,i_nshell
              sigma_r = egs_read_real(pe_sw_unit,curr_rec)
              pe_xsection(j,iZpos,k) = sigma_r
              rest_xs(j,iZpos) = rest_xs(j,iZpos) - sigma_r
12771       CONTINUE
12772       CONTINUE
            IF ((e_r - e_old .LT. 1e-15)) THEN
              pe_be(iZpos,i_nshell-ish) = e_r
              ish = ish + 1
            END IF
            e_old = e_r
12761     CONTINUE
12762     CONTINUE
12731   CONTINUE
12732   CONTINUE
12701 CONTINUE
12702 CONTINUE
      pe_ne = iZpos
      DO 12781 i=1,pe_ne
        iZ = zread(i)
        IF ((pe_nshell(i) .EQ. 0)) THEN
          DO 12791 j=1,pe_nge(i)
            pe_energy(j,i) = log(pe_energy(j,i))
12791     CONTINUE
12792     CONTINUE
          GO TO12781
        END IF
        DO 12801 l=1,pe_nshell(i)
          IF (( pe_be(i,l) .NE. binding_energies(l,iZ))) THEN
            shift_required = .true.
            deltaEb = binding_energies(l,iZ)-pe_be(i,l)
          ELSE
            shift_required =.false.
          END IF
          is_there = .false.
          DO 12811 j=1,pe_nge(i)
            tmp_e(j,l) = pe_energy(j,i)
            tmp_xs(j,l) = pe_xsection(j,i,l)
            IF (( shift_required .AND. pe_energy(j,i) .GE. pe_be(i,l) ))
     *       THEN
              tmp_e(j,l) = tmp_e(j,l) + deltaEb
              IF ((pe_energy(j,i) .EQ. pe_be(i,l) .AND. .NOT.is_there))
     *        THEN
                ib(l) = j
                is_there = .true.
              END IF
              IF ((l .EQ. 1)) THEN
                new_e(j) = tmp_e(j,l)
              ELSE IF((j .LT. ib(l-1))) THEN
                new_e(j) = tmp_e(j,l)
              END IF
            END IF
12811     CONTINUE
12812     CONTINUE
          pe_be(i,l) = binding_energies(l,iZ)
12801   CONTINUE
12802   CONTINUE
        DO 12821 l=2,pe_nshell(i)
          DO 12831 j=1,pe_nge(i)
            IF (( new_e(j) .GE. pe_be(i,l-1) )) THEN
              m = ibsearch(new_e(j),pe_nge(i),tmp_e(1,l))
              slope = log(tmp_xs(m+1,l)/tmp_xs(m,l))
              slope = slope/log(tmp_e(m+1,l)/tmp_e(m,l))
              pe_xsection(j,i,l) = log(tmp_xs(m,l))
              pe_xsection(j,i,l) = pe_xsection(j,i,l) + slope*log(new_e(
     *        j)/tmp_e(m,l))
              pe_xsection(j,i,l) = exp(pe_xsection(j,i,l))
            END IF
12831     CONTINUE
12832     CONTINUE
12821   CONTINUE
12822   CONTINUE
        DO 12841 j=1,pe_nge(i)
          IF (( j .LT. ib(pe_nshell(i)))) THEN
            new_e(j) = pe_energy(j,i)
          END IF
          m = ibsearch(new_e(j),pe_nge(i),pe_energy(1,i))
          slope = log(rest_xs(m+1,i)/rest_xs(m,i))
          slope = slope/log(pe_energy(m+1,i)/pe_energy(m,i))
          pe_xsection(j,i,0) = log(rest_xs(m,i))
          pe_xsection(j,i,0) = pe_xsection(j,i,0) + slope*log(new_e(j)/p
     *    e_energy(m,i))
          pe_xsection(j,i,0) = exp(pe_xsection(j,i,0))
          DO 12851 l=1,pe_nshell(i)
            pe_xsection(j,i,0) = pe_xsection(j,i,0) + pe_xsection(j,i,l)
12851     CONTINUE
12852     CONTINUE
12841   CONTINUE
12842   CONTINUE
        DO 12861 j=1,pe_nge(i)
          pe_energy(j,i) = log(new_e(j))
          DO 12871 l=1,pe_nshell(i)
            pe_xsection(j,i,l) = log(pe_xsection(j,i,l)/pe_xsection(j,i,
     *      0))
12871     CONTINUE
12872     CONTINUE
12861   CONTINUE
12862   CONTINUE
12781 CONTINUE
12782 CONTINUE
      write(6,'(a/)') ' done'
      write(1,'(a/)') ' done'
      IF((is_open))close(pe_sw_unit)
      return
      end
      SUBROUTINE RELAX(energy,n,iZ)
      implicit none
      integer*4 n,iZ
      real*8 energy
      integer*4 vac_array(50),  n_vac,  shell
      integer*4 final,finala,  final1,final2,   iql,  irl
      integer*4 first_transition(5), last_transition(5)
      integer*4 final_state(39)
      integer*4 k, np_old, ip, iarg
      real*8 e_array(50),  Ei,Ef,  Ex,  eta,  e_check,  min_E,ekcut,pkcu
     *t,elcut
      real*8 xphi,yphi,xphi2,yphi2,rhophi2, cphi,sphi
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/BOUNDS/ECUT( 1001),PCUT( 1001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common/user_relax/ u_relax,ish_relax,iZ_relax
      real*8 u_relax
      integer*4 ish_relax, iZ_relax
      data first_transition/1,20,27,33,38/
      data last_transition/19,26,32,37,39/
      data final_state/  4,3,5,6,  202,302,402,404,403,303,  502,503,504
     *,602,603,604,  505,605,606,  13,14,  5,6,  505,605,606,  14,  5,6,
     *  505,605,606,  5,6,  505,605,606,  6,  606/
      save first_transition,last_transition,final_state
      IF ((eadl_relax)) THEN
        call egs_eadl_relax(iZ,n)
        return
      END IF
      IF (( n .LT. 1 .OR. n .GT. 6 )) THEN
        return
      END IF
      iz_relax = iZ
      irl = ir(np)
      ekcut = ecut(irl)-rm
      pkcut = pcut(irl)
      min_E = 0.001
      IF (( energy .LE. min_E )) THEN
        edep = edep + energy
        edep_local = energy
        IARG=34
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
        return
      END IF
      n_vac = 1
      vac_array(n_vac) = n
      np_old = np
      e_check = 0
      e_array(n_vac) = energy
12880 CONTINUE
12881   CONTINUE
        shell = vac_array(n_vac)
        Ei = e_array(n_vac)
        n_vac = n_vac - 1
        IF (( Ei .LE. min_E )) THEN
          edep = edep + Ei
          edep_local = Ei
          IARG=34
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          IF((n_vac .GT. 0))goto 12880
          GO TO12882
        END IF
        ish_relax = shell
        u_relax = Ei
        IF (( shell .EQ. 6 )) THEN
          IF (( Ei .GT. ekcut )) THEN
            np = np + 1
            IF (( np .GT. 40 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','RELAX'
     *        , ' stack size exceeded! ',' $MAXSTACK = ',40,' np = ',np
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            e(np) = Ei + prm
            iq(np) = -1
            X(np)=X(np-1)
            Y(np)=Y(np-1)
            Z(np)=Z(np-1)
            IR(np)=IR(np-1)
            WT(np)=WT(np-1)
            DNEAR(np)=DNEAR(np-1)
            LATCH(np)=LATCH(np-1)
            IF((rng_seed .GT. 128))call ranmar_get
            eta = rng_array(rng_seed)*twom24
            rng_seed = rng_seed + 1
            eta = 2*eta - 1
            w(np) = eta
            eta = (1-eta)*(1+eta)
            IF (( eta .GT. 1e-20 )) THEN
              eta = Sqrt(eta)
12891         CONTINUE
                IF((rng_seed .GT. 128))call ranmar_get
                xphi = rng_array(rng_seed)*twom24
                rng_seed = rng_seed + 1
                xphi = 2*xphi - 1
                xphi2 = xphi*xphi
                IF((rng_seed .GT. 128))call ranmar_get
                yphi = rng_array(rng_seed)*twom24
                rng_seed = rng_seed + 1
                yphi2 = yphi*yphi
                rhophi2 = xphi2 + yphi2
                IF(rhophi2.LE.1)GO TO12892
              GO TO 12891
12892         CONTINUE
              rhophi2 = 1/rhophi2
              cphi = (xphi2 - yphi2)*rhophi2
              sphi = 2*xphi*yphi*rhophi2
              u(np) = eta*cphi
              v(np) = eta*sphi
            ELSE
              u(np) = 0
              v(np) = 0
              w(np) = 1
            END IF
            IARG=27
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE
            edep = edep + Ei
            edep_local = Ei
            IARG=34
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          END IF
          IF((n_vac .GT. 0))goto 12880
          GO TO12882
        END IF
        IF((rng_seed .GT. 128))call ranmar_get
        eta = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        DO 12901 k=first_transition(shell),last_transition(shell)-1
          eta = eta - relaxation_prob(k,iZ)
          IF((eta .LE. 0))GO TO12902
12901   CONTINUE
12902   CONTINUE
        final = final_state(k)
        finala = final
        IF (( final .LT. 100 )) THEN
          IF (( final .LT. 10 )) THEN
            iql = 0
            elcut = pkcut
          ELSE
            final = final - 10
            iql = -1
            elcut = ekcut
          END IF
          Ef = binding_energies(final,iZ)
          Ex = Ei - Ef
          n_vac = n_vac + 1
          vac_array(n_vac) = final
          e_array(n_vac) = Ef
        ELSE
          final1 = final/100
          final2 = final - final1*100
          n_vac = n_vac + 1
          vac_array(n_vac) = final1
          e_array(n_vac) = binding_energies(final1,iZ)
          n_vac = n_vac + 1
          vac_array(n_vac) = final2
          e_array(n_vac) = binding_energies(final2,iZ)
          iql = -1
          Ex = Ei - e_array(n_vac) - e_array(n_vac-1)
          elcut = ekcut
        END IF
        IF (( Ex .LE. elcut )) THEN
          edep = edep + Ex
          IF (( finala .LT. 10 )) THEN
            edep_local = Ex
            IARG=33
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE
            edep_local = Ex
            IARG=34
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          END IF
        ELSE
          np = np + 1
          IF (( np .GT. 40 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','RELAX',
     *      ' stack size exceeded! ',' $MAXSTACK = ',40,' np = ',np
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          iq(np) = iql
          IF (( iql .EQ. 0 )) THEN
            e(np) = Ex
          ELSE
            e(np) = Ex + rm
          END IF
          X(np)=X(np-1)
          Y(np)=Y(np-1)
          Z(np)=Z(np-1)
          IR(np)=IR(np-1)
          WT(np)=WT(np-1)
          DNEAR(np)=DNEAR(np-1)
          LATCH(np)=LATCH(np-1)
          IF((rng_seed .GT. 128))call ranmar_get
          eta = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          eta = 2*eta - 1
          w(np) = eta
          eta = (1-eta)*(1+eta)
          IF (( eta .GT. 1e-20 )) THEN
            eta = Sqrt(eta)
12911       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              xphi = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              xphi = 2*xphi - 1
              xphi2 = xphi*xphi
              IF((rng_seed .GT. 128))call ranmar_get
              yphi = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              yphi2 = yphi*yphi
              rhophi2 = xphi2 + yphi2
              IF(rhophi2.LE.1)GO TO12912
            GO TO 12911
12912       CONTINUE
            rhophi2 = 1/rhophi2
            cphi = (xphi2 - yphi2)*rhophi2
            sphi = 2*xphi*yphi*rhophi2
            u(np) = eta*cphi
            v(np) = eta*sphi
          ELSE
            u(np) = 0
            v(np) = 0
            w(np) = 1
          END IF
          IF (( finala .LT. 10 )) THEN
            IARG=25
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE IF(( finala .LT. 100 )) THEN
            IARG=26
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE
            IARG=27
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          END IF
        END IF
      GO TO 12881
12882 CONTINUE
      return
      end
      subroutine egs_init_relax
      implicit none
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(3), GE0(3),GE1(3), GMFP0(2000,3),GMFP1(2000,
     *3),GBR10(2000,3),GBR11(2000,3),GBR20(2000,3),GBR21(2000,3), RCO0(3
     *),RCO1(3), RSCT0(100,3),RSCT1(100,3), COHE0(2000,3),COHE1(2000,3),
     *  PHOTONUC0(2000,3),PHOTONUC1(2000,3), DPMFP, MPGEM(1,3), NGR(3)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/shell_data/ shell_be(3000),  shell_type(3000),  shell_num(3
     *000),  shell_Z(3000),  shell_eadl(100,30),  shell_ntot
      real*8 shell_be
      integer*4 shell_type,shell_Z,shell_ntot,shell_num,shell_eadl
      integer*4 lnblnk1,egs_get_unit,relax_unit,ounit,egs_open_file
      integer*4 sorted(100),i,j,k,k1,k2,m
      real*8 z_sorted(100),pz_sorted(100)
      character data_dir*128,relax_file*144
      integer*4 ish,medio,iZ,ntran
      real*8 Ec, Pc, tmp, min_be, sumw,Ex
      logical is_open, is_there
      real*8 wtmp(300)
      integer*4 itmp(300)
      integer*4 pos, curr_rec, sh_eadl
      integer*4 nz, nshell, tr_type
      integer*4 ttype
      real*4 be_r, prob_r
      DO 12921 iZ=1,100
        DO 12931 k=1,30
          shell_eadl(iZ,k) = -1
12931   CONTINUE
12932   CONTINUE
12921 CONTINUE
12922 CONTINUE
      min_be = 0.001
      write(6,'(/a)') ' Reading EADL relaxation data ......'
      write(1,'(/a)') ' Reading EADL relaxation data ......'
      data_dir = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      relax_file = data_dir(:lnblnk1(data_dir)) // 'relax.data'
      relax_unit = egs_get_unit(0)
      IF (( relax_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_relax: failed to get a free Fortran I/O
     * unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(relax_unit,file=relax_file,status='old', form='UNFORMATTED',A
     *CCESS='direct',recl=4, err=12940)
      GOTO 12950
12940 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(2a)') 'egs_init_relax: failed to open ', relax_file
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
12950 is_open = .true.
      curr_rec = 1
      read(relax_unit,rec=curr_rec) nz
      shell_ntot = 0
      relax_ntot = 0
      DO 12961 medio=1,nmed
        DO 12971 i=1,nne(medio)
          z_sorted(i) = zelem(medio,i)
12971   CONTINUE
12972   CONTINUE
        call egs_heap_sort(nne(medio),z_sorted,sorted)
        DO 12981 i=1,nne(medio)
          iZ = z_sorted(i)
          is_there = .false.
          DO 12991 j=1,shell_ntot
            IF (( iZ .EQ. shell_Z(j) )) THEN
              is_there = .true.
              GO TO12992
            END IF
12991     CONTINUE
12992     CONTINUE
          IF((is_there))GO TO12981
          pos = iZ + 1
          read(relax_unit,rec=pos) curr_rec
          read(relax_unit,rec=curr_rec) nshell
          IF (( shell_ntot + nshell .GT. 3000 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a,i5,a/,a//)') ' Too many shells to fit in the
     * list: ', shell_ntot + nshell,' (at least).', ' Increase the param
     *eter $MAXSHELL and retry '
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          write(6,'(a,i3,a,i2,a)') '  Z = ',iZ,' has ',nshell,' shells'
          write(1,'(a,i3,a,i2,a)') '  Z = ',iZ,' has ',nshell,' shells'
          DO 13001 ish=shell_ntot+1,shell_ntot+nshell
            curr_rec = curr_rec+1
            read(relax_unit,rec=curr_rec) shell_type(ish)
            curr_rec = curr_rec+1
            read(relax_unit,rec=curr_rec) ntran
            curr_rec = curr_rec+1
            read(relax_unit,rec=curr_rec) be_r
            shell_be(ish) = be_r
            shell_Z(ish) = iZ
            shell_num(ish) = ish - shell_ntot
            shell_eadl(iZ,shell_num(ish)) = ish
            IF ((binding_energies(shell_num(ish),iZ) .GT. 0)) THEN
              shell_be(ish) = binding_energies(shell_num(ish),iZ)
            ELSE IF(( photon_xsections .EQ. 'epdl' )) THEN
              binding_energies(shell_num(ish),iZ) = shell_be(ish)
            END IF
            DO 13011 k=1,ntran
              curr_rec = curr_rec+1
              read(relax_unit,rec=curr_rec) itmp(k)
              curr_rec = curr_rec+1
              read(relax_unit,rec=curr_rec) prob_r
              wtmp(k)=prob_r
              IF ((itmp(k).LT.64)) THEN
                itmp(k) = itmp(k) + 1
              ELSE
                itmp(k) = itmp(k) + 65
              END IF
13011       CONTINUE
13012       CONTINUE
            IF (( shell_be(ish) .LT. min_be )) THEN
              relax_first(ish) = -1
              relax_ntran(ish) = -1
            ELSE
              sumw = 0
              DO 13021 k=1,ntran
                sumw = sumw + wtmp(k)
13021         CONTINUE
13022         CONTINUE
              IF (( sumw .GT. 1 )) THEN
                DO 13031 k=1,ntran
                  wtmp(k) = wtmp(k)/sumw
13031           CONTINUE
13032           CONTINUE
              ELSE IF(( sumw .LT. 1 )) THEN
                ntran = ntran + 1
                itmp(ntran) = -1
                wtmp(ntran) = 1-sumw
              END IF
              IF (( relax_ntot + ntran .GT. 10000 )) THEN
                write(i_log,'(/a)') '***************** Error: '
                write(i_log,'(a,i5,a/,a/)') ' Too many relaxation transi
     *tions: ', relax_ntot + ntran,' (at least).', ' Increase $MAXRELAX
     *and retry '
                write(i_log,'(/a)') '***************** Quiting now.'
                call exit(1)
              END IF
              relax_first(ish) = relax_ntot+1
              relax_ntran(ish) = ntran
              call prepare_alias_histogram(ntran,wtmp, relax_atbin(relax
     *        _ntot+1))
              DO 13041 k=1,ntran
                j = relax_ntot + k
                relax_state(j) = itmp(k)
                relax_prob(j) = wtmp(k)
13041         CONTINUE
13042         CONTINUE
              relax_ntot = relax_ntot + ntran
            END IF
13001     CONTINUE
13002     CONTINUE
          shell_ntot = shell_ntot + nshell
12981   CONTINUE
12982   CONTINUE
12961 CONTINUE
12962 CONTINUE
      write(6,'(a/)') ' ...... Done.'
      write(1,'(a/)') ' ...... Done.'
      IF((is_open))close(relax_unit)
      return
      stop
      end
      subroutine egs_eadl_relax(iZ, shell_egs)
      implicit none
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/relax_for_user/ rfu_E0,  rfu_E,  rfu_Z,  rfu_j0,  rfu_n0,
     *rfu_t0,  rfu_j,  rfu_n,  rfu_t
      integer*4 rfu_Z,rfu_j0,rfu_n0,rfu_t0,rfu_j,rfu_n,rfu_t
      real*8 rfu_E0,rfu_E
      common/shell_data/ shell_be(3000),  shell_type(3000),  shell_num(3
     *000),  shell_Z(3000),  shell_eadl(100,30),  shell_ntot
      real*8 shell_be
      integer*4 shell_type,shell_Z,shell_ntot,shell_num,shell_eadl
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/BOUNDS/ECUT( 1001),PCUT( 1001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common/user_relax/ u_relax,ish_relax,iZ_relax
      real*8 u_relax
      integer*4 ish_relax, iZ_relax
      real*8 Ec,Pc,min_E,rnno,Evac,Ef,Ef1,Ef2,Ex,Ecc, cost,sint,cphi,sph
     *i
      integer*4 shell, shell_egs, iZ, iarg
      integer*4 irl,vacs(100),nvac,vac,new_state,iqf,np_save,new1,new2
      integer*4 sample_alias_histogram
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      shell = shell_eadl(iZ,shell_egs)
      IF (( shell .LT. 1 .OR. shell .GT. 3000 )) THEN
        return
      END IF
      irl = ir(np)
      Ec = ecut(irl) - rm
      Pc = pcut(irl)
      min_E = 0.001
      Evac = shell_be(shell)
      rfu_Z = shell_Z(shell)
      rfu_j0 = shell
      rfu_n0 = shell_num(shell)
      rfu_t0 = shell_type(shell)
      rfu_E0 = Evac
      IF ((shell_egs .GT. 4 .AND. .NOT.mcdf_pe_xsections)) THEN
        edep = Evac
        edep_local = Evac
        IARG=34
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
        return
      END IF
      vac = shell
      Nvac = 0
      np_save = np
13051 CONTINUE
        IF (( Evac .LT. min_E .OR. relax_ntran(vac) .LT. 1 )) THEN
          edep = edep + Evac
          edep_local = Evac
          IARG=34
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          go to 13060
        END IF
        new_state = sample_alias_histogram(relax_ntran(vac), relax_prob(
     *  relax_first(vac)), relax_atbin(relax_first(vac)))
        IF (( new_state .LT. 0 )) THEN
          Ef = 0
          iqf = -1
          Ecc = Ec
        ELSE
          new_state = relax_state(relax_first(vac)+new_state-1)
          IF (( new_state .LE. 64 )) THEN
            iqf = 0
            new_state = new_state + vac - shell_num(vac)
            Ef = shell_be(new_state)
            Nvac = Nvac + 1
            vacs(Nvac) = new_state
            Ecc = Pc
          ELSE
            iqf = -1
            new1 = new_state/64
            new2 = new_state - 64*new1
            new1 = new1 + vac - shell_num(vac)
            new2 = new2 + vac - shell_num(vac)
            Ef1 = shell_be(new1)
            Ef2 = shell_be(new2)
            Nvac = Nvac + 1
            vacs(Nvac) = new1
            Nvac = Nvac + 1
            vacs(Nvac) = new2
            Ef = Ef1 + Ef2
            Ecc = Ec
          END IF
        END IF
        Ex = Evac - Ef
        edep_local = 0
        IF (( Ex .GT. Ecc )) THEN
          np = np + 1
          IF (( np .GT. 40 )) THEN
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,'(3(a,f10.6),a,i2)') 'Evac = ',Evac, ' Ef = ',Ef
     *      ,  ' min_E = ', min_E,' iq = ',iqf
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(//,3a,/,2(a,i9),/,a)') ' In subroutine ','new_
     *relax', ' stack size exceeded! ',' $MXSTACK = ',40,' np = ',np, '
     *Increase $MXSTACK and try again '
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          iq(np) = iqf
          X(np)=X(np_save)
          Y(np)=Y(np_save)
          Z(np)=Z(np_save)
          IR(np)=IR(np_save)
          WT(np)=WT(np_save)
          DNEAR(np)=DNEAR(np_save)
          LATCH(np)=LATCH(np_save)
          IF((rng_seed .GT. 128))call ranmar_get
          rnno = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          cost = 2*rnno-1
          sint = 1-cost*cost
          IF (( sint .GT. 0 )) THEN
            sint = sqrt(sint)
13071       CONTINUE
              IF((rng_seed .GT. 128))call ranmar_get
              xphi = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              xphi = 2*xphi - 1
              xphi2 = xphi*xphi
              IF((rng_seed .GT. 128))call ranmar_get
              yphi = rng_array(rng_seed)*twom24
              rng_seed = rng_seed + 1
              yphi2 = yphi*yphi
              rhophi2 = xphi2 + yphi2
              IF(rhophi2.LE.1)GO TO13072
            GO TO 13071
13072       CONTINUE
            rhophi2 = 1/rhophi2
            cphi = (xphi2 - yphi2)*rhophi2
            sphi = 2*xphi*yphi*rhophi2
            u(np) = sint*cphi
            v(np) = sint*sphi
            w(np) = cost
          ELSE
            u(np) = 0
            v(np) = 0
            w(np) = cost
          END IF
          rfu_j = vac
          rfu_n = shell_num(vac)
          rfu_t = shell_type(vac)
          rfu_E = shell_be(vac)
          IF (( iqf .EQ. 0 )) THEN
            e(np) = Ex
            IARG=25
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE
            e(np) = Ex + rm
            IARG=27
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          END IF
        ELSE
          edep = edep + Ex
          IF (( iqf .EQ. 0 )) THEN
            edep_local = Ex
            IARG=33
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          ELSE
            edep_local = Ex
            IARG=34
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
          END IF
        END IF
13060   CONTINUE
        IF((Nvac .EQ. 0))GO TO13052
        vac = vacs(Nvac)
        Evac = shell_be(vac)
        Nvac = Nvac - 1
      GO TO 13051
13052 CONTINUE
      return
      end
      subroutine init_triplet
      implicit none
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/triplet_data/ a_triplet(250,3), b_triplet(250,3), dl_triple
     *t, dli_triplet, bli_triplet, log_4rm
      real*8 a_triplet,b_triplet,dl_triplet, dli_triplet, bli_triplet, l
     *og_4rm
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      real*8 energies(55), sig_pair(100,55), sig_triplet(100,55), f_trip
     *let(55), sigp(55), sigt(55), as(55), bs(55), cs(55), ds(55)
      character*128 triplet_data_file
      integer*4 want_triplet_unit, triplet_unit, triplet_out
      integer*4 i, iel, imed, lnblnk1, egs_get_unit, ntrip, iz1, izi, if
     *irst
      real*8 logE, f_new, f_old, spline
      IF((itriplet .EQ. 0))return
      DO 13081 i=1,len(triplet_data_file)
        triplet_data_file(i:i) = ' '
13081 CONTINUE
13082 CONTINUE
      triplet_data_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/
     *' // 'triplet.data'
      want_triplet_unit = 63
      triplet_unit = egs_get_unit(want_triplet_unit)
      IF (( triplet_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'init_triplet: failed to get a free Fortran I/O u
     *nit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(triplet_unit,file=triplet_data_file,err=13090)
      write(6,'(a,$)') ' init_triplet: reading triplet data ... '
      write(1,'(a,$)') ' init_triplet: reading triplet data ... '
      read(triplet_unit,*) ntrip
      IF (( ntrip .GT. 55 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Max. number of data points per element is ',55
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      read(triplet_unit,*,err=13100) (energies(i),i=1,ntrip)
      DO 13111 iel=1,100
        read(triplet_unit,*)
        read(triplet_unit,*,err=13100) (sig_pair(iel,i),i=1,ntrip)
        read(triplet_unit,*,err=13100) (sig_triplet(iel,i),i=1,ntrip)
13111 CONTINUE
13112 CONTINUE
      write(6,*) 'OK'
      write(1,*) 'OK'
      ifirst = 0
      DO 13121 i=1,ntrip
        IF((ifirst .EQ. 0 .AND. energies(i) .GT. 4.01*rm))ifirst = i
        energies(i) = log(energies(i))
13121 CONTINUE
13122 CONTINUE
      log_4rm = log(4*rm)
      energies(ifirst-1) = log_4rm
      dl_triplet = (energies(ntrip) - log_4rm)/250
      dli_triplet = 1/dl_triplet
      bli_triplet = 1 - log_4rm/dl_triplet
      DO 13131 imed=1,nmed
        write(6,'(a,i3,a,$)') '   Preparing triplet fraction data for me
     *dium ',imed,' ... '
        write(1,'(a,i3,a,$)') '   Preparing triplet fraction data for me
     *dium ',imed,' ... '
        iz1 = zelem(imed,1) + 0.1
        DO 13141 i=1,ntrip
          sigp(i) = pz(imed,1)*sig_pair(iz1,i)
          sigt(i) = pz(imed,1)*sig_triplet(iz1,i)
          DO 13151 iel=2,nne(imed)
            izi = zelem(imed,iel) + 0.1
            sigp(i) = sigp(i) + pz(imed,iel)*sig_pair(izi,i)
            sigt(i) = sigt(i) + pz(imed,iel)*sig_triplet(izi,i)
13151     CONTINUE
13152     CONTINUE
13141   CONTINUE
13142   CONTINUE
        DO 13161 i=ifirst,ntrip
          f_triplet(i-ifirst+2) = sigt(i)/(sigp(i) + sigt(i))
13161   CONTINUE
13162   CONTINUE
        f_triplet(1) = 0
        call set_spline(energies(ifirst-1),f_triplet,as,bs,cs,ds,ntrip-i
     *  first+2)
        logE = log_4rm
        f_old = 0
        DO 13171 i=1,250-1
          logE = logE + dl_triplet
          f_new = spline(logE,energies(ifirst-1),as,bs,cs,ds,ntrip-ifirs
     *    t+2)
          a_triplet(i,imed) = (f_new - f_old)*dli_triplet
          b_triplet(i,imed) = f_new - a_triplet(i,imed)*logE
          f_old = f_new
13171   CONTINUE
13172   CONTINUE
        write(6,*) 'OK'
        write(1,*) 'OK'
13131 CONTINUE
13132 CONTINUE
      close(triplet_unit)
      return
13090 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,a)') ' init_triplet: failed to open the data file
     *', triplet_data_file(:lnblnk1(triplet_data_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
13100 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' init_triplet: error while reading triplet data '
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      SUBROUTINE EDGSET(NREGLO,NREGHI)
      implicit none
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer NREGLO,NREGHI
      integer*4 i,j,k,jj,iz
      logical do_relax
      logical got_data
      save got_data
      data got_data/.false./
      IF((got_data))return
      write(6,'(a/,a)') 'Output from subroutine EDGSET:', '=============
     *================='
      write(1,'(a/,a)') 'Output from subroutine EDGSET:', '=============
     *================='
      do_relax = .false.
      DO 13181 j=1, 1001
        IF (( iedgfl(j) .GT. 0 .AND. iedgfl(j) .LE. 100 )) THEN
          do_relax = .true.
          GO TO13182
        END IF
13181 CONTINUE
13182 CONTINUE
      IF (( .NOT.do_relax )) THEN
        IF ((eadl_relax)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,/a)') 'You must turn ON atomic relaxations whe
     *n requesting', 'detailed atomic relaxation (eadl_relax=true)!'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        write(6,'(a/)') ' Atomic relaxations not requested! '
        write(1,'(a/)') ' Atomic relaxations not requested! '
        return
      END IF
      write(6,'(a/)') ' Atomic relaxations requested! '
      write(1,'(a/)') ' Atomic relaxations requested! '
      write(6,'(a$)') ' Reading simplified photo-absorption data .....'
      write(1,'(a$)') ' Reading simplified photo-absorption data .....'
      got_data = .true.
      rewind(i_photo_relax)
      DO 13191 i=1,100
        IF ((eadl_relax)) THEN
          read(i_photo_relax,*)
        ELSE
          read(i_photo_relax,*) j,(binding_energies(k,i),k=1,6)
          DO 13201 k=1,6
            binding_energies(k,i) = binding_energies(k,i)*1e-6
13201     CONTINUE
13202     CONTINUE
        END IF
13191 CONTINUE
13192 CONTINUE
      read(i_photo_relax,*)
      DO 13211 i=1,100
        read(i_photo_relax,*) j,(interaction_prob(k,i),k=1,5)
        interaction_prob(6,i)=1.01
13211 CONTINUE
13212 CONTINUE
      write(6,'(a)') ' Done'
      write(1,'(a)') ' Done'
      write(6,'(/a$)') ' Reading simplified relaxation data .....'
      write(1,'(/a$)') ' Reading simplified relaxation data .....'
      read(i_photo_relax,*)
      DO 13221 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=1,19)
13221 CONTINUE
13222 CONTINUE
      read(i_photo_relax,*)
      DO 13231 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=20,26)
13231 CONTINUE
13232 CONTINUE
      read(i_photo_relax,*)
      DO 13241 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=27,32)
13241 CONTINUE
13242 CONTINUE
      read(i_photo_relax,*)
      DO 13251 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=33,37)
13251 CONTINUE
13252 CONTINUE
      read(i_photo_relax,*)
      DO 13261 i=1,100
        read(i_photo_relax,*) j,relaxation_prob(38,i)
13261 CONTINUE
13262 CONTINUE
      write(6,'(a)') ' Done'
      write(1,'(a)') ' Done'
      write(6,'(/a$)') ' Reading parametrized XCOM photo cross section d
     *ata .....'
      write(1,'(/a$)') ' Reading parametrized XCOM photo cross section d
     *ata .....'
      rewind(i_photo_cs)
      DO 13271 i=1,100
        read(i_photo_cs,*) j,edge_number(i)
        DO 13281 j=1,edge_number(i)
          read(i_photo_cs,*) edge_a(j,i),edge_b(j,i),edge_c(j,i), edge_d
     *    (j,i),edge_energies(j,i)
13281   CONTINUE
13282   CONTINUE
13271 CONTINUE
13272 CONTINUE
      write(6,'(a)') ' Done'
      write(1,'(a)') ' Done'
      IF ((eadl_relax)) THEN
        call egs_init_relax
      END IF
      RETURN
      END
      SUBROUTINE PHOTON(IRCODE)
      implicit none
      integer*4 IRCODE
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/BOUNDS/ECUT( 1001),PCUT( 1001),VACDST
      real*8 ECUT,  PCUT,  VACDST
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/PHOTIN/ EBINDA(3), GE0(3),GE1(3), GMFP0(2000,3),GMFP1(2000,
     *3),GBR10(2000,3),GBR11(2000,3),GBR20(2000,3),GBR21(2000,3), RCO0(3
     *),RCO1(3), RSCT0(100,3),RSCT1(100,3), COHE0(2000,3),COHE1(2000,3),
     *  PHOTONUC0(2000,3),PHOTONUC1(2000,3), DPMFP, MPGEM(1,3), NGR(3)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/USERVR/ CEXPTR,GWAIT,PATHL,DUMU,DUMX,DUMY,DUMZ, DELTAP,GWTO
     *LD,EPSLON,ARG,EXPMFP,ESAVEIN, IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM, IFO
     *RCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN, MEDTMP,IREJCT
      real*8 CEXPTR,GWAIT,DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,GWTOLD,EPSLON
     *,ARG, EXPMFP,ESAVEIN
      integer*4 NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN,IFORCE,IRODU
     *M, IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,IREJCT
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/GEOM/ ZPLANE( 101),RCYL(0:10),CYRAD2( 11), NZ,NR,NREG,NPLAN
     *E
      real*8 ZPLANE,RCYL,CYRAD2
      integer*4 NZ,NR,NREG,NPLANE
      DOUBLE PRECISION PEIG
      real*8 EIG,  RNNO35,  GMFPR0,  GMFP,  COHFAC,  RNNO37,  XXX,  X2,
     * Q2,  CSQTHE,  REJF,  RNNORJ,  RNNO36,  GBR1,  GBR2,  T,   PHOTONU
     *CFAC,  RNNO39
      integer*4 IARG,  IDR,  IRL,  LGLE,  LXXX
      IRCODE=1
      PEIG=E(NP)
      EIG=PEIG
      IRL=IR(NP)
      medium = med(irl)
      IF ((EIG .LE. PCUT(IRL))) THEN
        GO TO 13290
      END IF
13300 CONTINUE
13301   CONTINUE
        IF ((WT(NP) .EQ. 0.0)) THEN
          go to 13310
        END IF
        GLE=LOG(EIG)
        NFTIME=NFTIME+1
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO35 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (((IFORCE.EQ.0).OR.(NFTIME.GT.NFMAX).OR.(NFTIME.LT.NFMIN))) T
     *  HEN
          IF ((RNNO35 .EQ. 0.0)) THEN
            RNNO35=1.E-30
          END IF
          DPMFP=-LOG(RNNO35)
        ELSE
          IF(((IFPB.EQ.0).AND.(NFTIME.EQ.1).AND.(MONOEN.EQ.0).AND. (IQIN
     *    C.EQ.0)))GOTO 13320
          DUMU=USTEP
          DUMX=X(NP)
          DUMY=Y(NP)
          DUMZ=Z(NP)
          IRODUM=IROLD
          IRNDUM=IRNEW
          IRDUM=IR(NP)
          MEDDUM=MEDIUM
          IDUM=IDISC
          PATHL=0.0
          MEDTMP=0
13331     CONTINUE
            USTEP=VACDST
            IROLD=IR(NP)
            MEDIUM=MED(IROLD)
            IF ((MEDIUM.EQ.0)) THEN
              DELTAP=0.
            ELSE
              IF ((MEDTMP.NE.MEDIUM)) THEN
                MEDTMP=MEDIUM
                LGLE=GE1(MEDIUM)*GLE+GE0(MEDIUM)
                DELTAP=GMFP1(LGLE,MEDIUM)*GLE+GMFP0(LGLE,MEDIUM)
              END IF
              IF ((IRAYLR(IROLD) .EQ. 1)) THEN
                COHFAC=COHE1(LGLE,MEDIUM)*GLE+COHE0(LGLE,MEDIUM)
              ELSE
                COHFAC=1.0
              END IF
            END IF
            CALL HOWFAR
            IF((DELTAP.NE.0))PATHL=PATHL+USTEP/(DELTAP*COHFAC)
            IF((IRNEW .EQ. 1))GO TO13332
            IR(NP)=IRNEW
            X(NP)=X(NP)+USTEP*U(NP)
            Y(NP)=Y(NP)+USTEP*V(NP)
            Z(NP)=Z(NP)+USTEP*W(NP)
          GO TO 13331
13332     CONTINUE
          USTEP=DUMU
          X(NP)=DUMX
          Y(NP)=DUMY
          Z(NP)=DUMZ
          IROLD=IRODUM
          IRNEW=IRNDUM
          IR(NP)=IRDUM
          MEDIUM=MEDDUM
          IDISC=IDUM
          IF ((PATHL.LE.1.0E-3)) THEN
            GWAIT=PATHL*(1.-0.5*PATHL)
          ELSE
            GWAIT=1.-EXP(-PATHL)
          END IF
          GWTOLD=WT(NP)
          WT(NP)=GWTOLD*GWAIT
13320     CONTINUE
          EPSLON=RNNO35*GWAIT
          IF ((EPSLON.LE.1.0E-3)) THEN
            IF((NFTIME .EQ. 1))EXPMFP=EPSLON*(1.+EPSLON)
            DPMFP=EPSLON*(1.+0.5*EPSLON)
          ELSE
            ARG=1./(1.-EPSLON)
            DPMFP=LOG(ARG)
            IF((NFTIME .EQ. 1))EXPMFP=EPSLON*ARG
          END IF
        END IF
        IROLD=IR(NP)
13340   CONTINUE
13341     CONTINUE
          IF ((MEDIUM.NE.0)) THEN
            LGLE=GE1(MEDIUM)*GLE+GE0(MEDIUM)
            GMFPR0=GMFP1(LGLE,MEDIUM)*GLE+GMFP0(LGLE,MEDIUM)
          END IF
13350     CONTINUE
13351       CONTINUE
            IF ((MEDIUM.EQ.0)) THEN
              TSTEP=VACDST
            ELSE
              RHOF=RHOR(IRL)/RHO(MEDIUM)
              GMFP=GMFPR0/RHOF
              IF ((IRAYLR(IRL).EQ.1)) THEN
                COHFAC=COHE1(LGLE,MEDIUM)*GLE+COHE0(LGLE,MEDIUM)
                GMFP=GMFP*COHFAC
              END IF
              IF ((IPHOTONUCR(IRL).EQ.1)) THEN
                PHOTONUCFAC=PHOTONUC1(LGLE,MEDIUM)*GLE+PHOTONUC0(LGLE,ME
     *          DIUM)
                GMFP=GMFP*PHOTONUCFAC
              END IF
              TSTEP=GMFP*DPMFP
            END IF
            IRNEW=IR(NP)
            IDISC=0
            USTEP=TSTEP
            TUSTEP=USTEP
            IF (( ustep .GT. dnear(np) .OR. wt(np) .LE. 0 )) THEN
              call howfar
            END IF
            IF ((IDISC.GT.0)) THEN
              GO TO 13310
            END IF
            VSTEP=USTEP
            TVSTEP=VSTEP
            EDEP=PZERO
            x_final = x(np) + u(np)*vstep
            y_final = y(np) + v(np)*vstep
            z_final = z(np) + w(np)*vstep
            IARG=0
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            x(np) = x_final
            y(np) = y_final
            z(np) = z_final
            DNEAR(NP)=DNEAR(NP)-USTEP
            IF ((MEDIUM.NE.0)) THEN
              DPMFP=MAX(0.,DPMFP-USTEP/GMFP)
            END IF
            IROLD=IR(NP)
            MEDOLD=MEDIUM
            IF ((IRNEW.NE.IROLD)) THEN
              ir(np) = irnew
              irl = irnew
              medium = med(irl)
            END IF
            IARG=5
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            IF ((EIG.LE.PCUT(IRL))) THEN
              GO TO 13290
            END IF
            IF((IDISC.LT.0))GO TO 13310
            IF((MEDIUM.NE.MEDOLD))GO TO 13352
            IF ((MEDIUM.NE.0.AND.DPMFP.LE.1.E-8)) THEN
              GO TO 13342
            END IF
          GO TO 13351
13352     CONTINUE
        GO TO 13341
13342   CONTINUE
        IF ((IRAYLR(IRL).EQ.1)) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO37 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF ((RNNO37.LE.(1.0-COHFAC))) THEN
            IARG=23
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            NPold = NP
            call egs_rayleigh_sampling(MEDIUM,E(NP),GLE,LGLE,COSTHE,SINT
     *      HE)
            CALL UPHI(2,1)
            IARG=24
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            GOTO 13300
          END IF
        END IF
        IF ((IPHOTONUCR(IRL).EQ.1)) THEN
          IF((rng_seed .GT. 128))call ranmar_get
          RNNO39 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          IF ((RNNO39.LE.(1.0-PHOTONUCFAC))) THEN
            IARG=29
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            call PHOTONUC
            IARG=30
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              CALL AUSGAB(IARG)
            END IF
            GOTO 13300
          END IF
        END IF
        IF((rng_seed .GT. 128))call ranmar_get
        RNNO36 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        GBR1=GBR11(LGLE,MEDIUM)*GLE+GBR10(LGLE,MEDIUM)
        IF (((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )) THEN
          IARG=15
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          CALL PAIR
          IARG=16
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          IF (( iq(np) .NE. 0 )) THEN
            GO TO 13302
          ELSE
            goto 13360
          END IF
        END IF
        GBR2=GBR21(LGLE,MEDIUM)*GLE+GBR20(LGLE,MEDIUM)
        IF ((RNNO36.LT.GBR2)) THEN
          IARG=17
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          CALL COMPT
          IARG=18
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          IF((IQ(NP).NE.0))GO TO 13302
        ELSE
          IARG=19
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          CALL PHOTO
          IF ((NP .EQ. 0 .OR. NP .LT. NPOLD )) THEN
            RETURN
          END IF
          IARG=20
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            CALL AUSGAB(IARG)
          END IF
          IF((IQ(NP) .NE. 0))GO TO 13302
        END IF
13360   PEIG=E(NP)
        EIG=PEIG
        IF((EIG.LT.PCUT(IRL)))GO TO 13290
      GO TO 13301
13302 CONTINUE
      RETURN
13290 IF (( medium .GT. 0 )) THEN
        IF ((EIG.GT.AP(MEDIUM))) THEN
          IDR=1
        ELSE
          IDR=2
        END IF
      ELSE
        IDR=1
      END IF
      EDEP=PEIG
      IARG=IDR
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      IRCODE=2
      NP=NP-1
      RETURN
13310 EDEP=PEIG
      IARG=3
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      IRCODE=2
      NP=NP-1
      RETURN
      END
      SUBROUTINE SHOWER(IQI,EI,XI,YI,ZI,UI,VI,WI,IRI,WTI)
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 EI,  XI,YI,ZI, UI,VI,WI, WTI
      integer*4 IQI,  IRI
      DOUBLE PRECISION DEG,  DPGL,  DEI,  DPI,  DCSTH,  DCOSTH,  PI0MSQ
      real*8 DNEARI,  CSTH
      integer*4 IRCODE
      DATA PI0MSQ/1.8215416D4/
      NP=1
      NPold = NP
      DNEARI=0.0
      IQ(1)=IQI
      E(1)=EI
      U(1)=UI
      V(1)=VI
      W(1)=WI
      X(1)=XI
      Y(1)=YI
      Z(1)=ZI
      IR(1)=IRI
      WT(1)=WTI
      DNEAR(1)=DNEARI
      LATCH(1)=LATCHI
      IF ((IQI .EQ. 2)) THEN
        IF ((EI**2 .LE. PI0MSQ)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//a/,a,g15.5,a)') ' Stopped in subroutine SHOWER
     *---PI-ZERO option invoked', ' but the total energy was too small (
     *EI=',EI,' MeV)'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF((rng_seed .GT. 128))call ranmar_get
        CSTH = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        DCSTH=CSTH
        DEI=EI
        DPI=DSQRT(DEI*DEI-PI0MSQ)
        DEG=DEI+DPI*DCSTH
        DPGL=DPI+DEI*DCSTH
        DCOSTH=DPGL/DEG
        COSTHE=DCOSTH
        SINTHE=DSQRT(1.D0-DCOSTH*DCOSTH)
        IQ(1)=0
        E(1)=DEG/2.
        CALL UPHI(2,1)
        NP=2
        DEG=DEI-DPI*DCSTH
        DPGL=DPI-DEI*DCSTH
        DCOSTH=DPGL/DEG
        COSTHE=DCOSTH
        SINTHE=-DSQRT(1.D0-DCOSTH*DCOSTH)
        IQ(2)=0
        E(2)=DEG/2.
        CALL UPHI(3,2)
      END IF
13371 CONTINUE
        IF((np .LE. 0))GO TO13372
        IF (( iq(np) .EQ. 0 )) THEN
          call photon(ircode)
        ELSE
          call electr(ircode)
        END IF
      GO TO 13371
13372 CONTINUE
      RETURN
      END
      SUBROUTINE UPHI(IENTRY,LVL)
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      real*8 SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer IENTRY,LVL
      real*8 CTHET,  RNNO38,  PHI,  CPHI,  A,B,C,  SINPS2,  SINPSI,  US,
     *VS,  SINDEL,COSDEL
      integer*4 IARG,  LPHI,LTHETA,LCTHET,LCPHI
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      save CTHET,PHI,CPHI,A,B,C,SINPS2,SINPSI,US,VS,SINDEL,COSDEL
      IARG=21
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      GO TO (13380,13390,13400),IENTRY
      GO TO 13410
13380 CONTINUE
      SINTHE=sin(THETA)
      CTHET=PI5D2-THETA
      COSTHE=sin(CTHET)
13390 CONTINUE
13421 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        xphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF((rng_seed .GT. 128))call ranmar_get
        yphi = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO13422
      GO TO 13421
13422 CONTINUE
      rhophi2 = 1/rhophi2
      cosphi = (xphi2 - yphi2)*rhophi2
      sinphi = 2*xphi*yphi*rhophi2
13400 GO TO (13430,13440,13450),LVL
      GO TO 13410
13430 A=U(NP)
      B=V(NP)
      C=W(NP)
      GO TO 13460
13450 A=U(NP-1)
      B=V(NP-1)
      C=W(NP-1)
13440 X(NP)=X(NP-1)
      Y(NP)=Y(NP-1)
      Z(NP)=Z(NP-1)
      IR(NP)=IR(NP-1)
      WT(NP)=WT(NP-1)
      DNEAR(NP)=DNEAR(NP-1)
      LATCH(NP)=LATCH(NP-1)
13460 SINPS2=A*A+B*B
      IF ((SINPS2.LT.1.0E-20)) THEN
        U(NP)=SINTHE*COSPHI
        V(NP)=SINTHE*SINPHI
        W(NP)=C*COSTHE
      ELSE
        SINPSI=SQRT(SINPS2)
        US=SINTHE*COSPHI
        VS=SINTHE*SINPHI
        SINDEL=B/SINPSI
        COSDEL=A/SINPSI
        U(NP)=C*COSDEL*US-SINDEL*VS+A*COSTHE
        V(NP)=C*SINDEL*US+COSDEL*VS+B*COSTHE
        W(NP)=-SINPSI*US+C*COSTHE
      END IF
      IARG=22
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        CALL AUSGAB(IARG)
      END IF
      RETURN
13410 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,2i6)') ' STOPPED IN UPHI WITH IENTRY,LVL=',IENTRY,
     *LVL
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      END
      subroutine init_nist_brems
      implicit none
      real*8 energy_array(57),x_array(54), cs_array(57,54,100)
      real*8 xi_array(54)
      real*8 x_gauss(64),w_gauss(64)
      integer*4 nmix,kmix,i,n,k,j,ii
      integer*4 ngauss,i_gauss
      integer*4 lnblnk1,egs_get_unit
      integer*4 ifirst,ilast,nener,neke,leil
      real*8 cs(57,54),ee(57),ele(57)
      real*8 csx(54),afx(54),bfx(54),cfx(54),dfx(54)
      real*8 cse(57),afe(57),bfe(57),cfe(57),dfe(57)
      real*8 Z,sumA
      real*8 emin,xi,res,spline,eil,ei,beta2,aux,sigb,sigt,ebr1,ebr2
      real*8 sigee,sigep,sige,si_esig,si1_esig,si_ebr1,si1_ebr1,ededx, s
     *ig_bhabha,si_psig,si1_psig,si_pbr1,si1_pbr1,si_pbr2,si1_pbr2
      integer*4 iz
      real*8 ple,qle,x,f,error,max_error,x_max_error,f_max_error
      integer*4 ndat,k_max_error
      character tmp_string*512, tmp1_string*512
      integer itmp
      real*8 amu
      parameter (amu = 1660.5655)
      logical ex,is_opened
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/nist_brems/ nb_fdata(0:50,100,3), nb_xdata(0:50,100,3), nb_
     *wdata(50,100,3), nb_idata(50,100,3), nb_emin(3),nb_emax(3), nb_lem
     *in(3),nb_lemax(3), nb_dle(3),nb_dlei(3), log_ap(3)
      real*8 nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lema
     *x, nb_dle,nb_dlei,log_ap
      integer*4 nb_idata
      common/spin_data/ spin_rej(3,0:1,0: 31,0:15,0:31), espin_min,espin
     *_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dleneri,dq
     *q1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DO 13471 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
13471 CONTINUE
13472 CONTINUE
      tmp_string = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      IF (( ibr_nist .EQ. 1 )) THEN
        DO 13481 i=1,len(tmp1_string)
          tmp1_string(i:i) = ' '
13481   CONTINUE
13482   CONTINUE
        tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'nist_brems.da
     *ta'
        inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
        IF (( .NOT.ex )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'EGSnrc data file ','nist_brems.data',' does no
     *t exist'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF (( .NOT.is_opened )) THEN
          i_nist_data=egs_get_unit(i_nist_data)
          IF ((i_nist_data.LT.0)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'failed to get a free Fortran I/O unit for da
     *ta file ', tmp1_string(:lnblnk1(tmp1_string))
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(i_nist_data,file=tmp1_string,status='old',err=8540)
        ELSE
          i_nist_data = itmp
        END IF
      ELSE IF((ibr_nist .EQ. 2)) THEN
        DO 13491 i=1,len(tmp1_string)
          tmp1_string(i:i) = ' '
13491   CONTINUE
13492   CONTINUE
        tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'nrc_brems.dat
     *a'
        inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
        IF (( .NOT.ex )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'EGSnrc data file ','nrc_brems.data',' does not
     * exist'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF (( .NOT.is_opened )) THEN
          i_nist_data=egs_get_unit(i_nist_data)
          IF ((i_nist_data.LT.0)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'failed to get a free Fortran I/O unit for da
     *ta file ', tmp1_string(:lnblnk1(tmp1_string))
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(i_nist_data,file=tmp1_string,status='old',err=8540)
        ELSE
          i_nist_data = itmp
        END IF
      ELSE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' init_nist_brems: unknown value of ibr_nist!
     *                  ibr_nist = ', ibr_nist
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      rewind(i_nist_data)
      read(i_nist_data,*)
      read(i_nist_data,*) nmix,kmix
      IF ((kmix .GT. 54)) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' init_nist_brems: to many k values in data file!
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF ((nmix .GT. 57)) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' init_nist_brems: to many T values in data file!
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      read(i_nist_data,*) (energy_array(n),n=1,nmix)
      DO 13501 n=1,nmix
        energy_array(n) = 1.0*energy_array(n)
13501 CONTINUE
13502 CONTINUE
      read(i_nist_data,*) (x_array(k),k=1,kmix)
      read(i_nist_data,*)
      DO 13511 i=1,100
        read(i_nist_data,*) ((cs_array(n,k,i),n=1,nmix),k=1,kmix)
13511 CONTINUE
13512 CONTINUE
      close(i_nist_data)
      DO 13521 k=1,kmix
        xi_array(k)=Log(1-x_array(k)+1e-6)
        IF (( fool_intel_optimizer )) THEN
          write(6,*) 'xi_array(k): ',xi_array(k)
          write(1,*) 'xi_array(k): ',xi_array(k)
        END IF
13521 CONTINUE
13522 CONTINUE
      ngauss = 64
      call gauss_legendre(0d0,1d0,x_gauss,w_gauss,ngauss)
      write(6,*) ' '
      write(1,*) ' '
      IF ((ibr_nist .EQ. 1)) THEN
        write(6,*) 'Using NIST brems cross sections! '
        write(1,*) 'Using NIST brems cross sections! '
      ELSE IF((ibr_nist .EQ. 2)) THEN
        write(6,*) 'Using NRC brems cross sections! '
        write(1,*) 'Using NRC brems cross sections! '
      END IF
      write(6,*) ' '
      write(1,*) ' '
      DO 13531 medium=1,nmed
        log_ap(medium) = log(ap(medium))
        write(6,*) ' Initializing brems data for medium ',medium,'...'
        write(1,*) ' Initializing brems data for medium ',medium,'...'
        emin = max(ae(medium) - rm, ap(medium))
        DO 13541 i=1,nmix
          IF((energy_array(i) .GE. emin))GO TO13542
13541   CONTINUE
13542   CONTINUE
        ifirst = i
        DO 13551 i=nmix,1,-1
          IF((energy_array(i) .LT. ue(medium) - rm))GO TO13552
13551   CONTINUE
13552   CONTINUE
        ilast = i+1
        IF (( ifirst .LT. 1 .OR. ilast .GT. nmix )) THEN
          write(6,*) ' init_nist_brems: data available only for '
          write(1,*) ' init_nist_brems: data available only for '
          write(6,*) energy_array(1),' <= E <= ',energy_array(nmix)
          write(1,*) energy_array(1),' <= E <= ',energy_array(nmix)
          write(6,*) ' will use spline interpolations to get cross '
          write(1,*) ' will use spline interpolations to get cross '
          write(6,*) ' sections beyond the available data but this may'
          write(1,*) ' sections beyond the available data but this may'
          write(6,*) ' produce nonsense!'
          write(1,*) ' produce nonsense!'
          IF((ifirst .LT. 1))ifirst=1
          IF((ilast .GT. nmix))ilast = nmix
        END IF
        DO 13561 i=ifirst,ilast
          ii = i+1 - ifirst
          ee(ii) = energy_array(i)
          ele(ii) = log(ee(ii))
          sumA = 0
          DO 13571 j=1,NNE(medium)
            sumA = sumA + pz(medium,j)*wa(medium,j)
13571     CONTINUE
13572     CONTINUE
          sumA = sumA*amu
          DO 13581 k=1,kmix
            cs(ii,k) = 0
            DO 13591 j=1,NNE(medium)
              Z = zelem(medium,j)
              iz = int(Z+0.1)
              Z = Z*Z/sumA
              cs(ii,k) = cs(ii,k) + pz(medium,j)*Z*cs_array(i,k,iz)
13591       CONTINUE
13592       CONTINUE
            csx(k) = Log(cs(ii,k))
13581     CONTINUE
13582     CONTINUE
          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix)
          cse(ii) = 0
          aux = Log(ee(ii)/ap(medium))
          DO 13601 i_gauss=1,ngauss
            xi = log(1 - ap(medium)/ee(ii)*exp(x_gauss(i_gauss)*aux)+1e-
     *      6)
            res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix)
            cse(ii) = cse(ii) + w_gauss(i_gauss)*exp(res)
13601     CONTINUE
13602     CONTINUE
13561   CONTINUE
13562   CONTINUE
        nener = ilast - ifirst + 1
        call set_spline(ele,cse,afe,bfe,cfe,dfe,nener)
        neke = meke(medium)
        sigee = 1E-15
        sigep = 1E-15
        DO 13611 i=1,neke
          eil = (float(i) - eke0(medium))/eke1(medium)
          ei = exp(eil)
          leil = i
          beta2 = ei*(ei+2*rm)/(ei+rm)**2
          IF (( ei .LE. ap(medium) )) THEN
            sigb = 1e-30
          ELSE
            sigb = spline(eil,ele,afe,bfe,cfe,dfe,nener)
            sigb = sigb*log(ei/ap(medium))/beta2*rho(medium)
          END IF
          sigt=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
          ebr1=ebr11(Leil,MEDIUM)*eil+ebr10(Leil,MEDIUM)
          IF((sigt .LT. 0))sigt = 0
          IF((ebr1 .GT. 1))ebr1 = 1
          IF((ebr1 .LT. 0))ebr1 = 0
          IF (( i .GT. 1 )) THEN
            si_esig = si1_esig
            si_ebr1 = si1_ebr1
            si1_esig = sigt*(1 - ebr1) + sigb
            si1_ebr1 = sigb/si1_esig
            esig1(i-1,medium) = (si1_esig - si_esig)*eke1(medium)
            esig0(i-1,medium) = si1_esig - esig1(i-1,medium)*eil
            ebr11(i-1,medium) = (si1_ebr1 - si_ebr1)*eke1(medium)
            ebr10(i-1,medium) = si1_ebr1 - ebr11(i-1,medium)*eil
          ELSE
            si1_esig = sigt*(1 - ebr1) + sigb
            si1_ebr1 = sigb/si1_esig
          END IF
          sigt=psig1(Leil,MEDIUM)*eil+psig0(Leil,MEDIUM)
          ebr1=pbr11(Leil,MEDIUM)*eil+pbr10(Leil,MEDIUM)
          ebr2=pbr21(Leil,MEDIUM)*eil+pbr20(Leil,MEDIUM)
          IF((sigt .LT. 0))sigt = 0
          IF((ebr1 .GT. 1))ebr1 = 1
          IF((ebr1 .LT. 0))ebr1 = 0
          IF((ebr2 .GT. 1))ebr2 = 1
          IF((ebr2 .LT. 0))ebr2 = 0
          sig_bhabha = sigt*(ebr2 - ebr1)
          IF((sig_bhabha .LT. 0))sig_bhabha = 0
          IF (( i .GT. 1 )) THEN
            si_psig = si1_psig
            si_pbr1 = si1_pbr1
            si_pbr2 = si1_pbr2
            si1_psig = sigt*(1 - ebr1) + sigb
            si1_pbr1 = sigb/si1_psig
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig
            psig1(i-1,medium) = (si1_psig - si_psig)*eke1(medium)
            psig0(i-1,medium) = si1_psig - psig1(i-1,medium)*eil
            pbr11(i-1,medium) = (si1_pbr1 - si_pbr1)*eke1(medium)
            pbr10(i-1,medium) = si1_pbr1 - pbr11(i-1,medium)*eil
            pbr21(i-1,medium) = (si1_pbr2 - si_pbr2)*eke1(medium)
            pbr20(i-1,medium) = si1_pbr2 - pbr21(i-1,medium)*eil
          ELSE
            si1_psig = sigt*(1 - ebr1) + sigb
            si1_pbr1 = sigb/si1_psig
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig
          END IF
          ededx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
          sige = si1_esig/ededx
          IF((sige .GT. sigee))sigee = sige
          ededx=pdedx1(Leil,MEDIUM)*eil+pdedx0(Leil,MEDIUM)
          sige = si1_psig/ededx
          IF((sige .GT. sigep))sigep = sige
13611   CONTINUE
13612   CONTINUE
        esig1(neke,medium) = esig1(neke-1,medium)
        esig0(neke,medium) = esig0(neke-1,medium)
        ebr11(neke,medium) = ebr11(neke-1,medium)
        ebr10(neke,medium) = ebr10(neke-1,medium)
        psig1(neke,medium) = psig1(neke-1,medium)
        psig0(neke,medium) = psig0(neke-1,medium)
        pbr11(neke,medium) = pbr11(neke-1,medium)
        pbr10(neke,medium) = pbr10(neke-1,medium)
        pbr21(neke,medium) = pbr21(neke-1,medium)
        pbr20(neke,medium) = pbr20(neke-1,medium)
        write(6,*) ' Max. new cross sections per energy loss: ',sigee,si
     *  gep
        write(1,*) ' Max. new cross sections per energy loss: ',sigee,si
     *  gep
        esig_e(medium) = sigee
        psig_e(medium) = sigep
        IF((sigee .GT. esige_max))esige_max = sigee
        IF((sigep .GT. psige_max))psige_max = sigep
        nb_emin(medium) = energy_array(ifirst)
        IF (( nb_emin(medium) .LE. ap(medium) )) THEN
          nb_emin(medium) = energy_array(ifirst+1)
        END IF
        nb_emax(medium) = energy_array(ilast)
        nb_lemin(medium) = log(nb_emin(medium))
        nb_lemax(medium) = log(nb_emax(medium))
        nb_dle(medium) = (nb_lemax(medium) - nb_lemin(medium))/(100-1)
        nb_dlei(medium) = 1/nb_dle(medium)
        eil = nb_lemin(medium) - nb_dle(medium)
        DO 13621 i=1,100
          eil = eil + nb_dle(medium)
          ei = exp(eil)
          DO 13631 ii=1,nener
            IF((ei .LT. ee(ii)))GO TO13632
13631     CONTINUE
13632     CONTINUE
          ii = ii-1
          IF((ii .LT. 1))ii = 1
          IF((ii .GT. nener-1))ii = nener-1
          ple = (eil - ele(ii))/(ele(ii+1)-ele(ii))
          qle = 1 - ple
          DO 13641 k=1,kmix
            csx(k) = log(qle*cs(ii,k) + ple*cs(ii+1,k))
13641     CONTINUE
13642     CONTINUE
          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix)
          x = ap(medium)/ei
          aux = -log(x)
          xi = log(1 - x+1e-6)
          res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix)
          nb_xdata(0,i,medium) = 0
          nb_fdata(0,i,medium) = exp(res)
          DO 13651 k=1,kmix
            IF((x_array(k) .GT. x))GO TO13652
13651     CONTINUE
13652     CONTINUE
          IF((k .GT. kmix))k = kmix
          ndat = 0
          DO 13661 j=k+1,kmix-1
            ndat = ndat+1
            nb_xdata(ndat,i,medium) = log(x_array(j)/x)/aux
            nb_fdata(ndat,i,medium) = exp(csx(j))
            IF (( fool_intel_optimizer )) THEN
              write(6,*) 'nb_xdata(ndat,i,medium): ', nb_xdata(ndat,i,me
     *        dium)
              write(1,*) 'nb_xdata(ndat,i,medium): ', nb_xdata(ndat,i,me
     *        dium)
            END IF
13661     CONTINUE
13662     CONTINUE
          ndat = ndat+1
          nb_xdata(ndat,i,medium) = 1
          nb_fdata(ndat,i,medium) = exp(csx(kmix))
          IF((ndat .GE. 50))goto 13670
13681     CONTINUE
            x_max_error = 0
            f_max_error = 0
            k_max_error = 0
            max_error = 0
            DO 13691 k=0,ndat-1
              x = 0.5*(nb_xdata(k,i,medium) + nb_xdata(k+1,i,medium))
              f = 0.5*(nb_fdata(k,i,medium) + nb_fdata(k+1,i,medium))
              xi = log(1 - ap(medium)/ei*exp(x*aux)+1e-6)
              res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix)
              res = exp(res)
              error = abs(1-f/res)
              IF (( error .GT. max_error )) THEN
                x_max_error = x
                f_max_error = res
                max_error = error
                k_max_error = k
              END IF
13691       CONTINUE
13692       CONTINUE
            ndat = ndat+1
            DO 13701 k=ndat,k_max_error+2,-1
              nb_xdata(k,i,medium) = nb_xdata(k-1,i,medium)
              nb_fdata(k,i,medium) = nb_fdata(k-1,i,medium)
13701       CONTINUE
13702       CONTINUE
            nb_xdata(k_max_error+1,i,medium) = x_max_error
            nb_fdata(k_max_error+1,i,medium) = f_max_error
            IF(((ndat .EQ. 50)))GO TO13682
          GO TO 13681
13682     CONTINUE
13670     call prepare_alias_table(50,nb_xdata(0,i,medium), nb_fdata(0,i
     *    ,medium),nb_wdata(1,i,medium),nb_idata(1,i,medium))
13621   CONTINUE
13622   CONTINUE
13531 CONTINUE
13532 CONTINUE
      write(6,*) ' '
      write(1,*) ' '
      write(6,*) ' '
      write(1,*) ' '
      return
8540  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open EGSnrc data file ',tmp1_string(:lnb
     *lnk1(tmp1_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine init_nrc_pair
      implicit none
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      common/nrc_pair/ nrcp_fdata(65,84,3), nrcp_wdata(65,84,3), nrcp_id
     *ata(65,84,3), nrcp_xdata(65), nrcp_emin, nrcp_emax, nrcp_dle, nrcp
     *_dlei
      real*8 nrcp_fdata,nrcp_wdata,nrcp_xdata, nrcp_emin, nrcp_emax, nrc
     *p_dle, nrcp_dlei
      integer*4 nrcp_idata
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character nrcp_file*256, endianess*4
      integer egs_get_unit
      integer*4 nrcp_unit, want_nrcp_unit, rec_length
      integer*4 i, lnblnk1
      real*8 tmp, ddx, xx, Z
      real*4 emin, emax
      integer*4 ne, nb, ix, ie, irec, i_ele, nbb, iz
      character endian, cdum( 243)
      logical swap
      real*4 tmp_4, tarray(65)
      integer*4 itmp_4
      character c_4(4), ic_4(4)
      equivalence (tmp_4,c_4), (itmp_4, ic_4)
      DO 13711 i=1,len(nrcp_file)
        nrcp_file(i:i) = ' '
13711 CONTINUE
13712 CONTINUE
      nrcp_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'pa
     *ir_nrc1.data'
      want_nrcp_unit = 62
      nrcp_unit = egs_get_unit(want_nrcp_unit)
      IF (( nrcp_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'init_nrc_pair: failed to get a free fortran unit
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      rec_length = 65*4
      open(nrcp_unit,file=nrcp_file,form='unformatted',access='direct',
     *status='old',recl=rec_length,err=13720)
      read(nrcp_unit,rec=1,err=13730) emin, emax, ne, nb, endian, cdum
      IF (( ichar(endian) .EQ. 0 )) THEN
        endianess = '1234'
      ELSE
        endianess = '4321'
      END IF
      swap = endianess.ne.'1234'
      IF (( swap )) THEN
        tmp_4 = emin
        call egs_swap_4(c_4)
        emin = tmp_4
        tmp_4 = emax
        call egs_swap_4(c_4)
        emax = tmp_4
        itmp_4 = ne
        call egs_swap_4(ic_4)
        ne = itmp_4
        itmp_4 = nb
        call egs_swap_4(ic_4)
        nb = itmp_4
      END IF
      write(6,'(//a,a)') 'Reading NRC pair data base from ',nrcp_file(:l
     *nblnk1(nrcp_file))
      write(1,'(//a,a)') 'Reading NRC pair data base from ',nrcp_file(:l
     *nblnk1(nrcp_file))
      write(6,'(a,a,a)') 'Data generated on a machine with ',endianess,'
     * endianess'
      write(1,'(a,a,a)') 'Data generated on a machine with ',endianess,'
     * endianess'
      write(6,'(a,a)') 'The endianess of this CPU is ','1234'
      write(1,'(a,a)') 'The endianess of this CPU is ','1234'
      IF (( swap )) THEN
        write(6,'(a)') '=> will need to do byte swaping'
        write(1,'(a)') '=> will need to do byte swaping'
      END IF
      write(6,'(a,2f9.3)') 'Energy range of the data: ',emin,emax
      write(1,'(a,2f9.3)') 'Energy range of the data: ',emin,emax
      IF (( nb .NE. 65 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Inconsistent x-grid size'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( ne .NE. 84 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Inconsistent energy grid size'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      nrcp_emin = emin
      nrcp_emax = emax
      nrcp_dle = log((emax-2)/(emin-2))/(ne-1)
      nrcp_dlei = 1/nrcp_dle
      nbb = nb/2
      ddx = sqrt(0.5)/nbb
      DO 13741 ix=0,nbb
        xx = ddx*ix
        nrcp_xdata(ix+1) = xx*xx
13741 CONTINUE
13742 CONTINUE
      do ix=nbb-1,0,-1
        xx = ddx*ix
        nrcp_xdata(nb-ix) = 1 - xx*xx
      end do
      DO 13761 medium=1,NMED
        write(6,'(a,i4,a,$)') '  medium ',medium,' .....................
     * '
        write(1,'(a,i4,a,$)') '  medium ',medium,' .....................
     * '
        DO 13771 ie=1,84
          DO 13781 ix=1,65
            nrcp_fdata(ix,ie,medium) = 0
13781     CONTINUE
13782     CONTINUE
13771   CONTINUE
13772   CONTINUE
        DO 13791 i_ele=1,NNE(medium)
          Z = ZELEM(medium,i_ele)
          iz = int(Z+0.5)
          tmp = PZ(medium,i_ele)*Z*Z
          irec = (iz-1)*ne + 2
          DO 13801 ie=1,84
            read(nrcp_unit,rec=irec,err=13730) tarray
            DO 13811 ix=1,65
              tmp_4 = tarray(ix)
              IF (( swap )) THEN
                call egs_swap_4(c_4)
              END IF
              nrcp_fdata(ix,ie,medium)=nrcp_fdata(ix,ie,medium)+tmp*tmp_
     *        4
13811       CONTINUE
13812       CONTINUE
            irec = irec + 1
13801     CONTINUE
13802     CONTINUE
13791   CONTINUE
13792   CONTINUE
        DO 13821 ie=1,84
          call prepare_alias_table(nb-1,nrcp_xdata,nrcp_fdata(1,ie,mediu
     *    m), nrcp_wdata(1,ie,medium),nrcp_idata(1,ie,medium))
13821   CONTINUE
13822   CONTINUE
        write(6,'(a)') ' done'
        write(1,'(a)') ' done'
13761 CONTINUE
13762 CONTINUE
      write(6,*) ' '
      write(1,*) ' '
      close(nrcp_unit)
      return
13720 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Failed to open NRC pair data file'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
13730 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'I/O error while reading NRC pair data file'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      subroutine vmc_electron(ircode)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 ircode
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(//a//)') ' ********* VMC Transport option not in thi
     *s distribution ****** '
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      subroutine egs_init_default_rng
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      ixx=0
      jxx=0
      call init_ranmar
      return
      end
      subroutine egs_init_rng(arg1,arg2)
      integer*4 arg1,arg2
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      ixx = arg1
      jxx = arg2
      call init_ranmar
      return
      end
      subroutine egs_get_rndm(ran)
      real*8 ran
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      IF((rng_seed .GT. 128))call ranmar_get
      ran = rng_array(rng_seed)*twom24
      rng_seed = rng_seed + 1
      return
      end
      subroutine egs_get_rndm_array(n,rarray)
      integer*4 n
      real*8 rarray(*)
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      real*8 rtmp
      integer*4 i
      IF((n .LT. 1))return
      DO 13831 i=1,n
        IF((rng_seed .GT. 128))call ranmar_get
        rtmp = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        rarray(i) = rtmp
13831 CONTINUE
13832 CONTINUE
      return
      end
      subroutine eii_init
      implicit none
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(3), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),  e
     *ii_sh(40),  eii_nshells(100),  eii_nsh(3),  eii_first(3,50),  eii_
     *no(3,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      COMMON/ELECIN/ esig_e(3),psig_e(3), esige_max, psige_max, range_ep
     *(0:1,500,3), E_array(500,3), etae_ms0(500,3),etae_ms1(500,3),etap_
     *ms0(500,3),etap_ms1(500,3),q1ce_ms0(500,3),q1ce_ms1(500,3),q1cp_ms
     *0(500,3),q1cp_ms1(500,3),q2ce_ms0(500,3),q2ce_ms1(500,3),q2cp_ms0(
     *500,3),q2cp_ms1(500,3),blcce0(500,3),blcce1(500,3), EKE0(3),EKE1(3
     *), XR0(3),TEFF0(3),BLCC(3),XCC(3), ESIG0(500,3),ESIG1(500,3),PSIG0
     *(500,3),PSIG1(500,3),EDEDX0(500,3),EDEDX1(500,3),PDEDX0(500,3),PDE
     *DX1(500,3),EBR10(500,3),EBR11(500,3),PBR10(500,3),PBR11(500,3),PBR
     *20(500,3),PBR21(500,3),TMXS0(500,3),TMXS1(500,3), expeke1(3), IUNR
     *ST(3),EPSTFL(3),IAPRIM(3), sig_ismonotone(0:1,3)
      real*8 esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E_ar
     *ray,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1,
     *q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blcce0
     *,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG0,E
     *SIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR11,
     * PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      integer*4 imed,iele,ish,nsh,iZ,j,i,itmp,nskip,nbin,ii,nsh_tot,iii,
     *k
      integer*4 jj,jjj
      integer*4 lnblnk1
      integer*4 tmp_array(100)
      integer*4 want_eii_unit,eii_unit,eii_out,egs_open_file
      integer egs_get_unit
      real*8 e_eii_min,emax,fmax,aux_array(250)
      real*8 sigo,loge,tau,beta2,p2,uwm,Wmax
      real*8 ss_0, ss_1, sh_0, sh_1, aux, av_e, con_med, dedx_old, sigm_
     *old
      real*8 dedx,e,sig,sigm,wbrem,sum_a,sum_z,sum_pz,sum_wa,Ec,Ecc
      real*8 sum_sh,sum_occn,U,sum_sigma,sum_dedx
      real*8 sigma,sigma_old,wbrem_old,sig_j,de
      integer*4 lloge
      logical check_it,is_monotone,getd
      real*8 sigma_max
      character eii_file*128
      character*512 toUpper
      integer*4 occn_numbers(4)
      real*8 cons
      parameter (cons = 0.153536)
      data occn_numbers/2,2,2,4/
      DO 13841 j=1,100
        eii_nshells(j) = 0
13841 CONTINUE
13842 CONTINUE
      DO 13851 j=1,3
        eii_nsh(j) = 0
13851 CONTINUE
13852 CONTINUE
      IF (( eii_flag .EQ. 0 )) THEN
        return
      END IF
      getd = .false.
      DO 13861 j=1, 1001
        IF (( iedgfl(j) .GT. 0 .AND. iedgfl(j) .LE. 100 )) THEN
          getd = .true.
          GO TO13862
        END IF
13861 CONTINUE
13862 CONTINUE
      IF (( .NOT.getd )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(/a,/a,/a,/a)') ' In subroutine eii_init: ', '   Sc
     *attering off bound electrons creates atomic vacancies,', '   poten
     *tially starting an atomic relaxation cascade. ', '   Please turn O
     *N atomic relaxations.'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      e_eii_min = 1e30
      DO 13871 imed=1,nmed
        IF((ae(imed)-rm .LT. e_eii_min))e_eii_min = ae(imed) - rm
        IF((ap(imed) .LT. e_eii_min))e_eii_min = ap(imed)
13871 CONTINUE
13872 CONTINUE
      write(6,*) ' '
      write(1,*) ' '
      write(6,*) 'eii_init: minimum threshold energy found: ',e_eii_min
      write(1,*) 'eii_init: minimum threshold energy found: ',e_eii_min
      DO 13881 imed=1,nmed
        DO 13891 iele=1,nne(imed)
          iZ = int(zelem(imed,iele)+0.5)
          IF (( eii_nshells(iZ) .EQ. 0 )) THEN
            nsh = 0
            DO 13901 ish=1,4
              IF((binding_energies(ish,iZ) .GT. e_eii_min))nsh = nsh+1
13901       CONTINUE
13902       CONTINUE
            eii_nshells(iZ) = nsh
          END IF
13891   CONTINUE
13892   CONTINUE
13881 CONTINUE
13882 CONTINUE
      nsh = 0
      DO 13911 iZ=1,100
        nsh = nsh + eii_nshells(iZ)
13911 CONTINUE
13912 CONTINUE
      IF (( nsh .EQ. 0 )) THEN
        write(6,*) '*** EII requested but no shells with binding energie
     *s '
        write(1,*) '*** EII requested but no shells with binding energie
     *s '
        write(6,*) '    above the specified threshold found'
        write(1,*) '    above the specified threshold found'
        write(6,*) '    => turning off EII'
        write(1,*) '    => turning off EII'
        eii_flag = 0
      END IF
      IF (( nsh .GT. 40 )) THEN
        write(6,*) '*** Number of shells with binding energies greater t
     *han '
        write(1,*) '*** Number of shells with binding energies greater t
     *han '
        write(6,*) '    the specified thresholds is ',nsh
        write(1,*) '    the specified thresholds is ',nsh
        write(6,*) '    This is more than the allocated arrays can hold'
        write(1,*) '    This is more than the allocated arrays can hold'
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) '    Increase the macro $MAX_EII_SHELLS and retry
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      write(6,*) 'eii_init: number of shells to simulate EII: ',nsh
      write(1,*) 'eii_init: number of shells to simulate EII: ',nsh
      nsh_tot = nsh
      tmp_array(1) = 0
      DO 13921 j=2,100
        tmp_array(j) = tmp_array(j-1) + eii_nshells(j-1)
13921 CONTINUE
13922 CONTINUE
      DO 13931 imed=1,nmed
        nsh = 0
        DO 13941 iele=1,nne(imed)
          iZ = int(zelem(imed,iele)+0.5)
          eii_no(imed,iele) = eii_nshells(iZ)
          nsh = nsh + eii_nshells(iZ)
          IF (( eii_nshells(iZ) .GT. 0 )) THEN
            eii_first(imed,iele) = tmp_array(iZ) + 1
          ELSE
            eii_first(imed,iele) = 0
          END IF
13941   CONTINUE
13942   CONTINUE
        eii_nsh(imed) = nsh
13931 CONTINUE
13932 CONTINUE
      DO 13951 i=1,len(eii_file)
        eii_file(i:i) = ' '
13951 CONTINUE
13952 CONTINUE
      eii_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'eii
     *_'// eii_xfile(:lnblnk1(eii_xfile)) //'.data'
      want_eii_unit = 62
      eii_unit = egs_get_unit(want_eii_unit)
      IF (( eii_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'eii_init: failed to get a free Fortran I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(eii_unit,file=eii_file(:lnblnk1(eii_file)),status='old',err=1
     *3960)
      write(6,'(//a,a)') 'Opened EII data file ',eii_file(:lnblnk1(eii_f
     *ile))
      write(1,'(//a,a)') 'Opened EII data file ',eii_file(:lnblnk1(eii_f
     *ile))
      write(6,'(a,$)') ' eii_init: reading EII data ... '
      write(1,'(a,$)') ' eii_init: reading EII data ... '
      read(eii_unit,*,err=13970,end=13970) nskip
      DO 13981 j=1,nskip
        read(eii_unit,*,err=13970,end=13970)
13981 CONTINUE
13982 CONTINUE
      read(eii_unit,*,err=13970,end=13970) emax,nbin
      IF (( nbin .NE. 250 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Inconsistent EII data file'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF ((xsec_out .EQ. 1)) THEN
        eii_out = egs_open_file(93,0,1,'.eiixsec')
      END IF
      ii = 0
      DO 13991 j=1,100
        read(eii_unit,*,err=13970,end=13970) iZ,nsh
        IF ((xsec_out .EQ. 1 .AND. eii_nshells(iZ) .GT. 0)) THEN
          write(eii_out,*) '================================='
          write(eii_out,'(a,i3)') 'EII xsections for element Z = ',iZ
          write(eii_out,*) '================================='
        END IF
        IF (( nsh .LT. eii_nshells(iZ) )) THEN
          write(6,*) 'EII data file has data for ',nsh,' shells for elem
     *ent '
          write(1,*) 'EII data file has data for ',nsh,' shells for elem
     *ent '
          write(6,*) iZ,' but according'
          write(1,*) iZ,' but according'
          write(6,*) 'to binding energies and thresholds ',eii_nshells(i
     *    Z)
          write(1,*) 'to binding energies and thresholds ',eii_nshells(i
     *    Z)
          write(6,*) 'shells are required'
          write(1,*) 'shells are required'
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'This is a fatal error.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        DO 14001 ish=1,nsh
          read(eii_unit,*,err=13970,end=13970) fmax
          read(eii_unit,*,err=13970,end=13970) aux_array
          IF ((ish.GT.1 .AND. ish .LT. 5)) THEN
            fmax = fmax*eii_L_factor
          END IF
          IF (( ish .LE. eii_nshells(iZ) )) THEN
            IF ((xsec_out .EQ. 1)) THEN
              IF ((ish .EQ. 1)) THEN
                write(eii_out,'(a,f10.2,a)') 'K-shell sigma_max = ',fmax
     *          ,' b/atom'
              ELSE IF((ish .EQ. 2)) THEN
                write(eii_out,'(a,f9.2,a)') '=> LI-shell sigma_max = ',f
     *          max,' b/atom'
              ELSE IF((ish .EQ. 3)) THEN
                write(eii_out,'(a,f8.2,a)') '=> LII-shell sigma_max = ',
     *          fmax,' b/atom'
              ELSE IF((ish .EQ. 4)) THEN
                write(eii_out,'(a,f8.2,a)') '=> LIII-shell sigma_max = '
     *          ,fmax,' b/atom'
              ELSE
                write(eii_out,*) '=> Wrong number of shells!'
              END IF
              write(eii_out,*) '   E/keV     sigma/(b/atom)'
              write(eii_out,*) '---------------------------'
            END IF
            ii = ii+1
            eii_z(ii) = iZ
            eii_sh(ii) = ish
            eii_a(ii) = nbin
            eii_a(ii) = eii_a(ii)/log(emax/binding_energies(ish,iZ))
            eii_b(ii) = 1 - eii_a(ii)*log(binding_energies(ish,iZ))
            DO 14011 k=1,nbin
              IF (( k .GT. 1 )) THEN
                sigo = fmax*aux_array(k-1)
              ELSE
                sigo = 0
              END IF
              loge = (k - eii_b(ii))/eii_a(ii)
              iii = nbin*(ii-1)+k
              eii_xsection_a(iii) = (fmax*aux_array(k)-sigo)*eii_a(ii)
              eii_xsection_b(iii) = sigo - eii_xsection_a(iii)*loge
              IF ((xsec_out .EQ. 1)) THEN
                write(eii_out,'(f12.2,2X,10f9.2)') Exp((k+1-eii_b(ii))/e
     *          ii_a(ii))*1000.0,fmax*aux_array(k)
              END IF
14011       CONTINUE
14012       CONTINUE
          END IF
14001   CONTINUE
14002   CONTINUE
        IF (( ii .EQ. nsh_tot )) THEN
          GO TO13992
        END IF
13991 CONTINUE
13992 CONTINUE
      close(eii_unit)
      IF ((xsec_out .EQ. 1)) THEN
        close(eii_out)
      END IF
      write(6,*) ' OK '
      write(1,*) ' OK '
      write(6,*) ' '
      write(1,*) ' '
      DO 14021 imed=1,nmed
        Ec = ae(imed) - rm
        Ecc = min(Ec,ap(imed))
        sum_z=0
        sum_pz=0
        sum_a=0
        sum_wa=0
        DO 14031 iele=1,nne(imed)
          sum_z = sum_z + pz(imed,iele)*zelem(imed,iele)
          sum_pz = sum_pz + pz(imed,iele)
          sum_wa = sum_wa + rhoz(imed,iele)
          sum_a = sum_a + pz(imed,iele)*wa(imed,iele)
14031   CONTINUE
14032   CONTINUE
        con_med = rho(imed)/1.6605655/sum_a
        eii_cons(imed) = con_med
        IF (( eii_nsh(imed) .GT. 0 )) THEN
          is_monotone = .true.
          sigma_max = 0
          DO 14041 j=1,meke(imed)
            loge = (j - eke0(imed))/eke1(imed)
            e = Exp(loge)
            tau = e/rm
            beta2 = tau*(tau+2)/(tau+1)**2
            p2 = 2*rm*tau*(tau+2)
            lloge = j
            medium = imed
            dedx=ededx1(Lloge,MEDIUM)*loge+ededx0(Lloge,MEDIUM)
            IF (( e .GT. ap(medium) .OR. e .GT. 2*Ec )) THEN
              sig=esig1(Lloge,MEDIUM)*loge+esig0(Lloge,MEDIUM)
            ELSE
              sig = 0
            END IF
            IF (( e .GT. 2*Ec )) THEN
              wbrem=ebr11(Lloge,MEDIUM)*loge+ebr10(Lloge,MEDIUM)
              sigm = sig*(1-wbrem)
            ELSE
              sigm = 0
              wbrem = 1
            END IF
            sum_occn=0
            sum_sigma=0
            sum_dedx=0
            DO 14051 iele=1,nne(imed)
              iZ = int(zelem(imed,iele)+0.5)
              sum_sh = 0
              DO 14061 ish=1,eii_no(imed,iele)
                jj = eii_first(imed,iele) + ish - 1
                jjj = eii_sh(jj)
                U = binding_energies(jjj,iZ)
                Wmax = (e+U)/2
                uwm = U/Wmax
                IF (( U .LT. e .AND. U .GT. Ecc )) THEN
                  sum_sh = sum_sh + occn_numbers(jjj)
                  ss_0 = 2*(log(p2/U)-uwm**3*log(p2/Wmax)- (beta2+0.8333
     *            33)*(1-uwm**3))/3/U
                  sh_0 = ((1-uwm)*(1+uwm/(2-uwm))+U*(Wmax-U)/(e+rm)**2 -
     *             (2*tau+1)/(tau+1)**2*uwm/2*log((2-uwm)/uwm))/U
                  ss_1 = log(p2/U)-uwm**2*log(p2/Wmax)- (beta2+1)*(1-uwm
     *            **2)
                  sh_1 = log(Wmax/U/(2-uwm))+2*(Wmax-U)/(2*Wmax-U) +(Wma
     *            x**2-U**2)/(e+rm)**2/2 -(2*tau+1)/(tau+1)**2*log((2*Wm
     *            ax-U)/Wmax)
                  av_E = (ss_1 + sh_1)/(ss_0 + sh_0)
                  i = eii_a(jjj)*loge + eii_b(jjj)
                  i = (jj-1)*250 + i
                  sig_j = eii_xsection_a(i)*loge + eii_xsection_b(i)
                  sig_j = sig_j*pz(imed,iele)*con_med
                  sum_sigma = sum_sigma + sig_j
                  sum_dedx = sum_dedx + sig_j*av_E
                END IF
14061         CONTINUE
14062         CONTINUE
              sum_occn = sum_occn + sum_sh*pz(imed,iele)
14051       CONTINUE
14052       CONTINUE
            sigm = sigm + sum_sigma
            dedx = dedx - sum_dedx
            aux = Ec/e
            IF (( e .GT. 2*Ec )) THEN
              sigo = cons*sum_occn*rho(imed)/(beta2*Ec)*( (1-2*aux)*(1+a
     *        ux/(1-aux)+(tau/(tau+1))**2*aux/2)- (2*tau+1)/(tau+1)**2*a
     *        ux*log((1-aux)/aux))/sum_a
              de = cons*sum_occn*rho(imed)/beta2*( log(0.25/aux/(1-aux))
     *        +(1-2*aux)/(1-aux)+ (tau/(tau+1))**2*(1-4*aux*aux)/8- (2*t
     *        au+1)/(tau+1)**2*log(2*(1-aux)))/sum_a
              sigm = sigm - sigo
              dedx = dedx + de
            END IF
            sigma = sigm + wbrem*sig
            IF((sigma/dedx .GT. sigma_max))sigma_max = sigma/dedx
            IF (( sigma .GT. 0 )) THEN
              wbrem = wbrem*sig/sigma
            ELSE
              wbrem = 1
            END IF
            IF (( j .GT. 1 )) THEN
              ededx1(j-1,imed) = (dedx - dedx_old)*eke1(imed)
              ededx0(j-1,imed) = dedx - ededx1(j-1,imed)*loge
              esig1(j-1,imed) = (sigma - sigma_old)*eke1(imed)
              esig0(j-1,imed) = sigma - esig1(j-1,imed)*loge
              ebr11(j-1,imed) = (wbrem - wbrem_old)*eke1(imed)
              ebr10(j-1,imed) = wbrem - ebr11(j-1,imed)*loge
              IF((sigma/dedx .LT. sigma_old/dedx_old))is_monotone = .fal
     *        se.
            END IF
            dedx_old = dedx
            sigm_old = sigm
            sigma_old = sigma
            wbrem_old = wbrem
14041     CONTINUE
14042     CONTINUE
          ededx1(meke(imed),imed) = ededx1(meke(imed)-1,imed)
          ededx0(meke(imed),imed) = ededx0(meke(imed)-1,imed)
          esig1(meke(imed),imed) = esig1(meke(imed)-1,imed)
          esig0(meke(imed),imed) = esig0(meke(imed)-1,imed)
          ebr11(meke(imed),imed) = ebr11(meke(imed)-1,imed)
          ebr10(meke(imed),imed) = ebr10(meke(imed)-1,imed)
          write(6,*) 'eii_init: for medium ',imed,' adjusted sige = ', s
     *    igma_max,' monotone = ',is_monotone
          write(1,*) 'eii_init: for medium ',imed,' adjusted sige = ', s
     *    igma_max,' monotone = ',is_monotone
          sig_ismonotone(0,imed) = is_monotone
          esig_e(imed) = sigma_max
        END IF
14021 CONTINUE
14022 CONTINUE
      return
13970 write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'I/O error while reading EII data'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
13960 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(//a,a,/a,/a/)') 'Failed to open EII data file ',eii_
     *file(:lnblnk1(eii_file)), 'Make sure file exists in your $HEN_HOUS
     *E/data directory!', '****BEWARE of case sensitive file names!!!'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine eii_sample(ish,iZ,Uj)
      implicit none
      integer*4 ish,iZ
      real*8 Uj
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(3), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(40),  e
     *ii_sh(40),  eii_nshells(100),  eii_nsh(3),  eii_first(3,50),  eii_
     *no(3,50),  eii_flag
      real*8 eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_fa
     *ctor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_flag,eii_nsh
      common/egs_vr/ e_max_rr( 1001),  prob_RR,  nbr_split,  i_play_RR,
     *     i_survived_RR,
     *         n_RR_warning,                                        i_do
     *_rr( 1001)
      real*8          e_max_rr,prob_RR
      integer*4       nbr_split,i_play_RR,i_survived_RR,n_RR_warning
      integer*2     i_do_rr
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      real*8 THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5D2
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      real*8 relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      real*8 T,tau,tau1,tau12,tau2,p2,beta2,c1,c2,Wmax,xmax,fm_s,fm_h,pr
     *ob_s,prob
      real*8 r1,r2,r3,wx,wxx,aux,frej
      real*8 peie,pese1,pese2,dcosth,h1
      integer*4 iarg
      real*8 eta,cphi,sphi
      integer*4 np_save,ip,j
      real*8 xphi,xphi2,yphi,yphi2,rhophi2
      peie = e(np)
      T = peie - rm
      tau = T/rm
      tau1 = tau+1
      tau12 = tau1*tau1
      tau2 = tau*tau
      p2 = tau2 + 2*tau
      beta2 = p2/tau12
      Wmax = 0.5*(T+Uj)
      xmax = Uj/Wmax
      c1 = (Wmax/peie)**2
      c2 = (2*tau+1)/tau12
      fm_s = log(rmt2*p2/Uj) - beta2 - 0.5
      prob_s = 0.66666667*fm_s*(1+xmax+xmax*xmax)
      fm_h = 2 + c1 - c2
      IF((fm_h .LT. 1))fm_h = 1
      prob = fm_h + prob_s
14071 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        r1 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((rng_seed .GT. 128))call ranmar_get
        r2 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF((rng_seed .GT. 128))call ranmar_get
        r3 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
        IF (( r1*prob .LT. fm_h )) THEN
          wx = 1/(r2*xmax+1-r2)
          wxx = wx*xmax
          aux = wxx/(2-wxx)
          frej = (1 + aux*(aux-c2)+c1*wxx*wxx)/fm_h
        ELSE
          wx = 1/(r2*xmax**3+1-r2)**0.333333333
          frej = 1 - log(wx)/fm_s
        END IF
        IF((( r3 .LT. frej )))GO TO14072
      GO TO 14071
14072 CONTINUE
      wx = wx*Uj
      h1 = (peie + prm)/T
      pese1 = peie - wx
      e(np) = pese1
      dcosth = h1*(pese1-prm)/(pese1+prm)
      sinthe = dsqrt(1-dcosth)
      costhe = dsqrt(dcosth)
      call uphi(2,1)
      pese2 = wx - Uj + prm
      edep_local = 0
      IF (( pese2 .GT. ae(medium) )) THEN
        IF (( np+1 .GT. 40 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','eii_sample
     *', ' stack size exceeded! ',' $MAXSTACK = ',40,' np = ',np+1
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        np = np+1
        e(np) = pese2
        dcosth = h1*(pese2-prm)/(pese2+prm)
        sinthe = -dsqrt(1-dcosth)
        costhe = dsqrt(dcosth)
        iq(np) = -1
        call uphi(3,2)
        edep = 0
      ELSE
        edep = wx - Uj
        edep_local = edep
        IARG=34
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
      END IF
      call relax(Uj,ish,iZ)
      IF (( edep .GT. 0 )) THEN
        IARG=4
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          CALL AUSGAB(IARG)
        END IF
      END IF
      return
      end
      subroutine egs_scale_photon_xsection(imed,fac,which)
      implicit none
      integer*4 imed,which
      real*8 fac
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(3), GE0(3),GE1(3), GMFP0(2000,3),GMFP1(2000,
     *3),GBR10(2000,3),GBR11(2000,3),GBR20(2000,3),GBR21(2000,3), RCO0(3
     *),RCO1(3), RSCT0(100,3),RSCT1(100,3), COHE0(2000,3),COHE1(2000,3),
     *  PHOTONUC0(2000,3),PHOTONUC1(2000,3), DPMFP, MPGEM(1,3), NGR(3)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 ifirst,ilast,medium,j
      logical has_r
      real*8 gle,gmfp,gbr1,gbr2,cohfac,aux,gmfp_old,gbr1_old,gbr2_old,co
     *hfac_old
      character*8 strings(5)
      data strings/'photon','Rayleigh','Compton','pair','photo'/
      IF (( which .LT. 0 .OR. which .GT. 4 )) THEN
        return
      END IF
      IF (( imed .GT. 0 .AND. imed .LE. nmed )) THEN
        ifirst = imed
        ilast = imed
      ELSE
        ifirst = 1
        ilast = nmed
      END IF
      IF (( which .EQ. 1 )) THEN
        has_r = .false.
        DO 14081 medium=ifirst,ilast
          IF (( iraylm(medium) .EQ. 1 )) THEN
            has_r = .true.
          END IF
14081   CONTINUE
14082   CONTINUE
        IF((.NOT.has_r))return
      END IF
      write(6,*) ' '
      write(1,*) ' '
      DO 14091 medium=ifirst,ilast
        write(6,'(a,a,a,i3,a,f9.5)') 'Scaling ',strings(which+1),' x-sec
     *tion data for medium', medium,' with ',fac
        write(1,'(a,a,a,i3,a,f9.5)') 'Scaling ',strings(which+1),' x-sec
     *tion data for medium', medium,' with ',fac
        DO 14101 j=1,mge(medium)
          gle = (j - ge0(medium))/ge1(medium)
          gmfp = gmfp0(j,medium) + gmfp1(j,medium)*gle
          gbr1 = gbr10(j,medium) + gbr11(j,medium)*gle
          gbr2 = gbr20(j,medium) + gbr21(j,medium)*gle
          IF (( iraylm(medium) .EQ. 1 )) THEN
            cohfac = cohe0(j,medium) + cohe1(j,medium)*gle
          ELSE
            cohfac = 1
          END IF
          IF (( which .EQ. 0 )) THEN
            gmfp = gmfp/fac
          ELSE IF(( which .EQ. 1 )) THEN
            cohfac = cohfac/(fac*(1-cohfac)+cohfac)
          ELSE
            IF (( which .EQ. 2 )) THEN
              aux = fac*(gbr2-gbr1) + gbr1 + 1 - gbr2
              gbr2 = (gbr1 + fac*(gbr2-gbr1))/aux
              gbr1 = gbr1/aux
            ELSE IF(( which .EQ. 3 )) THEN
              aux = fac*gbr1 + 1 - gbr1
              gbr2 = (fac*gbr1 + gbr2-gbr1)/aux
              gbr1 = fac*gbr1/aux
            ELSE
              aux = gbr2 + fac*(1-gbr2)
              gbr1 = gbr1/aux
              gbr2 = gbr2/aux
            END IF
            gmfp = gmfp/aux
            cohfac = cohfac*aux/(aux*cohfac + 1 - cohfac)
          END IF
          IF (( j .GT. 1 )) THEN
            gmfp1(j-1,medium) = (gmfp - gmfp_old)*ge1(medium)
            gmfp0(j-1,medium) = gmfp - gmfp1(j-1,medium)*gle
            gbr11(j-1,medium) = (gbr1 - gbr1_old)*ge1(medium)
            gbr10(j-1,medium) = gbr1 - gbr11(j-1,medium)*gle
            gbr21(j-1,medium) = (gbr2 - gbr2_old)*ge1(medium)
            gbr20(j-1,medium) = gbr2 - gbr21(j-1,medium)*gle
            cohe1(j-1,medium) = (cohfac - cohfac_old)*ge1(medium)
            cohe0(j-1,medium) = cohfac - cohe1(j-1,medium)*gle
          END IF
          gmfp_old = gmfp
          gbr1_old = gbr1
          gbr2_old = gbr2
          cohfac_old = cohfac
14101   CONTINUE
14102   CONTINUE
        gmfp1(mge(medium),medium) = gmfp1(mge(medium)-1,medium)
        gmfp0(mge(medium),medium) = gmfp0(mge(medium)-1,medium)
        gbr11(mge(medium),medium) = gbr11(mge(medium)-1,medium)
        gbr10(mge(medium),medium) = gbr10(mge(medium)-1,medium)
        gbr21(mge(medium),medium) = gbr21(mge(medium)-1,medium)
        gbr20(mge(medium),medium) = gbr20(mge(medium)-1,medium)
        cohe1(mge(medium),medium) = cohe1(mge(medium)-1,medium)
        cohe0(mge(medium),medium) = cohe0(mge(medium)-1,medium)
14091 CONTINUE
14092 CONTINUE
      return
      end
      subroutine egs_init_user_photon(prefix,comp_prefix,photonuc_prefix
     *,out)
      implicit none
      character*(*) prefix, comp_prefix,  photonuc_prefix
      integer*4 out
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100), IEDGF
     *L( 1001),IPHTER( 1001)
      real*8 binding_energies,  interaction_prob,    relaxation_prob,  e
     *dge_energies,  edge_a,edge_b,edge_c,edge_d
      integer*2 IEDGFL,  IPHTER
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(3), GE0(3),GE1(3), GMFP0(2000,3),GMFP1(2000,
     *3),GBR10(2000,3),GBR11(2000,3),GBR20(2000,3),GBR21(2000,3), RCO0(3
     *),RCO1(3), RSCT0(100,3),RSCT1(100,3), COHE0(2000,3),COHE1(2000,3),
     *  PHOTONUC0(2000,3),PHOTONUC1(2000,3), DPMFP, MPGEM(1,3), NGR(3)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/compton_data/ iz_array(1538),  be_array(1538),  Jo_array(15
     *38),  erfJo_array(1538),   ne_array(1538),  shn_array(1538),
     *shell_array(200,3), eno_array(200,3), eno_atbin_array(200,3), n_sh
     *ell(3), radc_flag,  ibcmp( 1001)
      integer*4 iz_array,ne_array,shn_array,eno_atbin_array, shell_array
     *,n_shell,radc_flag
      real*8 be_array,Jo_array,erfJo_array,eno_array
      integer*2 ibcmp
      common/x_options/eadl_relax,  mcdf_pe_xsections
      logical eadl_relax, mcdf_pe_xsections
      integer*4 lnblnk1,egs_get_unit,medium, photo_unit,pair_unit,raylei
     *gh_unit,triplet_unit, ounit,egs_open_file,compton_unit,  photonuc_
     *unit
      integer*4 nge,sorted(50),i,j,k,iz,iz_old,ndat
      real*8 z_sorted(50),pz_sorted(50)
      real*8 sig_photo(2000),sig_pair(2000),sig_triplet(2000), sig_rayle
     *igh(2000),sig_compton(2000)
      real*8 sigma,cohe,gmfp,gbr1,gbr2,sig_KN,gle,e,sig_p
      real*8 cohe_old,gmfp_old,gbr1_old,gbr2_old,  sig_photonuc(2000), p
     *hotonuc, photonuc_old
      real*8 etmp(2000),ftmp(2000)
      real*8 sumZ,sumA,con1,con2,egs_KN_sigma0
      real*8 bc_emin,bc_emax,bc_dle,bc_data(183),bc_tmp(183),bcf,aj
      integer*4 bc_ne
      logical input_compton_data,  input_photonuc_data
      character data_dir*128,photo_file*140,pair_file*140,rayleigh_file*
     *144, triplet_file*142,tmp_string*144,compton_file*144,  photonuc_f
     *ile*144
      write(6,'(/a$)') '(Re)-initializing photon cross sections'
      write(1,'(/a$)') '(Re)-initializing photon cross sections'
      write(6,'(a,a/)') ' with files from the series: ', prefix(:lnblnk1
     *(prefix))
      write(1,'(a,a/)') ' with files from the series: ', prefix(:lnblnk1
     *(prefix))
      write(6,'(a,a)') ' Compton cross sections: ',comp_prefix(:lnblnk1(
     *comp_prefix))
      write(1,'(a,a)') ' Compton cross sections: ',comp_prefix(:lnblnk1(
     *comp_prefix))
      IF ((iphotonuc .EQ. 1)) THEN
        write(6,'(a,a)') ' Photonuclear cross sections: ', photonuc_pref
     *  ix(:lnblnk1(photonuc_prefix))
        write(1,'(a,a)') ' Photonuclear cross sections: ', photonuc_pref
     *  ix(:lnblnk1(photonuc_prefix))
        input_photonuc_data = .false.
        IF ((lnblnk1(photonuc_prefix) .GT. 0 .AND. photonuc_prefix(1:7)
     *  .NE. 'default')) THEN
          input_photonuc_data = .true.
        END IF
      END IF
      input_compton_data = .false.
      IF (( ibcmp(1) .GT. 1 .AND. lnblnk1(comp_prefix) .GT. 0 )) THEN
        IF((comp_prefix(1:7) .NE. 'default'))input_compton_data = .true.
      END IF
      data_dir = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      photo_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(prefi
     *x)) // '_photo.data'
      pair_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(prefix
     *)) // '_pair.data'
      triplet_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(pre
     *fix)) // '_triplet.data'
      rayleigh_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(pr
     *efix)) // '_rayleigh.data'
      IF (( input_compton_data )) THEN
        compton_file = data_dir(:lnblnk1(data_dir)) // comp_prefix(:lnbl
     *  nk1(comp_prefix)) // '_compton.data'
      ELSE
        compton_file = data_dir(:lnblnk1(data_dir)) // 'compton_sigma.da
     *ta'
      END IF
      write(6,'(a,a)') ' Using Compton cross sections from ', compton_fi
     *le(:lnblnk1(compton_file))
      write(1,'(a,a)') ' Using Compton cross sections from ', compton_fi
     *le(:lnblnk1(compton_file))
      IF ((iphotonuc .EQ. 1)) THEN
        IF (( input_photonuc_data )) THEN
          photonuc_file = data_dir(:lnblnk1(data_dir)) // photonuc_prefi
     *    x(:lnblnk1(photonuc_prefix)) // '_photonuc.data'
        ELSE
          photonuc_file = data_dir(:lnblnk1(data_dir)) // 'iaea_photonuc
     *.data'
        END IF
        write(6,'(a,a)') ' Using photonuclear cross sections from ', pho
     *  tonuc_file(:lnblnk1(photonuc_file))
        write(1,'(a,a)') ' Using photonuclear cross sections from ', pho
     *  tonuc_file(:lnblnk1(photonuc_file))
      END IF
      photo_unit = 83
      photo_unit = egs_get_unit(photo_unit)
      IF (( photo_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = photo_file
      open(photo_unit,file=photo_file,status='old',err=14110)
      pair_unit = 84
      pair_unit = egs_get_unit(pair_unit)
      IF (( pair_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = pair_file
      open(pair_unit,file=pair_file,status='old',err=14110)
      triplet_unit = 85
      triplet_unit = egs_get_unit(triplet_unit)
      IF (( triplet_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = triplet_file
      open(triplet_unit,file=triplet_file,status='old',err=14110)
      rayleigh_unit = 86
      rayleigh_unit = egs_get_unit(rayleigh_unit)
      IF (( rayleigh_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = rayleigh_file
      open(rayleigh_unit,file=rayleigh_file,status='old',err=14110)
      IF (( ibcmp(1) .GT. 1 )) THEN
        compton_unit = 88
        compton_unit = egs_get_unit(compton_unit)
        IF (( compton_unit .LT. 1 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'egs_init_user_photon: failed to get a free For
     *tran I/O unit'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        tmp_string = compton_file
        open(compton_unit,file=compton_file,status='old',err=14110)
      END IF
      IF (( iphotonuc .EQ. 1 )) THEN
        photonuc_unit = 89
        photonuc_unit = egs_get_unit(photonuc_unit)
        IF (( photonuc_unit .LT. 1 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'egs_init_user_photon: failed to get a free For
     *tran I/O unit'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        tmp_string = photonuc_file
        open(photonuc_unit,file=photonuc_file,status='old',err=14110)
      END IF
      IF (( out .EQ. 1 )) THEN
        ounit = egs_open_file(87,0,1,'.xsections')
        write(ounit,'(/a,a,a)') 'Photon cross sections initialized from
     *', prefix(:lnblnk1(prefix)),' data files'
        write(ounit,'(a,/)') '==========================================
     *=================================='
        write(ounit,'(a,/)') 'Grid energies and cross sections are outpu
     *t'
        IF ((iphotonuc .EQ. 1)) THEN
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a)') 'Energy','
     * GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ', ' GMFP(cm) '
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a/)') '(MeV)','
     *no Rayleigh','(fraction)','(fraction)','with Rayleigh', 'w/ Ray +
     *photnuc'
        ELSE
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a)') 'Energy',' GMFP(
     *cm) ',' Pair ','Compton',' GMFP(cm) '
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a/)') '(MeV)','no Ray
     *leigh','(fraction)','(fraction)','with Rayleigh'
        END IF
      END IF
      DO 14121 iz=1,100
        read(photo_unit,*) ndat
        read(photo_unit,*) (etmp(k),ftmp(k),k=1,ndat)
        k = 0
        DO 14131 j=ndat,2,-1
          IF (( etmp(j)-etmp(j-1) .LT. 1e-5 )) THEN
            k = k+1
            IF (( k .LE. 30 )) THEN
              binding_energies(k,iz) = exp(etmp(j))
            ELSE
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,'(i3,a,i3,//a)') k,' binding energies read exc
     *eeding array size of', 30,'Increase $MXSHXSEC in egsnrc.macros!'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            IF((.NOT.eadl_relax .AND. k .GE. 4))GO TO14132
          END IF
14131   CONTINUE
14132   CONTINUE
14121 CONTINUE
14122 CONTINUE
      IF ((mcdf_pe_xsections)) THEN
        call egs_read_shellwise_pe()
      END IF
      DO 14141 medium=1,nmed
        mge(medium) = 2000
        nge = 2000
        ge1(medium) = nge-1
        ge1(medium) = ge1(medium)/log(up(medium)/ap(medium))
        ge0(medium) = 1 - ge1(medium)*log(ap(medium))
        write(6,'(a,i3,a,$)') ' Working on medium ',medium,' ... '
        write(1,'(a,i3,a,$)') ' Working on medium ',medium,' ... '
        IF (( out .EQ. 1 )) THEN
          write(ounit,'(/,2x,a,i3,a,24a1/)') 'Medium ',medium,': ', (med
     *    ia(k,medium),k=1,24)
        END IF
        sumZ=0
        sumA=0
        DO 14151 i=1,nne(medium)
          z_sorted(i) = zelem(medium,i)
          sumZ = sumZ + pz(medium,i)*zelem(medium,i)
          sumA = sumA + pz(medium,i)*wa(medium,i)
14151   CONTINUE
14152   CONTINUE
        con1 = sumZ*rho(medium)/(sumA*1.6605655)
        con2 = rho(medium)/(sumA*1.6605655)
        call egs_heap_sort(nne(medium),z_sorted,sorted)
        DO 14161 i=1,nne(medium)
          pz_sorted(i) = pz(medium,sorted(i))
14161   CONTINUE
14162   CONTINUE
        IF ((mcdf_pe_xsections)) THEN
          call egsi_get_shell_data(medium,nge,nne(medium),z_sorted,pz_so
     *    rted, ge1(medium),ge0(medium),sig_photo)
        ELSE
          call egsi_get_data(0,photo_unit,nge,nne(medium),z_sorted,pz_so
     *    rted, ge1(medium),ge0(medium),sig_photo)
        END IF
        call egsi_get_data(0,rayleigh_unit,nge,nne(medium),z_sorted,pz_s
     *  orted, ge1(medium),ge0(medium),sig_rayleigh)
        call egsi_get_data(1,pair_unit,nge,nne(medium),z_sorted,pz_sorte
     *  d, ge1(medium),ge0(medium),sig_pair)
        call egsi_get_data(2,triplet_unit,nge,nne(medium),z_sorted,pz_so
     *  rted, ge1(medium),ge0(medium),sig_triplet)
        IF (( iphotonuc .EQ. 1 )) THEN
          call egsi_get_data(3,photonuc_unit,nge,nne(medium),z_sorted,pz
     *    _sorted, ge1(medium),ge0(medium),sig_photonuc)
        END IF
        IF (( ibcmp(1) .GT. 1 )) THEN
          IF (( input_compton_data )) THEN
            call egsi_get_data(0,compton_unit,nge,nne(medium), z_sorted,
     *      pz_sorted,ge1(medium),ge0(medium), sig_compton)
          ELSE
            rewind(compton_unit)
            read(compton_unit,*) bc_emin,bc_emax,bc_ne
            IF (( bc_ne .GT. 183 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'Number of input Compton data exceeds array
     * size'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            bc_dle = log(bc_emax/bc_emin)/(bc_ne-1)
            DO 14171 j=1,bc_ne
              bc_data(j) = 0
14171       CONTINUE
14172       CONTINUE
            iz_old = 1
            DO 14181 i=1,nne(medium)
              iz = int(z_sorted(i)+0.5)
              DO 14191 j=iz_old,iz
                read(compton_unit,*) (bc_tmp(k),k=1,bc_ne)
14191         CONTINUE
14192         CONTINUE
              DO 14201 j=1,bc_ne
                bc_data(j)=bc_data(j)+pz_sorted(i)*z_sorted(i)*bc_tmp(j)
14201         CONTINUE
14202         CONTINUE
              iz_old = iz+1
14181       CONTINUE
14182       CONTINUE
            DO 14211 j=1,bc_ne
              bc_data(j)=log(bc_data(j)/sumZ)
14211       CONTINUE
14212       CONTINUE
          END IF
        END IF
        call egs_init_rayleigh(medium,sig_rayleigh)
        DO 14221 i=1,nge
          gle = (i - ge0(medium))/ge1(medium)
          e = exp(gle)
          sig_KN = sumZ*egs_KN_sigma0(e)
          IF (( ibcmp(1) .GT. 1 )) THEN
            IF (( input_compton_data )) THEN
              sig_KN = sig_compton(i)
            ELSE
              IF (( e .LE. bc_emin )) THEN
                bcf = exp(bc_data(1))
              ELSE IF(( e .LT. bc_emax )) THEN
                aj = 1 + log(e/bc_emin)/bc_dle
                j = int(aj)
                aj = aj - j
                bcf = exp(bc_data(j)*(1-aj) + bc_data(j+1)*aj)
              ELSE
                bcf = 1
              END IF
              sig_KN = sig_KN*bcf
            END IF
          END IF
          sig_p = sig_pair(i) + sig_triplet(i)
          sigma = sig_KN + sig_p + sig_photo(i)
          gmfp = 1/(sigma*con2)
          gbr1 = sig_p/sigma
          gbr2 = gbr1 + sig_KN/sigma
          cohe = sigma/(sig_rayleigh(i) + sigma)
          photonuc = sigma/(sig_photonuc(i) + sigma)
          IF (( out .EQ. 1 )) THEN
            IF ((iphotonucm(medium) .EQ. 1)) THEN
              write(ounit,'(6(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1, gmfp*co
     *        he,gmfp*cohe*photonuc
            ELSE
              write(ounit,'(5(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,gmfp*coh
     *        e
            END IF
          END IF
          IF (( i .GT. 1 )) THEN
            gmfp1(i-1,medium) = (gmfp - gmfp_old)*ge1(medium)
            gmfp0(i-1,medium) = gmfp - gmfp1(i-1,medium)*gle
            gbr11(i-1,medium) = (gbr1 - gbr1_old)*ge1(medium)
            gbr10(i-1,medium) = gbr1 - gbr11(i-1,medium)*gle
            gbr21(i-1,medium) = (gbr2 - gbr2_old)*ge1(medium)
            gbr20(i-1,medium) = gbr2 - gbr21(i-1,medium)*gle
            cohe1(i-1,medium) = (cohe - cohe_old)*ge1(medium)
            cohe0(i-1,medium) = cohe - cohe1(i-1,medium)*gle
            photonuc1(i-1,medium) = (photonuc - photonuc_old)*ge1(medium
     *      )
            photonuc0(i-1,medium) = photonuc - photonuc1(i-1,medium)*gle
          END IF
          gmfp_old = gmfp
          gbr1_old = gbr1
          gbr2_old = gbr2
          cohe_old = cohe
          photonuc_old = photonuc
14221   CONTINUE
14222   CONTINUE
        gmfp1(nge,medium) = gmfp1(nge-1,medium)
        gmfp0(nge,medium) = gmfp - gmfp1(nge,medium)*gle
        gbr11(nge,medium) = gbr11(nge-1,medium)
        gbr10(nge,medium) = gbr1 - gbr11(nge,medium)*gle
        gbr21(nge,medium) = gbr21(nge-1,medium)
        gbr20(nge,medium) = gbr2 - gbr21(nge,medium)*gle
        cohe1(nge,medium) = cohe1(nge-1,medium)
        cohe0(nge,medium) = cohe - cohe1(nge,medium)*gle
        photonuc1(nge,medium) = photonuc1(nge-1,medium)
        photonuc0(nge,medium) = photonuc - photonuc1(nge,medium)*gle
        write(6,'(a)') 'OK'
        write(1,'(a)') 'OK'
14141 CONTINUE
14142 CONTINUE
      close(photo_unit)
      close(pair_unit)
      close(triplet_unit)
      close(rayleigh_unit)
      IF (( iphotonuc .EQ. 1 )) THEN
        close(photonuc_unit)
      END IF
      IF (( ibcmp(1) .GT. 1 )) THEN
        close(compton_unit)
      END IF
      IF (( out .EQ. 1 )) THEN
        close(ounit)
      END IF
      return
14110 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(//a,a)') 'Failed to open data file ',tmp_string(:lnb
     *lnk1(tmp_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_init_rayleigh(medium,sig_rayleigh)
      implicit none
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PHOTIN/ EBINDA(3), GE0(3),GE1(3), GMFP0(2000,3),GMFP1(2000,
     *3),GBR10(2000,3),GBR11(2000,3),GBR20(2000,3),GBR21(2000,3), RCO0(3
     *),RCO1(3), RSCT0(100,3),RSCT1(100,3), COHE0(2000,3),COHE1(2000,3),
     *  PHOTONUC0(2000,3),PHOTONUC1(2000,3), DPMFP, MPGEM(1,3), NGR(3)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/rayleigh_inputs/iray_ff_media(3),iray_ff_file(3)
      character*24 iray_ff_media
      character*128 iray_ff_file
      COMMON/rayleigh_sampling/xgrid(100,3), fcum(100,3), b_array(100,3)
     *, c_array(100,3), i_array(100,3), pmax0(2000,3),pmax1(2000,3)
      real*8 xgrid, fcum, b_array, c_array,pmax0, pmax1
      integer*4 i_array
      real*8 xval(100),aff(100,100),ff(100,3)
      real*8 xsc, fsc
      real*8 sig_rayleigh(2000), pe_array(2000,3)
      real*8 e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA
      real*8 totRayleigh2,pzmin
      real*8 emin, emax
      integer*4 i,j,k,ff_unit, egs_get_unit, ne
      integer*4 lnblnk1, EOF, nff, medium, ncustom
      character dummy*24, afac_file*128, ff_file*128
      IF ((iraylm(medium).EQ.0)) THEN
        return
      END IF
      ncustom=0
      write(dummy,'(24a1)')(media(j,medium),j=1,24)
      ff_file=' '
      DO 14231 i=1,3
        IF ((lnblnk1(iray_ff_file(i)).NE.0)) THEN
          ncustom = ncustom + 1
        END IF
14231 CONTINUE
14232 CONTINUE
      DO 14241 i=1,ncustom
        IF ((dummy(:lnblnk1(dummy)) .EQ. iray_ff_media(i))) THEN
          ff_file = iray_ff_file(i)
        END IF
14241 CONTINUE
14242 CONTINUE
      ff_unit = egs_get_unit(0)
      IF (( ff_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_rayleigh: failed to get a free Fortran
     *I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( lnblnk1(ff_file) .GT. 0)) THEN
        open(ff_unit,file=ff_file(:lnblnk1(ff_file)), status='old',err=1
     *  4250)
        GOTO 14260
14250   write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(2a)') 'egs_init_rayleigh: failed to open custom ff
     * file ', ff_file(:lnblnk1(ff_file))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
14260   write(6,'(/2a)') 'Opened custom ff file ',ff_file(:lnblnk1(ff_fi
     *  le))
        write(1,'(/2a)') 'Opened custom ff file ',ff_file(:lnblnk1(ff_fi
     *  le))
        j = 0
14271   CONTINUE
          j = j + 1
          read(ff_unit,*,IOSTAT=EOF) xsc, fsc
          IF((EOF .LT. 0))GO TO14272
          IF ((j .LE. 100)) THEN
            xgrid(j,medium)=xsc
            ff(j,medium)=fsc
          END IF
        GO TO 14271
14272   CONTINUE
        nff = j-1
        IF ((nff .GT. 100)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,/,a,i5,a,i5,/,a)') 'subroutine egs_init_raylei
     *gh: form factors size too small!!', '$XRAYFF =  ', 100,', and need
     * to be ',nff, ' and try again!!!'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF((xgrid(1,medium) .LT. 1e-6))xgrid(1,medium) = 1e-4
        write(*,*) '\n  -> ', nff, ' values of mol. ff read!'
        sumA = 0.0
        DO 14281 j=1,nne(medium)
          sumA=sumA+PZ(medium,j)*WA(medium,j)
14281   CONTINUE
14282   CONTINUE
        DO 14291 j=1,MGE(medium)
          gle=(j-GE0(medium))/GE1(medium)
          e=exp(gle)
          sig_rayleigh(j)=egs_rayleigh_sigma(medium,e,nff, xgrid(1,mediu
     *    m),ff(1,medium))*sumA
14291   CONTINUE
14292   CONTINUE
      ELSE
        DO 14301 i=1,len(afac_file)
          afac_file(i:i) = ' '
14301   CONTINUE
14302   CONTINUE
        afac_file = hen_house(:lnblnk1(hen_house))//'pegs4'//'/'//'pgs4f
     *orm.dat'
        open(ff_unit,file=afac_file(:lnblnk1(afac_file)), status='old',e
     *  rr=14310)
        GOTO 14320
14310   write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(2a)') 'egs_init_rayleigh: failed to open atomic ff
     * file', afac_file(:lnblnk1(afac_file))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
14320   read(ff_unit,*) xval, aff
        DO 14331 i=1,100
          ff(i,medium) = 0.0
          xgrid(i,medium)=xval(i)
          DO 14341 j=1,nne(medium)
            ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(mediu
     *      m,j)))**2
14341     CONTINUE
14342     CONTINUE
          ff(i,medium) = sqrt(ff(i,medium))
14331   CONTINUE
14332   CONTINUE
        nff = 100
        IF((xgrid(1,medium) .LT. 1e-6))xgrid(1,medium) = 1e-4
        write(6,'(/a,i4,a)') '  -> ', nff, ' atomic ff values computed!'
        write(1,'(/a,i4,a)') '  -> ', nff, ' atomic ff values computed!'
      END IF
      close(ff_unit)
      emin = exp((1 - ge0(medium))/ge1(medium))
      emax = exp((mge(medium) - ge0(medium))/ge1(medium))
      call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium), mge(m
     *edium),emin,emax, pe_array(1,medium),100, fcum(1,medium),i_array(1
     *,medium), b_array(1,medium),c_array(1,medium))
      ne=MGE(medium)
      dle=log(up(medium)/ap(medium))/(ne-1)
      dlei=1/dle
      DO 14351 i=1,ne-1
        gle = (i - ge0(medium))/ge1(medium)
        pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(me
     *  dium)
        pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle
14351 CONTINUE
14352 CONTINUE
      pmax0(ne,medium)=pmax0(ne-1,medium)
      pmax1(ne,medium)=pmax1(ne-1,medium)
      return
      end
      subroutine egs_init_rayleigh_sampling(medium)
      implicit none
      COMMON/THRESH/RMT2,RMSQ, AP(3),AE(3),UP(3),UE(3),TE(3),THMOLL(3)
      real*8 RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/MISC/  DUNIT,KMPI,KMPO,RHOR( 1001),MED( 1001),IRAYLR( 1001)
     *,IPHOTONUCR( 1001)
      real*8 DUNIT,  RHOR
      integer*4 KMPI,  KMPO
      integer*2 MED,  IRAYLR,  IPHOTONUCR
      COMMON/PHOTIN/ EBINDA(3), GE0(3),GE1(3), GMFP0(2000,3),GMFP1(2000,
     *3),GBR10(2000,3),GBR11(2000,3),GBR20(2000,3),GBR21(2000,3), RCO0(3
     *),RCO1(3), RSCT0(100,3),RSCT1(100,3), COHE0(2000,3),COHE1(2000,3),
     *  PHOTONUC0(2000,3),PHOTONUC1(2000,3), DPMFP, MPGEM(1,3), NGR(3)
      real*8 EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR21,
     *  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,  D
     *PMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/rayleigh_inputs/iray_ff_media(3),iray_ff_file(3)
      character*24 iray_ff_media
      character*128 iray_ff_file
      COMMON/rayleigh_sampling/xgrid(100,3), fcum(100,3), b_array(100,3)
     *, c_array(100,3), i_array(100,3), pmax0(2000,3),pmax1(2000,3)
      real*8 xgrid, fcum, b_array, c_array,pmax0, pmax1
      integer*4 i_array
      real*8 xval(100),aff(100,100),ff(100,3)
      real*8 xsc, fsc
      real*8 sig_rayleigh(2000), pe_array(2000,3)
      real*8 e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA
      real*8 totRayleigh2,pzmin
      real*8 emin, emax
      integer*4 i,j,k,ff_unit, egs_get_unit, ne
      integer*4 lnblnk1, EOF, nff, medium, ncustom
      character dummy*24, afac_file*128, ff_file*128
      IF ((iraylm(medium).EQ.0)) THEN
        return
      END IF
      ff_unit = egs_get_unit(0)
      IF (( ff_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_rayleigh: failed to get a free Fortran
     *I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      DO 14361 i=1,len(afac_file)
        afac_file(i:i) = ' '
14361 CONTINUE
14362 CONTINUE
      afac_file = hen_house(:lnblnk1(hen_house))//'pegs4'//'/'//'pgs4for
     *m.dat'
      open(ff_unit,file=afac_file(:lnblnk1(afac_file)),status='old',err=
     *14310)
      GOTO 14320
14310 write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(2a)') 'egs_init_rayleigh_sampling: failed to open at
     *omic ff file ', afac_file(:lnblnk1(afac_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
14320 read(ff_unit,*) xval, aff
      DO 14371 i=1,100
        ff(i,medium) = 0.0
        xgrid(i,medium)=xval(i)
        DO 14381 j=1,nne(medium)
          ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,
     *    j)))**2
14381   CONTINUE
14382   CONTINUE
        ff(i,medium) = sqrt(ff(i,medium))
14371 CONTINUE
14372 CONTINUE
      nff = 100
      IF((xgrid(1,medium) .LT. 1e-6))xgrid(1,medium) = 1e-4
      write(6,'(/a,i4,a)') '  -> ', nff, ' atomic ff values computed!'
      write(1,'(/a,i4,a)') '  -> ', nff, ' atomic ff values computed!'
      close(ff_unit)
      emin = exp((1 - ge0(medium))/ge1(medium))
      emax = exp((mge(medium) - ge0(medium))/ge1(medium))
      call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium), mge(m
     *edium),emin,emax, pe_array(1,medium),100, fcum(1,medium),i_array(1
     *,medium), b_array(1,medium),c_array(1,medium))
      ne=MGE(medium)
      DO 14391 i=1,ne-1
        gle = (i - ge0(medium))/ge1(medium)
        pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(me
     *  dium)
        pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle
14391 CONTINUE
14392 CONTINUE
      pmax0(ne,medium)=pmax0(ne-1,medium)
      pmax1(ne,medium)=pmax1(ne-1,medium)
      return
      end
      real*8 function egs_rayleigh_sigma(imed,E,ndat,x,f)
      implicit none
      integer*4 i, j, k,imed, ndat
      real*8 hc2,conv,b,hc
      parameter (hc = 0.0123984768438,hc2=0.0001537222280)
      real*8 x(100), f(100), zero, E, xmax
      real*8 x1,x2,pow_x1,pow_x2,raysig,C,C2,f1,f2
      C=2.*hc2/(E*E)
      C2=C*C
      xmax=E/hc
      egs_rayleigh_sigma = 0.0
      DO 14401 i=1,ndat-1
        IF((x(i) .EQ. 0.0))x(i) = zero()
        IF((x(i+1) .EQ. 0.0))x(i+1) = zero()
        IF((f(i) .EQ. 0.0))f(i) = zero()
        IF((f(i+1) .EQ. 0.0))f(i+1) = zero()
        b = log(f(i+1)/f(i))/log(x(i+1)/x(i))
        x1=x(i)
        x2=x(i+1)
        IF ((x2 .GT. xmax)) THEN
          x2=xmax
        END IF
        pow_x1=x1**(2*b)
        pow_x2=x2**(2*b)
        raysig = pow_x2*(x2**2/(b+1)-(C*x2**4)/(b+2)+(C2*x2**6)/(2*b+6))
        raysig = raysig - pow_x1*(x1**2/(b+1)-(C*x1**4)/(b+2)+(C2*x1**6)
     *  /(2*b+6))
        raysig = raysig*f(i)*f(i)/pow_x1
        egs_rayleigh_sigma = egs_rayleigh_sigma + raysig
        IF ((x(i+1).GT.xmax)) THEN
          GO TO14402
        END IF
14401 CONTINUE
14402 CONTINUE
      egs_rayleigh_sigma = 0.49893439187842413747*C*egs_rayleigh_sigma
      return
      end
      subroutine egs_rayleigh_sampling(medium,e,gle,lgle,costhe,sinthe)
      implicit none
      real*8 e
      real*8 gle,costhe,sinthe,pmax,xv,xmax,csqthe
      real*8 rnnray1,rnnray0,hc_i,twice_hc2,dwi
      parameter(hc_i=80.65506856998,twice_hc2=0.000307444456)
      integer*4 lgle,ib,ibin,medium, trials
      common/randomm/ rng_array(128), urndm(97), crndm, cdrndm, cmrndm,
     *i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed
      integer*4 urndm, crndm, cdrndm, cmrndm, i4opt, ixx, jxx, fool_opti
     *mizer,rng_seed,rng_array
      real*4 twom24
      COMMON/rayleigh_sampling/xgrid(100,3), fcum(100,3), b_array(100,3)
     *, c_array(100,3), i_array(100,3), pmax0(2000,3),pmax1(2000,3)
      real*8 xgrid, fcum, b_array, c_array,pmax0, pmax1
      integer*4 i_array
      dwi = 100-1
      pmax=pmax1(Lgle,MEDIUM)*gle+pmax0(Lgle,MEDIUM)
      xmax = hc_i*e
14411 CONTINUE
        IF((rng_seed .GT. 128))call ranmar_get
        rnnray1 = rng_array(rng_seed)*twom24
        rng_seed = rng_seed + 1
14421   CONTINUE
          IF((rng_seed .GT. 128))call ranmar_get
          rnnray0 = rng_array(rng_seed)*twom24
          rng_seed = rng_seed + 1
          rnnray0 = rnnray0*pmax
          ibin = 1 + rnnray0*dwi
          ib = i_array(ibin,medium)
          IF (( i_array(ibin+1,medium) .GT. ib )) THEN
14431       CONTINUE
              IF((rnnray0.LT.fcum(ib+1,medium)))GO TO14432
              ib=ib+1
            GO TO 14431
14432       CONTINUE
          END IF
          rnnray0 = (rnnray0 - fcum(ib,medium))*c_array(ib,medium)
          xv = xgrid(ib,medium)*exp(log(1+rnnray0)*b_array(ib,medium))
          IF(((xv .LT. xmax)))GO TO14422
        GO TO 14421
14422   CONTINUE
        xv = xv/e
        costhe = 1 - twice_hc2*xv*xv
        csqthe=costhe*costhe
        IF((( 2*rnnray1 .LT. 1 + csqthe )))GO TO14412
      GO TO 14411
14412 CONTINUE
      sinthe=sqrt(1.0-csqthe)
      return
      end
      subroutine prepare_rayleigh_data(ndat,x,f, ne,emin,emax,pe_array,
     *ncbin,fcum,i_array, b_array,c_array)
      implicit none
      integer*4 ndat
      real*8 x(ndat),  f(ndat)
      integer*4 ne
      real*8 emin,  emax,  pe_array(ne)
      integer*4 ncbin
      real*8 fcum(ndat)
      integer*4 i_array(ncbin)
      real*8 b_array(ndat),  c_array(ndat)
      real*8 zero
      real*8 sum0,a,b,x1,x2,pow_x1,pow_x2,dle,e,xmax, anorm,anorm1,anorm
     *2,w,dw,xold,t,aux
      integer*4 i,j,k,ibin
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      write(*,'(a$)') '      preparing data for Rayleigh sampling ... '
      DO 14441 i=1,ndat
        IF((f(i) .EQ. 0.0))f(i) = zero()
14441 CONTINUE
14442 CONTINUE
      sum0=0
      fcum(1)=0
      DO 14451 i=1,ndat-1
        b = log(f(i+1)/f(i))/log(x(i+1)/x(i))
        b_array(i) = b
        x1 = x(i)
        x2 = x(i+1)
        pow_x1 = x1**(2*b)
        pow_x2 = x2**(2*b)
        sum0=sum0+f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1)
        fcum(i+1) = sum0
14451 CONTINUE
14452 CONTINUE
      dle = log(emax/emin)/(ne-1)
      i = 1
      DO 14461 j=1,ne
        e = emin*exp(dle*(j-1))
        xmax = 20.607544d0*2*e/prm
        DO 14471 k=i,ndat-1
          IF((xmax .GE. x(k) .AND. xmax .LT. x(k+1)))GO TO14472
14471   CONTINUE
14472   CONTINUE
        i = k
        b = b_array(i)
        x1 = x(i)
        x2 = xmax
        pow_x1 = x1**(2*b)
        pow_x2 = x2**(2*b)
        pe_array(j) = fcum(i) + f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((
     *  1+b)*pow_x1)
14461 CONTINUE
14462 CONTINUE
      i_array(ncbin) = i
      anorm = 1d0/sqrt(pe_array(ne))
      anorm1 = 1.005d0/pe_array(ne)
      anorm2 = 1d0/pe_array(ne)
      DO 14481 j=1,ne
        pe_array(j) = pe_array(j)*anorm1
        IF((pe_array(j) .GT. 1))pe_array(j) = 1
14481 CONTINUE
14482 CONTINUE
      DO 14491 j=1,ndat
        f(j) = f(j)*anorm
        fcum(j) = fcum(j)*anorm2
        c_array(j) = (1+b_array(j))/(x(j)*f(j))**2
14491 CONTINUE
14492 CONTINUE
      dw = 1d0/(ncbin-1)
      xold = x(1)
      ibin = 1
      b = b_array(1)
      pow_x1 = x(1)**(2*b)
      i_array(1) = 1
      DO 14501 i=2,ncbin-1
        w = dw
14511   CONTINUE
          x1 = xold
          x2 = x(ibin+1)
          t = x1*x1*x1**(2*b)
          pow_x2 = x2**(2*b)
          aux=f(ibin)*f(ibin)*(x2*x2*pow_x2-t)/((1+b)*pow_x1)
          IF (( aux .GT. w )) THEN
            xold = exp(log(t+w*(1+b)*pow_x1/f(ibin)/f(ibin))/(2+2*b))
            i_array(i) = ibin
            GO TO14512
          END IF
          w = w - aux
          xold = x2
          ibin = ibin+1
          b = b_array(ibin)
          pow_x1 = xold**(2*b)
        GO TO 14511
14512   CONTINUE
14501 CONTINUE
14502 CONTINUE
      DO 14521 j=1,ndat
        b_array(j) = 0.5/(1 + b_array(j))
14521 CONTINUE
14522 CONTINUE
      write(*,'(a /)') 'done'
      return
      end
      real*8 function egs_KN_sigma0(e)
      implicit none
      real*8 e
      real*8 con,ko,c1,c2,c3,eps1,eps2
      data con/0.1274783851/
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      ko = e/prm
      IF (( ko .LT. 0.01 )) THEN
        egs_KN_sigma0 = 8.*con/3.*(1-ko*(2-ko*(5.2-13.3*ko)))/prm
        return
      END IF
      c1 = 1./(ko*ko)
      c2 = 1. - 2*(1+ko)*c1
      c3 = (1+2*ko)*c1
      eps2 = 1
      eps1 = 1./(1+2*ko)
      egs_KN_sigma0 = (c1*(1./eps1-1./eps2)+c2*log(eps2/eps1)+eps2*(c3+0
     *.5*eps2)- eps1*(c3+0.5*eps1))/e*con
      return
      end
      real*8 function egs_KN_sigma1(e)
      implicit none
      real*8 e
      real*8 con,ko,c1,c2,c3,eps1,eps2
      data con/0.1274783851/
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      ko = e/prm
      c1 = 1./(ko*ko)
      c2 = 1. - 2*(1+ko)*c1
      c3 = (1+2*ko)*c1
      eps2 = 1
      eps1 = 1./(1+2*ko)
      egs_KN_sigma1 = c1*(1./eps1-1./eps2)
      egs_KN_sigma1 = egs_KN_sigma1 + log(eps2/eps1)*(c2 - c1) - c2*(eps
     *2-eps1)
      egs_KN_sigma1 = egs_KN_sigma1 + c3*(eps2-eps1)*(1-0.5*(eps1+eps2))
      egs_KN_sigma1 = egs_KN_sigma1 + (eps2-eps1)*(0.5*(eps1+eps2)-(eps1
     **eps1+eps2*eps2+eps1*eps2)/3)
      egs_KN_sigma1 = egs_KN_sigma1*con
      return
      end
      subroutine egsi_get_data(flag,iunit,n,ne,zsorted,pz_sorted,ge1,ge0
     *,data)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 eth
      integer*4 flag,iunit,n,ne
      real*8 ge1,ge0,zsorted(*),pz_sorted(*),data(*)
      real*8 etmp(2000),ftmp(2000)
      real*8 gle,sig,p,e
      integer*4 i,j,k,kk,iz,iz_old,ndat,iiz
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      rewind(iunit)
      iz_old = 0
      DO 14531 k=1,n
        data(k) = 0
14531 CONTINUE
14532 CONTINUE
      DO 14541 i=1,ne
        iiz = int(zsorted(i)+0.5)
        DO 14551 iz=iz_old+1,iiz
          read(iunit,*,err=14560) ndat
          IF (( ndat .GT. 2000 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'Too many input data points. Max. is ',2000
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          IF (( flag .EQ. 0 .OR. flag .EQ. 3)) THEN
            read(iunit,*,err=14560) (etmp(k),ftmp(k),k=1,ndat)
          ELSE
            read(iunit,*,err=14560) (etmp(k+1),ftmp(k+1), k=1,ndat)
            IF (( flag .EQ. 1 )) THEN
              eth = 2*rm
            ELSE
              eth = 4*rm
            END IF
            ndat = ndat + 1
            DO 14571 k=2,ndat
              ftmp(k) = ftmp(k) - 3*log(1-eth/exp(etmp(k)))
14571       CONTINUE
14572       CONTINUE
            ftmp(1) = ftmp(2)
            etmp(1) = log(eth)
          END IF
14551   CONTINUE
14552   CONTINUE
        iz_old = iiz
        DO 14581 k=1,n
          gle = (k - ge0)/ge1
          e = exp(gle)
          IF (( gle .LT. etmp(1) .OR. gle .GE. etmp(ndat) )) THEN
            IF (( flag .EQ. 0 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'Energy ',exp(gle), ' is outside the availa
     *ble data range of ', exp(etmp(1)),exp(etmp(ndat))
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            ELSE IF((flag .EQ. 1 .OR. flag .EQ. 2)) THEN
              IF (( gle .LT. etmp(1) )) THEN
                sig = 0
              ELSE
                sig = exp(ftmp(ndat))
              END IF
            ELSE
              sig = 0
            END IF
          ELSE
            DO 14591 kk=1,ndat-1
              IF((gle .GE. etmp(kk) .AND. gle .LT. etmp(kk+1)))GO TO1459
     *        2
14591       CONTINUE
14592       CONTINUE
            IF (( flag .NE. 3)) THEN
              p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk))
              sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk))
            ELSE
              p = (e - exp(etmp(kk)))/(exp(etmp(kk+1)) - exp(etmp(kk)))
              sig = p*exp(ftmp(kk+1)) + (1-p)*exp(ftmp(kk))
            END IF
          END IF
          IF(((flag .EQ. 1 .OR. flag .EQ. 2) .AND. e .GT. eth))sig = sig
     *    *(1-eth/e)**3
          data(k) = data(k) + pz_sorted(i)*sig
14581   CONTINUE
14582   CONTINUE
14541 CONTINUE
14542 CONTINUE
      return
14560 CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Error while reading user photon cross sections fro
     *m unit ', iunit
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egsi_get_shell_data(imed,n,ne,zsorted,pz_sorted,ge1,ge0
     *,data)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/MEDIA/  RLC(3),RLDU(3),RHO(3),MSGE(3),MGE(3),MSEKE(3),MEKE(
     *3),MLEKE(3),MCMFP(3),MRANGE(3),IRAYLM(3),IPHOTONUCM(3), MEDIA(24,3
     *), photon_xsections, comp_xsections, photonuc_xsections,eii_xfile,
     *IPHOTONUC,NMED
      CHARACTER*4 MEDIA
      real*8 RLC,  RLDU,  RHO,  apx, upx
      integer*4 MSGE,  MGE,  MSEKE, MEKE,  MLEKE, MCMFP, MRANGE, IRAYLM,
     *  IPHOTONUCM, IPHOTONUC, NMED
      character*16 eii_xfile
      character*16 photon_xsections
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,3),   pe_energy(500,100),  pe_zsorted(100,3), pe_be(100,16),
     * pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      real*8 pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      integer*4 n,  ne,  ndat
      real*8 ge1,ge0,zsorted(*),pz_sorted(*),data(*)
      real*8 sigma(500),sigmaMedium
      real*4 etmp(2000),ftmp(2000)
      real*4 gle,sig,p
      integer*4 i,j,k,kk,iz,zpos,imed
      DO 14601 k=1,n
        data(k) = 0
14601 CONTINUE
14602 CONTINUE
      DO 14611 k=1,ne
        sigma(k) = 0
14611 CONTINUE
14612 CONTINUE
      DO 14621 i=1,ne
        iz = int(zsorted(i)+0.5)
        zpos = pe_zpos(iz)
        ndat = pe_nge(zpos)
        DO 14631 k=1,ndat
          pe_elem_prob(k,i,imed) = pz_sorted(i)*pe_xsection(k,zpos,0)
          etmp(k) = pe_energy(k,zpos)
          ftmp(k) = log(pe_xsection(k,zpos,0))
14631   CONTINUE
14632   CONTINUE
        DO 14641 k=1,n
          gle = (k - ge0)/ge1
          IF (( gle .LT. etmp(1) .OR. gle .GE. etmp(ndat) )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'egsi_get_shell_data: Energy ',exp(gle), ' is
     * outside the available data range of ', exp(etmp(1)),exp(etmp(ndat
     *      ))
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          ELSE
            DO 14651 kk=1,ndat-1
              IF((gle .GE. etmp(kk) .AND. gle .LT. etmp(kk+1)))GO TO1465
     *        2
14651       CONTINUE
14652       CONTINUE
            p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk))
            sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk))
          END IF
          data(k) = data(k) + pz_sorted(i)*sig
14641   CONTINUE
14642   CONTINUE
14621 CONTINUE
14622 CONTINUE
      DO 14661 i=1,ne
        iz = int(zsorted(i)+0.5)
        zpos = pe_zpos(iz)
        ndat = pe_nge(zpos)
        DO 14671 k=1,ndat
          sig = sigmaMedium(imed,pe_energy(k,zpos))
          pe_elem_prob(k,i,imed) = log(pe_elem_prob(k,i,imed)/sig)
14671   CONTINUE
14672   CONTINUE
14661 CONTINUE
14662 CONTINUE
      return
      end
      real*8 function sigmaMedium(imed, logE)
      implicit none
      COMMON/BREMPR/ DL1(8,3),DL2(8,3),DL3(8,3),DL4(8,3),DL5(8,3),DL6(8,
     *3), ALPHI(2,3),BPAR(2,3),DELPOS(2,3), WA(3,50),PZ(3,50),ZELEM(3,50
     *),RHOZ(3,50), PWR2I(50), DELCM(3),ZBRANG(3),LZBRANG(3),NNE(3), IBR
     *DST,IPRDST,ibr_nist,pair_nrc,itriplet, ASYM(3,50,2)
      CHARACTER*4 ASYM
      real*8 DL1,DL2,DL3,DL4,DL5,DL6,   ALPHI,  BPAR,  DELPOS,  WA,  PZ,
     *  ZELEM,  RHOZ,  PWR2I,  DELCM,  ZBRANG,  LZBRANG
      integer*4 NNE,  IBRDST,  IPRDST,  ibr_nist,  itriplet,  pair_nrc
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,3),   pe_energy(500,100),  pe_zsorted(100,3), pe_be(100,16),
     * pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      real*8 pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      real*8 logE, slope, sigma
      integer*4 k,imed,Z,zpos,m,ibsearch
      sigmaMedium = 0
      DO 14681 k=1,nne(imed)
        Z = int( zelem(imed,k) + 0.5 )
        zpos = pe_zpos(Z)
        m = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos))
        slope = log(pe_xsection(m+1,zpos,0)/pe_xsection(m,zpos,0))
        slope = slope/(pe_energy(m+1,zpos)-pe_energy(m,zpos))
        sigma = log(pe_xsection(m,zpos,0))
        sigma = sigma + slope*(logE - pe_energy(m,zpos))
        sigma = exp(sigma)
        sigmaMedium = sigmaMedium + pz(imed,k)*sigma
14681 CONTINUE
14682 CONTINUE
      return
      end
      subroutine egs_heap_sort(n,rarray,jarray)
      implicit none
      integer*4 n,jarray(*)
      real*8 rarray(*)
      integer*4 i,ir,j,l,ira
      real*8 rra
      DO 14691 i=1,n
        jarray(i)=i
14691 CONTINUE
14692 CONTINUE
      IF((n .LT. 2))return
      l=n/2+1
      ir=n
14701 CONTINUE
        IF ((l .GT. 1)) THEN
          l=l-1
          rra=rarray(l)
          ira=l
        ELSE
          rra=rarray(ir)
          ira=jarray(ir)
          rarray(ir)=rarray(1)
          jarray(ir)=jarray(1)
          ir=ir-1
          IF ((ir .EQ. 1)) THEN
            rarray(1)=rra
            jarray(1)=ira
            return
          END IF
        END IF
        i=l
        j=l+l
14711   CONTINUE
          IF((j .GT. ir))GO TO14712
          IF ((j .LT. ir)) THEN
            IF((rarray(j) .LT. rarray(j+1)))j=j+1
          END IF
          IF ((rra .LT. rarray(j))) THEN
            rarray(i)=rarray(j)
            jarray(i)=jarray(j)
            i=j
            j=j+j
          ELSE
            j=ir+1
          END IF
        GO TO 14711
14712   CONTINUE
        rarray(i)=rra
        jarray(i)=ira
      GO TO 14701
14702 CONTINUE
      return
      end
      SUBROUTINE PHOTONUC
      implicit none
      COMMON/STACK/ E(40),X(40),Y(40),Z(40),U(40),V(40),W(40),DNEAR(40),
     *WT(40),IQ(40),IR(40),LATCH(40), LATCHI,NP,NPold
      DOUBLE PRECISION E
      real*8 X,Y,Z,  U,V,W,  DNEAR,  WT
      integer*4 IQ,  IR,  LATCH,  LATCHI, NP,  NPold
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      real*8 TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,  ENE
     *W,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_final,
     *v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD
      DOUBLE PRECISION PZERO,  PRM,  PRMT2
      real*8 RM
      integer*4 MEDIUM,  MEDOLD
      DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      npold = np
      edep = pzero
      e(np) = pzero
      wt(np) = 0
      return
      end
