#include "array_sizes.h"
#ifdef SINGLE
#define EGS_Float real*4
#else
#define EGS_Float real*8
#endif
#define EGS_Float4 real*4
C***************************************************************************
C
C   This file was automatically generated by:
C   EGSnrc-configure-linux version 1.0
C   It contains various subroutines and functions for date, time,
C   CPU time, host name, etc.
C
C   Attention: all changes will be lost the next time you run
C   EGSnrc-configure-linux.
C
C***************************************************************************

C##############################################################################
C
C  EGSnrc egs_system subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C egs_system(command)  runs a system command and returns the status
C                      command must be null-terminated
C*****************************************************************************
      integer function egs_system(command)
      character*(*) command
      integer system, istat
      istat = system(command)
      egs_system = istat
      return
      end

C##############################################################################
C
C  EGSnrc egs_isdir subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C  egs_isdir(file_name)  Returns .true., if the string file_name points to
C                        an existing directory. This version uses the lstat
C                        intrinsic and then tests for bit 14 being set in
C                        the mode element. This works on all Unix systems
C                        that I have access to (Linux, Aix, HP-UX, OSF1,
C                        Solaris, IRIX)
C
C*****************************************************************************

      logical function egs_isdir(file_name)
      implicit none
      character*(*) file_name
      integer*4 lnblnk1, res, array(13), l, lstat
      logical btest
      egs_isdir = .false.
      l = lnblnk1(file_name)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = char(0)
         ! On some systems lstat only works if the string is 0-terminated
      res = lstat(file_name,array)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = ' '
      if( res.eq.0 ) then
            ! Amost all compilers that have the lstat intrinsic return the
            ! file mode in the 3rd array element. But the PGI compiler has
            ! its own opinion on the subject and returns it in the 5th element
            ! That's why the relevant element is written as 3
            ! here, 3 gets replaced by the appropriate element
            ! by the configure script.
          if( btest(array(3),14) ) egs_isdir = .true.
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C***************************************************************************
C
C   egs_fdate(out):  print a 24 char date and time string in the form
C                         'Tue Mar 18 08:16:42 2003'
C                    to the unit specified by out without end of line
C                    i.e. the sequence
C                    write(6,'(a,$)') 'Today is '
C                    call egs_fdate(6)
C                    write(6,'(a)') '. Have a nice date'
C                    should result in something like
C                    Today is Tue Mar 18 08:16:42 2003. Have a nice date
C                    printed to unit 6.
C
C***************************************************************************

      subroutine egs_fdate(ounit)
      integer ounit
      character*24 string
      call fdate(string)
      write(ounit,'(a,$)') string
      end

C***************************************************************************
C
C   egs_get_fdate(string) assignes a 24 char date and time string to string
C                         string must be at least 24 chars long, otherwise
C                         this subroutine has no effect.
C
C***************************************************************************

      subroutine egs_get_fdate(string)
      character*(*) string
      if( len(string).ge.24 ) call fdate(string)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date_and_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


      subroutine egs_date_and_time(vnow)
      integer vnow(8)
      character dat*8,tim*10,zon*5
      call date_and_time(dat,tim,zon,vnow)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*************************************************************************
C
C egs_date(ounit): print a 11 char string in the form
C                     '18-Mar-2003'
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_date(ounit)
      integer ounit
      character string*24, dat*11
      call fdate(string)
      dat(1:2) = string(9:10)
      dat(3:3) = '-'
      dat(4:6) = string(5:7)
      dat(7:7) = '-'
      dat(8:11) = string(21:24)
      write(ounit,'(a,$)') dat
      return
      end

C##############################################################################
C
C  EGSnrc egs_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C $Id: egs_time_v1.f,v 1.1 2003/07/11 19:17:08 iwan Exp $
C*************************************************************************
C
C egs_time(ounit): print a 8 char string in the form hh:mm:ss
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_time(ounit)
      integer ounit
      character string*24
      call fdate(string)
      write(ounit,'(a,$)') string(12:19)
      return
      end

C##############################################################################
C
C  EGSnrc seconds timing subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_secnds(t0): returns seconds passed since midnight minus t0
C
C*****************************************************************************

      real function egs_secnds(t0)
      real t0,t1
      character dat*8,tim*10,zon*5
      integer values(8)
      call date_and_time(dat,tim,zon,values)
      t1 = 3600.*values(5) + 60.*values(6) + values(7) + 0.001*values(8)
      egs_secnds = t1 - t0
      return
      end

C*****************************************************************************
C
C real function egs_tot_time()
C
C   On first call returns seconds passed since 1/1/1970
C   On subsequent calls returns
C     - seconds since last call, if flag = 0
C     - seconds since first call, else
C
C*****************************************************************************

      real function egs_tot_time(flag)
      integer flag
      character dat*8,tim*10,zon*5
      integer vnow(8), vlast(8),i
      real t,egs_time_diff,t0
      data vlast/1970,1,1,5*0/,t0/-1/
      save vlast,t0
      call date_and_time(dat,tim,zon,vnow)
      t = egs_time_diff(vlast,vnow)
      do i=1,8
        vlast(i)=vnow(i)
      end do
      if( t0.lt.0 ) then
        t0 = 0
        egs_tot_time = t
      else
        t0 = t0 + t
        if(flag.eq.0) then
          egs_tot_time = t
        else
          egs_tot_time = t0
        end if
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date and time subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C****************************************************************************
C
C Returns the time difference between vstart and vend
C vstart and vend are integer arrays of dimension 8 with elements
C corresponding to the specification of the data_and_time routine, i.e.
C   array(1) = year
C   array(2) = month of the year   (1...12)
C   array(3) = day of the month    (1...31)
C   array(4) = difference in minutes from UTC
C   array(5) = hour of the day     (1...23)
C   array(6) = minute of the hour  (1...59)
C   array(7) = seconds of the minute (1...59)
C   array(8) = miliseconds of the second (1...999)
C
C Note: this implementation ignores the time difference from UTC field
C
C*****************************************************************************
      real function egs_time_diff(vstart,vend)
      integer    vstart(8),vend(8)
      real       egs_time_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_time_diff = -egs_time_diff_o(vend,vstart)
      else
        egs_time_diff = egs_time_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C day difference between the dates specified by the integer arrays vstart and
C vend. The arrays are v(1)=year, v(2)=month, v(3)=day
C
C******************************************************************************
      integer function egs_day_diff(vstart,vend)
      integer vstart(3),vend(3),egs_day_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_day_diff = -egs_day_diff_o(vend,vstart)
      else
        egs_day_diff = egs_day_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C Returns a 3-letter abreviation of the day of the week in the string day,
C given a day specified by the integer array values
C   values(1)=year, values(2)=month, values(3)=day
C
C******************************************************************************
      subroutine egs_weekday(values,day)
      character*(*) day
      integer       values(3)
      integer       days,vtmp(3),egs_day_diff,aux
      character*3   wdays(7)
      data wdays/'Mon','Tue','Wed','Thu','Fri','Sat','Sun'/
      vtmp(1) = 1970
      vtmp(2) = 1
      vtmp(3) = 1
      days = egs_day_diff(vtmp,values)
      aux = mod(days,7)
      days = 4 + aux
      if( days.gt.7 ) days = days - 7
      day(:len(day)) = ' '
      aux = min(len(day),3)
      day(:aux) = wdays(days)(:aux)
      return
      end

C*****************************************************************************
C
C Same as egs_day_diff above, but assumes that vend specifies a later date
C than vstart.
C
C*****************************************************************************
      integer function egs_day_diff_o(vstart,vend)
      integer vstart(3),vend(3)
      integer    days
      logical    next_month
      integer    tm,m,ty,y
      integer    mdays(12)
      data       mdays/31,28,31,30,31,30,31,31,30,31,30,31/
      days = 0
      ty = vstart(1)
      y  = vend(1)
      tm = vstart(2)
      m  = vend(2)
      next_month = .true.
      do while(next_month)
        if( tm.eq.m.and.ty.eq.y ) then
          next_month = .false.
        else
          days = days + mdays(tm)
          if( tm.eq.2.and.mod(ty,4).eq.0 ) days = days + 1
          tm = tm + 1
          if( tm.gt.12 ) then
            ty = ty + 1
            tm = 1
          end if
        end if
      end do
      days = days + vend(3) - vstart(3)
      egs_day_diff_o = days
      return
      end

C******************************************************************************
C
C Same as egs_time_diff above, but assumes that vend specifies a later date
C than vstart.
C
C******************************************************************************
      real function egs_time_diff_o(vstart,vend)
      integer    vstart(8),vend(8)
      integer    days,hours,minutes,secs,msecs
      integer    egs_day_diff_o
      days = egs_day_diff_o(vstart,vend)
      hours = vend(5) - vstart(5)
      minutes = vend(6) - vstart(6)
      secs = vend(7) - vstart(7)
      msecs = vend(8) - vstart(8)
      egs_time_diff_o = 3600.*(24.*days+hours)+60.*minutes+secs+
     &                  0.001*msecs
      return
      end

C******************************************************************************
C
C Returns in month a 3-letter abreviation of the month specified by mo, if
C mo is between 1 and 12, or an empty string otherwise.
C
C******************************************************************************
      subroutine egs_month(mo,month)
      integer mo
      character*(*) month
      integer iaux
      character*3   months(12)
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      iaux = min(len(month),3)
      month(:len(month)) = ' '
      if( mo.ge.1.and.mo.le.12 ) month(:iaux) = months(mo)(:iaux)
      return
      end

C******************************************************************************
C
C Converts a 3-letter abreviation of a month to its corresponding integer
C value, if the string month is a valid month, or -1 otherwise.
C
C******************************************************************************
      integer function egs_conver_month(month)
      character*3 month
      character*3 months(12)
      integer i
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      do i=1,12
        if( month.eq.months(i) ) then
          egs_conver_month = i
          return
        end if
      end do
      egs_conver_month = -1
      return
      end


C##############################################################################
C
C  EGSnrc egs_etime subroutine
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_etime(): returns CPU time consumed since the start of
C                            the program
C
C*****************************************************************************

      real function egs_etime()
      real tarray(2),etime
      egs_etime = etime(tarray)
      return
      end

C##############################################################################
C
C  EGSnrc canonical system name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the canonical system name as determined by the config.guess script
C or the Windows installation program to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_canonical_system(ounit)
      integer ounit
      write(6,'(a,$)') 'linux64'
      return
      end

C******************************************************************************
C
C Assign the canonical system name as determined by the config.guess script
C or the Windows installation program to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_canonical_system(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('linux64')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'linux64'
      else
        res(:l2) = 'linux64'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc configuration name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the configuration name as specified suring the configuration
C process to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_configuration_name(ounit)
      integer ounit
      write(6,'(a,$)') 'linux64'
      return
      end

C******************************************************************************
C
C Assign the configuration name as specified suring the configuration
C process to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_configuration_name(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('linux64')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'linux64'
      else
        res(:l2) = 'linux64'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc hostname subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C Print the host name to the unit specified by ounit without inserting
C a new line character.
C
C*****************************************************************************

      subroutine egs_print_hostnm(ounit)
      integer ounit
      character*256 string
      integer res,hostnm,lnblnk1
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      write(ounit,'(a,$)') string(:lnblnk1(string))
      return
      end

C*****************************************************************************
C
C Assign the host name to the string pointed to be hname.
C
C*****************************************************************************

      subroutine egs_get_hostnm(hname)
      character*(*) hname
      character*256 string
      integer res,hostnm,lnblnk1,l1,l2,l
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      l1 = lnblnk1(string)
      l2 = len(hname)
      hname(:l2) = ' '
      l = min(l1,l2)
      hname(:l) = string(:l)
      return
      end

      subroutine egs_init_f
      implicit none
      common/my_times/ t_elapsed, t_cpu, t_first
      EGS_Float t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      EGS_Float dum
      call egs_set_defaults
      call egs_check_arguments
      call egs_init1
      return
      end
      subroutine egs_init1
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/misc/ DUNIT,KMPI,KMPO
      EGS_Float DUNIT
      integer*4 KMPI,KMPO
      common/my_times/ t_elapsed, t_cpu, t_first
      EGS_Float t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      integer l, lnblnk1, l1, l2
      integer i
      character arg*256,tmp_string*512, tmp1_string*512, ucode_dir*512,
     *line*80, line1*80,dattim*24
      logical have_input,egs_isdir,egs_strip_extension,ex, on_egs_home,i
     *s_opened
      integer*4 mypid
      integer getpid
      integer istat, egs_system, u, pos1, pos2,egs_get_unit,itmp
      EGS_Float dum
      t_elapsed = 0
      t_cpu = egs_etime()
      dum = egs_tot_time(1)
      call egs_date_and_time(t_first)
      DO 1011 i=1,len(line)
        line(i:i) = '='
1011  CONTINUE
1012  CONTINUE
      DO 1021 i=1,len(line1)
        line1(i:i) = '.'
1021  CONTINUE
1022  CONTINUE
      IF ((.NOT.is_pegsless)) THEN
        on_egs_home = .false.
        inquire(file=pegs_file,exist=ex)
        IF (( ex )) THEN
          kmpi=egs_get_unit(kmpi)
          IF ((kmpi.LT.0)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'failed to get a free Fortran I/O unit for pe
     *gs file'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(kmpi,file=pegs_file,status='old',err=1030)
          goto 1040
        END IF
        arg = pegs_file(:lnblnk1(pegs_file))
        ex = egs_strip_extension(arg,'.pegs4dat')
        l = lnblnk1(egs_home)
        l1 = lnblnk1('pegs4data') + 2*lnblnk1('/')
        l2 = lnblnk1(arg) + lnblnk1('.pegs4dat')
        IF (( l + l1 + l2 .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'pegs4 data file name (including absolute path)
     *'
          write(i_log,'(a,i4,a)') 'is too long (',l+l1+l2,') characters'
        ELSE
          pegs_file = egs_home(:lnblnk1(egs_home)) // 'pegs4' // '/' //
     *    'data' // '/' // arg(:lnblnk1(arg)) // '.pegs4dat'
          inquire(file=pegs_file,exist=ex)
          IF (( ex )) THEN
            kmpi=egs_get_unit(kmpi)
            IF ((kmpi.LT.0)) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'failed to get a free Fortran I/O unit for
     *pegs file'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            open(kmpi,file=pegs_file,status='old',err=1030)
            on_egs_home = .true.
            goto 1040
          END IF
        END IF
        l = lnblnk1(hen_house)
        IF (( l + l1 + l2 .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'pegs4 data file name (including absolute path)
     *'
          write(i_log,'(a,i4,a)') 'is too long (',l+l1+l2,') characters'
        ELSE
          pegs_file = hen_house(:lnblnk1(hen_house)) // 'pegs4' // '/' /
     *    / 'data' // '/' // arg(:lnblnk1(arg)) // '.pegs4dat'
          inquire(file=pegs_file,exist=ex)
          IF (( ex )) THEN
            kmpi=egs_get_unit(kmpi)
            IF ((kmpi.LT.0)) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'failed to get a free Fortran I/O unit for
     *pegs file'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            open(kmpi,file=pegs_file,status='old',err=1030)
            goto 1040
          END IF
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'could not find pegs4 file named ',arg(:lnblnk1(a
     *  rg))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
1040  CONTINUE
      DO 1051 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
1051  CONTINUE
1052  CONTINUE
      tmp_string = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      i_nist_data=76
      i_incoh=78
      i_photo_relax=77
      i_photo_cs=79
      i_mscat=11
      DO 1061 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
1061  CONTINUE
1062  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'photo_cs.data'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','photo_cs.data',' does not ex
     *ist'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_photo_cs=egs_get_unit(i_photo_cs)
        IF ((i_photo_cs.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_photo_cs,file=tmp1_string,status='old',err=1070)
      ELSE
        i_photo_cs = itmp
      END IF
      DO 1081 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
1081  CONTINUE
1082  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'msnew.data'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','msnew.data',' does not exist
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_mscat=egs_get_unit(i_mscat)
        IF ((i_mscat.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_mscat,file=tmp1_string,status='old',err=1070)
      ELSE
        i_mscat = itmp
      END IF
      DO 1091 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
1091  CONTINUE
1092  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'incoh.data'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','incoh.data',' does not exist
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_incoh=egs_get_unit(i_incoh)
        IF ((i_incoh.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_incoh,file=tmp1_string,status='old',err=1070)
      ELSE
        i_incoh = itmp
      END IF
      DO 1101 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
1101  CONTINUE
1102  CONTINUE
      tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'photo_relax.dat
     *a'
      inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
      IF (( .NOT.ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'EGSnrc data file ','photo_relax.data',' does not
     * exist'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( .NOT.is_opened )) THEN
        i_photo_relax=egs_get_unit(i_photo_relax)
        IF ((i_photo_relax.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for data
     * file ', tmp1_string(:lnblnk1(tmp1_string))
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_photo_relax,file=tmp1_string,status='old',err=1070)
      ELSE
        i_photo_relax = itmp
      END IF
      DO 1111 i=1,len(ucode_dir)
        ucode_dir(i:i) = ' '
1111  CONTINUE
1112  CONTINUE
      ucode_dir = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(use
     *r_code)) // '/'
      have_input = .false.
      i_input=5
      IF (( lnblnk1(input_file) .GT. 0 )) THEN
        have_input = .true.
        l = lnblnk1(egs_home)
        l1 = lnblnk1(user_code)+1
        l2 = lnblnk1(input_file) + lnblnk1('.egsinp')
        IF (( l + l1 + l2 .GT. 1024 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'input file name (including path) is too long '
     *    ,l+l1+l2
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        ex = egs_strip_extension(input_file,'.egsinp')
        tmp_string = ucode_dir(:lnblnk1(ucode_dir)) // input_file(:lnbln
     *  k1(input_file)) // '.egsinp'
        inquire(file=tmp_string,exist=ex)
        IF (( .NOT.ex )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'Input file ',tmp_string(:lnblnk1(tmp_string)),
     *    ' does not exist.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_input,file=tmp_string,status='old',err=1120)
      END IF
      DO 1131 i=1,len(work_dir)
        work_dir(i:i) = ' '
1131  CONTINUE
1132  CONTINUE
      work_dir = 'egsrun_'
      mypid = getpid()
      call egs_itostring(work_dir,mypid,.false.)
      call egs_get_hostnm(host_name)
      IF((lnblnk1(host_name) .LT. 1))host_name = 'unknown'
      IF (( have_input )) THEN
        work_dir = work_dir(:lnblnk1(work_dir)) // '_' // input_file(:ln
     *  blnk1(input_file)) // '_' // host_name(:lnblnk1(host_name)) // '
     */'
      ELSE
        work_dir = work_dir(:lnblnk1(work_dir)) // '_noinput_' // host_n
     *  ame(:lnblnk1(host_name)) // '/'
      END IF
      DO 1141 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
1141  CONTINUE
1142  CONTINUE
      tmp_string = ucode_dir(:lnblnk1(ucode_dir)) // work_dir(:lnblnk1(w
     *ork_dir))
      DO 1151 i=1,lnblnk1(tmp_string)
        IF (( tmp_string(i:i) .EQ. '/' )) THEN
          tmp_string(i:i) = '/'
        END IF
1151  CONTINUE
1152  CONTINUE
      ex = egs_isdir(tmp_string)
      IF (( ex )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'a directory named ',tmp_string(:lnblnk1(tmp_stri
     *  ng)),' already exists?'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp1_string = 'mkdir ' // tmp_string(:lnblnk1(tmp_string))
      l = lnblnk1(tmp1_string)
      tmp1_string(l+1:l+1) = char(0)
      istat = egs_system(tmp1_string)
      IF (( istat .NE. 0 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'failed to create working directory ',tmp1_string
     *  (:lnblnk1(tmp1_string))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      call egs_open_units(.true.)
      write(i_log,'(a)') line
      write(i_log,'(a,a,t55,a,$)') 'EGSnrc version 4 for ','linux64',' '
      call egs_get_fdate(dattim)
      write(i_log,'(a,/,a)') dattim,line
      pos1 = lnblnk1('output file(s)')
      pos2 = 80 - lnblnk1('linux64')
      pos2 = min(pos2,80-lnblnk1(user_code))
      DO 1161 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
1161  CONTINUE
1162  CONTINUE
      tmp_string = pegs_file
      call egs_strip_path(tmp_string)
      ex = egs_strip_extension(tmp_string,'.pegs4dat')
      IF (( on_egs_home )) THEN
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // ' on EGS_HOME'
      ELSE
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // ' on HEN_HOUSE'
      END IF
      IF (( lnblnk1(tmp_string) .GT. lnblnk1(pegs_file) )) THEN
        DO 1171 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
1171    CONTINUE
1172    CONTINUE
        tmp_string = pegs_file
      END IF
      pos2 = min(pos2,80-lnblnk1(tmp_string))
      pos2 = min(pos2,80-lnblnk1(host_name))
      IF((have_input))pos2 = min(pos2,80-lnblnk1(input_file))
      pos2 = min(pos2,80-lnblnk1(output_file))
      IF((pos2 .LT. pos1+2))pos2 = pos1 + 2
      write(i_log,'(a,$)') 'configuration'
      l = pos2 - lnblnk1('configuration')
      write(i_log,'(a,$)') line1(:l)
      write(i_log,'(a)') 'linux64'
      write(i_log,'(a,$)') 'user code'
      l = pos2 - lnblnk1('user code')
      write(i_log,'(a,$)') line1(:l)
      write(i_log,'(a)') user_code(:lnblnk1(user_code))
      write(i_log,'(a,$)') 'pegs file'
      l = pos2 - lnblnk1('pegs file')
      write(i_log,'(a,$)') line1(:l)
      write(i_log,'(a)') tmp_string(:lnblnk1(tmp_string))
      write(i_log,'(a,$)') 'using host'
      l = pos2 - lnblnk1('using host')
      write(i_log,'(a,$)') line1(:l)
      write(i_log,'(a)') host_name(:lnblnk1(host_name))
      IF (( have_input )) THEN
        write(i_log,'(a,$)') 'input file'
        l = pos2 - lnblnk1('input file')
        write(i_log,'(a,$)') line1(:l)
        write(i_log,'(a)') input_file(:lnblnk1(input_file))
      END IF
      write(i_log,'(a,$)') 'output file(s)'
      l = pos2 - lnblnk1('output file(s)')
      write(i_log,'(a,$)') line1(:l)
      write(i_log,'(a)') output_file(:lnblnk1(output_file))
      IF (( n_parallel .GT. 0 )) THEN
        write(i_log,'(a,$)') 'number of parallel jobs'
        l = pos2 - lnblnk1('number of parallel jobs')
        write(i_log,'(a,$)') line1(:l)
        write(i_log,'(i2)') n_parallel
        write(i_log,'(a,$)') 'job number'
        l = pos2 - lnblnk1('job number')
        write(i_log,'(a,$)') line1(:l)
        write(i_log,'(i2)') i_parallel
      END IF
      write(i_log,'(a)') line
      return
1120  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open input file ',tmp_string(:lnblnk1(tm
     *p_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
1030  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open existing pegs file ',pegs_file(:lnb
     *lnk1(pegs_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
1070  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open EGSnrc data file ',tmp1_string(:lnb
     *lnk1(tmp1_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_check_arguments
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character arg*256,tmp_string*512, line1*80
      logical have_arg,egs_isdir,egs_strip_extension,ex, on_egs_home
      integer narg, iargc, i, lnblnk1, l, l2,i_help,egs_get_unit
      call egs_iargc(narg)
      IF((narg .LT. 1))return
      have_arg = .false.
      DO 1181 i=1,narg-1
        call egs_getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-H') .AND. arg(:l) .EQ. '-H' ) .OR. ( l
     *  .EQ. lnblnk1('--hen-house') .AND. arg(:l) .EQ. '--hen-house' ) )
     *  ) THEN
          have_arg = .true.
          call egs_getarg(i+1,arg)
          GO TO1182
        END IF
1181  CONTINUE
1182  CONTINUE
      IF (( have_arg )) THEN
        l = lnblnk1(arg)
        DO 1191 i=1,len(hen_house)
          hen_house(i:i) = ' '
1191    CONTINUE
1192    CONTINUE
        IF (( l .GT. 0 )) THEN
          IF (( l .GT. 254 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a,i5)') ' HEN_HOUSE argument is too long',l
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          hen_house(:l) = arg(:lnblnk1(arg))
          IF((hen_house(l:l) .NE. '/'))hen_house(l+1:l+1) = '/'
        ELSE
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a)') ' empty argument after -H'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        DO 1201 i=1,lnblnk1(hen_house)
          IF (( hen_house(i:i) .EQ. '/' )) THEN
            hen_house(i:i) = '/'
          END IF
1201    CONTINUE
1202    CONTINUE
      END IF
      IF (( .NOT.egs_isdir(hen_house) )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,'(a,a)') ' HEN_HOUSE directory ',hen_house(:lnblnk1(
     *  hen_house))
        write(i_log,'(a)') 'does not exist. Hope you know what you are d
     *oing.'
      END IF
      have_arg = .false.
      DO 1211 i=1,narg
        call egs_getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-h') .AND. arg(:l) .EQ. '-h' ) .OR. ( l
     *  .EQ. lnblnk1('--help') .AND. arg(:l) .EQ. '--help' ) )) THEN
          have_arg = .true.
          GO TO1212
        END IF
1211  CONTINUE
1212  CONTINUE
      IF (( have_arg )) THEN
        call egs_getarg(0,arg)
        call egs_strip_path(arg)
        write(i_log,'(//,a,a,a,//)') 'Usage: ',arg(:lnblnk1(arg)),' [arg
     *s] '
        tmp_string = hen_house(:lnblnk1(hen_house)) // 'pieces/help_mess
     *age'
        i_help=98
        i_help=egs_get_unit(i_help)
        IF ((i_help.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for help
     * file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_help,file=tmp_string,status='old',err=1220)
1231    CONTINUE
          read(i_help,'(a)',err=1240,end=1240) line1
          write(i_log,'(a)') line1
        GO TO 1231
1232    CONTINUE
1240    CONTINUE
        call exit(0)
1220    CONTINUE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Did not find the help_message file!'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      have_arg = .false.
      DO 1251 i=1,narg
        call egs_getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-b') .AND. arg(:l) .EQ. '-b' ) .OR. ( l
     *  .EQ. lnblnk1('--batch') .AND. arg(:l) .EQ. '--batch' ) )) THEN
          have_arg = .true.
          GO TO1252
        END IF
1251  CONTINUE
1252  CONTINUE
      IF((have_arg))is_batch = .true.
      have_arg = .false.
      DO 1261 i=1,narg-1
        call egs_getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-P') .AND. arg(:l) .EQ. '-P' ) .OR. ( l
     *  .EQ. lnblnk1('--parallel') .AND. arg(:l) .EQ. '--parallel' ) ))
     *  THEN
          have_arg = .true.
          call egs_getarg(i+1,arg)
          GO TO1262
        END IF
1261  CONTINUE
1262  CONTINUE
      IF (( have_arg )) THEN
        read(arg,*,err=1270) n_parallel
        IF((n_parallel .LT. 0))goto 1270
        goto 1280
1270    CONTINUE
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Wrong/missing parallel job number argument, -P
     *option ignored'
        n_parallel = 0
1280    CONTINUE
      END IF
      have_arg = .false.
      DO 1291 i=1,narg-1
        call egs_getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-j') .AND. arg(:l) .EQ. '-j' ) .OR. ( l
     *  .EQ. lnblnk1('--job') .AND. arg(:l) .EQ. '--job' ) )) THEN
          have_arg = .true.
          call egs_getarg(i+1,arg)
          GO TO1292
        END IF
1291  CONTINUE
1292  CONTINUE
      IF (( have_arg )) THEN
        read(arg,*,err=1300) i_parallel
        IF((i_parallel .LT. 0))goto 1300
        goto 1310
1300    CONTINUE
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Wrong/missing job argument, -j option ognored'
        i_parallel = 0
1310    CONTINUE
      END IF
      have_arg = .false.
      DO 1321 i=1,narg-1
        call egs_getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-f') .AND. arg(:l) .EQ. '-f' ) .OR. ( l
     *  .EQ. lnblnk1('--first-job') .AND. arg(:l) .EQ. '--first-job' ) )
     *  ) THEN
          have_arg = .true.
          call egs_getarg(i+1,arg)
          GO TO1322
        END IF
1321  CONTINUE
1322  CONTINUE
      IF (( have_arg )) THEN
        read(arg,*,err=1330) first_parallel
        IF((first_parallel .LT. 1))goto 1330
        goto 1340
1330    CONTINUE
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Wrong/missing first job argument, -f option ogn
     *ored'
        first_parallel = 1
1340    CONTINUE
      END IF
      IF (( n_parallel .GT. 0 .OR. i_parallel .GT. 0 )) THEN
        IF (( n_parallel*i_parallel .EQ. 0 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'You need to specify number of jobs AND job num
     *ber ', '=> will not use parallel run '
          n_parallel = 0
          i_parallel = 0
        END IF
        IF (( first_parallel .GT. i_parallel )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'i_parallel (',i_parallel, ') can not be smalle
     *r than first_parallel (',first_parallel,')'
          first_parallel = i_parallel
        END IF
      END IF
      have_arg = .false.
      DO 1351 i=1,narg-1
        call egs_getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-e') .AND. arg(:l) .EQ. '-e' ) .OR. ( l
     *  .EQ. lnblnk1('--egs-home') .AND. arg(:l) .EQ. '--egs-home' ) ))
     *  THEN
          have_arg = .true.
          call egs_getarg(i+1,arg)
          GO TO1352
        END IF
1351  CONTINUE
1352  CONTINUE
      IF (( have_arg )) THEN
        l = lnblnk1(arg)
        DO 1361 i=1,len(egs_home)
          egs_home(i:i) = ' '
1361    CONTINUE
1362    CONTINUE
        IF (( l .EQ. 0 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a)') ' empty argument after -e'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF (( l .GT. 254 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,i5)') ' EGS_HOME argument is too long ',l
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        egs_home(:l) = arg(:lnblnk1(arg))
        IF((egs_home(l:l) .NE. '/'))egs_home(l+1:l+1) = '/'
        DO 1371 i=1,lnblnk1(egs_home)
          IF (( egs_home(i:i) .EQ. '/' )) THEN
            egs_home(i:i) = '/'
          END IF
1371    CONTINUE
1372    CONTINUE
      END IF
      IF (( .NOT.egs_isdir(egs_home) )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' EGS_HOME directory ',egs_home(:lnblnk1(egs_home
     *  )),' does not exist.'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      on_egs_home = .false.
      is_pegsless=.false.
      have_arg = .false.
      DO 1381 i=1,narg-1
        call egs_getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-p') .AND. arg(:l) .EQ. '-p' ) .OR. ( l
     *  .EQ. lnblnk1('--pegs-file') .AND. arg(:l) .EQ. '--pegs-file' ) )
     *  ) THEN
          have_arg = .true.
          call egs_getarg(i+1,arg)
          GO TO1382
        END IF
1381  CONTINUE
1382  CONTINUE
      IF (( .NOT.have_arg )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) 'No pegs4 file name supplied.  Will assume you ar
     *e running    in pegs-less mode with media details specified in inp
     *ut file.'
        is_pegsless=.true.
      ELSE
        pegs_file = arg(:lnblnk1(arg))
      END IF
      call egs_get_usercode(user_code)
      have_arg = .false.
      DO 1391 i=1,narg-1
        call egs_getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-i') .AND. arg(:l) .EQ. '-i' ) .OR. ( l
     *  .EQ. lnblnk1('--input') .AND. arg(:l) .EQ. '--input' ) )) THEN
          have_arg = .true.
          call egs_getarg(i+1,arg)
          GO TO1392
        END IF
1391  CONTINUE
1392  CONTINUE
      IF (( have_arg )) THEN
        ex = egs_strip_extension(arg,'.egsinp')
        l2 = lnblnk1(arg) + lnblnk1('.egsinp')
        IF (( l2 .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'input file name is too long ',l2
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        input_file = arg(:lnblnk1(arg))
      END IF
      have_arg = .false.
      DO 1401 i=1,narg-1
        call egs_getarg(i,arg)
        l = lnblnk1(arg)
        IF (( ( l .EQ. lnblnk1('-o') .AND. arg(:l) .EQ. '-o' ) .OR. ( l
     *  .EQ. lnblnk1('--output') .AND. arg(:l) .EQ. '--output' ) )) THEN
          have_arg = .true.
          call egs_getarg(i+1,arg)
          GO TO1402
        END IF
1401  CONTINUE
1402  CONTINUE
      IF (( have_arg )) THEN
        l = lnblnk1(arg)
        IF (( l .GT. 256 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'output file name is too long ',l
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        output_file(:l) = arg(:lnblnk1(arg))
      ELSE
        IF (( lnblnk1(input_file) .GT. 0 )) THEN
          output_file(:lnblnk1(input_file)) = input_file(:lnblnk1(input_
     *    file))
        ELSE
          output_file = 'test'
        END IF
      END IF
      return
      end
      subroutine egs_open_units(flag)
      implicit none
      logical flag
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character tmp_string*1024, tmp1_string*1024, tmp2_string*1024, uco
     *de_dir*1024, input_line*100, arg*20
      integer i,lnblnk1,u,l,istart,egs_get_unit,i_iofile
      logical ex,is_open
      DO 1411 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
1411  CONTINUE
1412  CONTINUE
      DO 1421 i=1,len(ucode_dir)
        ucode_dir(i:i) = ' '
1421  CONTINUE
1422  CONTINUE
      ucode_dir = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(use
     *r_code)) // '/'
      IF (( flag )) THEN
        tmp_string = ucode_dir(:lnblnk1(ucode_dir)) // work_dir(:lnblnk1
     *  (work_dir))
      ELSE
        tmp_string = ucode_dir(:lnblnk1(ucode_dir))
      END IF
      tmp_string = tmp_string(:lnblnk1(tmp_string)) // output_file(:lnbl
     *nk1(output_file))
      IF (( i_parallel .GT. 0 )) THEN
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // '_w'
        call egs_itostring(tmp_string,i_parallel,.false.)
      END IF
      DO 1431 i=1,len(tmp1_string)
        tmp1_string(i:i) = ' '
1431  CONTINUE
1432  CONTINUE
      i_log=6
      IF (( is_batch )) THEN
        tmp1_string = tmp_string(:lnblnk1(tmp_string)) // '.egslog'
        open(i_log,file=tmp1_string,status='unknown',err=1440)
      END IF
      DO 1451 i=1,len(tmp2_string)
        tmp2_string(i:i) = ' '
1451  CONTINUE
1452  CONTINUE
      tmp2_string = ucode_dir(:lnblnk1(ucode_dir)) // user_code(:lnblnk1
     *(user_code)) // '.io'
      inquire(file=tmp2_string,exist=ex)
      n_files = 0
      IF (( ex )) THEN
        i_iofile=99
        i_iofile=egs_get_unit(i_iofile)
        IF ((i_iofile.LT.1)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for .io
     *file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_iofile,file=tmp2_string,status='old',err=1460)
1471    CONTINUE
          read(i_iofile,'(a)',err=1480,end=1480) input_line
          IF((input_line(1:1) .EQ. '#'))GO TO1471
          read(input_line,*,err=1490,end=1490) u
          istart = 1
          DO 1501 i=lnblnk1(input_line),1,-1
            IF (( input_line(i:i) .EQ. ' ' )) THEN
              istart = i+1
              GO TO1502
            END IF
1501      CONTINUE
1502      CONTINUE
          DO 1511 i=1,len(arg)
            arg(i:i) = ' '
1511      CONTINUE
1512      CONTINUE
          DO 1521 i=istart,lnblnk1(input_line)
            arg(i+1-istart:i+1-istart) = input_line(i:i)
1521      CONTINUE
1522      CONTINUE
          inquire(unit=u,opened=is_open)
          IF (( is_open )) THEN
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,'(a,i3,a,a,a,/,a,/,a,/)') 'Unit ',u,' which you
     *want to connect to a ', arg(:lnblnk1(arg)),' file ', 'is already i
     *n use. Will assume this code is being used as', 'a shared library
     *source and this file will be opened explicitly.'
          ELSE
            n_files = n_files + 1
            IF (( n_files .GT. 20 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'Too many units requested in .io.', ' Incre
     *as $mx_units and retry'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            file_units(n_files) = u
            DO 1531 i=1,len(file_extensions(n_files))
              file_extensions(n_files)(i:i) = ' '
1531        CONTINUE
1532        CONTINUE
            l = lnblnk1(arg)
            IF (( l .GT. 10 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'extension ',arg(:lnblnk1(arg)),' is longer
     * than ', 10,' chars. ', 'Increase $max_extension_length and retry
     *'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            file_extensions(n_files) = arg(:lnblnk1(arg))
            tmp1_string = tmp_string(:lnblnk1(tmp_string)) // arg(:lnbln
     *      k1(arg))
            open(u,file=tmp1_string,status='unknown')
          END IF
1490      CONTINUE
        GO TO 1471
1472    CONTINUE
1480    close(i_iofile)
      END IF
      return
1440  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open output file ',tmp1_string(:lnblnk1(
     *tmp1_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
1460  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open existing .io file',tmp2_string(:lnb
     *lnk1(tmp2_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_finish
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/my_times/ t_elapsed, t_cpu, t_first
      EGS_Float t_elapsed, t_cpu
      integer t_first(8)
      real egs_tot_time,egs_etime
      character line*80,base*512,base1*512,tmp_string*512,junk_file*128,
     *fname*512
      character dattim*24
      integer i,l,lnblnk1,istat,egs_system,n_open,unlink,i_junk,egs_get_
     *unit
      logical is_open,egs_isdir
      EGS_Float t1,t2,tt_cpu
      DO 1541 i=1,len(line)
        line(i:i) = '='
1541  CONTINUE
1542  CONTINUE
      IF (( n_parallel .EQ. 0 .OR. i_parallel .GT. 0 )) THEN
        t_elapsed = egs_tot_time(1)
        tt_cpu = egs_etime() - t_cpu
        t1 = t_elapsed
        t2 = t1/3600
        write(i_log,'(//a,/,a,/)') line,'Finished simulation'
        write(i_log,'(2x,a,t30,f9.1,a,f7.3,a)') 'Elapsed time: ',t1,' s
     *(',t2,' h)'
        t1 = tt_cpu
        t2 = t1/3600
        write(i_log,'(2x,a,t30,f9.1,a,f7.3,a)') 'CPU time:',t1,' s (',t2
     *  ,' h)'
        write(i_log,'(2x,a,t30,f10.3)') 'Ratio:',t_elapsed/tt_cpu
      END IF
      call egs_get_fdate(dattim)
      write(i_log,'(//a,t56,a,/,a)') 'End of run ',dattim,line
      n_open=0
      DO 1551 i=1,len(base)
        base(i:i) = ' '
1551  CONTINUE
1552  CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e))
      DO 1561 i=1,99
        IF (( is_batch .OR. i .NE. i_log )) THEN
          inquire(i,opened=is_open)
          IF (( is_open )) THEN
            inquire(i,name=fname)
            IF ((index(fname(:lnblnk1(fname)),base(:lnblnk1(base))).GT.0
     *      )) THEN
              close(i)
              n_open = n_open+1
            END IF
          END IF
        END IF
1561  CONTINUE
1562  CONTINUE
      IF (( lnblnk1(work_dir) .EQ. 0 )) THEN
        return
      END IF
      DO 1571 i=1,len(base)
        base(i:i) = ' '
1571  CONTINUE
1572  CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e)) // '/' // work_dir(:lnblnk1(work_dir))
      DO 1581 i=1,lnblnk1(base)
        IF (( base(i:i) .EQ. '/' )) THEN
          base(i:i) = '/'
        END IF
1581  CONTINUE
1582  CONTINUE
      IF (( egs_isdir(base) )) THEN
        DO 1591 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
1591    CONTINUE
1592    CONTINUE
        DO 1601 i=1,len(junk_file)
          junk_file(i:i) = ' '
1601    CONTINUE
1602    CONTINUE
        junk_file = work_dir(:lnblnk1(work_dir))
        l = lnblnk1(junk_file)
        junk_file(l:l) = ' '
        junk_file = junk_file(:lnblnk1(junk_file)) // '_junk'
        tmp_string = base(:lnblnk1(base)) // junk_file(:lnblnk1(junk_fil
     *  e))
        i_junk=99
        i_junk=egs_get_unit(i_junk)
        IF ((i_junk.LT.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'failed to get a free Fortran I/O unit for junk
     * file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        open(i_junk,file=tmp_string,status='unknown')
        write(i_junk,*) 'junk'
        close(i_junk)
        DO 1611 i=1,len(base1)
          base1(i:i) = ' '
1611    CONTINUE
1612    CONTINUE
        base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_c
     *  ode)) // '/' // work_dir(:lnblnk1(work_dir))
        base1 = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_
     *  code))
        DO 1621 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
1621    CONTINUE
1622    CONTINUE
        tmp_string = 'mv -f ' // base(:lnblnk1(base)) // '*  ' // base1(
     *  :lnblnk1(base1))
        l = lnblnk1(tmp_string)+1
        tmp_string(l:l) = char(0)
        istat = egs_system(tmp_string)
        IF (( istat .NE. 0 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) 'Moving files from working directory failed ?'
          write(i_log,*) '=> will not remove working directory'
        ELSE
          DO 1631 i=1,len(tmp_string)
            tmp_string(i:i) = ' '
1631      CONTINUE
1632      CONTINUE
          tmp_string = 'rm -rf ' // base(:lnblnk1(base))
          l = lnblnk1(tmp_string)+1
          tmp_string(l:l) = char(0)
          istat = egs_system(tmp_string)
          IF (( istat .NE. 0 )) THEN
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,*) 'Failed to remove working directory ', work_d
     *      ir(:lnblnk1(work_dir))
          END IF
          DO 1641 i=1,len(tmp_string)
            tmp_string(i:i) = ' '
1641      CONTINUE
1642      CONTINUE
          tmp_string = base1(:lnblnk1(base1)) // '/' // junk_file(:lnbln
     *    k1(junk_file))
          l = lnblnk1(tmp_string)+1
          tmp_string(l:l) = char(0)
          istat = unlink(tmp_string)
        END IF
      END IF
      DO 1651 i=1,len(work_dir)
        work_dir(i:i) = ' '
1651  CONTINUE
1652  CONTINUE
      return
      end
      subroutine egs_set_defaults
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common/bounds/ ecut, pcut, ecut_new, pcut_new, vacdst
      EGS_Float ecut, pcut, ecut_new, pcut_new, vacdst
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      common/compton_data/ iz_array(1538),be_array(1538), Jo_array(1538)
     *,erfJo_array(1538), ne_array(1538),shn_array(1538), shell_array(20
     *0,max_med), eno_array(200,max_med), eno_atbin_array(200,max_med),n
     *_shell(max_med)
      integer*4 iz_array,ne_array,shn_array, shell_array,eno_atbin_array
     *,n_shell
      EGS_Float be_array,Jo_array,erfJo_array,eno_array
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100)
      EGS_Float binding_energies, interaction_prob, relaxation_prob, edg
     *e_energies, edge_a,edge_b,edge_c,edge_d
      integer*4 edge_number
      COMMON/ELECIN/ esig_e(max_med),psig_e(max_med), esige_max, psige_m
     *ax, range_ep(0:1,500,max_med), E_array(500,max_med), etae_ms0(500,
     *max_med),etae_ms1(500,max_med),etap_ms0(500,max_med),etap_ms1(500,
     *max_med),q1ce_ms0(500,max_med),q1ce_ms1(500,max_med),q1cp_ms0(500,
     *max_med),q1cp_ms1(500,max_med),q2ce_ms0(500,max_med),q2ce_ms1(500,
     *max_med),q2cp_ms0(500,max_med),q2cp_ms1(500,max_med),blcce0(500,ma
     *x_med),blcce1(500,max_med), EKE0(max_med),EKE1(max_med), XR0(max_m
     *ed),TEFF0(max_med),BLCC(max_med),XCC(max_med), ESIG0(500,max_med),
     *ESIG1(500,max_med),PSIG0(500,max_med),PSIG1(500,max_med),EDEDX0(50
     *0,max_med),EDEDX1(500,max_med),PDEDX0(500,max_med),PDEDX1(500,max_
     *med),EBR10(500,max_med),EBR11(500,max_med),PBR10(500,max_med),PBR1
     *1(500,max_med),PBR20(500,max_med),PBR21(500,max_med),TMXS0(500,max
     *_med),TMXS1(500,max_med), expeke1(max_med), IUNRST(max_med),EPSTFL
     *(max_med),IAPRIM(max_med), sig_ismonotone(0:1,max_med)
      EGS_Float esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E
     *_array,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1
     *,  q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blc
     *ce0,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG
     *0,ESIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR1
     *1,  PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      common/ET_control/ smaxir,smax_new,estepe,ximax,skindepth_for_bca,
     * transport_algorithm,bca_algorithm,exact_bca
      EGS_Float smaxir,smax_new,estepe,ximax,skindepth_for_bca
      integer*4 transport_algorithm,bca_algorithm
      logical exact_bca
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/misc/ DUNIT,KMPI,KMPO
      EGS_Float DUNIT
      integer*4 KMPI,KMPO
      COMMON/PHOTIN/ EBINDA(max_med), GE0(max_med),GE1(max_med), GMFP0(2
     *000,max_med),GMFP1(2000,max_med),GBR10(2000,max_med),GBR11(2000,ma
     *x_med),GBR20(2000,max_med),GBR21(2000,max_med), RCO0(max_med),RCO1
     *(max_med), RSCT0(100,max_med),RSCT1(100,max_med), COHE0(2000,max_m
     *ed),COHE1(2000,max_med),  PHOTONUC0(2000,max_med),PHOTONUC1(2000,m
     *ax_med), DPMFP, MPGEM(1,max_med), NGR(max_med)
      EGS_Float EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR
     *21,  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,
     *  DPMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      EGS_Float SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/egs_vr/ e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_
     *RR, i_survived_RR, n_RR_warning, i_do_rr
      EGS_Float e_max_rr,e_max_rr_new,prob_RR
      integer*4 nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/spin_data/ spin_rej(max_med,0:1,0: 31,0:15,0:31), espin_min
     *,espin_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dlen
     *eri,dqq1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(max_med), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(4
     *0),  eii_sh(40),  eii_nshells(100),  eii_nsh(max_med),  eii_first(
     *max_med,50),  eii_no(max_med,50)
      EGS_Float eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L
     *_factor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_nsh
      COMMON/rayleigh_inputs/iray_ff_media(max_med),iray_ff_file(max_med
     *)
      character*24 iray_ff_media
      character*128 iray_ff_file
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      EGS_Float ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_ne
     *w,By_new,Bz_new
      logical emfield_on
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      integer i,j,lnblnk1
      CHARACTER*4 MEDIA1(24)
      EQUIVALENCE(MEDIA1(1),MEDIA(1,1))
      character fool_dec
      data MEDIA1/'N','A','I',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','
     *',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '/
      data fool_dec/'/'/
      data fool_intel_optimizer/.false./
      vacdst = 1e8
      ecut = 0
      pcut = 0
      smaxir = 1e10
      ecut_new = 0
      pcut_new = 0
      smax_new = 1e10
      rhor = 1
      rhor_new = 1
      ibcmp = 3
      iraylr = 1
      iphotonuc=0
      iedgfl = 1
      iphter = 1
      i_do_rr = 0
      e_max_rr = 0
      e_max_rr_new = 0
      eii_flag = 0
      eii_xfile = 'Off'
      eii_L_factor = 1.0
      xsec_out = 0
      photon_xsections = 'xcom'
      comp_xsections = 'default'
      eadl_relax = .true.
      mcdf_pe_xsections = .false.
      photonuc_xsections = 'default'
      ExIN=0
      EyIN=0
      EzIN=0
      BxIN=0
      ByIN=0
      BzIN=0
      EMLMTIN=0.02
      Bx=BxIN
      By=ByIN
      Bz=BzIN
      Bx_new=Bx
      By_new=By
      Bz_new=Bz
      emfield_on=.false.
      IF (( ExIN**2+EyIN**2+EzIN**2 + BxIN**2+ByIN**2+BzIN**2 .GT. 0 ))
     *THEN
        emfield_on=.true.
      END IF
      DO 1661 i=1,max_med
        iraylm(i) = 0
        DO 1671 j=1,len(iray_ff_file(i))
          iray_ff_file(i)(j:j) = ' '
1671    CONTINUE
1672    CONTINUE
        DO 1681 j=1,len(iray_ff_media(i))
          iray_ff_media(i)(j:j) = ' '
1681    CONTINUE
1682    CONTINUE
        ae(i)=0
        ap(i)=0
        ue(i)=0
        up(i)=0
        te(i)=0
        thmoll(i)=0
1661  CONTINUE
1662  CONTINUE
      DO 1691 i=1,30
        DO 1701 j=1,100
          binding_energies(i,j) = 0
1701    CONTINUE
1702    CONTINUE
1691  CONTINUE
1692  CONTINUE
      ibrdst = 1
      ibr_nist = 0
      pair_nrc = 0
      itriplet = 0
      iprdst = 1
      rhof = 1
      DO 1711 i=1,5
        iausfl(i) = 1
1711  CONTINUE
1712  CONTINUE
      DO 1721 i=6,35
        iausfl(i) = 0
1721  CONTINUE
1722  CONTINUE
      ximax = 0.5
      estepe = 0.25
      skindepth_for_bca = 3
      transport_algorithm = 0
      bca_algorithm = 0
      exact_bca = .true.
      spin_effects = .true.
      count_pII_steps = 0
      count_all_steps = 0
      radc_flag = 0
      nmed = 0
      kmpi = 12
      kmpo = 8
      dunit = 1
      rng_seed = 999999
      latchi = 0
      rmt2 = 2*rm
      rmsq = rm*rm
      pi = 4*datan(1d0)
      twopi = 2*pi
      pi5d2 = 2.5*pi
      nbr_split = 1
      i_play_RR = 0
      i_survived_RR = 0
      prob_RR = -1
      n_RR_warning = 0
      DO 1731 i=1,len(hen_house)
        hen_house(i:i) = ' '
1731  CONTINUE
1732  CONTINUE
      i = lnblnk1('/home/miia/EGSnrc/HEN_HOUSE/')
      hen_house(:i) = '/home/miia/EGSnrc/HEN_HOUSE/'
      IF (( '/' .NE. fool_dec )) THEN
        DO 1741 j=1,i
          IF((hen_house(j:j) .EQ. '/'))hen_house(j:j) = '/'
1741    CONTINUE
1742    CONTINUE
      END IF
      IF((hen_house(i:i) .NE. '/'))hen_house(i+1:i+1) = '/'
      n_files = 0
      DO 1751 i=1,len(egs_home)
        egs_home(i:i) = ' '
1751  CONTINUE
1752  CONTINUE
      call getenv('EGS_HOME',egs_home)
      i = lnblnk1(egs_home)
      IF (( '/' .NE. fool_dec )) THEN
        DO 1761 j=1,i
          IF((egs_home(j:j) .EQ. '/'))egs_home(j:j) = '/'
1761    CONTINUE
1762    CONTINUE
      END IF
      IF((i .GT. 0 .AND. egs_home(i:i) .NE. '/'))egs_home(i+1:i+1) = '/'
      DO 1771 i=1,len(input_file)
        input_file(i:i) = ' '
1771  CONTINUE
1772  CONTINUE
      DO 1781 i=1,len(output_file)
        output_file(i:i) = ' '
1781  CONTINUE
1782  CONTINUE
      DO 1791 i=1,len(work_dir)
        work_dir(i:i) = ' '
1791  CONTINUE
1792  CONTINUE
      DO 1801 i=1,len(pegs_file)
        pegs_file(i:i) = ' '
1801  CONTINUE
1802  CONTINUE
      DO 1811 i=1,len(host_name)
        host_name(i:i) = ' '
1811  CONTINUE
1812  CONTINUE
      n_parallel = 0
      i_parallel = 0
      n_chunk = 0
      is_batch = .false.
      first_parallel = 1
      return
      end
      subroutine egs_combine_runs(combine_routine,extension)
      implicit none
      external combine_routine
      character*(*) extension
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*1024 tmp_string,base,command,outfile,parfile_name,base1,
     * text_string
      integer lnblnk1,istat,ipar,egs_system,egs_open_file
      integer*4 i,k,j,numparfiles,textindex
      logical ex,iwin
      iwin=.false.
      DO 1821 i=1,len(base)
        base(i:i) = ' '
1821  CONTINUE
1822  CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e)) // '/' // output_file(:lnblnk1(output_file)) // '_w'
      DO 1831 i=1,len(base1)
        base1(i:i) = ' '
1831  CONTINUE
1832  CONTINUE
      base1 = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_co
     *de)) // '/' // output_file(:lnblnk1(output_file)) // '_w*' // exte
     *nsion(:lnblnk1(extension))
      DO 1841 i=1,len(outfile)
        outfile(i:i) = ' '
1841  CONTINUE
1842  CONTINUE
      outfile = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_
     *code)) // '/' // 'parfiles_tmp'
      DO 1851 i=1,len(command)
        command(i:i) = ' '
1851  CONTINUE
1852  CONTINUE
      command = 'ls ' // base1(:lnblnk1(base1)) // ' | wc -l > ' // outf
     *ile(:lnblnk1(outfile))
      istat = egs_system(command(:lnblnk1(command)))
      IF ((istat.NE.0)) THEN
        command = 'dir ' // base1(:lnblnk1(base1)) // ' | find "File(s)"
     * > ' // outfile(:lnblnk1(outfile))
        istat = egs_system(command(:lnblnk1(command)))
        IF ((istat.NE.0)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) ' Failed to write number of output files from p
     *arallel runs.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        ELSE
          iwin=.true.
        END IF
      END IF
      ipar=1
      ipar=egs_open_file(ipar,0,1,outfile(:lnblnk1(outfile)))
      IF ((iwin)) THEN
        read(ipar,'(a)',err=1860,end=1860) text_string
        text_string = text_string(:lnblnk1(text_string))
        textindex = index(text_string,'File(s)')
        text_string = text_string(:textindex-1)
        read(text_string,'(i256)',err=1860) numparfiles
      ELSE
        read(ipar,'(i256)',err=1860,end=1860) numparfiles
      END IF
      close(ipar)
      DO 1871 i=1,len(command)
        command(i:i) = ' '
1871  CONTINUE
1872  CONTINUE
      IF ((iwin)) THEN
        command = 'del /Q ' // outfile(:lnblnk1(outfile))
      ELSE
        command = 'rm -f ' // outfile(:lnblnk1(outfile))
      END IF
      istat = egs_system(command(:lnblnk1(command)))
      IF ((istat.NE.0)) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' Failed to delete list of output files from para
     *llel runs.'
      END IF
      k=1
      j=1
1881  IF(j.GT.numparfiles)GO TO 1882
        DO 1891 i=1,len(tmp_string)
          tmp_string(i:i) = ' '
1891    CONTINUE
1892    CONTINUE
        tmp_string = base(:lnblnk1(base))
        call egs_itostring(tmp_string,k,.false.)
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // extension(:lnbl
     *  nk1(extension))
        inquire(file=tmp_string,exist=ex)
        IF (( ex )) THEN
          call combine_routine(tmp_string)
          j=j+1
        END IF
        k=k+1
      GO TO 1881
1882  CONTINUE
      return
1860  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' Failed to read number of output files from parall
     *el runs.'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      logical function egs_strip_extension(filen,fext)
      implicit none
      character*(*) filen,fext
      integer l1,l2,lnblnk1,i
      l1 = lnblnk1(filen)
      l2 = lnblnk1(fext)
      IF (( l1 .GE. l2 .AND. filen(l1-l2+1:l1) .EQ. fext(:l2) )) THEN
        egs_strip_extension = .true.
        DO 1901 i=l1-l2+1,len(filen)
          filen(i:i) = ' '
1901    CONTINUE
1902    CONTINUE
      ELSE
        egs_strip_extension = .false.
      END IF
      return
      end
      logical function egs_is_absolute_path(fn)
      implicit none
      character*(*) fn
      integer i,lnblnk1
      DO 1911 i=1,lnblnk1(fn)
        IF (( fn(i:i) .EQ. '/' )) THEN
          egs_is_absolute_path = .true.
          return
        END IF
1911  CONTINUE
1912  CONTINUE
      egs_is_absolute_path = .false.
      return
      end
      integer function egs_get_unit(iunit)
      implicit none
      integer*4 iunit, i
      logical is_open
      IF (( iunit .GT. 0 )) THEN
        inquire(iunit,opened=is_open)
        IF (( .NOT.is_open )) THEN
          egs_get_unit = iunit
          return
        END IF
      END IF
      DO 1921 i=1,99
        inquire(i,opened=is_open)
        IF (( .NOT.is_open )) THEN
          egs_get_unit = i
          return
        END IF
1921  CONTINUE
1922  CONTINUE
      egs_get_unit = -1
      return
      end
      integer function egs_open_file(iunit,rl,action,extension)
      implicit none
      integer*4 iunit, rl, action
      character*(*) extension
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      logical egs_is_absolute_path,is_open
      integer egs_get_unit
      integer i,lnblnk1
      character*1024 tmp_string,error_string
      integer*4 the_unit
      egs_open_file = -1
      the_unit = egs_get_unit(iunit)
      IF (( the_unit .LT. 0 )) THEN
        IF (( action .EQ. 0 )) THEN
          egs_open_file = -1
          return
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'No free Fortran I/O units left'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( egs_is_absolute_path(extension) )) THEN
        inquire(file=extension,opened=is_open)
        IF ((is_open)) THEN
          inquire(file=extension,number=the_unit)
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,'(a,a,/,a,i3,/,a,/,a)') 'File ',extension(:lnblnk1
     *    (extension)), ' is already opened and connected to unit ',the_
     *    unit, ' Will not try to re-open this file, assuming it has bee
     *n opened', ' by the .io file.'
        ELSE IF(( rl .EQ. 0 )) THEN
          open(the_unit,file=extension,status='unknown')
        ELSE
          open(the_unit,file=extension,status='unknown',form='unformatte
     *d', access='direct', recl=rl)
        END IF
        egs_open_file = the_unit
        return
      END IF
      DO 1931 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
1931  CONTINUE
1932  CONTINUE
      tmp_string = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(us
     *er_code)) // '/' // work_dir(:lnblnk1(work_dir)) // output_file(:l
     *nblnk1(output_file))
      IF (( i_parallel .GT. 0 )) THEN
        tmp_string = tmp_string(:lnblnk1(tmp_string)) // '_w'
        call egs_itostring(tmp_string,i_parallel,.false.)
      END IF
      tmp_string = tmp_string(:lnblnk1(tmp_string)) // extension(:lnblnk
     *1(extension))
      inquire(file=tmp_string,opened=is_open)
      IF ((is_open)) THEN
        inquire(file=tmp_string,number=the_unit)
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,'(a,a,/,a,i3,/,a,/,a,/)') 'File ',tmp_string(:lnblnk
     *  1(tmp_string)), ' is already opened and connected to unit ',the_
     *  unit, ' Will not try to re-open this file, assuming it has been
     *opened', ' by specifying it in the .io file.'
      ELSE IF(( rl .EQ. 0 )) THEN
        open(the_unit,file=tmp_string,status='unknown',err=1940)
      ELSE
        open(the_unit,file=tmp_string,status='unknown',form='unformatted
     *', access='direct', recl=rl,err=1940)
      END IF
      egs_open_file = the_unit
      return
1940  error_string = 'In egs_open_file: failed to open file ' // tmp_str
     *ing(:lnblnk1(tmp_string)) // char(10) // 'iunit = '
      call egs_itostring(error_string,iunit,.false.)
      error_string = error_string(:lnblnk1(error_string)) // ' the_unit
     *= '
      call egs_itostring(error_string,the_unit,.false.)
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a)') error_string(:lnblnk1(error_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      integer function egs_open_datfile(iunit,rl,action,extension)
      implicit none
      integer*4 iunit,rl,action
      character*(*) extension
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer i,the_unit,lnblnk1,egs_get_unit
      logical egs_is_absolute_path
      character base*1024, fn*1024
      egs_open_datfile = -1
      the_unit = egs_get_unit(iunit)
      IF (( the_unit .LT. 0 )) THEN
        IF (( action .EQ. 0 )) THEN
          egs_open_datfile = -1
          return
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'No free Fortran I/O units left'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( egs_is_absolute_path(extension) )) THEN
        IF (( rl .EQ. 0 )) THEN
          open(the_unit,file=extension,status='old',err=1950)
        ELSE
          open(the_unit,file=extension,status='old',form='unformatted',
     *    access='direct',recl=rl,err=1950)
        END IF
        egs_open_datfile = the_unit
        return
1950    CONTINUE
        IF (( action .EQ. 0 )) THEN
          egs_open_datfile = -2
          return
        END IF
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Failed to open file ',extension(:lnblnk1(extensi
     *  on))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      DO 1961 i=1,len(base)
        base(i:i) = ' '
1961  CONTINUE
1962  CONTINUE
      DO 1971 i=1,len(fn)
        fn(i:i) = ' '
1971  CONTINUE
1972  CONTINUE
      base = egs_home(:lnblnk1(egs_home)) // user_code(:lnblnk1(user_cod
     *e)) // '/'
      IF (( i_parallel .GT. 0 )) THEN
        fn = base(:lnblnk1(base)) // output_file(:lnblnk1(output_file))
     *  // '_w'
        call egs_itostring(fn,i_parallel,.false.)
        fn = fn(:lnblnk1(fn)) // extension(:lnblnk1(extension))
      ELSE
        fn = base(:lnblnk1(base)) // output_file(:lnblnk1(output_file))
     *  // extension(:lnblnk1(extension))
      END IF
      IF (( rl .EQ. 0 )) THEN
        open(the_unit,file=fn,status='old',err=1980)
      ELSE
        open(the_unit,file=fn,status='old',form='unformatted',access='di
     *rect', recl=rl,err=1980)
      END IF
      egs_open_datfile = the_unit
      return
1980  CONTINUE
      write(i_log,'(/a)') '***************** Warning: '
      write(i_log,'(a,a)') 'Failed to open ',fn(:lnblnk1(fn))
      DO 1991 i=1,len(fn)
        fn(i:i) = ' '
1991  CONTINUE
1992  CONTINUE
      IF (( i_parallel .GT. 0 )) THEN
        fn = base(:lnblnk1(base)) // input_file(:lnblnk1(input_file)) //
     *   '_w'
        call egs_itostring(fn,i_parallel,.false.)
        fn = fn(:lnblnk1(fn)) // extension(:lnblnk1(extension))
      ELSE
        fn = base(:lnblnk1(base)) // input_file(:lnblnk1(input_file)) //
     *   extension(:lnblnk1(extension))
      END IF
      IF (( rl .EQ. 0 )) THEN
        open(the_unit,file=fn,status='old',err=2000)
      ELSE
        open(the_unit,file=fn,status='old',form='unformatted',access='di
     *rect', recl=rl,err=2000)
      END IF
      egs_open_datfile = the_unit
      return
2000  CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Failed to open data file'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      integer function egs_open_file_junk(iunit,do_it_anyway,filen)
      implicit none
      integer*4 iunit
      logical do_it_anyway
      character*(*) filen
      logical aux
      integer*4 the_unit,i
      inquire(file=filen,exist=aux)
      IF (( .NOT.aux )) THEN
        egs_open_file_junk = -2
        return
      END IF
      IF (( iunit .LT. 0 )) THEN
        the_unit = -iunit
      ELSE
        the_unit = iunit
      END IF
      IF (( the_unit .NE. 0 )) THEN
        inquire(unit=the_unit,opened=aux)
        IF (( aux )) THEN
          IF (( .NOT.do_it_anyway )) THEN
            egs_open_file_junk = -4
            return
          END IF
          IF((iunit .LT. 0))the_unit = 0
        END IF
      END IF
      IF (( the_unit .EQ. 0 )) THEN
        DO 2011 i=1,99
          inquire(unit=i,opened=aux)
          IF (( .NOT.aux )) THEN
            the_unit = i
            GO TO2012
          END IF
2011    CONTINUE
2012    CONTINUE
        IF (( the_unit .EQ. 0 )) THEN
          egs_open_file_junk = -1
          return
        END IF
      END IF
      open(the_unit,file=filen,status='old',err=2020)
      egs_open_file_junk = the_unit
      return
2020  egs_open_file_junk = -3
      return
      end
      subroutine egs_strip_path(fname)
      implicit none
      character*(*) fname
      integer i,l,l1,lnblnk1,j
      character slash
      slash = '/'
      l = lnblnk1(fname)
      DO 2031 i=1,l
        IF (( fname(i:i) .EQ. slash )) THEN
          fname(i:i) = '/'
        END IF
2031  CONTINUE
2032  CONTINUE
      DO 2041 i=l,1,-1
        IF (( fname(i:i) .EQ. '/' .OR. fname(i:i) .EQ. slash )) THEN
          l1 = l-i
          fname(:l1) = fname(i+1:l)
          DO 2051 j=l1+1,len(fname)
            fname(j:j) = ' '
2051      CONTINUE
2052      CONTINUE
          return
        END IF
2041  CONTINUE
2042  CONTINUE
      return
      end
      subroutine replace_env(fname)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*(*) fname
      character*256 dirname
      integer indsep,ind1,ind2
      indsep = index(fname,'/')
      IF((indsep .LE. 0))return
      ind1=index(fname,'$')
      ind2=index(fname,'~')
      IF ((ind1.EQ.1)) THEN
        call getenv(fname(2:indsep-1),dirname)
        IF ((dirname.EQ.' ')) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,a/,a)') ' Error in file name: ',fname(:lnblnk1
     *    (fname)), ' First element in name does not specify a defined e
     *nvironment variable.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        fname=dirname(:lnblnk1(dirname))//fname(indsep:)
        write(i_log,'(//a,a/)') ' Retrieving file: ',fname(:lnblnk1(fnam
     *  e))
      ELSE IF((ind2.EQ.1)) THEN
        call getenv('HOME',dirname)
        IF ((dirname.EQ.' ')) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,a/,a)') ' Error in file name: ',fname(:lnblnk1
     *    (fname)), ' HOME is undefined.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        fname=dirname(:lnblnk1(dirname))//fname(indsep:)
        write(i_log,'(//a,a/)') ' Retrieving file: ',fname(:lnblnk1(fnam
     *  e))
      END IF
      return
      end
      subroutine egs_get_usercode(ucode)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character*(*) ucode
      character*512 arg
      integer l,l1,lnblnk1,i
      call egs_getarg(0,arg)
      call egs_strip_path(arg)
      l = lnblnk1(arg)
      IF (( arg(l-3:l) .EQ. '.exe' )) THEN
        arg(l-3:l) = ' '
        l = l - 4
      END IF
      IF (( arg(l-5:l) .EQ. '_debug' )) THEN
        arg(l-5:l) = ' '
        l = l-5
      END IF
      IF (( arg(l-5:l) .EQ. '_noopt' )) THEN
        arg(l-5:l) = ' '
        l = l-5
      END IF
      l1 = len(ucode)
      IF (( l .GT. l1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' user code name is too long (',l,' chars)'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      DO 2061 i=1,len(ucode)
        ucode(i:i) = ' '
2061  CONTINUE
2062  CONTINUE
      ucode(:l) = arg(:l)
      return
      end
      subroutine egs_itostring(string,i,leave_space)
      implicit none
      character*(*) string
      integer*4 i
      integer l,lnblnk1,idiv,itmp,iaux
      logical first,leave_space
      l = lnblnk1(string)+1
      IF((l .GT. 1 .AND. leave_space))l=l+1
      idiv = 1000000000
      itmp = i
      first = .false.
      do while(idiv.gt.0)
      iaux = itmp/idiv
      IF (( (iaux .GT. 0 .OR. first ) .AND. l .LE. len(string) )) THEN
        string(l:l) = char(iaux+48)
        first = .true.
        l = l+1
      END IF
      itmp = itmp - iaux*idiv
      idiv = idiv/10
      end do
      return
      end
      EGS_Float function egs_rndm()
      implicit none
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      IF (( rng_seed .GT. 128 )) THEN
        rng_seed = 128
        call egs_fill_rndm_array(rng_seed,rng_array)
        rng_seed = 1
      END IF
      egs_rndm = rng_array(rng_seed)
      rng_seed = rng_seed + 1
      return
      end
      integer function egs_add_medium(medname)
      implicit none
      character*(*) medname
      integer max_med
      parameter (max_med = MXMED)
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,l,imed,medname_len
      character c
      logical same
      l = min(len(medname),24)
      medname_len = l
      DO 2071 i=1,l
        c = medname(i:i)
        IF (( ichar(c) .EQ. 0 )) THEN
          medname_len = i-1
          GO TO2072
        END IF
2071  CONTINUE
2072  CONTINUE
      DO 2081 imed=1,nmed
        l = 24
        DO 2091 i=1,24
          IF (( media(i,imed)(1:1) .EQ. ' ' )) THEN
            l = i-1
            GO TO2092
          END IF
2091    CONTINUE
2092    CONTINUE
        IF (( l .EQ. medname_len )) THEN
          same = .true.
          DO 2101 i=1,l
            c = medname(i:i)
            IF (( c .NE. media(i,imed)(1:1) )) THEN
              same = .false.
              GO TO2102
            END IF
2101      CONTINUE
2102      CONTINUE
          IF (( same )) THEN
            egs_add_medium = imed
            return
          END IF
        END IF
2081  CONTINUE
2082  CONTINUE
      nmed = nmed + 1
      IF (( nmed .GT. max_med )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(a,/,a,i3,a)') 'In egs_add_medium: maximum number o
     *f media exceeded ', 'Increase the macro $MXMED (currently ',max_me
     *  d,') and retry'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      l = min(len(medname),24)
      DO 2111 i=1,l
        c = medname(i:i)
        IF (( ichar(c) .EQ. 0 )) THEN
          l = i-1
          GO TO2112
        END IF
        media(i,nmed) = ' '
        media(i,nmed)(1:1) = c
2111  CONTINUE
2112  CONTINUE
      IF (( l .LT. 24 )) THEN
        DO 2121 i=l+1,24
          media(i,nmed) = ' '
2121    CONTINUE
2122    CONTINUE
      END IF
      egs_add_medium = nmed
      return
      end
      subroutine egs_get_medium_name(imed,medname)
      implicit none
      character*(*) medname
      integer max_med
      parameter (max_med = MXMED)
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,l,imed
      DO 2131 i=1,len(medname)
        medname(i:i) = ' '
2131  CONTINUE
2132  CONTINUE
      IF (( imed .LT. 1 .OR. imed .GT. nmed )) THEN
        return
      END IF
      l = 24
      DO 2141 l=24,1,-1
        IF((media(l,imed)(1:1) .NE. ' '))GO TO2142
2141  CONTINUE
2142  CONTINUE
      l = min(l,len(medname))
      DO 2151 i=1,l
        medname(i:i) = media(i,imed)(1:1)
2151  CONTINUE
2152  CONTINUE
      return
      end
      subroutine egs_get_electron_data(func,imed,which)
      implicit none
      integer*4 imed,which
      external func
      integer max_med
      parameter (max_med = MXMED)
      COMMON/ELECIN/ esig_e(max_med),psig_e(max_med), esige_max, psige_m
     *ax, range_ep(0:1,500,max_med), E_array(500,max_med), etae_ms0(500,
     *max_med),etae_ms1(500,max_med),etap_ms0(500,max_med),etap_ms1(500,
     *max_med),q1ce_ms0(500,max_med),q1ce_ms1(500,max_med),q1cp_ms0(500,
     *max_med),q1cp_ms1(500,max_med),q2ce_ms0(500,max_med),q2ce_ms1(500,
     *max_med),q2cp_ms0(500,max_med),q2cp_ms1(500,max_med),blcce0(500,ma
     *x_med),blcce1(500,max_med), EKE0(max_med),EKE1(max_med), XR0(max_m
     *ed),TEFF0(max_med),BLCC(max_med),XCC(max_med), ESIG0(500,max_med),
     *ESIG1(500,max_med),PSIG0(500,max_med),PSIG1(500,max_med),EDEDX0(50
     *0,max_med),EDEDX1(500,max_med),PDEDX0(500,max_med),PDEDX1(500,max_
     *med),EBR10(500,max_med),EBR11(500,max_med),PBR10(500,max_med),PBR1
     *1(500,max_med),PBR20(500,max_med),PBR21(500,max_med),TMXS0(500,max
     *_med),TMXS1(500,max_med), expeke1(max_med), IUNRST(max_med),EPSTFL
     *(max_med),IAPRIM(max_med), sig_ismonotone(0:1,max_med)
      EGS_Float esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E
     *_array,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1
     *,  q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blc
     *ce0,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG
     *0,ESIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR1
     *1,  PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      EGS_Float lemin,lemax
      lemin = (1 - eke0(imed))/eke1(imed)
      lemax = (meke(imed) - eke0(imed))/eke1(imed)
      IF (( which .EQ. 1 )) THEN
        call func(meke(imed),lemin,lemax,esig0(1,imed),esig1(1,imed))
      ELSE IF(( which .EQ. 2 )) THEN
        call func(meke(imed),lemin,lemax,psig0(1,imed),psig1(1,imed))
      ELSE IF(( which .EQ. 3 )) THEN
        call func(meke(imed),lemin,lemax,ededx0(1,imed),ededx1(1,imed))
      ELSE IF(( which .EQ. 4 )) THEN
        call func(meke(imed),lemin,lemax,pdedx0(1,imed),pdedx1(1,imed))
      ELSE IF(( which .EQ. 5 )) THEN
        call func(meke(imed),lemin,lemax,ebr10(1,imed),ebr11(1,imed))
      ELSE IF(( which .EQ. 6 )) THEN
        call func(meke(imed),lemin,lemax,pbr10(1,imed),pbr11(1,imed))
      ELSE IF(( which .EQ. 7 )) THEN
        call func(meke(imed),lemin,lemax,pbr20(1,imed),pbr21(1,imed))
      ELSE IF(( which .EQ. 8 )) THEN
        call func(meke(imed),lemin,lemax,tmxs0(1,imed),tmxs1(1,imed))
      ELSE IF(( which .EQ. 9 )) THEN
        call func(meke(imed),lemin,lemax,range_ep(0,1,imed),range_ep(1,1
     *  ,imed))
      ELSE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Unknown electron data type ',which
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      return
      end
      subroutine egs_get_photon_data(func,imed,which)
      implicit none
      integer*4 imed,which
      external func
      integer max_med
      parameter (max_med = MXMED)
      COMMON/PHOTIN/ EBINDA(max_med), GE0(max_med),GE1(max_med), GMFP0(2
     *000,max_med),GMFP1(2000,max_med),GBR10(2000,max_med),GBR11(2000,ma
     *x_med),GBR20(2000,max_med),GBR21(2000,max_med), RCO0(max_med),RCO1
     *(max_med), RSCT0(100,max_med),RSCT1(100,max_med), COHE0(2000,max_m
     *ed),COHE1(2000,max_med),  PHOTONUC0(2000,max_med),PHOTONUC1(2000,m
     *ax_med), DPMFP, MPGEM(1,max_med), NGR(max_med)
      EGS_Float EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR
     *21,  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,
     *  DPMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      EGS_Float lemin,lemax
      lemin = (1 - ge0(imed))/ge1(imed)
      lemax = (mge(imed) - ge0(imed))/ge1(imed)
      IF (( which .EQ. 1 )) THEN
        call func(mge(imed),lemin,lemax,gmfp0(1,imed),gmfp1(1,imed))
      ELSE IF(( which .EQ. 2 )) THEN
        call func(mge(imed),lemin,lemax,gbr10(1,imed),gbr11(1,imed))
      ELSE IF(( which .EQ. 3 )) THEN
        call func(mge(imed),lemin,lemax,gbr20(1,imed),gbr21(1,imed))
      ELSE IF(( which .EQ. 4 )) THEN
        call func(mge(imed),lemin,lemax,cohe0(1,imed),cohe1(1,imed))
      ELSE IF(( which .EQ. 5 )) THEN
        call func(mge(imed),lemin,lemax,PHOTONUC0(1,imed),PHOTONUC1(1,im
     *  ed))
      ELSE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Unknown photon data type ',which
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      return
      end
      subroutine egs_print_binding_energies
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100)
      EGS_Float binding_energies, interaction_prob, relaxation_prob, edg
     *e_energies, edge_a,edge_b,edge_c,edge_d
      integer*4 edge_number
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,j
      integer*4 lnblnk1
      character*3 labels(16)
      data labels/'  K',' L1',' L2',' L3', ' M1',' M2',' M3',' M4',' M5'
     *, ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/
      write(i_log,'(a,a,a)') 'Binding energies from ',photon_xsections(:
     *lnblnk1(photon_xsections)), ' photon cross section library'
      DO 2161 j=1,100
        DO 2171 i=1,16
          IF (( binding_energies(i,j) .GT. 0 )) THEN
            write(i_log,'(a,i3,a,a,a,1pe12.4,a)') ' Eb(',j,',',labels(i)
     *      ,') = ',binding_energies(i,j),' MeV'
          END IF
2171    CONTINUE
2172    CONTINUE
2161  CONTINUE
2162  CONTINUE
      return
      end
      subroutine egs_scale_xcc(imed,factor)
      implicit none
      integer*4 imed
      EGS_Float factor
      integer max_med
      parameter (max_med = MXMED)
      COMMON/ELECIN/ esig_e(max_med),psig_e(max_med), esige_max, psige_m
     *ax, range_ep(0:1,500,max_med), E_array(500,max_med), etae_ms0(500,
     *max_med),etae_ms1(500,max_med),etap_ms0(500,max_med),etap_ms1(500,
     *max_med),q1ce_ms0(500,max_med),q1ce_ms1(500,max_med),q1cp_ms0(500,
     *max_med),q1cp_ms1(500,max_med),q2ce_ms0(500,max_med),q2ce_ms1(500,
     *max_med),q2cp_ms0(500,max_med),q2cp_ms1(500,max_med),blcce0(500,ma
     *x_med),blcce1(500,max_med), EKE0(max_med),EKE1(max_med), XR0(max_m
     *ed),TEFF0(max_med),BLCC(max_med),XCC(max_med), ESIG0(500,max_med),
     *ESIG1(500,max_med),PSIG0(500,max_med),PSIG1(500,max_med),EDEDX0(50
     *0,max_med),EDEDX1(500,max_med),PDEDX0(500,max_med),PDEDX1(500,max_
     *med),EBR10(500,max_med),EBR11(500,max_med),PBR10(500,max_med),PBR1
     *1(500,max_med),PBR20(500,max_med),PBR21(500,max_med),TMXS0(500,max
     *_med),TMXS1(500,max_med), expeke1(max_med), IUNRST(max_med),EPSTFL
     *(max_med),IAPRIM(max_med), sig_ismonotone(0:1,max_med)
      EGS_Float esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E
     *_array,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1
     *,  q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blc
     *ce0,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG
     *0,ESIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR1
     *1,  PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      IF (( imed .GT. 0 .AND. imed .LE. nmed )) THEN
        xcc(imed) = xcc(imed)*factor
      END IF
      return
      end
      subroutine egs_write_string(ounit,string)
      implicit none
      integer*4 ounit
      character*(*) string
      write(ounit,'(a,$)') string
      call flush(ounit)
      return
      end
      subroutine egs_swap_2(c)
      character c(2),tmp
      tmp=c(2)
      c(2)=c(1)
      c(1)=tmp
      return
      end
      subroutine egs_swap_4(c)
      character c(4),tmp
      tmp=c(4)
      c(4)=c(1)
      c(1)=tmp
      tmp=c(3)
      c(3)=c(2)
      c(2)=tmp
      return
      end
      subroutine set_spline(x,f,a,b,c,d,n)
      implicit none
      integer*4 n
      EGS_Float x(n),f(n),a(n),b(n),c(n),d(n)
      integer*4 m1,m2,m,mr
      EGS_Float s,r
      m1 = 2
      m2 = n-1
      s = 0
      DO 2181 m=1,m2
        d(m) = x(m+1) - x(m)
        r = (f(m+1) - f(m))/d(m)
        c(m) = r - s
        s = r
2181  CONTINUE
2182  CONTINUE
      s=0
      r=0
      c(1)=0
      c(n)=0
      DO 2191 m=m1,m2
        c(m) = c(m) + r*c(m-1)
        b(m) = 2*(x(m-1) - x(m+1)) - r*s
        s = d(m)
        r = s/b(m)
2191  CONTINUE
2192  CONTINUE
      mr = m2
      DO 2201 m=m1,m2
        c(mr) = (d(mr)*c(mr+1) - c(mr))/b(mr)
        mr = mr - 1
2201  CONTINUE
2202  CONTINUE
      DO 2211 m=1,m2
        s = d(m)
        r = c(m+1) - c(m)
        d(m) = r/s
        c(m) = 3*c(m)
        b(m) = (f(m+1)-f(m))/s - (c(m)+r)*s
        a(m) = f(m)
2211  CONTINUE
2212  CONTINUE
      return
      end
      EGS_Float function spline(s,x,a,b,c,d,n)
      implicit none
      integer*4 n
      EGS_Float s,x(n),a(n),b(n),c(n),d(n)
      integer m_lower,m_upper,direction,m,ml,mu,mav
      EGS_Float q
      IF (( x(1) .GT. x(n) )) THEN
        direction = 1
        m_lower = n
        m_upper = 0
      ELSE
        direction = 0
        m_lower = 0
        m_upper = n
      END IF
      IF (( s .GE. x(m_upper + direction) )) THEN
        m = m_upper + 2*direction - 1
      ELSE IF(( s .LE. x(m_lower+1-direction) )) THEN
        m = m_lower - 2*direction + 1
      ELSE
        ml = m_lower
        mu = m_upper
2221    IF(iabs(mu-ml).LE.1)GO TO 2222
          mav = (ml+mu)/2
          IF (( s .LT. x(mav) )) THEN
            mu = mav
          ELSE
            ml = mav
          END IF
        GO TO 2221
2222    CONTINUE
        m = mu + direction - 1
      END IF
      q = s - x(m)
      spline = a(m) + q*(b(m) + q*(c(m) + q*d(m)))
      return
      end
      subroutine prepare_alias_table(nsbin,xs_array,fs_array,ws_array,ib
     *in_array)
      implicit none
      integer nsbin
      integer*4 ibin_array(nsbin)
      EGS_Float xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin)
      integer*4 i,j_l,j_h
      EGS_Float sum,aux
      sum = 0
      DO 2231 i=1,nsbin
        aux = 0.5*(fs_array(i)+fs_array(i-1))*(xs_array(i)-xs_array(i-1)
     *  )
        IF((aux .LT. 1e-30))aux = 1e-30
        ws_array(i) = -aux
        ibin_array(i) = 1
        sum = sum + aux
2231  CONTINUE
2232  CONTINUE
      sum = sum/nsbin
      DO 2241 i=1,nsbin-1
        DO 2251 j_h=1,nsbin
          IF (( ws_array(j_h) .LT. 0 )) THEN
            IF((abs(ws_array(j_h)) .GT. sum))GOTO 2260
          END IF
2251    CONTINUE
2252    CONTINUE
        j_h = nsbin
2260    CONTINUE
          DO 2261 j_l=1,nsbin
          IF (( ws_array(j_l) .LT. 0 )) THEN
            IF((abs(ws_array(j_l)) .LT. sum))GOTO 2270
          END IF
2261    CONTINUE
2262    CONTINUE
        j_l = nsbin
2270    aux = sum - abs(ws_array(j_l))
        ws_array(j_h) = ws_array(j_h) + aux
        ws_array(j_l) = -ws_array(j_l)/sum
        ibin_array(j_l) = j_h
        IF((i .EQ. nsbin-1))ws_array(j_h) = 1
2241  CONTINUE
2242  CONTINUE
      return
      end
      EGS_Float function alias_sample1(nsbin,xs_array,fs_array,ws_array,
     *ibin_array)
      implicit none
      integer nsbin
      integer*4 ibin_array(nsbin)
      EGS_Float xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin)
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      integer*4 j
      EGS_Float r1,r2,aj,x,dx,a,rnno1
      IF (( rng_seed .GT. 128 )) THEN
        rng_seed = 128
        call egs_fill_rndm_array(rng_seed,rng_array)
        rng_seed = 1
      END IF
      r1 = rng_array(rng_seed)
      rng_seed = rng_seed + 1
      IF (( rng_seed .GT. 128 )) THEN
        rng_seed = 128
        call egs_fill_rndm_array(rng_seed,rng_array)
        rng_seed = 1
      END IF
      r2 = rng_array(rng_seed)
      rng_seed = rng_seed + 1
      aj = 1 + r1*nsbin
      j = aj
      aj = aj - j
      IF((aj .GT. ws_array(j)))j = ibin_array(j)
      x = xs_array(j-1)
      dx = xs_array(j)-x
      IF (( fs_array(j-1) .GT. 0 )) THEN
        a = fs_array(j)/fs_array(j-1)-1
        IF (( abs(a) .LT. 0.2 )) THEN
          rnno1 = 0.5*(1-r2)*a
          alias_sample1 = x + r2*dx*(1+rnno1*(1-r2*a))
        ELSE
          alias_sample1 = x - dx/a*(1-sqrt(1+r2*a*(2+a)))
        END IF
      ELSE
        alias_sample1 = x + dx*sqrt(r2)
      END IF
      return
      end
      subroutine prepare_alias_histogram(nsbin,ws_array,ibin_array)
      implicit none
      integer*4 nsbin,ibin_array(nsbin)
      EGS_Float ws_array(nsbin)
      integer*4 i,j_l,j_h
      EGS_Float sum,aux
      sum = 0
      DO 2281 i=1,nsbin
        sum = sum + ws_array(i)
        ibin_array(i) = -1
2281  CONTINUE
2282  CONTINUE
      sum = sum/nsbin
      DO 2291 i=1,nsbin-1
        DO 2301 j_h=1,nsbin
          IF((ibin_array(j_h) .LT. 0 .AND. ws_array(j_h) .GT. sum))GO TO
     *    2302
2301    CONTINUE
2302    CONTINUE
        DO 2311 j_l=1,nsbin
          IF((ibin_array(j_l) .LT. 0 .AND. ws_array(j_l) .LT. sum))GO TO
     *    2312
2311    CONTINUE
2312    CONTINUE
        aux = sum - ws_array(j_l)
        ws_array(j_h) = ws_array(j_h) - aux
        ws_array(j_l) = ws_array(j_l)/sum
        ibin_array(j_l) = j_h
2291  CONTINUE
2292  CONTINUE
      DO 2321 i=1,nsbin
        IF (( ibin_array(i) .LT. 0 )) THEN
          ibin_array(i) = i
          ws_array(i) = 1
        END IF
2321  CONTINUE
2322  CONTINUE
      return
      end
      integer*4 function sample_alias_histogram(nsbin,ws_array,ibin_arra
     *y)
      implicit none
      integer*4 nsbin,ibin_array(*)
      EGS_Float ws_array(*)
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      EGS_Float r1,r2
      integer*4 ibin
      IF (( rng_seed .GT. 128 )) THEN
        rng_seed = 128
        call egs_fill_rndm_array(rng_seed,rng_array)
        rng_seed = 1
      END IF
      r1 = rng_array(rng_seed)
      rng_seed = rng_seed + 1
      IF (( rng_seed .GT. 128 )) THEN
        rng_seed = 128
        call egs_fill_rndm_array(rng_seed,rng_array)
        rng_seed = 1
      END IF
      r2 = rng_array(rng_seed)
      rng_seed = rng_seed + 1
      ibin = 1 + nsbin*r1
      IF((r2 .GT. ws_array(ibin)))ibin = ibin_array(ibin)
      sample_alias_histogram = ibin
      return
      end
      subroutine gauss_legendre(x1,x2,x,w,n)
      implicit none
      integer*4 n
      real*8 x1,x2,x(n),w(n)
      real*8 eps,Pi
      parameter (eps = 3.D-14,Pi=3.141592654D0)
      integer*4 i,m,j
      real*8 xm,xl,z,z1,p1,p2,p3,pp
      m = (n + 1)/2
      xm=0.5d0*(x2+x1)
      xl=0.5d0*(x2-x1)
      DO 2331 i=1,m
        z=cos(Pi*(i-.25d0)/(n+.5d0))
2341    CONTINUE
          p1=1.d0
          p2=0.d0
          DO 2351 j=1,n
            p3 = p2
            p2 = p1
            p1=((2.d0*j-1.d0)*z*p2-(j-1.d0)*p3)/j
2351      CONTINUE
2352      CONTINUE
          pp=n*(z*p1-p2)/(z*z-1.d0)
          z1=z
          z=z1-p1/pp
          IF(((abs(z-z1) .LT. eps)))GO TO2342
        GO TO 2341
2342    CONTINUE
        x(i)=xm-xl*z
        x(n+1-i)=xm+xl*z
        w(i)=2.d0*xl/((1.d0-z*z)*pp*pp)
        w(n+1-i)=w(i)
2331  CONTINUE
2332  CONTINUE
      return
      end
      integer function lnblnk1(string)
      character*(*) string
      integer i
      DO 2361 i=len(string),1,-1
        j = ichar(string(i:i))
        IF (( j .EQ. 0 )) THEN
          lnblnk1 = i-1
          return
        END IF
        IF (( j .NE. 9 .AND. j .NE. 10 .AND. j .NE. 11 .AND. j .NE. 12 .
     *  AND. j .NE. 13 .AND. j .NE. 32 )) THEN
          lnblnk1 = i
          return
        END IF
2361  CONTINUE
2362  CONTINUE
      lnblnk1 = 0
      return
      end
      EGS_Float FUNCTION ERF1(X)
      implicit none
      EGS_Float x
      double precision A(0:22,2)
      double precision CONST,  BN,BN1,BN2,  Y,FAC
      integer*4 N,  K,  NLIM(2)
      DATA A/ 1.0954712997776232 , -0.2891754011269890 , 0.1104563986337
     *951 , -0.0412531882278565 , 0.0140828380706516 , -0.00432929544743
     *14 , 0.0011982719015923 , -0.0002999729623532 , 0.0000683258603789
     * , -0.0000142469884549 , 0.0000027354087728 , -0.0000004861912872
     *, 0.0000000803872762 , -0.0000000124184183 , 0.0000000017995326 ,
     *-0.0000000002454795 , 0.0000000000316251 , -0.0000000000038590 , 0
     *.0000000000004472 , -0.0000000000000493 , 0.0000000000000052 , -0.
     *0000000000000005 , 0.0000000000000001 , 0.9750834237085559 , -0.02
     *40493938504146 , 0.0008204522408804 , -0.0000434293081303 , 0.0000
     *030184470340 , -0.0000002544733193 , 0.0000000248583530 , -0.00000
     *00027317201 , 0.0000000003308472 , 0.0000000000001464 , -0.0000000
     *000000244 , 0.0000000000000042 , -0.0000000000000008 , 0.000000000
     *0000001 , 9*0.0 /
      DATA NLIM/ 22,16 /
      DATA CONST/ 1.128379167095513 /
      IF (( x .GT. 3 )) THEN
        y = 3/x
        k = 2
      ELSE
        y = x/3
        k = 1
      END IF
      FAC = 2.0 * ( 2.0 * Y*Y - 1.0 )
      BN1 = 0.0
      BN = 0.0
      DO 2371 n=NLIM(K),0,-1
        BN2 = BN1
        BN1 = BN
        BN = FAC * BN1 - BN2 + A(N,K)
2371  CONTINUE
2372  CONTINUE
      IF (( k .EQ. 1 )) THEN
        erf1 = CONST * Y * ( BN - BN1 )
      ELSE
        erf1 = 1 - CONST * EXP(-X**2) * ( BN - BN2 + A(0,K) )/(4.0 * X)
      END IF
      RETURN
      end
      EGS_Float FUNCTION ZERO()
      implicit none
      integer*4 i
      EGS_Float x, xtemp
      x = 1.E-20
      DO 2381 i=1,100
        IF ((x .EQ. 0.0)) THEN
          GO TO2382
        ELSE
          xtemp = x
        END IF
        x = x/1.E5
2381  CONTINUE
2382  CONTINUE
      x = xtemp
      DO 2391 i=1,5
        IF ((x .NE. 0.0)) THEN
          xtemp = x
        ELSE
          GO TO2392
        END IF
        x = x/10
2391  CONTINUE
2392  CONTINUE
      x = xtemp
      DO 2401 i=2,10
        IF ((x .NE. 0.0)) THEN
          xtemp = x
        ELSE
          GO TO2402
        END IF
        x = x/i
2401  CONTINUE
2402  CONTINUE
      zero = xtemp
      return
      end
      character*512 function toUpper(a_string)
      character*(*) a_string
      character*512 the_string
      integer*4 cursor, i, lnblnk1
      toUpper = a_string
      the_string = a_string
      DO 2411 i=1,lnblnk1(the_string)
        cursor=ICHAR(the_string(i:i))
        IF (((cursor.GE.97).AND.(cursor.LE.122))) THEN
          cursor=cursor-32
          toUpper(i:i)=CHAR(cursor)
        END IF
2411  CONTINUE
2412  CONTINUE
      return
      end
      integer*1 function egs_read_byte(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      integer*1 i_1
      character c_1
      equivalence (i_1,c_1)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      read(iunit,rec=jrec,IOSTAT=ierr) c_1
      IF ((ierr.ne.0)) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) ' *** egs_read_byte: ERROR READING A byte *** '
        write(i_log,*) ' From unit ',iunit,' position ',jrec,' bytes'
        egs_read_byte = -1
        return
      END IF
      jrec = jrec + 1
      egs_read_byte = i_1
      return
      end
      integer*2 function egs_read_short(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      integer*2 i_2
      character c_2(2)
      equivalence (i_2,c_2)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      j = 0
      DO 2421 i=jrec,jrec+1
        j = j + 1
        read(iunit,rec=i,IOSTAT=ierr) c_2(j)
        IF ((ierr.ne.0)) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' *** egs_read_short: ERROR READING short integ
     *er *** '
          write(i_log,*) ' From unit ',iunit,' position ',jrec,' bytes'
          egs_read_short = -1
          return
        END IF
2421  CONTINUE
2422  CONTINUE
      jrec = jrec + 2
      egs_read_short = i_2
      return
      end
      integer*4 function egs_read_int(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      integer*4 i_4
      character c_4(4)
      equivalence (i_4,c_4)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      j = 0
      DO 2431 i=jrec,jrec+3
        j = j + 1
        read(iunit,rec=i,IOSTAT=ierr) c_4(j)
        IF ((ierr.ne.0)) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' *** egs_read_int: ERROR READING integer *** '
          write(i_log,*) ' From unit ',iunit,' position ',jrec,' bytes'
          egs_read_int = -1
          return
        END IF
2431  CONTINUE
2432  CONTINUE
      jrec = jrec + 4
      egs_read_int = i_4
      return
      end
      real*4 function egs_read_real(iunit, jrec)
      implicit none
      integer iunit, jrec, i, j, ierr
      real*4 r_4
      character c_4(4)
      equivalence (r_4,c_4)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      j = 0
      DO 2441 i=jrec,jrec+3
        j = j + 1
        read(iunit,rec=i,IOSTAT=ierr) c_4(j)
        IF ((ierr.ne.0)) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' *** egs_read_real: ERROR READING float *** '
          write(i_log,*) ' From unit ',iunit,' position ',jrec,' bytes'
          egs_read_real = -1
          return
        END IF
2441  CONTINUE
2442  CONTINUE
      jrec = jrec + 4
      egs_read_real = r_4
      return
      end
      integer*4 function ibsearch(a, nsh, b)
      implicit none
      EGS_Float a, b(*)
      integer*4 min,max,help,nsh
      EGS_Float x
      min = 1
      max = nsh
      x = a
2451  IF(min.GE.max-1)GO TO 2452
        help = (max+min)/2
        IF (( b(help).le.x)) THEN
          min = help
        ELSE
          max = help
        END IF
      GO TO 2451
2452  CONTINUE
      ibsearch = min
      return
      end
      SUBROUTINE GET_INPUT
      IMPLICIT NONE
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      EGS_Float VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      CHARACTER*256 TEXT
      CHARACTER*256 KEEPTEXT
      CHARACTER*256 ORIGTEXT
      CHARACTER*256 TEXTPIECE
      CHARACTER*80 DELIM_START
      CHARACTER*80 DELIM_END
      CHARACTER*64 VNAME
      CHARACTER*64 VNAME1
      integer*4 CURSOR
      integer*4 IINDEX
      integer*4 iVNAME
      integer*4 IVAL
      integer*4 UNITNUM
      integer*4 ERR
      integer*4 I,J,K,CHECK
      integer*4 LINE
      integer*4 INT_VALUE
      integer*4 INT_VALUE_MIN
      integer*4 INT_VALUE_MAX
      logical ALLOWED
      logical START_FOUND
      integer*4 ifound,length,lll,Kconvert
      integer*4 lnblnk1
      logical IDEBUG
      character*1 blank
      integer*4 error_level
      integer*4 the_level
      data blank/' '/
      data error_level/1/
      save error_level
      IDEBUG = .false.
      ERROR_FLAG = 0
      IF ((IDEBUG)) THEN
        WRITE(6,2460)NMIN,NMAX, 100
2460    FORMAT(' Entering get_inputs seeking values', I5,' to', I5, '  w
     *ith a max allowed of',I5)
      END IF
      IF ((NMAX .LT. NMIN .OR. NMAX .GT. 100)) THEN
        WRITE(6,2470)NMAX, NMIN, 100
2470    FORMAT(//' Error entering get_inputs: Asked for values from',I5,
     *' to',I5, '    with a max of',I5//' This implies a bug in the call
     *ing routine'/ ' Fix it up and try again.  Stopping now.')
        STOP
      END IF
      ERR=i_errors
      UNITNUM=i_input
      DELIM_START=':START '//DELIMETER(:lnblnk1(DELIMETER))//':'
      DELIM_END=':STOP '//DELIMETER(:lnblnk1(DELIMETER))//':'
      DO 2481 Kconvert=1,lnblnk1(DELIM_START)
        CURSOR=ICHAR(DELIM_START(Kconvert:Kconvert))
        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
          CURSOR=CURSOR-32
          DELIM_START(Kconvert:Kconvert)=CHAR(CURSOR)
        END IF
2481  CONTINUE
2482  CONTINUE
      DO 2491 Kconvert=1,lnblnk1(DELIM_END)
        CURSOR=ICHAR(DELIM_END(Kconvert:Kconvert))
        IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
          CURSOR=CURSOR-32
          DELIM_END(Kconvert:Kconvert)=CHAR(CURSOR)
        END IF
2491  CONTINUE
2492  CONTINUE
      IF ((IDEBUG)) THEN
        WRITE(6,2500)DELIM_START,DELIM_END
2500    FORMAT(' start and stop delimeters are:'/ A/A/)
      END IF
      DO 2511 I=NMIN,NMAX
        REWIND (UNITNUM)
        LINE=0
        CHECK=0
        ERROR_FLAGS(I)=0
        IF ((TYPE(I) .EQ. 0 .OR. TYPE(I) .EQ. 1)) THEN
          VALUE(I,1) = DEFAULT(I)
        END IF
        IF ((TYPE(I) .EQ. 3)) THEN
          VALUE(I,1) = 0
        END IF
        VNAME=VALUES_SOUGHT(I)
        iVNAME=lnblnk1(VNAME)
        IF (( ivname .LT. 1 )) THEN
          IF (( error_level .GT. 0 )) THEN
            write(ERR,*) ' ======================= Warning =============
     *======== '
            write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!
     *         '
            write(ERR,*) ' =============================================
     *======== '
          END IF
          ERROR_FLAG=1
          ERROR_FLAGS(I)=1
          goto 2520
        END IF
        DO 2531 Kconvert=1,lnblnk1(vname)
          CURSOR=ICHAR(vname(Kconvert:Kconvert))
          IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
            CURSOR=CURSOR-32
            vname(Kconvert:Kconvert)=CHAR(CURSOR)
          END IF
2531    CONTINUE
2532    CONTINUE
        iindex = 0
        IF ((DELIMETER .EQ. 'NONE')) THEN
          start_found = .true.
        ELSE
          start_found = .false.
        END IF
2541    IF(iindex.NE.0)GO TO 2542
2550      CONTINUE
          LINE=LINE+1
          IF (( start_found )) THEN
            READ(UNITNUM,END=2560,ERR=2570,FMT='(A256)') TEXT
          ELSE
            READ(UNITNUM,END=2580,ERR=2570,FMT='(A256)') TEXT
          END IF
          length = len(text)
2591      IF(index(text,blank).NE.1)GO TO 2592
            IF (( length .GE. 2 )) THEN
              text=text(2:)
            ELSE
              GO TO2592
            END IF
            length = length - 1
          GO TO 2591
2592      CONTINUE
          ifound = INDEX(text,'#')
          IF (( ifound .GT. 1 )) THEN
            text = text(1:ifound-1)
          ELSE
            IF (( ifound .EQ. 1 )) THEN
              text = blank
            END IF
          END IF
          ifound = INDEX(text,';')
          IF (( ifound .GT. 1 )) THEN
            text = text(1:ifound-1)
          ELSE
            IF (( ifound .EQ. 1 )) THEN
              text = blank
            END IF
          END IF
          length = lnblnk1(TEXT)
          TEXT=TEXT(:length)
          origtext = text(:length)
          DO 2601 Kconvert=1,lnblnk1(text)
            CURSOR=ICHAR(text(Kconvert:Kconvert))
            IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
              CURSOR=CURSOR-32
              text(Kconvert:Kconvert)=CHAR(CURSOR)
            END IF
2601      CONTINUE
2602      CONTINUE
          IF (( .NOT.start_found )) THEN
            IF ((INDEX(TEXT,DELIM_START) .NE. 0 )) THEN
              start_found = .true.
            END IF
            goto 2550
          END IF
          iindex=INDEX(TEXT,VNAME(:iVNAME))
          IF (( DELIMETER.NE.'NONE' )) THEN
            IF ((INDEX(TEXT,DELIM_END).NE.0)) THEN
              IF (( error_level .GT. 0 )) THEN
                WRITE (ERR,*) '***************ERROR***************'
                WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUG
     *          HT(I))), '<<',' NOT FOUND'
                WRITE (ERR,*) 'END OF DELIMETER: ',DELIMETER(:lnblnk1(DE
     *          LIMETER))
              END IF
              ERROR_FLAG=1
              ERROR_FLAGS(I)=1
              GOTO 2520
            END IF
          END IF
        GO TO 2541
2542    CONTINUE
        CHECK=0
        IF (( idebug )) THEN
          write(i_log,*) ' ******* Found: '
          write(i_log,'(a,$)') ' text:     '
          length = lnblnk1(text)
          IF (( length .GT. 0 )) THEN
            DO 2611 lll=1,length
              write(i_log,'(a1,$)') text(lll:lll)
2611        CONTINUE
2612        CONTINUE
            write(i_log,*)
          END IF
          write(i_log,'(a,$)') ' origtext: '
          length = lnblnk1(origtext)
          IF (( length .GT. 0 )) THEN
            DO 2621 lll=1,length
              write(i_log,'(a1,$)') origtext(lll:lll)
2621        CONTINUE
2622        CONTINUE
            write(i_log,*)
          END IF
        END IF
        IINDEX=IINDEX+iVNAME
        TEXT=TEXT(IINDEX:)
        origtext=origtext(iindex:)
        IF (( idebug )) THEN
          write(i_log,*) ' After removing vname: '
          write(i_log,'(a,$)') ' text:     '
          length = lnblnk1(text)
          IF (( length .GT. 0 )) THEN
            DO 2631 lll=1,length
              write(i_log,'(a1,$)') text(lll:lll)
2631        CONTINUE
2632        CONTINUE
            write(i_log,*)
          END IF
          write(i_log,'(a,$)') ' origtext: '
          length = lnblnk1(origtext)
          IF (( length .GT. 0 )) THEN
            DO 2641 lll=1,length
              write(i_log,'(a1,$)') origtext(lll:lll)
2641        CONTINUE
2642        CONTINUE
            write(i_log,*)
          END IF
        END IF
        IINDEX=INDEX(TEXT,'=')
        IF ((IINDEX.NE.0)) THEN
          TEXT=TEXT(IINDEX+1:)
          origtext=origtext(iindex+1:)
        ELSE
          IINDEX=INDEX(TEXT,':')
          IF ((IINDEX.NE.0)) THEN
            TEXT=TEXT(IINDEX+1:)
            origtext=origtext(iindex+1:)
          END IF
        END IF
        IF (( idebug )) THEN
          write(i_log,*) ' After removing leading equals: '
          write(i_log,'(a,$)') ' text:     '
          length = lnblnk1(text)
          IF (( length .GT. 0 )) THEN
            DO 2651 lll=1,length
              write(i_log,'(a1,$)') text(lll:lll)
2651        CONTINUE
2652        CONTINUE
            write(i_log,*)
          END IF
          write(i_log,'(a,$)') ' origtext: '
          length = lnblnk1(origtext)
          IF (( length .GT. 0 )) THEN
            DO 2661 lll=1,length
              write(i_log,'(a1,$)') origtext(lll:lll)
2661        CONTINUE
2662        CONTINUE
            write(i_log,*)
          END IF
        END IF
        IF (( (lnblnk1(TEXT).EQ.0) .OR. (lnblnk1(TEXT).EQ.1) )) THEN
          IF ((vname(:ivname).EQ.'TITLE')) THEN
            READ (UNITNUM,FMT='(A256)') TEXTPIECE
            IF ((lnblnk1(TEXTPIECE).NE.0)) THEN
              TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE))
              length = len(text)
2671          IF(index(text,blank).NE.1)GO TO 2672
                IF (( length .GE. 2 )) THEN
                  text=text(2:)
                ELSE
                  GO TO2672
                END IF
                length = length - 1
              GO TO 2671
2672          CONTINUE
              length = len(origtext)
2681          IF(index(origtext,blank).NE.1)GO TO 2682
                IF (( length .GE. 2 )) THEN
                  origtext=origtext(2:)
                ELSE
                  GO TO2682
                END IF
                length = length - 1
              GO TO 2681
2682          CONTINUE
              GOTO 2690
            END IF
          END IF
          IF (( error_level .GT. 0 )) THEN
            WRITE (ERR,*) '*************ERROR*************'
            WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
            WRITE (ERR,*) 'VALUE NOT THERE!!'
          END IF
          ERROR_FLAG=1
          ERROR_FLAGS(I)=1
          RETURN
        END IF
2690    CONTINUE
        iindex = index(text,'DEFAULT')
        IF (( iindex .NE. 0 )) THEN
          IF (( type(i) .NE. 2 )) THEN
            IF (( type(i) .NE. 3 )) THEN
              VALUE(I,1)=DEFAULT(I)
            ELSE
              VALUE(I,1)=0
            END IF
            goto 2520
          END IF
        END IF
        IF (((TYPE(I) .EQ. 0).OR.(TYPE(I) .EQ. 1))) THEN
          IVAL=1
          IF (( idebug )) THEN
            write(i_log,*) ' *** Reading an integer or a real value! '
          END IF
2701      CONTINUE
            IF (( idebug )) THEN
              write(i_log,*) ' In LOOP, ival = ',ival
            END IF
            IF ((lnblnk1(TEXT).EQ.0)) THEN
              IF (( error_level .GT. 0 )) THEN
                WRITE(ERR,*) '*************ERROR*************'
                WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                WRITE (ERR,*) 'VALUE NOT THERE!!'
              END IF
              ERROR_FLAG=1
              ERROR_FLAGS(I)=1
              RETURN
            END IF
            READ(TEXT,END=2710,ERR=2720,FMT=*) VALUE(I,IVAL)
            IF (( idebug )) THEN
              write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL)
            END IF
            IF (((VALUE(I,IVAL).GT.VALUE_MAX(I)).OR.(VALUE(I,IVAL).LT.VA
     *      LUE_MIN(I)))) THEN
              IF ((TYPE(I).EQ.0)) THEN
                INT_VALUE=DEFAULT(I)
                IF (( error_level .GT. 0 )) THEN
                  WRITE(ERR,*) '************WARNING************'
                  WRITE(ERR,2730) INT_VALUE, VALUES_SOUGHT(I)(:lnblnk1(V
     *            ALUES_SOUGHT(I)))
                END IF
2730            FORMAT ( 'Default= ',I9,' used for: ', A )
                INT_VALUE=VALUE(I,IVAL)
                INT_VALUE_MIN=VALUE_MIN(I)
                INT_VALUE_MAX=VALUE_MAX(I)
                IF (( error_level .GT. 0 )) THEN
                  WRITE(ERR,2740) VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGH
     *            T(I))), INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX
                END IF
2740            FORMAT (A,'=', I9,' should be between ', I9,' and ', I9)
              END IF
              IF ((TYPE(I).EQ.1)) THEN
                IF (( error_level .GT. 0 )) THEN
                  WRITE(ERR,*) '************WARNING************'
                  WRITE(ERR,2750) DEFAULT(I), VALUES_SOUGHT(I)(:lnblnk1(
     *            VALUES_SOUGHT(I)))
2750              FORMAT ( 'Default= ',F12.6,' used for: ', A )
                  WRITE(ERR,2760) VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGH
     *            T(I))), VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I)
2760              FORMAT (A,'=', F12.6,' should be between ', G14.6,' an
     *d ', G14.6)
                END IF
              END IF
              VALUE(I,IVAL)=DEFAULT(I)
            END IF
            IF((IVAL .EQ. NVALUE(I)))GO TO2702
            IF (((INDEX(TEXT,',').NE.0).OR.(lnblnk1(TEXT).EQ.0))) THEN
              IF (( idebug )) THEN
                write(i_log,*) ' A comma or a blank text found -> '
                write(i_log,*) ' searching for further input'
              END IF
              TEXT=TEXT(INDEX(TEXT,',')+1:)
2771          IF(lnblnk1(TEXT).NE.0)GO TO 2772
                IF (( idebug )) THEN
                  write(i_log,*) ' Empty text -> reading next line! '
                END IF
                LINE=LINE+1
                READ (UNITNUM,END=2710,ERR=2720,FMT='(A256)') TEXT
                length = len(text)
2781            IF(index(text,blank).NE.1)GO TO 2782
                  IF (( length .GE. 2 )) THEN
                    text=text(2:)
                  ELSE
                    GO TO2782
                  END IF
                  length = length - 1
                GO TO 2781
2782            CONTINUE
                ifound = INDEX(text,'#')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                ifound = INDEX(text,';')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                length = lnblnk1(TEXT)
                TEXT=TEXT(:length)
                origtext = text(:length)
                DO 2791 Kconvert=1,lnblnk1(text)
                  CURSOR=ICHAR(text(Kconvert:Kconvert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                    CURSOR=CURSOR-32
                    text(Kconvert:Kconvert)=CHAR(CURSOR)
                  END IF
2791            CONTINUE
2792            CONTINUE
                DO 2801 K=1,NMAX
                  vname1 = VALUES_SOUGHT(K)
                  length = lnblnk1(vname1)
                  IF (( length .GT. 0 )) THEN
                    length = len(vname1)
2811                IF(index(vname1,blank).NE.1)GO TO 2812
                      IF (( length .GE. 2 )) THEN
                        vname1=vname1(2:)
                      ELSE
                        GO TO2812
                      END IF
                      length = length - 1
                    GO TO 2811
2812                CONTINUE
                    DO 2821 Kconvert=1,lnblnk1(vname1)
                      CURSOR=ICHAR(vname1(Kconvert:Kconvert))
                      IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                        CURSOR=CURSOR-32
                        vname1(Kconvert:Kconvert)=CHAR(CURSOR)
                      END IF
2821                CONTINUE
2822                CONTINUE
                    IF ((INDEX(TEXT,vname1(:length)).NE.0)) THEN
                      IF (( error_level .GT. 0 )) THEN
                        WRITE(ERR,*) '************ERROR************'
                        WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                        WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)), '<--C
     *OMMA INDICATES ANOTHER INPUT'
                        WRITE(ERR,*) 'SEARCHED NEXT LINE: ', TEXT(:lnbln
     *                  k1(TEXT))
                        WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED'
                      END IF
                      ERROR_FLAG=1
                      ERROR_FLAGS(I)=1
                    END IF
                  END IF
2801            CONTINUE
2802            CONTINUE
                IF (( idebug )) THEN
                  write(i_log,*) ' Next line: '
                  write(i_log,'(a,$)') ' text:     '
                  length = lnblnk1(text)
                  IF (( length .GT. 0 )) THEN
                    DO 2831 lll=1,length
                      write(i_log,'(a1,$)') text(lll:lll)
2831                CONTINUE
2832                CONTINUE
                    write(i_log,*)
                  END IF
                  write(i_log,'(a,$)') ' origtext: '
                  length = lnblnk1(origtext)
                  IF (( length .GT. 0 )) THEN
                    DO 2841 lll=1,length
                      write(i_log,'(a1,$)') origtext(lll:lll)
2841                CONTINUE
2842                CONTINUE
                    write(i_log,*)
                  END IF
                END IF
              GO TO 2771
2772          CONTINUE
            ELSE
              GO TO2702
            END IF
            IVAL=IVAL+1
          GO TO 2701
2702      CONTINUE
          IF (((NVALUE(I).NE.0).AND.(NVALUE(I).NE.IVAL))) THEN
            IF (( error_level .GT. 0 )) THEN
              WRITE (ERR,*) '**************ERROR**************'
              WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I)
              WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)'
              WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED'
            END IF
            ERROR_FLAG=1
            ERROR_FLAGS(I)=1
          ELSE
            NVALUE(I)=IVAL
          END IF
2710      CONTINUE
        END IF
        IF (((TYPE(I) .EQ. 2) .OR. (TYPE(I) .EQ. 3))) THEN
          IVAL=1
          IF (( idebug )) THEN
            write(i_log,*) ' Trying to read a string! '
          END IF
2851      CONTINUE
            IF (( idebug )) THEN
              write(i_log,*) ' In LOOP, ival = ',ival
            END IF
            IF ((lnblnk1(TEXT).EQ.0)) THEN
              IF (( error_level .GT. 0 )) THEN
                WRITE(ERR,*) '*************ERROR*************'
                WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                WRITE (ERR,*) 'VALUE NOT THERE!!'
              END IF
              ERROR_FLAG=1
              ERROR_FLAGS(I)=1
              RETURN
            END IF
            IF ((vname(:ivname).EQ.'TITLE')) THEN
              TEXTPIECE=origtext
              GOTO 2860
            END IF
            iindex = INDEX(origtext,',')
            IF (( iindex .NE. 0 )) THEN
              TEXTPIECE=origtext(:iindex-1)
            ELSE
              TEXTPIECE=origtext
            END IF
2860        CONTINUE
            READ(TEXTPIECE,ERR=2870,FMT='(A256)') CHAR_VALUE(I,IVAL)
            length = len(CHAR_VALUE(I,IVAL))
2881        IF(index(CHAR_VALUE(I,IVAL),blank).NE.1)GO TO 2882
              IF (( length .GE. 2 )) THEN
                CHAR_VALUE(I,IVAL)=CHAR_VALUE(I,IVAL)(2:)
              ELSE
                GO TO2882
              END IF
              length = length - 1
            GO TO 2881
2882        CONTINUE
            IF (( idebug )) THEN
              write(i_log,*) ' Read the following char string: '
              length = lnblnk1(CHAR_VALUE(I,IVAL))
              IF (( length .GT. 0 )) THEN
                DO 2891 lll=1,length
                  write(i_log,'(a1,$)') CHAR_VALUE(I,IVAL)(lll:lll)
2891            CONTINUE
2892            CONTINUE
                write(i_log,*)
              END IF
            END IF
            IF ((TYPE(I) .EQ. 3)) THEN
              DO 2901 Kconvert=1,lnblnk1(CHAR_VALUE(I,IVAL))
                CURSOR=ICHAR(CHAR_VALUE(I,IVAL)(Kconvert:Kconvert))
                IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                  CURSOR=CURSOR-32
                  CHAR_VALUE(I,IVAL)(Kconvert:Kconvert)=CHAR(CURSOR)
                END IF
2901          CONTINUE
2902          CONTINUE
              ALLOWED=.FALSE.
              DO 2911 K=0,5
                vname1 = ALLOWED_INPUTS(I,K)
                length = len(ALLOWED_INPUTS(I,K))
2921            IF(index(ALLOWED_INPUTS(I,K),blank).NE.1)GO TO 2922
                  IF (( length .GE. 2 )) THEN
                    ALLOWED_INPUTS(I,K)=ALLOWED_INPUTS(I,K)(2:)
                  ELSE
                    GO TO2922
                  END IF
                  length = length - 1
                GO TO 2921
2922            CONTINUE
                DO 2931 Kconvert=1,lnblnk1(ALLOWED_INPUTS(I,K))
                  CURSOR=ICHAR(ALLOWED_INPUTS(I,K)(Kconvert:Kconvert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                    CURSOR=CURSOR-32
                    ALLOWED_INPUTS(I,K)(Kconvert:Kconvert)=CHAR(CURSOR)
                  END IF
2931            CONTINUE
2932            CONTINUE
                IF ((ALLOWED_INPUTS(I,K).EQ.CHAR_VALUE(I,IVAL))) THEN
                  ALLOWED=.TRUE.
                  VALUE(I,IVAL)=K
                  IF (( idebug )) THEN
                    write(i_log,*) ' Found a allowed_value match ',k
                  END IF
                END IF
2911          CONTINUE
2912          CONTINUE
              IF ((.NOT.ALLOWED)) THEN
                WRITE(ERR,*) '*************ERROR*************'
                IF ((IVAL.NE.1)) THEN
                  WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                  WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY'
                  WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND
     * VALUE'
                ELSE
                  WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                  WRITE(ERR,*) 'INPUT-->', CHAR_VALUE(I,IVAL)(:lnblnk1(C
     *            HAR_VALUE(I,IVAL))), '<--NOT ALLOWED'
                  WRITE(ERR,*) 'OPTIONS ARE:'
                  WRITE(ERR,2940) (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_
     *            INPUTS(I,K))),K=0,5)
                END IF
2940            FORMAT(A40)
                ERROR_FLAG=1
                ERROR_FLAGS(I)=1
              END IF
            END IF
            IF ((vname(:ivname).EQ.'TITLE')) THEN
              GO TO2852
            END IF
            DO 2951 K=1,LEN(KEEPTEXT)
              KEEPTEXT(K:K)=' '
2951        CONTINUE
2952        CONTINUE
            KEEPTEXT(:lnblnk1(TEXT))=TEXT
            iindex = INDEX(TEXT,',')
            IF (( iindex .NE. 0 .OR. lnblnk1(TEXT).EQ.0 )) THEN
              TEXT=TEXT(INDEX(TEXT,',')+1:)
              origtext=origtext(iindex+1:)
2961          IF(lnblnk1(TEXT).NE.0)GO TO 2962
                LINE=LINE+1
                READ (UNITNUM,ERR=2870,FMT='(A256)') TEXT
                length = len(text)
2971            IF(index(text,blank).NE.1)GO TO 2972
                  IF (( length .GE. 2 )) THEN
                    text=text(2:)
                  ELSE
                    GO TO2972
                  END IF
                  length = length - 1
                GO TO 2971
2972            CONTINUE
                ifound = INDEX(text,'#')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                ifound = INDEX(text,';')
                IF (( ifound .GT. 1 )) THEN
                  text = text(1:ifound-1)
                ELSE
                  IF (( ifound .EQ. 1 )) THEN
                    text = blank
                  END IF
                END IF
                length = lnblnk1(TEXT)
                TEXT=TEXT(:length)
                origtext = text(:length)
                DO 2981 Kconvert=1,lnblnk1(text)
                  CURSOR=ICHAR(text(Kconvert:Kconvert))
                  IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                    CURSOR=CURSOR-32
                    text(Kconvert:Kconvert)=CHAR(CURSOR)
                  END IF
2981            CONTINUE
2982            CONTINUE
                DO 2991 K=1,NMAX
                  vname1 = VALUES_SOUGHT(K)
                  length = lnblnk1(vname1)
                  IF (( length .GT. 0 )) THEN
                    length = len(vname1)
3001                IF(index(vname1,blank).NE.1)GO TO 3002
                      IF (( length .GE. 2 )) THEN
                        vname1=vname1(2:)
                      ELSE
                        GO TO3002
                      END IF
                      length = length - 1
                    GO TO 3001
3002                CONTINUE
                    DO 3011 Kconvert=1,lnblnk1(vname1)
                      CURSOR=ICHAR(vname1(Kconvert:Kconvert))
                      IF (((CURSOR.GE.97).AND.(CURSOR.LE.122))) THEN
                        CURSOR=CURSOR-32
                        vname1(Kconvert:Kconvert)=CHAR(CURSOR)
                      END IF
3011                CONTINUE
3012                CONTINUE
                    IF ((INDEX(TEXT,vname1(:length)).NE.0)) THEN
                      WRITE(ERR,*) '************ERROR************'
                      WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I)
                      WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)), '<--COM
     *MA INDICATES ANOTHER INPUT'
                      WRITE(ERR,*) 'SEARCHED NEXT LINE: ', TEXT(:lnblnk1
     *                (TEXT))
                      WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED'
                      ERROR_FLAG=1
                      ERROR_FLAGS(I)=1
                    END IF
                  END IF
2991            CONTINUE
2992            CONTINUE
              GO TO 2961
2962          CONTINUE
            ELSE
              GO TO2852
            END IF
            IVAL=IVAL+1
          GO TO 2851
2852      CONTINUE
          IF (((NVALUE(I).NE.0).AND.(NVALUE(I).NE.IVAL))) THEN
            IF (( error_level .GT. 0 )) THEN
              WRITE (ERR,*) '*******************ERROR*******************
     *'
              WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I)
              WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)'
              WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED'
            END IF
            ERROR_FLAG=1
            ERROR_FLAGS(I)=1
          ELSE
            NVALUE(I)=IVAL
          END IF
        END IF
        goto 2520
2560    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '******************ERROR***********************'
          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND'
          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER'
          WRITE (ERR,*) 'VALUE SOUGHT: >>', VALUES_SOUGHT(I)(:lnblnk1(VA
     *    LUES_SOUGHT(I))),'<<'
          WRITE (ERR,*) 'END DELIMETER: >>', DELIM_END(:lnblnk1(DELIM_EN
     *    D)),'<<'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
        goto 2520
2580    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '******************ERROR***********************'
          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND'
          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER'
          WRITE (ERR,*) 'VALUE SOUGHT: >>', VALUES_SOUGHT(I)(:lnblnk1(VA
     *    LUES_SOUGHT(I))),'<<'
          WRITE (ERR,*) 'START DELIMETER: >>', DELIM_START(:lnblnk1(DELI
     *    M_START)),'<<'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
        goto 2520
2720    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '***************ERROR***************'
          IF ((IVAL.GT.1)) THEN
            J=IVAL
          ELSE
            J=1
          END IF
          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I)
          WRITE (ERR,*) 'LINE #',LINE
          WRITE (ERR,*) 'COULD NOT READ THE VALUE!!'
          WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...'
          WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPU
     *T?'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
        GOTO 2520
2870    IF (( error_level .GT. 0 )) THEN
          WRITE (ERR,*) '***************ERROR***************'
          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I)
          WRITE (ERR,*) 'LINE #',LINE
          WRITE (ERR,*) 'COULD NOT READ THE STRING !!'
        END IF
        ERROR_FLAG=1
        ERROR_FLAGS(I)=1
2520    CONTINUE
2511  CONTINUE
2512  CONTINUE
      RETURN
2570  WRITE (ERR,*) '***************ERROR***************'
      WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE
      goto 3020
3020  CONTINUE
      ERROR_FLAG=1
      ERROR_FLAGS(I)=1
      RETURN
      entry get_input_set_error_level(the_level)
      error_level = the_level
      return
      END
      subroutine get_transport_parameter(ounit)
      implicit none
      character*80 line
      character*512 toUpper
      integer*4 ounit
      integer max_med
      parameter (max_med = MXMED)
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      EGS_Float VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      common/bounds/ ecut, pcut, ecut_new, pcut_new, vacdst
      EGS_Float ecut, pcut, ecut_new, pcut_new, vacdst
      common/ET_control/ smaxir,smax_new,estepe,ximax,skindepth_for_bca,
     * transport_algorithm,bca_algorithm,exact_bca
      EGS_Float smaxir,smax_new,estepe,ximax,skindepth_for_bca
      integer*4 transport_algorithm,bca_algorithm
      logical exact_bca
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100)
      EGS_Float binding_energies, interaction_prob, relaxation_prob, edg
     *e_energies, edge_a,edge_b,edge_c,edge_d
      integer*4 edge_number
      common/compton_data/ iz_array(1538),be_array(1538), Jo_array(1538)
     *,erfJo_array(1538), ne_array(1538),shn_array(1538), shell_array(20
     *0,max_med), eno_array(200,max_med), eno_atbin_array(200,max_med),n
     *_shell(max_med)
      integer*4 iz_array,ne_array,shn_array, shell_array,eno_atbin_array
     *,n_shell
      EGS_Float be_array,Jo_array,erfJo_array,eno_array
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/misc/ DUNIT,KMPI,KMPO
      EGS_Float DUNIT
      integer*4 KMPI,KMPO
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(max_med), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(4
     *0),  eii_sh(40),  eii_nshells(100),  eii_nsh(max_med),  eii_first(
     *max_med,50),  eii_no(max_med,50)
      EGS_Float eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L
     *_factor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_nsh
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/rayleigh_inputs/iray_ff_media(max_med),iray_ff_file(max_med
     *)
      character*24 iray_ff_media
      character*128 iray_ff_file
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      EGS_Float ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_ne
     *w,By_new,Bz_new
      logical emfield_on
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      integer*4 ival,num_ecut,num_pcut,num_smax,num_incoh,num_radc,num_c
     *oh,num_relax, num_pe_ang,num_brems_ang,num_brems_cs,num_pair_cs, n
     *um_ffmed,num_ffiles, num_pair_ang,num_eii,num_eii_L,num_estepe,num
     *_ximax,num_triplet, num_pxsec,num_pxsec_out, num_cxsec, num_photon
     *uc, num_photonuc_xsec, num_efield, num_bfield, num_emlmt, num_spin
     *,num_bca,num_alg,num_skin,itmp,iitmp,i,j,k,istart,iend, egs_open_f
     *ile,lnblnk1
      logical ecut_inregions,pcut_inregions,smax_inregions, incoh_inregi
     *ons,coh_inregions,relax_inregions, pe_inregions,aux_inregions,phot
     *onuc_inregions
      character*15 output_strings(14)
      save output_strings,line
      save ecut_inregions,pcut_inregions,smax_inregions, incoh_inregions
     *,coh_inregions,relax_inregions, pe_inregions,aux_inregions,photonu
     *c_inregions, num_photonuc
      DO 3031 k=1,80
        line(k:k) = '='
3031  CONTINUE
3032  CONTINUE
      delimeter = 'MC TRANSPORT PARAMETER'
      ival = 0
      ecut_inregions=.false.
      pcut_inregions=.false.
      smax_inregions=.false.
      incoh_inregions=.false.
      coh_inregions=.false.
      relax_inregions=.false.
      pe_inregions=.false.
      aux_inregions=.false.
      photonuc_inregions=.false.
      i_errors=15
      i_errors=egs_open_file(i_errors,0,1,'.errors')
      write(i_errors,*) ' If you are not trying to reset transport param
     *eters, '
      write(i_errors,*) ' ignore all the output until the message '
      write(i_errors,*) ' ******************** end input transport param
     *eter *********************** '
      write(i_errors,*)
      ival = ival + 1
      num_ecut = ival
      values_sought(ival) = 'Global ECUT'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      num_pcut = ival
      values_sought(ival) = 'Global PCUT'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      num_smax = ival
      values_sought(ival) = 'Global SMAX'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1e15
      default(ival) = 1e10
      ival = ival + 1
      num_incoh = ival
      values_sought(ival) = 'Bound Compton scattering'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      allowed_inputs(ival,4) = 'Simple'
      allowed_inputs(ival,5) = 'norej'
      ival = ival + 1
      num_radc = ival
      values_sought(ival) = 'Radiative Compton corrections'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_coh = ival
      values_sought(ival) = 'Rayleigh scattering'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      allowed_inputs(ival,4) = 'custom'
      ival = ival + 1
      num_relax = ival
      values_sought(ival) = 'Atomic relaxations'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      allowed_inputs(ival,4) = 'eadl'
      allowed_inputs(ival,5) = 'simple'
      ival = ival + 1
      num_pe_ang = ival
      values_sought(ival) = 'Photoelectron angular sampling'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      ival = ival + 1
      num_brems_ang = ival
      values_sought(ival) = 'Brems angular sampling'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Simple'
      allowed_inputs(ival,1) = 'KM'
      ival = ival + 1
      num_brems_cs = ival
      values_sought(ival) = 'Brems cross sections'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'BH'
      allowed_inputs(ival,1) = 'NIST'
      allowed_inputs(ival,2) = 'NRC'
      ival = ival + 1
      num_pair_ang = ival
      values_sought(ival) = 'Pair angular sampling'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'Simple'
      allowed_inputs(ival,2) = 'KM'
      allowed_inputs(ival,3) = 'Uniform'
      allowed_inputs(ival,4) = 'Blend'
      ival = ival + 1
      num_pair_cs = ival
      values_sought(ival) = 'Pair cross sections'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'BH'
      allowed_inputs(ival,1) = 'NRC'
      ival = ival + 1
      num_triplet = ival
      values_sought(ival) = 'Triplet production'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_spin = ival
      values_sought(ival) = 'Spin effects'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_eii = ival
      values_sought(ival) = 'Electron Impact Ionization'
      nvalue(ival) = 1
      type(ival) = 2
      ival = ival + 1
      num_eii_L= ival
      values_sought(ival) = 'scale L EII cross-sections'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0.0
      value_max(ival) = 1.0e+9
      default(ival) = 1.0
      ival = ival + 1
      num_estepe = ival
      values_sought(ival) = 'ESTEPE'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 1e-5
      value_max(ival) = 1
      default(ival) = 0.25
      ival = ival + 1
      num_ximax = ival
      values_sought(ival) = 'XImax'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0
      value_max(ival) = 1
      default(ival) = 0.5
      ival = ival + 1
      num_bca = ival
      values_sought(ival) = 'Boundary crossing algorithm'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Exact'
      allowed_inputs(ival,1) = 'PRESTA-I'
      ival = ival + 1
      num_skin = ival
      values_sought(ival) = 'Skin depth for BCA'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = -1
      value_max(ival) = 1e15
      default(ival) = 3
      ival = ival + 1
      num_alg = ival
      values_sought(ival) = 'Electron-step algorithm'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'PRESTA-II'
      allowed_inputs(ival,1) = 'PRESTA-I'
      ival = ival + 1
      num_pxsec = ival
      values_sought(ival) = 'Photon cross sections'
      nvalue(ival) = 1
      type(ival) = 2
      ival = ival + 1
      num_pxsec_out = ival
      values_sought(ival) = 'Photon cross-sections output'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      ival = ival + 1
      num_cxsec = ival
      values_sought(ival) = 'Compton cross sections'
      nvalue(ival) = 1
      type(ival) = 2
      ival = ival + 1
      num_efield = ival
      values_sought(ival) = 'Electric Field'
      nvalue(ival) = 3
      type(ival) = 1
      value_min(ival) = -1e15
      value_max(ival) = 1e15
      default(ival) = 0
      ival = ival + 1
      num_bfield = ival
      values_sought(ival) = 'Magnetic Field'
      nvalue(ival) = 3
      type(ival) = 1
      value_min(ival) = -1e10
      value_max(ival) = 1e10
      default(ival) = 0
      ival = ival + 1
      num_emlmt = ival
      values_sought(ival) = 'EM ESTEPE'
      nvalue(ival) = 1
      type(ival) = 1
      value_min(ival) = 0.0
      value_max(ival) = 1.0
      default(ival) = 0.02
      ival = ival + 1
      num_photonuc = ival
      values_sought(ival) = 'Photonuclear attenuation'
      nvalue(ival) = 1
      type(ival) = 3
      allowed_inputs(ival,0) = 'Off'
      allowed_inputs(ival,1) = 'On'
      allowed_inputs(ival,2) = 'On in Regions'
      allowed_inputs(ival,3) = 'Off in Regions'
      ival = ival + 1
      num_photonuc_xsec = ival
      values_sought(ival) = 'Photonuclear cross sections'
      nvalue(ival) = 1
      type(ival) = 2
      Nmin = num_ecut
      Nmax = num_photonuc_xsec
      CALL GET_INPUT
      IF (( error_flags(num_ecut) .EQ. 0 )) THEN
        DO 3041 j=1,2000
          ecut = value(num_ecut,1)
3041    CONTINUE
3042    CONTINUE
      END IF
      IF (( error_flags(num_pcut) .EQ. 0 )) THEN
        DO 3051 j=1,2000
          pcut = value(num_pcut,1)
3051    CONTINUE
3052    CONTINUE
      END IF
      IF (( error_flags(num_smax) .EQ. 0 )) THEN
        DO 3061 j=1,2000
          smaxir = value(num_smax,1)
3061    CONTINUE
3062    CONTINUE
      END IF
      IF (( error_flags(num_brems_ang) .EQ. 0 )) THEN
        ibrdst = value(num_brems_ang,1)
      END IF
      IF (( error_flags(num_brems_cs) .EQ. 0 )) THEN
        ibr_nist = value(num_brems_cs,1)
      END IF
      IF (( error_flags(num_radc) .EQ. 0 )) THEN
        radc_flag = value(num_radc,1)
      END IF
      IF (( error_flags(num_pair_ang) .EQ. 0 )) THEN
        iprdst = value(num_pair_ang,1)
      END IF
      IF (( error_flags(num_pair_cs) .EQ. 0 )) THEN
        pair_nrc = value(num_pair_cs,1)
      END IF
      IF (( error_flags(num_triplet) .EQ. 0 )) THEN
        itriplet = value(num_triplet,1)
      END IF
      IF (( error_flags(num_eii_L) .EQ. 0 )) THEN
        eii_L_factor = value(num_eii_L,1)
      END IF
      IF (( error_flags(num_estepe) .EQ. 0 )) THEN
        estepe = value(num_estepe,1)
      END IF
      IF (( error_flags(num_ximax) .EQ. 0 )) THEN
        ximax = value(num_ximax,1)
      END IF
      IF (( error_flags(num_bca) .EQ. 0 )) THEN
        bca_algorithm = value(num_bca,1)
        IF (( bca_algorithm .EQ. 0 )) THEN
          exact_bca = .true.
        END IF
      END IF
      IF (( error_flags(num_alg) .EQ. 0 )) THEN
        transport_algorithm = value(num_alg,1)
      END IF
      IF (( error_flags(num_skin) .EQ. 0 )) THEN
        skindepth_for_bca = value(num_skin,1)
      END IF
      IF (( error_flags(num_spin) .EQ. 0 )) THEN
        itmp = value(num_spin,1)
        IF (( itmp .EQ. 1 )) THEN
          spin_effects = .true.
        ELSE
          spin_effects = .false.
        END IF
      END IF
      IF (( error_flags(num_eii) .EQ. 0 )) THEN
        eii_xfile = char_value(num_eii,1)
        eii_flag=1
        IF ((toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'ON' .OR. toUppe
     *  r(eii_xfile(:lnblnk1(eii_xfile))).eq.'IK' )) THEN
          eii_xfile = 'ik'
          write(i_log,*) '==> Using default EII data compilation ', eii_
     *    xfile(:lnblnk1(eii_xfile))
        ELSE IF((toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'OFF')) THEN
          eii_xfile='Off'
          eii_flag=0
        ELSE
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) '==> Using non-default EII data compilation ',
     *    eii_xfile(:lnblnk1(eii_xfile))
        END IF
      END IF
      IF (( error_flags(num_pxsec) .EQ. 0 )) THEN
        photon_xsections = char_value(num_pxsec,1)
        IF (( toUpper( photon_xsections(:lnblnk1(photon_xsections)) ) .E
     *  Q. 'MCDF-XCOM' )) THEN
          mcdf_pe_xsections = .true.
          photon_xsections = 'xcom'
        ELSE IF(( toUpper( photon_xsections(:lnblnk1(photon_xsections))
     *  ) .EQ. 'MCDF-EPDL' )) THEN
          mcdf_pe_xsections = .true.
          photon_xsections = 'epdl'
        ELSE
          mcdf_pe_xsections = .false.
        END IF
      END IF
      IF (( error_flags(num_pxsec_out) .EQ. 0 )) THEN
        xsec_out = value(num_pxsec_out,1)
      END IF
      IF (( error_flags(num_cxsec) .EQ. 0 )) THEN
        comp_xsections = char_value(num_cxsec,1)
      END IF
      IF (( error_flags(num_photonuc_xsec) .EQ. 0 )) THEN
        photonuc_xsections = char_value(num_photonuc_xsec,1)
      END IF
      IF (( error_flags(num_efield) .EQ. 0 )) THEN
        ExIN = value(num_efield,1)
        EyIN = value(num_efield,2)
        EzIN = value(num_efield,3)
        IF (( error_flags(num_emlmt) .EQ. 0 )) THEN
          EMLMTIN=value(num_emlmt,1)
        END IF
        IF (( ExIN**2+EyIN**2+EzIN**2 .GT. 0 )) THEN
          emfield_on=.true.
        END IF
      END IF
      IF (( error_flags(num_bfield) .EQ. 0 )) THEN
        BxIN = value(num_bfield,1)
        ByIN = value(num_bfield,2)
        BzIN = value(num_bfield,3)
        Bx=BxIN
        By=ByIN
        Bz=BzIN
        Bx_new=BxIN
        By_new=ByIN
        Bz_new=BzIN
        IF (( error_flags(num_emlmt) .EQ. 0 )) THEN
          EMLMTIN=value(num_emlmt,1)
        END IF
        IF (( BxIN**2+ByIN**2+BzIN**2 .GT. 0 )) THEN
          emfield_on=.true.
        END IF
      END IF
      IF (( error_flags(num_coh) .EQ. 0 )) THEN
        IF ((value(num_coh,1) .EQ. 4)) THEN
          write(*,'(/a/)') ' ===> custom ff requested!'
          ival = ival + 1
          num_ffmed = ival
          values_sought(ival) = 'ff media names'
          type(ival) = 2
          nvalue(ival) = 0
          ival = ival + 1
          num_ffiles = ival
          values_sought(ival) = 'ff file names'
          type(ival) = 2
          nvalue(ival) = 0
          Nmin = num_ffmed
          Nmax = num_ffiles
          CALL GET_INPUT
          IF (( error_flags(num_ffmed) .GT. 0 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a/,a,I3)') 'Error reading custom ff! Terminati
     *ng ...', ' error_flag = ', error_flags(num_ffmed)
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          IF (( error_flags(num_ffiles) .GT. 0 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a/,a,I3)') 'Error reading ff file names! Termi
     *nating ...', ' error_flag = ', error_flags(num_ffiles)
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          IF ((nvalue(num_ffmed).GT.max_med)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a,a,i3,a)') '***** Number of media with custom
     * ff larger ', 'than maximum number of media $MXMED = ',max_med, '
     *increase $MXMED and try again!!!'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          DO 3071 i=1,nvalue(num_ffmed)
            iray_ff_media(i) = char_value(num_ffmed,i)
            iray_ff_file(i) = char_value(num_ffiles,i)
3071      CONTINUE
3072      CONTINUE
          value(num_coh,1) = 1
        END IF
        write(*,'(/)')
      END IF
      aux_inregions = .false.
      IF (( error_flags(num_incoh) .EQ. 0 )) THEN
        write(i_log,*) 'Bound Compton start region'
        itmp = value(num_incoh,1)
        IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
          ival = ival + 1
          values_sought(ival) = 'Bound Compton start region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) = 2000
          default(ival) = 1
          ival = ival + 1
          values_sought(ival) = 'Bound Compton stop region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) = 2000
          default(ival) = 1
          Nmin = ival-1
          Nmax = ival
          CALL GET_INPUT
          IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ.
     *    0 )) THEN
            IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
              iitmp = itmp-2
              DO 3081 j=1,2000
                ibcmp = iitmp
3081          CONTINUE
3082          CONTINUE
              iitmp = 1 - iitmp
              DO 3091 k=1,nvalue(ival)
                istart = value(ival-1,k)
                iend = value(ival,k)
                write(i_log,*) 'Bound Compton start region',istart
                write(i_log,*) 'Bound Compton stop region',iend
                IF (( istart .LE. iend )) THEN
                  DO 3101 j=istart,iend
                    ibcmp = iitmp
3101              CONTINUE
3102              CONTINUE
                  aux_inregions = .true.
                END IF
3091          CONTINUE
3092          CONTINUE
            ELSE
              value(num_incoh,1) = ibcmp
            END IF
          ELSE
            value(num_incoh,1) = ibcmp
          END IF
        ELSE
          IF((itmp .GT. 3))itmp = itmp-2
          write(i_log,*) ' Setting all to ',itmp
          DO 3111 j=1,2000
            ibcmp = itmp
3111      CONTINUE
3112      CONTINUE
        END IF
      ELSE
        IF ((ibcmp .EQ. 2 .OR. ibcmp .EQ. 3)) THEN
          value(num_incoh,1) = ibcmp+2
        ELSE
          value(num_incoh,1) = ibcmp
        END IF
      END IF
      incoh_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_coh) .EQ. 0 )) THEN
        write(i_log,*) 'Rayleigh start region'
        itmp = value(num_coh,1)
        IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
          ival = ival + 1
          values_sought(ival) = 'Rayleigh start region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) = 2000
          default(ival) = 1
          ival = ival + 1
          values_sought(ival) = 'Rayleigh stop region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) = 2000
          default(ival) = 1
          Nmin = ival-1
          Nmax = ival
          CALL GET_INPUT
          IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ.
     *    0 )) THEN
            IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
              iitmp = itmp-2
              DO 3121 j=1,2000
                iraylr = iitmp
3121          CONTINUE
3122          CONTINUE
              iitmp = 1 - iitmp
              DO 3131 k=1,nvalue(ival)
                istart = value(ival-1,k)
                iend = value(ival,k)
                write(i_log,*) 'Rayleigh start region',istart
                write(i_log,*) 'Rayleigh stop region',iend
                IF (( istart .LE. iend )) THEN
                  DO 3141 j=istart,iend
                    iraylr = iitmp
3141              CONTINUE
3142              CONTINUE
                  aux_inregions = .true.
                END IF
3131          CONTINUE
3132          CONTINUE
            ELSE
              value(num_coh,1) = iraylr
            END IF
          ELSE
            value(num_coh,1) = iraylr
          END IF
        ELSE
          IF((itmp .GT. 3))itmp = itmp-2
          write(i_log,*) ' Setting all to ',itmp
          DO 3151 j=1,2000
            iraylr = itmp
3151      CONTINUE
3152      CONTINUE
        END IF
      ELSE
        IF ((iraylr .EQ. 2 .OR. iraylr .EQ. 3)) THEN
          value(num_coh,1) = iraylr+2
        ELSE
          value(num_coh,1) = iraylr
        END IF
      END IF
      coh_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_relax) .EQ. 0 )) THEN
        write(i_log,*) 'Relaxations start region'
        itmp = value(num_relax,1)
        IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
          ival = ival + 1
          values_sought(ival) = 'Relaxations start region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) = 2000
          default(ival) = 1
          ival = ival + 1
          values_sought(ival) = 'Relaxations stop region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) = 2000
          default(ival) = 1
          Nmin = ival-1
          Nmax = ival
          CALL GET_INPUT
          IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ.
     *    0 )) THEN
            IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
              iitmp = itmp-2
              DO 3161 j=1,2000
                iedgfl = iitmp
3161          CONTINUE
3162          CONTINUE
              iitmp = 1 - iitmp
              DO 3171 k=1,nvalue(ival)
                istart = value(ival-1,k)
                iend = value(ival,k)
                write(i_log,*) 'Relaxations start region',istart
                write(i_log,*) 'Relaxations stop region',iend
                IF (( istart .LE. iend )) THEN
                  DO 3181 j=istart,iend
                    iedgfl = iitmp
3181              CONTINUE
3182              CONTINUE
                  aux_inregions = .true.
                END IF
3171          CONTINUE
3172          CONTINUE
            ELSE
              value(num_relax,1) = iedgfl
            END IF
          ELSE
            value(num_relax,1) = iedgfl
          END IF
        ELSE
          IF((itmp .GT. 3))itmp = itmp-2
          write(i_log,*) ' Setting all to ',itmp
          DO 3191 j=1,2000
            iedgfl = itmp
3191      CONTINUE
3192      CONTINUE
        END IF
      ELSE
        IF ((iedgfl .EQ. 2 .OR. iedgfl .EQ. 3)) THEN
          value(num_relax,1) = iedgfl+2
        ELSE
          value(num_relax,1) = iedgfl
        END IF
      END IF
      relax_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_pe_ang) .EQ. 0 )) THEN
        write(i_log,*) 'PE sampling start region'
        itmp = value(num_pe_ang,1)
        IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
          ival = ival + 1
          values_sought(ival) = 'PE sampling start region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) = 2000
          default(ival) = 1
          ival = ival + 1
          values_sought(ival) = 'PE sampling stop region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) = 2000
          default(ival) = 1
          Nmin = ival-1
          Nmax = ival
          CALL GET_INPUT
          IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ.
     *    0 )) THEN
            IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
              iitmp = itmp-2
              DO 3201 j=1,2000
                iphter = iitmp
3201          CONTINUE
3202          CONTINUE
              iitmp = 1 - iitmp
              DO 3211 k=1,nvalue(ival)
                istart = value(ival-1,k)
                iend = value(ival,k)
                write(i_log,*) 'PE sampling start region',istart
                write(i_log,*) 'PE sampling stop region',iend
                IF (( istart .LE. iend )) THEN
                  DO 3221 j=istart,iend
                    iphter = iitmp
3221              CONTINUE
3222              CONTINUE
                  aux_inregions = .true.
                END IF
3211          CONTINUE
3212          CONTINUE
            ELSE
              value(num_pe_ang,1) = iphter
            END IF
          ELSE
            value(num_pe_ang,1) = iphter
          END IF
        ELSE
          IF((itmp .GT. 3))itmp = itmp-2
          write(i_log,*) ' Setting all to ',itmp
          DO 3231 j=1,2000
            iphter = itmp
3231      CONTINUE
3232      CONTINUE
        END IF
      ELSE
        IF ((iphter .EQ. 2 .OR. iphter .EQ. 3)) THEN
          value(num_pe_ang,1) = iphter+2
        ELSE
          value(num_pe_ang,1) = iphter
        END IF
      END IF
      pe_inregions = aux_inregions
      aux_inregions = .false.
      IF (( error_flags(num_photonuc) .EQ. 0 )) THEN
        write(i_log,*) 'Photonuclear start region'
        itmp = value(num_photonuc,1)
        IF (( itmp .EQ. 2 .OR. itmp .EQ. 3 )) THEN
          ival = ival + 1
          values_sought(ival) = 'Photonuclear start region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) = 2000
          default(ival) = 1
          ival = ival + 1
          values_sought(ival) = 'Photonuclear stop region'
          nvalue(ival) = 0
          type(ival) = 0
          value_min(ival) = 1
          value_max(ival) = 2000
          default(ival) = 1
          Nmin = ival-1
          Nmax = ival
          CALL GET_INPUT
          IF (( error_flags(ival-1) .EQ. 0 .AND. error_flags(ival) .EQ.
     *    0 )) THEN
            IF (( nvalue(ival) .EQ. nvalue(ival-1) )) THEN
              iitmp = itmp-2
              DO 3241 j=1,2000
                iphotonuc = iitmp
3241          CONTINUE
3242          CONTINUE
              iitmp = 1 - iitmp
              DO 3251 k=1,nvalue(ival)
                istart = value(ival-1,k)
                iend = value(ival,k)
                write(i_log,*) 'Photonuclear start region',istart
                write(i_log,*) 'Photonuclear stop region',iend
                IF (( istart .LE. iend )) THEN
                  DO 3261 j=istart,iend
                    iphotonuc = iitmp
3261              CONTINUE
3262              CONTINUE
                  aux_inregions = .true.
                END IF
3251          CONTINUE
3252          CONTINUE
            ELSE
              value(num_photonuc,1) = iphotonuc
            END IF
          ELSE
            value(num_photonuc,1) = iphotonuc
          END IF
        ELSE
          IF((itmp .GT. 3))itmp = itmp-2
          write(i_log,*) ' Setting all to ',itmp
          DO 3271 j=1,2000
            iphotonuc = itmp
3271      CONTINUE
3272      CONTINUE
        END IF
      ELSE
        IF ((iphotonuc .EQ. 2 .OR. iphotonuc .EQ. 3)) THEN
          value(num_photonuc,1) = iphotonuc+2
        ELSE
          value(num_photonuc,1) = iphotonuc
        END IF
      END IF
      photonuc_inregions = aux_inregions
      aux_inregions = .false.
      ival = ival + 1
      num_ecut = ival
      values_sought(ival) = 'Set ECUT'
      nvalue(ival) = 0
      type(ival) = 1
      value_min(ival) = 0.
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      values_sought(ival) = 'Set ECUT start region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) = 2000
      default(ival) = 1
      ival = ival + 1
      values_sought(ival) = 'Set ECUT stop region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) = 2000
      default(ival) = 1
      Nmin = num_ecut
      Nmax = num_ecut+2
      error_flag = 0
      CALL GET_INPUT
      IF (( error_flag .EQ. 0 )) THEN
        IF (( nvalue(num_ecut) .EQ. nvalue(ival) .AND. nvalue(ival-1) .E
     *  Q. nvalue(ival) )) THEN
          DO 3281 k=1,nvalue(ival)
            istart = value(ival-1,k)
            iend = value(ival,k)
            IF (( istart .LE. iend )) THEN
              DO 3291 j=istart,iend
                ecut = value(num_ecut,k)
3291          CONTINUE
3292          CONTINUE
              aux_inregions = .true.
            END IF
3281      CONTINUE
3282      CONTINUE
        END IF
      END IF
      ecut_inregions = aux_inregions
      aux_inregions = .false.
      ival = ival + 1
      num_pcut = ival
      values_sought(ival) = 'Set PCUT'
      nvalue(ival) = 0
      type(ival) = 1
      value_min(ival) = 0.
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      values_sought(ival) = 'Set PCUT start region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) = 2000
      default(ival) = 1
      ival = ival + 1
      values_sought(ival) = 'Set PCUT stop region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) = 2000
      default(ival) = 1
      Nmin = num_pcut
      Nmax = num_pcut+2
      error_flag = 0
      CALL GET_INPUT
      IF (( error_flag .EQ. 0 )) THEN
        IF (( nvalue(num_pcut) .EQ. nvalue(ival) .AND. nvalue(ival-1) .E
     *  Q. nvalue(ival) )) THEN
          DO 3301 k=1,nvalue(ival)
            istart = value(ival-1,k)
            iend = value(ival,k)
            IF (( istart .LE. iend )) THEN
              DO 3311 j=istart,iend
                pcut = value(num_pcut,k)
3311          CONTINUE
3312          CONTINUE
              aux_inregions = .true.
            END IF
3301      CONTINUE
3302      CONTINUE
        END IF
      END IF
      pcut_inregions = aux_inregions
      aux_inregions = .false.
      ival = ival + 1
      num_smax = ival
      values_sought(ival) = 'Set SMAX'
      nvalue(ival) = 0
      type(ival) = 1
      value_min(ival) = 0.
      value_max(ival) = 1e15
      default(ival) = 0.
      ival = ival + 1
      values_sought(ival) = 'Set SMAX start region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) = 2000
      default(ival) = 1
      ival = ival + 1
      values_sought(ival) = 'Set SMAX stop region'
      nvalue(ival) = 0
      type(ival) = 0
      value_min(ival) = 1
      value_max(ival) = 2000
      default(ival) = 1
      Nmin = num_smax
      Nmax = num_smax+2
      error_flag = 0
      CALL GET_INPUT
      IF (( error_flag .EQ. 0 )) THEN
        IF (( nvalue(num_smax) .EQ. nvalue(ival) .AND. nvalue(ival-1) .E
     *  Q. nvalue(ival) )) THEN
          DO 3321 k=1,nvalue(ival)
            istart = value(ival-1,k)
            iend = value(ival,k)
            IF (( istart .LE. iend )) THEN
              DO 3331 j=istart,iend
                smaxir = value(num_smax,k)
3331          CONTINUE
3332          CONTINUE
              aux_inregions = .true.
            END IF
3321      CONTINUE
3322      CONTINUE
        END IF
      END IF
      smax_inregions = aux_inregions
      write(i_errors,*)
      write(i_errors,*) ' ******************** end input transport param
     *eter *********************** '
      write(i_errors,*)
      IF ((value(num_relax,1) .GT. 0 .AND. value(num_relax,1) .LT. 5)) T
     *HEN
        eadl_relax = .true.
        IF ((value(num_relax,1) .EQ. 1)) THEN
          value(num_relax,1)=4
        END IF
      ELSE
        IF ((mcdf_pe_xsections .AND. value(num_relax,1) .EQ. 5)) THEN
          eadl_relax = .true.
          value(num_relax,1)=4
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,'(a/,a/,a/)') '    Simplified atomic relaxation no
     *t allowed', '    with shellwise PE cross sections. Resetting', '
     *  to detailed EADL atomic relaxation!!!'
        ELSE
          eadl_relax = .false.
        END IF
      END IF
      output_strings(1) = allowed_inputs(num_pair_ang,iprdst)
      itmp = value(num_incoh,1)
      output_strings(2) = allowed_inputs(num_incoh,itmp)
      IF (( radc_flag .EQ. 1 )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) 'You are trying to use radiative Compton correcti
     *ons'
        write(i_log,*) 'without having included rad_compton1.mortran'
        write(i_log,'(a//)') 'Turning radiative Compton corrections OFF
     *...'
        radc_flag = 0
      END IF
      output_strings(12) = allowed_inputs(num_radc,radc_flag)
      itmp = value(num_coh,1)
      output_strings(3) = allowed_inputs(num_coh,itmp)
      itmp = value(num_relax,1)
      output_strings(4) = allowed_inputs(num_relax,itmp)
      itmp = value(num_pe_ang,1)
      output_strings(5) = allowed_inputs(num_pe_ang,itmp)
      output_strings(6) = allowed_inputs(num_brems_ang,ibrdst)
      output_strings(7) = allowed_inputs(num_bca,bca_algorithm)
      output_strings(8) = allowed_inputs(num_alg,transport_algorithm)
      output_strings(9) = allowed_inputs(num_brems_cs,ibr_nist)
      output_strings(10) = allowed_inputs(num_pair_cs,pair_nrc)
      output_strings(11) = allowed_inputs(num_triplet,itriplet)
      itmp = value(num_photonuc,1)
      output_strings(14) = allowed_inputs(num_photonuc,itmp)
      entry show_transport_parameter(ounit)
      IF((ounit .LE. 0))return
      write(ounit,*)
      write(ounit,'(a)') line
      write(ounit,*)
      write(ounit,'(a,/)') '                   Electron/Photon transport
     * parameter'
      write(ounit,'(a,/)') line
      write(ounit,'(a,38x,a)') ' Photon cross sections', photon_xsection
     *s(:lnblnk1(photon_xsections))
      write(ounit,'(a,37x,a)') ' Compton cross sections', comp_xsections
     *(:lnblnk1(comp_xsections))
      write(ounit,'(a,$)') ' Photon transport cutoff(MeV)'
      IF (( pcut_inregions )) THEN
        write(ounit,'(32x,a)') 'Set in regions'
      ELSE
        IF (( pcut .GT. 1e-4 )) THEN
          write(ounit,'(32x,g14.4)') pcut
        ELSE
          write(ounit,'(32x,a)') 'AP(medium)'
        END IF
      END IF
      write(ounit,'(a,39x,a3)') ' Pair angular sampling',output_strings(
     *1)
      write(ounit,'(a,41x,a3)') ' Pair cross sections',output_strings(10
     *)
      write(ounit,'(a,42x,a3)') ' Triplet production',output_strings(11)
      write(ounit,'(a,36x,a14)') ' Bound Compton scattering',output_stri
     *ngs(2)
      write(ounit,'(a,31x,a14)') ' Radiative Compton corrections',output
     *_strings(12)
      write(ounit,'(a,41x,a14)') ' Rayleigh scattering',output_strings(3
     *)
      write(ounit,'(a,42x,a14)') ' Atomic relaxations',output_strings(4)
      write(ounit,'(a,30x,a14)') ' Photoelectron angular sampling',outpu
     *t_strings(5)
      IF (( value(num_photonuc,1) .GT. 0 )) THEN
        write(ounit,'(a,36x,a14)') ' Photonuclear attenuation',output_st
     *  rings(14)
        write(ounit,'(a,33x,a)') ' Photonuclear cross sections', photonu
     *  c_xsections(:lnblnk1(photonuc_xsections))
      END IF
      write(ounit,*)
      write(ounit,'(a,$)') ' Electron transport cutoff(MeV)'
      IF (( ecut_inregions )) THEN
        write(ounit,'(30x,a)') 'Set in regions'
      ELSE
        IF (( ecut .GT. 1e-4 )) THEN
          write(ounit,'(30x,f7.4)') ecut
        ELSE
          write(ounit,'(30x,a)') 'AE(medium)'
        END IF
      END IF
      write(ounit,'(a,30x,a4)') ' Bremsstrahlung cross sections',output_
     *strings(9)
      write(ounit,'(a,29x,a3)') ' Bremsstrahlung angular sampling',outpu
     *t_strings(6)
      IF (( spin_effects )) THEN
        write(ounit,'(a,48x,a)') ' Spin effects','On'
      ELSE
        write(ounit,'(a,48x,a)') ' Spin effects','Off'
      END IF
      write(ounit,'(a,34x,a)') ' Electron Impact Ionization',eii_xfile(:
     *lnblnk1(eii_xfile))
      IF ((eii_L_factor .NE. 1.0)) THEN
        write(ounit,'(a,25x,f6.4)') ' L-shell EII xsections scaling fact
     *or',eii_L_factor
      END IF
      write(ounit,'(a,$)') ' Maxium electron step in cm (SMAX)'
      IF (( smax_inregions )) THEN
        write(ounit,'(27x,a)') 'Set in regions'
      ELSE
        IF (( smaxir .GT. 1e-4 )) THEN
          write(ounit,'(27x,g14.4)') smaxir
        ELSE
          write(ounit,'(27x,a)') 'Restriction is off'
        END IF
      END IF
      write(ounit,'(a,16x,f6.4)') ' Maximum fractional energy loss/step
     *(ESTEPE)',estepe
      write(ounit,'(a,21x,f6.4)') ' Maximum 1st elastic moment/step (XIM
     *AX)',ximax
      write(ounit,'(a,33x,a10)') ' Boundary crossing algorithm',output_s
     *trings(7)
      write(ounit,'(a,22x,g9.4)') ' Skin-depth for boundary crossing (MF
     *P)',skindepth_for_bca
      write(ounit,'(a,37x,a10)') ' Electron-step algorithm',output_strin
     *gs(8)
      IF (( ExIN.NE.0 .OR. EyIN.NE.0 .OR. EzIN.NE.0 )) THEN
        write(ounit,'(a,38x,3f10.2)') ' Electric Field [V/cm]', ExIN,EyI
     *  N,EzIN
      END IF
      IF (( Bx.NE.0 .OR. By.NE.0 .OR. Bz.NE.0 )) THEN
        write(ounit,'(a,41x,3f10.2)') ' Magnetic Field [T]', Bx,By,Bz
      END IF
      IF (( ExIN.NE.0 .OR. EyIN.NE.0 .OR. EzIN.NE.0 .OR. Bx.NE.0 .OR. By
     *.NE.0 .OR. Bz.NE.0 )) THEN
        write(ounit,'(a,50x,f10.2)') ' EM ESTEPE',EMLMTIN
      END IF
      write(ounit,*)
      write(ounit,'(a)') line
      write(ounit,*)
      return
      end
      subroutine set_elastic_parameter
      implicit none
      integer*4 ounit
      integer max_med
      parameter (max_med = MXMED)
      COMMON/GetInput/ ALLOWED_INPUTS(100,0:5),   VALUES_SOUGHT(100),  C
     *HAR_VALUE(100,100),  VALUE(100,100),  DEFAULT(100),  VALUE_MIN(100
     *),  VALUE_MAX(100),  NVALUE(100),  TYPE(100),      ERROR_FLAGS(100
     *),   i_errors,  NMIN, NMAX,   ERROR_FLAG,  DELIMETER
      character ALLOWED_INPUTS*64,VALUES_SOUGHT*64, CHAR_VALUE*256,DELIM
     *ETER*64
      EGS_Float VALUE,DEFAULT,VALUE_MIN,VALUE_MAX
      integer*4 NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors
      COMMON/ELECIN/ esig_e(max_med),psig_e(max_med), esige_max, psige_m
     *ax, range_ep(0:1,500,max_med), E_array(500,max_med), etae_ms0(500,
     *max_med),etae_ms1(500,max_med),etap_ms0(500,max_med),etap_ms1(500,
     *max_med),q1ce_ms0(500,max_med),q1ce_ms1(500,max_med),q1cp_ms0(500,
     *max_med),q1cp_ms1(500,max_med),q2ce_ms0(500,max_med),q2ce_ms1(500,
     *max_med),q2cp_ms0(500,max_med),q2cp_ms1(500,max_med),blcce0(500,ma
     *x_med),blcce1(500,max_med), EKE0(max_med),EKE1(max_med), XR0(max_m
     *ed),TEFF0(max_med),BLCC(max_med),XCC(max_med), ESIG0(500,max_med),
     *ESIG1(500,max_med),PSIG0(500,max_med),PSIG1(500,max_med),EDEDX0(50
     *0,max_med),EDEDX1(500,max_med),PDEDX0(500,max_med),PDEDX1(500,max_
     *med),EBR10(500,max_med),EBR11(500,max_med),PBR10(500,max_med),PBR1
     *1(500,max_med),PBR20(500,max_med),PBR21(500,max_med),TMXS0(500,max
     *_med),TMXS1(500,max_med), expeke1(max_med), IUNRST(max_med),EPSTFL
     *(max_med),IAPRIM(max_med), sig_ismonotone(0:1,max_med)
      EGS_Float esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E
     *_array,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1
     *,  q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blc
     *ce0,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG
     *0,ESIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR1
     *1,  PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 imed,ival,lnblnk1,nchanged
      character*24 medname
      ounit = i_log
      ounit = i_log
      delimeter = 'MC TRANSPORT PARAMETER'
      call get_input_set_error_level(0)
      ival = 0
      DO 3341 imed=1,nmed
        call egs_get_medium_name(imed,medname)
        ival = ival + 1
        values_sought(ival) = 'scale elastic scattering in '// medname(:
     *  lnblnk1(medname))
        nvalue(ival) = 1
        type(ival) = 1
        value_min(ival) = 1e-3
        value_max(ival) = 1e3
        default(ival) = 1
3341  CONTINUE
3342  CONTINUE
      Nmin = 1
      Nmax = nmed
      CALL GET_INPUT
      nchanged = 0
      DO 3351 imed=1,nmed
        IF((error_flags(imed) .EQ. 0))nchanged = nchanged + 1
3351  CONTINUE
3352  CONTINUE
      IF (( nchanged .GT. 0 )) THEN
        write(ounit,'(//a)') '================ Elastic scattering scaled
     * as follows =================='
        DO 3361 imed=1,nmed
          IF (( error_flags(imed) .EQ. 0 )) THEN
            call egs_get_medium_name(imed,medname)
            xcc(imed) = xcc(imed)*value(imed,1)
            blcc(imed) = blcc(imed)*value(imed,1)
            write(ounit,'(a,t30,f10.6)') medname(:lnblnk1(medname)), val
     *      ue(imed,1)
          END IF
3361    CONTINUE
3362    CONTINUE
        write(ounit,'(a//)') '==========================================
     *=============================='
      END IF
      return
      end
      SUBROUTINE ANNIH
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common/egs_vr/ e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_
     *RR, i_survived_RR, n_RR_warning, i_do_rr
      EGS_Float e_max_rr,e_max_rr_new,prob_RR
      integer*4 nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DOUBLE PRECISION PAVIP,  PESG1,  PESG2
      EGS_Float AVIP,  A,                  G,T,P,                      P
     *OT,
     *        EP0,                                                 WSAMP
     *,                         RNNO01,
     *                        RNNO02,
     *                                      EP,
     *    REJF,                                                       ES
     *G1,                                      ESG2,
     *                  aa,bb,cc,sinpsi,sindel,cosdel,us,vs,cphi,sphi
      integer*4
     *                     ibr
      EGS_Float xphi,xphi2,yphi,yphi2,rhophi2
      integer*4 ip
      NPold = NP
      IF (( nbr_split .LE. 0 )) THEN
        return
      END IF
      PAVIP=E(NP)+PRM
      AVIP=PAVIP
      A=AVIP/RM
      G=A-1.0
      T=G-1.0
      P=SQRT(A*T)
      POT=P/T
      EP0=1.0/(A+P)
      WSAMP=LOG((1.0-EP0)/EP0)
      aa = u(np)
      bb = v(np)
      cc = w(np)
      sinpsi = aa*aa + bb*bb
      IF (( sinpsi .GT. 1e-20 )) THEN
        sinpsi = sqrt(sinpsi)
        sindel = bb/sinpsi
        cosdel = aa/sinpsi
      END IF
      IF (( nbr_split .GT. 1 )) THEN
        wt(np) = wt(np)/nbr_split
      END IF
      DO 3371 ibr=1,nbr_split
        IF (( np+1 .GT. max_stack )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//a,i6,a//)') ' Stack overflow in ANNIH! np = ',
     *    np+1, ' Increase $MXSTACK and try again'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
3381    CONTINUE
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          RNNO01 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          EP=EP0*EXP(RNNO01*WSAMP)
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          RNNO02 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          REJF = 1 - (EP*A-1)**2/(EP*(A*A-2))
          IF(((RNNO02 .LE. REJF)))GO TO3382
        GO TO 3381
3382    CONTINUE
        ESG1=AVIP*EP
        PESG1=ESG1
        E(NP)=PESG1
        IQ(NP)=0
        IF (( ibr .EQ. 1 )) THEN
          ip = npold
        ELSE
          ip = np-1
        END IF
        X(np)=X(ip)
        Y(np)=Y(ip)
        Z(np)=Z(ip)
        IR(np)=IR(ip)
        WT(np)=WT(ip)
        DNEAR(np)=DNEAR(ip)
        LATCH(np)=LATCH(ip)
        COSTHE=MAX(-1.0,MIN(1.0,(ESG1-RM)*POT/ESG1))
        SINTHE=SQRT(1.0-COSTHE*COSTHE)
3391    CONTINUE
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          xphi = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          xphi = 2*xphi - 1
          xphi2 = xphi*xphi
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          yphi = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          yphi2 = yphi*yphi
          rhophi2 = xphi2 + yphi2
          IF(rhophi2.LE.1)GO TO3392
        GO TO 3391
3392    CONTINUE
        rhophi2 = 1/rhophi2
        cphi = (xphi2 - yphi2)*rhophi2
        sphi = 2*xphi*yphi*rhophi2
        IF (( sinpsi .GE. 1e-10 )) THEN
          us = sinthe*cphi
          vs = sinthe*sphi
          u(np) = cc*cosdel*us - sindel*vs + aa*costhe
          v(np) = cc*sindel*us + cosdel*vs + bb*costhe
          w(np) = cc*costhe - sinpsi*us
        ELSE
          u(np) = sinthe*cphi
          v(np) = sinthe*sphi
          w(np) = cc*costhe
        END IF
        np = np + 1
        PESG2=PAVIP-PESG1
        esg2 = pesg2
        e(np) = pesg2
        iq(np) = 0
        X(np)=X(np-1)
        Y(np)=Y(np-1)
        Z(np)=Z(np-1)
        IR(np)=IR(np-1)
        WT(np)=WT(np-1)
        DNEAR(np)=DNEAR(np-1)
        LATCH(np)=LATCH(np-1)
        COSTHE=MAX(-1.0,MIN(1.0,(ESG2-RM)*POT/ESG2))
        SINTHE=-SQRT(1.0-COSTHE*COSTHE)
        IF (( sinpsi .GE. 1e-10 )) THEN
          us = sinthe*cphi
          vs = sinthe*sphi
          u(np) = cc*cosdel*us - sindel*vs + aa*costhe
          v(np) = cc*sindel*us + cosdel*vs + bb*costhe
          w(np) = cc*costhe - sinpsi*us
        ELSE
          u(np) = sinthe*cphi
          v(np) = sinthe*sphi
          w(np) = cc*costhe
        END IF
        np = np + 1
3371  CONTINUE
3372  CONTINUE
      np = np-1
      RETURN
      END
      SUBROUTINE ANNIH_AT_REST
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/egs_vr/ e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_
     *RR, i_survived_RR, n_RR_warning, i_do_rr
      EGS_Float e_max_rr,e_max_rr_new,prob_RR
      integer*4 nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      EGS_Float costhe,sinthe,cphi,sphi
      integer*4 ibr,ip
      EGS_Float xphi,xphi2,yphi,yphi2,rhophi2
      NPold = NP
      IF (( np+2*nbr_split-1 .GT. max_stack )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','ANNIH_AT_RES
     *T', ' stack size exceeded! ',' $MAXSTACK = ',max_stack,' np = ',np
     *  +2*nbr_split-1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( nbr_split .GT. 1 )) THEN
        wt(np) = wt(np)/nbr_split
      END IF
      DO 3401 ibr=1,nbr_split
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        costhe = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        costhe = 2*costhe-1
        sinthe = sqrt(max(0.0,(1-costhe)*(1+costhe)))
3411    CONTINUE
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          xphi = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          xphi = 2*xphi - 1
          xphi2 = xphi*xphi
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          yphi = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          yphi2 = yphi*yphi
          rhophi2 = xphi2 + yphi2
          IF(rhophi2.LE.1)GO TO3412
        GO TO 3411
3412    CONTINUE
        rhophi2 = 1/rhophi2
        cphi = (xphi2 - yphi2)*rhophi2
        sphi = 2*xphi*yphi*rhophi2
        e(np) = prm
        iq(np) = 0
        IF (( ibr .EQ. 1 )) THEN
          ip = npold
        ELSE
          ip = np-1
        END IF
        X(np)=X(ip)
        Y(np)=Y(ip)
        Z(np)=Z(ip)
        IR(np)=IR(ip)
        WT(np)=WT(ip)
        DNEAR(np)=DNEAR(ip)
        LATCH(np)=LATCH(ip)
        u(np) = sinthe*cphi
        v(np) = sinthe*sphi
        w(np) = costhe
        np = np+1
        e(np) = prm
        iq(np) = 0
        X(np)=X(np-1)
        Y(np)=Y(np-1)
        Z(np)=Z(np-1)
        IR(np)=IR(np-1)
        WT(np)=WT(np-1)
        DNEAR(np)=DNEAR(np-1)
        LATCH(np)=LATCH(np-1)
        u(np) = -u(np-1)
        v(np) = -v(np-1)
        w(np) = -w(np-1)
        np = np+1
3401  CONTINUE
3402  CONTINUE
      np = np-1
      return
      end
      SUBROUTINE BHABHA
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common/egs_vr/ e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_
     *RR, i_survived_RR, n_RR_warning, i_do_rr
      EGS_Float e_max_rr,e_max_rr_new,prob_RR
      integer*4 nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      DOUBLE PRECISION PEIP,  PEKIN,  PEKSE2,  PESE1,  PESE2,  H1,  DCOS
     *TH
      EGS_Float EIP,  EKIN,  T0,  E0,  E02,  YY,  Y2,YP,YP2, BETA2,  EP0
     *,  EP0C,  B1,B2,B3,B4,  RNNO03,RNNO04, BR,  REJF2,  ESE1,  ESE2
      NPold = NP
      PEIP=E(NP)
      EIP=PEIP
      PEKIN=PEIP-PRM
      EKIN=PEKIN
      T0=EKIN/RM
      E0=T0+1.
      YY=1./(T0+2.)
      E02=E0*E0
      BETA2=(E02-1.)/E02
      EP0=TE(MEDIUM)/EKIN
      EP0C=1.-EP0
      Y2=YY*YY
      YP=1.-2.*YY
      YP2=YP*YP
      B4=YP2*YP
      B3=B4+YP2
      B2=YP*(3.+Y2)
      B1=2.-Y2
3421  CONTINUE
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        RNNO03 = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        BR=EP0/(1.-EP0C*RNNO03)
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        RNNO04 = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        REJF2=(1.0-BETA2*BR*(B1-BR*(B2-BR*(B3-BR*B4))))
        IF((RNNO04.LE.REJF2))GO TO3422
      GO TO 3421
3422  CONTINUE
      IF (( np+1 .GT. max_stack )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','BHABHA', ' s
     *tack size exceeded! ',' $MAXSTACK = ',max_stack,' np = ',np+1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF ((BR.LT.0.5)) THEN
        IQ(NP+1)=-1
      ELSE
        IQ(NP)=-1
        IQ(NP+1)=1
        BR=1.-BR
      END IF
      BR=max(BR,0.0)
      PEKSE2=BR*EKIN
      PESE1=PEIP-PEKSE2
      PESE2=PEKSE2+PRM
      ESE1=PESE1
      ESE2=PESE2
      E(NP)=PESE1
      E(NP+1)=PESE2
      H1=(PEIP+PRM)/PEKIN
      DCOSTH=MIN(1.0D0,H1*(PESE1-PRM)/(PESE1+PRM))
      SINTHE=DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(2,1)
      NP=NP+1
      DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM)
      SINTHE=-DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(3,2)
      RETURN
      END
      SUBROUTINE BREMS
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/nist_brems/ nb_fdata(0:50,100,max_med), nb_xdata(0:50,100,m
     *ax_med), nb_wdata(50,100,max_med), nb_idata(50,100,max_med), nb_em
     *in(max_med),nb_emax(max_med), nb_lemin(max_med),nb_lemax(max_med),
     * nb_dle(max_med),nb_dlei(max_med), log_ap(max_med)
      EGS_Float nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_l
     *emax, nb_dle,nb_dlei,log_ap
      integer*4 nb_idata
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common/egs_vr/ e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_
     *RR, i_survived_RR, n_RR_warning, i_do_rr
      EGS_Float e_max_rr,e_max_rr_new,prob_RR
      integer*4 nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      DOUBLE PRECISION PEIE,  PESG,  PESE
      EGS_Float EIE,  EKIN,  brmin,  waux,  aux,  r1,  ajj,  alias_sampl
     *e1, RNNO06,  RNNO07,  BR,  ESG,  ESE,  DELTA,  phi1,  phi2,  REJF
      EGS_Float a,b,c,                               sinpsi, sindel, cos
     *del, us, vs,
     *                                                   ztarg,
     *                tteie,                                    beta,
     *                          y2max,
     *         y2maxi,
     * ttese,                                      rjarg1,rjarg2,rjarg3,
     *rejmin,rejmid,rejmax,rejtop,rejtst,
     *                    esedei,                                 y2tst,
     *                                y2tst1,
     *                                              rtest,
     *                               xphi,yphi,xphi2,yphi2,rhophi2,cphi,
     *sphi
      integer*4
     *                 L,L1,ibr,jj,j
      EGS_Float z2max,z2maxi,aux1,aux3,aux4,aux5,aux2,weight
      IF((nbr_split .LT. 1))return
      NPold = NP
      PEIE=E(NP)
      EIE=PEIE
      weight = wt(np)/nbr_split
      IF ((EIE.LT.50.0)) THEN
        L=1
      ELSE
        L=3
      END IF
      L1 = L+1
      ekin = peie-prm
      brmin = ap(medium)/ekin
      waux = elke - log_ap(medium)
      IF (( ibrdst .GE. 0 )) THEN
        a = u(np)
        b = v(np)
        c = w(np)
        sinpsi = a*a + b*b
        IF (( sinpsi .GT. 1e-20 )) THEN
          sinpsi = sqrt(sinpsi)
          sindel = b/sinpsi
          cosdel = a/sinpsi
        END IF
        ztarg = zbrang(medium)
        tteie = eie/rm
        beta = sqrt((tteie-1)*(tteie+1))/tteie
        y2max = 2*beta*(1+beta)*tteie*tteie
        y2maxi = 1/y2max
        IF (( ibrdst .EQ. 1 )) THEN
          z2max = y2max+1
          z2maxi = sqrt(z2max)
        END IF
      END IF
      IF (( ibr_nist .GE. 1 )) THEN
        ajj = 1 + (waux + log_ap(medium) - nb_lemin(medium))*nb_dlei(med
     *  ium)
        jj = ajj
        ajj = ajj - jj
        IF (( jj .GT. 100 )) THEN
          jj = 100
          ajj = -1
        END IF
      END IF
      DO 3431 ibr=1,nbr_split
        IF (( ibr_nist .GE. 1 )) THEN
          IF (( ekin .GT. nb_emin(medium) )) THEN
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            r1 = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            IF (( r1 .LT. ajj )) THEN
              j = jj+1
            ELSE
              j = jj
            END IF
            br = alias_sample1(50,nb_xdata(0,j,medium), nb_fdata(0,j,med
     *      ium), nb_wdata(1,j,medium),nb_idata(1,j,medium))
          ELSE
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            br = rng_array(rng_seed)
            rng_seed = rng_seed + 1
          END IF
          esg = ap(medium)*exp(br*waux)
          pesg = esg
          pese = peie - pesg
          ese = pese
        ELSE
3441      CONTINUE
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            rnno06 = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            rnno07 = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            br = brmin*exp(rnno06*waux)
            esg = ekin*br
            pesg = esg
            pese = peie - pesg
            ese = pese
            delta = esg/eie/ese*delcm(medium)
            aux = ese/eie
            IF (( delta .LT. 1 )) THEN
              phi1 = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medi
     *        um))
              phi2 = dl1(l1,medium)+delta*(dl2(l1,medium)+ delta*dl3(l1,
     *        medium))
            ELSE
              phi1 = dl4(l,medium)+dl5(l,medium)*log(delta+dl6(l,medium)
     *        )
              phi2 = phi1
            END IF
            rejf = (1+aux*aux)*phi1 - 2*aux*phi2/3
            IF(((rnno07 .LT. rejf)))GO TO3442
          GO TO 3441
3442      CONTINUE
        END IF
        np=np+1
        IF (( np .GT. max_stack )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//a,i6,a//)') ' Stack overflow in BREMS! np = ',
     *    np+1, ' Increase $MXSTACK and try again'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        e(np) = pesg
        iq(np) = 0
        X(np)=X(np-1)
        Y(np)=Y(np-1)
        Z(np)=Z(np-1)
        IR(np)=IR(np-1)
        WT(np)=WT(np-1)
        DNEAR(np)=DNEAR(np-1)
        LATCH(np)=LATCH(np-1)
        wt(np) = weight
        IF (( ibrdst .LT. 0 )) THEN
          u(np) = u(npold)
          v(np) = v(npold)
          w(np) = w(npold)
        ELSE
          IF (( ibrdst .EQ. 1 )) THEN
            ttese = ese/rm
            esedei = ttese/tteie
            rjarg1 = 1+esedei*esedei
            rjarg2 = rjarg1 + 2*esedei
            aux = 2*ese*tteie/esg
            aux = aux*aux
            aux1 = aux*ztarg
            IF (( aux1 .GT. 10 )) THEN
              rjarg3 = lzbrang(medium) + (1-aux1)/aux1**2
            ELSE
              rjarg3 = log(aux/(1+aux1))
            END IF
            rejmax = rjarg1*rjarg3-rjarg2
3451        CONTINUE
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              y2tst = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              rtest = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              aux3 = z2maxi/(y2tst+(1-y2tst)*z2maxi)
              rtest = rtest*aux3*rejmax
              y2tst = aux3**2-1
              y2tst1 = esedei*y2tst/aux3**4
              aux4 = 16*y2tst1-rjarg2
              aux5 = rjarg1-4*y2tst1
              IF((rtest .LT. aux4 + aux5*rjarg3))GO TO3452
              aux2 = log(aux/(1+aux1/aux3**4))
              rejtst = aux4+aux5*aux2
              IF(((rtest .LT. rejtst )))GO TO3452
            GO TO 3451
3452        CONTINUE
          ELSE
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            y2tst = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            y2tst = y2tst/(1-y2tst+y2maxi)
          END IF
          costhe = 1 - 2*y2tst*y2maxi
          sinthe = sqrt(max((1-costhe)*(1+costhe),0.0))
3461      CONTINUE
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            xphi = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            xphi = 2*xphi - 1
            xphi2 = xphi*xphi
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            yphi = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            yphi2 = yphi*yphi
            rhophi2 = xphi2 + yphi2
            IF(rhophi2.LE.1)GO TO3462
          GO TO 3461
3462      CONTINUE
          rhophi2 = 1/rhophi2
          cphi = (xphi2 - yphi2)*rhophi2
          sphi = 2*xphi*yphi*rhophi2
          IF (( sinpsi .GE. 1e-10 )) THEN
            us = sinthe*cphi
            vs = sinthe*sphi
            u(np) = c*cosdel*us - sindel*vs + a*costhe
            v(np) = c*sindel*us + cosdel*vs + b*costhe
            w(np) = c*costhe - sinpsi*us
          ELSE
            u(np) = sinthe*cphi
            v(np) = sinthe*sphi
            w(np) = c*costhe
          END IF
        END IF
3431  CONTINUE
3432  CONTINUE
      e(npold) = pese
      RETURN
      END
      SUBROUTINE COMPT
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common/compton_data/ iz_array(1538),be_array(1538), Jo_array(1538)
     *,erfJo_array(1538), ne_array(1538),shn_array(1538), shell_array(20
     *0,max_med), eno_array(200,max_med), eno_atbin_array(200,max_med),n
     *_shell(max_med)
      integer*4 iz_array,ne_array,shn_array, shell_array,eno_atbin_array
     *,n_shell
      EGS_Float be_array,Jo_array,erfJo_array,eno_array
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common/egs_vr/ e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_
     *RR, i_survived_RR, n_RR_warning, i_do_rr
      EGS_Float e_max_rr,e_max_rr_new,prob_RR
      integer*4 nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      EGS_Float relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      DOUBLE PRECISION PEIG,  PESG,  PESE
      EGS_Float ko,  broi,  broi2,  bro,  bro1,  alph1,  alph2,  alpha,
     * rnno15,rnno16,rnno17,rnno18,rnno19,  br,  temp,  rejf3,  rejmax,
     * Uj,  Jo,  br2,  fpz,fpz1, qc,  qc2,  af,  Fmax,  frej,  eta_incoh
     *, eta,  aux,aux1,aux2,aux3,aux4,  pzmax,  pz,  pz2,  rnno_RR
      integer*4 irl,  i,  j,  iarg,  ip
      logical first_time
      integer*4 ibcmpl
      NPold = NP
      peig=E(NP)
      ko = peig/rm
      broi = 1 + 2*ko
      irl = ir(np)
      first_time = .true.
      ibcmpl = ibcmp
3470  CONTINUE
      IF (( ibcmpl .GT. 0 )) THEN
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        rnno17 = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        rnno17 = 1 + rnno17*n_shell(medium)
        i = int(rnno17)
        IF((rnno17 .GT. eno_array(i,medium)))i = eno_atbin_array(i,mediu
     *  m)
        j = shell_array(i,medium)
        Uj = be_array(j)
        IF (( ko .LE. Uj )) THEN
          IF (( ibcmpl .EQ. 1 )) THEN
            goto 3480
          ELSE
            goto 3470
          END IF
        END IF
        Jo = Jo_array(j)
      END IF
3490  CONTINUE
      IF (( ko .GT. 2 )) THEN
        IF (( first_time )) THEN
          broi2 = broi*broi
          alph1 = Log(broi)
          bro = 1/broi
          alph2 = ko*(broi+1)*bro*bro
          alpha = alph1+alph2
        END IF
3501    CONTINUE
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnno15 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnno16 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF (( rnno15*alpha .LT. alph1 )) THEN
            br = Exp(alph1*rnno16)*bro
          ELSE
            br = Sqrt(rnno16*broi2 + (1-rnno16))*bro
          END IF
          temp = (1-br)/(ko*br)
          sinthe = Max(0.,temp*(2-temp))
          aux = 1+br*br
          rejf3 = aux - br*sinthe
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnno19 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF((rnno19*aux.le.rejf3))GO TO3502
        GO TO 3501
3502    CONTINUE
      ELSE
        IF (( first_time )) THEN
          bro = 1./broi
          bro1 = 1 - bro
          rejmax = broi + bro
        END IF
3511    CONTINUE
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnno15 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnno16 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          br = bro + bro1*rnno15
          temp = (1-br)/(ko*br)
          sinthe = Max(0.,temp*(2-temp))
          rejf3 = 1 + br*br - br*sinthe
          IF((rnno16*br*rejmax.le.rejf3))GO TO3512
        GO TO 3511
3512    CONTINUE
      END IF
      first_time = .false.
      IF ((br .LT. bro .OR. br .GT. 1)) THEN
        IF (( br .LT. 0.99999/broi .OR. br .GT. 1.00001 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' sampled br outside of allowed range! ',ko,1./
     *    broi,br
        END IF
        goto 3490
      END IF
      costhe = 1 - temp
      IF (( ibcmp .EQ. 0 )) THEN
        Uj = 0
        goto 3520
      END IF
      br2 = br*br
      aux = ko*(ko-Uj)*temp
      aux1 = 2*aux + Uj*Uj
      pzmax = aux - Uj
      IF (( pzmax .LT. 0 .AND. pzmax*pzmax .GE. aux1 )) THEN
        IF (( ibcmpl .EQ. 1 )) THEN
          goto 3480
        ELSE
          goto 3470
        END IF
      END IF
      pzmax = pzmax/sqrt(aux1)
      qc2 = 1 + br*br - 2*br*costhe
      qc = sqrt(qc2)
      IF (( pzmax .GT. 1 )) THEN
        pzmax = 1
        af = 0
        Fmax = 1
        fpz = 1
        goto 3530
      END IF
      aux3 = 1 + 2*Jo*abs(pzmax)
      aux4 = 0.5*(1-aux3*aux3)
      fpz = 0.5*exp(aux4)
      af = qc*(1+br*(br-costhe)/qc2)
      IF (( af .LT. 0 )) THEN
        IF((pzmax .GT. 0))fpz = 1 - fpz
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        eta_incoh = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        IF (( eta_incoh .GT. fpz )) THEN
          IF (( ibcmpl .EQ. 1 )) THEN
            goto 3480
          ELSE
            goto 3470
          END IF
        END IF
        af = 0
        Fmax = 1
        goto 3530
      END IF
      IF (( pzmax .LT. -0.15 )) THEN
        Fmax = 1-af*0.15
        fpz1 = fpz*Fmax*Jo
      ELSE IF(( pzmax .LT. 0.15 )) THEN
        Fmax = 1 + af*pzmax
        aux3 = 1/(1+0.33267252734*aux3)
        aux4 = fpz*aux3*(0.3480242+aux3*(-0.0958798+aux3*0.7478556)) + e
     *  rfJo_array(j)
        IF (( pzmax .GT. 0 )) THEN
          fpz1 = (1 - Fmax*fpz)*Jo - 0.62665706866*af*aux4
          fpz = 1 - fpz
        ELSE
          fpz1 = Fmax*fpz*Jo - 0.62665706866*af*aux4
        END IF
      ELSE
        Fmax = 1 + af*0.15
        fpz1 = (1 - Fmax*fpz)*Jo
        fpz = 1 - fpz
      END IF
      IF (( rng_seed .GT. 128 )) THEN
        rng_seed = 128
        call egs_fill_rndm_array(rng_seed,rng_array)
        rng_seed = 1
      END IF
      eta_incoh = rng_array(rng_seed)
      rng_seed = rng_seed + 1
      IF ((eta_incoh*Jo .GT. fpz1 )) THEN
        IF (( ibcmpl .EQ. 1 )) THEN
          goto 3480
        ELSE
          goto 3470
        END IF
      END IF
3530  CONTINUE
      IF (( ibcmpl .NE. 2 )) THEN
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        rnno18 = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        rnno18 = rnno18*fpz
        IF (( rnno18 .LT. 0.5 )) THEN
          rnno18 = Max(1e-30,2*rnno18)
          pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo
        ELSE
          rnno18 = 2*(1-rnno18)
          pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo
        END IF
        IF((abs(pz) .GT. 1))goto 3530
        IF (( pz .LT. 0.15 )) THEN
          IF (( pz .LT. -0.15 )) THEN
            frej = 1 - af*0.15
          ELSE
            frej = 1 + af*pz
          END IF
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          eta = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF((eta*Fmax .GT. frej))goto 3530
        END IF
      ELSE
        pz = 0
        Uj = 0
      END IF
      pz2 = pz*pz
      IF (( abs(pz) .LT. 0.01 )) THEN
        br = br*(1 + pz*(qc + (br2-costhe)*pz))
      ELSE
        aux = 1 - pz2*br*costhe
        aux1 = 1 - pz2*br2
        aux2 = qc2 - br2*pz2*sinthe
        IF (( aux2 .GT. 1e-10 )) THEN
          br = br/aux1*(aux+pz*Sqrt(aux2))
        END IF
      END IF
      Uj = Uj*prm
3520  pesg = br*peig
      pese = peig - pesg - Uj + prm
      sinthe = Sqrt(sinthe)
      call uphi(2,1)
      e(np) = pesg
      aux = 1 + br*br - 2*br*costhe
      IF (( aux .GT. 1e-8 )) THEN
        costhe = (1-br*costhe)/Sqrt(aux)
        sinthe = (1-costhe)*(1+costhe)
        IF (( sinthe .GT. 0 )) THEN
          sinthe = -Sqrt(sinthe)
        ELSE
          sinthe = 0
        END IF
      ELSE
        costhe = 0
        sinthe = -1
      END IF
      np = np + 1
      IF (( np .GT. max_stack )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','COMPT', ' st
     *ack size exceeded! ',' $MAXSTACK = ',max_stack,' np = ',np
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      call uphi(3,2)
      e(np) = pese
      iq(np) = -1
      IF (( ibcmpl .EQ. 1 .OR. ibcmpl .EQ. 3 )) THEN
        IF (( Uj .GT. 1e-3 )) THEN
          edep = pzero
          call relax(Uj,shn_array(j),iz_array(j))
        ELSE
          edep = Uj
          edep_local = edep
          iarg=33
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
        END IF
        IF (( edep .GT. 0 )) THEN
          iarg=4
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,3540)prob_RR
3540        FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold+1
3551      CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              rnno_RR = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO3552
          GO TO 3551
3552      CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
3480  return
      end
      SUBROUTINE old_COMPT
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common/compton_data/ iz_array(1538),be_array(1538), Jo_array(1538)
     *,erfJo_array(1538), ne_array(1538),shn_array(1538), shell_array(20
     *0,max_med), eno_array(200,max_med), eno_atbin_array(200,max_med),n
     *_shell(max_med)
      integer*4 iz_array,ne_array,shn_array, shell_array,eno_atbin_array
     *,n_shell
      EGS_Float be_array,Jo_array,erfJo_array,eno_array
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common/egs_vr/ e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_
     *RR, i_survived_RR, n_RR_warning, i_do_rr
      EGS_Float e_max_rr,e_max_rr_new,prob_RR
      integer*4 nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      EGS_Float relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      DOUBLE PRECISION PEIG,  PESG,  PESE
      EGS_Float ko,  broi,  broi2,  bro,  bro1,  alph1,  alph2,  alpha,
     * rnno15,rnno16,rnno17,rnno18,rnno19,  br,  temp,  rejf3,  rejmax,
     * Uj,  br2,  aux,aux1,aux2, pzmax2,  pz,  pz2,  rnno_RR
      integer*4 irl,  i,  j,  iarg,  ip
      i_survived_RR = 0
      NPold = NP
      peig=E(NP)
      ko = peig/rm
      broi = 1 + 2*ko
      irl = ir(np)
      IF (( ibcmp .EQ. 1 )) THEN
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        rnno17 = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        DO 3561 i=1,n_shell(medium)
          rnno17 = rnno17 - eno_array(i,medium)
          IF((rnno17 .LE. 0))GO TO3562
3561    CONTINUE
3562    CONTINUE
        j = shell_array(i,medium)
        Uj = be_array(j)
        IF (( ko .LE. Uj )) THEN
          goto 3570
        END IF
      END IF
3580  CONTINUE
      IF (( ko .GT. 2 )) THEN
        broi2 = broi*broi
        alph1 = Log(broi)
        alph2 = ko*(broi+1)/broi2
        alpha = alph1/(alph1+alph2)
3591    CONTINUE
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnno15 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnno16 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF (( rnno15 .LT. alpha )) THEN
            br = Exp(alph1*rnno16)/broi
          ELSE
            br = Sqrt(rnno16 + (1-rnno16)/broi2)
          END IF
          temp = (1-br)/ko/br
          sinthe = Max(0.,temp*(2-temp))
          rejf3 = 1 - br*sinthe/(1+br*br)
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnno19 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF((rnno19.le.rejf3))GO TO3592
        GO TO 3591
3592    CONTINUE
      ELSE
        bro = 1./broi
        bro1 = 1 - bro
        rejmax = broi + bro
3601    CONTINUE
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnno15 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnno16 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          br = bro + bro1*rnno15
          temp = (1-br)/ko/br
          sinthe = Max(0.,temp*(2-temp))
          rejf3 = (br + 1./br - sinthe)/rejmax
          IF((rnno16.le.rejf3))GO TO3602
        GO TO 3601
3602    CONTINUE
      END IF
      IF ((br .LT. 1./broi .OR. br .GT. 1)) THEN
        IF (( br .LT. 0.99999/broi .OR. br .GT. 1.00001 )) THEN
          write(i_log,'(/a)') '***************** Warning: '
          write(i_log,*) ' sampled br outside of allowed range! ',ko,1./
     *    broi,br
        END IF
        goto 3580
      END IF
      IF (( ibcmp .EQ. 0 )) THEN
        Uj = 0
        costhe = 1 - temp
        goto 3610
      END IF
      br2 = br*br
      costhe = 1 - temp
      aux = ko*(ko-Uj)*temp
      aux1 = aux-Uj
      pzmax2 = aux1*aux1/(2*aux+Uj*Uj)
3620  CONTINUE
      IF (( rng_seed .GT. 128 )) THEN
        rng_seed = 128
        call egs_fill_rndm_array(rng_seed,rng_array)
        rng_seed = 1
      END IF
      rnno18 = rng_array(rng_seed)
      rng_seed = rng_seed + 1
      IF (( rnno18 .LT. 0.5 )) THEN
        rnno18 = Max(1e-30,2*rnno18)
        pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo_array(j)
        pz2 = pz*pz
        IF (( (pz2 .LE. pzmax2) .AND. (aux1 .LT. 0) )) THEN
          goto 3570
        END IF
      ELSE
        IF (( aux1 .LT. 0 )) THEN
          goto 3570
        END IF
        rnno18 = 2*(1-rnno18)
        pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo_array(j)
        pz2 = pz*pz
        IF (( pz2 .GE. pzmax2 )) THEN
          goto 3570
        END IF
      END IF
      IF((abs(pz) .GT. 1))goto 3620
      aux = 1 - pz2*br*costhe
      aux1 = 1 - pz2*br2
      aux2 = 1-2*br*costhe+br2*(1-pz2*sinthe)
      IF (( aux2 .GT. 1e-10 )) THEN
        br = br/aux1*(aux+pz*Sqrt(aux2))
      END IF
      Uj = Uj*prm
3610  pesg = br*peig
      pese = peig - pesg - Uj + prm
      sinthe = Sqrt(sinthe)
      call uphi(2,1)
      e(np) = pesg
      aux = 1 + br*br - 2*br*costhe
      IF (( aux .GT. 1e-8 )) THEN
        costhe = (1-br*costhe)/Sqrt(aux)
        sinthe = (1-costhe)*(1+costhe)
        IF (( sinthe .GT. 0 )) THEN
          sinthe = -Sqrt(sinthe)
        ELSE
          sinthe = 0
        END IF
      ELSE
        costhe = 0
        sinthe = -1
      END IF
      np = np + 1
      IF (( np .GT. max_stack )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','COMPT', ' st
     *ack size exceeded! ',' $MAXSTACK = ',max_stack,' np = ',np
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      call uphi(3,2)
      e(np) = pese
      iq(np) = -1
      IF (( ibcmp .EQ. 1 )) THEN
        IF (( Uj .GT. 1e-3 )) THEN
          edep = 0
          call relax(Uj,shn_array(j),iz_array(j))
        ELSE
          edep = Uj
        END IF
        IF (( edep .GT. 0 )) THEN
          iarg=4
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,3630)prob_RR
3630        FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold+1
3641      CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              rnno_RR = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO3642
          GO TO 3641
3642      CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
3570  return
      end
      SUBROUTINE ELECTR(IRCODE)
      implicit none
      integer*4 IRCODE
      integer max_med
      parameter (max_med = MXMED)
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      common/bounds/ ecut, pcut, ecut_new, pcut_new, vacdst
      EGS_Float ecut, pcut, ecut_new, pcut_new, vacdst
      COMMON/ELECIN/ esig_e(max_med),psig_e(max_med), esige_max, psige_m
     *ax, range_ep(0:1,500,max_med), E_array(500,max_med), etae_ms0(500,
     *max_med),etae_ms1(500,max_med),etap_ms0(500,max_med),etap_ms1(500,
     *max_med),q1ce_ms0(500,max_med),q1ce_ms1(500,max_med),q1cp_ms0(500,
     *max_med),q1cp_ms1(500,max_med),q2ce_ms0(500,max_med),q2ce_ms1(500,
     *max_med),q2cp_ms0(500,max_med),q2cp_ms1(500,max_med),blcce0(500,ma
     *x_med),blcce1(500,max_med), EKE0(max_med),EKE1(max_med), XR0(max_m
     *ed),TEFF0(max_med),BLCC(max_med),XCC(max_med), ESIG0(500,max_med),
     *ESIG1(500,max_med),PSIG0(500,max_med),PSIG1(500,max_med),EDEDX0(50
     *0,max_med),EDEDX1(500,max_med),PDEDX0(500,max_med),PDEDX1(500,max_
     *med),EBR10(500,max_med),EBR11(500,max_med),PBR10(500,max_med),PBR1
     *1(500,max_med),PBR20(500,max_med),PBR21(500,max_med),TMXS0(500,max
     *_med),TMXS1(500,max_med), expeke1(max_med), IUNRST(max_med),EPSTFL
     *(max_med),IAPRIM(max_med), sig_ismonotone(0:1,max_med)
      EGS_Float esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E
     *_array,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1
     *,  q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blc
     *ce0,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG
     *0,ESIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR1
     *1,  PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/misc/ DUNIT,KMPI,KMPO
      EGS_Float DUNIT
      integer*4 KMPI,KMPO
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      EGS_Float SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common/ET_control/ smaxir,smax_new,estepe,ximax,skindepth_for_bca,
     * transport_algorithm,bca_algorithm,exact_bca
      EGS_Float smaxir,smax_new,estepe,ximax,skindepth_for_bca
      integer*4 transport_algorithm,bca_algorithm
      logical exact_bca
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      common/egs_vr/ e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_
     *RR, i_survived_RR, n_RR_warning, i_do_rr
      EGS_Float e_max_rr,e_max_rr_new,prob_RR
      integer*4 nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      EGS_Float ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_ne
     *w,By_new,Bz_new
      logical emfield_on
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(max_med), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(4
     *0),  eii_sh(40),  eii_nshells(100),  eii_nsh(max_med),  eii_first(
     *max_med,50),  eii_no(max_med,50)
      EGS_Float eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L
     *_factor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_nsh
      EGS_Float lambda_max, sigratio, u_tmp, v_tmp, w_tmp
      LOGICAL random_tustep
      DOUBLE PRECISION  demfp,  peie,  total_tstep,  total_de
      EGS_Float ekems,  elkems,  chia2,  etap,  lambda,  blccl,  xccl,
     *xi,  xi_corr,  ms_corr, p2,  beta2,  de,  save_de,  dedx,  dedx0,
     * dedxmid,  ekei,  elkei,  aux,  ebr1,  eie,  ekef,  elkef,  ekeold
     *,  eketmp,  elktmp,  fedep,  tuss,  pbr1,  pbr2,  range,  rfict,
     *rnne1,  rnno24,  rnno25,  rnnotu,  rnnoss,  sig,  sig0,  sigf,  sk
     *indepth,  ssmfp,  tmxs,  tperp,  ustep0,  uscat,  vscat,  wscat,
     *xtrans,  ytrans,  ztrans,  cphi,sphi
      EGS_Float xphi,xphi2,yphi,yphi2,rhophi2
      integer*4 iarg,  idr,  ierust,  irl,  lelec,  qel,  lelke,  lelkem
     *s,  lelkef,  lelktmp,  ibr
      logical  callhowfar,   domultiple,  dosingle,   callmsdist,
     *                findindex,
     *              spin_index,                                   comput
     *e_tstep
     *
      data ierust/0/
      save ierust
      ircode = 1
      irold = ir(np)
      irl = irold
      call egs_start_particle
      IF (( idisc .GT. 0 )) THEN
        np=np-1
        return
      END IF
3650  CONTINUE
3651    CONTINUE
        lelec = iq(np)
        qel = (1+lelec)/2
        peie = e(np)
        eie = peie
        IF ((eie .LE. ecut)) THEN
          go to 3660
        END IF
        IF ((WT(NP) .EQ. 0.0)) THEN
          go to 3670
        END IF
3680    CONTINUE
3681      CONTINUE
          compute_tstep = .true.
          eke = eie - rm
          IF ((medium .NE. 0)) THEN
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            RNNE1 = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            IF ((RNNE1.EQ.0.0)) THEN
              RNNE1=1.E-30
            END IF
            DEMFP=MAX(-LOG(RNNE1),1.E-8)
            elke = log(eke)
            Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
            IF (( sig_ismonotone(qel,medium) )) THEN
              IF ((lelec .LT. 0)) THEN
                sigf=esig1(Lelke,MEDIUM)*elke+esig0(Lelke,MEDIUM)
                dedx0=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
                sigf = sigf/dedx0
              ELSE
                sigf=psig1(Lelke,MEDIUM)*elke+psig0(Lelke,MEDIUM)
                dedx0=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
                sigf = sigf/dedx0
              END IF
              sig0 = sigf
            ELSE
              IF (( lelec .LT. 0 )) THEN
                sig0 = esig_e(medium)
              ELSE
                sig0 = psig_e(medium)
              END IF
            END IF
          END IF
3690      CONTINUE
3691        CONTINUE
            IF ((medium .EQ. 0)) THEN
              tstep = vacdst
              ustep = tstep
              tustep = ustep
              callhowfar = .true.
              ustep = tustep
            ELSE
              rhof = rhor
              sig = sig0
              IF ((sig .LE. 0)) THEN
                tstep = vacdst
                sig0 = 1.E-15
              ELSE
                IF (( compute_tstep )) THEN
                  total_de = demfp/sig
                  fedep = total_de
                  ekef = eke - fedep
                  IF (( ekef .LE. E_array(1,medium) )) THEN
                    tstep = vacdst
                  ELSE
                    elkef = Log(ekef)
                    Lelkef=eke1(MEDIUM)*elkef+eke0(MEDIUM)
                    IF (( lelkef .EQ. lelke )) THEN
                      fedep = 1 - ekef/eke
                      elktmp = 0.5*(elke+elkef+0.25*fedep*fedep*(1+fedep
     *                *(1+0.875*fedep)))
                      lelktmp = lelke
                      IF ((lelec .LT. 0)) THEN
                        dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = ededx1(lelktmp,medium)*dedxmid
                      ELSE
                        dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = pdedx1(lelktmp,medium)*dedxmid
                      END IF
                      aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
                      tstep = fedep*eke*dedxmid*(1+aux)
                    ELSE
                      ekei = E_array(lelke,medium)
                      elkei = (lelke - eke0(medium))/eke1(medium)
                      fedep = 1 - ekei/eke
                      elktmp = 0.5*(elke+elkei+0.25*fedep*fedep*(1+fedep
     *                *(1+0.875*fedep)))
                      lelktmp = lelke
                      IF ((lelec .LT. 0)) THEN
                        dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = ededx1(lelktmp,medium)*dedxmid
                      ELSE
                        dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = pdedx1(lelktmp,medium)*dedxmid
                      END IF
                      aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
                      tuss = fedep*eke*dedxmid*(1+aux)
                      ekei = E_array(lelkef+1,medium)
                      elkei = (lelkef + 1 - eke0(medium))/eke1(medium)
                      fedep = 1 - ekef/ekei
                      elktmp = 0.5*(elkei+elkef+0.25*fedep*fedep*(1+fede
     *                p*(1+0.875*fedep)))
                      lelktmp = lelkef
                      IF ((lelec .LT. 0)) THEN
                        dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = ededx1(lelktmp,medium)*dedxmid
                      ELSE
                        dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lel
     *                  ktmp,MEDIUM)
                        dedxmid = 1/dedxmid
                        aux = pdedx1(lelktmp,medium)*dedxmid
                      END IF
                      aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
                      tstep = fedep*ekei*dedxmid*(1+aux)
                      tstep=tstep+tuss+ range_ep(qel,lelke,medium)-range
     *                _ep(qel,lelkef+1,medium)
                    END IF
                  END IF
                  total_tstep = tstep
                  compute_tstep = .false.
                END IF
                tstep = total_tstep/rhof
              END IF
              IF ((lelec .LT. 0)) THEN
                dedx0=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
              ELSE
                dedx0=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
              END IF
              dedx = rhof*dedx0
              tmxs=tmxs1(Lelke,MEDIUM)*elke+tmxs0(Lelke,MEDIUM)
              tmxs = tmxs/rhof
              ekei = E_array(lelke,medium)
              elkei = (lelke - eke0(medium))/eke1(medium)
              fedep = 1 - ekei/eke
              elktmp = 0.5*(elke+elkei+0.25*fedep*fedep*(1+fedep*(1+0.87
     *        5*fedep)))
              lelktmp = lelke
              IF ((lelec .LT. 0)) THEN
                dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelktmp,MED
     *          IUM)
                dedxmid = 1/dedxmid
                aux = ededx1(lelktmp,medium)*dedxmid
              ELSE
                dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelktmp,MED
     *          IUM)
                dedxmid = 1/dedxmid
                aux = pdedx1(lelktmp,medium)*dedxmid
              END IF
              aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6
              range = fedep*eke*dedxmid*(1+aux)
              range = (range + range_ep(qel,lelke,medium))/rhof
              random_tustep = .false.
              IF ((random_tustep)) THEN
                IF (( rng_seed .GT. 128 )) THEN
                  rng_seed = 128
                  call egs_fill_rndm_array(rng_seed,rng_array)
                  rng_seed = 1
                END IF
                rnnotu = rng_array(rng_seed)
                rng_seed = rng_seed + 1
                tmxs = rnnotu*min(tmxs,smaxir)
              ELSE
                tmxs = min(tmxs,smaxir)
              END IF
              tustep = min(tstep,tmxs,range)
              e_range = range
              idisc = 0
              call egs_hownear(tperp)
              dnear(np) = tperp
              IF((idisc .GT. 0))goto 3670
              blccl = rhof*blcc(medium)
              xccl = rhof*xcc(medium)
              p2 = eke*(eke+rmt2)
              beta2 = p2/(p2 + rmsq)
              IF (( spin_effects )) THEN
                IF ((lelec .LT. 0)) THEN
                  etap=etae_ms1(Lelke,MEDIUM)*elke+etae_ms0(Lelke,MEDIUM
     *            )
                ELSE
                  etap=etap_ms1(Lelke,MEDIUM)*elke+etap_ms0(Lelke,MEDIUM
     *            )
                END IF
                ms_corr=blcce1(Lelke,MEDIUM)*elke+blcce0(Lelke,MEDIUM)
                blccl = blccl/etap/(1+0.25*etap*xccl/blccl/p2)*ms_corr
              END IF
              ssmfp=beta2/blccl
              skindepth = skindepth_for_bca*ssmfp
              tustep = min(tustep,max(tperp,skindepth))
              count_all_steps = count_all_steps + 1
              is_ch_step = .false.
              IF (((tustep .LE. tperp) .AND. ((.NOT.exact_bca) .OR. (tus
     *        tep .GT. skindepth)))) THEN
                callhowfar = .false.
                domultiple = .false.
                dosingle = .false.
                callmsdist = .true.
                tuss = range - range_ep(qel,lelke,medium)/rhof
                IF (( tuss .GE. tustep )) THEN
                  IF (( lelec .LT. 0 )) THEN
                    dedxmid=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIU
     *              M)
                    aux = ededx1(lelke,medium)/dedxmid
                  ELSE
                    dedxmid=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIU
     *              M)
                    aux = pdedx1(lelke,medium)/dedxmid
                  END IF
                  de = dedxmid*tustep*rhof
                  fedep = de/eke
                  de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.2
     *            5*fedep*(2-aux*(4-aux)))))
                ELSE
                  lelktmp = lelke
                  tuss = (range - tustep)*rhof
                  IF (( tuss .LE. 0 )) THEN
                    de = eke - TE(medium)*0.99
                  ELSE
3701                IF(tuss.GE.range_ep(qel,lelktmp,medium))GO TO 3702
                      lelktmp = lelktmp - 1
                    GO TO 3701
3702                CONTINUE
                    elktmp = (lelktmp+1-eke0(medium))/eke1(medium)
                    eketmp = E_array(lelktmp+1,medium)
                    tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof
                    IF (( lelec .LT. 0 )) THEN
                      dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelkt
     *                mp,MEDIUM)
                      aux = ededx1(lelktmp,medium)/dedxmid
                    ELSE
                      dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelkt
     *                mp,MEDIUM)
                      aux = pdedx1(lelktmp,medium)/dedxmid
                    END IF
                    de = dedxmid*tuss*rhof
                    fedep = de/eketmp
                    de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0
     *              .25*fedep*(2-aux*(4-aux)))))
                    de = de + eke - eketmp
                  END IF
                END IF
                tvstep = tustep
                is_ch_step = .true.
                IF ((transport_algorithm .EQ. 0)) THEN
                  call msdist_pII (  eke,de,tustep,rhof,medium,qel,spin_
     *            effects, u(np),v(np),w(np),x(np),y(np),z(np),  uscat,v
     *            scat,wscat,xtrans,ytrans,ztrans,ustep )
                ELSE
                  call msdist_pI (  eke,de,tustep,rhof,medium,qel,spin_e
     *            ffects, u(np),v(np),w(np),x(np),y(np),z(np),  uscat,vs
     *            cat,wscat,xtrans,ytrans,ztrans,ustep )
                END IF
              ELSE
                callmsdist = .false.
                IF ((exact_bca)) THEN
                  domultiple = .false.
                  IF (( rng_seed .GT. 128 )) THEN
                    rng_seed = 128
                    call egs_fill_rndm_array(rng_seed,rng_array)
                    rng_seed = 1
                  END IF
                  rnnoss = rng_array(rng_seed)
                  rng_seed = rng_seed + 1
                  IF (( rnnoss .LT. 1.e-30 )) THEN
                    rnnoss = 1.e-30
                  END IF
                  lambda = - Log(1 - rnnoss)
                  lambda_max = 0.5*blccl*rm/dedx*(eke/rm+1)**3
                  IF (( lambda .GE. 0 .AND. lambda_max .GT. 0 )) THEN
                    IF (( lambda .LT. lambda_max )) THEN
                      tuss=lambda*ssmfp*(1-0.5*lambda/lambda_max)
                    ELSE
                      tuss = 0.5 * lambda * ssmfp
                    END IF
                    IF ((tuss .LT. tustep)) THEN
                      tustep = tuss
                      dosingle = .true.
                    ELSE
                      dosingle = .false.
                    END IF
                  ELSE
                    write(i_log,'(/a)') '***************** Warning: '
                    write(i_log,*) ' lambda > lambda_max: ', lambda,lamb
     *              da_max,' eke dedx: ',eke,dedx, ' ir medium blcc: ',i
     *              r(np),medium,blcc(medium), ' position = ',x(np),y(np
     *              ),z(np)
                    dosingle = .false.
                    np=np-1
                    return
                  END IF
                  ustep = tustep
                ELSE
                  dosingle = .false.
                  domultiple = .true.
                  ekems = eke - 0.5*tustep*dedx
                  p2 = ekems*(ekems+rmt2)
                  beta2 = p2/(p2 + rmsq)
                  chia2 = xccl/(4*blccl*p2)
                  xi = 0.5*xccl/p2/beta2*tustep
                  IF (( spin_effects )) THEN
                    elkems = Log(ekems)
                    Lelkems=eke1(MEDIUM)*elkems+eke0(MEDIUM)
                    IF ((lelec .LT. 0)) THEN
                      etap=etae_ms1(Lelkems,MEDIUM)*elkems+etae_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1ce_ms1(Lelkems,MEDIUM)*elkems+q1ce_ms0(L
     *                elkems,MEDIUM)
                    ELSE
                      etap=etap_ms1(Lelkems,MEDIUM)*elkems+etap_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1cp_ms1(Lelkems,MEDIUM)*elkems+q1cp_ms0(L
     *                elkems,MEDIUM)
                    END IF
                    chia2 = chia2*etap
                    xi = xi*xi_corr
                    ms_corr=blcce1(Lelkems,MEDIUM)*elkems+blcce0(Lelkems
     *              ,MEDIUM)
                    blccl = blccl*ms_corr
                  ELSE
                    xi_corr = 1
                    etap = 1
                  END IF
                  xi = xi*(Log(1+1./chia2)-1/(1+chia2))
                  IF (( xi .LT. 0.1 )) THEN
                    ustep = tustep*(1 - xi*(0.5 - xi*0.166667))
                  ELSE
                    ustep = tustep*(1 - Exp(-xi))/xi
                  END IF
                END IF
                IF ((ustep .LT. tperp)) THEN
                  callhowfar = .false.
                ELSE
                  callhowfar = .true.
                END IF
              END IF
            END IF
            irold = ir(np)
            irnew = ir(np)
            idisc = 0
            ustep0 = ustep
            IF ((callhowfar .OR. wt(np) .LE. 0)) THEN
              call egs_howfar
            END IF
            IF ((idisc .GT. 0)) THEN
              go to 3670
            END IF
            IF ((ustep .LE. 0)) THEN
              IF ((ustep .LT. -1e-4)) THEN
                ierust = ierust + 1
                WRITE(6,3710)ierust,ustep,dedx,e(np)-prm, ir(np),irnew,i
     *          rold,x(np),y(np),z(np)
3710            FORMAT(i4,' Negative ustep = ',e12.5,' dedx=',F8.4,' ke=
     *',F8.4, ' ir,irnew,irold =',3i4,' x,y,z =',4e10.3)
                IF ((ierust .GT. 1000)) THEN
                  WRITE(6,3720)
3720              FORMAT(////' Called exit---too many ustep errors'///)
                  call exit(1)
                END IF
              END IF
              ustep = 0
            END IF
            IF ((ustep .EQ. 0 .OR. medium .EQ. 0)) THEN
              IF ((ustep .NE. 0)) THEN
                IF (.false.) THEN
                  edep = pzero
                ELSE
                  vstep = ustep
                  tvstep = vstep
                  edep = pzero
                  e_range = vacdst
                  iarg=0
                  IF ((IAUSFL(IARG+1).NE.0)) THEN
                    call egs_ausgab(iarg)
                  END IF
                  x(np) = x(np) + u(np)*vstep
                  y(np) = y(np) + v(np)*vstep
                  z(np) = z(np) + w(np)*vstep
                  dnear(np) = dnear(np) - vstep
                END IF
              END IF
              IF ((irnew .NE. irold)) THEN
                ir(np) = irnew
                irl = irnew
                rhor = rhor_new
                medium = medium_new
                ecut = ecut_new
                smaxir = smax_new
                Bx=Bx_new
                By=By_new
                Bz=Bz_new
              END IF
              IF ((ustep .NE. 0)) THEN
                iarg=5
                IF ((IAUSFL(IARG+1).NE.0)) THEN
                  call egs_ausgab(iarg)
                END IF
              END IF
              IF ((eie .LE. ecut)) THEN
                go to 3660
              END IF
              IF ((ustep .NE. 0 .AND. idisc .LT. 0)) THEN
                go to 3670
              END IF
              GO TO 3681
            END IF
            vstep = ustep
            IF ((callhowfar)) THEN
              IF ((exact_bca)) THEN
                tvstep = vstep
                IF ((tvstep .NE. tustep)) THEN
                  dosingle = .false.
                END IF
              ELSE
                IF (( vstep .LT. ustep0 )) THEN
                  ekems = eke - 0.5*tustep*vstep/ustep0*dedx
                  p2 = ekems*(ekems+rmt2)
                  beta2 = p2/(p2 + rmsq)
                  chia2 = xccl/(4*blccl*p2)
                  xi = 0.5*xccl/p2/beta2*vstep
                  IF (( spin_effects )) THEN
                    elkems = Log(ekems)
                    Lelkems=eke1(MEDIUM)*elkems+eke0(MEDIUM)
                    IF ((lelec .LT. 0)) THEN
                      etap=etae_ms1(Lelkems,MEDIUM)*elkems+etae_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1ce_ms1(Lelkems,MEDIUM)*elkems+q1ce_ms0(L
     *                elkems,MEDIUM)
                    ELSE
                      etap=etap_ms1(Lelkems,MEDIUM)*elkems+etap_ms0(Lelk
     *                ems,MEDIUM)
                      xi_corr=q1cp_ms1(Lelkems,MEDIUM)*elkems+q1cp_ms0(L
     *                elkems,MEDIUM)
                    END IF
                    chia2 = chia2*etap
                    xi = xi*xi_corr
                    ms_corr=blcce1(Lelkems,MEDIUM)*elkems+blcce0(Lelkems
     *              ,MEDIUM)
                    blccl = blccl*ms_corr
                  ELSE
                    xi_corr = 1
                    etap = 1
                  END IF
                  xi = xi*(Log(1+1./chia2)-1/(1+chia2))
                  IF (( xi .LT. 0.1 )) THEN
                    tvstep = vstep*(1 + xi*(0.5 + xi*0.333333))
                  ELSE
                    IF (( xi .LT. 0.999999 )) THEN
                      tvstep = -vstep*Log(1 - xi)/xi
                    ELSE
                      write(i_log,*) ' Stoped in SET-TVSTEP because xi >
     * 1! '
                      write(i_log,*) ' Medium: ',medium
                      write(i_log,*) ' Initial energy: ',eke
                      write(i_log,*) ' Average step energy: ',ekems
                      write(i_log,*) ' tustep: ',tustep
                      write(i_log,*) ' ustep0: ',ustep0
                      write(i_log,*) ' vstep:  ',vstep
                      write(i_log,*) ' ==> xi = ',xi
                      write(i_log,'(/a)') '***************** Error: '
                      write(i_log,*) 'This is a fatal error condition'
                      write(i_log,'(/a)') '***************** Quiting now
     *.'
                      call exit(1)
                    END IF
                  END IF
                ELSE
                  tvstep = tustep
                END IF
              END IF
              tuss = range - range_ep(qel,lelke,medium)/rhof
              IF (( tuss .GE. tvstep )) THEN
                IF (( lelec .LT. 0 )) THEN
                  dedxmid=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
                  aux = ededx1(lelke,medium)/dedxmid
                ELSE
                  dedxmid=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
                  aux = pdedx1(lelke,medium)/dedxmid
                END IF
                de = dedxmid*tvstep*rhof
                fedep = de/eke
                de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.25*
     *          fedep*(2-aux*(4-aux)))))
              ELSE
                lelktmp = lelke
                tuss = (range - tvstep)*rhof
                IF (( tuss .LE. 0 )) THEN
                  de = eke - TE(medium)*0.99
                ELSE
3731              IF(tuss.GE.range_ep(qel,lelktmp,medium))GO TO 3732
                    lelktmp = lelktmp - 1
                  GO TO 3731
3732              CONTINUE
                  elktmp = (lelktmp+1-eke0(medium))/eke1(medium)
                  eketmp = E_array(lelktmp+1,medium)
                  tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof
                  IF (( lelec .LT. 0 )) THEN
                    dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelktmp
     *              ,MEDIUM)
                    aux = ededx1(lelktmp,medium)/dedxmid
                  ELSE
                    dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelktmp
     *              ,MEDIUM)
                    aux = pdedx1(lelktmp,medium)/dedxmid
                  END IF
                  de = dedxmid*tuss*rhof
                  fedep = de/eketmp
                  de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.2
     *            5*fedep*(2-aux*(4-aux)))))
                  de = de + eke - eketmp
                END IF
              END IF
            ELSE
              tvstep = tustep
              IF (( .NOT.callmsdist )) THEN
                tuss = range - range_ep(qel,lelke,medium)/rhof
                IF (( tuss .GE. tvstep )) THEN
                  IF (( lelec .LT. 0 )) THEN
                    dedxmid=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIU
     *              M)
                    aux = ededx1(lelke,medium)/dedxmid
                  ELSE
                    dedxmid=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIU
     *              M)
                    aux = pdedx1(lelke,medium)/dedxmid
                  END IF
                  de = dedxmid*tvstep*rhof
                  fedep = de/eke
                  de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0.2
     *            5*fedep*(2-aux*(4-aux)))))
                ELSE
                  lelktmp = lelke
                  tuss = (range - tvstep)*rhof
                  IF (( tuss .LE. 0 )) THEN
                    de = eke - TE(medium)*0.99
                  ELSE
3741                IF(tuss.GE.range_ep(qel,lelktmp,medium))GO TO 3742
                      lelktmp = lelktmp - 1
                    GO TO 3741
3742                CONTINUE
                    elktmp = (lelktmp+1-eke0(medium))/eke1(medium)
                    eketmp = E_array(lelktmp+1,medium)
                    tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof
                    IF (( lelec .LT. 0 )) THEN
                      dedxmid=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelkt
     *                mp,MEDIUM)
                      aux = ededx1(lelktmp,medium)/dedxmid
                    ELSE
                      dedxmid=pdedx1(Lelktmp,MEDIUM)*elktmp+pdedx0(Lelkt
     *                mp,MEDIUM)
                      aux = pdedx1(lelktmp,medium)/dedxmid
                    END IF
                    de = dedxmid*tuss*rhof
                    fedep = de/eketmp
                    de = de*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1- 0
     *              .25*fedep*(2-aux*(4-aux)))))
                    de = de + eke - eketmp
                  END IF
                END IF
              END IF
            END IF
            save_de = de
            edep = de
            ekef = eke - de
            eold = eie
            enew = eold - de
            IF (( .NOT.callmsdist )) THEN
              IF (( domultiple )) THEN
                lambda = blccl*tvstep/beta2/etap/(1+chia2)
                xi = xi/xi_corr
                findindex = .true.
                spin_index = .true.
                call mscat(lambda,chia2,xi,elkems,beta2,qel,medium, spin
     *          _effects,findindex,spin_index, costhe,sinthe)
              ELSE
                IF ((dosingle)) THEN
                  ekems = Max(ekef,ecut-rm)
                  p2 = ekems*(ekems + rmt2)
                  beta2 = p2/(p2 + rmsq)
                  chia2 = xcc(medium)/(4*blcc(medium)*p2)
                  IF (( spin_effects )) THEN
                    elkems = Log(ekems)
                    Lelkems=eke1(MEDIUM)*elkems+eke0(MEDIUM)
                    IF ((lelec .LT. 0)) THEN
                      etap=etae_ms1(Lelkems,MEDIUM)*elkems+etae_ms0(Lelk
     *                ems,MEDIUM)
                    ELSE
                      etap=etap_ms1(Lelkems,MEDIUM)*elkems+etap_ms0(Lelk
     *                ems,MEDIUM)
                    END IF
                    chia2 = chia2*etap
                  END IF
                  call sscat(chia2,elkems,beta2,qel,medium, spin_effects
     *            ,costhe,sinthe)
                ELSE
                  theta = 0
                  sinthe = 0
                  costhe = 1
                END IF
              END IF
            END IF
            e_range = range
            IF (( callmsdist )) THEN
              u_final = uscat
              v_final = vscat
              w_final = wscat
              x_final = xtrans
              y_final = ytrans
              z_final = ztrans
            ELSE
              IF (.NOT.(.false.)) THEN
                x_final = x(np) + u(np)*vstep
                y_final = y(np) + v(np)*vstep
                z_final = z(np) + w(np)*vstep
              END IF
              IF (( domultiple .OR. dosingle )) THEN
                u_tmp = u(np)
                v_tmp = v(np)
                w_tmp = w(np)
                call uphi(2,1)
                u_final = u(np)
                v_final = v(np)
                w_final = w(np)
                u(np) = u_tmp
                v(np) = v_tmp
                w(np) = w_tmp
              ELSE
                u_final = u(np)
                v_final = v(np)
                w_final = w(np)
              END IF
            END IF
            iarg=0
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
            x(np) = x_final
            y(np) = y_final
            z(np) = z_final
            u(np) = u_final
            v(np) = v_final
            w(np) = w_final
            dnear(np) = dnear(np) - vstep
            irold = ir(np)
            peie = peie - edep
            eie = peie
            e(np) = peie
            IF (( irnew .EQ. irl .AND. eie .LE. ecut)) THEN
              go to 3660
            END IF
            medold = medium
            IF ((medium .NE. 0)) THEN
              ekeold = eke
              eke = eie - rm
              elke = log(eke)
              Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
            END IF
            IF ((irnew .NE. irold)) THEN
              ir(np) = irnew
              irl = irnew
              rhor = rhor_new
              medium = medium_new
              ecut = ecut_new
              smaxir = smax_new
              Bx=Bx_new
              By=By_new
              Bz=Bz_new
            END IF
            iarg=5
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
            IF ((eie .LE. ecut)) THEN
              go to 3660
            END IF
            IF ((idisc .LT. 0)) THEN
              go to 3670
            END IF
            IF((medium .NE. medold))GO TO 3681
            demfp = demfp - save_de*sig
            total_de = total_de - save_de
            total_tstep = total_tstep - tvstep*rhof
            IF (( total_tstep .LT. 1e-9 )) THEN
              demfp = 0
            END IF
            IF(((demfp .LT. 1.E-8)))GO TO3692
          GO TO 3691
3692      CONTINUE
          IF ((lelec .LT. 0)) THEN
            sigf=esig1(Lelke,MEDIUM)*elke+esig0(Lelke,MEDIUM)
            dedx0=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
            sigf = sigf/dedx0
          ELSE
            sigf=psig1(Lelke,MEDIUM)*elke+psig0(Lelke,MEDIUM)
            dedx0=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
            sigf = sigf/dedx0
          END IF
          sigratio = sigf/sig0
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rfict = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF(((rfict .LE. sigratio)))GO TO3682
        GO TO 3681
3682    CONTINUE
        IF ((lelec .LT. 0)) THEN
          ebr1=ebr11(Lelke,MEDIUM)*elke+ebr10(Lelke,MEDIUM)
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnno24 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF ((rnno24 .LE. ebr1)) THEN
            go to 3750
          ELSE
            IF ((e(np) .LE. thmoll(medium) .AND. eii_flag .EQ. 0)) THEN
              IF ((ebr1 .LE. 0)) THEN
                go to 3650
              END IF
              go to 3750
            END IF
            iarg=8
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
            call moller
            iarg=9
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
            IF((iq(np) .EQ. 0))return
          END IF
          go to 3650
        END IF
        pbr1=pbr11(Lelke,MEDIUM)*elke+pbr10(Lelke,MEDIUM)
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        rnno25 = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        IF ((rnno25 .LT. pbr1)) THEN
          go to 3750
        END IF
        pbr2=pbr21(Lelke,MEDIUM)*elke+pbr20(Lelke,MEDIUM)
        IF ((rnno25 .LT. pbr2)) THEN
          iarg=10
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
          call bhabha
          iarg=11
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
          IF((iq(np) .EQ. 0))return
        ELSE
          iarg=12
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
          call annih
          iarg=13
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
          GO TO 3652
        END IF
      GO TO 3651
3652  CONTINUE
      return
3750  iarg=6
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        call egs_ausgab(iarg)
      END IF
      call brems
      iarg=7
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        call egs_ausgab(iarg)
      END IF
      IF ((iq(np) .EQ. 0)) THEN
        return
      ELSE
        go to 3650
      END IF
3660  IF (( medium .GT. 0 )) THEN
        IF ((eie .GT. ae(medium))) THEN
          idr = 1
          IF ((lelec .LT. 0)) THEN
            edep = e(np) - prm
          ELSE
            EDEP=PEIE-PRM
          END IF
        ELSE
          idr = 2
          edep = e(np) - prm
        END IF
      ELSE
        idr = 1
        edep = e(np) - prm
      END IF
      iarg=idr
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        call egs_ausgab(iarg)
      END IF
3760  CONTINUE
      IF ((lelec .GT. 0)) THEN
        IF ((edep .LT. peie)) THEN
          iarg=28
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
          call annih_at_rest
          iarg=14
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
          return
        END IF
      END IF
      np = np - 1
      ircode = 2
      return
3670  idisc = abs(idisc)
      IF (((lelec .LT. 0) .OR. (idisc .EQ. 99))) THEN
        edep = e(np) - prm
      ELSE
        edep = e(np) + prm
      END IF
      iarg=3
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        call egs_ausgab(iarg)
      END IF
      IF((idisc .EQ. 99))goto 3760
      np = np - 1
      ircode = 2
      return
      end
      subroutine egs_hatch
      implicit none
      character*512 toUpper
      integer max_med
      parameter (max_med = MXMED)
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      common/bounds/ ecut, pcut, ecut_new, pcut_new, vacdst
      EGS_Float ecut, pcut, ecut_new, pcut_new, vacdst
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/ELECIN/ esig_e(max_med),psig_e(max_med), esige_max, psige_m
     *ax, range_ep(0:1,500,max_med), E_array(500,max_med), etae_ms0(500,
     *max_med),etae_ms1(500,max_med),etap_ms0(500,max_med),etap_ms1(500,
     *max_med),q1ce_ms0(500,max_med),q1ce_ms1(500,max_med),q1cp_ms0(500,
     *max_med),q1cp_ms1(500,max_med),q2ce_ms0(500,max_med),q2ce_ms1(500,
     *max_med),q2cp_ms0(500,max_med),q2cp_ms1(500,max_med),blcce0(500,ma
     *x_med),blcce1(500,max_med), EKE0(max_med),EKE1(max_med), XR0(max_m
     *ed),TEFF0(max_med),BLCC(max_med),XCC(max_med), ESIG0(500,max_med),
     *ESIG1(500,max_med),PSIG0(500,max_med),PSIG1(500,max_med),EDEDX0(50
     *0,max_med),EDEDX1(500,max_med),PDEDX0(500,max_med),PDEDX1(500,max_
     *med),EBR10(500,max_med),EBR11(500,max_med),PBR10(500,max_med),PBR1
     *1(500,max_med),PBR20(500,max_med),PBR21(500,max_med),TMXS0(500,max
     *_med),TMXS1(500,max_med), expeke1(max_med), IUNRST(max_med),EPSTFL
     *(max_med),IAPRIM(max_med), sig_ismonotone(0:1,max_med)
      EGS_Float esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E
     *_array,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1
     *,  q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blc
     *ce0,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG
     *0,ESIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR1
     *1,  PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/misc/ DUNIT,KMPI,KMPO
      EGS_Float DUNIT
      integer*4 KMPI,KMPO
      COMMON/PHOTIN/ EBINDA(max_med), GE0(max_med),GE1(max_med), GMFP0(2
     *000,max_med),GMFP1(2000,max_med),GBR10(2000,max_med),GBR11(2000,ma
     *x_med),GBR20(2000,max_med),GBR21(2000,max_med), RCO0(max_med),RCO1
     *(max_med), RSCT0(100,max_med),RSCT1(100,max_med), COHE0(2000,max_m
     *ed),COHE1(2000,max_med),  PHOTONUC0(2000,max_med),PHOTONUC1(2000,m
     *ax_med), DPMFP, MPGEM(1,max_med), NGR(max_med)
      EGS_Float EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR
     *21,  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,
     *  DPMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      EGS_Float SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common/ET_control/ smaxir,smax_new,estepe,ximax,skindepth_for_bca,
     * transport_algorithm,bca_algorithm,exact_bca
      EGS_Float smaxir,smax_new,estepe,ximax,skindepth_for_bca
      integer*4 transport_algorithm,bca_algorithm
      logical exact_bca
      common/egs_vr/ e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_
     *RR, i_survived_RR, n_RR_warning, i_do_rr
      EGS_Float e_max_rr,e_max_rr_new,prob_RR
      integer*4 nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      CHARACTER*4 MBUF(72),MDLABL(8)
      EGS_Float ACD ,  ADEV ,  ASD ,  COST ,  CTHET ,  DEL ,  DFACT ,  D
     *FACTI,  DUNITO,  DUNITR,  FNSSS ,  P ,  PZNORM,  RDEV ,  S2C2 ,  S
     *2C2MN,  S2C2MX,  SINT ,  SX ,  SXX ,  SXY ,   SY ,   WID ,  XS ,
     *XS0 ,  XS1 ,  XSI ,  WSS ,  YS ,  ZEROS(3)
      integer*4 I ,  I1ST ,  IB ,  ID ,  IE ,  IL ,  IM ,  IRAYL ,  IRN
     *,  ISTEST,  ISUB ,  ISS ,  IZ ,   IZZ ,  J ,  JR ,  LCTHET,  LMDL
     *,  LMDN ,  LTHETA,  MD ,  MXSINC,  NCMFP ,   NEKE ,   NGE ,   NGRI
     *M ,  NISUB ,  NLEKE ,    NM ,  NRANGE,    NRNA ,  NSEKE ,   NSGE ,
     *   NSINSS,  LOK(max_med)
      character*256 tmp_string
      integer*4 lnblnk1
      DATA MDLABL/' ','M','E','D','I','U','M','='/,LMDL/8/,LMDN/24/,DUNI
     *TO/1./
      DATA I1ST/1/,NSINSS/37/,MXSINC/1002/,ISTEST/0/,NRNA/1000/
3770  FORMAT(1X,14I5)
3780  FORMAT(1X,1PE14.5,4E14.5)
3790  FORMAT(72A1)
      IF ((I1ST.NE.0)) THEN
        I1ST=0
        DO 3801 J=1,2000
          IF ((smaxir.LE.0.0)) THEN
            smaxir=1e10
          END IF
3801    CONTINUE
3802    CONTINUE
        IF ((smax_new.LE.0.0)) THEN
          smax_new=1e10
        END IF
        NISUB=MXSINC-2
        FNSSS=NSINSS
        WID=PI5D2/FLOAT(NISUB)
        WSS=WID/(FNSSS-1.0)
        ZEROS(1)=0.
        ZEROS(2)=PI
        ZEROS(3)=TWOPI
        DO 3811 ISUB=1,MXSINC
          SX=0.
          SY=0.
          SXX=0.
          SXY=0.
          XS0=WID*FLOAT(ISUB-2)
          XS1=XS0+WID
          IZ=0
          DO 3821 IZZ=1,3
            IF (((XS0.LE.ZEROS(IZZ)).AND.(ZEROS(IZZ).LE.XS1))) THEN
              IZ=IZZ
              GO TO3822
            END IF
3821      CONTINUE
3822      CONTINUE
          IF ((IZ.EQ.0)) THEN
            XSI=XS0
          ELSE
            XSI=ZEROS(IZ)
          END IF
          DO 3831 ISS=1,NSINSS
            XS=WID*FLOAT(ISUB-2)+WSS*FLOAT(ISS-1)-XSI
            YS=SIN(XS+XSI)
            SX=SX+XS
            SY=SY+YS
            SXX=SXX+XS*XS
            SXY=SXY+XS*YS
3831      CONTINUE
3832      CONTINUE
          IF ((IZ.NE.0)) THEN
            SIN1(ISUB)=SXY/SXX
            SIN0(ISUB)=-SIN1(ISUB)*XSI
          ELSE
            DEL=FNSSS*SXX-SX*SX
            SIN1(ISUB)=(FNSSS*SXY-SY*SX)/DEL
            SIN0(ISUB)=(SY*SXX-SX*SXY)/DEL - SIN1(ISUB)*XSI
          END IF
3811    CONTINUE
3812    CONTINUE
        SINC0=2.0
        SINC1=1.0/WID
        IF ((ISTEST.NE.0)) THEN
          ADEV=0.
          RDEV=0.
          S2C2MN=10.
          S2C2MX=0.
          DO 3841 ISUB=1,NISUB
            DO 3851 ISS=1,NSINSS
              THETA=WID*FLOAT(ISUB-1)+WSS*FLOAT(ISS-1)
              CTHET=PI5D2-THETA
              SINTHE=sin(THETA)
              COSTHE=sin(CTHET)
              SINT=SIN(THETA)
              COST=COS(THETA)
              ASD=ABS(SINTHE-SINT)
              ACD=ABS(COSTHE-COST)
              ADEV=max(ADEV,ASD,ACD)
              IF((SINT.NE.0.0))RDEV=max(RDEV,ASD/ABS(SINT))
              IF((COST.NE.0.0))RDEV=max(RDEV,ACD/ABS(COST))
              S2C2=SINTHE**2+COSTHE**2
              S2C2MN=min(S2C2MN,S2C2)
              S2C2MX=max(S2C2MX,S2C2)
              IF ((ISUB.LT.11)) THEN
                write(i_log,'(1PE20.7,4E20.7)') THETA,SINTHE,SINT,COSTHE
     *          ,COST
              END IF
3851        CONTINUE
3852        CONTINUE
3841      CONTINUE
3842      CONTINUE
          write(i_log,'(a,2i5)') ' SINE TESTS,MXSINC,NSINSS=',MXSINC,NSI
     *    NSS
          write(i_log,'(a,1PE16.8,3e16.8)') ' ADEV,RDEV,S2C2(MN,MX) =',
     *    ADEV,RDEV,S2C2MN,S2C2MX
          ADEV=0.
          RDEV=0.
          S2C2MN=10.
          S2C2MX=0.
          DO 3861 IRN=1,NRNA
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            THETA = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            THETA=THETA*PI5D2
            CTHET=PI5D2-THETA
            SINTHE=sin(THETA)
            COSTHE=sin(CTHET)
            SINT=SIN(THETA)
            COST=COS(THETA)
            ASD=ABS(SINTHE-SINT)
            ACD=ABS(COSTHE-COST)
            ADEV=max(ADEV,ASD,ACD)
            IF((SINT.NE.0.0))RDEV=max(RDEV,ASD/ABS(SINT))
            IF((COST.NE.0.0))RDEV=max(RDEV,ACD/ABS(COST))
            S2C2=SINTHE**2+COSTHE**2
            S2C2MN=min(S2C2MN,S2C2)
            S2C2MX=max(S2C2MX,S2C2)
3861      CONTINUE
3862      CONTINUE
          write(i_log,'(a,i7,a)') ' TEST AT ',NRNA,' RANDOM ANGLES IN (0
     *,5*PI/2)'
          write(i_log,'(1PE16.8,3E16.8)') ' ADEV,RDEV,S2C2(MN,MX) =', AD
     *    EV,RDEV,S2C2MN,S2C2MX
        END IF
        P=1.
        DO 3871 I=1,50
          PWR2I(I)=P
          P=P/2.
3871    CONTINUE
3872    CONTINUE
      END IF
      DO 3881 j=1,nmed
        iraylm(j) = iraylr
3881  CONTINUE
3882  CONTINUE
      DO 3891 j=1,nmed
        iphotonucm(j) = iphotonuc
3891  CONTINUE
3892  CONTINUE
      write(i_log,'(a,i3)') ' ===> Photonuclear flag: ', iphotonuc
      IF((.NOT.is_pegsless))REWIND KMPI
      NM=0
      DO 3901 IM=1,NMED
        LOK(IM)=0
        IF ((IRAYLM(IM).EQ.1)) THEN
          write(i_log,'(a,i3/)') ' RAYLEIGH OPTION REQUESTED FOR MEDIUM
     *NUMBER',IM
        END IF
3901  CONTINUE
3902  CONTINUE
      DO 3911 IM=1,NMED
        IF ((IPHOTONUCM(IM).EQ.1)) THEN
          write(i_log,'(a,i3/)') ' PHOTONUCLEAR REQUESTED FOR MEDIUM NUM
     *BER',IM
        END IF
3911  CONTINUE
3912  CONTINUE
      IF ((.NOT.is_pegsless)) THEN
3920    CONTINUE
3921      CONTINUE
3930      CONTINUE
3931        CONTINUE
            READ(KMPI,3790,END=3940)MBUF
            DO 3951 IB=1,LMDL
              IF((MBUF(IB).NE.MDLABL(IB)))GO TO 3931
3951        CONTINUE
3952        CONTINUE
3960        CONTINUE
              DO 3961 IM=1,NMED
              DO 3971 IB=1,LMDN
                IL=LMDL+IB
                IF((MBUF(IL).NE.MEDIA(IB,IM)))GO TO 3961
                IF((IB.EQ.LMDN))GO TO 3932
3971          CONTINUE
3972          CONTINUE
3961        CONTINUE
3962        CONTINUE
          GO TO 3931
3932      CONTINUE
          IF((LOK(IM).NE.0))GO TO 3930
          LOK(IM)=1
          NM=NM+1
          read(kmpi,'(a)',err=3980) tmp_string
          goto 3990
3980      write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'Error while reading pegs4 file'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
3990      CONTINUE
          read(tmp_string,1,ERR=4000)  (MBUF(I),I=1,5),RHO(IM),NNE(IM),I
     *    UNRST(IM),EPSTFL(IM),IAPRIM(IM)
1         FORMAT(5A1,5X,F11.0,4X,I2,9X,I1,9X,I1,9X,I1)
          GO TO 4010
4000      CONTINUE
          write(i_log,*) 'Found medium with gas pressure'
          read(tmp_string,2) (MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),
     *    EPSTFL(IM), IAPRIM(IM)
2         FORMAT(5A1,5X,F11.0,4X,I2,26X,I1,9X,I1,9X,I1)
4010      CONTINUE
            DO 4011 IE=1,NNE(IM)
            READ(KMPI,4020)(MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2), ZELEM(
     *      IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE)
4020        FORMAT (6A1,2A1,3X,F3.0,3X,F9.0,4X,F12.0,6X,F12.0)
4011      CONTINUE
4012      CONTINUE
          READ(KMPI,3780) RLC(IM),AE(IM),AP(IM),UE(IM),UP(IM)
          TE(IM)=AE(IM)-RM
          THMOLL(IM)=TE(IM)*2. + RM
          READ(KMPI,3770) MSGE(IM),MGE(IM),MSEKE(IM),MEKE(IM),MLEKE(IM),
     *    MCMFP(IM),MRANGE(IM),IRAYL
          NSGE=MSGE(IM)
          NGE=MGE(IM)
          NSEKE=MSEKE(IM)
          NEKE=MEKE(IM)
          NLEKE=MLEKE(IM)
          NCMFP=MCMFP(IM)
          NRANGE=MRANGE(IM)
          READ(KMPI,3780)(DL1(I,IM),DL2(I,IM),DL3(I,IM),DL4(I,IM),DL5(I,
     *    IM),DL6(I,IM),I=1,6)
          READ(KMPI,3780)DELCM(IM),(ALPHI(I,IM),BPAR(I,IM),DELPOS(I,IM),
     *    I=1,2)
          READ(KMPI,3780)XR0(IM),TEFF0(IM),BLCC(IM),XCC(IM)
          READ(KMPI,3780)EKE0(IM),EKE1(IM)
          READ(KMPI,3780) (ESIG0(I,IM),ESIG1(I,IM),PSIG0(I,IM),PSIG1(I,I
     *    M),EDEDX0(I,IM),EDEDX1(I,IM),PDEDX0(I,IM),PDEDX1(I,IM),EBR10(I
     *    ,IM),EBR11(I,IM),PBR10(I,IM),PBR11(I,IM),PBR20(I,IM),PBR21(I,I
     *    M),TMXS0(I,IM),TMXS1(I,IM),I=1,NEKE)
          READ(KMPI,3780)EBINDA(IM),GE0(IM),GE1(IM)
          READ(KMPI,3780)(GMFP0(I,IM),GMFP1(I,IM),GBR10(I,IM),GBR11(I,IM
     *    ),GBR20(I,IM),GBR21(I,IM),I=1,NGE)
          IF ((IRAYL.EQ.1)) THEN
            READ(KMPI,3770) NGR(IM)
            NGRIM=NGR(IM)
            READ(KMPI,3780)RCO0(IM),RCO1(IM)
            READ(KMPI,3780)(RSCT0(I,IM),RSCT1(I,IM),I=1,NGRIM)
            READ(KMPI,3780)(COHE0(I,IM),COHE1(I,IM),I=1,NGE)
            write(i_log,'(a,i3,a)') ' Rayleigh data available for medium
     *', IM, ' in PEGS4 data set.'
          END IF
          IF ((IRAYLM(IM).EQ.1)) THEN
            IF ((IRAYL.NE.1)) THEN
              IF ((toUpper(photon_xsections(:lnblnk1(photon_xsections)))
     *        .EQ.'PEGS4')) THEN
                write(i_log,'(/a)') '***************** Error: '
                write(i_log,'(a,i3 /,a /,a)') ' IN HATCH: REQUESTED RAYL
     *EIGH OPTION FOR MEDIUM', IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PE
     *GS4 FILE.', ' YOU WILL NOT BE ABLE TO USE THE PEGS4 DATA WITH RAYL
     *EIGH ON!'
                write(i_log,'(/a)') '***************** Quiting now.'
                call exit(1)
              ELSE
                write(i_log,'(/a)') '***************** Warning: '
                write(i_log,'(a,i3 /,a)') ' IN HATCH: REQUESTED RAYLEIGH
     * OPTION FOR MEDIUM', IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4
     *FILE.'
              END IF
            ELSE
              IF ((toUpper(photon_xsections(:lnblnk1(photon_xsections)))
     *        .EQ.'PEGS4')) THEN
                call egs_init_rayleigh_sampling(IM)
              END IF
            END IF
          END IF
          IF((NM.GE.NMED))GO TO3922
        GO TO 3921
3922    CONTINUE
        CLOSE (UNIT=KMPI)
        DUNITR=DUNIT
        IF ((DUNIT.LT.0.0)) THEN
          ID=MAX0(1,MIN0(max_med,int(-DUNIT)))
          DUNIT=RLC(ID)
        END IF
        IF ((DUNIT.NE.1.0)) THEN
          write(i_log,'(a,1PE14.5,E14.5,a)') ' DUNIT REQUESTED&USED ARE:
     * ', DUNITR,DUNIT,'(CM.)'
        END IF
        DO 4031 IM=1,NMED
          DFACT=RLC(IM)/DUNIT
          DFACTI=1.0/DFACT
          I=1
            GO TO 4043
4041        I=I+1
4043        IF(I-(MEKE(IM)).GT.0)GO TO 4042
            ESIG0(I,IM)=ESIG0(I,IM)*DFACTI
            ESIG1(I,IM)=ESIG1(I,IM)*DFACTI
            PSIG0(I,IM)=PSIG0(I,IM)*DFACTI
            PSIG1(I,IM)=PSIG1(I,IM)*DFACTI
            EDEDX0(I,IM)=EDEDX0(I,IM)*DFACTI
            EDEDX1(I,IM)=EDEDX1(I,IM)*DFACTI
            PDEDX0(I,IM)=PDEDX0(I,IM)*DFACTI
            PDEDX1(I,IM)=PDEDX1(I,IM)*DFACTI
            TMXS0(I,IM)=TMXS0(I,IM)*DFACT
            TMXS1(I,IM)=TMXS1(I,IM)*DFACT
          GO TO 4041
4042      CONTINUE
          TEFF0(IM)=TEFF0(IM)*DFACT
          BLCC(IM)=BLCC(IM)*DFACTI
          XCC(IM)=XCC(IM)*SQRT(DFACTI)
          RLDU(IM)=RLC(IM)/DUNIT
          I=1
            GO TO 4053
4051        I=I+1
4053        IF(I-(MGE(IM)).GT.0)GO TO 4052
            GMFP0(I,IM)=GMFP0(I,IM)*DFACT
            GMFP1(I,IM)=GMFP1(I,IM)*DFACT
          GO TO 4051
4052      CONTINUE
4031    CONTINUE
4032    CONTINUE
        VACDST=VACDST*DUNITO/DUNIT
        DUNITO=DUNIT
      ELSE
        write(i_log,*) ' PEGSLESS INPUT.  CALCULATING ELECTRON CROSS-SEC
     *TIONS.'
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(a/a)') ' Code cannot be run in pegsless mode.', '
     *Compile with required files and try again.'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      DO 4061 md=1,nmed
        ecut = max(ecut,ae(md))
        pcut = max(pcut,ap(md))
4061  CONTINUE
4062  CONTINUE
      IF ((IBRDST.EQ.1)) THEN
        DO 4071 IM=1,NMED
          ZBRANG(IM)=0.0
          PZNORM=0.0
          DO 4081 IE=1,NNE(IM)
            ZBRANG(IM)= ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+
     *      1.0)
            PZNORM=PZNORM+PZ(IM,IE)
4081      CONTINUE
4082      CONTINUE
          ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.)
          LZBRANG(IM)=-log(ZBRANG(IM))
4071    CONTINUE
4072    CONTINUE
      END IF
      IF ((IPRDST.GT.0)) THEN
        DO 4091 IM=1,NMED
          ZBRANG(IM)=0.0
          PZNORM=0.0
          DO 4101 IE=1,NNE(IM)
            ZBRANG(IM)= ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+
     *      1.0)
            PZNORM=PZNORM+PZ(IM,IE)
4101      CONTINUE
4102      CONTINUE
          ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.)
4091    CONTINUE
4092    CONTINUE
      END IF
      IF ((toUpper(photon_xsections(:lnblnk1(photon_xsections))) .EQ. 'P
     *EGS4')) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,'(6(a/))') 'Using photon data from PEGS4 file!!!', '
     *However, the new Rayleigh angular sampling will be used.', 'The or
     *iginal EGS4 angular sampling undersamples large scattering ', 'ang
     *les. This may have little impact as Rayleigh scattering ', 'is for
     *ward peaked.', '**************************************************
     ********'
      ELSE
        call egs_init_user_photon(photon_xsections,comp_xsections, photo
     *  nuc_xsections,xsec_out)
      END IF
      call mscati
      IF (( eadl_relax .AND. photon_xsections .EQ. 'xcom' )) THEN
        call init_compton
        call EDGSET(1,1)
      ELSE
        call EDGSET(1,1)
        call init_compton
      END IF
      IF (( xsec_out .EQ. 1 .AND. eadl_relax)) THEN
        call egs_print_binding_energies
      END IF
      call fix_brems
      IF (( ibr_nist .GE. 1 )) THEN
        call init_nist_brems
      END IF
      IF (( pair_nrc .EQ. 1 )) THEN
        call init_nrc_pair
      END IF
      call eii_init
      call init_triplet
      IF ((NMED.EQ.1)) THEN
        write(i_log,*) 'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ONE MEDIUM.'
      ELSE
        write(i_log,'(a,i5,a)') 'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ',N
     *  MED,' MEDIA.'
      END IF
      RETURN
3940  write(i_log,'(a,i2//,a/,a/)') ' END OF FILE ON UNIT ',KMPI, ' PROG
     *RAM STOPPED IN HATCH BECAUSE THE', ' FOLLOWING NAMES WERE NOT RECO
     *GNIZED:'
      DO 4111 IM=1,NMED
        IF ((LOK(IM).NE.1)) THEN
          write(i_log,'(40x,a,24a1,a)') '''',(MEDIA(I,IM),I=1,LMDN),''''
        END IF
4111  CONTINUE
4112  CONTINUE
      STOP
      END
      subroutine fix_brems
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/nist_brems/ nb_fdata(0:50,100,max_med), nb_xdata(0:50,100,m
     *ax_med), nb_wdata(50,100,max_med), nb_idata(50,100,max_med), nb_em
     *in(max_med),nb_emax(max_med), nb_lemin(max_med),nb_lemax(max_med),
     * nb_dle(max_med),nb_dlei(max_med), log_ap(max_med)
      EGS_Float nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_l
     *emax, nb_dle,nb_dlei,log_ap
      integer*4 nb_idata
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      integer*4 medium,i
      EGS_Float Zt,Zb,Zf,Zg,Zv,fmax1,fmax2,Zi,pi,fc,xi,aux, XSIF,FCOULC
      DO 4121 medium=1,nmed
        log_ap(medium) = log(ap(medium))
        Zt = 0
        Zb = 0
        Zf = 0
        DO 4131 i=1,NNE(medium)
          Zi = ZELEM(medium,i)
          pi = PZ(medium,i)
          fc = FCOULC(Zi)
          xi = XSIF(Zi)
          aux = pi*Zi*(Zi + xi)
          Zt = Zt + aux
          Zb = Zb - aux*Log(Zi)/3
          Zf = Zf + aux*fc
4131    CONTINUE
4132    CONTINUE
        Zv = (Zb - Zf)/Zt
        Zg = Zb/Zt
        fmax1 = 2*(20.863 + 4*Zg) - 2*(20.029 + 4*Zg)/3
        fmax2 = 2*(20.863 + 4*Zv) - 2*(20.029 + 4*Zv)/3
        dl1(1,medium) = (20.863 + 4*Zg)/fmax1
        dl2(1,medium) = -3.242/fmax1
        dl3(1,medium) = 0.625/fmax1
        dl4(1,medium) = (21.12+4*Zg)/fmax1
        dl5(1,medium) = -4.184/fmax1
        dl6(1,medium) = 0.952
        dl1(2,medium) = (20.029+4*Zg)/fmax1
        dl2(2,medium) = -1.93/fmax1
        dl3(2,medium) = -0.086/fmax1
        dl4(2,medium) = (21.12+4*Zg)/fmax1
        dl5(2,medium) = -4.184/fmax1
        dl6(2,medium) = 0.952
        dl1(3,medium) = (20.863 + 4*Zv)/fmax2
        dl2(3,medium) = -3.242/fmax2
        dl3(3,medium) = 0.625/fmax2
        dl4(3,medium) = (21.12+4*Zv)/fmax2
        dl5(3,medium) = -4.184/fmax2
        dl6(3,medium) = 0.952
        dl1(4,medium) = (20.029+4*Zv)/fmax2
        dl2(4,medium) = -1.93/fmax2
        dl3(4,medium) = -0.086/fmax2
        dl4(4,medium) = (21.12+4*Zv)/fmax2
        dl5(4,medium) = -4.184/fmax2
        dl6(4,medium) = 0.952
        dl1(5,medium) = (3*(20.863 + 4*Zg) - (20.029 + 4*Zg))
        dl2(5,medium) = (3*(-3.242) - (-1.930))
        dl3(5,medium) = (3*(0.625)-(-0.086))
        dl4(5,medium) = (2*21.12+8*Zg)
        dl5(5,medium) = (2*(-4.184))
        dl6(5,medium) = 0.952
        dl1(6,medium) = (3*(20.863 + 4*Zg) + (20.029 + 4*Zg))
        dl2(6,medium) = (3*(-3.242) + (-1.930))
        dl3(6,medium) = (3*0.625+(-0.086))
        dl4(6,medium) = (4*21.12+16*Zg)
        dl5(6,medium) = (4*(-4.184))
        dl6(6,medium) = 0.952
        dl1(7,medium) = (3*(20.863 + 4*Zv) - (20.029 + 4*Zv))
        dl2(7,medium) = (3*(-3.242) - (-1.930))
        dl3(7,medium) = (3*(0.625)-(-0.086))
        dl4(7,medium) = (2*21.12+8*Zv)
        dl5(7,medium) = (2*(-4.184))
        dl6(7,medium) = 0.952
        dl1(8,medium) = (3*(20.863 + 4*Zv) + (20.029 + 4*Zv))
        dl2(8,medium) = (3*(-3.242) + (-1.930))
        dl3(8,medium) = (3*0.625+(-0.086))
        dl4(8,medium) = (4*21.12+16*Zv)
        dl5(8,medium) = (4*(-4.184))
        dl6(8,medium) = 0.952
        bpar(2,medium) = dl1(7,medium)/(3*dl1(8,medium) + dl1(7,medium))
        bpar(1,medium) = 12*dl1(8,medium)/(3*dl1(8,medium) + dl1(7,mediu
     *  m))
4121  CONTINUE
4122  CONTINUE
      return
      end
      EGS_Float function FCOULC(Z)
      implicit none
      EGS_Float Z
      EGS_Float fine,asq
      data fine/137.03604/
      asq = Z/fine
      asq = asq*asq
      FCOULC = asq*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+ASQ*(0.0083+ASQ*(
     *-0.002))))
      return
      end
      EGS_Float function XSIF(Z)
      implicit none
      EGS_Float Z
      integer*4 iZ
      EGS_Float alrad(4),alradp(4),a1440,a183,FCOULC
      data alrad/5.31,4.79,4.74,4.71/
      data alradp/6.144,5.621,5.805,5.924/
      data a1440/1194.0/,A183/184.15/
      IF (( Z .LE. 4 )) THEN
        iZ = Z
        xsif = alradp(iZ)/(alrad(iZ) - FCOULC(Z))
      ELSE
        xsif = Log(A1440*Z**(-0.666667))/(Log(A183*Z**(-0.33333))-FCOULC
     *  (Z))
      END IF
      return
      end
      subroutine init_compton
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common/compton_data/ iz_array(1538),be_array(1538), Jo_array(1538)
     *,erfJo_array(1538), ne_array(1538),shn_array(1538), shell_array(20
     *0,max_med), eno_array(200,max_med), eno_atbin_array(200,max_med),n
     *_shell(max_med)
      integer*4 iz_array,ne_array,shn_array, shell_array,eno_atbin_array
     *,n_shell
      EGS_Float be_array,Jo_array,erfJo_array,eno_array
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100)
      EGS_Float binding_energies, interaction_prob, relaxation_prob, edg
     *e_energies, edge_a,edge_b,edge_c,edge_d
      integer*4 edge_number
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/misc/ DUNIT,KMPI,KMPO
      EGS_Float DUNIT
      integer*4 KMPI,KMPO
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      integer*4 i,j,iz,nsh,j_l,j_h
      EGS_Float aux,pztot,atav
      EGS_Float aux_erf,erf1
      logical getd
      IF (( radc_flag .EQ. 1 )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) 'You are trying to use radiative Compton correcti
     *ons'
        write(i_log,*) 'without having included rad_compton1.mortran'
        write(i_log,'(a//)') 'Turning radiative Compton corrections OFF
     *...'
        radc_flag = 0
      END IF
      getd = ibcmp.gt.0
      IF (( .NOT.getd )) THEN
        IF (( eadl_relax .AND. photon_xsections .EQ. 'xcom' )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,/a,/a)') 'You must turn ON Compton binding cor
     *rections when using', 'a detailed atomic relaxation (eadl_relax=tr
     *ue) since ', 'binding energies taken from incoh.data below 1 keV!'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        write(i_log,'(a/)') ' Bound Compton scattering not requested! '
        return
      END IF
      write(i_log,'(/a$)') 'Bound Compton scattering requested, reading
     *data ......'
      rewind(i_incoh)
      DO 4141 j=1,18
        read(i_incoh,*)
4141  CONTINUE
4142  CONTINUE
      iz = 0
      DO 4151 j=1,1538
        read(i_incoh,*) iz_array(j),shn_array(j),ne_array(j), Jo_array(j
     *  ),be_array(j)
        Jo_array(j) = Jo_array(j)*137.
        be_array(j) = be_array(j)*1e-6/PRM
        aux_erf = 0.70710678119*(1+0.3*Jo_array(j))
        erfJo_array(j) = 0.82436063535*(erf1(aux_erf)-1)
        IF ((eadl_relax)) THEN
          IF ((iz_array(j) .NE. iz)) THEN
            shn_array(j) = 1
            iz = iz_array(j)
          ELSE
            shn_array(j) = shn_array(j-1)+1
          END IF
          IF ((binding_energies(shn_array(j),iz_array(j)) .GT. 0)) THEN
            be_array(j) = binding_energies(shn_array(j),iz_array(j))/PRM
          ELSE IF((photon_xsections .EQ. 'xcom')) THEN
            binding_energies(shn_array(j),iz_array(j)) = be_array(j)*PRM
          END IF
        END IF
4151  CONTINUE
4152  CONTINUE
      write(i_log,*) ' Done'
      write(i_log,'(/a)') ' Initializing Bound Compton scattering ......
     *'
      DO 4161 medium=1,nmed
        pztot = 0
        nsh = 0
        DO 4171 i=1,nne(medium)
          iz = int(zelem(medium,i))
          DO 4181 j=1,1538
            IF (( iz .EQ. iz_array(j) )) THEN
              nsh = nsh + 1
              IF (( nsh .GT. 200 )) THEN
                write(i_log,'(/a)') '***************** Error: '
                write(i_log,'(/a,i3,a,i4,a/,a)') ' For medium ',medium,
     *          ' the number of shells is > ',200,'!', ' Increase the pa
     *rameter $MXMDSH! '
                write(i_log,'(/a)') '***************** Quiting now.'
                call exit(1)
              END IF
              shell_array(nsh,medium) = j
              aux = pz(medium,i)*ne_array(j)
              eno_array(nsh,medium) = aux
              pztot = pztot + aux
            END IF
4181      CONTINUE
4182      CONTINUE
4171    CONTINUE
4172    CONTINUE
        IF (( nsh .EQ. 0 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,i3,a)') ' Medium ',medium,' has zero shells! '
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        n_shell(medium) = nsh
        write(i_log,'(a,i3,a,i3,a)') ' Medium ',medium,' has ',nsh,' she
     *lls: '
        DO 4191 i=1,nsh
          j = shell_array(i,medium)
          eno_array(i,medium) = eno_array(i,medium)/pztot
          write(i_log,'(i4,i5,i4,f9.5,e10.3,f10.3)') i,j,shn_array(j),en
     *    o_array(i,medium), Jo_array(j),be_array(j)*PRM*1000.
          eno_array(i,medium) = -eno_array(i,medium)
          eno_atbin_array(i,medium) = i
4191    CONTINUE
4192    CONTINUE
        atav = 1./nsh
        DO 4201 i=1,nsh-1
          DO 4211 j_h=1,nsh-1
            IF (( eno_array(j_h,medium) .LT. 0 )) THEN
              IF((abs(eno_array(j_h,medium)) .GT. atav))GO TO4212
            END IF
4211      CONTINUE
4212      CONTINUE
          DO 4221 j_l=1,nsh-1
            IF (( eno_array(j_l,medium) .LT. 0 )) THEN
              IF((abs(eno_array(j_l,medium)) .LT. atav))GO TO4222
            END IF
4221      CONTINUE
4222      CONTINUE
          aux = atav - abs(eno_array(j_l,medium))
          eno_array(j_h,medium) = eno_array(j_h,medium) + aux
          eno_array(j_l,medium) = -eno_array(j_l,medium)/atav + j_l
          eno_atbin_array(j_l,medium) = j_h
          IF((i .EQ. nsh-1))eno_array(j_h,medium) = 1 + j_h
4201    CONTINUE
4202    CONTINUE
        DO 4231 i=1,nsh
          IF (( eno_array(i,medium) .LT. 0 )) THEN
            eno_array(i,medium) = 1 + i
          END IF
4231    CONTINUE
4232    CONTINUE
4161  CONTINUE
4162  CONTINUE
      write(i_log,'(a/)') ' ...... Done.'
      getd = (iedgfl.gt.0.and.iedgfl.le.100)
      IF((getd))return
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(/a,/a,/a,/a)') ' In subroutine init_compton: ', '
     *Scattering off bound electrons creates atomic vacancies,', '   pot
     *entially starting an atomic relaxation cascade. ', '   Please turn
     * ON atomic relaxations.'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      SUBROUTINE MOLLER
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common/egs_vr/ e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_
     *RR, i_survived_RR, n_RR_warning, i_do_rr
      EGS_Float e_max_rr,e_max_rr_new,prob_RR
      integer*4 nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(max_med), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(4
     *0),  eii_sh(40),  eii_nshells(100),  eii_nsh(max_med),  eii_first(
     *max_med,50),  eii_no(max_med,50)
      EGS_Float eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L
     *_factor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_nsh
      COMMON/ELECIN/ esig_e(max_med),psig_e(max_med), esige_max, psige_m
     *ax, range_ep(0:1,500,max_med), E_array(500,max_med), etae_ms0(500,
     *max_med),etae_ms1(500,max_med),etap_ms0(500,max_med),etap_ms1(500,
     *max_med),q1ce_ms0(500,max_med),q1ce_ms1(500,max_med),q1cp_ms0(500,
     *max_med),q1cp_ms1(500,max_med),q2ce_ms0(500,max_med),q2ce_ms1(500,
     *max_med),q2cp_ms0(500,max_med),q2cp_ms1(500,max_med),blcce0(500,ma
     *x_med),blcce1(500,max_med), EKE0(max_med),EKE1(max_med), XR0(max_m
     *ed),TEFF0(max_med),BLCC(max_med),XCC(max_med), ESIG0(500,max_med),
     *ESIG1(500,max_med),PSIG0(500,max_med),PSIG1(500,max_med),EDEDX0(50
     *0,max_med),EDEDX1(500,max_med),PDEDX0(500,max_med),PDEDX1(500,max_
     *med),EBR10(500,max_med),EBR11(500,max_med),PBR10(500,max_med),PBR1
     *1(500,max_med),PBR20(500,max_med),PBR21(500,max_med),TMXS0(500,max
     *_med),TMXS1(500,max_med), expeke1(max_med), IUNRST(max_med),EPSTFL
     *(max_med),IAPRIM(max_med), sig_ismonotone(0:1,max_med)
      EGS_Float esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E
     *_array,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1
     *,  q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blc
     *ce0,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG
     *0,ESIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR1
     *1,  PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100)
      EGS_Float binding_energies, interaction_prob, relaxation_prob, edg
     *e_energies, edge_a,edge_b,edge_c,edge_d
      integer*4 edge_number
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      DOUBLE PRECISION PEIE,  PEKSE2,  PESE1,  PESE2,  PEKIN,  H1,  DCOS
     *TH
      EGS_Float EIE,  EKIN,  T0,  E0,  EXTRAE,  E02,  EP0,  G2,G3,  GMAX
     *,  BR,  R,  REJF4,  RNNO27,  RNNO28,  ESE1,  ESE2
      EGS_Float sigm,pbrem,rsh,Uj,sig_j
      integer*4 lelke,iele,ish,nsh,ifirst,i,jj,iZ,iarg
      NPold = NP
      PEIE=E(NP)
      EIE=PEIE
      PEKIN=PEIE-PRM
      EKIN=PEKIN
      IF (( eii_flag .GT. 0 .AND. eii_nsh(medium) .GT. 0 )) THEN
        Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
        sigm=esig1(Lelke,MEDIUM)*elke+esig0(Lelke,MEDIUM)
        pbrem=ebr11(Lelke,MEDIUM)*elke+ebr10(Lelke,MEDIUM)
        sigm = sigm*(1 - pbrem)
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        rsh = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        rsh = sigm*rsh
        DO 4241 iele=1,nne(medium)
          iZ = int(zelem(medium,iele)+0.5)
          nsh = eii_no(medium,iele)
          IF (( nsh .GT. 0 )) THEN
            ifirst = eii_first(medium,iele)
            DO 4251 ish=1,nsh
              Uj = binding_energies(ish,iZ)
              IF (( ekin .GT. Uj .AND. (Uj .GT. te(medium) .OR. Uj .GT.
     *        ap(medium)) )) THEN
                jj = ifirst + ish - 1
                i = eii_a(jj)*elke + eii_b(jj) + (jj-1)*250
                sig_j = eii_xsection_a(i)*elke + eii_xsection_b(i)
                sig_j = sig_j*pz(medium,iele)*eii_cons(medium)
                rsh = rsh - sig_j
                IF (( rsh .LT. 0 )) THEN
                  iarg=31
                  IF ((IAUSFL(IARG+1).NE.0)) THEN
                    call egs_ausgab(iarg)
                  END IF
                  call eii_sample(ish,iZ,Uj)
                  iarg=32
                  IF ((IAUSFL(IARG+1).NE.0)) THEN
                    call egs_ausgab(iarg)
                  END IF
                  return
                END IF
              END IF
4251        CONTINUE
4252        CONTINUE
          END IF
4241    CONTINUE
4242    CONTINUE
      END IF
      IF((ekin .LE. 2*te(medium)))return
      T0=EKIN/RM
      E0=T0+1.0
      EXTRAE = EIE - THMOLL(MEDIUM)
      E02=E0*E0
      EP0=TE(MEDIUM)/EKIN
      G2=T0*T0/E02
      G3=(2.*T0+1.)/E02
      GMAX=(1.+1.25*G2)
4261  CONTINUE
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        RNNO27 = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        BR = TE(MEDIUM)/(EKIN-EXTRAE*RNNO27)
        R=BR/(1.-BR)
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        RNNO28 = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        REJF4=(1.+G2*BR*BR+R*(R-G3))
        RNNO28=GMAX*RNNO28
        IF((RNNO28.LE.REJF4))GO TO4262
      GO TO 4261
4262  CONTINUE
      PEKSE2=BR*EKIN
      PESE1=PEIE-PEKSE2
      PESE2=PEKSE2+PRM
      ESE1=PESE1
      ESE2=PESE2
      E(NP)=PESE1
      IF (( np+1 .GT. max_stack )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','MOLLER', ' s
     *tack size exceeded! ',' $MAXSTACK = ',max_stack,' np = ',np+1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      E(NP+1)=PESE2
      H1=(PEIE+PRM)/PEKIN
      DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM)
      SINTHE=DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(2,1)
      NP=NP+1
      IQ(NP)=-1
      DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM)
      SINTHE=-DSQRT(1.D0-DCOSTH)
      COSTHE=DSQRT(DCOSTH)
      CALL UPHI(3,2)
      RETURN
      END
      subroutine mscati
      implicit none
      EGS_Float ededx,ei,eil,eip1,eip1l,si,sip1,eke,elke,aux,ecutmn,tstb
     *m,tstbmn
      EGS_Float p2,beta2,dedx0,ekef,elkef,estepx,ektmp,elktmp,chi_a2
      integer*4 i,leil,leip1l,neke,lelke,lelkef,lelktmp
      logical ise_monoton, isp_monoton
      EGS_Float sigee,sigep,sig,sige_old,sigp_old
      integer max_med
      parameter (max_med = MXMED)
      common/bounds/ ecut, pcut, ecut_new, pcut_new, vacdst
      EGS_Float ecut, pcut, ecut_new, pcut_new, vacdst
      COMMON/ELECIN/ esig_e(max_med),psig_e(max_med), esige_max, psige_m
     *ax, range_ep(0:1,500,max_med), E_array(500,max_med), etae_ms0(500,
     *max_med),etae_ms1(500,max_med),etap_ms0(500,max_med),etap_ms1(500,
     *max_med),q1ce_ms0(500,max_med),q1ce_ms1(500,max_med),q1cp_ms0(500,
     *max_med),q1cp_ms1(500,max_med),q2ce_ms0(500,max_med),q2ce_ms1(500,
     *max_med),q2cp_ms0(500,max_med),q2cp_ms1(500,max_med),blcce0(500,ma
     *x_med),blcce1(500,max_med), EKE0(max_med),EKE1(max_med), XR0(max_m
     *ed),TEFF0(max_med),BLCC(max_med),XCC(max_med), ESIG0(500,max_med),
     *ESIG1(500,max_med),PSIG0(500,max_med),PSIG1(500,max_med),EDEDX0(50
     *0,max_med),EDEDX1(500,max_med),PDEDX0(500,max_med),PDEDX1(500,max_
     *med),EBR10(500,max_med),EBR11(500,max_med),PBR10(500,max_med),PBR1
     *1(500,max_med),PBR20(500,max_med),PBR21(500,max_med),TMXS0(500,max
     *_med),TMXS1(500,max_med), expeke1(max_med), IUNRST(max_med),EPSTFL
     *(max_med),IAPRIM(max_med), sig_ismonotone(0:1,max_med)
      EGS_Float esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E
     *_array,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1
     *,  q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blc
     *ce0,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG
     *0,ESIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR1
     *1,  PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/misc/ DUNIT,KMPI,KMPO
      EGS_Float DUNIT
      integer*4 KMPI,KMPO
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common/ET_control/ smaxir,smax_new,estepe,ximax,skindepth_for_bca,
     * transport_algorithm,bca_algorithm,exact_bca
      EGS_Float smaxir,smax_new,estepe,ximax,skindepth_for_bca
      integer*4 transport_algorithm,bca_algorithm
      logical exact_bca
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      IF (( bca_algorithm .EQ. 0 )) THEN
        exact_bca = .true.
      ELSE
        exact_bca = .false.
      END IF
      IF (( estepe .LE. 0 .OR. estepe .GE. 1)) THEN
        estepe = 0.25
      END IF
      IF (( ximax .LE. 0 .OR. ximax .GE. 1 )) THEN
        IF (( exact_bca )) THEN
          ximax = 0.5
        ELSE
          ximax = 0.5
        END IF
      END IF
      IF ((transport_algorithm .NE. 0 .AND. transport_algorithm .NE. 1 .
     *AND. transport_algorithm .NE. 2 )) THEN
        transport_algorithm = 0
      END IF
      IF (( skindepth_for_bca .LE. 1e-4 )) THEN
        IF (( .NOT.exact_bca )) THEN
          write(i_log,*) ' old PRESTA calculates default min. step-size
     *for BCA: '
          ecutmn = 1e30
          DO 4271 i=1,nmed
            ecutmn = Min(ecutmn,ae(i))
4271      CONTINUE
4272      CONTINUE
          ecutmn = Max(ecutmn,ecut)
          write(i_log,*) '     minimum ECUT found: ',ecutmn
          tstbmn = 1e30
          DO 4281 medium=1,nmed
            tstbm = (ecutmn-prm)*(ecutmn+prm)/ecutmn**2
            tstbm = blcc(medium)*tstbm*(ecutmn/xcc(medium))**2
            aux = Log(tstbm)
            IF((aux .GT. 300))write(i_log,*) 'aux > 300 ? ',aux
            tstbm = Log(tstbm/aux)
            tstbmn = Min(tstbmn,tstbm)
4281      CONTINUE
4282      CONTINUE
          write(i_log,*) '     default BLCMIN is: ',tstbmn
          skindepth_for_bca = Exp(tstbmn)
          write(i_log,*) '     this corresponds to ',skindepth_for_bca,
     *    ' elastic MFPs '
        ELSE
          skindepth_for_bca = 3
        END IF
      END IF
      call init_ms_SR
      DO 4291 medium=1,nmed
        blcc(medium) = 1.16699413758864573*blcc(medium)
        xcc(medium) = xcc(medium)**2
4291  CONTINUE
4292  CONTINUE
      IF (( spin_effects )) THEN
        call init_spin
      END IF
      write(i_log,*) ' '
      esige_max = 0
      psige_max = 0
      DO 4301 medium=1,nmed
        sigee = 1E-15
        sigep = 1E-15
        neke = meke(medium)
        ise_monoton = .true.
        isp_monoton = .true.
        sige_old = -1
        sigp_old = -1
        DO 4311 i=1,neke
          ei = exp((float(i) - eke0(medium))/eke1(medium))
          eil = log(ei)
          leil = i
          ededx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
          sig=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
          sig = sig/ededx
          IF((sig .GT. sigee))sigee = sig
          IF((sig .LT. sige_old))ise_monoton = .false.
          sige_old = sig
          ededx=pdedx1(Leil,MEDIUM)*eil+pdedx0(Leil,MEDIUM)
          sig=psig1(Leil,MEDIUM)*eil+psig0(Leil,MEDIUM)
          sig = sig/ededx
          IF((sig .GT. sigep))sigep = sig
          IF((sig .LT. sigp_old))isp_monoton = .false.
          sigp_old = sig
4311    CONTINUE
4312    CONTINUE
        write(i_log,*) ' Medium ',medium,' sige = ',sigee,sigep,' monoto
     *ne = ', ise_monoton,isp_monoton
        sig_ismonotone(0,medium) = ise_monoton
        sig_ismonotone(1,medium) = isp_monoton
        esig_e(medium) = sigee
        psig_e(medium) = sigep
        IF((sigee .GT. esige_max))esige_max = sigee
        IF((sigep .GT. psige_max))psige_max = sigep
4301  CONTINUE
4302  CONTINUE
      write(i_log,*) ' '
      write(i_log,*) ' Initializing tmxs for estepe = ',estepe,' and xim
     *ax = ',ximax
      write(i_log,*) ' '
      DO 4321 medium=1,nmed
        ei = exp((1 - eke0(medium))/eke1(medium))
        eil = log(ei)
        leil = 1
        E_array(1,medium) = ei
        expeke1(medium) = Exp(1./eke1(medium))-1
        range_ep(0,1,medium) = 0
        range_ep(1,1,medium) = 0
        neke = meke(medium)
        DO 4331 i=1,neke - 1
          eip1 = exp((float(i + 1) - eke0(medium))/eke1(medium))
          E_array(i+1,medium) = eip1
          eke = 0.5*(eip1+ei)
          elke = Log(eke)
          Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
          ededx=pdedx1(Lelke,MEDIUM)*elke+pdedx0(Lelke,MEDIUM)
          aux = pdedx1(i,medium)/ededx
          range_ep(1,i+1,medium) = range_ep(1,i,medium) + (eip1-ei)/eded
     *    x*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24)
          ededx=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
          aux = ededx1(i,medium)/ededx
          range_ep(0,i+1,medium) = range_ep(0,i,medium) + (eip1-ei)/eded
     *    x*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24)
          ei = eip1
4331    CONTINUE
4332    CONTINUE
        eil = (1 - eke0(medium))/eke1(medium)
        ei = Exp(eil)
        leil = 1
        p2 = ei*(ei+2*rm)
        beta2 = p2/(p2+rm*rm)
        chi_a2 = Xcc(medium)/(4*p2*blcc(medium))
        dedx0=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
        estepx = 2*p2*beta2*dedx0/ei/Xcc(medium)/(Log(1+1./chi_a2)*(1+ch
     *  i_a2)-1)
        estepx = estepx*ximax
        IF (( estepx .GT. estepe )) THEN
          estepx = estepe
        END IF
        si = estepx*ei/dedx0
        DO 4341 i=1,neke - 1
          elke = (i + 1 - eke0(medium))/eke1(medium)
          eke = Exp(elke)
          lelke = i+1
          p2 = eke*(eke+2*rm)
          beta2 = p2/(p2+rm*rm)
          chi_a2 = Xcc(medium)/(4*p2*blcc(medium))
          ededx=ededx1(Lelke,MEDIUM)*elke+ededx0(Lelke,MEDIUM)
          estepx = 2*p2*beta2*ededx/eke/ Xcc(medium)/(Log(1+1./chi_a2)*(
     *    1+chi_a2)-1)
          estepx = estepx*ximax
          IF (( estepx .GT. estepe )) THEN
            estepx = estepe
          END IF
          ekef = (1-estepx)*eke
          IF (( ekef .LE. E_array(1,medium) )) THEN
            sip1 = (E_array(1,medium) - ekef)/dedx0
            ekef = E_array(1,medium)
            elkef = (1 - eke0(medium))/eke1(medium)
            lelkef = 1
          ELSE
            elkef = Log(ekef)
            Lelkef=eke1(MEDIUM)*elkef+eke0(MEDIUM)
            leip1l = lelkef + 1
            eip1l = (leip1l - eke0(medium))/eke1(medium)
            eip1 = E_array(leip1l,medium)
            aux = (eip1 - ekef)/eip1
            elktmp = 0.5*(elkef+eip1l+0.25*aux*aux*(1+aux*(1+0.875*aux))
     *      )
            ektmp = 0.5*(ekef+eip1)
            lelktmp = lelkef
            ededx=ededx1(Lelktmp,MEDIUM)*elktmp+ededx0(Lelktmp,MEDIUM)
            aux = ededx1(lelktmp,medium)/ededx
            sip1 = (eip1 - ekef)/ededx*( 1+aux*(1+2*aux)*((eip1-ekef)/ek
     *      tmp)**2/24)
          END IF
          sip1 = sip1 + range_ep(0,lelke,medium) - range_ep(0,lelkef+1,m
     *    edium)
          tmxs1(i,medium) = (sip1 - si)*eke1(medium)
          tmxs0(i,medium) = sip1 - tmxs1(i,medium)*elke
          si = sip1
4341    CONTINUE
4342    CONTINUE
        tmxs0(neke,medium) = tmxs0(neke - 1,medium)
        tmxs1(neke,medium) = tmxs1(neke - 1,medium)
4321  CONTINUE
4322  CONTINUE
      return
      end
      subroutine mscat(lambda,chia2,q1,elke,beta2,qel,medium, spin_effec
     *ts,find_index,spin_index, cost,sint)
      implicit none
      EGS_Float lambda, chia2,q1,elke,beta2,cost,sint
      integer*4 qel,medium
      logical spin_effects,find_index,spin_index
      common/ms_data/ ums_array(0:63,0:7,0:31), fms_array(0:63,0:7,0:31)
     *, wms_array(0:63,0:7,0:31), ims_array(0:63,0:7,0:31), llammin,llam
     *max,dllamb,dllambi,dqms,dqmsi
      real*4 ums_array,fms_array,wms_array, llammin,llammax,dllamb,dllam
     *bi,dqms,dqmsi
      integer*2 ims_array
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      EGS_Float sprob,explambda,wsum,wprob,xi,rejf,spin_rejection, cosz,
     *sinz,phi,omega2,llmbda,ai,aj,ak,a,u,du,x1,rnno
      integer*4 icount,i,j,k
      save i,j,omega2
      IF ((lambda .LE. 13.8)) THEN
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        sprob = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        explambda = Exp(-lambda)
        IF ((sprob .LT. explambda)) THEN
          cost = 1
          sint = 0
          return
        END IF
        wsum = (1+lambda)*explambda
        IF (( sprob .LT. wsum )) THEN
4350      CONTINUE
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          xi = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          xi = 2*chia2*xi/(1 - xi + chia2)
          cost = 1 - xi
          IF (( spin_effects )) THEN
            rejf = spin_rejection(qel,medium,elke,beta2,q1,cost, spin_in
     *      dex,.false.)
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            rnno = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            IF (( rnno .GT. rejf )) THEN
              GOTO 4350
            END IF
          END IF
          sint = sqrt(xi*(2 - xi))
          return
        END IF
        IF (( lambda .LE. 1 )) THEN
          wprob = explambda
          wsum = explambda
          cost = 1
          sint = 0
          icount = 0
4361      CONTINUE
            icount = icount + 1
            IF((icount .GT. 20))GO TO4362
            wprob = wprob*lambda/icount
            wsum = wsum + wprob
4370        CONTINUE
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            xi = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            xi = 2*chia2*xi/(1 - xi + chia2)
            cosz = 1 - xi
            IF (( spin_effects )) THEN
              rejf = spin_rejection(qel,medium,elke,beta2,q1,cosz, spin_
     *        index,.false.)
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              rnno = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              IF (( rnno .GT. rejf )) THEN
                GOTO 4370
              END IF
            END IF
            sinz = xi*(2 - xi)
            IF (( sinz .GT. 1.e-20 )) THEN
              sinz = Sqrt(sinz)
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              xi = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              phi = xi*6.2831853
              cost = cost*cosz - sint*sinz*Cos(phi)
              sint = Sqrt(Max(0.0,(1-cost)*(1+cost)))
            END IF
            IF((( wsum .GT. sprob)))GO TO4362
          GO TO 4361
4362      CONTINUE
          return
        END IF
      END IF
      IF ((lambda .LE. 1e5 )) THEN
        IF ((find_index)) THEN
          llmbda = log(lambda)
          ai = llmbda*dllambi
          i = ai
          ai = ai - i
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          xi = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF((xi .LT. ai))i = i + 1
          IF (( q1 .LT. 1e-3 )) THEN
            j = 0
          ELSE IF(( q1 .LT. 0.5 )) THEN
            aj = q1*dqmsi
            j = aj
            aj = aj - j
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            xi = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            IF((xi .LT. aj))j = j + 1
          ELSE
            j = 7
          END IF
          IF ((llmbda .LT. 2.2299)) THEN
            omega2 = chia2*(lambda + 4)*(1.347006 + llmbda*( 0.209364 -
     *      llmbda*(0.45525 - llmbda*(0.50142 - 0.081234*llmbda))))
          ELSE
            omega2 = chia2*(lambda + 4)*(-2.77164 + llmbda*(2.94874 - ll
     *      mbda*(0.1535754 - llmbda*0.00552888)))
          END IF
          find_index = .false.
        END IF
4380    CONTINUE
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        xi = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        ak = xi*31
        k = ak
        ak = ak - k
        IF((ak .GT. wms_array(i,j,k)))k = ims_array(i,j,k)
        a = fms_array(i,j,k)
        u = ums_array(i,j,k)
        du = ums_array(i,j,k+1) - u
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        xi = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        IF (( abs(a) .LT. 0.2 )) THEN
          x1 = 0.5*(1-xi)*a
          u = u + xi*du*(1+x1*(1-xi*a))
        ELSE
          u = u - du/a*(1-Sqrt(1+xi*a*(2+a)))
        END IF
        xi = omega2*u/(1 + 0.5*omega2 - u)
        IF (( xi .GT. 1.99999 )) THEN
          xi = 1.99999
        END IF
        cost = 1 - xi
        IF (( spin_effects )) THEN
          rejf=spin_rejection(qel,medium,elke,beta2,q1,cost,spin_index,.
     *    false.)
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnno = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF (( rnno .GT. rejf )) THEN
            GOTO 4380
          END IF
        END IF
        sint = sqrt(xi*(2-xi))
        return
      END IF
      write(i_log,*) ' '
      write(i_log,*) ' *************************************'
      write(i_log,*) ' Maximum step size in mscat exceeded! '
      write(i_log,*) ' Maximum step size initialized: 100000'
      write(i_log,*) ' Present lambda: ',lambda
      write(i_log,*) ' chia2: ',chia2
      write(i_log,*) ' q1 elke beta2: ',q1,elke,beta2
      write(i_log,*) ' medium: ',medium
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' Stopping execution'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      EGS_Float function spin_rejection(qel,medium,elke,beta2,q1,cost, s
     *pin_index,is_single)
      implicit none
      EGS_Float elke,beta2,q1,cost
      integer*4 qel,medium
      logical spin_index,is_single
      integer max_med
      parameter (max_med = MXMED)
      common/spin_data/ spin_rej(max_med,0:1,0: 31,0:15,0:31), espin_min
     *,espin_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dlen
     *eri,dqq1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      EGS_Float rnno,ai,qq1,aj,xi,ak
      integer*4 i,j,k
      save i,j
      IF (( spin_index )) THEN
        spin_index = .false.
        IF (( beta2 .GE. b2spin_min )) THEN
          ai = (beta2 - b2spin_min)*dbeta2i
          i = ai
          ai = ai - i
          i = i + 15 + 1
        ELSE IF(( elke .GT. espml )) THEN
          ai = (elke - espml)*dleneri
          i = ai
          ai = ai - i
        ELSE
          i = 0
          ai = -1
        END IF
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        rnno = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        IF((rnno .LT. ai))i = i + 1
        IF (( is_single )) THEN
          j = 0
        ELSE
          qq1 = 2*q1
          qq1 = qq1/(1 + qq1)
          aj = qq1*dqq1i
          j = aj
          IF (( j .GE. 15 )) THEN
            j = 15
          ELSE
            aj = aj - j
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            rnno = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            IF((rnno .LT. aj))j = j + 1
          END IF
        END IF
      END IF
      xi = Sqrt(0.5*(1-cost))
      ak = xi*31
      k = ak
      ak = ak - k
      spin_rejection = (1-ak)*spin_rej(medium,qel,i,j,k) + ak*spin_rej(m
     *edium,qel,i,j,k+1)
      return
      end
      subroutine sscat(chia2,elke,beta2,qel,medium,spin_effects,cost,sin
     *t)
      implicit none
      EGS_Float chia2,elke,beta2,cost,sint
      integer*4 qel,medium
      logical spin_effects
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      EGS_Float xi,rnno,rejf,spin_rejection,qzero
      logical spin_index
      spin_index = .true.
4390  CONTINUE
      IF (( rng_seed .GT. 128 )) THEN
        rng_seed = 128
        call egs_fill_rndm_array(rng_seed,rng_array)
        rng_seed = 1
      END IF
      xi = rng_array(rng_seed)
      rng_seed = rng_seed + 1
      xi = 2*chia2*xi/(1 - xi + chia2)
      cost = 1 - xi
      IF (( spin_effects )) THEN
        qzero=0
        rejf = spin_rejection(qel,medium,elke,beta2,qzero,cost,spin_inde
     *  x,.true.)
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        rnno = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        IF((rnno .GT. rejf))goto 4390
      END IF
      sint = sqrt(xi*(2 - xi))
      return
      end
      subroutine init_ms_SR
      implicit none
      common/ms_data/ ums_array(0:63,0:7,0:31), fms_array(0:63,0:7,0:31)
     *, wms_array(0:63,0:7,0:31), ims_array(0:63,0:7,0:31), llammin,llam
     *max,dllamb,dllambi,dqms,dqmsi
      real*4 ums_array,fms_array,wms_array, llammin,llammax,dllamb,dllam
     *bi,dqms,dqmsi
      integer*2 ims_array
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 i,j,k
      write(i_log,'(/a,$)') 'Reading screened Rutherford MS data .......
     *........ '
      rewind(i_mscat)
      DO 4401 i=0,63
        DO 4411 j=0,7
          read(i_mscat,*) (ums_array(i,j,k),k=0,31)
          read(i_mscat,*) (fms_array(i,j,k),k=0,31)
          read(i_mscat,*) (wms_array(i,j,k),k=0,31-1)
          read(i_mscat,*) (ims_array(i,j,k),k=0,31-1)
          DO 4421 k=0,31-1
            fms_array(i,j,k) = fms_array(i,j,k+1)/fms_array(i,j,k)-1
            ims_array(i,j,k) = ims_array(i,j,k)-1
4421      CONTINUE
4422      CONTINUE
          fms_array(i,j,31)=fms_array(i,j,31-1)
4411    CONTINUE
4412    CONTINUE
4401  CONTINUE
4402  CONTINUE
      write(i_log,'(a)') ' done '
      llammin = Log(1.)
      llammax = Log(1e5)
      dllamb = (llammax-llammin)/63
      dllambi = 1./dllamb
      dqms = 0.5/7
      dqmsi = 1./dqms
      return
      end
      subroutine init_spin
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common/spin_data/ spin_rej(max_med,0:1,0: 31,0:15,0:31), espin_min
     *,espin_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dlen
     *eri,dqq1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      COMMON/ELECIN/ esig_e(max_med),psig_e(max_med), esige_max, psige_m
     *ax, range_ep(0:1,500,max_med), E_array(500,max_med), etae_ms0(500,
     *max_med),etae_ms1(500,max_med),etap_ms0(500,max_med),etap_ms1(500,
     *max_med),q1ce_ms0(500,max_med),q1ce_ms1(500,max_med),q1cp_ms0(500,
     *max_med),q1cp_ms1(500,max_med),q2ce_ms0(500,max_med),q2ce_ms1(500,
     *max_med),q2cp_ms0(500,max_med),q2cp_ms1(500,max_med),blcce0(500,ma
     *x_med),blcce1(500,max_med), EKE0(max_med),EKE1(max_med), XR0(max_m
     *ed),TEFF0(max_med),BLCC(max_med),XCC(max_med), ESIG0(500,max_med),
     *ESIG1(500,max_med),PSIG0(500,max_med),PSIG1(500,max_med),EDEDX0(50
     *0,max_med),EDEDX1(500,max_med),PDEDX0(500,max_med),PDEDX1(500,max_
     *med),EBR10(500,max_med),EBR11(500,max_med),PBR10(500,max_med),PBR1
     *1(500,max_med),PBR20(500,max_med),PBR21(500,max_med),TMXS0(500,max
     *_med),TMXS1(500,max_med), expeke1(max_med), IUNRST(max_med),EPSTFL
     *(max_med),IAPRIM(max_med), sig_ismonotone(0:1,max_med)
      EGS_Float esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E
     *_array,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1
     *,  q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blc
     *ce0,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG
     *0,ESIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR1
     *1,  PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      EGS_Float eta_array(0:1,0: 31), c_array(0:1,0: 31),g_array(0:1,0:
     *31), earray(0: 31),tmp_array(0: 31), sum_Z2,sum_Z,sum_A,sum_pz,Z,t
     *mp,Z23,g_m,g_r,sig,dedx, tau,tauc,beta2,eta,gamma,fmax, eil,e,si1e
     *,si2e,si1p,si2p,aae,etap, elarray(0: 31),farray(0: 31), af(0: 31),
     *bf(0: 31),cf(0: 31), df(0: 31),spline,dloge,eloge
      real*4 dum1,dum2,dum3,aux_o
      real*4 fmax_array(0:15)
      integer*2 i2_array(512),ii2
      integer*4 iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke, nd
     *ata,leil,length,ii4,irec
      character spin_file*256
      character*6 string
      integer*4 lnblnk1
      integer*4 spin_unit, rec_length, want_spin_unit
      integer egs_get_unit
      character data_version*32,endianess*4
      logical swap
      EGS_Float fine,TF_constant
      parameter (fine=137.03604,TF_constant=0.88534138)
      real*4 tmp_4
      character c_2(2), c_4(4)
      equivalence (ii2,c_2), (tmp_4,c_4)
      DO 4431 i=1,len(spin_file)
        spin_file(i:i) = ' '
4431  CONTINUE
4432  CONTINUE
      spin_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'sp
     *inms.data'
      want_spin_unit = 61
      spin_unit = egs_get_unit(want_spin_unit)
      IF (( spin_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'init_spin: failed to get a free fortran unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      rec_length = 276*4
      open(spin_unit,file=spin_file,form='unformatted',access='direct',
     *status='old',recl=rec_length,err=4440)
      read(spin_unit,rec=1,err=4450) data_version,endianess, espin_min,e
     *spin_max,b2spin_min,b2spin_max
      swap = endianess.ne.'1234'
      IF (( swap )) THEN
        tmp_4 = espin_min
        call egs_swap_4(c_4)
        espin_min = tmp_4
        tmp_4 = espin_max
        call egs_swap_4(c_4)
        espin_max = tmp_4
        tmp_4 = b2spin_min
        call egs_swap_4(c_4)
        b2spin_min = tmp_4
        tmp_4 = b2spin_max
        call egs_swap_4(c_4)
        b2spin_max = tmp_4
      END IF
      write(i_log,'(//a,a)') 'Reading spin data base from ',spin_file(:l
     *nblnk1(spin_file))
      write(i_log,'(a)') data_version
      write(i_log,'(a,a,a)') 'Data generated on a machine with ',endiane
     *ss, ' endianess'
      write(i_log,'(a,a)') 'The endianess of this CPU is ','1234'
      IF((swap))write(i_log,'(a)') '=> will need to do byte swaping'
      write(i_log,'(a,2f9.2,2f9.5,//)') 'Ranges: ',espin_min,espin_max,
     *b2spin_min,b2spin_max
      n_ener = 15
      n_q = 15
      n_point = 31
      dloge = log(espin_max/espin_min)/n_ener
      eloge = log(espin_min)
      earray(0) = espin_min
      IF (( fool_intel_optimizer )) THEN
        write(25,*) 'Energy grid:'
      END IF
      DO 4461 i=1,n_ener
        eloge = eloge + dloge
        earray(i) = exp(eloge)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) i,earray(i)
        END IF
4461  CONTINUE
4462  CONTINUE
      dbeta2 = (b2spin_max - b2spin_min)/n_ener
      beta2 = b2spin_min
      earray(n_ener+1) = espin_max
      DO 4471 i=n_ener+2,2*n_ener+1
        beta2 = beta2 + dbeta2
        IF (( beta2 .LT. 0.999 )) THEN
          earray(i) = prm*1000.0*(1/sqrt(1-beta2)-1)
        ELSE
          earray(i) = 50585.1
        END IF
        IF (( fool_intel_optimizer )) THEN
          write(25,*) i,earray(i)
        END IF
4471  CONTINUE
4472  CONTINUE
      espin_min = espin_min/1000
      espin_max = espin_max/1000
      dlener = Log(espin_max/espin_min)/15
      dleneri = 1/dlener
      espml = Log(espin_min)
      dbeta2 = (b2spin_max-b2spin_min)/15
      dbeta2i = 1/dbeta2
      dqq1 = 0.5/15
      dqq1i = 1/dqq1
      DO 4481 medium=1,NMED
        write(i_log,'(a,i4,a,$)') '  medium ',medium,' .................
     *.... '
        DO 4491 iq=0,1
          DO 4501 i=0, 31
            eta_array(iq,i)=0
            c_array(iq,i)=0
            g_array(iq,i)=0
            DO 4511 j=0,15
              DO 4521 k=0,31
                spin_rej(medium,iq,i,j,k) = 0
4521          CONTINUE
4522          CONTINUE
4511        CONTINUE
4512        CONTINUE
4501      CONTINUE
4502      CONTINUE
4491    CONTINUE
4492    CONTINUE
        sum_Z2=0
        sum_A=0
        sum_pz=0
        sum_Z=0
        DO 4531 i_ele=1,NNE(medium)
          Z = ZELEM(medium,i_ele)
          iZ = int(Z+0.5)
          IF (( fool_intel_optimizer )) THEN
            write(25,*) ' Z = ',iZ
          END IF
          tmp = PZ(medium,i_ele)*Z*(Z+1)
          sum_Z2 = sum_Z2 + tmp
          sum_Z = sum_Z + PZ(medium,i_ele)*Z
          sum_A = sum_A + PZ(medium,i_ele)*WA(medium,i_ele)
          sum_pz = sum_pz + PZ(medium,i_ele)
          Z23 = Z**0.6666667
          DO 4541 iq=0,1
            DO 4551 i=0, 31
              irec = 1 + (iz-1)*4*(n_ener+1) + 2*iq*(n_ener+1) + i+1
              IF (( fool_intel_optimizer )) THEN
                write(25,*) '**** energy ',i,earray(i),irec
              END IF
              read(spin_unit,rec=irec,err=4450) dum1,dum2,dum3,aux_o,fma
     *        x_array,i2_array
              IF (( swap )) THEN
                tmp_4 = dum1
                call egs_swap_4(c_4)
                dum1 = tmp_4
                tmp_4 = dum2
                call egs_swap_4(c_4)
                dum2 = tmp_4
                tmp_4 = dum3
                call egs_swap_4(c_4)
                dum3 = tmp_4
                tmp_4 = aux_o
                call egs_swap_4(c_4)
                aux_o = tmp_4
              END IF
              eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o)
              tau = earray(i)/prm*0.001
              beta2 = tau*(tau+2)/(tau+1)**2
              eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2)
              c_array(iq,i)=c_array(iq,i)+ tmp*(Log(1+1/eta)-1/(1+eta))*
     *        dum1*dum3
              g_array(iq,i)=g_array(iq,i)+tmp*dum2
              DO 4561 j=0,15
                tmp_4 = fmax_array(j)
                IF((swap))call egs_swap_4(c_4)
                DO 4571 k=0,31
                  ii2 = i2_array((n_point+1)*j + k+1)
                  IF((swap))call egs_swap_2(c_2)
                  ii4 = ii2
                  IF((ii4 .LT. 0))ii4 = ii4 + 65536
                  dum1 = ii4
                  dum1 = dum1*tmp_4/65535
                  spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)
     *            + tmp*dum1
4571            CONTINUE
4572            CONTINUE
4561          CONTINUE
4562          CONTINUE
4551        CONTINUE
4552        CONTINUE
4541      CONTINUE
4542      CONTINUE
4531    CONTINUE
4532    CONTINUE
        DO 4581 iq=0,1
          DO 4591 i=0, 31
            DO 4601 j=0,15
              fmax = 0
              DO 4611 k=0,31
                IF (( spin_rej(medium,iq,i,j,k) .GT. fmax )) THEN
                  fmax = spin_rej(medium,iq,i,j,k)
                END IF
4611          CONTINUE
4612          CONTINUE
              DO 4621 k=0,31
                spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fm
     *          ax
4621          CONTINUE
4622          CONTINUE
4601        CONTINUE
4602        CONTINUE
4591      CONTINUE
4592      CONTINUE
4581    CONTINUE
4582    CONTINUE
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Spin corrections as read in from file'
        END IF
        DO 4631 i=0, 31
          tau = earray(i)/prm*0.001
          beta2 = tau*(tau+2)/(tau+1)**2
          DO 4641 iq=0,1
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium)
            eta = aux_o/4/tau/(tau+2)
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/ (Log(1+1/eta)*
     *      (1+eta)-1)
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta)
     *      )
4641      CONTINUE
4642      CONTINUE
          IF (( fool_intel_optimizer )) THEN
            write(25,*) i,earray(i),eta_array(0,i),eta_array(1,i), c_arr
     *      ay(0,i),c_array(1,i),g_array(0,i),g_array(1,i)
          END IF
4631    CONTINUE
4632    CONTINUE
        eil = (1 - eke0(medium))/eke1(medium)
        e = Exp(eil)
        IF (( e .LE. espin_min )) THEN
          si1e = eta_array(0,0)
          si1p = eta_array(1,0)
        ELSE
          IF (( e .LE. espin_max )) THEN
            aae = (eil-espml)*dleneri
            je = aae
            aae = aae - je
          ELSE
            tau = e/prm
            beta2 = tau*(tau+2)/(tau+1)**2
            aae = (beta2 - b2spin_min)*dbeta2i
            je = aae
            aae = aae - je
            je = je + 15 + 1
          END IF
          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
        END IF
        neke = meke(medium)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for eta correction'
        END IF
        DO 4651 i=1,neke - 1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          IF (( e .LE. espin_min )) THEN
            si2e = eta_array(0,0)
            si2p = eta_array(1,0)
          ELSE
            IF (( e .LE. espin_max )) THEN
              aae = (eil-espml)*dleneri
              je = aae
              aae = aae - je
            ELSE
              tau = e/prm
              beta2 = tau*(tau+2)/(tau+1)**2
              aae = (beta2 - b2spin_min)*dbeta2i
              je = aae
              aae = aae - je
              je = je + 15 + 1
            END IF
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
          END IF
          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil
          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium)
          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) i,e,si2e,si2p,etae_ms1(i,medium), etae_ms0(i,med
     *      ium),etap_ms1(i,medium),etap_ms0(i,medium)
          END IF
          si1e = si2e
          si1p = si2p
4651    CONTINUE
4652    CONTINUE
        etae_ms1(neke,medium) = etae_ms1(neke-1,medium)
        etae_ms0(neke,medium) = etae_ms0(neke-1,medium)
        etap_ms1(neke,medium) = etap_ms1(neke-1,medium)
        etap_ms0(neke,medium) = etap_ms0(neke-1,medium)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'elarray:'
        END IF
        DO 4661 i=0,15
          elarray(i) = Log(earray(i)/1000)
          farray(i) = c_array(0,i)
          IF (( fool_intel_optimizer )) THEN
            write(25,*) elarray(i),earray(i)
          END IF
4661    CONTINUE
4662    CONTINUE
        DO 4671 i=15+1, 31-1
          elarray(i) = Log(earray(i+1)/1000)
          farray(i) = c_array(0,i+1)
          IF (( fool_intel_optimizer )) THEN
            write(25,*) elarray(i),earray(i+1)
          END IF
4671    CONTINUE
4672    CONTINUE
        ndata =  31+1
        IF (( ue(medium) .GT. 1e5 )) THEN
          elarray(ndata-1) = Log(ue(medium))
        ELSE
          elarray(ndata-1) = Log(1e5)
        END IF
        farray(ndata-1) = 1
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q1 correction (e-)'
        END IF
        DO 4681 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q1ce_ms1(i,medium), q1ce_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
4681    CONTINUE
4682    CONTINUE
        q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium)
        q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Postrons:'
        END IF
        DO 4691 i=0,15
          farray(i) = c_array(1,i)
4691    CONTINUE
4692    CONTINUE
        DO 4701 i=15+1, 31-1
          farray(i) = c_array(1,i+1)
4701    CONTINUE
4702    CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q1 correction (e+)'
        END IF
        DO 4711 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q1cp_ms1(i,medium), q1cp_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
4711    CONTINUE
4712    CONTINUE
        q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium)
        q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium)
        DO 4721 i=0,15
          farray(i) = g_array(0,i)
4721    CONTINUE
4722    CONTINUE
        DO 4731 i=15+1, 31-1
          farray(i) = g_array(0,i+1)
4731    CONTINUE
4732    CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q2 correction (e-)'
        END IF
        DO 4741 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q2ce_ms1(i,medium), q2ce_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
4741    CONTINUE
4742    CONTINUE
        q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium)
        q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium)
        DO 4751 i=0,15
          farray(i) = g_array(1,i)
4751    CONTINUE
4752    CONTINUE
        DO 4761 i=15+1, 31-1
          farray(i) = g_array(1,i+1)
4761    CONTINUE
4762    CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        IF (( fool_intel_optimizer )) THEN
          write(25,*) 'Interpolation table for q2 correction (e+)'
        END IF
        DO 4771 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil
          IF (( fool_intel_optimizer )) THEN
            write(25,*) Exp(eil),si2e,q2cp_ms1(i,medium), q2cp_ms0(i,med
     *      ium)
          END IF
          si1e = si2e
4771    CONTINUE
4772    CONTINUE
        q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium)
        q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium)
        tauc = te(medium)/prm
        si1e = 1
        DO 4781 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          leil=i+1
          tau=e/prm
          IF (( tau .GT. 2*tauc )) THEN
            sig=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
            dedx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
            sig = sig/dedx
            IF (( sig .GT. 1e-6 )) THEN
              etap=etae_ms1(Leil,MEDIUM)*eil+etae_ms0(Leil,MEDIUM)
              eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2)
              g_r = (1+2*eta)*Log(1+1/eta)-2
              g_m = Log(0.5*tau/tauc)+ (1+((tau+2)/(tau+1))**2)*Log(2*(t
     *        au-tauc+2)/(tau+4))- 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+
     *        1)**2)* Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+ 0.5*(tau
     *        -2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2)
              IF (( g_m .LT. g_r )) THEN
                g_m = g_m/g_r
              ELSE
                g_m = 1
              END IF
              si2e = 1 - g_m*sum_Z/sum_Z2
            ELSE
              si2e = 1
            END IF
          ELSE
            si2e = 1
          END IF
          blcce1(i,medium) = (si2e - si1e)*eke1(medium)
          blcce0(i,medium) = si2e - blcce1(i,medium)*eil
          si1e = si2e
4781    CONTINUE
4782    CONTINUE
        blcce1(neke,medium) = blcce1(neke-1,medium)
        blcce0(neke,medium) = blcce0(neke-1,medium)
        write(i_log,'(a)') ' done'
4481  CONTINUE
4482  CONTINUE
      close(spin_unit)
      return
4440  write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,a)') 'Failed to open spin data file ',spin_file(:l
     *nblnk1(spin_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
4450  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Error while reading spin data file for element',iZ
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine init_spin_old
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common/spin_data/ spin_rej(max_med,0:1,0: 31,0:15,0:31), espin_min
     *,espin_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dlen
     *eri,dqq1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      COMMON/ELECIN/ esig_e(max_med),psig_e(max_med), esige_max, psige_m
     *ax, range_ep(0:1,500,max_med), E_array(500,max_med), etae_ms0(500,
     *max_med),etae_ms1(500,max_med),etap_ms0(500,max_med),etap_ms1(500,
     *max_med),q1ce_ms0(500,max_med),q1ce_ms1(500,max_med),q1cp_ms0(500,
     *max_med),q1cp_ms1(500,max_med),q2ce_ms0(500,max_med),q2ce_ms1(500,
     *max_med),q2cp_ms0(500,max_med),q2cp_ms1(500,max_med),blcce0(500,ma
     *x_med),blcce1(500,max_med), EKE0(max_med),EKE1(max_med), XR0(max_m
     *ed),TEFF0(max_med),BLCC(max_med),XCC(max_med), ESIG0(500,max_med),
     *ESIG1(500,max_med),PSIG0(500,max_med),PSIG1(500,max_med),EDEDX0(50
     *0,max_med),EDEDX1(500,max_med),PDEDX0(500,max_med),PDEDX1(500,max_
     *med),EBR10(500,max_med),EBR11(500,max_med),PBR10(500,max_med),PBR1
     *1(500,max_med),PBR20(500,max_med),PBR21(500,max_med),TMXS0(500,max
     *_med),TMXS1(500,max_med), expeke1(max_med), IUNRST(max_med),EPSTFL
     *(max_med),IAPRIM(max_med), sig_ismonotone(0:1,max_med)
      EGS_Float esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E
     *_array,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1
     *,  q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blc
     *ce0,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG
     *0,ESIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR1
     *1,  PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      EGS_Float eta_array(0:1,0: 31), c_array(0:1,0: 31),g_array(0:1,0:
     *31), earray(0: 31),tmp_array(0: 31), sum_Z2,sum_Z,sum_A,sum_pz,Z,t
     *mp,Z23,g_m,g_r,sig,dedx, dum1,dum2,dum3,aux_o,tau,tauc,beta2,eta,g
     *amma,fmax, eil,e,si1e,si2e,si1p,si2p,aae,etap, elarray(0: 31),farr
     *ay(0: 31), af(0: 31),bf(0: 31),cf(0: 31), df(0: 31),spline
      integer*4 iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke, nd
     *ata,leil,length,want_spin_unit,spin_unit,egs_get_unit
      character spin_file*256
      character*6 string
      integer*4 lnblnk1
      EGS_Float fine,TF_constant
      parameter (fine=137.03604,TF_constant=0.88534138)
      DO 4791 i=1,len(spin_file)
        spin_file(i:i) = ' '
4791  CONTINUE
4792  CONTINUE
      spin_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'sp
     *inms' // '/' // 'z000'
      length = lnblnk1(spin_file)
      DO 4801 medium=1,NMED
        write(i_log,'(a,i4,a,$)') '  Initializing spin data for medium '
     *  ,medium, ' ..................... '
        DO 4811 iq=0,1
          DO 4821 i=0, 31
            eta_array(iq,i)=0
            c_array(iq,i)=0
            g_array(iq,i)=0
            DO 4831 j=0,15
              DO 4841 k=0,31
                spin_rej(medium,iq,i,j,k) = 0
4841          CONTINUE
4842          CONTINUE
4831        CONTINUE
4832        CONTINUE
4821      CONTINUE
4822      CONTINUE
4811    CONTINUE
4812    CONTINUE
        sum_Z2=0
        sum_A=0
        sum_pz=0
        sum_Z=0
        DO 4851 i_ele=1,NNE(medium)
          Z = ZELEM(medium,i_ele)
          iZ = int(Z+0.5)
          tmp = PZ(medium,i_ele)*Z*(Z+1)
          iii = iZ/100
          spin_file(length-2:length-2) = char(iii+48)
          iiZ = iZ - iii*100
          iii = iiZ/10
          spin_file(length-1:length-1) = char(iii+48)
          iiZ = iiZ - 10*iii
          spin_file(length:length) = char(iiZ+48)
          want_spin_unit = 61
          spin_unit = egs_get_unit(want_spin_unit)
          IF (( spin_unit .LT. 1 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'init_spin: failed to get a free fortran unit
     *'
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(spin_unit,file=spin_file,status='old',err=4860)
          read(spin_unit,*) espin_min,espin_max,b2spin_min,b2spin_max
          read(spin_unit,*) n_ener,n_q,n_point
          IF (( n_ener .NE. 15 .OR. n_q .NE. 15 .OR. n_point .NE. 31)) T
     *    HEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) ' Wrong spin file for Z = ',iZ
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          sum_Z2 = sum_Z2 + tmp
          sum_Z = sum_Z + PZ(medium,i_ele)*Z
          sum_A = sum_A + PZ(medium,i_ele)*WA(medium,i_ele)
          sum_pz = sum_pz + PZ(medium,i_ele)
          Z23 = Z**0.6666667
          DO 4871 iq=0,1
            read(spin_unit,*)
            read(spin_unit,*)
            DO 4881 i=0, 31
              read(spin_unit,'(a,g14.6)') string,earray(i)
              read(spin_unit,*) dum1,dum2,dum3,aux_o
              eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o)
              tau = earray(i)/prm*0.001
              beta2 = tau*(tau+2)/(tau+1)**2
              eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2)
              c_array(iq,i)=c_array(iq,i)+ tmp*(Log(1+1/eta)-1/(1+eta))*
     *        dum1*dum3
              g_array(iq,i)=g_array(iq,i)+tmp*dum2
              DO 4891 j=0,15
                read(spin_unit,*) tmp_array
                DO 4901 k=0,31
                  spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)
     *            + tmp*tmp_array(k)
4901            CONTINUE
4902            CONTINUE
4891          CONTINUE
4892          CONTINUE
4881        CONTINUE
4882        CONTINUE
4871      CONTINUE
4872      CONTINUE
          close(spin_unit)
4851    CONTINUE
4852    CONTINUE
        DO 4911 iq=0,1
          DO 4921 i=0, 31
            DO 4931 j=0,15
              fmax = 0
              DO 4941 k=0,31
                IF (( spin_rej(medium,iq,i,j,k) .GT. fmax )) THEN
                  fmax = spin_rej(medium,iq,i,j,k)
                END IF
4941          CONTINUE
4942          CONTINUE
              DO 4951 k=0,31
                spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fm
     *          ax
4951          CONTINUE
4952          CONTINUE
4931        CONTINUE
4932        CONTINUE
4921      CONTINUE
4922      CONTINUE
4911    CONTINUE
4912    CONTINUE
        DO 4961 i=0, 31
          tau = earray(i)/prm*0.001
          beta2 = tau*(tau+2)/(tau+1)**2
          DO 4971 iq=0,1
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium)
            eta = aux_o/4/tau/(tau+2)
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/ (Log(1+1/eta)*
     *      (1+eta)-1)
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta)
     *      )
4971      CONTINUE
4972      CONTINUE
4961    CONTINUE
4962    CONTINUE
        espin_min = espin_min/1000
        espin_max = espin_max/1000
        dlener = Log(espin_max/espin_min)/15
        dleneri = 1/dlener
        espml = Log(espin_min)
        dbeta2 = (b2spin_max-b2spin_min)/15
        dbeta2i = 1/dbeta2
        dqq1 = 0.5/15
        dqq1i = 1/dqq1
        eil = (1 - eke0(medium))/eke1(medium)
        e = Exp(eil)
        IF (( e .LE. espin_min )) THEN
          si1e = eta_array(0,0)
          si1p = eta_array(1,0)
        ELSE
          IF (( e .LE. espin_max )) THEN
            aae = (eil-espml)*dleneri
            je = aae
            aae = aae - je
          ELSE
            tau = e/prm
            beta2 = tau*(tau+2)/(tau+1)**2
            aae = (beta2 - b2spin_min)*dbeta2i
            je = aae
            aae = aae - je
            je = je + 15 + 1
          END IF
          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
        END IF
        neke = meke(medium)
        DO 4981 i=1,neke - 1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          IF (( e .LE. espin_min )) THEN
            si2e = eta_array(0,0)
            si2p = eta_array(1,0)
          ELSE
            IF (( e .LE. espin_max )) THEN
              aae = (eil-espml)*dleneri
              je = aae
              aae = aae - je
            ELSE
              tau = e/prm
              beta2 = tau*(tau+2)/(tau+1)**2
              aae = (beta2 - b2spin_min)*dbeta2i
              je = aae
              aae = aae - je
              je = je + 15 + 1
            END IF
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1)
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1)
          END IF
          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil
          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium)
          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil
          si1e = si2e
          si1p = si2p
4981    CONTINUE
4982    CONTINUE
        etae_ms1(neke,medium) = etae_ms1(neke-1,medium)
        etae_ms0(neke,medium) = etae_ms0(neke-1,medium)
        etap_ms1(neke,medium) = etap_ms1(neke-1,medium)
        etap_ms0(neke,medium) = etap_ms0(neke-1,medium)
        DO 4991 i=0,15
          elarray(i) = Log(earray(i)/1000)
          farray(i) = c_array(0,i)
4991    CONTINUE
4992    CONTINUE
        DO 5001 i=15+1, 31-1
          elarray(i) = Log(earray(i+1)/1000)
          farray(i) = c_array(0,i+1)
5001    CONTINUE
5002    CONTINUE
        ndata =  31+1
        IF (( ue(medium) .GT. 1e5 )) THEN
          elarray(ndata-1) = Log(ue(medium))
        ELSE
          elarray(ndata-1) = Log(1e5)
        END IF
        farray(ndata-1) = 1
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 5011 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil
          si1e = si2e
5011    CONTINUE
5012    CONTINUE
        q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium)
        q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium)
        DO 5021 i=0,15
          farray(i) = c_array(1,i)
5021    CONTINUE
5022    CONTINUE
        DO 5031 i=15+1, 31-1
          farray(i) = c_array(1,i+1)
5031    CONTINUE
5032    CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 5041 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil
          si1e = si2e
5041    CONTINUE
5042    CONTINUE
        q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium)
        q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium)
        DO 5051 i=0,15
          farray(i) = g_array(0,i)
5051    CONTINUE
5052    CONTINUE
        DO 5061 i=15+1, 31-1
          farray(i) = g_array(0,i+1)
5061    CONTINUE
5062    CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 5071 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil
          si1e = si2e
5071    CONTINUE
5072    CONTINUE
        q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium)
        q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium)
        DO 5081 i=0,15
          farray(i) = g_array(1,i)
5081    CONTINUE
5082    CONTINUE
        DO 5091 i=15+1, 31-1
          farray(i) = g_array(1,i+1)
5091    CONTINUE
5092    CONTINUE
        call set_spline(elarray,farray,af,bf,cf,df,ndata)
        eil = (1 - eke0(medium))/eke1(medium)
        si1e = spline(eil,elarray,af,bf,cf,df,ndata)
        DO 5101 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          si2e = spline(eil,elarray,af,bf,cf,df,ndata)
          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium)
          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil
5101    CONTINUE
5102    CONTINUE
        q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium)
        q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium)
        tauc = te(medium)/prm
        si1e = 1
        DO 5111 i=1,neke-1
          eil = (i+1 - eke0(medium))/eke1(medium)
          e = Exp(eil)
          leil=i+1
          tau=e/prm
          IF (( tau .GT. 2*tauc )) THEN
            sig=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
            dedx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
            sig = sig/dedx
            IF (( sig .GT. 1e-6 )) THEN
              etap=etae_ms1(Leil,MEDIUM)*eil+etae_ms0(Leil,MEDIUM)
              eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2)
              g_r = (1+2*eta)*Log(1+1/eta)-2
              g_m = Log(0.5*tau/tauc)+ (1+((tau+2)/(tau+1))**2)*Log(2*(t
     *        au-tauc+2)/(tau+4))- 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+
     *        1)**2)* Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+ 0.5*(tau
     *        -2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2)
              IF (( g_m .LT. g_r )) THEN
                g_m = g_m/g_r
              ELSE
                g_m = 1
              END IF
              si2e = 1 - g_m*sum_Z/sum_Z2
            ELSE
              si2e = 1
            END IF
          ELSE
            si2e = 1
          END IF
          blcce1(i,medium) = (si2e - si1e)*eke1(medium)
          blcce0(i,medium) = si2e - blcce1(i,medium)*eil
          si1e = si2e
5111    CONTINUE
5112    CONTINUE
        blcce1(neke,medium) = blcce1(neke-1,medium)
        blcce0(neke,medium) = blcce0(neke-1,medium)
        write(i_log,'(a)') ' done'
4801  CONTINUE
4802  CONTINUE
      return
4860  write(i_log,*) ' ******************** Error in init_spin *********
     *********** '
      write(i_log,'(a,a)') '  could not open file ',spin_file
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' terminating execution '
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      subroutine msdist_pII ( e0,eloss,tustep,rhof,med,qel,spin_effects,
     *u0,v0,w0,x0,y0,z0,  us,vs,ws,xf,yf,zf,ustep )
      implicit none
      EGS_Float e0,  eloss,  rhof,  tustep,  u0,  v0,  w0,  x0,  y0,  z0
     *
      integer*4 med, qel
      logical spin_effects
      EGS_Float us,  vs,  ws,  xf,  yf,  zf,  ustep
      EGS_Float b,  blccc,  xcccc,  c,  eta,eta1,  chia2,  chilog,  cphi
     *0,   cphi1,  cphi2,  w1,  w2,  w1v2,  delta,  e,  elke,  beta2,  e
     *tap,  xi_corr,  ms_corr, tau,  tau2,  epsilon,  epsilonp,  temp,te
     *mp1, temp2,  factor,  gamma,  lambda,   p2,  p2i,  q1,  rhophi2,
     *sint0,  sint02,  sint0i,  sint1,  sint2,  sphi0,   sphi1,  sphi2,
     * u2p,  u2,  v2,  ut,  vt,  wt,  xi,  xphi,  xphi2,  yphi,  yphi2
      logical find_index,  spin_index
      integer*4 lelke
      integer max_med
      parameter (max_med = MXMED)
      COMMON/ELECIN/ esig_e(max_med),psig_e(max_med), esige_max, psige_m
     *ax, range_ep(0:1,500,max_med), E_array(500,max_med), etae_ms0(500,
     *max_med),etae_ms1(500,max_med),etap_ms0(500,max_med),etap_ms1(500,
     *max_med),q1ce_ms0(500,max_med),q1ce_ms1(500,max_med),q1cp_ms0(500,
     *max_med),q1cp_ms1(500,max_med),q2ce_ms0(500,max_med),q2ce_ms1(500,
     *max_med),q2cp_ms0(500,max_med),q2cp_ms1(500,max_med),blcce0(500,ma
     *x_med),blcce1(500,max_med), EKE0(max_med),EKE1(max_med), XR0(max_m
     *ed),TEFF0(max_med),BLCC(max_med),XCC(max_med), ESIG0(500,max_med),
     *ESIG1(500,max_med),PSIG0(500,max_med),PSIG1(500,max_med),EDEDX0(50
     *0,max_med),EDEDX1(500,max_med),PDEDX0(500,max_med),PDEDX1(500,max_
     *med),EBR10(500,max_med),EBR11(500,max_med),PBR10(500,max_med),PBR1
     *1(500,max_med),PBR20(500,max_med),PBR21(500,max_med),TMXS0(500,max
     *_med),TMXS1(500,max_med), expeke1(max_med), IUNRST(max_med),EPSTFL
     *(max_med),IAPRIM(max_med), sig_ismonotone(0:1,max_med)
      EGS_Float esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E
     *_array,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1
     *,  q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blc
     *ce0,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG
     *0,ESIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR1
     *1,  PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step
      real*8 count_pII_steps,count_all_steps
      logical is_ch_step
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      EGS_Float ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_ne
     *w,By_new,Bz_new
      logical emfield_on
      medium = med
      count_pII_steps = count_pII_steps + 1
      blccc = blcc(medium)
      xcccc = xcc(medium)
      e = e0 - 0.5*eloss
      tau = e/prm
      tau2 = tau*tau
      epsilon = eloss/e0
      epsilonp= eloss/e
      e = e * (1 - epsilonp*epsilonp*(6+10*tau+5*tau2)/(24*tau2+72*tau+4
     *8))
      p2 = e*(e + rmt2)
      beta2 = p2/(p2 + rmsq)
      chia2 = xcccc/(4*p2*blccc)
      lambda = 0.5*tustep*rhof*blccc/beta2
      temp2 = 0.166666*(4+tau*(6+tau*(7+tau*(4+tau))))* (epsilonp/((tau+
     *1)*(tau+2)))**2
      lambda = lambda*(1 - temp2)
      IF (( spin_effects )) THEN
        elke = Log(e)
        Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
        IF (( lelke .LT. 1 )) THEN
          lelke = 1
          elke = (1 - eke0(medium))/eke1(medium)
        END IF
        IF (( qel .EQ. 0 )) THEN
          etap=etae_ms1(Lelke,MEDIUM)*elke+etae_ms0(Lelke,MEDIUM)
          xi_corr=q1ce_ms1(Lelke,MEDIUM)*elke+q1ce_ms0(Lelke,MEDIUM)
          gamma=q2ce_ms1(Lelke,MEDIUM)*elke+q2ce_ms0(Lelke,MEDIUM)
        ELSE
          etap=etap_ms1(Lelke,MEDIUM)*elke+etap_ms0(Lelke,MEDIUM)
          xi_corr=q1cp_ms1(Lelke,MEDIUM)*elke+q1cp_ms0(Lelke,MEDIUM)
          gamma=q2cp_ms1(Lelke,MEDIUM)*elke+q2cp_ms0(Lelke,MEDIUM)
        END IF
        ms_corr=blcce1(Lelke,MEDIUM)*elke+blcce0(Lelke,MEDIUM)
      ELSE
        etap = 1
        xi_corr = 1
        gamma = 1
        ms_corr = 1
      END IF
      chia2 = chia2*etap
      lambda = lambda/(etap*(1+chia2))*ms_corr
      chilog = Log(1 + 1/chia2)
      q1 = 2*chia2*(chilog*(1 + chia2) - 1)
      gamma = 6*chia2*(1 + chia2)*(chilog*(1 + 2*chia2) - 2)/q1*gamma
      xi = q1*lambda
      find_index = .true.
      spin_index = .true.
      call mscat(lambda,chia2,xi,elke,beta2,qel,medium, spin_effects,fin
     *d_index,spin_index, w1,sint1)
5121  CONTINUE
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        xphi = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        yphi = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO5122
      GO TO 5121
5122  CONTINUE
      rhophi2 = 1/rhophi2
      cphi1 = (xphi2 - yphi2)*rhophi2
      sphi1 = 2*xphi*yphi*rhophi2
      call mscat(lambda,chia2,xi,elke,beta2,qel,medium, spin_effects,fin
     *d_index,spin_index, w2,sint2)
5131  CONTINUE
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        xphi = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        yphi = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO5132
      GO TO 5131
5132  CONTINUE
      rhophi2 = 1/rhophi2
      cphi2 = (xphi2 - yphi2)*rhophi2
      sphi2 = 2*xphi*yphi*rhophi2
      u2 = sint2*cphi2
      v2 = sint2*sphi2
      u2p = w1*u2 + sint1*w2
      us = u2p*cphi1 - v2*sphi1
      vs = u2p*sphi1 + v2*cphi1
      ws = w1*w2 - sint1*u2
      xi = 2*xi*xi_corr
      IF (( rng_seed .GT. 128 )) THEN
        rng_seed = 128
        call egs_fill_rndm_array(rng_seed,rng_array)
        rng_seed = 1
      END IF
      eta = rng_array(rng_seed)
      rng_seed = rng_seed + 1
      eta = Sqrt(eta)
      eta1 = 0.5*(1 - eta)
      delta = 0.9082483-(0.1020621-0.0263747*gamma)*xi
      temp1 = 2 + tau
      temp = (2+tau*temp1)/((tau+1)*temp1)
      temp = temp - (tau+1)/((tau+2)*(chilog*(1+chia2)-1))
      temp = temp * epsilonp
      temp1 = 1 - temp
      delta = delta + 0.40824829*(epsilon*(tau+1)/((tau+2)* (chilog*(1+c
     *hia2)-1)*(chilog*(1+2*chia2)-2)) - 0.25*temp*temp)
      b = eta*delta
      c = eta*(1-delta)
      w1v2 = w1*v2
      ut = b*sint1*cphi1 + c*(cphi1*u2 - sphi1*w1v2) + eta1*us*temp1
      vt = b*sint1*sphi1 + c*(sphi1*u2 + cphi1*w1v2) + eta1*vs*temp1
      wt = eta1*(1+temp) + b*w1 + c*w2 + eta1*ws*temp1
      ustep = tustep*sqrt(ut*ut + vt*vt + wt*wt)
      sint02 = u0**2 + v0**2
      IF ((sint02 .GT. 1e-20)) THEN
        sint0 = sqrt(sint02)
        sint0i = 1/sint0
        cphi0 = sint0i*u0
        sphi0 = sint0i*v0
        u2p = w0*us + sint0*ws
        ws = w0*ws - sint0*us
        us = u2p*cphi0 - vs*sphi0
        vs = u2p*sphi0 + vs*cphi0
        u2p = w0*ut + sint0*wt
        wt = w0*wt - sint0*ut
        ut = u2p*cphi0 - vt*sphi0
        vt = u2p*sphi0 + vt*cphi0
      ELSE
        wt = w0*wt
        ws = w0*ws
      END IF
      xf = x0 + tustep*ut
      yf = y0 + tustep*vt
      zf = z0 + tustep*wt
      return
      end
      subroutine msdist_pI ( e0,eloss,tustep,rhof,medium,qel,spin_effect
     *s,u0,v0,w0,x0,y0,z0,  us,vs,ws,xf,yf,zf,ustep )
      implicit none
      EGS_Float e0,  eloss,  rhof,  tustep,  u0,  v0,  w0,  x0,  y0,  z0
     *
      integer*4 medium, qel
      logical spin_effects
      EGS_Float us,  vs,  ws,  xf,  yf,  zf,  ustep
      EGS_Float blccc,  xcccc,  z,r,z2,r2,  r2max, chia2,  chilog,  cphi
     *0,   cphi,  sphi,  e,  elke,  beta2,  etap,  xi_corr,  ms_corr, ep
     *silon,  temp,  factor,  lambda,  p2,  p2i,  q1,  rhophi2,  sint,
     *sint0,  sint02,  sint0i,  sphi0,   u2p,  ut,  vt,  wt,  xi,  xphi,
     *  xphi2,  yphi,  yphi2
      logical find_index,  spin_index
      integer*4 lelke
      integer max_med
      parameter (max_med = MXMED)
      COMMON/ELECIN/ esig_e(max_med),psig_e(max_med), esige_max, psige_m
     *ax, range_ep(0:1,500,max_med), E_array(500,max_med), etae_ms0(500,
     *max_med),etae_ms1(500,max_med),etap_ms0(500,max_med),etap_ms1(500,
     *max_med),q1ce_ms0(500,max_med),q1ce_ms1(500,max_med),q1cp_ms0(500,
     *max_med),q1cp_ms1(500,max_med),q2ce_ms0(500,max_med),q2ce_ms1(500,
     *max_med),q2cp_ms0(500,max_med),q2cp_ms1(500,max_med),blcce0(500,ma
     *x_med),blcce1(500,max_med), EKE0(max_med),EKE1(max_med), XR0(max_m
     *ed),TEFF0(max_med),BLCC(max_med),XCC(max_med), ESIG0(500,max_med),
     *ESIG1(500,max_med),PSIG0(500,max_med),PSIG1(500,max_med),EDEDX0(50
     *0,max_med),EDEDX1(500,max_med),PDEDX0(500,max_med),PDEDX1(500,max_
     *med),EBR10(500,max_med),EBR11(500,max_med),PBR10(500,max_med),PBR1
     *1(500,max_med),PBR20(500,max_med),PBR21(500,max_med),TMXS0(500,max
     *_med),TMXS1(500,max_med), expeke1(max_med), IUNRST(max_med),EPSTFL
     *(max_med),IAPRIM(max_med), sig_ismonotone(0:1,max_med)
      EGS_Float esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E
     *_array,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1
     *,  q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blc
     *ce0,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG
     *0,ESIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR1
     *1,  PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common/emf_inputs/ExIN,EyIN,EzIN,  EMLMTIN,  BxIN, ByIN, BzIN,  Bx
     *, By, Bz,  Bx_new, By_new, Bz_new,  emfield_on
      EGS_Float ExIN,EyIN,EzIN, EMLMTIN, BxIN,ByIN,BzIN, Bx,By,Bz, Bx_ne
     *w,By_new,Bz_new
      logical emfield_on
      blccc = blcc(medium)
      xcccc = xcc(medium)
      e = e0 - 0.5*eloss
      p2 = e*(e + rmt2)
      p2i = 1/p2
      chia2 = xcccc*p2i/(4*blccc)
      beta2 = p2/(p2 + rmsq)
      lambda = tustep*rhof*blccc/beta2
      factor = 1/(1 + 0.9784671*e)
      epsilon= eloss/e0
      epsilon= epsilon/(1-0.5*epsilon)
      temp = 0.25*(1 - factor*(1 - 0.333333*factor))*epsilon**2
      lambda = lambda*(1 + temp)
      IF (( spin_effects )) THEN
        elke = Log(e)
        Lelke=eke1(MEDIUM)*elke+eke0(MEDIUM)
        IF (( lelke .LT. 1 )) THEN
          lelke = 1
          elke = (1 - eke0(medium))/eke1(medium)
        END IF
        IF (( qel .EQ. 0 )) THEN
          etap=etae_ms1(Lelke,MEDIUM)*elke+etae_ms0(Lelke,MEDIUM)
          xi_corr=q1ce_ms1(Lelke,MEDIUM)*elke+q1ce_ms0(Lelke,MEDIUM)
        ELSE
          etap=etap_ms1(Lelke,MEDIUM)*elke+etap_ms0(Lelke,MEDIUM)
          xi_corr=q1cp_ms1(Lelke,MEDIUM)*elke+q1cp_ms0(Lelke,MEDIUM)
        END IF
        ms_corr=blcce1(Lelke,MEDIUM)*elke+blcce0(Lelke,MEDIUM)
      ELSE
        etap = 1
        xi_corr = 1
        ms_corr = 1
      END IF
      chia2 = xcccc*p2i/(4*blccc)*etap
      lambda = lambda/etap/(1+chia2)*ms_corr
      chilog = Log(1 + 1/chia2)
      q1 = 2*chia2*(chilog*(1 + chia2) - 1)
      xi = q1*lambda
      find_index = .true.
      spin_index = .true.
      call mscat(lambda,chia2,xi,elke,beta2,qel,medium, spin_effects,fin
     *d_index,spin_index, ws,sint)
5141  CONTINUE
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        xphi = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        yphi = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO5142
      GO TO 5141
5142  CONTINUE
      rhophi2 = 1/rhophi2
      cphi = (xphi2 - yphi2)*rhophi2
      sphi = 2*xphi*yphi*rhophi2
      us = sint*cphi
      vs = sint*sphi
      xi = xi*xi_corr
      IF (( xi .LT. 0.1 )) THEN
        z = 1 - xi*(0.5 - xi*(0.166666667 - 0.041666667*xi))
      ELSE
        z = (1 - Exp(-xi))/xi
      END IF
      r = 0.5*sint
      r2 = r*r
      z2 = z*z
      r2max = 1 - z2
      IF (( r2max .LT. r2 )) THEN
        r2 = r2max
        r = Sqrt(r2)
      END IF
      ut = r*cphi
      vt = r*sphi
      wt = z
      ustep = Sqrt(z2 + r2)*tustep
      sint02 = u0**2 + v0**2
      IF ((sint02 .GT. 1e-20)) THEN
        sint0 = sqrt(sint02)
        sint0i = 1/sint0
        cphi0 = sint0i*u0
        sphi0 = sint0i*v0
        u2p = w0*us + sint0*ws
        ws = w0*ws - sint0*us
        us = u2p*cphi0 - vs*sphi0
        vs = u2p*sphi0 + vs*cphi0
        u2p = w0*ut + sint0*wt
        wt = w0*wt - sint0*ut
        ut = u2p*cphi0 - vt*sphi0
        vt = u2p*sphi0 + vt*cphi0
      ELSE
        wt = w0*wt
        ws = w0*ws
      END IF
      xf = x0 + tustep*ut
      yf = y0 + tustep*vt
      zf = z0 + tustep*wt
      return
      end
      SUBROUTINE PAIR
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/nrc_pair/ nrcp_fdata(65,84,max_med), nrcp_wdata(65,84,max_m
     *ed), nrcp_idata(65,84,max_med), nrcp_xdata(65), nrcp_emin, nrcp_em
     *ax, nrcp_dle, nrcp_dlei
      EGS_Float nrcp_fdata,nrcp_wdata,nrcp_xdata, nrcp_emin, nrcp_emax,
     *nrcp_dle, nrcp_dlei
      integer*4 nrcp_idata
      common/triplet_data/ a_triplet(250,max_med), b_triplet(250,max_med
     *), dl_triplet, dli_triplet, bli_triplet, log_4rm
      EGS_Float a_triplet,b_triplet,dl_triplet, dli_triplet, bli_triplet
     *, log_4rm
      common/egs_vr/ e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_
     *RR, i_survived_RR, n_RR_warning, i_do_rr
      EGS_Float e_max_rr,e_max_rr_new,prob_RR
      integer*4 nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      DOUBLE PRECISION PEIG,  PESE1,  PESE2
      EGS_Float EIG,  ESE2,  RNNO30,RNNO31,rnno32,rnno33,rnno34,  DELTA,
     *  REJF,  rejmax,  aux1,aux2,  Amax,  Bmax,  del0,  br,
     *                                  Eminus,Eplus,Eavail,rnno_RR
      integer*4
     *                     L,L1
      EGS_Float ESE,  PSE,  ZTARG,  TTEIG,  TTESE,  TTPSE,  ESEDEI, ESED
     *ER, XIMIN,  XIMID,  REJMIN, REJMID, REJTOP, YA,XITRY,GALPHA,GBETA,
     *  XITST,  REJTST_on_REJTOP ,  REJTST, RTEST
      integer*4 ICHRG
      EGS_Float k,xx,abin,rbin,alias_sample1
      integer*4 ibin, iq1, iq2, iprdst_use
      logical do_nrc_pair
      integer*4 itrip
      EGS_Float ftrip
      NPold = NP
      IF (( i_play_RR .EQ. 1 )) THEN
        i_survived_RR = 0
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,'(a,g14.6)') 'Attempt to play Russian Roulette w
     *ith prob_RR<0! '
          END IF
        ELSE
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnno_RR = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF (( rnno_RR .GT. prob_RR )) THEN
            i_survived_RR =2
            IF (( np .GT. 1 )) THEN
              np = np-1
            ELSE
              wt(np) = 0
              e(np) = 0
            END IF
            return
          ELSE
            wt(np) = wt(np)/prob_RR
          END IF
        END IF
      END IF
      IF (( np+1 .GT. max_stack )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','PAIR', ' sta
     *ck size exceeded! ',' $MAXSTACK = ',max_stack,' np = ',np+1
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      PEIG=E(NP)
      EIG=PEIG
      do_nrc_pair = .false.
      IF (( itriplet .GT. 0 .AND. eig .GT. 4*rm )) THEN
        itrip = dli_triplet*gle + bli_triplet
        ftrip = a_triplet(itrip,medium)*gle + b_triplet(itrip,medium)
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        rnno34 = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        IF (( rnno34 .LT. ftrip )) THEN
          call sample_triplet
          return
        END IF
      END IF
      IF (( pair_nrc .EQ. 1 )) THEN
        k = eig/rm
        IF (( k .LT. nrcp_emax )) THEN
          do_nrc_pair = .true.
          IF (( k .LE. nrcp_emin )) THEN
            ibin = 1
          ELSE
            abin = 1 + log((k-2)/(nrcp_emin-2))*nrcp_dlei
            ibin = abin
            abin = abin - ibin
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            rbin = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            IF((rbin .LT. abin))ibin = ibin + 1
          END IF
          xx = alias_sample1(64,nrcp_xdata, nrcp_fdata(1,ibin,medium),nr
     *    cp_wdata(1,ibin,medium), nrcp_idata(1,ibin,medium))
          IF (( xx .GT. 0.5 )) THEN
            pese1 = prm*(1 + xx*(k-2))
            iq1 = 1
            pese2 = peig - pese1
            iq2 = -1
          ELSE
            pese2 = prm*(1 + xx*(k-2))
            iq2 = 1
            pese1 = peig - pese2
            iq1 = -1
          END IF
        END IF
      END IF
      IF (( .NOT.do_nrc_pair )) THEN
        IF ((EIG.LE.2.1)) THEN
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          RNNO30 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnno34 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          PESE2 = PRM + 0.5*RNNO30*(PEIG-2*PRM)
          PESE1 = PEIG - PESE2
          IF (( rnno34 .LT. 0.5 )) THEN
            iq1 = -1
            iq2 = 1
          ELSE
            iq1 = 1
            iq2 = -1
          END IF
        ELSE
          IF ((EIG.LT.50.)) THEN
            L = 5
            L1 = L + 1
            delta = 4*delcm(medium)/eig
            IF (( delta .LT. 1 )) THEN
              Amax = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medi
     *        um))
              Bmax = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,m
     *        edium))
            ELSE
              aux2 = log(delta+dl6(l,medium))
              Amax = dl4(l,medium)+dl5(l,medium)*aux2
              Bmax = dl4(l1,medium)+dl5(l1,medium)*aux2
            END IF
            aux1 = 1 - rmt2/eig
            aux1 = aux1*aux1
            aux1 = aux1*Amax/3
            aux1 = aux1/(Bmax+aux1)
          ELSE
            L = 7
            Amax = dl1(l,medium)
            Bmax = dl1(l+1,medium)
            aux1 = bpar(2,medium)*(1-bpar(1,medium)*rm/eig)
          END IF
          del0 = eig*delcm(medium)
          Eavail = eig - rmt2
5151      CONTINUE
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            RNNO30 = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            RNNO31 = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            RNNO34 = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            IF (( rnno30 .GT. aux1 )) THEN
              br = 0.5*rnno31
              rejmax = Bmax
              l1 = l+1
            ELSE
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              rnno32 = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              rnno33 = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              br = 0.5*(1-max(rnno31,rnno32,rnno33))
              rejmax = Amax
              l1 = l
            END IF
            Eminus = br*Eavail + rm
            Eplus = eig - Eminus
            delta = del0/(Eminus*Eplus)
            IF (( delta .LT. 1 )) THEN
              rejf = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,m
     *        edium))
            ELSE
              rejf = dl4(l1,medium)+dl5(l1,medium)*log(delta+dl6(l1,medi
     *        um))
            END IF
            IF((( rnno34*rejmax .LE. rejf )))GO TO5152
          GO TO 5151
5152      CONTINUE
          pese2 = Eminus
          pese1 = peig - pese2
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          RNNO34 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF (( rnno34 .LT. 0.5 )) THEN
            iq1 = -1
            iq2 = 1
          ELSE
            iq1 = 1
            iq2 = -1
          END IF
        END IF
      END IF
      ESE2=PESE2
      E(NP)=PESE1
      E(NP+1)=PESE2
      IF (( iprdst .GT. 0 )) THEN
        IF (( iprdst .EQ. 4 )) THEN
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rtest = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          gbeta = PESE1/(PESE1+10)
          IF (( rtest .LT. gbeta )) THEN
            iprdst_use = 1
          ELSE
            iprdst_use = 4
          END IF
        ELSE IF(( iprdst .EQ. 2 .AND. eig .LT. 4.14 )) THEN
          iprdst_use = 1
        ELSE
          iprdst_use = iprdst
        END IF
        DO 5161 ichrg=1,2
          IF ((ICHRG.EQ.1)) THEN
            ESE=PESE1
          ELSE
            ESE=ESE2
            IF (( iprdst .EQ. 4 )) THEN
              gbeta = ESE/(ESE+10)
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              rtest = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              IF (( rtest .LT. gbeta )) THEN
                iprdst_use = 1
              ELSE
                iprdst_use = 4
              END IF
            END IF
          END IF
          IF (( iprdst_use .EQ. 1 )) THEN
            PSE=SQRT(MAX(0.0,(ESE-RM)*(ESE+RM)))
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            COSTHE = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            COSTHE=1.0-2.0*COSTHE
            SINTHE=RM*SQRT((1.0-COSTHE)*(1.0+COSTHE))/(PSE*COSTHE+ESE)
            COSTHE=(ESE*COSTHE+PSE)/(PSE*COSTHE+ESE)
          ELSE IF(( iprdst_use .EQ. 2 )) THEN
            ZTARG=ZBRANG(MEDIUM)
            TTEIG=EIG/RM
            TTESE=ESE/RM
            TTPSE=SQRT((TTESE-1.0)*(TTESE+1.0))
            ESEDEI=TTESE/(TTEIG-TTESE)
            ESEDER=1.0/ESEDEI
            XIMIN=1.0/(1.0+(3.141593*TTESE)**2)
            REJMIN = 2.0+3.0*(ESEDEI+ESEDER) - 4.00*(ESEDEI+ESEDER+1.0-4
     *      .0*(XIMIN-0.5)**2)*( 1.0+0.25*LOG( ((1.0+ESEDER)*(1.0+ESEDEI
     *      )/(2.*TTEIG))**2+ZTARG*XIMIN**2 ) )
            YA=(2.0/TTEIG)**2
            XITRY=MAX(0.01,MAX(XIMIN,MIN(0.5,SQRT(YA/ZTARG))))
            GALPHA=1.0+0.25*LOG(YA+ZTARG*XITRY**2)
            GBETA=0.5*ZTARG*XITRY/(YA+ZTARG*XITRY**2)
            GALPHA=GALPHA-GBETA*(XITRY-0.5)
            XIMID=GALPHA/(3.0*GBETA)
            IF ((GALPHA.GE.0.0)) THEN
              XIMID=0.5-XIMID+SQRT(XIMID**2+0.25)
            ELSE
              XIMID=0.5-XIMID-SQRT(XIMID**2+0.25)
            END IF
            XIMID=MAX(0.01,MAX(XIMIN,MIN(0.5,XIMID)))
            REJMID = 2.0+3.0*(ESEDEI+ESEDER) - 4.00*(ESEDEI+ESEDER+1.0-4
     *      .0*(XIMID-0.5)**2)*( 1.0+0.25*LOG( ((1.0+ESEDER)*(1.0+ESEDEI
     *      )/(2.*TTEIG))**2+ZTARG*XIMID**2 ) )
            REJTOP=1.02*MAX(REJMIN,REJMID)
5171        CONTINUE
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              XITST = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              REJTST = 2.0+3.0*(ESEDEI+ESEDER) - 4.00*(ESEDEI+ESEDER+1.0
     *        -4.0*(XITST-0.5)**2)*( 1.0+0.25*LOG( ((1.0+ESEDER)*(1.0+ES
     *        EDEI)/(2.*TTEIG))**2+ZTARG*XITST**2 ) )
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              RTEST = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              THETA=SQRT(1.0/XITST-1.0)/TTESE
              REJTST_on_REJTOP = REJTST/REJTOP
              IF((((RTEST .LE. REJTST_on_REJTOP) .AND. (THETA .LT. PI) )
     *        ))GO TO5172
            GO TO 5171
5172        CONTINUE
            SINTHE=SIN(THETA)
            COSTHE=COS(THETA)
          ELSE IF(( iprdst_use .EQ. 3 )) THEN
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            COSTHE = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            COSTHE=1.0-2.0*COSTHE
            sinthe=(1-costhe)*(1+costhe)
            IF (( sinthe .GT. 0 )) THEN
              sinthe = sqrt(sinthe)
            ELSE
              sinthe = 0
            END IF
          ELSE
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            costhe = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            costhe=1-2*sqrt(costhe)
            sinthe=(1-costhe)*(1+costhe)
            IF (( sinthe .GT. 0 )) THEN
              sinthe=sqrt(sinthe)
            ELSE
              sinthe=0
            END IF
          END IF
          IF (( ichrg .EQ. 1 )) THEN
            CALL UPHI(2,1)
          ELSE
            sinthe=-sinthe
            NP=NP+1
            CALL UPHI(3,2)
          END IF
5161    CONTINUE
5162    CONTINUE
        iq(np) = iq2
        iq(np-1) = iq1
        return
      ELSE
        THETA=0
      END IF
      CALL UPHI(1,1)
      NP=NP+1
      SINTHE=-SINTHE
      CALL UPHI(3,2)
      IQ(NP)=iq2
      IQ(NP-1)=iq1
      RETURN
      END
      subroutine sample_triplet
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      real*8 fmax_array(250), eta_p_array(250), eta_Ep_array(250), eta_c
     *ostp_array(250), eta_costm_array(250), ebin_array(250), wp_array(2
     *50), qmin_array(250)
      real*8 kmin, kmax, dlogki, alogkm, prmi, tiny_eta
      real*8 ai,rnno,k,qmin,qmax,aux,a1,a2,a3,D,px1,px2,pp_min,pp_max, E
     *p_min,Ep_max,k2p2,k2p2x,peig,b,aux1,aux12,D1,aux3,xmin,xmax, aux6,
     *aux7,uu,cphi,sphi,cphi_factor,aux5,phi,tmp
      real*8 Er,pr,pr2,eta_pr
      real*8 Ep,pp,pp2,wEp,cost_p,sint_p,eta_Ep,mup_min,wmup, eta_costp,
     *Epp,pp_sintp,pp_sntp2
      real*8 Em,pm,pm2,cost_m,sint_m,Emm,wmum,pm_sintm, eta_costm
      real*8 k2,k3,s2,s3,k2k3i,k22,k32,q2,aux4,S_1,S_2,sigma
      real*8 ppx, ppy, ppz, pmx, pmy, pmz, prx, pry, prz, a,c,sindel,cos
     *del,sinpsi
      integer*4 i
      logical use_it
      integer*4 iscore
      logical is_initialized
      data is_initialized/.false./
      save is_initialized,fmax_array,eta_p_array,eta_Ep_array,eta_costp_
     *array, eta_costm_array,ebin_array,wp_array,qmin_array, kmin,kmax,d
     *logki,alogkm,prmi,tiny_eta
      IF (( .NOT.is_initialized )) THEN
        is_initialized = .true.
        tiny_eta = 1e-6
        DO 5181 i=1,250
          fmax_array(i) = -1
5181    CONTINUE
5182    CONTINUE
        kmax = 0
        kmin = 4.1*prm
        DO 5191 i=1,nmed
          IF((up(i) .GT. kmax))kmax = UP(i)
5191    CONTINUE
5192    CONTINUE
        IF((kmax .LE. kmin))return
        dlogki = 250 - 1
        dlogki = dlogki/log(kmax/kmin)
        alogkm = 1 - dlogki*log(kmin)
        prmi = 1/prm
        DO 5201 i=1,250
          k = 4.1*exp((i-1.)/dlogki)
          ebin_array(i) = k
          qmin = 4*k/(k*(k-1)+(k+1)*sqrt(k*(k-4)))
          qmax = (k*(k-1) + (k+1)*sqrt(k*(k-4)))/(2*k+1)
          qmin_array(i) = qmin
          wp_array(i) = log(qmax/qmin)
5201    CONTINUE
5202    CONTINUE
      END IF
      peig = e(np)
      IF((peig .LE. 4*prm))return
      IF (( np+2 .GT. max_stack )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','sample_tripl
     *et', ' stack size exceeded! ',' $MAXSTACK = ',max_stack,' np = ',n
     *  p+2
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( peig .LE. kmin )) THEN
        i = 1
      ELSE IF(( peig .GE. kmax )) THEN
        i = 250
      ELSE
        ai = alogkm + dlogki*gle
        i = ai
        ai = ai - i
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        rnno = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        IF (( rnno .LT. ai )) THEN
          i = i+1
        END IF
      END IF
      k = ebin_array(i)
5210  CONTINUE
      IF (( rng_seed .GT. 128 )) THEN
        rng_seed = 128
        call egs_fill_rndm_array(rng_seed,rng_array)
        rng_seed = 1
      END IF
      eta_pr = rng_array(rng_seed)
      rng_seed = rng_seed + 1
      IF((eta_pr .LT. tiny_eta))eta_pr = tiny_eta
      pr = qmin_array(i)*exp(eta_pr*wp_array(i))
      pr2 = pr*pr
      Er = sqrt(1+pr2)
      aux = Er-pr-1
      a1=(k-pr)*(1-Er-k*aux)
      a2=1+k-Er
      a3=1/(aux*(pr+Er-2*k-1))
      D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2))
      px1 = (a1 + D)*a3
      px2 = (a1 - D)*a3
      IF (( px1 .LT. px2 )) THEN
        pp_min = px1
        pp_max = px2
      ELSE
        pp_min = px2
        pp_max = px1
      END IF
      Ep_min = sqrt(1 + pp_min*pp_min)
      Ep_max = sqrt(1 + pp_max*pp_max)
      IF (( rng_seed .GT. 128 )) THEN
        rng_seed = 128
        call egs_fill_rndm_array(rng_seed,rng_array)
        rng_seed = 1
      END IF
      eta_Ep = rng_array(rng_seed)
      rng_seed = rng_seed + 1
      IF((eta_Ep .LT. tiny_eta))eta_Ep = tiny_eta
      wEp = Ep_max - Ep_min
      Ep = Ep_min + eta_Ep*wEp
      pp2 = Ep*Ep - 1
      pp = sqrt(pp2)
      k2p2 = k*k + pp2
      Em = k + 1 - Er - Ep
      pm2 = Em*Em-1
      pm = sqrt(pm2)
      mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp)
      IF (( rng_seed .GT. 128 )) THEN
        rng_seed = 128
        call egs_fill_rndm_array(rng_seed,rng_array)
        rng_seed = 1
      END IF
      eta_costp = rng_array(rng_seed)
      rng_seed = rng_seed + 1
      IF((eta_costp .LT. tiny_eta))eta_costp = tiny_eta
      Epp = Ep/pp
      wmup = log((Epp-1)/(Epp-mup_min))
      cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp)
      wmup = wmup*(cost_p - Epp)
      sint_p = 1-cost_p*cost_p
      IF (( sint_p .GT. 1e-20 )) THEN
        sint_p = sqrt(sint_p)
      ELSE
        sint_p = 1e-10
      END IF
      k2p2x = k2p2 - 2*k*pp*cost_p
      b = pr2-k2p2x-pm2
      aux1 = k - pp*cost_p
      aux12 = aux1*aux1
      pp_sintp = pp*sint_p
      pp_sntp2 = pp_sintp*pp_sintp
      D1 = pm2*(aux12+pp_sntp2)-b*b/4
      IF (( D1 .LE. 0 )) THEN
        goto 5210
      END IF
      D = 2*pp_sintp*sqrt(D1)
      aux3 = 0.5/(aux12+pp_sntp2)
      xmin = (-b*aux1-D)*aux3
      xmax = (-b*aux1+D)*aux3
      IF (( rng_seed .GT. 128 )) THEN
        rng_seed = 128
        call egs_fill_rndm_array(rng_seed,rng_array)
        rng_seed = 1
      END IF
      eta_costm = rng_array(rng_seed)
      rng_seed = rng_seed + 1
      IF((eta_costm .LT. tiny_eta))eta_costm = tiny_eta
      aux6 = sqrt((Em-xmin)/(Em-xmax))
      aux7 = aux6*tan(1.570796326794897*eta_costm)
      uu = (aux7-1)/(aux7+1)
      cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))
      wmum = sqrt((xmax-cost_m)*(cost_m-xmin))
      wmum = wmum*aux6*(Em-cost_m)/(Em-xmin)
      cost_m = cost_m/pm
      sint_m = sqrt(1-cost_m*cost_m)
      pm_sintm = pm*sint_m
      cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm)
      IF (( abs(cphi) .GE. 1 )) THEN
        goto 5210
      END IF
      sphi = sqrt(1-cphi*cphi)
      k3 = k*(pp*cost_p - Ep)
      k2 = k*(pm*cost_m - Em)
      k22 = k2*k2
      k32 = k3*k3
      k2k3i = 1/(k2*k3)
      s2 = pp*pm*(cost_p*cost_m + sint_p*sint_m*cphi) - Ep*Em
      s3 = k2 - Em + 1 - s2
      q2 = 2*(Er-1)
      S_1 = k32+k22+(q2-2)*s2-(1-q2/2)*(k32+k22)*k2k3i
      aux4 = k3*Ep-k2*Em
      S_2 = -q2*(Ep*Ep+Em*Em) + 2*s2 - (2*aux4*aux4 - k22 - k32)*k2k3i
      sigma = abs(pp*pm2*pm*k2k3i/(q2*q2*(Em*s3+Er))*(S_1*(1-q2/4)+S_2*(
     *1+q2/4)))
      cphi_factor = abs(2*Er*pm2-Em*(k2p2x-pr2-pm2))/(2*pp_sintp*pm_sint
     *m*pm2*sphi)
      sigma = sigma*cphi_factor*wEp*wmup*wmum*wp_array(i)*pr2/Er
      IF (( sigma .LT. 0 )) THEN
        write(i_log,'(/a)') '***************** Warning: '
        write(i_log,*) 'In triplet sigma < 0 ? ',sigma
      END IF
      use_it = .true.
      IF (( sigma .LT. fmax_array(i) )) THEN
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        rnno = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        IF (( sigma .LT. fmax_array(i)*rnno )) THEN
          use_it = .false.
        END IF
      END IF
      IF (( use_it )) THEN
        fmax_array(i) = sigma
        eta_p_array(i) = eta_pr
        eta_Ep_array(i) = eta_Ep
        eta_costp_array(i) = eta_costp
        eta_costm_array(i) = eta_costm
      ELSE
        eta_pr = eta_p_array(i)
        eta_Ep = eta_Ep_array(i)
        eta_costp = eta_costp_array(i)
        eta_costm = eta_costm_array(i)
      END IF
      k = peig*prmi
      aux5 = k*(k-1)+(k+1)*sqrt(k*(k-4))
      qmin = 4*k/aux5
      qmax = aux5/(2*k+1)
      pr = qmin*exp(eta_pr*log(qmax/qmin))
      pr2 = pr*pr
      Er = sqrt(1+pr2)
      aux = Er-pr-1
      a1=(k-pr)*(1-Er-k*aux)
      a2=1+k-Er
      a3=1/(aux*(pr+Er-2*k-1))
      D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2))
      px1 = (a1 + D)*a3
      px2 = (a1 - D)*a3
      IF (( px1 .LT. px2 )) THEN
        pp_min = px1
        pp_max = px2
      ELSE
        pp_min = px2
        pp_max = px1
      END IF
      Ep_min = sqrt(1 + pp_min*pp_min)
      Ep_max = sqrt(1 + pp_max*pp_max)
      wEp = Ep_max - Ep_min
      Ep = Ep_min + eta_Ep*wEp
      pp2 = Ep*Ep - 1
      pp = sqrt(pp2)
      k2p2 = k*k + pp2
      Em = k + 1 - Er - Ep
      pm2 = Em*Em-1
      pm = sqrt(pm2)
      mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp)
      Epp = Ep/pp
      wmup = log((Epp-1)/(Epp-mup_min))
      cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp)
      sint_p = sqrt(1-cost_p*cost_p)
      k2p2x = k2p2 - 2*k*pp*cost_p
      b = pr2-k2p2x-pm2
      aux1 = k - pp*cost_p
      aux12 = aux1*aux1
      pp_sintp = pp*sint_p
      pp_sntp2 = pp_sintp*pp_sintp
      D1 = pm2*(aux12+pp_sntp2)-b*b/4
      IF (( D1 .LE. 0 )) THEN
        goto 5210
      END IF
      D = 2*pp_sintp*sqrt(D1)
      aux3 = 0.5/(aux12+pp_sntp2)
      xmin = (-b*aux1-D)*aux3
      xmax = (-b*aux1+D)*aux3
      aux6 = sqrt((Em-xmin)/(Em-xmax))
      aux7 = aux6*tan(1.570796326794897*eta_costm)
      uu = (aux7-1)/(aux7+1)
      cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))/pm
      sint_m = sqrt(1-cost_m*cost_m)
      pm_sintm = pm*sint_m
      cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm)
      IF (( abs(cphi) .GE. 1 )) THEN
        goto 5210
      END IF
      sphi = sqrt(1-cphi*cphi)
      IF (( rng_seed .GT. 128 )) THEN
        rng_seed = 128
        call egs_fill_rndm_array(rng_seed,rng_array)
        rng_seed = 1
      END IF
      phi = rng_array(rng_seed)
      rng_seed = rng_seed + 1
      phi = phi*6.283185307179586
      ppx = pp*sint_p
      ppy = 0
      pmx = pm*sint_m*cphi
      pmy = pm*sint_m*sphi
      cphi = cos(phi)
      sphi = sin(phi)
      tmp = ppx*sphi
      ppx = ppx*cphi - ppy*sphi
      ppy = tmp + ppy*cphi
      tmp = pmx*sphi
      pmx = pmx*cphi - pmy*sphi
      pmy = tmp + pmy*cphi
      ppz = pp*cost_p
      pmz = pm*cost_m
      prx = -ppx-pmx
      pry = -ppy-pmy
      prz = k - ppz - pmz
      NPold = np
      X(np)=X(np)
      Y(np)=Y(np)
      Z(np)=Z(np)
      IR(np)=IR(np)
      WT(np)=WT(np)
      DNEAR(np)=DNEAR(np)
      LATCH(np)=LATCH(np)
      X(np+1)=X(np)
      Y(np+1)=Y(np)
      Z(np+1)=Z(np)
      IR(np+1)=IR(np)
      WT(np+1)=WT(np)
      DNEAR(np+1)=DNEAR(np)
      LATCH(np+1)=LATCH(np)
      X(np+2)=X(np+1)
      Y(np+2)=Y(np+1)
      Z(np+2)=Z(np+1)
      IR(np+2)=IR(np+1)
      WT(np+2)=WT(np+1)
      DNEAR(np+2)=DNEAR(np+1)
      LATCH(np+2)=LATCH(np+1)
      pp = 1/pp
      pm = 1/pm
      pr = 1/pr
      a = u(np)
      b = v(np)
      c = w(np)
      sinpsi = a*a + b*b
      IF (( sinpsi .GT. 1e-20 )) THEN
        sinpsi = sqrt(sinpsi)
        sindel = b/sinpsi
        cosdel = a/sinpsi
        IF (( Ep .GT. Em )) THEN
          u(np) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz)
          v(np) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz)
          w(np) = pp*(c*ppz - sinpsi*ppx)
          iq(np) = 1
          E(np) = Ep*prm
          u(np+1) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz)
          v(np+1) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz)
          w(np+1) = pm*(c*pmz - sinpsi*pmx)
          iq(np+1) = -1
          E(np+1) = Em*prm
        ELSE
          u(np+1) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz)
          v(np+1) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz)
          w(np+1) = pp*(c*ppz - sinpsi*ppx)
          iq(np+1) = 1
          E(np+1) = Ep*prm
          u(np) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz)
          v(np) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz)
          w(np) = pm*(c*pmz - sinpsi*pmx)
          iq(np) = -1
          E(np) = Em*prm
        END IF
        np = np + 2
        u(np) = pr*(c*cosdel*prx - sindel*pry + a*prz)
        v(np) = pr*(c*sindel*prx + cosdel*pry + b*prz)
        w(np) = pr*(c*prz - sinpsi*prx)
        iq(np) = -1
        E(np) = Er*prm
      ELSE
        IF (( Ep .GT. Em )) THEN
          u(np) = pp*ppx
          v(np) = pp*ppy
          w(np) = c*pp*ppz
          iq(np) = 1
          E(np) = Ep*prm
          u(np+1) = pm*pmx
          v(np+1) = pm*pmy
          w(np+1) = c*pm*pmz
          iq(np+1) = -1
          E(np+1) = Em*prm
        ELSE
          u(np+1) = pp*ppx
          v(np+1) = pp*ppy
          w(np+1) = c*pp*ppz
          iq(np+1) = 1
          E(np+1) = Ep*prm
          u(np) = pm*pmx
          v(np) = pm*pmy
          w(np) = c*pm*pmz
          iq(np) = -1
          E(np) = Em*prm
        END IF
        np = np + 2
        u(np) = pr*prx
        v(np) = pr*pry
        w(np) = c*pr*prz
        iq(np) = -1
        E(np) = Er*prm
      END IF
      return
      end
      SUBROUTINE PHOTO
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common/bounds/ ecut, pcut, ecut_new, pcut_new, vacdst
      EGS_Float ecut, pcut, ecut_new, pcut_new, vacdst
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100)
      EGS_Float binding_energies, interaction_prob, relaxation_prob, edg
     *e_energies, edge_a,edge_b,edge_c,edge_d
      integer*4 edge_number
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(max_med), GE0(max_med),GE1(max_med), GMFP0(2
     *000,max_med),GMFP1(2000,max_med),GBR10(2000,max_med),GBR11(2000,ma
     *x_med),GBR20(2000,max_med),GBR21(2000,max_med), RCO0(max_med),RCO1
     *(max_med), RSCT0(100,max_med),RSCT1(100,max_med), COHE0(2000,max_m
     *ed),COHE1(2000,max_med),  PHOTONUC0(2000,max_med),PHOTONUC1(2000,m
     *ax_med), DPMFP, MPGEM(1,max_med), NGR(max_med)
      EGS_Float EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR
     *21,  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,
     *  DPMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/egs_vr/ e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_
     *RR, i_survived_RR, n_RR_warning, i_do_rr
      EGS_Float e_max_rr,e_max_rr_new,prob_RR
      integer*4 nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      EGS_Float relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      EGS_Float EELEC,  BETA,  GAMMA,  ALPHA,  RATIO,  RNPHT,  FKAPPA, X
     *I,  SINTH2, RNPHT2
      DOUBLE PRECISION PEIG
      EGS_Float BR,  sigma,  aux,aux1,  probs(50),  sigtot,  e_vac,  rnn
     *o_RR
      integer*4 IARG,  iZ,   irl,  ints(50),  j,ip,  n_warning,  k
      logical do_relax
      save n_warning
      data n_warning/0/
      IF (( mcdf_pe_xsections )) THEN
        call egs_shellwise_photo()
        return
      END IF
      NPold = NP
      PEIG=E(NP)
      irl = ir(np)
      IF (( peig .LT. edge_energies(2,1) )) THEN
        IF (( n_warning .LT. 100 )) THEN
          n_warning = n_warning + 1
          write(i_log,*) ' Subroutine PHOTO called with E = ',peig, ' wh
     *ich is below the current min. energy of 1 keV! '
          write(i_log,*) ' Converting now this photon to an electron, '
          write(i_log,*) ' but you should check your code! '
        END IF
        iq(np) = -1
        e(np) = peig + prm
        return
      END IF
      iZ = iedgfl
      do_relax = .false.
      edep = pzero
      IF (( iedgfl .NE. 0 )) THEN
        IF (( nne(medium) .EQ. 1 )) THEN
          iZ = int( zelem(medium,1) + 0.5 )
          DO 5221 j=1,edge_number(iZ)
            IF((peig .GE. edge_energies(j,iZ)))GO TO5222
5221      CONTINUE
5222      CONTINUE
        ELSE
          aux = peig*peig
          aux1 = aux*peig
          aux = aux*Sqrt(peig)
          sigtot = 0
          DO 5231 k=1,nne(medium)
            iZ = int( zelem(medium,k) + 0.5 )
            IF (( iZ .LT. 1 .OR. iZ .GT. 100 )) THEN
              write(i_log,*) ' Error in PHOTO: '
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) '   Atomic number of element ',k, ' in medi
     *um ',medium,' is not between 1 and ',100
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            IF (( peig .GT. edge_energies(1,iZ) )) THEN
              j = 1
              sigma = (edge_a(1,iZ) + edge_b(1,iZ)/peig + edge_c(1,iZ)/a
     *        ux + edge_d(1,iZ)/aux1)/peig
            ELSE
              DO 5241 j=2,edge_number(iZ)
                IF((peig .GE. edge_energies(j,iZ)))GO TO5242
5241          CONTINUE
5242          CONTINUE
              sigma = edge_a(j,iZ) + gle*(edge_b(j,iZ) + gle*(edge_c(j,i
     *        Z) + gle*edge_d(j,iZ) ))
              sigma = Exp(sigma)
            END IF
            sigma = sigma * pz(medium,k)
            sigtot = sigtot + sigma
            probs(k) = sigma
            ints(k) = j
5231      CONTINUE
5232      CONTINUE
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          br = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          br = br*sigtot
          DO 5251 k=1,nne(medium)
            br = br - probs(k)
            IF((br .LE. 0))GO TO5252
5251      CONTINUE
5252      CONTINUE
          iZ = int( zelem(medium,k) + 0.5 )
          j = ints(k)
        END IF
        IF (( peig .LE. binding_energies(6,iZ) )) THEN
          iq(np) = -1
          e(np) = peig + prm
        ELSE
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          br = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          DO 5261 k=1,5
            IF (( peig .GT. binding_energies(k,iZ) )) THEN
              IF((br .LT. interaction_prob(k,iZ)))GO TO5262
              br = (br - interaction_prob(k,iZ))/(1-interaction_prob(k,i
     *        Z))
            END IF
5261      CONTINUE
5262      CONTINUE
          IF ((eadl_relax .AND. k .GT. 4)) THEN
            iq(np) = -1
            e(np) = peig + prm
          ELSE
            e_vac = binding_energies(k,iZ)
            e(np) = peig - e_vac + prm
            do_relax = .true.
            iq(np) = -1
          END IF
        END IF
      ELSE
        e(np) = peig + prm
        iq(np) = -1
      END IF
      IF (( iq(np) .EQ. -1 )) THEN
        IF ((iphter.EQ.1)) THEN
          EELEC=E(NP)
          IF ((EELEC.GT.ecut)) THEN
            BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC
            GAMMA=EELEC/RM
            ALPHA=0.5*GAMMA-0.5+1./GAMMA
            RATIO=BETA/ALPHA
5271        CONTINUE
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              RNPHT = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              RNPHT=2.*RNPHT-1.
              IF ((RATIO.LE.0.2)) THEN
                FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT)
                IF (( gamma .LT. 100 )) THEN
                  COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                ELSE
                  IF (( fkappa .GT. 0 )) THEN
                    costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gam
     *              ma-1)**3)
                  ELSE
                    COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                  END IF
                END IF
                xi = (1+beta*fkappa)*gamma*gamma
              ELSE
                XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO)
     *          )-1.))
                COSTHE=(1.-1./XI)/BETA
              END IF
              SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE))
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              RNPHT2 = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              IF(RNPHT2.LE.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA)GO TO5272
            GO TO 5271
5272        CONTINUE
            SINTHE=SQRT(SINTH2)
            CALL UPHI(2,1)
          END IF
        END IF
      END IF
      IF (( do_relax )) THEN
        call relax(e_vac,k,iZ)
      END IF
      IF (( EDEP .GT. 0 )) THEN
        iarg=4
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          call egs_ausgab(iarg)
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,5280)prob_RR
5280        FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold
5291      CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              rnno_RR = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO5292
          GO TO 5291
5292      CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
      end
      subroutine egs_shellwise_photo
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common/bounds/ ecut, pcut, ecut_new, pcut_new, vacdst
      EGS_Float ecut, pcut, ecut_new, pcut_new, vacdst
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100)
      EGS_Float binding_energies, interaction_prob, relaxation_prob, edg
     *e_energies, edge_a,edge_b,edge_c,edge_d
      integer*4 edge_number
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(max_med), GE0(max_med),GE1(max_med), GMFP0(2
     *000,max_med),GMFP1(2000,max_med),GBR10(2000,max_med),GBR11(2000,ma
     *x_med),GBR20(2000,max_med),GBR21(2000,max_med), RCO0(max_med),RCO1
     *(max_med), RSCT0(100,max_med),RSCT1(100,max_med), COHE0(2000,max_m
     *ed),COHE1(2000,max_med),  PHOTONUC0(2000,max_med),PHOTONUC1(2000,m
     *ax_med), DPMFP, MPGEM(1,max_med), NGR(max_med)
      EGS_Float EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR
     *21,  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,
     *  DPMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/egs_vr/ e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_
     *RR, i_survived_RR, n_RR_warning, i_do_rr
      EGS_Float e_max_rr,e_max_rr_new,prob_RR
      integer*4 nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      EGS_Float relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,max_med),   pe_energy(500,100),  pe_zsorted(100,max_med), pe_
     *be(100,16),  pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      EGS_Float pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      EGS_Float EELEC,  BETA,  GAMMA,  ALPHA,  RATIO,  RNPHT,  FKAPPA, X
     *I,  SINTH2, RNPHT2
      DOUBLE PRECISION PEIG
      EGS_Float BR,  sigma,  aux,aux1,  probs(50),  sigtot,  e_vac,  rnn
     *o_RR
      integer*4 IARG,  iZ,   irl,  ints(50),  j,ip,  n_warning,  k
      logical do_relax
      save n_warning
      EGS_Float slope, logE, int_prob
      integer*4 zpos, ibsearch
      data n_warning/0/
      NPold = NP
      PEIG=E(NP)
      irl = ir(np)
      do_relax = .false.
      IF (( peig .LT. 0.001 )) THEN
        IF (( n_warning .LT. 100 )) THEN
          n_warning = n_warning + 1
          write(i_log,*) ' Subroutine egs_shellwise_photo called with E
     *= ', peig,' which is below the current min. energy of ', 0.001,' k
     *eV! '
          write(i_log,*) ' Converting now this photon to an electron, '
          write(i_log,*) ' but you should check your code! '
        END IF
        iq(np) = -1
        e(np) = peig + prm
        return
      END IF
      edep = pzero
      IF (( iedgfl .NE. 0 )) THEN
        j = -1
        IF (( nne(medium) .EQ. 1 )) THEN
          iZ = int( zelem(medium,1) + 0.5 )
          zpos = pe_zpos(iZ)
          IF (( pe_nshell(zpos) .GT. 0)) THEN
            logE = log(peig)
            j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos))
          END IF
        ELSE
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          br = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          logE = log(peig)
          DO 5301 k=nne(medium),1,-1
            iZ = int( zelem(medium,k) + 0.5 )
            zpos = pe_zpos(iZ)
            IF (( iZ .LT. 1 .OR. iZ .GT. 100 )) THEN
              write(i_log,*) ' Error in egs_shellwise_photo: '
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) '   Atomic number of element ',k, ' in medi
     *um ',medium,' is not between 1 and ',100
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos))
            slope = pe_elem_prob(j+1,k,medium) - pe_elem_prob(j,k,medium
     *      )
            slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos))
            int_prob = pe_elem_prob(j,k,medium)+slope*(logE-pe_energy(j,
     *      zpos))
            br = br - exp(int_prob)
            IF((br .LE. 0))GO TO5302
5301      CONTINUE
5302      CONTINUE
        END IF
        IF (( peig .LT. pe_be(zpos,pe_nshell(zpos)) .OR. pe_nshell(zpos)
     *   .EQ. 0 )) THEN
          iq(np) = -1
          e(np) = peig + prm
        ELSE
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          br = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          sigtot = 0
          DO 5311 k=1,pe_nshell(zpos)
            IF (( peig .GT. pe_be(zpos,k) )) THEN
              slope = pe_xsection(j+1,zpos,k) - pe_xsection(j,zpos,k)
              slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos))
              int_prob=pe_xsection(j,zpos,k)+slope*(logE-pe_energy(j,zpo
     *        s))
              br = br - exp(int_prob)
              sigtot = sigtot + exp(int_prob)
              IF((br .LE. 0))GO TO5312
            END IF
5311      CONTINUE
5312      CONTINUE
          IF ((k .GT. pe_nshell(zpos))) THEN
            iq(np) = -1
            e(np) = peig + prm
          ELSE
            e_vac = pe_be(zpos,k)
            e(np) = peig - e_vac + prm
            do_relax = .true.
            iq(np) = -1
          END IF
        END IF
      ELSE
        e(np) = peig + prm
        iq(np) = -1
      END IF
      IF (( iq(np) .EQ. -1 )) THEN
        IF ((iphter.EQ.1)) THEN
          EELEC=E(NP)
          IF ((EELEC.GT.ecut)) THEN
            BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC
            GAMMA=EELEC/RM
            ALPHA=0.5*GAMMA-0.5+1./GAMMA
            RATIO=BETA/ALPHA
5321        CONTINUE
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              RNPHT = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              RNPHT=2.*RNPHT-1.
              IF ((RATIO.LE.0.2)) THEN
                FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT)
                IF (( gamma .LT. 100 )) THEN
                  COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                ELSE
                  IF (( fkappa .GT. 0 )) THEN
                    costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gam
     *              ma-1)**3)
                  ELSE
                    COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA)
                  END IF
                END IF
                xi = (1+beta*fkappa)*gamma*gamma
              ELSE
                XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO)
     *          )-1.))
                COSTHE=(1.-1./XI)/BETA
              END IF
              SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE))
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              RNPHT2 = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              IF(RNPHT2.LE.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA)GO TO5322
            GO TO 5321
5322        CONTINUE
            SINTHE=SQRT(SINTH2)
            CALL UPHI(2,1)
          END IF
        END IF
      END IF
      IF (( do_relax )) THEN
        call egs_eadl_relax(iZ,k)
      END IF
      IF (( EDEP .GT. 0 )) THEN
        iarg=4
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          call egs_ausgab(iarg)
        END IF
      END IF
      i_survived_RR = 0
      IF (( i_play_RR .EQ. 1 )) THEN
        IF (( prob_RR .LE. 0 )) THEN
          IF (( n_RR_warning .LT. 50 )) THEN
            n_RR_warning = n_RR_warning + 1
            WRITE(6,5330)prob_RR
5330        FORMAT('**** Warning, attempt to play Roussian Roulette with
     * prob_RR<=0! ',g14.6)
          END IF
        ELSE
          ip = NPold
5341      CONTINUE
            IF (( iq(ip) .NE. 0 )) THEN
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              rnno_RR = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              IF (( rnno_RR .LT. prob_RR )) THEN
                wt(ip) = wt(ip)/prob_RR
                ip = ip + 1
              ELSE
                i_survived_RR = i_survived_RR + 1
                IF ((ip .LT. np)) THEN
                  e(ip) = e(np)
                  iq(ip) = iq(np)
                  wt(ip) = wt(np)
                  u(ip) = u(np)
                  v(ip) = v(np)
                  w(ip) = w(np)
                END IF
                np = np-1
              END IF
            ELSE
              ip = ip+1
            END IF
            IF(((ip .GT. np)))GO TO5342
          GO TO 5341
5342      CONTINUE
          IF (( np .EQ. 0 )) THEN
            np = 1
            e(np) = 0
            iq(np) = 0
            wt(np) = 0
          END IF
        END IF
      END IF
      return
      end
      subroutine egs_read_shellwise_pe
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100)
      EGS_Float binding_energies, interaction_prob, relaxation_prob, edg
     *e_energies, edge_a,edge_b,edge_c,edge_d
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(max_med), GE0(max_med),GE1(max_med), GMFP0(2
     *000,max_med),GMFP1(2000,max_med),GBR10(2000,max_med),GBR11(2000,ma
     *x_med),GBR20(2000,max_med),GBR21(2000,max_med), RCO0(max_med),RCO1
     *(max_med), RSCT0(100,max_med),RSCT1(100,max_med), COHE0(2000,max_m
     *ed),COHE1(2000,max_med),  PHOTONUC0(2000,max_med),PHOTONUC1(2000,m
     *ax_med), DPMFP, MPGEM(1,max_med), NGR(max_med)
      EGS_Float EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR
     *21,  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,
     *  DPMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,max_med),   pe_energy(500,100),  pe_zsorted(100,max_med), pe_
     *be(100,16),  pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      EGS_Float pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      integer*4 lnblnk1,egs_get_unit,pe_sw_unit,ounit,egs_open_file
      integer*4 sorted(100),i,j,k,l,m
      EGS_Float z_sorted(100),pz_sorted(100)
      EGS_Float rest_xs(500,100)
      EGS_Float tmp_e(500,16), tmp_xs(500,16)
      EGS_Float new_e(500),deltaEb,slope
      integer*4 zread(100),ib(16),ibsearch
      character data_dir*128,pe_sw_file*144
      integer*4 medio,iZ,iZpos,egs_read_int,pos,curr_rec
      real*4 egs_read_real,e_r, e_old,sigma_r
      integer*2 nz, egs_read_short,ish, i_nshell,i_nge
      logical is_open, is_there, shift_required
      character*3 labels(16)
      data labels/'  K',' L1',' L2',' L3', ' M1',' M2',' M3',' M4',' M5'
     *, ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/
      write(i_log,'(/a$)') ' Reading renormalized photoelectric cross se
     *ctions ......'
      data_dir = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      pe_sw_file = data_dir(:lnblnk1(data_dir)) // 'photo_shellwise.data
     *'
      pe_sw_unit = egs_get_unit(0)
      IF (( pe_sw_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_shellwise_pe: failed to get a free Fort
     *ran I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(pe_sw_unit,file=pe_sw_file,status='old', form='UNFORMATTED',A
     *CCESS='direct',recl=1, err=5350)
      GOTO 5360
5350  write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(2a)') 'egs_init_shellwise_pe: failed to open ', pe_s
     *w_file
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
5360  is_open = .true.
      DO 5371 medio=1,nmed
        DO 5381 i=1,nne(medio)
          pe_nshell(i*medio) = 0
          pe_nge(i*medio) = 0
          pe_zsorted(i,medio) = 0
5381    CONTINUE
5382    CONTINUE
5371  CONTINUE
5372  CONTINUE
      DO 5391 l=1,100
        pe_zpos(l) = -1
        DO 5401 k=1,500
          pe_energy(k,l) = 0.0
          DO 5411 m=1,16
            pe_xsection(k,l,m) = 0.0
5411      CONTINUE
5412      CONTINUE
5401    CONTINUE
5402    CONTINUE
        DO 5421 k=1,16
          pe_be(l,k) = -99
5421    CONTINUE
5422    CONTINUE
5391  CONTINUE
5392  CONTINUE
      curr_rec = 1
      iZpos = 0
      nz = egs_read_short(pe_sw_unit,curr_rec)
      DO 5431 medio=1,nmed
        DO 5441 i=1,nne(medio)
          z_sorted(i) = zelem(medio,i)
5441    CONTINUE
5442    CONTINUE
        call egs_heap_sort(nne(medio),z_sorted,sorted)
        DO 5451 i=1,nne(medio)
          pe_zsorted(i,medio) = z_sorted(i)
5451    CONTINUE
5452    CONTINUE
        DO 5461 i=1,nne(medio)
          iZ = z_sorted(i)
          is_there = .false.
          DO 5471 j=1,medio-1
            DO 5481 k=1,nne(j)
              IF (( iZ .EQ. pe_zsorted(k,j) )) THEN
                is_there = .true.
                GO TO5482
              END IF
5481        CONTINUE
5482        CONTINUE
5471      CONTINUE
5472      CONTINUE
          IF((is_there))GO TO5461
          iZpos = iZpos + 1
          zread(iZpos) = iZ
          pe_zpos(iZ) = iZpos
          pos = 3 + (iZ-1)*4
          curr_rec = egs_read_int(pe_sw_unit,pos) + 1
          i_nge = egs_read_short(pe_sw_unit,curr_rec)
          i_nshell = egs_read_short(pe_sw_unit,curr_rec)
          pe_nge(iZpos) = i_nge
          pe_nshell(iZpos) = i_nshell
          e_old = -1.0
          ish = 0
          DO 5491 j=1,i_nge
            e_r = egs_read_real(pe_sw_unit,curr_rec)
            sigma_r = egs_read_real(pe_sw_unit,curr_rec)
            pe_energy(j,iZpos) = e_r
            pe_xsection(j,iZpos,0) = sigma_r
            rest_xs(j,iZpos) = sigma_r
            DO 5501 k=1,i_nshell
              sigma_r = egs_read_real(pe_sw_unit,curr_rec)
              pe_xsection(j,iZpos,k) = sigma_r
              rest_xs(j,iZpos) = rest_xs(j,iZpos) - sigma_r
5501        CONTINUE
5502        CONTINUE
            IF ((e_r - e_old .LT. 1e-15)) THEN
              pe_be(iZpos,i_nshell-ish) = e_r
              ish = ish + 1
            END IF
            e_old = e_r
5491      CONTINUE
5492      CONTINUE
5461    CONTINUE
5462    CONTINUE
5431  CONTINUE
5432  CONTINUE
      pe_ne = iZpos
      DO 5511 i=1,pe_ne
        iZ = zread(i)
        IF ((pe_nshell(i) .EQ. 0)) THEN
          DO 5521 j=1,pe_nge(i)
            pe_energy(j,i) = log(pe_energy(j,i))
5521      CONTINUE
5522      CONTINUE
          GO TO5511
        END IF
        DO 5531 l=1,pe_nshell(i)
          IF (( pe_be(i,l) .NE. binding_energies(l,iZ))) THEN
            shift_required = .true.
            deltaEb = binding_energies(l,iZ)-pe_be(i,l)
          ELSE
            shift_required =.false.
          END IF
          is_there = .false.
          DO 5541 j=1,pe_nge(i)
            tmp_e(j,l) = pe_energy(j,i)
            tmp_xs(j,l) = pe_xsection(j,i,l)
            IF (( shift_required .AND. pe_energy(j,i) .GE. pe_be(i,l) ))
     *       THEN
              tmp_e(j,l) = tmp_e(j,l) + deltaEb
              IF ((pe_energy(j,i) .EQ. pe_be(i,l) .AND. .NOT.is_there))
     *        THEN
                ib(l) = j
                is_there = .true.
              END IF
              IF ((l .EQ. 1)) THEN
                new_e(j) = tmp_e(j,l)
              ELSE IF((j .LT. ib(l-1))) THEN
                new_e(j) = tmp_e(j,l)
              END IF
            END IF
5541      CONTINUE
5542      CONTINUE
          pe_be(i,l) = binding_energies(l,iZ)
5531    CONTINUE
5532    CONTINUE
        DO 5551 l=2,pe_nshell(i)
          DO 5561 j=1,pe_nge(i)
            IF (( new_e(j) .GE. pe_be(i,l-1) )) THEN
              m = ibsearch(new_e(j),pe_nge(i),tmp_e(1,l))
              slope = log(tmp_xs(m+1,l)/tmp_xs(m,l))
              slope = slope/log(tmp_e(m+1,l)/tmp_e(m,l))
              pe_xsection(j,i,l) = log(tmp_xs(m,l))
              pe_xsection(j,i,l) = pe_xsection(j,i,l) + slope*log(new_e(
     *        j)/tmp_e(m,l))
              pe_xsection(j,i,l) = exp(pe_xsection(j,i,l))
            END IF
5561      CONTINUE
5562      CONTINUE
5551    CONTINUE
5552    CONTINUE
        DO 5571 j=1,pe_nge(i)
          IF (( j .LT. ib(pe_nshell(i)))) THEN
            new_e(j) = pe_energy(j,i)
          END IF
          m = ibsearch(new_e(j),pe_nge(i),pe_energy(1,i))
          slope = log(rest_xs(m+1,i)/rest_xs(m,i))
          slope = slope/log(pe_energy(m+1,i)/pe_energy(m,i))
          pe_xsection(j,i,0) = log(rest_xs(m,i))
          pe_xsection(j,i,0) = pe_xsection(j,i,0) + slope*log(new_e(j)/p
     *    e_energy(m,i))
          pe_xsection(j,i,0) = exp(pe_xsection(j,i,0))
          DO 5581 l=1,pe_nshell(i)
            pe_xsection(j,i,0) = pe_xsection(j,i,0) + pe_xsection(j,i,l)
5581      CONTINUE
5582      CONTINUE
5571    CONTINUE
5572    CONTINUE
        DO 5591 j=1,pe_nge(i)
          pe_energy(j,i) = log(new_e(j))
          DO 5601 l=1,pe_nshell(i)
            pe_xsection(j,i,l) = log(pe_xsection(j,i,l)/pe_xsection(j,i,
     *      0))
5601      CONTINUE
5602      CONTINUE
5591    CONTINUE
5592    CONTINUE
5511  CONTINUE
5512  CONTINUE
      write(i_log,'(a/)') ' done'
      IF((is_open))close(pe_sw_unit)
      return
      end
      SUBROUTINE RELAX(energy,n,iZ)
      implicit none
      integer*4 n,iZ
      EGS_Float energy
      integer*4 vac_array(50),  n_vac,  shell
      integer*4 final,finala,  final1,final2,   iql,  irl
      integer*4 first_transition(5), last_transition(5)
      integer*4 final_state(39)
      integer*4 k, np_old, ip, iarg
      EGS_Float e_array(50),  Ei,Ef,  Ex,  eta,  e_check,  min_E,ekcut,p
     *kcut,elcut
      EGS_Float xphi,yphi,xphi2,yphi2,rhophi2, cphi,sphi
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      common/bounds/ ecut, pcut, ecut_new, pcut_new, vacdst
      EGS_Float ecut, pcut, ecut_new, pcut_new, vacdst
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100)
      EGS_Float binding_energies, interaction_prob, relaxation_prob, edg
     *e_energies, edge_a,edge_b,edge_c,edge_d
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      EGS_Float relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      common/user_relax/ u_relax,ish_relax,iZ_relax
      EGS_Float u_relax
      integer*4 ish_relax, iZ_relax
      data first_transition/1,20,27,33,38/
      data last_transition/19,26,32,37,39/
      data final_state/  4,3,5,6,  202,302,402,404,403,303,  502,503,504
     *,602,603,604,  505,605,606,  13,14,  5,6,  505,605,606,  14,  5,6,
     *  505,605,606,  5,6,  505,605,606,  6,  606/
      save first_transition,last_transition,final_state
      IF ((eadl_relax)) THEN
        call egs_eadl_relax(iZ,n)
        return
      END IF
      IF (( n .LT. 1 .OR. n .GT. 6 )) THEN
        return
      END IF
      iz_relax = iZ
      irl = ir(np)
      ekcut = ecut-rm
      pkcut = pcut
      min_E = 0.001
      IF (( energy .LE. min_E )) THEN
        edep = edep + energy
        edep_local = energy
        iarg=34
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          call egs_ausgab(iarg)
        END IF
        return
      END IF
      n_vac = 1
      vac_array(n_vac) = n
      np_old = np
      e_check = 0
      e_array(n_vac) = energy
5610  CONTINUE
5611    CONTINUE
        shell = vac_array(n_vac)
        Ei = e_array(n_vac)
        n_vac = n_vac - 1
        IF (( Ei .LE. min_E )) THEN
          edep = edep + Ei
          edep_local = Ei
          iarg=34
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
          IF((n_vac .GT. 0))goto 5610
          GO TO5612
        END IF
        ish_relax = shell
        u_relax = Ei
        IF (( shell .EQ. 6 )) THEN
          IF (( Ei .GT. ekcut )) THEN
            np = np + 1
            IF (( np .GT. max_stack )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','RELAX'
     *        , ' stack size exceeded! ',' $MAXSTACK = ',max_stack,' np
     *= ',np
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            e(np) = Ei + prm
            iq(np) = -1
            X(np)=X(np-1)
            Y(np)=Y(np-1)
            Z(np)=Z(np-1)
            IR(np)=IR(np-1)
            WT(np)=WT(np-1)
            DNEAR(np)=DNEAR(np-1)
            LATCH(np)=LATCH(np-1)
            IF (( rng_seed .GT. 128 )) THEN
              rng_seed = 128
              call egs_fill_rndm_array(rng_seed,rng_array)
              rng_seed = 1
            END IF
            eta = rng_array(rng_seed)
            rng_seed = rng_seed + 1
            eta = 2*eta - 1
            w(np) = eta
            eta = (1-eta)*(1+eta)
            IF (( eta .GT. 1e-20 )) THEN
              eta = Sqrt(eta)
5621          CONTINUE
                IF (( rng_seed .GT. 128 )) THEN
                  rng_seed = 128
                  call egs_fill_rndm_array(rng_seed,rng_array)
                  rng_seed = 1
                END IF
                xphi = rng_array(rng_seed)
                rng_seed = rng_seed + 1
                xphi = 2*xphi - 1
                xphi2 = xphi*xphi
                IF (( rng_seed .GT. 128 )) THEN
                  rng_seed = 128
                  call egs_fill_rndm_array(rng_seed,rng_array)
                  rng_seed = 1
                END IF
                yphi = rng_array(rng_seed)
                rng_seed = rng_seed + 1
                yphi2 = yphi*yphi
                rhophi2 = xphi2 + yphi2
                IF(rhophi2.LE.1)GO TO5622
              GO TO 5621
5622          CONTINUE
              rhophi2 = 1/rhophi2
              cphi = (xphi2 - yphi2)*rhophi2
              sphi = 2*xphi*yphi*rhophi2
              u(np) = eta*cphi
              v(np) = eta*sphi
            ELSE
              u(np) = 0
              v(np) = 0
              w(np) = 1
            END IF
            iarg=27
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
          ELSE
            edep = edep + Ei
            edep_local = Ei
            iarg=34
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
          END IF
          IF((n_vac .GT. 0))goto 5610
          GO TO5612
        END IF
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        eta = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        DO 5631 k=first_transition(shell),last_transition(shell)-1
          eta = eta - relaxation_prob(k,iZ)
          IF((eta .LE. 0))GO TO5632
5631    CONTINUE
5632    CONTINUE
        final = final_state(k)
        finala = final
        IF (( final .LT. 100 )) THEN
          IF (( final .LT. 10 )) THEN
            iql = 0
            elcut = pkcut
          ELSE
            final = final - 10
            iql = -1
            elcut = ekcut
          END IF
          Ef = binding_energies(final,iZ)
          Ex = Ei - Ef
          n_vac = n_vac + 1
          vac_array(n_vac) = final
          e_array(n_vac) = Ef
        ELSE
          final1 = final/100
          final2 = final - final1*100
          n_vac = n_vac + 1
          vac_array(n_vac) = final1
          e_array(n_vac) = binding_energies(final1,iZ)
          n_vac = n_vac + 1
          vac_array(n_vac) = final2
          e_array(n_vac) = binding_energies(final2,iZ)
          iql = -1
          Ex = Ei - e_array(n_vac) - e_array(n_vac-1)
          elcut = ekcut
        END IF
        IF (( Ex .LE. elcut )) THEN
          edep = edep + Ex
          IF (( finala .LT. 10 )) THEN
            edep_local = Ex
            iarg=33
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
          ELSE
            edep_local = Ex
            iarg=34
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
          END IF
        ELSE
          np = np + 1
          IF (( np .GT. max_stack )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','RELAX',
     *      ' stack size exceeded! ',' $MAXSTACK = ',max_stack,' np = ',
     *      np
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          iq(np) = iql
          IF (( iql .EQ. 0 )) THEN
            e(np) = Ex
          ELSE
            e(np) = Ex + rm
          END IF
          X(np)=X(np-1)
          Y(np)=Y(np-1)
          Z(np)=Z(np-1)
          IR(np)=IR(np-1)
          WT(np)=WT(np-1)
          DNEAR(np)=DNEAR(np-1)
          LATCH(np)=LATCH(np-1)
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          eta = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          eta = 2*eta - 1
          w(np) = eta
          eta = (1-eta)*(1+eta)
          IF (( eta .GT. 1e-20 )) THEN
            eta = Sqrt(eta)
5641        CONTINUE
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              xphi = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              xphi = 2*xphi - 1
              xphi2 = xphi*xphi
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              yphi = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              yphi2 = yphi*yphi
              rhophi2 = xphi2 + yphi2
              IF(rhophi2.LE.1)GO TO5642
            GO TO 5641
5642        CONTINUE
            rhophi2 = 1/rhophi2
            cphi = (xphi2 - yphi2)*rhophi2
            sphi = 2*xphi*yphi*rhophi2
            u(np) = eta*cphi
            v(np) = eta*sphi
          ELSE
            u(np) = 0
            v(np) = 0
            w(np) = 1
          END IF
          IF (( finala .LT. 10 )) THEN
            iarg=25
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
          ELSE IF(( finala .LT. 100 )) THEN
            iarg=26
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
          ELSE
            iarg=27
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
          END IF
        END IF
      GO TO 5611
5612  CONTINUE
      return
      end
      subroutine egs_init_relax
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100)
      EGS_Float binding_energies, interaction_prob, relaxation_prob, edg
     *e_energies, edge_a,edge_b,edge_c,edge_d
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(max_med), GE0(max_med),GE1(max_med), GMFP0(2
     *000,max_med),GMFP1(2000,max_med),GBR10(2000,max_med),GBR11(2000,ma
     *x_med),GBR20(2000,max_med),GBR21(2000,max_med), RCO0(max_med),RCO1
     *(max_med), RSCT0(100,max_med),RSCT1(100,max_med), COHE0(2000,max_m
     *ed),COHE1(2000,max_med),  PHOTONUC0(2000,max_med),PHOTONUC1(2000,m
     *ax_med), DPMFP, MPGEM(1,max_med), NGR(max_med)
      EGS_Float EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR
     *21,  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,
     *  DPMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      EGS_Float relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/shell_data/ shell_be(3000),  shell_type(3000),  shell_num(3
     *000),  shell_Z(3000),  shell_eadl(100,30),  shell_ntot
      EGS_Float shell_be
      integer*4 shell_type,shell_Z,shell_ntot,shell_num,shell_eadl
      integer*4 lnblnk1,egs_get_unit,relax_unit,ounit,egs_open_file
      integer*4 sorted(100),i,j,k,k1,k2,m
      EGS_Float z_sorted(100),pz_sorted(100)
      character data_dir*128,relax_file*144
      integer*4 ish,medio,iZ,ntran
      EGS_Float Ec, Pc, tmp, min_be, sumw,Ex
      logical is_open, is_there
      EGS_Float wtmp(300)
      integer*4 itmp(300)
      integer*4 pos, curr_rec, sh_eadl
      integer*4 nz, nshell, tr_type
      integer*4 ttype
      real*4 be_r, prob_r
      DO 5651 iZ=1,100
        DO 5661 k=1,30
          shell_eadl(iZ,k) = -1
5661    CONTINUE
5662    CONTINUE
5651  CONTINUE
5652  CONTINUE
      min_be = 0.001
      write(i_log,'(/a)') ' Reading EADL relaxation data ......'
      data_dir = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      relax_file = data_dir(:lnblnk1(data_dir)) // 'relax.data'
      relax_unit = egs_get_unit(0)
      IF (( relax_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_relax: failed to get a free Fortran I/O
     * unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(relax_unit,file=relax_file,status='old', form='UNFORMATTED',A
     *CCESS='direct',recl=4, err=5670)
      GOTO 5680
5670  write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(2a)') 'egs_init_relax: failed to open ', relax_file
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
5680  is_open = .true.
      curr_rec = 1
      read(relax_unit,rec=curr_rec) nz
      shell_ntot = 0
      relax_ntot = 0
      DO 5691 medio=1,nmed
        DO 5701 i=1,nne(medio)
          z_sorted(i) = zelem(medio,i)
5701    CONTINUE
5702    CONTINUE
        call egs_heap_sort(nne(medio),z_sorted,sorted)
        DO 5711 i=1,nne(medio)
          iZ = z_sorted(i)
          is_there = .false.
          DO 5721 j=1,shell_ntot
            IF (( iZ .EQ. shell_Z(j) )) THEN
              is_there = .true.
              GO TO5722
            END IF
5721      CONTINUE
5722      CONTINUE
          IF((is_there))GO TO5711
          pos = iZ + 1
          read(relax_unit,rec=pos) curr_rec
          read(relax_unit,rec=curr_rec) nshell
          IF (( shell_ntot + nshell .GT. 3000 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(a,i5,a/,a//)') ' Too many shells to fit in the
     * list: ', shell_ntot + nshell,' (at least).', ' Increase the param
     *eter $MAXSHELL and retry '
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          write(i_log,'(a,i3,a,i2,a)') '  Z = ',iZ,' has ',nshell,' shel
     *ls'
          DO 5731 ish=shell_ntot+1,shell_ntot+nshell
            curr_rec = curr_rec+1
            read(relax_unit,rec=curr_rec) shell_type(ish)
            curr_rec = curr_rec+1
            read(relax_unit,rec=curr_rec) ntran
            curr_rec = curr_rec+1
            read(relax_unit,rec=curr_rec) be_r
            shell_be(ish) = be_r
            shell_Z(ish) = iZ
            shell_num(ish) = ish - shell_ntot
            shell_eadl(iZ,shell_num(ish)) = ish
            IF ((binding_energies(shell_num(ish),iZ) .GT. 0)) THEN
              shell_be(ish) = binding_energies(shell_num(ish),iZ)
            ELSE IF(( photon_xsections .EQ. 'epdl' )) THEN
              binding_energies(shell_num(ish),iZ) = shell_be(ish)
            END IF
            DO 5741 k=1,ntran
              curr_rec = curr_rec+1
              read(relax_unit,rec=curr_rec) itmp(k)
              curr_rec = curr_rec+1
              read(relax_unit,rec=curr_rec) prob_r
              wtmp(k)=prob_r
              IF ((itmp(k).LT.64)) THEN
                itmp(k) = itmp(k) + 1
              ELSE
                itmp(k) = itmp(k) + 65
              END IF
5741        CONTINUE
5742        CONTINUE
            IF (( shell_be(ish) .LT. min_be )) THEN
              relax_first(ish) = -1
              relax_ntran(ish) = -1
            ELSE
              sumw = 0
              DO 5751 k=1,ntran
                sumw = sumw + wtmp(k)
5751          CONTINUE
5752          CONTINUE
              IF (( sumw .GT. 1 )) THEN
                DO 5761 k=1,ntran
                  wtmp(k) = wtmp(k)/sumw
5761            CONTINUE
5762            CONTINUE
              ELSE IF(( sumw .LT. 1 )) THEN
                ntran = ntran + 1
                itmp(ntran) = -1
                wtmp(ntran) = 1-sumw
              END IF
              IF (( relax_ntot + ntran .GT. 10000 )) THEN
                write(i_log,'(/a)') '***************** Error: '
                write(i_log,'(a,i5,a/,a/)') ' Too many relaxation transi
     *tions: ', relax_ntot + ntran,' (at least).', ' Increase $MAXRELAX
     *and retry '
                write(i_log,'(/a)') '***************** Quiting now.'
                call exit(1)
              END IF
              relax_first(ish) = relax_ntot+1
              relax_ntran(ish) = ntran
              call prepare_alias_histogram(ntran,wtmp, relax_atbin(relax
     *        _ntot+1))
              DO 5771 k=1,ntran
                j = relax_ntot + k
                relax_state(j) = itmp(k)
                relax_prob(j) = wtmp(k)
5771          CONTINUE
5772          CONTINUE
              relax_ntot = relax_ntot + ntran
            END IF
5731      CONTINUE
5732      CONTINUE
          shell_ntot = shell_ntot + nshell
5711    CONTINUE
5712    CONTINUE
5691  CONTINUE
5692  CONTINUE
      write(i_log,'(a/)') ' ...... Done.'
      IF((is_open))close(relax_unit)
      return
      stop
      end
      subroutine egs_eadl_relax(iZ, shell_egs)
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      EGS_Float relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      common/relax_for_user/ rfu_E0,  rfu_E,  rfu_Z,  rfu_j0,  rfu_n0,
     *rfu_t0,  rfu_j,  rfu_n,  rfu_t
      integer*4 rfu_Z,rfu_j0,rfu_n0,rfu_t0,rfu_j,rfu_n,rfu_t
      EGS_Float rfu_E0,rfu_E
      common/shell_data/ shell_be(3000),  shell_type(3000),  shell_num(3
     *000),  shell_Z(3000),  shell_eadl(100,30),  shell_ntot
      EGS_Float shell_be
      integer*4 shell_type,shell_Z,shell_ntot,shell_num,shell_eadl
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common/bounds/ ecut, pcut, ecut_new, pcut_new, vacdst
      EGS_Float ecut, pcut, ecut_new, pcut_new, vacdst
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/misc/ DUNIT,KMPI,KMPO
      EGS_Float DUNIT
      integer*4 KMPI,KMPO
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      common/user_relax/ u_relax,ish_relax,iZ_relax
      EGS_Float u_relax
      integer*4 ish_relax, iZ_relax
      EGS_Float Ec,Pc,min_E,rnno,Evac,Ef,Ef1,Ef2,Ex,Ecc, cost,sint,cphi,
     *sphi
      integer*4 shell, shell_egs, iZ, iarg
      integer*4 irl,vacs(100),nvac,vac,new_state,iqf,np_save,new1,new2
      integer*4 sample_alias_histogram
      EGS_Float xphi,xphi2,yphi,yphi2,rhophi2
      shell = shell_eadl(iZ,shell_egs)
      IF (( shell .LT. 1 .OR. shell .GT. 3000 )) THEN
        return
      END IF
      irl = ir(np)
      Ec = ecut - rm
      Pc = pcut
      min_E = 0.001
      Evac = shell_be(shell)
      rfu_Z = shell_Z(shell)
      rfu_j0 = shell
      rfu_n0 = shell_num(shell)
      rfu_t0 = shell_type(shell)
      rfu_E0 = Evac
      IF ((shell_egs .GT. 4 .AND. .NOT.mcdf_pe_xsections)) THEN
        edep = Evac
        edep_local = Evac
        iarg=34
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          call egs_ausgab(iarg)
        END IF
        return
      END IF
      vac = shell
      Nvac = 0
      np_save = np
5781  CONTINUE
        IF (( Evac .LT. min_E .OR. relax_ntran(vac) .LT. 1 )) THEN
          edep = edep + Evac
          edep_local = Evac
          iarg=34
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
          go to 5790
        END IF
        new_state = sample_alias_histogram(relax_ntran(vac), relax_prob(
     *  relax_first(vac)), relax_atbin(relax_first(vac)))
        IF (( new_state .LT. 0 )) THEN
          Ef = 0
          iqf = -1
          Ecc = Ec
        ELSE
          new_state = relax_state(relax_first(vac)+new_state-1)
          IF (( new_state .LE. 64 )) THEN
            iqf = 0
            new_state = new_state + vac - shell_num(vac)
            Ef = shell_be(new_state)
            Nvac = Nvac + 1
            vacs(Nvac) = new_state
            Ecc = Pc
          ELSE
            iqf = -1
            new1 = new_state/64
            new2 = new_state - 64*new1
            new1 = new1 + vac - shell_num(vac)
            new2 = new2 + vac - shell_num(vac)
            Ef1 = shell_be(new1)
            Ef2 = shell_be(new2)
            Nvac = Nvac + 1
            vacs(Nvac) = new1
            Nvac = Nvac + 1
            vacs(Nvac) = new2
            Ef = Ef1 + Ef2
            Ecc = Ec
          END IF
        END IF
        Ex = Evac - Ef
        edep_local = 0
        IF (( Ex .GT. Ecc )) THEN
          np = np + 1
          IF (( np .GT. max_stack )) THEN
            write(i_log,'(/a)') '***************** Warning: '
            write(i_log,'(3(a,f10.6),a,i2)') 'Evac = ',Evac, ' Ef = ',Ef
     *      ,  ' min_E = ', min_E,' iq = ',iqf
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,'(//,3a,/,2(a,i9),/,a)') ' In subroutine ','new_
     *relax', ' stack size exceeded! ',' $MXSTACK = ',max_stack,' np = '
     *      ,np, ' Increase $MXSTACK and try again '
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          iq(np) = iqf
          X(np)=X(np_save)
          Y(np)=Y(np_save)
          Z(np)=Z(np_save)
          IR(np)=IR(np_save)
          WT(np)=WT(np_save)
          DNEAR(np)=DNEAR(np_save)
          LATCH(np)=LATCH(np_save)
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnno = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          cost = 2*rnno-1
          sint = 1-cost*cost
          IF (( sint .GT. 0 )) THEN
            sint = sqrt(sint)
5801        CONTINUE
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              xphi = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              xphi = 2*xphi - 1
              xphi2 = xphi*xphi
              IF (( rng_seed .GT. 128 )) THEN
                rng_seed = 128
                call egs_fill_rndm_array(rng_seed,rng_array)
                rng_seed = 1
              END IF
              yphi = rng_array(rng_seed)
              rng_seed = rng_seed + 1
              yphi2 = yphi*yphi
              rhophi2 = xphi2 + yphi2
              IF(rhophi2.LE.1)GO TO5802
            GO TO 5801
5802        CONTINUE
            rhophi2 = 1/rhophi2
            cphi = (xphi2 - yphi2)*rhophi2
            sphi = 2*xphi*yphi*rhophi2
            u(np) = sint*cphi
            v(np) = sint*sphi
            w(np) = cost
          ELSE
            u(np) = 0
            v(np) = 0
            w(np) = cost
          END IF
          rfu_j = vac
          rfu_n = shell_num(vac)
          rfu_t = shell_type(vac)
          rfu_E = shell_be(vac)
          IF (( iqf .EQ. 0 )) THEN
            e(np) = Ex
            iarg=25
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
          ELSE
            e(np) = Ex + rm
            iarg=27
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
          END IF
        ELSE
          edep = edep + Ex
          IF (( iqf .EQ. 0 )) THEN
            edep_local = Ex
            iarg=33
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
          ELSE
            edep_local = Ex
            iarg=34
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
          END IF
        END IF
5790    CONTINUE
        IF((Nvac .EQ. 0))GO TO5782
        vac = vacs(Nvac)
        Evac = shell_be(vac)
        Nvac = Nvac - 1
      GO TO 5781
5782  CONTINUE
      return
      end
      subroutine init_triplet
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/triplet_data/ a_triplet(250,max_med), b_triplet(250,max_med
     *), dl_triplet, dli_triplet, bli_triplet, log_4rm
      EGS_Float a_triplet,b_triplet,dl_triplet, dli_triplet, bli_triplet
     *, log_4rm
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      EGS_Float energies(55), sig_pair(100,55), sig_triplet(100,55), f_t
     *riplet(55), sigp(55), sigt(55), as(55), bs(55), cs(55), ds(55)
      character*128 triplet_data_file
      integer*4 want_triplet_unit, triplet_unit, triplet_out
      integer*4 i, iel, imed, lnblnk1, egs_get_unit, ntrip, iz1, izi, if
     *irst
      EGS_Float logE, f_new, f_old, spline
      IF((itriplet .EQ. 0))return
      DO 5811 i=1,len(triplet_data_file)
        triplet_data_file(i:i) = ' '
5811  CONTINUE
5812  CONTINUE
      triplet_data_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/
     *' // 'triplet.data'
      want_triplet_unit = 63
      triplet_unit = egs_get_unit(want_triplet_unit)
      IF (( triplet_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'init_triplet: failed to get a free Fortran I/O u
     *nit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(triplet_unit,file=triplet_data_file,err=5820)
      write(i_log,'(a,$)') ' init_triplet: reading triplet data ... '
      read(triplet_unit,*) ntrip
      IF (( ntrip .GT. 55 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Max. number of data points per element is ',55
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      read(triplet_unit,*,err=5830) (energies(i),i=1,ntrip)
      DO 5841 iel=1,100
        read(triplet_unit,*)
        read(triplet_unit,*,err=5830) (sig_pair(iel,i),i=1,ntrip)
        read(triplet_unit,*,err=5830) (sig_triplet(iel,i),i=1,ntrip)
5841  CONTINUE
5842  CONTINUE
      write(i_log,*) 'OK'
      ifirst = 0
      DO 5851 i=1,ntrip
        IF((ifirst .EQ. 0 .AND. energies(i) .GT. 4.01*rm))ifirst = i
        energies(i) = log(energies(i))
5851  CONTINUE
5852  CONTINUE
      log_4rm = log(4*rm)
      energies(ifirst-1) = log_4rm
      dl_triplet = (energies(ntrip) - log_4rm)/250
      dli_triplet = 1/dl_triplet
      bli_triplet = 1 - log_4rm/dl_triplet
      DO 5861 imed=1,nmed
        write(i_log,'(a,i3,a,$)') '   Preparing triplet fraction data fo
     *r medium ',imed,' ... '
        iz1 = zelem(imed,1) + 0.1
        DO 5871 i=1,ntrip
          sigp(i) = pz(imed,1)*sig_pair(iz1,i)
          sigt(i) = pz(imed,1)*sig_triplet(iz1,i)
          DO 5881 iel=2,nne(imed)
            izi = zelem(imed,iel) + 0.1
            sigp(i) = sigp(i) + pz(imed,iel)*sig_pair(izi,i)
            sigt(i) = sigt(i) + pz(imed,iel)*sig_triplet(izi,i)
5881      CONTINUE
5882      CONTINUE
5871    CONTINUE
5872    CONTINUE
        DO 5891 i=ifirst,ntrip
          f_triplet(i-ifirst+2) = sigt(i)/(sigp(i) + sigt(i))
5891    CONTINUE
5892    CONTINUE
        f_triplet(1) = 0
        call set_spline(energies(ifirst-1),f_triplet,as,bs,cs,ds,ntrip-i
     *  first+2)
        logE = log_4rm
        f_old = 0
        DO 5901 i=1,250-1
          logE = logE + dl_triplet
          f_new = spline(logE,energies(ifirst-1),as,bs,cs,ds,ntrip-ifirs
     *    t+2)
          a_triplet(i,imed) = (f_new - f_old)*dli_triplet
          b_triplet(i,imed) = f_new - a_triplet(i,imed)*logE
          f_old = f_new
5901    CONTINUE
5902    CONTINUE
        write(i_log,*) 'OK'
5861  CONTINUE
5862  CONTINUE
      close(triplet_unit)
      return
5820  CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,a)') ' init_triplet: failed to open the data file
     *', triplet_data_file(:lnblnk1(triplet_data_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
5830  CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) ' init_triplet: error while reading triplet data '
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      SUBROUTINE EDGSET(NREGLO,NREGHI)
      implicit none
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100)
      EGS_Float binding_energies, interaction_prob, relaxation_prob, edg
     *e_energies, edge_a,edge_b,edge_c,edge_d
      integer*4 edge_number
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer NREGLO,NREGHI
      integer*4 i,j,k,jj,iz
      logical do_relax
      logical got_data
      save got_data
      data got_data/.false./
      IF((got_data))return
      write(i_log,'(a/,a)') 'Output from subroutine EDGSET:', '=========
     *====================='
      do_relax = (iedgfl.gt.0.and.iedgfl.le.100)
      IF (( .NOT.do_relax )) THEN
        IF ((eadl_relax)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,/a)') 'You must turn ON atomic relaxations whe
     *n requesting', 'detailed atomic relaxation (eadl_relax=true)!'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        write(i_log,'(a/)') ' Atomic relaxations not requested! '
        return
      END IF
      write(i_log,'(a/)') ' Atomic relaxations requested! '
      write(i_log,'(a$)') ' Reading simplified photo-absorption data ...
     *..'
      got_data = .true.
      rewind(i_photo_relax)
      DO 5911 i=1,100
        IF ((eadl_relax)) THEN
          read(i_photo_relax,*)
        ELSE
          read(i_photo_relax,*) j,(binding_energies(k,i),k=1,6)
          DO 5921 k=1,6
            binding_energies(k,i) = binding_energies(k,i)*1e-6
5921      CONTINUE
5922      CONTINUE
        END IF
5911  CONTINUE
5912  CONTINUE
      read(i_photo_relax,*)
      DO 5931 i=1,100
        read(i_photo_relax,*) j,(interaction_prob(k,i),k=1,5)
        interaction_prob(6,i)=1.01
5931  CONTINUE
5932  CONTINUE
      write(i_log,'(a)') ' Done'
      write(i_log,'(/a$)') ' Reading simplified relaxation data .....'
      read(i_photo_relax,*)
      DO 5941 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=1,19)
5941  CONTINUE
5942  CONTINUE
      read(i_photo_relax,*)
      DO 5951 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=20,26)
5951  CONTINUE
5952  CONTINUE
      read(i_photo_relax,*)
      DO 5961 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=27,32)
5961  CONTINUE
5962  CONTINUE
      read(i_photo_relax,*)
      DO 5971 i=1,100
        read(i_photo_relax,*) j,(relaxation_prob(k,i),k=33,37)
5971  CONTINUE
5972  CONTINUE
      read(i_photo_relax,*)
      DO 5981 i=1,100
        read(i_photo_relax,*) j,relaxation_prob(38,i)
5981  CONTINUE
5982  CONTINUE
      write(i_log,'(a)') ' Done'
      write(i_log,'(/a$)') ' Reading parametrized XCOM photo cross secti
     *on data .....'
      rewind(i_photo_cs)
      DO 5991 i=1,100
        read(i_photo_cs,*) j,edge_number(i)
        DO 6001 j=1,edge_number(i)
          read(i_photo_cs,*) edge_a(j,i),edge_b(j,i),edge_c(j,i), edge_d
     *    (j,i),edge_energies(j,i)
6001    CONTINUE
6002    CONTINUE
5991  CONTINUE
5992  CONTINUE
      write(i_log,'(a)') ' Done'
      IF ((eadl_relax)) THEN
        call egs_init_relax
      END IF
      RETURN
      END
      SUBROUTINE PHOTON(IRCODE)
      implicit none
      integer*4 IRCODE
      integer max_med
      parameter (max_med = MXMED)
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      common/bounds/ ecut, pcut, ecut_new, pcut_new, vacdst
      EGS_Float ecut, pcut, ecut_new, pcut_new, vacdst
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/misc/ DUNIT,KMPI,KMPO
      EGS_Float DUNIT
      integer*4 KMPI,KMPO
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      COMMON/PHOTIN/ EBINDA(max_med), GE0(max_med),GE1(max_med), GMFP0(2
     *000,max_med),GMFP1(2000,max_med),GBR10(2000,max_med),GBR11(2000,ma
     *x_med),GBR20(2000,max_med),GBR21(2000,max_med), RCO0(max_med),RCO1
     *(max_med), RSCT0(100,max_med),RSCT1(100,max_med), COHE0(2000,max_m
     *ed),COHE1(2000,max_med),  PHOTONUC0(2000,max_med),PHOTONUC1(2000,m
     *ax_med), DPMFP, MPGEM(1,max_med), NGR(max_med)
      EGS_Float EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR
     *21,  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,
     *  DPMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common/egs_vr/ e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_
     *RR, i_survived_RR, n_RR_warning, i_do_rr
      EGS_Float e_max_rr,e_max_rr_new,prob_RR
      integer*4 nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      DOUBLE PRECISION PEIG
      EGS_Float EIG,  RNNO35,  GMFPR0,  GMFP,  COHFAC,  RNNO37,  XXX,  X
     *2,  Q2,  CSQTHE,  REJF,  RNNORJ,  RNNO36,  GBR1,  GBR2,  T,   PHOT
     *ONUCFAC,  RNNO39
      integer*4 IARG,  IDR,  IRL,  LGLE,  LXXX
      IRCODE=1
      PEIG=E(NP)
      EIG=PEIG
      IRL=IR(NP)
      call egs_start_particle
      IF (( idisc .GT. 0 )) THEN
        np=np-1
        return
      END IF
      IF ((EIG .LE. pcut)) THEN
        GO TO 6010
      END IF
6020  CONTINUE
6021    CONTINUE
        IF ((WT(NP) .EQ. 0.0)) THEN
          go to 6030
        END IF
        GLE=LOG(EIG)
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        RNNO35 = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        IF ((RNNO35.EQ.0.0)) THEN
          RNNO35=1.E-30
        END IF
        DPMFP=-LOG(RNNO35)
        IROLD=IR(NP)
6040    CONTINUE
6041      CONTINUE
          IF ((MEDIUM.NE.0)) THEN
            LGLE=GE1(MEDIUM)*GLE+GE0(MEDIUM)
            GMFPR0=GMFP1(LGLE,MEDIUM)*GLE+GMFP0(LGLE,MEDIUM)
          END IF
6050      CONTINUE
6051        CONTINUE
            IF ((MEDIUM.EQ.0)) THEN
              TSTEP=VACDST
            ELSE
              rhof = rhor
              GMFP=GMFPR0/RHOF
              IF ((iraylr.EQ.1)) THEN
                COHFAC=COHE1(LGLE,MEDIUM)*GLE+COHE0(LGLE,MEDIUM)
                GMFP=GMFP*COHFAC
              END IF
              IF ((IPHOTONUC.EQ.1)) THEN
                PHOTONUCFAC=PHOTONUC1(LGLE,MEDIUM)*GLE+PHOTONUC0(LGLE,ME
     *          DIUM)
                GMFP=GMFP*PHOTONUCFAC
              END IF
              TSTEP=GMFP*DPMFP
            END IF
            IRNEW=IR(NP)
            IDISC=0
            USTEP=TSTEP
            TUSTEP=USTEP
            IF (( ustep .GT. dnear(np) .OR. wt(np) .LE. 0 )) THEN
              call egs_howfar
            END IF
            IF ((IDISC.GT.0)) THEN
              GO TO 6030
            END IF
            VSTEP=USTEP
            TVSTEP=VSTEP
            EDEP=PZERO
            x_final = x(np) + u(np)*vstep
            y_final = y(np) + v(np)*vstep
            z_final = z(np) + w(np)*vstep
            iarg=0
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
            x(np) = x_final
            y(np) = y_final
            z(np) = z_final
            DNEAR(NP)=DNEAR(NP)-USTEP
            IF ((MEDIUM.NE.0)) THEN
              DPMFP=MAX(0.,DPMFP-USTEP/GMFP)
            END IF
            IROLD=IR(NP)
            MEDOLD=MEDIUM
            IF ((IRNEW.NE.IROLD)) THEN
              ir(np) = irnew
              irl = irnew
              rhor = rhor_new
              medium = medium_new
              pcut = pcut_new
            END IF
            iarg=5
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
            IF ((EIG.LE.pcut)) THEN
              GO TO 6010
            END IF
            IF((IDISC.LT.0))GO TO 6030
            IF((MEDIUM.NE.MEDOLD))GO TO 6052
            IF ((MEDIUM.NE.0.AND.DPMFP.LE.1.E-8)) THEN
              GO TO 6042
            END IF
          GO TO 6051
6052      CONTINUE
        GO TO 6041
6042    CONTINUE
        IF ((iraylr.EQ.1)) THEN
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          RNNO37 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF ((RNNO37.LE.(1.0-COHFAC))) THEN
            iarg=23
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
            NPold = NP
            call egs_rayleigh_sampling(MEDIUM,E(NP),GLE,LGLE,COSTHE,SINT
     *      HE)
            CALL UPHI(2,1)
            iarg=24
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
            GOTO 6020
          END IF
        END IF
        IF ((IPHOTONUC.EQ.1)) THEN
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          RNNO39 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          IF ((RNNO39.LE.(1.0-PHOTONUCFAC))) THEN
            iarg=29
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
            call PHOTONUC
            iarg=30
            IF ((IAUSFL(IARG+1).NE.0)) THEN
              call egs_ausgab(iarg)
            END IF
            GOTO 6020
          END IF
        END IF
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        RNNO36 = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        GBR1=GBR11(LGLE,MEDIUM)*GLE+GBR10(LGLE,MEDIUM)
        IF (((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )) THEN
          iarg=15
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
          CALL PAIR
          iarg=16
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
          IF (( iq(np) .NE. 0 )) THEN
            GO TO 6022
          ELSE
            goto 6060
          END IF
        END IF
        GBR2=GBR21(LGLE,MEDIUM)*GLE+GBR20(LGLE,MEDIUM)
        IF ((RNNO36.LT.GBR2)) THEN
          iarg=17
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
          CALL COMPT
          iarg=18
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
          IF((IQ(NP).NE.0))GO TO 6022
        ELSE
          iarg=19
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
          CALL PHOTO
          IF ((NP .EQ. 0 .OR. NP .LT. NPOLD )) THEN
            RETURN
          END IF
          iarg=20
          IF ((IAUSFL(IARG+1).NE.0)) THEN
            call egs_ausgab(iarg)
          END IF
          IF((IQ(NP) .NE. 0))GO TO 6022
        END IF
6060    PEIG=E(NP)
        EIG=PEIG
        IF((EIG.LT.pcut))GO TO 6010
      GO TO 6021
6022  CONTINUE
      RETURN
6010  IF (( medium .GT. 0 )) THEN
        IF ((EIG.GT.AP(MEDIUM))) THEN
          IDR=1
        ELSE
          IDR=2
        END IF
      ELSE
        IDR=1
      END IF
      EDEP=PEIG
      iarg=IDR
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        call egs_ausgab(iarg)
      END IF
      IRCODE=2
      NP=NP-1
      RETURN
6030  EDEP=PEIG
      iarg=3
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        call egs_ausgab(iarg)
      END IF
      IRCODE=2
      NP=NP-1
      RETURN
      END
      SUBROUTINE SHOWER(IQI,EI,XI,YI,ZI,UI,VI,WI,IRI,WTI)
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      EGS_Float EI,  XI,YI,ZI, UI,VI,WI, WTI
      integer*4 IQI,  IRI
      DOUBLE PRECISION DEG,  DPGL,  DEI,  DPI,  DCSTH,  DCOSTH,  PI0MSQ
      EGS_Float DNEARI,  CSTH
      integer*4 IRCODE
      DATA PI0MSQ/1.8215416D4/
      NP=1
      NPold = NP
      DNEARI=0.0
      IQ(1)=IQI
      E(1)=EI
      U(1)=UI
      V(1)=VI
      W(1)=WI
      X(1)=XI
      Y(1)=YI
      Z(1)=ZI
      IR(1)=IRI
      WT(1)=WTI
      DNEAR(1)=DNEARI
      LATCH(1)=LATCHI
      IF ((IQI .EQ. 2)) THEN
        IF ((EI**2 .LE. PI0MSQ)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//a/,a,g15.5,a)') ' Stopped in subroutine SHOWER
     *---PI-ZERO option invoked', ' but the total energy was too small (
     *EI=',EI,' MeV)'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        CSTH = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        DCSTH=CSTH
        DEI=EI
        DPI=DSQRT(DEI*DEI-PI0MSQ)
        DEG=DEI+DPI*DCSTH
        DPGL=DPI+DEI*DCSTH
        DCOSTH=DPGL/DEG
        COSTHE=DCOSTH
        SINTHE=DSQRT(1.D0-DCOSTH*DCOSTH)
        IQ(1)=0
        E(1)=DEG/2.
        CALL UPHI(2,1)
        NP=2
        DEG=DEI-DPI*DCSTH
        DPGL=DPI-DEI*DCSTH
        DCOSTH=DPGL/DEG
        COSTHE=DCOSTH
        SINTHE=-DSQRT(1.D0-DCOSTH*DCOSTH)
        IQ(2)=0
        E(2)=DEG/2.
        CALL UPHI(3,2)
      END IF
6071  CONTINUE
        IF((np .LE. 0))GO TO6072
        IF (( iq(np) .EQ. 0 )) THEN
          call photon(ircode)
        ELSE
          call electr(ircode)
        END IF
      GO TO 6071
6072  CONTINUE
      RETURN
      END
      SUBROUTINE UPHI(IENTRY,LVL)
      implicit none
      COMMON/QDEBUG/QDEBUG
      LOGICAL QDEBUG
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/UPHIIN/SINC0,SINC1,SIN0(1002),SIN1(1002)
      EGS_Float SINC0,SINC1,SIN0,SIN1
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer IENTRY,LVL
      EGS_Float CTHET,  RNNO38,  PHI,  CPHI,  A,B,C,  SINPS2,  SINPSI,
     *US,VS,  SINDEL,COSDEL
      integer*4 IARG,  LPHI,LTHETA,LCTHET,LCPHI
      EGS_Float xphi,xphi2,yphi,yphi2,rhophi2
      save CTHET,PHI,CPHI,A,B,C,SINPS2,SINPSI,US,VS,SINDEL,COSDEL
      iarg=21
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        call egs_ausgab(iarg)
      END IF
      GO TO (6080,6090,6100),IENTRY
      GO TO 6110
6080  CONTINUE
      SINTHE=sin(THETA)
      CTHET=PI5D2-THETA
      COSTHE=sin(CTHET)
6090  CONTINUE
6121  CONTINUE
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        xphi = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        xphi = 2*xphi - 1
        xphi2 = xphi*xphi
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        yphi = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        yphi2 = yphi*yphi
        rhophi2 = xphi2 + yphi2
        IF(rhophi2.LE.1)GO TO6122
      GO TO 6121
6122  CONTINUE
      rhophi2 = 1/rhophi2
      cosphi = (xphi2 - yphi2)*rhophi2
      sinphi = 2*xphi*yphi*rhophi2
6100  GO TO (6130,6140,6150),LVL
      GO TO 6110
6130  A=U(NP)
      B=V(NP)
      C=W(NP)
      GO TO 6160
6150  A=U(NP-1)
      B=V(NP-1)
      C=W(NP-1)
6140  X(NP)=X(NP-1)
      Y(NP)=Y(NP-1)
      Z(NP)=Z(NP-1)
      IR(NP)=IR(NP-1)
      WT(NP)=WT(NP-1)
      DNEAR(NP)=DNEAR(NP-1)
      LATCH(NP)=LATCH(NP-1)
6160  SINPS2=A*A+B*B
      IF ((SINPS2.LT.1.0E-20)) THEN
        U(NP)=SINTHE*COSPHI
        V(NP)=SINTHE*SINPHI
        W(NP)=C*COSTHE
      ELSE
        SINPSI=SQRT(SINPS2)
        US=SINTHE*COSPHI
        VS=SINTHE*SINPHI
        SINDEL=B/SINPSI
        COSDEL=A/SINPSI
        U(NP)=C*COSDEL*US-SINDEL*VS+A*COSTHE
        V(NP)=C*SINDEL*US+COSDEL*VS+B*COSTHE
        W(NP)=-SINPSI*US+C*COSTHE
      END IF
      iarg=22
      IF ((IAUSFL(IARG+1).NE.0)) THEN
        call egs_ausgab(iarg)
      END IF
      RETURN
6110  write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(a,2i6)') ' STOPPED IN UPHI WITH IENTRY,LVL=',IENTRY,
     *LVL
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      END
      subroutine init_nist_brems
      implicit none
      EGS_Float energy_array(57),x_array(54), cs_array(57,54,100)
      EGS_Float xi_array(54)
      real*8 x_gauss(64),w_gauss(64)
      integer*4 nmix,kmix,i,n,k,j,ii
      integer*4 ngauss,i_gauss
      integer*4 lnblnk1,egs_get_unit
      integer*4 ifirst,ilast,nener,neke,leil
      EGS_Float cs(57,54),ee(57),ele(57)
      EGS_Float csx(54),afx(54),bfx(54),cfx(54),dfx(54)
      EGS_Float cse(57),afe(57),bfe(57),cfe(57),dfe(57)
      EGS_Float Z,sumA
      EGS_Float emin,xi,res,spline,eil,ei,beta2,aux,sigb,sigt,ebr1,ebr2
      EGS_Float sigee,sigep,sige,si_esig,si1_esig,si_ebr1,si1_ebr1,ededx
     *, sig_bhabha,si_psig,si1_psig,si_pbr1,si1_pbr1,si_pbr2,si1_pbr2
      integer*4 iz
      EGS_Float ple,qle,x,f,error,max_error,x_max_error,f_max_error
      integer*4 ndat,k_max_error
      character tmp_string*512, tmp1_string*512
      integer itmp
      EGS_Float amu
      parameter (amu = 1660.5655)
      logical ex,is_opened
      integer max_med
      parameter (max_med = MXMED)
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/ELECIN/ esig_e(max_med),psig_e(max_med), esige_max, psige_m
     *ax, range_ep(0:1,500,max_med), E_array(500,max_med), etae_ms0(500,
     *max_med),etae_ms1(500,max_med),etap_ms0(500,max_med),etap_ms1(500,
     *max_med),q1ce_ms0(500,max_med),q1ce_ms1(500,max_med),q1cp_ms0(500,
     *max_med),q1cp_ms1(500,max_med),q2ce_ms0(500,max_med),q2ce_ms1(500,
     *max_med),q2cp_ms0(500,max_med),q2cp_ms1(500,max_med),blcce0(500,ma
     *x_med),blcce1(500,max_med), EKE0(max_med),EKE1(max_med), XR0(max_m
     *ed),TEFF0(max_med),BLCC(max_med),XCC(max_med), ESIG0(500,max_med),
     *ESIG1(500,max_med),PSIG0(500,max_med),PSIG1(500,max_med),EDEDX0(50
     *0,max_med),EDEDX1(500,max_med),PDEDX0(500,max_med),PDEDX1(500,max_
     *med),EBR10(500,max_med),EBR11(500,max_med),PBR10(500,max_med),PBR1
     *1(500,max_med),PBR20(500,max_med),PBR21(500,max_med),TMXS0(500,max
     *_med),TMXS1(500,max_med), expeke1(max_med), IUNRST(max_med),EPSTFL
     *(max_med),IAPRIM(max_med), sig_ismonotone(0:1,max_med)
      EGS_Float esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E
     *_array,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1
     *,  q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blc
     *ce0,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG
     *0,ESIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR1
     *1,  PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/nist_brems/ nb_fdata(0:50,100,max_med), nb_xdata(0:50,100,m
     *ax_med), nb_wdata(50,100,max_med), nb_idata(50,100,max_med), nb_em
     *in(max_med),nb_emax(max_med), nb_lemin(max_med),nb_lemax(max_med),
     * nb_dle(max_med),nb_dlei(max_med), log_ap(max_med)
      EGS_Float nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_l
     *emax, nb_dle,nb_dlei,log_ap
      integer*4 nb_idata
      common/spin_data/ spin_rej(max_med,0:1,0: 31,0:15,0:31), espin_min
     *,espin_max,espml,b2spin_min,b2spin_max, dbeta2,dbeta2i,dlener,dlen
     *eri,dqq1,dqq1i, fool_intel_optimizer
      real*4 spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max, d
     *beta2,dbeta2i,dlener,dleneri,dqq1,dqq1i
      logical fool_intel_optimizer
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      DO 6171 i=1,len(tmp_string)
        tmp_string(i:i) = ' '
6171  CONTINUE
6172  CONTINUE
      tmp_string = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      IF (( ibr_nist .EQ. 1 )) THEN
        DO 6181 i=1,len(tmp1_string)
          tmp1_string(i:i) = ' '
6181    CONTINUE
6182    CONTINUE
        tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'nist_brems.da
     *ta'
        inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
        IF (( .NOT.ex )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'EGSnrc data file ','nist_brems.data',' does no
     *t exist'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF (( .NOT.is_opened )) THEN
          i_nist_data=egs_get_unit(i_nist_data)
          IF ((i_nist_data.LT.0)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'failed to get a free Fortran I/O unit for da
     *ta file ', tmp1_string(:lnblnk1(tmp1_string))
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(i_nist_data,file=tmp1_string,status='old',err=1070)
        ELSE
          i_nist_data = itmp
        END IF
      ELSE IF((ibr_nist .EQ. 2)) THEN
        DO 6191 i=1,len(tmp1_string)
          tmp1_string(i:i) = ' '
6191    CONTINUE
6192    CONTINUE
        tmp1_string = tmp_string(:lnblnk1(tmp_string)) // 'nrc_brems.dat
     *a'
        inquire(file=tmp1_string,exist=ex,opened=is_opened,number=itmp)
        IF (( .NOT.ex )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'EGSnrc data file ','nrc_brems.data',' does not
     * exist'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF (( .NOT.is_opened )) THEN
          i_nist_data=egs_get_unit(i_nist_data)
          IF ((i_nist_data.LT.0)) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'failed to get a free Fortran I/O unit for da
     *ta file ', tmp1_string(:lnblnk1(tmp1_string))
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          open(i_nist_data,file=tmp1_string,status='old',err=1070)
        ELSE
          i_nist_data = itmp
        END IF
      ELSE
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' init_nist_brems: unknown value of ibr_nist!
     *                  ibr_nist = ', ibr_nist
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      rewind(i_nist_data)
      read(i_nist_data,*)
      read(i_nist_data,*) nmix,kmix
      IF ((kmix .GT. 54)) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' init_nist_brems: to many k values in data file!
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF ((nmix .GT. 57)) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) ' init_nist_brems: to many T values in data file!
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      read(i_nist_data,*) (energy_array(n),n=1,nmix)
      DO 6201 n=1,nmix
        energy_array(n) = 1.0*energy_array(n)
6201  CONTINUE
6202  CONTINUE
      read(i_nist_data,*) (x_array(k),k=1,kmix)
      read(i_nist_data,*)
      DO 6211 i=1,100
        read(i_nist_data,*) ((cs_array(n,k,i),n=1,nmix),k=1,kmix)
6211  CONTINUE
6212  CONTINUE
      close(i_nist_data)
      DO 6221 k=1,kmix
        xi_array(k)=Log(1-x_array(k)+1e-6)
        IF (( fool_intel_optimizer )) THEN
          write(i_log,*) 'xi_array(k): ',xi_array(k)
        END IF
6221  CONTINUE
6222  CONTINUE
      ngauss = 64
      call gauss_legendre(0d0,1d0,x_gauss,w_gauss,ngauss)
      write(i_log,*) ' '
      IF ((ibr_nist .EQ. 1)) THEN
        write(i_log,*) 'Using NIST brems cross sections! '
      ELSE IF((ibr_nist .EQ. 2)) THEN
        write(i_log,*) 'Using NRC brems cross sections! '
      END IF
      write(i_log,*) ' '
      DO 6231 medium=1,nmed
        log_ap(medium) = log(ap(medium))
        write(i_log,*) ' Initializing brems data for medium ',medium,'..
     *.'
        emin = max(ae(medium) - rm, ap(medium))
        DO 6241 i=1,nmix
          IF((energy_array(i) .GE. emin))GO TO6242
6241    CONTINUE
6242    CONTINUE
        ifirst = i
        DO 6251 i=nmix,1,-1
          IF((energy_array(i) .LT. ue(medium) - rm))GO TO6252
6251    CONTINUE
6252    CONTINUE
        ilast = i+1
        IF (( ifirst .LT. 1 .OR. ilast .GT. nmix )) THEN
          write(i_log,*) ' init_nist_brems: data available only for '
          write(i_log,*) energy_array(1),' <= E <= ',energy_array(nmix)
          write(i_log,*) ' will use spline interpolations to get cross '
          write(i_log,*) ' sections beyond the available data but this m
     *ay'
          write(i_log,*) ' produce nonsense!'
          IF((ifirst .LT. 1))ifirst=1
          IF((ilast .GT. nmix))ilast = nmix
        END IF
        DO 6261 i=ifirst,ilast
          ii = i+1 - ifirst
          ee(ii) = energy_array(i)
          ele(ii) = log(ee(ii))
          sumA = 0
          DO 6271 j=1,NNE(medium)
            sumA = sumA + pz(medium,j)*wa(medium,j)
6271      CONTINUE
6272      CONTINUE
          sumA = sumA*amu
          DO 6281 k=1,kmix
            cs(ii,k) = 0
            DO 6291 j=1,NNE(medium)
              Z = zelem(medium,j)
              iz = int(Z+0.1)
              Z = Z*Z/sumA
              cs(ii,k) = cs(ii,k) + pz(medium,j)*Z*cs_array(i,k,iz)
6291        CONTINUE
6292        CONTINUE
            csx(k) = Log(cs(ii,k))
6281      CONTINUE
6282      CONTINUE
          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix)
          cse(ii) = 0
          aux = Log(ee(ii)/ap(medium))
          DO 6301 i_gauss=1,ngauss
            xi = log(1 - ap(medium)/ee(ii)*exp(x_gauss(i_gauss)*aux)+1e-
     *      6)
            res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix)
            cse(ii) = cse(ii) + w_gauss(i_gauss)*exp(res)
6301      CONTINUE
6302      CONTINUE
6261    CONTINUE
6262    CONTINUE
        nener = ilast - ifirst + 1
        call set_spline(ele,cse,afe,bfe,cfe,dfe,nener)
        neke = meke(medium)
        sigee = 1E-15
        sigep = 1E-15
        DO 6311 i=1,neke
          eil = (float(i) - eke0(medium))/eke1(medium)
          ei = exp(eil)
          leil = i
          beta2 = ei*(ei+2*rm)/(ei+rm)**2
          IF (( ei .LE. ap(medium) )) THEN
            sigb = 1e-30
          ELSE
            sigb = spline(eil,ele,afe,bfe,cfe,dfe,nener)
            sigb = sigb*log(ei/ap(medium))/beta2*rho(medium)
          END IF
          sigt=esig1(Leil,MEDIUM)*eil+esig0(Leil,MEDIUM)
          ebr1=ebr11(Leil,MEDIUM)*eil+ebr10(Leil,MEDIUM)
          IF((sigt .LT. 0))sigt = 0
          IF((ebr1 .GT. 1))ebr1 = 1
          IF((ebr1 .LT. 0))ebr1 = 0
          IF (( i .GT. 1 )) THEN
            si_esig = si1_esig
            si_ebr1 = si1_ebr1
            si1_esig = sigt*(1 - ebr1) + sigb
            si1_ebr1 = sigb/si1_esig
            esig1(i-1,medium) = (si1_esig - si_esig)*eke1(medium)
            esig0(i-1,medium) = si1_esig - esig1(i-1,medium)*eil
            ebr11(i-1,medium) = (si1_ebr1 - si_ebr1)*eke1(medium)
            ebr10(i-1,medium) = si1_ebr1 - ebr11(i-1,medium)*eil
          ELSE
            si1_esig = sigt*(1 - ebr1) + sigb
            si1_ebr1 = sigb/si1_esig
          END IF
          sigt=psig1(Leil,MEDIUM)*eil+psig0(Leil,MEDIUM)
          ebr1=pbr11(Leil,MEDIUM)*eil+pbr10(Leil,MEDIUM)
          ebr2=pbr21(Leil,MEDIUM)*eil+pbr20(Leil,MEDIUM)
          IF((sigt .LT. 0))sigt = 0
          IF((ebr1 .GT. 1))ebr1 = 1
          IF((ebr1 .LT. 0))ebr1 = 0
          IF((ebr2 .GT. 1))ebr2 = 1
          IF((ebr2 .LT. 0))ebr2 = 0
          sig_bhabha = sigt*(ebr2 - ebr1)
          IF((sig_bhabha .LT. 0))sig_bhabha = 0
          IF (( i .GT. 1 )) THEN
            si_psig = si1_psig
            si_pbr1 = si1_pbr1
            si_pbr2 = si1_pbr2
            si1_psig = sigt*(1 - ebr1) + sigb
            si1_pbr1 = sigb/si1_psig
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig
            psig1(i-1,medium) = (si1_psig - si_psig)*eke1(medium)
            psig0(i-1,medium) = si1_psig - psig1(i-1,medium)*eil
            pbr11(i-1,medium) = (si1_pbr1 - si_pbr1)*eke1(medium)
            pbr10(i-1,medium) = si1_pbr1 - pbr11(i-1,medium)*eil
            pbr21(i-1,medium) = (si1_pbr2 - si_pbr2)*eke1(medium)
            pbr20(i-1,medium) = si1_pbr2 - pbr21(i-1,medium)*eil
          ELSE
            si1_psig = sigt*(1 - ebr1) + sigb
            si1_pbr1 = sigb/si1_psig
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig
          END IF
          ededx=ededx1(Leil,MEDIUM)*eil+ededx0(Leil,MEDIUM)
          sige = si1_esig/ededx
          IF((sige .GT. sigee))sigee = sige
          ededx=pdedx1(Leil,MEDIUM)*eil+pdedx0(Leil,MEDIUM)
          sige = si1_psig/ededx
          IF((sige .GT. sigep))sigep = sige
6311    CONTINUE
6312    CONTINUE
        esig1(neke,medium) = esig1(neke-1,medium)
        esig0(neke,medium) = esig0(neke-1,medium)
        ebr11(neke,medium) = ebr11(neke-1,medium)
        ebr10(neke,medium) = ebr10(neke-1,medium)
        psig1(neke,medium) = psig1(neke-1,medium)
        psig0(neke,medium) = psig0(neke-1,medium)
        pbr11(neke,medium) = pbr11(neke-1,medium)
        pbr10(neke,medium) = pbr10(neke-1,medium)
        pbr21(neke,medium) = pbr21(neke-1,medium)
        pbr20(neke,medium) = pbr20(neke-1,medium)
        write(i_log,*) ' Max. new cross sections per energy loss: ',sige
     *  e,sigep
        esig_e(medium) = sigee
        psig_e(medium) = sigep
        IF((sigee .GT. esige_max))esige_max = sigee
        IF((sigep .GT. psige_max))psige_max = sigep
        nb_emin(medium) = energy_array(ifirst)
        IF (( nb_emin(medium) .LE. ap(medium) )) THEN
          nb_emin(medium) = energy_array(ifirst+1)
        END IF
        nb_emax(medium) = energy_array(ilast)
        nb_lemin(medium) = log(nb_emin(medium))
        nb_lemax(medium) = log(nb_emax(medium))
        nb_dle(medium) = (nb_lemax(medium) - nb_lemin(medium))/(100-1)
        nb_dlei(medium) = 1/nb_dle(medium)
        eil = nb_lemin(medium) - nb_dle(medium)
        DO 6321 i=1,100
          eil = eil + nb_dle(medium)
          ei = exp(eil)
          DO 6331 ii=1,nener
            IF((ei .LT. ee(ii)))GO TO6332
6331      CONTINUE
6332      CONTINUE
          ii = ii-1
          IF((ii .LT. 1))ii = 1
          IF((ii .GT. nener-1))ii = nener-1
          ple = (eil - ele(ii))/(ele(ii+1)-ele(ii))
          qle = 1 - ple
          DO 6341 k=1,kmix
            csx(k) = log(qle*cs(ii,k) + ple*cs(ii+1,k))
6341      CONTINUE
6342      CONTINUE
          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix)
          x = ap(medium)/ei
          aux = -log(x)
          xi = log(1 - x+1e-6)
          res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix)
          nb_xdata(0,i,medium) = 0
          nb_fdata(0,i,medium) = exp(res)
          DO 6351 k=1,kmix
            IF((x_array(k) .GT. x))GO TO6352
6351      CONTINUE
6352      CONTINUE
          IF((k .GT. kmix))k = kmix
          ndat = 0
          DO 6361 j=k+1,kmix-1
            ndat = ndat+1
            nb_xdata(ndat,i,medium) = log(x_array(j)/x)/aux
            nb_fdata(ndat,i,medium) = exp(csx(j))
            IF (( fool_intel_optimizer )) THEN
              write(i_log,*) 'nb_xdata(ndat,i,medium): ', nb_xdata(ndat,
     *        i,medium)
            END IF
6361      CONTINUE
6362      CONTINUE
          ndat = ndat+1
          nb_xdata(ndat,i,medium) = 1
          nb_fdata(ndat,i,medium) = exp(csx(kmix))
          IF((ndat .GE. 50))goto 6370
6381      CONTINUE
            x_max_error = 0
            f_max_error = 0
            k_max_error = 0
            max_error = 0
            DO 6391 k=0,ndat-1
              x = 0.5*(nb_xdata(k,i,medium) + nb_xdata(k+1,i,medium))
              f = 0.5*(nb_fdata(k,i,medium) + nb_fdata(k+1,i,medium))
              xi = log(1 - ap(medium)/ei*exp(x*aux)+1e-6)
              res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix)
              res = exp(res)
              error = abs(1-f/res)
              IF (( error .GT. max_error )) THEN
                x_max_error = x
                f_max_error = res
                max_error = error
                k_max_error = k
              END IF
6391        CONTINUE
6392        CONTINUE
            ndat = ndat+1
            DO 6401 k=ndat,k_max_error+2,-1
              nb_xdata(k,i,medium) = nb_xdata(k-1,i,medium)
              nb_fdata(k,i,medium) = nb_fdata(k-1,i,medium)
6401        CONTINUE
6402        CONTINUE
            nb_xdata(k_max_error+1,i,medium) = x_max_error
            nb_fdata(k_max_error+1,i,medium) = f_max_error
            IF(((ndat .EQ. 50)))GO TO6382
          GO TO 6381
6382      CONTINUE
6370      call prepare_alias_table(50,nb_xdata(0,i,medium), nb_fdata(0,i
     *    ,medium),nb_wdata(1,i,medium),nb_idata(1,i,medium))
6321    CONTINUE
6322    CONTINUE
6231  CONTINUE
6232  CONTINUE
      write(i_log,*) ' '
      write(i_log,*) ' '
      return
1070  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'failed to open EGSnrc data file ',tmp1_string(:lnb
     *lnk1(tmp1_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine init_nrc_pair
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/ELECIN/ esig_e(max_med),psig_e(max_med), esige_max, psige_m
     *ax, range_ep(0:1,500,max_med), E_array(500,max_med), etae_ms0(500,
     *max_med),etae_ms1(500,max_med),etap_ms0(500,max_med),etap_ms1(500,
     *max_med),q1ce_ms0(500,max_med),q1ce_ms1(500,max_med),q1cp_ms0(500,
     *max_med),q1cp_ms1(500,max_med),q2ce_ms0(500,max_med),q2ce_ms1(500,
     *max_med),q2cp_ms0(500,max_med),q2cp_ms1(500,max_med),blcce0(500,ma
     *x_med),blcce1(500,max_med), EKE0(max_med),EKE1(max_med), XR0(max_m
     *ed),TEFF0(max_med),BLCC(max_med),XCC(max_med), ESIG0(500,max_med),
     *ESIG1(500,max_med),PSIG0(500,max_med),PSIG1(500,max_med),EDEDX0(50
     *0,max_med),EDEDX1(500,max_med),PDEDX0(500,max_med),PDEDX1(500,max_
     *med),EBR10(500,max_med),EBR11(500,max_med),PBR10(500,max_med),PBR1
     *1(500,max_med),PBR20(500,max_med),PBR21(500,max_med),TMXS0(500,max
     *_med),TMXS1(500,max_med), expeke1(max_med), IUNRST(max_med),EPSTFL
     *(max_med),IAPRIM(max_med), sig_ismonotone(0:1,max_med)
      EGS_Float esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E
     *_array,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1
     *,  q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blc
     *ce0,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG
     *0,ESIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR1
     *1,  PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      common/nrc_pair/ nrcp_fdata(65,84,max_med), nrcp_wdata(65,84,max_m
     *ed), nrcp_idata(65,84,max_med), nrcp_xdata(65), nrcp_emin, nrcp_em
     *ax, nrcp_dle, nrcp_dlei
      EGS_Float nrcp_fdata,nrcp_wdata,nrcp_xdata, nrcp_emin, nrcp_emax,
     *nrcp_dle, nrcp_dlei
      integer*4 nrcp_idata
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      character nrcp_file*256, endianess*4
      integer egs_get_unit
      integer*4 nrcp_unit, want_nrcp_unit, rec_length
      integer*4 i, lnblnk1
      EGS_Float tmp, ddx, xx, Z
      real*4 emin, emax
      integer*4 ne, nb, ix, ie, irec, i_ele, nbb, iz
      character endian, cdum( 243)
      logical swap
      real*4 tmp_4, tarray(65)
      integer*4 itmp_4
      character c_4(4), ic_4(4)
      equivalence (tmp_4,c_4), (itmp_4, ic_4)
      DO 6411 i=1,len(nrcp_file)
        nrcp_file(i:i) = ' '
6411  CONTINUE
6412  CONTINUE
      nrcp_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'pa
     *ir_nrc1.data'
      want_nrcp_unit = 62
      nrcp_unit = egs_get_unit(want_nrcp_unit)
      IF (( nrcp_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'init_nrc_pair: failed to get a free fortran unit
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      rec_length = 65*4
      open(nrcp_unit,file=nrcp_file,form='unformatted',access='direct',
     *status='old',recl=rec_length,err=6420)
      read(nrcp_unit,rec=1,err=6430) emin, emax, ne, nb, endian, cdum
      IF (( ichar(endian) .EQ. 0 )) THEN
        endianess = '1234'
      ELSE
        endianess = '4321'
      END IF
      swap = endianess.ne.'1234'
      IF (( swap )) THEN
        tmp_4 = emin
        call egs_swap_4(c_4)
        emin = tmp_4
        tmp_4 = emax
        call egs_swap_4(c_4)
        emax = tmp_4
        itmp_4 = ne
        call egs_swap_4(ic_4)
        ne = itmp_4
        itmp_4 = nb
        call egs_swap_4(ic_4)
        nb = itmp_4
      END IF
      write(i_log,'(//a,a)') 'Reading NRC pair data base from ',nrcp_fil
     *e(:lnblnk1(nrcp_file))
      write(i_log,'(a,a,a)') 'Data generated on a machine with ',endiane
     *ss,' endianess'
      write(i_log,'(a,a)') 'The endianess of this CPU is ','1234'
      IF (( swap )) THEN
        write(i_log,'(a)') '=> will need to do byte swaping'
      END IF
      write(i_log,'(a,2f9.3)') 'Energy range of the data: ',emin,emax
      IF (( nb .NE. 65 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Inconsistent x-grid size'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( ne .NE. 84 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Inconsistent energy grid size'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      nrcp_emin = emin
      nrcp_emax = emax
      nrcp_dle = log((emax-2)/(emin-2))/(ne-1)
      nrcp_dlei = 1/nrcp_dle
      nbb = nb/2
      ddx = sqrt(0.5)/nbb
      DO 6441 ix=0,nbb
        xx = ddx*ix
        nrcp_xdata(ix+1) = xx*xx
6441  CONTINUE
6442  CONTINUE
      do ix=nbb-1,0,-1
        xx = ddx*ix
        nrcp_xdata(nb-ix) = 1 - xx*xx
      end do
      DO 6461 medium=1,NMED
        write(i_log,'(a,i4,a,$)') '  medium ',medium,' .................
     *.... '
        DO 6471 ie=1,84
          DO 6481 ix=1,65
            nrcp_fdata(ix,ie,medium) = 0
6481      CONTINUE
6482      CONTINUE
6471    CONTINUE
6472    CONTINUE
        DO 6491 i_ele=1,NNE(medium)
          Z = ZELEM(medium,i_ele)
          iz = int(Z+0.5)
          tmp = PZ(medium,i_ele)*Z*Z
          irec = (iz-1)*ne + 2
          DO 6501 ie=1,84
            read(nrcp_unit,rec=irec,err=6430) tarray
            DO 6511 ix=1,65
              tmp_4 = tarray(ix)
              IF (( swap )) THEN
                call egs_swap_4(c_4)
              END IF
              nrcp_fdata(ix,ie,medium)=nrcp_fdata(ix,ie,medium)+tmp*tmp_
     *        4
6511        CONTINUE
6512        CONTINUE
            irec = irec + 1
6501      CONTINUE
6502      CONTINUE
6491    CONTINUE
6492    CONTINUE
        DO 6521 ie=1,84
          call prepare_alias_table(nb-1,nrcp_xdata,nrcp_fdata(1,ie,mediu
     *    m), nrcp_wdata(1,ie,medium),nrcp_idata(1,ie,medium))
6521    CONTINUE
6522    CONTINUE
        write(i_log,'(a)') ' done'
6461  CONTINUE
6462  CONTINUE
      write(i_log,*) ' '
      close(nrcp_unit)
      return
6420  CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Failed to open NRC pair data file'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
6430  CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'I/O error while reading NRC pair data file'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      subroutine vmc_electron(ircode)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 ircode
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(//a//)') ' ********* VMC Transport option not in thi
     *s distribution ****** '
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      end
      subroutine egs_init_default_rng
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      return
      end
      subroutine egs_init_rng(arg1,arg2)
      integer*4 arg1,arg2
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'The INITIALIZE RNG USING macro should not be used
     *with the C++ interface!'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_get_rndm(ran)
      EGS_Float ran
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      IF (( rng_seed .GT. 128 )) THEN
        rng_seed = 128
        call egs_fill_rndm_array(rng_seed,rng_array)
        rng_seed = 1
      END IF
      ran = rng_array(rng_seed)
      rng_seed = rng_seed + 1
      return
      end
      subroutine egs_get_rndm_array(n,rarray)
      integer*4 n
      EGS_Float rarray(*)
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      EGS_Float rtmp
      integer*4 i
      IF((n .LT. 1))return
      DO 6531 i=1,n
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        rtmp = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        rarray(i) = rtmp
6531  CONTINUE
6532  CONTINUE
      return
      end
      subroutine eii_init
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100)
      EGS_Float binding_energies, interaction_prob, relaxation_prob, edg
     *e_energies, edge_a,edge_b,edge_c,edge_d
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(max_med), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(4
     *0),  eii_sh(40),  eii_nshells(100),  eii_nsh(max_med),  eii_first(
     *max_med,50),  eii_no(max_med,50)
      EGS_Float eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L
     *_factor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_nsh
      COMMON/ELECIN/ esig_e(max_med),psig_e(max_med), esige_max, psige_m
     *ax, range_ep(0:1,500,max_med), E_array(500,max_med), etae_ms0(500,
     *max_med),etae_ms1(500,max_med),etap_ms0(500,max_med),etap_ms1(500,
     *max_med),q1ce_ms0(500,max_med),q1ce_ms1(500,max_med),q1cp_ms0(500,
     *max_med),q1cp_ms1(500,max_med),q2ce_ms0(500,max_med),q2ce_ms1(500,
     *max_med),q2cp_ms0(500,max_med),q2cp_ms1(500,max_med),blcce0(500,ma
     *x_med),blcce1(500,max_med), EKE0(max_med),EKE1(max_med), XR0(max_m
     *ed),TEFF0(max_med),BLCC(max_med),XCC(max_med), ESIG0(500,max_med),
     *ESIG1(500,max_med),PSIG0(500,max_med),PSIG1(500,max_med),EDEDX0(50
     *0,max_med),EDEDX1(500,max_med),PDEDX0(500,max_med),PDEDX1(500,max_
     *med),EBR10(500,max_med),EBR11(500,max_med),PBR10(500,max_med),PBR1
     *1(500,max_med),PBR20(500,max_med),PBR21(500,max_med),TMXS0(500,max
     *_med),TMXS1(500,max_med), expeke1(max_med), IUNRST(max_med),EPSTFL
     *(max_med),IAPRIM(max_med), sig_ismonotone(0:1,max_med)
      EGS_Float esig_e,   psig_e,   esige_max,  psige_max,  range_ep,  E
     *_array,  etae_ms0,etae_ms1,  etap_ms0,etap_ms1,  q1ce_ms0,q1ce_ms1
     *,  q1cp_ms0,q1cp_ms1,  q2ce_ms0,q2ce_ms1,  q2cp_ms0,q2cp_ms1,  blc
     *ce0,blcce1,   expeke1,  EKE0,EKE1, XR0,  TEFF0,  BLCC,  XCC,  ESIG
     *0,ESIG1,  PSIG0,PSIG1,  EDEDX0,EDEDX1,  PDEDX0,PDEDX1,  EBR10,EBR1
     *1,  PBR10,PBR11,  PBR20,PBR21,  TMXS0,TMXS1
      integer*4 IUNRST,  EPSTFL,  IAPRIM
      logical sig_ismonotone
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      integer*4 imed,iele,ish,nsh,iZ,j,i,itmp,nskip,nbin,ii,nsh_tot,iii,
     *k
      integer*4 jj,jjj
      integer*4 lnblnk1
      integer*4 tmp_array(100)
      integer*4 want_eii_unit,eii_unit,eii_out,egs_open_file
      integer egs_get_unit
      EGS_Float e_eii_min,emax,fmax,aux_array(250)
      EGS_Float sigo,loge,tau,beta2,p2,uwm,Wmax
      EGS_Float ss_0, ss_1, sh_0, sh_1, aux, av_e, con_med, dedx_old, si
     *gm_old
      EGS_Float dedx,e,sig,sigm,wbrem,sum_a,sum_z,sum_pz,sum_wa,Ec,Ecc
      EGS_Float sum_sh,sum_occn,U,sum_sigma,sum_dedx
      EGS_Float sigma,sigma_old,wbrem_old,sig_j,de
      integer*4 lloge
      logical check_it,is_monotone,getd
      EGS_Float sigma_max
      character eii_file*128
      character*512 toUpper
      integer*4 occn_numbers(4)
      EGS_Float cons
      parameter (cons = 0.153536)
      data occn_numbers/2,2,2,4/
      DO 6541 j=1,100
        eii_nshells(j) = 0
6541  CONTINUE
6542  CONTINUE
      DO 6551 j=1,max_med
        eii_nsh(j) = 0
6551  CONTINUE
6552  CONTINUE
      IF (( eii_flag .EQ. 0 )) THEN
        return
      END IF
      getd = (iedgfl.gt.0.and.iedgfl.le.100)
      IF (( .NOT.getd )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(/a,/a,/a,/a)') ' In subroutine eii_init: ', '   Sc
     *attering off bound electrons creates atomic vacancies,', '   poten
     *tially starting an atomic relaxation cascade. ', '   Please turn O
     *N atomic relaxations.'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      e_eii_min = 1e30
      DO 6561 imed=1,nmed
        IF((ae(imed)-rm .LT. e_eii_min))e_eii_min = ae(imed) - rm
        IF((ap(imed) .LT. e_eii_min))e_eii_min = ap(imed)
6561  CONTINUE
6562  CONTINUE
      write(i_log,*) ' '
      write(i_log,*) 'eii_init: minimum threshold energy found: ',e_eii_
     *min
      DO 6571 imed=1,nmed
        DO 6581 iele=1,nne(imed)
          iZ = int(zelem(imed,iele)+0.5)
          IF (( eii_nshells(iZ) .EQ. 0 )) THEN
            nsh = 0
            DO 6591 ish=1,4
              IF((binding_energies(ish,iZ) .GT. e_eii_min))nsh = nsh+1
6591        CONTINUE
6592        CONTINUE
            eii_nshells(iZ) = nsh
          END IF
6581    CONTINUE
6582    CONTINUE
6571  CONTINUE
6572  CONTINUE
      nsh = 0
      DO 6601 iZ=1,100
        nsh = nsh + eii_nshells(iZ)
6601  CONTINUE
6602  CONTINUE
      IF (( nsh .EQ. 0 )) THEN
        write(i_log,*) '*** EII requested but no shells with binding ene
     *rgies '
        write(i_log,*) '    above the specified threshold found'
        write(i_log,*) '    => turning off EII'
        eii_flag = 0
      END IF
      IF (( nsh .GT. 40 )) THEN
        write(i_log,*) '*** Number of shells with binding energies great
     *er than '
        write(i_log,*) '    the specified thresholds is ',nsh
        write(i_log,*) '    This is more than the allocated arrays can h
     *old'
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) '    Increase the macro $MAX_EII_SHELLS and retry
     *'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      write(i_log,*) 'eii_init: number of shells to simulate EII: ',nsh
      nsh_tot = nsh
      tmp_array(1) = 0
      DO 6611 j=2,100
        tmp_array(j) = tmp_array(j-1) + eii_nshells(j-1)
6611  CONTINUE
6612  CONTINUE
      DO 6621 imed=1,nmed
        nsh = 0
        DO 6631 iele=1,nne(imed)
          iZ = int(zelem(imed,iele)+0.5)
          eii_no(imed,iele) = eii_nshells(iZ)
          nsh = nsh + eii_nshells(iZ)
          IF (( eii_nshells(iZ) .GT. 0 )) THEN
            eii_first(imed,iele) = tmp_array(iZ) + 1
          ELSE
            eii_first(imed,iele) = 0
          END IF
6631    CONTINUE
6632    CONTINUE
        eii_nsh(imed) = nsh
6621  CONTINUE
6622  CONTINUE
      DO 6641 i=1,len(eii_file)
        eii_file(i:i) = ' '
6641  CONTINUE
6642  CONTINUE
      eii_file = hen_house(:lnblnk1(hen_house)) // 'data' // '/' // 'eii
     *_'// eii_xfile(:lnblnk1(eii_xfile)) //'.data'
      want_eii_unit = 62
      eii_unit = egs_get_unit(want_eii_unit)
      IF (( eii_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'eii_init: failed to get a free Fortran I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      open(eii_unit,file=eii_file(:lnblnk1(eii_file)),status='old',err=6
     *650)
      write(i_log,'(//a,a)') 'Opened EII data file ',eii_file(:lnblnk1(e
     *ii_file))
      write(i_log,'(a,$)') ' eii_init: reading EII data ... '
      read(eii_unit,*,err=6660,end=6660) nskip
      DO 6671 j=1,nskip
        read(eii_unit,*,err=6660,end=6660)
6671  CONTINUE
6672  CONTINUE
      read(eii_unit,*,err=6660,end=6660) emax,nbin
      IF (( nbin .NE. 250 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'Inconsistent EII data file'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF ((xsec_out .EQ. 1)) THEN
        eii_out = egs_open_file(93,0,1,'.eiixsec')
      END IF
      ii = 0
      DO 6681 j=1,100
        read(eii_unit,*,err=6660,end=6660) iZ,nsh
        IF ((xsec_out .EQ. 1 .AND. eii_nshells(iZ) .GT. 0)) THEN
          write(eii_out,*) '================================='
          write(eii_out,'(a,i3)') 'EII xsections for element Z = ',iZ
          write(eii_out,*) '================================='
        END IF
        IF (( nsh .LT. eii_nshells(iZ) )) THEN
          write(i_log,*) 'EII data file has data for ',nsh,' shells for
     *element '
          write(i_log,*) iZ,' but according'
          write(i_log,*) 'to binding energies and thresholds ',eii_nshel
     *    ls(iZ)
          write(i_log,*) 'shells are required'
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'This is a fatal error.'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        DO 6691 ish=1,nsh
          read(eii_unit,*,err=6660,end=6660) fmax
          read(eii_unit,*,err=6660,end=6660) aux_array
          IF ((ish.GT.1 .AND. ish .LT. 5)) THEN
            fmax = fmax*eii_L_factor
          END IF
          IF (( ish .LE. eii_nshells(iZ) )) THEN
            IF ((xsec_out .EQ. 1)) THEN
              IF ((ish .EQ. 1)) THEN
                write(eii_out,'(a,f10.2,a)') 'K-shell sigma_max = ',fmax
     *          ,' b/atom'
              ELSE IF((ish .EQ. 2)) THEN
                write(eii_out,'(a,f9.2,a)') '=> LI-shell sigma_max = ',f
     *          max,' b/atom'
              ELSE IF((ish .EQ. 3)) THEN
                write(eii_out,'(a,f8.2,a)') '=> LII-shell sigma_max = ',
     *          fmax,' b/atom'
              ELSE IF((ish .EQ. 4)) THEN
                write(eii_out,'(a,f8.2,a)') '=> LIII-shell sigma_max = '
     *          ,fmax,' b/atom'
              ELSE
                write(eii_out,*) '=> Wrong number of shells!'
              END IF
              write(eii_out,*) '   E/keV     sigma/(b/atom)'
              write(eii_out,*) '---------------------------'
            END IF
            ii = ii+1
            eii_z(ii) = iZ
            eii_sh(ii) = ish
            eii_a(ii) = nbin
            eii_a(ii) = eii_a(ii)/log(emax/binding_energies(ish,iZ))
            eii_b(ii) = 1 - eii_a(ii)*log(binding_energies(ish,iZ))
            DO 6701 k=1,nbin
              IF (( k .GT. 1 )) THEN
                sigo = fmax*aux_array(k-1)
              ELSE
                sigo = 0
              END IF
              loge = (k - eii_b(ii))/eii_a(ii)
              iii = nbin*(ii-1)+k
              eii_xsection_a(iii) = (fmax*aux_array(k)-sigo)*eii_a(ii)
              eii_xsection_b(iii) = sigo - eii_xsection_a(iii)*loge
              IF ((xsec_out .EQ. 1)) THEN
                write(eii_out,'(f12.2,2X,10f9.2)') Exp((k+1-eii_b(ii))/e
     *          ii_a(ii))*1000.0,fmax*aux_array(k)
              END IF
6701        CONTINUE
6702        CONTINUE
          END IF
6691    CONTINUE
6692    CONTINUE
        IF (( ii .EQ. nsh_tot )) THEN
          GO TO6682
        END IF
6681  CONTINUE
6682  CONTINUE
      close(eii_unit)
      IF ((xsec_out .EQ. 1)) THEN
        close(eii_out)
      END IF
      write(i_log,*) ' OK '
      write(i_log,*) ' '
      DO 6711 imed=1,nmed
        Ec = ae(imed) - rm
        Ecc = min(Ec,ap(imed))
        sum_z=0
        sum_pz=0
        sum_a=0
        sum_wa=0
        DO 6721 iele=1,nne(imed)
          sum_z = sum_z + pz(imed,iele)*zelem(imed,iele)
          sum_pz = sum_pz + pz(imed,iele)
          sum_wa = sum_wa + rhoz(imed,iele)
          sum_a = sum_a + pz(imed,iele)*wa(imed,iele)
6721    CONTINUE
6722    CONTINUE
        con_med = rho(imed)/1.6605655/sum_a
        eii_cons(imed) = con_med
        IF (( eii_nsh(imed) .GT. 0 )) THEN
          is_monotone = .true.
          sigma_max = 0
          DO 6731 j=1,meke(imed)
            loge = (j - eke0(imed))/eke1(imed)
            e = Exp(loge)
            tau = e/rm
            beta2 = tau*(tau+2)/(tau+1)**2
            p2 = 2*rm*tau*(tau+2)
            lloge = j
            medium = imed
            dedx=ededx1(Lloge,MEDIUM)*loge+ededx0(Lloge,MEDIUM)
            IF (( e .GT. ap(medium) .OR. e .GT. 2*Ec )) THEN
              sig=esig1(Lloge,MEDIUM)*loge+esig0(Lloge,MEDIUM)
            ELSE
              sig = 0
            END IF
            IF (( e .GT. 2*Ec )) THEN
              wbrem=ebr11(Lloge,MEDIUM)*loge+ebr10(Lloge,MEDIUM)
              sigm = sig*(1-wbrem)
            ELSE
              sigm = 0
              wbrem = 1
            END IF
            sum_occn=0
            sum_sigma=0
            sum_dedx=0
            DO 6741 iele=1,nne(imed)
              iZ = int(zelem(imed,iele)+0.5)
              sum_sh = 0
              DO 6751 ish=1,eii_no(imed,iele)
                jj = eii_first(imed,iele) + ish - 1
                jjj = eii_sh(jj)
                U = binding_energies(jjj,iZ)
                Wmax = (e+U)/2
                uwm = U/Wmax
                IF (( U .LT. e .AND. U .GT. Ecc )) THEN
                  sum_sh = sum_sh + occn_numbers(jjj)
                  ss_0 = 2*(log(p2/U)-uwm**3*log(p2/Wmax)- (beta2+0.8333
     *            33)*(1-uwm**3))/3/U
                  sh_0 = ((1-uwm)*(1+uwm/(2-uwm))+U*(Wmax-U)/(e+rm)**2 -
     *             (2*tau+1)/(tau+1)**2*uwm/2*log((2-uwm)/uwm))/U
                  ss_1 = log(p2/U)-uwm**2*log(p2/Wmax)- (beta2+1)*(1-uwm
     *            **2)
                  sh_1 = log(Wmax/U/(2-uwm))+2*(Wmax-U)/(2*Wmax-U) +(Wma
     *            x**2-U**2)/(e+rm)**2/2 -(2*tau+1)/(tau+1)**2*log((2*Wm
     *            ax-U)/Wmax)
                  av_E = (ss_1 + sh_1)/(ss_0 + sh_0)
                  i = eii_a(jjj)*loge + eii_b(jjj)
                  i = (jj-1)*250 + i
                  sig_j = eii_xsection_a(i)*loge + eii_xsection_b(i)
                  sig_j = sig_j*pz(imed,iele)*con_med
                  sum_sigma = sum_sigma + sig_j
                  sum_dedx = sum_dedx + sig_j*av_E
                END IF
6751          CONTINUE
6752          CONTINUE
              sum_occn = sum_occn + sum_sh*pz(imed,iele)
6741        CONTINUE
6742        CONTINUE
            sigm = sigm + sum_sigma
            dedx = dedx - sum_dedx
            aux = Ec/e
            IF (( e .GT. 2*Ec )) THEN
              sigo = cons*sum_occn*rho(imed)/(beta2*Ec)*( (1-2*aux)*(1+a
     *        ux/(1-aux)+(tau/(tau+1))**2*aux/2)- (2*tau+1)/(tau+1)**2*a
     *        ux*log((1-aux)/aux))/sum_a
              de = cons*sum_occn*rho(imed)/beta2*( log(0.25/aux/(1-aux))
     *        +(1-2*aux)/(1-aux)+ (tau/(tau+1))**2*(1-4*aux*aux)/8- (2*t
     *        au+1)/(tau+1)**2*log(2*(1-aux)))/sum_a
              sigm = sigm - sigo
              dedx = dedx + de
            END IF
            sigma = sigm + wbrem*sig
            IF((sigma/dedx .GT. sigma_max))sigma_max = sigma/dedx
            IF (( sigma .GT. 0 )) THEN
              wbrem = wbrem*sig/sigma
            ELSE
              wbrem = 1
            END IF
            IF (( j .GT. 1 )) THEN
              ededx1(j-1,imed) = (dedx - dedx_old)*eke1(imed)
              ededx0(j-1,imed) = dedx - ededx1(j-1,imed)*loge
              esig1(j-1,imed) = (sigma - sigma_old)*eke1(imed)
              esig0(j-1,imed) = sigma - esig1(j-1,imed)*loge
              ebr11(j-1,imed) = (wbrem - wbrem_old)*eke1(imed)
              ebr10(j-1,imed) = wbrem - ebr11(j-1,imed)*loge
              IF((sigma/dedx .LT. sigma_old/dedx_old))is_monotone = .fal
     *        se.
            END IF
            dedx_old = dedx
            sigm_old = sigm
            sigma_old = sigma
            wbrem_old = wbrem
6731      CONTINUE
6732      CONTINUE
          ededx1(meke(imed),imed) = ededx1(meke(imed)-1,imed)
          ededx0(meke(imed),imed) = ededx0(meke(imed)-1,imed)
          esig1(meke(imed),imed) = esig1(meke(imed)-1,imed)
          esig0(meke(imed),imed) = esig0(meke(imed)-1,imed)
          ebr11(meke(imed),imed) = ebr11(meke(imed)-1,imed)
          ebr10(meke(imed),imed) = ebr10(meke(imed)-1,imed)
          write(i_log,*) 'eii_init: for medium ',imed,' adjusted sige =
     *', sigma_max,' monotone = ',is_monotone
          sig_ismonotone(0,imed) = is_monotone
          esig_e(imed) = sigma_max
        END IF
6711  CONTINUE
6712  CONTINUE
      return
6660  write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'I/O error while reading EII data'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
6650  write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(//a,a,/a,/a/)') 'Failed to open EII data file ',eii_
     *file(:lnblnk1(eii_file)), 'Make sure file exists in your $HEN_HOUS
     *E/data directory!', '****BEWARE of case sensitive file names!!!'
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine eii_sample(ish,iZ,Uj)
      implicit none
      integer*4 ish,iZ
      EGS_Float Uj
      integer max_med
      parameter (max_med = MXMED)
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/eii_data/ eii_xsection_a( 10000),  eii_xsection_b( 10000),
     * eii_cons(max_med), eii_a(40),  eii_b(40),  eii_L_factor,  eii_z(4
     *0),  eii_sh(40),  eii_nshells(100),  eii_nsh(max_med),  eii_first(
     *max_med,50),  eii_no(max_med,50)
      EGS_Float eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L
     *_factor
      integer*4 eii_z,eii_sh,eii_nshells
      integer*4 eii_first,eii_no
      integer*4 eii_elements,eii_nsh
      common/egs_vr/ e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_
     *RR, i_survived_RR, n_RR_warning, i_do_rr
      EGS_Float e_max_rr,e_max_rr_new,prob_RR
      integer*4 nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI, COSPHI,PI,TWOPI,PI5D2
      EGS_Float THETA,  SINTHE,  COSTHE,  SINPHI,  COSPHI,  PI,TWOPI,PI5
     *D2
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/relax_data/ relax_first(3000),  relax_ntran(3000),  relax_s
     *tate(10000),  relax_prob(10000),  relax_atbin(10000),  relax_ntot
      EGS_Float relax_prob
      integer*4 relax_first, relax_ntran, relax_state, relax_atbin, rela
     *x_ntot
      EGS_Float T,tau,tau1,tau12,tau2,p2,beta2,c1,c2,Wmax,xmax,fm_s,fm_h
     *,prob_s,prob
      EGS_Float r1,r2,r3,wx,wxx,aux,frej
      real*8 peie,pese1,pese2,dcosth,h1
      integer*4 iarg
      EGS_Float eta,cphi,sphi
      integer*4 np_save,ip,j
      EGS_Float xphi,xphi2,yphi,yphi2,rhophi2
      peie = e(np)
      T = peie - rm
      tau = T/rm
      tau1 = tau+1
      tau12 = tau1*tau1
      tau2 = tau*tau
      p2 = tau2 + 2*tau
      beta2 = p2/tau12
      Wmax = 0.5*(T+Uj)
      xmax = Uj/Wmax
      c1 = (Wmax/peie)**2
      c2 = (2*tau+1)/tau12
      fm_s = log(rmt2*p2/Uj) - beta2 - 0.5
      prob_s = 0.66666667*fm_s*(1+xmax+xmax*xmax)
      fm_h = 2 + c1 - c2
      IF((fm_h .LT. 1))fm_h = 1
      prob = fm_h + prob_s
6761  CONTINUE
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        r1 = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        r2 = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        r3 = rng_array(rng_seed)
        rng_seed = rng_seed + 1
        IF (( r1*prob .LT. fm_h )) THEN
          wx = 1/(r2*xmax+1-r2)
          wxx = wx*xmax
          aux = wxx/(2-wxx)
          frej = (1 + aux*(aux-c2)+c1*wxx*wxx)/fm_h
        ELSE
          wx = 1/(r2*xmax**3+1-r2)**0.333333333
          frej = 1 - log(wx)/fm_s
        END IF
        IF((( r3 .LT. frej )))GO TO6762
      GO TO 6761
6762  CONTINUE
      wx = wx*Uj
      h1 = (peie + prm)/T
      pese1 = peie - wx
      e(np) = pese1
      dcosth = h1*(pese1-prm)/(pese1+prm)
      sinthe = dsqrt(1-dcosth)
      costhe = dsqrt(dcosth)
      call uphi(2,1)
      pese2 = wx - Uj + prm
      edep_local = 0
      IF (( pese2 .GT. ae(medium) )) THEN
        IF (( np+1 .GT. max_stack )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(//,3a,/,2(a,i9))') ' In subroutine ','eii_sample
     *', ' stack size exceeded! ',' $MAXSTACK = ',max_stack,' np = ',np+
     *    1
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        np = np+1
        e(np) = pese2
        dcosth = h1*(pese2-prm)/(pese2+prm)
        sinthe = -dsqrt(1-dcosth)
        costhe = dsqrt(dcosth)
        iq(np) = -1
        call uphi(3,2)
        edep = 0
      ELSE
        edep = wx - Uj
        edep_local = edep
        iarg=34
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          call egs_ausgab(iarg)
        END IF
      END IF
      call relax(Uj,ish,iZ)
      IF (( edep .GT. 0 )) THEN
        iarg=4
        IF ((IAUSFL(IARG+1).NE.0)) THEN
          call egs_ausgab(iarg)
        END IF
      END IF
      return
      end
      subroutine egs_scale_photon_xsection(imed,fac,which)
      implicit none
      integer*4 imed,which
      EGS_Float fac
      integer max_med
      parameter (max_med = MXMED)
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(max_med), GE0(max_med),GE1(max_med), GMFP0(2
     *000,max_med),GMFP1(2000,max_med),GBR10(2000,max_med),GBR11(2000,ma
     *x_med),GBR20(2000,max_med),GBR21(2000,max_med), RCO0(max_med),RCO1
     *(max_med), RSCT0(100,max_med),RSCT1(100,max_med), COHE0(2000,max_m
     *ed),COHE1(2000,max_med),  PHOTONUC0(2000,max_med),PHOTONUC1(2000,m
     *ax_med), DPMFP, MPGEM(1,max_med), NGR(max_med)
      EGS_Float EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR
     *21,  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,
     *  DPMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      integer*4 ifirst,ilast,medium,j
      logical has_r
      EGS_Float gle,gmfp,gbr1,gbr2,cohfac,aux,gmfp_old,gbr1_old,gbr2_old
     *,cohfac_old
      character*8 strings(5)
      data strings/'photon','Rayleigh','Compton','pair','photo'/
      IF (( which .LT. 0 .OR. which .GT. 4 )) THEN
        return
      END IF
      IF (( imed .GT. 0 .AND. imed .LE. nmed )) THEN
        ifirst = imed
        ilast = imed
      ELSE
        ifirst = 1
        ilast = nmed
      END IF
      IF (( which .EQ. 1 )) THEN
        has_r = .false.
        DO 6771 medium=ifirst,ilast
          IF (( iraylm(medium) .EQ. 1 )) THEN
            has_r = .true.
          END IF
6771    CONTINUE
6772    CONTINUE
        IF((.NOT.has_r))return
      END IF
      write(i_log,*) ' '
      DO 6781 medium=ifirst,ilast
        write(i_log,'(a,a,a,i3,a,f9.5)') 'Scaling ',strings(which+1),' x
     *-section data for medium', medium,' with ',fac
        DO 6791 j=1,mge(medium)
          gle = (j - ge0(medium))/ge1(medium)
          gmfp = gmfp0(j,medium) + gmfp1(j,medium)*gle
          gbr1 = gbr10(j,medium) + gbr11(j,medium)*gle
          gbr2 = gbr20(j,medium) + gbr21(j,medium)*gle
          IF (( iraylm(medium) .EQ. 1 )) THEN
            cohfac = cohe0(j,medium) + cohe1(j,medium)*gle
          ELSE
            cohfac = 1
          END IF
          IF (( which .EQ. 0 )) THEN
            gmfp = gmfp/fac
          ELSE IF(( which .EQ. 1 )) THEN
            cohfac = cohfac/(fac*(1-cohfac)+cohfac)
          ELSE
            IF (( which .EQ. 2 )) THEN
              aux = fac*(gbr2-gbr1) + gbr1 + 1 - gbr2
              gbr2 = (gbr1 + fac*(gbr2-gbr1))/aux
              gbr1 = gbr1/aux
            ELSE IF(( which .EQ. 3 )) THEN
              aux = fac*gbr1 + 1 - gbr1
              gbr2 = (fac*gbr1 + gbr2-gbr1)/aux
              gbr1 = fac*gbr1/aux
            ELSE
              aux = gbr2 + fac*(1-gbr2)
              gbr1 = gbr1/aux
              gbr2 = gbr2/aux
            END IF
            gmfp = gmfp/aux
            cohfac = cohfac*aux/(aux*cohfac + 1 - cohfac)
          END IF
          IF (( j .GT. 1 )) THEN
            gmfp1(j-1,medium) = (gmfp - gmfp_old)*ge1(medium)
            gmfp0(j-1,medium) = gmfp - gmfp1(j-1,medium)*gle
            gbr11(j-1,medium) = (gbr1 - gbr1_old)*ge1(medium)
            gbr10(j-1,medium) = gbr1 - gbr11(j-1,medium)*gle
            gbr21(j-1,medium) = (gbr2 - gbr2_old)*ge1(medium)
            gbr20(j-1,medium) = gbr2 - gbr21(j-1,medium)*gle
            cohe1(j-1,medium) = (cohfac - cohfac_old)*ge1(medium)
            cohe0(j-1,medium) = cohfac - cohe1(j-1,medium)*gle
          END IF
          gmfp_old = gmfp
          gbr1_old = gbr1
          gbr2_old = gbr2
          cohfac_old = cohfac
6791    CONTINUE
6792    CONTINUE
        gmfp1(mge(medium),medium) = gmfp1(mge(medium)-1,medium)
        gmfp0(mge(medium),medium) = gmfp0(mge(medium)-1,medium)
        gbr11(mge(medium),medium) = gbr11(mge(medium)-1,medium)
        gbr10(mge(medium),medium) = gbr10(mge(medium)-1,medium)
        gbr21(mge(medium),medium) = gbr21(mge(medium)-1,medium)
        gbr20(mge(medium),medium) = gbr20(mge(medium)-1,medium)
        cohe1(mge(medium),medium) = cohe1(mge(medium)-1,medium)
        cohe0(mge(medium),medium) = cohe0(mge(medium)-1,medium)
6781  CONTINUE
6782  CONTINUE
      return
      end
      subroutine egs_init_user_photon(prefix,comp_prefix,photonuc_prefix
     *,out)
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      character*(*) prefix, comp_prefix,  photonuc_prefix
      integer*4 out
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/EDGE/binding_energies(30,100), interaction_prob(6,100), rel
     *axation_prob(39,100), edge_energies(16,100), edge_number(100), edg
     *e_a(16,100), edge_b(16,100), edge_c(16,100), edge_d(16,100)
      EGS_Float binding_energies, interaction_prob, relaxation_prob, edg
     *e_energies, edge_a,edge_b,edge_c,edge_d
      integer*4 edge_number
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      COMMON/PHOTIN/ EBINDA(max_med), GE0(max_med),GE1(max_med), GMFP0(2
     *000,max_med),GMFP1(2000,max_med),GBR10(2000,max_med),GBR11(2000,ma
     *x_med),GBR20(2000,max_med),GBR21(2000,max_med), RCO0(max_med),RCO1
     *(max_med), RSCT0(100,max_med),RSCT1(100,max_med), COHE0(2000,max_m
     *ed),COHE1(2000,max_med),  PHOTONUC0(2000,max_med),PHOTONUC1(2000,m
     *ax_med), DPMFP, MPGEM(1,max_med), NGR(max_med)
      EGS_Float EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR
     *21,  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,
     *  DPMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common/compton_data/ iz_array(1538),be_array(1538), Jo_array(1538)
     *,erfJo_array(1538), ne_array(1538),shn_array(1538), shell_array(20
     *0,max_med), eno_array(200,max_med), eno_atbin_array(200,max_med),n
     *_shell(max_med)
      integer*4 iz_array,ne_array,shn_array, shell_array,eno_atbin_array
     *,n_shell
      EGS_Float be_array,Jo_array,erfJo_array,eno_array
      common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects, i
     *bcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet, radc_flag,eii_flag,ip
     *hotonuc, eadl_relax, mcdf_pe_xsections
      integer*4 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc, ibcmp,irayl
     *r,iedgfl,iphter,pair_nrc, radc_flag,itriplet
      logical spin_effects
      logical eadl_relax, mcdf_pe_xsections
      integer*4 lnblnk1,egs_get_unit,medium, photo_unit,pair_unit,raylei
     *gh_unit,triplet_unit, ounit,egs_open_file,compton_unit,  photonuc_
     *unit
      integer*4 nge,sorted(50),i,j,k,iz,iz_old,ndat
      EGS_Float z_sorted(50),pz_sorted(50)
      EGS_Float sig_photo(2000),sig_pair(2000),sig_triplet(2000), sig_ra
     *yleigh(2000),sig_compton(2000)
      EGS_Float sigma,cohe,gmfp,gbr1,gbr2,sig_KN,gle,e,sig_p
      EGS_Float cohe_old,gmfp_old,gbr1_old,gbr2_old,  sig_photonuc(2000)
     *, photonuc, photonuc_old
      EGS_Float etmp(2000),ftmp(2000)
      EGS_Float sumZ,sumA,con1,con2,egs_KN_sigma0
      EGS_Float bc_emin,bc_emax,bc_dle,bc_data(183),bc_tmp(183),bcf,aj
      integer*4 bc_ne
      logical input_compton_data,  input_photonuc_data
      character data_dir*128,photo_file*140,pair_file*140,rayleigh_file*
     *144, triplet_file*142,tmp_string*144,compton_file*144,  photonuc_f
     *ile*144
      write(i_log,'(/a$)') '(Re)-initializing photon cross sections'
      write(i_log,'(a,a/)') ' with files from the series: ', prefix(:lnb
     *lnk1(prefix))
      write(i_log,'(a,a)') ' Compton cross sections: ',comp_prefix(:lnbl
     *nk1(comp_prefix))
      IF ((iphotonuc .EQ. 1)) THEN
        write(i_log,'(a,a)') ' Photonuclear cross sections: ', photonuc_
     *  prefix(:lnblnk1(photonuc_prefix))
        input_photonuc_data = .false.
        IF ((lnblnk1(photonuc_prefix) .GT. 0 .AND. photonuc_prefix(1:7)
     *  .NE. 'default')) THEN
          input_photonuc_data = .true.
        END IF
      END IF
      input_compton_data = .false.
      IF (( ibcmp .GT. 1 .AND. lnblnk1(comp_prefix) .GT. 0 )) THEN
        IF((comp_prefix(1:7) .NE. 'default'))input_compton_data = .true.
      END IF
      data_dir = hen_house(:lnblnk1(hen_house)) // 'data' // '/'
      photo_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(prefi
     *x)) // '_photo.data'
      pair_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(prefix
     *)) // '_pair.data'
      triplet_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(pre
     *fix)) // '_triplet.data'
      rayleigh_file = data_dir(:lnblnk1(data_dir)) // prefix(:lnblnk1(pr
     *efix)) // '_rayleigh.data'
      IF (( input_compton_data )) THEN
        compton_file = data_dir(:lnblnk1(data_dir)) // comp_prefix(:lnbl
     *  nk1(comp_prefix)) // '_compton.data'
      ELSE
        compton_file = data_dir(:lnblnk1(data_dir)) // 'compton_sigma.da
     *ta'
      END IF
      write(i_log,'(a,a)') ' Using Compton cross sections from ', compto
     *n_file(:lnblnk1(compton_file))
      IF ((iphotonuc .EQ. 1)) THEN
        IF (( input_photonuc_data )) THEN
          photonuc_file = data_dir(:lnblnk1(data_dir)) // photonuc_prefi
     *    x(:lnblnk1(photonuc_prefix)) // '_photonuc.data'
        ELSE
          photonuc_file = data_dir(:lnblnk1(data_dir)) // 'iaea_photonuc
     *.data'
        END IF
        write(i_log,'(a,a)') ' Using photonuclear cross sections from ',
     *   photonuc_file(:lnblnk1(photonuc_file))
      END IF
      photo_unit = 83
      photo_unit = egs_get_unit(photo_unit)
      IF (( photo_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = photo_file
      open(photo_unit,file=photo_file,status='old',err=6800)
      pair_unit = 84
      pair_unit = egs_get_unit(pair_unit)
      IF (( pair_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = pair_file
      open(pair_unit,file=pair_file,status='old',err=6800)
      triplet_unit = 85
      triplet_unit = egs_get_unit(triplet_unit)
      IF (( triplet_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = triplet_file
      open(triplet_unit,file=triplet_file,status='old',err=6800)
      rayleigh_unit = 86
      rayleigh_unit = egs_get_unit(rayleigh_unit)
      IF (( rayleigh_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_user_photon: failed to get a free Fortr
     *an I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      tmp_string = rayleigh_file
      open(rayleigh_unit,file=rayleigh_file,status='old',err=6800)
      IF (( ibcmp .GT. 1 )) THEN
        compton_unit = 88
        compton_unit = egs_get_unit(compton_unit)
        IF (( compton_unit .LT. 1 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'egs_init_user_photon: failed to get a free For
     *tran I/O unit'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        tmp_string = compton_file
        open(compton_unit,file=compton_file,status='old',err=6800)
      END IF
      IF (( iphotonuc .EQ. 1 )) THEN
        photonuc_unit = 89
        photonuc_unit = egs_get_unit(photonuc_unit)
        IF (( photonuc_unit .LT. 1 )) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,*) 'egs_init_user_photon: failed to get a free For
     *tran I/O unit'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        tmp_string = photonuc_file
        open(photonuc_unit,file=photonuc_file,status='old',err=6800)
      END IF
      IF (( out .EQ. 1 )) THEN
        ounit = egs_open_file(87,0,1,'.xsections')
        write(ounit,'(/a,a,a)') 'Photon cross sections initialized from
     *', prefix(:lnblnk1(prefix)),' data files'
        write(ounit,'(a,/)') '==========================================
     *=================================='
        write(ounit,'(a,/)') 'Grid energies and cross sections are outpu
     *t'
        IF ((iphotonuc .EQ. 1)) THEN
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a)') 'Energy','
     * GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ', ' GMFP(cm) '
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a/)') '(MeV)','
     *no Rayleigh','(fraction)','(fraction)','with Rayleigh', 'w/ Ray +
     *photnuc'
        ELSE
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a)') 'Energy',' GMFP(
     *cm) ',' Pair ','Compton',' GMFP(cm) '
          write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a/)') '(MeV)','no Ray
     *leigh','(fraction)','(fraction)','with Rayleigh'
        END IF
      END IF
      DO 6811 iz=1,100
        read(photo_unit,*) ndat
        read(photo_unit,*) (etmp(k),ftmp(k),k=1,ndat)
        k = 0
        DO 6821 j=ndat,2,-1
          IF (( etmp(j)-etmp(j-1) .LT. 1e-5 )) THEN
            k = k+1
            IF (( k .LE. 30 )) THEN
              binding_energies(k,iz) = exp(etmp(j))
            ELSE
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,'(i3,a,i3,//a)') k,' binding energies read exc
     *eeding array size of', 30,'Increase $MXSHXSEC in egsnrc.macros!'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            IF((.NOT.eadl_relax .AND. k .GE. 4))GO TO6822
          END IF
6821    CONTINUE
6822    CONTINUE
6811  CONTINUE
6812  CONTINUE
      IF ((mcdf_pe_xsections)) THEN
        call egs_read_shellwise_pe()
      END IF
      DO 6831 medium=1,nmed
        mge(medium) = 2000
        nge = 2000
        ge1(medium) = nge-1
        ge1(medium) = ge1(medium)/log(up(medium)/ap(medium))
        ge0(medium) = 1 - ge1(medium)*log(ap(medium))
        write(i_log,'(a,i3,a,$)') ' Working on medium ',medium,' ... '
        IF (( out .EQ. 1 )) THEN
          write(ounit,'(/,2x,a,i3,a,24a1/)') 'Medium ',medium,': ', (med
     *    ia(k,medium),k=1,24)
        END IF
        sumZ=0
        sumA=0
        DO 6841 i=1,nne(medium)
          z_sorted(i) = zelem(medium,i)
          sumZ = sumZ + pz(medium,i)*zelem(medium,i)
          sumA = sumA + pz(medium,i)*wa(medium,i)
6841    CONTINUE
6842    CONTINUE
        con1 = sumZ*rho(medium)/(sumA*1.6605655)
        con2 = rho(medium)/(sumA*1.6605655)
        call egs_heap_sort(nne(medium),z_sorted,sorted)
        DO 6851 i=1,nne(medium)
          pz_sorted(i) = pz(medium,sorted(i))
6851    CONTINUE
6852    CONTINUE
        IF ((mcdf_pe_xsections)) THEN
          call egsi_get_shell_data(medium,nge,nne(medium),z_sorted,pz_so
     *    rted, ge1(medium),ge0(medium),sig_photo)
        ELSE
          call egsi_get_data(0,photo_unit,nge,nne(medium),z_sorted,pz_so
     *    rted, ge1(medium),ge0(medium),sig_photo)
        END IF
        call egsi_get_data(0,rayleigh_unit,nge,nne(medium),z_sorted,pz_s
     *  orted, ge1(medium),ge0(medium),sig_rayleigh)
        call egsi_get_data(1,pair_unit,nge,nne(medium),z_sorted,pz_sorte
     *  d, ge1(medium),ge0(medium),sig_pair)
        call egsi_get_data(2,triplet_unit,nge,nne(medium),z_sorted,pz_so
     *  rted, ge1(medium),ge0(medium),sig_triplet)
        IF (( iphotonuc .EQ. 1 )) THEN
          call egsi_get_data(3,photonuc_unit,nge,nne(medium),z_sorted,pz
     *    _sorted, ge1(medium),ge0(medium),sig_photonuc)
        END IF
        IF (( ibcmp .GT. 1 )) THEN
          IF (( input_compton_data )) THEN
            call egsi_get_data(0,compton_unit,nge,nne(medium), z_sorted,
     *      pz_sorted,ge1(medium),ge0(medium), sig_compton)
          ELSE
            rewind(compton_unit)
            read(compton_unit,*) bc_emin,bc_emax,bc_ne
            IF (( bc_ne .GT. 183 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'Number of input Compton data exceeds array
     * size'
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            END IF
            bc_dle = log(bc_emax/bc_emin)/(bc_ne-1)
            DO 6861 j=1,bc_ne
              bc_data(j) = 0
6861        CONTINUE
6862        CONTINUE
            iz_old = 1
            DO 6871 i=1,nne(medium)
              iz = int(z_sorted(i)+0.5)
              DO 6881 j=iz_old,iz
                read(compton_unit,*) (bc_tmp(k),k=1,bc_ne)
6881          CONTINUE
6882          CONTINUE
              DO 6891 j=1,bc_ne
                bc_data(j)=bc_data(j)+pz_sorted(i)*z_sorted(i)*bc_tmp(j)
6891          CONTINUE
6892          CONTINUE
              iz_old = iz+1
6871        CONTINUE
6872        CONTINUE
            DO 6901 j=1,bc_ne
              bc_data(j)=log(bc_data(j)/sumZ)
6901        CONTINUE
6902        CONTINUE
          END IF
        END IF
        call egs_init_rayleigh(medium,sig_rayleigh)
        DO 6911 i=1,nge
          gle = (i - ge0(medium))/ge1(medium)
          e = exp(gle)
          sig_KN = sumZ*egs_KN_sigma0(e)
          IF (( ibcmp .GT. 1 )) THEN
            IF (( input_compton_data )) THEN
              sig_KN = sig_compton(i)
            ELSE
              IF (( e .LE. bc_emin )) THEN
                bcf = exp(bc_data(1))
              ELSE IF(( e .LT. bc_emax )) THEN
                aj = 1 + log(e/bc_emin)/bc_dle
                j = int(aj)
                aj = aj - j
                bcf = exp(bc_data(j)*(1-aj) + bc_data(j+1)*aj)
              ELSE
                bcf = 1
              END IF
              sig_KN = sig_KN*bcf
            END IF
          END IF
          sig_p = sig_pair(i) + sig_triplet(i)
          sigma = sig_KN + sig_p + sig_photo(i)
          gmfp = 1/(sigma*con2)
          gbr1 = sig_p/sigma
          gbr2 = gbr1 + sig_KN/sigma
          cohe = sigma/(sig_rayleigh(i) + sigma)
          photonuc = sigma/(sig_photonuc(i) + sigma)
          IF (( out .EQ. 1 )) THEN
            IF ((iphotonucm(medium) .EQ. 1)) THEN
              write(ounit,'(6(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1, gmfp*co
     *        he,gmfp*cohe*photonuc
            ELSE
              write(ounit,'(5(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,gmfp*coh
     *        e
            END IF
          END IF
          IF (( i .GT. 1 )) THEN
            gmfp1(i-1,medium) = (gmfp - gmfp_old)*ge1(medium)
            gmfp0(i-1,medium) = gmfp - gmfp1(i-1,medium)*gle
            gbr11(i-1,medium) = (gbr1 - gbr1_old)*ge1(medium)
            gbr10(i-1,medium) = gbr1 - gbr11(i-1,medium)*gle
            gbr21(i-1,medium) = (gbr2 - gbr2_old)*ge1(medium)
            gbr20(i-1,medium) = gbr2 - gbr21(i-1,medium)*gle
            cohe1(i-1,medium) = (cohe - cohe_old)*ge1(medium)
            cohe0(i-1,medium) = cohe - cohe1(i-1,medium)*gle
            photonuc1(i-1,medium) = (photonuc - photonuc_old)*ge1(medium
     *      )
            photonuc0(i-1,medium) = photonuc - photonuc1(i-1,medium)*gle
          END IF
          gmfp_old = gmfp
          gbr1_old = gbr1
          gbr2_old = gbr2
          cohe_old = cohe
          photonuc_old = photonuc
6911    CONTINUE
6912    CONTINUE
        gmfp1(nge,medium) = gmfp1(nge-1,medium)
        gmfp0(nge,medium) = gmfp - gmfp1(nge,medium)*gle
        gbr11(nge,medium) = gbr11(nge-1,medium)
        gbr10(nge,medium) = gbr1 - gbr11(nge,medium)*gle
        gbr21(nge,medium) = gbr21(nge-1,medium)
        gbr20(nge,medium) = gbr2 - gbr21(nge,medium)*gle
        cohe1(nge,medium) = cohe1(nge-1,medium)
        cohe0(nge,medium) = cohe - cohe1(nge,medium)*gle
        photonuc1(nge,medium) = photonuc1(nge-1,medium)
        photonuc0(nge,medium) = photonuc - photonuc1(nge,medium)*gle
        write(i_log,'(a)') 'OK'
6831  CONTINUE
6832  CONTINUE
      close(photo_unit)
      close(pair_unit)
      close(triplet_unit)
      close(rayleigh_unit)
      IF (( iphotonuc .EQ. 1 )) THEN
        close(photonuc_unit)
      END IF
      IF (( ibcmp .GT. 1 )) THEN
        close(compton_unit)
      END IF
      IF (( out .EQ. 1 )) THEN
        close(ounit)
      END IF
      return
6800  CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(//a,a)') 'Failed to open data file ',tmp_string(:lnb
     *lnk1(tmp_string))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egs_init_rayleigh(medium,sig_rayleigh)
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/misc/ DUNIT,KMPI,KMPO
      EGS_Float DUNIT
      integer*4 KMPI,KMPO
      COMMON/PHOTIN/ EBINDA(max_med), GE0(max_med),GE1(max_med), GMFP0(2
     *000,max_med),GMFP1(2000,max_med),GBR10(2000,max_med),GBR11(2000,ma
     *x_med),GBR20(2000,max_med),GBR21(2000,max_med), RCO0(max_med),RCO1
     *(max_med), RSCT0(100,max_med),RSCT1(100,max_med), COHE0(2000,max_m
     *ed),COHE1(2000,max_med),  PHOTONUC0(2000,max_med),PHOTONUC1(2000,m
     *ax_med), DPMFP, MPGEM(1,max_med), NGR(max_med)
      EGS_Float EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR
     *21,  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,
     *  DPMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/rayleigh_inputs/iray_ff_media(max_med),iray_ff_file(max_med
     *)
      character*24 iray_ff_media
      character*128 iray_ff_file
      COMMON/rayleigh_sampling/xgrid(100,max_med), fcum(100,max_med), b_
     *array(100,max_med), c_array(100,max_med), i_array(100,max_med), pm
     *ax0(2000,max_med),pmax1(2000,max_med)
      EGS_Float xgrid, fcum, b_array, c_array,pmax0, pmax1
      integer*4 i_array
      EGS_Float xval(100),aff(100,100),ff(100,max_med)
      EGS_Float xsc, fsc
      EGS_Float sig_rayleigh(2000), pe_array(2000,max_med)
      EGS_Float e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA
      EGS_Float totRayleigh2,pzmin
      EGS_Float emin, emax
      integer*4 i,j,k,ff_unit, egs_get_unit, ne
      integer*4 lnblnk1, EOF, nff, medium, ncustom
      character dummy*24, afac_file*128, ff_file*128
      IF ((iraylm(medium).EQ.0)) THEN
        return
      END IF
      ncustom=0
      write(dummy,'(24a1)')(media(j,medium),j=1,24)
      ff_file=' '
      DO 6921 i=1,max_med
        IF ((lnblnk1(iray_ff_file(i)).NE.0)) THEN
          ncustom = ncustom + 1
        END IF
6921  CONTINUE
6922  CONTINUE
      DO 6931 i=1,ncustom
        IF ((dummy(:lnblnk1(dummy)) .EQ. iray_ff_media(i))) THEN
          ff_file = iray_ff_file(i)
        END IF
6931  CONTINUE
6932  CONTINUE
      ff_unit = egs_get_unit(0)
      IF (( ff_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_rayleigh: failed to get a free Fortran
     *I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      IF (( lnblnk1(ff_file) .GT. 0)) THEN
        open(ff_unit,file=ff_file(:lnblnk1(ff_file)), status='old',err=6
     *  940)
        GOTO 6950
6940    write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(2a)') 'egs_init_rayleigh: failed to open custom ff
     * file ', ff_file(:lnblnk1(ff_file))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
6950    write(i_log,'(/2a)') 'Opened custom ff file ',ff_file(:lnblnk1(f
     *  f_file))
        j = 0
6961    CONTINUE
          j = j + 1
          read(ff_unit,*,IOSTAT=EOF) xsc, fsc
          IF((EOF .LT. 0))GO TO6962
          IF ((j .LE. 100)) THEN
            xgrid(j,medium)=xsc
            ff(j,medium)=fsc
          END IF
        GO TO 6961
6962    CONTINUE
        nff = j-1
        IF ((nff .GT. 100)) THEN
          write(i_log,'(/a)') '***************** Error: '
          write(i_log,'(a,/,a,i5,a,i5,/,a)') 'subroutine egs_init_raylei
     *gh: form factors size too small!!', '$XRAYFF =  ', 100,', and need
     * to be ',nff, ' and try again!!!'
          write(i_log,'(/a)') '***************** Quiting now.'
          call exit(1)
        END IF
        IF((xgrid(1,medium) .LT. 1e-6))xgrid(1,medium) = 1e-4
        write(*,*) '\n  -> ', nff, ' values of mol. ff read!'
        sumA = 0.0
        DO 6971 j=1,nne(medium)
          sumA=sumA+PZ(medium,j)*WA(medium,j)
6971    CONTINUE
6972    CONTINUE
        DO 6981 j=1,MGE(medium)
          gle=(j-GE0(medium))/GE1(medium)
          e=exp(gle)
          sig_rayleigh(j)=egs_rayleigh_sigma(medium,e,nff, xgrid(1,mediu
     *    m),ff(1,medium))*sumA
6981    CONTINUE
6982    CONTINUE
      ELSE
        DO 6991 i=1,len(afac_file)
          afac_file(i:i) = ' '
6991    CONTINUE
6992    CONTINUE
        afac_file = hen_house(:lnblnk1(hen_house))//'pegs4'//'/'//'pgs4f
     *orm.dat'
        open(ff_unit,file=afac_file(:lnblnk1(afac_file)), status='old',e
     *  rr=7000)
        GOTO 7010
7000    write(i_log,'(/a)') '***************** Error: '
        write(i_log,'(2a)') 'egs_init_rayleigh: failed to open atomic ff
     * file', afac_file(:lnblnk1(afac_file))
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
7010    read(ff_unit,*) xval, aff
        DO 7021 i=1,100
          ff(i,medium) = 0.0
          xgrid(i,medium)=xval(i)
          DO 7031 j=1,nne(medium)
            ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(mediu
     *      m,j)))**2
7031      CONTINUE
7032      CONTINUE
          ff(i,medium) = sqrt(ff(i,medium))
7021    CONTINUE
7022    CONTINUE
        nff = 100
        IF((xgrid(1,medium) .LT. 1e-6))xgrid(1,medium) = 1e-4
        write(i_log,'(/a,i4,a)') '  -> ', nff, ' atomic ff values comput
     *ed!'
      END IF
      close(ff_unit)
      emin = exp((1 - ge0(medium))/ge1(medium))
      emax = exp((mge(medium) - ge0(medium))/ge1(medium))
      call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium), mge(m
     *edium),emin,emax, pe_array(1,medium),100, fcum(1,medium),i_array(1
     *,medium), b_array(1,medium),c_array(1,medium))
      ne=MGE(medium)
      dle=log(up(medium)/ap(medium))/(ne-1)
      dlei=1/dle
      DO 7041 i=1,ne-1
        gle = (i - ge0(medium))/ge1(medium)
        pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(me
     *  dium)
        pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle
7041  CONTINUE
7042  CONTINUE
      pmax0(ne,medium)=pmax0(ne-1,medium)
      pmax1(ne,medium)=pmax1(ne-1,medium)
      return
      end
      subroutine egs_init_rayleigh_sampling(medium)
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      COMMON/THRESH/RMT2,RMSQ, AP(max_med),AE(max_med),UP(max_med),UE(ma
     *x_med),TE(max_med),THMOLL(max_med)
      EGS_Float RMT2,  RMSQ,  AP,  AE,  UP,  UE,  TE,  THMOLL
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/misc/ DUNIT,KMPI,KMPO
      EGS_Float DUNIT
      integer*4 KMPI,KMPO
      COMMON/PHOTIN/ EBINDA(max_med), GE0(max_med),GE1(max_med), GMFP0(2
     *000,max_med),GMFP1(2000,max_med),GBR10(2000,max_med),GBR11(2000,ma
     *x_med),GBR20(2000,max_med),GBR21(2000,max_med), RCO0(max_med),RCO1
     *(max_med), RSCT0(100,max_med),RSCT1(100,max_med), COHE0(2000,max_m
     *ed),COHE1(2000,max_med),  PHOTONUC0(2000,max_med),PHOTONUC1(2000,m
     *ax_med), DPMFP, MPGEM(1,max_med), NGR(max_med)
      EGS_Float EBINDA,  GE0,GE1,  GMFP0,GMFP1,  GBR10,GBR11,  GBR20,GBR
     *21,  RCO0,RCO1,  RSCT0,RSCT1,  COHE0,COHE1,   PHOTONUC0,PHOTONUC1,
     *  DPMFP
      integer*4
     *                  MPGEM,
     *                          NGR
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      COMMON/rayleigh_inputs/iray_ff_media(max_med),iray_ff_file(max_med
     *)
      character*24 iray_ff_media
      character*128 iray_ff_file
      COMMON/rayleigh_sampling/xgrid(100,max_med), fcum(100,max_med), b_
     *array(100,max_med), c_array(100,max_med), i_array(100,max_med), pm
     *ax0(2000,max_med),pmax1(2000,max_med)
      EGS_Float xgrid, fcum, b_array, c_array,pmax0, pmax1
      integer*4 i_array
      EGS_Float xval(100),aff(100,100),ff(100,max_med)
      EGS_Float xsc, fsc
      EGS_Float sig_rayleigh(2000), pe_array(2000,max_med)
      EGS_Float e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA
      EGS_Float totRayleigh2,pzmin
      EGS_Float emin, emax
      integer*4 i,j,k,ff_unit, egs_get_unit, ne
      integer*4 lnblnk1, EOF, nff, medium, ncustom
      character dummy*24, afac_file*128, ff_file*128
      IF ((iraylm(medium).EQ.0)) THEN
        return
      END IF
      ff_unit = egs_get_unit(0)
      IF (( ff_unit .LT. 1 )) THEN
        write(i_log,'(/a)') '***************** Error: '
        write(i_log,*) 'egs_init_rayleigh: failed to get a free Fortran
     *I/O unit'
        write(i_log,'(/a)') '***************** Quiting now.'
        call exit(1)
      END IF
      DO 7051 i=1,len(afac_file)
        afac_file(i:i) = ' '
7051  CONTINUE
7052  CONTINUE
      afac_file = hen_house(:lnblnk1(hen_house))//'pegs4'//'/'//'pgs4for
     *m.dat'
      open(ff_unit,file=afac_file(:lnblnk1(afac_file)),status='old',err=
     *7000)
      GOTO 7010
7000  write(i_log,'(/a)') '***************** Error: '
      write(i_log,'(2a)') 'egs_init_rayleigh_sampling: failed to open at
     *omic ff file ', afac_file(:lnblnk1(afac_file))
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
7010  read(ff_unit,*) xval, aff
      DO 7061 i=1,100
        ff(i,medium) = 0.0
        xgrid(i,medium)=xval(i)
        DO 7071 j=1,nne(medium)
          ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,
     *    j)))**2
7071    CONTINUE
7072    CONTINUE
        ff(i,medium) = sqrt(ff(i,medium))
7061  CONTINUE
7062  CONTINUE
      nff = 100
      IF((xgrid(1,medium) .LT. 1e-6))xgrid(1,medium) = 1e-4
      write(i_log,'(/a,i4,a)') '  -> ', nff, ' atomic ff values computed
     *!'
      close(ff_unit)
      emin = exp((1 - ge0(medium))/ge1(medium))
      emax = exp((mge(medium) - ge0(medium))/ge1(medium))
      call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium), mge(m
     *edium),emin,emax, pe_array(1,medium),100, fcum(1,medium),i_array(1
     *,medium), b_array(1,medium),c_array(1,medium))
      ne=MGE(medium)
      DO 7081 i=1,ne-1
        gle = (i - ge0(medium))/ge1(medium)
        pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(me
     *  dium)
        pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle
7081  CONTINUE
7082  CONTINUE
      pmax0(ne,medium)=pmax0(ne-1,medium)
      pmax1(ne,medium)=pmax1(ne-1,medium)
      return
      end
      EGS_Float function egs_rayleigh_sigma(imed,E,ndat,x,f)
      implicit none
      integer*4 i, j, k,imed, ndat
      EGS_Float hc2,conv,b,hc
      parameter (hc = 0.0123984768438,hc2=0.0001537222280)
      EGS_Float x(100), f(100), zero, E, xmax
      real*8 x1,x2,pow_x1,pow_x2,raysig,C,C2,f1,f2
      C=2.*hc2/(E*E)
      C2=C*C
      xmax=E/hc
      egs_rayleigh_sigma = 0.0
      DO 7091 i=1,ndat-1
        IF((x(i) .EQ. 0.0))x(i) = zero()
        IF((x(i+1) .EQ. 0.0))x(i+1) = zero()
        IF((f(i) .EQ. 0.0))f(i) = zero()
        IF((f(i+1) .EQ. 0.0))f(i+1) = zero()
        b = log(f(i+1)/f(i))/log(x(i+1)/x(i))
        x1=x(i)
        x2=x(i+1)
        IF ((x2 .GT. xmax)) THEN
          x2=xmax
        END IF
        pow_x1=x1**(2*b)
        pow_x2=x2**(2*b)
        raysig = pow_x2*(x2**2/(b+1)-(C*x2**4)/(b+2)+(C2*x2**6)/(2*b+6))
        raysig = raysig - pow_x1*(x1**2/(b+1)-(C*x1**4)/(b+2)+(C2*x1**6)
     *  /(2*b+6))
        raysig = raysig*f(i)*f(i)/pow_x1
        egs_rayleigh_sigma = egs_rayleigh_sigma + raysig
        IF ((x(i+1).GT.xmax)) THEN
          GO TO7092
        END IF
7091  CONTINUE
7092  CONTINUE
      egs_rayleigh_sigma = 0.49893439187842413747*C*egs_rayleigh_sigma
      return
      end
      subroutine egs_rayleigh_sampling(medium,e,gle,lgle,costhe,sinthe)
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      real*8 e
      EGS_Float gle,costhe,sinthe,pmax,xv,xmax,csqthe
      EGS_Float rnnray1,rnnray0,hc_i,twice_hc2,dwi
      parameter(hc_i=80.65506856998,twice_hc2=0.000307444456)
      integer*4 lgle,ib,ibin,medium, trials
      common/randomm/ rng_array(128), rng_seed
      integer*4 rng_seed
      EGS_Float rng_array
      COMMON/rayleigh_sampling/xgrid(100,max_med), fcum(100,max_med), b_
     *array(100,max_med), c_array(100,max_med), i_array(100,max_med), pm
     *ax0(2000,max_med),pmax1(2000,max_med)
      EGS_Float xgrid, fcum, b_array, c_array,pmax0, pmax1
      integer*4 i_array
      dwi = 100-1
      pmax=pmax1(Lgle,MEDIUM)*gle+pmax0(Lgle,MEDIUM)
      xmax = hc_i*e
7101  CONTINUE
        IF (( rng_seed .GT. 128 )) THEN
          rng_seed = 128
          call egs_fill_rndm_array(rng_seed,rng_array)
          rng_seed = 1
        END IF
        rnnray1 = rng_array(rng_seed)
        rng_seed = rng_seed + 1
7111    CONTINUE
          IF (( rng_seed .GT. 128 )) THEN
            rng_seed = 128
            call egs_fill_rndm_array(rng_seed,rng_array)
            rng_seed = 1
          END IF
          rnnray0 = rng_array(rng_seed)
          rng_seed = rng_seed + 1
          rnnray0 = rnnray0*pmax
          ibin = 1 + rnnray0*dwi
          ib = i_array(ibin,medium)
          IF (( i_array(ibin+1,medium) .GT. ib )) THEN
7121        CONTINUE
              IF((rnnray0.LT.fcum(ib+1,medium)))GO TO7122
              ib=ib+1
            GO TO 7121
7122        CONTINUE
          END IF
          rnnray0 = (rnnray0 - fcum(ib,medium))*c_array(ib,medium)
          xv = xgrid(ib,medium)*exp(log(1+rnnray0)*b_array(ib,medium))
          IF(((xv .LT. xmax)))GO TO7112
        GO TO 7111
7112    CONTINUE
        xv = xv/e
        costhe = 1 - twice_hc2*xv*xv
        csqthe=costhe*costhe
        IF((( 2*rnnray1 .LT. 1 + csqthe )))GO TO7102
      GO TO 7101
7102  CONTINUE
      sinthe=sqrt(1.0-csqthe)
      return
      end
      subroutine prepare_rayleigh_data(ndat,x,f, ne,emin,emax,pe_array,
     *ncbin,fcum,i_array, b_array,c_array)
      implicit none
      integer*4 ndat
      EGS_Float x(ndat),  f(ndat)
      integer*4 ne
      EGS_Float emin,  emax,  pe_array(ne)
      integer*4 ncbin
      EGS_Float fcum(ndat)
      integer*4 i_array(ncbin)
      EGS_Float b_array(ndat),  c_array(ndat)
      EGS_Float zero
      real*8 sum0,a,b,x1,x2,pow_x1,pow_x2,dle,e,xmax, anorm,anorm1,anorm
     *2,w,dw,xold,t,aux
      integer*4 i,j,k,ibin
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      write(*,'(a$)') '      preparing data for Rayleigh sampling ... '
      DO 7131 i=1,ndat
        IF((f(i) .EQ. 0.0))f(i) = zero()
7131  CONTINUE
7132  CONTINUE
      sum0=0
      fcum(1)=0
      DO 7141 i=1,ndat-1
        b = log(f(i+1)/f(i))/log(x(i+1)/x(i))
        b_array(i) = b
        x1 = x(i)
        x2 = x(i+1)
        pow_x1 = x1**(2*b)
        pow_x2 = x2**(2*b)
        sum0=sum0+f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1)
        fcum(i+1) = sum0
7141  CONTINUE
7142  CONTINUE
      dle = log(emax/emin)/(ne-1)
      i = 1
      DO 7151 j=1,ne
        e = emin*exp(dle*(j-1))
        xmax = 20.607544d0*2*e/prm
        DO 7161 k=i,ndat-1
          IF((xmax .GE. x(k) .AND. xmax .LT. x(k+1)))GO TO7162
7161    CONTINUE
7162    CONTINUE
        i = k
        b = b_array(i)
        x1 = x(i)
        x2 = xmax
        pow_x1 = x1**(2*b)
        pow_x2 = x2**(2*b)
        pe_array(j) = fcum(i) + f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((
     *  1+b)*pow_x1)
7151  CONTINUE
7152  CONTINUE
      i_array(ncbin) = i
      anorm = 1d0/sqrt(pe_array(ne))
      anorm1 = 1.005d0/pe_array(ne)
      anorm2 = 1d0/pe_array(ne)
      DO 7171 j=1,ne
        pe_array(j) = pe_array(j)*anorm1
        IF((pe_array(j) .GT. 1))pe_array(j) = 1
7171  CONTINUE
7172  CONTINUE
      DO 7181 j=1,ndat
        f(j) = f(j)*anorm
        fcum(j) = fcum(j)*anorm2
        c_array(j) = (1+b_array(j))/(x(j)*f(j))**2
7181  CONTINUE
7182  CONTINUE
      dw = 1d0/(ncbin-1)
      xold = x(1)
      ibin = 1
      b = b_array(1)
      pow_x1 = x(1)**(2*b)
      i_array(1) = 1
      DO 7191 i=2,ncbin-1
        w = dw
7201    CONTINUE
          x1 = xold
          x2 = x(ibin+1)
          t = x1*x1*x1**(2*b)
          pow_x2 = x2**(2*b)
          aux=f(ibin)*f(ibin)*(x2*x2*pow_x2-t)/((1+b)*pow_x1)
          IF (( aux .GT. w )) THEN
            xold = exp(log(t+w*(1+b)*pow_x1/f(ibin)/f(ibin))/(2+2*b))
            i_array(i) = ibin
            GO TO7202
          END IF
          w = w - aux
          xold = x2
          ibin = ibin+1
          b = b_array(ibin)
          pow_x1 = xold**(2*b)
        GO TO 7201
7202    CONTINUE
7191  CONTINUE
7192  CONTINUE
      DO 7211 j=1,ndat
        b_array(j) = 0.5/(1 + b_array(j))
7211  CONTINUE
7212  CONTINUE
      write(*,'(a /)') 'done'
      return
      end
      EGS_Float function egs_KN_sigma0(e)
      implicit none
      EGS_Float e
      EGS_Float con,ko,c1,c2,c3,eps1,eps2
      data con/0.1274783851/
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      ko = e/prm
      IF (( ko .LT. 0.01 )) THEN
        egs_KN_sigma0 = 8.*con/3.*(1-ko*(2-ko*(5.2-13.3*ko)))/prm
        return
      END IF
      c1 = 1./(ko*ko)
      c2 = 1. - 2*(1+ko)*c1
      c3 = (1+2*ko)*c1
      eps2 = 1
      eps1 = 1./(1+2*ko)
      egs_KN_sigma0 = (c1*(1./eps1-1./eps2)+c2*log(eps2/eps1)+eps2*(c3+0
     *.5*eps2)- eps1*(c3+0.5*eps1))/e*con
      return
      end
      EGS_Float function egs_KN_sigma1(e)
      implicit none
      EGS_Float e
      EGS_Float con,ko,c1,c2,c3,eps1,eps2
      data con/0.1274783851/
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      ko = e/prm
      c1 = 1./(ko*ko)
      c2 = 1. - 2*(1+ko)*c1
      c3 = (1+2*ko)*c1
      eps2 = 1
      eps1 = 1./(1+2*ko)
      egs_KN_sigma1 = c1*(1./eps1-1./eps2)
      egs_KN_sigma1 = egs_KN_sigma1 + log(eps2/eps1)*(c2 - c1) - c2*(eps
     *2-eps1)
      egs_KN_sigma1 = egs_KN_sigma1 + c3*(eps2-eps1)*(1-0.5*(eps1+eps2))
      egs_KN_sigma1 = egs_KN_sigma1 + (eps2-eps1)*(0.5*(eps1+eps2)-(eps1
     **eps1+eps2*eps2+eps1*eps2)/3)
      egs_KN_sigma1 = egs_KN_sigma1*con
      return
      end
      subroutine egsi_get_data(flag,iunit,n,ne,zsorted,pz_sorted,ge1,ge0
     *,data)
      implicit none
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      EGS_Float eth
      integer*4 flag,iunit,n,ne
      EGS_Float ge1,ge0,zsorted(*),pz_sorted(*),data(*)
      EGS_Float etmp(2000),ftmp(2000)
      EGS_Float gle,sig,p,e
      integer*4 i,j,k,kk,iz,iz_old,ndat,iiz
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      rewind(iunit)
      iz_old = 0
      DO 7221 k=1,n
        data(k) = 0
7221  CONTINUE
7222  CONTINUE
      DO 7231 i=1,ne
        iiz = int(zsorted(i)+0.5)
        DO 7241 iz=iz_old+1,iiz
          read(iunit,*,err=7250) ndat
          IF (( ndat .GT. 2000 )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'Too many input data points. Max. is ',2000
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          END IF
          IF (( flag .EQ. 0 .OR. flag .EQ. 3)) THEN
            read(iunit,*,err=7250) (etmp(k),ftmp(k),k=1,ndat)
          ELSE
            read(iunit,*,err=7250) (etmp(k+1),ftmp(k+1), k=1,ndat)
            IF (( flag .EQ. 1 )) THEN
              eth = 2*rm
            ELSE
              eth = 4*rm
            END IF
            ndat = ndat + 1
            DO 7261 k=2,ndat
              ftmp(k) = ftmp(k) - 3*log(1-eth/exp(etmp(k)))
7261        CONTINUE
7262        CONTINUE
            ftmp(1) = ftmp(2)
            etmp(1) = log(eth)
          END IF
7241    CONTINUE
7242    CONTINUE
        iz_old = iiz
        DO 7271 k=1,n
          gle = (k - ge0)/ge1
          e = exp(gle)
          IF (( gle .LT. etmp(1) .OR. gle .GE. etmp(ndat) )) THEN
            IF (( flag .EQ. 0 )) THEN
              write(i_log,'(/a)') '***************** Error: '
              write(i_log,*) 'Energy ',exp(gle), ' is outside the availa
     *ble data range of ', exp(etmp(1)),exp(etmp(ndat))
              write(i_log,'(/a)') '***************** Quiting now.'
              call exit(1)
            ELSE IF((flag .EQ. 1 .OR. flag .EQ. 2)) THEN
              IF (( gle .LT. etmp(1) )) THEN
                sig = 0
              ELSE
                sig = exp(ftmp(ndat))
              END IF
            ELSE
              sig = 0
            END IF
          ELSE
            DO 7281 kk=1,ndat-1
              IF((gle .GE. etmp(kk) .AND. gle .LT. etmp(kk+1)))GO TO7282
7281        CONTINUE
7282        CONTINUE
            IF (( flag .NE. 3)) THEN
              p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk))
              sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk))
            ELSE
              p = (e - exp(etmp(kk)))/(exp(etmp(kk+1)) - exp(etmp(kk)))
              sig = p*exp(ftmp(kk+1)) + (1-p)*exp(ftmp(kk))
            END IF
          END IF
          IF(((flag .EQ. 1 .OR. flag .EQ. 2) .AND. e .GT. eth))sig = sig
     *    *(1-eth/e)**3
          data(k) = data(k) + pz_sorted(i)*sig
7271    CONTINUE
7272    CONTINUE
7231  CONTINUE
7232  CONTINUE
      return
7250  CONTINUE
      write(i_log,'(/a)') '***************** Error: '
      write(i_log,*) 'Error while reading user photon cross sections fro
     *m unit ', iunit
      write(i_log,'(/a)') '***************** Quiting now.'
      call exit(1)
      return
      end
      subroutine egsi_get_shell_data(imed,n,ne,zsorted,pz_sorted,ge1,ge0
     *,data)
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common /egs_io/ file_extensions(20), file_units(20), user_code,  i
     *nput_file,  output_file, pegs_file,  hen_house,  egs_home,  work_d
     *ir,  host_name,  n_parallel,  i_parallel,  first_parallel, n_max_p
     *arallel, n_chunk,  n_files, i_input,  i_log,  i_incoh,  i_nist_dat
     *a,  i_mscat,  i_photo_cs,  i_photo_relax,  xsec_out,  is_batch,  i
     *s_pegsless
      character input_file*256, output_file*256, pegs_file*256, file_ext
     *ensions*10, hen_house*128, egs_home*128, work_dir*128, user_code*6
     *4, host_name*64
      integer*4 n_parallel, i_parallel, first_parallel,n_max_parallel, n
     *_chunk, file_units, n_files,i_input,i_log,i_incoh, i_nist_data,i_m
     *scat,i_photo_cs,i_photo_relax, xsec_out
      logical is_batch,is_pegsless
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      COMMON/MEDIA_p/ RLC(max_med),RLDU(max_med),MSGE(max_med),MGE(max_m
     *ed),MSEKE(max_med),MEKE(max_med),MLEKE(max_med),MCMFP(max_med),MRA
     *NGE(max_med),IRAYLM(max_med),IPHOTONUCM(max_med), MEDIA(24,max_med
     *)
      CHARACTER*4 MEDIA
      EGS_Float RLC,RLDU
      integer*4 MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM, IPHOTONUC
     *M
      common/media/ rho(max_med),photon_xsections,eii_xfile, comp_xsecti
     *ons,photonuc_xsections, nmed
      EGS_Float rho
      integer*4 nmed
      character*16 photon_xsections
      character*16 eii_xfile
      character*16 comp_xsections
      character*16 photonuc_xsections
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,max_med),   pe_energy(500,100),  pe_zsorted(100,max_med), pe_
     *be(100,16),  pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      EGS_Float pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      integer*4 n,  ne,  ndat
      EGS_Float ge1,ge0,zsorted(*),pz_sorted(*),data(*)
      EGS_Float sigma(500),sigmaMedium
      real*4 etmp(2000),ftmp(2000)
      real*4 gle,sig,p
      integer*4 i,j,k,kk,iz,zpos,imed
      DO 7291 k=1,n
        data(k) = 0
7291  CONTINUE
7292  CONTINUE
      DO 7301 k=1,ne
        sigma(k) = 0
7301  CONTINUE
7302  CONTINUE
      DO 7311 i=1,ne
        iz = int(zsorted(i)+0.5)
        zpos = pe_zpos(iz)
        ndat = pe_nge(zpos)
        DO 7321 k=1,ndat
          pe_elem_prob(k,i,imed) = pz_sorted(i)*pe_xsection(k,zpos,0)
          etmp(k) = pe_energy(k,zpos)
          ftmp(k) = log(pe_xsection(k,zpos,0))
7321    CONTINUE
7322    CONTINUE
        DO 7331 k=1,n
          gle = (k - ge0)/ge1
          IF (( gle .LT. etmp(1) .OR. gle .GE. etmp(ndat) )) THEN
            write(i_log,'(/a)') '***************** Error: '
            write(i_log,*) 'egsi_get_shell_data: Energy ',exp(gle), ' is
     * outside the available data range of ', exp(etmp(1)),exp(etmp(ndat
     *      ))
            write(i_log,'(/a)') '***************** Quiting now.'
            call exit(1)
          ELSE
            DO 7341 kk=1,ndat-1
              IF((gle .GE. etmp(kk) .AND. gle .LT. etmp(kk+1)))GO TO7342
7341        CONTINUE
7342        CONTINUE
            p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk))
            sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk))
          END IF
          data(k) = data(k) + pz_sorted(i)*sig
7331    CONTINUE
7332    CONTINUE
7311  CONTINUE
7312  CONTINUE
      DO 7351 i=1,ne
        iz = int(zsorted(i)+0.5)
        zpos = pe_zpos(iz)
        ndat = pe_nge(zpos)
        DO 7361 k=1,ndat
          sig = sigmaMedium(imed,pe_energy(k,zpos))
          pe_elem_prob(k,i,imed) = log(pe_elem_prob(k,i,imed)/sig)
7361    CONTINUE
7362    CONTINUE
7351  CONTINUE
7352  CONTINUE
      return
      end
      EGS_Float function sigmaMedium(imed, logE)
      implicit none
      integer max_med
      parameter (max_med = MXMED)
      common/brempr/ DL1(8,max_med),DL2(8,max_med),DL3(8,max_med),DL4(8,
     *max_med),DL5(8,max_med),DL6(8,max_med), ALPHI(2,max_med),BPAR(2,ma
     *x_med),DELPOS(2,max_med), WA(max_med,50),PZ(max_med,50),ZELEM(max_
     *med,50),RHOZ(max_med,50), PWR2I(50), DELCM(max_med),ZBRANG(max_med
     *),LZBRANG(max_med),NNE(max_med), ASYM(max_med,50,2)
      CHARACTER*4 ASYM
      EGS_Float DL1,DL2,DL3,DL4,DL5,DL6,ALPHI,BPAR,DELPOS,WA,PZ,ZELEM, R
     *HOZ,PWR2I,DELCM,ZBRANG,LZBRANG
      integer*4 NNE
      common/pe_shell_data/ pe_xsection(500,100,0:16),  pe_elem_prob(500
     *,100,max_med),   pe_energy(500,100),  pe_zsorted(100,max_med), pe_
     *be(100,16),  pe_nshell(100),  pe_zpos(100),  pe_nge(100),  pe_ne
      EGS_Float pe_be, pe_energy, pe_xsection, pe_elem_prob
      integer*4 pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne
      EGS_Float logE, slope, sigma
      integer*4 k,imed,Z,zpos,m,ibsearch
      sigmaMedium = 0
      DO 7371 k=1,nne(imed)
        Z = int( zelem(imed,k) + 0.5 )
        zpos = pe_zpos(Z)
        m = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos))
        slope = log(pe_xsection(m+1,zpos,0)/pe_xsection(m,zpos,0))
        slope = slope/(pe_energy(m+1,zpos)-pe_energy(m,zpos))
        sigma = log(pe_xsection(m,zpos,0))
        sigma = sigma + slope*(logE - pe_energy(m,zpos))
        sigma = exp(sigma)
        sigmaMedium = sigmaMedium + pz(imed,k)*sigma
7371  CONTINUE
7372  CONTINUE
      return
      end
      subroutine egs_heap_sort(n,rarray,jarray)
      implicit none
      integer*4 n,jarray(*)
      EGS_Float rarray(*)
      integer*4 i,ir,j,l,ira
      EGS_Float rra
      DO 7381 i=1,n
        jarray(i)=i
7381  CONTINUE
7382  CONTINUE
      IF((n .LT. 2))return
      l=n/2+1
      ir=n
7391  CONTINUE
        IF ((l .GT. 1)) THEN
          l=l-1
          rra=rarray(l)
          ira=l
        ELSE
          rra=rarray(ir)
          ira=jarray(ir)
          rarray(ir)=rarray(1)
          jarray(ir)=jarray(1)
          ir=ir-1
          IF ((ir .EQ. 1)) THEN
            rarray(1)=rra
            jarray(1)=ira
            return
          END IF
        END IF
        i=l
        j=l+l
7401    CONTINUE
          IF((j .GT. ir))GO TO7402
          IF ((j .LT. ir)) THEN
            IF((rarray(j) .LT. rarray(j+1)))j=j+1
          END IF
          IF ((rra .LT. rarray(j))) THEN
            rarray(i)=rarray(j)
            jarray(i)=jarray(j)
            i=j
            j=j+j
          ELSE
            j=ir+1
          END IF
        GO TO 7401
7402    CONTINUE
        rarray(i)=rra
        jarray(i)=ira
      GO TO 7391
7392  CONTINUE
      return
      end
      SUBROUTINE PHOTONUC
      implicit none
      integer max_stack
      parameter (max_stack = MXSTACK)
      common/stack/ E(max_stack),X(max_stack),Y(max_stack),Z(max_stack),
     *U(max_stack),V(max_stack),W(max_stack),DNEAR(max_stack),WT(max_sta
     *ck),IQ(max_stack),IR(max_stack),LATCH(max_stack), LATCHI,NP,NPold
      DOUBLE PRECISION E
      EGS_Float X,Y,Z,U,V,W,DNEAR,WT
      integer*4 IQ,IR,LATCH,LATCHI,NP,NPold
      COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP, RHO
     *F,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE, x_final,y_final,z_final, u_final
     *,v_final,w_final, IDISC,IROLD,IRNEW,IAUSFL(35)
      DOUBLE PRECISION EDEP,  EDEP_LOCAL
      EGS_Float TSTEP,  TUSTEP,  USTEP,  VSTEP,  TVSTEP,  RHOF,  EOLD,
     *ENEW,  EKE,  ELKE,  GLE,  E_RANGE, x_final,y_final,z_final,  u_fin
     *al,v_final,w_final
      integer*4 IDISC,  IROLD,  IRNEW,  IAUSFL
      common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medi
     *um_new, medold
      real*8 pzero, prm, prmt2
      EGS_Float rm, rhor, rhor_new
      integer*4 medium, medium_new, medold
      data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D
     *0/
      npold = np
      edep = pzero
      e(np) = pzero
      wt(np) = 0
      return
      end
