%L
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc macros                                                              "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2000                                       "
"                   Dave Rogers, 2000                                         "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                   Ernesto Mainegra-Hing                                     "
"                   Frederic Tessier                                          "
"                   Reid Townson                                              "
"                   Victor Malkov                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"


"Compiler directives"
"==================="
%Q1         "Automatically close comments at end of line
            "but this DOES NOT apply withing macro definitions!!
%C80        "Allow 80 columns of source/line (default is 72)
%L          "Turn on listing


"=================================================================="
" Macros to implement implicit data types                          "
"=================================================================="

REPLACE {$LOGICAL} WITH {;logical}
REPLACE {$REAL}    WITH {;real*8}
REPLACE {$INTEGER} WITH {;integer*4}
REPLACE {$LONG_INT} WITH {;integer*8} "change this to integer*4 for compilers"
                                      "that do not support integer*8"
REPLACE {$SHORT_INT} WITH {;integer*2} "change this to integer*4 for compilers"
                                      "that do not support integer*2"
"the above is not used in EGSnrc but is used in the NRC user codes,
"especially related to number of histories"
"Note that the HP compiler does not support *8 integers so the above"
" should be changed for HP"

REPLACE {$IMPLICIT-NONE;} WITH {;}
REPLACE {$IMPLICIT-NONE;} WITH {implicit none;}

"=================================================================="
"SELECT THE FORTRAN STANDARD TO BE USED (1966 OR 1977)             "
REPLACE {$FORTVER} WITH {1977}
"=================================================================="

"******************************************************************"
REPLACE {$TYPE} WITH {
  {SETR F=$FORTVER}
   [IF] {COPY F}=1977 [CHARACTER*4] [ELSE] [INTEGER*4]
  }
"******************************************************************"

"******************************************************************"
SPECIFY ALPHA    AS (0...$);
SPECIFY SYMBOL   AS (0...?);
SPECIFY NAME     AS LETTER(0,5)[ALPHA];
SPECIFY <COMMA>  AS [','|''];
SPECIFY <NAME>   AS [NAME|''];
SPECIFY LABEL    AS ':'NAME':';
SPECIFY <LABEL>  AS [LABEL|''];
SPECIFY <*>      AS ['*'|''];
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {NEWLABEL} WITH {@LG}
REPLACE {%'{ARB}'={<*>}'{ARB}'}
   WITH {[IF] '{P2}'='*' [APPEND'{P3}'TO'{P1}']
            [ELSE] [ REPLACE {{P1}}WITH{{P3}}]}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

    "RULES TO GENERALIZE MORTRAN'S INPUT AND OUTPUT"
REPLACE {;$UINPUT(#)#;}
   WITH {;{SETR A=NEWLABEL}
            READ({P1},{COPY A}){P2};{COPY A}FORMAT}

REPLACE {;$UOUTPUT(#)#;}
   WITH {;{SETR A=NEWLABEL}
            WRITE({P1},{COPY A}){P2};{COPY A}FORMAT}

REPLACE {;$ECHO#({NAME}{<COMMA>}#)#;}
 WITH {;{SETR X=NEWLABEL}
 WRITE(IUECHO,{COPY X});{COPY X}FORMAT(' ECHO {P1}:{P5}');
 [IF] {EXIST 3} [{P1}({P2},{P4}){P5};
 WRITE(IUECHO,{P4}){P5};]
 [ELSE] [{SETR Y=NEWLABEL}{P1}({P2},{COPY Y}){P4};
 WRITE(IUECHO,{COPY Y}){P5};{COPY Y}FORMAT]
 }
;  "---------- BUFFER FLUSH SEMICOLON ----------"
REPLACE {;IUECHO=#;} WITH { REPLACE {IUECHO} WITH {{P1}};}
"INITALIZE" ;IUECHO=6;

"MACRO TO SPLIT STRING INTO A LIST SEPARATED BY COMMAS"
REPLACE {$S'{SYMBOL}#'}
  WITH {'{P1}'[IF]{EXIST 2}[,$S'{P2}']}

"SOME DEBUGGING MACROS"
REPLACE {$LIST#/#/#;} WITH
   {;OUTPUT {P3};('LIST/{P2}/{P3}:'/(1X,{P1}));}
APPEND{;COMMON/QDEBUG/QDEBUG;LOGICAL QDEBUG;} TO {;COMIN/DEBUG/;}

REPLACE {$TRACE#;} WITH
  {REPLACE {;{P1}={WAIT {ARB}};}  WITH
  {{EMIT;{P1}}={WAIT {P1}};
  IF QDEBUG [OUTPUT{P1};
  (' {P1} ASSIGNED {WAIT {P1}} ',G25.18);] }; }
REPLACE {$S1TRACE#;} WITH
  {{SETR A=NEWLABEL}
    REPLACE {;{P1}({WAIT {ARB}})={WAIT {ARB}};}
       WITH {{EMIT ;{P1}({WAIT {P1}})}={WAIT {P2}};
           IF QDEBUG [I{COPY A}={WAIT {P1}};
                OUTPUT I{COPY A},{P1}(I{COPY A});
                    (' {P1}(',I6,') ASSIGNED {WAIT {P2}} ' ,
                       G25.18);] } ;}

REPLACE {$TRACE#,#;} WITH {$TRACE{P1};$TRACE{P2};}
REPLACE {$S1TRACE#,#;} WITH {$S1TRACE{P1};$S1TRACE{P2};}

SPECIFY DELIM AS ['('|';'];
REPLACE {$CALLTRACE;} WITH
  {REPLACE {;CALL{NAME}{DELIM}} WITH
  {;IF (QDEBUG)[OUTPUT;
    (' SUBROUTINE {WAIT {P1}} CALLED.');]
         {WAIT {EMIT CALL} {P1}{P2}} };}

REPLACE {$DUMP#,#;} WITH
    {;{SETR A=NEWLABEL}
         V{COPY A}={P1};OUTPUT V{COPY A};(' {P1}=',1PG15.7);
         [IF] {EXIST 2} [$DUMP{P2};] ;}
   "NOTICE: THE LIST OF VARIABLES MUST BE FOLLOWED BY A COMMA"
   "FOR EXAMPLE $DUMP S,T(U,V),W,; OR $DUMP A,;"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MORTRAN MACRO DEFINITIONS FOR EGS."

"FIRST SOME PARAMETERS"
REPLACE {PARAMETER #=#;} WITH
   { REPLACE {{P1}} WITH {{P2}}}

PARAMETER $MXMED=10;      "MAX. NO. OF DIFFERENT MEDIA (EXCL. VAC.)"
PARAMETER $MXREG=2000;    "MAXIMUM NO. OF REGIONS ALLOCATED"
PARAMETER $MXSTACK=40;    "STACK SIZE"
PARAMETER $MXVRT1=1000;   "NO. OF REPRESENTATIVE ANGLES IN VERT1"
PARAMETER $FMXVRT1=1000.; "FLOATING $MXVRT1"
PARAMETER $MXPWR2I=50;    "SIZE OF TABLE OF INVERSE POWERS OF TWO"
PARAMETER $MXJREFF=200;   "SIZE OF MULTIPLE SCATTERING JREFF MAP"
PARAMETER $MSSTEPS=16;    "NO. OF MULTIPLE SCATTERING STEP SIZES"
PARAMETER $MXVRT2=100;    "DISTRBTN OF NONOVERLAPPING PARTS OF VERT"

;
"FOLLOWING DEFINE MAX. NO. OF INTERVALS FOR FIT TO FUNCTIONS"
PARAMETER $MXSGE=400;     "GAMMA SMALL ENERGY INTERVALS"
PARAMETER $MXGE=2000;     "GAMMA MAPPED ENERGY INTERVALS"
PARAMETER $MXSEKE=300;    "ELECTRON SMALL ENERGY INTERVALS"
PARAMETER $MXEKE=500;     "ELECTRON MAPPED ENERGY INTERVALS"
PARAMETER $MXEL=50;       "MAXIMUM # OF ELEMENTS IN A MEDIUM"
PARAMETER $MXLEKE=100;    "ELECTRON ENERGY INTERVALS BELOW EKELIM"
PARAMETER $MXCMFP=100;    "CUMULATIVE ELECTRON MEAN-FREE-PATH"
PARAMETER $MXRANGE=100;   "ELECTRON RANGE"
PARAMETER $MXBLC=20;      "MOLIERE'S LOWER CASE B"
PARAMETER $MXRNTH=20;     "RANDOM NUMBER FOR SUBMEDIAN ANGLES"
PARAMETER $MXRNTHI=20;    "RANDOM NUMBER FOR SUPERMEDIAN ANGLES"
PARAMETER $MXRAYFF=100;   "RAYLEIGH ATOMIC FORM FACTOR"
PARAMETER $RAYCDFSIZE=100;"CDF from RAYLEIGH FORM FACTOR SQUARED"
PARAMETER $MXSINC=1002;   "ANGLE INTERVALS IN (0,5*PI/2) FOR SINE"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"THE FOLLOWING ARE PARAMETERS FOR AUSGAB CALLS:"
PARAMETER $MXAUS=35;       "CHANGE IF MORE AUSGAB CALLS ARE ADDED"
PARAMETER $MXAUSM5=30;     "SET THIS TO $MXAUS VALUE LESS 5"

"FIRST FIVE AUSGAB CALLS BELOW TURNED ON IN BLOCK DATA (DEFAULT)"
PARAMETER $TRANAUSB=0;    "BEFORE TRANSPORT"
PARAMETER $EGSCUTAUS=1;   "ENERGY BELOW ECUT OR PCUT"
PARAMETER $PEGSCUTAUS=2;  "ENERGY BELOW AE OR AP"
PARAMETER $USERDAUS=3;    "USER REQUESTED DISCARD"
PARAMETER $PHOTXAUS=4;    "FLUORESCENT PHOTON DISCARD"

"THE REMAINING 23 ARE TURNED OFF IN BLOCK DATA (DEFAULT)"
PARAMETER $TRANAUSA=5;    "AFTER TRANSPORT"
PARAMETER $BREMAUSB=6;    "BEFORE BREMS CALL"
PARAMETER $BREMAUSA=7;    "AFTER BREMS CALL"
PARAMETER $MOLLAUSB=8;    "BEFORE MOLLER CALL"
PARAMETER $MOLLAUSA=9;    "AFTER MOLLER CALL"
PARAMETER $BHABAUSB=10;   "BEFORE BHABHA CALL"
PARAMETER $BHABAUSA=11;   "AFTER BHABHA CALL"
PARAMETER $ANNIHFAUSB=12; "BEFORE ANNIH CALL"
PARAMETER $ANNIHFAUSA=13; "AFTER ANNIH CALL"
PARAMETER $ANNIHRAUSB=28; "BEFORE POSITRON ANNIH AT REST"
PARAMETER $ANNIHRAUSA=14; "POSITRON ANNIHILATED AT REST"
PARAMETER $PAIRAUSB=15;   "BEFORE PAIR CALL"
PARAMETER $PAIRAUSA=16;   "AFTER PAIR CALL"
PARAMETER $COMPAUSB=17;   "BEFORE COMPT CALL"
PARAMETER $COMPAUSA=18;   "AFTER COMPT CALL"
PARAMETER $PHOTOAUSB=19;  "BEFORE PHOTO CALL"
PARAMETER $PHOTOAUSA=20;  "AFTER PHOTO CALL"
PARAMETER $UPHIAUSB=21;   "ENTERED UPHI"
PARAMETER $UPHIAUSA=22;   "LEFT UPHI"
PARAMETER $RAYLAUSB=23;   "BEFORE RAYLEIGH EVENT"
PARAMETER $RAYLAUSA=24;   "AFTER RAYLEIGH EVENT"
PARAMETER $FLUORTRA=25;   "A fluorescent transition just occurred"
PARAMETER $COSKROTRA=26;  "A Coster-Kronig transition just occurred"
PARAMETER $AUGERTRA=27;   "An Auger transition just occurred"
"Ali:photonuc, 2 lines"
" note that 28 is already used for positron annih at rest - see above"
PARAMETER $PHOTONUCAUSB=29; "BEFORE PHOTONUCLEAR EVENT"
PARAMETER $PHOTONUCAUSA=30; "AFTER PHOTONUCLEAR EVENT"
PARAMETER $EIIB=31;   "Before EII"
PARAMETER $EIIA=32;   "After EII"
PARAMETER $SPHOTONA=33;   "After sub-threshold photon energy deposition"
PARAMETER $SELECTRONA=34;   "After sub-threshold electron energy deposition"

;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {$AUSCALL(#);} WITH
   {IARG={P1} ;  IF (IAUSFL(IARG+1).NE.0) [CALL AUSGAB(IARG);]} ;
;  "---------- BUFFER FLUSH SEMICOLON ----------"
"TEMPORARY OVER-RIDES FOR SOME OF THE ABOVE"
PARAMETER $MXSGE=1;
PARAMETER $MXSEKE=1;
PARAMETER $MXLEKE=1;
PARAMETER $MXCMFP=1;
PARAMETER $MXRANGE=1;
PARAMETER $MXBLC=1;
PARAMETER $MXRNTH=1;
PARAMETER $MXRNTHI=1;
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"THE FOLLOWING DEFINE PRECISION USED IN ENERGY COMPUTATIONS"
"THE LATTER OF THE TWO WILL BE IN EFFECT"
REPLACE {$ENERGYPRECISION} WITH {;REAL }"SINGLE PRECISION"
REPLACE {$ENERGYPRECISION} WITH {;DOUBLE PRECISION }
REPLACE {$MAX_INT} WITH {2147483647} "2^31-1"
"^--- limits number of particles and hence phase space file size"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MACROS TO MAKE CHANGES IN THE DEGREE OF FIT EASIER"
"ALSO USEFUL FOR ABBREVIATING LISTS OF SUBSCRIPTED VARIABLES"
"$LGN STANDS FOR 'LIST GENERATOR'"
"$RSC MEANS THAT THE EXPANDED LIST SHOULD RESCANNED FOR FURTHER"
"OPERATIONS.  MACROS EXPECTING TO DO RESCANS SHOULD BE"
"DEFINED AFTER THE FOLLOWING MACRO"
REPLACE {$RSC(#)} WITH {{P1}}
"IF NOT MATCHED BY ANYTHING ELSE, REMOVE $RSC()"
REPLACE {$RSC(#),#$LSCALEBY#;} WITH
   {{P1}={P1}*{P3};{P2}$LSCALEBY{P3};}
REPLACE {$RSC(#)$LSCALEBY#;} WITH {{P1}={P1}*{P2};}
REPLACE {$LGN(#/#/)} WITH {$RSC({P1}{P2})}
REPLACE {$LGN(#(#)/#/)} WITH {$RSC({P1}{P3}({P2}))}
REPLACE {$LGN(#(#))} WITH {$RSC({P1}({P2}))}
REPLACE {$LGN(#/#,#/)} WITH
    {$LGN({P1}/{P2}/),$LGN({P1}/{P3}/)}
REPLACE {$LGN(#,#/#/)} WITH
    {$LGN({P1}/{P3}/),$LGN({P2}/{P3}/)}
REPLACE {$LGN(#(#)/#,#/)} WITH
    {$LGN({P1}({P2})/{P3}/),$LGN({P1}({P2})/{P4}/)}
REPLACE {$LGN(#,#(#)#)} WITH
    {$LGN({P1}({P3}){P4}),$LGN({P2}({P3}){P4})}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MACROS FOR SCALING REQUIRED BY CHANGE IN DISTANCE UNIT"
REPLACE {$SCALE# BY #;} WITH {{P1}={P1}*{P2};}
REPLACE {$SCALE#,# BY #;} WITH
    {{P1}={P1}*{P3};$SCALE{P2} BY {P3};}
REPLACE {$SCALE$LGN(#) BY #;} WITH
    {$LGN({P1})$LSCALE BY {P2};}
REPLACE {$SCALE$LGN(#),# BY #;} WITH
            {$LGN({P1})$LSCALE BY {P3};$SCALE{P2} BY {P3};}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"------------------------------------------------------------------
" Macros related to bit setting
"------------------------------------------------------------------
""
"Macro to set bit {P2} in {P1}  to 1
REPLACE {$IBSET(#,#);} WITH {ibset({P1},{P2});}

"Macro to set test bit {P2} in {P1}
"Note this may require a LOGICAL declaration wherever used
REPLACE {$BTEST(#,#)} WITH {btest({P1}, {P2})}

"Macro to set bit {P2} in {P1}  to 0
REPLACE {$IBCLR(#,#);} WITH {ibclr({P1},{P2});}
"Above used by RW_PH_SP routine - (read_write_phase_space for BEAM)


"COMMON BLOCK INSERTION MACROS"
REPLACE {;COMIN/#,#/;} WITH {;COMIN/{P1}/;COMIN/{P2}/;}

"NOW FOR SOME SPECIFIC COMMON BLOCKS"

"------------------------------------------------------------------"
"*** BOUNDS--CUTOFF ENERGIES & VACUUM TRANSPORT DISTANCE           "
"------------------------------------------------------------------"
REPLACE {;COMIN/BOUNDS/;} WITH
{
    ;COMMON/BOUNDS/ECUT($MXREG),PCUT($MXREG),VACDST;
     $REAL         ECUT,   "Minimum electron transport energy"
                   PCUT,   "Minimum photon transport energy"
                   VACDST; "Infinity (1E8)"
}

"------------------------------------------------------------------"
"*** BREMPR--BREMSSTRAHLUNG AND PAIR PRODUCTION DATA               "
"------------------------------------------------------------------"

;
REPLACE {$MXBREN} WITH {57}
REPLACE {$MXBRXX} WITH {54}
REPLACE {$MXBREL} WITH {100}
REPLACE {$MXGAUSS} WITH {64}
REPLACE {$MXBRES} WITH {100}
REPLACE {$MXBRXS} WITH {50}
REPLACE {$NIST-ENERGY-SCALE} WITH {1.0}

REPLACE {$NIST-DATA-UNIT} WITH {i_nist_data}
;

REPLACE {$COMIN-INIT-NIST-BREMS;} WITH {;
    ;COMIN/MEDIA,BREMPR,ELECIN,THRESH,USEFUL,NIST-BREMS,Spin-Data,EGS-IO/;
};

REPLACE {;COMIN/BREMPR/;} WITH
{
  ;COMMON/BREMPR/
             $LGN(DL(8,$MXMED)/1,2,3,4,5,6/),
             $LGN(ALPHI,BPAR,DELPOS(2,$MXMED)),
             $LGN(WA,PZ,ZELEM,RHOZ($MXMED,$MXEL)),
             PWR2I($MXPWR2I),
             $LGN(DELCM,ZBRANG,LZBRANG,NNE($MXMED)),
             IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet,
             ASYM($MXMED,$MXEL,2);
   $TYPE     ASYM;
   $REAL     $LGN(DL/1,2,3,4,5,6/), "Parameter for the fit of the screening"
                                    "rejection function, eq. (2.7.14 and 15)"
             ALPHI,  "Prob. for the (1-BR)/BR part in BREMS, eq. (2.7.64)"
             BPAR,   "Prob. for the 12*(BR-1/2)**2 part in PAIR, eq. (2.7.105)"
             DELPOS, "maximum delta, eq. (2.7.31)"
             WA,     "atomic weight"
             PZ,     "atomic fraction of an element in a compound"
             ZELEM,  "Z for a given component"
             RHOZ,   "density of an element in a compound"
             PWR2I,  "powers of 1/2 (used for sampling (1-BR)/BR"
             DELCM,  "136*m*exp(Zg), eq. (2.7.51)"
             ZBRANG, "composite factor for angular distributions"
             LZBRANG;"-Log(ZBRANG)"
   $INTEGER  NNE,    "number of elements/compound"
             IBRDST, "flag to switch on bremsstrahlung angular distributions"
             IPRDST, "flag to switch on pair angular distributions"
             ibr_nist,  "use the NIST bremsstrahlung cross sections"
             itriplet,  "if set to 1, explicitely simulate triplet events"
             pair_nrc;  "=0 => use Bethe-Heitler pair cross sections"
                        "=1 => use the NRC pair cross sections"
};

REPLACE {;COMIN/NIST-BREMS/;} WITH {;

  common/nist_brems/ nb_fdata(0:$MXBRXS,$MXBRES,$MXMED),
                     nb_xdata(0:$MXBRXS,$MXBRES,$MXMED),
                     nb_wdata($MXBRXS,$MXBRES,$MXMED),
                     nb_idata($MXBRXS,$MXBRES,$MXMED),
                     nb_emin($MXMED),nb_emax($MXMED),
                     nb_lemin($MXMED),nb_lemax($MXMED),
                     nb_dle($MXMED),nb_dlei($MXMED),
                     log_ap($MXMED);
  $REAL    nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lemax,
           nb_dle,nb_dlei,log_ap;
  $INTEGER nb_idata;
};

REPLACE {$NRC-PAIR-NXX} WITH {65};
REPLACE {$NRC-PAIR-NEE} WITH {84};
REPLACE {$NRC-PAIR-NX-1} WITH {64};
REPLACE {$NRC-PAIR-NE-1} WITH {83};

REPLACE {;COMIN/NRC-PAIR-DATA/;} WITH {;
    common/nrc_pair/ nrcp_fdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
                     nrcp_wdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
                     nrcp_idata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
                     nrcp_xdata($NRC-PAIR-NXX),
                     nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
    $REAL            nrcp_fdata,nrcp_wdata,nrcp_xdata,
                     nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
    $INTEGER         nrcp_idata;
};

"------------------------------------------------------------------------"
"*** TRIPLET DATA                                                        "
"------------------------------------------------------------------------"
REPLACE {$MAX_TRIPLET} WITH {250}
REPLACE {;COMIN/TRIPLET-DATA/;} WITH {;
        common/triplet_data/ a_triplet($MAX_TRIPLET,$MXMED),
                             b_triplet($MAX_TRIPLET,$MXMED),
                             dl_triplet, dli_triplet, bli_triplet, log_4rm;
        $REAL                a_triplet,b_triplet,dl_triplet, dli_triplet,
                             bli_triplet, log_4rm;
};

"------------------------------------------------------------------------"
"*** COMPTON-DATA -- Incoherent scattering data                          "
"------------------------------------------------------------------------"
REPLACE {$MXTOTSH}   WITH {1538} "Total number of shells for Z=1..100    "
REPLACE {$MXMDSH}    WITH {200}   "Max. number of shells per medium       "
REPLACE {$INCOHUNIT} WITH {i_incoh}   "Unit number for compton data           "

REPLACE {;COMIN/COMPTON-DATA/;} WITH
{
  ;common/compton_data/ iz_array($MXTOTSH), "Atomic number for each shell"
                        be_array($MXTOTSH), "Shell binding energies      "
                        Jo_array($MXTOTSH), "Compton profile parameter   "
                        erfJo_array($MXTOTSH),"needed for the calculation"
                                            "of the incoherent scattering"
                                            "function                    "
                        ne_array($MXTOTSH), "Occupation number           "
                        shn_array($MXTOTSH),"shell type                  "
                                            "(=1     for K,              "
                                            " =2,3,4 for L1,L2,L3        "
                                            " =5     for M               "
                                            " =6     for N               "
                                            " =7     for all others      "
                        shell_array($MXMDSH,$MXMED),
                        eno_array($MXMDSH,$MXMED),
                        eno_atbin_array($MXMDSH,$MXMED),
                        n_shell($MXMED),
                        radc_flag,          "flag for radiative corrections"
                        ibcmp($MXREG);      "flag to turn on binding effects"
   $INTEGER             iz_array,ne_array,shn_array,eno_atbin_array,
                        shell_array,n_shell,radc_flag;
   $REAL                be_array,Jo_array,erfJo_array,eno_array;
   $SHORT_INT           ibcmp;
}


"------------------------------------------------------------------ "
"*** EDGE -- Containes binding energies for K,L1,L2,L3,             "
"             'average' M and 'average' N shells; photo-absorption  "
"             interaction probabilities with these shells;          "
"             + fluorescence, Auger, Coster-Kronig transition       "
"             probabilities                                         "
"             IEDGFL is a flag for turning on/off atomic relaxations"
"             IPHTER is a flag for turning on/off photo-lectron     "
"                    angular distribution                           "
"             both are left-overs from the previous coding          "
"             Have put now also data to calculate elemental PE      "
"             cross sections needed to sample the element the photon"
"             is interacting with.
"------------------------------------------------------------------ "
REPLACE {$MXELEMENT} WITH {100}  " Number of elements               "
REPLACE {$MXSHXSEC}  WITH {30}   " Number of shells available       "
REPLACE {$MXSHELL}   WITH {6}    " Number of shells treated         "
REPLACE {$MXINTER}   WITH {5}    " $MXSHELL-1                       "
REPLACE {$MXTRANS}   WITH {39}   " Number of possible transitions   "
REPLACE {$MXEDGE}    WITH {16}   " max. number of edges above 1 keV "
REPLACE {$PHOTOUNIT} WITH {i_photo_relax} " unit number for photo_relax.data "
REPLACE {$PHOCSUNIT} WITH {i_photo_cs}   " unit number for photo_cs.data    "

REPLACE {;COMIN/EDGE/;} WITH
{;
   COMMON/EDGE/binding_energies($MXSHXSEC,$MXELEMENT),
               interaction_prob($MXSHELL,$MXELEMENT),
               relaxation_prob($MXTRANS,$MXELEMENT),
               edge_energies($MXEDGE,$MXELEMENT),
               edge_number($MXELEMENT),
               edge_a($MXEDGE,$MXELEMENT),
               edge_b($MXEDGE,$MXELEMENT),
               edge_c($MXEDGE,$MXELEMENT),
               edge_d($MXEDGE,$MXELEMENT),
               IEDGFL($MXREG),IPHTER($MXREG);
   $REAL       binding_energies, " K,L1,L2,L3,M,N binding energies  "
               interaction_prob, " prob. for interaction with one of"
                                 " the above shells (provided photon"
                                 " energy is above be)              "
               relaxation_prob,  " relaxation probabilities         "
               edge_energies,    " photo-absorption edge energies   "
               edge_a,edge_b,edge_c,edge_d;
                                 " photo cross section fit parameters "
   $SHORT_INT  IEDGFL,  "flag for switching on fluorscent emission"
               IPHTER;  "flag for switching on photo-electron angular distr."
   $INTEGER    edge_number; " number of `edges' for each element"
}

"------------------------------------------------------------------"
"*** ELECIN--ELECTRON TRANSPORT INPUT                              "
"        MODIFIED 1989/12/19 TO INCLUDE IUNRST,EPSTFL AND IAPRIM   "
"        NRC DWOR                                                  "
"------------------------------------------------------------------"
REPLACE {;COMIN/ELECIN/;} WITH
{;
   COMMON/ELECIN/
   esig_e($MXMED),psig_e($MXMED),
   esige_max, psige_max,
   range_ep(0:1,$MXEKE,$MXMED),
   E_array($MXEKE,$MXMED),
   $LGN(etae_ms,etap_ms,q1ce_ms,q1cp_ms,q2ce_ms,q2cp_ms,
        blcce($MXEKE,$MXMED)/0,1/),
   $LGN(EKE($MXMED)/0,1/),
   $LGN(XR0,TEFF0,BLCC,XCC($MXMED)),
   $LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,TMXS($MXEKE,$MXMED)/0,1/),
   expeke1($MXMED),
   IUNRST($MXMED),EPSTFL($MXMED),IAPRIM($MXMED),
   sig_ismonotone(0:1,$MXMED);
   $REAL    esig_e,        "maximum electron cross section per energy loss"
                           "for each medium"
            psig_e,        "maximum positron cross section per energy loss"
                           "for each medium"
            esige_max,     "maximum electron cross section per energy loss"
            psige_max,     "maximum electron cross section per energy loss"
            range_ep,      "electron (0) or positron (1) range"
            E_array,       "table energies"
            etae_ms0,etae_ms1,
                           "for interpolation of screening parameter (e-)"
            etap_ms0,etap_ms1,
                           "for interpolation of screening parameter (e+)"
            q1ce_ms0,q1ce_ms1,
                          "for interpolation of q1 correction due to spin (e-)"
            q1cp_ms0,q1cp_ms1,
                          "for interpolation of q1 correction due to spin (e+)"
            q2ce_ms0,q2ce_ms1,
                          "for interpolation of q2 correction due to spin (e-)"
            q2cp_ms0,q2cp_ms1,
                          "for interpolation of q2 correction due to spin (e+)"
            blcce0,blcce1,"for interpolation of scattering power correction   "
                          "necessary to account for scattering already taken  "
                          "into account in discrete Moller/Bhabha             "
            expeke1,       "Exp(1/eke1)-1"
            $LGN(EKE/0,1/),"table for kinetic energy indexing"
            XR0,           "unused, but read in HATCH"
            TEFF0,         "unused, but read in HATCH"
            BLCC,          "b lower case sub c"
            XCC,           "chi sub-c-c"
            ESIG0,ESIG1,   "used for electron cross section interpolation"
            PSIG0,PSIG1,   "used for positron cross section interpolation"
            EDEDX0,EDEDX1, "used for electron dE/dx interpolation"
            PDEDX0,PDEDX1, "used for positron dE/dx interpolation"
            EBR10,EBR11,   "used for e- branching into brems interpolation"
            PBR10,PBR11,   "used for e+ branching into brems interpolation"
            PBR20,PBR21,   "used for e+ branching into Bhabha interpolation"
            TMXS0,TMXS1;   "used for maximum step-size interpolation"
   $INTEGER IUNRST,        "flag for type of stopping power (see PEGS4)"
            EPSTFL,        "flag for ICRU37 collision stopping powers"
            IAPRIM;        "flag for ICRU37 radiative stopping powers"
   $LOGICAL sig_ismonotone;"true, if cross section is an increasing function"
                           "of energy, false otherwise"
}

"***************************************************************************"
"                                                                           "
" ------------ common block for EII data -----------------                  "
"
" Added by Iwan Kawrakow, March 20 2004.
"                                                                           "
"****************************************************************************

REPLACE {$MAX_EII_SHELLS} WITH {40};  "Maximum number of shells participating"
                                      "in EII in a simulation                "
REPLACE {$N_EII_BINS} WITH {250};     "Number of bins for EII x-section      "
                                      "interpolations                        "
REPLACE {$MAX_EII_BINS} WITH {{COMPUTE $N_EII_BINS*$MAX_EII_SHELLS}};
"We store the EII x-section interpolation coefficients in 1D arrays  "
"The above is the dimension of these arrays required to hold the data"
REPLACE {;COMIN/EII-DATA/;} WITH {;
    common/eii_data/
        eii_xsection_a($MAX_EII_BINS), "EII x-section interpolation coeff."
        eii_xsection_b($MAX_EII_BINS), "EII x-section interpolation coeff."
        eii_cons($MXMED),
        eii_a($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
        eii_b($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
        eii_L_factor,                  "L-shell EII xsection scaling factor"
        eii_z($MAX_EII_SHELLS),        "Z of each shell                   "
        eii_sh($MAX_EII_SHELLS),       "shell type (1=K, 2=LI, eyc.)      "
        eii_nshells($MXELEMENT),       "No. of EII shells for each element"
        eii_nsh($MXMED),               "No. of EII shells for each medium "
        eii_first($MXMED,$MXEL),       "First EII shell in the list of shells"
        eii_no($MXMED,$MXEL),          "N. of EII shells                  "
        eii_flag;                      "EII flag                          "
                                       "         = 0 => no EII            "
                                       "         = 1 => simple EII        "
                                       "         > 1 => future use        "
    $REAL     eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_factor;
    $INTEGER  eii_z,eii_sh,eii_nshells;
    $INTEGER  eii_first,eii_no;
    $INTEGER  eii_elements,eii_flag,eii_nsh;
};

REPLACE {$COMIN-EII-SAMPLE;} WITH {
    ;COMIN/EPCONT,EII-DATA,EGS-VARIANCE-REDUCTION,RANDOM,STACK,THRESH,
           UPHIOT,USEFUL,EGS-IO,RELAX-DATA/;
};
REPLACE {$COMIN-EII-INIT;} WITH {
    ;COMIN/BREMPR,EDGE,EGS-IO,EII-DATA,ELECIN,MEDIA,THRESH,USEFUL/;
};

REPLACE {;COMIN/EMF-INPUTS/;} WITH {;
    common/emf_inputs/ExIN,EyIN,EzIN, "E field"
                     EMLMTIN,         "Ekin, u, E fractional maximum change"
                     BxIN, ByIN, BzIN,       "B field: initial region"
                     Bx, By, Bz,             "B field: current region"
                     Bx_new, By_new, Bz_new, "B field: in new region"
                     emfield_on;             "true if EM fields not null"

   $REAL    ExIN,EyIN,EzIN,
            EMLMTIN,
            BxIN,ByIN,BzIN,
            Bx,By,Bz,
            Bx_new,By_new,Bz_new;
   $LOGICAL emfield_on;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"
" The following common block is made available to the user so that  "
" he/she knows which shell was being relaxed when the call to ausgab"
" occured                                                           "
" Added by Iwan Kawrakow, March 22 2004.                            "

REPLACE {;COMIN/RELAX-USER/;} WITH {;
   common/user_relax/ u_relax,ish_relax,iZ_relax;
   $REAL              u_relax;
   $INTEGER           ish_relax, iZ_relax;
};


;  "---------- BUFFER FLUSH SEMICOLON ----------"
"***************************************************************************"
"                                                                           "
" ------------ common blocks for EADL relaxation data -----------------     "
"
" Added by Ernesto Mainegra, June 1st 2011.                                 "
"                                                                           "
"***************************************************************************"
"shell in one long list, avoiding repetition (i.e. if an element is present"
"in different materials, its shell structure and information will be stored"
"only once in the list). The array shell_eadl(Z,i) tells us the position of"
"the i'th shell of element Z in the long shell list.                       "
"***************************************************************************"

REPLACE {$MXESHLL} WITH {30}     "max. number of shells for an element"
REPLACE {$MAXSHELL} WITH {3000}  "max. number of shells"
REPLACE {$MAXRELAX} WITH {10000} "max. number of relaxations channels"
REPLACE {$MAXVAC} WITH {100}     "max. number of vacancies"
REPLACE {$MAXTRANS} WITH {300}   "max. number of transitions per element"
"============================================================"
" Set input key 'Atomic relaxations' to 'simple' to recover original
" implementation which allows photoelectric interactions with <M> and
" <N> shells. See below for details on the shells considered by different
" interactions depending on the value of eadl_relax:
"
"      Interaction        .false.             .true.
"      -----------------------------------------
"      Compton                all available shells
"      EII                K,L1..L3            K,L1..L3
"      Photoeffect        K,L1..L3,<M>,<N>    K,L1..L3
"      Shellwise
"      Photoeffect             N/A      All shells > $RELAX-CUTOFF
"      Relaxation
"        initial vacancy  K,L1..L3,<M>        K,L1..L3
"        (for new photoeffect)                K, L1..L3, M1..M5, N1..N4
"        final vacancy    L1..L3,<M>,<N>      L1..L3,M1..M5,N1..N7...
"
"============================================================"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {;COMIN/SHELL-DATA/;} WITH {;

  common/shell_data/
    shell_be($MAXSHELL),      "binding energies"
    shell_type($MAXSHELL),    "shell type according to EADL notation"
    shell_num($MAXSHELL),     "the shell position in the element"
    shell_Z($MAXSHELL),       "Z of the element the shell belongs to"
    shell_eadl($MXELEMENT,$MXESHLL), "global index for a shell of element Z"
    shell_ntot;               "total number of shells in the list"
  $REAL    shell_be;
  $INTEGER shell_type,shell_Z,shell_ntot,shell_num,shell_eadl;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {;COMIN/RELAX-DATA/;} WITH {;

  common/relax_data/
    relax_first($MAXSHELL),    "first transition"
    relax_ntran($MAXSHELL),    "number of transitions"
    relax_state($MAXRELAX),    "final state of the transition"
    relax_prob($MAXRELAX),     "probability"
    relax_atbin($MAXRELAX),    "used for alias sampling"
    relax_ntot;                "total number of transitions in the list"
  $REAL     relax_prob;
  $INTEGER  relax_first, relax_ntran, relax_state, relax_atbin, relax_ntot;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {;COMIN/RELAX-FOR-USER/;} WITH {;
    common/relax_for_user/
     rfu_E0, "binding energy of vacancy that initiated cascade"
     rfu_E,  "binding energy of current vacancy"
     rfu_Z,  "Atomic number of the element the relaxing shell belongs to"
     rfu_j0, "shell numb. of vacancy that initiated cascade in the list"
     rfu_n0, "same but number is shell number in the element"
     rfu_t0, "same but number is shell type according to EADL notation"
     rfu_j,  "shell number of current vacancy"
     rfu_n,  "same but number is shell number in the element"
     rfu_t;  "same but number is shell type according to EADL notation"
    $INTEGER rfu_Z,rfu_j0,rfu_n0,rfu_t0,rfu_j,rfu_n,rfu_t;
    $REAL    rfu_E0,rfu_E;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {$COMIN-RELAX-INIT;} WITH {
;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
RELAX-DATA,SHELL-DATA/;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {$COMIN-RELAX-EADL;} WITH {
;COMIN/RELAX-DATA,RELAX-FOR-USER,SHELL-DATA,
STACK,THRESH,EPCONT,USEFUL,UPHIOT,RANDOM,BOUNDS,EGS-IO,MISC,MEDIA,
X-OPTIONS/;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"***************************************************************************"
"                                                                           "
" -------------- shell-wise photoelectric cross section data ------------   "
"
" Cross sections taken from Sabbatucci and Salvat,                          "
" Theory and calculation of the atomic photoeffect                          "
" Radiat. Phys. and Chem., Volume 121, April 2016, Pages 122-140            "
"                                                                           "
"***************************************************************************"
" Shell-wise photoelectric cross sections from 50 eV up to 1 GeV for elements
" from Z=1 up to Z=99. All K, L, M, and N shells are included. One can define
" a threshold energy separating inner from outer shells. By default this
" energy is set to 1 keV, but for accurate calculation of quantities that  "
" require knowledge of which particle deposited the energy, one might need to
" use the a lower threshold.
"***************************************************************************"
"============================================================"
REPLACE {$RELAX-CUTOFF} WITH {0.001"threshold energy for outer shells"}
REPLACE {$MXPESHELL} WITH {16} "K,L1..L3,M1..M5,N1..N7 + outer shell"
REPLACE {$MXNE} WITH {500}     "number of energy points per shell "
"============================================================"
REPLACE {;COMIN/PE-SHELL-DATA/;} WITH {;

  common/pe_shell_data/
    pe_xsection($MXNE,$MXELEMENT,0:$MXPESHELL),  "shellwise cross sections"
    pe_elem_prob($MXNE,$MXELEMENT,$MXMED), "prob. of interaction with an"
                                           "element of a medium"
    pe_energy($MXNE,$MXELEMENT),    "energy grid"
    pe_zsorted($MXELEMENT,$MXMED),"sorted array of Z for each medium"
    pe_be($MXELEMENT,$MXPESHELL),      "binding energies"
    pe_nshell($MXELEMENT),       "number of shells for each element"
    pe_zpos($MXELEMENT),       "position of each Z element"
    pe_nge($MXELEMENT),       "number of energy points for each element"
    pe_ne;                    "number of elements in the simulation"
  $REAL    pe_be, pe_energy, pe_xsection, pe_elem_prob;
  $INTEGER pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne;
};
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {$COMIN-SHELLWISE-PE-INIT;} WITH {
;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
    PE-SHELL-DATA/;
};


;  "---------- BUFFER FLUSH SEMICOLON ----------"
" Some macros for C-style syntax in mortran "
" Unfortunately, /= doesn't work because of /v1,v2,...,vn/=value;"

REPLACE {;#+=#;} WITH { ;{P1} = {P1} + {P2}; }
REPLACE {[#+=#;} WITH { {P1} = {P1} + {P2}; }

REPLACE {;#-=#;} WITH { ;{P1} = {P1} - {P2}; }
REPLACE {[#-=#;} WITH { {P1} = {P1} - {P2}; }

REPLACE {;#*=#;} WITH { ;{P1} = {P1}*{P2}; }
REPLACE {[#*=#;} WITH { {P1} = {P1}*{P2}; }

;  "---------- BUFFER FLUSH SEMICOLON ----------"
"***************************************************************************"

REPLACE {;COMIN/ET-Control/;} WITH  "ET stands for Electron Transport"
{
  ;common/ET_control/
              smaxir($MXREG),estepe,ximax,
              "ximin_for_bca,"
              skindepth_for_bca,transport_algorithm,
              bca_algorithm,exact_bca,spin_effects;
    $REAL     smaxir,             "geom. step-size constrain for each region"
              estepe,             "global energy loss constrain"
              ximax,              "max. first GS moment per step"
                                  "(roughly half the average MS angle squared"
              "ximin_for_bca,"
                                  "min. first GS moment per step for boundary"
                                  "crossing in VMC mode"
              skindepth_for_bca;  "distance from a boundary (in elastic MFP)"
                                  "to switch to one of the BCAs "
    $INTEGER  transport_algorithm,"=$PRESTA-II or $PRESTA--I"
              bca_algorithm;      "will be used if other inexact BCAs"
                                  "implemented in the future"
    $LOGICAL  exact_bca,          "if .true. => BCA in single scattering mode"
              spin_effects;       "if .true. electron/positron spin effects"
                                  "are taken into account in the single and"
                                  "multiple elasting scattering routines"
}
;

" ======================== multiple scattering commons ================= "

" Screened Rutherford MS data "

REPLACE {$MAXL_MS}    WITH {63}
REPLACE {$MAXQ_MS}    WITH {7}
REPLACE {$MAXU_MS}    WITH {31}
REPLACE {$0-MAXL_MS}  WITH {0:63}
REPLACE {$0-MAXQ_MS}  WITH {0:7}
REPLACE {$0-MAXU_MS}  WITH {0:31}
REPLACE {$LAMBMIN_MS} WITH {1.}
REPLACE {$LAMBMAX_MS} WITH {1e5}
REPLACE {$QMIN_MS}    WITH {1e-3}
REPLACE {$QMAX_MS}    WITH {0.5}

REPLACE {COMIN/MS-Data/;} WITH {
  common/ms_data/
              ums_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
              fms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
              wms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
              ims_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
              llammin,llammax,dllamb,dllambi,dqms,dqmsi;
  real*4      ums_array,fms_array,wms_array,
              llammin,llammax,dllamb,dllambi,dqms,dqmsi;
  $SHORT_INT  ims_array;
}
;

" spin effect data used in an additional rejection loop "

REPLACE {$MAXE_SPIN}   WITH {15}
REPLACE {$MAXE_SPI1}   WITH {{COMPUTE 2*$MAXE_SPIN+1}}
REPLACE {$MAXQ_SPIN}   WITH {15}
REPLACE {$MAXU_SPIN}   WITH {31}
REPLACE {$0-MAXE_SPI1} WITH {0:$MAXE_SPI1}
REPLACE {$0-MAXQ_SPIN} WITH {0:$MAXQ_SPIN}
REPLACE {$0-MAXU_SPIN} WITH {0:$MAXU_SPIN}

REPLACE {COMIN/Spin-Data/;} WITH {
  common/spin_data/
              spin_rej($MXMED,0:1,$0-MAXE_SPI1,$0-MAXQ_SPIN,$0-MAXU_SPIN),
              espin_min,espin_max,espml,b2spin_min,b2spin_max,
              dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i,
              fool_intel_optimizer;
  real*4      spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max,
              dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i;
  $LOGICAL    fool_intel_optimizer;
}
;

REPLACE {COMIN/CH-Steps/;} WITH
{
  common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step;
  real*8           count_pII_steps,count_all_steps;
  $LOGICAL         is_ch_step;
}
;
"------------------------------------------------------------------"
"*** EPCONT--ELECTRON-PHOTON CONTROL VARIABLES                     "
"------------------------------------------------------------------"
REPLACE {;COMIN/EPCONT/;} WITH
{;
  COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP,
                RHOF,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE,
                x_final,y_final,z_final,
                u_final,v_final,w_final,
                IDISC,IROLD,IRNEW,IAUSFL($MXAUS);
    $ENERGY PRECISION EDEP,   "energy deposition in MeV"
                      EDEP_LOCAL; "local energy deposition in MeV"
    $REAL             TSTEP,  "distance to a discrete interaction"
                      TUSTEP, "intended step length, befor check with geometry"
                      USTEP,  "transport distance calculated from TUSTEP"
                      VSTEP,  "transport distance after truncation by HOWFAR"
                      TVSTEP, "curved path-length calculated from TVSTEP"
                      RHOF,   "mass density ratio"
                      EOLD,   "energy before deduction of energy loss"
                      ENEW,   "energy after  deduction of energy loss"
                      EKE,    "kinetic energy"
                      ELKE,   "Log(EKE)"
                      GLE,    "Log(energy) in PHOTON"
                      E_RANGE,"range of electron before an iarg=0 ausgab call"
                      x_final,y_final,z_final, "position at end of step"
                      u_final,v_final,w_final; "direction at end of step"
                                               "only set (and relevant) "
                                               "for electrons"
    $INTEGER          IDISC,  "flag indicating user discard"
                      IROLD,  "region before transport"
                      IRNEW,  "region after transport"
                      IAUSFL; "flags for AUSGAB calls"
}

"------------------------------------------------------------------"
"*** MEDIA--NAMES OF MEDIA CURRENTLY BEING USED                    "
"------------------------------------------------------------------"
REPLACE {;COMIN/MEDIA/;} WITH
{;
   COMMON/MEDIA/
"Ali:photonuc, 4 lines (order matters because of padding issues)"
       $LGN(RLC,RLDU,RHO,MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,
            IRAYLM,IPHOTONUCM($MXMED)),
            MEDIA(24,$MXMED), photon_xsections, comp_xsections,
            photonuc_xsections,eii_xfile,IPHOTONUC,NMED;
   $TYPE    MEDIA;"media names"
   $REAL    RLC,  "radiation length in centimeters for a given medium"
            RLDU, "radiation length after user scaling over-ride"
            RHO,  "mass density of a given medium"
            apx, upx;"new photon xsection data thresholds"
   $INTEGER MSGE, "??? "
            MGE,  "number of photon mapped energy intervals for a given medium"
            MSEKE,"??? "
            MEKE, "number of e mapped energy intervals for a given medium"
            MLEKE,"??? "
            MCMFP,"??? "
            MRANGE,"??? "
            IRAYLM,"Rayleigh switch for a given medium"
"Ali:photonuc, 2 lines"
            IPHOTONUCM,"photonuclear switch for a given medium"
            IPHOTONUC,"set to 1 if any IPHOTONUCM is set to 1"
            NMED;  "number of media"
   character*16 eii_xfile;
            "Defaults to eii_ik.data if On or Off options selected"
            "which is the EII implemented by Iwan for EGSnrc"
            "else, following options available: "
            "  eii_'casnati'.data    "
            "  eii_'kolbenstvedt'.data "
            "  eii_'gryzinski'.data"
            "these must be in $HEN_HOUSE/data"
   character*16 photon_xsections;
            "If photon_xsections is not empty, photon cross sections will be"
            "re-initialized using data files  "
            "  'photon_xsection'_photo.data   "
            "  'photon_xsection'_pair.data    "
            "  'photon_xsection'_triplet.data "
            "  'photon_xsection'_rayleigh.data"
            "that must be placed in $HEN_HOUSE/data"
   character*16 comp_xsections;
            "If comp_xsections is not empty or not set to 'default' and"
            "bound Compton scattering is On, then total Compton cross sections"
            "will be taken from 'comp_xsections'_compton.data"
            "instead of being computed from the theoretical expressions"
"Ali:photonuc, 5 lines"
   character*16 photonuc_xsections;
            "If photonuc_xsections is not empty or not set to 'default',"
            "the photonuclear cross sections will be taken from"
            "'photonuc_xsections'_photonuc.data instead of using the data"
            "in the default file iaea_photonuc.data."
}

"------------------------------------------------------------------"
"*** MISC--MISCELLANEOUS COMMON                                    "
"------------------------------------------------------------------"
REPLACE {;COMIN/MISC/;} WITH
{;
  COMMON/MISC/
"Ali:photonuc, 1 line"
           DUNIT,KMPI,KMPO,$LGN(RHOR,MED,IRAYLR,IPHOTONUCR($MXREG));
  $REAL    DUNIT,   "unit scaling factor"
           RHOR;    "density of a given region"
  $INTEGER KMPI,    "fortran unit number of the pegs4 datafile"
           KMPO;    "fortran unit number of pegs4 echo file"
  $SHORT_INT MED,   "medium number for a given region"
             IRAYLR,"Rayleigh switch for a given region"
"Ali:photonuc, 1 line"
             IPHOTONUCR;"photonuclear switch for a given region"
}
;

"------------------------------------------------------------------"
"*** PHOTIN--PHOTON TRANSPORT DATA                                 "
"------------------------------------------------------------------"
REPLACE {;COMIN/PHOTIN/;} WITH
{;
    COMMON/PHOTIN/
       EBINDA($MXMED),
       $LGN(GE($MXMED)/0,1/),
       $LGN(GMFP,GBR1,GBR2($MXGE,$MXMED)/0,1/),
       $LGN(RCO($MXMED)/0,1/),
       $LGN(RSCT($MXRAYFF,$MXMED)/0,1/),
       $LGN(COHE($MXGE,$MXMED)/0,1/),
"Ali:photonuc, 1 line"
       $LGN(PHOTONUC($MXGE,$MXMED)/0,1/),
       DPMFP,
       MPGEM($MXSGE,$MXMED),
       NGR($MXMED);
    $REAL
       EBINDA,      "energy of the K-edge for a given medium"
       GE0,GE1,     "used for indexing in logarithmic interpolations"
       GMFP0,GMFP1, "used for gamma MFP interpolation"
       GBR10,GBR11, "used for branching into pair interpolation"
       GBR20,GBR21, "used for branching into Compton interpolation"
       RCO0,RCO1,   "used for indexing in momentum trans. sampling in Rayleigh"
       RSCT0,RSCT1, "used for interpolation of momentum trans. func. in R"
       COHE0,COHE1, "used for Rayleigh modification interpolation"
"Ali:photonuc, 1 line"
       PHOTONUC0,PHOTONUC1, "used for photonuclear modification interpolation"
       DPMFP;       "number of MFP's to go to the next interaction"
    $INTEGER
       MPGEM,       "??? "
       NGR;         "array size for Rayleigh scattering data"
}
;

"------------------------------------------------------------------"
"*** RANDOM - DECLARATIONS FOR RANDOM NUMBER GENERATOR             "
"------------------------------------------------------------------"

" Note that the definition of the COMIN/RANDOM/ was taken out of   "
" the egsnrc.macros file. The current philosophy is that the user  "
" has to provide a random number generator in a separate file.     "
" Two commonly used RNGs are provided in separate files:           "
"  RANLUX: ranlux.macros and ranlux.mortran                        "
"  RANMAR: ranmar.macros and ranmar.mortran                        "


"------------------------------------------------------------------"
"*** STACK--INFORMATION KEPT ABOUT CURRENT PARTICLES               "
"------------------------------------------------------------------"
REPLACE {;COMIN/STACK/;} WITH
{;
   COMMON/STACK/
       $LGN(E,X,Y,Z,U,V,W,DNEAR,WT,IQ,IR,LATCH($MXSTACK)),
       LATCHI,NP,NPold;
   $ENERGY PRECISION
       E;     "total particle energy"
   $REAL
       X,Y,Z, "particle co-ordinates"
       U,V,W, "particle direction cosines"
       DNEAR, "perpendicular distance to nearest boundary"
       WT;    "particle weight"
   $INTEGER
       IQ,    "charge, -1 for electrons, 0 for photons, 1 for positrons"
       IR,    "current region"
       LATCH, "extra phase space variable"
       LATCHI,"needed because shower does not pass latch-BLOCK DATA sets 0"
       NP,    "stack pointer"
       NPold; "stack pointer before an interaction"
}

"------------------------------------------------------------------"
"*** THRESH--THRESHOLD (AND OTHER) ENERGIES                        "
"------------------------------------------------------------------"
REPLACE {;COMIN/THRESH/;} WITH
{;
   COMMON/THRESH/RMT2,RMSQ,
                 $LGN(AP,AE,UP,UE,TE,THMOLL($MXMED));
   $REAL         RMT2,  "2*electron mass in MeV"
                 RMSQ,  "electron mass squared in MeV**2"
                 AP,    "photon creation threshold energy"
                 AE,    "electron creation threshold energy (total)"
                 UP,    "upper photon energy in PEGS4 data set"
                 UE,    "upper electron energy in PEGS4 data set"
                 TE,    "electron creation threshold energy (kinetic)"
                 THMOLL;"Moller threshold = AE + TE"
}

"------------------------------------------------------------------"
"*** UPHIIN--SINE TABLES FOR UPHI                                  "
"------------------------------------------------------------------"
REPLACE {;COMIN/UPHIIN/;} WITH
{;
   COMMON/UPHIIN/SINC0,SINC1,$LGN(SIN($MXSINC)/0,1/);
   $REAL         SINC0,SINC1,SIN0,SIN1;
}

"------------------------------------------------------------------"
"*** UPHIOT--UPHI'S INPUT/OUTPUT WITH ITS USERS                    "
"------------------------------------------------------------------"
REPLACE {;COMIN/UPHIOT/;} WITH
{;
   COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI,
                 COSPHI,PI,TWOPI,PI5D2;
   $REAL         THETA,  "polar scattering angle"
                 SINTHE, "sin(THETA)"
                 COSTHE, "cos(THETA)"
                 SINPHI, "sine of the azimuthal scattering angle"
                 COSPHI, "cosine of the azimuthal scattering angle"
                 PI,TWOPI,PI5D2;
}

"------------------------------------------------------------------"
"*** USEFUL--HEAVILY USED VARIABLES                                "
"------------------------------------------------------------------"
REPLACE {;COMIN/USEFUL/;} WITH
{;
   COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD;
   $ENERGY PRECISION PZERO,   "precise zero"
                     PRM,     "precise electron mass in MeV"
                     PRMT2;   "2*PRM"
   $REAL             RM;      "electron mass in MeV"
   $INTEGER          MEDIUM,  "medium index of current region"
                     MEDOLD;  "medium index of previous region"
   " The rest mass value is as recommended by CODATA 2014"
   " http://physics.nist.gov/cgi-bin/cuu/Value?mec2mev"
   DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D0/;
}

"------------------------------------------------------------------"
"*** USER--A COMMON FOR THE 'USER' TO 'USE'                        "
"------------------------------------------------------------------"
REPLACE {;COMIN/USER/;} WITH {
         ;}  "DEFAULT IS NULL"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {;COMIN/X-OPTIONS/;} WITH {
    ;
  common/x_options/eadl_relax,       "Use EADL relaxation"
                   mcdf_pe_xsections;"Use Sabbatucci and Salvat PE xsections"
  $LOGICAL  eadl_relax, mcdf_pe_xsections;
};

"------------------------------------------------------------------"
"*** MACROS TO DEFINE THE COMMONS USED IN EACH SUBPROGRAM.         "
"------------------------------------------------------------------"
REPLACE {$COMIN-ANNIH;} WITH {
     ;COMIN/DEBUG,STACK, UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
REPLACE {$COMIN-ANNIH-ATREST;} WITH {
    ;COMIN/DEBUG,STACK,RANDOM,USEFUL,EGS-VARIANCE-REDUCTION,EGS-IO/;}
REPLACE {$COMIN-BHABHA;} WITH {
    ;COMIN/DEBUG,STACK, THRESH,UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,
           EGS-IO/;}
REPLACE {$COMIN-BREMS;} WITH {
    ;COMIN/DEBUG,BREMPR,EPCONT,NIST-BREMS,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
           EGS-VARIANCE-REDUCTION,EGS-IO/;}
REPLACE {$COMIN-COMPT;} WITH {
   ;COMIN/COMPTON-DATA,DEBUG,EPCONT,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
          EGS-VARIANCE-REDUCTION,EGS-IO,RELAX-DATA/;}
REPLACE {$COMIN-ELECTR;} WITH {
;COMIN/DEBUG,BOUNDS,ELECIN,EPCONT,MEDIA,MISC,STACK,THRESH,
UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,CH-Steps,EGS-IO,
          EGS-VARIANCE-REDUCTION,EMF-INPUTS/;}
REPLACE {$COMIN-HATCH;} WITH {
;COMIN/DEBUG,BOUNDS,BREMPR,ELECIN,MEDIA,MISC,PHOTIN,STACK,THRESH,
UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,EGS-IO,X-OPTIONS,
          EGS-VARIANCE-REDUCTION/;}
REPLACE {$COMIN-MOLLER;} WITH {
   ;COMIN/DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM,EGS-IO,
          EGS-VARIANCE-REDUCTION/;}
REPLACE {$COMIN-PAIR;} WITH {
   ;COMIN/DEBUG,BREMPR,NRC-PAIR-DATA,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
          EPCONT,TRIPLET-DATA,EGS-VARIANCE-REDUCTION,EGS-IO/;}
REPLACE {$COMIN-PHOTO;} WITH {
   ;COMIN/BOUNDS,BREMPR,DEBUG,EDGE,EPCONT,MEDIA,PHOTIN,RANDOM,
          STACK,UPHIOT,USEFUL,EGS-IO,X-OPTIONS,
          EGS-VARIANCE-REDUCTION,RELAX-DATA/;}
REPLACE {$COMIN-PHOTON;} WITH {
;COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,UPHIOT,
USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
REPLACE {$COMIN-SHOWER;} WITH {
  ;COMIN/DEBUG,STACK,UPHIOT,RANDOM,EGS-IO/;}
REPLACE {$COMIN-UPHI;} WITH {
  ;COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM,EGS-IO/;}
REPLACE {$COMIN-BLOCK;} WITH {
  ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,
  EPCONT,CH-Steps,ET-Control,MEDIA,MISC,PHOTIN,RANDOM,STACK,
  THRESH, UPHIIN,UPHIOT,USEFUL,EGS-VARIANCE-REDUCTION/;}
REPLACE {$COMIN-RELAX;} WITH {
  ;COMIN/EPCONT,STACK,BOUNDS,USEFUL,RANDOM,EDGE,EGS-IO,RELAX-DATA,X-OPTIONS/;}
REPLACE {$COMIN-SET-DEFAULTS;} WITH {
  ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,EPCONT,CH-Steps,ET-Control,
       MEDIA,MISC,PHOTIN,RANDOM,STACK,THRESH, UPHIIN,UPHIOT,USEFUL,
       EGS-VARIANCE-REDUCTION,EGS-IO,Spin-Data,EII-DATA,rayleigh_inputs,
       EMF-INPUTS,X-OPTIONS/;};
REPLACE {$COMIN-INIT-COMPT;} WITH {
  ;COMIN/COMPTON-DATA,BREMPR,EDGE,MEDIA,MISC,USEFUL,EGS-IO,X-OPTIONS/;};
REPLACE {$COMIN-MSCATI;} WITH {
  ;COMIN/BOUNDS,ELECIN,MEDIA,MISC,RANDOM,ET-Control,USEFUL,EGS-IO/;};
REPLACE {$COMIN-INIT-TRIPLET;} WITH {
  ;COMIN/BREMPR,EGS-IO,MEDIA,TRIPLET-DATA,USEFUL/;};
REPLACE {$COMIN-GET-TRANSPORTP;} WITH {
  ;COMIN/GetInput,BOUNDS,ET-Control,EDGE,COMPTON-DATA,MEDIA,MISC,
         BREMPR,EII-DATA,EGS-IO,rayleigh_inputs,EMF-INPUTS,X-OPTIONS/;};
"Ali:photonuc, 1 block"
REPLACE {$COMIN-PHOTONUC;} WITH {;COMIN/STACK,EPCONT,USEFUL/;};

;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {ILOG2(#)} WITH {
    IFIX(1.44269*LOG({P1}))} "1.44269=1/LN(2)"

REPLACE {$SETINTERVAL#,#;} WITH {
    [IF] '{P2}'=SNAME  [L{P1}={P2}1*{P1}+{P2}0;]
    [ELSE]  [L{P1}={P2}1(MEDIUM)*{P1}+{P2}0(MEDIUM);]}
"TWO ARGUMENT SET INTERVAL CALL (ABOVE) CURRENTLY MEANS"
"INTERVAL INDEX IS LINEAR FUNCTION OF THE LINEAR VARIABLE,"
"WITH NO MAPPING.  {P1} IS THE LINEAR VARIABLE AND {P2} IS"
"THE NAME OF THE INTERVAL(WHICH IS USED TO CONSTRUCT THE"
"COEFFICIENTS USED IN COMPUTING THE INTERVAL INDEX)."
"BUT, IF {P2} IS SINC OR BLC OR RTHR OR RTHRI, IT DOES"
"NOT DEPEND ON MEDIUM"

REPLACE {$EVALUATE#USING#(#);} WITH {
  [IF] '{P2}'=SNAME1
  [{P1}={P2}1(L{P3})*{P3}+{P2}0(L{P3});] [ELSE]
  [{P1}={P2}1(L{P3},MEDIUM)*{P3}+{P2}0(L{P3},MEDIUM);]}
"{P1} IS VARIABLE TO BE ASSIGNED VALUE."
"{P2} IS THE FUNCTION BEING APPROXIMATED."
"{P3} IS THE ARGUMENT OF THE FUNCTION. IN THE CURRENT"
"PWLF METHOD, THE ARGUMENT DETERMINES AN INTERVAL USING THE"
"$SET INTERVAL MACROS.   WITH IN THIS INTERVAL THE"
"FUNCTION IS APPROXIMATED AS A LINEAR FUNCTION OF"
"THE ARGUMENT. BUT"
"IF {P2}=SIN IT DOES NOT DEPEND ON MEDIUM"

REPLACE {$EVALUATE#USING#(#,#);} WITH {
  {P1}={P2}0(L{P3},L{P4})+{P2}1(L{P3},L{P4})*{P3}+
  {P2}2(L{P3},L{P4})*
  {P4};}"2-D APPROXIMATION INDEPENDENT OF MEDIUM"
SPECIFY SNAME AS ['sinc'|'blc'|'rthr'|'rthri'|'SINC'|'BLC'|'RTHR'|'RTHRI'];
SPECIFY SNAME1 AS ['sin'|'SIN'];

"The following circumvent the above table look up method for sin"
"functions.  Modern machines do sines very quickly so the large saving"
"in time from the above no longer exists for sines (was 40% on some"
"machines for the overall computing time! (for example it makes a
"20% effect on an SGI R4400)"
"To recover the use of tables, just comment out the following two"
"macros"

REPLACE {$EVALUATE#USING SIN(#);} WITH {{P1}=sin({P2});}
REPLACE {$SET INTERVAL#,SINC;} WITH {;}


"MACRO TO ALLOW USER TO ADD TO PROPERTIES THAT ARE"
"PASSED TO NEW PARTICLES"
REPLACE {$TRANSFERPROPERTIESTO#FROM#;} WITH {
    X{P1}=X{P2};Y{P1}=Y{P2};Z{P1}=Z{P2};IR{P1}=IR{P2};
    WT{P1}=WT{P2};DNEAR{P1}=DNEAR{P2};LATCH{P1}=LATCH{P2};}
   "IN THE USAGE OF THE ABOVE MACRO, '(IP)' WILL REFER TO THE"
   "PARTICLE WHOSE STACK INDEX IS 'IP'. 'NP' IS THE TOP OF THE STACK."
   "JUST PLAIN 'I' WILL REFER TO THE INITIAL VALUES SUPPLIED"
   "AS ARGUMENTS TO SHOWER, OR SUPPLIED IN COMMON BLOCKS OR"
   "DATA STATEMENTS IN SHOWER."

"Macro to check that the stack size is not exceeded"
REPLACE {$CHECK-STACK(#,#);} WITH {;
  IF( {P1} > $MXSTACK ) [
;  "---------- BUFFER FLUSH SEMICOLON ----------"
      $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
          ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
          ' Increase $MXSTACK and try again ');
  ]
};

/*
   Redefined to be able to use huge stack in C++ application after
   implementing new relaxation.
 */
REPLACE {$CHECK-STACK(#,#);} WITH {;
  IF( {P1} > $MXSTACK ) [
      $egs_fatal('(//,3a,/,2(a,i9))',' In subroutine ',{P2},
          ' stack size exceeded! ',' $MAXSTACK = ',$MXSTACK,' np = ',{P1});
  ]
};

"MACRO FOR RE-EVALUATING DEDX IN SUBROUTINE ELECTR"
REPLACE {$DEDX-RE-EVALUATION;} WITH {
;}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"THE FOLLOWING MACROS ARE USED IN SUBROUTINE ELECTR IN ORDER TO MAKE"
"PATH LENGTH CORRECTIONS AND RESTRICTIONS:"
REPLACE {$SET-USTEP;} WITH
{
  ekems = eke - 0.5*tustep*dedx; "Use mid-point energy to calculate"
                                  "energy dependent quantities"
  $CALCULATE-XI(tustep);
  IF ( xi < 0.1 )
    [
      ustep = tustep*(1 - xi*(0.5 - xi*0.166667));
    ]
    ELSE
    [
      ustep = tustep*(1 - Exp(-xi))/xi;
    ]
}
;

REPLACE {$CALCULATE-XI(#);} WITH
{
  p2 = ekems*(ekems+rmt2); beta2 = p2/(p2 + rmsq);
  chia2 = xccl/(4*blccl*p2);
                                "Note that our chia2 is Moliere chia2/4"
                                "Note also that xcc is now old egs xcc**2"
  xi = 0.5*xccl/p2/beta2*{P1};
  IF( spin_effects ) [
      elkems = Log(ekems);
      $SET INTERVAL elkems,eke;
      IF(lelec < 0) [
          $EVALUATE etap USING etae_ms(elkems);
          $EVALUATE xi_corr USING q1ce_ms(elkems);
      ]
      ELSE          [
          $EVALUATE etap USING etap_ms(elkems);
          $EVALUATE xi_corr USING q1cp_ms(elkems);
      ]
      chia2 = chia2*etap; xi = xi*xi_corr;
      $EVALUATE ms_corr USING blcce(elkems);
      blccl = blccl*ms_corr;
  ]
  ELSE [ xi_corr = 1; etap = 1; ]
  xi = xi*(Log(1+1./chia2)-1/(1+chia2));
}

REPLACE {$SET-TVSTEP;} WITH
"        ===========                 "
{
    ;IF ( vstep < ustep0 )
    [
      ekems = eke - 0.5*tustep*vstep/ustep0*dedx;
         "This estimates the energy loss to the boundary."
         "tustep was the intended curved path-length,"
         "ustep0 is the average transport distance in the initial direction"
         "       resulting from tustep"
         "vstep = ustep is the reduced average transport distance in the "
         "              initial direction due to boundary crossing"
      $CALCULATE-XI(vstep);
      IF ( xi < 0.1 )
      [
        tvstep = vstep*(1 + xi*(0.5 + xi*0.333333));
      ]
      ELSE
      [

        IF ( xi < 0.999999 )
        [
           tvstep = -vstep*Log(1 - xi)/xi;
        ]
        ELSE
        [
           "This is an error condition because the average transition "
           "in the initial direction of motion is always smaller than 1/Q1"
           $egs_info(*,' Stoped in SET-TVSTEP because xi > 1! ');
           $egs_info(*,' Medium: ',medium);
           $egs_info(*,' Initial energy: ',eke);
           $egs_info(*,' Average step energy: ',ekems);
           $egs_info(*,' tustep: ',tustep);
           $egs_info(*,' ustep0: ',ustep0);
           $egs_info(*,' vstep:  ',vstep);
           $egs_info(*,' ==> xi = ',xi);
           $egs_fatal(*,'This is a fatal error condition');
        ]
      ]
    ]
    ELSE
    [
      tvstep = tustep;
    ]
}
;

REPLACE {$ENEPS} WITH {0.0001}
            "DIFFERENCE BETWEEN ECUT AND END POINT ENERGY FOR"
            "RANGE CALCULATION"

REPLACE {$EPSEMFP} WITH {1.E-8}  "SMALLEST ELECTRON MFP VALUE"
REPLACE {$EPSGMFP} WITH {1.E-8}  "SMALLEST GAMMA MFP VALUE"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"THE FOLLOWING ARE UTILITY AND OTHER MACROS FOR THE USER"

"ETALY1---COMMON BLOCK FOR ENERGY CONSERVATION PURPOSES"
REPLACE {;COMIN/ETALY1/;} WITH {
    ;COMMON/ETALY1/ESUM(4,$MXREG,5);
    $ENERGY PRECISION ESUM;}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"NTALY1---COMMON BLOCK FOR KEEPING COUNT OF ETALY1-EVENTS"
REPLACE {;COMIN/NTALY1/;} WITH {
   ;COMMON/NTALY1/NSUM(4,$MXREG,5);
   $INTEGER NSUM;
}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MACRO TO ALLOW USER TO INITIALIZE IN SUBROUTINE HATCH"
REPLACE {$HATCH-USER-INPUT-INIT;} WITH {;
" $RNG-INITIALIZATION; "
" Have taken this out, (IK, Jan 2000). If the user does not initilize the"
" rng before the first call to shower, the rng will initialize itself    "
" using the default seed and the default luxury level (which is defined  "
" via $DEFAULT-LL).                                                      "

DO J=1,$MXREG [
  IF(SMAXIR(J)<=0.0) [SMAXIR(J)=1E10;]
]
;}

REPLACE {$KERMA-INSERT;} WITH {;}
            "USED IN KERMA CALCULATIONS---DEFAULT IS NULL"
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MACRO FOR CONTROLLING NEGATIVE USTEP"
REPLACE {$USER-CONTROLS-NEGATIVE-USTEP;} WITH {
"         ============================"
   ;IF(USTEP<-1.E-4)[ IERUST=IERUST+1;OUTPUT IERUST,USTEP,IR(NP),IRNEW,
   IROLD,X(NP),Y(NP),Z(NP),SQRT(X(NP)**2+Y(NP)**2);
   (I6,' NEGATIVE USTEP=',E14.6,' IR,IRNEW,IROLD=',3I4,' X,Y,Z,R=',
   4E14.6);
   IF(IERUST>10)[OUTPUT;(///'0STOP, TOO MANY USTEP ERRORS'///); STOP;]]
   USTEP=0.0;}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

REPLACE {$CHECK-NEGATIVE-USTEP;} WITH {;
    IF(ustep <= 0) [
        "Negative ustep---probable truncation problem at a"
        "boundary, which means we are not in the region we think"
        "we are in.  The default macro assumes that user has set"
        "irnew to the region we are really most likely to be"
        "in.  A message is written out whenever ustep is less than -1.e-4"
        IF(ustep < -1e-4) [
            ierust = ierust + 1;
            OUTPUT ierust,ustep,dedx,e(np)-prm,
                   ir(np),irnew,irold,x(np),y(np),z(np);
            (i4,' Negative ustep = ',e12.5,' dedx=',F8.4,' ke=',F8.4,
             ' ir,irnew,irold =',3i4,' x,y,z =',4e10.3);
            IF(ierust > 1000) [
                OUTPUT;(////' Called exit---too many ustep errors'///);
                $CALL_EXIT(1);
            ]
        ]
        ustep = 0;
    ]
};

"MACRO FOR INTRODUCING FLUCTUATIONS IN THE ENERGY LOSS BY"
"CHARGED PARTICLES (E.G., 'LANDAU FLUCTUATIONS')---DEFAULT IS NULL"
REPLACE {$DE-FLUCTUATION;} WITH {;}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"Macro for production of annihilation quanta whenever"
"the energy is greater than AE but less than or equal to ECUT."
"photons are always produced in EGSnrc."

REPLACE {$POSITRON-ECUT-DISCARD;} WITH {EDEP=PEIE-PRM;}
"NOTE: TO GET THE EGS3 VERSION SIMPLY USE EDEP=PEIE+PRM"
"      AS THE REPLACEMENT PART OF THE MACRO."
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"MACROS FOR PARTICLE SELECTION (E.G., LEADING PARTICLE,"
"SPLITTING, ETC.).  DEFAULT IS ULTIMATELY 'NULL'"
"     -----IN SUBROUTINE ELECTR-----                 "
REPLACE {$PARTICLE-SELECTION-ELECTR;} WITH {;}
REPLACE {$PARTICLE-SELECTION-ANNIH;} WITH {
         $PARTICLE-SELECTION-ELECTR;}
REPLACE {$PARTICLE-SELECTION-ANNIHREST;} WITH {
        $PARTICLE-SELECTION-ELECTR;}
REPLACE {$PARTICLE-SELECTION-BHABHA;} WITH {
        $PARTICLE-SELECTION-ELECTR;}
REPLACE {$PARTICLE-SELECTION-BREMS;} WITH {
        $PARTICLE-SELECTION-ELECTR;}
REPLACE {$PARTICLE-SELECTION-MOLLER;}
   WITH {$PARTICLE-SELECTION-ELECTR;}
"     -----IN SUBROUTINE PHOTON-----                 "
REPLACE {$PARTICLE-SELECTION-PHOTON;} WITH {;}
REPLACE {$PARTICLE-SELECTION-COMPT;} WITH {
        $PARTICLE-SELECTION-PHOTON;}
REPLACE {$PARTICLE-SELECTION-PAIR;} WITH {
        $PARTICLE-SELECTION-PHOTON;}
REPLACE {$PARTICLE-SELECTION-PHOTO;} WITH {
        $PARTICLE-SELECTION-PHOTON;}

"MACRO FOR SELECTION OF THE ELECTRON MEAN-FREE-PATH"
REPLACE {$SELECT-ELECTRON-MFP;} WITH {
        $RANDOMSET RNNE1; IF(RNNE1.EQ.0.0) [RNNE1=1.E-30;]
         DEMFP=MAX(-LOG(RNNE1),$EPSEMFP);}

"MACRO FOR SELECTION OF THE PHOTON MEAN-FREE-PATH"
REPLACE {$SELECT-PHOTON-MFP;} WITH {
       $RANDOMSET RNNO35; IF(RNNO35.EQ.0.0) [RNNO35=1.E-30;]
         DPMFP=-LOG(RNNO35);}

"MACRO to do range rejection on a region by region basis"
"      if the user requests it.  The variables e_max_rr and i_do_rr"
"      are in COMIN ET-CONTROL.  This macro is called immediately"
"      after $USER-RANGE-DISCARD in ELECTR and everytime called"
"      the electrons current range has been computed and stored in"
"      range and the distance to the nearest boundary has just been"
"      computed and is in tperp.  e_max_rr and i_do_rr are initialized"
"      to zero in BLOCK DATA so range rejection is not done unless"
"      Since option must be turned on by the user, it is considered a"
"      USER-ELECTRON-DISCARD."
"      Note this technique implies an approximation because the particle"
"      is not allowed to create a brem particle which might escape"
"      the region.  This is why  e_max_rr is used, to allow high"
"      energy electrons to be tracked in case they give off brem."

REPLACE {$RANGE-DISCARD;} WITH {
  ;IF( i_do_rr(irl) = 1 & e(np) < e_max_rr(irl) ) [
      IF(tperp >= range) ["particle cannot escape local region"
          idisc = 50 + 49*iq(np); "1 for electrons, 99 for positrons"
          go to :USER-ELECTRON-DISCARD: ;
      ]
  ]
};


"MACRO TO ALLOW USER TO DISCARD IF AT OR NEAR END OF RANGE"
REPLACE {$USER-RANGE-DISCARD;} WITH {;}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"RAYLEIGH (COHERENT) SCATTERING MACROS"

"custom form factor file names"
/*********************************************************
   For simplicity, molecular form factors are assumed to
   ALWAYS be given as FF/SQRT(MW). Current available mol.
   FF are given this way.

   One could devise a more complex scheme, where the user
   enters by input in which form the FF are given and then,
   depending on whether the medium is defined as compound or
   mixture, egsnrc must or not multiplicate the Rayleigh
   xsection with the molecular weight.

   In the current scheme, this is done automatically
   without needing input from the user.
**********************************************************/
REPLACE {COMIN/rayleigh_inputs/;} WITH
"        ================"
{
;COMMON/rayleigh_inputs/iray_ff_media($MXMED),iray_ff_file($MXMED);
;character*24 iray_ff_media;
;character*128 iray_ff_file;
}

REPLACE {COMIN/rayleigh_sampling/;} WITH
"        ================"
{;COMMON/rayleigh_sampling/xgrid($MXRAYFF,$MXMED),
                            fcum($MXRAYFF,$MXMED),
                           b_array($MXRAYFF,$MXMED),
                           c_array($MXRAYFF,$MXMED),
                           i_array($RAYCDFSIZE,$MXMED),
                           $LGN(pmax($MXGE,$MXMED)/0,1/);
$REAL xgrid, fcum, b_array, c_array,pmax0, pmax1;
$INTEGER i_array;
}

REPLACE {$RAYLEIGH-CORRECTION;} WITH {
     ;IF(IRAYLR(IRL).EQ.1) [$EVALUATE COHFAC USING COHE(GLE);
    GMFP=GMFP*COHFAC];}

REPLACE {$OLD_RAYLEIGH-SCATTERING;} WITH {
      ;IF(IRAYLR(IRL).EQ.1) [
   $RANDOMSET RNNO37;
   IF (RNNO37.LE.(1.0-COHFAC)) [
   $AUSCALL($RAYLAUSB);
   NPold = NP;
   :SAMPLING-LOOP: LOOP [$RANDOMSET XXX;
   $SET INTERVAL XXX,RCO; $EVALUATE X2 USING RSCT(XXX);
   Q2=X2*RMSQ/(20.60744*20.60744);
   COSTHE=1.-Q2/(2.*E(NP)*E(NP));
   IF (ABS(COSTHE).GT.1.0) GO TO :SAMPLING-LOOP:;
   CSQTHE=COSTHE*COSTHE;
   REJF=(1.0+CSQTHE)/2.0;
   $RANDOMSET RNNORJ;
   ] UNTIL (RNNORJ <= REJF);
   SINTHE=SQRT(1.0-CSQTHE); CALL UPHI(2,1);
   $AUSCALL($RAYLAUSA);
   GOTO :PNEWENERGY:;]]
  }
REPLACE {$RAYLEIGH-SCATTERING;} WITH {
   ;IF(IRAYLR(IRL).EQ.1) [
   $RANDOMSET RNNO37;
   IF (RNNO37.LE.(1.0-COHFAC)) [
   $AUSCALL($RAYLAUSB);
   NPold = NP;
   call egs_rayleigh_sampling(MEDIUM,E(NP),GLE,LGLE,COSTHE,SINTHE);
   CALL UPHI(2,1);
   $AUSCALL($RAYLAUSA);
   GOTO :PNEWENERGY:;]]
}

"Ali:photonuc, 2 blocks"
REPLACE {$PHOTONUC-CORRECTION;} WITH {
     ;IF(IPHOTONUCR(IRL).EQ.1) [$EVALUATE PHOTONUCFAC USING PHOTONUC(GLE);
    GMFP=GMFP*PHOTONUCFAC];}

REPLACE {$PHOTONUCLEAR;} WITH {
   ;IF(IPHOTONUCR(IRL).EQ.1) [
      $RANDOMSET RNNO39;
      IF (RNNO39.LE.(1.0-PHOTONUCFAC)) [
        $AUSCALL($PHOTONUCAUSB);
        call PHOTONUC;
        $AUSCALL($PHOTONUCAUSA);
        GOTO :PNEWENERGY:;
      ]
    ]
}

"DENSITY RATIO SCALING MACRO (TO OVER-RIDE DENSITY IN A PARTICULAR"
"REGION)  NOTE: THIS MACRO REPLACES SUBROUTINE RHOSET OF EGS3"

REPLACE {$SET-RHOF;} WITH {RHOF=RHOR(IRL)/RHO(MEDIUM);}  "DEFAULT"

"TEMPLATES FOR PERFORMING CHARGED PARTICLE TRANSPORT IN EM FIELD"
REPLACE {$SET-TUSTEP-EM-FIELD;} WITH {;}
REPLACE {$SET-USTEP-EM-FIELD;} WITH {;}
REPLACE {$VACUUM-ADD-WORK-EM-FIELD;} WITH {;}
REPLACE {$SET-ANGLES-EM-FIELD;} WITH {;}
REPLACE {$SET-TVSTEP-EM-FIELD;} WITH {;}
REPLACE {$ADD-WORK-EM-FIELD;} WITH {;}
REPLACE {$EMFIELD_INITIATE_SET_TUSTEP;} WITH {;}
REPLACE {;COMIN/EM/;} WITH {;}
REPLACE {$EMFIELD_PII;} WITH {;}
REPLACE{$EMFIELD_PI;}WITH{;}
REPLACE{$EM_FIELD_SS;}WITH{;}
REPLACE{$ADD_WORK_EM_FIELD;}WITH{;}
REPLACE{$EMFieldInVacuum;}WITH{;}
REPLACE{$EM_MACROS_ACTIVE}WITH{.false.}
;  "---------- BUFFER FLUSH SEMICOLON ----------"

"------------------------------------------------------------------"
"        EGS4/EGSnrc GEOMETRY MACROS: AN EXTENSION TO EGS MACROS   "
"------------------------------------------------------------------"

"   NOTE1: CYLNDR IS A NEW MACRO BY G.R.STEVENSON OF CERN"
"          (SEE HS-RP/TM/80-78, 25 NOV. 1980)"

"   NOTE2: CONE IS A NEW MACRO BY H.HIRAYAMA OF KEK. "
"          MACRO REPLACEMENT OF CERN VERSION SUBROUTINE CONE"
"          (SEE HS-RP/TM/81-30, 5 MAY 1981)"

"   NOTE3: SPHERE IS A NEW MACRO BY G.R.STEVENSON OF CERN"
"          (SEE HS-RP/TM/81-30, 5 MAY 1981)"

"   NOTE4: $PLAN2X AND $PLAN2P ARE TWO NEW MACROS BY W.R.NELSON."
"          $PLAN2P WAS FORMERLY CALLED $PLANE2 AND IS STILL THE"
"          SAME (CALLS TO $PLANE2 WILL AUTOMATICALLY DEFAULT TO"
"          TO $PLAN2P).  $PLAN2X, HOWEVER, WILL CORRECTLY HANDLE"
"          THE CASE OF TWO, NON-PARALLEL PLANES."

"------------------------------------------------------------------"
"        MACRO-ROUTINES FOR PLANE GEOMETRY  (SLAC VERSION)         "
"------------------------------------------------------------------"
;
PARAMETER $MXPLNS=100;     "MAX. NO. OF PLANES"

"PLADTA---COMMON BLOCK FOR $PLANE1 AND $PLANE2 MACROS"
REPLACE {;COMIN/PLADTA/;} WITH {
      ;COMMON/PLADTA/PCOORD(3,$MXPLNS),PNORM(3,$MXPLNS);
      $REAL PCOORD, PNORM;
}

"$PLANE1---MACRO REPLACEMENT FOR SUBROUTINE PLANE1"
REPLACE {$PLANE1(#,#,#,#);} WITH {
 UDOTA=PNORM(1,{P1})*U(NP)+PNORM(2,{P1})*
 V(NP)+PNORM(3,{P1})*W(NP); UDOTAP={P2}*UDOTA;
 IF(UDOTA.EQ.0.0)[{P3}=2;]ELSEIF(UDOTAP.LT.0.0)
 [{P3}=0;] ELSE [{P3}=1;{P4}=(PNORM(1,{P1})*
 (PCOORD(1,{P1})-X(NP))+ PNORM(2,{P1})*
 (PCOORD(2,{P1})-Y(NP))+PNORM(3,{P1})*
 (PCOORD(3,{P1})-Z(NP)))/UDOTA;]}
"NOTE:   EVERYWHERE $PLANE1 IS USED ONE MUST"
"        INCLUDE COMIN/PLADTA,STACK/"

"------------------------------------------------------------------"

"$PLANE2---MACRO REPLACEMENT FOR SUBROUTINE PLANE2"
"          NOTE: $PLANE2 HAS BEEN SUPERCEDED BY $PLAN2P (BELOW),"
"                WHICH IS AUTOMATICALLY TAKEN CARE OF BY THE"
"                FOLLOWING MACRO STATEMENT."
REPLACE {$PLANE2} WITH {$PLAN2P}

"------------------------------------------------------------------"

"$PLAN2P---MACRO REPLACEMENT FOR SUBROUTINE PLAN2P (OR $PLANE2)"
"          (I.E., TWO PARALLEL PLANES)"
REPLACE {$PLAN2P(#,#,#,#,#,#);} WITH {
  $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1)
 [ $CHGTR(TVAL,{P2});] ELSEIF(IHIT.EQ.0)
 [$PLANE1({P4},{P6},IHIT,TVAL);$CHGTR(TVAL,{P5});]}
"NOTE:   EVERYWHERE $PLAN2P ($PLANE2) IS USED ONE MUST"
"        INCLUDE COMIN/EPCONT,PLADTA,STACK/"

"------------------------------------------------------------------"

"$PLAN2X---MACRO REPLACEMENT FOR SUBROUTINE PLAN2X"
"          (I.E., TWO, NON-PARALLEL (CROSSING) PLANES)"
REPLACE {$PLAN2X(#,#,#,#,#,#);} WITH {
    $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1) [
   $CHGTR(TVAL,{P2});]   $PLANE1({P4},{P6},IHIT,TVAL);
   IF(IHIT.EQ.1) [$CHGTR(TVAL,{P5});]}
"NOTE:   EVERYWHERE $PLAN2X IS USED ONE MUST"
"        INCLUDE COMIN/EPCONT,PLADTA,STACK/"

"------------------------------------------------------------------"
"      MACRO-ROUTINE FOR CYLINRICAL GEOMETRY  (CERN VERSION)       "
"------------------------------------------------------------------"

PARAMETER $MXCYLS=75;      "MAX. NO. OF CYLINDERS"
PARAMETER $DELCYL=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"

"CYLDTA---COMMON BLOCK FOR $CYLNDR MACRO"
REPLACE {;COMIN/CYLDTA/;} WITH {
   ;COMMON/CYLDTA/CYRAD2($MXCYLS);
   $REAL CYRAD2;
}

"$CYLNDR---MACRO REPLACEMENT FOR SUB CYLNDR GRS VERSION 14 11 80"
REPLACE {$CYLNDR(#,#,#,#);} WITH {
   {P3}=1;{P4}=0.0;ACYL=SQRT(U(NP)*U(NP)+V(NP)*V(NP));
   IF(ACYL.EQ.0.0)[{P3}=0;]  ELSE [
   BCYL=(X(NP)*U(NP)+Y(NP)*V(NP))/ACYL;CCYL=X(NP)*X(NP)+Y(NP)*Y(NP)
   -CYRAD2({P1});  ARGCY=BCYL*BCYL-CCYL;
   IF(ARGCY.LT.0.0) [{P3}=0;]   ELSE [
   IF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.0.AND.BCYL.GE.0.0)[{P3}=0;]
   ELSEIF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.1.AND.BCYL.LT.0.0)[
   {P4}=-2.0*BCYL/ACYL;]
   ELSE [ IF({P2}.EQ.1.AND.CCYL.GE.0.0)[{P3}=1;{P4}=$DELCYL;]
   ELSEIF({P2}.EQ.0.AND.CCYL.LE.0.0)[{P3}=1;{P4}=$DELCYL;]
   ELSE  [  ROOTCY=SQRT(ARGCY); IF(CCYL.LT.0.0)
   [{P4}=(-BCYL+ROOTCY)/ACYL;]
   ELSEIF(BCYL.LT.0.0) [{P4}=(-BCYL-ROOTCY)/ACYL;]
   ELSE [{P3}=0;]]]]]}
"NOTE:   EVERYWHERE $CYLNDR IS USED ONE MUST"
"         INCLUDE COMIN/CYLDTA,STACK/"

"$CYL2--MACRO EQUIVALENT FOR CYLNDR OF $PLANE2  GRS 17.11.80"
REPLACE {$CYL2(#,#,#,#);} WITH {
 $CYLNDR({P1},0,IHIT,TCYL);IF(IHIT.EQ.1)[
 $CHGTR(TCYL,{P2});]ELSE[$CYLNDR({P3},1,IHIT,TCYL);
 IF(IHIT.EQ.1)[ $CHGTR(TCYL,{P4});]]}
"NOTE:   EVERYWHERE $CYL2 IS USED ONE MUST
"         INCLUDE COMIN/CYLDTA,STACK/"

;  "---------- BUFFER FLUSH SEMICOLON ----------"

"------------------------------------------------------------------"
"     MACRO-ROUTINE FOR CERN CONICAL GEOMETRY  (SLAC VERSION)      "
"------------------------------------------------------------------"

PARAMETER $MXCONES=75;     "MAXIMUM NUMBER OF CONES"
PARAMETER $DELCON=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"

"CONDTA---COMMON BLOCK FOR $CONE MACRO"
REPLACE {;COMIN/CONDTA/;} WITH {
   ;COMMON/CONDTA/COTAL2($MXCONES),SMALLL($MXCONES);
   $REAL COTAL2, SMALLL;
}

"$CONE---MACRO REPLACEMENT FOR CERN VERSION SUBROUTINE CONE"
REPLACE {$CONE(#,#,#,#);} WITH {
   {P3}=0;ITWOPR=0;CPCON=COTAL2({P1});SGNCON=SIGN(1.0,CPCON);
   CPCON=ABS(CPCON);ZNP=SGNCON*(Z(NP)-SMALLL({P1}));
   WNP=SGNCON*W(NP);CPCON1=1.0+CPCON;
   CPCON2=SQRT(CPCON1);DCON1=X(NP)*X(NP)+Y(NP)*Y(NP);
   DCON2=SQRT(DCON1); IF((ZNP.GE.0.0).OR.(WNP.GE.0.0)) [
   ACON=(U(NP)*U(NP)+V(NP)*V(NP))*CPCON-WNP*WNP;
   BCON1=(X(NP)*U(NP)+Y(NP)*V(NP))*CPCON;BCON=BCON1-ZNP*WNP;
   CCON=DCON1*CPCON-ZNP*ZNP;
   IF(ACON.EQ.0.0)[IF(BCON.NE.0.0)
   [IF(ABS(CCON).LT.$DELCON.AND.ZNP.GE.0.0)[
   IF(({P2}.EQ.1.AND.BCON.GE.0.0).OR.({P2}.EQ.0.AND.BCON.LE.0.0))[
   TCON1=-CCON/(2*BCON);IF(TCON1.GE.0.0)[IF((ZNP+TCON1*WNP).GE.0.0)
   [{P4}=TCON1;{P3}=1;]]]]]
   ELSE[TCON1=CPCON2*ZNP*SIGN(1.0,-WNP);
   IF(TCON1.GE.0.0)[{P4}=TCON1;{P3}=1;]]]
   ELSEIF((ABS(CCON).LT.$DELCON).AND.(ZNP.GE.0.0))
   [BPRIM=BCON1-WNP*DCON2;
   IF({P2}.EQ.1.AND.BPRIM.LT.0.0)[TCON1=-2*BCON/ACON;
   IF(TCON1.GE.0.0) [{P4}=TCON1;{P3}=1;]]]
   ELSEIF({P2}.EQ.1.AND.CCON.GT.0.0) [{P4}=$DELCON;{P3}=1;]
   ELSEIF({P2}.EQ.0.AND.CCON.LT.0.0.AND.ZNP.GE.0.0)
   [{P4}=$DELCON;{P3}=1;] ELSE[CCON1=BCON*BCON-ACON*CCON;
   IF(CCON1.GE.0.0)[ROOT=SQRT(CCON1);
   IF(BCON.GT.0.0)[TCON11=-(BCON+ROOT)/ACON;]
   ELSE[TCON11=-CCON/(BCON-ROOT);]
   IF(BCON.LT.0.0)[TCON22=-(BCON-ROOT)/ACON;]
   ELSE[TCON22=-CCON/(BCON+ROOT);]
   IF((TCON11.GE.0.0).OR.(TCON22.GE.0.0))[
   IF(TCON11.LT.0.0)[TCON1=TCON22;]
   ELSE[IF(TCON22.LT.0.0)[TCON1=TCON11;] ELSE[ITWOPR=1;
   TCON1=min(TCON11,TCON22);TCON2=max(TCON11,TCON22);]]
   IF((ZNP+TCON1*WNP).GE.0.0)[{P4}=TCON1;{P3}=1;]
   ELSEIF((ITWOPR.EQ.1).AND.((ZNP+TCON2*WNP).GE.0.0))
   [{P4}=TCON2;{P3}=1;]]]]]}
"NOTE:   EVERYWHERE $CONE IS USED ONE MUST
"         INCLUDE COMIN/CONDTA,STACK/"

"$CON2--MACRO EQUIVALENT FOR CONE OF $PLANE2            "
REPLACE {$CON2(#,#,#,#);} WITH {
   $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
   $CHGTR(TCON,{P2});]ELSE[$CONE({P3},1,IHIT,TCON);IF(IHIT.EQ.1)[
   $CHGTR(TCON,{P4});]]}

"$CON21--MACRO EQUIVALENT FOR CONE OF $PLANE2 (IN THE CASE  "
"OF OUTSIDE TWO CONE SURFACE)                               "
REPLACE {$CON21(#,#,#,#);} WITH {
   $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
   $CHGTR(TCON,{P2});]ELSE[$CONE({P3},0,IHIT,TCON);IF(IHIT.EQ.1)[
   $CHGTR(TCON,{P4});]]}

;  "---------- BUFFER FLUSH SEMICOLON ----------"

"------------------------------------------------------------------"
"        MACRO-ROUTINE FOR SPHERICAL GEOMETRY  (CERN VERSION)      "
"------------------------------------------------------------------"

PARAMETER $MXSPHE=75;      "MAX. NO. OF SPHERES"
PARAMETER $DELSPH=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"

"SPHDTA------COMMON BLOCK FOR $SPHERE MACRO"
REPLACE {;COMIN/SPHDTA/;} WITH {
   ;COMMON/SPHDTA/SPRAD2($MXSPHE);
   $REAL SPRAD2;
}

"$SPHERE---MACRO REPLACEMENT FOR SUB SPHERE GRS VERSION 08 12 80"
REPLACE {$SPHERE(#,#,#,#);} WITH {
   {P3}=1;{P4}=0.0;ASPH=1.0;
   BSPH=(X(NP)*U(NP)+Y(NP)*V(NP)+Z(NP)*W(NP))/ASPH;CSPH=X(NP)*X(NP)
   +Y(NP)*Y(NP)+Z(NP)*Z(NP)  -SPRAD2({P1});  ARGSP=BSPH*BSPH-CSPH;
   IF(ARGSP.LT.0.0) [{P3}=0;]   ELSE [
   IF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.0.AND.BSPH.GE.0.0)[{P3}=0;]
   ELSEIF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.1.AND.BSPH.LT.0.0)[
   {P4}=-2.0*BSPH/ASPH;]
   ELSE [ IF({P2}.EQ.1.AND.CSPH.GE.0.0)[{P3}=1;{P4}=$DELSPH;]
   ELSEIF({P2}.EQ.0.AND.CSPH.LE.0.0)[{P3}=1;{P4}=$DELSPH;]
   ELSE [ROOTSP=SQRT(ARGSP); IF(CSPH.LT.0.0)
   [{P4}=(-BSPH+ROOTSP)/ASPH;] ELSEIF(BSPH.LT.0.0)
   [{P4}=(-BSPH-ROOTSP)/ASPH;] ELSE [{P3}=0;]]]]}
"NOTE:   EVERYWHERE $SPHERE IS USED ONE MUST
"         INCLUDE COMIN/SPHDTA,STACK/"

"$SPH2--MACRO EQUIVALENT FOR SPHERE OF $PLANE2  GRS 08.12.80"
REPLACE {$SPH2(#,#,#,#);} WITH {
 $SPHERE({P1},0,IHIT,TSPH);IF(IHIT.EQ.1)[
 $CHGTR(TSPH,{P2});]ELSE[$SPHERE({P3},1,IHIT,TSPH);
 IF(IHIT.EQ.1)[ $CHGTR(TSPH,{P4});]]}
"NOTE:   EVERYWHERE $SPH2 IS USED ONE MUST
"         INCLUDE COMIN/SPHDTA,STACK/"

;  "---------- BUFFER FLUSH SEMICOLON ----------"

"------------------------------------------------------------------"
"        MACRO-ROUTINE FOR CHANGING REGIONS  (SLAC VERSION)        "
"------------------------------------------------------------------"

"$CHGTR---MACRO REPLACEMENT FOR SUBROUTINE CHGTR"
REPLACE {$CHGTR(#,#);} WITH {
    ;IF({P1}.LE.USTEP) [USTEP={P1}; IRNEW={P2};]}
"NOTE:   EVERYWHERE $CHGTR IS USED ONE MUST
"         INCLUDE COMIN/EPCONT/"

"------------------------------------------------------------------"
"     MACRO-ROUTINE TO OBTAIN FINAL COORDINATES (SLAC VERSION)     "
"------------------------------------------------------------------"

"$FINVAL---MACRO REPLACEMENT FOR SUBROUTINE FINVAL"
REPLACE {$FINVAL(#,#,#,#);} WITH {
   {P2}=X(NP)+{P1}*U(NP); {P3}=Y(NP)+{P1}*V(NP);
   {P4}=Z(NP)+{P1}*W(NP);}
"NOTE:   EVERYWHERE $FINVAL IS USED ONE MUST
"         INCLUDE COMIN/STACK/"

"------------------------------------------------------------------"
"                 END OF GEMOETRY MACRO EXTENSION                  "
"------------------------------------------------------------------"

"******************************************************************"
"                                                                  "
"                    NRC EXTENSIONS                                "
"                                                                  "
"******************************************************************"

; "BUFFER FLUSH"
"--------------------------------------------------------------"
"                                                              "
"           PHOTOELECTRON ANGLE SELECTION                      "
"           =============================                      "
"                                                              "
"--------------------------------------------------------------"
"This macro can be used to select the photoelectron direction  "

REPLACE {$SELECT-PHOTOELECTRON-DIRECTION;} WITH {
"        ================================"
;IF(IPHTER(IR(NP)).EQ.1)[
  EELEC=E(NP);
  IF(EELEC.GT.ECUT(IR(NP)))[
    BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC;
    GAMMA=EELEC/RM;
    ALPHA=0.5*GAMMA-0.5+1./GAMMA;
    RATIO=BETA/ALPHA;
    LOOP[
      $RANDOMSET RNPHT;RNPHT=2.*RNPHT-1.;
      IF(RATIO.LE.0.2)[
        FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT);
        IF( gamma < 100 ) [
            COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA);
        ]
        ELSE [
            IF( fkappa > 0 ) [
                costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gamma-1)**3);
            ]
            ELSE [ COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA); ]
        ]
        "XI=1./(1.-BETA*COSTHE); <-- this numerically problematic "
        "                            at high energies, IK"
        xi = (1+beta*fkappa)*gamma*gamma;
      ]
      ELSE[
        XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO))-1.));
        COSTHE=(1.-1./XI)/BETA;
      ]
      SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE));
      $RANDOMSET RNPHT2;
      ]WHILE(RNPHT2.GT.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA);
    SINTHE=SQRT(SINTH2);
    CALL UPHI(2,1);]]
}

; "BUFFER FLUSH"

"--------------------------------------------------------------"
"                                                              "
"           TSTEP RECURSION IN ELECTR                          "
"           =========================                          "
"                                                              "
"--------------------------------------------------------------"
"This macro can be used to control TSTEP recursion in ELECTR   "

REPLACE {$USER_CONTROLS_TSTEP_RECURSION;} WITH {;}

; "BUFFER FLUSH"

%C80
"------------------------------------------------------------------"
"  BREMSSTRAHLUNG ANGLE SELECTION MACROS                           "
"------------------------------------------------------------------"


"These macros are explained in NRCC REPORT #PIRS0203"
"by Bielajew, Mohan and Chui                        "

"Macro to initialize data for bremsstrahlung production               "
"The quantity ZBRANG is ( (1/111)*Zeff**(1/3) )**2                    "
"where Zeff is defined in equation (7) OF PIRS0203                    "
"This macro goes in SUBROUTINE HATCH                                  "
"                                                                     "
REPLACE {$INITIALIZE-BREMS-ANGLE;} WITH {
; IF(IBRDST.EQ.1)[
        DO IM=1,NMED[
            ZBRANG(IM)=0.0;PZNORM=0.0;
            DO IE=1,NNE(IM)[
                ZBRANG(IM)=
                  ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
                PZNORM=PZNORM+PZ(IM,IE);
                ]
                ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
                LZBRANG(IM)=-log(ZBRANG(IM));
            ]
        ]
}
;

;

" Following is associated with the selection of bremsstrahlung photon"
" angle.  This has been implemented directly into the BREMS subroutine"
" and changed slightly. Nonetheless, this macro is still used."

"This is the function G(X) of PIRS0203               "
"The result is returned in {P1} as a function of {P2}"
"i.e. {P1}=G({P2}) where {P2}=X                      "
"                                                    "
REPLACE {$SET-BREM-REJECTION-FUNCTION(#,#);} WITH {
; Y2TST1=(1.+{P2})**2;
{P1}= (4.+LOG(RJARG3+ZTARG/Y2TST1))*(4.*ESEDEI*{P2}/Y2TST1-RJARG1)+RJARG2;
}
;

"------------------------------------------------------------------"
"  PAIR ANGLE SELECTION MACROS                                     "
"------------------------------------------------------------------"

"These macros are explained in NRCC REPORT # PIRS0287 by Bielajew     "

;
"Macro to initialize data for PAIR PRODUCTION                         "
"THE QUANTITY ZBRANG IS ( (1/111)*Zeff**(1/3) )**2                    "
"WHERE Zeff IS DEFINED IN EQUATION (7) OF PIRS0287                    "
"THIS MACRO GOES IN SUBROUTINE HATCH                                  "
"THIS MACRO IS IDENTICAL TO THE $INITIALIZE-BREMS-ANGLE DEFINED ABOVE "
"                                                                     "
REPLACE {$INITIALIZE-PAIR-ANGLE;} WITH {
;    IF(IPRDST.GT.0)[
        DO IM=1,NMED[
            ZBRANG(IM)=0.0;PZNORM=0.0;
            DO IE=1,NNE(IM)[
                ZBRANG(IM)=
                  ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
                PZNORM=PZNORM+PZ(IM,IE);
                ]
                ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
            ]
        ]
}
;
"THRESHOLD BELOW WHICH ONLY LOWEST ORDER ANGULAR DISTRIBUTION OF THE  "
"PAIR ANGLE IS EMPLOYED. SCALE IS ENERGY (MeV).                       "
"USERS MAY OVERRIDE THIS WITH A HIGHER VALUE BUT A LOWER VALUE WILL   "
"CAUSE NON-PHYSICAL SAMPLING                                          "
"                                                                     "
REPLACE {$BHPAIR} WITH {4.14}
;
"THIS MACRO ENABLES VERY SMALL ANGLE SAMPLING TO BE     "
"ACCUMULATED. THE LIMIT OF 1.0E-10 BREAKS DOWN AROUND   "
"50 GEV OR SO (THETA=RM/E, FOR BOTH PAIR AND BREM).     "
"THIS MACRO REPLACES CODE IN UPHI AND IN THE PRESTA     "
"MACROS FOR THE LATERAL CORRELATION PART $PRESTA-LCDV.  "
;
REPLACE {(SINPS2.LT.1.0E-10)} WITH {(SINPS2.LT.1.0E-20)}
;
"THE FOLLOWING REPLACES THE EGS4 DEFAULT $SET-PAIR-ANGLE MACRO    "
"IT'S USE REQUIRES AN ASSOCIATE MACRO $SET-PAIR-REJECTION-FUNCTION"
"DEFINED BELOW                                                    "
"                                                                 "
"USAGE: IPRDST=0 => EGS4 DEFAULT ANGLE SELECTION                  "
"       IPRDST=1 => LOWEST ORDER ANGULAR DISTRIBUTION             "
"                                                                 "
"              d(Probability)            sin(theta)               "
"              -------------- = -------------------------------   "
"                 d(theta)      2*P*[E_total - P*cos(theta)]**2   "
"                                                                 "
"       IPRDST=2 => MOTZ, OLSEN AND KOCH (1969) EQ. 3D-2003       "
"                   IF IPRDST IS NON-ZERO AND E_PHOTON < $BHPAIR  "
"                   THE IPRDST=1 DISTRIBUTION IS USED             "
"                                                                 "
REPLACE {$SET-PAIR-ANGLE;} WITH {;
    IF( iprdst > 0 ) [
        IF( iprdst = 4 ) [
            $RANDOMSET rtest;
            "gbeta = (1-rmt2/eig)**8;"
            gbeta = PESE1/(PESE1+10);
            IF( rtest < gbeta ) [ iprdst_use = 1; ]
            ELSE [ iprdst_use = 4; ]
        ]
        ELSEIF ( iprdst = 2 & eig < $BHPAIR ) [ iprdst_use = 1; ]
        ELSE [ iprdst_use = iprdst; ]
        DO ichrg = 1,2 [
            IF(ICHRG.EQ.1)[ESE=PESE1;]ELSE[
                ESE=ESE2;
                IF( iprdst = 4 ) [
                    gbeta = ESE/(ESE+10);
                    $RANDOMSET rtest;
                    IF( rtest < gbeta ) [ iprdst_use = 1; ]
                    ELSE [ iprdst_use = 4; ]
                ]
            ]
            IF( iprdst_use = 1 ) [
                PSE=SQRT(MAX(0.0,(ESE-RM)*(ESE+RM)));
                $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
                SINTHE=RM*SQRT((1.0-COSTHE)*(1.0+COSTHE))/(PSE*COSTHE+ESE);
                COSTHE=(ESE*COSTHE+PSE)/(PSE*COSTHE+ESE);
            ]
            ELSE IF( iprdst_use = 2 ) [
                "ZBRANG=( (1/111)*Zeff**(1/3) )**2"
                ZTARG=ZBRANG(MEDIUM);
                "TTEIG=TOTAL INITIAL PHOTON ENERGY IN ELECTRON REST MASS UNITS"
                TTEIG=EIG/RM;
                "TTESE=TOTAL FINAL ELECTRON ENERGY IN ELECTRON REST MASS UNITS"
                TTESE=ESE/RM;
                "TTPSE=TOTAL FINAL ELECTRON MOMENTUM IN rm UNITS"
                TTPSE=SQRT((TTESE-1.0)*(TTESE+1.0));
                "THIS IS THE RATIO (r IN PIRS0287)"
                ESEDEI=TTESE/(TTEIG-TTESE);
                ESEDER=1.0/ESEDEI;
                "DETERMINE THE NORMALIZATION "
                XIMIN=1.0/(1.0+(3.141593*TTESE)**2);
                $SET-PAIR-REJECTION-FUNCTION(REJMIN,XIMIN);
                YA=(2.0/TTEIG)**2;
                XITRY=MAX(0.01,MAX(XIMIN,MIN(0.5,SQRT(YA/ZTARG))));
                GALPHA=1.0+0.25*LOG(YA+ZTARG*XITRY**2);
                GBETA=0.5*ZTARG*XITRY/(YA+ZTARG*XITRY**2);
                GALPHA=GALPHA-GBETA*(XITRY-0.5);
                XIMID=GALPHA/(3.0*GBETA);
                IF(GALPHA.GE.0.0)[
                    XIMID=0.5-XIMID+SQRT(XIMID**2+0.25);
                ]
                ELSE[
                    XIMID=0.5-XIMID-SQRT(XIMID**2+0.25);
                ]
                XIMID=MAX(0.01,MAX(XIMIN,MIN(0.5,XIMID)));
                $SET-PAIR-REJECTION-FUNCTION(REJMID,XIMID);
                "ESTIMATE MAXIMUM OF THE REJECTION FUNCTION"
                "FOR LATER USE BY THE REJECTION TECHNIQUE  "
                REJTOP=1.02*MAX(REJMIN,REJMID);
                LOOP[
                    $RANDOMSET XITST;
                    $SET-PAIR-REJECTION-FUNCTION(REJTST,XITST);
                    $RANDOMSET RTEST;
                    "CONVERT THE SUCCESSFUL CANDIDATE XITST TO AN ANGLE"
                    THETA=SQRT(1.0/XITST-1.0)/TTESE;
                    "LOOP UNTIL REJECTION TECHNIQUE ACCEPTS XITST"
                    REJTST_on_REJTOP   = REJTST/REJTOP;
                ]UNTIL((RTEST <= REJTST_on_REJTOP) & (THETA < PI) );
                SINTHE=SIN(THETA);COSTHE=COS(THETA);
            ]
            ELSE IF( iprdst_use = 3 ) [
                $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
                sinthe=(1-costhe)*(1+costhe);
                IF( sinthe > 0 ) [ sinthe = sqrt(sinthe); ] ELSE [ sinthe = 0; ]
            ]
            ELSE [
                "PSE=SQRT(MAX(1e-10,(ESE-RM)*(ESE+RM)));"
                "$RANDOMSET costhe;"
                "costhe=(ese-(ese+pse)*exp(-2*costhe*log((ese+pse)/rm)))/pse;"
                $RANDOMSET costhe;
                costhe=1-2*sqrt(costhe);
                sinthe=(1-costhe)*(1+costhe);
                IF( sinthe > 0 ) [ sinthe=sqrt(sinthe); ] ELSE [ sinthe=0; ]
            ]
            IF( ichrg = 1 ) [CALL UPHI(2,1);]
            ELSE [ sinthe=-sinthe; NP=NP+1; CALL UPHI(3,2); ]
        ]
        iq(np) = iq2; iq(np-1) = iq1; return;
    ]
    ELSE[
        THETA=0; "THETA=RM/EIG; "
    ]
}
;
"THIS IS THE FUNCTION d[G(XI)]/(d XI) OF PIRS0287    "
"THE RESULT IS RETURNED IN {P1} AS A FUNCTION OF {P2}"
"I.E. {P1}=G({P2}) WHERE {P2}=XI                     "
"                                                    "
REPLACE {$SET-PAIR-REJECTION-FUNCTION(#,#);} WITH {
; {P1} = 2.0+3.0*(ESEDEI+ESEDER) -
        4.00*(ESEDEI+ESEDER+1.0-4.0*({P2}-0.5)**2)*(
            1.0+0.25*LOG(
                ((1.0+ESEDER)*(1.0+ESEDEI)/(2.*TTEIG))**2+ZTARG*{P2}**2
                )
            )
        ;
}
;

REPLACE {$SELECT-LOW-ENERGY-PAIR-PRODICTION;} WITH
{
  $RANDOMSET RNNO30; $RANDOMSET rnno34;
  PESE2 = PRM + 0.5*RNNO30*(PEIG-2*PRM); PESE1 = PEIG - PESE2;
  IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]
}
" IK introduced this macro because uniform energy distribution"
" is probably a better approximation than a zero energy 'electron'"
" for low energy pair production"

;

"THIS MACRO EXCHANGES TWO POSITIONS ON THE STACK"
"NB: LATCH IS A NON-STANDARD STACK VARIABLE     "
"    REMOVE IT IF IT CAUSES PROBLEMS            "
"                                               "
REPLACE {$EXCHANGE-STACK(#,#);} WITH {
;
FDUMMY = U({P2});     U({P2})     = U({P1});     U({P1})     = FDUMMY;
FDUMMY = V({P2});     V({P2})     = V({P1});     V({P1})     = FDUMMY;
FDUMMY = W({P2});     W({P2})     = W({P1});     W({P1})     = FDUMMY;
FDUMMY = E({P2});     E({P2})     = E({P1});     E({P1})     = FDUMMY;
FDUMMY = WT({P2});    WT({P2})    = WT({P1});    WT({P1})    = FDUMMY;
IDUMMY = IQ({P2});    IQ({P2})    = IQ({P1});    IQ({P1})    = IDUMMY;
"LATCH IS NOW STANDARD"
IDUMMY = LATCH({P2}); LATCH({P2}) = LATCH({P1}); LATCH({P1}) = IDUMMY;
}
;

REPLACE {;OUTPUT61#;#;} WITH {
"       ==============="
;{SETR A=@LG}
WRITE(6,{COPY A}){P1};WRITE(1,{COPY A}){P1};{COPY A}FORMAT{P2};}
;

" The following macro provides a second order evaluation of the   "
" stopping power. The parameter is half of the initial estimate of"
" the energy loss fraction. IK Oct 97                             "
REPLACE {$RE-EVALUATE-DEDX(#);} WITH
{
;
  elktmp = elke + Log(1 - {P1});
  $SET INTERVAL elktmp,eke;
  lelktmp = max(1,lelktmp);
  IF(lelec < 0)[$EVALUATE dedxmid USING ededx(elktmp);]
  ELSE         [$EVALUATE dedxmid USING pdedx(elktmp);]
  dedx = rhof*dedxmid*(1+0.17408298*({P1}/(1-{P1})/(eke+PRM))**2);
                   "0.17408298 is 2/3*m**2"
  {P1} = 2*{P1};
}

; "BUFFER FLUSH"


%E    "egsnrc.macros"
"******************************************************************"
"                                                                  "
"       transport algorithm related stuff                          "
"                                                                  "
"******************************************************************"

"Macros to denote the various transport algorithms"
"These numbers just have to be distinct"
"Note that the distributed version of EGSnrc does not include the VMC option"
REPLACE {$PRESTA-II} WITH {0}
REPLACE {$PRESTA--I} WITH {1}
REPLACE {$VMC}       WITH {2}

REPLACE {$CALL-USER-ELECTRON} WITH {;}

;
REPLACE {$MSCAT-DATAFILE} WITH {i_mscat}
  "Fortran unit number used to read in new MS"
;
REPLACE {$RANDOMIZE-TUSTEP} WITH {.false.}
  "Switches tustep randomization off"
;
REPLACE {$SKIN-DEPTH-FOR-BCA} WITH {3}
;
REPLACE {$PRESTA-DEBUG} WITH {.false.}
;
REPLACE {$EXACT-BCA-XIMAX} WITH {0.5}
;
REPLACE {$INEXACT-BCA-XIMAX} WITH {0.5} "this is not realy neccessary, "
                                        "it remained from Alex's coding"
;
REPLACE {$MAX-ELOSS} WITH {0.25}
;
REPLACE {$SUBSTEP-ELOSS-EVALUATION} WITH {.false.}
;
REPLACE {$MAX-SMAX} WITH {1e10}
;
REPLACE {$GLOBAL-ECUT} WITH {0.}
;
REPLACE {$GLOBAL-PCUT} WITH {0.}
;
REPLACE {$IBRDST-DEFAULT} WITH {1}
;
REPLACE {$IBR-NIST-DEFAULT} WITH {0}
;
REPLACE {$PAIR-NRC-DEFAULT} WITH {0}
;
REPLACE {$TRIPLET-DEFAULT} WITH {0}
;
REPLACE {$IPRDST-DEFAULT} WITH {1}
;
REPLACE {$IBCMP-DEFAULT} WITH {3} "set to norej"
;
REPLACE {$IEDGFL-DEFAULT} WITH {1}
;
REPLACE {$IPHTER-DEFAULT} WITH {1}
;
REPLACE {$TRANSPORT-ALGORITHM-DEFAULT} WITH {$PRESTA-II}
;
REPLACE {$BCA-ALGORITHM-DEFAULT} WITH {0}
;
REPLACE {$EXACT-BCA-DEFAULT} WITH {.true.}
;
REPLACE {$SPIN-EFFECTS-DEFAULT} WITH {.true.}
;
REPLACE {$IRAYLR-DEFAULT} WITH {1}
;
REPLACE {$AP-DEFAULT} WITH {-1}
;
REPLACE {$UP-DEFAULT} WITH {-1}
;
REPLACE {$XSEC-DEFAULT} WITH {0}
;
REPLACE {$XDATA-DEFAULT} WITH {'xcom'}
;
REPLACE {$COMP-XDATA-DEFAULT} WITH {'default'}
;
"EADL relaxation is now the default"
REPLACE {$EADL-RELAX-DEFAULT} WITH {.true.}
;
"Sabbatucci and Salvat PE xsections not the default yet"
REPLACE {$MCDF-PE-DEFAULT} WITH {.false.}
;
"Ali:photonuc, 2 lines"
REPLACE {$IPHOTONUCR-DEFAULT} WITH {0}
;
REPLACE {$PHOTONUC-XDATA-DEFAULT} WITH {'default'}
;
"EMH:emf, 7 lines"
REPLACE {$ExDEF} WITH {0}
;
REPLACE {$EyDEF} WITH {0}
;
REPLACE {$EzDEF} WITH {0}
;
REPLACE {$BxDEF} WITH {0}
;
REPLACE {$ByDEF} WITH {0}
;
REPLACE {$BzDEF} WITH {0}
;
REPLACE {$EMLMTDEF} WITH {0.02}
;

            "This macro sets the minimum step size for a condensed"
            "history (CH) step. When the exact BCA is used, the minimum"
            "CH step is determined by efficiency considerations only"
            "At about 3 elastic MFP's single scattering becomes more"
            "efficient than CH and so the algorithm switches off CH"
            "If one of the various inexact BCA's is invoked, this macro"
            "provides a simple way to include more sophisticated"
            "decisions about the maximum acceptable approximated CH step"

"The parameters passed to the macro in ELECTR are  eke and elke "

REPLACE {$SET-SKINDEPTH(#,#);} WITH
"        =================                  "
{
   $CALCULATE-ELASTIC-SCATTERING-MFP(ssmfp,{P1},{P2});
   skindepth = skindepth_for_bca*ssmfp;
}
;

"This macro calculates the elastic scattering MFP"
"If spin_effects is .false., the screened Rutherford cross section"
"is used, else the the elastic MFP is based on PWA cross sections"

REPLACE {$CALCULATE-ELASTIC-SCATTERING-MFP(#,#,#);} WITH
"        =======================================           "
{
    blccl = rhof*blcc(medium);
    xccl  = rhof*xcc(medium);
    p2 = {P2}*({P2}+rmt2); beta2 = p2/(p2 + rmsq);
    IF ( spin_effects ) [
      IF(lelec < 0) [ $EVALUATE etap USING etae_ms({P3}); ]
      ELSE          [ $EVALUATE etap USING etap_ms({P3}); ]
      $EVALUATE ms_corr USING blcce({P3});
      blccl = blccl/etap/(1+0.25*etap*xccl/blccl/p2)*ms_corr;
    ]
    {P1}=beta2/blccl;
}
;

REPLACE {$SINGLE-SCATTERING(#);} WITH
"        ======================                     "
{
    $SET-SCREENING-ANGLE({P1});
    call sscat(chia2,costhe,sinthe);
}
;

"The following macro will allow the use of better single scattering"
"cross sections (PWA) and/or to take into account double counting  "
"of the contribution of atomic electrons to the scattering power   "

REPLACE {$SET-SCREENING-ANGLE(#);} WITH
"        ========================                   "
{
    chia2   = xcc(medium)/(4*{P1}*({P1} + rmt2)*blcc(medium));
}
;

REPLACE {$HARD-SCATTERING;} WITH {;}
;

REPLACE {$TURN_OFF_SCATTERING} WITH {;}
;
"If the above is redefined in a user code or uncommented here                 "
"REPLACE {$TURN_OFF_SCATTERING} WITH {;cost = 1.000; sint = 0.000; return;}   "
"this will turn off all single and multiple scattering                        "
"DR April 2012   see corresponding 2 additions to egsnrc,mortran in           "
"                subroutines sscat and mscat

%E "egsnrc.macros"

REPLACE {$CALL-HOWFAR-IN-ELECTR;} WITH {;
  IF(callhowfar | wt(np) <= 0) [ call howfar; ]
};

REPLACE {$CALL-HOWFAR-IN-PHOTON;} WITH {;
  IF( ustep > dnear(np) | wt(np) <= 0 ) [ call howfar; ]
};

REPLACE {$CALL-HOWNEAR(#);} WITH
{
    OUTPUT 35; "35 in decimal is ascii code for the pound sign"
    (
        ' '/
        ' '/
        ' ***************************************************************'/
        ' ***************************************************************'/
        ' '/
        ' PRESTA-II is aborting execution because you have not defined   '/
        ' the HOWNEAR macro for your geometry.                           '/
        ' '/
        ' You MUST either do so or employ a limited form of PRESTA-II    '/
        ' which does not attempt the refined boundary crossing or lateral'/
        ' correlation features of the algorithm.                         '/
        ' '/
        ' If you include the following macro in your usercode:           '/
        ' '/
        ' REPLACE {$CALL-HOWNEAR(',a,');} WITH {;}                       '/
        ' '/
        ' you can choose between single scattering mode (very slow) and  '/
        ' standard EGS4 mode (no PRESTA enhancments) by the appropriate  '/
        ' choice of the parameters in your input file (see the PRESTA-II '/
        ' manual)                                                        '/
        ' '/
        ' ***************************************************************'/
        ' ***************************************************************'/
        ' '/
        ' '/
    );
    stop;
}

"For compability with user codes with PRESTA-I implemented"
REPLACE {$PRESTA-INPUT-SUMMARY;} WITH {;}
REPLACE {$PRESTA-INPUTS;}        WITH {;}

"If you want to read P-II inputs using the get_input() routine by "
"A. Merovitz and D.W.O.R. you need to either place the following  "
"three macros at the top of your user code, or after the default"
"definitions given below"

;

REPLACE {$USE-GET-INPUTS} WITH {.true.} "To not use get_input replace this "
                                        "with .false.                      "

"The following are the ones used by default"


REPLACE {$USE-GET-INPUTS} WITH {.false.}


;
%E    "egsnrc.macros"

"Macro for azimuthal angle selection
"using a sampling within a box method
"Choose a point randomly within a box such that
"-1 <= x <= 1 and 0 <= y < = 1
"Reject the set if it lies without the inscribed unit semicircle centered
"at (x,y) = (0,0)
"once out of the loop, use the trigonimetric relations (TeX notation)
"\cos 2\phi = (x^2 - y^2)/(x^2 + y^2)
"\sin 2\phi = 2xy/(x^2 + y^2)
REPLACE {$SELECT-AZIMUTHAL-ANGLE(#,#);} WITH
{
;
LOOP
[
    $RANDOMSET xphi;
    xphi  = 2*xphi - 1;
    xphi2 = xphi*xphi;
    $RANDOMSET yphi;
    yphi2  = yphi*yphi;
    rhophi2 = xphi2 + yphi2;
]WHILE(rhophi2 > 1);
rhophi2 = 1/rhophi2;
{P1}  = (xphi2 - yphi2)*rhophi2;
{P2}  = 2*xphi*yphi*rhophi2;
}
;

REPLACE {$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;} WITH {;
  $REAL xphi,xphi2,yphi,yphi2,rhophi2;
};

%E     "egsnrc.macros"
"************************************************************************"
"                                                                        "
"                 Definitions of local variables                         "
"                                                                        "
"************************************************************************"

REPLACE {$DEFINE-LOCAL-VARIABLES-ANNIH;} WITH
{;
"Local variables in order of appearance"
$ENERGY PRECISION
      PAVIP,    "precise total energy in the laboratory frame"
      PESG1,    "precise energy of 1st annihilation photon"
      PESG2;    "precise energy of 2nd annihilation photon"
$REAL AVIP,     "total energy in the laboratory frame"
      A,        "total energy in units of the electron's rest energy"
      G,T,P,    "energy, kinetic energy and momentum in units of RM"
      POT,      "P/T"
      EP0,      "minimum fractional energy"
      WSAMP,    "to avoid un-necessary calc. of Log((1-ep0)/ep0)"
      RNNO01,   "random numbers"
      RNNO02,
      EP,       "fractional energy of the more energetic photon"
      REJF,     "rejection function"
      ESG1,     "energy of the more energetic photon"
      ESG2,     "energy of the less energetic photon"
      aa,bb,cc,sinpsi,sindel,cosdel,us,vs,cphi,sphi;
                "for inline rotations"
$INTEGER
      ibr;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-BHABHA;} WITH
{;
"Local variables in order of appearance"
$ENERGY PRECISION
      PEIP,     "precise total energy of incident positron"
      PEKIN,    "precise kinetic energy of incident positron"
      PEKSE2,   "precise kinetic energy of second 'electron'"
      PESE1,    "precise total energy of first 'electron'"
      PESE2,    "precise total energy of second 'electron'"
      H1,       "used in direction cosine calculations"
      DCOSTH;   "polar scattering angle for more energetic 'electron'"
$REAL EIP,      "total energy of incident positron"
      EKIN,     "kinetic energy of incident positron"
      T0,       "kinetic energy of incident positron in units of RM"
      E0,       "total energy of incident positron in units of RM"
      E02,      "E0**2"
      YY,       "1/(T0+2)"
      Y2,YP,YP2,"various functions of YY"
      BETA2,    "incident positron velocity in units of c"
      EP0,      "minimum fractional energy of a secondary 'electron'"
      EP0C,     "1-EP0"
      B1,B2,B3,B4,  "used in rejection function calculation"
      RNNO03,RNNO04,"random numbers"
      BR,       "kinetic energy fraction of the 2nd 'electron'"
      REJF2,    "rejection function"
      ESE1,     "total energy of 1st 'electron'"
      ESE2;     "total energy of 2nd 'electron'"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-BREMS;} WITH
{;
"Local variables in order of appearance"
$ENERGY PRECISION
  PEIE,   "precise incident electron energy"
  PESG,   "presice energy of emitted photon"
  PESE;   "precise total energy of scattered electron"
$REAL
  EIE,    "total incident electron energy"
  EKIN,   "kinetic incident energy"
  brmin,  " ap(medium)/ekin"
  waux,   "for faster sampling of 1/br"
  aux,    "ese/eie"
  r1,     "a random number"
  ajj,    "for energy bin determination if alias sampling is employed"
  alias_sample1,
  RNNO06, "random number"
  RNNO07, "random number"
  BR,     "energy fraction of secondary photon"
  ESG,    "energy of secondary photon"
  ESE,    "total energy of secondary electron"
  DELTA,  "scaled momentum transfer"
  phi1,   "screening function"
  phi2,   "screening function"
  REJF;   "screening rejection function"

"Brems angle selection variables"
$REAL
  a,b,c,  "direction cosines of incident `electron'"
  sinpsi, sindel, cosdel, us, vs,
          "all used for rotations"
  ztarg,  "(Zeff**1/3/111)**2, used for 2BS angle sampling"
  tteie,  "total energy in units of rest energy"
  beta,   "electron velocity in units of speed of light"
  y2max,  "maximum possible scaled angle"
  y2maxi, "inverse of the above"
  ttese,  "new electron energy in units of rm"
  rjarg1,rjarg2,rjarg3,rejmin,rejmid,rejmax,rejtop,rejtst,
          "all of them used for angle rejection function calcs"
  esedei, "new total energy over old total energy"
  y2tst,  "scaled angle, costhe = 1 - 2*y2tst/y2max"
  y2tst1,
  rtest,  "random number for rejection"
  xphi,yphi,xphi2,yphi2,rhophi2,cphi,sphi;
          "all of the above is for azimuthal angle sampling"

$INTEGER
  L,L1,ibr,jj,j;

}
;

REPLACE {$DEFINE-VARIABLES-FOR-SET-BREMS-ANGLE;} WITH
{;
"Local variables for photon angle selection"
$REAL ZTARG,  "( (1/111)*Zeff**(1/3) )**2"
      TTEIE,  "total incident electron energy in units of RM"
      TTESE,  "total scattered electron energy in units of RM"
      ESEDEI, "TTESE/TTEIE"
      beta,   "electron speed in units of c"
      Y2MAX,  "maximum value of the scaled angle"
      RJARG1,RJARG2,RJARG3,
              "arguments for which the rejection function is calculated"
      REJMIN,REJMID,REJMAX,
              "corresponding values of the rejection function"
      REJTOP, "max(REJMIN,REJMID,REJMAX)"
      Y2TST,  "random number and candidate for a scaled angle"
      REJTST, "rejection function at Y2TST"
      Y2TST1, "aux. variable for rejection function calculation"
      REJTST_on_REJTOP  ,  "ratio for rejection test"
      RTEST;  "random number for rejection"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT;} WITH
{;
"Local COMPT variables in order of appearance"
$ENERGY PRECISION
      PEIG,   "precise energy of incident photon"
      PESG,   "precise energy of scattered photon"
      PESE;   "precise total energy of compton electron"
$REAL ko,     "energy of incident photon in units of RM"
      broi,   "1+2*ko"
      broi2,  "broi*broi"
      bro,    "1/broi"
      bro1,   "1-bro"
      alph1,  "probability for the 1/BR part"
      alph2,  "probability for the BR part"
      alpha,  "alpha1/(alph1+alph2)"
      rnno15,rnno16,rnno17,rnno18,rnno19,
              "random numbers"
      br,     "scattered photon energy fraction"
      temp,   "aux. variable for polar angle calculation"
      rejf3,  "rejection function"
      rejmax, "max. of rejf3 in thge case of uniform sampling"
      Uj,     "binding energy of the selected shell"
      Jo,     "the Compton profile parameter"
      br2,    "br*br"
      fpz,fpz1,"used for limited pz-range rejection"
      qc,     "momentum transfer corresponding to the Compton line energy"
      qc2,    "qc squared"
      af,     "for calculating F"
      Fmax,   "maximum of F"
      frej,   "used for F-rejection"
      eta_incoh, eta, "random numbers"
      aux,aux1,aux2,aux3,aux4, "aux. variables"
      pzmax,  "max. possible z-component of the initial electron momentum"
      pz,     "initial electron momentum projection"
      pz2,    "pz*pz"
      rnno_RR;"for playing Russian Roulette"
$INTEGER
      irl,    "local region number"
      i,      "loop variable for shell sampling (and then shell sampled)"
      j,      "pointer to the shell in the shell data list"
      iarg,   "argument for ausgab call"
      ip;     "a loop variable"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT-old;} WITH
{;
"Local COMPT variables in order of appearance"
$ENERGY PRECISION
      PEIG,   "precise energy of incident photon"
      PESG,   "precise energy of scattered photon"
      PESE;   "precise total energy of compton electron"
$REAL ko,     "energy of incident photon in units of RM"
      broi,   "1+2*ko"
      broi2,  "broi*broi"
      bro,    "1/broi"
      bro1,   "1-bro"
      alph1,  "probability for the 1/BR part"
      alph2,  "probability for the BR part"
      alpha,  "alpha1/(alph1+alph2)"
      rnno15,rnno16,rnno17,rnno18,rnno19,
              "random numbers"
      br,     "scattered photon energy fraction"
      temp,   "aux. variable for polar angle calculation"
      rejf3,  "rejection function"
      rejmax, "max. of rejf3 in thge case of uniform sampling"
      Uj,     "binding energy of the selected shell"
      br2,    "br*br"
      aux,aux1,aux2,"aux. variables"
      pzmax2, "max. possible momentum transfer squared"
      pz,     "momentum transfer prejection"
      pz2,    "pz*pz"
      rnno_RR;"for playing Russian Roulette"
$INTEGER
      irl,    "local region number"
      i,      "loop variable for shell sampling (and then shell sampled)"
      j,      "pointer to the shell in the shell data list"
      iarg,   "argument for ausgab call"
      ip;     "a loop variable"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-ELECTR;} WITH
{;
" Local ELECTR variables"
$ENERGY PRECISION "($ENERGY PRECISION means double precision)"
    demfp,        "differential electron mean free path"
    peie,         "precise energy of incident electron"
    total_tstep,  "total path-length to next discrete interaction"
    total_de      "total energy loss to next discrete interaction"
;
$REAL
    ekems,      "kinetic energy used to sample MS angle (normally midpoint)"
    elkems,     "Log(ekems)"
    chia2,      "Multiple scattering screening angle"
    etap,       "correction to Moliere screening angle from PWA cross sections"
    lambda,     "number of mean free paths (elastic scattering cross section)"
    blccl,      "blcc(medium)*rhof"
    xccl,       "xcc(medium)*rhof"
    xi,         "used for PLC calculations (first GS moment times path-length)"
    xi_corr,    "correction to xi due to spin effects"
    ms_corr,
    p2,         "electron momentum times c, squared"
    beta2,      "electron speed in units of c, squared"
    de,         "energy loss to dedx"
    save_de,    "de saved before $DE-FLUCTUATION"
    dedx,       "stopping power after density scaling"
    dedx0,      "stopping power before density scaling"
    dedxmid,    "stopping power at mid-step before density scaling"
    ekei,       "used in $CALCULATE-TSTEP-FROM-DEMFP;"
    elkei,      "Log(ekei), used in $CALCULATE-TSTEP-FROM-DEMFP;"
    aux,        "aux. variable"
    ebr1,       "e- branching ratio into brem"
    eie,        "energy of incident electron"
    ekef,       "kinetic energy after a step"
    elkef,      "Log(ekef)"
    ekeold,     "kinetic energy before a step"
    eketmp,     "used to evaluate average kinetic energy of a step"
    elktmp,     "log(eketmp)"
    fedep,      "fractional energy loss used in stopping power calculation"
    tuss,       "sampled path-length to a single scattering event"
    pbr1,       "e+ branching ratio into brem"
    pbr2,       "e+ branching ratio into brem or Bhabha"
    range,      "electron range"
    rfict,      "rejection function for fictitious cross section"
    rnne1,      "random number"
    rnno24,     "random number"
    rnno25,     "random number"
    rnnotu,     "random number"
    rnnoss,     "random number"
    sig,        "cross section after density scaling but before a step"
    sig0,       "cross section before density scaling but before a step"
    sigf,       "cross section before density scaling but after a step"
    skindepth,  "skin depth employed for PRESTA-II boundary crossing"
    ssmfp,      "distance of one single elastic scattering mean free path"
    tmxs,       "electron step-size restriction"
    tperp,      "perpendicular distance to the closest boundary"
    ustep0,     "temporary storage for ustep"
    uscat,      "x-axis direction cosine for scattering"
    vscat,      "y-axis direction cosine for scattering"
    wscat,      "z-axis direction cosine for scattering"
    xtrans,     "final x-axis position after transport"
    ytrans,     "final y-axis position after transport"
    ztrans,     "final z-axis position after transport"
    cphi,sphi;  "for azimuthal angle selection for annih at rest"

$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;

$INTEGER
    iarg,      "calling code for ausgab"
    idr,       "calling code for ausgab"
    ierust,    "error counter for negative ustep errors"
    irl,       "region number"
    lelec,     "charge of electron"
    qel,       " = 0 for electrons, = 1 for positrons "
    lelke,     "index into the energy grid of tabulated functions"
    lelkems,   "index into the energy grid of tabulated functions"
    lelkef,    "index into the energy grid of tabulated functions"
    lelktmp,   "index into the energy grid of tabulated functions"
    ibr;       "a loop variable"

$LOGICAL
    "BCA = boundary crossing algorithm"
    callhowfar, "= .true.  => BCA requires a call to howfar"
                "= .false. => BCA does not require a call to howfar"
    domultiple, "= .true.  => inexact BCA requires multiple scattering"
    dosingle,   "= .true.  => exact BCA requires single scattering"
                "= .false. => exact BCA requires no single scattering"
    callmsdist, "= .true.  => normal condensed-history transport"
                "= .false. => one of the BCA's will be invoked"
    findindex,  "used for mscat"
    spin_index, "used for mscat with spin effects"
    compute_tstep
;
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-HATCH;} WITH
{;
"Local HATCH variables in alphabetical order"

$TYPE MBUF(72),MDLABL(8);

$REAL
    ACD   , "used to test goodness of sine-table look-up"
    ADEV  , "absolute deviation in sine-table look-up"
    ASD   , "used to test goodness of sine-table look-up"
    COST  , "cos(theta) from instrinsic library function"
    CTHET , "use to calculate cos(theta) according to look-up tables"
    DEL   , "leat squares delta for sine-table look-up"
    DFACT , "converts rl to dunits"
    DFACTI, "converts rl**-1 to dunits**-1"
    DUNITO, "units scaling varable"
    DUNITR, "saved value of dunit"
    FNSSS , "real form of integer nsinss"
    P     , "counter used in the pwr2i(i) = 1/2**(i - 1) construction"
    PZNORM, "used in $INITIALIZE-BREMS-ANGLE"
    RDEV  , "relative deviation in sine-table look-up"
    S2C2  , "sinthe**2 + costhe**2, used to test look-up table"
    S2C2MN, "min(s2c2)"
    S2C2MX, "max(s2c2)"
    SINT  , "sin(theta) from instrinsic library function"
    SX    , "sum of angles for least squared analysis of look-up table errors"
    SXX   , "sum**2 of angles for least square analysis of look-up table errors"
    SXY   , "sum of angle*sin(angle) for least squared analysis of look-up"
            "table errors"
    SY    , "sum of sin(angle) for least squared analysis of look-up table "
            "errors"
    WID   , "width of sine-table mesh sub-interval (sine-table algorithm)"
    XS    , "angle value in a sub-sub-interval (sine-table algorithm)"
    XS0   , "lower limit of a sub-sub-interval (sine-table algorithm)"
    XS1   , "upwer limit of a sub-sub-interval (sine-table algorithm)"
    XSI   , "beginning angle of a sun-interval (sine-table algorithm)"
    WSS   , "width of a sub-sub-interval (sine-table algorithm)"
    YS    , "sin(angle) for least squared analysis of look-up table errors"
    ZEROS(3); "zeros of sine, 0,pi,twopi"

$INTEGER
    I     , "generic do-loop variable"
    I1ST  , "flag = 0 on first pass"
    IB    , "do-loop variable used for reading the medium type"
    ID    , "integer value of -dunit, when dunit is negative"
    IE    , "do-loop variable for reading over elements in a compound/mixture"
    IL    , "do-loop variable used for reading the medium type"
    IM    , "do-loop variable looping over nmed, number of media"
    IRAYL , "Rayleigh switch read in from PEGS"
    IRN   , "do-loop variable over random set of sine-table look-ups"
    ISTEST, "flag that switches on test of sine function fit"
    ISUB  , "do-loop variable over sub-intervals of the sine look-up table"
    ISS   , "do-loop variable over sub-sub-intervals of the sine look-up table"
    IZ    , "used to locate an exact zero of a sun-interval mesh point in the"
            "sine-table look-up"
    IZZ   , "do-loop variable over the exact zeros of the sine-table look-up"
    J     , "do-loop variable looping over nmed, number of media"
    JR    , "do-loop variable looping over number of regions"
    LCTHET, "$SET INTERVAL index for cos(theta) from look-up table"
    LMDL  , "character width of medium header ' MEDIUM='"
    LMDN  , "character width of medium description"
    LTHETA, "$SET INTERVAL index for sin(theta) from look-up table"
    MD    , "temporary storage for the medium number"
    MXSINC, "number of intervals approximating the sine function"
    NCMFP , "array size input from PEGS. Currently 0, but probably intended"
            "to be cumulative electron mean free path. Presently unused."
    NEKE  , "array size input from PEGS."
            "Number of electron mapped energy intervals."
    NGE   , "array size input from PEGS."
            "Number of photon mapped energy intervals."
    NGRIM , "Rayleigh cross section array size."
    NISUB , "mxsinc - 2. Size of array with endpoints removed."
    NLEKE , "array size input from PEGS. Currently 0, but probably intended"
            "to be number of electron energy intervals below threshold."
            "Presently unused."
    NM    , "number of media found in the "
    NRANGE, "array size input from PEGS. Currently 0, but probably intended"
            "to be number of intervals in an array giving the electron range."
            "Presently unused."
    NRNA  , "number of random angles testing sine function fit"
    NSEKE , "array size input from PEGS. Currently 0, but probably intended"
            "to be number of electron small energy intervals. Presently unused."
    NSGE  , "array size input from PEGS. Currently 0, but probably intended"
            "to be number of gamma small energy intervals. Presently unused."
    NSINSS, "number of sub-intervals for each sine function interval"
    LOK($MXMED); "flag indicating that medium has been found in the PEGS "
                 "datafile"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-MOLLER;} WITH
{;
"Local MOLLER variables in order of their appearance"

$ENERGY PRECISION
     PEIE,   "precise total energy of incident electron"
     PEKSE2, "precise kinetic energy of 2nd secondary electron"
     PESE1,  "precise total energy of 1st secondary electron"
     PESE2,  "precise total energy of 2nd secondary electron"
     PEKIN,  "precise kinetic energy of incident electron"
     H1,     "used for polar scattering angle calculation"
     DCOSTH; "polar scattering angle squared"
$REAL EIE,    "total energy of incident electron"
     EKIN,   "kinetic energy of incident electron"
     T0,     "kinetic energy of incident electron in units of RM"
     E0,     "total energy of incident electron in units of RM"
     EXTRAE, "energy above the Moller threshold"
     E02,    "E0**2"
     EP0,    "minimum alowed kinetic energy fraction"
     G2,G3,  "used for rejection function calculation"
     GMAX,   "maximum value of the rejection function"
     BR,     "kinetic energy fraction to lowew energy electron"
     R,      "(1-BR)/BR"
     REJF4,  "rejection function"
     RNNO27, "random number for BR sampling"
     RNNO28, "random number for rejection"
     ESE1,   "energy of 1st secondary electron"
     ESE2;   "energy of 2nd secondary electron"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-PAIR;} WITH
{;
"Local PAIR variables in order of their appearance"
$ENERGY PRECISION
      PEIG,      "precise energy of incident photon"
      PESE1,     "precise energy of 1st 'electron'"
      PESE2;     "precise energy of 2nd 'electron'"

$REAL EIG,       "energy of incident photon"
      ESE2,      "total energy of lower energy 'electron'"
      RNNO30,RNNO31,rnno32,rnno33,rnno34,
                 "random numbers"
      DELTA,     "scaled momentum transfer"
      REJF,      "screening rejection function"
      rejmax,    "the maximum of rejf"
      aux1,aux2, "auxilary variables"
      Amax,      "Maximum of the screening function used with (br-1/2)**2"
      Bmax,      "Maximum of the screening function used with the uniform part"
      del0,      "delcm*eig"
      br,        "fraction of the available energy (eig-rmt2) going to the"
                 "lower energy `electron'"
      Eminus,Eplus,Eavail,rnno_RR;

$INTEGER
      L,L1;  "flags for high/low energy distributions"
}
;

REPLACE {$DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;} WITH
{;
$REAL ESE,   "total energy of one of the 'electrons'"
      PSE,   "momentum corresponding to ESE"
      ZTARG, "( (1/111)*Zeff**(1/3) )**2"
      TTEIG, "incident photon energy in units of RM"
      TTESE, "energy of one of the 'electrons' in units of RM"
      TTPSE, "momentum of one of the 'electrons' in units of RM"
      ESEDEI,"TTESE/(TTEIG-TTESE) = ratio of secondary electron energies"
      ESEDER,"1/ESEDEI"
      XIMIN, "1st argument where rejection function might have a maximum"
      XIMID, "2nd argument where rejection function might have a maximum"
      REJMIN,"rejection function at XIMIN"
      REJMID,"rejection function at XIMID"
      REJTOP,"max(REJMIN,REJMID)"
      YA,XITRY,GALPHA,GBETA,
             "aux. variables for XIMID calculation"
      XITST, "random number for pair angle sampling"
      REJTST_on_REJTOP  ,  "ratio for rejection test"
      REJTST,"rejection function at XITST"
      RTEST; "random number for rejection"
$INTEGER
      ICHRG; "loop variable"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTO;} WITH
{;
"Local PHOTO variables in order of their appearance"

$ENERGY PRECISION
      PEIG;         "precise energy of incident photon"
$REAL BR,           "random number"
      sigma,        "elemental cross section"
      aux,aux1,     "aux. variables"
      probs($MXEL), "probability for an interaction with a given element"
      sigtot,       "total cross section"
      e_vac,        "shell binding energy"
      rnno_RR;      "for playing Russian Roulette"
$INTEGER
      IARG,         "AUSGAB calling switch"
      iZ,           "Atomic number of the element the photon is "
                    "interactiong with"
      irl,          "local region number"
      ints($MXEL),  "energy interval number for a given element"
      j,ip,         "loop variables"
      n_warning,    "a warning counter"
      k;            "shell number"

$LOGICAL
      do_relax;
save  n_warning;
}
;

REPLACE {$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;} WITH
{;
"Photo-electron angle selection variables"
$REAL EELEC, "total energy of photo-electron"
      BETA,  "velocity of electron in units of c"
      GAMMA, "total energy of photo-electron in units of RM"
      ALPHA, "kinematic factor"
      RATIO, "=BETA/ALPHA"
      RNPHT, "random number"
      FKAPPA,"aux. variable for COSTHE calculation"
      XI,    "used in rejection function calculation"
      SINTH2,"SINTHE**2"
      RNPHT2;"random number for rejection"
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-EDGSET;} WITH
{;
"Local EDGSET variables in order of their appearance"
$REAL EALF(100),EBET(100),OMEG(100),PHOTOK(100),PKA(100);
      "see the data statements in EDGSETfor definition of these arrays"
$INTEGER JJ,IZ,IMED,I;
}
;

REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTON;} WITH
{;
"Local PHOTON variables in order of their appearance"
$ENERGY PRECISION
    PEIG;   "precise photon energy"
;
$REAL
    EIG,    "photon energy"
    RNNO35, "random number for default MFP selection"
    GMFPR0, "photon MFP before density scaling and coherent correction"
    GMFP,   "photon MFP after density scaling"
    COHFAC, "Rayleigh scattering correction"
    RNNO37, "random number for Rayleigh scattering selection"
    XXX,    "random number for momentum transfer sampling in Rayleigh"
    X2,     "scaled momentum transfer in Rayleigh scattering event"
    Q2,     "momentum transfer squared in Rayleigh scattering event"
    CSQTHE, "COSTHE**2"
    REJF,   "Rayleigh scattering rejection function"
    RNNORJ, "random number for rejection in Rayleigh scattering"
    RNNO36, "random number for interaction branching"
    GBR1,   "probability for pair production"
    GBR2,   "probability for pair + compton"
    T,      "used for particle exchange on the stack"
"Ali:photonuc, 2 lines"
    PHOTONUCFAC, "photonuclear correction"
    RNNO39; "random number for photonuclear selection (RNNO38 is taken)"
;
$INTEGER
    IARG,   "parameter for AUSGAB"
    IDR,    "parameter for AUSGAB"
    IRL,    "region number"
    LGLE,   "index for GMFP interpolation"
    LXXX;   "index for Rayleigh scattering cummulative distribution int."
}
;

"Ali:photonuc, 1 block"
REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTONUC;} WITH {;}
;

" Handling track-ends "
" By default, just call AUSGAB and drop energy on the spot"

REPLACE {$ELECTRON-TRACK-END;} WITH {; $AUSCALL(idr); }
REPLACE {$PHOTON-TRACK-END;}   WITH {; $AUSCALL(IDR); }
;

" Macros for the fictitious method  "
"==================================="

" The following version uses sub-threshold energy loss "
" as a measure of path-length => cross section is actual "
" cross section divided by restricted stopping power "
" The global maximum of this quantity called esig_e (electrons) or "
" psig_e (positrons) and is determined in HATCH "

REPLACE {$EVALUATE-SIG0;} WITH
"        ==============="
{;
   IF( sig_ismonotone(qel,medium) ) [
       $EVALUATE-SIGF; sig0 = sigf;
   ]
   ELSE [
       IF( lelec < 0 ) [sig0 = esig_e(medium);]
       ELSE            [sig0 = psig_e(medium);]
   ]
}

REPLACE {$EVALUATE-SIGF;} WITH
"        ==============="
{;
  IF(lelec < 0)
  [
      $EVALUATE sigf USING esig(elke);
      $EVALUATE dedx0 USING ededx(elke);
      sigf = sigf/dedx0;
  ]
  ELSE
  [
      $EVALUATE sigf USING psig(elke);
      $EVALUATE dedx0 USING pdedx(elke);
      sigf = sigf/dedx0;
  ]
}
;

REPLACE {$EVALUATE-EBREM-FRACTION;} WITH {
    $EVALUATE ebr1 USING ebr1(elke);
};
REPLACE {$EVALUATE-PBREM-FRACTION;} WITH {
    $EVALUATE pbr1 USING pbr1(elke);
};
REPLACE {$EVALUATE-BHABHA-FRACTION;} WITH {
    $EVALUATE pbr2 USING pbr2(elke);
};


" Because the cross section is interactions per energy loss, no "
" rhof-scaling is required "
REPLACE {$SCALE-SIG0;} WITH
"        ============"
{
   sig = sig0;
}
;

" Once the sub-threshold processes energy loss to the next discrete "
" interaction is determined, the corresponding path-length has to be"
" calculated. This is done by the macro below. This macro           "
" assumes the energy at the begining to be eke, the logarithm of it "
" elke, lelke - the corresponding interpolation index and makes     "
" use of $COMPUTE-DRANGE(#,#,#,#,#,#)                               "

REPLACE {$CALCULATE-TSTEP-FROM-DEMFP;} WITH
"        ============================"
{;
  IF( compute_tstep ) [
    total_de = demfp/sig; fedep = total_de;
    ekef  = eke - fedep;
    IF( ekef <= E_array(1,medium) ) [ tstep = vacdst; ]
    ELSE
    [
      elkef = Log(ekef);
      $SET INTERVAL elkef,eke;
      IF( lelkef = lelke )
      [       " initial and final energy are in the same interpolation bin "
          $COMPUTE-DRANGE(eke,ekef,lelke,elke,elkef,tstep);
      ]
      ELSE
      [   " initial and final energy are in different interpolation bins, "
          " calc range from ekef to E(lelkef+1) and from E(lelke) to eke  "
          " and add the pre-calculated range from E(lelkef+1) to E(lelke) "
          ekei = E_array(lelke,medium);
          elkei = (lelke - eke0(medium))/eke1(medium);
          $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,tuss);
          ekei = E_array(lelkef+1,medium);
          elkei = (lelkef + 1 - eke0(medium))/eke1(medium);
          $COMPUTE-DRANGE(ekei,ekef,lelkef,elkei,elkef,tstep);
          tstep=tstep+tuss+
                  range_ep(qel,lelke,medium)-range_ep(qel,lelkef+1,medium);
      ]
    ]
    total_tstep = tstep;
    compute_tstep = .false.;
  ]
  tstep = total_tstep/rhof;  " non-default density scaling "
}
;

" The following macro computes the path-length traveled while going from  "
" energy {P1} to energy {P2}, both energies being in the same             "
" interpolation bin, given by {P3}. {P4} and {P5} are the logarithms of   "
" {P1} and {P2}. The expression is based on logarithmic interpolation as  "
" used in EGSnrc (i.e. dedx = a + b*Log(E) ) and a power series expansion "
" of the ExpIntegralEi function that is the result of the integration.    "
" The result is returned in {P6}.                                         "

REPLACE {$COMPUTE-DRANGE(#,#,#,#,#,#);} WITH
"        ============================="
{
  fedep = 1 - {P2}/{P1};
  elktmp = 0.5*({P4}+{P5}+0.25*fedep*fedep*(1+fedep*(1+0.875*fedep)));
           " the above evaluates the logarithm of the midpoint energy"
  lelktmp = {P3};
  IF(lelec < 0) [
      $EVALUATE dedxmid USING ededx(elktmp);
      dedxmid = 1/dedxmid;
      aux = ededx1(lelktmp,medium)*dedxmid;
      "aux = ededx1(lelktmp,medium)/dedxmid;"
  ]
  ELSE [
      $EVALUATE dedxmid USING pdedx(elktmp);
      dedxmid = 1/dedxmid;
      aux = pdedx1(lelktmp,medium)*dedxmid;
      "aux = pdedx1(lelktmp,medium)/dedxmid;"
  ]
  aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6;
  "{P6} = fedep*{P1}/dedxmid*(1+aux);"
  {P6} = fedep*{P1}*dedxmid*(1+aux);
}
;

" The following macro computes the range to the minimum table energy "
" It uses $COMPUTE-DRANGE                                            "
" Note that range_ep array is precomputed in subroutine mscati and   "
" gives the range from the energy interval end points to AE for each "
" medium.

REPLACE {$COMPUTE-RANGE;} WITH
"        ==============="
{
;
  ekei = E_array(lelke,medium);
  elkei = (lelke - eke0(medium))/eke1(medium);
  $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,range);
  range = (range + range_ep(qel,lelke,medium))/rhof;
}
;

/******* trying to save evaluation of range.
REPLACE {$COMPUTE-RANGE;} WITH {;
"        ==============="
  IF( do_range ) [
      ekei = E_array(lelke,medium);
      elkei = (lelke - eke0(medium))/eke1(medium);
      $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,range);
      the_range = range + range_ep(qel,lelke,medium);
      do_range = .false.;
  ]
  range = the_range/rhof;
};
******************/

" The following macro updates demfp. As energy loss is used as the  "
" 'path-length' variable (see above), it just substracts the energy "
" loss for the step.                                                "
REPLACE {$UPDATE-DEMFP;} WITH
"        =============="
{
  demfp = demfp - save_de*sig;
  total_de = total_de - save_de;
  total_tstep = total_tstep - tvstep*rhof;
  IF( total_tstep < 1e-9 ) [ demfp = 0; ]
}
;

" The following macro computes the energy loss due to sub-threshold "
" processes for a path-length {P1}. The energy at the beginning of  "
" the step is {P2}, {P3}=Log({P2}), {P4} is the interpolation index "
" The formulae are based on the logarithmic interpolation for dedx  "
" used in EGSnrc. The result is returned in {P5}. Assumes that      "
" initial and final energy are in the same interpolation bin.       "

REPLACE {$COMPUTE-ELOSS(#,#,#,#,#);} WITH
"        =========================="
{;
  IF( lelec < 0 ) [
      $EVALUATE dedxmid USING ededx({P3});
      aux = ededx1({P4},medium)/dedxmid;
  ]
  ELSE [
      $EVALUATE dedxmid USING pdedx({P3});
      aux = pdedx1({P4},medium)/dedxmid;
  ]
  /*
  {P5} = dedxmid*{P1};  " Energy loss using stopping power at the beginning "
  */
  {P5} = dedxmid*{P1}*rhof; "IK: rhof scaling bug, June 9 2006"
                            "rhof scaling must be done here and NOT in "
                            "$COMPUTE-ELOSS-G below!"
  fedep = {P5}/{P2};
  {P5} = {P5}*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1-
             0.25*fedep*(2-aux*(4-aux)))));
}
;

" The following is a generalized version of $COMPUTE-ELOSS.        "

REPLACE {$COMPUTE-ELOSS-G(#,#,#,#,#);} WITH
"        ============================"
{
  tuss = range - range_ep(qel,{P4},medium)/rhof;
    " here tuss is the range between the initial energy and the next lower "
    " energy on the interpolation grid "
  IF( tuss >= {P1} ) [  " Final energy is in the same interpolation bin "
      $COMPUTE-ELOSS({P1},{P2},{P3},{P4},{P5});
      /* {P5} = {P5}*rhof; "IK, rhof bug"  */
      "IK: rhof scaling bug, June 9 2006. rhof scaling is done in "
      "    $COMPUTE-ELOSS above!                                  "
  ]
  ELSE [ " Must find first the table index where the step ends using "
         " pre-calculated ranges                                     "
      lelktmp = {P4};
      tuss = (range - {P1})*rhof;
         " now tuss is the range of the final energy electron "
         " scaled to the default mass density from PEGS4      "
      IF( tuss <= 0 ) [ {P5} = {P2} - TE(medium)*0.99; ]
        " i.e., if the step we intend to take is longer than the particle "
        " range, the particle energy goes down to the threshold "
        "({P2} is the initial particle energy)  "
        "originally the entire energy was lost, but msdist_xxx is not prepared"
        "to deal with such large eloss fractions => changed July 2005."
      ELSE [
          WHILE ( tuss < range_ep(qel,lelktmp,medium) ) [
              lelktmp = lelktmp - 1; ]
          elktmp = (lelktmp+1-eke0(medium))/eke1(medium);
          eketmp = E_array(lelktmp+1,medium);
          "tuss = range_ep(qel,lelktmp+1,medium) - tuss;"
          "IK: rhof scaling bug, June 9 2006: because of the change in "
          "    $COMPUTE-ELOSS above, we must scale tuss by rhof        "
          tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof;
          $COMPUTE-ELOSS(tuss,eketmp,elktmp,lelktmp,{P5});
          {P5} = {P5} + {P2} - eketmp;
      ]
  ]
}
;
%E  "egsnrc.macros"
"============================================================================"
"
"   The following is related to use of the NRC auxilliary get_inputs
"   routine which is part of the standard NRC user-codes.
"
"   It is not an essential part of EGSnrc but is most easily defined here.
"
"============================================================================"
"
" Input stuff for the get_inputs() routine.                                  "
" As the expirience has shown that get_inputs() is frequently used in several"
" subroutines, I changed the parameter passed to get_inputs() to a common    "
" block. Otherwise, the parameters have to be defined in each subroutine using"
" get_inputs() and, with static variables, this lead to a memory use         "
" explosion (e.g. 8 MB for CAVRZ vs. 0.8 MB without get_inputs()!)           "
" IK, Dec. 1998                                                              "

REPLACE {$NMAX} WITH {100};
REPLACE {$NVALUE} WITH {100};
REPLACE {$STRING80} WITH {80};
REPLACE {$STRING32} WITH {64};
REPLACE {$STRING40} WITH {40};
REPLACE {$STRING256} WITH {256};
REPLACE {$MXALINP} WITH {5};

REPLACE {COMIN/GetInput/;} WITH
"        ================"
{
  ;COMMON/GetInput/
        ALLOWED_INPUTS($NMAX,0:$MXALINP), "Associates a name with each second "
                                   "array index(0:4) for a value sought"
        VALUES_SOUGHT($NMAX),      "Name of each input                 "
        CHAR_VALUE($NMAX,$NVALUE), "For returning character inputs     "
        VALUE($NMAX,$NVALUE),      "For returning int. or real inputs  "
        DEFAULT($NMAX),            "Default value, only for type 0 & 1 "
        VALUE_MIN($NMAX),          "Min and max value defining         "
        VALUE_MAX($NMAX),          "the acceptable input range         "
        NVALUE($NMAX),             "Number of values per value sought  "
        TYPE($NMAX),               "Type of the value sought           "
                                   "0 for integer                      "
                                   "1 for real                         "
                                   "2 for character                    "
                                   "3 for character with allowed_inputs"
        ERROR_FLAGS($NMAX),        "An error flag for each of the      "
                                   "attempted inputs                   "
        i_errors,                  "Unit no. for .errors output file   "
        NMIN, NMAX,                "Minimum and maximum index number of"
                                   "the values sought                  "
        ERROR_FLAG,                "0 for no errors, 1 for errors      "
        DELIMETER;                 "Name of the delimeter              "
   character ALLOWED_INPUTS*$STRING32,VALUES_SOUGHT*$STRING32,
             CHAR_VALUE*$STRING256,DELIMETER*$STRING32;
   $REAL     VALUE,DEFAULT,VALUE_MIN,VALUE_MAX;
   $INTEGER  NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors;
}
;

REPLACE {$GET_INPUT(#);} WITH { NMIN = {P1}; NMAX = {P1}; CALL GET_INPUT; }
;

REPLACE {$GET_INPUTS(#,#);} WITH { NMIN = {P1}; NMAX = {P2}; CALL GET_INPUT; }
;

"The following macro is used in the egs_init1 subroutine (in the file
"egs_utilities.mortran.  Here it is replaced by null so that we insist that
"the .egsinp file be opened with unit=5 (standard input) and the .egslog
"file (if required) be opened with unit=6 (standard output).  This is
"replaced by a search for available units in beamnrc_lib.mortran to avoid
"unit collisions with BEAM shared library sources

REPLACE {$AVAILABLE_UNIT(#,#)} WITH {;}

" The following two macros are defined so that if the nrcaux.mortran file
" is included in the configuration file these are defined at least.
" If the NRC statistics routine  SIGMA is to be used these must have realistic
" definitions in the user-code.

REPLACE {$MXDATA} WITH {1};
REPLACE {$STAT} WITH {2};

%E  "egsnrc.macros"
"============================================================================"
"   The following is related to use of the NRC auxilliary
"   routine xvgrplot which is called from some of the standard
"   NRC user-codes.
"
"   It is not an essential part of EGSnrc but is most easily defined here.
"============================================================================"
REPLACE{$PLTDIM} WITH {300};"Unique array dimension for XVGRPLOT and PLOTSN"
                        "Suppresses warnings from Intel compiler on Windows"
                   "when arrays have different dimensions in diff. routines"

%E   "egsnrc.macros"
"***************************************************************************"
"                                                                           "
"         EGSnrc internal Variance Reduction Macros                         "
"                                                                           "
"***************************************************************************"

REPLACE {;COMIN/EGS-VARIANCE-REDUCTION/;} WITH {;

  common/egs_vr/
    e_max_rr($MXREG), "max energy at which to do range rejection (RR)"
    prob_RR,          "probability for survival in R. Roulette"
    nbr_split,        "do brems splitting if > 1"
    i_play_RR,        "0=>don't play Russian Roulette,1=>play Russian Roulette"
    i_survived_RR,    "0=> all particles survive RR, n=> n partilces were"
                      "eliminated by RR in this interaction"
    n_RR_warning,     "a counter for user errors"
    i_do_rr($MXREG);  "0=>no RR, region by region, 1=>there is RR"
  $REAL          e_max_rr,prob_RR;
  $INTEGER       nbr_split,i_play_RR,i_survived_RR,n_RR_warning;
  $SHORT_INT     i_do_rr;
};

REPLACE {$MAX-RR-WARNING} WITH {50}

"This macro implements Russian Roulette (most useful  with brems splitting)"
"It is more efficient than having the user do it via AUSGAB since it avoids"
"considerable handling of the particles by ELECTR"
"The user must set i_play_RR (defaults to 0) and prob_RR"
"Both are in COMIN EGS-VARIANCE-REDUCTION"
""
"Note that this macro is called as $PLAY RUSSIAN ROULETTE WITH ELECTRONS..."
"Note also that subroutine pair has its own, internal version"

REPLACE {$PLAYRUSSIANROULETTEWITHELECTRONSFROM#;} WITH {;

  i_survived_RR = 0;   "flag all survive"
  ;IF( i_play_RR = 1 ) [
      IF( prob_RR <= 0 ) [
          IF( n_RR_warning < $MAX-RR-WARNING ) [
            n_RR_warning = n_RR_warning + 1;
            OUTPUT prob_RR;
  ('**** Warning, attempt to play Roussian Roulette with prob_RR<=0! ',g14.6);
          ]
      ]
      ELSE [
          ip = {P1};
          LOOP [     "handle all particles from p1 to np"
              IF( iq(ip) ~= 0 ) [   "i.e. charged particles"
                  $RANDOMSET rnno_RR;
                  IF( rnno_RR < prob_RR ) [ "particle survives"
                      wt(ip) = wt(ip)/prob_RR;
                      ip = ip + 1; "increase local pointer"
                  ]
                  ELSE [                    "particle killed"
                      ;i_survived_RR = i_survived_RR + 1;
                      ;IF(ip < np) [
                          "=>replace it with last particle on stack"
                          e(ip) = e(np); iq(ip) = iq(np); wt(ip) = wt(np);
                          u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
                      ]
                      np = np-1; "reduce stack by one=> particle gone"
                  ] "end of kill particle block"
              ] ELSE [ "this is a photon, leave it. Change pointer" ip = ip+1; ]
          ] UNTIL (ip > np);
          "loops until either np is decreased to ip, or ip increased to np"
          IF( np = 0 ) [ " we need at least one particle on the stack "
                         " so that the transport routines can exit properly"
              np = 1; e(np) = 0; iq(np) = 0; wt(np) = 0;
          ]
      ] "end of russian roulette block"
  ] "end of flag set block"
};

"*********************************************************************"
"  Stuff related to radiative corrections for Compton scattering      "
"                                                                     "
"  For now we exclude such corrections by default. They can be        "
"  included by adding the file rad_compton.mortran to the list of     "
"  files used to build EGSnrc just before egsnrc.mortran              "
"  The reason is that there is a fairly large amount of data needed   "
"  and this would be wasteful if the effect turns out to be small     "
"*********************************************************************"

REPLACE {$RADC_CHECK;} WITH {;}
REPLACE {$RADC_REJECTION;} WITH {;}
REPLACE {$RADC_WARNING;} WITH {;
    IF( radc_flag = 1 ) [
        $egs_warning(*,'You are trying to use radiative Compton corrections');
        $egs_info(*,'without having included rad_compton1.mortran');
        $egs_info('(a//)','Turning radiative Compton corrections OFF ...');
        radc_flag = 0;
    ]
};
REPLACE {$RADC_HATCH;} WITH {$RADC_WARNING;}
REPLACE {$COMIN-RADC-INIT;} WITH {
        ;COMIN/RAD_COMPTON,EGS-IO,COMPTON-DATA,MEDIA,PHOTIN,USEFUL/;
};
REPLACE {$COMIN-RADC-SAMPLE;} WITH {
        ;COMIN/RAD_COMPTON,RANDOM,STACK,USEFUL,EGS-IO/;
};


"*********************************************************************"
"  I/O, parallel processing, string manipulations, etc.
"*********************************************************************"

"how many chunks do we want to split the parallel run into
REPLACE {$N_CHUNKS} WITH {10};

" String manipulations, error messages, etc. "
REPLACE {$cstring(#)} WITH {{P1}(:lnblnk1({P1}))};
REPLACE {$set_string(#,#);} WITH {;
  DO i=1,len({P1}) [ {P1}(i:i) = {P2}; ] ;
};

REPLACE {$egs_debug(#,#);} WITH { write(i_log,{P1}) {P2}; };
REPLACE {$egs_fatal(#,#,#);} WITH {
  $warning('(/a)','***************** Error: ');
  $warning({P1},{P2});
  $warning('(/a)','***************** Quiting now.');
  $CALL_EXIT({P3});
};
REPLACE {$egs_fatal(#,#);} WITH {
  $warning('(/a)','***************** Error: ');
  $warning({P1},{P2});
  $warning('(/a)','***************** Quiting now.');
  $CALL_EXIT(1);
};
REPLACE {$egs_warning(#,#);} WITH {
  $warning('(/a)','***************** Warning: ');
  $warning({P1},{P2});
};
REPLACE {$warning(#,#);} WITH { write(i_log,{P1}) {P2}; };
REPLACE {$egs_info(#,#);} WITH { write(i_log,{P1}) {P2}; };
REPLACE {$declare_write_buffer;} WITH {;};


" Common block containing various directories, file names, etc. "
REPLACE {$mx_units} WITH {20};
REPLACE {$max_extension_length} WITH {10};
REPLACE {;COMIN/EGS-IO/;} WITH {;
  common /egs_io/ file_extensions($mx_units),
                  file_units($mx_units),
                  user_code,  "The name of the user code"
                  input_file, "The input file name with path but no extension"
                  output_file,"Same as above but for output"
                  pegs_file,  "The pegs file name with path and extension"
                  hen_house,  "The HEN_HOUSE directory"
                  egs_home,   "The EGS_HOME directory"
                  work_dir,   "The working directory within the user code dir."
                  host_name,  "The name of the host"
                  n_parallel, "if >0, number of parallel jobs"
                  i_parallel, "if >0, parallel job number"
                  first_parallel,"first parallel job (default is 1)"
                  n_max_parallel,"if parallel run, max. number of running jobs"
                  n_chunk,    "Histories per calculation chunk"
                  n_files,
                  i_input,    "unit no. for .egsinp if required"
                  i_log,      "unit no. for .egslog if required"
                  i_incoh,    "unit no. for Compton data"
                  i_nist_data, "unit no. for NIST data"
                  i_mscat,     "unit no. for multiple scattering data"
                  i_photo_cs,  "unit no. for photon cross-section data"
                  i_photo_relax, "unit no. for photon relaxation data"
                  xsec_out,     "switches on/off xsection file output"
                  is_batch,   "True for batch mode"
                  is_pegsless; "true if you are running without pegs file"
  character input_file*256, output_file*256, pegs_file*256,
            file_extensions*$max_extension_length,
            hen_house*128, egs_home*128, work_dir*128, user_code*64,
            host_name*64;
  $INTEGER  n_parallel, i_parallel, first_parallel,n_max_parallel,
            n_chunk, file_units, n_files,i_input,i_log,i_incoh,
            i_nist_data,i_mscat,i_photo_cs,i_photo_relax, xsec_out;
  $LOGICAL  is_batch,is_pegsless;
};

"The following macro sets the EGS_HOME directory               "
"The defualt implementation is to use the environment variable "
"EGS_HOME. But at the NRC EGS_HOME is set using the macro      "
"$EGS_HOME defined in machine.macros.                          "
REPLACE {$set_egs_home;} WITH {;
  $set_string(egs_home,' ');
  call getenv('EGS_HOME',egs_home);
};


" Initialization of various variables on a region-by-region basis "
" This is made a macro so that it can be replaced with a different "
" version for the C/C++ interface                                 "
REPLACE {$set-region-by-region-defaults;} WITH {;
DO i=1,$MXREG [
    ecut(i) = $GLOBAL-ECUT; pcut(i) = $GLOBAL-PCUT; "cut-off energies"
    ibcmp(i) = $IBCMP-DEFAULT;    "Compton "
    iedgfl(i) = $IEDGFL-DEFAULT;  "Relaxations"
    iphter(i) = $IPHTER-DEFAULT;  "photo-electron angular distribution"
    smaxir(i) = $MAX-SMAX;        "maximum step size"
    i_do_rr(i) = 0;               "range rejection flag"
    e_max_rr(i) = 0;              "`save' energy for range rejection"
    med(i) = 1;                   "default medium"
    rhor(i) = 0;                  "default mass density"
    iraylr(i) = $IRAYLR-DEFAULT;  "Rayleigh flag"
"Ali:photonuc, 1 line"
    iphotonucr(i) = $IPHOTONUCR-DEFAULT;  "photonuclear flag per region"]
};

" Make sure ecut and pcut are at least ae/ap and set default densities "
" This is made a macro so that it can be replaced with a different "
" version for the C/C++ interface                                 "
REPLACE {$adjust_rhor_ecut_pcut;} WITH {;
DO JR=1,$MXREG [
    MD=MED(JR);
    IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
        ECUT(JR)=max(ECUT(JR),AE(MD));
        PCUT(JR)=max(PCUT(JR),AP(MD));
        "   USE STANDARD DENSITY FOR REGIONS NOT SPECIALLY SET UP"
        IF (RHOR(JR).EQ.0.0)[RHOR(JR)=RHO(MD);]
    ]
]
};

REPLACE {$adjust_pcut;} WITH {;
DO JR=1,$MXREG [
    MD=MED(JR);
    IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
        PCUT(JR)=max(PCUT(JR),AP(MD));
    ]
]
};

REPLACE {$start_new_particle;} WITH { medium = med(irl); };

REPLACE {$electron_region_change;} WITH {
    ir(np) = irnew; irl = irnew; medium = med(irl);
};
REPLACE {$photon_region_change;} WITH { $electron_region_change; }

REPLACE {$declare_max_medium;} WITH {;};

REPLACE {$need_bound_compton_data(#);} WITH {
  {P1} = .false.;
  DO j=1,$MXREG [
      medium = med(j);
      IF( medium > 0 & medium <= nmed) [
          IF( ibcmp(j) > 0 ) [ {P1} = .true.; EXIT; ]
      ]
  ]
};

REPLACE {$need_relaxation_data(#);} WITH {
  {P1} = .false.;
  DO j=1,$MXREG [
      IF( iedgfl(j) > 0 & iedgfl(j) <= $MXELEMENT ) [ {P1} = .true.; EXIT; ]
  ]
};

REPLACE {$need_rayleigh_data;} WITH {;
DO J=1,NMED [
:LOOP-OVER-REGIONS:  DO I=1,$MXREG [
IF(IRAYLR(I).EQ.1.AND.MED(I).EQ.J) [
"REGION I = MEDIUM J AND WE WANT RAYLEIGH SCATTERING, SO"
"SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
IRAYLM(J)=1; EXIT :LOOP-OVER-REGIONS:;]
"END OF REGION-LOOP"]
"END OF MEDIA-LOOP"]
};

"Ali:photonuc, 1 block"
REPLACE {$need_photonuc_data;} WITH {;
IPHOTONUC=0;
DO J=1,NMED [
:LOOP-OVER-REGIONS-PHOTONUC: DO I=1,$MXREG [
IF(IPHOTONUCR(I).EQ.1.AND.MED(I).EQ.J) [
"REGION I = MEDIUM J AND WE WANT PHOTONUCLEAR, SO"
"SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
IPHOTONUCM(J)=1; IPHOTONUC=1; EXIT :LOOP-OVER-REGIONS-PHOTONUC:;]
"END OF REGION-LOOP"]
"END OF MEDIA-LOOP"]
};

REPLACE {$set_ecutmn;} WITH {
  ecutmn = 1e30;
  DO i=1,$MXREG [
      IF( med(i) > 0 & med(i) <= nmed ) [
                ecutmn = Min(ecutmn,ecut(i));
      ]
  ]
};

" default numer of media. "
REPLACE {$default_nmed} WITH {1}

REPLACE {$GET-PEGSLESS-XSECTIONS;} WITH {;
$egs_fatal('(a/a)',' Code cannot be run in pegsless mode.',
' Compile with required files and try again.');
;
}

REPLACE {$INIT-PEGS4-VARIABLES;} WITH {;}

REPLACE {$DECLARE-PEGS4-COMMON-BLOCKS;} WITH {;}

" The following macro is defined to fool the Intel Fortran compiler "
" version 8.0, which miscompiles init_spin when certain optimizations"
" are turned on and the code is run on an Athlon CPU. "
REPLACE {$FOOL-INTEL-OPTIMIZER(#) #;} WITH {;
    IF( fool_intel_optimizer ) [ write({P1},*) {P2}; ]
}
;
%E
%I4
!INDENT F2;
%C80
%Q1
"#############################################################################"
"                                                                             "
" EGSnrc machine dependent macro file for linux                               "
"                                                                             "
" Created by configure version 2.0 on ti 22.9.2020 12.43.13 +0300             "
"                                                                             "
" You may add your own machine dependent macros to this file,                 "
" but be carefull to not overwrite it if you re-run configure.                "
"                                                                             "
"#############################################################################"

REPLACE {$MACHINE} WITH
  {,'linux',};
REPLACE {$HEN_HOUSE} WITH
  {'/home/miia/EGSnrc/HEN_HOUSE/'};
REPLACE {$CANONICAL_SYSTEM} WITH
  {'x86_64-unknown-linux-gnu'};
REPLACE {$CONFIGURATION_NAME} WITH
  {'linux'};
REPLACE {$EGS_CONFIG} WITH
  {'/home/miia/EGSnrc/HEN_HOUSE/specs/linux.conf'};

" System dependent stuff "
"========================================"
" Unfortunately, there appears to be no reliable way of copying files "
" under Fortran => we use a system call for this"
REPLACE {$copy_file} WITH {'cp '};

" Although one can move files using Fortran's intrinsic rename, "
" we don't know whether the user has not created additional files in "
" the temporary working directory => it is easiest to use a system call "
" to move all files from the temporary working directory to the user-code "
" directory. "
REPLACE {$move_file} WITH {'mv -f '};

" There appears to be no way of removing a directory from Fortran "
" => we use a system call for this. "
REPLACE {$remove_directory} WITH {'rm -rf '};

" The directory separator "
REPLACE {$file_sep} WITH {'/'};

REPLACE {$LONG_INT} WITH { integer*8 };
REPLACE {$SHORT_INT} WITH { integer*2 };
"$MAX_INT SET TO 2^63-1 in egsnrc.macros"
"The machine byte order"
REPLACE {$BYTE_ORDER} WITH {'1234'};
;
REPLACE {$RECL-FACTOR} WITH {4};
;
REPLACE {$FLUSH_UNIT(#);} WITH {call flush({P1});}
;
" If you want your user-code to return an exit status, use the "
" following macro to terminate execution"
REPLACE {$CALL_EXIT(#);} WITH {call exit({P1});}
;
" mortran3 gets confused by the # char => we need to pass it as an "
" argument to the macro. "
REPLACE {$HAVE_C_COMPILER(#);} WITH {{EMIT;{P1}define HAVE_C_COMPILER};}
;
REPLACE {$HAVE_LOAD_DSO(#);} WITH {{EMIT;{P1}define HAVE_LOAD_DSO};}
;
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc common block reorganization for C interface                         "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Iwan Kawrakow, 2003                                       "
"                                                                             "
"  Contributors:    Ernesto Mainegra-Hing                                     "
"                   Blake Walters                                             "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This is a set of macros that slightly re-organizes EGSnrc common blocks,   "
"  so that only a relatively small set of common blocks needs to be exported  "
"  as C structures. It is only needed when generating the EGSnrc fortran code "
"  used with the C inteface and should get included after egsnrc.macros.      "
"                                                                             "
"  In the original ecut, pcut are arrays of dimension $MXREG, where $MXREG is "
"  a macro that defines the maximum number of regions the geometry can have.  "
"  For the C/C++ interface we wish to completely decouple EGSnrc routines     "
"  from the geometry so that the C/C++ user code programmer can dynamically   "
"  allocate resources depending on the actual number of regions. We therefore "
"  use ecut, pcut, ecut_new, pcut_new to interact with the user with respect  "
"  to particle transport cut-off energies. ecut, ecut_new, pcut, pcut_new are "
"  initialized to zero by default. If the user does not wish to use transport "
"  thresholds different than the particle production thresholds ae and ap,    "
"  they don't need to do anything with ecut, ecut_new, pcut, pcut_new. If the "
"  user wants to use higher thresholds, possibly different from one region to "
"  another, then the user code must do the following:                         "
"                                                                             "
"  - In the function start_new_particle() called before the transport of      "
"    a new particle starts, the user should set pcut and ecut to the desired  "
"    values based on the region number of the top particle on the stack.      "
"                                                                             "
"  - In howfar(), the user should set ecut_new, pcut_new to the desired       "
"    values in the new region after the step (provided the particle is        "
"    entering a new region, i.e., irnew is different from ir(np), see the     "
"    geometry interface specs)                                                "
"                                                                             "
"#############################################################################"


" Single or double precision for floating point operations "
REPLACE {$REAL} WITH {EGS_Float};


" Take care of the rundom numner generator "
REPLACE {$NRANDOM} WITH {128};
REPLACE {;COMIN/RANDOM/;} WITH {;
    common/randomm/ rng_array($NRANDOM), rng_seed;
    integer*4       rng_seed;
    $REAL           rng_array;
};
REPLACE {$RANDOMSET#;} WITH {;
    IF( rng_seed > $NRANDOM ) [
        rng_seed = $NRANDOM;
        call egs_fill_rndm_array(rng_seed,rng_array);
        rng_seed = 1;
    ]
    {P1} = rng_array(rng_seed); rng_seed = rng_seed + 1;
};
REPLACE {$RNG-DEFAULT-INITIALIZATION;} WITH {;};
REPLACE {$INITIALIZERNGUSING#AND#;} WITH {;
 $egs_fatal(*,
 'The INITIALIZE RNG USING macro should not be used with the C++ interface!');
};

REPLACE {;COMIN/BOUNDS/;} WITH {

 ;common/bounds/ ecut, pcut, ecut_new, pcut_new, vacdst;
  $REAL          ecut, pcut, ecut_new, pcut_new, vacdst;

};

" Remove iprdst, ibrdst and ibr_nist, they will go into a "
" a cross section options common that will get exported   "
REPLACE {;COMIN/BREMPR/;} WITH {
 ;common/brempr/
     $LGN(DL(8,$MXMED)/1,2,3,4,5,6/),
     $LGN(ALPHI,BPAR,DELPOS(2,$MXMED)),
     $LGN(WA,PZ,ZELEM,RHOZ($MXMED,$MXEL)),
     PWR2I($MXPWR2I),
     $LGN(DELCM,ZBRANG,LZBRANG,NNE($MXMED)),
     ASYM($MXMED,$MXEL,2);
  $TYPE     ASYM;
  $REAL     $LGN(DL/1,2,3,4,5,6/),ALPHI,BPAR,DELPOS,WA,PZ,ZELEM,
            RHOZ,PWR2I,DELCM,ZBRANG,LZBRANG;
  $INTEGER  NNE;

};

" Remove ibcmp, which will go into the cross section options common "
" that will get exported                                            "
REPLACE {;COMIN/COMPTON-DATA/;} WITH {

  ;common/compton_data/ iz_array($MXTOTSH),be_array($MXTOTSH),
                        Jo_array($MXTOTSH),erfJo_array($MXTOTSH),
                        ne_array($MXTOTSH),shn_array($MXTOTSH),
                        shell_array($MXMDSH,$MXMED),
                        eno_array($MXMDSH,$MXMED),
                        eno_atbin_array($MXMDSH,$MXMED),n_shell($MXMED);
  $INTEGER              iz_array,ne_array,shn_array,
                        shell_array,eno_atbin_array,n_shell;
  $REAL                 be_array,Jo_array,erfJo_array,eno_array;

};

" Remove iedgfl and iphter, to go into the cross section options common "
REPLACE {;COMIN/EDGE/;} WITH
{;
   COMMON/EDGE/binding_energies($MXSHXSEC,$MXELEMENT),
               interaction_prob($MXSHELL,$MXELEMENT),
               relaxation_prob($MXTRANS,$MXELEMENT),
               edge_energies($MXEDGE,$MXELEMENT),
               edge_number($MXELEMENT),
               edge_a($MXEDGE,$MXELEMENT),
               edge_b($MXEDGE,$MXELEMENT),
               edge_c($MXEDGE,$MXELEMENT),
               edge_d($MXEDGE,$MXELEMENT);
   $REAL       binding_energies, interaction_prob, relaxation_prob,
               edge_energies, edge_a,edge_b,edge_c,edge_d;
   $INTEGER    edge_number;
};

" Remove spin_effects, which determines a cross section being used     "
" and is therefore logically better to be in the cross section options "
" common. smaxir used to be an array that provides a max. geometrical  "
" step size restriction on a region-by-region basis. But we wish to    "
" decouple EGSnrc for the geometry (see comments about ecut, pcut      "
" above). smaxir, smax_new are set by default to 1e10, i.e. no step    "
" size restriction. If the user wishes to control smax, possibly on a  "
" region by region bases, then                                         "
"   - set smaxir to the desired value in start_new_particle()          "
"   - set smax_new to the desired value in howfar(), if the particle   "
"     will enter a new region after the step.                          "
REPLACE {;COMIN/ET-Control/;} WITH {
  ;common/ET_control/
              smaxir,smax_new,estepe,ximax,skindepth_for_bca,
              transport_algorithm,bca_algorithm,exact_bca;
    $REAL     smaxir,smax_new,estepe,ximax,skindepth_for_bca;
    $INTEGER  transport_algorithm,bca_algorithm;
    $LOGICAL  exact_bca;
};

" From MEDIA, the only variables that the C user should have access to "
" rho and nmed (the functions egs_add_medium and egs_set_medium are    "
" provided for accessing media names)                                  "
" => split COMIN/MEDIA/ into 2 commons and export only the second      "
REPLACE {;COMIN/MEDIA/;} WITH {
  ;COMMON/MEDIA_p/ $LGN(RLC,RLDU,MSGE,MGE,MSEKE,
                   MEKE,MLEKE,MCMFP,MRANGE,IRAYLM,IPHOTONUCM($MXMED)),
                   MEDIA(24,$MXMED);
   $TYPE    MEDIA;
   $REAL    RLC,RLDU;
   $INTEGER MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM,
            IPHOTONUCM;
   common/media/   rho($MXMED),photon_xsections,eii_xfile,
                   comp_xsections,photonuc_xsections,
                   nmed;
   $REAL           rho;
   $INTEGER        nmed;
   character*16    photon_xsections;
   character*16    eii_xfile;
   character*16    comp_xsections;
   character*16    photonuc_xsections;
};

" IRAYLR gets removed and goes into the x-section options.             "
" rhor and med are also removed so that EGSnrc can be decoupled from the"
" geometry (see comment about ecut, pcut and also smax above)          "
" EGSnrc obtains medium information in the following manner:           "
"  - in start_new_particle() the user must set medium and rhor (in     "
"    common/useful/) to the medium index and mass density scaling for  "
"    region of the top particle on the stack. rhor is the ratio of the "
"    mass density in that region to the default mass density of the    "
"    medium occupying the region and is normally 1, but can be used    "
"    to overwrite the default mass density. Note that this is different"
"    from the original EGSnrc implementation where rhor(irl) was the   "
"    actual mass density, not the ratio of actual to default.          "
"  - in howfar(), the user must set medium_new and rhof_new to the     "
"    values in the new region, if the particle will enter a new region "
"    after the step.                                                   "

REPLACE {;COMIN/EII-DATA/;} WITH {;
    common/eii_data/
        eii_xsection_a($MAX_EII_BINS), "EII x-section interpolation coeff."
        eii_xsection_b($MAX_EII_BINS), "EII x-section interpolation coeff."
        eii_cons($MXMED),
        eii_a($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
        eii_b($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
        eii_L_factor,                  "L-shell EII xsection scaling factor"
        eii_z($MAX_EII_SHELLS),        "Z of each shell                   "
        eii_sh($MAX_EII_SHELLS),       "shell type (1=K, 2=LI, eyc.)      "
        eii_nshells($MXELEMENT),       "No. of EII shells for each element"
        eii_nsh($MXMED),               "No. of EII shells for each medium "
        eii_first($MXMED,$MXEL),       "First EII shell in the list of shells"
        eii_no($MXMED,$MXEL);          "N. of EII shells                  "
    $REAL     eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_factor;
    $INTEGER  eii_z,eii_sh,eii_nshells;
    $INTEGER  eii_first,eii_no;
    $INTEGER  eii_elements,eii_nsh;
};

REPLACE {;COMIN/MISC/;} WITH {
  ;common/misc/ DUNIT,KMPI,KMPO;
   $REAL        DUNIT;
   $INTEGER     KMPI,KMPO;
};

REPLACE {;COMIN/USEFUL/;} WITH {
 ;common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medium_new,
                 medold;
  real*8         pzero, prm, prmt2;
  $REAL          rm, rhor, rhor_new;
  $INTEGER       medium, medium_new, medold;
  data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D0/;
};

" And now the cross section options common                             "
" Some of the flags were originally arrays for turning on/off options  "
" on a region-by-rgion basis (ibcmp, iraylr, iedgfl, iphter).          "
" If you wish to change the options from their default, use this common"
" For the options that need data to be loaded (iraylr, ibcmp, iedgfl,  "
" ibr_nist, spin_effects), make sure that they are set before calling  "
" hatch. If you want to vary these options by region, then             "
"   - set the appropriate ausgab flag to be called before the          "
"     interaction                                                      "
"   - in ausgab, set the flag to the desired value.                    "
REPLACE {;COMIN/X-OPTIONS/;} WITH {
 ;common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects,
                           ibcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet,
                           radc_flag,eii_flag,iphotonuc,
                           eadl_relax, mcdf_pe_xsections;
  $INTEGER                 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc,
                           ibcmp,iraylr,iedgfl,iphter,pair_nrc,
                           radc_flag,itriplet;
  $LOGICAL                 spin_effects;
  $LOGICAL  eadl_relax, mcdf_pe_xsections;
};

" Again, to remove geometry dependence make e_max_rr and i_do_rr sclars"
REPLACE {;COMIN/EGS-VARIANCE-REDUCTION/;} WITH {;
 common/egs_vr/  e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_RR,
                 i_survived_RR, n_RR_warning, i_do_rr;
  $REAL          e_max_rr,e_max_rr_new,prob_RR;
  $INTEGER       nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr;
};

" We now have to replace all occurences of arrays of dimension $MXREG "
" to scalars                                                          "
REPLACE {pcut(#)} WITH {pcut};
REPLACE {PCUT(#)} WITH {pcut};
REPLACE {ecut(#)} WITH {ecut};
REPLACE {ECUT(#)} WITH {ecut};
REPLACE {med(#)} WITH {med};
REPLACE {MED(#)} WITH {med};
REPLACE {rhor(#)} WITH {rhor};
REPLACE {RHOR(#)} WITH {rhor};
REPLACE {ibcmp(#)} WITH {ibcmp};
REPLACE {IBCMP(#)} WITH {ibcmp};
REPLACE {iraylr(#)} WITH {iraylr};
REPLACE {IRAYLR(#)} WITH {iraylr};
REPLACE {iedgfl(#)} WITH {iedgfl};
REPLACE {IEDGFL(#)} WITH {iedgfl};
REPLACE {iphter(#)} WITH {iphter};
REPLACE {IPHTER(#)} WITH {iphter};
REPLACE {smaxir(#)} WITH {smaxir};
REPLACE {SMAXIR(#)} WITH {smaxir};
REPLACE {e_max_rr(#)} WITH {e_max_rr};
REPLACE {i_do_rr(#)} WITH {i_do_rr};
REPLACE {iphotonucr(#)} WITH {iphotonuc};
REPLACE {IPHOTONUCR(#)} WITH {IPHOTONUC};

" Set default values "
REPLACE {$set-region-by-region-defaults;} WITH {;
  ecut = 0; pcut = 0; smaxir = $MAX-SMAX;
  ecut_new = 0; pcut_new = 0; smax_new = $MAX-SMAX;
  rhor = 1; rhor_new = 1;
  ibcmp = $IBCMP-DEFAULT;
  iraylr = $IRAYLR-DEFAULT; iphotonuc=$IPHOTONUCR-DEFAULT;
  iedgfl = $IEDGFL-DEFAULT; iphter = $IPHTER-DEFAULT;
  i_do_rr = 0; e_max_rr = 0; e_max_rr_new = 0;
};

"below replaces version in $HEN_HOUSE/egsnrc.macros"
"necessary for setting smax_new to default SMAX in the case where"
"smaxir was set by the user <=0.  Both SMAXIR and smax_new must then be reset"
"to the default SMAX.  Situation arises because user values are input"
"after setting defaults via the $set-region-by-region-defaults macro"
"above."
REPLACE {$HATCH-USER-INPUT-INIT;} WITH {;
DO J=1,$MXREG [
  IF(smaxir(J)<=0.0) [smaxir(J)=$MAX-SMAX;]
]
IF(smax_new<=0.0) [smax_new=$MAX-SMAX;]
;}

" Should bound compton data be loaded ? "
REPLACE {$need_bound_compton_data(#);} WITH { {P1} = ibcmp.gt.0; };

" Should relaxation data be loaded ? "
REPLACE {$need_relaxation_data(#);} WITH {
  {P1} = (iedgfl.gt.0.and.iedgfl.le.100);
};

" Are Rayleigh data required ? "
REPLACE {$need_rayleigh_data;} WITH {;
  DO j=1,nmed [ iraylm(j) = iraylr; ]
};

" Are photonuclear data required ? "
REPLACE {$need_photonuc_data;} WITH {;
  DO j=1,nmed [ iphotonucm(j) = iphotonuc; ]
};

" rhor, ecut, pcut initializtion in hatch "
REPLACE {$adjust_rhor_ecut_pcut;} WITH {;
    DO md=1,nmed [
        ecut = max(ecut,ae(md));
        pcut = max(pcut,ap(md));
    ]
};

" hownear and range discard: before calling hownear, we set e_range in "
" common/epcont/ to the residual range of the electron and idisc to 0  "
" In hownear the user calculates the minimum perpendicular distance to "
" a boundary. If the user wishes to range-discard the electron, he/she "
" should set idisc (also in /epcont/) to 50 + 49*iq(np).               "

REPLACE {$CALL-HOWNEAR(#);} WITH {
  e_range = range; idisc = 0; call egs_hownear({P1});
};

REPLACE {$CALL-HOWFAR-IN-ELECTR;} WITH {;
  IF(callhowfar | wt(np) <= 0) [ call egs_howfar; ]
};

REPLACE {$CALL-HOWFAR-IN-PHOTON;} WITH {;
  IF( ustep > dnear(np) | wt(np) <= 0 ) [ call egs_howfar; ]
};

REPLACE {$AUSCALL(#);} WITH {
   iarg={P1};
   IF (IAUSFL(IARG+1).NE.0) [call egs_ausgab(iarg);]
};



" Range discard is up to the user
REPLACE {$RANGE-DISCARD;} WITH {;
  IF( idisc > 0 ) goto :USER-ELECTRON-DISCARD:;
};

" Minimum ecut for default min. step-size for PRESTA-I BCA "
REPLACE {$set_ecutmn;} WITH {
  ecutmn = 1e30;
  DO i=1,nmed [
      ecutmn = Min(ecutmn,ae(i));
  ]
  ecutmn = Max(ecutmn,ecut);
};

REPLACE {$start_new_particle;} WITH {
    call egs_start_particle;
    IF( idisc > 0 ) [ np=np-1; return; ]
};

REPLACE {$electron_region_change;} WITH {
  ir(np) = irnew; irl = irnew; rhor = rhor_new;
  medium = medium_new; ecut = ecut_new; smaxir = smax_new;
  Bx=Bx_new;By=By_new;Bz=Bz_new;
};

REPLACE {$photon_region_change;} WITH {
  ir(np) = irnew; irl = irnew; rhor = rhor_new;
  medium = medium_new; pcut = pcut_new;
};

REPLACE {$SET-RHOF;} WITH { rhof = rhor; };

REPLACE {$default_nmed} WITH {0};

REPLACE {narg = iargc();} WITH {call egs_iargc(narg);};
REPLACE {call getarg(#,#);} WITH {call egs_getarg({P1},{P2});};

" The following set of macros is there so that $MXSTACK and $MXMED "
" get defined via the macros in array_sizes.h                      "
REPLACE {$MXMED} WITH {max_med};
REPLACE {$MXSTACK} WITH {max_stack};
REPLACE {;COMIN/STACK/;} WITH {;
  integer max_stack; parameter (max_stack = MXSTACK);
  common/stack/
    $LGN(E,X,Y,Z,U,V,W,DNEAR,WT,IQ,IR,LATCH($MXSTACK)),
         LATCHI,NP,NPold;
    $ENERGY PRECISION E;
    $REAL             X,Y,Z,U,V,W,DNEAR,WT;
    $INTEGER          IQ,IR,LATCH,LATCHI,NP,NPold;
};
REPLACE {$COMIN-BREMS;} WITH {;
  ;integer max_med; parameter (max_med = MXMED);
  ;COMIN/DEBUG,BREMPR,EPCONT,NIST-BREMS,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
         EGS-VARIANCE-REDUCTION,EGS-IO/;
};
REPLACE {$COMIN-HATCH;} WITH {;
  ;integer max_med; parameter (max_med = MXMED);
  ;COMIN/DEBUG,BOUNDS,BREMPR,ELECIN,MEDIA,MISC,PHOTIN,STACK,THRESH,
         UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,
         EGS-VARIANCE-REDUCTION,EGS-IO/;
};
REPLACE {$COMIN-PAIR;} WITH {;
  ;integer max_med; parameter (max_med = MXMED);
  ;COMIN/DEBUG,BREMPR,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
          EPCONT,NRC-PAIR-DATA,TRIPLET-DATA,EGS-VARIANCE-REDUCTION,EGS-IO/;
};
REPLACE {$COMIN-PHOTO;} WITH {;
  ;integer max_med; parameter (max_med = MXMED);
  ;COMIN/BOUNDS,BREMPR,DEBUG,EDGE,EPCONT,MEDIA,PHOTIN,RANDOM,
         STACK,UPHIOT,USEFUL,EGS-VARIANCE-REDUCTION,EGS-IO,RELAX-DATA/;
};
REPLACE {$COMIN-PHOTON;} WITH {;
  ;integer max_med; parameter (max_med = MXMED);
  ;COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,UPHIOT,
         USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;
};
REPLACE {$COMIN-SET-DEFAULTS;} WITH {;
  ;integer max_med; parameter (max_med = MXMED);
  ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,EPCONT,CH-Steps,ET-Control,
         MEDIA,MISC,PHOTIN,RANDOM,STACK,THRESH, UPHIIN,UPHIOT,USEFUL,
         EGS-VARIANCE-REDUCTION,EGS-IO,Spin-Data,EII-DATA,rayleigh_inputs,
         EMF-INPUTS/;
};
REPLACE {$COMIN-INIT-COMPT;} WITH {;
  ;integer max_med; parameter (max_med = MXMED);
  ;COMIN/COMPTON-DATA,BREMPR,EDGE,MEDIA,MISC,USEFUL,EGS-IO/;
};
REPLACE {$COMIN-COMPT;} WITH {;
  ;integer max_med; parameter (max_med = MXMED);
  ;COMIN/COMPTON-DATA,DEBUG,EPCONT,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
         EGS-VARIANCE-REDUCTION,EGS-IO,RELAX-DATA/;
};
REPLACE {$COMIN-ELECTR;} WITH {;
  ;integer max_med; parameter (max_med = MXMED);
  ;COMIN/DEBUG,BOUNDS,ELECIN,EPCONT,MEDIA,MISC,STACK,THRESH,
         UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,CH-Steps,
         EGS-VARIANCE-REDUCTION,EGS-IO,EMF-INPUTS/;
};
REPLACE {$COMIN-MSCATI;} WITH {;
  ;integer max_med; parameter (max_med = MXMED);
  ;COMIN/BOUNDS,ELECIN,MEDIA,MISC,RANDOM,ET-Control,USEFUL,EGS-IO/;
};
REPLACE {$COMIN-MOLLER;} WITH {;
  ;integer max_med; parameter (max_med = MXMED);
  ;COMIN/DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
         EGS-VARIANCE-REDUCTION,EGS-IO/;
};
REPLACE {$COMIN-BHABHA;} WITH {;
  ;integer max_med; parameter (max_med = MXMED);
  ;COMIN/DEBUG,STACK, THRESH,UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,
         EGS-IO/;
};

REPLACE {$COMIN-EII-INIT;} WITH {;
  ;integer max_med; parameter (max_med = MXMED);
  ;COMIN/BREMPR,EDGE,EGS-IO,EII-DATA,ELECIN,MEDIA,THRESH,USEFUL/;
};
REPLACE {$COMIN-EII-SAMPLE;} WITH {
  ;integer max_med; parameter (max_med = MXMED);
  ;COMIN/EPCONT,EII-DATA,EGS-VARIANCE-REDUCTION,RANDOM,STACK,THRESH,
         UPHIOT,USEFUL,EGS-IO,RELAX-DATA/;
};

REPLACE {$declare_max_medium;} WITH {
  ;integer max_med; parameter (max_med = MXMED);
};

#include 'array_sizes.h';
#ifdef SINGLE;
#define EGS_Float real*4;
#else;
#define EGS_Float real*8;
#endif;
#define EGS_Float4 real*4;

" The following set of macros takes care of the various cross section "
" options being available when needed                                 "

APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-SET-DEFAULTS;};
APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-BREMS;};
APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-COMPT;};
APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-ELECTR;};
APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-HATCH;};
APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-INIT-COMPT;};
APPEND {;COMIN/THRESH,X-OPTIONS/;} TO {$COMIN-MSCATI;};
APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-PAIR;};
APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-PHOTO;};
APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-PHOTON;};
APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-EII-INIT;};
APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-INIT-TRIPLET;};
"APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-GET-TRANSPORTP;}; already there"
APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-MOLLER;};
APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-RADC-INIT;};
APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-INIT-NIST-BREMS;};

" make a couple of renames "
REPLACE {subroutine egs_init;} WITH {subroutine egs_init_f;};
REPLACE {SUBROUTINE HATCH;} WITH {subroutine egs_hatch;};

/*
   The folowing was an ttempt to redirect fortran I/O
   to the C++ interface. Unfortunately it fails with
   segmentation violations in the fortran I/O
   subroutines that I don't understand.

" redirect I/O from the fortran subroutines to the C++ application "
REPLACE {$egs_info(#,#);} WITH {
    write(write_buffer,{P1}) {P2};
    call egs_info_output(write_buffer);
};
REPLACE {$warning(#,#);} WITH {
    write(write_buffer,{P1}) {P2};
    call egs_warning_output(write_buffer);
};
REPLACE {$declare_write_buffer;} WITH {character*8192 write_buffer;};

APPEND {$declare_write_buffer;} TO {$DEFINE-LOCAL-VARIABLES-ANNIH;};
APPEND {$declare_write_buffer;} TO {$DEFINE-LOCAL-VARIABLES-BHABHA;};
APPEND {$declare_write_buffer;} TO {$DEFINE-LOCAL-VARIABLES-BREMS;};
APPEND {$declare_write_buffer;} TO {$DEFINE-LOCAL-VARIABLES-COMPT;};
APPEND {$declare_write_buffer;} TO {$DEFINE-LOCAL-VARIABLES-COMPT-old;};
APPEND {$declare_write_buffer;} TO {$DEFINE-LOCAL-VARIABLES-ELECTR;};
APPEND {$declare_write_buffer;} TO {$DEFINE-LOCAL-VARIABLES-HATCH;};
APPEND {$declare_write_buffer;} TO {$DEFINE-LOCAL-VARIABLES-MOLLER;};
APPEND {$declare_write_buffer;} TO {$DEFINE-LOCAL-VARIABLES-PAIR;};
APPEND {$declare_write_buffer;} TO {$DEFINE-LOCAL-VARIABLES-PHOTON;};
APPEND {$declare_write_buffer;} TO {$DEFINE-LOCAL-VARIABLES-PHOTO;};
APPEND {$declare_write_buffer;} TO {$COMIN-INIT-TRIPLET;};
APPEND {$declare_write_buffer;} TO {$COMIN-EII-SAMPLE;};

*/
%F
C##############################################################################
C
C   This file was automatically generated by configure version 2.0
C   It contains various subroutines and functions for date, time,
C   CPU time, host name, etc.
C
C   Attention: all changes will be lost the next time you run configure!
C
C##############################################################################


C##############################################################################
C
C  EGSnrc egs_system subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C egs_system(command)  runs a system command and returns the status
C                      command must be null-terminated
C*****************************************************************************
      integer function egs_system(command)
      character*(*) command
      integer system, istat
      istat = system(command)
      egs_system = istat
      return
      end

C##############################################################################
C
C  EGSnrc egs_isdir subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C  egs_isdir(file_name)  Returns .true., if the string file_name points to
C                        an existing directory. This version uses the lstat
C                        intrinsic and then tests for bit 14 being set in
C                        the mode element. This works on all Unix systems
C                        that I have access to (Linux, Aix, HP-UX, OSF1,
C                        Solaris, IRIX)
C
C*****************************************************************************

      logical function egs_isdir(file_name)
      implicit none
      character*(*) file_name
      integer*4 lnblnk1, res, array(13), l, lstat
      logical btest
      egs_isdir = .false.
      l = lnblnk1(file_name)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = char(0)
         ! On some systems lstat only works if the string is 0-terminated
      res = lstat(file_name,array)
      if( l.lt.len(file_name) ) file_name(l+1:l+1) = ' '
      if( res.eq.0 ) then
            ! Amost all compilers that have the lstat intrinsic return the
            ! file mode in the 3rd array element. But the PGI compiler has
            ! its own opinion on the subject and returns it in the 5th element
            ! That's why the relevant element is written as 3
            ! here, 3 gets replaced by the appropriate element
            ! by the configure script.
          if( btest(array(3),14) ) egs_isdir = .true.
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C***************************************************************************
C
C   egs_fdate(out):  print a 24 char date and time string in the form
C                         'Tue Mar 18 08:16:42 2003'
C                    to the unit specified by out without end of line
C                    i.e. the sequence
C                    write(6,'(a,$)') 'Today is '
C                    call egs_fdate(6)
C                    write(6,'(a)') '. Have a nice date'
C                    should result in something like
C                    Today is Tue Mar 18 08:16:42 2003. Have a nice date
C                    printed to unit 6.
C
C***************************************************************************

      subroutine egs_fdate(ounit)
      integer ounit
      character*24 string
      call fdate(string)
      write(ounit,'(a,$)') string
      end

C***************************************************************************
C
C   egs_get_fdate(string) assignes a 24 char date and time string to string
C                         string must be at least 24 chars long, otherwise
C                         this subroutine has no effect.
C
C***************************************************************************

      subroutine egs_get_fdate(string)
      character*(*) string
      if( len(string).ge.24 ) call fdate(string)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date_and_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


      subroutine egs_date_and_time(vnow)
      integer vnow(8)
      character dat*8,tim*10,zon*5
      call date_and_time(dat,tim,zon,vnow)
      return
      end

C##############################################################################
C
C  EGSnrc egs_date subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*************************************************************************
C
C egs_date(ounit): print a 11 char string in the form
C                     '18-Mar-2003'
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_date(ounit)
      integer ounit
      character string*24, dat*11
      call fdate(string)
      dat(1:2) = string(9:10)
      dat(3:3) = '-'
      dat(4:6) = string(5:7)
      dat(7:7) = '-'
      dat(8:11) = string(21:24)
      write(ounit,'(a,$)') dat
      return
      end

C##############################################################################
C
C  EGSnrc egs_time subroutine v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C $Id: egs_time_v1.f,v 1.1 2003/07/11 19:17:08 iwan Exp $
C*************************************************************************
C
C egs_time(ounit): print a 8 char string in the form hh:mm:ss
C                  to the unit specified by ounit
C                  No end of line character is inserted
C
C*************************************************************************

      subroutine egs_time(ounit)
      integer ounit
      character string*24
      call fdate(string)
      write(ounit,'(a,$)') string(12:19)
      return
      end

C##############################################################################
C
C  EGSnrc seconds timing subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_secnds(t0): returns seconds passed since midnight minus t0
C
C*****************************************************************************

      real function egs_secnds(t0)
      real t0,t1
      character dat*8,tim*10,zon*5
      integer values(8)
      call date_and_time(dat,tim,zon,values)
      t1 = 3600.*values(5) + 60.*values(6) + values(7) + 0.001*values(8)
      egs_secnds = t1 - t0
      return
      end

C*****************************************************************************
C
C real function egs_tot_time()
C
C   On first call returns seconds passed since 1/1/1970
C   On subsequent calls returns
C     - seconds since last call, if flag = 0
C     - seconds since first call, else
C
C*****************************************************************************

      real function egs_tot_time(flag)
      integer flag
      character dat*8,tim*10,zon*5
      integer vnow(8), vlast(8),i
      real t,egs_time_diff,t0
      data vlast/1970,1,1,5*0/,t0/-1/
      save vlast,t0
      call date_and_time(dat,tim,zon,vnow)
      t = egs_time_diff(vlast,vnow)
      do i=1,8
        vlast(i)=vnow(i)
      end do
      if( t0.lt.0 ) then
        t0 = 0
        egs_tot_time = t
      else
        t0 = t0 + t
        if(flag.eq.0) then
          egs_tot_time = t
        else
          egs_tot_time = t0
        end if
      end if
      return
      end

C##############################################################################
C
C  EGSnrc date and time subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C****************************************************************************
C
C Returns the time difference between vstart and vend
C vstart and vend are integer arrays of dimension 8 with elements
C corresponding to the specification of the data_and_time routine, i.e.
C   array(1) = year
C   array(2) = month of the year   (1...12)
C   array(3) = day of the month    (1...31)
C   array(4) = difference in minutes from UTC
C   array(5) = hour of the day     (1...23)
C   array(6) = minute of the hour  (1...59)
C   array(7) = seconds of the minute (1...59)
C   array(8) = miliseconds of the second (1...999)
C
C Note: this implementation ignores the time difference from UTC field
C
C*****************************************************************************
      real function egs_time_diff(vstart,vend)
      integer    vstart(8),vend(8)
      real       egs_time_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_time_diff = -egs_time_diff_o(vend,vstart)
      else
        egs_time_diff = egs_time_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C day difference between the dates specified by the integer arrays vstart and
C vend. The arrays are v(1)=year, v(2)=month, v(3)=day
C
C******************************************************************************
      integer function egs_day_diff(vstart,vend)
      integer vstart(3),vend(3),egs_day_diff_o
      if( vend(1).lt.vstart(1).or.
     &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
        egs_day_diff = -egs_day_diff_o(vend,vstart)
      else
        egs_day_diff = egs_day_diff_o(vstart,vend)
      end if
      return
      end

C******************************************************************************
C
C Returns a 3-letter abreviation of the day of the week in the string day,
C given a day specified by the integer array values
C   values(1)=year, values(2)=month, values(3)=day
C
C******************************************************************************
      subroutine egs_weekday(values,day)
      character*(*) day
      integer       values(3)
      integer       days,vtmp(3),egs_day_diff,aux
      character*3   wdays(7)
      data wdays/'Mon','Tue','Wed','Thu','Fri','Sat','Sun'/
      vtmp(1) = 1970
      vtmp(2) = 1
      vtmp(3) = 1
      days = egs_day_diff(vtmp,values)
      aux = mod(days,7)
      days = 4 + aux
      if( days.gt.7 ) days = days - 7
      day(:len(day)) = ' '
      aux = min(len(day),3)
      day(:aux) = wdays(days)(:aux)
      return
      end

C*****************************************************************************
C
C Same as egs_day_diff above, but assumes that vend specifies a later date
C than vstart.
C
C*****************************************************************************
      integer function egs_day_diff_o(vstart,vend)
      integer vstart(3),vend(3)
      integer    days
      logical    next_month
      integer    tm,m,ty,y
      integer    mdays(12)
      data       mdays/31,28,31,30,31,30,31,31,30,31,30,31/
      days = 0
      ty = vstart(1)
      y  = vend(1)
      tm = vstart(2)
      m  = vend(2)
      next_month = .true.
      do while(next_month)
        if( tm.eq.m.and.ty.eq.y ) then
          next_month = .false.
        else
          days = days + mdays(tm)
          if( tm.eq.2.and.mod(ty,4).eq.0 ) days = days + 1
          tm = tm + 1
          if( tm.gt.12 ) then
            ty = ty + 1
            tm = 1
          end if
        end if
      end do
      days = days + vend(3) - vstart(3)
      egs_day_diff_o = days
      return
      end

C******************************************************************************
C
C Same as egs_time_diff above, but assumes that vend specifies a later date
C than vstart.
C
C******************************************************************************
      real function egs_time_diff_o(vstart,vend)
      integer    vstart(8),vend(8)
      integer    days,hours,minutes,secs,msecs
      integer    egs_day_diff_o
      days = egs_day_diff_o(vstart,vend)
      hours = vend(5) - vstart(5)
      minutes = vend(6) - vstart(6)
      secs = vend(7) - vstart(7)
      msecs = vend(8) - vstart(8)
      egs_time_diff_o = 3600.*(24.*days+hours)+60.*minutes+secs+
     &                  0.001*msecs
      return
      end

C******************************************************************************
C
C Returns in month a 3-letter abreviation of the month specified by mo, if
C mo is between 1 and 12, or an empty string otherwise.
C
C******************************************************************************
      subroutine egs_month(mo,month)
      integer mo
      character*(*) month
      integer iaux
      character*3   months(12)
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      iaux = min(len(month),3)
      month(:len(month)) = ' '
      if( mo.ge.1.and.mo.le.12 ) month(:iaux) = months(mo)(:iaux)
      return
      end

C******************************************************************************
C
C Converts a 3-letter abreviation of a month to its corresponding integer
C value, if the string month is a valid month, or -1 otherwise.
C
C******************************************************************************
      integer function egs_conver_month(month)
      character*3 month
      character*3 months(12)
      integer i
      data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
     *,'Oct','Nov','Dec'/
      do i=1,12
        if( month.eq.months(i) ) then
          egs_conver_month = i
          return
        end if
      end do
      egs_conver_month = -1
      return
      end


C##############################################################################
C
C  EGSnrc egs_etime subroutine
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C real function egs_etime(): returns CPU time consumed since the start of
C                            the program
C
C*****************************************************************************

      real function egs_etime()
      real tarray(2),etime
      egs_etime = etime(tarray)
      return
      end

C##############################################################################
C
C  EGSnrc canonical system name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the canonical system name as determined by the config.guess script
C or the Windows installation program to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_canonical_system(ounit)
      integer ounit
      write(6,'(a,$)') 'x86_64-unknown-linux-gnu'
      return
      end

C******************************************************************************
C
C Assign the canonical system name as determined by the config.guess script
C or the Windows installation program to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_canonical_system(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('x86_64-unknown-linux-gnu')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'x86_64-unknown-linux-gnu'
      else
        res(:l2) = 'x86_64-unknown-linux-gnu'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc configuration name subroutines
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C******************************************************************************
C
C Print the configuration name as specified suring the configuration
C process to the unit specified by ounit.
C
C*****************************************************************************

      subroutine egs_print_configuration_name(ounit)
      integer ounit
      write(6,'(a,$)') 'linux'
      return
      end

C******************************************************************************
C
C Assign the configuration name as specified suring the configuration
C process to the string pointed to by res
C
C******************************************************************************

      subroutine egs_get_configuration_name(res)
      character*(*) res
      integer l1,l2
      l1 = lnblnk1('linux')
      l2 = len(res)
      res(:l2) = ' '
      if( l2.ge.l1 ) then
        res(:l1) = 'linux'
      else
        res(:l2) = 'linux'
      end if
      return
      end


C##############################################################################
C
C  EGSnrc hostname subroutines v1
C  Copyright (C) 2015 National Research Council Canada
C
C  This file is part of EGSnrc.
C
C  EGSnrc is free software: you can redistribute it and/or modify it under
C  the terms of the GNU Affero General Public License as published by the
C  Free Software Foundation, either version 3 of the License, or (at your
C  option) any later version.
C
C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
C  more details.
C
C  You should have received a copy of the GNU Affero General Public License
C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
C
C##############################################################################
C
C  Author:          Iwan Kawrakow, 2003
C
C  Contributors:
C
C##############################################################################


C*****************************************************************************
C
C Print the host name to the unit specified by ounit without inserting
C a new line character.
C
C*****************************************************************************

      subroutine egs_print_hostnm(ounit)
      integer ounit
      character*256 string
      integer res,hostnm,lnblnk1
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      write(ounit,'(a,$)') string(:lnblnk1(string))
      return
      end

C*****************************************************************************
C
C Assign the host name to the string pointed to be hname.
C
C*****************************************************************************

      subroutine egs_get_hostnm(hname)
      character*(*) hname
      character*256 string
      integer res,hostnm,lnblnk1,l1,l2,l
      res = hostnm(string)
      if( res.ne.0 ) then
        write(6,'(a,a)') 'hostnm returned with a non-zero status '
        stop
      end if
      l1 = lnblnk1(string)
      l2 = len(hname)
      hname(:l2) = ' '
      l = min(l1,l2)
      hname(:l) = string(:l)
      return
      end

%M
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc I/O functions                                                       "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Iwan Kawrakow, 2003                                       "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Ernesto Mainegra-Hing                                     "
"                   Blake Walters                                             "
"                   Frederic Tessier                                          "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
" Iwan Kawrakow, 2004:                                                        "
"                                                                             "
" re-factored egs_init so that it is easy to program a corresponding egs_init "
" when one loads a EGSnrc user code as a library and therefore no command     "
" line arguments are available. (see beam library).                           "
"                                                                             "
"#############################################################################"


%I4
%C80
%Q1
!INDENT F2;
REPLACE {$max_unit} WITH {99}

REPLACE {$egs_debug(#,#);} WITH {;} " no need for debug info "

REPLACE {;COMIN/my_times/;} WITH {;
  common/my_times/ t_elapsed, t_cpu, t_first;
  $REAL            t_elapsed, t_cpu;
  integer          t_first(8);
  real             egs_tot_time,egs_etime;
};

"******************************************************************************
" subroutine egs_init;
"******************************************************************************
" A call to this subroutine becomes Step 0 in every EGSnrc user code.
" Its purpose is to:
"   - initialize arrays and default values for various transport options
"     (this was previously done in block data, but due to the GNU Fortran
"     compiler complaints and extremely slow compilation when the number of
"     regions is large, we decided to remove block data from the source)
"   - Process command line arguments specifying input file, pegs4 data file,etc.
"     In the current version the following command line options are supported:
"
"       -i or --input ifile          Input file is ifile.egsinp
"
"       -p or --pegs-file file_name  The pegs4 data file is file_name.pegs4dat
"                                    The system will look for it in the
"                                    HEN_HOUSE and the user's pegs4 data areas
"
"       -o or --output ofile         Output data will be writtent to
"                                    ofile.egslog, ofile.egslst, etc., instead
"                                    of ifile.egslog, etc.
"
"       -H or --hen-house dir        Change the HEN_HOUSE to be dir instead
"                                    of the directory specified in the
"                                    machine.macros file.
"
"       -e or --egs-home dir         Change EGS_HOME to be dir instead of
"                                    the directory specified by the EGS_HOME
"                                    environment variable
"
"       -h or --help                 Print a help message and exit
"                                    ignoring all other arguments
"
"       -b or --batch                Specify a 'batch' run. The difference
"                                    between a 'batch' run and an interactive
"                                    run is that in 'batch' mode unit 6 is
"                                    connected to a file, whereas in intarctive
"                                    mode unit 6 goes to the standard output.
"                                    The file name in batch run is determined
"                                    as follows:
"                                     - ofile.egslog, if ofile was specified
"                                       with the -o option
"                                     - ifile.egslog, if there was no -o option
"                                       used but an input file was specified
"                                       with -i
"                                     - test.egslog, if neither -i nor -o was
"                                       used.
"
"       -P or --parallel n           Tell the system that this run is part of
"                                    a parallel run and that this is job number
"                                    n (so that the random number sequence
"                                    can be initialized differently)
"
"       -c or --chunk N              Tell the system to use N histories per
"                                    calculation 'chunk' in parallel runs.
"
"   - open default EGSnrc data file units thus avoiding the necessity for
"     symbolik links
"   - open user code specific I/O units if a .io file is found in
"     the user code area. The format of this file is an integer
"     followed by a string on every line.
"     The string specifies the file extension
"     and the integer the unit number this file should connect to, e.g.
"       4   .egsdat
"       15  .egserr
"       1   .egslst
"     will result in connecting unit 4 to the file ifile.egsdat
"     (or ofile.egsdat, see above) to unit 4, [i|o]file.egserr to unit 15, etc.
"  -  Outputs a summary to standard output about configuration etc
"  -  Creates a temporary working directory in the user code area
"
"  The files always opened (appart from the ones specified in the .io file)
"  are the following:
"
"  1. The PEGS data file (and so, for now, the -p pegs_file command line
"     option must be always given)
"     The algorithm for looking for a PEGS data file is:
"       - The file name passed with -p. In this way, PEGS files can be located
"         everywhere on the file system (not just in $HEN_HOUSE/pegs4/data
"         and $EGS_HOME/pegs4/data) if the absolute path name is given after
"         the -p option.
"       - $EGS_HOME/pegs4/data/pegs_file or
"         $EGS_HOME/pegs4/data/pegs_file.pegs4dat
"       - $HEN_HOUSE/pegs4/data/pegs_file or
"         $HEN_HOUSE/pegs4/data/pegs_file.pegs4dat
"     See note below on how $HEN_HOUSE and $EGS_HOME are determined
"
"  2. If a -i ifile option was given as argument, ifile.egsinp is
"     opened as fortran unit 5.
"     The input file MUST be in the user code directory on $EGS_HOME
"
"  3. If the run is a batch run (the -b option was present on the command
"     line), fortran unit 6 is connected to an output file with a .egslog
"     extension instead of going to standard output.
"     The algorithm for determining the .egslog file name is the following:
"       - If the -o ofile option was present, the output to unit 6 will go
"         to ofile.egslog
"       - If there was no -o option, but there is an inpuit file specified
"         with -i ifile, output to unit 6 will go to ifile.egslog
"       - If neither of the above is true, the output will go to
"         test.egslog.
"
"  Note on determining EGS_HOME:
"  EGS_HOME is normally taken from the environment variable EGS_HOME.
"  However, one can overwrite the environment by giving the
"    -e | --egs-home  new_egs_home_location
"  option on the command line.
"  EGS_HOME must be set, either via the environment or via the command line,
"  otherwise the job will abort.
"
"  Note on determining HEN_HOUSE:
"  HEN_HOUSE is set to the value defined in machine.macros, which is
"  created by the configure script or the configuration wizard in the GUI
"  This value can be overwritten by giving the
"    -H | --hen-house new_hen_house_location
"  option on the command line.
"  HEN_HOUSE is NOT taken from the environment.
"
"  The name of the temporary working directory is created using
"    egsrun_getpid_ifile_hostname, if there was an input file, or
"    egsrun_getpid_noinput_hostname, if there was no input file specified.
"  In the above, getpid is the process id returned bt the getpid() intrinsic
"  and hostname is the host name as determined by egs_get_hostnm().
"  During run time, all output from the program (the .egslog file and
"  all other files specified in the .io file) is kept in the
"  temporary working directory. After succesful completion, egs_finish
"  moves all output back to the user code area and removes the
"  temporary working directory. This implies that if for whatever reason
"  the job terminates prematurely, the temporary working directory
"  with all output will be left behind.
"
"
"
"******************************************************************************
subroutine egs_init;
"******************************************************************************
implicit none;
;COMIN/my_times/;
$REAL dum;

/*
t_elapsed = 0; t_cpu = egs_etime(); dum = egs_tot_time(1);
call egs_date_and_time(t_first);
*/
call egs_set_defaults;
call egs_check_arguments;
call egs_init1;
return; end;

"******************************************************************************
subroutine egs_init1;
"******************************************************************************

implicit none;
;COMIN/EGS-IO,MISC,my_times/;
integer   l, lnblnk1, l1, l2;
integer   i;
character arg*256,tmp_string*512, tmp1_string*512, ucode_dir*512,
          line*80,
          line1*80,dattim*24;
$LOGICAL  have_input,egs_isdir,egs_strip_extension,ex,
          on_egs_home,is_opened;
$INTEGER  mypid;
integer   getpid;
integer   istat, egs_system, u, pos1, pos2,egs_get_unit,itmp;
$REAL     dum;
$declare_write_buffer;

t_elapsed = 0; t_cpu = egs_etime(); dum = egs_tot_time(1);
call egs_date_and_time(t_first);

$set_string(line,'=');
$set_string(line1,'.');

" Handy macros for checking command line arguments "
REPLACE {$check_get_argument(#,#,#);} WITH {
  have_arg = .false.;
  DO i=1,narg-1 [
      call getarg(i,{P3}); l = lnblnk1({P3});
      IF( ( l = lnblnk1({P1}) & {P3}(:l) = {P1} ) |
          ( l = lnblnk1({P2}) & {P3}(:l) = {P2} ) ) [
          have_arg = .true.; call getarg(i+1,{P3}); EXIT;
      ]
  ]
};

REPLACE {$check_argument(#,#,#);} WITH {
  have_arg = .false.;
  DO i=1,narg [
      call getarg(i,{P3}); l = lnblnk1({P3});
      IF( ( l = lnblnk1({P1}) & {P3}(:l) = {P1} ) |
          ( l = lnblnk1({P2}) & {P3}(:l) = {P2} ) ) [
          have_arg = .true.; EXIT;
      ]
  ]
};

IF(~is_pegsless)[
" Get the pegs4 data file "
on_egs_home = .false.;
inquire(file=pegs_file,exist=ex);
IF( ex ) [
    kmpi=egs_get_unit(kmpi);
    IF(kmpi<0)[
      $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
    ]
    open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
    $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
    goto :found_pegs_file:;
]
arg = $cstring(pegs_file);
ex = egs_strip_extension(arg,'.pegs4dat');
l = lnblnk1(egs_home); l1 = lnblnk1('pegs4data') + 2*lnblnk1($file_sep);
l2 = lnblnk1(arg) + lnblnk1('.pegs4dat');
IF( l + l1 + l2 > 256 ) [
    $egs_warning(*,'pegs4 data file name (including absolute path)');
    $warning('(a,i4,a)','is too long (',l+l1+l2,') characters');
]
ELSE [
    pegs_file = $cstring(egs_home) // 'pegs4' // $file_sep // 'data' //
      $file_sep // $cstring(arg) // '.pegs4dat';
    $egs_debug('(a,a)','checking for pegs file ',$cstring(pegs_file));
    inquire(file=pegs_file,exist=ex);
    IF( ex ) [
        kmpi=egs_get_unit(kmpi);
        IF(kmpi<0)[
          $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
        ]
        open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
        $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
        on_egs_home = .true.;
        goto :found_pegs_file:;
    ]
]
l = lnblnk1(hen_house);
IF( l + l1 + l2 > 256 ) [
    $egs_warning(*,'pegs4 data file name (including absolute path)');
    $warning('(a,i4,a)','is too long (',l+l1+l2,') characters');
]
ELSE [
    pegs_file = $cstring(hen_house) // 'pegs4' // $file_sep // 'data' //
       $file_sep // $cstring(arg) // '.pegs4dat';
    $egs_debug('(a,a)','checking for pegs file ',$cstring(pegs_file));
    inquire(file=pegs_file,exist=ex);
    IF( ex ) [
        kmpi=egs_get_unit(kmpi);
        IF(kmpi<0)[
          $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
        ]
        open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
        $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
        goto :found_pegs_file:;
    ]
]

$egs_fatal(*,'could not find pegs4 file named ',$cstring(arg));

]

:found_pegs_file:
;
" Open egsnrc data files "
$set_string(tmp_string,' ');
tmp_string = $cstring(hen_house) // 'data' // $file_sep;

"set proposed unit numbers"
i_nist_data=76;
i_incoh=78;
i_photo_relax=77;
i_photo_cs=79;
i_mscat=11;

REPLACE {$open_data_file(#,#,#,#);} WITH {;
    $set_string({P2},' ');
    {P2} = $cstring({P1}) // {P3};
    inquire(file={P2},exist=ex,opened=is_opened,number=itmp);
    IF( ~ex ) [
        $egs_fatal(*,'EGSnrc data file ',{P3},' does not exist');
    ]
    IF( ~is_opened ) [
        {P4}=egs_get_unit({P4});
        IF({P4}<0)[
          $egs_fatal(*,'failed to get a free Fortran I/O unit for data file ',
                       $cstring({P2}));
        ]
        open({P4},file={P2},status='old',err=:data_file_error:);
    ]
    ELSE [ {P4} = itmp; ]
    $egs_debug('(a,a)','opened data file ',$cstring({P2}));
};
$open_data_file(tmp_string,tmp1_string,'photo_cs.data',$PHOCSUNIT);
$open_data_file(tmp_string,tmp1_string,'msnew.data',$MSCAT-DATAFILE);
$open_data_file(tmp_string,tmp1_string,'incoh.data',$INCOHUNIT);
$open_data_file(tmp_string,tmp1_string,'photo_relax.data',$PHOTOUNIT);

$set_string(ucode_dir,' ');
ucode_dir = $cstring(egs_home) // $cstring(user_code) // $file_sep;

have_input = .false.;
i_input=5;
IF( lnblnk1(input_file) > 0 ) [
    have_input = .true.;
    l = lnblnk1(egs_home); l1 = lnblnk1(user_code)+1;
    l2 = lnblnk1(input_file) + lnblnk1('.egsinp');
    IF( l + l1 + l2 > 1024 ) [
        $egs_fatal(*,'input file name (including path) is too long ',l+l1+l2);
    ]
    ex = egs_strip_extension(input_file,'.egsinp');
    tmp_string = $cstring(ucode_dir) // $cstring(input_file) // '.egsinp';
    inquire(file=tmp_string,exist=ex);
    IF( ~ex ) [
        $egs_fatal(*,'Input file ',$cstring(tmp_string),' does not exist.');
    ]
    $AVAILABLE_UNIT(i_input,tmp_string);
    open(i_input,file=tmp_string,status='old',err=:open_input_error:);
]

" Construct a temporary directory name to run from "
$set_string(work_dir,' ');
work_dir = 'egsrun_'; mypid = getpid();
call egs_itostring(work_dir,mypid,.false.);
call egs_get_hostnm(host_name);
IF( lnblnk1(host_name) < 1 ) host_name = 'unknown';
IF( have_input ) [
    work_dir = $cstring(work_dir) // '_' // $cstring(input_file) //
               '_' // $cstring(host_name) // $file_sep;
]
ELSE [
    work_dir = $cstring(work_dir) // '_noinput_' // $cstring(host_name) //
               $file_sep;
]
$set_string(tmp_string,' ');
tmp_string = $cstring(ucode_dir) // $cstring(work_dir);
DO i=1,lnblnk1(tmp_string) [
    IF( tmp_string(i:i) = '/' ) [
        tmp_string(i:i) = $file_sep;
    ]
]
ex = egs_isdir(tmp_string);
IF( ex ) [
 $egs_fatal(*,'a directory named ',$cstring(tmp_string),' already exists?');
]
tmp1_string = 'mkdir ' // $cstring(tmp_string);
l = lnblnk1(tmp1_string); tmp1_string(l+1:l+1) = char(0);
                 " some systems need the command string to be 0 terminated"
istat = egs_system(tmp1_string);
IF( istat ~= 0 ) [
    $egs_fatal(*,'failed to create working directory ',$cstring(tmp1_string));
]

call egs_open_units(.true.);

" Now print a summary of what happened "
$egs_info('(a)',line);
$egs_info('(a,a,t55,a,$)','EGSnrc version 4 for ',$CANONICAL_SYSTEM,' ');
call egs_get_fdate(dattim);
$egs_info('(a,/,a)',dattim,line);

REPLACE {$write_description(#);} WITH {;
  $egs_info('(a,$)',{P1}); l = pos2 - lnblnk1({P1});
  $egs_info('(a,$)',line1(:l));
};
pos1 = lnblnk1('output file(s)');
pos2 = 80 - lnblnk1($CONFIGURATION_NAME);
pos2 = min(pos2,80-lnblnk1(user_code));
$set_string(tmp_string,' '); tmp_string = pegs_file;
call egs_strip_path(tmp_string);
ex = egs_strip_extension(tmp_string,'.pegs4dat');
IF( on_egs_home ) [ tmp_string = $cstring(tmp_string) // ' on EGS_HOME'; ]
ELSE [ tmp_string = $cstring(tmp_string) // ' on HEN_HOUSE'; ]
IF( lnblnk1(tmp_string) > lnblnk1(pegs_file) ) [
    $set_string(tmp_string,' '); tmp_string = pegs_file;
]
pos2 = min(pos2,80-lnblnk1(tmp_string));
pos2 = min(pos2,80-lnblnk1(host_name));
IF( have_input ) pos2 = min(pos2,80-lnblnk1(input_file));
pos2 = min(pos2,80-lnblnk1(output_file));
IF( pos2 < pos1+2 ) pos2 = pos1 + 2;

$write_description('configuration'); $egs_info('(a)',$CONFIGURATION_NAME);
$write_description('user code'); $egs_info('(a)',$cstring(user_code));
$write_description('pegs file'); $egs_info('(a)',$cstring(tmp_string));
$write_description('using host'); $egs_info('(a)',$cstring(host_name));
IF( have_input ) [
    $write_description('input file'); $egs_info('(a)',$cstring(input_file));
]
$write_description('output file(s)'); $egs_info('(a)',$cstring(output_file));
IF( n_parallel > 0 ) [
    $write_description('number of parallel jobs');
    $egs_info('(i2)',n_parallel);
    $write_description('job number'); $egs_info('(i2)',i_parallel);
]
$egs_info('(a)',line);

return;

" Errors "
:open_input_error:
$egs_fatal(*,'failed to open input file ',$cstring(tmp_string));

:open_pegs_error:
$egs_fatal(*,'failed to open existing pegs file ',$cstring(pegs_file));

:data_file_error:
$egs_fatal(*,'failed to open EGSnrc data file ',$cstring(tmp1_string));

return; end;

"*****************************************************************************
subroutine egs_check_arguments;
"*****************************************************************************
implicit none;

;COMIN/EGS-IO/;

character arg*256,tmp_string*512, line1*80;
$LOGICAL  have_arg,egs_isdir,egs_strip_extension,ex,
          on_egs_home;
integer   narg, iargc, i, lnblnk1, l, l2,i_help,egs_get_unit;
$declare_write_buffer;

narg = iargc();
IF( narg < 1 ) return;

" Check for hen_house "
$check_get_argument('-H','--hen-house',arg);
IF( have_arg ) [
    l = lnblnk1(arg); $set_string(hen_house,' ');
    IF( l > 0 ) [
        IF( l > 254 ) [
            $egs_fatal('(a,i5)',' HEN_HOUSE argument is too long',l);
        ]
        hen_house(:l) = $cstring(arg);
        IF( hen_house(l:l) ~= $file_sep ) hen_house(l+1:l+1) = $file_sep;
    ]
    ELSE [
        $egs_fatal('(a)',' empty argument after -H');
    ]
    DO i=1,lnblnk1(hen_house) [
        IF( hen_house(i:i) = '/' ) [
            hen_house(i:i) = $file_sep;
        ]
    ]
]
IF( ~egs_isdir(hen_house) ) [
    $egs_warning('(a,a)',' HEN_HOUSE directory ',$cstring(hen_house));
    $warning('(a)','does not exist. Hope you know what you are doing.');
]

" Check if the user requested help "
$check_argument('-h','--help',arg);
IF( have_arg ) [
  call getarg(0,arg); call egs_strip_path(arg);
  $egs_info('(//,a,a,a,//)','Usage: ',$cstring(arg),' [args] ');
  tmp_string = $cstring(hen_house) // 'pieces/help_message';
  i_help=98;
  i_help=egs_get_unit(i_help);
  IF(i_help<0)[
     $egs_fatal(*,'failed to get a free Fortran I/O unit for help file');
  ]
  open(i_help,file=tmp_string,status='old',err=:no_help_file:);
  LOOP [
      read(i_help,'(a)',err=:end_of_help:,end=:end_of_help:) line1;
      $egs_info('(a)',line1);
  ]
  :end_of_help:;
  $CALL_EXIT(0);
  :no_help_file:;
  $egs_fatal(*,'Did not find the help_message file!');
]

" Check for batch option "
$check_argument('-b','--batch',arg);
IF( have_arg ) is_batch = .true.;

" Check for parallel run option"
$check_get_argument('-P','--parallel',arg);
IF( have_arg ) [
    read(arg,*,err=:wrong_parallel_arg:) n_parallel;
    IF( n_parallel < 0 ) goto :wrong_parallel_arg:;
    goto :ok_parallel_arg:;
    :wrong_parallel_arg:;
    $egs_warning(*,
     ' Wrong/missing parallel job number argument, -P option ignored');
    n_parallel = 0;
    :ok_parallel_arg:;
]

$check_get_argument('-j','--job',arg);
IF( have_arg ) [
    read(arg,*,err=:wrong_job_arg:) i_parallel;
    IF( i_parallel < 0 ) goto :wrong_job_arg:;
    goto :ok_job_arg:;
    :wrong_job_arg:;
    $egs_warning(*,' Wrong/missing job argument, -j option ognored');
    i_parallel = 0;
    :ok_job_arg:;
]

$check_get_argument('-f','--first-job',arg);
IF( have_arg ) [
    read(arg,*,err=:wrong_first_job_arg:) first_parallel;
    IF( first_parallel < 1 ) goto :wrong_first_job_arg:;
    goto :ok_first_job_arg:;
    :wrong_first_job_arg:;
    $egs_warning(*,' Wrong/missing first job argument, -f option ognored');
    first_parallel = 1;
    :ok_first_job_arg:;
]

IF( n_parallel > 0 | i_parallel > 0 ) [
    IF( n_parallel*i_parallel = 0 ) [
        $egs_warning(*,'You need to specify number of jobs AND job number ',
          '=> will not use parallel run ');
        n_parallel = 0; i_parallel = 0;
    ]
    IF( first_parallel > i_parallel ) [
        $egs_warning(*,'i_parallel (',i_parallel,
          ') can not be smaller than first_parallel (',first_parallel,')');
        first_parallel = i_parallel;
    ]
]

$egs_debug('(a,a)','HEN_HOUSE is ',$cstring(hen_house));

" Check for egs_home "
$check_get_argument('-e','--egs-home',arg);
IF( have_arg ) [
    l = lnblnk1(arg); $set_string(egs_home,' ');
    IF( l = 0 ) [
        $egs_fatal('(a)',' empty argument after -e');
    ]
    IF( l > 254 ) [
        $egs_fatal('(a,i5)',' EGS_HOME argument is too long ',l);
    ]
    egs_home(:l) = $cstring(arg);
    IF( egs_home(l:l) ~= $file_sep ) egs_home(l+1:l+1) = $file_sep;
    DO i=1,lnblnk1(egs_home) [
        IF( egs_home(i:i) = '/' ) [
            egs_home(i:i) = $file_sep;
        ]
    ]
]
IF( ~egs_isdir(egs_home) ) [
  $egs_fatal(*,' EGS_HOME directory ',$cstring(egs_home),' does not exist.');
]
$egs_debug('(a,a)','EGS_HOME is ',$cstring(egs_home));

" Get the pegs4 data file "
on_egs_home = .false.;
is_pegsless=.false.;
$check_get_argument('-p','--pegs-file',arg);
IF( ~have_arg ) [
    $egs_warning(*,'No pegs4 file name supplied.  Will assume you are running
 in pegs-less mode with media details specified in input file.');
    is_pegsless=.true.;
]
ELSE[
    pegs_file = $cstring(arg);
]

" Deduct the user code name from the executable name "
call egs_get_usercode(user_code);

" Check for an input file "
$check_get_argument('-i','--input',arg);
IF( have_arg ) [
    ex = egs_strip_extension(arg,'.egsinp');
    l2 = lnblnk1(arg) + lnblnk1('.egsinp');
    IF( l2 > 256 ) [
        $egs_fatal(*,'input file name is too long ',l2);
    ]
    input_file = $cstring(arg);
]

" Check for an output file option "
$check_get_argument('-o','--output',arg);
IF( have_arg ) [
    l = lnblnk1(arg);
    IF( l > 256 ) [
        $egs_fatal(*,'output file name is too long ',l);
    ]
    output_file(:l) = $cstring(arg);
]
ELSE [
    IF( lnblnk1(input_file) > 0 ) [
        output_file(:lnblnk1(input_file)) = $cstring(input_file);
    ]
    ELSE [
        output_file = 'test';
    ]
]

return; end;

"******************************************************************************
subroutine egs_open_units(flag);
"******************************************************************************
" Open output files.
" Looks for output file definition in user_code.io.
" In addition, if it is a batch run connects a .egslog file to unit 6.
" If flag is .true., open the files in the temporary working directory,
" else open them in the user code directory.
"******************************************************************************
implicit none;
$LOGICAL flag;

;COMIN/EGS-IO/;

character tmp_string*1024, tmp1_string*1024, tmp2_string*1024, ucode_dir*1024,
          input_line*100, arg*20;
integer   i,lnblnk1,u,l,istart,egs_get_unit,i_iofile;
$LOGICAL  ex,is_open;
$declare_write_buffer;

$set_string(tmp_string,' '); $set_string(ucode_dir,' ');
ucode_dir = $cstring(egs_home) // $cstring(user_code) // $file_sep;
IF( flag ) [
    tmp_string = $cstring(ucode_dir) // $cstring(work_dir);
]
ELSE [
    tmp_string = $cstring(ucode_dir);
]

tmp_string = $cstring(tmp_string) // $cstring(output_file);
IF( i_parallel > 0 ) [
    tmp_string = $cstring(tmp_string) // '_w';
    call egs_itostring(tmp_string,i_parallel,.false.);
]
$set_string(tmp1_string,' ');
i_log=6;
IF( is_batch ) [
    tmp1_string = $cstring(tmp_string) // '.egslog';
    $AVAILABLE_UNIT(i_log,tmp1_string);
    open(i_log,file=tmp1_string,status='unknown',err=:output_file_error:);
]
$set_string(tmp2_string,' ');
tmp2_string = $cstring(ucode_dir) // $cstring(user_code) // '.io';
inquire(file=tmp2_string,exist=ex);
n_files = 0;
IF( ex ) [
    i_iofile=99;
    i_iofile=egs_get_unit(i_iofile);
    IF (i_iofile<1)[
      $egs_fatal(*,'failed to get a free Fortran I/O unit for .io file');
    ]
    open(i_iofile,file=tmp2_string,status='old',err=:io_file_error:);
    LOOP [
        read(i_iofile,'(a)',err=:end_of_iofile:,end=:end_of_iofile:) input_line;
        IF( input_line(1:1) = '#' ) NEXT;
        "The DEC and SGI compilers fail at the following statement!"
        "read(input_line,*,err=:end_of_iofile:,end=:end_of_iofile:) u,arg;"
        read(input_line,*,err=:end_of_ioline:,end=:end_of_ioline:) u;
        istart = 1;
        DO i=lnblnk1(input_line),1,-1 [
            IF( input_line(i:i) = ' ' ) [ istart = i+1; EXIT; ]
        ]
        DO i=1,len(arg) [ arg(i:i) = ' '; ]
        DO i=istart,lnblnk1(input_line) [
            arg(i+1-istart:i+1-istart) = input_line(i:i);
        ]
        inquire(unit=u,opened=is_open);
        IF( is_open ) [
            $egs_warning('(a,i3,a,a,a,/,a,/,a,/)',
              'Unit ',u,' which you want to connect to a ',
              $cstring(arg),' file ',
           'is already in use. Will assume this code is being used as',
           'a shared library source and this file will be opened explicitly.');
        ]
        ELSE[
            n_files = n_files + 1;
            IF( n_files > $mx_units ) [
               $egs_fatal(*,'Too many units requested in .io.',
                ' Increas $mx_units and retry');
            ]
            file_units(n_files) = u;
            $set_string(file_extensions(n_files),' ');
            l = lnblnk1(arg);
            IF( l > $max_extension_length ) [
                $egs_fatal(*,'extension ',$cstring(arg),' is longer than ',
                  $max_extension_length,' chars. ',
                  'Increase $max_extension_length and retry ');
            ]
            file_extensions(n_files) = $cstring(arg);
            tmp1_string = $cstring(tmp_string) // $cstring(arg);
            open(u,file=tmp1_string,status='unknown');
            $egs_debug('(a,a,a,i3)','connected ',$cstring(tmp1_string),
              ' to unit ',u);
        ]
        :end_of_ioline:
    ]
    :end_of_iofile:
    close(i_iofile);
]
return;

:output_file_error:
$egs_fatal(*,'failed to open output file ',$cstring(tmp1_string));

:io_file_error:
$egs_fatal(*,'failed to open existing .io file',$cstring(tmp2_string));
return; end;


"******************************************************************************
subroutine egs_finish;
"******************************************************************************
" This subroutine becomes the last step in every EGSnrc user code.
" It's purpose is to move the all output files from the temporary working
" directory to the user code directory and to remove the working dir.
" This was previously done by the egs_run script.
" This routine also prints a summary to standard output.
"******************************************************************************
implicit none;
;COMIN/EGS-IO,my_times/;
character line*80,base*512,base1*512,tmp_string*512,junk_file*128,fname*512;
character dattim*24;
integer  i,l,lnblnk1,istat,egs_system,n_open,unlink,i_junk,egs_get_unit;
$LOGICAL is_open,egs_isdir;
$REAL    t1,t2,tt_cpu;
$declare_write_buffer;

$set_string(line,'=');
IF( n_parallel = 0 | i_parallel > 0 ) [
 "i.e. we want that info if this is not a parallel run (n_parallel = 0)"
 "or if it is parallel but it is not the final egs_finish (after combining"
 "results from parallel runs)"
t_elapsed = egs_tot_time(1); tt_cpu = egs_etime() - t_cpu;
t1 = t_elapsed; t2 = t1/3600;
$egs_info('(//a,/,a,/)',line,'Finished simulation');
$egs_info('(2x,a,t30,f9.1,a,f7.3,a)','Elapsed time: ',t1,' s (',t2,' h)');
t1 = tt_cpu; t2 = t1/3600;
$egs_info('(2x,a,t30,f9.1,a,f7.3,a)','CPU time:',t1,' s (',t2,' h)');
$egs_info('(2x,a,t30,f10.3)','Ratio:',t_elapsed/tt_cpu);
]
call egs_get_fdate(dattim);
$egs_info('(//a,t56,a,/,a)','End of run ',dattim,line);

" Close all I/O units "
n_open=0;
$set_string(base,' ');
base = $cstring(egs_home) // $cstring(user_code);
DO i=1,$max_unit [
    IF( is_batch | i ~= i_log ) [
      inquire(i,opened=is_open);
      IF( is_open ) [
         inquire(i,name=fname);
         IF(index($cstring(fname),$cstring(base))>0)[
              close(i); n_open = n_open+1; ]
      ]
    ]
]

"If work_dir is empty, this is a second call to egs_finish for the last"
"job in a parallel run. This implies that the temporary working "
"directory has been already removed => just return"

IF( lnblnk1(work_dir) = 0 ) [ return; ]

" Now generate a junk file in the working directory so that the move "
" command does not fail in case there are no files "
$set_string(base,' ');
base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
        $cstring(work_dir);
DO i=1,lnblnk1(base) [
    IF( base(i:i) = '/' ) [
        base(i:i) = $file_sep;
    ]
]
IF( egs_isdir(base) ) [
    $set_string(tmp_string,' '); $set_string(junk_file,' ');
    junk_file = $cstring(work_dir);
    l = lnblnk1(junk_file); junk_file(l:l) = ' ';
    junk_file = $cstring(junk_file) // '_junk';
    tmp_string = $cstring(base) // $cstring(junk_file);
    i_junk=99;
    i_junk=egs_get_unit(i_junk);
    IF(i_junk<0)[
      $egs_fatal(*,'failed to get a free Fortran I/O unit for junk file');
    ]
    open(i_junk,file=tmp_string,status='unknown');
    write(i_junk,*) 'junk';
    close(i_junk);

    " Move all files from the working directory to the user code directory "
    $set_string(base1,' ');
    base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
            $cstring(work_dir);
    base1 = $cstring(egs_home) // $cstring(user_code);
    $set_string(tmp_string,' ');
    tmp_string = $move_file // $cstring(base) // '*  ' // $cstring(base1);
    l = lnblnk1(tmp_string)+1;
    tmp_string(l:l) = char(0);
    istat = egs_system(tmp_string);
    IF( istat ~= 0 ) [
        $egs_warning(*,'Moving files from working directory failed ?');
        $warning(*,'=> will not remove working directory');
    ]
    ELSE [
        " Remove the working directory "
        $set_string(tmp_string,' ');
        tmp_string = $remove_directory // $cstring(base);
        l = lnblnk1(tmp_string)+1; tmp_string(l:l) = char(0);
        istat = egs_system(tmp_string);
        IF( istat ~= 0 ) [
            $egs_warning(*,'Failed to remove working directory ',
              $cstring(work_dir));
        ]
        " Remove the junk file "
        $set_string(tmp_string,' ');
        tmp_string = $cstring(base1) // $file_sep // $cstring(junk_file);
        l = lnblnk1(tmp_string)+1; tmp_string(l:l) = char(0);
        istat = unlink(tmp_string);
    ]
]

" Now set work_dir to blank so that all I/O stuff after egs_finish ends up"
" in the user code directory "
$set_string(work_dir,' ');

return; end;

"******************************************************************************
subroutine egs_set_defaults;
"******************************************************************************
" Replaces BLOCK DATA "
implicit none;
$COMIN-SET-DEFAULTS;

integer  i,j,lnblnk1;
$TYPE MEDIA1(24); EQUIVALENCE(MEDIA1(1),MEDIA(1,1));
character fool_dec;
data MEDIA1/$S'NAI                     '/;
data fool_dec/'/'/;
data fool_intel_optimizer/.false./;

vacdst = 1e8;
$set-region-by-region-defaults;

eii_flag = 0; "No EII by default. "
eii_xfile = 'Off';
eii_L_factor = 1.0; "No L-shell EII xsection scaling by default"
"========================================="
"See egsnrc.macros for defaults used below"
"========================================="
xsec_out = $XSEC-DEFAULT;
photon_xsections = $XDATA-DEFAULT;"default photon xsection"
comp_xsections = $COMP-XDATA-DEFAULT;
eadl_relax = $EADL-RELAX-DEFAULT;
mcdf_pe_xsections = $MCDF-PE-DEFAULT;
"Ali:photonuc, 2 lines"
photonuc_xsections = $PHOTONUC-XDATA-DEFAULT;
"EMH:emf"
ExIN=$ExDEF;EyIN=$EyDEF;EzIN=$EzDEF;
" Initially set to input values, could change with regions"
" by converting it to an array over all regions. This is  "
" currently implemented ONLY for the C++ applications     "
BxIN=$BxDEF;ByIN=$ByDEF;BzIN=$BzDEF; EMLMTIN=$EMLMTDEF;
Bx=BxIN;    By=ByIN;    Bz=BzIN;
Bx_new=Bx;  By_new=By;  Bz_new=Bz;
emfield_on=.false.;
IF( ExIN**2+EyIN**2+EzIN**2 + BxIN**2+ByIN**2+BzIN**2 > 0 ) [
    emfield_on=.true.
]

DO i=1,$MXMED [
    iraylm(i) = 0; "Rayleigh data available?"
    DO j=1,len(iray_ff_file(i)) [ iray_ff_file(i)(j:j) = ' ';]
    DO j=1,len(iray_ff_media(i)) [ iray_ff_media(i)(j:j) = ' ';]
      " set all thresholds to zero "
    /ae(i),ap(i),ue(i),up(i),te(i),thmoll(i)/=0;
]
DO i=1,$MXSHXSEC [
  DO j=1,$MXELEMENT [ binding_energies(i,j) = 0; ]
]
ibrdst = $IBRDST-DEFAULT;      " brems angular sampling"
ibr_nist = $IBR-NIST-DEFAULT;  " flag for brems from NIST data base "
pair_nrc = $PAIR-NRC-DEFAULT;  " flag for pair from the NRC data base "
itriplet = $TRIPLET-DEFAULT;   " flag for triplet production "
iprdst = $IPRDST-DEFAULT;      " pair angular sampling "
rhof = 1;
DO i=1,5 [ iausfl(i) = 1; ]
"Ali:photonuc, line below already includes iarg=29,30"
DO i=6,$MXAUS [ iausfl(i) = 0; ]
ximax = $EXACT-BCA-XIMAX; estepe = $MAX-ELOSS;
skindepth_for_bca = $SKIN-DEPTH-FOR-BCA;
transport_algorithm = $TRANSPORT-ALGORITHM-DEFAULT;
bca_algorithm = $BCA-ALGORITHM-DEFAULT;
exact_bca = $EXACT-BCA-DEFAULT;
spin_effects = $SPIN-EFFECTS-DEFAULT;
count_pII_steps = 0; count_all_steps = 0;
radc_flag = 0;
nmed = $default_nmed;
kmpi = 12; kmpo = 8; dunit = 1;
rng_seed = 999999;
latchi = 0;

rmt2 = 2*rm; rmsq = rm*rm;

pi = 4*datan(1d0); twopi = 2*pi; pi5d2 = 2.5*pi;
nbr_split = 1;
i_play_RR = 0; i_survived_RR = 0; prob_RR = -1; n_RR_warning = 0;

$set_string(hen_house,' ');
i = lnblnk1($HEN_HOUSE);
hen_house(:i) = $HEN_HOUSE;
IF( $file_sep ~= fool_dec ) [
    DO j=1,i [
        IF( hen_house(j:j) = '/' ) hen_house(j:j) = $file_sep;
    ]
]
IF( hen_house(i:i) ~= $file_sep ) hen_house(i+1:i+1) = $file_sep;

n_files = 0;
$set_egs_home;
i = lnblnk1(egs_home);
IF( $file_sep ~= fool_dec ) [
    DO j=1,i [
        IF( egs_home(j:j) = '/' ) egs_home(j:j) = $file_sep;
    ]
]
IF( i > 0 & egs_home(i:i) ~= $file_sep ) egs_home(i+1:i+1) = $file_sep;
$set_string(input_file,' ');
$set_string(output_file,' ');
$set_string(work_dir,' ');
$set_string(pegs_file,' ');
$set_string(host_name,' ');
n_parallel = 0; i_parallel = 0; n_chunk = 0; is_batch = .false.;
first_parallel = 1;
return; end;

"*****************************************************************************
subroutine egs_combine_runs(combine_routine,extension);
"*****************************************************************************
" This subroutine loops over job number i from 1 to $max_unit,
" checks if the file output_file_wi.extension exists, and if yes,
" calls the external subroutine combine_routine with that file name.
"*****************************************************************************
implicit none;
external combine_routine;
character*(*) extension;
;COMIN/EGS-IO/;
character*1024 tmp_string,base,command,outfile,parfile_name,base1,
           text_string;
integer  lnblnk1,istat,ipar,egs_system,egs_open_file;
$INTEGER i,k,j,numparfiles,textindex;
$LOGICAL ex,iwin;

iwin=.false.; "start off assuming a non-Windows system"

$set_string(base,' ');
base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
       $cstring(output_file) // '_w';

"the following is to count the number of output files from"
"a parallel run"
$set_string(base1,' ');
base1 = $cstring(egs_home) // $cstring(user_code) // $file_sep //
       $cstring(output_file) // '_w*' // $cstring(extension);
$set_string(outfile,' ');
outfile = $cstring(egs_home) // $cstring(user_code) // $file_sep //
       'parfiles_tmp';
"try Unix/Linux first"
$set_string(command,' ');
command = 'ls ' // $cstring(base1) // ' | wc -l > ' // $cstring(outfile);
istat = egs_system($cstring(command));
IF(istat~=0)["now assume a Windows system"
   command = 'dir ' // $cstring(base1) // ' | find "File(s)" > ' //
   $cstring(outfile);
   istat = egs_system($cstring(command));
   IF(istat~=0)[
$egs_fatal(*,' Failed to write number of output files from parallel runs.');
   ]
   ELSE [
     iwin=.true.;
   ]
]

"now open parfiles_tmp and read the number of files"
ipar=1;
ipar=egs_open_file(ipar,0,1,$cstring(outfile));
IF(iwin)[
"need to do a bit of manipulation of a text string to get the number of files
  read(ipar,'(a)',err=:end_of_parfile:,end=:end_of_parfile:) text_string;
  text_string = $cstring(text_string);
  textindex = index(text_string,'File(s)');
  text_string = text_string(:textindex-1);
  read(text_string,'(i256)',err=:end_of_parfile:) numparfiles;
]
ELSE[
  read(ipar,'(i256)',err=:end_of_parfile:,end=:end_of_parfile:) numparfiles;
]
close(ipar);

"now remove parfiles_tmp"
$set_string(command,' ');

IF(iwin)[
   command = 'del /Q ' // $cstring(outfile);
]
ELSE[
   command = 'rm -f ' // $cstring(outfile);
]
istat = egs_system($cstring(command));
IF(istat~=0)[
   $egs_warning(*,' Failed to delete list of output files from parallel runs.');
]

k=1;
j=1;
WHILE(j<=numparfiles) [
     $set_string(tmp_string,' ');
     tmp_string = $cstring(base);
     call egs_itostring(tmp_string,k,.false.);
     tmp_string = $cstring(tmp_string) // $cstring(extension);
     inquire(file=tmp_string,exist=ex);
     IF( ex ) [
        call combine_routine(tmp_string);
        j=j+1;
     ]
     k=k+1;
]
return;

:end_of_parfile:
$egs_fatal(*,' Failed to read number of output files from parallel runs.');
end;

"******************************************************************************
$LOGICAL function egs_strip_extension(filen,fext);
"******************************************************************************
" Check if the string pointed to by filen ends with the string pointed to by
" fext and if yes, replace with blanks and return .true., otherwise return
" false.
"******************************************************************************
implicit none;
character*(*) filen,fext;
integer  l1,l2,lnblnk1,i;

l1 = lnblnk1(filen); l2 = lnblnk1(fext);
IF( l1 >= l2 & filen(l1-l2+1:l1) = fext(:l2) ) [
    egs_strip_extension = .true.;
    DO i=l1-l2+1,len(filen) [ filen(i:i) = ' '; ]
]
ELSE [ egs_strip_extension = .false.; ]
return; end;

"******************************************************************************
$LOGICAL function egs_is_absolute_path(fn);
"******************************************************************************
" Returns .true., if the string pointed to by fn is an absolute file name,
" .fale. otherwise.
"******************************************************************************
implicit none;
character*(*) fn;
integer  i,lnblnk1;
DO i=1,lnblnk1(fn) [
    IF( fn(i:i) = $file_sep ) [ egs_is_absolute_path = .true.; return; ]
]
egs_is_absolute_path = .false.; return; end;

"******************************************************************************
integer  function egs_get_unit(iunit);
"******************************************************************************
" Returns iunit, if the Fortran I/O unit iunit is not currently in use.
" Otherwise return the first free I/O unit found or -1 if none is available.
"******************************************************************************
implicit none;
$INTEGER iunit, i;
$LOGICAL is_open;

IF( iunit > 0 ) [
    inquire(iunit,opened=is_open);
    IF( ~is_open ) [ egs_get_unit = iunit; return; ]
]
DO i=1,$max_unit [
    inquire(i,opened=is_open);
    IF( ~is_open ) [ egs_get_unit = i; return; ]
]
egs_get_unit = -1; return; end;

"******************************************************************************
integer function egs_open_file(iunit,rl,action,extension);
"******************************************************************************
" Open a file trying to connect to Fortran I/O unit iunit.
" If iunit is already in use, connect to the first free I/O unit found.
" If no free I/O unit is found, then
"   - if action = 0, return -1.
"   - if action ~= 0, call the $egs_fatal macro.
" If extension is an absolute file name (including path), use extension
" as a file name, otherwise use output_file.extension in the temporary
" working directory as name. In both cases use status='unknown' to open the
" file. If rl = 0, open the file for formatted sequential access, otherwise
" open for unformatted direct access with record length = rl.
"******************************************************************************
implicit none;
$INTEGER iunit, rl, action;
character*(*) extension;
;COMIN/EGS-IO/;
$LOGICAL egs_is_absolute_path,is_open;
integer  egs_get_unit;
integer  i,lnblnk1;
character*1024 tmp_string,error_string;
$INTEGER the_unit;
$declare_write_buffer;

egs_open_file = -1; "so that the DEC compiler does not complain that"
                    "the function has an undefined values in some of"
                    "the excution paths (where exit(1) is called."
the_unit = egs_get_unit(iunit);
IF( the_unit < 0 ) [
    IF( action = 0 ) [ egs_open_file = -1; return; ]
    $egs_fatal(*,'No free Fortran I/O units left');
]

IF( egs_is_absolute_path(extension) ) [
    inquire(file=extension,opened=is_open);
    IF(is_open)[
        inquire(file=extension,number=the_unit);
        $egs_warning('(a,a,/,a,i3,/,a,/,a)',
             'File ',$cstring(extension),
             ' is already opened and connected to unit ',the_unit,
             ' Will not try to re-open this file, assuming it has been opened',
             ' by the .io file.');
    ]
    ELSE IF( rl = 0 ) [
        open(the_unit,file=extension,status='unknown');
    ]
    ELSE [
        open(the_unit,file=extension,status='unknown',form='unformatted',
             access='direct', recl=rl);
    ]
    egs_open_file = the_unit; return;
]

$set_string(tmp_string,' ');
tmp_string = $cstring(egs_home) // $cstring(user_code) // $file_sep //
             $cstring(work_dir) // $cstring(output_file);
IF( i_parallel > 0 ) [
    tmp_string = $cstring(tmp_string) // '_w';
    call egs_itostring(tmp_string,i_parallel,.false.);
]
tmp_string = $cstring(tmp_string) // $cstring(extension);

inquire(file=tmp_string,opened=is_open);
IF(is_open)[
    inquire(file=tmp_string,number=the_unit);
    $egs_warning('(a,a,/,a,i3,/,a,/,a,/)',
             'File ',$cstring(tmp_string),
             ' is already opened and connected to unit ',the_unit,
             ' Will not try to re-open this file, assuming it has been opened',
             ' by specifying it in the .io file.');
]
ELSE IF( rl = 0 ) [
    open(the_unit,file=tmp_string,status='unknown',err=:open_error:);
]
ELSE [
    open(the_unit,file=tmp_string,status='unknown',form='unformatted',
         access='direct', recl=rl,err=:open_error:);
]
egs_open_file = the_unit; return;

:open_error:
error_string = 'In egs_open_file: failed to open file ' // $cstring(tmp_string)
      // char(10) // 'iunit = ';
call egs_itostring(error_string,iunit,.false.);
error_string = $cstring(error_string) // ' the_unit = ';
call egs_itostring(error_string,the_unit,.false.);
$egs_fatal('(a)',$cstring(error_string));
end;


"******************************************************************************
integer  function egs_open_datfile(iunit,rl,action,extension);
"******************************************************************************
"
" Open an existing 'data' file.
" First try to connect the file to Fortran unit iunit, but if iunit is
" already in use, use the first free unit instead.
" extension is the datafile extension (e.g. '.egsdat') .
" The algorithm for searching for the file is as follows:
"  1. If extension is an absolute file name (including path),
"     try opening this file, else
"  2. Try output_file.extension in the user code directory.
"  3. Try input_file.extension in the user code directory (if input_file is
"     different from output_file).
" If the file is found, open it using status='old' for
"   a) formatted sequential access, if rl=0
"   b) unformatted direct access with record length = rl, if rl > 0.
"
" Return value:
"   - if all is OK, return the opened unit number
"   - if something fails, then
"       * if action = 0, return error code less than 0.
"       * if action != 0, call the $egs_fatal macro with an error message.
"
"******************************************************************************
implicit none;
$INTEGER iunit,rl,action;
character*(*) extension;

;COMIN/EGS-IO/;

integer  i,the_unit,lnblnk1,egs_get_unit;
$LOGICAL egs_is_absolute_path;
character base*1024, fn*1024;
$declare_write_buffer;

egs_open_datfile = -1; "so that the DEC compiler does not complain that"
                    "the function has an undefined values in some of"
                    "the excution paths (where exit(1) is called."
the_unit = egs_get_unit(iunit);
IF( the_unit < 0 ) [
    IF( action = 0 ) [ egs_open_datfile = -1; return; ]
    $egs_fatal(*,'No free Fortran I/O units left');
]

IF( egs_is_absolute_path(extension) ) [
    IF( rl = 0 ) [
        open(the_unit,file=extension,status='old',err=:no_datfile_0:);
    ]
    ELSE [
        open(the_unit,file=extension,status='old',form='unformatted',
              access='direct',recl=rl,err=:no_datfile_0:);
    ]
    egs_open_datfile = the_unit; return;

    :no_datfile_0:;
    IF( action = 0 ) [ egs_open_datfile = -2; return; ]
    $egs_fatal(*,'Failed to open file ',$cstring(extension));
]

$set_string(base,' '); $set_string(fn,' ');
base = $cstring(egs_home) // $cstring(user_code) // $file_sep;
"fn = $cstring(base) // $cstring(output_file) // $cstring(extension);"
IF( i_parallel > 0 ) [
    fn = $cstring(base) // $cstring(output_file) // '_w';
    call egs_itostring(fn,i_parallel,.false.);
    fn = $cstring(fn) // $cstring(extension);
]
ELSE [
    fn = $cstring(base) // $cstring(output_file) // $cstring(extension);
]
IF( rl = 0 ) [
    open(the_unit,file=fn,status='old',err=:no_datfile_1:);
]
ELSE [
    open(the_unit,file=fn,status='old',form='unformatted',access='direct',
         recl=rl,err=:no_datfile_1:);
]
egs_open_datfile = the_unit; return;

:no_datfile_1:;
$egs_warning('(a,a)','Failed to open ',$cstring(fn));
$set_string(fn,' ');
"fn = $cstring(base) // $cstring(input_file) // $cstring(extension);"
IF( i_parallel > 0 ) [
    fn = $cstring(base) // $cstring(input_file) // '_w';
    call egs_itostring(fn,i_parallel,.false.);
    fn = $cstring(fn) // $cstring(extension);
]
ELSE [
    fn = $cstring(base) // $cstring(input_file) // $cstring(extension);
]
IF( rl = 0 ) [
    open(the_unit,file=fn,status='old',err=:no_datfile_2:);
]
ELSE [
    open(the_unit,file=fn,status='old',form='unformatted',access='direct',
         recl=rl,err=:no_datfile_2:);
]
egs_open_datfile = the_unit; return;

:no_datfile_2:;
$egs_fatal(*,'Failed to open data file');
end;

"******************************************************************************
integer  function egs_open_file_junk(iunit,do_it_anyway,filen);
"******************************************************************************
" Open the file filen for sequential formatted I/O and return the unit
" number it was connected to.
" If iunit ~= 0, try to connect to unit |iuniti|, otherwise
" use the first unconnected unit found.
" If iunit > 0
"    open the unit even if it was already open, if do_it_anyway is .true.,
"    otherwise return -4.
" If iunit < 0
"    if the unit |iunit| is already in use and do_it_anyway is .true.,
"    search for the first available unit, otherwise return -4.
" Return values:
"   unit number, if the file was succesfully opened.
"   -1, if there was no free unit numer to connect to.
"   -2, if the file does not exist.
"   -3, if the file exist, but could not be opened.
"   -4, if |iunit|>0 & do_it_anyway=.false. and |iunit| is already in use.
"******************************************************************************
implicit none;
$INTEGER iunit;
$LOGICAL do_it_anyway;
character*(*) filen;

$LOGICAL aux;
$INTEGER the_unit,i;

inquire(file=filen,exist=aux);
IF( ~aux ) [ egs_open_file_junk = -2; return; ]
IF( iunit < 0 ) [ the_unit = -iunit; ] ELSE [ the_unit = iunit; ]
IF( the_unit ~= 0 ) [
    inquire(unit=the_unit,opened=aux);
    IF( aux ) [
        IF( ~do_it_anyway ) [ egs_open_file_junk = -4; return; ]
        IF( iunit < 0 ) the_unit = 0;
    ]
]
IF( the_unit = 0 ) [
    DO i=1,$max_unit [
        inquire(unit=i,opened=aux);
        IF( ~aux ) [ the_unit = i; EXIT; ]
    ]
    IF( the_unit = 0 ) [ egs_open_file_junk = -1; return; ]
]
open(the_unit,file=filen,status='old',err=:failed_to_open:);
egs_open_file_junk = the_unit; return;
:failed_to_open:
egs_open_file_junk = -3; return; end;

"==============================================================================
subroutine egs_strip_path(fname);
"==============================================================================
" Strip the path name from fname (if any)
implicit none;
character*(*) fname;
integer  i,l,l1,lnblnk1,j;
character slash;
slash = '/';
l = lnblnk1(fname);
DO i=1,l [
    IF( fname(i:i) = slash ) [ fname(i:i) = $file_sep; ]
]
DO i=l,1,-1 [
    IF( fname(i:i) = $file_sep | fname(i:i) = slash ) [
        l1 = l-i;
        fname(:l1) = fname(i+1:l);
        DO j=l1+1,len(fname) [ fname(j:j) = ' '; ]
        return;
    ]
]
return; end;

"==============================================================================
subroutine replace_env(fname);
"==============================================================================
"subroutine to replace environment variables (beginning with $) with their"
"full names or ~ with the full name of $HOME"
"Assumes environment variable or ~ appears only at the beginning of the"
"file name"

;COMIN/EGS-IO/;

character*(*) fname;
character*256 dirname;
integer indsep,ind1,ind2;

indsep = index(fname,$file_sep);
IF(indsep <= 0) return;
"hope that the user has just supplied the file name"
"and it is in the current directory"

ind1=index(fname,'$');
ind2=index(fname,'~');

"examine first character of name"
IF(ind1=1)[
    "get the environment variable"
    call getenv(fname(2:indsep-1),dirname);
    IF(dirname=' ')[
      $egs_fatal('(a,a/,a)',' Error in file name: ',$cstring(fname),
  ' First element in name does not specify a defined environment variable.');
   ]
   fname=$cstring(dirname)//fname(indsep:);
   $egs_info('(//a,a/)',' Retrieving file: ',$cstring(fname));
]
ELSEIF(ind2=1)[
    call getenv('HOME',dirname);
    IF(dirname=' ')[
      $egs_fatal('(a,a/,a)',' Error in file name: ',$cstring(fname),
  ' HOME is undefined.');
   ]
   fname=$cstring(dirname)//fname(indsep:);
   $egs_info('(//a,a/)',' Retrieving file: ',$cstring(fname));
]
return;
end;

"=============================================================================
subroutine egs_get_usercode(ucode);
"=============================================================================
" Deduct the user code name from the executable name
" The algorithm assumes that the executable is called
"   xxx[_debug|noopt][.exe]
" and it will fail if this is not the case.
"=============================================================================
implicit none;
COMIN/EGS-IO/;
character*(*) ucode;
character*512 arg;
integer  l,l1,lnblnk1,i;
$declare_write_buffer;

call getarg(0,arg); call egs_strip_path(arg);
l = lnblnk1(arg);
IF( arg(l-3:l) = '.exe' ) [
    arg(l-3:l) = ' '; l = l - 4;
]
IF( arg(l-5:l) = '_debug' ) [
    arg(l-5:l) = ' '; l = l-5;
]
IF( arg(l-5:l) = '_noopt' ) [
    arg(l-5:l) = ' '; l = l-5;
]
l1 = len(ucode);
IF( l > l1 ) [
    $egs_fatal(*,' user code name is too long (',l,' chars)');
]
$set_string(ucode,' '); ucode(:l) = arg(:l);
return; end;

subroutine egs_itostring(string,i,leave_space);
implicit none;
character*(*) string;
$INTEGER i;
integer  l,lnblnk1,idiv,itmp,iaux;
$LOGICAL first,leave_space;
l = lnblnk1(string)+1; IF( l > 1 & leave_space ) l=l+1;
idiv = 1000000000; itmp = i; first = .false.;
do while(idiv.gt.0) ;
    iaux = itmp/idiv;
    IF( (iaux > 0 | first ) & l <= len(string) ) [
        string(l:l) = char(iaux+48); first = .true.; l = l+1;
    ]
    itmp = itmp - iaux*idiv; idiv = idiv/10;
end do;
return; end;

"=============================================================================
$REAL function egs_rndm();
"=============================================================================
implicit none;
;COMIN/RANDOM/;
$RANDOMSET egs_rndm;
return; end;

"=============================================================================
integer  function egs_add_medium(medname);
implicit none;
character*(*) medname;
$declare_max_medium;
;COMIN/MEDIA,EGS-IO/;
$INTEGER i,l,imed,medname_len;
character c;
$LOGICAL  same;
$declare_write_buffer;

l = min(len(medname),24); medname_len = l;
DO i=1,l [
    c = medname(i:i);
    IF( ichar(c) = 0 ) [ medname_len = i-1; EXIT; ]
]
DO imed=1,nmed [
    l = 24;
    DO i=1,24 [
        IF( media(i,imed)(1:1) = ' ' ) [ l = i-1; EXIT; ]
    ]
    IF( l = medname_len ) [
        same = .true.;
        DO i=1,l [
            c = medname(i:i);
            IF( c ~= media(i,imed)(1:1) ) [ same = .false.; EXIT; ]
        ]
        IF( same ) [
            egs_add_medium = imed; return;
        ]
    ]
]
nmed = nmed + 1;
IF( nmed > $MXMED ) [
  $egs_fatal('(a,/,a,i3,a)',
    'In egs_add_medium: maximum number of media exceeded ',
    'Increase the macro $MXMED (currently ',$MXMED,') and retry');
]
l = min(len(medname),24);
DO i=1,l [
    c = medname(i:i);
    IF( ichar(c) = 0 ) [ l = i-1; EXIT; ]
    media(i,nmed) = ' ';
    media(i,nmed)(1:1) = c;
]
IF( l < 24 ) [
    DO i=l+1,24 [ media(i,nmed) = ' '; ]
]
egs_add_medium = nmed;
return; end;

subroutine egs_get_medium_name(imed,medname);
implicit none;
character*(*) medname;
$declare_max_medium;
;COMIN/MEDIA,EGS-IO/;
$INTEGER i,l,imed;
DO i=1,len(medname) [ medname(i:i) = ' '; ]
IF( imed < 1 | imed > nmed ) [ return; ]
l = 24;
DO l=24,1,-1 [
    IF( media(l,imed)(1:1) ~= ' ' ) EXIT;
]
l = min(l,len(medname));
DO i=1,l [ medname(i:i) = media(i,imed)(1:1); ]
return; end;
;

"============================================================================"
"  Pass pointers to the cross section interpolation coefficients to          "
"  an external subroutine                                                    "
"============================================================================"
subroutine egs_get_electron_data(func,imed,which);
implicit none;
$INTEGER imed,which;
external func;
$declare_max_medium;
;COMIN/ELECIN,MEDIA,EGS-IO/;
$REAL    lemin,lemax;

lemin = (1 - eke0(imed))/eke1(imed);
lemax = (meke(imed) - eke0(imed))/eke1(imed);
    IF( which = 1 ) [
    call func(meke(imed),lemin,lemax,esig0(1,imed),esig1(1,imed));
] ELSE IF( which = 2 ) [
    call func(meke(imed),lemin,lemax,psig0(1,imed),psig1(1,imed));
] ELSE IF( which = 3 ) [
    call func(meke(imed),lemin,lemax,ededx0(1,imed),ededx1(1,imed));
] ELSE IF( which = 4 ) [
    call func(meke(imed),lemin,lemax,pdedx0(1,imed),pdedx1(1,imed));
] ELSE IF( which = 5 ) [
    call func(meke(imed),lemin,lemax,ebr10(1,imed),ebr11(1,imed));
] ELSE IF( which = 6 ) [
    call func(meke(imed),lemin,lemax,pbr10(1,imed),pbr11(1,imed));
] ELSE IF( which = 7 ) [
    call func(meke(imed),lemin,lemax,pbr20(1,imed),pbr21(1,imed));
] ELSE IF( which = 8 ) [
    call func(meke(imed),lemin,lemax,tmxs0(1,imed),tmxs1(1,imed));
] ELSE IF( which = 9 ) [
    call func(meke(imed),lemin,lemax,range_ep(0,1,imed),range_ep(1,1,imed));
] ELSE [
    $egs_fatal(*,'Unknown electron data type ',which);
]
return; end;

subroutine egs_get_photon_data(func,imed,which);
implicit none;
$INTEGER imed,which;
external func;
$declare_max_medium;
;COMIN/PHOTIN,MEDIA,EGS-IO/;
$REAL    lemin,lemax;

lemin = (1 - ge0(imed))/ge1(imed);
lemax = (mge(imed) - ge0(imed))/ge1(imed);
IF( which = 1 ) [
    call func(mge(imed),lemin,lemax,gmfp0(1,imed),gmfp1(1,imed));
] ELSE IF( which = 2 ) [
    call func(mge(imed),lemin,lemax,gbr10(1,imed),gbr11(1,imed));
] ELSE IF( which = 3 ) [
    call func(mge(imed),lemin,lemax,gbr20(1,imed),gbr21(1,imed));
] ELSE IF( which = 4 ) [
    call func(mge(imed),lemin,lemax,cohe0(1,imed),cohe1(1,imed));
] ELSE IF( which = 5 ) [
    call func(mge(imed),lemin,lemax,PHOTONUC0(1,imed),PHOTONUC1(1,imed));
] ELSE [
    $egs_fatal(*,'Unknown photon data type ',which);
]
return; end;

/* Print binding energies: In the case of the EPDL library
   only energies above 1 keV are output for elements not part
   of the current simlation. This is due to the fact that energies
   below 1 keV are taken from the relaxation database only for
   elements requested in the input when EPDL is used. This is not
   an issue when using XCOM.
 */
subroutine egs_print_binding_energies;
implicit none;
$declare_max_medium;
;COMIN/EDGE,MEDIA,EGS-IO/;
$INTEGER    i,j;
integer*4   lnblnk1;
character*3 labels(16);
data labels/'  K',' L1',' L2',' L3',
            ' M1',' M2',' M3',' M4',' M5',
            ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/;

$egs_info('(a,a,a)',
        'Binding energies from ',$cstring(photon_xsections),
        ' photon cross section library');
DO j = 1,$MXELEMENT [
   DO i = 1,$MXPESHELL [
      IF ( binding_energies(i,j) > 0 ) [
         $egs_info('(a,i3,a,a,a,1pe12.4,a)',
         ' Eb(',j,',',labels(i),') = ',binding_energies(i,j),' MeV');
      ]
   ]
]

return;end;


"============================================================================="
"  scale elastic scattering strength by a given factor                        "
"============================================================================="
subroutine egs_scale_xcc(imed,factor);
implicit none;
$INTEGER imed;
$REAL    factor;
$declare_max_medium;
;COMIN/ELECIN,MEDIA/;
IF( imed > 0 & imed <= nmed ) [ xcc(imed) = xcc(imed)*factor; ]
return; end;


"============================================================================"
subroutine egs_write_string(ounit,string);
implicit none;
$INTEGER ounit;
character*(*) string;
write(ounit,'(a,$)') string;
$FLUSH_UNIT(ounit);
return; end;


"============================================================================"
subroutine egs_swap_2(c);
"============================================================================"
" Convert a 2 byte object from little endian to big endian byte order        "
" or vice versa                                                              "
character  c(2),tmp;
tmp=c(2); c(2)=c(1); c(1)=tmp;
return; end;

"============================================================================"
subroutine egs_swap_4(c);
"============================================================================"
" Convert a 2 byte object from little endian to big endian byte order        "
" or vice versa                                                              "
character  c(4),tmp;
tmp=c(4); c(4)=c(1); c(1)=tmp;
tmp=c(3); c(3)=c(2); c(2)=tmp;
return; end;


"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
" Utility subroutines and functions previously in egsnrc.mortran
"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

%E
subroutine set_spline(x,f,a,b,c,d,n);
"======================================================================"
"
" Sets cubic spline interpolation coefficients for the data contained  "
" in the array f(n) at the abscissas x(n)                              "
"                                                                      "
" I.Kawrakow, NRC                                                      "
"======================================================================"

implicit none;

$INTEGER n;
$REAL    x(n),f(n),a(n),b(n),c(n),d(n);

$INTEGER m1,m2,m,mr;
$REAL    s,r;

m1 = 2; m2 = n-1; s = 0;
DO m=1,m2 [
    d(m) = x(m+1) - x(m); r = (f(m+1) - f(m))/d(m);
    c(m) = r - s; s = r;
]
/s,r,c(1),c(n)/=0;
DO m=m1,m2 [
    c(m) = c(m) + r*c(m-1);
    b(m) = 2*(x(m-1) - x(m+1)) - r*s;
    s = d(m); r = s/b(m);
]
mr = m2;
DO m=m1,m2 [
    c(mr) = (d(mr)*c(mr+1) - c(mr))/b(mr);
    mr = mr - 1;
]
DO m=1,m2 [
    s = d(m); r = c(m+1) - c(m); d(m) = r/s;
    c(m) = 3*c(m);
    b(m) = (f(m+1)-f(m))/s - (c(m)+r)*s;
    a(m) = f(m);
]
return; end;
;

$REAL function spline(s,x,a,b,c,d,n);
"======================================================================"
"                                                                      "
" Returns the value of the function at s using the spline coefficients "
" a,b,c,d, which must have been set using set_spline                   "
"                                                                      "
" I.Kawrakow, NRC                                                      "
"======================================================================"

implicit none;

$INTEGER n;
$REAL    s,x(n),a(n),b(n),c(n),d(n);

integer  m_lower,m_upper,direction,m,ml,mu,mav;
$REAL    q;

IF( x(1) > x(n) ) [ direction = 1; m_lower = n; m_upper = 0; ]
ELSE              [ direction = 0; m_lower = 0; m_upper = n; ]
IF ( s >= x(m_upper + direction) ) [
    m = m_upper + 2*direction - 1;
]
ELSE IF( s <= x(m_lower+1-direction) ) [
    m = m_lower - 2*direction + 1;
]
ELSE [   " Perform a binary search to find the interval s is in "
    ml = m_lower; mu = m_upper;
    WHILE ( iabs(mu-ml) > 1 ) [
        mav = (ml+mu)/2;
        IF( s < x(mav) ) [ mu = mav; ]
        ELSE             [ ml = mav; ]
    ]
    m = mu + direction - 1;
]
q = s - x(m);
spline = a(m) + q*(b(m) + q*(c(m) + q*d(m)));
return; end;
;

%E "start of prepare_alias_table subroutine"
"****************************************************************************

subroutine prepare_alias_table(nsbin,xs_array,fs_array,ws_array,ibin_array);

" Prepare an alias sampling table, given the histogram probabilities
" xs_array,fs_array.
"*****************************************************************************
implicit none;

integer   nsbin;
$INTEGER  ibin_array(nsbin);
$REAL     xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin);

$INTEGER  i,j_l,j_h;
$REAL     sum,aux;

sum = 0;
DO i=1,nsbin [
    aux = 0.5*(fs_array(i)+fs_array(i-1))*(xs_array(i)-xs_array(i-1));
    IF( aux < 1e-30 ) aux = 1e-30;
    ws_array(i) = -aux; ibin_array(i) = 1;
    sum = sum + aux;
]
sum = sum/nsbin;

DO i=1,nsbin-1 [

    DO j_h = 1,nsbin [
        IF( ws_array(j_h) < 0 ) [
            IF( abs(ws_array(j_h)) > sum ) GOTO :AT_EXIT_1:;
        ]
    ]
    j_h = nsbin;
    :AT_EXIT_1:

    DO j_l = 1,nsbin [
        IF( ws_array(j_l) < 0 ) [
            IF( abs(ws_array(j_l)) < sum ) GOTO :AT_EXIT_2:;
        ]
    ]
    j_l = nsbin;
    :AT_EXIT_2:

    aux = sum - abs(ws_array(j_l));
    ws_array(j_h) = ws_array(j_h) + aux;
    ws_array(j_l) = -ws_array(j_l)/sum;
    ibin_array(j_l) = j_h;
    IF( i = nsbin-1 ) ws_array(j_h) = 1;

]

return; end;
;

%E   " start of alias_sample1 function "
"******************************************************************************

$REAL function alias_sample1(nsbin,xs_array,fs_array,ws_array,ibin_array);

" Sample a random variable from the alias table
"    xs_array,fs_array,ws_array,ibin_array
" which must have been prepared with prepare_alias_table
"
"******************************************************************************
implicit none;

integer   nsbin;
$INTEGER  ibin_array(nsbin);
$REAL     xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin);

;COMIN/RANDOM/;

$INTEGER j;
$REAL    r1,r2,aj,x,dx,a,rnno1;

$RANDOMSET r1; $RANDOMSET r2;
aj = 1 + r1*nsbin; j = aj; aj = aj - j;
IF( aj > ws_array(j) ) j = ibin_array(j);
x = xs_array(j-1); dx = xs_array(j)-x;
IF( fs_array(j-1) > 0 ) [
    a = fs_array(j)/fs_array(j-1)-1;
    IF( abs(a) < 0.2 ) [
        rnno1 = 0.5*(1-r2)*a;
        alias_sample1 = x + r2*dx*(1+rnno1*(1-r2*a));
    ]
    ELSE [
        alias_sample1 = x - dx/a*(1-sqrt(1+r2*a*(2+a)));
    ]
]
ELSE [
    alias_sample1 = x + dx*sqrt(r2);
]
return; end;
;

%E   " start of prepare_alias_histogram routine "
subroutine prepare_alias_histogram(nsbin,ws_array,ibin_array);
"*************************************************************
"                                                                           "
" Prepares an alias histogram for the probability array ws_array of         "
" dimension nsbin.                                                          "
" On return, the ws_array is modified and contains the alias weights,       "
" ibin_array holds the alias indices.                                       "
" To be used with the integer function sample_alias_histogram, which        "
" returns a bin index j with probability ws_array(j)                        "
"                                                                           "
" Iwan Kawrakow, November 2001
"***************************************************************************"

implicit none;

$INTEGER  nsbin,ibin_array(nsbin);
$REAL     ws_array(nsbin);

$INTEGER  i,j_l,j_h;
$REAL     sum,aux;

sum = 0;
DO i=1,nsbin [
    sum = sum + ws_array(i); ibin_array(i) = -1;
]
sum = sum/nsbin;

DO i=1,nsbin-1 [

    DO j_h = 1,nsbin [
        IF( ibin_array(j_h) < 0 & ws_array(j_h) > sum ) EXIT;
    ]

    DO j_l = 1,nsbin [
        IF( ibin_array(j_l) < 0 & ws_array(j_l) < sum ) EXIT;
    ]

    aux = sum - ws_array(j_l);
    ws_array(j_h) = ws_array(j_h) - aux;
    ws_array(j_l) = ws_array(j_l)/sum;
    ibin_array(j_l) = j_h;

]

DO i=1,nsbin [
    IF( ibin_array(i) < 0 ) [
        ibin_array(i) = i; ws_array(i) = 1;
    ]
]

return;
end;

%E   " start of sample_alias_histogram function "
$INTEGER function sample_alias_histogram(nsbin,ws_array,ibin_array);
"***********************************************************************
"
" This function samples a bin index using the alias sampling technique.
" The arrays ws_array and ibin_array of dimension nsbin must have been
" prepared with the subroutine prepare_alias_histogram.
"
" Iwan Kawrakow, November 2001.
"***********************************************************************

implicit none;

$INTEGER  nsbin,ibin_array(*);
$REAL     ws_array(*);

;COMIN/RANDOM/;

$REAL    r1,r2;
$INTEGER ibin;

$RANDOMSET r1; $RANDOMSET r2;
ibin = 1 + nsbin*r1;
IF( r2 > ws_array(ibin) ) ibin = ibin_array(ibin);
sample_alias_histogram = ibin;
return;
end;

%E   " start of gauss_legendre subroutine "
"******************************************************************************

subroutine gauss_legendre(x1,x2,x,w,n);

"     Given the lower and upper limit of integration, x1 and x2,
"     and given n, this routine returns arrays x and w,
"     containing the abscissas and weights of the Gauss-Legendre
"     n - point quadrature formula
"
"******************************************************************************
$IMPLICIT-NONE;

$INTEGER n;
real*8   x1,x2,x(n),w(n);

real*8     eps,Pi;
parameter (eps = 3.D-14, Pi = 3.141592654D0);

$INTEGER i,m,j;
real*8   xm,xl,z,z1,p1,p2,p3,pp;

m = (n + 1)/2;
xm=0.5d0*(x2+x1); xl=0.5d0*(x2-x1);
DO i=1,m [
    z=cos(Pi*(i-.25d0)/(n+.5d0));
    LOOP [
        p1=1.d0; p2=0.d0;
        DO j=1,n [
            p3 = p2; p2 = p1;
            p1=((2.d0*j-1.d0)*z*p2-(j-1.d0)*p3)/j;
        ]
        pp=n*(z*p1-p2)/(z*z-1.d0);
        z1=z; z=z1-p1/pp;
    ] UNTIL (abs(z-z1) < eps);
    x(i)=xm-xl*z; x(n+1-i)=xm+xl*z;
    w(i)=2.d0*xl/((1.d0-z*z)*pp*pp); w(n+1-i)=w(i);
]
return; end;
;

%E   " start of lnblnk1 function"
"******************************************************************************

integer  function lnblnk1(string);

"Function to return index of last non-blank character in a string"
"We use this instead of lnblnk because there are compilers"
"that do not have lnblnk"

"******************************************************************************
character*(*) string;
integer i;
DO i=len(string),1,-1 [
    j = ichar(string(i:i));
    IF( j = 0 ) [ lnblnk1 = i-1; return; ] "i.e. the same as strlen for "
                                           "0-terminated C-strings"
    IF( j ~= 9 & j ~= 10 & j ~= 11 & j ~= 12 & j ~= 13 & j ~= 32 ) [
        lnblnk1 = i; return;
    ]
]
lnblnk1 = 0; return; end;

%E   " start of erf1 function "
"************************************************************************
"       an error function routine which is needed since some of
"       the compiler don't have it as an intrinsic
"
"       Originally came from some library somewhere (Harwell I think)
"       recoded in mortran
"************************************************************************

$REAL FUNCTION ERF1(X);

$IMPLICIT-NONE;

$REAL x;

double precision A(0:22,2);     " Coefficients in expansion for erf(x) if x<3
                                " (K=1) and for erfc(x) x>3 (K=2)
double precision
       CONST,                   " 2/sqrt(pi)
       BN,BN1,BN2,              " Recursion coefficients B(n),B(n+1),B(n+2)
       Y,FAC;                   " y=x/3 or 3/x and FAC = 2(2y**2-1)
$INTEGER N,                     " recursion index n
         K,                     " K=1,2 for x <= 3 or x > 3
         NLIM(2);               " Maximum value of n in sum for K=1,2

DATA A/  1.0954712997776232 , -0.2891754011269890 ,  0.1104563986337951 ,
        -0.0412531882278565 ,  0.0140828380706516 , -0.0043292954474314 ,
         0.0011982719015923 , -0.0002999729623532 ,  0.0000683258603789 ,
        -0.0000142469884549 ,  0.0000027354087728 , -0.0000004861912872 ,
         0.0000000803872762 , -0.0000000124184183 ,  0.0000000017995326 ,
        -0.0000000002454795 ,  0.0000000000316251 , -0.0000000000038590 ,
         0.0000000000004472 , -0.0000000000000493 ,  0.0000000000000052 ,
        -0.0000000000000005 ,  0.0000000000000001 ,
         0.9750834237085559 , -0.0240493938504146 ,  0.0008204522408804 ,
        -0.0000434293081303 ,  0.0000030184470340 , -0.0000002544733193 ,
         0.0000000248583530 , -0.0000000027317201 ,  0.0000000003308472 ,
         0.0000000000001464 , -0.0000000000000244 ,  0.0000000000000042 ,
        -0.0000000000000008 ,  0.0000000000000001 ,  9*0.0              /;

DATA NLIM/ 22,16 /;
DATA CONST/ 1.128379167095513 /;

IF( x > 3 ) [ y = 3/x; k = 2; ]
ELSE        [ y = x/3; k = 1; ]

" Calculate sum of Chebyshev polynomials by backwards recursion
"
"       sum { A(n)*T(2n+1;y) : n=0,N } = y * ( B(0) - B(1) )
"       sum { A(n)*T(2n;y)   : n=0,N } = ( B(0) - (2*y**2-1) * B(1) ) / 2
"                                      = ( B(0) - B(2) + A(0) ) / 2
"
"       where B(N+2) = B(N+1) = 0
"       and B(n) = 2*(2*y**2-1)*B(n+1) - B(n+2) + A(n) for n=N,(N-1),...,1,0
"
FAC = 2.0 * ( 2.0 * Y*Y - 1.0 );
BN1 = 0.0;                       " Initialise B(N+2) = 0
BN  = 0.0;                       " Initialise B(N+1) = 0

DO n = NLIM(K),0,-1 [
   BN2 = BN1; BN1 = BN;
   BN = FAC * BN1 - BN2 + A(N,K)
]

IF ( k = 1 ) [ erf1 = CONST * Y * ( BN - BN1 ); ]
ELSE       [ erf1 = 1 - CONST * EXP(-X**2) * ( BN - BN2 + A(0,K) )/(4.0 * X); ]

RETURN;
end;

%E   " start of zero function "
"********************************************************"
"   Finds minimum non-zero value which can be used for   "
"   evaluating logarithms without getting a NAN.         "
"                                                        "
" Starting with 10^-20 and decreasing it by 5 orders of  "
" magnitud at a time, a check is made until the compiler "
" recognizes the number as zero and the previous number  "
" used. The same procedure is applied to this number but "
" decreasing it by one order of magnitud. Finally it is  "
" divided by 2..10 until the zero-check is successful.   "
"********************************************************"
$REAL FUNCTION ZERO();
$IMPLICIT-NONE;

$INTEGER i;
$REAL    x, xtemp;

x = 1.E-20;
"jump over 5 orders of magnitude"
DO i=1,100[
   IF (x = 0.0) [EXIT;]
   ELSE[xtemp = x;]
   x = x/1.E5;
]
x = xtemp;
"jump over 1 order of magnitude"
DO i=1,5[
   IF (x ~= 0.0)[xtemp = x;]
   ELSE[EXIT;]
   x = x/10;
]
x = xtemp;
"divide it up by 2...10"
DO i=2,10[
   IF (x ~= 0.0)[xtemp = x;]
   ELSE[EXIT;]
   x = x/i;
]
zero = xtemp;
return;end;
;

%E   " start of toUpper function "
"**************************************"
                                       "
"   Converts a string to upper case.   "
"                                      "
"**************************************"
character*512 function toUpper(a_string);
character*(*) a_string;
character*512 the_string;
$INTEGER cursor, i, lnblnk1;
toUpper = a_string; the_string = a_string;
DO i=1, lnblnk1(the_string) [
   cursor=ICHAR(the_string(i:i));
   IF ((cursor.GE.97).AND.(cursor.LE.122)) [
        cursor=cursor-32;toUpper(i:i)=CHAR(cursor);
   ]
]
return; end;
;

/***********************************************************************
   Tools for reading C/C++ binary files (byte-oriented) in Fortran.
   Note that with gfortran one could use access=stream, but this is not
   available in GNU g77. So, to preserve backwards compatibility we have
   created these tools.
 ************************************************************************/

"================================================================="
 integer*1 function egs_read_byte(iunit, jrec);
"================================================================="
" Reads one byte from a C/C++ binary file at jrec position        "
 implicit none;
 integer iunit, jrec, i, j, ierr;
 integer*1 i_1;
 character c_1;
 equivalence (i_1,c_1);
;COMIN/EGS-IO/;
 read(iunit,rec=jrec,IOSTAT=ierr) c_1;
 IF (ierr.ne.0) [
    $egs_warning(*,' *** egs_read_byte: ERROR READING A byte *** ');
    $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
    egs_read_byte = -1; return;
 ]
 jrec = jrec + 1; egs_read_byte = i_1;
 return; end;

"================================================================="
 integer*2 function egs_read_short(iunit, jrec);
"================================================================="
" Reads short int from a C/C++ binary file at jrec position        "
 implicit none;
 integer iunit, jrec, i, j, ierr;
 integer*2 i_2;
 character c_2(2);
 equivalence (i_2,c_2);
;COMIN/EGS-IO/;
 j = 0;
 DO i=jrec,jrec+1[
  j = j + 1;
  read(iunit,rec=i,IOSTAT=ierr) c_2(j);
  IF (ierr.ne.0) [
    $egs_warning(*,' *** egs_read_short: ERROR READING short integer *** ');
    $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
    egs_read_short = -1; return;
  ]
 ]
 jrec = jrec + 2; egs_read_short = i_2;
 return; end;

"================================================================="
 integer*4 function egs_read_int(iunit, jrec);
"================================================================="
" Reads integer from a C/C++ binary file at jrec position        "
 implicit none;
 integer iunit, jrec, i, j, ierr;
 integer*4 i_4;
 character c_4(4);
 equivalence (i_4,c_4);
;COMIN/EGS-IO/;
 j = 0;
 DO i=jrec,jrec+3[
  j = j + 1;
  read(iunit,rec=i,IOSTAT=ierr) c_4(j);
  IF (ierr.ne.0) [
    $egs_warning(*,' *** egs_read_int: ERROR READING integer *** ');
    $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
    egs_read_int = -1; return;
  ]
 ]
 jrec = jrec + 4; egs_read_int = i_4;
 return; end;


"================================================================="
 real*4 function egs_read_real(iunit, jrec);
"================================================================="
" Reads float from a C/C++ binary file at jrec position        "
 implicit none;
 integer iunit, jrec, i, j, ierr;
 real*4 r_4;
 character c_4(4);
 equivalence (r_4,c_4);
;COMIN/EGS-IO/;
 j = 0;
 DO i=jrec,jrec+3[
  j = j + 1;
  read(iunit,rec=i,IOSTAT=ierr) c_4(j);
  IF (ierr.ne.0) [
    $egs_warning(*,' *** egs_read_real: ERROR READING float *** ');
    $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
    egs_read_real = -1; return;
  ]
 ]
 jrec = jrec + 4; egs_read_real = r_4;
 return; end;

"****************************************************************
"*                                                              *
"*                 Function ibsearch(a, nsh, b)                 *
"*                                                              *
"*       binary search for an element l of array b such that    *
"*   b[l] =< a < b[l+1], array must be monotonically increasing *
"*                                                              *
"****************************************************************
$INTEGER function ibsearch(a, nsh, b);
 implicit none;
 $REAL a, b(*);
 $INTEGER min,max,help,nsh;
 $REAL x;
 min = 1; max = nsh; x = a;
 WHILE ( min < max-1 )[
       help = (max+min)/2;
       IF ( b(help).le.x)[min = help;]
       ELSE[max = help;]
 ]
 ibsearch = min;
 return;end;

%C80
"#############################################################################"
"                                                                             "
"  EGSnrc transport parameter macros                                          "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Iwan Kawrakow, 2003                                       "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                   Ernesto Mainegra-Hing                                     "
"                                                                             "
"#############################################################################"
"                                                                             "
"  These macros are used in conjunction with the get_inputs.mortran routines  "
"  to read in EGSnrc transport physics parameters. Specifically with          "
"  subroutine get_transport_parameter.                                        "
"                                                                             "
"  The following are definitions of code words (values sought) for the        "
"  various transport parameters that can be set. I hope they are              "
"  self-explanatory. If you don't like them:                                  "
"                                                                             "
"  - include this file via the configuration file BEFORE your user code.      "
"                                                                             "
"  - Replace the macros in your user code with code words that you prefer.    "
"                                                                             "
"#############################################################################"


REPLACE {$GLOBAL_ELECTRON_CUTOFF} WITH {'Global ECUT'}
REPLACE {$GLOBAL_PHOTON_CUTOFF}   WITH {'Global PCUT'}
REPLACE {$GLOBAL_SMAX}            WITH {'Global SMAX'}
REPLACE {$INCOHERENT_SCATTERING}  WITH {'Bound Compton scattering'}
REPLACE {$RADC_COMPTON}           WITH {'Radiative Compton corrections'}
REPLACE {$COHERENT_SCATTERING}    WITH {'Rayleigh scattering'}
REPLACE {$ATOMIC_RELAXATIONS}     WITH {'Atomic relaxations'}
REPLACE {$PE_ANGULAR_SAMPLING}    WITH {'Photoelectron angular sampling'}
REPLACE {$BREMS_ANGULAR_SAMPLING} WITH {'Brems angular sampling'}
REPLACE {$BREMS_CROSS_SECTIONS}   WITH {'Brems cross sections'}
REPLACE {$PAIR_ANGULAR_SAMPLING}  WITH {'Pair angular sampling'}
REPLACE {$PAIR_CROSS_SECTIONS}    WITH {'Pair cross sections'}
REPLACE {$TRIPLET_PRODUCTION}     WITH {'Triplet production'}
REPLACE {$ELECTRON_IMPACT_IONI}   WITH {'Electron Impact Ionization'}
REPLACE {$SPIN_EFFECTS}           WITH {'Spin effects'}
REPLACE {$MAXIMUM_ESTEPE}         WITH {'ESTEPE'}
REPLACE {$MAXIMUM_XIMAX}          WITH {'XImax'}
REPLACE {$SKIN_FOR_BCA}           WITH {'Skin depth for BCA'}
REPLACE {$BOUNDARY_ALGORITHM}     WITH {'Boundary crossing algorithm'}
REPLACE {$ELECTRON_STEP_ALG}      WITH {'Electron-step algorithm'}
REPLACE {$ON_IN_REGIONS}          WITH {'On in Regions'}
REPLACE {$OFF_IN_REGIONS}         WITH {'Off in Regions'}
REPLACE {$IN_REGIONS}             WITH {'Regions'}
REPLACE {$THE_DELIMETER}          WITH {'MC TRANSPORT PARAMETER'}
REPLACE {$PHOTON_XSECTIONS}       WITH {'Photon cross sections'}
REPLACE {$COMPTON_XSECTIONS}      WITH {'Compton cross sections'}
REPLACE {$PHOTON_XSECTIONS_OUT}   WITH {'Photon cross-sections output'}
REPLACE {$SCALE_L_EII_XSECTIONS}  WITH {'scale L EII cross-sections'}
"Ali:photonuc, 2 lines"
"Cannot use $PHOTONUC; it clashes with other variables"
REPLACE {$PHOTO_NUCLEAR}          WITH {'Photonuclear attenuation'}
REPLACE {$PHOTONUC_XSECTIONS}     WITH {'Photonuclear cross sections'}
REPLACE {$B_FIELD} WITH {'Magnetic Field'}
REPLACE {$E_FIELD} WITH {'Electric Field'}
REPLACE {$EM_LMT} WITH {'EM ESTEPE'}
;

REPLACE {$TURN-ON/OFF-IN-REGIONS(#,#,#,#);} WITH
{;
aux_inregions = .false.;
IF( error_flags({P1}) = 0 ) [
    write(i_log,*) {P2};
    itmp = value({P1},1);
    IF( itmp = 2 | itmp = 3 ) [
        ival                = ival + 1;
        values_sought(ival) = {P2};
        nvalue(ival)        = 0;
        type(ival)          = 0;
        value_min(ival)     = 1;
        value_max(ival)     = $MXREG;
        default(ival)       = 1;
        ival                = ival + 1;
        values_sought(ival) = {P3};
        nvalue(ival)        = 0;
        type(ival)          = 0;
        value_min(ival)     = 1;
        value_max(ival)     = $MXREG;
        default(ival)       = 1;
        Nmin = ival-1; Nmax = ival;
        CALL GET_INPUT;
        IF( error_flags(ival-1) = 0 & error_flags(ival) = 0 ) [
            IF( nvalue(ival) = nvalue(ival-1) ) [
                iitmp = itmp-2;
                DO j=1,$MXREG [ {P4}(j) = iitmp; ]
                 "i.e. set everywhere to 0 (if turn on) or 1 (if turn off)"
                iitmp = 1 - iitmp;
                 "and then re-set in the specified regions"
                DO k=1,nvalue(ival) [
                    istart = value(ival-1,k);
                    iend = value(ival,k);
"Ali:photonuc, 2 lines to crudely print start/stop regions"
                    write(i_log,*) {P2},istart;
                    write(i_log,*) {P3},iend;
                    IF( istart <= iend ) [
                        DO j=istart,iend [ {P4}(j) = iitmp; ]
                        aux_inregions = .true.;
                    ]
                ]
            ]
            ELSE [ value({P1},1) = {P4}(1); ]
        ]
        ELSE [ value({P1},1) = {P4}(1); ]
    ]
    ELSE [
        IF( itmp > 3 ) itmp = itmp-2;
        write(i_log,*) ' Setting all to ',itmp;
        DO j=1,$MXREG [ {P4}(j) = itmp; ]
    ]
]
ELSE ["Use default value"
  "Check if default is other than ON or Off"
  "and shift as no input by regions requested"
  IF({P4}(1) = 2 | {P4}(1) = 3)[
    value({P1},1) = {P4}(1)+2;
  ]
  ELSE[
    value({P1},1) = {P4}(1);
  ]
]

};

REPLACE{$SET # IN REGIONS(#,#,#,#,#,#,#);} WITH
{;

aux_inregions = .false.;
ival                = ival + 1;
{P2}                = ival;
values_sought(ival) = {P6};
nvalue(ival)        = 0;
type(ival)          = 1;
value_min(ival)     = {P3};
value_max(ival)     = {P4};
default(ival)       = {P5};

ival                = ival + 1;
values_sought(ival) = {P7};
nvalue(ival)        = 0;
type(ival)          = 0;
value_min(ival)     = 1;
value_max(ival)     = $MXREG;
default(ival)       = 1;

ival                = ival + 1;
values_sought(ival) = {P8};
nvalue(ival)        = 0;
type(ival)          = 0;
value_min(ival)     = 1;
value_max(ival)     = $MXREG;
default(ival)       = 1;

Nmin = {P2}; Nmax = {P2}+2; error_flag = 0;
CALL GET_INPUT;

IF( error_flag = 0 ) [
    IF( nvalue({P2}) = nvalue(ival) & nvalue(ival-1) = nvalue(ival) ) [
        DO k=1,nvalue(ival) [
            istart = value(ival-1,k);
            iend = value(ival,k);
            IF( istart <= iend ) [
                DO j=istart,iend [ {P1}(j) = value({P2},k); ]
                aux_inregions = .true.;
            ]
        ]
    ]
]
};
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc parameter input functions                                           "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Aaron Merovitz, 1998                                      "
"                   Dave Rogers, 1998                                         "
"                   Iwan Kawrakow, 1998                                       "
"                                                                             "
"  Contributors:    Ernesto Mainegra-Hing                                     "
"                   Blake Walters                                             "
"                   Frederic Tessier                                          "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Iwan Kawrakow, 1998, version 2.0, major rework:                            "
"                                                                             "
"  - Input values taken only if between specified delimiters (prior this      "
"    change, the first VALUES_SOUGHT found was taken, even if it was not      "
"    between the specified delimiters).                                       "
"                                                                             "
"  - Changed argument list to a common block GetInput defined in egs4.macros  "
"    to avoid memory use explosion.                                           "
"                                                                             "
"  - Eliminated initial loop checking for presence of values sought as it is  "
"    not necessary.                                                           "
"                                                                             "
"  - Introduced macros for handling strings (skipping blanks and comments,    "
"    changing to upper case, etc.)                                            "
"                                                                             "
"  - Eliminated string input bug: strings were always converted to upper case "
"                                                                             "
"  - Changed definition of strings to character*$MACRO where $MACRO has a     "
"    certain value that can be be defined in the user code if longer strings  "
"    are required.                                                            "
"                                                                             "
"                                                                             "
"  Iwan Kawrakow, 1999, version 2.1, major rework:                            "
"                                                                             "
"  - Missing or misspelled end delimiter together with a missing value sought  "
"    caused the routine to terminate. It now prints an error message and      "
"    continues to look for additional input.                                  "
"                                                                             "
"  - Introduced an array ERROR_FLAGS where the input status of each of the    "
"    attempted inputs is stored.                                              "
"                                                                             "
"#############################################################################"


SUBROUTINE GET_INPUT;
"                                                                           "
"                                                                           "
" FUNCTION: Extracts the requested values_sought from input file and        "
"           returns it to the caller.                                       "
"                                                                           "
" USAGE   :      Inputs must have the general form:                         "
"              ***************************************                      "
"              * Value_sought=  Value(s)             *                      "
"              ***************************************                      "
"         e.g.:        MEDNUM= 0, 1, 2                                      "
"                      MEDIA= AIR700ICRU                                    "
"                      RAYLEIGH SCATTERING= on                              "
"                                                                           "
"***************************************************************************"
"           >>>>>>>>>>>     BASIC RULES AND FEATURES    <<<<<<<<<<<         "
"***************************************************************************"
"
"   Inputs are all in the format: name of value_sought= value
"   where the name of value_sought must match that expected by the
"   program and the = sign must have no blanks between it and value_sought.
"
"   The value_sought must be the first thing on a line but blanks are
"     allowed before it.
"
"   Various inputs are only sought between certain delimeter strings
"     which are defined below (eg :start I/O control: :stop I/O control:)
"     If not specified, the whole file is searched for a requested value_sought.
"     Delimeter strings are enclosed by colons.
"     Note that within delimeter strings, order of inputs does not matter.
"
"   If a requested quantity is not found, this is noted in $input.errors
"     and this file is printed at the end of the log file.
"
"   A semi-colon implies the end of input for this quantity but is
"     not mandatory.  However, this means they cannot be used in titles.
"   A # sign indicated everything else on the line is a comment (and
"     cannot be used in titles.
"   Case is not important in the names of the quantites.
"
"   Commas separate multiple values for a given quantity and a comma
"     at the end of a line implies there is more input on the next line.
"   Values can extend over as many lines as needed. Use commas to imply
"     there are more values on the next line.
"
"   Blank lines and blanks in general are ignored.
"
"   The maximum record length is 256 characters.
"
"
"*******************************************************************************
"* (1)  *  Integers between parentheses show the value of the internal         *
"*      *  variable corresponding to this input. These are for reference only. *
"*      *                                                                      *
"* (M)  *  The 'M' indicates that the variable at hand has multiple            *
"*      *  input capability.  One may assign an arbitrary number of            *
"*      *  values to that input.                                               *
"*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
"*      *                                                                      *
"* (M2) *  The 'M' with an integer beside it means that the variable           *
"*      *  has that number of inputs.                                          *
"*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
"*      *                                                                      *
"* (I)  *  Regular (one number) integer input value.                           *
"*      *  E.g.:  SOURCE NUMBER= 0                                             *
"*      *                                                                      *
"* (R)  *  Regular (one number) real input value.                              *
"*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
"*      *                                                                      *
"* (C)  *  Regular (one string) character input value(no ; or #).              *
"*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
"*      *                                                                      *
"*******************************************************************************
"                                                                           "
"                                                                           "
" FEATURES: If the amount of values needed for a particular values_sought   "
"           is known and passed throught NVALUE(I), the subroutine will     "
"           check that the number of inputs correspond.  Otherwise,         "
"           NVALUE(I) will return the # of inputs found.                    "
"                                                                           "
"           For any integer or real (TYPE=0 or 1), get_inputs will check    "
"           that the numerical value input is between VALUE_MIN and         "
"           VALUE_MAX.  If not, it sets this value to the DEFAULT.          "
"                                                                           "
"           Writing in the input file can be upper case or lower case.      "
"           However, all FORTRAN >MUST< be programmed in upper case.        "
"              Changed the above: Can now be upper or lower case            "
"                                 IK, Dec. 1998                             "
"                                                                           "
"           For clarity, inputs can be terminated with a semicolon(;).      "
"           This is by no means necessary.                                  "
"                                                                           "
"***************************************************************************"
"          >>>>>>>>>>> IMPLEMENTING INTO NEW USER CODES <<<<<<<<<<<         "
"***************************************************************************"
"                                                                           "
"                   **** DECLARE YOUR INPUTS ****                           "
"                                                                           "
"    REALS AND INTEGERS (TYPE 0 AND 1)                                      "
"                                                                           "
"  I=I+1;                              <--index counter                     "
"  NUM_DRMIN=I;                        <--named pointer to the index num.   "
"  VALUES_SOUGHT(I)='DOSE RBOUND MIN'; <--name of variable                  "
"  NVALUE(I)=1;                        <--# of inputs(left out if not known)"
"  TYPE(I)=0;                          <--Type (0-3)                        "
"  VALUE_MIN(I)=0;                     <--Minimum value                     "
"  VALUE_MAX(I)=$MAXRADII-1;           <--Maximum value                     "
"  DEFAULT(I)=0;                       <--Default value                     "
"                                                                           "
"    CHARACTER INPUTS (TYPE 2)                                              "
"                                                                           "
"  I=I+1;
"  NUM_TITLE=I;
"  VALUES_SOUGHT(I)='TITLE';
"  TYPE(I)=2;
"  NVALUE(I)=1;                        <--left out if not known
"
"    ALLOWED INPTUS (TYPE 3)
"
"  I=I+1;
"  NUM_IWATCH=I;
"  VALUES_SOUGHT(I)='IWATCH';
"  NVALUE(I)=1;                        <--left out if not known
"  TYPE(I)=3;
"  ALLOWED_INPUTS(I,0)='OFF';
"  ALLOWED_INPUTS(I,1)='INTERACTIONS';
"  ALLOWED_INPUTS(I,2)='STEPS';
"  ALLOWED_INPUTS(I,3)='DEPOSITED';
"  ALLOWED_INPUTS(I,4)='GRAPH';
"                                                                           "
"                      **** STATE THE DELIMETER ****                        "
"                                                                           "
"            DELIMETER='TRANSPORT CONTROL'                                  "
"     OR     DELIMETER='NONE';                                              "
"                                                                           "
"  **** CALL THE SUBROUTINE WITH THE APPROPRIATE INDEX NUMBER OF THE ****   "
"                **** VALUES_SOUGHT(use NMIN and NMAX) ****                 "
"                                                                           "
"   The inputs are returned through CHAR_VALUE for character inputs         "
"   or VALUE for integers, reals and allowed inputs                         "
"                                                                           "
"---------------------------------------------------------------------------"


;IMPLICIT NONE;

COMIN/GetInput,EGS-IO/;

"***************************************************************************"
"*                   Variables used by the subroutine                      *"
"***************************************************************************"
CHARACTER*$STRING256 TEXT;      "Used to read in each line of the input file   "
CHARACTER*$STRING256 KEEPTEXT;  "Used to keep an old line of TEXT              "
CHARACTER*$STRING256 ORIGTEXT;  "The text without conversion to upper case     "
CHARACTER*$STRING256 TEXTPIECE;  "Used to read a piece of TEXT                 "
CHARACTER*$STRING80  DELIM_START;"Start of the delimeter                       "
CHARACTER*$STRING80  DELIM_END;  "End of the delimeter                         "
CHARACTER*$STRING32  VNAME;      "The name of the variable being extracted.    "
CHARACTER*$STRING32  VNAME1;     "The name of the variable being extracted.    "
$INTEGER       CURSOR;          "Used to read one of the TEXT letters          "
$INTEGER       IINDEX;          "Integer index for clipping string excess.     "
$INTEGER       iVNAME;          "Length of variable name string.               "
$INTEGER       IVAL;            "Value number of the value_sought              "
$INTEGER       UNITNUM;         "Unit number of the input file                 "
$INTEGER       ERR;             "Unit number of the error file                 "
$INTEGER       I,J,K,CHECK;     "Counters and checkers                         "
$INTEGER       LINE;            "Counts the eumber of lines                    "
$INTEGER       INT_VALUE;       "For printing integers                         "
$INTEGER       INT_VALUE_MIN;   "For printing integers                         "
$INTEGER       INT_VALUE_MAX;   "For printing integers                         "
$LOGICAL       ALLOWED;         "For evaluating an allowed_input               "
$LOGICAL       START_FOUND;     "Start of delimeter switch                     "
$INTEGER       ifound,length,lll,Kconvert;
$INTEGER       lnblnk1;"in house lnblnk function becuase not all compilers     "
                       "support this"
logical IDEBUG;
character*1 blank;
$INTEGER    error_level;
$INTEGER    the_level;
data blank/' '/;
data        error_level/1/;
save        error_level;
"---------------------------------------------------------------------------"

"Macro changing text string to upper case"
"REPLACE {$CONVERT-STRING-TO-UPPER-CASE(#);} WITH"
REPLACE {$CONVERT # TO UPPER CASE;} WITH
{;
   DO Kconvert=1, lnblnk1({P1}) [
         CURSOR=ICHAR({P1}(Kconvert:Kconvert));
         IF ((CURSOR.GE.97).AND.(CURSOR.LE.122)) [
            CURSOR=CURSOR-32;
            {P1}(Kconvert:Kconvert)=CHAR(CURSOR);
         ]
   ]
}
;

"Macro to skip leading blanks "
REPLACE {$SKIP LEADING BLANKS IN #;} WITH
{;
  length = len({P1});
  WHILE ( index({P1},blank) = 1 ) [
    IF( length >= 2 ) [ {P1}={P1}(2:); ] ELSE [ EXIT; ]
    length = length - 1;
  ]
}

"Macro that removes everything after comments "
REPLACE {$REMOVE EVERYTHING AFTER # IN #;} WITH
{
  ifound = INDEX({P2},{P1});
  IF( ifound > 1 ) [ {P2} = {P2}(1:ifound-1); ]
  ELSE [ IF( ifound = 1 ) [ {P2} = blank; ] ]
}

REPLACE {$STRING-OUTPUT(#);} WITH
{;
  length = lnblnk1({P1});
  IF( length > 0 ) [
    DO lll=1,length [ write(i_log,'(a1,$)') {P1}(lll:lll); ]
    write(i_log,*); "For a new line"
  ]
}

IDEBUG = .false.;   "set to .true. for debug outputs"
ERROR_FLAG = 0;
IF(IDEBUG) [OUTPUT NMIN,NMAX, $NMAX;(' Entering get_inputs seeking values',
   I5,' to', I5, '  with a max allowed of',I5);
]
IF (NMAX < NMIN | NMAX > $NMAX)[
  OUTPUT NMAX, NMIN, $NMAX;
  (//' Error entering get_inputs: Asked for values from',I5,' to',I5,
  '    with a max of',I5//' This implies a bug in the calling routine'/
  ' Fix it up and try again.  Stopping now.');
  STOP;
]
ERR=i_errors;    "inputfile.errors"
UNITNUM=i_input; "inputfile.egs4inp"
DELIM_START=':START '//DELIMETER(:lnblnk1(DELIMETER))//':';
DELIM_END=':STOP '//DELIMETER(:lnblnk1(DELIMETER))//':';
$CONVERT DELIM_START TO UPPER CASE; "This allows use of lower case letters"
$CONVERT DELIM_END TO UPPER CASE; "This allows use of lower case letters"

IF(IDEBUG) [OUTPUT DELIM_START,DELIM_END;(' start and stop delimeters are:'/
   A/A/);
]
"===================check that each value_sought is there===================="

DO I = NMIN, NMAX  [ "for each value_sought"
   REWIND (UNITNUM);   "Rewind the input file"
   LINE=0;             "reset line counter"
   CHECK=0;            "reset error checker"
   ERROR_FLAGS(I)=0;
   " Set to default for the case the input is not found "
   IF(TYPE(I) = 0 | TYPE(I) = 1) [ VALUE(I,1) = DEFAULT(I); ]
   IF(TYPE(I) = 3) [ VALUE(I,1) = 0; ]
   VNAME=VALUES_SOUGHT(I);
   iVNAME=lnblnk1(VNAME);
   IF( ivname < 1 )
   [
     IF( error_level > 0 ) [
       write(ERR,*) ' ======================= Warning ===================== ';
       write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!         ';
       write(ERR,*) ' ===================================================== ';
     ]
     ERROR_FLAG=1;
     ERROR_FLAGS(I)=1;
     goto :END-NMIN-NMAX-LOOP:;
   ]

   $CONVERT vname TO UPPER CASE; "This allows use of lower case letters"
   iindex = 0;
   IF (DELIMETER = 'NONE') [ start_found = .true.; ]
   ELSE                    [ start_found = .false.; ]
   WHILE ( iindex = 0 )  "Until the value sought is found"
   [
:GI25:
       CONTINUE;
       LINE=LINE+1;
       IF( start_found ) [
         READ(UNITNUM,END=:GI1003:,ERR=:GI1001:,FMT='(A256)') TEXT;
       ]
       ELSE [
         READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;
       ]
       "READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;"
       $SKIP LEADING BLANKS IN text;
       $REMOVE EVERYTHING AFTER '#' IN text;
       $REMOVE EVERYTHING AFTER ';' IN text;
       length = lnblnk1(TEXT);
       TEXT=TEXT(:length);
       origtext = text(:length);
       $CONVERT text TO UPPER CASE;
       IF( ~start_found ) [
         IF (INDEX(TEXT,DELIM_START) ~= 0 ) [ start_found = .true.; ]
         goto :GI25:;
       ]

       iindex=INDEX(TEXT,VNAME(:iVNAME));

       " Check for end delimeter "
       IF( DELIMETER~='NONE' )
       [
         IF (INDEX(TEXT,DELIM_END)~=0)
         [
             IF( error_level > 0 ) [
             WRITE (ERR,*) '***************ERROR***************';
             WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
                           '<<',' NOT FOUND';
             WRITE (ERR,*) 'END OF DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
             ]
             ERROR_FLAG=1;
             ERROR_FLAGS(I)=1;
             GOTO :END-NMIN-NMAX-LOOP:;
         ]
       ]
   ] "end while loop. If we pass this loop, we have the values_sought string "
     "in text"

   CHECK=0; "reset error checker"
   IF( idebug ) [
       write(i_log,*) ' ******* Found: ';
       write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
       write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
   ]

   " Set string pointer to position after vname string and/or "
   " leadinf equals                                           "
   IINDEX=IINDEX+iVNAME;
   TEXT=TEXT(IINDEX:); origtext=origtext(iindex:);
   IF( idebug ) [
       write(i_log,*) ' After removing vname: ';
       write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
       write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
   ]
   IINDEX=INDEX(TEXT,'=');
   IF (IINDEX.NE.0) [
      TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
   ]
   ELSE [
       IINDEX=INDEX(TEXT,':');
       IF (IINDEX.NE.0) [
          TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
       ]
   ]
   IF( idebug ) [
       write(i_log,*) ' After removing leading equals: ';
       write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
       write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
   ]

   "===============read the value(i)======================="
   IF ( (lnblnk1(TEXT)=0) | (lnblnk1(TEXT)=1) )
   [
        IF (vname(:ivname)='TITLE')
        [
           READ (UNITNUM,FMT='(A256)') TEXTPIECE;
           IF (lnblnk1(TEXTPIECE)~=0) [
              TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE));
              $SKIP LEADING BLANKS IN text;
              $SKIP LEADING BLANKS IN origtext;
              GOTO :TITLE-THERE:;
           ]
        ]
        IF( error_level > 0 ) [
        WRITE (ERR,*) '*************ERROR*************';
        WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
        WRITE (ERR,*) 'VALUE NOT THERE!!';
        ]
        ERROR_FLAG=1;
        ERROR_FLAGS(I)=1;
        RETURN;
   ]
:TITLE-THERE:
   CONTINUE;

   " Always check for default. The following sets the value to "
   " default(i) for a numeric input (type=1 or 2) and to 0 for "
   " an 'allowed input' => use only if one input is expected!  "
   iindex = index(text,'DEFAULT');
   IF( iindex ~= 0 )
   [                  "User requested a default value"
       IF( type(i) ~= 2 )
       [
           IF( type(i) ~= 3 ) [ VALUE(I,1)=DEFAULT(I); ]
           ELSE               [ VALUE(I,1)=0;          ]
           goto :END-NMIN-NMAX-LOOP:;
       ]
   ]

   IF ((TYPE(I) = 0)|(TYPE(I) = 1))
   [                                 "Read the number"
       IVAL=1;  "nvalue counter"
       IF( idebug )[write(i_log,*) ' *** Reading an integer or a real value! ';]
       LOOP
       [
           IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
           IF (lnblnk1(TEXT)=0) [
                 IF( error_level > 0 ) [
                 WRITE(ERR,*) '*************ERROR*************';
                 WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                 WRITE (ERR,*) 'VALUE NOT THERE!!';
                 ]
                 ERROR_FLAG=1;
                 ERROR_FLAGS(I)=1;
                 RETURN;
           ]
           READ(TEXT,END=:GI1010:,ERR=:GI1007:,FMT=*) VALUE(I,IVAL);
           IF( idebug ) [write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL);]
"==========================================================================="
"=================================Defaults=================================="

           IF ((VALUE(I,IVAL)>VALUE_MAX(I))|(VALUE(I,IVAL)<VALUE_MIN(I)))
           [
               IF (TYPE(I)=0)
               [
                    INT_VALUE=DEFAULT(I);
                    IF( error_level > 0 ) [
                    WRITE(ERR,*) '************WARNING************';
                    WRITE(ERR,:FMTA:) INT_VALUE,
                                 VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
                    ]
                    :FMTA: FORMAT ( 'Default= ',I9,' used for: ', A );
                    INT_VALUE=VALUE(I,IVAL);
                    INT_VALUE_MIN=VALUE_MIN(I);
                    INT_VALUE_MAX=VALUE_MAX(I);
                    IF( error_level > 0 ) [
                    WRITE(ERR,:FMTB:)
                        VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
                        INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX;
                    ]
                    :FMTB: FORMAT (A,'=', I9,' should be between ',
                                   I9,' and ', I9);
               ]
               IF (TYPE(I)=1)
               [
                    IF( error_level > 0 ) [
                    WRITE(ERR,*) '************WARNING************';
                    WRITE(ERR,:FMTC:) DEFAULT(I),
                                 VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
                    :FMTC: FORMAT ( 'Default= ',F12.6,' used for: ', A );
                    WRITE(ERR,:FMTD:)
                        VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
                        VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I);
                    :FMTD: FORMAT (A,'=', F12.6,' should be between ',
                                   G14.6,' and ', G14.6);
                    ]
               ]
               VALUE(I,IVAL)=DEFAULT(I);
           ] "end IF default"

           IF ( IVAL = NVALUE(I) ) EXIT; "Required inputs found"
"==========================================================================="
"=======================Move to next value, else exit======================="

           IF ((INDEX(TEXT,',')~=0)|(lnblnk1(TEXT)=0))
           [
               IF ( idebug ) [
                   write(i_log,*) ' A comma or a blank text found -> ';
                   write(i_log,*) ' searching for further input';
               ]
               TEXT=TEXT(INDEX(TEXT,',')+1:);
               WHILE (lnblnk1(TEXT)=0)
               [
                   IF ( idebug ) [
                     write(i_log,*) ' Empty text -> reading next line! ';
                   ]
                   LINE=LINE+1;
                   READ (UNITNUM,END=:GI1010:,ERR=:GI1007:,FMT='(A256)') TEXT;
                   $SKIP LEADING BLANKS IN text;
                   $REMOVE EVERYTHING AFTER '#' IN text;
                   $REMOVE EVERYTHING AFTER ';' IN text;
                   length = lnblnk1(TEXT);
                   TEXT=TEXT(:length);
                   origtext = text(:length);
                   $CONVERT text TO UPPER CASE;

                   "Check whether this line containes one of the strings sought"
                   DO K = 1 , NMAX
                   [
                       vname1 = VALUES_SOUGHT(K);
                       length = lnblnk1(vname1);
                       IF( length > 0 )
                       [
                           $SKIP LEADING BLANKS IN vname1;
                           $CONVERT vname1 TO UPPER CASE;
                           IF (INDEX(TEXT,vname1(:length))~=0)
                           [
                             IF( error_level > 0 ) [
                             WRITE(ERR,*) '************ERROR************';
                             WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                             WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
                                      '<--COMMA INDICATES ANOTHER INPUT';
                             WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
                                             TEXT(:lnblnk1(TEXT));
                             WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
                             ]
                             ERROR_FLAG=1;
                             ERROR_FLAGS(I)=1;
                           ]
                       ]
                   ]
                   IF( idebug ) [
                     write(i_log,*) ' Next line: ';
                     write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
                     write(i_log,'(a,$)') ' origtext: ';
                                          $STRING-OUTPUT(origtext);
                   ]
               ]
           ] "end if ~=0"
           ELSE [EXIT;]
           IVAL=IVAL+1;
       ] "end loop"
       IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
           IF( error_level > 0 ) [
           WRITE (ERR,*) '**************ERROR**************';
           WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
           WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)';
           WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
           ]
           ERROR_FLAG=1;
           ERROR_FLAGS(I)=1;
       ]
       ELSE [NVALUE(I)=IVAL;]
:GI1010:
       CONTINUE;
   ] "end IF TYPE"

"============================read the char_value(i)========================="

   IF ((TYPE(I) = 2) | (TYPE(I) = 3))
   [                                   "Read the string"
       IVAL=1;     "nvalue counter"
       IF( idebug ) [write(i_log,*) ' Trying to read a string! ';]
       LOOP
       [
           IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
           IF (lnblnk1(TEXT)=0) [
              IF( error_level > 0 ) [
              WRITE(ERR,*) '*************ERROR*************';
              WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
              WRITE (ERR,*) 'VALUE NOT THERE!!';
              ]
              ERROR_FLAG=1;
              ERROR_FLAGS(I)=1;
              RETURN;
           ]
           IF (vname(:ivname)='TITLE') [
              TEXTPIECE=origtext;
              GOTO :READ-IT:
           ]
           iindex = INDEX(origtext,',');
           IF ( iindex ~= 0 ) [ TEXTPIECE=origtext(:iindex-1); ]
           ELSE               [ TEXTPIECE=origtext;            ]
                      "The above is to avoid conversion to upper case"
                      "for e.g. media names                          "
           :READ-IT:
           CONTINUE;
           READ(TEXTPIECE,ERR=:GI1008:,FMT='(A256)') CHAR_VALUE(I,IVAL);
           $SKIP LEADING BLANKS IN CHAR_VALUE(I,IVAL);
           IF( idebug ) [
             write(i_log,*) ' Read the following char string: ';
             $STRING-OUTPUT(CHAR_VALUE(I,IVAL));
           ]
"===============================Allowed inputs=============================="
           IF (TYPE(I) = 3)
           [
              $CONVERT CHAR_VALUE(I,IVAL) TO UPPER CASE;
              ALLOWED=.FALSE.;
              DO K=0, $MXALINP [
                 vname1 = ALLOWED_INPUTS(I,K);
                 $SKIP LEADING BLANKS IN ALLOWED_INPUTS(I,K);
                 $CONVERT ALLOWED_INPUTS(I,K) TO UPPER CASE;
                 IF (ALLOWED_INPUTS(I,K)=CHAR_VALUE(I,IVAL)) [
                    ALLOWED=.TRUE.;
                    VALUE(I,IVAL)=K;
                    IF( idebug ) [
                      write(i_log,*) ' Found a allowed_value match ',k;
                    ]
                 ]
              ]
              IF (.NOT.ALLOWED) [
                 WRITE(ERR,*) '*************ERROR*************';
                 IF (IVAL~=1) [
                    WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                    WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY';
                 WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND VALUE';
                 ]
                 ELSE [
                    WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                    WRITE(ERR,*) 'INPUT-->',
                               CHAR_VALUE(I,IVAL)(:lnblnk1(CHAR_VALUE(I,IVAL))),
                               '<--NOT ALLOWED';
                    WRITE(ERR,*) 'OPTIONS ARE:';
                    WRITE(ERR,:FMT:)
                    (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_INPUTS(I,K))),
                     K=0,$MXALINP);
                 ]
                 :FMT: FORMAT(A40);
                 ERROR_FLAG=1;
                 ERROR_FLAGS(I)=1;
              ]
           ]
"=======================Move to next value, else exit======================="

           IF (vname(:ivname)='TITLE') [ EXIT; ]
           DO K=1,LEN(KEEPTEXT) [KEEPTEXT(K:K)=' ';]  "erase previous KEEPTEXT"
           KEEPTEXT(:lnblnk1(TEXT))=TEXT;
           iindex = INDEX(TEXT,',');
           IF ( iindex ~= 0 | lnblnk1(TEXT)=0 )
           [
               TEXT=TEXT(INDEX(TEXT,',')+1:);
               origtext=origtext(iindex+1:);
               WHILE (lnblnk1(TEXT)=0)
               [
                   LINE=LINE+1;
                   READ (UNITNUM,ERR=:GI1008:,FMT='(A256)') TEXT;
                   $SKIP LEADING BLANKS IN text;
                   $REMOVE EVERYTHING AFTER '#' IN text;
                   $REMOVE EVERYTHING AFTER ';' IN text;
                   length = lnblnk1(TEXT);
                   TEXT=TEXT(:length);
                   origtext = text(:length);
                   $CONVERT text TO UPPER CASE;

                   "Check whether this line containes one of the strings sought"
                   DO K = 1 , NMAX
                   [
                       vname1 = VALUES_SOUGHT(K);
                       length = lnblnk1(vname1);
                       IF( length > 0 )
                       [
                           $SKIP LEADING BLANKS IN vname1;
                           $CONVERT vname1 TO UPPER CASE;
                           IF (INDEX(TEXT,vname1(:length))~=0)
                           [
                             WRITE(ERR,*) '************ERROR************';
                             WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                             WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
                                      '<--COMMA INDICATES ANOTHER INPUT';
                             WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
                                             TEXT(:lnblnk1(TEXT));
                             WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
                             ERROR_FLAG=1;
                             ERROR_FLAGS(I)=1;
                           ]
                       ]
                   ]
               ]
           ] "end if ~=0"
           ELSE [EXIT;]
           IVAL=IVAL+1;
        ] "end loop"
        IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
           IF( error_level > 0 ) [
           WRITE (ERR,*) '*******************ERROR*******************';
           WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
           WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)';
           WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
           ]
           ERROR_FLAG=1;
           ERROR_FLAGS(I)=1;
        ]
        ELSE [NVALUE(I)=IVAL;]
   ]
"==========================================================================="
"==========================================================================="
   goto :END-NMIN-NMAX-LOOP:;

:GI1003:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '******************ERROR***********************';
        WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
        WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER';
        WRITE (ERR,*) 'VALUE SOUGHT: >>',
          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
        WRITE (ERR,*) 'END DELIMETER: >>',
          DELIM_END(:lnblnk1(DELIM_END)),'<<';
        ]
        ERROR_FLAG=1;
        ERROR_FLAGS(I)=1;
        goto :END-NMIN-NMAX-LOOP:;

:GI1004:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '******************ERROR***********************';
        WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
        WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER';
        WRITE (ERR,*) 'VALUE SOUGHT: >>',
          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
        WRITE (ERR,*) 'START DELIMETER: >>',
          DELIM_START(:lnblnk1(DELIM_START)),'<<';
        ]
        ERROR_FLAG=1;
        ERROR_FLAGS(I)=1;
        goto :END-NMIN-NMAX-LOOP:;

:GI1007:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '***************ERROR***************';
        IF (IVAL>1) [J=IVAL;] ELSE [J=1;]
        WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
        WRITE (ERR,*) 'LINE #',LINE;
        WRITE (ERR,*) 'COULD NOT READ THE VALUE!!';
        WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...';
        WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPUT?';
        ]
        ERROR_FLAG=1; "turn on the error flag"
        ERROR_FLAGS(I)=1; "turn on the error flag"
        GOTO :END-NMIN-NMAX-LOOP:;
:GI1008:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '***************ERROR***************';
        WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
        WRITE (ERR,*) 'LINE #',LINE;
        WRITE (ERR,*) 'COULD NOT READ THE STRING !!';
        ]
        ERROR_FLAG=1; "turn on the error flag"
        ERROR_FLAGS(I)=1; "turn on the error flag"

:END-NMIN-NMAX-LOOP:
    CONTINUE;
] "end do NMAX loop"
RETURN;

"**************if any errors**************"
:GI1001:
      WRITE (ERR,*) '***************ERROR***************';
      WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE;
      goto :GI1009:;
"the following is no longer used so comment it out"
":GI1002:
"      WRITE (ERR,*) '***************ERROR***************';
"      IF (CHECK=100) [
"         WRITE (ERR,*) 'DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
"         WRITE (ERR,*) 'WAS NOT FOUND';
"      ]
"      ELSE [
"         WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
"                       '<<',' NOT FOUND';
"      ]
"      WRITE (ERR,*) 'END OF FILE REACHED';
:GI1009:
      CONTINUE;  "exit if there is an error"
      ERROR_FLAG=1; "turn on the error flag"
      ERROR_FLAGS(I)=1; "turn on the error flag"
      RETURN;

entry get_input_set_error_level(the_level);
error_level = the_level;
return;
END;



%E   "get_inputs.mortran"
"*****************************************************************************
"
subroutine get_transport_parameter(ounit);
"
" is provided for use with the EGSnrc system. It reads all physics
" related parameters from the input file using the get_input routine.
" For a description for the format/conventions used in get_input,
" see the description at the beginning of this file.
" In order to use this routine, include transportp.macros BEFORE
" get_inputs.mortran via the configuration file.
" If the routine is called with ounit > 0, the transport parameter
" settings will be printid on unit ounit.
"
" Version 0.1           Iwan Kawrakow, January 1999
"
"******************************************************************************
"*******************************************************************************
"
"                         MC TRANSPORT PARAMETER
"                         **********************
"
"  All input associated with selection of various transport parameter
"  is not crucial for the execution as there are default values set.
"  Therefore, if some of the input options in this section are
"  missing/misspelled, this will be ignored and defualt parameter assumed
"  As the transport parameter input routine uses get_inputs, a lot
"  of error/warning messages may be produced on UNIT 15, though.
"  If you don't have the intention of changing default settings,
"  simply ignore the error messages.
"
"  The delimeters are
"
"               :start mc transport parameter:
"               :stop mc transport parameter:
"
"  You can change this by including the statement
"
"  REPLACE {$THE_DELIMETER} WITH {'WHATEVER-YOU-LIKE-THE-DELIMETER-TO-BE'}
"
"  in your input file.
"
"  Currently, the following options are available (case does not matter and
"             the internal variables are shown in [ ] brackets):
"
"       Global ECUT=     Global (in all regions) electron transport cut
"                        off energy (in MeV). If this imput is missing,
"                        AE(medium) will be used.
"                        [ ECUT ]
"       Global PCUT=     Global (in all regions) photon transport cut
"                        off energy (in MeV). If this imput is missing,
"                        AP(medium) will be used.
"                        [ PCUT ]
"       Global SMAX=     Global (in all regions) maximum step-size
"                        restriction for electron transport (in cm).
"                        If missing, no geometrical step-size restrictions
"                        will be employed. Note that if you use the default
"                        EGSnrc electron-step algorithm, no SMAX-restriction
"                        is necessary. Option is useful for transport in low
"                        density materials (air) when PRESTA behaviour is
"                        turned on (see below)
"                        [ SMAXIR ]
"       ESTEPE=          Maximum fractional energy loss per step.
"                        Note that this is a global option only, no
"                        region-by-region setting is possible. If missing,
"                        the defualt is 0.25 (25%).
"                        [ ESTEPE ]
"       XImax=           Maximum first elastic scattering moment per step.
"                        Default is 0.5, NEVER use value greater than 1 as
"                        this is beyond the range of MS data available.
"                        [ XIMAX ]
"       Boundary crossing algorithm=
"                        There are two selections possible: EXACT, means
"                        the algorithm will cross boundaries in a single
"                        scattering (SS) mode, the distance from a boundary
"                        at which the transition to SS mode is made is
"                        determined by 'Skin depth for BCA' (see below).
"                        The second option is PRESTA-I, if selected boundaries
"                        will be crossed a la PRESTA, i.e. with lateral
"                        correlations turned off and MS forced at boundaries.
"                        Default is EXACT.
"                        [ bca_algorithm, exact_bca ]
"       Skin depth for BCA=
"                        Determines the distance from a boundary (in elastic
"                        MFP) at which the algorithm will go into single
"                        scattering mode (if EXACT boundary crossing) or
"                        swith off lateral correlations (if PRESTA-I boundary
"                        crossing). Default value is 3 for EXACT or
"                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
"                        for a definition of BLCMIN). Note that if you choose
"                        EXACT boundary crossing and set Skin depth for BCA
"                        to a very large number (e.g. 1e10), the entire
"                        calculation will be in SS mode. If you choose
"                        PRESTA-I boundary crossing and make Skin depth for BCA
"                        large, you will get default EGS4 behavious (no PRESTA)
"                        [ skindepth_for_bca ]
"       Electron-step algorithm=
"                        PRESTA-II (the default), the name is
"                        used for historical reasons
"                        or PRESTA-I
"                        Determines the algorithm used to take into account
"                        lateral and longitudinal correlations in a
"                        condensed history step.
"                        [ transport_algorithm ]
"       Spin effects=    Off, On, default is On
"                        Turns off/on spin effects for electron elastic
"                        scattering. Spin On is ABSOLUTELY necessary for
"                        good backscattering calculations. Will make a
"                        difference even in `well conditioned' situations
"                        (e.g. depth dose curves for RTP energy range
"                        electrons).
"                        [ spin_effects ]
"       Brems angular sampling= Simple, KM, default is KM
"                        If Simple, use only the leading term of the Koch-Motz
"                        distribution to determine the emission angle of
"                        bremsstrahlung photons. If KM, complete
"                        modified Koch-Motz 2BS is used (modifications
"                        concern proper handling of kinematics at low energies,
"                        makes 2BS almost the same as 2BN at low energies).
"                        [ IBRDST ]
"       Brems cross sections= BH, NIST, NRC default is BH
"                        If BH is selected, the Bethe-Heitler bremsstrahlung
"                        cross sections (Coulomb corrected above 50 MeV)
"                        will be used. If NIST is selected, the NIST brems
"                        cross section data base (which is the basis for
"                        the ICRU radiative stopping powers) will be employed.
"                        Differences are negligible for E > ,say, 10 MeV,
"                        but significant in the keV energy range. If NRC is
"                        selected, the NRC brems cross-section data base will
"                        be used, which is a version of the NIST data base
"                        with corrected electron-electron brems contributions
"                        (corrections to the NIST data is typically only
"                        significant for low values of the atomic number Z
"                        and for k/T < 0.005).
"       Triplet production= On or Off (default).  Turns on/off simulation
"                        of triplet production.  If On, then Borsellino's
"                        first Born approximation is used to sample triplet
"                        events based on the triplet cross-section data.
"                        [ itriplet ]
"       Bound Compton scattering=  On, Off, Simple or norej (default)
"                        If Off, Compton scattering will be treated with
"                        Klein-Nishina, with On Compton scattering is
"                        treated in the Impulse approximation.
"                        With Simple, the impulse approximation incoherent
"                        scattering function will be used (i.e., no Doppler
"                        broadenning). With norej the actual total bound
"                        Compton cross section is used and there are no
"                        rejections at run time.
"                        Make sure to use for low energy applications,
"                        not necessary above, say, 1 MeV.
"                        [ IBCMP ]
"       Radiative Compton corrections= On or Off (default). If on, then
"                        include radiative corrections for Compton scattering.
"                        Equations are based on original Brown & Feynman
"                        equations (Phys. Rev. 85, p 231--1952).  Requires
"                        a change to the user codes Makefile to include
"                        $(EGS_SOURCEDIR)rad_compton1.mortran in the
"                        SOURCES (just before
"                        $(EGS_SOURCEDIR)get_inputs.mortran).
"                        [ radc_flag ]
"       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
"                        gryzinski, penelope.  If set to On or ik, then use
"                        Kawrakow's theory to derive EII cross-sections.
"                        If set to casnati, then
"                        use the cross-sections of Casnati (contained in the
"                        file ($HEN_HOUSE/data/eii_casnati.data).  Similar for
"                        kolbenstvedt, gryzinski and penelope. This is only of
"                        interest in kV X-ray calculations.
"                        Case-sensitive except for Off, On or ik options.
"                        [ eii_flag ]
"       Pair angular sampling= Off, Simple, KM.
"                        If off, pairs are set in motion at an angle m/E
"                        relative to the photon direction (m is electron rest
"                        energy, E the photon energy). Simple turns on
"                        the leading term of the angular distribution
"                        (this is sufficient for most applications),
"                        KM (comes from Koch and Motz) turns on using 2BS
"                        from the article by Koch and Motz.  Uniform
"                        Default is Simple, make sure you always use
"                        Simple or KM
"                        [ IPRDST ]
"       Pair cross sections= BH (default) or NRC.  If set to BH, then use
"                        Bethe-Heitler pair production cross-sections.  If set
"                        to NRC, then use NRC pair production cross-sections
"                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
"                        of interest at low energies, where the NRC cross-
"                        sections take into account the assymmetry in the
"                        positron-electron energy distribution.
"                        [ pair_nrc ]
"       Photon cross sections= Photon cross-section data.  Current options are
"                        si (Storm-Israel), epdl (Evaluated Photon Data
"                        Library), xcom (the default), pegs4, mcdf-xcom and
"                        mcdf-epdl:
"                        Allows the use of photon cross-sections other than
"                        from the PEGS4 file (unless the pegs4 option is
"                        specified).  Options mcdf-xcom and mcdf-epdl use
"                        Sabbatucci and Salvat's renormalized photoelectric
"                        cross sections with either xcom or epdl for all other
"                        cross sections.  These are more accurate but can
"                        increase CPU time by up to 6 %.
"                        Note that the user can supply their own cross-section
"                        data as well. The requirement is that the files
"                        photon_xsections_photo.data,
"                        photon_xsections_pair.data,
"                        photon_xsections_triplet.data, and
"                        photon_xsections_rayleigh.data exist in the
"                        $HEN_HOUSE/data directory, where photon_xsections
"                        is the name specified.
"                        Hence this entry is case-sensitive.
"                        [ photon_xsections ]
"       Photon cross-sections output= Off (default) or On.  If On, then
"                        a file $EGS_HOME/user_code/inputfile.xsections is
"                        output containing photon cross-section data used.
"                        [ xsec_out ]
"       Compton cross sections= Bound Compton cross-section data.  User-
"                        supplied bound Compton cross-sections in the file
"                        $HEN_HOUSE/data/comp_xsections_compton.data, where
"                        comp_xsections is the name supplied for this input.
"                        This is only used if Bound Compton scattering= Simple
"                        and is not available on a region-by-region basis
"                        (see below).  The default file (ie in the absence
"                        of any user-supplied data) is compton_sigma.data.
"                        [ comp_xsections ]
"       Rayleigh scattering= Off, On, custom
"                        If On, turn on coherent (Rayleigh) scattering.
"                        Default is On. Should be turned on for low energy
"                        applications.
"                        If custom, user must provide media names and form
"                        factor files for each desired medium. For the rest
"                        of the media, default atomic FF are used.
"                        [ IRAYLR ]
"       ff media names = A list of media names (must match media found in
"                        PEGS4 data file) for which the user is going to
"                        provide custom Rayleigh form factor data.
"                        [ iray_ff_media($MXMED) ]
"       ff file names = A list of names of files containing the Rayleigh
"                       form factor data for the media specified by
"                       the ff media names = input above.  Full directory
"                       paths must be given for all files, and for each medium
"                       specified, iray_ff_media(i), there must be a
"                       corresponding file name, iray_ff_file(i).  For
"                       example files, see the directory
"                       $HEN_HOUSE/data/molecular_form_factors.
"                       [ iray_ff_file($MXMED) ]
"Ali:photonuc, 2 blocks of comments"
"       Photonuclear attenuation= Off (default) or On
"                        If On, models the photonuclear effect. Current
"                        implementation is crude. Available on a
"                        region-by-region basis (see below)
"                        [ IPHOTONUCR ]
"       Photonuclear cross sections= Total photonuclear cross sections. User-
"                        supplied total photonuclear cross-sections in
"                        $HEN_HOUSE/data/photonuc_xsections_photonuc.data,
"                        where photonuc_xsections is the name supplied for
"                        this input (case sensitive). In the absence of
"                        any user-supplied data, or if photonuc_xsections
"                        is set to 'default', the default file is
"                        iaea_photonuc.data.
"                        [ photonuc_xsections ]
"       Photoelectron angular sampling= Off or On
"                        If Off, photo-electrons get the direction of the
"                        `mother' photon, with On, Sauter's furmula is
"                        used (which is, striktly speaking, valid only for
"                        K-shell photo-absorption).
"                        If the user has a better approach, replace the macro
"                            $SELECT-PHOTOELECTRON-DIRECTION;
"                        The only application that
"                        I encountered until now where this option made a
"                        small difference was a big ion chamber (cavity size
"                        comparable with electron range) with high-Z walls
"                        in a low energy photon beam.
"                        Default is On
"                        [ IPHTER ]
"       Atomic relaxations= Off, On, eadl, simple
"                        Default is eadl.  On defaults to eadl.
"                        When simulating atomic relaxations:
"                        - In photo-electric absorption events, the element
"                          (if material is mixture) and the shell the photon
"                          is interacting with are sampled from the appropriate
"                          cross sections
"                        - Shell vacancies created in photoelectric,
"                          compton and electron impact ionization events
"                          are relaxed via emission of fluorescent X-Rays,
"                          Auger and Koster-Cronig electrons.
"                         The eadl option features a more accurate treatment
"                         of relaxation events and uses binding energies
"                         consistent with those in of the photon cross sections
"                         used in the simulation.  If using mcdf-xcom or
"                         mcdf-epdl photon cross sections, you cannot use
"                         the simple option and this will automatically get
"                         reset to eadl.
"                         Make sure to use eadl or simple for low energy
"                         applications.
"                         [ IEDGFL ]
"
"       Atomic relaxations, Rayleigh scattering,
"       Photoelectron angular sampling and Bound Compton scattering
"       and photonuclear effect(Ali:photonuc)
"       can also be turned On/Off on a region-by-region
"       basis. To do so, put e.g.
"
"       Atomic relaxations= On in Regions   or
"       Atomic relaxations= Off in regions
"
"                         in your input file. Then use
"
"       Bound Compton start region=
"       Bound Compton stop region=
"                or
"       Rayleigh start region=
"       Rayleigh stop region=
"                or
"       Relaxations start region=
"       Relaxations stop region=
"                or
"       PE sampling start region=
"       PE sampling stop region=
"                or                  Ali:photonuc
"       Photonuclear start region=
"       Photonuclear stop region=
"
"                         each followed by a lost of of one or more
"                         start and stop regions separated by commas.
"                         Example:
"        Atomic relaxations= On in Regions
"        Relaxations start region=  1, 40
"        Relaxations stop region=  10, 99
"                         will first turn off relaxations everywhere and
"                         then turn on in regions 1-10 and 40-99.
"                         Note that input is checked against min. and max.
"                         region number and ignored if
"                         start region < 1 or stop_region > $MXREG or
"                         start region > stop region.
"
"                         ECUT, PCUT and SMAX can also be set on a
"                         region-by-region basis. To do so, iclude
"                         in your input file
"
"         Set XXXX=              f_value1, f_value2, ...
"         Set XXXX start region= i_value1, i_value2, ...
"         Set XXXX stop region=  j_value1, j_value2, ...
"
"                         where XXXX is ECUT, PCUT or SMAX ,
"                         f_value1, f_value2,... are the desired values for XXXX
"                         and i_value_i and j_value_i are the start and
"                         stop regions.
"
"*******************************************************************************

implicit none;  "Hard coded to catch possible user replacements of the "
                "following common blocks"

character*80 line;
character*512 toUpper;

$INTEGER ounit;
$declare_max_medium;

$COMIN-GET-TRANSPORTP;

$INTEGER  ival,num_ecut,num_pcut,num_smax,num_incoh,num_radc,num_coh,num_relax,
          num_pe_ang,num_brems_ang,num_brems_cs,num_pair_cs,
          num_ffmed,num_ffiles,
          num_pair_ang,num_eii,num_eii_L,num_estepe,num_ximax,num_triplet,
          num_pxsec,num_pxsec_out, num_cxsec,
          num_photonuc, num_photonuc_xsec,"Ali:photonuc, 1 line"
          num_efield, num_bfield, num_emlmt,"EMH: EM fields"
          num_spin,num_bca,num_alg,num_skin,itmp,iitmp,i,j,k,istart,iend,
          egs_open_file,lnblnk1;

$LOGICAL  ecut_inregions,pcut_inregions,smax_inregions,
          incoh_inregions,coh_inregions,relax_inregions,
          pe_inregions,aux_inregions,photonuc_inregions;"Ali:photonuc"

character*15 output_strings(14);"Ali:photonuc, increased by 1"
save         output_strings,line;
save         ecut_inregions,pcut_inregions,smax_inregions,
             incoh_inregions,coh_inregions,relax_inregions,
             pe_inregions,aux_inregions,photonuc_inregions,
             num_photonuc;"Ali:photonuc"


DO k=1,80 [ line(k:k) = '='; ]
delimeter = $THE_DELIMETER;
ival = 0;

;
/ecut_inregions,pcut_inregions,smax_inregions,
 incoh_inregions,coh_inregions,relax_inregions,
 pe_inregions,aux_inregions,
 "Ali:photonuc, 1 line"
 photonuc_inregions/ = .false.;

"open a .errors file exclusively for output from this subroutine"
i_errors=15;
i_errors=egs_open_file(i_errors,0,1,'.errors');

write(i_errors,*)
' If you are not trying to reset transport parameters, ';
write(i_errors,*)
' ignore all the output until the message ';
write(i_errors,*)
' ******************** end input transport parameter *********************** ';
write(i_errors,*);

" ECUT "
ival                = ival + 1;
num_ecut            = ival;                     "Set the variable pointer"
values_sought(ival) = $GLOBAL_ELECTRON_CUTOFF;  "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $GLOBAL-ECUT;

" PCUT "
ival                = ival + 1;
num_pcut            = ival;                     "Set the variable pointer"
values_sought(ival) = $GLOBAL_PHOTON_CUTOFF;    "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $GLOBAL-PCUT;

" SMAX "
ival                = ival + 1;
num_smax            = ival;                     "Set the variable pointer"
values_sought(ival) = $GLOBAL_SMAX;             "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $MAX-SMAX;

" Incoherent (Compton) scattering "
ival                = ival + 1;
num_incoh           = ival;                     "Set the variable pointer"
values_sought(ival) = $INCOHERENT_SCATTERING;   "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;
allowed_inputs(ival,4) = 'Simple';
allowed_inputs(ival,5) = 'norej';

" Radiative corrections for Compton scattering "
ival                = ival + 1;
num_radc            = ival;
values_sought(ival) = $RADC_COMPTON;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';

" Coherent (Rayleigh) scattering "
ival                = ival + 1;
num_coh             = ival;                     "Set the variable pointer"
values_sought(ival) = $COHERENT_SCATTERING;     "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;
allowed_inputs(ival,4) = 'custom';

" Atomic Relaxations "
ival                = ival + 1;
num_relax           = ival;                     "Set the variable pointer"
values_sought(ival) = $ATOMIC_RELAXATIONS;      "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;
allowed_inputs(ival,4) = 'eadl';
allowed_inputs(ival,5) = 'simple';

" Photoelectron angular sampling "
ival                = ival + 1;
num_pe_ang          = ival;                     "Set the variable pointer"
values_sought(ival) = $PE_ANGULAR_SAMPLING;     "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;

" Bremsstrahlung angular sampling "
ival                = ival + 1;
num_brems_ang       = ival;                     "Set the variable pointer"
values_sought(ival) = $BREMS_ANGULAR_SAMPLING;  "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Simple';
allowed_inputs(ival,1) = 'KM';   "means Koch-Motz, Simple turns on just the"
                                 "leading term of the distribution which is"
                                 "probably sufficiently accurate for most"
                                 "applications"

" Bremsstrahlung cross sections "
ival                = ival + 1;
num_brems_cs        = ival;                     "Set the variable pointer"
values_sought(ival) = $BREMS_CROSS_SECTIONS;    "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'BH';
allowed_inputs(ival,1) = 'NIST';                "Only global on/off available"
allowed_inputs(ival,2) = 'NRC';                 "Only global on/off available"


" Pair angular sampling "
ival                = ival + 1;
num_pair_ang        = ival;                     "Set the variable pointer"
values_sought(ival) = $PAIR_ANGULAR_SAMPLING;   "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'Simple';             "Only global on/off available"
allowed_inputs(ival,2) = 'KM';   "means Koch-Motz, Simple turns on just the"
                                 "leading term of the distribution which is"
                                 "probably sufficiently accurate for most"
                                 "applications"
allowed_inputs(ival,3) = 'Uniform';
allowed_inputs(ival,4) = 'Blend';

" Pair cross sections "
ival                = ival + 1;
num_pair_cs         = ival;
values_sought(ival) = $PAIR_CROSS_SECTIONS;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'BH';
allowed_inputs(ival,1) = 'NRC';

" Triplet production "
ival                = ival + 1;
num_triplet         = ival;
values_sought(ival) = $TRIPLET_PRODUCTION;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';

" Spin effects          "
ival                = ival + 1;
num_spin            = ival;                     "Set the variable pointer"
values_sought(ival) = $SPIN_EFFECTS;            "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';                 "Only global on/off available"

" Electron impact ionization "
ival                = ival + 1;
num_eii             = ival;
values_sought(ival) = $ELECTRON_IMPACT_IONI;
nvalue(ival)        = 1;
type(ival)          = 2;
"type(ival)          = 3;"
"allowed_inputs(ival,0) = 'Off';"
"allowed_inputs(ival,1) = 'On';"
"allowed_inputs(ival,2) = 'casnati';"
"allowed_inputs(ival,3) = 'kolbenstvedt';"
"allowed_inputs(ival,4) = 'gryzinski';"

" L-shell EII xsection scaling"
ival                = ival + 1;
num_eii_L= ival;                                "Set the variable pointer"
values_sought(ival) = $SCALE_L_EII_XSECTIONS;   "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0.0;                      "Define the allowed range"
value_max(ival)     = 1.0e+9;
default(ival)       = 1.0;

" ESTEPE "
ival                = ival + 1;
num_estepe          = ival;                     "Set the variable pointer"
values_sought(ival) = $MAXIMUM_ESTEPE;          "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 1e-5;                     "Define the allowed range"
value_max(ival)     = 1;
default(ival)       = $MAX-ELOSS;

" XIMAX "
ival                = ival + 1;
num_ximax           = ival;                     "Set the variable pointer"
values_sought(ival) = $MAXIMUM_XIMAX;           "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1;
default(ival)       = $EXACT-BCA-XIMAX;

" BCA "
ival                = ival + 1;
num_bca             = ival;                     "Set the variable pointer"
values_sought(ival) = $BOUNDARY_ALGORITHM;      "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Exact';
allowed_inputs(ival,1) = 'PRESTA-I';

" Skindepth "
ival                = ival + 1;
num_skin            = ival;                     "Set the variable pointer"
values_sought(ival) = $SKIN_FOR_BCA;            "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = -1;                       "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $SKIN-DEPTH-FOR-BCA;

" Electron-step algorithm "
ival                = ival + 1;
num_alg             = ival;                     "Set the variable pointer"
values_sought(ival) = $ELECTRON_STEP_ALG;       "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'PRESTA-II'; "Better EGSnrc ???"
allowed_inputs(ival,1) = 'PRESTA-I';

" Photon cross sections "
ival                = ival + 1;
num_pxsec           = ival;
values_sought(ival) = $PHOTON_XSECTIONS;
nvalue(ival)        = 1;
type(ival)          = 2;

" Photon cross sections output "
ival                = ival + 1;
num_pxsec_out       = ival;
values_sought(ival) = $PHOTON_XSECTIONS_OUT;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';

" Compton cross sections "
ival                = ival + 1;
num_cxsec           = ival;
values_sought(ival) = $COMPTON_XSECTIONS;
nvalue(ival)        = 1;
type(ival)          = 2;

" E-Field "
ival                = ival + 1;
num_efield          = ival;                     "Set the variable pointer"
values_sought(ival) = $E_FIELD;                 "The code word"
nvalue(ival)        = 3;                        "3 inputs"
type(ival)          = 1;                        "A real number"
value_min(ival)     = -1e15;                    "Define the allowed range"
value_max(ival)     =  1e15;
default(ival)       =  0;

" B-Field "
ival                = ival + 1;
num_bfield          = ival;                     "Set the variable pointer"
values_sought(ival) = $B_FIELD;                 "The code word"
nvalue(ival)        = 3;                        "3 inputs"
type(ival)          = 1;                        "A real number"
value_min(ival)     = -1e10;                    "Define the allowed range"
value_max(ival)     =  1e10;
default(ival)       =  0;

" EM-field step and eloss restriction "
ival                = ival + 1;
num_emlmt           = ival;                     "Set the variable pointer"
values_sought(ival) = $EM_LMT;                 "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0.0;                      "Define the allowed range"
value_max(ival)     = 1.0;
default(ival)       = 0.02;

"Ali:photonuc, 2 blocks"
" Photonuclear "
ival                = ival + 1;
num_photonuc        = ival;           "set the variable pointer"
values_sought(ival) = $PHOTO_NUCLEAR; "the code word"
nvalue(ival)        = 1;              "1 input"
type(ival)          = 3;              "an `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;

" Photonuclear cross sections "
ival                = ival + 1;
num_photonuc_xsec   = ival;
values_sought(ival) = $PHOTONUC_XSECTIONS;
nvalue(ival)        = 1;
type(ival)          = 2;

"Ali:photonuc, 1 line"
Nmin = num_ecut; Nmax = num_photonuc_xsec;
"Nmin = num_ecut; Nmax = num_cxsec;"

CALL GET_INPUT;

IF( error_flags(num_ecut) = 0 ) [
    DO j=1,$MXREG [ ecut(j) = value(num_ecut,1); ]
]
IF( error_flags(num_pcut) = 0 ) [
    DO j=1,$MXREG [ pcut(j) = value(num_pcut,1); ]
]
IF( error_flags(num_smax) = 0 ) [
    DO j=1,$MXREG [ smaxir(j) = value(num_smax,1); ]
]
IF( error_flags(num_brems_ang) = 0 ) [
    ibrdst = value(num_brems_ang,1);
]
IF( error_flags(num_brems_cs) = 0 ) [
    ibr_nist = value(num_brems_cs,1);
]
IF( error_flags(num_radc) = 0 ) [
    radc_flag = value(num_radc,1);
]
IF( error_flags(num_pair_ang) = 0 ) [
    iprdst = value(num_pair_ang,1);
]
IF( error_flags(num_pair_cs) = 0 ) [
    pair_nrc = value(num_pair_cs,1);
]
IF( error_flags(num_triplet) = 0 ) [
    itriplet = value(num_triplet,1);
]
IF( error_flags(num_eii_L) = 0 ) [ eii_L_factor = value(num_eii_L,1); ]
IF( error_flags(num_estepe) = 0 ) [ estepe = value(num_estepe,1); ]
IF( error_flags(num_ximax) = 0 ) [ ximax = value(num_ximax,1); ]
IF( error_flags(num_bca) = 0 ) [
    bca_algorithm = value(num_bca,1);
    IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
]
IF( error_flags(num_alg) = 0 ) [ transport_algorithm = value(num_alg,1); ]
IF( error_flags(num_skin) = 0 ) [ skindepth_for_bca = value(num_skin,1); ]
IF( error_flags(num_spin) = 0 ) [
   itmp = value(num_spin,1);
   IF( itmp = 1 ) [ spin_effects = .true.; ]
   ELSE           [ spin_effects = .false.; ]
]
/******************************************************
   Mantaining compatibility with previous versions
   allowing ON(IK) and OFF besides custom EII data
   compilation files of the form eii_prefix.data.
 ******************************************************/
IF( error_flags(num_eii) = 0 ) [
   eii_xfile = char_value(num_eii,1);eii_flag=1;
   IF (toUpper($cstring(eii_xfile)).eq.'ON' |
       toUpper($cstring(eii_xfile)).eq.'IK' )[
       eii_xfile = 'ik';
    $egs_info(*,'==> Using default EII data compilation ',
              $cstring(eii_xfile));
   ]
   ELSEIF (toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'OFF')[
       eii_xfile='Off';eii_flag=0;
   ]
   ELSE["Using non-default EII data compilation"
    $egs_warning(*,'==> Using non-default EII data compilation ',
                 $cstring(eii_xfile));
   ]
]
/******************************************************
   Use Sabbatucci and Salvat shellwise photoelectric
   cross sections together with XCOM or EPDL cross sections
   for pair production.
 ******************************************************/
IF( error_flags(num_pxsec) = 0 ) [
    photon_xsections = char_value(num_pxsec,1);
    IF ( toUpper( $cstring(photon_xsections) ) = 'MCDF-XCOM' )[
        mcdf_pe_xsections = .true.; photon_xsections = 'xcom';
    ]
    ELSEIF ( toUpper( $cstring(photon_xsections) ) = 'MCDF-EPDL' )[
        mcdf_pe_xsections = .true.; photon_xsections = 'epdl';
    ]
    ELSE[
        mcdf_pe_xsections = .false.;
    ]
]
/**********************************************************/
IF( error_flags(num_pxsec_out) = 0 ) [
    xsec_out = value(num_pxsec_out,1);
]
IF( error_flags(num_cxsec) = 0 ) [
    comp_xsections = char_value(num_cxsec,1);
]
"Ali:photonuc, 3 lines"
IF( error_flags(num_photonuc_xsec) = 0 ) [
    photonuc_xsections = char_value(num_photonuc_xsec,1);
]

IF( error_flags(num_efield) = 0 ) [
    ExIN = value(num_efield,1);
    EyIN = value(num_efield,2);
    EzIN = value(num_efield,3);
    IF( error_flags(num_emlmt) = 0 )[
       EMLMTIN=value(num_emlmt,1);
    ]
    IF( ExIN**2+EyIN**2+EzIN**2 > 0 ) [
        emfield_on=.true.
    ]
]
" Initially set to input values, could change with regions"
" by converting it to an array over all regions. This is  "
" currently implemented only for the C++ applications     "
IF( error_flags(num_bfield) = 0 ) [
    BxIN = value(num_bfield,1);
    ByIN = value(num_bfield,2);
    BzIN = value(num_bfield,3);
    Bx=BxIN;By=ByIN;Bz=BzIN;
    Bx_new=BxIN;By_new=ByIN;Bz_new=BzIN;
    IF( error_flags(num_emlmt) = 0 )[
       EMLMTIN=value(num_emlmt,1);
    ]
    IF( BxIN**2+ByIN**2+BzIN**2 > 0 ) [
        emfield_on=.true.
    ]
]


/***************************************************************/
/* Get media for which to read custom ff and the ff file names */
/***************************************************************/
IF( error_flags(num_coh) = 0 ) [
  IF(value(num_coh,1) = 4)[
   write(*,'(/a/)') ' ===> custom ff requested!';
   ival                = ival + 1;
   num_ffmed           = ival;
   values_sought(ival) = 'ff media names';
   type(ival)          = 2;  "i.e.  character input"
   nvalue(ival)        = 0;
   ival                = ival + 1;
   num_ffiles          = ival;
   values_sought(ival) = 'ff file names';
   type(ival)          = 2;  "i.e.  character input"
   nvalue(ival)        = 0;
   Nmin = num_ffmed; Nmax = num_ffiles;
   CALL GET_INPUT;
   IF( error_flags(num_ffmed) > 0 ) [
    $egs_fatal('(a/,a,I3)','Error reading custom ff! Terminating ...',
               ' error_flag = ', error_flags(num_ffmed));
   ]
   IF( error_flags(num_ffiles) > 0 ) [
    $egs_fatal('(a/,a,I3)','Error reading ff file names! Terminating ...',
               ' error_flag = ', error_flags(num_ffiles));
   ]
   IF (nvalue(num_ffmed)>$MXMED)[
      $egs_fatal('(a,a,i3,a)',
              '***** Number of media with custom ff larger ',
              'than maximum number of media $MXMED = ',$MXMED,
              ' increase $MXMED and try again!!!');
   ]
   DO i=1,nvalue(num_ffmed) [
    iray_ff_media(i) = char_value(num_ffmed,i);
    iray_ff_file(i)  = char_value(num_ffiles,i);
   ]
   value(num_coh,1) = 1; "reset to 1 since custom info in iray_ff_files"
  ]
  write(*,'(/)');
]
/***************************************************************/
/*
 Inputs allowing setting by region are checked with the macro
 $TURN-ON/OFF-IN-REGIONS. For this type of input, the second
 and third entries correspond to turning ON or OFF the interaction
 in specific regions. If no input is found, the default value is
 used.
 */
/***************************************************************/
$TURN-ON/OFF-IN-REGIONS(num_incoh,
                    'Bound Compton start region',
                    'Bound Compton stop region',
                    ibcmp); incoh_inregions = aux_inregions;
$TURN-ON/OFF-IN-REGIONS(num_coh,
                    'Rayleigh start region',
                    'Rayleigh stop region',
                    iraylr); coh_inregions = aux_inregions;
$TURN-ON/OFF-IN-REGIONS(num_relax,
                    'Relaxations start region',
                    'Relaxations stop region',
                    iedgfl); relax_inregions = aux_inregions;
$TURN-ON/OFF-IN-REGIONS(num_pe_ang,
                    'PE sampling start region',
                    'PE sampling stop region',
                    iphter); pe_inregions = aux_inregions;
"Ali:photonuc, 1 block"
$TURN-ON/OFF-IN-REGIONS(num_photonuc,
                    'Photonuclear start region',
                    'Photonuclear stop region',
                    iphotonucr); photonuc_inregions = aux_inregions;
$SET ecut IN REGIONS(num_ecut,0.,1e15,0.,'Set ECUT','Set ECUT start region',
                                         'Set ECUT stop region');
ecut_inregions = aux_inregions;

$SET pcut IN REGIONS(num_pcut,0.,1e15,0.,'Set PCUT','Set PCUT start region',
                                         'Set PCUT stop region');
pcut_inregions = aux_inregions;

$SET smaxir IN REGIONS(num_smax,0.,1e15,0.,'Set SMAX','Set SMAX start region',
                                         'Set SMAX stop region');
smax_inregions = aux_inregions;

write(i_errors,*);
write(i_errors,*)
' ******************** end input transport parameter *********************** ';
write(i_errors,*);

"Check if EADL relaxation requested. Note that original relaxation"
"algorithm using <M> and <N> is only turned ON for all regions."
"Moved past the $TURN-ON/OFF-IN-REGIONS statement to catch the"
"default case."
IF(value(num_relax,1) > 0 & value(num_relax,1) < 5)[
   eadl_relax = .true.;
   "Default relaxation is EADL"
   IF (value(num_relax,1) = 1)[value(num_relax,1)=4;]
]
ELSE [
    IF (mcdf_pe_xsections & value(num_relax,1) = 5)[
       eadl_relax = .true.; value(num_relax,1)=4;
       $egs_warning('(a/,a/,a/)',
                    '    Simplified atomic relaxation not allowed',
                    '    with shellwise PE cross sections. Resetting',
                    '    to detailed EADL atomic relaxation!!!');
    ]
    ELSE [
       eadl_relax = .false.;
    ]
]

" we put the information stored in allowed_inputs into "
" output_strings just in case the user over-rides it "
" before printing out the settings "

output_strings(1) = allowed_inputs(num_pair_ang,iprdst);
itmp = value(num_incoh,1);
output_strings(2) = allowed_inputs(num_incoh,itmp);
$RADC_WARNING;
output_strings(12) = allowed_inputs(num_radc,radc_flag);
itmp = value(num_coh,1);
output_strings(3) = allowed_inputs(num_coh,itmp);
itmp = value(num_relax,1);
output_strings(4) = allowed_inputs(num_relax,itmp);
itmp = value(num_pe_ang,1);
output_strings(5) = allowed_inputs(num_pe_ang,itmp);
output_strings(6) = allowed_inputs(num_brems_ang,ibrdst);
output_strings(7) = allowed_inputs(num_bca,bca_algorithm);
output_strings(8) = allowed_inputs(num_alg,transport_algorithm);
output_strings(9) = allowed_inputs(num_brems_cs,ibr_nist);
output_strings(10) = allowed_inputs(num_pair_cs,pair_nrc);
output_strings(11) = allowed_inputs(num_triplet,itriplet);
"output_strings(13) = allowed_inputs(num_eii,eii_flag);"
"Ali:photonuc, 2 lines"
itmp = value(num_photonuc,1);
output_strings(14) = allowed_inputs(num_photonuc,itmp);

entry show_transport_parameter(ounit);

IF ( ounit <= 0 ) return;

write(ounit,*);
write(ounit,'(a)') line;
write(ounit,*);
write(ounit,'(a,/)')
'                   Electron/Photon transport parameter';
write(ounit,'(a,/)') line;

/* initialized in egs_set_defaults */
write(ounit,'(a,38x,a)') ' Photon cross sections',
      $cstring(photon_xsections);
write(ounit,'(a,37x,a)') ' Compton cross sections', $cstring(comp_xsections);

write(ounit,'(a,$)') ' Photon transport cutoff(MeV)';
IF( pcut_inregions ) [ write(ounit,'(32x,a)') 'Set in regions'; ]
ELSE [
    IF( pcut(1) > 1e-4 ) [ write(ounit,'(32x,g14.4)') pcut(1); ]
    ELSE [ write(ounit,'(32x,a)') 'AP(medium)'; ]
]
write(ounit,'(a,39x,a3)')  ' Pair angular sampling',output_strings(1);
write(ounit,'(a,41x,a3)')  ' Pair cross sections',output_strings(10);
write(ounit,'(a,42x,a3)')  ' Triplet production',output_strings(11);
write(ounit,'(a,36x,a14)') ' Bound Compton scattering',output_strings(2);
write(ounit,'(a,31x,a14)') ' Radiative Compton corrections',output_strings(12);
write(ounit,'(a,41x,a14)') ' Rayleigh scattering',output_strings(3);
write(ounit,'(a,42x,a14)') ' Atomic relaxations',output_strings(4);
write(ounit,'(a,30x,a14)') ' Photoelectron angular sampling',output_strings(5);
"Ali:photonuc, 3 lines. EMH added IF statement"
IF ( value(num_photonuc,1) > 0 )[
 write(ounit,'(a,36x,a14)') ' Photonuclear attenuation',output_strings(14);
 write(ounit,'(a,33x,a)') ' Photonuclear cross sections',
 $cstring(photonuc_xsections);
]

write(ounit,*);

write(ounit,'(a,$)') ' Electron transport cutoff(MeV)';
IF( ecut_inregions ) [ write(ounit,'(30x,a)') 'Set in regions'; ]
ELSE [
    IF( ecut(1) > 1e-4 ) [ write(ounit,'(30x,f7.4)') ecut(1); ]
    ELSE [ write(ounit,'(30x,a)') 'AE(medium)'; ]
]
write(ounit,'(a,30x,a4)') ' Bremsstrahlung cross sections',output_strings(9);
write(ounit,'(a,29x,a3)') ' Bremsstrahlung angular sampling',output_strings(6);
IF( spin_effects ) [ write(ounit,'(a,48x,a)') ' Spin effects','On'; ]
ELSE [ write(ounit,'(a,48x,a)') ' Spin effects','Off'; ]
write(ounit,'(a,34x,a)') ' Electron Impact Ionization',$cstring(eii_xfile);
IF (eii_L_factor ~= 1.0) [
   write(ounit,'(a,25x,f6.4)')
   ' L-shell EII xsections scaling factor',eii_L_factor;
]
write(ounit,'(a,$)') ' Maxium electron step in cm (SMAX)';
IF( smax_inregions ) [ write(ounit,'(27x,a)') 'Set in regions'; ]
ELSE [
    IF( smaxir(1) > 1e-4 ) [ write(ounit,'(27x,g14.4)') smaxir(1); ]
    ELSE [ write(ounit,'(27x,a)') 'Restriction is off'; ]
]
write(ounit,'(a,16x,f6.4)')
 ' Maximum fractional energy loss/step (ESTEPE)',estepe;
write(ounit,'(a,21x,f6.4)')
 ' Maximum 1st elastic moment/step (XIMAX)',ximax;
write(ounit,'(a,33x,a10)')
 ' Boundary crossing algorithm',output_strings(7);
write(ounit,'(a,22x,g9.4)')
 ' Skin-depth for boundary crossing (MFP)',skindepth_for_bca;
write(ounit,'(a,37x,a10)')
 ' Electron-step algorithm',output_strings(8);
IF( ExIN~=0 | EyIN~=0 | EzIN~=0 )[
  write(ounit,'(a,38x,3f10.2)') ' Electric Field [V/cm]',
                  ExIN,EyIN,EzIN;
]
IF( Bx~=0 | By~=0 | Bz~=0 )[
  write(ounit,'(a,41x,3f10.2)') ' Magnetic Field [T]',
                  Bx,By,Bz;
]
IF( ExIN~=0 | EyIN~=0 | EzIN~=0 |
    Bx~=0 | By~=0 | Bz~=0 )[
  write(ounit,'(a,50x,f10.2)') ' EM ESTEPE',EMLMTIN;
]
write(ounit,*);
write(ounit,'(a)') line;
write(ounit,*);

return;
end;
;
/************************************************************************
 *
 * The following subroutine can be used to modify the elastic
 * scattering power in one or more media.
 * To do so, the user includes one or more lines in
 * the transport parameter section of the input file
 *
 *     scale elastic scattering in SOME_MEDIUM= 1.05
 *
 * where SOME_MEDIUM is the name of a medium.
 *
 * The effect of this will be that both, xcc and blcc will
 * get multiplied with the provided factor, leaving the
 * screening angle unchanged but increasing the number of collisions
 * per unit length.
 *
 ************************************************************************/

subroutine set_elastic_parameter;

implicit none;
$INTEGER ounit;
$declare_max_medium;
;COMIN/GetInput,ELECIN,MEDIA,EGS-IO/;
$INTEGER imed,ival,lnblnk1,nchanged;
character*24 medname;

ounit = i_log;
ounit = i_log;
delimeter = $THE_DELIMETER;
call get_input_set_error_level(0);
ival = 0;
DO imed=1,nmed [
    call egs_get_medium_name(imed,medname);
    ival                = ival + 1;
    values_sought(ival) = 'scale elastic scattering in '//
                           medname(:lnblnk1(medname));
    nvalue(ival)        = 1;
    type(ival)          = 1;
    value_min(ival)     = 1e-3;
    value_max(ival)     = 1e3;
    default(ival)       = 1;
]
Nmin = 1; Nmax = nmed;
CALL GET_INPUT;
nchanged = 0;
DO imed=1,nmed [
    IF( error_flags(imed) = 0 ) nchanged = nchanged + 1;
]
IF( nchanged > 0 ) [
    write(ounit,'(//a)')
'================ Elastic scattering scaled as follows ==================';
    DO imed=1,nmed [
        IF( error_flags(imed) = 0 ) [
            call egs_get_medium_name(imed,medname);
            xcc(imed)  = xcc(imed)*value(imed,1);
            blcc(imed) = blcc(imed)*value(imed,1);
            write(ounit,'(a,t30,f10.6)') medname(:lnblnk1(medname)),
              value(imed,1);
        ]
    ]
    write(ounit,'(a//)')
'========================================================================';
]
return; end;
;

"==========================end of get_inputs.mortran=================="
%C80
"#############################################################################"
"                                                                             "
"  EGSnrc core source code                                                    "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2000                                       "
"                   Dave Rogers, 2000                                         "
"                                                                             "
"  Contributors:    Ernesto Mainegra-Hing                                     "
"                   Blake Walters                                             "
"                   Frederic Tessier                                          "
"                   Reid Townson                                              "
"                   Victor Malkov                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"


"Compiler directives"
"==================="
%Q1         "Automatically close comments at end of line
            "but NOTE, this doesn't happen inside a REPLACE macro
            "you must open and close within a REPLACE macro.
%C80        "Allow 80 columns of source/line (default is 72)
!INDENT M2; "Indent Mortran compile listing 2 spaces each nesting level
!INDENT F2; "Indent fortran output 2 spaces each nesting level
%L          "Turn on listing

%I4 "INDENT FOUR SPACES EACH LEVEL"

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE ANNIH;
"                                                                  "
"******************************************************************"
"   GAMMA SPECTRUM FOR TWO GAMMA IN-FLIGHT POSITRON ANNIHILATION.  "
"   USING SCHEME BASED ON HEITLER'S P269-27O FORMULAE.             "
"                                                                  "
"   If the user requests radiative splitting (via nbr_split > 1),  "
"   this routine produces 2*nbr_split annihilation photons at once,"
"   each carying the fraction 1/nbr_split of the weight of the     "
"   incident positron.                                             "
"                                                                  "
"   Except for taking out the calculation of                       "
"   LOG((1.0-EP0)/EP0) out of the sampling loop and using a        "
"   rejection function normalized to its maximum, the sampling     "
"   technique is the same as the original EGS4 implementation.     "
"                                                                  "
"   I. Kawrakow, January 2000                                      "
"                                                                  "
"******************************************************************"
$IMPLICIT-NONE;

$COMIN-ANNIH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
                 "COMIN/DEBUG,STACK,UPHIOT,USEFUL,RANDOM,          "
                 "EGS-VARIANCE-REDUCTION/;                         "

$DEFINE-LOCAL-VARIABLES-ANNIH;
$INTEGER ip;

NPold = NP; "Set the old stack counter"
IF( nbr_split <= 0 ) [ return; ]
PAVIP=E(NP)+PRM; "PRECISE AVAILABLE ENERGY OF INCIDENT POSITRON,
                 "i.e. electron assumed to be at rest
AVIP=PAVIP;      "AVAILABLE ENERGY OF INCIDENT POSITRON"
A=AVIP/RM;
"AI=1.0/A;  AI not necessary, IK Oct 97"
G=A-1.0;
T=G-1.0;
P=SQRT(A*T);
POT=P/T;
EP0=1.0/(A+P);
"   SAMPLE 1/EP FROM EP=EP0 TO 1.0-EP0"
"Take the calculation of the logarithm out of the loop, IK Oct 97"
WSAMP=LOG((1.0-EP0)/EP0);

aa = u(np); bb = v(np); cc = w(np);
sinpsi = aa*aa + bb*bb;
IF( sinpsi > 1e-20 ) [
   sinpsi = sqrt(sinpsi);
   sindel = bb/sinpsi; cosdel = aa/sinpsi;
]

IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]

DO ibr = 1,nbr_split [  "nbr_split > 1 means we want splitting for any"
                        "radiative event                              "

    IF( np+1 > $MXSTACK ) [
        $egs_fatal('(//a,i6,a//)',' Stack overflow in ANNIH! np = ',np+1,
                   ' Increase $MXSTACK and try again' );
    ]

    LOOP[
        $RANDOMSET RNNO01;
        EP=EP0*EXP(RNNO01*WSAMP);
        "   NOW DECIDE WHETHER TO ACCEPT"
        $RANDOMSET RNNO02;
        "REJF=1.0-EP+AI*AI*(2.0*G-1.0/EP);"
        "The above rejection function has a maximum = 1 - 2/A**2"
        "For efficiency, it is better to divide by the maximum value, IK Oct 97"
        REJF = 1 - (EP*A-1)**2/(EP*(A*A-2));
    ] UNTIL (RNNO02 <= REJF);


    "   SET UP ENERGIES"
    ESG1=AVIP*EP; "ENERGY OF SECONDARY GAMMA 1"
    PESG1=ESG1; "PRECISE ENERGY OF SECONDARY GAMMA 1"
    E(NP)=PESG1; IQ(NP)=0;
    IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
    $TRANSFER PROPERTIES TO (np) FROM (ip);
    COSTHE=MAX(-1.0,MIN(1.0,(ESG1-RM)*POT/ESG1));
    SINTHE=SQRT(1.0-COSTHE*COSTHE);
    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
    IF( sinpsi >= 1e-10 ) [
        us = sinthe*cphi; vs = sinthe*sphi;
        u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
        v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
        w(np) = cc*costhe - sinpsi*us;
    ]
    ELSE [
        u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
    ]
    np = np + 1;
    PESG2=PAVIP-PESG1; esg2 = pesg2;
    e(np) = pesg2; iq(np) = 0;
    $TRANSFER PROPERTIES TO (np) FROM (np-1);
    COSTHE=MAX(-1.0,MIN(1.0,(ESG2-RM)*POT/ESG2));
    SINTHE=-SQRT(1.0-COSTHE*COSTHE);
    IF( sinpsi >= 1e-10 ) [
        us = sinthe*cphi; vs = sinthe*sphi;
        u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
        v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
        w(np) = cc*costhe - sinpsi*us;
    ]
    ELSE [
        u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
    ]
    np = np + 1;

]
np = np-1;

RETURN;
"END OF SUBROUTINE ANNIH"   END;

"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE ANNIH_AT_REST;
"                                                                  "
" It is handy to be able to initiate annihilation at rest from     "
" places other than the electron discard section (e.g. AUSGAB)     "
" Annihilation at rest takes a sufficent amount of time to not     "
" have any real benefit from this code being inline in the         "
" ELECTR subroutine.                                               "
" I. Kawrakow, June 2005.                                          "
"******************************************************************"
$IMPLICIT-NONE;
$COMIN-ANNIH-ATREST;
$REAL costhe,sinthe,cphi,sphi;
$INTEGER ibr,ip;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;

NPold = NP;
$CHECK-STACK(np+2*nbr_split-1,'ANNIH_AT_REST');
IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]
    " nbr_split > 1 means user wants to use radiative "
    " splitting => produce 2*nbr_split annihilation   "
    " photons at once                                 "
DO ibr = 1, nbr_split [
    "Pick random direction for first gamma
    $RANDOMSET costhe; costhe = 2*costhe-1;
    sinthe = sqrt(max(0.0,(1-costhe)*(1+costhe)));
    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
    e(np) = prm; iq(np) = 0;
    IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
    $TRANSFER PROPERTIES TO (np) FROM (ip);
    u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = costhe;
    np = np+1;
    e(np) = prm; iq(np) = 0;
    $TRANSFER PROPERTIES TO (np) FROM (np-1);
    u(np) = -u(np-1); v(np) = -v(np-1); w(np) = -w(np-1);
    np = np+1;
]
np = np-1;
return; end;


%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE BHABHA;
"                                                                  "
"******************************************************************"
"   DISCRETE BHABHA SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
"   ARBITRARILY DEFINED AND CALCULATED TO MEAN BHABHA SCATTERINGS  "
"   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
"   IT BE TRANSPORTED DISCRETELY, I.E. E=AE OR T=TE.  IT IS NOT    "
"   GUARANTEED THAT THE FINAL POSITRON WILL HAVE THIS MUCH ENERGY  "
"   HOWEVER.  THE EXACT BHABHA DIFFERENTIAL CROSS SECTION IS USED. "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-BHABHA;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
                   "COMIN/DEBUG,EGS-VARIANCE-REDUCTION,STACK,"
                                "THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-BHABHA;

NPold = NP;      "Set the old stack counter"
PEIP=E(NP); "PRECISE ENERGY OF INCIDENT POSITRON"
EIP=PEIP; "ENERGY OF INCIDENT POSITRON"
PEKIN=PEIP-PRM;  "PRECISE K.E. OF INCIDENT POSITRON"
EKIN=PEKIN;
T0=EKIN/RM;
E0=T0+1.;
YY=1./(T0+2.);
E02=E0*E0;
"BETAI2=E02/(E02-1.);" "BLIF 96/2/1 -- not needed for Bhabha fix-up"
BETA2=(E02-1.)/E02;    "BLIF 96/2/1 -- needed for Bhabha fix-up"
EP0=TE(MEDIUM)/EKIN;
EP0C=1.-EP0;
Y2=YY*YY;
YP=1.-2.*YY;
YP2=YP*YP;
B4=YP2*YP;
B3=B4+YP2;
B2=YP*(3.+Y2);
B1=2.-Y2;
"   SAMPLE BR FROM MINIMUM(EP0) TO 1."
LOOP[$RANDOMSET RNNO03;
BR=EP0/(1.-EP0C*RNNO03);
"   APPLY REJECTION FUNCTION"
$RANDOMSET RNNO04;
"REJF2=EP0C*(BETAI2-BR*(B1-BR*(B2-BR*(B3-BR*B4))));BLIF 96/2/1 -- Bhabha fix-up"
REJF2=(1.0-BETA2*BR*(B1-BR*(B2-BR*(B3-BR*B4)))); "BLIF 96/2/1 -- Bhabha fix-up"
]UNTIL RNNO04.LE.REJF2 ;
"   IF E- GOT MORE THAN E+, MOVE THE E+ POINTER AND REFLECT B"
$CHECK-STACK(np+1,'BHABHA');
IF (BR.LT.0.5)[IQ(NP+1)=-1;]ELSE[IQ(NP)=-1;IQ(NP+1)=1;BR=1.-BR;]
"THE ABOVE PUTS E+ ON TOP OF STACK IF IT HAS LESS ENERGY"
"   DIVIDE UP THE ENERGY"
BR=max(BR,0.0); "AVOIDS POSSIBLE NEGATIVE NUMBER DUE TO ROUND-OFF"
PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY 'ELECTRON' 2"
PESE1=PEIP-PEKSE2; "PRECISE ENERGY OF SECONDARY 'ELECTRON' 1"
PESE2=PEKSE2+PRM;  "PRECISE ENERGY OF SECONDARY 'ELECTRON' 2"
ESE1=PESE1;
ESE2=PESE2;
E(NP)=PESE1;
E(NP+1)=PESE2;
"   BHABHA ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS"
H1=(PEIP+PRM)/PEKIN;
"   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON"

"AFB modified the following statement 92/10/28 to avoid"
"numerical difficulties"
"DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);"
DCOSTH=MIN(1.0D0,H1*(PESE1-PRM)/(PESE1+PRM));

SINTHE=DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);
CALL UPHI(2,1);
NP=NP+1;
DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
SINTHE=-DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);
CALL UPHI(3,2);
RETURN;
"END OF SUBROUTINE BHABHA"  END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE BREMS;
"                                                                  "
"******************************************************************"
"   Samples bremsstrahlung energy using                            "
"    - Coulomb corrected Bethe-Heitler above 50 MeV                "
"    - Bethe-Heitler below 50 MeV                                  "
"   if ibr_nist = 0, or                                            "
"    - the NIST bremsstrahlung cross section data base             "
"      (prepared in a form of an alias table for rapid sampling)   "
"   if ibr_nist = 1  or                                            "
"    - the NRC bremsstrahlung cross section data base, which is    "
"      the same as the NIST database, but with corrections to      "
"      the electron-electron contribution, which are mostly        "
"      important for low Z and low k                               "
"   if ibr_nist = 2                                                "
"   and direction using                                            "
"    - formula 2BS from from Koch and Motz if IBRDST=1             "
"    - leading term of the brems angular dsstr. if IBRDST=0        "
"    - photon direction = electron direction if IBRDST<0           "
"                                                                  "
"   This version replaces the original EGS4 implementation         "
"   because of a bug discovered in the EGS4 brems routine          "
"   In order to work properly, the parameter DL1,..,DL6            "
"   are re-calculated in subroutine fix_brems which is called      "
"   from HATCH                                                     "
"   In addition, this version has the internal capability of       "
"   bremsstrahlung splitting.                                      "
"   To use bremsstrahlung splitting, set nbr_split (COMON/BREMPR/) "
"   to the desired number > 1 (1 is the default)                   "
"   Be aware that event-by-event energy conservation is NOT        "
"   guaranteed, so don't use for calculations where this is        "
"   important (e.g. calculation of detector response functions)    "
"   The result will be nbr_split photons, all with the weight      "
"   wt(npold)/nbr_split, and an electron with the original weight  "
"   and energy given by the incident energy - energy of last photon"
"                                                                  "
" I. Kawrakow, January 2000                                        "
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-BREMS;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,   "
                           "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-BREMS;
$REAL z2max,z2maxi,aux1,aux3,aux4,aux5,aux2,weight;

IF( nbr_split < 1 ) return;  "i.e. the user can turn off brems production"
                             "by setting nbr_split to zero!"

NPold = NP;      "Set the old stack counter"
PEIE=E(NP);      "PRECISE ENERGY OF INCIDENT 'ELECTRON'"
EIE=PEIE;        "ENERGY OF INCIDENT 'ELECTRON'"
weight = wt(np)/nbr_split;

"   DECIDE WHICH DISTRIBUTION TO USE (B-H COULOMB CORRECTED IS     "
"   USED FROM 50 TO 20000 MEV, B-H IS USED 1.5 TO 50 MEV)          "
IF (EIE.LT.50.0)[ L=1; ] ELSE [ L=3; ]
L1 = L+1;

ekin = peie-prm;
brmin = ap(medium)/ekin;
"waux = -log(brmin);"
waux = elke - log_ap(medium); "this saves the time consuming log evaluation"
                              "log_ap = log(ap(medium)) is calculated in   "
                              "fix_brems for each medium, elke is needed   "
                              "in electr to calculate the branching ratios "
                              "and therefore it must be known at this point"

IF( ibrdst >= 0 ) [ "inrdst >=0 means we will sample the photon emmision"
                    "angle from KM-2BS (ibrdst=1) or from the leading"
                    "term (ibrdst=0). If nbr_split > 1, we can re-use"
                    "the following quantities several time"

    a = u(np); b = v(np); c = w(np);
    sinpsi = a*a + b*b;
    IF( sinpsi > 1e-20 ) [
       sinpsi = sqrt(sinpsi);
       sindel = b/sinpsi; cosdel = a/sinpsi;
    ]

    ztarg = zbrang(medium);
    tteie = eie/rm;
    beta = sqrt((tteie-1)*(tteie+1))/tteie;
    y2max = 2*beta*(1+beta)*tteie*tteie;
    y2maxi = 1/y2max;
    IF( ibrdst = 1 ) [ z2max = y2max+1; z2maxi = sqrt(z2max); ]

]

IF( ibr_nist >= 1 ) [
    ajj = 1 + (waux + log_ap(medium) - nb_lemin(medium))*nb_dlei(medium);
    jj = ajj; ajj = ajj - jj;
    IF( jj >  $MXBRES ) [ jj = $MXBRES; ajj = -1; ]
]

DO ibr = 1,nbr_split [

    IF( ibr_nist >= 1 ) [ "use the NIST or NRC bremsstrahlung cross section"
                         "data base"
        IF( ekin > nb_emin(medium) ) [
            $RANDOMSET r1;
            IF( r1 < ajj ) [ j = jj+1; ] ELSE [ j = jj; ]
            br = alias_sample1($MXBRXS,nb_xdata(0,j,medium),
                               nb_fdata(0,j,medium),
                               nb_wdata(1,j,medium),nb_idata(1,j,medium));
        ]
        ELSE [ $RANDOMSET br; ]
        esg = ap(medium)*exp(br*waux); pesg = esg;
        pese = peie - pesg; ese = pese;
    ]
    ELSE [

        LOOP [ "User wants to use Bethe-Heitler"

            $RANDOMSET rnno06; $RANDOMSET rnno07;
            br = brmin*exp(rnno06*waux);
            esg = ekin*br; pesg = esg;
            pese = peie - pesg; ese = pese;
            delta = esg/eie/ese*delcm(medium); aux = ese/eie;
            IF( delta < 1 ) [
                phi1 = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
                phi2 = dl1(l1,medium)+delta*(dl2(l1,medium)+
                        delta*dl3(l1,medium));
            ]
            ELSE [
                phi1 = dl4(l,medium)+dl5(l,medium)*log(delta+dl6(l,medium));
                phi2 = phi1;
            ]
            rejf = (1+aux*aux)*phi1 - 2*aux*phi2/3;

        ] UNTIL (rnno07 < rejf);
    ]

    "   SET UP THE NEW PHOTON                                          "
    np=np+1;
    IF( np > $MXSTACK ) [
        $egs_fatal('(//a,i6,a//)',' Stack overflow in BREMS! np = ',np+1,
                   ' Increase $MXSTACK and try again' );
    ]
    e(np) = pesg; iq(np) = 0;
    $TRANSFER PROPERTIES TO (np) FROM (np-1);
    wt(np) = weight;
    IF( ibrdst < 0 ) [  "The photon will inherit the direction from "
                        "the electron. This option is given so that "
                        "the user can implement their own brems angle "
                        "schemes via a call to ausgab"
        u(np) = u(npold); v(np) = v(npold); w(np) = w(npold);
    ]
    ELSE [
       IF( ibrdst = 1 ) [
           /*
              This is the original implementation
              suggested by Alex Bielajew. Commented out as
              the implementation below is way more efficient.
              IK, Sep. 2004.
           ttese = ese/rm; esedei = ttese/tteie;
           rjarg1 = 1+esedei*esedei;
           rjarg2 = 3*rjarg1 - 2*esedei;
           rjarg3 = ((1-esedei)/(2*tteie*esedei))**2;
           $SET-BREM-REJECTION-FUNCTION(REJMIN,0.0);
           $SET-BREM-REJECTION-FUNCTION(REJMID,1.0);
           $SET-BREM-REJECTION-FUNCTION(REJMAX,y2max);
           rejtop = max(rejmin,rejmid,rejmax);
           LOOP [
              $RANDOMSET y2tst; y2tst = y2tst/(1-y2tst+y2maxi);
              $SET-BREM-REJECTION-FUNCTION(REJTST,Y2TST);
              $RANDOMSET rtest;
           ] UNTIL (rtest*rejtop <= REJTST);
           */
           ttese = ese/rm; esedei = ttese/tteie;
           rjarg1 = 1+esedei*esedei;
           rjarg2 = rjarg1 + 2*esedei;
           aux = 2*ese*tteie/esg; aux = aux*aux; aux1 = aux*ztarg;
           IF( aux1 > 10 ) [ rjarg3 = lzbrang(medium) + (1-aux1)/aux1**2; ]
           ELSE [ rjarg3 = log(aux/(1+aux1)); ]
           rejmax = rjarg1*rjarg3-rjarg2;
           LOOP [
               $RANDOMSET y2tst; $RANDOMSET rtest;
               aux3 = z2maxi/(y2tst+(1-y2tst)*z2maxi);
               rtest = rtest*aux3*rejmax;
               y2tst = aux3**2-1; y2tst1 = esedei*y2tst/aux3**4;
               aux4 = 16*y2tst1-rjarg2; aux5 = rjarg1-4*y2tst1;
               IF( rtest < aux4 + aux5*rjarg3 ) EXIT;
               aux2 = log(aux/(1+aux1/aux3**4));
               rejtst = aux4+aux5*aux2;
           ] UNTIL (rtest < rejtst );

       ]
       ELSE [
           $RANDOMSET y2tst; y2tst = y2tst/(1-y2tst+y2maxi);
       ]
       costhe = 1 - 2*y2tst*y2maxi;
       sinthe = sqrt(max((1-costhe)*(1+costhe),0.0));
       $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
       IF( sinpsi >= 1e-10 ) [
           us = sinthe*cphi; vs = sinthe*sphi;
           u(np) = c*cosdel*us - sindel*vs + a*costhe;
           v(np) = c*sindel*us + cosdel*vs + b*costhe;
           w(np) = c*costhe - sinpsi*us;
       ]
       ELSE [
           u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = c*costhe;
       ]
    ]
]

e(npold) = pese;

RETURN;
"END OF SUBROUTINE BREMS"   END;

"******************************************************************"
"                                                          NRCC    "
SUBROUTINE COMPT;
"                                VERSION 1.00  --  12 JAN 1999     "
"******************************************************************"
"                                                                  "
"   Subroutine for sampling incoherent (Compton) scattering        "
"   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
"   Otherwise scattering is modelled in the impulse approximation  "
"   (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325)  "
"   As the total cross section from PEGS4 is not modified (and thus"
"   calculated using Klein-Nishina), all rejections lead to an     "
"   unscattered photon and a zero energy electron.                 "
"   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
"   atomic relaxation is treated in RELAX. This has as a           "
"   consequence that more than one particle can be created as a    "
"   result of an incoherent scattering. The user should therefore  "
"   check their user codes for possible inconsistencies.           "
"                                                                  "
"   I.Kawrakow, January 1999                                       "
"                                                                  "
"   I.Kawrakow, March 2008:                                        "
"      If ibcmp = 2 or 3, the actual bound Compton scattering      "
"      cross section is used and rejections lead to resampling     "
"      instead of rejecting the entire interactions as stated above"
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/COMPTON-DATA,DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM/;

$DEFINE-LOCAL-VARIABLES-COMPT;
$LOGICAL first_time;
$INTEGER ibcmpl;

NPold = NP;       "Set the old stack counter"
peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
ko = peig/rm;     "Gamma energy in units of electron rest energy"
broi = 1 + 2*ko;  "Needed for scattering angle sampling"

$RADC_CHECK;

irl = ir(np); first_time = .true.; ibcmpl = ibcmp(irl);

:resample-compton:;
IF( ibcmpl > 0 ) [ "User wants to take into account binding effects"
                   "=>first sample the shell and see whether an    "
                   "  interaction is possible                      "
    $RANDOMSET rnno17; rnno17 = 1 + rnno17*n_shell(medium);
    i = int(rnno17); "rnno17 = rnno17 - i;
    IF( rnno17 > eno_array(i,medium) ) i = eno_atbin_array(i,medium);
    j = shell_array(i,medium); "j is the shell number in the data list"
    Uj = be_array(j);          "Uj is the binding energy in units of rm"

    " Binding energy rejection "
    IF( ko <= Uj ) [
        IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
        ELSE             [ goto :resample-compton:;     ]
    ]
    Jo = Jo_array(j);          "Jo is the Compton profile parameter"

]

" We always sample the scattering angle from Klein-Nishina"
:RESAMPLE:
;
IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
    IF( first_time ) [
        broi2 = broi*broi;
        alph1 = Log(broi);
        bro   = 1/broi;
        alph2 = ko*(broi+1)*bro*bro;
        alpha = alph1+alph2;
    ]
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        IF( rnno15*alpha < alph1 ) [ "Use 1/br part"
            br = Exp(alph1*rnno16)*bro;
        ]
        ELSE [  "Use the br part."
            br = Sqrt(rnno16*broi2 + (1-rnno16))*bro;
        ]
        temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
        aux = 1+br*br;
        rejf3 = aux - br*sinthe;
        $RANDOMSET rnno19;
    ] UNTIL rnno19*aux.le.rejf3;
]
ELSE [ "At low energies it is faster to sample br uniformely"
    IF( first_time ) [
        bro = 1./broi; bro1 = 1 - bro;
        rejmax = broi + bro;
    ]
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        br = bro + bro1*rnno15;
        temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
        rejf3 = 1 + br*br - br*sinthe;
    ] UNTIL rnno16*br*rejmax.le.rejf3;
]
first_time = .false.;

IF(br < bro | br > 1)  [
    IF( br < 0.99999/broi | br > 1.00001 ) [
        $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
    ]
    goto :RESAMPLE: ;
]

$RADC_REJECTION;

costhe = 1 - temp;
IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
    Uj = 0;
    goto :FINISHED-COMPTON-SAMPLING:;
]

" Check for rejection due to the limited range of pzmax "
br2 = br*br;
aux = ko*(ko-Uj)*temp;
aux1 = 2*aux + Uj*Uj;
pzmax = aux - Uj;
IF( pzmax < 0 & pzmax*pzmax >= aux1 ) [
    IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
    ELSE             [ goto :resample-compton:; ]
]
pzmax = pzmax/sqrt(aux1);
/*
pzmax = (aux - Uj)/sqrt(2*aux + Uj*Uj);
IF( pzmax <= -1 ) [
    IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
    ELSE             [ goto :resample-compton:; ]
]
*/
qc2 = 1 + br*br - 2*br*costhe;
qc  = sqrt(qc2);

IF( pzmax > 1 ) [
    pzmax = 1; af = 0; Fmax = 1; fpz = 1;
    goto :RETRY-PZ:;
]

aux3 = 1 + 2*Jo*abs(pzmax);
aux4 = 0.5*(1-aux3*aux3);
fpz  = 0.5*exp(aux4);
af   = qc*(1+br*(br-costhe)/qc2);

IF( af < 0 ) [
    IF( pzmax > 0 ) fpz = 1 - fpz;
    $RANDOMSET eta_incoh;
    IF( eta_incoh > fpz ) [
        IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
        ELSE             [ goto :resample-compton:; ]
    ]
    af = 0; Fmax = 1; goto :RETRY-PZ:;
]

IF( pzmax < -0.15 ) [
    Fmax = 1-af*0.15;
    fpz1 = fpz*Fmax*Jo;
]
ELSE IF( pzmax < 0.15 ) [
    Fmax = 1 + af*pzmax;
    aux3 = 1/(1+0.33267252734*aux3);
            "0.33267252734 is p/sqrt(2), p is the parameter from Eq. 7.1.25"
            "of Abramowitz and Stegun, needed for approximating Erf        "
    aux4 = fpz*aux3*(0.3480242+aux3*(-0.0958798+aux3*0.7478556)) +
           erfJo_array(j);
    IF( pzmax > 0 ) [
        "fpz1 = 1 - Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
          "missing factor 1/2 in the above found by Cerneliu Costescu"
          "0.62665706866 is sqrt(Pi/8)"
        fpz1 = (1 - Fmax*fpz)*Jo - 0.62665706866*af*aux4;
        fpz = 1 - fpz;
    ]
    ELSE [
        "fpz1 = Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
          "missing factor 1/2 in the above found by Cerneliu Costescu"
          "0.62665706866 is sqrt(Pi/8)"
        fpz1 = Fmax*fpz*Jo - 0.62665706866*af*aux4;
    ]
]
ELSE [
    Fmax = 1 + af*0.15;
    fpz1 = (1 - Fmax*fpz)*Jo;
    fpz = 1 - fpz;
]
$RANDOMSET eta_incoh;
IF(eta_incoh*Jo > fpz1 ) [
    IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
    ELSE             [ goto :resample-compton:; ]
]

"At this point, all rejections are handled, now we need to sample pz "
"between -1 and pzmax using the Compton profile of the selected shell"
"and F(pz,cos(theta)) as a rejection function                        "

:RETRY-PZ:;
IF( ibcmpl ~= 2 ) [
  $RANDOMSET rnno18; rnno18 = rnno18*fpz;
  IF( rnno18 < 0.5 ) [
    rnno18 = Max(1e-30,2*rnno18);
    pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo;
  ]
  ELSE [
    rnno18 = 2*(1-rnno18);
    pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo;
  ]
  IF( abs(pz) > 1 ) goto :RETRY-PZ:;
      "Due to the non-relativistic approximation"
      "for pz, it has to be between -1 and 1    "
  IF( pz < 0.15  ) [
    IF( pz < -0.15 ) [ frej = 1 - af*0.15; ]
    ELSE             [ frej = 1 + af*pz;   ]
    $RANDOMSET eta;
    IF( eta*Fmax > frej ) goto :RETRY-PZ:;
  ]
  "If pz > 0.15, F is always 1 => no need for rejection"
]
ELSE [ pz = 0; Uj = 0; "i.e., no Doppler broadenning and no binding energy" ]

" Calculate energy of scattered photon "
pz2 = pz*pz;
IF( abs(pz) < 0.01 ) [
    br = br*(1 + pz*(qc + (br2-costhe)*pz));
]
ELSE [
    aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
    aux2 = qc2 - br2*pz2*sinthe;
    IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
]
Uj = Uj*prm;

:FINISHED-COMPTON-SAMPLING:
pesg = br*peig; pese = peig - pesg - Uj + prm;
sinthe = Sqrt(sinthe);
call uphi(2,1); e(np) = pesg;
aux = 1 + br*br - 2*br*costhe;
IF( aux > 1e-8 ) [
    costhe = (1-br*costhe)/Sqrt(aux);
    sinthe = (1-costhe)*(1+costhe);
    IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
    ELSE [ sinthe = 0; ]
] ELSE [ costhe = 0; sinthe = -1; ]
np = np + 1;
$CHECK-STACK(np,'COMPT');
call uphi(3,2);
e(np) = pese; iq(np) = -1;

IF( ibcmpl = 1 | ibcmpl = 3 ) [

    " Shell vacancy "
    IF( Uj > 1e-3 ) [
        edep = pzero;

        call relax(Uj,shn_array(j),iz_array(j));
        "relax will put all particles with energies above ecut,pcut on the "
        "stack, the remaining energy will be scored in edep and deposited  "
        "locally (via the call to ausgab below)                            "
    ]
    ELSE [
        edep = Uj;
        edep_local = edep;
        $AUSCALL($SPHOTONA);
    ]
    IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]

]

" Now play Russian Roulette with resulting electrons if the user asked for it"
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"

return;

:INTERACTION-REJECTED:
" Create here a zero energy electron if required (check user codes) "
return;
end;

"******************************************************************"
"                                                          NRCC    "
SUBROUTINE old_COMPT;
"                                VERSION 1.00  --  12 JAN 1999     "
"******************************************************************"
"                                                                  "
"   Subroutine for sampling incoherent (Compton) scattering        "
"   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
"   Otherwise scattering is modelled in the impuls approximation   "
"    (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325) "
"   As the total cross section from PEGS4 is not modified (and thus"
"   calculated using Klein-Nishina), all rejections leed to an     "
"   unscattered photon and a zero energy electron.                 "
"   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
"   atomic relaxation is treated in RELAX. This has as a           "
"   consequence that more than one particle can be created as a    "
"   result of an incoherent scattering. The user should therefore  "
"   check their user codes for possible inconsistencies.           "
"   This version ignores the function F(cos(theta),pz).            "
"   This leads to a small error (at least compared to the cross    "
"   section we want to sample) at low energies (say, below Z keV)  "
"   The advantage is that it is substantially faster then the      "
"   version with F taken into account.                             "
"                                                                  "
"                                                                  "
"   I.Kawrakow, January 1999                                       "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/COMPTON-DATA,EGS-VARIANCE-REDUCTION,DEBUG, "
                               "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-COMPT-old;

i_survived_RR = 0;"0=> all survived russian roulette if played"
                  "must set here since, if bound compton and event is"
                  "rejected, this wouldn't be set to the new 0 value"
NPold = NP;       "Set the old stack counter"
peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
ko = peig/rm;     "Gamma energy in units of electron rest energy"
broi = 1 + 2*ko;  "Needed for scattering angle sampling"

irl = ir(np);
IF( ibcmp(irl) = 1 ) [ "User wants to take into account binding effects"
                       "=>first sample the shell and see whether an    "
                       "  interaction is possible                      "
    $RANDOMSET rnno17;
    DO i=1,n_shell(medium) [
        rnno17 = rnno17 - eno_array(i,medium);
        IF( rnno17 <= 0 ) EXIT;
    ]
    j = shell_array(i,medium); "j is the shell number in the data list"
    Uj = be_array(j);          "Uj is the binding energy in units of rm"

    " Binding energy rejection "
    IF( ko <= Uj ) [ goto :INTERACTION-REJECTED-old:; ]

]

" We always sample the scattering angle from Klein-Nishina"
:RESAMPLE-old:
;
IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
    broi2 = broi*broi;
    alph1 = Log(broi);
    alph2 = ko*(broi+1)/broi2;
    alpha = alph1/(alph1+alph2);
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        IF( rnno15 < alpha ) [ "Use 1/br part"
            br = Exp(alph1*rnno16)/broi;
        ]
        ELSE [  "Use the br part."
            br = Sqrt(rnno16 + (1-rnno16)/broi2);
        ]
        temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
        rejf3 = 1 - br*sinthe/(1+br*br);
        $RANDOMSET rnno19;
    ] UNTIL rnno19.le.rejf3;
]
ELSE [ "At low energies it is faster to sample br uniformely"
    bro = 1./broi; bro1 = 1 - bro;
    rejmax = broi + bro;
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        br = bro + bro1*rnno15;
        temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
        rejf3 = (br + 1./br - sinthe)/rejmax;
    ] UNTIL rnno16.le.rejf3;
]

IF(br < 1./broi | br > 1)  [
    IF( br < 0.99999/broi | br > 1.00001 ) [
    $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
    ]
    goto :RESAMPLE-old: ;
]

IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
    Uj = 0; costhe = 1 - temp;
    goto :FINISHED-COMPTON-SAMPLING-old:;
]

" Sample Doppler broadening using the Compton profile of the selected shell"
br2 = br*br;
costhe = 1 - temp;
aux = ko*(ko-Uj)*temp; aux1 = aux-Uj;
pzmax2 = aux1*aux1/(2*aux+Uj*Uj);
:RETRY-PZ-old:;
$RANDOMSET rnno18;
IF( rnno18 < 0.5 ) [
    rnno18 = Max(1e-30,2*rnno18);
    pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo_array(j);
    pz2 = pz*pz;
    IF( (pz2 <= pzmax2) & (aux1 < 0) ) [goto :INTERACTION-REJECTED-old:; ]
]
ELSE [
    IF( aux1 < 0 ) [goto :INTERACTION-REJECTED-old:; ]
    rnno18 = 2*(1-rnno18);
    pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo_array(j);
    pz2 = pz*pz;
    IF( pz2 >= pzmax2 ) [goto :INTERACTION-REJECTED-old:; ]
]
IF( abs(pz) > 1 ) goto :RETRY-PZ-old:;

" Calculate energy of scattered photon "
aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
aux2 = 1-2*br*costhe+br2*(1-pz2*sinthe);
IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
Uj = Uj*prm;

:FINISHED-COMPTON-SAMPLING-old:
pesg = br*peig; pese = peig - pesg - Uj + prm;
sinthe = Sqrt(sinthe);
call uphi(2,1); e(np) = pesg;
aux = 1 + br*br - 2*br*costhe;
IF( aux > 1e-8 ) [
    costhe = (1-br*costhe)/Sqrt(aux);
    sinthe = (1-costhe)*(1+costhe);
    IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
    ELSE [ sinthe = 0; ]
] ELSE [ costhe = 0; sinthe = -1; ]
np = np + 1;
$CHECK-STACK(np,'COMPT');
call uphi(3,2);
e(np) = pese; iq(np) = -1;

IF( ibcmp(irl) = 1 ) [

    " Shell vacancy "
    IF( Uj > 1e-3 ) [
        edep = 0;

        call relax(Uj,shn_array(j),iz_array(j));
          "relax will put all particles with energies above ecut,pcut on the "
          "stack, the remaining energy will be scored in edep and deposited  "
          "localy (via the call to ausgab below)                             "
    ]
    ELSE [ edep = Uj; ]
    IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]

]

" Now play Russian Roulette with resulting electrons if the user asked for it"
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"

return;

:INTERACTION-REJECTED-old:
" Create here a zero energy electron if required (check user codes) "
return;
end;

%E
"******************************************************************"
"                               NATIONAL RESEARCH COUNCIL OF CANADA"
SUBROUTINE ELECTR(IRCODE);
"******************************************************************"
"   This subroutine has been almost completely recoded to include  "
"   the EGSnrc enhancements.                                       "
"                                                                  "
"   Version 1.0   Iwan Kawrakow       Complete recoding            "
"   Version 1.1   Iwan Kawrakow       Corrected implementation of  "
"                                     fictitious method (important "
"                                     for low energy transport     "
"******************************************************************"

$IMPLICIT-NONE;

$INTEGER IRCODE;

$COMIN-ELECTR; "default replacement produces the following:
               "COMIN/DEBUG,BOUNDS,EGS-VARIANCE-REDUCTION, ELECIN,EPCONT,"
                        "ET-Control,MEDIA,MISC,STACK,THRESH,UPHIIN,"
                        "UPHIOT,USEFUL,USER,RANDOM/;"
;COMIN/EII-DATA/;
;COMIN/EM/;
$REAL lambda_max, sigratio, u_tmp, v_tmp, w_tmp;
LOGICAL random_tustep;

$DEFINE-LOCAL-VARIABLES-ELECTR;
/******* trying to save evaluation of range.
$LOGICAL  do_range;
$REAL     the_range;
*/

data ierust/0/;         "To count negative ustep's"

save ierust;

$CALL-USER-ELECTRON;

ircode = 1; "Set up normal return-which means there is a photon
            "with less available energy than the lowest energy electron,
            "so return to shower so it can call photon to follow it.
            "(For efficiency's sake, we like to stay in this routine
            " as long as there are electrons to process. That's why this
            " apparently convoluted scheme of STACK contro is effected.)

irold = ir(np);    "Initialize previous region
                   "(ir() is an integer that is attached to the particle's
                   " phase space. It contains the region
                   " number that the current particle is in.
                   " Np is the stack pointer, it points to where on the
                   " stack the current particle is.)
irl    = irold;    "region number in local variable


$start_new_particle;
" Default replacement for the above is medium = med(irl); "
" This is made a macro so that it can be replaced with a call to a "
" user provided function start_new_particle(); for the C/C++ interface "

:NEWELECTRON:LOOP
[
    "Go once through this loop for each 'new' electron whose charge and
    "energy has not been checked

    lelec = iq(np); "Save charge in local variable
                    "(iq = -1 for electrons, 0 for photons and 1 for positrons)
    qel   = (1+lelec)/2; " = 0 for electrons, = 1 for positrons "
    peie  = e(np);  "precise energy of incident electron (double precision)
    eie   = peie;   "energy incident electron (conversion to single)

    IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
        "(Ecut is the lower transport threshold.)

    "medium = med(irl);" "(This renders the above assignment redundant!)
    "The above assignment is unnecessary, IK, June 2003"

    IF(WT(NP) = 0.0) [go to :USER-ELECTRON-DISCARD:;] "added May 01"

    :TSTEP:LOOP
    [
        "Go through this loop each time we recompute distance to an interaction
        /******* trying to save evaluation of range.
        do_range = .true.; "compute the range in $COMPUTE-RANGE below"
        ********/
        compute_tstep = .true.; "MFP resampled => calculate distance to the
                                "interaction in the USTEP loop
        eke = eie - rm; "moved here so that kinetic energy will be known"
                        "to user even for a vacuum step, IK January 2000"
        IF(medium ~= 0)
        [
            "Not vacuum. Must sample to see how far to next interaction.

            $SELECT-ELECTRON-MFP;
                " Default FOR $SELECT-ELECTRON-MFP; is: $RANDOMSET rnne1;
                "                                       demfp = -log(rnne1);
                "($RANDOMSET is a macro'ed random number generator)
                "(demfp = differential electron mean free path)

            elke = log(eke);
            "(eke = kinetic energy, rm = rest mass, all in units of MeV)
            $SET INTERVAL elke,eke; "Prepare to approximate cross section

            $EVALUATE-SIG0;
               "The fix up of the fictitious method uses cross section per"
               "energy loss. Therefore, demfp/sig is sub-threshold energy loss"
               "until the next discrete interaction occures (see below)"
               "As this quantity is a single constant for a material,"
               "$SET INTERVAL is not necessary at this point. However, to not"
               "completely alter the logic of the TSTEP and USTEP loops,"
               "this is left for now"

        ] "end non-vacuum test

        :USTEP:LOOP
        [
            "Here for each check with user geometry.
            "Compute size of maximum acceptable step, which is limited
            "by multiple scattering or other approximations.
            IF(medium = 0)
            [
                    "vacuum
                    $EMFIELD_INITIATE_SET_TUSTEP;
                    tstep = vacdst; ustep = tstep; tustep = ustep;
                    callhowfar = .true.; "Always call HOWFAR for vacuum steps!"

                    "(Important definitions:
                    " tstep  = total pathlength to the next discrete interaction
                    " vacdst = infinity (actually 10^8)
                    " tustep = total pathlength of the electron step
                    " ustep  = projected transport distance in the
                    "          direction of motion at the start of the step
                    " Note that tustep and ustep are modified below.
                    " The above provide defaults.)

                    " EM field step size restriction in vacuum
                    $SET-TUSTEP-EM-FIELD;
                    ustep = tustep;
            ]
            ELSE
            [
                "non-vacuum
                $SET-RHOF;    "density ratio scaling template
                              "EGS allows the density to vary
                              "continuously (user option)

                $SCALE-SIG0;
                IF(sig <= 0)
                [
                    "This can happen if the threshold for brems,
                    "(ap + rm), is greater than ae.  Moller threshold is
                    "2*ae - rm. If sig is zero, we are below the
                    "thresholds for both bremsstrahlung and Moller.
                    "In this case we will just lose energy by
                    "ionization loss until we go below cut-off. Do not
                    "assume range is available, so just ask for step
                    "same as vacuum.  Electron transport will reduce
                    "into little steps.
                    "(Note: ae is the lower threshold for creation of a
                    "       secondary Moller electron, ap is the lower
                    "       threshold for creation of a brem.)
                    tstep = vacdst;
                    sig0 = 1.E-15;
                ]
                ELSE
                [
                    $CALCULATE-TSTEP-FROM-DEMFP;
                ] "end sig if-else

                "calculate stopping power"
                IF(lelec < 0) [$EVALUATE dedx0 USING ededx(elke);] "e-"
                ELSE          [$EVALUATE dedx0 USING pdedx(elke);] "e+"
                dedx  = rhof*dedx0;

                "Determine maximum step-size (Formerly $SET-TUSTEP)
                $EVALUATE tmxs USING tmxs(elke);
                tmxs = tmxs/rhof;

                "Compute the range to E_min(medium) (e_min is the first
                "energy in the table). Do not go more than range.
                "Don't replace this macro and don't override range, because
                "the energy loss evaluation below relies on the accurate
                "(and self-consistent) evaluation of range!
                $COMPUTE-RANGE;

                "The RANDOMIZE-TUSTEP option as coded by AFB forced the
                "electrons to approach discrete events (Moller,brems etc.)
                "only in a single scattering mode => waste of CPU time.
                "Moved here and changed by IK Oct 22 1997
                random_tustep = $RANDOMIZE-TUSTEP;
                IF(random_tustep)
                [
                    $RANDOMSET rnnotu;
                    tmxs = rnnotu*min(tmxs,smaxir(irl));
                ]
                ELSE
                [
                    tmxs = min(tmxs,smaxir(irl));
                ]
                tustep = min(tstep,tmxs,range);
                $SET-TUSTEP-EM-FIELD; "optional tustep restriction in EM field

                $CALL-HOWNEAR(tperp);
                dnear(np) = tperp;
                $RANGE-DISCARD;       "optional regional range rejection for"
                                      "particles below e_max_rr if i_do_rr set"

                $USER-RANGE-DISCARD;  "default is ;, but user may implement"

                $SET-SKINDEPTH(eke,elke);
                  "This macro sets the minimum step size for a condensed"
                  "history (CH) step. When the exact BCA is used, the minimum"
                  "CH step is determined by efficiency considerations only"
                  "At about 3 elastic MFP's single scattering becomes more"
                  "efficient than CH and so the algorithm switches off CH"
                  "If one of the various inexact BCA's is invoked, this macro"
                  "provides a simple way to include more sophisticated"
                  "decisions about the maximum acceptable approximated CH step"

                tustep = min(tustep,max(tperp,skindepth));
                $EMFIELD_INITIATE_SET_TUSTEP;
                "The transport logic below is determined by the logical
                "variables callhhowfar, domultiple and dosingle
                "
                "There are the following possibilities:
                "
                "   callhowfar = .false.  This indicates that the
                "   ====================  intended step is shorter than tperp
                "                         independent of BCA used
                "  - domultiple = .false. dosingle = .false. and
                "                         callmsdist = .true.
                "       ==> everything has been done in msdist
                "  - domultiple = .true. and dosingle = .false.
                "       ==> should happen only if exact_bca = .false.
                "           indicates that MS remains to be done
                "  - domultiple = .false. and dosingle = .true.
                "       ==> should happen only if exact_bca = .true.
                "           sampled distance to a single scattering event is
                "           shorter than tperp ==> do single scattering at the
                "           end of the step
                "  - domultiple = .true. and dosingle = .true.
                "       ==> error condition, something with the logic is wrong!
                "
                "   callhowfar = .true. This indicates that the intended step
                "   =================== is longer than tperp and forces a
                "                       call to hawfar which returns the
                "                       straight line distance to the boundary
                "                       in the initial direction of motion
                "                       (via a modification of ustep)
                "  - domultiple = .false. and dosingle = .false.
                "       ==> should happen only of exact_bca=.true.
                "           simply put the particle on the boundary
                "  - domultiple = .false. and dosingle = .true.
                "       ==> should happen only of exact_bca=.true.
                "           single elastic scattering has to be done
                "  - domultiple = .true. and dosingle = .false.
                "       ==> should happen only of exact_bca=.false.
                "           indicates that MS remains to be done
                "  - domultiple = .true. and dosingle = .true.
                "       ==> error condition, something with the logic is wrong!

                "IF(tustep <= tperp & tustep > skindepth)"
                "This statement changed to be consistent with PRESTA-I"
                count_all_steps = count_all_steps + 1;
                is_ch_step = .false.;
                IF((tustep <= tperp) & ((~exact_bca) | (tustep > skindepth)))
                [
                    "We are further way from a boundary than a skindepth, so
                    "perform a normal condensed-history step
                    callhowfar = .false.; "Do not call HAWFAR
                    domultiple = .false.; "Multiple scattering done here
                    dosingle   = .false.; "MS => no single scattering
                    callmsdist = .true.;  "Remember that msdist has been called

                    "Fourth order technique for de
                    $COMPUTE-ELOSS-G(tustep,eke,elke,lelke,de);

                    tvstep = tustep; is_ch_step = .true.;

                    IF (transport_algorithm = $PRESTA-II)
                    [
                      call msdist_pII
                      (
                        "Inputs
                        eke,de,tustep,rhof,medium,qel,spin_effects,
                        u(np),v(np),w(np),x(np),y(np),z(np),
                        "Outputs
                        uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
                      );
                    ]
                    ELSE
                    [
                      call msdist_pI
                      (
                        "Inputs
                        eke,de,tustep,rhof,medium,qel,spin_effects,
                        u(np),v(np),w(np),x(np),y(np),z(np),
                        "Outputs
                        uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
                      );
                    ]
                ]
                ELSE
                [
                    "We are within a skindepth from a boundary, invoke
                    "one of the various boundary-crossing algorithms
                    callmsdist = .false.;
                         "Remember that msdist has not been called
                    IF (exact_bca)
                    [
                        "Cross the boundary in a single scattering mode
                        domultiple = .false.; "Do not do multiple scattering
                        "Sample the distance to a single scattering event
                        $RANDOMSET rnnoss;
                        IF( rnnoss < 1.e-30 ) [
                            rnnoss = 1.e-30;
                        ]
                        lambda = - Log(1 - rnnoss);
                        lambda_max = 0.5*blccl*rm/dedx*(eke/rm+1)**3;
                        IF( lambda >= 0 & lambda_max > 0 ) [
                            IF( lambda < lambda_max ) [
                                tuss=lambda*ssmfp*(1-0.5*lambda/lambda_max);
                            ]
                            ELSE [
                              tuss = 0.5 * lambda * ssmfp;
                            ]
                            IF (tuss < tustep) [
                                tustep = tuss;
                                dosingle = .true.;
                            ]
                            ELSE [
                                dosingle = .false.;
                            ]
                        ]
                        ELSE [
                          $egs_warning(*,' lambda > lambda_max: ',
                             lambda,lambda_max,' eke dedx: ',eke,dedx,
                             ' ir medium blcc: ',ir(np),medium,blcc(medium),
                             ' position = ',x(np),y(np),z(np));
                          dosingle = .false.;
                          np=np-1; return;
                        ]
                        ustep = tustep;
                    ]
                    ELSE
                    [
                        "Boundary crossing a la EGS4/PRESTA-I but using
                        "exact PLC
                        dosingle = .false.;
                        domultiple = .true.;
                        $SET-USTEP;
                    ]
                    IF(ustep < tperp)
                    [
                        callhowfar = .false.;
                    ]
                    ELSE
                    [
                        callhowfar = .true.;
                    ]
                ]
            ] "end non-vacuum test

            $SET-USTEP-EM-FIELD;  "additional ustep restriction in em field
                                  "default for $SET-USTEP-EM-FIELD; is ;(null)
            irold  = ir(np); "save current region
            irnew  = ir(np); "default new region is current region
            idisc  = 0; "default is no discard (this flag is initialized here)
            ustep0 = ustep; "Save the intended ustep."

            "IF(callhowfar) [ call howfar; ]"
            $CALL-HOWFAR-IN-ELECTR; "The above is the default replacement"

            "Now see if user requested discard
            IF(idisc > 0) "(idisc is returned by howfar)
            [
                "User requested immediate discard
                go to :USER-ELECTRON-DISCARD:;
            ]

            $CHECK-NEGATIVE-USTEP;

            IF(ustep = 0 | medium = 0)
            [
                "Do fast step in vacuum
                IF(ustep ~= 0)
                [
                    IF $EM_MACROS_ACTIVE
                    [
                        edep = pzero; "no energy loss in vacuum
                        "transport in EMF in vacuum:"
                        "only a B or and E field can be active"
                        "(not both at the same time)"
                        $EMFieldInVacuum;
                    ]
                    ELSE
                    [
                        "Step in vacuum
                        vstep  = ustep;
                        tvstep = vstep;
                        "( vstep is ustep truncated (possibly) by howfar
                        " tvstep is the total curved path associated with vstep)
                        edep = pzero; "no energy loss in vacuum
                        $VACUUM-ADD-WORK-EM-FIELD;
                            "additional vacuum transport in em field
                        e_range = vacdst;
                        $AUSCALL($TRANAUSB);
                        "Transport the particle
                        x(np) = x(np) + u(np)*vstep;
                        y(np) = y(np) + v(np)*vstep;
                        z(np) = z(np) + w(np)*vstep;
                        dnear(np) = dnear(np) - vstep;
                            "(dnear is distance to the nearest boundary
                            " that goes along with particle stack and
                            " which the user's howfar can supply (option)
                        $SET-ANGLES-EM-FIELD;
                            "default for $SET-ANGLES-EM-FIELD; is ; (null)
                             "(allows for EM field deflection
                    ] "end of EM_MACROS_ACTIVE block"
                ] "end of vacuum step

                IF(irnew ~= irold) [ $electron_region_change; ];

                IF(ustep ~= 0) [$AUSCALL($TRANAUSA);]
                IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
                IF(ustep ~= 0 & idisc < 0) [go to :USER-ELECTRON-DISCARD:;]
                NEXT :TSTEP: ; "(Start again at :TSTEP:)

            ] "Go try another big step in (possibly) new medium

            vstep = ustep;
            $EM_FIELD_SS;
            IF(callhowfar)
            [
                IF(exact_bca)
                [
                    "If callhowfar=.true. and exact_bca=.true. we are"
                    "in a single scattering mode"
                    tvstep = vstep;
                    IF(tvstep ~= tustep)
                    [
                       "Boundary was crossed. Shut off single scattering"
                        dosingle = .false.;
                    ]
                ]
                ELSE
                [
                    "callhowfar=.true. and exact_bca=.false."
                    "=>we are doing an approximate CH step"
                    "calculate the average curved path-length corresponding"
                    "to vstep"
                    $SET-TVSTEP;
                ]
                "Fourth order technique for dedx
                "Must be done for an approx. CH step or a
                "single scattering step.
                $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
            ]
            ELSE
            [
               "callhowfar=.false. => step has not been reduced due to
               "                      boundaries
               tvstep = tustep;
               IF ( ~callmsdist )
               [
                  "Second order technique for dedx
                  "Already done in a normal CH step with call to msdist
                  $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
               ]
            ]

            $SET-TVSTEP-EM-FIELD; "additional path length correction in em field
                "( Calculates tvstep given vstep
                " default for $SET-TVSTEP-EM-FIELD; is ; (null)

            save_de = de;     "the energy loss is used to calculate the number
                              "of MFP gone up to now. If energy loss
                              "fluctuations are implemented, de will be
                              "changed in $DE-FLUCTUATION; => save

            "The following macro template allows the user to change the
            "ionization loss.
            "(Provides a user hook for Landau/Vavilov processes)
            $DE-FLUCTUATION;
                "default for $DE-FLUCTUATION; is ; (null)
            edep = de; "energy deposition variable for user
            $ADD-WORK-EM-FIELD;  "e-loss or gain in em field
            $ADD_WORK_EM_FIELD;  "EEMF implementation"
                "Default for $ADD-WORK-EM-FIELD; is ; (null)
            ekef = eke - de;  "(final kinetic energy)
            eold = eie;       "save old value
            enew = eold - de; "energy at end of transport

            "Now do multiple scattering
            IF ( ~callmsdist )   "everything done if callmsdist = .true.
            [
                IF ( domultiple )
                [
                    "Approximated CH step => do multiple scattering
                    "
                    "ekems, elkems, beta2 have been set in either $SET-TUSTEP
                    "or $SET-TVSTEP if spin_effects is .true., they are
                    "not needed if spin_effects is .false.
                    "
                    "chia2,etap,xi,xi_corr are also set in the above macros
                    "
                    "qel (0 for e-, 1 for e+) and medium are now also required
                    "(for the spin rejection loop)
                    "
                    lambda = blccl*tvstep/beta2/etap/(1+chia2);
                    xi = xi/xi_corr;
                    findindex = .true.; spin_index = .true.;
                    call mscat(lambda,chia2,xi,elkems,beta2,qel,medium,
                               spin_effects,findindex,spin_index,
                               costhe,sinthe);
                ]
                ELSE
                [
                    IF(dosingle)
                    [
                       "Single scattering

                       ekems = Max(ekef,ecut(irl)-rm);
                       p2 = ekems*(ekems + rmt2);
                       beta2 = p2/(p2 + rmsq);
                       chia2 = xcc(medium)/(4*blcc(medium)*p2);
                       IF( spin_effects ) [
                         elkems = Log(ekems);
                         $SET INTERVAL elkems,eke;
                         IF(lelec < 0) [$EVALUATE etap USING etae_ms(elkems);]
                         ELSE          [$EVALUATE etap USING etap_ms(elkems);]
                         chia2 = chia2*etap;
                       ]
                       call sscat(chia2,elkems,beta2,qel,medium,
                                  spin_effects,costhe,sinthe);
                    ]
                    ELSE
                    [
                       theta  = 0; "No deflection in single scattering model
                       sinthe = 0;
                       costhe = 1;
                    ]
                ]
            ]

            "We now know distance and amount of energy loss for this step,
            "and the angle by which the electron will be scattered. Hence,
            "it is time to call the user and inform him of this transport,
            "after which we will do it.

            "Now transport, deduct energy loss, and do multiple scatter.
            e_range = range;
            /******* trying to save evaluation of range.
            the_range = the_range - tvstep*rhof;
            ********/

            /*
               Put expected final position and direction in common
               block variables so that they are available to the
               user for things such as scoring on a grid that is
               different from the geometry grid
            */
            IF( callmsdist ) [
               "Deflection and scattering have been calculated/sampled in msdist
                u_final = uscat;
                v_final = vscat;
                w_final = wscat;
                x_final = xtrans;
                y_final = ytrans;
                z_final = ztrans;
            ]
            ELSE
            [
                IF ~($EM_MACROS_ACTIVE)
                [
                    x_final = x(np) + u(np)*vstep;
                    y_final = y(np) + v(np)*vstep;
                    z_final = z(np) + w(np)*vstep;
                ]

                IF ( domultiple | dosingle )
                [
                    u_tmp = u(np); v_tmp = v(np); w_tmp = w(np);
                    call uphi(2,1); "Apply the deflection, save call to uphi if
                                    "no deflection in a single scattering mode
                    u_final = u(np); v_final = v(np); w_final = w(np);
                    u(np) = u_tmp; v(np) = v_tmp; w(np) = w_tmp;
                ]
                ELSE [ u_final = u(np); v_final = v(np); w_final = w(np); ]
            ]

            $AUSCALL($TRANAUSB);

            "Transport the particle

            x(np) = x_final; y(np) = y_final; z(np) = z_final;
            u(np) = u_final; v(np) = v_final; w(np) = w_final;

            dnear(np) = dnear(np) - vstep;
            irold = ir(np); "save previous region
            $SET-ANGLES-EM-FIELD;
            "Default for $SET-ANGLES-EM-FIELD; is ; (null)


            "Now done with multiple scattering,
            "update energy and see if below cut
            "below subtracts only energy deposited"
            peie  = peie - edep;
            "below subtracts energy deposited + work due to E field"
            "peie = peie - de;"
            eie   = peie;
            e(np) = peie;

            "IF( irnew ~= irl & eie <= ecut(irl)) [
            "IK: the above is clearly a bug. If the particle energy falls "
            "    below ecut, but the particle is actually entering a new "
            "    region, the discard will happen in the current region "
            "    instead the next. If the particle is a positron, all "
            "    resulting annihilation photons will have the new position "
            "    but the old region => confusion in the geometry routine "
            "    is very likely.      Jan 27 2004 "
            IF( irnew = irl & eie <= ecut(irl)) [
               go to :ECUT-DISCARD:;
            ]

            medold = medium;
            IF(medium ~= 0)
            [
                ekeold = eke; eke = eie - rm; "update kinetic energy
                elke   = log(eke);
                $SET INTERVAL elke,eke; "Get updated interval
            ]

            IF(irnew ~= irold) [ $electron_region_change; ]

            "After transport call to user scoring routine
            $AUSCALL($TRANAUSA);

            IF(eie <= ecut(irl)) [
               go to :ECUT-DISCARD:;
            ]

            "Now check for deferred discard request.  May have been set
            "by either howfar, or one of the transport ausgab calls
            IF(idisc < 0) [
              go to :USER-ELECTRON-DISCARD:;
            ]

            IF(medium ~= medold) NEXT :TSTEP:;

            $USER_CONTROLS_TSTEP_RECURSION;
                "NRCC update 87/12/08--default is null

            $UPDATE-DEMFP;

        ] UNTIL(demfp < $EPSEMFP); "end ustep loop

        "Compute final sigma to see if resample is needed.
        "this will take the energy variation of the sigma into
        "account using the fictitious sigma method.

        $EVALUATE-SIGF;

        sigratio = sigf/sig0;

        $RANDOMSET rfict;

    ] UNTIL (rfict <= sigratio) ; "end tstep loop

    " Now sample electron interaction

    IF(lelec < 0)
    [
        "e-,check branching ratio
        $EVALUATE-EBREM-FRACTION;
          "Default is $EVALUATE ebr1 USING ebr1(elke);"
        $RANDOMSET rnno24;
        IF(rnno24 <= ebr1)
        [
            "It was bremsstrahlung
            go to :EBREMS:;
        ]
        ELSE
        [
            "It was Moller, but first check the kinematics.
            "However, if EII is on, we should still permit an interaction
            "even if E<moller threshold as EII interactions go down to
            "the ionization threshold which may be less than thmoll.
            IF(e(np) <= thmoll(medium) & eii_flag = 0)
                 "(thmoll = lower Moller threshold)
            [
                "Not enough energy for Moller, so
                "force it to be a bremsstrahlung---provided ok kinematically.
                IF(ebr1 <= 0) [go to :NEWELECTRON:;]
                    "Brems not allowed either.
                go to :EBREMS:;
            ]
            $AUSCALL($MOLLAUSB);
            call moller;
            "The following macro template allows the user to change the
            "particle selection scheme (e.g., adding importance sampling
            "such as splitting, leading particle selection, etc.).
            "(Default macro is template '$PARTICLE-SELECTION-ELECTR'
            "which in turn has the 'null' replacement ';')
            $PARTICLE-SELECTION-MOLLER;
            $AUSCALL($MOLLAUSA);
            IF( iq(np) = 0 ) return;
        ]

        go to :NEWELECTRON:; "Electron is lowest energy-follow it
    ]

    "e+ interaction. pbr1 = brems/(brems + bhabha + annih
    $EVALUATE-PBREM-FRACTION;
       "Default is $EVALUATE pbr1 USING pbr1(elke);"
    $RANDOMSET rnno25;
    IF(rnno25 < pbr1) [go to :EBREMS:;] "It was bremsstrahlung
    "Decide between bhabha and annihilation
    "pbr2 is (brems + bhabha)/(brems + bhabha + annih)
    $EVALUATE-BHABHA-FRACTION;
       "Default is $EVALUATE pbr2 USING pbr2(elke);"
    IF(rnno25 < pbr2)
    [
        "It is bhabha
        $AUSCALL($BHABAUSB);
        call bhabha;
        "The following macro template allows the user to change the
        "particle selection scheme (e.g., adding importance sampling
        "such as splitting, leading particle selection, etc.).  (default
        "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
        "has the 'null' replacement ';')
        $PARTICLE-SELECTION-BHABHA;
        $AUSCALL($BHABAUSA);
        IF( iq(np) = 0 ) return;
    ]
    ELSE
    [
        "It is in-flight annihilation
        $AUSCALL($ANNIHFAUSB);
        call annih;
        "The following macro template allows the user to change the
        "particle selection scheme (e.g., adding importance sampling
        "such as splitting, leading particle selection, etc.).  (default
        "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
        "has the 'null' replacement ';')
        $PARTICLE-SELECTION-ANNIH;
        $AUSCALL($ANNIHFAUSA);
        EXIT :NEWELECTRON:; "i.e., in order to return to shower
        "After annihilation the gammas are bound to be the lowest energy
        "particles, so return and follow them.
    ] "end pbr2 else

] REPEAT "newelectron

return; "i.e., return to shower


"---------------------------------------------
"Bremsstrahlung-call section
"---------------------------------------------
:EBREMS:
$AUSCALL($BREMAUSB);
call brems;
"The following macro template allows the user to change the particle
"selection scheme (e.g., adding importance sampling such as splitting,
"leading particle selection, etc.).  (default macro is template
"'$PARTICLE-SELECTION-ELECTR' which in turn has the 'null' replacement ';')
$PARTICLE-SELECTION-BREMS;
$AUSCALL($BREMAUSA);
IF(iq(np) = 0)
[
    "Photon was selected.
    return;
    "i.e., return to shower
]
ELSE
[
    "Electron was selected
    go to :NEWELECTRON:;
]

"---------------------------------------------
"Electron cutoff energy discard section
"---------------------------------------------
:ECUT-DISCARD:
IF( medium > 0 ) [
    IF(eie > ae(medium)) [
        idr = $EGSCUTAUS;
        IF(lelec < 0) [edep = e(np) - prm;] ELSE[$POSITRON-ECUT-DISCARD;]
    ]
    ELSE [ idr = $PEGSCUTAUS; edep = e(np) - prm; ]
] ELSE [idr = $EGSCUTAUS; edep = e(np) - prm; ]


$ELECTRON-TRACK-END; "The default replacement for this macros is "
                     "          $AUSCALL(idr);                   "
                     "Use this macro if you wish to modify the   "
                     "treatment of track ends                    "

:POSITRON-ANNIHILATION:; "NRCC extension 86/9/12

IF(lelec > 0) [
    "It's a positron. Produce annihilation gammas if edep < peie
    IF(edep < peie) [
        $AUSCALL($ANNIHRAUSB);
        call annih_at_rest;
        $PARTICLE-SELECTION-ANNIHREST;
        $AUSCALL($ANNIHRAUSA);
        "Now discard the positron and take normal return to follow
        "the annihilation gammas.
        return; "i.e., return to shower
    ]
] "end of positron block

np = np - 1;
ircode = 2; "tell shower an e- or un-annihilated
            "e+ has been discarded

return; "i.e., return to shower"

"---------------------------------------------
"User requested electron discard section
"---------------------------------------------
:USER-ELECTRON-DISCARD:

idisc = abs(idisc);

IF((lelec < 0) | (idisc = 99))[edep = e(np) - prm;]
ELSE                          [edep = e(np) + prm;]

$AUSCALL($USERDAUS);

IF(idisc = 99) goto :POSITRON-ANNIHILATION:;

np = np - 1; ircode = 2;

return; "i.e., return to shower
end;    "End of subroutine electr
"*******************************************************************************


%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE HATCH;
"                                                                  "
"******************************************************************"
"   Setup which the user is expected to do before calling HATCH is:"
"     1. SET 'NMED' TO THE NUMBER OF MEDIA TO BE USED."
"     2. SET THE ARRAY 'MEDIA', WHICH CONTAINS THE NAMES OF THE"
"        MEDIA THAT ARE DESIRED.  THE CHARACTER FORMAT IS A1, SO"
"        THAT MEDIA(IB,IM) CONTAINS THE IB'TH BYTE OF THE NAME OF"
"        THE IM'TH MEDIUM IN A1 FORMAT."
"     3. SET 'DUNIT', THE DISTANCE UNIT TO BE USED."
"        DUNIT.GT.0 MEANS VALUE OF DUNIT IS LENGTH OF DISTANCE UNIT"
"        CENTIMETERS.  DUNIT.LT.0 MEANS USE THE RADIATION LENGTH OF"
"        THE ABS(DUNIT)'TH MEDIUM FOR THE DISTANCE UNIT."
"     4. FILL THE ARRAY 'MED' WITH THE MEDIUM INDICES FOR THE"
"        REGIONS."
"     5. FILL ARRAYS 'ECUT' AND 'PCUT' WITH THE ELECTRON AND PHOTON"
"        CUT-OFF ENERGIES FOR EACH REGION RESPECTIVELY.  SETUP WILL"
"        RAISE THESE IF NECESSARY TO MAKE THEM AT LEAST AS LARGE AS"
"        THE REGION'S MEDIUM'S AE AND AP RESPECTIVELY."
"     6. FILL 'MED' ARRAY.  MED(IR) IS THE MEDIUM INDEX FOR REGION"
"        IR.  A ZERO MEDIUM INDEX MEANS THE REGION IS IN A VACUUM."
"     7. FILL THE ARRAY 'IRAYLR' WITH 1 FOR EACH REGION IN WHICH"
"        RAYLEIGH (COHERENT) SCATTERING IS TO BE INCLUDED."
"
"   KMPO = 8 and KMPI = 12 are set in BLOCK DATA"
"   The echo to unit 8 has been removed since it is sent"
"                                          to /dev/null anyway!"
"           To put it back search $UOUTPUT  and $ECHO and uncomment"
"******************************************************************"

$IMPLICIT-NONE;

character*512 toUpper;
$COMIN-HATCH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,BOUNDS,BREMPR,EGS-VARIANCE-REDUCTION,"
                      "ELECIN,MEDIA,MISC,PHOTIN,STACK,
                      "THRESH,UPHIIN,UPHIOT,USEFUL,USER,RANDOM/;

$DECLARE-PEGS4-COMMON-BLOCKS;

$DEFINE-LOCAL-VARIABLES-HATCH;

character*256 tmp_string;
$INTEGER      lnblnk1;" in house lnblnk function becuase not all compilers"
                      " support this"

DATA MDLABL/$S' MEDIUM='/,LMDL/8/,LMDN/24/,DUNITO/1./;
DATA I1ST/1/,NSINSS/37/,MXSINC/$MXSINC/,ISTEST/0/,NRNA/1000/;

$INIT-PEGS4-VARIABLES;

"   FORMAT STATEMENTS USED MULTIPLE TIMES IN SETUP"
:INT:FORMAT(1X,14I5);
:FLT:FORMAT(1X,1PE14.5,4E14.5);
:BYTE:FORMAT(72A1);

IF (I1ST.NE.0)[ I1ST=0;"RESET FIRST TIME FLAG"
"   DO FIRST TIME INITIALIZATION"

$HATCH-USER-INPUT-INIT;

"   NOW CONSTRUCT PIECEWISE LINEAR FIT TO SINE FUNCTION OVER THE"
"   INTERVAL (0,5*PI/2).  DIVIDE THIS INTERVAL INTO MXSINC SUB-"
"   INTERVALS.  EACH OF THESE SUBINTERVALS IS THEN SUBDIVIDED INTO"
"   NSINSS SUB-SUB-INTERVALS.  THE ANGLES AT THE BOUNDARIES OF"
"   THESE SUB-SUB-INTERVALS AND THEIR SINES ARE USED TO COMPUTE"
"   LEAST SQUARES COEFFICIENTS FOR THE SUBINTERVAL.  AN EXTRA"
"   SUBINTERVAL ON EACH SIDE OF THE INTERVAL (0,5*PI/2) IS INCLUDED"
"   FOR GOOD MEASURE."
NISUB=MXSINC-2;FNSSS=NSINSS;
WID=PI5D2/FLOAT(NISUB);
WSS=WID/(FNSSS-1.0);
ZEROS(1)=0.;ZEROS(2)=PI; ZEROS(3)=TWOPI;

DO ISUB=1,MXSINC ["LOOP OVER SUBINTERVALS"
SX=0.;SY=0.;SXX=0.;SXY=0.;"ZERO SUMS"

XS0=WID*FLOAT(ISUB-2);XS1=XS0+WID;"LOWER & UPPER LIMITS"
"   NOW CHECK TO SEE IF ANY ZEROS ARE IN THE INTERVAL"
IZ=0; DO IZZ=1,3 [
IF ((XS0.LE.ZEROS(IZZ)).AND.(ZEROS(IZZ).LE.XS1))[IZ=IZZ;EXIT;]
] "END OF LOOP OVER ZEROS"
IF (IZ.EQ.0)[XSI=XS0;]ELSE[XSI=ZEROS(IZ);]
DO ISS=1,NSINSS ["LOOP OVER SUB-SUBINTERVALS"
XS=WID*FLOAT(ISUB-2)+WSS*FLOAT(ISS-1)-XSI; "ANGLE VALUE"
YS=SIN(XS+XSI); "SINE OF ANGLE"
SX=SX+XS; "ACCUMULATE SUMS"
SY=SY+YS;
SXX=SXX+XS*XS;
SXY=SXY+XS*YS;
] "END SUB-SUBINTERVAL LOOP"

"   NOW COMPUTE LEAST SQUARES COEFFICIENTS"
IF (IZ.NE.0)["FORCE FIT THROUGH SINES' ZEROS,"
"             FOR SMALL REL.ERR.&GOOD"
"   VALUES OF SINTHE/THETA NEAR ZERO"
SIN1(ISUB)=SXY/SXX;
SIN0(ISUB)=-SIN1(ISUB)*XSI;]
ELSE["DO FULL LEAST SQUARES"
DEL=FNSSS*SXX-SX*SX;
SIN1(ISUB)=(FNSSS*SXY-SY*SX)/DEL;
SIN0(ISUB)=(SY*SXX-SX*SXY)/DEL - SIN1(ISUB)*XSI ; ]
] "END SUB-INTERVAL LOOP"

SINC0=2.0 ;"SET COEFFICIENTS WHICH DETERMINE INTERVAL"
SINC1=1.0/WID;

"   NOW TEST FIT, IF REQUESTED"
IF (ISTEST.NE.0)[
"   FIRST TEST AT POINTS PREVIOUSLY COMPUTED, EXCLUDING"
"   END SUBINTERVALS"
ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
DO ISUB=1,NISUB [ DO ISS=1,NSINSS [
THETA=WID*FLOAT(ISUB-1)+WSS*FLOAT(ISS-1);
CTHET=PI5D2-THETA;
$SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
$EVALUATE SINTHE USING SIN(THETA);
$EVALUATE COSTHE USING SIN(CTHET);
SINT=SIN(THETA); COST=COS(THETA);
ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
ADEV=max(ADEV,ASD,ACD);
IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
S2C2=SINTHE**2+COSTHE**2;
S2C2MN=min(S2C2MN,S2C2);
S2C2MX=max(S2C2MX,S2C2);
IF (ISUB.LT.11)[$egs_info('(1PE20.7,4E20.7)',THETA,SINTHE,SINT,COSTHE,COST);]
] ] "END OF FIXED INTERVAL TEST-OUTPUT RESULTS"
$egs_info('(a,2i5)',' SINE TESTS,MXSINC,NSINSS=',MXSINC,NSINSS);
$egs_info('(a,1PE16.8,3e16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
                                 ADEV,RDEV,S2C2MN,S2C2MX);
"   NOW DO RANDOM TEST"
ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
DO IRN=1,NRNA[ $RANDOMSET THETA;THETA=THETA*PI5D2;
CTHET=PI5D2-THETA;
$SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
$EVALUATE SINTHE USING SIN(THETA);
$EVALUATE COSTHE USING SIN(CTHET);
SINT=SIN(THETA); COST=COS(THETA);
ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
ADEV=max(ADEV,ASD,ACD);
IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
S2C2=SINTHE**2+COSTHE**2;
S2C2MN=min(S2C2MN,S2C2);
S2C2MX=max(S2C2MX,S2C2);
] "END RANDOM ANGLE LOOP"
$egs_info('(a,i7,a)', ' TEST AT ',NRNA,' RANDOM ANGLES IN (0,5*PI/2)');
$egs_info('(1PE16.8,3E16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
                               ADEV,RDEV,S2C2MN,S2C2MX);
] "END OF SINE TABLE TEST"

"   NOW FILL IN POWER OF TWO TABLE.  PWR2I(I)=1/2**(I-1)"
P=1.; DO I=1,$MXPWR2I [PWR2I(I)=P; P=P/2.;]

] "END OF FIRST TIME INITIALIZATION"

"FILL IRAYLM ARRAY BASED ON IRAYLR INPUTS"
$need_rayleigh_data;

"Ali:photonuc, 2 lines"
"FILL IPHOTONUCM ARRAY BASED ON IPHOTONUCR INPUTS"
$need_photonuc_data;
$egs_info('(a,i3)',' ===> Photonuclear flag: ', iphotonuc);

"   NOW SEARCH FILE FOR DATA FOR REQUESTED MATERIALS"
IF(~is_pegsless) REWIND KMPI;
"explicit file name for HP compiler  Nov 23, 1996   DR"
IUECHO=KMPO;
NM=0; "NUMBER OF MEDIA FOUND"
DO IM=1,NMED [LOK(IM)=0;"SET FLAG TELLING WHICH MEDIA ARE OK"
  "NOW TELL USER IF RAYLEIGH OPTION HAS BEEN REQUESTED"
  IF(IRAYLM(IM).EQ.1) [
     $egs_info('(a,i3/)', ' RAYLEIGH OPTION REQUESTED FOR MEDIUM NUMBER',IM);
  ]
]

"Ali:photonuc, 1 block"
DO IM=1,NMED [
  "TELL USER IF PHOTONUC HAS BEEN REQUESTED"
  IF(IPHOTONUCM(IM).EQ.1) [
     $egs_info('(a,i3/)', ' PHOTONUCLEAR REQUESTED FOR MEDIUM NUMBER',IM);
  ]
]

IF(~is_pegsless)[
:MEDIUM:
LOOP["MEDIUM SEARCH LOOP"

:MDLOOK:
LOOP["MEDIUM HEADER SEARCH LOOP"
  "   FIRST LOOK FOR MEDIUM HEADER"
  READ(KMPI,:BYTE:,END=:MDNOMORE:)MBUF;
  DO IB=1,LMDL [IF (MBUF(IB).NE.MDLABL(IB))NEXT:MDLOOK:;]
  "   HEADER MATCHES. NOW SEE IF IT IS ONE OF REQUESTED MEDIA"
  :MDNAME:
  DO IM=1,NMED [
    DO IB=1,LMDN [IL=LMDL+IB; IF (MBUF(IL).NE.MEDIA(IB,IM))NEXT:MDNAME:;
    IF (IB.EQ.LMDN)EXIT:MDLOOK:; ]
  ] "END :MDNAME: DO"
  "   NOT IN NAME TABLE, SO IGNORE IT"
]REPEAT "MDLOOK"

"   'IM' IS THE INDEX OF THE MEDIUM READY TO BE READ"
IF (LOK(IM).NE.0)GO TO :MDLOOK:;"WE ALREADY HAVE THIS ONE"
LOK(IM)=1;NM=NM+1;"SET FOUND FLAG AND STEP MEDIUM COUNTER"

"   NOW READY TO READ IN DATA FOR THIS MEDIUM"
"$UOUTPUT(KMPO)IM,MBUF;(' DATA FOR MEDIUM #',I3,', WHICH IS:',72A1);"

"   NOW PUT OUT LINES SHOWING COMPOSITION OF MEDIUM"
"THE FOLLOWING LINE WAS CHANGED TO STORE THE ELEMENTAL COMPOSITION AFB 88/05/31"
"$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NE;"
"The next two lines were line prior to Dec 89 mods to get IUNRST"
"$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
"(5A1,5X,F11.0,4X,I2);"
"following used to pick up IUNRST, IAPRIM and EPSTFL"
"Problem is that GASP may or may not be printed, so we make"
"a kludge which will work with all old data files"
"FIRST WE ASSUME THERE IS NO GASP VALUE IN THE LINE"
"Note that this reading scheme counts on there being an"
"error when GASP does exist on the line--an error does"
"occur on most compilers, however, we have found that on"
"the rs6000 an error does not occur.  Instead, a warning"
"is printed out and IUNRST,EPSTFL and IAPRIM are set to 0."
"This will make no difference in simulations but will cause"
"a problem when running EXAMIN"

" IK: backspace(kmpi) fails under windows using g77 with I/O error"
"     therefore we read the line in a temporary string and then "
"     use memoty I/O to try to read with and without gasp there. "

read(kmpi,'(a)',err=:hatch_read_error1:) tmp_string;
goto :no_hatch_read_error1:;
:hatch_read_error1:
$egs_fatal(*,'Error while reading pegs4 file');

:no_hatch_read_error1:;
read(tmp_string,1,ERR=:GASP-THERE:)
"READ(KMPI,1,ERR=:GASP-THERE:)"
(MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),IAPRIM(IM);
1   FORMAT(5A1,5X,F11.0,4X,I2,9X,I1,9X,I1,9X,I1);
"IUNRST, EPSTFL AND IAPRIM ARE STORED IN COMIN ELECIN"
GO TO :GASP-NOT-THERE:;

:GASP-THERE:;
"WE MUST REREAD THE LINE WITH THE CORRECT FORMAT"
"BACKSPACE(KMPI);""THIS BACKS UP ONE RECORD TO RE-READ IT"
"READ(KMPI,2)"

"The following output is only there because without it"
"code compiled with the new gfortran GNU compiler "
"fails with run time error. Another bug in their "
"pre-alpha quality I/O system ----IK, Oct 26 2005 "
"write(6,*) 'Found medium with gas pressure';"
$egs_info(*,'Found medium with gas pressure');
read(tmp_string,2)
(MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),
IAPRIM(IM);
2     FORMAT(5A1,5X,F11.0,4X,I2,26X,I1,9X,I1,9X,I1);

:GASP-NOT-THERE:

"THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
"$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NE;"
";$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
"(5A1,',RHO=',1PG11.4,',NE=',I2,',COMPOSITION IS :');"
"THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
"DO IE=1,NE["
DO IE=1,NNE(IM)[
    "THE FOLLOWING LINE, COMMENTED OUT, WAS THE OLD WAY OF READING IN "
    "THE ELEMENTAL COMPOSITION OF EACH MEDIUM. THE INFORMATION WAS NOT"
    "PASSED ON TO EGS. IN THE PRESENT VERSION IT IS READ IN AND STORED"
    "IN COMMON BREMPR. AFB 88/05/31.                                  "
    "READ(KMPI,:BYTE:)MBUF;WRITE(KMPO,:BYTE:)MBUF;"
    $UINPUT(KMPI)
    (MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),
    ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);
    (6A1,2A1,3X,F3.0,3X,F9.0,4X,F12.0,6X,F12.0);
    "$UOUTPUT(KMPO)"
    "(MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),"
    "ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);"
    "(6A1,2A1,',Z=',F3.0,',A=',F9.3,',PZ=',1PE12.5,',RHOZ=',1PE12.5);"
    ]

"   MEDIA AND THRESH"
"$ECHO" READ(KMPI,:FLT:) $LGN(RLC,AE,AP,UE,UP(IM));
TE(IM)=AE(IM)-RM; THMOLL(IM)=TE(IM)*2. + RM ;

"   ACTUAL ARRAY SIZES FROM PEGS"
"$ECHO" READ(KMPI,:INT:)
$LGN(MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE(IM)),IRAYL;
NSGE=MSGE(IM);NGE=MGE(IM);NSEKE=MSEKE(IM);NEKE=MEKE(IM);
NLEKE=MLEKE(IM);NCMFP=MCMFP(IM);NRANGE=MRANGE(IM);

"   BREMPR"
"$ECHO" READ(KMPI,:FLT:)($LGN(DL(I,IM)/1,2,3,4,5,6/),I=1,6);
"$ECHO" READ(KMPI,:FLT:)DELCM(IM),($LGN(ALPHI,BPAR,
   DELPOS(I,IM)),I=1,2);

"   ELECIN"
"$ECHO" READ(KMPI,:FLT:)$LGN(XR0,TEFF0,BLCC,XCC(IM));
"$ECHO" READ(KMPI,:FLT:)$LGN(EKE(IM)/0,1/);
"$ECHO" READ(KMPI,:FLT:)
($LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,
   TMXS(I,IM)/0,1/),I=1,NEKE);

"   PHOTIN"
"$ECHO" READ(KMPI,:FLT:)EBINDA(IM),$LGN(GE(IM)/0,1/);
"$ECHO" READ(KMPI,:FLT:)($LGN(GMFP,GBR1,GBR2(I,IM)/0,1/),I=1,NGE);

"   PHOTIN (CONTINUED)---OPTIONAL RAYLEIGH SCATTERING INPUT"

/* Leave this for compatibility with existing pegs4 data sets.  */
IF (IRAYL.EQ.1) [
"$ECHO" READ(KMPI,:INT:) NGR(IM);
NGRIM=NGR(IM);
"$ECHO" READ(KMPI,:FLT:)$LGN(RCO(IM)/0,1/);
"$ECHO" READ(KMPI,:FLT:)($LGN(RSCT(I,IM)/0,1/),I=1,NGRIM);
"$ECHO" READ(KMPI,:FLT:)($LGN(COHE(I,IM)/0,1/),I=1,NGE);
 "IF(IRAYLM(IM).NE.1) ["
 $egs_info('(a,i3,a)', ' Rayleigh data available for medium',
          IM, ' in PEGS4 data set.');
 "]"
]

/*******************************************************************
 Rayleigh data picked up directly from pgs4form.data or user-supplied
 ff file in egs_init_rayleigh unless user wants to use PEGS4 data.
*********************************************************************/
IF(IRAYLM(IM).EQ.1) ["Rayleigh data requested for medium IM"
  IF(IRAYL.NE.1) ["No data in PEGS4"
    IF(toUpper($cstring(photon_xsections))='PEGS4')
    ["Rayleigh not possible"
     $egs_fatal('(a,i3 /,a /,a)',
     ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
     IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.',
     ' YOU WILL NOT BE ABLE TO USE THE PEGS4 DATA WITH RAYLEIGH ON!');
    ]
    ELSE["Data will be taken from elsewhere (si,epdl,xcom,custom)"
     $egs_warning('(a,i3 /,a)',
     ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
     IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.');
    ]
  ]
 ELSE["Rayleigh data in PEGS4"
    IF(toUpper($cstring(photon_xsections))='PEGS4')
    ["PEGS4 data selected"
      "***********************************************************"
      "Preparing data for new Rayleigh angular sampling when using"
      "the pegs4 data set,                                        "
      "***********************************************************"
       call egs_init_rayleigh_sampling(IM);
    ]
    "ELSE[Taking photon data from either si,epdl,xcom or user]"
  ]
]
/*******************************************************************/

"   THAT'S ALL FOR THIS MEDIUM"
]UNTIL NM.GE.NMED; "LOOP UNTIL WE HAVE ENOUGH.  END :MEDIUM: LOOP"

CLOSE (UNIT=KMPI);

"   WE NOW HAVE DATA FOR ALL MEDIA REQUESTED.  NOW DO DISTANCE UNIT"
"   CHANGE.  DATA FROM PEGS IS IN UNITS OF RADIATION LENGTHS."
"   EGS IS RUN IN UNITS OF 'DUNIT' CENTIMETERS, IF DUNIT.GT.0 "
"   OR IN UNITS OF RLC(-DUNIT) CENTIMETERS IF DUNIT.LT.0."
"   THAT IS, A NEGATIVE DUNIT MEANS UNIT IS TO BE THE RADIATION"
"   LENGTH OF THE MEDIUM WHOSE INDEX IS -DUNIT"
DUNITR=DUNIT; "SAVE REQUESTED"
IF(DUNIT.LT.0.0)[ID=MAX0(1,MIN0($MXMED,int(-DUNIT)));
   DUNIT=RLC(ID);]
IF(DUNIT.NE.1.0) [
$egs_info('(a,1PE14.5,E14.5,a)',' DUNIT REQUESTED&USED ARE: ',
         DUNITR,DUNIT,'(CM.)' );
]
DO IM=1,NMED [
DFACT=RLC(IM)/DUNIT; "CONVERTS RL TO DUNITS"
DFACTI=1.0/DFACT;    "CONVERT RL**-1 TO DUNITS**-1"

FOR I=1 TO MEKE(IM) [
$SCALE $LGN(ESIG,PSIG,EDEDX,PDEDX(I,IM)/0,1/) BY DFACTI;
$SCALE $LGN(TMXS(I,IM)/0,1/) BY DFACT;]
$SCALE TEFF0(IM) BY DFACT;
$SCALE BLCC(IM) BY DFACTI;
$SCALE XCC(IM) BY SQRT(DFACTI);
RLDU(IM)=RLC(IM)/DUNIT;
FOR I=1 TO MGE(IM) [$SCALE $LGN(GMFP(I,IM)/0,1/) BY DFACT; ]
] "END IM DO"

"   SCALE VACDST.  UNDO PREVIOUS SCALE, THEN DO NEW."
VACDST=VACDST*DUNITO/DUNIT;
DUNITO=DUNIT; "SAVE OLD DUNIT"

]"end regular pegs4 intake"
ELSE["pegsless intake of medium data"

$egs_info(*,' PEGSLESS INPUT.  CALCULATING ELECTRON CROSS-SECTIONS.');

$GET-PEGSLESS-XSECTIONS;

]

"   NOW MAKE SURE ECUT AND PCUT ARE NOT LOWER THAN ANY AE OR AP"
"   ALSO SET DEFAULT DENSITIES"
$adjust_rhor_ecut_pcut;

"BREMSSTRAHLUNG ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
"NEXT LINE ADDED AFB 88/05/31"
$INITIALIZE-BREMS-ANGLE;

"PAIR ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
"NEXT LINE ADDED AFB 91/05/29"
$INITIALIZE-PAIR-ANGLE;

" See if user has requested PEGS4 photon cross section data "
IF(toUpper($cstring(photon_xsections)) = 'PEGS4')[
  $egs_warning('(6(a/))','Using photon data from PEGS4 file!!!',
  'However, the new Rayleigh angular sampling will be used.',
  'The original EGS4 angular sampling undersamples large scattering ',
  'angles. This may have little impact as Rayleigh scattering ',
  'is forward peaked.',
  '*********************************************************');

]
ELSE["re-calculates photon xsections using available or user data"
"Ali:photonuc, 2 lines"
    call egs_init_user_photon(photon_xsections,comp_xsections,
    photonuc_xsections,xsec_out);
"    call egs_init_user_photon(photon_xsections,comp_xsections,xsec_out);"
]

call mscati;       "Initialize new MS, step-sizes, etc, IK Oct 97"

"Calling order of the subroutines below is important when using"
"detailed atomic relaxation in order to use the binding energies"
"corresponding to the requested photon cross section library"
IF ( eadl_relax & photon_xsections = 'xcom' )[
   call init_compton; "Initialize bound Compton scattering"
   call EDGSET(1,1);  "Initialize relaxations and photo-absorption data"
]
ELSE[
   call EDGSET(1,1);  "Initialize relaxations and photo-absorption data,"
                      "if requested
   call init_compton; "Initialize bound compton scattering, IK, Jan 99"
                      "if requested
]

IF( xsec_out = 1 & eadl_relax) [
  call egs_print_binding_energies;
]

call fix_brems;    "Re-calculate dl1,... for the different technique"
                   "employed in BREMS. Note that the old EGS sampling"
                   "technique for BREMS had a bug that shows up only"
                   "if AP is not much smaller than electron kinetic energy"

IF( ibr_nist >= 1 ) [ call init_nist_brems; ]
                   "initializes the sampling tables and modifies the total"
                   "brems cross sections if the NIST brems data base is to"
                   "be used                                               "

IF( pair_nrc = 1 ) [ call init_nrc_pair; ]

" Load and initialize EII data if needed. "
call eii_init;

" Load and initialize the triplet data if needed "
call init_triplet;

"   SETUP IS NOW COMPLETE"
IF (NMED.EQ.1)[
   $egs_info(*,'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ONE MEDIUM.');
]
ELSE[
   $egs_info('(a,i5,a)',
             'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ',NMED,' MEDIA.');
]

RETURN;

:MDNOMORE:
$egs_info('(a,i2//,a/,a/)', ' END OF FILE ON UNIT ',KMPI,
  ' PROGRAM STOPPED IN HATCH BECAUSE THE',
  ' FOLLOWING NAMES WERE NOT RECOGNIZED:');
DO IM=1,NMED [
   IF(LOK(IM).NE.1) [
      $egs_info('(40x,a,24a1,a)','''',(MEDIA(I,IM),I=1,LMDN),'''');
   ]
]
STOP;
"END OF SUBROUTINE HATCH"   END;

subroutine fix_brems;
"******************************************************************"
"
" Calculates the parameter for the rejection function used in
" the current implementation of bremsstrahlung sampling
"
" I Kawrakow, January 2000
"
"*******************************************************************"

$IMPLICIT-NONE;
$declare_max_medium;
;COMIN/BREMPR,MEDIA,NIST-BREMS,THRESH/;

$INTEGER medium,i;
$REAL    Zt,Zb,Zf,Zg,Zv,fmax1,fmax2,Zi,pi,fc,xi,aux,
         XSIF,FCOULC;

DO medium = 1,nmed [

    log_ap(medium) = log(ap(medium));
    Zt = 0; Zb = 0; Zf = 0;
    DO i=1, NNE(medium) [
        Zi = ZELEM(medium,i); pi = PZ(medium,i);
        fc = FCOULC(Zi); xi = XSIF(Zi);
        aux = pi*Zi*(Zi + xi);
        Zt = Zt + aux;
        Zb = Zb - aux*Log(Zi)/3;
        Zf = Zf + aux*fc;
    ]
    Zv = (Zb - Zf)/Zt; Zg = Zb/Zt;
    fmax1 = 2*(20.863 + 4*Zg) - 2*(20.029 + 4*Zg)/3;
    fmax2 = 2*(20.863 + 4*Zv) - 2*(20.029 + 4*Zv)/3;

    "These are used in BREMS"
    dl1(1,medium) = (20.863 + 4*Zg)/fmax1;
    dl2(1,medium) = -3.242/fmax1;
    dl3(1,medium) = 0.625/fmax1;
    dl4(1,medium) = (21.12+4*Zg)/fmax1;
    dl5(1,medium) = -4.184/fmax1;
    dl6(1,medium) = 0.952;
    dl1(2,medium) = (20.029+4*Zg)/fmax1;
    dl2(2,medium) = -1.93/fmax1;
    dl3(2,medium) = -0.086/fmax1;
    dl4(2,medium) = (21.12+4*Zg)/fmax1;
    dl5(2,medium) = -4.184/fmax1;
    dl6(2,medium) = 0.952;
    dl1(3,medium) = (20.863 + 4*Zv)/fmax2;
    dl2(3,medium) = -3.242/fmax2;
    dl3(3,medium) = 0.625/fmax2;
    dl4(3,medium) = (21.12+4*Zv)/fmax2;
    dl5(3,medium) = -4.184/fmax2;
    dl6(3,medium) = 0.952;
    dl1(4,medium) = (20.029+4*Zv)/fmax2;
    dl2(4,medium) = -1.93/fmax2;
    dl3(4,medium) = -0.086/fmax2;
    dl4(4,medium) = (21.12+4*Zv)/fmax2;
    dl5(4,medium) = -4.184/fmax2;
    dl6(4,medium) = 0.952;

    "and these in PAIR"
    dl1(5,medium) = (3*(20.863 + 4*Zg) - (20.029 + 4*Zg));
    dl2(5,medium) = (3*(-3.242) - (-1.930));
    dl3(5,medium) = (3*(0.625)-(-0.086));
    dl4(5,medium) = (2*21.12+8*Zg);
    dl5(5,medium) = (2*(-4.184));
    dl6(5,medium) = 0.952;
    dl1(6,medium) = (3*(20.863 + 4*Zg) + (20.029 + 4*Zg));
    dl2(6,medium) = (3*(-3.242) + (-1.930));
    dl3(6,medium) = (3*0.625+(-0.086));
    dl4(6,medium) = (4*21.12+16*Zg);
    dl5(6,medium) = (4*(-4.184));
    dl6(6,medium) = 0.952;
    dl1(7,medium) = (3*(20.863 + 4*Zv) - (20.029 + 4*Zv));
    dl2(7,medium) = (3*(-3.242) - (-1.930));
    dl3(7,medium) = (3*(0.625)-(-0.086));
    dl4(7,medium) = (2*21.12+8*Zv);
    dl5(7,medium) = (2*(-4.184));
    dl6(7,medium) = 0.952;
    dl1(8,medium) = (3*(20.863 + 4*Zv) + (20.029 + 4*Zv));
    dl2(8,medium) = (3*(-3.242) + (-1.930));
    dl3(8,medium) = (3*0.625+(-0.086));
    dl4(8,medium) = (4*21.12+16*Zv);
    dl5(8,medium) = (4*(-4.184));
    dl6(8,medium) = 0.952;

    bpar(2,medium) = dl1(7,medium)/(3*dl1(8,medium) + dl1(7,medium));
    bpar(1,medium) = 12*dl1(8,medium)/(3*dl1(8,medium) + dl1(7,medium));

]
return;
end;


$REAL function FCOULC(Z);
"************************"
$IMPLICIT-NONE;
$REAL Z;
$REAL fine,asq;
data fine/137.03604/;
asq = Z/fine; asq = asq*asq;
FCOULC = asq*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+ASQ*(0.0083+ASQ*(-0.002))));
return;
end;

$REAL function XSIF(Z);
"**********************"
$IMPLICIT-NONE;
$REAL    Z;
$INTEGER iZ;
$REAL    alrad(4),alradp(4),a1440,a183,FCOULC;
data     alrad/5.31,4.79,4.74,4.71/;
data     alradp/6.144,5.621,5.805,5.924/;
data     a1440/1194.0/,A183/184.15/;
IF( Z <= 4 ) [ iZ = Z; xsif = alradp(iZ)/(alrad(iZ) - FCOULC(Z)); ]
ELSE [ xsif = Log(A1440*Z**(-0.666667))/(Log(A183*Z**(-0.33333))-FCOULC(Z)); ]
return;
end;

"******************************************************************"
subroutine init_compton;
"
"  Reads in bound Compton scattering data from unit $INCOHUNIT
"  and performs necessary initializations
"
"  See definitions of variables in egsnrc.macros with definition
"  of COMIN/COMPTON-DATA/
"
"  I.Kawrakow, January 99
"******************************************************************"

implicit none;

$COMIN-INIT-COMPT;

$INTEGER i,j,iz,nsh,j_l,j_h;
$REAL    aux,pztot,atav;
$REAL    aux_erf,erf1;  "using erf1, provided with EGSnrc, because some"
                        "compiler don't have an intrinsic error function"
$LOGICAL getd;

" Initialize radiative Compton corrections, if needed "
$RADC_HATCH;

$need_bound_compton_data(getd);
IF( ~getd ) [
    IF( eadl_relax & photon_xsections = 'xcom' )[
        $egs_fatal('(a,/a,/a)',
                   'You must turn ON Compton binding corrections when using',
                   'a detailed atomic relaxation (eadl_relax=true) since ',
                   'binding energies taken from incoh.data below 1 keV!');
    ]
    $egs_info('(a/)',' Bound Compton scattering not requested! ');
    return;
]

$egs_info('(/a$)','Bound Compton scattering requested, reading data ......');
rewind($INCOHUNIT);
DO j=1,18 [ read($INCOHUNIT,*); ]  "skip 1st 18 lines of comments"
iz = 0;
DO j=1,$MXTOTSH [
    read($INCOHUNIT,*) iz_array(j),shn_array(j),ne_array(j),
                       Jo_array(j),be_array(j);
    Jo_array(j) = Jo_array(j)*137.;
    be_array(j) = be_array(j)*1e-6/PRM;
    aux_erf = 0.70710678119*(1+0.3*Jo_array(j));
    erfJo_array(j) = 0.82436063535*(erf1(aux_erf)-1);
                    "0.82436063535 is exp(0.5)/2"

    "For detailed atomic relaxations set shell type
    "to actual shell number and update binding energies
    "with values from the photo-electric cross sections
    IF (eadl_relax)[
       IF (iz_array(j) ~= iz)[
          shn_array(j) = 1; iz = iz_array(j);
       ]
       ELSE[
          shn_array(j) = shn_array(j-1)+1;
       ]
       IF(binding_energies(shn_array(j),iz_array(j)) > 0)[
         be_array(j) = binding_energies(shn_array(j),iz_array(j))/PRM;
       ]
       ELSE IF(photon_xsections = 'xcom') [
         "Use binding energies from incoh.data below 1 keV"
         binding_energies(shn_array(j),iz_array(j)) = be_array(j)*PRM;
       ]
    ]

]
$egs_info(*,' Done');
$egs_info('(/a)',' Initializing Bound Compton scattering ......');
DO medium = 1,nmed [
    pztot = 0; nsh = 0;
    DO i = 1, nne(medium) [
        iz = int(zelem(medium,i));
        DO j = 1, $MXTOTSH [
            IF( iz = iz_array(j) ) [
                nsh = nsh + 1;
                IF( nsh > $MXMDSH ) [
                    $egs_fatal('(/a,i3,a,i4,a/,a)',' For medium ',medium,
                              ' the number of shells is > ',$MXMDSH,'!',
                              ' Increase the parameter $MXMDSH! ');
                ]
                shell_array(nsh,medium) = j;
                aux = pz(medium,i)*ne_array(j);
                eno_array(nsh,medium) = aux;
                pztot = pztot + aux;
            ]
        ]
    ]
    IF( nsh = 0 ) [
        $egs_fatal('(a,i3,a)', ' Medium ',medium,' has zero shells! ');
    ]
    n_shell(medium) = nsh;
    $egs_info('(a,i3,a,i3,a)', ' Medium ',medium,' has ',nsh,' shells: ');
    DO i=1,nsh [
        j = shell_array(i,medium);
        eno_array(i,medium) = eno_array(i,medium)/pztot;
        $egs_info('(i4,i5,i4,f9.5,e10.3,f10.3)',
                  i,j,shn_array(j),eno_array(i,medium),
                  Jo_array(j),be_array(j)*PRM*1000.);
        eno_array(i,medium) = -eno_array(i,medium);
        eno_atbin_array(i,medium) = i;
    ]
    atav = 1./nsh;
    DO i=1,nsh-1 [
        DO j_h = 1,nsh-1 [
            IF( eno_array(j_h,medium) < 0 ) [
                IF( abs(eno_array(j_h,medium)) > atav ) EXIT;
            ]
        ]
        DO j_l = 1,nsh-1 [
            IF( eno_array(j_l,medium) < 0 ) [
                IF( abs(eno_array(j_l,medium)) < atav ) EXIT;
            ]
        ]
        aux = atav - abs(eno_array(j_l,medium));
        eno_array(j_h,medium) = eno_array(j_h,medium) + aux;
        eno_array(j_l,medium) = -eno_array(j_l,medium)/atav + j_l;
        eno_atbin_array(j_l,medium) = j_h;
        IF( i = nsh-1 ) eno_array(j_h,medium) = 1 + j_h;
    ]
    DO i=1,nsh [
        IF( eno_array(i,medium) < 0 ) [ eno_array(i,medium) = 1 + i; ]
    ]
]

$egs_info('(a/)',' ...... Done.');

$need_relaxation_data(getd);
IF( getd ) return;
$egs_fatal('(/a,/a,/a,/a)',
' In subroutine init_compton: ',
'   Scattering off bound electrons creates atomic vacancies,',
'   potentially starting an atomic relaxation cascade. ',
'   Please turn ON atomic relaxations.');
/*
Turning ON relaxations to setup relaxations for bound Compton
and then turning it back OFF seems inconsistent. One should have
relaxations for all interactions with atomic electrons.

$egs_info('(a/,a/,a/,a//)',
' In subroutine init_compton: ',
'   fluorescence not set but relaxation data are required for ',
'   bound Compton scattering. ',
'   calling EDGSET. ');
iedgfl(1) = 1;              "This was (2) originally  DR"
eadl_relax = .true.;
call edgset(1,1);
iedgfl(1) = 0;              "This was (2) originally  DR"
*/
return;
end;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE MOLLER;
"                                                                  "
"******************************************************************"
"   DISCRETE MOLLER SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
"   ARBITRARILY DEFINED AND CALCULATED TO MEAN MOLLER SCATTERINGS  "
"   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
"   IT BE TRANSPORTED DISCRETELY.  THE THRESHOLD TO TRANSPORT AN   "
"   ELECTRON DISCRETELY IS A TOTAL ENERGY OF AE OR A KINETIC ENERGY"
"   OF TE=AE-RM.  SINCE THE KINETIC ENERGY TRANSFER IS ALWAYS, BY  "
"   DEFINITION, LESS THAN HALF OF THE INCIDENT KINETIC ENERGY, THIS"
"   IMPLIES THAT THE INCIDENT ENERGY, EIE, MUST BE LARGER THAN     "
"   THMOLL=TE*2+RM.  THE REST OF THE COLLISION CONTRIBUTION IS     "
"   SUBTRACTED CONTINUOUSLY FROM THE ELECTRON AS IONIZATION        "
"   LOSS DURING TRANSPORT.                                         "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-MOLLER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "  COMIN/EGS-VARIANCE-REDUCTION, DEBUG,STACK,THRESH,"
                                          "UPHIOT,USEFUL,RANDOM/;"
;COMIN/EII-DATA,ELECIN,EPCONT,EDGE,BREMPR/;

$DEFINE-LOCAL-VARIABLES-MOLLER;

$REAL sigm,pbrem,rsh,Uj,sig_j;
$INTEGER lelke,iele,ish,nsh,ifirst,i,jj,iZ,iarg;

"IRCODE=1;  appears to be unused, IK Oct 97"
NPold = NP;      "Set the old stack counter"
PEIE=E(NP);"PRECISE ENERGY OF INCIDENT ELECTRON"
EIE=PEIE; "ENERGY OF INCIDENT ELECTRON"
PEKIN=PEIE-PRM;  "PRECISE K.E. OF INCIDENT ELECTRON"
EKIN=PEKIN;

IF( eii_flag > 0 & eii_nsh(medium) > 0 ) [
    "The EII flag is set and this medium has shells for which we want to"
    "simulate EII => sample if the interaction is with a EII shell"
    $SET INTERVAL elke,eke;
    $EVALUATE sigm USING esig(elke);
    $EVALUATE pbrem USING ebr1(elke);
    sigm = sigm*(1 - pbrem);
    $RANDOMSET rsh; rsh = sigm*rsh;
    DO iele=1,nne(medium) [
        iZ = int(zelem(medium,iele)+0.5);
        nsh = eii_no(medium,iele);
        IF( nsh > 0 ) [
            ifirst = eii_first(medium,iele);
            DO ish = 1,nsh [
                Uj = binding_energies(ish,iZ);
                IF( ekin > Uj & (Uj > te(medium) | Uj > ap(medium)) ) [
                    jj = ifirst + ish - 1;
                    i = eii_a(jj)*elke + eii_b(jj) + (jj-1)*$N_EII_BINS;
                    sig_j = eii_xsection_a(i)*elke + eii_xsection_b(i);
                    sig_j = sig_j*pz(medium,iele)*eii_cons(medium);
                    rsh = rsh - sig_j;
                    IF( rsh < 0 ) [
                        $AUSCALL($EIIB);
                        call eii_sample(ish,iZ,Uj);
                        $AUSCALL($EIIA);
                        return;
                    ]
                ]
            ]
        ]
    ]
]
IF( ekin <= 2*te(medium) ) return;
T0=EKIN/RM;
E0=T0+1.0;
EXTRAE = EIE - THMOLL(MEDIUM);
E02=E0*E0;
"BETAI2=E02/(E02-1.0); " "BLIF 96/2/1 -- not needed for Moller fix-up"
EP0=TE(MEDIUM)/EKIN;
"G1=(1.-2.*EP0)*BETAI2;" "BLIF 96/2/1 -- not needed for Moller fix-up"
G2=T0*T0/E02;
G3=(2.*T0+1.)/E02;
"   H.H.NAGEL HAS CONSTRUCTED A FACTORIZATION OF THE FREQUENCY"
"   DISTRIBUTION FUNCTION FOR THE MOLLER DIFFERENTIAL CROSS"
"   SECTION USED AS SUGGESTED BY BUTCHER AND MESSEL."
"   (H.H.NAGEL, OP.CIT., P. 53-55)                                 "
"   HOWEVER, A MUCH SIMPLER SAMPLING METHOD WHICH DOES NOT BECOME  "
"   VERY INEFFICIENT NEAR THMOLL IS THE FOLLOWING. . .             "
"   LET BR=EKS/EKIN,  WHERE EKS IS KINETIC ENERGY TRANSFERED TO THE"
"   SECONDARY ELECTRON AND EKIN IS THE INCIDENT KINETIC ENERGY.    "

"   MODIFIED (7 FEB 1974) TO USE THE TRUE MOLLER CROSS SECTION."
"   THAT IS, INSTEAD OF THE E+ E- AVERAGE GIVEN IN THE ROSSI"
"   FORMULA USED BY NAGEL.  THE SAMPLING SCHEME IS THAT"
"   USED BY MESSEL AND CRAWFORD (EPSDF 1970 P.13)"
"   FIRST SAMPLE (1/BR**2) OVER (TE/EKIN,1/2) . . .            "

GMAX=(1.+1.25*G2); "BLIF 96/2/1 -- Moller fix-up"
LOOP[" TO RETRY IF REJECTED"
$RANDOMSET RNNO27;
BR = TE(MEDIUM)/(EKIN-EXTRAE*RNNO27);

"   USE MESSEL AND CRAWFORDS REJECTION FUNCTION."
R=BR/(1.-BR);
$RANDOMSET RNNO28;
REJF4="G1*"(1.+G2*BR*BR+R*(R-G3)); "BLIF 96/2/1 -- Moller fix-up"
RNNO28=GMAX*RNNO28; "BLIF 96/2/1 -- Moller fix-up"
]UNTIL RNNO28.LE.REJF4; "TRY UNTIL ACCEPTED. END REJECTION LOOP"

PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY ELECTRON #2"
PESE1=PEIE-PEKSE2; "PRECISE ENERGY OF SECONDARY ELECTRON #1"
PESE2=PEKSE2+PRM; "PRECISE ENERGY OF SECONDARY ELECTRON #2"
ESE1=PESE1; "ENERGY OF SECONDARY ELECTRON 1"
ESE2=PESE2; "ENERGY OF SECONDARY ELECTRON 2"
E(NP)=PESE1;
$CHECK-STACK(np+1,'MOLLER');
E(NP+1)=PESE2;
"   SINCE BR.LE.0.5, E(NP+1) MUST BE .LE. E(NP). "
"   MOLLER ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS            "

" One possible way of dealing with double counting of angular      "
" deflections in inelastic scattering would be to                  "
" not deflect the 'old' electron as these deflections are          "
" already taken into account in the multiple elastic scattering    "
" This approach has the disadvantage of loosing correlations       "
" between big energy losses and strong angular deflections         "
" The advantage of such an approach is its simplicity.             "
" If spin effects for multiple elastic scattering are turned on,   "
" the double counting is taken into account by the appropriate     "
" modification of the scattering power (which depends on AE)       "
"                                                                  "
"                                                                  "
" IK, June 1999                                                    "

H1=(PEIE+PRM)/PEKIN;
"   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON                     "
DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);
SINTHE=DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);

"sinthe = 0; costhe = 1; <- this will turn off the Moller ang. deflections"

CALL UPHI(2,1);

"   RELATED CHANGE AND (X,Y,Z) SETUP FOR 'NEW' ELECTRON            "
NP=NP+1;
IQ(NP)=-1;
DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
SINTHE=-DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);
CALL UPHI(3,2);
RETURN;
"END OF SUBROUTINE MOLLER"  END;

%E

subroutine mscati;
"**********************************************************************"

" Subroutine to read the pre-calculated q^(2+)-surface, prepare data
" required by the mscat and msdist subroutines, initialize spin effect
" corrections
"
" I.Kawrakow, NRC
"**********************************************************************"

implicit none;

$REAL ededx,ei,eil,eip1,eip1l,si,sip1,eke,elke,aux,ecutmn,tstbm,tstbmn;
$REAL p2,beta2,dedx0,ekef,elkef,estepx,ektmp,elktmp,chi_a2;
$INTEGER
    i,leil,leip1l,neke,lelke,lelkef,lelktmp;
$LOGICAL  ise_monoton, isp_monoton;

$declare_write_buffer;

"cross section per energy loss"
$REAL sigee,sigep,sig,sige_old,sigp_old;

"entry mscat variables
"======================

$COMIN-MSCATI;

" moved the following from prestaII_inputs, "
" if transport_algorithm = presta-I, exact_bca = .false. and
" skin_depth_for_bca <= 1  ==> calculate default presta-I tmin for bca"

IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
ELSE                    [ exact_bca = .false.; ]
IF( estepe <= 0 | estepe >= 1) [ estepe = $MAX-ELOSS; ]
IF( ximax <= 0  | ximax >= 1 ) [
    IF( exact_bca ) [ ximax = $EXACT-BCA-XIMAX;   ]
    ELSE            [ ximax = $INEXACT-BCA-XIMAX; ]
]
IF (transport_algorithm ~= $PRESTA-II &
    transport_algorithm ~= $PRESTA--I &
    transport_algorithm ~= $VMC ) [transport_algorithm = $PRESTA-II;]
IF( skindepth_for_bca <= 1e-4 ) [
    "IF( transport_algorithm = $PRESTA--I & ~exact_bca ) ["
    IF( ~exact_bca ) [
        $egs_info(*,' old PRESTA calculates default min. step-size for BCA: ');
        $set_ecutmn;
        $egs_info(*,'     minimum ECUT found: ',ecutmn);
        tstbmn = 1e30;
        DO medium = 1,nmed [
            tstbm = (ecutmn-prm)*(ecutmn+prm)/ecutmn**2;
            tstbm = blcc(medium)*tstbm*(ecutmn/xcc(medium))**2;
            aux = Log(tstbm);
            IF( aux > 300 ) $egs_info(*,'aux > 300 ? ',aux);
            tstbm = Log(tstbm/aux);
            "Changed the following to the above so that the Intel compiler"
            " does not vectorize the loop with -xK. Vectorizing this loop"
            " on an Athlon CPU results in segmentation fault."
            " IK, Jan 29 2004."
            "tstbm = Log(tstbm/Log(tstbm));"
            tstbmn = Min(tstbmn,tstbm);
        ]
        $egs_info(*,'     default BLCMIN is: ',tstbmn);
        skindepth_for_bca = Exp(tstbmn);
        $egs_info(*,'     this corresponds to ',skindepth_for_bca,
         ' elastic MFPs ');
    ]
    ELSE [ skindepth_for_bca = $SKIN-DEPTH-FOR-BCA; ]
]

" read MS data for screened Rutherford scattering "
call init_ms_SR;

DO medium = 1,nmed
[
    "Absorb Euler constant into the multiple scattering parameter
    "1.16699413758864573 = Exp[2 EulerGamma - 1]
    blcc(medium) = 1.16699413758864573*blcc(medium);

    "Take its square as this is employed throughout
    xcc(medium)  = xcc(medium)**2;
]

IF( spin_effects ) [ call init_spin; ]

"Determine maximum cross section per energy loss for every medium
$egs_info(*,' ');
esige_max = 0;
psige_max = 0;
DO medium = 1,nmed
[

  sigee = 1E-15; sigep = 1E-15;
  neke = meke(medium); "Number of elements in storage array
  ise_monoton = .true.; isp_monoton = .true.;
  sige_old = -1; sigp_old = -1;
  DO i = 1,neke
  [

    ei   = exp((float(i) - eke0(medium))/eke1(medium));
    eil  = log(ei);
    leil = i;
    $EVALUATE ededx USING ededx(eil);
    $EVALUATE sig USING esig(eil);
    sig = sig/ededx;
    IF (sig > sigee) sigee = sig;
    IF( sig < sige_old ) ise_monoton = .false.;
    sige_old = sig;
    $EVALUATE ededx USING pdedx(eil);
    $EVALUATE sig USING psig(eil);
    sig = sig/ededx;
    IF (sig > sigep) sigep = sig;
    IF( sig < sigp_old ) isp_monoton = .false.;
    sigp_old = sig;

  ]
  $egs_info(*,' Medium ',medium,' sige = ',sigee,sigep,' monotone = ',
          ise_monoton,isp_monoton);
  sig_ismonotone(0,medium) = ise_monoton;
  sig_ismonotone(1,medium) = isp_monoton;
  esig_e(medium) = sigee; psig_e(medium) = sigep;
  IF( sigee > esige_max ) esige_max = sigee;
  IF( sigep > psige_max ) psige_max = sigep;
]
$egs_info(*,' ');

$egs_info(*,' Initializing tmxs for estepe = ',estepe,' and ximax = ',ximax);
$egs_info(*,' ');

"Determine upper limit in step size for multiple scattering
DO medium = 1,nmed
[
    " Calculate range array first "
    " =========================== "
    ei   = exp((1 - eke0(medium))/eke1(medium)); "Energy of first table entry
    eil  = log(ei);
    leil = 1;
    E_array(1,medium) = ei;
    expeke1(medium) = Exp(1./eke1(medium))-1;
    range_ep(0,1,medium) = 0; range_ep(1,1,medium) = 0;
    neke = meke(medium); "Number of elements in storage array
    DO i = 1,neke - 1
    [
        eip1   = exp((float(i + 1) - eke0(medium))/eke1(medium)); "Energy at i+1
        E_array(i+1,medium) = eip1;
        " Calculate range. The following expressions result from the"
        " logarithmic interpolation for the (restricted) stopping power "
        " and a power power series expansion of the integral "
        eke = 0.5*(eip1+ei); elke = Log(eke);
        $SET INTERVAL elke,eke;
        $EVALUATE ededx USING pdedx(elke);
        aux = pdedx1(i,medium)/ededx;
        range_ep(1,i+1,medium) = range_ep(1,i,medium) +
          (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
        $EVALUATE ededx USING ededx(elke);
        aux = ededx1(i,medium)/ededx;
        range_ep(0,i+1,medium) = range_ep(0,i,medium) +
          (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
        ei = eip1;
    ]

    " Now tmxs "
    " ======== "

    eil = (1 - eke0(medium))/eke1(medium);
    ei  = Exp(eil); leil = 1; " As in $SET INTERVAL but avoids roundoff
    p2  = ei*(ei+2*rm); beta2 = p2/(p2+rm*rm);
    chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
    $EVALUATE dedx0 USING ededx(eil);
    estepx = 2*p2*beta2*dedx0/ei/Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
    estepx = estepx*ximax;
    IF( estepx > estepe ) [ estepx = estepe; ]
    si = estepx*ei/dedx0;

    DO i = 1,neke - 1
    [

        elke = (i + 1 - eke0(medium))/eke1(medium);
        eke  = Exp(elke); lelke = i+1;
        p2  = eke*(eke+2*rm); beta2 = p2/(p2+rm*rm);
        chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
        $EVALUATE ededx USING ededx(elke);
        estepx = 2*p2*beta2*ededx/eke/
                  Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
        estepx = estepx*ximax;
        IF( estepx > estepe ) [ estepx = estepe; ]
        ekef = (1-estepx)*eke;
        IF( ekef <= E_array(1,medium) )
        [
            sip1 = (E_array(1,medium) - ekef)/dedx0;
            ekef = E_array(1,medium);
            elkef = (1 - eke0(medium))/eke1(medium);
            lelkef = 1;
        ]
        ELSE
        [
            elkef = Log(ekef);
            $SET INTERVAL elkef,eke;
            leip1l = lelkef + 1;
            eip1l  = (leip1l - eke0(medium))/eke1(medium);
            eip1   = E_array(leip1l,medium);
            aux    = (eip1 - ekef)/eip1;
            elktmp = 0.5*(elkef+eip1l+0.25*aux*aux*(1+aux*(1+0.875*aux)));
            ektmp  = 0.5*(ekef+eip1);
            lelktmp = lelkef;
            $EVALUATE ededx USING ededx(elktmp);
            aux = ededx1(lelktmp,medium)/ededx;
            sip1 = (eip1 - ekef)/ededx*(
                     1+aux*(1+2*aux)*((eip1-ekef)/ektmp)**2/24);
        ]
        sip1 = sip1 + range_ep(0,lelke,medium) - range_ep(0,lelkef+1,medium);

        "Now solve these equations
        "  si   = tmxs1 * eil   + tmxs0
        "  sip1 = tmxs1 * eip1l + tmxs0

        tmxs1(i,medium) = (sip1 - si)*eke1(medium);
        tmxs0(i,medium) = sip1 - tmxs1(i,medium)*elke;

        si  = sip1;
    ]

    "Now pick up last table entry which applies only to last energy
    tmxs0(neke,medium) = tmxs0(neke - 1,medium);
    tmxs1(neke,medium) = tmxs1(neke - 1,medium);

]

return;
end;

%E
; "buffer flush

subroutine mscat(lambda,chia2,q1,elke,beta2,qel,medium,
                 spin_effects,find_index,spin_index,
                 cost,sint);
"========================================================================="
"                                                                         "
" Subroutine to sample multiple electron scattering angles from the exact "
" distribution resulting from elastic scattering described by the screened"
" Rutherford cross section (spin_effects=.false.) or by the screened      "
" Rutherford cross times Mott correction (spin_effects=.true.)            "
"                                                                         "
" I.Kawrakow, NRC                                                         "
"========================================================================="

implicit none;

$REAL    lambda, chia2,q1,elke,beta2,cost,sint;
$INTEGER qel,medium;
$LOGICAL spin_effects,find_index,spin_index;

COMIN/MS-Data,RANDOM,EGS-IO/;

$declare_write_buffer;

$REAL    sprob,explambda,wsum,wprob,xi,rejf,spin_rejection,
         cosz,sinz,phi,omega2,llmbda,ai,aj,ak,a,u,du,x1,rnno;
$INTEGER icount,i,j,k;

save     i,j,omega2;

$TURN_OFF_SCATTERING;
" default of above is ';' See definition in egsnrc.macros for example"
" of how to turn off all scattering    DR April 2012"

IF(lambda <= 13.8)
[
    "Test only for lambda = 13.8 implies a 1e-6 error, ie large-lambda cases
    "that contribute to the forward no-scattering amplitude.
    $RANDOMSET sprob;
    explambda = Exp(-lambda);
    IF (sprob < explambda)
    [
        "It was a no scattering event
        cost = 1; sint = 0;
        return;
    ]
    wsum = (1+lambda)*explambda;
    IF ( sprob < wsum )
    [
      :RETRY_1:;
      $RANDOMSET xi;
      xi  = 2*chia2*xi/(1 - xi + chia2);
      cost = 1 - xi;
      IF( spin_effects ) [
          rejf = spin_rejection(qel,medium,elke,beta2,q1,cost,
                                spin_index,.false.);
          $RANDOMSET rnno;
          IF( rnno > rejf ) [ GOTO :RETRY_1:; ]
      ]
      sint = sqrt(xi*(2 - xi));
      return;
    ]
    IF ( lambda <= 1 )      "IK introduced this portion because with
                            "alternative BCAs mscat can be called with
                            " lambda < 1 where there are no pre-calculated
                            "data
    [
        wprob = explambda; wsum = explambda;
        cost = 1; sint = 0;
        icount = 0;
        LOOP
        [
            icount = icount + 1;
            IF (icount > 20) EXIT; "To avoid underflow if sprob very close to 1
            wprob = wprob*lambda/icount;
            wsum = wsum + wprob;
            :RETRY_2:;
            $RANDOMSET xi;
            xi  = 2*chia2*xi/(1 - xi + chia2);
            cosz = 1 - xi;
            IF( spin_effects ) [
                rejf = spin_rejection(qel,medium,elke,beta2,q1,cosz,
                                      spin_index,.false.);
                $RANDOMSET rnno;
                IF( rnno > rejf ) [ GOTO :RETRY_2:; ]
            ]
            sinz = xi*(2 - xi);
            IF ( sinz > 1.e-20 )
            [
               sinz = Sqrt(sinz);
               $RANDOMSET xi;
               phi = xi*6.2831853;
               cost = cost*cosz - sint*sinz*Cos(phi);
               sint = Sqrt(Max(0.0,(1-cost)*(1+cost)));
             ]
        ] UNTIL ( wsum > sprob);
        return;
    ]
]

"It was a multiple scattering event
"Sample the angle from the q^(2+) surface

IF (lambda <= $LAMBMAX_MS ) [

    IF (find_index)
    [
        llmbda = log(lambda);

        " First fix lambda bin
        ai = llmbda*dllambi; i = ai; ai = ai - i;
        $RANDOMSET xi;
        IF(xi < ai) i = i + 1;

        " fix now q1 bin
        IF( q1 < $QMIN_MS ) [ j = 0; ]
        ELSE IF( q1 < $QMAX_MS ) [
            aj = q1*dqmsi; j = aj; aj = aj - j;
            $RANDOMSET xi;
            IF( xi < aj ) j = j + 1;
        ]
        ELSE [ j = $MAXQ_MS; ]

        " Calculate omega2 "
        IF(llmbda < 2.2299) [
          omega2 = chia2*(lambda + 4)*(1.347006 + llmbda*(
            0.209364 - llmbda*(0.45525 - llmbda*(0.50142 - 0.081234*llmbda))));
        ]
        ELSE [
          omega2 = chia2*(lambda + 4)*(-2.77164 + llmbda*(2.94874 -
                   llmbda*(0.1535754 - llmbda*0.00552888)));
        ]

        find_index = .false.;
    ]
    "If this is a re-iteration with the same lambda, then omega2, i, and k
    "should have been defined in the previous iteration

:RETRY_3:;
    $RANDOMSET xi;
    ak = xi*$MAXU_MS; k = ak; ak = ak - k;
    IF( ak > wms_array(i,j,k) ) k = ims_array(i,j,k);
    a = fms_array(i,j,k); u = ums_array(i,j,k);
    du = ums_array(i,j,k+1) - u;
    $RANDOMSET xi;
    IF( abs(a) < 0.2 ) [
        x1 = 0.5*(1-xi)*a;
        u  = u + xi*du*(1+x1*(1-xi*a));
    ]
    ELSE [ u = u - du/a*(1-Sqrt(1+xi*a*(2+a))); ]

    xi      = omega2*u/(1 + 0.5*omega2 - u);
    IF( xi > 1.99999 ) [ xi = 1.99999; ]
      "some machines have trouble when xi is very close to 2 in subsequent"
      "calculations. IK, April 25 2002"
    cost    = 1 - xi;
    IF( spin_effects ) [
        rejf=spin_rejection(qel,medium,elke,beta2,q1,cost,spin_index,.false.);
        $RANDOMSET rnno;
        IF( rnno > rejf ) [ GOTO :RETRY_3:; ]
    ]
    sint    = sqrt(xi*(2-xi));
    return;
]

"This is an error condition

$egs_info(*,' ');
$egs_info(*,' *************************************');
$egs_info(*,' Maximum step size in mscat exceeded! ');
$egs_info(*,' Maximum step size initialized: 100000');
$egs_info(*,' Present lambda: ',lambda);
$egs_info(*,' chia2: ',chia2);
$egs_info(*,' q1 elke beta2: ',q1,elke,beta2);
$egs_info(*,' medium: ',medium);
$egs_fatal(*,' Stopping execution');

end;

%E
; "buffer flush

$REAL function spin_rejection(qel,medium,elke,beta2,q1,cost,
                              spin_index,is_single);
"============================================================================="
"                                                                             "
" Determines the rejection function due to spin effects for                   "
"   charge        qel (=0 for e-, =1 for e+)                                  "
"   log(energy)   elke                                                        "
"   speed         beta2                                                       "
"   1. MS moment  q1                                                          "
"   cos(theta)    cost                                                        "
"                                                                             "
" I.Kawrakow, NRC                                                             "
"============================================================================="

implicit none;

$REAL      elke,beta2,q1,cost;
$INTEGER   qel,medium;
$LOGICAL   spin_index,is_single;
$declare_max_medium;
COMIN/Spin-Data,RANDOM/;

$REAL      rnno,ai,qq1,aj,xi,ak;
$INTEGER   i,j,k;

save       i,j;

IF( spin_index ) [  "Determine the energy and q1 index
    spin_index = .false.;
    IF( beta2 >= b2spin_min ) [
        ai = (beta2 - b2spin_min)*dbeta2i;
        i = ai; ai = ai - i; i = i + $MAXE_SPIN + 1;
    ]
    ELSE IF( elke > espml ) [
        ai = (elke - espml)*dleneri; i = ai; ai = ai - i;
    ]
    ELSE [ i = 0; ai = -1; ]
    $RANDOMSET rnno;
    IF( rnno < ai ) i = i + 1;
    IF( is_single ) [ j = 0; ]
    ELSE [
        qq1 = 2*q1; qq1 = qq1/(1 + qq1);
        aj = qq1*dqq1i; j = aj;
        IF( j >= $MAXQ_SPIN ) [ j = $MAXQ_SPIN; ]
        ELSE [  aj = aj - j;
                $RANDOMSET rnno;
                IF( rnno < aj ) j = j + 1;
        ]
    ]
]
xi = Sqrt(0.5*(1-cost));
ak = xi*$MAXU_SPIN; k = ak; ak = ak - k;
spin_rejection = (1-ak)*spin_rej(medium,qel,i,j,k) +
                     ak*spin_rej(medium,qel,i,j,k+1);
return;
end;

%E
; "buffer flush


subroutine sscat(chia2,elke,beta2,qel,medium,spin_effects,cost,sint);
"============================================================================"
"                                                                            "
" single elastic scattering                                                  "
"                                                                            "
" I.Kawrakow, NRC                                                            "
"============================================================================"

implicit none;

$REAL    chia2,elke,beta2,cost,sint;
$INTEGER qel,medium;
$LOGICAL spin_effects;

COMIN/RANDOM/;

$REAL    xi,rnno,rejf,spin_rejection,qzero;
$LOGICAL spin_index;

$TURN_OFF_SCATTERING;
" default of above is ';' See definition in egsnrc.macros for example"
" of how to turn off all scattering    DR April 2012"

spin_index = .true.;
:RETRY-SPIN:;
$RANDOMSET xi;
xi  = 2*chia2*xi/(1 - xi + chia2);
cost = 1 - xi;
IF( spin_effects ) [
    qzero=0;
    rejf = spin_rejection(qel,medium,elke,beta2,qzero,cost,spin_index,.true.);
    $RANDOMSET rnno;
    IF( rnno > rejf ) goto :RETRY-SPIN:;
]
sint = sqrt(xi*(2 - xi));
return;
end;

%E
; "buffer flush

subroutine init_ms_SR;
"================================================================"
"                                                                "
" Reads in pre-calculated screened Rutherford multiple elastic   "
" scattering data                                                "
"                                                                "
" I. Kawrakow, NRC                                               "
"================================================================"

implicit none;

COMIN/MS-Data,EGS-IO/;
$declare_write_buffer;

integer*4 i,j,k;

$egs_info('(/a,$)','Reading screened Rutherford MS data ............... ');
rewind($MSCAT-DATAFILE);
DO i=0,$MAXL_MS [
    DO j=0,$MAXQ_MS [
        read($MSCAT-DATAFILE,*) (ums_array(i,j,k),k=0,$MAXU_MS);
        read($MSCAT-DATAFILE,*) (fms_array(i,j,k),k=0,$MAXU_MS);
        read($MSCAT-DATAFILE,*) (wms_array(i,j,k),k=0,$MAXU_MS-1);
        read($MSCAT-DATAFILE,*) (ims_array(i,j,k),k=0,$MAXU_MS-1);
        DO k=0,$MAXU_MS-1 [
           fms_array(i,j,k) = fms_array(i,j,k+1)/fms_array(i,j,k)-1;
           ims_array(i,j,k) = ims_array(i,j,k)-1;
        ]
        fms_array(i,j,$MAXU_MS)=fms_array(i,j,$MAXU_MS-1);
    ]
]
$egs_info('(a)',' done ');

llammin = Log($LAMBMIN_MS); llammax = Log($LAMBMAX_MS);
dllamb  = (llammax-llammin)/$MAXL_MS; dllambi = 1./dllamb;
dqms    = $QMAX_MS/$MAXQ_MS; dqmsi = 1./dqms;

return;
end;

%E
; "buffer flush

subroutine init_spin;
"======================================================================="
"                                                                       "
" Reads in spin rejection data for multiple elastic scattering and      "
" initializes interpolation arrays for the screening parameter,         "
" elastic cross section, first and second MS moments                    "
"                                                                       "
" I. Kawrakow, NRC                                                      "
"======================================================================="

implicit none;
$declare_max_medium;
COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
                            "BREMPR is needed for the elemental composition"

$REAL         eta_array(0:1,$0-MAXE_SPI1),
              c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
              earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
              sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
              tau,tauc,beta2,eta,gamma,fmax,
              eil,e,si1e,si2e,si1p,si2p,aae,etap,
              elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
              af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
              df($0-MAXE_SPI1),spline,dloge,eloge;

real*4        dum1,dum2,dum3,aux_o; " These must be 32 bit floats!!!!!"

real*4        fmax_array(0:$MAXQ_SPIN);
integer*2     i2_array(512),ii2;

$INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
              ndata,leil,length,ii4,irec;

character     spin_file*256;
character*6   string;
integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
                       "do not have lnblnk, we supply lnblnk1 in this file

$INTEGER      spin_unit, rec_length, want_spin_unit;
integer       egs_get_unit;
character     data_version*32,endianess*4;
$LOGICAL      swap;

$declare_write_buffer;

$REAL        fine,TF_constant;
parameter    (fine=137.03604, TF_constant=0.88534138);

" stupid GNU compiler complains that the arguments to egs_swap_ are of "
" one kind here, but of some other kind there => need character arrays and "
" equivalence statements"
real*4        tmp_4;
character     c_2(2), c_4(4);
equivalence   (ii2,c_2), (tmp_4,c_4);

" First construct the path to the spin dbase directory "
$set_string(spin_file,' ');
spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms.data';
want_spin_unit = 61;
spin_unit = egs_get_unit(want_spin_unit);
IF( spin_unit < 1 ) [
    $egs_fatal(*,'init_spin: failed to get a free fortran unit');
]
rec_length = 276*$RECL-FACTOR;
open(spin_unit,file=spin_file,form='unformatted',access='direct',
     status='old',recl=rec_length,err=:spin-open-error:);
read(spin_unit,rec=1,err=:spin-read-error:) data_version,endianess,
                      espin_min,espin_max,b2spin_min,b2spin_max;
swap = endianess.ne.$BYTE_ORDER;
IF( swap ) [
    tmp_4 = espin_min; call egs_swap_4(c_4); espin_min = tmp_4;
    tmp_4 = espin_max; call egs_swap_4(c_4); espin_max = tmp_4;
    tmp_4 = b2spin_min; call egs_swap_4(c_4); b2spin_min = tmp_4;
    tmp_4 = b2spin_max; call egs_swap_4(c_4); b2spin_max = tmp_4;
]
$egs_info('(//a,a)','Reading spin data base from ',$cstring(spin_file));
$egs_info('(a)',data_version);
$egs_info('(a,a,a)','Data generated on a machine with ',endianess,
        ' endianess');
$egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
IF( swap ) $egs_info('(a)','=> will need to do byte swaping');
$egs_info('(a,2f9.2,2f9.5,//)','Ranges: ',espin_min,espin_max,
        b2spin_min,b2spin_max);
n_ener = $MAXE_SPIN; n_q = $MAXQ_SPIN; n_point = $MAXU_SPIN;
dloge = log(espin_max/espin_min)/n_ener;
eloge = log(espin_min); earray(0) = espin_min;
$FOOL-INTEL-OPTIMIZER(25) 'Energy grid:';
DO i=1,n_ener [
    eloge = eloge + dloge; earray(i) = exp(eloge);
    $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
]
dbeta2 = (b2spin_max - b2spin_min)/n_ener;
beta2 = b2spin_min; earray(n_ener+1) = espin_max;
DO i=n_ener+2,2*n_ener+1 [
    beta2 = beta2 + dbeta2;
    IF( beta2 < 0.999 ) [ earray(i) = prm*1000.0*(1/sqrt(1-beta2)-1); ]
    ELSE [ earray(i) = 50585.1; ]
    $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
]

" Convert to MeV and set interpolation interavals"
/*
 * IK: Moved here Feb 4 2004.
 *     Bug found and reported by Dr Helmut Schlattl.
 */
espin_min = espin_min/1000; espin_max = espin_max/1000;
dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
espml = Log(espin_min);
dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;

DO medium = 1,NMED [
    $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
            DO j=0,$MAXQ_SPIN [
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = 0;
                ]
            ]
        ]
    ]
    /sum_Z2,sum_A,sum_pz,sum_Z/=0;
    DO i_ele=1,NNE(medium) [
        Z = ZELEM(medium,i_ele);
        iZ = int(Z+0.5);
        $FOOL-INTEL-OPTIMIZER(25) ' Z = ',iZ;
        tmp = PZ(medium,i_ele)*Z*(Z+1);
              "For now, we take into account the contribution of atomic"
              "electrons to elastic scattering by replacing Z**2 with  "
              "Z*(Z+1). The part of the scattering power that is taken "
              "into account by discrete Moller/Bhabha events is        "
              "substracted below => bc is energy dependent. We will    "
              "worry about better approaches in the future (a realistic"
              "inelastic scattering model is needed first)             "
        sum_Z2 = sum_Z2 + tmp;
        sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
        sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
        sum_pz = sum_pz + PZ(medium,i_ele);
        Z23    = Z**0.6666667;
        DO iq=0,1 [
            DO i=0,$MAXE_SPI1 [
                irec = 1 + (iz-1)*4*(n_ener+1) + 2*iq*(n_ener+1) + i+1;
                $FOOL-INTEL-OPTIMIZER(25) '**** energy ',i,earray(i),irec;
                read(spin_unit,rec=irec,err=:spin-read-error:)
                  dum1,dum2,dum3,aux_o,fmax_array,i2_array;
                IF( swap ) [
                  tmp_4 = dum1; call egs_swap_4(c_4); dum1 = tmp_4;
                  tmp_4 = dum2; call egs_swap_4(c_4); dum2 = tmp_4;
                  tmp_4 = dum3; call egs_swap_4(c_4); dum3 = tmp_4;
                  tmp_4 = aux_o; call egs_swap_4(c_4); aux_o = tmp_4;
                ]
                eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
                tau = earray(i)/prm*0.001;  "energy in the file is in keV"
                beta2 = tau*(tau+2)/(tau+1)**2;
                eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
                c_array(iq,i)=c_array(iq,i)+
                  tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
                g_array(iq,i)=g_array(iq,i)+tmp*dum2;
                DO j=0,$MAXQ_SPIN [
                    tmp_4 = fmax_array(j);
                    IF( swap ) call egs_swap_4(c_4);
                    DO k=0,$MAXU_SPIN [
                        ii2 = i2_array((n_point+1)*j + k+1);
                        IF( swap ) call egs_swap_2(c_2);
                        ii4 = ii2;
                        IF( ii4 < 0 ) ii4 = ii4 + 65536;
                        dum1 = ii4; dum1 = dum1*tmp_4/65535;
                        spin_rej(medium,iq,i,j,k) =
                          spin_rej(medium,iq,i,j,k) + tmp*dum1;
                    ]
                ]
            ]
        ]
    ]

    " spin_rej will be used as a rejection function in MS sampling, "
    " so scale maximum to unity"
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            DO j=0,$MAXQ_SPIN [
                fmax = 0;
                DO k=0,$MAXU_SPIN [
                    IF( spin_rej(medium,iq,i,j,k) > fmax )
                       [ fmax = spin_rej(medium,iq,i,j,k); ]
                ]
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
                ]
            ]
        ]
    ]

    " Process eta_array, c_array and g_array to their final form "
    $FOOL-INTEL-OPTIMIZER(25) 'Spin corrections as read in from file';
    DO i=0,$MAXE_SPI1 [
        tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
        DO iq=0,1 [
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
            eta = aux_o/4/tau/(tau+2);
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
                      (Log(1+1/eta)*(1+eta)-1);
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
        ]
        $FOOL-INTEL-OPTIMIZER(25) i,earray(i),eta_array(0,i),eta_array(1,i),
          c_array(0,i),c_array(1,i),g_array(0,i),g_array(1,i);
    ]

    " Prepare interpolation table for the screening parameter "
    eil = (1 - eke0(medium))/eke1(medium);
    e = Exp(eil);
    IF( e <= espin_min ) [
        si1e = eta_array(0,0); si1p = eta_array(1,0);
    ]
    ELSE [
        IF( e <= espin_max ) [
            aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
        ]
        ELSE [
            tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
            aae = (beta2 - b2spin_min)*dbeta2i;
            je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
        ]
        si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
        si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
    ]
    neke = meke(medium);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for eta correction';
    DO i = 1,neke - 1 [
        eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
        IF( e <= espin_min ) [
            si2e = eta_array(0,0); si2p = eta_array(1,0);
        ]
        ELSE [
            IF( e <= espin_max ) [
                aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
            ]
            ELSE [
                tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
                aae = (beta2 - b2spin_min)*dbeta2i;
                je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
            ]
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
        ]
        etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
        etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
        etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) i,e,si2e,si2p,etae_ms1(i,medium),
         etae_ms0(i,medium),etap_ms1(i,medium),etap_ms0(i,medium);
        si1e = si2e; si1p = si2p;
    ]
    etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
    etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
    etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
    etap_ms0(neke,medium) = etap_ms0(neke-1,medium);

    "Prepare correction to the first MS moment due to spin effects"
    "first electrons"
    $FOOL-INTEL-OPTIMIZER(25) 'elarray:';
    DO i=0,$MAXE_SPIN [
        elarray(i) = Log(earray(i)/1000);
        farray(i) = c_array(0,i);
        $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i);
    ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
        elarray(i) = Log(earray(i+1)/1000);
        farray(i) = c_array(0,i+1);
        $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i+1);
    ]
    ndata = $MAXE_SPI1+1;
    IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
    ELSE [ elarray(ndata-1) = Log(1e5); ]
    farray(ndata-1) = 1;
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e-)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1ce_ms1(i,medium),
          q1ce_ms0(i,medium);
        si1e = si2e;
    ]
    q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
    q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
    "now positrons"
    $FOOL-INTEL-OPTIMIZER(25) 'Postrons:';
    DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e+)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1cp_ms1(i,medium),
          q1cp_ms0(i,medium);
        si1e = si2e;
    ]
    q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
    q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);

    "prepare interpolation table for the second MS moment correction"
    "e-"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e-)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2ce_ms1(i,medium),
          q2ce_ms0(i,medium);
        si1e = si2e;
    ]
    q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
    q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
    "e+"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e+)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2cp_ms1(i,medium),
          q2cp_ms0(i,medium);
        si1e = si2e;
    ]
    q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
    q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);

    "Now substract scattering power that is already taken into account in"
    "discrete Moller/Bhabha events"
    tauc = te(medium)/prm;
    si1e = 1;
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        e = Exp(eil); leil=i+1; tau=e/prm;
        IF( tau > 2*tauc ) [
            $EVALUATE sig USING esig(eil);
            $EVALUATE dedx USING ededx(eil);
            sig = sig/dedx;
            IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
                $EVALUATE etap USING etae_ms(eil);
                eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
                g_r = (1+2*eta)*Log(1+1/eta)-2;
                g_m = Log(0.5*tau/tauc)+
                 (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
                 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
                    Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
                 0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
                IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
                si2e = 1 - g_m*sum_Z/sum_Z2;
            ] ELSE [ si2e = 1; ]
        ] ELSE [ si2e = 1; ]
        blcce1(i,medium) = (si2e - si1e)*eke1(medium);
        blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
        si1e = si2e;
    ]
    blcce1(neke,medium) = blcce1(neke-1,medium);
    blcce0(neke,medium) = blcce0(neke-1,medium);

    "We will not bother to do the same for positrons at this time"

    $egs_info('(a)',' done');
]
close(spin_unit);
return;

:spin-open-error:
$egs_fatal('(a,a)','Failed to open spin data file ',$cstring(spin_file));

:spin-read-error:
$egs_fatal(*,'Error while reading spin data file for element',iZ);

return; end;
%E

subroutine init_spin_old;
"======================================================================="
"                                                                       "
" Reads in spin rejection data for multiple elastic scattering and      "
" initializes interpolation arrays for the screening parameter,         "
" elastic cross section, first and second MS moments                    "
"                                                                       "
" This version uses the old EGSnrc ASCII spin data format.              "
" If the installation failed to figure out the byte order of your       "
" machine, rename this subroutine to init_spin, the current init_spin   "
" to init_spin_new (or whatever) and download the old spinms data       "
" directory.
"                                                                       "
" I. Kawrakow, NRC                                                      "
"======================================================================="

implicit none;
$declare_max_medium;
COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
                            "BREMPR is needed for the elemental composition"

$REAL         eta_array(0:1,$0-MAXE_SPI1),
              c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
              earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
              sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
              dum1,dum2,dum3,aux_o,tau,tauc,beta2,eta,gamma,fmax,
              eil,e,si1e,si2e,si1p,si2p,aae,etap,
              elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
              af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
              df($0-MAXE_SPI1),spline;

$INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
              ndata,leil,length,want_spin_unit,spin_unit,egs_get_unit;

character     spin_file*256;
character*6   string;
integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
                       "do not have lnblnk, we supply lnblnk1 in this file
$declare_write_buffer;

$REAL        fine,TF_constant;
parameter    (fine=137.03604, TF_constant=0.88534138);

" First construct the path to the spin dbase directory "
$set_string(spin_file,' ');
spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms' //
             $file_sep // 'z000';
length = lnblnk1(spin_file);

DO medium = 1,NMED [
    $egs_info('(a,i4,a,$)','  Initializing spin data for medium ',medium,
                          ' ..................... ');
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
            DO j=0,$MAXQ_SPIN [
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = 0;
                ]
            ]
        ]
    ]
    /sum_Z2,sum_A,sum_pz,sum_Z/=0;
    DO i_ele=1,NNE(medium) [
        Z = ZELEM(medium,i_ele);
        iZ = int(Z+0.5);
        tmp = PZ(medium,i_ele)*Z*(Z+1);
              "For now, we take into account the contribution of atomic"
              "electrons to elastic scattering by replacing Z**2 with  "
              "Z*(Z+1). The part of the scattering power that is taken "
              "into account by discrete Moller/Bhabha events is        "
              "substracted below => bc is energy dependent. We will    "
              "worry about better approaches in the future (a realistic"
              "inelastic scattering model is needed first)             "
        iii = iZ/100; spin_file(length-2:length-2) = char(iii+48);
        iiZ = iZ - iii*100;
        iii = iiZ/10; spin_file(length-1:length-1) = char(iii+48);
        iiZ = iiZ - 10*iii;
        spin_file(length:length) = char(iiZ+48);
        want_spin_unit = 61;
        spin_unit = egs_get_unit(want_spin_unit);
        IF( spin_unit < 1 ) [
            $egs_fatal(*,'init_spin: failed to get a free fortran unit');
        ]
        open(spin_unit,file=spin_file,status='old',err=:SPIN-DBASE-ERROR:);
        read(spin_unit,*) espin_min,espin_max,b2spin_min,b2spin_max;
        read(spin_unit,*) n_ener,n_q,n_point;
        IF( n_ener ~= $MAXE_SPIN | n_q ~= $MAXQ_SPIN | n_point ~= $MAXU_SPIN) [
            $egs_fatal(*,' Wrong spin file for Z = ',iZ);
        ]
        sum_Z2 = sum_Z2 + tmp;
        sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
        sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
        sum_pz = sum_pz + PZ(medium,i_ele);
        Z23    = Z**0.6666667;
        DO iq=0,1 [
            read(spin_unit,*); read(spin_unit,*);
            DO i=0,$MAXE_SPI1 [
                read(spin_unit,'(a,g14.6)') string,earray(i);
                read(spin_unit,*) dum1,dum2,dum3,aux_o;
                eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
                tau = earray(i)/prm*0.001;  "energy in the file is in keV"
                beta2 = tau*(tau+2)/(tau+1)**2;
                eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
                c_array(iq,i)=c_array(iq,i)+
                  tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
                g_array(iq,i)=g_array(iq,i)+tmp*dum2;
                DO j=0,$MAXQ_SPIN [
                    read(spin_unit,*) tmp_array;
                    DO k=0,$MAXU_SPIN [
                        spin_rej(medium,iq,i,j,k) =
                          spin_rej(medium,iq,i,j,k) + tmp*tmp_array(k);
                    ]
                ]
            ]
        ]
        close(spin_unit);
    ]

    " spin_rej will be used as a rejection function in MS sampling, "
    " so scale maximum to unity"
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            DO j=0,$MAXQ_SPIN [
                fmax = 0;
                DO k=0,$MAXU_SPIN [
                    IF( spin_rej(medium,iq,i,j,k) > fmax )
                       [ fmax = spin_rej(medium,iq,i,j,k); ]
                ]
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
                ]
            ]
        ]
    ]

    " Process eta_array, c_array and g_array to their final form "
    DO i=0,$MAXE_SPI1 [
        tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
        DO iq=0,1 [
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
            eta = aux_o/4/tau/(tau+2);
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
                      (Log(1+1/eta)*(1+eta)-1);
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
        ]
    ]

    " Convert to MeV and set interpolation interavals"
    espin_min = espin_min/1000; espin_max = espin_max/1000;
    dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
    espml = Log(espin_min);
    dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
    dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;

    " Prepare interpolation table for the screening parameter "
    eil = (1 - eke0(medium))/eke1(medium);
    e = Exp(eil);
    IF( e <= espin_min ) [
        si1e = eta_array(0,0); si1p = eta_array(1,0);
    ]
    ELSE [
        IF( e <= espin_max ) [
            aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
        ]
        ELSE [
            tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
            aae = (beta2 - b2spin_min)*dbeta2i;
            je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
        ]
        si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
        si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
    ]
    neke = meke(medium);
    DO i = 1,neke - 1 [
        eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
        IF( e <= espin_min ) [
            si2e = eta_array(0,0); si2p = eta_array(1,0);
        ]
        ELSE [
            IF( e <= espin_max ) [
                aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
            ]
            ELSE [
                tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
                aae = (beta2 - b2spin_min)*dbeta2i;
                je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
            ]
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
        ]
        etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
        etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
        etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
        si1e = si2e; si1p = si2p;
    ]
    etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
    etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
    etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
    etap_ms0(neke,medium) = etap_ms0(neke-1,medium);

    "Prepare correction to the first MS moment due to spin effects"
    "first electrons"
    DO i=0,$MAXE_SPIN [
        elarray(i) = Log(earray(i)/1000);
        farray(i) = c_array(0,i);
    ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
        elarray(i) = Log(earray(i+1)/1000);
        farray(i) = c_array(0,i+1);
    ]
    ndata = $MAXE_SPI1+1;
    IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
    ELSE [ elarray(ndata-1) = Log(1e5); ]
    farray(ndata-1) = 1;
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
        si1e = si2e;
    ]
    q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
    q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
    "now positrons"
    DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
        si1e = si2e;
    ]
    q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
    q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);

    "prepare interpolation table for the second MS moment correction"
    "e-"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
        si1e = si2e;
    ]
    q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
    q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
    "e+"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
    ]
    q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
    q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);

    "Now substract scattering power that is already taken into account in"
    "discrete Moller/Bhabha events"
    tauc = te(medium)/prm;
    si1e = 1;
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        e = Exp(eil); leil=i+1; tau=e/prm;
        IF( tau > 2*tauc ) [
            $EVALUATE sig USING esig(eil);
            $EVALUATE dedx USING ededx(eil);
            sig = sig/dedx;
            IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
                $EVALUATE etap USING etae_ms(eil);
                eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
                g_r = (1+2*eta)*Log(1+1/eta)-2;
                g_m = Log(0.5*tau/tauc)+
                 (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
                 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
                    Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
                 0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
                IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
                si2e = 1 - g_m*sum_Z/sum_Z2;
            ] ELSE [ si2e = 1; ]
        ] ELSE [ si2e = 1; ]
        blcce1(i,medium) = (si2e - si1e)*eke1(medium);
        blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
        si1e = si2e;
    ]
    blcce1(neke,medium) = blcce1(neke-1,medium);
    blcce0(neke,medium) = blcce0(neke-1,medium);

    "We will not bother to do the same for positrons at this time"

    $egs_info('(a)',' done');
]
return;

:SPIN-DBASE-ERROR:
$egs_info(*,' ******************** Error in init_spin ******************* ');
$egs_info('(a,a)','  could not open file ',spin_file);
$egs_fatal(*,' terminating execution ');

end;
%E
; "buffer flush

"======================================================================"
"                 subroutine msdist_pII                                "
"                 =====================                                "
"                                                                      "
"  This subroutine models multiple elastic scattering and spatial      "
"  deflections for a given path-length tustep.                         "
"  For description of input and output variables see below             "
"                                                                      "
"  September 1996      Iwan Kawrakow        Initial coding (in fortran)"
"  March 1997          Alex Bielajew        Adaption for EGS4          "
"  April/Mai 1997      Iwan Kawrakow        Debuging of the EGS4       "
"                                           mortran version by Bielajew"
"  June 1997           Iwan Kawrakow        Improved energy loss       "
"                                           corrections                "
"  June 1999           Iwan Kawrakow        spin effects, removed      "
"                                           $SUBSTEP-ELOSS-EVALUATION  "
"                                                                      "
"======================================================================"
"                                                                      "
subroutine msdist_pII
(
    e0,eloss,tustep,rhof,med,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
    us,vs,ws,xf,yf,zf,ustep                                         "Outputs
);

$IMPLICIT-NONE;

" Input variables
" ===============
$REAL
    e0,     "electron kinetic energy at the beginning of step
    eloss,  "energy loss for this step
    rhof,   "density scaling template (as in EGS)
    tustep, "total pathlength of the step,
    u0,     "x-direction cosine before scattering
    v0,     "y-direction cosine before scattering
    w0,     "z-direction cosine before scattering
    x0,     "initial x-position
    y0,     "initial y-position
    z0      "initial z-position
;
$INTEGER
    med,"medium number
    qel    "=0 for e-, =1 for e+, needed for spin effects
;
$LOGICAL
    spin_effects;
;

" Output variables
" ================
$REAL
    us,    "x-direction cosine after scattering
    vs,    "y-direction cosine after scattering
    ws,    "z-direction cosine after scattering
    xf,    "final x-position after transport
    yf,    "final y-position after transport
    zf,    "final z-position after transport
    ustep  "straight line distance between the initial and final position
;

" Local variables
" ===============
$REAL
    b,         "substep transport distance,
    blccc,     "multiple scattering parameter
    xcccc,     "multiple scattering parameter
    c,         "substep transport distance,
    eta,eta1,  "randomization of the substep transport distances
    chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
    chilog,    "log(1+1/chia2)
    cphi0,     "cosine of the azimuthal angle of the initial particle relative
               "to its coordinates
    cphi1,     "cosine of the first azimuthal angle
    cphi2,     "cosine of the second azimuthal angle
    w1,        "cosine of the first substep polar scattering angle
    w2,        "cosine of the second substep polar scattering angle
    w1v2,      "w1*v2;
    delta,     "transport parameter (see paper)
    e,         "average kinetic energy over the step
    elke,      "Log(e)"
    beta2,     "speed at e in units of c, squared"
    etap,      "correction to the screening parameter derived from PWA
    xi_corr,   "correction to the first MS moments due to spin
    ms_corr,
    tau,       "average kinetic energy over the step divided by electron mass
    tau2,      "tau squared
    epsilon,   "fractional energy loss
    epsilonp,  "fractional energy loss
    temp,temp1,"auxilarity variables for energy loss corrections
    temp2,     "
    factor,    "intermediate factor employed in the energy-loss calculations
    gamma,     "q2/q1
    lambda,    "distance in number of elastic scattering mean free paths
               "for each sample of the multiple scattering angle
    p2,        "average momentum over the step
    p2i,       "inverse of ap2
    q1,        "first moment of the single scattering cross section
    rhophi2,   "xphi**2 + yphi**2 or its inverse
    sint0,     "sine of the initial particle relative to its coordinates
    sint02,    "sint0**2
    sint0i,    "1/sint0
    sint1,     "sine   of the first substep polar scattering angle
    sint2,     "sine   of the second substep polar scattering angle
    sphi0,     "sine of the azimuthal angle of the initial particle relative
               "to its coordinates
    sphi1,     "sine   of the first azimuthal angle
    sphi2,     "sine   of the second azimuthal angle
    u2p,       "intermediate scatter or transport direction cosine
    u2,        "sint2*cphi2;
    v2,        "sint2*sphi2;
    ut,        "x-direction cosine for transport
    vt,        "y-direction cosine for transport
    wt,        "z-direction cosine for transport
    xi,        "first GS - moment
    xphi,      "x - used to calculated azimuthal angles
    xphi2,     "xphi**2
    yphi,      "y - used to calculated azimuthal angles
    yphi2      "yphi**2
;
$LOGICAL
   find_index,  "needed to save locating the q2 index in the 2. call to mscat"
   spin_index   "saves locating the spin rejection index in 2. call to mscat"
;
$INTEGER
   lelke
;
$declare_max_medium;
;COMIN/ELECIN,THRESH,UPHIOT,RANDOM,CH-Steps,USEFUL,EMF-INPUTS/;
;COMIN/EM/;
medium  = med;

count_pII_steps = count_pII_steps + 1;
blccc   = blcc(medium);
xcccc   = xcc(medium);

"Commonly used factors
e       = e0 - 0.5*eloss;
tau     = e/prm;
tau2    = tau*tau;
epsilon = eloss/e0;
epsilonp= eloss/e;
"e       = e * (1 - epsilonp*epsilonp*((6+tau*(10+5*tau))/(tau+1)/(tau+2))/24);
e       = e * (1 - epsilonp*epsilonp*(6+10*tau+5*tau2)/(24*tau2+72*tau+48));
p2      = e*(e + rmt2);
"p2i     = 1/p2;
beta2   = p2/(p2 + rmsq);
"chia2   = xcccc*p2i/(4*blccc);
chia2   = xcccc/(4*p2*blccc);
lambda  = 0.5*tustep*rhof*blccc/beta2; "The 0.5 implies a half-step

temp2  = 0.166666*(4+tau*(6+tau*(7+tau*(4+tau))))*
             (epsilonp/((tau+1)*(tau+2)))**2;
lambda = lambda*(1 - temp2);

IF ( spin_effects ) [
   elke = Log(e);
   $SET INTERVAL elke,eke;
   IF ( lelke < 1 ) [ "This should normally not happen"
       lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
   ]
   IF( qel = 0 ) [
       $EVALUATE etap USING etae_ms(elke);
       $EVALUATE xi_corr USING q1ce_ms(elke);
       $EVALUATE gamma USING q2ce_ms(elke);
   ]
   ELSE [
       $EVALUATE etap USING etap_ms(elke);
       $EVALUATE xi_corr USING q1cp_ms(elke);
       $EVALUATE gamma USING q2cp_ms(elke);
   ]
   $EVALUATE ms_corr USING blcce(elke);
]
ELSE [ etap = 1; xi_corr = 1; gamma = 1; ms_corr = 1; ]

chia2  = chia2*etap;
lambda = lambda/(etap*(1+chia2))*ms_corr;
chilog = Log(1 + 1/chia2);
q1     = 2*chia2*(chilog*(1 + chia2) - 1);
gamma  = 6*chia2*(1 + chia2)*(chilog*(1 + 2*chia2) - 2)/q1*gamma;
xi     = q1*lambda;

"Sample first substep scattering angle
find_index = .true.; spin_index = .true.;
call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
           spin_effects,find_index,spin_index,
           w1,sint1);
$SELECT-AZIMUTHAL-ANGLE(cphi1,sphi1);

"Sample second substep scattering angle
call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
           spin_effects,find_index,spin_index,
           w2,sint2);
$SELECT-AZIMUTHAL-ANGLE(cphi2,sphi2);

"Final direction of motion, relative to z-axis motion
u2  = sint2*cphi2;
v2  = sint2*sphi2;
u2p = w1*u2 + sint1*w2;
us  = u2p*cphi1 - v2*sphi1;
vs  = u2p*sphi1 + v2*cphi1;
ws  = w1*w2 - sint1*u2;

"Calculate delta, b, c

xi = 2*xi*xi_corr;  "xi was for half step, xi_corr corrects for spin effects

$RANDOMSET eta; eta = Sqrt(eta); eta1 = 0.5*(1 - eta);
delta  = 0.9082483-(0.1020621-0.0263747*gamma)*xi;

"Correct the coefficients for energy loss
temp1 = 2 + tau;
temp = (2+tau*temp1)/((tau+1)*temp1);
"Take logarithmic dependence into account as well
temp = temp - (tau+1)/((tau+2)*(chilog*(1+chia2)-1));
temp = temp * epsilonp;
temp1 = 1 - temp;
delta = delta + 0.40824829*(epsilon*(tau+1)/((tau+2)*
          (chilog*(1+chia2)-1)*(chilog*(1+2*chia2)-2)) - 0.25*temp*temp);
           "0.40824829 is 1/Sqrt(6)"
b      = eta*delta;
c      = eta*(1-delta);

"Calculate transport direction cosines
w1v2 = w1*v2;
ut   = b*sint1*cphi1 + c*(cphi1*u2 - sphi1*w1v2) + eta1*us*temp1;
vt   = b*sint1*sphi1 + c*(sphi1*u2 + cphi1*w1v2) + eta1*vs*temp1;
wt   = eta1*(1+temp) +        b*w1 +  c*w2       + eta1*ws*temp1;

"Calculate transport distance
ustep  = tustep*sqrt(ut*ut + vt*vt + wt*wt);

"Rotate into the final direction of motion and transport
"relative to original direction of motion
sint02 = u0**2 + v0**2;
IF (sint02 > 1e-20)
[
    sint0  = sqrt(sint02);
    sint0i = 1/sint0;
    cphi0  = sint0i*u0;
    sphi0  = sint0i*v0;

    "Scattering angles
    u2p    = w0*us + sint0*ws;
    ws     = w0*ws - sint0*us;
    us     = u2p*cphi0 - vs*sphi0;
    vs     = u2p*sphi0 + vs*cphi0;

    "Transport angles
    u2p    = w0*ut + sint0*wt;
    wt     = w0*wt - sint0*ut;
    ut     = u2p*cphi0 - vt*sphi0;
    vt     = u2p*sphi0 + vt*cphi0;
]
ELSE [ wt = w0*wt; ws = w0*ws; ]

$EMFIELD_PII;
"Transport
xf = x0 + tustep*ut;
yf = y0 + tustep*vt;
zf = z0 + tustep*wt;

return;
end;

;

"                 subroutine msdist_pI                                 "
"                 ====================                                 "
"                                                                      "
"  This subroutine models multiple elastic scattering and spatial      "
"  deflections for a given path-length tustep                          "
"  resampling PRESTA-I behaviour.                                      "
"                                                                      "
"  October 1997        Iwan Kawrakow        Initial coding             "
"  June    1999        Iwan Kawrakow        spin effects               "
"                                                                      "
"======================================================================"
"                                                                      "
subroutine msdist_pI
(
    e0,eloss,tustep,rhof,medium,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
    us,vs,ws,xf,yf,zf,ustep                                         "Outputs
);

$IMPLICIT-NONE;

" Input variables
" ===============
$REAL
    e0,     "electron kinetic energy at the beginning of step
    eloss,  "energy loss for this step
    rhof,   "density scaling template (as in EGS)
    tustep, "total pathlength of the step,
    u0,     "x-direction cosine before scattering
    v0,     "y-direction cosine before scattering
    w0,     "z-direction cosine before scattering
    x0,     "initial x-position
    y0,     "initial y-position
    z0      "initial z-position
;
$INTEGER
    medium,"medium number
    qel    "=0 for e-, =1 for e+, needed for spin effects
;
$LOGICAL
    spin_effects
;

" Output variables
" ================
$REAL
    us,    "x-direction cosine after scattering
    vs,    "y-direction cosine after scattering
    ws,    "z-direction cosine after scattering
    xf,    "final x-position after transport
    yf,    "final y-position after transport
    zf,    "final z-position after transport
    ustep  "straight line distance between the initial and final position
;

" Local variables
" ===============
$REAL
    blccc,     "multiple scattering parameter
    xcccc,     "multiple scattering parameter
    z,r,z2,r2, "used to calculate PLC and lateral deflection a la PRESTA-I
    r2max,
    chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
    chilog,    "log(1+1/chia2)
    cphi0,     "cosine of the azimuthal angle of the initial particle relative
               "to its coordinates
    cphi,      "cosine of the azimuthal scattering angle
    sphi,      "sine of the  azimuthal scattering angle
    e,         "average kinetic energy over the step
    elke,      "Log(e)
    beta2,     "speed at e in units of c, squared
    etap,      "correction to the screening angle derived from PWA
    xi_corr,   "correction to the first MS moment due to spin
    ms_corr,
    epsilon,   "fractional energy loss
    temp,      "auxilarity variable for energy loss corrections
    factor,    "intermediate factor employed in the energy-loss calculations
    lambda,    "distance in number of elastic scattering mean free paths
    p2,        "average momentum over the step
    p2i,       "inverse of p2
    q1,        "first moment of the single scattering cross section
    rhophi2,   "xphi**2 + yphi**2 or its inverse
    sint,      "sine of the MS angle
    sint0,     "sine of the initial particle relative to its coordinates
    sint02,    "sint0**2
    sint0i,    "1/sint0
    sphi0,     "sine of the azimuthal angle of the initial particle relative
               "to its coordinates
    u2p,       "intermediate scatter or transport direction cosine
    ut,        "x-direction cosine for transport
    vt,        "y-direction cosine for transport
    wt,        "z-direction cosine for transport
    xi,        "first GS - moment
    xphi,      "x - used to calculated azimuthal angles
    xphi2,     "xphi**2
    yphi,      "y - used to calculated azimuthal angles
    yphi2      "yphi**2
;
$LOGICAL
   find_index, "needed to save locating the q2 index in the 2. call to mscat"
   spin_index
;
$INTEGER
   lelke
;
$declare_max_medium;
;COMIN/ELECIN,THRESH,UPHIOT,RANDOM,EMF-INPUTS/;
;COMIN/EM/;
blccc   = blcc(medium);
xcccc   = xcc(medium);

e       = e0 - 0.5*eloss;
p2      = e*(e + rmt2);
p2i     = 1/p2;
chia2   = xcccc*p2i/(4*blccc);
beta2   = p2/(p2 + rmsq);
lambda  = tustep*rhof*blccc/beta2;

"Account for energy loss in the MS distribution
factor = 1/(1 + 0.9784671*e); "0.9784671 = 1/(2*rm)
epsilon= eloss/e0;
epsilon= epsilon/(1-0.5*epsilon);
temp   = 0.25*(1 - factor*(1 - 0.333333*factor))*epsilon**2;
lambda = lambda*(1 + temp);

IF ( spin_effects ) [
   elke = Log(e);
   $SET INTERVAL elke,eke;
   IF ( lelke < 1 ) [ "This should normally not happen"
       lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
   ]
   IF( qel = 0 ) [
       $EVALUATE etap USING etae_ms(elke);
       $EVALUATE xi_corr USING q1ce_ms(elke);
   ]
   ELSE [
       $EVALUATE etap USING etap_ms(elke);
       $EVALUATE xi_corr USING q1cp_ms(elke);
   ]
   $EVALUATE ms_corr USING blcce(elke);
]
ELSE [ etap = 1; xi_corr = 1; ms_corr = 1; ]

chia2   = xcccc*p2i/(4*blccc)*etap;
lambda = lambda/etap/(1+chia2)*ms_corr;
chilog = Log(1 + 1/chia2);
q1     = 2*chia2*(chilog*(1 + chia2) - 1);
xi     = q1*lambda;

"Sample multiple scattering angle
find_index = .true.; spin_index = .true.;
call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
           spin_effects,find_index,spin_index,
           ws,sint);
$SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
us  = sint*cphi;
vs  = sint*sphi;

"Correct xi used for the PLC calc. for spin effects
xi     = xi*xi_corr;

"Calculate PLC and lateral transport a la PRESTA-I
"Note that we use here the exact expression for <z>
"because it is much simpler and faster than the original PRESTA-I formulas
"(which are also second order approximations)
IF ( xi < 0.1 )
[
   z = 1 - xi*(0.5 - xi*(0.166666667 - 0.041666667*xi));
]
ELSE
[
   z = (1 - Exp(-xi))/xi;
]
r  = 0.5*sint;
r2 = r*r; z2 = z*z;
r2max = 1 - z2;
IF ( r2max < r2 ) [ r2 = r2max; r = Sqrt(r2); ]

"Calculate final position vector
ut   = r*cphi; vt = r*sphi; wt = z;

"Calculate transport distance
ustep = Sqrt(z2 + r2)*tustep;

"Rotate into the final direction of motion and transport
"relative to original direction of motion
sint02 = u0**2 + v0**2;
IF (sint02 > 1e-20)
[
    sint0  = sqrt(sint02);
    sint0i = 1/sint0;
    cphi0  = sint0i*u0;
    sphi0  = sint0i*v0;

    "Scattering angles
    u2p    = w0*us + sint0*ws;
    ws     = w0*ws - sint0*us;
    us     = u2p*cphi0 - vs*sphi0;
    vs     = u2p*sphi0 + vs*cphi0;

    "Transport angles
    u2p    = w0*ut + sint0*wt;
    wt     = w0*wt - sint0*ut;
    ut     = u2p*cphi0 - vt*sphi0;
    vt     = u2p*sphi0 + vt*cphi0;
]
ELSE [ wt = w0*wt; ws = w0*ws; ]

$EMFIELD_PI;
"Transport
xf = x0 + tustep*ut;
yf = y0 + tustep*vt;
zf = z0 + tustep*wt;

return;
end;

;
%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE PAIR;
"                                                                  "
"******************************************************************"
"   For a photon energy below 2.1 MeV, the energies of the pair    "
"   particles are uniformly distributed in the allowed range via   "
"   the default replacement for $SELECT-LOW-ENERGY-PAIR-PRODICTION;"
"   If the user has a better approach, modify this macro.          "
"   For a photon energy between 2.1 and 50 MeV the Bethe-Heitler   "
"   cross section is employed, above 50 MeV the Coulomb-corrected  "
"   Bethe-Heitler is used.                                         "
"   Modified from its original version to make compatible with the "
"   changes made in BREMS.                                         "
"                                                                  "
"   I. Kawrakow                                                    "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-PAIR;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,STACK,"
                                 "THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-PAIR;

$DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;

$REAL    k,xx,abin,rbin,alias_sample1;
$INTEGER ibin, iq1, iq2, iprdst_use;
$LOGICAL do_nrc_pair;
$INTEGER itrip;
$REAL    ftrip;

NPold = NP;      "Set the old stack counter"

IF( i_play_RR = 1 ) [ " The user wants to play Russian Roulette. For pair "
                      " it is much more efficient to do it BEFORE the "
                      " actual sampling "
    i_survived_RR = 0;  "flag they all survive inititally"
    IF( prob_RR <= 0 ) [
        IF( n_RR_warning < $MAX-RR-WARNING ) [
          n_RR_warning = n_RR_warning + 1;
          $egs_warning('(a,g14.6)',
                      'Attempt to play Russian Roulette with prob_RR<0! ');
        ]
    ]
    ELSE [
        $RANDOMSET rnno_RR;
        IF( rnno_RR > prob_RR ) [  "The pair was killed "
            i_survived_RR =2; "flag both particles eliminated"
            IF( np > 1 ) [ np = np-1; ]
            ELSE [ " We have just one photon left on the stack. In order to  "
                   " get a proper exit from PHOTO, we have to leave at least "
                   " one particle on the stack                               "
                wt(np) = 0; e(np) = 0;
            ]
            return;
        ]
        ELSE [ "The pair survived, increase the weight"
            wt(np) = wt(np)/prob_RR;
        ]
    ]
]

$CHECK-STACK(np+1,'PAIR');
PEIG=E(NP); "PRECISE ENERGY OF INCIDENT GAMMA"
EIG=PEIG;   "ENERGY OF INCIDENT GAMMA"
do_nrc_pair = .false.;

IF( itriplet > 0 & eig > 4*rm ) [
    itrip = dli_triplet*gle + bli_triplet;
    ftrip = a_triplet(itrip,medium)*gle + b_triplet(itrip,medium);
    $RANDOMSET rnno34;
    IF( rnno34 < ftrip ) [  " Triplet production "
        call sample_triplet;
        return;
    ]
]

IF( pair_nrc = 1 ) [  "Sample from the NRC pair cross section data base"
                      "(privided the energy is within the available range)"
    k = eig/rm;
    IF( k < nrcp_emax ) [
        do_nrc_pair = .true.;
        IF( k <= nrcp_emin ) [ ibin = 1; ]
        ELSE [
            abin = 1 + log((k-2)/(nrcp_emin-2))*nrcp_dlei;
            ibin = abin; abin = abin - ibin;
            $RANDOMSET rbin;
            IF( rbin < abin ) ibin = ibin + 1;
        ]
        xx = alias_sample1($NRC-PAIR-NX-1,nrcp_xdata,
                nrcp_fdata(1,ibin,medium),nrcp_wdata(1,ibin,medium),
                nrcp_idata(1,ibin,medium));
           " The above returns the energy fraction of the positron "
        IF( xx > 0.5 ) [
            pese1 = prm*(1 + xx*(k-2)); iq1 = 1;
            pese2 = peig - pese1; iq2 = -1;
        ]
        ELSE [
            pese2 = prm*(1 + xx*(k-2)); iq2 = 1;
            pese1 = peig - pese2; iq1 = -1;
        ]
    ]
]


IF( ~do_nrc_pair ) [
IF (EIG.LE.2.1) [
    "   BELOW 2.1,USE APPROXIMATION"
    $SELECT-LOW-ENERGY-PAIR-PRODICTION;
]
ELSE[   "ABOVE 2.1, MUST SAMPLE"

    "   DECIDE WHETHER TO USE BETHE-HEITLER or BH
    "   COULOMB CORRECTED

    IF (EIG.LT.50.) [ "Use BH without Coulomb correction"

        L = 5;
        L1 = L + 1;

        "Find the actual rejection maximum for this photon energy"
        delta = 4*delcm(medium)/eig;
        IF( delta < 1 ) [
           Amax = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
           Bmax = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
        ]
        ELSE [
           aux2 = log(delta+dl6(l,medium));
           Amax = dl4(l,medium)+dl5(l,medium)*aux2;
           Bmax = dl4(l1,medium)+dl5(l1,medium)*aux2;
        ]
        "and then calculate the probability for sampling from (br-1/2)**2"
        aux1 = 1 - rmt2/eig; aux1 = aux1*aux1;
        aux1 = aux1*Amax/3; aux1 = aux1/(Bmax+aux1);
    ]
    ELSE [
        "Use BH Coulomb-corrected"
        L = 7;
        "The absolute maxima are close to the actual maxima at high energies"
        "=>use the absolute maxima to save time"
        Amax = dl1(l,medium); Bmax = dl1(l+1,medium);
        aux1 = bpar(2,medium)*(1-bpar(1,medium)*rm/eig);
    ]

    del0 = eig*delcm(medium);
    Eavail = eig - rmt2;

    LOOP [

        $RANDOMSET RNNO30; $RANDOMSET RNNO31; $RANDOMSET RNNO34;
        IF( rnno30 > aux1 ) [ "use the uniform part"
            br = 0.5*rnno31;  rejmax = Bmax; l1 = l+1;
        ]
        ELSE [  "use the (br-1/2)**2 part of the distribution"
            $RANDOMSET rnno32; $RANDOMSET rnno33;
            br = 0.5*(1-max(rnno31,rnno32,rnno33));
            rejmax = Amax; l1 = l;
        ]
        Eminus = br*Eavail + rm;
        Eplus  = eig - Eminus;
        delta = del0/(Eminus*Eplus);
        IF( delta < 1 ) [
           rejf = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
        ]
        ELSE [
          rejf = dl4(l1,medium)+dl5(l1,medium)*log(delta+dl6(l1,medium));
        ]

    ] UNTIL ( rnno34*rejmax <= rejf );

    pese2 = Eminus; pese1 = peig - pese2;
    $RANDOMSET RNNO34;
    IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]

]
]

"   ENERGY GOING TO LOWER SECONDARY HAS NOW BEEN DETERMINED"
ESE2=PESE2;
E(NP)=PESE1; E(NP+1)=PESE2;
"   THIS AVERAGE ANGLE OF EMISSION FOR BOTH PAIR PRODUCTION AND"
"   BREMSSTRAHLUNG IS MUCH SMALLER THAN THE AVERAGE ANGLE OF"
"   MULTIPLE SCATTERING FOR DELTA T TRANSPORT=0.01 R.L."
"   THE INITIAL AND FINAL MOMENTA ARE COPLANAR "
"   SET UP A NEW 'ELECTRON'  "
$SET-PAIR-ANGLE;
" DEFAULT FOR $SET-PAIR-ANGLE; is to select the angle from the leading term"
" of the angular distribution "
CALL UPHI(1,1);
"   SET UP A NEW 'ELECTRON' "
NP=NP+1;
SINTHE=-SINTHE;
CALL UPHI(3,2);

IQ(NP)=iq2; IQ(NP-1)=iq1;
RETURN;
"END OF SUBROUTINE PAIR"    END;

"***************************************************************************"
"                                                                           "
" Sampling of triplet production events.                                    "
"                                                                           "
" The treatment is based on Borsellino's first Born approximation           "
" result (see Eq. 4B-3002 in the pair article of Motz, Olsen & Koch)        "
" As the kinematic of the process is already complicated enough and the     "
" cross section itself is not simple either, a Markov-chain method is used  "
" to sample triplet events from the Borsellino equation without any         "
" additional approximations (other then the use of the first Born           "
" approximation and the assumption of free electrons implied by             "
" Borsellino's derivation)                                                  "
"                                                                           "
" Iwan Kawrakow, April 2005.                                                "
"***************************************************************************"

subroutine sample_triplet;

"***************************************************************************"
implicit none;
$declare_max_medium;
;COMIN/EPCONT,STACK,MEDIA,THRESH,USEFUL,RANDOM,USER,EGS-IO/;
$declare_write_buffer;

" We use double precision throughout as in many cases the kinematically "
" permitted angular interval is too small to be resolved accurately enough "
" in single precision "

real*8 fmax_array($MAX_TRIPLET), eta_p_array($MAX_TRIPLET),
       eta_Ep_array($MAX_TRIPLET), eta_costp_array($MAX_TRIPLET),
       eta_costm_array($MAX_TRIPLET), ebin_array($MAX_TRIPLET),
       wp_array($MAX_TRIPLET), qmin_array($MAX_TRIPLET);

real*8 kmin, kmax, dlogki, alogkm, prmi, tiny_eta;

real*8 ai,rnno,k,qmin,qmax,aux,a1,a2,a3,D,px1,px2,pp_min,pp_max,
       Ep_min,Ep_max,k2p2,k2p2x,peig,b,aux1,aux12,D1,aux3,xmin,xmax,
       aux6,aux7,uu,cphi,sphi,cphi_factor,aux5,phi,tmp;
real*8 Er,pr,pr2,eta_pr;
real*8 Ep,pp,pp2,wEp,cost_p,sint_p,eta_Ep,mup_min,wmup,
       eta_costp,Epp,pp_sintp,pp_sntp2;
real*8 Em,pm,pm2,cost_m,sint_m,Emm,wmum,pm_sintm,
       eta_costm;
real*8 k2,k3,s2,s3,k2k3i,k22,k32,q2,aux4,S_1,S_2,sigma;
real*8 ppx, ppy, ppz, pmx, pmy, pmz, prx, pry, prz,
       a,c,sindel,cosdel,sinpsi;

$INTEGER i;
$LOGICAL use_it;
$INTEGER iscore; " needed for BEAM "

$LOGICAL is_initialized;
data is_initialized/.false./;
save is_initialized,fmax_array,eta_p_array,eta_Ep_array,eta_costp_array,
     eta_costm_array,ebin_array,wp_array,qmin_array,
     kmin,kmax,dlogki,alogkm,prmi,tiny_eta;

IF( ~is_initialized ) [
    is_initialized = .true.;
    tiny_eta = 1e-6;
    " Set current cross section value to -1 in each energy bin "
    DO i=1,$MAX_TRIPLET [ fmax_array(i) = -1; ]
    " Find the maximum energy of the cross section data "
    kmax = 0; kmin = 4.1*prm;
    DO i=1,nmed [ IF( up(i) > kmax ) kmax = UP(i); ]
    IF( kmax <= kmin ) return;
    dlogki = $MAX_TRIPLET - 1; dlogki = dlogki/log(kmax/kmin);
    alogkm = 1 - dlogki*log(kmin);
    prmi = 1/prm;
    DO i=1,$MAX_TRIPLET [
        k = 4.1*exp((i-1.)/dlogki); ebin_array(i) = k;
        qmin = 4*k/(k*(k-1)+(k+1)*sqrt(k*(k-4)));
        qmax = (k*(k-1) + (k+1)*sqrt(k*(k-4)))/(2*k+1);
        qmin_array(i) = qmin; wp_array(i) = log(qmax/qmin);
    ]
]

peig = e(np);
IF( peig <= 4*prm ) return;
$CHECK-STACK(np+2,'sample_triplet');

" Determine energy bin "
IF( peig <= kmin ) [ i = 1; ]
ELSE IF( peig >= kmax ) [ i = $MAX_TRIPLET; ]
ELSE [
    ai = alogkm + dlogki*gle; i = ai; ai = ai - i;
    $RANDOMSET rnno;
    IF( rnno < ai ) [ i = i+1; ]
]

" First use the bin energy to sample the random numbers "
" that determine recoil momentum and electron/postron angles "
k = ebin_array(i);

/*
   In the following:  k is incident photon energy in units of m*c^2
                      (all energies are in units of m*c^2, momenta in
                       units of m*c)
                      Er,pr is energy, momentum of the recoil electron
                      Ep,pp is energy, momentum of the pair positron
                      Em,pm is energy, momentum of the pair electron
                      cost_p, sint_p is cos, sin of the positron angle
                                     with respect to k
                      cost_m, sint_m same but for the electron
                      cphi is cos of azimuthal angle between positron
                              and pair electron directions.
*/

:retry_triplet:;

" Pick the recoil electron momentum from 1/p.
$RANDOMSET eta_pr; IF( eta_pr < tiny_eta ) eta_pr = tiny_eta;
pr = qmin_array(i)*exp(eta_pr*wp_array(i));
pr2 = pr*pr; Er = sqrt(1+pr2);

" Determine min./max. kinematically permitted postron energy for "
" this k and p "
aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
ELSE            [ pp_min = px2; pp_max = px1; ]
Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);

" Pick the positron energy "
$RANDOMSET eta_Ep; IF( eta_Ep < tiny_eta ) eta_Ep = tiny_eta;
wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;

" Now we can determine the pair electron energy from energy conservation "
Em = k + 1 - Er - Ep;
pm2 = Em*Em-1; pm = sqrt(pm2);

" The minimum cosine of the positron angle follows from the kinematics. "
mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);

" Now pick the positron direction from 1/(Ep-pp*cost_p) "
$RANDOMSET eta_costp; IF( eta_costp < tiny_eta ) eta_costp = tiny_eta;
Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
wmup = wmup*(cost_p - Epp);
sint_p = 1-cost_p*cost_p;
IF( sint_p > 1e-20 ) [ sint_p = sqrt(sint_p); ] ELSE [ sint_p = 1e-10; ]
k2p2x = k2p2 - 2*k*pp*cost_p;

" The minimum amd maximum cosine of the pair electron angle follows from "
" the kinematics "
b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
D1 = pm2*(aux12+pp_sntp2)-b*b/4;
if( D1 <= 0 ) [ goto :retry_triplet:; ]
D = 2*pp_sintp*sqrt(D1);
aux3 = 0.5/(aux12+pp_sntp2);
xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;

" Now pick the electron direction from "
"  1/(Em-pm*cost_m)/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) "
" We have to take into account the "
" 1/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) factor in the sampling "
" otherwise we end up with 1/sqrt() singularities near the ends of the "
" allowed cost_m range                                                 "
$RANDOMSET eta_costm; IF( eta_costm < tiny_eta ) eta_costm = tiny_eta;
aux6 = sqrt((Em-xmin)/(Em-xmax));
aux7 = aux6*tan(1.570796326794897*eta_costm);
uu = (aux7-1)/(aux7+1);
cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu));
wmum = sqrt((xmax-cost_m)*(cost_m-xmin));
wmum = wmum*aux6*(Em-cost_m)/(Em-xmin);
cost_m = cost_m/pm;
sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;

" Now we have selected all independent kinematic variables. "
" Determine the azimuthal angle between the pair electrons "
cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
sphi = sqrt(1-cphi*cphi);

" And now evaluate the Borsellino cross section "
k3 = k*(pp*cost_p - Ep); k2 = k*(pm*cost_m - Em);
k22 = k2*k2; k32 = k3*k3; k2k3i = 1/(k2*k3);
s2 = pp*pm*(cost_p*cost_m + sint_p*sint_m*cphi) - Ep*Em;
s3 = k2 - Em + 1 - s2; q2 = 2*(Er-1);
S_1 = k32+k22+(q2-2)*s2-(1-q2/2)*(k32+k22)*k2k3i;
aux4 = k3*Ep-k2*Em;
S_2 = -q2*(Ep*Ep+Em*Em) + 2*s2 - (2*aux4*aux4 - k22 - k32)*k2k3i;
sigma = abs(pp*pm2*pm*k2k3i/(q2*q2*(Em*s3+Er))*(S_1*(1-q2/4)+S_2*(1+q2/4)));

" We get the following factor due to the transformation from phi to "
" the recoil momentum pr "
cphi_factor = abs(2*Er*pm2-Em*(k2p2x-pr2-pm2))/(2*pp_sintp*pm_sintm*pm2*sphi);

" We have to also multiply by the various factors from the sampling of "
" pr, Ep, cost_p and cost_m "
sigma = sigma*cphi_factor*wEp*wmup*wmum*wp_array(i)*pr2/Er;
IF( sigma < 0 ) [
    $egs_warning(*,'In triplet sigma < 0 ? ',sigma);
]

" Now determine if we accept this new event "
use_it = .true.;
IF( sigma < fmax_array(i) ) [
    $RANDOMSET rnno;
    IF( sigma < fmax_array(i)*rnno ) [ use_it = .false. ]
]
IF( use_it ) [       " Yes, event accepted "
    fmax_array(i) = sigma;
    eta_p_array(i) = eta_pr; eta_Ep_array(i) = eta_Ep;
    eta_costp_array(i) = eta_costp; eta_costm_array(i) = eta_costm;
] ELSE [             " Nop, event rejected => use last accepted "
    eta_pr = eta_p_array(i); eta_Ep = eta_Ep_array(i);
    eta_costp = eta_costp_array(i); eta_costm = eta_costm_array(i);
]

" We now have a set of random number accepted for sampling around "
" the i'th bin energy. We need to recalculate all variables using "
" the actual photon energy "

k = peig*prmi;
aux5 = k*(k-1)+(k+1)*sqrt(k*(k-4));
qmin = 4*k/aux5; qmax = aux5/(2*k+1);
pr = qmin*exp(eta_pr*log(qmax/qmin));
pr2 = pr*pr; Er = sqrt(1+pr2);

aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
ELSE            [ pp_min = px2; pp_max = px1; ]
Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);

wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;
Em = k + 1 - Er - Ep;
pm2 = Em*Em-1; pm = sqrt(pm2);

mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);
Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
sint_p = sqrt(1-cost_p*cost_p);
k2p2x = k2p2 - 2*k*pp*cost_p;

b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
D1 = pm2*(aux12+pp_sntp2)-b*b/4;
if( D1 <= 0 ) [ goto :retry_triplet:; ]
D = 2*pp_sintp*sqrt(D1);
aux3 = 0.5/(aux12+pp_sntp2);
xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;
aux6 = sqrt((Em-xmin)/(Em-xmax));
aux7 = aux6*tan(1.570796326794897*eta_costm);
uu = (aux7-1)/(aux7+1);
cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))/pm;
sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;

cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
sphi = sqrt(1-cphi*cphi);

/*
   OK, now the final momenta are
     Positron:     (pp*sint_p,      0,             pp*cost_p)
     Electron:     (pm*sint_m*cphi,pm*sint_m*sphi, pm*cost_m)
 Recoil electron:  k - pp - pm
   This is in a frame where the photon is moving along the z axis.
   We have to pick another azimuthal angle randomly, rotate the
   x- and y- components of pp and pm by that, determine the recoil
   momentum from momentum conservation and then rotate all three
   momenta back into the lab frame.
*/
$RANDOMSET phi; phi = phi*6.283185307179586;
ppx = pp*sint_p; ppy = 0;
pmx = pm*sint_m*cphi; pmy = pm*sint_m*sphi;
cphi = cos(phi); sphi = sin(phi);
tmp = ppx*sphi; ppx = ppx*cphi - ppy*sphi; ppy = tmp + ppy*cphi;
tmp = pmx*sphi; pmx = pmx*cphi - pmy*sphi; pmy = tmp + pmy*cphi;
ppz = pp*cost_p; pmz = pm*cost_m;
prx = -ppx-pmx; pry = -ppy-pmy; prz = k - ppz - pmz;
" Set up particles on the stack ";
" We always put the recoil electron on top (even if its energy is higher "
" then the energies of the pair particles) because                       "
"   - that way, we know which particle is the recoil  electron in case   "
"     we want to score some quantity related to it                       "
"   - its energy is, on average, lower than the pair particle energies   "
NPold = np;
$TRANSFER PROPERTIES TO (np)   FROM (np);
$TRANSFER PROPERTIES TO (np+1) FROM (np);
$TRANSFER PROPERTIES TO (np+2) FROM (np+1);
pp = 1/pp; pm = 1/pm; pr = 1/pr;
a = u(np); b = v(np); c = w(np); sinpsi = a*a + b*b;
IF( sinpsi > 1e-20 ) [
    sinpsi = sqrt(sinpsi); sindel = b/sinpsi; cosdel = a/sinpsi;
    IF( Ep > Em ) [
        u(np)   = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
        v(np)   = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
        w(np)   = pp*(c*ppz - sinpsi*ppx); iq(np) = 1; E(np) = Ep*prm;
        u(np+1) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
        v(np+1) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
        w(np+1) = pm*(c*pmz - sinpsi*pmx); iq(np+1) = -1; E(np+1) = Em*prm;
    ]
    ELSE [
        u(np+1) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
        v(np+1) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
        w(np+1) = pp*(c*ppz - sinpsi*ppx); iq(np+1) = 1; E(np+1) = Ep*prm;
        u(np)   = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
        v(np)   = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
        w(np)   = pm*(c*pmz - sinpsi*pmx); iq(np) = -1; E(np) = Em*prm;
    ]
    np = np + 2;
    u(np)   = pr*(c*cosdel*prx - sindel*pry + a*prz);
    v(np)   = pr*(c*sindel*prx + cosdel*pry + b*prz);
    w(np)   = pr*(c*prz - sinpsi*prx); iq(np) = -1; E(np) = Er*prm;
] ELSE [
    IF( Ep > Em ) [
        u(np) = pp*ppx; v(np) = pp*ppy; w(np) = c*pp*ppz;
        iq(np) = 1; E(np) = Ep*prm;
        u(np+1) = pm*pmx; v(np+1) = pm*pmy; w(np+1) = c*pm*pmz;
        iq(np+1) = -1; E(np+1) = Em*prm;
    ]
    ELSE [
        u(np+1) = pp*ppx; v(np+1) = pp*ppy; w(np+1) = c*pp*ppz;
        iq(np+1) = 1; E(np+1) = Ep*prm;
        u(np) = pm*pmx; v(np) = pm*pmy; w(np) = c*pm*pmz;
        iq(np) = -1; E(np) = Em*prm;
    ]
    np = np + 2;
    u(np) = pr*prx; v(np) = pr*pry; w(np) = c*pr*prz;
    iq(np) = -1; E(np) = Er*prm;
]

return; end;

%E
"******************************************************************"
SUBROUTINE PHOTO;
"******************************************************************"
" Programmers:  I. Kawrakow, complete recoding,                    "
"                            Fluorescent X-rays, Auger,            "
"                            Coster-Kronig treated in RELAX        "
"               A.F. Bielajew (NRC) photoelectric angular distn    "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-PHOTO; "default replacement is:
              "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
                  "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"

$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
$DEFINE-LOCAL-VARIABLES-PHOTO;
/* $REAL ftot,iprob; */
data n_warning/0/;

IF ( mcdf_pe_xsections )[call egs_shellwise_photo();return;]

NPold = NP;      "Set the old stack counter"
PEIG=E(NP); irl = ir(np);
IF( peig < edge_energies(2,1) ) [
    IF( n_warning < 100 ) [
        n_warning = n_warning + 1;
        $egs_info(*,' Subroutine PHOTO called with E = ',peig,
                   ' which is below the current min. energy of 1 keV! ');
        $egs_info(*,' Converting now this photon to an electron, ');
        $egs_info(*,' but you should check your code! ');
    ]
    iq(np) = -1;
    e(np) = peig + prm;
    return;
]

iZ = iedgfl(irl);
do_relax = .false.;
edep = pzero;
IF( iedgfl(irl) ~= 0 ) [   " User requested atomic relaxations "
                           " first sample the element "
    IF( nne(medium) = 1 ) [
        iZ = int( zelem(medium,1) + 0.5 );
        DO j=1,edge_number(iZ) [
            IF( peig >= edge_energies(j,iZ) ) EXIT;
        ]
    ]
    ELSE [
        aux = peig*peig; aux1 = aux*peig; aux = aux*Sqrt(peig);
        sigtot = 0;
        DO k=1,nne(medium) [
            iZ = int( zelem(medium,k) + 0.5 );
            IF( iZ < 1 | iZ > $MXELEMENT ) [
                $egs_info(*,' Error in PHOTO: ');
                $egs_fatal(*,'   Atomic number of element ',k,
                   ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
            ]
            IF( peig > edge_energies(1,iZ) ) [
                j = 1;
                sigma = (edge_a(1,iZ) + edge_b(1,iZ)/peig +
                     edge_c(1,iZ)/aux + edge_d(1,iZ)/aux1)/peig;
            ]
            ELSE [
                DO j=2,edge_number(iZ) [
                    IF( peig >= edge_energies(j,iZ) ) EXIT;
                ]
                sigma = edge_a(j,iZ) + gle*(edge_b(j,iZ) + gle*(edge_c(j,iZ) +
                        gle*edge_d(j,iZ) ));
                sigma = Exp(sigma);
            ]
            sigma = sigma * pz(medium,k);
            sigtot = sigtot + sigma;
            probs(k) = sigma;
            ints(k) = j;
        ]
        $RANDOMSET br; br = br*sigtot;
        DO k=1,nne(medium) [
            br = br - probs(k);
            IF( br <= 0 ) EXIT;
        ]
        iZ = int( zelem(medium,k) + 0.5 );
        j  = ints(k);
    ]
    " Now we know the atomic number (iZ) and the energy interval the "
    " photon energy is in (j). It is time to sample the shell the photon "
    " is interacting with. "
    " left for now as before, to be changed!!! "
    IF( peig <= binding_energies($MXSHELL,iZ) )
    [   "Outer shells, no atomic relaxation"
           "EADL relax: Below  M2-shell -> just emit e- "
           iq(np) = -1;
           e(np) = peig + prm;
    ]
    ELSE ["Above  N-shell -> sample the shell the photon is interacting with"
        $RANDOMSET br; /* ftot = 1;  */
        DO k=1,$MXINTER [
            IF( peig > binding_energies(k,iZ) ) [
                IF( br < interaction_prob(k,iZ) ) EXIT;
                br = (br - interaction_prob(k,iZ))/(1-interaction_prob(k,iZ));
            ]
        ]
        "Interaction possible with any shell from k=1 to $MXSHELL"
        "Defaults to $MXSHELL interaction if DO loop completes"
        "****************"
        "EADL APPROACH 1: Do not allow interaction below L3. Deviates"
        "**************** from previous EGSnrc approach as it doesn't"
        "                 generate e- nor x-rays from <M> and <N> shells."
        IF (eadl_relax & k > 4)[
           "No initial vacancy below L3 for now, just emit e-"
           iq(np) = -1;
           e(np) = peig + prm;
        ]
        ELSE["EADL:    Interacts with K,L1..L3 shells"
             "default: Interacts with K,L1..L3,<M>, and <N> shells"
           e_vac = binding_energies(k,iZ);
           e(np) = peig - e_vac + prm; do_relax = .true.;
           iq(np) = -1;
        ]
    ]
]
ELSE [
    e(np) = peig + prm; iq(np) = -1;
]

IF( iq(np) = -1 ) [
    $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
]

"****************"
"EADL APPROACH 2: PE interactions with K, L1...L3,<M> and <N> shells,"
"**************** but vacancies below L3 deposit energy locally. It wont"
"                 produce x-rays from <M> and <N> shells."
"IF ($EADL_RELAX & k > 4)[
"   edep = e_vac; do_relax = .false.;
"]
IF( do_relax ) [
    call relax(e_vac,k,iZ);
]

IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"

;
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"

return;
end;

%E
"******************************************************************"
subroutine egs_shellwise_photo;
"******************************************************************"
" Derived from PHOTO by I. Kawrakow and A.F. Bielajew              "
" Shellwise implementation and      "
"                                sampling optimizations            "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-PHOTO; "default replacement is:
              "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
                  "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"
;COMIN/PE-SHELL-DATA/;

$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
$DEFINE-LOCAL-VARIABLES-PHOTO;
$REAL slope, logE, int_prob;
$INTEGER zpos, ibsearch;
data n_warning/0/;

NPold = NP;      "Set the old stack counter"
PEIG=E(NP); irl = ir(np);
do_relax = .false.;
IF( peig < $RELAX-CUTOFF ) [
    IF( n_warning < 100 ) [
        n_warning = n_warning + 1;
        $egs_info(*,' Subroutine egs_shellwise_photo called with E = ',
                    peig,' which is below the current min. energy of ',
                   $RELAX-CUTOFF,' keV! ');
        $egs_info(*,' Converting now this photon to an electron, ');
        $egs_info(*,' but you should check your code! ');
    ]
    iq(np) = -1;
    e(np) = peig + prm;
    return;
]

edep = pzero;

IF( iedgfl(irl) ~= 0 ) [" User requested atomic relaxations "
                        " sample element and atomic shell for"
   j = -1;              " the interaction."
   IF( nne(medium) = 1 ) [
    iZ = int( zelem(medium,1) + 0.5 ); zpos = pe_zpos(iZ);
    IF( pe_nshell(zpos) > 0) [
      logE = log(peig);
      j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
    ]
   ]
   ELSE [
      $RANDOMSET br; logE = log(peig);
      "DO k=1,nne(medium) ["
      DO k=nne(medium),1,-1 [
          iZ = int( zelem(medium,k) + 0.5 );zpos = pe_zpos(iZ);
          IF( iZ < 1 | iZ > $MXELEMENT ) [
              $egs_info(*,' Error in egs_shellwise_photo: ');
              $egs_fatal(*,'   Atomic number of element ',k,
                 ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
          ]
          j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
          slope    = pe_elem_prob(j+1,k,medium) - pe_elem_prob(j,k,medium);
          slope    = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
          int_prob = pe_elem_prob(j,k,medium)+slope*(logE-pe_energy(j,zpos));
          br -= exp(int_prob);
          IF ( br <= 0 ) EXIT;
      ]
   ]
   " Now we know the atomic number (iZ) and the energy interval the "
   " photon energy is in (j). It is time to sample the shell the photon "
   " is interacting with. "
   IF( peig < pe_be(zpos,pe_nshell(zpos)) | pe_nshell(zpos) = 0 )
   [   "no atomic relaxation, create photo-electron"
         iq(np) = -1;
         e(np) = peig + prm;
   ]
   ELSE ["sample the shell the photon is interacting with"
      $RANDOMSET br; sigtot = 0;
      DO k=1,pe_nshell(zpos) [
          IF( peig > pe_be(zpos,k) ) [
            slope = pe_xsection(j+1,zpos,k) - pe_xsection(j,zpos,k);
            slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
            int_prob=pe_xsection(j,zpos,k)+slope*(logE-pe_energy(j,zpos));
            br -= exp(int_prob); sigtot += exp(int_prob);
            IF ( br <= 0 ) EXIT;
          ]
      ]
      IF (k > pe_nshell(zpos))["outer shell, create photo-electron"
         iq(np) = -1;
         e(np) = peig + prm;
      ]
      ELSE[
         e_vac = pe_be(zpos,k);
         e(np) = peig - e_vac + prm; do_relax = .true.;
         iq(np) = -1;
      ]
   ]
]
ELSE ["No atomic relaxations, just create photo-electron"
    e(np) = peig + prm; iq(np) = -1;
]

IF( iq(np) = -1 ) [
    $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
]

IF( do_relax ) [
    call egs_eadl_relax(iZ,k);
]

IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"

;
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"

return;
end;

"*************************************************************************"
subroutine egs_read_shellwise_pe;
"*************************************************************************"

$IMPLICIT-NONE;

$declare_max_medium;
$COMIN-SHELLWISE-PE-INIT;

$INTEGER   lnblnk1,egs_get_unit,pe_sw_unit,ounit,egs_open_file;
$INTEGER   sorted($MXELEMENT),i,j,k,l,m;
$REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
$REAL      rest_xs($MXNE,$MXELEMENT);
$REAL      tmp_e($MXNE,$MXPESHELL), tmp_xs($MXNE,$MXPESHELL);
$REAL      new_e($MXNE),deltaEb,slope;
$INTEGER   zread($MXELEMENT),ib($MXPESHELL),ibsearch;
character  data_dir*128,pe_sw_file*144;

$INTEGER  medio,iZ,iZpos,egs_read_int,pos,curr_rec;
real*4    egs_read_real,e_r, e_old,sigma_r;
integer*2 nz, egs_read_short,ish, i_nshell,i_nge;
$LOGICAL  is_open, is_there, shift_required;

character*3 labels(16);
data labels/'  K',' L1',' L2',' L3',
            ' M1',' M2',' M3',' M4',' M5',
            ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/;

/*********************************************
   Open PE shellwise data file photo_shellwise.data
 **********************************************/
$egs_info('(/a$)',
' Reading renormalized photoelectric cross sections ......');
data_dir = $cstring(hen_house) // 'data' // $file_sep;
pe_sw_file = $cstring(data_dir) // 'photo_shellwise.data';

/* Open a fortran unit for reading data */
pe_sw_unit = egs_get_unit(0);
IF( pe_sw_unit < 1 ) [
  $egs_fatal(*,'egs_init_shellwise_pe: failed to get a free Fortran I/O unit');
]
open(pe_sw_unit,file=pe_sw_file,status='old',
     form='UNFORMATTED',ACCESS='direct',recl=1,
     err=:no-pe-sw-file:);
GOTO :read-pe-sw:;
:no-pe-sw-file:
$egs_fatal('(2a)','egs_init_shellwise_pe: failed to open ',
           pe_sw_file);
:read-pe-sw:
is_open = .true.;
/******************************
   Array initialization
 ******************************/
DO medio = 1,nmed [
   DO i=1,nne(medio) [
      pe_nshell(i*medio) = 0;
      pe_nge(i*medio) = 0;
      pe_zsorted(i,medio) = 0;
   ]
]
DO l = 1,$MXELEMENT [
   pe_zpos(l) = -1;
   DO k = 1,$MXNE [
      pe_energy(k,l) = 0.0;
      DO m = 1,$MXPESHELL [
         pe_xsection(k,l,m) = 0.0;
      ]
   ]
   DO k = 1,$MXPESHELL [
      pe_be(l,k) = -99;
   ]
]

/******************************
   Get shellwise PE xsections
 ******************************/
curr_rec = 1; iZpos = 0;
nz = egs_read_short(pe_sw_unit,curr_rec);
"$egs_info('(a,i2,a)','PE shellwise data available for ',nz,' elements....');"
DO medio = 1,nmed [
   DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
   call egs_heap_sort(nne(medio),z_sorted,sorted);
   DO i=1,nne(medio) [pe_zsorted(i,medio) = z_sorted(i);]
   DO i=1,nne(medio) [
      iZ = z_sorted(i);
      "Now check whether we have already loaded the data for"
      "this atomic number"
      is_there = .false.;
      DO j = 1,medio-1 [
         DO k = 1, nne(j)[
           IF( iZ = pe_zsorted(k,j) ) [
               is_there = .true.; EXIT;
           ]
         ]
      ]
      IF (is_there) NEXT;
      "Read data for this element"
      iZpos += 1; zread(iZpos) = iZ;
      pe_zpos(iZ) = iZpos;
      pos         = 3 + (iZ-1)*4;
      curr_rec    = egs_read_int(pe_sw_unit,pos) + 1;
      i_nge       = egs_read_short(pe_sw_unit,curr_rec);
      i_nshell    = egs_read_short(pe_sw_unit,curr_rec);
      "$egs_info('(a,i2,a,i3,a,i2,a)','Element ',iZ,' has ',i_nge,
      "  ' energy points and ',i_nshell,' shells');
      pe_nge(iZpos) = i_nge; pe_nshell(iZpos) = i_nshell;
      e_old = -1.0; ish = 0;
      DO j = 1,i_nge[
         e_r = egs_read_real(pe_sw_unit,curr_rec);
         sigma_r = egs_read_real(pe_sw_unit,curr_rec);
         pe_energy(j,iZpos) = e_r;
         pe_xsection(j,iZpos,0) = sigma_r;
         rest_xs(j,iZpos) = sigma_r;
         DO k = 1, i_nshell[
            sigma_r =  egs_read_real(pe_sw_unit,curr_rec);
            pe_xsection(j,iZpos,k) = sigma_r;
            rest_xs(j,iZpos) = rest_xs(j,iZpos) - sigma_r;

         ]
         "Extract binding energies from the data base"
         IF (e_r - e_old < 1e-15)[
            pe_be(iZpos,i_nshell-ish) = e_r;
            ish += 1;
         ]
         e_old = e_r;

      ]
      "DO k = 1, i_nshell[
      "   $egs_info('(a2,a3,a2,1pe12.4,a4)',
      "             'E(',labels(k),')=',pe_be(iZpos,k),' MeV');
      "]

   ]
]
pe_ne = iZpos;
"$egs_info('(a,i2,a/)','Finished processing ',iZpos,' elements!');

/*********************************************
 Adjust xsections to current binding energies
 Shift energy scale for each subshell when
 required.
 *********************************************/
"$egs_info(*,' Adjusting cross sections to new binding energies ...');
DO i=1,pe_ne[
   iZ = zread(i);
   IF (pe_nshell(i) = 0)[
      DO j=1,pe_nge(i)[
         pe_energy(j,i) =  log(pe_energy(j,i));
      ]
      NEXT;
   ]
   "Shift energy scale for different binding energy sets"
   DO l=1,pe_nshell(i)[
      IF ( pe_be(i,l) ~= binding_energies(l,iZ))[
           shift_required = .true.;
           deltaEb = binding_energies(l,iZ)-pe_be(i,l);
           "$egs_info('(2(a,a,a,1pe12.4),a,1pe12.4,a,e12.4)',
           "           'Eb_p_',labels(l),' = ',pe_be(i,l),
           "          ' Eb_e_',labels(l),' = ',binding_energies(l,iZ),
           "          ' diff = ',pe_be(i,l)-binding_energies(l,iZ),
           "          ' -> ', 100*(1.0 - binding_energies(l,iZ) / pe_be(i,l))
           "          );
      ]
      ELSE[shift_required =.false.;]
      is_there = .false.;
      DO j=1,pe_nge(i)[
         tmp_e(j,l)  = pe_energy(j,i);
         tmp_xs(j,l) = pe_xsection(j,i,l);
         IF ( shift_required &
              pe_energy(j,i) => pe_be(i,l) )[
            tmp_e(j,l) += deltaEb;
            "$egs_info(*,'Shifting ',pe_energy(j,i),' to ',tmp_e(j,l));
            "Determine edge position in energy array"
            IF (pe_energy(j,i) = pe_be(i,l) & ~is_there)[
               ib(l) = j; is_there = .true.;
            ]
            "Update new energy grid"
            IF (l = 1)[
               new_e(j) = tmp_e(j,l);
            ]
            "ELSE IF(tmp_e(j,l) < binding_energies(l-1,iZ))[
            ELSE IF(j < ib(l-1))[
               new_e(j) = tmp_e(j,l);
            ]
         ]
      ]
      pe_be(i,l) = binding_energies(l,iZ);
   ]
   "Re-compute sub-shell xsections for new energy grid new_e"
   "Not needed for K shell"
   DO l=2,pe_nshell(i)[
      DO j=1,pe_nge(i)[
         IF ( new_e(j) >= pe_be(i,l-1) )[
            m = ibsearch(new_e(j),pe_nge(i),tmp_e(1,l));
            slope = log(tmp_xs(m+1,l)/tmp_xs(m,l));
            slope = slope/log(tmp_e(m+1,l)/tmp_e(m,l));
            pe_xsection(j,i,l) = log(tmp_xs(m,l));
            pe_xsection(j,i,l) += slope*log(new_e(j)/tmp_e(m,l));
            pe_xsection(j,i,l) = exp(pe_xsection(j,i,l));
         ]
      ]
   ]
   "Re-compute total xsections for new energy grid new_e"
   "$egs_info(*,'-> Z = ',iZ);"
   DO j=1,pe_nge(i)[
      IF ( j < ib(pe_nshell(i)))[
         new_e(j) = pe_energy(j,i);
      ]
      m = ibsearch(new_e(j),pe_nge(i),pe_energy(1,i));
      slope = log(rest_xs(m+1,i)/rest_xs(m,i));
      slope = slope/log(pe_energy(m+1,i)/pe_energy(m,i));
      pe_xsection(j,i,0)  = log(rest_xs(m,i));
      pe_xsection(j,i,0) += slope*log(new_e(j)/pe_energy(m,i));
      pe_xsection(j,i,0) = exp(pe_xsection(j,i,0));
      "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4,1x,1pe12.4)',
      "         new_e(j),pe_xsection(j,i,0),pe_energy(j,i),rest_xs(j,i));
      DO l=1,pe_nshell(i)[
         pe_xsection(j,i,0) += pe_xsection(j,i,l);
      ]
      "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4)',
      "         new_e(j),pe_xsection(j,i,0));
   ]
   "Normalize shell cross sections to total for sampling"
   "and update energy grid of ith element."
   " Prepare for log/log interpolation."
   DO j=1,pe_nge(i)[
      pe_energy(j,i) =  log(new_e(j));
      DO l=1,pe_nshell(i)[
         pe_xsection(j,i,l) = log(pe_xsection(j,i,l)/pe_xsection(j,i,0));
      ]
   ]
]

$egs_info('(a/)',' done');

IF( is_open ) close(pe_sw_unit);
return;
end;


"******************************************************************"
SUBROUTINE RELAX(energy,n,iZ);
"******************************************************************"
" Subroutine to fill a vacancy in shell n, element iZ              "
" by emitting fluorescent X-rays, Auger and Coster-Kronig electrons"
" Transitions between K,L1,L2,L3,average M,average N are taken into"
" account. Particles with energies above the transport cut-offs    "
" (ECUT and PCUT) are placed on the stack, energy of sub-threshold "
" particles is stored in EDEP.                                     "
" In this version a global cut-off of 1 keV applies                "
"  i.e. if ECUT-RM or PCUT is below 1 keV, binding energies below  "
"  1 keV will still be absorbed locally (due to lack of data)      "
"                                                                  "
" Version 1:  I. Kawrakow, December 1998                           "
"******************************************************************"
implicit none;

" Input variables "
"================="
$INTEGER n,iZ;
$REAL    energy;  "

$declare_write_buffer;

" Local variables "
"================="
REPLACE {$MXVAC} WITH {50}  "Maximum number of vacancies during the"
                            "relaxation cascade                    "

$INTEGER vac_array($MXVAC), "array with shell vacancies            "
         n_vac,             "current number of vacancies           "
         shell;             "current shell                         "
$INTEGER final,finala,      "code of final state                   "
         final1,final2,     "two vacancies in the final state in   "
                            "the case of Auger transitions         "
         iql,               "particle charge                       "
         irl;               "present region"
$INTEGER first_transition($MXINTER),
         last_transition($MXINTER);
                            "first and last transition for a given "
                            "shell in the list of all possible     "
                            "transitions                           "
$INTEGER final_state($MXTRANS);
           " final_state(i) is the final atomic state                "
           " after transition i coded as follows:                    "
           "   * fluorescence - final_state is the shell number      "
           "                    of the new vacancy                   "
           "   * Coster-Kronig - final_state is the shell number     "
           "                     of the new vacancy + 10             "
           "   * Auger - final_state is n1 + 100*n2 where n1 and n2  "
           "             are the shell numbers of the 2 new vacancies"

$INTEGER k, np_old, ip, iarg;
$REAL    e_array($MXVAC),   "array with vacancy energies           "
         Ei,Ef,             "initial,final binding energies        "
         Ex,                "kinetic energy of emitted particle    "
         eta,               "a random number                       "
         e_check,           "energy conservation check             "
         min_E,ekcut,pkcut,elcut; "cut-off energies  "

$REAL    xphi,yphi,xphi2,yphi2,rhophi2,
         cphi,sphi;         "for azimuthal angle selection"

" Global EGS4 variables "
"======================="
$COMIN-RELAX;
;COMIN/RELAX-USER/;

data first_transition/1,20,27,33,38/;
data last_transition/19,26,32,37,39/;
data final_state/ "See the final_state definition above"
         4,3,5,6,                           " K-shell fluorescence    "
         202,302,402,404,403,303,           " K-shell Auger           "
         502,503,504,602,603,604,           " K-shell Auger           "
         505,605,606,                       " K-shell Auger           "
         13,14,                             " L1 Coster-Kronig        "
         5,6,                               " L1 fluorescence         "
         505,605,606,                       " L1 Auger                "
         14,                                " L2 Coster-Kronig        "
         5,6,                               " L2 fluorescence         "
         505,605,606,                       " L2 Auger                "
         5,6,                               " L3 fluorescence         "
         505,605,606,                       " L3 Auger                "
         6,                                 " M  fluorescence         "
         606/;                              " M  Auger                "

save first_transition,last_transition,final_state; "to avoid problems with "
                                                   "non-static compiler options"

IF (eadl_relax)[
   call egs_eadl_relax(iZ,n);
   return;
]

IF( n < 1 | n > $MXSHELL ) [ return; ] "unknown vacancy"

iz_relax = iZ;
irl = ir(np);
ekcut = ecut(irl)-rm; pkcut = pcut(irl);
min_E = $RELAX-CUTOFF;

IF( energy <= min_E ) [
    edep = edep + energy;  "We assume that edep is zeroed "
                        "(or set to the appropriate value) in the routine "
                        "calling RELAX "
    edep_local = energy;

    "Assign this energy deposition to an electron."
    "Note that this should NOT be treated as though it came from a photon,"
    "even if a photon initiated the relaxations. Rather, energy remaining"
    "in vacancies should be given to an electron or absorbed locally."
    $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

    return;
]

" Set-up the array of vacancies for the relaxation cascade "
n_vac = 1; vac_array(n_vac) = n; np_old = np;
e_check = 0; e_array(n_vac) = energy;

:START: LOOP[     "Until no  >N-shell vacancies"

    shell = vac_array(n_vac); Ei = e_array(n_vac); n_vac = n_vac - 1;

    IF( Ei <= min_E ) [  " Below cut-off -> local absorption "
        edep = edep + Ei;

        edep_local = Ei;

        "Assign this energy deposition to an electron."
        "Note that this should NOT be treated as though it came from a photon,"
        "even if a photon initiated the relaxations. Rather, energy remaining"
        "in vacancies should be given to an electron or absorbed locally."
        $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

        IF( n_vac > 0 ) goto :START: ;
        EXIT;
    ]

    "Set the relax_user common block variables, IK March 22 2004"
    ish_relax = shell; u_relax = Ei;
    IF( shell = $MXSHELL ) [ "This is N-shell vacancy -> just produce Auger"
        IF( Ei > ekcut ) [
            np = np + 1;
            $CHECK-STACK(np,'RELAX');
            e(np) = Ei + prm; iq(np) = -1;
            $TRANSFER PROPERTIES TO (np) FROM (np-1);
            $RANDOMSET eta; eta = 2*eta - 1; w(np) = eta;
            eta = (1-eta)*(1+eta);
            IF( eta > 1e-20 ) [
                eta = Sqrt(eta);
                $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
                u(np) = eta*cphi; v(np) = eta*sphi;
            ]
            ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
            $AUSCALL($AUGERTRA);
        ]
        ELSE             [
            edep = edep + Ei;

            edep_local = Ei;
            $AUSCALL($SELECTRONA);
        ]
        IF( n_vac > 0 ) goto :START: ;
        EXIT;
    ]
    " Sample transition number for this vacancy "
    $RANDOMSET eta;
    DO k=first_transition(shell),last_transition(shell)-1 [
        eta = eta - relaxation_prob(k,iZ);
        IF( eta <= 0 ) EXIT;
    ]
    final = final_state(k); finala = final;
    IF( final < 100 ) [
        IF( final < 10 ) [ "fuorescence"
            iql = 0; elcut = pkcut;
        ]
        ELSE             [ "Coster-Kronig"
            final = final - 10;
            iql = -1; elcut = ekcut;
        ]
        Ef = binding_energies(final,iZ);
        Ex = Ei - Ef;
        n_vac = n_vac + 1;
        vac_array(n_vac) = final;
        e_array(n_vac) = Ef
    ]
    ELSE [  "Auger"
        final1 = final/100; final2 = final - final1*100;
        n_vac  = n_vac + 1;
        vac_array(n_vac) = final1;
        e_array(n_vac) = binding_energies(final1,iZ);
        n_vac  = n_vac + 1;
        vac_array(n_vac) = final2;
        e_array(n_vac) = binding_energies(final2,iZ);
        iql = -1;
        Ex = Ei - e_array(n_vac) - e_array(n_vac-1);
        elcut = ekcut;
    ]
    IF( Ex <= elcut ) [ "Below cut-off"
        edep = edep + Ex;

        IF( finala <  10 ) [
            edep_local = Ex;
            $AUSCALL($SPHOTONA);
        ]
        ELSE [
            edep_local = Ex;
            $AUSCALL($SELECTRONA);
        ]
    ]
    ELSE [
        np = np + 1;
        $CHECK-STACK(np,'RELAX');
        iq(np) = iql;
        IF( iql = 0 ) [ e(np) = Ex; ] ELSE [ e(np) = Ex + rm;]
        $TRANSFER PROPERTIES TO (np) FROM (np-1);
        $RANDOMSET eta;
        eta = 2*eta - 1;
        w(np) = eta;
        eta = (1-eta)*(1+eta);
        IF( eta > 1e-20 ) [
            eta = Sqrt(eta);
            $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
            u(np) = eta*cphi;
            v(np) = eta*sphi;
        ]
        ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
        IF     ( finala <  10 ) [ $AUSCALL($FLUORTRA);  ]
        ELSE IF( finala < 100 ) [ $AUSCALL($COSKROTRA); ]
        ELSE                    [ $AUSCALL($AUGERTRA);  ]
    ]
]

return;
end;

"*************************************************************************"
subroutine egs_init_relax;
"*************************************************************************"
" Reads EADL atomic relaxation data from $HEN_HOUSE/data/relax.data. This "
" data base was originally created by I. Kawrakow to be used with C++ user"
" codes. It has been re-created using 4 bytes integers instead of using   "
" optimized integer sizes to save space. It is now about 34% larger (760K)"
" than before (557K). Reason for this was that some compilers need a switch"
" to get it to read binary files on byte at a time. This would have been a"
" nuisance for users when configuring the already complex system.         "
"                                                                        "
" The final relaxation state from radiative transitions assumes C-style  "
" array indexing and hence needs to be increased by 1.                   "
" Similarly, for non-radiative transitions, there is need to increase the"
" codified value of the two electron states by 65. The reason is that the"
" two transition states are encoded as 64*state1+state2. Because of the C"
" style indexing, state1 and state2 must be increased by 1, increasing the"
" above codified value by 65.                                            "
"                                                                        "
"Shell information for all media elements stored in one-dimensional arrays:"
"                                                                        "
" ish              => absolute shell index (1...shell_ntot)              "
" shell_be(ish)    => shell binding energy                               "
" shell_type(ish)  => shell type according to EADL notation              "
" shell_Z(ish)     => Z of shell element                                 "
" shell_num(ish)   =>  relative shell position within one element        "
" shell_ntot       => total number of shells for all media elements      "
" relax_first(ish) => initial absolute relaxation position               "
" relax_ntran(ish) => number of transitions                              "
" shell_eadl(Z,shell_num(ish)) => absolute shell position for element Z  "
"                                                                        "
"Transition information for all shells also stored in one-dimensional arrays:"
"                                                                         "
" transition index itran runs from 1...relax_ntot                         "
" relax_prob(itran)  => transition probabilities                          "
" relax_atbin(itran) => holds the alias indices                           "
" relax_state(itran) => final relaxation state:                           "
"                       radiative: relative shell position                "
"                   non-radiative: relative position of shells(64*sh1+sh2)"
"                                                                         "
"                              Originally coded by IK in a standalone code"
"                          Modified for use with EGSnrc by EMH, June 2011 "
"                          Corrected bugs and commented by EMH, April 2012"
"*************************************************************************"
$IMPLICIT-NONE;

$declare_max_medium;
$COMIN-RELAX-INIT;

$INTEGER   lnblnk1,egs_get_unit,relax_unit,ounit,egs_open_file;
$INTEGER   sorted($MXELEMENT),i,j,k,k1,k2,m;
$REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
character  data_dir*128,relax_file*144;

$INTEGER  ish,medio,iZ,ntran;
$REAL     Ec, Pc, tmp, min_be, sumw,Ex;
$LOGICAL  is_open, is_there;
$REAL     wtmp($MAXTRANS);
$INTEGER  itmp($MAXTRANS);

integer*4 pos, curr_rec, sh_eadl;
integer*4 nz, nshell, tr_type;
integer*4 ttype;
real*4    be_r, prob_r;


DO iZ=1,$MXELEMENT[
 DO k=1,$MXESHLL[
   shell_eadl(iZ,k) = -1;
 ]
]

/*********************************************
   Determine minimum energy
 **********************************************/
/*Pc = 1e30; Ec = 1e30;
DO medio = 1,nmed [
    tmp = AE(medio) - rm; Ec = min(Ec,tmp); Pc = min(Pc,ap(medio));
]
min_be = min(Ec,Pc);  "This is the minimum binding energy for which we need"
                      "relaxation data"
*/
min_be = $RELAX-CUTOFF;
$egs_debug('(a)',' ************ relax_init **************** ');
$egs_debug('(a,f10.7)',
        ' Minimum binding energy requiring relaxation data: ',min_be);

/*********************************************
   Open EADL relaxation data file relax.data
 **********************************************/
$egs_info('(/a)',' Reading EADL relaxation data ......');
data_dir = $cstring(hen_house) // 'data' // $file_sep;
relax_file = $cstring(data_dir) // 'relax.data';

/* Open a fortran unit for reading relaxation data */
relax_unit = egs_get_unit(0);
IF( relax_unit < 1 ) [
   $egs_fatal(*,'egs_init_relax: failed to get a free Fortran I/O unit');
]
open(relax_unit,file=relax_file,status='old',
     form='UNFORMATTED',ACCESS='direct',recl=$RECL-FACTOR,
     err=:no-relax-file:);
GOTO :read-relax:;
:no-relax-file:
$egs_fatal('(2a)','egs_init_relax: failed to open ',
           relax_file);
:read-relax:
is_open = .true.;
/*********************************************
   Get EADL relaxation data from relax.data
 **********************************************/
curr_rec = 1;
read(relax_unit,rec=curr_rec) nz;
"$egs_info('(a,i2,a)','Relaxation data for ',nz,' elements....');"
shell_ntot = 0;relax_ntot = 0;
DO medio = 1,nmed [
   DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
   call egs_heap_sort(nne(medio),z_sorted,sorted);
   DO i=1,nne(medio) [
      iZ = z_sorted(i);
      "Now check whether we have already loaded the data for"
      "this atomic number"
      is_there = .false.;
      DO j = 1,shell_ntot [
         IF( iZ = shell_Z(j) ) [ is_there = .true.; EXIT; ]
      ]
      IF (is_there) NEXT;
      pos = iZ + 1;
      read(relax_unit,rec=pos) curr_rec;
      read(relax_unit,rec=curr_rec) nshell;
      IF( shell_ntot + nshell > $MAXSHELL ) [
         $egs_fatal('(a,i5,a/,a//)',' Too many shells to fit in the list: ',
                shell_ntot + nshell,' (at least).',
                ' Increase the parameter $MAXSHELL and retry ');
      ]
      $egs_info('(a,i3,a,i2,a)',
      '  Z = ',iZ,' has ',nshell,' shells');
      DO ish=shell_ntot+1,shell_ntot+nshell[
        curr_rec  = curr_rec+1;
        read(relax_unit, rec=curr_rec) shell_type(ish);
        curr_rec  = curr_rec+1;
        read(relax_unit, rec=curr_rec) ntran;
        curr_rec  = curr_rec+1;
        read(relax_unit, rec=curr_rec) be_r; shell_be(ish) = be_r;

        shell_Z(ish) = iZ;
        shell_num(ish) = ish - shell_ntot;
        shell_eadl(iZ,shell_num(ish)) = ish;
        IF (binding_energies(shell_num(ish),iZ) > 0)[
           shell_be(ish) = binding_energies(shell_num(ish),iZ);
        ]
        ELSE IF( photon_xsections = 'epdl' )[
          "Use binding energies from relax.data below 1 keV"
           binding_energies(shell_num(ish),iZ) = shell_be(ish);
        ]
        DO k=1,ntran[
            curr_rec  = curr_rec+1;
            read(relax_unit,rec=curr_rec) itmp(k);
            curr_rec  = curr_rec+1;
            read(relax_unit,rec=curr_rec) prob_r;wtmp(k)=prob_r;
            /*Relaxation data uses C-style array indexing.
              Hence final relaxation state increased by 1  for
              radiative and by 65 for non-radiative transitions*/
            IF (itmp(k)<64) [itmp(k) +=1;]
            ELSE            [itmp(k) += 65;]
        ]
        IF( shell_be(ish) < min_be ) [
            relax_first(ish) = -1;
            relax_ntran(ish) = -1;
        ]
        ELSE [
            sumw = 0;
            DO k=1,ntran [  sumw = sumw + wtmp(k); ]
            IF( sumw > 1 ) [
                DO k=1,ntran [  wtmp(k) = wtmp(k)/sumw; ]
            ]
            ELSE IF( sumw < 1 ) [
                ntran = ntran + 1; itmp(ntran) = -1; wtmp(ntran) = 1-sumw;
            ]
            IF( relax_ntot + ntran > $MAXRELAX ) [
               $egs_fatal('(a,i5,a/,a/)',' Too many relaxation transitions: ',
                 relax_ntot + ntran,' (at least).',
                 ' Increase $MAXRELAX and retry ');
            ]
            relax_first(ish) = relax_ntot+1; relax_ntran(ish) = ntran;
            call prepare_alias_histogram(ntran,wtmp,
                                 relax_atbin(relax_ntot+1));
            DO k=1,ntran [
               j = relax_ntot + k;
               relax_state(j) = itmp(k); relax_prob(j) = wtmp(k);
            ]
            relax_ntot = relax_ntot + ntran;
        ]
      ]

      shell_ntot = shell_ntot + nshell;

   ]

]
$egs_debug('(a,i4,a)',' There are ',
        shell_ntot,' shells in the list of shells ');
$egs_info('(a/)',' ...... Done.');
/***********************************************/

IF( is_open ) close(relax_unit);
return;

stop;
end;

"Macro to check that the stack size is not exceeded"
REPLACE {$CHECK-RELAX-STACK(#,#);} WITH {;
  IF( {P1} > $MXSTACK ) [
      $egs_warning('(3(a,f10.6),a,i2)',
       'Evac = ',Evac, ' Ef = ',Ef,
       "' Z = ',iZ,' Nvac = ',Nvac,"
       ' min_E = ', min_E,' iq = ',iqf);
;  "---------- BUFFER FLUSH SEMICOLON ----------"
      $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
          ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
          ' Increase $MXSTACK and try again ');
  ]
};

"***********************************************************************"
  subroutine egs_eadl_relax(iZ, shell_egs);
"************************************************************************"
" Subroutine, called from subroutine relax, to fill a vacancy in         "
" shell shell_egs in element iZ by emitting fluorescent X-rays, Auger    "
" and Coster-Kronig electrons.  Uses EADL data.                          "
" Results passed via variables in comins.                                "
"   edep                                                                 "
"   edep_local                                                           "
"   e(np)                                                                "
"                                                                        "
" There are calls to ausgab with IARG values                             "
"   24  A fluorescent transition just occurred                           "
"   26  An Auger transition just occurred                                "
"   32  Sub-threshold fluorescent transition just occurred               "
"   33  Sub-threshold Auger transition just occurred                     "
"                                                                        "
" There is an inconsistency in the binding energies (BE) as COMPT uses   "
" different BE (incoh.data)                                              "
"                                                                        "
" Explain need to reduce new_state by 1 below as alias sampling provides "
" bin number from 1...nbin and not 0...nbin-1                            "
"                                                                        "
"                             Originally coded by IK in a standalone code"
"                         Modified for use with EGSnrc by EMH, June 2011 "
"                         Corrected bugs and commented by EMH, April 2012"
"************************************************************************"

$IMPLICIT-NONE;

$declare_max_medium;
$COMIN-RELAX-EADL;
;COMIN/RELAX-USER/;

$REAL    Ec,Pc,min_E,rnno,Evac,Ef,Ef1,Ef2,Ex,Ecc,
         cost,sint,cphi,sphi;
"Ec      ecut as k.e. for current region"
"Pc      pcut for current region"
"min_E   the minimum energy for transitions to continue"
"rnno    a random number"
"Evac    binding energy of current vacancy"
"Ef      the sum of the binding energies of the new vacancies"
"Ef1     the first new binding energy of for non-radiative transitions"
"Ef2     the second new binding energy of for non-radiative transitions"
"Ex      the change in total binding energy"
"Ecc     the cutoff energy (Ec or Pc)"
"cost,sint,cphi,sphi variables for calculating particle direction"

$INTEGER  shell, shell_egs, iZ, iarg;
"shell       number in master eadl list"
"shell_egs   shell number in current element"
"iZ          atomic number of element"

$INTEGER  irl,vacs($MAXVAC),nvac,vac,new_state,iqf,np_save,new1,new2;
"irl           current region"
"vacs($MAXVAC) array of vacancy shell numbers"
"nvac          current number of vacancies in vacs"
"vac           shell number of current vacancy"
"new_state     the state number that represents the new vacancy"
"iqf           the charge of the emitted relaxation particle"
"np_save       the stack index of the particle inducing in relaxations"
"new1          the first new vacancy for non-radiative transitions"
"new2          the second new vacancy for non-radiative transitions"

$INTEGER sample_alias_histogram;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;

shell = shell_eadl(iZ,shell_egs);
IF( shell < 1 | shell > $MAXSHELL ) [ return; ] "unknown vacancy"

irl = ir(np);
Ec = ecut(irl) - rm;
Pc = pcut(irl);
min_E = $RELAX-CUTOFF;

Evac = shell_be(shell); "provides relevant binding energy for this vacancy"
"store some information in comin RELAX-FOR-USER.  This just duplicates"
"various pieces of info so the user can access them."
rfu_Z  = shell_Z(shell); "Z of element the relaxing shell belongs to"
rfu_j0 = shell;         "shell # of vacancy that initiated cascade in long list"
rfu_n0 = shell_num(shell); "same but number is shell number in element iZ"
rfu_t0 = shell_type(shell); "the shell type (encodes the type of relaxation)"
rfu_E0 = Evac;          "B.E. of vacancy that initiated cascade"
"
"Local energy deposition for vacancies below L3 shell."
"Added here for consistency in algorithm for as long as"
"<M> and <N> shells considered instead of proper shells."
"AUSGAB call should be updated when charge of particle"
"creating vacancy becomes available."
IF (shell_egs > 4 & ~mcdf_pe_xsections) [
    edep = Evac;        "add energy of vacancy to edep"
    edep_local = Evac;  "set value of edep_local to energy of vacancy"

    "Assign this energy deposition to an electron."
    "Note that this should NOT be treated as though it came from a photon,"
    "even if a photon initiated the relaxations. Rather, energy remaining"
    "in vacancies should be given to an electron or absorbed locally."
    $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

    return; "invokes $AUSCALL($PHOTXAUS) in COMPT;"
]

vac = shell; Nvac = 0; np_save = np;
LOOP [ "from here to end of routine over all vacancies created"

    "check if energy of vacancy < cutoff OR no transitions from this shell"
    IF( Evac < min_E | relax_ntran(vac) < 1 ) [
        edep += Evac;         "add energy of vacancy to edep"
        edep_local = Evac;    "set value of edep_local to energy of vacancy"

        "Assign this energy deposition to an electron."
        "Note that this should NOT be treated as though it came from a photon,"
        "even if a photon initiated the relaxations. Rather, energy remaining"
        "in vacancies should be given to an electron or absorbed locally."
        $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

        go to :VACANCY:;      "exit loop and if Nvac still 0, exit routine"
    ]

    "prepare_alias_histogram is called from subroutine egs_init_relax and"
    "sample_alias_histogram uses the array of bin probabilities and bin"
    "numbers relax_prob(relax_first(vac) and relax_atbin(relax_first(vac))"
    "to return the bin which has been sampled, i.e. new_state"
    "relax_ntran(vac) tells how many transitions are available"
    new_state = sample_alias_histogram(relax_ntran(vac),
                  relax_prob(relax_first(vac)),
                  relax_atbin(relax_first(vac)));
    IF( new_state < 0 ) [ "this may happen if the sum of probabilities from"
                          "EADL was < 1. In this case the entire energy is"
                          "given to an electron and no new vacancy is created"
        Ef = 0;
        iqf = -1;
        Ecc = Ec;
    ]
    ELSE[
        new_state = relax_state(relax_first(vac)+new_state-1);
        IF( new_state <= 64 ) [ "It was a radiative transition (fluorescence)"
          iqf = 0;
          new_state += vac - shell_num(vac);
          Ef = shell_be(new_state);
          Nvac += 1;
          vacs(Nvac) = new_state;
          Ecc = Pc;
        ] "end of fluorescence block"
        ELSE [ "It was a non-radiative transition (Auger or Coster-Kronig)"
          iqf = -1; new1 = new_state/64; new2 = new_state - 64*new1;
          new1 += vac - shell_num(vac); new2 += vac - shell_num(vac);
          Ef1 = shell_be(new1); Ef2 = shell_be(new2);
          Nvac += 1; vacs(Nvac) = new1;
          Nvac += 1; vacs(Nvac) = new2;
          Ef = Ef1 + Ef2; Ecc = Ec;
        ] "end Auger or Coster-Kronig block"
    ]
    Ex = Evac - Ef;
    edep_local = 0;
    IF( Ex > Ecc ) [
        np += 1; $CHECK-RELAX-STACK(np,'new_relax');
        iq(np) = iqf;
        $TRANSFER PROPERTIES TO (np) FROM (np_save);
        $RANDOMSET rnno; cost = 2*rnno-1; sint = 1-cost*cost;
        IF( sint > 0 ) [
            sint = sqrt(sint);
            $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
            u(np) = sint*cphi; v(np) = sint*sphi; w(np) = cost;
        ] ELSE [ u(np) = 0; v(np) = 0; w(np) = cost; ]
        rfu_j = vac; rfu_n = shell_num(vac); rfu_t = shell_type(vac);
        rfu_E = shell_be(vac);
        IF( iqf = 0 ) [
            e(np) = Ex; $AUSCALL($FLUORTRA);
        ]
        ELSE [
            e(np) = Ex + rm; $AUSCALL($AUGERTRA);
        ]
    ] ELSE [ "Ex <= Ecc"
        edep += Ex;

        IF( iqf = 0 ) [
            edep_local = Ex;
            $AUSCALL($SPHOTONA);
        ] ELSE [
            edep_local = Ex;
            $AUSCALL($SELECTRONA);
        ]
    ] "end Ex <= Ecc block"
    :VACANCY:;
    IF( Nvac = 0 ) EXIT;
    "get next vacancy to process"
    vac = vacs(Nvac); Evac = shell_be(vac); Nvac -= 1;
] "end of main loop"
return;
end;
;

"***************************************************************************"
"     Triplet production stuff                                              "
"***************************************************************************"

REPLACE {$N_TRIPLET_DATA} WITH {55}
REPLACE {$N_ELEMENT} WITH {100}
;
subroutine init_triplet;
implicit none;
$declare_max_medium;
$COMIN-INIT-TRIPLET;
$REAL  energies($N_TRIPLET_DATA), sig_pair($N_ELEMENT,$N_TRIPLET_DATA),
       sig_triplet($N_ELEMENT,$N_TRIPLET_DATA), f_triplet($N_TRIPLET_DATA),
       sigp($N_TRIPLET_DATA), sigt($N_TRIPLET_DATA),
       as($N_TRIPLET_DATA), bs($N_TRIPLET_DATA), cs($N_TRIPLET_DATA),
       ds($N_TRIPLET_DATA);
character*128  triplet_data_file;
$INTEGER want_triplet_unit, triplet_unit, triplet_out;
$INTEGER i, iel, imed, lnblnk1, egs_get_unit, ntrip, iz1, izi, ifirst;
$REAL    logE, f_new, f_old, spline;

IF( itriplet = 0 ) return;
$set_string(triplet_data_file,' ');
triplet_data_file = $cstring(hen_house) // 'data' // $file_sep //
                    'triplet.data';
want_triplet_unit = 63;
triplet_unit = egs_get_unit(want_triplet_unit);
IF( triplet_unit < 1 ) [
    $egs_fatal(*,'init_triplet: failed to get a free Fortran I/O unit');
]
open(triplet_unit,file=triplet_data_file,err=:no-triplet-file:);
$egs_info('(a,$)',' init_triplet: reading triplet data ... ');
read(triplet_unit,*) ntrip;
IF( ntrip > $N_TRIPLET_DATA ) [
    $egs_fatal(*,'Max. number of data points per element is ',$N_TRIPLET_DATA);
]
read(triplet_unit,*,err=:error_triplet_data:) (energies(i),i=1,ntrip);
DO iel=1,$N_ELEMENT [
    read(triplet_unit,*);
    read(triplet_unit,*,err=:error_triplet_data:)
        (sig_pair(iel,i),i=1,ntrip);
    read(triplet_unit,*,err=:error_triplet_data:)
        (sig_triplet(iel,i),i=1,ntrip);
]
$egs_info(*,'OK');
ifirst = 0;
DO i=1,ntrip [
    IF( ifirst = 0 & energies(i) > 4.01*rm ) ifirst = i;
    energies(i) = log(energies(i));
]
log_4rm = log(4*rm);
energies(ifirst-1) = log_4rm;
dl_triplet = (energies(ntrip) - log_4rm)/$MAX_TRIPLET;
dli_triplet = 1/dl_triplet;
bli_triplet = 1 - log_4rm/dl_triplet;

DO imed = 1, nmed [

    $egs_info('(a,i3,a,$)',
      '   Preparing triplet fraction data for medium ',imed,' ... ');
    iz1 = zelem(imed,1) + 0.1;
    DO i=1,ntrip [
        sigp(i) = pz(imed,1)*sig_pair(iz1,i);
        sigt(i) = pz(imed,1)*sig_triplet(iz1,i);
        DO iel=2,nne(imed) [
            izi = zelem(imed,iel) + 0.1;
            sigp(i) = sigp(i) + pz(imed,iel)*sig_pair(izi,i);
            sigt(i) = sigt(i) + pz(imed,iel)*sig_triplet(izi,i);
        ]
    ]

    DO i=ifirst,ntrip [ f_triplet(i-ifirst+2) = sigt(i)/(sigp(i) + sigt(i)); ]
    f_triplet(1) = 0;
    call set_spline(energies(ifirst-1),f_triplet,as,bs,cs,ds,ntrip-ifirst+2);

    logE = log_4rm; f_old = 0;
    DO i=1, $MAX_TRIPLET-1 [
        logE = logE + dl_triplet;
        f_new = spline(logE,energies(ifirst-1),as,bs,cs,ds,ntrip-ifirst+2);
        a_triplet(i,imed) = (f_new - f_old)*dli_triplet;
        b_triplet(i,imed) = f_new - a_triplet(i,imed)*logE;
        f_old = f_new;
    ]
    $egs_info(*,'OK');

]
close(triplet_unit);
return;

:no-triplet-file:;
$egs_fatal('(a,a)',' init_triplet: failed to open the data file ',
             triplet_data_file(:lnblnk1(triplet_data_file)));

:error_triplet_data:;
$egs_fatal(*,' init_triplet: error while reading triplet data ');

return; end;

%E
"******************************************************************"
SUBROUTINE EDGSET(NREGLO,NREGHI);
"******************************************************************"
" SUBPROGRAM TO SET UP PARAMETERS FOR ATOMIC RELAXATIONS           "
" and proper handling of photo-electric absorption
"******************************************************************"
" Programmer:   I. Kawrakow, (NRC)                                 "
"******************************************************************"
"                                                                  "
"  Input:  NREGLO and NREGHI, not needed but left there for        "
"                             compatibility with older user codes  "
"
"  This routine is called from HATCH, it checks whether one of the "
"  elements of IEDGFL has been set to an integer number between    "
"  1 and 100 and if so reads in photo-absorption and relaxation    "
"  data. Note that the array IEDGFL, which used to be the          "
"  `effecvtive' atomic number of a medium is not used for any      "
"  purpose other than to indicate that relaxations are requested   "
"  (if non-zero).
"******************************************************************"
"                                                                  "

$IMPLICIT-NONE;

;COMIN/EDGE,X-OPTIONS,EGS-IO/;

"Input variables"
integer  NREGLO,NREGHI;

$INTEGER i,j,k,jj,iz;
logical  do_relax;
logical  got_data;
save     got_data;
data     got_data/.false./;

IF( got_data ) return;
   "EDGSET is now called from HATCH. In older user codes it was called
   "from within the user code. If this happens, and the data is already
   "available, we don't need to read it again. That's why the above
   "statement.

$egs_info('(a/,a)',
          'Output from subroutine EDGSET:',
          '==============================');

$need_relaxation_data(do_relax);
IF( ~do_relax ) [

    IF(eadl_relax)[
        $egs_fatal('(a,/a)',
                   'You must turn ON atomic relaxations when requesting',
                   'detailed atomic relaxation (eadl_relax=true)!');
    ]
    $egs_info('(a/)',' Atomic relaxations not requested! ');
    return;
]

$egs_info('(a/)',' Atomic relaxations requested! ');

$egs_info('(a$)',' Reading simplified photo-absorption data .....');

got_data = .true.;
rewind($PHOTOUNIT);

DO i=1,$MXELEMENT
[
    IF (eadl_relax)[
       "Skip, using binding_energies from *_photo.data file
       read($PHOTOUNIT,*);
    ]
    ELSE[
       read($PHOTOUNIT,*) j,(binding_energies(k,i),k=1,$MXSHELL);
       DO k=1,$MXSHELL [
          binding_energies(k,i) = binding_energies(k,i)*1e-6; "Convert to MeV"
       ]
    ]
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT
[
    read($PHOTOUNIT,*) j,(interaction_prob(k,i),k=1,$MXINTER);
    interaction_prob($MXSHELL,i)=1.01;
]
$egs_info('(a)',' Done');

$egs_info('(/a$)',' Reading simplified relaxation data .....');
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=1,19);   "K-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=20,26);   "L1-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=27,32);   "L2-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=33,37);   "L3-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,relaxation_prob(38,i);   "M-shell"
]
$egs_info('(a)',' Done');
$egs_info('(/a$)',' Reading parametrized XCOM photo cross section data .....');
rewind($PHOCSUNIT);
DO i=1,$MXELEMENT [
    read($PHOCSUNIT,*) j,edge_number(i);
    DO j=1,edge_number(i) [
        read($PHOCSUNIT,*) edge_a(j,i),edge_b(j,i),edge_c(j,i),
                           edge_d(j,i),edge_energies(j,i);
    ]
]
$egs_info('(a)',' Done');

IF (eadl_relax)[
 call egs_init_relax;
]

RETURN;
END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE PHOTON(IRCODE);
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$INTEGER IRCODE; "1 => normal return"

$COMIN-PHOTON;   "default replacement produces the following:
                 "COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,"
                 "  UPHIOT,USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION/;"

$DEFINE-LOCAL-VARIABLES-PHOTON;


IRCODE=1;"set up normal return"
PEIG=E(NP);
EIG=PEIG; "energy of incident gamma"
IRL=IR(NP);
$start_new_particle;

IF(EIG <= PCUT(IRL)) [GO TO :PCUT-DISCARD:;]

:PNEWENERGY:
LOOP["enter this loop for each photon with new energy"

IF(WT(NP) = 0.0) [go to :USER-PHOTON-DISCARD:;] "added May 01"

GLE=LOG(EIG);"GLE IS GAMMA LOG ENERGY"

"   here to sample no. mfp to transport before interacting"

$SELECT-PHOTON-MFP;
" DEFAULT FOR $SELECT-PHOTON-MFP; IS:  $RANDOMSET RNNO35;"
"                                      DPMFP=-LOG(RNNO35);"
"NOTE:  THIS TEMPLATE CAN ALSO BE OVER-RIDDEN BY OTHER SCHEMES,"
"       SUCH AS THE 'EXPONENTIAL TRANSFORM' TECHNIQUE."

IROLD=IR(NP);"INITIALIZE PREVIOUS REGION"

:PNEWMEDIUM:
LOOP["HERE EACH TIME WE CHANGE MEDIUM DURING PHOTON TRANSPORT"
IF (MEDIUM.NE.0)[$SET INTERVAL GLE,GE;"SET PWLF INTERVAL"
$EVALUATE GMFPR0 USING GMFP(GLE);]

:PTRANS:
LOOP["PHOTON TRANSPORT LOOP"
IF (MEDIUM.EQ.0)[TSTEP=VACDST;]
ELSE [$SET-RHOF;    "DENSITY RATIO SCALING TEMPLATE"
GMFP=GMFPR0/RHOF;
$RAYLEIGH-CORRECTION;  "A RAYLEIGH SCATTERING TEMPLATE"
"Ali:photonuc, 1 line"
$PHOTONUC-CORRECTION;  "A PHOTONUCLEAR TEMPLATE"
TSTEP=GMFP*DPMFP;]
"   SET DEFAULT VALUES FOR FLAGS SENT BACK FROM USER"
IRNEW=IR(NP);"SET DEFAULT NEW REGION NUMBER"
IDISC=0;"ASSUME PHOTON NOT DISCARDED"
USTEP=TSTEP;"TRANSFER TRANSPORT DISTANCE TO USER VARIABLE"
TUSTEP=USTEP;

"IF (USTEP.GT.DNEAR(NP)) [;CALL HOWFAR;]"
$CALL-HOWFAR-IN-PHOTON; "The above is the default replacement"


"   NOW CHECK FOR USER DISCARD REQUEST"
IF (IDISC.GT.0)["USER REQUESTED IMMEDIATE DISCARD"
GO TO :USER-PHOTON-DISCARD:;]

VSTEP=USTEP; "SET VARIABLE FOR OUTPUT CODE"
TVSTEP=VSTEP;
EDEP=PZERO; "NO ENERGY DEPOSITION ON PHOTON TRANSPORT"

x_final = x(np) + u(np)*vstep;
y_final = y(np) + v(np)*vstep;
z_final = z(np) + w(np)*vstep;

$AUSCALL($TRANAUSB);

"   TRANSPORT THE PHOTON"
x(np) = x_final; y(np) = y_final; z(np) = z_final;
DNEAR(NP)=DNEAR(NP)-USTEP;"DEDUCT FROM DISTANCE TO NEAREST BOUNDARY"
IF (MEDIUM.NE.0)[DPMFP=MAX(0.,DPMFP-USTEP/GMFP);] "DEDUCT MFP'S"
IROLD=IR(NP); "SAVE PREVIOUS REGION"

MEDOLD=MEDIUM;
IF (IRNEW.NE.IROLD) ["REGION CHANGE"
  $photon_region_change;
]

"   AFTER TRANSPORT CALL TO USER"
$AUSCALL($TRANAUSA);
"oct 31 bug found by C Ma. PCUT discard now after AUSGAB call"
IF(EIG.LE.PCUT(IRL)) [GO TO :PCUT-DISCARD:;]

"   NOW CHECK FOR DEFERRED DISCARD REQUEST.  MAY HAVE BEEN SET"
"   BY EITHER HOWFAR, OR ONE OF THE TRANSPORT AUSGAB CALLS"
IF (IDISC.LT.0) GO TO :USER-PHOTON-DISCARD:;

IF (MEDIUM.NE.MEDOLD) EXIT :PTRANS:;

IF (MEDIUM.NE.0.AND.DPMFP.LE.$EPSGMFP)["TIME FOR AN INTERACTION"
EXIT :PNEWMEDIUM:;]
]REPEAT ":PTRANS: LOOP"

]REPEAT ":PNEWMEDIUM: LOOP"


"   IT IS FINALLY TIME TO INTERACT."
"   THE FOLLOWING MACRO ALLOWS ONE TO INTRODUCE RAYLEIGH SCATTERING"
$RAYLEIGH-SCATTERING;
"Ali:photonuclear, 1 line"
$PHOTONUCLEAR;
$RANDOMSET RNNO36; "THIS RANDOM NUMBER DETERMINES WHICH INTERACTION"
"   GBR1=PAIR/(PAIR+COMPTON+PHOTO)=PAIR/GTOTAL"
$EVALUATE GBR1 USING GBR1(GLE);
IF((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )["IT WAS A PAIR PRODUCTION"
    $AUSCALL($PAIRAUSB);
    CALL PAIR;
    "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
    "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
    "   LEADING PARTICLE SELECTION, ETC.))."
    "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
    "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
    $PARTICLE-SELECTION-PAIR;
    $AUSCALL($PAIRAUSA);
    IF( iq(np) ~= 0 ) [ EXIT :PNEWENERGY:; ]
    ELSE [ "this may happen if pair electrons killed via Russian Roulette"
        goto :PAIR-ELECTRONS-KILLED:;
    ]
]
"GBR2=(PAIR+COMPTON)/GTOTAL"
$EVALUATE GBR2 USING GBR2(GLE);
IF (RNNO36.LT.GBR2)["IT WAS A COMPTON"
    $AUSCALL($COMPAUSB);
    CALL COMPT;
    "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
    "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
    "   LEADING PARTICLE SELECTION, ETC.))."
    "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
    "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
    $PARTICLE-SELECTION-COMPT;
    $AUSCALL($COMPAUSA);
    IF (IQ(NP).NE.0"NOT PHOTON")EXIT:PNEWENERGY:;
]
ELSE["IT WAS PHOTOELECTRIC EFFECT"
    $AUSCALL($PHOTOAUSB);
    CALL PHOTO;
    "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
    "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
    "   LEADING PARTICLE SELECTION, ETC.))."
    "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
    "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
    $PARTICLE-SELECTION-PHOTO;
    IF (NP = 0 | NP < NPOLD ) [RETURN;]
      "The above may happen if Russian Roulette is on"
      "NP<NPOLD means that only electrons were created in the interaction"
      "and that all of them were killed. Hence, the top particle on the "
      "stack is from a previous interaction and may be in another region"
      "To avoid problems with the :PNEWENERGY: loop logic, we simply force"
      "a return to shower so that ELECTR or PHOTON are properly re-entered."
      "Changed by IK Dec. 21 2006 after D. Rogers and R. Taylor found a"
      "wrong dose with brems splitting and Russian Roulette on in a low "
      "energy calculation."

    $AUSCALL($PHOTOAUSA);
    IF (IQ(NP) ~= 0 ) EXIT :PNEWENERGY:;
] "END OF PHOTO ELECTRIC BLOCK"

:PAIR-ELECTRONS-KILLED:

"   IF HERE, THEN GAMMA IS LOWEST ENERGY PARTICLE."
PEIG=E(NP);
EIG=PEIG;
IF(EIG.LT.PCUT(IRL)) GO TO :PCUT-DISCARD:;
]REPEAT ":PNEWENERGY: LOOP"

"   IF HERE, MEANS ELECTRON TO BE TRANSPORTED NEXT"
RETURN;

"---------------------------------------------"
"PHOTON CUTOFF ENERGY DISCARD SECTION         "
"---------------------------------------------"
:PCUT-DISCARD:
IF( medium > 0 ) [
    IF(EIG.GT.AP(MEDIUM)) [IDR=$EGSCUTAUS;]ELSE[IDR=$PEGSCUTAUS;]
] ELSE [ IDR=$EGSCUTAUS; ]
EDEP=PEIG;"GET ENERGY DEPOSITION FOR USER"
$PHOTON-TRACK-END;
IRCODE=2;
NP=NP-1;
RETURN;

"---------------------------------------------"
"User requested photon discard section        "
"---------------------------------------------"
:USER-PHOTON-DISCARD:
EDEP=PEIG;
$AUSCALL($USERDAUS);
IRCODE=2;
NP=NP-1;
RETURN;

"END OF SUBROUTINE PHOTON"  END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE SHOWER(IQI,EI,XI,YI,ZI,UI,VI,WI,IRI,WTI);
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-SHOWER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,STACK,UPHIOT,RANDOM/;

"Input variables"
$REAL EI,      "initial shower energy"
      XI,YI,ZI,"initial co-ordinates"
      UI,VI,WI,"initial direction cosines"
      WTI;     "initial weight"

$INTEGER
      IQI,     "initial particle charge"
      IRI;     "initial region number"

"Local variables"
DOUBLE PRECISION
      DEG,    "energy for pi-zero option"
      DPGL,   "angle factor for pi-zero option"
      DEI,    "incident energy for pi-zero option"
      DPI,    "intermediate factor for pi-zero option"
      DCSTH,  "random number for pi-zero option"
      DCOSTH, "cos(theta) for pi-zero option"
      PI0MSQ; "pi-zero mass squared (in MeV**2)"

$REAL DNEARI, "initial distance to closest boundary"
      CSTH;   "random number for pi-zero option"

$INTEGER
      IRCODE; "status returned by ELECTR or PHOTON"

DATA PI0MSQ/1.8215416D4/;  "PI-ZERO MASS (MEV) SQUARED"

NP=1; NPold = NP;      "Set the old stack counter"
DNEARI=0.0;
IQ(1)=IQI; E(1)=EI; U(1)=UI; V(1)=VI; W(1)=WI;
$TRANSFER PROPERTIES TO (1) FROM I;

IF (IQI = 2) ["PI-ZERO OPTION"
  "IF(EI <= PI0MSQ) [OUTPUT EI;    corrected Oct 24 1995 e-mail Hideo H "
  "                  noted by      Dr.  Muroyama at Nagoya University
  IF(EI**2 <= PI0MSQ) [
     $egs_fatal('(//a/,a,g15.5,a)',
     ' Stopped in subroutine SHOWER---PI-ZERO option invoked',
     ' but the total energy was too small (EI=',EI,' MeV)');
  ]
  $RANDOMSET CSTH;
  DCSTH=CSTH; DEI=EI; DPI=DSQRT(DEI*DEI-PI0MSQ);
  DEG=DEI+DPI*DCSTH; DPGL=DPI+DEI*DCSTH; DCOSTH=DPGL/DEG;
  COSTHE=DCOSTH; SINTHE=DSQRT(1.D0-DCOSTH*DCOSTH);
  IQ(1)=0; E(1)=DEG/2.;
  CALL UPHI(2,1);
  NP=2;
  DEG=DEI-DPI*DCSTH; DPGL=DPI-DEI*DCSTH; DCOSTH=DPGL/DEG;
  COSTHE=DCOSTH; SINTHE=-DSQRT(1.D0-DCOSTH*DCOSTH);
  IQ(2)=0; E(2)=DEG/2.;
  CALL UPHI(3,2);
]"end of pi-zero option"

"The following convoluted logic is difficult to follow"
"when one modifies the outcome of certain interactions"
"using nbr_split, Russian Roulette, or one of the     "
"particle selection macros. I'm simplifying it        "
"so that ircode becomes irrelevant. IK, August 2002   "
":TOPSTACK:"
"LOOP["
"   $KERMA-INSERT;"
"   IF(IQ(NP) = 0) GO TO :PHOTON:;"
"   LOOP ["
"      :ELECTRON:"
"      CALL ELECTR(IRCODE);"
"      IF(IRCODE.EQ.2) EXIT; "
"      :PHOTON:"
"      CALL PHOTON(IRCODE);"
"      IF(IRCODE.EQ.2) EXIT;"
"   ]REPEAT"
"   IF(NP <= 0) EXIT;"
"]REPEAT "

LOOP [
    ;
    IF( np <= 0 ) EXIT;
    $KERMA-INSERT;  " DEFAULT FOR $KERMA-INSERT; IS ; (NULL)"
    IF( iq(np) = 0 ) [ call photon(ircode); ]
    ELSE             [ call electr(ircode); ]

]

RETURN;
"end of subroutine shower"  END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE UPHI(IENTRY,LVL);
"                                                                  "
"******************************************************************"
"   UPHI STANDS FOR 'UNIFORM PHI DISTRIBUTION'.                    "
"   SET COORDINATES FOR NEW PARTICLE OR RESET DIRECTION COSINES OF "
"   OLD ONE.  GENERATE RANDOM AZIMUTH SELECTION AND REPLACE THE    "
"   DIRECTION COSINES WITH THEIR NEW VALUES.                       "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-UPHI;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM/;

"Input variables"
integer  IENTRY,LVL; "entry switches"

"Local variables"
$REAL CTHET,  "5/2*pi-THETA, used to evaluate cos(THETA) using the sine table"
      RNNO38, "random number for azimuthal angle selection"
      PHI,    "azimuthal scattering angle"
      CPHI,   "5/2*pi-PHI"
      A,B,C,  "direction cosines before rotation"
      SINPS2, "SINPS2=A*A+B*B"
      SINPSI, "Sqrt(SINPS2)"
      US,VS,  "x- and y- component of scattering vector"
      SINDEL,COSDEL;
              "aux. variables for the rotation algorithm"

$INTEGER
      IARG,   "index for AUSGAB"
      LPHI,LTHETA,LCTHET,LCPHI;
              "indeces for sine table"

$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
save CTHET,PHI,CPHI,A,B,C,SINPS2,SINPSI,US,VS,SINDEL,COSDEL;

$AUSCALL($UPHIAUSB);
GO TO (:UPHI:,:UPHI2:,:NRK:),IENTRY;
"   IENTRY OUT-OF-BOUNDS IF HERE"  GO TO :ERROR:;

:UPHI:; "NOTE: AFB 88/12/12 ADDED SEMI-COLON, ELSE BUG WHEN OVERRIDING SIN"
        "TABLE LOOK-UP"
$SET INTERVAL THETA,SINC;
$EVALUATE SINTHE USING SIN(THETA);
CTHET=PI5D2-THETA;$SET INTERVAL CTHET,SINC;
$EVALUATE COSTHE USING SIN(CTHET);

"   USE THE FOLLOWING ENTRY IF SINTHE AND COSTHE ARE ALREADY KNOWN."
"   SELECT PHI UNIFORMLY OVER THE INTERVAL (0,TWO PI). THEN USE    "
"   PWLF OF SIN FUNCTION TO GET SIN(PHI) AND COS(PHI).  THE COSINE "
"   IS GOTTEN BY COS(PHI)=SIN(9*PI/4 - PHI).                       "

:UPHI2:;

" It is much faster to use the box method for azimuthal angle selection"
" than the following                                                   "
" $RANDOMSET RNNO38;
" PHI=RNNO38*TWOPI;$SET INTERVAL PHI,SINC;
" $EVALUATE SINPHI USING SIN(PHI);
" CPHI=PI5D2-PHI;$SET INTERVAL CPHI,SINC;
" $EVALUATE COSPHI USING SIN(CPHI);
$SELECT-AZIMUTHAL-ANGLE(cosphi,sinphi);

"   USE THE FOLLOWING ENTRY FOR THE SECOND OF TWO PARTICLES WHEN WE"
"   KNOW TWO PARTICLES HAVE A RELATIONSHIP IN THEIR CORRECTIONS.   "
"   NOTE: SINTHE AND COSTHE CAN BE CHANGED OUTSIDE THROUGH COMMON. "
"   LVL IS A PARAMETER TELLING WHICH PARTICLES TO WORK WITH.       "
"   THETA (SINTHE AND COSTHE) ARE ALWAYS RELATIVE TO THE DIRECTION "
"   OF THE INCIDENT PARTICLE BEFORE ITS DIRECTION WAS ADJUSTED.    "
"   THUS WHEN TWO PARTICLES NEED TO HAVE THEIR DIRECTIONS COMPUTED,"
"   THE ORIGINAL INCIDENT DIRECTION IS SAVED IN THE VARIABLE A,B,C "
"   SO THAT IT CAN BE USED ON BOTH CALLS."

"   LVL=1 -- OLD PARTICLE, SAVE ITS DIRECTION AND ADJUST IT"
"   LVL=2 -- NEW PARTICLE. ADJUST DIRECTION USING SAVED A,B,C"
"   LVL=3 -- BREMSSTRAHLUNG GAMMA.  SAVE ELECTRON DIRECTION (NEXT  "
"   TO TOP OF STACK), AND THEN ADJUST GAMMA DIRECTION."

:NRK:
GO TO (:OLD-PARTICLE:,:NEW-PARTICLE:,:BREMS-GAMMA:),LVL;
"   LVL OUT-OF-BOUNDS IF HERE"   GO TO :ERROR:;

:OLD-PARTICLE:
A=U(NP);B=V(NP);C=W(NP);
GO TO :ADJUST:;

:BREMS-GAMMA:
A=U(NP-1);B=V(NP-1);C=W(NP-1);

:NEW-PARTICLE:
$TRANSFER PROPERTIES TO (NP) FROM (NP-1);

"   SEE H.H. NAGEL DISSERTATION FOR COORDINATE SYSTEM DESCRIPTION. "
"   A ROTATION IS PERFORMED TO TRANSFORM DIRECTION COSINES OF THE  "
"   PARTICLE BACK TO THE PHYSICAL FRAME (FROM THE TRANSPORT FRAME) "

:ADJUST:
SINPS2=A*A+B*B;
"   If SINPS2 is small, no rotation is needed    "
IF (SINPS2.LT.1.0E-20)["small polar angle case"
   U(NP)=SINTHE*COSPHI;
   V(NP)=SINTHE*SINPHI;
   W(NP)=C*COSTHE;    "fixed March 2001 from =COSTHE"
] "end small polar angle case"
ELSE["large polar angle case"
   SINPSI=SQRT(SINPS2);
   US=SINTHE*COSPHI;
   VS=SINTHE*SINPHI;
   SINDEL=B/SINPSI;
   COSDEL=A/SINPSI;
   U(NP)=C*COSDEL*US-SINDEL*VS+A*COSTHE;
   V(NP)=C*SINDEL*US+COSDEL*VS+B*COSTHE;
   W(NP)=-SINPSI*US+C*COSTHE;
]"end large polar angle case"

$AUSCALL($UPHIAUSA);

RETURN;

:ERROR: "REACH THIS POINT IF EITHER IENTRY OR LVL NE 1,2, OR 3"
$egs_fatal('(a,2i6)',' STOPPED IN UPHI WITH IENTRY,LVL=',IENTRY,LVL);

"END OF SUBROUTINE UPHI"    END;

;
%E
"*************************************************************************
"
" The following is a set of macros and subroutines that implement
" bremsstrahlung sampling from the S. Seltzer (NIST) cross sections
" (which are the basis for ICRU radiative stopping powers, into the
" EGSnrc environment) or the NRC cross sections, which are essentially
" the same as NIST, but with corrections to the electron-electron
" contribution (corrections are only significant for low values of
" atomic number Z and low values of the emitted photon energy k.
"
" In order to use it, you have to `turn on' this option by
" setting ibr_nist (which is in COMON/BREMPR/) to ibr_nist=1 for the
" original NIST data (nist_brems.data) or ibr_nist=2 for the NRC
" data (nrc_brems.data).
"
" If this option is turned on, subroutine HATCH will call
" subroutine init_nist_brems.
" In init_nist_brems the NIST cross sections are read in,
" total bremsstrahlung cross sections are calculated using
" 64 point Gauss-Legendre quadrature, the interpolation arrays
" that are used for total cross sections and brems fraction interpolations
" (esig0, esig1, ebr10, ebr11               for electrons)
" (psig0, psig1, pbr10, pbr11, pbr20, pbr21 for positrons)
" are updated and alias sampling tables for rapid sampling of brems
" energies are created. These alias sampling tables are then used
" during the simulation in subroutine BREMS.
" Be aware that there is a slight inconsistency when using this option
" as resttricted radiative stopping powers used are the ones coming
" from PEGS and so, they are calculated using Bethe-Heitler.
" This will not matter at all if
"   - AP is much smaller than the electron energy
"       and/or
"   - the restricted radiative stopping power is much smaller
"     then the restricted collision stopping power
" Both conditions are usually satisfied.
"
" I. Kawrakow, NRC, January 2000.
"
" Added NRC brems cross-sections
" F. Tessier, NRC, August 2007.
"
"****************************************************************************

subroutine init_nist_brems;
"**************************"

$IMPLICIT-NONE;

$REAL    energy_array($MXBREN),x_array($MXBRXX),
         cs_array($MXBREN,$MXBRXX,$MXBREL);
$REAL    xi_array($MXBRXX);
real*8   x_gauss($MXGAUSS),w_gauss($MXGAUSS);

$INTEGER nmix,kmix,i,n,k,j,ii;
$INTEGER ngauss,i_gauss;
$INTEGER lnblnk1,egs_get_unit;
$INTEGER ifirst,ilast,nener,neke,leil;

$REAL    cs($MXBREN,$MXBRXX),ee($MXBREN),ele($MXBREN);
$REAL    csx($MXBRXX),afx($MXBRXX),bfx($MXBRXX),cfx($MXBRXX),dfx($MXBRXX);
$REAL    cse($MXBREN),afe($MXBREN),bfe($MXBREN),cfe($MXBREN),dfe($MXBREN);
$REAL    Z,sumA;
$REAL    emin,xi,res,spline,eil,ei,beta2,aux,sigb,sigt,ebr1,ebr2;
$REAL    sigee,sigep,sige,si_esig,si1_esig,si_ebr1,si1_ebr1,ededx,
         sig_bhabha,si_psig,si1_psig,si_pbr1,si1_pbr1,si_pbr2,si1_pbr2;
$INTEGER iz;
$REAL    ple,qle,x,f,error,max_error,x_max_error,f_max_error;
$INTEGER ndat,k_max_error;
character tmp_string*512, tmp1_string*512;
integer  itmp;

$declare_write_buffer;

$REAL amu;
parameter (amu = 1660.5655);  "converts the cross sections from mB/per atom"
                              "to cm^2/g"
$LOGICAL ex,is_opened;
$declare_max_medium;
$COMIN-INIT-NIST-BREMS;

$set_string(tmp_string,' ');
tmp_string = $cstring(hen_house) // 'data' // $file_sep;

IF( ibr_nist = 1 ) [
    $open_data_file(tmp_string,tmp1_string,'nist_brems.data',$NIST-DATA-UNIT);
]
ELSE IF (ibr_nist = 2) [
    $open_data_file(tmp_string,tmp1_string,'nrc_brems.data',$NIST-DATA-UNIT);
]
ELSE [
    $egs_fatal(*,' init_nist_brems: unknown value of ibr_nist!
    ibr_nist = ', ibr_nist);
]

"Get the S. Seltzer (ibr_nist=1) or NRC's (ibr_nist=2) brems cross sections"
"
rewind($NIST-DATA-UNIT);
read($NIST-DATA-UNIT,*);
read($NIST-DATA-UNIT,*) nmix,kmix;
IF (kmix > $MXBRXX) [
    $egs_fatal(*,' init_nist_brems: to many k values in data file!');
]
IF (nmix > $MXBREN) [
    $egs_fatal(*,' init_nist_brems: to many T values in data file!');
]

read($NIST-DATA-UNIT,*) (energy_array(n),n=1,nmix);
DO n=1,nmix [ energy_array(n) = $NIST-ENERGY-SCALE*energy_array(n); ]
read($NIST-DATA-UNIT,*) (x_array(k),k=1,kmix);
read($NIST-DATA-UNIT,*);
DO i=1,$MXBREL [
    read($NIST-DATA-UNIT,*) ((cs_array(n,k,i),n=1,nmix),k=1,kmix);
]
close($NIST-DATA-UNIT);

DO k=1,kmix [
    xi_array(k)=Log(1-x_array(k)+1e-6);
    IF( fool_intel_optimizer ) [
        $egs_info(*,'xi_array(k): ',xi_array(k));
    ]
]

"Get abscissas and weights for Gauss-Legendre quadrature"
"
ngauss = $MXGAUSS;
call gauss_legendre(0d0,1d0,x_gauss,w_gauss,ngauss);

"Calculate total brems cross sections and sampling tables"
"for all media                                           "

$egs_info(*,' ');
IF (ibr_nist = 1) [
$egs_info(*,'Using NIST brems cross sections! ');
]
ELSE IF (ibr_nist = 2) [
    $egs_info(*,'Using NRC brems cross sections! ');
]
$egs_info(*,' ');
DO medium=1,nmed [

    log_ap(medium) = log(ap(medium));
    $egs_info(*,' Initializing brems data for medium ',medium,'...');
    emin = max(ae(medium) - rm, ap(medium));
    DO i=1,nmix [
        IF( energy_array(i) >= emin ) EXIT;
    ]
    ifirst = i;
    DO i=nmix,1,-1 [
        IF( energy_array(i) < ue(medium) - rm ) EXIT;
    ]
    ilast = i+1;
    IF( ifirst < 1 | ilast > nmix ) [
        $egs_info(*,' init_nist_brems: data available only for ');
        $egs_info(*,energy_array(1),' <= E <= ',energy_array(nmix));
        $egs_info(*,' will use spline interpolations to get cross ');
        $egs_info(*,' sections beyond the available data but this may');
        $egs_info(*,' produce nonsense!');
        IF( ifirst < 1 ) ifirst=1;
        IF( ilast > nmix ) ilast = nmix;
    ]
    DO i=ifirst,ilast [
        ii = i+1 - ifirst;
        ee(ii) = energy_array(i); ele(ii) = log(ee(ii));
        sumA = 0;
        DO j=1,NNE(medium) [ sumA = sumA + pz(medium,j)*wa(medium,j); ]
        sumA = sumA*amu;
        DO k=1,kmix [
            cs(ii,k) = 0;
            DO j=1,NNE(medium) [
                Z = zelem(medium,j); iz = int(Z+0.1); Z = Z*Z/sumA;
                cs(ii,k) = cs(ii,k) + pz(medium,j)*Z*cs_array(i,k,iz);
            ]
            csx(k) = Log(cs(ii,k));
        ]
        call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
        "
        " Integrate
        "
        cse(ii) = 0; aux = Log(ee(ii)/ap(medium));
        DO i_gauss = 1,ngauss [
            xi = log(1 - ap(medium)/ee(ii)*exp(x_gauss(i_gauss)*aux)+1e-6);
            res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
            cse(ii) = cse(ii) + w_gauss(i_gauss)*exp(res);
        ]
    ]
    nener = ilast - ifirst + 1;
    call set_spline(ele,cse,afe,bfe,cfe,dfe,nener);
    "
    " Now replace the PEGS cross sections "
    "
    neke = meke(medium);
    sigee = 1E-15; sigep = 1E-15;
    DO i = 1,neke [
        eil = (float(i) - eke0(medium))/eke1(medium); ei = exp(eil);
        leil = i;
        beta2 = ei*(ei+2*rm)/(ei+rm)**2;
        IF( ei <= ap(medium) ) [ sigb = 1e-30; ]
        ELSE [
            sigb = spline(eil,ele,afe,bfe,cfe,dfe,nener);
            sigb = sigb*log(ei/ap(medium))/beta2*rho(medium);
        ]
        $EVALUATE sigt USING esig(eil);  " sigt is the total cross section "
        $EVALUATE ebr1 USING ebr1(eil);  " coming from PEGS, ebr1*sigt is "
                                         " then the brems cross section "
        IF( sigt < 0 ) sigt = 0;
        IF( ebr1 > 1 ) ebr1 = 1;
        IF( ebr1 < 0 ) ebr1 = 0;
        IF( i > 1 ) [
            si_esig = si1_esig;
            si_ebr1 = si1_ebr1;
            si1_esig = sigt*(1 - ebr1) + sigb;
            si1_ebr1 = sigb/si1_esig;
            esig1(i-1,medium) = (si1_esig - si_esig)*eke1(medium);
            esig0(i-1,medium) = si1_esig - esig1(i-1,medium)*eil;
            ebr11(i-1,medium) = (si1_ebr1 - si_ebr1)*eke1(medium);
            ebr10(i-1,medium) = si1_ebr1 - ebr11(i-1,medium)*eil;
        ]
        ELSE [
            si1_esig = sigt*(1 - ebr1) + sigb;
            si1_ebr1 = sigb/si1_esig;
        ]

        "
        " Positrons "
        "
        $EVALUATE sigt USING psig(eil);
        $EVALUATE ebr1 USING pbr1(eil);
        $EVALUATE ebr2 USING pbr2(eil);
        IF( sigt < 0 ) sigt = 0;
        IF( ebr1 > 1 ) ebr1 = 1;
        IF( ebr1 < 0 ) ebr1 = 0;
        IF( ebr2 > 1 ) ebr2 = 1;
        IF( ebr2 < 0 ) ebr2 = 0;
        sig_bhabha = sigt*(ebr2 - ebr1);
        IF( sig_bhabha < 0 ) sig_bhabha = 0;
        IF( i > 1 ) [
            si_psig = si1_psig;
            si_pbr1 = si1_pbr1;
            si_pbr2 = si1_pbr2;
            si1_psig = sigt*(1 - ebr1) + sigb;
            si1_pbr1 = sigb/si1_psig;
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
            psig1(i-1,medium) = (si1_psig - si_psig)*eke1(medium);
            psig0(i-1,medium) = si1_psig - psig1(i-1,medium)*eil;
            pbr11(i-1,medium) = (si1_pbr1 - si_pbr1)*eke1(medium);
            pbr10(i-1,medium) = si1_pbr1 - pbr11(i-1,medium)*eil;
            pbr21(i-1,medium) = (si1_pbr2 - si_pbr2)*eke1(medium);
            pbr20(i-1,medium) = si1_pbr2 - pbr21(i-1,medium)*eil;
        ]
        ELSE [
            si1_psig = sigt*(1 - ebr1) + sigb;
            si1_pbr1 = sigb/si1_psig;
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
        ]
        $EVALUATE ededx USING ededx(eil);
        sige = si1_esig/ededx;
        IF( sige > sigee ) sigee = sige;
        $EVALUATE ededx USING pdedx(eil);
        sige = si1_psig/ededx;
        IF( sige > sigep ) sigep = sige;
    ]
    esig1(neke,medium) = esig1(neke-1,medium);
    esig0(neke,medium) = esig0(neke-1,medium);
    ebr11(neke,medium) = ebr11(neke-1,medium);
    ebr10(neke,medium) = ebr10(neke-1,medium);
    psig1(neke,medium) = psig1(neke-1,medium);
    psig0(neke,medium) = psig0(neke-1,medium);
    pbr11(neke,medium) = pbr11(neke-1,medium);
    pbr10(neke,medium) = pbr10(neke-1,medium);
    pbr21(neke,medium) = pbr21(neke-1,medium);
    pbr20(neke,medium) = pbr20(neke-1,medium);
    $egs_info(*,' Max. new cross sections per energy loss: ',sigee,sigep);
    esig_e(medium) = sigee; psig_e(medium) = sigep;
    IF( sigee > esige_max ) esige_max = sigee;
    IF( sigep > psige_max ) psige_max = sigep;

    "
    " Now prepare the arrays for brems sampling
    "
    nb_emin(medium) = energy_array(ifirst);
    IF( nb_emin(medium) <= ap(medium) ) [
        nb_emin(medium) = energy_array(ifirst+1);
    ]
    nb_emax(medium) = energy_array(ilast);
    nb_lemin(medium) = log(nb_emin(medium));
    nb_lemax(medium) = log(nb_emax(medium));
    nb_dle(medium) = (nb_lemax(medium) - nb_lemin(medium))/($MXBRES-1);
    nb_dlei(medium) = 1/nb_dle(medium);
    "
    eil = nb_lemin(medium) - nb_dle(medium);
    DO i=1,$MXBRES [
        eil = eil + nb_dle(medium); ei = exp(eil);
        DO ii=1,nener [
            IF( ei < ee(ii) ) EXIT;
        ]
        ii = ii-1;
        IF( ii < 1) ii = 1;
        IF( ii > nener-1 ) ii = nener-1;
        "
        " ple and qle are energy interpolation coefficients
        "
        ple = (eil - ele(ii))/(ele(ii+1)-ele(ii)); qle = 1 - ple;
        DO k=1,kmix [
            csx(k) = log(qle*cs(ii,k) + ple*cs(ii+1,k));
        ]
        call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
        "
        " fill the abscissas for this energy
        "
        x = ap(medium)/ei; aux = -log(x);
        xi = log(1 - x+1e-6);
        res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
        nb_xdata(0,i,medium) = 0;
        nb_fdata(0,i,medium) = exp(res);

        DO k=1,kmix [
            IF( x_array(k) > x ) EXIT;
        ]
        IF( k > kmix ) k = kmix;
        ndat = 0;
        DO j=k+1,kmix-1 [
            ndat = ndat+1;
            nb_xdata(ndat,i,medium) = log(x_array(j)/x)/aux;
            nb_fdata(ndat,i,medium) = exp(csx(j));
            IF( fool_intel_optimizer ) [
                $egs_info(*,'nb_xdata(ndat,i,medium): ',
                        nb_xdata(ndat,i,medium));
            ]
        ]
        ndat = ndat+1;
        nb_xdata(ndat,i,medium) = 1;
        nb_fdata(ndat,i,medium) = exp(csx(kmix));
        "
        " Now expand the arrays by filling intermediate points
        " at the positions that show the maxium relative error
        " when using linear interpolation in x.
        " If arrays were allocated dynamically one could use
        " a certain condition to stop the iteration but in our case
        " memory is allocated anyway and so we use the maximum
        " space provided
        "
        IF( ndat >= $MXBRXS ) goto :SKIP-LOOP:;
        LOOP [
            x_max_error = 0; f_max_error = 0; k_max_error = 0;
            max_error = 0;
            DO k=0,ndat-1 [
                x = 0.5*(nb_xdata(k,i,medium) + nb_xdata(k+1,i,medium));
                f = 0.5*(nb_fdata(k,i,medium) + nb_fdata(k+1,i,medium));
                xi = log(1 - ap(medium)/ei*exp(x*aux)+1e-6);
                res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
                res = exp(res);
                error = abs(1-f/res);
                IF( error > max_error ) [
                    x_max_error = x;
                    f_max_error = res;
                    max_error = error;
                    k_max_error = k;
                ]
            ]
            ndat = ndat+1;
            DO k=ndat,k_max_error+2,-1 [
                nb_xdata(k,i,medium) = nb_xdata(k-1,i,medium);
                nb_fdata(k,i,medium) = nb_fdata(k-1,i,medium);
            ]
            nb_xdata(k_max_error+1,i,medium) = x_max_error;
            nb_fdata(k_max_error+1,i,medium) = f_max_error;
        ] UNTIL (ndat = $MXBRXS);

        :SKIP-LOOP:
        "
        " Now generate the alias tables for rapid brems sampling
        " during run time
        "
        call prepare_alias_table($MXBRXS,nb_xdata(0,i,medium),
               nb_fdata(0,i,medium),nb_wdata(1,i,medium),nb_idata(1,i,medium));

    ]
]
$egs_info(*,' ');
$egs_info(*,' ');
return;
" Errors "
:data_file_error:
$egs_fatal(*,'failed to open EGSnrc data file ',$cstring(tmp1_string));
return;
end;

%E
/***************************************************************************
 *
 * A subroutine to initialize pair energy sampling from the NRC
 * cross sections differential in the positron energy.
 * These cross sections are calculated as the product of the
 * exact cross section without screening times the ratio
 * of the first Born approximation with screening to the first
 * Born approximation without screening.
 * At high energies (above, say, 50 MeV) the NRC cross sections are
 * are very close to the Bethe-Heitler cross sections but
 * there are significant differences at low energies. In particular,
 * the asymetrie in the energy distribution between the positron
 * and the electron is properly taken into account.
 *
 * I. Kawrakow, April 2005.
 *
 ***************************************************************************/

subroutine init_nrc_pair;
implicit none;
$declare_max_medium;
;COMIN/MEDIA,BREMPR,ELECIN,NRC-PAIR-DATA,THRESH,USEFUL,EGS-IO/;
$declare_write_buffer;

character     nrcp_file*256, endianess*4;
integer       egs_get_unit;
$INTEGER      nrcp_unit, want_nrcp_unit, rec_length;
$INTEGER      i, lnblnk1;
$REAL         tmp, ddx, xx, Z;
real*4        emin, emax;
integer*4     ne, nb, ix, ie, irec, i_ele, nbb, iz;
REPLACE {$cdum_size} WITH {{COMPUTE 4*($NRC-PAIR-NXX-4)-1}};
character     endian, cdum($cdum_size);
$LOGICAL      swap;
real*4        tmp_4, tarray($NRC-PAIR-NXX);
integer*4     itmp_4;
character     c_4(4), ic_4(4);
equivalence   (tmp_4,c_4), (itmp_4, ic_4);

$set_string(nrcp_file,' ');
nrcp_file = $cstring(hen_house) // 'data' // $file_sep // 'pair_nrc1.data';
want_nrcp_unit = 62;
nrcp_unit = egs_get_unit(want_nrcp_unit);
IF( nrcp_unit < 1 ) [
    $egs_fatal(*,'init_nrc_pair: failed to get a free fortran unit');
]

rec_length = $NRC-PAIR-NXX*$RECL-FACTOR;
open(nrcp_unit,file=nrcp_file,form='unformatted',access='direct',
        status='old',recl=rec_length,err=:nrcp-open-error:);
read(nrcp_unit,rec=1,err=:nrcp-read-error:) emin, emax, ne, nb, endian, cdum;
IF( ichar(endian) = 0 ) [ endianess = '1234'; ] ELSE [ endianess = '4321'; ]
swap = endianess.ne.$BYTE_ORDER;
IF( swap ) [
    tmp_4 = emin; call egs_swap_4(c_4); emin = tmp_4;
    tmp_4 = emax; call egs_swap_4(c_4); emax = tmp_4;
    itmp_4 = ne; call egs_swap_4(ic_4); ne = itmp_4;
    itmp_4 = nb; call egs_swap_4(ic_4); nb = itmp_4;
]
$egs_info('(//a,a)','Reading NRC pair data base from ',$cstring(nrcp_file));
$egs_info('(a,a,a)','Data generated on a machine with ',endianess,' endianess');
$egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
IF( swap ) [ $egs_info('(a)','=> will need to do byte swaping'); ]
$egs_info('(a,2f9.3)','Energy range of the data: ',emin,emax);
IF( nb ~= $NRC-PAIR-NXX ) [
    $egs_fatal(*,'Inconsistent x-grid size');
]
IF( ne ~= $NRC-PAIR-NEE ) [
    $egs_fatal(*,'Inconsistent energy grid size');
]
nrcp_emin = emin; nrcp_emax = emax;
nrcp_dle = log((emax-2)/(emin-2))/(ne-1); nrcp_dlei = 1/nrcp_dle;

nbb = nb/2; ddx = sqrt(0.5)/nbb;
DO ix=0,nbb [ xx = ddx*ix; nrcp_xdata(ix+1) = xx*xx; ]
do ix=nbb-1,0,-1 [ xx = ddx*ix; nrcp_xdata(nb-ix) = 1 - xx*xx; ]

DO medium = 1,NMED [
    $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
    DO ie=1,$NRC-PAIR-NEE [
        DO ix=1,$NRC-PAIR-NXX [ nrcp_fdata(ix,ie,medium) = 0; ]
    ]
    DO i_ele=1,NNE(medium) [
        Z = ZELEM(medium,i_ele); iz = int(Z+0.5);
        tmp = PZ(medium,i_ele)*Z*Z;
        irec = (iz-1)*ne + 2;
        DO ie=1,$NRC-PAIR-NEE [
            read(nrcp_unit,rec=irec,err=:nrcp-read-error:) tarray;
            DO ix=1,$NRC-PAIR-NXX [
                tmp_4 = tarray(ix);
                IF( swap ) [ call egs_swap_4(c_4); ]
                nrcp_fdata(ix,ie,medium)=nrcp_fdata(ix,ie,medium)+tmp*tmp_4;
            ]
            irec = irec + 1;
        ]
    ]
    DO ie=1,$NRC-PAIR-NEE [
        call prepare_alias_table(nb-1,nrcp_xdata,nrcp_fdata(1,ie,medium),
                nrcp_wdata(1,ie,medium),nrcp_idata(1,ie,medium));
    ]

    $egs_info('(a)',' done');

]
$egs_info(*,' ');
close(nrcp_unit);
return;

:nrcp-open-error:;
$egs_fatal(*,'Failed to open NRC pair data file');

:nrcp-read-error:;
$egs_fatal(*,'I/O error while reading NRC pair data file');

end;

%E
"******************************************************************"
"                               NATIONAL RESEARCH COUNCIL OF CANADA"
"                                                                  "
subroutine vmc_electron(ircode);
"                                                                  "
"******************************************************************"
"   This subroutine performs condensed history simulation of       "
"   electron/positron transport according to VMC                   "
"                                                                  "
"   Version 1.0   Iwan Kawrakow       Initial coding               "
"                                     coding is in EGSnrc style    "
"                                     for maximum compatibility    "
"                                     with EGSnrc user codes       "
"******************************************************************"

$IMPLICIT-NONE;

;COMIN/EGS-IO/;

$INTEGER ircode;
$egs_fatal('(//a//)',
' ********* VMC Transport option not in this distribution ****** ');
end;

" Subroutine versions of the random number generator "
" Included here because it makes life easier for using the EGSnrc RNG"
" from within the C-interface. "
subroutine egs_init_default_rng;
;COMIN/RANDOM/;
$RNG-DEFAULT-INITIALIZATION;
return; end;

subroutine egs_init_rng(arg1,arg2);
$INTEGER arg1,arg2;
;COMIN/RANDOM/;
$declare_write_buffer;
$INITIALIZE RNG USING arg1 AND arg2;
return; end;

subroutine egs_get_rndm(ran);
$REAL ran;
;COMIN/RANDOM/;
$RANDOMSET ran;
return; end;

subroutine egs_get_rndm_array(n,rarray);
$INTEGER n;
$REAL    rarray(*);
;COMIN/RANDOM/;
$REAL    rtmp;
$INTEGER i;
IF( n < 1 ) return;
DO i=1,n [
    $RANDOMSET rtmp; rarray(i) = rtmp;
]
return; end;

/****************************************************************************
 *
 * Subroutines for modelling Electron Impact Ionization (EII) in EGSnrc.
 * This implementation uses EII cross section derived from a GOS
 * approach using photo-ionization cross sections from EPDL97 for the
 * OOS. It is called "simple" because
 *   - Ionizations of only K-, LI-, LII- and LIII-shell with binding
 *     energies above 1 keV are taken into account
 *   - Simplified versions of the differential cross sections are used
 *     (but it is made sure that the total energy loss is still
 *      correctly reproduced).
 *
 * EII is turned on by setting the flag eii_flag in COMIN/EII-DATA/ to 1.
 *
 * Iwan Kawrakow, March 2004.
 *
 *****************************************************************************/

"**************************************************************************"
"Init EII. This subroutine is called from HATCH after all media are known, "
"threshold energies and interpolation data have been initialized.          "
"**************************************************************************"
subroutine eii_init;
"**************************************************************************"
implicit none;
$COMIN-EII-INIT;
$INTEGER imed,iele,ish,nsh,iZ,j,i,itmp,nskip,nbin,ii,nsh_tot,iii,k;
$INTEGER jj,jjj;
integer*4 lnblnk1;
$INTEGER tmp_array($MXELEMENT);
$INTEGER want_eii_unit,eii_unit,eii_out,egs_open_file;
integer  egs_get_unit;
$REAL    e_eii_min,emax,fmax,aux_array($N_EII_BINS);
$REAL    sigo,loge,tau,beta2,p2,uwm,Wmax;
$REAL    ss_0, ss_1, sh_0, sh_1, aux, av_e, con_med, dedx_old, sigm_old;
$REAL    dedx,e,sig,sigm,wbrem,sum_a,sum_z,sum_pz,sum_wa,Ec,Ecc;
$REAL    sum_sh,sum_occn,U,sum_sigma,sum_dedx;
$REAL    sigma,sigma_old,wbrem_old,sig_j,de;
$INTEGER lloge;
$LOGICAL check_it,is_monotone,getd;
$REAL    sigma_max;
character eii_file*128;
character*512 toUpper;
$INTEGER occn_numbers(4);
$declare_write_buffer;
$REAL    cons;
parameter (cons = 0.153536); " 2*Pi*Re^2*rm/u "
data     occn_numbers/2,2,2,4/;

DO j=1,$MXELEMENT [ eii_nshells(j) = 0; ]
DO j=1,$MXMED [ eii_nsh(j) = 0; ]
IF( eii_flag = 0 ) [ return; ]

$need_relaxation_data(getd);
IF( ~getd )[
  $egs_fatal('(/a,/a,/a,/a)',
          ' In subroutine eii_init: ',
          '   Scattering off bound electrons creates atomic vacancies,',
          '   potentially starting an atomic relaxation cascade. ',
          '   Please turn ON atomic relaxations.');
]

/*
  find minimum of all threshold energies
 */
e_eii_min = 1e30;
DO imed = 1,nmed [
    IF( ae(imed)-rm < e_eii_min ) e_eii_min = ae(imed) - rm;
    IF( ap(imed) < e_eii_min ) e_eii_min = ap(imed);
]
$egs_info(*,' ');
$egs_info(*,'eii_init: minimum threshold energy found: ',e_eii_min);

/*
  determine elements that need to load EII data
 */
DO imed = 1,nmed [
    DO iele = 1,nne(imed) [
        iZ = int(zelem(imed,iele)+0.5);
        IF( eii_nshells(iZ) = 0 ) [
            nsh = 0;
            DO ish=1,4 [
                IF( binding_energies(ish,iZ) > e_eii_min ) nsh = nsh+1;
            ]
            eii_nshells(iZ) = nsh;
        ]
    ]
]

/* total number of shells that need to be loaded */
nsh = 0;
DO iZ=1,$MXELEMENT [
    nsh = nsh + eii_nshells(iZ);
]
IF( nsh = 0 ) [
    $egs_info(*,'*** EII requested but no shells with binding energies ');
    $egs_info(*,'    above the specified threshold found');
    $egs_info(*,'    => turning off EII');
    eii_flag = 0;
]
IF( nsh > $MAX_EII_SHELLS ) [
    $egs_info(*,'*** Number of shells with binding energies greater than ');
    $egs_info(*,'    the specified thresholds is ',nsh);
    $egs_info(*,'    This is more than the allocated arrays can hold');
    $egs_fatal(*,'    Increase the macro $MAX_EII_SHELLS and retry');
]
$egs_info(*,'eii_init: number of shells to simulate EII: ',nsh);
nsh_tot = nsh;
tmp_array(1) = 0;
DO j=2,$MXELEMENT [ tmp_array(j) = tmp_array(j-1) + eii_nshells(j-1); ]

/* set EII active shells per medium and for each element */
DO imed=1,nmed [
    nsh = 0;
    DO iele=1,nne(imed) [
        iZ = int(zelem(imed,iele)+0.5);
        eii_no(imed,iele) = eii_nshells(iZ);
        nsh = nsh + eii_nshells(iZ);
        IF( eii_nshells(iZ) > 0 ) [ eii_first(imed,iele) = tmp_array(iZ) + 1; ]
        ELSE [ eii_first(imed,iele) = 0; ]
    ]
    eii_nsh(imed) = nsh;
]

/* read EII data */
$set_string(eii_file,' ');
eii_file = $cstring(hen_house) // 'data' // $file_sep // 'eii_'//
           $cstring(eii_xfile) //'.data';
want_eii_unit = 62;
eii_unit = egs_get_unit(want_eii_unit);
IF( eii_unit < 1 ) [
    $egs_fatal(*,'eii_init: failed to get a free Fortran I/O unit');
]
open(eii_unit,file=$cstring(eii_file),status='old',err=:no-eii-file:);
$egs_info('(//a,a)','Opened EII data file ',$cstring(eii_file));
$egs_info('(a,$)',' eii_init: reading EII data ... ');
read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) nskip;
DO j=1,nskip [
    read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:);
]
read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) emax,nbin;
IF( nbin ~= $N_EII_BINS ) [
    $egs_fatal(*,'Inconsistent EII data file');
]
IF (xsec_out = 1)[
   eii_out = egs_open_file(93,0,1,'.eiixsec');
]
ii = 0;
DO j=1,$MXELEMENT [
    read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) iZ,nsh;
    IF (xsec_out = 1 & eii_nshells(iZ) > 0)[
     write(eii_out,*) '=================================';
     write(eii_out,'(a,i3)') 'EII xsections for element Z = ',iZ;
     write(eii_out,*) '=================================';
    ]
    IF( nsh < eii_nshells(iZ) ) [
        $egs_info(*,'EII data file has data for ',nsh,' shells for element ');
        $egs_info(*,iZ,' but according');
        $egs_info(*,'to binding energies and thresholds ',eii_nshells(iZ));
        $egs_info(*,'shells are required');
        $egs_fatal(*,'This is a fatal error.');
    ]
    DO ish=1,nsh [
        read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) fmax;
        read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:)
           aux_array;
        "Scale L-shell EII xsections by eii_L_factor. Defaults to 1."
        IF (ish>1 & ish < 5) [fmax = fmax*eii_L_factor;]
        IF( ish <= eii_nshells(iZ) ) [
            IF (xsec_out = 1)[
              IF(ish = 1)[
               write(eii_out,'(a,f10.2,a)')
               'K-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSEIF (ish = 2)[
               write(eii_out,'(a,f9.2,a)')
               '=> LI-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSEIF (ish = 3)[
               write(eii_out,'(a,f8.2,a)')
               '=> LII-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSEIF (ish = 4)[
               write(eii_out,'(a,f8.2,a)')
               '=> LIII-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSE[ write(eii_out,*) '=> Wrong number of shells!';]
              write(eii_out,*) '   E/keV     sigma/(b/atom)';
              write(eii_out,*) '---------------------------';
            ]
            ii = ii+1; eii_z(ii) = iZ; eii_sh(ii) = ish;
            eii_a(ii) = nbin;
            eii_a(ii) = eii_a(ii)/log(emax/binding_energies(ish,iZ));
            eii_b(ii) = 1 - eii_a(ii)*log(binding_energies(ish,iZ));
            DO k=1,nbin [
                IF( k > 1 ) [ sigo = fmax*aux_array(k-1); ]
                ELSE [ sigo = 0; ]
                loge = (k - eii_b(ii))/eii_a(ii); iii = nbin*(ii-1)+k;
                eii_xsection_a(iii) = (fmax*aux_array(k)-sigo)*eii_a(ii);
                eii_xsection_b(iii) = sigo - eii_xsection_a(iii)*loge;
                IF (xsec_out = 1)[
                   write(eii_out,'(f12.2,2X,10f9.2)')
                   Exp((k+1-eii_b(ii))/eii_a(ii))*1000.0,fmax*aux_array(k);
                ]
            ]
        ]
    ]
    IF( ii = nsh_tot ) [ EXIT; ]
]
close(eii_unit);
IF (xsec_out = 1)[ close(eii_out); ]
$egs_info(*,' OK '); $egs_info(*,' ');

/*
   Adjust restricted stopping power and discrete inelastic cross sections

   Discrete interaction cross sections for all shells that come from PEGS4
   are calculated using the Moller cross section
     => we must subtract the Moller cross section for the shells that will
        have EII and then add the EII cross sections for these shells
   The restricted stopping power that comes from PEGS4 is calculated assuming
   that all shells will be producing secondaries according to Moller
     => we must add the energy lost in Moller events in EII shells to the
        restricted stopping power and then subtract the average energy lost
        in EII events.
 */
DO imed = 1,nmed [
    Ec = ae(imed) - rm; Ecc = min(Ec,ap(imed));
    /sum_z,sum_pz,sum_a,sum_wa/=0;
    DO iele=1,nne(imed) [
        sum_z = sum_z + pz(imed,iele)*zelem(imed,iele);
        sum_pz = sum_pz + pz(imed,iele);
        sum_wa = sum_wa + rhoz(imed,iele);
        sum_a = sum_a + pz(imed,iele)*wa(imed,iele);
    ]
    con_med = rho(imed)/1.6605655/sum_a;
    eii_cons(imed) = con_med;
    IF( eii_nsh(imed) > 0 ) [
        is_monotone = .true.;
        sigma_max = 0;
        DO j=1,meke(imed) [
            loge = (j - eke0(imed))/eke1(imed); e = Exp(loge);
            tau = e/rm; beta2 = tau*(tau+2)/(tau+1)**2;
            p2 = 2*rm*tau*(tau+2);
            lloge = j;
            medium = imed;
            $EVALUATE dedx USING ededx(loge);
            IF( e > ap(medium) | e > 2*Ec ) [
                $EVALUATE sig USING esig(loge);
            ] ELSE [ sig = 0; ]
            IF( e > 2*Ec ) [
                $EVALUATE wbrem USING ebr1(loge);
                sigm = sig*(1-wbrem);
            ] ELSE [ sigm = 0; wbrem = 1; ]
            /sum_occn,sum_sigma,sum_dedx/=0;
            DO iele=1,nne(imed) [
                iZ = int(zelem(imed,iele)+0.5);
                sum_sh = 0;
                DO ish = 1,eii_no(imed,iele) [
                    "jj is the shell index in the list of EII shells "
                    jj = eii_first(imed,iele) + ish - 1;
                    "jjj is shell type (1 = K, 2 = LI, 3 = LII, etc.)
                    jjj = eii_sh(jj); U = binding_energies(jjj,iZ);
                    Wmax = (e+U)/2; uwm = U/Wmax;
                    "IF( Uj >= Ecc ) sum_sh = sum_sh + occn_numbers(jjj);
                    IF( U < e & U > Ecc ) [
                        " At this energy interactions with this shell will "
                        " be done using the EII differential x-section "
                        sum_sh = sum_sh + occn_numbers(jjj);
                        ss_0 = 2*(log(p2/U)-uwm**3*log(p2/Wmax)-
                          (beta2+0.833333)*(1-uwm**3))/3/U;
                        sh_0 = ((1-uwm)*(1+uwm/(2-uwm))+U*(Wmax-U)/(e+rm)**2
                          - (2*tau+1)/(tau+1)**2*uwm/2*log((2-uwm)/uwm))/U;
                        ss_1 = log(p2/U)-uwm**2*log(p2/Wmax)-
                          (beta2+1)*(1-uwm**2);
                        sh_1 = log(Wmax/U/(2-uwm))+2*(Wmax-U)/(2*Wmax-U)
                          +(Wmax**2-U**2)/(e+rm)**2/2
                          -(2*tau+1)/(tau+1)**2*log((2*Wmax-U)/Wmax);
                        av_E = (ss_1 + sh_1)/(ss_0 + sh_0);
                          "av_E is the average energy lost in a collision"
                          "with this shell"
                        i = eii_a(jjj)*loge + eii_b(jjj);
                        i = (jj-1)*$N_EII_BINS + i;
                        sig_j = eii_xsection_a(i)*loge + eii_xsection_b(i);
                        sig_j = sig_j*pz(imed,iele)*con_med;
                        sum_sigma = sum_sigma + sig_j;
                        sum_dedx = sum_dedx + sig_j*av_E;
                    ]
                ]
                sum_occn = sum_occn + sum_sh*pz(imed,iele);
            ]
            sigm = sigm + sum_sigma;
            dedx = dedx - sum_dedx;
            aux = Ec/e;
            IF( e > 2*Ec ) [
                sigo = cons*sum_occn*rho(imed)/(beta2*Ec)*(
                        (1-2*aux)*(1+aux/(1-aux)+(tau/(tau+1))**2*aux/2)-
                        (2*tau+1)/(tau+1)**2*aux*log((1-aux)/aux))/sum_a;
                de = cons*sum_occn*rho(imed)/beta2*(
                  log(0.25/aux/(1-aux))+(1-2*aux)/(1-aux)+
                  (tau/(tau+1))**2*(1-4*aux*aux)/8-
                  (2*tau+1)/(tau+1)**2*log(2*(1-aux)))/sum_a;
                sigm = sigm - sigo;
                "sigm = sig*(1-wbrem)*(1-sum_occn/sum_z);
                dedx = dedx + de;
            ]
            sigma = sigm + wbrem*sig;
            IF( sigma/dedx > sigma_max ) sigma_max = sigma/dedx;
            IF( sigma > 0 ) [ wbrem = wbrem*sig/sigma; ]
            ELSE [ wbrem = 1; ]
            IF( j > 1 ) [
                ededx1(j-1,imed) = (dedx - dedx_old)*eke1(imed);
                ededx0(j-1,imed) = dedx - ededx1(j-1,imed)*loge;
                esig1(j-1,imed) = (sigma - sigma_old)*eke1(imed);
                esig0(j-1,imed) = sigma - esig1(j-1,imed)*loge;
                ebr11(j-1,imed) = (wbrem - wbrem_old)*eke1(imed);
                ebr10(j-1,imed) = wbrem - ebr11(j-1,imed)*loge;
                IF( sigma/dedx < sigma_old/dedx_old ) is_monotone = .false.;
            ]
            dedx_old = dedx; sigm_old = sigm;
            sigma_old = sigma; wbrem_old = wbrem;
        ]
        ededx1(meke(imed),imed) = ededx1(meke(imed)-1,imed);
        ededx0(meke(imed),imed) = ededx0(meke(imed)-1,imed);
        esig1(meke(imed),imed) = esig1(meke(imed)-1,imed);
        esig0(meke(imed),imed) = esig0(meke(imed)-1,imed);
        ebr11(meke(imed),imed) = ebr11(meke(imed)-1,imed);
        ebr10(meke(imed),imed) = ebr10(meke(imed)-1,imed);
        $egs_info(*,'eii_init: for medium ',imed,' adjusted sige = ',
                sigma_max,' monotone = ',is_monotone);
        sig_ismonotone(0,imed) = is_monotone;
        esig_e(imed) = sigma_max;
    ]
]
return;

:eii-reading-error:
$egs_fatal(*,'I/O error while reading EII data');

:no-eii-file:
$egs_fatal('(//a,a,/a,/a/)','Failed to open EII data file ',$cstring(eii_file),
          'Make sure file exists in your $HEN_HOUSE/data directory!',
          '****BEWARE of case sensitive file names!!!');

return; end;

"*****************************************************************************"

subroutine eii_sample(ish,iZ,Uj);
implicit none;
$INTEGER ish,iZ;
$REAL    Uj;

$COMIN-EII-SAMPLE;

$REAL T,tau,tau1,tau12,tau2,p2,beta2,c1,c2,Wmax,xmax,fm_s,fm_h,prob_s,prob;
$REAL r1,r2,r3,wx,wxx,aux,frej;
real*8 peie,pese1,pese2,dcosth,h1;
$INTEGER iarg;
$REAL    eta,cphi,sphi;
$INTEGER np_save,ip,j;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;

/* calculate some useful constants */
peie = e(np);
T = peie - rm; tau = T/rm; tau1 = tau+1;
tau12 = tau1*tau1; tau2 = tau*tau; p2 = tau2 + 2*tau;
beta2 = p2/tau12;
"c1 = tau2/tau12; "
Wmax = 0.5*(T+Uj); xmax = Uj/Wmax;
c1 = (Wmax/peie)**2;
c2 = (2*tau+1)/tau12;
fm_s = log(rmt2*p2/Uj) - beta2 - 0.5;
prob_s = 0.66666667*fm_s*(1+xmax+xmax*xmax);
"fm_h = 1 + c1 - c2;"
fm_h = 2 + c1 - c2;
IF( fm_h < 1 ) fm_h = 1;
prob = fm_h + prob_s;

LOOP [
    $RANDOMSET r1; $RANDOMSET r2; $RANDOMSET r3;
    IF( r1*prob < fm_h ) [ "Use the hard collision cross section "
        wx = 1/(r2*xmax+1-r2); wxx = wx*xmax; aux = wxx/(2-wxx);
        frej = (1 + aux*(aux-c2)+c1*wxx*wxx)/fm_h;
    ] ELSE [               "Use the soft collision cross section "
        wx = 1/(r2*xmax**3+1-r2)**0.333333333;
        frej = 1 - log(wx)/fm_s;
    ]
] UNTIL ( r3 < frej );

wx = wx*Uj;

/* set-up new particles */
h1 = (peie + prm)/T; pese1 = peie - wx;
e(np) = pese1;
dcosth = h1*(pese1-prm)/(pese1+prm);
sinthe = dsqrt(1-dcosth); costhe = dsqrt(dcosth);
call uphi(2,1);

pese2 = wx - Uj + prm;
edep_local = 0;
IF( pese2 > ae(medium) ) [
    $CHECK-STACK(np+1,'eii_sample');
    np = np+1; e(np) = pese2;
    dcosth = h1*(pese2-prm)/(pese2+prm);
    sinthe = -dsqrt(1-dcosth); costhe = dsqrt(dcosth);
    iq(np) = -1; call uphi(3,2);
    edep = 0;
] ELSE [
    edep = wx - Uj;
    edep_local = edep;
    $AUSCALL($SELECTRONA);
]
"ish ranges from 1 to 4 for K,L1,L2,L3 shells"
call relax(Uj,ish,iZ);

IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); ]

/*
IF( nbr_split > 1 ) [
    np_save = np;
    DO ip=NPold+1,np_save [
        IF( iq(ip) = 0 ) [
            wt(ip) = wt(ip)/nbr_split;
            DO j = 1,nbr_split-1 [
                np = np + 1; $CHECK-STACK(np,'eii_sample');
                iq(np) = 0; e(np) = e(ip);
                $TRANSFER PROPERTIES TO (np) FROM (ip);
                $RANDOMSET eta; eta = 2*eta - 1; w(np) = eta;
                eta = (1-eta)*(1+eta);
                IF( eta > 1e-20 ) [
                    eta = Sqrt(eta);
                    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
                    u(np) = eta*cphi; v(np) = eta*sphi;
                ] ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
            ]
        ]
    ]
]
*/


return; end;

"============================================================================"
subroutine egs_scale_photon_xsection(imed,fac,which);
"============================================================================"
"
"  Scale the photon cross section 'which' by factor fac for medium imed.
"  which = 0 for all cross sections
"        = 1 for Rayleigh scattering
"        = 2 for Compton scattering
"        = 3 for Pair production
"        = 4 for photo-absorption
"  If imed = 0, scaling is done for all media.
"============================================================================"
implicit none;
$INTEGER imed,which;
$REAL    fac;
$declare_max_medium;
;COMIN/MEDIA,PHOTIN,EGS-IO/;
$INTEGER ifirst,ilast,medium,j;
$LOGICAL has_r;
$REAL    gle,gmfp,gbr1,gbr2,cohfac,aux,gmfp_old,gbr1_old,gbr2_old,cohfac_old;
character*8 strings(5);
data       strings/'photon','Rayleigh','Compton','pair','photo'/;

IF( which < 0 | which > 4 ) [ return; ]
IF( imed > 0 & imed <= nmed ) [ ifirst = imed; ilast = imed; ]
ELSE [ ifirst = 1; ilast = nmed; ]
IF( which = 1 ) [
    has_r = .false.;
    DO medium = ifirst, ilast [
        IF( iraylm(medium) = 1 ) [ has_r = .true.; ]
    ]
    IF( ~has_r ) return;
]
$egs_info(*,' ');
DO medium = ifirst,ilast [

    $egs_info('(a,a,a,i3,a,f9.5)',
            'Scaling ',strings(which+1),' x-section data for medium',
            medium,' with ',fac);

    DO j = 1,mge(medium) [

        gle = (j - ge0(medium))/ge1(medium);
        gmfp = gmfp0(j,medium) + gmfp1(j,medium)*gle;
        gbr1 = gbr10(j,medium) + gbr11(j,medium)*gle;
        gbr2 = gbr20(j,medium) + gbr21(j,medium)*gle;
        IF( iraylm(medium) = 1 ) [
            cohfac = cohe0(j,medium) + cohe1(j,medium)*gle;
        ] ELSE [ cohfac = 1; ]
        IF( which = 0 ) [ gmfp = gmfp/fac; ]
        ELSE IF( which = 1 ) [ cohfac = cohfac/(fac*(1-cohfac)+cohfac); ]
        ELSE [
            IF( which = 2 ) [
                aux = fac*(gbr2-gbr1) + gbr1 + 1 - gbr2;
                gbr2 = (gbr1 + fac*(gbr2-gbr1))/aux; gbr1 = gbr1/aux;
            ]
            ELSE IF( which = 3 ) [
                aux = fac*gbr1 + 1 - gbr1;
                gbr2 = (fac*gbr1 + gbr2-gbr1)/aux; gbr1 = fac*gbr1/aux;
            ]
            ELSE [
                aux = gbr2 + fac*(1-gbr2);
                gbr1 = gbr1/aux; gbr2 = gbr2/aux;
            ]
            gmfp = gmfp/aux;
            cohfac = cohfac*aux/(aux*cohfac + 1 - cohfac);
        ]
        IF( j > 1 ) [
            gmfp1(j-1,medium) = (gmfp - gmfp_old)*ge1(medium);
            gmfp0(j-1,medium) = gmfp - gmfp1(j-1,medium)*gle;
            gbr11(j-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
            gbr10(j-1,medium) = gbr1 - gbr11(j-1,medium)*gle;
            gbr21(j-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
            gbr20(j-1,medium) = gbr2 - gbr21(j-1,medium)*gle;
            cohe1(j-1,medium) = (cohfac - cohfac_old)*ge1(medium);
            cohe0(j-1,medium) = cohfac - cohe1(j-1,medium)*gle;
        ]
        gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohfac_old = cohfac;

    ]
    gmfp1(mge(medium),medium) = gmfp1(mge(medium)-1,medium);
    gmfp0(mge(medium),medium) = gmfp0(mge(medium)-1,medium);
    gbr11(mge(medium),medium) = gbr11(mge(medium)-1,medium);
    gbr10(mge(medium),medium) = gbr10(mge(medium)-1,medium);
    gbr21(mge(medium),medium) = gbr21(mge(medium)-1,medium);
    gbr20(mge(medium),medium) = gbr20(mge(medium)-1,medium);
    cohe1(mge(medium),medium) = cohe1(mge(medium)-1,medium);
    cohe0(mge(medium),medium) = cohe0(mge(medium)-1,medium);
]

return; end;

/*============================================================================

 Subroutines to initialize photon cross section data.
 The data is read from string_photo.data, string_pair.data,
 string_triplet.data, and string_rayleigh.data, where string is the argument
 passed to the subroutine.

============================================================================*/

REPLACE {$OPEN-UNIT(#,#,#);} WITH {
    {P1} = {P2};
    {P1} = egs_get_unit({P1});
    IF( {P1} < 1 ) [
        $egs_fatal(*,
         'egs_init_user_photon: failed to get a free Fortran I/O unit');
    ]
    tmp_string = {P3};
    open({P1},file={P3},status='old',err=:no-user-data-file:);
};

REPLACE {$MXINPUT} WITH {2000};
REPLACE {$MXBCINP} WITH {183};

"============================================================================="
"Ali:photonuc, 1 line"
 subroutine egs_init_user_photon(prefix,comp_prefix,photonuc_prefix,out);
"subroutine egs_init_user_photon(prefix,comp_prefix,out);"
"============================================================================="
implicit none;
$declare_max_medium;
character*(*) prefix, comp_prefix,
"Ali:photonuc, 1 line"
              photonuc_prefix;
$INTEGER      out;
;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,COMPTON-DATA,X-OPTIONS/;
$INTEGER   lnblnk1,egs_get_unit,medium,
           photo_unit,pair_unit,rayleigh_unit,triplet_unit,
           ounit,egs_open_file,compton_unit,
"Ali:photonuc, 1 line"
           photonuc_unit;
$INTEGER   nge,sorted($MXEL),i,j,k,iz,iz_old,ndat;
$REAL      z_sorted($MXEL),pz_sorted($MXEL);
$REAL      sig_photo($MXGE),sig_pair($MXGE),sig_triplet($MXGE),
           sig_rayleigh($MXGE),sig_compton($MXGE);
$REAL      sigma,cohe,gmfp,gbr1,gbr2,sig_KN,gle,e,sig_p;
$REAL      cohe_old,gmfp_old,gbr1_old,gbr2_old,
"Ali:photonuc, 3 lines"
           sig_photonuc($MXGE),
           photonuc,
           photonuc_old;

$REAL      etmp($MXINPUT),ftmp($MXINPUT);
$REAL      sumZ,sumA,con1,con2,egs_KN_sigma0;
$REAL      bc_emin,bc_emax,bc_dle,bc_data($MXBCINP),bc_tmp($MXBCINP),bcf,aj;
$INTEGER   bc_ne;
$LOGICAL   input_compton_data,
"Ali:photonuc, 1 line"
           input_photonuc_data;
character  data_dir*128,photo_file*140,pair_file*140,rayleigh_file*144,
           triplet_file*142,tmp_string*144,compton_file*144,
"Ali:photonuc, 1 line"
           photonuc_file*144;

$egs_info('(/a$)','(Re)-initializing photon cross sections');
$egs_info('(a,a/)',' with files from the series: ',
      prefix(:lnblnk1(prefix)));

$egs_info('(a,a)',' Compton cross sections: ',$cstring(comp_prefix));

"Ali:photonuc, 1 block"
IF(iphotonuc = 1) [
 $egs_info('(a,a)',' Photonuclear cross sections: ',
 $cstring(photonuc_prefix));
 input_photonuc_data = .false.;
 IF(lnblnk1(photonuc_prefix) > 0 & photonuc_prefix(1:7) ~= 'default') [
   input_photonuc_data = .true.;
 ]
]

input_compton_data = .false.;
IF( ibcmp(1) > 1 & lnblnk1(comp_prefix) > 0 ) [
    IF( comp_prefix(1:7) ~= 'default' ) input_compton_data = .true.;
]
data_dir = $cstring(hen_house) // 'data' // $file_sep;
photo_file = $cstring(data_dir) // $cstring(prefix) // '_photo.data';
pair_file = $cstring(data_dir) // $cstring(prefix) // '_pair.data';
triplet_file = $cstring(data_dir) // $cstring(prefix) // '_triplet.data';
rayleigh_file = $cstring(data_dir) // $cstring(prefix) // '_rayleigh.data';
IF( input_compton_data ) [
    compton_file = $cstring(data_dir) // $cstring(comp_prefix) //
                   '_compton.data';
]
ELSE [
    compton_file = $cstring(data_dir) // 'compton_sigma.data';
]
"Ali: I moved this info line from inside the IF statement
" because it's useful to print the cross section file either way
$egs_info('(a,a)',' Using Compton cross sections from ',
          $cstring(compton_file));

"Ali:photonuc, 1 block"
IF(iphotonuc = 1) [
 IF( input_photonuc_data ) [
    photonuc_file = $cstring(data_dir) // $cstring(photonuc_prefix) //
                    '_photonuc.data';
 ]
 ELSE [
    photonuc_file = $cstring(data_dir) // 'iaea_photonuc.data';
 ]
 $egs_info('(a,a)',' Using photonuclear cross sections from ',
  $cstring(photonuc_file));
]

$OPEN-UNIT(photo_unit,83,photo_file);
$OPEN-UNIT(pair_unit,84,pair_file);
$OPEN-UNIT(triplet_unit,85,triplet_file);
$OPEN-UNIT(rayleigh_unit,86,rayleigh_file);
IF( ibcmp(1) > 1 ) [ $OPEN-UNIT(compton_unit,88,compton_file); ]
" Note: ibcmp > 1 means the user wants to use Bound Compton scattering "
"       without rejections. For this we have to use the actual bound   "
"       Compton scattering cross section, which is now available in a  "
"       file called bound_compton.data (the file actually contains the "
"       ratio of the Bound Compton to the KN cross section).           "
"       Because this option is not available on a region by region     "
"       basis, we just need to check ibcmp(1)                          "
"Ali:photonuc, 1 line"
IF( iphotonuc = 1 ) [ $OPEN-UNIT(photonuc_unit,89,photonuc_file); ]

IF( out = 1 ) [
    ounit = egs_open_file(87,0,1,'.xsections');
    write(ounit,'(/a,a,a)') 'Photon cross sections initialized from ',
       $cstring(prefix),' data files';
    write(ounit,'(a,/)')
'============================================================================';
    write(ounit,'(a,/)') 'Grid energies and cross sections are output';
"Ali:photonuc, 1 block"
    IF(iphotonuc = 1) [
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a)')
         'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ',
         ' GMFP(cm) ';
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a/)')
         '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh',
         'w/ Ray + photnuc';
    ]
    ELSE[
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a)')
            'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ';
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a/)')
            '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh';
   ]
]
/* Replace binding energies with the edges in the photo-absorption file */
DO iz=1,100 [
    read(photo_unit,*) ndat;
    read(photo_unit,*) (etmp(k),ftmp(k),k=1,ndat);
    k = 0;
    DO j=ndat,2,-1 [
        IF( etmp(j)-etmp(j-1) < 1e-5 ) [
            k = k+1;
            IF ( k <= $MXSHXSEC )[
               binding_energies(k,iz) = exp(etmp(j));
            ]
            ELSE[
              $egs_fatal('(i3,a,i3,//a)',
                         k,' binding energies read exceeding array size of',
                         $MXSHXSEC,'Increase $MXSHXSEC in egsnrc.macros!');
            ]
            IF( ~eadl_relax & k >= 4 ) EXIT;
        ]
    ]
]

IF (mcdf_pe_xsections)[call egs_read_shellwise_pe();]

DO medium = 1,nmed [

    mge(medium) = $MXGE; nge = $MXGE;
    ge1(medium) = nge-1; ge1(medium) = ge1(medium)/log(up(medium)/ap(medium));
    ge0(medium) = 1 - ge1(medium)*log(ap(medium));

    $egs_info('(a,i3,a,$)',' Working on medium ',medium,' ... ');
    IF( out = 1 ) [
        write(ounit,'(/,2x,a,i3,a,24a1/)') 'Medium ',medium,': ',
          (media(k,medium),k=1,24);
    ]
    /sumZ,sumA/ = 0;
    DO i=1,nne(medium) [
        z_sorted(i) = zelem(medium,i);
        sumZ = sumZ + pz(medium,i)*zelem(medium,i);
        sumA = sumA + pz(medium,i)*wa(medium,i);
    ]
    con1 = sumZ*rho(medium)/(sumA*1.6605655);
    con2 = rho(medium)/(sumA*1.6605655);
    call egs_heap_sort(nne(medium),z_sorted,sorted);
    DO i=1,nne(medium) [ pz_sorted(i) = pz(medium,sorted(i)); ]

    IF (mcdf_pe_xsections)[
       call egsi_get_shell_data(medium,nge,nne(medium),z_sorted,pz_sorted,
                                ge1(medium),ge0(medium),sig_photo);
    ]
    ELSE[
       call egsi_get_data(0,photo_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_photo);
    ]
    call egsi_get_data(0,rayleigh_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_rayleigh);
    call egsi_get_data(1,pair_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_pair);
    call egsi_get_data(2,triplet_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_triplet);
"Ali:photonuc, 1 block"
    IF( iphotonuc = 1 ) [
      call egsi_get_data(3,photonuc_unit,nge,nne(medium),z_sorted,pz_sorted,
                        ge1(medium),ge0(medium),sig_photonuc);
    ]

    IF( ibcmp(1) > 1 ) [
        "Get the bound compton cross section data"
        IF( input_compton_data ) [
            call egsi_get_data(0,compton_unit,nge,nne(medium),
                    z_sorted,pz_sorted,ge1(medium),ge0(medium),
                    sig_compton);
        ]
        ELSE [
            rewind(compton_unit);
            read(compton_unit,*) bc_emin,bc_emax,bc_ne;
            IF( bc_ne > $MXBCINP ) [
              $egs_fatal(*,'Number of input Compton data exceeds array size');
            ]
            "write(6,*) 'bc emin,emax,ne = ',bc_emin,bc_emax,bc_ne;
            bc_dle = log(bc_emax/bc_emin)/(bc_ne-1);
            DO j=1,bc_ne [ bc_data(j) = 0; ]
            iz_old = 1;
            DO i=1,nne(medium) [
                iz = int(z_sorted(i)+0.5);
                "write(6,*) ' reading bc data for ',iz;
                DO j=iz_old,iz [ read(compton_unit,*) (bc_tmp(k),k=1,bc_ne); ]
                DO j=1,bc_ne [
                    bc_data(j)=bc_data(j)+pz_sorted(i)*z_sorted(i)*bc_tmp(j);
                ]
                iz_old = iz+1;
            ]
            DO j=1,bc_ne [ bc_data(j)=log(bc_data(j)/sumZ); ]
        ]
    ]

    /* prepare data needed for Rayleigh scattering sampling */
    call egs_init_rayleigh(medium,sig_rayleigh);

    DO i=1,nge [

        gle = (i - ge0(medium))/ge1(medium); e = exp(gle);
        sig_KN = sumZ*egs_KN_sigma0(e);
        IF( ibcmp(1) > 1 ) [
            IF( input_compton_data ) [
                sig_KN = sig_compton(i);
            ]
            ELSE [
                "Apply the bound Compton correction to sig_KN"
                IF( e <= bc_emin ) [ bcf = exp(bc_data(1)); ]
                ELSE IF( e < bc_emax ) [
                    aj = 1 + log(e/bc_emin)/bc_dle;
                    j = int(aj); aj = aj - j;
                    bcf = exp(bc_data(j)*(1-aj) + bc_data(j+1)*aj);
                ]
                ELSE [ bcf = 1; ]
                sig_KN = sig_KN*bcf;
                "write(6,*) 'e = ',e,' bcf = ',bcf;
            ]
        ]
        sig_p  = sig_pair(i) + sig_triplet(i);
        sigma  = sig_KN + sig_p + sig_photo(i);
        gmfp   = 1/(sigma*con2);
        gbr1   = sig_p/sigma;
        gbr2   = gbr1 + sig_KN/sigma;
        cohe   = sigma/(sig_rayleigh(i) + sigma);
"Ali:photonuc, 1 line"
        photonuc = sigma/(sig_photonuc(i) + sigma);

        IF( out = 1 ) [
"Ali:photonuc, 1 block"
           IF(iphotonucm(medium) = 1) [
              write(ounit,'(6(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,
              gmfp*cohe,gmfp*cohe*photonuc;
           ]
           ELSE[
              write(ounit,'(5(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,gmfp*cohe;
           ]
        ]
        IF( i > 1 ) [
            gmfp1(i-1,medium) = (gmfp - gmfp_old)*ge1(medium);
            gmfp0(i-1,medium) =  gmfp - gmfp1(i-1,medium)*gle;
            gbr11(i-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
            gbr10(i-1,medium) =  gbr1 - gbr11(i-1,medium)*gle;
            gbr21(i-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
            gbr20(i-1,medium) =  gbr2 - gbr21(i-1,medium)*gle;
            cohe1(i-1,medium) = (cohe - cohe_old)*ge1(medium);
            cohe0(i-1,medium) =  cohe - cohe1(i-1,medium)*gle;
"Ali:photonuc, 2 lines"
            photonuc1(i-1,medium) = (photonuc - photonuc_old)*ge1(medium);
            photonuc0(i-1,medium) =  photonuc - photonuc1(i-1,medium)*gle;
        ]
        gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohe_old = cohe;
"Ali:photonuc, 1 line"
        photonuc_old = photonuc;
    ]

    gmfp1(nge,medium) = gmfp1(nge-1,medium);
    gmfp0(nge,medium) = gmfp - gmfp1(nge,medium)*gle;
    gbr11(nge,medium) = gbr11(nge-1,medium);
    gbr10(nge,medium) = gbr1 - gbr11(nge,medium)*gle;
    gbr21(nge,medium) = gbr21(nge-1,medium);
    gbr20(nge,medium) = gbr2 - gbr21(nge,medium)*gle;
    cohe1(nge,medium) = cohe1(nge-1,medium);
    cohe0(nge,medium) = cohe - cohe1(nge,medium)*gle;
"Ali:photonuc, 2 lines"
    photonuc1(nge,medium) = photonuc1(nge-1,medium);
    photonuc0(nge,medium) = photonuc - photonuc1(nge,medium)*gle;

    $egs_info('(a)','OK');
]

close(photo_unit); close(pair_unit);
close(triplet_unit); close(rayleigh_unit);
"Ali:photonuc, 1 line"
IF( iphotonuc = 1 ) [ close(photonuc_unit);]
IF( ibcmp(1) > 1 ) [ close(compton_unit);]
IF( out = 1 )      [ close(ounit); ]
return;

:no-user-data-file:;
$egs_fatal('(//a,a)','Failed to open data file ',$cstring(tmp_string));

return; end;

/*********************************************************************/
subroutine egs_init_rayleigh(medium,sig_rayleigh);
/*********************************************************************
 This routine is called after Rayleigh data has been read from one of
 the available data bases (si, xcom, epdl). Therefore total Rayleigh
 xsections are already available. Here one reads in either custom FF
 for a medium or builds the FF using the atomic FF (default) and the
 IAM (Independent Atom Model). The total Rayleigh xsection must also
 be calculated for the media with user-supplied FF.
 *********************************************************************/
$IMPLICIT-NONE;
$declare_max_medium;
;COMIN/THRESH,          "for threshold energies"
       EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
       rayleigh_inputs,rayleigh_sampling/;

$REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
$REAL xsc, fsc;
$REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
$REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
$REAL totRayleigh2,pzmin;
$REAL emin, emax;
$INTEGER i,j,k,ff_unit, egs_get_unit, ne;
$INTEGER lnblnk1, EOF, nff, medium, ncustom;
character dummy*24, afac_file*128, ff_file*128;

IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"

/*****************************************************************
   Figure out if custom ff needed for medium: check that medium
   is in the list iray_ff_media, else the default atomic ff used.
   This used to be done in subroutine get_transport_parameter
   but was moved here, since it is up to the the user-code to
   read in the information and it is not ensured that the media
   information will be read before getting the transport parameters.
****************************************************************/
ncustom=0;write(dummy,'(24a1)')(media(j,medium),j=1,24);ff_file=' ';
DO i=1,$MXMED[IF(lnblnk1(iray_ff_file(i))~=0)[ncustom = ncustom + 1;]]
DO i=1,ncustom[IF (dummy(:lnblnk1(dummy)) = iray_ff_media(i))[
   ff_file = iray_ff_file(i);
];]

/* Open a fortran unit for reading form factors */
ff_unit = egs_get_unit(0);
IF( ff_unit < 1 ) [
   $egs_fatal(*,
   'egs_init_rayleigh: failed to get a free Fortran I/O unit');
]

/***********************************************************
   Read the FF and calculate the xsections for the custom FF
   or calculate the FF for a molecule using the IAM in the
   atomic case.
 ***********************************************************/
IF ( lnblnk1(ff_file) > 0) ["custom FF requested"
     open(ff_unit,file=$cstring(ff_file),
          status='old',err=:no-ff-file:);
     GOTO :read-ff:;
     :no-ff-file:
     $egs_fatal('(2a)','egs_init_rayleigh: failed to open custom ff file ',
             $cstring(ff_file));
     :read-ff:
     $egs_info('(/2a)','Opened custom ff file ',$cstring(ff_file));
     " read Rayleigh molecular form factor data from a file"
     " which is given as Fmol/sqrt(MW) hence no need to compute"
     " MW to get the xsections in cm-1. See conv variable below"
     j = 0;
     LOOP [
       j = j + 1;
       read(ff_unit,*,IOSTAT = EOF) xsc, fsc;
       IF (EOF < 0) EXIT;
       IF (j <= $MXRAYFF)[xgrid(j,medium)=xsc;ff(j,medium)=fsc;]
     ] REPEAT
     nff = j-1;
     IF (nff > $MXRAYFF)[
        $egs_fatal('(a,/,a,i5,a,i5,/,a)',
        'subroutine egs_init_rayleigh: form factors size too small!!',
        '$XRAYFF =  ', $MXRAYFF,', and need to be ',nff,
        ' and try again!!!');
     ]
     "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
     "and much less for higher energies"
     IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
     write(*,*) '\n  -> ', nff, ' values of mol. ff read!';
     /* Now calculate Rayleigh xsections */
     "Since MW already included in the molecular FF,"
     "must multiply by sumA which is MW for compound"
     "or unity for mixtures."
     sumA = 0.0;
     DO j=1,nne(medium)[sumA=sumA+PZ(medium,j)*WA(medium,j);]
     DO j=1,MGE(medium) [
       gle=(j-GE0(medium))/GE1(medium);e=exp(gle);
       sig_rayleigh(j)=egs_rayleigh_sigma(medium,e,nff,
                       xgrid(1,medium),ff(1,medium))*sumA;
     ]
]
ELSE[
     $set_string(afac_file,' ');
     afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
     open(ff_unit,file=$cstring(afac_file),
       status='old',err=:no-afac-file:);
     GOTO :read-afac:;
     :no-afac-file:
     $egs_fatal('(2a)','egs_init_rayleigh: failed to open atomic ff file',
             $cstring(afac_file));
     :read-afac:
     " read Rayleigh atomic form factor data from a file"
     read(ff_unit,*) xval, aff;
     "calculate form factor using independent atom model"
     DO i=1,$MXRAYFF[
       ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
       DO j=1,nne(medium)[
        ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
       ]
       ff(i,medium) = sqrt(ff(i,medium));
     ]
     nff = $MXRAYFF;
     "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
     "and much less for higher energies"
     IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
     $egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');
]
close(ff_unit);
/* call routine for preparing sampling data */
/* The following is inconsistent with the $SET INTERVAL macro. IK, July 21 2009
   This is because the actual min/max energy of the interpolation
   grid coming from PEGS might be lower/higher than ap/up.
   The medium specific constants ge0(medium) and ge1(medium) come
   from PEGS => one has to use those to find the actual emin/emax.
   If not done that way, the tabulated data will be inconsistent
   with the $SET INTERVAL macro.
call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
                             mge(medium),ap(medium),up(medium),
                             pe_array(1,medium),$RAYCDFSIZE,
                             fcum(1,medium),i_array(1,medium),
                             b_array(1,medium),c_array(1,medium));
*/
emin = exp((1 - ge0(medium))/ge1(medium));
emax = exp((mge(medium) - ge0(medium))/ge1(medium));
call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
                             mge(medium),emin,emax,
                             pe_array(1,medium),$RAYCDFSIZE,
                             fcum(1,medium),i_array(1,medium),
                             b_array(1,medium),c_array(1,medium));

/* prepare coefficients for pmax interpolation */
ne=MGE(medium);dle=log(up(medium)/ap(medium))/(ne-1);
dlei=1/dle;
DO i=1,ne-1 [
   /*  The stuff below is inconsistent with the
       $SET INTERVAL macro (see above) IK, July 21 2009
   gle = log(ap(medium)) + dle*(i-1);
   pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*dlei;
   pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
   */
   gle = (i - ge0(medium))/ge1(medium);
   pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
   pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
]
pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);

return; end;

/*********************************************************************/
subroutine egs_init_rayleigh_sampling(medium);
/*********************************************************************
 This routine is called from HATCH if user requested to use the photon
 xsection data from the pegs4 file. Here one reads in atomic FF and
 builds the FF using the IAM (Independent Atom Model).
 *********************************************************************/
$IMPLICIT-NONE;
$declare_max_medium;
;COMIN/THRESH,          "for threshold energies"
       EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
       rayleigh_inputs,rayleigh_sampling/;

$REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
$REAL xsc, fsc;
$REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
$REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
$REAL totRayleigh2,pzmin;
$REAL emin, emax;
$INTEGER i,j,k,ff_unit, egs_get_unit, ne;
$INTEGER lnblnk1, EOF, nff, medium, ncustom;
character dummy*24, afac_file*128, ff_file*128;

IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"

/* Open a fortran unit for reading form factors */
ff_unit = egs_get_unit(0);
IF( ff_unit < 1 ) [
   $egs_fatal(*,
   'egs_init_rayleigh: failed to get a free Fortran I/O unit');
]

$set_string(afac_file,' ');
afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
open(ff_unit,file=$cstring(afac_file),status='old',err=:no-afac-file:);
GOTO :read-afac:;
:no-afac-file:
$egs_fatal('(2a)',
        'egs_init_rayleigh_sampling: failed to open atomic ff file ',
        $cstring(afac_file));
:read-afac:
" read Rayleigh atomic form factor data from a file"
read(ff_unit,*) xval, aff;
"calculate form factor using independent atom model"
DO i=1,$MXRAYFF[
  ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
  DO j=1,nne(medium)[
   ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
  ]
  ff(i,medium) = sqrt(ff(i,medium));
]
nff = $MXRAYFF;
"To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
"and much less for higher energies"
IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
"write(*,*) '\n  -> ', nff, ' atomic ff values computed!';
$egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');

close(ff_unit);
/* call routine for preparing sampling data */
emin = exp((1 - ge0(medium))/ge1(medium));
emax = exp((mge(medium) - ge0(medium))/ge1(medium));
call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
                             mge(medium),emin,emax,
                             pe_array(1,medium),$RAYCDFSIZE,
                             fcum(1,medium),i_array(1,medium),
                             b_array(1,medium),c_array(1,medium));

/* prepare coefficients for pmax interpolation */
ne=MGE(medium);
DO i=1,ne-1 [
   gle = (i - ge0(medium))/ge1(medium);
   pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
   pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
]
pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);

return; end;

/**********************************************************
   Analytic expression of the Rayleigh xsection in barns.
 **********************************************************/
$REAL function egs_rayleigh_sigma(imed,E,ndat,x,f);
$IMPLICIT-NONE;
$INTEGER i, j, k,imed, ndat;
$REAL hc2,conv,b,hc;
parameter (hc  = 0.0123984768438,  "[Armstrong]*[MeV]"
           hc2 = 0.0001537222280); "h*c squared"
$REAL x($MXRAYFF), f($MXRAYFF), zero, E, xmax;
real*8 x1,x2,pow_x1,pow_x2,raysig,C,C2,f1,f2;
C=2.*hc2/(E*E);C2=C*C;xmax=E/hc;
egs_rayleigh_sigma = 0.0;
DO i=1,ndat-1[
   IF (x(i) = 0.0) x(i) = zero();IF (x(i+1) = 0.0) x(i+1) = zero();
   IF (f(i) = 0.0) f(i) = zero(); IF (f(i+1) = 0.0) f(i+1) = zero();
   b = log(f(i+1)/f(i))/log(x(i+1)/x(i));
   x1=x(i);x2=x(i+1);IF(x2 > xmax) [x2=xmax;]
   pow_x1=x1**(2*b);pow_x2=x2**(2*b);
   raysig = pow_x2*(x2**2/(b+1)-(C*x2**4)/(b+2)+(C2*x2**6)/(2*b+6));
   raysig = raysig - pow_x1*(x1**2/(b+1)-(C*x1**4)/(b+2)+(C2*x1**6)/(2*b+6));
   raysig = raysig*f(i)*f(i)/pow_x1;
   egs_rayleigh_sigma = egs_rayleigh_sigma + raysig;
   IF(x(i+1)>xmax)[EXIT;]"exit loop"
]
/*totRayleigh = 2.*Pi*R02*1E24*C*totRayleigh;"in barns"
 2*Pi*Ro^2*1E24 = 0.49893439187842413747
 */
egs_rayleigh_sigma = 0.49893439187842413747*C*egs_rayleigh_sigma;"in barns"
return;
end;
/******************************************************
   Rayleigh run time sampling routine
 *******************************************************/
subroutine egs_rayleigh_sampling(medium,e,gle,lgle,costhe,sinthe);
$IMPLICIT-NONE;
$declare_max_medium;
real*8 e;
$REAL gle,costhe,sinthe,pmax,xv,xmax,csqthe;
$REAL rnnray1,rnnray0,hc_i,twice_hc2,dwi;
parameter(hc_i=80.65506856998,      "h*c inverse"
          twice_hc2=0.000307444456);"2*(hc)^2"
          "h*c=0.0123984768438 [Armstrong]*[MeV]"
$INTEGER lgle,ib,ibin,medium, trials;
;COMIN/RANDOM,rayleigh_sampling/;
dwi = $RAYCDFSIZE-1;
$EVALUATE pmax USING pmax(gle);xmax = hc_i*e;
LOOP [
    $RANDOMSET rnnray1;
    LOOP [
        $RANDOMSET rnnray0; rnnray0 = rnnray0*pmax;
        ibin = 1 + rnnray0*dwi; /* rnno = rnno + 1 - ibin; */
        ib = i_array(ibin,medium);
        IF( i_array(ibin+1,medium) > ib ) [
          LOOP [IF(rnnray0<fcum(ib+1,medium)) EXIT; ib=ib+1;]
        ]
        rnnray0 = (rnnray0 - fcum(ib,medium))*c_array(ib,medium);
        xv = xgrid(ib,medium)*exp(log(1+rnnray0)*b_array(ib,medium));
    ] UNTIL (xv < xmax);
    xv = xv/e;
    costhe = 1 - twice_hc2*xv*xv;csqthe=costhe*costhe;
] UNTIL ( 2*rnnray1 < 1 + csqthe );
sinthe=sqrt(1.0-csqthe);
return;
end;
/******************************************************
   Prepares Rayleigh run time sampling data
 *******************************************************/
subroutine prepare_rayleigh_data(ndat,x,f,
                                 ne,emin,emax,pe_array,
                                 ncbin,fcum,i_array,
                                 b_array,c_array);
$IMPLICIT-NONE;

/******* input F (form factor) data ********************************/
$INTEGER    ndat;         " number of F data points "
$REAL       x(ndat),      " x values of F data "
            f(ndat);      " F data "

/******* energy range to initialize ********************************/
$INTEGER    ne;           " number of energy bins "
$REAL       emin,         " minimum photon energy (i.e. AP(medium))"
            emax,         " maximum photon energy (i.e. UP(medium))"
            pe_array(ne); " integral over F^2 from 0 to xmax(E)    "
                          " i.e., pe_array(E) = fcum(xmax(E))      "


/******* cumulative distribution **********************************/
$INTEGER    ncbin;          " number of cumulative bins (input)"
$REAL       fcum(ndat);     " cumulative distribution (output)"
$INTEGER    i_array(ncbin); " original data bin in which the i'th "
                            " cumulative bin edge falls.          "

/******* sampling data ********************************************/
$REAL       b_array(ndat),  " F interpolation coefficient "
            c_array(ndat);  " needed for sampling at run time "

$REAL zero;

real*8 sum0,a,b,x1,x2,pow_x1,pow_x2,dle,e,xmax,
       anorm,anorm1,anorm2,w,dw,xold,t,aux;
$INTEGER i,j,k,ibin;

;COMIN/USEFUL/;

write(*,'(a$)') '      preparing data for Rayleigh sampling ... ';

/* this to avoid NAN in the log(f(i)) below */
DO i=1,ndat [IF (f(i) = 0.0) f(i) = zero();]

/**********************************************************
 *
 * Calculate the cumulative distribution
 *
 *********************************************************/
sum0=0; fcum(1)=0;
DO i=1,ndat-1 [
    b = log(f(i+1)/f(i))/log(x(i+1)/x(i)); b_array(i) = b;
    x1 = x(i); x2 = x(i+1);
    pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
    sum0=sum0+f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
    fcum(i+1) = sum0;
]

/*************************************************************
 *
 * Now the maximum cumulative probability as a function of
 * incident photon energy. We have xmax = 2*E*20.60744/m, so
 * pe_array(E) = fcum(xmax)
 *
 **************************************************************/
dle = log(emax/emin)/(ne-1); i = 1;
DO j=1,ne [
    e = emin*exp(dle*(j-1)); xmax = 20.607544d0*2*e/prm;
    DO k=i,ndat-1 [
        IF( xmax >= x(k) & xmax < x(k+1) ) EXIT;
    ]
    i = k; b = b_array(i);
    x1 = x(i); x2 = xmax;
    pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
    pe_array(j) = fcum(i) +
      f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
]
i_array(ncbin) = i;

/***********************************************************************
 *
 * Now renormalize data so that pe_array(emax)=1
 * Note that we make pe_array(j) slightly larger so that fcum(xmax) is
 * never underestimated when interpolating
 *
 ***********************************************************************/
anorm = 1d0/sqrt(pe_array(ne));
anorm1 = 1.005d0/pe_array(ne);
anorm2 = 1d0/pe_array(ne);
DO j=1,ne [
    pe_array(j) = pe_array(j)*anorm1;
    IF( pe_array(j) > 1 ) pe_array(j) = 1;
]
DO j=1,ndat [
    f(j) = f(j)*anorm; fcum(j) = fcum(j)*anorm2;
    c_array(j) = (1+b_array(j))/(x(j)*f(j))**2;
]

/***********************************************************************
 *
 * Now prepare uniform cumulative bins
 *
 ***********************************************************************/
dw = 1d0/(ncbin-1);
xold = x(1); ibin = 1;
b = b_array(1);
pow_x1 = x(1)**(2*b);
i_array(1) = 1;
DO i=2,ncbin-1 [
    w = dw;
    LOOP [
        x1 = xold; x2 = x(ibin+1);
        t = x1*x1*x1**(2*b);
        pow_x2 = x2**(2*b);
        aux=f(ibin)*f(ibin)*(x2*x2*pow_x2-t)/((1+b)*pow_x1);
        IF( aux > w ) [
            xold = exp(log(t+w*(1+b)*pow_x1/f(ibin)/f(ibin))/(2+2*b));
            i_array(i) = ibin;
            EXIT;
        ]
        w = w - aux; xold = x2; ibin = ibin+1;
        b = b_array(ibin); pow_x1 = xold**(2*b);
    ]
]

/*************************************************************************
 *
 * Change definition of b_array because that's what is needed at run time
 *
 **************************************************************************/
DO j=1,ndat [ b_array(j) = 0.5/(1 + b_array(j)); ]


write(*,'(a /)') 'done';

return; end;

"============================================================================="
$REAL function egs_KN_sigma0(e);
"=========================================================================="
implicit none;
$REAL    e;
$REAL    con,ko,c1,c2,c3,eps1,eps2;
data     con/0.1274783851/;
;COMIN/USEFUL/;
ko = e/prm;
IF( ko < 0.01 ) [
    egs_KN_sigma0 = 8.*con/3.*(1-ko*(2-ko*(5.2-13.3*ko)))/prm;
    return;
]
c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
eps2 = 1; eps1 = 1./(1+2*ko);
egs_KN_sigma0 = (c1*(1./eps1-1./eps2)+c2*log(eps2/eps1)+eps2*(c3+0.5*eps2)-
                eps1*(c3+0.5*eps1))/e*con;
return; end;

"============================================================================="
$REAL function egs_KN_sigma1(e);
"=========================================================================="
implicit none;
$REAL    e;
$REAL    con,ko,c1,c2,c3,eps1,eps2;
data     con/0.1274783851/;
;COMIN/USEFUL/;
ko = e/prm; c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
eps2 = 1; eps1 = 1./(1+2*ko);
egs_KN_sigma1 = c1*(1./eps1-1./eps2);
egs_KN_sigma1 = egs_KN_sigma1 + log(eps2/eps1)*(c2 - c1) - c2*(eps2-eps1);
egs_KN_sigma1 = egs_KN_sigma1 + c3*(eps2-eps1)*(1-0.5*(eps1+eps2));
egs_KN_sigma1 = egs_KN_sigma1 +
         (eps2-eps1)*(0.5*(eps1+eps2)-(eps1*eps1+eps2*eps2+eps1*eps2)/3);
egs_KN_sigma1 = egs_KN_sigma1*con;
return; end;

"============================================================================="
subroutine egsi_get_data(flag,iunit,n,ne,zsorted,pz_sorted,ge1,ge0,data);
"=========================================================================="
implicit none;
COMIN/EGS-IO/;
$REAL    eth;
$INTEGER flag,iunit,n,ne;
$REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
$REAL    etmp($MXINPUT),ftmp($MXINPUT);
$REAL    gle,sig,p,e;
$INTEGER i,j,k,kk,iz,iz_old,ndat,iiz;

;COMIN/USEFUL/;

"Ali:photonuc. The whole routine is commented out and re-written
"to accommodate reading photonuclear cross sections. A copy of the
"commented original routine is at the bottom.
" flag = 0: photoelectric, Rayleigh, Compton
" flag = 1: pair
" flag = 2: triplet
" flag = 3: photonuclear

rewind(iunit);
iz_old = 0;
DO k=1,n [ data(k) = 0; ]
DO i=1,ne [
    iiz = int(zsorted(i)+0.5);
    DO iz=iz_old+1,iiz [
        read(iunit,*,err=:user-data-failure:) ndat;
        IF( ndat > $MXINPUT ) [
            $egs_fatal(*,'Too many input data points. Max. is ',$MXINPUT);
        ]
        IF( flag = 0 | flag = 3) [
            read(iunit,*,err=:user-data-failure:) (etmp(k),ftmp(k),k=1,ndat);
        ]
        ELSE [
            read(iunit,*,err=:user-data-failure:) (etmp(k+1),ftmp(k+1),
                k=1,ndat);
            IF( flag = 1 ) [ eth = 2*rm; ] ELSE [ eth = 4*rm; ]
            ndat = ndat + 1;
            DO k=2,ndat [
                ftmp(k) = ftmp(k) - 3*log(1-eth/exp(etmp(k)));
            ]
            ftmp(1) = ftmp(2); etmp(1) = log(eth);
        ]
    ]
    iz_old = iiz;
    DO k=1,n [
        gle = (k - ge0)/ge1; e = exp(gle);
        IF( gle < etmp(1) | gle >= etmp(ndat) ) [
            IF( flag = 0 ) [
                $egs_fatal(*,'Energy ',exp(gle),
                   ' is outside the available data range of ',
                   exp(etmp(1)),exp(etmp(ndat)));
            ]
            ELSEIF (flag = 1 | flag = 2) [
                IF( gle < etmp(1) ) [ sig = 0; ]
                ELSE [ sig = exp(ftmp(ndat)); ]
            ]
            ELSE [ "photonuclear, zero it before and after
             sig = 0;
            ]
        ] ELSE [
            DO kk=1,ndat-1 [
                IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
            ]
            IF( flag ~= 3) ["log/log interpolation"
               p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
               sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
            ]
            ELSE["lin/lin interpolation for photonuc"
               p = (e - exp(etmp(kk)))/(exp(etmp(kk+1)) - exp(etmp(kk)));
               sig = p*exp(ftmp(kk+1)) + (1-p)*exp(ftmp(kk));
            ]
        ]
        IF( (flag = 1 | flag = 2) & e > eth ) sig = sig*(1-eth/e)**3;
        data(k) = data(k) + pz_sorted(i)*sig;
    ]
]

return;

:user-data-failure:;
$egs_fatal(*,'Error while reading user photon cross sections from unit ',
     iunit);

return; end;

/*****************************************************************
   Prepare photoelectric cross section data base for medium imed
   on same energy grid as for the other photon interactions.
   Normalize elemental PE cross sections to medium cross section
   to use for selecting element the photon interacts with.
 *****************************************************************/
"============================================================================="
subroutine egsi_get_shell_data(imed,n,ne,zsorted,pz_sorted,ge1,ge0,data);
"=========================================================================="
implicit none;
$declare_max_medium;
;COMIN/EGS-IO,BREMPR,USEFUL,MEDIA,PE-SHELL-DATA/;
$INTEGER n,   "number of data points requested"
         ne,  "number of elements in medium"
         ndat;"number of data points from original grid"
$REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
$REAL    sigma($MXNE),sigmaMedium;
"$INTEGER sorted(*);
real*4    etmp($MXINPUT),ftmp($MXINPUT);
real*4    gle,sig,p;
$INTEGER i,j,k,kk,iz,zpos,imed;

DO k=1,n  [ data(k)  = 0;]
DO k=1,ne [ sigma(k) = 0;]
DO i=1,ne [
    iz = int(zsorted(i)+0.5);
    zpos = pe_zpos(iz); ndat = pe_nge(zpos);
    "Total cross sections for a given element"
    "on initial energy grid"
    DO k=1,ndat[
       pe_elem_prob(k,i,imed) = pz_sorted(i)*pe_xsection(k,zpos,0);
       "etmp(k) = log(pe_energy(k,zpos)); Done in egs_read_shellwise_pe
       etmp(k) = pe_energy(k,zpos);
       ftmp(k) = log(pe_xsection(k,zpos,0));
    ]
    "Total cross sections for a given element"
    "on requested energy grid"
    DO k=1,n [
        gle = (k - ge0)/ge1;
        IF( gle < etmp(1) | gle >= etmp(ndat) ) [
            $egs_fatal(*,'egsi_get_shell_data: Energy ',exp(gle),
                         ' is outside the available data range of ',
                         exp(etmp(1)),exp(etmp(ndat)));
        ] ELSE [
            "Find energy interval gle falls in"
            DO kk=1,ndat-1 [
                IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
            ]
            "log/log interpolation"
            p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
            sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
        ]
        data(k) = data(k) + pz_sorted(i)*sig;
        "data(k) = data(k) + pz(imed,sorted(i))*sig;
    ]
]
"Normalize elemental cross section to medium cross section"
"Prepare for log/log interpolation"
DO i=1,ne [
   iz = int(zsorted(i)+0.5);
   zpos = pe_zpos(iz); ndat = pe_nge(zpos);
   DO k=1,ndat[
      sig = sigmaMedium(imed,pe_energy(k,zpos));
      pe_elem_prob(k,i,imed) = log(pe_elem_prob(k,i,imed)/sig);
   ]
]

return; end;

/***************************************************************
   Calculate photoelectric cross section for medium imed using
   log/log linear interpolation and binary search to find energy
   interval
 ***************************************************************/
$REAL function sigmaMedium(imed, logE);

implicit none;
$declare_max_medium;
;COMIN/BREMPR,PE-SHELL-DATA/;
$REAL logE, slope, sigma;
$INTEGER k,imed,Z,zpos,m,ibsearch;

sigmaMedium = 0;
DO k=1,nne(imed) [
   Z = int( zelem(imed,k) + 0.5 );zpos = pe_zpos(Z);
   m = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
   slope = log(pe_xsection(m+1,zpos,0)/pe_xsection(m,zpos,0));
   slope = slope/(pe_energy(m+1,zpos)-pe_energy(m,zpos));
   sigma = log(pe_xsection(m,zpos,0));
   sigma += slope*(logE - pe_energy(m,zpos));
   sigma = exp(sigma);
   sigmaMedium += pz(imed,k)*sigma;
]
return; end;

"============================================================================="
subroutine egs_heap_sort(n,rarray,jarray);
"************************************************************************
"  egs_heap_sort will sort the real array rarray of dimension n in
"  ascending order and at the same time put into the integer array
"  jarray the original position of the elements, e.g.
"  if rarray was on input (5,14,8,2), it will be after completion
"  of heap_sort (2,5,8,14) and jarray will be (4,1,3,2).
"  heap_sort uses the heap sort algorithm, the implementation is
"  based  on hpsort from Numerical Recipies with a couple of
"  modifications.
"
"  Iwan Kawrakow, NRC, July 2001
"*************************************************************************

implicit none;

$INTEGER n,jarray(*);
$REAL    rarray(*);
$INTEGER i,ir,j,l,ira;
$REAL    rra;

DO i=1,n [ jarray(i)=i; ]
IF (n < 2) return;
l=n/2+1; ir=n;

LOOP [
   IF (l > 1)  [
       l=l-1; rra=rarray(l); ira=l;
   ]
   ELSE [
       rra=rarray(ir); ira=jarray(ir);
       rarray(ir)=rarray(1); jarray(ir)=jarray(1);
       ir=ir-1;
       IF (ir = 1) [
           rarray(1)=rra; jarray(1)=ira; return;
       ]
   ]
   i=l; j=l+l;
   LOOP [
       IF( j > ir ) EXIT;
       IF (j < ir) [ IF (rarray(j) < rarray(j+1) ) j=j+1; ]
       IF (rra < rarray(j)) [
           rarray(i)=rarray(j); jarray(i)=jarray(j);
           i=j; j=j+j;
       ] ELSE [ j=ir+1; ]
   ]
   rarray(i)=rra; jarray(i)=ira;
]
return; end;

%E
"Ali:photonuc, 1 subroutine"
"******************************************************************"
SUBROUTINE PHOTONUC;
"******************************************************************"
" Placeholder for photonuclear modelling. Currently the photon is
" discarded and its energy is thrown away (i.e. not deposited).
"******************************************************************"
$IMPLICIT-NONE;
$COMIN-PHOTONUC; "current default replacement is:
                 "COMIN/STACK,EPCONT,USEFUL/"
$DEFINE-LOCAL-VARIABLES-PHOTONUC; "currently empty"

npold = np; "set the old stack counter"
edep = pzero; e(np) = pzero; wt(np) = 0;

return;
end;
"******************************************************************"

%%
